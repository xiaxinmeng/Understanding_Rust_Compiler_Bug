{"sha": "b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZmYjQzYWIzZTU5YTBhNGQ5MDYzZGFlZDk2ODEyZWViNWE5ZmI0Nw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2002-07-02T22:20:33Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-07-02T22:20:33Z"}, "message": "cpp.texi: Update for traditional preprocessing changes.\n\n\t* doc/cpp.texi: Update for traditional preprocessing changes.\n\t* goc/cppopts.texi: Similarly.\n\nFrom-SVN: r55194", "tree": {"sha": "219fc2c5e94c8359756a707b9a23f7d0ca464355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/219fc2c5e94c8359756a707b9a23f7d0ca464355"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c680d2b66aedd245b38b6ac67f1bacd7f1619afd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c680d2b66aedd245b38b6ac67f1bacd7f1619afd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c680d2b66aedd245b38b6ac67f1bacd7f1619afd"}], "stats": {"total": 306, "additions": 219, "deletions": 87}, "files": [{"sha": "82d5964f06fc2e2b18c32237f1e90cfd835feb74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47", "patch": "@@ -1,3 +1,8 @@\n+2002-07-02  Neil Booth  <neil@daikokuya.co.uk>\n+\t\n+\t* doc/cpp.texi: Update for traditional preprocessing changes.\n+\t* goc/cppopts.texi: Similarly.\n+\n 2002-07-02  Ziemowit Laski  <zlaski@apple.com>\n \n \t* c-parse.in (designator): Enable designated initializers if ObjC."}, {"sha": "5b7d08ed1d1091c1e8b796aec1ed0849e15e3f3e", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 210, "deletions": 83, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47", "patch": "@@ -204,7 +204,7 @@ will be removed, and the Makefile will not work.\n \n Having said that, you can often get away with using cpp on things which\n are not C@.  Other Algol-ish programming languages are often safe\n-(Pascal, Ada, etc.) So is assembly, with caution.  @option{-traditional}\n+(Pascal, Ada, etc.) So is assembly, with caution.  @option{-traditional-cpp}\n mode preserves more white space, and is otherwise more permissive.  Many\n of the problems can be avoided by writing C or C++ style comments\n instead of native language comments, and keeping macros simple.\n@@ -275,8 +275,8 @@ warning message.\n \n @item\n @cindex trigraphs\n-If trigraphs are enabled, they are replaced by their corresponding\n-single characters.\n+@anchor{trigraphs}If trigraphs are enabled, they are replaced by their\n+corresponding single characters.\n \n These are nine three-character sequences, all starting with @samp{??},\n that are defined by ISO C to stand for single characters.  They permit\n@@ -1779,9 +1779,9 @@ In normal operation, this macro expands to the constant 1, to signify\n that this compiler conforms to ISO Standard C@.  If GNU CPP is used with\n a compiler other than GCC, this is not necessarily true; however, the\n preprocessor always conforms to the standard, unless the\n-@option{-traditional} option is used.\n+@option{-traditional-cpp} option is used.\n \n-This macro is not defined if the @option{-traditional} option is used.\n+This macro is not defined if the @option{-traditional-cpp} option is used.\n \n On some hosts, the system compiler uses a different convention, where\n @code{__STDC__} is normally 0, but is 1 if the user specifies strict\n@@ -1806,8 +1806,8 @@ The value @code{199409L} signifies the 1989 C standard as amended in\n the 1999 revision of the C standard.  Support for the 1999 revision is\n not yet complete.\n \n-This macro is not defined if the @option{-traditional} option is used, nor\n-when compiling C++ or Objective-C@.\n+This macro is not defined if the @option{-traditional-cpp} option is\n+used, nor when compiling C++ or Objective-C@.\n \n @item __STDC_HOSTED__\n This macro is defined, with value 1, if the compiler's target is a\n@@ -2141,13 +2141,15 @@ f (1\n f)\n @end smallexample\n \n-@noindent which expands to\n+@noindent\n+which expands to\n \n @smallexample\n 1 2 1 2\n @end smallexample\n \n-@noindent with the semantics described above.\n+@noindent\n+with the semantics described above.\n \n @node Macro Pitfalls\n @section Macro Pitfalls\n@@ -3334,91 +3336,225 @@ the directive name.\n \n Traditional (pre-standard) C preprocessing is rather different from\n the preprocessing specified by the standard.  When GCC is given the\n-@option{-traditional} option, it attempts to emulate a traditional\n-preprocessor.  We do not guarantee that GCC's behavior under\n-@option{-traditional} matches any pre-standard preprocessor exactly.\n+@option{-traditional-cpp} option, it attempts to emulate a traditional\n+preprocessor.\n \n-Traditional mode exists only for backward compatibility.  We have no\n-plans to augment it in any way nor will we change it except to fix\n-catastrophic bugs.  As of GCC 3.2, traditional mode is not supported for\n-compilation, only preprocessing.\n+GCC versions 3.2 and later only support traditional mode semantics in\n+the preprocessor, and not in the compiler.  This chapter outlines the\n+semantics we implemented in the traditional preprocessor that is\n+integrated into the compiler front end.\n \n-This is a list of the differences.  It may not be complete, and may not\n-correspond exactly to the behavior of either GCC or a true traditional\n-preprocessor.\n+The implementation does not correspond precisely to the behavior of\n+earlier versions of GCC, nor to any true traditional preprocessor.\n+After all, inconsistencies among traditional implementations were a\n+major motivation for C standardization.  However, we intend that it\n+should be compatible with true traditional preprocessors in all ways\n+that actually matter.\n \n-@itemize @bullet\n-@item\n-Traditional macro expansion pays no attention to single-quote or\n-double-quote characters; macro argument symbols are replaced by the\n-argument values even when they appear within apparent string or\n-character constants.\n+@menu\n+* Traditional lexical analysis::\n+* Traditional macros::\n+* Traditional miscellany::\n+* Traditional warnings::\n+@end menu\n \n-@item\n-Traditionally, it is permissible for a macro expansion to end in the\n-middle of a string or character constant.  The constant continues into\n-the text surrounding the macro call.\n+@node Traditional lexical analysis\n+@section Traditional lexical analysis\n \n-@item\n-However, the end of the line terminates a string or character constant,\n-with no error.  (This is a kluge.  Traditional mode is commonly used to\n-preprocess things which are not C, and have a different comment syntax.\n-Single apostrophes often appear in comments.  This kluge prevents the\n-traditional preprocessor from issuing errors on such comments.)\n+The traditional preprocessor does not decompose its input into tokens\n+the same way a standards-conforming preprocessor does.  The input is\n+simply treated as a stream of text with minimal form imposed on it.\n \n-@item\n-Preprocessing directives are recognized in traditional C only when their\n-leading @samp{#} appears in the first column.  There can be no\n-whitespace between the beginning of the line and the @samp{#}.\n+This implementation does not treat trigraphs (@pxref{trigraphs})\n+specially since they were created later during standardization.  It\n+handles arbitrarily-positioned escaped newlines properly and splices\n+the lines as you would expect; many traditional preprocessors did not\n+do this.\n \n-@item\n-In traditional C, a comment is equivalent to no text at all.  (In ISO\n-C, a comment counts as whitespace.)  It can be used sort of the same way\n-that @samp{##} is used in ISO C, to paste macro arguments together.\n+The form of horizontal whitespace in the input file is preserved in\n+the output.  In particular, hard tabs remain hard tabs.  This can be\n+useful if, for example, you are preprocessing a Makefile.\n \n-@item\n-Traditional C does not have the concept of a preprocessing number.\n+Traditional CPP only recognizes C-style block comments, and treats the\n+@samp{/*} sequence as introducing a comment only if it lies outside\n+quoted text.  Quoted text is introduced by the usual single and double\n+quotes, and also by @samp{<} in a @code{#include} directive.\n \n-@item\n-A macro is not suppressed within its own definition, in traditional C@.\n-Thus, any macro that is used recursively inevitably causes an error.\n+Traditionally, comments are completely removed and are not replaced\n+with a space.  Since a traditional compiler does its own tokenization\n+of the output of the preprocessor, comments can effectively be used as\n+token paste operators.  However, comments behave like separators for\n+text handled by the preprocessor itself.  For example, in\n \n-@item\n-The @samp{#} and @samp{##} operators are not available in traditional\n-C@.\n+@smallexample\n+#if foo/**/bar\n+@end smallexample\n \n-@item\n-In traditional C, the text at the end of a macro expansion can run\n-together with the text after the macro call, to produce a single token.\n-This is impossible in ISO C@.\n+@noindent\n+@samp{foo} and @samp{bar} are distinct identifiers and expanded\n+separately if they happen to be macros.  In other words, this\n+directive is equivalent to\n+\n+@smallexample\n+#if foo bar\n+@end smallexample\n+\n+@noindent\n+rather than\n \n+@smallexample\n+#if foobar\n+@end smallexample\n+\n+Generally speaking, in traditional mode an opening quote need not have\n+a matching closing quote.  In particular, a macro may be defined with\n+replacement text that contains an unmatched quote.  Of course, if you\n+attempt to compile preprocessed output containing an unmatched quote\n+you will get a syntax error.\n+\n+However, all preprocessing directives other than @code{#define}\n+require matching quotes.  For example:\n+\n+@smallexample\n+#define m This macro's fine and has an unmatched quote\n+\"/* This is not a comment.  */\n+/* This is a comment.  The following #include directive\n+   is ill-formed.  */\n+#include <stdio.h\n+@end smallexample\n+\n+Just as for the ISO preprocessor, what would be a closing quote can be\n+escaped with a backslash to prevent the quoted text from closing.\n+\n+@node Traditional macros\n+@section Traditional macros\n+\n+The major difference between traditional and ISO macros is that the\n+former expand to text rather than to a token sequence.  CPP removes\n+all leading and trailing horizontal whitespace from a macro's\n+replacement text before storing it, but preserves the form of internal\n+whitespace.\n+\n+One consequence is that it is legitimate for the replacement text to\n+contain an unmatched quote (@pxref{Traditional lexical analysis}). An\n+unclosed string or character constant continues into the text\n+following the macro call.  Similarly, the text at the end of a macro's\n+expansion can run together with the text after the macro invocation to\n+produce a single token.\n+\n+Normally comments are removed from the replacement text after the\n+macro is expanded, but if the @option{-CC} option is passed on the\n+command line comments are preserved.  (In fact, the current\n+implementation removes comments even before saving the macro\n+replacement text, but it careful to do it in such a way that the\n+observed effect is identical even in the function-like macro case.)\n+\n+The ISO stringification operator @samp{#} and token paste operator\n+@samp{##} have no special meaning.  As explained later, an effect\n+similar to these operators can be obtained in a different way.  Macro\n+names that are embedded in quotes, either from the main file or after\n+macro replacement, do not expand.\n+\n+CPP replaces an unquoted object-like macro name with its replacement\n+text, and then rescans it for further macros to replace.  Unlike\n+standard macro expansion, traditional macro expansion has no provision\n+to prevent recursion.  If an object-like macro appears unquoted in its\n+replacement text, it will be replaced again during the rescan pass,\n+and so on @emph{ad infinitum}.  GCC detects when it is expanding\n+recursive macros, emits an error message, and continues after the\n+offending macro invocation.\n+\n+@smallexample\n+#define PLUS +\n+#define INC(x) PLUS+x\n+INC(foo);\n+     @expansion{} ++foo;\n+@end smallexample\n+\n+Function-like macros are similar in form but quite different in\n+behavior to their ISO counterparts.  Their arguments are contained\n+within parentheses, are comma-separated, and can cross physical lines.\n+Commas within nested parentheses are not treated as argument\n+separators.  Similarly, a quote in an argument cannot be left\n+unclosed; in other words a comma or parenthesis in quotes is treated\n+like any other character.  There is no facility for handling variadic\n+macros.\n+\n+This implementation removes all comments from macro arguments, unless\n+the @option{-C} option is given.  The form of all other horizontal\n+whitespace in arguments is preserved, including leading and trailing\n+whitespace.  In particular\n+\n+@smallexample\n+f( )\n+@end smallexample\n+\n+@noindent\n+is treated as an invocation of the macro @samp{f} with a single\n+argument consisting of a single space.  If you want to invoke a\n+function-like macro that takes no arguments, you must not leave any\n+whitespace between the parentheses.\n+\n+If a macro argument crosses a new line, the new line is replaced with\n+a space when forming the argument.  If the previous line contained an\n+unterminated quote, the following line inherits the quoted state.\n+\n+Traditional preprocessors replace parameters in the replacement text\n+with their arguments regardless of whether the parameters are within\n+quotes or not.  This provides a way to stringize arguments.  For\n+example\n+\n+@smallexample\n+#define str(x) \"x\"\n+str(/* A comment */ some text)\n+     @expansion{} \" some text\"\n+@end smallexample\n+\n+@noindent\n+Note that the comment is removed, but that the leading space is\n+preserved.  Here is an example of using a comment to effect token\n+pasting.\n+\n+@smallexample\n+#define suffix(x) foo_/**/x\n+suffix(bar)\n+     @expansion{} foo_bar\n+@end smallexample\n+\n+@node Traditional miscellany\n+@section Traditional miscellany\n+\n+Here are some things to be aware of when using the traditional\n+preprocessor.\n+\n+@itemize @bullet\n @item\n-None of the GNU extensions to the preprocessor are available in\n-traditional mode, with the exception of a partial implementation of\n-assertions, and those may be removed in the future.\n+Preprocessing directives are recognized only when their leading\n+@samp{#} appears in the first column.  There can be no whitespace\n+between the beginning of the line and the @samp{#}, but whitespace can\n+follow the @samp{#}.\n \n @item\n-A true traditional C preprocessor does not recognize @samp{#elif},\n-@samp{#error}, or @samp{#pragma}.  GCC supports @samp{#elif} and\n-@samp{#error} even in traditional mode, but not @samp{#pragma}.\n+A true traditional C preprocessor does not recognize @samp{#error} or\n+@samp{#pragma}, and may not recognize @samp{#elif}.  CPP supports all\n+the directives in traditional mode that it supports in ISO mode,\n+including extensions, with the exception that the effects of\n+@samp{#pragma GCC poison} are undefined.\n \n @item\n-Traditional mode is text-based, not token-based, and comments are\n-stripped after macro expansion.  Therefore, @samp{/**/} can be used to\n-paste tokens together provided that there is no whitespace between it\n-and the tokens to be pasted.\n+__STDC__ is not defined.\n \n @item\n-Traditional mode preserves the amount and form of whitespace provided by\n-the user.  Hard tabs remain hard tabs.  This can be useful, e.g.@: if you\n-are preprocessing a Makefile (which we do not encourage).\n+If you use digraphs the behaviour is undefined.\n+\n @end itemize\n \n+@node Traditional warnings\n+@section Traditional warnings\n You can request warnings about features that did not exist, or worked\n differently, in traditional C with the @option{-Wtraditional} option.\n-This works only if you do @emph{not} specify @option{-traditional}.  GCC\n-does not warn about features of ISO C which you must use when you are\n-using a conforming compiler, such as the @samp{#} and @samp{##}\n+GCC does not warn about features of ISO C which you must use when you\n+are using a conforming compiler, such as the @samp{#} and @samp{##}\n operators.\n \n Presently @option{-Wtraditional} warns about:\n@@ -3441,9 +3577,9 @@ traditional implementations would not recognize @samp{#elif}, so it\n suggests avoiding it altogether.\n \n @item\n-A function-like macro that appears without an argument list.  In\n-traditional C this was an error.  In ISO C it merely means that the\n-macro is not expanded.\n+A function-like macro that appears without an argument list.  In some\n+traditional preprocessors this was an error.  In ISO C it merely means\n+that the macro is not expanded.\n \n @item\n The unary plus operator.  This did not exist in traditional C@.\n@@ -3811,15 +3947,6 @@ omitted entirely, the comma will be removed from the expansion.  If the\n variable argument is empty, or the token before @samp{##} is not a\n comma, then @samp{##} behaves as a normal token paste.\n \n-@item Traditional mode and GNU extensions\n-\n-Traditional mode used to be implemented in the same program as normal\n-preprocessing.  Therefore, all the GNU extensions to the preprocessor\n-were still available in traditional mode.  It is now a separate program\n-and does not implement any of the GNU extensions, except for a partial\n-implementation of assertions.  Even those may be removed in a future\n-release.\n-\n @item @samp{#line} and @samp{#include}\n \n The @samp{#line} directive used to change GCC's notion of the"}, {"sha": "6fb3b53f157f7cd6a673b356302e04ff533f9f69", "filename": "gcc/doc/cppopts.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47/gcc%2Fdoc%2Fcppopts.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47/gcc%2Fdoc%2Fcppopts.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppopts.texi?ref=b6fb43ab3e59a0a4d9063daed96812eeb5a9fb47", "patch": "@@ -551,10 +551,10 @@ Define the macros @sc{__gnuc__}, @sc{__gnuc_minor__} and\n @command{gcc -E}; you can turn them off in that case with\n @option{-no-gcc}.\n \n-@item -traditional\n-@opindex traditional\n-Try to imitate the behavior of old-fashioned C, as opposed to ISO\n-C@.\n+@item -traditional-cpp\n+@opindex traditional-cpp\n+Try to imitate the behavior of old-fashioned C preprocessors, as\n+opposed to ISO C preprocessors.\n @ifset cppmanual\n @xref{Traditional Mode}.\n @end ifset"}]}