{"sha": "a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg3Y2Y5N2UwZDY4NDNmNmJhNmM0ZTEyMGFjZmRiNTY5MzcwMGVkYQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2010-06-30T18:47:43Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2010-06-30T18:47:43Z"}, "message": "re PR middle-end/44566 (configuration with multiple targets / backends is not supported.)\n\n        PR other/44566\n        * coretypes.h [!USED_FOR_TARGET] (reg_class_t): Define.\n        * target.def (struct gcc_target): Replace enum reg_class with\n        reg_class_t in hook argument / return types.\n        * doc/tm.texi.in (TARGET_SECONDARY_RELOAD): Likewise.\n        (TARGET_IRA_COVER_CLASSES, TARGET_MEMORY_MOVE_COST): Likewise.\n        (TARGET_BRANCH_TARGET_REGISTER_CLASS): Likewise.\n        * targhooks.h (default_branch_target_register_class): Likewise.\n        (default_ira_cover_classes, default_secondary_reload): Likewise.\n        (default_memory_move_cost, default_register_move_cost): Likewise.\n        * targhooks.c (default_branch_target_register_class): Likewise.\n        (default_ira_cover_classes, default_secondary_reload): Likewise.\n        (default_memory_move_cost, default_register_move_cost): Likewise.\n        * reload.c (push_secondary_reload, secondary_reload_class): Likewise.\n        * bt-load.c (branch_target_load_optimize): Likewise.\n        * ira.c (setup_cover_and_important_classes): Likewise.\n        * ira-costs.c (copy_cost): Likewise.\n        * reload1.c (emit_input_reload_insns): Likewise.\n        * config/alpha/alpha.c (alpha_secondary_reload): Likewise.\n        * config/frv/frv.c (frv_secondary_reload): Likewise.\n        * config/s390/s390.c (s390_secondary_reload): Likewise.\n        * config/i386/i386.c (i386_ira_cover_classes): Likewise.\n        (ix86_secondary_reload, ix86_memory_move_cost): Likewise.\n        (ix86_register_move_cost): Likewise.\n        * config/sh/sh-protos.h (sh_secondary_reload): Likewise.\n        * config/sh/sh.c (sh_target_reg_class, sh_secondary_reload): Likewise.\n        * config/xtensa/xtensa.c (xtensa_secondary_reload): Likewise.\n        * config/xtensa/xtensa-protos.h (xtensa_secondary_reload): Likewise.\n        * config/rs6000/rs6000.c (rs6000_secondary_reload): Likewise.\n        (rs6000_ira_cover_classes): Likewise.\n        * config/picochip/picochip.c (picochip_secondary_reload): Likewise.\n        * config/picochip/picochip-protos.h (picochip_secondary_reload):\n        Likewise.\n        * config/pa/pa.c (pa_secondary_reload): Likewise.\n        * config/mips/mips.c (mips_ira_cover_classes): Likewise.\n        * config/bfin/bfin.c (bfin_secondary_reload): Likewise.\n        * config/ia64/ia64.c (ia64_register_move_cost): Likewise.\n        * doc/tm.texi: Regenerate.\n\nFrom-SVN: r161633", "tree": {"sha": "684be6242471aff6286aab4d1043e3360a5902af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/684be6242471aff6286aab4d1043e3360a5902af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e44d26e24a11cfd8bfc929f2fbc2c73765c99af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e44d26e24a11cfd8bfc929f2fbc2c73765c99af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e44d26e24a11cfd8bfc929f2fbc2c73765c99af"}], "stats": {"total": 279, "additions": 175, "deletions": 104}, "files": [{"sha": "af1148791b953cbfbb34f346a289ee214d6b4b2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -1,3 +1,44 @@\n+2010-06-30  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR other/44566\n+\t* coretypes.h [!USED_FOR_TARGET] (reg_class_t): Define.\n+\t* target.def (struct gcc_target): Replace enum reg_class with\n+\treg_class_t in hook argument / return types.\n+\t* doc/tm.texi.in (TARGET_SECONDARY_RELOAD): Likewise.\n+\t(TARGET_IRA_COVER_CLASSES, TARGET_MEMORY_MOVE_COST): Likewise.\n+\t(TARGET_BRANCH_TARGET_REGISTER_CLASS): Likewise.\n+\t* targhooks.h (default_branch_target_register_class): Likewise.\n+\t(default_ira_cover_classes, default_secondary_reload): Likewise.\n+\t(default_memory_move_cost, default_register_move_cost): Likewise.\n+\t* targhooks.c (default_branch_target_register_class): Likewise.\n+\t(default_ira_cover_classes, default_secondary_reload): Likewise.\n+\t(default_memory_move_cost, default_register_move_cost): Likewise.\n+\t* reload.c (push_secondary_reload, secondary_reload_class): Likewise.\n+\t* bt-load.c (branch_target_load_optimize): Likewise.\n+\t* ira.c (setup_cover_and_important_classes): Likewise.\n+\t* ira-costs.c (copy_cost): Likewise.\n+\t* reload1.c (emit_input_reload_insns): Likewise.\n+\t* config/alpha/alpha.c (alpha_secondary_reload): Likewise.\n+\t* config/frv/frv.c (frv_secondary_reload): Likewise.\n+\t* config/s390/s390.c (s390_secondary_reload): Likewise.\n+\t* config/i386/i386.c (i386_ira_cover_classes): Likewise.\n+\t(ix86_secondary_reload, ix86_memory_move_cost): Likewise.\n+\t(ix86_register_move_cost): Likewise.\n+\t* config/sh/sh-protos.h (sh_secondary_reload): Likewise.\n+\t* config/sh/sh.c (sh_target_reg_class, sh_secondary_reload): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_secondary_reload): Likewise.\n+\t* config/xtensa/xtensa-protos.h (xtensa_secondary_reload): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_secondary_reload): Likewise.\n+\t(rs6000_ira_cover_classes): Likewise.\n+\t* config/picochip/picochip.c (picochip_secondary_reload): Likewise.\n+\t* config/picochip/picochip-protos.h (picochip_secondary_reload):\n+\tLikewise.\n+\t* config/pa/pa.c (pa_secondary_reload): Likewise.\n+\t* config/mips/mips.c (mips_ira_cover_classes): Likewise.\n+\t* config/bfin/bfin.c (bfin_secondary_reload): Likewise.\n+\t* config/ia64/ia64.c (ia64_register_move_cost): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\n 2010-06-30  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR bootstrrap/44726"}, {"sha": "abb033fc096eae687b27bf4d83daa4b95c75fea9", "filename": "gcc/bt-load.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -1458,7 +1458,8 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n static void\n branch_target_load_optimize (bool after_prologue_epilogue_gen)\n {\n-  enum reg_class klass = targetm.branch_target_register_class ();\n+  enum reg_class klass\n+    = (enum reg_class) targetm.branch_target_register_class ();\n   if (klass != NO_REGS)\n     {\n       /* Initialize issue_rate.  */"}, {"sha": "7345be4791b0197c88263845e8fe4502a325d8ab", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -1569,10 +1569,12 @@ alpha_preferred_reload_class(rtx x, enum reg_class rclass)\n    RCLASS requires an extra scratch or immediate register.  Return the class\n    needed for the immediate register.  */\n \n-static enum reg_class\n-alpha_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n+static reg_class_t\n+alpha_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t\tenum machine_mode mode, secondary_reload_info *sri)\n {\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n+\n   /* Loading and storing HImode or QImode values to and from memory\n      usually requires a scratch register.  */\n   if (!TARGET_BWX && (mode == QImode || mode == HImode || mode == CQImode))"}, {"sha": "1232ecc7378d01613f5fc17fbbe7c6bd9dec2d6d", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -2458,15 +2458,16 @@ bfin_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n    RCLASS requires an extra scratch register.  Return the class needed for the\n    scratch register.  */\n \n-static enum reg_class\n-bfin_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n+static reg_class_t\n+bfin_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t       enum machine_mode mode, secondary_reload_info *sri)\n {\n   /* If we have HImode or QImode, we can only use DREGS as secondary registers;\n      in most other cases we can also use PREGS.  */\n   enum reg_class default_class = GET_MODE_SIZE (mode) >= 4 ? DPREGS : DREGS;\n   enum reg_class x_class = NO_REGS;\n   enum rtx_code code = GET_CODE (x);\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n \n   if (code == SUBREG)\n     x = SUBREG_REG (x), code = GET_CODE (x);"}, {"sha": "9454bd25e7bd2e0ee02bdf7f31690f713ff309fc", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -1,5 +1,5 @@\n /* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007,\n-   2008, 2009  Free Software Foundation, Inc.\n+   2008, 2009, 2010  Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc.\n \n This file is part of GCC.\n@@ -384,7 +384,7 @@ static int frv_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, bool);\n static void frv_output_dwarf_dtprel\t\t(FILE *, int, rtx)\n   ATTRIBUTE_UNUSED;\n-static bool frv_secondary_reload                (bool, rtx, enum reg_class,\n+static reg_class_t frv_secondary_reload\t\t(bool, rtx, reg_class_t,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t secondary_reload_info *);\n static bool frv_frame_pointer_required\t\t(void);\n@@ -6492,12 +6492,13 @@ frv_secondary_reload_class (enum reg_class rclass,\n    called from init_reg_autoinc() in regclass.c - before the reload optabs\n    have been initialised.  */\n    \n-static bool\n-frv_secondary_reload (bool in_p, rtx x, enum reg_class reload_class,\n+static reg_class_t\n+frv_secondary_reload (bool in_p, rtx x, reg_class_t reload_class_i,\n \t\t      enum machine_mode reload_mode,\n \t\t      secondary_reload_info * sri)\n {\n   enum reg_class rclass = NO_REGS;\n+  enum reg_class reload_class = (enum reg_class) reload_class_i;\n \n   if (sri->prev_sri && sri->prev_sri->t_icode != CODE_FOR_nothing)\n     {"}, {"sha": "4f5afbec0a1d885f06e50bbda22ca24ae4fad719", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -25287,13 +25287,13 @@ ix86_free_from_memory (enum machine_mode mode)\n /* Implement TARGET_IRA_COVER_CLASSES.  If -mfpmath=sse, we prefer\n    SSE_REGS to FLOAT_REGS if their costs for a pseudo are the\n    same.  */\n-static const enum reg_class *\n+static const reg_class_t *\n i386_ira_cover_classes (void)\n {\n-  static const enum reg_class sse_fpmath_classes[] = {\n+  static const reg_class_t sse_fpmath_classes[] = {\n     GENERAL_REGS, SSE_REGS, MMX_REGS, FLOAT_REGS, LIM_REG_CLASSES\n   };\n-  static const enum reg_class no_sse_fpmath_classes[] = {\n+  static const reg_class_t no_sse_fpmath_classes[] = {\n     GENERAL_REGS, FLOAT_REGS, MMX_REGS, SSE_REGS, LIM_REG_CLASSES\n   };\n \n@@ -25403,8 +25403,8 @@ ix86_preferred_output_reload_class (rtx x, enum reg_class regclass)\n   return regclass;\n }\n \n-static enum reg_class\n-ix86_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n+static reg_class_t\n+ix86_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n \t\t       enum machine_mode mode,\n \t\t       secondary_reload_info *sri ATTRIBUTE_UNUSED)\n {\n@@ -25657,10 +25657,10 @@ inline_memory_move_cost (enum machine_mode mode, enum reg_class regclass,\n }\n \n static int\n-ix86_memory_move_cost (enum machine_mode mode, enum reg_class regclass,\n+ix86_memory_move_cost (enum machine_mode mode, reg_class_t regclass,\n \t\t       bool in)\n {\n-  return inline_memory_move_cost (mode, regclass, in ? 1 : 0);\n+  return inline_memory_move_cost (mode, (enum reg_class) regclass, in ? 1 : 0);\n }\n \n \n@@ -25672,9 +25672,12 @@ ix86_memory_move_cost (enum machine_mode mode, enum reg_class regclass,\n    general registers.  */\n \n static int\n-ix86_register_move_cost (enum machine_mode mode, enum reg_class class1,\n-\t\t\t enum reg_class class2)\n+ix86_register_move_cost (enum machine_mode mode, reg_class_t class1_i,\n+\t\t\t reg_class_t class2_i)\n {\n+  enum reg_class class1 = (enum reg_class) class1_i;\n+  enum reg_class class2 = (enum reg_class) class2_i;\n+\n   /* In case we require secondary memory, compute cost of the store followed\n      by load.  In order to avoid bad register allocation choices, we need\n      for this to be *at least* as high as the symmetric MEMORY_MOVE_COST.  */"}, {"sha": "0b6df6192449388bac892790a05bac0cb818050b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -5207,8 +5207,11 @@ ia64_rtx_costs (rtx x, int code, int outer_code, int *total,\n    one in class TO, using MODE.  */\n \n static int\n-ia64_register_move_cost (enum machine_mode mode, enum reg_class from,\n-\t\t\t enum reg_class to)\n+ia64_register_move_cost (enum machine_mode mode, enum reg_class from_i,\n+\t\t\t enum reg_class to_i)\n+{\n+  enum reg_class from = (enum reg_class) from_i;\n+  enum reg_class to = (enum reg_class) to_i;\n {\n   /* ADDL_REGS is the same as GR_REGS for movement purposes.  */\n   if (to == ADDL_REGS)"}, {"sha": "ccdfbbc3fd13b5ae2b358aecd16904e1992af4c4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -10929,14 +10929,14 @@ mips_register_move_cost (enum machine_mode mode,\n \n /* Implement TARGET_IRA_COVER_CLASSES.  */\n \n-static const enum reg_class *\n+static const reg_class_t *\n mips_ira_cover_classes (void)\n {\n-  static const enum reg_class acc_classes[] = {\n+  static const reg_class_t acc_classes[] = {\n     GR_AND_ACC_REGS, FP_REGS, COP0_REGS, COP2_REGS, COP3_REGS,\n     ST_REGS, LIM_REG_CLASSES\n   };\n-  static const enum reg_class no_acc_classes[] = {\n+  static const reg_class_t no_acc_classes[] = {\n     GR_REGS, FP_REGS, COP0_REGS, COP2_REGS, COP3_REGS,\n     ST_REGS, LIM_REG_CLASSES\n   };"}, {"sha": "2640f05e1bcd1ead6c2b4927e370ebe6e92a0dec", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -155,9 +155,9 @@ static bool pa_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n static int pa_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t tree, bool);\n static struct machine_function * pa_init_machine_status (void);\n-static enum reg_class pa_secondary_reload (bool, rtx, enum reg_class,\n-\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t   secondary_reload_info *);\n+static reg_class_t pa_secondary_reload (bool, rtx, reg_class_t,\n+\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\tsecondary_reload_info *);\n static void pa_extra_live_on_entry (bitmap);\n static enum machine_mode pa_promote_function_mode (const_tree,\n \t\t\t\t\t\t   enum machine_mode, int *,\n@@ -5688,11 +5688,12 @@ output_arg_descriptor (rtx call_insn)\n   fputc ('\\n', asm_out_file);\n }\n \f\n-static enum reg_class\n-pa_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n+static reg_class_t\n+pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t     enum machine_mode mode, secondary_reload_info *sri)\n {\n   int is_symbolic, regno;\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n \n   /* Handle the easy stuff first.  */\n   if (rclass == R1_REGS)"}, {"sha": "4a80bd16d5d25ffc37703a9c3041f74f7756c77e", "filename": "gcc/config/picochip/picochip-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -73,9 +73,9 @@ extern int picochip_symbol_offset (rtx operand);\n \n extern int picochip_get_function_arg_boundary (enum machine_mode mode);\n \n-extern enum reg_class picochip_secondary_reload(bool in_p,\n+extern reg_class_t picochip_secondary_reload(bool in_p,\n                                  rtx x,\n-                                 enum reg_class cla,\n+                                 reg_class_t cla,\n                                  enum machine_mode mode,\n                                  secondary_reload_info *sri);\n "}, {"sha": "2e8dbb923558a72ef5399795a708b413a44f4cbf", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on picoChip processors.\n-   Copyright (C) 2001,2008, 2009   Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2008, 2009, 2010   Free Software Foundation, Inc.\n    Contributed by picoChip Designs Ltd. (http://www.picochip.com)\n    Maintained by Daniel Towner (daniel.towner@picochip.com) and\n    Hariharan Sandanagobalane (hariharan@picochip.com)\n@@ -103,12 +103,12 @@ int picochip_legitimize_reload_address (rtx *x, enum machine_mode mode,\n rtx picochip_struct_value_rtx(tree fntype ATTRIBUTE_UNUSED, int incoming ATTRIBUTE_UNUSED);\n rtx picochip_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n                          bool outgoing ATTRIBUTE_UNUSED);\n-enum reg_class\n+reg_class_t\n picochip_secondary_reload (bool in_p,\n-\t\t\t\t rtx x ATTRIBUTE_UNUSED,\n-\t\t\t\t enum reg_class cla ATTRIBUTE_UNUSED,\n-\t\t\t\t enum machine_mode mode,\n-\t\t\t\t secondary_reload_info *sri);\n+\t\t\t   rtx x ATTRIBUTE_UNUSED,\n+\t\t\t   reg_class_t cla ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode,\n+\t\t\t   secondary_reload_info *sri);\n void\n picochip_asm_named_section (const char *name,\n \t\t\t    unsigned int flags ATTRIBUTE_UNUSED,\n@@ -4363,12 +4363,12 @@ picochip_get_high_const (rtx value)\n    choice of two registers to choose from, so that we a guaranteed to\n    get at least one register which is different to the output\n    register.  This trick is taken from the alpha implementation. */\n-enum reg_class\n+reg_class_t\n picochip_secondary_reload (bool in_p,\n-\t\t\t\t rtx x ATTRIBUTE_UNUSED,\n-\t\t\t\t enum reg_class cla ATTRIBUTE_UNUSED,\n-\t\t\t\t enum machine_mode mode,\n-\t\t\t\t secondary_reload_info *sri)\n+\t\t\t   rtx x ATTRIBUTE_UNUSED,\n+\t\t\t   reg_class_t cla ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode,\n+\t\t\t   secondary_reload_info *sri)\n {\n   if (mode == QImode && !TARGET_HAS_BYTE_ACCESS)\n   {"}, {"sha": "70ff5e0f292b695810bbd896553a8ee4494ec7e8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -1240,11 +1240,11 @@ bool (*rs6000_cannot_change_mode_class_ptr) (enum machine_mode,\n \t\t\t\t\t     enum reg_class)\n   = rs6000_cannot_change_mode_class;\n \n-static enum reg_class rs6000_secondary_reload (bool, rtx, enum reg_class,\n-\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t       struct secondary_reload_info *);\n+static reg_class_t rs6000_secondary_reload (bool, rtx, reg_class_t,\n+\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t    struct secondary_reload_info *);\n \n-static const enum reg_class *rs6000_ira_cover_classes (void);\n+static const reg_class_t *rs6000_ira_cover_classes (void);\n \n const int INSN_NOT_AVAILABLE = -1;\n static enum machine_mode rs6000_eh_return_filter_mode (void);\n@@ -13728,14 +13728,15 @@ rs6000_reload_register_type (enum reg_class rclass)\n    For VSX and Altivec, we may need a register to convert sp+offset into\n    reg+sp.  */\n \n-static enum reg_class\n+static reg_class_t\n rs6000_secondary_reload (bool in_p,\n \t\t\t rtx x,\n-\t\t\t enum reg_class rclass,\n+\t\t\t reg_class_t rclass_i,\n \t\t\t enum machine_mode mode,\n \t\t\t secondary_reload_info *sri)\n {\n-  enum reg_class ret = ALL_REGS;\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n+  reg_class_t ret = ALL_REGS;\n   enum insn_code icode;\n   bool default_p = false;\n \n@@ -14127,11 +14128,11 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n    account for the Altivec and Floating registers being subsets of the VSX\n    register set under VSX, but distinct register sets on pre-VSX machines.  */\n \n-static const enum reg_class *\n+static const reg_class_t *\n rs6000_ira_cover_classes (void)\n {\n-  static const enum reg_class cover_pre_vsx[] = IRA_COVER_CLASSES_PRE_VSX;\n-  static const enum reg_class cover_vsx[]     = IRA_COVER_CLASSES_VSX;\n+  static const reg_class_t cover_pre_vsx[] = IRA_COVER_CLASSES_PRE_VSX;\n+  static const reg_class_t cover_vsx[]     = IRA_COVER_CLASSES_VSX;\n \n   return (TARGET_VSX) ? cover_vsx : cover_pre_vsx;\n }"}, {"sha": "7ff8cb870cd79119fe4bce741b7b9a9bc2d0ff1c", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -2957,10 +2957,12 @@ s390_reload_symref_address (rtx reg, rtx mem, rtx scratch, bool tomem)\n    RCLASS requires an extra scratch or immediate register.  Return the class\n    needed for the immediate register.  */\n \n-static enum reg_class\n-s390_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n+static reg_class_t\n+s390_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t       enum machine_mode mode, secondary_reload_info *sri)\n {\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n+\n   /* Intermediate register needed.  */\n   if (reg_classes_intersect_p (CC_REGS, rclass))\n     return GENERAL_REGS;"}, {"sha": "dc68af1332b852a2bd50202ebddb10884e01344f", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -173,9 +173,9 @@ extern int sh_contains_memref_p (rtx);\n extern int sh_loads_bankedreg_p (rtx);\n extern rtx shmedia_prepare_call_address (rtx fnaddr, int is_sibcall);\n struct secondary_reload_info;\n-extern enum reg_class sh_secondary_reload (bool, rtx, enum reg_class,\n-\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t   struct secondary_reload_info *);\n+extern reg_class_t sh_secondary_reload (bool, rtx, reg_class_t,\n+\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\tstruct secondary_reload_info *);\n extern int sh2a_get_function_vector_number (rtx);\n extern int sh2a_is_function_vector_call (rtx);\n extern void sh_fix_range (const char *);"}, {"sha": "c488ef4958b396ec0d1ea6a30a89a46338b931df", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -225,7 +225,7 @@ static int sh_variable_issue (FILE *, int, rtx, int);\n static bool sh_function_ok_for_sibcall (tree, tree);\n \n static bool sh_cannot_modify_jumps_p (void);\n-static enum reg_class sh_target_reg_class (void);\n+static reg_class_t sh_target_reg_class (void);\n static bool sh_optimize_target_register_callee_saved (bool);\n static bool sh_ms_bitfield_layout_p (const_tree);\n \n@@ -10519,7 +10519,7 @@ sh_cannot_modify_jumps_p (void)\n   return (TARGET_SHMEDIA && (reload_in_progress || reload_completed));\n }\n \n-static enum reg_class\n+static reg_class_t\n sh_target_reg_class (void)\n {\n   return TARGET_SHMEDIA ? TARGET_REGS : NO_REGS;\n@@ -12158,10 +12158,12 @@ shmedia_prepare_call_address (rtx fnaddr, int is_sibcall)\n   return fnaddr;\n }\n \n-enum reg_class\n-sh_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n+reg_class_t\n+sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t     enum machine_mode mode, secondary_reload_info *sri)\n {\n+  enum reg_class rclass = (enum reg_class) rclass_i;\n+\n   if (in_p)\n     {\n       if (REGCLASS_HAS_FP_REG (rclass)"}, {"sha": "729bc84bbbca5f6a8dd6d099d040b4515da6191e", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -67,9 +67,9 @@ extern void xtensa_output_literal (FILE *, rtx, enum machine_mode, int);\n extern rtx xtensa_return_addr (int, rtx);\n extern enum reg_class xtensa_preferred_reload_class (rtx, enum reg_class, int);\n struct secondary_reload_info;\n-extern enum reg_class xtensa_secondary_reload (bool, rtx, enum reg_class,\n-\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t       struct secondary_reload_info *);\n+extern reg_class_t xtensa_secondary_reload (bool, rtx, reg_class_t,\n+\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t    struct secondary_reload_info *);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "5d891cde044ea2cdb2eeff34cccb6a736ec5b31f", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Tensilica's Xtensa architecture.\n-   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n@@ -3089,8 +3089,8 @@ xtensa_preferred_reload_class (rtx x, enum reg_class rclass, int isoutput)\n }\n \n \n-enum reg_class\n-xtensa_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n+reg_class_t\n+xtensa_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n \t\t\t enum machine_mode mode, secondary_reload_info *sri)\n {\n   int regno;"}, {"sha": "b631d94d85f05af98c06a21c490a834177ba5c7e", "filename": "gcc/coretypes.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -119,6 +119,11 @@ typedef const struct basic_block_def *const_basic_block;\n \t\t  obstack_chunk_alloc,\t\t\t\\\n \t\t  obstack_chunk_free)\n \n+/* enum reg_class is target specific, so it should not appear in\n+   target-independent code or interfaces, like the target hook declarations\n+   in target.h.  */\n+typedef int reg_class_t;\n+\n #else\n \n struct _dont_use_rtx_here_;"}, {"sha": "d6bc604b7ee1b15131b991babd47b4160376b8e5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -2648,7 +2648,7 @@ Don't define this macro unless the target machine has limitations which\n require the macro to do something nontrivial.\n @end defmac\n \n-@deftypefn {Target Hook} {enum reg_class} TARGET_SECONDARY_RELOAD (bool @var{in_p}, rtx @var{x}, enum reg_class @var{reload_class}, enum machine_mode @var{reload_mode}, secondary_reload_info *@var{sri})\n+@deftypefn {Target Hook} reg_class_t TARGET_SECONDARY_RELOAD (bool @var{in_p}, rtx @var{x}, reg_class_t @var{reload_class}, enum machine_mode @var{reload_mode}, secondary_reload_info *@var{sri})\n Many machines have some registers that cannot be copied directly to or\n from memory or even from other types of registers.  An example is the\n @samp{MQ} register, which on most machines, can only be copied to or\n@@ -2888,7 +2888,7 @@ as below:\n @end smallexample\n @end defmac\n \n-@deftypefn {Target Hook} {const enum reg_class *} TARGET_IRA_COVER_CLASSES (void)\n+@deftypefn {Target Hook} {const reg_class_t *} TARGET_IRA_COVER_CLASSES (void)\n Return an array of cover classes for the Integrated Register Allocator\n (@acronym{IRA}).  Cover classes are a set of non-intersecting register\n classes covering all hard registers used for register allocation\n@@ -6122,7 +6122,7 @@ These macros are obsolete, new ports should use the target hook\n @code{TARGET_REGISTER_MOVE_COST} instead.\n @end defmac\n \n-@deftypefn {Target Hook} int TARGET_REGISTER_MOVE_COST (enum machine_mode @var{mode}, enum reg_class @var{from}, enum reg_class @var{to})\n+@deftypefn {Target Hook} int TARGET_REGISTER_MOVE_COST (enum machine_mode @var{mode}, reg_class_t @var{from}, reg_class_t @var{to})\n This target hook should return the cost of moving data of mode @var{mode}\n from a register in class @var{from} to one in class @var{to}.  The classes\n are expressed using the enumeration values such as @code{GENERAL_REGS}.\n@@ -6170,7 +6170,7 @@ These macros are obsolete, new ports should use the target hook\n @code{TARGET_MEMORY_MOVE_COST} instead.\n @end defmac\n \n-@deftypefn {Target Hook} int TARGET_MEMORY_MOVE_COST (enum machine_mode @var{mode}, enum reg_class @var{rclass}, bool @var{in})\n+@deftypefn {Target Hook} int TARGET_MEMORY_MOVE_COST (enum machine_mode @var{mode}, reg_class_t @var{rclass}, bool @var{in})\n This target hook should return the cost of moving data of mode @var{mode}\n between a register of class @var{rclass} and memory; @var{in} is @code{false}\n if the value is to be written to memory, @code{true} if it is to be read in.\n@@ -10944,7 +10944,7 @@ cannot_modify_jumps_past_reload_p ()\n @end smallexample\n @end deftypefn\n \n-@deftypefn {Target Hook} {enum reg_class} TARGET_BRANCH_TARGET_REGISTER_CLASS (void)\n+@deftypefn {Target Hook} reg_class_t TARGET_BRANCH_TARGET_REGISTER_CLASS (void)\n This target hook returns a register class for which branch target register\n optimizations should be applied.  All registers in this class should be\n usable interchangeably.  After reload, registers in this class will be"}, {"sha": "da26ad3d8c95314b32ea00d36534acc5bac81195", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -156,7 +156,8 @@ copy_cost (rtx x, enum machine_mode mode, enum reg_class rclass, bool to_p,\n      copy it.  */\n   sri.prev_sri = prev_sri;\n   sri.extra_cost = 0;\n-  secondary_class = targetm.secondary_reload (to_p, x, rclass, mode, &sri);\n+  secondary_class\n+    = (enum reg_class) targetm.secondary_reload (to_p, x, rclass, mode, &sri);\n \n   if (secondary_class != NO_REGS)\n     {"}, {"sha": "0f0b70ab4739e94effde1d1f6389867a67c56ce1", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -740,7 +740,7 @@ setup_cover_and_important_classes (void)\n {\n   int i, j, n, cl;\n   bool set_p;\n-  const enum reg_class *cover_classes;\n+  const reg_class_t *cover_classes;\n   HARD_REG_SET temp_hard_regset2;\n   static enum reg_class classes[LIM_REG_CLASSES + 1];\n "}, {"sha": "ea552e6695cbf687f995a50954491502c44e5a37", "filename": "gcc/reload.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -362,7 +362,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n   sri.icode = CODE_FOR_nothing;\n   sri.prev_sri = prev_sri;\n-  rclass = targetm.secondary_reload (in_p, x, reload_class, reload_mode, &sri);\n+  rclass = (enum reg_class) targetm.secondary_reload (in_p, x, reload_class,\n+\t\t\t\t\t\t      reload_mode, &sri);\n   icode = (enum insn_code) sri.icode;\n \n   /* If we don't need any secondary registers, done.  */\n@@ -525,7 +526,8 @@ secondary_reload_class (bool in_p, enum reg_class rclass,\n \n   sri.icode = CODE_FOR_nothing;\n   sri.prev_sri = NULL;\n-  rclass = targetm.secondary_reload (in_p, x, rclass, mode, &sri);\n+  rclass\n+    = (enum reg_class) targetm.secondary_reload (in_p, x, rclass, mode, &sri);\n   icode = (enum insn_code) sri.icode;\n \n   /* If there are no secondary reloads at all, we return NO_REGS."}, {"sha": "412f45d10d88608f63a1dcc4ec38f136e392fe1a", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -7506,8 +7506,10 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \n \t  sri.icode = CODE_FOR_nothing;\n \t  sri.prev_sri = NULL;\n-\t  new_class = targetm.secondary_reload (1, real_oldequiv, rl->rclass,\n-\t\t\t\t\t\tmode, &sri);\n+\t  new_class\n+\t    = (enum reg_class) targetm.secondary_reload (1, real_oldequiv,\n+\t\t\t\t\t\t\t rl->rclass, mode,\n+\t\t\t\t\t\t\t &sri);\n \n \t  if (new_class == NO_REGS && sri.icode == CODE_FOR_nothing)\n \t    second_reload_reg = 0;\n@@ -7533,8 +7535,10 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t    {\n \t      sri2.icode = CODE_FOR_nothing;\n \t      sri2.prev_sri = &sri;\n-\t      new_t_class = targetm.secondary_reload (1, real_oldequiv,\n-\t\t\t\t\t\t      new_class, mode, &sri);\n+\t      new_t_class\n+\t\t= (enum reg_class) targetm.secondary_reload (1, real_oldequiv,\n+\t\t\t\t\t\t\t     new_class, mode,\n+\t\t\t\t\t\t\t     &sri);\n \t      if (new_t_class == NO_REGS && sri2.icode == CODE_FOR_nothing)\n \t\t{\n \t\t  if (reload_adjust_reg_for_temp (&second_reload_reg,"}, {"sha": "8bcf877359c715e015e1f9449381e22e218b267d", "filename": "gcc/target.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -1083,7 +1083,7 @@ DEFHOOK\n DEFHOOK\n (branch_target_register_class,\n  \"\",\n- enum reg_class, (void),\n+ reg_class_t, (void),\n  default_branch_target_register_class)\n \n /* Return true if branch target register optimizations should include\n@@ -1362,7 +1362,7 @@ DEFHOOK\n DEFHOOK\n (register_move_cost,\n  \"\",\n- int, (enum machine_mode mode, enum reg_class from, enum reg_class to),\n+ int, (enum machine_mode mode, reg_class_t from, reg_class_t to),\n  default_register_move_cost)\n \n /* Compute cost of moving registers to/from memory.  */\n@@ -1371,7 +1371,7 @@ DEFHOOK\n DEFHOOK\n (memory_move_cost,\n  \"\",\n- int, (enum machine_mode mode, enum reg_class rclass, bool in),\n+ int, (enum machine_mode mode, reg_class_t rclass, bool in),\n  default_memory_move_cost)\n \n /* True for MODE if the target expects that registers in this mode will\n@@ -1931,15 +1931,15 @@ DEFHOOK\n DEFHOOK\n (ira_cover_classes,\n  \"\",\n- const enum reg_class *, (void),\n+ const reg_class_t *, (void),\n  default_ira_cover_classes)\n \n /* Return the class for a secondary reload, and fill in extra information.  */\n DEFHOOK\n (secondary_reload,\n  \"\",\n- enum reg_class,\n- (bool in_p, rtx x, enum reg_class reload_class, enum machine_mode reload_mode,\n+ reg_class_t,\n+ (bool in_p, rtx x, reg_class_t reload_class, enum machine_mode reload_mode,\n   secondary_reload_info *sri),\n  default_secondary_reload)\n "}, {"sha": "9271db829bf1160faf4914822a25c4d198cb0ad4", "filename": "gcc/targhooks.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -807,28 +807,29 @@ default_return_pops_args (tree fundecl ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n-enum reg_class\n+reg_class_t\n default_branch_target_register_class (void)\n {\n   return NO_REGS;\n }\n \n #ifdef IRA_COVER_CLASSES\n-const enum reg_class *\n+const reg_class_t *\n default_ira_cover_classes (void)\n {\n-  static enum reg_class classes[] = IRA_COVER_CLASSES;\n+  static reg_class_t classes[] = IRA_COVER_CLASSES;\n   return classes;\n }\n #endif\n \n-enum reg_class\n+reg_class_t\n default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n-\t\t\t  enum reg_class reload_class ATTRIBUTE_UNUSED,\n+\t\t\t  reg_class_t reload_class_i ATTRIBUTE_UNUSED,\n \t\t\t  enum machine_mode reload_mode ATTRIBUTE_UNUSED,\n \t\t\t  secondary_reload_info *sri)\n {\n   enum reg_class rclass = NO_REGS;\n+  enum reg_class reload_class = (enum reg_class) reload_class_i;\n \n   if (sri->prev_sri && sri->prev_sri->t_icode != CODE_FOR_nothing)\n     {\n@@ -1176,13 +1177,13 @@ default_have_conditional_execution (void)\n \n int\n default_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t  enum reg_class rclass ATTRIBUTE_UNUSED,\n+\t\t\t  reg_class_t rclass ATTRIBUTE_UNUSED,\n \t\t\t  bool in ATTRIBUTE_UNUSED)\n {\n #ifndef MEMORY_MOVE_COST\n-    return (4 + memory_move_secondary_cost (mode, rclass, in));\n+    return (4 + memory_move_secondary_cost (mode, (enum reg_class) rclass, in));\n #else\n-    return MEMORY_MOVE_COST (mode, rclass, in);\n+    return MEMORY_MOVE_COST (mode, (enum reg_class) rclass, in);\n #endif\n }\n \n@@ -1191,13 +1192,13 @@ default_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n \n int\n default_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-                            enum reg_class from ATTRIBUTE_UNUSED,\n-                            enum reg_class to ATTRIBUTE_UNUSED)\n+                            reg_class_t from ATTRIBUTE_UNUSED,\n+                            reg_class_t to ATTRIBUTE_UNUSED)\n {\n #ifndef REGISTER_MOVE_COST\n   return 2;\n #else\n-  return REGISTER_MOVE_COST (mode, from, to);\n+  return REGISTER_MOVE_COST (mode, (enum reg_class) from, (enum reg_class) to);\n #endif\n }\n "}, {"sha": "f491dbd4d299244bcd7130a768e2a1c2564f221a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87cf97e0d6843f6ba6c4e120acfdb5693700eda/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=a87cf97e0d6843f6ba6c4e120acfdb5693700eda", "patch": "@@ -115,13 +115,13 @@ extern rtx default_internal_arg_pointer (void);\n extern rtx default_static_chain (const_tree, bool);\n extern void default_trampoline_init (rtx, tree, rtx);\n extern int default_return_pops_args (tree, tree, int);\n-extern enum reg_class default_branch_target_register_class (void);\n+extern reg_class_t default_branch_target_register_class (void);\n #ifdef IRA_COVER_CLASSES\n-extern const enum reg_class *default_ira_cover_classes (void);\n+extern const reg_class_t *default_ira_cover_classes (void);\n #endif\n-extern enum reg_class default_secondary_reload (bool, rtx, enum reg_class,\n-\t\t\t\t\t\tenum machine_mode,\n-\t\t\t\t\t\tsecondary_reload_info *);\n+extern reg_class_t default_secondary_reload (bool, rtx, reg_class_t,\n+\t\t\t\t\t     enum machine_mode,\n+\t\t\t\t\t     secondary_reload_info *);\n extern void default_target_option_override (void);\n extern void hook_void_bitmap (bitmap);\n extern bool default_handle_c_option (size_t, const char *, int);\n@@ -147,7 +147,7 @@ extern bool default_addr_space_subset_p (addr_space_t, addr_space_t);\n extern rtx default_addr_space_convert (rtx, tree, tree);\n extern unsigned int default_case_values_threshold (void);\n extern bool default_have_conditional_execution (void);\n-extern int default_memory_move_cost (enum machine_mode, enum reg_class, bool);\n-extern int default_register_move_cost (enum machine_mode, enum reg_class,\n-\t\t\t\t       enum reg_class);\n+extern int default_memory_move_cost (enum machine_mode, reg_class_t, bool);\n+extern int default_register_move_cost (enum machine_mode, reg_class_t,\n+\t\t\t\t       reg_class_t);\n "}]}