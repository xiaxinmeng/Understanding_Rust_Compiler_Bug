{"sha": "ce552f75de9316942eb2762787ade0ac7684e299", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U1NTJmNzVkZTkzMTY5NDJlYjI3NjI3ODdhZGUwYWM3Njg0ZTI5OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-08-27T16:45:20Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-27T16:45:20Z"}, "message": "tree.h (size_int_type): Remove.\n\n\t* tree.h (size_int_type): Remove.\n\t* fold-const.c: Do not #include gt-fold-const.h.\n\t(size_htab_hash, size_htab_eq): Remove.\n\t(size_int_kind): Use build_int_cst.\n\t(new_const, size_htab): Remove.\n\t(size_int_type): Remove.\n\t(round_up): Use build_int_cst.\n\t(round_down): Likewise. Remove spurious constant build.\n\n\t* ada/utils2.c (build_allocator): Use ssize_int.\n\n\t* cp/class.c (build_vtbl_initializer): Use ssize_int.\n\t* cp/decl.c (complete_array_type): Likewise.\n\t* cp/method.c (finish_thunk): Likewise.\n\t* cp/search.c (get_dynamic_base_type): Likewise.\n\nFrom-SVN: r86667", "tree": {"sha": "0747dfb5ae0b38c647d928875f6ef8f699b58a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0747dfb5ae0b38c647d928875f6ef8f699b58a80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce552f75de9316942eb2762787ade0ac7684e299", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce552f75de9316942eb2762787ade0ac7684e299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce552f75de9316942eb2762787ade0ac7684e299", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce552f75de9316942eb2762787ade0ac7684e299/comments", "author": null, "committer": null, "parents": [{"sha": "06c37c965a32bf125f32111fac25707bee54708a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c37c965a32bf125f32111fac25707bee54708a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c37c965a32bf125f32111fac25707bee54708a"}], "stats": {"total": 143, "additions": 35, "deletions": 108}, "files": [{"sha": "5e5e1511092386092d88fcf234c83833a2d01253", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -1,3 +1,14 @@\n+2004-08-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h (size_int_type): Remove.\n+\t* fold-const.c: Do not #include gt-fold-const.h.\n+\t(size_htab_hash, size_htab_eq): Remove.\n+\t(size_int_kind): Use build_int_cst.\n+\t(new_const, size_htab): Remove.\n+\t(size_int_type): Remove.\n+\t(round_up): Use build_int_cst.\n+\t(round_down): Likewise. Remove spurious constant build.\n+\n 2004-08-27  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* configure.ac: Add ENABLE_ASSERT_CHECKING control."}, {"sha": "5d5187771efe1ad80166190799432f8c04c66a18", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -1,5 +1,7 @@\n 2004-08-27  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* utils2.c (build_allocator): Use ssize_int.\n+\n \t* utils.c (gnat_init_decl_processing): Ada has a signed sizetype.\n \n 2004-08-27  Andreas Schwab  <schwab@suse.de>"}, {"sha": "093e6f00feedf88c34d49c9491b3c035ab2efbb0", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -1799,7 +1799,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n       /* If the size overflows, pass -1 so the allocator will raise\n \t storage error.  */\n       if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n-\tsize = build_int_cst (ssizetype, -1);\n+\tsize = ssize_int (-1);\n \n       storage = build_call_alloc_dealloc (NULL_TREE, size,\n \t\t\t\t\t  TYPE_ALIGN (storage_type),\n@@ -1872,7 +1872,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n   /* If the size overflows, pass -1 so the allocator will raise\n      storage error.  */\n   if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n-    size = build_int_cst (ssizetype, -1);\n+    size = ssize_int (-1);\n \n   /* If this is a type whose alignment is larger than the\n      biggest we support in normal alignment and this is in"}, {"sha": "b2e109dbc367602482b3141cdf5ff7f0ab7529e4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -1,3 +1,10 @@\n+2004-08-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (build_vtbl_initializer): Use ssize_int.\n+\t* decl.c (complete_array_type): Likewise.\n+\t* method.c (finish_thunk): Likewise.\n+\t* search.c (get_dynamic_base_type): Likewise.\n+\n 2004-08-26  Richard Henderson  <rth@redhat.com>\n \n \t* cp-tree.h (DECL_FIELD_IS_BASE): New."}, {"sha": "8785de75b7d90494e82d194f9e4ca9dcb23971dc", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -7282,8 +7282,7 @@ build_vtbl_initializer (tree binfo,\n   vid.ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n   vid.generate_vcall_entries = true;\n   /* The first vbase or vcall offset is at index -3 in the vtable.  */\n-  vid.index = build_int_cst (ssizetype,\n-\t\t\t     -3 * TARGET_VTABLE_DATA_ENTRY_DISTANCE);\n+  vid.index = ssize_int(-3 * TARGET_VTABLE_DATA_ENTRY_DISTANCE);\n \n   /* Add entries to the vtable for RTTI.  */\n   build_rtti_vtbl_entries (binfo, &vid);"}, {"sha": "a5c6309deed03961fe6f8ba33ce6c5647bb453e2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -5260,7 +5260,7 @@ complete_array_type (tree type, tree initial_value, int do_default)\n \t{\n \t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n \n-\t  maxindex = build_int_cst (ssizetype, -1);\n+\t  maxindex = ssize_int (-1);\n \t  for (; elts; elts = TREE_CHAIN (elts))\n \t    {\n \t      if (TREE_PURPOSE (elts))"}, {"sha": "13fe0a492aa4bec2af32ac69d2c230fe35519d0f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -179,7 +179,7 @@ void\n finish_thunk (tree thunk)\n {\n   tree function, name;\n-  tree fixed_offset = build_int_cst (ssizetype, THUNK_FIXED_OFFSET (thunk));\n+  tree fixed_offset = ssize_int (THUNK_FIXED_OFFSET (thunk));\n   tree virtual_offset = THUNK_VIRTUAL_OFFSET (thunk);\n \n   my_friendly_assert (!DECL_NAME (thunk) && DECL_THUNK_P (thunk), 20021127);"}, {"sha": "c0342ad75de9c6fa3e1dde9f91c3af168c150670", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -347,7 +347,7 @@ get_dynamic_cast_base_type (tree subtype, tree target)\n   \n   if (!boff)\n     return offset;\n-  offset = build_int_cst (ssizetype, boff);\n+  offset = ssize_int (boff);\n   return offset;\n }\n "}, {"sha": "f728db60edc3fc815d4297651e86a7ed254b146e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 8, "deletions": 99, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -89,8 +89,6 @@ static tree negate_expr (tree);\n static tree split_tree (tree, enum tree_code, tree *, tree *, tree *, int);\n static tree associate_trees (tree, tree, enum tree_code, tree);\n static tree const_binop (enum tree_code, tree, tree, int);\n-static hashval_t size_htab_hash (const void *);\n-static int size_htab_eq (const void *, const void *);\n static tree fold_convert_const (enum tree_code, tree, tree);\n static enum tree_code invert_tree_comparison (enum tree_code, bool);\n static enum comparison_code comparison_to_compcode (enum tree_code);\n@@ -1597,101 +1595,15 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n   return 0;\n }\n \n-/* These are the hash table functions for the hash table of INTEGER_CST\n-   nodes of a sizetype.  */\n-\n-/* Return the hash code code X, an INTEGER_CST.  */\n-\n-static hashval_t\n-size_htab_hash (const void *x)\n-{\n-  tree t = (tree) x;\n-\n-  return (TREE_INT_CST_HIGH (t) ^ TREE_INT_CST_LOW (t)\n-\t  ^ htab_hash_pointer (TREE_TYPE (t))\n-\t  ^ (TREE_OVERFLOW (t) << 20));\n-}\n-\n-/* Return nonzero if the value represented by *X (an INTEGER_CST tree node)\n-   is the same as that given by *Y, which is the same.  */\n-\n-static int\n-size_htab_eq (const void *x, const void *y)\n-{\n-  tree xt = (tree) x;\n-  tree yt = (tree) y;\n-\n-  return (TREE_INT_CST_HIGH (xt) == TREE_INT_CST_HIGH (yt)\n-\t  && TREE_INT_CST_LOW (xt) == TREE_INT_CST_LOW (yt)\n-\t  && TREE_TYPE (xt) == TREE_TYPE (yt)\n-\t  && TREE_OVERFLOW (xt) == TREE_OVERFLOW (yt));\n-}\n-\f\n-/* Return an INTEGER_CST with value whose low-order HOST_BITS_PER_WIDE_INT\n-   bits are given by NUMBER and of the sizetype represented by KIND.  */\n+/* Create a size type INT_CST node with NUMBER sign extended.  KIND\n+   indicates which particular sizetype to create.  */\n \n tree\n size_int_kind (HOST_WIDE_INT number, enum size_type_kind kind)\n {\n-  return size_int_type (number, sizetype_tab[(int) kind]);\n+  return build_int_cst (sizetype_tab[(int) kind], number);\n }\n-\n-/* Likewise, but the desired type is specified explicitly.  */\n-\n-static GTY (()) tree new_const;\n-static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n-     htab_t size_htab;\n-\n-tree\n-size_int_type (HOST_WIDE_INT number, tree type)\n-{\n-  void **slot;\n-  unsigned int prec;\n-  HOST_WIDE_INT high;\n-  unsigned HOST_WIDE_INT low;\n-\n-  if (size_htab == 0)\n-    {\n-      size_htab = htab_create_ggc (1024, size_htab_hash, size_htab_eq, NULL);\n-      new_const = make_node (INTEGER_CST);\n-    }\n-\n-  /* Adjust NEW_CONST to be the constant we want.  If it's already in the\n-     hash table, we return the value from the hash table.  Otherwise, we\n-     place that in the hash table and make a new node for the next time.  */\n-  prec = TYPE_PRECISION (type);\n-  TREE_TYPE (new_const) = type;\n-  TREE_OVERFLOW (new_const) = TREE_CONSTANT_OVERFLOW (new_const) = 0;\n-  low = number;\n-  if (number >= 0)\n-    high = 0;\n-  else\n-    {\n-      /* Sizetype IS sign extended.  */\n-      high = -1;\n-      if (prec <= HOST_BITS_PER_WIDE_INT)\n-\tlow |= (HOST_WIDE_INT)(-1) << (prec - 1);\n-    }\n-  TREE_INT_CST_LOW (new_const) = low;\n-  TREE_INT_CST_HIGH (new_const) = high;\n-\n-  if (low != (unsigned HOST_WIDE_INT)number\n-      || high != (number < 0 ? -1 : 0))\n-    TREE_OVERFLOW (new_const) = TREE_CONSTANT_OVERFLOW (new_const) = 1;\n-  \n-  slot = htab_find_slot (size_htab, new_const, INSERT);\n-  if (*slot == 0)\n-    {\n-      tree t = new_const;\n-\n-      *slot = new_const;\n-      new_const = make_node (INTEGER_CST);\n-      return t;\n-    }\n-  else\n-    return (tree) *slot;\n-}\n-\n+\f\n /* Combine operands OP1 and OP2 with arithmetic operation CODE.  CODE\n    is a tree code.  The type of the result is taken from the operands.\n    Both must be the same type integer type and it must be a size type.\n@@ -10649,7 +10561,7 @@ round_up (tree value, int divisor)\n      doing it. */\n   if (TREE_CODE (value) != INTEGER_CST)\n     {\n-      div = size_int_type (divisor, TREE_TYPE (value));\n+      div = build_int_cst (TREE_TYPE (value), divisor);\n \n       if (multiple_of_p (TREE_TYPE (value), value, div))\n \treturn value;\n@@ -10668,7 +10580,7 @@ round_up (tree value, int divisor)\n   else\n     {\n       if (!div)\n-\tdiv = size_int_type (divisor, TREE_TYPE (value));\n+\tdiv = build_int_cst (TREE_TYPE (value), divisor);\n       value = size_binop (CEIL_DIV_EXPR, value, div);\n       value = size_binop (MULT_EXPR, value, div);\n     }\n@@ -10688,15 +10600,13 @@ round_down (tree value, int divisor)\n   if (divisor == 1)\n     return value;\n \n-  div = size_int_type (divisor, TREE_TYPE (value));\n-\n   /* See if VALUE is already a multiple of DIVISOR.  If so, we don't\n      have to do anything.  Only do this when we are not given a const,\n      because in that case, this check is more expensive than just\n      doing it. */\n   if (TREE_CODE (value) != INTEGER_CST)\n     {\n-      div = size_int_type (divisor, TREE_TYPE (value));\n+      div = build_int_cst (TREE_TYPE (value), divisor);\n \n       if (multiple_of_p (TREE_TYPE (value), value, div))\n \treturn value;\n@@ -10713,11 +10623,10 @@ round_down (tree value, int divisor)\n   else\n     {\n       if (!div)\n-\tdiv = size_int_type (divisor, TREE_TYPE (value));\n+\tdiv = build_int_cst (TREE_TYPE (value), divisor);\n       value = size_binop (FLOOR_DIV_EXPR, value, div);\n       value = size_binop (MULT_EXPR, value, div);\n     }\n \n   return value;\n }\n-#include \"gt-fold-const.h\""}, {"sha": "59905a47b87480a1ae4ed267ba188401abd45339", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce552f75de9316942eb2762787ade0ac7684e299/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ce552f75de9316942eb2762787ade0ac7684e299", "patch": "@@ -3091,10 +3091,9 @@ extern GTY(()) tree sizetype_tab[(int) TYPE_KIND_LAST];\n #define ssizetype sizetype_tab[(int) SSIZETYPE]\n #define sbitsizetype sizetype_tab[(int) SBITSIZETYPE]\n \n+extern tree size_int_kind (HOST_WIDE_INT, enum size_type_kind);\n extern tree size_binop (enum tree_code, tree, tree);\n extern tree size_diffop (tree, tree);\n-extern tree size_int_kind (HOST_WIDE_INT, enum size_type_kind);\n-extern tree size_int_type (HOST_WIDE_INT, tree);\n \n #define size_int(L) size_int_kind (L, SIZETYPE)\n #define ssize_int(L) size_int_kind (L, SSIZETYPE)"}]}