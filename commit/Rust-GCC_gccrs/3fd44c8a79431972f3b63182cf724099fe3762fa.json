{"sha": "3fd44c8a79431972f3b63182cf724099fe3762fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkNDRjOGE3OTQzMTk3MmYzYjYzMTgyY2Y3MjQwOTlmZTM3NjJmYQ==", "commit": {"author": {"name": "Carl Love", "email": "cel@us.ibm.com", "date": "2017-06-02T20:11:40Z"}, "committer": {"name": "Carl Love", "email": "carll@gcc.gnu.org", "date": "2017-06-02T20:11:40Z"}, "message": "rs6000-c: Add support for built-in functions vector double vec_doublee (vector signed int)...\n\ngcc/ChangeLog:\n\n2017-06-02  Carl Love  <cel@us.ibm.com>\n\n   * config/rs6000/rs6000-c: Add support for built-in functions\n   vector double vec_doublee (vector signed int);\n   vector double vec_doublee (vector unsigned int);\n   vector double vec_doublee (vector float);\n   vector double vec_doubleh (vector signed int);\n   vector double vec_doubleh (vector unsigned int);\n   vector double vec_doubleh (vector float);\n   vector double vec_doublel (vector signed int);\n   vector double vec_doublel (vector unsigned int);\n   vector double vec_doublel (vector float);\n   vector double vec_doubleo (vector signed int);\n   vector double vec_doubleo (vector unsigned int);\n   vector double vec_doubleo (vector float);.\n   * config/rs6000/rs6000-builtin.def: Add definitions for DOUBLEE,\n   DOUBLEO, DOUBLEH, DOUBLEL, UNS_DOUBLEO, UNS_DOUBLEE, UNS_DOUBLEH,\n   UNS_DOUBLEL.\n   * config/rs6000/altivec.md: Add code generator for doublee<mode>2,\n   unsdoubleev4si2, doubleo<mode>2, unsdoubleov4si2, doubleh<mode>2,\n   unsdoublehv4si2, doublel<mode>2, unsdoublelv4si2, add mode attribute\n   VS_sxwsp.\n   * config/rs6000/altivec.h: Add define for vec_doublee, vec_doubleo,\n   vec_doublel, vec_doubleh.\n   * doc/extend.texi: Update the built-in documentation file for the\n   new built-in functions.\n\n2017-06-02  Carl Love  <cel@us.ibm.com>\n\ngcc/testsuite/ChangeLog:\n\n   * gcc.target/powerpc/builtins-3-runnable.c: New file of runnable tests\n   for the new built-ins.\n\nFrom-SVN: r248846", "tree": {"sha": "a89d262a2d2e334793524af936aae2a00c40437d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a89d262a2d2e334793524af936aae2a00c40437d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fd44c8a79431972f3b63182cf724099fe3762fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd44c8a79431972f3b63182cf724099fe3762fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd44c8a79431972f3b63182cf724099fe3762fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd44c8a79431972f3b63182cf724099fe3762fa/comments", "author": {"login": "carlelove", "id": 86435705, "node_id": "MDQ6VXNlcjg2NDM1NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/86435705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carlelove", "html_url": "https://github.com/carlelove", "followers_url": "https://api.github.com/users/carlelove/followers", "following_url": "https://api.github.com/users/carlelove/following{/other_user}", "gists_url": "https://api.github.com/users/carlelove/gists{/gist_id}", "starred_url": "https://api.github.com/users/carlelove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carlelove/subscriptions", "organizations_url": "https://api.github.com/users/carlelove/orgs", "repos_url": "https://api.github.com/users/carlelove/repos", "events_url": "https://api.github.com/users/carlelove/events{/privacy}", "received_events_url": "https://api.github.com/users/carlelove/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c19e432d63ec411dfab13294ac02af2ff11516c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c19e432d63ec411dfab13294ac02af2ff11516c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c19e432d63ec411dfab13294ac02af2ff11516c"}], "stats": {"total": 525, "additions": 525, "deletions": 0}, "files": [{"sha": "dcb621615067c4fddd16bf36ccd52e76c314f700", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fd44c8a79431972f3b63182cf724099fe3762fa", "patch": "@@ -1,3 +1,30 @@\n+2017-06-02  Carl Love  <cel@us.ibm.com>\n+\n+\t* config/rs6000/rs6000-c: Add support for built-in functions\n+\tvector double vec_doublee (vector signed int);\n+\tvector double vec_doublee (vector unsigned int);\n+\tvector double vec_doublee (vector float);\n+\tvector double vec_doubleh (vector signed int);\n+\tvector double vec_doubleh (vector unsigned int);\n+\tvector double vec_doubleh (vector float);\n+\tvector double vec_doublel (vector signed int);\n+\tvector double vec_doublel (vector unsigned int);\n+\tvector double vec_doublel (vector float);\n+\tvector double vec_doubleo (vector signed int);\n+\tvector double vec_doubleo (vector unsigned int);\n+\tvector double vec_doubleo (vector float);.\n+\t* config/rs6000/rs6000-builtin.def: Add definitions for DOUBLEE,\n+\tDOUBLEO, DOUBLEH, DOUBLEL, UNS_DOUBLEO, UNS_DOUBLEE, UNS_DOUBLEH,\n+\tUNS_DOUBLEL.\n+\t* config/rs6000/altivec.md: Add code generator for doublee<mode>2,\n+\tunsdoubleev4si2, doubleo<mode>2, unsdoubleov4si2, doubleh<mode>2,\n+\tunsdoublehv4si2, doublel<mode>2, unsdoublelv4si2, add mode attribute\n+\tVS_sxwsp.\n+\t* config/rs6000/altivec.h: Add define for vec_doublee, vec_doubleo,\n+\tvec_doublel, vec_doubleh.\n+\t* doc/extend.texi: Update the built-in documentation file for the\n+\tnew built-in functions.\n+\n 2017-06-02  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/80954"}, {"sha": "20050ebde22e04e643c6e5612b1442fc096e97b1", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=3fd44c8a79431972f3b63182cf724099fe3762fa", "patch": "@@ -128,6 +128,10 @@\n #define vec_ctu __builtin_vec_ctu\n #define vec_cpsgn __builtin_vec_copysign\n #define vec_double __builtin_vec_double\n+#define vec_doublee __builtin_vec_doublee\n+#define vec_doubleo __builtin_vec_doubleo\n+#define vec_doublel __builtin_vec_doublel\n+#define vec_doubleh __builtin_vec_doubleh\n #define vec_expte __builtin_vec_expte\n #define vec_floor __builtin_vec_floor\n #define vec_loge __builtin_vec_loge"}, {"sha": "404cc4eb8aca485cdd850c8de79b71cbf4c30a50", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=3fd44c8a79431972f3b63182cf724099fe3762fa", "patch": "@@ -203,6 +203,10 @@\n \t\t\t   (KF \"FLOAT128_VECTOR_P (KFmode)\")\n \t\t\t   (TF \"FLOAT128_VECTOR_P (TFmode)\")])\n \n+;; Map the Vector convert single precision to double precision for integer\n+;; versus floating point\n+(define_mode_attr VS_sxwsp [(V4SI \"sxw\") (V4SF \"sp\")])\n+\n ;; Specific iterator for parity which does not have a byte/half-word form, but\n ;; does have a quad word form\n (define_mode_iterator VParity [V4SI\n@@ -2739,6 +2743,339 @@\n   \"stvewx %1,%y0\"\n   [(set_attr \"type\" \"vecstore\")])\n \n+;; Generate doublee\n+;; signed int/float to double convert words 0 and 2\n+(define_expand \"doublee<mode>2\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(match_operand:VSX_W 1 \"register_operand\" \"v\"))]\n+  \"TARGET_VSX\"\n+{\n+  machine_mode op_mode = GET_MODE (operands[1]);\n+\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      /* Big endian word numbering for words in operand is 0 1 2 3.\n+\t Input words 0 and 2 are where they need to be.  */\n+      emit_insn (gen_vsx_xvcv<VS_sxwsp>dp (operands[0], operands[1]));\n+    }\n+  else\n+    {\n+      /* Little endian word numbering for operand is 3 2 1 0.\n+\t take (operand[1] operand[1]) and shift left one word\n+\t 3 2 1 0    3 2 1 0  =>  2 1 0 3\n+\t Input words 2 and 0 are now where they need to be for the\n+\t conversion.  */\n+      rtx rtx_tmp;\n+      rtx rtx_val = GEN_INT (1);\n+\n+      rtx_tmp = gen_reg_rtx (op_mode);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, operands[1],\n+\t\t\t\t\t operands[1], rtx_val));\n+      emit_insn (gen_vsx_xvcv<VS_sxwsp>dp (operands[0], rtx_tmp));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n+;; Generate unsdoublee\n+;; unsigned int to double convert words 0 and 2\n+(define_expand \"unsdoubleev4si2\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(match_operand:V4SI 1 \"register_operand\" \"v\"))]\n+  \"TARGET_VSX\"\n+{\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      /* Big endian word numbering for words in operand is 0 1 2 3.\n+\t Input words 0 and 2 are where they need to be.  */\n+      emit_insn (gen_vsx_xvcvuxwdp (operands[0], operands[1]));\n+    }\n+  else\n+    {\n+      /* Little endian word numbering for operand is 3 2 1 0.\n+\t take (operand[1] operand[1]) and shift left one word\n+\t 3 2 1 0    3 2 1 0  =>   2 1 0 3\n+\t Input words 2 and 0 are now where they need to be for the\n+\t conversion.  */\n+      rtx rtx_tmp;\n+      rtx rtx_val = GEN_INT (1);\n+\n+      rtx_tmp = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, operands[1],\n+\t\t\t\t       operands[1], rtx_val));\n+      emit_insn (gen_vsx_xvcvuxwdp (operands[0], rtx_tmp));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n+;; Generate doubleov\n+;; signed int/float to double convert words 1 and 3\n+(define_expand \"doubleo<mode>2\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(match_operand:VSX_W 1 \"register_operand\" \"v\"))]\n+  \"TARGET_VSX\"\n+{\n+  machine_mode op_mode = GET_MODE (operands[1]);\n+\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      /* Big endian word numbering for words in operand is 0 1 2 3.\n+\t take (operand[1] operand[1]) and shift left one word\n+\t 0 1 2 3    0 1 2 3  =>  1 2 3 0\n+\t Input words 1 and 3 are now where they need to be for the\n+\t conversion.  */\n+      rtx rtx_tmp;\n+      rtx rtx_val = GEN_INT (1);\n+\n+      rtx_tmp = gen_reg_rtx (op_mode);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, operands[1],\n+\t\t\t\t\t operands[1], rtx_val));\n+      emit_insn (gen_vsx_xvcv<VS_sxwsp>dp (operands[0], rtx_tmp));\n+    }\n+  else\n+    {\n+      /* Little endian word numbering for operand is 3 2 1 0.\n+\t Input words 3 and 1 are where they need to be.  */\n+      emit_insn (gen_vsx_xvcv<VS_sxwsp>dp (operands[0], operands[1]));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n+;; Generate unsdoubleov\n+;; unsigned int to double convert words 1 and 3\n+(define_expand \"unsdoubleov4si2\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(match_operand:V4SI 1 \"register_operand\" \"v\"))]\n+  \"TARGET_VSX\"\n+{\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      /* Big endian word numbering for words in operand is 0 1 2 3.\n+\t take (operand[1] operand[1]) and shift left one word\n+\t 0 1 2 3    0 1 2 3  =>  1 2 3 0\n+\t Input words 1 and 3 are now where they need to be for the\n+\t conversion.  */\n+      rtx rtx_tmp;\n+      rtx rtx_val = GEN_INT (1);\n+\n+      rtx_tmp = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, operands[1],\n+\t\t\t\t       operands[1], rtx_val));\n+      emit_insn (gen_vsx_xvcvuxwdp (operands[0], rtx_tmp));\n+    }\n+  else\n+    {\n+      /* Want to convert the words 1 and 3.\n+\t Little endian word numbering for operand is 3 2 1 0.\n+\t Input words 3 and 1 are where they need to be.  */\n+      emit_insn (gen_vsx_xvcvuxwdp (operands[0], operands[1]));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n+;; Generate doublehv\n+;; signed int/float to double convert words 0 and 1\n+(define_expand \"doubleh<mode>2\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(match_operand:VSX_W 1 \"register_operand\" \"v\"))]\n+  \"TARGET_VSX\"\n+{\n+  rtx rtx_tmp;\n+  rtx rtx_val;\n+\n+  machine_mode op_mode = GET_MODE (operands[1]);\n+  rtx_tmp = gen_reg_rtx (op_mode);\n+\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      /* Big endian word numbering for words in operand is 0 1 2 3.\n+\t Shift operand left one word, rtx_tmp word order is now 1 2 3 0.\n+\t take (rts_tmp operand[1]) and shift left three words\n+\t 1 2 3 0  0 1 2 3 => 0 0 1 2\n+\t Input words 0 and 1 are now where they need to be for the\n+\t conversion.  */\n+      rtx_val = GEN_INT (1);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, operands[1],\n+\t\t\t\t\t operands[1], rtx_val));\n+\n+      rtx_val = GEN_INT (3);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, rtx_tmp,\n+\t\t\t\t\t operands[1], rtx_val));\n+      emit_insn (gen_vsx_xvcv<VS_sxwsp>dp (operands[0], rtx_tmp));\n+    }\n+  else\n+    {\n+      /* Little endian word numbering for operand is 3 2 1 0.\n+\t Shift operand left three words, rtx_tmp word order is now 0 3 2 1.\n+\t take (operand[1] rts_tmp) and shift left two words\n+\t 3 2 1 0  0 3 2 1   =>  1 0 0 3\n+\t Input words 0 and 1 are now where they need to be for the\n+\t conversion.  */\n+      rtx_val = GEN_INT (3);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, operands[1],\n+\t\t\t\t\t operands[1], rtx_val));\n+\n+      rtx_val = GEN_INT (2);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, operands[1],\n+\t\t\t\t\t rtx_tmp, rtx_val));\n+      emit_insn (gen_vsx_xvcv<VS_sxwsp>dp (operands[0], rtx_tmp));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n+;; Generate unsdoublehv\n+;; unsigned int to double convert words 0 and 1\n+(define_expand \"unsdoublehv4si2\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(match_operand:V4SI 1 \"register_operand\" \"v\"))]\n+  \"TARGET_VSX\"\n+{\n+  rtx rtx_tmp = gen_reg_rtx (V4SImode);\n+  rtx rtx_val = GEN_INT (12);\n+\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      /* Big endian word numbering for words in operand is 0 1 2 3.\n+\t Shift operand left one word, rtx_tmp word order is now 1 2 3 0.\n+\t take (rts_tmp operand[1]) and shift left three words\n+\t 1 2 3 0  0 1 2 3 => 0 0 1 2\n+\t Input words 0 and 1 are now where they need to be for the\n+\t conversion.  */\n+      rtx_val = GEN_INT (1);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, operands[1],\n+\t\t\t\t       operands[1], rtx_val));\n+\n+      rtx_val = GEN_INT (3);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, rtx_tmp,\n+\t\t\t\t       operands[1], rtx_val));\n+      emit_insn (gen_vsx_xvcvuxwdp (operands[0], rtx_tmp));\n+    }\n+  else\n+    {\n+      /* Little endian word numbering for operand is 3 2 1 0.\n+\t Shift operand left three words, rtx_tmp word order is now 0 3 2 1.\n+\t take (operand[1] rts_tmp) and shift left two words\n+\t 3 2 1 0   0 3 2 1  =>   1 0 0 3\n+\t Input words 1 and 0 are now where they need to be for the\n+\t conversion.  */\n+      rtx_val = GEN_INT (3);\n+\n+      rtx_tmp = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, operands[1],\n+\t\t\t\t       operands[1], rtx_val));\n+\n+      rtx_val = GEN_INT (2);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, operands[1],\n+\t\t\t\t       rtx_tmp, rtx_val));\n+      emit_insn (gen_vsx_xvcvuxwdp (operands[0], rtx_tmp));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n+;; Generate doublelv\n+;; signed int/float to double convert words 2 and 3\n+(define_expand \"doublel<mode>2\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(match_operand:VSX_W 1 \"register_operand\" \"v\"))]\n+  \"TARGET_VSX\"\n+{\n+  rtx rtx_tmp;\n+  rtx rtx_val = GEN_INT (3);\n+\n+  machine_mode op_mode = GET_MODE (operands[1]);\n+  rtx_tmp = gen_reg_rtx (op_mode);\n+\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      /* Big endian word numbering for operand is 0 1 2 3.\n+\t Shift operand left three words, rtx_tmp word order is now 3 0 1 2.\n+\t take (operand[1] rtx_tmp) and shift left two words\n+\t 0 1 2 3   3 0 1 2  =>  2 3 3 0\n+\t now use convert instruction to convert word 2 and 3 in the\n+\t input vector.  */\n+      rtx_val = GEN_INT (3);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, operands[1],\n+\t\t\t\t\t operands[1], rtx_val));\n+\n+      rtx_val = GEN_INT (8);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, operands[1],\n+\t\t\t\t\t rtx_tmp, rtx_val));\n+      emit_insn (gen_vsx_xvcv<VS_sxwsp>dp (operands[0], rtx_tmp));\n+    }\n+  else\n+    {\n+      /* Little endian word numbering for operand is 3 2 1 0.\n+\t Shift operand left one word, rtx_tmp word order is now  2 1 0 3.\n+\t take (rtx_tmp operand[1]) and shift left three words\n+\t 2 1 0 3  3 2 1 0  =>  3 3 2 1\n+\t now use convert instruction to convert word 3 and 2 in the\n+\t input vector.  */\n+      rtx_val = GEN_INT (1);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, operands[1],\n+\t\t\t\t\t operands[1], rtx_val));\n+\n+      rtx_val = GEN_INT (3);\n+      emit_insn (gen_vsx_xxsldwi_<mode> (rtx_tmp, rtx_tmp,\n+\t\t\t\t\t operands[1], rtx_val));\n+      emit_insn (gen_vsx_xvcv<VS_sxwsp>dp (operands[0], rtx_tmp));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n+;; Generate unsdoublelv\n+;; unsigned int to double convert convert 2 and 3\n+(define_expand \"unsdoublelv4si2\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=v\")\n+\t(match_operand:V4SI 1 \"register_operand\" \"v\"))]\n+  \"TARGET_VSX\"\n+{\n+  rtx rtx_tmp = gen_reg_rtx (V4SImode);\n+  rtx rtx_val = GEN_INT (12);\n+\n+  if (VECTOR_ELT_ORDER_BIG)\n+    {\n+      /* Big endian word numbering for operand is 0 1 2 3.\n+\t Shift operand left three words, rtx_tmp word order is now 3 0 1 2.\n+\t take (operand[1] rtx_tmp) and shift left two words\n+\t 0 1 2 3   3 0 1 2  =>  2 3 3 0\n+\t now use convert instruction to convert word 2 and 3 in the\n+\t input vector.  */\n+      rtx_val = GEN_INT (3);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, operands[1],\n+\t\t\t\t       operands[1], rtx_val));\n+\n+      rtx_val = GEN_INT (2);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, operands[1],\n+\t\t\t\t       rtx_tmp, rtx_val));\n+      emit_insn (gen_vsx_xvcvuxwdp (operands[0], rtx_tmp));\n+    }\n+  else\n+    {\n+      /* Little endian word numbering for operand is 3 2 1 0.\n+\t Shift operand left one word, rtx_tmp word order is now 2 1 0 3.\n+\t take (rtx_tmp operand[1]) and shift left three words\n+\t 2 1 0 3  3 2 1 0  =>   3 3 2 1\n+\t now use convert instruction to convert word 3 and 2 in the\n+\t input vector.  */\n+      rtx_val = GEN_INT (1);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp,\n+      operands[1], operands[1], rtx_val));\n+\n+      rtx_val = GEN_INT (3);\n+      emit_insn (gen_vsx_xxsldwi_v4si (rtx_tmp, rtx_tmp,\n+\t\t\t\t       operands[1], rtx_val));\n+      emit_insn (gen_vsx_xvcvuxwdp (operands[0], rtx_tmp));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n ;; Generate\n ;;    xxlxor/vxor SCRATCH0,SCRATCH0,SCRATCH0\n ;;    vsubu?m SCRATCH2,SCRATCH1,%1"}, {"sha": "de6b2ccee1f2b13f98042c427d7a30c92ad3b690", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=3fd44c8a79431972f3b63182cf724099fe3762fa", "patch": "@@ -1719,6 +1719,19 @@ BU_VSX_1 (XSRDPIM,\t      \"xsrdpim\",\tCONST,\tfloordf2)\n BU_VSX_1 (XSRDPIP,\t      \"xsrdpip\",\tCONST,\tceildf2)\n BU_VSX_1 (XSRDPIZ,\t      \"xsrdpiz\",\tCONST,\tbtruncdf2)\n \n+BU_VSX_1 (DOUBLEE_V4SI,      \"doublee_v4si\",     CONST,\tdoubleev4si2)\n+BU_VSX_1 (DOUBLEE_V4SF,      \"doublee_v4sf\",     CONST,\tdoubleev4sf2)\n+BU_VSX_1 (UNS_DOUBLEE_V4SI,  \"uns_doublee_v4si\", CONST,\tunsdoubleev4si2)\n+BU_VSX_1 (DOUBLEO_V4SI,      \"doubleo_v4si\",     CONST,\tdoubleov4si2)\n+BU_VSX_1 (DOUBLEO_V4SF,      \"doubleo_v4sf\",     CONST,\tdoubleov4sf2)\n+BU_VSX_1 (UNS_DOUBLEO_V4SI,  \"uns_doubleo_v4si\", CONST,\tunsdoubleov4si2)\n+BU_VSX_1 (DOUBLEH_V4SI,      \"doubleh_v4si\",     CONST,\tdoublehv4si2)\n+BU_VSX_1 (DOUBLEH_V4SF,      \"doubleh_v4sf\",     CONST,\tdoublehv4sf2)\n+BU_VSX_1 (UNS_DOUBLEH_V4SI,  \"uns_doubleh_v4si\", CONST,\tunsdoublehv4si2)\n+BU_VSX_1 (DOUBLEL_V4SI,      \"doublel_v4si\",     CONST,\tdoublelv4si2)\n+BU_VSX_1 (DOUBLEL_V4SF,      \"doublel_v4sf\",     CONST,\tdoublelv4sf2)\n+BU_VSX_1 (UNS_DOUBLEL_V4SI,  \"uns_doublel_v4si\", CONST,\tunsdoublelv4si2)\n+\n /* VSX predicate functions.  */\n BU_VSX_P (XVCMPEQSP_P,\t      \"xvcmpeqsp_p\",\tCONST,\tvector_eq_v4sf_p)\n BU_VSX_P (XVCMPGESP_P,\t      \"xvcmpgesp_p\",\tCONST,\tvector_ge_v4sf_p)\n@@ -1809,6 +1822,14 @@ BU_VSX_OVERLOAD_2 (XXSPLTW,  \"xxspltw\")\n \n /* 1 argument VSX overloaded builtin functions.  */\n BU_VSX_OVERLOAD_1 (DOUBLE,   \"double\")\n+BU_VSX_OVERLOAD_1 (DOUBLEE,  \"doublee\")\n+BU_VSX_OVERLOAD_1 (UNS_DOUBLEE,  \"uns_doublee\")\n+BU_VSX_OVERLOAD_1 (DOUBLEO,  \"doubleo\")\n+BU_VSX_OVERLOAD_1 (UNS_DOUBLEO,  \"uns_doubleo\")\n+BU_VSX_OVERLOAD_1 (DOUBLEH,  \"doubleh\")\n+BU_VSX_OVERLOAD_1 (UNS_DOUBLEH,  \"uns_doubleh\")\n+BU_VSX_OVERLOAD_1 (DOUBLEL,  \"doublel\")\n+BU_VSX_OVERLOAD_1 (UNS_DOUBLEL,  \"uns_doublel\")\n \n /* VSX builtins that are handled as special cases.  */\n BU_VSX_OVERLOAD_X (LD,\t     \"ld\")"}, {"sha": "b602dee8c236e8d83bc853af5e0fd8baed4faf44", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=3fd44c8a79431972f3b63182cf724099fe3762fa", "patch": "@@ -1513,6 +1513,35 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_V2DF, RS6000_BTI_V2DI, 0, 0 },\n   { VSX_BUILTIN_VEC_DOUBLE, VSX_BUILTIN_XVCVUXDDP,\n     RS6000_BTI_V2DF, RS6000_BTI_unsigned_V2DI, 0, 0 },\n+\n+  { VSX_BUILTIN_VEC_DOUBLEE, VSX_BUILTIN_DOUBLEE_V4SI,\n+    RS6000_BTI_V2DF, RS6000_BTI_V4SI, 0, 0 },\n+  { VSX_BUILTIN_VEC_DOUBLEE, VSX_BUILTIN_UNS_DOUBLEE_V4SI,\n+    RS6000_BTI_V2DF, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+  { VSX_BUILTIN_VEC_DOUBLEE, VSX_BUILTIN_DOUBLEE_V4SF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },\n+\n+  { VSX_BUILTIN_VEC_DOUBLEO, VSX_BUILTIN_DOUBLEO_V4SI,\n+    RS6000_BTI_V2DF, RS6000_BTI_V4SI, 0, 0 },\n+  { VSX_BUILTIN_VEC_DOUBLEO, VSX_BUILTIN_UNS_DOUBLEO_V4SI,\n+    RS6000_BTI_V2DF, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+  { VSX_BUILTIN_VEC_DOUBLEO, VSX_BUILTIN_DOUBLEO_V4SF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },\n+\n+  { VSX_BUILTIN_VEC_DOUBLEH, VSX_BUILTIN_DOUBLEH_V4SI,\n+    RS6000_BTI_V2DF, RS6000_BTI_V4SI, 0, 0 },\n+  { VSX_BUILTIN_VEC_DOUBLEH, VSX_BUILTIN_UNS_DOUBLEH_V4SI,\n+    RS6000_BTI_V2DF, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+  { VSX_BUILTIN_VEC_DOUBLEH, VSX_BUILTIN_DOUBLEH_V4SF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },\n+\n+  { VSX_BUILTIN_VEC_DOUBLEL, VSX_BUILTIN_DOUBLEL_V4SI,\n+    RS6000_BTI_V2DF, RS6000_BTI_V4SI, 0, 0 },\n+  { VSX_BUILTIN_VEC_DOUBLEL, VSX_BUILTIN_UNS_DOUBLEL_V4SI,\n+    RS6000_BTI_V2DF, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+  { VSX_BUILTIN_VEC_DOUBLEL, VSX_BUILTIN_DOUBLEL_V4SF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },\n+\n   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,\n     RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },\n   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,"}, {"sha": "60a1a3f67cf1170ac6d126d1fa168716e849ba03", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=3fd44c8a79431972f3b63182cf724099fe3762fa", "patch": "@@ -15872,6 +15872,22 @@ vector signed long vec_cts (vector double, const int);\n vector unsigned int vec_ctu (vector float, const int);\n vector unsigned long vec_ctu (vector double, const int);\n \n+vector double vec_doublee (vector float);\n+vector double vec_doublee (vector signed int);\n+vector double vec_doublee (vector unsigned int);\n+\n+vector double vec_doubleo (vector float);\n+vector double vec_doubleo (vector signed int);\n+vector double vec_doubleo (vector unsigned int);\n+\n+vector double vec_doubleh (vector float);\n+vector double vec_doubleh (vector signed int);\n+vector double vec_doubleh (vector unsigned int);\n+\n+vector double vec_doublel (vector float);\n+vector double vec_doublel (vector signed int);\n+vector double vec_doublel (vector unsigned int);\n+\n void vec_dss (const int);\n \n void vec_dssall (void);"}, {"sha": "9af9ca8c667f0c46e32697c7889d3ecbef2dfb73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fd44c8a79431972f3b63182cf724099fe3762fa", "patch": "@@ -1,3 +1,10 @@\n+2017-06-02  Carl Love  <cel@us.ibm.com>\n+\n+gcc/testsuite/ChangeLog:\n+\n+\t* gcc.target/powerpc/builtins-3-runnable.c: New file of runnable tests\n+\tfor the new built-ins.\n+\n 2017-06-02  Sudakshina Das  <sudi.das@arm.com>\n \n \t* gcc.target/aarch64/cmp_shifted_reg_1.c: New."}, {"sha": "60ec617ab1a288f0f83befe8f6230dc5a45dc227", "filename": "gcc/testsuite/gcc.target/powerpc/builtins-3-runnable.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltins-3-runnable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd44c8a79431972f3b63182cf724099fe3762fa/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltins-3-runnable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbuiltins-3-runnable.c?ref=3fd44c8a79431972f3b63182cf724099fe3762fa", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx -mcpu=power8\" } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+\n+#include <altivec.h> // vector\n+\n+void abort (void);\n+\n+void test_result_dp(vector double vec_result, vector double vec_expected)\n+{\n+\tif (vec_result[0] != vec_expected[0])\n+\t\tabort();\n+\n+\tif (vec_result[1] != vec_expected[1])\n+\t\tabort();\n+}\n+\n+int main()\n+{\n+\tint i;\n+\tvector unsigned int vec_unint;\n+\tvector signed int vec_int;\n+\tvector float  vec_flt, vec_flt_result, vec_flt_expected;\n+\tvector double vec_dble0, vec_dble1, vec_dble_result, vec_dble_expected;\n+\n+\tvec_int = (vector signed int){ -1, 3, -5, 1234567 };\n+\tvec_unint = (vector unsigned int){ 9, 11, 15, 2468013579 };\n+\tvec_flt = (vector float){ -21., 3.5, -53., 78. };\n+\tvec_dble0 = (vector double){ 34.0, 97.0 };\n+\tvec_dble1 = (vector double){ 214.0, -5.5 };\n+\n+\t/* conversion of words 0 and 2 */\n+\tvec_dble_expected = (vector double){-1.000000, -5.000000};\n+\tvec_dble_result = vec_doublee (vec_int);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+\t\n+\tvec_dble_expected = (vector double){9.000000, 15.000000};\n+\tvec_dble_result = vec_doublee (vec_unint);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+\n+\tvec_dble_expected = (vector double){-21.000000, -53.000000};\n+\tvec_dble_result = vec_doublee (vec_flt);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+\n+\n+\t/* conversion of words 1 and 3 */\n+\tvec_dble_expected = (vector double){3.000000, 1234567.000000};\n+\tvec_dble_result = vec_doubleo (vec_int);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+   \n+\tvec_dble_expected = (vector double){11.000000, 2468013579.000000};\n+\tvec_dble_result = vec_doubleo (vec_unint);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+\n+\tvec_dble_expected = (vector double){3.500000, 78.000000};\n+\tvec_dble_result = vec_doubleo (vec_flt);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+\n+\n+\t/* conversion of words 0 and 1 */\n+\tvec_dble_expected = (vector double){-5.000000, 1234567.000000};\n+\tvec_dble_result = vec_doublel (vec_int);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+   \n+\tvec_dble_expected = (vector double){15.000000, 2468013579.000000};\n+\tvec_dble_result = vec_doublel (vec_unint);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+\n+\tvec_dble_expected = (vector double){-53.000000, 78.000000};\n+\tvec_dble_result = vec_doublel (vec_flt);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+\n+   \n+\t/* conversion of words 2 and 3 */\n+\tvec_dble_expected = (vector double){-1.000000, 3.000000};\n+\tvec_dble_result = vec_doubleh (vec_int);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+   \n+\tvec_dble_expected = (vector double){9.000000, 11.000000};\n+\tvec_dble_result = vec_doubleh (vec_unint);\n+\ttest_result_dp(vec_dble_result, vec_dble_expected);\n+\n+}"}]}