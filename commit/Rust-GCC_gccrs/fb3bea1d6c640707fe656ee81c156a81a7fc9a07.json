{"sha": "fb3bea1d6c640707fe656ee81c156a81a7fc9a07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIzYmVhMWQ2YzY0MDcwN2ZlNjU2ZWU4MWMxNTZhODFhN2ZjOWEwNw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-06-17T03:52:24Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-06-17T03:52:24Z"}, "message": "* java/io/LineNumberInputStream.java: Merged with Classpath.\n\nFrom-SVN: r54691", "tree": {"sha": "fdb019b1cc50c45407648ac6a22514f11d87b234", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb019b1cc50c45407648ac6a22514f11d87b234"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb3bea1d6c640707fe656ee81c156a81a7fc9a07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3bea1d6c640707fe656ee81c156a81a7fc9a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3bea1d6c640707fe656ee81c156a81a7fc9a07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3bea1d6c640707fe656ee81c156a81a7fc9a07/comments", "author": null, "committer": null, "parents": [{"sha": "fd852454b1cefd1a004cded6f5afd7332d5b6f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd852454b1cefd1a004cded6f5afd7332d5b6f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd852454b1cefd1a004cded6f5afd7332d5b6f81"}], "stats": {"total": 208, "additions": 191, "deletions": 17}, "files": [{"sha": "313353c59eeb053ae51cffa1e3ce3467f33ce440", "filename": "libjava/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3bea1d6c640707fe656ee81c156a81a7fc9a07/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3bea1d6c640707fe656ee81c156a81a7fc9a07/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fb3bea1d6c640707fe656ee81c156a81a7fc9a07", "patch": "@@ -1,5 +1,7 @@\n 2002-06-16  Tom Tromey  <tromey@redhat.com>\n \n+\t* java/io/LineNumberInputStream.java: Merged with Classpath.\n+\n \t* java/lang/RuntimeException.java: Re-merge with Classpath.\n \t* java/util/ArrayList.java: Likewise.\n \t* java/util/Arrays.java: Likewise."}, {"sha": "4a4d68a3d706776e21ca481109fa12182e7c0015", "filename": "libjava/java/io/LineNumberInputStream.java", "status": "modified", "additions": 189, "deletions": 17, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3bea1d6c640707fe656ee81c156a81a7fc9a07/libjava%2Fjava%2Fio%2FLineNumberInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3bea1d6c640707fe656ee81c156a81a7fc9a07/libjava%2Fjava%2Fio%2FLineNumberInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FLineNumberInputStream.java?ref=fb3bea1d6c640707fe656ee81c156a81a7fc9a07", "patch": "@@ -1,59 +1,178 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* LineNumberInputStream.java -- An input stream which counts line numbers\n+   Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n package java.io;\n \n /**\n+ * This class functions like a standard <code>InputStream</code>\n+ * except that it counts line numbers, and canonicalizes newline\n+ * characters.  As data is read, whenever the byte sequences \"\\r\",\n+ * \"\\n\", or \"\\r\\n\" are encountered, the running line count is\n+ * incremeted by one.  Additionally, the whatever line termination\n+ * sequence was encountered will be converted to a \"\\n\" byte.  Note\n+ * that this class numbers lines from 0.  When the first line\n+ * terminator is encountered, the line number is incremented to 1, and\n+ * so on.\n+ * <p>\n+ * This class counts only line termination characters.  If the last line\n+ * read from the stream does not end in a line termination sequence, it\n+ * will not be counted as a line.\n+ * <p>\n+ * Note that since this class operates as a filter on an underlying\n+ * stream, it has the same mark/reset functionality as the underlying\n+ * stream.  The <code>mark()</code> and <code>reset()</code> methods\n+ * in this class handle line numbers correctly.  Calling\n+ * @code{reset()} resets the line number to the point at which\n+ * <code>mark()</code> was called if the subordinate stream supports\n+ * that functionality.\n+ * <p>\n+ * @deprecated This class is deprecated in favor if\n+ * <code>LineNumberReader</code> because it operates on ASCII bytes\n+ * instead of an encoded character stream.  This class is for backward\n+ * compatibility only and should not be used in new applications.\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Warren Levy <warrenl@cygnus.com>\n- * @date November 11, 1998.\n- * @deprecated \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.  Deprecated in JDK 1.1.\n  */\n- \n public class LineNumberInputStream extends FilterInputStream\n {\n-  /* The current line number. */\n+  /** The current line number. */\n   private int lineNumber = 0;\n \n-  /* The line number when the stream was marked. */\n+  /** The line number when the stream was marked. */\n   private int markLineNumber = 0;\n \n-  /* Flag to indicate a '\\r' was just read so that an immediately subsequent\n-   * '\\n' can be ignored. */\n+  /** Flag to indicate a '\\r' was just read so that an immediately\n+   * subsequent '\\n' can be ignored. */\n   private boolean justReadReturnChar = false;\n \n+  /**\n+   * Create a new <code>LineNumberInputStream</code> that reads from the \n+   * specified subordinate <code>InputStream</code>\n+   *\n+   * @param in The subordinate <code>InputStream</code> to read from\n+   */\n   public LineNumberInputStream(InputStream in)\n   {\n     super(in);\n   }\n \n+  /**\n+   * This method returns the number of bytes that can be read from the\n+   * stream before the stream can block.  This method is tricky\n+   * because the subordinate <code>InputStream</code> might return\n+   * only \"\\r\\n\" characters, which are replaced by a single \"\\n\"\n+   * character by the <code>read()</code> method of this class.  So\n+   * this method can only guarantee that <code>in.available() /\n+   * 2</code> bytes can actually be read before blocking.  In\n+   * practice, considerably more bytes might be read before blocking\n+   * <p>\n+   * Note that the stream may not block if additional bytes beyond the count\n+   * returned by this method are read.\n+   *\n+   * @return The number of bytes that can be read before blocking could occur\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int available() throws IOException\n   {\n     // We can only guarantee half the characters that might be available\n     // without blocking because \"\\r\\n\" is treated as a single character.\n     return in.available() / 2;\n   }\n \n+  /**\n+   * This method returns the current line number\n+   *\n+   * @returns The current line number\n+   */\n   public int getLineNumber()\n   {\n     return lineNumber;\n   }\n \n+  /**\n+   * This method marks a position in the input to which the stream can\n+   * be \"reset\" byte calling the <code>reset()</code> method.  The\n+   * parameter <code>readlimit</code> is the number of bytes that can\n+   * be read from the stream after setting the mark before the mark\n+   * becomes invalid.  For example, if <code>mark()</code> is called\n+   * with a read limit of 10, then when 11 bytes of data are read from\n+   * the stream before the <code>reset()</code> method is called, then\n+   * the mark is invalid and the stream object instance is not\n+   * required to remember the mark.\n+   * <p>\n+   * In this class, this method will remember the current line number\n+   * as well as the current position in the stream.  When the\n+   * <code>reset()</code> method is called, the line number will be\n+   * restored to the saved line number in addition to the stream\n+   * position.\n+   * <p>\n+   * This method only works if the subordinate stream supports mark/reset\n+   * functionality.\n+   *\n+   * @param readlimit The number of bytes that can be read before the\n+   * mark becomes invalid \n+   */\n   public void mark(int readlimit)\n   {\n     in.mark(readlimit);\n     markLineNumber = lineNumber;\n   }\n \n+  /**\n+   * This method reads an unsigned byte from the input stream and returns it\n+   * as an int in the range of 0-255.  This method will return -1 if the\n+   * end of the stream has been reached.\n+   * <p>\n+   * Note that if a line termination sequence is encountered (ie, \"\\r\",\n+   * \"\\n\", or \"\\r\\n\") then that line termination sequence is converted to\n+   * a single \"\\n\" value which is returned from this method.  This means\n+   * that it is possible this method reads two bytes from the subordinate\n+   * stream instead of just one.\n+   * <p>\n+   * Note that this method will block until a byte of data is available\n+   * to be read.\n+   *\n+   * @return The byte read or -1 if end of stream\n+   * \n+   * @exception IOException If an error occurs\n+   */\n   public int read() throws IOException\n   {\n     // Treat \"\\r\\n\" as a single character.  A '\\r' may have been read by\n@@ -82,6 +201,29 @@ else if (ch == '\\r')\n     return ch;\n   }\n \n+  /**\n+   * This method reads bytes from a stream and stores them into a caller\n+   * supplied buffer.  It starts storing data at index <code>offset</code> into\n+   * the buffer and attemps to read <code>len</code> bytes.  This method can\n+   * return before reading the number of bytes requested.  The actual number\n+   * of bytes read is returned as an int.  A -1 is returned to indicated the\n+   * end of the stream.\n+   * <p>\n+   * This method will block until some data can be read.\n+   * <p>\n+   * Note that if a line termination sequence is encountered (ie, \"\\r\",\n+   * \"\\n\", or \"\\r\\n\") then that line termination sequence is converted to\n+   * a single \"\\n\" value which is stored in the buffer.  Only a single\n+   * byte is counted towards the number of bytes read in this case.\n+   *\n+   * @param buf The array into which the bytes read should be stored\n+   * @param offset The offset into the array to start storing bytes\n+   * @param len The requested number of bytes to read\n+   *\n+   * @return The actual number of bytes read, or -1 if end of stream\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public int read(byte[] b, int off, int len) throws IOException\n   {\n     if (off < 0 || len < 0 || off + len > b.length)\n@@ -109,18 +251,48 @@ public int read(byte[] b, int off, int len) throws IOException\n     return off == origOff ? -1 : off - origOff;\n   }\n \n+  /**\n+   * This method resets a stream to the point where the\n+   * <code>mark()</code> method was called.  Any bytes that were read\n+   * after the mark point was set will be re-read during subsequent\n+   * reads.\n+   * <p>\n+   * In this class, this method will also restore the line number that was\n+   * current when the <code>mark()</code> method was called.\n+   *  <p>\n+   * This method only works if the subordinate stream supports mark/reset\n+   * functionality.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void reset() throws IOException\n   {\n     in.reset();\n     lineNumber = markLineNumber;\n     justReadReturnChar = false;\n   }\n \n+  /**\n+   * This method sets the current line number to the specified value.\n+   * \n+   * @param lineNumber The new line number\n+   */\n   public void setLineNumber(int lineNumber)\n   {\n     this.lineNumber = lineNumber;\n   }\n \n+  /**\n+   * This method skips up to the requested number of bytes in the \n+   * input stream.  The actual number of bytes skipped is returned.  If the\n+   * desired number of bytes to skip is negative, no bytes are skipped.\n+   *\n+   * @param n requested number of bytes to skip.\n+   *\n+   * @return The actual number of bytes skipped.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public long skip(long n) throws IOException\n   {\n     if (n <= 0)"}]}