{"sha": "f741a71c75d5196f226fc86697fa46cc0e427bf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc0MWE3MWM3NWQ1MTk2ZjIyNmZjODY2OTdmYTQ2Y2MwZTQyN2JmNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "2000-01-03T15:23:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-01-03T15:23:56Z"}, "message": "regclass.c (op_costs): Remove global variable.\n\n\t* regclass.c (op_costs): Remove global variable.\n\t(record_reg_classes): New parameter \"op_costs\" and \"reg_pref\".\n\t(record_operand_costs): Break out from ...\n\t(scan_one_insn): ... here.\n\t(dump_regclass): Make dumps nicer.\n\t(regclass): Dump preferrences choosed and changes done during passes.\n\nFrom-SVN: r31179", "tree": {"sha": "c385eb88d5708aa09a583d60fe79cf0bb8e605d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c385eb88d5708aa09a583d60fe79cf0bb8e605d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f741a71c75d5196f226fc86697fa46cc0e427bf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f741a71c75d5196f226fc86697fa46cc0e427bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f741a71c75d5196f226fc86697fa46cc0e427bf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f741a71c75d5196f226fc86697fa46cc0e427bf5/comments", "author": null, "committer": null, "parents": [{"sha": "2aac41d648d21a7e120edc5a0f4b0efaae42cc4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aac41d648d21a7e120edc5a0f4b0efaae42cc4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aac41d648d21a7e120edc5a0f4b0efaae42cc4a"}], "stats": {"total": 198, "additions": 122, "deletions": 76}, "files": [{"sha": "3bdb03a06eae51278b169b5fc5ced27f1efdd60f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f741a71c75d5196f226fc86697fa46cc0e427bf5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f741a71c75d5196f226fc86697fa46cc0e427bf5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f741a71c75d5196f226fc86697fa46cc0e427bf5", "patch": "@@ -1,3 +1,12 @@\n+Mon Jan  3 15:33:37 MET 2000  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* regclass.c (op_costs): Remove global variable.\n+\t(record_reg_classes): New parameter \"op_costs\" and \"reg_pref\".\n+\t(record_operand_costs): Break out from ...\n+\t(scan_one_insn): ... here.\n+\t(dump_regclass): Make dumps nicer.\n+\t(regclass): Dump preferrences choosed and changes done during passes.\n+\n 2000-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.c (gen_df_reg): Fix for 32bit SPARC."}, {"sha": "1da14a4c06875cd1356f2f4310506442b2df118f", "filename": "gcc/regclass.c", "status": "modified", "additions": 113, "deletions": 76, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f741a71c75d5196f226fc86697fa46cc0e427bf5/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f741a71c75d5196f226fc86697fa46cc0e427bf5/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=f741a71c75d5196f226fc86697fa46cc0e427bf5", "patch": "@@ -1,5 +1,5 @@\n /* Compute register class preferences for pseudo-registers.\n-   Copyright (C) 1987, 88, 91-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91-98, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -703,12 +703,6 @@ static struct costs *costs;\n \n static struct costs init_cost;\n \n-/* Record the same data by operand number, accumulated for each alternative\n-   in an insn.  The contribution to a pseudo is that of the minimum-cost\n-   alternative.  */\n-\n-static struct costs op_costs[MAX_RECOG_OPERANDS];\n-\n /* Record preferrences of each pseudo.\n    This is available after `regclass' is run.  */\n \n@@ -724,9 +718,11 @@ static struct reg_pref *reg_pref_buffer;\n static int loop_cost;\n \n static rtx scan_one_insn\tPROTO((rtx, int));\n+static void record_operand_costs PROTO((rtx, struct costs *, struct reg_pref *));\n static void dump_regclass\tPROTO((FILE *));\n static void record_reg_classes\tPROTO((int, int, rtx *, enum machine_mode *,\n-\t\t\t\t       char *, const char **, rtx));\n+\t\t\t\t       char *, const char **, rtx,\n+\t\t\t\t       struct costs *, struct reg_pref *));\n static int copy_cost\t\tPROTO((rtx, enum machine_mode, \n \t\t\t\t       enum reg_class, int));\n static void record_address_regs\tPROTO((rtx, enum reg_class, int));\n@@ -789,15 +785,89 @@ dump_regclass (dump)\n       enum reg_class class;\n       if (REG_N_REFS (i))\n \t{\n-\t  fprintf (dump, \";; Register %i costs:\", i);\n+\t  fprintf (dump, \"  Register %i costs:\", i);\n \t  for (class = 0; class < N_REG_CLASSES; class++)\n \t    fprintf (dump, \" %s:%i\", reg_class_names[(int) class],\n \t\t     costs[i].cost[class]);\n-\t  fprintf (dump, \" MEM:%i\\n\\n\", costs[i].mem_cost);\n+\t  fprintf (dump, \" MEM:%i\\n\", costs[i].mem_cost);\n \t}\n     }\n }\n+\f\n+\n+/* Calculate the costs of insn operands.  */\n+\n+static void\n+record_operand_costs (insn, op_costs, reg_pref)\n+     rtx insn;\n+     struct costs *op_costs;\n+     struct reg_pref *reg_pref;\n+{\n+  const char *constraints[MAX_RECOG_OPERANDS];\n+  enum machine_mode modes[MAX_RECOG_OPERANDS];\n+  char subreg_changes_size[MAX_RECOG_OPERANDS];\n+  int i;\n \n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      constraints[i] = recog_data.constraints[i];\n+      modes[i] = recog_data.operand_mode[i];\n+    }\n+  memset (subreg_changes_size, 0, sizeof (subreg_changes_size));\n+\n+  /* If we get here, we are set up to record the costs of all the\n+     operands for this insn.  Start by initializing the costs.\n+     Then handle any address registers.  Finally record the desired\n+     classes for any pseudos, doing it twice if some pair of\n+     operands are commutative.  */\n+\t     \n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      op_costs[i] = init_cost;\n+\n+      if (GET_CODE (recog_data.operand[i]) == SUBREG)\n+\t{\n+\t  rtx inner = SUBREG_REG (recog_data.operand[i]);\n+\t  if (GET_MODE_SIZE (modes[i]) != GET_MODE_SIZE (GET_MODE (inner)))\n+\t    subreg_changes_size[i] = 1;\n+\t  recog_data.operand[i] = inner;\n+\t}\n+\n+      if (GET_CODE (recog_data.operand[i]) == MEM)\n+\trecord_address_regs (XEXP (recog_data.operand[i], 0),\n+\t\t\t     BASE_REG_CLASS, loop_cost * 2);\n+      else if (constraints[i][0] == 'p')\n+\trecord_address_regs (recog_data.operand[i],\n+\t\t\t     BASE_REG_CLASS, loop_cost * 2);\n+    }\n+\n+  /* Check for commutative in a separate loop so everything will\n+     have been initialized.  We must do this even if one operand\n+     is a constant--see addsi3 in m68k.md.  */\n+\n+  for (i = 0; i < (int) recog_data.n_operands - 1; i++)\n+    if (constraints[i][0] == '%')\n+      {\n+\tconst char *xconstraints[MAX_RECOG_OPERANDS];\n+\tint j;\n+\n+\t/* Handle commutative operands by swapping the constraints.\n+\t   We assume the modes are the same.  */\n+\n+\tfor (j = 0; j < recog_data.n_operands; j++)\n+\t  xconstraints[j] = constraints[j];\n+\n+\txconstraints[i] = constraints[i+1];\n+\txconstraints[i+1] = constraints[i];\n+\trecord_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n+\t\t\t    recog_data.operand, modes, subreg_changes_size,\n+\t\t\t    xconstraints, insn, op_costs, reg_pref);\n+      }\n+\n+  record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n+\t\t      recog_data.operand, modes, subreg_changes_size,\n+\t\t      constraints, insn, op_costs, reg_pref);\n+}\n \f\n /* Subroutine of regclass, processes one insn INSN.  Scan it and record each\n    time it would save code to put a certain register in a certain class.\n@@ -813,11 +883,9 @@ scan_one_insn (insn, pass)\n {\n   enum rtx_code code = GET_CODE (insn);\n   enum rtx_code pat_code;\n-  const char *constraints[MAX_RECOG_OPERANDS];\n-  enum machine_mode modes[MAX_RECOG_OPERANDS];\n-  char subreg_changes_size[MAX_RECOG_OPERANDS];\n   rtx set, note;\n   int i, j;\n+  struct costs op_costs[MAX_RECOG_OPERANDS];\n \n   if (GET_RTX_CLASS (code) != 'i')\n     return insn;\n@@ -833,13 +901,6 @@ scan_one_insn (insn, pass)\n   set = single_set (insn);\n   extract_insn (insn);\n \n-  for (i = 0; i < recog_data.n_operands; i++)\n-    {\n-      constraints[i] = recog_data.constraints[i];\n-      modes[i] = recog_data.operand_mode[i];\n-    }\n-  memset (subreg_changes_size, 0, sizeof (subreg_changes_size));\n-\n   /* If this insn loads a parameter from its stack slot, then\n      it represents a savings, rather than a cost, if the\n      parameter is stored in memory.  Record this fact.  */\n@@ -913,58 +974,7 @@ scan_one_insn (insn, pass)\n       return PREV_INSN (newinsn);\n     }\n \n-  /* If we get here, we are set up to record the costs of all the\n-     operands for this insn.  Start by initializing the costs.\n-     Then handle any address registers.  Finally record the desired\n-     classes for any pseudos, doing it twice if some pair of\n-     operands are commutative.  */\n-\t     \n-  for (i = 0; i < recog_data.n_operands; i++)\n-    {\n-      op_costs[i] = init_cost;\n-\n-      if (GET_CODE (recog_data.operand[i]) == SUBREG)\n-\t{\n-\t  rtx inner = SUBREG_REG (recog_data.operand[i]);\n-\t  if (GET_MODE_SIZE (modes[i]) != GET_MODE_SIZE (GET_MODE (inner)))\n-\t    subreg_changes_size[i] = 1;\n-\t  recog_data.operand[i] = inner;\n-\t}\n-\n-      if (GET_CODE (recog_data.operand[i]) == MEM)\n-\trecord_address_regs (XEXP (recog_data.operand[i], 0),\n-\t\t\t     BASE_REG_CLASS, loop_cost * 2);\n-      else if (constraints[i][0] == 'p')\n-\trecord_address_regs (recog_data.operand[i],\n-\t\t\t     BASE_REG_CLASS, loop_cost * 2);\n-    }\n-\n-  /* Check for commutative in a separate loop so everything will\n-     have been initialized.  We must do this even if one operand\n-     is a constant--see addsi3 in m68k.md.  */\n-\n-  for (i = 0; i < (int) recog_data.n_operands - 1; i++)\n-    if (constraints[i][0] == '%')\n-      {\n-\tconst char *xconstraints[MAX_RECOG_OPERANDS];\n-\tint j;\n-\n-\t/* Handle commutative operands by swapping the constraints.\n-\t   We assume the modes are the same.  */\n-\n-\tfor (j = 0; j < recog_data.n_operands; j++)\n-\t  xconstraints[j] = constraints[j];\n-\n-\txconstraints[i] = constraints[i+1];\n-\txconstraints[i+1] = constraints[i];\n-\trecord_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n-\t\t\t    recog_data.operand, modes, subreg_changes_size,\n-\t\t\t    xconstraints, insn);\n-      }\n-\n-  record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n-\t\t      recog_data.operand, modes, subreg_changes_size,\n-\t\t      constraints, insn);\n+  record_operand_costs(insn, op_costs, reg_pref);\n \n   /* Now add the cost for each operand to the total costs for\n      its register.  */\n@@ -1064,6 +1074,9 @@ regclass (f, nregs, dump)\n   for (pass = 0; pass <= flag_expensive_optimizations; pass++)\n     {\n       int index;\n+\n+      if (dump)\n+        fprintf (dump, \"\\n\\nPass %i\\n\\n\",pass);\n       /* Zero out our accumulation of the cost of each class for each reg.  */\n \n       bzero ((char *) costs, nregs * sizeof (struct costs));\n@@ -1110,6 +1123,11 @@ regclass (f, nregs, dump)\n       if (pass == 0)\n \treg_pref = reg_pref_buffer;\n \n+      if (dump)\n+        {\n+\t  dump_regclass (dump);\n+\t  fprintf(dump,\"\\n\");\n+\t}\n       for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n \t{\n \t  register int best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n@@ -1119,6 +1137,9 @@ regclass (f, nregs, dump)\n \t  register int class;\n \t  register struct costs *p = &costs[i];\n \n+\t  if (!REG_N_REFS (i))\n+\t    continue;\n+\n \t  for (class = (int) ALL_REGS - 1; class > 0; class--)\n \t    {\n \t      /* Ignore classes that are too small for this operand or\n@@ -1146,7 +1167,7 @@ regclass (f, nregs, dump)\n \t     should be provided as a register class.  Don't do this if we\n \t     will be doing it again later.  */\n \n-\t  if (pass == 1 || ! flag_expensive_optimizations)\n+\t  if ((pass == 1  || dump) || ! flag_expensive_optimizations)\n \t    for (class = 0; class < N_REG_CLASSES; class++)\n \t      if (p->cost[class] < p->mem_cost\n \t\t  && (reg_class_size[(int) reg_class_subunion[(int) alt][class]]\n@@ -1161,14 +1182,28 @@ regclass (f, nregs, dump)\n \t  if (alt == best)\n \t    alt = NO_REGS;\n \n+\t  if (dump \n+\t      && (reg_pref[i].prefclass != (int) best\n+\t\t  || reg_pref[i].altclass != (int) alt))\n+\t    {\n+\t      static const char *const reg_class_names[] = REG_CLASS_NAMES;\n+\t      fprintf(dump, \"  Register %i\", i);\n+\t      if (alt == ALL_REGS || best == ALL_REGS)\n+\t\tfprintf (dump, \" pref %s\\n\", reg_class_names[(int) best]);\n+\t      else if (alt == NO_REGS)\n+\t\tfprintf (dump, \" pref %s or none\\n\", reg_class_names[(int) best]);\n+\t      else\n+\t\tfprintf (dump, \" pref %s, else %s\\n\",\n+\t\t\t reg_class_names[(int) best],\n+\t\t\t reg_class_names[(int) alt]);\n+\t    }\n+\n \t  /* We cast to (int) because (char) hits bugs in some compilers.  */\n \t  reg_pref[i].prefclass = (int) best;\n \t  reg_pref[i].altclass = (int) alt;\n \t}\n     }\n \n-  if (dump)\n-    dump_regclass (dump);\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n   free (in_inc_dec);\n #endif\n@@ -1201,14 +1236,16 @@ regclass (f, nregs, dump)\n \n static void\n record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n-\t\t    constraints, insn)\n+\t\t    constraints, insn, op_costs, reg_pref)\n      int n_alts;\n      int n_ops;\n      rtx *ops;\n      enum machine_mode *modes;\n      char *subreg_changes_size ATTRIBUTE_UNUSED;\n      const char **constraints;\n      rtx insn;\n+     struct costs *op_costs;\n+     struct reg_pref *reg_pref;\n {\n   int alt;\n   int i, j;"}]}