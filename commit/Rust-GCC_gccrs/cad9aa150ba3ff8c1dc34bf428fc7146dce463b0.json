{"sha": "cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FkOWFhMTUwYmEzZmY4YzFkYzM0YmY0MjhmYzcxNDZkY2U0NjNiMA==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2010-07-27T19:48:15Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2010-07-27T19:48:15Z"}, "message": "re PR target/42495 (redundant memory load)\n\n\tPR target/42495\n\tPR middle-end/42574\n\t* basic-block.h (get_dominated_to_depth): Declare.\n\t* dominance.c (get_dominated_to_depth): New function, use\n\tget_all_dominated_blocks as a base.\n\t(get_all_dominated_blocks): Use get_dominated_to_depth.\n\n\t* gcse.c (occr_t, VEC (occr_t, heap)): Define.\n\t(hoist_exprs): Remove.\n\t(alloc_code_hoist_mem, free_code_hoist_mem): Update.\n\t(compute_code_hoist_vbeinout): Add debug print outs.\n\t(hoist_code): Partially rewrite, simplify.  Use get_dominated_to_depth.\n\n\t* params.def (PARAM_MAX_HOIST_DEPTH): New parameter to avoid\n\tquadratic behavior.\n\t* params.h (MAX_HOIST_DEPTH): New macro.\n\t* doc/invoke.texi (max-hoist-depth): Document.\n\nFrom-SVN: r162597", "tree": {"sha": "ef6e287dda7baf7be12f1fb62bf64d66c6a8211d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef6e287dda7baf7be12f1fb62bf64d66c6a8211d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/comments", "author": null, "committer": null, "parents": [{"sha": "9b9ee6d392b6f4f50bacb299e8e1350b1173add8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b9ee6d392b6f4f50bacb299e8e1350b1173add8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b9ee6d392b6f4f50bacb299e8e1350b1173add8"}], "stats": {"total": 336, "additions": 203, "deletions": 133}, "files": [{"sha": "8c7db8faa4b36c91a48ad989ad36d89e5bb59299", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "patch": "@@ -1,3 +1,23 @@\n+2010-07-27  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\tPR target/42495\n+\tPR middle-end/42574\n+\t* basic-block.h (get_dominated_to_depth): Declare.\n+\t* dominance.c (get_dominated_to_depth): New function, use\n+\tget_all_dominated_blocks as a base.\n+\t(get_all_dominated_blocks): Use get_dominated_to_depth.\n+\n+\t* gcse.c (occr_t, VEC (occr_t, heap)): Define.\n+\t(hoist_exprs): Remove.\n+\t(alloc_code_hoist_mem, free_code_hoist_mem): Update.\n+\t(compute_code_hoist_vbeinout): Add debug print outs.\n+\t(hoist_code): Partially rewrite, simplify.  Use get_dominated_to_depth.\n+\n+\t* params.def (PARAM_MAX_HOIST_DEPTH): New parameter to avoid\n+\tquadratic behavior.\n+\t* params.h (MAX_HOIST_DEPTH): New macro.\n+\t* doc/invoke.texi (max-hoist-depth): Document.\n+\n 2010-07-27  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \tPR rtl-optimization/40956"}, {"sha": "1bf192d47f7c95a35592dcb6c081f18328c0199b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "patch": "@@ -854,6 +854,8 @@ extern VEC (basic_block, heap) *get_dominated_by (enum cdi_direction, basic_bloc\n extern VEC (basic_block, heap) *get_dominated_by_region (enum cdi_direction,\n \t\t\t\t\t\t\t basic_block *,\n \t\t\t\t\t\t\t unsigned);\n+extern VEC (basic_block, heap) *get_dominated_to_depth (enum cdi_direction,\n+\t\t\t\t\t\t\tbasic_block, int);\n extern VEC (basic_block, heap) *get_all_dominated_blocks (enum cdi_direction,\n \t\t\t\t\t\t\t  basic_block);\n extern void add_to_dominance_info (enum cdi_direction, basic_block);"}, {"sha": "78f81e219dfefefbc54d3bdb289aaf1f180b789a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "patch": "@@ -8260,6 +8260,12 @@ the more aggressive code hoisting will be.  Specifying 0 will\n allow all expressions to travel unrestricted distances.\n The default value is 3.\n \n+@item max-hoist-depth\n+The depth of search in the dominator tree for expressions to hoist.\n+This is used to avoid quadratic behavior in hoisting algorithm.\n+The value of 0 will avoid limiting the search, but may slow down compilation\n+of huge functions.  The default value is 30.\n+\n @item max-unrolled-insns\n The maximum number of instructions that a loop should have if that loop\n is unrolled, and if the loop is unrolled, it determines how many times"}, {"sha": "688c87bff43bc171cbb8a87048dcde98efd66d8b", "filename": "gcc/dominance.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "patch": "@@ -784,16 +784,20 @@ get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n }\n \n /* Returns the list of basic blocks including BB dominated by BB, in the\n-   direction DIR.  The vector will be sorted in preorder.  */\n+   direction DIR up to DEPTH in the dominator tree.  The DEPTH of zero will\n+   produce a vector containing all dominated blocks.  The vector will be sorted\n+   in preorder.  */\n \n VEC (basic_block, heap) *\n-get_all_dominated_blocks (enum cdi_direction dir, basic_block bb)\n+get_dominated_to_depth (enum cdi_direction dir, basic_block bb, int depth)\n {\n   VEC(basic_block, heap) *bbs = NULL;\n   unsigned i;\n+  unsigned next_level_start;\n \n   i = 0;\n   VEC_safe_push (basic_block, heap, bbs, bb);\n+  next_level_start = 1; /* = VEC_length (basic_block, bbs); */\n \n   do\n     {\n@@ -804,12 +808,24 @@ get_all_dominated_blocks (enum cdi_direction dir, basic_block bb)\n \t   son;\n \t   son = next_dom_son (dir, son))\n \tVEC_safe_push (basic_block, heap, bbs, son);\n+\n+      if (i == next_level_start && --depth)\n+\tnext_level_start = VEC_length (basic_block, bbs);\n     }\n-  while (i < VEC_length (basic_block, bbs));\n+  while (i < next_level_start);\n \n   return bbs;\n }\n \n+/* Returns the list of basic blocks including BB dominated by BB, in the\n+   direction DIR.  The vector will be sorted in preorder.  */\n+\n+VEC (basic_block, heap) *\n+get_all_dominated_blocks (enum cdi_direction dir, basic_block bb)\n+{\n+  return get_dominated_to_depth (dir, bb, 0);\n+}\n+\n /* Redirect all edges pointing to BB to TO.  */\n void\n redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,"}, {"sha": "a60310f67e87cb3fc5104c14672b14fe902dcf3e", "filename": "gcc/gcse.c", "status": "modified", "additions": 146, "deletions": 130, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "patch": "@@ -329,6 +329,10 @@ struct occr\n   char copied_p;\n };\n \n+typedef struct occr *occr_t;\n+DEF_VEC_P (occr_t);\n+DEF_VEC_ALLOC_P (occr_t, heap);\n+\n /* Expression and copy propagation hash tables.\n    Each hash table is an array of buckets.\n    ??? It is known that if it were an array of entries, structure elements\n@@ -4163,9 +4167,6 @@ add_label_notes (rtx x, rtx insn)\n static sbitmap *hoist_vbein;\n static sbitmap *hoist_vbeout;\n \n-/* Hoistable expressions.  */\n-static sbitmap *hoist_exprs;\n-\n /* ??? We could compute post dominators and run this algorithm in\n    reverse to perform tail merging, doing so would probably be\n    more effective than the tail merging code in jump.c.\n@@ -4184,7 +4185,6 @@ alloc_code_hoist_mem (int n_blocks, int n_exprs)\n \n   hoist_vbein = sbitmap_vector_alloc (n_blocks, n_exprs);\n   hoist_vbeout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  hoist_exprs = sbitmap_vector_alloc (n_blocks, n_exprs);\n }\n \n /* Free vars used for code hoisting analysis.  */\n@@ -4198,7 +4198,6 @@ free_code_hoist_mem (void)\n \n   sbitmap_vector_free (hoist_vbein);\n   sbitmap_vector_free (hoist_vbeout);\n-  sbitmap_vector_free (hoist_exprs);\n \n   free_dominance_info (CDI_DOMINATORS);\n }\n@@ -4249,7 +4248,17 @@ compute_code_hoist_vbeinout (void)\n     }\n \n   if (dump_file)\n-    fprintf (dump_file, \"hoisting vbeinout computation: %d passes\\n\", passes);\n+    {\n+      fprintf (dump_file, \"hoisting vbeinout computation: %d passes\\n\", passes);\n+\n+      FOR_EACH_BB (bb)\n+        {\n+\t  fprintf (dump_file, \"vbein (%d): \", bb->index);\n+\t  dump_sbitmap_file (dump_file, hoist_vbein[bb->index]);\n+\t  fprintf (dump_file, \"vbeout(%d): \", bb->index);\n+\t  dump_sbitmap_file (dump_file, hoist_vbeout[bb->index]);\n+\t}\n+    }\n }\n \n /* Top level routine to do the dataflow analysis needed by code hoisting.  */\n@@ -4352,6 +4361,8 @@ static int\n hoist_code (void)\n {\n   basic_block bb, dominated;\n+  VEC (basic_block, heap) *dom_tree_walk;\n+  unsigned int dom_tree_walk_index;\n   VEC (basic_block, heap) *domby;\n   unsigned int i,j;\n   struct expr **index_map;\n@@ -4360,8 +4371,6 @@ hoist_code (void)\n   int *bb_size;\n   int changed = 0;\n \n-  sbitmap_vector_zero (hoist_exprs, last_basic_block);\n-\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n@@ -4400,34 +4409,72 @@ hoist_code (void)\n       bb_size[bb->index] = to_head;\n     }\n \n+  gcc_assert (EDGE_COUNT (ENTRY_BLOCK_PTR->succs) == 1\n+\t      && (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest\n+\t\t  == ENTRY_BLOCK_PTR->next_bb));\n+\n+  dom_tree_walk = get_all_dominated_blocks (CDI_DOMINATORS,\n+\t\t\t\t\t    ENTRY_BLOCK_PTR->next_bb);\n+\n   /* Walk over each basic block looking for potentially hoistable\n      expressions, nothing gets hoisted from the entry block.  */\n-  FOR_EACH_BB (bb)\n+  for (dom_tree_walk_index = 0;\n+       VEC_iterate (basic_block, dom_tree_walk, dom_tree_walk_index, bb);\n+       dom_tree_walk_index++)\n     {\n-      int found = 0;\n-      int insn_inserted_p;\n+      domby = get_dominated_to_depth (CDI_DOMINATORS, bb, MAX_HOIST_DEPTH);\n+\n+      if (VEC_length (basic_block, domby) == 0)\n+\tcontinue;\n \n-      domby = get_dominated_by (CDI_DOMINATORS, bb);\n       /* Examine each expression that is very busy at the exit of this\n \t block.  These are the potentially hoistable expressions.  */\n       for (i = 0; i < hoist_vbeout[bb->index]->n_bits; i++)\n \t{\n-\t  int hoistable = 0;\n-\n \t  if (TEST_BIT (hoist_vbeout[bb->index], i))\n \t    {\n+\t      /* Current expression.  */\n+\t      struct expr *expr = index_map[i];\n+\t      /* Number of occurences of EXPR that can be hoisted to BB.  */\n+\t      int hoistable = 0;\n+\t      /* Basic blocks that have occurences reachable from BB.  */\n+\t      bitmap_head _from_bbs, *from_bbs = &_from_bbs;\n+\t      /* Occurences reachable from BB.  */\n+\t      VEC (occr_t, heap) *occrs_to_hoist = NULL;\n+\t      /* We want to insert the expression into BB only once, so\n+\t\t note when we've inserted it.  */\n+\t      int insn_inserted_p;\n+\t      occr_t occr;\n+\n+\t      bitmap_initialize (from_bbs, 0);\n+\n \t      /* If an expression is computed in BB and is available at end of\n \t\t BB, hoist all occurences dominated by BB to BB.  */\n \t      if (TEST_BIT (comp[bb->index], i))\n-\t\thoistable++;\n+\t\t{\n+\t\t  occr = find_occr_in_bb (expr->antic_occr, bb);\n+\n+\t\t  if (occr)\n+\t\t    {\n+\t\t      /* An occurence might've been already deleted\n+\t\t\t while processing a dominator of BB.  */\n+\t\t      if (occr->deleted_p)\n+\t\t\tgcc_assert (MAX_HOIST_DEPTH > 1);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  gcc_assert (NONDEBUG_INSN_P (occr->insn));\n+\t\t\t  hoistable++;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    hoistable++;\n+\t\t}\n \n \t      /* We've found a potentially hoistable expression, now\n \t\t we look at every block BB dominates to see if it\n \t\t computes the expression.  */\n \t      for (j = 0; VEC_iterate (basic_block, domby, j, dominated); j++)\n \t\t{\n-\t\t  struct expr *expr = index_map[i];\n-\t\t  struct occr *occr = NULL;\n \t\t  int max_distance;\n \n \t\t  /* Ignore self dominance.  */\n@@ -4439,22 +4486,25 @@ hoist_code (void)\n \t\t  if (!TEST_BIT (antloc[dominated->index], i))\n \t\t    continue;\n \n-\t\t  max_distance = expr->max_distance;\n-\t\t  if (max_distance > 0)\n-\t\t    {\n-\t\t      struct occr *occr;\n-\n-\t\t      occr = find_occr_in_bb (expr->antic_occr, dominated);\n-\t\t      gcc_assert (occr);\n-\n-\t\t      gcc_assert (NONDEBUG_INSN_P (occr->insn));\n+\t\t  occr = find_occr_in_bb (expr->antic_occr, dominated);\n+\t\t  gcc_assert (occr);\n \n-\t\t      /* Adjust MAX_DISTANCE to account for the fact that\n-\t\t\t OCCR won't have to travel all of DOMINATED, but\n-\t\t\t only part of it.  */\n-\t\t      max_distance += (bb_size[dominated->index]\n-\t\t\t\t       - to_bb_head[INSN_UID (occr->insn)]);\n+\t\t  /* An occurence might've been already deleted\n+\t\t     while processing a dominator of BB.  */\n+\t\t  if (occr->deleted_p)\n+\t\t    {\n+\t\t      gcc_assert (MAX_HOIST_DEPTH > 1);\n+\t\t      continue;\n \t\t    }\n+\t\t  gcc_assert (NONDEBUG_INSN_P (occr->insn));\n+\n+\t\t  max_distance = expr->max_distance;\n+\t\t  if (max_distance > 0)\n+\t\t    /* Adjust MAX_DISTANCE to account for the fact that\n+\t\t       OCCR won't have to travel all of DOMINATED, but\n+\t\t       only part of it.  */\n+\t\t    max_distance += (bb_size[dominated->index]\n+\t\t\t\t     - to_bb_head[INSN_UID (occr->insn)]);\n \n \t\t  /* Note if the expression would reach the dominated block\n \t\t     unimpared if it was placed at the end of BB.\n@@ -4463,11 +4513,16 @@ hoist_code (void)\n \t\t     from a dominated block into BB.  */\n \t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL,\n \t\t\t\t\t\t max_distance, bb_size))\n-\t\t    hoistable++;\n+\t\t    {\n+\t\t      hoistable++;\n+\t\t      VEC_safe_push (occr_t, heap,\n+\t\t\t\t     occrs_to_hoist, occr);\n+\t\t      bitmap_set_bit (from_bbs, dominated->index);\n+\t\t    }\n \t\t}\n \n \t      /* If we found more than one hoistable occurrence of this\n-\t\t expression, then note it in the bitmap of expressions to\n+\t\t expression, then note it in the vector of expressions to\n \t\t hoist.  It makes no sense to hoist things which are computed\n \t\t in only one BB, and doing so tends to pessimize register\n \t\t allocation.  One could increase this value to try harder\n@@ -4478,115 +4533,76 @@ hoist_code (void)\n \t\t to nullify any benefit we get from code hoisting.  */\n \t      if (hoistable > 1 && dbg_cnt (hoist_insn))\n \t\t{\n-\t\t  SET_BIT (hoist_exprs[bb->index], i);\n-\t\t  found = 1;\n+\t\t  /* If (hoistable != VEC_length), then there is\n+\t\t     an occurence of EXPR in BB itself.  Don't waste\n+\t\t     time looking for LCA in this case.  */\n+\t\t  if ((unsigned) hoistable\n+\t\t      == VEC_length (occr_t, occrs_to_hoist))\n+\t\t    {\n+\t\t      basic_block lca;\n+\n+\t\t      lca = nearest_common_dominator_for_set (CDI_DOMINATORS,\n+\t\t\t\t\t\t\t      from_bbs);\n+\t\t      if (lca != bb)\n+\t\t\t/* Punt, it's better to hoist these occurences to\n+\t\t\t   LCA.  */\n+\t\t\tVEC_free (occr_t, heap, occrs_to_hoist);\n+\t\t    }\n \t\t}\n-\t    }\n-\t}\n-      /* If we found nothing to hoist, then quit now.  */\n-      if (! found)\n-        {\n-\t  VEC_free (basic_block, heap, domby);\n-\t  continue;\n-\t}\n+\t      else\n+\t\t/* Punt, no point hoisting a single occurence.  */\n+\t\tVEC_free (occr_t, heap, occrs_to_hoist);\n \n-      /* Loop over all the hoistable expressions.  */\n-      for (i = 0; i < hoist_exprs[bb->index]->n_bits; i++)\n-\t{\n-\t  /* We want to insert the expression into BB only once, so\n-\t     note when we've inserted it.  */\n-\t  insn_inserted_p = 0;\n+\t      insn_inserted_p = 0;\n \n-\t  /* These tests should be the same as the tests above.  */\n-\t  if (TEST_BIT (hoist_exprs[bb->index], i))\n-\t    {\n-\t      /* We've found a potentially hoistable expression, now\n-\t\t we look at every block BB dominates to see if it\n-\t\t computes the expression.  */\n-\t      for (j = 0; VEC_iterate (basic_block, domby, j, dominated); j++)\n+\t      /* Walk through occurences of I'th expressions we want\n+\t\t to hoist to BB and make the transformations.  */\n+\t      for (j = 0;\n+\t\t   VEC_iterate (occr_t, occrs_to_hoist, j, occr);\n+\t\t   j++)\n \t\t{\n-\t\t  struct expr *expr = index_map[i];\n-\t\t  int max_distance;\n-\n-\t\t  /* Ignore self dominance.  */\n-\t\t  if (bb == dominated)\n-\t\t    continue;\n-\n-\t\t  /* We've found a dominated block, now see if it computes\n-\t\t     the busy expression and whether or not moving that\n-\t\t     expression to the \"beginning\" of that block is safe.  */\n-\t\t  if (!TEST_BIT (antloc[dominated->index], i))\n-\t\t    continue;\n-\n-\t\t  max_distance = expr->max_distance;\n-\t\t  if (max_distance > 0)\n+\t\t  rtx insn;\n+\t\t  rtx set;\n+\n+\t\t  gcc_assert (!occr->deleted_p);\n+\n+\t\t  insn = occr->insn;\n+\t\t  set = single_set (insn);\n+\t\t  gcc_assert (set);\n+\n+\t\t  /* Create a pseudo-reg to store the result of reaching\n+\t\t     expressions into.  Get the mode for the new pseudo\n+\t\t     from the mode of the original destination pseudo.\n+\n+\t\t     It is important to use new pseudos whenever we\n+\t\t     emit a set.  This will allow reload to use\n+\t\t     rematerialization for such registers.  */\n+\t\t  if (!insn_inserted_p)\n+\t\t    expr->reaching_reg\n+\t\t      = gen_reg_rtx_and_attrs (SET_DEST (set));\n+\n+\t\t  gcse_emit_move_after (expr->reaching_reg, SET_DEST (set),\n+\t\t\t\t\tinsn);\n+\t\t  delete_insn (insn);\n+\t\t  occr->deleted_p = 1;\n+\t\t  changed = 1;\n+\t\t  gcse_subst_count++;\n+\n+\t\t  if (!insn_inserted_p)\n \t\t    {\n-\t\t      occr = find_occr_in_bb (expr->antic_occr, dominated);\n-\t\t      gcc_assert (occr);\n-\n-\t\t      gcc_assert (NONDEBUG_INSN_P (occr->insn));\n-\n-\t\t      /* Adjust MAX_DISTANCE to account for the fact that\n-\t\t\t OCCR won't have to travel all of DOMINATED, but\n-\t\t\t only part of it.  */\n-\t\t      max_distance += (bb_size[dominated->index]\n-\t\t\t\t       - to_bb_head[INSN_UID (occr->insn)]);\n-\t\t    }\n-\n-\t\t  /* The expression is computed in the dominated block and\n-\t\t     it would be safe to compute it at the start of the\n-\t\t     dominated block.  Now we have to determine if the\n-\t\t     expression would reach the dominated block if it was\n-\t\t     placed at the end of BB.\n-\t\t     Note: the fact that hoist_exprs has i-th bit set means\n-\t\t     that /some/, not necesserilly all, occurences from\n-\t\t     the dominated blocks can be hoisted to BB.  Here we check\n-\t\t     if a specific occurence can be hoisted to BB.  */\n-\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL,\n-\t\t\t\t\t\t max_distance, bb_size))\n-\t\t    {\n-\t\t      rtx insn;\n-\t\t      rtx set;\n-\n-\t\t      if (!occr)\n-\t\t\t{\n-\t\t\t  occr = find_occr_in_bb (expr->antic_occr, dominated);\n-\t\t\t  gcc_assert (occr);\n-\t\t\t}\n-\n-\t\t      insn = occr->insn;\n-\t\t      set = single_set (insn);\n-\t\t      gcc_assert (set);\n-\n-\t\t      /* Create a pseudo-reg to store the result of reaching\n-\t\t\t expressions into.  Get the mode for the new pseudo\n-\t\t\t from the mode of the original destination pseudo.\n-\n-\t\t\t It is important to use new pseudos whenever we\n-\t\t\t emit a set.  This will allow reload to use\n-\t\t\t rematerialization for such registers.  */\n-\t\t      if (!insn_inserted_p)\n-\t\t\texpr->reaching_reg\n-\t\t\t  = gen_reg_rtx_and_attrs (SET_DEST (set));\n-\n-\t\t      gcse_emit_move_after (expr->reaching_reg, SET_DEST (set), insn);\n-\t\t      delete_insn (insn);\n-\t\t      occr->deleted_p = 1;\n-\t\t      changed = 1;\n-\t\t      gcse_subst_count++;\n-\n-\t\t      if (!insn_inserted_p)\n-\t\t\t{\n-\t\t\t  insert_insn_end_basic_block (index_map[i], bb);\n-\t\t\t  insn_inserted_p = 1;\n-\t\t\t}\n+\t\t      insert_insn_end_basic_block (expr, bb);\n+\t\t      insn_inserted_p = 1;\n \t\t    }\n \t\t}\n+\n+\t      VEC_free (occr_t, heap, occrs_to_hoist);\n+\t      bitmap_clear (from_bbs);\n \t    }\n \t}\n       VEC_free (basic_block, heap, domby);\n     }\n \n+  VEC_free (basic_block, heap, dom_tree_walk);\n   free (bb_size);\n   free (to_bb_head);\n   free (index_map);"}, {"sha": "1d4e68722592290b94e85cd822553ad7affe2546", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "patch": "@@ -240,6 +240,14 @@ DEFPARAM(PARAM_GCSE_UNRESTRICTED_COST,\n \t \"Cost at which GCSE optimizations will not constraint the distance an expression can travel\",\n \t 3, 0, 0)\n \n+/* How deep from a given basic block the dominator tree should be searched\n+   for expressions to hoist to the block.  The value of 0 will avoid limiting\n+   the search.  */\n+DEFPARAM(PARAM_MAX_HOIST_DEPTH,\n+\t \"max-hoist-depth\",\n+\t \"Maximum depth of search in the dominator tree for expressions to hoist\",\n+\t 30, 0, 0)\n+\n /* This parameter limits the number of insns in a loop that will be unrolled,\n    and by how much the loop is unrolled.\n "}, {"sha": "aa96c818f26af15e978c87643f668d313d54cf1f", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad9aa150ba3ff8c1dc34bf428fc7146dce463b0/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=cad9aa150ba3ff8c1dc34bf428fc7146dce463b0", "patch": "@@ -129,6 +129,8 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_GCSE_COST_DISTANCE_RATIO)\n #define GCSE_UNRESTRICTED_COST \\\n   PARAM_VALUE (PARAM_GCSE_UNRESTRICTED_COST)\n+#define MAX_HOIST_DEPTH \\\n+  PARAM_VALUE (PARAM_MAX_HOIST_DEPTH)\n #define MAX_UNROLLED_INSNS \\\n   PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS)\n #define MAX_SMS_LOOP_NUMBER \\"}]}