{"sha": "d4c2f1d376da6fc3f3c30a9d3160e43c95399343", "node_id": "C_kwDOANBUbNoAKGQ0YzJmMWQzNzZkYTZmYzNmM2MzMGE5ZDMxNjBlNDNjOTUzOTkzNDM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-12T08:39:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-12T08:42:34Z"}, "message": "range-op: Implement op[12]_range operators for {PLUS,MINUS,MULT,RDIV}_EXPR\n\nOn Wed, Nov 09, 2022 at 04:43:56PM +0100, Aldy Hernandez wrote:\n> On Wed, Nov 9, 2022 at 3:58 PM Jakub Jelinek <jakub@redhat.com> wrote:\n> >\n> > On Wed, Nov 09, 2022 at 10:02:46AM +0100, Aldy Hernandez wrote:\n> > > We can implement the op[12]_range entries for plus and minus in terms\n> > > of each other.  These are adapted from the integer versions.\n> >\n> > I think for NANs the op[12]_range shouldn't act this way.\n> > For the forward binary operations, we have the (maybe/known) NAN handling\n> > of one or both NAN operands resulting in VARYING sign (maybe/known) NAN\n> > result, that is the somehow the case for the reverse binary operations too,\n> > if result is (maybe/known) NAN and the other op is not NAN, op is\n> > VARYING sign (maybe/known) NAN, if other op is (maybe/known) NAN,\n> > then op is VARYING sign maybe NAN (always maybe, never known).\n> > But then for + we have the -INF + INF or vice versa into NAN, and that\n> > is something that shouldn't be considered.  If result isn't NAN, then\n> > neither operand can be NAN, regardless of whether result can be\n> > +/- INF and the other op -/+ INF.\n>\n> Heh.  I just ran into this while debugging the problem reported by Xi.\n>\n> We are solving NAN = op1 - VARYING, and trying to do it with op1 = NAN\n> + VARYING, which returns op1 = NAN (incorrectly).\n>\n> I suppose in the above case op1 should ideally be\n> [-INF,-INF][+INF,+INF]+-NAN, but since we can't represent that then\n> [-INF,+INF] +-NAN, which is actually VARYING.  Do you agree?\n>\n> I'm reverting this patch as attached, while I sort this out.\n\nHere is a patch which reinstalls your change, add the fixups I've talked\nabout and also hooks up reverse operators for MULT_EXPR/RDIV_EXPR.\n\n2022-11-12  Aldy Hernandez  <aldyh@redhat.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\t* range-op-float.cc (float_binary_op_range_finish): New function.\n\t(foperator_plus::op1_range): New.\n\t(foperator_plus::op2_range): New.\n\t(foperator_minus::op1_range): New.\n\t(foperator_minus::op2_range): New.\n\t(foperator_mult::op1_range): New.\n\t(foperator_mult::op2_range): New.\n\t(foperator_div::op1_range): New.\n\t(foperator_div::op2_range): New.\n\n\t* gcc.c-torture/execute/ieee/inf-4.c: New test.", "tree": {"sha": "b2503f30b2405578df5bb228c2b3479220bd2430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2503f30b2405578df5bb228c2b3479220bd2430"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4c2f1d376da6fc3f3c30a9d3160e43c95399343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4c2f1d376da6fc3f3c30a9d3160e43c95399343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4c2f1d376da6fc3f3c30a9d3160e43c95399343", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4c2f1d376da6fc3f3c30a9d3160e43c95399343/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5747470efa8ff0ac82bb5f53d737b29a44f18118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5747470efa8ff0ac82bb5f53d737b29a44f18118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5747470efa8ff0ac82bb5f53d737b29a44f18118"}], "stats": {"total": 157, "additions": 157, "deletions": 0}, "files": [{"sha": "4472337e03ef46ed7950ff5197a858d77c872cbf", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4c2f1d376da6fc3f3c30a9d3160e43c95399343/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4c2f1d376da6fc3f3c30a9d3160e43c95399343/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=d4c2f1d376da6fc3f3c30a9d3160e43c95399343", "patch": "@@ -1861,6 +1861,39 @@ foperator_unordered_equal::op1_range (frange &r, tree type,\n   return true;\n }\n \n+// Final tweaks for float binary op op1_range/op2_range.\n+// Return TRUE if the operation is performed and a valid range is available.\n+\n+static bool\n+float_binary_op_range_finish (bool ret, frange &r, tree type,\n+\t\t\t      const frange &lhs)\n+{\n+  if (!ret)\n+    return false;\n+\n+  // If we get a known NAN from reverse op, it means either that\n+  // the other operand was known NAN (in that case we know nothing),\n+  // or the reverse operation introduced a known NAN.\n+  // Say for lhs = op1 * op2 if lhs is [-0, +0] and op2 is too,\n+  // 0 / 0 is known NAN.  Just punt in that case.\n+  // Or if lhs is a known NAN, we also don't know anything.\n+  if (r.known_isnan () || lhs.known_isnan ())\n+    {\n+      r.set_varying (type);\n+      return true;\n+    }\n+\n+  // If lhs isn't NAN, then neither operand could be NAN,\n+  // even if the reverse operation does introduce a maybe_nan.\n+  if (!lhs.maybe_isnan ())\n+    r.clear_nan ();\n+  // If lhs is a maybe or known NAN, the operand could be\n+  // NAN.\n+  else\n+    r.update_nan ();\n+  return true;\n+}\n+\n // True if [lb, ub] is [+-0, +-0].\n static bool\n zero_p (const REAL_VALUE_TYPE &lb, const REAL_VALUE_TYPE &ub)\n@@ -1955,6 +1988,30 @@ zero_to_inf_range (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, int signbit_known)\n \n class foperator_plus : public range_operator_float\n {\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+public:\n+  virtual bool op1_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op2,\n+\t\t\t  relation_trio = TRIO_VARYING) const final override\n+  {\n+    if (lhs.undefined_p ())\n+      return false;\n+    range_op_handler minus (MINUS_EXPR, type);\n+    if (!minus)\n+      return false;\n+    return float_binary_op_range_finish (minus.fold_range (r, type, lhs, op2),\n+\t\t\t\t\t r, type, lhs);\n+  }\n+  virtual bool op2_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op1,\n+\t\t\t  relation_trio = TRIO_VARYING) const final override\n+  {\n+    return op1_range (r, type, lhs, op1);\n+  }\n+private:\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n \t\ttree type,\n \t\tconst REAL_VALUE_TYPE &lh_lb,\n@@ -1980,6 +2037,31 @@ class foperator_plus : public range_operator_float\n \n class foperator_minus : public range_operator_float\n {\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+public:\n+  virtual bool op1_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op2,\n+\t\t\t  relation_trio = TRIO_VARYING) const final override\n+  {\n+    if (lhs.undefined_p ())\n+      return false;\n+    return float_binary_op_range_finish (fop_plus.fold_range (r, type, lhs,\n+\t\t\t\t\t\t\t      op2),\n+\t\t\t\t\t r, type, lhs);\n+  }\n+  virtual bool op2_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op1,\n+\t\t\t  relation_trio = TRIO_VARYING) const final override\n+  {\n+    if (lhs.undefined_p ())\n+      return false;\n+    return float_binary_op_range_finish (fold_range (r, type, op1, lhs),\n+\t\t\t\t\t r, type, lhs);\n+  }\n+private:\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n \t\ttree type,\n \t\tconst REAL_VALUE_TYPE &lh_lb,\n@@ -2030,6 +2112,30 @@ class foperator_mult_div_base : public range_operator_float\n \n class foperator_mult : public foperator_mult_div_base\n {\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+public:\n+  virtual bool op1_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op2,\n+\t\t\t  relation_trio = TRIO_VARYING) const final override\n+  {\n+    if (lhs.undefined_p ())\n+      return false;\n+    range_op_handler rdiv (RDIV_EXPR, type);\n+    if (!rdiv)\n+      return false;\n+    return float_binary_op_range_finish (rdiv.fold_range (r, type, lhs, op2),\n+\t\t\t\t\t r, type, lhs);\n+  }\n+  virtual bool op2_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op1,\n+\t\t\t  relation_trio = TRIO_VARYING) const final override\n+  {\n+    return op1_range (r, type, lhs, op1);\n+  }\n+private:\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n \t\ttree type,\n \t\tconst REAL_VALUE_TYPE &lh_lb,\n@@ -2137,6 +2243,31 @@ class foperator_mult : public foperator_mult_div_base\n \n class foperator_div : public foperator_mult_div_base\n {\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+public:\n+  virtual bool op1_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op2,\n+\t\t\t  relation_trio = TRIO_VARYING) const final override\n+  {\n+    if (lhs.undefined_p ())\n+      return false;\n+    return float_binary_op_range_finish (fop_mult.fold_range (r, type, lhs,\n+\t\t\t\t\t\t\t      op2),\n+\t\t\t\t\t r, type, lhs);\n+  }\n+  virtual bool op2_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op1,\n+\t\t\t  relation_trio = TRIO_VARYING) const final override\n+  {\n+    if (lhs.undefined_p ())\n+      return false;\n+    return float_binary_op_range_finish (fold_range (r, type, op1, lhs),\n+\t\t\t\t\t r, type, lhs);\n+  }\n+private:\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n \t\ttree type,\n \t\tconst REAL_VALUE_TYPE &lh_lb,"}, {"sha": "119775d7b891b9826850b7a9ec24ebfd73db0ac1", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/inf-4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4c2f1d376da6fc3f3c30a9d3160e43c95399343/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4c2f1d376da6fc3f3c30a9d3160e43c95399343/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Finf-4.c?ref=d4c2f1d376da6fc3f3c30a9d3160e43c95399343", "patch": "@@ -0,0 +1,26 @@\n+__attribute__((noipa)) int\n+foo (double a, double b)\n+{\n+  double c = a - b;\n+  if (!__builtin_isfinite (c))\n+    {\n+      if (__builtin_isnan (c))\n+\t{\n+\t  if (!__builtin_isnan (a) && !__builtin_isnan (b))\n+\t    return 1;\n+\t}\n+      else if (__builtin_isfinite (a) && __builtin_isfinite (b))\n+\treturn 2;\n+    }\n+  else if (c == 0 && a != b)\n+    return 3;\n+  return 4;\n+}\n+\n+int\n+main ()\n+{\n+  double a = __builtin_inf ();\n+  if (foo (a, a) != 1)\n+    __builtin_abort ();\n+}"}]}