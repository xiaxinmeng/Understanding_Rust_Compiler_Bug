{"sha": "1ee85ee19b06863781374b7c9f97e4f6e931118b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVlODVlZTE5YjA2ODYzNzgxMzc0YjdjOWY5N2U0ZjZlOTMxMTE4Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-11T23:16:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-11T23:16:42Z"}, "message": "common.opt (flto-odr-type-merging): New flag.\n\n\n\t* common.opt (flto-odr-type-merging): New flag.\n\t* ipa-deivrt.c (hash_type_name): Use ODR names for hasing if availale.\n\t(types_same_for_odr): Likewise.\n\t(odr_subtypes_equivalent_p): Likewise.\n\t(add_type_duplicate): Do not walk type variants.\n\t(register_odr_type): New function.\n\t* ipa-utils.h (register_odr_type): Declare.\n\t(odr_type_p): New function.\n\t* langhooks.c (lhd_set_decl_assembler_name): Do not compute\n\tTYPE_DECLs\n\t* doc/invoke.texi (-flto-odr-type-merging): Document.\n\t* tree.c (need_assembler_name_p): Compute ODR names when asked\n\tfor it.\n\t* tree.h (DECL_ASSEMBLER_NAME): Update comment.\n\n\t* lto.c (lto_read_decls): Register ODR types.\n\nFrom-SVN: r215196", "tree": {"sha": "5ca60267bac44557141301c497a4c5364a3466f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ca60267bac44557141301c497a4c5364a3466f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ee85ee19b06863781374b7c9f97e4f6e931118b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ee85ee19b06863781374b7c9f97e4f6e931118b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ee85ee19b06863781374b7c9f97e4f6e931118b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ee85ee19b06863781374b7c9f97e4f6e931118b/comments", "author": null, "committer": null, "parents": [{"sha": "bc9132dee6c4a8a4348a15ad62772d632351388b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9132dee6c4a8a4348a15ad62772d632351388b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc9132dee6c4a8a4348a15ad62772d632351388b"}], "stats": {"total": 225, "additions": 175, "deletions": 50}, "files": [{"sha": "ba4a0ddffe154d45dfa94b2ef8bfd6cf7c314a97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -1,3 +1,20 @@\n+2014-09-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* common.opt (flto-odr-type-merging): New flag.\n+\t* ipa-deivrt.c (hash_type_name): Use ODR names for hasing if availale.\n+\t(types_same_for_odr): Likewise.\n+\t(odr_subtypes_equivalent_p): Likewise.\n+\t(add_type_duplicate): Do not walk type variants.\n+\t(register_odr_type): New function.\n+\t* ipa-utils.h (register_odr_type): Declare.\n+\t(odr_type_p): New function.\n+\t* langhooks.c (lhd_set_decl_assembler_name): Do not compute\n+\tTYPE_DECLs\n+\t* doc/invoke.texi (-flto-odr-type-merging): Document.\n+\t* tree.c (need_assembler_name_p): Compute ODR names when asked\n+\tfor it.\n+\t* tree.h (DECL_ASSEMBLER_NAME): Update comment.\n+\n 2014-09-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/63228"}, {"sha": "634a72bc1c1fee9d28d3520e4e268c371dc769a9", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -1560,6 +1560,10 @@ flto-compression-level=\n Common Joined RejectNegative UInteger Var(flag_lto_compression_level) Init(-1)\n -flto-compression-level=<number>\tUse zlib compression level <number> for IL\n \n+flto-odr-type-merging\n+Common Report Var(flag_lto_odr_type_mering) Init(1)\n+Merge C++ types using One Definition Rule\n+\n flto-report\n Common Report Var(flag_lto_report) Init(0)\n Report various link-time optimization statistics"}, {"sha": "eae4ab1ac5e7e0d62311404116cc8abc56056d49", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -9019,6 +9019,12 @@ The value @code{one} specifies that exactly one partition should be\n used while the value @code{none} bypasses partitioning and executes\n the link-time optimization step directly from the WPA phase.\n \n+@item -flto-odr-type-merging\n+@opindex flto-odr-type-merging\n+Enable streaming of mangled types names of C++ types and their unification\n+at linktime.  This increases size of LTO object files, but enable\n+diagnostics about One Definition Rule violations.\n+\n @item -flto-compression-level=@var{n}\n This option specifies the level of compression used for intermediate\n language written to LTO object files, and is only meaningful in"}, {"sha": "2981a858718f70987341be148952a80e81b2ec6f", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 101, "deletions": 48, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -287,7 +287,13 @@ hash_type_name (tree t)\n   if (type_in_anonymous_namespace_p (t))\n     return htab_hash_pointer (t);\n \n-  /* For polymorphic types, we can simply hash the virtual table.  */\n+  /* ODR types have name specified.  */\n+  if (TYPE_NAME (t)\n+      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n+    return IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME (TYPE_NAME (t)));\n+\n+  /* For polymorphic types that was compiled with -fno-lto-odr-type-merging\n+     we can simply hash the virtual table.  */\n   if (TREE_CODE (t) == RECORD_TYPE\n       && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n     {\n@@ -305,8 +311,14 @@ hash_type_name (tree t)\n       return hash;\n     }\n \n-  /* Rest is not implemented yet.  */\n-  gcc_unreachable ();\n+  /* Builtin types may appear as main variants of ODR types and are unique.\n+     Sanity check we do not get anything that looks non-builtin.  */\n+  gcc_checking_assert (TREE_CODE (t) == INTEGER_TYPE\n+\t\t       || TREE_CODE (t) == VOID_TYPE\n+\t\t       || TREE_CODE (t) == COMPLEX_TYPE\n+\t\t       || TREE_CODE (t) == REAL_TYPE\n+\t\t       || TREE_CODE (t) == POINTER_TYPE);\n+  return htab_hash_pointer (t);\n }\n \n /* Return the computed hashcode for ODR_TYPE.  */\n@@ -347,42 +359,61 @@ types_same_for_odr (const_tree type1, const_tree type2)\n       || type_in_anonymous_namespace_p (type2))\n     return false;\n \n-  /* See if types are obvoiusly different (i.e. different codes\n-     or polymorphis wrt non-polymorphic).  This is not strictly correct\n-     for ODR violating programs, but we can't do better without streaming\n-     ODR names.  */\n-  if (TREE_CODE (type1) != TREE_CODE (type2))\n-    return false;\n-  if (TREE_CODE (type1) == RECORD_TYPE\n-      && (TYPE_BINFO (type1) == NULL_TREE) != (TYPE_BINFO (type1) == NULL_TREE))\n-    return false;\n-  if (TREE_CODE (type1) == RECORD_TYPE && TYPE_BINFO (type1)\n-      && (BINFO_VTABLE (TYPE_BINFO (type1)) == NULL_TREE)\n-\t != (BINFO_VTABLE (TYPE_BINFO (type2)) == NULL_TREE))\n-    return false;\n \n-  /* At the moment we have no way to establish ODR equivlaence at LTO\n-     other than comparing virtual table pointrs of polymorphic types.\n-     Eventually we should start saving mangled names in TYPE_NAME.\n-     Then this condition will become non-trivial.  */\n+  /* ODR name of the type is set in DECL_ASSEMBLER_NAME of its TYPE_NAME.\n \n-  if (TREE_CODE (type1) == RECORD_TYPE\n-      && TYPE_BINFO (type1) && TYPE_BINFO (type2)\n-      && BINFO_VTABLE (TYPE_BINFO (type1))\n-      && BINFO_VTABLE (TYPE_BINFO (type2)))\n+     Ideally we should never meed types without ODR names here.  It can however\n+     happen in two cases:\n+\n+       1) for builtin types that are not streamed but rebuilt in lto/lto-lang.c\n+          Here testing for equivalence is safe, since their MAIN_VARIANTs are\n+          unique.\n+       2) for units streamed with -fno-lto-odr-type-merging.  Here we can't\n+\t  establish precise ODR equivalency, but for correctness we care only\n+\t  about equivalency on complete polymorphic types.  For these we can\n+\t  compare assembler names of their virtual tables.  */\n+  if ((!TYPE_NAME (type1) || !DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (type1)))\n+      || (!TYPE_NAME (type2) || !DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (type2))))\n     {\n-      tree v1 = BINFO_VTABLE (TYPE_BINFO (type1));\n-      tree v2 = BINFO_VTABLE (TYPE_BINFO (type2));\n-      gcc_assert (TREE_CODE (v1) == POINTER_PLUS_EXPR\n-\t\t  && TREE_CODE (v2) == POINTER_PLUS_EXPR);\n-      return (operand_equal_p (TREE_OPERAND (v1, 1),\n-\t\t\t       TREE_OPERAND (v2, 1), 0)\n-\t      && DECL_ASSEMBLER_NAME\n-\t\t     (TREE_OPERAND (TREE_OPERAND (v1, 0), 0))\n-\t\t == DECL_ASSEMBLER_NAME\n-\t\t     (TREE_OPERAND (TREE_OPERAND (v2, 0), 0)));\n+      /* See if types are obvoiusly different (i.e. different codes\n+\t or polymorphis wrt non-polymorphic).  This is not strictly correct\n+\t for ODR violating programs, but we can't do better without streaming\n+\t ODR names.  */\n+      if (TREE_CODE (type1) != TREE_CODE (type2))\n+\treturn false;\n+      if (TREE_CODE (type1) == RECORD_TYPE\n+\t  && (TYPE_BINFO (type1) == NULL_TREE) != (TYPE_BINFO (type1) == NULL_TREE))\n+\treturn false;\n+      if (TREE_CODE (type1) == RECORD_TYPE && TYPE_BINFO (type1)\n+\t  && (BINFO_VTABLE (TYPE_BINFO (type1)) == NULL_TREE)\n+\t     != (BINFO_VTABLE (TYPE_BINFO (type2)) == NULL_TREE))\n+\treturn false;\n+\n+      /* At the moment we have no way to establish ODR equivlaence at LTO\n+\t other than comparing virtual table pointrs of polymorphic types.\n+\t Eventually we should start saving mangled names in TYPE_NAME.\n+\t Then this condition will become non-trivial.  */\n+\n+      if (TREE_CODE (type1) == RECORD_TYPE\n+\t  && TYPE_BINFO (type1) && TYPE_BINFO (type2)\n+\t  && BINFO_VTABLE (TYPE_BINFO (type1))\n+\t  && BINFO_VTABLE (TYPE_BINFO (type2)))\n+\t{\n+\t  tree v1 = BINFO_VTABLE (TYPE_BINFO (type1));\n+\t  tree v2 = BINFO_VTABLE (TYPE_BINFO (type2));\n+\t  gcc_assert (TREE_CODE (v1) == POINTER_PLUS_EXPR\n+\t\t      && TREE_CODE (v2) == POINTER_PLUS_EXPR);\n+\t  return (operand_equal_p (TREE_OPERAND (v1, 1),\n+\t\t\t\t   TREE_OPERAND (v2, 1), 0)\n+\t\t  && DECL_ASSEMBLER_NAME\n+\t\t\t (TREE_OPERAND (TREE_OPERAND (v1, 0), 0))\n+\t\t     == DECL_ASSEMBLER_NAME\n+\t\t\t (TREE_OPERAND (TREE_OPERAND (v2, 0), 0)));\n+\t}\n+      gcc_unreachable ();\n     }\n-  gcc_unreachable ();\n+  return (DECL_ASSEMBLER_NAME (TYPE_NAME (type1))\n+\t  == DECL_ASSEMBLER_NAME (TYPE_NAME (type2)));\n }\n \n \n@@ -451,33 +482,35 @@ odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<tree> *visited)\n   t2 = main_odr_variant (t2);\n   if (t1 == t2)\n     return true;\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return false;\n-  if ((TYPE_NAME (t1) == NULL_TREE) != (TYPE_NAME (t2) == NULL_TREE))\n-    return false;\n-  if (TYPE_NAME (t1) && DECL_NAME (TYPE_NAME (t1)) != DECL_NAME (TYPE_NAME (t2)))\n-    return false;\n \n   /* Anonymous namespace types must match exactly.  */\n   an1 = type_in_anonymous_namespace_p (t1);\n   an2 = type_in_anonymous_namespace_p (t2);\n   if (an1 != an2 || an1)\n     return false;\n \n-  /* For types where we can not establish ODR equivalency, recurse and deeply\n-     compare.  */\n-  if (TREE_CODE (t1) != RECORD_TYPE\n-      || !TYPE_BINFO (t1) || !TYPE_BINFO (t2)\n-      || !polymorphic_type_binfo_p (TYPE_BINFO (t1))\n-      || !polymorphic_type_binfo_p (TYPE_BINFO (t2)))\n+  /* For types where we can not establish ODR equivalency (either by ODR names\n+     or by virtual tables), recurse and deeply compare.  */\n+  if ((!odr_type_p (t1) || !odr_type_p (t2))\n+      && (TREE_CODE (t1) != RECORD_TYPE || TREE_CODE (t2) != RECORD_TYPE\n+          || !TYPE_BINFO (t1) || !TYPE_BINFO (t2)\n+          || !polymorphic_type_binfo_p (TYPE_BINFO (t1))\n+          || !polymorphic_type_binfo_p (TYPE_BINFO (t2))))\n     {\n+      if (TREE_CODE (t1) != TREE_CODE (t2))\n+\treturn false;\n+      if ((TYPE_NAME (t1) == NULL_TREE) != (TYPE_NAME (t2) == NULL_TREE))\n+\treturn false;\n+      if (TYPE_NAME (t1) && DECL_NAME (TYPE_NAME (t1)) != DECL_NAME (TYPE_NAME (t2)))\n+\treturn false;\n       /* This should really be a pair hash, but for the moment we do not need\n \t 100% reliability and it would be better to compare all ODR types so\n \t recursion here is needed only for component types.  */\n       if (visited->add (t1))\n \treturn true;\n       return odr_types_equivalent_p (t1, t2, false, NULL, visited);\n     }\n+\n   return types_same_for_odr (t1, t2);\n }\n \n@@ -1148,8 +1181,14 @@ add_type_duplicate (odr_type val, tree type)\n \t to external declarations of methods that may be defined in the\n \t merged LTO unit.  For this reason we absolutely need to remove\n \t them and replace by internal variants. Not doing so will lead\n-         to incomplete answers from possible_polymorphic_call_targets.  */\n+         to incomplete answers from possible_polymorphic_call_targets.\n+\n+\t FIXME: disable for now; because ODR types are now build during\n+\t streaming in, the variants do not need to be linked to the type,\n+\t yet.  We need to do the merging in cleanup pass to be implemented\n+\t soon.  */\n       if (!flag_ltrans && merge\n+\t  && 0\n \t  && TREE_CODE (val->type) == RECORD_TYPE\n \t  && TREE_CODE (type) == RECORD_TYPE\n \t  && TYPE_BINFO (val->type) && TYPE_BINFO (type)\n@@ -1281,6 +1320,20 @@ get_odr_type (tree type, bool insert)\n   return val;\n }\n \n+/* Add TYPE od ODR type hash.  */\n+\n+void\n+register_odr_type (tree type)\n+{\n+  if (!odr_hash)\n+    odr_hash = new odr_hash_type (23);\n+  /* Arrange things to be nicer and insert main variants first.  */\n+  if (odr_type_p (TYPE_MAIN_VARIANT (type)))\n+    get_odr_type (TYPE_MAIN_VARIANT (type), true);\n+  if (TYPE_MAIN_VARIANT (type) != type)\n+    get_odr_type (type, true);\n+}\n+\n /* Dump ODR type T and all its derrived type.  INDENT specify indentation for\n    recusive printing.  */\n "}, {"sha": "9c81d5c639df6d48eeda9e68860d72b10ed228de", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -152,6 +152,7 @@ tree vtable_pointer_value_to_binfo (const_tree);\n bool vtable_pointer_value_to_vtable (const_tree, tree *, unsigned HOST_WIDE_INT *);\n void compare_virtual_tables (varpool_node *, varpool_node *);\n bool contains_polymorphic_type_p (const_tree);\n+void register_odr_type (tree);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If FINALP is non-NULL, store true if the list is complette. \n@@ -239,6 +240,23 @@ possible_polymorphic_call_target_p (tree call,\n \t\t\t\t\t     context,\n \t\t\t\t\t     n);\n }\n+\n+/* Return true of T is type with One Definition Rule info attached. \n+   It means that either it is anonymous type or it has assembler name\n+   set.  */\n+\n+static inline bool\n+odr_type_p (const_tree t)\n+{\n+  if (type_in_anonymous_namespace_p (t))\n+    return true;\n+  /* We do not have this information when not in LTO, but we do not need\n+     to care, since it is used only for type merging.  */\n+  gcc_assert (in_lto_p || flag_lto);\n+\n+  return (TYPE_NAME (t)\n+          && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))));\n+}\n #endif  /* GCC_IPA_UTILS_H  */\n \n "}, {"sha": "7d4c294700a9c74e6574eaddc7b799cbd0f16b2a", "filename": "gcc/langhooks.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -147,6 +147,11 @@ lhd_set_decl_assembler_name (tree decl)\n {\n   tree id;\n \n+  /* set_decl_assembler_name may be called on TYPE_DECL to record ODR\n+     name for C++ types.  By default types have no ODR names.  */\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    return;\n+\n   /* The language-independent code should never use the\n      DECL_ASSEMBLER_NAME for lots of DECLs.  Only FUNCTION_DECLs and\n      VAR_DECLs for variables with static storage duration need a real"}, {"sha": "a8dd53f8a8e49a66d6c23a20f818d4324be3cb6d", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -1,3 +1,7 @@\n+2014-09-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (lto_read_decls): Register ODR types.\n+\n 2014-08-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (read_cgraph_and_symbols): Fix symtab_remove_unreachable_nodes"}, {"sha": "570b1f7c35f05afe70f4823a40606771c4f58e42", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pass_manager.h\"\n #include \"ipa-inline.h\"\n #include \"params.h\"\n+#include \"ipa-utils.h\"\n \n \n /* Number of parallel tasks to run, -1 if we want to use GNU Make jobserver.  */\n@@ -1911,7 +1912,11 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t      /* Compute the canonical type of all types.\n \t\t ???  Should be able to assert that !TYPE_CANONICAL.  */\n \t      if (TYPE_P (t) && !TYPE_CANONICAL (t))\n-\t\tgimple_register_canonical_type (t);\n+\t\t{\n+\t\t  gimple_register_canonical_type (t);\n+\t\t  if (odr_type_p (t))\n+\t\t    register_odr_type (t);\n+\t\t}\n \t      /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its\n \t\t type which is also member of this SCC.  */\n \t      if (TREE_CODE (t) == INTEGER_CST"}, {"sha": "e40ee23e1e3d6d571761687549376926853c184e", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -4980,6 +4980,15 @@ free_lang_data_in_type (tree type)\n static inline bool\n need_assembler_name_p (tree decl)\n {\n+  /* We use DECL_ASSEMBLER_NAME to hold mangled type names for One Definition Rule\n+     merging.  */\n+  if (flag_lto_odr_type_mering\n+      && TREE_CODE (decl) == TYPE_DECL\n+      && DECL_NAME (decl)\n+      && decl == TYPE_NAME (TREE_TYPE (decl))\n+      && !is_lang_specific (TREE_TYPE (decl))\n+      && !type_in_anonymous_namespace_p (TREE_TYPE (decl)))\n+    return !DECL_ASSEMBLER_NAME_SET_P (decl);\n   /* Only FUNCTION_DECLs and VAR_DECLs are considered.  */\n   if (TREE_CODE (decl) != FUNCTION_DECL\n       && TREE_CODE (decl) != VAR_DECL)"}, {"sha": "93a940aaee0727cdc733e85dc111d8f2bbcdbad3", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ee85ee19b06863781374b7c9f97e4f6e931118b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1ee85ee19b06863781374b7c9f97e4f6e931118b", "patch": "@@ -2344,7 +2344,11 @@ extern void decl_value_expr_insert (tree, tree);\n \n /* The name of the object as the assembler will see it (but before any\n    translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n-   as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n+   as DECL_NAME.  It is an IDENTIFIER_NODE.\n+\n+   ASSEMBLER_NAME of TYPE_DECLS may store global name of type used for\n+   One Definition Rule based type merging at LTO.  It is computed only for\n+   LTO compilation and C++.  */\n #define DECL_ASSEMBLER_NAME(NODE) decl_assembler_name (NODE)\n \n /* Return true if NODE is a NODE that can contain a DECL_ASSEMBLER_NAME."}]}