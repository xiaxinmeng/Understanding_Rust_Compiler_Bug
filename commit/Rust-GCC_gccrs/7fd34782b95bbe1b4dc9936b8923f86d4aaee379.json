{"sha": "7fd34782b95bbe1b4dc9936b8923f86d4aaee379", "node_id": "C_kwDOANBUbNoAKDdmZDM0NzgyYjk1YmJlMWI0ZGM5OTM2Yjg5MjNmODZkNGFhZWUzNzk", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2022-06-24T11:52:44Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2022-06-24T11:52:44Z"}, "message": "Fix stmt_kills_ref_p WRT external throws\n\nAdd missing check to stmt_kills_ref_p for case that function\nis terminated by EH before call return value kills the ref. In the PR\nI tried to construct testcase but I don't know how to do that until I\nannotate EH code with fnspec attributes which I will do in separate patch\nand add a testcase.\n\n\tPR ipa/106057\n\t* tree-ssa-alias.cc (stmt_kills_ref_p): Check for external throw.", "tree": {"sha": "fa668f35065c45cf9fd948e8f08572d4e351e561", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa668f35065c45cf9fd948e8f08572d4e351e561"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fd34782b95bbe1b4dc9936b8923f86d4aaee379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd34782b95bbe1b4dc9936b8923f86d4aaee379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd34782b95bbe1b4dc9936b8923f86d4aaee379", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd34782b95bbe1b4dc9936b8923f86d4aaee379/comments", "author": null, "committer": null, "parents": [{"sha": "268b5c81e93ac3ff44fc8ace22ce504d8faa4b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268b5c81e93ac3ff44fc8ace22ce504d8faa4b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268b5c81e93ac3ff44fc8ace22ce504d8faa4b07"}], "stats": {"total": 24, "additions": 18, "deletions": 6}, "files": [{"sha": "782266bdad8ab0625ed038d93d9522fb8ffb508f", "filename": "gcc/tree-ssa-alias.cc", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd34782b95bbe1b4dc9936b8923f86d4aaee379/gcc%2Ftree-ssa-alias.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd34782b95bbe1b4dc9936b8923f86d4aaee379/gcc%2Ftree-ssa-alias.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.cc?ref=7fd34782b95bbe1b4dc9936b8923f86d4aaee379", "patch": "@@ -87,10 +87,11 @@ along with GCC; see the file COPYING3.  If not see\n \n      This function tries to disambiguate two reference trees.\n \n-   bool ptr_deref_may_alias_global_p (tree)\n+   bool ptr_deref_may_alias_global_p (tree, bool)\n \n      This function queries if dereferencing a pointer variable may\n-     alias global memory.\n+     alias global memory.  If bool argument is true, global memory\n+     is considered to also include function local memory that escaped.\n \n    More low-level disambiguators are available and documented in\n    this file.  Low-level disambiguators dealing with points-to\n@@ -3333,11 +3334,18 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n       && TREE_CODE (gimple_get_lhs (stmt)) != SSA_NAME\n       /* The assignment is not necessarily carried out if it can throw\n \t and we can catch it in the current function where we could inspect\n-\t the previous value.\n+\t the previous value.  Similarly if the function can throw externally\n+\t and the ref does not die on the function return.\n \t ???  We only need to care about the RHS throwing.  For aggregate\n \t assignments or similar calls and non-call exceptions the LHS\n-\t might throw as well.  */\n-      && !stmt_can_throw_internal (cfun, stmt))\n+\t might throw as well.\n+\t ???  We also should care about possible longjmp, but since we\n+\t do not understand that longjmp is not using global memory we will\n+\t not consider a kill here since the function call will be considered\n+\t as possibly using REF.\t */\n+      && !stmt_can_throw_internal (cfun, stmt)\n+      && (!stmt_can_throw_external (cfun, stmt)\n+\t  || !ref_may_alias_global_p (ref, false)))\n     {\n       tree lhs = gimple_get_lhs (stmt);\n       /* If LHS is literally a base of the access we are done.  */\n@@ -3434,8 +3442,12 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t  && node->binds_to_current_def_p ()\n \t  && (summary = get_modref_function_summary (node)) != NULL\n \t  && summary->kills.length ()\n+\t  /* Check that we can not trap while evaulating function\n+\t     parameters.  This check is overly conservative.  */\n \t  && (!cfun->can_throw_non_call_exceptions\n-\t      || !stmt_can_throw_internal (cfun, stmt)))\n+\t      || (!stmt_can_throw_internal (cfun, stmt)\n+\t\t  && (!stmt_can_throw_external (cfun, stmt)\n+\t\t      || !ref_may_alias_global_p (ref, false)))))\n \t{\n \t  for (auto kill : summary->kills)\n \t    {"}]}