{"sha": "d8041cc89f1e72d6a67de3c152f0f5f758c7d507", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwNDFjYzg5ZjFlNzJkNmE2N2RlM2MxNTJmMGY1Zjc1OGM3ZDUwNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-01T00:12:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-01T00:12:15Z"}, "message": "dwarf2out.c (struct dw_loc_descr_struct): Add dw_loc_addr.\n\n        * dwarf2out.c (struct dw_loc_descr_struct): Add dw_loc_addr.\n        (size_of_locs): Set it.\n        (output_loc_operands): Use it to compute branch displacement.\n        (int_loc_descriptor): New.\n        (mem_loc_descriptor): Dereference memory in the proper size.\n        Use DW_OP_plus_uconst when possible.  Use int_loc_descriptor.\n        (loc_descriptor_from_tree): New.\n        (rtl_for_decl_location): Break out from ...\n        (add_location_or_const_value_attribute): ... here.\n        (add_bound_info): Use loc_descriptor_from_tree.\n\nFrom-SVN: r37172", "tree": {"sha": "47f8dbc1dff7fcae119b12e1e6c74faacd3b3864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f8dbc1dff7fcae119b12e1e6c74faacd3b3864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8041cc89f1e72d6a67de3c152f0f5f758c7d507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8041cc89f1e72d6a67de3c152f0f5f758c7d507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8041cc89f1e72d6a67de3c152f0f5f758c7d507", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8041cc89f1e72d6a67de3c152f0f5f758c7d507/comments", "author": null, "committer": null, "parents": [{"sha": "86368122e68f2b697cf898523d408bea831fa6e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86368122e68f2b697cf898523d408bea831fa6e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86368122e68f2b697cf898523d408bea831fa6e7"}], "stats": {"total": 488, "additions": 435, "deletions": 53}, "files": [{"sha": "21b94a3529d7b84ce57f0186120290259ceb30b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8041cc89f1e72d6a67de3c152f0f5f758c7d507/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8041cc89f1e72d6a67de3c152f0f5f758c7d507/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8041cc89f1e72d6a67de3c152f0f5f758c7d507", "patch": "@@ -1,3 +1,16 @@\n+2000-10-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (struct dw_loc_descr_struct): Add dw_loc_addr.\n+\t(size_of_locs): Set it.\n+\t(output_loc_operands): Use it to compute branch displacement.\n+\t(int_loc_descriptor): New.\n+\t(mem_loc_descriptor): Dereference memory in the proper size.\n+\tUse DW_OP_plus_uconst when possible.  Use int_loc_descriptor.\n+\t(loc_descriptor_from_tree): New.\n+\t(rtl_for_decl_location): Break out from ...\n+\t(add_location_or_const_value_attribute): ... here.\n+\t(add_bound_info): Use loc_descriptor_from_tree.\n+\n 2000-10-31  Neil Booth  <neilb@earthling.net>\n \n \t* cpp.texi: Update for new command line assertion syntax."}, {"sha": "02ec9ce3fad1817d0abdc58827397f8eb751146f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 422, "deletions": 53, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8041cc89f1e72d6a67de3c152f0f5f758c7d507/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8041cc89f1e72d6a67de3c152f0f5f758c7d507/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d8041cc89f1e72d6a67de3c152f0f5f758c7d507", "patch": "@@ -2176,6 +2176,7 @@ typedef struct dw_loc_descr_struct\n   enum dwarf_location_atom dw_loc_opc;\n   dw_val_node dw_loc_oprnd1;\n   dw_val_node dw_loc_oprnd2;\n+  int dw_loc_addr;\n }\n dw_loc_descr_node;\n \n@@ -2645,7 +2646,10 @@ size_of_locs (loc)\n   register unsigned long size = 0;\n \n   for (; loc != NULL; loc = loc->dw_loc_next)\n-    size += size_of_loc_descr (loc);\n+    {\n+      loc->dw_loc_addr = size;\n+      size += size_of_loc_descr (loc);\n+    }\n \n   return size;\n }\n@@ -2683,8 +2687,17 @@ output_loc_operands (loc)\n       break;\n     case DW_OP_skip:\n     case DW_OP_bra:\n-      ASM_OUTPUT_DWARF_DATA2 (asm_out_file, val1->v.val_int);\n-      fputc ('\\n', asm_out_file);\n+      {\n+\tint offset;\n+\n+\tif (val1->val_class == dw_val_class_loc)\n+\t  offset = val1->v.val_loc->dw_loc_addr - (loc->dw_loc_addr + 3);\n+\telse\n+\t  abort ();\n+\n+\tASM_OUTPUT_DWARF_DATA2 (asm_out_file, offset);\n+\tfputc ('\\n', asm_out_file);\n+      }\n       break;\n #else\n     case DW_OP_addr:\n@@ -3426,11 +3439,13 @@ static dw_die_ref modified_type_die\tPARAMS ((tree, int, int, dw_die_ref));\n static int type_is_enum\t\t\tPARAMS ((tree));\n static unsigned int reg_number\t\tPARAMS ((rtx));\n static dw_loc_descr_ref reg_loc_descriptor PARAMS ((rtx));\n+static dw_loc_descr_ref int_loc_descriptor PARAMS ((HOST_WIDE_INT));\n static dw_loc_descr_ref based_loc_descr\tPARAMS ((unsigned, long));\n static int is_based_loc\t\t\tPARAMS ((rtx));\n static dw_loc_descr_ref mem_loc_descriptor PARAMS ((rtx, enum machine_mode mode));\n static dw_loc_descr_ref concat_loc_descriptor PARAMS ((rtx, rtx));\n static dw_loc_descr_ref loc_descriptor\tPARAMS ((rtx));\n+static dw_loc_descr_ref loc_descriptor_from_tree PARAMS ((tree, int));\n static HOST_WIDE_INT ceiling\t\tPARAMS ((HOST_WIDE_INT, unsigned int));\n static tree field_type\t\t\tPARAMS ((tree));\n static unsigned int simple_type_align_in_bits PARAMS ((tree));\n@@ -3440,6 +3455,7 @@ static void add_AT_location_description\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute, rtx));\n static void add_data_member_location_attribute PARAMS ((dw_die_ref, tree));\n static void add_const_value_attribute\tPARAMS ((dw_die_ref, rtx));\n+static rtx rtl_for_decl_location\tPARAMS ((tree));\n static void add_location_or_const_value_attribute PARAMS ((dw_die_ref, tree));\n static void tree_add_const_value_attribute PARAMS ((dw_die_ref, tree));\n static void add_name_attribute\t\tPARAMS ((dw_die_ref, const char *));\n@@ -7173,6 +7189,46 @@ reg_loc_descriptor (rtl)\n   return loc_result;\n }\n \n+/* Return a location descriptor that designates a constant.  */\n+\n+static dw_loc_descr_ref\n+int_loc_descriptor (i)\n+     HOST_WIDE_INT i;\n+{\n+  enum dwarf_location_atom op;\n+\n+  /* Pick the smallest representation of a constant, rather than just\n+     defaulting to the LEB encoding.  */\n+  if (i >= 0)\n+    {\n+      if (i <= 31)\n+\top = DW_OP_lit0 + i;\n+      else if (i <= 0xff)\n+\top = DW_OP_const1u;\n+      else if (i <= 0xffff)\n+\top = DW_OP_const2u;\n+      else if (HOST_BITS_PER_WIDE_INT == 32\n+\t       || i <= 0xffffffff)\n+\top = DW_OP_const4u;\n+      else\n+\top = DW_OP_constu;\n+    }\n+  else\n+    {\n+      if (i >= -0x80)\n+\top = DW_OP_const1s;\n+      else if (i >= -0x8000)\n+\top = DW_OP_const2s;\n+      else if (HOST_BITS_PER_WIDE_INT == 32\n+\t       || i >= -0x80000000)\n+\top = DW_OP_const4s;\n+      else\n+\top = DW_OP_consts;\n+    }\n+\n+  return new_loc_descr (op, i, 0);\n+}\n+\n /* Return a location descriptor that designates a base+offset location.  */\n \n static dw_loc_descr_ref\n@@ -7274,12 +7330,22 @@ mem_loc_descriptor (rtl, mode)\n       break;\n \n     case MEM:\n-      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode);\n-      add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n+      {\n+\tdw_loc_descr_ref deref;\n+\n+\tmem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n+\n+\tif (GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE)\n+\t  deref = new_loc_descr (DW_OP_deref, 0, 0);\n+\telse\n+\t  deref = new_loc_descr (DW_OP_deref_size, GET_MODE_SIZE (mode), 0);\n+\n+\tadd_loc_descr (&mem_loc_result, deref);\n+      }\n       break;\n \n-     case LABEL_REF:\n-       /* Some ports can transform a symbol ref into a label ref, because\n+    case LABEL_REF:\n+      /* Some ports can transform a symbol ref into a label ref, because\n  \t the symbol ref is too far away and has to be dumped into a constant\n  \t pool.  */\n     case CONST:\n@@ -7306,24 +7372,37 @@ mem_loc_descriptor (rtl, mode)\n \t\t\t\t\t  INTVAL (XEXP (rtl, 1)));\n       else\n \t{\n-\t  add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 0),\n-\t\t\t\t\t\t\t      mode));\n-\t  add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 1),\n-\t\t\t\t\t\t\t      mode));\n-\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_plus, 0, 0));\n+\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode);\n+\n+\t  if (GET_CODE (XEXP (rtl, 1)) == CONST_INT\n+\t      && INTVAL (XEXP (rtl, 1)) >= 0)\n+\t    {\n+\t      add_loc_descr (&mem_loc_result,\n+\t\t\t     new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t    INTVAL (XEXP (rtl, 1)), 0));\n+\t    }\n+\t  else\n+\t    {\n+\t      add_loc_descr (&mem_loc_result,\n+\t\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode));\n+\t      add_loc_descr (&mem_loc_result,\n+\t\t\t     new_loc_descr (DW_OP_plus, 0, 0));\n+\t    }\n \t}\n       break;\n \n     case MULT:\n       /* If a pseudo-reg is optimized away, it is possible for it to\n \t be replaced with a MEM containing a multiply.  */\n-      add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 0), mode));\n-      add_loc_descr (&mem_loc_result, mem_loc_descriptor (XEXP (rtl, 1), mode));\n+      add_loc_descr (&mem_loc_result,\n+\t\t     mem_loc_descriptor (XEXP (rtl, 0), mode));\n+      add_loc_descr (&mem_loc_result,\n+\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode));\n       add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_mul, 0, 0));\n       break;\n \n     case CONST_INT:\n-      mem_loc_result = new_loc_descr (DW_OP_constu, INTVAL (rtl), 0);\n+      mem_loc_result = int_loc_descriptor (INTVAL (rtl));\n       break;\n \n     default:\n@@ -7399,6 +7478,260 @@ loc_descriptor (rtl)\n   return loc_result;\n }\n \n+/* Similar, but generate the descriptor from trees instead of rtl.\n+   This comes up particularly with variable length arrays.  */\n+\n+static dw_loc_descr_ref\n+loc_descriptor_from_tree (loc, addressp)\n+     tree loc;\n+     int addressp;\n+{\n+  dw_loc_descr_ref ret = NULL;\n+  int indirect_size = 0;\n+  int unsignedp = TREE_UNSIGNED (TREE_TYPE (loc));\n+  enum dwarf_location_atom op;\n+\n+  /* ??? Most of the time we do not take proper care for sign/zero\n+     extending the values properly.  Hopefully this won't be a real\n+     problem...  */\n+\n+  switch (TREE_CODE (loc))\n+    {\n+    case ERROR_MARK:\n+      break;\n+\n+    case VAR_DECL:\n+    case PARM_DECL:\n+      {\n+\trtx rtl = rtl_for_decl_location (loc);\n+\tenum machine_mode mode = DECL_MODE (loc);\n+\n+\tif (CONSTANT_P (rtl))\n+\t  {\n+\t    ret = new_loc_descr (DW_OP_addr, 0, 0);\n+\t    ret->dw_loc_oprnd1.val_class = dw_val_class_addr;\n+\t    ret->dw_loc_oprnd1.v.val_addr = rtl;\n+\t    indirect_size = GET_MODE_SIZE (mode);\n+\t  }\n+\telse\n+\t  {\n+\t    if (GET_CODE (rtl) == MEM)\n+\t      {\n+\t\tindirect_size = GET_MODE_SIZE (mode);\n+\t\trtl = XEXP (rtl, 0);\n+\t      }\n+\t    ret = mem_loc_descriptor (rtl, mode);\n+\t  }\n+      }\n+      break;\n+\n+    case INDIRECT_REF:\n+      ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+      indirect_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (loc)));\n+      break;\n+\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case ARRAY_REF:\n+      {\n+\ttree obj, offset;\n+\tHOST_WIDE_INT bitsize, bitpos, bytepos;\n+\tenum machine_mode mode;\n+\tint volatilep;\n+\tunsigned int alignment;\n+\n+\tobj = get_inner_reference (loc, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t   &unsignedp, &volatilep, &alignment);\n+\tret = loc_descriptor_from_tree (obj, 1);\n+\n+\tif (offset != NULL_TREE)\n+\t  {\n+\t    /* Variable offset.  */\n+\t    add_loc_descr (&ret, loc_descriptor_from_tree (offset, 0));\n+\t    add_loc_descr (&ret, new_loc_descr (DW_OP_plus, 0, 0));\n+\t  }\n+\n+\tif (addressp)\n+\t  {\n+\t    /* We cannot address anything not on a unit boundary.  */\n+\t    if (bitpos % BITS_PER_UNIT != 0)\n+\t      abort ();\n+\t  }\n+\telse\n+\t  {\n+\t    if (bitpos % BITS_PER_UNIT != 0\n+\t\t|| bitsize % BITS_PER_UNIT != 0)\n+\t      {\n+\t\t/* ??? We could handle this by loading and shifting etc.\n+\t\t   Wait until someone needs it before expending the effort.  */\n+\t\tabort ();\n+\t      }\n+\n+\t    indirect_size = bitsize / BITS_PER_UNIT;\n+\t  }\n+\n+\tbytepos = bitpos / BITS_PER_UNIT;\n+\tif (bytepos > 0)\n+\t  add_loc_descr (&ret, new_loc_descr (DW_OP_plus_uconst, bytepos, 0));\n+\telse if (bytepos < 0)\n+\t  {\n+\t    add_loc_descr (&ret, int_loc_descriptor (bytepos));\n+\t    add_loc_descr (&ret, new_loc_descr (DW_OP_plus, 0, 0));\n+\t  }\n+\tbreak;\n+      }\n+\n+    case INTEGER_CST:\n+      if (host_integerp (loc, 0))\n+\tret = int_loc_descriptor (tree_low_cst (loc, 0));\n+      break;\n+      break;\n+\n+    case BIT_AND_EXPR:\n+      op = DW_OP_and;\n+      goto do_binop;\n+    case BIT_XOR_EXPR:\n+      op = DW_OP_xor;\n+      goto do_binop;\n+    case BIT_IOR_EXPR:\n+      op = DW_OP_or;\n+      goto do_binop;\n+    case TRUNC_DIV_EXPR:\n+      op = DW_OP_div;\n+      goto do_binop;\n+    case MINUS_EXPR:\n+      op = DW_OP_minus;\n+      goto do_binop;\n+    case TRUNC_MOD_EXPR:\n+      op = DW_OP_mod;\n+      goto do_binop;\n+    case MULT_EXPR:\n+      op = DW_OP_mul;\n+      goto do_binop;\n+    case LSHIFT_EXPR:\n+      op = DW_OP_shl;\n+      goto do_binop;\n+    case RSHIFT_EXPR:\n+      op = (unsignedp ? DW_OP_shr : DW_OP_shra);\n+      goto do_binop;\n+    case PLUS_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (loc, 1)) == INTEGER_CST\n+\t  && host_integerp (TREE_OPERAND (loc, 1), 0))\n+\t{\n+\t  ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+\t  add_loc_descr (&ret,\n+\t\t\t new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\ttree_low_cst (TREE_OPERAND (loc, 1),\n+\t\t\t\t\t\t      0),\n+\t\t\t\t\t0));\n+\t  break;\n+\t}\n+      op = DW_OP_plus;\n+      goto do_binop;\n+    case LE_EXPR:\n+      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+\tbreak;\n+      op = DW_OP_le;\n+      goto do_binop;\n+    case GE_EXPR:\n+      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+\tbreak;\n+      op = DW_OP_ge;\n+      goto do_binop;\n+    case LT_EXPR:\n+      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+\tbreak;\n+      op = DW_OP_lt;\n+      goto do_binop;\n+    case GT_EXPR:\n+      if (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))\n+\tbreak;\n+      op = DW_OP_gt;\n+      goto do_binop;\n+    case EQ_EXPR:\n+      op = DW_OP_eq;\n+      goto do_binop;\n+    case NE_EXPR:\n+      op = DW_OP_ne;\n+      goto do_binop;\n+\n+    do_binop:\n+      ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+      add_loc_descr (&ret, loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0));\n+      add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n+      break;\n+\n+    case BIT_NOT_EXPR:\n+      op = DW_OP_not;\n+      goto do_unop;\n+    case ABS_EXPR:\n+      op = DW_OP_abs;\n+      goto do_unop;\n+    case NEGATE_EXPR:\n+      op = DW_OP_neg;\n+      goto do_unop;\n+\n+    do_unop:\n+      ret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+      add_loc_descr (&ret, new_loc_descr (op, 0, 0));\n+      break;\n+\n+    case MAX_EXPR:\n+      loc = build (COND_EXPR, TREE_TYPE (loc),\n+\t\t   build (LT_EXPR, integer_type_node,\n+\t\t\t  TREE_OPERAND (loc, 0), TREE_OPERAND (loc, 1)),\n+\t\t   TREE_OPERAND (loc, 1), TREE_OPERAND (loc, 0));\n+      /* FALLTHRU */\n+\n+    case COND_EXPR:\n+      {\n+\tdw_loc_descr_ref bra_node, jump_node, tmp;\n+\n+\tret = loc_descriptor_from_tree (TREE_OPERAND (loc, 0), 0);\n+\tbra_node = new_loc_descr (DW_OP_bra, 0, 0);\n+\tadd_loc_descr (&ret, bra_node);\n+\n+\ttmp = loc_descriptor_from_tree (TREE_OPERAND (loc, 2), 0);\n+\tadd_loc_descr (&ret, tmp);\n+\tjump_node = new_loc_descr (DW_OP_skip, 0, 0);\n+\tadd_loc_descr (&ret, jump_node);\n+\n+\ttmp = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);\n+\tadd_loc_descr (&ret, tmp);\n+\tbra_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\tbra_node->dw_loc_oprnd1.v.val_loc = tmp;\n+\n+\t/* ??? Need a node to point the skip at.  Use a nop.  */\n+\ttmp = new_loc_descr (DW_OP_nop, 0, 0);\n+\tadd_loc_descr (&ret, tmp);\n+\tjump_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\tjump_node->dw_loc_oprnd1.v.val_loc = tmp;\n+      }\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  /* If we can't fill the request for an address, die.  */\n+  if (addressp && indirect_size == 0)\n+    abort ();\n+\n+  /* If we've got an address and don't want one, dereference.  */\n+  if (!addressp && indirect_size > 0)\n+    {\n+      if (indirect_size > DWARF2_ADDR_SIZE)\n+\tabort ();\n+      if (indirect_size == DWARF2_ADDR_SIZE)\n+\top = DW_OP_deref;\n+      else\n+\top = DW_OP_deref_size;\n+      add_loc_descr (&ret, new_loc_descr (op, indirect_size, 0));\n+    }\n+\n+  return ret;\n+}\n+\n /* Given a value, round it up to the lowest multiple of `boundary'\n    which is not less than the value itself.  */\n \n@@ -7768,31 +8101,11 @@ add_const_value_attribute (die, rtl)\n \n }\n \n-/* Generate *either* an DW_AT_location attribute or else an DW_AT_const_value\n-   data attribute for a variable or a parameter.  We generate the\n-   DW_AT_const_value attribute only in those cases where the given variable\n-   or parameter does not have a true \"location\" either in memory or in a\n-   register.  This can happen (for example) when a constant is passed as an\n-   actual argument in a call to an inline function.  (It's possible that\n-   these things can crop up in other ways also.)  Note that one type of\n-   constant value which can be passed into an inlined function is a constant\n-   pointer.  This can happen for example if an actual argument in an inlined\n-   function call evaluates to a compile-time constant address.  */\n-\n-static void\n-add_location_or_const_value_attribute (die, decl)\n-     register dw_die_ref die;\n-     register tree decl;\n+static rtx\n+rtl_for_decl_location (decl)\n+     tree decl;\n {\n   register rtx rtl;\n-  register tree declared_type;\n-  register tree passed_type;\n-\n-  if (TREE_CODE (decl) == ERROR_MARK)\n-    return;\n-\n-  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != PARM_DECL)\n-    abort ();\n \n   /* Here we have to decide where we are going to say the parameter \"lives\"\n      (as far as the debugger is concerned).  We only have a couple of\n@@ -7876,8 +8189,8 @@ add_location_or_const_value_attribute (die, decl)\n     {\n       if (rtl == NULL_RTX || is_pseudo_reg (rtl))\n \t{\n-\t  declared_type = type_main_variant (TREE_TYPE (decl));\n-\t  passed_type = type_main_variant (DECL_ARG_TYPE (decl));\n+\t  tree declared_type = type_main_variant (TREE_TYPE (decl));\n+\t  tree passed_type = type_main_variant (DECL_ARG_TYPE (decl));\n \n \t  /* This decl represents a formal parameter which was optimized out.\n \t     Note that DECL_INCOMING_RTL may be NULL in here, but we handle\n@@ -7924,14 +8237,43 @@ add_location_or_const_value_attribute (die, decl)\n \t}\n     }\n \n-  if (rtl == NULL_RTX)\n-    return;\n-\n-  rtl = eliminate_regs (rtl, 0, NULL_RTX);\n+  if (rtl != NULL_RTX)\n+    {\n+      rtl = eliminate_regs (rtl, 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n-  if (current_function_uses_only_leaf_regs)\n-    leaf_renumber_regs_insn (rtl);\n+      if (current_function_uses_only_leaf_regs)\n+\tleaf_renumber_regs_insn (rtl);\n #endif\n+    }\n+\n+  return rtl;\n+}\n+\n+/* Generate *either* an DW_AT_location attribute or else an DW_AT_const_value\n+   data attribute for a variable or a parameter.  We generate the\n+   DW_AT_const_value attribute only in those cases where the given variable\n+   or parameter does not have a true \"location\" either in memory or in a\n+   register.  This can happen (for example) when a constant is passed as an\n+   actual argument in a call to an inline function.  (It's possible that\n+   these things can crop up in other ways also.)  Note that one type of\n+   constant value which can be passed into an inlined function is a constant\n+   pointer.  This can happen for example if an actual argument in an inlined\n+   function call evaluates to a compile-time constant address.  */\n+\n+static void\n+add_location_or_const_value_attribute (die, decl)\n+     register dw_die_ref die;\n+     register tree decl;\n+{\n+  register rtx rtl;\n+\n+  if (TREE_CODE (decl) == ERROR_MARK)\n+    return;\n+\n+  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != PARM_DECL)\n+    abort ();\n+\n+  rtl = rtl_for_decl_location (decl);\n \n   switch (GET_CODE (rtl))\n     {\n@@ -8102,16 +8444,43 @@ add_bound_info (subrange_die, bound_attr, bound)\n       /* Else leave out the attribute.  */\n       break;\n \n-    case MAX_EXPR:\n     case VAR_DECL:\n-    case COMPONENT_REF:\n-    case COND_EXPR:\n-      /* ??? These types of bounds can be created by the Ada front end,\n-\t and it isn't clear how to emit debug info for them.  */\n-      break;\n+    case PARM_DECL:\n+      {\n+\tdw_die_ref decl_die = lookup_decl_die (bound);\n+\n+\t/* ??? Can this happen, or should the variable have been bound\n+\t   first?  Probably it can, since I imagine that we try to create\n+\t   the types of parameters in the order in which they exist in\n+\t   the list, and won't have created a forward reference to a \n+\t   later parameter.  */\n+\tif (decl_die != NULL)\n+\t  add_AT_die_ref (subrange_die, bound_attr, decl_die);\n+\tbreak;\n+      }\n \n     default:\n-      abort ();\n+      {\n+\t/* Otherwise try to create a stack operation procedure to\n+\t   evaluate the value of the array bound.  */\n+\n+\tdw_die_ref ctx, decl_die;\n+\tdw_loc_descr_ref loc;\n+\n+\tloc = loc_descriptor_from_tree (bound, 0);\n+\tif (loc == NULL)\n+\t  break;\n+\n+\tctx = lookup_decl_die (current_function_decl);\n+\n+\tdecl_die = new_die (DW_TAG_variable, ctx);\n+\tadd_AT_flag (decl_die, DW_AT_artificial, 1);\n+\tadd_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n+\tadd_AT_loc (decl_die, DW_AT_location, loc);\n+\n+\tadd_AT_die_ref (subrange_die, bound_attr, decl_die);\n+\tbreak;\n+      }\n     }\n }\n "}]}