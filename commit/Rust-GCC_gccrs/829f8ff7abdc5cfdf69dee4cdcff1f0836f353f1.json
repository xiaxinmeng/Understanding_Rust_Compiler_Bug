{"sha": "829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI5ZjhmZjdhYmRjNWNmZGY2OWRlZTRjZGNmZjFmMDgzNmYzNTNmMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-07-26T00:27:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-07-26T00:27:34Z"}, "message": "combine.c (combine_max_regno): Remove.\n\n\t* combine.c (combine_max_regno): Remove.  Remove all uses.\n\t(struct reg_stat_struct): Rename from struct reg_stat.\n\t(reg_stat_type): Define, and declare VECs.\n\t(reg_stat): Change from pointer to VEC.  Change all uses.\n\t(combine_split_insns): New static function.\n\t(try_combine, find_split_point): Call it instead of split_insns.\n\nFrom-SVN: r126942", "tree": {"sha": "bfa01cdcd333693cddb3706d1cb23f593ffdfbf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfa01cdcd333693cddb3706d1cb23f593ffdfbf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1/comments", "author": null, "committer": null, "parents": [{"sha": "a3f444ba418083ed3e5637501cb5fa5e42b0900b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f444ba418083ed3e5637501cb5fa5e42b0900b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f444ba418083ed3e5637501cb5fa5e42b0900b"}], "stats": {"total": 325, "additions": 196, "deletions": 129}, "files": [{"sha": "8e01a599b99f617a4f407e0468f95c7084ffe3c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1", "patch": "@@ -1,3 +1,12 @@\n+2007-07-25  Ian Lance Taylor  <iant@google.com>\n+\n+\t* combine.c (combine_max_regno): Remove.  Remove all uses.\n+\t(struct reg_stat_struct): Rename from struct reg_stat.\n+\t(reg_stat_type): Define, and declare VECs.\n+\t(reg_stat): Change from pointer to VEC.  Change all uses.\n+\t(combine_split_insns): New static function.\n+\t(try_combine, find_split_point): Call it instead of split_insns.\n+\n 2007-07-25  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* cfghooks.c (split_block): Fix the information about loop latch."}, {"sha": "e3a3fb189e76f75c9d38f54a639cd5ba1e48673a", "filename": "gcc/combine.c", "status": "modified", "additions": 187, "deletions": 129, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=829f8ff7abdc5cfdf69dee4cdcff1f0836f353f1", "patch": "@@ -143,11 +143,7 @@ static rtx i2mod_old_rhs;\n \n static rtx i2mod_new_rhs;\n \f\n-/* Maximum register number, which is the size of the tables below.  */\n-\n-static unsigned int combine_max_regno;\n-\n-struct reg_stat {\n+typedef struct reg_stat_struct {\n   /* Record last point of death of (hard or pseudo) register n.  */\n   rtx\t\t\t\tlast_death;\n \n@@ -254,9 +250,12 @@ struct reg_stat {\n      value.  */\n \n   ENUM_BITFIELD(machine_mode)\ttruncated_to_mode : 8;\n-};\n+} reg_stat_type;\n+\n+DEF_VEC_O(reg_stat_type);\n+DEF_VEC_ALLOC_O(reg_stat_type,heap);\n \n-static struct reg_stat *reg_stat;\n+static VEC(reg_stat_type,heap) *reg_stat;\n \n /* Record the luid of the last insn that invalidated memory\n    (anything that writes memory, and subroutine calls, but not pushes).  */\n@@ -468,6 +467,25 @@ static rtx gen_lowpart_or_truncate (enum machine_mode, rtx);\n static const struct rtl_hooks combine_rtl_hooks = RTL_HOOKS_INITIALIZER;\n \n \f\n+/* Try to split PATTERN found in INSN.  This returns NULL_RTX if\n+   PATTERN can not be split.  Otherwise, it returns an insn sequence.\n+   This is a wrapper around split_insns which ensures that the\n+   reg_stat vector is made larger if the splitter creates a new\n+   register.  */\n+\n+static rtx\n+combine_split_insns (rtx pattern, rtx insn)\n+{\n+  rtx ret;\n+  unsigned int nregs;\n+\n+  ret = split_insns (pattern, insn);\n+  nregs = max_reg_num ();\n+  if (nregs > VEC_length (reg_stat_type, reg_stat))\n+    VEC_safe_grow_cleared (reg_stat_type, heap, reg_stat, nregs);\n+  return ret;\n+}\n+\n /* This is used by find_single_use to locate an rtx in LOC that\n    contains exactly one use of DEST, which is typically either a REG\n    or CC0.  It returns a pointer to the innermost rtx expression\n@@ -1024,11 +1042,9 @@ combine_instructions (rtx f, unsigned int nregs)\n   combine_extras = 0;\n   combine_successes = 0;\n \n-  combine_max_regno = nregs;\n-\n   rtl_hooks = combine_rtl_hooks;\n \n-  reg_stat = XCNEWVEC (struct reg_stat, nregs);\n+  VEC_safe_grow_cleared (reg_stat_type, heap, reg_stat, nregs);\n \n   init_recog_no_volatile ();\n \n@@ -1261,7 +1277,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   /* Clean up.  */\n   free (uid_log_links);\n   free (uid_insn_cost);\n-  free (reg_stat);\n+  VEC_free (reg_stat_type, heap, reg_stat);\n \n   {\n     struct undo *undo, *next;\n@@ -1293,8 +1309,10 @@ static void\n init_reg_last (void)\n {\n   unsigned int i;\n-  for (i = 0; i < combine_max_regno; i++)\n-    memset (reg_stat + i, 0, offsetof (struct reg_stat, sign_bit_copies));\n+  reg_stat_type *p;\n+\n+  for (i = 0; VEC_iterate (reg_stat_type, reg_stat, i, p); ++i)\n+    memset (p, 0, offsetof (reg_stat_type, sign_bit_copies));\n }\n \f\n /* Set up any promoted values for incoming argument registers.  */\n@@ -1357,10 +1375,12 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set, void *data)\n            (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x))\n       && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n     {\n+      reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n \t{\n-\t  reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n-\t  reg_stat[REGNO (x)].sign_bit_copies = 1;\n+\t  rsp->nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n+\t  rsp->sign_bit_copies = 1;\n \t  return;\n \t}\n \n@@ -1391,8 +1411,8 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set, void *data)\n \t    }\n \t  if (!link)\n \t    {\n-\t      reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n-\t      reg_stat[REGNO (x)].sign_bit_copies = 1;\n+\t      rsp->nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n+\t      rsp->sign_bit_copies = 1;\n \t      return;\n \t    }\n \t}\n@@ -1434,18 +1454,17 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set, void *data)\n #endif\n \n \t  /* Don't call nonzero_bits if it cannot change anything.  */\n-\t  if (reg_stat[REGNO (x)].nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)\n-\t    reg_stat[REGNO (x)].nonzero_bits\n-\t      |= nonzero_bits (src, nonzero_bits_mode);\n+\t  if (rsp->nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)\n+\t    rsp->nonzero_bits |= nonzero_bits (src, nonzero_bits_mode);\n \t  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n-\t  if (reg_stat[REGNO (x)].sign_bit_copies == 0\n-\t      || reg_stat[REGNO (x)].sign_bit_copies > num)\n-\t    reg_stat[REGNO (x)].sign_bit_copies = num;\n+\t  if (rsp->sign_bit_copies == 0\n+\t      || rsp->sign_bit_copies > num)\n+\t    rsp->sign_bit_copies = num;\n \t}\n       else\n \t{\n-\t  reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n-\t  reg_stat[REGNO (x)].sign_bit_copies = 1;\n+\t  rsp->nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n+\t  rsp->sign_bit_copies = 1;\n \t}\n     }\n }\n@@ -2869,13 +2888,13 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n   if (i1 && insn_code_number < 0 && GET_CODE (newpat) == SET\n       && asm_noperands (newpat) < 0)\n     {\n-      rtx m_split, *split;\n+      rtx parallel, m_split, *split;\n \n       /* See if the MD file can split NEWPAT.  If it can't, see if letting it\n \t use I2DEST as a scratch register will help.  In the latter case,\n \t convert I2DEST to the mode of the source of NEWPAT if we can.  */\n \n-      m_split = split_insns (newpat, i3);\n+      m_split = combine_split_insns (newpat, i3);\n \n       /* We can only use I2DEST as a scratch reg if it doesn't overlap any\n \t inputs of NEWPAT.  */\n@@ -2890,12 +2909,11 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \t  /* First try to split using the original register as a\n \t     scratch register.  */\n-\t  m_split = split_insns (gen_rtx_PARALLEL\n-\t\t\t\t (VOIDmode,\n-\t\t\t\t  gen_rtvec (2, newpat,\n-\t\t\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t\t      i2dest))),\n-\t\t\t\t i3);\n+\t  parallel = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t       gen_rtvec (2, newpat,\n+\t\t\t\t\t\t  gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t\t\t   i2dest)));\n+\t  m_split = combine_split_insns (parallel, i3);\n \n \t  /* If that didn't work, try changing the mode of I2DEST if\n \t     we can.  */\n@@ -2915,12 +2933,12 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t  ni2dest = regno_reg_rtx[REGNO (i2dest)];\n \t\t}\n \n-\t      m_split = split_insns (gen_rtx_PARALLEL\n-\t\t\t\t     (VOIDmode,\n-\t\t\t\t      gen_rtvec (2, newpat,\n-\t\t\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t\t\t  ni2dest))),\n-\t\t\t\t     i3);\n+\t      parallel = (gen_rtx_PARALLEL\n+\t\t\t  (VOIDmode,\n+\t\t\t   gen_rtvec (2, newpat,\n+\t\t\t\t      gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t       ni2dest))));\n+\t      m_split = combine_split_insns (parallel, i3);\n \n \t      if (m_split == 0\n \t\t  && REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n@@ -2939,9 +2957,10 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       /* If recog_for_combine has discarded clobbers, try to use them\n \t again for the split.  */\n       if (m_split == 0 && newpat_vec_with_clobbers)\n-\tm_split\n-\t  = split_insns (gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t\t   newpat_vec_with_clobbers), i3);\n+\t{\n+\t  parallel = gen_rtx_PARALLEL (VOIDmode, newpat_vec_with_clobbers);\n+\t  m_split = combine_split_insns (parallel, i3);\n+\t}\n \n       if (m_split && NEXT_INSN (m_split) == NULL_RTX)\n \t{\n@@ -3191,18 +3210,22 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t (REG_P (temp)\n-\t\t  && reg_stat[REGNO (temp)].nonzero_bits != 0\n+\t\t  && VEC_index (reg_stat_type, reg_stat,\n+\t\t\t\tREGNO (temp))->nonzero_bits != 0\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t  && (reg_stat[REGNO (temp)].nonzero_bits\n+\t\t  && (VEC_index (reg_stat_type, reg_stat,\n+\t\t\t\t REGNO (temp))->nonzero_bits\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n \t\t && (temp = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n \t\t     (REG_P (temp)\n-\t\t      && reg_stat[REGNO (temp)].nonzero_bits != 0\n+\t\t      && VEC_index (reg_stat_type, reg_stat,\n+\t\t\t\t    REGNO (temp))->nonzero_bits != 0\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t      && (reg_stat[REGNO (temp)].nonzero_bits\n+\t\t      && (VEC_index (reg_stat_type, reg_stat,\n+\t\t\t\t     REGNO (temp))->nonzero_bits\n \t\t\t  != GET_MODE_MASK (word_mode)))))\n \t   && ! reg_overlap_mentioned_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t\t SET_SRC (XVECEXP (newpat, 0, 1)))\n@@ -3849,8 +3872,9 @@ find_split_point (rtx *loc, rtx insn)\n \t  && ! memory_address_p (GET_MODE (x), XEXP (x, 0)))\n \t{\n \t  rtx reg = regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n-\t  rtx seq = split_insns (gen_rtx_SET (VOIDmode, reg, XEXP (x, 0)),\n-\t\t\t\t subst_insn);\n+\t  rtx seq = combine_split_insns (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t\t\t\t      XEXP (x, 0)),\n+\t\t\t\t\t subst_insn);\n \n \t  /* This should have produced two insns, each of which sets our\n \t     placeholder.  If the source of the second is a valid address,\n@@ -8606,26 +8630,28 @@ reg_nonzero_bits_for_combine (rtx x, enum machine_mode mode,\n \t\t\t      unsigned HOST_WIDE_INT *nonzero)\n {\n   rtx tem;\n+  reg_stat_type *rsp;\n \n   /* If X is a register whose nonzero bits value is current, use it.\n      Otherwise, if X is a register whose value we can find, use that\n      value.  Otherwise, use the previously-computed global nonzero bits\n      for this register.  */\n \n-  if (reg_stat[REGNO (x)].last_set_value != 0\n-      && (reg_stat[REGNO (x)].last_set_mode == mode\n-\t  || (GET_MODE_CLASS (reg_stat[REGNO (x)].last_set_mode) == MODE_INT\n+  rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  if (rsp->last_set_value != 0\n+      && (rsp->last_set_mode == mode\n+\t  || (GET_MODE_CLASS (rsp->last_set_mode) == MODE_INT\n \t      && GET_MODE_CLASS (mode) == MODE_INT))\n-      && ((reg_stat[REGNO (x)].last_set_label >= label_tick_ebb_start\n-\t   && reg_stat[REGNO (x)].last_set_label < label_tick)\n-\t  || (reg_stat[REGNO (x)].last_set_label == label_tick\n-              && DF_INSN_LUID (reg_stat[REGNO (x)].last_set) < subst_low_luid)\n+      && ((rsp->last_set_label >= label_tick_ebb_start\n+\t   && rsp->last_set_label < label_tick)\n+\t  || (rsp->last_set_label == label_tick\n+              && DF_INSN_LUID (rsp->last_set) < subst_low_luid)\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n \t      && !REGNO_REG_SET_P\n \t          (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x)))))\n     {\n-      *nonzero &= reg_stat[REGNO (x)].last_set_nonzero_bits;\n+      *nonzero &= rsp->last_set_nonzero_bits;\n       return NULL;\n     }\n \n@@ -8655,9 +8681,9 @@ reg_nonzero_bits_for_combine (rtx x, enum machine_mode mode,\n #endif\n       return tem;\n     }\n-  else if (nonzero_sign_valid && reg_stat[REGNO (x)].nonzero_bits)\n+  else if (nonzero_sign_valid && rsp->nonzero_bits)\n     {\n-      unsigned HOST_WIDE_INT mask = reg_stat[REGNO (x)].nonzero_bits;\n+      unsigned HOST_WIDE_INT mask = rsp->nonzero_bits;\n \n       if (GET_MODE_BITSIZE (GET_MODE (x)) < GET_MODE_BITSIZE (mode))\n \t/* We don't know anything about the upper bits.  */\n@@ -8682,29 +8708,31 @@ reg_num_sign_bit_copies_for_combine (rtx x, enum machine_mode mode,\n \t\t\t\t     unsigned int *result)\n {\n   rtx tem;\n-\n-  if (reg_stat[REGNO (x)].last_set_value != 0\n-      && reg_stat[REGNO (x)].last_set_mode == mode\n-      && ((reg_stat[REGNO (x)].last_set_label >= label_tick_ebb_start\n-\t   && reg_stat[REGNO (x)].last_set_label < label_tick)\n-\t  || (reg_stat[REGNO (x)].last_set_label == label_tick\n-              && DF_INSN_LUID (reg_stat[REGNO (x)].last_set) < subst_low_luid)\n+  reg_stat_type *rsp;\n+\n+  rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  if (rsp->last_set_value != 0\n+      && rsp->last_set_mode == mode\n+      && ((rsp->last_set_label >= label_tick_ebb_start\n+\t   && rsp->last_set_label < label_tick)\n+\t  || (rsp->last_set_label == label_tick\n+              && DF_INSN_LUID (rsp->last_set) < subst_low_luid)\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n \t      && !REGNO_REG_SET_P\n \t          (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x)))))\n     {\n-      *result = reg_stat[REGNO (x)].last_set_sign_bit_copies;\n+      *result = rsp->last_set_sign_bit_copies;\n       return NULL;\n     }\n \n   tem = get_last_value (x);\n   if (tem != 0)\n     return tem;\n \n-  if (nonzero_sign_valid && reg_stat[REGNO (x)].sign_bit_copies != 0\n+  if (nonzero_sign_valid && rsp->sign_bit_copies != 0\n       && GET_MODE_BITSIZE (GET_MODE (x)) == GET_MODE_BITSIZE (mode))\n-    *result = reg_stat[REGNO (x)].sign_bit_copies;\n+    *result = rsp->sign_bit_copies;\n \n   return NULL;\n }\n@@ -11156,7 +11184,10 @@ update_table_tick (rtx x)\n       unsigned int r;\n \n       for (r = regno; r < endregno; r++)\n-\treg_stat[r].last_set_table_tick = label_tick;\n+\t{\n+\t  reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, r);\n+\t  rsp->last_set_table_tick = label_tick;\n+\t}\n \n       return;\n     }\n@@ -11214,6 +11245,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   unsigned int regno = REGNO (reg);\n   unsigned int endregno = END_REGNO (reg);\n   unsigned int i;\n+  reg_stat_type *rsp;\n \n   /* If VALUE contains REG and we have a previous value for REG, substitute\n      the previous value.  */\n@@ -11254,15 +11286,17 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n      register.  */\n   for (i = regno; i < endregno; i++)\n     {\n+      rsp = VEC_index (reg_stat_type, reg_stat, i);\n+\n       if (insn)\n-\treg_stat[i].last_set = insn;\n+\trsp->last_set = insn;\n \n-      reg_stat[i].last_set_value = 0;\n-      reg_stat[i].last_set_mode = 0;\n-      reg_stat[i].last_set_nonzero_bits = 0;\n-      reg_stat[i].last_set_sign_bit_copies = 0;\n-      reg_stat[i].last_death = 0;\n-      reg_stat[i].truncated_to_mode = 0;\n+      rsp->last_set_value = 0;\n+      rsp->last_set_mode = 0;\n+      rsp->last_set_nonzero_bits = 0;\n+      rsp->last_set_sign_bit_copies = 0;\n+      rsp->last_death = 0;\n+      rsp->truncated_to_mode = 0;\n     }\n \n   /* Mark registers that are being referenced in this value.  */\n@@ -11278,41 +11312,43 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n \n   for (i = regno; i < endregno; i++)\n     {\n-      reg_stat[i].last_set_label = label_tick;\n+      rsp = VEC_index (reg_stat_type, reg_stat, i);\n+      rsp->last_set_label = label_tick;\n       if (!insn\n-\t  || (value && reg_stat[i].last_set_table_tick >= label_tick_ebb_start))\n-\treg_stat[i].last_set_invalid = 1;\n+\t  || (value && rsp->last_set_table_tick >= label_tick_ebb_start))\n+\trsp->last_set_invalid = 1;\n       else\n-\treg_stat[i].last_set_invalid = 0;\n+\trsp->last_set_invalid = 0;\n     }\n \n   /* The value being assigned might refer to X (like in \"x++;\").  In that\n      case, we must replace it with (clobber (const_int 0)) to prevent\n      infinite loops.  */\n+  rsp = VEC_index (reg_stat_type, reg_stat, regno);\n   if (value && ! get_last_value_validate (&value, insn,\n-\t\t\t\t\t  reg_stat[regno].last_set_label, 0))\n+\t\t\t\t\t  rsp->last_set_label, 0))\n     {\n       value = copy_rtx (value);\n       if (! get_last_value_validate (&value, insn,\n-\t\t\t\t     reg_stat[regno].last_set_label, 1))\n+\t\t\t\t     rsp->last_set_label, 1))\n \tvalue = 0;\n     }\n \n   /* For the main register being modified, update the value, the mode, the\n      nonzero bits, and the number of sign bit copies.  */\n \n-  reg_stat[regno].last_set_value = value;\n+  rsp->last_set_value = value;\n \n   if (value)\n     {\n       enum machine_mode mode = GET_MODE (reg);\n       subst_low_luid = DF_INSN_LUID (insn);\n-      reg_stat[regno].last_set_mode = mode;\n+      rsp->last_set_mode = mode;\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \tmode = nonzero_bits_mode;\n-      reg_stat[regno].last_set_nonzero_bits = nonzero_bits (value, mode);\n-      reg_stat[regno].last_set_sign_bit_copies\n+      rsp->last_set_nonzero_bits = nonzero_bits (value, mode);\n+      rsp->last_set_sign_bit_copies\n \t= num_sign_bit_copies (value, GET_MODE (reg));\n     }\n }\n@@ -11385,7 +11421,12 @@ record_dead_and_set_regs (rtx insn)\n \t  unsigned int endregno = END_REGNO (XEXP (link, 0));\n \n \t  for (i = regno; i < endregno; i++)\n-\t    reg_stat[i].last_death = insn;\n+\t    {\n+\t      reg_stat_type *rsp;\n+\n+\t      rsp = VEC_index (reg_stat_type, reg_stat, i);\n+\t      rsp->last_death = insn;\n+\t    }\n \t}\n       else if (REG_NOTE_KIND (link) == REG_INC)\n \trecord_value_for_reg (XEXP (link, 0), insn, NULL_RTX);\n@@ -11396,14 +11437,17 @@ record_dead_and_set_regs (rtx insn)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t  {\n-\t    reg_stat[i].last_set_invalid = 1;\n-\t    reg_stat[i].last_set = insn;\n-\t    reg_stat[i].last_set_value = 0;\n-\t    reg_stat[i].last_set_mode = 0;\n-\t    reg_stat[i].last_set_nonzero_bits = 0;\n-\t    reg_stat[i].last_set_sign_bit_copies = 0;\n-\t    reg_stat[i].last_death = 0;\n-\t    reg_stat[i].truncated_to_mode = 0;\n+\t    reg_stat_type *rsp;\n+\n+\t    rsp = VEC_index (reg_stat_type, reg_stat, i);\n+\t    rsp->last_set_invalid = 1;\n+\t    rsp->last_set = insn;\n+\t    rsp->last_set_value = 0;\n+\t    rsp->last_set_mode = 0;\n+\t    rsp->last_set_nonzero_bits = 0;\n+\t    rsp->last_set_sign_bit_copies = 0;\n+\t    rsp->last_death = 0;\n+\t    rsp->truncated_to_mode = 0;\n \t  }\n \n       last_call_luid = mem_last_set = DF_INSN_LUID (insn);\n@@ -11439,6 +11483,8 @@ record_promoted_value (rtx insn, rtx subreg)\n \n   for (links = LOG_LINKS (insn); links;)\n     {\n+      reg_stat_type *rsp;\n+\n       insn = XEXP (links, 0);\n       set = single_set (insn);\n \n@@ -11450,10 +11496,11 @@ record_promoted_value (rtx insn, rtx subreg)\n \t  continue;\n \t}\n \n-      if (reg_stat[regno].last_set == insn)\n+      rsp = VEC_index (reg_stat_type, reg_stat, regno);\n+      if (rsp->last_set == insn)\n \t{\n \t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg) > 0)\n-\t    reg_stat[regno].last_set_nonzero_bits &= GET_MODE_MASK (mode);\n+\t    rsp->last_set_nonzero_bits &= GET_MODE_MASK (mode);\n \t}\n \n       if (REG_P (SET_SRC (set)))\n@@ -11474,10 +11521,11 @@ record_promoted_value (rtx insn, rtx subreg)\n static bool\n reg_truncated_to_mode (enum machine_mode mode, rtx x)\n {\n-  enum machine_mode truncated = reg_stat[REGNO (x)].truncated_to_mode;\n+  reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  enum machine_mode truncated = rsp->truncated_to_mode;\n \n   if (truncated == 0\n-      || reg_stat[REGNO (x)].truncation_label < label_tick_ebb_start)\n+      || rsp->truncation_label < label_tick_ebb_start)\n     return false;\n   if (GET_MODE_SIZE (truncated) <= GET_MODE_SIZE (mode))\n     return true;\n@@ -11495,6 +11543,7 @@ static void\n record_truncated_value (rtx x)\n {\n   enum machine_mode truncated_mode;\n+  reg_stat_type *rsp;\n \n   if (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x)))\n     {\n@@ -11517,13 +11566,14 @@ record_truncated_value (rtx x)\n   else\n     return;\n \n-  if (reg_stat[REGNO (x)].truncated_to_mode == 0\n-      || reg_stat[REGNO (x)].truncation_label < label_tick_ebb_start\n+  rsp = VEC_index (reg_stat_type, reg_stat, REGNO (x));\n+  if (rsp->truncated_to_mode == 0\n+      || rsp->truncation_label < label_tick_ebb_start\n       || (GET_MODE_SIZE (truncated_mode)\n-\t  < GET_MODE_SIZE (reg_stat[REGNO (x)].truncated_to_mode)))\n+\t  < GET_MODE_SIZE (rsp->truncated_to_mode)))\n     {\n-      reg_stat[REGNO (x)].truncated_to_mode = truncated_mode;\n-      reg_stat[REGNO (x)].truncation_label = label_tick;\n+      rsp->truncated_to_mode = truncated_mode;\n+      rsp->truncation_label = label_tick;\n     }\n }\n \n@@ -11588,19 +11638,22 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n       unsigned int j;\n \n       for (j = regno; j < endregno; j++)\n-\tif (reg_stat[j].last_set_invalid\n-\t    /* If this is a pseudo-register that was only set once and not\n-\t       live at the beginning of the function, it is always valid.  */\n-\t    || (! (regno >= FIRST_PSEUDO_REGISTER\n-\t\t   && REG_N_SETS (regno) == 1\n-\t\t   && !REGNO_REG_SET_P\n-\t\t       (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), regno))\n-\t\t&& reg_stat[j].last_set_label > tick))\n+\t{\n+\t  reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, j);\n+\t  if (rsp->last_set_invalid\n+\t      /* If this is a pseudo-register that was only set once and not\n+\t\t live at the beginning of the function, it is always valid.  */\n+\t      || (! (regno >= FIRST_PSEUDO_REGISTER\n+\t\t     && REG_N_SETS (regno) == 1\n+\t\t     && (!REGNO_REG_SET_P\n+\t\t\t (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), regno)))\n+\t\t  && rsp->last_set_label > tick))\n \t  {\n \t    if (replace)\n \t      *loc = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n \t    return replace;\n \t  }\n+\t}\n \n       return 1;\n     }\n@@ -11672,6 +11725,7 @@ get_last_value (rtx x)\n {\n   unsigned int regno;\n   rtx value;\n+  reg_stat_type *rsp;\n \n   /* If this is a non-paradoxical SUBREG, get the value of its operand and\n      then convert it to the desired mode.  If this is a paradoxical SUBREG,\n@@ -11687,7 +11741,8 @@ get_last_value (rtx x)\n     return 0;\n \n   regno = REGNO (x);\n-  value = reg_stat[regno].last_set_value;\n+  rsp = VEC_index (reg_stat_type, reg_stat, regno);\n+  value = rsp->last_set_value;\n \n   /* If we don't have a value, or if it isn't for this basic block and\n      it's either a hard register, set more than once, or it's a live\n@@ -11700,7 +11755,7 @@ get_last_value (rtx x)\n      block.  */\n \n   if (value == 0\n-      || (reg_stat[regno].last_set_label < label_tick_ebb_start\n+      || (rsp->last_set_label < label_tick_ebb_start\n \t  && (regno < FIRST_PSEUDO_REGISTER\n \t      || REG_N_SETS (regno) != 1\n \t      || REGNO_REG_SET_P\n@@ -11709,21 +11764,21 @@ get_last_value (rtx x)\n \n   /* If the value was set in a later insn than the ones we are processing,\n      we can't use it even if the register was only set once.  */\n-  if (reg_stat[regno].last_set_label == label_tick\n-      && DF_INSN_LUID (reg_stat[regno].last_set) >= subst_low_luid)\n+  if (rsp->last_set_label == label_tick\n+      && DF_INSN_LUID (rsp->last_set) >= subst_low_luid)\n     return 0;\n \n   /* If the value has all its registers valid, return it.  */\n-  if (get_last_value_validate (&value, reg_stat[regno].last_set,\n-\t\t\t       reg_stat[regno].last_set_label, 0))\n+  if (get_last_value_validate (&value, rsp->last_set,\n+\t\t\t       rsp->last_set_label, 0))\n     return value;\n \n   /* Otherwise, make a copy and replace any invalid register with\n      (clobber (const_int 0)).  If that fails for some reason, return 0.  */\n \n   value = copy_rtx (value);\n-  if (get_last_value_validate (&value, reg_stat[regno].last_set,\n-\t\t\t       reg_stat[regno].last_set_label, 1))\n+  if (get_last_value_validate (&value, rsp->last_set,\n+\t\t\t       rsp->last_set_label, 1))\n     return value;\n \n   return 0;\n@@ -11751,10 +11806,13 @@ use_crosses_set_p (rtx x, int from_luid)\n \treturn 1;\n #endif\n       for (; regno < endreg; regno++)\n-\tif (reg_stat[regno].last_set\n-\t    && reg_stat[regno].last_set_label == label_tick\n-\t    && DF_INSN_LUID (reg_stat[regno].last_set) > from_luid)\n-\t  return 1;\n+\t{\n+\t  reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, regno);\n+\t  if (rsp->last_set\n+\t      && rsp->last_set_label == label_tick\n+\t      && DF_INSN_LUID (rsp->last_set) > from_luid)\n+\t    return 1;\n+\t}\n       return 0;\n     }\n \n@@ -12001,7 +12059,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx to_insn,\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      rtx where_dead = reg_stat[regno].last_death;\n+      rtx where_dead = VEC_index (reg_stat_type, reg_stat, regno)->last_death;\n \n       /* Don't move the register if it gets killed in between from and to.  */\n       if (maybe_kill_insn && reg_set_p (x, maybe_kill_insn)\n@@ -12637,20 +12695,20 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  if (place && REG_NOTE_KIND (note) == REG_DEAD)\n \t    {\n \t      unsigned int regno = REGNO (XEXP (note, 0));\n-\n+\t      reg_stat_type *rsp = VEC_index (reg_stat_type, reg_stat, regno);\n \n \t      if (dead_or_set_p (place, XEXP (note, 0))\n \t\t  || reg_bitfield_target_p (XEXP (note, 0), PATTERN (place)))\n \t\t{\n \t\t  /* Unless the register previously died in PLACE, clear\n \t\t     last_death.  [I no longer understand why this is\n \t\t     being done.] */\n-\t\t  if (reg_stat[regno].last_death != place)\n-\t\t    reg_stat[regno].last_death = 0;\n+\t\t  if (rsp->last_death != place)\n+\t\t    rsp->last_death = 0;\n \t\t  place = 0;\n \t\t}\n \t      else\n-\t\treg_stat[regno].last_death = place;\n+\t\trsp->last_death = place;\n \n \t      /* If this is a death note for a hard reg that is occupying\n \t\t multiple registers, ensure that we are still using all"}]}