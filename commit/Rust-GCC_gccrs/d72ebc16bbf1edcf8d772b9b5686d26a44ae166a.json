{"sha": "d72ebc16bbf1edcf8d772b9b5686d26a44ae166a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcyZWJjMTZiYmYxZWRjZjhkNzcyYjliNTY4NmQyNmE0NGFlMTY2YQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-04-11T20:40:02Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-11T20:40:02Z"}, "message": "i386.md (any_shiftrt): New code iterator.\n\n\t* config/i386/i386.md (any_shiftrt): New code iterator.\n\t(shiftrt_insn): New code attribute.\n\t(shiftrt): Ditto.\n\t(<shiftrt_insn><mode>3): Macroize expander from ashr<mode>3 and\n\tlshr<mode>3 using any_shiftrt code iterator.\n\t(*<shiftrt_insn><mode>3_doubleword): Macroize insn_and_split from\n\t*ashr<mode>3_doubleword and *lshr<mode>3_doubleword using\n\tany_shiftrt code iterator.\n\t(*<shiftrt_insn><mode>3_doubleword peephole2): Macroize peephole2\n\tpattern from corresponding peephole2 patterns.\n\t(*<shiftrt_insn><mode>3_1): Macroize insn from *ashr<mode>3_1\n\tand *lshr<mode>3_1 using any_shiftrt code iterator.\n\t(*<shiftrt_insn>si3_1_zext): Ditto from *ashrsi3_1_zext\n\tand *lshrsi3_1_zext.\n\t(*<shiftrt_insn>qi3_1_slp): Ditto from *ashrqi3_1_slp\n\tand *lshrqi3_1_slp.\n\t(*<shiftrt_insn><mode>3_cmp): Ditto from *ashr<mode>3_cmp\n\tand *lshr<mode>3_cmp.\n\t(*<shiftrt_insn><mode>3_cmp_zext): Ditto from *ashr<mode>3_cmp_zext\n\tand *lshr<mode>3_cmp_zext.\n\t(*<shiftrt_insn><mode>3_cconly): Ditto from *ashr<mode>3_cconly\n\tand *lshr<mode>3_cconly.\n\nFrom-SVN: r158205", "tree": {"sha": "b427c3490d6002d893977647a51c3916ae696fb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b427c3490d6002d893977647a51c3916ae696fb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d72ebc16bbf1edcf8d772b9b5686d26a44ae166a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72ebc16bbf1edcf8d772b9b5686d26a44ae166a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d72ebc16bbf1edcf8d772b9b5686d26a44ae166a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72ebc16bbf1edcf8d772b9b5686d26a44ae166a/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59caab22b5f31eef1b5b89a0caf2fc1c155585bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59caab22b5f31eef1b5b89a0caf2fc1c155585bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59caab22b5f31eef1b5b89a0caf2fc1c155585bd"}], "stats": {"total": 356, "additions": 90, "deletions": 266}, "files": [{"sha": "c3de163654d7d266e2f5f70a761c13369b887b07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72ebc16bbf1edcf8d772b9b5686d26a44ae166a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72ebc16bbf1edcf8d772b9b5686d26a44ae166a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d72ebc16bbf1edcf8d772b9b5686d26a44ae166a", "patch": "@@ -1,3 +1,28 @@\n+2010-04-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (any_shiftrt): New code iterator.\n+\t(shiftrt_insn): New code attribute.\n+\t(shiftrt): Ditto.\n+\t(<shiftrt_insn><mode>3): Macroize expander from ashr<mode>3 and\n+\tlshr<mode>3 using any_shiftrt code iterator.\n+\t(*<shiftrt_insn><mode>3_doubleword): Macroize insn_and_split from\n+\t*ashr<mode>3_doubleword and *lshr<mode>3_doubleword using\n+\tany_shiftrt code iterator.\n+\t(*<shiftrt_insn><mode>3_doubleword peephole2): Macroize peephole2\n+\tpattern from corresponding peephole2 patterns.\n+\t(*<shiftrt_insn><mode>3_1): Macroize insn from *ashr<mode>3_1\n+\tand *lshr<mode>3_1 using any_shiftrt code iterator.\n+\t(*<shiftrt_insn>si3_1_zext): Ditto from *ashrsi3_1_zext\n+\tand *lshrsi3_1_zext.\n+\t(*<shiftrt_insn>qi3_1_slp): Ditto from *ashrqi3_1_slp\n+\tand *lshrqi3_1_slp.\n+\t(*<shiftrt_insn><mode>3_cmp): Ditto from *ashr<mode>3_cmp\n+\tand *lshr<mode>3_cmp.\n+\t(*<shiftrt_insn><mode>3_cmp_zext): Ditto from *ashr<mode>3_cmp_zext\n+\tand *lshr<mode>3_cmp_zext.\n+\t(*<shiftrt_insn><mode>3_cconly): Ditto from *ashr<mode>3_cconly\n+\tand *lshr<mode>3_cconly.\n+\n 2010-04-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*ashr<mode>3_cconly): Fix wrong mode of\n@@ -16,6 +41,7 @@\n \t(*lshr<mode>3_1): Merge with *lshr{qi,hi,si}3_1_one_bit and\n \t*lshrdi3_1_one_bit_rex64. Macroize insn from *lshr{qi,hi,si}3_cmp\n \tand *lshrdi3_cmp_rex64 using SWI mode iterator.\n+\t(*lshrsi3_1_zext): Merge with *lshrsi3_1_one_bit_zext.\n \t(*lshrqi3_1_slp): Merge with *lshrqi3_1_one_bit_slp.\n \t(*lshr<mode>3_cmp): Merge with *lshr{qi,hi,si}3_one_bit_cmp and\n \t*lshrdi3_one_bit_cmp_rex64. Macroize insn from *lshr{qi,hi,si}3_cmp\n@@ -43,6 +69,7 @@\n \t(*ashr<mode>3_1): Merge with *ashr{qi,hi,si}3_1_one_bit and\n \t*ashrdi3_1_one_bit_rex64. Macroize insn from *ashr{qi,hi,si}3_cmp\n \tand *ashrdi3_cmp_rex64 using SWI mode iterator.\n+\t(*ashrsi3_1_zext): Merge with *ashrsi3_1_one_bit_zext.\n \t(*ashrqi3_1_slp): Merge with *ashrqi3_1_one_bit_slp.\n \t(*ashr<mode>3_cmp): Merge with *ashr{qi,hi,si}3_one_bit_cmp and\n \t*ashrdi3_one_bit_cmp_rex64. Macroize insn from *ashr{qi,hi,si}3_cmp"}, {"sha": "abe09cf7ee47d5356d734fb3ce945dd620ffa5d9", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 63, "deletions": 266, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72ebc16bbf1edcf8d772b9b5686d26a44ae166a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72ebc16bbf1edcf8d772b9b5686d26a44ae166a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d72ebc16bbf1edcf8d772b9b5686d26a44ae166a", "patch": "@@ -724,6 +724,15 @@\n ;; Base name for insn mnemonic.\n (define_code_attr logicprefix [(and \"and\") (ior \"or\") (xor \"xor\")])\n \n+;; Mapping of shift-right operators\n+(define_code_iterator any_shiftrt [lshiftrt ashiftrt])\n+\n+;; Base name for define_insn\n+(define_code_attr shiftrt_insn [(lshiftrt \"lshr\") (ashiftrt \"ashr\")])\n+\n+;; Base name for insn mnemonic.\n+(define_code_attr shiftrt [(lshiftrt \"shr\") (ashiftrt \"sar\")])\n+\n ;; Mapping of abs neg operators\n (define_code_iterator absneg [abs neg])\n \n@@ -9529,7 +9538,7 @@\n \t\t   (zero_extend:DI (xor:SI (match_dup 3) (const_int -1))))])]\n   \"\")\n \f\n-;; Arithmetic shift instructions\n+;; Shift instructions\n \n ;; DImode shifts are implemented using the i386 \"shift double\" opcode,\n ;; which is written as \"sh[lr]d[lw] imm,reg,reg/mem\".  If the shift count\n@@ -10207,25 +10216,25 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n-;; See comment above `ashldi3' about how this works.\n+;; See comment above `ashl<mode>3' about how this works.\n \n-(define_expand \"ashr<mode>3\"\n+(define_expand \"<shiftrt_insn><mode>3\"\n   [(set (match_operand:SDWIM 0 \"<shift_operand>\" \"\")\n-\t(ashiftrt:SDWIM (match_operand:SDWIM 1 \"<shift_operand>\" \"\")\n-\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+\t(any_shiftrt:SDWIM (match_operand:SDWIM 1 \"<shift_operand>\" \"\")\n+\t\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"ix86_expand_binary_operator (ASHIFTRT, <MODE>mode, operands); DONE;\")\n+  \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n-(define_insn_and_split \"*ashr<mode>3_doubleword\"\n+(define_insn_and_split \"*<shiftrt_insn><mode>3_doubleword\"\n   [(set (match_operand:DWI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:DWI (match_operand:DWI 1 \"register_operand\" \"0\")\n-\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"<S>c\")))\n+\t(any_shiftrt:DWI (match_operand:DWI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"nonmemory_operand\" \"<S>c\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n   \"#\"\n   \"(optimize && flag_peephole2) ? epilogue_completed : reload_completed\"\n   [(const_int 0)]\n-  \"ix86_split_ashr (operands, NULL_RTX, <MODE>mode); DONE;\"\n+  \"ix86_split_<shiftrt_insn> (operands, NULL_RTX, <MODE>mode); DONE;\"\n   [(set_attr \"type\" \"multi\")])\n \n ;; By default we don't ask for a scratch register, because when DWImode\n@@ -10235,14 +10244,14 @@\n (define_peephole2\n   [(match_scratch:DWIH 3 \"r\")\n    (parallel [(set (match_operand:<DWI> 0 \"register_operand\" \"\")\n-\t\t   (ashiftrt:<DWI>\n+\t\t   (any_shiftrt:<DWI>\n \t\t     (match_operand:<DWI> 1 \"register_operand\" \"\")\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_dup 3)]\n   \"TARGET_CMOVE\"\n   [(const_int 0)]\n-  \"ix86_split_ashr (operands, operands[3], <DWI>mode); DONE;\")\n+  \"ix86_split_<shiftrt_insn> (operands, operands[3], <DWI>mode); DONE;\")\n \n (define_insn \"x86_64_shrd\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"+r*m\")\n@@ -10354,234 +10363,20 @@\n   DONE;\n })\n \n-(define_insn \"*ashr<mode>3_1\"\n-  [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n-\t(ashiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n-\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"c<S>\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ASHIFTRT, <MODE>mode, operands)\"\n-{\n-  if (REG_P (operands[2]))\n-    return \"sar{<imodesuffix>}\\t{%b2, %0|%0, %b2}\";\n-  else if (operands[2] == const1_rtx\n-\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"sar{<imodesuffix>}\\t%0\";\n-  else\n-    return \"sar{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n-}\n-  [(set_attr \"type\" \"ishift\")\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (and (match_operand 2 \"const1_operand\" \"\")\n-\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t(const_int 0)))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*ashrsi3_1_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"cI\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-{\n-  if (REG_P (operands[2]))\n-    return \"sar{l}\\t{%b2, %k0|%k0, %b2}\";\n-  else if (operands[2] == const1_rtx\n-\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"sar{l}\\t%k0\";\n-  else\n-    return \"sar{l}\\t{%2, %k0|%k0, %2}\";\n-}\n-  [(set_attr \"type\" \"ishift\")\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (and (match_operand 2 \"const1_operand\" \"\")\n-\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t(const_int 0)))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrqi3_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(ashiftrt:QI (match_dup 0)\n-\t\t     (match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_REG_STALL\n-    || (operands[1] == const1_rtx\n-\t&& TARGET_SHIFT1))\"\n-{\n-  if (REG_P (operands[1]))\n-    return \"sar{b}\\t{%b1, %0|%0, %b1}\";\n-  else if (operands[1] == const1_rtx\n-\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"sar{b}\\t%0\";\n-  else\n-    return \"sar{b}\\t{%1, %0|%0, %1}\";\n-}\n-  [(set_attr \"type\" \"ishift1\")\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (and (match_operand 1 \"const1_operand\" \"\")\n-\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t(const_int 0)))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"QI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashr<mode>3_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n-\t\t\t(match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n-\t  (const_int 0)))\n-   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n-\t(ashiftrt:SWI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_FLAG_REG_STALL\n-    || (operands[2] == const1_rtx\n-\t&& TARGET_SHIFT1))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, <MODE>mode, operands)\"\n-{\n-  if (operands[2] == const1_rtx\n-      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"sar{<imodesuffix>}\\t%0\";\n-  else\n-    return \"sar{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n-}\n-  [(set_attr \"type\" \"ishift\")\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (and (match_operand 2 \"const1_operand\" \"\")\n-\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t(const_int 0)))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*ashrsi3_cmp_zext\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (ashiftrt:SI (match_dup 1) (match_dup 2))))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun)\n-       || !TARGET_PARTIAL_FLAG_REG_STALL\n-       || (operands[2] == const1_rtx\n-\t   && TARGET_SHIFT1))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-{\n-  if (operands[2] == const1_rtx\n-      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"sar{l}\\t%k0\";\n-  else\n-    return \"sar{l}\\t{%2, %k0|%k0, %2}\";\n-}\n-  [(set_attr \"type\" \"ishift\")\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (and (match_operand 2 \"const1_operand\" \"\")\n-\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t(const_int 0)))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashr<mode>3_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n-\t\t\t(match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:SWI 0 \"=<r>\"))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_FLAG_REG_STALL\n-    || (operands[2] == const1_rtx\n-\t&& TARGET_SHIFT1))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, <MODE>mode, operands)\"\n-{\n-  if (operands[2] == const1_rtx\n-      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"sar{<imodesuffix>}\\t%0\";\n-  else\n-    return \"sar{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n-}\n-  [(set_attr \"type\" \"ishift\")\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (and (match_operand 2 \"const1_operand\" \"\")\n-\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t(const_int 0)))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"<MODE>\")])\n-\f\n-;; Logical shift instructions\n-\n-;; See comment above `ashldi3' about how this works.\n-\n-(define_expand \"lshr<mode>3\"\n-  [(set (match_operand:SDWIM 0 \"<shift_operand>\" \"\")\n-\t(lshiftrt:SDWIM (match_operand:SDWIM 1 \"<shift_operand>\" \"\")\n-\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (LSHIFTRT, <MODE>mode, operands); DONE;\")\n-\n-(define_insn_and_split \"*lshr<mode>3_doubleword\"\n-  [(set (match_operand:DWI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:DWI (match_operand:DWI 1 \"register_operand\" \"0\")\n-\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"<S>c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"#\"\n-  \"(optimize && flag_peephole2) ? epilogue_completed : reload_completed\"\n-  [(const_int 0)]\n-  \"ix86_split_lshr (operands, NULL_RTX, <MODE>mode); DONE;\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-;; By default we don't ask for a scratch register, because when DWImode\n-;; values are manipulated, registers are already at a premium.  But if\n-;; we have one handy, we won't turn it away.\n-\n-(define_peephole2\n-  [(match_scratch:DWIH 3 \"r\")\n-   (parallel [(set (match_operand:<DWI> 0 \"register_operand\" \"\")\n-\t\t   (lshiftrt:<DWI>\n-\t\t     (match_operand:<DWI> 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (match_dup 3)]\n-  \"TARGET_CMOVE\"\n-  [(const_int 0)]\n-  \"ix86_split_lshr (operands, operands[3], <DWI>mode); DONE;\")\n-\n-(define_insn \"*lshr<mode>3_1\"\n+(define_insn \"*<shiftrt_insn><mode>3_1\"\n   [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n-\t(lshiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n-\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"c<S>\")))\n+\t(any_shiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"nonmemory_operand\" \"c<S>\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (LSHIFTRT, <MODE>mode, operands)\"\n+  \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n   if (REG_P (operands[2]))\n-    return \"shr{<imodesuffix>}\\t{%b2, %0|%0, %b2}\";\n+    return \"<shiftrt>{<imodesuffix>}\\t{%b2, %0|%0, %b2}\";\n   else if (operands[2] == const1_rtx\n \t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"shr{<imodesuffix>}\\t%0\";\n+    return \"<shiftrt>{<imodesuffix>}\\t%0\";\n   else\n-    return \"shr{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+    return \"<shiftrt>{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n }\n   [(set_attr \"type\" \"ishift\")\n    (set (attr \"length_immediate\")\n@@ -10593,21 +10388,21 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*lshrsi3_1_zext\"\n+(define_insn \"*<shiftrt_insn>si3_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t  (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"cI\"))))\n+\t  (any_shiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"cI\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (LSHIFTRT, SImode, operands)\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n {\n   if (REG_P (operands[2]))\n-    return \"shr{l}\\t{%b2, %k0|%k0, %b2}\";\n+    return \"<shiftrt>{l}\\t{%b2, %k0|%k0, %b2}\";\n   else if (operands[2] == const1_rtx\n \t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"shr{l}\\t%k0\";\n+    return \"<shiftrt>{l}\\t%k0\";\n   else\n-    return \"shr{l}\\t{%2, %k0|%k0, %2}\";\n+    return \"<shiftrt>{l}\\t{%2, %k0|%k0, %2}\";\n }\n   [(set_attr \"type\" \"ishift\")\n    (set (attr \"length_immediate\")\n@@ -10619,23 +10414,23 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*lshrqi3_1_slp\"\n+(define_insn \"*<shiftrt_insn>qi3_1_slp\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(lshiftrt:QI (match_dup 0)\n-\t\t     (match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n+\t(any_shiftrt:QI (match_dup 0)\n+\t\t\t(match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(optimize_function_for_size_p (cfun)\n     || !TARGET_PARTIAL_REG_STALL\n     || (operands[1] == const1_rtx\n \t&& TARGET_SHIFT1))\"\n {\n   if (REG_P (operands[1]))\n-    return \"shr{b}\\t{%b1, %0|%0, %b1}\";\n+    return \"<shiftrt>{b}\\t{%b1, %0|%0, %b1}\";\n   else if (operands[1] == const1_rtx\n \t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"shr{b}\\t%0\";\n+    return \"<shiftrt>{b}\\t%0\";\n   else\n-    return \"shr{b}\\t{%1, %0|%0, %1}\";\n+    return \"<shiftrt>{b}\\t{%1, %0|%0, %1}\";\n }\n   [(set_attr \"type\" \"ishift1\")\n    (set (attr \"length_immediate\")\n@@ -10650,26 +10445,27 @@\n ;; This pattern can't accept a variable shift count, since shifts by\n ;; zero don't affect the flags.  We assume that shifts by constant\n ;; zero are optimized away.\n-(define_insn \"*lshr<mode>3_cmp\"\n+(define_insn \"*<shiftrt_insn><mode>3_cmp\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (lshiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n-\t\t\t(match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n+\t  (any_shiftrt:SWI\n+\t    (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t    (match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n \t  (const_int 0)))\n    (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n-\t(lshiftrt:SWI (match_dup 1) (match_dup 2)))]\n+\t(any_shiftrt:SWI (match_dup 1) (match_dup 2)))]\n   \"(optimize_function_for_size_p (cfun)\n     || !TARGET_PARTIAL_FLAG_REG_STALL\n     || (operands[2] == const1_rtx\n \t&& TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, <MODE>mode, operands)\"\n+   && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n   if (operands[2] == const1_rtx\n       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"shr{<imodesuffix>}\\t%0\";\n+    return \"<shiftrt>{<imodesuffix>}\\t%0\";\n   else\n-    return \"shr{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+    return \"<shiftrt>{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n }\n   [(set_attr \"type\" \"ishift\")\n    (set (attr \"length_immediate\")\n@@ -10681,27 +10477,27 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*lshrsi3_cmp_zext\"\n+(define_insn \"*<shiftrt_insn>si3_cmp_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n+\t  (any_shiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t  (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n \t  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (lshiftrt:SI (match_dup 1) (match_dup 2))))]\n+\t(zero_extend:DI (any_shiftrt:SI (match_dup 1) (match_dup 2))))]\n   \"TARGET_64BIT\n    && (optimize_function_for_size_p (cfun)\n        || !TARGET_PARTIAL_FLAG_REG_STALL\n        || (operands[2] == const1_rtx\n \t   && TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, SImode, operands)\"\n+   && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n {\n   if (operands[2] == const1_rtx\n       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"shr{l}\\t%k0\";\n+    return \"<shiftrt>{l}\\t%k0\";\n   else\n-    return \"shr{l}\\t{%2, %k0|%k0, %2}\";\n+    return \"<shiftrt>{l}\\t{%2, %k0|%k0, %2}\";\n }\n   [(set_attr \"type\" \"ishift\")\n    (set (attr \"length_immediate\")\n@@ -10713,25 +10509,26 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*lshr<mode>3_cconly\"\n+(define_insn \"*<shiftrt_insn><mode>3_cconly\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (lshiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n-\t\t\t(match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n+\t  (any_shiftrt:SWI\n+\t    (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t    (match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n \t  (const_int 0)))\n    (clobber (match_scratch:SWI 0 \"=<r>\"))]\n   \"(optimize_function_for_size_p (cfun)\n     || !TARGET_PARTIAL_FLAG_REG_STALL\n     || (operands[2] == const1_rtx\n \t&& TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (LSHIFTRT, <MODE>mode, operands)\"\n+   && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n   if (operands[2] == const1_rtx\n       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-    return \"shr{<imodesuffix>}\\t%0\";\n+    return \"<shiftrt>{<imodesuffix>}\\t%0\";\n   else\n-    return \"shr{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+    return \"<shiftrt>{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n }\n   [(set_attr \"type\" \"ishift\")\n    (set (attr \"length_immediate\")"}]}