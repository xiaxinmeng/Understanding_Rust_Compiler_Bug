{"sha": "aa6b6385f2b1aa288907cc7adbd0b5b839707a94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE2YjYzODVmMmIxYWEyODg5MDdjYzdhZGJkMGI1YjgzOTcwN2E5NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-26T12:40:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-26T12:40:08Z"}, "message": "(do_include, read_name_map): Omit leading \"./\" and trailing \"/\" when it makes sense.\n\n(do_include, read_name_map): Omit leading \"./\" and trailing \"/\" when\nit makes sense.\n(skip_redundant_dir_prefix): New function.\n\nFrom-SVN: r10163", "tree": {"sha": "e7ec26497c0de9ed78d5a1c1f3d277ae04c5fd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7ec26497c0de9ed78d5a1c1f3d277ae04c5fd8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa6b6385f2b1aa288907cc7adbd0b5b839707a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6b6385f2b1aa288907cc7adbd0b5b839707a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6b6385f2b1aa288907cc7adbd0b5b839707a94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6b6385f2b1aa288907cc7adbd0b5b839707a94/comments", "author": null, "committer": null, "parents": [{"sha": "dfda5a87b5432c74b6f5dde252a0d07c81314332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfda5a87b5432c74b6f5dde252a0d07c81314332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfda5a87b5432c74b6f5dde252a0d07c81314332"}], "stats": {"total": 47, "additions": 34, "deletions": 13}, "files": [{"sha": "ee726e591c22a8e08bcca9f477dfb79667b5eefa", "filename": "gcc/cccp.c", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6b6385f2b1aa288907cc7adbd0b5b839707a94/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6b6385f2b1aa288907cc7adbd0b5b839707a94/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=aa6b6385f2b1aa288907cc7adbd0b5b839707a94", "patch": "@@ -1082,7 +1082,8 @@ static struct tm *timestamp PROTO((void));\n static void special_symbol PROTO((HASHNODE *, FILE_BUF *));\n \n static int redundant_include_p PROTO((char *));\n-static is_system_include PROTO((char *));\n+static int is_system_include PROTO((char *));\n+static char *skip_redundant_dir_prefix PROTO((char *));\n \n static char *read_filename_string PROTO((int, FILE *));\n static struct file_name_map *read_name_map PROTO((char *));\n@@ -4260,7 +4261,7 @@ do_include (buf, limit, op, keyword)\n   struct file_name_list *search_start = include; /* Chain of dirs to search */\n   struct file_name_list dsp[1];\t/* First in chain, if #include \"...\" */\n   struct file_name_list *searchptr = 0;\n-  int flen;\n+  size_t flen;\n \n   int f;\t\t\t/* file number */\n \n@@ -4500,9 +4501,9 @@ do_include (buf, limit, op, keyword)\n \t   a standard piece of the list.  */\n \tif (searchptr->fname[0] == 0)\n \t  continue;\n-\tstrcpy (fname, searchptr->fname);\n-\tstrcat (fname, \"/\");\n-\tfname[strlen (fname) + flen] = 0;\n+\tstrcpy (fname, skip_redundant_dir_prefix (searchptr->fname));\n+\tif (fname[0] && fname[strlen (fname) - 1] != '/')\n+\t  strcat (fname, \"/\");\n       } else {\n \tfname[0] = 0;\n       }\n@@ -4569,8 +4570,9 @@ do_include (buf, limit, op, keyword)\n \t\t      continue;\n \t\t    p = (char *) alloca (strlen (searchptr->fname)\n \t\t\t\t\t + strlen (fname) + 2);\n-\t\t    strcpy (p, searchptr->fname);\n-\t\t    strcat (p, \"/\");\n+\t\t    strcpy (p, skip_redundant_dir_prefix (searchptr->fname));\n+\t\t    if (p[0] && p[strlen (p) - 1] != '/')\n+\t\t      strcat (p, \"/\");\n \t\t    strcat (p, fname);\n \t\t    deps_output (p, ' ');\n \t\t    break;\n@@ -4749,6 +4751,21 @@ is_system_include (filename)\n   return 0;\n }\n \f\n+/* Skip leading \"./\" from a directory name.\n+   This may yield the empty string, which represents the current directory.  */\n+\n+static char *\n+skip_redundant_dir_prefix (dir)\n+     char *dir;\n+{\n+  while (dir[0] == '.' && dir[1] == '/')\n+    for (dir += 2; *dir == '/'; dir++)\n+      continue;\n+  if (dir[0] == '.' && !dir[1])\n+    dir++;\n+  return dir;\n+}\n+\f\n /* The file_name_map structure holds a mapping of file names for a\n    particular directory.  This mapping is read from the file named\n    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n@@ -4816,6 +4833,10 @@ read_name_map (dirname)\n   register struct file_name_map_list *map_list_ptr;\n   char *name;\n   FILE *f;\n+  size_t dirlen;\n+  int separator_needed;\n+\n+  dirname = skip_redundant_dir_prefix (dirname);\n \n   for (map_list_ptr = map_list; map_list_ptr;\n        map_list_ptr = map_list_ptr->map_list_next)\n@@ -4827,18 +4848,18 @@ read_name_map (dirname)\n   map_list_ptr->map_list_name = savestring (dirname);\n   map_list_ptr->map_list_map = NULL;\n \n-  name = (char *) alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n+  dirlen = strlen (dirname);\n+  separator_needed = dirlen != 0 && dirname[dirlen - 1] != '/';\n+  name = (char *) alloca (dirlen + strlen (FILE_NAME_MAP_FILE) + 2);\n   strcpy (name, dirname);\n-  if (*dirname)\n-    strcat (name, \"/\");\n-  strcat (name, FILE_NAME_MAP_FILE);\n+  name[dirlen] = '/';\n+  strcpy (name + dirlen + separator_needed, FILE_NAME_MAP_FILE);\n   f = fopen (name, \"r\");\n   if (!f)\n     map_list_ptr->map_list_map = NULL;\n   else\n     {\n       int ch;\n-      int dirlen = strlen (dirname);\n \n       while ((ch = getc (f)) != EOF)\n \t{\n@@ -4864,7 +4885,7 @@ read_name_map (dirname)\n \t      ptr->map_to = xmalloc (dirlen + strlen (to) + 2);\n \t      strcpy (ptr->map_to, dirname);\n \t      ptr->map_to[dirlen] = '/';\n-\t      strcpy (ptr->map_to + dirlen + 1, to);\n+\t      strcpy (ptr->map_to + dirlen + separator_needed, to);\n \t      free (to);\n \t    }\t      \n "}]}