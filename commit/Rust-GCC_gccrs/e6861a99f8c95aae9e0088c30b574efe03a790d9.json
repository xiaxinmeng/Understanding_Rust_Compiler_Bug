{"sha": "e6861a99f8c95aae9e0088c30b574efe03a790d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY4NjFhOTlmOGM5NWFhZTllMDA4OGMzMGI1NzRlZmUwM2E3OTBkOQ==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2016-02-25T12:23:52Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2016-02-25T12:23:52Z"}, "message": "re PR driver/68463 (Offloading fails when some objects are compiled with LTO and some without)\n\ngcc/\n\tPR driver/68463\n\t* config/gnu-user.h (CRTOFFLOADBEGIN): Define.  Add crtoffloadbegin.o if\n\toffloading is enabled and -fopenacc or -fopenmp is specified.\n\t(CRTOFFLOADEND): Likewise.\n\t(GNU_USER_TARGET_STARTFILE_SPEC): Add CRTOFFLOADBEGIN.\n\t(GNU_USER_TARGET_ENDFILE_SPEC): Add CRTOFFLOADEND.\n\t* lto-wrapper.c (offloadbegin, offloadend): Remove static vars.\n\t(offload_objects_file_name): New static var.\n\t(tool_cleanup): Remove offload_objects_file_name file.\n\t(find_offloadbeginend): Replace with ...\n\t(find_crtoffloadtable): ... this.\n\t(run_gcc): Remove offload_argc and offload_argv.\n\tGet offload_objects_file_name from -foffload-objects=... option.\n\tRead names of object files with offload from this file, pass them to\n\tcompile_images_for_offload_targets.  Don't call find_offloadbeginend and\n\tdon't pass offloadbegin and offloadend to the linker.  Don't pass\n\toffload non-LTO files to the linker, because now they're not claimed.\nlibgcc/\n\tPR driver/68463\n\t* Makefile.in (crtoffloadtable$(objext)): New rule.\n\t* configure.ac (extra_parts): Add crtoffloadtable$(objext) if\n\tenable_offload_targets is not empty.\n\t* configure: Regenerate.\n\t* offloadstuff.c: Move __OFFLOAD_TABLE__ from crtoffloadend to\n\tcrtoffloadtable.\nlibgomp/\n\tPR driver/68463\n\t* testsuite/libgomp.oacc-c-c++-common/parallel-dims-2.c: Remove.\nlto-plugin/\n\tPR driver/68463\n\t* lto-plugin.c (struct plugin_offload_file): New.\n\t(offload_files): Change type.\n\t(offload_files_last, offload_files_last_obj): New.\n\t(offload_files_last_lto): New.\n\t(free_2): Adjust accordingly.\n\t(all_symbols_read_handler): Don't add offload files to lto_arg_ptr.\n\tDon't call free_1 for offload_files.  Write names of object files with\n\toffloading to the temporary file.  Add new option to lto_arg_ptr.\n\t(claim_file_handler): Don't claim file if it contains offload sections\n\twithout LTO sections.  If it contains offload sections, add to the list.\n\nFrom-SVN: r233712", "tree": {"sha": "f080211fbe21bc4592195a286afa017b06b0bbba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f080211fbe21bc4592195a286afa017b06b0bbba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6861a99f8c95aae9e0088c30b574efe03a790d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6861a99f8c95aae9e0088c30b574efe03a790d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6861a99f8c95aae9e0088c30b574efe03a790d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6861a99f8c95aae9e0088c30b574efe03a790d9/comments", "author": null, "committer": null, "parents": [{"sha": "cf1fcb76fb5e8064316ef40d3c563c8d8e3fdc36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf1fcb76fb5e8064316ef40d3c563c8d8e3fdc36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf1fcb76fb5e8064316ef40d3c563c8d8e3fdc36"}], "stats": {"total": 418, "additions": 299, "deletions": 119}, "files": [{"sha": "21d304d1cc02e54af429492c51a8f8f3b61efa94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -1,3 +1,23 @@\n+2016-02-25  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\tPR driver/68463\n+\t* config/gnu-user.h (CRTOFFLOADBEGIN): Define.  Add crtoffloadbegin.o if\n+\toffloading is enabled and -fopenacc or -fopenmp is specified.\n+\t(CRTOFFLOADEND): Likewise.\n+\t(GNU_USER_TARGET_STARTFILE_SPEC): Add CRTOFFLOADBEGIN.\n+\t(GNU_USER_TARGET_ENDFILE_SPEC): Add CRTOFFLOADEND.\n+\t* lto-wrapper.c (offloadbegin, offloadend): Remove static vars.\n+\t(offload_objects_file_name): New static var.\n+\t(tool_cleanup): Remove offload_objects_file_name file.\n+\t(find_offloadbeginend): Replace with ...\n+\t(find_crtoffloadtable): ... this.\n+\t(run_gcc): Remove offload_argc and offload_argv.\n+\tGet offload_objects_file_name from -foffload-objects=... option.\n+\tRead names of object files with offload from this file, pass them to\n+\tcompile_images_for_offload_targets.  Don't call find_offloadbeginend and\n+\tdon't pass offloadbegin and offloadend to the linker.  Don't pass\n+\toffload non-LTO files to the linker, because now they're not claimed.\n+\n 2016-02-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/69630"}, {"sha": "b0bf40a954f22698d04bb1d07e6972efba603b39", "filename": "gcc/config/gnu-user.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/gcc%2Fconfig%2Fgnu-user.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/gcc%2Fconfig%2Fgnu-user.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgnu-user.h?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -35,6 +35,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #undef ASM_APP_OFF\n #define ASM_APP_OFF \"#NO_APP\\n\"\n \n+#if ENABLE_OFFLOADING == 1\n+#define CRTOFFLOADBEGIN \"%{fopenacc|fopenmp:crtoffloadbegin%O%s}\"\n+#define CRTOFFLOADEND \"%{fopenacc|fopenmp:crtoffloadend%O%s}\"\n+#else\n+#define CRTOFFLOADBEGIN \"\"\n+#define CRTOFFLOADEND \"\"\n+#endif\n+\n /* Provide a STARTFILE_SPEC appropriate for GNU userspace.  Here we add\n    the GNU userspace magical crtbegin.o file (see crtstuff.c) which\n    provides part of the support for getting C++ file-scope static\n@@ -49,14 +57,16 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \t      %{\" NO_PIE_SPEC \":crtbegin.o%s}} \\\n    %{fvtable-verify=none:%s; \\\n      fvtable-verify=preinit:vtv_start_preinit.o%s; \\\n-     fvtable-verify=std:vtv_start.o%s}\"\n+     fvtable-verify=std:vtv_start.o%s} \\\n+   \" CRTOFFLOADBEGIN\n #else\n #define GNU_USER_TARGET_STARTFILE_SPEC \\\n   \"%{!shared: %{pg|p|profile:gcrt1.o%s;:crt1.o%s}} \\\n    crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s} \\\n    %{fvtable-verify=none:%s; \\\n      fvtable-verify=preinit:vtv_start_preinit.o%s; \\\n-     fvtable-verify=std:vtv_start.o%s}\"\n+     fvtable-verify=std:vtv_start.o%s} \\\n+   \" CRTOFFLOADBEGIN\n #endif\n #undef  STARTFILE_SPEC\n #define STARTFILE_SPEC GNU_USER_TARGET_STARTFILE_SPEC\n@@ -73,13 +83,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n      fvtable-verify=preinit:vtv_end_preinit.o%s; \\\n      fvtable-verify=std:vtv_end.o%s} \\\n    %{shared:crtendS.o%s;: %{\" PIE_SPEC \":crtendS.o%s} \\\n-   %{\" NO_PIE_SPEC \":crtend.o%s}} crtn.o%s\"\n+   %{\" NO_PIE_SPEC \":crtend.o%s}} crtn.o%s \\\n+   \" CRTOFFLOADEND\n #else\n #define GNU_USER_TARGET_ENDFILE_SPEC \\\n   \"%{fvtable-verify=none:%s; \\\n      fvtable-verify=preinit:vtv_end_preinit.o%s; \\\n      fvtable-verify=std:vtv_end.o%s} \\\n-   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s\"\n+   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s \\\n+   \" CRTOFFLOADEND\n #endif\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC GNU_USER_TARGET_ENDFILE_SPEC"}, {"sha": "f240812f9520b4d927f313ded7a4fa98738b4db7", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 105, "deletions": 61, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -68,7 +68,7 @@ static unsigned int nr;\n static char **input_names;\n static char **output_names;\n static char **offload_names;\n-static const char *offloadbegin, *offloadend;\n+static char *offload_objects_file_name;\n static char *makefile;\n \n const char tool_name[] = \"lto-wrapper\";\n@@ -84,6 +84,8 @@ tool_cleanup (bool)\n     maybe_unlink (ltrans_output_file);\n   if (flto_out)\n     maybe_unlink (flto_out);\n+  if (offload_objects_file_name)\n+    maybe_unlink (offload_objects_file_name);\n   if (makefile)\n     maybe_unlink (makefile);\n   for (i = 0; i < nr; ++i)\n@@ -840,40 +842,32 @@ copy_file (const char *dest, const char *src)\n     }\n }\n \n-/* Find the crtoffloadbegin.o and crtoffloadend.o files in LIBRARY_PATH, make\n-   copies and store the names of the copies in offloadbegin and offloadend.  */\n+/* Find the crtoffloadtable.o file in LIBRARY_PATH, make copy and pass name of\n+   the copy to the linker.  */\n \n static void\n-find_offloadbeginend (void)\n+find_crtoffloadtable (void)\n {\n   char **paths = NULL;\n   const char *library_path = getenv (\"LIBRARY_PATH\");\n   if (!library_path)\n     return;\n-  unsigned n_paths = parse_env_var (library_path, &paths, \"/crtoffloadbegin.o\");\n+  unsigned n_paths = parse_env_var (library_path, &paths, \"/crtoffloadtable.o\");\n \n   unsigned i;\n   for (i = 0; i < n_paths; i++)\n     if (access_check (paths[i], R_OK) == 0)\n       {\n-\tsize_t len = strlen (paths[i]);\n-\tchar *tmp = xstrdup (paths[i]);\n-\tstrcpy (paths[i] + len - strlen (\"begin.o\"), \"end.o\");\n-\tif (access_check (paths[i], R_OK) != 0)\n-\t  fatal_error (input_location,\n-\t\t       \"installation error, can't find crtoffloadend.o\");\n-\t/* The linker will delete the filenames we give it, so make\n-\t   copies.  */\n-\toffloadbegin = make_temp_file (\".o\");\n-\toffloadend = make_temp_file (\".o\");\n-\tcopy_file (offloadbegin, tmp);\n-\tcopy_file (offloadend, paths[i]);\n-\tfree (tmp);\n+\t/* The linker will delete the filename we give it, so make a copy.  */\n+\tchar *crtoffloadtable = make_temp_file (\".crtoffloadtable.o\");\n+\tcopy_file (crtoffloadtable, paths[i]);\n+\tprintf (\"%s\\n\", crtoffloadtable);\n+\tXDELETEVEC (crtoffloadtable);\n \tbreak;\n       }\n   if (i == n_paths)\n     fatal_error (input_location,\n-\t\t \"installation error, can't find crtoffloadbegin.o\");\n+\t\t \"installation error, can't find crtoffloadtable.o\");\n \n   free_array_of_ptrs ((void **) paths, n_paths);\n }\n@@ -970,8 +964,8 @@ run_gcc (unsigned argc, char *argv[])\n   int new_head_argc;\n   bool have_lto = false;\n   bool have_offload = false;\n-  unsigned lto_argc = 0, offload_argc = 0;\n-  char **lto_argv, **offload_argv;\n+  unsigned lto_argc = 0;\n+  char **lto_argv;\n \n   /* Get the driver and options.  */\n   collect_gcc = getenv (\"COLLECT_GCC\");\n@@ -987,10 +981,9 @@ run_gcc (unsigned argc, char *argv[])\n \t\t\t\t\t&decoded_options,\n \t\t\t\t\t&decoded_options_count);\n \n-  /* Allocate arrays for input object files with LTO or offload IL,\n+  /* Allocate array for input object files with LTO IL,\n      and for possible preceding arguments.  */\n   lto_argv = XNEWVEC (char *, argc);\n-  offload_argv = XNEWVEC (char *, argc);\n \n   /* Look at saved options in the IL files.  */\n   for (i = 1; i < argc; ++i)\n@@ -1002,6 +995,15 @@ run_gcc (unsigned argc, char *argv[])\n       int consumed;\n       char *filename = argv[i];\n \n+      if (strncmp (argv[i], \"-foffload-objects=\",\n+\t\t   sizeof (\"-foffload-objects=\") - 1) == 0)\n+\t{\n+\t  have_offload = true;\n+\t  offload_objects_file_name\n+\t    = argv[i] + sizeof (\"-foffload-objects=\") - 1;\n+\t  continue;\n+\t}\n+\n       if ((p = strrchr (argv[i], '@'))\n \t  && p != argv[i] \n \t  && sscanf (p, \"@%li%n\", &loffset, &consumed) >= 1\n@@ -1026,15 +1028,6 @@ run_gcc (unsigned argc, char *argv[])\n \t  have_lto = true;\n \t  lto_argv[lto_argc++] = argv[i];\n \t}\n-\n-      if (find_and_merge_options (fd, file_offset, OFFLOAD_SECTION_NAME_PREFIX,\n-\t\t\t\t  &offload_fdecoded_options,\n-\t\t\t\t  &offload_fdecoded_options_count, collect_gcc))\n-\t{\n-\t  have_offload = true;\n-\t  offload_argv[offload_argc++] = argv[i];\n-\t}\n-\n       close (fd);\n     }\n \n@@ -1133,47 +1126,102 @@ run_gcc (unsigned argc, char *argv[])\n \n   if (have_offload)\n     {\n-      compile_images_for_offload_targets (offload_argc, offload_argv,\n+      unsigned i, num_offload_files;\n+      char **offload_argv;\n+      FILE *f;\n+\n+      f = fopen (offload_objects_file_name, \"r\");\n+      if (f == NULL)\n+\tfatal_error (input_location, \"cannot open %s: %m\",\n+\t\t     offload_objects_file_name);\n+      if (fscanf (f, \"%u \", &num_offload_files) != 1)\n+\tfatal_error (input_location, \"cannot read %s: %m\",\n+\t\t     offload_objects_file_name);\n+      offload_argv = XCNEWVEC (char *, num_offload_files);\n+\n+      /* Read names of object files with offload.  */\n+      for (i = 0; i < num_offload_files; i++)\n+\t{\n+\t  const unsigned piece = 32;\n+\t  char *buf, *filename = XNEWVEC (char, piece);\n+\t  size_t len;\n+\n+\t  buf = filename;\n+cont1:\n+\t  if (!fgets (buf, piece, f))\n+\t    break;\n+\t  len = strlen (filename);\n+\t  if (filename[len - 1] != '\\n')\n+\t    {\n+\t      filename = XRESIZEVEC (char, filename, len + piece);\n+\t      buf = filename + len;\n+\t      goto cont1;\n+\t    }\n+\t  filename[len - 1] = '\\0';\n+\t  offload_argv[i] = filename;\n+\t}\n+      fclose (f);\n+      if (offload_argv[num_offload_files - 1] == NULL)\n+\tfatal_error (input_location, \"invalid format of %s\",\n+\t\t     offload_objects_file_name);\n+      maybe_unlink (offload_objects_file_name);\n+      offload_objects_file_name = NULL;\n+\n+      /* Look at saved offload options in files.  */\n+      for (i = 0; i < num_offload_files; i++)\n+\t{\n+\t  char *p;\n+\t  long loffset;\n+\t  int fd, consumed;\n+\t  off_t file_offset = 0;\n+\t  char *filename = offload_argv[i];\n+\n+\t  if ((p = strrchr (offload_argv[i], '@'))\n+\t      && p != offload_argv[i]\n+\t      && sscanf (p, \"@%li%n\", &loffset, &consumed) >= 1\n+\t      && strlen (p) == (unsigned int) consumed)\n+\t    {\n+\t      filename = XNEWVEC (char, p - offload_argv[i] + 1);\n+\t      memcpy (filename, offload_argv[i], p - offload_argv[i]);\n+\t      filename[p - offload_argv[i]] = '\\0';\n+\t      file_offset = (off_t) loffset;\n+\t    }\n+\t  fd = open (filename, O_RDONLY | O_BINARY);\n+\t  if (fd == -1)\n+\t    fatal_error (input_location, \"cannot open %s: %m\", filename);\n+\t  if (!find_and_merge_options (fd, file_offset,\n+\t\t\t\t       OFFLOAD_SECTION_NAME_PREFIX,\n+\t\t\t\t       &offload_fdecoded_options,\n+\t\t\t\t       &offload_fdecoded_options_count,\n+\t\t\t\t       collect_gcc))\n+\t    fatal_error (input_location, \"cannot read %s: %m\", filename);\n+\t  close (fd);\n+\t  if (filename != offload_argv[i])\n+\t    XDELETEVEC (filename);\n+\t}\n+\n+      compile_images_for_offload_targets (num_offload_files, offload_argv,\n \t\t\t\t\t  offload_fdecoded_options,\n \t\t\t\t\t  offload_fdecoded_options_count,\n \t\t\t\t\t  decoded_options,\n \t\t\t\t\t  decoded_options_count);\n+\n+      free_array_of_ptrs ((void **) offload_argv, num_offload_files);\n+\n       if (offload_names)\n \t{\n-\t  find_offloadbeginend ();\n+\t  find_crtoffloadtable ();\n \t  for (i = 0; offload_names[i]; i++)\n \t    printf (\"%s\\n\", offload_names[i]);\n \t  free_array_of_ptrs ((void **) offload_names, i);\n \t}\n     }\n \n-  if (offloadbegin)\n-    printf (\"%s\\n\", offloadbegin);\n-\n   /* If object files contain offload sections, but do not contain LTO sections,\n      then there is no need to perform a link-time recompilation, i.e.\n      lto-wrapper is used only for a compilation of offload images.  */\n   if (have_offload && !have_lto)\n-    {\n-      for (i = 1; i < argc; ++i)\n-\tif (strncmp (argv[i], \"-fresolution=\",\n-\t\t     sizeof (\"-fresolution=\") - 1) != 0\n-\t    && strncmp (argv[i], \"-flinker-output=\",\n-\t\t\tsizeof (\"-flinker-output=\") - 1) != 0)\n-\t  {\n-\t    char *out_file;\n-\t    /* Can be \".o\" or \".so\".  */\n-\t    char *ext = strrchr (argv[i], '.');\n-\t    if (ext == NULL)\n-\t      out_file = make_temp_file (\"\");\n-\t    else\n-\t      out_file = make_temp_file (ext);\n-\t    /* The linker will delete the files we give it, so make copies.  */\n-\t    copy_file (out_file, argv[i]);\n-\t    printf (\"%s\\n\", out_file);\n-\t  }\n-      goto finish;\n-    }\n+    goto finish;\n \n   if (lto_mode == LTO_MODE_LTO)\n     {\n@@ -1402,11 +1450,7 @@ run_gcc (unsigned argc, char *argv[])\n     }\n \n  finish:\n-  if (offloadend)\n-    printf (\"%s\\n\", offloadend);\n-\n   XDELETE (lto_argv);\n-  XDELETE (offload_argv);\n   obstack_free (&argv_obstack, NULL);\n }\n "}, {"sha": "36d10b0450faf6da735ed982f87dc6d09439ad43", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -1,3 +1,13 @@\n+2016-02-25  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\tPR driver/68463\n+\t* Makefile.in (crtoffloadtable$(objext)): New rule.\n+\t* configure.ac (extra_parts): Add crtoffloadtable$(objext) if\n+\tenable_offload_targets is not empty.\n+\t* configure: Regenerate.\n+\t* offloadstuff.c: Move __OFFLOAD_TABLE__ from crtoffloadend to\n+\tcrtoffloadtable.\n+\n 2016-02-17  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* config/xtensa/ieee754-df.S (__muldf3_aux, __divdf3_aux): Add"}, {"sha": "f09b39b0e85fdd0aa61b147238dd4b584b3d2f6a", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -995,12 +995,16 @@ crtbeginT$(objext): $(srcdir)/crtstuff.c\n \t$(crt_compile) $(CRTSTUFF_T_CFLAGS) -c $< -DCRT_BEGIN -DCRTSTUFFT_O\n \n # crtoffloadbegin and crtoffloadend contain symbols, that mark the begin and\n-# the end of tables with addresses, required for offloading.\n+# the end of tables with addresses, required for offloading.  crtoffloadtable\n+# contains the array with addresses of those symbols.\n crtoffloadbegin$(objext): $(srcdir)/offloadstuff.c\n \t$(crt_compile) $(CRTSTUFF_T_CFLAGS) -c $< -DCRT_BEGIN\n \n crtoffloadend$(objext): $(srcdir)/offloadstuff.c\n \t$(crt_compile) $(CRTSTUFF_T_CFLAGS) -c $< -DCRT_END\n+\n+crtoffloadtable$(objext): $(srcdir)/offloadstuff.c\n+\t$(crt_compile) $(CRTSTUFF_T_CFLAGS) -c $< -DCRT_TABLE\n endif\n \n ifeq ($(enable_vtable_verify),yes)"}, {"sha": "f3f360512c46589973a6fdfbd68feb5658d85063", "filename": "libgcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -4835,7 +4835,7 @@ fi\n \n \n if test x\"$enable_offload_targets\" != x; then\n-  extra_parts=\"${extra_parts} crtoffloadbegin.o crtoffloadend.o\"\n+  extra_parts=\"${extra_parts} crtoffloadbegin.o crtoffloadend.o crtoffloadtable.o\"\n fi\n \n # Check if Solaris/x86 linker supports ZERO terminator unwind entries."}, {"sha": "897259e62bc304cb02193f75f7ef1b05a9a5d520", "filename": "libgcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure.ac?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -418,7 +418,7 @@ AC_SUBST(accel_dir_suffix)\n AC_SUBST(real_host_noncanonical)\n \n if test x\"$enable_offload_targets\" != x; then\n-  extra_parts=\"${extra_parts} crtoffloadbegin.o crtoffloadend.o\"\n+  extra_parts=\"${extra_parts} crtoffloadbegin.o crtoffloadend.o crtoffloadtable.o\"\n fi\n \n # Check if Solaris/x86 linker supports ZERO terminator unwind entries."}, {"sha": "4ab639721cbedb90062cd805419c2523045785ef", "filename": "libgcc/offloadstuff.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2Foffloadstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgcc%2Foffloadstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Foffloadstuff.c?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -40,41 +40,45 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"tm.h\"\n #include \"libgcc_tm.h\"\n \n+#if defined(HAVE_GAS_HIDDEN) && ENABLE_OFFLOADING == 1\n+\n #define OFFLOAD_FUNC_TABLE_SECTION_NAME \".gnu.offload_funcs\"\n #define OFFLOAD_VAR_TABLE_SECTION_NAME \".gnu.offload_vars\"\n \n #ifdef CRT_BEGIN\n \n-#if defined(HAVE_GAS_HIDDEN) && defined(ENABLE_OFFLOADING)\n const void *const __offload_func_table[0]\n   __attribute__ ((__used__, visibility (\"hidden\"),\n \t\t  section (OFFLOAD_FUNC_TABLE_SECTION_NAME))) = { };\n const void *const __offload_var_table[0]\n   __attribute__ ((__used__, visibility (\"hidden\"),\n \t\t  section (OFFLOAD_VAR_TABLE_SECTION_NAME))) = { };\n-#endif\n \n #elif defined CRT_END\n \n-#if defined(HAVE_GAS_HIDDEN) && defined(ENABLE_OFFLOADING)\n const void *const __offload_funcs_end[0]\n   __attribute__ ((__used__, visibility (\"hidden\"),\n \t\t  section (OFFLOAD_FUNC_TABLE_SECTION_NAME))) = { };\n const void *const __offload_vars_end[0]\n   __attribute__ ((__used__, visibility (\"hidden\"),\n \t\t  section (OFFLOAD_VAR_TABLE_SECTION_NAME))) = { };\n \n+#elif defined CRT_TABLE\n+\n extern const void *const __offload_func_table[];\n extern const void *const __offload_var_table[];\n+extern const void *const __offload_funcs_end[];\n+extern const void *const __offload_vars_end[];\n \n const void *const __OFFLOAD_TABLE__[]\n   __attribute__ ((__visibility__ (\"hidden\"))) =\n {\n   &__offload_func_table, &__offload_funcs_end,\n   &__offload_var_table, &__offload_vars_end\n };\n+\n+#else /* ! CRT_BEGIN && ! CRT_END && ! CRT_TABLE  */\n+#error \"One of CRT_BEGIN, CRT_END or CRT_TABLE must be defined.\"\n #endif\n \n-#else /* ! CRT_BEGIN && ! CRT_END */\n-#error \"One of CRT_BEGIN or CRT_END must be defined.\"\n #endif"}, {"sha": "3cf28601f0d7a79d0c4bf8335c429bdcf6753f43", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -1,3 +1,8 @@\n+2016-02-25  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\tPR driver/68463\n+\t* testsuite/libgomp.oacc-c-c++-common/parallel-dims-2.c: Remove.\n+\n 2016-02-23  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* oacc-parallel.c (GOACC_parallel_keyed): Initialize dims."}, {"sha": "eea8c7e4fa2401dbbb907e094afa32155bc96689", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-dims-2.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf1fcb76fb5e8064316ef40d3c563c8d8e3fdc36/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf1fcb76fb5e8064316ef40d3c563c8d8e3fdc36/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims-2.c?ref=cf1fcb76fb5e8064316ef40d3c563c8d8e3fdc36", "patch": "@@ -1,19 +0,0 @@\n-/* { dg-do run { target { openacc_nvidia_accel_selected && lto } } } */\n-/* { dg-additional-options \"-flto -fno-use-linker-plugin\" } */\n-\n-/* Worker and vector size checks.  Picked an outrageously large\n-   value.  */\n-\n-int main ()\n-{\n-#pragma acc parallel num_workers (2<<20) /* { dg-error \"using num_workers\" } */\n-  {\n-  }\n-\n-#pragma acc parallel vector_length (2<<20) /* { dg-error \"using vector_length\" } */\n-  {\n-  }\n-\n-  return 0;\n-}\n-"}, {"sha": "d2cd98675bc7f929945bd9dc56cb9e87f938ee21", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -1,3 +1,17 @@\n+2016-02-25  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\tPR driver/68463\n+\t* lto-plugin.c (struct plugin_offload_file): New.\n+\t(offload_files): Change type.\n+\t(offload_files_last, offload_files_last_obj): New.\n+\t(offload_files_last_lto): New.\n+\t(free_2): Adjust accordingly.\n+\t(all_symbols_read_handler): Don't add offload files to lto_arg_ptr.\n+\tDon't call free_1 for offload_files.  Write names of object files with\n+\toffloading to the temporary file.  Add new option to lto_arg_ptr.\n+\t(claim_file_handler): Don't claim file if it contains offload sections\n+\twithout LTO sections.  If it contains offload sections, add to the list.\n+\n 2016-01-15  Martin Liska  <mliska@suse.cz>\n \n \t* lto-plugin.c (all_symbols_read_handler): Assign default"}, {"sha": "51afc528d059be925cc65993ec7d0680a694fde8", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 113, "deletions": 27, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6861a99f8c95aae9e0088c30b574efe03a790d9/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6861a99f8c95aae9e0088c30b574efe03a790d9/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=e6861a99f8c95aae9e0088c30b574efe03a790d9", "patch": "@@ -129,6 +129,14 @@ struct plugin_file_info\n   struct plugin_symtab conflicts;\n };\n \n+/* List item with name of the file with offloading.  */\n+\n+struct plugin_offload_file\n+{\n+  char *name;\n+  struct plugin_offload_file *next;\n+};\n+\n /* Until ASM_OUTPUT_LABELREF can be hookized and decoupled from\n    stdio file streams, we do simple label translation here.  */\n \n@@ -152,8 +160,16 @@ static ld_plugin_add_symbols add_symbols;\n static struct plugin_file_info *claimed_files = NULL;\n static unsigned int num_claimed_files = 0;\n \n-static struct plugin_file_info *offload_files = NULL;\n-static unsigned int num_offload_files = 0;\n+/* List of files with offloading.  */\n+static struct plugin_offload_file *offload_files;\n+/* Last file in the list.  */\n+static struct plugin_offload_file *offload_files_last;\n+/* Last non-archive file in the list.  */\n+static struct plugin_offload_file *offload_files_last_obj;\n+/* Last LTO file in the list.  */\n+static struct plugin_offload_file *offload_files_last_lto;\n+/* Total number of files with offloading.  */\n+static unsigned num_offload_files;\n \n static char **output_files = NULL;\n static unsigned int num_output_files = 0;\n@@ -351,14 +367,6 @@ free_2 (void)\n       free (info->name);\n     }\n \n-  for (i = 0; i < num_offload_files; i++)\n-    {\n-      struct plugin_file_info *info = &offload_files[i];\n-      struct plugin_symtab *symtab = &info->symtab;\n-      free (symtab->aux);\n-      free (info->name);\n-    }\n-\n   for (i = 0; i < num_output_files; i++)\n     free (output_files[i]);\n   free (output_files);\n@@ -367,8 +375,12 @@ free_2 (void)\n   claimed_files = NULL;\n   num_claimed_files = 0;\n \n-  free (offload_files);\n-  offload_files = NULL;\n+  while (offload_files)\n+    {\n+      struct plugin_offload_file *ofld = offload_files;\n+      offload_files = offload_files->next;\n+      free (ofld);\n+    }\n   num_offload_files = 0;\n \n   free (arguments_file_name);\n@@ -625,8 +637,7 @@ static enum ld_plugin_status\n all_symbols_read_handler (void)\n {\n   unsigned i;\n-  unsigned num_lto_args\n-    = num_claimed_files + num_offload_files + lto_wrapper_num_args + 2;\n+  unsigned num_lto_args = num_claimed_files + lto_wrapper_num_args + 3;\n   char **lto_argv;\n   const char *linker_output_str = NULL;\n   const char **lto_arg_ptr;\n@@ -646,7 +657,6 @@ all_symbols_read_handler (void)\n   write_resolution ();\n \n   free_1 (claimed_files, num_claimed_files);\n-  free_1 (offload_files, num_offload_files);\n \n   for (i = 0; i < lto_wrapper_num_args; i++)\n     *lto_arg_ptr++ = lto_wrapper_argv[i];\n@@ -671,16 +681,38 @@ all_symbols_read_handler (void)\n       break;\n     }\n   *lto_arg_ptr++ = xstrdup (linker_output_str);\n-  for (i = 0; i < num_claimed_files; i++)\n+\n+  if (num_offload_files > 0)\n     {\n-      struct plugin_file_info *info = &claimed_files[i];\n+      FILE *f;\n+      char *arg;\n+      char *offload_objects_file_name;\n+      struct plugin_offload_file *ofld;\n+\n+      offload_objects_file_name = make_temp_file (\".ofldlist\");\n+      check (offload_objects_file_name, LDPL_FATAL,\n+\t     \"Failed to generate a temporary file name\");\n+      f = fopen (offload_objects_file_name, \"w\");\n+      check (f, LDPL_FATAL, \"could not open file with offload objects\");\n+      fprintf (f, \"%u\\n\", num_offload_files);\n+\n+      /* Skip the dummy item at the start of the list.  */\n+      ofld = offload_files->next;\n+      while (ofld)\n+\t{\n+\t  fprintf (f, \"%s\\n\", ofld->name);\n+\t  ofld = ofld->next;\n+\t}\n+      fclose (f);\n \n-      *lto_arg_ptr++ = info->name;\n+      arg = concat (\"-foffload-objects=\", offload_objects_file_name, NULL);\n+      check (arg, LDPL_FATAL, \"could not allocate\");\n+      *lto_arg_ptr++ = arg;\n     }\n \n-  for (i = 0; i < num_offload_files; i++)\n+  for (i = 0; i < num_claimed_files; i++)\n     {\n-      struct plugin_file_info *info = &offload_files[i];\n+      struct plugin_file_info *info = &claimed_files[i];\n \n       *lto_arg_ptr++ = info->name;\n     }\n@@ -1007,18 +1039,72 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n \txrealloc (claimed_files,\n \t\t  num_claimed_files * sizeof (struct plugin_file_info));\n       claimed_files[num_claimed_files - 1] = lto_file;\n+\n+      *claimed = 1;\n     }\n \n-  if (obj.found == 0 && obj.offload == 1)\n+  if (offload_files == NULL)\n     {\n-      num_offload_files++;\n-      offload_files =\n-\txrealloc (offload_files,\n-\t\t  num_offload_files * sizeof (struct plugin_file_info));\n-      offload_files[num_offload_files - 1] = lto_file;\n+      /* Add dummy item to the start of the list.  */\n+      offload_files = xmalloc (sizeof (struct plugin_offload_file));\n+      offload_files->name = NULL;\n+      offload_files->next = NULL;\n+      offload_files_last = offload_files;\n     }\n \n-  *claimed = 1;\n+  /* If this is an LTO file without offload, and it is the first LTO file, save\n+     the pointer to the last offload file in the list.  Further offload LTO\n+     files will be inserted after it, if any.  */\n+  if (*claimed && obj.offload == 0 && offload_files_last_lto == NULL)\n+    offload_files_last_lto = offload_files_last;\n+\n+  if (obj.offload == 1)\n+    {\n+      /* Add file to the list.  The order must be exactly the same as the final\n+\t order after recompilation and linking, otherwise host and target tables\n+\t with addresses wouldn't match.  If a static library contains both LTO\n+\t and non-LTO objects, ld and gold link them in a different order.  */\n+      struct plugin_offload_file *ofld\n+\t= xmalloc (sizeof (struct plugin_offload_file));\n+      ofld->name = lto_file.name;\n+      ofld->next = NULL;\n+\n+      if (*claimed && offload_files_last_lto == NULL && file->offset != 0\n+\t  && gold_version == -1)\n+\t{\n+\t  /* ld only: insert first LTO file from the archive after the last real\n+\t     object file immediately preceding the archive, or at the begin of\n+\t     the list if there was no real objects before archives.  */\n+\t  if (offload_files_last_obj != NULL)\n+\t    {\n+\t      ofld->next = offload_files_last_obj->next;\n+\t      offload_files_last_obj->next = ofld;\n+\t    }\n+\t  else\n+\t    {\n+\t      ofld->next = offload_files->next;\n+\t      offload_files->next = ofld;\n+\t    }\n+\t}\n+      else if (*claimed && offload_files_last_lto != NULL)\n+\t{\n+\t  /* Insert LTO file after the last LTO file in the list.  */\n+\t  ofld->next = offload_files_last_lto->next;\n+\t  offload_files_last_lto->next = ofld;\n+\t}\n+      else\n+\t/* Add non-LTO file or first non-archive LTO file to the end of the\n+\t   list.  */\n+\toffload_files_last->next = ofld;\n+\n+      if (ofld->next == NULL)\n+\toffload_files_last = ofld;\n+      if (file->offset == 0)\n+\toffload_files_last_obj = ofld;\n+      if (*claimed)\n+\toffload_files_last_lto = ofld;\n+      num_offload_files++;\n+    }\n \n   goto cleanup;\n "}]}