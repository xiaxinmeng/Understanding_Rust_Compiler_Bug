{"sha": "75df395f15f2641bfcae7f1179d3ef963771379c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkZjM5NWYxNWYyNjQxYmZjYWU3ZjExNzlkM2VmOTYzNzcxMzc5Yw==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2009-05-18T07:54:44Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2009-05-18T07:54:44Z"}, "message": "M68K TLS support.\n\n\t* configure.ac (m68k-*-*): Check if binutils support TLS.\n\t* configure: Regenerate.\n\t* config/m68k/predicates.md (symbolic_operand): Extend comment.\n\t* config/m68k/constraints.md (Cu): New constraint.\n\t* config/m68k/m68k.md (UNSPEC_GOTOFF): Remove.\n\t(UNSPEC_RELOC16, UNSPEC_RELOC32): New constants.\n\t(movsi): Handle TLS symbols.\n\t(addsi3_5200): Handle XTLS symbols, indent.\n\t* config/m68k/m68k-protos.h (m68k_legitimize_tls_address): Declare.\n\t(m68k_tls_reference_p): Declare.\n\t(m68k_legitimize_address): Declare.\n\t(m68k_unwrap_symbol): Declare.\n\t* config/m68k/m68k.opt (mxtls): New option.\n\t* config/m68k/m68k.c (ggc.h): Include.\n\t(m68k_output_dwarf_dtprel): Implement hook.\n\t(TARGET_HAVE_TLS, TARGET_ASM_OUTPUT_DWARF_DTPREL): Define.\n\t(m68k_expand_prologue): Load GOT pointer when function needs it.\n\t(m68k_illegitimate_symbolic_constant_p): Handle TLS symbols.\n\t(m68k_legitimate_constant_address_p): Same.\n\t(m68k_decompose_address): Handle TLS references.\n\t(m68k_get_gp): New static function.\n\t(enum m68k_reloc): New contants.\n\t(TLS_RELOC_P): New macro.\n\t(m68k_wrap_symbol): New static function.\n\t(m68k_unwrap_symbol): New function.\n\t(m68k_final_prescan_insn_1): New static function.\n\t(m68k_final_prescan_insn): New function.\n\t(m68k_move_to_reg, m68k_wrap_symbol_into_got_ref): New static\n\tfunctions.\n\t(legitimize_pic_address): Handle TLS references..\n\t(m68k_tls_get_addr, m68k_get_tls_get_addr)\n\t(m68k_libcall_value_in_a0_p)\n\t(m68k_call_tls_get_addr, m68k_read_tp, m68k_get_m68k_read_tp)\n\t(m68k_call_m68k_read_tp): Helper variables and functions for ...\n\t(m68k_legitimize_tls_address): Handle TLS references.\n\t(m68k_tls_symbol_p, m68k_tls_reference_p_1, m68k_tls_reference_p):\n\tNew functions.\n\t(m68k_legitimize_address): Handle TLS symbols.\n\t(m68k_get_reloc_decoration): New static function.\n\t(m68k_output_addr_const_extra): Handle UNSPEC_RELOC16 and\n\tUNSPEC_RELOC32.\n\t(m68k_output_dwarf_dtprel): Implement hook.\n\t(print_operand_address): Handle UNSPEC_RELOC16 adn UNSPEC_RELOC32.\n\t(m68k_libcall_value): Return result in A0 instead of D0 when asked by\n\tm68k_call_* routines.\n\t(sched_attr_op_type): Handle TLS symbols.\n\t(gt-m68k.h): Include.\n\t* config/m68k/m68k.h (FINAL_PRESCAN_INSN): Define.\n\t(LEGITIMATE_PIC_OPERAND_P): Support TLS.\n\n\t* gcc.target/m68k/tls-ie.c: New test.\n\t* gcc.target/m68k/tls-le.c: New test.\n\t* gcc.target/m68k/tls-gd.c: New test.\n\t* gcc.target/m68k/tls-ld.c: New test.\n\t* gcc.target/m68k/tls-ie-xgot.c: New test.\n\t* gcc.target/m68k/tls-le-xtls.c: New test.\n\t* gcc.target/m68k/tls-gd-xgot.c: New test.\n\t* gcc.target/m68k/tls-ld-xgot.c: New test.\n\t* gcc.target/m68k/tls-ld-xtls.c: New test.\n\t* gcc.target/m68k/tls-ld-xgot-xtls.c: New test.\n\nFrom-SVN: r147654", "tree": {"sha": "e8ce029d9db8c2877121f38cd2a486004490e1d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8ce029d9db8c2877121f38cd2a486004490e1d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75df395f15f2641bfcae7f1179d3ef963771379c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75df395f15f2641bfcae7f1179d3ef963771379c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75df395f15f2641bfcae7f1179d3ef963771379c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75df395f15f2641bfcae7f1179d3ef963771379c/comments", "author": null, "committer": null, "parents": [{"sha": "676fd528c9990a4f1046b51d40059893c3a71490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/676fd528c9990a4f1046b51d40059893c3a71490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/676fd528c9990a4f1046b51d40059893c3a71490"}], "stats": {"total": 989, "additions": 902, "deletions": 87}, "files": [{"sha": "372df6b4eb34c0a204a883afaeee2c9008b038ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -1,3 +1,56 @@\n+2009-05-18  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\tM68K TLS support.\n+\t* configure.ac (m68k-*-*): Check if binutils support TLS.\n+\t* configure: Regenerate.\n+\t* config/m68k/predicates.md (symbolic_operand): Extend comment.\n+\t* config/m68k/constraints.md (Cu): New constraint.\n+\t* config/m68k/m68k.md (UNSPEC_GOTOFF): Remove.\n+\t(UNSPEC_RELOC16, UNSPEC_RELOC32): New constants.\n+\t(movsi): Handle TLS symbols.\n+\t(addsi3_5200): Handle XTLS symbols, indent.\n+\t* config/m68k/m68k-protos.h (m68k_legitimize_tls_address): Declare.\n+\t(m68k_tls_reference_p): Declare.\n+\t(m68k_legitimize_address): Declare.\n+\t(m68k_unwrap_symbol): Declare.\n+\t* config/m68k/m68k.opt (mxtls): New option.\n+\t* config/m68k/m68k.c (ggc.h): Include.\n+\t(m68k_output_dwarf_dtprel): Implement hook.\n+\t(TARGET_HAVE_TLS, TARGET_ASM_OUTPUT_DWARF_DTPREL): Define.\n+\t(m68k_expand_prologue): Load GOT pointer when function needs it.\n+\t(m68k_illegitimate_symbolic_constant_p): Handle TLS symbols.\n+\t(m68k_legitimate_constant_address_p): Same.\n+\t(m68k_decompose_address): Handle TLS references.\n+\t(m68k_get_gp): New static function.\n+\t(enum m68k_reloc): New contants.\n+\t(TLS_RELOC_P): New macro.\n+\t(m68k_wrap_symbol): New static function.\n+\t(m68k_unwrap_symbol): New function.\n+\t(m68k_final_prescan_insn_1): New static function.\n+\t(m68k_final_prescan_insn): New function.\n+\t(m68k_move_to_reg, m68k_wrap_symbol_into_got_ref): New static\n+\tfunctions.\n+\t(legitimize_pic_address): Handle TLS references..\n+\t(m68k_tls_get_addr, m68k_get_tls_get_addr)\n+\t(m68k_libcall_value_in_a0_p)\n+\t(m68k_call_tls_get_addr, m68k_read_tp, m68k_get_m68k_read_tp)\n+\t(m68k_call_m68k_read_tp): Helper variables and functions for ...\n+\t(m68k_legitimize_tls_address): Handle TLS references.\n+\t(m68k_tls_symbol_p, m68k_tls_reference_p_1, m68k_tls_reference_p):\n+\tNew functions.\n+\t(m68k_legitimize_address): Handle TLS symbols.\n+\t(m68k_get_reloc_decoration): New static function.\n+\t(m68k_output_addr_const_extra): Handle UNSPEC_RELOC16 and\n+\tUNSPEC_RELOC32.\n+\t(m68k_output_dwarf_dtprel): Implement hook.\n+\t(print_operand_address): Handle UNSPEC_RELOC16 adn UNSPEC_RELOC32.\n+\t(m68k_libcall_value): Return result in A0 instead of D0 when asked by\n+\tm68k_call_* routines.\n+\t(sched_attr_op_type): Handle TLS symbols.\n+\t(gt-m68k.h): Include.\n+\t* config/m68k/m68k.h (FINAL_PRESCAN_INSN): Define.\n+\t(LEGITIMATE_PIC_OPERAND_P): Support TLS.\n+\n 2009-05-18  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.c (ipa_check_stmt_modifications): Removed."}, {"sha": "a4885cda6ca5b030f998e3680d6b3ab31df470f4", "filename": "gcc/config/m68k/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fconstraints.md?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -129,6 +129,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival < -0x8000 || ival > 0x7FFF\")))\n \n+(define_constraint \"Cu\"\n+  \"16-bit offset for wrapped symbols\"\n+  (and (match_code \"const\")\n+       (match_test \"m68k_unwrap_symbol (op, false) != op\")))\n+\n (define_constraint \"CQ\"\n   \"Integers valid for mvq.\"\n   (and (match_code \"const_int\")"}, {"sha": "08f8a91e6916db668c3415a6ca7663bcfdbb4c0c", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -59,13 +59,20 @@ extern bool m68k_illegitimate_symbolic_constant_p (rtx);\n extern bool m68k_matches_q_p (rtx);\n extern bool m68k_matches_u_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern rtx m68k_legitimize_tls_address (rtx);\n+extern bool m68k_tls_reference_p (rtx, bool);\n extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);\n extern rtx m68k_libcall_value (enum machine_mode);\n extern rtx m68k_function_value (const_tree, const_tree);\n extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n extern bool m68k_movem_pattern_p (rtx, rtx, HOST_WIDE_INT, bool);\n extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);\n+extern void m68k_final_prescan_insn (rtx, rtx *, int);\n \n+/* Functions from m68k.c used in constraints.md.  */\n+extern rtx m68k_unwrap_symbol (rtx, bool);\n+\n+/* Functions from m68k.c used in genattrtab.  */\n #ifdef HAVE_ATTR_cpu\n extern enum attr_cpu m68k_sched_cpu;\n extern enum attr_mac m68k_sched_mac;"}, {"sha": "c5a668a497b6fe4df6b347ae413c0c12732c0b58", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 603, "deletions": 77, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n /* ??? Need to add a dependency between m68k.o and sched-int.h.  */\n #include \"sched-int.h\"\n #include \"insn-codes.h\"\n+#include \"ggc.h\"\n \n enum reg_class regno_reg_class[] =\n {\n@@ -144,11 +145,13 @@ static tree m68k_handle_fndecl_attribute (tree *node, tree name,\n static void m68k_compute_frame_layout (void);\n static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);\n static bool m68k_ok_for_sibcall_p (tree, tree);\n+static bool m68k_tls_symbol_p (rtx);\n static rtx m68k_legitimize_address (rtx, rtx, enum machine_mode);\n static bool m68k_rtx_costs (rtx, int, int, int *, bool);\n #if M68K_HONOR_TARGET_STRICT_ALIGNMENT\n static bool m68k_return_in_memory (const_tree, const_tree);\n #endif\n+static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n \f\n \n /* Specify the identification number of the library being built */\n@@ -249,6 +252,14 @@ const char *m68k_library_id_string = \"_current_shared_library_a5_offset_\";\n #define TARGET_RETURN_IN_MEMORY m68k_return_in_memory\n #endif\n \n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS (true)\n+\n+#undef TARGET_ASM_OUTPUT_DWARF_DTPREL\n+#define TARGET_ASM_OUTPUT_DWARF_DTPREL m68k_output_dwarf_dtprel\n+#endif\n+\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P\tm68k_legitimate_address_p\n \n@@ -1149,8 +1160,7 @@ m68k_expand_prologue (void)\n \t\t\t    current_frame.reg_mask, true, true));\n     }\n \n-  if (flag_pic\n-      && !TARGET_SEP_DATA\n+  if (!TARGET_SEP_DATA\n       && crtl->uses_pic_offset_table)\n     insn = emit_insn (gen_load_got (pic_offset_table_rtx));\n }\n@@ -1435,6 +1445,9 @@ m68k_legitimize_sibcall_address (rtx x)\n rtx\n m68k_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n {\n+  if (m68k_tls_symbol_p (x))\n+    return m68k_legitimize_tls_address (x);\n+\n   if (GET_CODE (x) == PLUS)\n     {\n       int ch = (x) != (oldx);\n@@ -1853,7 +1866,7 @@ m68k_illegitimate_symbolic_constant_p (rtx x)\n \t  && !offset_within_block_p (base, INTVAL (offset)))\n \treturn true;\n     }\n-  return false;\n+  return m68k_tls_reference_p (x, false);\n }\n \n /* Return true if X is a legitimate constant address that can reach\n@@ -1881,7 +1894,7 @@ m68k_legitimate_constant_address_p (rtx x, unsigned int reach, bool strict_p)\n \treturn false;\n     }\n \n-  return true;\n+  return !m68k_tls_reference_p (x, false);\n }\n \n /* Return true if X is a LABEL_REF for a jump table.  Assume that unplaced\n@@ -1948,15 +1961,17 @@ m68k_decompose_address (enum machine_mode mode, rtx x,\n   /* Check for GOT loads.  These are (bd,An,Xn) addresses if\n      TARGET_68020 && flag_pic == 2, otherwise they are (d16,An)\n      addresses.  */\n-  if (flag_pic\n-      && GET_CODE (x) == PLUS\n-      && XEXP (x, 0) == pic_offset_table_rtx\n-      && (GET_CODE (XEXP (x, 1)) == SYMBOL_REF\n-\t  || GET_CODE (XEXP (x, 1)) == LABEL_REF))\n+  if (GET_CODE (x) == PLUS\n+      && XEXP (x, 0) == pic_offset_table_rtx)\n     {\n-      address->base = XEXP (x, 0);\n-      address->offset = XEXP (x, 1);\n-      return true;\n+      /* As we are processing a PLUS, do not unwrap RELOC32 symbols --\n+\t they are invalid in this context.  */\n+      if (m68k_unwrap_symbol (XEXP (x, 1), false) != XEXP (x, 1))\n+\t{\n+\t  address->base = XEXP (x, 0);\n+\t  address->offset = XEXP (x, 1);\n+\t  return true;\n+\t}\n     }\n \n   /* The ColdFire FPU only accepts addressing modes 2-5.  */\n@@ -2101,6 +2116,243 @@ m68k_matches_u_p (rtx x)\n \t  && !address.index);\n }\n \n+/* Return GOT pointer.  */\n+\n+static rtx\n+m68k_get_gp (void)\n+{\n+  if (pic_offset_table_rtx == NULL_RTX)\n+    pic_offset_table_rtx = gen_rtx_REG (Pmode, PIC_REG);\n+\n+  crtl->uses_pic_offset_table = 1;\n+\n+  return pic_offset_table_rtx;\n+}\n+\n+/* M68K relocations, used to distinguish GOT and TLS relocations in UNSPEC\n+   wrappers.  */\n+enum m68k_reloc { RELOC_GOT, RELOC_TLSGD, RELOC_TLSLDM, RELOC_TLSLDO,\n+\t\t  RELOC_TLSIE, RELOC_TLSLE };\n+\n+#define TLS_RELOC_P(RELOC) ((RELOC) != RELOC_GOT)\n+\n+/* Wrap symbol X into unspec representing relocation RELOC.\n+   BASE_REG - register that should be added to the result.\n+   TEMP_REG - if non-null, temporary register.  */\n+\n+static rtx\n+m68k_wrap_symbol (rtx x, enum m68k_reloc reloc, rtx base_reg, rtx temp_reg)\n+{\n+  bool use_x_p;\n+\n+  use_x_p = (base_reg == pic_offset_table_rtx) ? TARGET_XGOT : TARGET_XTLS;\n+\n+  if (TARGET_COLDFIRE && use_x_p)\n+    /* When compiling with -mx{got, tls} switch the code will look like this:\n+\n+       move.l <X>@<RELOC>,<TEMP_REG>\n+       add.l <BASE_REG>,<TEMP_REG>  */\n+    {\n+      /* Wrap X in UNSPEC_??? to tip m68k_output_addr_const_extra\n+\t to put @RELOC after reference.  */\n+      x = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (reloc)),\n+\t\t\t  UNSPEC_RELOC32);\n+      x = gen_rtx_CONST (Pmode, x);\n+\n+      if (temp_reg == NULL)\n+\t{\n+\t  gcc_assert (can_create_pseudo_p ());\n+\t  temp_reg = gen_reg_rtx (Pmode);\n+\t}\n+\n+      emit_move_insn (temp_reg, x);\n+      emit_insn (gen_addsi3 (temp_reg, temp_reg, base_reg));\n+      x = temp_reg;\n+    }\n+  else\n+    {\n+      x = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (reloc)),\n+\t\t\t  UNSPEC_RELOC16);\n+      x = gen_rtx_CONST (Pmode, x);\n+\n+      x = gen_rtx_PLUS (Pmode, base_reg, x);\n+    }\n+\n+  return x;\n+}\n+\n+/* Helper for m68k_unwrap_symbol.\n+   Also, if unwrapping was successful (that is if (ORIG != <return value>)),\n+   sets *RELOC_PTR to relocation type for the symbol.  */\n+\n+static rtx\n+m68k_unwrap_symbol_1 (rtx orig, bool unwrap_reloc32_p,\n+\t\t      enum m68k_reloc *reloc_ptr)\n+{\n+  if (GET_CODE (orig) == CONST)\n+    {\n+      rtx x;\n+      enum m68k_reloc dummy;\n+\n+      x = XEXP (orig, 0);\n+\n+      if (reloc_ptr == NULL)\n+\treloc_ptr = &dummy;\n+\n+      /* Handle an addend.  */\n+      if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)\n+\t  && CONST_INT_P (XEXP (x, 1)))\n+\tx = XEXP (x, 0);\n+\n+      if (GET_CODE (x) == UNSPEC)\n+\t{\n+\t  switch (XINT (x, 1))\n+\t    {\n+\t    case UNSPEC_RELOC16:\n+\t      orig = XVECEXP (x, 0, 0);\n+\t      *reloc_ptr = (enum m68k_reloc) INTVAL (XVECEXP (x, 0, 1));\n+\t      break;\n+\n+\t    case UNSPEC_RELOC32:\n+\t      if (unwrap_reloc32_p)\n+\t\t{\n+\t\t  orig = XVECEXP (x, 0, 0);\n+\t\t  *reloc_ptr = (enum m68k_reloc) INTVAL (XVECEXP (x, 0, 1));\n+\t\t}\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  return orig;\n+}\n+\n+/* Unwrap symbol from UNSPEC_RELOC16 and, if unwrap_reloc32_p,\n+   UNSPEC_RELOC32 wrappers.  */\n+\n+rtx\n+m68k_unwrap_symbol (rtx orig, bool unwrap_reloc32_p)\n+{\n+  return m68k_unwrap_symbol_1 (orig, unwrap_reloc32_p, NULL);\n+}\n+\n+/* Helper for m68k_final_prescan_insn.  */\n+\n+static int\n+m68k_final_prescan_insn_1 (rtx *x_ptr, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x = *x_ptr;\n+\n+  if (m68k_unwrap_symbol (x, true) != x)\n+    /* For rationale of the below, see comment in m68k_final_prescan_insn.  */\n+    {\n+      rtx plus;\n+\n+      gcc_assert (GET_CODE (x) == CONST);\n+      plus = XEXP (x, 0);\n+\n+      if (GET_CODE (plus) == PLUS || GET_CODE (plus) == MINUS)\n+\t{\n+\t  rtx unspec;\n+\t  rtx addend;\n+\n+\t  unspec = XEXP (plus, 0);\n+\t  gcc_assert (GET_CODE (unspec) == UNSPEC);\n+\t  addend = XEXP (plus, 1);\n+\t  gcc_assert (CONST_INT_P (addend));\n+\n+\t  /* We now have all the pieces, rearrange them.  */\n+\n+\t  /* Move symbol to plus.  */\n+\t  XEXP (plus, 0) = XVECEXP (unspec, 0, 0);\n+\n+\t  /* Move plus inside unspec.  */\n+\t  XVECEXP (unspec, 0, 0) = plus;\n+\n+\t  /* Move unspec to top level of const.  */\n+\t  XEXP (x, 0) = unspec;\n+\t}\n+\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Prescan insn before outputing assembler for it.  */\n+\n+void\n+m68k_final_prescan_insn (rtx insn ATTRIBUTE_UNUSED,\n+\t\t\t rtx *operands, int n_operands)\n+{\n+  int i;\n+\n+  /* Combine and, possibly, other optimizations may do good job\n+     converting\n+       (const (unspec [(symbol)]))\n+     into\n+       (const (plus (unspec [(symbol)])\n+                    (const_int N))).\n+     The problem with this is emitting @TLS or @GOT decorations.\n+     The decoration is emitted when processing (unspec), so the\n+     result would be \"#symbol@TLSLE+N\" instead of \"#symbol+N@TLSLE\".\n+\n+     It seems that the easiest solution to this is to convert such\n+     operands to\n+       (const (unspec [(plus (symbol)\n+                             (const_int N))])).\n+     Note, that the top level of operand remains intact, so we don't have\n+     to patch up anything outside of the operand.  */\n+\n+  for (i = 0; i < n_operands; ++i)\n+    {\n+      rtx op;\n+\n+      op = operands[i];\n+\n+      for_each_rtx (&op, m68k_final_prescan_insn_1, NULL);\n+    }\n+}\n+\n+/* Move X to a register and add REG_EQUAL note pointing to ORIG.\n+   If REG is non-null, use it; generate new pseudo otherwise.  */\n+\n+static rtx\n+m68k_move_to_reg (rtx x, rtx orig, rtx reg)\n+{\n+  rtx insn;\n+\n+  if (reg == NULL_RTX)\n+    {\n+      gcc_assert (can_create_pseudo_p ());\n+      reg = gen_reg_rtx (Pmode);\n+    }\n+\n+  insn = emit_move_insn (reg, x);\n+  /* Put a REG_EQUAL note on this insn, so that it can be optimized\n+     by loop.  */\n+  set_unique_reg_note (insn, REG_EQUAL, orig);\n+\n+  return reg;\n+}\n+\n+/* Does the same as m68k_wrap_symbol, but returns a memory reference to\n+   GOT slot.  */\n+\n+static rtx\n+m68k_wrap_symbol_into_got_ref (rtx x, enum m68k_reloc reloc, rtx temp_reg)\n+{\n+  x = m68k_wrap_symbol (x, reloc, m68k_get_gp (), temp_reg);\n+\n+  x = gen_rtx_MEM (Pmode, x);\n+  MEM_READONLY_P (x) = 1;\n+\n+  return x;\n+}\n+\n /* Legitimize PIC addresses.  If the address is already\n    position-independent, we return ORIG.  Newly generated\n    position-independent addresses go to REG.  If we need more\n@@ -2152,42 +2404,15 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n     {\n       gcc_assert (reg);\n \n-      if (TARGET_COLDFIRE && TARGET_XGOT)\n-\t/* When compiling with -mxgot switch the code for the above\n-\t   example will look like this:\n-\n-\t   movel a5, a0\n-\t   addl _foo@GOT, a0\n-\t   movel a0@, a0\n-\t   movel #12345, a0@  */\n-\t{\n-\t  rtx pic_offset;\n-\n-\t  /* Wrap ORIG in UNSPEC_GOTOFF to tip m68k_output_addr_const_extra\n-\t     to put @GOT after reference.  */\n-\t  pic_offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, orig),\n-\t\t\t\t       UNSPEC_GOTOFF);\n-\t  pic_offset = gen_rtx_CONST (Pmode, pic_offset);\n-\t  emit_move_insn (reg, pic_offset);\n-\t  emit_insn (gen_addsi3 (reg, reg, pic_offset_table_rtx));\n-\t  pic_ref = gen_rtx_MEM (Pmode, reg);\n-\t}\n-      else\n-\tpic_ref = gen_rtx_MEM (Pmode,\n-\t\t\t       gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t     pic_offset_table_rtx, orig));\n-      crtl->uses_pic_offset_table = 1;\n-      MEM_READONLY_P (pic_ref) = 1;\n-      emit_move_insn (reg, pic_ref);\n-      return reg;\n+      pic_ref = m68k_wrap_symbol_into_got_ref (orig, RELOC_GOT, reg);\n+      pic_ref = m68k_move_to_reg (pic_ref, orig, reg);\n     }\n   else if (GET_CODE (orig) == CONST)\n     {\n       rtx base;\n \n       /* Make sure this has not already been legitimized.  */\n-      if (GET_CODE (XEXP (orig, 0)) == PLUS\n-\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+      if (m68k_unwrap_symbol (orig, true) != orig)\n \treturn orig;\n \n       gcc_assert (reg);\n@@ -2200,13 +2425,257 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\t     base == reg ? 0 : reg);\n \n       if (GET_CODE (orig) == CONST_INT)\n-\treturn plus_constant (base, INTVAL (orig));\n-      pic_ref = gen_rtx_PLUS (Pmode, base, orig);\n-      /* Likewise, should we set special REG_NOTEs here?  */\n+\tpic_ref = plus_constant (base, INTVAL (orig));\n+      else\n+\tpic_ref = gen_rtx_PLUS (Pmode, base, orig);\n     }\n+\n   return pic_ref;\n }\n \n+/* The __tls_get_addr symbol.  */\n+static GTY(()) rtx m68k_tls_get_addr;\n+\n+/* Return SYMBOL_REF for __tls_get_addr.  */\n+\n+static rtx\n+m68k_get_tls_get_addr (void)\n+{\n+  if (m68k_tls_get_addr == NULL_RTX)\n+    m68k_tls_get_addr = init_one_libfunc (\"__tls_get_addr\");\n+\n+  return m68k_tls_get_addr;\n+}\n+\n+/* Return libcall result in A0 instead of usual D0.  */\n+static bool m68k_libcall_value_in_a0_p = false;\n+\n+/* Emit instruction sequence that calls __tls_get_addr.  X is\n+   the TLS symbol we are referencing and RELOC is the symbol type to use\n+   (either TLSGD or TLSLDM).  EQV is the REG_EQUAL note for the sequence\n+   emitted.  A pseudo register with result of __tls_get_addr call is\n+   returned.  */\n+\n+static rtx\n+m68k_call_tls_get_addr (rtx x, rtx eqv, enum m68k_reloc reloc)\n+{\n+  rtx a0;\n+  rtx insns;\n+  rtx dest;\n+\n+  /* Emit the call sequence.  */\n+  start_sequence ();\n+\n+  /* FIXME: Unfortunately, emit_library_call_value does not\n+     consider (plus (%a5) (const (unspec))) to be a good enough\n+     operand for push, so it forces it into a register.  The bad\n+     thing about this is that combiner, due to copy propagation and other\n+     optimizations, sometimes can not later fix this.  As a consequence,\n+     additional register may be allocated resulting in a spill.\n+     For reference, see args processing loops in\n+     calls.c:emit_library_call_value_1.\n+     For testcase, see gcc.target/m68k/tls-{gd, ld}.c  */\n+  x = m68k_wrap_symbol (x, reloc, m68k_get_gp (), NULL_RTX);\n+\n+  /* __tls_get_addr() is not a libcall, but emitting a libcall_value\n+     is the simpliest way of generating a call.  The difference between\n+     __tls_get_addr() and libcall is that the result is returned in D0\n+     instead of A0.  To workaround this, we use m68k_libcall_value_in_a0_p\n+     which temporarily switches returning the result to A0.  */ \n+\n+  m68k_libcall_value_in_a0_p = true;\n+  a0 = emit_library_call_value (m68k_get_tls_get_addr (), NULL_RTX, LCT_PURE,\n+\t\t\t\tPmode, 1, x, Pmode);\n+  m68k_libcall_value_in_a0_p = false;\n+  \n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  gcc_assert (can_create_pseudo_p ());\n+  dest = gen_reg_rtx (Pmode);\n+  emit_libcall_block (insns, dest, a0, eqv);\n+\n+  return dest;\n+}\n+\n+/* The __tls_get_addr symbol.  */\n+static GTY(()) rtx m68k_read_tp;\n+\n+/* Return SYMBOL_REF for __m68k_read_tp.  */\n+\n+static rtx\n+m68k_get_m68k_read_tp (void)\n+{\n+  if (m68k_read_tp == NULL_RTX)\n+    m68k_read_tp = init_one_libfunc (\"__m68k_read_tp\");\n+\n+  return m68k_read_tp;\n+}\n+\n+/* Emit instruction sequence that calls __m68k_read_tp.\n+   A pseudo register with result of __m68k_read_tp call is returned.  */\n+\n+static rtx \n+m68k_call_m68k_read_tp (void)\n+{\n+  rtx a0;\n+  rtx eqv;\n+  rtx insns;\n+  rtx dest;\n+\n+  start_sequence ();\n+\n+  /* __m68k_read_tp() is not a libcall, but emitting a libcall_value\n+     is the simpliest way of generating a call.  The difference between\n+     __m68k_read_tp() and libcall is that the result is returned in D0\n+     instead of A0.  To workaround this, we use m68k_libcall_value_in_a0_p\n+     which temporarily switches returning the result to A0.  */ \n+\n+  /* Emit the call sequence.  */\n+  m68k_libcall_value_in_a0_p = true;\n+  a0 = emit_library_call_value (m68k_get_m68k_read_tp (), NULL_RTX, LCT_PURE,\n+\t\t\t\tPmode, 0);\n+  m68k_libcall_value_in_a0_p = false;\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  /* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n+     share the m68k_read_tp result with other IE/LE model accesses.  */\n+  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const1_rtx), UNSPEC_RELOC32);\n+\n+  gcc_assert (can_create_pseudo_p ());\n+  dest = gen_reg_rtx (Pmode);\n+  emit_libcall_block (insns, dest, a0, eqv);\n+\n+  return dest;\n+}\n+\n+/* Return a legitimized address for accessing TLS SYMBOL_REF X.\n+   For explanations on instructions sequences see TLS/NPTL ABI for m68k and\n+   ColdFire.  */\n+\n+rtx\n+m68k_legitimize_tls_address (rtx orig)\n+{\n+  switch (SYMBOL_REF_TLS_MODEL (orig))\n+    {\n+    case TLS_MODEL_GLOBAL_DYNAMIC:\n+      orig = m68k_call_tls_get_addr (orig, orig, RELOC_TLSGD);\n+      break;\n+\n+    case TLS_MODEL_LOCAL_DYNAMIC:\n+      {\n+\trtx eqv;\n+\trtx a0;\n+\trtx x;\n+ \n+\t/* Attach a unique REG_EQUIV, to allow the RTL optimizers to\n+\t   share the LDM result with other LD model accesses.  */\n+\teqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t      UNSPEC_RELOC32);\n+\n+\ta0 = m68k_call_tls_get_addr (orig, eqv, RELOC_TLSLDM);\n+\n+\tx = m68k_wrap_symbol (orig, RELOC_TLSLDO, a0, NULL_RTX);\n+\n+\tif (can_create_pseudo_p ())\n+\t  x = m68k_move_to_reg (x, orig, NULL_RTX);\n+\n+\torig = x;\n+\tbreak;\n+      }\n+\n+    case TLS_MODEL_INITIAL_EXEC:\n+      {\n+\trtx a0;\n+\trtx x;\n+\n+\ta0 = m68k_call_m68k_read_tp ();\n+\n+\tx = m68k_wrap_symbol_into_got_ref (orig, RELOC_TLSIE, NULL_RTX);\n+\tx = gen_rtx_PLUS (Pmode, x, a0);\n+\n+\tif (can_create_pseudo_p ())\n+\t  x = m68k_move_to_reg (x, orig, NULL_RTX);\n+\n+\torig = x;\n+\tbreak;\n+      }\n+\n+    case TLS_MODEL_LOCAL_EXEC:\n+      {\n+\trtx a0;\n+\trtx x;\n+\n+\ta0 = m68k_call_m68k_read_tp ();\n+\n+\tx = m68k_wrap_symbol (orig, RELOC_TLSLE, a0, NULL_RTX);\n+\n+\tif (can_create_pseudo_p ())\n+\t  x = m68k_move_to_reg (x, orig, NULL_RTX);\n+\n+\torig = x;\n+\tbreak;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return orig;\n+}\n+\n+/* Return true if X is a TLS symbol.  */\n+\n+static bool\n+m68k_tls_symbol_p (rtx x)\n+{\n+  if (!TARGET_HAVE_TLS)\n+    return false;\n+\n+  if (GET_CODE (x) != SYMBOL_REF)\n+    return false;\n+\n+  return SYMBOL_REF_TLS_MODEL (x) != 0;\n+}\n+\n+/* Helper for m68k_tls_referenced_p.  */\n+\n+static int\n+m68k_tls_reference_p_1 (rtx *x_ptr, void *data ATTRIBUTE_UNUSED)\n+{\n+  /* Note: this is not the same as m68k_tls_symbol_p.  */\n+  if (GET_CODE (*x_ptr) == SYMBOL_REF)\n+    return SYMBOL_REF_TLS_MODEL (*x_ptr) != 0 ? 1 : 0;\n+\n+  /* Don't recurse into legitimate TLS references.  */\n+  if (m68k_tls_reference_p (*x_ptr, true))\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* If !LEGITIMATE_P, return true if X is a TLS symbol reference,\n+   though illegitimate one.\n+   If LEGITIMATE_P, return true if X is a legitimate TLS symbol reference.  */\n+\n+bool\n+m68k_tls_reference_p (rtx x, bool legitimate_p)\n+{\n+  if (!TARGET_HAVE_TLS)\n+    return false;\n+\n+  if (!legitimate_p)\n+    return for_each_rtx (&x, m68k_tls_reference_p_1, NULL) == 1 ? true : false;\n+  else\n+    {\n+      enum m68k_reloc reloc = RELOC_GOT;\n+\n+      return (m68k_unwrap_symbol_1 (x, true, &reloc) != x\n+\t      && TLS_RELOC_P (reloc));\n+    }\n+}\n+\n \f\n \n #define USE_MOVQ(i)\t((unsigned) ((i) + 128) <= 255)\n@@ -3999,18 +4468,92 @@ print_operand (FILE *file, rtx op, int letter)\n     }\n }\n \n+/* Return string for TLS relocation RELOC.  */\n+\n+static const char *\n+m68k_get_reloc_decoration (enum m68k_reloc reloc)\n+{\n+  /* To my knowledge, !MOTOROLA assemblers don't support TLS.  */\n+  gcc_assert (MOTOROLA || reloc == RELOC_GOT);\n+\n+  switch (reloc)\n+    {\n+    case RELOC_GOT:\n+      if (MOTOROLA)\n+\t{\n+\t  if (flag_pic == 1 && TARGET_68020)\n+\t    return \"@GOT.w\";\n+\t  else\n+\t    return \"@GOT\";\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_68020)\n+\t    {\n+\t      switch (flag_pic)\n+\t\t{\n+\t\tcase 1:\n+\t\t  return \":w\";\n+\t\tcase 2:\n+\t\t  return \":l\";\n+\t\tdefault:\n+\t\t  return \"\";\n+\t\t}\n+\t    }\n+\t}\n+\n+    case RELOC_TLSGD:\n+      return \"@TLSGD\";\n+\n+    case RELOC_TLSLDM:\n+      return \"@TLSLDM\";\n+\n+    case RELOC_TLSLDO:\n+      return \"@TLSLDO\";\n+\n+    case RELOC_TLSIE:\n+      return \"@TLSIE\";\n+\n+    case RELOC_TLSLE:\n+      return \"@TLSLE\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* m68k implementation of OUTPUT_ADDR_CONST_EXTRA.  */\n \n bool\n m68k_output_addr_const_extra (FILE *file, rtx x)\n {\n-  if (GET_CODE (x) != UNSPEC || XINT (x, 1) != UNSPEC_GOTOFF)\n-    return false;\n+  if (GET_CODE (x) == UNSPEC)\n+    {\n+      switch (XINT (x, 1))\n+\t{\n+\tcase UNSPEC_RELOC16:\n+\tcase UNSPEC_RELOC32:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (m68k_get_reloc_decoration (INTVAL (XVECEXP (x, 0, 1))), file);\n+\t  return true;\n \n-  output_addr_const (file, XVECEXP (x, 0, 0));\n-  /* ??? What is the non-MOTOROLA syntax?  */\n-  fputs (\"@GOT\", file);\n-  return true;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* M68K implementation of TARGET_ASM_OUTPUT_DWARF_DTPREL.  */\n+\n+static void\n+m68k_output_dwarf_dtprel (FILE *file, int size, rtx x)\n+{\n+  gcc_assert (size == 4);\n+  fputs (\"\\t.long\\t\", file);\n+  output_addr_const (file, x);\n+  fputs (\"@TLSLDO+0x8000\", file);\n }\n \n \f\n@@ -4100,15 +4643,8 @@ print_operand_address (FILE *file, rtx addr)\n \t  else\n \t    {\n \t      if (address.offset)\n-\t\t{\n-\t\t  output_addr_const (file, address.offset);\n-\t\t  if (flag_pic && address.base == pic_offset_table_rtx)\n-\t\t    {\n-\t\t      fprintf (file, \"@GOT\");\n-\t\t      if (flag_pic == 1 && TARGET_68020)\n-\t\t\tfprintf (file, \".w\");\n-\t\t    }\n-\t\t}\n+\t\toutput_addr_const (file, address.offset);\n+\n \t      putc ('(', file);\n \t      if (address.base)\n \t\tfputs (M68K_REGNAME (REGNO (address.base)), file);\n@@ -4141,19 +4677,7 @@ print_operand_address (FILE *file, rtx addr)\n \t\t    fputs (M68K_REGNAME (REGNO (address.base)), file);\n \t\t  fprintf (file, \"@(\");\n \t\t  if (address.offset)\n-\t\t    {\n-\t\t      output_addr_const (file, address.offset);\n-\t\t      if (address.base == pic_offset_table_rtx && TARGET_68020)\n-\t\t\tswitch (flag_pic)\n-\t\t\t  {\n-\t\t\t  case 1:\n-\t\t\t    fprintf (file, \":w\"); break;\n-\t\t\t  case 2:\n-\t\t\t    fprintf (file, \":l\"); break;\n-\t\t\t  default:\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t    }\n+\t\t    output_addr_const (file, address.offset);\n \t\t}\n \t      /* Print the \",index\" component, if any.  */\n \t      if (address.index)\n@@ -4641,7 +5165,8 @@ m68k_libcall_value (enum machine_mode mode)\n   default:\n     break;\n   }\n-  return gen_rtx_REG (mode, D0_REG);\n+\n+  return gen_rtx_REG (mode, m68k_libcall_value_in_a0_p ? A0_REG : D0_REG);\n }\n \n rtx\n@@ -4907,9 +5432,8 @@ sched_attr_op_type (rtx insn, bool opx_p, bool address_p)\n \t  return OP_TYPE_IMM_L;\n \n \tdefault:\n-\t  if (GET_CODE (op) == SYMBOL_REF)\n-\t    /* ??? Just a guess.  Probably we can guess better using length\n-\t       attribute of the instructions.  */\n+\t  if (symbolic_operand (m68k_unwrap_symbol (op, false), VOIDmode))\n+\t    /* Just a guess.  */\n \t    return OP_TYPE_IMM_W;\n \n \t  return OP_TYPE_IMM_L;\n@@ -5854,3 +6378,5 @@ m68k_sched_indexed_address_bypass_p (rtx pro, rtx con)\n       return 0;\n     }\n }\n+\n+#include \"gt-m68k.h\""}, {"sha": "2d3b592eb8810e967b14709922129644a11762c5", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -750,7 +750,8 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \n #define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n   (!symbolic_operand (X, VOIDmode)\t\t\t\t\\\n-   || (TARGET_PCREL && REG_STRICT_P))\n+   || (TARGET_PCREL && REG_STRICT_P)\t\t\t\t\\\n+   || m68k_tls_reference_p (X, true))\n \n #define REG_OK_FOR_BASE_P(X) \\\n   m68k_legitimate_base_reg_p (X, REG_STRICT_P)\n@@ -967,6 +968,9 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n   assemble_name ((FILE), (NAME)),\t\t\\\n   fprintf ((FILE), \",%u\\n\", (int)(ROUNDED)))\n \n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n+  m68k_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+\n /* On the 68000, we use several CODE characters:\n    '.' for dot needed in Motorola-style opcode names.\n    '-' for an operand pushing on the stack:"}, {"sha": "037bb372cc996b38386012be0a6ec3a4b98b2de9", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -116,7 +116,8 @@\n    (UNSPEC_GOT 3)\n    (UNSPEC_IB 4)\n    (UNSPEC_TIE 5)\n-   (UNSPEC_GOTOFF 6)\n+   (UNSPEC_RELOC16 6)\n+   (UNSPEC_RELOC32 7)\n   ])\n \n ;; UNSPEC_VOLATILE usage:\n@@ -869,7 +870,41 @@\n {\n   rtx tmp, base, offset;\n \n-  if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))\n+  /* Recognize the case where operand[1] is a reference to thread-local\n+     data and load its address to a register.  */\n+  if (!TARGET_PCREL && m68k_tls_reference_p (operands[1], false))\n+    {\n+      rtx tmp = operands[1];\n+      rtx addend = NULL;\n+\n+      if (GET_CODE (tmp) == CONST && GET_CODE (XEXP (tmp, 0)) == PLUS)\n+        {\n+          addend = XEXP (XEXP (tmp, 0), 1);\n+          tmp = XEXP (XEXP (tmp, 0), 0);\n+        }\n+\n+      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);\n+      gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);\n+\n+      tmp = m68k_legitimize_tls_address (tmp);\n+\n+      if (addend)\n+        {\n+\t  if (!REG_P (tmp))\n+\t    {\n+\t      rtx reg;\n+\n+\t      reg = gen_reg_rtx (Pmode);\n+\t      emit_move_insn (reg, tmp);\n+\t      tmp = reg;\n+\t    }\n+\n+          tmp = gen_rtx_PLUS (SImode, tmp, addend);\n+\t}\n+\n+      operands[1] = tmp;\n+    }\n+  else if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))\n     {\n       /* The source is an address which requires PIC relocation.\n          Call legitimize_pic_address with the source, mode, and a relocation\n@@ -2428,9 +2463,9 @@\n   \"* return output_addsi3 (operands);\")\n \n (define_insn_and_split \"*addsi3_5200\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\"         \"=mr,mr,a,m,r,  ?a, ?a,?a,?a\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\"     \"%0, 0, 0,0,0,   a,  a, r, a\")\n-\t\t (match_operand:SI 2 \"general_src_operand\" \" I, L, J,d,mrKi,Cj, r, a, J\")))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\"         \"=mr,mr,a,  m,r,  ?a, ?a,?a,?a\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\"     \"%0, 0, 0,  0,0,   a,  a, r, a\")\n+\t\t (match_operand:SI 2 \"general_src_operand\" \" I, L, JCu,d,mrKi,Cj, r, a, JCu\")))]\n   \"TARGET_COLDFIRE\"\n {\n   switch (which_alternative)\n@@ -2472,9 +2507,9 @@\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n   \"\"\n-  [(set_attr \"type\" \"aluq_l,aluq_l,lea,alu_l,alu_l,*,lea,lea,lea\")\n-   (set_attr \"opy\" \"2,2,*,2,2,*,*,*,*\")\n-   (set_attr \"opy_type\" \"*,*,mem5,*,*,*,mem6,mem6,mem5\")])\n+  [(set_attr \"type\"     \"aluq_l,aluq_l,lea, alu_l,alu_l,*,lea, lea, lea\")\n+   (set_attr \"opy\"      \"2,     2,     *,   2,    2,    *,*,   *,   *\")\n+   (set_attr \"opy_type\" \"*,     *,     mem5,*,    *,    *,mem6,mem6,mem5\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=a\")"}, {"sha": "d5aa9fa769832b00cd7ba1f14b2473d09b855e89", "filename": "gcc/config/m68k/m68k.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fm68k.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.opt?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -182,3 +182,7 @@ Tune for the specified target CPU or architecture\n mxgot\n Target Report Mask(XGOT)\n Support more than 8192 GOT entries on ColdFire\n+\n+mxtls\n+Target Report Mask(XTLS)\n+Support TLS segment larger than 64K"}, {"sha": "6ca261fb92a2b7ecd53a0356d06410e2c0d70965", "filename": "gcc/config/m68k/predicates.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpredicates.md?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -135,7 +135,9 @@\n   (match_code \"sign_extend,zero_extend\"))\n \n ;; Returns true if OP is either a symbol reference or a sum of a\n-;; symbol reference and a constant.\n+;; symbol reference and a constant.  This predicate is for \"raw\"\n+;; symbol references not yet processed by legitimize*_address,\n+;; hence we do not handle UNSPEC_{XGOT, TLS, XTLS} here.\n \n (define_predicate \"symbolic_operand\"\n   (match_code \"symbol_ref,label_ref,const\")"}, {"sha": "4bab41d4a5e05c35663d81e76f8ae536a3a9891a", "filename": "gcc/configure", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -21984,6 +21984,22 @@ x:\n \ttls_first_minor=16\n \ttls_as_opt='-32 --fatal-warnings'\n \t;;\n+  m68k-*-*)\n+    conftest_s='\n+\t.section .tdata,\"awT\",@progbits\n+x:\n+\t.word 2\n+\t.text\n+foo:\n+\tmove.l x@TLSGD(%a5),%a0\n+\tmove.l x@TLSLDM(%a5),%a0\n+\tmove.l x@TLSLDO(%a5),%a0\n+\tmove.l x@TLSIE(%a5),%a0\n+\tmove.l x@TLSLE(%a5),%a0'\n+\ttls_first_major=2\n+\ttls_first_minor=19\n+\ttls_as_opt='--fatal-warnings'\n+\t;;\n   powerpc-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}, {"sha": "80f942268cdbbae45314e96e01ccc34583afc8c8", "filename": "gcc/configure.ac", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -2570,6 +2570,22 @@ x:\n \ttls_first_minor=16\n \ttls_as_opt='-32 --fatal-warnings'\n \t;;\n+  m68k-*-*)\n+    conftest_s='\n+\t.section .tdata,\"awT\",@progbits\n+x:\n+\t.word 2\n+\t.text\n+foo:\n+\tmove.l x@TLSGD(%a5),%a0\n+\tmove.l x@TLSLDM(%a5),%a0\n+\tmove.l x@TLSLDO(%a5),%a0\n+\tmove.l x@TLSIE(%a5),%a0\n+\tmove.l x@TLSLE(%a5),%a0'\n+\ttls_first_major=2\n+\ttls_first_minor=19\n+\ttls_as_opt='--fatal-warnings'\n+\t;;\n   powerpc-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}, {"sha": "994360be60b6467611cb106e5c1ba56c1feec63c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -1,3 +1,16 @@\n+2009-05-18  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* gcc.target/m68k/tls-ie.c: New test.\n+\t* gcc.target/m68k/tls-le.c: New test.\n+\t* gcc.target/m68k/tls-gd.c: New test.\n+\t* gcc.target/m68k/tls-ld.c: New test.\n+\t* gcc.target/m68k/tls-ie-xgot.c: New test.\n+\t* gcc.target/m68k/tls-le-xtls.c: New test.\n+\t* gcc.target/m68k/tls-gd-xgot.c: New test.\n+\t* gcc.target/m68k/tls-ld-xgot.c: New test.\n+\t* gcc.target/m68k/tls-ld-xtls.c: New test.\n+\t* gcc.target/m68k/tls-ld-xgot-xtls.c: New test.\n+\n 2009-05-18  Martin Jambor  <mjambor@suse.cz>\n \n \t* gcc.dg/ipa/modif-1.c: Do not check for unmodified int parameter."}, {"sha": "2a4900b5a08a91cd12c171cb9e265152816777d2", "filename": "gcc/testsuite/gcc.target/m68k/tls-gd-xgot.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-gd-xgot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-gd-xgot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-gd-xgot.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -fpic -mxgot\" } */\n+/* { dg-final { scan-assembler \"#foo@TLSGD,\\%\\[ad\\]\\[0-7\\]\" } } */\n+/* { dg-final { scan-assembler \"bsr.l __tls_get_addr@PLTPC\" } } */\n+\n+extern int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "2b69fbdc1b46b446c64fcc34566dba5dbeda7a87", "filename": "gcc/testsuite/gcc.target/m68k/tls-gd.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-gd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-gd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-gd.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -fpic\" } */\n+/* { dg-final { scan-assembler \"foo@TLSGD\\\\(\\%a5\\\\)\" } } */\n+/* { dg-final { scan-assembler \"bsr.l __tls_get_addr@PLTPC\" } } */\n+\n+extern int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "d3fbfdaa4b63e811056a4fce43be4691cac49e5c", "filename": "gcc/testsuite/gcc.target/m68k/tls-ie-xgot.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ie-xgot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ie-xgot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ie-xgot.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mxgot\" } */\n+/* { dg-final { scan-assembler \"jsr __m68k_read_tp\" } } */\n+/* { dg-final { scan-assembler \"#foo@TLSIE,\\%\\[ad\\]\\[0-7\\]\" } } */\n+\n+extern int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "2661f9fc0534b4ab39d2e58bb23b54bc29e9c7bb", "filename": "gcc/testsuite/gcc.target/m68k/tls-ie.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ie.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \"jsr __m68k_read_tp\" } } */\n+/* { dg-final { scan-assembler \"foo@TLSIE\\\\(\\%a5\\\\)\" } } */\n+\n+extern int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "4817de01d441734601d9cab7779ddb49cb5449b8", "filename": "gcc/testsuite/gcc.target/m68k/tls-ld-xgot-xtls.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xgot-xtls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xgot-xtls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xgot-xtls.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -fpic -mxgot -mxtls\" } */\n+/* { dg-final { scan-assembler \"#foo@TLSLDM,\\%\\[ad\\]\\[0-7\\]\" } } */\n+/* { dg-final { scan-assembler \"bsr.l __tls_get_addr@PLTPC\" } } */\n+/* { dg-final { scan-assembler \"#foo@TLSLDO,\\%\\[ad\\]\\[0-7\\]\" } } */\n+\n+static int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "f95f7192855f0574e763f941cc2e2cbc44355a44", "filename": "gcc/testsuite/gcc.target/m68k/tls-ld-xgot.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xgot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xgot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xgot.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -fpic -mxgot\" } */\n+/* { dg-final { scan-assembler \"#foo@TLSLDM,\\%\\[ad\\]\\[0-7\\]\" } } */\n+/* { dg-final { scan-assembler \"bsr.l __tls_get_addr@PLTPC\" } } */\n+/* { dg-final { scan-assembler \"lea \\\\(foo@TLSLDO,\\%a0\\\\)\" } } */\n+\n+static int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "1bc3eaf7de59a287122c847c5d0a50183de9ba8c", "filename": "gcc/testsuite/gcc.target/m68k/tls-ld-xtls.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xtls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xtls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld-xtls.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -fpic -mxtls\" } */\n+/* { dg-final { scan-assembler \"foo@TLSLDM\\\\(\\%a5\\\\)\" } } */\n+/* { dg-final { scan-assembler \"bsr.l __tls_get_addr@PLTPC\" } } */\n+/* { dg-final { scan-assembler \"#foo@TLSLDO,\\%\\[ad\\]\\[0-7\\]\" } } */\n+\n+static int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "556a11718ca0579bb97b7a910c6a117ab88562e3", "filename": "gcc/testsuite/gcc.target/m68k/tls-ld.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-ld.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -fpic\" } */\n+/* { dg-final { scan-assembler \"foo@TLSLDM\\\\(\\%a5\\\\)\" } } */\n+/* { dg-final { scan-assembler \"bsr.l __tls_get_addr@PLTPC\" } } */\n+/* { dg-final { scan-assembler \"lea \\\\(foo@TLSLDO,\\%a0\\\\)\" } } */\n+\n+static int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "90061153f89d47ffcc135401c2af2010de434b95", "filename": "gcc/testsuite/gcc.target/m68k/tls-le-xtls.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-le-xtls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-le-xtls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-le-xtls.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mxtls\" } */\n+/* { dg-final { scan-assembler \"jsr __m68k_read_tp\" } } */\n+/* { dg-final { scan-assembler \"#foo@TLSLE,\\%\\[ad\\]\\[0-7\\]\" } } */\n+\n+static int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}, {"sha": "1c0eab2388615127db9383185df56be68d4f723c", "filename": "gcc/testsuite/gcc.target/m68k/tls-le.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-le.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75df395f15f2641bfcae7f1179d3ef963771379c/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-le.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Ftls-le.c?ref=75df395f15f2641bfcae7f1179d3ef963771379c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { ! *-linux-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \"jsr __m68k_read_tp\" } } */\n+/* { dg-final { scan-assembler \"lea \\\\(foo@TLSLE,\\%a0\\\\)\" } } */\n+\n+static int __thread foo;\n+\n+int *\n+bar (void)\n+{\n+  return &foo;\n+}"}]}