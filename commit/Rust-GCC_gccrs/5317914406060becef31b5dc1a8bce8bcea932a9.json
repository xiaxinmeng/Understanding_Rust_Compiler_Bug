{"sha": "5317914406060becef31b5dc1a8bce8bcea932a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMxNzkxNDQwNjA2MGJlY2VmMzFiNWRjMWE4YmNlOGJjZWE5MzJhOQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2009-12-17T09:37:16Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-12-17T09:37:16Z"}, "message": "PR libstdc++/21772 part 2\n\n2009-12-16  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/21772 part 2\n\t* doc/xml/manual/test.xml: Add documentation about testing details.\n\t* testsuite/util/exception/safety.h: New. Functor objects for\n\ttesting C++0x container classes.\n\t* testsuite/util/testsuite_container_traits.h: Add traits.\n\n\t* testsuite/23_containers/list/requirements/exception/\n\tbasic.cc: New.\n\tgeneration_prohibited.cc: New.\n\tpropagation_consistent.cc: New.\n\nFrom-SVN: r155306", "tree": {"sha": "0c608f9406158852df879eef2fb019cab3cde860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c608f9406158852df879eef2fb019cab3cde860"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5317914406060becef31b5dc1a8bce8bcea932a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5317914406060becef31b5dc1a8bce8bcea932a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5317914406060becef31b5dc1a8bce8bcea932a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5317914406060becef31b5dc1a8bce8bcea932a9/comments", "author": null, "committer": null, "parents": [{"sha": "ccfd729622bed7e213dccdc07bbc60903e1ad65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccfd729622bed7e213dccdc07bbc60903e1ad65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccfd729622bed7e213dccdc07bbc60903e1ad65b"}], "stats": {"total": 1658, "additions": 1565, "deletions": 93}, "files": [{"sha": "bf7f50ec99da80d98bbcbdee8ae1481815ae527b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5317914406060becef31b5dc1a8bce8bcea932a9", "patch": "@@ -1,3 +1,16 @@\n+2009-12-16  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/21772 part 2\n+\t* doc/xml/manual/test.xml: Add documentation about testing details.\n+\t* testsuite/util/exception/safety.h: New. Functor objects for\n+\ttesting C++0x container classes.\n+\t* testsuite/util/testsuite_container_traits.h: Add traits.\n+\n+\t* testsuite/23_containers/list/requirements/exception/\n+\tbasic.cc: New.\n+\tgeneration_prohibited.cc: New.\n+\tpropagation_consistent.cc: New.\n+\n 2009-12-15  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/21772 part 1"}, {"sha": "3da168ec45bf9d7683e518ab24af7cf9ac804bb1", "filename": "libstdc++-v3/doc/xml/manual/test.xml", "status": "modified", "additions": 284, "deletions": 56, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Ftest.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Ftest.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Ftest.xml?ref=5317914406060becef31b5dc1a8bce8bcea932a9", "patch": "@@ -1,6 +1,6 @@\n <sect1 id=\"manual.intro.setup.test\" xreflabel=\"Testing\">\n <?dbhtml filename=\"test.html\"?>\n- \n+\n <sect1info>\n   <keywordset>\n     <keyword>\n@@ -48,7 +48,7 @@ regressions, ABI, and performance.\n   that are packaged in a separate testing library.\n </para>\n \n-<para> \n+<para>\n   All test cases for functionality required by the runtime components\n   of the C++ standard (ISO 14882) are files within the following\n   directories.\n@@ -65,6 +65,9 @@ regressions, ABI, and performance.\n 25_algorithms\n 26_numerics\n 27_io\n+28_regex\n+29_atomics\n+30_threads\n    </programlisting>\n \n    <para>\n@@ -77,9 +80,8 @@ backward\t  Tests for backwards compatibility and deprecated features.\n demangle\t  Tests for __cxa_demangle, the IA 64 C++ ABI demangler\n ext\t\t  Tests for extensions.\n performance\t  Tests for performance analysis, and performance regressions.\n-thread\t\t  Tests for threads.\n    </programlisting>\n-   \n+\n    <para>\n       Some directories don't have test files, but instead contain\n       auxiliary information:\n@@ -104,7 +106,7 @@ util\t\t  Files for libtestc++, utilities and testing routines.\n    </para>\n    <programlisting>\n 21_strings/find.cc\n-   </programlisting>   \n+   </programlisting>\n    <para>\n       However, that practice soon became a liability as the test cases\n       became huge and unwieldy, and testing new or extended\n@@ -123,11 +125,11 @@ util\t\t  Files for libtestc++, utilities and testing routines.\n 21_strings/basic_string/find/wchar_t/1.cc\n 21_strings/basic_string/find/wchar_t/2.cc\n 21_strings/basic_string/find/wchar_t/3.cc\n-   </programlisting>   \n+   </programlisting>\n \n    <para>\n       All new tests should be written with the policy of one test\n-      case, one file in mind. \n+      case, one file in mind.\n    </para>\n </sect3>\n \n@@ -140,7 +142,7 @@ util\t\t  Files for libtestc++, utilities and testing routines.\n       used within the testsuite to designate particular kinds of\n       tests.\n    </para>\n- \n+\n <itemizedlist>\n <listitem>\n   <para>\n@@ -151,10 +153,10 @@ util\t\t  Files for libtestc++, utilities and testing routines.\n       to finish or pass. At the moment, the interactive tests are not\n       run by default. Instead, they are run by hand, like:\n    </para>\n-      <programlisting> \n+      <programlisting>\n g++ 27_io/objects/char/3_xin.cc\n cat 27_io/objects/char/3_xin.in | a.out\n-     </programlisting> \n+     </programlisting>\n </listitem>\n <listitem>\n    <para>\n@@ -232,7 +234,7 @@ cat 27_io/objects/char/3_xin.in | a.out\n \n   <sect3 id=\"test.run.basic\">\n     <title>Basic</title>\n-   \n+\n     <para>\n       You can check the status of the build without installing it\n       using the dejagnu harness, much like the rest of the gcc\n@@ -254,7 +256,7 @@ cat 27_io/objects/char/3_xin.in | a.out\n        the exact command line passed to the compiler, the compiler\n        output, and the executable output (if any).\n      </para>\n-     \n+\n      <para>\n        Archives of test results for various versions and platforms are\n        available on the GCC website in the <ulink\n@@ -266,7 +268,7 @@ cat 27_io/objects/char/3_xin.in | a.out\n        combination of source version, operating system, and host CPU.\n      </para>\n   </sect3>\n-  \n+\n   <sect3 id=\"test.run.variations\">\n     <title>Variations</title>\n     <para>\n@@ -322,15 +324,15 @@ make check-target-libstdc++-v3 RUNTESTFLAGS=\"--target_board=calmrisc32-sid\"\n make check-target-libstdc++-v3 RUNTESTFLAGS=\"--target_board=arm-sim\"\n </programlisting>\n \n-    <para> \n+    <para>\n       Also, here is an example of how to run the libstdc++ testsuite\n       for a multilibed build directory with different ABI settings:\n     </para>\n \n  <programlisting>\n make check-target-libstdc++-v3 RUNTESTFLAGS='--target_board \\\"unix{-mabi=32,,-mabi=64}\\\"'\n </programlisting>\n- \n+\n     <para>\n       You can run the tests with a compiler and library that have\n       already been installed.  Make sure that the compiler (e.g.,\n@@ -354,7 +356,7 @@ runtest --tool libstdc++ --srcdir=/path/to/gcc/libstdc++-v3/testsuite\n       testsuites in parallel from the same directory.\n     </para>\n \n-    <para> \n+    <para>\n       In addition, there are some testing options that are mostly of\n       interest to library maintainers and system integrators. As such,\n       these tests may not work on all cpu and host combinations, and\n@@ -378,7 +380,7 @@ runtest --tool libstdc++ --srcdir=/path/to/gcc/libstdc++-v3/testsuite\n        <para>\n \t <emphasis>testsuite_files</emphasis>\n        </para>\n-       <para> \n+       <para>\n \t This is a list of all the test cases that will be run. Each\n \t test case is on a separate line, given with an absolute path\n \t from the <emphasis>libsrcdir/testsuite</emphasis> directory.\n@@ -389,7 +391,7 @@ runtest --tool libstdc++ --srcdir=/path/to/gcc/libstdc++-v3/testsuite\n        <para>\n \t <emphasis>testsuite_files_interactive</emphasis>\n        </para>\n-       <para> \n+       <para>\n \t This is a list of all the interactive test cases, using the\n \t same format as the file list above. These tests are not run\n \t by default.\n@@ -400,7 +402,7 @@ runtest --tool libstdc++ --srcdir=/path/to/gcc/libstdc++-v3/testsuite\n        <para>\n \t <emphasis>testsuite_files_performance</emphasis>\n        </para>\n-       <para> \n+       <para>\n \t This is a list of all the performance test cases, using the\n \t same format as the file list above. These tests are not run\n \t by default.\n@@ -411,7 +413,7 @@ runtest --tool libstdc++ --srcdir=/path/to/gcc/libstdc++-v3/testsuite\n        <para>\n \t <emphasis>testsuite_thread</emphasis>\n        </para>\n-       <para> \n+       <para>\n \t This file indicates that the host system can run tests which\n \t involved multiple threads.\n        </para>\n@@ -421,7 +423,7 @@ runtest --tool libstdc++ --srcdir=/path/to/gcc/libstdc++-v3/testsuite\n        <para>\n \t <emphasis>testsuite_wchar_t</emphasis>\n        </para>\n-       <para> \n+       <para>\n \t This file indicates that the host system can run the wchar_t\n \t tests, and corresponds to the macro definition <code>\n \t _GLIBCXX_USE_WCHAR_T</code> in the file c++config.h.\n@@ -432,11 +434,11 @@ runtest --tool libstdc++ --srcdir=/path/to/gcc/libstdc++-v3/testsuite\n    <programlisting>\n    make check-abi\n    </programlisting>\n-   \n+\n    <para>\n      The library ABI can be tested. This involves testing the shared\n      library against an ABI-defining previous version of symbol\n-     exports. \n+     exports.\n    </para>\n \n   <programlisting>\n@@ -507,7 +509,7 @@ runtest --tool libstdc++ --srcdir=/path/to/gcc/libstdc++-v3/testsuite\n    <para>\n     The first step in making a new test case is to choose the correct\n     directory and file name, given the organization as previously\n-    described. \n+    described.\n    </para>\n \n    <para>\n@@ -638,7 +640,7 @@ up in the normal.exp file.\n \n <sect3 id=\"test.harness.dejagnu\">\n <title>Dejagnu Harness Details</title>\n-  <para> \n+  <para>\n     Underlying details of testing for conformance and regressions are\n     abstracted via the GNU Dejagnu package. This is similar to the\n     rest of GCC.\n@@ -684,7 +686,7 @@ only default variables.\n \n <sect3 id=\"test.harness.utils\">\n <title>Utilities</title>\n-  <para> \n+  <para>\n   </para>\n   <para>\n    The testsuite directory also contains some files that implement\n@@ -709,11 +711,11 @@ only default variables.\n        <emphasis>testsuite_abi_check.cc</emphasis>\n        </para>\n        <para>\n-        Creates the executable <emphasis>abi_check</emphasis>.\n-        Used to check correctness of symbol versioning, visibility of\n-        exported symbols, and compatibility on symbols in the shared\n-        library, for hosts that support this feature. More information\n-        can be found in the ABI documentation <link linkend=\"appendix.porting.abi\">here</link>\n+\tCreates the executable <emphasis>abi_check</emphasis>.\n+\tUsed to check correctness of symbol versioning, visibility of\n+\texported symbols, and compatibility on symbols in the shared\n+\tlibrary, for hosts that support this feature. More information\n+\tcan be found in the ABI documentation <link linkend=\"appendix.porting.abi\">here</link>\n        </para>\n      </listitem>\n      <listitem>\n@@ -722,21 +724,21 @@ only default variables.\n        <emphasis>testsuite_allocator.cc</emphasis>\n        </para>\n        <para>\n-        Contains specialized allocators that keep track of construction\n-        and destruction. Also, support for overriding global new and\n-        delete operators, including verification that new and delete\n-        are called during execution, and that allocation over max_size\n-        fails.\n+\tContains specialized allocators that keep track of construction\n+\tand destruction. Also, support for overriding global new and\n+\tdelete operators, including verification that new and delete\n+\tare called during execution, and that allocation over max_size\n+\tfails.\n        </para>\n      </listitem>\n      <listitem>\n        <para>\n        <emphasis>testsuite_character.h</emphasis>\n        </para>\n        <para>\n-        Contains <code>std::char_traits</code> and\n-        <code>std::codecvt</code> specializations for a user-defined\n-        POD.\n+\tContains <code>std::char_traits</code> and\n+\t<code>std::codecvt</code> specializations for a user-defined\n+\tPOD.\n        </para>\n      </listitem>\n      <listitem>\n@@ -748,20 +750,20 @@ only default variables.\n        A large number of utilities, including:\n        </para>\n        <itemizedlist>\n-         <listitem><para>VERIFY</para></listitem>\n-         <listitem><para>set_memory_limits</para></listitem>\n-         <listitem><para>verify_demangle</para></listitem>\n-         <listitem><para>run_tests_wrapped_locale</para></listitem>\n-         <listitem><para>run_tests_wrapped_env</para></listitem>\n-         <listitem><para>try_named_locale</para></listitem>\n-         <listitem><para>try_mkfifo</para></listitem>\n-         <listitem><para>func_callback</para></listitem>\n-         <listitem><para>counter</para></listitem>\n-         <listitem><para>copy_tracker</para></listitem>\n-         <listitem><para>copy_constructor</para></listitem>\n-         <listitem><para>assignment_operator</para></listitem>\n-         <listitem><para>destructor</para></listitem>\n-         <listitem>\n+\t <listitem><para>VERIFY</para></listitem>\n+\t <listitem><para>set_memory_limits</para></listitem>\n+\t <listitem><para>verify_demangle</para></listitem>\n+\t <listitem><para>run_tests_wrapped_locale</para></listitem>\n+\t <listitem><para>run_tests_wrapped_env</para></listitem>\n+\t <listitem><para>try_named_locale</para></listitem>\n+\t <listitem><para>try_mkfifo</para></listitem>\n+\t <listitem><para>func_callback</para></listitem>\n+\t <listitem><para>counter</para></listitem>\n+\t <listitem><para>copy_tracker</para></listitem>\n+\t <listitem><para>copy_constructor</para></listitem>\n+\t <listitem><para>assignment_operator</para></listitem>\n+\t <listitem><para>destructor</para></listitem>\n+\t <listitem>\n \t <para>pod_char, pod_int and associated char_traits specializations</para>\n \t </listitem>\n        </itemizedlist>\n@@ -792,13 +794,239 @@ only default variables.\n        reporting functions including:\n        </para>\n       <itemizedlist>\n-         <listitem><para>time_counter</para></listitem>\n-         <listitem><para>resource_counter</para></listitem>\n-         <listitem><para>report_performance</para></listitem>\n+\t <listitem><para>time_counter</para></listitem>\n+\t <listitem><para>resource_counter</para></listitem>\n+\t <listitem><para>report_performance</para></listitem>\n       </itemizedlist>\n      </listitem>\n   </itemizedlist>\n </sect3>\n \n </sect2>\n+\n+<sect2 id=\"test.special\">\n+<title>Special Topics</title>\n+\n+<sect3 id=\"test.exception.safety\">\n+<title>\n+  Qualifying Exception Safety Guarantees\n+  <indexterm>\n+    <primary>Test</primary>\n+    <secondary>Exception Safety</secondary>\n+  </indexterm>\n+</title>\n+\n+<sect4 id=\"test.exception.safety.overview\">\n+<title>Overview</title>\n+\n+       <para>\n+\t Testing is composed of running a particular test sequence,\n+\t and looking at what happens to the surrounding code when\n+\t exceptions are thrown. Each test is composed of measuring\n+\t initial state, executing a particular sequence of code under\n+\t some instrumented conditions, measuring a final state, and\n+\t then examining the differences between the two states.\n+       </para>\n+\n+       <para>\n+\t Test sequences are composed of constructed code sequences\n+\t that exercise a particular function or member function, and\n+\t either confirm no exceptions were generated, or confirm the\n+\t consistency/coherency of the test subject in the event of a\n+\t thrown exception.\n+       </para>\n+\n+       <para>\n+\t Random code paths can be constructed using the the basic test\n+\t sequences and instrumentation as above, only combined in a\n+\t random or pseudo-random way.\n+       </para>\n+\n+       <para> To compute the code paths that throw, test instruments\n+\t are used that throw on allocation events\n+\t (<classname>__gnu_cxx::throw_allocator_random</classname>\n+\t and <classname>__gnu_cxx::throw_allocator_limit</classname>)\n+\t and copy, assignment, comparison, increment, swap, and\n+\t various operators\n+\t (<classname>__gnu_cxx::throw_type_random</classname>\n+\t and <classname>__gnu_cxx::throw_type_limit</classname>). Looping\n+\t through a given test sequence and conditionally throwing in\n+\t all instrumented places.  Then, when the test sequence\n+\t completes without an exception being thrown, assume all\n+\t potential error paths have been exercised in a sequential\n+\t manner.\n+       </para>\n+</sect4>\n+\n+\n+<sect4 id=\"test.exception.safety.status\">\n+<title>\n+    Existing tests\n+</title>\n+\n+  <itemizedlist>\n+     <listitem>\n+       <para>\n+\t Ad Hoc\n+       </para>\n+       <para>\n+\t For example,\n+\t <filename>testsuite/23_containers/list/modifiers/3.cc</filename>.\n+       </para>\n+     </listitem>\n+\n+     <listitem>\n+       <para>\n+\t Policy Based Data Structures\n+       </para>\n+       <para>\n+\t For example, take the test\n+\t functor <classname>rand_reg_test</classname> in\n+\t in <filename>testsuite/ext/pb_ds/regression/tree_no_data_map_rand.cc</filename>. This uses <classname>container_rand_regression_test</classname> in\n+<filename>testsuite/util/regression/rand/assoc/container_rand_regression_test.h</filename>.\n+\n+       </para>\n+\n+       <para>\n+\t Which has several tests for container member functions,\n+Includes control and test container objects. Configuration includes\n+random seed, iterations, number of distinct values, and the\n+probability that and exception will be thrown. Assumes instantiating\n+container uses an extension\n+allocator, <classname>__gnu_cxx::throw_allocator_random</classname>,\n+as the allocator type.\n+       </para>\n+     </listitem>\n+\n+     <listitem>\n+       <para>\n+\t C++0x Container Requirements.\n+       </para>\n+\n+       <para>\n+\t Coverage is currently limited to testing container\n+\t requirements for exception safety,\n+\t although <classname>__gnu_cxx::throw_type</classname> meets\n+\t the additional type requirements for testing numeric data\n+\t structures and instantiating algorithms.\n+       </para>\n+\n+       <para>\n+\t Of particular interest is extending testing to algorithms and\n+\t then to parallel algorithms. Also io, and locales.\n+       </para>\n+     </listitem>\n+  </itemizedlist>\n+</sect4>\n+\n+\n+<sect4 id=\"test.exception.safety.containers\">\n+<title>\n+C++0x Requirements Test Sequence Descriptions\n+</title>\n+\n+  <itemizedlist>\n+     <listitem>\n+       <para>\n+\t Basic\n+       </para>\n+\n+       <para>\n+\t Basic consistency on exception propagation tests. For\n+\t each container, an object of that container is constructed,\n+\t a specific member function is exercised in\n+\t a <literal>try</literal> block, and then any thrown\n+\t exceptions lead to error checking in the appropriate\n+\t <literal>catch</literal> block. The container's use of\n+\t resources is compared to the container's use prior to the\n+\t test block. Resource monitoring is limited to allocations\n+\t made through the container's <type>allocator_type</type>,\n+\t which should be sufficient for container data\n+\t structures. Included in these tests are member functions\n+\t are <type>iterator</type> and <type>const_iterator</type>\n+\t operations, <function>pop_front</function>, <function>pop_back</function>, <function>push_front</function>, <function>push_back</function>, <function>insert</function>, <function>erase</function>, <function>swap</function>, <function>clear</function>,\n+\t and <function>rehash</function>. The container in question is\n+\t instantiated with two instrumented template arguments,\n+\t with <classname>__gnu_cxx::throw_allocator_limit</classname>\n+\t as the allocator type, and\n+\t with <classname>__gnu_cxx::throw_type_limit</classname> as\n+\t the value type. This allows the test to loop through\n+\t conditional throw points.\n+       </para>\n+\n+     <para>\n+\t The general form is demonstrated in\n+\t <filename>testsuite/23_containers/list/requirements/exception/basic.cc\n+\t </filename>. The instantiating test object is <classname>__gnu_test::basic_safety</classname> and is detailed in <filename>testsuite/util/exception/safety.h</filename>.\n+       </para>\n+     </listitem>\n+\n+\n+     <listitem>\n+       <para>\n+\t Generation Prohibited\n+       </para>\n+\n+       <para>\n+\t Exception generation tests. For each container, an object of\n+\t that container is constructed and all member functions\n+\t required to not throw exceptions are exercised. Included in\n+\t these tests are member functions\n+\t are <type>iterator</type> and <type>const_iterator</type> operations, <function>erase</function>, <function>pop_front</function>, <function>pop_back</function>, <function>swap</function>,\n+\t and <function>clear</function>. The container in question is\n+\t instantiated with two instrumented template arguments,\n+\t with <classname>__gnu_cxx::throw_allocator_random</classname>\n+\t as the allocator type, and\n+\t with <classname>__gnu_cxx::throw_type_random</classname> as\n+\t the value type. This test does not loop, an instead is sudden\n+\t death: first error fails.\n+       </para>\n+       <para>\n+\t The general form is demonstrated in\n+\t <filename>testsuite/23_containers/list/requirements/exception/generation_prohibited.cc\n+\t </filename>. The instantiating test object is <classname>__gnu_test::generation_prohibited</classname> and is detailed in <filename>testsuite/util/exception/safety.h</filename>.\n+       </para>\n+     </listitem>\n+\n+\n+     <listitem>\n+       <para>\n+\t Propagation Consistent\n+       </para>\n+\n+       <para>\n+\t Container rollback on exception propagation tests. For\n+\t each container, an object of that container is constructed,\n+\t a specific member function that requires rollback to a previous\n+\t known good state is exercised in\n+\t a <literal>try</literal> block, and then any thrown\n+\t exceptions lead to error checking in the appropriate\n+\t <literal>catch</literal> block. The container is compared to\n+\t the container's last known good state using such parameters\n+\t as size, contents, and iterator references. Included in these\n+\t tests are member functions\n+\t are <function>push_front</function>, <function>push_back</function>, <function>insert</function>,\n+\t and <function>rehash</function>. The container in question is\n+\t instantiated with two instrumented template arguments,\n+\t with <classname>__gnu_cxx::throw_allocator_limit</classname>\n+\t as the allocator type, and\n+\t with <classname>__gnu_cxx::throw_type_limit</classname> as\n+\t the value type. This allows the test to loop through\n+\t conditional throw points.\n+       </para>\n+\n+       <para>\n+\t The general form demonstrated in\n+\t <filename>testsuite/23_containers/list/requirements/exception/propagation_coherent.cc\n+\t </filename>. The instantiating test object is <classname>__gnu_test::propagation_coherent</classname> and is detailed in <filename>testsuite/util/exception/safety.h</filename>.\n+       </para>\n+     </listitem>\n+  </itemizedlist>\n+\n+</sect4>\n+\n+</sect3>\n+\n+</sect2>\n+\n </sect1>"}, {"sha": "33232f965f6724ca237a2efdf66114614184401f", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/exception/basic.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fbasic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fbasic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fbasic.cc?ref=5317914406060becef31b5dc1a8bce8bcea932a9", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-cstdint \"\" }\n+\n+// 2009-11-30  Benjamin Kosnik  <benjamin@redhat.com>\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <list>\n+#include <exception/safety.h>\n+\n+void\n+value()\n+{\n+  typedef __gnu_cxx::throw_value_limit value_type;\n+  typedef __gnu_cxx::throw_allocator_limit<value_type> allocator_type;\n+  typedef std::list<value_type, allocator_type> test_type;\n+  __gnu_test::basic_safety<test_type> test;\n+}\n+\n+// Container requirement testing, exceptional behavior\n+int main()\n+{\n+  value();\n+  return 0;\n+}"}, {"sha": "f3d16028e2a30c7c59b81a63b0f9076942ac8b2f", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/exception/generation_prohibited.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fgeneration_prohibited.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fgeneration_prohibited.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fgeneration_prohibited.cc?ref=5317914406060becef31b5dc1a8bce8bcea932a9", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-cstdint \"\" }\n+\n+// 2009-09-09  Benjamin Kosnik  <benjamin@redhat.com>\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <list>\n+#include <exception/safety.h>\n+\n+// Container requirement testing, exceptional behavior\n+int main()\n+{\n+  typedef __gnu_cxx::throw_value_random value_type;\n+  typedef __gnu_cxx::throw_allocator_random<value_type> allocator_type;\n+  typedef std::list<value_type, allocator_type> test_type;\n+  __gnu_test::generation_prohibited<test_type> test;\n+  return 0;\n+}"}, {"sha": "02d8d0b254f110489fe00347b0386047ab04a2da", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/exception/propagation_consistent.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fpropagation_consistent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fpropagation_consistent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fexception%2Fpropagation_consistent.cc?ref=5317914406060becef31b5dc1a8bce8bcea932a9", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-cstdint \"\" }\n+\n+// 2009-09-09  Benjamin Kosnik  <benjamin@redhat.com>\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <list>\n+#include <exception/safety.h>\n+\n+// Container requirement testing, exceptional behavior\n+int main()\n+{\n+  typedef __gnu_cxx::throw_value_limit value_type;\n+  typedef __gnu_cxx::throw_allocator_limit<value_type> allocator_type;\n+  typedef std::list<value_type, allocator_type> test_type;\n+  __gnu_test::propagation_consistent<test_type> test;\n+  return 0;\n+}"}, {"sha": "ce9dad4f7ba6aca1319d914214840aa58084cb6b", "filename": "libstdc++-v3/testsuite/util/exception/safety.h", "status": "added", "additions": 1066, "deletions": 0, "changes": 1066, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h?ref=5317914406060becef31b5dc1a8bce8bcea932a9", "patch": "@@ -0,0 +1,1066 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _GLIBCXX_EXCEPTION_SAFETY_H\n+#define _GLIBCXX_EXCEPTION_SAFETY_H\n+\n+#include <testsuite_container_traits.h>\n+#include <ext/throw_allocator.h>\n+\n+// Container requirement testing.\n+namespace __gnu_test\n+{\n+  // Base class for exception testing, contains utilities.\n+  struct setup_base\n+  {\n+    typedef std::size_t \t\t\t\tsize_type;\n+    typedef std::uniform_int_distribution<size_type> \tdistribution_type;\n+    typedef std::mt19937 \t\t\t\tengine_type;\n+\n+    // Return randomly generated integer on range [0, __max_size].\n+    static size_type\n+    generate(size_type __max_size)\n+    {\n+      // Make the generator static...\n+      const engine_type engine;\n+      const distribution_type distribution;\n+      static auto generator = std::bind(distribution, engine,\n+\t\t\t\t\tstd::placeholders::_1);\n+\n+      // ... but set the range for this particular invocation here.\n+      const typename distribution_type::param_type p(0, __max_size);\n+      size_type random = generator(p);\n+      if (random < distribution.min() || random > distribution.max())\n+\t{\n+\t  std::string __s(\"setup_base::generate\");\n+\t  __s += \"\\n\";\n+\t  __s += \"random number generated is: \";\n+\t  char buf[40];\n+\t  __builtin_sprintf(buf, \"%lu\", random);\n+\t  __s += buf;\n+\t  __s += \" on range [\";\n+\t  __builtin_sprintf(buf, \"%lu\", distribution.min());\n+\t  __s += buf;\n+\t  __s += \", \";\n+\t  __builtin_sprintf(buf, \"%lu\", distribution.max());\n+\t  __s += buf;\n+\t  __s += \"]\\n\";\n+\t  std::__throw_out_of_range(__s.c_str());\n+\t}\n+      return random;\n+    }\n+\n+    // Given an instantiating type, return a unique value.\n+    template<typename _Tp>\n+      struct generate_unique\n+      {\n+\ttypedef _Tp value_type;\n+\n+\toperator value_type()\n+\t{\n+\t  static value_type __ret;\n+\t  ++__ret;\n+\t  return __ret;\n+\t}\n+      };\n+\n+    // Partial specialization for pair.\n+    template<typename _Tp1, typename _Tp2>\n+      struct generate_unique<std::pair<const _Tp1, _Tp2>>\n+      {\n+\ttypedef _Tp1 first_type;\n+\ttypedef _Tp2 second_type;\n+\ttypedef std::pair<const _Tp1, _Tp2> pair_type;\n+\n+\toperator pair_type()\n+\t{\n+\t  static first_type _S_1;\n+\t  static second_type _S_2;\n+\t  ++_S_1;\n+\t  ++_S_2;\n+\t  return pair_type(_S_1, _S_2);\n+\t}\n+      };\n+\n+    // Partial specialization for throw_value\n+    template<typename _Cond>\n+      struct generate_unique<__gnu_cxx::throw_value_base<_Cond>>\n+      {\n+\ttypedef __gnu_cxx::throw_value_base<_Cond> value_type;\n+\n+\toperator value_type()\n+\t{\n+\t  static size_t _S_i(0);\n+\t  return value_type(_S_i++);\n+\t}\n+      };\n+\n+\n+    // Construct container of size n directly. _Tp == container type.\n+    template<typename _Tp>\n+      struct make_container_base\n+      {\n+\t_Tp _M_container;\n+\n+\tmake_container_base() = default;\n+\tmake_container_base(const size_type n): _M_container(n) { }\n+\n+\toperator _Tp&() { return _M_container; }\n+      };\n+\n+    // Construct container of size n, via multiple insertions. For\n+    // associated and unordered types, unique value_type elements are\n+    // necessary.\n+    template<typename _Tp, bool = traits<_Tp>::is_mapped::value>\n+      struct make_insert_container_base\n+      : public make_container_base<_Tp>\n+      {\n+\tusing make_container_base<_Tp>::_M_container;\n+\ttypedef typename _Tp::value_type value_type;\n+\n+\tmake_insert_container_base(const size_type n)\n+\t{\n+\t  for (size_type i = 0; i < n; ++i)\n+\t    {\n+\t      value_type v = generate_unique<value_type>();\n+\t      _M_container.insert(v);\n+\t    }\n+\t  assert(_M_container.size() == n);\n+\t}\n+      };\n+\n+    template<typename _Tp>\n+      struct make_insert_container_base<_Tp, false>\n+      : public make_container_base<_Tp>\n+      {\n+\tusing make_container_base<_Tp>::_M_container;\n+\ttypedef typename _Tp::value_type value_type;\n+\n+\tmake_insert_container_base(const size_type n)\n+\t{\n+\t  for (size_type i = 0; i < n; ++i)\n+\t    {\n+\t      value_type v = generate_unique<value_type>();\n+\t      _M_container.insert(_M_container.end(), v);\n+\t    }\n+\t  assert(_M_container.size() == n);\n+\t}\n+      };\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_size_type_constructor::value>\n+      struct make_container_n;\n+\n+    // Specialization for non-associative types that have a constructor with\n+    // a size argument.\n+    template<typename _Tp>\n+      struct make_container_n<_Tp, true>\n+      : public make_container_base<_Tp>\n+      {\n+\tmake_container_n(const size_type n) : make_container_base<_Tp>(n) { }\n+      };\n+\n+    template<typename _Tp>\n+      struct make_container_n<_Tp, false>\n+      : public make_insert_container_base<_Tp>\n+      {\n+\tmake_container_n(const size_type n)\n+\t: make_insert_container_base<_Tp>(n) { }\n+      };\n+\n+\n+    // Randomly size and populate a given container reference.\n+    // NB: Responsibility for turning off exceptions lies with caller.\n+    template<typename _Tp, bool = traits<_Tp>::is_allocator_aware::value>\n+      struct populate\n+      {\n+\ttypedef _Tp \t\t\t\t\tcontainer_type;\n+\ttypedef typename container_type::allocator_type\tallocator_type;\n+\ttypedef typename container_type::value_type    \tvalue_type;\n+\n+\tpopulate(_Tp& __container)\n+\t{\n+\t  const allocator_type a = __container.get_allocator();\n+\n+\t  // Size test container.\n+\t  const size_type max_elements = 100;\n+\t  size_type n = generate(max_elements);\n+\n+\t  // Construct new container.\n+\t  make_container_n<container_type> made(n);\n+\t  container_type& tmp = made;\n+\t  std::swap(tmp, __container);\n+\t}\n+      };\n+\n+    // Partial specialization, empty.\n+    template<typename _Tp>\n+      struct populate<_Tp, false>\n+      {\n+\tpopulate(_Tp&) { }\n+      };\n+\n+    // Compare two containers for equivalence.\n+    // Right now, that means size.\n+    // Returns true if equal, throws if not.\n+    template<typename _Tp>\n+      static bool\n+      compare(const _Tp& __control, const _Tp& __test)\n+      {\n+\t// Make sure test container is in a consistent state, as\n+\t// compared to the control container.\n+\t// NB: Should be equivalent to __test != __control, but\n+\t// computed without equivalence operators\n+\tconst size_type szt = std::distance(__test.begin(), __test.end());\n+\tconst size_type szc = std::distance(__control.begin(),\n+\t\t\t\t\t    __control.end());\n+\tbool __equal_size = szt == szc;\n+\n+\t// Should test iterator validity before and after exception.\n+\tbool __equal_it = std::equal(__test.begin(), __test.end(),\n+\t\t\t\t     __control.begin());\n+\n+\tif (!__equal_size || !__equal_it)\n+\t  throw std::logic_error(\"setup_base::compare containers not equal\");\n+\n+\treturn true;\n+      }\n+  };\n+\n+\n+  // Containing structure holding functors.\n+  struct functor_base : public setup_base\n+  {\n+    // Abstract the erase function.\n+    template<typename _Tp>\n+      struct erase_base\n+      {\n+\ttypedef typename _Tp::iterator \t\t\titerator;\n+\n+\titerator (_Tp::* _F_erase_point)(iterator);\n+\titerator (_Tp::* _F_erase_range)(iterator, iterator);\n+\n+\terase_base()\n+\t: _F_erase_point(&_Tp::erase), _F_erase_range(&_Tp::erase) { }\n+      };\n+\n+    // Specialization, as forward_list has erase_after.\n+    template<typename _Tp1, typename _Tp2>\n+      struct erase_base<std::forward_list<_Tp1, _Tp2>>\n+      {\n+\ttypedef std::forward_list<_Tp1, _Tp2> \t\tcontainer_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator \tconst_iterator;\n+\n+\tvoid (container_type::* _F_erase_point)(const_iterator);\n+\tvoid (container_type::* _F_erase_range)(const_iterator, const_iterator);\n+\n+\terase_base()\n+\t: _F_erase_point(&container_type::erase_after),\n+\t  _F_erase_range(&container_type::erase_after) { }\n+      };\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_erase::value>\n+      struct erase_point : public erase_base<_Tp>\n+      {\n+\tusing erase_base<_Tp>::_F_erase_point;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      // NB: Should be equivalent to size() member function, but\n+\t      // computed with begin() and end().\n+\t      const size_type sz = std::distance(__container.begin(),\n+\t\t\t\t\t\t __container.end());\n+\n+\t      // NB: Lowest common denominator: use forward iterator operations.\n+\t      auto i = __container.begin();\n+\t      std::advance(i, generate(sz));\n+\n+\t      // Makes it easier to think of this as __container.erase(i)\n+\t      (__container.*_F_erase_point)(i);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct erase_point<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_erase::value>\n+      struct erase_range : public erase_base<_Tp>\n+      {\n+\tusing erase_base<_Tp>::_F_erase_range;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      const size_type sz = std::distance(__container.begin(),\n+\t\t\t\t\t\t __container.end());\n+\t      size_type s1 = generate(sz);\n+\t      size_type s2 = generate(sz);\n+\t      auto i1 = __container.begin();\n+\t      auto i2 = __container.begin();\n+\t      std::advance(i1, std::min(s1, s2));\n+\t      std::advance(i2, std::max(s1, s2));\n+\n+\t      // Makes it easier to think of this as __container.erase(i1, i2).\n+\t      (__container.*_F_erase_range)(i1, i2);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct erase_range<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_push_pop::value>\n+      struct pop_front\n+      {\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      __container.pop_front();\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct pop_front<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_push_pop::value\n+\t\t\t\t  && traits<_Tp>::is_reversible::value>\n+      struct pop_back\n+      {\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      __container.pop_back();\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct pop_back<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_push_pop::value>\n+      struct push_front\n+      {\n+\ttypedef _Tp \t\t\t\t\tcontainer_type;\n+\ttypedef typename container_type::value_type    \tvalue_type;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.push_front(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.push_front(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+    };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct push_front<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+\n+\tvoid\n+\toperator()(_Tp&, _Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_push_pop::value\n+\t\t\t\t  && traits<_Tp>::is_reversible::value>\n+      struct push_back\n+      {\n+\ttypedef _Tp \t\t\t\t\tcontainer_type;\n+\ttypedef typename container_type::value_type    \tvalue_type;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.push_back(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.push_back(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+    };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct push_back<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+\n+\tvoid\n+\toperator()(_Tp&, _Tp&) { }\n+      };\n+\n+\n+    // Abstract the insert function into two parts:\n+    // 1, insert_base_functions == holds function pointer\n+    // 2, insert_base == links function pointer to class insert method\n+    template<typename _Tp>\n+      struct insert_base\n+      {\n+\ttypedef typename _Tp::iterator \t\t\titerator;\n+\ttypedef typename _Tp::value_type \t\tvalue_type;\n+\n+\titerator (_Tp::* _F_insert_point)(iterator, const value_type&);\n+\n+\tinsert_base() : _F_insert_point(&_Tp::insert) { }\n+      };\n+\n+    // Specialization, as string insertion has a different signature.\n+    template<typename _Tp1, typename _Tp2, typename _Tp3>\n+      struct insert_base<std::basic_string<_Tp1, _Tp2, _Tp3>>\n+      {\n+\ttypedef std::basic_string<_Tp1, _Tp2, _Tp3> \tcontainer_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\titerator (container_type::* _F_insert_point)(iterator, value_type);\n+\n+\tinsert_base() : _F_insert_point(&container_type::insert) { }\n+      };\n+\n+    template<typename _Tp1, typename _Tp2, typename _Tp3>\n+      struct insert_base<__gnu_cxx::__versa_string<_Tp1, _Tp2, _Tp3>>\n+      {\n+\ttypedef __gnu_cxx::__versa_string<_Tp1, _Tp2, _Tp3> container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\titerator (container_type::* _F_insert_point)(iterator, value_type);\n+\n+\tinsert_base() : _F_insert_point(&container_type::insert) { }\n+      };\n+\n+    // Specialization, as forward_list insertion has a different signature.\n+    template<typename _Tp1, typename _Tp2>\n+      struct insert_base<std::forward_list<_Tp1, _Tp2>>\n+      {\n+\ttypedef std::forward_list<_Tp1, _Tp2> container_type;\n+\ttypedef typename container_type::iterator \titerator;\n+\ttypedef typename container_type::const_iterator \tconst_iterator;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\titerator (container_type::* _F_insert_point)(const_iterator,\n+\t\t\t\t\t\t   const value_type&);\n+\n+\tinsert_base() : _F_insert_point(&container_type::insert_after) { }\n+      };\n+\n+    template<typename _Tp, bool = traits<_Tp>::has_insert::value>\n+      struct insert_point : public insert_base<_Tp>\n+      {\n+\ttypedef _Tp \t\t\t\t       \tcontainer_type;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\tusing insert_base<_Tp>::_F_insert_point;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.begin();\n+\t      std::advance(i, s);\n+\t      (__test.*_F_insert_point)(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.begin();\n+\t      std::advance(i, s);\n+\t      (__test.*_F_insert_point)(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+ \t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct insert_point<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+\n+\tvoid\n+\toperator()(_Tp&, _Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp, bool = traits<_Tp>::is_associative::value\n+\t\t\t\t  || traits<_Tp>::is_unordered::value>\n+      struct clear\n+      {\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      __container.clear();\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct clear<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp, bool = traits<_Tp>::is_unordered::value>\n+      struct rehash\n+      {\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      size_type s = generate(__test.bucket_count());\n+\t      __test.rehash(s);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      size_type s = generate(__test.bucket_count());\n+\t      __test.rehash(s);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    {\n+\t      // Also check hash status.\n+\t      bool fail(false);\n+\t      if (__control.load_factor() != __test.load_factor())\n+\t\tfail = true;\n+\t      if (__control.max_load_factor() != __test.max_load_factor())\n+\t\tfail = true;\n+\t      if (__control.bucket_count() != __test.bucket_count())\n+\t\tfail = true;\n+\t      if (__control.max_bucket_count() != __test.max_bucket_count())\n+\t\tfail = true;\n+\n+\t      if (fail)\n+\t\t{\n+\t\t  char buf[40];\n+\t\t  std::string __s(\"setup_base::rehash \"\n+\t\t\t\t  \"containers not equal\");\n+\t\t  __s += \"\\n\";\n+\t\t  __s += \"\\n\";\n+\t\t  __s += \"\\t\\t\\tcontrol : test\";\n+\t\t  __s += \"\\n\";\n+\t\t  __s += \"load_factor\\t\\t\";\n+\t\t  __builtin_sprintf(buf, \"%lu\", __control.load_factor());\n+\t\t  __s += buf;\n+\t\t  __s += \" : \";\n+\t\t  __builtin_sprintf(buf, \"%lu\", __test.load_factor());\n+\t\t  __s += buf;\n+\t\t  __s += \"\\n\";\n+\n+\t\t  __s += \"max_load_factor\\t\\t\";\n+\t\t  __builtin_sprintf(buf, \"%lu\", __control.max_load_factor());\n+\t\t  __s += buf;\n+\t\t  __s += \" : \";\n+\t\t  __builtin_sprintf(buf, \"%lu\", __test.max_load_factor());\n+\t\t  __s += buf;\n+\t\t  __s += \"\\n\";\n+\n+\t\t  __s += \"bucket_count\\t\\t\";\n+\t\t  __builtin_sprintf(buf, \"%lu\", __control.bucket_count());\n+\t\t  __s += buf;\n+\t\t  __s += \" : \";\n+\t\t  __builtin_sprintf(buf, \"%lu\", __test.bucket_count());\n+\t\t  __s += buf;\n+\t\t  __s += \"\\n\";\n+\n+\t\t  __s += \"max_bucket_count\\t\";\n+\t\t  __builtin_sprintf(buf, \"%lu\", __control.max_bucket_count());\n+\t\t  __s += buf;\n+\t\t  __s += \" : \";\n+\t\t  __builtin_sprintf(buf, \"%lu\", __test.max_bucket_count());\n+\t\t  __s += buf;\n+\t\t  __s += \"\\n\";\n+\n+\t\t  std::__throw_logic_error(__s.c_str());\n+\t\t}\n+\t    }\n+ \t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct rehash<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+\n+\tvoid\n+\toperator()(_Tp&, _Tp&) { }\n+      };\n+\n+\n+    template<typename _Tp>\n+      struct swap\n+      {\n+\t_Tp _M_other;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      __container.swap(_M_other);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n+\n+    template<typename _Tp>\n+      struct iterator_operations\n+      {\n+\ttypedef _Tp \t\t\t\t\tcontainer_type;\n+\ttypedef typename container_type::iterator       iterator;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      // Any will do.\n+\t      iterator i = __container.begin();\n+\t      iterator __attribute__((unused)) icopy(i);\n+\t      iterator __attribute__((unused)) iassign = i;\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n+\n+    template<typename _Tp>\n+      struct const_iterator_operations\n+      {\n+\ttypedef _Tp \t\t\t\t\tcontainer_type;\n+\ttypedef typename container_type::const_iterator\tconst_iterator;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      // Any will do.\n+\t      const_iterator i = __container.begin();\n+\t      const_iterator __attribute__((unused)) icopy(i);\n+\t      const_iterator __attribute__((unused)) iassign = i;\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+  };\n+\n+  // Base class for exception tests.\n+  template<typename _Tp>\n+    struct test_base: public functor_base\n+    {\n+      typedef _Tp \t\t\t\t\tcontainer_type;\n+\n+      typedef functor_base\t\t\t\tbase_type;\n+      typedef populate<container_type> \t       \t\tpopulate;\n+      typedef make_container_n<container_type> \t       \tmake_container_n;\n+\n+      typedef clear<container_type> \t\t       \tclear;\n+      typedef erase_point<container_type> \t       \terase_point;\n+      typedef erase_range<container_type> \t       \terase_range;\n+      typedef insert_point<container_type> \t       \tinsert_point;\n+      typedef pop_front<container_type> \t       \tpop_front;\n+      typedef pop_back<container_type> \t\t\tpop_back;\n+      typedef push_front<container_type> \t       \tpush_front;\n+      typedef push_back<container_type> \t       \tpush_back;\n+      typedef rehash<container_type> \t\t\trehash;\n+      typedef swap<container_type> \t\t\tswap;\n+      typedef iterator_operations<container_type>\titerator_ops;\n+      typedef const_iterator_operations<container_type>\tconst_iterator_ops;\n+\n+      using base_type::compare;\n+\n+      // Functor objects.\n+      clear\t\t\t_M_clear;\n+      erase_point\t\t_M_erasep;\n+      erase_range\t\t_M_eraser;\n+      insert_point\t\t_M_insertp;\n+      pop_front\t\t\t_M_popf;\n+      pop_back\t\t\t_M_popb;\n+      push_front\t       \t_M_pushf;\n+      push_back\t\t\t_M_pushb;\n+      rehash\t\t\t_M_rehash;\n+      swap\t\t\t_M_swap;\n+\n+      iterator_ops\t       \t_M_iops;\n+      const_iterator_ops\t_M_ciops;\n+    };\n+\n+\n+  // Run through all member functions for basic exception safety\n+  // guarantee: no resource leaks when exceptions are thrown.\n+  //\n+  // Types of resources checked: memory.\n+  //\n+  // For each member function, use throw_value and throw_allocator as\n+  // value_type and allocator_type to force potential exception safety\n+  // errors.\n+  //\n+  // NB: Assumes\n+  // _Tp::value_type is __gnu_cxx::throw_value_*\n+  // _Tp::allocator_type is __gnu_cxx::throw_allocator_*\n+  // And that the _Cond template parameter for them both is\n+  // __gnu_cxx::limit_condition.\n+  template<typename _Tp>\n+    struct basic_safety : public test_base<_Tp>\n+    {\n+      typedef _Tp \t\t\t\t\tcontainer_type;\n+      typedef test_base<container_type>\t\t\tbase_type;\n+      typedef typename base_type::populate \t\tpopulate;\n+      typedef std::function<void(container_type&)> \tfunction_type;\n+      typedef __gnu_cxx::limit_condition\t\tcondition_type;\n+\n+      using base_type::generate;\n+\n+      container_type \t\t\t\t\t_M_container;\n+      std::vector<function_type>\t\t\t_M_functions;\n+\n+      basic_safety() { run(); }\n+\n+      void\n+      run()\n+      {\n+\t// Setup.\n+\tcondition_type::never_adjustor off;\n+\t\n+\t// Construct containers.\n+\tpopulate p1(_M_container);\n+\tpopulate p2(base_type::_M_swap._M_other);\n+\t\n+\t// Construct list of member functions to exercise.\n+\t_M_functions.push_back(function_type(base_type::_M_iops));\n+\t_M_functions.push_back(function_type(base_type::_M_ciops));\n+\t\n+\t_M_functions.push_back(function_type(base_type::_M_erasep));\n+\t_M_functions.push_back(function_type(base_type::_M_eraser));\n+\t_M_functions.push_back(function_type(base_type::_M_insertp));\n+\t_M_functions.push_back(function_type(base_type::_M_popf));\n+\t_M_functions.push_back(function_type(base_type::_M_popb));\n+\t_M_functions.push_back(function_type(base_type::_M_pushf));\n+\t_M_functions.push_back(function_type(base_type::_M_pushb));\n+\t_M_functions.push_back(function_type(base_type::_M_rehash));\n+\t_M_functions.push_back(function_type(base_type::_M_swap));\n+\t\n+\t// Last.\n+\t_M_functions.push_back(function_type(base_type::_M_clear));\n+\n+\t// Run tests.\n+\tauto i = _M_functions.begin();\n+\tfor (auto i = _M_functions.begin(); i != _M_functions.end(); ++i)\n+\t  {\n+\t    function_type& f = *i;\n+\t    run_steps_to_limit(f);\n+\t  }\n+      }\n+\n+      template<typename _Funct>\n+\tvoid\n+\trun_steps_to_limit(const _Funct& __f)\n+\t{\n+\t  size_t i(1);\n+\t  bool exit(false);\n+\t  auto a = _M_container.get_allocator();\n+\n+\t  do\n+\t    {\n+\t      // Use the current step as an allocator label.\n+\t      a.set_label(i);\n+\n+\t      try\n+\t\t{\n+\t\t  condition_type::limit_adjustor limit(i);\n+\t\t  __f(_M_container);\n+\n+\t\t  // If we get here, done.\n+\t\t  exit = true;\n+\t\t}\n+\t      catch(const __gnu_cxx::forced_error&)\n+\t\t{\n+\t\t  // Check this step for allocations.\n+\t\t  // NB: Will throw std::logic_error if allocations.\n+\t\t  a.check_allocated(i);\n+\n+\t\t  // Check memory allocated with operator new.\n+\n+\t\t  ++i;\n+\t\t}\n+\t    }\n+\t  while (!exit);\n+\n+\t  // Log count info.\n+\t  std::cout << __f.target_type().name() << std::endl;\n+\t  std::cout << \"end count \" << i << std::endl;\n+\t}\n+  };\n+\n+\n+  // Run through all member functions with a no throw requirement, sudden death.\n+  // all: member functions erase, pop_back, pop_front, swap\n+  //      iterator copy ctor, assignment operator\n+  // unordered and associative: clear\n+  // NB: Assumes _Tp::allocator_type is __gnu_cxx::throw_allocator_random.\n+  template<typename _Tp>\n+    struct generation_prohibited : public test_base<_Tp>\n+    {\n+      typedef _Tp \t\t\t\t\tcontainer_type;\n+      typedef test_base<container_type>\t\t\tbase_type;\n+      typedef typename base_type::populate \t\tpopulate;\n+      typedef __gnu_cxx::random_condition\t\tcondition_type;\n+\n+      container_type \t\t\t\t\t_M_container;\n+\n+      generation_prohibited()  { run(); }\n+\n+      void\n+      run()\n+      {\n+\t// Furthermore, assumes that the test functor will throw\n+\t// forced_exception via throw_allocator, that all errors are\n+\t// propagated and in error. Sudden death!\n+\n+\t// Setup.\n+\t{\n+\t  condition_type::never_adjustor off;\n+\t  populate p1(_M_container);\n+\t  populate p2(base_type::_M_swap._M_other);\n+\t}\n+\n+\t// Run tests.\n+\t{\n+\t  condition_type::always_adjustor on;\n+\n+\t  _M_erasep(_M_container);\n+\t  _M_eraser(_M_container);\n+\n+\t  _M_popf(_M_container);\n+\t  _M_popb(_M_container);\n+\n+\t  _M_iops(_M_container);\n+\t  _M_ciops(_M_container);\n+\n+\t  _M_swap(_M_container);\n+\n+\t  // Last.\n+\t  _M_clear(_M_container);\n+\t}\n+      }\n+    };\n+\n+\n+  // Test strong exception guarantee.\n+  // Run through all member functions with a roll-back, consistent\n+  // coherent requirement.\n+  // all: member functions insert of a single element, push_back, push_front\n+  // unordered: rehash\n+  template<typename _Tp>\n+    struct propagation_consistent : public test_base<_Tp>\n+    {\n+      typedef _Tp \t\t\t\t\tcontainer_type;\n+      typedef test_base<container_type>\t\t\tbase_type;\n+      typedef typename base_type::populate \t\tpopulate;\n+      typedef std::function<void(container_type&)> \tfunction_type;\n+      typedef __gnu_cxx::limit_condition\t\tcondition_type;\n+\n+      using base_type::compare;\n+\n+      container_type \t\t\t\t\t_M_container_test;\n+      container_type \t\t\t\t\t_M_container_control;\n+      std::vector<function_type>\t\t\t_M_functions;\n+\n+      propagation_consistent() { run(); }\n+\n+      void\n+      sync()\n+      { _M_container_test = _M_container_control; }\n+\n+      // Run test.\n+      void\n+      run()\n+      {\n+\t// Setup.\n+\tcondition_type::never_adjustor off;\n+\n+\t// Construct containers.\n+\tpopulate p(_M_container_control);\n+\tsync();\n+\n+\t// Construct list of member functions to exercise.\n+\t_M_functions.push_back(function_type(base_type::_M_pushf));\n+\t_M_functions.push_back(function_type(base_type::_M_pushb));\n+\t_M_functions.push_back(function_type(base_type::_M_insertp));\n+\t_M_functions.push_back(function_type(base_type::_M_rehash));\n+\n+\t// Run tests.\n+\tauto i = _M_functions.begin();\n+\tfor (auto i = _M_functions.begin(); i != _M_functions.end(); ++i)\n+\t  {\n+\t    function_type& f = *i;\n+\t    run_steps_to_limit(f);\n+\t  }\n+      }\n+\n+      template<typename _Funct>\n+\tvoid\n+\trun_steps_to_limit(const _Funct& __f)\n+\t{\n+\t  size_t i(1);\n+\t  bool exit(false);\n+\n+\t  do\n+\t    {\n+\t      sync();\n+\n+\t      try\n+\t\t{\n+\t\t  condition_type::limit_adjustor limit(i);\n+\t\t  __f(_M_container_test);\n+\n+\t\t  // If we get here, done.\n+\t\t  exit = true;\n+\t\t}\n+\t      catch(const __gnu_cxx::forced_error&)\n+\t\t{\n+\t\t  compare(_M_container_control, _M_container_test);\n+\t\t  ++i;\n+\t\t}\n+\t    }\n+\t  while (!exit);\n+\n+\t  // Log count info.\n+\t  std::cout << __f.target_type().name() << std::endl;\n+\t  std::cout << \"end count \" << i << std::endl;\n+\t}\n+    };\n+\n+} // namespace __gnu_test\n+\n+#endif"}, {"sha": "85d04c5728ca12a4c8d6ebc8af360d3ccaff7b9a", "filename": "libstdc++-v3/testsuite/util/testsuite_container_traits.h", "status": "modified", "additions": 94, "deletions": 37, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5317914406060becef31b5dc1a8bce8bcea932a9/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h?ref=5317914406060becef31b5dc1a8bce8bcea932a9", "patch": "@@ -24,8 +24,9 @@\n #include <ext/vstring.h>\n \n namespace __gnu_test\n-{  \n+{\n   // Container traits.\n+  // Base class with default false values for all traits.\n   struct traits_base\n   {\n     // Type, nested type, and typedef related traits.\n@@ -37,6 +38,11 @@ namespace __gnu_test\n     typedef std::false_type\tis_associative;\n     typedef std::false_type\tis_unordered;\n     typedef std::false_type\tis_mapped;\n+\n+    typedef std::false_type\thas_erase;\n+    typedef std::false_type\thas_insert;\n+    typedef std::false_type\thas_push_pop;\n+    typedef std::false_type\thas_size_type_constructor;\n   };\n \n   // Primary template does nothing. Specialize on each type under\n@@ -46,51 +52,68 @@ namespace __gnu_test\n \n   // Specialize for each container.\n   template<typename _Tp, size_t _Np>\n-    struct traits<std::array<_Tp, _Np> > : public traits_base\n+    struct traits<std::array<_Tp, _Np>> : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_reversible;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::deque<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2>\n+    struct traits<std::deque<_Tp1, _Tp2>> : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_reversible;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n+\n+      typedef std::true_type\thas_erase;\n+      typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_push_pop;\n+      typedef std::true_type\thas_size_type_constructor;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::forward_list<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2>\n+    struct traits<std::forward_list<_Tp1, _Tp2>> : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n+\n+      typedef std::true_type\thas_erase;\n+      typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_push_pop;\n+      typedef std::true_type\thas_size_type_constructor;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::list<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2>\n+    struct traits<std::list<_Tp1, _Tp2>> : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_reversible;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n+\n+      typedef std::true_type\thas_erase;\n+      typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_push_pop;\n+      typedef std::true_type\thas_size_type_constructor;\n     };\n \n-  template<typename _Kp, typename _Tp>\n-    struct traits<std::map<_Kp, _Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n+    struct traits<std::map<_Tp1, _Tp2, _Tp3, _Tp4>> : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_reversible;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n       typedef std::true_type\tis_associative;\n       typedef std::true_type\tis_mapped;\n+\n+      typedef std::true_type\thas_insert;\n     };\n \n-  template<typename _Kp, typename _Tp>\n-    struct traits<std::multimap<_Kp, _Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n+    struct traits<std::multimap<_Tp1, _Tp2, _Tp3, _Tp4>> : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_reversible;\n@@ -100,108 +123,142 @@ namespace __gnu_test\n       typedef std::true_type\tis_mapped;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::multiset<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3>\n+    struct traits<std::multiset<_Tp1, _Tp2, _Tp3>> : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_reversible;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n       typedef std::true_type\tis_associative;\n+\n+      typedef std::true_type\thas_insert;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::priority_queue<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2>\n+    struct traits<std::priority_queue<_Tp1, _Tp2>> : public traits_base\n     {\n       typedef std::true_type\tis_adaptor;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::queue<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2>\n+    struct traits<std::queue<_Tp1, _Tp2>> : public traits_base\n     {\n       typedef std::true_type\tis_adaptor;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::set<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3>\n+    struct traits<std::set<_Tp1, _Tp2, _Tp3>> : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_reversible;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n       typedef std::true_type\tis_associative;\n+\n+      typedef std::true_type\thas_insert;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::stack<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2>\n+    struct traits<std::stack<_Tp1, _Tp2> > : public traits_base\n     {\n       typedef std::true_type\tis_adaptor;\n     };\n \n-  template<typename _Kp, typename _Tp>\n-    struct traits<std::unordered_map<_Kp, _Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3,\n+\t   typename _Tp4, typename _Tp5>\n+    struct traits<std::unordered_map<_Tp1, _Tp2, _Tp3, _Tp4, _Tp5>>\n+    : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n       typedef std::true_type\tis_unordered;\n       typedef std::true_type\tis_mapped;\n+\n+      typedef std::true_type\thas_size_type_constructor;\n+      typedef std::true_type\thas_insert;\n     };\n \n-  template<typename _Kp, typename _Tp>\n-    struct traits<std::unordered_multimap<_Kp, _Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3,\n+\t   typename _Tp4, typename _Tp5>\n+    struct traits<std::unordered_multimap<_Tp1, _Tp2, _Tp3, _Tp4, _Tp5>>\n+    : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n       typedef std::true_type\tis_unordered;\n       typedef std::true_type\tis_mapped;\n+\n+      typedef std::true_type\thas_size_type_constructor;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::unordered_multiset<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n+    struct traits<std::unordered_multiset<_Tp1, _Tp2, _Tp3, _Tp4>>\n+    : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n       typedef std::true_type\tis_unordered;\n+\n+      typedef std::true_type\thas_insert;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::unordered_set<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n+    struct traits<std::unordered_set<_Tp1, _Tp2, _Tp3, _Tp4>>\n+    : public traits_base\n     {\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_allocator_aware;\n       typedef std::true_type\tis_pointer_aware;\n       typedef std::true_type\tis_unordered;\n+\n+      typedef std::true_type\thas_size_type_constructor;\n+      typedef std::true_type\thas_insert;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::vector<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2>\n+    struct traits<std::vector<_Tp1, _Tp2>> : public traits_base\n     {\n       typedef std::true_type    is_container;\n       typedef std::true_type    is_reversible;\n       typedef std::true_type    is_allocator_aware;\n       typedef std::true_type    is_pointer_aware;\n+\n+      typedef std::true_type\thas_erase;\n+      typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_size_type_constructor;\n     };\n \n-  template<typename _Tp>\n-    struct traits<std::basic_string<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3>\n+    struct traits<std::basic_string<_Tp1, _Tp2, _Tp3>> : public traits_base\n     {\n       typedef std::true_type    is_container;\n       typedef std::true_type    is_reversible;\n       typedef std::true_type    is_allocator_aware;\n       typedef std::true_type    is_pointer_aware;\n+\n+      typedef std::true_type\thas_erase;\n+      typedef std::true_type\thas_insert;\n     };\n \n-  template<typename _Tp>\n-    struct traits<__gnu_cxx::__versa_string<_Tp> > : public traits_base\n+  template<typename _Tp1, typename _Tp2, typename _Tp3,\n+\t   template <typename, typename, typename> class _Tp4>\n+    struct traits<__gnu_cxx::__versa_string<_Tp1, _Tp2, _Tp3, _Tp4>>\n+    : public traits_base\n     {\n       typedef std::true_type    is_container;\n       typedef std::true_type    is_reversible;\n       typedef std::true_type    is_allocator_aware;\n       typedef std::true_type    is_pointer_aware;\n+\n+      typedef std::true_type\thas_erase;\n+\n+      // XXX no vstring<rc>::insert\n+      //      typedef std::true_type\thas_insert;\n     };\n } // namespace __gnu_test\n \n-#endif \n+#endif"}]}