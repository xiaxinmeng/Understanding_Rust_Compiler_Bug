{"sha": "5e48d89420f8b16c1eddb9b568c4fee74eefbd45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU0OGQ4OTQyMGY4YjE2YzFlZGRiOWI1NjhjNGZlZTc0ZWVmYmQ0NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:01:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:01:10Z"}, "message": "poly_int: cfgexpand stack variables\n\nThis patch changes the type of stack_var::size from HOST_WIDE_INT\nto poly_uint64.  The difference in signedness is because the\nfield was set by:\n\n  v->size = tree_to_uhwi (size);\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* cfgexpand.c (stack_var::size): Change from a HOST_WIDE_INT\n\tto a poly_uint64.\n\t(add_stack_var, stack_var_cmp, partition_stack_vars)\n\t(dump_stack_var_partition): Update accordingly.\n\t(alloc_stack_frame_space): Take the size as a poly_int64 rather\n\tthan a HOST_WIDE_INT.\n\t(expand_stack_vars, expand_one_stack_var_1): Handle polynomial sizes.\n\t(defer_stack_allocation, estimated_stack_frame_size): Likewise.\n\t(account_stack_vars, expand_one_var): Likewise.  Return a poly_uint64\n\trather than a HOST_WIDE_INT.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255922", "tree": {"sha": "73861bbd923cc748c738d57d075b97f0ca8b459a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73861bbd923cc748c738d57d075b97f0ca8b459a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e48d89420f8b16c1eddb9b568c4fee74eefbd45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e48d89420f8b16c1eddb9b568c4fee74eefbd45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e48d89420f8b16c1eddb9b568c4fee74eefbd45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e48d89420f8b16c1eddb9b568c4fee74eefbd45/comments", "author": null, "committer": null, "parents": [{"sha": "a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb"}], "stats": {"total": 97, "additions": 56, "deletions": 41}, "files": [{"sha": "30abd3dea011cd3163125affcd30c5f48145a7b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e48d89420f8b16c1eddb9b568c4fee74eefbd45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e48d89420f8b16c1eddb9b568c4fee74eefbd45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e48d89420f8b16c1eddb9b568c4fee74eefbd45", "patch": "@@ -1,3 +1,18 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* cfgexpand.c (stack_var::size): Change from a HOST_WIDE_INT\n+\tto a poly_uint64.\n+\t(add_stack_var, stack_var_cmp, partition_stack_vars)\n+\t(dump_stack_var_partition): Update accordingly.\n+\t(alloc_stack_frame_space): Take the size as a poly_int64 rather\n+\tthan a HOST_WIDE_INT.\n+\t(expand_stack_vars, expand_one_stack_var_1): Handle polynomial sizes.\n+\t(defer_stack_allocation, estimated_stack_frame_size): Likewise.\n+\t(account_stack_vars, expand_one_var): Likewise.  Return a poly_uint64\n+\trather than a HOST_WIDE_INT.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "60fb137a540ad546a08f9623b30e3a5c80854892", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e48d89420f8b16c1eddb9b568c4fee74eefbd45/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e48d89420f8b16c1eddb9b568c4fee74eefbd45/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=5e48d89420f8b16c1eddb9b568c4fee74eefbd45", "patch": "@@ -314,7 +314,7 @@ struct stack_var\n \n   /* Initially, the size of the variable.  Later, the size of the partition,\n      if this variable becomes it's partition's representative.  */\n-  HOST_WIDE_INT size;\n+  poly_uint64 size;\n \n   /* The *byte* alignment required for this variable.  Or as, with the\n      size, the alignment for this partition.  */\n@@ -390,7 +390,7 @@ align_base (HOST_WIDE_INT base, unsigned HOST_WIDE_INT align, bool align_up)\n    Return the frame offset.  */\n \n static poly_int64\n-alloc_stack_frame_space (HOST_WIDE_INT size, unsigned HOST_WIDE_INT align)\n+alloc_stack_frame_space (poly_int64 size, unsigned HOST_WIDE_INT align)\n {\n   poly_int64 offset, new_frame_offset;\n \n@@ -443,10 +443,10 @@ add_stack_var (tree decl)\n   tree size = TREE_CODE (decl) == SSA_NAME\n     ? TYPE_SIZE_UNIT (TREE_TYPE (decl))\n     : DECL_SIZE_UNIT (decl);\n-  v->size = tree_to_uhwi (size);\n+  v->size = tree_to_poly_uint64 (size);\n   /* Ensure that all variables have size, so that &a != &b for any two\n      variables that are simultaneously live.  */\n-  if (v->size == 0)\n+  if (known_eq (v->size, 0U))\n     v->size = 1;\n   v->alignb = align_local_variable (decl);\n   /* An alignment of zero can mightily confuse us later.  */\n@@ -676,8 +676,8 @@ stack_var_cmp (const void *a, const void *b)\n   size_t ib = *(const size_t *)b;\n   unsigned int aligna = stack_vars[ia].alignb;\n   unsigned int alignb = stack_vars[ib].alignb;\n-  HOST_WIDE_INT sizea = stack_vars[ia].size;\n-  HOST_WIDE_INT sizeb = stack_vars[ib].size;\n+  poly_int64 sizea = stack_vars[ia].size;\n+  poly_int64 sizeb = stack_vars[ib].size;\n   tree decla = stack_vars[ia].decl;\n   tree declb = stack_vars[ib].decl;\n   bool largea, largeb;\n@@ -690,10 +690,9 @@ stack_var_cmp (const void *a, const void *b)\n     return (int)largeb - (int)largea;\n \n   /* Secondary compare on size, decreasing  */\n-  if (sizea > sizeb)\n-    return -1;\n-  if (sizea < sizeb)\n-    return 1;\n+  int diff = compare_sizes_for_sort (sizeb, sizea);\n+  if (diff != 0)\n+    return diff;\n \n   /* Tertiary compare on true alignment, decreasing.  */\n   if (aligna < alignb)\n@@ -904,7 +903,7 @@ partition_stack_vars (void)\n     {\n       size_t i = stack_vars_sorted[si];\n       unsigned int ialign = stack_vars[i].alignb;\n-      HOST_WIDE_INT isize = stack_vars[i].size;\n+      poly_int64 isize = stack_vars[i].size;\n \n       /* Ignore objects that aren't partition representatives. If we\n          see a var that is not a partition representative, it must\n@@ -916,7 +915,7 @@ partition_stack_vars (void)\n \t{\n \t  size_t j = stack_vars_sorted[sj];\n \t  unsigned int jalign = stack_vars[j].alignb;\n-\t  HOST_WIDE_INT jsize = stack_vars[j].size;\n+\t  poly_int64 jsize = stack_vars[j].size;\n \n \t  /* Ignore objects that aren't partition representatives.  */\n \t  if (stack_vars[j].representative != j)\n@@ -932,8 +931,8 @@ partition_stack_vars (void)\n \t     sizes, as the shorter vars wouldn't be adequately protected.\n \t     Don't do that for \"large\" (unsupported) alignment objects,\n \t     those aren't protected anyway.  */\n-\t  if ((asan_sanitize_stack_p ())\n-\t      && isize != jsize\n+\t  if (asan_sanitize_stack_p ()\n+\t      && maybe_ne (isize, jsize)\n \t      && ialign * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n \t    break;\n \n@@ -964,9 +963,9 @@ dump_stack_var_partition (void)\n       if (stack_vars[i].representative != i)\n \tcontinue;\n \n-      fprintf (dump_file, \"Partition %lu: size \" HOST_WIDE_INT_PRINT_DEC\n-\t       \" align %u\\n\", (unsigned long) i, stack_vars[i].size,\n-\t       stack_vars[i].alignb);\n+      fprintf (dump_file, \"Partition %lu: size \", (unsigned long) i);\n+      print_dec (stack_vars[i].size, dump_file);\n+      fprintf (dump_file, \" align %u\\n\", stack_vars[i].alignb);\n \n       for (j = i; j != EOC; j = stack_vars[j].next)\n \t{\n@@ -1042,7 +1041,7 @@ static void\n expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n {\n   size_t si, i, j, n = stack_vars_num;\n-  HOST_WIDE_INT large_size = 0, large_alloc = 0;\n+  poly_uint64 large_size = 0, large_alloc = 0;\n   rtx large_base = NULL;\n   unsigned large_align = 0;\n   bool large_allocation_done = false;\n@@ -1085,8 +1084,7 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t      : DECL_RTL (decl) != pc_rtx)\n \t    continue;\n \n-\t  large_size += alignb - 1;\n-\t  large_size &= -(HOST_WIDE_INT)alignb;\n+\t  large_size = aligned_upper_bound (large_size, alignb);\n \t  large_size += stack_vars[i].size;\n \t}\n     }\n@@ -1125,7 +1123,8 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t  HOST_WIDE_INT prev_offset;\n \t  if (asan_sanitize_stack_p ()\n \t      && pred\n-\t      && frame_offset.is_constant (&prev_offset))\n+\t      && frame_offset.is_constant (&prev_offset)\n+\t      && stack_vars[i].size.is_constant ())\n \t    {\n \t      prev_offset = align_base (prev_offset,\n \t\t\t\t\tMAX (alignb, ASAN_RED_ZONE_SIZE),\n@@ -1184,23 +1183,22 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \n \t  /* If there were any variables requiring \"large\" alignment, allocate\n \t     space.  */\n-\t  if (large_size > 0 && ! large_allocation_done)\n+\t  if (maybe_ne (large_size, 0U) && ! large_allocation_done)\n \t    {\n \t      poly_int64 loffset;\n \t      rtx large_allocsize;\n \n-\t      large_allocsize = GEN_INT (large_size);\n+\t      large_allocsize = gen_int_mode (large_size, Pmode);\n \t      get_dynamic_stack_size (&large_allocsize, 0, large_align, NULL);\n \t      loffset = alloc_stack_frame_space\n-\t\t(INTVAL (large_allocsize),\n+\t\t(rtx_to_poly_int64 (large_allocsize),\n \t\t PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT);\n \t      large_base = get_dynamic_stack_base (loffset, large_align);\n \t      large_allocation_done = true;\n \t    }\n \t  gcc_assert (large_base != NULL);\n \n-\t  large_alloc += alignb - 1;\n-\t  large_alloc &= -(HOST_WIDE_INT)alignb;\n+\t  large_alloc = aligned_upper_bound (large_alloc, alignb);\n \t  offset = large_alloc;\n \t  large_alloc += stack_vars[i].size;\n \n@@ -1218,15 +1216,15 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t}\n     }\n \n-  gcc_assert (large_alloc == large_size);\n+  gcc_assert (known_eq (large_alloc, large_size));\n }\n \n /* Take into account all sizes of partitions and reset DECL_RTLs.  */\n-static HOST_WIDE_INT\n+static poly_uint64\n account_stack_vars (void)\n {\n   size_t si, j, i, n = stack_vars_num;\n-  HOST_WIDE_INT size = 0;\n+  poly_uint64 size = 0;\n \n   for (si = 0; si < n; ++si)\n     {\n@@ -1289,19 +1287,19 @@ set_parm_rtl (tree parm, rtx x)\n static void\n expand_one_stack_var_1 (tree var)\n {\n-  HOST_WIDE_INT size;\n+  poly_uint64 size;\n   poly_int64 offset;\n   unsigned byte_align;\n \n   if (TREE_CODE (var) == SSA_NAME)\n     {\n       tree type = TREE_TYPE (var);\n-      size = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+      size = tree_to_poly_uint64 (TYPE_SIZE_UNIT (type));\n       byte_align = TYPE_ALIGN_UNIT (type);\n     }\n   else\n     {\n-      size = tree_to_uhwi (DECL_SIZE_UNIT (var));\n+      size = tree_to_poly_uint64 (DECL_SIZE_UNIT (var));\n       byte_align = align_local_variable (var);\n     }\n \n@@ -1513,12 +1511,14 @@ defer_stack_allocation (tree var, bool toplevel)\n   tree size_unit = TREE_CODE (var) == SSA_NAME\n     ? TYPE_SIZE_UNIT (TREE_TYPE (var))\n     : DECL_SIZE_UNIT (var);\n+  poly_uint64 size;\n \n   /* Whether the variable is small enough for immediate allocation not to be\n      a problem with regard to the frame size.  */\n   bool smallish\n-    = ((HOST_WIDE_INT) tree_to_uhwi (size_unit)\n-       < PARAM_VALUE (PARAM_MIN_SIZE_FOR_STACK_SHARING));\n+    = (poly_int_tree_p (size_unit, &size)\n+       && (estimated_poly_value (size)\n+\t   < PARAM_VALUE (PARAM_MIN_SIZE_FOR_STACK_SHARING)));\n \n   /* If stack protection is enabled, *all* stack variables must be deferred,\n      so that we can re-order the strings to the top of the frame.\n@@ -1572,7 +1572,7 @@ defer_stack_allocation (tree var, bool toplevel)\n    Return stack usage this variable is supposed to take.\n */\n \n-static HOST_WIDE_INT\n+static poly_uint64\n expand_one_var (tree var, bool toplevel, bool really_expand)\n {\n   unsigned int align = BITS_PER_UNIT;\n@@ -1615,6 +1615,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n \n   record_alignment_for_reg_var (align);\n \n+  poly_uint64 size;\n   if (TREE_CODE (origvar) == SSA_NAME)\n     {\n       gcc_assert (!VAR_P (var)\n@@ -1655,7 +1656,8 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n       if (really_expand)\n         expand_one_register_var (origvar);\n     }\n-  else if (! valid_constant_size_p (DECL_SIZE_UNIT (var)))\n+  else if (!poly_int_tree_p (DECL_SIZE_UNIT (var), &size)\n+\t   || !valid_constant_size_p (DECL_SIZE_UNIT (var)))\n     {\n       /* Reject variables which cover more than half of the address-space.  */\n       if (really_expand)\n@@ -1677,9 +1679,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n \n           expand_one_stack_var (origvar);\n         }\n-\n-\n-      return tree_to_uhwi (DECL_SIZE_UNIT (var));\n+      return size;\n     }\n   return 0;\n }\n@@ -1932,7 +1932,7 @@ fini_vars_expansion (void)\n HOST_WIDE_INT\n estimated_stack_frame_size (struct cgraph_node *node)\n {\n-  HOST_WIDE_INT size = 0;\n+  poly_int64 size = 0;\n   size_t i;\n   tree var;\n   struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n@@ -1956,7 +1956,7 @@ estimated_stack_frame_size (struct cgraph_node *node)\n \n   fini_vars_expansion ();\n   pop_cfun ();\n-  return size;\n+  return estimated_poly_value (size);\n }\n \n /* Helper routine to check if a record or union contains an array field. */"}]}