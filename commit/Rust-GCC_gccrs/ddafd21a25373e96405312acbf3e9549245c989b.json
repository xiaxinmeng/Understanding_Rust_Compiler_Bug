{"sha": "ddafd21a25373e96405312acbf3e9549245c989b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRhZmQyMWEyNTM3M2U5NjQwNTMxMmFjYmYzZTk1NDkyNDVjOTg5Yg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2014-01-18T20:05:25Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2014-01-18T20:05:25Z"}, "message": "re PR fortran/58007 ([OOP] ICE in free_pi_tree(): Unresolved fixup - resolve_fixups does not fixup component of __class_bsr_Bsr_matrix)\n\nfortran/\n        PR fortran/58007\n        * module.c (MOD_VERSION): Bump.\n        (fp2, find_pointer2): Remove.\n        (mio_component_ref): Don't forcedfully set the containing derived type\n        symbol for loading.  Remove unused argument.\n        (mio_ref): Update caller\n        (mio_symbol): Dump component list earlier.\n        (skip_list): New argument nest_level.  Initialize level with the new\n        argument.\n        (read_module): Add forced pointer components association for derived\n        type symbols.\n\ntestsuite/\n        PR fortran/58007\n        * gfortran.dg/unresolved_fixup_1.f90: New test.\n        * gfortran.dg/unresolved_fixup_2.f90: New test.\n\nFrom-SVN: r206759", "tree": {"sha": "0421e3e54b073f116c8bbd3cecac24e5f7e09d21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0421e3e54b073f116c8bbd3cecac24e5f7e09d21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddafd21a25373e96405312acbf3e9549245c989b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddafd21a25373e96405312acbf3e9549245c989b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddafd21a25373e96405312acbf3e9549245c989b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddafd21a25373e96405312acbf3e9549245c989b/comments", "author": null, "committer": null, "parents": [{"sha": "646bdeabace2ff6565c9536b9bc1cb8b0743aaf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646bdeabace2ff6565c9536b9bc1cb8b0743aaf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646bdeabace2ff6565c9536b9bc1cb8b0743aaf1"}], "stats": {"total": 239, "additions": 157, "deletions": 82}, "files": [{"sha": "802ca7321481010f2140bf60464dbd00bc609252", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ddafd21a25373e96405312acbf3e9549245c989b", "patch": "@@ -1,3 +1,17 @@\n+2014-01-18  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/58007\n+\t* module.c (MOD_VERSION): Bump.\n+\t(fp2, find_pointer2): Remove.\n+\t(mio_component_ref): Don't forcedfully set the containing derived type\n+\tsymbol for loading.  Remove unused argument.\n+\t(mio_ref): Update caller\n+\t(mio_symbol): Dump component list earlier.\n+\t(skip_list): New argument nest_level.  Initialize level with the new\n+\targument.\n+\t(read_module): Add forced pointer components association for derived\n+\ttype symbols.\n+\n 2014-01-12  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/58026"}, {"sha": "90fe7b9484177b5f06de4958af44ad096315ca05", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 56, "deletions": 81, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=ddafd21a25373e96405312acbf3e9549245c989b", "patch": "@@ -82,7 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Don't put any single quote (') in MOD_VERSION, if you want it to be\n    recognized.  */\n-#define MOD_VERSION \"11\"\n+#define MOD_VERSION \"12\"\n \n \n /* Structure that describes a position within a module file.  */\n@@ -390,37 +390,6 @@ get_integer (int integer)\n }\n \n \n-/* Recursive function to find a pointer within a tree by brute force.  */\n-\n-static pointer_info *\n-fp2 (pointer_info *p, const void *target)\n-{\n-  pointer_info *q;\n-\n-  if (p == NULL)\n-    return NULL;\n-\n-  if (p->u.pointer == target)\n-    return p;\n-\n-  q = fp2 (p->left, target);\n-  if (q != NULL)\n-    return q;\n-\n-  return fp2 (p->right, target);\n-}\n-\n-\n-/* During reading, find a pointer_info node from the pointer value.\n-   This amounts to a brute-force search.  */\n-\n-static pointer_info *\n-find_pointer2 (void *p)\n-{\n-  return fp2 (pi_root, p);\n-}\n-\n-\n /* Resolve any fixups using a known pointer.  */\n \n static void\n@@ -2588,45 +2557,13 @@ mio_pointer_ref (void *gp)\n    the namespace and is not loaded again.  */\n \n static void\n-mio_component_ref (gfc_component **cp, gfc_symbol *sym)\n+mio_component_ref (gfc_component **cp)\n {\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n-  gfc_component *q;\n   pointer_info *p;\n \n   p = mio_pointer_ref (cp);\n   if (p->type == P_UNKNOWN)\n     p->type = P_COMPONENT;\n-\n-  if (iomode == IO_OUTPUT)\n-    mio_pool_string (&(*cp)->name);\n-  else\n-    {\n-      mio_internal_string (name);\n-\n-      if (sym && sym->attr.is_class)\n-\tsym = sym->components->ts.u.derived;\n-\n-      /* It can happen that a component reference can be read before the\n-\t associated derived type symbol has been loaded. Return now and\n-\t wait for a later iteration of load_needed.  */\n-      if (sym == NULL)\n-\treturn;\n-\n-      if (sym->components != NULL && p->u.pointer == NULL)\n-\t{\n-\t  /* Symbol already loaded, so search by name.  */\n-\t  q = gfc_find_component (sym, name, true, true);\n-\n-\t  if (q)\n-\t    associate_integer_pointer (p, q);\n-\t}\n-\n-      /* Make sure this symbol will eventually be loaded.  */\n-      p = find_pointer2 (sym);\n-      if (p->u.rsym.state == UNUSED)\n-\tp->u.rsym.state = NEEDED;\n-    }\n }\n \n \n@@ -2983,7 +2920,7 @@ mio_ref (gfc_ref **rp)\n \n     case REF_COMPONENT:\n       mio_symbol_ref (&r->u.c.sym);\n-      mio_component_ref (&r->u.c.component, r->u.c.sym);\n+      mio_component_ref (&r->u.c.component);\n       break;\n \n     case REF_SUBSTRING:\n@@ -3855,7 +3792,9 @@ mio_full_f2k_derived (gfc_symbol *sym)\n \n \n /* Unlike most other routines, the address of the symbol node is already\n-   fixed on input and the name/module has already been filled in.  */\n+   fixed on input and the name/module has already been filled in.\n+   If you update the symbol format here, don't forget to update read_module\n+   as well (look for \"seek to the symbol's component list\").   */\n \n static void\n mio_symbol (gfc_symbol *sym)\n@@ -3865,6 +3804,14 @@ mio_symbol (gfc_symbol *sym)\n   mio_lparen ();\n \n   mio_symbol_attribute (&sym->attr);\n+\n+  /* Note that components are always saved, even if they are supposed\n+     to be private.  Component access is checked during searching.  */\n+  mio_component_list (&sym->components, sym->attr.vtype);\n+  if (sym->components != NULL)\n+    sym->component_access\n+      = MIO_NAME (gfc_access) (sym->component_access, access_types);\n+\n   mio_typespec (&sym->ts);\n   if (sym->ts.type == BT_CLASS)\n     sym->attr.class_ok = 1;\n@@ -3893,15 +3840,6 @@ mio_symbol (gfc_symbol *sym)\n   if (sym->attr.cray_pointee)\n     mio_symbol_ref (&sym->cp_pointer);\n \n-  /* Note that components are always saved, even if they are supposed\n-     to be private.  Component access is checked during searching.  */\n-\n-  mio_component_list (&sym->components, sym->attr.vtype);\n-\n-  if (sym->components != NULL)\n-    sym->component_access\n-      = MIO_NAME (gfc_access) (sym->component_access, access_types);\n-\n   /* Load/save the f2k_derived namespace of a derived-type symbol.  */\n   mio_full_f2k_derived (sym);\n \n@@ -3997,14 +3935,17 @@ find_symbol (gfc_symtree *st, const char *name,\n }\n \n \n-/* Skip a list between balanced left and right parens.  */\n+/* Skip a list between balanced left and right parens.\n+   By setting NEST_LEVEL one assumes that a number of NEST_LEVEL opening parens\n+   have been already parsed by hand, and the remaining of the content is to be\n+   skipped here.  The default value is 0 (balanced parens).  */\n \n static void\n-skip_list (void)\n+skip_list (int nest_level = 0)\n {\n   int level;\n \n-  level = 0;\n+  level = nest_level;\n   do\n     {\n       switch (parse_atom ())\n@@ -4638,7 +4579,6 @@ read_module (void)\n       info->u.rsym.ns = atom_int;\n \n       get_module_locus (&info->u.rsym.where);\n-      skip_list ();\n \n       /* See if the symbol has already been loaded by a previous module.\n \t If so, we reference the existing symbol and prevent it from\n@@ -4649,10 +4589,45 @@ read_module (void)\n \n       if (sym == NULL\n \t  || (sym->attr.flavor == FL_VARIABLE && info->u.rsym.ns !=1))\n-\tcontinue;\n+\t{\n+\t  skip_list ();\n+\t  continue;\n+\t}\n \n       info->u.rsym.state = USED;\n       info->u.rsym.sym = sym;\n+      /* The current symbol has already been loaded, so we can avoid loading\n+\t it again.  However, if it is a derived type, some of its components\n+\t can be used in expressions in the module.  To avoid the module loading\n+\t failing, we need to associate the module's component pointer indexes\n+\t with the existing symbol's component pointers.  */\n+      if (sym->attr.flavor == FL_DERIVED)\n+\t{\n+\t  gfc_component *c;\n+\n+\t  /* First seek to the symbol's component list.  */\n+\t  mio_lparen (); /* symbol opening.  */\n+\t  skip_list (); /* skip symbol attribute.  */\n+\n+\t  mio_lparen (); /* component list opening.  */\n+\t  for (c = sym->components; c; c = c->next)\n+\t    {\n+\t      pointer_info *p;\n+\t      int n;\n+\n+\t      mio_lparen (); /* component opening.  */\n+\t      mio_integer (&n);\n+\t      p = get_integer (n);\n+\t      if (p->u.pointer == NULL)\n+\t\tassociate_integer_pointer (p, c);\n+\t      skip_list (1); /* component end.  */\n+\t    }\n+\t  mio_rparen (); /* component list closing.  */\n+\n+\t  skip_list (1); /* symbol end.  */\n+\t}\n+      else\n+\tskip_list ();\n \n       /* Some symbols do not have a namespace (eg. formal arguments),\n \t so the automatic \"unique symtree\" mechanism must be suppressed"}, {"sha": "48b309025b7e3cec537d037a6b19071b5d9edceb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ddafd21a25373e96405312acbf3e9549245c989b", "patch": "@@ -1,3 +1,9 @@\n+2014-01-18  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/58007\n+\t* gfortran.dg/unresolved_fixup_1.f90: New test.\n+\t* gfortran.dg/unresolved_fixup_2.f90: New test.\n+\n 2014-01-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/58944\n@@ -19,7 +25,7 @@\n \n 2014-01-17  Jeff Law  <law@redhat.com>\n \n-        PR middle-end/57904\n+\tPR middle-end/57904\n \t* gfortran.dg/pr57904.f90: New test.\n \n 2014-01-17  Paolo Carlini  <paolo.carlini@oracle.com>"}, {"sha": "07fbce3d5957fb34484b4049892baf2d18d11d0e", "filename": "gcc/testsuite/gfortran.dg/unresolved_fixup_1.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ftestsuite%2Fgfortran.dg%2Funresolved_fixup_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ftestsuite%2Fgfortran.dg%2Funresolved_fixup_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funresolved_fixup_1.f90?ref=ddafd21a25373e96405312acbf3e9549245c989b", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+!\n+! PR fortran/58007\n+! Unresolved fixup while loading a module.\n+!\n+! This tests that the specification expression A%MAX_DEGREE in module BSR is\n+! correctly loaded and resolved in program MAIN.\n+!\n+! Original testcase from Daniel Shapiro <shapero@uw.edu>\n+! Reduced by Tobias Burnus <burnus@net-b.de> and Janus Weil <janus@gcc.gnu.org>\n+\n+module matrix\n+  type :: sparse_matrix\n+    integer :: max_degree\n+  end type\n+contains\n+  subroutine init_interface (A)\n+    class(sparse_matrix), intent(in) :: A\n+  end subroutine\n+  real function get_value_interface()\n+  end function\n+end module\n+\n+module ellpack\n+  use matrix\n+end module\n+\n+module bsr\n+  use matrix\n+  type, extends(sparse_matrix) :: bsr_matrix\n+  contains\n+    procedure :: get_neighbors\n+  end type\n+contains\n+  function get_neighbors (A)\n+    class(bsr_matrix), intent(in) :: A\n+    integer :: get_neighbors(A%max_degree)\n+  end function\n+end module\n+\n+program main\n+  use ellpack\n+  use bsr\n+end"}, {"sha": "ca0a05a629a1fbca56405fa546ae58cc27e2787a", "filename": "gcc/testsuite/gfortran.dg/unresolved_fixup_2.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ftestsuite%2Fgfortran.dg%2Funresolved_fixup_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddafd21a25373e96405312acbf3e9549245c989b/gcc%2Ftestsuite%2Fgfortran.dg%2Funresolved_fixup_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funresolved_fixup_2.f90?ref=ddafd21a25373e96405312acbf3e9549245c989b", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+!\n+! PR fortran/58007\n+! Unresolved fiixup while loading a module.\n+!\n+! This tests that the specification expression A%MAX_DEGREE in module BSR is\n+! correctly loaded and resolved in program MAIN.\n+!\n+! Original testcase from Daniel Shapiro <shapero@uw.edu>\n+\n+module matrix\n+  type :: sparse_matrix\n+    integer :: max_degree\n+  end type\n+end module\n+\n+module bsr\n+  use matrix\n+\n+  type, extends(sparse_matrix) :: bsr_matrix\n+  end type\n+\n+  integer :: i1\n+  integer :: i2\n+  integer :: i3\n+contains\n+  function get_neighbors (A)\n+    type(bsr_matrix), intent(in) :: A\n+    integer :: get_neighbors(A%max_degree)\n+  end function\n+end module\n+\n+program main\n+  use matrix\n+  use bsr\n+end"}]}