{"sha": "d6ae9a6d8d392bc439419066ee94f884020edfef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZhZTlhNmQ4ZDM5MmJjNDM5NDE5MDY2ZWU5NGY4ODQwMjBlZGZlZg==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2015-01-03T02:59:20Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2015-01-03T02:59:20Z"}, "message": "invoke.texi (Option Summary): Fix spelling of -fdevirtualize-at-ltrans.\n\n2015-01-02  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/\n\t* doc/invoke.texi (Option Summary): Fix spelling of\n\t-fdevirtualize-at-ltrans.\n\t([-fdevirtualize]): Fix markup.\n\t([-fdevirtualize-speculatively]): Fix typo.\n\t([-fdevirtualize-at-ltrans]): Likewise.  Make description less\n\timplementor-speaky.\n\t* common.opt (fdevirtualize-at-ltrans): Likewise.\n\t* ipa-devirt.c: Fix typos in comments throughout the file.\n\t(ipa_devirt): Fix typos in format strings for dump output.\n\nFrom-SVN: r219158", "tree": {"sha": "74b9f477673806a08619bd1e0617f60e991bb462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74b9f477673806a08619bd1e0617f60e991bb462"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6ae9a6d8d392bc439419066ee94f884020edfef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ae9a6d8d392bc439419066ee94f884020edfef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ae9a6d8d392bc439419066ee94f884020edfef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ae9a6d8d392bc439419066ee94f884020edfef/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "931d6406354fc205f018df335e53a5fdb12e79bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/931d6406354fc205f018df335e53a5fdb12e79bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/931d6406354fc205f018df335e53a5fdb12e79bb"}], "stats": {"total": 138, "additions": 76, "deletions": 62}, "files": [{"sha": "d5980c9a26c945e5be49fa449eb96d115716b2cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ae9a6d8d392bc439419066ee94f884020edfef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ae9a6d8d392bc439419066ee94f884020edfef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6ae9a6d8d392bc439419066ee94f884020edfef", "patch": "@@ -1,3 +1,15 @@\n+2015-01-02  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* doc/invoke.texi (Option Summary): Fix spelling of\n+\t-fdevirtualize-at-ltrans.\n+\t([-fdevirtualize]): Fix markup.\n+\t([-fdevirtualize-speculatively]): Fix typo.\n+\t([-fdevirtualize-at-ltrans]): Likewise.  Make description less\n+\timplementor-speaky.\n+\t* common.opt (fdevirtualize-at-ltrans): Likewise.\n+\t* ipa-devirt.c: Fix typos in comments throughout the file.\n+\t(ipa_devirt): Fix typos in format strings for dump output.\n+\n 2015-01-02  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/invoke.texi ([-fopt-info]): Fix markup, consolidate"}, {"sha": "27532d5a657319d485f4e052ad68a0b2d4ad405d", "filename": "gcc/common.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ae9a6d8d392bc439419066ee94f884020edfef/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ae9a6d8d392bc439419066ee94f884020edfef/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d6ae9a6d8d392bc439419066ee94f884020edfef", "patch": "@@ -1064,7 +1064,7 @@ Delete useless null pointer checks\n \n fdevirtualize-at-ltrans\n Common Report Var(flag_ltrans_devirtualize)\n-Perofrm extra streaming to support more agressive devirtualization at LTO ltrans stage.\n+Stream extra data to support more aggressive devirtualization in LTO local transformation mode\n \n fdevirtualize-speculatively\n Common Report Var(flag_devirtualize_speculatively) Optimization"}, {"sha": "1361ac22020028937538f06a764922ec78bbe8ba", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ae9a6d8d392bc439419066ee94f884020edfef/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ae9a6d8d392bc439419066ee94f884020edfef/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d6ae9a6d8d392bc439419066ee94f884020edfef", "patch": "@@ -378,7 +378,7 @@ Objective-C and Objective-C++ Dialects}.\n -fcx-limited-range @gol\n -fdata-sections -fdce -fdelayed-branch @gol\n -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively @gol\n--devirtualize-at-ltrans -fdse @gol\n+-fdevirtualize-at-ltrans -fdse @gol\n -fearly-inlining -fipa-sra -fexpensive-optimizations -ffat-lto-objects @gol\n -ffast-math -ffinite-math-only -ffloat-store -fexcess-precision=@var{style} @gol\n -fforward-propagate -ffp-contract=@var{style} -ffunction-sections @gol\n@@ -7772,7 +7772,7 @@ are enabled independently at different optimization levels.\n @opindex fdevirtualize\n Attempt to convert calls to virtual functions to direct calls.  This\n is done both within a procedure and interprocedurally as part of\n-indirect inlining (@code{-findirect-inlining}) and interprocedural constant\n+indirect inlining (@option{-findirect-inlining}) and interprocedural constant\n propagation (@option{-fipa-cp}).\n Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n \n@@ -7781,14 +7781,15 @@ Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n Attempt to convert calls to virtual functions to speculative direct calls.\n Based on the analysis of the type inheritance graph, determine for a given call\n the set of likely targets. If the set is small, preferably of size 1, change\n-the call into an conditional deciding on direct and indirect call.  The\n+the call into a conditional deciding between direct and indirect calls.  The\n speculative calls enable more optimizations, such as inlining.  When they seem\n useless after further optimization, they are converted back into original form.\n \n @item -fdevirtualize-at-ltrans\n @opindex fdevirtualize-at-ltrans\n-Perform extra streaming needed for agressive devirtualization during LTO local\n-transformation stage. This option enables more devirtualization but\n+Stream extra information needed for aggressive devirtualization when running\n+the link-time optimizer in local transformation mode.  \n+This option enables more devirtualization but\n significantly increases the size of streamed data. For this reason it is\n disabled by default.\n "}, {"sha": "2f89ce6a9c870541f3a76872e6473679bfc0fd26", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ae9a6d8d392bc439419066ee94f884020edfef/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ae9a6d8d392bc439419066ee94f884020edfef/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=d6ae9a6d8d392bc439419066ee94f884020edfef", "patch": "@@ -19,7 +19,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Brief vocalburary:\n+/* Brief vocabulary:\n      ODR = One Definition Rule\n         In short, the ODR states that:\n \t1 In any translation unit, a template, type, function, or object can\n@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n \n      BINFO\n        This is the type inheritance information attached to each tree\n-       RECORD_TYPE by the C++ frotend.  It provides information about base\n+       RECORD_TYPE by the C++ frontend.  It provides information about base\n        types and virtual tables.\n \n        BINFO is linked to the RECORD_TYPE by TYPE_BINFO.\n@@ -75,7 +75,7 @@ along with GCC; see the file COPYING3.  If not see\n        or from DECL_VINDEX of a given virtual table.\n \n      polymorphic (indirect) call\n-       This is callgraph represention of virtual method call.  Every\n+       This is callgraph representation of virtual method call.  Every\n        polymorphic call contains otr_type and otr_token taken from\n        original OBJ_TYPE_REF at callgraph construction time.\n \n@@ -196,17 +196,17 @@ static bool odr_violation_reported = false;\n static hash_set<cgraph_node *> *cached_polymorphic_call_targets;\n \n /* The node of type inheritance graph.  For each type unique in\n-   One Defintion Rule (ODR) sense, we produce one node linking all \n+   One Definition Rule (ODR) sense, we produce one node linking all \n    main variants of types equivalent to it, bases and derived types.  */\n \n struct GTY(()) odr_type_d\n {\n   /* leader type.  */\n   tree type;\n-  /* All bases; built only for main variants of types  */\n+  /* All bases; built only for main variants of types.  */\n   vec<odr_type> GTY((skip)) bases;\n-  /* All derrived types with virtual methods seen in unit;\n-     built only for main variants oftypes  */\n+  /* All derived types with virtual methods seen in unit;\n+     built only for main variants of types.  */\n   vec<odr_type> GTY((skip)) derived_types;\n \n   /* All equivalent types, if more than one.  */\n@@ -246,7 +246,7 @@ type_all_derivations_known_p (const_tree t)\n   return (decl_function_context (TYPE_NAME (t)) != NULL);\n }\n \n-/* Return TURE if type's constructors are all visible.  */\n+/* Return TRUE if type's constructors are all visible.  */\n \n static bool\n type_all_ctors_visible_p (tree t)\n@@ -367,7 +367,7 @@ odr_hasher::hash (const value_type *odr_type)\n /* For languages with One Definition Rule, work out if\n    types are the same based on their name.\n  \n-   This is non-trivial for LTO where minnor differences in\n+   This is non-trivial for LTO where minor differences in\n    the type representation may have prevented type merging\n    to merge two copies of otherwise equivalent type.\n \n@@ -397,7 +397,7 @@ types_same_for_odr (const_tree type1, const_tree type2)\n \n   /* ODR name of the type is set in DECL_ASSEMBLER_NAME of its TYPE_NAME.\n \n-     Ideally we should never meed types without ODR names here.  It can however\n+     Ideally we should never need types without ODR names here.  It can however\n      happen in two cases:\n \n        1) for builtin types that are not streamed but rebuilt in lto/lto-lang.c\n@@ -410,8 +410,8 @@ types_same_for_odr (const_tree type1, const_tree type2)\n   if ((!TYPE_NAME (type1) || !DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (type1)))\n       || (!TYPE_NAME (type2) || !DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (type2))))\n     {\n-      /* See if types are obvoiusly different (i.e. different codes\n-\t or polymorphis wrt non-polymorphic).  This is not strictly correct\n+      /* See if types are obviously different (i.e. different codes\n+\t or polymorphic wrt non-polymorphic).  This is not strictly correct\n \t for ODR violating programs, but we can't do better without streaming\n \t ODR names.  */\n       if (TREE_CODE (type1) != TREE_CODE (type2))\n@@ -424,8 +424,8 @@ types_same_for_odr (const_tree type1, const_tree type2)\n \t     != (BINFO_VTABLE (TYPE_BINFO (type2)) == NULL_TREE))\n \treturn false;\n \n-      /* At the moment we have no way to establish ODR equivlaence at LTO\n-\t other than comparing virtual table pointrs of polymorphic types.\n+      /* At the moment we have no way to establish ODR equivalence at LTO\n+\t other than comparing virtual table pointers of polymorphic types.\n \t Eventually we should start saving mangled names in TYPE_NAME.\n \t Then this condition will become non-trivial.  */\n \n@@ -508,7 +508,7 @@ odr_hasher::remove (value_type *v)\n   ggc_free (v);\n }\n \n-/* ODR type hash used to lookup ODR type based on tree type node.  */\n+/* ODR type hash used to look up ODR type based on tree type node.  */\n \n typedef hash_table<odr_hasher> odr_hash_type;\n static odr_hash_type *odr_hash;\n@@ -565,7 +565,7 @@ odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<type_pair,pair_traits> *vi\n         return true;\n     }\n \n-  /* Component types, builtins and possibly vioalting ODR types\n+  /* Component types, builtins and possibly violating ODR types\n      have to be compared structurally.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return false;\n@@ -586,7 +586,7 @@ odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<type_pair,pair_traits> *vi\n }\n \n /* Compare two virtual tables, PREVAILING and VTABLE and output ODR\n-   violation warings.  */\n+   violation warnings.  */\n \n void\n compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n@@ -1445,8 +1445,8 @@ type_known_to_have_no_deriavations_p (tree t)\n \t\t  && !get_odr_type (t, true)->derived_types.length())));\n }\n \n-/* Dump ODR type T and all its derrived type.  INDENT specify indentation for\n-   recusive printing.  */\n+/* Dump ODR type T and all its derived types.  INDENT specifies indentation for\n+   recursive printing.  */\n \n static void\n dump_odr_type (FILE *f, odr_type t, int indent=0)\n@@ -1517,7 +1517,7 @@ dump_type_inheritance_graph (FILE *f)\n }\n \n /* Given method type T, return type of class it belongs to.\n-   Lookup this pointer and get its type.    */\n+   Look up this pointer and get its type.    */\n \n tree\n method_class_type (const_tree t)\n@@ -1664,7 +1664,7 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n \n   target_node = cgraph_node::get (target);\n \n-  /* Preffer alias target over aliases, so we do not get confused by\n+  /* Prefer alias target over aliases, so we do not get confused by\n      fake duplicates.  */\n   if (target_node)\n     {\n@@ -1676,7 +1676,7 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n     }\n \n   /* Method can only be called by polymorphic call if any\n-     of vtables refering to it are alive. \n+     of vtables referring to it are alive. \n \n      While this holds for non-anonymous functions, too, there are\n      cases where we want to keep them in the list; for example\n@@ -1686,7 +1686,7 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n \n      Currently we ignore these functions in speculative devirtualization.\n      ??? Maybe it would make sense to be more aggressive for LTO even\n-     eslewhere.  */\n+     elsewhere.  */\n   if (!flag_ltrans\n       && type_in_anonymous_namespace_p (DECL_CONTEXT (target))\n       && (!target_node\n@@ -1714,12 +1714,12 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n     *completep = false;\n }\n \n-/* See if BINFO's type match OUTER_TYPE.  If so, lookup \n+/* See if BINFO's type matches OUTER_TYPE.  If so, look up \n    BINFO of subtype of OTR_TYPE at OFFSET and in that BINFO find\n    method in vtable and insert method to NODES array\n    or BASES_TO_CONSIDER if this array is non-NULL.\n    Otherwise recurse to base BINFOs.\n-   This match what get_binfo_at_offset does, but with offset\n+   This matches what get_binfo_at_offset does, but with offset\n    being unknown.\n \n    TYPE_BINFOS is a stack of BINFOS of types with defined\n@@ -1760,7 +1760,7 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n       int i;\n       tree type_binfo = NULL;\n \n-      /* Lookup BINFO with virtual table.  For normal types it is always last\n+      /* Look up BINFO with virtual table.  For normal types it is always last\n \t binfo on stack.  */\n       for (i = type_binfos.length () - 1; i >= 0; i--)\n \tif (BINFO_OFFSET (type_binfos[i]) == BINFO_OFFSET (binfo))\n@@ -1815,7 +1815,7 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n \n   /* Walk bases.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-    /* Walking bases that have no virtual method is pointless excercise.  */\n+    /* Walking bases that have no virtual method is pointless exercise.  */\n     if (polymorphic_type_binfo_p (base_binfo))\n       record_target_from_binfo (nodes, bases_to_consider, base_binfo, otr_type,\n \t\t\t\ttype_binfos, \n@@ -1825,13 +1825,13 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n     type_binfos.pop ();\n }\n      \n-/* Lookup virtual methods matching OTR_TYPE (with OFFSET and OTR_TOKEN)\n+/* Look up virtual methods matching OTR_TYPE (with OFFSET and OTR_TOKEN)\n    of TYPE, insert them to NODES, recurse into derived nodes. \n    INSERTED is used to avoid duplicate insertions of methods into NODES.\n    MATCHED_VTABLES are used to avoid duplicate walking vtables.\n    Clear COMPLETEP if unreferable target is found.\n  \n-   If CONSIDER_CONSTURCTION is true, record to BASES_TO_CONSDIER\n+   If CONSIDER_CONSTRUCTION is true, record to BASES_TO_CONSIDER\n    all cases where BASE_SKIPPED is true (because the base is abstract\n    class).  */\n \n@@ -1989,7 +1989,7 @@ devirt_node_removal_hook (struct cgraph_node *n, void *d ATTRIBUTE_UNUSED)\n     free_polymorphic_call_targets_hash ();\n }\n \n-/* Lookup base of BINFO that has virtual table VTABLE with OFFSET.  */\n+/* Look up base of BINFO that has virtual table VTABLE with OFFSET.  */\n \n tree\n subbinfo_with_vtable_at_offset (tree binfo, unsigned HOST_WIDE_INT offset,\n@@ -2031,7 +2031,7 @@ vtable_pointer_value_to_vtable (const_tree t, tree *v,\n   /* We expect &MEM[(void *)&virtual_table + 16B].\n      We obtain object's BINFO from the context of the virtual table. \n      This one contains pointer to virtual table represented via\n-     POINTER_PLUS_EXPR.  Verify that this pointer match to what\n+     POINTER_PLUS_EXPR.  Verify that this pointer matches what\n      we propagated through.\n \n      In the case of virtual inheritance, the virtual tables may\n@@ -2084,14 +2084,14 @@ vtable_pointer_value_to_binfo (const_tree t)\n      because we do not have BINFO for those. Eventually we should fix\n      our representation to allow this case to be handled, too.\n      In the case we see store of BINFO we however may assume\n-     that standard folding will be ale to cope with it.  */\n+     that standard folding will be able to cope with it.  */\n   return subbinfo_with_vtable_at_offset (TYPE_BINFO (DECL_CONTEXT (vtable)),\n \t\t\t\t\t offset, vtable);\n }\n \n /* Walk bases of OUTER_TYPE that contain OTR_TYPE at OFFSET.\n-   Lookup their respecitve virtual methods for OTR_TOKEN and OTR_TYPE\n-   and insert them to NODES.\n+   Look up their respective virtual methods for OTR_TOKEN and OTR_TYPE\n+   and insert them in NODES.\n \n    MATCHED_VTABLES and INSERTED is used to avoid duplicated work.  */\n \n@@ -2126,10 +2126,10 @@ record_targets_from_bases (tree otr_type,\n \t      && polymorphic_type_binfo_p (TYPE_BINFO (TREE_TYPE (fld))))\n \t    break;\n \t}\n-      /* Within a class type we should always find correcponding fields.  */\n+      /* Within a class type we should always find corresponding fields.  */\n       gcc_assert (fld && TREE_CODE (TREE_TYPE (fld)) == RECORD_TYPE);\n \n-      /* Nonbasetypes should have been stripped by outer_class_type.  */\n+      /* Nonbase types should have been stripped by outer_class_type.  */\n       gcc_assert (DECL_ARTIFICIAL (fld));\n \n       outer_type = TREE_TYPE (fld);\n@@ -2197,8 +2197,8 @@ struct final_warning_record\n struct final_warning_record *final_warning_records;\n \n /* Return vector containing possible targets of polymorphic call of type\n-   OTR_TYPE caling method OTR_TOKEN within type of OTR_OUTER_TYPE and OFFSET.\n-   If INCLUDE_BASES is true, walk also base types of OUTER_TYPES containig\n+   OTR_TYPE calling method OTR_TOKEN within type of OTR_OUTER_TYPE and OFFSET.\n+   If INCLUDE_BASES is true, walk also base types of OUTER_TYPES containing\n    OTR_TYPE and include their virtual method.  This is useful for types\n    possibly in construction or destruction where the virtual table may\n    temporarily change to one of base types.  INCLUDE_DERIVER_TYPES make\n@@ -2238,7 +2238,7 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   otr_type = TYPE_MAIN_VARIANT (otr_type);\n \n-  /* If ODR is not initialized or the constext is invalid, return empty\n+  /* If ODR is not initialized or the context is invalid, return empty\n      incomplete list.  */\n   if (!odr_hash || context.invalid || !TYPE_BINFO (otr_type))\n     {\n@@ -2255,11 +2255,11 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   type = get_odr_type (otr_type, true);\n \n-  /* Recording type variants would wast results cache.  */\n+  /* Recording type variants would waste results cache.  */\n   gcc_assert (!context.outer_type\n \t      || TYPE_MAIN_VARIANT (context.outer_type) == context.outer_type);\n \n-  /* Lookup the outer class type we want to walk.\n+  /* Look up the outer class type we want to walk.\n      If we fail to do so, the context is invalid.  */\n   if ((context.outer_type || context.speculative_outer_type)\n       && !context.restrict_to_inner_class (otr_type))\n@@ -2279,10 +2279,10 @@ possible_polymorphic_call_targets (tree otr_type,\n   /* We canonicalize our query, so we do not need extra hashtable entries.  */\n \n   /* Without outer type, we have no use for offset.  Just do the\n-     basic search from innter type  */\n+     basic search from inner type.  */\n   if (!context.outer_type)\n     context.clear_outer_type (otr_type);\n-  /* We need to update our hiearchy if the type does not exist.  */\n+  /* We need to update our hierarchy if the type does not exist.  */\n   outer_type = get_odr_type (context.outer_type, true);\n   /* If the type is complete, there are no derivations.  */\n   if (TYPE_FINAL_P (outer_type->type))\n@@ -2313,7 +2313,7 @@ possible_polymorphic_call_targets (tree otr_type,\n \t  = get_odr_type (context.speculative_outer_type, true)->type;\n     }\n \n-  /* Lookup cached answer.  */\n+  /* Look up cached answer.  */\n   key.type = type;\n   key.otr_token = otr_token;\n   key.speculative = speculative;\n@@ -2362,7 +2362,8 @@ possible_polymorphic_call_targets (tree otr_type,\n       odr_type speculative_outer_type;\n       bool speculation_complete = true;\n \n-      /* First insert target from type itself and check if it may have derived types.  */\n+      /* First insert target from type itself and check if it may have\n+\t derived types.  */\n       speculative_outer_type = get_odr_type (context.speculative_outer_type, true);\n       if (TYPE_FINAL_P (speculative_outer_type->type))\n \tcontext.speculative_maybe_derived_type = false;\n@@ -2498,8 +2499,8 @@ possible_polymorphic_call_targets (tree otr_type,\n       if (!speculative)\n \t{\n \t  /* Destructors are never called through construction virtual tables,\n-\t     because the type is always known.  One of entries may be cxa_pure_virtual\n-\t     so look to at least two of them.  */\n+\t     because the type is always known.  One of entries may be\n+\t     cxa_pure_virtual so look to at least two of them.  */\n \t  if (context.maybe_in_construction)\n \t    for (i =0 ; i < MIN (nodes.length (), 2); i++)\n \t      if (DECL_CXX_DESTRUCTOR_P (nodes[i]->decl))\n@@ -2705,16 +2706,16 @@ likely_target_p (struct cgraph_node *n)\n     return false;\n   if (n->frequency < NODE_FREQUENCY_NORMAL)\n     return false;\n-  /* If there are no virtual tables refering the target alive,\n-     the only way the target can be called is an instance comming from other\n-     compilation unit; speculative devirtualization is build around an\n+  /* If there are no live virtual tables referring the target,\n+     the only way the target can be called is an instance coming from other\n+     compilation unit; speculative devirtualization is built around an\n      assumption that won't happen.  */\n   if (!referenced_from_vtable_p (n))\n     return false;\n   return true;\n }\n \n-/* Compare type warning records P1 and P2 and chose one with larger count;\n+/* Compare type warning records P1 and P2 and choose one with larger count;\n    helper for qsort.  */\n \n int\n@@ -2730,7 +2731,7 @@ type_warning_cmp (const void *p1, const void *p2)\n   return t2->count - t1->count;\n }\n \n-/* Compare decl warning records P1 and P2 and chose one with larger count;\n+/* Compare decl warning records P1 and P2 and choose one with larger count;\n    helper for qsort.  */\n \n int\n@@ -2747,7 +2748,7 @@ decl_warning_cmp (const void *p1, const void *p2)\n }\n \n \n-/* Try speculatively devirtualize call to OTR_TYPE with OTR_TOKEN with\n+/* Try to speculatively devirtualize call to OTR_TYPE with OTR_TOKEN with\n    context CTX.  */\n \n struct cgraph_node *\n@@ -2785,7 +2786,7 @@ try_speculative_devirtualization (tree otr_type, HOST_WIDE_INT otr_token,\n \n /* The ipa-devirt pass.\n    When polymorphic call has only one likely target in the unit,\n-   turn it into speculative call.  */\n+   turn it into a speculative call.  */\n \n static unsigned int\n ipa_devirt (void)\n@@ -2860,7 +2861,7 @@ ipa_devirt (void)\n \t    if (e->speculative)\n \t      {\n \t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Call is aready speculated\\n\\n\");\n+\t\t  fprintf (dump_file, \"Call is already speculated\\n\\n\");\n \t\tnspeculated++;\n \n \t\t/* When dumping see if we agree with speculation.  */\n@@ -2915,7 +2916,7 @@ ipa_devirt (void)\n \t    if (!likely_target->definition)\n \t      {\n \t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Target is not an definition\\n\\n\");\n+\t\t  fprintf (dump_file, \"Target is not a definition\\n\\n\");\n \t\tnnotdefined++;\n \t\tcontinue;\n \t      }"}]}