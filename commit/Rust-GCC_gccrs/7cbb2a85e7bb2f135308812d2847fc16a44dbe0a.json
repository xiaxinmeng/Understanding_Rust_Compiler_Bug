{"sha": "7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NiYjJhODVlN2JiMmYxMzUzMDg4MTJkMjg0N2ZjMTZhNDRkYmUwYQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-06-26T00:22:12Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-06-26T00:22:12Z"}, "message": "cse.c (approx_reg_cost_1, cse_insn): Fix -Wc++-compat and/or -Wcast-qual warnings.\n\n\t* cse.c (approx_reg_cost_1, cse_insn): Fix -Wc++-compat and/or\n\t-Wcast-qual warnings.\n\t* gcc.c (process_command): Likewise.\n\t* genattrtab.c (oballoc): Use XOBNEW.\n\t(oballocvec): Define.\n\t(attr_hash_add_rtx, attr_hash_add_string, attr_string,\n\tget_attr_value, fill_attr, make_length_attrs, gen_attr, gen_insn,\n\tgen_delay, find_attr, gen_insn_reserv, gen_bypass_1): Fix\n\t-Wc++-compat and/or -Wcast-qual warnings.\n\t* genautomata.c (XCREATENODE, XCREATENODEVEC, XCREATENODEVAR,\n\tXCOPYNODE, XCOPYNODEVEC, XCOPYNODEVAR): New.\n\t(gen_cpu_unit, gen_query_cpu_unit, gen_bypass, gen_excl_set,\n\tgen_presence_absence_set, gen_automaton, gen_regexp_el,\n\tgen_regexp_repeat, gen_regexp_allof, gen_regexp_oneof,\n\tgen_regexp_sequence, gen_reserv, gen_insn_reserv, process_excls,\n\tadd_excls, process_presence_absence_names,\n\tprocess_presence_absence_patterns, add_presence_absence,\n\tprocess_regexp, add_advance_cycle_insn_decl, get_free_alt_state,\n\tget_free_state, add_arc, get_free_automata_list_el,\n\tform_reserv_sets_list, copy_insn_regexp, transform_1, transform_2,\n\ttransform_3, cache_presence, create_ainsns, create_automata,\n\tcreate_state_ainsn_table, dfa_insn_code_enlarge,\n\toutput_trans_func, output_min_issue_delay_func,\n\toutput_dead_lock_func, output_reset_func,\n\toutput_get_cpu_unit_code_func, output_dfa_start_func,\n\texpand_automata): Likewise.\n\t* genextract.c (gen_insn): Likewise.\n\t* gengtype-lex.l: Likewise.\n\t* gengtype.c (read_input_list, adjust_field_type,\n\tprocess_gc_options): Likewise.\n\t* genoutput.c (note_constraint): Likewise.\n\t* genpreds.c (mangle, add_constraint): Likewise.\n\t* genrecog.c (process_define_predicate, new_decision,\n\tadd_to_sequence): Likewise.\n\t* gensupport.c (record_insn_name): Likewise.\n\nFrom-SVN: r137135", "tree": {"sha": "fb71542f91c1a9dcc70d28cb64513626a2cdcfb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb71542f91c1a9dcc70d28cb64513626a2cdcfb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/comments", "author": null, "committer": null, "parents": [{"sha": "d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3bfe4decc2bbbce0585df7814c7923488cb1cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3bfe4decc2bbbce0585df7814c7923488cb1cb5"}], "stats": {"total": 323, "additions": 186, "deletions": 137}, "files": [{"sha": "a65715f1c93a8af4f93c38e4f9a69a53cd70a2de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -1,3 +1,41 @@\n+2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cse.c (approx_reg_cost_1, cse_insn): Fix -Wc++-compat and/or\n+\t-Wcast-qual warnings.\n+\t* gcc.c (process_command): Likewise.\n+\t* genattrtab.c (oballoc): Use XOBNEW.\n+\t(oballocvec): Define.\n+\t(attr_hash_add_rtx, attr_hash_add_string, attr_string,\n+\tget_attr_value, fill_attr, make_length_attrs, gen_attr, gen_insn,\n+\tgen_delay, find_attr, gen_insn_reserv, gen_bypass_1): Fix\n+\t-Wc++-compat and/or -Wcast-qual warnings.\n+\t* genautomata.c (XCREATENODE, XCREATENODEVEC, XCREATENODEVAR,\n+\tXCOPYNODE, XCOPYNODEVEC, XCOPYNODEVAR): New.\n+\t(gen_cpu_unit, gen_query_cpu_unit, gen_bypass, gen_excl_set,\n+\tgen_presence_absence_set, gen_automaton, gen_regexp_el,\n+\tgen_regexp_repeat, gen_regexp_allof, gen_regexp_oneof,\n+\tgen_regexp_sequence, gen_reserv, gen_insn_reserv, process_excls,\n+\tadd_excls, process_presence_absence_names,\n+\tprocess_presence_absence_patterns, add_presence_absence,\n+\tprocess_regexp, add_advance_cycle_insn_decl, get_free_alt_state,\n+\tget_free_state, add_arc, get_free_automata_list_el,\n+\tform_reserv_sets_list, copy_insn_regexp, transform_1, transform_2,\n+\ttransform_3, cache_presence, create_ainsns, create_automata,\n+\tcreate_state_ainsn_table, dfa_insn_code_enlarge,\n+\toutput_trans_func, output_min_issue_delay_func,\n+\toutput_dead_lock_func, output_reset_func,\n+\toutput_get_cpu_unit_code_func, output_dfa_start_func,\n+\texpand_automata): Likewise.\n+\t* genextract.c (gen_insn): Likewise.\n+\t* gengtype-lex.l: Likewise.\n+\t* gengtype.c (read_input_list, adjust_field_type,\n+\tprocess_gc_options): Likewise.\n+\t* genoutput.c (note_constraint): Likewise.\n+\t* genpreds.c (mangle, add_constraint): Likewise.\n+\t* genrecog.c (process_define_predicate, new_decision,\n+\tadd_to_sequence): Likewise.\n+\t* gensupport.c (record_insn_name): Likewise.\n+\n 2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* config/i386/driver-i386.c (detect_caches_amd,"}, {"sha": "86c0f5408dac5c111d31edfd86c2f685384c73c7", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -663,7 +663,7 @@ static int\n approx_reg_cost_1 (rtx *xp, void *data)\n {\n   rtx x = *xp;\n-  int *cost_p = data;\n+  int *cost_p = (int *) data;\n \n   if (x && REG_P (x))\n     {\n@@ -4005,7 +4005,7 @@ cse_insn (rtx insn)\n \n   if (GET_CODE (x) == SET)\n     {\n-      sets = alloca (sizeof (struct set));\n+      sets = XALLOCA (struct set);\n       sets[0].rtl = x;\n \n       /* Ignore SETs that are unconditional jumps.\n@@ -4040,7 +4040,7 @@ cse_insn (rtx insn)\n     {\n       int lim = XVECLEN (x, 0);\n \n-      sets = alloca (lim * sizeof (struct set));\n+      sets = XALLOCAVEC (struct set, lim);\n \n       /* Find all regs explicitly clobbered in this insn,\n \t and ensure they are not replaced with any other regs"}, {"sha": "a8c6218e646288a520acc93e8dfbfdd10aabd8fb", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -3409,15 +3409,14 @@ process_command (int argc, const char **argv)\n       for (baselen = strlen (progname); baselen > 0; baselen--)\n \tif (IS_DIR_SEPARATOR (progname[baselen-1]))\n \t  break;\n-      new_argv0 = (char *) xmemdup (progname, baselen,\n+      new_argv0 = XDUPVAR (char, progname, baselen,\n \t\t\t   baselen + concat_length (new_version, new_machine,\n \t\t\t\t\t\t    \"-gcc-\", NULL) + 1);\n       strcpy (new_argv0 + baselen, new_machine);\n       strcat (new_argv0, \"-gcc-\");\n       strcat (new_argv0, new_version);\n \n-      new_argv = (char **) xmemdup (argv, (argc + 1) * sizeof (argv[0]),\n-\t\t\t  (argc + 1) * sizeof (argv[0]));\n+      new_argv = XDUPVEC (char *, argv, argc + 1);\n       new_argv[0] = new_argv0;\n \n       execvp (new_argv0, new_argv);"}, {"sha": "079c81f95528ec18f26507084b02c027a4911b35", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -286,7 +286,8 @@ static rtx one_fn\t\t   (rtx);\n static rtx max_fn\t\t   (rtx);\n static rtx min_fn\t\t   (rtx);\n \n-#define oballoc(size) obstack_alloc (hash_obstack, size)\n+#define oballoc(T) XOBNEW (hash_obstack, T)\n+#define oballocvec(T, N) XOBNEWVEC (hash_obstack, T, (N))\n \n /* Hash table for sharing RTL and strings.  */\n \n@@ -326,7 +327,7 @@ attr_hash_add_rtx (int hashcode, rtx rtl)\n {\n   struct attr_hash *h;\n \n-  h = obstack_alloc (hash_obstack, sizeof (struct attr_hash));\n+  h = XOBNEW (hash_obstack, struct attr_hash);\n   h->hashcode = hashcode;\n   h->u.rtl = rtl;\n   h->next = attr_hash_table[hashcode % RTL_HASH_SIZE];\n@@ -340,7 +341,7 @@ attr_hash_add_string (int hashcode, char *str)\n {\n   struct attr_hash *h;\n \n-  h = obstack_alloc (hash_obstack, sizeof (struct attr_hash));\n+  h = XOBNEW (hash_obstack, struct attr_hash);\n   h->hashcode = -hashcode;\n   h->u.str = str;\n   h->next = attr_hash_table[hashcode % RTL_HASH_SIZE];\n@@ -601,7 +602,7 @@ attr_string (const char *str, int len)\n       return h->u.str;\t\t\t/* <-- return if found.  */\n \n   /* Not found; create a permanent copy and add it to the hash table.  */\n-  new_str = obstack_alloc (hash_obstack, len + 1);\n+  new_str = XOBNEWVAR (hash_obstack, char, len + 1);\n   memcpy (new_str, str, len);\n   new_str[len] = '\\0';\n   attr_hash_add_string (hashcode, new_str);\n@@ -1297,7 +1298,7 @@ get_attr_value (rtx value, struct attr_desc *attr, int insn_code)\n \t    || insn_alternatives[av->first_insn->def->insn_code]))\n       return av;\n \n-  av = oballoc (sizeof (struct attr_value));\n+  av = oballoc (struct attr_value);\n   av->value = value;\n   av->next = attr->first_value;\n   attr->first_value = av;\n@@ -1440,7 +1441,7 @@ fill_attr (struct attr_desc *attr)\n       else\n \tav = get_attr_value (value, attr, id->insn_code);\n \n-      ie = oballoc (sizeof (struct insn_ent));\n+      ie = oballoc (struct insn_ent);\n       ie->def = id;\n       insert_insn_ent (av, ie);\n     }\n@@ -1571,7 +1572,7 @@ make_length_attrs (void)\n \t\t\t\t\t\t\t no_address_fn[i],\n \t\t\t\t\t\t\t address_fn[i]),\n \t\t\t\t     new_attr, ie->def->insn_code);\n-\t    new_ie = oballoc (sizeof (struct insn_ent));\n+\t    new_ie = oballoc (struct insn_ent);\n \t    new_ie->def = ie->def;\n \t    insert_insn_ent (new_av, new_ie);\n \t  }\n@@ -2949,7 +2950,7 @@ gen_attr (rtx exp, int lineno)\n       name_ptr = XSTR (exp, 1);\n       while ((p = next_comma_elt (&name_ptr)) != NULL)\n \t{\n-\t  av = oballoc (sizeof (struct attr_value));\n+\t  av = oballoc (struct attr_value);\n \t  av->value = attr_rtx (CONST_STRING, p);\n \t  av->next = attr->first_value;\n \t  attr->first_value = av;\n@@ -3062,7 +3063,7 @@ gen_insn (rtx exp, int lineno)\n {\n   struct insn_def *id;\n \n-  id = oballoc (sizeof (struct insn_def));\n+  id = oballoc (struct insn_def);\n   id->next = defs;\n   defs = id;\n   id->def = exp;\n@@ -3126,7 +3127,7 @@ gen_delay (rtx def, int lineno)\n \thave_annul_false = 1;\n     }\n \n-  delay = oballoc (sizeof (struct delay_desc));\n+  delay = oballoc (struct delay_desc);\n   delay->def = def;\n   delay->num = ++num_delays;\n   delay->next = delays;\n@@ -4158,7 +4159,7 @@ find_attr (const char **name_p, int create)\n   if (! create)\n     return NULL;\n \n-  attr = oballoc (sizeof (struct attr_desc));\n+  attr = oballoc (struct attr_desc);\n   attr->name = DEF_ATTR_STRING (name);\n   attr->first_value = attr->default_val = NULL;\n   attr->is_numeric = attr->is_const = attr->is_special = 0;\n@@ -4297,7 +4298,7 @@ static size_t n_insn_reservs;\n static void\n gen_insn_reserv (rtx def)\n {\n-  struct insn_reserv *decl = oballoc (sizeof (struct insn_reserv));\n+  struct insn_reserv *decl = oballoc (struct insn_reserv);\n \n   decl->name            = DEF_ATTR_STRING (XSTR (def, 0));\n   decl->default_latency = XINT (def, 1);\n@@ -4338,7 +4339,7 @@ gen_bypass_1 (const char *s, size_t len)\n     if (s == b->insn)\n       return;  /* already got that one */\n \n-  b = oballoc (sizeof (struct bypass_list));\n+  b = oballoc (struct bypass_list);\n   b->insn = s;\n   b->next = all_bypasses;\n   all_bypasses = b;\n@@ -4544,13 +4545,13 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#define operands recog_data.operand\\n\\n\");\n \n   /* Make `insn_alternatives'.  */\n-  insn_alternatives = oballoc (insn_code_number * sizeof (int));\n+  insn_alternatives = oballocvec (int, insn_code_number);\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_alternatives[id->insn_code] = (1 << id->num_alternatives) - 1;\n \n   /* Make `insn_n_alternatives'.  */\n-  insn_n_alternatives = oballoc (insn_code_number * sizeof (int));\n+  insn_n_alternatives = oballocvec (int, insn_code_number);\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_n_alternatives[id->insn_code] = id->num_alternatives;"}, {"sha": "3709c557fb3c44ec713198a771ae2276571329b4", "filename": "gcc/genautomata.c", "status": "modified", "additions": 107, "deletions": 97, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -1085,6 +1085,14 @@ regexp_mode_check_failed (enum regexp_mode mode,\n \n #endif /* #if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007) */\n \n+#define XCREATENODE(T) ((T *) create_node (sizeof (T)))\n+#define XCREATENODEVEC(T, N) ((T *) create_node (sizeof (T) * (N)))\n+#define XCREATENODEVAR(T, S) ((T *) create_node ((S)))\n+\n+#define XCOPYNODE(T, P) ((T *) copy_node ((P), sizeof (T)))\n+#define XCOPYNODEVEC(T, P, N) ((T *) copy_node ((P), sizeof (T) * (N)))\n+#define XCOPYNODEVAR(T, P, S) ((T *) copy_node ((P), (S)))\n+\n /* Create IR structure (node).  */\n static void *\n create_node (size_t size)\n@@ -1242,7 +1250,7 @@ gen_cpu_unit (rtx def)\n     fatal (\"invalid string `%s' in define_cpu_unit\", XSTR (def, 0));\n   for (i = 0; i < vect_length; i++)\n     {\n-      decl = create_node (sizeof (struct decl));\n+      decl = XCREATENODE (struct decl);\n       decl->mode = dm_unit;\n       decl->pos = 0;\n       DECL_UNIT (decl)->name = check_name (str_cpu_units [i], decl->pos);\n@@ -1272,7 +1280,7 @@ gen_query_cpu_unit (rtx def)\n     fatal (\"invalid string `%s' in define_query_cpu_unit\", XSTR (def, 0));\n   for (i = 0; i < vect_length; i++)\n     {\n-      decl = create_node (sizeof (struct decl));\n+      decl = XCREATENODE (struct decl);\n       decl->mode = dm_unit;\n       decl->pos = 0;\n       DECL_UNIT (decl)->name = check_name (str_cpu_units [i], decl->pos);\n@@ -1306,7 +1314,7 @@ gen_bypass (rtx def)\n   for (i = 0; i < out_length; i++)\n     for (j = 0; j < in_length; j++)\n       {\n-\tdecl = create_node (sizeof (struct decl));\n+\tdecl = XCREATENODE (struct decl);\n \tdecl->mode = dm_bypass;\n \tdecl->pos = 0;\n \tDECL_BYPASS (decl)->latency = XINT (def, 0);\n@@ -1341,7 +1349,7 @@ gen_excl_set (rtx def)\n   if (second_str_cpu_units == NULL)\n     fatal (\"invalid second string `%s' in exclusion_set\", XSTR (def, 1));\n   length += first_vect_length;\n-  decl = create_node (sizeof (struct decl) + (length - 1) * sizeof (char *));\n+  decl = XCREATENODEVAR (struct decl, sizeof (struct decl) + (length - 1) * sizeof (char *));\n   decl->mode = dm_excl;\n   decl->pos = 0;\n   DECL_EXCL (decl)->all_names_num = length;\n@@ -1394,14 +1402,14 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n \t    : (final_p\n \t       ? \"invalid second string `%s' in final_absence_set\"\n \t       : \"invalid second string `%s' in absence_set\")), XSTR (def, 1));\n-  str_patterns = obstack_alloc (&irp, patterns_length * sizeof (char **));\n+  str_patterns = XOBNEWVEC (&irp, char **, patterns_length);\n   for (i = 0; i < patterns_length; i++)\n     {\n       str_patterns [i] = get_str_vect (str_pattern_lists [i],\n \t\t\t\t       &length, ' ', FALSE);\n       gcc_assert (str_patterns [i]);\n     }\n-  decl = create_node (sizeof (struct decl));\n+  decl = XCREATENODE (struct decl);\n   decl->pos = 0;\n   if (presence_p)\n     {\n@@ -1486,7 +1494,7 @@ gen_automaton (rtx def)\n     fatal (\"invalid string `%s' in define_automaton\", XSTR (def, 0));\n   for (i = 0; i < vect_length; i++)\n     {\n-      decl = create_node (sizeof (struct decl));\n+      decl = XCREATENODE (struct decl);\n       decl->mode = dm_automaton;\n       decl->pos = 0;\n       DECL_AUTOMATON (decl)->name = check_name (str_automata [i], decl->pos);\n@@ -1539,19 +1547,19 @@ gen_regexp_el (const char *str)\n       len = strlen (str);\n       if (str [len - 1] != ')')\n \tfatal (\"garbage after ) in reservation `%s'\", reserv_str);\n-      dstr = alloca (len - 1);\n+      dstr = XALLOCAVAR (char, len - 1);\n       memcpy (dstr, str + 1, len - 2);\n       dstr [len-2] = '\\0';\n       regexp = gen_regexp_sequence (dstr);\n     }\n   else if (strcmp (str, NOTHING_NAME) == 0)\n     {\n-      regexp = create_node (sizeof *regexp);\n+      regexp = XCREATENODE (struct regexp);\n       regexp->mode = rm_nothing;\n     }\n   else\n     {\n-      regexp = create_node (sizeof *regexp);\n+      regexp = XCREATENODE (struct regexp);\n       regexp->mode = rm_unit;\n       REGEXP_UNIT (regexp)->name = str;\n     }\n@@ -1576,7 +1584,7 @@ gen_regexp_repeat (const char *str)\n       regexp = gen_regexp_el (repeat_vect [0]);\n       for (i = 1; i < els_num; i++)\n \t{\n-\t  repeat = create_node (sizeof (struct regexp));\n+\t  repeat = XCREATENODE (struct regexp);\n \t  repeat->mode = rm_repeat;\n \t  REGEXP_REPEAT (repeat)->regexp = regexp;\n \t  REGEXP_REPEAT (repeat)->repeat_num = atoi (repeat_vect [i]);\n@@ -1605,8 +1613,8 @@ gen_regexp_allof (const char *str)\n     fatal (\"invalid `%s' in reservation `%s'\", str, reserv_str);\n   if (els_num > 1)\n     {\n-      allof = create_node (sizeof (struct regexp)\n-\t\t\t   + sizeof (regexp_t) * (els_num - 1));\n+      allof = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t      + sizeof (regexp_t) * (els_num - 1));\n       allof->mode = rm_allof;\n       REGEXP_ALLOF (allof)->regexps_num = els_num;\n       for (i = 0; i < els_num; i++)\n@@ -1631,8 +1639,8 @@ gen_regexp_oneof (const char *str)\n     fatal (\"invalid `%s' in reservation `%s'\", str, reserv_str);\n   if (els_num > 1)\n     {\n-      oneof = create_node (sizeof (struct regexp)\n-\t\t\t   + sizeof (regexp_t) * (els_num - 1));\n+      oneof = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t      + sizeof (regexp_t) * (els_num - 1));\n       oneof->mode = rm_oneof;\n       REGEXP_ONEOF (oneof)->regexps_num = els_num;\n       for (i = 0; i < els_num; i++)\n@@ -1655,8 +1663,8 @@ gen_regexp_sequence (const char *str)\n   sequence_vect = get_str_vect (str, &els_num, ',', TRUE);\n   if (els_num > 1)\n     {\n-      sequence = create_node (sizeof (struct regexp)\n-\t\t\t      + sizeof (regexp_t) * (els_num - 1));\n+      sequence = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t + sizeof (regexp_t) * (els_num - 1));\n       sequence->mode = rm_sequence;\n       REGEXP_SEQUENCE (sequence)->regexps_num = els_num;\n       for (i = 0; i < els_num; i++)\n@@ -1686,7 +1694,7 @@ gen_reserv (rtx def)\n {\n   decl_t decl;\n \n-  decl = create_node (sizeof (struct decl));\n+  decl = XCREATENODE (struct decl);\n   decl->mode = dm_reserv;\n   decl->pos = 0;\n   DECL_RESERV (decl)->name = check_name (XSTR (def, 0), decl->pos);\n@@ -1704,7 +1712,7 @@ gen_insn_reserv (rtx def)\n {\n   decl_t decl;\n \n-  decl = create_node (sizeof (struct decl));\n+  decl = XCREATENODE (struct decl);\n   decl->mode = dm_insn_reserv;\n   decl->pos = 0;\n   DECL_INSN_RESERV (decl)->name\n@@ -2052,7 +2060,7 @@ process_excls (char **names, int num, pos_t excl_pos ATTRIBUTE_UNUSED)\n \terror (\"`%s' in exclusion is not unit\", names [i]);\n       else\n \t{\n-\t  new_el = create_node (sizeof (struct unit_set_el));\n+\t  new_el = XCREATENODE (struct unit_set_el);\n \t  new_el->unit_decl = DECL_UNIT (decl_in_table);\n \t  new_el->next_unit_set_el = NULL;\n \t  if (last_el == NULL)\n@@ -2105,7 +2113,7 @@ add_excls (unit_set_el_t dest_list, unit_set_el_t source_list,\n \tif (curr_el == NULL)\n \t  {\n \t    /* Element not found - insert.  */\n-\t    copy = copy_node (src, sizeof (*src));\n+\t    copy = XCOPYNODE (struct unit_set_el, src);\n \t    copy->next_unit_set_el = NULL;\n \t    if (prev_el == NULL)\n \t      dst->unit_decl->excl_list = copy;\n@@ -2152,7 +2160,7 @@ process_presence_absence_names (char **names, int num,\n \t\t   : \"`%s' in absence set is not unit\")), names [i]);\n       else\n \t{\n-\t  new_el = create_node (sizeof (struct unit_set_el));\n+\t  new_el = XCREATENODE (struct unit_set_el);\n \t  new_el->unit_decl = DECL_UNIT (decl_in_table);\n \t  new_el->next_unit_set_el = NULL;\n \t  if (last_el == NULL)\n@@ -2187,8 +2195,9 @@ process_presence_absence_patterns (char ***patterns, int num,\n     {\n       for (j = 0; patterns [i] [j] != NULL; j++)\n \t;\n-      new_el = create_node (sizeof (struct pattern_set_el)\n-\t\t\t    + sizeof (struct unit_decl *) * j);\n+      new_el = XCREATENODEVAR (struct pattern_set_el,\n+\t\t\t       sizeof (struct pattern_set_el)\n+\t\t\t       + sizeof (struct unit_decl *) * j);\n       new_el->unit_decls\n \t= (struct unit_decl **) ((char *) new_el\n \t\t\t\t + sizeof (struct pattern_set_el));\n@@ -2334,7 +2343,7 @@ add_presence_absence (unit_set_el_t dest_list,\n \t\t     prev_el != NULL && prev_el->next_pattern_set_el != NULL;\n \t\t     prev_el = prev_el->next_pattern_set_el)\n \t\t  ;\n-\t\tcopy = copy_node (pat, sizeof (*pat));\n+\t\tcopy = XCOPYNODE (struct pattern_set_el, pat);\n \t\tcopy->next_pattern_set_el = NULL;\n \t\tif (prev_el == NULL)\n \t\t  {\n@@ -2664,7 +2673,7 @@ process_regexp (regexp_t regexp)\n \n \t  case dm_reserv:\n \t    DECL_RESERV (decl_in_table)->reserv_is_used = 1;\n-\t    new_regexp = create_node (sizeof (struct regexp));\n+\t    new_regexp = XCREATENODE (struct regexp);\n \t    new_regexp->mode = rm_reserv;\n \t    new_regexp->pos = regexp->pos;\n \t    REGEXP_RESERV (new_regexp)->name = REGEXP_UNIT (regexp)->name;\n@@ -3105,7 +3114,7 @@ static decl_t advance_cycle_insn_decl;\n static void\n add_advance_cycle_insn_decl (void)\n {\n-  advance_cycle_insn_decl = create_node (sizeof (struct decl));\n+  advance_cycle_insn_decl = XCREATENODE (struct decl);\n   advance_cycle_insn_decl->mode = dm_insn_reserv;\n   advance_cycle_insn_decl->pos = no_pos;\n   DECL_INSN_RESERV (advance_cycle_insn_decl)->regexp = NULL;\n@@ -3148,7 +3157,7 @@ get_free_alt_state (void)\n #ifndef NDEBUG\n       allocated_alt_states_num++;\n #endif\n-      result = create_node (sizeof (struct alt_state));\n+      result = XCREATENODE (struct alt_state);\n     }\n   result->state = NULL;\n   result->next_alt_state = NULL;\n@@ -3623,7 +3632,7 @@ get_free_state (int with_reservs, automaton_t automaton)\n #ifndef NDEBUG\n       allocated_states_num++;\n #endif\n-      result = create_node (sizeof (struct state));\n+      result = XCREATENODE (struct state);\n       result->automaton = automaton;\n       result->first_out_arc = NULL;\n       result->unique_num = curr_unique_state_num;\n@@ -3890,7 +3899,7 @@ add_arc (state_t from_state, state_t to_state, ainsn_t ainsn)\n #ifndef NDEBUG\n       allocated_arcs_num++;\n #endif\n-      new_arc = create_node (sizeof (struct arc));\n+      new_arc = XCREATENODE (struct arc);\n       new_arc->to_state = NULL;\n       new_arc->insn = NULL;\n       new_arc->next_out_arc = NULL;\n@@ -3964,7 +3973,7 @@ get_free_automata_list_el (void)\n \t= first_free_automata_list_el->next_automata_list_el;\n     }\n   else\n-    result = create_node (sizeof (struct automata_list_el));\n+    result = XCREATENODE (struct automata_list_el);\n   result->automaton = NULL;\n   result->next_automata_list_el = NULL;\n   return result;\n@@ -4191,7 +4200,7 @@ form_reserv_sets_list (pattern_set_el_t pattern_list)\n   prev = first = NULL;\n   for (el = pattern_list; el != NULL; el = el->next_pattern_set_el)\n     {\n-      curr = create_node (sizeof (struct pattern_reserv));\n+      curr = XCREATENODE (struct pattern_reserv);\n       curr->reserv = alloc_empty_reserv_sets ();\n       curr->next_pattern_reserv = NULL;\n       for (i = 0; i < el->units_num; i++)\n@@ -4362,44 +4371,44 @@ copy_insn_regexp (regexp_t regexp)\n       break;\n \n     case rm_unit:\n-      result = copy_node (regexp, sizeof (struct regexp));\n+      result = XCOPYNODE (struct regexp, regexp);\n       break;\n \n     case rm_repeat:\n-      result = copy_node (regexp, sizeof (struct regexp));\n+      result = XCOPYNODE (struct regexp, regexp);\n       REGEXP_REPEAT (result)->regexp\n         = copy_insn_regexp (REGEXP_REPEAT (regexp)->regexp);\n       break;\n \n     case rm_sequence:\n-      result = copy_node (regexp,\n-                          sizeof (struct regexp) + sizeof (regexp_t)\n-\t\t\t  * (REGEXP_SEQUENCE (regexp)->regexps_num - 1));\n+      result = XCOPYNODEVAR (struct regexp, regexp,\n+\t\t\t     sizeof (struct regexp) + sizeof (regexp_t)\n+\t\t\t     * (REGEXP_SEQUENCE (regexp)->regexps_num - 1));\n       for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \tREGEXP_SEQUENCE (result)->regexps [i]\n \t  = copy_insn_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n       break;\n \n     case rm_allof:\n-      result = copy_node (regexp,\n-                          sizeof (struct regexp) + sizeof (regexp_t)\n-\t\t\t  * (REGEXP_ALLOF (regexp)->regexps_num - 1));\n+      result = XCOPYNODEVAR (struct regexp, regexp,\n+\t\t\t     sizeof (struct regexp) + sizeof (regexp_t)\n+\t\t\t     * (REGEXP_ALLOF (regexp)->regexps_num - 1));\n       for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \tREGEXP_ALLOF (result)->regexps [i]\n \t  = copy_insn_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n       break;\n \n     case rm_oneof:\n-      result = copy_node (regexp,\n-                          sizeof (struct regexp) + sizeof (regexp_t)\n-\t\t\t  * (REGEXP_ONEOF (regexp)->regexps_num - 1));\n+      result = XCOPYNODEVAR (struct regexp, regexp,\n+\t\t\t     sizeof (struct regexp) + sizeof (regexp_t)\n+\t\t\t     * (REGEXP_ONEOF (regexp)->regexps_num - 1));\n       for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n \tREGEXP_ONEOF (result)->regexps [i]\n \t  = copy_insn_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n       break;\n \n     case rm_nothing:\n-      result = copy_node (regexp, sizeof (struct regexp));\n+      result = XCOPYNODE (struct regexp, regexp);\n       break;\n \n     default:\n@@ -4428,8 +4437,8 @@ transform_1 (regexp_t regexp)\n       gcc_assert (repeat_num > 1);\n       operand = REGEXP_REPEAT (regexp)->regexp;\n       pos = regexp->mode;\n-      regexp = create_node (sizeof (struct regexp) + sizeof (regexp_t)\n-\t\t\t    * (repeat_num - 1));\n+      regexp = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t       + sizeof (regexp_t) * (repeat_num - 1));\n       regexp->mode = rm_sequence;\n       regexp->pos = pos;\n       REGEXP_SEQUENCE (regexp)->regexps_num = repeat_num;\n@@ -4465,11 +4474,11 @@ transform_2 (regexp_t regexp)\n \t{\n \t  gcc_assert (REGEXP_SEQUENCE (sequence)->regexps_num > 1\n \t\t      && REGEXP_SEQUENCE (regexp)->regexps_num > 1);\n-\t  result = create_node (sizeof (struct regexp)\n-                                + sizeof (regexp_t)\n-\t\t\t\t* (REGEXP_SEQUENCE (regexp)->regexps_num\n-                                   + REGEXP_SEQUENCE (sequence)->regexps_num\n-                                   - 2));\n+\t  result = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t   + sizeof (regexp_t)\n+\t\t\t\t   * (REGEXP_SEQUENCE (regexp)->regexps_num\n+\t\t\t\t      + REGEXP_SEQUENCE (sequence)->regexps_num\n+\t\t\t\t      - 2));\n \t  result->mode = rm_sequence;\n \t  result->pos = regexp->pos;\n \t  REGEXP_SEQUENCE (result)->regexps_num\n@@ -4509,10 +4518,10 @@ transform_2 (regexp_t regexp)\n \t{\n \t  gcc_assert (REGEXP_ALLOF (allof)->regexps_num > 1\n \t\t      && REGEXP_ALLOF (regexp)->regexps_num > 1);\n-\t  result = create_node (sizeof (struct regexp)\n-                                + sizeof (regexp_t)\n-\t\t\t\t* (REGEXP_ALLOF (regexp)->regexps_num\n-                                   + REGEXP_ALLOF (allof)->regexps_num - 2));\n+\t  result = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t   + sizeof (regexp_t)\n+\t\t\t\t   * (REGEXP_ALLOF (regexp)->regexps_num\n+\t\t\t\t      + REGEXP_ALLOF (allof)->regexps_num - 2));\n \t  result->mode = rm_allof;\n \t  result->pos = regexp->pos;\n \t  REGEXP_ALLOF (result)->regexps_num\n@@ -4552,10 +4561,10 @@ transform_2 (regexp_t regexp)\n \t{\n \t  gcc_assert (REGEXP_ONEOF (oneof)->regexps_num > 1\n \t\t      && REGEXP_ONEOF (regexp)->regexps_num > 1);\n-\t  result = create_node (sizeof (struct regexp)\n-\t\t\t\t+ sizeof (regexp_t)\n-\t\t\t\t* (REGEXP_ONEOF (regexp)->regexps_num\n-                                   + REGEXP_ONEOF (oneof)->regexps_num - 2));\n+\t  result = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t   + sizeof (regexp_t)\n+\t\t\t\t   * (REGEXP_ONEOF (regexp)->regexps_num\n+\t\t\t\t      + REGEXP_ONEOF (oneof)->regexps_num - 2));\n \t  result->mode = rm_oneof;\n \t  result->pos = regexp->pos;\n \t  REGEXP_ONEOF (result)->regexps_num\n@@ -4607,19 +4616,19 @@ transform_3 (regexp_t regexp)\n \t{\n \t  gcc_assert (REGEXP_ONEOF (oneof)->regexps_num > 1\n \t\t      && REGEXP_SEQUENCE (regexp)->regexps_num > 1);\n-\t  result = create_node (sizeof (struct regexp)\n-\t\t\t\t+ sizeof (regexp_t)\n-\t\t\t\t* (REGEXP_ONEOF (oneof)->regexps_num - 1));\n+\t  result = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t   + sizeof (regexp_t)\n+\t\t\t\t   * (REGEXP_ONEOF (oneof)->regexps_num - 1));\n \t  result->mode = rm_oneof;\n \t  result->pos = regexp->pos;\n \t  REGEXP_ONEOF (result)->regexps_num\n \t    = REGEXP_ONEOF (oneof)->regexps_num;\n \t  for (i = 0; i < REGEXP_ONEOF (result)->regexps_num; i++)\n \t    {\n \t      sequence\n-                = create_node (sizeof (struct regexp)\n-                               + sizeof (regexp_t)\n-                               * (REGEXP_SEQUENCE (regexp)->regexps_num - 1));\n+                = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t  + sizeof (regexp_t)\n+\t\t\t\t  * (REGEXP_SEQUENCE (regexp)->regexps_num - 1));\n \t      sequence->mode = rm_sequence;\n \t      sequence->pos = regexp->pos;\n \t      REGEXP_SEQUENCE (sequence)->regexps_num\n@@ -4659,19 +4668,19 @@ transform_3 (regexp_t regexp)\n \t{\n \t  gcc_assert (REGEXP_ONEOF (oneof)->regexps_num > 1\n \t\t      && REGEXP_ALLOF (regexp)->regexps_num > 1);\n-\t  result = create_node (sizeof (struct regexp)\n-\t\t\t\t+ sizeof (regexp_t)\n-\t\t\t\t* (REGEXP_ONEOF (oneof)->regexps_num - 1));\n+\t  result = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t   + sizeof (regexp_t)\n+\t\t\t\t   * (REGEXP_ONEOF (oneof)->regexps_num - 1));\n \t  result->mode = rm_oneof;\n \t  result->pos = regexp->pos;\n \t  REGEXP_ONEOF (result)->regexps_num\n \t    = REGEXP_ONEOF (oneof)->regexps_num;\n \t  for (i = 0; i < REGEXP_ONEOF (result)->regexps_num; i++)\n \t    {\n \t      allof\n-\t\t= create_node (sizeof (struct regexp)\n-                               + sizeof (regexp_t)\n-\t\t\t       * (REGEXP_ALLOF (regexp)->regexps_num - 1));\n+\t\t= XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t  + sizeof (regexp_t)\n+\t\t\t\t  * (REGEXP_ALLOF (regexp)->regexps_num - 1));\n \t      allof->mode = rm_allof;\n \t      allof->pos = regexp->pos;\n \t      REGEXP_ALLOF (allof)->regexps_num\n@@ -4714,8 +4723,8 @@ transform_3 (regexp_t regexp)\n \t{\n \t  gcc_assert (max_seq_length != 1\n \t\t      && REGEXP_ALLOF (regexp)->regexps_num > 1);\n-\t  result = create_node (sizeof (struct regexp)\n-\t\t\t\t+ sizeof (regexp_t) * (max_seq_length - 1));\n+\t  result = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t   + sizeof (regexp_t) * (max_seq_length - 1));\n \t  result->mode = rm_sequence;\n \t  result->pos = regexp->pos;\n \t  REGEXP_SEQUENCE (result)->regexps_num = max_seq_length;\n@@ -4752,9 +4761,9 @@ transform_3 (regexp_t regexp)\n \t\tREGEXP_SEQUENCE (result)->regexps [i] = allof_op;\n \t      else\n \t\t{\n-\t\t  allof = create_node (sizeof (struct regexp)\n-\t\t\t\t       + sizeof (regexp_t)\n-\t\t\t\t       * (allof_length - 1));\n+\t\t  allof = XCREATENODEVAR (struct regexp, sizeof (struct regexp)\n+\t\t\t\t\t  + sizeof (regexp_t)\n+\t\t\t\t\t  * (allof_length - 1));\n \t\t  allof->mode = rm_allof;\n \t\t  allof->pos = regexp->pos;\n \t\t  REGEXP_ALLOF (allof)->regexps_num = allof_length;\n@@ -5669,7 +5678,7 @@ cache_presence (state_t state)\n   sz = (description->query_units_num + sizeof (int) * CHAR_BIT - 1)\n         / (sizeof (int) * CHAR_BIT);\n   \n-  state->presence_signature = create_node (sz * sizeof (int));\n+  state->presence_signature = XCREATENODEVEC (unsigned int, sz);\n   for (i = 0; i < description->units_num; i++)\n     if (units_array [i]->query_p)\n       {\n@@ -6397,7 +6406,7 @@ create_ainsns (void)\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv)\n \t{\n-\t  curr_ainsn = create_node (sizeof (struct ainsn));\n+\t  curr_ainsn = XCREATENODE (struct ainsn);\n \t  curr_ainsn->insn_reserv_decl = DECL_INSN_RESERV (decl);\n \t  curr_ainsn->important_p = FALSE;\n \t  curr_ainsn->next_ainsn = NULL;\n@@ -6455,7 +6464,7 @@ create_automata (void)\n            curr_automaton_num < automata_num;\n            curr_automaton_num++, prev_automaton = curr_automaton)\n         {\n-\t  curr_automaton = create_node (sizeof (struct automaton));\n+\t  curr_automaton = XCREATENODE (struct automaton);\n \t  curr_automaton->ainsn_list = create_ainsns ();\n \t  curr_automaton->corresponding_automaton_decl = NULL;\n \t  curr_automaton->next_automaton = NULL;\n@@ -6476,7 +6485,7 @@ create_automata (void)\n \t  if (decl->mode == dm_automaton\n \t      && DECL_AUTOMATON (decl)->automaton_is_used)\n \t    {\n-\t      curr_automaton = create_node (sizeof (struct automaton));\n+\t      curr_automaton = XCREATENODE (struct automaton);\n \t      curr_automaton->ainsn_list = create_ainsns ();\n \t      curr_automaton->corresponding_automaton_decl\n \t\t= DECL_AUTOMATON (decl);\n@@ -6493,7 +6502,7 @@ create_automata (void)\n \t}\n       if (curr_automaton_num == 0)\n \t{\n-\t  curr_automaton = create_node (sizeof (struct automaton));\n+\t  curr_automaton = XCREATENODE (struct automaton);\n \t  curr_automaton->ainsn_list = create_ainsns ();\n \t  curr_automaton->corresponding_automaton_decl = NULL;\n \t  curr_automaton->next_automaton = NULL;\n@@ -6994,7 +7003,7 @@ create_state_ainsn_table (automaton_t automaton)\n   int full_vect_length;\n   int i;\n \n-  tab = create_node (sizeof (struct state_ainsn_table));\n+  tab = XCREATENODE (struct state_ainsn_table);\n   tab->automaton = automaton;\n \n   tab->comb_vect  = VEC_alloc (vect_el_t,heap, 10000);\n@@ -7908,8 +7917,8 @@ dfa_insn_code_enlarge (int uid)\\n\\\n {\\n\\\n   int i = %s;\\n\\\n   %s = 2 * uid;\\n\\\n-  %s = xrealloc (%s,\\n\\\n-                 %s * sizeof(int));\\n\\\n+  %s = XRESIZEVEC (int, %s,\\n\\\n+                 %s);\\n\\\n   for (; i < %s; i++)\\n\\\n     %s[i] = -1;\\n}\\n\\n\",\n \t   DFA_INSN_CODES_LENGTH_VARIABLE_NAME,\n@@ -7954,8 +7963,8 @@ output_trans_func (void)\n   fprintf (output_file, \"{\\n  int %s;\\n\", INTERNAL_INSN_CODE_NAME);\n   output_internal_insn_code_evaluation (INSN_PARAMETER_NAME,\n \t\t\t\t\tINTERNAL_INSN_CODE_NAME, -1);\n-  fprintf (output_file, \"  return %s (%s, %s);\\n}\\n\\n\",\n-\t   INTERNAL_TRANSITION_FUNC_NAME, INTERNAL_INSN_CODE_NAME, STATE_NAME);\n+  fprintf (output_file, \"  return %s (%s, (struct %s *) %s);\\n}\\n\\n\",\n+\t   INTERNAL_TRANSITION_FUNC_NAME, INTERNAL_INSN_CODE_NAME, CHIP_NAME, STATE_NAME);\n }\n \n /* Output function `min_issue_delay'.  */\n@@ -7973,9 +7982,9 @@ output_min_issue_delay_func (void)\n \t   INTERNAL_INSN_CODE_NAME, ADVANCE_CYCLE_VALUE_NAME);\n   fprintf (output_file, \"    }\\n  else\\n    %s = %s;\\n\",\n \t   INTERNAL_INSN_CODE_NAME, ADVANCE_CYCLE_VALUE_NAME);\n-  fprintf (output_file, \"\\n  return %s (%s, %s);\\n\",\n+  fprintf (output_file, \"\\n  return %s (%s, (struct %s *) %s);\\n\",\n \t   INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME, INTERNAL_INSN_CODE_NAME,\n-\t   STATE_NAME);\n+\t   CHIP_NAME, STATE_NAME);\n   fprintf (output_file, \"}\\n\\n\");\n }\n \n@@ -8008,8 +8017,8 @@ output_dead_lock_func (void)\n {\n   fprintf (output_file, \"int\\n%s (%s %s)\\n\",\n \t   DEAD_LOCK_FUNC_NAME, STATE_TYPE_NAME, STATE_NAME);\n-  fprintf (output_file, \"{\\n  return %s (%s);\\n}\\n\\n\",\n-\t   INTERNAL_DEAD_LOCK_FUNC_NAME, STATE_NAME);\n+  fprintf (output_file, \"{\\n  return %s ((struct %s *) %s);\\n}\\n\\n\",\n+\t   INTERNAL_DEAD_LOCK_FUNC_NAME, CHIP_NAME, STATE_NAME);\n }\n \n /* Output function `internal_reset'.  */\n@@ -8036,8 +8045,8 @@ output_reset_func (void)\n {\n   fprintf (output_file, \"void\\n%s (%s %s)\\n\",\n \t   RESET_FUNC_NAME, STATE_TYPE_NAME, STATE_NAME);\n-  fprintf (output_file, \"{\\n  %s (%s);\\n}\\n\\n\", INTERNAL_RESET_FUNC_NAME,\n-\t   STATE_NAME);\n+  fprintf (output_file, \"{\\n  %s ((struct %s *) %s);\\n}\\n\\n\", INTERNAL_RESET_FUNC_NAME,\n+\t   CHIP_NAME, STATE_NAME);\n }\n \n /* Output function `min_insn_conflict_delay'.  */\n@@ -8284,7 +8293,7 @@ output_get_cpu_unit_code_func (void)\n \t   LOW_VARIABLE_NAME, MIDDLE_VARIABLE_NAME, HIGH_VARIABLE_NAME);\n   fprintf (output_file, \"  static struct %s %s [] =\\n    {\\n\",\n \t   NAME_CODE_STRUCT_NAME, NAME_CODE_TABLE_NAME);\n-  units = xmalloc (sizeof (unit_decl_t) * description->units_num);\n+  units = XNEWVEC (unit_decl_t, description->units_num);\n   memcpy (units, units_array, sizeof (unit_decl_t) * description->units_num);\n   qsort (units, description->units_num, sizeof (unit_decl_t), units_cmp);\n   for (i = 0; i < description->units_num; i++)\n@@ -8416,7 +8425,7 @@ output_dfa_start_func (void)\n   fprintf (output_file,\n \t   \"void\\n%s (void)\\n{\\n  %s = get_max_uid ();\\n\",\n \t   DFA_START_FUNC_NAME, DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n-  fprintf (output_file, \"  %s = xmalloc (%s * sizeof (int));\\n\",\n+  fprintf (output_file, \"  %s = XNEWVEC (int, %s);\\n\",\n \t   DFA_INSN_CODES_VARIABLE_NAME, DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n   fprintf (output_file, \"  %s ();\\n}\\n\\n\", DFA_CLEAN_INSN_CACHE_FUNC_NAME);\n }\n@@ -9099,9 +9108,10 @@ expand_automata (void)\n {\n   int i;\n \n-  description = create_node (sizeof (struct description)\n-\t\t\t     /* One entry for cycle advancing insn.  */\n-\t\t\t     + sizeof (decl_t) * VEC_length (decl_t, decls));\n+  description = XCREATENODEVAR (struct description,\n+\t\t\t\tsizeof (struct description)\n+\t\t\t\t/* One entry for cycle advancing insn.  */\n+\t\t\t\t+ sizeof (decl_t) * VEC_length (decl_t, decls));\n   description->decls_num = VEC_length (decl_t, decls);\n   description->query_units_num = 0;\n   for (i = 0; i < description->decls_num; i++)"}, {"sha": "cfc7037528a6a76268a00ef6dfbc28aed6b39b19", "filename": "gcc/genextract.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -152,7 +152,7 @@ gen_insn (rtx insn, int insn_code_number)\n   /* Otherwise, make a new extraction method.  We stash the arrays\n      after the extraction structure in memory.  */\n \n-  p = xmalloc (sizeof (struct extraction)\n+  p = XNEWVAR (struct extraction, sizeof (struct extraction)\n \t       + op_count*sizeof (char *)\n \t       + dup_count*sizeof (char *)\n \t       + dup_count*sizeof (int));"}, {"sha": "822c84cbed40613ed2544b34158ba0d019aedd09", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -116,7 +116,7 @@ EOID\t[^[:alnum:]_]\n \"nested_ptr\"/{EOID}\t\t{ return NESTED_PTR; }\n [0-9]+\t\t\t\t{ return NUM; }\n \"param\"[0-9]*\"_is\"/{EOID}\t\t{\n-  *yylval = xmemdup (yytext, yyleng, yyleng+1);\n+  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);\n   return PARAM_IS;\n }\n \n@@ -127,28 +127,28 @@ EOID\t[^[:alnum:]_]\n   for (len = yyleng; ISSPACE (yytext[len-1]); len--)\n     ;\n \n-  *yylval = xmemdup (yytext, len, len+1);\n+  *yylval = XDUPVAR (const char, yytext, len, len+1);\n   update_lineno (yytext, yyleng);\n   return SCALAR;\n }\n \n \n {ID}/{EOID}\t\t\t{\n-  *yylval = xmemdup (yytext, yyleng, yyleng+1);\n+  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);\n   return ID;\n }\n \n \\\"([^\"\\\\]|\\\\.)*\\\"\t\t{\n-  *yylval = xmemdup (yytext+1, yyleng-2, yyleng-1);\n+  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng-1);\n   return STRING;\n }\n   /* This \"terminal\" avoids having to parse integer constant expressions.  */\n \"[\"[^\\[\\]]*\"]\"\t\t\t{\n-  *yylval = xmemdup (yytext+1, yyleng-2, yyleng-1);\n+  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng-1);\n   return ARRAY;\n }\n \"'\"(\"\\\\\".|[^\\\\])\"'\"\t\t{\n-  *yylval = xmemdup (yytext+1, yyleng-2, yyleng);\n+  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng);\n   return CHAR;\n }\n "}, {"sha": "72d10781241789cd815a030bb08d93f9aa1a51a7", "filename": "gcc/gengtype.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -439,7 +439,7 @@ read_input_list (const char *listname)\n \t\t\t\t     : lang_dir_names[langno - 1]);\n \n \t\t    bmap |= curlangs;\n-\t\t    set_lang_bitmap ((char *)gt_files[i], bmap);\n+\t\t    set_lang_bitmap (CONST_CAST(char *, gt_files[i]), bmap);\n \t\t    here = committed;\n \t\t    goto next_line;\n \t\t  }\n@@ -1272,9 +1272,9 @@ adjust_field_type (type_p t, options_p opt)\n \tif (params[num] != NULL)\n \t  error_at_line (&lexer_line, \"duplicate `%s' option\", opt->name);\n \tif (! ISDIGIT (opt->name[5]))\n-\t  params[num] = create_pointer ((type_p) opt->info);\n+\t  params[num] = create_pointer (CONST_CAST2(type_p, const char *, opt->info));\n \telse\n-\t  params[num] = (type_p) opt->info;\n+\t  params[num] = CONST_CAST2 (type_p, const char *, opt->info);\n       }\n     else if (strcmp (opt->name, \"special\") == 0)\n       {\n@@ -1323,7 +1323,8 @@ process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n   options_p o;\n   for (o = opt; o; o = o->next)\n     if (strcmp (o->name, \"ptr_alias\") == 0 && level == GC_POINTED_TO)\n-      set_gc_used_type ((type_p) o->info, GC_POINTED_TO, NULL);\n+      set_gc_used_type (CONST_CAST2 (type_p, const char *, o->info),\n+\t\t\tGC_POINTED_TO, NULL);\n     else if (strcmp (o->name, \"maybe_undef\") == 0)\n       *maybe_undef = 1;\n     else if (strcmp (o->name, \"use_params\") == 0)"}, {"sha": "3592388bd642fc1e43201d3beb2afb41a3b4384b", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -1173,7 +1173,7 @@ note_constraint (rtx exp, int lineno)\n \t  return;\n \t}\n     }\n-  new = xmalloc (sizeof (struct constraint_data) + namelen);\n+  new = XNEWVAR (struct constraint_data, sizeof (struct constraint_data) + namelen);\n   strcpy ((char *)new + offsetof(struct constraint_data, name), name);\n   new->namelen = namelen;\n   new->lineno = lineno;"}, {"sha": "bf53944e2973055efaed1149a35540fc0924a31a", "filename": "gcc/genpreds.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -732,7 +732,7 @@ mangle (const char *name)\n       }\n \n   obstack_1grow (rtl_obstack, '\\0');\n-  return obstack_finish (rtl_obstack);\n+  return XOBFINISH (rtl_obstack, const char *);\n }\n \n /* Add one constraint, of any sort, to the tables.  NAME is its name;\n@@ -897,7 +897,7 @@ add_constraint (const char *name, const char *regclass,\n     }\n \n   \n-  c = obstack_alloc (rtl_obstack, sizeof (struct constraint_data));\n+  c = XOBNEW (rtl_obstack, struct constraint_data);\n   c->name = name;\n   c->c_name = need_mangled_name ? mangle (name) : name;\n   c->lineno = lineno;"}, {"sha": "1713f1333144df7678f5559a7bf89c8114fd6a2a", "filename": "gcc/genrecog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -366,7 +366,7 @@ compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n static void\n process_define_predicate (rtx desc)\n {\n-  struct pred_data *pred = xcalloc (sizeof (struct pred_data), 1);\n+  struct pred_data *pred = XCNEW (struct pred_data);\n   char codes[NUM_RTX_CODE];\n   int i;\n \n@@ -474,7 +474,7 @@ extern void debug_decision_list\n static struct decision *\n new_decision (const char *position, struct decision_head *last)\n {\n-  struct decision *new = xcalloc (1, sizeof (struct decision));\n+  struct decision *new = XCNEW (struct decision);\n \n   new->success = *last;\n   new->position = xstrdup (position);\n@@ -890,7 +890,7 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n   if (depth > max_depth)\n     max_depth = depth;\n \n-  subpos = xmalloc (depth + 2);\n+  subpos = XNEWVAR (char, depth + 2);\n   strcpy (subpos, position);\n   subpos[depth + 1] = 0;\n "}, {"sha": "912b81b79c63297313f6dd1c98aa6e407ed3f4e6", "filename": "gcc/gensupport.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbb2a85e7bb2f135308812d2847fc16a44dbe0a/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=7cbb2a85e7bb2f135308812d2847fc16a44dbe0a", "patch": "@@ -1434,15 +1434,15 @@ record_insn_name (int code, const char *name)\n     {\n       int new_size;\n       new_size = (insn_name_ptr_size ? insn_name_ptr_size * 2 : 512);\n-      insn_name_ptr = xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n+      insn_name_ptr = XRESIZEVEC (char *, insn_name_ptr, new_size);\n       memset (insn_name_ptr + insn_name_ptr_size, 0,\n \t      sizeof(char *) * (new_size - insn_name_ptr_size));\n       insn_name_ptr_size = new_size;\n     }\n \n   if (!name || name[0] == '\\0')\n     {\n-      new = xmalloc (strlen (last_real_name) + 10);\n+      new = XNEWVAR (char, strlen (last_real_name) + 10);\n       sprintf (new, \"%s+%d\", last_real_name, code - last_real_code);\n     }\n   else"}]}