{"sha": "8e8b576639cd41490c89668c6aff04853654cf87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4YjU3NjYzOWNkNDE0OTBjODk2NjhjNmFmZjA0ODUzNjU0Y2Y4Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-05-07T22:15:12Z"}, "committer": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-05-07T22:15:12Z"}, "message": "    More cleanups.  Merging patterns with iterators, split out peepholes, etc.\n\n\t* config/h8300/h8300.md (adds/subs splitters): Merge into single\n\tsplitter.\n\t(negation expanders and patterns): Simplify and combine using\n\titerators.\n\t(one_cmpl expanders and patterns): Likewise.\n\t(tablejump, indirect_jump patterns ): Likewise.\n\t(shift and rotate expanders and patterns): Likewise.\n\t(absolute value expander and pattern): Drop expander, rename pattern\n\tto just \"abssf2\"\n\t(peephole2 patterns): Move into...\n\t* config/h8300/peepholes.md: New file.", "tree": {"sha": "ea3a21c6985a5fa5beb6dcd3212c5b10c073b54b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea3a21c6985a5fa5beb6dcd3212c5b10c073b54b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e8b576639cd41490c89668c6aff04853654cf87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8b576639cd41490c89668c6aff04853654cf87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8b576639cd41490c89668c6aff04853654cf87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8b576639cd41490c89668c6aff04853654cf87/comments", "author": null, "committer": null, "parents": [{"sha": "27c1afd533722e0dbc90562618a136653339cc49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c1afd533722e0dbc90562618a136653339cc49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c1afd533722e0dbc90562618a136653339cc49"}], "stats": {"total": 3454, "additions": 1649, "deletions": 1805}, "files": [{"sha": "0db7c65ac83fb770de7e9be9ffac36bb14202172", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8b576639cd41490c89668c6aff04853654cf87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8b576639cd41490c89668c6aff04853654cf87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e8b576639cd41490c89668c6aff04853654cf87", "patch": "@@ -1,5 +1,17 @@\n 2020-05-07 Jeff Law  <law@redhat.com>\n \n+\t* config/h8300/h8300.md (adds/subs splitters): Merge into single\n+\tsplitter.\n+\t(negation expanders and patterns): Simplify and combine using\n+\titerators.\n+\t(one_cmpl expanders and patterns): Likewise.\n+\t(tablejump, indirect_jump patterns ): Likewise.\n+\t(shift and rotate expanders and patterns): Likewise.\n+\t(absolute value expander and pattern): Drop expander, rename pattern\n+\tto just \"abssf2\"\n+\t(peephole2 patterns): Move into...\n+\t* config/h8300/peepholes.md: New file.\n+\t\n \t* config/h8300/constraints.md (L and N): Simplify now that we're not\n \tlonger supporting the original H8/300 chip.\n \t* config/h8300/elf.h (LINK_SPEC): Likewise.  Default to H8/300H."}, {"sha": "4fc55b675e2e8c35d2239dd684ac6e6829ef22bc", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 96, "deletions": 1805, "changes": 1901, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8b576639cd41490c89668c6aff04853654cf87/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8b576639cd41490c89668c6aff04853654cf87/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=8e8b576639cd41490c89668c6aff04853654cf87", "patch": "@@ -698,13 +698,13 @@\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(plus:HI (match_dup 0)\n-\t\t (match_operand:HI 1 \"two_insn_adds_subs_operand\" \"\")))]\n+  [(set (match_operand:HSI 0 \"register_operand\" \"\")\n+\t(plus:HSI (match_dup 0)\n+\t\t (match_operand:HSI 1 \"two_insn_adds_subs_operand\" \"\")))]\n   \"\"\n   [(const_int 0)]\n   {\n-    split_adds_subs (HImode, operands);\n+    split_adds_subs (<MODE>mode, operands);\n     DONE;\n   })\n \n@@ -722,17 +722,6 @@\n    (set (attr \"cc\")\n \t(symbol_ref \"compute_plussi_cc (operands)\"))])\n \n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 0)\n-\t\t (match_operand:SI 1 \"two_insn_adds_subs_operand\" \"\")))]\n-  \"\"\n-  [(const_int 0)]\n-  {\n-    split_adds_subs (SImode, operands);\n-    DONE;\n-  })\n-\n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -1256,47 +1245,29 @@\n   [(set (match_operand:QHSIF 0 \"register_operand\" \"\")\n \t(neg:QHSIF (match_operand:QHSIF 1 \"register_operand\" \"\")))]\n   \"\"\n-  { })\n-\n-(define_insn \"*negqi2\"\n-  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(neg:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"\"\n-  \"neg\t%X0\"\n-  [(set_attr \"length_table\" \"unary\")\n-   (set_attr \"cc\" \"set_zn\")])\n+  \"\")\n \n-(define_expand \"neg<mode>2_h8300\"\n-  [(set (match_dup 2)\n-\t(not:HSI (match_operand:HSI 1 \"register_operand\" \"\")))\n-   (set (match_dup 2) (plus:HSI (match_dup 2) (const_int 1)))\n-   (set (match_operand:HSI 0 \"register_operand\" \"\")\n-\t(match_dup 2))]\n+(define_insn \"*neg<mode>2\"\n+  [(set (match_operand:QHSI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(neg:QHSI (match_operand:QHSI 1 \"h8300_dst_operand\" \"0\")))]\n   \"\"\n   {\n-    operands[2] = gen_reg_rtx (<MODE>mode);\n-  })\n-\n-(define_insn \"*neghi2_h8300hs\"\n-  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(neg:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"h8300_operands_match_p (operands)\"\n-  \"neg.w\t%T0\"\n+    if (<MODE>mode == E_QImode)\n+      return \"neg\t%X0\";\n+    if (<MODE>mode == E_HImode)\n+      return \"neg.w\t%T0\";\n+    if (<MODE>mode == E_SImode)\n+      return \"neg.l\t%S0\";\n+    gcc_unreachable ();\n+  }\n   [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_zn\")])\n \n-(define_insn \"*negsi2_h8300hs\"\n-  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(neg:SI (match_operand:SI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"h8300_operands_match_p (operands)\"\n-  \"neg.l\t%S0\"\n-  [(set_attr \"length_table\" \"unary\")\n-   (set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"*negsf2_h8300hs\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n        (neg:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"xor.w\\\\t#32768,%e0\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -1305,13 +1276,7 @@\n ;; ABSOLUTE VALUE INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*abssf2_h8300hs\"\n+(define_insn \"abssf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n \t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n   \"\"\n@@ -1322,35 +1287,22 @@\n ;; NOT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"one_cmpl<mode>2\"\n-  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n-\t(not:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(not:QI (match_operand:QI 1 \"h8300_dst_operand\" \"0\")))]\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:QHSI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(not:QHSI (match_operand:QHSI 1 \"h8300_dst_operand\" \"0\")))]\n   \"\"\n-  \"not\t%X0\"\n+  {\n+    if (<MODE>mode == E_QImode)\n+      return \"not\t%X0\";\n+    if (<MODE>mode == E_HImode)\n+      return \"not.w\t%T0\";\n+    if (<MODE>mode == E_SImode)\n+      return \"not.l\t%S0\";\n+    gcc_unreachable ();\n+  }\n   [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"*one_cmplhi2_h8300hs\"\n-  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(not:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"h8300_operands_match_p (operands)\"\n-  \"not.w\t%T0\"\n-  [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length_table\" \"unary\")])\n-\n-(define_insn \"*one_cmplsi2_h8300hs\"\n-  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(not:SI (match_operand:SI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"h8300_operands_match_p (operands)\"\n-  \"not.l\t%S0\"\n-  [(set_attr \"cc\" \"set_znv\")\n-   (set_attr \"length_table\" \"unary\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; JUMP INSTRUCTIONS\n@@ -1550,19 +1502,17 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*tablejump_h8300hs_advanced\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"!TARGET_NORMAL_MODE\"\n-  \"jmp\t@%0\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*tablejump_h8300hs_normal\"\n-  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))\n+(define_insn \"tablejump<mode>\"\n+  [(set (pc) (match_operand:P 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_NORMAL_MODE\"\n-  \"jmp @%S0\"\n+  \"\"\n+  {\n+    if (<MODE>mode == E_HImode)\n+      return \"jmp\t@%0\";\n+    if (<MODE>mode == E_SImode)\n+      return \"jmp\t@%S0\";\n+    gcc_unreachable ();\n+  }\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n \n@@ -1573,17 +1523,16 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*indirect_jump_h8300hs_advanced\"\n-  [(set (pc) (match_operand:SI 0 \"jump_address_operand\" \"Vr\"))]\n-  \"!TARGET_NORMAL_MODE\"\n-  \"jmp @%0\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*indirect_jump_h8300hs_normal\"\n-  [(set (pc) (match_operand:HI 0 \"jump_address_operand\" \"Vr\"))]\n-  \"TARGET_NORMAL_MODE\"\n-  \"jmp @%S0\"\n+(define_insn \"*indirect_jump_<mode>\"\n+  [(set (pc) (match_operand:P 0 \"jump_address_operand\" \"Vr\"))]\n+  \"\"\n+  {\n+    if (<MODE>mode == E_HImode)\n+      return \"jmp\t@%0\";\n+    if (<MODE>mode == E_SImode)\n+      return \"jmp\t@%S0\";\n+    gcc_unreachable ();\n+  }\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n \n@@ -1968,58 +1917,72 @@\n ;; For these and other fuzzy reasons, I've decided to go the less pretty but\n ;; easier \"do it at insn emit time\" route.\n \n-;; QI BIT SHIFTS\n \n-(define_expand \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+(define_expand \"ashl<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(ashift:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   {\n-    if (expand_a_shift (QImode, ASHIFT, operands))\n+    if (expand_a_shift (<MODE>mode, ASHIFT, operands))\n     DONE;\n   })\n \n-(define_expand \"ashrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+(define_expand \"ashr<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(ashiftrt:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   {\n-    if (expand_a_shift (QImode, ASHIFTRT, operands))\n+    if (expand_a_shift (<MODE>mode, ASHIFTRT, operands))\n     DONE;\n   })\n \n-(define_expand \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+(define_expand \"lshr<mode>3\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(lshiftrt:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n+\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   {\n-    if (expand_a_shift (QImode, LSHIFTRT, operands))\n+    if (expand_a_shift (<MODE>mode, LSHIFTRT, operands))\n     DONE;\n   })\n \n+;; QI/HI/SI BIT SHIFTS\n+;; Sub-optimal WRT the scratch operand\n+\n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(match_operator:QI 3 \"h8sx_unary_shift_operator\"\n-\t [(match_operand:QI 1 \"h8300_dst_operand\" \"0\")\n+  [(set (match_operand:QHSI 0 \"h8300_dst_operand\" \"=rQ\")\n+\t(match_operator:QHSI 3 \"h8sx_unary_shift_operator\"\n+\t [(match_operand:QHSI 1 \"h8300_dst_operand\" \"0\")\n \t  (match_operand:QI 2 \"const_int_operand\" \"\")]))]\n   \"h8300_operands_match_p (operands)\"\n {\n-  return output_h8sx_shift (operands, 'b', 'X');\n+  if (<MODE>mode == E_QImode)\n+    return output_h8sx_shift (operands, 'b', 'X');\n+  if (<MODE>mode == E_HImode)\n+    return output_h8sx_shift (operands, 'w', 'T');\n+  if (<MODE>mode == E_SImode)\n+    return output_h8sx_shift (operands, 'l', 'S');\n+  gcc_unreachable ();\n }\n   [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_operator:QI 3 \"h8sx_binary_shift_operator\"\n-\t [(match_operand:QI 1 \"register_operand\" \"0\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \"r P3>X\")]))]\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(match_operator:QHSI 3 \"h8sx_binary_shift_operator\"\n+\t [(match_operand:QHSI 1 \"register_operand\" \"0\")\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"r P5>X\")]))]\n   \"\"\n {\n-  return output_h8sx_shift (operands, 'b', 'X');\n+  if (<MODE>mode == QImode)\n+    return output_h8sx_shift (operands, 'b', 'X');\n+  if (<MODE>mode == HImode)\n+    return output_h8sx_shift (operands, 'w', 'T');\n+  if (<MODE>mode == SImode)\n+    return output_h8sx_shift (operands, 'l', 'S');\n+  gcc_unreachable ();\n }\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_znv\")])\n@@ -2039,62 +2002,6 @@\n    (set (attr \"cc\")\n \t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n \n-;; HI BIT SHIFTS\n-\n-(define_expand \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (expand_a_shift (HImode, ASHIFT, operands))\n-    DONE;\n-  })\n-\n-(define_expand \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (expand_a_shift (HImode, LSHIFTRT, operands))\n-    DONE;\n-  })\n-\n-(define_expand \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (expand_a_shift (HImode, ASHIFTRT, operands))\n-    DONE;\n-  })\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(match_operator:HI 3 \"h8sx_unary_shift_operator\"\n-\t [(match_operand:HI 1 \"h8300_dst_operand\" \"0\")\n-\t  (match_operand:QI 2 \"const_int_operand\" \"\")]))]\n-  \"h8300_operands_match_p (operands)\"\n-{\n-  return output_h8sx_shift (operands, 'w', 'T');\n-}\n-  [(set_attr \"length_table\" \"unary\")\n-   (set_attr \"cc\" \"set_znv\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(match_operator:HI 3 \"h8sx_binary_shift_operator\"\n-\t [(match_operand:HI 1 \"register_operand\" \"0\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \"r P4>X\")]))]\n-  \"\"\n-{\n-  return output_h8sx_shift (operands, 'w', 'T');\n-}\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_znv\")])\n-\n (define_insn \"*shifthi\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(match_operator:HI 3 \"nshift_operator\"\n@@ -2110,62 +2017,6 @@\n    (set (attr \"cc\")\n \t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n \n-;;  SI BIT SHIFTS\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (expand_a_shift (SImode, ASHIFT, operands))\n-    DONE;\n-  })\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (expand_a_shift (SImode, LSHIFTRT, operands))\n-    DONE;\n-  })\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (expand_a_shift (SImode, ASHIFTRT, operands))\n-    DONE;\n-  })\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n-\t(match_operator:SI 3 \"h8sx_unary_shift_operator\"\n-\t [(match_operand:SI 1 \"h8300_dst_operand\" \"0\")\n-\t  (match_operand:QI 2 \"const_int_operand\" \"\")]))]\n-  \"h8300_operands_match_p (operands)\"\n-{\n-  return output_h8sx_shift (operands, 'l', 'S');\n-}\n-  [(set_attr \"length_table\" \"unary\")\n-   (set_attr \"cc\" \"set_znv\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 3 \"h8sx_binary_shift_operator\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0\")\n-\t  (match_operand:QI 2 \"nonmemory_operand\" \"r P5>X\")]))]\n-  \"\"\n-{\n-  return output_h8sx_shift (operands, 'l', 'S');\n-}\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_znv\")])\n-\n (define_insn \"*shiftsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(match_operator:SI 3 \"nshift_operator\"\n@@ -2181,6 +2032,7 @@\n    (set (attr \"cc\")\n \t(symbol_ref \"compute_a_shift_cc (insn, operands)\"))])\n \n+\n ;; Split a variable shift into a loop.  If the register containing\n ;; the shift count dies, then we just use that register.\n \n@@ -2251,8 +2103,8 @@\n ;; ----------------------------------------------------------------------\n \n (define_expand \"rotl<mode>3\"\n-  [(set (match_operand:QHI 0 \"register_operand\" \"\")\n-\t(rotate:QHI (match_operand:QHI 1 \"register_operand\" \"\")\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"\")\n+\t(rotate:QHSI (match_operand:QHSI 1 \"register_operand\" \"\")\n \t\t    (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   {\n@@ -2261,30 +2113,9 @@\n   })\n \n (define_insn \"rotl<mode>3_1\"\n-  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n-\t(rotate:QHI (match_operand:QHI 1 \"register_operand\" \"0\")\n-\t\t    (match_operand:QI 2 \"immediate_operand\" \"\")))]\n-  \"\"\n-{\n-  return output_a_rotate (ROTATE, operands);\n-}\n-  [(set (attr \"length\")\n-\t(symbol_ref \"compute_a_rotate_length (operands)\"))])\n-\n-(define_expand \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  {\n-    if (expand_a_rotate (operands))\n-    DONE;\n-  })\n-\n-(define_insn \"rotlsi3_1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"immediate_operand\" \"\")))]\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(rotate:QHSI (match_operand:QHSI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"\")))]\n   \"\"\n {\n   return output_a_rotate (ROTATE, operands);\n@@ -3509,1544 +3340,4 @@\n \t\t      (pc)))]\n   \"\")\n \f\n-;; -----------------------------------------------------------------\n-;; PEEPHOLE PATTERNS\n-;; -----------------------------------------------------------------\n-\n-;; Convert (A >> B) & C to (A & 255) >> B if C == 255 >> B.\n-\n-(define_peephole2\n-  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t   (lshiftrt:HI (match_dup 0)\n-\t\t\t\t(match_operand:HI 1 \"const_int_operand\" \"\")))\n-\t      (clobber (match_operand:HI 2 \"\" \"\"))])\n-   (set (match_dup 0)\n-\t(and:HI (match_dup 0)\n-\t\t(match_operand:HI 3 \"const_int_operand\" \"\")))]\n-  \"INTVAL (operands[3]) == (255 >> INTVAL (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(and:HI (match_dup 0)\n-\t\t(const_int 255)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (lshiftrt:HI (match_dup 0) (match_dup 1)))\n-\t      (clobber (match_dup 2))])]\n-  \"\")\n-\n-;; Convert (A << B) & C to (A & 255) << B if C == 255 << B.\n-\n-(define_peephole2\n-  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t   (ashift:HI (match_dup 0)\n-\t\t\t      (match_operand:HI 1 \"const_int_operand\" \"\")))\n-\t      (clobber (match_operand:HI 2 \"\" \"\"))])\n-   (set (match_dup 0)\n-\t(and:HI (match_dup 0)\n-\t\t(match_operand:HI 3 \"const_int_operand\" \"\")))]\n-  \"INTVAL (operands[3]) == (255 << INTVAL (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(and:HI (match_dup 0)\n-\t\t(const_int 255)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (ashift:HI (match_dup 0) (match_dup 1)))\n-\t      (clobber (match_dup 2))])]\n-  \"\")\n-\n-;; Convert (A >> B) & C to (A & 255) >> B if C == 255 >> B.\n-\n-(define_peephole2\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (lshiftrt:SI (match_dup 0)\n-\t\t\t\t(match_operand:SI 1 \"const_int_operand\" \"\")))\n-\t      (clobber (match_operand:SI 2 \"\" \"\"))])\n-   (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n-  \"INTVAL (operands[3]) == (255 >> INTVAL (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(const_int 255)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (lshiftrt:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (match_dup 2))])]\n-  \"\")\n-\n-;; Convert (A << B) & C to (A & 255) << B if C == 255 << B.\n-\n-(define_peephole2\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (ashift:SI (match_dup 0)\n-\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"\")))\n-\t      (clobber (match_operand:SI 2 \"\" \"\"))])\n-   (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n-  \"INTVAL (operands[3]) == (255 << INTVAL (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(const_int 255)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (ashift:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (match_dup 2))])]\n-  \"\")\n-\n-;; Convert (A >> B) & C to (A & 65535) >> B if C == 65535 >> B.\n-\n-(define_peephole2\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (lshiftrt:SI (match_dup 0)\n-\t\t\t\t(match_operand:SI 1 \"const_int_operand\" \"\")))\n-\t      (clobber (match_operand:SI 2 \"\" \"\"))])\n-   (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n-  \"INTVAL (operands[3]) == (65535 >> INTVAL (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(const_int 65535)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (lshiftrt:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (match_dup 2))])]\n-  \"\")\n-\n-;; Convert (A << B) & C to (A & 65535) << B if C == 65535 << B.\n-\n-(define_peephole2\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (ashift:SI (match_dup 0)\n-\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"\")))\n-\t      (clobber (match_operand:SI 2 \"\" \"\"))])\n-   (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n-  \"INTVAL (operands[3]) == (65535 << INTVAL (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(const_int 65535)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (ashift:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (match_dup 2))])]\n-  \"\")\n-\n-;; Cram four pushes into stm.l.\n-\n-(define_peephole2\n-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS\n-       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n-       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n-       && REGNO (operands[3]) == REGNO (operands[0]) + 3\n-       && (TARGET_H8300SX || REGNO (operands[0]) == 0))\"\n-  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n-\t\t   (match_dup 0))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n-\t\t   (match_dup 1))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))\n-\t\t   (match_dup 2))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -16)))\n-\t\t   (match_dup 3))\n-\t      (set (reg:SI SP_REG)\n-\t\t   (plus:SI (reg:SI SP_REG)\n-\t\t\t    (const_int -16)))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS\n-       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n-       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n-       && REGNO (operands[3]) == REGNO (operands[0]) + 3\n-       && (TARGET_H8300SX || REGNO (operands[0]) == 0))\"\n-  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n-\t\t   (match_dup 0))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n-\t\t   (match_dup 1))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))\n-\t\t   (match_dup 2))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -16)))\n-\t\t   (match_dup 3))\n-\t      (set (reg:HI SP_REG)\n-\t\t   (plus:HI (reg:HI SP_REG)\n-\t\t\t    (const_int -16)))])]\n-  \"\")\n-\n-;; Cram three pushes into stm.l.\n-\n-(define_peephole2\n-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS\n-       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n-       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n-       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))\"\n-  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n-\t\t   (match_dup 0))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n-\t\t   (match_dup 1))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))\n-\t\t   (match_dup 2))\n-\t      (set (reg:SI SP_REG)\n-\t\t   (plus:SI (reg:SI SP_REG)\n-\t\t\t    (const_int -12)))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS\n-       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n-       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n-       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))\"\n-  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n-\t\t   (match_dup 0))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n-\t\t   (match_dup 1))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))\n-\t\t   (match_dup 2))\n-\t      (set (reg:HI SP_REG)\n-\t\t   (plus:HI (reg:HI SP_REG)\n-\t\t\t    (const_int -12)))])]\n-  \"\")\n-\n-;; Cram two pushes into stm.l.\n-\n-(define_peephole2\n-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n-   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS\n-       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n-       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))\"\n-  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n-\t\t   (match_dup 0))\n-\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n-\t\t   (match_dup 1))\n-\t      (set (reg:SI SP_REG)\n-\t\t   (plus:SI (reg:SI SP_REG)\n-\t\t\t    (const_int -8)))])]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))\n-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_operand:SI 1 \"register_operand\" \"\"))]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE\n-   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS\n-       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n-       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))\"\n-  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n-\t\t   (match_dup 0))\n-\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n-\t\t   (match_dup 1))\n-\t      (set (reg:HI SP_REG)\n-\t\t   (plus:HI (reg:HI SP_REG)\n-\t\t\t    (const_int -8)))])]\n-  \"\")\n-\n-;; Turn\n-;;\n-;;   mov.w #2,r0\n-;;   add.w r7,r0  (6 bytes)\n-;;\n-;; into\n-;;\n-;;   mov.w r7,r0\n-;;   adds  #2,r0  (4 bytes)\n-\n-(define_peephole2\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(match_operand:HI 1 \"const_int_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(plus:HI (match_dup 0)\n-\t\t (match_operand:HI 2 \"register_operand\" \"\")))]\n-  \"REG_P (operands[0]) && REG_P (operands[2])\n-   && REGNO (operands[0]) != REGNO (operands[2])\n-   && (satisfies_constraint_J (operands[1])\n-       || satisfies_constraint_L (operands[1])\n-       || satisfies_constraint_N (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(plus:HI (match_dup 0)\n-\t\t (match_dup 1)))]\n-  \"\")\n-\n-;; Turn\n-;;\n-;;   sub.l  er0,er0\n-;;   add.b  #4,r0l\n-;;   add.l  er7,er0  (6 bytes)\n-;;\n-;; into\n-;;\n-;;   mov.l  er7,er0\n-;;   adds   #4,er0   (4 bytes)\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"REG_P (operands[0]) && REG_P (operands[2])\n-   && REGNO (operands[0]) != REGNO (operands[2])\n-   && (satisfies_constraint_L (operands[1])\n-       || satisfies_constraint_N (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 1)))]\n-  \"\")\n-\n-;; Turn\n-;;\n-;;   mov.l er7,er0\n-;;   add.l #10,er0  (takes 8 bytes)\n-;;\n-;; into\n-;;\n-;;   sub.l er0,er0\n-;;   add.b #10,r0l\n-;;   add.l er7,er0  (takes 6 bytes)\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"operands[0] != stack_pointer_rtx\n-   && REG_P (operands[0]) && REG_P (operands[1])\n-   && REGNO (operands[0]) != REGNO (operands[1])\n-   && !satisfies_constraint_L (operands[2])\n-   && !satisfies_constraint_N (operands[2])\n-   && ((INTVAL (operands[2]) & 0xff) == INTVAL (operands[2])\n-       || (INTVAL (operands[2]) & 0xff00) == INTVAL (operands[2])\n-       || INTVAL (operands[2]) == 0xffff\n-       || INTVAL (operands[2]) == 0xfffe)\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 1)))]\n-  \"\")\n-\n-;; Turn\n-;;\n-;;   subs   #1,er4\n-;;   mov.w  r4,r4\n-;;   bne    .L2028\n-;;\n-;; into\n-;;\n-;;   dec.w  #1,r4\n-;;   bne    .L2028\n-\n-(define_peephole2\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(plus:HI (match_dup 0)\n-\t\t (match_operand 1 \"incdec_operand\" \"\")))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(unspec:HI [(match_dup 0)\n-\t\t    (match_dup 1)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  \"\")\n-\n-;; The SImode version of the previous pattern.\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 0)\n-\t\t (match_operand 1 \"incdec_operand\" \"\")))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(unspec:SI [(match_dup 0)\n-\t\t    (match_dup 1)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  \"\")\n-\n-(define_peephole2\n-  [(parallel [(set (cc0)\n-\t\t   (compare (zero_extract:SI (match_operand:QI 0 \"register_operand\" \"\")\n-\t\t\t\t\t     (const_int 1)\n-\t\t\t\t\t     (const_int 7))\n-\t\t\t    (const_int 0)))\n-\t      (clobber (scratch:QI))])\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  [(set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[3] = ((GET_CODE (operands[1]) == EQ)\n-\t\t   ? gen_rtx_GE (VOIDmode, cc0_rtx, const0_rtx)\n-\t\t   : gen_rtx_LT (VOIDmode, cc0_rtx, const0_rtx));\n-  })\n-\n-;; The next three peephole2's will try to transform\n-;;\n-;;   mov.b A,r0l    (or mov.l A,er0)\n-;;   and.l #CST,er0\n-;;\n-;; into\n-;;\n-;;   sub.l er0\n-;;   mov.b A,r0l\n-;;   and.b #CST,r0l (if CST is not 255)\n-\n-(define_peephole2\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(and:SI (match_dup 2)\n-\t\t(const_int 255)))]\n-  \"!reg_overlap_mentioned_p (operands[2], operands[1])\n-   && REGNO (operands[0]) == REGNO (operands[2])\"\n-  [(set (match_dup 2)\n-\t(const_int 0))\n-   (set (strict_low_part (match_dup 0))\n-\t(match_dup 1))]\n-  \"\")\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(const_int 255)))]\n-  \"!reg_overlap_mentioned_p (operands[0], operands[1])\n-   && !(GET_CODE (operands[1]) == MEM && !offsettable_memref_p (operands[1]))\n-   && !(GET_CODE (operands[1]) == MEM && MEM_VOLATILE_P (operands[1]))\"\n-  [(set (match_dup 0)\n-\t(const_int 0))\n-   (set (strict_low_part (match_dup 2))\n-\t(match_dup 3))]\n-  {\n-    operands[2] = gen_lowpart (QImode, operands[0]);\n-    operands[3] = gen_lowpart (QImode, operands[1]);\n-  })\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"nonimmediate_operand\" \"\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(and:SI (match_dup 2)\n-\t\t(match_operand:SI 3 \"const_int_qi_operand\" \"\")))]\n-  \"(GET_MODE (operands[0]) == QImode\n-    || GET_MODE (operands[0]) == HImode\n-    || GET_MODE (operands[0]) == SImode)\n-   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n-   && REGNO (operands[0]) == REGNO (operands[2])\n-   && !reg_overlap_mentioned_p (operands[2], operands[1])\n-   && !(GET_MODE (operands[1]) != QImode\n-\t&& GET_CODE (operands[1]) == MEM\n-\t&& !offsettable_memref_p (operands[1]))\n-   && !(GET_MODE (operands[1]) != QImode\n-\t&& GET_CODE (operands[1]) == MEM\n-\t&& MEM_VOLATILE_P (operands[1]))\"\n-  [(set (match_dup 2)\n-\t(const_int 0))\n-   (set (strict_low_part (match_dup 4))\n-\t(match_dup 5))\n-   (set (match_dup 2)\n-\t(and:SI (match_dup 2)\n-\t\t(match_dup 6)))]\n-  {\n-    operands[4] = gen_lowpart (QImode, operands[0]);\n-    operands[5] = gen_lowpart (QImode, operands[1]);\n-    operands[6] = GEN_INT (~0xff | INTVAL (operands[3]));\n-  })\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(const_int 65280)))]\n-  \"!reg_overlap_mentioned_p (operands[0], operands[1])\"\n-  [(set (match_dup 0)\n-\t(const_int 0))\n-   (set (zero_extract:SI (match_dup 0)\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 8))\n-\t(lshiftrt:SI (match_dup 1)\n-\t\t     (const_int 8)))]\n-  \"\")\n-\n-;; If a load of mem:SI is followed by an AND that turns off the upper\n-;; half, then we can load mem:HI instead.\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"memory_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"!MEM_VOLATILE_P (operands[1])\n-   && offsettable_memref_p (operands[1])\n-   && (INTVAL (operands[2]) & ~0xffff) == 0\n-   && INTVAL (operands[2]) != 255\"\n-  [(set (match_dup 3)\n-\t(match_dup 4))\n-   (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_dup 2)))]\n-  {\n-    operands[3] = gen_lowpart (HImode, operands[0]);\n-    operands[4] = gen_lowpart (HImode, operands[1]);\n-  })\n-\n-;; Convert a memory comparison to a move if there is a scratch register.\n-\n-(define_peephole2\n-  [(match_scratch:QI 1 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:QI 0 \"memory_operand\" \"\")\n-\t\t (const_int 0)))]\n-  \"\"\n-  [(set (match_dup 1)\n-\t(match_dup 0))\n-   (set (cc0) (compare (match_dup 1)\n-\t\t       (const_int 0)))]\n-  \"\")\n-\n-(define_peephole2\n-  [(match_scratch:HI 1 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:HI 0 \"memory_operand\" \"\")\n-\t\t (const_int 0)))]\n-  \"\"\n-  [(set (match_dup 1)\n-\t(match_dup 0))\n-   (set (cc0) (compare (match_dup 1)\n-\t\t       (const_int 0)))]\n-  \"\")\n-\n-(define_peephole2\n-  [(match_scratch:SI 1 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:SI 0 \"memory_operand\" \"\")\n-\t\t (const_int 0)))]\n-  \"\"\n-  [(set (match_dup 1)\n-\t(match_dup 0))\n-   (set (cc0) (compare (match_dup 1)\n-\t\t       (const_int 0)))]\n-  \"\")\n-\n-\n-;; (compare (reg:HI) (const_int)) takes 4 bytes, so we try to achieve\n-;; the equivalent with shorter sequences.  Here is the summary.  Cases\n-;; are grouped for each define_peephole2.\n-;;\n-;; reg  const_int                   use     insn\n-;; --------------------------------------------------------\n-;; dead    -2                       eq/ne   inc.l\n-;; dead    -1                       eq/ne   inc.l\n-;; dead     1                       eq/ne   dec.l\n-;; dead     2                       eq/ne   dec.l\n-;;\n-;; dead     1                       ge/lt shar.l\n-;; dead     3 (H8S)                 ge/lt shar.l\n-;;\n-;; dead     1                       geu/ltu shar.l\n-;; dead     3 (H8S)                 geu/ltu shar.l\n-;;\n-;; ----   255                       ge/lt mov.b\n-;;\n-;; ----   255                       geu/ltu mov.b\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#1,r0\n-;;\tbne\t.L1\n-;;\n-;; into\n-;;\n-;;\tdec.w\t#1,r0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (match_operand:HI 1 \"incdec_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])\"\n-  [(set (match_dup 0)\n-\t(unspec:HI [(match_dup 0)\n-\t\t    (match_dup 4)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (- INTVAL (operands[1]));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#1,r0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tshar.w\tr0\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (match_operand:HI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 2 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (ashiftrt:HI (match_dup 0)\n-\t\t\t\t(match_dup 4)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 2)\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#1,r0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tshar.w\tr0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (match_operand:HI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (ashiftrt:HI (match_dup 0)\n-\t\t\t\t(match_dup 4)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 5)\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#255,r0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.b\tr0h,r0h\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (const_int 255)))\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  [(set (cc0) (compare (and:HI (match_dup 0)\n-\t\t\t       (const_int -256))\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  \"\")\n-\n-;; Transform\n-;;\n-;;\tcmp.w\t#255,r0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.b\tr0h,r0h\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t (const_int 255)))\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  [(set (cc0) (compare (and:HI (match_dup 0)\n-\t\t\t       (const_int -256))\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; (compare (reg:SI) (const_int)) takes 6 bytes, so we try to achieve\n-;; the equivalent with shorter sequences.  Here is the summary.  Cases\n-;; are grouped for each define_peephole2.\n-;;\n-;; reg  const_int                   use     insn\n-;; --------------------------------------------------------\n-;; live    -2                       eq/ne   copy and inc.l\n-;; live    -1                       eq/ne   copy and inc.l\n-;; live     1                       eq/ne   copy and dec.l\n-;; live     2                       eq/ne   copy and dec.l\n-;;\n-;; dead    -2                       eq/ne   inc.l\n-;; dead    -1                       eq/ne   inc.l\n-;; dead     1                       eq/ne   dec.l\n-;; dead     2                       eq/ne   dec.l\n-;;\n-;; dead -131072                     eq/ne   inc.w and test\n-;; dead  -65536                     eq/ne   inc.w and test\n-;; dead   65536                     eq/ne   dec.w and test\n-;; dead  131072                     eq/ne   dec.w and test\n-;;\n-;; dead 0x000000?? except 1 and 2   eq/ne   xor.b and test\n-;; dead 0x0000??00                  eq/ne   xor.b and test\n-;; dead 0x0000ffff                  eq/ne   not.w and test\n-;;\n-;; dead 0xffffff?? except -1 and -2 eq/ne   xor.b and not.l\n-;; dead 0xffff??ff                  eq/ne   xor.b and not.l\n-;; dead 0x40000000 (H8S)            eq/ne   rotl.l and dec.l\n-;; dead 0x80000000                  eq/ne   rotl.l and dec.l\n-;;\n-;; live     1                       ge/lt copy and shar.l\n-;; live     3 (H8S)                 ge/lt copy and shar.l\n-;;\n-;; live     1                       geu/ltu copy and shar.l\n-;; live     3 (H8S)                 geu/ltu copy and shar.l\n-;;\n-;; dead     1                       ge/lt shar.l\n-;; dead     3 (H8S)                 ge/lt shar.l\n-;;\n-;; dead     1                       geu/ltu shar.l\n-;; dead     3 (H8S)                 geu/ltu shar.l\n-;;\n-;; dead     3 (H8/300H)             ge/lt and.b and test\n-;; dead     7                       ge/lt and.b and test\n-;; dead    15                       ge/lt and.b and test\n-;; dead    31                       ge/lt and.b and test\n-;; dead    63                       ge/lt and.b and test\n-;; dead   127                       ge/lt and.b and test\n-;; dead   255                       ge/lt and.b and test\n-;;\n-;; dead     3 (H8/300H)             geu/ltu and.b and test\n-;; dead     7                       geu/ltu and.b and test\n-;; dead    15                       geu/ltu and.b and test\n-;; dead    31                       geu/ltu and.b and test\n-;; dead    63                       geu/ltu and.b and test\n-;; dead   127                       geu/ltu and.b and test\n-;; dead   255                       geu/ltu and.b and test\n-;;\n-;; ---- 65535                       ge/lt mov.w\n-;;\n-;; ---- 65535                       geu/ltu mov.w\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\tdec.l\t#1,er0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"incdec_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])\"\n-  [(set (match_dup 0)\n-\t(unspec:SI [(match_dup 0)\n-\t\t    (match_dup 4)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (- INTVAL (operands[1]));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#65536,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\tdec.l\t#1,e0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == -131072\n-       || INTVAL (operands[1]) == -65536\n-       || INTVAL (operands[1]) == 65536\n-       || INTVAL (operands[1]) == 131072)\"\n-  [(set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 4)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (- INTVAL (operands[1]));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#100,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\txor.b\t#100,er0\n-;;\tmov.l\ter0,er0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])\n-       || (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])\n-       || INTVAL (operands[1]) == 0x0000ffff)\n-   && INTVAL (operands[1]) != 0\n-   && INTVAL (operands[1]) != 1\n-   && INTVAL (operands[1]) != 2\"\n-  [(set (match_dup 0)\n-\t(xor:SI (match_dup 0)\n-\t\t(match_dup 1)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  \"\")\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#-100,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\txor.b\t#99,er0\n-;;\tnot.l\ter0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && ((INTVAL (operands[1]) | 0x00ff) == -1\n-       || (INTVAL (operands[1]) | 0xff00) == -1)\n-   && INTVAL (operands[1]) != -1\n-   && INTVAL (operands[1]) != -2\"\n-  [(set (match_dup 0)\n-\t(xor:SI (match_dup 0)\n-\t\t(match_dup 4)))\n-   (set (match_dup 0)\n-\t(not:SI (match_dup 0)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (INTVAL (operands[1]) ^ -1);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#-2147483648,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\trotl.l\ter0\n-;;\tdec.l\t#1,er0\n-;;\tbeq\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == -2147483647 - 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 1073741824))\"\n-  [(set (match_dup 0)\n-\t(rotate:SI (match_dup 0)\n-\t\t   (match_dup 4)))\n-   (set (match_dup 0)\n-\t(unspec:SI [(match_dup 0)\n-\t\t    (const_int -1)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (INTVAL (operands[1]) == -2147483647 - 1 ? 1 : 2);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\ter0,er1\n-;;\tshar.l\ter1\n-;;\tbgt\t.L1\n-\n-;; We avoid this transformation if we see more than one copy of the\n-;; same compare insn immediately before this one.\n-\n-(define_peephole2\n-  [(match_scratch:SI 4 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 2 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"!peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\n-   && !same_cmp_preceding_p (insn)\"\n-  [(set (match_dup 4)\n-\t(match_dup 0))\n-   (parallel [(set (match_dup 4)\n-\t\t   (ashiftrt:SI (match_dup 4)\n-\t\t\t\t(match_dup 5)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 4)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 2)\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))]\n-  {\n-    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\ter0,er1\n-;;\tshar.l\ter1\n-;;\tbne\t.L1\n-\n-;; We avoid this transformation if we see more than one copy of the\n-;; same compare insn immediately before this one.\n-\n-(define_peephole2\n-  [(match_scratch:SI 4 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n-\t\t         [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"!peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\n-   && !same_cmp_preceding_p (insn)\"\n-  [(set (match_dup 4)\n-\t(match_dup 0))\n-   (parallel [(set (match_dup 4)\n-\t\t   (ashiftrt:SI (match_dup 4)\n-\t\t\t\t(match_dup 5)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 4)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 6)\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))]\n-  {\n-    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-    operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tshar.l\ter0\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 2 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (ashiftrt:SI (match_dup 0)\n-\t\t\t\t(match_dup 4)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 2)\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tshar.l\ter0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 1\n-       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (ashiftrt:SI (match_dup 0)\n-\t\t\t\t(match_dup 4)))\n-\t      (clobber (scratch:QI))])\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 5)\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n-    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#15,er0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tand\t#240,r0l\n-;;\tmov.l\ter0,er0\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 2 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && (INTVAL (operands[1]) == 3\n-       || INTVAL (operands[1]) == 7\n-       || INTVAL (operands[1]) == 15\n-       || INTVAL (operands[1]) == 31\n-       || INTVAL (operands[1]) == 63\n-       || INTVAL (operands[1]) == 127\n-       || INTVAL (operands[1]) == 255)\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_dup 4)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 2)\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (~INTVAL (operands[1]));\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#15,er0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tand\t#240,r0l\n-;;\tmov.l\ter0,er0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"peep2_reg_dead_p (1, operands[0])\n-   && ((TARGET_H8300H && INTVAL (operands[1]) == 3)\n-\t|| INTVAL (operands[1]) == 7\n-\t|| INTVAL (operands[1]) == 15\n-\t|| INTVAL (operands[1]) == 31\n-\t|| INTVAL (operands[1]) == 63\n-\t|| INTVAL (operands[1]) == 127\n-\t|| INTVAL (operands[1]) == 255)\"\n-  [(set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_dup 4)))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 5)\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))]\n-  {\n-    operands[4] = GEN_INT (~INTVAL (operands[1]));\n-    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#65535,er0\n-;;\tbgt\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\te0,e0\n-;;\tbgt\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (const_int 65535)))\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"gtle_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  [(set (cc0) (compare (and:SI (match_dup 0)\n-\t\t\t       (const_int -65536))\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 1)\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  \"\")\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#65535,er0\n-;;\tbhi\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\te0,e0\n-;;\tbne\t.L1\n-\n-(define_peephole2\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (const_int 65535)))\n-   (set (pc)\n-\t(if_then_else (match_operator 1 \"gtuleu_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  [(set (cc0) (compare (and:SI (match_dup 0)\n-\t\t\t       (const_int -65536))\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_dup 3)\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,\n-\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n-  })\n-\n-;; Transform\n-;;\n-;;\tcmp.l\t#1,er0\n-;;\tbeq\t.L1\n-;;\n-;; into\n-;;\n-;;\tmov.l\ter0,er1\n-;;\tdec.l\t#1,er1\n-;;\tbeq\t.L1\n-\n-;; We avoid this transformation if we see more than one copy of the\n-;; same compare insn.\n-\n-(define_peephole2\n-  [(match_scratch:SI 4 \"r\")\n-   (set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t (match_operand:SI 1 \"incdec_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"INTVAL (operands[1]) != 0\n-   && !peep2_reg_dead_p (1, operands[0])\n-   && !same_cmp_following_p (insn)\"\n-  [(set (match_dup 4)\n-\t(match_dup 0))\n-   (set (match_dup 4)\n-\t(unspec:SI [(match_dup 4)\n-\t\t    (match_dup 5)]\n-\t\t   UNSPEC_INCDEC))\n-   (set (cc0) (compare (match_dup 4)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    operands[5] = GEN_INT (- INTVAL (operands[1]));\n-  })\n-\n-;; Narrow the mode of testing if possible.\n-\n-(define_peephole2\n-  [(set (match_operand:HSI 0 \"register_operand\" \"\")\n-\t(and:HSI (match_dup 0)\n-\t\t (match_operand:HSI 1 \"const_int_operand\" \"\")))\n-   (set (cc0) (compare (match_dup 0)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_operator 3 \"eqne_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"((const_int_qi_operand (operands[1], QImode)\n-     || (GET_MODE (operands[0]) == SImode\n-\t && const_int_hi_operand (operands[1], HImode)))\n-    && peep2_reg_dead_p (2, operands[0]))\"\n-  [(set (match_dup 4) (match_dup 6))\n-   (set (cc0) (compare (match_dup 4)\n-\t\t       (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))]\n-  {\n-    enum machine_mode mode;\n-\n-    mode = const_int_qi_operand (operands[1], QImode) ? QImode : HImode;\n-    operands[4] = gen_rtx_REG (mode, REGNO (operands[0]));\n-    operands[5] = gen_int_mode (INTVAL (operands[1]), mode);\n-    operands[6] = gen_rtx_AND (mode, operands[4], operands[5]);\n-  })\n-\n-;; These triggers right at the end of allocation of locals in the\n-;; prologue (and possibly at other places).\n-\n-;; stack adjustment of -4, generate one push\n-;;\n-;; before : 6 bytes, 10 clocks\n-;; after  : 4 bytes, 10 clocks\n-\n-(define_peephole2\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (const_int -4)))\n-   (set (mem:SI (reg:SI SP_REG))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))]\n-  \"!TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_dup 0))]\n-  \"\")\n-\n-;; stack adjustment of -12, generate one push\n-;;\n-;; before : 10 bytes, 14 clocks\n-;; after  :  8 bytes, 14 clocks\n-\n-(define_peephole2\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (const_int -12)))\n-   (set (mem:SI (reg:SI SP_REG))\n-\t(match_operand:SI 0 \"register_operand\" \"\"))]\n-  \"!TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n-  [(set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (const_int -4)))\n-   (set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (const_int -4)))\n-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_dup 0))]\n-  \"\")\n-\n-;; Transform\n-;;\n-;;\tmov\tdst,reg\n-;;\top\treg\n-;;\tmov\treg,dst\n-;;\n-;; into\n-;;\n-;;\top\tdst\n-;;\n-;; if \"reg\" dies at the end of the sequence.\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"memory_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(match_operator 2 \"h8sx_unary_memory_operator\"\n-\t [(match_dup 0)]))\n-   (set (match_operand 3 \"memory_operand\" \"\")\n-\t(match_dup 0))]\n-  \"TARGET_H8300SX\n-   && peep2_reg_dead_p (3, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[3])\n-   && h8sx_mergeable_memrefs_p (operands[3], operands[1])\"\n-  [(set (match_dup 3)\n-\t(match_dup 4))]\n-  {\n-    operands[4] = shallow_copy_rtx (operands[2]);\n-    XEXP (operands[4], 0) = operands[1];\n-  })\n-\n-;; Transform\n-;;\n-;;\tmov\tsrc1,reg\n-;;\tcmp\treg,src2\n-;;\n-;; into\n-;;\n-;;\tcmp\tsrc1,src2\n-;;\n-;; if \"reg\" dies in the comparison.\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"h8300_dst_operand\" \"\"))\n-   (set (cc0)\n-\t(compare (match_dup 0)\n-\t\t (match_operand 2 \"h8300_src_operand\" \"\")))]\n-  \"TARGET_H8300SX\n-   && peep2_reg_dead_p (2, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[2])\n-   && operands[2] != const0_rtx\"\n-  [(set (cc0)\n-\t(compare (match_dup 1)\n-\t\t (match_dup 2)))])\n-\n-;; Likewise for the second operand.\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"h8300_src_operand\" \"\"))\n-   (set (cc0)\n-\t(compare (match_operand 2 \"h8300_dst_operand\" \"\")\n-\t\t (match_dup 0)))]\n-  \"TARGET_H8300SX\n-   && peep2_reg_dead_p (2, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n-  [(set (cc0)\n-\t(compare (match_dup 2)\n-\t\t (match_dup 1)))])\n-\n-;; Combine two moves.\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"h8300_src_operand\" \"\"))\n-   (set (match_operand 2 \"h8300_dst_operand\" \"\")\n-\t(match_dup 0))]\n-  \"TARGET_H8300SX\n-   && peep2_reg_dead_p (2, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n-  [(set (match_dup 2)\n-\t(match_dup 1))])\n-\n-\n+(include \"peepholes.md\")"}, {"sha": "9086bddcf57f69aada79e250d2e42f805a13e2c7", "filename": "gcc/config/h8300/peepholes.md", "status": "added", "additions": 1541, "deletions": 0, "changes": 1541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e8b576639cd41490c89668c6aff04853654cf87/gcc%2Fconfig%2Fh8300%2Fpeepholes.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e8b576639cd41490c89668c6aff04853654cf87/gcc%2Fconfig%2Fh8300%2Fpeepholes.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fpeepholes.md?ref=8e8b576639cd41490c89668c6aff04853654cf87", "patch": "@@ -0,0 +1,1541 @@\n+;; -----------------------------------------------------------------\n+;; PEEPHOLE PATTERNS\n+;; -----------------------------------------------------------------\n+\n+;; Convert (A >> B) & C to (A & 255) >> B if C == 255 >> B.\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:HI (match_dup 0)\n+\t\t\t\t(match_operand:HI 1 \"const_int_operand\" \"\")))\n+\t      (clobber (match_operand:HI 2 \"\" \"\"))])\n+   (set (match_dup 0)\n+\t(and:HI (match_dup 0)\n+\t\t(match_operand:HI 3 \"const_int_operand\" \"\")))]\n+  \"INTVAL (operands[3]) == (255 >> INTVAL (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(and:HI (match_dup 0)\n+\t\t(const_int 255)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (lshiftrt:HI (match_dup 0) (match_dup 1)))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; Convert (A << B) & C to (A & 255) << B if C == 255 << B.\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t   (ashift:HI (match_dup 0)\n+\t\t\t      (match_operand:HI 1 \"const_int_operand\" \"\")))\n+\t      (clobber (match_operand:HI 2 \"\" \"\"))])\n+   (set (match_dup 0)\n+\t(and:HI (match_dup 0)\n+\t\t(match_operand:HI 3 \"const_int_operand\" \"\")))]\n+  \"INTVAL (operands[3]) == (255 << INTVAL (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(and:HI (match_dup 0)\n+\t\t(const_int 255)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ashift:HI (match_dup 0) (match_dup 1)))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; Convert (A >> B) & C to (A & 255) >> B if C == 255 >> B.\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:SI (match_dup 0)\n+\t\t\t\t(match_operand:SI 1 \"const_int_operand\" \"\")))\n+\t      (clobber (match_operand:SI 2 \"\" \"\"))])\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"INTVAL (operands[3]) == (255 >> INTVAL (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(const_int 255)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (lshiftrt:SI (match_dup 0) (match_dup 1)))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; Convert (A << B) & C to (A & 255) << B if C == 255 << B.\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ashift:SI (match_dup 0)\n+\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"\")))\n+\t      (clobber (match_operand:SI 2 \"\" \"\"))])\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"INTVAL (operands[3]) == (255 << INTVAL (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(const_int 255)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 0) (match_dup 1)))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; Convert (A >> B) & C to (A & 65535) >> B if C == 65535 >> B.\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (lshiftrt:SI (match_dup 0)\n+\t\t\t\t(match_operand:SI 1 \"const_int_operand\" \"\")))\n+\t      (clobber (match_operand:SI 2 \"\" \"\"))])\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"INTVAL (operands[3]) == (65535 >> INTVAL (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(const_int 65535)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (lshiftrt:SI (match_dup 0) (match_dup 1)))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; Convert (A << B) & C to (A & 65535) << B if C == 65535 << B.\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ashift:SI (match_dup 0)\n+\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"\")))\n+\t      (clobber (match_operand:SI 2 \"\" \"\"))])\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"INTVAL (operands[3]) == (65535 << INTVAL (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(const_int 65535)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 0) (match_dup 1)))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; Cram four pushes into stm.l.\n+\n+(define_peephole2\n+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 2 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n+   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n+       && REGNO (operands[3]) == REGNO (operands[0]) + 3\n+       && (TARGET_H8300SX || REGNO (operands[0]) == 0))\"\n+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n+\t\t   (match_dup 0))\n+\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n+\t\t   (match_dup 1))\n+\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))\n+\t\t   (match_dup 2))\n+\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -16)))\n+\t\t   (match_dup 3))\n+\t      (set (reg:SI SP_REG)\n+\t\t   (plus:SI (reg:SI SP_REG)\n+\t\t\t    (const_int -16)))])]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 2 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"TARGET_H8300S && TARGET_NORMAL_MODE\n+   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n+       && REGNO (operands[3]) == REGNO (operands[0]) + 3\n+       && (TARGET_H8300SX || REGNO (operands[0]) == 0))\"\n+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n+\t\t   (match_dup 0))\n+\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n+\t\t   (match_dup 1))\n+\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))\n+\t\t   (match_dup 2))\n+\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -16)))\n+\t\t   (match_dup 3))\n+\t      (set (reg:HI SP_REG)\n+\t\t   (plus:HI (reg:HI SP_REG)\n+\t\t\t    (const_int -16)))])]\n+  \"\")\n+\n+;; Cram three pushes into stm.l.\n+\n+(define_peephole2\n+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n+   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n+       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))\"\n+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n+\t\t   (match_dup 0))\n+\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n+\t\t   (match_dup 1))\n+\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))\n+\t\t   (match_dup 2))\n+\t      (set (reg:SI SP_REG)\n+\t\t   (plus:SI (reg:SI SP_REG)\n+\t\t\t    (const_int -12)))])]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"TARGET_H8300S && TARGET_NORMAL_MODE\n+   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && REGNO (operands[2]) == REGNO (operands[0]) + 2\n+       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))\"\n+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n+\t\t   (match_dup 0))\n+\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n+\t\t   (match_dup 1))\n+\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))\n+\t\t   (match_dup 2))\n+\t      (set (reg:HI SP_REG)\n+\t\t   (plus:HI (reg:HI SP_REG)\n+\t\t\t    (const_int -12)))])]\n+  \"\")\n+\n+;; Cram two pushes into stm.l.\n+\n+(define_peephole2\n+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_operand:SI 1 \"register_operand\" \"\"))]\n+  \"TARGET_H8300S && !TARGET_NORMAL_MODE\n+   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))\"\n+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n+\t\t   (match_dup 0))\n+\t      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))\n+\t\t   (match_dup 1))\n+\t      (set (reg:SI SP_REG)\n+\t\t   (plus:SI (reg:SI SP_REG)\n+\t\t\t    (const_int -8)))])]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n+\t(match_operand:SI 1 \"register_operand\" \"\"))]\n+  \"TARGET_H8300S && TARGET_NORMAL_MODE\n+   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS\n+       && REGNO (operands[1]) == REGNO (operands[0]) + 1\n+       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))\"\n+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))\n+\t\t   (match_dup 0))\n+\t      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))\n+\t\t   (match_dup 1))\n+\t      (set (reg:HI SP_REG)\n+\t\t   (plus:HI (reg:HI SP_REG)\n+\t\t\t    (const_int -8)))])]\n+  \"\")\n+\n+;; Turn\n+;;\n+;;   mov.w #2,r0\n+;;   add.w r7,r0  (6 bytes)\n+;;\n+;; into\n+;;\n+;;   mov.w r7,r0\n+;;   adds  #2,r0  (4 bytes)\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(match_operand:HI 1 \"const_int_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t\t (match_operand:HI 2 \"register_operand\" \"\")))]\n+  \"REG_P (operands[0]) && REG_P (operands[2])\n+   && REGNO (operands[0]) != REGNO (operands[2])\n+   && (satisfies_constraint_J (operands[1])\n+       || satisfies_constraint_L (operands[1])\n+       || satisfies_constraint_N (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t\t (match_dup 1)))]\n+  \"\")\n+\n+;; Turn\n+;;\n+;;   sub.l  er0,er0\n+;;   add.b  #4,r0l\n+;;   add.l  er7,er0  (6 bytes)\n+;;\n+;; into\n+;;\n+;;   mov.l  er7,er0\n+;;   adds   #4,er0   (4 bytes)\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n+  \"REG_P (operands[0]) && REG_P (operands[2])\n+   && REGNO (operands[0]) != REGNO (operands[2])\n+   && (satisfies_constraint_L (operands[1])\n+       || satisfies_constraint_N (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_dup 1)))]\n+  \"\")\n+\n+;; Turn\n+;;\n+;;   mov.l er7,er0\n+;;   add.l #10,er0  (takes 8 bytes)\n+;;\n+;; into\n+;;\n+;;   sub.l er0,er0\n+;;   add.b #10,r0l\n+;;   add.l er7,er0  (takes 6 bytes)\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"\")))]\n+  \"operands[0] != stack_pointer_rtx\n+   && REG_P (operands[0]) && REG_P (operands[1])\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && !satisfies_constraint_L (operands[2])\n+   && !satisfies_constraint_N (operands[2])\n+   && ((INTVAL (operands[2]) & 0xff) == INTVAL (operands[2])\n+       || (INTVAL (operands[2]) & 0xff00) == INTVAL (operands[2])\n+       || INTVAL (operands[2]) == 0xffff\n+       || INTVAL (operands[2]) == 0xfffe)\"\n+  [(set (match_dup 0)\n+\t(match_dup 2))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_dup 1)))]\n+  \"\")\n+\n+;; Turn\n+;;\n+;;   subs   #1,er4\n+;;   mov.w  r4,r4\n+;;   bne    .L2028\n+;;\n+;; into\n+;;\n+;;   dec.w  #1,r4\n+;;   bne    .L2028\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(plus:HI (match_dup 0)\n+\t\t (match_operand 1 \"incdec_operand\" \"\")))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(unspec:HI [(match_dup 0)\n+\t\t    (match_dup 1)]\n+\t\t   UNSPEC_INCDEC))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  \"\")\n+\n+;; The SImode version of the previous pattern.\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand 1 \"incdec_operand\" \"\")))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(unspec:SI [(match_dup 0)\n+\t\t    (match_dup 1)]\n+\t\t   UNSPEC_INCDEC))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(parallel [(set (cc0)\n+\t\t   (compare (zero_extract:SI (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t\t\t\t     (const_int 1)\n+\t\t\t\t\t     (const_int 7))\n+\t\t\t    (const_int 0)))\n+\t      (clobber (scratch:QI))])\n+   (set (pc)\n+\t(if_then_else (match_operator 1 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  [(set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[3] = ((GET_CODE (operands[1]) == EQ)\n+\t\t   ? gen_rtx_GE (VOIDmode, cc0_rtx, const0_rtx)\n+\t\t   : gen_rtx_LT (VOIDmode, cc0_rtx, const0_rtx));\n+  })\n+\n+;; The next three peephole2's will try to transform\n+;;\n+;;   mov.b A,r0l    (or mov.l A,er0)\n+;;   and.l #CST,er0\n+;;\n+;; into\n+;;\n+;;   sub.l er0\n+;;   mov.b A,r0l\n+;;   and.b #CST,r0l (if CST is not 255)\n+\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(and:SI (match_dup 2)\n+\t\t(const_int 255)))]\n+  \"!reg_overlap_mentioned_p (operands[2], operands[1])\n+   && REGNO (operands[0]) == REGNO (operands[2])\"\n+  [(set (match_dup 2)\n+\t(const_int 0))\n+   (set (strict_low_part (match_dup 0))\n+\t(match_dup 1))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(const_int 255)))]\n+  \"!reg_overlap_mentioned_p (operands[0], operands[1])\n+   && !(GET_CODE (operands[1]) == MEM && !offsettable_memref_p (operands[1]))\n+   && !(GET_CODE (operands[1]) == MEM && MEM_VOLATILE_P (operands[1]))\"\n+  [(set (match_dup 0)\n+\t(const_int 0))\n+   (set (strict_low_part (match_dup 2))\n+\t(match_dup 3))]\n+  {\n+    operands[2] = gen_lowpart (QImode, operands[0]);\n+    operands[3] = gen_lowpart (QImode, operands[1]);\n+  })\n+\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"nonimmediate_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(and:SI (match_dup 2)\n+\t\t(match_operand:SI 3 \"const_int_qi_operand\" \"\")))]\n+  \"(GET_MODE (operands[0]) == QImode\n+    || GET_MODE (operands[0]) == HImode\n+    || GET_MODE (operands[0]) == SImode)\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && REGNO (operands[0]) == REGNO (operands[2])\n+   && !reg_overlap_mentioned_p (operands[2], operands[1])\n+   && !(GET_MODE (operands[1]) != QImode\n+\t&& GET_CODE (operands[1]) == MEM\n+\t&& !offsettable_memref_p (operands[1]))\n+   && !(GET_MODE (operands[1]) != QImode\n+\t&& GET_CODE (operands[1]) == MEM\n+\t&& MEM_VOLATILE_P (operands[1]))\"\n+  [(set (match_dup 2)\n+\t(const_int 0))\n+   (set (strict_low_part (match_dup 4))\n+\t(match_dup 5))\n+   (set (match_dup 2)\n+\t(and:SI (match_dup 2)\n+\t\t(match_dup 6)))]\n+  {\n+    operands[4] = gen_lowpart (QImode, operands[0]);\n+    operands[5] = gen_lowpart (QImode, operands[1]);\n+    operands[6] = GEN_INT (~0xff | INTVAL (operands[3]));\n+  })\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(const_int 65280)))]\n+  \"!reg_overlap_mentioned_p (operands[0], operands[1])\"\n+  [(set (match_dup 0)\n+\t(const_int 0))\n+   (set (zero_extract:SI (match_dup 0)\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 8))\n+\t(lshiftrt:SI (match_dup 1)\n+\t\t     (const_int 8)))]\n+  \"\")\n+\n+;; If a load of mem:SI is followed by an AND that turns off the upper\n+;; half, then we can load mem:HI instead.\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"memory_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))]\n+  \"!MEM_VOLATILE_P (operands[1])\n+   && offsettable_memref_p (operands[1])\n+   && (INTVAL (operands[2]) & ~0xffff) == 0\n+   && INTVAL (operands[2]) != 255\"\n+  [(set (match_dup 3)\n+\t(match_dup 4))\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_dup 2)))]\n+  {\n+    operands[3] = gen_lowpart (HImode, operands[0]);\n+    operands[4] = gen_lowpart (HImode, operands[1]);\n+  })\n+\n+;; Convert a memory comparison to a move if there is a scratch register.\n+\n+(define_peephole2\n+  [(match_scratch:QI 1 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:QI 0 \"memory_operand\" \"\")\n+\t\t (const_int 0)))]\n+  \"\"\n+  [(set (match_dup 1)\n+\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 1)\n+\t\t       (const_int 0)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(match_scratch:HI 1 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:HI 0 \"memory_operand\" \"\")\n+\t\t (const_int 0)))]\n+  \"\"\n+  [(set (match_dup 1)\n+\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 1)\n+\t\t       (const_int 0)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(match_scratch:SI 1 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:SI 0 \"memory_operand\" \"\")\n+\t\t (const_int 0)))]\n+  \"\"\n+  [(set (match_dup 1)\n+\t(match_dup 0))\n+   (set (cc0) (compare (match_dup 1)\n+\t\t       (const_int 0)))]\n+  \"\")\n+\n+\n+;; (compare (reg:HI) (const_int)) takes 4 bytes, so we try to achieve\n+;; the equivalent with shorter sequences.  Here is the summary.  Cases\n+;; are grouped for each define_peephole2.\n+;;\n+;; reg  const_int                   use     insn\n+;; --------------------------------------------------------\n+;; dead    -2                       eq/ne   inc.l\n+;; dead    -1                       eq/ne   inc.l\n+;; dead     1                       eq/ne   dec.l\n+;; dead     2                       eq/ne   dec.l\n+;;\n+;; dead     1                       ge/lt shar.l\n+;; dead     3 (H8S)                 ge/lt shar.l\n+;;\n+;; dead     1                       geu/ltu shar.l\n+;; dead     3 (H8S)                 geu/ltu shar.l\n+;;\n+;; ----   255                       ge/lt mov.b\n+;;\n+;; ----   255                       geu/ltu mov.b\n+\n+;; Transform\n+;;\n+;;\tcmp.w\t#1,r0\n+;;\tbne\t.L1\n+;;\n+;; into\n+;;\n+;;\tdec.w\t#1,r0\n+;;\tbne\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t (match_operand:HI 1 \"incdec_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])\"\n+  [(set (match_dup 0)\n+\t(unspec:HI [(match_dup 0)\n+\t\t    (match_dup 4)]\n+\t\t   UNSPEC_INCDEC))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (- INTVAL (operands[1]));\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.w\t#1,r0\n+;;\tbgt\t.L1\n+;;\n+;; into\n+;;\n+;;\tshar.w\tr0\n+;;\tbgt\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t (match_operand:HI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtle_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashiftrt:HI (match_dup 0)\n+\t\t\t\t(match_dup 4)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 2)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.w\t#1,r0\n+;;\tbhi\t.L1\n+;;\n+;; into\n+;;\n+;;\tshar.w\tr0\n+;;\tbne\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t (match_operand:HI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashiftrt:HI (match_dup 0)\n+\t\t\t\t(match_dup 4)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 5)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n+\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.w\t#255,r0\n+;;\tbgt\t.L1\n+;;\n+;; into\n+;;\n+;;\tmov.b\tr0h,r0h\n+;;\tbgt\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t (const_int 255)))\n+   (set (pc)\n+\t(if_then_else (match_operator 1 \"gtle_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  [(set (cc0) (compare (and:HI (match_dup 0)\n+\t\t\t       (const_int -256))\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  \"\")\n+\n+;; Transform\n+;;\n+;;\tcmp.w\t#255,r0\n+;;\tbhi\t.L1\n+;;\n+;; into\n+;;\n+;;\tmov.b\tr0h,r0h\n+;;\tbne\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t (const_int 255)))\n+   (set (pc)\n+\t(if_then_else (match_operator 1 \"gtuleu_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  [(set (cc0) (compare (and:HI (match_dup 0)\n+\t\t\t       (const_int -256))\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,\n+\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n+  })\n+\n+;; (compare (reg:SI) (const_int)) takes 6 bytes, so we try to achieve\n+;; the equivalent with shorter sequences.  Here is the summary.  Cases\n+;; are grouped for each define_peephole2.\n+;;\n+;; reg  const_int                   use     insn\n+;; --------------------------------------------------------\n+;; live    -2                       eq/ne   copy and inc.l\n+;; live    -1                       eq/ne   copy and inc.l\n+;; live     1                       eq/ne   copy and dec.l\n+;; live     2                       eq/ne   copy and dec.l\n+;;\n+;; dead    -2                       eq/ne   inc.l\n+;; dead    -1                       eq/ne   inc.l\n+;; dead     1                       eq/ne   dec.l\n+;; dead     2                       eq/ne   dec.l\n+;;\n+;; dead -131072                     eq/ne   inc.w and test\n+;; dead  -65536                     eq/ne   inc.w and test\n+;; dead   65536                     eq/ne   dec.w and test\n+;; dead  131072                     eq/ne   dec.w and test\n+;;\n+;; dead 0x000000?? except 1 and 2   eq/ne   xor.b and test\n+;; dead 0x0000??00                  eq/ne   xor.b and test\n+;; dead 0x0000ffff                  eq/ne   not.w and test\n+;;\n+;; dead 0xffffff?? except -1 and -2 eq/ne   xor.b and not.l\n+;; dead 0xffff??ff                  eq/ne   xor.b and not.l\n+;; dead 0x40000000 (H8S)            eq/ne   rotl.l and dec.l\n+;; dead 0x80000000                  eq/ne   rotl.l and dec.l\n+;;\n+;; live     1                       ge/lt copy and shar.l\n+;; live     3 (H8S)                 ge/lt copy and shar.l\n+;;\n+;; live     1                       geu/ltu copy and shar.l\n+;; live     3 (H8S)                 geu/ltu copy and shar.l\n+;;\n+;; dead     1                       ge/lt shar.l\n+;; dead     3 (H8S)                 ge/lt shar.l\n+;;\n+;; dead     1                       geu/ltu shar.l\n+;; dead     3 (H8S)                 geu/ltu shar.l\n+;;\n+;; dead     3 (H8/300H)             ge/lt and.b and test\n+;; dead     7                       ge/lt and.b and test\n+;; dead    15                       ge/lt and.b and test\n+;; dead    31                       ge/lt and.b and test\n+;; dead    63                       ge/lt and.b and test\n+;; dead   127                       ge/lt and.b and test\n+;; dead   255                       ge/lt and.b and test\n+;;\n+;; dead     3 (H8/300H)             geu/ltu and.b and test\n+;; dead     7                       geu/ltu and.b and test\n+;; dead    15                       geu/ltu and.b and test\n+;; dead    31                       geu/ltu and.b and test\n+;; dead    63                       geu/ltu and.b and test\n+;; dead   127                       geu/ltu and.b and test\n+;; dead   255                       geu/ltu and.b and test\n+;;\n+;; ---- 65535                       ge/lt mov.w\n+;;\n+;; ---- 65535                       geu/ltu mov.w\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#1,er0\n+;;\tbeq\t.L1\n+;;\n+;; into\n+;;\n+;;\tdec.l\t#1,er0\n+;;\tbeq\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"incdec_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])\"\n+  [(set (match_dup 0)\n+\t(unspec:SI [(match_dup 0)\n+\t\t    (match_dup 4)]\n+\t\t   UNSPEC_INCDEC))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (- INTVAL (operands[1]));\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#65536,er0\n+;;\tbeq\t.L1\n+;;\n+;; into\n+;;\n+;;\tdec.l\t#1,e0\n+;;\tbeq\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == -131072\n+       || INTVAL (operands[1]) == -65536\n+       || INTVAL (operands[1]) == 65536\n+       || INTVAL (operands[1]) == 131072)\"\n+  [(set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_dup 4)))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (- INTVAL (operands[1]));\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#100,er0\n+;;\tbeq\t.L1\n+;;\n+;; into\n+;;\n+;;\txor.b\t#100,er0\n+;;\tmov.l\ter0,er0\n+;;\tbeq\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])\n+       || (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])\n+       || INTVAL (operands[1]) == 0x0000ffff)\n+   && INTVAL (operands[1]) != 0\n+   && INTVAL (operands[1]) != 1\n+   && INTVAL (operands[1]) != 2\"\n+  [(set (match_dup 0)\n+\t(xor:SI (match_dup 0)\n+\t\t(match_dup 1)))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  \"\")\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#-100,er0\n+;;\tbeq\t.L1\n+;;\n+;; into\n+;;\n+;;\txor.b\t#99,er0\n+;;\tnot.l\ter0\n+;;\tbeq\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && ((INTVAL (operands[1]) | 0x00ff) == -1\n+       || (INTVAL (operands[1]) | 0xff00) == -1)\n+   && INTVAL (operands[1]) != -1\n+   && INTVAL (operands[1]) != -2\"\n+  [(set (match_dup 0)\n+\t(xor:SI (match_dup 0)\n+\t\t(match_dup 4)))\n+   (set (match_dup 0)\n+\t(not:SI (match_dup 0)))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (INTVAL (operands[1]) ^ -1);\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#-2147483648,er0\n+;;\tbeq\t.L1\n+;;\n+;; into\n+;;\n+;;\trotl.l\ter0\n+;;\tdec.l\t#1,er0\n+;;\tbeq\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == -2147483647 - 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 1073741824))\"\n+  [(set (match_dup 0)\n+\t(rotate:SI (match_dup 0)\n+\t\t   (match_dup 4)))\n+   (set (match_dup 0)\n+\t(unspec:SI [(match_dup 0)\n+\t\t    (const_int -1)]\n+\t\t   UNSPEC_INCDEC))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (INTVAL (operands[1]) == -2147483647 - 1 ? 1 : 2);\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#1,er0\n+;;\tbgt\t.L1\n+;;\n+;; into\n+;;\n+;;\tmov.l\ter0,er1\n+;;\tshar.l\ter1\n+;;\tbgt\t.L1\n+\n+;; We avoid this transformation if we see more than one copy of the\n+;; same compare insn immediately before this one.\n+\n+(define_peephole2\n+  [(match_scratch:SI 4 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtle_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\n+   && !same_cmp_preceding_p (insn)\"\n+  [(set (match_dup 4)\n+\t(match_dup 0))\n+   (parallel [(set (match_dup 4)\n+\t\t   (ashiftrt:SI (match_dup 4)\n+\t\t\t\t(match_dup 5)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 2)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  {\n+    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#1,er0\n+;;\tbhi\t.L1\n+;;\n+;; into\n+;;\n+;;\tmov.l\ter0,er1\n+;;\tshar.l\ter1\n+;;\tbne\t.L1\n+\n+;; We avoid this transformation if we see more than one copy of the\n+;; same compare insn immediately before this one.\n+\n+(define_peephole2\n+  [(match_scratch:SI 4 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n+\t\t         [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\n+   && !same_cmp_preceding_p (insn)\"\n+  [(set (match_dup 4)\n+\t(match_dup 0))\n+   (parallel [(set (match_dup 4)\n+\t\t   (ashiftrt:SI (match_dup 4)\n+\t\t\t\t(match_dup 5)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 6)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  {\n+    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+    operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n+\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#1,er0\n+;;\tbgt\t.L1\n+;;\n+;; into\n+;;\n+;;\tshar.l\ter0\n+;;\tbgt\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtle_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashiftrt:SI (match_dup 0)\n+\t\t\t\t(match_dup 4)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 2)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#1,er0\n+;;\tbhi\t.L1\n+;;\n+;; into\n+;;\n+;;\tshar.l\ter0\n+;;\tbne\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashiftrt:SI (match_dup 0)\n+\t\t\t\t(match_dup 4)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 5)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n+\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#15,er0\n+;;\tbgt\t.L1\n+;;\n+;; into\n+;;\n+;;\tand\t#240,r0l\n+;;\tmov.l\ter0,er0\n+;;\tbgt\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtle_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 3\n+       || INTVAL (operands[1]) == 7\n+       || INTVAL (operands[1]) == 15\n+       || INTVAL (operands[1]) == 31\n+       || INTVAL (operands[1]) == 63\n+       || INTVAL (operands[1]) == 127\n+       || INTVAL (operands[1]) == 255)\"\n+  [(set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_dup 4)))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 2)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (~INTVAL (operands[1]));\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#15,er0\n+;;\tbhi\t.L1\n+;;\n+;; into\n+;;\n+;;\tand\t#240,r0l\n+;;\tmov.l\ter0,er0\n+;;\tbne\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && ((TARGET_H8300H && INTVAL (operands[1]) == 3)\n+\t|| INTVAL (operands[1]) == 7\n+\t|| INTVAL (operands[1]) == 15\n+\t|| INTVAL (operands[1]) == 31\n+\t|| INTVAL (operands[1]) == 63\n+\t|| INTVAL (operands[1]) == 127\n+\t|| INTVAL (operands[1]) == 255)\"\n+  [(set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_dup 4)))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 5)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+  {\n+    operands[4] = GEN_INT (~INTVAL (operands[1]));\n+    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n+\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#65535,er0\n+;;\tbgt\t.L1\n+;;\n+;; into\n+;;\n+;;\tmov.l\te0,e0\n+;;\tbgt\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (const_int 65535)))\n+   (set (pc)\n+\t(if_then_else (match_operator 1 \"gtle_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  [(set (cc0) (compare (and:SI (match_dup 0)\n+\t\t\t       (const_int -65536))\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  \"\")\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#65535,er0\n+;;\tbhi\t.L1\n+;;\n+;; into\n+;;\n+;;\tmov.l\te0,e0\n+;;\tbne\t.L1\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (const_int 65535)))\n+   (set (pc)\n+\t(if_then_else (match_operator 1 \"gtuleu_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  [(set (cc0) (compare (and:SI (match_dup 0)\n+\t\t\t       (const_int -65536))\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,\n+\t\t\t\t  VOIDmode, cc0_rtx, const0_rtx);\n+  })\n+\n+;; Transform\n+;;\n+;;\tcmp.l\t#1,er0\n+;;\tbeq\t.L1\n+;;\n+;; into\n+;;\n+;;\tmov.l\ter0,er1\n+;;\tdec.l\t#1,er1\n+;;\tbeq\t.L1\n+\n+;; We avoid this transformation if we see more than one copy of the\n+;; same compare insn.\n+\n+(define_peephole2\n+  [(match_scratch:SI 4 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"incdec_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"INTVAL (operands[1]) != 0\n+   && !peep2_reg_dead_p (1, operands[0])\n+   && !same_cmp_following_p (insn)\"\n+  [(set (match_dup 4)\n+\t(match_dup 0))\n+   (set (match_dup 4)\n+\t(unspec:SI [(match_dup 4)\n+\t\t    (match_dup 5)]\n+\t\t   UNSPEC_INCDEC))\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    operands[5] = GEN_INT (- INTVAL (operands[1]));\n+  })\n+\n+;; Narrow the mode of testing if possible.\n+\n+(define_peephole2\n+  [(set (match_operand:HSI 0 \"register_operand\" \"\")\n+\t(and:HSI (match_dup 0)\n+\t\t (match_operand:HSI 1 \"const_int_operand\" \"\")))\n+   (set (cc0) (compare (match_dup 0)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t       [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"((const_int_qi_operand (operands[1], QImode)\n+     || (GET_MODE (operands[0]) == SImode\n+\t && const_int_hi_operand (operands[1], HImode)))\n+    && peep2_reg_dead_p (2, operands[0]))\"\n+  [(set (match_dup 4) (match_dup 6))\n+   (set (cc0) (compare (match_dup 4)\n+\t\t       (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  {\n+    enum machine_mode mode;\n+\n+    mode = const_int_qi_operand (operands[1], QImode) ? QImode : HImode;\n+    operands[4] = gen_rtx_REG (mode, REGNO (operands[0]));\n+    operands[5] = gen_int_mode (INTVAL (operands[1]), mode);\n+    operands[6] = gen_rtx_AND (mode, operands[4], operands[5]);\n+  })\n+\n+;; These triggers right at the end of allocation of locals in the\n+;; prologue (and possibly at other places).\n+\n+;; stack adjustment of -4, generate one push\n+;;\n+;; before : 6 bytes, 10 clocks\n+;; after  : 4 bytes, 10 clocks\n+\n+(define_peephole2\n+  [(set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (const_int -4)))\n+   (set (mem:SI (reg:SI SP_REG))\n+\t(match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"!TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_dup 0))]\n+  \"\")\n+\n+;; stack adjustment of -12, generate one push\n+;;\n+;; before : 10 bytes, 14 clocks\n+;; after  :  8 bytes, 14 clocks\n+\n+(define_peephole2\n+  [(set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (const_int -12)))\n+   (set (mem:SI (reg:SI SP_REG))\n+\t(match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"!TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n+  [(set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (const_int -4)))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (const_int -4)))\n+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n+\t(match_dup 0))]\n+  \"\")\n+\n+;; Transform\n+;;\n+;;\tmov\tdst,reg\n+;;\top\treg\n+;;\tmov\treg,dst\n+;;\n+;; into\n+;;\n+;;\top\tdst\n+;;\n+;; if \"reg\" dies at the end of the sequence.\n+\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"memory_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(match_operator 2 \"h8sx_unary_memory_operator\"\n+\t [(match_dup 0)]))\n+   (set (match_operand 3 \"memory_operand\" \"\")\n+\t(match_dup 0))]\n+  \"TARGET_H8300SX\n+   && peep2_reg_dead_p (3, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[3])\n+   && h8sx_mergeable_memrefs_p (operands[3], operands[1])\"\n+  [(set (match_dup 3)\n+\t(match_dup 4))]\n+  {\n+    operands[4] = shallow_copy_rtx (operands[2]);\n+    XEXP (operands[4], 0) = operands[1];\n+  })\n+\n+;; Transform\n+;;\n+;;\tmov\tsrc1,reg\n+;;\tcmp\treg,src2\n+;;\n+;; into\n+;;\n+;;\tcmp\tsrc1,src2\n+;;\n+;; if \"reg\" dies in the comparison.\n+\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"h8300_dst_operand\" \"\"))\n+   (set (cc0)\n+\t(compare (match_dup 0)\n+\t\t (match_operand 2 \"h8300_src_operand\" \"\")))]\n+  \"TARGET_H8300SX\n+   && peep2_reg_dead_p (2, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[2])\n+   && operands[2] != const0_rtx\"\n+  [(set (cc0)\n+\t(compare (match_dup 1)\n+\t\t (match_dup 2)))])\n+\n+;; Likewise for the second operand.\n+\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"h8300_src_operand\" \"\"))\n+   (set (cc0)\n+\t(compare (match_operand 2 \"h8300_dst_operand\" \"\")\n+\t\t (match_dup 0)))]\n+  \"TARGET_H8300SX\n+   && peep2_reg_dead_p (2, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n+  [(set (cc0)\n+\t(compare (match_dup 2)\n+\t\t (match_dup 1)))])\n+\n+;; Combine two moves.\n+\n+(define_peephole2\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"h8300_src_operand\" \"\"))\n+   (set (match_operand 2 \"h8300_dst_operand\" \"\")\n+\t(match_dup 0))]\n+  \"TARGET_H8300SX\n+   && peep2_reg_dead_p (2, operands[0])\n+   && !reg_overlap_mentioned_p (operands[0], operands[2])\"\n+  [(set (match_dup 2)\n+\t(match_dup 1))])\n+\n+"}]}