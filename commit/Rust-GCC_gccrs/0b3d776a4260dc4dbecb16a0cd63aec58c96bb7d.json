{"sha": "0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIzZDc3NmE0MjYwZGM0ZGJlY2IxNmEwY2Q2M2FlYzU4Yzk2YmI3ZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.phys.columbia.edu", "date": "1998-11-25T11:56:54Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1998-11-25T11:56:54Z"}, "message": "cpplib.h: Delete struct import_file.\n\nWed Nov 25 14:54:46 1998  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n        * cpplib.h: Delete struct import_file.  Add ihash element to\n        struct cpp_buffer.  Delete dont_repeat_files and\n        import_hash_table elements from cpp_reader; change\n        all_include_files to a hash table.  Delete all foobar_include\n        / last_foobar_include elements from struct cpp_options; put\n        back four such: quote_include, bracket_include,\n        system_include, after_include.  Redo struct file_name_list\n        completely.  Add new structure type include_hash.  Add\n        prototypes for merge_include_chains and include_hash.  Change\n        prototypes for finclude, find_include_file, and\n        append_include_chain to match changes below.\n        * cppfiles.c (simplify_pathname, include_hash,\n        remap_filename, merge_include_chains): New functions.\n        (add_import, lookup_import, open_include_file): Removed.\n        (INO_T_EQ): Define this (copied from cccp.c).\n        (hack_vms_include_specification): Remove all calls and #if 0\n        out the definition.  It was being called incorrectly and at\n        the wrong times.  Until a VMSie can look at this, it's better\n        to not pretend to support it.\n        (append_include_chain): Change calling convention; now takes\n        only one directory at a time, and sets up the data structure\n        itself.\n        (redundant_include_p): Rewritten - this is now used for all\n        include redundancy, whether by #ifndef, #import, or #pragma\n        once.  Looks up things in the include hash table.\n        (file_cleanup): Decrement pfile->system_include_depth here if\n        it's >0.\n        (find_include_file): Calling convention changed; now passes\n        around a struct include_hash instead of 3 separate parameters.\n        Guts ripped out and replaced with new include_hash mechanism.\n        (finclude): Calling convention changed as for\n        find_include_file.  Error exits pulled out-of-line.  Reformat.\n        (safe_read): Return a long, not an int.\n        (deps_output): Don't recurse.\n        * cpplib.c (is_system_include): Deleted.\n        (path_include): Fix up call to append_include_chain.\n        (do_include): Fix up calls to find_include_file and finclude.\n        Clean up dependency output a bit.  Shorten obnoxiously lengthy\n        #import warning message.  Don't decrement\n        pfile->system_include_depth here.\n        (do_pragma): Understand the include_hash structure.  Reformat.\n        (do_endif): Correct handling of control macros.  Understand\n        the include_hash.\n        (cpp_start_read): Fix up calls to finclude.  Call\n        merge_include_chains.\n        (cpp_handle_option): Fix up calls to append_include_chain.\n        Understand the four partial include chains.\n        (cpp_finish): Add debugging code (#if 0-ed out) for the\n        include_hash.\n        (cpp_cleanup): Free the include_hash, not the import hash and\n        the all_include and dont_repeat lists which no longer exist.\n\nFrom-SVN: r23857", "tree": {"sha": "253cbf23655502b69467d0b7954eb66616f10a2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/253cbf23655502b69467d0b7954eb66616f10a2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/comments", "author": null, "committer": null, "parents": [{"sha": "08b24bda510d3b1eab281447a32816d75be07756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b24bda510d3b1eab281447a32816d75be07756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b24bda510d3b1eab281447a32816d75be07756"}], "stats": {"total": 2094, "additions": 1137, "deletions": 957}, "files": [{"sha": "b684e5bfc2c888a5080a9405727a4b73b0a30be7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d", "patch": "@@ -1,3 +1,59 @@\n+Wed Nov 25 14:54:46 1998  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n+\n+        * cpplib.h: Delete struct import_file.  Add ihash element to\n+        struct cpp_buffer.  Delete dont_repeat_files and\n+        import_hash_table elements from cpp_reader; change\n+        all_include_files to a hash table.  Delete all foobar_include\n+        / last_foobar_include elements from struct cpp_options; put\n+        back four such: quote_include, bracket_include,\n+        system_include, after_include.  Redo struct file_name_list\n+        completely.  Add new structure type include_hash.  Add\n+        prototypes for merge_include_chains and include_hash.  Change\n+        prototypes for finclude, find_include_file, and\n+        append_include_chain to match changes below.\n+\n+        * cppfiles.c (simplify_pathname, include_hash,\n+        remap_filename, merge_include_chains): New functions.\n+        (add_import, lookup_import, open_include_file): Removed.\n+        (INO_T_EQ): Define this (copied from cccp.c).\n+        (hack_vms_include_specification): Remove all calls and #if 0\n+        out the definition.  It was being called incorrectly and at\n+        the wrong times.  Until a VMSie can look at this, it's better\n+        to not pretend to support it.\n+        (append_include_chain): Change calling convention; now takes\n+        only one directory at a time, and sets up the data structure\n+        itself.\n+        (redundant_include_p): Rewritten - this is now used for all\n+        include redundancy, whether by #ifndef, #import, or #pragma\n+        once.  Looks up things in the include hash table.\n+        (file_cleanup): Decrement pfile->system_include_depth here if\n+        it's >0.\n+        (find_include_file): Calling convention changed; now passes\n+        around a struct include_hash instead of 3 separate parameters.\n+        Guts ripped out and replaced with new include_hash mechanism.\n+        (finclude): Calling convention changed as for\n+        find_include_file.  Error exits pulled out-of-line.  Reformat.\n+        (safe_read): Return a long, not an int.\n+        (deps_output): Don't recurse.\n+\n+        * cpplib.c (is_system_include): Deleted.\n+        (path_include): Fix up call to append_include_chain.\n+        (do_include): Fix up calls to find_include_file and finclude.\n+        Clean up dependency output a bit.  Shorten obnoxiously lengthy\n+        #import warning message.  Don't decrement\n+        pfile->system_include_depth here.\n+        (do_pragma): Understand the include_hash structure.  Reformat.\n+        (do_endif): Correct handling of control macros.  Understand\n+        the include_hash.\n+        (cpp_start_read): Fix up calls to finclude.  Call\n+        merge_include_chains.\n+        (cpp_handle_option): Fix up calls to append_include_chain.\n+        Understand the four partial include chains.\n+        (cpp_finish): Add debugging code (#if 0-ed out) for the\n+        include_hash.\n+        (cpp_cleanup): Free the include_hash, not the import hash and\n+        the all_include and dont_repeat lists which no longer exist.\n+\n Wed Nov 25 11:26:19 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* toplev.c (no_new_pseudos): Define."}, {"sha": "b0e20825a12e6fa4ebd8a84e7f8689f95069e8c7", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 714, "deletions": 442, "changes": 1156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d", "patch": "@@ -28,333 +28,447 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n \n /* The entry points to this file are: find_include_file, finclude,\n-   append_include_chain, deps_output, and file_cleanup.\n+   include_hash, append_include_chain, deps_output, and file_cleanup.\n    file_cleanup is only called through CPP_BUFFER(pfile)->cleanup,\n    so it's static anyway. */\n \n-static void add_import\t\t\tPROTO ((cpp_reader *, int, char *));\n-static int lookup_import\t\tPROTO ((cpp_reader *, char *,\n+static struct include_hash *redundant_include_p\n+\t\t\t\t\tPROTO ((cpp_reader *,\n+\t\t\t\t\t\tstruct include_hash *,\n \t\t\t\t\t\tstruct file_name_list *));\n-static int redundant_include_p\t\tPROTO ((cpp_reader *, char *));\n static struct file_name_map *read_name_map\tPROTO ((cpp_reader *, char *));\n static char *read_filename_string\tPROTO ((int, FILE *));\n-static int open_include_file\t\tPROTO ((cpp_reader *, char *,\n+static char *remap_filename \t\tPROTO ((cpp_reader *, char *,\n \t\t\t\t\t\tstruct file_name_list *));\n-static int safe_read\t\t\tPROTO ((int, char *, int));\n+static long safe_read\t\t\tPROTO ((int, char *, int));\n+static void simplify_pathname\t\tPROTO ((char *));\n+\n+#if 0\n+static void hack_vms_include_specification PROTO ((char *));\n+#endif\n \n /* Not safe to prototype these. */\n extern char *xmalloc();\n extern char *xrealloc();\n \n-/* Append a chain of `struct file_name_list's\n-   to the end of the main include chain.\n-   FIRST is the beginning of the chain to append, and LAST is the end.  */\n+/* Windows does not natively support inodes, and neither does MSDOS.\n+   VMS has non-numeric inodes. */\n+#ifdef VMS\n+#define INO_T_EQ(a, b) (!bcmp((char *) &(a), (char *) &(b), sizeof (a)))\n+#elif (defined _WIN32 && !defined CYGWIN) || defined __MSDOS__\n+#define INO_T_EQ(a, b) 0\n+#else\n+#define INO_T_EQ(a, b) ((a) == (b))\n+#endif\n \n+/* Append an entry for dir DIR to list LIST, simplifying it if\n+   possible.  SYS says whether this is a system include directory.\n+   *** DIR is modified in place.  It must be writable and permanently\n+   allocated. LIST is a pointer to the head pointer, because we actually\n+   *prepend* the dir, and reverse the list later (in merge_include_chains). */\n void\n-append_include_chain (pfile, first, last)\n+append_include_chain (pfile, list, dir, sysp)\n      cpp_reader *pfile;\n-     struct file_name_list *first, *last;\n+     struct file_name_list **list;\n+     char *dir;\n+     int sysp;\n {\n-  struct cpp_options *opts = CPP_OPTIONS (pfile);\n-  struct file_name_list *dir;\n-\n-  if (!first || !last)\n-    return;\n-\n-  if (opts->include == 0)\n-    opts->include = first;\n-  else\n-    opts->last_include->next = first;\n+  struct file_name_list *new;\n+  struct stat st;\n+  unsigned int len;\n \n-  if (opts->first_bracket_include == 0)\n-    opts->first_bracket_include = first;\n+  dir = savestring (dir);\n+  simplify_pathname (dir);\n+  if (stat (dir, &st))\n+    {\n+      /* Dirs that don't exist are silently ignored. */\n+      if (errno != ENOENT)\n+\tcpp_perror_with_name (pfile, dir);\n+      return;\n+    }\n \n-  for (dir = first; ; dir = dir->next) {\n-    int len = strlen (dir->fname) + INCLUDE_LEN_FUDGE;\n-    if (len > pfile->max_include_len)\n-      pfile->max_include_len = len;\n-    if (dir == last)\n-      break;\n-  }\n+  if (!S_ISDIR (st.st_mode))\n+    {\n+      cpp_message (pfile, 1, \"%s: %s: Not a directory\", progname, dir);\n+      return;\n+    }\n \n-  last->next = NULL;\n-  opts->last_include = last;\n+  len = strlen(dir);\n+  if (len > pfile->max_include_len)\n+    pfile->max_include_len = len;\n+  \n+  new = (struct file_name_list *)xmalloc (sizeof (struct file_name_list));\n+  new->name = dir;\n+  new->nlen = len;\n+  new->next = *list;\n+  new->ino  = st.st_ino;\n+  new->dev  = st.st_dev;\n+  new->sysp = sysp;\n+  new->name_map = NULL;\n+\n+  *list = new;\n }\n \n-/* Add output to `deps_buffer' for the -M switch.\n-   STRING points to the text to be output.\n-   SPACER is ':' for targets, ' ' for dependencies, zero for text\n-   to be inserted literally.  */\n+/* Merge the four include chains together in the order quote, bracket,\n+   system, after.  Remove duplicate dirs (as determined by\n+   INO_T_EQ()).  The system_include and after_include chains are never\n+   referred to again after this function; all access is through the\n+   bracket_include path.\n+\n+   For the future: Check if the directory is empty (but\n+   how?) and possibly preload the include hash. */\n \n void\n-deps_output (pfile, string, spacer)\n-     cpp_reader *pfile;\n-     char *string;\n-     int spacer;\n+merge_include_chains (opts)\n+     struct cpp_options *opts;\n {\n-  int size;\n-\n-  if (!*string)\n-    return;\n-\n-#ifdef VMS\n-  hack_vms_include_specification (string);\n-#endif\n-\n-  size = strlen (string);\n-\n-#ifndef MAX_OUTPUT_COLUMNS\n-#define MAX_OUTPUT_COLUMNS 72\n-#endif\n-  if (spacer\n-      && pfile->deps_column > 0\n-      && (pfile->deps_column + size) > MAX_OUTPUT_COLUMNS)\n+  struct file_name_list *prev, *next, *cur, *other;\n+  struct file_name_list *quote, *brack, *systm, *after;\n+  struct file_name_list *qtail, *btail, *stail, *atail;\n+\n+  qtail = opts->quote_include;\n+  btail = opts->bracket_include;\n+  stail = opts->system_include;\n+  atail = opts->after_include;\n+\n+  /* Nreverse the four lists. */\n+  prev = 0;\n+  for (cur = qtail; cur; cur = next)\n     {\n-      deps_output (pfile, \" \\\\\\n  \", 0);\n-      pfile->deps_column = 0;\n+      next = cur->next;\n+      cur->next = prev;\n+      prev = cur;\n     }\n+  quote = prev;\n \n-  if (pfile->deps_size + size + 8 > pfile->deps_allocated_size)\n+  prev = 0;\n+  for (cur = btail; cur; cur = next)\n     {\n-      pfile->deps_allocated_size = (pfile->deps_size + size + 50) * 2;\n-      pfile->deps_buffer = (char *) xrealloc (pfile->deps_buffer,\n-\t\t\t\t\t      pfile->deps_allocated_size);\n+      next = cur->next;\n+      cur->next = prev;\n+      prev = cur;\n     }\n-  if (spacer == ' ' && pfile->deps_column > 0)\n-    pfile->deps_buffer[pfile->deps_size++] = ' ';\n-  bcopy (string, &pfile->deps_buffer[pfile->deps_size], size);\n-  pfile->deps_size += size;\n-  pfile->deps_column += size;\n-  if (spacer == ':')\n-    pfile->deps_buffer[pfile->deps_size++] = ':';\n-  pfile->deps_buffer[pfile->deps_size] = 0;\n-}\n+  brack = prev;\n \n-static int\n-file_cleanup (pbuf, pfile)\n-     cpp_buffer *pbuf;\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  if (pbuf->buf)\n+  prev = 0;\n+  for (cur = stail; cur; cur = next)\n     {\n-      free (pbuf->buf);\n-      pbuf->buf = 0;\n+      next = cur->next;\n+      cur->next = prev;\n+      prev = cur;\n     }\n-  return 0;\n-}\n+  systm = prev;\n \n-int\n-find_include_file (pfile, fbeg, flen, fname,\n-\t\t   importing, search_start, foundhere)\n-     cpp_reader *pfile;\n-     char *fbeg;\n-     unsigned long flen;\n-     char *fname;\n-     int importing;\n-     struct file_name_list *search_start;\n-     struct file_name_list **foundhere;\n-{\n-  struct file_name_list *searchptr;\n-  int f;\n-    \n-  /* If specified file name is absolute, just open it.  */\n+  prev = 0;\n+  for (cur = atail; cur; cur = next)\n+    {\n+      next = cur->next;\n+      cur->next = prev;\n+      prev = cur;\n+    }\n+  after = prev;\n \n-  if (*fbeg == '/')\n-  {\n-    strcpy (fname, fbeg);\n-#ifdef VMS\n-    hack_vms_include_specification (fname);\n-#endif\n-    if (redundant_include_p (pfile, fname))\n-      return -2;\n-    if (importing)\n-      f = lookup_import (pfile, fname, NULL_PTR);\n-    else\n-      f = open_include_file (pfile, fname, NULL_PTR);\n-    if (f == -2)\n-      return -2;\t/* Already included this file */\n-  }\n+  /* Paste together bracket, system, and after include chains. */\n+  if (stail)\n+    stail->next = after;\n   else\n-  {\n-    /* Search directory path, trying to open the file.\n-       Copy each filename tried into FNAME.  */\n-\n-    for (searchptr = search_start; searchptr; searchptr = searchptr->next)\n-    {\n-      unsigned int l = 0;\n-      if (searchptr->fname)\n-      {\n-\t/* The empty string in a search path is ignored.\n-\t   This makes it possible to turn off entirely\n-\t   a standard piece of the list.  */\n-\tif (searchptr->fname[0] == 0)\n-\t  continue;\n+    systm = after;\n+  if (btail)\n+    btail->next = systm;\n+  else\n+    brack = systm;\n \n-\tl = strlen (searchptr->fname);\n+  /* This is a bit tricky.\n+     First we drop dupes from the quote-include list.\n+     Then we drop dupes from the bracket-include list.\n+     Finally, if qtail and brack are the same directory,\n+     we cut out qtail.\n \n-\tbcopy (searchptr->fname, fname, l);\n-\tfname[l++] = '/';\n-      }\n+     We can't just merge the lists and then uniquify them because\n+     then we may lose directories from the <> search path that should\n+     be there; consider -Ifoo -Ibar -I- -Ifoo -Iquux. It is however\n+     safe to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written\n+     -Ibar -I- -Ifoo -Iquux. */\n \n-      bcopy (fbeg, &fname[l], flen);\n-      fname[flen+l] = '\\0';\n-#ifdef VMS\n-      hack_vms_include_specification (fname);\n-#endif /* VMS */\n-      /* ??? There are currently 3 separate mechanisms for avoiding processing\n-\t of redundant include files: #import, #pragma once, and\n-\t redundant_include_p.  It would be nice if they were unified.  */\n-      if (redundant_include_p (pfile, fname))\n-\treturn -2;\n-      if (importing)\n-\tf = lookup_import (pfile, fname, searchptr);\n-      else\n-\tf = open_include_file (pfile, fname, searchptr);\n-      if (f == -2)\n-\treturn -2;\t\t\t/* Already included this file */\n-#ifdef EACCES\n-      else if (f == -1 && errno == EACCES)\n-\tcpp_warning (pfile, \"Header file %s exists, but is not readable\",\n-\t\t     fname);\n-#endif\n-      if (f >= 0)\n-\tbreak;\n+  for (cur = quote; cur; cur = cur->next)\n+    {\n+      for (other = quote; other != cur; other = other->next)\n+        if (INO_T_EQ (cur->ino, other->ino)\n+\t    && cur->dev == other->dev)\n+          {\n+\t    prev->next = cur->next;\n+\t    free (cur->name);\n+\t    free (cur);\n+\t    cur = prev;\n+\t    break;\n+\t  }\n+      prev = cur;\n     }\n-  }\n+  qtail = prev;\n \n-  if (f < 0)\n+  for (cur = brack; cur; cur = cur->next)\n     {\n-      /* A file that was not found.  */\n-      bcopy (fbeg, fname, flen);\n-      fname[flen] = 0;\n-\n-      return -1;\n+      for (other = brack; other != cur; other = other->next)\n+        if (INO_T_EQ (cur->ino, other->ino)\n+\t    && cur->dev == other->dev)\n+          {\n+\t    prev->next = cur->next;\n+\t    free (cur->name);\n+\t    free (cur);\n+\t    cur = prev;\n+\t    break;\n+\t  }\n+      prev = cur;\n     }\n-  else\n-    {\n-      /* Check to see if this include file is a once-only include file.\n-\t If so, give up.  */\n-\n-      struct file_name_list *ptr;\n \n-      for (ptr = pfile->dont_repeat_files; ptr; ptr = ptr->next)\n-\t  if (!strcmp (ptr->fname, fname))\n+  if (quote)\n+    {\n+      if (INO_T_EQ (qtail->ino, brack->ino) && qtail->dev == brack->dev)\n+        {\n+\t  if (quote == qtail)\n+\t    {\n+\t      free (quote->name);\n+\t      free (quote);\n+\t      quote = brack;\n+\t    }\n+\t  else\n \t    {\n-\t      close (f);\n-\t      return -2;\t\t/* This file was once'd.  */\n+\t      cur = quote;\n+\t      while (cur->next != qtail)\n+\t\t  cur = cur->next;\n+\t      cur->next = brack;\n+\t      free (qtail->name);\n+\t      free (qtail);\n \t    }\n+\t}\n+      else\n+\t  qtail->next = brack;\n     }\n+  else\n+      quote = brack;\n \n-    /* Record file on \"seen\" list for #import.  */\n-    add_import (pfile, f, fname);\n-\n-    *foundhere = searchptr;\n-    return f;\n+  opts->quote_include = quote;\n+  opts->bracket_include = brack;\n+  opts->system_include = NULL;\n+  opts->after_include = NULL;\n }\n \n-/* Return nonzero if there is no need to include file NAME\n-   because it has already been included and it contains a conditional\n-   to make a repeated include do nothing.  */\n+/* Look up or add an entry to the table of all includes.  This table\n+ is indexed by the name as it appears in the #include line.  The\n+ ->next_this_file chain stores all different files with the same\n+ #include name (there are at least three ways this can happen).  The\n+ hash function could probably be improved a bit. */\n \n-static int\n-redundant_include_p (pfile, name)\n+struct include_hash *\n+include_hash (pfile, fname, add)\n      cpp_reader *pfile;\n-     char *name;\n+     char *fname;\n+     int add;\n {\n-  struct file_name_list *l = pfile->all_include_files;\n-  for (; l; l = l->next)\n-    if (! strcmp (name, l->fname)\n-\t&& l->control_macro\n-\t&& cpp_lookup (pfile, l->control_macro, -1, -1))\n-      return 1;\n-  return 0;\n-}\n+  unsigned int hash = 0;\n+  struct include_hash *l, *m;\n+  char *f = fname;\n \n+  while (*f)\n+    hash += *f++;\n \n+  l = pfile->all_include_files[hash % ALL_INCLUDE_HASHSIZE];\n+  m = 0;\n+  for (; l; m = l, l = l->next)\n+    if (!strcmp (l->nshort, fname))\n+      return l;\n \n-/* Maintain and search list of included files, for #import.  */\n+  if (!add)\n+    return 0;\n+  \n+  l = (struct include_hash *) xmalloc (sizeof (struct include_hash));\n+  l->next = NULL;\n+  l->next_this_file = NULL;\n+  l->foundhere = NULL;\n+  l->buf = NULL;\n+  l->limit = NULL;\n+  if (m)\n+    m->next = l;\n+  else\n+    pfile->all_include_files[hash % ALL_INCLUDE_HASHSIZE] = l;\n+  \n+  return l;\n+}\n \n-/* Hash a file name for import_hash_table.  */\n+/* Return 0 if the file pointed to by IHASH has never been included before,\n+         -1 if it has been included before and need not be again,\n+\t or a pointer to an IHASH entry which is the file to be reread.\n+   \"Never before\" is with respect to the position in ILIST.\n \n-static int \n-import_hash (f)\n-     char *f;\n-{\n-  int val = 0;\n+   This will not detect redundancies involving odd uses of the\n+   `current directory' rule for \"\" includes.  They aren't quite\n+   pathological, but I think they are rare enough not to worry about.\n+   The simplest example is:\n \n-  while (*f) val += *f++;\n-  return (val%IMPORT_HASH_SIZE);\n-}\n+   top.c:\n+   #include \"a/a.h\"\n+   #include \"b/b.h\"\n \n-/* Search for file FILENAME in import_hash_table.\n-   Return -2 if found, either a matching name or a matching inode.\n-   Otherwise, open the file and return a file descriptor if successful\n-   or -1 if unsuccessful.  */\n+   a/a.h:\n+   #include \"../b/b.h\"\n \n-static int\n-lookup_import (pfile, filename, searchptr)\n+   and the problem is that for `current directory' includes,\n+   ihash->foundhere is not on any of the global include chains,\n+   so the test below (i->foundhere == l) may be false even when\n+   the directories are in fact the same.  */\n+\n+static struct include_hash *\n+redundant_include_p (pfile, ihash, ilist)\n      cpp_reader *pfile;\n-     char *filename;\n-     struct file_name_list *searchptr;\n+     struct include_hash *ihash;\n+     struct file_name_list *ilist;\n {\n-  struct import_file *i;\n-  int h;\n-  int hashval;\n-  struct stat sb;\n-  int fd;\n+  struct file_name_list *l;\n+  struct include_hash *i;\n \n-  hashval = import_hash (filename);\n+  if (! ihash->foundhere)\n+    return 0;\n \n-  /* Attempt to find file in list of already included files */\n-  i = pfile->import_hash_table[hashval];\n+  for (i = ihash; i; i = i->next_this_file)\n+    for (l = ilist; l; l = l->next)\n+       if (i->foundhere == l)\n+\t /* The control_macro works like this: If it's NULL, the file\n+\t    is to be included again.  If it's \"\", the file is never to\n+\t    be included again.  If it's a string, the file is not to be\n+\t    included again if the string is the name of a defined macro. */\n+\t return (i->control_macro\n+\t\t && (i->control_macro[0] == '\\0'\n+\t\t     || cpp_lookup (pfile, i->control_macro, -1, -1)))\n+\t     ? (struct include_hash *)-1 : i;\n \n-  while (i) {\n-    if (!strcmp (filename, i->name))\n-      return -2;\t\t/* return found */\n-    i = i->next;\n-  }\n-  /* Open it and try a match on inode/dev */\n-  fd = open_include_file (pfile, filename, searchptr);\n-  if (fd < 0)\n-    return fd;\n-  fstat (fd, &sb);\n-  for (h = 0; h < IMPORT_HASH_SIZE; h++) {\n-    i = pfile->import_hash_table[h];\n-    while (i) {\n-      /* Compare the inode and the device.\n-\t Supposedly on some systems the inode is not a scalar.  */\n-      if (!bcmp ((char *) &i->inode, (char *) &sb.st_ino, sizeof (sb.st_ino))\n-\t  && i->dev == sb.st_dev) {\n-        close (fd);\n-        return -2;\t\t/* return found */\n-      }\n-      i = i->next;\n-    }\n-  }\n-  return fd;\t\t\t/* Not found, return open file */\n+  return 0;\n }\n \n-/* Add the file FNAME, open on descriptor FD, to import_hash_table.  */\n+static int\n+file_cleanup (pbuf, pfile)\n+     cpp_buffer *pbuf;\n+     cpp_reader *pfile;\n+{\n+  if (pbuf->buf)\n+    {\n+      free (pbuf->buf);\n+      pbuf->buf = 0;\n+    }\n+  if (pfile->system_include_depth)\n+    pfile->system_include_depth--;\n+  return 0;\n+}\n \n-static void\n-add_import (pfile, fd, fname)\n+/* Search for include file FNAME in the include chain starting at\n+   SEARCH_START.  Return -2 if this file doesn't need to be included\n+   (because it was included already and it's marked idempotent),\n+   -1 if an error occurred, or a file descriptor open on the file.\n+   *IHASH is set to point to the include hash entry for this file, and\n+   *BEFORE is 1 if the file was included before (but needs to be read\n+   again). */\n+int\n+find_include_file (pfile, fname, search_start, ihash, before)\n      cpp_reader *pfile;\n-     int fd;\n      char *fname;\n+     struct file_name_list *search_start;\n+     struct include_hash **ihash;\n+     int *before;\n {\n-  struct import_file *i;\n-  int hashval;\n-  struct stat sb;\n-\n-  hashval = import_hash (fname);\n-  fstat (fd, &sb);\n-  i = (struct import_file *)xmalloc (sizeof (struct import_file));\n-  i->name = (char *)xmalloc (strlen (fname)+1);\n-  strcpy (i->name, fname);\n-  bcopy ((char *) &sb.st_ino, (char *) &i->inode, sizeof (sb.st_ino));\n-  i->dev = sb.st_dev;\n-  i->next = pfile->import_hash_table[hashval];\n-  pfile->import_hash_table[hashval] = i;\n+  struct file_name_list *l;\n+  struct include_hash *ih, *jh;\n+  int f, len;\n+  char *name;\n+  \n+  ih = include_hash (pfile, fname, 1);\n+  jh = redundant_include_p (pfile, ih,\n+\t\t\t    fname[0] == '/' ? ABSOLUTE_PATH : search_start);\n+\n+  if (jh != 0)\n+    {\n+      *before = 1;\n+      *ihash = jh;\n+\n+      if (jh == (struct include_hash *)-1)\n+\treturn -2;\n+      else\n+\treturn open (jh->name, O_RDONLY, 0666);\n+    }\n+\n+  if (ih->foundhere)\n+    /* A file is already known by this name, but it's not the same file.\n+       Allocate another include_hash block and add it to the next_this_file\n+       chain. */\n+    {\n+      jh = (struct include_hash *)xmalloc (sizeof (struct include_hash));\n+      while (ih->next_this_file) ih = ih->next_this_file;\n+\n+      ih->next_this_file = jh;\n+      jh = ih;\n+      ih = ih->next_this_file;\n+\n+      ih->next = NULL;\n+      ih->next_this_file = NULL;\n+      ih->buf = NULL;\n+      ih->limit = NULL;\n+    }\n+  *before = 0;\n+  *ihash = ih;\n+  ih->nshort = savestring (fname);\n+  ih->control_macro = NULL;\n+  \n+  /* If the pathname is absolute, just open it. */ \n+  if (fname[0] == '/')\n+    {\n+      ih->foundhere = ABSOLUTE_PATH;\n+      ih->name = ih->nshort;\n+      return open (ih->name, O_RDONLY, 0666);\n+    }\n+\n+  /* Search directory path, trying to open the file. */\n+\n+  /* The first entry in the search list may be a buffer-specific entry,\n+     and its directory name may be longer than max_include_len.  Adjust\n+     as appropriate. */\n+ if (pfile->max_include_len < search_start->nlen)\n+    pfile->max_include_len = search_start->nlen;\n+  len = strlen (fname);\n+  name = xmalloc (len + pfile->max_include_len + 2 + INCLUDE_LEN_FUDGE);\n+\n+  for (l = search_start; l; l = l->next)\n+    {\n+      bcopy (l->name, name, l->nlen);\n+      name[l->nlen] = '/';\n+      strcpy (&name[l->nlen+1], fname);\n+      simplify_pathname (name);\n+      if (CPP_OPTIONS (pfile)->remap)\n+\tname = remap_filename (pfile, name, l);\n+      \n+      f = open (name, O_RDONLY, 0666);\n+#ifdef EACCES\n+      if (f == -1 && errno == EACCES)\n+\t{\n+\t  cpp_error(pfile, \"included file `%s' exists but is not readable\",\n+\t\t    name);\n+\t  return -1;\n+\t}\n+#endif\n+\n+      if (f >= 0)\n+        {\n+\t  ih->foundhere = l;\n+\t  ih->name = xrealloc (name, strlen (name)+1);\n+\t  return f;\n+        }\n+    }\n+  \n+    if (jh)\n+      {\n+\tjh->next_this_file = NULL;\n+\tfree (ih);\n+      }\n+    free (name);\n+    *ihash = (struct include_hash *)-1;\n+    return -1;\n }\n \n /* The file_name_map structure holds a mapping of file names for a\n@@ -434,7 +548,6 @@ read_name_map (pfile, dirname)\n   map_list_ptr = ((struct file_name_map_list *)\n \t\t  xmalloc (sizeof (struct file_name_map_list)));\n   map_list_ptr->map_list_name = savestring (dirname);\n-  map_list_ptr->map_list_map = NULL;\n \n   name = (char *) alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n   strcpy (name, dirname);\n@@ -443,7 +556,7 @@ read_name_map (pfile, dirname)\n   strcat (name, FILE_NAME_MAP_FILE);\n   f = fopen (name, \"r\");\n   if (!f)\n-    map_list_ptr->map_list_map = NULL;\n+    map_list_ptr->map_list_map = (struct file_name_map *)-1;\n   else\n     {\n       int ch;\n@@ -493,220 +606,192 @@ read_name_map (pfile, dirname)\n   return map_list_ptr->map_list_map;\n }  \n \n-/* Try to open include file FILENAME.  SEARCHPTR is the directory\n-   being tried from the include file search path.  This function maps\n-   filenames on file systems based on information read by\n-   read_name_map.  */\n+/* Remap NAME based on the file_name_map (if any) for LOC. */\n \n-static int\n-open_include_file (pfile, filename, searchptr)\n+static char *\n+remap_filename (pfile, name, loc)\n      cpp_reader *pfile;\n-     char *filename;\n-     struct file_name_list *searchptr;\n+     char *name;\n+     struct file_name_list *loc;\n {\n-  if (CPP_OPTIONS (pfile)->remap)\n-    {\n-      register struct file_name_map *map;\n-      register char *from;\n-      char *p, *dir;\n-\n-      if (searchptr && ! searchptr->got_name_map)\n-\t{\n-\t  searchptr->name_map = read_name_map (pfile,\n-\t\t\t\t\t       searchptr->fname\n-\t\t\t\t\t       ? searchptr->fname : \".\");\n-\t  searchptr->got_name_map = 1;\n-\t}\n-\n-      /* First check the mapping for the directory we are using.  */\n-      if (searchptr && searchptr->name_map)\n-\t{\n-\t  from = filename;\n-\t  if (searchptr->fname)\n-\t    from += strlen (searchptr->fname) + 1;\n-\t  for (map = searchptr->name_map; map; map = map->map_next)\n-\t    {\n-\t      if (! strcmp (map->map_from, from))\n-\t\t{\n-\t\t  /* Found a match.  */\n-\t\t  return open (map->map_to, O_RDONLY, 0666);\n-\t\t}\n-\t    }\n-\t}\n+  struct file_name_map *map;\n+  char *from;\n+  char *p, *dir;\n \n-      /* Try to find a mapping file for the particular directory we are\n-\t looking in.  Thus #include <sys/types.h> will look up sys/types.h\n-\t in /usr/include/header.gcc and look up types.h in\n-\t /usr/include/sys/header.gcc.  */\n-      p = rindex (filename, '/');\n-      if (! p)\n-\tp = filename;\n-      if (searchptr\n-\t  && searchptr->fname\n-\t  && strlen (searchptr->fname) == (size_t) (p - filename)\n-\t  && ! strncmp (searchptr->fname, filename, p - filename))\n-\t{\n-\t  /* FILENAME is in SEARCHPTR, which we've already checked.  */\n-\t  return open (filename, O_RDONLY, 0666);\n-\t}\n+  if (! loc->name_map)\n+    loc->name_map = read_name_map (pfile,\n+\t\t\t\t   loc->name\n+\t\t\t\t   ? loc->name : \".\");\n \n-      if (p == filename)\n-\t{\n-\t  dir = \".\";\n-\t  from = filename;\n-\t}\n-      else\n-\t{\n-\t  dir = (char *) alloca (p - filename + 1);\n-\t  bcopy (filename, dir, p - filename);\n-\t  dir[p - filename] = '\\0';\n-\t  from = p + 1;\n-\t}\n-      for (map = read_name_map (pfile, dir); map; map = map->map_next)\n-\tif (! strcmp (map->map_from, from))\n-\t  return open (map->map_to, O_RDONLY, 0666);\n+  if (loc->name_map == (struct file_name_map *)-1)\n+    return name;\n+  \n+  from = name + strlen (loc->name) + 1;\n+  \n+  for (map = loc->name_map; map; map = map->map_next)\n+    if (!strcmp (map->map_from, from))\n+      return map->map_to;\n+\n+  /* Try to find a mapping file for the particular directory we are\n+     looking in.  Thus #include <sys/types.h> will look up sys/types.h\n+     in /usr/include/header.gcc and look up types.h in\n+     /usr/include/sys/header.gcc.  */\n+  p = rindex (name, '/');\n+  if (!p)\n+    p = name;\n+  if (loc && loc->name\n+      && strlen (loc->name) == (size_t) (p - name)\n+      && !strncmp (loc->name, name, p - name))\n+    /* FILENAME is in SEARCHPTR, which we've already checked.  */\n+    return name;\n+\n+  if (p == name)\n+    {\n+      dir = \".\";\n+      from = name;\n     }\n+  else\n+    {\n+      dir = (char *) alloca (p - name + 1);\n+      bcopy (name, dir, p - name);\n+      dir[p - name] = '\\0';\n+      from = p + 1;\n+    }\n+  \n+  for (map = read_name_map (pfile, dir); map; map = map->map_next)\n+    if (! strcmp (map->map_from, name))\n+      return map->map_to;\n \n-  return open (filename, O_RDONLY, 0666);\n+  return name;\n }\n \n-/* Process the contents of include file FNAME, already open on descriptor F,\n-   with output to OP.\n-   SYSTEM_HEADER_P is 1 if this file resides in any one of the known\n-   \"system\" include directories (as decided by the `is_system_include'\n-   function above).\n-   DIRPTR is the link in the dir path through which this file was found,\n-   or 0 if the file name was absolute or via the current directory.\n-   Return 1 on success, 0 on failure.\n+/* Read the contents of FD into the buffer on the top of PFILE's stack.\n+   IHASH points to the include hash entry for the file associated with\n+   FD.\n \n    The caller is responsible for the cpp_push_buffer.  */\n \n int\n-finclude (pfile, f, fname, system_header_p, dirptr)\n+finclude (pfile, fd, ihash)\n      cpp_reader *pfile;\n-     int f;\n-     char *fname;\n-     int system_header_p;\n-     struct file_name_list *dirptr;\n+     int fd;\n+     struct include_hash *ihash;\n {\n   struct stat st;\n   size_t st_size;\n-  long i;\n-  int length;\n-  cpp_buffer *fp;\t\t\t/* For input stack frame */\n-#if 0\n-  int missing_newline = 0;\n-#endif\n-\n-  if (fstat (f, &st) < 0)\n-    {\n-      cpp_perror_with_name (pfile, fname);\n-      close (f);\n-      cpp_pop_buffer (pfile);\n-      return 0;\n-    }\n+  long i, length;\n+  cpp_buffer *fp;\n \n+  if (fstat (fd, &st) < 0)\n+    goto perror_fail;\n+  \n   fp = CPP_BUFFER (pfile);\n-  fp->nominal_fname = fp->fname = fname;\n-#if 0\n-  fp->length = 0;\n-#endif\n-  fp->dir = dirptr;\n-  fp->system_header_p = system_header_p;\n+  fp->nominal_fname = fp->fname = ihash->name;\n+  fp->ihash = ihash;\n+  fp->system_header_p = (ihash->foundhere != ABSOLUTE_PATH\n+\t\t\t && ihash->foundhere->sysp);\n   fp->lineno = 1;\n   fp->colno = 1;\n   fp->cleanup = file_cleanup;\n \n-  if (S_ISREG (st.st_mode)) {\n-    st_size = (size_t) st.st_size;\n-    if (st_size != st.st_size || st_size + 2 < st_size) {\n-      cpp_error (pfile, \"file `%s' too large\", fname);\n-      close (f);\n-      return 0;\n-    }\n-    fp->buf = (U_CHAR *) xmalloc (st_size + 2);\n-    fp->alimit = fp->buf + st_size + 2;\n-    fp->cur = fp->buf;\n-\n-    /* Read the file contents, knowing that st_size is an upper bound\n-       on the number of bytes we can read.  */\n-    length = safe_read (f, fp->buf, st_size);\n-    fp->rlimit = fp->buf + length;\n-    if (length < 0) goto nope;\n-  }\n-  else if (S_ISDIR (st.st_mode)) {\n-    cpp_error (pfile, \"directory `%s' specified in #include\", fname);\n-    close (f);\n-    return 0;\n-  } else {\n-    /* Cannot count its file size before reading.\n-       First read the entire file into heap and\n-       copy them into buffer on stack.  */\n-\n-    size_t bsize = 2000;\n-\n-    st_size = 0;\n-    fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n-\n-    for (;;) {\n-      i = safe_read (f, fp->buf + st_size, bsize - st_size);\n-      if (i < 0)\n-\tgoto nope;      /* error! */\n-      st_size += i;\n-      if (st_size != bsize)\n-\tbreak;\t/* End of file */\n-      bsize *= 2;\n-      fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);\n-    }\n-    fp->cur = fp->buf;\n-    length = st_size;\n-  }\n+  /* The ->dir field is only used when ignore_srcdir is not in effect;\n+     see do_include */\n+  if (!CPP_OPTIONS (pfile)->ignore_srcdir)\n+    {\n+      char *last_slash;\n+      fp->dir = savestring (fp->fname);\n+      last_slash = rindex (fp->dir, '/');\n+      if (last_slash)\n+        {\n+\t  if (last_slash == fp->dir)\n+\t    {\n+\t      fp->dlen = 1;\n+\t      last_slash[1] = '\\0';\n+\t    }\n+\t  else\n+\t    {\n+\t      fp->dlen = last_slash - fp->dir;\n+\t      *last_slash = '\\0';\n+\t    }\n+\t}\n+      else\n+        {\n+\t  fp->dir[0] = '.';\n+\t  fp->dir[1] = '\\0';\n+\t  fp->dlen = 1;\n+\t}\n+    }\n \n+  if (S_ISREG (st.st_mode))\n+    {\n+      st_size = (size_t) st.st_size;\n+      if (st_size != st.st_size || st_size + 2 < st_size)\n+      {\n+        cpp_error (pfile, \"file `%s' too large\", ihash->name);\n+\tgoto fail;\n+      }\n+      fp->buf = (U_CHAR *) xmalloc (st_size + 2);\n+      fp->alimit = fp->buf + st_size + 2;\n+      fp->cur = fp->buf;\n+      \n+      /* Read the file contents, knowing that st_size is an upper bound\n+\t on the number of bytes we can read.  */\n+      length = safe_read (fd, fp->buf, st_size);\n+      fp->rlimit = fp->buf + length;\n+      if (length < 0)\n+\t  goto perror_fail;\n+    }\n+  else if (S_ISDIR (st.st_mode))\n+    {\n+      cpp_pop_buffer (pfile);\n+      cpp_error (pfile, \"directory `%s' specified in #include\", ihash->name);\n+      goto fail;\n+    }\n+  else\n+    {\n+      /* Cannot count its file size before reading.\n+\t First read the entire file into heap and\n+\t copy them into buffer on stack.  */\n+\n+      size_t bsize = 2000;\n+\n+      st_size = 0;\n+      fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n+\n+      for (;;)\n+        {\n+\t  i = safe_read (fd, fp->buf + st_size, bsize - st_size);\n+\t  if (i < 0)\n+\t    goto perror_fail;\n+\t  st_size += i;\n+\t  if (st_size != bsize)\n+\t    break;\t/* End of file */\n+\t  bsize *= 2;\n+\t  fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);\n+\t}\n+      fp->cur = fp->buf;\n+      length = st_size;\n+    }\n+\n+  /* FIXME: Broken in presence of trigraphs (consider ??/<EOF>)\n+     and doesn't warn about a missing newline. */\n   if ((length > 0 && fp->buf[length - 1] != '\\n')\n-      /* Backslash-newline at end is not good enough.  */\n-      || (length > 1 && fp->buf[length - 2] == '\\\\')) {\n+      || (length > 1 && fp->buf[length - 2] == '\\\\'))\n     fp->buf[length++] = '\\n';\n-#if 0\n-    missing_newline = 1;\n-#endif\n-  }\n+\n   fp->buf[length] = '\\0';\n   fp->rlimit = fp->buf + length;\n \n-  /* Close descriptor now, so nesting does not use lots of descriptors.  */\n-  close (f);\n-\n-  /* Must do this before calling trigraph_pcp, so that the correct file name\n-     will be printed in warning messages.  */\n-\n+  close (fd);\n   pfile->input_stack_listing_current = 0;\n-\n-#if 0\n-  if (!no_trigraphs)\n-    trigraph_pcp (fp);\n-#endif\n-\n-#if 0\n-  rescan (op, 0);\n-\n-  if (missing_newline)\n-    fp->lineno--;\n-\n-  if (CPP_PEDANTIC (pfile) && missing_newline)\n-    pedwarn (\"file does not end in newline\");\n-\n-  indepth--;\n-  input_file_stack_tick++;\n-  free (fp->buf);\n-#endif\n   return 1;\n \n- nope:\n-\n-  cpp_perror_with_name (pfile, fname);\n-  close (f);\n-  free (fp->buf);\n-  return 1;\n+ perror_fail:\n+  cpp_pop_buffer (pfile);\n+  cpp_error_from_errno (pfile, ihash->name);\n+ fail:\n+  close (fd);\n+  return 0;\n }\n \n /* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n@@ -715,7 +800,7 @@ finclude (pfile, f, fname, system_header_p, dirptr)\n    otherwise return the actual number of bytes read,\n    which must be LEN unless end-of-file was reached.  */\n \n-static int\n+static long\n safe_read (desc, ptr, len)\n      int desc;\n      char *ptr;\n@@ -747,7 +832,194 @@ safe_read (desc, ptr, len)\n   return len - left;\n }\n \n-#ifdef VMS\n+/* Add output to `deps_buffer' for the -M switch.\n+   STRING points to the text to be output.\n+   SPACER is ':' for targets, ' ' for dependencies, zero for text\n+   to be inserted literally.  */\n+\n+void\n+deps_output (pfile, string, spacer)\n+     cpp_reader *pfile;\n+     char *string;\n+     int spacer;\n+{\n+  int size;\n+  int cr = 0;\n+\n+  if (!*string)\n+    return;\n+\n+  size = strlen (string);\n+\n+#ifndef MAX_OUTPUT_COLUMNS\n+#define MAX_OUTPUT_COLUMNS 72\n+#endif\n+  if (pfile->deps_column > 0\n+      && (pfile->deps_column + size) > MAX_OUTPUT_COLUMNS)\n+    {\n+      size += 5;\n+      cr = 1;\n+      pfile->deps_column = 0;\n+    }\n+\n+  if (pfile->deps_size + size + 8 > pfile->deps_allocated_size)\n+    {\n+      pfile->deps_allocated_size = (pfile->deps_size + size + 50) * 2;\n+      pfile->deps_buffer = (char *) xrealloc (pfile->deps_buffer,\n+\t\t\t\t\t      pfile->deps_allocated_size);\n+    }\n+\n+  if (cr)\n+    {\n+      bcopy (\" \\\\\\n  \", &pfile->deps_buffer[pfile->deps_size], 5);\n+      pfile->deps_size += 5;\n+    }\n+  \n+  if (spacer == ' ' && pfile->deps_column > 0)\n+    pfile->deps_buffer[pfile->deps_size++] = ' ';\n+  bcopy (string, &pfile->deps_buffer[pfile->deps_size], size);\n+  pfile->deps_size += size;\n+  pfile->deps_column += size;\n+  if (spacer == ':')\n+    pfile->deps_buffer[pfile->deps_size++] = ':';\n+  pfile->deps_buffer[pfile->deps_size] = 0;\n+}\n+\n+/* Simplify a path name in place, deleting redundant components.  This\n+   reduces OS overhead and guarantees that equivalent paths compare\n+   the same (modulo symlinks).\n+\n+   Transforms made:\n+   foo/bar/../quux\tfoo/quux\n+   foo/./bar\t\tfoo/bar\n+   foo//bar\t\tfoo/bar\n+   /../quux\t\t/quux\n+   //quux\t\t//quux  (POSIX allows leading // as a namespace escape)\n+\n+   Guarantees no trailing slashes. All transforms reduce the length\n+   of the string.\n+ */\n+static void\n+simplify_pathname (char *path)\n+{\n+    char *from, *to;\n+    char *base;\n+    int absolute = 0;\n+\n+#if defined _WIN32 || defined __MSDOS__\n+    /* Convert all backslashes to slashes. */\n+    for (from = path; *from; from++)\n+\tif (*from == '\\\\') *from = '/';\n+    \n+    /* Skip over leading drive letter if present. */\n+    if (ISALPHA (path[0]) && path[1] == ':')\n+\tfrom = to = &path[2];\n+    else\n+\tfrom = to = path;\n+#else\n+    from = to = path;\n+#endif\n+    \n+    /* Remove redundant initial /s.  */\n+    if (*from == '/')\n+    {\n+\tabsolute = 1;\n+\tto++;\n+\tfrom++;\n+\tif (*from == '/')\n+\t{\n+\t    if (*++from == '/')\n+\t\t/* 3 or more initial /s are equivalent to 1 /.  */\n+\t\twhile (*++from == '/');\n+\t    else\n+\t\t/* On some hosts // differs from /; Posix allows this.  */\n+\t\tto++;\n+\t}\n+    }\n+    base = to;\n+    \n+    for (;;)\n+    {\n+\twhile (*from == '/')\n+\t    from++;\n+\n+\tif (from[0] == '.' && from[1] == '/')\n+\t    from += 2;\n+\telse if (from[0] == '.' && from[1] == '\\0')\n+\t    goto done;\n+\telse if (from[0] == '.' && from[1] == '.' && from[2] == '/')\n+\t{\n+\t    if (base == to)\n+\t    {\n+\t\tif (absolute)\n+\t\t    from += 3;\n+\t\telse\n+\t\t{\n+\t\t    *to++ = *from++;\n+\t\t    *to++ = *from++;\n+\t\t    *to++ = *from++;\n+\t\t    base = to;\n+\t\t}\n+\t    }\n+\t    else\n+\t    {\n+\t\tto -= 2;\n+\t\twhile (to > base && *to != '/') to--;\n+\t\tif (*to == '/')\n+\t\t    to++;\n+\t\tfrom += 3;\n+\t    }\n+\t}\n+\telse if (from[0] == '.' && from[1] == '.' && from[2] == '\\0')\n+\t{\n+\t    if (base == to)\n+\t    {\n+\t\tif (!absolute)\n+\t\t{\n+\t\t    *to++ = *from++;\n+\t\t    *to++ = *from++;\n+\t\t}\n+\t    }\n+\t    else\n+\t    {\n+\t\tto -= 2;\n+\t\twhile (to > base && *to != '/') to--;\n+\t\tif (*to == '/')\n+\t\t    to++;\n+\t    }\n+\t    goto done;\n+\t}\n+\telse\n+\t    /* Copy this component and trailing /, if any.  */\n+\t    while ((*to++ = *from++) != '/')\n+\t    {\n+\t\tif (!to[-1])\n+\t\t{\n+\t\t    to--;\n+\t\t    goto done;\n+\t\t}\n+\t    }\n+\t\n+    }\n+    \n+ done:\n+    /* Trim trailing slash */\n+    if (to[0] == '/' && (!absolute || to > path+1))\n+\tto--;\n+\n+    /* Change the empty string to \".\" so that stat() on the result\n+       will always work. */\n+    if (to == path)\n+      *to++ = '.';\n+    \n+    *to = '\\0';\n+\n+    return;\n+}\n+\n+/* It is not clear when this should be used if at all, so I've\n+   disabled it until someone who understands VMS can look at it. */\n+#if 0\n \n /* Under VMS we need to fix up the \"include\" specification filename.\n "}, {"sha": "227441353a11e3e1d5332646978ce1500e69dbb3", "filename": "gcc/cpplib.c", "status": "modified", "additions": 305, "deletions": 453, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d", "patch": "@@ -206,7 +206,6 @@ static int compare_defs\t\t\tPROTO ((cpp_reader *,\n \t\t\t\t\t\tDEFINITION *, DEFINITION *));\n static int compare_token_lists\t\tPROTO ((struct arglist *,\n \t\t\t\t\t\tstruct arglist *));\n-static int is_system_include\t\tPROTO ((cpp_reader *, char *));\n static HOST_WIDE_INT eval_if_expression\tPROTO ((cpp_reader *, U_CHAR *, int));\n static int change_newlines\t\tPROTO ((U_CHAR *, int));\n static struct arglist *read_token_list\tPROTO ((cpp_reader *, int *));\n@@ -585,7 +584,6 @@ path_include (pfile, path)\n     while (1) {\n       char *q = p;\n       char *name;\n-      struct file_name_list *dirtmp;\n \n       /* Find the end of this name.  */\n       while (*q != 0 && *q != PATH_SEPARATOR) q++;\n@@ -601,14 +599,8 @@ path_include (pfile, path)\n \tname[q - p] = 0;\n       }\n \n-      dirtmp = (struct file_name_list *)\n-\txmalloc (sizeof (struct file_name_list));\n-      dirtmp->next = 0;\t\t/* New one goes on the end */\n-      dirtmp->control_macro = 0;\n-      dirtmp->c_system_include_path = 0;\n-      dirtmp->fname = name;\n-      dirtmp->got_name_map = 0;\n-      append_include_chain (pfile, dirtmp, dirtmp);\n+      append_include_chain (pfile,\n+\t\t\t    &(CPP_OPTIONS (pfile)->bracket_include), name, 0);\n \n       /* Advance past this name.  */\n       p = q;\n@@ -2940,16 +2932,16 @@ do_include (pfile, keyword, unused1, unused2)\n   int importing = (keyword->type == T_IMPORT);\n   int skip_dirs = (keyword->type == T_INCLUDE_NEXT);\n   int angle_brackets = 0;\t/* 0 for \"...\", 1 for <...> */\n-  char *fname;\t\t/* Dynamically allocated fname buffer */\n-  char *fbeg, *fend;\t\t/* Beginning and end of fname */\n+  int before;  /* included before? */\n   long flen;\n+  char *fbeg, *fend;\n+  struct file_name_list *srcdir = 0;  /* for \"\" includes */\n \n   enum cpp_token token;\n \n   /* Chain of dirs to search */\n-  struct file_name_list *search_start = CPP_OPTIONS (pfile)->include;\n-  struct file_name_list dsp;\t/* First in chain, if #include \"...\" */\n-  struct file_name_list *foundhere, *ptr;\n+  struct include_hash *ihash;\n+  struct file_name_list *search_start;\n   \n   long old_written = CPP_WRITTEN (pfile);\n \n@@ -2968,17 +2960,7 @@ do_include (pfile, keyword, unused1, unused2)\n       && !CPP_BUFFER (pfile)->system_header_p && !pfile->import_warning)\n     {\n       pfile->import_warning = 1;\n-      cpp_warning (pfile, \"using `#import' is not recommended\");\n-      fprintf (stderr, \"The fact that a certain header file need not be processed more than once\\n\");\n-      fprintf (stderr, \"should be indicated in the header file, not where it is used.\\n\");\n-      fprintf (stderr, \"The best way to do this is with a conditional of this form:\\n\\n\");\n-      fprintf (stderr, \"  #ifndef _FOO_H_INCLUDED\\n\");\n-      fprintf (stderr, \"  #define _FOO_H_INCLUDED\\n\");\n-      fprintf (stderr, \"  ... <real contents of file> ...\\n\");\n-      fprintf (stderr, \"  #endif /* Not _FOO_H_INCLUDED */\\n\\n\");\n-      fprintf (stderr, \"Then users can use `#include' any number of times.\\n\");\n-      fprintf (stderr, \"GNU C automatically avoids processing the file more than once\\n\");\n-      fprintf (stderr, \"when it is equipped with such a conditional.\\n\");\n+      cpp_warning (pfile, \"`#import' is obsolete, use an #ifdef wrapper in the header file\");\n     }\n \n   pfile->parsing_include_directive++;\n@@ -2991,71 +2973,17 @@ do_include (pfile, keyword, unused1, unused2)\n       fend = CPP_PWRITTEN (pfile) - 1;\n       *fend = '\\0';\n       if (fbeg[-1] == '<')\n-\t{\n \t  angle_brackets = 1;\n-\t  /* If -I-, start with the first -I dir after the -I-.  */\n-\t  if (CPP_OPTIONS (pfile)->first_bracket_include)\n-\t    search_start = CPP_OPTIONS (pfile)->first_bracket_include;\n-\t}\n-      /* If -I- was specified, don't search current dir, only spec'd ones.  */\n-      else if (! CPP_OPTIONS (pfile)->ignore_srcdir)\n-\t{\n-\t  cpp_buffer *fp = CPP_BUFFER (pfile);\n-\t  /* We have \"filename\".  Figure out directory this source\n-\t     file is coming from and put it on the front of the list.  */\n-\n-\t  for ( ; fp != CPP_NULL_BUFFER (pfile); fp = CPP_PREV_BUFFER (fp))\n-\t    {\n-\t      int n;\n-\t      char *ep,*nam;\n-\n-\t      if ((nam = fp->nominal_fname) != NULL)\n-\t\t{\n-\t\t  /* Found a named file.  Figure out dir of the file,\n-\t\t     and put it in front of the search list.  */\n-\t\t  dsp.next = search_start;\n-\t\t  search_start = &dsp;\n-#ifndef VMS\n-\t\t  ep = rindex (nam, '/');\n-#else\t\t\t\t/* VMS */\n-\t\t  ep = rindex (nam, ']');\n-\t\t  if (ep == NULL) ep = rindex (nam, '>');\n-\t\t  if (ep == NULL) ep = rindex (nam, ':');\n-\t\t  if (ep != NULL) ep++;\n-#endif\t\t\t\t/* VMS */\n-\t\t  if (ep != NULL)\n-\t\t    {\n-\t\t      n = ep - nam;\n-\t\t      dsp.fname = (char *) alloca (n + 1);\n-\t\t      strncpy (dsp.fname, nam, n);\n-\t\t      dsp.fname[n] = '\\0';\n-\t\t      if (n + INCLUDE_LEN_FUDGE > pfile->max_include_len)\n-\t\t\tpfile->max_include_len = n + INCLUDE_LEN_FUDGE;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      dsp.fname = 0; /* Current directory */\n-\t\t    }\n-\t\t  dsp.got_name_map = 0;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n     }\n #ifdef VMS\n   else if (token == CPP_NAME)\n     {\n-      /*\n-       * Support '#include xyz' like VAX-C to allow for easy use of all the\n-       * decwindow include files. It defaults to '#include <xyz.h>' (so the\n-       * code from case '<' is repeated here) and generates a warning.\n-       */\n+      /* Support '#include xyz' like VAX-C to allow for easy use of\n+       * all the decwindow include files. It defaults to '#include\n+       * <xyz.h>' and generates a warning.  */\n       cpp_warning (pfile,\n \t\t   \"VAX-C-style include specification found, use '#include <filename.h>' !\");\n       angle_brackets = 1;\n-      /* If -I-, start with the first -I dir after the -I-.  */\n-      if (CPP_OPTIONS (pfile)->first_bracket_include)\n-\tsearch_start = CPP_OPTIONS (pfile)->first_bracket_include;\n \n       /* Append the missing `.h' to the name. */\n       CPP_PUTS (pfile, \".h\", 3)\n@@ -3081,6 +3009,16 @@ do_include (pfile, keyword, unused1, unused2)\n       skip_rest_of_line (pfile);\n     }\n \n+  CPP_SET_WRITTEN (pfile, old_written);\n+\n+  flen = fend - fbeg;\n+\n+  if (flen == 0)\n+    {\n+      cpp_error (pfile, \"empty file name in `#%s'\", keyword->name);\n+      return 0;\n+    }\n+  \n   /* For #include_next, skip in the search path\n      past the dir in which the containing file was found.  */\n   if (skip_dirs)\n@@ -3089,39 +3027,55 @@ do_include (pfile, keyword, unused1, unused2)\n       for (; fp != CPP_NULL_BUFFER (pfile); fp = CPP_PREV_BUFFER (fp))\n \tif (fp->fname != NULL)\n \t  {\n-\t    /* fp->dir is null if the containing file was specified with\n-\t       an absolute file name.  In that case, don't skip anything.  */\n-\t    if (fp->dir == SELF_DIR_DUMMY)\n-\t      search_start = CPP_OPTIONS (pfile)->include;\n-\t    else if (fp->dir)\n-\t      search_start = fp->dir->next;\n+\t    /* Don't skip anything if the containing file was found\n+\t       by an absolute path. */\n+\t    if (fp->ihash->foundhere == ABSOLUTE_PATH)\n+\t      search_start = angle_brackets\n+\t\t  ? CPP_OPTIONS (pfile)->bracket_include\n+\t\t  : CPP_OPTIONS (pfile)->quote_include;\n+\t    else\n+\t      search_start = fp->ihash->foundhere->next;\n \t    break;\n \t  }\n     }\n+  else\n+    search_start = angle_brackets\n+\t? CPP_OPTIONS (pfile)->bracket_include\n+\t: CPP_OPTIONS (pfile)->quote_include;\n+\n+  /* For \"\" includes when ignore_srcdir is off, tack the actual directory\n+     of the current file onto the beginning of the search path.\n+     The block must be permanently allocated since it may wind up\n+     in the include hash. */\n+  if (!angle_brackets \n+      && search_start == CPP_OPTIONS (pfile)->quote_include\n+      && !CPP_OPTIONS (pfile)->ignore_srcdir)\n+    {\n+      srcdir = (struct file_name_list *)\n+\t  xmalloc (sizeof (struct file_name_list));\n+      srcdir->next = CPP_OPTIONS (pfile)->quote_include;\n+      srcdir->name = CPP_BUFFER (pfile)->dir;\n+      srcdir->nlen = CPP_BUFFER (pfile)->dlen;\n+      srcdir->sysp = 0;\n+      srcdir->name_map = NULL;\n \n-  CPP_SET_WRITTEN (pfile, old_written);\n-\n-  flen = fend - fbeg;\n+      search_start = srcdir;\n+    }\n \n-  if (flen == 0)\n+  if (!search_start)\n     {\n-      cpp_error (pfile, \"empty file name in `#%s'\", keyword->name);\n+      cpp_error (pfile, \"No include path in which to find %s\", fbeg);\n       return 0;\n     }\n \n-  /* Allocate this permanently, because it gets stored in the definitions\n-     of macros.  */\n-  /* + 2 above for slash and terminating null.  */\n-  fname = (char *) xmalloc (pfile->max_include_len + flen + 2);\n-\n-  fd = find_include_file (pfile, fbeg, flen, fname,\n-\t\t\t  importing, search_start, &foundhere);\n+  fd = find_include_file (pfile, fbeg, search_start, &ihash, &before);\n \n+  if (srcdir\n+      && (ihash == (struct include_hash *)-1 || srcdir != ihash->foundhere))\n+    free (srcdir);\n+  \n   if (fd == -2)\n-    {\n-      free (fname);\n-      return 0;\n-    }\n+    return 0;\n   \n   if (fd == -1)\n     {\n@@ -3133,27 +3087,24 @@ do_include (pfile, keyword, unused1, unused2)\n \t    deps_output (pfile, fbeg, ' ');\n \t  else\n \t    {\n+\t      char *p;\n+\t      struct file_name_list *ptr;\n \t      /* If requested as a system header, assume it belongs in\n \t\t the first system header directory. */\n-\t      if (CPP_OPTIONS (pfile)->first_bracket_include)\n-\t        ptr = CPP_OPTIONS (pfile)->first_bracket_include;\n+\t      if (CPP_OPTIONS (pfile)->bracket_include)\n+\t        ptr = CPP_OPTIONS (pfile)->bracket_include;\n \t      else\n-\t\tptr = CPP_OPTIONS (pfile)->include;\n-\t      for (; ptr; ptr = ptr->next)\n-\t\t  if (ptr->fname)\n-\t\t    {\n-\t\t      char *p;\n+\t        ptr = CPP_OPTIONS (pfile)->quote_include;\n \n-\t\t      if (ptr->fname[0] == 0)\n-\t\t\tcontinue;\n-\t\t      p = (char *) alloca (strlen (ptr->fname)\n-\t\t\t\t\t   + strlen (fname) + 2);\n-\t\t      strcpy (p, ptr->fname);\n-\t\t      strcat (p, \"/\");\n-\t\t      strcat (p, fname);\n-\t\t      deps_output (pfile, p, ' ');\n-\t\t      break;\n-\t\t    }\n+\t      p = (char *) alloca (strlen (ptr->name)\n+\t\t\t\t   + strlen (fbeg) + 2);\n+\t      if (*ptr->name != '\\0')\n+\t        {\n+\t\t  strcpy (p, ptr->name);\n+\t\t  strcat (p, \"/\");\n+\t        }\n+\t      strcat (p, fbeg);\n+\t      deps_output (pfile, p, ' ');\n \t    }\n \t}\n       /* If -M was specified, and this header file won't be added to\n@@ -3165,106 +3116,47 @@ do_include (pfile, keyword, unused1, unused2)\n       else if (CPP_PRINT_DEPS (pfile)\n \t       && (CPP_PRINT_DEPS (pfile)\n \t\t   <= (angle_brackets || (pfile->system_include_depth > 0))))\n-\tcpp_warning (pfile, \"No include path in which to find %s\", fname);\n-      else if (search_start)\n-\tcpp_error_from_errno (pfile, fname);\n+\tcpp_warning (pfile, \"No include path in which to find %s\", fbeg);\n       else\n-\tcpp_error (pfile, \"No include path in which to find %s\", fname);\n+\tcpp_error_from_errno (pfile, fbeg);\n \n-      free (fname);\n       return 0;\n     }\n \n-  /* If we get here, we have a file to process. */\n-\n-  for (ptr = pfile->all_include_files; ptr; ptr = ptr->next)\n-    if (!strcmp (ptr->fname, fname))\n-      break;\t\t\t\t/* This file was included before.  */\n-\n-  if (ptr == 0)\n-    {\n-      /* This is the first time for this file.  */\n-      /* Add it to list of files included.  */\n-\n-      ptr = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-      ptr->control_macro = 0;\n-      ptr->c_system_include_path = 0;\n-      ptr->next = pfile->all_include_files;\n-      pfile->all_include_files = ptr;\n-      ptr->fname = savestring (fname);\n-      ptr->got_name_map = 0;\n-\n-      /* For -M, add this file to the dependencies.  */\n-      if (CPP_PRINT_DEPS (pfile)\n-\t  > (angle_brackets || (pfile->system_include_depth > 0)))\n-\tdeps_output (pfile, fname, ' ');\n-    }\n+  /* For -M, add the file to the dependencies on its first inclusion. */\n+  if (!before && (CPP_PRINT_DEPS (pfile)\n+\t\t  > (angle_brackets || (pfile->system_include_depth > 0))))\n+    deps_output (pfile, ihash->name, ' ');\n \n   /* Handle -H option.  */\n   if (CPP_OPTIONS(pfile)->print_include_names)\n     {\n       cpp_buffer *buf = CPP_BUFFER (pfile);\n       while ((buf = CPP_PREV_BUFFER (buf)) != CPP_NULL_BUFFER (pfile))\n \tputc ('.', stderr);\n-      fprintf (stderr, \"%s\\n\", fname);\n+      fprintf (stderr, \" %s\\n\", ihash->name);\n     }\n \n   /* Actually process the file */\n+\n+  if (importing)\n+    ihash->control_macro = \"\";\n+  \n   if (cpp_push_buffer (pfile, NULL, 0) == NULL)\n     {\n       close (fd);\n-      free (fname);\n       return 0;\n     }\n-\n+  \n   if (angle_brackets)\n-    pfile->system_include_depth++;\n+    pfile->system_include_depth++;   /* Decremented in file_cleanup. */\n \n-  if (finclude (pfile, fd, fname, is_system_include (pfile, fname),\n-\t\tfoundhere != &dsp ? foundhere : SELF_DIR_DUMMY))\n+  if (finclude (pfile, fd, ihash))\n     {\n       output_line_command (pfile, 0, enter_file);\n       pfile->only_seen_white = 2;\n     }\n-  \n-  if (angle_brackets)\n-    pfile->system_include_depth--;\n-\n-  return 0;\n-}\n-\n-/* Return nonzero if the given FILENAME is an absolute pathname which\n-   designates a file within one of the known \"system\" include file\n-   directories.  We assume here that if the given FILENAME looks like\n-   it is the name of a file which resides either directly in a \"system\"\n-   include file directory, or within any subdirectory thereof, then the\n-   given file must be a \"system\" include file.  This function tells us\n-   if we should suppress pedantic errors/warnings for the given FILENAME.\n-\n-   The value is 2 if the file is a C-language system header file\n-   for which C++ should (on most systems) assume `extern \"C\"'.  */\n-\n-static int\n-is_system_include (pfile, filename)\n-     cpp_reader *pfile;\n-     register char *filename;\n-{\n-  struct file_name_list *searchptr;\n \n-  for (searchptr = CPP_OPTIONS (pfile)->first_system_include; searchptr;\n-       searchptr = searchptr->next)\n-    if (searchptr->fname) {\n-      register char *sys_dir = searchptr->fname;\n-      register unsigned length = strlen (sys_dir);\n-\n-      if (! strncmp (sys_dir, filename, length) && filename[length] == '/')\n-\t{\n-\t  if (searchptr->c_system_include_path)\n-\t    return 2;\n-\t  else\n-\t    return 1;\n-\t}\n-    }\n   return 0;\n }\n \n@@ -3665,7 +3557,6 @@ do_pragma (pfile, keyword, buf, limit)\n   if (!strncmp (buf, \"once\", 4))\n     {\n       cpp_buffer *ip = NULL;\n-      struct file_name_list *new;\n \n       /* Allow #pragma once in system headers, since that's not the user's\n \t fault.  */\n@@ -3679,39 +3570,36 @@ do_pragma (pfile, keyword, buf, limit)\n \t  if (ip->fname != NULL)\n \t    break;\n \t}\n-      \n-      new = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-      new->next = pfile->dont_repeat_files;\n-      new->fname = savestring (ip->fname);\n-      new->control_macro = 0;\n-      new->got_name_map = 0;\n-      new->c_system_include_path = 0;\n-      pfile->dont_repeat_files = new;\n-    }\n \n-  if (!strncmp (buf, \"implementation\", 14)) {\n-    /* Be quiet about `#pragma implementation' for a file only if it hasn't\n-       been included yet.  */\n-    struct file_name_list *ptr;\n-    U_CHAR *p = buf + 14, *fname, *inc_fname;\n-    int fname_len;\n-    SKIP_WHITE_SPACE (p);\n-    if (*p == '\\n' || *p != '\\\"')\n-      return 0;\n+      if (CPP_PREV_BUFFER (ip) == CPP_NULL_BUFFER (pfile))\n+\tcpp_warning (pfile, \"`#pragma once' outside include file\");\n+      else\n+\tip->ihash->control_macro = \"\";  /* never repeat */\n+    }\n \n-    fname = p + 1;\n-    p = (U_CHAR *) index (fname, '\\\"');\n-    fname_len = p != NULL ? p - fname : strlen (fname);\n-    \n-    for (ptr = pfile->all_include_files; ptr; ptr = ptr->next) {\n-      inc_fname = (U_CHAR *) rindex (ptr->fname, '/');\n-      inc_fname = inc_fname ? inc_fname + 1 : (U_CHAR *) ptr->fname;\n-      if (inc_fname && !strncmp (inc_fname, fname, fname_len))\n-\tcpp_warning (pfile,\n-\t   \"`#pragma implementation' for `%s' appears after file is included\",\n-\t\t     fname);\n+  if (!strncmp (buf, \"implementation\", 14))\n+    {\n+      /* Be quiet about `#pragma implementation' for a file only if it hasn't\n+\t been included yet.  */\n+      struct include_hash *ptr;\n+      U_CHAR *p = buf + 14, *fname, *fcopy;\n+      SKIP_WHITE_SPACE (p);\n+      if (*p == '\\n' || *p != '\\\"')\n+        return 0;\n+\n+      fname = p + 1;\n+      p = (U_CHAR *) index (fname, '\\\"');\n+\n+      fcopy = alloca (p - fname + 1);\n+      bcopy (fname, fcopy, p - fname);\n+      fcopy[p-fname] = '\\0';\n+\n+      ptr = include_hash (pfile, fcopy, 0);\n+      if (ptr)\n+        cpp_warning (pfile,\n+\t  \"`#pragma implementation' for `%s' appears after file is included\",\n+\t\t     fcopy);\n     }\n-  }\n \n   return 0;\n }\n@@ -4219,31 +4107,15 @@ do_endif (pfile, keyword, buf, limit)\n \n \t  if (c == EOF)\n \t    {\n-\t      /* If we get here, this #endif ends a #ifndef\n+\t      /* This #endif ends a #ifndef\n \t\t that contains all of the file (aside from whitespace).\n \t\t Arrange not to include the file again\n-\t\t if the macro that was tested is defined.\n-\n-\t\t Do not do this for the top-level file in a -include or any\n-\t\t file in a -imacros.  */\n-#if 0\n-FIXME!\n-\t      if (indepth != 0\n-\t\t  && ! (indepth == 1 && pfile->no_record_file)\n-\t\t  && ! (pfile->no_record_file && no_output))\n-#endif\n-\t\t{\n-\t\t  struct file_name_list *ifile = pfile->all_include_files;\n-\t\t  \n-\t\t  for ( ; ifile != NULL; ifile = ifile->next)\n-\t\t    {\n-\t\t      if (!strcmp (ifile->fname, CPP_BUFFER (pfile)->fname))\n-\t\t\t{\n-\t\t\t  ifile->control_macro = temp->control_macro;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n+\t\t if the macro that was tested is defined. */\n+\t      struct cpp_buffer *ip;\n+\t      for (ip = CPP_BUFFER (pfile); ; ip = CPP_PREV_BUFFER (ip))\n+\t\tif (ip->fname != NULL)\n+\t\t  break;\n+\t      ip->ihash->control_macro = temp->control_macro;\n \t    }\n         }\n       free (temp);\n@@ -4995,6 +4867,7 @@ cpp_start_read (pfile, fname)\n   char *p;\n   int f;\n   cpp_buffer *fp;\n+  struct include_hash *ih_fake;\n \n   /* The code looks at the defaults through this pointer, rather than through\n      the constant structure above.  This pointer gets changed if an environment\n@@ -5193,9 +5066,6 @@ cpp_start_read (pfile, fname)\n     }\n   }\n \n-  append_include_chain (pfile, opts->before_system, opts->last_before_system);\n-  opts->first_system_include = opts->before_system;\n-\n   /* Unless -fnostdinc,\n      tack on the standard include file dirs to the specified list */\n   if (!opts->no_standard_includes) {\n@@ -5218,19 +5088,14 @@ cpp_start_read (pfile, fname)\n \t  /* Does this dir start with the prefix?  */\n \t  if (!strncmp (p->fname, default_prefix, default_len)) {\n \t    /* Yes; change prefix and add to search list.  */\n-\t    struct file_name_list *new\n-\t      = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-\t    int this_len = strlen (specd_prefix) + strlen (p->fname) - default_len;\n+\t    int this_len = strlen (specd_prefix)\n+\t\t\t   + strlen (p->fname) - default_len;\n \t    char *str = (char *) xmalloc (this_len + 1);\n \t    strcpy (str, specd_prefix);\n \t    strcat (str, p->fname + default_len);\n-\t    new->fname = str;\n-\t    new->control_macro = 0;\n-\t    new->c_system_include_path = !p->cxx_aware;\n-\t    new->got_name_map = 0;\n-\t    append_include_chain (pfile, new, new);\n-\t    if (opts->first_system_include == 0)\n-\t      opts->first_system_include = new;\n+\n+\t    append_include_chain (pfile, &opts->system_include,\n+\t\t\t\t  str, !p->cxx_aware);\n \t  }\n \t}\n       }\n@@ -5239,32 +5104,23 @@ cpp_start_read (pfile, fname)\n       /* Some standard dirs are only for C++.  */\n       if (!p->cplusplus\n \t  || (opts->cplusplus && !opts->no_standard_cplusplus_includes)) {\n-\tstruct file_name_list *new\n-\t  = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-\tnew->control_macro = 0;\n-\tnew->c_system_include_path = !p->cxx_aware;\n-\tnew->fname = update_path (p->fname, p->component);\n-\tnew->got_name_map = 0;\n-\tappend_include_chain (pfile, new, new);\n-\tif (opts->first_system_include == 0)\n-\t  opts->first_system_include = new;\n+\tchar *str = update_path (p->fname, p->component);\n+\tappend_include_chain (pfile, &opts->system_include,\n+\t\t\t      str, !p->cxx_aware);\n       }\n     }\n   }\n \n-  /* Tack the after_include chain at the end of the include chain.  */\n-  append_include_chain (pfile, opts->after_include, opts->last_after_include);\n-  if (opts->first_system_include == 0)\n-    opts->first_system_include = opts->after_include;\n+  merge_include_chains (opts);\n \n   /* With -v, print the list of dirs to search.  */\n   if (opts->verbose) {\n     struct file_name_list *p;\n     fprintf (stderr, \"#include \\\"...\\\" search starts here:\\n\");\n-    for (p = opts->include; p; p = p->next) {\n-      if (p == opts->first_bracket_include)\n+    for (p = opts->quote_include; p; p = p->next) {\n+      if (p == opts->bracket_include)\n \tfprintf (stderr, \"#include <...> search starts here:\\n\");\n-      fprintf (stderr, \" %s\\n\", p->fname);\n+      fprintf (stderr, \" %s\\n\", p->name);\n     }\n     fprintf (stderr, \"End of search list.\\n\");\n   }\n@@ -5416,7 +5272,15 @@ cpp_start_read (pfile, fname)\n   /* Must call finclude() on the main input before processing\n      -include switches; otherwise the -included text winds up\n      after the main input. */\n-  if (!finclude (pfile, f, fname, 0, NULL_PTR))\n+  ih_fake = (struct include_hash *) xmalloc (sizeof (struct include_hash));\n+  ih_fake->next = 0;\n+  ih_fake->next_this_file = 0;\n+  ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n+  ih_fake->name = fname;\n+  ih_fake->control_macro = 0;\n+  ih_fake->buf = (char *)-1;\n+  ih_fake->limit = 0;\n+  if (!finclude (pfile, f, ih_fake))\n     return 0;\n   output_line_command (pfile, 0, same_file);\n   pfile->only_seen_white = 2;\n@@ -5429,6 +5293,7 @@ cpp_start_read (pfile, fname)\n      means the -imacros files have to be done separately and first. */\n   \n   pfile->no_record_file++;\n+  opts->no_output++;\n   for (pend = opts->pending; pend; pend = pend->next)\n     {\n       if (pend->cmd != NULL)\n@@ -5443,13 +5308,23 @@ cpp_start_read (pfile, fname)\n \t        }\n \t      if (!cpp_push_buffer (pfile, NULL, 0))\n \t        return 0;\n-\t      opts->no_output++;\n-\t      if (finclude (pfile, fd, pend->arg, 0, NULL_PTR))\n+\n+\t      ih_fake = (struct include_hash *)\n+\t\t  xmalloc (sizeof (struct include_hash));\n+\t      ih_fake->next = 0;\n+\t      ih_fake->next_this_file = 0;\n+\t      ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n+\t      ih_fake->name = pend->arg;\n+\t      ih_fake->control_macro = 0;\n+\t      ih_fake->buf = (char *)-1;\n+\t      ih_fake->limit = 0;\n+\t      if (!finclude (pfile, fd, ih_fake))\n \t\tcpp_scan_buffer (pfile);\n-\t      opts->no_output--;\n+\t      free (ih_fake);\n \t    }\n \t}\n     }\n+  opts->no_output--;\n   opts->pending = nreverse_pending (opts->pending);\n   for (pend = opts->pending; pend; pend = pend->next)\n     {\n@@ -5465,7 +5340,17 @@ cpp_start_read (pfile, fname)\n \t        }\n \t      if (!cpp_push_buffer (pfile, NULL, 0))\n \t        return 0;\n-\t      if (finclude (pfile, fd, pend->arg, 0, NULL_PTR))\n+\n+\t      ih_fake = (struct include_hash *)\n+\t\t  xmalloc (sizeof (struct include_hash));\n+\t      ih_fake->next = 0;\n+\t      ih_fake->next_this_file = 0;\n+\t      ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n+\t      ih_fake->name = pend->arg;\n+\t      ih_fake->control_macro = 0;\n+\t      ih_fake->buf = (char *)-1;\n+\t      ih_fake->limit = 0;\n+\t      if (finclude (pfile, fd, ih_fake))\n \t        output_line_command (pfile, 0, enter_file);\n \t    }\n \t}\n@@ -5495,10 +5380,6 @@ cpp_reader_init (pfile)\n   pfile->token_buffer = (U_CHAR *) xmalloc (pfile->token_buffer_size);\n   CPP_SET_WRITTEN (pfile, 0);\n \n-  pfile->system_include_depth = 0;\n-  pfile->dont_repeat_files = 0;\n-  pfile->all_include_files = 0;\n-  pfile->max_include_len = 0;\n   pfile->timebuf = NULL;\n   pfile->only_seen_white = 1;\n   pfile->buffer = CPP_NULL_BUFFER(pfile);\n@@ -5644,131 +5525,121 @@ cpp_handle_option (pfile, argc, argv)\n  \tuser_label_prefix = \"\";\n       break;\n \n+    case 'I':\t\t\t/* Add directory to path for includes.  */\n+      if (!strcmp (argv[i] + 2, \"-\"))\n+        {\n+\t  if (! opts->ignore_srcdir)\n+\t    {\n+\t      opts->ignore_srcdir = 1;\n+\t      /* Don't use any preceding -I directories for #include <...>. */\n+\t      opts->quote_include = opts->bracket_include;\n+\t      opts->bracket_include = 0;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  char *fname;\n+\t  if (argv[i][2] != 0)\n+\t    fname = argv[i] + 2;\n+\t  else if (i + 1 == argc)\n+\t    goto missing_dirname;\n+\t  else\n+\t    fname = argv[++i];\n+\t  append_include_chain (pfile, &opts->bracket_include, fname, 0);\n+\t}\n+      break;\n+\n     case 'i':\n-      if (!strcmp (argv[i], \"-include\")\n-\t  || !strcmp (argv[i], \"-imacros\")) {\n-\tif (i + 1 == argc)\n-\t  goto missing_filename;\n-\telse\n-\t  push_pending (pfile, argv[i], argv[i+1]), i++;\n-      }\n-      if (!strcmp (argv[i], \"-iprefix\")) {\n-\tif (i + 1 == argc)\n-\t  goto missing_filename;\n-\telse\n-\t  opts->include_prefix = argv[++i];\n-      }\n-      if (!strcmp (argv[i], \"-ifoutput\")) {\n-\topts->output_conditionals = 1;\n-      }\n-      if (!strcmp (argv[i], \"-isystem\")) {\n-\tstruct file_name_list *dirtmp;\n-\t\n-\tif (i + 1 == argc)\n-\t  goto missing_filename;\n-\t\n-\tdirtmp = (struct file_name_list *)\n-\t  xmalloc (sizeof (struct file_name_list));\n-\tdirtmp->next = 0;\n-\tdirtmp->control_macro = 0;\n-\tdirtmp->c_system_include_path = 1;\n-\tdirtmp->fname = (char *) xmalloc (strlen (argv[i+1]) + 1);\n-\tstrcpy (dirtmp->fname, argv[++i]);\n-\tdirtmp->got_name_map = 0;\n-\t\n-\tif (opts->before_system == 0)\n-\t  opts->before_system = dirtmp;\n-\telse\n-\t  opts->last_before_system->next = dirtmp;\n-\topts->last_before_system = dirtmp; /* Tail follows the last one */\n-      }\n+      /* Add directory to beginning of system include path, as a system\n+\t include directory. */\n+      if (!strcmp (argv[i], \"-isystem\"))\n+        {\n+\t  if (i + 1 == argc)\n+\t    goto missing_filename;\n+\t  append_include_chain (pfile, &opts->system_include, argv[++i], 1);\n+\t}\n       /* Add directory to end of path for includes,\n \t with the default prefix at the front of its name.  */\n-      if (!strcmp (argv[i], \"-iwithprefix\")) {\n-\tstruct file_name_list *dirtmp;\n-\tchar *prefix;\n-\t\n-\tif (opts->include_prefix != 0)\n-\t  prefix = opts->include_prefix;\n-\telse {\n-\t  prefix = savestring (GCC_INCLUDE_DIR);\n-\t  /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n-\t  if (!strcmp (prefix + strlen (prefix) - 8, \"/include\"))\n-\t    prefix[strlen (prefix) - 7] = 0;\n-\t}\n-\t\n-\tdirtmp = (struct file_name_list *)\n-\t  xmalloc (sizeof (struct file_name_list));\n-\tdirtmp->next = 0;\t/* New one goes on the end */\n-\tdirtmp->control_macro = 0;\n-\tdirtmp->c_system_include_path = 0;\n-\tif (i + 1 == argc)\n-\t  goto missing_dirname;\n-\t\n-\tdirtmp->fname = (char *) xmalloc (strlen (argv[i+1])\n-\t\t\t\t\t  + strlen (prefix) + 1);\n-\tstrcpy (dirtmp->fname, prefix);\n-\tstrcat (dirtmp->fname, argv[++i]);\n-\tdirtmp->got_name_map = 0;\n-\t\n-\tif (opts->after_include == 0)\n-\t  opts->after_include = dirtmp;\n-\telse\n-\t  opts->last_after_include->next = dirtmp;\n-\topts->last_after_include = dirtmp; /* Tail follows the last one */\n+      else if (!strcmp (argv[i], \"-iwithprefix\"))\n+        {\n+\t  char *fname;\n+\t  if (i + 1 == argc)\n+\t    goto missing_dirname;\n+\t  ++i;\n+\n+\t  if (opts->include_prefix != 0)\n+\t    {\n+\t      fname = xmalloc (strlen (opts->include_prefix)\n+\t\t\t       + strlen (argv[i]) + 1);\n+\t      strcpy (fname, opts->include_prefix);\n+\t      strcat (fname, argv[i]);\n+\t    }\n+\t  else\n+\t    {\n+\t      fname = xmalloc (strlen (GCC_INCLUDE_DIR)\n+\t\t\t       + strlen (argv[i]) + 1);\n+\t      strcpy (fname, GCC_INCLUDE_DIR);\n+\t      /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n+\t      if (!strcmp (fname + strlen (fname) - 8, \"/include\"))\n+\t\tfname[strlen (fname) - 7] = 0;\n+\t      strcat (fname, argv[i]);\n+\t    }\n+\t  \n+\t  append_include_chain (pfile, &opts->system_include, fname, 0);\n       }\n       /* Add directory to main path for includes,\n \t with the default prefix at the front of its name.  */\n-      if (!strcmp (argv[i], \"-iwithprefixbefore\")) {\n-\tstruct file_name_list *dirtmp;\n-\tchar *prefix;\n-\t\n-\tif (opts->include_prefix != 0)\n-\t  prefix = opts->include_prefix;\n-\telse {\n-\t  prefix = savestring (GCC_INCLUDE_DIR);\n-\t  /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n-\t  if (!strcmp (prefix + strlen (prefix) - 8, \"/include\"))\n-\t    prefix[strlen (prefix) - 7] = 0;\n-\t}\n-\t\n-\tdirtmp = (struct file_name_list *)\n-\t  xmalloc (sizeof (struct file_name_list));\n-\tdirtmp->next = 0;\t/* New one goes on the end */\n-\tdirtmp->control_macro = 0;\n-\tdirtmp->c_system_include_path = 0;\n-\tif (i + 1 == argc)\n-\t  goto missing_dirname;\n-\t\n-\tdirtmp->fname = (char *) xmalloc (strlen (argv[i+1])\n-\t\t\t\t\t  + strlen (prefix) + 1);\n-\tstrcpy (dirtmp->fname, prefix);\n-\tstrcat (dirtmp->fname, argv[++i]);\n-\tdirtmp->got_name_map = 0;\n-\t\n-\tappend_include_chain (pfile, dirtmp, dirtmp);\n-      }\n+      else if (!strcmp (argv[i], \"-iwithprefix\"))\n+        {\n+\t  char *fname;\n+\t  if (i + 1 == argc)\n+\t    goto missing_dirname;\n+\t  ++i;\n+\n+\t  if (opts->include_prefix != 0)\n+\t    {\n+\t      fname = xmalloc (strlen (opts->include_prefix)\n+\t\t\t       + strlen (argv[i]) + 1);\n+\t      strcpy (fname, opts->include_prefix);\n+\t      strcat (fname, argv[i]);\n+\t    }\n+\t  else\n+\t    {\n+\t      fname = xmalloc (strlen (GCC_INCLUDE_DIR)\n+\t\t\t       + strlen (argv[i]) + 1);\n+\t      strcpy (fname, GCC_INCLUDE_DIR);\n+\t      /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n+\t      if (!strcmp (fname + strlen (fname) - 8, \"/include\"))\n+\t\tfname[strlen (fname) - 7] = 0;\n+\t      strcat (fname, argv[i]);\n+\t    }\n+\t  \n+\t  append_include_chain (pfile, &opts->bracket_include, fname, 0);\n+        }\n       /* Add directory to end of path for includes.  */\n-      if (!strcmp (argv[i], \"-idirafter\")) {\n-\tstruct file_name_list *dirtmp;\n-\t\n-\tdirtmp = (struct file_name_list *)\n-\t  xmalloc (sizeof (struct file_name_list));\n-\tdirtmp->next = 0;\t/* New one goes on the end */\n-\tdirtmp->control_macro = 0;\n-\tdirtmp->c_system_include_path = 0;\n-\tif (i + 1 == argc)\n-\t  goto missing_dirname;\n-\telse\n-\t  dirtmp->fname = argv[++i];\n-\tdirtmp->got_name_map = 0;\n-\t\n-\tif (opts->after_include == 0)\n-\t  opts->after_include = dirtmp;\n-\telse\n-\t  opts->last_after_include->next = dirtmp;\n-\topts->last_after_include = dirtmp; /* Tail follows the last one */\n-      }\n+      else if (!strcmp (argv[i], \"-idirafter\"))\n+        {\n+\t  if (i + 1 == argc)\n+\t    goto missing_dirname;\n+\t  append_include_chain (pfile, &opts->after_include, argv[++i], 0);\n+\t}\n+      else if (!strcmp (argv[i], \"-include\") || !strcmp (argv[i], \"-imacros\"))\n+        {\n+\t  if (i + 1 == argc)\n+\t    goto missing_filename;\n+\t  else\n+\t    push_pending (pfile, argv[i], argv[i+1]), i++;\n+        }\n+      else if (!strcmp (argv[i], \"-iprefix\"))\n+        {\n+\t  if (i + 1 == argc)\n+\t    goto missing_filename;\n+\t  else\n+\t      opts->include_prefix = argv[++i];\n+\t}\n+      else if (!strcmp (argv[i], \"-ifoutput\"))\n+\topts->output_conditionals = 1;\n+\n       break;\n       \n     case 'o':\n@@ -6051,34 +5922,6 @@ cpp_handle_option (pfile, argc, argv)\n       opts->dollars_in_ident = 0;\n       break;\n       \n-    case 'I':\t\t\t/* Add directory to path for includes.  */\n-      {\n-\tstruct file_name_list *dirtmp;\n-\t\n-\tif (! CPP_OPTIONS(pfile)->ignore_srcdir\n-\t    && !strcmp (argv[i] + 2, \"-\")) {\n-\t  CPP_OPTIONS (pfile)->ignore_srcdir = 1;\n-\t  /* Don't use any preceding -I directories for #include <...>.  */\n-\t  CPP_OPTIONS (pfile)->first_bracket_include = 0;\n-\t}\n-\telse {\n-\t  dirtmp = (struct file_name_list *)\n-\t    xmalloc (sizeof (struct file_name_list));\n-\t  dirtmp->next = 0;\t\t/* New one goes on the end */\n-\t  dirtmp->control_macro = 0;\n-\t  dirtmp->c_system_include_path = 0;\n-\t  if (argv[i][2] != 0)\n-\t    dirtmp->fname = argv[i] + 2;\n-\t  else if (i + 1 == argc)\n-\t    goto missing_dirname;\n-\t  else\n-\t    dirtmp->fname = argv[++i];\n-\t  dirtmp->got_name_map = 0;\n-\t  append_include_chain (pfile, dirtmp, dirtmp);\n-\t}\n-      }\n-    break;\n-    \n     case 'n':\n       if (!strcmp (argv[i], \"-nostdinc\"))\n \t/* -nostdinc causes no default include directories.\n@@ -6171,6 +6014,28 @@ cpp_finish (pfile)\n \t    }\n \t}\n     }\n+\n+#if 0\n+  /* Debugging: dump statistics on the include hash table. */\n+  {\n+      struct include_hash *x;\n+      int i, j;\n+\n+      for(i = 0; i < ALL_INCLUDE_HASHSIZE; i++)\n+      {\n+\t  x = pfile->all_include_files[i];\n+\t  j = 0;\n+\t  while(x)\n+\t  {\n+\t      j++;\n+\t      x = x->next;\n+\t  }\n+\t  fprintf(stderr, \"%d/%d \", i, j);\n+      }\n+      fputc('\\n', stderr);\n+  }\n+#endif\n+  \n }\n \n /* Free resources used by PFILE.\n@@ -6204,33 +6069,20 @@ cpp_cleanup (pfile)\n       free (temp);\n     }\n \n-  while (pfile->dont_repeat_files)\n-    {\n-      struct file_name_list *temp = pfile->dont_repeat_files;\n-      pfile->dont_repeat_files = temp->next;\n-      free (temp->fname);\n-      free (temp);\n-    }\n-\n-  while (pfile->all_include_files)\n+  for (i = ALL_INCLUDE_HASHSIZE; --i >= 0; )\n     {\n-      struct file_name_list *temp = pfile->all_include_files;\n-      pfile->all_include_files = temp->next;\n-      free (temp->fname);\n-      free (temp);\n-    }\n-\n-  for (i = IMPORT_HASH_SIZE; --i >= 0; )\n-    {\n-      register struct import_file *imp = pfile->import_hash_table[i];\n+      struct include_hash *imp = pfile->all_include_files[i];\n       while (imp)\n \t{\n-\t  struct import_file *next = imp->next;\n+\t  struct include_hash *next = imp->next;\n+#if 0\n+\t  /* This gets freed elsewhere - I think. */\n \t  free (imp->name);\n+#endif\n \t  free (imp);\n \t  imp = next;\n \t}\n-      pfile->import_hash_table[i] = 0;\n+      pfile->all_include_files[i] = 0;\n     }\n \n   for (i = ASSERTION_HASHSIZE; --i >= 0; )"}, {"sha": "fe2810237dcf33516214e95e44853aca0f0eb9b4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=0b3d776a4260dc4dbecb16a0cd63aec58c96bb7d", "patch": "@@ -96,17 +96,6 @@ extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n /* This frees resources used by PFILE. */\n extern void cpp_cleanup PARAMS ((cpp_reader *PFILE));\n \n-/* Maintain and search list of included files, for #import.  */\n-\n-#define IMPORT_HASH_SIZE 31\n-\n-struct import_file {\n-  char *name;\n-  ino_t inode;\n-  dev_t dev;\n-  struct import_file *next;\n-};\n-\n /* If we have a huge buffer, may need to cache more recent counts */\n #define CPP_LINE_BASE(BUF) ((BUF)->buf + (BUF)->line_base)\n \n@@ -120,10 +109,14 @@ struct cpp_buffer {\n   char *fname;\n   /* Filename specified with #line command.  */\n   char *nominal_fname;\n+  /* Actual directory of this file, used only for \"\" includes */\n+  char *dir;\n+  size_t dlen;\n \n-  /* Record where in the search path this file was found.\n-     For #include_next.  */\n-  struct file_name_list *dir;\n+  /* Pointer into the include hash table.  Used for include_next and\n+     to record control macros.\n+     ->fname is an alias to ->ihash->fname. */\n+  struct include_hash *ihash;\n \n   long line_base;\n   long lineno; /* Line number at CPP_LINE_BASE. */\n@@ -185,20 +178,13 @@ struct cpp_reader {\n   /* Current depth in #include directives that use <...>.  */\n   int system_include_depth;\n \n-  /* List of included files that contained #pragma once.  */\n-  struct file_name_list *dont_repeat_files;\n-\n-  /* List of other included files.\n-     If ->control_macro if nonzero, the file had a #ifndef\n-     around the entire contents, and ->control_macro gives the macro name.  */\n-  struct file_name_list *all_include_files;\n+  /* Hash table of other included files.  See cppfiles.c */\n+#define ALL_INCLUDE_HASHSIZE 71\n+  struct include_hash *all_include_files[ALL_INCLUDE_HASHSIZE];\n \n   /* Current maximum length of directory names in the search path\n      for include files.  (Altered as we get more of them.)  */\n-  int max_include_len;\n-\n-  /* Hash table of files already included with #include or #import.  */\n-  struct import_file *import_hash_table[IMPORT_HASH_SIZE];\n+  unsigned int max_include_len;\n \n   struct if_stack *if_stack;\n \n@@ -441,23 +427,12 @@ struct cpp_options {\n \n   char done_initializing;\n \n-  struct file_name_list *include;\t/* First dir to search */\n-  /* First dir to search for <file> */\n-  /* This is the first element to use for #include <...>.\n-     If it is 0, use the entire chain for such includes.  */\n-  struct file_name_list *first_bracket_include;\n-  /* This is the first element in the chain that corresponds to\n-     a directory of system header files.  */\n-  struct file_name_list *first_system_include;\n-  struct file_name_list *last_include;\t/* Last in chain */\n-\n-  /* Chain of include directories to put at the end of the other chain.  */\n-  struct file_name_list *after_include;\n-  struct file_name_list *last_after_include;\t/* Last in chain */\n-\n-  /* Chain to put at the start of the system include files.  */\n-  struct file_name_list *before_system;\n-  struct file_name_list *last_before_system;\t/* Last in chain */\n+  /* Search paths for include files.  system_include, after_include are\n+     only used during option parsing. */\n+  struct file_name_list *quote_include;\t /* First dir to search for \"file\" */\n+  struct file_name_list *bracket_include;/* First dir to search for <file> */\n+  struct file_name_list *system_include; /* First dir with system headers  */\n+  struct file_name_list *after_include;  /* Headers to search after system */\n \n   /* Directory prefix that should replace `/usr' in the standard\n      include file directories.  */\n@@ -506,22 +481,45 @@ struct cpp_options {\n #define CPP_PEDANTIC(PFILE) (CPP_OPTIONS (PFILE)->pedantic)\n #define CPP_PRINT_DEPS(PFILE) (CPP_OPTIONS (PFILE)->print_deps)\n \n+/* List of directories to look for include files in. */\n struct file_name_list\n-  {\n-    struct file_name_list *next;\n-    char *fname;\n-    /* If the following is nonzero, it is a macro name.\n-       Don't include the file again if that macro is defined.  */\n-    U_CHAR *control_macro;\n-    /* If the following is nonzero, it is a C-language system include\n-       directory.  */\n-    int c_system_include_path;\n-    /* Mapping of file names for this directory.  */\n-    struct file_name_map *name_map;\n-    /* Non-zero if name_map is valid.  */\n-    int got_name_map;\n-  };\n+{\n+  struct file_name_list *next;\n+  char *name;\n+  unsigned int nlen;\n+  /* We use these to tell if the directory mentioned here is a duplicate\n+     of an earlier directory on the search path. */\n+  ino_t ino;\n+  dev_t dev;\n+  /* If the following is nonzero, it is a C-language system include\n+     directory.  */\n+  int sysp;\n+  /* Mapping of file names for this directory.\n+     Only used on MS-DOS and related platforms. */\n+  struct file_name_map *name_map;\n+};\n+#define ABSOLUTE_PATH ((struct file_name_list *)-1)\n \n+/* This structure is used for the table of all includes.  It is\n+   indexed by the `short name' (the name as it appeared in the\n+   #include statement) which is stored in *nshort.  */\n+struct include_hash\n+{\n+  struct include_hash *next;\n+  /* Next file with the same short name but a\n+     different (partial) pathname). */\n+  struct include_hash *next_this_file;\n+\n+  /* Location of the file in the include search path.\n+     Used for include_next */\n+  struct file_name_list *foundhere;\n+  char *name;\t\t/* (partial) pathname of file */\n+  char *nshort;\t\t/* name of file as referenced in #include */\n+  char *control_macro;\t/* macro, if any, preventing reinclusion - see\n+\t\t\t   redundant_include_p */\n+  char *buf, *limit;\t/* for file content cache, not yet implemented */\n+};\n+    \n /* If a buffer's dir field is SELF_DIR_DUMMY, it means the file was found\n    via the same directory as the file that #included it.  */\n #define SELF_DIR_DUMMY ((struct file_name_list *) (~0))\n@@ -706,15 +704,17 @@ extern void cpp_print_containing_files PROTO ((cpp_reader *));\n \n /* In cppfiles.c */\n extern void append_include_chain\tPROTO ((cpp_reader *,\n-\t\t\t\t\t\tstruct file_name_list *,\n-\t\t\t\t\t\tstruct file_name_list *));\n-extern int finclude\t\t\tPROTO ((cpp_reader *, int, char *,\n-\t\t\t\t\t\tint, struct file_name_list *));\n+\t\t\t\t\t\tstruct file_name_list **,\n+\t\t\t\t\t\tchar *, int));\n+extern void merge_include_chains\tPROTO ((struct cpp_options *));\n extern int find_include_file\t\tPROTO ((cpp_reader *, char *,\n-\t\t\t\t\t\tunsigned long, char *, int,\n \t\t\t\t\t\tstruct file_name_list *,\n-\t\t\t\t\t\tstruct file_name_list **));\n+\t\t\t\t\t\tstruct include_hash **,\n+\t\t\t\t\t\tint *));\n+extern int finclude\t\t\tPROTO ((cpp_reader *, int,\n+\t\t\t\t\t        struct include_hash *));\n extern void deps_output\t\t\tPROTO ((cpp_reader *, char *, int));\n+extern struct include_hash *include_hash PROTO ((cpp_reader *, char *, int));\n \n /* Bleargh. */\n extern char *savestring\t\t\tPROTO ((char *));"}]}