{"sha": "b97366d9b363fd591fb7caa31ffb46a5c106c241", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk3MzY2ZDliMzYzZmQ1OTFmYjdjYWEzMWZmYjQ2YTVjMTA2YzI0MQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@wasabisystems.com", "date": "2003-11-30T20:25:46Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2003-11-30T20:25:46Z"}, "message": "* doschk.c: Remove.\n\nFrom-SVN: r74072", "tree": {"sha": "52f74f5a73d4d02cbbf404ddbdf9cddcb7471fb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52f74f5a73d4d02cbbf404ddbdf9cddcb7471fb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b97366d9b363fd591fb7caa31ffb46a5c106c241", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b97366d9b363fd591fb7caa31ffb46a5c106c241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b97366d9b363fd591fb7caa31ffb46a5c106c241", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b97366d9b363fd591fb7caa31ffb46a5c106c241/comments", "author": null, "committer": null, "parents": [{"sha": "936b13179f2c50dbfc0ace293cf7558b6399d6ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/936b13179f2c50dbfc0ace293cf7558b6399d6ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/936b13179f2c50dbfc0ace293cf7558b6399d6ea"}], "stats": {"total": 364, "additions": 4, "deletions": 360}, "files": [{"sha": "42deabae3c8dad2403056d3482f44bf720cf74d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97366d9b363fd591fb7caa31ffb46a5c106c241/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97366d9b363fd591fb7caa31ffb46a5c106c241/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b97366d9b363fd591fb7caa31ffb46a5c106c241", "patch": "@@ -1,3 +1,7 @@\n+2003-11-30  Ben Elliston  <bje@wasabisystems.com>\n+\n+\t* doschk.c: Remove.\n+\n 2003-11-30  Richard Sandiford  <rsandifo@redhat.com>\n \n \tPR target/12727"}, {"sha": "d024efc14ce110f619606455a05e093ac1a797ab", "filename": "gcc/doschk.c", "status": "removed", "additions": 0, "deletions": 360, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936b13179f2c50dbfc0ace293cf7558b6399d6ea/gcc%2Fdoschk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936b13179f2c50dbfc0ace293cf7558b6399d6ea/gcc%2Fdoschk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoschk.c?ref=936b13179f2c50dbfc0ace293cf7558b6399d6ea", "patch": "@@ -1,360 +0,0 @@\n-/*\n-**  DosFCheck - check file names for DOS consistency\n-**\n-**  Distribute freely, it only encourages DOS compatibility!\n-**  - DJ Delorie\n-*/\n-\n-/* This file is not part of GCC.  */\n-\n-#include <stdio.h>\n-#ifdef __MSDOS__\n-#include <alloc.h>\n-#else\n-#include <malloc.h>\n-#endif\n-#include <ctype.h>\n-#include <string.h>\n-\n-typedef struct ENT\n-{\n-  struct ENT *next;\n-  char *dos_name;\n-  char *full_name;\n-  char *path;\n-  int tagged;\n-} ENT;\n-\n-ENT *eroot = 0;\n-\n-int first_inv = 1;\n-int first_msg = 1;\n-\n-/****************************************************************\\\n- *  Utility routines\t\t\t\t\t\t*\n-\\****************************************************************/\n-\n-void\n-invalid_msg ()\n-{\n-  if (first_inv)\n-    {\n-      if (first_msg)\n-\tfirst_msg = 0;\n-      else\n-\tputchar ('\\n');\n-      printf (\"The following files are not valid DOS file names:\\n\");\n-      first_inv = 0;\n-    }\n-}\n-\n-ENT *\n-alloc_ent ()\n-{\n-  ENT *rv = (ENT *)malloc (sizeof (ENT));\n-  if (rv == 0)\n-    {\n-      fprintf (stderr, \"Unable to allocate memory for an ENT\\n\");\n-      exit (1);\n-    }\n-  memset (rv, 0, sizeof (ENT));\n-  return rv;\n-}\n-\n-void\n-fill_ent (ent, path)\n-ENT *ent;\n-char *path;\n-{\n-  char *first = path;\n-  char *null = path+strlen (path);\n-  char *last_slash = strrchr (path, '/');\n-  char *cp, *dp;\n-  int dots_seen, chars_seen;\n-\n-  if (last_slash+1 == null)\n-    {\n-      * --null = '\\0';\n-      last_slash = strrchr (path, '/');\n-    }\n-\n-  if (!last_slash)\n-    {\n-      last_slash = first-1;\n-    }\n-\n-  if (null-last_slash < 13)\n-    ent->dos_name = (char *)malloc (null-last_slash);\n-  else\n-    ent->dos_name = (char *)malloc (13);\n-  ent->full_name = (char *)malloc (null-last_slash);\n-  ent->path = (char *)malloc (last_slash-first+1);\n-\n-  strcpy (ent->full_name, last_slash+1);\n-  if (last_slash > first)\n-    {\n-      strncpy (ent->path, first, last_slash-first);\n-      ent->path[last_slash-first] = '\\0';\n-    }\n-  else\n-    *ent->path = '\\0';\n-\n-  cp = last_slash+1;\n-  dp = ent->dos_name;\n-  dots_seen = 0;\n-  chars_seen = 0;\n-  while (1)\n-    {\n-      if (! *cp)\n-\tbreak;\n-      switch (*cp)\n-\t{\n-\tcase '.':\n-\t  if (cp == last_slash+1 && strcmp (last_slash+1, \".\"))\n-\t    {\n-\t      invalid_msg ();\n-\t      printf (\"%s - file name cannot start with dot\\n\", path);\n-\t      *dp = 0;\n-\t      break;\n-\t    }\n-\t  if (dots_seen == 1)\n-\t    {\n-\t      invalid_msg ();\n-\t      printf (\"%s - too many dots\\n\", path);\n-\t      *dp = '\\0';\n-\t      break;\n-\t    }\n-\t  *dp++ = '.';\n-\t  chars_seen = 0;\n-\t  dots_seen++;\n-\t  break;\n-\tcase '\"':\n-\tcase '*':\n-\tcase '+':\n-\tcase ',':\n-\tcase ';':\n-\tcase '<':\n-\tcase '=':\n-\tcase '>':\n-\tcase '?':\n-\tcase '[':\n-\tcase '\\\\':\n-\tcase ']':\n-\tcase '|':\n-\t  invalid_msg ();\n-\t  printf (\"%s - invalid character `%c'\\n\", path, *cp);\n-\t  *dp++ = '?';\n-\t  chars_seen++;\n-\t  break;\n-\tdefault:\n-\t  if (dots_seen)\n-\t    {\n-\t      if (chars_seen >= 3)\n-\t\tbreak;\n-\t    }\n-\t  else\n-\t    if (chars_seen >= 8)\n-\t      break;\n-\t  if ((*cp <= ' ') || (*cp >= 0x7f))\n-\t    {\n-\t      invalid_msg ();\n-\t      printf (\"%s - invalid character `%c'\\n\", path, *cp);\n-\t      *dp++ = '?';\n-\t      chars_seen++;\n-\t      break;\n-\t    }\n-\t  if (islower (*cp))\n-\t    *dp++ = toupper (*cp);\n-\t  else\n-\t    *dp++ = *cp;\n-\t  chars_seen++;\n-\t  break;\n-\t}\n-      cp++;\n-    }\n-  *dp++ = '\\0';\n-}\n-\n-int\n-compare_ent_dosname (e1, e2)\n-ENT **e1;\n-ENT **e2;\n-{\n-  int r = strcmp ((*e1)->dos_name, (*e2)->dos_name);\n-  if (r == 0)\n-    r = strcmp ((*e1)->path, (*e2)->path);\n-  if (r == 0)\n-    r = strcmp ((*e1)->full_name, (*e2)->full_name);\n-  return r;\n-}\n-\n-int\n-compare_ent_fullname (e1, e2)\n-ENT **e1;\n-ENT **e2;\n-{\n-  int r = strncmp ((*e1)->full_name, (*e2)->full_name, 14);\n-  if (r == 0)\n-    r = strcmp ((*e1)->path, (*e2)->path);\n-  if (r == 0)\n-    r = strcmp ((*e1)->full_name, (*e2)->full_name);\n-  return r;\n-}\n-\n-char *\n-mpath (ent)\n-ENT *ent;\n-{\n-  static char buf[500];\n-  if (ent->path && ent->path[0])\n-    sprintf (buf, \"%s/%s\", ent->path, ent->full_name);\n-  else\n-    return ent->full_name;\n-  return buf;\n-}\n-\n-/****************************************************************\\\n- *  List handling routines\t\t\t\t\t*\n-\\****************************************************************/\n-\n-void\n-add_ent (ent)\n-ENT *ent;\n-{\n-  ent->next = eroot;\n-  eroot = ent;\n-}\n-\n-void\n-handle_input (line)\n-char *line;\n-{\n-  ENT *ent = alloc_ent ();\n-  fill_ent (ent, line);\n-  add_ent (ent);\n-}\n-\n-void\n-display_problems ()\n-{\n-  ENT **elist, *ent;\n-  int ecount, i, first, first_err;\n-\n-  for (ecount=0, ent=eroot; ent; ent=ent->next, ecount++);\n-  elist = (ENT **)malloc (sizeof (ENT *) * ecount);\n-  for (ecount=0, ent=eroot; ent; ent=ent->next, ecount++)\n-    elist[ecount] = ent;\n-\n-  qsort (elist, ecount, sizeof (ENT *), compare_ent_dosname);\n-\n-  first = 1;\n-  first_err = 1;\n-  for (i=0; i<ecount-1; i++)\n-    {\n-      if ((strcmp (elist[i]->dos_name, elist[i+1]->dos_name) == 0)\n-\t  && (strcmp (elist[i]->path, elist[i+1]->path) == 0))\n-\t{\n-\t  if (first_err)\n-\t    {\n-\t      if (first_msg)\n-\t\tfirst_msg = 0;\n-\t      else\n-\t\tputchar ('\\n');\n-\t      printf (\"The following resolve to the same DOS file names:\\n\");\n-\t      first_err = 0;\n-\t    }\n-\t  if (first)\n-\t    {\n-\t      printf (\"%14s : %s\\n\", elist[i]->dos_name, mpath (elist[i]));\n-\t      first = 0;\n-\t    }\n-\t  printf (\"\\t\\t %s\\n\", mpath (elist[i+1]));\n-\t}\n-      else\n-\tfirst = 1;\n-    }\n-\n-  qsort (elist, ecount, sizeof (ENT *), compare_ent_fullname);\n-\n-  first = 1;\n-  first_err = 1;\n-  for (i=0; i<ecount-1; i++)\n-    {\n-      if ((strncmp (elist[i]->full_name, elist[i+1]->full_name, 14) == 0)\n-\t  && (strcmp (elist[i]->path, elist[i+1]->path) == 0))\n-\t{\n-\t  if (first_err)\n-\t    {\n-\t      if (first_msg)\n-\t\tfirst_msg = 0;\n-\t      else\n-\t\tputchar ('\\n');\n-\t      printf (\"The following resolve to the same SysV file names:\\n\");\n-\t      first_err = 0;\n-\t    }\n-\t  if (first)\n-\t    {\n-\t      printf (\"%.14s : %s\\n\", elist[i]->full_name, mpath (elist[i]));\n-\t      first = 0;\n-\t      elist[i]->tagged = 1;\n-\t    }\n-\t  printf (\"\\t\\t %s\\n\", mpath (elist[i+1]));\n-\t  elist[i+1]->tagged = 1;\n-\t}\n-      else\n-\tfirst = 1;\n-    }\n-\n-  first_err = 1;\n-  for (i=0; i<ecount; i++)\n-    {\n-      if ((strlen (elist[i]->full_name) > 14) && !elist[i]->tagged)\n-\t{\n-\t  if (first_err)\n-\t    {\n-\t      if (first_msg)\n-\t\tfirst_msg = 0;\n-\t      else\n-\t\tputchar ('\\n');\n-\t      printf (\"The following file names are too long for SysV:\\n\");\n-\t      first_err = 0;\n-\t    }\n-\t  printf (\"%.14s : %s\\n\", elist[i]->full_name, mpath (elist[i]));\n-\t}\n-    }\n-}\n-\n-/****************************************************************\\\n- *  Main entry point\t\t\t\t\t\t*\n-\\****************************************************************/\n-\n-main (argc, argv)\n-int argc;\n-char **argv;\n-{\n-  FILE *input = stdin;\n-  if (argc > 1)\n-    {\n-      input = fopen (argv[1], \"r\");\n-      if (!input)\n-\t{\n-\t  perror (argv[1]);\n-\t  exit (1);\n-\t}\n-    }\n-  while (1)\n-    {\n-      char line[500];\n-      char *lp;\n-      fgets (line, 500, input);\n-      if (feof (input))\n-\tbreak;\n-      lp = line+strlen (line);\n-      while ((lp != line) && (*lp <= ' '))\n-\tlp--;\n-      lp[1] = 0;\n-      handle_input (line);\n-    }\n-  display_problems ();\n-}\n-"}]}