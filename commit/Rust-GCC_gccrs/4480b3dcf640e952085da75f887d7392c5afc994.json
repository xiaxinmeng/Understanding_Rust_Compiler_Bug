{"sha": "4480b3dcf640e952085da75f887d7392c5afc994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ4MGIzZGNmNjQwZTk1MjA4NWRhNzVmODg3ZDczOTJjNWFmYzk5NA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2003-02-28T11:38:56Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2003-02-28T11:38:56Z"}, "message": "Makefile.am (nat_source_files): Remove java/io/natObjectOutputStream.cc.\n\n        * Makefile.am (nat_source_files): Remove\n        java/io/natObjectOutputStream.cc.\n        * Makefile.in: Regenerated.\n        * mauve-libgcj: Don't exclude java.io.ObjectInputOutput tests.\n        * java/io/ObjectStreamField.java (typename): New field.\n        (ObjectStreamField(String, Class)): Initialize new field.\n        (ObjectStreamField(String, String)): New Constructor.\n        (getTypeCode): Use new field.\n        (getTypeString): Use new field.\n        * java/io/ObjectOutputStream.java (writeObject): Rethrow fatal\n        ObjectStreamExceptions. Remember and reset old BlockDataMode.\n        Handle reading of Proxy classes. Never drain(), just write\n        TC_ENDBLOCKDATA. Rethrow ObjectStreamExceptions.\n        (drain): Check writeDataAsBlocks before calling writeBlockDataHeader.\n        (flush): Call flush(), not just drain().\n        (writeBoolean): Always use blockDataOutput.\n        (writeByte): Likewise.\n        (writeShort): Likewise.\n        (writeChar): Likewise.\n        (writeInt): Likewise.\n        (writeLong): Likewise.\n        (writeFloat): Likewise.\n        (writeDouble): Likewise.\n        (writeBytes): Likewise.\n        (putfield (put(String,Object))): Throw IllegalArgumentException if\n        field cannot be found.\n        (putfield (write(ObjectOutput))): Remember old BlockDataMode.\n        (writeArraySizeAndElements): Write byte[] in one go.\n        (writeFields): Write TC_ENDBLOCKDATA when call_write_method, otherwise\n        set BlockDataMode to false.\n        (annotateProxyClass): New method.\n        (defaultProtocolVersion): Now defaults to PROTOCOL_VERSION_2\n        (getField): No longer native.\n        (getMethod): Likewise.\n        (setBlockDataMode): Always drain() on switch, return old mode.\n        (static): New static code block.\n        * java/io/natObjectOutputStream.cc: Removed.\n        * java/io/ObjectInputStream.java (getField): No longer native.\n        (getMethod): Likewise.\n        (readObject): Remember and reset old BlockDataMode. Track whether\n        object is consumed. Handle TC_ENDBLOCKDATA, TC_PROXYCLASSDESC and\n        TC_LONGSTRING.\n        (defaultReadObject): Set BlockDataMode to false during readFields.\n        (resolveClass): Create new SecurityManager if necessary.\n        Use Class.forName() if null ClassLoader found.\n        (read(byte[],int,int): Copy remaining bytes to data before calling\n        readNextBlock().\n        (readFields): Set and reset BlockDataMode on call_read_method.\n        Catch NoSuchFieldErrors.\n        (setBlockDataMode): Return old mode.\n        (static): New static code block.\n        * java/io/natObjectInputStream.cc (getField): Removed.\n        (getMethod): Likewise.\n\nFrom-SVN: r63556", "tree": {"sha": "eb6527381e25675338e21ca7ad2996e4d91330c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb6527381e25675338e21ca7ad2996e4d91330c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4480b3dcf640e952085da75f887d7392c5afc994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4480b3dcf640e952085da75f887d7392c5afc994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4480b3dcf640e952085da75f887d7392c5afc994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4480b3dcf640e952085da75f887d7392c5afc994/comments", "author": null, "committer": null, "parents": [{"sha": "28727f1fb365c5cc0d02394dd06d57a57eb0fa76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28727f1fb365c5cc0d02394dd06d57a57eb0fa76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28727f1fb365c5cc0d02394dd06d57a57eb0fa76"}], "stats": {"total": 1465, "additions": 812, "deletions": 653}, "files": [{"sha": "9b95932ae1aa0568840d33356f48800404c4e5fc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4480b3dcf640e952085da75f887d7392c5afc994", "patch": "@@ -1,3 +1,59 @@\n+2003-02-28  Mark Wielaard  <mark@klomp.org>\n+\n+\t* Makefile.am (nat_source_files): Remove\n+\tjava/io/natObjectOutputStream.cc.\n+\t* Makefile.in: Regenerated.\n+\t* mauve-libgcj: Don't exclude java.io.ObjectInputOutput tests.\n+\t* java/io/ObjectStreamField.java (typename): New field.\n+\t(ObjectStreamField(String, Class)): Initialize new field.\n+\t(ObjectStreamField(String, String)): New Constructor.\n+\t(getTypeCode): Use new field.\n+\t(getTypeString): Use new field.\n+\t* java/io/ObjectOutputStream.java (writeObject): Rethrow fatal\n+\tObjectStreamExceptions. Remember and reset old BlockDataMode.\n+\tHandle reading of Proxy classes. Never drain(), just write\n+\tTC_ENDBLOCKDATA. Rethrow ObjectStreamExceptions.\n+\t(drain): Check writeDataAsBlocks before calling writeBlockDataHeader.\n+\t(flush): Call flush(), not just drain().\n+\t(writeBoolean): Always use blockDataOutput.\n+\t(writeByte): Likewise.\n+\t(writeShort): Likewise.\n+\t(writeChar): Likewise.\n+\t(writeInt): Likewise.\n+\t(writeLong): Likewise.\n+\t(writeFloat): Likewise.\n+\t(writeDouble): Likewise.\n+\t(writeBytes): Likewise.\n+\t(putfield (put(String,Object))): Throw IllegalArgumentException if\n+\tfield cannot be found.\n+\t(putfield (write(ObjectOutput))): Remember old BlockDataMode.\n+\t(writeArraySizeAndElements): Write byte[] in one go.\n+\t(writeFields): Write TC_ENDBLOCKDATA when call_write_method, otherwise\n+\tset BlockDataMode to false.\n+\t(annotateProxyClass): New method.\n+\t(defaultProtocolVersion): Now defaults to PROTOCOL_VERSION_2\n+\t(getField): No longer native.\n+\t(getMethod): Likewise.\n+\t(setBlockDataMode): Always drain() on switch, return old mode.\n+\t(static): New static code block.\n+\t* java/io/natObjectOutputStream.cc: Removed.\n+\t* java/io/ObjectInputStream.java (getField): No longer native.\n+\t(getMethod): Likewise.\n+\t(readObject): Remember and reset old BlockDataMode. Track whether\n+\tobject is consumed. Handle TC_ENDBLOCKDATA, TC_PROXYCLASSDESC and\n+\tTC_LONGSTRING.\n+\t(defaultReadObject): Set BlockDataMode to false during readFields.\n+\t(resolveClass): Create new SecurityManager if necessary.\n+\tUse Class.forName() if null ClassLoader found.\n+\t(read(byte[],int,int): Copy remaining bytes to data before calling\n+\treadNextBlock().\n+\t(readFields): Set and reset BlockDataMode on call_read_method.\n+\tCatch NoSuchFieldErrors.\n+\t(setBlockDataMode): Return old mode.\n+\t(static): New static code block.\n+\t* java/io/natObjectInputStream.cc (getField): Removed.\n+\t(getMethod): Likewise.\n+\n 2003-02-27  Michael Koch  <konqueror@gmx.de>\n \n \t* java/beans/Beans.java,"}, {"sha": "297bc4acff8482bc2f4a99015416f1b89f753d6b", "filename": "libjava/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=4480b3dcf640e952085da75f887d7392c5afc994", "patch": "@@ -2496,7 +2496,6 @@ gnu/java/nio/natSocketChannelImpl.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/io/natObjectInputStream.cc \\\n-java/io/natObjectOutputStream.cc \\\n java/io/natVMObjectStreamClass.cc \\\n java/lang/natCharacter.cc \\\n java/lang/natClass.cc \\"}, {"sha": "333e0a3659252998914bfe469e27bee9e54024b1", "filename": "libjava/Makefile.in", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=4480b3dcf640e952085da75f887d7392c5afc994", "patch": "@@ -2257,7 +2257,6 @@ gnu/java/nio/natSocketChannelImpl.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/io/natObjectInputStream.cc \\\n-java/io/natObjectOutputStream.cc \\\n java/io/natVMObjectStreamClass.cc \\\n java/lang/natCharacter.cc \\\n java/lang/natClass.cc \\\n@@ -2432,11 +2431,11 @@ gnu/java/nio/natIntBufferImpl.lo gnu/java/nio/natLongBufferImpl.lo \\\n gnu/java/nio/natSelectorImpl.lo gnu/java/nio/natShortBufferImpl.lo \\\n gnu/java/nio/natSocketChannelImpl.lo java/io/natFile.lo \\\n java/io/natFileDescriptor.lo java/io/natObjectInputStream.lo \\\n-java/io/natObjectOutputStream.lo java/io/natVMObjectStreamClass.lo \\\n-java/lang/natCharacter.lo java/lang/natClass.lo \\\n-java/lang/natClassLoader.lo java/lang/natConcreteProcess.lo \\\n-java/lang/natDouble.lo java/lang/natFloat.lo java/lang/natMath.lo \\\n-java/lang/natObject.lo java/lang/natRuntime.lo java/lang/natString.lo \\\n+java/io/natVMObjectStreamClass.lo java/lang/natCharacter.lo \\\n+java/lang/natClass.lo java/lang/natClassLoader.lo \\\n+java/lang/natConcreteProcess.lo java/lang/natDouble.lo \\\n+java/lang/natFloat.lo java/lang/natMath.lo java/lang/natObject.lo \\\n+java/lang/natRuntime.lo java/lang/natString.lo \\\n java/lang/natStringBuffer.lo java/lang/natSystem.lo \\\n java/lang/natThread.lo java/lang/natVMSecurityManager.lo \\\n java/lang/ref/natReference.lo java/lang/reflect/natArray.lo \\\n@@ -2599,7 +2598,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -3270,7 +3269,6 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/io/WriteAbortedException.P .deps/java/io/Writer.P \\\n .deps/java/io/natFile.P .deps/java/io/natFileDescriptor.P \\\n .deps/java/io/natObjectInputStream.P \\\n-.deps/java/io/natObjectOutputStream.P \\\n .deps/java/io/natVMObjectStreamClass.P \\\n .deps/java/lang/AbstractMethodError.P \\\n .deps/java/lang/ArithmeticException.P \\"}, {"sha": "f2b2df8ed58de9aab4277c1cff50fb1afef3b224", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 458, "deletions": 364, "changes": 822, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=4480b3dcf640e952085da75f887d7392c5afc994", "patch": "@@ -1,5 +1,5 @@\n /* ObjectInputStream.java -- Class used to read serialized objects\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,8 +38,6 @@\n \n package java.io;\n \n-import gnu.classpath.Configuration;\n-\n import java.lang.reflect.Array;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Proxy;\n@@ -53,7 +51,7 @@\n import java.lang.reflect.Method;\n import java.lang.reflect.InvocationTargetException;\n \n-\n+import gnu.classpath.Configuration;\n \n public class ObjectInputStream extends InputStream\n   implements ObjectInput, ObjectStreamConstants\n@@ -130,286 +128,343 @@ public final Object readObject () throws ClassNotFoundException, IOException\n     Object ret_val;\n     was_deserializing = this.isDeserializing;\n \n-    if (! was_deserializing)\n-      setBlockDataMode (false);\n+    boolean is_consumed = false;\n+    boolean old_mode = setBlockDataMode (false);\n \n     this.isDeserializing = true;\n \n     byte marker = this.realInputStream.readByte ();\n     dumpElement (\"MARKER: 0x\" + Integer.toHexString(marker) + \" \");\n \n-    switch (marker)\n-    {\n-      case TC_BLOCKDATA:\n-      case TC_BLOCKDATALONG:\n-\tif (marker == TC_BLOCKDATALONG) \n-\t  dumpElementln (\"BLOCKDATALONG\");\n-\telse\n-\t  dumpElementln (\"BLOCKDATA\");\n-\treadNextBlock (marker);\n-\tthrow new StreamCorruptedException (\"Unexpected blockData\");\n-\n-      case TC_NULL:\n-\tdumpElementln (\"NULL\");\n-\tret_val = null;\n-\tbreak;\n-\n-      case TC_REFERENCE:\n-      {\n-\tdumpElement (\"REFERENCE \");\n-\tInteger oid = new Integer (this.realInputStream.readInt ());\n-\tdumpElementln (Integer.toHexString(oid.intValue()));\n-\tret_val = ((ObjectIdentityWrapper)\n-\t\t   this.objectLookupTable.get (oid)).object;\n-\tbreak;\n-      }\n-\n-      case TC_CLASS:\n-      {\n-\tdumpElementln (\"CLASS\");\n-\tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n-\tClass clazz = osc.forClass ();\n-\tassignNewHandle (clazz);\n-\tret_val = clazz;\n-\tbreak;\n-      }\n-\n-      case TC_CLASSDESC:\n-      {\n-\tdumpElement (\"CLASSDESC NAME=\");\n-\tString name = this.realInputStream.readUTF ();\n-\tdumpElement (name + \"; UID=\");\n-\tlong uid = this.realInputStream.readLong ();\n-\tdumpElement (Long.toHexString(uid) + \"; FLAGS=\");\n-\tbyte flags = this.realInputStream.readByte ();\n-\tdumpElement (Integer.toHexString(flags) + \"; FIELD COUNT=\");\n-\tshort field_count = this.realInputStream.readShort ();\n-\tdumpElementln (Short.toString(field_count));\n-\tObjectStreamField[] fields = new ObjectStreamField[field_count];\n-\n-\tObjectStreamClass osc = new ObjectStreamClass (name, uid,\n-\t\t\t\t\t\t       flags, fields);\n-\tassignNewHandle (osc);\n-\n-\tfor (int i=0; i < field_count; i++)\n-\t{\n-\t  dumpElement (\"  TYPE CODE=\");\n-\t  char type_code = (char)this.realInputStream.readByte ();\n-\t  dumpElement (type_code + \"; FIELD NAME=\");\n-\t  String field_name = this.realInputStream.readUTF ();\n-\t  dumpElementln (field_name);\n-\t  String class_name;\n-\n-\t  if (type_code == 'L' || type_code == '[')\n-\t    class_name = (String)readObject ();\n-\t  else\n-\t    class_name = String.valueOf (type_code);\n-\n-\t  fields[i] =\n-\t    new ObjectStreamField (field_name,\n-\t\t\t\t   TypeSignature.getClassForEncoding\n-\t\t\t\t   (class_name));\n-\t}\n-\n-\tClass cl = resolveClass (osc);\n-\tosc.setClass (cl);\n-\tsetBlockDataMode (false);\n-\n-\tif (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n-\t  throw new IOException (\"Data annotated to class was not consumed.\");\n-\tdumpElementln (\"ENDBLOCKDATA \");\n-\n-\tosc.setSuperclass ((ObjectStreamClass)readObject ());\n-\tret_val = osc;\n-\tbreak;\n-      }\n-\n-      case TC_STRING:\n-      {\n-\tdumpElement (\"STRING=\");\n-\tString s = this.realInputStream.readUTF ();\n-\tdumpElementln (s);\n-\tret_val = processResolution (s, assignNewHandle (s));\n-\tbreak;\n-      }\n-\n-      case TC_ARRAY:\n-      {\n-\tdumpElementln (\"ARRAY\");\n-\tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n-\tClass componentType = osc.forClass ().getComponentType ();\n-\tdumpElement (\"ARRAY LENGTH=\");\n-\tint length = this.realInputStream.readInt ();\n-\tdumpElementln (length + \"; COMPONENT TYPE=\" + componentType);\n-\tObject array = Array.newInstance (componentType, length);\n-\tint handle = assignNewHandle (array);\n-\treadArrayElements (array, componentType);\n-\tfor (int i=0, len=Array.getLength(array); i < len; i++)\n-\t  dumpElementln (\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n-\tret_val = processResolution (array, handle);\n-\tbreak;\n-      }\n-\n-      case TC_OBJECT:\n+    try\n       {\n-\tdumpElementln (\"OBJECT\");\n-\tObjectStreamClass osc = (ObjectStreamClass)readObject ();\n-\tClass clazz = osc.forClass ();\n-\n-\tif (!Serializable.class.isAssignableFrom (clazz))\n-\t  throw new NotSerializableException (clazz + \" is not Serializable, and thus cannot be deserialized.\");\n-\n-\tif (Externalizable.class.isAssignableFrom (clazz))\n-\t{\n-\t  Externalizable obj = null;\n-\n-\t  try\n-\t  {\n-\t    obj = (Externalizable)clazz.newInstance ();\n-\t  }\n-\t  catch (InstantiationException e)\n-\t  {\n-\t    throw new ClassNotFoundException (\"Instance of \" + clazz\n-\t\t\t\t\t      + \" could not be created\");\n-\t  }\n-\t  catch (IllegalAccessException e)\n-\t  {\n-\t    throw new ClassNotFoundException (\"Instance of \" + clazz\n-\t\t\t\t\t      + \" could not be created because class or zero-argument constructor is not accessible\");\n-\t  }\n-\t  catch (NoSuchMethodError e)\n+\tswitch (marker)\n \t  {\n-\t    throw new ClassNotFoundException (\"Instance of \" + clazz\n-\t\t\t\t\t      + \" could not be created because zero-argument constructor is not defined\");\n-\t  }\n-\n-\t  int handle = assignNewHandle (obj);\n-\n-\t  boolean read_from_blocks = ((osc.getFlags () & SC_BLOCK_DATA) != 0);\n-\n-\t  if (read_from_blocks)\n-\t    setBlockDataMode (true);\n-\n-\t  obj.readExternal (this);\n-\n-\t  if (read_from_blocks)\n-\t    setBlockDataMode (false);\n-\n-\t  ret_val = processResolution (obj, handle);\n-\t  break;\n-\t} // end if (Externalizable.class.isAssignableFrom (clazz))\n+\t  case TC_ENDBLOCKDATA:\n+\t    {\n+\t      ret_val = null;\n+\t      is_consumed = true;\n+\t      break;\n+\t    }\n+\t    \n+\t  case TC_BLOCKDATA:\n+\t  case TC_BLOCKDATALONG:\n+\t    {\n+\t      if (marker == TC_BLOCKDATALONG) \n+\t\tdumpElementln (\"BLOCKDATALONG\");\n+\t      else\n+\t\tdumpElementln (\"BLOCKDATA\");\n+\t      readNextBlock (marker);\n+\t      throw new StreamCorruptedException (\"Unexpected blockData\");\n+\t    }\n+\n+\t  case TC_NULL:\n+\t    {\n+\t      dumpElementln (\"NULL\");\n+\t      ret_val = null;\n+\t      break;\n+\t    }\n+\t    \n+\t  case TC_REFERENCE:\n+\t    {\n+\t      dumpElement (\"REFERENCE \");\n+\t      Integer oid = new Integer (this.realInputStream.readInt ());\n+\t      dumpElementln (Integer.toHexString(oid.intValue()));\n+\t      ret_val = ((ObjectIdentityWrapper)\n+\t\t\t this.objectLookupTable.get (oid)).object;\n+\t      break;\n+\t    }\n+\t    \n+\t  case TC_CLASS:\n+\t    {\n+\t      dumpElementln (\"CLASS\");\n+\t      ObjectStreamClass osc = (ObjectStreamClass)readObject ();\n+\t      Class clazz = osc.forClass ();\n+\t      assignNewHandle (clazz);\n+\t      ret_val = clazz;\n+\t      break;\n+\t    }\n+\n+\t  case TC_PROXYCLASSDESC:\n+\t    {\n+\t      dumpElementln (\"PROXYCLASS\");\n+\t      int n_intf = this.realInputStream.readInt();\n+\t      String[] intfs = new String[n_intf];\n+\t      for (int i = 0; i < n_intf; i++)\n+\t\t{\n+\t\t  intfs[i] = this.realInputStream.readUTF();\n+\t\t  System.out.println(intfs[i]);\n+\t\t}\n+\t      \n+\t      boolean oldmode = setBlockDataMode (true);\n+\t      Class cl = resolveProxyClass(intfs);\n+\t      setBlockDataMode(oldmode);\n+\t      \n+\t      ObjectStreamClass osc = ObjectStreamClass.lookup(cl);\n+\t      assignNewHandle (osc);\n+\t      \n+\t      if (!is_consumed)\n+\t\t{\n+\t\t  byte b = this.realInputStream.readByte ();\n+\t\t  if (b != TC_ENDBLOCKDATA)\n+\t\t    throw new IOException (\"Data annotated to class was not consumed.\" + b);\n+\t\t}\n+\t      else\n+\t\tis_consumed = false;\n+\t      ObjectStreamClass superosc = (ObjectStreamClass)readObject ();\n+\t      osc.setSuperclass (superosc);\n+\t      ret_val = osc;\n+\t      break;\n+\t    }\n+\n+\t  case TC_CLASSDESC:\n+\t    {\n+\t      dumpElement (\"CLASSDESC NAME=\");\n+\t      String name = this.realInputStream.readUTF ();\n+\t      dumpElement (name + \"; UID=\");\n+\t      long uid = this.realInputStream.readLong ();\n+\t      dumpElement (Long.toHexString(uid) + \"; FLAGS=\");\n+\t      byte flags = this.realInputStream.readByte ();\n+\t      dumpElement (Integer.toHexString(flags) + \"; FIELD COUNT=\");\n+\t      short field_count = this.realInputStream.readShort ();\n+\t      dumpElementln (Short.toString(field_count));\n+\t      ObjectStreamField[] fields = new ObjectStreamField[field_count];\n+\t      \n+\t      ObjectStreamClass osc = new ObjectStreamClass (name, uid,\n+\t\t\t\t\t\t\t     flags, fields);\n+\t      assignNewHandle (osc);\n+\t      \n+\t      for (int i=0; i < field_count; i++)\n+\t\t{\n+\t\t  dumpElement (\"  TYPE CODE=\");\n+\t\t  char type_code = (char)this.realInputStream.readByte ();\n+\t\t  dumpElement (type_code + \"; FIELD NAME=\");\n+\t\t  String field_name = this.realInputStream.readUTF ();\n+\t\t  dumpElementln (field_name);\n+\t\t  String class_name;\n+\t\t  \n+\t\t  if (type_code == 'L' || type_code == '[')\n+\t\t    class_name = (String)readObject ();\n+\t\t  else\n+\t\t    class_name = String.valueOf (type_code);\n+\t\t  \n+\t\t  // There're many cases you can't get java.lang.Class from\n+\t\t  // typename if your context class loader can't load it,\n+\t\t  // then use typename to construct the field\n+\t\t  fields[i] =\n+\t\t    new ObjectStreamField (field_name, class_name);\n+\t\t}\n+\t      \n+\t      boolean oldmode = setBlockDataMode (true);\n+\t      osc.setClass (resolveClass (osc));\n+\t      setBlockDataMode (oldmode);\n+\t      \n+\t      if (!is_consumed)\n+\t\t{\n+\t\t  byte b = this.realInputStream.readByte ();\n+\t\t  if (b != TC_ENDBLOCKDATA)\n+\t\t    throw new IOException (\"Data annotated to class was not consumed.\" + b);\n+\t\t}\n+\t      else\n+\t\tis_consumed = false;\n+\t      \n+\t      osc.setSuperclass ((ObjectStreamClass)readObject ());\n+\t      ret_val = osc;\n+\t      break;\n+\t    }\n+\t    \n+\t  case TC_STRING:\n+\t  case TC_LONGSTRING:\n+\t    {\n+\t      dumpElement (\"STRING=\");\n+\t      String s = this.realInputStream.readUTF ();\n+\t      dumpElementln (s);\n+\t      ret_val = processResolution (s, assignNewHandle (s));\n+\t      break;\n+\t    }\n+\n+\t  case TC_ARRAY:\n+\t    {\n+\t      dumpElementln (\"ARRAY\");\n+\t      ObjectStreamClass osc = (ObjectStreamClass)readObject ();\n+\t      Class componentType = osc.forClass ().getComponentType ();\n+\t      dumpElement (\"ARRAY LENGTH=\");\n+\t      int length = this.realInputStream.readInt ();\n+\t      dumpElementln (length + \"; COMPONENT TYPE=\" + componentType);\n+\t      Object array = Array.newInstance (componentType, length);\n+\t      int handle = assignNewHandle (array);\n+\t      readArrayElements (array, componentType);\n+\t      for (int i=0, len=Array.getLength(array); i < len; i++)\n+\t\tdumpElementln (\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n+\t      ret_val = processResolution (array, handle);\n+\t      break;\n+\t    }\n+\n+\t  case TC_OBJECT:\n+\t    {\n+\t      dumpElementln (\"OBJECT\");\n+\t      ObjectStreamClass osc = (ObjectStreamClass)readObject ();\n+\t      Class clazz = osc.forClass ();\n+\t      \n+\t      if (!Serializable.class.isAssignableFrom (clazz))\n+\t\tthrow new NotSerializableException (clazz + \" is not Serializable, and thus cannot be deserialized.\");\n+\t      \n+\t      if (Externalizable.class.isAssignableFrom (clazz))\n+\t\t{\n+\t\t  Externalizable obj = null;\n+\t\t  \n+\t\t  try\n+\t\t    {\n+\t\t      obj = (Externalizable)clazz.newInstance ();\n+\t\t    }\n+\t\t  catch (InstantiationException e)\n+\t\t    {\n+\t\t      throw new ClassNotFoundException (\"Instance of \" + clazz\n+\t\t\t\t\t\t\t+ \" could not be created\");\n+\t\t    }\n+\t\t  catch (IllegalAccessException e)\n+\t\t    {\n+\t\t      throw new ClassNotFoundException (\"Instance of \" + clazz\n+\t\t\t\t\t\t\t+ \" could not be created because class or zero-argument constructor is not accessible\");\n+\t\t    }\n+\t\t  catch (NoSuchMethodError e)\n+\t\t    {\n+\t\t      throw new ClassNotFoundException (\"Instance of \" + clazz\n+\t\t\t\t\t\t\t+ \" could not be created because zero-argument constructor is not defined\");\n+\t\t    }\n+\t\t  \n+\t\t  int handle = assignNewHandle (obj);\n+\t\t  \n+\t\t  boolean read_from_blocks = ((osc.getFlags () & SC_BLOCK_DATA) != 0);\n+\t\t  \n+\t\t  boolean oldmode = this.readDataFromBlock;\n+\t\t  if (read_from_blocks)\n+\t\t    setBlockDataMode (true);\n+\t\t  \n+\t\t  obj.readExternal (this);\n+\t\t  \n+\t\t  if (read_from_blocks)\n+\t\t    setBlockDataMode (oldmode);\n+\t\t  \n+\t\t  ret_val = processResolution (obj, handle);\n+\t\t  break;\n+\t\t} // end if (Externalizable.class.isAssignableFrom (clazz))\n+\t      \n+\t      // find the first non-serializable, non-abstract\n+\t      // class in clazz's inheritance hierarchy\n+\t      Class first_nonserial = clazz.getSuperclass ();\n+\t      while (Serializable.class.isAssignableFrom (first_nonserial)\n+\t\t     || Modifier.isAbstract (first_nonserial.getModifiers ()))\n+\t\tfirst_nonserial = first_nonserial.getSuperclass ();\n+\t      \n+\t      //\tDEBUGln (\"Using \" + first_nonserial\n+\t      //\t\t + \" as starting point for constructing \" + clazz);\n+\t      \n+\t      Object obj = null;\n+\t      obj = newObject (clazz, first_nonserial);\n+\t      \n+\t      if (obj == null)\n+\t\tthrow new ClassNotFoundException (\"Instance of \" + clazz +\n+\t\t\t\t\t\t  \" could not be created\");\n+\t      \n+\t      int handle = assignNewHandle (obj);\n+\t      this.currentObject = obj;\n+\t      ObjectStreamClass[] hierarchy =\n+\t\tObjectStreamClass.getObjectStreamClasses (clazz);\n+\t      \n+\t      //\tDEBUGln (\"Got class hierarchy of depth \" + hierarchy.length);\n+\t      \n+\t      boolean has_read;\n+\t      for (int i=0; i < hierarchy.length; i++)\n+\t\t{\n+\t\t  this.currentObjectStreamClass = hierarchy[i];\n+\t\t  \n+\t\t  dumpElementln (\"Reading fields of \"\n+\t\t\t\t + this.currentObjectStreamClass.getName ());\n+\t\t  \n+\t\t  has_read = true;\n+\t\t  \n+\t\t  try\n+\t\t    {\n+\t\t      this.currentObjectStreamClass.forClass ().\n+\t\t\tgetDeclaredMethod (\"readObject\", readObjectParams);\n+\t\t    }\n+\t\t  catch (NoSuchMethodException e)\n+\t\t    {\n+\t\t      has_read = false;\n+\t\t    }\n+\n+\t\t  // XXX: should initialize fields in classes in the hierarchy\n+\t\t  // that aren't in the stream\n+\t\t  // should skip over classes in the stream that aren't in the\n+\t\t  // real classes hierarchy\n+\t\t  readFields (obj, this.currentObjectStreamClass.fields,\n+\t\t\t      has_read, this.currentObjectStreamClass);\n+\n+\t\t  if (has_read)\n+\t\t    {\n+\t\t      dumpElement (\"ENDBLOCKDATA? \");\n+\t\t      try\n+\t\t\t{\n+\t\t\t  // FIXME: XXX: This try block is to catch EOF which is\n+\t\t\t  // thrown for some objects.  That indicates a bug in the logic.\n+\t\t\t  if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n+\t\t\t    throw new IOException (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n+\t\t\t  dumpElementln (\"yes\");\n+\t\t\t}\n+\t\t      catch (EOFException e)\n+\t\t\t{\n+\t\t\t  dumpElementln (\"no, got EOFException\");\n+\t\t\t}\n+\t\t      catch (IOException e)\n+\t\t\t{\n+\t\t\t  dumpElementln (\"no, got IOException\");\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      this.currentObject = null;\n+\t      this.currentObjectStreamClass = null;\n+\t      ret_val = processResolution (obj, handle);\n+\t      break;\n+\t    }\n+\t    \n+\t  case TC_RESET:\n+\t    dumpElementln (\"RESET\");\n+\t    clearHandles ();\n+\t    ret_val = readObject ();\n+\t    break;\n+\t    \n+\t  case TC_EXCEPTION:\n+\t    {\n+\t      dumpElement (\"EXCEPTION=\");\n+\t      Exception e = (Exception)readObject ();\n+\t      dumpElementln (e.toString());\n+\t      clearHandles ();\n+\t      throw new WriteAbortedException (\"Exception thrown during writing of stream\", e);\n+\t    }\n+\t      \n+\t  default:\n+\t    throw new IOException (\"Unknown marker on stream: \" + marker);\n \n-\t// find the first non-serializable, non-abstract\n-\t// class in clazz's inheritance hierarchy\n-\tClass first_nonserial = clazz.getSuperclass ();\n-\twhile (Serializable.class.isAssignableFrom (first_nonserial)\n-\t       || Modifier.isAbstract (first_nonserial.getModifiers ()))\n-\t  first_nonserial = first_nonserial.getSuperclass ();\n-\n-//\tDEBUGln (\"Using \" + first_nonserial\n-//\t\t + \" as starting point for constructing \" + clazz);\n-\n-\tObject obj = null;\n-\tobj = newObject (clazz, first_nonserial);\n-\n-\tif (obj == null)\n-\t  throw new ClassNotFoundException (\"Instance of \" + clazz +\n-\t\t\t\t\t    \" could not be created\");\n-\n-\tint handle = assignNewHandle (obj);\n-\tthis.currentObject = obj;\n-\tObjectStreamClass[] hierarchy =\n-\t  ObjectStreamClass.getObjectStreamClasses (clazz);\n-\n-//\tDEBUGln (\"Got class hierarchy of depth \" + hierarchy.length);\n-\n-\tboolean has_read;\n-\tfor (int i=0; i < hierarchy.length; i++)\n-\t{\n-\t  this.currentObjectStreamClass = hierarchy[i];\n-\n-\t  dumpElementln (\"Reading fields of \"\n-\t\t   + this.currentObjectStreamClass.getName ());\n-\n-\t  has_read = true;\n-\n-\t  try\n-\t  {\n-\t    this.currentObjectStreamClass.forClass ().\n-\t      getDeclaredMethod (\"readObject\", readObjectParams);\n \t  }\n-\t  catch (NoSuchMethodException e)\n-\t  {\n-\t    has_read = false;\n-\t  }\n-\n-\t  // XXX: should initialize fields in classes in the hierarchy\n-\t  // that aren't in the stream\n-\t  // should skip over classes in the stream that aren't in the\n-\t  // real classes hierarchy\n-\t  readFields (obj, this.currentObjectStreamClass.fields,\n-\t\t      has_read, this.currentObjectStreamClass);\n-\n-\t  if (has_read)\n-\t  {\n-\t    dumpElement (\"ENDBLOCKDATA? \");\n-\t    try\n-\t      {\n-\t\t// FIXME: XXX: This try block is to catch EOF which is\n-\t\t// thrown for some objects.  That indicates a bug in the logic.\n-\t        if (this.realInputStream.readByte () != TC_ENDBLOCKDATA)\n-\t\t  throw new IOException (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n-\t        dumpElementln (\"yes\");\n-\t      }\n-\t    catch (EOFException e)\n-\t      {\n-\t        dumpElementln (\"no, got EOFException\");\n-\t      }\n-\t    catch (IOException e)\n-\t      {\n-\t        dumpElementln (\"no, got IOException\");\n-\t      }\n-\t  }\n-\t}\n-\n-\tthis.currentObject = null;\n-\tthis.currentObjectStreamClass = null;\n-\tret_val = processResolution (obj, handle);\n-\tbreak;\n       }\n-\n-      case TC_RESET:\n-\tdumpElementln (\"RESET\");\n-\tclearHandles ();\n-\tret_val = readObject ();\n-\tbreak;\n-\n-      case TC_EXCEPTION:\n+    finally\n       {\n-\tdumpElement (\"EXCEPTION=\");\n-\tException e = (Exception)readObject ();\n-\tdumpElementln (e.toString());\n-\tclearHandles ();\n-\tthrow new WriteAbortedException (\"Exception thrown during writing of stream\", e);\n+\tsetBlockDataMode (old_mode);\n+\t\n+\tthis.isDeserializing = was_deserializing;\n+\t\n+\tif (! was_deserializing)\n+\t  {\n+\t    if (validators.size () > 0)\n+\t      invokeValidators ();\n+\t  }\n       }\n-\n-      default:\n-\tthrow new IOException (\"Unknown marker on stream\");\n-    }\n-\n-    this.isDeserializing = was_deserializing;\n-\n-    if (! was_deserializing)\n-    {\n-      setBlockDataMode (true);\n-\n-      if (validators.size () > 0)\n-\tinvokeValidators ();\n-    }\n-\n+    \n     return ret_val;\n   }\n-\n+\t\n \n   /**\n      Reads the current objects non-transient, non-static fields from\n@@ -439,9 +494,11 @@ public void defaultReadObject ()\n     if (fieldsAlreadyRead)\n       throw new NotActiveException (\"defaultReadObject called but fields already read from stream (by defaultReadObject or readFields)\");\n \n+    boolean oldmode = setBlockDataMode(false);\n     readFields (this.currentObject,\n \t\tthis.currentObjectStreamClass.fields,\n \t\tfalse, this.currentObjectStreamClass);\n+    setBlockDataMode(oldmode);\n \n     fieldsAlreadyRead = true;\n   }\n@@ -500,13 +557,18 @@ protected Class resolveClass (ObjectStreamClass osc)\n     throws ClassNotFoundException, IOException\n   {\n     SecurityManager sm = System.getSecurityManager ();\n+    if (sm == null)\n+      sm = new SecurityManager () {};\n \n     // FIXME: currentClassLoader doesn't yet do anything useful. We need\n     // to call forName() with the classloader of the class which called \n     // readObject(). See SecurityManager.getClassContext().\n     ClassLoader cl = currentClassLoader (sm);\n \n-    return Class.forName (osc.getName (), true, cl);\n+    if (cl == null)\n+      return Class.forName (osc.getName ());\n+    else\n+      return cl.loadClass (osc.getName ());\n   }\n \n   /**\n@@ -617,7 +679,17 @@ public int read (byte[] data, int offset, int length) throws IOException\n     if (this.readDataFromBlock)\n     {\n       if (this.blockDataPosition + length > this.blockDataBytes)\n-\treadNextBlock ();\n+\t{\n+\t  int remain = this.blockDataBytes - this.blockDataPosition;\n+\t  if (remain != 0)\n+\t    {\n+\t      System.arraycopy (this.blockData, this.blockDataPosition,\n+\t\t\t\tdata, offset, remain);\n+\t      offset += remain;\n+\t      length -= remain;\n+\t    }\n+\t  readNextBlock ();\n+\t}\n \n       System.arraycopy (this.blockData, this.blockDataPosition,\n \t\t\tdata, offset, length);\n@@ -785,11 +857,11 @@ public GetField readFields ()\n     // Apparently Block data is not used with GetField as per\n     // empirical evidence against JDK 1.2.  Also see Mauve test\n     // java.io.ObjectInputOutput.Test.GetPutField.\n-    setBlockDataMode (false);\n+    boolean oldmode = setBlockDataMode (false);\n     readFully (prim_field_data);\n     for (int i = 0; i < objs.length; ++ i)\n       objs[i] = readObject ();\n-    setBlockDataMode (true);\n+    setBlockDataMode (oldmode);\n \n     return new GetField ()\n     {\n@@ -990,7 +1062,7 @@ protected ObjectInputStream ()\n      de serialization mechanism provided by\n      <code>ObjectInputStream</code>.  To make this method be used for\n      writing objects, subclasses must invoke the 0-argument\n-     constructor on this class from there constructor.\n+     constructor on this class from their constructor.\n \n      @see ObjectInputStream ()\n   */\n@@ -1175,9 +1247,9 @@ private void readFields (Object obj, ObjectStreamField[] stream_fields,\n     {\n //    DEBUGln (\"  call_read_method is true\");\n       fieldsAlreadyRead = false;\n-      setBlockDataMode (true);\n+      boolean oldmode = setBlockDataMode (true);\n       callReadMethod (obj, stream_osc.forClass ());\n-      setBlockDataMode (false);\n+      setBlockDataMode (oldmode);\n       return;\n     }\n \n@@ -1237,101 +1309,109 @@ else if (comp_val > 0)\n \t}\n       }\n \n-      if (type == Boolean.TYPE)\n-      {\n-\tboolean value =\n-\t  default_initialize ? false : this.realInputStream.readBoolean ();\n-\tif (!default_initialize && set_value)\n-\t  dumpElementln (\"  \" + field_name + \": \" + value);\n-\tif (set_value)\n-\t  setBooleanField (obj, field_name, value);\n-      }\n-      else if (type == Byte.TYPE)\n-      {\n-\tbyte value =\n-\t  default_initialize ? 0 : this.realInputStream.readByte ();\n-\tif (!default_initialize && set_value)\n-\t  dumpElementln (\"  \" + field_name + \": \" + value);\n-\tif (set_value)\n-\t  setByteField (obj, field_name, value);\n-      }\n-      else if (type == Character.TYPE)\n-      {\n-\tchar value =\n-\t  default_initialize ? (char)0 : this.realInputStream.readChar ();\n-\tif (!default_initialize && set_value)\n-\t  dumpElementln (\"  \" + field_name + \": \" + value);\n-\tif (set_value)\n-\t  setCharField (obj, field_name, value);\n-      }\n-      else if (type == Double.TYPE)\n-      {\n-\tdouble value =\n-\t  default_initialize ? 0 : this.realInputStream.readDouble ();\n-\tif (!default_initialize && set_value)\n-\t  dumpElementln (\"  \" + field_name + \": \" + value);\n-\tif (set_value)\n-\t  setDoubleField (obj, field_name, value);\n-      }\n-      else if (type == Float.TYPE)\n-      {\n-\tfloat value =\n-\t  default_initialize ? 0 : this.realInputStream.readFloat ();\n-\tif (!default_initialize && set_value)\n-\t  dumpElementln (\"  \" + field_name + \": \" + value);\n-\tif (set_value)\n-\t  setFloatField (obj, field_name, value);\n-      }\n-      else if (type == Integer.TYPE)\n-      {\n-\tint value =\n-\t  default_initialize ? 0 : this.realInputStream.readInt ();\n-\tif (!default_initialize && set_value)\n-\t  dumpElementln (\"  \" + field_name + \": \" + value);\n-\tif (set_value)\n-\t  setIntField (obj, field_name, value);\n-      }\n-      else if (type == Long.TYPE)\n-      {\n-\tlong value =\n-\t  default_initialize ? 0 : this.realInputStream.readLong ();\n-\tif (!default_initialize && set_value)\n-\t  dumpElementln (\"  \" + field_name + \": \" + value);\n-\tif (set_value)\n-\t  setLongField (obj, field_name, value);\n-      }\n-      else if (type == Short.TYPE)\n-      {\n-\tshort value =\n-\t  default_initialize ? (short)0 : this.realInputStream.readShort ();\n-\tif (!default_initialize && set_value)\n-\t  dumpElementln (\"  \" + field_name + \": \" + value);\n-\tif (set_value)\n-\t  setShortField (obj, field_name, value);\n-      }\n-      else\n-      {\n-\tObject value =\n-\t  default_initialize ? null : readObject ();\n-\tif (set_value)\n-\t  setObjectField (obj, field_name,\n-\t\t\t  real_field.getTypeString (), value);\n-      }\n+      try\n+\t{\n+\t  if (type == Boolean.TYPE)\n+\t    {\n+\t      boolean value =\n+\t\tdefault_initialize ? false : this.realInputStream.readBoolean ();\n+\t      if (!default_initialize && set_value)\n+\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\tsetBooleanField (obj, field_name, value);\n+\t    }\n+\t  else if (type == Byte.TYPE)\n+\t    {\n+\t      byte value =\n+\t\tdefault_initialize ? 0 : this.realInputStream.readByte ();\n+\t      if (!default_initialize && set_value)\n+\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\tsetByteField (obj, field_name, value);\n+\t    }\n+\t  else if (type == Character.TYPE)\n+\t    {\n+\t      char value =\n+\t\tdefault_initialize ? (char)0 : this.realInputStream.readChar ();\n+\t      if (!default_initialize && set_value)\n+\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\tsetCharField (obj, field_name, value);\n+\t    }\n+\t  else if (type == Double.TYPE)\n+\t    {\n+\t      double value =\n+\t\tdefault_initialize ? 0 : this.realInputStream.readDouble ();\n+\t      if (!default_initialize && set_value)\n+\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\tsetDoubleField (obj, field_name, value);\n+\t    }\n+\t  else if (type == Float.TYPE)\n+\t    {\n+\t      float value =\n+\t\tdefault_initialize ? 0 : this.realInputStream.readFloat ();\n+\t      if (!default_initialize && set_value)\n+\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\tsetFloatField (obj, field_name, value);\n+\t    }\n+\t  else if (type == Integer.TYPE)\n+\t    {\n+\t      int value =\n+\t\tdefault_initialize ? 0 : this.realInputStream.readInt ();\n+\t      if (!default_initialize && set_value)\n+\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\tsetIntField (obj, field_name, value);\n+\t    }\n+\t  else if (type == Long.TYPE)\n+\t    {\n+\t      long value =\n+\t\tdefault_initialize ? 0 : this.realInputStream.readLong ();\n+\t      if (!default_initialize && set_value)\n+\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\tsetLongField (obj, field_name, value);\n+\t    }\n+\t  else if (type == Short.TYPE)\n+\t    {\n+\t      short value =\n+\t\tdefault_initialize ? (short)0 : this.realInputStream.readShort ();\n+\t      if (!default_initialize && set_value)\n+\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n+\t      if (set_value)\n+\t\tsetShortField (obj, field_name, value);\n+\t    }\n+\t  else\n+\t    {\n+\t      Object value =\n+\t\tdefault_initialize ? null : readObject ();\n+\t      if (set_value)\n+\t\tsetObjectField (obj, field_name,\n+\t\t\t\treal_field.getTypeString (), value);\n+\t    }\n+\t}\n+      catch (NoSuchFieldError e)\n+\t{\n+\t  dumpElementln(\"XXXX \" + field_name + \" does not exist.\");\n+\t}\n     }\n   }\n \n \n   // Toggles writing primitive data to block-data buffer.\n-  private void setBlockDataMode (boolean on)\n+  private boolean setBlockDataMode (boolean on)\n   {\n //    DEBUGln (\"Setting block data mode to \" + on);\n-\n+    boolean oldmode = this.readDataFromBlock;\n     this.readDataFromBlock = on;\n \n     if (on)\n       this.dataInputStream = this.blockDataInput;\n     else\n       this.dataInputStream = this.realInputStream;\n+    return oldmode;\n   }\n \n \n@@ -1380,12 +1460,18 @@ private static ClassLoader currentClassLoader (SecurityManager sm)\n     return ClassLoader.getSystemClassLoader ();\n   }\n \n-  private static native Field getField (Class klass, String name)\n-    throws java.lang.NoSuchFieldException;\n-\n-  private static native Method getMethod (Class klass, String name, Class args[])\n-    throws java.lang.NoSuchMethodException;\n-\n+  private static Field getField (Class klass, String name)\n+    throws java.lang.NoSuchFieldException\n+  {\n+    return klass.getDeclaredField(name);\n+  }\n+                                                                                \n+  private static Method getMethod (Class klass, String name, Class args[])\n+    throws java.lang.NoSuchMethodException\n+  {\n+    return klass.getDeclaredMethod(name, args);\n+  }\n+                                                                                \n   private void callReadMethod (Object obj, Class klass) throws IOException\n   {\n     try\n@@ -1593,6 +1679,14 @@ private void dumpElementln (String msg)\n     if (Configuration.DEBUG && dump)\n       System.out.println(msg);\n   }\n+\n+  static\n+    {\n+      if (Configuration.INIT_LOAD_LIBRARY)\n+\t{\n+\t  System.loadLibrary (\"javaio\");\n+\t}\n+    }\n }\n \n "}, {"sha": "d522996d7a55a3a80e21c2e4a2f32c934d40ae53", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 272, "deletions": 230, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=4480b3dcf640e952085da75f887d7392c5afc994", "patch": "@@ -1,5 +1,5 @@\n /* ObjectOutputStream.java -- Class used to write serialized objects\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -46,6 +46,7 @@\n \n import gnu.java.io.ObjectIdentityWrapper;\n import gnu.java.lang.reflect.TypeSignature;\n+import gnu.classpath.Configuration;\n \n /**\n    An <code>ObjectOutputStream</code> can be used to write objects\n@@ -167,229 +168,242 @@ <code>private void writeObject (ObjectOutputStream)</code>.\n   public final void writeObject (Object obj) throws IOException\n   {\n     if (useSubclassMethod)\n-    {\n-      writeObjectOverride (obj);\n-      return;\n-    }\n+      {\n+\twriteObjectOverride (obj);\n+\treturn;\n+      }\n \n     boolean was_serializing = isSerializing;\n-\n-    if (! was_serializing)\n-      setBlockDataMode (false);\n-\n+    boolean old_mode = setBlockDataMode (false);\n     try\n-    {\n-      isSerializing = true;\n-      boolean replaceDone = false;\n-\n-      drain ();\n-\n-      while (true)\n       {\n-\tif (obj == null)\n-\t{\n-\t  realOutput.writeByte (TC_NULL);\n-\t  break;\n-\t}\n-\n-\tInteger handle = findHandle (obj);\n-\tif (handle != null)\n-\t{\n-\t  realOutput.writeByte (TC_REFERENCE);\n-\t  realOutput.writeInt (handle.intValue ());\n-\t  break;\n-\t}\n-\n-\tif (obj instanceof Class)\n-\t{\n-\t  realOutput.writeByte (TC_CLASS);\n-\t  writeObject (ObjectStreamClass.lookup ((Class)obj));\n-\t  assignNewHandle (obj);\n-\t  break;\n-\t}\n-\n-\tif (obj instanceof ObjectStreamClass)\n-\t{\n-\t  ObjectStreamClass osc = (ObjectStreamClass)obj;\n-\t  realOutput.writeByte (TC_CLASSDESC);\n-\t  realOutput.writeUTF (osc.getName ());\n-\t  realOutput.writeLong (osc.getSerialVersionUID ());\n-\t  assignNewHandle (obj);\n-\n-\t  int flags = osc.getFlags ();\n-\n-\t  if (protocolVersion == PROTOCOL_VERSION_2\n-\t      && osc.isExternalizable ())\n-\t    flags |= SC_BLOCK_DATA;\n-\n-\t  realOutput.writeByte (flags);\n-\n-\t  ObjectStreamField[] fields = osc.fields;\n-\t  realOutput.writeShort (fields.length);\n-\n-\t  ObjectStreamField field;\n-\t  for (int i=0; i < fields.length; i++)\n-\t  {\n-\t    field = fields[i];\n-\t    realOutput.writeByte (field.getTypeCode ());\n-\t    realOutput.writeUTF (field.getName ());\n-\n-\t    if (! field.isPrimitive ())\n-\t      writeObject (field.getTypeString ());\n-\t  }\n-\n-\t  setBlockDataMode (true);\n-\t  annotateClass (osc.forClass ());\n-\t  setBlockDataMode (false);\n-\t  realOutput.writeByte (TC_ENDBLOCKDATA);\n-\n-\t  if (osc.isSerializable ())\n-\t    writeObject (osc.getSuper ());\n-\t  else\n-\t    writeObject (null);\n-\t  break;\n-\t}\n-\n-\n+\tisSerializing = true;\n+\tboolean replaceDone = false;\n \tObject replacedObject = null;\n-\n-\tif ((replacementEnabled || obj instanceof Serializable)\n-\t    && ! replaceDone)\n-\t{\n-\t  replacedObject = obj;\n-\n-\t  if (obj instanceof Serializable)\n-\t    {\n-\t      Method m = null;\n-\t      try\n+\t\n+\twhile (true)\n+\t  {\n+\t    if (obj == null)\n+\t      {\n+\t\trealOutput.writeByte (TC_NULL);\n+\t\tbreak;\n+\t      }\n+\t    \n+\t    Integer handle = findHandle (obj);\n+\t    if (handle != null)\n+\t      {\n+\t\trealOutput.writeByte (TC_REFERENCE);\n+\t\trealOutput.writeInt (handle.intValue ());\n+\t\tbreak;\n+\t      }\n+\t    \n+\t    if (obj instanceof Class)\n+\t      {\n+\t\tClass cl = (Class)obj;\n+\t\tObjectStreamClass osc = ObjectStreamClass.lookupForClassObject(cl);\n+\t\tassignNewHandle (obj);\n+\t\trealOutput.writeByte (TC_CLASS);\n+\t\tif (!osc.isProxyClass)\n+\t\t  {\n+\t\t    writeObject(osc);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    realOutput.writeByte (TC_PROXYCLASSDESC);\n+\t\t    Class[] intfs = cl.getInterfaces();\n+\t\t    realOutput.writeInt(intfs.length);\n+\t\t    for (int i = 0; i < intfs.length; i++)\n+\t\t      realOutput.writeUTF(intfs[i].getName());\n+\t\t    \n+\t\t    boolean oldmode = setBlockDataMode (true);\n+\t\t    annotateProxyClass(cl);\n+\t\t    setBlockDataMode (oldmode);\n+\t\t    realOutput.writeByte(TC_ENDBLOCKDATA);\n+\t\t    \n+\t\t    writeObject (osc.getSuper());\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    \n+\t    if (obj instanceof ObjectStreamClass)\n+\t      {\n+\t\tObjectStreamClass osc = (ObjectStreamClass)obj;\n+\t\trealOutput.writeByte (TC_CLASSDESC);\n+\t\trealOutput.writeUTF (osc.getName ());\n+\t\trealOutput.writeLong (osc.getSerialVersionUID ());\n+\t\tassignNewHandle (obj);\n+\t\t\n+\t\tint flags = osc.getFlags ();\n+\t\t\n+\t\tif (protocolVersion == PROTOCOL_VERSION_2\n+\t\t    && osc.isExternalizable ())\n+\t\t  flags |= SC_BLOCK_DATA;\n+\t\t\n+\t\trealOutput.writeByte (flags);\n+\t\t\n+\t\tObjectStreamField[] fields = osc.fields;\n+\t\trealOutput.writeShort (fields.length);\n+\t\t\n+\t\tObjectStreamField field;\n+\t\tfor (int i=0; i < fields.length; i++)\n+\t\t  {\n+\t\t    field = fields[i];\n+\t\t    realOutput.writeByte (field.getTypeCode ());\n+\t\t    realOutput.writeUTF (field.getName ());\n+\t\t    \n+\t\t    if (! field.isPrimitive ())\n+\t\t      writeObject (field.getTypeString ());\n+\t\t  }\n+\t\t\n+\t\tboolean oldmode = setBlockDataMode (true);\n+\t\tannotateClass (osc.forClass ());\n+\t\tsetBlockDataMode (oldmode);\n+\t\trealOutput.writeByte (TC_ENDBLOCKDATA);\n+\t\t\n+\t\tif (osc.isSerializable ())\n+\t\t  writeObject (osc.getSuper ());\n+\t\telse\n+\t\t  writeObject (null);\n+\t\tbreak;\n+\t      }\n+\t    \n+\t    if ((replacementEnabled || obj instanceof Serializable)\n+\t\t&& ! replaceDone)\n \t      {\n-\t        Class classArgs[] = {};\n-\t\tm = obj.getClass ().getDeclaredMethod (\"writeReplace\",\n-\t\t\t\t\t\t       classArgs);\n-\t\t// m can't be null by definition since an exception would\n-\t\t// have been thrown so a check for null is not needed.\n-\t\tobj = m.invoke (obj, new Object[] {});\n+\t\treplacedObject = obj;\n+\t\t\n+\t\tif (obj instanceof Serializable)\n+\t\t  {\n+\t\t    Method m = null;\n+\t\t    try\n+\t\t      {\n+\t\t\tClass classArgs[] = {};\n+\t\t\tm = obj.getClass ().getDeclaredMethod (\"writeReplace\",\n+\t\t\t\t\t\t\t       classArgs);\n+\t\t\t// m can't be null by definition since an exception would\n+\t\t\t// have been thrown so a check for null is not needed.\n+\t\t\tobj = m.invoke (obj, new Object[] {});\n+\t\t      }\n+\t\t    catch (NoSuchMethodException ignore)\n+\t\t      {\n+\t\t      }\n+\t\t    catch (IllegalAccessException ignore)\n+\t\t      {\n+\t\t      }\n+\t\t    catch (InvocationTargetException ignore)\n+\t\t      {\n+\t\t      }\n+\t\t  }\n+\t\t\n+\t\tif (replacementEnabled)\n+\t\t  obj = replaceObject (obj);\n+\t\t\n+\t\treplaceDone = true;\n+\t\tcontinue;\n \t      }\n-\t      catch (NoSuchMethodException ignore)\n+\t    \n+\t    if (obj instanceof String)\n \t      {\n+\t\trealOutput.writeByte (TC_STRING);\n+\t\tassignNewHandle (obj);\n+\t\trealOutput.writeUTF ((String)obj);\n+\t\tbreak;\n \t      }\n-\t      catch (IllegalAccessException ignore)\n+\t    \n+\t    Class clazz = obj.getClass ();\n+\t    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (clazz);\n+\t    if (osc == null)\n+\t      throw new NotSerializableException (clazz.getName ());\n+\t    \n+\t    if (clazz.isArray ())\n \t      {\n+\t\trealOutput.writeByte (TC_ARRAY);\n+\t\twriteObject (osc);\n+\t\tassignNewHandle (obj);\n+\t\twriteArraySizeAndElements (obj, clazz.getComponentType ());\n+\t\tbreak;\n \t      }\n-\t      catch (InvocationTargetException ignore)\n+\t    \n+\t    realOutput.writeByte (TC_OBJECT);\n+\t    writeObject (osc);\n+\t    \n+\t    if (replaceDone)\n+\t      assignNewHandle (replacedObject);\n+\t    else\n+\t      assignNewHandle (obj);\n+\t    \n+\t    if (obj instanceof Externalizable)\n \t      {\n+\t\tif (protocolVersion == PROTOCOL_VERSION_2)\n+\t\t  setBlockDataMode (true);\n+\t\t\n+\t\t((Externalizable)obj).writeExternal (this);\n+\t\t\n+\t\tif (protocolVersion == PROTOCOL_VERSION_2)\n+\t\t  {\n+\t\t    setBlockDataMode (false);\n+\t\t    realOutput.writeByte (TC_ENDBLOCKDATA);\n+\t\t  }\n+\t\t\n+\t\tbreak;\n \t      }\n-\t    }\n-\n-\t  if (replacementEnabled)\n-\t    obj = replaceObject (obj);\n-\n-\t  replaceDone = true;\n-\t  continue;\n-\t}\n-\n-\tif (obj instanceof String)\n-\t{\n-\t  realOutput.writeByte (TC_STRING);\n-\t  assignNewHandle (obj);\n-\t  realOutput.writeUTF ((String)obj);\n-\t  break;\n-\t}\n-\n-\tClass clazz = obj.getClass ();\n-\tObjectStreamClass osc = ObjectStreamClass.lookup (clazz);\n-\tif (osc == null)\n-\t  throw new NotSerializableException (clazz.getName ());\n-\n-\tif (clazz.isArray ())\n-\t{\n-\t  realOutput.writeByte (TC_ARRAY);\n-\t  writeObject (osc);\n-\t  assignNewHandle (obj);\n-\t  writeArraySizeAndElements (obj, clazz.getComponentType ());\n-\t  break;\n-\t}\n-\n-\trealOutput.writeByte (TC_OBJECT);\n-\twriteObject (osc);\n-\n-\tif (replaceDone)\n-\t  assignNewHandle (replacedObject);\n-\telse\n-\t  assignNewHandle (obj);\n-\n-\tif (obj instanceof Externalizable)\n-\t{\n-\t  if (protocolVersion == PROTOCOL_VERSION_2)\n-\t    setBlockDataMode (true);\n-\n-\t  ((Externalizable)obj).writeExternal (this);\n-\n-\t  if (protocolVersion == PROTOCOL_VERSION_2)\n+\t    \n+\t    if (obj instanceof Serializable)\n+\t      {\n+\t\tcurrentObject = obj;\n+\t\tObjectStreamClass[] hierarchy =\n+\t\t  ObjectStreamClass.getObjectStreamClasses (clazz);\n+\t\t\n+\t\tboolean has_write;\n+\t\tfor (int i=0; i < hierarchy.length; i++)\n+\t\t  {\n+\t\t    currentObjectStreamClass = hierarchy[i];\n+\t\t    \n+\t\t    fieldsAlreadyWritten = false;\n+\t\t    has_write = currentObjectStreamClass.hasWriteMethod ();\n+\t\t    \n+\t\t    writeFields (obj, currentObjectStreamClass.fields,\n+\t\t\t\t has_write);\n+\t\t    \n+\t\t  }\n+\t\t\n+\t\tcurrentObject = null;\n+\t\tcurrentObjectStreamClass = null;\n+\t\tcurrentPutField = null;\n+\t\tbreak;\n+\t      }\n+\t    \n+\t    throw new NotSerializableException (clazz.getName ());\n+\t  } // end pseudo-loop\n+      }\n+    catch (ObjectStreamException ose)\n+      {\n+\t// Rethrow these are fatal.\n+\tthrow ose;\n+      }\n+    catch (IOException e)\n+      {\n+\trealOutput.writeByte (TC_EXCEPTION);\n+\treset (true);\n+\n+\tsetBlockDataMode (false);\n+\ttry\n \t  {\n-\t    setBlockDataMode (false);\n-\t    drain ();\n+\t    writeObject (e);\n \t  }\n-\n-\t  break;\n-\t}\n-\n-\tif (obj instanceof Serializable)\n-\t{\n-\t  currentObject = obj;\n-\t  ObjectStreamClass[] hierarchy =\n-\t    ObjectStreamClass.getObjectStreamClasses (clazz);\n-\n-\t  boolean has_write;\n-\t  for (int i=0; i < hierarchy.length; i++)\n+\tcatch (IOException ioe)\n \t  {\n-\t    currentObjectStreamClass = hierarchy[i];\n-\n-\t    fieldsAlreadyWritten = false;\n-\t    has_write = currentObjectStreamClass.hasWriteMethod ();\n-\n-\t    writeFields (obj, currentObjectStreamClass.fields,\n-\t\t\t has_write);\n-\n-\t    if (has_write)\n-\t    {\n-\t      drain ();\n-\t      realOutput.writeByte (TC_ENDBLOCKDATA);\n-\t    }\n+\t    throw new StreamCorruptedException (\"Exception \" + ioe + \" thrown while exception was being written to stream.\");\n \t  }\n-\n-\t  currentObject = null;\n-\t  currentObjectStreamClass = null;\n-\t  currentPutField = null;\n-\t  break;\n-\t}\n-\n-\tthrow new NotSerializableException (clazz.getName ());\n-      } // end pseudo-loop\n-    }\n-    catch (IOException e)\n-    {\n-      realOutput.writeByte (TC_EXCEPTION);\n-      reset (true);\n-\n-      try\n-      {\n-\twriteObject (e);\n+\t\n+\treset (true);\n       }\n-      catch (IOException ioe)\n-      {\n-\tthrow new StreamCorruptedException (\"Exception \" + ioe + \" thrown while exception was being written to stream.\");\n-      }\n-\n-      reset (true);\n-    }\n     finally\n-    {\n-      isSerializing = was_serializing;\n+      {\n+\tisSerializing = was_serializing;\n \n-      if (! was_serializing)\n-\tsetBlockDataMode (true);\n-    }\n+\tsetBlockDataMode (old_mode);\n+      }\n   }\n \n \n@@ -466,8 +480,8 @@ private void reset (boolean internal) throws IOException\n      according to the specified protocol.  There are currently two\n      different protocols, specified by <code>PROTOCOL_VERSION_1</code>\n      and <code>PROTOCOL_VERSION_2</code>.  This implementation writes\n-     data using <code>PROTOCOL_VERSION_1</code> by default, as is done\n-     by the JDK 1.1.\n+     data using <code>PROTOCOL_VERSION_2</code> by default, as is done\n+     by the JDK 1.2.\n \n      A non-portable method, <code>setDefaultProtocolVersion (int\n      version)</code> is provided to change the default protocol\n@@ -528,6 +542,8 @@ information about the class has been written.\n   protected void annotateClass (Class cl) throws IOException\n   {}\n \n+  protected void annotateProxyClass(Class cl) throws IOException\n+  {}\n \n   /**\n      Allows subclasses to replace objects that are written to the\n@@ -702,7 +718,8 @@ protected void drain () throws IOException\n     if (blockDataCount == 0)\n       return;\n \n-    writeBlockDataHeader (blockDataCount);\n+    if (writeDataAsBlocks)\n+      writeBlockDataHeader (blockDataCount);\n     realOutput.write (blockData, 0, blockDataCount);\n     blockDataCount = 0;\n   }\n@@ -713,7 +730,7 @@ protected void drain () throws IOException\n   */\n   public void close () throws IOException\n   {\n-    drain ();\n+    flush ();\n     realOutput.close ();\n   }\n \n@@ -723,7 +740,7 @@ public void close () throws IOException\n   */\n   public void writeBoolean (boolean data) throws IOException\n   {\n-    dataOutput.writeBoolean (data);\n+    blockDataOutput.writeBoolean (data);\n   }\n \n \n@@ -732,7 +749,7 @@ public void writeBoolean (boolean data) throws IOException\n   */\n   public void writeByte (int data) throws IOException\n   {\n-    dataOutput.writeByte (data);\n+    blockDataOutput.writeByte (data);\n   }\n \n \n@@ -741,7 +758,7 @@ public void writeByte (int data) throws IOException\n   */\n   public void writeShort (int data) throws IOException\n   {\n-    dataOutput.writeShort (data);\n+    blockDataOutput.writeShort (data);\n   }\n \n \n@@ -750,7 +767,7 @@ public void writeShort (int data) throws IOException\n   */\n   public void writeChar (int data) throws IOException\n   {\n-    dataOutput.writeChar (data);\n+    blockDataOutput.writeChar (data);\n   }\n \n \n@@ -759,7 +776,7 @@ public void writeChar (int data) throws IOException\n   */\n   public void writeInt (int data) throws IOException\n   {\n-    dataOutput.writeInt (data);\n+    blockDataOutput.writeInt (data);\n   }\n \n \n@@ -768,7 +785,7 @@ public void writeInt (int data) throws IOException\n   */\n   public void writeLong (long data) throws IOException\n   {\n-    dataOutput.writeLong (data);\n+    blockDataOutput.writeLong (data);\n   }\n \n \n@@ -777,7 +794,7 @@ public void writeLong (long data) throws IOException\n   */\n   public void writeFloat (float data) throws IOException\n   {\n-    dataOutput.writeFloat (data);\n+    blockDataOutput.writeFloat (data);\n   }\n \n \n@@ -786,7 +803,7 @@ public void writeFloat (float data) throws IOException\n   */\n   public void writeDouble (double data) throws IOException\n   {\n-    dataOutput.writeDouble (data);\n+    blockDataOutput.writeDouble (data);\n   }\n \n \n@@ -795,7 +812,7 @@ public void writeDouble (double data) throws IOException\n   */\n   public void writeBytes (String data) throws IOException\n   {\n-    dataOutput.writeBytes (data);\n+    blockDataOutput.writeBytes (data);\n   }\n \n \n@@ -965,6 +982,8 @@ public void put (String name, Object value)\n \t  {\n \t    ObjectStreamField field\n \t      = currentObjectStreamClass.getField (name);\n+\t    if (field == null)\n+\t      throw new IllegalArgumentException ();\n \t    if (value != null &&\n \t    \t! field.getType ().isAssignableFrom (value.getClass ()))\n \t      throw new IllegalArgumentException ();\n@@ -976,11 +995,11 @@ public void write (ObjectOutput out) throws IOException\n \t    // Apparently Block data is not used with PutField as per\n \t    // empirical evidence against JDK 1.2.  Also see Mauve test\n \t    // java.io.ObjectInputOutput.Test.GetPutField.\n-\t    setBlockDataMode (false);\n+\t    boolean oldmode = setBlockDataMode (false);\n \t    out.write (prim_field_data);\n \t    for (int i = 0; i < objs.length; ++ i)\n \t      out.writeObject (objs[i]);\n-\t    setBlockDataMode (true);\n+\t    setBlockDataMode (oldmode);\n \t  }\n \n \tprivate void checkType (ObjectStreamField field, char type)\n@@ -1067,8 +1086,7 @@ private void writeArraySizeAndElements (Object array, Class clazz)\n       {\n \tbyte[] cast_array = (byte[])array;\n \trealOutput.writeInt (length);\n-\tfor (int i=0; i < length; i++)\n-\t  realOutput.writeByte (cast_array[i]);\n+\trealOutput.write(cast_array, 0, length);\n \treturn;\n       }\n       if (clazz == Character.TYPE)\n@@ -1142,9 +1160,11 @@ private void writeFields (Object obj,\n       setBlockDataMode (true);\n       callWriteMethod (obj);\n       setBlockDataMode (false);\n+      realOutput.writeByte (TC_ENDBLOCKDATA);\n       return;\n     }\n \n+    boolean oldmode = setBlockDataMode (false);\n     String field_name;\n     Class type;\n     for (int i=0; i < fields.length; i++)\n@@ -1170,20 +1190,28 @@ else if (type == Short.TYPE)\n \trealOutput.writeShort (getShortField (obj, field_name));\n       else\n \twriteObject (getObjectField (obj, field_name,\n-\t\t\t\t     TypeSignature.getEncodingOfClass (type)));\n+\t\t\t\t     fields[i].getTypeString ()));\n     }\n+    setBlockDataMode(oldmode);\n   }\n \n \n   // Toggles writing primitive data to block-data buffer.\n-  private void setBlockDataMode (boolean on)\n+  private boolean setBlockDataMode (boolean on) throws IOException\n   {\n+    if (on == writeDataAsBlocks)\n+      return on;\n+\n+    drain();\n+    boolean oldmode = writeDataAsBlocks;\n     writeDataAsBlocks = on;\n \n     if (on)\n       dataOutput = blockDataOutput;\n     else\n       dataOutput = realOutput;\n+\n+    return oldmode;\n   }\n \n \n@@ -1355,16 +1383,22 @@ private Object getObjectField (Object obj, String field_name,\n       }    \n   }\n \n-  private static native Field getField (Class klass, String name)\n-    throws java.lang.NoSuchFieldException;\n-\n-  private static native Method getMethod (Class klass, String name, Class[] args)\n-    throws java.lang.NoSuchMethodException;\n-\n+  private static Field getField (Class klass, String name)\n+    throws java.lang.NoSuchFieldException\n+  {\n+    return klass.getDeclaredField(name);\n+  }\n+                                                                                \n+  private static Method getMethod (Class klass, String name, Class[] args)\n+    throws java.lang.NoSuchMethodException\n+  {\n+    return klass.getDeclaredMethod(name, args);\n+  }\n+                                                                                \n   // this value comes from 1.2 spec, but is used in 1.1 as well\n   private final static int BUFFER_SIZE = 1024;\n \n-  private static int defaultProtocolVersion = PROTOCOL_VERSION_1;\n+  private static int defaultProtocolVersion = PROTOCOL_VERSION_2;\n \n   private DataOutputStream dataOutput;\n   private boolean writeDataAsBlocks;\n@@ -1382,4 +1416,12 @@ private static native Method getMethod (Class klass, String name, Class[] args)\n   private Hashtable OIDLookupTable;\n   private int protocolVersion;\n   private boolean useSubclassMethod;\n+\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary (\"javaio\");\n+      }\n+  }\n }"}, {"sha": "bb78a786c1f9b8f4fb27f3113b307599bfd153d3", "filename": "libjava/java/io/ObjectStreamField.java", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fjava%2Fio%2FObjectStreamField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fjava%2Fio%2FObjectStreamField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamField.java?ref=4480b3dcf640e952085da75f887d7392c5afc994", "patch": "@@ -47,8 +47,23 @@ public ObjectStreamField (String name, Class type)\n   {\n     this.name = name;\n     this.type = type;\n+    this.typename = TypeSignature.getEncodingOfClass(type);\n   }\n-\n+ \n+  /**\n+   * There're many cases you can't get java.lang.Class from typename if your context\n+   * class loader can't load it, then use typename to construct the field\n+   */\n+  ObjectStreamField (String name, String typename){\n+    this.name = name;\n+    this.typename = typename;\n+    try{\n+      type = TypeSignature.getClassForEncoding(typename);\n+    }catch(ClassNotFoundException e){\n+      type = Object.class; //??\n+    }\n+  }\n+  \n   public String getName ()\n   {\n     return name;\n@@ -61,12 +76,13 @@ public Class getType ()\n \n   public char getTypeCode ()\n   {\n-    return TypeSignature.getEncodingOfClass (type).charAt (0);\n+    return typename.charAt (0);\n   }\n \n   public String getTypeString ()\n   {\n-    return TypeSignature.getEncodingOfClass (type);\n+    // use intern()\n+    return typename.intern();\n   }\n \n   public int getOffset ()\n@@ -106,5 +122,6 @@ public String toString ()\n \n   private String name;\n   private Class type;\n+  private String typename;\n   private int offset = -1; // XXX make sure this is correct\n }"}, {"sha": "8b84e7e319973b2dc3bdae09da97da999b2990cf", "filename": "libjava/java/io/natObjectInputStream.cc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc?ref=4480b3dcf640e952085da75f887d7392c5afc994", "patch": "@@ -69,16 +69,3 @@ java::io::ObjectInputStream::callConstructor (jclass klass, jobject obj)\n \t\t\t\t+ m->offset);\n   _Jv_CallAnyMethodA (obj, JvPrimClass (void), meth, false, arg_types, NULL);\n }\n-  \n-java::lang::reflect::Field *\n-java::io::ObjectInputStream::getField (jclass klass, jstring name)\n-{\n-  return klass->getPrivateField (name);\n-}\n-\n-java::lang::reflect::Method *\n-java::io::ObjectInputStream::getMethod (jclass klass, jstring name, \n-\t\t\t\t\tJArray<jclass> *arg_types)\n-{\n-  return klass->getPrivateMethod (name, arg_types);\n-}"}, {"sha": "45ab7537fc35c5798f08f71a26c975ac8f1a3152", "filename": "libjava/java/io/natObjectOutputStream.cc", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28727f1fb365c5cc0d02394dd06d57a57eb0fa76/libjava%2Fjava%2Fio%2FnatObjectOutputStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28727f1fb365c5cc0d02394dd06d57a57eb0fa76/libjava%2Fjava%2Fio%2FnatObjectOutputStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatObjectOutputStream.cc?ref=28727f1fb365c5cc0d02394dd06d57a57eb0fa76", "patch": "@@ -1,33 +0,0 @@\n-// natObjectOutputStream.cc - Native part of ObjectOutputStream class.\n-\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n-\n-   This ObjectOutputStream is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the ObjectOutputStream \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/io/ObjectOutputStream$PutField.h>\n-#include <java/io/ObjectOutputStream.h>\n-#include <java/io/IOException.h>\n-#include <java/lang/Class.h>\n-\n-\n-java::lang::reflect::Field *\n-java::io::ObjectOutputStream::getField (jclass klass, jstring name)\n-{\n-  return klass->getPrivateField (name);\n-}\n-\n-java::lang::reflect::Method *\n-java::io::ObjectOutputStream::getMethod (jclass klass, jstring name, \n-\t\t\t\t\t JArray<jclass> *arg_types)\n-{\n-  return klass->getPrivateMethod (name, arg_types);\n-}\n-"}, {"sha": "a2ccd5f9785b5dd91afc947ec147a04cb2ba9e15", "filename": "libjava/mauve-libgcj", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fmauve-libgcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4480b3dcf640e952085da75f887d7392c5afc994/libjava%2Fmauve-libgcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fmauve-libgcj?ref=4480b3dcf640e952085da75f887d7392c5afc994", "patch": "@@ -15,7 +15,6 @@ JDBC2.0\n \n # The following tests seem to hang or crash the testsuite.\n # This a problem when running Mauve \"standalone\".\n-!java.io.ObjectInputOutput\n !java.lang.reflect.Array.newInstance\n \n # Character.unicode seems to be very broken (the test)"}]}