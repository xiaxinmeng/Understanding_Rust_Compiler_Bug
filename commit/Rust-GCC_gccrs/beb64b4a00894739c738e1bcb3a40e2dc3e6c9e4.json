{"sha": "beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmViNjRiNGEwMDg5NDczOWM3MzhlMWJjYjNhNDBlMmRjM2U2YzllNA==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2009-04-05T18:02:00Z"}, "committer": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2009-04-05T18:02:00Z"}, "message": "re PR fortran/29458 (Spurious -Wuninitialized warning for implied do-loop counter)\n\ngcc/fortran/:\n2009-04-05  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/29458\n        * trans-array.c (gfc_trans_array_constructor_value): Shadow implied\n        do-loop variable to avoid spurious middle-end warnings.\n\n\ngcc/testsuite/:\n2009-04-05  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/29458\n        * gfortran.dg/implied_do_1.f90: New.\n\nFrom-SVN: r145564", "tree": {"sha": "af274a78e5b936a0f10510d0954668036829f374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af274a78e5b936a0f10510d0954668036829f374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2fcf6ffb76998fd44284bc6d77503966ac36e30c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fcf6ffb76998fd44284bc6d77503966ac36e30c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fcf6ffb76998fd44284bc6d77503966ac36e30c"}], "stats": {"total": 100, "additions": 62, "deletions": 38}, "files": [{"sha": "0d9a935c9a95ae6094cbbe26561a3f4bdf467e89", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4", "patch": "@@ -1,3 +1,9 @@\n+2009-04-05  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/29458\n+\t* trans-array.c (gfc_trans_array_constructor_value): Shadow\n+\timplied do-loop variable to avoid spurious middle-end warnings.\n+\n 2009-04-04  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/39577"}, {"sha": "bc045dbd356195df1596a2b64e7f06416d737870", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4", "patch": "@@ -1183,13 +1183,30 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n   gfc_se se;\n   mpz_t size;\n \n+  tree shadow_loopvar = NULL_TREE;\n+  gfc_saved_var saved_loopvar;\n+\n   mpz_init (size);\n   for (; c; c = c->next)\n     {\n       /* If this is an iterator or an array, the offset must be a variable.  */\n       if ((c->iterator || c->expr->rank > 0) && INTEGER_CST_P (*poffset))\n \tgfc_put_offset_into_var (pblock, poffset, offsetvar);\n \n+      /* Shadowing the iterator avoids changing its value and saves us from\n+\t keeping track of it. Further, it makes sure that there's always a\n+\t backend-decl for the symbol, even if there wasn't one before,\n+\t e.g. in the case of an iterator that appears in a specification\n+\t expression in an interface mapping.  */\n+      if (c->iterator)\n+\t{\n+\t  gfc_symbol *sym = c->iterator->var->symtree->n.sym;\n+\t  tree type = gfc_typenode_for_spec (&sym->ts);\n+\n+\t  shadow_loopvar = gfc_create_var (type, \"shadow_loopvar\");\n+\t  gfc_shadow_sym (sym, shadow_loopvar, &saved_loopvar);\n+\t}\n+\n       gfc_start_block (&body);\n \n       if (c->expr->expr_type == EXPR_ARRAY)\n@@ -1312,69 +1329,51 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n       else\n \t{\n \t  /* Build the implied do-loop.  */\n+\t  stmtblock_t implied_do_block;\n \t  tree cond;\n \t  tree end;\n \t  tree step;\n-\t  tree loopvar;\n \t  tree exit_label;\n \t  tree loopbody;\n \t  tree tmp2;\n-\t  tree tmp_loopvar;\n \n \t  loopbody = gfc_finish_block (&body);\n \n-\t  if (c->iterator->var->symtree->n.sym->backend_decl)\n-\t    {\n-\t      gfc_init_se (&se, NULL);\n-\t      gfc_conv_expr (&se, c->iterator->var);\n-\t      gfc_add_block_to_block (pblock, &se.pre);\n-\t      loopvar = se.expr;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If the iterator appears in a specification expression in\n-\t\t an interface mapping, we need to make a temp for the loop\n-\t\t variable because it is not declared locally.  */\n-\t      loopvar = gfc_typenode_for_spec (&c->iterator->var->ts);\n-\t      loopvar = gfc_create_var (loopvar, \"loopvar\");\n-\t    }\n-\n-\t  /* Make a temporary, store the current value in that\n-\t     and return it, once the loop is done.  */\n-\t  tmp_loopvar = gfc_create_var (TREE_TYPE (loopvar), \"loopvar\");\n-\t  gfc_add_modify (pblock, tmp_loopvar, loopvar);\n+\t  /* Create a new block that holds the implied-do loop. A temporary\n+\t     loop-variable is used.  */\n+\t  gfc_start_block(&implied_do_block);\n \n \t  /* Initialize the loop.  */\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr_val (&se, c->iterator->start);\n-\t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  gfc_add_modify (pblock, loopvar, se.expr);\n+\t  gfc_add_block_to_block (&implied_do_block, &se.pre);\n+\t  gfc_add_modify (&implied_do_block, shadow_loopvar, se.expr);\n \n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr_val (&se, c->iterator->end);\n-\t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  end = gfc_evaluate_now (se.expr, pblock);\n+\t  gfc_add_block_to_block (&implied_do_block, &se.pre);\n+\t  end = gfc_evaluate_now (se.expr, &implied_do_block);\n \n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr_val (&se, c->iterator->step);\n-\t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  step = gfc_evaluate_now (se.expr, pblock);\n+\t  gfc_add_block_to_block (&implied_do_block, &se.pre);\n+\t  step = gfc_evaluate_now (se.expr, &implied_do_block);\n \n \t  /* If this array expands dynamically, and the number of iterations\n \t     is not constant, we won't have allocated space for the static\n \t     part of C->EXPR's size.  Do that now.  */\n \t  if (dynamic && gfc_iterator_has_dynamic_bounds (c->iterator))\n \t    {\n \t      /* Get the number of iterations.  */\n-\t      tmp = gfc_get_iteration_count (loopvar, end, step);\n+\t      tmp = gfc_get_iteration_count (shadow_loopvar, end, step);\n \n \t      /* Get the static part of C->EXPR's size.  */\n \t      gfc_get_array_constructor_element_size (&size, c->expr);\n \t      tmp2 = gfc_conv_mpz_to_tree (size, gfc_index_integer_kind);\n \n \t      /* Grow the array by TMP * TMP2 elements.  */\n \t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, tmp2);\n-\t      gfc_grow_array (pblock, desc, tmp);\n+\t      gfc_grow_array (&implied_do_block, desc, tmp);\n \t    }\n \n \t  /* Generate the loop body.  */\n@@ -1388,9 +1387,9 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t     build_int_cst (TREE_TYPE (step), 0));\n \t  cond = fold_build3 (COND_EXPR, boolean_type_node, tmp,\n \t\t\t      fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\t   loopvar, end),\n+\t\t\t\t\t   shadow_loopvar, end),\n \t\t\t      fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\t   loopvar, end));\n+\t\t\t\t\t   shadow_loopvar, end));\n \t  tmp = build1_v (GOTO_EXPR, exit_label);\n \t  TREE_USED (exit_label) = 1;\n \t  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n@@ -1400,20 +1399,23 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_add_expr_to_block (&body, loopbody);\n \n \t  /* Increase loop variable by step.  */\n-\t  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (loopvar), loopvar, step);\n-\t  gfc_add_modify (&body, loopvar, tmp);\n+\t  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (shadow_loopvar), shadow_loopvar, step);\n+\t  gfc_add_modify (&body, shadow_loopvar, tmp);\n \n \t  /* Finish the loop.  */\n \t  tmp = gfc_finish_block (&body);\n \t  tmp = build1_v (LOOP_EXPR, tmp);\n-\t  gfc_add_expr_to_block (pblock, tmp);\n+\t  gfc_add_expr_to_block (&implied_do_block, tmp);\n \n \t  /* Add the exit label.  */\n \t  tmp = build1_v (LABEL_EXPR, exit_label);\n-\t  gfc_add_expr_to_block (pblock, tmp);\n+\t  gfc_add_expr_to_block (&implied_do_block, tmp);\n+\n+\t  /* Finishe the implied-do loop.  */\n+\t  tmp = gfc_finish_block(&implied_do_block);\n+\t  gfc_add_expr_to_block(pblock, tmp);\n \n-\t  /* Restore the original value of the loop counter.  */\n-\t  gfc_add_modify (pblock, loopvar, tmp_loopvar);\n+\t  gfc_restore_sym (c->iterator->var->symtree->n.sym, &saved_loopvar);\n \t}\n     }\n   mpz_clear (size);"}, {"sha": "6d0a9d13aff1b3debd867e123d1cf2923ed8f0b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4", "patch": "@@ -1,3 +1,8 @@\n+2009-04-05  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/29458\n+\t* gfortran.dg/implied_do_1.f90: New.\n+\n 2009-04-04  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/39577"}, {"sha": "7f1266c5dc2255a318bfb6bbfd01413c17607d86", "filename": "gcc/testsuite/gfortran.dg/implied_do_1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_1.f90?ref=beb64b4a00894739c738e1bcb3a40e2dc3e6c9e4", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do \"run\" }\n+! PR fortran/29458 - spurious warning for implied do-loop counter\n+\n+  integer :: n, i\n+  i = 10\n+  n = 5\n+  n = SUM((/(i,i=1,n)/))\n+\n+  ! 'i' must not be changed\n+  IF (i /= 10) CALL abort()\n+END"}]}