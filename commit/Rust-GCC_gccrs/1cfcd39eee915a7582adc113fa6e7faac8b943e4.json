{"sha": "1cfcd39eee915a7582adc113fa6e7faac8b943e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNmY2QzOWVlZTkxNWE3NTgyYWRjMTEzZmE2ZTdmYWFjOGI5NDNlNA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-05-03T09:04:46Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-05-03T09:04:46Z"}, "message": "re PR tree-optimization/56541 (vectorizaton fails in conditional assignment of a constant)\n\n\tPR tree-optimization/56541\n\t* doc/invoke.texi (@item max-tree-if-conversion-phi-args): New item.\n\t* params.def (PARAM_MAX_TREE_IF_CONVERSION_PHI_ARGS): new param.\n\t* tree-if-conv.c (MAX_PHI_ARG_NUM): new macro.\n\t(any_complicated_phi): new static variable.\n\t(aggressive_if_conv): delete.\n\t(if_convertible_phi_p): support phis with more than two arguments.\n\t(if_convertible_bb_p): remvoe check on aggressive_if_conv and\n\tcritical pred edges.\n\t(ifcvt_split_critical_edges): support phis with more than two\n\targuments by checking new parameter.  only split critical edges\n\tif needed.\n\t(tree_if_conversion): handle simd pragma marked loop using new\n\tlocal variable aggressive_if_conv.  check any_complicated_phi.\n\n\tgcc/testsuite\n\tPR tree-optimization/56541\n\t* gcc.dg/tree-ssa/ifc-pr56541.c: new test.\n\t* gcc.dg/vect/pr56541.c: new test.\n\nFrom-SVN: r235808", "tree": {"sha": "5411de44c126dfd942b7250b8f84f5f31dbfa368", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5411de44c126dfd942b7250b8f84f5f31dbfa368"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cfcd39eee915a7582adc113fa6e7faac8b943e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cfcd39eee915a7582adc113fa6e7faac8b943e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cfcd39eee915a7582adc113fa6e7faac8b943e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cfcd39eee915a7582adc113fa6e7faac8b943e4/comments", "author": null, "committer": null, "parents": [{"sha": "15526589cf190bc111e1ef27f713e2d46c449172", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15526589cf190bc111e1ef27f713e2d46c449172", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15526589cf190bc111e1ef27f713e2d46c449172"}], "stats": {"total": 216, "additions": 155, "deletions": 61}, "files": [{"sha": "ffe45b718a5bc1fca6cb3683c07f12d7f1f08116", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cfcd39eee915a7582adc113fa6e7faac8b943e4", "patch": "@@ -1,3 +1,20 @@\n+2016-05-03  bin cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/56541\n+\t* doc/invoke.texi (@item max-tree-if-conversion-phi-args): New item.\n+\t* params.def (PARAM_MAX_TREE_IF_CONVERSION_PHI_ARGS): new param.\n+\t* tree-if-conv.c (MAX_PHI_ARG_NUM): new macro.\n+\t(any_complicated_phi): new static variable.\n+\t(aggressive_if_conv): delete.\n+\t(if_convertible_phi_p): support phis with more than two arguments.\n+\t(if_convertible_bb_p): remvoe check on aggressive_if_conv and\n+\tcritical pred edges.\n+\t(ifcvt_split_critical_edges): support phis with more than two\n+\targuments by checking new parameter.  only split critical edges\n+\tif needed.\n+\t(tree_if_conversion): handle simd pragma marked loop using new\n+\tlocal variable aggressive_if_conv.  check any_complicated_phi.\n+\n 2016-05-03  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (get_computation_cost_at): Check depends_on"}, {"sha": "f5413faf11615ae982aee1bea50720b62be37ecb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1cfcd39eee915a7582adc113fa6e7faac8b943e4", "patch": "@@ -9020,6 +9020,10 @@ Large expressions slow the analyzer.\n Bound on the complexity of the expressions in the scalar evolutions analyzer.\n Complex expressions slow the analyzer.\n \n+@item max-tree-if-conversion-phi-args\n+Maximum number of arguments in a PHI supported by TREE if conversion\n+unless the loop is marked with simd pragma.\n+\n @item vect-max-version-for-alignment-checks\n The maximum number of run-time checks that can be performed when\n doing loop versioning for alignment in the vectorizer."}, {"sha": "62a1e404a1aac763ae1187b98027d073bcd6f712", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=1cfcd39eee915a7582adc113fa6e7faac8b943e4", "patch": "@@ -530,6 +530,12 @@ DEFPARAM(PARAM_SCEV_MAX_EXPR_COMPLEXITY,\n \t \"Bound on the complexity of the expressions in the scalar evolutions analyzer.\",\n \t 10, 0, 0)\n \n+DEFPARAM (PARAM_MAX_TREE_IF_CONVERSION_PHI_ARGS,\n+\t  \"max-tree-if-conversion-phi-args\",\n+\t  \"Maximum number of arguments in a PHI supported by TREE if-conversion \"\n+\t  \"unless the loop is marked with simd pragma.\",\n+\t  4, 2, 0)\n+\n DEFPARAM(PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS,\n          \"vect-max-version-for-alignment-checks\",\n          \"Bound on number of runtime checks inserted by the vectorizer's loop versioning for alignment check.\","}, {"sha": "6ce2c7e916c30fefddc4351a37b9d0ce49538e55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1cfcd39eee915a7582adc113fa6e7faac8b943e4", "patch": "@@ -1,3 +1,9 @@\n+2016-05-03  bin cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/56541\n+\t* gcc.dg/tree-ssa/ifc-pr56541.c: new test.\n+\t* gcc.dg/vect/pr56541.c: new test.\n+\n 2016-05-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/float128-complex-1.c: New tests for complex"}, {"sha": "a52bacacedfa81f555da7932c03137279b45372c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-pr56541.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr56541.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr56541.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr56541.c?ref=1cfcd39eee915a7582adc113fa6e7faac8b943e4", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-ifcvt-stats\" } */\n+\n+float a,b,c,d;\n+\n+float z[1024]; int ok[1024];\n+const float rBig = 150.;\n+\n+void foo()\n+{\n+  int i;\n+\n+  for (i=0; i!=1024; ++i)\n+    {\n+      float rR = a*z[i];\n+      float rL = b*z[i];\n+      float rMin = (rR<rL) ? rR : rL;\n+      float rMax = (rR<rL) ? rL : rR;\n+      rMin = (rMax>0) ? rMin : rBig;\n+      rMin = (rMin>0) ? rMin : rMax;\n+      ok[i] = rMin-c<rMax+d;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */"}, {"sha": "16b8d7cb75bc6126530d116bf63030bd8c344ea0", "filename": "gcc/testsuite/gcc.dg/vect/pr56541.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr56541.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr56541.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr56541.c?ref=1cfcd39eee915a7582adc113fa6e7faac8b943e4", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_float } */\n+/* { dg-require-effective-target vect_condition } */\n+\n+float a,b,c,d;\n+\n+float z[1024]; int ok[1024];\n+const float rBig = 150.;\n+\n+void foo()\n+{\n+  int i;\n+\n+  for (i=0; i!=1024; ++i)\n+    {\n+      float rR = a*z[i];\n+      float rL = b*z[i];\n+      float rMin = (rR<rL) ? rR : rL;\n+      float rMax = (rR<rL) ? rL : rR;\n+      rMin = (rMax>0) ? rMin : rBig;\n+      rMin = (rMin>0) ? rMin : rMax;\n+      ok[i] = rMin-c<rMax+d;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "97b62b7a79e94883b319f12a946729ac55f6f840", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 70, "deletions": 61, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfcd39eee915a7582adc113fa6e7faac8b943e4/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=1cfcd39eee915a7582adc113fa6e7faac8b943e4", "patch": "@@ -113,11 +113,22 @@ along with GCC; see the file COPYING3.  If not see\n #include \"varasm.h\"\n #include \"builtins.h\"\n #include \"params.h\"\n- \n+\n+/* Only handle PHIs with no more arguments unless we are asked to by\n+   simd pragma.  */\n+#define MAX_PHI_ARG_NUM \\\n+  ((unsigned) PARAM_VALUE (PARAM_MAX_TREE_IF_CONVERSION_PHI_ARGS))\n+\n /* Indicate if new load/store that needs to be predicated is introduced\n    during if conversion.  */\n static bool any_pred_load_store;\n \n+/* Indicate if there are any complicated PHIs that need to be handled in\n+   if-conversion.  Complicated PHI has more than two arguments and can't\n+   be degenerated to two arguments PHI.  See more information in comment\n+   before phi_convertible_by_degenerating_args.  */\n+static bool any_complicated_phi;\n+\n /* Hash for struct innermost_loop_behavior.  It depends on the user to\n    free the memory.  */\n \n@@ -172,9 +183,6 @@ innermost_loop_behavior_hash::equal (const value_type &e1,\n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n \n-/* Apply more aggressive (extended) if-conversion if true.  */\n-static bool aggressive_if_conv;\n-\n /* Hash table to store <DR's innermost loop behavior, DR> pairs.  */\n static hash_map<innermost_loop_behavior_hash,\n \t\tdata_reference_p> *innermost_DR_map;\n@@ -639,13 +647,9 @@ phi_convertible_by_degenerating_args (gphi *phi)\n }\n \n /* Return true when PHI is if-convertible.  PHI is part of loop LOOP\n-   and it belongs to basic block BB.\n-\n-   PHI is not if-convertible if:\n-   - it has more than 2 arguments.\n-\n-   When the aggressive_if_conv is set, PHI can have more than\n-   two arguments.  */\n+   and it belongs to basic block BB.  Note at this point, it is sure\n+   that PHI is if-convertible.  This function updates global variable\n+   ANY_COMPLICATED_PHI if PHI is complicated.  */\n \n static bool\n if_convertible_phi_p (struct loop *loop, basic_block bb, gphi *phi)\n@@ -656,17 +660,10 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gphi *phi)\n       print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n     }\n \n-  if (bb != loop->header)\n-    {\n-      if (gimple_phi_num_args (phi) > 2\n-\t  && !aggressive_if_conv\n-\t  && !phi_convertible_by_degenerating_args (phi))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Phi can't be predicated by single cond.\\n\");\n-\t  return false;\n-        }\n-    }\n+  if (bb != loop->header\n+      && gimple_phi_num_args (phi) > 2\n+      && !phi_convertible_by_degenerating_args (phi))\n+    any_complicated_phi = true;\n \n   return true;\n }\n@@ -1012,8 +1009,6 @@ has_pred_critical_p (basic_block bb)\n    - it is after the exit block but before the latch,\n    - its edges are not normal.\n \n-   Last restriction is valid if aggressive_if_conv is false.\n-\n    EXIT_BB is the basic block containing the exit of the LOOP.  BB is\n    inside LOOP.  */\n \n@@ -1062,19 +1057,6 @@ if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n \treturn false;\n       }\n \n-  /* At least one incoming edge has to be non-critical as otherwise edge\n-     predicates are not equal to basic-block predicates of the edge\n-     source.  This check is skipped if aggressive_if_conv is true.  */\n-  if (!aggressive_if_conv\n-      && EDGE_COUNT (bb->preds) > 1\n-      && bb != loop->header\n-      && all_preds_critical_p (bb))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"only critical predecessors\\n\");\n-      return false;\n-    }\n-\n   return true;\n }\n \n@@ -2380,11 +2362,16 @@ version_loop_for_if_conversion (struct loop *loop)\n   return true;\n }\n \n-/* Performs splitting of critical edges if aggressive_if_conv is true.\n-   Returns false if loop won't be if converted and true otherwise.  */\n+/* Performs splitting of critical edges.  Skip splitting and return false\n+   if LOOP will not be converted because:\n+\n+     - LOOP is not well formed.\n+     - LOOP has PHI with more than MAX_PHI_ARG_NUM arguments.\n+\n+   Last restriction is valid only if AGGRESSIVE_IF_CONV is false.  */\n \n static bool\n-ifcvt_split_critical_edges (struct loop *loop)\n+ifcvt_split_critical_edges (struct loop *loop, bool aggressive_if_conv)\n {\n   basic_block *body;\n   basic_block bb;\n@@ -2393,30 +2380,51 @@ ifcvt_split_critical_edges (struct loop *loop)\n   gimple *stmt;\n   edge e;\n   edge_iterator ei;\n+  vec<edge> critical_edges = vNULL;\n \n-  if (num <= 2)\n-    return false;\n-  if (loop->inner)\n-    return false;\n-  if (!single_exit (loop))\n+  /* Loop is not well formed.  */\n+  if (num <= 2 || loop->inner || !single_exit (loop))\n     return false;\n \n   body = get_loop_body (loop);\n   for (i = 0; i < num; i++)\n     {\n       bb = body[i];\n-      if (bb == loop->latch\n-\t  || bb_with_exit_edge_p (loop, bb))\n+      if (!aggressive_if_conv\n+\t  && phi_nodes (bb)\n+\t  && EDGE_COUNT (bb->preds) > MAX_PHI_ARG_NUM)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"BB %d has complicated PHI with more than %u args.\\n\",\n+\t\t     bb->index, MAX_PHI_ARG_NUM);\n+\n+\t  free (body);\n+\t  critical_edges.release ();\n+\t  return false;\n+\t}\n+      if (bb == loop->latch || bb_with_exit_edge_p (loop, bb))\n \tcontinue;\n+\n       stmt = last_stmt (bb);\n       /* Skip basic blocks not ending with conditional branch.  */\n-      if (!(stmt && gimple_code (stmt) == GIMPLE_COND))\n+      if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n \tcontinue;\n+\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (EDGE_CRITICAL_P (e) && e->dest->loop_father == loop)\n-\t  split_edge (e);\n+\t  critical_edges.safe_push (e);\n     }\n   free (body);\n+\n+  while (critical_edges.length () > 0)\n+    {\n+      e = critical_edges.pop ();\n+      /* Don't split if bb can be predicated along non-critical edge.  */\n+      if (EDGE_COUNT (e->dest->preds) > 2 || all_preds_critical_p (e->dest))\n+\tsplit_edge (e);\n+    }\n+\n   return true;\n }\n \n@@ -2713,33 +2721,37 @@ static unsigned int\n tree_if_conversion (struct loop *loop)\n {\n   unsigned int todo = 0;\n+  bool aggressive_if_conv;\n+\n   ifc_bbs = NULL;\n   any_pred_load_store = false;\n+  any_complicated_phi = false;\n \n-  /* Set up aggressive if-conversion for loops marked with simd pragma.  */\n+  /* Apply more aggressive if-conversion when loop or its outer loop were\n+     marked with simd pragma.  When that's the case, we try to if-convert\n+     loop containing PHIs with more than MAX_PHI_ARG_NUM arguments.  */\n   aggressive_if_conv = loop->force_vectorize;\n-  /* Check either outer loop was marked with simd pragma.  */\n   if (!aggressive_if_conv)\n     {\n       struct loop *outer_loop = loop_outer (loop);\n       if (outer_loop && outer_loop->force_vectorize)\n \taggressive_if_conv = true;\n     }\n \n-  if (aggressive_if_conv)\n-    if (!ifcvt_split_critical_edges (loop))\n-      goto cleanup;\n+  if (!ifcvt_split_critical_edges (loop, aggressive_if_conv))\n+    goto cleanup;\n \n   if (!if_convertible_loop_p (loop)\n       || !dbg_cnt (if_conversion_tree))\n     goto cleanup;\n \n-  if (any_pred_load_store\n+  if ((any_pred_load_store || any_complicated_phi)\n       && ((!flag_tree_loop_vectorize && !loop->force_vectorize)\n \t  || loop->dont_vectorize))\n     goto cleanup;\n \n-  if (any_pred_load_store && !version_loop_for_if_conversion (loop))\n+  if ((any_pred_load_store || any_complicated_phi)\n+      && !version_loop_for_if_conversion (loop))\n     goto cleanup;\n \n   /* Now all statements are if-convertible.  Combine all the basic\n@@ -2749,11 +2761,8 @@ tree_if_conversion (struct loop *loop)\n \n   /* Delete dead predicate computations and repair tree correspondent\n      to bool pattern to delete multiple uses of predicates.  */\n-  if (aggressive_if_conv)\n-    {\n-      ifcvt_local_dce (loop->header);\n-      ifcvt_repair_bool_pattern (loop->header);\n-    }\n+  ifcvt_local_dce (loop->header);\n+  ifcvt_repair_bool_pattern (loop->header);\n \n   todo |= TODO_cleanup_cfg;\n   mark_virtual_operands_for_renaming (cfun);"}]}