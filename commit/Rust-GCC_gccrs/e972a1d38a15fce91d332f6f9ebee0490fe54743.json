{"sha": "e972a1d38a15fce91d332f6f9ebee0490fe54743", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk3MmExZDM4YTE1ZmNlOTFkMzMyZjZmOWViZWUwNDkwZmU1NDc0Mw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-05-05T10:43:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-05-05T10:43:36Z"}, "message": "re PR debug/43478 (Missing DW_AT_location for a variable)\n\n\tPR debug/43478\n\t* df-problems.c (struct dead_debug_use, struct dead_debug): New.\n\t(dead_debug_init, dead_debug_finish): New functions.\n\t(dead_debug_add, dead_debug_insert_before): Likewise.\n\t(df_note_bb_compute): Initialize a dead_debug object, add dead\n\tdebug uses to it, insert debug bind insns before death insns,\n\treset debug insns that refer to pending uses at the end.\n\t* rtl.h (make_debug_expr_from_rtl): New prototype.\n\t* varasm.c (make_debug_expr_from_rtl): New function.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r159063", "tree": {"sha": "59842b6dc18621e5312a68fbb0c8fbf681aa0180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59842b6dc18621e5312a68fbb0c8fbf681aa0180"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e972a1d38a15fce91d332f6f9ebee0490fe54743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e972a1d38a15fce91d332f6f9ebee0490fe54743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e972a1d38a15fce91d332f6f9ebee0490fe54743", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e972a1d38a15fce91d332f6f9ebee0490fe54743/comments", "author": null, "committer": null, "parents": [{"sha": "2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f41ecf538cfb7f3355dc1844345d9d78e0ca56a"}], "stats": {"total": 184, "additions": 183, "deletions": 1}, "files": [{"sha": "89487f7aa524b9a48e7613b54362ab2b91b0eb9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e972a1d38a15fce91d332f6f9ebee0490fe54743/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e972a1d38a15fce91d332f6f9ebee0490fe54743/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e972a1d38a15fce91d332f6f9ebee0490fe54743", "patch": "@@ -1,3 +1,16 @@\n+2010-05-05  Alexandre Oliva  <aoliva@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/43478\n+\t* df-problems.c (struct dead_debug_use, struct dead_debug): New.\n+\t(dead_debug_init, dead_debug_finish): New functions.\n+\t(dead_debug_add, dead_debug_insert_before): Likewise.\n+\t(df_note_bb_compute): Initialize a dead_debug object, add dead\n+\tdebug uses to it, insert debug bind insns before death insns,\n+\treset debug insns that refer to pending uses at the end.\n+\t* rtl.h (make_debug_expr_from_rtl): New prototype.\n+\t* varasm.c (make_debug_expr_from_rtl): New function.\n+\n 2010-05-05  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-cgraph.c (output_varpool): Forward declare; work on encoder."}, {"sha": "5f908da07ef32d7a2ba2546b10ebdea9c25bd599", "filename": "gcc/df-problems.c", "status": "modified", "additions": 141, "deletions": 1, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e972a1d38a15fce91d332f6f9ebee0490fe54743/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e972a1d38a15fce91d332f6f9ebee0490fe54743/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=e972a1d38a15fce91d332f6f9ebee0490fe54743", "patch": "@@ -3403,6 +3403,138 @@ df_create_unused_note (rtx insn, rtx old, df_ref def,\n   return old;\n }\n \n+/* Node of a linked list of uses of dead REGs in debug insns.  */\n+struct dead_debug_use\n+{\n+  df_ref use;\n+  struct dead_debug_use *next;\n+};\n+\n+/* Linked list of the above, with a bitmap of the REGs in the\n+   list.  */\n+struct dead_debug\n+{\n+  struct dead_debug_use *head;\n+  bitmap used;\n+};\n+\n+/* Initialize DEBUG to an empty list, and clear USED, if given.  */\n+static inline void\n+dead_debug_init (struct dead_debug *debug, bitmap used)\n+{\n+  debug->head = NULL;\n+  debug->used = used;\n+  if (used)\n+    bitmap_clear (used);\n+}\n+\n+/* Reset all debug insns with pending uses.  Release the bitmap in it,\n+   unless it is USED.  USED must be the same bitmap passed to\n+   dead_debug_init.  */\n+static inline void\n+dead_debug_finish (struct dead_debug *debug, bitmap used)\n+{\n+  struct dead_debug_use *head;\n+  rtx insn = NULL;\n+\n+  if (debug->used != used)\n+    BITMAP_FREE (debug->used);\n+\n+  while ((head = debug->head))\n+    {\n+      insn = DF_REF_INSN (head->use);\n+      if (!head->next || DF_REF_INSN (head->next->use) != insn)\n+\t{\n+\t  INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n+\t  df_insn_rescan_debug_internal (insn);\n+\t}\n+      debug->head = head->next;\n+      XDELETE (head);\n+    }\n+}\n+\n+/* Add USE to DEBUG.  It must be a dead reference to UREGNO in a debug\n+   insn.  Create a bitmap for DEBUG as needed.  */\n+static inline void\n+dead_debug_add (struct dead_debug *debug, df_ref use, unsigned int uregno)\n+{\n+  struct dead_debug_use *newddu = XNEW (struct dead_debug_use);\n+\n+  newddu->use = use;\n+  newddu->next = debug->head;\n+  debug->head = newddu;\n+\n+  if (!debug->used)\n+    debug->used = BITMAP_ALLOC (NULL);\n+\n+  bitmap_set_bit (debug->used, uregno);\n+}\n+\n+/* If UREGNO is referenced by any entry in DEBUG, emit a debug insn\n+   before INSN that binds the REG to a debug temp, and replace all\n+   uses of UREGNO in DEBUG with uses of the debug temp.  INSN must be\n+   the insn where UREGNO dies.  */\n+static inline void\n+dead_debug_insert_before (struct dead_debug *debug, unsigned int uregno,\n+\t\t\t  rtx insn)\n+{\n+  struct dead_debug_use **tailp = &debug->head;\n+  struct dead_debug_use *cur;\n+  struct dead_debug_use *uses = NULL;\n+  struct dead_debug_use **usesp = &uses;\n+  rtx reg = NULL;\n+  rtx dval;\n+  rtx bind;\n+\n+  if (!debug->used || !bitmap_clear_bit (debug->used, uregno))\n+    return;\n+\n+  /* Move all uses of uregno from debug->head to uses, setting mode to\n+     the widest referenced mode.  */\n+  while ((cur = *tailp))\n+    {\n+      if (DF_REF_REGNO (cur->use) == uregno)\n+\t{\n+\t  *usesp = cur;\n+\t  usesp = &cur->next;\n+\t  *tailp = cur->next;\n+\t  cur->next = NULL;\n+\t  if (!reg\n+\t      || (GET_MODE_BITSIZE (GET_MODE (reg))\n+\t\t  < GET_MODE_BITSIZE (GET_MODE (DF_REF_REAL_REG (cur->use)))))\n+\t    reg = DF_REF_REAL_REG (cur->use);\n+\t}\n+      else\n+\ttailp = &(*tailp)->next;\n+    }\n+\n+  gcc_assert (reg);\n+\n+  /* Create DEBUG_EXPR (and DEBUG_EXPR_DECL).  */\n+  dval = make_debug_expr_from_rtl (reg);\n+\n+  /* Emit a debug bind insn before the insn in which reg dies.  */\n+  bind = gen_rtx_VAR_LOCATION (GET_MODE (reg),\n+\t\t\t       DEBUG_EXPR_TREE_DECL (dval), reg,\n+\t\t\t       VAR_INIT_STATUS_INITIALIZED);\n+\n+  bind = emit_debug_insn_before (bind, insn);\n+  df_insn_rescan (bind);\n+\n+  /* Adjust all uses.  */\n+  while ((cur = uses))\n+    {\n+      if (GET_MODE (DF_REF_REAL_REG (cur->use)) == GET_MODE (reg))\n+\t*DF_REF_REAL_LOC (cur->use) = dval;\n+      else\n+\t*DF_REF_REAL_LOC (cur->use)\n+\t  = gen_lowpart_SUBREG (GET_MODE (DF_REF_REAL_REG (cur->use)), dval);\n+      /* ??? Should we simplify subreg of subreg?  */\n+      df_insn_rescan (DF_REF_INSN (cur->use));\n+      uses = cur->next;\n+      XDELETE (cur);\n+    }\n+}\n \n /* Recompute the REG_DEAD and REG_UNUSED notes and compute register\n    info: lifetime, bb, and number of defs and uses for basic block\n@@ -3416,6 +3548,9 @@ df_note_bb_compute (unsigned int bb_index,\n   rtx insn;\n   df_ref *def_rec;\n   df_ref *use_rec;\n+  struct dead_debug debug;\n+\n+  dead_debug_init (&debug, NULL);\n \n   bitmap_copy (live, df_get_live_out (bb));\n   bitmap_clear (artificial_uses);\n@@ -3592,9 +3727,12 @@ df_note_bb_compute (unsigned int bb_index,\n \t    {\n \t      if (debug_insn)\n \t\t{\n-\t\t  debug_insn = -1;\n+\t\t  if (debug_insn > 0)\n+\t\t    dead_debug_add (&debug, use, uregno);\n \t\t  break;\n \t\t}\n+\t      else\n+\t\tdead_debug_insert_before (&debug, uregno, insn);\n \n \t      if ( (!(DF_REF_FLAGS (use) & DF_REF_MW_HARDREG))\n \t\t   && (!bitmap_bit_p (do_not_gen, uregno))\n@@ -3636,6 +3774,8 @@ df_note_bb_compute (unsigned int bb_index,\n \t  df_insn_rescan_debug_internal (insn);\n \t}\n     }\n+\n+  dead_debug_finish (&debug, NULL);\n }\n \n "}, {"sha": "88c0abf6204fafbd6abeb5025d03d9dcaa9203bf", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e972a1d38a15fce91d332f6f9ebee0490fe54743/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e972a1d38a15fce91d332f6f9ebee0490fe54743/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e972a1d38a15fce91d332f6f9ebee0490fe54743", "patch": "@@ -2382,6 +2382,8 @@ extern rtx emit_library_call_value (rtx, rtx, enum libcall_type,\n extern void init_varasm_once (void);\n extern enum tls_model decl_default_tls_model (const_tree);\n \n+extern rtx make_debug_expr_from_rtl (const_rtx);\n+\n /* In rtl.c */\n extern void traverse_md_constants (int (*) (void **, void *), void *);\n struct md_constant { char *name, *value; };"}, {"sha": "9f2f0a6f95730fbbc9807f64a36ebdae11858131", "filename": "gcc/varasm.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e972a1d38a15fce91d332f6f9ebee0490fe54743/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e972a1d38a15fce91d332f6f9ebee0490fe54743/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e972a1d38a15fce91d332f6f9ebee0490fe54743", "patch": "@@ -7261,4 +7261,31 @@ default_elf_asm_output_external (FILE *file ATTRIBUTE_UNUSED,\n     maybe_assemble_visibility (decl);\n }\n \n+/* Create a DEBUG_EXPR_DECL / DEBUG_EXPR pair from RTL expression\n+   EXP.  */\n+rtx\n+make_debug_expr_from_rtl (const_rtx exp)\n+{\n+  tree ddecl = make_node (DEBUG_EXPR_DECL), type;\n+  enum machine_mode mode = GET_MODE (exp);\n+  rtx dval;\n+\n+  DECL_ARTIFICIAL (ddecl) = 1;\n+  if (REG_P (exp) && REG_EXPR (exp))\n+    type = TREE_TYPE (REG_EXPR (exp));\n+  else if (MEM_P (exp) && MEM_EXPR (exp))\n+    type = TREE_TYPE (MEM_EXPR (exp));\n+  else\n+    type = NULL_TREE;\n+  if (type && TYPE_MODE (type) == mode)\n+    TREE_TYPE (ddecl) = type;\n+  else\n+    TREE_TYPE (ddecl) = lang_hooks.types.type_for_mode (mode, 1);\n+  DECL_MODE (ddecl) = mode;\n+  dval = gen_rtx_DEBUG_EXPR (mode);\n+  DEBUG_EXPR_TREE_DECL (dval) = ddecl;\n+  SET_DECL_RTL (ddecl, dval);\n+  return dval;\n+}\n+\n #include \"gt-varasm.h\""}]}