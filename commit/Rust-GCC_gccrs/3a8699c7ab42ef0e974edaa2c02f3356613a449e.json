{"sha": "3a8699c7ab42ef0e974edaa2c02f3356613a449e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E4Njk5YzdhYjQyZWYwZTk3NGVkYWEyYzAyZjMzNTY2MTNhNDQ5ZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2003-01-24T15:45:53Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2003-01-24T15:45:53Z"}, "message": "Add sh2e support:\n\n    2002-08-12  Alexandre Oliva  <aoliva@redhat.com>\n\n        * config/sh/sh.c (output_branch) [TARGET_SH2E]: Handle\n        med_cbranches.  Fix logic in short_cbranches.\n\n    2002-04-03  Alexandre Oliva  <aoliva@redhat.com>\n\n        * config/sh/sh.md (delay for cbranch): Don't annul delay\n        slots on SH2e.\n        * config/sh/sh.c (sh_insn_length_adjustment): Add 2 for\n        cbranch with unfilled delay slot on SH2e.\n        (output_branch): Fill with a nop the delay slot of a\n        branch that required a delay slot but didn't get one.\n\n    2002-04-02  Alexandre Oliva  <aoliva@redhat.com>\n\n        * doc/invoke.texi (SH options): Document -m2e.\n        * config/sh/crt1.asm: Add __SH2E__ Next to __SH3E__.\n        * config/sh/lib1funcs.asm: Likewise.\n        * config/sh/sh.c: Replace all uses of TARGET_SH3E with SH2E.\n        * config/sh/sh.h (CPP_SPEC): Define __SH2E__ for -m2e, and\n        not __sh1__.\n        (CONDITIONAL_REGISTER_USAGE): Don't disable FP regs from\n        SH2E up.\n        (SH3E_BIT): Renamed to...\n        (SH_E_BIT): ... this.  Replace all uses.\n        (TARGET_SH2E): Define from SH_E_BIT and TARGET_SH2.\n        Replace all uses of TARGET_SH3E with TARGET_SH2E.\n        (TARGET_SWITCHES): Added 2e.\n        (OVERRIDE_OPTIONS): Set sh_cpu for SH2E.\n        (processor_type): Added PROCESSOR_SH2E.\n        * config/sh/sh.md: Replace all uses of TARGET_SH3E with\n        TARGET_SH2E, except in sqrtsf2_i.\n        (attribute cpu): Added sh2e.\n        * config/sh/t-sh (MULTILIB_OPTIONS): Replace m3e with m2e.\n        (MULTILIB_MATCHES): Use m2e multilib for m3e.\n        * config.gcc: Add sh2e target support.\n\nFrom-SVN: r61697", "tree": {"sha": "917842f3380f9081f8a94f8d4b8cf5c00fb26222", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/917842f3380f9081f8a94f8d4b8cf5c00fb26222"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a8699c7ab42ef0e974edaa2c02f3356613a449e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8699c7ab42ef0e974edaa2c02f3356613a449e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a8699c7ab42ef0e974edaa2c02f3356613a449e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8699c7ab42ef0e974edaa2c02f3356613a449e/comments", "author": null, "committer": null, "parents": [{"sha": "65ca2d606c1420d9a4f76f22c5f07823119fe543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ca2d606c1420d9a4f76f22c5f07823119fe543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65ca2d606c1420d9a4f76f22c5f07823119fe543"}], "stats": {"total": 320, "additions": 193, "deletions": 127}, "files": [{"sha": "dd06d690c2873d14fee2b9730de8db77e9529fbf", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -2207,6 +2207,7 @@ sh-*-elf* | sh[2346l]*-*-elf*)\n \tsh4*)  target_cpu_default=\"SELECT_SH4\" ;;\n \tsh3e*) target_cpu_default=\"SELECT_SH3E\" ;;\n \tsh3*)  target_cpu_default=\"SELECT_SH3\" ;;\n+\tsh2e*) target_cpu_default=\"SELECT_SH2E\" ;;\n \tsh2*)  target_cpu_default=\"SELECT_SH2\" ;;\n \tesac\n \tcase $machine in\n@@ -2251,6 +2252,9 @@ sh-*-linux* | sh[2346lbe]*-*-linux*)\n \tsh3e[lb]*) target_cpu_default=\"SELECT_SH3\" ;;\n \tsh3e*) target_cpu_default=\"SELECT_SH3E\" ;;\n \tsh3*) target_cpu_default=\"SELECT_SH3\" ;;\n+\tsh2e[lb]e*) target_cpu_default=\"SELECT_SH2E\" ;;\n+\tsh2e[lb]*) target_cpu_default=\"SELECT_SH2\" ;;\n+\tsh2e*) target_cpu_default=\"SELECT_SH2E\" ;;\n \tsh2*) target_cpu_default=\"SELECT_SH2\" ;;\n \tesac\n \tcase $machine in\n@@ -2273,7 +2277,7 @@ sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \\\n \tcase $machine in\n \tsh5*-*)\n \t\t# SHmedia, 32-bit ABI\n-\t\ttarget_cpu_default=\"SH5_BIT|SH4_BIT|SH3E_BIT\"\n+\t\ttarget_cpu_default=\"SH5_BIT|SH4_BIT|SH3_BIT|SH_E_BIT\"\n \t\ttmake_file=\"${tmake_file} sh/t-sh64 sh/t-netbsd-sh5\"\n \t\t;;\n \tsh64*-*)"}, {"sha": "155e8318cfe5901276841da28e9f4bdd01309888", "filename": "gcc/config/sh/crt1.asm", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fcrt1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fcrt1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fcrt1.asm?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+/* Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n    This file was pretty much copied from newlib.\n \n This file is part of GNU CC.\n@@ -116,12 +116,12 @@ start_l:\n \tcmp/ge\tr0,r1\n \tbt\tstart_l\n \n-#if defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n+#if defined (__SH2E__) || defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n \tmov.l set_fpscr_k, r1\n \tjsr @r1\n \tmov #0,r4\n \tlds r3,fpscr\n-#endif /*  defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) */\n+#endif /*  defined (__SH2E__) || defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) */\n \n \t! arrange for exit to call fini\n \tmov.l\tatexit_k,r0\n@@ -146,10 +146,11 @@ start_l:\n \tnop\n \n \t.align 2\n-#if defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n+#if defined (__SH2E__) || defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n set_fpscr_k:\n \t.long\t___set_fpscr\n-#endif /*  defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) */\n+#endif /*  defined (__SH2E__) || defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) */\n+\n stack_k:\n \t.long\t_stack\t\n edata_k:"}, {"sha": "d9e6512ce6d1e9b62fe38f44f4b4e6411283cf69", "filename": "gcc/config/sh/lib1funcs.asm", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flib1funcs.asm?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002\n+/* Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n This file is free software; you can redistribute it and/or modify it\n@@ -1044,7 +1044,7 @@ GLOBAL(sdivsi3_i4):\n \n #ifdef L_sdivsi3\n /* __SH4_SINGLE_ONLY__ keeps this part for link compatibility with\n-   sh3e code.  */\n+   sh2e/sh3e code.  */\n #if (! defined(__SH4__) && ! defined (__SH4_SINGLE__)) || defined (__linux__)\n !!\n !! Steve Chamberlain\n@@ -1433,7 +1433,7 @@ L1:\n \n #ifdef L_udivsi3\n /* __SH4_SINGLE_ONLY__ keeps this part for link compatibility with\n-   sh3e code.  */\n+   sh2e/sh3e code.  */\n #if (! defined(__SH4__) && ! defined (__SH4_SINGLE__)) || defined (__linux__)\n \n !! args in r4 and r5, result in r0, clobbers r4, pr, and t bit\n@@ -1928,7 +1928,7 @@ GLOBAL(moddi3):\n #endif /* L_moddi3 */\n \n #ifdef L_set_fpscr\n-#if defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || __SH5__ == 32\n+#if defined (__SH2E__) || defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || __SH5__ == 32\n #ifdef __SH5__\n \t.mode\tSHcompact\n #endif\n@@ -1945,7 +1945,7 @@ GLOBAL(set_fpscr):\n #if defined(__SH4__)\n \tswap.w r0,r3\n \tmov.l r3,@(4,r1)\n-#else /* defined(__SH3E__) || defined(__SH4_SINGLE*__) */\n+#else /* defined (__SH2E__) || defined(__SH3E__) || defined(__SH4_SINGLE*__) */\n \tswap.w r0,r2\n \tmov.l r2,@r1\n #endif\n@@ -1958,7 +1958,7 @@ GLOBAL(set_fpscr):\n \tswap.w r0,r2\n \trts\n \tmov.l r2,@r1\n-#else /* defined(__SH3E__) || defined(__SH4_SINGLE*__) */\n+#else /* defined(__SH2E__) || defined(__SH3E__) || defined(__SH4_SINGLE*__) */\n \tswap.w r0,r3\n \trts\n \tmov.l r3,@(4,r1)\n@@ -1975,7 +1975,7 @@ LOCAL(set_fpscr_L1):\n         .comm   GLOBAL(fpscr_values),8\n #endif /* ELF */\n #endif /* NO_FPSCR_VALUES */\n-#endif /* SH3E / SH4 */\n+#endif /* SH2E / SH3E / SH4 */\n #endif /* L_set_fpscr */\n #ifdef L_ic_invalidate\n #if __SH5__ == 32"}, {"sha": "dbebd24fd6f9dbe223222e24e0d3107abe818c14", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 62, "deletions": 19, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for Hitachi / SuperH SH.\n-   Copyright (C) 1993, 1994, 1995, 1997, 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1993, 1994, 1995, 1997, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com). \n@@ -794,7 +794,7 @@ prepare_scc_operands (code)\n        && (sh_compare_op1 != const0_rtx\n \t   || code == GTU  || code == GEU || code == LTU || code == LEU))\n       || (mode == DImode && sh_compare_op1 != const0_rtx)\n-      || (TARGET_SH3E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n+      || (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n     sh_compare_op1 = force_reg (mode, sh_compare_op1);\n \n   if (TARGET_SH4 && GET_MODE_CLASS (mode) == MODE_FLOAT)\n@@ -825,16 +825,16 @@ from_compare (operands, code)\n     mode = GET_MODE (sh_compare_op1);\n   if (code != EQ\n       || mode == DImode\n-      || (TARGET_SH3E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n+      || (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n     {\n       /* Force args into regs, since we can't use constants here.  */\n       sh_compare_op0 = force_reg (mode, sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx\n \t  || code == GTU  || code == GEU\n-\t  || (TARGET_SH3E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n+\t  || (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n \tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n     }\n-  if (TARGET_SH3E && GET_MODE_CLASS (mode) == MODE_FLOAT && code == GE)\n+  if (TARGET_SH2E && GET_MODE_CLASS (mode) == MODE_FLOAT && code == GE)\n     {\n       from_compare (operands, GT);\n       insn = gen_ieee_ccmpeqsf_t (sh_compare_op0, sh_compare_op1);\n@@ -1091,6 +1091,39 @@ output_branch (logic, insn, operands)\n \t will fix it up if it still doesn't fit after relaxation.  */\n     case 2:\n       return logic ? \"bt%.\\t%l0\" : \"bf%.\\t%l0\";\n+\n+      /* These are for SH2e, in which we have to account for the\n+\t extra nop because of the hardware bug in annulled branches.  */\n+    case 8:\n+      if (! TARGET_RELAX)\n+\t{\n+\t  int label = lf++;\n+\n+\t  if (final_sequence\n+\t      && INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n+\t    abort ();\n+\t  asm_fprintf (asm_out_file, \"b%s%ss\\t%LLF%d\\n\",\n+\t\t       logic ? \"f\" : \"t\",\n+\t\t       ASSEMBLER_DIALECT ? \"/\" : \".\", label);\n+\t  fprintf (asm_out_file, \"\\tnop\\n\");\n+\t  output_asm_insn (\"bra\\t%l0\", operands);\n+\t  fprintf (asm_out_file, \"\\tnop\\n\");\n+\t  (*targetm.asm_out.internal_label) (asm_out_file, \"LF\", label);\n+\n+\t  return \"\";\n+\t}\n+      /* When relaxing, fall through.  */\n+    case 4:\n+      {\n+\tchar buffer[10];\n+\t\n+\tsprintf (buffer, \"b%s%ss\\t%%l0\",\n+\t\t logic ? \"t\" : \"f\",\n+\t\t ASSEMBLER_DIALECT ? \"/\" : \".\");\n+\toutput_asm_insn (buffer, &operands[0]);\n+\treturn \"nop\";\n+      }\n+\n     default:\n       /* There should be no longer branches now - that would\n \t indicate that something has destroyed the branches set\n@@ -1945,7 +1978,7 @@ shl_sext_kind (left_rtx, size_rtx, costp)\n      int *costp;\n {\n   int left, size, insize, ext;\n-  int cost, best_cost;\n+  int cost = 0, best_cost;\n   int kind;\n \n   left = INTVAL (left_rtx);\n@@ -2559,7 +2592,7 @@ broken_move (insn)\n \t      || (GET_CODE (SET_SRC (pat)) == UNSPEC\n \t\t  && XINT (SET_SRC (pat), 1) == UNSPEC_MOVA\n \t\t  && GET_CODE (XVECEXP (SET_SRC (pat), 0, 0)) == CONST))\n-\t  && ! (TARGET_SH3E\n+\t  && ! (TARGET_SH2E\n \t\t&& GET_CODE (SET_SRC (pat)) == CONST_DOUBLE\n \t\t&& (fp_zero_operand (SET_SRC (pat))\n \t\t    || fp_one_operand (SET_SRC (pat)))\n@@ -2612,7 +2645,7 @@ find_barrier (num_mova, mova, from)\n   int hi_align = 2;\n   int si_align = 2;\n   int leading_mova = num_mova;\n-  rtx barrier_before_mova, found_barrier = 0, good_barrier = 0;\n+  rtx barrier_before_mova = 0, found_barrier = 0, good_barrier = 0;\n   int si_limit;\n   int hi_limit;\n \n@@ -3291,7 +3324,7 @@ barrier_align (barrier_or_label)\n      rtx barrier_or_label;\n {\n   rtx next = next_real_insn (barrier_or_label), pat, prev;\n-  int slot, credit, jump_to_next;\n+  int slot, credit, jump_to_next = 0;\n  \n   if (! next)\n     return 0;\n@@ -3437,7 +3470,7 @@ void\n machine_dependent_reorg (first)\n      rtx first;\n {\n-  rtx insn, mova;\n+  rtx insn, mova = NULL_RTX;\n   int num_mova;\n   rtx r0_rtx = gen_rtx_REG (Pmode, 0);\n   rtx r0_inc_rtx = gen_rtx_POST_INC (Pmode, r0_rtx);\n@@ -3732,7 +3765,7 @@ machine_dependent_reorg (first)\n \t  /* Scan ahead looking for a barrier to stick the constant table\n \t     behind.  */\n \t  rtx barrier = find_barrier (num_mova, mova, insn);\n-\t  rtx last_float_move, last_float = 0, *last_float_addr;\n+\t  rtx last_float_move = NULL_RTX, last_float = 0, *last_float_addr = NULL;\n \n \t  if (num_mova && ! mova_p (mova))\n \t    {\n@@ -4321,7 +4354,7 @@ push (rn)\n \treturn NULL_RTX;\n       x = gen_push_4 (gen_rtx_REG (DFmode, rn));\n     }\n-  else if (TARGET_SH3E && FP_REGISTER_P (rn))\n+  else if (TARGET_SH2E && FP_REGISTER_P (rn))\n     x = gen_push_e (gen_rtx_REG (SFmode, rn));\n   else\n     x = gen_push (gen_rtx_REG (SImode, rn));\n@@ -4351,7 +4384,7 @@ pop (rn)\n \treturn;\n       x = gen_pop_4 (gen_rtx_REG (DFmode, rn));\n     }\n-  else if (TARGET_SH3E && FP_REGISTER_P (rn))\n+  else if (TARGET_SH2E && FP_REGISTER_P (rn))\n     x = gen_pop_e (gen_rtx_REG (SFmode, rn));\n   else\n     x = gen_pop (gen_rtx_REG (SImode, rn));\n@@ -4590,8 +4623,8 @@ sh_expand_prologue ()\n   /* Emit the code for SETUP_VARARGS.  */\n   if (current_function_stdarg)\n     {\n-      /* This is not used by the SH3E calling convention  */\n-      if (TARGET_SH1 && ! TARGET_SH3E && ! TARGET_SH5 && ! TARGET_HITACHI)\n+      /* This is not used by the SH2E calling convention  */\n+      if (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5 && ! TARGET_HITACHI)\n \t{\n \t  /* Push arg regs as if they'd been provided by caller in stack.  */\n \t  for (i = 0; i < NPARM_REGS(SImode); i++)\n@@ -5246,7 +5279,7 @@ sh_builtin_saveregs ()\n \treturn const0_rtx;\n     }\n   \n-  if (! TARGET_SH3E && ! TARGET_SH4 && ! TARGET_SH5)\n+  if (! TARGET_SH2E && ! TARGET_SH4 && ! TARGET_SH5)\n     {\n       error (\"__builtin_saveregs not supported by this subtarget\");\n       return const0_rtx;\n@@ -5349,7 +5382,7 @@ sh_build_va_list ()\n   tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n   tree record;\n \n-  if (TARGET_SH5 || (! TARGET_SH3E && ! TARGET_SH4) || TARGET_HITACHI)\n+  if (TARGET_SH5 || (! TARGET_SH2E && ! TARGET_SH4) || TARGET_HITACHI)\n     return ptr_type_node;\n \n   record = make_node (RECORD_TYPE);\n@@ -5403,7 +5436,7 @@ sh_va_start (valist, nextarg)\n       return;\n     }\n \n-  if ((! TARGET_SH3E && ! TARGET_SH4) || TARGET_HITACHI)\n+  if ((! TARGET_SH2E && ! TARGET_SH4) || TARGET_HITACHI)\n     {\n       std_expand_builtin_va_start (valist, nextarg);\n       return;\n@@ -5481,7 +5514,7 @@ sh_va_arg (valist, type)\n   if (pass_by_ref)\n     type = build_pointer_type (type);\n \n-  if (! TARGET_SH5 && (TARGET_SH3E || TARGET_SH4) && ! TARGET_HITACHI)\n+  if (! TARGET_SH5 && (TARGET_SH2E || TARGET_SH4) && ! TARGET_HITACHI)\n     {\n       tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n       tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n@@ -6877,6 +6910,16 @@ sh_insn_length_adjustment (insn)\n       && get_attr_needs_delay_slot (insn) == NEEDS_DELAY_SLOT_YES)\n     return 2;\n \n+  /* SH2e has a bug that prevents the use of annulled branches, so if\n+     the delay slot is not filled, we'll have to put a NOP in it.  */\n+  if (sh_cpu == CPU_SH2E\n+      && GET_CODE (insn) == JUMP_INSN\n+      && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC\n+      && GET_CODE (PATTERN (insn)) != ADDR_VEC\n+      && get_attr_type (insn) == TYPE_CBRANCH\n+      && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (insn)))) != SEQUENCE)\n+    return 2;\n+\n   /* sh-dsp parallel processing insn take four bytes instead of two.  */\n      \n   if (GET_CODE (insn) == INSN)"}, {"sha": "b92c747f02cfd441c834e3d2ddcab374b0c5018c", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 54, "deletions": 42, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -45,6 +45,9 @@ do { \\\n     case PROCESSOR_SH2: \\\n       builtin_define (\"__sh2__\"); \\\n       break; \\\n+    case PROCESSOR_SH2E: \\\n+      builtin_define (\"__SH2E__\"); \\\n+      break; \\\n     case PROCESSOR_SH3: \\\n       builtin_define (\"__sh3__\"); \\\n       builtin_define (\"__SH3__\"); \\\n@@ -132,7 +135,7 @@ extern int target_flags;\n #define SH1_BIT\t       \t(1<<8)\n #define SH2_BIT\t       \t(1<<9)\n #define SH3_BIT\t       \t(1<<10)\n-#define SH3E_BIT\t(1<<11)\n+#define SH_E_BIT\t(1<<11)\n #define HARD_SH4_BIT\t(1<<5)\n #define FPU_SINGLE_BIT\t(1<<7)\n #define SH4_BIT\t       \t(1<<12)\n@@ -161,11 +164,14 @@ extern int target_flags;\n /* Nonzero if we should generate code using type 2 insns.  */\n #define TARGET_SH2 (target_flags & SH2_BIT)\n \n+/* Nonzero if we should generate code using type 2E insns.  */\n+#define TARGET_SH2E ((target_flags & SH_E_BIT) && TARGET_SH2)\n+\n /* Nonzero if we should generate code using type 3 insns.  */\n #define TARGET_SH3 (target_flags & SH3_BIT)\n \n /* Nonzero if we should generate code using type 3E insns.  */\n-#define TARGET_SH3E ((target_flags & SH3E_BIT) && (target_flags & SH1_BIT))\n+#define TARGET_SH3E ((target_flags & SH_E_BIT) && TARGET_SH3)\n \n /* Nonzero if the cache line size is 32.  */\n #define TARGET_CACHE32 (target_flags & HARD_SH4_BIT || TARGET_SH5)\n@@ -186,7 +192,7 @@ extern int target_flags;\n #define TARGET_FPU_DOUBLE (target_flags & SH4_BIT)\n \n /* Nonzero if an FPU is available.  */\n-#define TARGET_FPU_ANY (TARGET_SH3E || TARGET_FPU_DOUBLE)\n+#define TARGET_FPU_ANY (TARGET_SH2E || TARGET_FPU_DOUBLE)\n \n /* Nonzero if we should generate code using type 4 insns.  */\n #define TARGET_SH4 ((target_flags & SH4_BIT) && (target_flags & SH1_BIT))\n@@ -205,12 +211,12 @@ extern int target_flags;\n /* Nonzero if we should generate code using the SHmedia ISA and 32-bit\n    ABI.  */\n #define TARGET_SHMEDIA32 (TARGET_SH5 && ! TARGET_SH1 \\\n-\t\t\t  && (target_flags & SH3E_BIT))\n+\t\t\t  && (target_flags & SH_E_BIT))\n \n /* Nonzero if we should generate code using the SHmedia ISA and 64-bit\n    ABI.  */\n #define TARGET_SHMEDIA64 (TARGET_SH5 && ! TARGET_SH1 \\\n- \t\t\t  && ! (target_flags & SH3E_BIT))\n+ \t\t\t  && ! (target_flags & SH_E_BIT))\n \n /* Nonzero if we should generate code using SHmedia FPU instructions.  */\n #define TARGET_SHMEDIA_FPU (TARGET_SHMEDIA && TARGET_FPU_DOUBLE)\n@@ -252,42 +258,45 @@ extern int target_flags;\n /* Nonzero if we should prefer @GOT calls when generating PIC.  */\n #define TARGET_PREFERGOT\t(target_flags & PREFERGOT_BIT)\n \n-#define SELECT_SH1 (SH1_BIT)\n-#define SELECT_SH2 (SH2_BIT | SELECT_SH1)\n-#define SELECT_SH3 (SH3_BIT | SELECT_SH2)\n-#define SELECT_SH3E (SH3E_BIT | FPU_SINGLE_BIT | SELECT_SH3)\n-#define SELECT_SH4_NOFPU (HARD_SH4_BIT | SELECT_SH3)\n-#define SELECT_SH4_SINGLE_ONLY (HARD_SH4_BIT | SELECT_SH3E)\n-#define SELECT_SH4 (SH4_BIT|SH3E_BIT|HARD_SH4_BIT | SELECT_SH3)\n-#define SELECT_SH4_SINGLE (FPU_SINGLE_BIT | SELECT_SH4)\n-#define SELECT_SH5_64 (SH5_BIT | SH4_BIT)\n-#define SELECT_SH5_64_NOFPU (SH5_BIT)\n-#define SELECT_SH5_32 (SH5_BIT | SH4_BIT | SH3E_BIT)\n-#define SELECT_SH5_32_NOFPU (SH5_BIT | SH3E_BIT)\n-#define SELECT_SH5_COMPACT (SH5_BIT | SH4_BIT | SELECT_SH3E)\n+#define SELECT_SH1               (SH1_BIT)\n+#define SELECT_SH2               (SH2_BIT | SELECT_SH1)\n+#define SELECT_SH2E              (SH_E_BIT | SH2_BIT | SH1_BIT | FPU_SINGLE_BIT)\n+#define SELECT_SH3               (SH3_BIT | SELECT_SH2)\n+#define SELECT_SH3E              (SH_E_BIT | FPU_SINGLE_BIT | SELECT_SH3)\n+#define SELECT_SH4_NOFPU         (HARD_SH4_BIT | SELECT_SH3)\n+#define SELECT_SH4_SINGLE_ONLY   (HARD_SH4_BIT | SELECT_SH3E)\n+#define SELECT_SH4               (SH4_BIT | SH_E_BIT | HARD_SH4_BIT | SELECT_SH3)\n+#define SELECT_SH4_SINGLE        (FPU_SINGLE_BIT | SELECT_SH4)\n+#define SELECT_SH5_64            (SH5_BIT | SH4_BIT)\n+#define SELECT_SH5_64_NOFPU      (SH5_BIT)\n+#define SELECT_SH5_32            (SH5_BIT | SH4_BIT | SH_E_BIT)\n+#define SELECT_SH5_32_NOFPU      (SH5_BIT | SH_E_BIT)\n+#define SELECT_SH5_COMPACT       (SH5_BIT | SH4_BIT | SELECT_SH3E)\n #define SELECT_SH5_COMPACT_NOFPU (SH5_BIT | SELECT_SH3)\n \n /* Reset all target-selection flags.  */\n-#define TARGET_NONE -(SH1_BIT | SH2_BIT | SH3_BIT | SH3E_BIT | SH4_BIT \\\n+#define TARGET_NONE -(SH1_BIT | SH2_BIT | SH3_BIT | SH_E_BIT | SH4_BIT \\\n \t\t      | HARD_SH4_BIT | FPU_SINGLE_BIT | SH5_BIT)\n \n #define TARGET_SWITCHES  \t\t\t\\\n { {\"1\",\t        TARGET_NONE, \"\" },\t\t\\\n-  {\"1\",\t        SELECT_SH1, \"\" },\t\t\t\\\n+  {\"1\",\t        SELECT_SH1, \"\" },\t\t\\\n   {\"2\",\t        TARGET_NONE, \"\" },\t\t\\\n   {\"2\",\t        SELECT_SH2, \"\" },\t\t\\\n+  {\"2e\",        TARGET_NONE, \"\" },\t\t\\\n+  {\"2e\",        SELECT_SH2E, \"\" },\t\t\\\n   {\"3\",\t        TARGET_NONE, \"\" },\t\t\\\n-  {\"3\",\t        SELECT_SH3, \"\" },\t\\\n+  {\"3\",\t        SELECT_SH3, \"\" },\t\t\\\n   {\"3e\",\tTARGET_NONE, \"\" },\t\t\\\n-  {\"3e\",\tSELECT_SH3E, \"\" },\t\\\n+  {\"3e\",\tSELECT_SH3E, \"\" },\t\t\\\n   {\"4-single-only\",\tTARGET_NONE, \"\" },\t\\\n   {\"4-single-only\",\tSELECT_SH4_SINGLE_ONLY, \"\" },\t\\\n   {\"4-single\",\tTARGET_NONE, \"\" },\t\t\\\n-  {\"4-single\",\tSELECT_SH4_SINGLE, \"\" },\\\n+  {\"4-single\",\tSELECT_SH4_SINGLE, \"\" },\t\\\n   {\"4-nofpu\",\tTARGET_NONE, \"\" },\t\t\\\n-  {\"4-nofpu\",\tSELECT_SH4_NOFPU, \"\" },\\\n+  {\"4-nofpu\",\tSELECT_SH4_NOFPU, \"\" },\t\t\\\n   {\"4\",\t        TARGET_NONE, \"\" },\t\t\\\n-  {\"4\",\t        SELECT_SH4, \"\" }, \\\n+  {\"4\",\t        SELECT_SH4, \"\" }, \t\t\\\n   {\"5-64media\",\tTARGET_NONE, \"\" },\t\t\\\n   {\"5-64media\", SELECT_SH5_64, \"Generate 64-bit SHmedia code\" }, \\\n   {\"5-64media-nofpu\", TARGET_NONE, \"\" },\t\\\n@@ -365,11 +374,11 @@ extern int target_flags;\n #define LINK_EMUL_PREFIX \"sh%{ml:l}\"\n \n #if TARGET_CPU_DEFAULT & SH5_BIT\n-#if TARGET_CPU_DEFAULT & SH3E_BIT\n+#if TARGET_CPU_DEFAULT & SH_E_BIT\n #define LINK_DEFAULT_CPU_EMUL \"32\"\n #else\n #define LINK_DEFAULT_CPU_EMUL \"64\"\n-#endif /* SH3E_BIT */\n+#endif /* SH_E_BIT */\n #else\n #define LINK_DEFAULT_CPU_EMUL \"\"\n #endif /* SH5_BIT */\n@@ -409,6 +418,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   assembler_dialect = 0;\t\t\t\t\t\t\\\n   if (TARGET_SH2)\t\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH2;\t\t\t\t\t\t\t\\\n+  if (TARGET_SH2E)\t\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH2E;\t\t\t\t\t\t\t\\\n   if (TARGET_SH3)\t\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH3;\t\t\t\t\t\t\t\\\n   if (TARGET_SH3E)\t\t\t\t\t\t\t\\\n@@ -737,7 +748,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n #define LAST_GENERAL_REG (FIRST_GENERAL_REG + (TARGET_SHMEDIA ? 63 : 15))\n #define FIRST_FP_REG DR0_REG\n #define LAST_FP_REG  (FIRST_FP_REG + \\\n-\t\t      (TARGET_SHMEDIA_FPU ? 63 : TARGET_SH3E ? 15 : -1))\n+\t\t      (TARGET_SHMEDIA_FPU ? 63 : TARGET_SH2E ? 15 : -1))\n #define FIRST_XD_REG XD0_REG\n #define LAST_XD_REG  (FIRST_XD_REG + ((TARGET_SH4 && TARGET_FMOVD) ? 7 : -1))\n #define FIRST_TARGET_REG TR0_REG\n@@ -778,7 +789,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n   (SHMEDIA_REGISTER_P (REGNO) || XD_REGISTER_P (REGNO) \\\n    || (REGNO) == AP_REG || (REGNO) == RAP_REG \\\n    || (TARGET_SH1 && (SPECIAL_REGISTER_P (REGNO) || (REGNO) == PR_REG)) \\\n-   || (TARGET_SH3E && (REGNO) == FPUL_REG))\n+   || (TARGET_SH2E && (REGNO) == FPUL_REG))\n \n /* The mode that should be generally used to store a register by\n    itself in the stack, or to load it back.  */\n@@ -927,7 +938,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n       : (REGNO) == FIRST_XD_REG) \\\n    : FP_REGISTER_P (REGNO) \\\n    ? ((MODE) == SFmode || (MODE) == SImode \\\n-      || ((TARGET_SH3E || TARGET_SHMEDIA) && (MODE) == SCmode) \\\n+      || ((TARGET_SH2E || TARGET_SHMEDIA) && (MODE) == SCmode) \\\n       || (((TARGET_SH4 && (MODE) == DFmode) || (MODE) == DCmode \\\n \t   || (TARGET_SHMEDIA && ((MODE) == DFmode || (MODE) == DImode \\\n \t\t\t\t  || (MODE) == V2SFmode || (MODE) == TImode))) \\\n@@ -1468,7 +1479,7 @@ extern enum reg_class reg_class_from_letter[];\n    : FIRST_RET_REG)\n \n #define BASE_ARG_REG(MODE) \\\n-  ((TARGET_SH3E && ((MODE) == SFmode))\t\t\t\\\n+  ((TARGET_SH2E && ((MODE) == SFmode))\t\t\t\\\n    ? FIRST_FP_PARM_REG\t\t\t\t\t\\\n    : TARGET_SH4 && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n \t\t    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\\\n@@ -1504,7 +1515,7 @@ extern enum reg_class reg_class_from_letter[];\n \n /* 1 if N is a possible register number for a function value.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO) \\\n-  ((REGNO) == FIRST_RET_REG || (TARGET_SH3E && (REGNO) == FIRST_FP_RET_REG) \\\n+  ((REGNO) == FIRST_RET_REG || (TARGET_SH2E && (REGNO) == FIRST_FP_RET_REG) \\\n    || (TARGET_SHMEDIA_FPU && (REGNO) == FIRST_FP_RET_REG))\n \n /* 1 if N is a possible register number for function argument passing.  */\n@@ -1838,7 +1849,7 @@ struct sh_args {\n     || (! TREE_ADDRESSABLE ((tree)(TYPE)) \\\n \t&& (! TARGET_HITACHI || ! AGGREGATE_TYPE_P (TYPE)))) \\\n    && ! (CUM).force_mem \\\n-   && (TARGET_SH3E \\\n+   && (TARGET_SH2E \\\n        ? ((MODE) == BLKmode \\\n \t  ? (((CUM).arg_count[(int) SH_ARG_INT] * UNITS_PER_WORD \\\n \t      + int_size_in_bytes (TYPE)) \\\n@@ -2181,7 +2192,7 @@ while (0)\n       || TARGET_SHMEDIA64)\t\t\t\t\t\t\\\n    : (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n       || GET_MODE (X) == DFmode || GET_MODE (X) == SFmode\t\t\\\n-      || (TARGET_SH3E && (fp_zero_operand (X) || fp_one_operand (X)))))\n+      || (TARGET_SH2E && (fp_zero_operand (X) || fp_one_operand (X)))))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -2336,7 +2347,7 @@ while (0)\n \n #define MODE_DISP_OK_4(X,MODE) \\\n (GET_MODE_SIZE (MODE) == 4 && (unsigned) INTVAL (X) < 64\t\\\n- && ! (INTVAL (X) & 3) && ! (TARGET_SH3E && (MODE) == SFmode))\n+ && ! (INTVAL (X) & 3) && ! (TARGET_SH2E && (MODE) == SFmode))\n \n #define MODE_DISP_OK_8(X,MODE) \\\n ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60)\t\\\n@@ -2367,7 +2378,7 @@ while (0)\n \t  REG++\n \t  --REG  */\n \n-/* ??? The SH3e does not have the REG+disp addressing mode when loading values\n+/* ??? The SH2e does not have the REG+disp addressing mode when loading values\n    into the FRx registers.  We implement this by setting the maximum offset\n    to zero when the value is SFmode.  This also restricts loading of SFmode\n    values into the integer registers, but that can't be helped.  */\n@@ -2453,7 +2464,7 @@ while (0)\n       && BASE_REGISTER_RTX_P (XEXP ((X), 0))\t\t\t\\\n       && ! TARGET_SHMEDIA\t\t\t\t\t\\\n       && ! (TARGET_SH4 && (MODE) == DFmode)\t\t\t\\\n-      && ! (TARGET_SH3E && (MODE) == SFmode))\t\t\t\\\n+      && ! (TARGET_SH2E && (MODE) == SFmode))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       rtx index_rtx = XEXP ((X), 1);\t\t\t\t\\\n       HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\t\\\n@@ -2508,7 +2519,7 @@ while (0)\n       HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\t\t\\\n       rtx sum;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (TARGET_SH3E && MODE == SFmode)\t\t\t\t\\\n+      if (TARGET_SH2E && MODE == SFmode)\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  X = copy_rtx (X);\t\t\t\t\t\t\\\n \t  push_reload (index_rtx, NULL_RTX, &XEXP (X, 1), NULL,\t\t\\\n@@ -2547,7 +2558,7 @@ while (0)\n \t   && BASE_REGISTER_RTX_P (XEXP (XEXP (X, 0), 0))\t\t\\\n \t   && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n \t   && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n-\t   && ! (TARGET_SH3E && MODE == SFmode))\t\t\t\\\n+\t   && ! (TARGET_SH2E && MODE == SFmode))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       /* Because this address is so complex, we know it must have\t\\\n \t been created by LEGITIMIZE_RELOAD_ADDRESS before; thus,\t\\\n@@ -2593,9 +2604,9 @@ while (0)\n /* Define it here, so that it doesn't get bumped to 64-bits on SHmedia.  */\n #define FLOAT_TYPE_SIZE 32\n \n-/* Since the SH3e has only `float' support, it is desirable to make all\n+/* Since the SH2e has only `float' support, it is desirable to make all\n    floating point types equivalent to `float'.  */\n-#define DOUBLE_TYPE_SIZE ((TARGET_SH3E && ! TARGET_SH4) ? 32 : 64)\n+#define DOUBLE_TYPE_SIZE ((TARGET_SH2E && ! TARGET_SH4) ? 32 : 64)\n \n /* 'char' is signed by default.  */\n #define DEFAULT_SIGNED_CHAR  1\n@@ -3138,6 +3149,7 @@ extern struct rtx_def *sh_compare_op1;\n enum processor_type {\n   PROCESSOR_SH1,\n   PROCESSOR_SH2,\n+  PROCESSOR_SH2E,\n   PROCESSOR_SH3,\n   PROCESSOR_SH3E,\n   PROCESSOR_SH4,\n@@ -3286,7 +3298,7 @@ extern int rtx_equal_function_value_matters;\n    : TARGET_FPU_SINGLE ? FP_MODE_SINGLE \\\n    : FP_MODE_DOUBLE)\n \n-#define EPILOGUE_USES(REGNO)       ((TARGET_SH3E || TARGET_SH4)\t\t\\\n+#define EPILOGUE_USES(REGNO)       ((TARGET_SH2E || TARGET_SH4)\t\t\\\n \t\t\t\t    && (REGNO) == FPSCR_REG)\n \n #define MODE_NEEDED(ENTITY, INSN)\t\t\t\t\t\\"}, {"sha": "45f661014b14945f7900fc4a3db3466f009b0830", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for Hitachi / SuperH SH.\n-;;  Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n+;;  Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n ;;  Free Software Foundation, Inc.\n ;;  Contributed by Steve Chamberlain (sac@cygnus.com).\n ;;  Improved by Jim Wilson (wilson@cygnus.com).\n@@ -154,7 +154,7 @@\n ;; Target CPU.\n \n (define_attr \"cpu\"\n- \"sh1,sh2,sh3,sh3e,sh4,sh5\"\n+ \"sh1,sh2,sh2e,sh3,sh3e,sh4,sh5\"\n   (const (symbol_ref \"sh_cpu_attr\")))\n \n (define_attr \"endian\" \"big,little\"\n@@ -609,7 +609,10 @@\n (define_delay\n   (and (eq_attr \"type\" \"cbranch\")\n        (ne (symbol_ref \"TARGET_SH2\") (const_int 0)))\n-  [(eq_attr \"in_delay_slot\" \"yes\") (eq_attr \"cond_delay_slot\" \"yes\") (nil)])\n+  ;; SH2e has a hardware bug that pretty much prohibits the use of\n+  ;; annuled delay slots.\n+  [(eq_attr \"in_delay_slot\" \"yes\") (and (eq_attr \"cond_delay_slot\" \"yes\")\n+\t\t\t\t\t(not (eq_attr \"cpu\" \"sh2e\"))) (nil)])\n \f\n ;; -------------------------------------------------------------------------\n ;; SImode signed integer comparisons\n@@ -1346,7 +1349,7 @@\n \n   operands[3] = gen_reg_rtx (Pmode);\n   /* Emit the move of the address to a pseudo outside of the libcall.  */\n-  if (TARGET_HARD_SH4 && TARGET_SH3E)\n+  if (TARGET_HARD_SH4 && TARGET_SH2E)\n     {\n       emit_move_insn (operands[3],\n \t\t      gen_rtx_SYMBOL_REF (SImode, \\\"__udivsi3_i4\\\"));\n@@ -1496,7 +1499,7 @@\n \n   operands[3] = gen_reg_rtx (Pmode);\n   /* Emit the move of the address to a pseudo outside of the libcall.  */\n-  if (TARGET_HARD_SH4 && TARGET_SH3E)\n+  if (TARGET_HARD_SH4 && TARGET_SH2E)\n     {\n       emit_move_insn (operands[3],\n \t\t      gen_rtx_SYMBOL_REF (SImode, \\\"__sdivsi3_i4\\\"));\n@@ -3297,7 +3300,7 @@\n \n (define_insn \"push_fpul\"\n   [(set (mem:SF (pre_dec:SI (reg:SI SP_REG))) (reg:SF FPUL_REG))]\n-  \"TARGET_SH3E && ! TARGET_SH5\"\n+  \"TARGET_SH2E && ! TARGET_SH5\"\n   \"sts.l\tfpul,@-r15\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"late_fp_use\" \"yes\")\n@@ -3323,7 +3326,7 @@\n \n (define_insn \"pop_fpul\"\n   [(set (reg:SF FPUL_REG) (mem:SF (post_inc:SI (reg:SI SP_REG))))]\n-  \"TARGET_SH3E && ! TARGET_SH5\"\n+  \"TARGET_SH2E && ! TARGET_SH5\"\n   \"lds.l\t@r15+,fpul\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"hit_stack\" \"yes\")])\n@@ -3383,7 +3386,7 @@\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,t,r,r,r,r,m,<,<,x,l,x,l,r\")\n \t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,r,mr,x,l,t,r,x,l,r,r,>,>,i\"))]\n   \"TARGET_SH1\n-   && ! TARGET_SH3E\n+   && ! TARGET_SH2E\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@\n@@ -3414,7 +3417,7 @@\n (define_insn \"movsi_ie\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,t,r,r,r,r,m,<,<,x,l,x,l,y,<,r,y,r,*f,y,*f,y\")\n \t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,r,mr,x,l,t,r,x,l,r,r,>,>,>,y,i,r,y,y,*f,*f,y\"))]\n-  \"TARGET_SH3E\n+  \"TARGET_SH2E\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@\n@@ -4354,7 +4357,7 @@\n \t(match_operand:SF 1 \"register_operand\" \"\"))\n    (use (match_operand:PSI 2 \"fpscr_operand\" \"\"))\n    (clobber (match_scratch:SI 3 \"X\"))]\n-  \"TARGET_SH3E && reload_completed\n+  \"TARGET_SH2E && reload_completed\n    && true_regnum (operands[0]) == true_regnum (operands[1])\"\n   [(set (match_dup 0) (match_dup 0))]\n   \"\")\n@@ -4843,7 +4846,7 @@\n   [(set (match_operand:SF 0 \"general_movdst_operand\" \"=r,r,r,r,m,l,r\")\n \t(match_operand:SF 1 \"general_movsrc_operand\"  \"r,I,FQ,mr,r,r,l\"))]\n   \"TARGET_SH1\n-   && (! TARGET_SH3E\n+   && (! TARGET_SH2E\n        /* ??? We provide some insn so that direct_{load,store}[SFmode] get set */\n        || (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3)\n        || (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3))\n@@ -4870,7 +4873,7 @@\n    (use (match_operand:PSI 2 \"fpscr_operand\" \"c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c\"))\n    (clobber (match_scratch:SI 3 \"=X,X,X,X,&z,X,X,X,X,X,X,X,X,y,X,X,X,X,X\"))]\n \n-  \"TARGET_SH3E\n+  \"TARGET_SH2E\n    && (arith_reg_operand (operands[0], SFmode)\n        || arith_reg_operand (operands[1], SFmode)\n        || arith_reg_operand (operands[3], SImode)\n@@ -4937,7 +4940,7 @@\n \temit_insn (gen_movsf_media_nofpu (operands[0], operands[1]));\n       DONE;\n     }\n-  if (TARGET_SH3E)\n+  if (TARGET_SH2E)\n     {\n       emit_sf_insn (gen_movsf_ie (operands[0], operands[1], get_fpscr_rtx ()));\n       DONE;\n@@ -4946,7 +4949,7 @@\n \n (define_insn \"mov_nop\"\n   [(set (match_operand 0 \"any_register_operand\" \"\") (match_dup 0))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH2E\"\n   \"\"\n   [(set_attr \"length\" \"0\")\n    (set_attr \"type\" \"nil\")])\n@@ -4970,7 +4973,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=y,y\")\n \t(match_operand:SI 1 \"immediate_operand\" \"Qi,I\"))\n    (clobber (match_scratch:SI 2 \"=&z,r\"))]\n-  \"TARGET_SH3E\n+  \"TARGET_SH2E\n    && (reload_in_progress || reload_completed)\"\n   \"#\"\n   [(set_attr \"length\" \"4\")\n@@ -5290,7 +5293,7 @@\n       DONE;\n     }\n \n-  if (TARGET_SH3E\n+  if (TARGET_SH2E\n       && TARGET_IEEE\n       && GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n     {\n@@ -5331,7 +5334,7 @@\n       DONE;\n     }\n \n-  if (TARGET_SH3E\n+  if (TARGET_SH2E\n       && ! TARGET_IEEE\n       && GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n     {\n@@ -6487,7 +6490,7 @@\n \t\t    (const_int 0))\n \t      (match_operand 1 \"\" \"\")\n \t      (match_operand 2 \"\" \"\")])]\n-  \"TARGET_SH3E || TARGET_SHMEDIA\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA\"\n   \"\n {\n   int i;\n@@ -7991,10 +7994,10 @@\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"\")\n \t(plus:SF (match_operand:SF 1 \"arith_reg_operand\" \"\")\n \t\t (match_operand:SF 2 \"arith_reg_operand\" \"\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n-  if (TARGET_SH3E)\n+  if (TARGET_SH2E)\n     {\n       expand_sf_binop (&gen_addsf3_i, operands);\n       DONE;\n@@ -8080,7 +8083,7 @@\n \t(plus:SF (match_operand:SF 1 \"arith_reg_operand\" \"%0\")\n \t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))\n    (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH2E\"\n   \"fadd\t%2,%0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -8089,10 +8092,10 @@\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"\")\n \t(minus:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"\")\n \t\t  (match_operand:SF 2 \"fp_arith_reg_operand\" \"\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n-  if (TARGET_SH3E)\n+  if (TARGET_SH2E)\n     {\n       expand_sf_binop (&gen_subsf3_i, operands);\n       DONE;\n@@ -8112,7 +8115,7 @@\n \t(minus:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"0\")\n \t\t (match_operand:SF 2 \"fp_arith_reg_operand\" \"f\")))\n    (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH2E\"\n   \"fsub\t%2,%0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -8126,12 +8129,12 @@\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"\")\n \t(mult:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"\")\n \t\t (match_operand:SF 2 \"fp_arith_reg_operand\" \"\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n   if (TARGET_SH4)\n     expand_sf_binop (&gen_mulsf3_i4, operands);\n-  else if (TARGET_SH3E)\n+  else if (TARGET_SH2E)\n     emit_insn (gen_mulsf3_ie (operands[0], operands[1], operands[2]));\n   if (! TARGET_SHMEDIA)\n     DONE;\n@@ -8150,7 +8153,7 @@\n \t(mult:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"%0\")\n \t\t (match_operand:SF 2 \"fp_arith_reg_operand\" \"f\")))\n    (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH2E\"\n   \"fmul\t%2,%0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -8159,7 +8162,7 @@\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"%0\")\n \t\t (match_operand:SF 2 \"fp_arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH3E && ! TARGET_SH4\"\n+  \"TARGET_SH2E && ! TARGET_SH4\"\n   \"fmul\t%2,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -8178,7 +8181,7 @@\n \t\t\t  (match_operand:SF 2 \"fp_arith_reg_operand\" \"f\"))\n \t\t (match_operand:SF 3 \"arith_reg_operand\" \"0\")))\n    (use (match_operand:PSI 4 \"fpscr_operand\" \"c\"))]\n-  \"TARGET_SH3E && ! TARGET_SH4\"\n+  \"TARGET_SH2E && ! TARGET_SH4\"\n   \"fmac\tfr0,%2,%0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -8187,10 +8190,10 @@\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"\")\n \t(div:SF (match_operand:SF 1 \"arith_reg_operand\" \"\")\n \t\t(match_operand:SF 2 \"arith_reg_operand\" \"\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n-  if (TARGET_SH3E)\n+  if (TARGET_SH2E)\n     {\n       expand_sf_binop (&gen_divsf3_i, operands);\n       DONE;\n@@ -8210,7 +8213,7 @@\n \t(div:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")\n \t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))\n    (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH2E\"\n   \"fdiv\t%2,%0\"\n   [(set_attr \"type\" \"fdiv\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -8225,7 +8228,7 @@\n (define_expand \"floatsisf2\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"\")\n \t(float:SF (match_operand:SI 1 \"fpul_operand\" \"\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n   if (TARGET_SH4)\n@@ -8254,7 +8257,7 @@\n (define_insn \"*floatsisf2_ie\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n \t(float:SF (match_operand:SI 1 \"fpul_operand\" \"y\")))]\n-  \"TARGET_SH3E && ! TARGET_SH4\"\n+  \"TARGET_SH2E && ! TARGET_SH4\"\n   \"float\t%1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -8268,7 +8271,7 @@\n (define_expand \"fix_truncsfsi2\"\n   [(set (match_operand:SI 0 \"fpul_operand\" \"=y\")\n \t(fix:SI (match_operand:SF 1 \"fp_arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n   if (TARGET_SH4)\n@@ -8319,15 +8322,15 @@\n (define_insn \"*fixsfsi\"\n   [(set (match_operand:SI 0 \"fpul_operand\" \"=y\")\n \t(fix:SI (match_operand:SF 1 \"fp_arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH3E && ! TARGET_SH4\"\n+  \"TARGET_SH2E && ! TARGET_SH4\"\n   \"ftrc\t%1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn \"cmpgtsf_t\"\n   [(set (reg:SI T_REG)\n \t(gt:SI (match_operand:SF 0 \"fp_arith_reg_operand\" \"f\")\n \t       (match_operand:SF 1 \"fp_arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH3E && ! TARGET_SH4\"\n+  \"TARGET_SH2E && ! TARGET_SH4\"\n   \"fcmp/gt\t%1,%0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -8336,7 +8339,7 @@\n   [(set (reg:SI T_REG)\n \t(eq:SI (match_operand:SF 0 \"fp_arith_reg_operand\" \"f\")\n \t       (match_operand:SF 1 \"fp_arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH3E && ! TARGET_SH4\"\n+  \"TARGET_SH2E && ! TARGET_SH4\"\n   \"fcmp/eq\t%1,%0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -8346,7 +8349,7 @@\n \t(ior:SI (reg:SI T_REG)\n \t\t(eq:SI (match_operand:SF 0 \"fp_arith_reg_operand\" \"f\")\n \t\t       (match_operand:SF 1 \"fp_arith_reg_operand\" \"f\"))))]\n-  \"TARGET_SH3E && TARGET_IEEE && ! TARGET_SH4\"\n+  \"TARGET_SH2E && TARGET_IEEE && ! TARGET_SH4\"\n   \"* return output_ieee_ccmpeq (insn, operands);\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -8418,7 +8421,7 @@\n   [(set (reg:SI T_REG)\n \t(compare (match_operand:SF 0 \"arith_operand\" \"\")\n \t\t (match_operand:SF 1 \"arith_operand\" \"\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n   sh_compare_op0 = operands[0];\n@@ -8429,10 +8432,10 @@\n (define_expand \"negsf2\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"\")\n \t(neg:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n-  if (TARGET_SH3E)\n+  if (TARGET_SH2E)\n     {\n       expand_sf_unop (&gen_negsf2_i, operands);\n       DONE;\n@@ -8450,7 +8453,7 @@\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n \t(neg:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"0\")))\n    (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH2E\"\n   \"fneg\t%0\"\n   [(set_attr \"type\" \"fmove\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -8487,10 +8490,10 @@\n (define_expand \"abssf2\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"\")\n \t(abs:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"\")))]\n-  \"TARGET_SH3E || TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n   \"\n {\n-  if (TARGET_SH3E)\n+  if (TARGET_SH2E)\n     {\n       expand_sf_unop (&gen_abssf2_i, operands);\n       DONE;\n@@ -8508,7 +8511,7 @@\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n \t(abs:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"0\")))\n    (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH2E\"\n   \"fabs\t%0\"\n   [(set_attr \"type\" \"fmove\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -9143,7 +9146,7 @@\n \t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n    (set (mem:SF (match_dup 0))\n \t(match_operand:SF 2 \"general_movsrc_operand\" \"\"))]\n-  \"TARGET_SH3E && REGNO (operands[0]) == 0\n+  \"TARGET_SH2E && REGNO (operands[0]) == 0\n    && ((GET_CODE (operands[2]) == REG\n         && FP_OR_XD_REGISTER_P (REGNO (operands[2])))\n        || (GET_CODE (operands[2]) == SUBREG\n@@ -9157,7 +9160,7 @@\n    (set (match_operand:SF 2 \"general_movdst_operand\" \"\")\n \n \t(mem:SF (match_dup 0)))]\n-  \"TARGET_SH3E && REGNO (operands[0]) == 0\n+  \"TARGET_SH2E && REGNO (operands[0]) == 0\n    && ((GET_CODE (operands[2]) == REG\n \t&& FP_OR_XD_REGISTER_P (REGNO (operands[2])))\n        || (GET_CODE (operands[2]) == SUBREG"}, {"sha": "1134350cf5e042d71da9cb143eb2a4aee374276e", "filename": "gcc/config/sh/sh64.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fsh64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Fsh64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh64.h?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler for SuperH SH 5.\n-   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva <aoliva@redhat.com>\n \n This file is part of GNU CC.\n@@ -35,7 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #define LINK_DEFAULT_CPU_EMUL \"32\"\n \n #undef TARGET_DEFAULT\n-#define TARGET_DEFAULT  (SH5_BIT|SH4_BIT|SH3E_BIT|TARGET_ENDIAN_DEFAULT)\n+#define TARGET_DEFAULT  (SH5_BIT|SH4_BIT|SH_E_BIT|TARGET_ENDIAN_DEFAULT)\n \n #undef SH_ELF_WCHAR_TYPE\n #define SH_ELF_WCHAR_TYPE \"int\""}, {"sha": "ee4db6639f9f09c041712e268a6f27266489e407", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -31,9 +31,9 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n MULTILIB_ENDIAN = ml\n-MULTILIB_OPTIONS= $(MULTILIB_ENDIAN) m2/m3e/m4-single-only/m4-single/m4\n+MULTILIB_OPTIONS= $(MULTILIB_ENDIAN) m2/m2e/m4-single-only/m4-single/m4\n MULTILIB_DIRNAMES= \n-MULTILIB_MATCHES = m2=m3 m2=m4-nofpu\n+MULTILIB_MATCHES = m2=m3 m2e=m3e m2=m4-nofpu\n MULTILIB_EXCEPTIONS = ml\n \n LIBGCC = stmp-multilib"}, {"sha": "ddcb9ff520a3eb4f27d8009125c4ca963f9be086", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a8699c7ab42ef0e974edaa2c02f3356613a449e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3a8699c7ab42ef0e974edaa2c02f3356613a449e", "patch": "@@ -557,7 +557,7 @@ in the following sections.\n \n @emph{SH Options}\n @gccoptlist{\n--m1  -m2  -m3  -m3e @gol\n+-m1  -m2  -m2e  -m3  -m3e @gol\n -m4-nofpu  -m4-single-only  -m4-single  -m4 @gol\n -m5-64media -m5-64media-nofpu @gol\n -m5-32media -m5-32media-nofpu @gol\n@@ -8793,6 +8793,9 @@ Generate code for the SH1.\n @opindex m2\n Generate code for the SH2.\n \n+@item -m2e\n+Generate code for the SH2e.\n+\n @item -m3\n @opindex m3\n Generate code for the SH3."}]}