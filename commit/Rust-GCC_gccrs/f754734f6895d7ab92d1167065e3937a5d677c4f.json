{"sha": "f754734f6895d7ab92d1167065e3937a5d677c4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc1NDczNGY2ODk1ZDdhYjkyZDExNjcwNjVlMzkzN2E1ZDY3N2M0Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-09-13T07:31:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-09-13T07:31:42Z"}, "message": "ira-color.c (conflict_allocno_vec): Delete.\n\ngcc/\n\t* ira-color.c (conflict_allocno_vec): Delete.\n\t(update_cost_queue_elem): New structure.\n\t(update_cost_queue): New variable.\n\t(update_cost_queue_tail): Likewise.\n\t(update_cost_queue_elems): Likewise.\n\t(allocno_update_cost_check): Delete.\n\t(initiate_cost_update): Allocate update_cost_queue_elems\n\tinstead of allocno_update_cost_check.\n\t(finish_cost_update): Update the free()s accordingly.\n\t(start_update_cost): New function.\n\t(queue_update_cost): Likewise.\n\t(get_next_update_cost): Likewise.\n\t(update_copy_costs_1): Inline into...\n\t(update_copy_costs): ...here.  Use a queue instead of recursive calls.\n\tUse cover_class instead of ALLOCNO_COVER_CLASS (another_allocno),\n\tonce we've established they are equal.  Don't allocate update\n\tcosts if there is nothing to add to them.\n\t(update_conflict_hard_regno_costs): Remove ALLOCNO and\n\tDIVISOR arguments.  Use a queue instead of recursive calls;\n\tprocess all the allocnos in the initial queue, rather than\n\ta single allocno.\n\t(assign_hard_reg): Use queue_update_cost instead of\n\tconflict_allocno_vec.  Queue coalesced allocnos instead\n\tof calling update_conflict_hard_regno_costs for each one.\n\tJust call update_conflict_hard_regno_costs once for the\n\tentire queue.\n\t(ira_color): Remove conflict_allocno_vec handling.\n\nFrom-SVN: r140335", "tree": {"sha": "4b26e4c12ebbf13245d6bd410c5c8a9b1c44f09a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b26e4c12ebbf13245d6bd410c5c8a9b1c44f09a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f754734f6895d7ab92d1167065e3937a5d677c4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f754734f6895d7ab92d1167065e3937a5d677c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f754734f6895d7ab92d1167065e3937a5d677c4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f754734f6895d7ab92d1167065e3937a5d677c4f/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29d7f40905677253de1cabb707ae78d9adde8178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d7f40905677253de1cabb707ae78d9adde8178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29d7f40905677253de1cabb707ae78d9adde8178"}], "stats": {"total": 386, "additions": 233, "deletions": 153}, "files": [{"sha": "d1da74af6c094485c2d1dcbfb684e8b2fb351931", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f754734f6895d7ab92d1167065e3937a5d677c4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f754734f6895d7ab92d1167065e3937a5d677c4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f754734f6895d7ab92d1167065e3937a5d677c4f", "patch": "@@ -1,3 +1,33 @@\n+2008-09-13  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* ira-color.c (conflict_allocno_vec): Delete.\n+\t(update_cost_queue_elem): New structure.\n+\t(update_cost_queue): New variable.\n+\t(update_cost_queue_tail): Likewise.\n+\t(update_cost_queue_elems): Likewise.\n+\t(allocno_update_cost_check): Delete.\n+\t(initiate_cost_update): Allocate update_cost_queue_elems\n+\tinstead of allocno_update_cost_check.\n+\t(finish_cost_update): Update the free()s accordingly.\n+\t(start_update_cost): New function.\n+\t(queue_update_cost): Likewise.\n+\t(get_next_update_cost): Likewise.\n+\t(update_copy_costs_1): Inline into...\n+\t(update_copy_costs): ...here.  Use a queue instead of recursive calls.\n+\tUse cover_class instead of ALLOCNO_COVER_CLASS (another_allocno),\n+\tonce we've established they are equal.  Don't allocate update\n+\tcosts if there is nothing to add to them.\n+\t(update_conflict_hard_regno_costs): Remove ALLOCNO and\n+\tDIVISOR arguments.  Use a queue instead of recursive calls;\n+\tprocess all the allocnos in the initial queue, rather than\n+\ta single allocno.\n+\t(assign_hard_reg): Use queue_update_cost instead of\n+\tconflict_allocno_vec.  Queue coalesced allocnos instead\n+\tof calling update_conflict_hard_regno_costs for each one.\n+\tJust call update_conflict_hard_regno_costs once for the\n+\tentire queue.\n+\t(ira_color): Remove conflict_allocno_vec handling.\n+\n 2008-09-12  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/37484"}, {"sha": "7319f2a803a64d34721210b6a7d6618c989416aa", "filename": "gcc/ira-color.c", "status": "modified", "additions": 203, "deletions": 153, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f754734f6895d7ab92d1167065e3937a5d677c4f/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f754734f6895d7ab92d1167065e3937a5d677c4f/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=f754734f6895d7ab92d1167065e3937a5d677c4f", "patch": "@@ -68,9 +68,6 @@ static ira_allocno_t *sorted_allocnos;\n /* Vec representing the stack of allocnos used during coloring.  */\n static VEC(ira_allocno_t,heap) *allocno_stack_vec;\n \n-/* Vec representing conflict allocnos used during assigning.  */\n-static VEC(ira_allocno_t,heap) *conflict_allocno_vec;\n-\n /* Array used to choose an allocno for spilling.  */\n static ira_allocno_t *allocnos_for_spilling;\n \n@@ -94,9 +91,31 @@ static VEC(ira_allocno_t,heap) *removed_splay_allocno_vec;\n    register was already allocated for an allocno.  */\n static bool allocated_hardreg_p[FIRST_PSEUDO_REGISTER];\n \n-/* Array used to check already processed allocnos during the current\n-   update_copy_costs call.  */\n-static int *allocno_update_cost_check;\n+/* Describes one element in a queue of allocnos whose costs need to be\n+   updated.  Each allocno in the queue is known to have a cover class.  */\n+struct update_cost_queue_elem {\n+  /* This element is in the queue iff CHECK == update_cost_check.  */\n+  int check;\n+\n+  /* COST_HOP_DIVISOR**N, where N is the length of the shortest path\n+     connecting this allocno to the one being allocated.  */\n+  int divisor;\n+\n+  /* The next allocno in the queue, or null if this is the last element.  */\n+  ira_allocno_t next;\n+};\n+\n+/* The first element in a queue of allocnos whose copy costs need to be\n+   updated.  Null if the queue is empty.  */\n+static ira_allocno_t update_cost_queue;\n+\n+/* The last element in the queue described by update_cost_queue.\n+   Not valid if update_cost_queue is null.  */\n+static struct update_cost_queue_elem *update_cost_queue_tail;\n+\n+/* A pool of elements in the queue described by update_cost_queue.\n+   Elements are indexed by ALLOCNO_NUM.  */\n+static struct update_cost_queue_elem *update_cost_queue_elems;\n \n /* The current value of update_copy_cost call count.  */\n static int update_cost_check;\n@@ -106,179 +125,217 @@ static int update_cost_check;\n static void\n initiate_cost_update (void)\n {\n-  allocno_update_cost_check\n-    = (int *) ira_allocate (ira_allocnos_num * sizeof (int));\n-  memset (allocno_update_cost_check, 0, ira_allocnos_num * sizeof (int));\n+  size_t size;\n+\n+  size = ira_allocnos_num * sizeof (struct update_cost_queue_elem);\n+  update_cost_queue_elems\n+    = (struct update_cost_queue_elem *) ira_allocate (size);\n+  memset (update_cost_queue_elems, 0, size);\n   update_cost_check = 0;\n }\n \n /* Deallocate data used by function update_copy_costs.  */\n static void\n finish_cost_update (void)\n {\n-  ira_free (allocno_update_cost_check);\n+  ira_free (update_cost_queue);\n }\n \n /* When we traverse allocnos to update hard register costs, the cost\n    divisor will be multiplied by the following macro value for each\n    hop from given allocno to directly connected allocnos.  */\n #define COST_HOP_DIVISOR 4\n \n-/* This recursive function updates costs (decrease if DECR_P) of the\n-   unassigned allocnos connected by copies with ALLOCNO.  This update\n-   increases chances to remove some copies.  Copy cost is proportional\n-   the copy frequency divided by DIVISOR.  */\n+/* Start a new cost-updating pass.  */\n static void\n-update_copy_costs_1 (ira_allocno_t allocno, int hard_regno,\n-\t\t     bool decr_p, int divisor)\n+start_update_cost (void)\n {\n-  int i, cost, update_cost;\n-  enum machine_mode mode;\n-  enum reg_class rclass, cover_class;\n-  ira_allocno_t another_allocno;\n-  ira_copy_t cp, next_cp;\n+  update_cost_check++;\n+  update_cost_queue = NULL;\n+}\n \n-  cover_class = ALLOCNO_COVER_CLASS (allocno);\n-  if (cover_class == NO_REGS)\n-    return;\n-  if (allocno_update_cost_check[ALLOCNO_NUM (allocno)] == update_cost_check)\n-    return;\n-  allocno_update_cost_check[ALLOCNO_NUM (allocno)] = update_cost_check;\n-  ira_assert (hard_regno >= 0);\n-  i = ira_class_hard_reg_index[cover_class][hard_regno];\n-  ira_assert (i >= 0);\n-  rclass = REGNO_REG_CLASS (hard_regno);\n-  mode = ALLOCNO_MODE (allocno);\n-  for (cp = ALLOCNO_COPIES (allocno); cp != NULL; cp = next_cp)\n+/* Add (ALLOCNO, DIVISOR) to the end of update_cost_queue,\n+   unless ALLOCNO is already in the queue, or has no cover class.  */\n+static inline void\n+queue_update_cost (ira_allocno_t allocno, int divisor)\n+{\n+  struct update_cost_queue_elem *elem;\n+\n+  elem = &update_cost_queue_elems[ALLOCNO_NUM (allocno)];\n+  if (elem->check != update_cost_check\n+      && ALLOCNO_COVER_CLASS (allocno) != NO_REGS)\n     {\n-      if (cp->first == allocno)\n-\t{\n-\t  next_cp = cp->next_first_allocno_copy;\n-\t  another_allocno = cp->second;\n-\t}\n-      else if (cp->second == allocno)\n-\t{\n-\t  next_cp = cp->next_second_allocno_copy;\n-\t  another_allocno = cp->first;\n-\t}\n+      elem->check = update_cost_check;\n+      elem->divisor = divisor;\n+      elem->next = NULL;\n+      if (update_cost_queue == NULL)\n+\tupdate_cost_queue = allocno;\n       else\n-\tgcc_unreachable ();\n-      if (cover_class\n-\t  != ALLOCNO_COVER_CLASS (another_allocno)\n-\t  || ALLOCNO_ASSIGNED_P (another_allocno))\n-\tcontinue;\n-      cost = (cp->second == allocno\n-\t      ? ira_register_move_cost[mode][rclass]\n-\t        [ALLOCNO_COVER_CLASS (another_allocno)]\n-\t      : ira_register_move_cost[mode]\n-\t        [ALLOCNO_COVER_CLASS (another_allocno)][rclass]);\n-      if (decr_p)\n-\tcost = -cost;\n-      ira_allocate_and_set_or_copy_costs\n-\t(&ALLOCNO_UPDATED_HARD_REG_COSTS (another_allocno), cover_class,\n-\t ALLOCNO_COVER_CLASS_COST (another_allocno),\n-\t ALLOCNO_HARD_REG_COSTS (another_allocno));\n-      ira_allocate_and_set_or_copy_costs\n-\t(&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n-\t cover_class, 0,\n-\t ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n-      update_cost = cp->freq * cost / divisor;\n-      ALLOCNO_UPDATED_HARD_REG_COSTS (another_allocno)[i] += update_cost;\n-      ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno)[i]\n-\t+= update_cost;\n-      if (update_cost != 0)\n-\tupdate_copy_costs_1 (another_allocno, hard_regno,\n-\t\t\t     decr_p, divisor * COST_HOP_DIVISOR);\n+\tupdate_cost_queue_tail->next = allocno;\n+      update_cost_queue_tail = elem;\n     }\n }\n \n-/* Update the cost of allocnos to increase chances to remove some\n-   copies as the result of subsequent assignment.  */\n-static void\n-update_copy_costs (ira_allocno_t allocno, bool decr_p)\n+/* Try to remove the first element from update_cost_queue.  Return false\n+   if the queue was empty, otherwise make (*ALLOCNO, *DIVISOR) describe\n+   the removed element.  */\n+static inline bool\n+get_next_update_cost (ira_allocno_t *allocno, int *divisor)\n {\n-  update_cost_check++;  \n-  update_copy_costs_1 (allocno, ALLOCNO_HARD_REGNO (allocno), decr_p, 1);\n+  struct update_cost_queue_elem *elem;\n+\n+  if (update_cost_queue == NULL)\n+    return false;\n+\n+  *allocno = update_cost_queue;\n+  elem = &update_cost_queue_elems[ALLOCNO_NUM (*allocno)];\n+  *divisor = elem->divisor;\n+  update_cost_queue = elem->next;\n+  return true;\n }\n \n-/* This recursive function updates COSTS (decrease if DECR_P) by\n-   conflict costs of the unassigned allocnos connected by copies with\n-   ALLOCNO.  This update increases chances to remove some copies.\n-   Copy cost is proportional to the copy frequency divided by\n-   DIVISOR.  */\n+/* Update the cost of allocnos to increase chances to remove some\n+   copies as the result of subsequent assignment.  */\n static void\n-update_conflict_hard_regno_costs (int *costs, ira_allocno_t allocno,\n-\t\t\t\t  int divisor, bool decr_p)\n+update_copy_costs (ira_allocno_t allocno, bool decr_p)\n {\n-  int i, cost, class_size, freq, mult, div;\n-  int *conflict_costs;\n-  bool cont_p;\n+  int i, cost, update_cost, hard_regno, divisor;\n   enum machine_mode mode;\n-  enum reg_class cover_class;\n+  enum reg_class rclass, cover_class;\n   ira_allocno_t another_allocno;\n   ira_copy_t cp, next_cp;\n \n+  hard_regno = ALLOCNO_HARD_REGNO (allocno);\n+  ira_assert (hard_regno >= 0);\n+\n   cover_class = ALLOCNO_COVER_CLASS (allocno);\n-  /* Probably 5 hops will be enough.  */\n-  if (divisor > (COST_HOP_DIVISOR * COST_HOP_DIVISOR\n-\t\t * COST_HOP_DIVISOR * COST_HOP_DIVISOR * COST_HOP_DIVISOR))\n-    return;\n   if (cover_class == NO_REGS)\n     return;\n-  /* Check that it was already visited.  */\n-  if (allocno_update_cost_check[ALLOCNO_NUM (allocno)] == update_cost_check)\n-    return;\n-  allocno_update_cost_check[ALLOCNO_NUM (allocno)] = update_cost_check;\n-  mode = ALLOCNO_MODE (allocno);\n-  class_size = ira_class_hard_regs_num[cover_class];\n-  for (cp = ALLOCNO_COPIES (allocno); cp != NULL; cp = next_cp)\n+  i = ira_class_hard_reg_index[cover_class][hard_regno];\n+  ira_assert (i >= 0);\n+  rclass = REGNO_REG_CLASS (hard_regno);\n+\n+  start_update_cost ();\n+  divisor = 1;\n+  do\n     {\n-      if (cp->first == allocno)\n-\t{\n-\t  next_cp = cp->next_first_allocno_copy;\n-\t  another_allocno = cp->second;\n-\t}\n-      else if (cp->second == allocno)\n-\t{\n-\t  next_cp = cp->next_second_allocno_copy;\n-\t  another_allocno = cp->first;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-      if (cover_class != ALLOCNO_COVER_CLASS (another_allocno)\n-\t  || ALLOCNO_ASSIGNED_P (another_allocno)\n-\t  || ALLOCNO_MAY_BE_SPILLED_P (another_allocno))\n-\tcontinue;\n-      ira_allocate_and_copy_costs\n-\t(&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n-\t cover_class, ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n-      conflict_costs\n-\t= ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno);\n-      if (conflict_costs == NULL)\n-\tcont_p = true;\n-      else\n+      mode = ALLOCNO_MODE (allocno);\n+      for (cp = ALLOCNO_COPIES (allocno); cp != NULL; cp = next_cp)\n \t{\n-\t  mult = cp->freq;\n-\t  freq = ALLOCNO_FREQ (another_allocno);\n-\t  if (freq == 0)\n-\t    freq = 1;\n-\t  div = freq * divisor;\n-\t  cont_p = false;\n-\t  for (i = class_size - 1; i >= 0; i--)\n+\t  if (cp->first == allocno)\n \t    {\n-\t      cost = conflict_costs [i] * mult / div;\n-\t      if (cost == 0)\n-\t\tcontinue;\n-\t      cont_p = true;\n-\t      if (decr_p)\n-\t\tcost = -cost;\n-\t      costs[i] += cost;\n+\t      next_cp = cp->next_first_allocno_copy;\n+\t      another_allocno = cp->second;\n+\t    }\n+\t  else if (cp->second == allocno)\n+\t    {\n+\t      next_cp = cp->next_second_allocno_copy;\n+\t      another_allocno = cp->first;\n \t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  if (cover_class != ALLOCNO_COVER_CLASS (another_allocno)\n+\t      || ALLOCNO_ASSIGNED_P (another_allocno))\n+\t    continue;\n+\n+\t  cost = (cp->second == allocno\n+\t\t  ? ira_register_move_cost[mode][rclass][cover_class]\n+\t\t  : ira_register_move_cost[mode][cover_class][rclass]);\n+\t  if (decr_p)\n+\t    cost = -cost;\n+\n+\t  update_cost = cp->freq * cost / divisor;\n+\t  if (update_cost == 0)\n+\t    continue;\n+\n+\t  ira_allocate_and_set_or_copy_costs\n+\t    (&ALLOCNO_UPDATED_HARD_REG_COSTS (another_allocno), cover_class,\n+\t     ALLOCNO_COVER_CLASS_COST (another_allocno),\n+\t     ALLOCNO_HARD_REG_COSTS (another_allocno));\n+\t  ira_allocate_and_set_or_copy_costs\n+\t    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n+\t     cover_class, 0,\n+\t     ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n+\t  ALLOCNO_UPDATED_HARD_REG_COSTS (another_allocno)[i] += update_cost;\n+\t  ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno)[i]\n+\t    += update_cost;\n+\n+\t  queue_update_cost (another_allocno, divisor * COST_HOP_DIVISOR);\n \t}\n-      if (cont_p)\n-\tupdate_conflict_hard_regno_costs (costs, another_allocno,\n-\t\t\t\t\t  divisor * COST_HOP_DIVISOR, decr_p);\n     }\n+  while (get_next_update_cost (&allocno, &divisor));\n+}\n+\n+/* This function updates COSTS (decrease if DECR_P) by conflict costs\n+   of the unassigned allocnos connected by copies with allocnos in\n+   update_cost_queue.  This update increases chances to remove some\n+   copies.  */\n+static void\n+update_conflict_hard_regno_costs (int *costs, bool decr_p)\n+{\n+  int i, cost, class_size, freq, mult, div, divisor;\n+  int *conflict_costs;\n+  bool cont_p;\n+  enum reg_class cover_class;\n+  ira_allocno_t allocno, another_allocno;\n+  ira_copy_t cp, next_cp;\n+\n+  while (get_next_update_cost (&allocno, &divisor))\n+    for (cp = ALLOCNO_COPIES (allocno); cp != NULL; cp = next_cp)\n+      {\n+\tif (cp->first == allocno)\n+\t  {\n+\t    next_cp = cp->next_first_allocno_copy;\n+\t    another_allocno = cp->second;\n+\t  }\n+\telse if (cp->second == allocno)\n+\t  {\n+\t    next_cp = cp->next_second_allocno_copy;\n+\t    another_allocno = cp->first;\n+\t  }\n+\telse\n+\t  gcc_unreachable ();\n+\tcover_class = ALLOCNO_COVER_CLASS (allocno);\n+\tif (cover_class != ALLOCNO_COVER_CLASS (another_allocno)\n+\t    || ALLOCNO_ASSIGNED_P (another_allocno)\n+\t    || ALLOCNO_MAY_BE_SPILLED_P (another_allocno))\n+\t  continue;\n+\tclass_size = ira_class_hard_regs_num[cover_class];\n+\tira_allocate_and_copy_costs\n+\t  (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n+\t   cover_class, ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n+\tconflict_costs\n+\t  = ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno);\n+\tif (conflict_costs == NULL)\n+\t  cont_p = true;\n+\telse\n+\t  {\n+\t    mult = cp->freq;\n+\t    freq = ALLOCNO_FREQ (another_allocno);\n+\t    if (freq == 0)\n+\t      freq = 1;\n+\t    div = freq * divisor;\n+\t    cont_p = false;\n+\t    for (i = class_size - 1; i >= 0; i--)\n+\t      {\n+\t\tcost = conflict_costs [i] * mult / div;\n+\t\tif (cost == 0)\n+\t\t  continue;\n+\t\tcont_p = true;\n+\t\tif (decr_p)\n+\t\t  cost = -cost;\n+\t\tcosts[i] += cost;\n+\t      }\n+\t  }\n+\t/* Probably 5 hops will be enough.  */\n+\tif (cont_p\n+\t    && divisor <= (COST_HOP_DIVISOR\n+\t\t\t   * COST_HOP_DIVISOR\n+\t\t\t   * COST_HOP_DIVISOR\n+\t\t\t   * COST_HOP_DIVISOR))\n+\t  queue_update_cost (another_allocno, divisor * COST_HOP_DIVISOR);\n+      }\n }\n \n /* Sort allocnos according to the profit of usage of a hard register\n@@ -355,6 +412,7 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n #ifdef STACK_REGS\n   no_stack_reg_p = false;\n #endif\n+  start_update_cost ();\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n@@ -419,33 +477,27 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n \t\tif (conflict_costs != NULL)\n \t\t  for (j = class_size - 1; j >= 0; j--)\n \t\t    full_costs[j] -= conflict_costs[j];\n-\t\tVEC_safe_push (ira_allocno_t, heap, conflict_allocno_vec,\n-\t\t\t       conflict_allocno);\n+\t\tqueue_update_cost (conflict_allocno, COST_HOP_DIVISOR);\n \t      }\n \t  }\n       if (a == allocno)\n \tbreak;\n     }\n   /* Take into account preferences of allocnos connected by copies to\n      the conflict allocnos.  */\n-  update_cost_check++;\n-  while (VEC_length (ira_allocno_t, conflict_allocno_vec) != 0)\n-    {\n-      conflict_allocno = VEC_pop (ira_allocno_t, conflict_allocno_vec);\n-      update_conflict_hard_regno_costs (full_costs, conflict_allocno,\n-\t\t\t\t\tCOST_HOP_DIVISOR, true);\n-    }\n-  update_cost_check++;\n+  update_conflict_hard_regno_costs (full_costs, true);\n+\n   /* Take preferences of allocnos connected by copies into\n      account.  */\n+  start_update_cost ();\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      update_conflict_hard_regno_costs (full_costs, a,\n-\t\t\t\t\tCOST_HOP_DIVISOR, false);\n+      queue_update_cost (a, COST_HOP_DIVISOR);\n       if (a == allocno)\n \tbreak;\n     }\n+  update_conflict_hard_regno_costs (full_costs, false);\n   min_cost = min_full_cost = INT_MAX;\n   /* We don't care about giving callee saved registers to allocnos no\n      living through calls because call clobbered registers are\n@@ -2926,15 +2978,13 @@ void\n ira_color (void)\n {\n   allocno_stack_vec = VEC_alloc (ira_allocno_t, heap, ira_allocnos_num);\n-  conflict_allocno_vec = VEC_alloc (ira_allocno_t, heap, ira_allocnos_num);\n   removed_splay_allocno_vec\n     = VEC_alloc (ira_allocno_t, heap, ira_allocnos_num);\n   memset (allocated_hardreg_p, 0, sizeof (allocated_hardreg_p));\n   ira_initiate_assign ();\n   do_coloring ();\n   ira_finish_assign ();\n   VEC_free (ira_allocno_t, heap, removed_splay_allocno_vec);\n-  VEC_free (ira_allocno_t, heap, conflict_allocno_vec);\n   VEC_free (ira_allocno_t, heap, allocno_stack_vec);\n   move_spill_restore ();\n }"}]}