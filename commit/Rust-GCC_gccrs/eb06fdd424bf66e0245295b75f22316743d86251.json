{"sha": "eb06fdd424bf66e0245295b75f22316743d86251", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIwNmZkZDQyNGJmNjZlMDI0NTI5NWI3NWYyMjMxNjc0M2Q4NjI1MQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-01-29T20:12:24Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-01-29T20:12:24Z"}, "message": "analyzer: consolidate conditionals in paths\n\nThis patch adds a simplification to analyzer paths for\nrepeated CFG edges generated from compound conditionals.\nFor example, it simplifies:\n\n    |    5 |   if (a && b && c)\n    |      |      ^~~~~~~~~~~~\n    |      |      |  |    |\n    |      |      |  |    (4) ...to here\n    |      |      |  |    (5) following \u2018true\u2019 branch (when \u2018c != 0\u2019)...\n    |      |      |  (2) ...to here\n    |      |      |  (3) following \u2018true\u2019 branch (when \u2018b != 0\u2019)...\n    |      |      (1) following \u2018true\u2019 branch (when \u2018a != 0\u2019)...\n    |    6 |     __analyzer_dump_path ();\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (6) ...to here\n\nto:\n\n    |    5 |   if (a && b && c)\n    |      |      ^\n    |      |      |\n    |      |      (1) following \u2018true\u2019 branch...\n    |    6 |     __analyzer_dump_path ();\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) ...to here\n\ngcc/analyzer/ChangeLog:\n\t* checker-path.cc (event_kind_to_string): Handle\n\tEK_START_CONSOLIDATED_CFG_EDGES and\n\tEK_END_CONSOLIDATED_CFG_EDGES.\n\t(start_consolidated_cfg_edges_event::get_desc): New.\n\t(checker_path::cfg_edge_pair_at_p): New.\n\t* checker-path.h (enum event_kind): Add\n\tEK_START_CONSOLIDATED_CFG_EDGES and\n\tEK_END_CONSOLIDATED_CFG_EDGES.\n\t(class start_consolidated_cfg_edges_event): New class.\n\t(class end_consolidated_cfg_edges_event): New class.\n\t(checker_path::delete_events): New.\n\t(checker_path::replace_event): New.\n\t(checker_path::cfg_edge_pair_at_p): New decl.\n\t* diagnostic-manager.cc (diagnostic_manager::prune_path): Call\n\tconsolidate_conditions.\n\t(same_line_as_p): New.\n\t(diagnostic_manager::consolidate_conditions): New.\n\t* diagnostic-manager.h\n\t(diagnostic_manager::consolidate_conditions): New decl.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/combined-conditionals-1.c: New test.", "tree": {"sha": "3a06559e68cbf2a5ddd0e08cdeaaf5156fa9f20a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a06559e68cbf2a5ddd0e08cdeaaf5156fa9f20a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb06fdd424bf66e0245295b75f22316743d86251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb06fdd424bf66e0245295b75f22316743d86251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb06fdd424bf66e0245295b75f22316743d86251", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb06fdd424bf66e0245295b75f22316743d86251/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9f83ef300e8734dccb90a7c347997b2787e9e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f9f83ef300e8734dccb90a7c347997b2787e9e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f9f83ef300e8734dccb90a7c347997b2787e9e9"}], "stats": {"total": 283, "additions": 283, "deletions": 0}, "files": [{"sha": "e6e3ec18688ca0b4f5879049f1d2860bd88916a8", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=eb06fdd424bf66e0245295b75f22316743d86251", "patch": "@@ -93,6 +93,10 @@ event_kind_to_string (enum event_kind ek)\n       return \"EK_CALL_EDGE\";\n     case EK_RETURN_EDGE:\n       return \"EK_RETURN_EDGE\";\n+    case EK_START_CONSOLIDATED_CFG_EDGES:\n+      return \"EK_START_CONSOLIDATED_CFG_EDGES\";\n+    case EK_END_CONSOLIDATED_CFG_EDGES:\n+      return \"EK_END_CONSOLIDATED_CFG_EDGES\";\n     case EK_SETJMP:\n       return \"EK_SETJMP\";\n     case EK_REWIND_FROM_LONGJMP:\n@@ -709,6 +713,16 @@ return_event::is_return_p () const\n   return true;\n }\n \n+/* class start_consolidated_cfg_edges_event : public checker_event.  */\n+\n+label_text\n+start_consolidated_cfg_edges_event::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize,\n+\t\t\t  \"following %qs branch...\",\n+\t\t\t  m_edge_sense ? \"true\" : \"false\");\n+}\n+\n /* class setjmp_event : public checker_event.  */\n \n /* Implementation of diagnostic_event::get_desc vfunc for\n@@ -991,6 +1005,18 @@ checker_path::fixup_locations (pending_diagnostic *pd)\n     e->set_location (pd->fixup_location (e->get_location ()));\n }\n \n+/* Return true if there is a (start_cfg_edge_event, end_cfg_edge_event) pair\n+   at (IDX, IDX + 1).  */\n+\n+bool\n+checker_path::cfg_edge_pair_at_p (unsigned idx) const\n+{\n+  if (m_events.length () < idx + 1)\n+    return false;\n+  return (m_events[idx]->m_kind == EK_START_CFG_EDGE\n+\t  && m_events[idx + 1]->m_kind == EK_END_CFG_EDGE);\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "f76bb94e7cccb3a635d7cc35e9fd94ef8baf1490", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=eb06fdd424bf66e0245295b75f22316743d86251", "patch": "@@ -37,6 +37,8 @@ enum event_kind\n   EK_END_CFG_EDGE,\n   EK_CALL_EDGE,\n   EK_RETURN_EDGE,\n+  EK_START_CONSOLIDATED_CFG_EDGES,\n+  EK_END_CONSOLIDATED_CFG_EDGES,\n   EK_SETJMP,\n   EK_REWIND_FROM_LONGJMP,\n   EK_REWIND_TO_SETJMP,\n@@ -63,6 +65,8 @@ extern const char *event_kind_to_string (enum event_kind ek);\n \t   end_cfg_edge_event (EK_END_CFG_EDGE)\n          call_event (EK_CALL_EDGE)\n          return_edge (EK_RETURN_EDGE)\n+       start_consolidated_cfg_edges_event (EK_START_CONSOLIDATED_CFG_EDGES)\n+       end_consolidated_cfg_edges_event (EK_END_CONSOLIDATED_CFG_EDGES)\n        setjmp_event (EK_SETJMP)\n        rewind_event\n          rewind_from_longjmp_event (EK_REWIND_FROM_LONGJMP)\n@@ -337,6 +341,42 @@ class return_event : public superedge_event\n   bool is_return_p () const FINAL OVERRIDE;\n };\n \n+/* A concrete event subclass for the start of a consolidated run of CFG\n+   edges all either TRUE or FALSE e.g. \"following 'false' branch...'.  */\n+\n+class start_consolidated_cfg_edges_event : public checker_event\n+{\n+public:\n+  start_consolidated_cfg_edges_event (location_t loc, tree fndecl, int depth,\n+\t\t\t\t      bool edge_sense)\n+  : checker_event (EK_START_CONSOLIDATED_CFG_EDGES, loc, fndecl, depth),\n+    m_edge_sense (edge_sense)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+ private:\n+  bool m_edge_sense;\n+};\n+\n+/* A concrete event subclass for the end of a consolidated run of\n+   CFG edges e.g. \"...to here'.  */\n+\n+class end_consolidated_cfg_edges_event : public checker_event\n+{\n+public:\n+  end_consolidated_cfg_edges_event (location_t loc, tree fndecl, int depth)\n+  : checker_event (EK_END_CONSOLIDATED_CFG_EDGES, loc, fndecl, depth)\n+  {\n+  }\n+\n+  label_text get_desc (bool /*can_colorize*/) const FINAL OVERRIDE\n+  {\n+    return label_text::borrow (\"...to here\");\n+  }\n+};\n+\n /* A concrete event subclass for a setjmp or sigsetjmp call.  */\n \n class setjmp_event : public checker_event\n@@ -490,6 +530,19 @@ class checker_path : public diagnostic_path\n     delete event;\n   }\n \n+  void delete_events (unsigned start_idx, unsigned len)\n+  {\n+    for (unsigned i = start_idx; i < start_idx + len; i++)\n+      delete m_events[i];\n+    m_events.block_remove (start_idx, len);\n+  }\n+\n+  void replace_event (unsigned idx, checker_event *new_event)\n+  {\n+    delete m_events[idx];\n+    m_events[idx] = new_event;\n+  }\n+\n   void add_final_event (const state_machine *sm,\n \t\t\tconst exploded_node *enode, const gimple *stmt,\n \t\t\ttree var, state_machine::state_t state);\n@@ -525,6 +578,8 @@ class checker_path : public diagnostic_path\n     return false;\n   }\n \n+  bool cfg_edge_pair_at_p (unsigned idx) const;\n+\n private:\n   DISABLE_COPY_AND_ASSIGN(checker_path);\n "}, {"sha": "cbb76d89e0d19b3cb09459fdf9ac5bb2972fda4d", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=eb06fdd424bf66e0245295b75f22316743d86251", "patch": "@@ -1301,6 +1301,7 @@ diagnostic_manager::prune_path (checker_path *path,\n   path->maybe_log (get_logger (), \"path\");\n   prune_for_sm_diagnostic (path, sm, sval, state);\n   prune_interproc_events (path);\n+  consolidate_conditions (path);\n   finish_pruning (path);\n   path->maybe_log (get_logger (), \"pruned\");\n }\n@@ -1656,6 +1657,151 @@ diagnostic_manager::prune_interproc_events (checker_path *path) const\n   while (changed);\n }\n \n+/* Return true iff event IDX within PATH is on the same line as REF_EXP_LOC.  */\n+\n+static bool\n+same_line_as_p (const expanded_location &ref_exp_loc,\n+\t\tchecker_path *path, unsigned idx)\n+{\n+  const checker_event *ev = path->get_checker_event (idx);\n+  expanded_location idx_exp_loc = expand_location (ev->get_location ());\n+  gcc_assert (ref_exp_loc.file);\n+  if (idx_exp_loc.file == NULL)\n+    return false;\n+  if (strcmp (ref_exp_loc.file, idx_exp_loc.file))\n+    return false;\n+  return ref_exp_loc.line == idx_exp_loc.line;\n+}\n+\n+/* This path-readability optimization reduces the verbosity of compound\n+   conditional statements (without needing to reconstruct the AST, which\n+   has already been lost).\n+\n+   For example, it converts:\n+\n+    |   61 |   if (cp[0] != '\\0' && cp[0] != '#')\n+    |      |      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+    |      |      |              |    |\n+    |      |      |              |    (6) ...to here\n+    |      |      |              (7) following \u2018true\u2019 branch...\n+    |      |      (5) following \u2018true\u2019 branch...\n+    |   62 |     {\n+    |   63 |       alias = cp++;\n+    |      |               ~~~~\n+    |      |                 |\n+    |      |                 (8) ...to here\n+\n+   into:\n+\n+    |   61 |   if (cp[0] != '\\0' && cp[0] != '#')\n+    |      |      ~\n+    |      |      |\n+    |      |      (5) following \u2018true\u2019 branch...\n+    |   62 |     {\n+    |   63 |       alias = cp++;\n+    |      |               ~~~~\n+    |      |                 |\n+    |      |                 (6) ...to here\n+\n+   by combining events 5-8 into new events 5-6.\n+\n+   Find runs of consecutive (start_cfg_edge_event, end_cfg_edge_event) pairs\n+   in which all events apart from the final end_cfg_edge_event are on the same\n+   line, and for which either all the CFG edges are TRUE edges, or all are\n+   FALSE edges.\n+\n+   Consolidate each such run into a\n+     (start_consolidated_cfg_edges_event, end_consolidated_cfg_edges_event)\n+   pair.  */\n+\n+void\n+diagnostic_manager::consolidate_conditions (checker_path *path) const\n+{\n+  /* Don't simplify edges if we're debugging them.  */\n+  if (flag_analyzer_verbose_edges)\n+    return;\n+\n+  for (unsigned start_idx = 0; start_idx < path->num_events () - 1; start_idx++)\n+    {\n+      if (path->cfg_edge_pair_at_p (start_idx))\n+\t{\n+\t  const checker_event *old_start_ev\n+\t    = path->get_checker_event (start_idx);\n+\t  expanded_location start_exp_loc\n+\t    = expand_location (old_start_ev->get_location ());\n+\t  if (start_exp_loc.file == NULL)\n+\t    continue;\n+\t  if (!same_line_as_p (start_exp_loc, path, start_idx + 1))\n+\t    continue;\n+\n+\t  /* Are we looking for a run of all TRUE edges, or all FALSE edges?  */\n+\t  gcc_assert (old_start_ev->m_kind == EK_START_CFG_EDGE);\n+\t  const start_cfg_edge_event *old_start_cfg_ev\n+\t    = (const start_cfg_edge_event *)old_start_ev;\n+\t  const cfg_superedge& first_cfg_sedge\n+\t    = old_start_cfg_ev->get_cfg_superedge ();\n+\t  bool edge_sense;\n+\t  if (first_cfg_sedge.true_value_p ())\n+\t    edge_sense = true;\n+\t  else if (first_cfg_sedge.false_value_p ())\n+\t    edge_sense = false;\n+\t  else\n+\t    continue;\n+\n+\t  /* Find a run of CFG start/end event pairs from\n+\t       [start_idx, next_idx)\n+\t     where all apart from the final event are on the same line,\n+\t     and all are either TRUE or FALSE edges, matching the initial.  */\n+\t  unsigned next_idx = start_idx + 2;\n+\t  while (path->cfg_edge_pair_at_p (next_idx)\n+\t\t && same_line_as_p (start_exp_loc, path, next_idx))\n+\t    {\n+\t      const checker_event *iter_ev\n+\t\t= path->get_checker_event (next_idx);\n+\t      gcc_assert (iter_ev->m_kind == EK_START_CFG_EDGE);\n+\t      const start_cfg_edge_event *iter_cfg_ev\n+\t\t= (const start_cfg_edge_event *)iter_ev;\n+\t      const cfg_superedge& iter_cfg_sedge\n+\t\t= iter_cfg_ev->get_cfg_superedge ();\n+\t      if (edge_sense)\n+\t\t{\n+\t\t  if (!iter_cfg_sedge.true_value_p ())\n+\t\t    break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (!iter_cfg_sedge.false_value_p ())\n+\t\t    break;\n+\t\t}\n+\t      next_idx += 2;\n+\t    }\n+\n+\t  /* If we have more than one pair in the run, consolidate.  */\n+\t  if (next_idx > start_idx + 2)\n+\t    {\n+\t      const checker_event *old_end_ev\n+\t\t= path->get_checker_event (next_idx - 1);\n+\t      log (\"consolidating CFG edge events %i-%i into %i-%i\",\n+\t\t   start_idx, next_idx - 1, start_idx, start_idx +1);\n+\t      start_consolidated_cfg_edges_event *new_start_ev\n+\t\t= new start_consolidated_cfg_edges_event\n+\t\t(old_start_ev->get_location (),\n+\t\t old_start_ev->get_fndecl (),\n+\t\t old_start_ev->get_stack_depth (),\n+\t\t edge_sense);\n+\t      checker_event *new_end_ev\n+\t\t= new end_consolidated_cfg_edges_event\n+\t\t(old_end_ev->get_location (),\n+\t\t old_end_ev->get_fndecl (),\n+\t\t old_end_ev->get_stack_depth ());\n+\t      path->replace_event (start_idx, new_start_ev);\n+\t      path->replace_event (start_idx + 1, new_end_ev);\n+\t      path->delete_events (start_idx + 2, next_idx - (start_idx + 2));\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Final pass of diagnostic_manager::prune_path.\n \n    If all we're left with is in one function, then filter function entry"}, {"sha": "9fb952b422848d1f527c7dbcb6eb0863a6984d85", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=eb06fdd424bf66e0245295b75f22316743d86251", "patch": "@@ -175,6 +175,7 @@ class diagnostic_manager : public log_user\n \t\t\t\tstate_machine::state_t state) const;\n   void update_for_unsuitable_sm_exprs (tree *expr) const;\n   void prune_interproc_events (checker_path *path) const;\n+  void consolidate_conditions (checker_path *path) const;\n   void finish_pruning (checker_path *path) const;\n \n   engine *m_eng;"}, {"sha": "caac2678bf3c0ecb9b7f68ae2953765389152484", "filename": "gcc/testsuite/gcc.dg/analyzer/combined-conditionals-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcombined-conditionals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb06fdd424bf66e0245295b75f22316743d86251/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcombined-conditionals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcombined-conditionals-1.c?ref=eb06fdd424bf66e0245295b75f22316743d86251", "patch": "@@ -0,0 +1,55 @@\n+/* Verify that we correctly consolidate conditionals in paths.  */\n+\n+#include \"analyzer-decls.h\"\n+\n+extern int foo ();\n+extern int bar ();\n+extern int baz ();\n+\n+void test_1 (int a, int b, int c)\n+{\n+  if (a && b && c) /* { dg-message \"\\\\(1\\\\) following 'true' branch\\\\.\\\\.\\\\.\" } */\n+    __analyzer_dump_path (); /* { dg-message \"\\\\(2\\\\) \\\\.\\\\.\\\\.to here\" } */\n+}\n+\n+void test_2 (int a, int b, int c)\n+{\n+  if (a && b) /* { dg-message \"\\\\(1\\\\) following 'true' branch\\\\.\\\\.\\\\.\" } */\n+    if (c) /* { dg-message \"\\\\(2\\\\) \\\\.\\\\.\\\\.to here\" } */\n+      __analyzer_dump_path ();\n+}\n+\n+void test_3 (int a, int b, int c)\n+{\n+  if (a) /* { dg-message \"\\\\(1\\\\) following 'true' branch\" } */\n+    if (b && c) /* { dg-message \"\\\\(2\\\\) \\\\.\\\\.\\\\.to here\" } */\n+      __analyzer_dump_path ();\n+}\n+\n+void test_4 (void)\n+{\n+  while (foo () && bar ()) /* { dg-message \"\\\\(1\\\\) following 'true' branch\\\\.\\\\.\\\\.\" } */\n+    __analyzer_dump_path (); /* { dg-message \"\\\\(2\\\\) \\\\.\\\\.\\\\.to here\" } */\n+}\n+\n+void test_5 (int a, int b, int c)\n+{\n+  if (a || b || c) /* { dg-message \"\\\\(1\\\\) following 'false' branch\\\\.\\\\.\\\\.\" } */\n+    {\n+    }\n+  else\n+    __analyzer_dump_path (); /* { dg-message \"\\\\(2\\\\) \\\\.\\\\.\\\\.to here\" } */\n+}\n+\n+void test_6 (void)\n+{\n+  int i;\n+  for (i = 0; i < 10 && foo (); i++) /* { dg-message \"\\\\(1\\\\) following 'true' branch\\\\.\\\\.\\\\.\" } */\n+    __analyzer_dump_path (); /* { dg-message \"\\\\(2\\\\) \\\\.\\\\.\\\\.to here\" } */\n+}\n+\n+int test_7 (void)\n+{\n+  if (foo () ? bar () ? baz () : 0 : 0) /* { dg-message \"\\\\(1\\\\) following 'true' branch\\\\.\\\\.\\\\.\" } */\n+    __analyzer_dump_path (); /* { dg-message \"\\\\(2\\\\) \\\\.\\\\.\\\\.to here\" } */    \n+}"}]}