{"sha": "30442c59aa4fff0ca2b3a2d186510f95367836ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA0NDJjNTlhYTRmZmYwY2EyYjNhMmQxODY1MTBmOTUzNjc4MzZlZg==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2010-12-10T01:31:08Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2010-12-10T01:31:08Z"}, "message": "pdp11-protos.h (output_move_double, [...]): Delete.\n\n* config/pdp11/pdp11-protos.h (output_move_double,\noutput_move_quad): Delete.\n(output_move_multiple, pdp11_expand_operands): New functions.\n(pdp11_action, pdp11_partorder): New enums.\n* config/pdp11/pdp11.md (movdi, movsi, movdf, movsf): Use\noutput_move_multiple.\n(adddi3, subdi3, negdi2): New patterns.\n(addsi3, subsi3, negsi2): Use pdp11_expand_operands.\n(abshi2): Delete.\n(neghi2, negqi2): Use PDPint iterator.\n* config/pdp11/pdp11.c (find_addr_reg, output_move_double,\noutput_move_quad): Delete. \n(pdp11_expand_operands, output_move_multiple): New functions.\n\nFrom-SVN: r167676", "tree": {"sha": "eb921c80643da0d30831fd0a272038eead6aaba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb921c80643da0d30831fd0a272038eead6aaba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30442c59aa4fff0ca2b3a2d186510f95367836ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30442c59aa4fff0ca2b3a2d186510f95367836ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30442c59aa4fff0ca2b3a2d186510f95367836ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30442c59aa4fff0ca2b3a2d186510f95367836ef/comments", "author": null, "committer": null, "parents": [{"sha": "a23980bdb62645c6adbf6ba7a18a825e2c08c5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a23980bdb62645c6adbf6ba7a18a825e2c08c5d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a23980bdb62645c6adbf6ba7a18a825e2c08c5d0"}], "stats": {"total": 883, "additions": 360, "deletions": 523}, "files": [{"sha": "988dd2e7660c3103d4887d600acec706130435e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30442c59aa4fff0ca2b3a2d186510f95367836ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30442c59aa4fff0ca2b3a2d186510f95367836ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30442c59aa4fff0ca2b3a2d186510f95367836ef", "patch": "@@ -1,3 +1,19 @@\n+2010-12-09  Paul Koning  <ni1d@arrl.net>\n+\n+\t* config/pdp11/pdp11-protos.h (output_move_double,\n+\toutput_move_quad): Delete.\n+\t(output_move_multiple, pdp11_expand_operands): New functions.\n+\t(pdp11_action, pdp11_partorder): New enums.\n+\t* config/pdp11/pdp11.md (movdi, movsi, movdf, movsf): Use\n+\toutput_move_multiple.\n+\t(adddi3, subdi3, negdi2): New patterns.\n+\t(addsi3, subsi3, negsi2): Use pdp11_expand_operands.\n+\t(abshi2): Delete.\n+\t(neghi2, negqi2): Use PDPint iterator.\n+\t* config/pdp11/pdp11.c (find_addr_reg, output_move_double,\n+\toutput_move_quad): Delete. \n+\t(pdp11_expand_operands, output_move_multiple): New functions.\n+\t\n 2010-12-09  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/vax/linux.h (WCHAR_TYPE, WCHAR_TYPE_SIZE): Define."}, {"sha": "09ba7b21e662dee2b21cccea4e74407d1212e53d", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30442c59aa4fff0ca2b3a2d186510f95367836ef/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30442c59aa4fff0ca2b3a2d186510f95367836ef/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=30442c59aa4fff0ca2b3a2d186510f95367836ef", "patch": "@@ -26,15 +26,18 @@ extern int simple_memory_operand (rtx, enum machine_mode);\n extern int legitimate_const_double_p (rtx);\n extern void notice_update_cc_on_set (rtx, rtx);\n extern void output_addr_const_pdp11 (FILE *, rtx);\n-extern const char *output_move_double (rtx *);\n-extern const char *output_move_quad (rtx *);\n+extern const char *output_move_multiple (rtx *);\n extern const char *output_block_move (rtx *);\n extern const char *output_jump (enum rtx_code, int, int);\n extern void print_operand_address (FILE *, rtx);\n extern bool pdp11_cannot_change_mode_class (enum machine_mode,\n                                             enum machine_mode, enum reg_class);\n extern bool pdp11_secondary_memory_needed (reg_class_t, reg_class_t, \n \t\t\t\t\t   enum machine_mode);\n+typedef enum { no_action, dec_before, inc_after } pdp11_action;\n+typedef enum { little, either, big } pdp11_partorder;\n+extern bool pdp11_expand_operands (rtx *, rtx [][2], int, \n+\t\t\t\t   pdp11_action *, pdp11_partorder);\n extern int pdp11_initial_elimination_offset (int, int);\n extern enum reg_class pdp11_regno_reg_class (int);\n "}, {"sha": "fedb22a12d4697739b9e86ce0dd99eb71e9cf136", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 180, "deletions": 373, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30442c59aa4fff0ca2b3a2d186510f95367836ef/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30442c59aa4fff0ca2b3a2d186510f95367836ef/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=30442c59aa4fff0ca2b3a2d186510f95367836ef", "patch": "@@ -140,7 +140,6 @@ decode_pdp11_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n static bool pdp11_handle_option (size_t, const char *, int);\n static void pdp11_option_init_struct (struct gcc_options *);\n-static rtx find_addr_reg (rtx); \n static const char *singlemove_string (rtx *);\n static bool pdp11_assemble_integer (rtx, unsigned int, int);\n static void pdp11_output_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -236,7 +235,6 @@ static const struct default_options pdp11_option_optimization_table[] =\n \n #undef  TARGET_ASM_FUNCTION_SECTION\n #define TARGET_ASM_FUNCTION_SECTION pdp11_function_section\n-\n \f\n /* Implement TARGET_HANDLE_OPTION.  */\n \n@@ -483,408 +481,216 @@ singlemove_string (rtx *operands)\n }\n \n \f\n-/* Output assembler code to perform a doubleword move insn\n-   with operands OPERANDS.  */\n-\n-const char *\n-output_move_double (rtx *operands)\n+/* Expand multi-word operands (SImode or DImode) into the 2 or 4\n+   corresponding HImode operands.  The number of operands is given\n+   as the third argument, and the required order of the parts as\n+   the fourth argument.  */\n+bool\n+pdp11_expand_operands (rtx *operands, rtx exops[][2], int opcount, \n+\t\t       pdp11_action *action, pdp11_partorder order)\n {\n-  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n-  rtx latehalf[2];\n-  rtx addreg0 = 0, addreg1 = 0;\n-\n-  /* First classify both operands.  */\n-\n-  if (REG_P (operands[0]))\n-    optype0 = REGOP;\n-  else if (offsettable_memref_p (operands[0]))\n-    optype0 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    optype0 = POPOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    optype0 = PUSHOP;\n-  else if (GET_CODE (operands[0]) == MEM)\n-    optype0 = MEMOP;\n-  else\n-    optype0 = RNDOP;\n-\n-  if (REG_P (operands[1]))\n-    optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1])\n-#if 0\n-\t   || GET_CODE (operands[1]) == CONST_DOUBLE\n-#endif\n-\t   )\n-    optype1 = CNSTOP;\n-  else if (offsettable_memref_p (operands[1]))\n-    optype1 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n-    optype1 = POPOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n-    optype1 = PUSHOP;\n-  else if (GET_CODE (operands[1]) == MEM)\n-    optype1 = MEMOP;\n-  else\n-    optype1 = RNDOP;\n-\n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n-\n-  gcc_assert (optype0 != RNDOP && optype1 != RNDOP);\n-\n-  /* If one operand is decrementing and one is incrementing\n-     decrement the former register explicitly\n-     and change that operand into ordinary indexing.  */\n-\n-  if (optype0 == PUSHOP && optype1 == POPOP)\n-    {\n-      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      output_asm_insn (\"sub $4,%0\", operands);\n-      operands[0] = gen_rtx_MEM (SImode, operands[0]);\n-      optype0 = OFFSOP;\n-    }\n-  if (optype0 == POPOP && optype1 == PUSHOP)\n+  int words, op, w, i, sh;\n+  pdp11_partorder useorder;\n+  bool sameoff = false;\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype;\n+  REAL_VALUE_TYPE r;\n+  long sval[2];\n+  \n+  words = GET_MODE_BITSIZE (GET_MODE (operands[0])) / 16;\n+  \n+  /* If either piece order is accepted and one is pre-decrement\n+     while the other is post-increment, set order to be high order\n+     word first.  That will force the pre-decrement to be turned\n+     into a pointer adjust, then offset addressing.\n+     Otherwise, if either operand uses pre-decrement, that means\n+     the order is low order first. \n+     Otherwise, if both operands are registers and destination is\n+     higher than source and they overlap, do low order word (highest\n+     register number) first.  */\n+  useorder = either;\n+  if (opcount == 2)\n     {\n-      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-      output_asm_insn (\"sub $4,%1\", operands);\n-      operands[1] = gen_rtx_MEM (SImode, operands[1]);\n-      optype1 = OFFSOP;\n+      if (!REG_P (operands[0]) && !REG_P (operands[1]) &&\n+\t  !(CONSTANT_P (operands[1]) || \n+\t    GET_CODE (operands[1]) == CONST_DOUBLE) &&\n+\t  ((GET_CODE (XEXP (operands[0], 0)) == POST_INC &&\n+\t    GET_CODE (XEXP (operands[1], 0)) == PRE_DEC) ||\n+\t   (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC &&\n+\t    GET_CODE (XEXP (operands[1], 0)) == POST_INC)))\n+\t    useorder = big;\n+      else if ((!REG_P (operands[0]) &&\n+\t\tGET_CODE (XEXP (operands[0], 0)) == PRE_DEC) ||\n+\t       (!REG_P (operands[1]) &&\n+\t\t!(CONSTANT_P (operands[1]) || \n+\t\t  GET_CODE (operands[1]) == CONST_DOUBLE) &&\n+\t\tGET_CODE (XEXP (operands[1], 0)) == PRE_DEC))\n+\tuseorder = little;\n+      else if (REG_P (operands[0]) && REG_P (operands[1]) &&\n+\t       REGNO (operands[0]) > REGNO (operands[1]) &&\n+\t       REGNO (operands[0]) < REGNO (operands[1]) + words)\n+\t    useorder = little;\n+\n+      /* Check for source == offset from register and dest == push of\n+\t the same register.  In that case, we have to use the same\n+\t offset (the one for the low order word) for all words, because\n+\t the push increases the offset to each source word.\n+\t In theory there are other cases like this, for example dest == pop,\n+\t but those don't occur in real life so ignore those.  */\n+      if (GET_CODE (operands[0]) ==  MEM \n+\t  && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n+\t  && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n+\t  && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n+\tsameoff = true;\n     }\n \n-  /* If an operand is an unoffsettable memory ref, find a register\n-     we can increment temporarily to make it refer to the second word.  */\n-\n-  if (optype0 == MEMOP)\n-    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n-\n-  if (optype1 == MEMOP)\n-    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n-\n-  /* Ok, we can do one word at a time.\n-     Normally we do the low-numbered word first,\n-     but if either operand is autodecrementing then we\n-     do the high-numbered word first.\n-\n-     In either case, set up in LATEHALF the operands to use\n-     for the high-numbered word and in some cases alter the\n-     operands in OPERANDS to be suitable for the low-numbered word.  */\n-\n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adjust_address (operands[0], HImode, 2);\n+  /* If the caller didn't specify order, use the one we computed,\n+     or high word first if we don't care either.  If the caller did\n+     specify, verify we don't have a problem with that order.\n+     (If it matters to the caller, constraints need to be used to\n+     ensure this case doesn't occur).  */\n+  if (order == either)\n+    order = (useorder == either) ? big : useorder;\n   else\n-    latehalf[0] = operands[0];\n+    gcc_assert (useorder == either || useorder == order);\n \n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adjust_address (operands[1], HImode, 2);\n-  else if (optype1 == CNSTOP)\n+  \n+  for (op = 0; op < opcount; op++)\n     {\n-\tif (CONSTANT_P (operands[1]))\n+      /* First classify the operand.  */\n+      if (REG_P (operands[op]))\n+\toptype = REGOP;\n+      else if (CONSTANT_P (operands[op])\n+\t       || GET_CODE (operands[op]) == CONST_DOUBLE)\n+\toptype = CNSTOP;\n+      else if (GET_CODE (XEXP (operands[op], 0)) == POST_INC)\n+\toptype = POPOP;\n+      else if (GET_CODE (XEXP (operands[op], 0)) == PRE_DEC)\n+\toptype = PUSHOP;\n+      else if (!reload_in_progress || offsettable_memref_p (operands[op]))\n+\toptype = OFFSOP;\n+      else if (GET_CODE (operands[op]) == MEM)\n+\toptype = MEMOP;\n+      else\n+\toptype = RNDOP;\n+\n+      /* Check for the cases that the operand constraints are not\n+\t supposed to allow to happen. Return failure for such cases.  */\n+      if (optype == RNDOP)\n+\treturn false;\n+      \n+      if (action != NULL)\n+\taction[op] = no_action;\n+      \n+      /* If the operand uses pre-decrement addressing but we\n+\t want to get the parts high order first,\n+\t decrement the former register explicitly\n+\t and change the operand into ordinary indexing.  */\n+      if (optype == PUSHOP && order == big)\n+\t{\n+\t  gcc_assert (action != NULL);\n+\t  action[op] = dec_before;\n+\t  operands[op] = gen_rtx_MEM (GET_MODE (operands[op]),\n+\t\t\t\t      XEXP (XEXP (operands[op], 0), 0));\n+\t  optype = OFFSOP;\n+\t}\n+      /* If the operand uses post-increment mode but we want \n+\t to get the parts low order first, change the operand\n+\t into ordinary indexing and remember to increment\n+\t the register explicitly when we're done.  */\n+      else if (optype == POPOP && order == little)\n \t{\n-\t    /* now the mess begins, high word is in lower word??? \n+\t  gcc_assert (action != NULL);\n+\t  action[op] = inc_after;\n+\t  operands[op] = gen_rtx_MEM (GET_MODE (operands[op]),\n+\t\t\t\t      XEXP (XEXP (operands[op], 0), 0));\n+\t  optype = OFFSOP;\n+\t}\n \n-\t       that's what ashc makes me think, but I don't remember :-( */\n-\t    latehalf[1] = GEN_INT (INTVAL(operands[1]) >> 16);\n-\t    operands[1] = GEN_INT (INTVAL(operands[1]) & 0xff);\n+      if (GET_CODE (operands[op]) == CONST_DOUBLE)\n+\t{\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[op]);\n+\t  REAL_VALUE_TO_TARGET_DOUBLE (r, sval);\n+\t}\n+      \n+      for (i = 0; i < words; i++)\n+\t{\n+\t  if (order == big)\n+\t    w = i;\n+\t  else if (sameoff)\n+\t    w = words - 1;\n+\t  else\n+\t    w = words - 1 - i;\n+\n+\t  /* Set the output operand to be word \"w\" of the input.  */\n+\t  if (optype == REGOP)\n+\t    exops[i][op] = gen_rtx_REG (HImode, REGNO (operands[op]) + w);\n+\t  else if (optype == OFFSOP)\n+\t    exops[i][op] = adjust_address (operands[op], HImode, w * 2);\n+\t  else if (optype == CNSTOP)\n+\t    {\n+\t      if (GET_CODE (operands[op]) == CONST_DOUBLE)\n+\t\t{\n+\t\t  sh = 16 - (w & 1) * 16;\n+\t\t  exops[i][op] = gen_rtx_CONST_INT (HImode, (sval[w / 2] >> sh) & 0xffff);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  sh = ((words - 1 - w) * 16);\n+\t\t  exops[i][op] = gen_rtx_CONST_INT (HImode, trunc_int_for_mode (INTVAL(operands[op]) >> sh, HImode));\n+\t\t}\n+\t    }\n+\t  else\n+\t    exops[i][op] = operands[op];\n \t}\n-\telse\n-\t  /* immediate 32-bit values not allowed */\n-\t  gcc_assert (GET_CODE (operands[1]) != CONST_DOUBLE);\n-    }\n-  else\n-    latehalf[1] = operands[1];\n-\n-  /* If insn is effectively movd N(sp),-(sp) then we will do the\n-     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n-     for the low word as well, to compensate for the first decrement of sp.  */\n-  if (optype0 == PUSHOP\n-      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n-      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n-    operands[1] = latehalf[1];\n-\n-  /* If one or both operands autodecrementing,\n-     do the two words, high-numbered first.  */\n-\n-  /* Likewise,  the first move would clobber the source of the second one,\n-     do them in the other order.  This happens only for registers;\n-     such overlap can't happen in memory unless the user explicitly\n-     sets it up, and that is an undefined circumstance.  */\n-\n-  if (optype0 == PUSHOP || optype1 == PUSHOP\n-      || (optype0 == REGOP && optype1 == REGOP\n-\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n-    {\n-      /* Make any unoffsettable addresses point at high-numbered word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add $2,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add $2,%0\", &addreg1);\n-\n-      /* Do that word.  */\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"sub $2,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"sub $2,%0\", &addreg1);\n-\n-      /* Do low-numbered word.  */\n-      return singlemove_string (operands);\n     }\n-\n-  /* Normal case: do the two words, low-numbered first.  */\n-\n-  output_asm_insn (singlemove_string (operands), operands);\n-\n-  /* Make any unoffsettable addresses point at high-numbered word.  */\n-  if (addreg0)\n-    output_asm_insn (\"add $2,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add $2,%0\", &addreg1);\n-\n-  /* Do that word.  */\n-  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-  /* Undo the adds we just did.  */\n-  if (addreg0)\n-    output_asm_insn (\"sub $2,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"sub $2,%0\", &addreg1);\n-\n-  return \"\";\n+  return true;\n }\n-/* Output assembler code to perform a quadword move insn\n-   with operands OPERANDS.  */\n+\n+/* Output assembler code to perform a multiple-word move insn\n+   with operands OPERANDS.  This moves 2 or 4 words depending\n+   on the machine mode of the operands.  */\n \n const char *\n-output_move_quad (rtx *operands)\n+output_move_multiple (rtx *operands)\n {\n-  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n-  rtx latehalf[2];\n-  rtx addreg0 = 0, addreg1 = 0;\n-\n-  output_asm_insn(\";/* movdi/df: %1 -> %0 */\", operands);\n+  rtx exops[4][2];\n+  pdp11_action action[2];\n+  int i, words;\n   \n-  if (REG_P (operands[0]))\n-    optype0 = REGOP;\n-  else if (offsettable_memref_p (operands[0]))\n-    optype0 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    optype0 = POPOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    optype0 = PUSHOP;\n-  else if (GET_CODE (operands[0]) == MEM)\n-    optype0 = MEMOP;\n-  else\n-    optype0 = RNDOP;\n-\n-  if (REG_P (operands[1]))\n-    optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1])\n-\t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n-    optype1 = CNSTOP;\n-  else if (offsettable_memref_p (operands[1]))\n-    optype1 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n-    optype1 = POPOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n-    optype1 = PUSHOP;\n-  else if (GET_CODE (operands[1]) == MEM)\n-    optype1 = MEMOP;\n-  else\n-    optype1 = RNDOP;\n-\n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n+  words = GET_MODE_BITSIZE (GET_MODE (operands[0])) / 16;\n \n-  gcc_assert (optype0 != RNDOP && optype1 != RNDOP);\n+  pdp11_expand_operands (operands, exops, 2, action, either);\n   \n-  if (optype0 == REGOP || optype1 == REGOP)\n-  {\n-      /* check for use of clrd???? \n-         if you ever allow ac4 and ac5 (now we require secondary load) \n-\t you must check whether \n-\t you want to load into them or store from them - \n-\t then dump ac0 into $help$ movce ac4/5 to ac0, do the \n-\t store from ac0, and restore ac0 - if you can find \n-\t an unused ac[0-3], use that and you save a store and a load!*/\n-\n-      if (FPU_REG_P(REGNO(operands[0])))\n-      {\n-\t  if (GET_CODE(operands[1]) == CONST_DOUBLE)\n-\t  {\n-\t      REAL_VALUE_TYPE r;\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-\n-\t      if (REAL_VALUES_EQUAL (r, dconst0))\n-\t\t  return \"{clrd|clrf} %0\";\n-\t  }\n-\t      \n-\t  return \"{ldd|movf} %1, %0\";\n-      }\n-      \n-      if (FPU_REG_P(REGNO(operands[1])))\n-\t  return \"{std|movf} %1, %0\";\n-  }\n-      \n-  /* If one operand is decrementing and one is incrementing\n-     decrement the former register explicitly\n-     and change that operand into ordinary indexing.  */\n-\n-  if (optype0 == PUSHOP && optype1 == POPOP)\n+  /* Check for explicit decrement before.  */\n+  if (action[0] == dec_before)\n     {\n-      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      output_asm_insn (\"sub $8,%0\", operands);\n-      operands[0] = gen_rtx_MEM (DImode, operands[0]);\n-      optype0 = OFFSOP;\n+      operands[0] = XEXP (operands[0], 0);\n+      output_asm_insn (\"sub $4,%0\", operands);\n     }\n-  if (optype0 == POPOP && optype1 == PUSHOP)\n+  if (action[1] == dec_before)\n     {\n-      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-      output_asm_insn (\"sub $8,%1\", operands);\n-      operands[1] = gen_rtx_MEM (SImode, operands[1]);\n-      optype1 = OFFSOP;\n+      operands[1] = XEXP (operands[1], 0);\n+      output_asm_insn (\"sub $4,%1\", operands);\n     }\n \n-  /* If an operand is an unoffsettable memory ref, find a register\n-     we can increment temporarily to make it refer to the second word.  */\n-\n-  if (optype0 == MEMOP)\n-    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n-\n-  if (optype1 == MEMOP)\n-    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n-\n-  /* Ok, we can do one word at a time.\n-     Normally we do the low-numbered word first,\n-     but if either operand is autodecrementing then we\n-     do the high-numbered word first.\n-\n-     In either case, set up in LATEHALF the operands to use\n-     for the high-numbered word and in some cases alter the\n-     operands in OPERANDS to be suitable for the low-numbered word.  */\n+  /* Do the words.  */\n+  for (i = 0; i < words; i++)\n+    output_asm_insn (singlemove_string (exops[i]), exops[i]);\n \n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 2);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adjust_address (operands[0], SImode, 4);\n-  else\n-    latehalf[0] = operands[0];\n-\n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 2);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adjust_address (operands[1], SImode, 4);\n-  else if (optype1 == CNSTOP)\n+  /* Check for increment after.  */\n+  if (action[0] == inc_after)\n     {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t{\n-\t  REAL_VALUE_TYPE r;\n-\t  long dval[2];\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-\t  REAL_VALUE_TO_TARGET_DOUBLE (r, dval);\n-\t  latehalf[1] = GEN_INT (dval[1]);\n-\t  operands[1] = GEN_INT\t(dval[0]);\n-\t}\n-      else if (GET_CODE(operands[1]) == CONST_INT)\n-\t{\n-\t  latehalf[1] = const0_rtx;\n-\t}\n-      else\n-\tgcc_unreachable ();\n+      operands[0] = XEXP (operands[0], 0);\n+      output_asm_insn (\"add $4,%0\", operands);\n     }\n-  else\n-    latehalf[1] = operands[1];\n-\n-  /* If insn is effectively movd N(sp),-(sp) then we will do the\n-     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n-     for the low word as well, to compensate for the first decrement of sp.  */\n-  if (optype0 == PUSHOP\n-      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n-      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n-    operands[1] = latehalf[1];\n-\n-  /* If one or both operands autodecrementing,\n-     do the two words, high-numbered first.  */\n-\n-  /* Likewise,  the first move would clobber the source of the second one,\n-     do them in the other order.  This happens only for registers;\n-     such overlap can't happen in memory unless the user explicitly\n-     sets it up, and that is an undefined circumstance.  */\n-\n-  if (optype0 == PUSHOP || optype1 == PUSHOP\n-      || (optype0 == REGOP && optype1 == REGOP\n-\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+  if (action[1] == inc_after)\n     {\n-      /* Make any unoffsettable addresses point at high-numbered word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add $4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add $4,%0\", &addreg1);\n-\n-      /* Do that word.  */\n-      output_asm_insn(output_move_double(latehalf), latehalf);\n-\n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"sub $4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"sub $4,%0\", &addreg1);\n-\n-      /* Do low-numbered word.  */\n-      return output_move_double (operands);\n+      operands[1] = XEXP (operands[1], 0);\n+      output_asm_insn (\"add $4,%1\", operands);\n     }\n \n-  /* Normal case: do the two words, low-numbered first.  */\n-\n-  output_asm_insn (output_move_double (operands), operands);\n-\n-  /* Make any unoffsettable addresses point at high-numbered word.  */\n-  if (addreg0)\n-    output_asm_insn (\"add $4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add $4,%0\", &addreg1);\n-\n-  /* Do that word.  */\n-  output_asm_insn (output_move_double (latehalf), latehalf);\n-\n-  /* Undo the adds we just did.  */\n-  if (addreg0)\n-    output_asm_insn (\"sub $4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"sub $4,%0\", &addreg1);\n-\n   return \"\";\n }\n-\n-\f\n-/* Return a REG that occurs in ADDR with coefficient 1.\n-   ADDR can be effectively incremented by incrementing REG.  */\n-\n-static rtx\n-find_addr_reg (rtx addr)\n-{\n-  while (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-\taddr = XEXP (addr, 0);\n-      if (GET_CODE (XEXP (addr, 1)) == REG)\n-\taddr = XEXP (addr, 1);\n-      if (CONSTANT_P (XEXP (addr, 0)))\n-\taddr = XEXP (addr, 1);\n-      if (CONSTANT_P (XEXP (addr, 1)))\n-\taddr = XEXP (addr, 0);\n-    }\n-  if (GET_CODE (addr) == REG)\n-    return addr;\n-  return 0;\n-}\n \f\n /* Output an ascii string.  */\n void\n@@ -1806,6 +1612,7 @@ pdp11_legitimate_address_p (enum machine_mode mode,\n \treturn false;\n       }\n }\n+\n /* Return the class number of the smallest class containing\n    reg number REGNO.  */\n enum reg_class"}, {"sha": "a070c3726cc4860799c29f694c29d02376a0c748", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 159, "deletions": 148, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30442c59aa4fff0ca2b3a2d186510f95367836ef/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30442c59aa4fff0ca2b3a2d186510f95367836ef/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=30442c59aa4fff0ca2b3a2d186510f95367836ef", "patch": "@@ -260,21 +260,21 @@\n ;; Move instructions\n \n (define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g,rm,o\")\n-\t(match_operand:DI 1 \"general_operand\" \"m,r,a\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,g\")\n+\t(match_operand:DI 1 \"general_operand\" \"rN,g\"))]\n   \"\"\n-  \"* return output_move_quad (operands);\"\n+  \"* return output_move_multiple (operands);\"\n ;; what's the mose expensive code - say twice movsi = 16\n-  [(set_attr \"length\" \"32,32,32\")])\n+  [(set_attr \"length\" \"16,32\")])\n \n (define_insn \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,rm,m\")\n-\t(match_operand:SI 1 \"general_operand\" \"rN,IJ,K,m,r\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,g,g\")\n+\t(match_operand:SI 1 \"general_operand\" \"rN,IJ,IJ,g\"))]\n   \"\"\n-  \"* return output_move_double (operands);\"\n+  \"* return output_move_multiple (operands);\"\n ;; what's the most expensive code ? - I think 8!\n ;; we could split it up and make several sub-cases...\n-  [(set_attr \"length\" \"4,6,8,16,16\")])\n+  [(set_attr \"length\" \"4,6,8,16\")])\n \n (define_insn \"mov<mode>\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n@@ -298,7 +298,7 @@\n      else if (which_alternative == 1 || which_alternative == 3)\n        return \\\"std %1, %0\\\";\n      else \n-       return output_move_quad (operands); \"\n+       return output_move_multiple (operands); \"\n ;; just a guess..\n   [(set_attr \"length\" \"2,2,10,10,32\")])\n \n@@ -311,7 +311,7 @@\n      else if (which_alternative == 1 || which_alternative == 3)\n        return \\\"{stcdf|movfo} %1, %0\\\";\n      else \n-       return output_move_double (operands); \"\n+       return output_move_multiple (operands); \"\n ;; just a guess..\n   [(set_attr \"length\" \"2,2,10,10,16\")])\n \n@@ -614,55 +614,79 @@\n   \"{addd|addf} %2, %0\"\n   [(set_attr \"length\" \"2,4,10\")])\n \n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,o,o,r,r,r,o,o,o\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,0,0,0,0,0,0,0,0,0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"r,o,r,o,I,J,K,I,J,K\")))]\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"r,on,r,on\")))]\n   \"\"\n   \"*\n-{ /* Here we trust that operands don't overlap \n-\n-     or is lateoperands the low word?? - looks like it! */\n-\n-  rtx lateoperands[3];\n+{\n+  rtx inops[2];\n+  rtx exops[4][2];\n   \n-  lateoperands[0] = operands[0];\n-\n-  if (REG_P (operands[0]))\n-    operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n-  else\n-    operands[0] = adjust_address (operands[0], HImode, 2);\n+  inops[0] = operands[0];\n+  inops[1] = operands[2];\n+  pdp11_expand_operands (inops, exops, 2, NULL, either);\n   \n-  if (! CONSTANT_P(operands[2]))\n+  if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n+    output_asm_insn (\\\"add %1, %0\\\", exops[0]);\n+  if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n-    lateoperands[2] = operands[2];\n-\n-    if (REG_P (operands[2]))\n-      operands[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + 1);\n-    else\n-      operands[2] = adjust_address (operands[2], HImode, 2);\n-\n-    output_asm_insn (\\\"add %2, %0\\\", operands);\n-    output_asm_insn (\\\"adc %0\\\", lateoperands);\n-    output_asm_insn (\\\"add %2, %0\\\", lateoperands);\n-    return \\\"\\\";\n+    output_asm_insn (\\\"add %1, %0\\\", exops[1]);\n+    output_asm_insn (\\\"adc %0\\\", exops[0]);\n+  }\n+  if (!CONSTANT_P (exops[2][1]) || INTVAL (exops[2][1]) != 0)\n+  {\n+    output_asm_insn (\\\"add %1, %0\\\", exops[2]);\n+    output_asm_insn (\\\"adc %0\\\", exops[1]);\n+    output_asm_insn (\\\"adc %0\\\", exops[0]);\n+  }\n+  if (!CONSTANT_P (exops[3][1]) || INTVAL (exops[3][1]) != 0)\n+  {\n+    output_asm_insn (\\\"add %1, %0\\\", exops[3]);\n+    output_asm_insn (\\\"adc %0\\\", exops[2]);\n+    output_asm_insn (\\\"adc %0\\\", exops[1]);\n+    output_asm_insn (\\\"adc %0\\\", exops[0]);\n   }\n \n-  lateoperands[2] = GEN_INT ((INTVAL (operands[2]) >> 16) & 0xffff);\n-  operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"20,28,40,48\")])\n+\n+;; Note that the register operand is not marked earlyclobber.\n+;; The reason is that SI values go in register pairs, so they\n+;; can't partially overlap.  They can be either disjoint, or\n+;; source and destination can be equal.  The latter case is \n+;; handled properly because of the ordering of the individual\n+;; instructions used.  Specifically, carry from the low to the\n+;; high word is added at the end, so the adding of the high parts\n+;; will always used the original high part and not a high part\n+;; modified by carry (which would amount to double carry).\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,o,o\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"r,on,r,on\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx inops[2];\n+  rtx exops[2][2];\n   \n-  if (INTVAL(operands[2]))\n-  { \n-    output_asm_insn (\\\"add %2, %0\\\", operands);\n-    output_asm_insn (\\\"adc %0\\\", lateoperands);\n+  inops[0] = operands[0];\n+  inops[1] = operands[2];\n+  pdp11_expand_operands (inops, exops, 2, NULL, either);\n+  \n+  if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n+    output_asm_insn (\\\"add %1, %0\\\", exops[0]);\n+  if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n+  {\n+    output_asm_insn (\\\"add %1, %0\\\", exops[1]);\n+    output_asm_insn (\\\"adc %0\\\", exops[0]);\n   }\n \n-  if (INTVAL(lateoperands[2]))\n-    output_asm_insn (\\\"add %2, %0\\\", lateoperands);\n-\n   return \\\"\\\";\n }\"\n-  [(set_attr \"length\" \"6,10,12,16,6,2,10,10,6,16\")])\n+  [(set_attr \"length\" \"6,10,12,16\")])\n \n (define_insn \"addhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n@@ -697,38 +721,69 @@\n   \"{subd|subf} %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,o,o\")\n-        (minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0,0\")\n-                  (match_operand:SI 2 \"general_operand\" \"r,o,r,o\")))]\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"r,on,r,on\")))]\n   \"\"\n   \"*\n-{ /* Here we trust that operands don't overlap \n+{\n+  rtx inops[2];\n+  rtx exops[4][2];\n+  \n+  inops[0] = operands[0];\n+  inops[1] = operands[2];\n+  pdp11_expand_operands (inops, exops, 2, NULL, either);\n+  \n+  if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n+    output_asm_insn (\\\"sub %1, %0\\\", exops[0]);\n+  if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n+  {\n+    output_asm_insn (\\\"sub %1, %0\\\", exops[1]);\n+    output_asm_insn (\\\"sbc %0\\\", exops[0]);\n+  }\n+  if (!CONSTANT_P (exops[2][1]) || INTVAL (exops[2][1]) != 0)\n+  {\n+    output_asm_insn (\\\"sub %1, %0\\\", exops[2]);\n+    output_asm_insn (\\\"sbc %0\\\", exops[1]);\n+    output_asm_insn (\\\"sbc %0\\\", exops[0]);\n+  }\n+  if (!CONSTANT_P (exops[3][1]) || INTVAL (exops[3][1]) != 0)\n+  {\n+    output_asm_insn (\\\"sub %1, %0\\\", exops[3]);\n+    output_asm_insn (\\\"sbc %0\\\", exops[2]);\n+    output_asm_insn (\\\"sbc %0\\\", exops[1]);\n+    output_asm_insn (\\\"sbc %0\\\", exops[0]);\n+  }\n \n-     or is lateoperands the low word?? - looks like it! */\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"20,28,40,48\")])\n \n-  rtx lateoperands[3];\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,o,o\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"r,on,r,on\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx inops[2];\n+  rtx exops[2][2];\n   \n-  lateoperands[0] = operands[0];\n-\n-  if (REG_P (operands[0]))\n-    operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n-  else\n-    operands[0] = adjust_address (operands[0], HImode, 2);\n+  inops[0] = operands[0];\n+  inops[1] = operands[2];\n+  pdp11_expand_operands (inops, exops, 2, NULL, either);\n   \n-  lateoperands[2] = operands[2];\n-\n-  if (REG_P (operands[2]))\n-    operands[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + 1);\n-  else\n-    operands[2] = adjust_address (operands[2], HImode, 2);\n+  if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n+    output_asm_insn (\\\"sub %1, %0\\\", exops[0]);\n+  if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n+  {\n+    output_asm_insn (\\\"sub %1, %0\\\", exops[1]);\n+    output_asm_insn (\\\"sbc %0\\\", exops[0]);\n+  }\n \n-  output_asm_insn (\\\"sub %2, %0\\\", operands);\n-  output_asm_insn (\\\"sbc %0\\\", lateoperands);\n-  output_asm_insn (\\\"sub %2, %0\\\", lateoperands);\n   return \\\"\\\";\n }\"\n-;; offsettable memory addresses always are expensive!!!\n   [(set_attr \"length\" \"6,10,12,16\")])\n \n (define_insn \"subhi3\"\n@@ -1070,60 +1125,6 @@\n   \"{absd|absf} %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-(define_insn \"abshi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(abs:HI (match_operand:HI 1 \"general_operand\" \"0,0\")))]\n-  \"\"\n-  \"*\n-{\n-  static int count = 0;\n-  char buf[200];\n-\t\n-  output_asm_insn(\\\"tst %0\\\", operands);\n-  sprintf(buf, \\\"bge abshi%d\\\", count);\n-  output_asm_insn(buf, NULL);\n-  output_asm_insn(\\\"neg %0\\\", operands);\n-  sprintf(buf, \\\"\\\\nabshi%d:\\\", count++);\n-  output_asm_insn(buf, NULL);\n-\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"length\" \"6,10\")])\n-\n-\n-;; define expand abshi - is much better !!! - but\n-;; will it be optimized into an abshi2 ?\n-;; it will leave better code, because the tsthi might be \n-;; optimized away!!\n-; -- just a thought - don't have time to check \n-;\n-;(define_expand \"abshi2\"\n-;  [(match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-;   (match_operand:HI 1 \"general_operand\" \"\")]\n-;  \"\"\n-;  \"\n-;{\n-;  rtx label = gen_label_rtx ();\n-;\n-;  /* do I need this? */\n-;  do_pending_stack_adjust ();\n-;\n-;  emit_move_insn (operands[0], operands[1]);\n-;\n-;  emit_insn (gen_tsthi (operands[0]));\n-;  emit_insn (gen_bge (label1));\n-;\n-;  emit_insn (gen_neghi(operands[0], operands[0])\n-;  \n-;  emit_barrier ();\n-;\n-;  emit_label (label);\n-;\n-;  /* allow REG_NOTES to be set on last insn (labels don't have enough\n-;     fields, and can't be used for REG_NOTES anyway).  */\n-;  emit_use (stack_pointer_rtx);\n-;  DONE;\n-;}\")\n \n ;; negate insns\n \n@@ -1134,41 +1135,51 @@\n   \"{negd|negf} %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0\")))]\n   \"\"\n {\n+  rtx exops[4][2];\n+  \n+  pdp11_expand_operands (operands, exops, 1, NULL, either);\n \n-  rtx lateoperands[2];\n+  output_asm_insn (\\\"com %0\\\", exops[3]);\n+  output_asm_insn (\\\"com %0\\\", exops[2]);\n+  output_asm_insn (\\\"com %0\\\", exops[1]);\n+  output_asm_insn (\\\"com %0\\\", exops[0]);\n+  output_asm_insn (\\\"add $1, %0\\\", exops[3]);\n+  output_asm_insn (\\\"adc %0\\\", exops[2]);\n+  output_asm_insn (\\\"adc %0\\\", exops[1]);\n+  output_asm_insn (\\\"adc %0\\\", exops[0]);\n \n-  lateoperands[0] = operands[0];\n-  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n+  return \\\"\\\";\n+}\n+[(set_attr \"length\" \"18,34\")])\n \n-  lateoperands[1] = operands[1];\n-  operands[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+{\n+  rtx exops[2][2];\n+  \n+  pdp11_expand_operands (operands, exops, 1, NULL, either);\n \n-  output_asm_insn (\\\"com %0\\\", lateoperands);\n-  output_asm_insn (\\\"com %0\\\", operands);\n-  output_asm_insn (\\\"add $1, %0\\\", operands);\n-  output_asm_insn (\\\"adc %0\\\", lateoperands);\n+  output_asm_insn (\\\"com %0\\\", exops[1]);\n+  output_asm_insn (\\\"com %0\\\", exops[0]);\n+  output_asm_insn (\\\"add $1, %0\\\", exops[1]);\n+  output_asm_insn (\\\"adc %0\\\", exops[0]);\n \n   return \\\"\\\";\n }\n-  [(set_attr \"length\" \"14\")])\n+[(set_attr \"length\" \"12,20\")])\n \n-(define_insn \"neghi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n-\t(neg:HI (match_operand:HI 1 \"general_operand\" \"0,0\")))]\n-  \"\"\n-  \"neg %0\"\n-  [(set_attr \"length\" \"2,4\")])\n-\n-(define_insn \"negqi2\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rR,Q\")\n-\t(neg:QI (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Q\")\n+\t(neg:PDPint (match_operand:PDPint 1 \"general_operand\" \"0,0\")))]\n   \"\"\n-  \"negb %0\"\n+  \"neg<isfx> %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n "}]}