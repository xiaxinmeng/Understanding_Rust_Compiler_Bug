{"sha": "df2fba9e343385222745d9e99cbaae29026a263d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYyZmJhOWUzNDMzODUyMjI3NDVkOWU5OWNiYWFlMjkwMjZhMjYzZA==", "commit": {"author": {"name": "Ralf Wildenhues", "email": "Ralf.Wildenhues@gmx.de", "date": "2008-07-21T19:17:08Z"}, "committer": {"name": "Ralf Wildenhues", "email": "rwild@gcc.gnu.org", "date": "2008-07-21T19:17:08Z"}, "message": "fmt_g0_3.f08: Fix typo in expected error message.\n\ngcc/testsuite/\n\n\t* gfortran.dg/fmt_g0_3.f08: Fix typo in expected error message.\n\ngcc/fortran/\n\n\t* expr.c (gfc_check_pointer_assign): Fix typo in string.\n\t* io.c (check_format): Fix typo in string.  Fix comment typos.\n\t* parse.c (gfc_global_used): Likewise.\n\t* resolve.c (resolve_allocate_expr): Likewise.\n\t* symbol.c (gfc_set_default_type): Likewise.\n\t* arith.c: Fix typos in comments.\n\t* array.c: Likewise.\n\t* data.c: Likewise.\n\t* decl.c: Likewise.\n\t* dependency.c: Likewise.\n\t* f95-lang.c: Likewise.\n\t* gfortran.h: Likewise.\n\t* matchexp.c: Likewise.\n\t* module.c: Likewise.\n\t* primary.c: Likewise.\n\t* scanner.c: Likewise.\n\t* trans-array.c: Likewise.\n\t* trans-common.c: Likewise.\n\t* trans-decl.c: Likewise.\n\t* trans-expr.c: Likewise.\n\t* trans-intrinsic.c: Likewise.\n\t* trans-types.c: Likewise.\n\t* trans.c: Likewise.\n\t* trans.h: Likewise.\n\nFrom-SVN: r138040", "tree": {"sha": "b4aa45858530c5447d03da6b7e211c2d414973d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4aa45858530c5447d03da6b7e211c2d414973d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df2fba9e343385222745d9e99cbaae29026a263d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df2fba9e343385222745d9e99cbaae29026a263d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df2fba9e343385222745d9e99cbaae29026a263d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df2fba9e343385222745d9e99cbaae29026a263d/comments", "author": null, "committer": null, "parents": [{"sha": "2e7628842865d7de2eeb170af79f0fc38c057d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7628842865d7de2eeb170af79f0fc38c057d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e7628842865d7de2eeb170af79f0fc38c057d9c"}], "stats": {"total": 175, "additions": 103, "deletions": 72}, "files": [{"sha": "b46306174e18a7857cc9b867f7d973f7fd99f358", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1,3 +1,30 @@\n+2008-07-21  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n+\n+\t* expr.c (gfc_check_pointer_assign): Fix typo in string.\n+\t* io.c (check_format): Fix typo in string.  Fix comment typos.\n+\t* parse.c (gfc_global_used): Likewise.\n+\t* resolve.c (resolve_allocate_expr): Likewise.\n+\t* symbol.c (gfc_set_default_type): Likewise.\n+\t* arith.c: Fix typos in comments.\n+\t* array.c: Likewise.\n+\t* data.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* dependency.c: Likewise.\n+\t* f95-lang.c: Likewise.\n+\t* gfortran.h: Likewise.\n+\t* matchexp.c: Likewise.\n+\t* module.c: Likewise.\n+\t* primary.c: Likewise.\n+\t* scanner.c: Likewise.\n+\t* trans-array.c: Likewise.\n+\t* trans-common.c: Likewise.\n+\t* trans-decl.c: Likewise.\n+\t* trans-expr.c: Likewise.\n+\t* trans-intrinsic.c: Likewise.\n+\t* trans-types.c: Likewise.\n+\t* trans.c: Likewise.\n+\t* trans.h: Likewise.\n+\n 2008-07-19  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/36795"}, {"sha": "2e21b840e2a955d84a28684bb54e878e835d488f", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1092,7 +1092,7 @@ gfc_arith_concat (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n }\n \n /* Comparison between real values; returns 0 if (op1 .op. op2) is true.\n-   This function mimics mpr_cmp but takes NaN into account.  */\n+   This function mimics mpfr_cmp but takes NaN into account.  */\n \n static int\n compare_real (gfc_expr *op1, gfc_expr *op2, gfc_intrinsic_op op)\n@@ -1159,7 +1159,7 @@ gfc_compare_expr (gfc_expr *op1, gfc_expr *op2, gfc_intrinsic_op op)\n \n \n /* Compare a pair of complex numbers.  Naturally, this is only for\n-   equality and nonequality.  */\n+   equality and inequality.  */\n \n static int\n compare_complex (gfc_expr *op1, gfc_expr *op2)\n@@ -2084,7 +2084,7 @@ arith_error (arith rc, gfc_typespec *from, gfc_typespec *to, locus *where)\n       gfc_internal_error (\"gfc_arith_error(): Bad error code\");\n     }\n \n-  /* TODO: Do something about the error, ie, throw exception, return\n+  /* TODO: Do something about the error, i.e., throw exception, return\n      NaN, etc.  */\n }\n "}, {"sha": "7216d1f472e4708c3c10aba2dd603aa5e3f4cac0", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1577,7 +1577,7 @@ resolve_array_list (gfc_constructor *p)\n }\n \n /* Resolve character array constructor. If it has a specified constant character\n-   length, pad/trunkate the elements here; if the length is not specified and\n+   length, pad/truncate the elements here; if the length is not specified and\n    all elements are of compile-time known length, emit an error as this is\n    invalid.  */\n \n@@ -1675,7 +1675,7 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \t max_length only if they pass.  */\n       gfc_extract_int (expr->ts.cl->length, &found_length);\n \n-      /* Now pad/trunkate the elements accordingly to the specified character\n+      /* Now pad/truncate the elements accordingly to the specified character\n \t length.  This is ok inside this conditional, as in the case above\n \t (without typespec) all elements are verified to have the same length\n \t anyway.  */"}, {"sha": "bda448a8f5688c9872c58bd72c19611ae6842868", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Notes for DATA statement implementation:\n \t\t\t\t\t\t\t\t\t       \n    We first assign initial value to each symbol by gfc_assign_data_value\n-   during resolveing DATA statement. Refer to check_data_variable and\n+   during resolving DATA statement. Refer to check_data_variable and\n    traverse_data_list in resolve.c.\n \t\t\t\t\t\t\t\t\t       \n    The complexity exists in the handling of array section, implied do\n@@ -144,7 +144,7 @@ find_con_by_component (gfc_component *com, gfc_constructor *con)\n \n /* Create a character type initialization expression from RVALUE.\n    TS [and REF] describe [the substring of] the variable being initialized.\n-   INIT is thh existing initializer, not NULL.  Initialization is performed\n+   INIT is the existing initializer, not NULL.  Initialization is performed\n    according to normal assignment rules.  */\n \n static gfc_expr *\n@@ -754,7 +754,7 @@ formalize_structure_cons (gfc_expr *expr)\n }\n \n \n-/* Make sure an initialization expression is in normalized form.  Ie. all\n+/* Make sure an initialization expression is in normalized form, i.e., all\n    elements of the constructors are in the correct order.  */\n \n static void"}, {"sha": "aff1ebbaeb5cf148cd157de68a2f8b16c955b1af", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -762,7 +762,7 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n \t  (*result)->ts = sym->ts;\n \n \t  /* Put the symbol in the procedure namespace so that, should\n-\t     the ENTRY preceed its specification, the specification\n+\t     the ENTRY precede its specification, the specification\n \t     can be applied.  */\n \t  (*result)->ns = gfc_current_ns;\n \n@@ -5770,7 +5770,7 @@ gfc_match_protected (void)\n \n \n /* The PRIVATE statement is a bit weird in that it can be an attribute\n-   declaration, but also works as a standlone statement inside of a\n+   declaration, but also works as a standalone statement inside of a\n    type declaration or a module.  */\n \n match\n@@ -6341,7 +6341,7 @@ gfc_match_derived_decl (void)\n      components.  The ways this can happen is via a function\n      definition, an INTRINSIC statement or a subtype in another\n      derived type that is a pointer.  The first part of the AND clause\n-     is true if a the symbol is not the return value of a function.  */\n+     is true if the symbol is not the return value of a function.  */\n   if (sym->attr.flavor != FL_DERIVED\n       && gfc_add_flavor (&sym->attr, FL_DERIVED, sym->name, NULL) == FAILURE)\n     return MATCH_ERROR;"}, {"sha": "558b7675873b6d06c9ffa97d19925727435447be", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -37,7 +37,7 @@ typedef enum\n {\n   GFC_DEP_ERROR,\n   GFC_DEP_EQUAL,\t/* Identical Ranges.  */\n-  GFC_DEP_FORWARD,\t/* eg. a(1:3), a(2:4).  */\n+  GFC_DEP_FORWARD,\t/* e.g., a(1:3), a(2:4).  */\n   GFC_DEP_OVERLAP,\t/* May overlap in some other way.  */\n   GFC_DEP_NODEP\t\t/* Distinct ranges.  */\n }\n@@ -523,7 +523,7 @@ gfc_check_fncall_dependency (gfc_expr *other, sym_intent intent,\n \n \n /* Return 1 if e1 and e2 are equivalenced arrays, either\n-   directly or indirectly; ie. equivalence (a,b) for a and b\n+   directly or indirectly; i.e., equivalence (a,b) for a and b\n    or equivalence (a,c),(b,c).  This function uses the equiv_\n    lists, generated in trans-common(add_equivalences), that are\n    guaranteed to pick up indirect equivalences.  We explicitly\n@@ -1183,7 +1183,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n   while (lref && rref)\n     {\n       /* We're resolving from the same base symbol, so both refs should be\n-\t the same type.  We traverse the reference chain intil we find ranges\n+\t the same type.  We traverse the reference chain until we find ranges\n \t that are not equal.  */\n       gcc_assert (lref->type == rref->type);\n       switch (lref->type)"}, {"sha": "3dfd31b4183a682e8a85f52d7f62979723d106bb", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -3002,7 +3002,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \n   if (attr.is_protected && attr.use_assoc)\n     {\n-      gfc_error (\"Pointer assigment target has PROTECTED \"\n+      gfc_error (\"Pointer assignment target has PROTECTED \"\n \t\t \"attribute at %L\", &rvalue->where);\n       return FAILURE;\n     }"}, {"sha": "8e052aaf0d195cb6bc8c6ad22356b02d79ebbd8b", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -236,7 +236,7 @@ gfc_be_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n   cgraph_finalize_compilation_unit ();\n   cgraph_optimize ();\n \n-  /* Tell the frontent about any errors.  */\n+  /* Tell the frontend about any errors.  */\n   gfc_get_errors (&warnings, &errors);\n   errorcount += errors;\n   warningcount += warnings;\n@@ -437,7 +437,7 @@ poplevel (int keep, int reverse, int functionbody)\n     }\n   else if (current_binding_level == global_binding_level)\n     /* When using gfc_start_block/gfc_finish_block from middle-end hooks,\n-       don't add newly created BLOCKs as sublocks of global_binding_level.  */\n+       don't add newly created BLOCKs as subblocks of global_binding_level.  */\n     ;\n   else if (block_node)\n     {\n@@ -547,7 +547,7 @@ gfc_init_decl_processing (void)\n      only use it for actual characters, not for INTEGER(1). Also, we\n      want double_type_node to actually have double precision.  */\n   build_common_tree_nodes (false, false);\n-  /* x86_64 minw32 has a sizetype of \"unsigned long long\", most other hosts\n+  /* x86_64 mingw32 has a sizetype of \"unsigned long long\", most other hosts\n      have a sizetype of \"unsigned long\". Therefore choose the correct size\n      in mostly target independent way.  */\n   if (TYPE_MODE (long_unsigned_type_node) == ptr_mode)"}, {"sha": "2c284657a09183383d9245bb915ddf3f21784ece", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -78,7 +78,7 @@ char *alloca ();\n #define stringize(x) expand_macro(x)\n #define expand_macro(x) # x\n \n-/* For a the runtime library, a standard prefix is a requirement to\n+/* For the runtime library, a standard prefix is a requirement to\n    avoid cluttering the namespace with things nobody asked for.  It's\n    ugly to look at and a pain to type when you add the prefix by hand,\n    so we hide it behind a macro.  */\n@@ -304,7 +304,7 @@ extern const mstring save_status[];\n enum gfc_isym_id\n {\n   /* GFC_ISYM_NONE is used for intrinsics which will never be seen by\n-     the backend (eg. KIND).  */\n+     the backend (e.g. KIND).  */\n   GFC_ISYM_NONE = 0,\n   GFC_ISYM_ABORT,\n   GFC_ISYM_ABS,\n@@ -693,7 +693,7 @@ typedef struct\n   unsigned cray_pointer:1, cray_pointee:1;\n \n   /* The symbol is a derived type with allocatable components, pointer \n-     components or private components, possibly nested.  zer_comp\n+     components or private components, possibly nested.  zero_comp\n      is true if the derived type has no component at all.  */\n   unsigned alloc_comp:1, pointer_comp:1, private_comp:1, zero_comp:1;\n \n@@ -1960,7 +1960,7 @@ typedef struct gfc_finalizer\n {\n   struct gfc_finalizer* next;\n   gfc_symbol* procedure;\n-  locus where; /* Where the FINAL declaration occured.  */\n+  locus where; /* Where the FINAL declaration occurred.  */\n }\n gfc_finalizer;\n "}, {"sha": "5d3f454acc09580c0fcfbc32a0216da621c1707a", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -696,7 +696,7 @@ check_format (bool is_input)\n \t      goto syntax;\n \t    }\n \n-\t  if (gfc_notify_std (GFC_STD_F2008, \"Fortran F2008: 'G0' in \"\n+\t  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: 'G0' in \"\n \t\t\t      \"format at %C\") == FAILURE)\n \t    return FAILURE;\n \n@@ -2489,9 +2489,9 @@ gfc_resolve_dt (gfc_dt *dt)\n       else\n \t{\n \t  /* At this point, we have an extra comma.  If io_unit has arrived as\n-\t     type chracter, we assume its really the \"format\" form of the I/O\n+\t     type character, we assume its really the \"format\" form of the I/O\n \t     statement.  We set the io_unit to the default unit and format to\n-\t     the chracter expression.  See F95 Standard section 9.4.  */\n+\t     the character expression.  See F95 Standard section 9.4.  */\n \t  io_kind k;\n \t  k = dt->extra_comma->value.iokind;\n \t  if (e->ts.type == BT_CHARACTER && (k == M_READ || k == M_PRINT))"}, {"sha": "f7573655316d50aa7f7514336a4ba25aed4b56c7", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -254,7 +254,7 @@ match_level_1 (gfc_expr **result)\n /* As a GNU extension we support an expanded level-2 expression syntax.\n    Via this extension we support (arbitrary) nesting of unary plus and\n    minus operations following unary and binary operators, such as **.\n-   The grammar of section 7.1.1.3 is effectively rewitten as:\n+   The grammar of section 7.1.1.3 is effectively rewritten as:\n \n \tR704  mult-operand     is level-1-expr [ power-op ext-mult-operand ]\n \tR704' ext-mult-operand is add-op ext-mult-operand"}, {"sha": "a418bb9d9a467abe0c79b45d6030437bb95a11ba", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -20,7 +20,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* The syntax of gfortran modules resembles that of lisp lists, ie a\n+/* The syntax of gfortran modules resembles that of lisp lists, i.e. a\n    sequence of atoms, which can be left or right parenthesis, names,\n    integers or strings.  Parenthesis are always matched which allows\n    us to skip over sections at high speed without having to know\n@@ -446,7 +446,7 @@ associate_integer_pointer (pointer_info *p, void *gp)\n    either store the pointer from an already-known value or create a\n    fixup structure in order to store things later.  Returns zero if\n    the reference has been actually stored, or nonzero if the reference\n-   must be fixed later (ie associate_integer_pointer must be called\n+   must be fixed later (i.e., associate_integer_pointer must be called\n    sometime later.  Returns the pointer_info structure.  */\n \n static pointer_info *\n@@ -3062,7 +3062,7 @@ mio_namelist (gfc_symbol *sym)\n }\n \n \n-/* Save/restore lists of gfc_interface stuctures.  When loading an\n+/* Save/restore lists of gfc_interface structures.  When loading an\n    interface, we are really appending to the existing list of\n    interfaces.  Checking for duplicate and ambiguous interfaces has to\n    be done later when all symbols have been loaded.  */\n@@ -3272,7 +3272,7 @@ find_symtree_for_symbol (gfc_symtree *st, gfc_symbol *sym)\n }\n \n \n-/* A recursive function to look for a speficic symbol by name and by\n+/* A recursive function to look for a specific symbol by name and by\n    module.  Whilst several symtrees might point to one symbol, its\n    is sufficient for the purposes here than one exist.  Note that\n    generic interfaces are distinguished as are symbols that have been"}, {"sha": "1a4796276687380f9fb5ace43278764a25c707d4", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1533,7 +1533,7 @@ unexpected_statement (gfc_statement st)\n    issue an error and return FAILURE.  Otherwise we return SUCCESS.\n \n    Individual parsers need to verify that the statements seen are\n-   valid before calling here, ie ENTRY statements are not allowed in\n+   valid before calling here, i.e., ENTRY statements are not allowed in\n    INTERFACE blocks.  The following diagram is taken from the standard:\n \n \t    +---------------------------------------+\n@@ -3413,7 +3413,7 @@ gfc_global_used (gfc_gsymbol *sym, locus *where)\n       name = \"MODULE\";\n       break;\n     default:\n-      gfc_internal_error (\"gfc_gsymbol_type(): Bad type\");\n+      gfc_internal_error (\"gfc_global_used(): Bad type\");\n       name = NULL;\n     }\n \n@@ -3688,7 +3688,7 @@ gfc_parse_file (void)\n \n duplicate_main:\n   /* If we see a duplicate main program, shut down.  If the second\n-     instance is an implied main program, ie data decls or executable\n+     instance is an implied main program, i.e. data decls or executable\n      statements, we're in for lots of errors.  */\n   gfc_error (\"Two main PROGRAMs at %L and %C\", &prog_locus);\n   reject_statement ();"}, {"sha": "ba8416376ec8603f57eb5ffe9a5e7fef411527d5", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -2689,7 +2689,7 @@ gfc_match_rvalue (gfc_expr **result)\n }\n \n \n-/* Match a variable, ie something that can be assigned to.  This\n+/* Match a variable, i.e. something that can be assigned to.  This\n    starts as a symbol, can be a structure component or an array\n    reference.  It can be a function if the function doesn't have a\n    separate RESULT variable.  If the symbol has not been previously\n@@ -2714,7 +2714,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n      we force the changed_symbols mechanism to work by setting\n      host_flag to 0. This prevents valid symbols that have the name\n      of keywords, such as 'end', being turned into variables by\n-     failed matching to assignments for, eg., END INTERFACE.  */\n+     failed matching to assignments for, e.g., END INTERFACE.  */\n   if (gfc_current_state () == COMP_MODULE\n       || gfc_current_state () == COMP_INTERFACE\n       || gfc_current_state () == COMP_CONTAINS)"}, {"sha": "056ff0ee3e2e6daed22b4e237bd7bc74a83c0a7d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1,4 +1,4 @@\n-/* Perform type resolution on the various stuctures.\n+/* Perform type resolution on the various structures.\n    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n@@ -1568,7 +1568,7 @@ resolve_specific_f0 (gfc_symbol *sym, gfc_expr *expr)\n       gfc_intrinsic_sym *isym;\n       isym = gfc_find_function (sym->ts.interface->name);\n \n-      /* Existance of isym should be checked already.  */\n+      /* Existence of isym should be checked already.  */\n       gcc_assert (isym);\n \n       sym->ts.type = isym->ts.type;\n@@ -2644,7 +2644,7 @@ resolve_specific_s0 (gfc_code *c, gfc_symbol *sym)\n \n       isym = gfc_find_function (sym->ts.interface->name);\n \n-      /* Existance of isym should be checked already.  */\n+      /* Existence of isym should be checked already.  */\n       gcc_assert (isym);\n \n       sym->ts.type = isym->ts.type;\n@@ -3185,7 +3185,7 @@ resolve_operator (gfc_expr *e)\n     {\n       t = gfc_simplify_expr (e, 0);\n       /* Some calls do not succeed in simplification and return FAILURE\n-\t even though there is no error; eg. variable references to\n+\t even though there is no error; e.g. variable references to\n \t PARAMETER arrays.  */\n       if (!gfc_is_constant_expr (e))\n \tt = SUCCESS;\n@@ -4873,7 +4873,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t      || (ar->end[i] != NULL\n \t\t  && gfc_find_sym_in_expr (sym, ar->end[i])))\n \t    {\n-\t      gfc_error (\"'%s' must not appear an the array specification at \"\n+\t      gfc_error (\"'%s' must not appear in the array specification at \"\n \t\t\t \"%L in the same ALLOCATE statement where it is \"\n \t\t\t \"itself allocated\", sym->name, &ar->where);\n \t      return FAILURE;\n@@ -5999,7 +5999,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \n \n /* Does everything to resolve an ordinary assignment.  Returns true\n-   if this is an interface asignment.  */\n+   if this is an interface assignment.  */\n static bool\n resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n {\n@@ -7251,7 +7251,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n     }\n \n   /* Ensure that derived type for are not of a private type.  Internal\n-     module procedures are excluded by 2.2.3.3 - ie. they are not\n+     module procedures are excluded by 2.2.3.3 - i.e., they are not\n      externally accessible and can access all the objects accessible in\n      the host.  */\n   if (!(sym->ns->parent\n@@ -7563,7 +7563,7 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n \tprev_link = &list->next;\n \tcontinue;\n \n-\t/* Remove wrong nodes immediatelly from the list so we don't risk any\n+\t/* Remove wrong nodes immediately from the list so we don't risk any\n \t   troubles in the future when they might fail later expectations.  */\n error:\n \tresult = FAILURE;\n@@ -8642,7 +8642,7 @@ resolve_data (gfc_data *d)\n    is storage associated with any such variable, shall not be used in the\n    following contexts: (clients of this function).  */\n \n-/* Determines if a variable is not 'pure', ie not assignable within a pure\n+/* Determines if a variable is not 'pure', i.e., not assignable within a pure\n    procedure.  Returns zero if assignment is OK, nonzero if there is a\n    problem.  */\n int"}, {"sha": "c0becf05e2c147d03b6fc351dbec2eaadbb7dbab", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1917,7 +1917,7 @@ load_file (const char *realfilename, const char *displayedname, bool initial)\n \n \n /* Open a new file and start scanning from that file. Returns SUCCESS\n-   if everything went OK, FAILURE otherwise.  If form == FORM_UKNOWN\n+   if everything went OK, FAILURE otherwise.  If form == FORM_UNKNOWN\n    it tries to determine the source form from the filename, defaulting\n    to free form.  */\n "}, {"sha": "121f62ea2cb0763e26efd020bf128df1ece156a0", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -272,7 +272,7 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n         {\n           /* Dummy args to a BIND(C) routine may not be interoperable if\n              they are implicitly typed.  */\n-          gfc_warning_now (\"Implicity declared variable '%s' at %L may not \"\n+          gfc_warning_now (\"Implicitly declared variable '%s' at %L may not \"\n                            \"be C interoperable but it is a dummy argument to \"\n                            \"the BIND(C) procedure '%s' at %L\", sym->name,\n                            &(sym->declared_at), sym->ns->proc_name->name,"}, {"sha": "6402887cec857930fa42ef5cf2748e51983944d0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n    In fortran all the rhs values of an assignment must be evaluated before\n    any assignments take place.  This can require a temporary array to store the\n    values.  We also require a temporary when we are passing array expressions\n-   or vector subecripts as procedure parameters.\n+   or vector subscripts as procedure parameters.\n \n    Array sections are passed without copying to a temporary.  These use the\n    scalarizer to determine the shape of the section.  The flag\n@@ -1645,7 +1645,7 @@ gfc_trans_constant_array_constructor (gfc_loopinfo * loop,\n /* Helper routine of gfc_trans_array_constructor to determine if the\n    bounds of the loop specified by LOOP are constant and simple enough\n    to use with gfc_trans_constant_array_constructor.  Returns the\n-   the iteration count of the loop if suitable, and NULL_TREE otherwise.  */\n+   iteration count of the loop if suitable, and NULL_TREE otherwise.  */\n \n static tree\n constant_array_constructor_loop_size (gfc_loopinfo * loop)\n@@ -1901,8 +1901,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n   gfc_se se;\n   int n;\n \n-  /* TODO: This can generate bad code if there are ordering dependencies.\n-     eg. a callee allocated function and an unknown size constructor.  */\n+  /* TODO: This can generate bad code if there are ordering dependencies,\n+     e.g., a callee allocated function and an unknown size constructor.  */\n   gcc_assert (ss != NULL);\n \n   for (; ss != gfc_ss_terminator; ss = ss->loop_chain)\n@@ -4536,7 +4536,7 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n   tmp = gfc_build_array_ref (tmp, offset, NULL);\n \n   /* Offset the data pointer for pointer assignments from arrays with\n-     subreferences; eg. my_integer => my_type(:)%integer_component.  */\n+     subreferences; e.g. my_integer => my_type(:)%integer_component.  */\n   if (subref)\n     {\n       /* Go past the array reference.  */\n@@ -4635,7 +4635,7 @@ get_elemental_fcn_charlen (gfc_expr *expr, gfc_se *se)\n   arg = expr->value.function.actual;\n   gfc_init_interface_mapping (&mapping);\n \n-  /* Set se = NULL in the calls to the interface mapping, to supress any\n+  /* Set se = NULL in the calls to the interface mapping, to suppress any\n      backend stuff.  */\n   for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n     {\n@@ -5865,7 +5865,7 @@ gfc_walk_op_expr (gfc_ss * ss, gfc_expr * expr)\n   if (head == ss)\n     {\n       /* First operand is scalar.  We build the chain in reverse order, so\n-         add the scarar SS after the second operand.  */\n+         add the scalar SS after the second operand.  */\n       head = head2;\n       while (head && head->next != ss)\n \thead = head->next;"}, {"sha": "8c30309b81f5c61e8a54ff4fb698902eacc2fd12", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -955,7 +955,7 @@ find_equivalence (segment_info *n)\n    segment list multiple times to include indirect equivalences.  Since\n    a new segment_info can inserted at the beginning of the segment list,\n    depending on its offset, we have to force a final pass through the\n-   loop by demanding that completion sees a pass with no matches; ie.\n+   loop by demanding that completion sees a pass with no matches; i.e.,\n    all symbols with equiv_built set and no new equivalences found.  */\n \n static void"}, {"sha": "d2161f5c5c7c6a3715b44b45bc3dd703ab23a4bc", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -525,7 +525,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n      a default initializer; this must be applied each time the variable\n      comes into scope it therefore need not be static.  These variables\n      are SAVE_NONE but have an initializer.  Otherwise explicitly\n-     intitialized variables are SAVE_IMPLICIT and explicitly saved are\n+     initialized variables are SAVE_IMPLICIT and explicitly saved are\n      SAVE_EXPLICIT.  */\n   if (!sym->attr.use_assoc\n \t&& (sym->attr.save != SAVE_NONE || sym->attr.data\n@@ -1584,7 +1584,7 @@ create_function_arglist (gfc_symbol * sym)\n       if (f->sym->attr.proc_pointer)\n         type = build_pointer_type (type);\n \n-      /* Build a the argument declaration.  */\n+      /* Build the argument declaration.  */\n       parm = build_decl (PARM_DECL, gfc_sym_identifier (f->sym), type);\n \n       /* Fill in arg stuff.  */"}, {"sha": "b5c9cdda0c69497d67841a19ce899f41e5f0b098", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1927,7 +1927,7 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n \n   /* ...and to the expression's symbol, if it has one.  */\n   /* TODO Find out why the condition on expr->symtree had to be moved into\n-     the loop rather than being ouside it, as originally.  */\n+     the loop rather than being outside it, as originally.  */\n   for (sym = mapping->syms; sym; sym = sym->next)\n     if (expr->symtree && sym->old == expr->symtree->n.sym)\n       {\n@@ -2691,7 +2691,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n     {\n       if (se->direct_byref)\n \t{\n-\t  /* Sometimes, too much indirection can be applied; eg. for\n+\t  /* Sometimes, too much indirection can be applied; e.g. for\n \t     function_result = array_valued_recursive_function.  */\n \t  if (TREE_TYPE (TREE_TYPE (se->expr))\n \t\t&& TREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr)))\n@@ -3934,7 +3934,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \n \n /* Makes sure se is suitable for passing as a function string parameter.  */\n-/* TODO: Need to check all callers fo this function.  It may be abused.  */\n+/* TODO: Need to check all callers of this function.  It may be abused.  */\n \n void\n gfc_conv_string_parameter (gfc_se * se)"}, {"sha": "92bc0bb6d5124204063948dda9f4bd96b970e631", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -2754,7 +2754,7 @@ gfc_conv_intrinsic_index_scan_verify (gfc_se * se, gfc_expr * expr,\n   args = (tree *) alloca (sizeof (tree) * 5);\n \n   /* Get number of arguments; characters count double due to the\n-     string length argument. Kind= is not passed to the libary\n+     string length argument. Kind= is not passed to the library\n      and thus ignored.  */\n   if (expr->value.function.actual->next->next->expr == NULL)\n     num_args = 4;\n@@ -4666,7 +4666,7 @@ gfc_walk_intrinsic_libfunc (gfc_ss * ss, gfc_expr * expr)\n }\n \n \n-/* Returns nonzero if the specified intrinsic function call maps directly to a\n+/* Returns nonzero if the specified intrinsic function call maps directly to\n    an external library call.  Should only be used for functions that return\n    arrays.  */\n "}, {"sha": "2928cc68bf268c89a74c4e54421160a50c6e88fc", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -361,7 +361,7 @@ gfc_init_kinds (void)\n       if (kind == 16)\n \tsaw_r16 = true;\n \n-      /* Careful we don't stumble a wierd internal mode.  */\n+      /* Careful we don't stumble a weird internal mode.  */\n       gcc_assert (r_index <= 0 || gfc_real_kinds[r_index-1].kind != kind);\n       /* Or have too many modes for the allocated space.  */\n       gcc_assert (r_index != MAX_REAL_KINDS);\n@@ -393,7 +393,7 @@ gfc_init_kinds (void)\n       gfc_default_integer_kind = 8;\n \n       /* Even if the user specified that the default integer kind be 8,\n-         the numerica storage size isn't 64.  In this case, a warning will\n+         the numeric storage size isn't 64.  In this case, a warning will\n \t be issued when NUMERIC_STORAGE_SIZE is used.  */\n       gfc_numeric_storage_size = 4 * 8;\n     }\n@@ -1065,8 +1065,8 @@ gfc_get_element_type (tree type)\n    ARRAYS comment.\n \n    The data component points to the first element in the array.  The\n-   offset field is the position of the origin of the array (ie element\n-   (0, 0 ...)).  This may be outsite the bounds of the array.\n+   offset field is the position of the origin of the array (i.e. element\n+   (0, 0 ...)).  This may be outside the bounds of the array.\n \n    An element is accessed by\n     data[offset + index0*stride0 + index1*stride1 + index2*stride2]\n@@ -1078,7 +1078,7 @@ gfc_get_element_type (tree type)\n    elements of the origin (2^63 on 64-bit machines).  For example\n     integer, dimension (80000:90000, 80000:90000, 2) :: array\n    may not work properly on 32-bit machines because 80000*80000 >\n-   2^31, so the calculation for stride02 would overflow.  This may\n+   2^31, so the calculation for stride2 would overflow.  This may\n    still work, but I haven't checked, and it relies on the overflow\n    doing the right thing.\n \n@@ -2163,7 +2163,7 @@ gfc_type_for_size (unsigned bits, int unsignedp)\n \t}\n \n       /* Handle TImode as a special case because it is used by some backends\n-         (eg. ARM) even though it is not available for normal use.  */\n+         (e.g. ARM) even though it is not available for normal use.  */\n #if HOST_BITS_PER_WIDE_INT >= 64\n       if (bits == TYPE_PRECISION (intTI_type_node))\n \treturn intTI_type_node;"}, {"sha": "1db628eff423b49e2549f57238f85ade3abe9d5e", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -129,7 +129,7 @@ gfc_create_var (tree type, const char *prefix)\n }\n \n \n-/* If the an expression is not constant, evaluate it now.  We assign the\n+/* If the expression is not constant, evaluate it now.  We assign the\n    result of the expression to an artificially created variable VAR, and\n    return a pointer to the VAR_DECL node for this variable.  */\n "}, {"sha": "98002a9f2f739a453acdeab300037bc1c1fb8c0f", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1,5 +1,5 @@\n /* Header for code translation functions\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n    Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -137,7 +137,7 @@ typedef enum\n   /* A non-elemental function call returning an array.  The call is executed\n      before entering the scalarization loop, storing the result in a\n      temporary.  This temporary is then used inside the scalarization loop.\n-     Simple assignments, eg. a(:) = fn() are handles without a temporary\n+     Simple assignments, e.g. a(:) = fn(), are handled without a temporary\n      as a special case.  */\n   GFC_SS_FUNCTION,\n \n@@ -654,7 +654,7 @@ struct lang_decl\t\tGTY(())\n #define GFC_TYPE_ARRAY_SIZE(node) (TYPE_LANG_SPECIFIC(node)->size)\n #define GFC_TYPE_ARRAY_OFFSET(node) (TYPE_LANG_SPECIFIC(node)->offset)\n #define GFC_TYPE_ARRAY_AKIND(node) (TYPE_LANG_SPECIFIC(node)->akind)\n-/* Code should use gfc_get_dtype instead of accesing this directly.  It may\n+/* Code should use gfc_get_dtype instead of accessing this directly.  It may\n    not be known when the type is created.  */\n #define GFC_TYPE_ARRAY_DTYPE(node) (TYPE_LANG_SPECIFIC(node)->dtype)\n #define GFC_TYPE_ARRAY_DATAPTR_TYPE(node) \\"}, {"sha": "2e53d3a5111db38ac0302b6d2bed2dc7cd7446ab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -1,3 +1,7 @@\n+2008-07-21  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n+\n+\t* gfortran.dg/fmt_g0_3.f08: Fix typo in expected error message.\n+\n 2008-07-21  Paolo Carlini  <paolo.carlini@oracle.com>\n \n         PR c++/36871"}, {"sha": "b0b8139a3f3c21ed59842bf8e3eb3c3989e8b68b", "filename": "gcc/testsuite/gfortran.dg/fmt_g0_3.f08", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_g0_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df2fba9e343385222745d9e99cbaae29026a263d/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_g0_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_g0_3.f08?ref=df2fba9e343385222745d9e99cbaae29026a263d", "patch": "@@ -3,5 +3,5 @@\n ! Test case provided by Jerry DeLisle <jvdelisle@gcc.gnu.org>\n     character(25) :: string = \"(g0,g0,g0)\" \n     character(33) :: buffer\n-    write(buffer, '(g0,g0,g0)') ':',12340,':' ! { dg-error \"Fortran F2008:\" }\n+    write(buffer, '(g0,g0,g0)') ':',12340,':' ! { dg-error \"Fortran 2008:\" }\n end"}]}