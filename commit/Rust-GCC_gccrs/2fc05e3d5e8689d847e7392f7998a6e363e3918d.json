{"sha": "2fc05e3d5e8689d847e7392f7998a6e363e3918d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZjMDVlM2Q1ZTg2ODlkODQ3ZTczOTJmNzk5OGE2ZTM2M2UzOTE4ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T15:57:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T15:57:44Z"}, "message": "[multiple changes]\n\n2009-04-07  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb:\n\t(Expand_N_Op_Concat): Call Expand_Concatenate for all cases\n\t(Expand_Concatenate): New name for Expand_Concatenate_String which has\n\tbeen rewritten to handle all types.\n\t(Expand_Concatenate_Other): Remove\n\n2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* lib-xref.adb (Generate_Reference): A default subprogram in an\n\tinstance appears within the tree for the instance, but generates an\n\timplicit reference in the ALI.\n\nFrom-SVN: r145686", "tree": {"sha": "84629507e1f955c284edab8d68d26c389ce5eab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84629507e1f955c284edab8d68d26c389ce5eab0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fc05e3d5e8689d847e7392f7998a6e363e3918d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fc05e3d5e8689d847e7392f7998a6e363e3918d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fc05e3d5e8689d847e7392f7998a6e363e3918d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fc05e3d5e8689d847e7392f7998a6e363e3918d/comments", "author": null, "committer": null, "parents": [{"sha": "dc5e72981f0a2bc79f4c6975ad025239ee41a515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc5e72981f0a2bc79f4c6975ad025239ee41a515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc5e72981f0a2bc79f4c6975ad025239ee41a515"}], "stats": {"total": 94, "additions": 40, "deletions": 54}, "files": [{"sha": "664dfa8e7635da7e1d79ac63cbdb90ee8afccb38", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fc05e3d5e8689d847e7392f7998a6e363e3918d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fc05e3d5e8689d847e7392f7998a6e363e3918d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2fc05e3d5e8689d847e7392f7998a6e363e3918d", "patch": "@@ -1,3 +1,17 @@\n+2009-04-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb:\n+\t(Expand_N_Op_Concat): Call Expand_Concatenate for all cases\n+\t(Expand_Concatenate): New name for Expand_Concatenate_String which has\n+\tbeen rewritten to handle all types.\n+\t(Expand_Concatenate_Other): Remove\n+\n+2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* lib-xref.adb (Generate_Reference): A default subprogram in an\n+\tinstance appears within the tree for the instance, but generates an\n+\timplicit reference in the ALI.\n+\n 2009-04-07  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_ch3.adb (Build_Derived_Record_Type): When processing a tagged"}, {"sha": "27c450d01c31c42ee98a1ad85bf611e759ed1fd0", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 22, "deletions": 52, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fc05e3d5e8689d847e7392f7998a6e363e3918d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fc05e3d5e8689d847e7392f7998a6e363e3918d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=2fc05e3d5e8689d847e7392f7998a6e363e3918d", "patch": "@@ -2216,7 +2216,7 @@ package body Exp_Ch4 is\n \n       function To_Intyp (X : Node_Id) return Node_Id is\n       begin\n-         if Ityp = Intyp then\n+         if Base_Type (Ityp) = Base_Type (Intyp) then\n             return X;\n \n          elsif Is_Enumeration_Type (Ityp) then\n@@ -2237,10 +2237,7 @@ package body Exp_Ch4 is\n \n       function To_Ityp (X : Node_Id) return Node_Id is\n       begin\n-         if Intyp = Ityp then\n-            return X;\n-\n-         elsif Is_Enumeration_Type (Ityp) then\n+         if Is_Enumeration_Type (Ityp) then\n             return\n               Make_Attribute_Reference (Loc,\n                 Prefix         => New_Occurrence_Of (Ityp, Loc),\n@@ -2279,7 +2276,11 @@ package body Exp_Ch4 is\n                raise Concatenation_Error;\n \n             else\n-               return Convert_To (Ityp, X);\n+               if Base_Type (Ityp) = Base_Type (Intyp) then\n+                  return X;\n+               else\n+                  return Convert_To (Ityp, X);\n+               end if;\n             end if;\n          end if;\n       end To_Ityp;\n@@ -2316,57 +2317,26 @@ package body Exp_Ch4 is\n       if Is_Enumeration_Type (Ityp) then\n          Intyp := Standard_Integer;\n \n-      elsif Atyp = Standard_String then\n-         Intyp := Standard_Natural;\n-\n-      --  For unsigned types, we can safely use a 32-bit unsigned type for any\n-      --  type whose size is in the range 1-31 bits, and we can safely use a\n-      --  64-bit unsigned type for any type whose size is in the range 33-63\n-      --  bits. So those case are easy. For 64-bit unsigned types, there is no\n-      --  possible type to use, since the maximum length is 2**64 which is not\n-      --  representable in any type. We just use a 64-bit unsigned type anyway,\n-      --  and won't be able to handle objects that big, which is no loss in\n-      --  practice (we will raise CE in this case).\n-\n-      --  32-bit unsigned types are a bit of a problem. If we are on a 64-bit\n-      --  machine where 64-bit arithmetic is presumably efficient, then we can\n-      --  just use the 64-bit type. But we really hate to do that on a 32-bit\n-      --  machine since it could be quite inefficient. So on a 32-bit machine,\n-      --  we use the 32-bit unsigned type, and too bad if we can't handle\n-      --  arrays with 2**32 elements (the programmer can always get around\n-      --  this by using a 64-bit type as an index).\n-\n-      elsif Is_Unsigned_Type (Ityp) then\n-         if RM_Size (Ityp) < RM_Size (Standard_Unsigned) then\n-            Intyp := Standard_Unsigned;\n-\n-         elsif RM_Size (Ityp) = RM_Size (Standard_Unsigned)\n-           and then System_Address_Size = 32\n-         then\n-            Intyp := Ityp;\n+      --  For modular types, we use a 32-bit modular type for types whose size\n+      --  is in the range 1-31 bits. For 32-bit unsigned types, we use the\n+      --  identity type, and for larger unsigned types we use 64-bits.\n \n+      elsif Is_Modular_Integer_Type (Ityp) then\n+         if RM_Size (Base_Type (Ityp)) < RM_Size (Standard_Unsigned) then\n+            Intyp := Standard_Unsigned;\n+         elsif RM_Size (Base_Type (Ityp)) = RM_Size (Standard_Unsigned) then\n+            Intyp := Base_Type (Ityp);\n          else\n             Intyp := RTE (RE_Long_Long_Unsigned);\n          end if;\n \n-      --  For signed types, the considerations are similar to the unsigned case\n-      --  for types with sizes in the range 1-30 or 33-64, but now 30 and 31\n-      --  are both problems (the 31-bit type can have a length of 2**31 which\n-      --  is out of the range of standard integer), but again, we don't want\n-      --  the inefficiency of using 64-bit arithmetic on a 32-bit machine.\n+      --  Similar treatment for signed types\n \n       else\n-         if RM_Size (Ityp) < (RM_Size (Standard_Integer) - 1)\n-           or (RM_Size (Ityp) = (RM_Size (Standard_Integer) - 1)\n-                and then System_Address_Size = 32)\n-         then\n+         if RM_Size (Base_Type (Ityp)) < RM_Size (Standard_Integer) then\n             Intyp := Standard_Integer;\n-\n-         elsif RM_Size (Ityp) = RM_Size (Standard_Integer)\n-           and then System_Address_Size = 32\n-         then\n-            Intyp := Ityp;\n-\n+         elsif RM_Size (Base_Type (Ityp)) = RM_Size (Standard_Integer) then\n+            Intyp := Base_Type (Ityp);\n          else\n             Intyp := Standard_Long_Long_Integer;\n          end if;\n@@ -2395,10 +2365,10 @@ package body Exp_Ch4 is\n             Is_Fixed_Length (NN) := True;\n             Fixed_Length (NN) := Uint_1;\n \n-            --  Set lower bound to 1, that's right for characters, but is\n-            --  it really right for other types ???\n+            --  Set lower bound to lower bound of index subtype. This is not\n+            --  right where the index subtype bound is dynamic ???\n \n-            Fixed_Low_Bound (NN) := Uint_1;\n+            Fixed_Low_Bound (NN) := Expr_Value (Type_Low_Bound (Ityp));\n             Set := True;\n \n          --  String literal case (can only occur for strings of course)"}, {"sha": "04c39a5085d6ed5f4b1a39ed10770f95d844c3b2", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fc05e3d5e8689d847e7392f7998a6e363e3918d/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fc05e3d5e8689d847e7392f7998a6e363e3918d/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=2fc05e3d5e8689d847e7392f7998a6e363e3918d", "patch": "@@ -657,9 +657,11 @@ package body Lib.Xref is\n          and then Sloc (E) > No_Location\n          and then Sloc (N) > No_Location\n \n-         --  We ignore references from within an instance\n+         --  We ignore references from within an instance, except for default\n+         --  subprograms, for which we generate an implicit reference.\n \n-         and then Instantiation_Location (Sloc (N)) = No_Location\n+         and then\n+           (Instantiation_Location (Sloc (N)) = No_Location or else Typ = 'i')\n \n          --  Ignore dummy references\n "}]}