{"sha": "ae13fce333f73741790fef665546290509220093", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUxM2ZjZTMzM2Y3Mzc0MTc5MGZlZjY2NTU0NjI5MDUwOTIyMDA5Mw==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2014-07-24T14:39:07Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2014-07-24T14:39:07Z"}, "message": "[AArch64] Infrastructure to allow optional use of write back.\n\nFrom-SVN: r212997", "tree": {"sha": "5118e6668d97c0a145b04ec33c8e0d012217f578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5118e6668d97c0a145b04ec33c8e0d012217f578"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae13fce333f73741790fef665546290509220093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae13fce333f73741790fef665546290509220093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae13fce333f73741790fef665546290509220093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae13fce333f73741790fef665546290509220093/comments", "author": null, "committer": null, "parents": [{"sha": "363ffa50f1394a6eaaa137f7c5e63084b9fd4226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/363ffa50f1394a6eaaa137f7c5e63084b9fd4226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/363ffa50f1394a6eaaa137f7c5e63084b9fd4226"}], "stats": {"total": 53, "additions": 38, "deletions": 15}, "files": [{"sha": "fa627c5e562a0299c354236c94cc0fae0bf56bfe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae13fce333f73741790fef665546290509220093/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae13fce333f73741790fef665546290509220093/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae13fce333f73741790fef665546290509220093", "patch": "@@ -1,3 +1,9 @@\n+2014-07-24  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_restore_callee_saves)\n+\t(aarch64_save_callee_saves): New parameter \"skip_wb\".\n+\t(aarch64_expand_prologue, aarch64_expand_epilogue): Update call site.\n+\n 2014-07-24  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.h (frame): New fields \"wb_candidate1\" and"}, {"sha": "163dfcdca46b026f179d620abb4efbaf2d1404ff", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae13fce333f73741790fef665546290509220093/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae13fce333f73741790fef665546290509220093/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=ae13fce333f73741790fef665546290509220093", "patch": "@@ -2042,7 +2042,7 @@ aarch64_gen_load_pair (enum machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n \n static void\n aarch64_save_callee_saves (enum machine_mode mode, HOST_WIDE_INT start_offset,\n-\t\t\t   unsigned start, unsigned limit)\n+\t\t\t   unsigned start, unsigned limit, bool skip_wb)\n {\n   rtx insn;\n   rtx (*gen_mem_ref) (enum machine_mode, rtx) = (frame_pointer_needed\n@@ -2054,11 +2054,16 @@ aarch64_save_callee_saves (enum machine_mode mode, HOST_WIDE_INT start_offset,\n        regno <= limit;\n        regno = aarch64_next_callee_save (regno + 1, limit))\n     {\n-      rtx reg = gen_rtx_REG (mode, regno);\n-      rtx mem;\n+      rtx reg, mem;\n+      HOST_WIDE_INT offset;\n \n-      HOST_WIDE_INT offset = start_offset\n-\t\t\t     + cfun->machine->frame.reg_offset[regno];\n+      if (skip_wb\n+\t  && (regno == cfun->machine->frame.wb_candidate1\n+\t      || regno == cfun->machine->frame.wb_candidate2))\n+\tcontinue;\n+\n+      reg = gen_rtx_REG (mode, regno);\n+      offset = start_offset + cfun->machine->frame.reg_offset[regno];\n       mem = gen_mem_ref (mode, plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t      offset));\n \n@@ -2095,7 +2100,7 @@ aarch64_save_callee_saves (enum machine_mode mode, HOST_WIDE_INT start_offset,\n static void\n aarch64_restore_callee_saves (enum machine_mode mode,\n \t\t\t      HOST_WIDE_INT start_offset, unsigned start,\n-\t\t\t      unsigned limit)\n+\t\t\t      unsigned limit, bool skip_wb)\n {\n   rtx insn;\n   rtx base_rtx = stack_pointer_rtx;\n@@ -2109,9 +2114,14 @@ aarch64_restore_callee_saves (enum machine_mode mode,\n        regno <= limit;\n        regno = aarch64_next_callee_save (regno + 1, limit))\n     {\n-      rtx reg = gen_rtx_REG (mode, regno);\n-      rtx mem;\n+      rtx reg, mem;\n \n+      if (skip_wb\n+\t  && (regno == cfun->machine->frame.wb_candidate1\n+\t      || regno == cfun->machine->frame.wb_candidate2))\n+\tcontinue;\n+\n+      reg = gen_rtx_REG (mode, regno);\n       offset = start_offset + cfun->machine->frame.reg_offset[regno];\n       mem = gen_mem_ref (mode, plus_constant (Pmode, base_rtx, offset));\n \n@@ -2267,6 +2277,8 @@ aarch64_expand_prologue (void)\n \n   if (offset > 0)\n     {\n+      bool skip_wb = false;\n+\n       /* Save the frame pointer and lr if the frame pointer is needed\n \t first.  Make the frame pointer point to the location of the\n \t old frame pointer on the stack.  */\n@@ -2284,7 +2296,7 @@ aarch64_expand_prologue (void)\n \t\t\t\t\t\t      GEN_INT (offset))));\n \n \t      aarch64_save_callee_saves (DImode, fp_offset, R29_REGNUM,\n-\t\t\t\t\t R30_REGNUM);\n+\t\t\t\t\t R30_REGNUM, skip_wb);\n \t    }\n \t  else\n \t    aarch64_pushwb_pair_reg (DImode, R29_REGNUM, R30_REGNUM, offset);\n@@ -2303,18 +2315,21 @@ aarch64_expand_prologue (void)\n \t  insn = emit_insn (gen_stack_tie (stack_pointer_rtx,\n \t\t\t\t\t   hard_frame_pointer_rtx));\n \n-\t  aarch64_save_callee_saves (DImode, fp_offset, R0_REGNUM, R28_REGNUM);\n+\t  aarch64_save_callee_saves (DImode, fp_offset, R0_REGNUM, R28_REGNUM,\n+\t\t\t\t     skip_wb);\n \t}\n       else\n \t{\n \t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n \t\t\t\t\t   GEN_INT (-offset)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \n-\t  aarch64_save_callee_saves (DImode, fp_offset, R0_REGNUM, R30_REGNUM);\n+\t  aarch64_save_callee_saves (DImode, fp_offset, R0_REGNUM, R30_REGNUM,\n+\t\t\t\t     skip_wb);\n \t}\n \n-      aarch64_save_callee_saves (DFmode, fp_offset, V0_REGNUM, V31_REGNUM);\n+      aarch64_save_callee_saves (DFmode, fp_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t\t skip_wb);\n     }\n \n   /* when offset >= 512,\n@@ -2339,6 +2354,7 @@ aarch64_expand_epilogue (bool for_sibcall)\n   HOST_WIDE_INT fp_offset;\n   rtx insn;\n   rtx cfa_reg;\n+  bool skip_wb = false;\n \n   aarch64_layout_frame ();\n \n@@ -2387,20 +2403,21 @@ aarch64_expand_epilogue (bool for_sibcall)\n     }\n \n   aarch64_restore_callee_saves (DFmode, frame_pointer_needed ? 0 : fp_offset,\n-\t\t\t\tV0_REGNUM, V31_REGNUM);\n+\t\t\t\tV0_REGNUM, V31_REGNUM, skip_wb);\n \n   if (offset > 0)\n     {\n       if (frame_pointer_needed)\n \t{\n-\t  aarch64_restore_callee_saves (DImode, 0, R0_REGNUM, R28_REGNUM);\n+\t  aarch64_restore_callee_saves (DImode, 0, R0_REGNUM, R28_REGNUM,\n+\t\t\t\t\tskip_wb);\n \t  aarch64_popwb_pair_reg (DImode, R29_REGNUM, R30_REGNUM, offset,\n \t\t\t\t  cfa_reg);\n \t}\n       else\n \t{\n \t  aarch64_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n-\t\t\t\t\tR30_REGNUM);\n+\t\t\t\t\tR30_REGNUM, skip_wb);\n \t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n \t\t\t\t\t   GEN_INT (offset)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;"}]}