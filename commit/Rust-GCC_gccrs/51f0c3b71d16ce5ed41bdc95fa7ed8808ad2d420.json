{"sha": "51f0c3b71d16ce5ed41bdc95fa7ed8808ad2d420", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFmMGMzYjcxZDE2Y2U1ZWQ0MWJkYzk1ZmE3ZWQ4ODA4YWQyZDQyMA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-15T19:10:36Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-15T19:10:36Z"}, "message": "(emit_reload_insns): Call reload_reg_reaches_end_p for every reg of multi-reg spill register.\n\n(emit_reload_insns): Call reload_reg_reaches_end_p for\nevery reg of multi-reg spill register.  Invalidate old info for multi\nreg spill registers when only part survives to the end.\n\nFrom-SVN: r11801", "tree": {"sha": "824fb10e141de413c078e330d17414394a9c3465", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/824fb10e141de413c078e330d17414394a9c3465"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51f0c3b71d16ce5ed41bdc95fa7ed8808ad2d420", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51f0c3b71d16ce5ed41bdc95fa7ed8808ad2d420", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51f0c3b71d16ce5ed41bdc95fa7ed8808ad2d420", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51f0c3b71d16ce5ed41bdc95fa7ed8808ad2d420/comments", "author": null, "committer": null, "parents": [{"sha": "9cca6a99da69dc2326806259f9c39e8082fc6463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cca6a99da69dc2326806259f9c39e8082fc6463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cca6a99da69dc2326806259f9c39e8082fc6463"}], "stats": {"total": 192, "additions": 112, "deletions": 80}, "files": [{"sha": "09922ce2adc6ee828aa347d212169389450f0836", "filename": "gcc/reload1.c", "status": "modified", "additions": 112, "deletions": 80, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f0c3b71d16ce5ed41bdc95fa7ed8808ad2d420/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f0c3b71d16ce5ed41bdc95fa7ed8808ad2d420/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=51f0c3b71d16ce5ed41bdc95fa7ed8808ad2d420", "patch": "@@ -6588,107 +6588,139 @@ emit_reload_insns (insn)\n \n       /* I is nonneg if this reload used one of the spill regs.\n \t If reload_reg_rtx[r] is 0, this is an optional reload\n-\t that we opted to ignore.\n-\n-\t Also ignore reloads that don't reach the end of the insn,\n-\t since we will eventually see the one that does.  */\n+\t that we opted to ignore.  */\n \n-      if (i >= 0 && reload_reg_rtx[r] != 0\n-\t  && reload_reg_reaches_end_p (spill_regs[i], reload_opnum[r],\n-\t\t\t\t       reload_when_needed[r]))\n+      if (i >= 0 && reload_reg_rtx[r] != 0)\n \t{\n-\t  /* First, clear out memory of what used to be in this spill reg.\n-\t     If consecutive registers are used, clear them all.  */\n \t  int nr\n \t    = HARD_REGNO_NREGS (spill_regs[i], GET_MODE (reload_reg_rtx[r]));\n \t  int k;\n+\t  int part_reaches_end = 0;\n+\t  int all_reaches_end = 1;\n \n+\t  /* For a multi register reload, we need to check if all or part\n+\t     of the value lives to the end.  */\n \t  for (k = 0; k < nr; k++)\n \t    {\n-\t      reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]] = -1;\n-\t      reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = 0;\n+\t      if (reload_reg_reaches_end_p (spill_regs[i] + k, reload_opnum[r],\n+\t\t\t\t\t    reload_when_needed[r]))\n+\t\tpart_reaches_end = 1;\n+\t      else\n+\t\tall_reaches_end = 0;\n \t    }\n \n-\t  /* Maybe the spill reg contains a copy of reload_out.  */\n-\t  if (reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG)\n+\t  /* Ignore reloads that don't reach the end of the insn in\n+\t     entirety.  */\n+\t  if (all_reaches_end)\n \t    {\n-\t      register int nregno = REGNO (reload_out[r]);\n-\t      int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t : HARD_REGNO_NREGS (nregno,\n-\t\t\t\t\t     GET_MODE (reload_reg_rtx[r])));\n-\n-\t      spill_reg_store[i] = new_spill_reg_store[i];\n-\t      reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n-\n-\t      /* If NREGNO is a hard register, it may occupy more than\n-\t\t one register.  If it does, say what is in the \n-\t\t rest of the registers assuming that both registers\n-\t\t agree on how many words the object takes.  If not,\n-\t\t invalidate the subsequent registers.  */\n-\n-\t      if (nregno < FIRST_PSEUDO_REGISTER)\n-\t\tfor (k = 1; k < nnr; k++)\n-\t\t  reg_last_reload_reg[nregno + k]\n-\t\t    = (nr == nnr ? gen_rtx (REG,\n-\t\t\t\t\t    reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n-\t\t\t\t\t    REGNO (reload_reg_rtx[r]) + k)\n-\t\t       : 0);\n+\t      /* First, clear out memory of what used to be in this spill reg.\n+\t\t If consecutive registers are used, clear them all.  */\n \n-\t      /* Now do the inverse operation.  */\n \t      for (k = 0; k < nr; k++)\n \t\t{\n-\t\t  reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n-\t\t    = (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr ? nregno\n-\t\t       : nregno + k);\n-\t\t  reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = insn;\n+\t\t  reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]] = -1;\n+\t\t  reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = 0;\n \t\t}\n-\t    }\n-\n-\t  /* Maybe the spill reg contains a copy of reload_in.  Only do\n-\t     something if there will not be an output reload for\n-\t     the register being reloaded.  */\n-\t  else if (reload_out[r] == 0\n-\t\t   && reload_in[r] != 0\n-\t\t   && ((GET_CODE (reload_in[r]) == REG\n-\t\t\t&& ! reg_has_output_reload[REGNO (reload_in[r])])\n-\t\t       || (GET_CODE (reload_in_reg[r]) == REG\n-\t\t\t   && ! reg_has_output_reload[REGNO (reload_in_reg[r])])))\n-\t    {\n-\t      register int nregno;\n-\t      int nnr;\n \n-\t      if (GET_CODE (reload_in[r]) == REG)\n-\t\tnregno = REGNO (reload_in[r]);\n-\t      else\n-\t\tnregno = REGNO (reload_in_reg[r]);\n-\n-\t      nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t     : HARD_REGNO_NREGS (nregno,\n-\t\t\t\t\t GET_MODE (reload_reg_rtx[r])));\n+\t      /* Maybe the spill reg contains a copy of reload_out.  */\n+\t      if (reload_out[r] != 0 && GET_CODE (reload_out[r]) == REG)\n+\t\t{\n+\t\t  register int nregno = REGNO (reload_out[r]);\n+\t\t  int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n+\t\t\t     : HARD_REGNO_NREGS (nregno,\n+\t\t\t\t\t\t GET_MODE (reload_reg_rtx[r])));\n+\n+\t\t  spill_reg_store[i] = new_spill_reg_store[i];\n+\t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n+\n+\t\t  /* If NREGNO is a hard register, it may occupy more than\n+\t\t     one register.  If it does, say what is in the \n+\t\t     rest of the registers assuming that both registers\n+\t\t     agree on how many words the object takes.  If not,\n+\t\t     invalidate the subsequent registers.  */\n+\n+\t\t  if (nregno < FIRST_PSEUDO_REGISTER)\n+\t\t    for (k = 1; k < nnr; k++)\n+\t\t      reg_last_reload_reg[nregno + k]\n+\t\t\t= (nr == nnr\n+\t\t\t   ? gen_rtx (REG,\n+\t\t\t\t      reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n+\t\t\t\t      REGNO (reload_reg_rtx[r]) + k)\n+\t\t\t   : 0);\n+\n+\t\t  /* Now do the inverse operation.  */\n+\t\t  for (k = 0; k < nr; k++)\n+\t\t    {\n+\t\t      reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n+\t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr\n+\t\t\t   ? nregno\n+\t\t\t   : nregno + k);\n+\t\t      reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = insn;\n+\t\t    }\n+\t\t}\n \n-\t      reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n+\t      /* Maybe the spill reg contains a copy of reload_in.  Only do\n+\t\t something if there will not be an output reload for\n+\t\t the register being reloaded.  */\n+\t      else if (reload_out[r] == 0\n+\t\t       && reload_in[r] != 0\n+\t\t       && ((GET_CODE (reload_in[r]) == REG\n+\t\t\t    && ! reg_has_output_reload[REGNO (reload_in[r])])\n+\t\t\t   || (GET_CODE (reload_in_reg[r]) == REG\n+\t\t\t       && ! reg_has_output_reload[REGNO (reload_in_reg[r])])))\n+\t\t{\n+\t\t  register int nregno;\n+\t\t  int nnr;\n \n-\t      if (nregno < FIRST_PSEUDO_REGISTER)\n-\t\tfor (k = 1; k < nnr; k++)\n-\t\t  reg_last_reload_reg[nregno + k]\n-\t\t    = (nr == nnr ? gen_rtx (REG,\n-\t\t\t\t\t    reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n-\t\t\t\t\t    REGNO (reload_reg_rtx[r]) + k)\n-\t\t       : 0);\n+\t\t  if (GET_CODE (reload_in[r]) == REG)\n+\t\t    nregno = REGNO (reload_in[r]);\n+\t\t  else\n+\t\t    nregno = REGNO (reload_in_reg[r]);\n \n-\t      /* Unless we inherited this reload, show we haven't\n-\t\t recently done a store.  */\n-\t      if (! reload_inherited[r])\n-\t\tspill_reg_store[i] = 0;\n+\t\t  nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n+\t\t\t : HARD_REGNO_NREGS (nregno,\n+\t\t\t\t\t     GET_MODE (reload_reg_rtx[r])));\n+\t\t  \n+\t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n+\n+\t\t  if (nregno < FIRST_PSEUDO_REGISTER)\n+\t\t    for (k = 1; k < nnr; k++)\n+\t\t      reg_last_reload_reg[nregno + k]\n+\t\t\t= (nr == nnr\n+\t\t\t   ? gen_rtx (REG,\n+\t\t\t\t      reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n+\t\t\t\t      REGNO (reload_reg_rtx[r]) + k)\n+\t\t\t   : 0);\n+\n+\t\t  /* Unless we inherited this reload, show we haven't\n+\t\t     recently done a store.  */\n+\t\t  if (! reload_inherited[r])\n+\t\t    spill_reg_store[i] = 0;\n+\n+\t\t  for (k = 0; k < nr; k++)\n+\t\t    {\n+\t\t      reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n+\t\t\t= (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr\n+\t\t\t   ? nregno\n+\t\t\t   : nregno + k);\n+\t\t      reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]]\n+\t\t\t= insn;\n+\t\t    }\n+\t\t}\n+\t    }\n \n+\t  /* However, if part of the reload reaches the end, then we must\n+\t     invalidate the old info for the part that survives to the end.  */\n+\t  else if (part_reaches_end)\n+\t    {\n \t      for (k = 0; k < nr; k++)\n-\t\t{\n-\t\t  reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n-\t\t    = (nregno >= FIRST_PSEUDO_REGISTER || nr != nnr ? nregno\n-\t\t       : nregno + k);\n-\t\t  reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]]\n-\t\t    = insn;\n-\t\t}\n+\t\tif (reload_reg_reaches_end_p (spill_regs[i] + k,\n+\t\t\t\t\t      reload_opnum[r],\n+\t\t\t\t\t      reload_when_needed[r]))\n+\t\t  {\n+\t\t    reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]] = -1;\n+\t\t    reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]] = 0;\n+\t\t  }\n \t    }\n \t}\n "}]}