{"sha": "5f251c2603135f0565ac08898410d795dff8e8d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyNTFjMjYwMzEzNWYwNTY1YWMwODg5ODQxMGQ3OTVkZmY4ZThkMA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2004-05-30T10:49:50Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-05-30T10:49:50Z"}, "message": "iresolve.c (gfc_resolve_random_number): Clean up conditional.\n\n\t* iresolve.c (gfc_resolve_random_number): Clean up conditional.\nlibgfortran/\n\t* libgfortran.h (random_seed): Update prototype.\n\t* intrinsics/random.c: Disable old implementation and add new one.\ntestsuite/\n\t* gfortran.fortran-torture/execute/random_1.f90: New test.\n\nFrom-SVN: r82443", "tree": {"sha": "c7388f0241ffd16eefa7c8649497e527ecdcbeba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7388f0241ffd16eefa7c8649497e527ecdcbeba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f251c2603135f0565ac08898410d795dff8e8d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f251c2603135f0565ac08898410d795dff8e8d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f251c2603135f0565ac08898410d795dff8e8d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f251c2603135f0565ac08898410d795dff8e8d0/comments", "author": null, "committer": null, "parents": [{"sha": "ebeb17c7bb8d07d412b5f02786fb79b0ab0ad2b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebeb17c7bb8d07d412b5f02786fb79b0ab0ad2b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebeb17c7bb8d07d412b5f02786fb79b0ab0ad2b9"}], "stats": {"total": 399, "additions": 382, "deletions": 17}, "files": [{"sha": "3bc180987718e721fc8bf7d918ebb93dd6ab5ada", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f251c2603135f0565ac08898410d795dff8e8d0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f251c2603135f0565ac08898410d795dff8e8d0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5f251c2603135f0565ac08898410d795dff8e8d0", "patch": "@@ -1,3 +1,7 @@\n+2004-05-30  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* iresolve.c (gfc_resolve_random_number): Clean up conditional.\n+\n 2004-05-29  Steven G. Kargl  <kargls@comcast.net>\n \n \t* simplify.c (gfc_simplify_log): Remove useless line of code."}, {"sha": "f1da7329c48984c637439e16c834245f476e215b", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f251c2603135f0565ac08898410d795dff8e8d0/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f251c2603135f0565ac08898410d795dff8e8d0/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=5f251c2603135f0565ac08898410d795dff8e8d0", "patch": "@@ -1363,12 +1363,15 @@ gfc_resolve_random_number (gfc_code * c ATTRIBUTE_UNUSED)\n   int kind;\n \n   kind = c->ext.actual->expr->ts.kind;\n-  name = gfc_get_string ((c->ext.actual->expr->rank == 0) ?\n-\t\t\t   PREFIX(\"random_r%d\") : PREFIX(\"arandom_r%d\"),\n-\t\t\t kind);\n+  if (c->ext.actual->expr->rank == 0)\n+    name = gfc_get_string (PREFIX(\"random_r%d\"), kind);\n+  else\n+    name = gfc_get_string (PREFIX(\"arandom_r%d\"), kind);\n+  \n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n+\n /* Determine if the arguments to SYSTEM_CLOCK are INTEGER(4) or INTEGER(8) */\n \n void"}, {"sha": "0535cfe5ce3c8d868cbcf676eae4819aad2dab60", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f251c2603135f0565ac08898410d795dff8e8d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f251c2603135f0565ac08898410d795dff8e8d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f251c2603135f0565ac08898410d795dff8e8d0", "patch": "@@ -1,3 +1,7 @@\n+2004-05-30  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* gfortran.fortran-torture/execute/random_1.f90: New test.\n+\n 2004-05-28  Ziemowit Laski  <zlaski@apple.com>\n \n \t* g++.dg/ext/altivec-10.C: New test."}, {"sha": "900a724da6cd7df53b97d30cc7cfbb62cedf48f4", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/random_1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f251c2603135f0565ac08898410d795dff8e8d0/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Frandom_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f251c2603135f0565ac08898410d795dff8e8d0/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Frandom_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Frandom_1.f90?ref=5f251c2603135f0565ac08898410d795dff8e8d0", "patch": "@@ -0,0 +1,33 @@\n+! PR15619\n+! Check that random_seed works as expected.\n+! Does not check the quality of random numbers, hence should never fail.\n+program test_random\n+  implicit none\n+  integer, allocatable :: seed(:)\n+  real, dimension(10) :: a, b\n+  integer n; \n+\n+  call random_seed (size=n)\n+  allocate (seed(n))\n+  \n+  ! Exercise the generator a bit.\n+  call random_number (a)\n+\n+  ! Remeber the seed and get 10 more.\n+  call random_seed (get=seed)\n+  call random_number (a)\n+\n+  ! Get the same 10 numbers in two blocks, remebering the seed in the middle\n+  call random_seed (put=seed)\n+  call random_number (b(1:5))\n+  call random_seed(get=seed)\n+  call random_number (b(6:10))\n+  if (any (a .ne. b)) call abort\n+\n+  ! Get the last 5 numbers again.\n+  call random_seed (put=seed)\n+  call random_number (b(6:10))\n+  if (any (a .ne. b)) call abort\n+end program\n+\n+"}, {"sha": "def98c626702f0ddd90973ce000188947c736a4e", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f251c2603135f0565ac08898410d795dff8e8d0/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f251c2603135f0565ac08898410d795dff8e8d0/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5f251c2603135f0565ac08898410d795dff8e8d0", "patch": "@@ -1,3 +1,8 @@\n+2004-05-30  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* libgfortran.h (random_seed): Update prototype.\n+\t* intrinsics/random.c: Disable old implementation and add new one.\n+\n 2004-05-30  Andreas Jaeger  <aj@suse.de>\n \n \t* intrinsics/random.c: Include unistd.h for close and read"}, {"sha": "bfda3437f91de2046cf96e1a6bc01d9de969212d", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 328, "deletions": 12, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f251c2603135f0565ac08898410d795dff8e8d0/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f251c2603135f0565ac08898410d795dff8e8d0/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=5f251c2603135f0565ac08898410d795dff8e8d0", "patch": "@@ -1,18 +1,7 @@\n /* Implementation of the RANDOM intrinsics\n    Copyright 2002, 2004 Free Software Foundation, Inc.\n    Contributed by Lars Segerlund <seger@linuxmail.org>\n-\n-  The algorithm was taken from the paper :\n-\n-\tMersenne Twister:\t623-dimensionally equidistributed\n-\t\t\t\tuniform pseudorandom generator.\n-\n-\tby:\tMakoto Matsumoto\n-\t\tTakuji Nishimura\n-\n-\tWhich appeared in the: ACM Transactions on Modelling and Computer\n-\tSimulations: Special Issue on Uniform Random Number\n-\tGeneration. ( Early in 1998 ).\n+   and Steve Kargl.\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -31,6 +20,31 @@ License along with libgfor; see the file COPYING.LIB.  If not,\n write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#if 0\n+\n+/*  The Mersenne Twister code is currently commented out due to\n+\n+    (1) Simple user specified seeds lead to really bad sequences for\n+        nearly 100000 random numbers.\n+    (2) open(), read(), and close() are not properly declared via header\n+        files.\n+    (3) The global index i is abused and causes unexpected behavior with\n+        GET and PUT.\n+    (4) See PR 15619.\n+\n+  The algorithm was taken from the paper :\n+\n+\tMersenne Twister:\t623-dimensionally equidistributed\n+\t\t\t\tuniform pseudorandom generator.\n+\n+\tby:\tMakoto Matsumoto\n+\t\tTakuji Nishimura\n+\n+\tWhich appeared in the: ACM Transactions on Modelling and Computer\n+\tSimulations: Special Issue on Uniform Random Number\n+\tGeneration. ( Early in 1998 ).  */\n+\n+\n #include \"config.h\"\n #include <stdio.h>\n #include <stdlib.h>\n@@ -362,4 +376,306 @@ arandom_r8 (gfc_array_r8 * harv)\n \t}\n     }\n }\n+#endif /* Mersenne Twister code */\n+\n+\n+/* George Marsaglia's KISS (Keep It Simple Stupid) random number generator.\n+\n+   This PRNG combines:\n+\n+   (1) The congruential generator x(n)=69069*x(n-1)+1327217885 with a period\n+       of 2^32,\n+   (2) A 3-shift shift-register generator with a period of 2^32-1,\n+   (3) Two 16-bit multiply-with-carry generators with a period of\n+       597273182964842497 > 2^59.\n+\n+   The overall period exceeds 2^123.\n+\n+   http://www.ciphersbyritter.com/NEWS4/RANDC.HTM#369F6FCA.74C7C041@stat.fsu.edu\n+\n+   The above web site has an archive of a newsgroup posting from George\n+   Marsaglia with the statement:\n+\n+   Subject: Random numbers for C: Improvements.\n+   Date: Fri, 15 Jan 1999 11:41:47 -0500\n+   From: George Marsaglia <geo@stat.fsu.edu>\n+   Message-ID: <369F6FCA.74C7C041@stat.fsu.edu>\n+   References: <369B5E30.65A55FD1@stat.fsu.edu>\n+   Newsgroups: sci.stat.math,sci.math,sci.math.numer-analysis\n+   Lines: 93\n+\n+   As I hoped, several suggestions have led to\n+   improvements in the code for RNG's I proposed for\n+   use in C. (See the thread \"Random numbers for C: Some\n+   suggestions\" in previous postings.) The improved code\n+   is listed below.\n+\n+   A question of copyright has also been raised.  Unlike\n+   DIEHARD, there is no copyright on the code below. You\n+   are free to use it in any way you want, but you may\n+   wish to acknowledge the source, as a courtesy.\n+\n+\"There is no copyright on the code below.\" included the original\n+KISS algorithm. */\n+\n+#include \"config.h\"\n+#include \"libgfortran.h\"\n+\n+#define GFC_SL(k, n)\t((k)^((k)<<(n)))\n+#define GFC_SR(k, n)\t((k)^((k)>>(n)))\n+\n+static const GFC_INTEGER_4 kiss_size = 4;\n+#define KISS_DEFAULT_SEED {123456789, 362436069, 521288629, 916191069};\n+static const GFC_UINTEGER_4 kiss_default_seed[4] = KISS_DEFAULT_SEED;\n+static GFC_UINTEGER_4 kiss_seed[4] = KISS_DEFAULT_SEED;\n+\n+/* kiss_random_kernel() returns an integer value in the range of\n+   (0, GFC_UINTEGER_4_HUGE].  The distribution of pseudorandom numbers\n+   should be uniform.  */\n+\n+static GFC_UINTEGER_4\n+kiss_random_kernel(void)\n+{\n+\n+  GFC_UINTEGER_4 kiss;\n+\n+  kiss_seed[0] = 69069 * kiss_seed[0] + 1327217885;\n+  kiss_seed[1] = GFC_SL(GFC_SR(GFC_SL(kiss_seed[1],13),17),5);\n+  kiss_seed[2] = 18000 * (kiss_seed[2] & 65535) + (kiss_seed[2] >> 16);\n+  kiss_seed[3] = 30903 * (kiss_seed[3] & 65535) + (kiss_seed[3] >> 16);\n+  kiss = kiss_seed[0] + kiss_seed[1] + (kiss_seed[2] << 16) + kiss_seed[3];\n+\n+  return kiss;\n+\n+}\n+\n+/*  This function produces a REAL(4) value in the uniform distribution\n+    with range [0,1).  */\n+\n+void\n+prefix(random_r4) (GFC_REAL_4 *x)\n+{\n+\n+  GFC_UINTEGER_4 kiss;\n+\n+  do\n+    {\n+      kiss = kiss_random_kernel ();\n+      *x = (GFC_REAL_4)kiss / (GFC_REAL_4)(~(GFC_UINTEGER_4) 0);\n+    }\n+  while (*x == 1.0);\n+\n+}\n+\n+/*  This function produces a REAL(8) value from the uniform distribution\n+    with range [0,1).  */\n+\n+void\n+prefix(random_r8) (GFC_REAL_8 *x)\n+{\n+\n+  GFC_UINTEGER_8 kiss;\n+\n+  do\n+    {\n+      kiss = (((GFC_UINTEGER_8)kiss_random_kernel ()) << 32)\n+\t     + kiss_random_kernel ();\n+      *x = (GFC_REAL_8)kiss / (GFC_REAL_8)(~(GFC_UINTEGER_8) 0);\n+    }\n+  while (*x != 0);\n+\n+}\n+\n+/*  This function fills a REAL(4) array with values from the uniform\n+    distribution with range [0,1).  */\n+\n+void\n+prefix(arandom_r4) (gfc_array_r4 *x)\n+{\n+\n+  index_type count[GFC_MAX_DIMENSIONS - 1];\n+  index_type extent[GFC_MAX_DIMENSIONS - 1];\n+  index_type stride[GFC_MAX_DIMENSIONS - 1];\n+  index_type stride0;\n+  index_type dim;\n+  GFC_REAL_4 *dest;\n+  int n;\n+\n+  dest = x->data;\n+\n+  if (x->dim[0].stride == 0)\n+    x->dim[0].stride = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (x);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = x->dim[n].stride;\n+      extent[n] = x->dim[n].ubound + 1 - x->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      prefix(random_r4) (dest);\n+\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/*  This function fills a REAL(8) array with valuse from the uniform\n+    distribution with range [0,1).  */\n+\n+void\n+prefix(arandom_r8) (gfc_array_r8 *x)\n+{\n+\n+  index_type count[GFC_MAX_DIMENSIONS - 1];\n+  index_type extent[GFC_MAX_DIMENSIONS - 1];\n+  index_type stride[GFC_MAX_DIMENSIONS - 1];\n+  index_type stride0;\n+  index_type dim;\n+  GFC_REAL_8 *dest;\n+  int n;\n+\n+  dest = x->data;\n+\n+  if (x->dim[0].stride == 0)\n+    x->dim[0].stride = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (x);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = x->dim[n].stride;\n+      extent[n] = x->dim[n].ubound + 1 - x->dim[n].lbound;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      prefix(random_r8) (dest);\n+\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* prefix(random_seed) is used to seed the PRNG with either a default\n+   set of seeds or user specified set of seed.  prefix(random_seed) \n+   must be called with no argument or exactly one argument.  */\n+\n+void\n+random_seed (GFC_INTEGER_4 *size, gfc_array_i4 * put, \n+\t\t     gfc_array_i4 * get)\n+{\n+\n+  int i;\n+\n+  if (size == NULL && put == NULL && get == NULL)\n+    {\n+      /* From the standard: \"If no argument is present, the processor assigns\n+         a processor-dependent value to the seed.\" */\n+      kiss_seed[0] = kiss_default_seed[0];\n+      kiss_seed[1] = kiss_default_seed[1];\n+      kiss_seed[2] = kiss_default_seed[2];\n+      kiss_seed[3] = kiss_default_seed[3];\n+    }\n+\n+  if (size != NULL)\n+    *size = kiss_size;\n+\n+  if (put != NULL)\n+    {\n+      /* If the rank of the array is not 1, abort */\n+      if (GFC_DESCRIPTOR_RANK (put) != 1)\n+        runtime_error (\"Array rank of PUT is not 1.\");\n+\n+      /* If the array is too small, abort */\n+      if (((put->dim[0].ubound + 1 - put->dim[0].lbound)) < kiss_size)\n+        runtime_error (\"Array size of PUT is too small.\");\n+\n+      if (put->dim[0].stride == 0)\n+\tput->dim[0].stride = 1;\n+\n+      /*  This code now should do correct strides. */\n+      for (i = 0; i < kiss_size; i++)\n+        kiss_seed[i] =(GFC_UINTEGER_4) put->data[i * put->dim[0].stride];\n+    }\n+\n+  /* Return the seed to GET data */\n+  if (get != NULL)\n+    {\n+      /* If the rank of the array is not 1, abort. */\n+      if (GFC_DESCRIPTOR_RANK (get) != 1)\n+\truntime_error (\"Array rank of GET is not 1.\");\n+\n+      /* If the array is too small, abort. */\n+      if (((get->dim[0].ubound + 1 - get->dim[0].lbound)) < kiss_size)\n+\truntime_error (\"Array size of GET is too small.\");\n+\n+      if (get->dim[0].stride == 0)\n+\tget->dim[0].stride = 1;\n+\n+      /*  This code now should do correct strides. */\n+      for (i = 0; i < kiss_size; i++)\n+        get->data[i * get->dim[0].stride] = (GFC_INTEGER_4) kiss_seed[i];\n+    }\n+}\n+\n "}, {"sha": "a4c27597280952bffa5662355d42689777de62ef", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f251c2603135f0565ac08898410d795dff8e8d0/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f251c2603135f0565ac08898410d795dff8e8d0/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=5f251c2603135f0565ac08898410d795dff8e8d0", "patch": "@@ -399,8 +399,8 @@ GFC_INTEGER_4 compare_string (GFC_INTEGER_4, const char *,\n /* random.c */\n \n #define random_seed prefix(random_seed)\n-void random_seed (GFC_INTEGER_4 * size, const gfc_array_i4 * put,\n-             const gfc_array_i4 * get);\n+void random_seed (GFC_INTEGER_4 * size, gfc_array_i4 * put,\n+\t\t  gfc_array_i4 * get);\n \n #endif\n "}]}