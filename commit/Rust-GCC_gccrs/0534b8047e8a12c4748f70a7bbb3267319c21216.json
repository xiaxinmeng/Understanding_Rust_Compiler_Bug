{"sha": "0534b8047e8a12c4748f70a7bbb3267319c21216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUzNGI4MDQ3ZThhMTJjNDc0OGY3MGE3YmJiMzI2NzMxOWMyMTIxNg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-01-25T22:49:56Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-01-25T22:49:56Z"}, "message": "loop.c (current_loop_info): Delete.\n\n2000-01-26  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n\n\t* loop.c (current_loop_info): Delete.\n\t(consec_sets_invariant_p): Add loop argument, update callers.\n\t(get_condition_for_loop): Likewise.\n\t(count_nonfixed_reads, update_giv_derive): Likewise.\n\t(simplify_giv_expr, general_induction_var): Likewise.\n\t(consec_sets_giv, recombine_givs): Likewise.\n\t(move_movables): Delete loop_start and loop_end arguments,\n\tadd loop argument, and update callers.\n\t(find_mem_givs, check_final_value): Likewise.\n\t(record_giv, maybe_eliminate_biv, maybe_eliminate_biv_1): Likewise.\n\t(loop_invariant_p): Rename from invariant_p, add loop argument, and\n\tupdate callers.\n\t(basic_induction_var): Add loop argument, delete loop_level argument,\n\tand update callers.\n\t* unroll.c (iteration_info): Delete loop_start and loop_end arguments,\n\tadd loop argument, and update callers.\n\t(find_splittable_regs, find_splittable_givs): Likewise.\n\t(reg_dead_after_loop, loop_find_equiv_value): Likewise.\n\t(final_biv_value, final_giv_value, back_branch_in_range_p): Likewise.\n\t(biv_total_increment): Delete loop_start and loop_end arguments;\n\tupdate callers.\n\t(precondition_loop_p): Delete loop_start and loop_info arguments;\n\tupdate callers.\n\t* loop.h (get_condition_for_loop): Add loop argument.\n\t(biv_total_increment): Delete loop_start and loop_end arguments.\n\t(precondition_loop_p): Delete loop_start and loop_info arguments;\n\tadd loop argument.\n\t(final_biv_value): Delete loop_start and loop_end arguments;\n\tadd loop argument.\n\t(final_giv_value, back_branch_in_range_p): Likewise.\n\nFrom-SVN: r31618", "tree": {"sha": "485accfbaa9a9a0c623a1a52c041fc3b441001ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/485accfbaa9a9a0c623a1a52c041fc3b441001ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0534b8047e8a12c4748f70a7bbb3267319c21216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0534b8047e8a12c4748f70a7bbb3267319c21216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0534b8047e8a12c4748f70a7bbb3267319c21216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0534b8047e8a12c4748f70a7bbb3267319c21216/comments", "author": null, "committer": null, "parents": [{"sha": "8e46653128e8fdebfd07d72f8190cea7b632bec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e46653128e8fdebfd07d72f8190cea7b632bec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e46653128e8fdebfd07d72f8190cea7b632bec6"}], "stats": {"total": 683, "additions": 366, "deletions": 317}, "files": [{"sha": "f3c6842f5097f5de7ecff9e09252fd13aeca73b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0534b8047e8a12c4748f70a7bbb3267319c21216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0534b8047e8a12c4748f70a7bbb3267319c21216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0534b8047e8a12c4748f70a7bbb3267319c21216", "patch": "@@ -1,3 +1,36 @@\n+2000-01-26  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* loop.c (current_loop_info): Delete.\n+\t(consec_sets_invariant_p): Add loop argument, update callers.\n+\t(get_condition_for_loop): Likewise.\n+\t(count_nonfixed_reads, update_giv_derive): Likewise.\n+\t(simplify_giv_expr, general_induction_var): Likewise.\n+\t(consec_sets_giv, recombine_givs): Likewise.\n+\t(move_movables): Delete loop_start and loop_end arguments,\n+\tadd loop argument, and update callers.\n+\t(find_mem_givs, check_final_value): Likewise.\n+\t(record_giv, maybe_eliminate_biv, maybe_eliminate_biv_1): Likewise.\n+\t(loop_invariant_p): Rename from invariant_p, add loop argument, and\n+\tupdate callers.\n+\t(basic_induction_var): Add loop argument, delete loop_level argument,\n+\tand update callers.\n+\t* unroll.c (iteration_info): Delete loop_start and loop_end arguments,\n+\tadd loop argument, and update callers.\n+\t(find_splittable_regs, find_splittable_givs): Likewise.\n+\t(reg_dead_after_loop, loop_find_equiv_value): Likewise.\n+\t(final_biv_value, final_giv_value, back_branch_in_range_p): Likewise.\n+\t(biv_total_increment): Delete loop_start and loop_end arguments;\n+\tupdate callers.\n+\t(precondition_loop_p): Delete loop_start and loop_info arguments;\n+\tupdate callers.\n+\t* loop.h (get_condition_for_loop): Add loop argument.\n+\t(biv_total_increment): Delete loop_start and loop_end arguments.\n+\t(precondition_loop_p): Delete loop_start and loop_info arguments;\n+\tadd loop argument.\n+\t(final_biv_value): Delete loop_start and loop_end arguments;\n+\tadd loop argument.\n+\t(final_giv_value, back_branch_in_range_p): Likewise.\n+\n 2000-01-25  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* config/mips/mips.h (LEGITIMATE_CONSTANT_P): Fix for mips16."}, {"sha": "283e2194431d01c84a9c59551eeac35abe886235", "filename": "gcc/loop.c", "status": "modified", "additions": 222, "deletions": 207, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0534b8047e8a12c4748f70a7bbb3267319c21216/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0534b8047e8a12c4748f70a7bbb3267319c21216/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=0534b8047e8a12c4748f70a7bbb3267319c21216", "patch": "@@ -53,11 +53,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n \n-/* Information about the current loop being processed used to compute\n-   the number of loop iterations for loop unrolling and doloop\n-   optimization.  */\n-static struct loop_info *current_loop_info;\n-\n /* Vector mapping INSN_UIDs to luids.\n    The luids are like uids but increase monotonically always.\n    We use them to see whether a jump comes from outside a given loop.  */\n@@ -239,12 +234,13 @@ static void find_and_verify_loops PARAMS ((rtx, struct loops *));\n static void mark_loop_jump PARAMS ((rtx, struct loop *));\n static void prescan_loop PARAMS ((struct loop *));\n static int reg_in_basic_block_p PARAMS ((rtx, rtx));\n-static int consec_sets_invariant_p PARAMS ((rtx, int, rtx));\n+static int consec_sets_invariant_p PARAMS ((const struct loop *,\n+\t\t\t\t\t    rtx, int, rtx));\n static int labels_in_range_p PARAMS ((rtx, int));\n static void count_one_set PARAMS ((rtx, rtx, varray_type, rtx *));\n \n static void count_loop_regs_set PARAMS ((rtx, rtx, varray_type, varray_type,\n-\t\t\t\t       int *, int)); \n+\t\t\t\t\t int *, int)); \n static void note_addr_stored PARAMS ((rtx, rtx, void *));\n static void note_set_pseudo_multiple_uses PARAMS ((rtx, rtx, void *));\n static int loop_reg_used_before_p PARAMS ((const struct loop *, rtx, rtx));\n@@ -260,37 +256,49 @@ static void combine_movables PARAMS ((struct movable *, int));\n static int regs_match_p PARAMS ((rtx, rtx, struct movable *));\n static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movable *));\n static void add_label_notes PARAMS ((rtx, rtx));\n-static void move_movables PARAMS ((struct movable *, int, int, rtx, rtx, int));\n-static int count_nonfixed_reads PARAMS ((rtx));\n+static void move_movables PARAMS ((struct loop *loop, struct movable *, \n+\t\t\t\t   int, int, int));\n+static int count_nonfixed_reads PARAMS ((const struct loop *, rtx));\n static void strength_reduce PARAMS ((struct loop *, int, int, int));\n static void find_single_use_in_loop PARAMS ((rtx, rtx, varray_type));\n static int valid_initial_value_p PARAMS ((rtx, rtx, int, rtx));\n-static void find_mem_givs PARAMS ((rtx, rtx, int, int, rtx, rtx));\n-static void record_biv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx *, int, int, int));\n-static void check_final_value PARAMS ((struct induction *, rtx, rtx, \n-\t\t\t\t     unsigned HOST_WIDE_INT));\n-static void record_giv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, int, rtx *, rtx, rtx));\n-static void update_giv_derive PARAMS ((rtx));\n-static int basic_induction_var PARAMS ((rtx, enum machine_mode, rtx, rtx, int, rtx *, rtx *, rtx **, int *));\n-static rtx simplify_giv_expr PARAMS ((rtx, int *));\n-static int general_induction_var PARAMS ((rtx, rtx *, rtx *, rtx *, int, int *));\n-static int consec_sets_giv PARAMS ((int, rtx, rtx, rtx, rtx *, rtx *, rtx *));\n+static void find_mem_givs PARAMS ((const struct loop *, rtx, rtx, int, int));\n+static void record_biv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx *, \n+\t\t\t\tint, int, int));\n+static void check_final_value PARAMS ((const struct loop *,\n+\t\t\t\t       struct induction *));\n+static void record_giv PARAMS ((const struct loop *, struct induction *, \n+\t\t\t\trtx, rtx, rtx, rtx, rtx, int, enum g_types, \n+\t\t\t\tint, int, rtx *));\n+static void update_giv_derive PARAMS ((const struct loop *, rtx));\n+static int basic_induction_var PARAMS ((const struct loop *, rtx, \n+\t\t\t\t\tenum machine_mode, rtx, rtx,\n+\t\t\t\t\trtx *, rtx *, rtx **, int *));\n+static rtx simplify_giv_expr PARAMS ((const struct loop *, rtx, int *));\n+static int general_induction_var PARAMS ((const struct loop *loop, rtx, rtx *,\n+\t\t\t\t\t  rtx *, rtx *, int, int *));\n+static int consec_sets_giv PARAMS ((const struct loop *, int, rtx,\n+\t\t\t\t    rtx, rtx, rtx *, rtx *, rtx *));\n static int check_dbra_loop PARAMS ((struct loop *, int));\n static rtx express_from_1 PARAMS ((rtx, rtx, rtx));\n static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));\n static void combine_givs PARAMS ((struct iv_class *));\n struct recombine_givs_stats;\n-static int find_life_end PARAMS ((rtx, struct recombine_givs_stats *, rtx, rtx));\n-static void recombine_givs PARAMS ((struct iv_class *, rtx, rtx, int));\n+static int find_life_end PARAMS ((rtx, struct recombine_givs_stats *,\n+\t\t\t\t  rtx, rtx));\n+static void recombine_givs PARAMS ((const struct loop *, struct iv_class *,\n+\t\t\t\t    int));\n static int product_cheap_p PARAMS ((rtx, rtx));\n-static int maybe_eliminate_biv PARAMS ((struct iv_class *, rtx, rtx, int, int, int));\n-static int maybe_eliminate_biv_1 PARAMS ((rtx, rtx, struct iv_class *, int, rtx));\n+static int maybe_eliminate_biv PARAMS ((const struct loop *, struct iv_class *,\n+\t\t\t\t\tint, int, int));\n+static int maybe_eliminate_biv_1 PARAMS ((const struct loop *, rtx, rtx, \n+\t\t\t\t\t  struct iv_class *, int, rtx));\n static int last_use_this_basic_block PARAMS ((rtx, rtx));\n static void record_initial PARAMS ((rtx, rtx, void *));\n static void update_reg_last_use PARAMS ((rtx, rtx));\n static rtx next_insn_in_loop PARAMS ((const struct loop *, rtx));\n static void load_mems_and_recount_loop_regs_set PARAMS ((const struct loop*,\n-\t\t\t\t\t\t       int *));\n+\t\t\t\t\t\t\t int *));\n static void load_mems PARAMS ((const struct loop *));\n static int insert_loop_mem PARAMS ((rtx *, void *));\n static int replace_loop_mem PARAMS ((rtx *, void *));\n@@ -546,7 +554,7 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n \f\n /* Returns the next insn, in execution order, after INSN.  START and\n    END are the NOTE_INSN_LOOP_BEG and NOTE_INSN_LOOP_END for the loop,\n-   respectively.  LOOP_TOP, if non-NULL, is the top of the loop in the\n+   respectively.  LOOP->TOP, if non-NULL, is the top of the loop in the\n    insn-stream; it is used with loops that are entered near the\n    bottom.  */\n \n@@ -590,6 +598,9 @@ scan_loop (loop, unroll_p, bct_p)\n   register int i;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n+  /* Additional information about the current loop being processed\n+     that is used to compute the number of loop iterations for loop\n+     unrolling and doloop optimization.  */\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   rtx p;\n   /* 1 if we are scanning insns that could be executed zero times.  */\n@@ -619,7 +630,6 @@ scan_loop (loop, unroll_p, bct_p)\n   int loop_depth = 0;\n   int nregs;\n \n-  current_loop_info = loop_info;\n   loop->top = 0;\n \n   /* Determine whether this loop starts with a jump down to a test at\n@@ -827,14 +837,14 @@ scan_loop (loop, unroll_p, bct_p)\n \t       which was not created by the user and not used in an exit test.\n \t       That behavior is incorrect and was removed.  */\n \t    ;\n-\t  else if ((tem = invariant_p (src))\n+\t  else if ((tem = loop_invariant_p (loop, src))\n \t\t   && (dependencies == 0\n-\t\t       || (tem2 = invariant_p (dependencies)) != 0)\n+\t\t       || (tem2 = loop_invariant_p (loop, dependencies)) != 0)\n \t\t   && (VARRAY_INT (set_in_loop, \n \t\t\t\t   REGNO (SET_DEST (set))) == 1\n \t\t       || (tem1\n \t\t\t   = consec_sets_invariant_p \n-\t\t\t   (SET_DEST (set),\n+\t\t\t   (loop, SET_DEST (set),\n \t\t\t    VARRAY_INT (set_in_loop, REGNO (SET_DEST (set))),\n \t\t\t    p)))\n \t\t   /* If the insn can cause a trap (such as divide by zero),\n@@ -1109,8 +1119,7 @@ scan_loop (loop, unroll_p, bct_p)\n      optimizing for code size.  */\n \n   if (! optimize_size)\n-    move_movables (movables, threshold,\n-\t\t   insn_count, loop_start, loop_end, nregs);\n+    move_movables (loop, movables, threshold, insn_count, nregs);\n \n   /* Now candidates that still are negative are those not moved.\n      Change set_in_loop to indicate that those are not actually invariant.  */\n@@ -1123,7 +1132,8 @@ scan_loop (loop, unroll_p, bct_p)\n   load_mems_and_recount_loop_regs_set (loop, &insn_count);\n \n   for (update_start = loop_start;\n-       PREV_INSN (update_start) && GET_CODE (PREV_INSN (update_start)) != CODE_LABEL;\n+       PREV_INSN (update_start)\n+\t && GET_CODE (PREV_INSN (update_start)) != CODE_LABEL;\n        update_start = PREV_INSN (update_start))\n     ;\n   update_end = NEXT_INSN (loop_end);\n@@ -1702,17 +1712,18 @@ add_label_notes (x, insns)\n    other throughout.  */\n \n static void\n-move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n+move_movables (loop, movables, threshold, insn_count, nregs)\n+     struct loop *loop;\n      struct movable *movables;\n      int threshold;\n      int insn_count;\n-     rtx loop_start;\n-     rtx end;\n      int nregs;\n {\n   rtx new_start = 0;\n   register struct movable *m;\n   register rtx p;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n   /* Map of pseudo-register replacements to handle combining\n      when we move several insns that load the same value\n      into different pseudo-registers.  */\n@@ -1757,11 +1768,11 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \n       if (!m->done\n \t  && (! m->cond\n-\t      || (1 == invariant_p (m->set_src)\n+\t      || (1 == loop_invariant_p (loop, m->set_src)\n \t\t  && (m->dependencies == 0\n-\t\t      || 1 == invariant_p (m->dependencies))\n+\t\t      || 1 == loop_invariant_p (loop, m->dependencies))\n \t\t  && (m->consec == 0\n-\t\t      || 1 == consec_sets_invariant_p (m->set_dest,\n+\t\t      || 1 == consec_sets_invariant_p (loop, m->set_dest,\n \t\t\t\t\t\t       m->consec + 1,\n \t\t\t\t\t\t       m->insn))))\n \t  && (! m->forces || m->forces->done))\n@@ -2062,7 +2073,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t\t     like this as a result of record_jump_cond.  */\n \t\t      \n \t\t\t  if ((temp = find_reg_note (i1, REG_EQUAL, NULL_RTX))\n-\t\t\t      && ! invariant_p (XEXP (temp, 0)))\n+\t\t\t      && ! loop_invariant_p (loop, XEXP (temp, 0)))\n \t\t\t    remove_note (i1, temp);\n \t\t\t}\n \n@@ -2123,8 +2134,8 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t   We can't use the moved insn because it is out of range\n \t\t   in uid_luid.  Only the old insns have luids.  */\n \t\tREGNO_FIRST_UID (regno) = INSN_UID (loop_start);\n-\t      if (uid_luid[REGNO_LAST_UID (regno)] < INSN_LUID (end))\n-\t\tREGNO_LAST_UID (regno) = INSN_UID (end);\n+\t      if (uid_luid[REGNO_LAST_UID (regno)] < INSN_LUID (loop_end))\n+\t\tREGNO_LAST_UID (regno) = INSN_UID (loop_end);\n \n \t      /* Combine with this moved insn any other matching movables.  */\n \n@@ -2192,7 +2203,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \n   /* Go through all the instructions in the loop, making\n      all the register substitutions scheduled in REG_MAP.  */\n-  for (p = new_start; p != end; p = NEXT_INSN (p))\n+  for (p = new_start; p != loop_end; p = NEXT_INSN (p))\n     if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n \t|| GET_CODE (p) == CALL_INSN)\n       {\n@@ -2274,7 +2285,8 @@ replace_call_address (x, reg, addr)\n    in the rtx X.  */\n \n static int\n-count_nonfixed_reads (x)\n+count_nonfixed_reads (loop, x)\n+     const struct loop *loop;\n      rtx x;\n {\n   register enum rtx_code code;\n@@ -2299,8 +2311,8 @@ count_nonfixed_reads (x)\n       return 0;\n \n     case MEM:\n-      return ((invariant_p (XEXP (x, 0)) != 1)\n-\t      + count_nonfixed_reads (XEXP (x, 0)));\n+      return ((loop_invariant_p (loop, XEXP (x, 0)) != 1)\n+\t      + count_nonfixed_reads (loop, XEXP (x, 0)));\n       \n     default:\n       break;\n@@ -2311,12 +2323,12 @@ count_nonfixed_reads (x)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tvalue += count_nonfixed_reads (XEXP (x, i));\n-      else if (fmt[i] == 'E')\n+\tvalue += count_nonfixed_reads (loop, XEXP (x, i));\n+      if (fmt[i] == 'E')\n \t{\n \t  register int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    value += count_nonfixed_reads (XVECEXP (x, i, j));\n+\t    value += count_nonfixed_reads (loop, XVECEXP (x, i, j));\n \t}\n     }\n   return value;\n@@ -3189,7 +3201,8 @@ note_set_pseudo_multiple_uses (x, y, data)\n    anything stored in `loop_store_mems'.  */\n \n int\n-invariant_p (x)\n+loop_invariant_p (loop, x)\n+     const struct loop *loop;\n      register rtx x;\n {\n   register int i;\n@@ -3238,7 +3251,7 @@ invariant_p (x)\n \t  && ! current_function_has_nonlocal_goto)\n \treturn 1;\n \n-      if (current_loop_info->has_call\n+      if (LOOP_INFO (loop)->has_call\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER && call_used_regs[REGNO (x)])\n \treturn 0;\n \n@@ -3292,7 +3305,7 @@ invariant_p (x)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  int tem = invariant_p (XEXP (x, i));\n+\t  int tem = loop_invariant_p (loop, XEXP (x, i));\n \t  if (tem == 0)\n \t    return 0;\n \t  if (tem == 2)\n@@ -3303,7 +3316,7 @@ invariant_p (x)\n \t  register int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-\t      int tem = invariant_p (XVECEXP (x, i, j));\n+\t      int tem = loop_invariant_p (loop, XVECEXP (x, i, j));\n \t      if (tem == 0)\n \t\treturn 0;\n \t      if (tem == 2)\n@@ -3328,7 +3341,8 @@ invariant_p (x)\n    and that its source is invariant.  */\n \n static int\n-consec_sets_invariant_p (reg, n_sets, insn)\n+consec_sets_invariant_p (loop, reg, n_sets, insn)\n+     const struct loop *loop;\n      int n_sets;\n      rtx reg, insn;\n {\n@@ -3365,7 +3379,7 @@ consec_sets_invariant_p (reg, n_sets, insn)\n \t  && GET_CODE (SET_DEST (set)) == REG\n \t  && REGNO (SET_DEST (set)) == regno)\n \t{\n-\t  this = invariant_p (SET_SRC (set));\n+\t  this = loop_invariant_p (loop, SET_SRC (set));\n \t  if (this != 0)\n \t    value |= this;\n \t  else if ((temp = find_reg_note (p, REG_EQUAL, NULL_RTX)))\n@@ -3375,7 +3389,7 @@ consec_sets_invariant_p (reg, n_sets, insn)\n \t\t notes are OK.  */\n \t      this = (CONSTANT_P (XEXP (temp, 0))\n \t\t      || (find_reg_note (p, REG_RETVAL, NULL_RTX)\n-\t\t\t  && invariant_p (XEXP (temp, 0))));\n+\t\t\t  && loop_invariant_p (loop, XEXP (temp, 0))));\n \t      if (this != 0)\n \t\tvalue |= this;\n \t    }\n@@ -3390,7 +3404,7 @@ consec_sets_invariant_p (reg, n_sets, insn)\n     }\n \n   VARRAY_INT (set_in_loop, regno) = old;\n-  /* If invariant_p ever returned 2, we return 2.  */\n+  /* If loop_invariant_p ever returned 2, we return 2.  */\n   return 1 + (value & 2);\n }\n \n@@ -3420,7 +3434,7 @@ all_sets_invariant_p (reg, insn, table)\n \t  && GET_CODE (SET_DEST (PATTERN (p))) == REG\n \t  && REGNO (SET_DEST (PATTERN (p))) == regno)\n \t{\n-\t  if (!invariant_p (SET_SRC (PATTERN (p)), table))\n+\t  if (! loop_invariant_p (loop, SET_SRC (PATTERN (p)), table))\n \t    return 0;\n \t}\n     }\n@@ -3575,11 +3589,10 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n   free (last_set);\n }\n \f\n-/* Given a loop that is bounded by LOOP_START and LOOP_END\n-   and that is entered at LOOP_SCAN_START,\n-   return 1 if the register set in SET contained in insn INSN is used by\n-   any insn that precedes INSN in cyclic order starting\n-   from the loop entry point.\n+/* Given a loop that is bounded by LOOP->START and LOOP->END and that\n+   is entered at LOOP->SCAN_START, return 1 if the register set in SET\n+   contained in insn INSN is used by any insn that precedes INSN in\n+   cyclic order starting from the loop entry point.\n \n    We don't want to use INSN_LUID here because if we restrict INSN to those\n    that have a valid INSN_LUID, it means we cannot move an invariant out\n@@ -3685,13 +3698,7 @@ static rtx addr_placeholder;\n    valid index in several tables including n_times_set and regno_last_uid.\n    This does not cause a problem here, because the added registers cannot be\n    givs outside of their loop, and hence will never be reconsidered.\n-   But scan_loop must check regnos to make sure they are in bounds. \n-   \n-   LOOP_SCAN_START is the first instruction in the loop, as the loop would\n-   actually be executed.  END is the NOTE_INSN_LOOP_END.  LOOP_TOP is\n-   the first instruction in the loop, as it is layed out in the\n-   instruction stream.  LOOP_START is the NOTE_INSN_LOOP_BEG.\n-   LOOP_CONT is the NOTE_INSN_LOOP_CONT.  */\n+   But scan_loop must check regnos to make sure they are in bounds.   */\n \n static void\n strength_reduce (loop, insn_count, unroll_p, bct_p)\n@@ -3741,7 +3748,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n   /* If loop_scan_start points to the loop exit test, we have to be wary of\n      subversive use of gotos inside expression statements.  */\n   if (prev_nonnote_insn (loop_scan_start) != prev_nonnote_insn (loop_start))\n-    maybe_multiple = back_branch_in_range_p (loop_scan_start, loop_start, loop_end);\n+    maybe_multiple = back_branch_in_range_p (loop, loop_scan_start);\n \n   VARRAY_INT_INIT (reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n   VARRAY_GENERIC_PTR_INIT (reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n@@ -3780,9 +3787,9 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t    {\n \t      int multi_insn_incr = 0;\n \n-\t      if (basic_induction_var (SET_SRC (set), GET_MODE (SET_SRC (set)),\n-\t\t\t\t       dest_reg, p, loop->level,\n-\t\t\t\t       &inc_val, &mult_val,\n+\t      if (basic_induction_var (loop, SET_SRC (set),\n+\t\t\t\t       GET_MODE (SET_SRC (set)),\n+\t\t\t\t       dest_reg, p, &inc_val, &mult_val,\n \t\t\t\t       &location, &multi_insn_incr))\n \t\t{\n \t\t  /* It is a possible basic induction variable.\n@@ -3860,9 +3867,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t     matter.  Check to see if the target of this branch is on the\n \t     loop->exits_labels list.  */\n \t     \n-\t  for (label = uid_loop[INSN_UID (loop_start)]->exit_labels;\n-\t       label;\n-\t       label = LABEL_NEXTREF (label))\n+\t  for (label = loop->exit_labels; label; label = LABEL_NEXTREF (label))\n \t    if (XEXP (label, 0) == JUMP_LABEL (p))\n \t      break;\n \n@@ -3999,7 +4004,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n       if (GET_CODE (p) == JUMP_INSN\n \t  && JUMP_LABEL (p) != 0\n \t  && next_real_insn (JUMP_LABEL (p)) == next_real_insn (loop_end)\n-\t  && (test = get_condition_for_loop (p)) != 0\n+\t  && (test = get_condition_for_loop (loop, p)) != 0\n \t  && GET_CODE (XEXP (test, 0)) == REG\n \t  && REGNO (XEXP (test, 0)) < max_reg_before_loop\n \t  && (bl = reg_biv_class[REGNO (XEXP (test, 0))]) != 0\n@@ -4080,8 +4085,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t      && GET_CODE (src) == PLUS\n \t      && GET_CODE (XEXP (src, 0)) == REG\n \t      && CONSTANT_P (XEXP (src, 1))\n-\t      && ((increment = biv_total_increment (bl, loop_start, loop_end))\n-\t\t  != NULL_RTX))\n+\t      && ((increment = biv_total_increment (bl)) != NULL_RTX))\n \t    {\n \t      int regno = REGNO (XEXP (src, 0));\n \n@@ -4093,8 +4097,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t  /* Now, can we transform this biv into a giv?  */\n \t  if (bl2\n \t      && bl2->biv_count == 1\n-\t      && rtx_equal_p (increment,\n-\t\t\t      biv_total_increment (bl2, loop_start, loop_end))\n+\t      && rtx_equal_p (increment, biv_total_increment (bl2))\n \t      /* init_insn is only set to insns that are before loop_start\n \t\t without any intervening labels.  */\n \t      && ! reg_set_between_p (bl2->biv->src_reg,\n@@ -4114,7 +4117,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t\t\t\t  &SET_SRC (single_set (bl->biv->insn)),\n \t\t\t\t  copy_rtx (src), 0))\n \t    {\n-\t      rtx dominator = uid_loop[INSN_UID (loop_start)]->cont_dominator;\n+\t      rtx dominator = loop->cont_dominator;\n \t      rtx giv = bl->biv->src_reg;\n \t      rtx giv_insn = bl->biv->insn;\n \t      rtx after_giv = NEXT_INSN (giv_insn);\n@@ -4467,11 +4470,11 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t    continue;\n \n \t  if (/* SET_SRC is a giv.  */\n-\t      (general_induction_var (SET_SRC (set), &src_reg, &add_val,\n+\t      (general_induction_var (loop, SET_SRC (set), &src_reg, &add_val,\n \t\t\t\t      &mult_val, 0, &benefit)\n \t       /* Equivalent expression is a giv.  */\n \t       || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))\n-\t\t   && general_induction_var (XEXP (regnote, 0), &src_reg,\n+\t\t   && general_induction_var (loop, XEXP (regnote, 0), &src_reg,\n \t\t\t\t\t     &add_val, &mult_val, 0,\n \t\t\t\t\t     &benefit)))\n \t      /* Don't try to handle any regs made by loop optimization.\n@@ -4482,7 +4485,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t      /* This must be the only place where the register is set.  */\n \t      && (VARRAY_INT (n_times_set, REGNO (dest_reg)) == 1\n \t\t  /* or all sets must be consecutive and make a giv.  */\n-\t\t  || (benefit = consec_sets_giv (benefit, p,\n+\t\t  || (benefit = consec_sets_giv (loop, benefit, p,\n \t\t\t\t\t\t src_reg, dest_reg,\n \t\t\t\t\t\t &add_val, &mult_val,\n \t\t\t\t\t\t &last_consec_insn))))\n@@ -4498,9 +4501,9 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t      if (VARRAY_INT (n_times_set, REGNO (dest_reg)) != 1)\n \t\tp = last_consec_insn;\n \n-\t      record_giv (v, p, src_reg, dest_reg, mult_val, add_val, benefit,\n-\t\t\t  DEST_REG, not_every_iteration, maybe_multiple,\n-\t\t\t  NULL_PTR, loop_start, loop_end);\n+\t      record_giv (loop, v, p, src_reg, dest_reg, mult_val, add_val,\n+\t\t\t  benefit, DEST_REG, not_every_iteration,\n+\t\t\t  maybe_multiple, NULL_PTR);\n \n \t    }\n \t}\n@@ -4510,15 +4513,15 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n       /* This resulted in worse code on a VAX 8600.  I wonder if it\n \t still does.  */\n       if (GET_CODE (p) == INSN)\n-\tfind_mem_givs (PATTERN (p), p, not_every_iteration, maybe_multiple,\n-\t\t       loop_start, loop_end);\n+\tfind_mem_givs (loop, PATTERN (p), p, not_every_iteration,\n+\t\t       maybe_multiple);\n #endif\n \n       /* Update the status of whether giv can derive other givs.  This can\n \t change when we pass a label or an insn that updates a biv.  */\n       if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n \t|| GET_CODE (p) == CODE_LABEL)\n-\tupdate_giv_derive (p);\n+\tupdate_giv_derive (loop, p);\n \n       /* Past CODE_LABEL, we get to insns that may be executed multiple\n \t times.  The only way we can be sure that they can't is if every\n@@ -4582,9 +4585,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t     matter.  Check to see if the target of this branch is on the\n \t     loop->exits_labels list.  */\n \t     \n-\t  for (label = uid_loop[INSN_UID (loop_start)]->exit_labels;\n-\t       label;\n-\t       label = LABEL_NEXTREF (label))\n+\t  for (label = loop->exit_labels; label; label = LABEL_NEXTREF (label))\n \t    if (XEXP (label, 0) == JUMP_LABEL (p))\n \t      break;\n \n@@ -4643,7 +4644,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \n       for (v = bl->giv; v; v = v->next_iv)\n \tif (! v->replaceable && ! v->not_replaceable)\n-\t  check_final_value (v, loop_start, loop_end, loop_info->n_iterations);\n+\t  check_final_value (loop, v);\n     }\n \n   /* Try to prove that the loop counter variable (if any) is always\n@@ -4692,14 +4693,13 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t   && ! bl->nonneg\n #endif\n \t   && ! reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n-\t  || ((final_value = final_biv_value (bl, loop_start, loop_end, \n-\t\t\t\t\t      loop_info->n_iterations))\n+\t  || ((final_value = final_biv_value (loop, bl))\n #ifdef HAVE_decrement_and_branch_until_zero\n \t      && ! bl->nonneg\n #endif\n \t      ))\n-\tbl->eliminable = maybe_eliminate_biv (bl, loop_start, loop_end, 0,\n-\t\t\t\t\t      threshold, insn_count);\n+\tbl->eliminable = maybe_eliminate_biv (loop, bl, 0, threshold, \n+\t\t\t\t\t      insn_count);\n       else\n \t{\n \t  if (loop_dump_stream)\n@@ -4863,7 +4863,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t  VARRAY_GROW (reg_iv_type, nregs);\n \t  VARRAY_GROW (reg_iv_info, nregs);\n \t}\n-      recombine_givs (bl, loop_start, loop_end, unroll_p);\n+      recombine_givs (loop, bl, unroll_p);\n \n       /* Reduce each giv that we decided to reduce.  */\n \n@@ -5096,7 +5096,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t\t loop to ensure that it will always be executed no matter\n \t\t how the loop exits.  Otherwise, emit the insn after the loop,\n \t\t since this is slightly more efficient.  */\n-\t      if (uid_loop[INSN_UID (loop_start)]->exit_count)\n+\t      if (loop->exit_count)\n \t\tinsert_before = loop_start;\n \t      else\n \t\tinsert_before = end_insert_before;\n@@ -5164,9 +5164,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t doing so in the rare cases where it can occur.  */\n \n       if (all_reduced == 1 && bl->eliminable\n-\t  && maybe_eliminate_biv (bl, loop_start, loop_end, 1,\n-\t\t\t\t  threshold, insn_count))\n-\n+\t  && maybe_eliminate_biv (loop, bl, 1, threshold, insn_count))\n \t{\n \t  /* ?? If we created a new test to bypass the loop entirely,\n \t     or otherwise drop straight in, based on this test, then\n@@ -5188,7 +5186,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t\t loop to ensure that it will always be executed no matter\n \t\t how the loop exits.  Otherwise, emit the insn after the\n \t\t loop, since this is slightly more efficient.  */\n-\t      if (uid_loop[INSN_UID (loop_start)]->exit_count)\n+\t      if (loop->exit_count)\n \t\tinsert_before = loop_start;\n \t      else\n \t\tinsert_before = end_insert_before;\n@@ -5328,12 +5326,11 @@ valid_initial_value_p (x, insn, call_seen, loop_start)\n    more thanonce in each loop iteration.  */\n \n static void\n-find_mem_givs (x, insn, not_every_iteration, maybe_multiple, loop_start,\n-\t       loop_end)\n+find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n+     const struct loop *loop;\n      rtx x;\n      rtx insn;\n      int not_every_iteration, maybe_multiple;\n-     rtx loop_start, loop_end;\n {\n   register int i, j;\n   register enum rtx_code code;\n@@ -5371,16 +5368,16 @@ find_mem_givs (x, insn, not_every_iteration, maybe_multiple, loop_start,\n \t   it comes time to combine a set of related DEST_ADDR GIVs, since\n \t   this one would not be seen.   */\n \n-\tif (general_induction_var (XEXP (x, 0), &src_reg, &add_val,\n+\tif (general_induction_var (loop, XEXP (x, 0), &src_reg, &add_val,\n \t\t\t\t   &mult_val, 1, &benefit))\n \t  {\n \t    /* Found one; record it.  */\n \t    struct induction *v\n \t      = (struct induction *) oballoc (sizeof (struct induction));\n \n-\t    record_giv (v, insn, src_reg, addr_placeholder, mult_val,\n+\t    record_giv (loop, v, insn, src_reg, addr_placeholder, mult_val,\n \t\t\tadd_val, benefit, DEST_ADDR, not_every_iteration,\n-\t\t\tmaybe_multiple, &XEXP (x, 0), loop_start, loop_end);\n+\t\t\tmaybe_multiple, &XEXP (x, 0));\n \n \t    v->mem_mode = GET_MODE (x);\n \t  }\n@@ -5396,12 +5393,12 @@ find_mem_givs (x, insn, not_every_iteration, maybe_multiple, loop_start,\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n-      find_mem_givs (XEXP (x, i), insn, not_every_iteration, maybe_multiple,\n-\t\t     loop_start, loop_end);\n+      find_mem_givs (loop, XEXP (x, i), insn, not_every_iteration,\n+\t\t     maybe_multiple);\n     else if (fmt[i] == 'E')\n       for (j = 0; j < XVECLEN (x, i); j++)\n-\tfind_mem_givs (XVECEXP (x, i, j), insn, not_every_iteration,\n-\t\t       maybe_multiple, loop_start, loop_end);\n+\tfind_mem_givs (loop, XVECEXP (x, i, j), insn, not_every_iteration,\n+\t\t       maybe_multiple);\n }\n \f\n /* Fill in the data about one biv update.\n@@ -5524,9 +5521,9 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n    LOCATION points to the place where this giv's value appears in INSN.  */\n \n static void\n-record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n-\t    type, not_every_iteration, maybe_multiple, location, loop_start,\n-\t    loop_end)\n+record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n+\t    type, not_every_iteration, maybe_multiple, location)\n+     const struct loop *loop;\n      struct induction *v;\n      rtx insn;\n      rtx src_reg;\n@@ -5536,7 +5533,6 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n      enum g_types type;\n      int not_every_iteration, maybe_multiple;\n      rtx *location;\n-     rtx loop_start, loop_end;\n {\n   struct induction *b;\n   struct iv_class *bl;\n@@ -5637,7 +5633,8 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n \n       if (REGNO_FIRST_UID (REGNO (dest_reg)) == INSN_UID (insn)\n \t  /* Previous line always fails if INSN was moved by loop opt.  */\n-\t  && uid_luid[REGNO_LAST_UID (REGNO (dest_reg))] < INSN_LUID (loop_end)\n+\t  && uid_luid[REGNO_LAST_UID (REGNO (dest_reg))] \n+\t  < INSN_LUID (loop->end)\n \t  && (! not_every_iteration\n \t      || last_use_this_basic_block (dest_reg, insn)))\n  \t{\n@@ -5674,7 +5671,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n \t     biv update to before it, then this giv is not replaceable.  */\n \t  if (v->replaceable)\n \t    for (b = bl->biv; b; b = b->next_iv)\n-\t      if (back_branch_in_range_p (b->insn, loop_start, loop_end))\n+\t      if (back_branch_in_range_p (loop, b->insn))\n \t\t{\n \t\t  v->replaceable = 0;\n \t\t  v->not_replaceable = 1;\n@@ -5772,10 +5769,9 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n    have been identified.  */\n \n static void\n-check_final_value (v, loop_start, loop_end, n_iterations)\n+check_final_value (loop, v)\n+     const struct loop *loop;\n      struct induction *v;\n-     rtx loop_start, loop_end;\n-     unsigned HOST_WIDE_INT n_iterations;\n {\n   struct iv_class *bl;\n   rtx final_value = 0;\n@@ -5802,7 +5798,7 @@ check_final_value (v, loop_start, loop_end, n_iterations)\n   v->replaceable = 0;\n #endif\n \n-  if ((final_value = final_giv_value (v, loop_start, loop_end, n_iterations))\n+  if ((final_value = final_giv_value (loop, v))\n       && (v->always_computable || last_use_this_basic_block (v->dest_reg, v->insn)))\n     {\n       int biv_increment_seen = 0;\n@@ -5834,8 +5830,8 @@ check_final_value (v, loop_start, loop_end, n_iterations)\n       while (1)\n \t{\n \t  p = NEXT_INSN (p);\n-\t  if (p == loop_end)\n-\t    p = NEXT_INSN (loop_start);\n+\t  if (p == loop->end)\n+\t    p = NEXT_INSN (loop->start);\n \t  if (p == v->insn)\n \t    break;\n \n@@ -5868,17 +5864,17 @@ check_final_value (v, loop_start, loop_end, n_iterations)\n \t  while (1)\n \t    {\n \t      p = NEXT_INSN (p);\n-\t      if (p == loop_end)\n-\t\tp = NEXT_INSN (loop_start);\n+\t      if (p == loop->end)\n+\t\tp = NEXT_INSN (loop->start);\n \t      if (p == last_giv_use)\n \t\tbreak;\n \n \t      if (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p)\n \t\t  && LABEL_NAME (JUMP_LABEL (p))\n \t\t  && ((loop_insn_first_p (JUMP_LABEL (p), v->insn)\n-\t\t       && loop_insn_first_p (loop_start, JUMP_LABEL (p)))\n+\t\t       && loop_insn_first_p (loop->start, JUMP_LABEL (p)))\n \t\t      || (loop_insn_first_p (last_giv_use, JUMP_LABEL (p))\n-\t\t\t  && loop_insn_first_p (JUMP_LABEL (p), loop_end))))\n+\t\t\t  && loop_insn_first_p (JUMP_LABEL (p), loop->end))))\n \t\t{\n \t\t  v->replaceable = 0;\n \t\t  v->not_replaceable = 1;\n@@ -5914,7 +5910,8 @@ check_final_value (v, loop_start, loop_end, n_iterations)\n    The cases we look at are when a label or an update to a biv is passed.  */\n \n static void\n-update_giv_derive (p)\n+update_giv_derive (loop, p)\n+     const  struct loop *loop;\n      rtx p;\n {\n   struct iv_class *bl;\n@@ -5982,14 +5979,16 @@ update_giv_derive (p)\n \t\t  tem = 0;\n \n \t\t  if (biv->mult_val == const1_rtx)\n-\t\t    tem = simplify_giv_expr (gen_rtx_MULT (giv->mode,\n+\t\t    tem = simplify_giv_expr (loop,\n+\t\t\t\t\t     gen_rtx_MULT (giv->mode,\n \t\t\t\t\t\t\t   biv->add_val,\n \t\t\t\t\t\t\t   giv->mult_val),\n \t\t\t\t\t     &dummy);\n \n \t\t  if (tem && giv->derive_adjustment)\n \t\t    tem = simplify_giv_expr\n-\t\t      (gen_rtx_PLUS (giv->mode, tem, giv->derive_adjustment),\n+\t\t      (loop,\n+\t\t       gen_rtx_PLUS (giv->mode, tem, giv->derive_adjustment),\n \t\t       &dummy);\n \n \t\t  if (tem)\n@@ -6042,13 +6041,13 @@ update_giv_derive (p)\n    If we cannot find a biv, we return 0.  */\n \n static int\n-basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n+basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val,\n \t\t     location, multi_insn_incr)\n+     const struct loop *loop;\n      register rtx x;\n      enum machine_mode mode;\n      rtx dest_reg;\n      rtx p;\n-     int level;\n      rtx *inc_val;\n      rtx *mult_val;\n      rtx **location;\n@@ -6081,7 +6080,7 @@ basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n  \treturn 0;\n \n       arg = *argp;\n-      if (invariant_p (arg) != 1)\n+      if (loop_invariant_p (loop, arg) != 1)\n \treturn 0;\n \n       *inc_val = convert_modes (GET_MODE (dest_reg), GET_MODE (x), arg, 0);\n@@ -6093,9 +6092,9 @@ basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n       /* If this is a SUBREG for a promoted variable, check the inner\n \t value.  */\n       if (SUBREG_PROMOTED_VAR_P (x))\n-\treturn basic_induction_var (SUBREG_REG (x), GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t    dest_reg, p, level, \n-\t\t\t\t    inc_val, mult_val, location,\n+\treturn basic_induction_var (loop, SUBREG_REG (x),\n+\t\t\t\t    GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t    dest_reg, p, inc_val, mult_val, location,\n \t\t\t\t    multi_insn_incr);\n       return 0;\n \n@@ -6124,11 +6123,11 @@ basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n \t\t   && (GET_MODE_CLASS (GET_MODE (SET_DEST (set)))\n \t\t       == MODE_INT)\n \t\t   && SUBREG_REG (SET_DEST (set)) == x))\n-\t      && basic_induction_var (SET_SRC (set),\n+\t      && basic_induction_var (loop, SET_SRC (set),\n \t\t\t\t      (GET_MODE (SET_SRC (set)) == VOIDmode\n \t\t\t\t       ? GET_MODE (x)\n \t\t\t\t       : GET_MODE (SET_SRC (set))),\n-\t\t\t\t      dest_reg, insn, level,\n+\t\t\t\t      dest_reg, insn,\n \t\t\t\t      inc_val, mult_val, location,\n \t\t\t\t      multi_insn_incr))\n \t    {\n@@ -6143,15 +6142,15 @@ basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n \t as a biv of the outer loop,\n \t causing code to be moved INTO the inner loop.  */\n     case MEM:\n-      if (invariant_p (x) != 1)\n+      if (loop_invariant_p (loop, x) != 1)\n \treturn 0;\n     case CONST_INT:\n     case SYMBOL_REF:\n     case CONST:\n       /* convert_modes aborts if we try to convert to or from CCmode, so just\n          exclude that case.  It is very unlikely that a condition code value\n \t would be a useful iterator anyways.  */\n-      if (level == 0\n+      if (loop->level == 1\n \t  && GET_MODE_CLASS (mode) != MODE_CC\n \t  && GET_MODE_CLASS (GET_MODE (dest_reg)) != MODE_CC)\n  \t{\n@@ -6164,9 +6163,9 @@ basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n  \treturn 0;\n \n     case SIGN_EXTEND:\n-      return basic_induction_var (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  dest_reg, p, level, inc_val, mult_val,\n-\t\t\t\t  location, multi_insn_incr);\n+      return basic_induction_var (loop, XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n+\t\t\t\t  dest_reg, p, inc_val, mult_val, location,\n+\t\t\t\t  multi_insn_incr);\n \n     case ASHIFTRT:\n       /* Similar, since this can be a sign extension.  */\n@@ -6184,9 +6183,9 @@ basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && GET_CODE (SET_SRC (set)) == ASHIFT\n \t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1)\n-\t  && basic_induction_var (XEXP (SET_SRC (set), 0),\n+\t  && basic_induction_var (loop, XEXP (SET_SRC (set), 0),\n \t\t\t\t  GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  dest_reg, insn, level, inc_val, mult_val,\n+\t\t\t\t  dest_reg, insn, inc_val, mult_val,\n \t\t\t\t  location, multi_insn_incr))\n \t{\n \t  *multi_insn_incr = 1;\n@@ -6214,7 +6213,8 @@ basic_induction_var (x, mode, dest_reg, p, level, inc_val, mult_val,\n      such that the value of X is biv * mult + add;  */\n \n static int\n-general_induction_var (x, src_reg, add_val, mult_val, is_addr, pbenefit)\n+general_induction_var (loop, x, src_reg, add_val, mult_val, is_addr, pbenefit)\n+     const struct loop *loop;\n      rtx x;\n      rtx *src_reg;\n      rtx *add_val;\n@@ -6226,14 +6226,14 @@ general_induction_var (x, src_reg, add_val, mult_val, is_addr, pbenefit)\n   char *storage;\n \n   /* If this is an invariant, forget it, it isn't a giv.  */\n-  if (invariant_p (x) == 1)\n+  if (loop_invariant_p (loop, x) == 1)\n     return 0;\n \n   /* See if the expression could be a giv and get its form.\n      Mark our place on the obstack in case we don't find a giv.  */\n   storage = (char *) oballoc (0);\n   *pbenefit = 0;\n-  x = simplify_giv_expr (x, pbenefit);\n+  x = simplify_giv_expr (loop, x, pbenefit);\n   if (x == 0)\n     {\n       obfree (storage);\n@@ -6336,7 +6336,8 @@ static int cmp_combine_givs_stats PARAMS ((const PTR, const PTR));\n static int cmp_recombine_givs_stats PARAMS ((const PTR, const PTR));\n \n static rtx\n-simplify_giv_expr (x, benefit)\n+simplify_giv_expr (loop, x, benefit)\n+     const struct loop *loop;\n      rtx x;\n      int *benefit;\n {\n@@ -6354,8 +6355,8 @@ simplify_giv_expr (x, benefit)\n   switch (GET_CODE (x))\n     {\n     case PLUS:\n-      arg0 = simplify_giv_expr (XEXP (x, 0), benefit);\n-      arg1 = simplify_giv_expr (XEXP (x, 1), benefit);\n+      arg0 = simplify_giv_expr (loop, XEXP (x, 0), benefit);\n+      arg1 = simplify_giv_expr (loop, XEXP (x, 1), benefit);\n       if (arg0 == 0 || arg1 == 0)\n \treturn NULL_RTX;\n \n@@ -6401,7 +6402,8 @@ simplify_giv_expr (x, benefit)\n \t  case PLUS:\n \t    /* (a + invar_1) + invar_2.  Associate.  */\n \t    return\n-\t      simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t      simplify_giv_expr (loop,\n+\t\t\t\t gen_rtx_PLUS (mode,\n \t\t\t\t\t       XEXP (arg0, 0),\n \t\t\t\t\t       gen_rtx_PLUS (mode,\n \t\t\t\t\t\t\t     XEXP (arg0, 1),\n@@ -6427,7 +6429,8 @@ simplify_giv_expr (x, benefit)\n \n       if (GET_CODE (arg1) == PLUS)\n \t  return\n-\t    simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t    simplify_giv_expr (loop,\n+\t\t\t       gen_rtx_PLUS (mode,\n \t\t\t\t\t     gen_rtx_PLUS (mode, arg0,\n \t\t\t\t\t\t\t   XEXP (arg1, 0)),\n \t\t\t\t\t     XEXP (arg1, 1)),\n@@ -6440,7 +6443,8 @@ simplify_giv_expr (x, benefit)\n       if (!rtx_equal_p (arg0, arg1))\n \treturn NULL_RTX;\n \n-      return simplify_giv_expr (gen_rtx_MULT (mode,\n+      return simplify_giv_expr (loop,\n+\t\t\t\tgen_rtx_MULT (mode,\n \t\t\t\t\t      XEXP (arg0, 0),\n \t\t\t\t\t      gen_rtx_PLUS (mode,\n \t\t\t\t\t\t\t    XEXP (arg0, 1),\n@@ -6449,16 +6453,17 @@ simplify_giv_expr (x, benefit)\n \n     case MINUS:\n       /* Handle \"a - b\" as \"a + b * (-1)\".  */\n-      return simplify_giv_expr (gen_rtx_PLUS (mode,\n+      return simplify_giv_expr (loop,\n+\t\t\t\tgen_rtx_PLUS (mode,\n \t\t\t\t\t      XEXP (x, 0),\n \t\t\t\t\t      gen_rtx_MULT (mode,\n \t\t\t\t\t\t\t    XEXP (x, 1),\n \t\t\t\t\t\t\t    constm1_rtx)),\n \t\t\t\tbenefit);\n \n     case MULT:\n-      arg0 = simplify_giv_expr (XEXP (x, 0), benefit);\n-      arg1 = simplify_giv_expr (XEXP (x, 1), benefit);\n+      arg0 = simplify_giv_expr (loop, XEXP (x, 0), benefit);\n+      arg1 = simplify_giv_expr (loop, XEXP (x, 1), benefit);\n       if (arg0 == 0 || arg1 == 0)\n \treturn NULL_RTX;\n \n@@ -6511,7 +6516,8 @@ simplify_giv_expr (x, benefit)\n \n \tcase MULT:\n \t  /* (a * invar_1) * invar_2.  Associate.  */\n-\t  return simplify_giv_expr (gen_rtx_MULT (mode,\n+\t  return simplify_giv_expr (loop,\n+\t\t\t\t    gen_rtx_MULT (mode,\n \t\t\t\t\t\t  XEXP (arg0, 0),\n \t\t\t\t\t\t  gen_rtx_MULT (mode,\n \t\t\t\t\t\t\t\tXEXP (arg0, 1),\n@@ -6520,7 +6526,8 @@ simplify_giv_expr (x, benefit)\n \n \tcase PLUS:\n \t  /* (a + invar_1) * invar_2.  Distribute.  */\n-\t  return simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t  return simplify_giv_expr (loop,\n+\t\t\t\t    gen_rtx_PLUS (mode,\n \t\t\t\t\t\t  gen_rtx_MULT (mode,\n \t\t\t\t\t\t\t\tXEXP (arg0, 0),\n \t\t\t\t\t\t\t\targ1),\n@@ -6539,20 +6546,23 @@ simplify_giv_expr (x, benefit)\n \treturn 0;\n \n       return\n-\tsimplify_giv_expr (gen_rtx_MULT (mode,\n+\tsimplify_giv_expr (loop,\n+\t\t\t   gen_rtx_MULT (mode,\n \t\t\t\t\t XEXP (x, 0),\n \t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n \t\t\t\t\t\t  << INTVAL (XEXP (x, 1)))),\n \t\t\t   benefit);\n \n     case NEG:\n       /* \"-a\" is \"a * (-1)\" */\n-      return simplify_giv_expr (gen_rtx_MULT (mode, XEXP (x, 0), constm1_rtx),\n+      return simplify_giv_expr (loop,\n+\t\t\t\tgen_rtx_MULT (mode, XEXP (x, 0), constm1_rtx),\n \t\t\t\tbenefit);\n \n     case NOT:\n       /* \"~a\" is \"-a - 1\". Silly, but easy.  */\n-      return simplify_giv_expr (gen_rtx_MINUS (mode,\n+      return simplify_giv_expr (loop,\n+\t\t\t\tgen_rtx_MINUS (mode,\n \t\t\t\t\t       gen_rtx_NEG (mode, XEXP (x, 0)),\n \t\t\t\t\t       const1_rtx),\n \t\t\t\tbenefit);\n@@ -6587,14 +6597,14 @@ simplify_giv_expr (x, benefit)\n \n \t    if (v->derive_adjustment)\n \t      tem = gen_rtx_MINUS (mode, tem, v->derive_adjustment);\n-\t    return simplify_giv_expr (tem, benefit);\n+\t    return simplify_giv_expr (loop, tem, benefit);\n \t  }\n \n \tdefault:\n \t  /* If it isn't an induction variable, and it is invariant, we\n \t     may be able to simplify things further by looking through\n \t     the bits we just moved outside the loop.  */\n-\t  if (invariant_p (x) == 1)\n+\t  if (loop_invariant_p (loop, x) == 1)\n \t    {\n \t      struct movable *m;\n \n@@ -6606,7 +6616,8 @@ simplify_giv_expr (x, benefit)\n \t\t    /* If we match another movable, we must use that, as \n \t\t       this one is going away.  */\n \t\t    if (m->match)\n-\t\t      return simplify_giv_expr (m->match->set_dest, benefit);\n+\t\t      return simplify_giv_expr (loop, m->match->set_dest, \n+\t\t\t\t\t\tbenefit);\n \n \t\t    /* If consec is non-zero, this is a member of a group of\n \t\t       instructions that were moved together.  We handle this\n@@ -6640,7 +6651,7 @@ simplify_giv_expr (x, benefit)\n \t\t\t    || GET_CODE (tem) == CONST_INT\n \t\t\t    || GET_CODE (tem) == SYMBOL_REF)\n \t\t\t  {\n-\t\t\t    tem = simplify_giv_expr (tem, benefit);\n+\t\t\t    tem = simplify_giv_expr (loop, tem, benefit);\n \t\t\t    if (tem)\n \t\t\t      return tem;\n \t\t\t  }\n@@ -6649,7 +6660,8 @@ simplify_giv_expr (x, benefit)\n \t\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 0)) == SYMBOL_REF\n \t\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 1)) == CONST_INT)\n \t\t\t  {\n-\t\t\t    tem = simplify_giv_expr (XEXP (tem, 0), benefit);\n+\t\t\t    tem = simplify_giv_expr (loop, XEXP (tem, 0),\n+\t\t\t\t\t\t     benefit);\n \t\t\t    if (tem)\n \t\t\t      return tem;\n \t\t\t  }\n@@ -6667,7 +6679,7 @@ simplify_giv_expr (x, benefit)\n       if (GET_CODE (x) == USE)\n \tx = XEXP (x, 0);\n \n-      if (invariant_p (x) == 1)\n+      if (loop_invariant_p (loop, x) == 1)\n \t{\n \t  if (GET_CODE (x) == CONST_INT)\n \t    return x;\n@@ -6753,8 +6765,9 @@ sge_plus (mode, x, y)\n    *MULT_VAL and *ADD_VAL.  */\n \n static int\n-consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n+consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n \t\t add_val, mult_val, last_consec_insn)\n+     const struct loop *loop;\n      int first_benefit;\n      rtx p;\n      rtx src_reg;\n@@ -6803,11 +6816,11 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n \t  && (set = single_set (p))\n \t  && GET_CODE (SET_DEST (set)) == REG\n \t  && SET_DEST (set) == dest_reg\n-\t  && (general_induction_var (SET_SRC (set), &src_reg,\n+\t  && (general_induction_var (loop, SET_SRC (set), &src_reg,\n \t\t\t\t     add_val, mult_val, 0, &benefit)\n \t      /* Giv created by equivalent expression.  */\n \t      || ((temp = find_reg_note (p, REG_EQUAL, NULL_RTX))\n-\t\t  && general_induction_var (XEXP (temp, 0), &src_reg,\n+\t\t  && general_induction_var (loop, XEXP (temp, 0), &src_reg,\n \t\t\t\t\t    add_val, mult_val, 0, &benefit)))\n \t  && src_reg == v->src_reg)\n \t{\n@@ -7380,9 +7393,9 @@ find_life_end (x, stats, insn, biv)\n    This tends to shorten giv lifetimes, and helps the next step:\n    try to derive givs from other givs.  */\n static void\n-recombine_givs (bl, loop_start, loop_end, unroll_p)\n+recombine_givs (loop, bl, unroll_p)\n+     const struct loop *loop;\n      struct iv_class *bl;\n-     rtx loop_start, loop_end;\n      int unroll_p;\n {\n   struct induction *v, **giv_array, *last_giv;\n@@ -7535,7 +7548,7 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n \t      else\n \t\t{\n \t\t  stats[i].end_luid = uid_luid[REGNO_LAST_UID (regno)];\n-\t\t  if (stats[i].end_luid > INSN_LUID (loop_end))\n+\t\t  if (stats[i].end_luid > INSN_LUID (loop->end))\n \t\t    {\n \t\t      stats[i].end_luid = -1;\n \t\t      ends_need_computing++;\n@@ -7550,12 +7563,12 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n   if (ends_need_computing)\n     {\n       rtx biv = bl->biv->src_reg;\n-      rtx p = loop_end;\n+      rtx p = loop->end;\n \n       do\n \t{\n-\t  if (p == loop_start)\n-\t    p = loop_end;\n+\t  if (p == loop->start)\n+\t    p = loop->end;\n \t  p = PREV_INSN (p);\n \t  if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n \t    continue;\n@@ -7641,8 +7654,8 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n \t\t  derived giv would defeat the purpose of reducing register\n \t\t  pressure.\n \t\t  ??? We could arrange to move the insn.  */\n-\t      && ((unsigned) stats[i].end_luid - INSN_LUID (loop_start)\n-                  > (unsigned) stats[i].start_luid - INSN_LUID (loop_start))\n+\t      && ((unsigned) stats[i].end_luid - INSN_LUID (loop->start)\n+                  > (unsigned) stats[i].start_luid - INSN_LUID (loop->start))\n \t      && rtx_equal_p (last_giv->mult_val, v->mult_val)\n \t      /* ??? Could handle libcalls, but would need more logic.  */\n \t      && ! find_reg_note (v->insn, REG_RETVAL, NULL_RTX)\n@@ -7860,7 +7873,7 @@ check_dbra_loop (loop, insn_count)\n      register value, try to optimize it.  Otherwise, we can't do anything.  */\n \n   jump = PREV_INSN (loop_end);\n-  comparison = get_condition_for_loop (jump);\n+  comparison = get_condition_for_loop (loop, jump);\n   if (comparison == 0)\n     return 0;\n \n@@ -7931,7 +7944,7 @@ check_dbra_loop (loop, insn_count)\n \t  if (GET_CODE (p) != JUMP_INSN)\n \t    continue;\n \n-\t  before_comparison = get_condition_for_loop (p);\n+\t  before_comparison = get_condition_for_loop (loop, p);\n \t  if (before_comparison\n \t      && XEXP (before_comparison, 0) == bl->biv->dest_reg\n \t      && GET_CODE (before_comparison) == LT\n@@ -7969,8 +7982,7 @@ check_dbra_loop (loop, insn_count)\n \t which is reversible.  */\n       int reversible_mem_store = 1;\n \n-      if (bl->giv_count == 0\n-\t  && ! uid_loop[INSN_UID (loop_start)]->exit_count)\n+      if (bl->giv_count == 0 && ! loop->exit_count)\n \t{\n \t  rtx bivreg = regno_reg_rtx[bl->regno];\n \n@@ -8018,7 +8030,7 @@ check_dbra_loop (loop, insn_count)\n \t{\n \t  for (p = loop_start; p != loop_end; p = NEXT_INSN (p))\n \t    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n-\t      num_nonfixed_reads += count_nonfixed_reads (PATTERN (p));\n+\t      num_nonfixed_reads += count_nonfixed_reads (loop, PATTERN (p));\n \n \t  /* If the loop has a single store, and the destination address is\n \t     invariant, then we can't reverse the loop, because this address\n@@ -8033,7 +8045,9 @@ check_dbra_loop (loop, insn_count)\n \t      reversible_mem_store\n \t\t= (! unknown_address_altered\n \t\t   && ! unknown_constant_address_altered\n-\t\t   && ! invariant_p (XEXP (XEXP (loop_store_mems, 0), 0)));\n+\t\t   && ! loop_invariant_p (loop,\n+\t\t\t\t\t  XEXP (XEXP (loop_store_mems, 0),\n+\t\t\t\t\t\t0)));\n \n \t      /* If the store depends on a register that is set after the\n \t\t store, it depends on the initial value, and is thus not\n@@ -8115,7 +8129,7 @@ check_dbra_loop (loop, insn_count)\n \t\t ??? If the insns which initialize the comparison value as\n \t\t a whole compute an invariant result, then we could move\n \t\t them out of the loop and proceed with loop reversal.  */\n-\t      if (!invariant_p (comparison_value))\n+\t      if (! loop_invariant_p (loop, comparison_value))\n \t\treturn 0;\n \n \t      if (GET_CODE (comparison_value) == CONST_INT)\n@@ -8403,7 +8417,6 @@ check_dbra_loop (loop, insn_count)\n \f\n /* Verify whether the biv BL appears to be eliminable,\n    based on the insns in the loop that refer to it.\n-   LOOP_START is the first insn of the loop, and END is the end insn.\n \n    If ELIMINATE_P is non-zero, actually do the elimination.\n \n@@ -8412,15 +8425,15 @@ check_dbra_loop (loop, insn_count)\n    start of the loop.  */\n \n static int\n-maybe_eliminate_biv (bl, loop_start, loop_end, eliminate_p, threshold,\n-\t\t     insn_count)\n+maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n+     const struct loop *loop;\n      struct iv_class *bl;\n-     rtx loop_start;\n-     rtx loop_end;\n      int eliminate_p;\n      int threshold, insn_count;\n {\n   rtx reg = bl->biv->dest_reg;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n   rtx p;\n \n   /* Scan all insns in the loop, stopping if we find one that uses the\n@@ -8454,7 +8467,8 @@ maybe_eliminate_biv (bl, loop_start, loop_end, eliminate_p, threshold,\n \t}\n       if ((code == INSN || code == JUMP_INSN || code == CALL_INSN)\n \t  && reg_mentioned_p (reg, PATTERN (p))\n-\t  && ! maybe_eliminate_biv_1 (PATTERN (p), p, bl, eliminate_p, where))\n+\t  && ! maybe_eliminate_biv_1 (loop, PATTERN (p), p, bl,\n+\t\t\t\t      eliminate_p, where))\n \t{\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,\n@@ -8558,7 +8572,8 @@ biv_elimination_giv_has_0_offset (biv, giv, insn)\n    the loop.  */\n \n static int\n-maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n+maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n+     const struct loop *loop;\n      rtx x, insn;\n      struct iv_class *bl;\n      int eliminate_p;\n@@ -8777,7 +8792,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t}\n       else if (GET_CODE (arg) == REG || GET_CODE (arg) == MEM)\n \t{\n-\t  if (invariant_p (arg) == 1)\n+\t  if (loop_invariant_p (loop, arg) == 1)\n \t    {\n \t      /* Look for giv with constant positive mult_val and nonconst\n \t\t add_val. Insert insns to compute new compare value. \n@@ -8884,14 +8899,14 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n       switch (fmt[i])\n \t{\n \tcase 'e':\n-\t  if (! maybe_eliminate_biv_1 (XEXP (x, i), insn, bl, \n+\t  if (! maybe_eliminate_biv_1 (loop, XEXP (x, i), insn, bl, \n \t\t\t\t       eliminate_p, where))\n \t    return 0;\n \t  break;\n \n \tcase 'E':\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (! maybe_eliminate_biv_1 (XVECEXP (x, i, j), insn, bl,\n+\t    if (! maybe_eliminate_biv_1 (loop, XVECEXP (x, i, j), insn, bl,\n \t\t\t\t\t eliminate_p, where))\n \t      return 0;\n \t  break;\n@@ -9250,14 +9265,15 @@ get_condition (jump, earliest)\n    unless both operands are invariants.  */\n \n rtx\n-get_condition_for_loop (x)\n+get_condition_for_loop (loop, x)\n+     const struct loop *loop;\n      rtx x;\n {\n   rtx comparison = get_condition (x, NULL_PTR);\n \n   if (comparison == 0\n-      || ! invariant_p (XEXP (comparison, 0))\n-      || invariant_p (XEXP (comparison, 1)))\n+      || ! loop_invariant_p (loop, XEXP (comparison, 0))\n+      || loop_invariant_p (loop, XEXP (comparison, 1)))\n     return comparison;\n \n   return gen_rtx_fmt_ee (swap_condition (GET_CODE (comparison)), VOIDmode,\n@@ -9762,7 +9778,7 @@ load_mems (loop)\n       rtx mem_list_entry;\n \n       if (MEM_VOLATILE_P (mem) \n-\t  || invariant_p (XEXP (mem, 0)) != 1)\n+\t  || loop_invariant_p (loop, XEXP (mem, 0)) != 1)\n \t/* There's no telling whether or not MEM is modified.  */\n \tloop_mems[i].optimize = 0;\n \n@@ -9874,7 +9890,7 @@ load_mems (loop)\n \t  int j;\n \t  rtx set;\n \n-\t  /* Load the memory immediately before START, which is\n+\t  /* Load the memory immediately before LOOP->START, which is\n \t     the NOTE_LOOP_BEG.  */\n \t  set = gen_move_insn (reg, mem);\n \t  emit_insn_before (set, loop->start);\n@@ -9963,8 +9979,7 @@ note_reg_stored (x, setter, arg)\n /* Try to replace every occurrence of pseudo REGNO with REPLACEMENT.\n    There must be exactly one insn that sets this pseudo; it will be\n    deleted if all replacements succeed and we can prove that the register\n-   is not used after the loop.\n-   The arguments SCAN_START, LOOP_TOP and END are as in load_mems.  */\n+   is not used after the loop.  */\n static void\n try_copy_prop (loop, replacement, regno)\n      const struct loop *loop;"}, {"sha": "8fbde2146ac26663e7e35993d5e2ec2d622e1d15", "filename": "gcc/loop.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0534b8047e8a12c4748f70a7bbb3267319c21216/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0534b8047e8a12c4748f70a7bbb3267319c21216/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=0534b8047e8a12c4748f70a7bbb3267319c21216", "patch": "@@ -230,23 +230,21 @@ extern int first_increment_giv, last_increment_giv;\n \n /* Forward declarations for non-static functions declared in loop.c and\n    unroll.c.  */\n-int invariant_p PARAMS ((rtx));\n-rtx get_condition_for_loop PARAMS ((rtx));\n+int loop_invariant_p PARAMS ((const struct loop *, rtx));\n+rtx get_condition_for_loop PARAMS ((const struct loop *, rtx));\n void emit_iv_add_mult PARAMS ((rtx, rtx, rtx, rtx, rtx));\n rtx express_from PARAMS ((struct induction *, struct induction *));\n \n void unroll_loop PARAMS ((struct loop *, int, rtx, int));\n-rtx biv_total_increment PARAMS ((struct iv_class *, rtx, rtx));\n+rtx biv_total_increment PARAMS ((struct iv_class *));\n unsigned HOST_WIDE_INT loop_iterations PARAMS ((struct loop *));\n-int precondition_loop_p PARAMS ((rtx, struct loop_info *, \n+int precondition_loop_p PARAMS ((const struct loop *,\n \t\t\t       rtx *, rtx *, rtx *, \n \t\t\t       enum machine_mode *mode));\n-rtx final_biv_value PARAMS ((struct iv_class *, rtx, rtx,\n-\t\t\t   unsigned HOST_WIDE_INT));\n-rtx final_giv_value PARAMS ((struct induction *, rtx, rtx,\n-\t\t\t   unsigned HOST_WIDE_INT));\n+rtx final_biv_value PARAMS ((const struct loop *, struct iv_class *));\n+rtx final_giv_value PARAMS ((const struct loop *, struct induction *));\n void emit_unrolled_add PARAMS ((rtx, rtx, rtx));\n-int back_branch_in_range_p PARAMS ((rtx, rtx, rtx));\n+int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n \n int loop_insn_first_p PARAMS ((rtx, rtx));\n "}, {"sha": "7f3658eb2624c3517e5a72fdcbd11092c49f210b", "filename": "gcc/unroll.c", "status": "modified", "additions": 104, "deletions": 101, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0534b8047e8a12c4748f70a7bbb3267319c21216/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0534b8047e8a12c4748f70a7bbb3267319c21216/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=0534b8047e8a12c4748f70a7bbb3267319c21216", "patch": "@@ -200,26 +200,27 @@ static rtx initial_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n static void final_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n static void copy_loop_body PARAMS ((rtx, rtx, struct inline_remap *, rtx, int,\n \t\t\t\t  enum unroll_types, rtx, rtx, rtx, rtx));\n-static void iteration_info PARAMS ((rtx, rtx *, rtx *, rtx, rtx));\n-static int find_splittable_regs PARAMS ((enum unroll_types, rtx, rtx, rtx, int,\n-\t\t\t\t       unsigned HOST_WIDE_INT));\n-static int find_splittable_givs PARAMS ((struct iv_class *, enum unroll_types,\n-\t\t\t\t       rtx, rtx, rtx, int));\n-static int reg_dead_after_loop PARAMS ((rtx, rtx, rtx));\n+static void iteration_info PARAMS ((const struct loop *, rtx, rtx *, rtx *));\n+static int find_splittable_regs PARAMS ((const struct loop *,\n+\t\t\t\t\t enum unroll_types, rtx, int));\n+static int find_splittable_givs PARAMS ((const struct loop *, \n+\t\t\t\t\t struct iv_class *, enum unroll_types,\n+\t\t\t\t\t rtx, int));\n+static int reg_dead_after_loop PARAMS ((const struct loop *, rtx));\n static rtx fold_rtx_mult_add PARAMS ((rtx, rtx, rtx, enum machine_mode));\n static int verify_addresses PARAMS ((struct induction *, rtx, int));\n static rtx remap_split_bivs PARAMS ((rtx));\n static rtx find_common_reg_term PARAMS ((rtx, rtx));\n static rtx subtract_reg_term PARAMS ((rtx, rtx));\n-static rtx loop_find_equiv_value PARAMS ((rtx, rtx));\n+static rtx loop_find_equiv_value PARAMS ((const struct loop *, rtx));\n \n /* Try to unroll one loop and split induction variables in the loop.\n \n-   The loop is described by the arguments LOOP_END, INSN_COUNT, and\n-   LOOP_START.  END_INSERT_BEFORE indicates where insns should be added\n-   which need to be executed when the loop falls through.  STRENGTH_REDUCTION_P\n-   indicates whether information generated in the strength reduction pass\n-   is available.\n+   The loop is described by the arguments LOOP and INSN_COUNT.\n+   END_INSERT_BEFORE indicates where insns should be added which need\n+   to be executed when the loop falls through.  STRENGTH_REDUCTION_P\n+   indicates whether information generated in the strength reduction\n+   pass is available.\n \n    This function is intended to be called from within `strength_reduce'\n    in loop.c.  */\n@@ -894,7 +895,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n       rtx initial_value, final_value, increment;\n       enum machine_mode mode;\n \n-      if (precondition_loop_p (loop_start, loop_info,\n+      if (precondition_loop_p (loop,\n \t\t\t       &initial_value, &final_value, &increment,\n \t\t\t       &mode))\n \t{\n@@ -1158,9 +1159,8 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n   if (splitting_not_safe)\n     temp = 0;\n   else\n-    temp = find_splittable_regs (unroll_type, loop_start, loop_end,\n-\t\t\t\t end_insert_before, unroll_number,\n-\t\t\t\t loop_info->n_iterations);\n+    temp = find_splittable_regs (loop, unroll_type,\n+\t\t\t\t end_insert_before, unroll_number);\n \n   /* find_splittable_regs may have created some new registers, so must\n      reallocate the reg_map with the new larger size, and must realloc\n@@ -1356,13 +1356,13 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n    reflected in RTX_COST.  */\n \n int\n-precondition_loop_p (loop_start, loop_info,\n-\t\t     initial_value, final_value, increment, mode)\n-     rtx loop_start;\n-     struct loop_info *loop_info;\n+precondition_loop_p (loop, initial_value, final_value, increment, mode)\n+     const struct loop *loop;\n      rtx *initial_value, *final_value, *increment;\n      enum machine_mode *mode;\n {\n+  rtx loop_start = loop->start;\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n \n   if (loop_info->n_iterations > 0)\n     {\n@@ -1423,16 +1423,16 @@ precondition_loop_p (loop_start, loop_info,\n       return 0;\n     }\n \n-  /* Must ensure that final_value is invariant, so call invariant_p to\n-     check.  Before doing so, must check regno against max_reg_before_loop\n-     to make sure that the register is in the range covered by invariant_p.\n-     If it isn't, then it is most likely a biv/giv which by definition are\n-     not invariant.  */\n+  /* Must ensure that final_value is invariant, so call\n+     loop_invariant_p to check.  Before doing so, must check regno\n+     against max_reg_before_loop to make sure that the register is in\n+     the range covered by loop_invariant_p.  If it isn't, then it is\n+     most likely a biv/giv which by definition are not invariant.  */\n   if ((GET_CODE (loop_info->final_value) == REG\n        && REGNO (loop_info->final_value) >= max_reg_before_loop)\n       || (GET_CODE (loop_info->final_value) == PLUS\n \t  && REGNO (XEXP (loop_info->final_value, 0)) >= max_reg_before_loop)\n-      || ! invariant_p (loop_info->final_value))\n+      || ! loop_invariant_p (loop, loop_info->final_value))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -2288,21 +2288,23 @@ emit_unrolled_add (dest_reg, src_reg, increment)\n     emit_move_insn (dest_reg, result);\n }\n \f\n-/* Searches the insns between INSN and LOOP_END.  Returns 1 if there\n+/* Searches the insns between INSN and LOOP->END.  Returns 1 if there\n    is a backward branch in that range that branches to somewhere between\n-   LOOP_START and INSN.  Returns 0 otherwise.  */\n+   LOOP->START and INSN.  Returns 0 otherwise.  */\n \n /* ??? This is quadratic algorithm.  Could be rewritten to be linear.\n    In practice, this is not a problem, because this function is seldom called,\n    and uses a negligible amount of CPU time on average.  */\n \n int\n-back_branch_in_range_p (insn, loop_start, loop_end)\n+back_branch_in_range_p (loop, insn)\n+     const struct loop *loop;\n      rtx insn;\n-     rtx loop_start, loop_end;\n {\n   rtx p, q, target_insn;\n-  rtx orig_loop_end = loop_end;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n+  rtx orig_loop_end = loop->end;\n \n   /* Stop before we get to the backward branch at the end of the loop.  */\n   loop_end = prev_nonnote_insn (loop_end);\n@@ -2392,9 +2394,8 @@ fold_rtx_mult_add (mult1, mult2, add1, mode)\n    if it can be calculated.  Otherwise, returns 0.  */\n \n rtx\n-biv_total_increment (bl, loop_start, loop_end)\n+biv_total_increment (bl)\n      struct iv_class *bl;\n-     rtx loop_start ATTRIBUTE_UNUSED, loop_end ATTRIBUTE_UNUSED;\n {\n   struct induction *v;\n   rtx result;\n@@ -2427,14 +2428,11 @@ biv_total_increment (bl, loop_start, loop_end)\n    be calculated.  */\n \n static void\n-iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n+iteration_info (loop, iteration_var, initial_value, increment)\n+     const struct loop *loop;\n      rtx iteration_var, *initial_value, *increment;\n-     rtx loop_start, loop_end;\n {\n   struct iv_class *bl;\n-#if 0\n-  struct induction *v;\n-#endif\n \n   /* Clear the result values, in case no answer can be found.  */\n   *initial_value = 0;\n@@ -2484,7 +2482,7 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n       bl = reg_biv_class[REGNO (iteration_var)];\n       *initial_value = bl->initial_value;\n \n-      *increment = biv_total_increment (bl, loop_start, loop_end);\n+      *increment = biv_total_increment (bl);\n     }\n   else if (REG_IV_TYPE (REGNO (iteration_var)) == GENERAL_INDUCT)\n     {\n@@ -2498,7 +2496,7 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n \n       /* Increment value is mult_val times the increment value of the biv.  */\n \n-      *increment = biv_total_increment (bl, loop_start, loop_end);\n+      *increment = biv_total_increment (bl);\n       if (*increment)\n \t{\n \t  struct induction *biv_inc;\n@@ -2564,27 +2562,27 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n    times, since multiplies by small integers (1,2,3,4) are very cheap.  */\n \n static int\n-find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n-\t\t     unroll_number, n_iterations)\n+find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n+     const struct loop *loop;\n      enum unroll_types unroll_type;\n-     rtx loop_start, loop_end;\n      rtx end_insert_before;\n      int unroll_number;\n-     unsigned HOST_WIDE_INT n_iterations;\n {\n   struct iv_class *bl;\n   struct induction *v;\n   rtx increment, tem;\n   rtx biv_final_value;\n   int biv_splittable;\n   int result = 0;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n \n   for (bl = loop_iv_list; bl; bl = bl->next)\n     {\n       /* Biv_total_increment must return a constant value,\n \t otherwise we can not calculate the split values.  */\n \n-      increment = biv_total_increment (bl, loop_start, loop_end);\n+      increment = biv_total_increment (bl);\n       if (! increment || GET_CODE (increment) != CONST_INT)\n \tcontinue;\n \n@@ -2600,16 +2598,14 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n       biv_splittable = 1;\n       biv_final_value = 0;\n       if (unroll_type != UNROLL_COMPLETELY\n-\t  && (uid_loop[INSN_UID (loop_start)]->exit_count\n-\t      || unroll_type == UNROLL_NAIVE)\n+\t  && (loop->exit_count || unroll_type == UNROLL_NAIVE)\n \t  && (uid_luid[REGNO_LAST_UID (bl->regno)] >= INSN_LUID (loop_end)\n \t      || ! bl->init_insn\n \t      || INSN_UID (bl->init_insn) >= max_uid_for_loop\n \t      || (uid_luid[REGNO_FIRST_UID (bl->regno)]\n \t\t  < INSN_LUID (bl->init_insn))\n \t      || reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n-\t  && ! (biv_final_value = final_biv_value (bl, loop_start, loop_end,\n-\t\t\t\t\t\t   n_iterations)))\n+\t  && ! (biv_final_value = final_biv_value (loop, bl)))\n \tbiv_splittable = 0;\n \n       /* If any of the insns setting the BIV don't do so with a simple\n@@ -2641,7 +2637,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t      if (GET_CODE (bl->initial_value) == REG\n \t\t  && (REGNO (bl->initial_value) == bl->regno\n \t\t      || REGNO (bl->initial_value) < FIRST_PSEUDO_REGISTER\n-\t\t      || ! invariant_p (bl->initial_value)))\n+\t\t      || ! loop_invariant_p (loop, bl->initial_value)))\n \t\t{\n \t\t  rtx tem = gen_reg_rtx (bl->biv->mode);\n \n@@ -2677,8 +2673,8 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t depend on it may be splittable if the biv is live outside the\n \t loop, and the givs aren't.  */\n \n-      result += find_splittable_givs (bl, unroll_type, loop_start, loop_end,\n-\t\t\t\t     increment, unroll_number);\n+      result += find_splittable_givs (loop, bl, unroll_type, increment, \n+\t\t\t\t      unroll_number);\n \n       /* If final value is non-zero, then must emit an instruction which sets\n \t the value of the biv to the proper value.  This is done after\n@@ -2690,7 +2686,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t     loop to ensure that it will always be executed no matter\n \t     how the loop exits.  Otherwise emit the insn after the loop,\n \t     since this is slightly more efficient.  */\n-\t  if (! uid_loop[INSN_UID (loop_start)]->exit_count)\n+\t  if (! loop->exit_count)\n \t    emit_insn_before (gen_move_insn (bl->biv->src_reg,\n \t\t\t\t\t     biv_final_value),\n \t\t\t      end_insert_before);\n@@ -2758,11 +2754,10 @@ verify_addresses (v, giv_inc, unroll_number)\n    Return the number of instructions that set splittable registers.  */\n \n static int\n-find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n-\t\t      unroll_number)\n+find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n+     const struct loop *loop;\n      struct iv_class *bl;\n      enum unroll_types unroll_type;\n-     rtx loop_start, loop_end;\n      rtx increment;\n      int unroll_number;\n {\n@@ -2796,7 +2791,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t won't reach here if they aren't.  */\n       if (v->giv_type != DEST_ADDR\n \t  && (! v->always_computable\n-\t      || back_branch_in_range_p (v->insn, loop_start, loop_end)))\n+\t      || back_branch_in_range_p (loop, v->insn)))\n \tcontinue;\n \n       /* The giv increment value must be a constant.  */\n@@ -2817,8 +2812,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \n       final_value = 0;\n       if (unroll_type != UNROLL_COMPLETELY\n-\t  && (uid_loop[INSN_UID (loop_start)]->exit_count\n-\t      || unroll_type == UNROLL_NAIVE)\n+\t  && (loop->exit_count || unroll_type == UNROLL_NAIVE)\n \t  && v->giv_type != DEST_ADDR\n \t  /* The next part is true if the pseudo is used outside the loop.\n \t     We assume that this is true for any pseudo created after loop\n@@ -2833,7 +2827,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t\t  != INSN_UID (XEXP (tem, 0)))))\n \t      /* Line above always fails if INSN was moved by loop opt.  */\n \t      || (uid_luid[REGNO_LAST_UID (REGNO (v->dest_reg))]\n-\t\t  >= INSN_LUID (loop_end)))\n+\t\t  >= INSN_LUID (loop->end)))\n \t  /* Givs made from biv increments are missed by the above test, so\n \t     test explicitly for them.  */\n \t  && (REGNO (v->dest_reg) < first_increment_giv\n@@ -2891,7 +2885,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \n \t      record_base_value (REGNO (tem), bl->biv->add_val, 0);\n \t      emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n-\t\t\t\tloop_start);\n+\t\t\t\tloop->start);\n \t      biv_initial_value = tem;\n \t    }\n \t  value = fold_rtx_mult_add (v->mult_val, biv_initial_value,\n@@ -2933,7 +2927,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t  rtx tem = gen_reg_rtx (v->mode);\n \t\t  record_base_value (REGNO (tem), v->add_val, 0);\n \t\t  emit_iv_add_mult (bl->initial_value, v->mult_val,\n-\t\t\t\t    v->add_val, tem, loop_start);\n+\t\t\t\t    v->add_val, tem, loop->start);\n \t\t  value = tem;\n \t\t}\n \n@@ -3082,24 +3076,24 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t     to calculate the value from scratch.  */\n \t\t  emit_insn_before (gen_rtx_SET (VOIDmode, tem,\n \t\t\t\t\t\t copy_rtx (v->new_reg)),\n-\t\t\t\t    loop_start);\n-\t\t  if (recog_memoized (PREV_INSN (loop_start)) < 0)\n+\t\t\t\t    loop->start);\n+\t\t  if (recog_memoized (PREV_INSN (loop->start)) < 0)\n \t\t    {\n \t\t      rtx sequence, ret;\n \n \t\t      /* We can't use bl->initial_value to compute the initial\n \t\t\t value, because the loop may have been preconditioned.\n \t\t\t We must calculate it from NEW_REG.  Try using\n \t\t\t force_operand instead of emit_iv_add_mult.  */\n-\t\t      delete_insn (PREV_INSN (loop_start));\n+\t\t      delete_insn (PREV_INSN (loop->start));\n \n \t\t      start_sequence ();\n \t\t      ret = force_operand (v->new_reg, tem);\n \t\t      if (ret != tem)\n \t\t\temit_move_insn (tem, ret);\n \t\t      sequence = gen_sequence ();\n \t\t      end_sequence ();\n-\t\t      emit_insn_before (sequence, loop_start);\n+\t\t      emit_insn_before (sequence, loop->start);\n \n \t\t      if (loop_dump_stream)\n \t\t\tfprintf (loop_dump_stream,\n@@ -3238,14 +3232,14 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n    it can search past if statements and other similar structures.  */\n \n static int\n-reg_dead_after_loop (reg, loop_start, loop_end)\n-     rtx reg, loop_start, loop_end;\n+reg_dead_after_loop (loop, reg)\n+     const struct loop *loop;\n+     rtx reg;\n {\n   rtx insn, label;\n   enum rtx_code code;\n   int jump_count = 0;\n   int label_count = 0;\n-  struct loop *loop = uid_loop[INSN_UID (loop_start)];\n \n   /* In addition to checking all exits of this loop, we must also check\n      all exits of inner nested loops that would exit this loop.  We don't\n@@ -3259,9 +3253,9 @@ reg_dead_after_loop (reg, loop_start, loop_end)\n     return 0;\n \n   /* HACK: Must also search the loop fall through exit, create a label_ref\n-     here which points to the loop_end, and append the loop_number_exit_labels\n+     here which points to the loop->end, and append the loop_number_exit_labels\n      list to it.  */\n-  label = gen_rtx_LABEL_REF (VOIDmode, loop_end);\n+  label = gen_rtx_LABEL_REF (VOIDmode, loop->end);\n   LABEL_NEXTREF (label) = loop->exit_labels;\n \n   for ( ; label; label = LABEL_NEXTREF (label))\n@@ -3310,11 +3304,12 @@ reg_dead_after_loop (reg, loop_start, loop_end)\n    the end of the loop.  If we can do it, return that value.  */\n \n rtx\n-final_biv_value (bl, loop_start, loop_end, n_iterations)\n+final_biv_value (loop, bl)\n+     const struct loop *loop;\n      struct iv_class *bl;\n-     rtx loop_start, loop_end;\n-     unsigned HOST_WIDE_INT n_iterations;\n {\n+  rtx loop_end = loop->end;\n+  unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n   rtx increment, tem;\n \n   /* ??? This only works for MODE_INT biv's.  Reject all others for now.  */\n@@ -3342,12 +3337,12 @@ final_biv_value (bl, loop_start, loop_end, n_iterations)\n      value of the biv must be invariant.  */\n \n   if (n_iterations != 0\n-      && ! uid_loop[INSN_UID (loop_start)]->exit_count\n-      && invariant_p (bl->initial_value))\n+      && ! loop->exit_count\n+      && loop_invariant_p (loop, bl->initial_value))\n     {\n-      increment = biv_total_increment (bl, loop_start, loop_end);\n+      increment = biv_total_increment (bl);\n \n-      if (increment && invariant_p (increment))\n+      if (increment && loop_invariant_p (loop, increment))\n \t{\n \t  /* Can calculate the loop exit value, emit insns after loop\n \t     end to calculate this value into a temporary register in\n@@ -3370,7 +3365,7 @@ final_biv_value (bl, loop_start, loop_end, n_iterations)\n     }\n \n   /* Check to see if the biv is dead at all loop exits.  */\n-  if (reg_dead_after_loop (bl->biv->src_reg, loop_start, loop_end))\n+  if (reg_dead_after_loop (loop, bl->biv->src_reg))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -3387,15 +3382,16 @@ final_biv_value (bl, loop_start, loop_end, n_iterations)\n    the end of the loop.  If we can do it, return that value.  */\n \n rtx\n-final_giv_value (v, loop_start, loop_end, n_iterations)\n+final_giv_value (loop, v)\n+     const struct loop *loop;\n      struct induction *v;\n-     rtx loop_start, loop_end;\n-     unsigned HOST_WIDE_INT n_iterations;\n {\n   struct iv_class *bl;\n   rtx insn;\n   rtx increment, tem;\n   rtx insert_before, seq;\n+  rtx loop_end = loop->end;\n+  unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n \n   bl = reg_biv_class[REGNO (v->src_reg)];\n \n@@ -3422,7 +3418,7 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n      to be known.  */\n \n   if (n_iterations != 0\n-      && ! uid_loop[INSN_UID (loop_start)]->exit_count)\n+      && ! loop->exit_count)\n     {\n       /* ?? It is tempting to use the biv's value here since these insns will\n \t be put after the loop, and hence the biv will have its final value\n@@ -3435,10 +3431,10 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n \t sure that bl->initial_value is still valid then.  It will still\n \t be valid if it is invariant.  */\n \n-      increment = biv_total_increment (bl, loop_start, loop_end);\n+      increment = biv_total_increment (bl);\n \n-      if (increment && invariant_p (increment)\n-\t  && invariant_p (bl->initial_value))\n+      if (increment && loop_invariant_p (loop, increment)\n+\t  && loop_invariant_p (loop, bl->initial_value))\n \t{\n \t  /* Can calculate the loop exit value of its biv as\n \t     (n_iterations * increment) + initial_value */\n@@ -3495,7 +3491,7 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n     abort ();\n \n   /* Check to see if the biv is dead at all loop exits.  */\n-  if (reg_dead_after_loop (v->dest_reg, loop_start, loop_end))\n+  if (reg_dead_after_loop (loop, v->dest_reg))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -3509,15 +3505,16 @@ final_giv_value (v, loop_start, loop_end, n_iterations)\n }\n \n \n-/* Look back before LOOP_START for then insn that sets REG and return\n+/* Look back before LOOP->START for then insn that sets REG and return\n    the equivalent constant if there is a REG_EQUAL note otherwise just\n    the SET_SRC of REG.  */\n \n static rtx\n-loop_find_equiv_value (loop_start, reg)\n-     rtx loop_start;\n+loop_find_equiv_value (loop, reg)\n+     const struct loop *loop;\n      rtx reg;\n {\n+  rtx loop_start = loop->start;\n   rtx insn, set;\n   rtx ret;\n \n@@ -3678,7 +3675,7 @@ loop_iterations (loop)\n      branch, and the insn before tests a register value, make that the\n      iteration variable.  */\n \n-  comparison = get_condition_for_loop (last_loop_insn);\n+  comparison = get_condition_for_loop (loop, last_loop_insn);\n   if (comparison == 0)\n     {\n       if (loop_dump_stream)\n@@ -3712,8 +3709,8 @@ loop_iterations (loop)\n       && ! REG_USERVAR_P (iteration_var))\n     abort ();\n \n-  iteration_info (iteration_var, &initial_value, &increment,\n-\t\t  loop->start, loop->end);\n+  iteration_info (loop, iteration_var, &initial_value, &increment);\n+\n   if (initial_value == 0)\n     /* iteration_info already printed a message.  */\n     return 0;\n@@ -3758,12 +3755,14 @@ loop_iterations (loop)\n      its value from the insns before the start of the loop.  */\n \n   final_value = comparison_value;\n-  if (GET_CODE (comparison_value) == REG && invariant_p (comparison_value))\n+  if (GET_CODE (comparison_value) == REG \n+      && loop_invariant_p (loop, comparison_value))\n     {\n-      final_value = loop_find_equiv_value (loop->start, comparison_value);\n+      final_value = loop_find_equiv_value (loop, comparison_value);\n+\n       /* If we don't get an invariant final value, we are better\n \t off with the original register.  */\n-      if (!invariant_p (final_value))\n+      if (! loop_invariant_p (loop, final_value))\n \tfinal_value = comparison_value;\n     }\n \n@@ -3820,15 +3819,17 @@ loop_iterations (loop)\n \n \t  /* Find what reg1 is equivalent to.  Hopefully it will\n \t     either be reg2 or reg2 plus a constant.  */\n-\t  temp = loop_find_equiv_value (loop->start, reg1);\n+\t  temp = loop_find_equiv_value (loop, reg1);\n+\n \t  if (find_common_reg_term (temp, reg2))\n \t    initial_value = temp;\n \t  else\n \t    {\n \t      /* Find what reg2 is equivalent to.  Hopefully it will\n \t\t either be reg1 or reg1 plus a constant.  Let's ignore\n \t\t the latter case for now since it is not so common.  */\n-\t      temp = loop_find_equiv_value (loop->start, reg2);\n+\t      temp = loop_find_equiv_value (loop, reg2);\n+\n \t      if (temp == loop_info->iteration_var)\n \t\ttemp = initial_value;\n \t      if (temp == reg1)\n@@ -3847,10 +3848,12 @@ loop_iterations (loop)\n \t      where temp2 = init + const.  If the loop has a vtop we\n \t      can replace initial_value with const.  */\n \n-\t  temp = loop_find_equiv_value (loop->start, reg1);\n+\t  temp = loop_find_equiv_value (loop, reg1);\n+\n \t  if (GET_CODE (temp) == MINUS && REG_P (XEXP (temp, 0)))\n \t    {\n-\t      rtx temp2 = loop_find_equiv_value (loop->start, XEXP (temp, 0));\n+\t      rtx temp2 = loop_find_equiv_value (loop, XEXP (temp, 0));\n+\n \t      if (GET_CODE (temp2) == PLUS\n \t\t  && XEXP (temp2, 0) == XEXP (temp, 1))\n \t\tinitial_value = XEXP (temp2, 1);\n@@ -3897,7 +3900,7 @@ loop_iterations (loop)\n       /* ??? Other RTL, such as (neg (reg)) is possible here, but it isn't\n \t clear if it is worthwhile to try to handle such RTL.  */\n       if (GET_CODE (increment) == REG || GET_CODE (increment) == SUBREG)\n-\tincrement = loop_find_equiv_value (loop->start, increment);\n+\tincrement = loop_find_equiv_value (loop, increment);\n \n       if (GET_CODE (increment) != CONST_INT)\n \t{"}]}