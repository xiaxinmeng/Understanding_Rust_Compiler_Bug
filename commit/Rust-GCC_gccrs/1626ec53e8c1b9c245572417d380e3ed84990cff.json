{"sha": "1626ec53e8c1b9c245572417d380e3ed84990cff", "node_id": "C_kwDOANBUbNoAKDE2MjZlYzUzZThjMWI5YzI0NTU3MjQxN2QzODBlM2VkODQ5OTBjZmY", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2023-01-17T16:39:47Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2023-01-31T14:56:27Z"}, "message": "Add op2_range to pointer_plus.\n\nImplement op2_range for pointer_plus to determine the offset (operand 2) is\nzero or non-zero based on equality/inequality between the LHS and op1.\nAlso allow GORI computations to continue if the LHS is VARYING and there\nis also a relation.\n\n\tPR tree-optimization/108385\n\tgcc/\n\t* gimple-range-gori.cc (gori_compute::compute_operand_range):\n\tAllow VARYING computations to continue if there is a relation.\n\t* range-op.cc (pointer_plus_operator::op2_range): New.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr108385.c: New.", "tree": {"sha": "6d7ae16ee9d8774a96a6d0d75c80e5b2b8460584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d7ae16ee9d8774a96a6d0d75c80e5b2b8460584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1626ec53e8c1b9c245572417d380e3ed84990cff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1626ec53e8c1b9c245572417d380e3ed84990cff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1626ec53e8c1b9c245572417d380e3ed84990cff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1626ec53e8c1b9c245572417d380e3ed84990cff/comments", "author": null, "committer": null, "parents": [{"sha": "809d661aff99ae0287baf4a52269425de62381e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809d661aff99ae0287baf4a52269425de62381e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809d661aff99ae0287baf4a52269425de62381e6"}], "stats": {"total": 75, "additions": 71, "deletions": 4}, "files": [{"sha": "beb1c0064b9805ac541fccf57e20d01bbd351222", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1626ec53e8c1b9c245572417d380e3ed84990cff/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1626ec53e8c1b9c245572417d380e3ed84990cff/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=1626ec53e8c1b9c245572417d380e3ed84990cff", "patch": "@@ -607,10 +607,6 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n {\n   value_relation vrel;\n   value_relation *vrel_ptr = rel;\n-  // If the lhs doesn't tell us anything, neither will unwinding further.\n-  if (lhs.varying_p ())\n-    return false;\n-\n   // Empty ranges are viral as they are on an unexecutable path.\n   if (lhs.undefined_p ())\n     {\n@@ -657,10 +653,19 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n   if (!op1_in_chain && !op2_in_chain)\n     return false;\n \n+  // If the lhs doesn't tell us anything and there are no relations, there\n+  // is nothing to be learned.\n+  if (lhs.varying_p () && !vrel_ptr)\n+    return false;\n+\n   bool res;\n   // Process logicals as they have special handling.\n   if (is_gimple_logical_p (stmt))\n     {\n+      // If the lhs doesn't tell us anything, neither will combining operands.\n+      if (lhs.varying_p ())\n+\treturn false;\n+\n       unsigned idx;\n       if ((idx = tracer.header (\"compute_operand \")))\n \t{"}, {"sha": "136b709385cd6f0e2b453fa25ab41ce4aab1bff6", "filename": "gcc/range-op.cc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1626ec53e8c1b9c245572417d380e3ed84990cff/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1626ec53e8c1b9c245572417d380e3ed84990cff/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=1626ec53e8c1b9c245572417d380e3ed84990cff", "patch": "@@ -4212,6 +4212,10 @@ class pointer_plus_operator : public range_operator\n \t\t        const wide_int &lh_ub,\n \t\t        const wide_int &rh_lb,\n \t\t        const wide_int &rh_ub) const;\n+  virtual bool op2_range (irange &r, tree type,\n+\t\t\t  const irange &lhs,\n+\t\t\t  const irange &op1,\n+\t\t\t  relation_trio = TRIO_VARYING) const;\n } op_pointer_plus;\n \n void\n@@ -4258,6 +4262,25 @@ pointer_plus_operator::wi_fold (irange &r, tree type,\n    r.set_varying (type);\n }\n \n+bool\n+pointer_plus_operator::op2_range (irange &r, tree type,\n+\t\t\t\t  const irange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t  const irange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t  relation_trio trio) const\n+{\n+  relation_kind rel = trio.lhs_op1 ();\n+  r.set_varying (type);\n+\n+  // If the LHS and OP1 are equal, the op2 must be zero.\n+  if (rel == VREL_EQ)\n+    r.set_zero (type);\n+  // If the LHS and OP1 are not equal, the offset must be non-zero.\n+  else if (rel == VREL_NE)\n+    r.set_nonzero (type);\n+  else\n+    return false;\n+  return true;\n+}\n \n class pointer_min_max_operator : public range_operator\n {"}, {"sha": "13babf06d9a479a749536b82d701a4333b12718d", "filename": "gcc/testsuite/gcc.dg/pr108385.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1626ec53e8c1b9c245572417d380e3ed84990cff/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108385.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1626ec53e8c1b9c245572417d380e3ed84990cff/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108385.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108385.c?ref=1626ec53e8c1b9c245572417d380e3ed84990cff", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+void bar(char *);\n+\n+/* Ensure that PTR1 = PTR2 + OFF properly picks up the zero and non-zero\n+   properties if PTR1 and PTR2 are known equal or non-equal.  */\n+\n+void foo1 (char *p, char *pp, int off)\n+{\n+  char *q = p + off;\n+  if (q != p)\n+    {\n+      if (off == 0)\n+\t  bar (q);\n+    }\n+  else\n+    {\n+      if (off != 0)\n+        bar (p);\n+    }\n+}\n+\n+void foo2 (char *p, char *pp, int off)\n+{\n+  char *q = p + off;\n+  if (q == p)\n+    {\n+      if (off != 0)\n+        bar (p);\n+    }\n+  else\n+    {\n+      if (off == 0)\n+\t  bar (q);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"bar\" \"evrp\" } } */"}]}