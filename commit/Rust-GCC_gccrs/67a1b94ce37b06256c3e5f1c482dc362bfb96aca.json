{"sha": "67a1b94ce37b06256c3e5f1c482dc362bfb96aca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdhMWI5NGNlMzdiMDYyNTZjM2U1ZjFjNDgyZGMzNjJiZmI5NmFjYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-10-02T04:45:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-10-02T04:45:44Z"}, "message": "* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::restrict_to_inner_class):\n\tRename EXPECTED_TYPE to OTR_TYPE; Validate speculation late;\n\tuse speculation_consistent_p to do so; Add CONSDER_BASES\n\tand CONSIDER_PLACEMENT_NEW parameters.\n\t(contains_type_p): Add CONSDER_PLACEMENT_NEW and CONSIDER_BASES;\n\tshort circuit obvious cases.\n\t(ipa_polymorphic_call_context::dump): Improve formatting.\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Use\n\tcombine_speculation_with to record speculations; Do not ICE when\n\tobject is located in pointer type decl; do not ICE for methods\n\tof UNION_TYPE; do not record nonpolymorphic types.\n\t(ipa_polymorphic_call_context::speculation_consistent_p): New method.\n\t(ipa_polymorphic_call_context::combine_speculation_with): New method.\n\t(ipa_polymorphic_call_context::combine_with): New method.\n\t(ipa_polymorphic_call_context::make_speculative): Move here; use\n\tcombine speculation.\n\t* cgraph.h (ipa_polymorphic_call_context): Update\n\trestrict_to_inner_class prototype; add offset_by, make_speculative, \n\tcombine_with, useless_p, combine_speculation_with and\n\tspeculation_consistent_p methods.\n\t(ipa_polymorphic_call_context::offset_by): New method.\n\t(ipa_polymorphic_call_context::useless_p): New method.\n\nFrom-SVN: r215790", "tree": {"sha": "91aae0c45a18d47eee745c1fff31111ffe05564d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91aae0c45a18d47eee745c1fff31111ffe05564d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67a1b94ce37b06256c3e5f1c482dc362bfb96aca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a1b94ce37b06256c3e5f1c482dc362bfb96aca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67a1b94ce37b06256c3e5f1c482dc362bfb96aca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a1b94ce37b06256c3e5f1c482dc362bfb96aca/comments", "author": null, "committer": null, "parents": [{"sha": "fef32cf89f7fe0c8864443dca942c6e34a204976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef32cf89f7fe0c8864443dca942c6e34a204976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef32cf89f7fe0c8864443dca942c6e34a204976"}], "stats": {"total": 701, "additions": 617, "deletions": 84}, "files": [{"sha": "3d65423077746cc89f07c5c13aeb265608a18bbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a1b94ce37b06256c3e5f1c482dc362bfb96aca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a1b94ce37b06256c3e5f1c482dc362bfb96aca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67a1b94ce37b06256c3e5f1c482dc362bfb96aca", "patch": "@@ -1,3 +1,29 @@\n+2014-10-01  Jan HUbicka  <hubicka@ucw.cz>\n+\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::restrict_to_inner_class):\n+\tRename EXPECTED_TYPE to OTR_TYPE; Validate speculation late;\n+\tuse speculation_consistent_p to do so; Add CONSDER_BASES\n+\tand CONSIDER_PLACEMENT_NEW parameters.\n+\t(contains_type_p): Add CONSDER_PLACEMENT_NEW and CONSIDER_BASES;\n+\tshort circuit obvious cases.\n+\t(ipa_polymorphic_call_context::dump): Improve formatting.\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Use\n+\tcombine_speculation_with to record speculations; Do not ICE when\n+\tobject is located in pointer type decl; do not ICE for methods\n+\tof UNION_TYPE; do not record nonpolymorphic types.\n+\t(ipa_polymorphic_call_context::speculation_consistent_p): New method.\n+\t(ipa_polymorphic_call_context::combine_speculation_with): New method.\n+\t(ipa_polymorphic_call_context::combine_with): New method.\n+\t(ipa_polymorphic_call_context::make_speculative): Move here; use\n+\tcombine speculation.\n+\t* cgraph.h (ipa_polymorphic_call_context): Update\n+\trestrict_to_inner_class prototype; add offset_by, make_speculative, \n+\tcombine_with, useless_p, combine_speculation_with and\n+\tspeculation_consistent_p methods.\n+\t(ipa_polymorphic_call_context::offset_by): New method.\n+\t(ipa_polymorphic_call_context::useless_p): New method.\n+\n 2014-10-01  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/62151"}, {"sha": "fb41b01cf349c5c58bc9e877158a75c9c16930f0", "filename": "gcc/cgraph.h", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a1b94ce37b06256c3e5f1c482dc362bfb96aca/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a1b94ce37b06256c3e5f1c482dc362bfb96aca/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=67a1b94ce37b06256c3e5f1c482dc362bfb96aca", "patch": "@@ -1314,8 +1314,35 @@ class GTY(()) ipa_polymorphic_call_context {\n   void clear_speculation ();\n \n   /* Walk container types and modify context to point to actual class\n-     containing EXPECTED_TYPE as base class.  */\n-  bool restrict_to_inner_class (tree expected_type);\n+     containing OTR_TYPE (if non-NULL) as base class.\n+     Return true if resulting context is valid.\n+\n+     When CONSIDER_PLACEMENT_NEW is false, reject contexts that may be made\n+     valid only via alocation of new polymorphic type inside by means\n+     of placement new.\n+\n+     When CONSIDER_BASES is false, only look for actual fields, not base types\n+     of TYPE.  */\n+  bool restrict_to_inner_class (tree otr_type,\n+\t\t\t\tbool consider_placement_new = true,\n+\t\t\t\tbool consider_bases = true);\n+\n+  /* Adjust all offsets in contexts by given number of bits.  */\n+  void offset_by (HOST_WIDE_INT);\n+  /* Take non-speculative info, merge it with speculative and clear speculatoin.\n+     Used when we no longer manage to keep track of actual outer type, but we\n+     think it is still there. \n+     If OTR_TYPE is set, the transformation can be done more effectively assuming\n+     that context is going to be used only that way.  */\n+  void make_speculative (tree otr_type = NULL);\n+  /* Assume that both THIS and a given context is valid and strenghten THIS\n+     if possible.  Return true if any strenghtening was made.\n+     If actual type the context is being used in is known, OTR_TYPE should be\n+     set accordingly. This improves quality of combined result.  */\n+  bool combine_with (ipa_polymorphic_call_context, tree otr_type = NULL);\n+\n+  /* Return TRUE if context is fully useless.  */\n+  bool useless_p () const;\n \n   /* Dump human readable context to F.  */\n   void dump (FILE *f) const;\n@@ -1326,9 +1353,11 @@ class GTY(()) ipa_polymorphic_call_context {\n   void stream_in (struct lto_input_block *, struct data_in *data_in);\n \n private:\n+  bool combine_speculation_with (tree, HOST_WIDE_INT, bool, tree);\n   void set_by_decl (tree, HOST_WIDE_INT);\n   bool set_by_invariant (tree, tree, HOST_WIDE_INT);\n   void clear_outer_type (tree otr_type = NULL);\n+  bool speculation_consistent_p (tree, HOST_WIDE_INT, bool, tree);\n };\n \n /* Structure containing additional information about an indirect call.  */\n@@ -2634,4 +2663,23 @@ ipa_polymorphic_call_context::clear_outer_type (tree otr_type)\n   maybe_derived_type = true;\n   maybe_in_construction = true;\n }\n+\n+/* Adjust all offsets in contexts by OFF bits.  */\n+\n+inline void\n+ipa_polymorphic_call_context::offset_by (HOST_WIDE_INT off)\n+{\n+  if (outer_type)\n+    offset += off;\n+  if (speculative_outer_type)\n+    speculative_offset += off;\n+}\n+\n+/* Return TRUE if context is fully useless.  */\n+\n+inline bool\n+ipa_polymorphic_call_context::useless_p () const\n+{\n+  return (!outer_type && !speculative_outer_type);\n+}\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "e71d3ba666183ce1a5989d7bd49e16a9368f5979", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 541, "deletions": 82, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a1b94ce37b06256c3e5f1c482dc362bfb96aca/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a1b94ce37b06256c3e5f1c482dc362bfb96aca/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=67a1b94ce37b06256c3e5f1c482dc362bfb96aca", "patch": "@@ -53,7 +53,9 @@ along with GCC; see the file COPYING3.  If not see\n /* Return true when TYPE contains an polymorphic type and thus is interesting\n    for devirtualization machinery.  */\n \n-static bool contains_type_p (tree, HOST_WIDE_INT, tree);\n+static bool contains_type_p (tree, HOST_WIDE_INT, tree,\n+\t\t\t     bool consider_placement_new = true,\n+\t\t\t     bool consider_bases = true);\n \n bool\n contains_polymorphic_type_p (const_tree type)\n@@ -99,13 +101,13 @@ possible_placement_new (tree type, tree expected_type,\n \t\t  <= tree_to_uhwi (TYPE_SIZE (type)))));\n }\n \n-/* THIS->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n+/* THIS->OUTER_TYPE is a type of memory object where object of OTR_TYPE\n    is contained at THIS->OFFSET.  Walk the memory representation of\n    THIS->OUTER_TYPE and find the outermost class type that match\n-   EXPECTED_TYPE or contain EXPECTED_TYPE as a base.  Update THIS\n+   OTR_TYPE or contain OTR_TYPE as a base.  Update THIS\n    to represent it.\n \n-   If EXPECTED_TYPE is NULL, just find outermost polymorphic type with\n+   If OTR_TYPE is NULL, just find outermost polymorphic type with\n    virtual table present at possition OFFSET.\n \n    For example when THIS represents type\n@@ -119,22 +121,32 @@ possible_placement_new (tree type, tree expected_type,\n    sizeof(int). \n \n    If we can not find corresponding class, give up by setting\n-   THIS->OUTER_TYPE to EXPECTED_TYPE and THIS->OFFSET to NULL. \n-   Return true when lookup was sucesful.  */\n+   THIS->OUTER_TYPE to OTR_TYPE and THIS->OFFSET to NULL. \n+   Return true when lookup was sucesful.\n+\n+   When CONSIDER_PLACEMENT_NEW is false, reject contexts that may be made\n+   valid only via alocation of new polymorphic type inside by means\n+   of placement new.\n+\n+   When CONSIDER_BASES is false, only look for actual fields, not base types\n+   of TYPE.  */\n \n bool\n-ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n+ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n+\t\t\t\t\t\t       bool consider_placement_new,\n+\t\t\t\t\t\t       bool consider_bases)\n {\n   tree type = outer_type;\n   HOST_WIDE_INT cur_offset = offset;\n   bool speculative = false;\n   bool size_unknown = false;\n+  unsigned HOST_WIDE_INT otr_type_size = GET_MODE_BITSIZE (Pmode);\n \n   /* Update OUTER_TYPE to match EXPECTED_TYPE if it is not set.  */\n   if (!outer_type)\n     {\n-      clear_outer_type (expected_type);\n-      type = expected_type;\n+      clear_outer_type (otr_type);\n+      type = otr_type;\n       cur_offset = 0;\n     }\n  /* See if OFFSET points inside OUTER_TYPE.  If it does not, we know\n@@ -151,8 +163,8 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t   && tree_to_shwi (TYPE_SIZE (outer_type)) >= 0\n \t   && tree_to_shwi (TYPE_SIZE (outer_type)) <= offset)\n    {\n-     clear_outer_type (expected_type);\n-     type = expected_type;\n+     clear_outer_type (otr_type);\n+     type = otr_type;\n      cur_offset = 0;\n \n      /* If derived type is not allowed, we know that the context is invalid.  */\n@@ -164,36 +176,11 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n        }\n    }\n \n-  if (speculative_outer_type)\n-    {\n-      /* Short cirucit the busy work bellow and give up on case when speculation\n-\t is obviously the same as outer_type.  */\n-      if ((!maybe_derived_type\n-\t   || speculative_maybe_derived_type)\n-\t  && types_must_be_same_for_odr (speculative_outer_type, outer_type))\n-\tclear_speculation ();\n-\n-      /* See if SPECULATIVE_OUTER_TYPE is contained in or derived from OUTER_TYPE.\n-\t In this case speculation is valid only if derived types are allowed. \n-\n-\t The test does not really look for derivate, but also accepts the case where\n-\t outer_type is a field of speculative_outer_type.  In this case eiter\n-\t MAYBE_DERIVED_TYPE is false and we have full non-speculative information or\n-\t the loop bellow will correctly update SPECULATIVE_OUTER_TYPE\n-\t and SPECULATIVE_MAYBE_DERIVED_TYPE.  */\n-      else if (speculative_offset < offset\n-\t       || !contains_type_p (speculative_outer_type,\n-\t\t\t\t    speculative_offset - offset,\n-\t\t\t\t    outer_type)\n-\t       || !maybe_derived_type)\n-\tclear_speculation ();\n-    }\n-  else\n-    /* Regularize things little bit and clear all the fields when no useful\n-       speculatin is known.  */\n-    clear_speculation ();\n+  if (otr_type && TYPE_SIZE (otr_type)\n+      && tree_fits_shwi_p (TYPE_SIZE (otr_type)))\n+    otr_type_size = tree_to_uhwi (TYPE_SIZE (otr_type));\n \n-  if (!type)\n+  if (!type || offset < 0)\n     goto no_useful_type_info;\n \n   /* Find the sub-object the constant actually refers to and mark whether it is\n@@ -203,7 +190,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n      for speculative_outer_type.  The second run has SPECULATIVE set.  */\n   while (true)\n     {\n-      HOST_WIDE_INT pos, size;\n+      unsigned HOST_WIDE_INT pos, size;\n       tree fld;\n \n       /* If we do not know size of TYPE, we need to be more conservative\n@@ -218,9 +205,10 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \tsize_unknown = true;\n \n       /* On a match, just return what we found.  */\n-      if ((types_odr_comparable (type, expected_type)\n-\t   && types_same_for_odr (type, expected_type))\n-\t  || (!expected_type\n+      if ((otr_type\n+\t   && types_odr_comparable (type, otr_type)\n+\t   && types_same_for_odr (type, otr_type))\n+\t  || (!otr_type\n \t      && TREE_CODE (type) == RECORD_TYPE\n \t      && TYPE_BINFO (type)\n \t      && polymorphic_type_binfo_p (TYPE_BINFO (type))))\n@@ -242,7 +230,9 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t    {\n \t      /* If type is known to be final, do not worry about derived\n \t\t types.  Testing it here may help us to avoid speculation.  */\n-\t      if (type_known_to_have_no_deriavations_p (outer_type))\n+\t      if (otr_type && TREE_CODE (outer_type) == RECORD_TYPE\n+\t\t  && (!in_lto_p || odr_type_p (outer_type))\n+\t\t  && type_known_to_have_no_deriavations_p (outer_type))\n \t\tmaybe_derived_type = false;\n \n \t      /* Type can not contain itself on an non-zero offset.  In that case\n@@ -254,7 +244,11 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t\tgoto no_useful_type_info;\n \t      /* If we determined type precisely or we have no clue on\n  \t\t speuclation, we are done.  */\n-\t      if (!maybe_derived_type || !speculative_outer_type)\n+\t      if (!maybe_derived_type || !speculative_outer_type\n+\t\t  || !speculation_consistent_p (speculative_outer_type,\n+\t\t\t\t\t        speculative_offset,\n+\t\t\t\t\t        speculative_maybe_derived_type,\n+\t\t\t\t\t\totr_type))\n \t\t{\n \t\t  clear_speculation ();\n \t          return true;\n@@ -279,8 +273,29 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t\tcontinue;\n \n \t      pos = int_bit_position (fld);\n+\t      if (pos > (unsigned HOST_WIDE_INT)cur_offset)\n+\t\tcontinue;\n+\t      if (!DECL_SIZE (fld) || !tree_fits_uhwi_p (DECL_SIZE (fld)))\n+\t\tgoto no_useful_type_info;\n \t      size = tree_to_uhwi (DECL_SIZE (fld));\n-\t      if (pos <= cur_offset && (pos + size) > cur_offset)\n+\n+\t      /* We can always skip types smaller than pointer size:\n+\t\t those can not contain a virtual table pointer.\n+\n+\t\t Disqualifying fields that are too small to fit OTR_TYPE\n+\t\t saves work needed to walk them for no benefit.\n+\t\t Because of the way the bases are packed into a class, the\n+\t\t field's size may be smaller than type size, so it needs\n+\t\t to be done with a care.  */\n+\t\t\n+\t      if (pos <= (unsigned HOST_WIDE_INT)cur_offset\n+\t\t  && (pos + size) >= (unsigned HOST_WIDE_INT)cur_offset\n+\t\t\t\t     + GET_MODE_BITSIZE (Pmode)\n+\t\t  && (!otr_type\n+\t\t      || !TYPE_SIZE (TREE_TYPE (fld))\n+\t\t      || !tree_fits_shwi_p (TYPE_SIZE (TREE_TYPE (fld)))\n+\t\t      || (pos + tree_to_uhwi (TYPE_SIZE (TREE_TYPE (fld))))\n+\t\t\t  >= cur_offset + otr_type_size))\n \t\tbreak;\n \t    }\n \n@@ -307,12 +322,16 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t\t  speculative_maybe_derived_type = false;\n \t\t}\n \t    }\n+\t  else if (!consider_bases)\n+\t    goto no_useful_type_info;\n \t}\n       else if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n \t  tree subtype = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n \n-\t  /* Give up if we don't know array size.  */\n+\t  /* Give up if we don't know array field size.\n+\t     Also give up on non-polymorphic types as they are used\n+\t     as buffers for placement new.  */\n \t  if (!TYPE_SIZE (subtype)\n \t      || !tree_fits_shwi_p (TYPE_SIZE (subtype))\n \t      || tree_to_shwi (TYPE_SIZE (subtype)) <= 0\n@@ -324,9 +343,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t  /* We may see buffer for placement new.  In this case the expected type\n \t     can be bigger than the subtype.  */\n \t  if (TYPE_SIZE (subtype)\n-\t      && (cur_offset\n-\t\t  + (expected_type ? tree_to_uhwi (TYPE_SIZE (expected_type))\n-\t\t     : 0)\n+\t      && (cur_offset + otr_type_size\n \t\t  > tree_to_uhwi (TYPE_SIZE (subtype))))\n \t    goto no_useful_type_info;\n \n@@ -349,12 +366,36 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n       else\n \t{\n no_useful_type_info:\n+\t  if (maybe_derived_type && !speculative\n+\t      && TREE_CODE (outer_type) == RECORD_TYPE\n+\t      && TREE_CODE (otr_type) == RECORD_TYPE\n+\t      && TYPE_BINFO (otr_type)\n+\t      && !offset\n+\t      && get_binfo_at_offset (TYPE_BINFO (otr_type), 0, outer_type))\n+\t    {\n+\t      clear_outer_type (otr_type);\n+\t      if (!speculative_outer_type\n+\t\t  || !speculation_consistent_p (speculative_outer_type,\n+\t\t\t\t\t\tspeculative_offset,\n+\t\t\t\t\t        speculative_maybe_derived_type,\n+\t\t\t\t\t\totr_type))\n+\t\tclear_speculation ();\n+\t      if (speculative_outer_type)\n+\t\t{\n+\t\t  speculative = true;\n+\t\t  type = speculative_outer_type;\n+\t\t  cur_offset = speculative_offset;\n+\t\t}\n+\t      else\n+\t\treturn true;\n+\t    }\n \t  /* We found no way to embedd EXPECTED_TYPE in TYPE.\n \t     We still permit two special cases - placement new and\n \t     the case of variadic types containing themselves.  */\n \t  if (!speculative\n-\t      && (size_unknown || !type\n-\t\t  || possible_placement_new (type, expected_type, cur_offset)))\n+\t      && consider_placement_new\n+\t      && (size_unknown || !type || maybe_derived_type\n+\t\t  || possible_placement_new (type, otr_type, cur_offset)))\n \t    {\n \t      /* In these weird cases we want to accept the context.\n \t\t In non-speculative run we have no useful outer_type info\n@@ -364,7 +405,13 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t\t give useful info.  */\n \t      if (!speculative)\n \t\t{\n-\t\t  clear_outer_type (expected_type);\n+\t\t  clear_outer_type (otr_type);\n+\t\t  if (!speculative_outer_type\n+\t\t      || !speculation_consistent_p (speculative_outer_type,\n+\t\t\t\t\t\t    speculative_offset,\n+\t\t\t\t\t\t    speculative_maybe_derived_type,\n+\t\t\t\t\t\t    otr_type))\n+\t\t    clear_speculation ();\n \t\t  if (speculative_outer_type)\n \t\t    {\n \t\t      speculative = true;\n@@ -383,25 +430,41 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t      clear_speculation ();\n \t      if (speculative)\n \t\treturn true;\n-\t      clear_outer_type (expected_type);\n+\t      clear_outer_type (otr_type);\n \t      invalid = true; \n \t      return false;\n \t    }\n \t}\n     }\n }\n \n-/* Return true if OUTER_TYPE contains OTR_TYPE at OFFSET.  */\n+/* Return true if OUTER_TYPE contains OTR_TYPE at OFFSET.\n+   CONSIDER_PLACEMENT_NEW makes function to accept cases where OTR_TYPE can\n+   be built within OUTER_TYPE by means of placement new.  CONSIDER_BASES makes\n+   function to accept cases where OTR_TYPE appears as base of OUTER_TYPE or as\n+   base of one of fields of OUTER_TYPE.  */\n \n static bool\n contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n-\t\t tree otr_type)\n+\t\t tree otr_type,\n+\t\t bool consider_placement_new,\n+\t\t bool consider_bases)\n {\n   ipa_polymorphic_call_context context;\n+\n+  /* Check that type is within range.  */\n+  if (offset < 0)\n+    return false;\n+  if (TYPE_SIZE (outer_type) && TYPE_SIZE (otr_type)\n+      && TREE_CODE (outer_type) == INTEGER_CST\n+      && TREE_CODE (otr_type) == INTEGER_CST\n+      && wi::ltu_p (wi::to_offset (outer_type), (wi::to_offset (otr_type) + offset)))\n+    return false;\n+\n   context.offset = offset;\n   context.outer_type = TYPE_MAIN_VARIANT (outer_type);\n   context.maybe_derived_type = false;\n-  return context.restrict_to_inner_class (otr_type);\n+  return context.restrict_to_inner_class (otr_type, consider_placement_new, consider_bases);\n }\n \n \n@@ -508,8 +571,8 @@ ipa_polymorphic_call_context::dump (FILE *f) const\n     fprintf (f, \"Call is known to be undefined\\n\");\n   else\n     {\n-      if (!outer_type && !offset && !speculative_outer_type)\n-\tfprintf (f, \"Empty context\\n\");\n+      if (useless_p ())\n+\tfprintf (f, \"nothing known\");\n       if (outer_type || offset)\n \t{\n \t  fprintf (f, \"Outer type:\");\n@@ -523,7 +586,9 @@ ipa_polymorphic_call_context::dump (FILE *f) const\n \t}\n       if (speculative_outer_type)\n \t{\n-\t  fprintf (f, \" speculative outer type:\");\n+\t  if (outer_type || offset)\n+\t    fprintf (f, \" \");\n+\t  fprintf (f, \"Speculative outer type:\");\n \t  print_generic_expr (f, speculative_outer_type, TDF_SLIM);\n \t  if (speculative_maybe_derived_type)\n \t    fprintf (f, \" (or a derived type)\");\n@@ -730,6 +795,13 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t  tree base = get_ref_base_and_extent (TREE_OPERAND (base_pointer, 0),\n \t\t\t\t\t       &offset2, &size, &max_size);\n \n+\t  if (max_size != -1 && max_size == size)\n+\t    combine_speculation_with (TYPE_MAIN_VARIANT\n+\t\t\t\t\t(TREE_TYPE (TREE_TYPE (base_pointer))),\n+\t\t\t\t      offset + offset2,\n+\t\t\t\t      true,\n+\t\t\t\t      NULL /* Do not change outer type.  */);\n+\n \t  /* If this is a varying address, punt.  */\n \t  if ((TREE_CODE (base) == MEM_REF || DECL_P (base))\n \t      && max_size != -1\n@@ -748,8 +820,6 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t\t is known.  */\n \t      else if (DECL_P (base))\n \t\t{\n-\t\t  gcc_assert (!POINTER_TYPE_P (TREE_TYPE (base)));\n-\n \t\t  /* Only type inconsistent programs can have otr_type that is\n \t\t     not part of outer type.  */\n \t\t  if (otr_type\n@@ -801,15 +871,17 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t{\n \t  outer_type\n \t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n-\t  gcc_assert (TREE_CODE (outer_type) == RECORD_TYPE);\n+\t  gcc_assert (TREE_CODE (outer_type) == RECORD_TYPE\n+\t\t      || TREE_CODE (outer_type) == UNION_TYPE);\n \n \t  /* Dynamic casting has possibly upcasted the type\n \t     in the hiearchy.  In this case outer type is less\n \t     informative than inner type and we should forget\n \t     about it.  */\n-\t  if (otr_type\n-\t      && !contains_type_p (outer_type, offset,\n-\t\t\t\t   otr_type))\n+\t  if ((otr_type\n+\t       && !contains_type_p (outer_type, offset,\n+\t\t\t\t    otr_type))\n+\t      || !contains_polymorphic_type_p (outer_type))\n \t    {\n \t      outer_type = NULL;\n \t      if (instance)\n@@ -842,17 +914,24 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t{\n \t  outer_type\n \t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n-\t  gcc_assert (!POINTER_TYPE_P (outer_type));\n \t  /* Only type inconsistent programs can have otr_type that is\n \t     not part of outer type.  */\n-\t  if (!contains_type_p (outer_type, offset,\n-\t\t\t        otr_type))\n+\t  if (otr_type && !contains_type_p (outer_type, offset,\n+\t\t\t\t\t    otr_type))\n \t    { \n \t      invalid = true;\n \t      if (instance)\n \t\t*instance = base_pointer;\n \t      return;\n \t    }\n+\t  /* Non-polymorphic types have no interest for us.  */\n+\t  else if (!otr_type && !contains_polymorphic_type_p (outer_type))\n+\t    {\n+\t      outer_type = NULL;\n+\t      if (instance)\n+\t\t*instance = base_pointer;\n+\t      return;\n+\t    }\n \t  maybe_derived_type = false;\n \t  maybe_in_construction = false;\n \t  if (instance)\n@@ -878,17 +957,10 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n     base_type = TREE_TYPE (gimple_assign_rhs1\n \t\t\t    (SSA_NAME_DEF_STMT (base_pointer)));\n  \n-  if (POINTER_TYPE_P (base_type)\n-      && (otr_type\n-\t  || !contains_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (base_type)),\n-\t\t\t       offset,\n-\t\t\t       otr_type)))\n-    {\n-      speculative_outer_type = TYPE_MAIN_VARIANT\n-\t\t\t\t\t  (TREE_TYPE (base_type));\n-      speculative_offset = offset;\n-      speculative_maybe_derived_type = true;\n-    }\n+  if (POINTER_TYPE_P (base_type))\n+    combine_speculation_with (TYPE_MAIN_VARIANT (TREE_TYPE (base_type)),\n+\t\t\t      offset,\n+\t\t\t      true, NULL /* Do not change type here */);\n   /* TODO: There are multiple ways to derive a type.  For instance\n      if BASE_POINTER is passed to an constructor call prior our refernece.\n      We do not make this type of flow sensitive analysis yet.  */\n@@ -1080,7 +1152,7 @@ extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci,\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"    Construction vtable used\\n\");\n-      /* FIXME: We should suport construction contextes.  */\n+      /* FIXME: We should suport construction contexts.  */\n       return NULL;\n     }\n  \n@@ -1516,3 +1588,390 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n   return true;\n }\n \n+/* See if speculation given by SPEC_OUTER_TYPE, SPEC_OFFSET and SPEC_MAYBE_DERIVED_TYPE\n+   seems consistent (and useful) with what we already have in the non-speculative context.  */\n+\n+bool\n+ipa_polymorphic_call_context::speculation_consistent_p (tree spec_outer_type,\n+\t\t\t\t\t\t\tHOST_WIDE_INT spec_offset,\n+\t\t\t\t\t\t\tbool spec_maybe_derived_type,\n+\t\t\t\t\t\t\ttree otr_type)\n+{\n+  if (!flag_devirtualize_speculatively)\n+    return false;\n+  /* If we know nothing, speculation is always good.  */\n+  if (!outer_type)\n+    return true;\n+\n+  /* Speculation is only useful to avoid derived types.\n+     This is not 100% true for placement new, where the outer context may\n+     turn out to be useless, but ignore these for now.  */\n+  if (!maybe_derived_type)\n+    return false;\n+\n+  /* If types agrees, speculation is consistent, but it makes sense only\n+     when it says something new.  */\n+  if (types_must_be_same_for_odr (spec_outer_type, outer_type))\n+    return maybe_derived_type && !spec_maybe_derived_type;\n+\n+  /* Non-polymorphic types are useless for deriving likely polymorphic\n+     call targets.  */\n+  if (!contains_polymorphic_type_p (spec_outer_type))\n+    return false;\n+\n+  /* If speculation does not contain the type in question, ignore it.  */\n+  if (otr_type\n+      && !contains_type_p (spec_outer_type, spec_offset, otr_type, false, true))\n+    return false;\n+\n+  /* If outer type already contains speculation as a filed,\n+     it is useless.  We already know from OUTER_TYPE \n+     SPEC_TYPE and that it is not in the construction.  */\n+  if (contains_type_p (outer_type, offset - spec_offset,\n+\t\t       spec_outer_type, false, false))\n+    return false;\n+\n+  /* If speculative outer type is not more specified than outer\n+     type, just give up. \n+     We can only decide this safely if we can compare types with OUTER_TYPE.\n+   */\n+  if ((!in_lto_p || odr_type_p (outer_type))\n+      && !contains_type_p (spec_outer_type,\n+\t\t\t   spec_offset - offset,\n+\t\t\t   outer_type, false))\n+    return false;\n+  return true;\n+}\n+\n+/* Improve THIS with speculation described by NEW_OUTER_TYPE, NEW_OFFSET,\n+   NEW_MAYBE_DERIVED_TYPE \n+   If OTR_TYPE is set, assume the context is used with OTR_TYPE.  */\n+\n+bool\n+ipa_polymorphic_call_context::combine_speculation_with\n+   (tree new_outer_type, HOST_WIDE_INT new_offset, bool new_maybe_derived_type,\n+    tree otr_type)\n+{\n+  if (!new_outer_type)\n+    return false;\n+\n+  /* restrict_to_inner_class may eliminate wrong speculation making our job\n+     easeier.  */\n+  if (otr_type)\n+    restrict_to_inner_class (otr_type);\n+\n+  if (!speculation_consistent_p (new_outer_type, new_offset,\n+\t\t\t\t new_maybe_derived_type, otr_type))\n+    return false;\n+\n+  /* New speculation is a win in case we have no speculation or new\n+     speculation does not consider derivations.  */\n+  if (!speculative_outer_type\n+      || (speculative_maybe_derived_type\n+\t  && !new_maybe_derived_type))\n+    {\n+      speculative_outer_type = new_outer_type;\n+      speculative_offset = new_offset;\n+      speculative_maybe_derived_type = new_maybe_derived_type;\n+      return true;\n+    }\n+  else if (types_must_be_same_for_odr (speculative_outer_type,\n+\t\t\t\t       new_outer_type))\n+    {\n+      if (speculative_offset != new_offset)\n+\t{\n+\t  /* OK we have two contexts that seems valid but they disagree,\n+\t     just give up.\n+\n+\t     This is not a lattice operation, so we may want to drop it later.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Speculative outer types match, \"\n+\t\t     \"offset mismatch -> invalid speculation\\n\");\n+\t  clear_speculation ();\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  if (speculative_maybe_derived_type && !new_maybe_derived_type)\n+\t    {\n+\t      speculative_maybe_derived_type = false;\n+\t      return true;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+    }\n+  /* Choose type that contains the other.  This one either contains the outer\n+     as a field (thus giving exactly one target) or is deeper in the type\n+     hiearchy.  */\n+  else if (speculative_outer_type\n+\t   && speculative_maybe_derived_type\n+\t   && (new_offset > speculative_offset\n+\t       || (new_offset == speculative_offset\n+\t\t   && contains_type_p (new_outer_type,\n+\t\t\t\t       0, speculative_outer_type, false))))\n+    {\n+      tree old_outer_type = speculative_outer_type;\n+      HOST_WIDE_INT old_offset = speculative_offset;\n+      bool old_maybe_derived_type = speculative_maybe_derived_type;\n+\n+      speculative_outer_type = new_outer_type;\n+      speculative_offset = new_offset;\n+      speculative_maybe_derived_type = new_maybe_derived_type;\n+\n+      if (otr_type)\n+\trestrict_to_inner_class (otr_type);\n+\n+      /* If the speculation turned out to make no sense, revert to sensible\n+\t one.  */\n+      if (!speculative_outer_type)\n+\t{\n+\t  speculative_outer_type = old_outer_type;\n+\t  speculative_offset = old_offset;\n+\t  speculative_maybe_derived_type = old_maybe_derived_type;\n+\t  return false;\n+\t}\n+      return (old_offset != speculative_offset\n+\t      || old_maybe_derived_type != speculative_maybe_derived_type\n+\t      || types_must_be_same_for_odr (speculative_outer_type,\n+\t\t\t\t\t     new_outer_type));\n+    }\n+  return false;\n+}\n+\n+/* Assume that both THIS and a given context is valid and strenghten THIS\n+   if possible.  Return true if any strenghtening was made.\n+   If actual type the context is being used in is known, OTR_TYPE should be\n+   set accordingly. This improves quality of combined result.  */\n+\n+bool\n+ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n+\t\t\t\t\t    tree otr_type)\n+{\n+  bool updated = false;\n+\n+  if (ctx.useless_p () || invalid)\n+    return false;\n+\n+  /* Restricting context to inner type makes merging easier, however do not\n+     do that unless we know how the context is used (OTR_TYPE is non-NULL)  */\n+  if (otr_type && !invalid && !ctx.invalid)\n+    {\n+      restrict_to_inner_class (otr_type);\n+      ctx.restrict_to_inner_class (otr_type);\n+      if(invalid)\n+        return false;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Polymorphic call context combine:\");\n+      dump (dump_file);\n+      fprintf (dump_file, \"With context:                    \");\n+      ctx.dump (dump_file);\n+      if (otr_type)\n+\t{\n+          fprintf (dump_file, \"To be used with type:            \");\n+\t  print_generic_expr (dump_file, otr_type, TDF_SLIM);\n+          fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+\n+  /* If call is known to be invalid, we are done.  */\n+  if (ctx.invalid)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"-> Invalid context\\n\");\n+      goto invalidate;\n+    }\n+\n+  if (!ctx.outer_type)\n+    ;\n+  else if (!outer_type)\n+    {\n+      outer_type = ctx.outer_type;\n+      offset = ctx.offset;\n+      maybe_in_construction = ctx.maybe_in_construction;\n+      maybe_derived_type = ctx.maybe_derived_type;\n+      updated = true;\n+    }\n+  /* If types are known to be same, merging is quite easy.  */\n+  else if (types_must_be_same_for_odr (outer_type, ctx.outer_type))\n+    {\n+      if (offset != ctx.offset\n+\t  && TYPE_SIZE (outer_type)\n+\t  && TREE_CODE (TYPE_SIZE (outer_type)) == INTEGER_CST)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Outer types match, offset mismatch -> invalid\\n\");\n+\t  clear_speculation ();\n+\t  clear_outer_type ();\n+\t  invalid = true;\n+\t  return true;\n+\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"Outer types match, merging flags\\n\");\n+      if (maybe_in_construction && !ctx.maybe_in_construction)\n+\t{\n+\t  updated = true;\n+\t  maybe_in_construction = false;\n+\t}\n+      if (maybe_derived_type && !ctx.maybe_derived_type)\n+\t{\n+\t  updated = true;\n+\t  maybe_derived_type = false;\n+\t}\n+    }\n+  /* If we know the type precisely, there is not much to improve.  */\n+  else if (!maybe_derived_type && !maybe_in_construction\n+\t   && !ctx.maybe_derived_type && !ctx.maybe_in_construction)\n+    {\n+      /* It may be easy to check if second context permits the first\n+\t and set INVALID otherwise.  This is not easy to do in general;\n+\t contains_type_p may return false negatives for non-comparable\n+\t types.  \n+\n+\t If OTR_TYPE is known, we however can expect that\n+\t restrict_to_inner_class should have discovered the same base\n+\t type.  */\n+      if (otr_type && !ctx.maybe_in_construction && !ctx.maybe_derived_type)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Contextes disagree -> invalid\\n\");\n+\t  goto invalidate;\n+\t}\n+    }\n+  /* See if one type contains the other as a field (not base).\n+     In this case we want to choose the wider type, because it contains\n+     more information.  */\n+  else if (contains_type_p (ctx.outer_type, ctx.offset - offset,\n+\t\t\t    outer_type, false, false))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Second type contain the first as a field\\n\");\n+\n+      if (maybe_derived_type)\n+\t{\n+\t  outer_type = ctx.outer_type;\n+\t  maybe_derived_type = ctx.maybe_derived_type;\n+\t  offset = ctx.offset;\n+\t  updated = true;\n+\t}\n+\n+      /* If we do not know how the context is being used, we can\n+\t not clear MAYBE_IN_CONSTRUCTION because it may be offseted\n+\t to other component of OUTER_TYPE later and we know nothing\n+\t about it.  */\n+      if (otr_type && maybe_in_construction\n+\t  && !ctx.maybe_in_construction)\n+\t{\n+          maybe_in_construction = false;\n+\t  updated = true;\n+\t}\n+    }\n+  else if (contains_type_p (outer_type, offset - ctx.offset,\n+\t\t\t    ctx.outer_type, false, false))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"First type contain the second as a field\\n\");\n+\n+      if (otr_type && maybe_in_construction\n+\t  && !ctx.maybe_in_construction)\n+\t{\n+          maybe_in_construction = false;\n+\t  updated = true;\n+\t}\n+    }\n+  /* See if OUTER_TYPE is base of CTX.OUTER_TYPE.  */\n+  else if (contains_type_p (ctx.outer_type,\n+\t\t\t    ctx.offset - offset, outer_type, false, true))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"First type is base of second\\n\");\n+      if (!maybe_derived_type)\n+\t{\n+\t  if (!ctx.maybe_in_construction\n+\t      && types_odr_comparable (outer_type, ctx.outer_type))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Second context does not permit base -> invalid\\n\");\n+\t      goto invalidate;\n+\t    }\n+\t}\n+      /* Pick variant deeper in the hiearchy.  */\n+      else\n+\t{\n+\t  outer_type = ctx.outer_type;\n+\t  maybe_in_construction = ctx.maybe_in_construction;\n+\t  maybe_derived_type = ctx.maybe_derived_type;\n+\t  offset = ctx.offset;\n+          updated = true;\n+\t}\n+    }\n+  /* See if CTX.OUTER_TYPE is base of OUTER_TYPE.  */\n+  else if (contains_type_p (outer_type,\n+\t\t\t    offset - ctx.offset, ctx.outer_type, false, true))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Second type is base of first\\n\");\n+      if (!ctx.maybe_derived_type)\n+\t{\n+\t  if (!maybe_in_construction\n+\t      && types_odr_comparable (outer_type, ctx.outer_type))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"First context does not permit base -> invalid\\n\");\n+\t      goto invalidate;\n+\t    }\n+\t}\n+    }\n+  /* TODO handle merging using hiearchy. */\n+  else if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Giving up on merge\\n\");\n+\n+  updated |= combine_speculation_with (ctx.speculative_outer_type,\n+\t\t\t\t       ctx.speculative_offset,\n+\t\t\t\t       ctx.maybe_in_construction,\n+\t\t\t\t       otr_type);\n+\n+  if (updated && dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Updated as:                      \");\n+      dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  return updated;\n+\n+invalidate:\n+  invalid = true;\n+  clear_speculation ();\n+  clear_outer_type ();\n+  return true;\n+}\n+\n+/* Take non-speculative info, merge it with speculative and clear speculation.\n+   Used when we no longer manage to keep track of actual outer type, but we\n+   think it is still there.  */\n+\n+void\n+ipa_polymorphic_call_context::make_speculative (tree otr_type)\n+{\n+  tree spec_outer_type = outer_type;\n+  HOST_WIDE_INT spec_offset = offset;\n+  bool spec_maybe_derived_type = maybe_derived_type;\n+\n+  if (invalid)\n+    {\n+      invalid = false;\n+      clear_outer_type ();\n+      clear_speculation ();\n+      return;\n+    }\n+  if (!outer_type)\n+    return;\n+  clear_outer_type ();\n+  combine_speculation_with (spec_outer_type, spec_offset,\n+\t\t\t    spec_maybe_derived_type,\n+\t\t\t    otr_type);\n+}"}]}