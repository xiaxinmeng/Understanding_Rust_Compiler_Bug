{"sha": "7a866e7e316df13b04a84a8d5426b43d016573ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E4NjZlN2UzMTZkZjEzYjA0YTg0YThkNTQyNmI0M2QwMTY1NzNlYQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-10-12T17:37:56Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-10-12T17:37:56Z"}, "message": "PR c/82301 - Updated test case g++.dg/ext/attr-ifunc-1.C (and others) in r253041 segfault on powerpc64\n\nPR c/82301 - Updated test case g++.dg/ext/attr-ifunc-1.C (and others) in r253041 segfault on powerpc64\nPR c/82435 - new __attribute__((alias)) warning gets in the way\n\ngcc/ChangeLog:\n\n\tPR other/82301\n\tPR c/82435\n\t* cgraphunit.c (maybe_diag_incompatible_alias): New function.\n\t(handle_alias_pairs): Call it.\n\t* common.opt (-Wattribute-alias): New option.\n\t* doc/extend.texi (ifunc attribute): Discuss C++ specifics.\n\t* doc/invoke.texi (-Wattribute-alias): Document.\n\ngcc/testsuite/ChangeLog:\n\n\tPR other/82301\n\tPR c/82435\n\t* g++.dg/ext/attr-ifunc-1.C: Update.\n\t* g++.dg/ext/attr-ifunc-2.C: Same.\n\t* g++.dg/ext/attr-ifunc-3.C: Same.\n\t* g++.dg/ext/attr-ifunc-4.C: Same.\n\t* g++.dg/ext/attr-ifunc-5.C: Same.\n\t* g++.dg/ext/attr-ifunc-6.C: New test.\n\t* g++.old-deja/g++.abi/vtable2.C: Update.\n\t* gcc.dg/attr-ifunc-6.c: New test.\n\t* gcc.dg/attr-ifunc-7.c: New test.\n\t* gcc.dg/pr81854.c: Update.\n\t* lib/target-supports.exp: Update.\n\nFrom-SVN: r253688", "tree": {"sha": "0aa083148a64517b691539878d5b1cfcead20175", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aa083148a64517b691539878d5b1cfcead20175"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a866e7e316df13b04a84a8d5426b43d016573ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a866e7e316df13b04a84a8d5426b43d016573ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a866e7e316df13b04a84a8d5426b43d016573ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a866e7e316df13b04a84a8d5426b43d016573ea/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e95c91292876830c8e36b0a55f0c03d1247aaccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95c91292876830c8e36b0a55f0c03d1247aaccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95c91292876830c8e36b0a55f0c03d1247aaccb"}], "stats": {"total": 394, "additions": 282, "deletions": 112}, "files": [{"sha": "dc17b705025daeceff773667b17caeba50f8439c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -1,3 +1,13 @@\n+2017-10-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR other/82301\n+\tPR c/82435\n+\t* cgraphunit.c (maybe_diag_incompatible_alias): New function.\n+\t(handle_alias_pairs): Call it.\n+\t* common.opt (-Wattribute-alias): New option.\n+\t* doc/extend.texi (ifunc attribute): Discuss C++ specifics.\n+\t* doc/invoke.texi (-Wattribute-alias): Document.\n+\n 2017-10-12  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tRevert"}, {"sha": "9385dc825ab286276a627955d004b7aa462dda12", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 89, "deletions": 60, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -1296,6 +1296,93 @@ analyze_functions (bool first_time)\n   input_location = saved_loc;\n }\n \n+/* Check declaration of the type of ALIAS for compatibility with its TARGET\n+   (which may be an ifunc resolver) and issue a diagnostic when they are\n+   not compatible according to language rules (plus a C++ extension for\n+   non-static member functions).  */\n+\n+static void\n+maybe_diag_incompatible_alias (tree alias, tree target)\n+{\n+  tree altype = TREE_TYPE (alias);\n+  tree targtype = TREE_TYPE (target);\n+\n+  bool ifunc = lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (alias));\n+  tree funcptr = altype;\n+\n+  if (ifunc)\n+    {\n+      /* Handle attribute ifunc first.  */\n+      if (TREE_CODE (altype) == METHOD_TYPE)\n+\t{\n+\t  /* Set FUNCPTR to the type of the alias target.  If the type\n+\t     is a non-static member function of class C, construct a type\n+\t     of an ordinary function taking C* as the first argument,\n+\t     followed by the member function argument list, and use it\n+\t     instead to check for incompatibility.  This conversion is\n+\t     not defined by the language but an extension provided by\n+\t     G++.  */\n+\n+\t  tree rettype = TREE_TYPE (altype);\n+\t  tree args = TYPE_ARG_TYPES (altype);\n+\t  altype = build_function_type (rettype, args);\n+\t  funcptr = altype;\n+\t}\n+\n+      targtype = TREE_TYPE (targtype);\n+\n+      if (POINTER_TYPE_P (targtype))\n+\t{\n+\t  targtype = TREE_TYPE (targtype);\n+\n+\t  /* Only issue Wattribute-alias for conversions to void* with\n+\t     -Wextra.  */\n+\t  if (VOID_TYPE_P (targtype) && !extra_warnings)\n+\t    return;\n+\n+\t  /* Proceed to handle incompatible ifunc resolvers below.  */\n+\t}\n+      else\n+\t{\n+\t  funcptr = build_pointer_type (funcptr);\n+\n+\t  error_at (DECL_SOURCE_LOCATION (target),\n+\t\t    \"%<ifunc%> resolver for %qD must return %qT\",\n+\t\t alias, funcptr);\n+\t  inform (DECL_SOURCE_LOCATION (alias),\n+\t\t  \"resolver indirect function declared here\");\n+\t  return;\n+\t}\n+    }\n+\n+  if ((!FUNC_OR_METHOD_TYPE_P (targtype)\n+       || (prototype_p (altype)\n+\t   && prototype_p (targtype)\n+\t   && !types_compatible_p (altype, targtype))))\n+    {\n+      /* Warn for incompatibilities.  Avoid warning for functions\n+\t without a prototype to make it possible to declare aliases\n+\t without knowing the exact type, as libstdc++ does.  */\n+      if (ifunc)\n+\t{\n+\t  funcptr = build_pointer_type (funcptr);\n+\n+\t  if (warning_at (DECL_SOURCE_LOCATION (target),\n+\t\t\t  OPT_Wattribute_alias,\n+\t\t\t  \"%<ifunc%> resolver for %qD should return %qT\",\n+\t\t\t  alias, funcptr))\n+\t    inform (DECL_SOURCE_LOCATION (alias),\n+\t\t    \"resolver indirect function declared here\");\n+\t}\n+      else if (warning_at (DECL_SOURCE_LOCATION (alias),\n+\t\t\t   OPT_Wattribute_alias,\n+\t\t\t   \"%qD alias between functions of incompatible \"\n+\t\t\t   \"types %qT and %qT\", alias, altype, targtype))\n+\tinform (DECL_SOURCE_LOCATION (target),\n+\t\t\"aliased declaration here\");\n+    }\n+}\n+\n /* Translate the ugly representation of aliases as alias pairs into nice\n    representation in callgraph.  We don't handle all cases yet,\n    unfortunately.  */\n@@ -1305,7 +1392,7 @@ handle_alias_pairs (void)\n {\n   alias_pair *p;\n   unsigned i;\n-  \n+\n   for (i = 0; alias_pairs && alias_pairs->iterate (i, &p);)\n     {\n       symtab_node *target_node = symtab_node::get_for_asmname (p->target);\n@@ -1352,65 +1439,7 @@ handle_alias_pairs (void)\n       if (TREE_CODE (p->decl) == FUNCTION_DECL\n           && target_node && is_a <cgraph_node *> (target_node))\n \t{\n-\t  tree t1 = TREE_TYPE (p->decl);\n-\t  tree t2 = TREE_TYPE (target_node->decl);\n-\n-\t  if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (p->decl)))\n-\t    {\n-\t      t2 = TREE_TYPE (t2);\n-\t      if (POINTER_TYPE_P (t2))\n-\t\t{\n-\t\t  t2 = TREE_TYPE (t2);\n-\t\t  if (!FUNC_OR_METHOD_TYPE_P (t2))\n-\t\t    {\n-\t\t      if (warning_at (DECL_SOURCE_LOCATION (p->decl),\n-\t\t\t\t      OPT_Wattributes,\n-\t\t\t\t      \"%q+D %<ifunc%> resolver should return \"\n-\t\t\t\t      \"a function pointer\",\n-\t\t\t\t      p->decl))\n-\t\t\tinform (DECL_SOURCE_LOCATION (target_node->decl),\n-\t\t\t\t\"resolver declaration here\");\n-\n-\t\t      t2 = NULL_TREE;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Deal with static member function pointers.  */\n-\t\t  if (TREE_CODE (t2) == RECORD_TYPE\n-\t\t      && TYPE_FIELDS (t2)\n-\t\t      && TREE_CODE (TREE_TYPE (TYPE_FIELDS (t2))) == POINTER_TYPE\n-\t\t      && (TREE_CODE (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (t2))))\n-\t\t\t  == METHOD_TYPE))\n-\t\t    t2 = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (t2)));\n-\t\t  else\n-\t\t    {\n-\t\t      error (\"%q+D %<ifunc%> resolver must return a function \"\n-\t\t\t     \"pointer\",\n-\t\t\t     p->decl);\n-\t\t      inform (DECL_SOURCE_LOCATION (target_node->decl),\n-\t\t\t      \"resolver declaration here\");\n-\n-\t\t      t2 = NULL_TREE;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  if (t2\n-\t      && (!FUNC_OR_METHOD_TYPE_P (t2)\n-\t\t  || (prototype_p (t1)\n-\t\t      && prototype_p (t2)\n-\t\t      && !types_compatible_p (t1, t2))))\n-\t    {\n-\t      /* Warn for incompatibilities.  Avoid warning for functions\n-\t\t without a prototype to make it possible to declare aliases\n-\t\t without knowing the exact type, as libstdc++ does.  */\n-\t      if (warning_at (DECL_SOURCE_LOCATION (p->decl), OPT_Wattributes,\n-\t\t\t      \"%q+D alias between functions of incompatible \"\n-\t\t\t      \"types %qT and %qT\", p->decl, t1, t2))\n-\t\tinform (DECL_SOURCE_LOCATION (target_node->decl),\n-\t\t\t\"aliased declaration here\");\n-\t    }\n+\t  maybe_diag_incompatible_alias (p->decl, target_node->decl);\n \n \t  cgraph_node *src_node = cgraph_node::get (p->decl);\n \t  if (src_node && src_node->definition)"}, {"sha": "c95da64017465a9ca09f393d3c6e0c8ab085df59", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -562,6 +562,10 @@ Wattributes\n Common Var(warn_attributes) Init(1) Warning\n Warn about inappropriate attribute usage.\n \n+Wattribute-alias\n+Common Var(warn_attributes) Init(1) Warning\n+Warn about type safety and similar errors in attribute alias and related.\n+\n Wcast-align\n Common Var(warn_cast_align) Warning\n Warn about pointer casts which increase alignment."}, {"sha": "a196b596fa9337189b019f83d2bb9a24bfafb4ab", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -2801,7 +2801,7 @@ void *my_memcpy (void *dst, const void *src, size_t len)\n \n static void * (*resolve_memcpy (void))(void *, const void *, size_t)\n @{\n-  return my_memcpy; // we'll just always select this routine\n+  return my_memcpy; // we will just always select this routine\n @}\n @end smallexample\n \n@@ -2814,15 +2814,56 @@ extern void *memcpy (void *, const void *, size_t);\n @end smallexample\n \n @noindent\n-allowing the user to call this as a regular function, unaware of the\n-implementation.  Finally, the indirect function needs to be defined in\n-the same translation unit as the resolver function:\n+allowing the user to call @code{memcpy} as a regular function, unaware of\n+the actual implementation.  Finally, the indirect function needs to be\n+defined in the same translation unit as the resolver function:\n \n @smallexample\n void *memcpy (void *, const void *, size_t)\n      __attribute__ ((ifunc (\"resolve_memcpy\")));\n @end smallexample\n \n+In C++, the @code{ifunc} attribute takes a string that is the mangled name\n+of the resolver function.  A C++ resolver for a non-static member function\n+of class @code{C} should be declared to return a pointer to a non-member\n+function taking pointer to @code{C} as the first argument, followed by\n+the same arguments as of the implementation function.  G++ checks\n+the signatures of the two functions and issues\n+a @option{-Wattribute-alias} warning for mismatches.  To suppress a warning\n+for the necessary cast from a pointer to the implementation member function\n+to the type of the corresponding non-member function use\n+the @option{-Wno-pmf-conversions} option.  For example:\n+\n+@smallexample\n+class S\n+@{\n+private:\n+  int debug_impl (int);\n+  int optimized_impl (int);\n+\n+  typedef int Func (S*, int);\n+\n+  static Func* resolver ();\n+public:\n+\n+  int interface (int);\n+@};\n+\n+int S::debug_impl (int) @{ /* @r{@dots{}} */ @}\n+int S::optimized_impl (int) @{ /* @r{@dots{}} */ @}\n+\n+S::Func* S::resolver ()\n+@{\n+  int (S::*pimpl) (int)\n+    = getenv (\"DEBUG\") ? &S::debug_impl : &S::optimized_impl;\n+\n+  // Cast triggers -Wno-pmf-conversions.\n+  return reinterpret_cast<Func*>(pimpl);\n+@}\n+\n+int S::interface (int) __attribute__ ((ifunc (\"_ZN1S8resolverEv\")));\n+@end smallexample\n+\n Indirect functions cannot be weak.  Binutils version 2.20.1 or higher\n and GNU C Library version 2.11.1 are required to use this feature.\n "}, {"sha": "4e7dfb33c310ef30ebf904bce8f66ef994b41da2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -5402,6 +5402,11 @@ pointers. This warning level may give a larger number of\n false positives and is deactivated by default.\n @end table\n \n+@item -Wattribute-alias\n+Warn about declarations using the @code{alias} and similar attributes whose\n+target is incompatible with the type of the alias.  @xref{Function Attributes,\n+,Declaring Attributes of Functions}.\n+\n @item -Wbool-compare\n @opindex Wno-bool-compare\n @opindex Wbool-compare"}, {"sha": "a910f8aeac166e3bb0459cde32ba7938b06f0d2d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -1,3 +1,19 @@\n+2017-10-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR other/82301\n+\tPR c/82435\n+\t* g++.dg/ext/attr-ifunc-1.C: Update.\n+\t* g++.dg/ext/attr-ifunc-2.C: Same.\n+\t* g++.dg/ext/attr-ifunc-3.C: Same.\n+\t* g++.dg/ext/attr-ifunc-4.C: Same.\n+\t* g++.dg/ext/attr-ifunc-5.C: Same.\n+\t* g++.dg/ext/attr-ifunc-6.C: New test.\n+\t* g++.old-deja/g++.abi/vtable2.C: Update.\n+\t* gcc.dg/attr-ifunc-6.c: New test.\n+\t* gcc.dg/attr-ifunc-7.c: New test.\n+\t* gcc.dg/pr81854.c: Update.\n+\t* lib/target-supports.exp: Update.\n+\n 2017-10-12  David Malcolm  <dmalcolm@redhat.com>\n \n \t* g++.dg/parse/pragma2.C: Update to reflect reinstatement of the"}, {"sha": "4a29e8bb4d69aef2aff03266b16c7d00dd2f1c19", "filename": "gcc/testsuite/g++.dg/ext/attr-ifunc-1.C", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-1.C?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -4,26 +4,33 @@\n \n struct Klass\n {\n+  int a[4];\n+\n   int implementation ();\n   int magic ();\n \n-  typedef int (Klass::*MemFuncPtr)();\n+  /* An ifunc resolver must return a pointer to an ordinary (non-member)\n+     function.  To make it possible to use ifunc with member functions,\n+     the resolver must convert a member function pointer to an ordinary\n+     function pointer (slicing off the high word).  */\n+  typedef int Func (Klass*);\n \n-  static MemFuncPtr resolver ();\n+  static Func* resolver ();\n };\n \n-Klass::MemFuncPtr p = &Klass::implementation;\n-\n-int Klass::implementation (void)\n+int Klass::implementation ()\n {\n   __builtin_printf (\"'ere I am JH\\n\");\n-  return 1234;\n+  return a[0] + a[1] + a[2] + a[3];\n }\n \n-\n-Klass::MemFuncPtr Klass::resolver (void)\n+Klass::Func* Klass::resolver (void)\n {\n-  return &Klass::implementation;\n+  /* GCC guarantees this conversion to be safe and the resulting pointer\n+     usable to call the member function using ordinary (i.e., non-member)\n+     function call syntax.  */\n+\n+  return reinterpret_cast<Func*>(&Klass::implementation);\n }\n \n int f (void) __attribute__ ((ifunc (\"foo\")));\n@@ -32,11 +39,16 @@ typedef int (F)(void);\n extern \"C\" F* foo () { return 0; }\n \n \n-int Klass::magic (void) __attribute__ ((ifunc (\"_ZN5Klass8resolverEv\")));\n+int Klass::magic () __attribute__ ((ifunc (\"_ZN5Klass8resolverEv\")));\n \n int main ()\n {\n   Klass obj;\n \n-  return !(obj.magic () == 1234);\n+  obj.a[0] = 1;\n+  obj.a[1] = 2;\n+  obj.a[2] = 3;\n+  obj.a[3] = 4;\n+\n+  return !(obj.magic () == 10);\n }"}, {"sha": "e5be3d29aba096f1cb7414966a91db7833330899", "filename": "gcc/testsuite/g++.dg/ext/attr-ifunc-2.C", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-2.C?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -9,9 +9,9 @@ struct Klass\n   int implementation ();\n   int magic ();\n \n-  typedef int (Klass::*MemFuncPtr)();\n+  typedef int Func (Klass*);\n \n-  static MemFuncPtr resolver ();\n+  static Func* resolver ();\n };\n \n int Klass::implementation (void)\n@@ -20,9 +20,13 @@ int Klass::implementation (void)\n   return 0;\n }\n \n-Klass::MemFuncPtr Klass::resolver (void)\n+Klass::Func* Klass::resolver (void)\n {\n-  return &Klass::implementation;\n+  /* GCC guarantees this conversion to be safe and the resulting pointer\n+     usable to call the member function using ordinary (i.e., non-member)\n+     function call syntax.  */\n+\n+  return reinterpret_cast<Func*>(&Klass::implementation);\n }\n \n int Klass::magic (void) __attribute__ ((ifunc (\"_ZN5Klass8resolverEv\")));"}, {"sha": "6d494244331278a257f75514cfec2097d3538f45", "filename": "gcc/testsuite/g++.dg/ext/attr-ifunc-3.C", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-3.C?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -6,23 +6,29 @@\n \n struct Klass\n {\n+  int a[4];\n+\n   int implementation ();\n   int magic ();\n \n-  typedef int (Klass::*MemFuncPtr)();\n+  typedef int Func (Klass*);\n \n-  static MemFuncPtr resolver ();\n+  static Func* resolver ();\n };\n \n int Klass::implementation (void)\n {\n   printf (\"'ere I am JH\\n\");\n-  return 0;\n+  return a[0] + a[1] + a[2] + a[3];\n }\n \n-Klass::MemFuncPtr Klass::resolver (void)\n+Klass::Func* Klass::resolver ()\n {\n-  return &Klass::implementation;\n+  /* GCC guarantees this conversion to be safe and the resulting pointer\n+     usable to call the member function using ordinary (i.e., non-member)\n+     function call syntax.  */\n+\n+  return reinterpret_cast<Func*>(&Klass::implementation);\n }\n \n int Klass::magic (void) __attribute__ ((ifunc (\"_ZN5Klass8resolverEv\")));\n@@ -36,5 +42,10 @@ int main ()\n {\n   Klass obj;\n \n-  return Foo (obj, &Klass::magic) != 0;\n+  obj.a[0] = 1;\n+  obj.a[1] = 2;\n+  obj.a[2] = 3;\n+  obj.a[3] = 4;\n+\n+  return Foo (obj, &Klass::magic) != 10;\n }"}, {"sha": "f71dc3b9ba9f44d6e5f08c1d6d193a79f9af6a90", "filename": "gcc/testsuite/g++.dg/ext/attr-ifunc-4.C", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-4.C?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -14,9 +14,9 @@ struct Klassier : Klass\n   int implementation ();\n   int magic ();\n \n-  typedef int (Klassier::*MemFuncPtr)();\n+  typedef int Func (Klass*);\n \n-  static MemFuncPtr resolver ();\n+  static Func* resolver ();\n };\n \n int Klassier::implementation (void)\n@@ -25,9 +25,13 @@ int Klassier::implementation (void)\n   return 0;\n }\n \n-Klassier::MemFuncPtr Klassier::resolver (void)\n+Klassier::Func* Klassier::resolver ()\n {\n-  return &Klassier::implementation;\n+  /* GCC guarantees this conversion to be safe and the resulting pointer\n+     usable to call the member function using ordinary (i.e., non-member)\n+     function call syntax.  */\n+\n+  return reinterpret_cast<Func*>(&Klassier::implementation);\n }\n \n int Klassier::magic (void) __attribute__ ((ifunc (\"_ZN8Klassier8resolverEv\")));"}, {"sha": "fd8bcff79b79bdff46d1c6f78f5fbf5a46399e04", "filename": "gcc/testsuite/g++.dg/ext/attr-ifunc-5.C", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-ifunc-5.C?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -1,29 +1,64 @@\n // PR c/81854 - weak alias of an incompatible symbol accepted\n // { dg-do compile }\n // { dg-require-ifunc \"\" } */\n+// { dg-options \"-Wextra -Wno-pmf-conversions\" }\n \n struct Klass\n {\n   int implementation ();\n-  const char* magic ();\n+  int good_magic ();\n+  int iffy_magic ();\n+  const char* bad_magic ();\n \n+  typedef int (Func)(Klass*);\n   typedef int (Klass::*MemFuncPtr)();\n \n-  static MemFuncPtr resolver ();\n+  static Func* good_resolver ();\n+  static void* iffy_resolver ();\n+  static MemFuncPtr bad_resolver ();\n };\n \n int Klass::implementation (void)\n {\n   return 0;\n }\n \n-const char* __attribute__ ((ifunc (\"_ZN5Klass8resolverEv\")))\n-  Klass::magic ();   // { dg-warning \"alias between functions of incompatible types\" }\n+// Verify no warning for the expected/compatible declaration.\n \n+int __attribute__ ((ifunc (\"_ZN5Klass13good_resolverEv\")))\n+Klass::good_magic ();\n+\n+Klass::Func*\n+Klass::good_resolver (void)\n+{\n+  MemFuncPtr mfp = &Klass::implementation;\n+\n+  return reinterpret_cast<Func*>(mfp);\n+}\n+\n+\n+// Verify a warning for the unsafe declaration.\n+\n+int __attribute__ ((ifunc (\"_ZN5Klass13iffy_resolverEv\")))\n+Klass::iffy_magic ();    // { dg-message \"resolver indirect function declared here\" }\n+\n+void*\n+Klass::iffy_resolver (void)   // { dg-warning \".ifunc. resolver for .int Klass::iffy_magic\\\\(\\\\). should return .int \\\\(\\\\*\\\\)\\\\(Klass\\\\*\\\\).\" }\n+{\n+  MemFuncPtr mfp = &Klass::implementation;\n+\n+  return reinterpret_cast<void*>(mfp);\n+}\n+\n+\n+// Verify an error for an incompatible declaration.\n+\n+const char* __attribute__ ((ifunc (\"_ZN5Klass12bad_resolverEv\")))\n+Klass::bad_magic ();   // { dg-message \"resolver indirect function declared here\" }\n \n \n Klass::MemFuncPtr\n-Klass::resolver (void) // { dg-message \"aliased declaration here\" }\n+Klass::bad_resolver (void)   // { dg-error \".ifunc. resolver for .const char\\\\* Klass::bad_magic\\\\(\\\\). must return .const char\\\\* \\\\(\\\\*\\\\)\\\\(Klass\\\\*\\\\).\" }\n {\n   return &Klass::implementation;\n }"}, {"sha": "96533e09218e5c94c510853ac59a12a5b6661782", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -1,5 +1,5 @@\n // { dg-do run  }\n-// { dg-options \"-Wno-attributes -fno-strict-aliasing\" }\n+// { dg-options \"-Wno-attribute-alias -fno-strict-aliasing\" }\n // Origin: Mark Mitchell <mark@codesourcery.com>\n \n #if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100"}, {"sha": "1021a811be40103dd06894f8841e5e56a847c161", "filename": "gcc/testsuite/gcc.dg/pr81854.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81854.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81854.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81854.c?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -1,6 +1,7 @@\n /* PR c/81854 - weak alias of an incompatible symbol accepted\n    { dg-do compile }\n-   { dg-require-ifunc \"\" } */\n+   { dg-require-ifunc \"\" }\n+   { dg-options \"-Wextra\" } */\n \n const char* __attribute__ ((weak, alias (\"f0_target\")))\n f0 (void);          /* { dg-error \"alias between function and variable\" } */\n@@ -26,39 +27,37 @@ const char* f2_target (int i)   /* { dg-message \"aliased declaration here\" } */\n   return 0;\n }\n \n-\n int __attribute__ ((ifunc (\"f3_resolver\")))\n-f3 (void);          /* { dg-error \".ifunc. resolver must return a function pointer\" } */\n+f3 (void);          /* { dg-message \"resolver indirect function declared here\" } */\n \n-int f3_resolver (void)   /* { dg-message \"resolver declaration here\" } */\n+void* f3_resolver (void) /* { dg-warning \"ifunc. resolver for .f3. should return .int \\\\(\\\\*\\\\)\\\\(void\\\\).\" } */\n {\n   return 0;\n }\n \n \n int __attribute__ ((ifunc (\"f4_resolver\")))\n-f4 (void);          /* { dg-warning \".ifunc. resolver should return a function pointer\" } */\n+f4 (void);          /* { dg-message \"resolver indirect function declared here\" } */\n \n-void* f4_resolver (void) /* { dg-message \"resolver declaration here\" } */\n+typedef void F4 (void);\n+F4* f4_resolver (void) /* { dg-warning \".ifunc. resolver for .f4. should return .int \\\\(\\\\*\\\\)\\\\(void\\\\)\" } */\n {\n   return 0;\n }\n \n+const char* __attribute__ ((ifunc (\"f5_resolver\")))\n+f5 (void);\n \n-int __attribute__ ((ifunc (\"f5_resolver\")))\n-f5 (void);          /* { dg-warning \"alias between functions of incompatible types\" } */\n-\n-typedef void F5 (void);\n-F5* f5_resolver (void) /* { dg-message \"aliased declaration here\" } */\n+typedef const char* F5 (void);\n+F5* f5_resolver (void)\n {\n   return 0;\n }\n \n-const char* __attribute__ ((ifunc (\"f6_resolver\")))\n-f6 (void);\n+int __attribute__ ((ifunc (\"f6_resolver\")))\n+f6 (void);          /* { dg-message \"resolver indirect function declared here\" } */\n \n-typedef const char* F6 (void);\n-F6* f6_resolver (void)\n+int f6_resolver (void)   /* { dg-error \".ifunc. resolver for 'f6' must return .int \\\\(\\\\*\\\\)\\\\(void\\\\).\" } */\n {\n   return 0;\n }"}, {"sha": "4f9bf460c220aa88a1f1236e17ca6f93d6ca8a88", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a866e7e316df13b04a84a8d5426b43d016573ea/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=7a866e7e316df13b04a84a8d5426b43d016573ea", "patch": "@@ -440,8 +440,8 @@ proc check_ifunc_available { } {\n \textern \"C\" {\n \t#endif\n \ttypedef void F (void);\n-\tF* g() {}\n-\tvoid f() __attribute__((ifunc(\"g\")));\n+\tF* g (void) {}\n+\tvoid f () __attribute__ ((ifunc (\"g\")));\n \t#ifdef __cplusplus\n \t}\n \t#endif"}]}