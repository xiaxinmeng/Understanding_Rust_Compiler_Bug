{"sha": "a065f205c3171e63b4efee0b9d890782e95a691b", "node_id": "C_kwDOANBUbNoAKGEwNjVmMjA1YzMxNzFlNjNiNGVmZWUwYjlkODkwNzgyZTk1YTY5MWI", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-25T19:45:36Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-29T14:27:20Z"}, "message": "This updates our handling of canonical paths to contain the crate-name\n\nIn the name resolver there are two types of canonical-path object.\n\n1. The relative canonical path to a type for name resolution\n2. The full canonical-path including the crate-name (this-was-missing)\n\nThe lack of the crate-name being present in the canonical-path meant the\nsymbol mangling system was required to append it where apropriate but this\nwas going to be too messy to handle all cases. Such as module blocks\ncontaining impl blocks requires a prefix::<impl crate::path>::item and\nsimilarly for trait impl blocks.\n\nThis patch updates the name-resolution system to build up the\ncanonical-path of items along side the relative type-paths at the same time\nthis needs to be done as it is not possible to resolve the canonical path\nin the toplevel scan for all names within the crate when it comes to\nimpl/trait-impl blocks as they may be declared after the block so this\nneeds to be done at the same time as the normal name resolution mechanisms.\n\nThe patch here means the name-manglers no longer need to care about the\ncrate names of any item which is key for when we need to call functions\nin other crates.", "tree": {"sha": "579891f4bd5354d72a093fd9aab8dd83407f2620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/579891f4bd5354d72a093fd9aab8dd83407f2620"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a065f205c3171e63b4efee0b9d890782e95a691b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a065f205c3171e63b4efee0b9d890782e95a691b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a065f205c3171e63b4efee0b9d890782e95a691b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a065f205c3171e63b4efee0b9d890782e95a691b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63686e099bfd0e3e89789942f20a05a750541d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63686e099bfd0e3e89789942f20a05a750541d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63686e099bfd0e3e89789942f20a05a750541d6b"}], "stats": {"total": 979, "additions": 749, "deletions": 230}, "files": [{"sha": "6ee5f3de929f9db894c56dd10a3c7c32ce1ae79b", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -201,13 +201,14 @@ class ResolverBase : public AST::ASTVisitor\n \n protected:\n   ResolverBase (NodeId parent)\n-    : resolver (Resolver::get ()), resolved_node (UNKNOWN_NODEID),\n-      parent (parent), locus (Location ())\n+    : resolver (Resolver::get ()), mappings (Analysis::Mappings::get ()),\n+      resolved_node (UNKNOWN_NODEID), parent (parent), locus (Location ())\n   {}\n \n   bool resolved () const { return resolved_node != UNKNOWN_NODEID; }\n \n   Resolver *resolver;\n+  Analysis::Mappings *mappings;\n   NodeId resolved_node;\n   NodeId parent;\n   Location locus;"}, {"sha": "b7b86467bbad173271384f3f2a847632815f55c4", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -63,15 +63,16 @@ class ResolveExpr : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Expr *expr, NodeId parent)\n+  static void go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveExpr resolver (parent);\n+    ResolveExpr resolver (parent, prefix, canonical_prefix);\n     expr->accept_vis (resolver);\n   };\n \n   void visit (AST::TupleIndexExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_tuple_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::TupleExpr &expr) override\n@@ -80,7 +81,7 @@ class ResolveExpr : public ResolverBase\n       return;\n \n     for (auto &elem : expr.get_tuple_elems ())\n-      ResolveExpr::go (elem.get (), expr.get_node_id ());\n+      resolve_expr (elem.get (), expr.get_node_id ());\n   }\n \n   void visit (AST::PathInExpression &expr) override\n@@ -96,20 +97,20 @@ class ResolveExpr : public ResolverBase\n   void visit (AST::ReturnExpr &expr) override\n   {\n     if (expr.has_returned_expr ())\n-      ResolveExpr::go (expr.get_returned_expr ().get (), expr.get_node_id ());\n+      resolve_expr (expr.get_returned_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::CallExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_function_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_function_expr ().get (), expr.get_node_id ());\n     auto const &in_params = expr.get_params ();\n     for (auto &param : in_params)\n-      ResolveExpr::go (param.get (), expr.get_node_id ());\n+      resolve_expr (param.get (), expr.get_node_id ());\n   }\n \n   void visit (AST::MethodCallExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n \n     if (expr.get_method_name ().has_generic_args ())\n       {\n@@ -119,13 +120,13 @@ class ResolveExpr : public ResolverBase\n \n     auto const &in_params = expr.get_params ();\n     for (auto &param : in_params)\n-      ResolveExpr::go (param.get (), expr.get_node_id ());\n+      resolve_expr (param.get (), expr.get_node_id ());\n   }\n \n   void visit (AST::AssignmentExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n \n     // need to verify the assignee\n     VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n@@ -160,60 +161,60 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::ArithmeticOrLogicalExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::CompoundAssignmentExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n \n     // need to verify the assignee\n     VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::ComparisonExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::LazyBooleanExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::NegationExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_negated_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_negated_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::TypeCastExpr &expr) override\n   {\n     ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_casted_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_casted_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::IfExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::IfExprConseqElse &expr) override\n   {\n-    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_else_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_else_block ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::IfExprConseqIf &expr) override\n   {\n-    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::BlockExpr &expr) override;\n@@ -226,7 +227,7 @@ class ResolveExpr : public ResolverBase\n   void visit (AST::ArrayElemsValues &elems) override\n   {\n     for (auto &elem : elems.get_values ())\n-      ResolveExpr::go (elem.get (), elems.get_node_id ());\n+      resolve_expr (elem.get (), elems.get_node_id ());\n   }\n \n   void visit (AST::ArrayExpr &expr) override\n@@ -236,52 +237,51 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::ArrayIndexExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_array_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_index_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_array_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_index_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::ArrayElemsCopied &elems) override\n   {\n-    ResolveExpr::go (elems.get_num_copies ().get (), elems.get_node_id ());\n-    ResolveExpr::go (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n+    resolve_expr (elems.get_num_copies ().get (), elems.get_node_id ());\n+    resolve_expr (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n   }\n \n   // this this an empty struct constructor like 'S {}'\n   void visit (AST::StructExprStruct &struct_expr) override\n   {\n-    ResolveExpr::go (&struct_expr.get_struct_name (),\n-\t\t     struct_expr.get_node_id ());\n+    resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n   }\n \n   // this this a struct constructor with fields\n   void visit (AST::StructExprStructFields &struct_expr) override\n   {\n-    ResolveExpr::go (&struct_expr.get_struct_name (),\n-\t\t     struct_expr.get_node_id ());\n+    resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n \n     if (struct_expr.has_struct_base ())\n       {\n \tAST::StructBase &base = struct_expr.get_struct_base ();\n-\tResolveExpr::go (base.get_base_struct ().get (),\n-\t\t\t struct_expr.get_node_id ());\n+\tresolve_expr (base.get_base_struct ().get (),\n+\t\t      struct_expr.get_node_id ());\n       }\n \n     auto const &struct_fields = struct_expr.get_fields ();\n     for (auto &struct_field : struct_fields)\n       {\n \tResolveStructExprField::go (struct_field.get (),\n-\t\t\t\t    struct_expr.get_node_id ());\n+\t\t\t\t    struct_expr.get_node_id (), prefix,\n+\t\t\t\t    canonical_prefix);\n       }\n   }\n \n   void visit (AST::GroupedExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::FieldAccessExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::LoopExpr &expr) override\n@@ -311,7 +311,7 @@ class ResolveExpr : public ResolverBase\n \t\t\t\t\t Definition{label_lifetime_node_id,\n \t\t\t\t\t\t    label.get_node_id ()});\n       }\n-    ResolveExpr::go (expr.get_loop_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::BreakExpr &expr) override\n@@ -340,7 +340,7 @@ class ResolveExpr : public ResolverBase\n       }\n \n     if (expr.has_break_expr ())\n-      ResolveExpr::go (expr.get_break_expr ().get (), expr.get_node_id ());\n+      resolve_expr (expr.get_break_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::WhileLoopExpr &expr) override\n@@ -370,8 +370,8 @@ class ResolveExpr : public ResolverBase\n \t\t\t\t\t Definition{label_lifetime_node_id,\n \t\t\t\t\t\t    label.get_node_id ()});\n       }\n-    ResolveExpr::go (expr.get_predicate_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_loop_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_predicate_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::ContinueExpr &expr) override\n@@ -402,17 +402,17 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::BorrowExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::DereferenceExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::MatchExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n     for (auto &match_case : expr.get_match_cases ())\n       {\n \t// each arm is in its own scope\n@@ -427,7 +427,7 @@ class ResolveExpr : public ResolverBase\n \t// resolve\n \tAST::MatchArm &arm = match_case.get_arm ();\n \tif (arm.has_match_arm_guard ())\n-\t  ResolveExpr::go (arm.get_guard_expr ().get (), expr.get_node_id ());\n+\t  resolve_expr (arm.get_guard_expr ().get (), expr.get_node_id ());\n \n \t// insert any possible new patterns\n \tfor (auto &pattern : arm.get_patterns ())\n@@ -436,7 +436,7 @@ class ResolveExpr : public ResolverBase\n \t  }\n \n \t// resolve the body\n-\tResolveExpr::go (match_case.get_expr ().get (), expr.get_node_id ());\n+\tresolve_expr (match_case.get_expr ().get (), expr.get_node_id ());\n \n \t// done\n \tresolver->get_name_scope ().pop ();\n@@ -445,8 +445,21 @@ class ResolveExpr : public ResolverBase\n       }\n   }\n \n+protected:\n+  void resolve_expr (AST::Expr *e, NodeId parent)\n+  {\n+    ResolveExpr::go (e, parent, prefix, canonical_prefix);\n+  }\n+\n private:\n-  ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n+  ResolveExpr (NodeId parent, const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix)\n+    : ResolverBase (parent), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "074855eae2eb063653aab0dd41b25289203be808", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -45,8 +45,10 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::TypeAlias &type) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (type.get_node_id (), type.get_new_type_name ()));\n+    auto decl\n+      = CanonicalPath::new_seg (type.get_node_id (), type.get_new_type_name ());\n+    auto path = prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, type.get_node_id (), type.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -58,8 +60,9 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto path\n-      = prefix.append (ResolveConstantItemToCanonicalPath::resolve (constant));\n+    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -74,8 +77,9 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n-    auto path\n-      = prefix.append (ResolveFunctionItemToCanonicalPath::resolve (function));\n+    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -90,8 +94,9 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Method &method) override\n   {\n-    auto path\n-      = prefix.append (ResolveMethodItemToCanonicalPath::resolve (method));\n+    auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, method.get_node_id (), method.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -119,17 +124,19 @@ class ResolveTopLevelTraitItems : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::TraitItem *item,\n-\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n+  static void go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveTopLevelTraitItems resolver (prefix);\n+    ResolveTopLevelTraitItems resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TraitItemFunc &function) override\n   {\n-    auto path = prefix.append (\n-      ResolveTraitItemFunctionToCanonicalPath::resolve (function));\n+    auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (function);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -140,12 +147,17 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     resolver->insert_new_definition (function.get_node_id (),\n \t\t\t\t     Definition{function.get_node_id (),\n \t\t\t\t\t\tfunction.get_node_id ()});\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     function.get_node_id (), cpath);\n   }\n \n   void visit (AST::TraitItemMethod &method) override\n   {\n-    auto path\n-      = prefix.append (ResolveTraitItemMethodToCanonicalPath::resolve (method));\n+    auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (method);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, method.get_node_id (), method.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -156,12 +168,17 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     resolver->insert_new_definition (method.get_node_id (),\n \t\t\t\t     Definition{method.get_node_id (),\n \t\t\t\t\t\tmethod.get_node_id ()});\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     method.get_node_id (), cpath);\n   }\n \n   void visit (AST::TraitItemConst &constant) override\n   {\n-    auto path = prefix.append (\n-      ResolveTraitItemConstToCanonicalPath::resolve (constant));\n+    auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -172,46 +189,57 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     resolver->insert_new_definition (constant.get_node_id (),\n \t\t\t\t     Definition{constant.get_node_id (),\n \t\t\t\t\t\tconstant.get_node_id ()});\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n   }\n \n   void visit (AST::TraitItemType &type) override\n   {\n-    auto path\n-      = prefix.append (ResolveTraitItemTypeToCanonicalPath::resolve (type));\n+    auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, type.get_node_id (), type.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (type.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     type.get_node_id (), cpath);\n   }\n \n private:\n-  ResolveTopLevelTraitItems (const CanonicalPath &prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+  ResolveTopLevelTraitItems (const CanonicalPath &prefix,\n+\t\t\t     const CanonicalPath &canonical_prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n   {}\n \n   const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n class ResolveToplevelExternItem : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::ExternalItem *item,\n-\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n+  static void go (AST::ExternalItem *item, const CanonicalPath &prefix)\n   {\n     ResolveToplevelExternItem resolver (prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::ExternalFunctionItem &function) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (function.get_node_id (),\n-\t\t\t\t\t       function.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_identifier ());\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -226,8 +254,10 @@ class ResolveToplevelExternItem : public ResolverBase\n \n   void visit (AST::ExternalStaticItem &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {"}, {"sha": "e428880ea792e2cbbe03efd171f2b367724d3ab1", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 254, "deletions": 33, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -35,20 +35,33 @@ class ResolveTraitItems : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::TraitItem *item)\n+  static void go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveTraitItems resolver;\n+    ResolveTraitItems resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TraitItemType &type) override\n   {\n+    auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     type.get_node_id (), cpath);\n+\n     for (auto &bound : type.get_type_param_bounds ())\n       ResolveTypeBound::go (bound.get (), type.get_node_id ());\n   }\n \n   void visit (AST::TraitItemFunc &func) override\n   {\n+    auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (func);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     func.get_node_id (), cpath);\n+\n     NodeId scope_node_id = func.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -86,7 +99,8 @@ class ResolveTraitItems : public ResolverBase\n \n     // trait items have an optional body\n     if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n+\t\t       cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -95,6 +109,12 @@ class ResolveTraitItems : public ResolverBase\n \n   void visit (AST::TraitItemMethod &func) override\n   {\n+    auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (func);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     func.get_node_id (), cpath);\n+\n     NodeId scope_node_id = func.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -152,7 +172,8 @@ class ResolveTraitItems : public ResolverBase\n \n     // trait items have an optional body\n     if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n+\t\t       cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -161,10 +182,17 @@ class ResolveTraitItems : public ResolverBase\n \n   void visit (AST::TraitItemConst &constant) override\n   {\n+    auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n+\n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n \n     if (constant.has_expr ())\n-      ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+      ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (),\n+\t\t       path, cpath);\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment\n@@ -174,22 +202,37 @@ class ResolveTraitItems : public ResolverBase\n   }\n \n private:\n-  ResolveTraitItems () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveTraitItems (const CanonicalPath &prefix,\n+\t\t     const CanonicalPath &canonical_prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n class ResolveItem : public ResolverBase\n {\n public:\n   using Rust::Resolver::ResolverBase::visit;\n \n-  static void go (AST::Item *item)\n+  static void go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveItem resolver;\n+    ResolveItem resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TypeAlias &alias) override\n   {\n+    auto talias = CanonicalPath::new_seg (alias.get_node_id (),\n+\t\t\t\t\t  alias.get_new_type_name ());\n+    auto path = prefix.append (talias);\n+    auto cpath = canonical_prefix.append (talias);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     alias.get_node_id (), cpath);\n+\n     NodeId scope_node_id = alias.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -209,6 +252,13 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Module &module) override\n   {\n+    auto mod\n+      = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n+    auto path = prefix.append (mod);\n+    auto cpath = canonical_prefix.append (mod);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     module.get_node_id (), cpath);\n+\n     NodeId scope_node_id = module.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -218,10 +268,10 @@ class ResolveItem : public ResolverBase\n     resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n     for (auto &item : module.get_items ())\n-      ResolveTopLevel::go (item.get ());\n+      ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath);\n \n     for (auto &item : module.get_items ())\n-      ResolveItem::go (item.get ());\n+      ResolveItem::go (item.get (), path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -230,6 +280,13 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n+\n     NodeId scope_node_id = struct_decl.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -254,6 +311,13 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Enum &enum_decl) override\n   {\n+    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\tenum_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     enum_decl.get_node_id (), cpath);\n+\n     NodeId scope_node_id = enum_decl.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -270,7 +334,7 @@ class ResolveItem : public ResolverBase\n \n     /* The actual fields are inside the variants.  */\n     for (auto &variant : enum_decl.get_variants ())\n-      ResolveItem::go (variant.get ());\n+      ResolveItem::go (variant.get (), path, cpath);\n \n     resolver->get_type_scope ().pop ();\n   }\n@@ -279,20 +343,50 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::EnumItemTuple &item) override\n   {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     for (auto &field : item.get_tuple_fields ())\n       ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n   }\n \n   void visit (AST::EnumItemStruct &item) override\n   {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     for (auto &field : item.get_struct_fields ())\n       ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n   }\n \n-  /* EnumItemDiscriminant doesn't need to be handled, no fields.  */\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+  }\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n+\n     NodeId scope_node_id = struct_decl.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -317,6 +411,13 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Union &union_decl) override\n   {\n+    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t\tunion_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     union_decl.get_node_id (), cpath);\n+\n     NodeId scope_node_id = union_decl.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -340,8 +441,15 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::StaticItem &var) override\n   {\n+    auto decl\n+      = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     var.get_node_id (), cpath);\n+\n     ResolveType::go (var.get_type ().get (), var.get_node_id ());\n-    ResolveExpr::go (var.get_expr ().get (), var.get_node_id ());\n+    ResolveExpr::go (var.get_expr ().get (), var.get_node_id (), path, cpath);\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment\n@@ -350,8 +458,15 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n+    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n+\n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n+\t\t     cpath);\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment\n@@ -365,6 +480,12 @@ class ResolveItem : public ResolverBase\n     if (function.is_marked_for_strip ())\n       return;\n \n+    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     function.get_node_id (), cpath);\n+\n     NodeId scope_node_id = function.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -402,8 +523,8 @@ class ResolveItem : public ResolverBase\n       }\n \n     // resolve the function body\n-    ResolveExpr::go (function.get_definition ().get (),\n-\t\t     function.get_node_id ());\n+    ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n+\t\t     path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -430,17 +551,47 @@ class ResolveItem : public ResolverBase\n     if (impl_block.has_where_clause ())\n       ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n \n+    // FIXME this needs to be protected behind nominal type-checks see:\n+    // rustc --explain E0118\n+\n+    CanonicalPath self_cpath = CanonicalPath::create_empty ();\n     bool canonicalize_type_with_generics = false;\n-    NodeId resolved_node = ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t\t\t    impl_block.get_node_id (),\n-\t\t\t\t\t    canonicalize_type_with_generics);\n+    NodeId resolved_node\n+      = ResolveType::go (impl_block.get_type ().get (),\n+\t\t\t impl_block.get_node_id (),\n+\t\t\t canonicalize_type_with_generics, &self_cpath);\n     if (resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n \tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n+    // Setup paths\n+    bool canonicalize_type_args = !impl_block.has_generics ();\n+    bool type_resolve_generic_args = false;\n+\n+    CanonicalPath impl_type\n+      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+    CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n+    // see https://godbolt.org/z/a3vMbsT6W\n+    CanonicalPath cpath = CanonicalPath::create_empty ();\n+    if (canonical_prefix.size () > 1)\n+      {\n+\tstd::string seg_buf = \"<impl \" + self_cpath.get () + \">\";\n+\tCanonicalPath seg\n+\t  = CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+\tcpath = canonical_prefix.append (seg);\n+      }\n+    else\n+      {\n+\tcpath = canonical_prefix.append (self_cpath);\n+      }\n+    // done setup paths\n+\n     auto Self\n       = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n \n@@ -450,7 +601,7 @@ class ResolveItem : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n-\tresolve_impl_item (impl_item.get ());\n+\tresolve_impl_item (impl_item.get (), impl_prefix, cpath);\n       }\n \n     resolver->get_type_scope ().peek ()->clear_name (\n@@ -462,6 +613,12 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Method &method) override\n   {\n+    auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     method.get_node_id (), cpath);\n+\n     NodeId scope_node_id = method.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -522,7 +679,8 @@ class ResolveItem : public ResolverBase\n       ResolveWhereClause::Resolve (method.get_where_clause ());\n \n     // resolve the function body\n-    ResolveExpr::go (method.get_definition ().get (), method.get_node_id ());\n+    ResolveExpr::go (method.get_definition ().get (), method.get_node_id (),\n+\t\t     path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -549,29 +707,72 @@ class ResolveItem : public ResolverBase\n     if (impl_block.has_where_clause ())\n       ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n \n+    CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n     bool canonicalize_type_with_generics = false;\n     NodeId trait_resolved_node\n       = ResolveType::go (&impl_block.get_trait_path (),\n \t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics);\n+\t\t\t canonicalize_type_with_generics,\n+\t\t\t &canonical_trait_type);\n     if (trait_resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n \tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n+    CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n     NodeId type_resolved_node\n       = ResolveType::go (impl_block.get_type ().get (),\n \t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics);\n+\t\t\t canonicalize_type_with_generics, &canonical_impl_type);\n     if (type_resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n \tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n+    // setup paths\n+    bool canonicalize_type_args = !impl_block.has_generics ();\n+    bool type_resolve_generic_args = false;\n+\n+    CanonicalPath impl_type_seg\n+      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+    CanonicalPath trait_type_seg\n+      = ResolveTypeToCanonicalPath::resolve (impl_block.get_trait_path (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+\n+    CanonicalPath projection\n+      = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n+\t\t\t\t      impl_type_seg);\n+    CanonicalPath impl_prefix = prefix.append (projection);\n+\n+    // setup canonical-path\n+    CanonicalPath canonical_projection\n+      = TraitImplProjection::resolve (impl_block.get_node_id (),\n+\t\t\t\t      canonical_trait_type,\n+\t\t\t\t      canonical_impl_type);\n+    CanonicalPath cpath = CanonicalPath::create_empty ();\n+    if (canonical_prefix.size () > 1)\n+      {\n+\tstd::string projection_str = canonical_projection.get ();\n+\tstd::string seg_buf\n+\t  = \"<impl \" + projection_str.substr (1, projection_str.size () - 2)\n+\t    + \">\";\n+\tCanonicalPath seg\n+\t  = CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+\tcpath = canonical_prefix.append (seg);\n+      }\n+    else\n+      {\n+\tcpath = canonical_prefix.append (canonical_projection);\n+      }\n+    // DONE setup canonical-path\n+\n     auto Self\n       = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n \n@@ -581,7 +782,7 @@ class ResolveItem : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n-\tresolve_impl_item (impl_item.get ());\n+\tresolve_impl_item (impl_item.get (), impl_prefix, cpath);\n       }\n \n     resolver->get_type_scope ().peek ()->clear_name (\n@@ -625,9 +826,14 @@ class ResolveItem : public ResolverBase\n     if (trait.has_where_clause ())\n       ResolveWhereClause::Resolve (trait.get_where_clause ());\n \n+    // resolve the paths\n+    CanonicalPath path = CanonicalPath::create_empty ();\n+    CanonicalPath cpath = CanonicalPath::create_empty ();\n+    //\n+\n     for (auto &item : trait.get_trait_items ())\n       {\n-\tResolveTraitItems::go (item.get ());\n+\tResolveTraitItems::go (item.get (), path, cpath);\n       }\n \n     resolver->get_type_scope ().pop ();\n@@ -643,27 +849,39 @@ class ResolveItem : public ResolverBase\n   }\n \n protected:\n-  void resolve_impl_item (AST::TraitImplItem *item);\n-  void resolve_impl_item (AST::InherentImplItem *item);\n+  void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix);\n+  void resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t  const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix);\n   void resolve_extern_item (AST::ExternalItem *item);\n \n-  ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveItem (const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n class ResolveImplItems : public ResolveItem\n {\n   using Rust::Resolver::ResolveItem::visit;\n \n public:\n-  static void go (AST::InherentImplItem *item)\n+  static void go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveImplItems resolver;\n+    ResolveImplItems resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n-  static void go (AST::TraitImplItem *item)\n+  static void go (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveImplItems resolver;\n+    ResolveImplItems resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n@@ -677,7 +895,10 @@ class ResolveImplItems : public ResolveItem\n   }\n \n private:\n-  ResolveImplItems () : ResolveItem () {}\n+  ResolveImplItems (const CanonicalPath &prefix,\n+\t\t    const CanonicalPath &canonical_prefix)\n+    : ResolveItem (prefix, canonical_prefix)\n+  {}\n };\n \n class ResolveExternItem : public ResolverBase"}, {"sha": "0c7c8f37a3a5283ab223fc7fbf983bdecacd7ce5", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -25,13 +25,13 @@ namespace Resolver {\n void\n PatternDeclaration::visit (AST::PathInExpression &pattern)\n {\n-  ResolveExpr::go (&pattern, parent);\n+  ResolvePath::go (&pattern, parent);\n }\n \n void\n PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n {\n-  ResolveExpr::go (&pattern.get_path (), parent);\n+  ResolvePath::go (&pattern.get_path (), parent);\n \n   std::unique_ptr<AST::TupleStructItems> &items = pattern.get_items ();\n   switch (items->get_item_type ())\n@@ -59,7 +59,7 @@ PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n void\n PatternDeclaration::visit (AST::StructPattern &pattern)\n {\n-  ResolveExpr::go (&pattern.get_path (), parent);\n+  ResolvePath::go (&pattern.get_path (), parent);\n \n   auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n   for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())"}, {"sha": "308de146f996bd3e31f29327a0f5b7e5894555ee", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 85, "deletions": 25, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -33,27 +33,34 @@ class ResolveStmt : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Stmt *stmt, NodeId parent,\n-\t\t  const CanonicalPath &enum_prefix\n-\t\t  = CanonicalPath::create_empty ())\n+  static void go (AST::Stmt *stmt, NodeId parent, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix,\n+\t\t  const CanonicalPath &enum_prefix)\n   {\n-    ResolveStmt resolver (parent, enum_prefix);\n+    ResolveStmt resolver (parent, prefix, canonical_prefix, enum_prefix);\n     stmt->accept_vis (resolver);\n   };\n \n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n-    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id ());\n+    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,\n+\t\t     canonical_prefix);\n   }\n \n   void visit (AST::ExprStmtWithoutBlock &stmt) override\n   {\n-    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id ());\n+    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,\n+\t\t     canonical_prefix);\n   }\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto path = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n+\n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -66,7 +73,8 @@ class ResolveStmt : public ResolverBase\n \t\t\t\t\t\tconstant.get_node_id ()});\n \n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (),\n+\t\t     prefix, canonical_prefix);\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment\n@@ -79,7 +87,8 @@ class ResolveStmt : public ResolverBase\n   {\n     if (stmt.has_init_expr ())\n       {\n-\tResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id ());\n+\tResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id (),\n+\t\t\t prefix, canonical_prefix);\n \n \t// mark the assignment\n \tresolver->mark_assignment_to_decl (\n@@ -93,8 +102,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    auto path = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n \t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -124,10 +138,15 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::Enum &enum_decl) override\n   {\n-    auto enum_path = CanonicalPath::new_seg (enum_decl.get_node_id (),\n-\t\t\t\t\t     enum_decl.get_identifier ());\n+    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\tenum_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     enum_decl.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n-      enum_path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n+      path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (enum_decl.get_locus ());\n \tr.add_range (locus);\n@@ -146,15 +165,20 @@ class ResolveStmt : public ResolverBase\n       }\n \n     for (auto &variant : enum_decl.get_variants ())\n-      ResolveStmt::go (variant.get (), parent, enum_path);\n+      ResolveStmt::go (variant.get (), parent, path, canonical_prefix, path);\n \n     resolver->get_type_scope ().pop ();\n   }\n \n   void visit (AST::EnumItem &item) override\n   {\n-    auto path = enum_prefix.append (\n+    auto decl = enum_prefix.append (\n       CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -168,8 +192,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::EnumItemTuple &item) override\n   {\n-    auto path = enum_prefix.append (\n+    auto decl = enum_prefix.append (\n       CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -184,8 +213,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::EnumItemStruct &item) override\n   {\n-    auto path = enum_prefix.append (\n+    auto decl = enum_prefix.append (\n       CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -200,8 +234,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::EnumItemDiscriminant &item) override\n   {\n-    auto path = enum_prefix.append (\n+    auto decl = enum_prefix.append (\n       CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -215,8 +254,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    auto path = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n \t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -246,8 +290,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::Union &union_decl) override\n   {\n-    auto path = CanonicalPath::new_seg (union_decl.get_node_id (),\n+    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n \t\t\t\t\tunion_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     union_decl.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, union_decl.get_node_id (), union_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -276,7 +325,12 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n-    auto path = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     function.get_node_id (), cpath);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -321,19 +375,25 @@ class ResolveStmt : public ResolverBase\n       }\n \n     // resolve the function body\n-    ResolveExpr::go (function.get_definition ().get (),\n-\t\t     function.get_node_id ());\n+    ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n+\t\t     path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n     resolver->get_label_scope ().pop ();\n   }\n \n private:\n-  ResolveStmt (NodeId parent, const CanonicalPath &enum_prefix)\n-    : ResolverBase (parent), enum_prefix (enum_prefix)\n+  ResolveStmt (NodeId parent, const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix,\n+\t       const CanonicalPath &enum_prefix)\n+    : ResolverBase (parent), prefix (prefix),\n+      canonical_prefix (canonical_prefix), enum_prefix (enum_prefix)\n   {}\n \n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+\n   /* item declaration statements are not given a canonical path, but enum items\n    * (variants) do inherit the enum path/identifier name.  */\n   const CanonicalPath &enum_prefix;"}, {"sha": "b2c30a95dbc26d7a90d2523f04c2c3fd7520c237", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -32,9 +32,11 @@ class ResolveStructExprField : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::StructExprField *field, NodeId parent)\n+  static void go (AST::StructExprField *field, NodeId parent,\n+\t\t  const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveStructExprField resolver (parent);\n+    ResolveStructExprField resolver (parent, prefix, canonical_prefix);\n     field->accept_vis (resolver);\n   }\n \n@@ -47,7 +49,14 @@ class ResolveStructExprField : public ResolverBase\n   void visit (AST::StructExprFieldIdentifier &field) override;\n \n private:\n-  ResolveStructExprField (NodeId parent) : ResolverBase (parent) {}\n+  ResolveStructExprField (NodeId parent, const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix)\n+    : ResolverBase (parent), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "56962f617240ceb02d65b78f9f347d19541435e8", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 126, "deletions": 41, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -33,17 +33,20 @@ class ResolveTopLevel : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Item *item,\n-\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n+  static void go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveTopLevel resolver (prefix);\n+    ResolveTopLevel resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::Module &module) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (module.get_node_id (), module.get_name ()));\n+    auto mod\n+      = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n+    auto path = prefix.append (mod);\n+    auto cpath = canonical_prefix.append (mod);\n+\n     resolver->get_name_scope ().insert (\n       path, module.get_node_id (), module.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -57,42 +60,57 @@ class ResolveTopLevel : public ResolverBase\n \t\t\t\t\t\tmodule.get_node_id ()});\n \n     for (auto &item : module.get_items ())\n-      ResolveTopLevel::go (item.get (), path);\n+      ResolveTopLevel::go (item.get (), path, cpath);\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     module.get_node_id (), cpath);\n   }\n \n   void visit (AST::TypeAlias &alias) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (alias.get_node_id (),\n-\t\t\t\t\t       alias.get_new_type_name ()));\n+    auto talias = CanonicalPath::new_seg (alias.get_node_id (),\n+\t\t\t\t\t  alias.get_new_type_name ());\n+    auto path = prefix.append (talias);\n+    auto cpath = canonical_prefix.append (talias);\n+\n     resolver->get_type_scope ().insert (\n       path, alias.get_node_id (), alias.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (alias.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     alias.get_node_id (), cpath);\n   }\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (struct_decl.get_node_id (),\n-\t\t\t\t\t       struct_decl.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n   }\n \n   void visit (AST::Enum &enum_decl) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (enum_decl.get_node_id (),\n-\t\t\t\t\t       enum_decl.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\tenum_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -102,93 +120,133 @@ class ResolveTopLevel : public ResolverBase\n       });\n \n     for (auto &variant : enum_decl.get_variants ())\n-      ResolveTopLevel::go (variant.get (), path);\n+      ResolveTopLevel::go (variant.get (), path, cpath);\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     enum_decl.get_node_id (), cpath);\n   }\n \n   void visit (AST::EnumItem &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n   }\n \n   void visit (AST::EnumItemTuple &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n   }\n \n   void visit (AST::EnumItemStruct &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n   }\n \n   void visit (AST::EnumItemDiscriminant &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n   }\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (struct_decl.get_node_id (),\n-\t\t\t\t\t       struct_decl.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n   }\n \n   void visit (AST::Union &union_decl) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (union_decl.get_node_id (),\n-\t\t\t\t\t       union_decl.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t\tunion_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, union_decl.get_node_id (), union_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (union_decl.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     union_decl.get_node_id (), cpath);\n   }\n \n   void visit (AST::StaticItem &var) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, var.get_node_id (), var.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -200,12 +258,17 @@ class ResolveTopLevel : public ResolverBase\n \t\t\t\t     Definition{var.get_node_id (),\n \t\t\t\t\t\tvar.get_node_id ()});\n     resolver->mark_decl_mutability (var.get_node_id (), var.is_mutable ());\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     var.get_node_id (), cpath);\n   }\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto path\n-      = prefix.append (ResolveConstantItemToCanonicalPath::resolve (constant));\n+    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -216,15 +279,20 @@ class ResolveTopLevel : public ResolverBase\n     resolver->insert_new_definition (constant.get_node_id (),\n \t\t\t\t     Definition{constant.get_node_id (),\n \t\t\t\t\t\tconstant.get_node_id ()});\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n   }\n \n   void visit (AST::Function &function) override\n   {\n     if (function.is_marked_for_strip ())\n       return;\n \n-    auto path\n-      = prefix.append (ResolveFunctionItemToCanonicalPath::resolve (function));\n+    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -243,12 +311,16 @@ class ResolveTopLevel : public ResolverBase\n \tresolver->insert_resolved_name (function.get_node_id (),\n \t\t\t\t\tfunction.get_node_id ());\n       }\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     function.get_node_id (), cpath);\n   }\n \n   void visit (AST::InherentImpl &impl_block) override\n   {\n     bool canonicalize_type_args = !impl_block.has_generics ();\n     bool type_resolve_generic_args = false;\n+\n     CanonicalPath impl_type\n       = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n \t\t\t\t\t     canonicalize_type_args,\n@@ -257,6 +329,8 @@ class ResolveTopLevel : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n+\n+    // we cannot resolve canonical paths here until later on\n   }\n \n   void visit (AST::TraitImpl &impl_block) override\n@@ -293,12 +367,17 @@ class ResolveTopLevel : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n+\n+    // we cannot resolve canonical paths here until later on\n   }\n \n   void visit (AST::Trait &trait) override\n   {\n-    CanonicalPath path = prefix.append (\n-      CanonicalPath::new_seg (trait.get_node_id (), trait.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (trait.get_node_id (), trait.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, trait.get_node_id (), trait.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -308,7 +387,10 @@ class ResolveTopLevel : public ResolverBase\n       });\n \n     for (auto &item : trait.get_trait_items ())\n-      ResolveTopLevelTraitItems::go (item.get (), path);\n+      ResolveTopLevelTraitItems::go (item.get (), path, cpath);\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     trait.get_node_id (), cpath);\n   }\n \n   void visit (AST::ExternBlock &extern_block) override\n@@ -320,11 +402,14 @@ class ResolveTopLevel : public ResolverBase\n   }\n \n private:\n-  ResolveTopLevel (const CanonicalPath &prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+  ResolveTopLevel (const CanonicalPath &prefix,\n+\t\t   const CanonicalPath &canonical_prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n   {}\n \n   const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "f7bdc9efb4ed4a8b9fb08721f3931b8d31f69f9a", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 66, "deletions": 16, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -250,9 +250,11 @@ class ResolveType : public ResolverBase\n \n public:\n   static NodeId go (AST::Type *type, NodeId parent,\n-\t\t    bool canonicalize_type_with_generics = false)\n+\t\t    bool canonicalize_type_with_generics = false,\n+\t\t    CanonicalPath *canonical_path = nullptr)\n   {\n-    ResolveType resolver (parent, canonicalize_type_with_generics);\n+    ResolveType resolver (parent, canonicalize_type_with_generics,\n+\t\t\t  canonical_path);\n     type->accept_vis (resolver);\n     if (!resolver.ok)\n       rust_error_at (type->get_locus (), \"unresolved type\");\n@@ -285,35 +287,52 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TypePath &path) override\n   {\n-    auto canonical_path\n+    auto rel_canonical_path\n       = ResolveTypeToCanonicalPath::resolve (path,\n \t\t\t\t\t     canonicalize_type_with_generics,\n \t\t\t\t\t     true);\n-    if (canonical_path.is_empty ())\n+    if (rel_canonical_path.is_empty ())\n       {\n \trust_error_at (path.get_locus (),\n \t\t       \"Failed to resolve canonical path for TypePath\");\n \treturn;\n       }\n \n-    ok = !canonical_path.is_empty ();\n+    ok = !rel_canonical_path.is_empty ();\n \n     // lets try and resolve in one go else leave it up to the type resolver to\n     // figure outer\n \n-    if (resolver->get_type_scope ().lookup (canonical_path, &resolved_node))\n+    if (resolver->get_type_scope ().lookup (rel_canonical_path, &resolved_node))\n       {\n \tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (path.get_node_id (),\n \t\t\t\t\t Definition{path.get_node_id (),\n \t\t\t\t\t\t    parent});\n+\n+\tif (canonical_path != nullptr)\n+\t  {\n+\t    const CanonicalPath *cpath = nullptr;\n+\t    bool ok\n+\t      = mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t\t\t resolved_node, &cpath);\n+\t    if (!ok)\n+\t      {\n+\t\t*canonical_path = rel_canonical_path;\n+\t      }\n+\t    else\n+\t      {\n+\t\t*canonical_path = *cpath;\n+\t      }\n+\t  }\n+\n \treturn;\n       }\n \n     // lets resolve as many segments as we can and leave it up to the type\n     // resolver otherwise\n     size_t nprocessed = 0;\n-    canonical_path.iterate ([&] (const CanonicalPath &seg) -> bool {\n+    rel_canonical_path.iterate ([&] (const CanonicalPath &seg) -> bool {\n       resolved_node = UNKNOWN_NODEID;\n \n       if (!resolver->get_type_scope ().lookup (seg, &resolved_node))\n@@ -336,12 +355,22 @@ class ResolveType : public ResolverBase\n     // its ok if this fails since the type resolver sometimes will need to\n     // investigate the bounds of a type for the associated type for example see:\n     // https://github.com/Rust-GCC/gccrs/issues/746\n-    if (nprocessed == canonical_path.size ())\n+    if (nprocessed == rel_canonical_path.size ())\n       {\n \tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (path.get_node_id (),\n \t\t\t\t\t Definition{path.get_node_id (),\n \t\t\t\t\t\t    parent});\n+\n+\tif (canonical_path != nullptr)\n+\t  {\n+\t    const CanonicalPath *cpath = nullptr;\n+\t    bool ok\n+\t      = mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t\t\t resolved_node, &cpath);\n+\t    rust_assert (ok);\n+\t    *canonical_path = *cpath;\n+\t  }\n       }\n   }\n \n@@ -356,28 +385,44 @@ class ResolveType : public ResolverBase\n   void visit (AST::ReferenceType &type) override\n   {\n     type.get_type_referenced ()->accept_vis (*this);\n+\n+    if (canonical_path != nullptr && canonical_path->size () > 0)\n+      {\n+\tstd::string seg = canonical_path->get ();\n+\t*canonical_path\n+\t  = CanonicalPath::new_seg (type.get_node_id (), \"&\" + seg);\n+      }\n   }\n \n   void visit (AST::InferredType &type) override { ok = true; }\n \n   void visit (AST::RawPointerType &type) override\n   {\n     type.get_type_pointed_to ()->accept_vis (*this);\n+\n+    if (canonical_path != nullptr && canonical_path->size () > 0)\n+      {\n+\tstd::string seg = canonical_path->get ();\n+\t*canonical_path\n+\t  = CanonicalPath::new_seg (type.get_node_id (), \"*\" + seg);\n+      }\n   }\n \n   void visit (AST::TraitObjectTypeOneBound &type) override;\n \n   void visit (AST::TraitObjectType &type) override;\n \n private:\n-  ResolveType (NodeId parent, bool canonicalize_type_with_generics)\n+  ResolveType (NodeId parent, bool canonicalize_type_with_generics,\n+\t       CanonicalPath *canonical_path)\n     : ResolverBase (parent),\n       canonicalize_type_with_generics (canonicalize_type_with_generics),\n-      ok (false)\n+      ok (false), canonical_path (canonical_path)\n   {}\n \n   bool canonicalize_type_with_generics;\n   bool ok;\n+  CanonicalPath *canonical_path;\n };\n \n class ResolveTypeBound : public ResolverBase\n@@ -453,16 +498,18 @@ class ResolveGenericParam : public ResolverBase\n \t  }\n       }\n \n-    // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n+    auto seg = CanonicalPath::new_seg (param.get_node_id (),\n+\t\t\t\t       param.get_type_representation ());\n     resolver->get_type_scope ().insert (\n-      CanonicalPath::new_seg (param.get_node_id (),\n-\t\t\t      param.get_type_representation ()),\n-      param.get_node_id (), param.get_locus (), false,\n+      seg, param.get_node_id (), param.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (param.get_locus (),\n \t\t       \"generic param redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     param.get_node_id (), seg);\n   }\n \n private:\n@@ -483,7 +530,10 @@ class ResolveWhereClause : public ResolverBase\n       clause->accept_vis (r);\n   }\n \n-  void visit (AST::LifetimeWhereClauseItem &) override {}\n+  void visit (AST::LifetimeWhereClauseItem &) override\n+  {\n+    // nothing to do\n+  }\n \n   void visit (AST::TypeBoundWhereClauseItem &item) override\n   {\n@@ -499,7 +549,7 @@ class ResolveWhereClause : public ResolverBase\n \n private:\n   ResolveWhereClause (NodeId parent) : ResolverBase (parent) {}\n-}; // namespace Resolver\n+};\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "5e29e25f23061c0e03b62deeeb14a849c162778c", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -313,6 +313,13 @@ NameResolution::Resolve (AST::Crate &crate)\n void\n NameResolution::go (AST::Crate &crate)\n {\n+  // lookup current crate name\n+  std::string crate_name;\n+  bool ok\n+    = mappings->get_crate_name (mappings->get_current_crate (), crate_name);\n+  rust_assert (ok);\n+\n+  // setup the ribs\n   NodeId scope_node_id = crate.get_node_id ();\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n@@ -321,16 +328,24 @@ NameResolution::go (AST::Crate &crate)\n   resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n   resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n-  // first gather the top-level namespace names then we drill down\n+  // get the root segment\n+  CanonicalPath crate_prefix\n+    = CanonicalPath::new_seg (scope_node_id, crate_name);\n+\n+  // first gather the top-level namespace names then we drill down so this\n+  // allows for resolving forward declarations since an impl block might have a\n+  // Self type Foo which is defined after the impl block for example.\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    ResolveTopLevel::go (it->get ());\n+    ResolveTopLevel::go (it->get (), CanonicalPath::create_empty (),\n+\t\t\t crate_prefix);\n \n+  // FIXME remove this\n   if (saw_errors ())\n     return;\n \n   // next we can drill down into the items and their scopes\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    ResolveItem::go (it->get ());\n+    ResolveItem::go (it->get (), CanonicalPath::create_empty (), crate_prefix);\n }\n \n // rust-ast-resolve-expr.h\n@@ -349,17 +364,19 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n   for (auto &s : expr.get_statements ())\n     {\n       if (s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id ());\n+\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n     }\n \n   for (auto &s : expr.get_statements ())\n     {\n       if (!s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id ());\n+\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n     }\n \n   if (expr.has_tail_expr ())\n-    ResolveExpr::go (expr.get_tail_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_tail_expr ().get (), expr.get_node_id ());\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n@@ -371,13 +388,15 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n void\n ResolveStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n {\n-  ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n+  ResolveExpr::go (field.get_value ().get (), field.get_node_id (), prefix,\n+\t\t   canonical_prefix);\n }\n \n void\n ResolveStructExprField::visit (AST::StructExprFieldIndexValue &field)\n {\n-  ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n+  ResolveExpr::go (field.get_value ().get (), field.get_node_id (), prefix,\n+\t\t   canonical_prefix);\n }\n \n void\n@@ -386,7 +405,7 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n   AST::IdentifierExpr expr (field.get_field_name (), {}, field.get_locus ());\n   expr.set_node_id (field.get_node_id ());\n \n-  ResolveExpr::go (&expr, field.get_node_id ());\n+  ResolveExpr::go (&expr, field.get_node_id (), prefix, canonical_prefix);\n }\n \n // rust-ast-resolve-type.h\n@@ -746,7 +765,12 @@ void\n ResolveType::visit (AST::ArrayType &type)\n {\n   type.get_elem_type ()->accept_vis (*this);\n-  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id ());\n+  // FIXME\n+  // the capacity expr can contain block-expr with functions but these should be\n+  // folded via constexpr code\n+  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id (),\n+\t\t   CanonicalPath::create_empty (),\n+\t\t   CanonicalPath::create_empty ());\n }\n \n void\n@@ -771,15 +795,19 @@ ResolveType::visit (AST::TraitObjectType &type)\n // rust-ast-resolve-item.h\n \n void\n-ResolveItem::resolve_impl_item (AST::TraitImplItem *item)\n+ResolveItem::resolve_impl_item (AST::TraitImplItem *item,\n+\t\t\t\tconst CanonicalPath &prefix,\n+\t\t\t\tconst CanonicalPath &canonical_prefix)\n {\n-  ResolveImplItems::go (item);\n+  ResolveImplItems::go (item, prefix, canonical_prefix);\n }\n \n void\n-ResolveItem::resolve_impl_item (AST::InherentImplItem *item)\n+ResolveItem::resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t\tconst CanonicalPath &prefix,\n+\t\t\t\tconst CanonicalPath &canonical_prefix)\n {\n-  ResolveImplItems::go (item);\n+  ResolveImplItems::go (item, prefix, canonical_prefix);\n }\n \n void"}, {"sha": "199b0f98bd895b15c4f6f5d3bc583f7714c2114a", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -39,6 +39,7 @@ class Rib\n \n   ~Rib () {}\n \n+  // this takes the relative paths of items within a compilation unit for lookup\n   void insert_name (\n     const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n     std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n@@ -60,7 +61,6 @@ class Rib\n     reverse_path_mappings.insert (std::pair<NodeId, CanonicalPath> (id, path));\n     decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n     references[id] = {};\n-    mappings->insert_canonical_path (mappings->get_current_crate (), id, path);\n   }\n \n   bool lookup_name (const CanonicalPath &ident, NodeId *id)"}, {"sha": "af547ef59a1c53e9f2aa1628739b41b0a48925c7", "filename": "gcc/testsuite/rust/compile/canonical_paths1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcanonical_paths1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcanonical_paths1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcanonical_paths1.rs?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -0,0 +1,25 @@\n+// { dg-additional-options \"-w -fdump-tree-gimple\" }\n+struct Foo(i32);\n+\n+trait TR {\n+    fn test(&self) -> i32;\n+}\n+\n+mod A {\n+    impl ::Foo {\n+        pub fn test(self) {}\n+        // { dg-final { scan-tree-dump-times {example::A::<impl example::Foo>::test} 2 gimple } }\n+    }\n+\n+    impl ::TR for ::Foo {\n+        fn test(&self) -> i32 {\n+            // { dg-final { scan-tree-dump-times {example::A::<impl example::Foo as example::TR>::test} 1 gimple } }\n+            self.0\n+        }\n+    }\n+}\n+\n+pub fn test() {\n+    let a = Foo(123);\n+    a.test();\n+}"}, {"sha": "2ace8c064d8ba1585707249895912d6cf3eba525", "filename": "gcc/testsuite/rust/compile/torture/mod3.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmod3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmod3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmod3.rs?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -1,25 +1,22 @@\n+// { dg-additional-options \"-w\" }\n mod A {\n-    pub mod B {  // { dg-warning \"unused name\" }\n-        pub mod C { // { dg-warning \"unused name\" }\n+    pub mod B {\n+        pub mod C {\n             pub struct Foo {\n                 pub f: i32,\n             }\n             impl Foo {\n-                pub fn new() -> Self {  // { dg-warning \"unused name\" }\n-                    Foo {\n-                        f: 23i32,\n-                    }\n+                pub fn new() -> Self {\n+                    Foo { f: 23i32 }\n                 }\n             }\n         }\n     }\n }\n \n-fn main() ->i32 {\n+fn main() -> i32 {\n     let a = A::B::C::Foo::new();\n-    let b = A::B::C::Foo {\n-        f: -23i32,\n-    };\n+    let b = A::B::C::Foo { f: -23i32 };\n \n     a.f - b.f\n }"}, {"sha": "7ef577acd09a36e24916b89d14238324d6dd5396", "filename": "gcc/testsuite/rust/compile/traits9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065f205c3171e63b4efee0b9d890782e95a691b/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs?ref=a065f205c3171e63b4efee0b9d890782e95a691b", "patch": "@@ -8,6 +8,6 @@ fn main() {\n     a = Foo(123);\n \n     let b: &dyn Bar = &a;\n-    // { dg-error \"bounds not satisfied for Foo .Bar. is not satisfied\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"bounds not satisfied for Foo .example::Bar. is not satisfied\" \"\" { target *-*-* } .-1 }\n     // { dg-error \"expected\" \"\" { target *-*-* } .-2 }\n }"}]}