{"sha": "bc69f7ffb57a35be61feb20e4a7b4300c8d1de24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM2OWY3ZmZiNTdhMzViZTYxZmViMjBlNGE3YjQzMDBjOGQxZGUyNA==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-05-23T07:27:59Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-05-23T07:27:59Z"}, "message": "re PR middle-end/45098 (Missed induction variable optimization)\n\n2011-05-23  Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/45098\n\t* tree-ssa-loop-niter.c (infer_loop_bounds_from_pointer_arith): New\n\tfunction.\n\t(infer_loop_bounds_from_undefined): Use new function.\n\nFrom-SVN: r174056", "tree": {"sha": "fb512c461f1f61fb543c5013b019ee653fc7d9b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb512c461f1f61fb543c5013b019ee653fc7d9b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc69f7ffb57a35be61feb20e4a7b4300c8d1de24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc69f7ffb57a35be61feb20e4a7b4300c8d1de24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc69f7ffb57a35be61feb20e4a7b4300c8d1de24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc69f7ffb57a35be61feb20e4a7b4300c8d1de24/comments", "author": null, "committer": null, "parents": [{"sha": "fec5d58b1ff0548148eb41ae72757a09d67a876c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec5d58b1ff0548148eb41ae72757a09d67a876c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fec5d58b1ff0548148eb41ae72757a09d67a876c"}], "stats": {"total": 60, "additions": 59, "deletions": 1}, "files": [{"sha": "70709733413e4ef9aa92184aa13135b0cf657084", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc69f7ffb57a35be61feb20e4a7b4300c8d1de24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc69f7ffb57a35be61feb20e4a7b4300c8d1de24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc69f7ffb57a35be61feb20e4a7b4300c8d1de24", "patch": "@@ -1,3 +1,10 @@\n+2011-05-23  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/45098\n+\t* tree-ssa-loop-niter.c (infer_loop_bounds_from_pointer_arith): New\n+\tfunction.\n+\t(infer_loop_bounds_from_undefined): Use new function.\n+\n 2011-05-22  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips.h (SUBTARGET_ASM_OPTIMIZING_SPEC): Delete."}, {"sha": "230593ad264b99d67680a044b93e861faf183523", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc69f7ffb57a35be61feb20e4a7b4300c8d1de24/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc69f7ffb57a35be61feb20e4a7b4300c8d1de24/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=bc69f7ffb57a35be61feb20e4a7b4300c8d1de24", "patch": "@@ -2831,6 +2831,54 @@ infer_loop_bounds_from_array (struct loop *loop, gimple stmt, bool reliable)\n     }\n }\n \n+/* Determine information about number of iterations of a LOOP from the fact\n+   that pointer arithmetics in STMT does not overflow.  */\n+\n+static void\n+infer_loop_bounds_from_pointer_arith (struct loop *loop, gimple stmt)\n+{\n+  tree def, base, step, scev, type, low, high;\n+  tree var, ptr;\n+\n+  if (!is_gimple_assign (stmt)\n+      || gimple_assign_rhs_code (stmt) != POINTER_PLUS_EXPR)\n+    return;\n+\n+  def = gimple_assign_lhs (stmt);\n+  if (TREE_CODE (def) != SSA_NAME)\n+    return;\n+\n+  type = TREE_TYPE (def);\n+  if (!nowrap_type_p (type))\n+    return;\n+\n+  ptr = gimple_assign_rhs1 (stmt);\n+  if (!expr_invariant_in_loop_p (loop, ptr))\n+    return;\n+\n+  var = gimple_assign_rhs2 (stmt);\n+  if (TYPE_PRECISION (type) != TYPE_PRECISION (TREE_TYPE (var)))\n+    return;\n+\n+  scev = instantiate_parameters (loop, analyze_scalar_evolution (loop, def));\n+  if (chrec_contains_undetermined (scev))\n+    return;\n+\n+  base = initial_condition_in_loop_num (scev, loop->num);\n+  step = evolution_part_in_loop_num (scev, loop->num);\n+\n+  if (!base || !step\n+      || TREE_CODE (step) != INTEGER_CST\n+      || tree_contains_chrecs (base, NULL)\n+      || chrec_contains_symbols_defined_in_loop (base, loop->num))\n+    return;\n+\n+  low = lower_bound_in_type (type, type);\n+  high = upper_bound_in_type (type, type);\n+\n+  record_nonwrapping_iv (loop, base, step, stmt, low, high, false, true);\n+}\n+\n /* Determine information about number of iterations of a LOOP from the fact\n    that signed arithmetics in STMT does not overflow.  */\n \n@@ -2907,7 +2955,10 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n \t  infer_loop_bounds_from_array (loop, stmt, reliable);\n \n \t  if (reliable)\n-\t    infer_loop_bounds_from_signedness (loop, stmt);\n+            {\n+              infer_loop_bounds_from_signedness (loop, stmt);\n+              infer_loop_bounds_from_pointer_arith (loop, stmt);\n+            }\n   \t}\n \n     }"}]}