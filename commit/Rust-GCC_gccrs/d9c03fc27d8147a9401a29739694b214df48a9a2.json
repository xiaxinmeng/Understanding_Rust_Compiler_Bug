{"sha": "d9c03fc27d8147a9401a29739694b214df48a9a2", "node_id": "C_kwDOANBUbNoAKGQ5YzAzZmMyN2Q4MTQ3YTk0MDFhMjk3Mzk2OTRiMjE0ZGY0OGE5YTI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-01T09:50:41Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-01T09:50:41Z"}, "message": "phiopt: Improve value_replacement [PR104645]\n\nThe following patch fixes the P1 regression by reusing existing\nvalue_replacement code.  That function already has code to\nhandle simple preparation statements (casts, and +,&,|,^ binary\nassignments) before a final binary assignment (which can be\nmuch wider range of ops).  When we have e.g.\n      if (y_3(D) == 0)\n        goto <bb 4>;\n      else\n        goto <bb 3>;\n     <bb 3>:\n      y_4 = y_3(D) & 31;\n      _1 = (int) y_4;\n      _6 = x_5(D) r<< _1;\n     <bb 4>:\n      # _2 = PHI <x_5(D)(2), _6(3)>\nthe preparation statements y_4 = y_3(D) & 31; and\n_1 = (int) y_4; are handled by constant evaluation, passing through\ny_3(D) = 0 initially and propagating that through the assignments\nwith checking that UB isn't invoked.  But the final\n_6 = x_5(D) r<< _1; assign is handled differently, either through\nneutral_element_p or absorbing_element_p.\nIn the first function below we now have:\n  <bb 2> [local count: 1073741824]:\n  if (i_2(D) != 0)\n    goto <bb 3>; [50.00%]\n  else\n    goto <bb 4>; [50.00%]\n\n  <bb 3> [local count: 536870913]:\n  _3 = i_2(D) & 1;\n  iftmp.0_4 = (int) _3;\n\n  <bb 4> [local count: 1073741824]:\n  # iftmp.0_1 = PHI <iftmp.0_4(3), 0(2)>\nwhere in GCC 11 we had:\n  <bb 2> :\n  if (i_3(D) != 0)\n    goto <bb 3>; [INV]\n  else\n    goto <bb 4>; [INV]\n\n  <bb 3> :\n  i.1_1 = (int) i_3(D);\n  iftmp.0_5 = i.1_1 & 1;\n\n  <bb 4> :\n  # iftmp.0_2 = PHI <iftmp.0_5(3), 0(2)>\nCurrent value_replacement can handle the latter as the last\nstmt of middle_bb is a binary op that in this case satisfies\nabsorbing_element_p.\nBut the former we can't handle, as the last stmt in middle_bb\nis a cast.\n\nThe patch makes it work in that case by pretending all of middle_bb\nare the preparation statements and there is no binary assign at the\nend, so everything is handled through the constant evaluation.\nWe simply set at the start of middle_bb the lhs of comparison\nvirtually to the rhs, propagate it through and at the end\nsee if virtually the arg0 of the PHI is equal to arg1 of it.\n\nFor GCC 13, I think we just should throw away all the neutral/absorbing\nelement stuff and do the constant evaluation of the whole middle_bb\nand handle that way all the ops we currently handle in neutral/absorbing\nelement.\n\n2022-04-01  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/104645\n\t* tree-ssa-phiopt.cc (value_replacement): If assign has\n\tCONVERT_EXPR_CODE_P rhs_code, treat it like a preparation\n\tstatement with constant evaluation.\n\n\t* gcc.dg/tree-ssa/pr104645.c: New test.", "tree": {"sha": "4435a0ab4b63d63b41805e3bb5a6ef6f07a785e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4435a0ab4b63d63b41805e3bb5a6ef6f07a785e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9c03fc27d8147a9401a29739694b214df48a9a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c03fc27d8147a9401a29739694b214df48a9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9c03fc27d8147a9401a29739694b214df48a9a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c03fc27d8147a9401a29739694b214df48a9a2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0ce885851dfd926c0cfe6f23a2debc87ea2bb9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ce885851dfd926c0cfe6f23a2debc87ea2bb9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ce885851dfd926c0cfe6f23a2debc87ea2bb9d"}], "stats": {"total": 91, "additions": 77, "deletions": 14}, "files": [{"sha": "83c1dd451f19eead5f6c0004cd97fcceee7f9383", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr104645.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c03fc27d8147a9401a29739694b214df48a9a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104645.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c03fc27d8147a9401a29739694b214df48a9a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104645.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr104645.c?ref=d9c03fc27d8147a9401a29739694b214df48a9a2", "patch": "@@ -0,0 +1,28 @@\n+/* PR tree-optimization/104645 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" = PHI <\" \"optimized\" } } */\n+\n+int\n+foo (unsigned i)\n+{\n+  return i ? i % 2 : 0;\n+}\n+\n+int\n+bar (unsigned i)\n+{\n+  int b = 0;\n+  if (i)\n+    {\n+      unsigned a = i & 1;\n+      b = a;\n+    }\n+  return b;\n+}\n+\n+int\n+baz (unsigned i)\n+{\n+  return i ? i + 4 : 4;\n+}"}, {"sha": "4a0c9dd656d6065cb26d9f2ff4901cf185fe5281", "filename": "gcc/tree-ssa-phiopt.cc", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c03fc27d8147a9401a29739694b214df48a9a2/gcc%2Ftree-ssa-phiopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c03fc27d8147a9401a29739694b214df48a9a2/gcc%2Ftree-ssa-phiopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.cc?ref=d9c03fc27d8147a9401a29739694b214df48a9a2", "patch": "@@ -1395,11 +1395,22 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   gimple *assign = gsi_stmt (gsi);\n   if (!is_gimple_assign (assign)\n-      || gimple_assign_rhs_class (assign) != GIMPLE_BINARY_RHS\n       || (!INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n \t  && !POINTER_TYPE_P (TREE_TYPE (arg0))))\n     return 0;\n \n+  if (gimple_assign_rhs_class (assign) != GIMPLE_BINARY_RHS)\n+    {\n+      /* If last stmt of the middle_bb is a conversion, handle it like\n+\t a preparation statement through constant evaluation with\n+\t checking for UB.  */\n+      enum tree_code sc = gimple_assign_rhs_code (assign);\n+      if (CONVERT_EXPR_CODE_P (sc))\n+\tassign = NULL;\n+      else\n+\treturn 0;\n+    }\n+\n   /* Punt if there are (degenerate) PHIs in middle_bb, there should not be.  */\n   if (!gimple_seq_empty_p (phi_nodes (middle_bb)))\n     return 0;\n@@ -1430,7 +1441,8 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n   int prep_cnt;\n   for (prep_cnt = 0; ; prep_cnt++)\n     {\n-      gsi_prev_nondebug (&gsi);\n+      if (prep_cnt || assign)\n+\tgsi_prev_nondebug (&gsi);\n       if (gsi_end_p (gsi))\n \tbreak;\n \n@@ -1450,7 +1462,8 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  || !INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t  || !INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n \t  || !single_imm_use (lhs, &use_p, &use_stmt)\n-\t  || use_stmt != (prep_cnt ? prep_stmt[prep_cnt - 1] : assign))\n+\t  || ((prep_cnt || assign)\n+\t      && use_stmt != (prep_cnt ? prep_stmt[prep_cnt - 1] : assign)))\n \treturn 0;\n       switch (gimple_assign_rhs_code (g))\n \t{\n@@ -1483,10 +1496,6 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \t >= 3 * estimate_num_insns (cond, &eni_time_weights))\n     return 0;\n \n-  tree lhs = gimple_assign_lhs (assign);\n-  tree rhs1 = gimple_assign_rhs1 (assign);\n-  tree rhs2 = gimple_assign_rhs2 (assign);\n-  enum tree_code code_def = gimple_assign_rhs_code (assign);\n   tree cond_lhs = gimple_cond_lhs (cond);\n   tree cond_rhs = gimple_cond_rhs (cond);\n \n@@ -1516,16 +1525,39 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \treturn 0;\n     }\n \n+  tree lhs, rhs1, rhs2;\n+  enum tree_code code_def;\n+  if (assign)\n+    {\n+      lhs = gimple_assign_lhs (assign);\n+      rhs1 = gimple_assign_rhs1 (assign);\n+      rhs2 = gimple_assign_rhs2 (assign);\n+      code_def = gimple_assign_rhs_code (assign);\n+    }\n+  else\n+    {\n+      gcc_assert (prep_cnt > 0);\n+      lhs = cond_lhs;\n+      rhs1 = NULL_TREE;\n+      rhs2 = NULL_TREE;\n+      code_def = ERROR_MARK;\n+    }\n+\n   if (((code == NE_EXPR && e1 == false_edge)\n \t|| (code == EQ_EXPR && e1 == true_edge))\n       && arg0 == lhs\n-      && ((arg1 == rhs1\n-\t   && operand_equal_for_phi_arg_p (rhs2, cond_lhs)\n-\t   && neutral_element_p (code_def, cond_rhs, true))\n-\t  || (arg1 == rhs2\n+      && ((assign == NULL\n+\t   && operand_equal_for_phi_arg_p (arg1, cond_rhs))\n+\t  || (assign\n+\t      && arg1 == rhs1\n+\t      && operand_equal_for_phi_arg_p (rhs2, cond_lhs)\n+\t      && neutral_element_p (code_def, cond_rhs, true))\n+\t  || (assign\n+\t      && arg1 == rhs2\n \t      && operand_equal_for_phi_arg_p (rhs1, cond_lhs)\n \t      && neutral_element_p (code_def, cond_rhs, false))\n-\t  || (operand_equal_for_phi_arg_p (arg1, cond_rhs)\n+\t  || (assign\n+\t      && operand_equal_for_phi_arg_p (arg1, cond_rhs)\n \t      && ((operand_equal_for_phi_arg_p (rhs2, cond_lhs)\n \t\t   && absorbing_element_p (code_def, cond_rhs, true, rhs2))\n \t\t  || (operand_equal_for_phi_arg_p (rhs1, cond_lhs)\n@@ -1555,8 +1587,11 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  gsi_from = gsi_for_stmt (prep_stmt[i]);\n \t  gsi_move_before (&gsi_from, &gsi);\n \t}\n-      gsi_from = gsi_for_stmt (assign);\n-      gsi_move_before (&gsi_from, &gsi);\n+      if (assign)\n+\t{\n+\t  gsi_from = gsi_for_stmt (assign);\n+\t  gsi_move_before (&gsi_from, &gsi);\n+\t}\n       replace_phi_edge_with_variable (cond_bb, e1, phi, lhs);\n       return 2;\n     }"}]}