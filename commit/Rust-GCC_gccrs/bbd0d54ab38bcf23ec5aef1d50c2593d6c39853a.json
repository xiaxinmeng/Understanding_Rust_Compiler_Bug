{"sha": "bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJkMGQ1NGFiMzhiY2YyM2VjNWFlZjFkNTBjMjU5M2Q2YzM5ODUzYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-08-24T04:16:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-08-24T04:16:06Z"}, "message": "exception.cc (__cplus_type_matcher): Call __throw_type_match_rtti_2.\n\n\t* exception.cc (__cplus_type_matcher): Call __throw_type_match_rtti_2.\n\tReturn arbitrary pointer or NULL.\n\t(check_eh_spec): Call __throw_type_match_rtti_2.\n\t* tinfo.h (*::dcast): Return int.  Add valp parm.\n\t* tinfo.cc (*::dcast): Likewise.  Adjust to allow for null pointers.\n\t* tinfo2.cc (__throw_type_match_rtti_2): Likewise.\n\t(__throw_type_match_rtti): Now just a wrapper.\n\n\t* except.c: Lose CatchMatch, FirstExceptionMatch, and Unwind.\n\t(init_exception_processing): Don't initialize them.\n\nFrom-SVN: r28811", "tree": {"sha": "c097dc69150c566739513cb37b500b1e01cdb7b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c097dc69150c566739513cb37b500b1e01cdb7b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/comments", "author": null, "committer": null, "parents": [{"sha": "657ac7664ccb23e3d8c45ca4932a6226fef076de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/657ac7664ccb23e3d8c45ca4932a6226fef076de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/657ac7664ccb23e3d8c45ca4932a6226fef076de"}], "stats": {"total": 256, "additions": 131, "deletions": 125}, "files": [{"sha": "77deef6d25bfc3f1e921195395d6b35496cd4862", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "patch": "@@ -1,3 +1,16 @@\n+1999-08-23  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* exception.cc (__cplus_type_matcher): Call __throw_type_match_rtti_2.\n+\tReturn arbitrary pointer or NULL.\n+\t(check_eh_spec): Call __throw_type_match_rtti_2.\n+\t* tinfo.h (*::dcast): Return int.  Add valp parm.\n+\t* tinfo.cc (*::dcast): Likewise.  Adjust to allow for null pointers.\n+\t* tinfo2.cc (__throw_type_match_rtti_2): Likewise.\n+\t(__throw_type_match_rtti): Now just a wrapper.\n+\n+\t* except.c: Lose CatchMatch, FirstExceptionMatch, and Unwind.\n+\t(init_exception_processing): Don't initialize them.\n+\n 1999-08-23  Paul Burchard <burchard@pobox.com>\n \n \t* decl.c (check_default_argument): Fix typo."}, {"sha": "100ff2c7b88e8404a10485f167e0257748de3c7b", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "patch": "@@ -155,25 +155,12 @@ asm (TEXT_SECTION_ASM_OP);\n /* local globals for function calls\n    ====================================================================== */\n \n-/* Used to cache \"terminate\" and \"__throw_type_match*\".  */\n-static tree Terminate, CatchMatch;\n-\n-/* Used to cache __find_first_exception_table_match for throw.  */\n-static tree FirstExceptionMatch;\n-\n-/* Used to cache a call to __unwind_function.  */\n-static tree Unwind;\n+static tree Terminate;\n \n /* ====================================================================== */\n \n-\n-/* ========================================================================= */\n-\n /* sets up all the global eh stuff that needs to be initialized at the\n-   start of compilation.\n-\n-   This includes:\n-\t\t- Setting up all the function call trees.  */\n+   start of compilation.  */\n \n void\n init_exception_processing ()\n@@ -189,36 +176,9 @@ init_exception_processing ()\n   if (flag_honor_std)\n     pop_namespace ();\n \n-  push_lang_context (lang_name_c);\n-\n   set_exception_lang_code (EH_LANG_C_plus_plus);\n   set_exception_version_code (1);\n \n-  CatchMatch\n-    = builtin_function (flag_rtti\n-\t\t\t? \"__throw_type_match_rtti\"\n-\t\t\t: \"__throw_type_match\",\n-\t\t\tbuild_function_type (ptr_type_node,\n-\t\t\t\t\t     tree_cons (NULL_TREE, const_ptr_type_node,\n-\t\t\t\t\t\t\ttree_cons (NULL_TREE, const_ptr_type_node,\n-\t\t\t\t\t\t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t\t\t\t      void_list_node)))),\n-\t\t\tNOT_BUILT_IN, NULL_PTR);\n-  FirstExceptionMatch\n-    = builtin_function (\"__find_first_exception_table_match\",\n-\t\t\tbuild_function_type (ptr_type_node,\n-\t\t\t\t\t     tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t\tvoid_list_node)),\n-\t\t\tNOT_BUILT_IN, NULL_PTR);\n-  Unwind\n-    = builtin_function (\"__unwind_function\",\n-\t\t\tbuild_function_type (void_type_node,\n-\t\t\t\t\t     tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t\tvoid_list_node)),\n-\t\t\tNOT_BUILT_IN, NULL_PTR);\n-\n-  pop_lang_context ();\n-\n   /* If we use setjmp/longjmp EH, arrange for all cleanup actions to\n      be protected with __terminate.  */\n   protect_cleanup_actions_with_terminate = 1;"}, {"sha": "efc0b1fe83c315ef924906cbe67c718f47aca0e7", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "patch": "@@ -165,31 +165,34 @@ __eh_free (void *p)\n   free (p);\n }\n \n+extern \"C\" int __throw_type_match_rtti_2 (const void *, const void *,\n+\t\t\t\t\t void *, void **);\n+\n extern \"C\" void *\n __cplus_type_matcher (__eh_info *info_, void *match_info,\n-                                 exception_descriptor *exception_table)\n+\t\t      exception_descriptor *exception_table)\n {\n   cp_eh_info *info = (cp_eh_info *)info_;\n-  void *ret;\n \n   /* No exception table implies the old style mechanism, so don't check. */\n   if (exception_table != NULL \n       && exception_table->lang.language != EH_LANG_C_plus_plus)\n     return NULL;\n \n   if (match_info == CATCH_ALL_TYPE)\n-    return info->value;\n+    return (void *)1;\n \n   /* we don't worry about version info yet, there is only one version! */\n   \n   void *match_type = ((void *(*)())match_info) ();\n-  ret = __throw_type_match_rtti (match_type, info->type, info->original_value);\n-  /* change value of exception */\n-  if (ret)\n-    info->value = ret;\n-  return ret;\n-}\n \n+  if (__throw_type_match_rtti_2 (match_type, info->type,\n+\t\t\t\t info->original_value, &info->value))\n+    // Arbitrary non-null pointer.\n+    return (void *)1;\n+  else\n+    return NULL;\n+}\n \n /* Compiler hook to push a new exception onto the stack.\n    Used by expand_throw().  */\n@@ -278,10 +281,11 @@ extern \"C\" void\n __check_eh_spec (int n, const void **spec)\n {\n   cp_eh_info *p = CP_EH_INFO;\n+  void *d;\n \n   for (int i = 0; i < n; ++i)\n     {\n-      if (__throw_type_match_rtti (spec[i], p->type, p->value))\n+      if (__throw_type_match_rtti_2 (spec[i], p->type, p->value, &d))\n \tthrow;\n     }\n \n@@ -297,15 +301,15 @@ __check_eh_spec (int n, const void **spec)\n \t  p = __exception_info;\n \t  for (int i = 0; i < n; ++i)\n \t    {\n-\t      if (__throw_type_match_rtti (spec[i], p->type, p->value))\n+\t      if (__throw_type_match_rtti_2 (spec[i], p->type, p->value, &d))\n \t\tthrow;\n \t    }\n \t}\n \n       const std::type_info &bad_exc = typeid (std::bad_exception);\n       for (int i = 0; i < n; ++i)\n \t{\n-\t  if (__throw_type_match_rtti (spec[i], &bad_exc, p->value))\n+\t  if (__throw_type_match_rtti_2 (spec[i], &bad_exc, p->value, &d))\n \t    throw std::bad_exception ();\n \t}\n "}, {"sha": "fe22e8de0745c0d6e3b9f0ffc186f159845a5036", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 56, "deletions": 29, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "patch": "@@ -1,5 +1,5 @@\n // Methods for type_info for -*- C++ -*- Run Time Type Identification.\n-// Copyright (C) 1994, 1996, 1998 Free Software Foundation\n+// Copyright (C) 1994, 1996, 1998, 1999 Free Software Foundation\n \n // This file is part of GNU CC.\n \n@@ -63,43 +63,66 @@ __rtti_user (void *addr, const char *name)\n { new (addr) __user_type_info (name); }\n \n // dynamic_cast helper methods.\n-// Returns a pointer to the desired sub-object or 0.\n+// Returns 1 if the cast succeeds, 0 otherwise.  Stores the adjusted value\n+// in VALP.\n \n-void * __user_type_info::\n-dcast (const type_info& to, int, void *addr, const type_info *, void *) const\n-{ return (*this == to) ? addr : 0; }\n+int __user_type_info::\n+dcast (const type_info& to, int, void *addr, void **valp,\n+       const type_info *, void *) const\n+{\n+  *valp = addr;\n+  return (*this == to);\n+}\n \n-void * __si_type_info::\n-dcast (const type_info& to, int require_public, void *addr,\n+int __si_type_info::\n+dcast (const type_info& to, int require_public, void *addr, void **valp,\n        const type_info *sub, void *subptr) const\n {\n   if (*this == to)\n-    return addr;\n-  return base.dcast (to, require_public, addr, sub, subptr);\n+    {\n+      *valp = addr;\n+      return 1;\n+    }\n+  return base.dcast (to, require_public, addr, valp, sub, subptr);\n }\n \n-void* __class_type_info::\n-dcast (const type_info& desired, int is_public, void *objptr,\n+int __class_type_info::\n+dcast (const type_info& desired, int is_public, void *objptr, void **valp,\n        const type_info *sub, void *subptr) const\n {\n+  *valp = objptr;\n+\n   if (*this == desired)\n-    return objptr;\n+    return 1;\n+\n+  int match_found = 0;\n+  void *match = 0;\n \n-  void *match_found = 0;\n   for (size_t i = 0; i < n_bases; i++)\n     {\n       if (is_public && base_list[i].access != PUBLIC)\n \tcontinue;\n \n-      void *p = (char *)objptr + base_list[i].offset;\n-      if (base_list[i].is_virtual)\n-\tp = *(void **)p;\n-      p = base_list[i].base->dcast (desired, is_public, p, sub, subptr);\n-      if (p)\n+      void *p;\n+\n+      if (objptr)\n \t{\n-\t  if (match_found == 0)\n-\t    match_found = p;\n-\t  else if (match_found != p)\n+\t  p = (char *)objptr + base_list[i].offset;\n+\t  if (base_list[i].is_virtual)\n+\t    p = *(void **)p;\n+\t}\n+      else\n+\t/* Preserve null pointer.  */\n+\tp = objptr;\n+\n+      if (base_list[i].base->dcast (desired, is_public, p, &p, sub, subptr))\n+\t{\n+\t  if (! match_found)\n+\t    {\n+\t      match_found = 1;\n+\t      match = p;\n+\t    }\n+\t  else if (match != p)\n \t    {\n \t      if (sub)\n \t\t{\n@@ -109,26 +132,30 @@ dcast (const type_info& desired, int is_public, void *objptr,\n \t\t  const __user_type_info &d =\n \t\t    static_cast <const __user_type_info &> (desired);\n \n-\t\t  void *os = d.dcast (*sub, 1, match_found);\n-\t\t  void *ns = d.dcast (*sub, 1, p);\n+\t\t  void *os;\n+\t\t  d.dcast (*sub, 1, match, &os);\n+\t\t  void *ns;\n+\t\t  d.dcast (*sub, 1, p, &ns);\n \n \t\t  if (os == ns)\n-\t\t    /* ambiguous -- subptr is a virtual base */;\n+\t\t    // Both have the same subobject, so we can't disambiguate;\n+\t\t    // i.e. subptr is a virtual base.\n+\t\t    return 0;\n \t\t  else if (os == subptr)\n \t\t    continue;\n \t\t  else if (ns == subptr)\n \t\t    {\n-\t\t      match_found = p;\n+\t\t      match = p;\n \t\t      continue;\n \t\t    }\n \t\t}\n-\n-\t      // base found at two different pointers,\n-\t      // conversion is not unique\n-\t      return 0;\n+\t      else\n+\t\t// We're not downcasting, so we can't disambiguate.\n+\t\treturn 0;\n \t    }\n \t}\n     }\n \n+  *valp = match;\n   return match_found;\n }"}, {"sha": "ffca9c35cf16940173391ef664418445bb7cebbc", "filename": "gcc/cp/tinfo.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.h?ref=bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "patch": "@@ -1,5 +1,5 @@\n // RTTI support internals for -*- C++ -*-\n-// Copyright (C) 1994, 1995, 1996, 1998 Free Software Foundation\n+// Copyright (C) 1994, 1995, 1996, 1998, 1999 Free Software Foundation\n \n #include \"typeinfo\"\n \n@@ -12,8 +12,8 @@ struct __user_type_info : public std::type_info {\n \n   // If our type can be converted to the desired type, \n   // return the pointer, adjusted accordingly; else return 0.\n-  virtual void* dcast (const type_info &, int, void *,\n-\t\t       const type_info * = 0, void * = 0) const;\n+  virtual int dcast (const type_info &, int, void *, void **,\n+\t\t     const type_info * = 0, void * = 0) const;\n };\n \n // type_info for a class with one public, nonvirtual base class.\n@@ -25,8 +25,8 @@ class __si_type_info : public __user_type_info {\n   __si_type_info (const char *n, const __user_type_info &b)\n     : __user_type_info (n), base (b) { }\n \n-  virtual void *dcast (const type_info &, int, void *,\n-\t\t       const type_info * = 0, void * = 0) const;\n+  virtual int dcast (const type_info &, int, void *, void **,\n+\t\t     const type_info * = 0, void * = 0) const;\n };\n \n // type_info for a general class.\n@@ -50,6 +50,6 @@ struct __class_type_info : public __user_type_info {\n     : __user_type_info (name), base_list (bl), n_bases (bn) {}\n \n   // This is a little complex.\n-  virtual void* dcast (const type_info &, int, void *,\n-\t\t       const type_info * = 0, void * = 0) const;\n+  virtual int dcast (const type_info &, int, void *, void **,\n+\t\t     const type_info * = 0, void * = 0) const;\n };"}, {"sha": "877872f4e70a6a450e11cbabe81115c97e97a1af", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=bbd0d54ab38bcf23ec5aef1d50c2593d6c39853a", "patch": "@@ -1,5 +1,5 @@\n // Methods for type_info for -*- C++ -*- Run Time Type Identification.\n-// Copyright (C) 1994, 96-97, 1998 Free Software Foundation\n+// Copyright (C) 1994, 96-97, 1998, 1999 Free Software Foundation\n \n // This file is part of GNU CC.\n \n@@ -93,28 +93,23 @@ struct __array_type_info : public type_info {\n /* Low level match routine used by compiler to match types of catch\n    variables and thrown objects.  */\n \n-extern \"C\" void*\n-__throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n-\t\t\t void *objptr)\n+extern \"C\" int\n+__throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n+\t\t\t void *objptr, void **valp)\n {\n   const type_info &catch_type = *(const type_info *)catch_type_r;\n   const type_info &throw_type = *(const type_info *)throw_type_r;\n-  \n-  if (catch_type == throw_type)\n-    return objptr;\n-  \n-#if 0\n-  printf (\"We want to match a %s against a %s!\\n\",\n-\t  throw_type.name (), catch_type.name ());\n-#endif\n \n-  void *new_objptr = 0;\n+  *valp = objptr;\n \n+  if (catch_type == throw_type)\n+    return 1;\n+  \n   if (const __user_type_info *p\n       = dynamic_cast <const __user_type_info *> (&throw_type))\n     {\n       /* The 1 skips conversions to private bases. */\n-      new_objptr = p->dcast (catch_type, 1, objptr);\n+      return p->dcast (catch_type, 1, objptr, valp);\n     }\n   else if (const __pointer_type_info *fr =\n \t   dynamic_cast <const __pointer_type_info *> (&throw_type))\n@@ -123,7 +118,7 @@ __throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n \t   dynamic_cast <const __pointer_type_info *> (&catch_type);\n \n       if (! to)\n-\tgoto fail;\n+\treturn 0;\n \n       const type_info *subfr = &fr->type, *subto = &to->type;\n       __attr_type_info::cv cvfrom, cvto;\n@@ -150,18 +145,18 @@ __throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n \t   > (cvto & __attr_type_info::CONST))\n \t  || ((cvfrom & __attr_type_info::VOLATILE)\n \t      > (cvto & __attr_type_info::VOLATILE)))\n-\tgoto fail;\n+\treturn 0;\n \n       if (*subto == *subfr)\n-\tnew_objptr = objptr;\n+\treturn 1;\n       else if (*subto == typeid (void)\n \t       && dynamic_cast <const __func_type_info *> (subfr) == 0)\n-\tnew_objptr = objptr;\n+\treturn 1;\n       else if (const __user_type_info *p\n \t       = dynamic_cast <const __user_type_info *> (subfr))\n \t{\n \t  /* The 1 skips conversions to private bases. */\n-\t  new_objptr = p->dcast (*subto, 1, objptr);\n+\t  return p->dcast (*subto, 1, objptr, valp);\n \t}\n       else if (const __pointer_type_info *pfr\n \t       = dynamic_cast <const __pointer_type_info *> (subfr))\n@@ -172,7 +167,7 @@ __throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n \t    = dynamic_cast <const __pointer_type_info *> (subto);\n \n \t  if (! pto)\n-\t    goto fail;\n+\t    return 0;\n \t    \n \t  bool constp = (cvto & __attr_type_info::CONST);\n \t  for (subto = &pto->type, subfr = &pfr->type; ;\n@@ -200,38 +195,42 @@ __throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n \t\t   > (cvto & __attr_type_info::CONST))\n \t\t  || ((cvfrom & __attr_type_info::VOLATILE)\n \t\t      > (cvto & __attr_type_info::VOLATILE)))\n-\t\tgoto fail;\n+\t\treturn 0;\n \n \t      if (! constp\n \t\t  && (((cvfrom & __attr_type_info::CONST)\n \t\t       < (cvto & __attr_type_info::CONST))\n \t\t      || ((cvfrom & __attr_type_info::VOLATILE)\n \t\t\t  < (cvto & __attr_type_info::VOLATILE))))\n-\t\tgoto fail;\n+\t\treturn 0;\n \n \t      if (*subto == *subfr)\n-\t\t{\n-\t\t  new_objptr = objptr;\n-\t\t  break;\n-\t\t}\n+\t\treturn 1;\n \n \t      pto = dynamic_cast <const __pointer_type_info *> (subto);\n \t      pfr = dynamic_cast <const __pointer_type_info *> (subfr);\n \t      if (! pto || ! pfr)\n-\t\tgoto fail;\t\t\n+\t\treturn 0;\t\t\n \n \t      if (! (cvto & __attr_type_info::CONST))\n \t\tconstp = false;\n \t    }\n \t}\n     }\n- fail:\n \n-#if 0\n-  if (new_objptr)\n-    printf (\"It converts, delta is %d\\n\", new_objptr-objptr);\n-#endif\n-  return new_objptr;\n+  return 0;\n+}\n+\n+/* Backward compatibility wrapper.  */\n+\n+extern \"C\" void*\n+__throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n+\t\t\t void *objptr)\n+{\n+  void *ret;\n+  if (__throw_type_match_rtti_2 (catch_type_r, throw_type_r, objptr, &ret))\n+    return ret;\n+  return NULL;\n }\n \n /* Called from __cp_pop_exception.  Is P the type_info node for a pointer\n@@ -278,8 +277,11 @@ __dynamic_cast (const type_info& (*from)(void), const type_info& (*to)(void),\n \t\tint require_public, void *address,\n \t\tconst type_info & (*sub)(void), void *subptr)\n {\n-  return static_cast <const __user_type_info &> (from ()).dcast\n-    (to (), require_public, address, &(sub ()), subptr);\n+  void *ret;\n+  if (static_cast <const __user_type_info &> (from ()).dcast\n+      (to (), require_public, address, &ret, &(sub ()), subptr))\n+    return ret;\n+  return 0;\n }\n \n // type_info nodes and functions for the builtin types.  The mangling here"}]}