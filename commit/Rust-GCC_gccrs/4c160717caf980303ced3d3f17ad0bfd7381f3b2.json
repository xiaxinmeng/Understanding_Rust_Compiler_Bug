{"sha": "4c160717caf980303ced3d3f17ad0bfd7381f3b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMxNjA3MTdjYWY5ODAzMDNjZWQzZDNmMTdhZDBiZmQ3MzgxZjNiMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-09-20T15:12:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-09-20T15:12:54Z"}, "message": "fold-const.c (hashtab.h): Include.\n\n\t* fold-const.c (hashtab.h): Include.\n\t(int_const_binop): Remove FORSIZE arg and compute from type; all\n\tcallers changed.\n\tCall size_int_type_wide for all single-word constants.\n\t(size_htab_hash, size_htab_eq): New functions.\n\t(size_int_type_wide): Rework to use hash table.\n\t* ggc-common.c (hashtab.h): Include.\n\t(struct d_htab_root): New struct.\n\t(d_htab_roots): New variable.\n\t(ggc_add_deletable_htab, ggc_htab_delete): New functions\n\t(ggc_mark_roots): Handle deletable htabs.\n\t* ggc-page.c (ggc_marked_p): New function.\n\t* ggc-simple.c (ggc_marked_p): Likewise.\n\t* ggc.h: Reformatting throughout.\n\t(ggc_marked_p, ggc_add_deletable_htab): New declarations.\n\t* tree.c (init_obstacks): Make type_hash_table a deletable root.\n\t(type_hash_add): Allocate struct type_hash from GC memory.\n\t(mark_hash_entry, mark_type_hash): Deleted.\n\t(type_hash_marked_p, type_hash_mark): New functions.\n\t* Makefile.in (ggc-common.o, fold-const.o): Include hashtab.h.\n\nFrom-SVN: r45710", "tree": {"sha": "9f82325d87e923ce9de88e1e1f44c7643f7d9c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f82325d87e923ce9de88e1e1f44c7643f7d9c53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c160717caf980303ced3d3f17ad0bfd7381f3b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c160717caf980303ced3d3f17ad0bfd7381f3b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c160717caf980303ced3d3f17ad0bfd7381f3b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c160717caf980303ced3d3f17ad0bfd7381f3b2/comments", "author": null, "committer": null, "parents": [{"sha": "c762ab6ebb62bc1e1d93b6d81b83737e39df2c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c762ab6ebb62bc1e1d93b6d81b83737e39df2c01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c762ab6ebb62bc1e1d93b6d81b83737e39df2c01"}], "stats": {"total": 421, "additions": 314, "deletions": 107}, "files": [{"sha": "b8e3ab8e7aac9e6638cb80bd252817b0b3ec0a06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c160717caf980303ced3d3f17ad0bfd7381f3b2", "patch": "@@ -1,3 +1,26 @@\n+Thu Sep 20 09:00:27 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* fold-const.c (hashtab.h): Include.\n+\t(int_const_binop): Remove FORSIZE arg and compute from type; all\n+\tcallers changed.\n+\tCall size_int_type_wide for all single-word constants.\n+\t(size_htab_hash, size_htab_eq): New functions.\n+\t(size_int_type_wide): Rework to use hash table.\n+\t* ggc-common.c (hashtab.h): Include.\n+\t(struct d_htab_root): New struct.\n+\t(d_htab_roots): New variable.\n+\t(ggc_add_deletable_htab, ggc_htab_delete): New functions\n+\t(ggc_mark_roots): Handle deletable htabs.\n+\t* ggc-page.c (ggc_marked_p): New function.\n+\t* ggc-simple.c (ggc_marked_p): Likewise.\n+\t* ggc.h: Reformatting throughout.\n+\t(ggc_marked_p, ggc_add_deletable_htab): New declarations.\n+\t* tree.c (init_obstacks): Make type_hash_table a deletable root.\n+\t(type_hash_add): Allocate struct type_hash from GC memory.\n+\t(mark_hash_entry, mark_type_hash): Deleted.\n+\t(type_hash_marked_p, type_hash_mark): New functions.\n+\t* Makefile.in (ggc-common.o, fold-const.o): Include hashtab.h.\n+\n Thu Sep 20 12:49:34 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* sh.c (shiftcosts): Don't use shiftcosts array for modes wider"}, {"sha": "db4dfcdcafb9c3ef84b1f4534a8ed585c92393b9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4c160717caf980303ced3d3f17ad0bfd7381f3b2", "patch": "@@ -1310,7 +1310,7 @@ dumpvers: dumpvers.c\n version.o: version.c version.h\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n-\tflags.h $(GGC_H) varray.h hash.h $(TM_P_H)\n+\tflags.h $(GGC_H) varray.h hash.h $(HASHTAB_H) $(TM_P_H)\n \n ggc-simple.o: ggc-simple.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n \t$(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H)\n@@ -1346,8 +1346,8 @@ tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h function.h toplev.h \\\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(GGC_H)\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h \\\n    function.h $(EXPR_H) $(RTL_H) toplev.h $(GGC_H) $(TM_P_H)\n-fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h toplev.h \\\n-   $(EXPR_H) $(RTL_H) $(GGC_H) $(TM_P_H)\n+fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h \\\n+   toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) $(GGC_H) $(TM_P_H)\n diagnostic.o : diagnostic.c diagnostic.h real.h diagnostic.def \\\n    $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) flags.h $(GGC_H) \\\n    input.h toplev.h intl.h"}, {"sha": "b4c60a489bb4442ffde49ebcc71c94ac462ea518", "filename": "gcc/fold-const.c", "status": "modified", "additions": 85, "deletions": 43, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4c160717caf980303ced3d3f17ad0bfd7381f3b2", "patch": "@@ -51,6 +51,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"hashtab.h\"\n \n static void encode\t\tPARAMS ((HOST_WIDE_INT *,\n \t\t\t\t\t unsigned HOST_WIDE_INT,\n@@ -65,9 +66,11 @@ static tree negate_expr\t\tPARAMS ((tree));\n static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n \t\t\t\t\t int));\n static tree associate_trees\tPARAMS ((tree, tree, enum tree_code, tree));\n-static tree int_const_binop\tPARAMS ((enum tree_code, tree, tree, int, int));\n+static tree int_const_binop\tPARAMS ((enum tree_code, tree, tree, int));\n static void const_binop_1\tPARAMS ((PTR));\n static tree const_binop\t\tPARAMS ((enum tree_code, tree, tree, int));\n+static hashval_t size_htab_hash\tPARAMS ((const void *));\n+static int size_htab_eq\t\tPARAMS ((const void *, const void *));\n static void fold_convert_1\tPARAMS ((PTR));\n static tree fold_convert\tPARAMS ((tree, tree));\n static enum tree_code invert_tree_comparison PARAMS ((enum tree_code));\n@@ -1478,14 +1481,13 @@ associate_trees (t1, t2, code, type)\n /* Combine two integer constants ARG1 and ARG2 under operation CODE\n    to produce a new constant.\n \n-   If NOTRUNC is nonzero, do not truncate the result to fit the data type.\n-   If FORSIZE is nonzero, compute overflow for unsigned types.  */\n+   If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n \n static tree\n-int_const_binop (code, arg1, arg2, notrunc, forsize)\n+int_const_binop (code, arg1, arg2, notrunc)\n      enum tree_code code;\n      register tree arg1, arg2;\n-     int notrunc, forsize;\n+     int notrunc;\n {\n   unsigned HOST_WIDE_INT int1l, int2l;\n   HOST_WIDE_INT int1h, int2h;\n@@ -1494,7 +1496,10 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n   unsigned HOST_WIDE_INT garbagel;\n   HOST_WIDE_INT garbageh;\n   register tree t;\n-  int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n+  tree type = TREE_TYPE (arg1);\n+  int uns = TREE_UNSIGNED (type);\n+  int is_sizetype\n+    = (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type));\n   int overflow = 0;\n   int no_overflow = 0;\n \n@@ -1527,15 +1532,15 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n       /* It's unclear from the C standard whether shifts can overflow.\n \t The following code ignores overflow; perhaps a C standard\n \t interpretation ruling is needed.  */\n-      lshift_double (int1l, int1h, int2l, TYPE_PRECISION (TREE_TYPE (arg1)),\n+      lshift_double (int1l, int1h, int2l, TYPE_PRECISION (type),\n \t\t     &low, &hi, !uns);\n       no_overflow = 1;\n       break;\n \n     case RROTATE_EXPR:\n       int2l = - int2l;\n     case LROTATE_EXPR:\n-      lrotate_double (int1l, int1h, int2l, TYPE_PRECISION (TREE_TYPE (arg1)),\n+      lrotate_double (int1l, int1h, int2l, TYPE_PRECISION (type),\n \t\t      &low, &hi);\n       break;\n \n@@ -1583,8 +1588,7 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n \t  low = 1, hi = 0;\n \t  break;\n \t}\n-      overflow = div_and_round_double (code, uns,\n-\t\t\t\t       int1l, int1h, int2l, int2h,\n+      overflow = div_and_round_double (code, uns, int1l, int1h, int2l, int2h,\n \t\t\t\t       &low, &hi, &garbagel, &garbageh);\n       break;\n \n@@ -1632,24 +1636,31 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n       abort ();\n     }\n \n-  if (forsize && hi == 0 && low < 10000\n+  /* If this is for a sizetype, can be represented as one (signed)\n+     HOST_WIDE_INT word, and doesn't overflow, use size_int since it caches\n+     constants.  */\n+  if (is_sizetype\n+      && ((hi == 0 && (HOST_WIDE_INT) low >= 0)\n+\t  || (hi == -1 && (HOST_WIDE_INT) low < 0))\n       && overflow == 0 && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n-    return size_int_type_wide (low, TREE_TYPE (arg1));\n+    return size_int_type_wide (low, type);\n   else\n     {\n       t = build_int_2 (low, hi);\n       TREE_TYPE (t) = TREE_TYPE (arg1);\n     }\n \n   TREE_OVERFLOW (t)\n-    = ((notrunc ? (!uns || forsize) && overflow\n-\t: force_fit_type (t, (!uns || forsize) && overflow) && ! no_overflow)\n+    = ((notrunc\n+\t? (!uns || is_sizetype) && overflow\n+\t: (force_fit_type (t, (!uns || is_sizetype) && overflow)\n+\t   && ! no_overflow))\n        | TREE_OVERFLOW (arg1)\n        | TREE_OVERFLOW (arg2));\n \n   /* If we're doing a size calculation, unsigned arithmetic does overflow.\n      So check if force_fit_type truncated the value.  */\n-  if (forsize\n+  if (is_sizetype\n       && ! TREE_OVERFLOW (t)\n       && (TREE_INT_CST_HIGH (t) != hi\n \t  || TREE_INT_CST_LOW (t) != low))\n@@ -1740,7 +1751,7 @@ const_binop (code, arg1, arg2, notrunc)\n   STRIP_NOPS (arg2);\n \n   if (TREE_CODE (arg1) == INTEGER_CST)\n-    return int_const_binop (code, arg1, arg2, notrunc, 0);\n+    return int_const_binop (code, arg1, arg2, notrunc);\n \n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   if (TREE_CODE (arg1) == REAL_CST)\n@@ -1865,6 +1876,39 @@ const_binop (code, arg1, arg2, notrunc)\n     }\n   return 0;\n }\n+\n+/* These are the hash table functions for the hash table of INTEGER_CST\n+   nodes of a sizetype.  */\n+\n+/* Return the hash code code X, an INTEGER_CST.  */\n+\n+static hashval_t\n+size_htab_hash (x)\n+     const void *x;\n+{\n+  tree t = (tree) x;\n+\n+  return (TREE_INT_CST_HIGH (t) ^ TREE_INT_CST_LOW (t)\n+\t  ^ (hashval_t) ((long) TREE_TYPE (t) >> 3)\n+\t  ^ (TREE_OVERFLOW (t) << 20));\n+}\n+\n+/* Return non-zero if the value represented by *X (an INTEGER_CST tree node)\n+   is the same as that given by *Y, which is the same.  */\n+\n+static int\n+size_htab_eq (x, y)\n+     const void *x;\n+     const void *y;\n+{\n+  tree xt = (tree) x;\n+  tree yt = (tree) y;\n+\n+  return (TREE_INT_CST_HIGH (xt) == TREE_INT_CST_HIGH (yt)\n+\t  && TREE_INT_CST_LOW (xt) == TREE_INT_CST_LOW (yt)\n+\t  && TREE_TYPE (xt) == TREE_TYPE (yt)\n+\t  && TREE_OVERFLOW (xt) == TREE_OVERFLOW (yt));\n+}\n \f\n /* Return an INTEGER_CST with value whose low-order HOST_BITS_PER_WIDE_INT\n    bits are given by NUMBER and of the sizetype represented by KIND.  */\n@@ -1884,40 +1928,38 @@ size_int_type_wide (number, type)\n      HOST_WIDE_INT number;\n      tree type;\n {\n-  /* Type-size nodes already made for small sizes.  */\n-  static tree size_table[2048 + 1];\n-  static int init_p = 0;\n-  tree t;\n+  static htab_t size_htab = 0;\n+  static tree new_const = 0;\n+  PTR *slot;\n \n-  if (! init_p)\n+  if (size_htab == 0)\n     {\n-      ggc_add_tree_root ((tree *) size_table,\n-\t\t\t sizeof size_table / sizeof (tree));\n-      init_p = 1;\n+      size_htab = htab_create (1024, size_htab_hash, size_htab_eq, NULL);\n+      ggc_add_deletable_htab (size_htab, NULL, NULL);\n+      new_const = make_node (INTEGER_CST);\n+      ggc_add_tree_root (&new_const, 1);\n     }\n \n-  /* If this is a positive number that fits in the table we use to hold\n-     cached entries, see if it is already in the table and put it there\n-     if not.  */\n-  if (number >= 0 && number < (int) ARRAY_SIZE (size_table))\n+  /* Adjust NEW_CONST to be the constant we want.  If it's already in the\n+     hash table, we return the value from the hash table.  Otherwise, we\n+     place that in the hash table and make a new node for the next time.  */\n+  TREE_INT_CST_LOW (new_const) = number;\n+  TREE_INT_CST_HIGH (new_const) = number < 0 ? -1 : 0;\n+  TREE_TYPE (new_const) = type;\n+  TREE_OVERFLOW (new_const) = TREE_CONSTANT_OVERFLOW (new_const)\n+    = force_fit_type (new_const, 0);\n+\n+  slot = htab_find_slot (size_htab, new_const, INSERT);\n+  if (*slot == 0)\n     {\n-      if (size_table[number] != 0)\n-\tfor (t = size_table[number]; t != 0; t = TREE_CHAIN (t))\n-\t  if (TREE_TYPE (t) == type)\n-\t    return t;\n-\n-      t = build_int_2 (number, 0);\n-      TREE_TYPE (t) = type;\n-      TREE_CHAIN (t) = size_table[number];\n-      size_table[number] = t;\n+      tree t = new_const;\n \n+      *slot = (PTR) new_const;\n+      new_const = make_node (INTEGER_CST);\n       return t;\n     }\n-\n-  t = build_int_2 (number, number < 0 ? -1 : 0);\n-  TREE_TYPE (t) = type;\n-  TREE_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (t) = force_fit_type (t, 0);\n-  return t;\n+  else\n+    return (tree) *slot;\n }\n \n /* Combine operands OP1 and OP2 with arithmetic operation CODE.  CODE\n@@ -1949,7 +1991,7 @@ size_binop (code, arg0, arg1)\n \treturn arg1;\n \n       /* Handle general case of two integer constants.  */\n-      return int_const_binop (code, arg0, arg1, 0, 1);\n+      return int_const_binop (code, arg0, arg1, 0);\n     }\n \n   if (arg0 == error_mark_node || arg1 == error_mark_node)"}, {"sha": "154d47b3f48a025416d06691991639f5c6f4219d", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=4c160717caf980303ced3d3f17ad0bfd7381f3b2", "patch": "@@ -27,6 +27,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree.h\"\n #include \"tm_p.h\"\n #include \"hash.h\"\n+#include \"hashtab.h\"\n #include \"varray.h\"\n #include \"ggc.h\"\n \n@@ -47,9 +48,10 @@ static void ggc_mark_tree_ptr PARAMS ((void *));\n static void ggc_mark_rtx_varray_ptr PARAMS ((void *));\n static void ggc_mark_tree_varray_ptr PARAMS ((void *));\n static void ggc_mark_tree_hash_table_ptr PARAMS ((void *));\n+static int ggc_htab_delete PARAMS ((void **, void *));\n static void ggc_mark_trees PARAMS ((void));\n static bool ggc_mark_tree_hash_table_entry PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t       hash_table_key));\n+\t\t\t\t\t\t    hash_table_key));\n \n /* Maintain global roots that are preserved during GC.  */\n \n@@ -166,12 +168,79 @@ ggc_del_root (base)\n   abort();\n }\n \n+/* Add a hash table to be scanned when all roots have been processed.  We\n+   delete any entry in the table that has not been marked.  */\n+\n+struct d_htab_root\n+{\n+  struct d_htab_root *next;\n+  htab_t htab;\n+  ggc_htab_marked_p marked_p;\n+  ggc_htab_mark mark;\n+};\n+\n+static struct d_htab_root *d_htab_roots;\n+\n+/* Add X, an htab, to a list of htabs that contain objects which are allocated\n+   from GC memory.  Once all other roots are marked, we check each object in\n+   the htab to see if it has already been marked.  If not, it is deleted.\n+\n+   MARKED_P, if specified, is a function that returns 1 if the entry is to\n+   be considered as \"marked\".  If not present, the data structure pointed to\n+   by the htab slot is tested.  This function should be supplied if some\n+   other object (such as something pointed to by that object) should be tested\n+   in which case the function tests whether that object (or objects) are\n+   marked (using ggc_marked_p) and returns nonzero if it is.\n+\n+   MARK, if specified, is a function that is passed the contents of a slot\n+   that has been determined to have been \"marked\" (via the above function)\n+   and marks any other objects pointed to by that object.  For example,\n+   we might have a hash table of memory attribute blocks, which are pointed\n+   to by a MEM RTL but have a pointer to a DECL.  MARKED_P in that case will\n+   not be specified because we want to know if the attribute block is pointed\n+   to by the MEM, but MARK must be specified because if the block has been\n+   marked, we need to mark the DECL.  */\n+\n+void\n+ggc_add_deletable_htab (x, marked_p, mark)\n+     PTR x;\n+     ggc_htab_marked_p marked_p;\n+     ggc_htab_mark mark;\n+{\n+  struct d_htab_root *r\n+    = (struct d_htab_root *) xmalloc (sizeof (struct d_htab_root));\n+\n+  r->next = d_htab_roots;\n+  r->htab = (htab_t) x;\n+  r->marked_p = marked_p ? marked_p : ggc_marked_p;\n+  r->mark = mark;\n+  d_htab_roots = r;\n+}\n+\n+/* Process a slot of an htab by deleting it if it has not been marked.  */\n+\n+static int\n+ggc_htab_delete (slot, info)\n+     void **slot;\n+     void *info;\n+{\n+  struct d_htab_root *r = (struct d_htab_root *) info;\n+\n+  if (! (*r->marked_p) (*slot))\n+    htab_clear_slot (r->htab, slot);\n+  else if (r->mark)\n+    (*r->mark) (*slot);\n+\n+  return 1;\n+}\n+\n /* Iterate through all registered roots and mark each element.  */\n \n void\n ggc_mark_roots ()\n {\n-  struct ggc_root* x;\n+  struct ggc_root *x;\n+  struct d_htab_root *y;\n   \n   VARRAY_TREE_INIT (ggc_pending_trees, 4096, \"ggc_pending_trees\");\n \n@@ -189,6 +258,16 @@ ggc_mark_roots ()\n   /* Mark all the queued up trees, and their children.  */\n   ggc_mark_trees ();\n   VARRAY_FREE (ggc_pending_trees);\n+\n+  /* Now scan all hash tables that have objects which are to be deleted if\n+     they are not already marked.  Since these may mark more trees, we need\n+     to reinitialize that varray.  */\n+  VARRAY_TREE_INIT (ggc_pending_trees, 1024, \"ggc_pending_trees\");\n+\n+  for (y = d_htab_roots; y != NULL; y = y->next)\n+    htab_traverse (y->htab, ggc_htab_delete, (PTR) y);\n+  ggc_mark_trees ();\n+  VARRAY_FREE (ggc_pending_trees);\n }\n \n /* R had not been previously marked, but has now been marked via\n@@ -463,7 +542,7 @@ ggc_mark_tree_varray (v)\n       ggc_mark_tree (VARRAY_TREE (v, i));\n }\n \n-/* Mark the hash table-entry HE.  It's key field is really a tree.  */\n+/* Mark the hash table-entry HE.  Its key field is really a tree.  */\n \n static bool\n ggc_mark_tree_hash_table_entry (he, k)"}, {"sha": "60517ae9020c8ce0e8bf8c51a25fb3a738c92718", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=4c160717caf980303ced3d3f17ad0bfd7381f3b2", "patch": "@@ -1001,6 +1001,35 @@ ggc_set_mark (p)\n   return 0;\n }\n \n+/* Return 1 if P has been marked, zero otherwise. \n+   P must have been allocated by the GC allocator; it mustn't point to\n+   static objects, stack variables, or memory allocated with malloc.  */\n+\n+int\n+ggc_marked_p (p)\n+     const void *p;\n+{\n+  page_entry *entry;\n+  unsigned bit, word;\n+  unsigned long mask;\n+\n+  /* Look up the page on which the object is alloced.  If the object\n+     wasn't allocated by the collector, we'll probably die.  */\n+  entry = lookup_page_table_entry (p);\n+#ifdef ENABLE_CHECKING\n+  if (entry == NULL)\n+    abort ();\n+#endif\n+\n+  /* Calculate the index of the object on the page; this is its bit\n+     position in the in_use_p bitmap.  */\n+  bit = (((const char *) p) - entry->page) / OBJECT_SIZE (entry->order);\n+  word = bit / HOST_BITS_PER_LONG;\n+  mask = (unsigned long) 1 << (bit % HOST_BITS_PER_LONG);\n+  \n+  return entry->in_use_p[word] & mask;\n+}\n+\n /* Return the size of the gc-able object P.  */\n \n size_t"}, {"sha": "81d2c36fc6d0e7d2084abf7727e18fce9494129a", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=4c160717caf980303ced3d3f17ad0bfd7381f3b2", "patch": "@@ -228,6 +228,23 @@ ggc_set_mark (p)\n   return 0;\n }\n \n+/* Return 1 if P has been marked, zero otherwise.  */\n+\n+int\n+ggc_marked_p (p)\n+     const void *p;\n+{\n+  struct ggc_mem *x;\n+\n+  x = (struct ggc_mem *) ((const char *)p - offsetof (struct ggc_mem, u));\n+#ifdef GGC_ALWAYS_VERIFY\n+  if (! tree_lookup (x))\n+    abort ();\n+#endif\n+\n+   return x->mark;\n+}\n+\n /* Return the size of the gc-able object P.  */\n \n size_t"}, {"sha": "fe3290bc59a0e96f64431c8252bc191d5d331594", "filename": "gcc/ggc.h", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=4c160717caf980303ced3d3f17ad0bfd7381f3b2", "patch": "@@ -47,23 +47,39 @@ extern const char digit_vector[];\t/* \"0\" .. \"9\" */\n extern varray_type ggc_pending_trees;\n \n /* Manipulate global roots that are needed between calls to gc.  */\n-void ggc_add_root PARAMS ((void *base, int nelt, int size, void (*)(void *)));\n-void ggc_add_rtx_root PARAMS ((struct rtx_def **, int nelt));\n-void ggc_add_tree_root PARAMS ((union tree_node **, int nelt));\n-void ggc_add_rtx_varray_root PARAMS ((struct varray_head_tag **, int nelt));\n-void ggc_add_tree_varray_root PARAMS ((struct varray_head_tag **, int nelt));\n-void ggc_add_tree_hash_table_root PARAMS ((struct hash_table **, int nelt));\n-void ggc_del_root PARAMS ((void *base));\n+extern void ggc_add_root\t\tPARAMS ((void *base, int nelt,\n+\t\t\t\t\t\t int size, void (*)(void *)));\n+extern void ggc_add_rtx_root\t\tPARAMS ((struct rtx_def **, int nelt));\n+extern void ggc_add_tree_root\t\tPARAMS ((union tree_node **,\n+\t\t\t\t\t\t int nelt));\n+extern void ggc_add_rtx_varray_root\tPARAMS ((struct varray_head_tag **,\n+\t\t\t\t\t\t int nelt));\n+extern void ggc_add_tree_varray_root\tPARAMS ((struct varray_head_tag **,\n+\t\t\t\t\t\t int nelt));\n+extern void ggc_add_tree_hash_table_root PARAMS ((struct hash_table **,\n+\t\t\t\t\t\t  int nelt));\n+extern void ggc_del_root\t\tPARAMS ((void *base));\n+\n+/* Types used for mark test and marking functions, if specified, in call\n+   below.  */\n+typedef int (*ggc_htab_marked_p) PARAMS ((const void *));\n+typedef void (*ggc_htab_mark) PARAMS ((const void *));\n+\n+/* Add a hash table to be scanned when all roots have been processed.  We\n+   delete any entry in the table that has not been marked.  The argument is\n+   really htab_t.  */\n+extern void ggc_add_deletable_htab\tPARAMS ((PTR, ggc_htab_marked_p,\n+\t\t\t\t\t\t ggc_htab_mark));\n \n /* Mark nodes from the gc_add_root callback.  These functions follow\n    pointers to mark other objects too.  */\n-extern void ggc_mark_rtx_varray PARAMS ((struct varray_head_tag *));\n-extern void ggc_mark_tree_varray PARAMS ((struct varray_head_tag *));\n-extern void ggc_mark_tree_hash_table PARAMS ((struct hash_table *));\n-extern void ggc_mark_roots PARAMS ((void));\n+extern void ggc_mark_rtx_varray\t\tPARAMS ((struct varray_head_tag *));\n+extern void ggc_mark_tree_varray\tPARAMS ((struct varray_head_tag *));\n+extern void ggc_mark_tree_hash_table\tPARAMS ((struct hash_table *));\n+extern void ggc_mark_roots\t\tPARAMS ((void));\n \n-extern void ggc_mark_rtx_children PARAMS ((struct rtx_def *));\n-extern void ggc_mark_rtvec_children PARAMS ((struct rtvec_def *));\n+extern void ggc_mark_rtx_children\tPARAMS ((struct rtx_def *));\n+extern void ggc_mark_rtvec_children\tPARAMS ((struct rtvec_def *));\n \n /* If EXPR is not NULL and previously unmarked, mark it and evaluate\n    to true.  Otherwise evaluate to false.  */\n@@ -108,23 +124,23 @@ extern void ggc_mark_rtvec_children PARAMS ((struct rtvec_def *));\n /* A GC implementation must provide these functions.  */\n \n /* Initialize the garbage collector.   */\n-extern void init_ggc PARAMS ((void));\n-extern void init_stringpool PARAMS ((void));\n+extern void init_ggc\t\tPARAMS ((void));\n+extern void init_stringpool\tPARAMS ((void));\n \n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n-extern void ggc_push_context PARAMS ((void));\n+extern void ggc_push_context\tPARAMS ((void));\n \n /* Finish a GC context.  Any uncollected memory in the new context\n    will be merged with the old context.  */\n-extern void ggc_pop_context PARAMS ((void));\n+extern void ggc_pop_context \tPARAMS ((void));\n \n /* Allocation.  */\n \n /* The internal primitive.  */\n-void *ggc_alloc PARAMS ((size_t));\n+extern void *ggc_alloc\t\tPARAMS ((size_t));\n /* Like ggc_alloc, but allocates cleared memory.  */\n-void *ggc_alloc_cleared PARAMS ((size_t));\n+extern void *ggc_alloc_cleared\tPARAMS ((size_t));\n \n #define ggc_alloc_rtx(NSLOTS)\t\t\t\t\t\t  \\\n   ((struct rtx_def *) ggc_alloc (sizeof (struct rtx_def)\t\t  \\\n@@ -139,27 +155,33 @@ void *ggc_alloc_cleared PARAMS ((size_t));\n /* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n    If LENGTH is -1, then CONTENTS is assumed to be a\n    null-terminated string and the memory sized accordingly.  */\n-const char *ggc_alloc_string PARAMS ((const char *contents, int length));\n+extern const char *ggc_alloc_string\tPARAMS ((const char *contents,\n+\t\t\t\t\t\t int length));\n \n /* Make a copy of S, in GC-able memory.  */\n #define ggc_strdup(S) ggc_alloc_string((S), -1)\n \n /* Invoke the collector.  Garbage collection occurs only when this\n    function is called, not during allocations.  */\n-void ggc_collect PARAMS ((void));\n+extern void ggc_collect\t\t\tPARAMS ((void));\n \n /* Actually set the mark on a particular region of memory, but don't\n    follow pointers.  This function is called by ggc_mark_*.  It\n    returns zero if the object was not previously marked; non-zero if\n    the object was already marked, or if, for any other reason,\n    pointers in this data structure should not be traversed.  */\n-int ggc_set_mark PARAMS ((const void *));\n+extern int ggc_set_mark\t\t\tPARAMS ((const void *));\n+\n+/* Return 1 if P has been marked, zero otherwise. \n+   P must have been allocated by the GC allocator; it mustn't point to\n+   static objects, stack variables, or memory allocated with malloc.  */\n+extern int ggc_marked_p\t\t\tPARAMS ((const void *));\n \n /* Callbacks to the languages.  */\n \n /* This is the language's opportunity to mark nodes held through\n    the lang_specific hooks in the tree.  */\n-void lang_mark_tree PARAMS ((union tree_node *));\n+extern void lang_mark_tree\t\tPARAMS ((union tree_node *));\n \n /* The FALSE_LABEL_STACK, declared in except.h, has language-dependent\n    semantics.  If a front-end needs to mark the false label stack, it\n@@ -169,12 +191,12 @@ extern void (*lang_mark_false_label_stack) PARAMS ((struct label_node *));\n \n /* Mark functions for various structs scattered about.  */\n \n-void mark_eh_status PARAMS ((struct eh_status *));\n-void mark_emit_status PARAMS ((struct emit_status *));\n-void mark_expr_status PARAMS ((struct expr_status *));\n-void mark_stmt_status PARAMS ((struct stmt_status *));\n-void mark_varasm_status PARAMS ((struct varasm_status *));\n-void mark_optab PARAMS ((void *));\n+void mark_eh_status\t\t\tPARAMS ((struct eh_status *));\n+void mark_emit_status\t\t\tPARAMS ((struct emit_status *));\n+void mark_expr_status\t\t\tPARAMS ((struct expr_status *));\n+void mark_stmt_status\t\t\tPARAMS ((struct stmt_status *));\n+void mark_varasm_status\t\t\tPARAMS ((struct varasm_status *));\n+void mark_optab\t\t\t\tPARAMS ((void *));\n \n /* Statistics.  */\n \n@@ -203,12 +225,12 @@ typedef struct ggc_statistics\n } ggc_statistics;\n \n /* Return the number of bytes allocated at the indicated address.  */\n-size_t ggc_get_size PARAMS ((const void *));\n+extern size_t ggc_get_size\t\tPARAMS ((const void *));\n \n /* Used by the various collectors to gather and print statistics that\n    do not depend on the collector in use.  */\n-void ggc_print_common_statistics PARAMS ((FILE *, ggc_statistics *));\n+extern void ggc_print_common_statistics PARAMS ((FILE *, ggc_statistics *));\n \n /* Print allocation statistics.  */\n-extern void ggc_print_statistics PARAMS ((void));\n-void stringpool_statistics PARAMS ((void));\n+extern void ggc_print_statistics\tPARAMS ((void));\n+extern void stringpool_statistics\tPARAMS ((void));"}, {"sha": "731791c8602a0b148ed9420adb7f2ce0e140ae5c", "filename": "gcc/tree.c", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c160717caf980303ced3d3f17ad0bfd7381f3b2/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4c160717caf980303ced3d3f17ad0bfd7381f3b2", "patch": "@@ -158,12 +158,12 @@ htab_t type_hash_table;\n static void build_real_from_int_cst_1 PARAMS ((PTR));\n static void set_type_quals PARAMS ((tree, int));\n static void append_random_chars PARAMS ((char *));\n-static void mark_type_hash PARAMS ((void *));\n static int type_hash_eq PARAMS ((const void*, const void*));\n static unsigned int type_hash_hash PARAMS ((const void*));\n static void print_type_hash_statistics PARAMS((void));\n-static int mark_hash_entry PARAMS((void **, void *));\n static void finish_vector_type PARAMS((tree));\n+static int type_hash_marked_p PARAMS ((const void *));\n+static void type_hash_mark PARAMS ((const void *));\n static int mark_tree_hashtable_entry PARAMS((void **, void *));\n \n /* If non-null, these are language-specific helper functions for\n@@ -225,7 +225,8 @@ init_obstacks ()\n   /* Initialize the hash table of types.  */\n   type_hash_table = htab_create (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n \t\t\t\t type_hash_eq, 0);\n-  ggc_add_root (&type_hash_table, 1, sizeof type_hash_table, mark_type_hash);\n+  ggc_add_deletable_htab (type_hash_table, type_hash_marked_p,\n+\t\t\t  type_hash_mark);\n   ggc_add_tree_root (global_trees, TI_MAX);\n   ggc_add_tree_root (integer_types, itk_none);\n \n@@ -3186,7 +3187,7 @@ type_hash_add (hashcode, type)\n   struct type_hash *h;\n   void **loc;\n \n-  h = (struct type_hash *) permalloc (sizeof (struct type_hash));\n+  h = (struct type_hash *) ggc_alloc (sizeof (struct type_hash));\n   h->hash = hashcode;\n   h->type = type;\n   loc = htab_find_slot_with_hash (type_hash_table, h, hashcode, INSERT);\n@@ -3217,6 +3218,8 @@ type_hash_canon (hashcode, type)\n   if (debug_no_type_hash)\n     return type;\n \n+  /* See if the type is in the hash table already.  If so, return it.\n+     Otherwise, add the type.  */\n   t1 = type_hash_lookup (hashcode, type);\n   if (t1 != 0)\n     {\n@@ -3226,37 +3229,29 @@ type_hash_canon (hashcode, type)\n #endif\n       return t1;\n     }\n-\n-  /* If this is a permanent type, record it for later reuse.  */\n-  type_hash_add (hashcode, type);\n-\n-  return type;\n+  else\n+    {\n+      type_hash_add (hashcode, type);\n+      return type;\n+    }\n }\n \n-/* Callback function for htab_traverse.  */\n+/* See if the data pointed to by the type hash table is marked.  */\n \n static int\n-mark_hash_entry (entry, param)\n-     void **entry;\n-     void *param ATTRIBUTE_UNUSED;\n+type_hash_marked_p (p)\n+     const void *p;\n {\n-  struct type_hash *p = *(struct type_hash **) entry;\n-\n-  ggc_mark_tree (p->type);\n-\n-  /* Continue scan.  */\n-  return 1;\n+  return ggc_marked_p (((struct type_hash *) p)->type);\n }\n \n-/* Mark ARG (which is really a htab_t *) for GC.  */\n+/* Mark the entry in the type hash table the type it points to is marked. */\n \n static void\n-mark_type_hash (arg)\n-     void *arg;\n+type_hash_mark (p)\n+     const void *p;\n {\n-  htab_t t = *(htab_t *) arg;\n-\n-  htab_traverse (t, mark_hash_entry, 0);\n+  ggc_mark (p);\n }\n \n /* Mark the hashtable slot pointed to by ENTRY (which is really a"}]}