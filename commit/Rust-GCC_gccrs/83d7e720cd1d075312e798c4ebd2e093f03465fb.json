{"sha": "83d7e720cd1d075312e798c4ebd2e093f03465fb", "node_id": "C_kwDOANBUbNoAKDgzZDdlNzIwY2QxZDA3NTMxMmU3OThjNGViZDJlMDkzZjAzNDY1ZmI", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-09T16:57:06Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-09T16:57:06Z"}, "message": "aarch64: Extend vec_concat patterns to 8-byte vectors\n\nThis patch extends the previous support for 16-byte vec_concat\nso that it supports pairs of 4-byte elements.  This too isn't\nstrictly a regression fix, since the 8-byte forms weren't affected\nby the same problems as the 16-byte forms, but it leaves things in\na more consistent state.\n\ngcc/\n\t* config/aarch64/iterators.md (VDCSIF): New mode iterator.\n\t(VDBL): Handle SF.\n\t(single_wx, single_type, single_dtype, dblq): New mode attributes.\n\t* config/aarch64/aarch64-simd.md (load_pair_lanes<mode>): Extend\n\tfrom VDC to VDCSIF.\n\t(store_pair_lanes<mode>): Likewise.\n\t(*aarch64_combine_internal<mode>): Likewise.\n\t(*aarch64_combine_internal_be<mode>): Likewise.\n\t(*aarch64_combinez<mode>): Likewise.\n\t(*aarch64_combinez_be<mode>): Likewise.\n\t* config/aarch64/aarch64.cc (aarch64_classify_address): Handle\n\t8-byte modes for ADDR_QUERY_LDP_STP_N.\n\t(aarch64_print_operand): Likewise for %y.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/vec-init-13.c: New test.\n\t* gcc.target/aarch64/vec-init-14.c: Likewise.\n\t* gcc.target/aarch64/vec-init-15.c: Likewise.\n\t* gcc.target/aarch64/vec-init-16.c: Likewise.\n\t* gcc.target/aarch64/vec-init-17.c: Likewise.", "tree": {"sha": "b91aafa3db7e5a166597b5b79e4f409d49a144a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b91aafa3db7e5a166597b5b79e4f409d49a144a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83d7e720cd1d075312e798c4ebd2e093f03465fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d7e720cd1d075312e798c4ebd2e093f03465fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83d7e720cd1d075312e798c4ebd2e093f03465fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d7e720cd1d075312e798c4ebd2e093f03465fb/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bce43c0493f65d2589776f0dafa396d5477a84c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce43c0493f65d2589776f0dafa396d5477a84c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bce43c0493f65d2589776f0dafa396d5477a84c7"}], "stats": {"total": 472, "additions": 430, "deletions": 42}, "files": [{"sha": "18733428f3fb91d937346aa360f6d1fe13ca1eae", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=83d7e720cd1d075312e798c4ebd2e093f03465fb", "patch": "@@ -4243,12 +4243,12 @@\n (define_insn \"load_pair_lanes<mode>\"\n   [(set (match_operand:<VDBL> 0 \"register_operand\" \"=w\")\n \t(vec_concat:<VDBL>\n-\t   (match_operand:VDC 1 \"memory_operand\" \"Utq\")\n-\t   (match_operand:VDC 2 \"memory_operand\" \"m\")))]\n+\t   (match_operand:VDCSIF 1 \"memory_operand\" \"Utq\")\n+\t   (match_operand:VDCSIF 2 \"memory_operand\" \"m\")))]\n   \"TARGET_SIMD\n    && aarch64_mergeable_load_pair_p (<VDBL>mode, operands[1], operands[2])\"\n-  \"ldr\\\\t%q0, %1\"\n-  [(set_attr \"type\" \"neon_load1_1reg_q\")]\n+  \"ldr\\\\t%<single_dtype>0, %1\"\n+  [(set_attr \"type\" \"neon_load1_1reg<dblq>\")]\n )\n \n ;; This STP pattern is a partial duplicate of the general vec_concat patterns\n@@ -4273,12 +4273,12 @@\n (define_insn \"store_pair_lanes<mode>\"\n   [(set (match_operand:<VDBL> 0 \"aarch64_mem_pair_lanes_operand\" \"=Umn, Umn\")\n \t(vec_concat:<VDBL>\n-\t   (match_operand:VDC 1 \"register_operand\" \"w, r\")\n-\t   (match_operand:VDC 2 \"register_operand\" \"w, r\")))]\n+\t   (match_operand:VDCSIF 1 \"register_operand\" \"w, r\")\n+\t   (match_operand:VDCSIF 2 \"register_operand\" \"w, r\")))]\n   \"TARGET_SIMD\"\n   \"@\n-   stp\\\\t%d1, %d2, %y0\n-   stp\\\\t%x1, %x2, %y0\"\n+   stp\\t%<single_type>1, %<single_type>2, %y0\n+   stp\\t%<single_wx>1, %<single_wx>2, %y0\"\n   [(set_attr \"type\" \"neon_stp, store_16\")]\n )\n \n@@ -4292,37 +4292,37 @@\n (define_insn \"*aarch64_combine_internal<mode>\"\n   [(set (match_operand:<VDBL> 0 \"aarch64_reg_or_mem_pair_operand\" \"=w, w, w, Umn, Umn\")\n \t(vec_concat:<VDBL>\n-\t  (match_operand:VDC 1 \"register_operand\" \"0, 0, 0, ?w, ?r\")\n-\t  (match_operand:VDC 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, Utv, w, ?r\")))]\n+\t  (match_operand:VDCSIF 1 \"register_operand\" \"0, 0, 0, ?w, ?r\")\n+\t  (match_operand:VDCSIF 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, Utv, w, ?r\")))]\n   \"TARGET_SIMD\n    && !BYTES_BIG_ENDIAN\n    && (register_operand (operands[0], <VDBL>mode)\n        || register_operand (operands[2], <MODE>mode))\"\n   \"@\n-   ins\\t%0.d[1], %2.d[0]\n-   ins\\t%0.d[1], %2\n-   ld1\\t{%0.d}[1], %2\n-   stp\\t%d1, %d2, %y0\n-   stp\\t%x1, %x2, %y0\"\n-  [(set_attr \"type\" \"neon_ins_q, neon_from_gp_q, neon_load1_one_lane_q, neon_stp, store_16\")]\n+   ins\\t%0.<single_type>[1], %2.<single_type>[0]\n+   ins\\t%0.<single_type>[1], %<single_wx>2\n+   ld1\\t{%0.<single_type>}[1], %2\n+   stp\\t%<single_type>1, %<single_type>2, %y0\n+   stp\\t%<single_wx>1, %<single_wx>2, %y0\"\n+  [(set_attr \"type\" \"neon_ins<dblq>, neon_from_gp<dblq>, neon_load1_one_lane<dblq>, neon_stp, store_16\")]\n )\n \n (define_insn \"*aarch64_combine_internal_be<mode>\"\n   [(set (match_operand:<VDBL> 0 \"aarch64_reg_or_mem_pair_operand\" \"=w, w, w, Umn, Umn\")\n \t(vec_concat:<VDBL>\n-\t  (match_operand:VDC 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, Utv, ?w, ?r\")\n-\t  (match_operand:VDC 1 \"register_operand\" \"0, 0, 0, ?w, ?r\")))]\n+\t  (match_operand:VDCSIF 2 \"aarch64_simd_nonimmediate_operand\" \"w, ?r, Utv, ?w, ?r\")\n+\t  (match_operand:VDCSIF 1 \"register_operand\" \"0, 0, 0, ?w, ?r\")))]\n   \"TARGET_SIMD\n    && BYTES_BIG_ENDIAN\n    && (register_operand (operands[0], <VDBL>mode)\n        || register_operand (operands[2], <MODE>mode))\"\n   \"@\n-   ins\\t%0.d[1], %2.d[0]\n-   ins\\t%0.d[1], %2\n-   ld1\\t{%0.d}[1], %2\n-   stp\\t%d2, %d1, %y0\n-   stp\\t%x2, %x1, %y0\"\n-  [(set_attr \"type\" \"neon_ins_q, neon_from_gp_q, neon_load1_one_lane_q, neon_stp, store_16\")]\n+   ins\\t%0.<single_type>[1], %2.<single_type>[0]\n+   ins\\t%0.<single_type>[1], %<single_wx>2\n+   ld1\\t{%0.<single_type>}[1], %2\n+   stp\\t%<single_type>2, %<single_type>1, %y0\n+   stp\\t%<single_wx>2, %<single_wx>1, %y0\"\n+  [(set_attr \"type\" \"neon_ins<dblq>, neon_from_gp<dblq>, neon_load1_one_lane<dblq>, neon_stp, store_16\")]\n )\n \n ;; In this insn, operand 1 should be low, and operand 2 the high part of the\n@@ -4331,27 +4331,27 @@\n (define_insn \"*aarch64_combinez<mode>\"\n   [(set (match_operand:<VDBL> 0 \"register_operand\" \"=w,w,w\")\n \t(vec_concat:<VDBL>\n-\t  (match_operand:VDC 1 \"nonimmediate_operand\" \"w,?r,m\")\n-\t  (match_operand:VDC 2 \"aarch64_simd_or_scalar_imm_zero\")))]\n+\t  (match_operand:VDCSIF 1 \"nonimmediate_operand\" \"w,?r,m\")\n+\t  (match_operand:VDCSIF 2 \"aarch64_simd_or_scalar_imm_zero\")))]\n   \"TARGET_SIMD && !BYTES_BIG_ENDIAN\"\n   \"@\n-   mov\\\\t%0.8b, %1.8b\n-   fmov\\t%d0, %1\n-   ldr\\\\t%d0, %1\"\n+   fmov\\\\t%<single_type>0, %<single_type>1\n+   fmov\\t%<single_type>0, %<single_wx>1\n+   ldr\\\\t%<single_type>0, %1\"\n   [(set_attr \"type\" \"neon_move<q>, neon_from_gp, neon_load1_1reg\")\n    (set_attr \"arch\" \"simd,fp,simd\")]\n )\n \n (define_insn \"*aarch64_combinez_be<mode>\"\n   [(set (match_operand:<VDBL> 0 \"register_operand\" \"=w,w,w\")\n         (vec_concat:<VDBL>\n-\t  (match_operand:VDC 2 \"aarch64_simd_or_scalar_imm_zero\")\n-\t  (match_operand:VDC 1 \"nonimmediate_operand\" \"w,?r,m\")))]\n+\t  (match_operand:VDCSIF 2 \"aarch64_simd_or_scalar_imm_zero\")\n+\t  (match_operand:VDCSIF 1 \"nonimmediate_operand\" \"w,?r,m\")))]\n   \"TARGET_SIMD && BYTES_BIG_ENDIAN\"\n   \"@\n-   mov\\\\t%0.8b, %1.8b\n-   fmov\\t%d0, %1\n-   ldr\\\\t%d0, %1\"\n+   fmov\\\\t%<single_type>0, %<single_type>1\n+   fmov\\t%<single_type>0, %<single_wx>1\n+   ldr\\\\t%<single_type>0, %1\"\n   [(set_attr \"type\" \"neon_move<q>, neon_from_gp, neon_load1_1reg\")\n    (set_attr \"arch\" \"simd,fp,simd\")]\n )\n@@ -4362,8 +4362,8 @@\n (define_expand \"@aarch64_vec_concat<mode>\"\n   [(set (match_operand:<VDBL> 0 \"register_operand\")\n \t(vec_concat:<VDBL>\n-\t  (match_operand:VDC 1 \"general_operand\")\n-\t  (match_operand:VDC 2 \"general_operand\")))]\n+\t  (match_operand:VDCSIF 1 \"general_operand\")\n+\t  (match_operand:VDCSIF 2 \"general_operand\")))]\n   \"TARGET_SIMD\"\n {\n   int lo = BYTES_BIG_ENDIAN ? 2 : 1;"}, {"sha": "7bb97bd48e4b01edc109274704160bc228778c09", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=83d7e720cd1d075312e798c4ebd2e093f03465fb", "patch": "@@ -9922,9 +9922,15 @@ aarch64_classify_address (struct aarch64_address_info *info,\n   /* If we are dealing with ADDR_QUERY_LDP_STP_N that means the incoming mode\n      corresponds to the actual size of the memory being loaded/stored and the\n      mode of the corresponding addressing mode is half of that.  */\n-  if (type == ADDR_QUERY_LDP_STP_N\n-      && known_eq (GET_MODE_SIZE (mode), 16))\n-    mode = DFmode;\n+  if (type == ADDR_QUERY_LDP_STP_N)\n+    {\n+      if (known_eq (GET_MODE_SIZE (mode), 16))\n+\tmode = DFmode;\n+      else if (known_eq (GET_MODE_SIZE (mode), 8))\n+\tmode = SFmode;\n+      else\n+\treturn false;\n+    }\n \n   bool allow_reg_index_p = (!load_store_pair_p\n \t\t\t    && ((vec_flags == 0\n@@ -11404,7 +11410,9 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n \tmachine_mode mode = GET_MODE (x);\n \n \tif (!MEM_P (x)\n-\t    || (code == 'y' && maybe_ne (GET_MODE_SIZE (mode), 16)))\n+\t    || (code == 'y'\n+\t\t&& maybe_ne (GET_MODE_SIZE (mode), 8)\n+\t\t&& maybe_ne (GET_MODE_SIZE (mode), 16)))\n \t  {\n \t    output_operand_lossage (\"invalid operand for '%%%c'\", code);\n \t    return;"}, {"sha": "88067a3536a9f9afbfaf2bd2db6d6a76f8556138", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=83d7e720cd1d075312e798c4ebd2e093f03465fb", "patch": "@@ -236,6 +236,9 @@\n ;; Double vector modes for combines.\n (define_mode_iterator VDC [V8QI V4HI V4BF V4HF V2SI V2SF DI DF])\n \n+;; VDC plus SI and SF.\n+(define_mode_iterator VDCSIF [V8QI V4HI V4BF V4HF V2SI V2SF SI SF DI DF])\n+\n ;; Polynomial modes for vector combines.\n (define_mode_iterator VDC_P [V8QI V4HI DI])\n \n@@ -1436,8 +1439,8 @@\n (define_mode_attr VDBL [(V8QI \"V16QI\") (V4HI \"V8HI\")\n \t\t\t(V4HF \"V8HF\")  (V4BF \"V8BF\")\n \t\t\t(V2SI \"V4SI\")  (V2SF \"V4SF\")\n-\t\t\t(SI   \"V2SI\")  (DI   \"V2DI\")\n-\t\t\t(DF   \"V2DF\")])\n+\t\t\t(SI   \"V2SI\")  (SF   \"V2SF\")\n+\t\t\t(DI   \"V2DI\")  (DF   \"V2DF\")])\n \n ;; Register suffix for double-length mode.\n (define_mode_attr Vdtype [(V4HF \"8h\") (V2SF \"4s\")])\n@@ -1557,6 +1560,30 @@\n \t\t\t     (V4SI \"2s\") (V8HF \"4h\")\n \t\t\t     (V4SF \"2s\")])\n \n+;; Whether a mode fits in W or X registers (i.e. \"w\" for 32-bit modes\n+;; and \"x\" for 64-bit modes).\n+(define_mode_attr single_wx [(SI   \"w\") (SF   \"w\")\n+\t\t\t     (V8QI \"x\") (V4HI \"x\")\n+\t\t\t     (V4HF \"x\") (V4BF \"x\")\n+\t\t\t     (V2SI \"x\") (V2SF \"x\")\n+\t\t\t     (DI   \"x\") (DF   \"x\")])\n+\n+;; Whether a mode fits in S or D registers (i.e. \"s\" for 32-bit modes\n+;; and \"d\" for 64-bit modes).\n+(define_mode_attr single_type [(SI   \"s\") (SF   \"s\")\n+\t\t\t       (V8QI \"d\") (V4HI \"d\")\n+\t\t\t       (V4HF \"d\") (V4BF \"d\")\n+\t\t\t       (V2SI \"d\") (V2SF \"d\")\n+\t\t\t       (DI   \"d\") (DF   \"d\")])\n+\n+;; Whether a double-width mode fits in D or Q registers (i.e. \"d\" for\n+;; 32-bit modes and \"q\" for 64-bit modes).\n+(define_mode_attr single_dtype [(SI   \"d\") (SF   \"d\")\n+\t\t\t        (V8QI \"q\") (V4HI \"q\")\n+\t\t\t        (V4HF \"q\") (V4BF \"q\")\n+\t\t\t        (V2SI \"q\") (V2SF \"q\")\n+\t\t\t        (DI   \"q\") (DF   \"q\")])\n+\n ;; Define corresponding core/FP element mode for each vector mode.\n (define_mode_attr vw [(V8QI \"w\") (V16QI \"w\")\n \t\t      (V4HI \"w\") (V8HI \"w\")\n@@ -1849,6 +1876,13 @@\n \t\t     (V4x1DF \"\") (V4x2DF \"_q\")\n \t\t     (V4x4BF \"\") (V4x8BF \"_q\")])\n \n+;; Equivalent of the \"q\" attribute for the <VDBL> mode.\n+(define_mode_attr dblq [(SI   \"\") (SF   \"\")\n+\t\t        (V8QI \"_q\") (V4HI \"_q\")\n+\t\t        (V4HF \"_q\") (V4BF \"_q\")\n+\t\t        (V2SI \"_q\") (V2SF \"_q\")\n+\t\t        (DI   \"_q\") (DF   \"_q\")])\n+\n (define_mode_attr vp [(V8QI \"v\") (V16QI \"v\")\n \t\t      (V4HI \"v\") (V8HI  \"v\")\n \t\t      (V2SI \"p\") (V4SI  \"v\")"}, {"sha": "d0f88cbe71a33c00101efc71ca254c6b5fe3788b", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-13.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-13.c?ref=83d7e720cd1d075312e798c4ebd2e093f03465fb", "patch": "@@ -0,0 +1,123 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+** s64q_1:\n+**\tfmov\td0, x0\n+**\tret\n+*/\n+int64x2_t s64q_1(int64_t a0) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int64x2_t) { 0, a0 };\n+  else\n+    return (int64x2_t) { a0, 0 };\n+}\n+/*\n+** s64q_2:\n+**\tldr\td0, \\[x0\\]\n+**\tret\n+*/\n+int64x2_t s64q_2(int64_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int64x2_t) { 0, ptr[0] };\n+  else\n+    return (int64x2_t) { ptr[0], 0 };\n+}\n+/*\n+** s64q_3:\n+**\tldr\td0, \\[x0, #?8\\]\n+**\tret\n+*/\n+int64x2_t s64q_3(int64_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int64x2_t) { 0, ptr[1] };\n+  else\n+    return (int64x2_t) { ptr[1], 0 };\n+}\n+\n+/*\n+** f64q_1:\n+**\tfmov\td0, d0\n+**\tret\n+*/\n+float64x2_t f64q_1(float64_t a0) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float64x2_t) { 0, a0 };\n+  else\n+    return (float64x2_t) { a0, 0 };\n+}\n+/*\n+** f64q_2:\n+**\tldr\td0, \\[x0\\]\n+**\tret\n+*/\n+float64x2_t f64q_2(float64_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float64x2_t) { 0, ptr[0] };\n+  else\n+    return (float64x2_t) { ptr[0], 0 };\n+}\n+/*\n+** f64q_3:\n+**\tldr\td0, \\[x0, #?8\\]\n+**\tret\n+*/\n+float64x2_t f64q_3(float64_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float64x2_t) { 0, ptr[1] };\n+  else\n+    return (float64x2_t) { ptr[1], 0 };\n+}\n+\n+/*\n+** s32q_1:\n+**\tfmov\td0, d0\n+**\tret\n+*/\n+int32x4_t s32q_1(int32x2_t a0, int32x2_t a1) {\n+  return vcombine_s32 (a0, (int32x2_t) { 0, 0 });\n+}\n+/*\n+** s32q_2:\n+**\tldr\td0, \\[x0\\]\n+**\tret\n+*/\n+int32x4_t s32q_2(int32x2_t *ptr) {\n+  return vcombine_s32 (ptr[0], (int32x2_t) { 0, 0 });\n+}\n+/*\n+** s32q_3:\n+**\tldr\td0, \\[x0, #?8\\]\n+**\tret\n+*/\n+int32x4_t s32q_3(int32x2_t *ptr) {\n+  return vcombine_s32 (ptr[1], (int32x2_t) { 0, 0 });\n+}\n+\n+/*\n+** f32q_1:\n+**\tfmov\td0, d0\n+**\tret\n+*/\n+float32x4_t f32q_1(float32x2_t a0, float32x2_t a1) {\n+  return vcombine_f32 (a0, (float32x2_t) { 0, 0 });\n+}\n+/*\n+** f32q_2:\n+**\tldr\td0, \\[x0\\]\n+**\tret\n+*/\n+float32x4_t f32q_2(float32x2_t *ptr) {\n+  return vcombine_f32 (ptr[0], (float32x2_t) { 0, 0 });\n+}\n+/*\n+** f32q_3:\n+**\tldr\td0, \\[x0, #?8\\]\n+**\tret\n+*/\n+float32x4_t f32q_3(float32x2_t *ptr) {\n+  return vcombine_f32 (ptr[1], (float32x2_t) { 0, 0 });\n+}"}, {"sha": "02875088cd98833882cdf15b14dcb426951e428f", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-14.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-14.c?ref=83d7e720cd1d075312e798c4ebd2e093f03465fb", "patch": "@@ -0,0 +1,123 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include <arm_neon.h>\n+\n+void ext();\n+\n+/*\n+** s32_1:\n+**\tfmov\ts0, w0\n+**\tins\tv0\\.s\\[1\\], w1\n+**\tret\n+*/\n+int32x2_t s32_1(int32_t a0, int32_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int32x2_t) { a1, a0 };\n+  else\n+    return (int32x2_t) { a0, a1 };\n+}\n+/*\n+** s32_2:\n+**\tfmov\ts0, w0\n+**\tld1\t{v0\\.s}\\[1\\], \\[x1\\]\n+**\tret\n+*/\n+int32x2_t s32_2(int32_t a0, int32_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int32x2_t) { ptr[0], a0 };\n+  else\n+    return (int32x2_t) { a0, ptr[0] };\n+}\n+/*\n+** s32_3:\n+**\tldr\ts0, \\[x0\\]\n+**\tins\tv0\\.s\\[1\\], w1\n+**\tret\n+*/\n+int32x2_t s32_3(int32_t *ptr, int32_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int32x2_t) { a1, ptr[0] };\n+  else\n+    return (int32x2_t) { ptr[0], a1 };\n+}\n+/*\n+** s32_4:\n+**\tstp\tw1, w2, \\[x0\\]\n+**\tret\n+*/\n+void s32_4(int32x2_t *res, int32_t a0, int32_t a1) {\n+  res[0] = (int32x2_t) { a0, a1 };\n+}\n+/*\n+** s32_5:\n+**\tstp\tw1, w2, \\[x0, #?4\\]\n+**\tret\n+*/\n+void s32_5(uintptr_t res, int32_t a0, int32_t a1) {\n+  *(int32x2_t *)(res + 4) = (int32x2_t) { a0, a1 };\n+}\n+/* Currently uses d8 to hold res across the call.  */\n+int32x2_t s32_6(int32_t a0, int32_t a1) {\n+  int32x2_t res = { a0, a1 };\n+  ext ();\n+  return res;\n+}\n+\n+/*\n+** f32_1:\n+**\tins\tv0\\.s\\[1\\], v1\\.s\\[0\\]\n+**\tret\n+*/\n+float32x2_t f32_1(float32_t a0, float32_t a1) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float32x2_t) { a1, a0 };\n+  else\n+    return (float32x2_t) { a0, a1 };\n+}\n+/*\n+** f32_2:\n+**\tld1\t{v0\\.s}\\[1\\], \\[x0\\]\n+**\tret\n+*/\n+float32x2_t f32_2(float32_t a0, float32_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float32x2_t) { ptr[0], a0 };\n+  else\n+    return (float32x2_t) { a0, ptr[0] };\n+}\n+/*\n+** f32_3:\n+**\tldr\ts0, \\[x0\\]\n+**\tins\tv0\\.s\\[1\\], v1\\.s\\[0\\]\n+**\tret\n+*/\n+float32x2_t f32_3(float32_t a0, float32_t a1, float32_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float32x2_t) { a1, ptr[0] };\n+  else\n+    return (float32x2_t) { ptr[0], a1 };\n+}\n+/*\n+** f32_4:\n+**\tstp\ts0, s1, \\[x0\\]\n+**\tret\n+*/\n+void f32_4(float32x2_t *res, float32_t a0, float32_t a1) {\n+  res[0] = (float32x2_t) { a0, a1 };\n+}\n+/*\n+** f32_5:\n+**\tstp\ts0, s1, \\[x0, #?4\\]\n+**\tret\n+*/\n+void f32_5(uintptr_t res, float32_t a0, float32_t a1) {\n+  *(float32x2_t *)(res + 4) = (float32x2_t) { a0, a1 };\n+}\n+/* Currently uses d8 to hold res across the call.  */\n+float32x2_t f32_6(float32_t a0, float32_t a1) {\n+  float32x2_t res = { a0, a1 };\n+  ext ();\n+  return res;\n+}"}, {"sha": "82f0a8f55ee746e3bca16eb668a4b2c772c595ea", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-15.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-15.c?ref=83d7e720cd1d075312e798c4ebd2e093f03465fb", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+#include <arm_neon.h>\n+\n+int32x2_t f1(int32_t *x, int c) {\n+  return c ? (int32x2_t) { x[0], x[2] } : (int32x2_t) { 0, 0 };\n+}\n+\n+int32x2_t f2(int32_t *x, int i0, int i1, int c) {\n+  return c ? (int32x2_t) { x[i0], x[i1] } : (int32x2_t) { 0, 0 };\n+}\n+\n+/* { dg-final { scan-assembler-times {\\t(?:ldr\\ts[0-9]+|ld1\\t)} 4 } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tw} } } */"}, {"sha": "e00aec7a32ccd39af6a006f9ffe480d3d0b0b604", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-16.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-16.c?ref=83d7e720cd1d075312e798c4ebd2e093f03465fb", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+#include <arm_neon.h>\n+\n+void f1(int32x2_t *res, int32_t *x, int c0, int c1) {\n+  res[0] = (int32x2_t) { c0 ? x[0] : 0, c1 ? x[2] : 0 };\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tldr\\tw[0-9]+} 2 } } */\n+/* { dg-final { scan-assembler {\\tstp\\tw[0-9]+, w[0-9]+} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\ts} } } */"}, {"sha": "86191b3ca1d36a6692576c414bfd7a6965ec5474", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-17.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d7e720cd1d075312e798c4ebd2e093f03465fb/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-17.c?ref=83d7e720cd1d075312e798c4ebd2e093f03465fb", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+** s32_1:\n+**\tfmov\ts0, w0\n+**\tret\n+*/\n+int32x2_t s32_1(int32_t a0) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int32x2_t) { 0, a0 };\n+  else\n+    return (int32x2_t) { a0, 0 };\n+}\n+/*\n+** s32_2:\n+**\tldr\ts0, \\[x0\\]\n+**\tret\n+*/\n+int32x2_t s32_2(int32_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int32x2_t) { 0, ptr[0] };\n+  else\n+    return (int32x2_t) { ptr[0], 0 };\n+}\n+/*\n+** s32_3:\n+**\tldr\ts0, \\[x0, #?4\\]\n+**\tret\n+*/\n+int32x2_t s32_3(int32_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (int32x2_t) { 0, ptr[1] };\n+  else\n+    return (int32x2_t) { ptr[1], 0 };\n+}\n+\n+/*\n+** f32_1:\n+**\tfmov\ts0, s0\n+**\tret\n+*/\n+float32x2_t f32_1(float32_t a0) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float32x2_t) { 0, a0 };\n+  else\n+    return (float32x2_t) { a0, 0 };\n+}\n+/*\n+** f32_2:\n+**\tldr\ts0, \\[x0\\]\n+**\tret\n+*/\n+float32x2_t f32_2(float32_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float32x2_t) { 0, ptr[0] };\n+  else\n+    return (float32x2_t) { ptr[0], 0 };\n+}\n+/*\n+** f32_3:\n+**\tldr\ts0, \\[x0, #?4\\]\n+**\tret\n+*/\n+float32x2_t f32_3(float32_t *ptr) {\n+  if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+    return (float32x2_t) { 0, ptr[1] };\n+  else\n+    return (float32x2_t) { ptr[1], 0 };\n+}"}]}