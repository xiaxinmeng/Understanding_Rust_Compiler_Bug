{"sha": "7219c2c7d309f8a8f3695d82462351bb06bce542", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIxOWMyYzdkMzA5ZjhhOGYzNjk1ZDgyNDYyMzUxYmIwNmJjZTU0Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-01-13T00:17:45Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-01-13T00:17:45Z"}, "message": "utils.c (aggregate_type_contains_array_p): New predicate.\n\n\t* utils.c (aggregate_type_contains_array_p): New predicate.\n\t(create_field_decl): In a packed record, force byte alignment\n\tfor fields without specified position that contain an array.\n\nFrom-SVN: r131498", "tree": {"sha": "95582da2dba72b28f390915018146be99c543e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95582da2dba72b28f390915018146be99c543e93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7219c2c7d309f8a8f3695d82462351bb06bce542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7219c2c7d309f8a8f3695d82462351bb06bce542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7219c2c7d309f8a8f3695d82462351bb06bce542", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7219c2c7d309f8a8f3695d82462351bb06bce542/comments", "author": null, "committer": null, "parents": [{"sha": "074e13552962827b93999e011156b0030b172acd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/074e13552962827b93999e011156b0030b172acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/074e13552962827b93999e011156b0030b172acd"}], "stats": {"total": 101, "additions": 99, "deletions": 2}, "files": [{"sha": "d1bedccbd9b7795f9f77f23bfc2f6e3abbed08bd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7219c2c7d309f8a8f3695d82462351bb06bce542", "patch": "@@ -1,3 +1,9 @@\n+2008-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* utils.c (aggregate_type_contains_array_p): New predicate.\n+\t(create_field_decl): In a packed record, force byte alignment\n+\tfor fields without specified position that contain an array.\n+\n 2008-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* utils.c (unchecked_convert): Fold the VIEW_CONVERT_EXPR expression."}, {"sha": "b158725747704f70f2db4766fb9b665c18e064ae", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=7219c2c7d309f8a8f3695d82462351bb06bce542", "patch": "@@ -1509,6 +1509,33 @@ create_true_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t\t    attr_list, gnat_node);\n }\n \f\n+/* Return true if TYPE, an aggregate type, contains (or is) an array.  */\n+\n+static bool\n+aggregate_type_contains_array_p (tree type)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\ttree field;\n+\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  if (AGGREGATE_TYPE_P (TREE_TYPE (field))\n+\t      && aggregate_type_contains_array_p (TREE_TYPE (field)))\n+\t    return true;\n+\treturn false;\n+      }\n+\n+    case ARRAY_TYPE:\n+      return true;\n+    \n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n    type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n    this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n@@ -1527,8 +1554,15 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n   TREE_READONLY (field_decl) = TYPE_READONLY (field_type);\n \n   /* If FIELD_TYPE is BLKmode, we must ensure this is aligned to at least a\n-     byte boundary since GCC cannot handle less-aligned BLKmode bitfields.  */\n-  if (packed && TYPE_MODE (field_type) == BLKmode)\n+     byte boundary since GCC cannot handle less-aligned BLKmode bitfields.\n+     Likewise for an aggregate without specified position that contains an\n+     array, because in this case slices of variable length of this array\n+     must be handled by GCC and variable-sized objects need to be aligned\n+     to at least a byte boundary.  */\n+  if (packed && (TYPE_MODE (field_type) == BLKmode\n+\t\t || (!pos\n+\t\t     && AGGREGATE_TYPE_P (field_type)\n+\t\t     && aggregate_type_contains_array_p (field_type))))\n     DECL_ALIGN (field_decl) = BITS_PER_UNIT;\n \n   /* If a size is specified, use it.  Otherwise, if the record type is packed"}, {"sha": "1c7ec62cac675cbef1e75482775b89c431014059", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7219c2c7d309f8a8f3695d82462351bb06bce542", "patch": "@@ -1,3 +1,8 @@\n+2008-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/slice3.adb: New test.\n+\t* gnat.dg/slice4.adb: Likewise.\n+\n 2008-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/bit_packed_array.ad[sb]: New test."}, {"sha": "db568f99740de1a5a66dd0d2a271d7780ca0edd9", "filename": "gcc/testsuite/gnat.dg/slice3.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Ftestsuite%2Fgnat.dg%2Fslice3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Ftestsuite%2Fgnat.dg%2Fslice3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fslice3.adb?ref=7219c2c7d309f8a8f3695d82462351bb06bce542", "patch": "@@ -0,0 +1,24 @@\n+-- { dg-do run }\n+\n+procedure Slice3 is\n+\n+   type Varray is array (1 .. 1) of Natural;  -- SImode\n+\n+   type Sample is record\n+      Maybe  : Boolean;\n+      Values : Varray;\n+   end record;\n+   pragma Pack (Sample);\n+\n+   function Match (X, Y: Sample; Length : Positive) return Boolean is\n+   begin\n+      return X.Values (1 .. Length) = Y.Values (1 .. Length);\n+   end;\n+\n+   X, Y : Sample := (Maybe => True, Values => (1 => 1));\n+begin\n+   X.Maybe := False;\n+   if not Match (X, Y, 1) then\n+      raise Program_Error;\n+   end if;\n+end;"}, {"sha": "a7890a2106812525392453bfdac0c9c6a47101b3", "filename": "gcc/testsuite/gnat.dg/slice4.adb", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Ftestsuite%2Fgnat.dg%2Fslice4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7219c2c7d309f8a8f3695d82462351bb06bce542/gcc%2Ftestsuite%2Fgnat.dg%2Fslice4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fslice4.adb?ref=7219c2c7d309f8a8f3695d82462351bb06bce542", "patch": "@@ -0,0 +1,28 @@\n+-- { dg-do run }\n+\n+procedure Slice4 is\n+\n+   type Varray is array (1 .. 1) of Natural;  -- SImode\n+\n+   type Rec is record\n+      Values : Varray;\n+   end record;\n+\n+   type Sample is record\n+      Maybe  : Boolean;\n+      R : Rec;\n+   end record;\n+   pragma Pack (Sample);\n+\n+   function Match (X, Y: Sample; Length : Positive) return Boolean is\n+   begin\n+      return X.R.Values (1 .. Length) = Y.R.Values (1 .. Length);\n+   end;\n+\n+   X, Y : Sample := (Maybe => True, R => (Values => (1 => 1)));\n+begin\n+   X.Maybe := False;\n+   if not Match (X, Y, 1) then\n+      raise Program_Error;\n+   end if;\n+end;"}]}