{"sha": "b75aab194e3fe40b594d9a70eb7068dc9950bcf0", "node_id": "C_kwDOANBUbNoAKGI3NWFhYjE5NGUzZmU0MGI1OTRkOWE3MGViNzA2OGRjOTk1MGJjZjA", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-24T16:33:04Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-01-17T07:57:27Z"}, "message": "Extend test cases for references in OpenACC 'private' clauses\n\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c++/privatized-ref-2.C: Extend.\n\t* testsuite/libgomp.oacc-c++/privatized-ref-3.C: Likewise.\n\t* testsuite/libgomp.oacc-fortran/privatized-ref-1.f95: Likewise.", "tree": {"sha": "37ce78c9e8db5522457d2371504c9e59ec8267e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37ce78c9e8db5522457d2371504c9e59ec8267e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b75aab194e3fe40b594d9a70eb7068dc9950bcf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b75aab194e3fe40b594d9a70eb7068dc9950bcf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b75aab194e3fe40b594d9a70eb7068dc9950bcf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b75aab194e3fe40b594d9a70eb7068dc9950bcf0/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbb438808e9b53a6e6b179a5787d609443acaad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb438808e9b53a6e6b179a5787d609443acaad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb438808e9b53a6e6b179a5787d609443acaad6"}], "stats": {"total": 386, "additions": 364, "deletions": 22}, "files": [{"sha": "520016ab59d2bbaf2514d2a108ab9d9ff25060f1", "filename": "libgomp/testsuite/libgomp.oacc-c++/privatized-ref-2.C", "status": "modified", "additions": 120, "deletions": 8, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b75aab194e3fe40b594d9a70eb7068dc9950bcf0/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fprivatized-ref-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b75aab194e3fe40b594d9a70eb7068dc9950bcf0/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fprivatized-ref-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fprivatized-ref-2.C?ref=b75aab194e3fe40b594d9a70eb7068dc9950bcf0", "patch": "@@ -1,20 +1,87 @@\n /* { dg-do run } */\n \n+/* { dg-additional-options \"-fopt-info-note-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-note-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* { dg-additional-options \"-Wuninitialized\" } */\n+\n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n #include <stdlib.h>\n \n+void gangs (void)\n+{\n+  double res[65536];\n+  int i;\n+\n+#pragma acc parallel copyout(res) num_gangs(64) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  {\n+    int i, j;\n+#pragma acc loop collapse(2) gang /* { dg-line l_loop[incr c_loop] } */\n+    /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    /* { dg-note {variable 'tmpvar' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_loop$c_loop }\n+       But, with optimizations enabled, per the '*.ssa' dump ('gcc/tree-ssa.c:execute_update_addresses_taken'):\n+           No longer having address taken: tmpvar\n+           Now a gimple register: tmpvar\n+       However, 'tmpvar' remains in the candidate set:\n+       { dg-note {variable 'tmpvar' ought to be adjusted for OpenACC privatization level: 'gang'} \"\" { target *-*-* } l_loop$c_loop }\n+       Now, for GCN offloading, 'adjust_private_decl' does the privatization change right away:\n+       { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target openacc_radeon_accel_selected } l_loop$c_loop }\n+       For nvptx offloading however, we first mark up 'tmpvar', and then later apply the privatization change -- or, with optimizations enabled, don't, because we then don't actually call 'expand_var_decl'.\n+       { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && { ! __OPTIMIZE__ } } } l_loop$c_loop }\n+       { dg-bogus {note: variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && __OPTIMIZE__ } } l_loop$c_loop }\n+  */\n+    /* { dg-note {variable 'tmpref' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    for (i = 0; i < 256; i++)\n+      {\n+\tfor (j = 0; j < 256; j++)\n+\t  {\n+\t    int tmpvar;\n+\t    int &tmpref = tmpvar;\n+\t    tmpref = (i * 256 + j) * 97;\n+\t    res[i * 256 + j] = tmpref;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 65536; i++)\n+    if (res[i] != i * 97)\n+      abort ();\n+}\n+\n void workers (void)\n {\n   double res[65536];\n   int i;\n \n-#pragma acc parallel copyout(res) num_gangs(64) num_workers(64)\n-  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } .-1 } */\n+#pragma acc parallel copyout(res) num_gangs(64) num_workers(64) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n   {\n     int i, j;\n-#pragma acc loop gang\n+#pragma acc loop gang /* { dg-line l_loop[incr c_loop] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n     for (i = 0; i < 256; i++)\n       {\n-#pragma acc loop worker\n+#pragma acc loop worker /* { dg-line l_loop[incr c_loop] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+\t/* { dg-note {variable 'tmpvar' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_loop$c_loop }\n+\t   { dg-note {variable 'tmpvar' ought to be adjusted for OpenACC privatization level: 'worker'} \"\" { target *-*-* } l_loop$c_loop }\n+\t   { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'worker'} \"TODO\" { target { ! openacc_host_selected } xfail *-*-* } l_loop$c_loop } */\n+\t/* { dg-note {variable 'tmpref' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n \tfor (j = 0; j < 256; j++)\n \t  {\n \t    int tmpvar;\n@@ -35,14 +102,22 @@ void vectors (void)\n   double res[65536];\n   int i;\n \n-#pragma acc parallel copyout(res) num_gangs(64) num_workers(64)\n-  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } .-1 } */\n+#pragma acc parallel copyout(res) num_gangs(64) num_workers(64) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n   {\n     int i, j;\n-#pragma acc loop gang worker\n+#pragma acc loop gang worker /* { dg-line l_loop[incr c_loop] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n     for (i = 0; i < 256; i++)\n       {\n-#pragma acc loop vector\n+#pragma acc loop vector /* { dg-line l_loop[incr c_loop] } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+\t/* { dg-note {variable 'tmpvar' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_loop$c_loop }\n+\t   { dg-note {variable 'tmpvar' ought to be adjusted for OpenACC privatization level: 'vector'} \"\" { target *-*-* } l_loop$c_loop }\n+\t   { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'vector'} \"TODO\" { target { ! openacc_host_selected } } l_loop$c_loop } */\n+\t/* { dg-note {variable 'tmpref' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n \tfor (j = 0; j < 256; j++)\n \t  {\n \t    int tmpvar;\n@@ -58,9 +133,46 @@ void vectors (void)\n       abort ();\n }\n \n+void gangs_workers_vectors (void)\n+{\n+  double res[65536];\n+  int i;\n+\n+#pragma acc parallel copyout(res) num_gangs(64) num_workers(64) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n+  {\n+    int i, j;\n+#pragma acc loop collapse(2) gang worker vector /* { dg-line l_loop[incr c_loop] } */\n+    /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    /* { dg-note {variable 'tmpvar' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_loop$c_loop }\n+       { dg-note {variable 'tmpvar' ought to be adjusted for OpenACC privatization level: 'vector'} \"\" { target *-*-* } l_loop$c_loop }\n+       { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'vector'} \"TODO\" { target { ! openacc_host_selected } } l_loop$c_loop } */\n+    /* { dg-note {variable 'tmpref' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    for (i = 0; i < 256; i++)\n+      {\n+\tfor (j = 0; j < 256; j++)\n+\t  {\n+\t    int tmpvar;\n+\t    int &tmpref = tmpvar;\n+\t    tmpref = (i * 256 + j) * 103;\n+\t    res[i * 256 + j] = tmpref;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 65536; i++)\n+    if (res[i] != i * 103)\n+      abort ();\n+}\n+\n int main (int argc, char *argv[])\n {\n+  gangs ();\n   workers ();\n   vectors ();\n+  gangs_workers_vectors ();\n   return 0;\n }"}, {"sha": "cb7085a01e8a62d9d97ce4b970768216bc605aa1", "filename": "libgomp/testsuite/libgomp.oacc-c++/privatized-ref-3.C", "status": "modified", "additions": 151, "deletions": 8, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b75aab194e3fe40b594d9a70eb7068dc9950bcf0/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fprivatized-ref-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b75aab194e3fe40b594d9a70eb7068dc9950bcf0/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fprivatized-ref-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fprivatized-ref-3.C?ref=b75aab194e3fe40b594d9a70eb7068dc9950bcf0", "patch": "@@ -1,25 +1,103 @@\n /* { dg-do run } */\n \n+/* { dg-additional-options \"-fopt-info-note-omp\" }\n+   { dg-additional-options \"-foffload=-fopt-info-note-omp\" } */\n+\n+/* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+\n+/* { dg-additional-options \"-Wuninitialized\" } */\n+\n /*TODO\n    { dg-xfail-run-if TODO { openacc_radeon_accel_selected && { ! __OPTIMIZE__ } } } */\n \n+/* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+   passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+   so to maintain compatibility with earlier Tcl releases, we manually\n+   initialize counter variables:\n+   { dg-line l_dummy[variable c_compute 0 c_loop 0] }\n+   { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+   \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n #include <stdlib.h>\n \n+void gangs (void)\n+{\n+  double res[65536];\n+  int i;\n+\n+#pragma acc parallel copyout(res) num_gangs(64) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'tmpvar' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_compute$c_compute }\n+     But, with optimizations enabled, per the '*.ssa' dump ('gcc/tree-ssa.c:execute_update_addresses_taken'):\n+         No longer having address taken: tmpvar\n+         Now a gimple register: tmpvar\n+     However, 'tmpvar' remains in the candidate set:\n+     { dg-note {variable 'tmpvar' ought to be adjusted for OpenACC privatization level: 'gang'} \"\" { target *-*-* } l_compute$c_compute }\n+     Now, for GCN offloading, 'adjust_private_decl' does the privatization change right away:\n+     { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target openacc_radeon_accel_selected } l_compute$c_compute }\n+     For nvptx offloading however, we first mark up 'tmpvar', and then later apply the privatization change -- or, with optimizations enabled, don't, because we then don't actually call 'expand_var_decl'.\n+     { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && { ! __OPTIMIZE__ } } } l_compute$c_compute }\n+     { dg-bogus {note: variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && __OPTIMIZE__ } } l_compute$c_compute }\n+  */\n+  /* { dg-note {variable 'tmpref' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  {\n+    int i, j;\n+    int tmpvar;\n+    int &tmpref = tmpvar;\n+#pragma acc loop collapse(2) gang private(tmpref) /* { dg-line l_loop[incr c_loop] } */\n+    /* { dg-note {variable 'tmpref' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    for (i = 0; i < 256; i++)\n+      {\n+\tfor (j = 0; j < 256; j++)\n+\t  {\n+\t    tmpref = (i * 256 + j) * 97;\n+\t    res[i * 256 + j] = tmpref;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 65536; i++)\n+    if (res[i] != i * 97)\n+      abort ();\n+}\n+\n void workers (void)\n {\n   double res[65536];\n   int i;\n \n-#pragma acc parallel copyout(res) num_gangs(64) num_workers(64)\n-  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } .-1 } */\n+#pragma acc parallel copyout(res) num_gangs(64) num_workers(64) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'tmpvar' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_compute$c_compute }\n+     But, with optimizations enabled, per the '*.ssa' dump ('gcc/tree-ssa.c:execute_update_addresses_taken'):\n+         No longer having address taken: tmpvar\n+         Now a gimple register: tmpvar\n+     However, 'tmpvar' remains in the candidate set:\n+     { dg-note {variable 'tmpvar' ought to be adjusted for OpenACC privatization level: 'gang'} \"\" { target *-*-* } l_compute$c_compute }\n+     Now, for GCN offloading, 'adjust_private_decl' does the privatization change right away:\n+     { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target openacc_radeon_accel_selected } l_compute$c_compute }\n+     For nvptx offloading however, we first mark up 'tmpvar', and then later apply the privatization change -- or, with optimizations enabled, don't, because we then don't actually call 'expand_var_decl'.\n+     { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && { ! __OPTIMIZE__ } } } l_compute$c_compute }\n+     { dg-bogus {note: variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && __OPTIMIZE__ } } l_compute$c_compute }\n+  */\n+  /* { dg-note {variable 'tmpref' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n   {\n     int i, j;\n     int tmpvar;\n     int &tmpref = tmpvar;\n-#pragma acc loop gang\n+#pragma acc loop gang /* { dg-line l_loop[incr c_loop] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n     for (i = 0; i < 256; i++)\n       {\n-#pragma acc loop worker private(tmpref)\n+#pragma acc loop worker private(tmpref) /* { dg-line l_loop[incr c_loop] } */\n+\t/* { dg-note {variable 'tmpref' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n \tfor (j = 0; j < 256; j++)\n \t  {\n \t    tmpref = (i * 256 + j) * 99;\n@@ -38,16 +116,34 @@ void vectors (void)\n   double res[65536];\n   int i;\n \n-#pragma acc parallel copyout(res) num_gangs(64) num_workers(64)\n-  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } .-1 } */\n+#pragma acc parallel copyout(res) num_gangs(64) num_workers(64) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'tmpvar' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_compute$c_compute }\n+     But, with optimizations enabled, per the '*.ssa' dump ('gcc/tree-ssa.c:execute_update_addresses_taken'):\n+         No longer having address taken: tmpvar\n+         Now a gimple register: tmpvar\n+     However, 'tmpvar' remains in the candidate set:\n+     { dg-note {variable 'tmpvar' ought to be adjusted for OpenACC privatization level: 'gang'} \"\" { target *-*-* } l_compute$c_compute }\n+     Now, for GCN offloading, 'adjust_private_decl' does the privatization change right away:\n+     { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target openacc_radeon_accel_selected } l_compute$c_compute }\n+     For nvptx offloading however, we first mark up 'tmpvar', and then later apply the privatization change -- or, with optimizations enabled, don't, because we then don't actually call 'expand_var_decl'.\n+     { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && { ! __OPTIMIZE__ } } } l_compute$c_compute }\n+     { dg-bogus {note: variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && __OPTIMIZE__ } } l_compute$c_compute }\n+  */\n+  /* { dg-note {variable 'tmpref' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n   {\n     int i, j;\n     int tmpvar;\n     int &tmpref = tmpvar;\n-#pragma acc loop gang worker\n+#pragma acc loop gang worker /* { dg-line l_loop[incr c_loop] } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n     for (i = 0; i < 256; i++)\n       {\n-#pragma acc loop vector private(tmpref)\n+#pragma acc loop vector private(tmpref) /* { dg-line l_loop[incr c_loop] } */\n+\t/* { dg-note {variable 'tmpref' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n \tfor (j = 0; j < 256; j++)\n \t  {\n \t    tmpref = (i * 256 + j) * 101;\n@@ -61,9 +157,56 @@ void vectors (void)\n       abort ();\n }\n \n+void gangs_workers_vectors (void)\n+{\n+  double res[65536];\n+  int i;\n+\n+#pragma acc parallel copyout(res) num_gangs(64) num_workers(64) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'i' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-note {variable 'tmpvar' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_compute$c_compute }\n+     But, with optimizations enabled, per the '*.ssa' dump ('gcc/tree-ssa.c:execute_update_addresses_taken'):\n+         No longer having address taken: tmpvar\n+         Now a gimple register: tmpvar\n+     However, 'tmpvar' remains in the candidate set:\n+     { dg-note {variable 'tmpvar' ought to be adjusted for OpenACC privatization level: 'gang'} \"\" { target *-*-* } l_compute$c_compute }\n+     Now, for GCN offloading, 'adjust_private_decl' does the privatization change right away:\n+     { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target openacc_radeon_accel_selected } l_compute$c_compute }\n+     For nvptx offloading however, we first mark up 'tmpvar', and then later apply the privatization change -- or, with optimizations enabled, don't, because we then don't actually call 'expand_var_decl'.\n+     { dg-note {variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && { ! __OPTIMIZE__ } } } l_compute$c_compute }\n+     { dg-bogus {note: variable 'tmpvar' adjusted for OpenACC privatization level: 'gang'} \"\" { target { openacc_nvidia_accel_selected && __OPTIMIZE__ } } l_compute$c_compute }\n+  */\n+  /* { dg-note {variable 'tmpref' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute } */\n+  /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } l_compute$c_compute } */\n+  {\n+    int i, j;\n+    int tmpvar;\n+    int &tmpref = tmpvar;\n+#pragma acc loop collapse(2) gang worker vector private(tmpref) /* { dg-line l_loop[incr c_loop] } */\n+    /* { dg-note {variable 'tmpref' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop } */\n+    for (i = 0; i < 256; i++)\n+      {\n+\tfor (j = 0; j < 256; j++)\n+\t  {\n+\t    tmpref = (i * 256 + j) * 103;\n+\t    res[i * 256 + j] = tmpref;\n+\t  }\n+      }\n+  }\n+\n+  for (i = 0; i < 65536; i++)\n+    if (res[i] != i * 103)\n+      abort ();\n+}\n+\n int main (int argc, char *argv[])\n {\n+  gangs ();\n   workers ();\n   vectors ();\n+  gangs_workers_vectors ();\n   return 0;\n }"}, {"sha": "a8230561fc9c78ebefa3e2031af17af97466755c", "filename": "libgomp/testsuite/libgomp.oacc-fortran/privatized-ref-1.f95", "status": "modified", "additions": 93, "deletions": 6, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b75aab194e3fe40b594d9a70eb7068dc9950bcf0/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivatized-ref-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b75aab194e3fe40b594d9a70eb7068dc9950bcf0/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivatized-ref-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivatized-ref-1.f95?ref=b75aab194e3fe40b594d9a70eb7068dc9950bcf0", "patch": "@@ -1,8 +1,24 @@\n ! { dg-do run }\n \n+! { dg-additional-options \"-fopt-info-note-omp\" }\n+! { dg-additional-options \"-foffload=-fopt-info-note-omp\" }\n+\n+! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n+! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+\n+! { dg-additional-options \"-Wuninitialized\" }\n+\n !TODO\n ! { dg-xfail-run-if TODO { openacc_radeon_accel_selected && { ! __OPTIMIZE__ } } }\n \n+! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n+! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n+! so to maintain compatibility with earlier Tcl releases, we manually\n+! initialize counter variables:\n+! { dg-line l_dummy[variable c_loop 0] }\n+! { dg-message \"dummy\" \"\" { target iN-VAl-Id } l_dummy } to avoid\n+! \"WARNING: dg-line var l_dummy defined, but not used\".  */\n+\n program main\n   implicit none\n   integer :: myint\n@@ -11,12 +27,22 @@ program main\n \n   res(:) = 0.0\n \n+  myint = 3\n+  call gangs(myint, res)\n+\n+  do i=1,65536\n+    tmp = i * 97\n+    if (res(i) .ne. tmp) stop 1\n+  end do\n+\n+  res(:) = 0.0\n+\n   myint = 5\n   call workers(myint, res)\n \n   do i=1,65536\n     tmp = i * 99\n-    if (res(i) .ne. tmp) stop 1\n+    if (res(i) .ne. tmp) stop 2\n   end do\n \n   res(:) = 0.0\n@@ -26,11 +52,43 @@ program main\n \n   do i=1,65536\n     tmp = i * 101\n-    if (res(i) .ne. tmp) stop 2\n+    if (res(i) .ne. tmp) stop 3\n+  end do\n+\n+  res(:) = 0.0\n+\n+  myint = 9\n+  call gangs_workers_vectors(myint, res)\n+\n+  do i=1,65536\n+    tmp = i * 103\n+    if (res(i) .ne. tmp) stop 4\n   end do\n \n contains\n \n+  subroutine gangs(t1, res)\n+    implicit none\n+    integer :: t1\n+    integer :: i, j\n+    real, intent(out) :: res(:)\n+\n+    !$acc parallel copyout(res) num_gangs(64)\n+\n+    !$acc loop collapse(2) gang private(t1) ! { dg-line l_loop[incr c_loop] }\n+    ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-note {variable 't1' in 'private' clause potentially has improper OpenACC privatization level: 'parm_decl'} \"\" { target *-*-* } l_loop$c_loop }\n+    do i=0,255\n+      do j=1,256\n+        t1 = (i * 256 + j) * 97\n+        res(i * 256 + j) = t1\n+      end do\n+    end do\n+\n+    !$acc end parallel\n+  end subroutine gangs\n+\n   subroutine workers(t1, res)\n     implicit none\n     integer :: t1\n@@ -40,9 +98,12 @@ subroutine workers(t1, res)\n     !$acc parallel copyout(res) num_gangs(64) num_workers(64)\n     ! { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } .-1 }\n \n-    !$acc loop gang\n+    !$acc loop gang ! { dg-line l_loop[incr c_loop] }\n+    ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n     do i=0,255\n-      !$acc loop worker private(t1)\n+      !$acc loop worker private(t1) ! { dg-line l_loop[incr c_loop] }\n+      ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+      ! { dg-note {variable 't1' in 'private' clause potentially has improper OpenACC privatization level: 'parm_decl'} \"\" { target *-*-* } l_loop$c_loop }\n       do j=1,256\n         t1 = (i * 256 + j) * 99\n         res(i * 256 + j) = t1\n@@ -61,9 +122,12 @@ subroutine vectors(t1, res)\n     !$acc parallel copyout(res) num_gangs(64) num_workers(64)\n     ! { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } .-1 }\n \n-    !$acc loop gang worker\n+    !$acc loop gang worker ! { dg-line l_loop[incr c_loop] }\n+    ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n     do i=0,255\n-      !$acc loop vector private(t1)\n+      !$acc loop vector private(t1) ! { dg-line l_loop[incr c_loop] }\n+      ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+      ! { dg-note {variable 't1' in 'private' clause potentially has improper OpenACC privatization level: 'parm_decl'} \"\" { target *-*-* } l_loop$c_loop }\n       do j=1,256\n         t1 = (i * 256 + j) * 101\n         res(i * 256 + j) = t1\n@@ -73,4 +137,27 @@ subroutine vectors(t1, res)\n     !$acc end parallel\n   end subroutine vectors\n \n+  subroutine gangs_workers_vectors(t1, res)\n+    implicit none\n+    integer :: t1\n+    integer :: i, j\n+    real, intent(out) :: res(:)\n+\n+    !$acc parallel copyout(res) num_gangs(64) num_workers(64)\n+    ! { dg-warning \"using num_workers \\\\(32\\\\), ignoring 64\" \"\" { target openacc_nvidia_accel_selected } .-1 }\n+\n+    !$acc loop collapse(2) gang worker vector private(t1) ! { dg-line l_loop[incr c_loop] }\n+    ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-note {variable 't1' in 'private' clause potentially has improper OpenACC privatization level: 'parm_decl'} \"\" { target *-*-* } l_loop$c_loop }\n+    do i=0,255\n+      do j=1,256\n+        t1 = (i * 256 + j) * 103\n+        res(i * 256 + j) = t1\n+      end do\n+    end do\n+\n+    !$acc end parallel\n+  end subroutine gangs_workers_vectors\n+\n end program main"}]}