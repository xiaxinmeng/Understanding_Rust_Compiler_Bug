{"sha": "c9423ca3fa65282b0ca58d33976c150f78e24f23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0MjNjYTNmYTY1MjgyYjBjYTU4ZDMzOTc2YzE1MGY3OGUyNGYyMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-10T11:06:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-10T11:06:44Z"}, "message": "[multiple changes]\n\n2012-01-10  Pascal Obry  <obry@adacore.com>\n\n\t* prj-nmsc.adb (Check_Library_Attributes): Kill check for object/source\n\tdirectories for aggregate libraries.\n\n2012-01-10  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cdlili.adb, a-cdlili.ads, a-cihama.adb, a-cihama.ads, a-coinve.adb,\n\ta-coinve.ads, a-ciorse.adb, a-ciorse.ads, a-coorma.adb, a-coorma.ads,\n\ta-cborma.adb, a-cborma.ads, a-cidlli.adb, a-cidlli.ads, a-cimutr.adb,\n\ta-cimutr.ads, a-cihase.adb, a-cihase.ads, a-cohama.adb, a-cohama.ads,\n\ta-coorse.adb, a-coorse.ads, a-cbhama.adb, a-cbhama.ads, a-cborse.adb,\n\ta-cborse.ads, a-comutr.adb, a-comutr.ads, a-ciorma.adb, a-cobove.adb,\n\ta-ciorma.ads, a-cobove.ads, a-convec.adb, a-convec.ads, a-cohase.adb,\n\ta-cohase.ads, a-cbdlli.adb, a-cbdlli.ads, a-cbmutr.adb, a-cbmutr.ads,\n\ta-cbhase.adb, a-cbhase.ads (Reference, Constant_Reference): Declare\n\tcontainer parameter as aliased in/in out.\n\tCode clean ups.\n\n2012-01-10  Bob Duff  <duff@adacore.com>\n\n\t* s-os_lib.ads: Improve comment.\n\n2012-01-10  Geert Bosch  <bosch@adacore.com>\n\n\t* s-gearop.adb (Forward_Eliminate): Avoid improper aliasing\n\tfor complex Scalar.\n\nFrom-SVN: r183060", "tree": {"sha": "294b7686614c59eae2c0a4ac8ed8cd7342de0f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/294b7686614c59eae2c0a4ac8ed8cd7342de0f82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9423ca3fa65282b0ca58d33976c150f78e24f23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9423ca3fa65282b0ca58d33976c150f78e24f23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9423ca3fa65282b0ca58d33976c150f78e24f23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9423ca3fa65282b0ca58d33976c150f78e24f23/comments", "author": null, "committer": null, "parents": [{"sha": "72348e26a5b81571cf11491569d5487203425a0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72348e26a5b81571cf11491569d5487203425a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72348e26a5b81571cf11491569d5487203425a0c"}], "stats": {"total": 3275, "additions": 2248, "deletions": 1027}, "files": [{"sha": "076707496904599b4216564acd25469621bed166", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -1,3 +1,31 @@\n+2012-01-10  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj-nmsc.adb (Check_Library_Attributes):\n+\tKill check for object/source directories for aggregate libraries.\n+\n+2012-01-10  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-cdlili.adb, a-cdlili.ads, a-cihama.adb, a-cihama.ads, a-coinve.adb,\n+\ta-coinve.ads, a-ciorse.adb, a-ciorse.ads, a-coorma.adb, a-coorma.ads,\n+\ta-cborma.adb, a-cborma.ads, a-cidlli.adb, a-cidlli.ads, a-cimutr.adb,\n+\ta-cimutr.ads, a-cihase.adb, a-cihase.ads, a-cohama.adb, a-cohama.ads,\n+\ta-coorse.adb, a-coorse.ads, a-cbhama.adb, a-cbhama.ads, a-cborse.adb,\n+\ta-cborse.ads, a-comutr.adb, a-comutr.ads, a-ciorma.adb, a-cobove.adb,\n+\ta-ciorma.ads, a-cobove.ads, a-convec.adb, a-convec.ads, a-cohase.adb,\n+\ta-cohase.ads, a-cbdlli.adb, a-cbdlli.ads, a-cbmutr.adb, a-cbmutr.ads,\n+\ta-cbhase.adb, a-cbhase.ads (Reference, Constant_Reference): Declare\n+\tcontainer parameter as aliased in/in out.\n+\tCode clean ups.\n+\n+2012-01-10  Bob Duff  <duff@adacore.com>\n+\n+\t* s-os_lib.ads: Improve comment.\n+\n+2012-01-10  Geert Bosch  <bosch@adacore.com>\n+\n+\t* s-gearop.adb (Forward_Eliminate): Avoid improper aliasing\n+\tfor complex Scalar.\n+\n 2012-01-10  Bob Duff  <duff@adacore.com>\n \n \t* sem_intr.adb (Check_Shift): Use RM_Size instead of Esize, when"}, {"sha": "40f5d8f2ead26e098188dd9b67536fade4275e43", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -296,6 +296,33 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Free (Container, X);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased List;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1537,34 +1564,27 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : List;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-   begin\n-      pragma Unreferenced (Container);\n-\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Element =>\n-         Position.Container.Nodes (Position.Node).Element'Unrestricted_Access);\n-   end Constant_Reference;\n-\n    function Reference\n-     (Container : List;\n+     (Container : aliased in out List;\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      pragma Unreferenced (Container);\n-\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      return (Element =>\n-         Position.Container.Nodes (Position.Node).Element'Unrestricted_Access);\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n    end Reference;\n \n    ---------------------"}, {"sha": "6612ea1e533727d30d81012665308fb82e57f65a", "filename": "gcc/ada/a-cbdlli.ads", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -88,6 +88,48 @@ package Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   type Reference_Type\n+     (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : aliased List;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out List;\n+      Position  : Cursor) return Reference_Type;\n+\n    procedure Assign (Target : in out List; Source : List);\n \n    function Copy (Source : List; Capacity : Count_Type := 0) return List;\n@@ -223,48 +265,6 @@ package Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n    end Generic_Sorting;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   type Reference_Type (Element : not null access Element_Type) is\n-   private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Reference_Type);\n-\n-   for Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Reference_Type);\n-\n-   for Reference_Type'Read use Read;\n-\n-   function Constant_Reference\n-     (Container : List;       -- SHOULD BE ALIASED ???\n-      Position  : Cursor) return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : List;       -- SHOULD BE ALIASED ???\n-      Position  : Cursor) return Reference_Type;\n-\n private\n \n    pragma Inline (Next);\n@@ -273,7 +273,7 @@ private\n    type Node_Type is record\n       Prev    : Count_Type'Base;\n       Next    : Count_Type;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n    end record;\n \n    type Node_Array is array (Count_Type range <>) of Node_Type;"}, {"sha": "b14383e321cacec0e5838cd276c04a93c9482eec", "filename": "gcc/ada/a-cbhama.adb", "status": "modified", "additions": 85, "deletions": 7, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -190,6 +190,53 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       HT_Ops.Clear (Container);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Position),\n+                     \"Position cursor in Constant_Reference is bad\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : Map;\n+      Key       : Key_Type) return Constant_Reference_Type\n+   is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -916,16 +963,47 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference (Container : Map; Key : Key_Type)\n-   return Constant_Reference_Type is\n+   function Reference\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type\n+   is\n    begin\n-      return (Element => Container.Element (Key)'Unrestricted_Access);\n-   end Constant_Reference;\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Position),\n+                     \"Position cursor in function Reference is bad\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Reference;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type\n+   is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n-   function Reference (Container : Map; Key : Key_Type)\n-   return Reference_Type is\n    begin\n-      return (Element => Container.Element (Key)'Unrestricted_Access);\n+      if Node = 0 then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n    end Reference;\n \n    -------------"}, {"sha": "78347c5473d5660fbc3139bb47fe1a47d776041a", "filename": "gcc/ada/a-cbhama.ads", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -134,6 +134,56 @@ package Ada.Containers.Bounded_Hashed_Maps is\n    --  Calls Process with the key (with only a constant view) and element (with\n    --  a variable view) of the node designed by the cursor.\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is\n+   private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type;\n+\n    procedure Assign (Target : in out Map; Source : Map);\n    --  If Target denotes the same object as Source, then the operation has no\n    --  effect. If the Target capacity is less then the Source length, then\n@@ -286,47 +336,6 @@ package Ada.Containers.Bounded_Hashed_Maps is\n    function Iterate (Container : Map)\n       return Map_Iterator_Interfaces.Forward_Iterator'class;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is\n-   private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   type Reference_Type (Element : not null access Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Reference_Type);\n-\n-   for Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Reference_Type);\n-\n-   for Reference_Type'Read use Read;\n-\n-   function Constant_Reference\n-     (Container : Map;\n-      Key       : Key_Type)    --  SHOULD BE ALIASED???\n-      return Constant_Reference_Type;\n-\n-   function Reference (Container : Map; Key : Key_Type) return Reference_Type;\n-\n private\n    pragma Inline (Length);\n    pragma Inline (Is_Empty);\n@@ -342,7 +351,7 @@ private\n \n    type Node_Type is record\n       Key     : Key_Type;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n       Next    : Count_Type;\n    end record;\n "}, {"sha": "7e294d3fb7573f1fc0e33d75c8426107aaee7c3e", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 120, "deletions": 34, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -210,6 +210,33 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       HT_Ops.Clear (Container);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1145,21 +1172,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       raise Program_Error with \"attempt to stream reference\";\n    end Read;\n \n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Constant_Reference\n-     (Container : aliased Set;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-      pragma Unreferenced (Container);\n-      S : Set renames Position.Container.all;\n-      N : Node_Type renames S.Nodes (Position.Node);\n-   begin\n-      return (Element => N.Element'Unrestricted_Access);\n-   end Constant_Reference;\n-\n    -------------\n    -- Replace --\n    -------------\n@@ -1581,6 +1593,28 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n            Hash      => Hash,\n            Equivalent_Keys => Equivalent_Key_Node);\n \n+      ------------------------\n+      -- Constant_Reference --\n+      ------------------------\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in set\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Node);\n+         begin\n+            return (Element => N.Element'Access);\n+         end;\n+      end Constant_Reference;\n+\n       --------------\n       -- Contains --\n       --------------\n@@ -1686,6 +1720,69 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          return Key (Position.Container.Nodes (Position.Node).Element);\n       end Key;\n \n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure  Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type)\n+      is\n+      begin\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Read;\n+\n+      ------------------------------\n+      -- Reference_Preserving_Key --\n+      ------------------------------\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type\n+      is\n+      begin\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert\n+           (Vet (Position),\n+            \"bad cursor in function Reference_Preserving_Key\");\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Position has\n+         --  not changed.  ???\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Position.Node);\n+         begin\n+            return (Element => N.Element'Access);\n+         end;\n+      end Reference_Preserving_Key;\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Key       : Key_Type) return Reference_Type\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in set\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Node);\n+         begin\n+            return (Element => N.Element'Access);\n+         end;\n+      end Reference_Preserving_Key;\n+\n       -------------\n       -- Replace --\n       -------------\n@@ -1806,28 +1903,17 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n-      ------------------------------\n-      -- Reference_Preserving_Key --\n-      ------------------------------\n-\n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Position  : Cursor) return Reference_Type\n-      is\n-         N : Node_Type renames Container.Nodes (Position.Node);\n-      begin\n-         return (Element => N.Element'Unrestricted_Access);\n-      end Reference_Preserving_Key;\n+      -----------\n+      -- Write --\n+      -----------\n \n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Reference_Type\n+      procedure Write\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : Reference_Type)\n       is\n-         Position : constant Cursor := Find (Container, Key);\n-         N        : Node_Type renames Container.Nodes (Position.Node);\n       begin\n-         return (Element => N.Element'Unrestricted_Access);\n-      end Reference_Preserving_Key;\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Write;\n \n    end Generic_Keys;\n "}, {"sha": "ceb358204bb27cdb6c0e57446056c97e5c21d65b", "filename": "gcc/ada/a-cbhase.ads", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -433,6 +433,10 @@ package Ada.Containers.Bounded_Hashed_Sets is\n         (Container : aliased in out Set;\n          Position  : Cursor) return Reference_Type;\n \n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type;\n+\n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n          Key       : Key_Type) return Reference_Type;\n@@ -441,13 +445,27 @@ package Ada.Containers.Bounded_Hashed_Sets is\n       type Reference_Type (Element : not null access Element_Type)\n          is null record;\n \n+      use Ada.Streams;\n+\n+      procedure Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type);\n+\n+      for Reference_Type'Read use Read;\n+\n+      procedure Write\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : Reference_Type);\n+\n+      for Reference_Type'Write use Write;\n+\n    end Generic_Keys;\n \n private\n    pragma Inline (Next);\n \n    type Node_Type is record\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n       Next    : Count_Type;\n    end record;\n "}, {"sha": "e40c7bfc82d645174eaadc34ec0291240216368e", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -588,6 +588,36 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       pragma Assert (Count = Container_Count);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node = Root_Node (Container) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      --  Implement Vet for multiway tree???\n+      --  pragma Assert (Vet (Position),\n+      --                 \"Position cursor in Constant_Reference is bad\");\n+\n+      return (Element => Container.Elements (Position.Node)'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -2464,26 +2494,30 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-      pragma Unreferenced (Container);\n-   begin\n-      return\n-        (Element =>\n-           Position.Container.Elements (Position.Node)'Unchecked_Access);\n-   end Constant_Reference;\n-\n    function Reference\n-     (Container : aliased Tree;\n+     (Container : aliased in out Tree;\n       Position  : Cursor) return Reference_Type\n    is\n-      pragma Unreferenced (Container);\n    begin\n-      return\n-        (Element =>\n-           Position.Container.Elements (Position.Node)'Unchecked_Access);\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node = Root_Node (Container) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      --  Implement Vet for multiway tree???\n+      --  pragma Assert (Vet (Position),\n+      --                 \"Position cursor in Constant_Reference is bad\");\n+\n+      return (Element => Container.Elements (Position.Node)'Access);\n    end Reference;\n \n    --------------------"}, {"sha": "46263088cd376eaf9a028c4e9e46ccae2d485fba", "filename": "gcc/ada/a-cbmutr.ads", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbmutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cbmutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -107,6 +107,14 @@ package Ada.Containers.Bounded_Multiway_Trees is\n      (Element : not null access Element_Type) is private\n         with Implicit_Dereference => Element;\n \n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Tree;\n+      Position  : Cursor) return Reference_Type;\n+\n    procedure Assign (Target : in out Tree; Source : Tree);\n \n    function Copy (Source : Tree; Capacity : Count_Type := 0) return Tree;\n@@ -375,6 +383,7 @@ private\n \n    type Reference_Type\n      (Element : not null access Element_Type) is null record;\n+\n    procedure Write\n      (Stream : not null access Root_Stream_Type'Class;\n       Item   : Reference_Type);\n@@ -385,14 +394,6 @@ private\n       Item   : out Reference_Type);\n    for Reference_Type'Read use Read;\n \n-   function Constant_Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Reference_Type;\n-\n    Empty_Tree : constant Tree := (Capacity => 0, others => <>);\n \n    No_Element : constant Cursor := Cursor'(others => <>);"}, {"sha": "9dec108219b00b3d2599e2907a93bd3b410acdd1", "filename": "gcc/ada/a-cborma.adb", "status": "modified", "additions": 81, "deletions": 7, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cborma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cborma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -402,6 +402,53 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       return Node.Color;\n    end Color;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position.Node),\n+                     \"Position cursor in Constant_Reference is bad\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : Map;\n+      Key       : Key_Type) return Constant_Reference_Type\n+   is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1318,20 +1365,47 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : Map;\n-      Key       : Key_Type) return Constant_Reference_Type\n+   function Reference\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type\n    is\n    begin\n-      return (Element => Container.Element (Key)'Unrestricted_Access);\n-   end Constant_Reference;\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position.Node),\n+                     \"Position cursor in function Reference is bad\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Reference;\n \n    function Reference\n-     (Container : Map;\n+     (Container : aliased in out Map;\n       Key       : Key_Type) return Reference_Type\n    is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n    begin\n-      return (Element => Container.Element (Key)'Unrestricted_Access);\n+      if Node = 0 then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n    end Reference;\n \n    -------------"}, {"sha": "bfb6f016028cafc66804b86ce65717b039e6f3ea", "filename": "gcc/ada/a-cborma.ads", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cborma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cborma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -50,7 +50,7 @@ package Ada.Containers.Bounded_Ordered_Maps is\n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n    type Map (Capacity : Count_Type) is tagged private with\n-      constant_Indexing => Constant_Reference,\n+      Constant_Indexing => Constant_Reference,\n       Variable_Indexing => Reference,\n       Default_Iterator  => Iterate,\n       Iterator_Element  => Element_Type;\n@@ -97,6 +97,55 @@ package Ada.Containers.Bounded_Ordered_Maps is\n       Process   : not null access\n                     procedure (Key : Key_Type; Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type;\n+\n    procedure Assign (Target : in out Map; Source : Map);\n \n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map;\n@@ -183,46 +232,6 @@ package Ada.Containers.Bounded_Ordered_Maps is\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   type Reference_Type (Element : not null access Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Reference_Type);\n-\n-   for Reference_Type'Read use Read;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Reference_Type);\n-\n-   for Reference_Type'Write use Write;\n-\n-   function Constant_Reference\n-     (Container : Map;\n-      Key       : Key_Type)    --  SHOULD BE ALIASED ???\n-      return Constant_Reference_Type;\n-\n-   function Reference (Container : Map; Key : Key_Type) return Reference_Type;\n-\n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n@@ -251,7 +260,7 @@ private\n       Right   : Count_Type;\n       Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n       Key     : Key_Type;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n    end record;\n \n    package Tree_Types is"}, {"sha": "62417f36b1170bef54cf41bb5b34f987c4656594", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 117, "deletions": 55, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -402,6 +402,35 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       return Node.Color;\n    end Color;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container, Position.Node),\n+         \"bad cursor in Constant_Reference\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+      begin\n+         return (Element => N.Element'Access);\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -697,6 +726,28 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n                  else Cursor'(Container'Unrestricted_Access, Node));\n       end Ceiling;\n \n+      ------------------------\n+      -- Constant_Reference --\n+      ------------------------\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in set\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Node);\n+         begin\n+            return (Element => N.Element'Access);\n+         end;\n+      end Constant_Reference;\n+\n       --------------\n       -- Contains --\n       --------------\n@@ -822,6 +873,69 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          return Key (Position.Container.Nodes (Position.Node).Element);\n       end Key;\n \n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure  Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type)\n+      is\n+      begin\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Read;\n+\n+      ------------------------------\n+      -- Reference_Preserving_Key --\n+      ------------------------------\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type\n+      is\n+      begin\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert\n+           (Vet (Container, Position.Node),\n+            \"bad cursor in function Reference_Preserving_Key\");\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Position has\n+         --  not changed.  ???\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Position.Node);\n+         begin\n+            return (Element => N.Element'Access);\n+         end;\n+      end Reference_Preserving_Key;\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Key       : Key_Type) return Reference_Type\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in set\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Node);\n+         begin\n+            return (Element => N.Element'Access);\n+         end;\n+      end Reference_Preserving_Key;\n+\n       -------------\n       -- Replace --\n       -------------\n@@ -900,45 +1014,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Constant_Reference_Type\n-      is\n-         Position : constant Cursor := Find (Container, Key);\n-\n-      begin\n-         if Position.Node = 0 then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n-\n-         return\n-           (Element =>\n-              Container.Nodes (Position.Node).Element'Unrestricted_Access);\n-      end Reference_Preserving_Key;\n-\n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Reference_Type\n-      is\n-         Position : constant Cursor := Find (Container, Key);\n-\n-      begin\n-         if Position.Node = 0 then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n-\n-         return\n-           (Element =>\n-              Container.Nodes (Position.Node).Element'Unrestricted_Access);\n-      end Reference_Preserving_Key;\n-\n-      procedure  Read\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Item   : out Reference_Type)\n-      is\n-      begin\n-         raise Program_Error with \"attempt to stream reference\";\n-      end Read;\n+      -----------\n+      -- Write --\n+      -----------\n \n       procedure Write\n         (Stream : not null access Root_Stream_Type'Class;\n@@ -1585,22 +1663,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       raise Program_Error with \"attempt to stream reference\";\n    end Read;\n \n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Constant_Reference (Container : Set; Position : Cursor)\n-   return Constant_Reference_Type\n-   is\n-   begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Element =>\n-        Container.Nodes (Position.Node).Element'Unrestricted_Access);\n-   end Constant_Reference;\n-\n    -------------\n    -- Replace --\n    -------------"}, {"sha": "6a8bff96a0d33de6c22153f3c6c0445dcb784201", "filename": "gcc/ada/a-cborse.ads", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cborse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cborse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -65,16 +65,6 @@ package Ada.Containers.Bounded_Ordered_Sets is\n    package Set_Iterator_Interfaces is new\n      Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is\n-   private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   function Constant_Reference\n-     (Container : Set; Position : Cursor)\n-   return Constant_Reference_Type;\n-\n    function \"=\" (Left, Right : Set) return Boolean;\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n@@ -98,6 +88,16 @@ package Ada.Containers.Bounded_Ordered_Sets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is\n+   private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n    procedure Assign (Target : in out Set; Source : Set);\n \n    function Copy (Source : Set; Capacity : Count_Type := 0) return Set;\n@@ -263,6 +263,10 @@ package Ada.Containers.Bounded_Ordered_Sets is\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type;\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n          Key       : Key_Type) return Constant_Reference_Type;\n \n       function Reference_Preserving_Key\n@@ -297,7 +301,7 @@ private\n       Left    : Count_Type;\n       Right   : Count_Type;\n       Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n    end record;\n \n    package Tree_Types is"}, {"sha": "55defaec254c2ff7368f184bc8a76d165571b2a3", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -219,6 +219,29 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       pragma Warnings (On);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased List;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+\n+      return (Element => Position.Node.Element'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1277,31 +1300,22 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : List;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-   begin\n-      pragma Unreferenced (Container);\n-\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Element => Position.Node.Element'Access);\n-   end Constant_Reference;\n-\n    function Reference\n-     (Container : List;\n+     (Container : aliased in out List;\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      pragma Unreferenced (Container);\n-\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n+      if Position.Container /= Container'Unchecked_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+\n       return (Element => Position.Node.Element'Access);\n    end Reference;\n "}, {"sha": "4799198a39a95e506b3b259fc4a35f824400212c", "filename": "gcc/ada/a-cdlili.ads", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -90,6 +90,48 @@ package Ada.Containers.Doubly_Linked_Lists is\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   type Reference_Type\n+     (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : aliased List;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out List;\n+      Position  : Cursor) return Reference_Type;\n+\n    procedure Assign (Target : in out List; Source : List);\n \n    function Copy (Source : List) return List;\n@@ -222,48 +264,6 @@ package Ada.Containers.Doubly_Linked_Lists is\n \n    end Generic_Sorting;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   type Reference_Type (Element : not null access Element_Type) is\n-   private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Reference_Type);\n-\n-   for Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Reference_Type);\n-\n-   for Reference_Type'Read use Read;\n-\n-   function Constant_Reference\n-     (Container : List; Position : Cursor)    --  SHOULD BE ALIASED\n-   return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : List; Position : Cursor)    --  SHOULD BE ALIASED\n-   return Reference_Type;\n-\n private\n \n    pragma Inline (Next);"}, {"sha": "183f6a8614a5bc8aa97be56e4b50786af3ea208c", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -242,6 +242,33 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Free (X);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased List;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1303,27 +1330,26 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference (Container : List; Position : Cursor)\n-   return Constant_Reference_Type is\n+   function Reference\n+     (Container : aliased in out List;\n+      Position  : Cursor) return Reference_Type\n+   is\n    begin\n-      pragma Unreferenced (Container);\n-\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      return (Element => Position.Node.Element.all'Access);\n-   end Constant_Reference;\n-\n-   function Reference (Container : List; Position : Cursor)\n-   return Reference_Type is\n-   begin\n-      pragma Unreferenced (Container);\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n \n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+\n       return (Element => Position.Node.Element.all'Access);\n    end Reference;\n "}, {"sha": "762693c7b9dd68da45a2b6b17ffc71b1cfb0aef2", "filename": "gcc/ada/a-cidlli.ads", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -90,6 +90,48 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   type Reference_Type\n+     (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : aliased List;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out List;\n+      Position  : Cursor) return Reference_Type;\n+\n    procedure Assign (Target : in out List; Source : List);\n \n    function Copy (Source : List) return List;\n@@ -203,50 +245,6 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Start     : Cursor)\n       return List_Iterator_Interfaces.Reversible_Iterator'class;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   type Reference_Type (Element : not null access Element_Type) is\n-   private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Reference_Type);\n-\n-   for Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Reference_Type);\n-\n-   for Reference_Type'Read use Read;\n-\n-   function Constant_Reference\n-     (Container : List;\n-      Position  : Cursor)    --  SHOULD BE ALIASED ???\n-      return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : List;\n-      Position  : Cursor)    --  SHOULD BE ALIASED ???\n-      return Reference_Type;\n-\n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting is"}, {"sha": "35419020c1097d099b9dee45feaf2c9980f5e49d", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 83, "deletions": 16, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -189,6 +189,55 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       HT_Ops.Clear (Container.HT);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Position),\n+         \"Position cursor in Constant_Reference is bad\");\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return Constant_Reference_Type\n+   is\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+\n+   begin\n+      if Node = null then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      if Node.Element = null then\n+         raise Program_Error with \"key has no element\";\n+      end if;\n+\n+      return (Element => Node.Element.all'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -955,31 +1004,49 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : Map;\n-      Key       : Key_Type) return Constant_Reference_Type\n-   is\n-   begin\n-      return (Element =>\n-        Container.Find (Key).Node.Element.all'Unrestricted_Access);\n-   end Constant_Reference;\n-\n    function Reference\n-     (Container : Map;\n-      Key       : Key_Type) return Reference_Type\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type\n    is\n    begin\n-      return (Element =>\n-         Container.Find (Key).Node.Element.all'Unrestricted_Access);\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Position),\n+         \"Position cursor in function Reference is bad\");\n+\n+      return (Element => Position.Node.Element.all'Access);\n    end Reference;\n \n    function Reference\n      (Container : aliased in out Map;\n-      Position  : Cursor) return Reference_Type\n+      Key       : Key_Type) return Reference_Type\n    is\n-      pragma Unreferenced (Container);\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+\n    begin\n-      return (Element => Element (Position)'Unrestricted_Access);\n+      if Node = null then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      if Node.Element = null then\n+         raise Program_Error with \"key has no element\";\n+      end if;\n+\n+      return (Element => Node.Element.all'Access);\n    end Reference;\n \n    -------------"}, {"sha": "2cd41eb0b469b8601aaee892e935dfff36785533", "filename": "gcc/ada/a-cihama.ads", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cihama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cihama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -134,6 +134,55 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n    --  Calls Process with the key (with only a constant view) and element (with\n    --  a variable view) of the node designed by the cursor.\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type;\n+\n    procedure Assign (Target : in out Map; Source : Map);\n \n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map;\n@@ -255,52 +304,6 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n    --  Returns the result of calling Equivalent_Keys with key Left and the node\n    --  designated by Right.\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   type Reference_Type (Element : not null access Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Reference_Type);\n-\n-   for Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Reference_Type);\n-\n-   for Reference_Type'Read use Read;\n-\n-   function Constant_Reference\n-     (Container : Map;\n-      Key       : Key_Type)    --  SHOULD BE ALIASED ???\n-      return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : Map;\n-      Key       : Key_Type) return Reference_Type;\n-\n-   function Reference\n-     (Container : aliased in out Map;\n-      Position  : Cursor) return Reference_Type;\n-\n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));"}, {"sha": "6255675550e36415c66784fdac3144724a24bab0", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 130, "deletions": 31, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -204,6 +204,33 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       HT_Ops.Clear (Container.HT);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1220,19 +1247,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          raise;\n    end Read_Node;\n \n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Constant_Reference\n-     (Container : aliased Set;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-      pragma Unreferenced (Container);\n-   begin\n-      return (Element => Position.Node.Element.all'Access);\n-   end Constant_Reference;\n-\n    -------------\n    -- Replace --\n    -------------\n@@ -1892,6 +1906,29 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            Hash      => Hash,\n            Equivalent_Keys => Equivalent_Key_Node);\n \n+      ------------------------\n+      -- Constant_Reference --\n+      ------------------------\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.HT, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error with \"Key not in set\";\n+         end if;\n+\n+         if Node.Element = null then\n+            raise Program_Error with \"Node has no element\";\n+         end if;\n+\n+         return (Element => Node.Element.all'Access);\n+      end Constant_Reference;\n+\n       --------------\n       -- Contains --\n       --------------\n@@ -2001,6 +2038,74 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return Key (Position.Node.Element.all);\n       end Key;\n \n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type)\n+      is\n+      begin\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Read;\n+\n+      ------------------------------\n+      -- Reference_Preserving_Key --\n+      ------------------------------\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type\n+      is\n+      begin\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n+         end if;\n+\n+         if Position.Node.Element = null then\n+            raise Program_Error with \"Node has no element\";\n+         end if;\n+\n+         pragma Assert\n+           (Vet (Position),\n+            \"bad cursor in function Reference_Preserving_Key\");\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Position has\n+         --  not changed.  ???\n+\n+         return (Element => Position.Node.Element.all'Access);\n+      end Reference_Preserving_Key;\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Key       : Key_Type) return Reference_Type\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.HT, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error with \"Key not in set\";\n+         end if;\n+\n+         if Node.Element = null then\n+            raise Program_Error with \"Node has no element\";\n+         end if;\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Key has not\n+         --  changed.  ???\n+\n+         return (Element => Node.Element.all'Access);\n+      end Reference_Preserving_Key;\n+\n       -------------\n       -- Replace --\n       -------------\n@@ -2022,6 +2127,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Replace_Element (Container.HT, Node, New_Item);\n       end Replace;\n \n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n+\n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n@@ -2123,27 +2232,17 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n-      ------------------------------\n-      -- Reference_Preserving_Key --\n-      ------------------------------\n-\n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Position  : Cursor) return Reference_Type\n-      is\n-         pragma Unreferenced (Container);\n-      begin\n-         return (Element => Position.Node.Element.all'Access);\n-      end Reference_Preserving_Key;\n+      -----------\n+      -- Write --\n+      -----------\n \n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Reference_Type\n+      procedure Write\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : Reference_Type)\n       is\n-         Position : constant Cursor := Find (Container, Key);\n       begin\n-         return (Element => Position.Node.Element.all'Access);\n-      end Reference_Preserving_Key;\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Write;\n \n    end Generic_Keys;\n "}, {"sha": "db59bdb7a002f4cd0654b4a59cab6ccf93de97a0", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -150,8 +150,7 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Constant_Reference\n      (Container : aliased Set;\n-      Position  : Cursor)\n-   return Constant_Reference_Type;\n+      Position  : Cursor) return Constant_Reference_Type;\n \n    procedure Assign (Target : in out Set; Source : Set);\n \n@@ -420,13 +419,31 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n         (Container : aliased in out Set;\n          Position  : Cursor) return Reference_Type;\n \n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type;\n+\n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n          Key       : Key_Type) return Reference_Type;\n \n    private\n       type Reference_Type (Element : not null access Element_Type)\n          is null record;\n+\n+      use Ada.Streams;\n+\n+      procedure Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type);\n+\n+      for Reference_Type'Read use Read;\n+\n+      procedure Write\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : Reference_Type);\n+\n+      for Reference_Type'Write use Write;\n    end Generic_Keys;\n \n private"}, {"sha": "c3887a57769b2a30c274a410c2f348b0c5111bca", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -441,6 +441,40 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       pragma Assert (Children_Count = Container_Count);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node = Root_Node (Container) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      --  Implement Vet for multiway tree???\n+      --  pragma Assert (Vet (Position),\n+      --                 \"Position cursor in Constant_Reference is bad\");\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1980,24 +2014,34 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-   begin\n-      pragma Unreferenced (Container);\n-\n-      return (Element => Position.Node.Element.all'Unchecked_Access);\n-   end Constant_Reference;\n-\n    function Reference\n-     (Container : aliased Tree;\n+     (Container : aliased in out Tree;\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      pragma Unreferenced (Container);\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node = Root_Node (Container) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      --  Implement Vet for multiway tree???\n+      --  pragma Assert (Vet (Position),\n+      --                 \"Position cursor in Constant_Reference is bad\");\n \n-      return (Element => Position.Node.Element.all'Unchecked_Access);\n+      return (Element => Position.Node.Element.all'Access);\n    end Reference;\n \n    --------------------"}, {"sha": "87c0e41f1d54622745fe50af7bef019501afe882", "filename": "gcc/ada/a-cimutr.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cimutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cimutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -109,6 +109,14 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n      (Element : not null access Element_Type) is private\n         with Implicit_Dereference => Element;\n \n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Tree;\n+      Position  : Cursor) return Reference_Type;\n+\n    procedure Assign (Target : in out Tree; Source : Tree);\n \n    function Copy (Source : Tree) return Tree;\n@@ -400,14 +408,6 @@ private\n \n    for Reference_Type'Write use Write;\n \n-   function Constant_Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Reference_Type;\n-\n    Empty_Tree : constant Tree := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (others => <>);"}, {"sha": "15efbc7243df4ad92e5a64ce28fa970fc4519d00", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -357,13 +357,47 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    -- Constant_Reference --\n    ------------------------\n \n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"Position cursor in Constant_Reference is bad\");\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Constant_Reference;\n+\n    function Constant_Reference\n      (Container : Map;\n       Key       : Key_Type) return Constant_Reference_Type\n    is\n-      Node : aliased Element_Type := Element (Container, Key);\n+      Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n    begin\n-      return (Element => Node'Access);\n+      if Node = null then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      if Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      return (Element => Node.Element.all'Access);\n    end Constant_Reference;\n \n    --------------\n@@ -1305,13 +1339,46 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    ---------------\n \n    function Reference\n-     (Container : Map;\n-      Key       : Key_Type)\n-      return Reference_Type\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type\n    is\n-      Node : aliased Element_Type := Element (Container, Key);\n    begin\n-      return (Element => Node'Access);\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"Position cursor in function Reference is bad\");\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Reference;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type\n+   is\n+      Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n+   begin\n+      if Node = null then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      if Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      return (Element => Node.Element.all'Access);\n    end Reference;\n \n    -------------"}, {"sha": "814f062537e76a093d1fcce0c11b897b3b6629b2", "filename": "gcc/ada/a-ciorma.ads", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-ciorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-ciorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -50,7 +50,7 @@ package Ada.Containers.Indefinite_Ordered_Maps is\n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n    type Map is tagged private\n-   with constant_Indexing => Constant_Reference,\n+   with Constant_Indexing => Constant_Reference,\n         Variable_Indexing => Reference,\n         Default_Iterator  => Iterate,\n         Iterator_Element  => Element_Type;\n@@ -96,6 +96,31 @@ package Ada.Containers.Indefinite_Ordered_Maps is\n       Process   : not null access procedure (Key     : Key_Type;\n                                              Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type;\n+\n    procedure Assign (Target : in out Map; Source : Map);\n \n    function Copy (Source : Map) return Map;\n@@ -176,23 +201,6 @@ package Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   type Reference_Type (Element : not null access Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   function Constant_Reference\n-     (Container : Map;\n-      Key       : Key_Type) return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : Map;\n-       Key      : Key_Type) return Reference_Type;\n-\n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));"}, {"sha": "ff929067237002c739c22f12f3cde7886ec71eaf", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 123, "deletions": 51, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -372,6 +372,35 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       return Node.Color;\n    end Color;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error with \"Node has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container.Tree, Position.Node),\n+         \"bad cursor in Constant_Reference\");\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -733,6 +762,29 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n                  else Cursor'(Container'Unrestricted_Access, Node));\n       end Ceiling;\n \n+      ------------------------\n+      -- Constant_Reference --\n+      ------------------------\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error with \"Key not in set\";\n+         end if;\n+\n+         if Node.Element = null then\n+            raise Program_Error with \"Node has no element\";\n+         end if;\n+\n+         return (Element => Node.Element.all'Access);\n+      end Constant_Reference;\n+\n       --------------\n       -- Contains --\n       --------------\n@@ -889,6 +941,74 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          Replace_Element (Container.Tree, Node, New_Item);\n       end Replace;\n \n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type)\n+      is\n+      begin\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Read;\n+\n+      ------------------------------\n+      -- Reference_Preserving_Key --\n+      ------------------------------\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type\n+      is\n+      begin\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n+         end if;\n+\n+         if Position.Node.Element = null then\n+            raise Program_Error with \"Node has no element\";\n+         end if;\n+\n+         pragma Assert\n+           (Vet (Container.Tree, Position.Node),\n+            \"bad cursor in function Reference_Preserving_Key\");\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Position has\n+         --  not changed.  ???\n+\n+         return (Element => Position.Node.Element.all'Access);\n+      end Reference_Preserving_Key;\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Key       : Key_Type) return Reference_Type\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error with \"Key not in set\";\n+         end if;\n+\n+         if Node.Element = null then\n+            raise Program_Error with \"Node has no element\";\n+         end if;\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Key has not\n+         --  changed.  ???\n+\n+         return (Element => Node.Element.all'Access);\n+      end Reference_Preserving_Key;\n+\n       -----------------------------------\n       -- Update_Element_Preserving_Key --\n       -----------------------------------\n@@ -955,41 +1075,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Constant_Reference_Type\n-      is\n-         Position : constant Cursor := Find (Container, Key);\n-\n-      begin\n-         if Position.Container = null then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n-\n-         return (Element => Position.Node.Element);\n-      end Reference_Preserving_Key;\n-\n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Reference_Type\n-      is\n-         Position : constant Cursor := Find (Container, Key);\n-\n-      begin\n-         if Position.Container = null then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n-\n-         return (Element => Position.Node.Element);\n-      end Reference_Preserving_Key;\n-\n-      procedure Read\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Item   : out Reference_Type)\n-      is\n-      begin\n-         raise Program_Error with \"attempt to stream reference\";\n-      end Read;\n+      -----------\n+      -- Write --\n+      -----------\n \n       procedure Write\n         (Stream : not null access Root_Stream_Type'Class;\n@@ -1653,22 +1741,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       raise Program_Error with \"attempt to stream reference\";\n    end Read;\n \n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Constant_Reference (Container : Set; Position : Cursor)\n-   return Constant_Reference_Type\n-   is\n-      pragma Unreferenced (Container);\n-   begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Element => Position.Node.Element.all'Access);\n-   end Constant_Reference;\n-\n    -------------\n    -- Replace --\n    -------------"}, {"sha": "5e2f84d2490a79678d32d85656fe9d1c9a01271c", "filename": "gcc/ada/a-ciorse.ads", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -67,27 +67,6 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n    package Set_Iterator_Interfaces is new\n      Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n-   type Constant_Reference_Type\n-     (Element : not null access constant Element_Type) is\n-   private with\n-      Implicit_Dereference => Element;\n-\n-   function Constant_Reference\n-     (Container : Set;\n-      Position  : Cursor) return Constant_Reference_Type;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n    function \"=\" (Left, Right : Set) return Boolean;\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n@@ -111,6 +90,27 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n+   type Constant_Reference_Type\n+     (Element : not null access constant Element_Type) is\n+   private with\n+      Implicit_Dereference => Element;\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n    procedure Assign (Target : in out Set; Source : Set);\n \n    function Copy (Source : Set) return Set;\n@@ -292,6 +292,10 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type;\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n          Key       : Key_Type) return Constant_Reference_Type;\n \n       function Reference_Preserving_Key"}, {"sha": "99659abc79535ecbeed14727d120aa86cd42ea08", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -378,6 +378,52 @@ package body Ada.Containers.Bounded_Vectors is\n       Container.Last := No_Index;\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n+      if Position.Index > Position.Container.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      declare\n+         A : Elements_Array renames Container.Elements;\n+         I : constant Count_Type := To_Array_Index (Position.Index);\n+      begin\n+         return (Element => A (I)'Access);\n+      end;\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return Constant_Reference_Type\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      declare\n+         A : Elements_Array renames Container.Elements;\n+         I : constant Count_Type := To_Array_Index (Index);\n+      begin\n+         return (Element => A (I)'Access);\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -2071,76 +2117,46 @@ package body Ada.Containers.Bounded_Vectors is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : Vector;\n-      Position  : Cursor)    --  SHOULD BE ALIASED\n-      return Constant_Reference_Type\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Position  : Cursor) return Reference_Type\n    is\n    begin\n-      pragma Unreferenced (Container);\n-\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n-\n-      return\n-       (Element =>\n-          Position.Container.Elements\n-            (To_Array_Index (Position.Index))'Access);\n-   end Constant_Reference;\n-\n-   function Constant_Reference\n-     (Container : Vector;\n-      Position  : Index_Type)\n-      return Constant_Reference_Type\n-   is\n-   begin\n-      if (Position) > Container.Last then\n-         raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      return (Element =>\n-                Container.Elements (To_Array_Index (Position))'Access);\n-   end Constant_Reference;\n-\n-   function Reference\n-     (Container : Vector;\n-      Position  : Cursor)\n-      return Reference_Type\n-   is\n-   begin\n-      pragma Unreferenced (Container);\n-\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n       if Position.Index > Position.Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n-      return\n-        (Element =>\n-           Position.Container.Elements\n-             (To_Array_Index (Position.Index))'Access);\n+      declare\n+         A : Elements_Array renames Container.Elements;\n+         I : constant Count_Type := To_Array_Index (Position.Index);\n+      begin\n+         return (Element => A (I)'Access);\n+      end;\n    end Reference;\n \n    function Reference\n-     (Container : Vector;\n-      Position  : Index_Type)\n-      return Reference_Type\n+     (Container : aliased in out Vector;\n+      Index     : Index_Type) return Reference_Type\n    is\n    begin\n-      if Position > Container.Last then\n+      if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n-      else\n-         return (Element =>\n-           Container.Elements (To_Array_Index (Position))'Unrestricted_Access);\n       end if;\n+\n+      declare\n+         A : Elements_Array renames Container.Elements;\n+         I : constant Count_Type := To_Array_Index (Index);\n+      begin\n+         return (Element => A (I)'Access);\n+      end;\n    end Reference;\n \n    ---------------------"}, {"sha": "6bcb0a407156edba955c3e75e4de905ea5fb6262", "filename": "gcc/ada/a-cobove.ads", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cobove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cobove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -142,6 +142,56 @@ package Ada.Containers.Bounded_Vectors is\n       Position  : Cursor;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is\n+   private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Position  : Cursor) return Reference_Type;\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Index     : Index_Type) return Reference_Type;\n+\n    procedure Assign (Target : in out Vector; Source : Vector);\n \n    function Copy (Source : Vector; Capacity : Count_Type := 0) return Vector;\n@@ -308,54 +358,6 @@ package Ada.Containers.Bounded_Vectors is\n       Start     : Cursor)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'class;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is\n-   private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   type Reference_Type (Element : not null access Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Reference_Type);\n-\n-   for Reference_Type'Read use Read;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Reference_Type);\n-\n-   for Reference_Type'Write use Write;\n-\n-   function Constant_Reference\n-     (Container : Vector; Position : Cursor)    --  SHOULD BE ALIASED\n-   return Constant_Reference_Type;\n-\n-   function Constant_Reference\n-     (Container : Vector; Position : Index_Type)\n-   return Constant_Reference_Type;\n-\n-   function Reference (Container : Vector; Position : Cursor)\n-   return Reference_Type;\n-\n-   function Reference (Container : Vector; Position : Index_Type)\n-   return Reference_Type;\n-\n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting is"}, {"sha": "8adcb1af35ad1f97f853b3681852ab3608248c07", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 62, "deletions": 20, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -188,6 +188,46 @@ package body Ada.Containers.Hashed_Maps is\n       HT_Ops.Clear (Container.HT);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Position),\n+         \"Position cursor in Constant_Reference is bad\");\n+\n+      return (Element => Position.Node.Element'Access);\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return Constant_Reference_Type\n+   is\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+\n+   begin\n+      if Node = null then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      return (Element => Node.Element'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -861,38 +901,40 @@ package body Ada.Containers.Hashed_Maps is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-      pragma Unreferenced (Container);\n-   begin\n-      return (Element => Element (Position)'Unrestricted_Access);\n-   end Constant_Reference;\n-\n    function Reference\n      (Container : aliased in out Map;\n       Position  : Cursor) return Reference_Type\n    is\n-      pragma Unreferenced (Container);\n    begin\n-      return (Element => Element (Position)'Unrestricted_Access);\n-   end Reference;\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n \n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Key       : Key_Type) return Constant_Reference_Type\n-   is\n-   begin\n-      return (Element => Container.Element (Key)'Unrestricted_Access);\n-   end Constant_Reference;\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Position),\n+         \"Position cursor in function Reference is bad\");\n+\n+      return (Element => Position.Node.Element'Access);\n+   end Reference;\n \n    function Reference\n      (Container : aliased in out Map;\n       Key       : Key_Type) return Reference_Type\n    is\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+\n    begin\n-      return (Element => Container.Element (Key)'Unrestricted_Access);\n+      if Node = null then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      return (Element => Node.Element'Access);\n    end Reference;\n \n    ---------------"}, {"sha": "a5b2ff3e1d7d4bb92ba0d7a81d6ead467324595a", "filename": "gcc/ada/a-cohama.ads", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -148,6 +148,55 @@ package Ada.Containers.Hashed_Maps is\n    --  Calls Process with the key (with only a constant view) and element (with\n    --  a variable view) of the node designed by the cursor.\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type;\n+\n    procedure Assign (Target : in out Map; Source : Map);\n \n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map;\n@@ -277,55 +326,6 @@ package Ada.Containers.Hashed_Maps is\n    --  Returns the result of calling Equivalent_Keys with key Left and the node\n    --  designated by Right.\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n-   type Reference_Type (Element : not null access Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Reference_Type);\n-\n-   for Reference_Type'Write use Write;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Reference_Type);\n-\n-   for Reference_Type'Read use Read;\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Position  : Cursor) return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : aliased in out Map;\n-      Position  : Cursor) return Reference_Type;\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Key       : Key_Type) return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : aliased in out Map;\n-      Key       : Key_Type) return Reference_Type;\n-\n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n@@ -354,7 +354,7 @@ private\n \n    type Node_Type is limited record\n       Key     : Key_Type;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n       Next    : Node_Access;\n    end record;\n "}, {"sha": "dd09da5a17c2fafc6c1d83f1d56a6d5eb8c645f0", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 110, "deletions": 30, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -198,6 +198,29 @@ package body Ada.Containers.Hashed_Sets is\n       HT_Ops.Clear (Container.HT);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+\n+      return (Element => Position.Node.Element'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1126,19 +1149,6 @@ package body Ada.Containers.Hashed_Sets is\n          raise;\n    end Read_Node;\n \n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Constant_Reference\n-     (Container : aliased Set;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-      pragma Unreferenced (Container);\n-   begin\n-      return (Element => Position.Node.Element'Unrestricted_Access);\n-   end Constant_Reference;\n-\n    -------------\n    -- Replace --\n    -------------\n@@ -1720,6 +1730,25 @@ package body Ada.Containers.Hashed_Sets is\n            Hash      => Hash,\n            Equivalent_Keys => Equivalent_Key_Node);\n \n+      ------------------------\n+      -- Constant_Reference --\n+      ------------------------\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.HT, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error with \"Key not in set\";\n+         end if;\n+\n+         return (Element => Node.Element'Access);\n+      end Constant_Reference;\n+\n       --------------\n       -- Contains --\n       --------------\n@@ -1831,6 +1860,66 @@ package body Ada.Containers.Hashed_Sets is\n          return Key (Position.Node.Element);\n       end Key;\n \n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type)\n+      is\n+      begin\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Read;\n+\n+      ------------------------------\n+      -- Reference_Preserving_Key --\n+      ------------------------------\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type\n+      is\n+      begin\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert\n+           (Vet (Position),\n+            \"bad cursor in function Reference_Preserving_Key\");\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Position has\n+         --  not changed.  ???\n+\n+         return (Element => Position.Node.Element'Access);\n+      end Reference_Preserving_Key;\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Key       : Key_Type) return Reference_Type\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.HT, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error with \"Key not in set\";\n+         end if;\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Key has not\n+         --  changed.  ???\n+\n+         return (Element => Node.Element'Access);\n+      end Reference_Preserving_Key;\n+\n       -------------\n       -- Replace --\n       -------------\n@@ -1952,27 +2041,18 @@ package body Ada.Containers.Hashed_Sets is\n          raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n-      ------------------------------\n-      -- Reference_Preserving_Key --\n-      ------------------------------\n+      -----------\n+      -- Write --\n+      -----------\n \n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Position  : Cursor) return Reference_Type\n+      procedure Write\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : Reference_Type)\n       is\n-         pragma Unreferenced (Container);\n       begin\n-         return (Element => Position.Node.Element'Unrestricted_Access);\n-      end Reference_Preserving_Key;\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Write;\n \n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Reference_Type\n-      is\n-         Position : constant Cursor := Find (Container, Key);\n-      begin\n-         return (Element => Position.Node.Element'Unrestricted_Access);\n-      end Reference_Preserving_Key;\n    end Generic_Keys;\n \n end Ada.Containers.Hashed_Sets;"}, {"sha": "97b209d280d4dd421c8c6befbf6dae564a968887", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -52,7 +52,7 @@ package Ada.Containers.Hashed_Sets is\n \n    type Set is tagged private\n    with\n-      constant_Indexing => Constant_Reference,\n+      Constant_Indexing => Constant_Reference,\n       Default_Iterator  => Iterate,\n       Iterator_Element  => Element_Type;\n \n@@ -145,10 +145,6 @@ package Ada.Containers.Hashed_Sets is\n    --  Calls Process with the element (having only a constant view) of the node\n    --  designed by the cursor.\n \n-   procedure Assign (Target : in out Set; Source : Set);\n-\n-   function Copy (Source : Set; Capacity : Count_Type := 0) return Set;\n-\n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is private\n         with Implicit_Dereference => Element;\n@@ -157,6 +153,10 @@ package Ada.Containers.Hashed_Sets is\n      (Container : aliased Set;\n       Position  : Cursor) return Constant_Reference_Type;\n \n+   procedure Assign (Target : in out Set; Source : Set);\n+\n+   function Copy (Source : Set; Capacity : Count_Type := 0) return Set;\n+\n    procedure Move (Target : in out Set; Source : in out Set);\n    --  Clears Target (if it's not empty), and then moves (not copies) the\n    --  buckets array and nodes from Source to Target.\n@@ -422,14 +422,32 @@ package Ada.Containers.Hashed_Sets is\n         (Container : aliased in out Set;\n          Position  : Cursor) return Reference_Type;\n \n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type;\n+\n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n-         Key  : Key_Type) return Reference_Type;\n+         Key       : Key_Type) return Reference_Type;\n \n    private\n       type Reference_Type (Element : not null access Element_Type)\n          is null record;\n \n+      use Ada.Streams;\n+\n+      procedure Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type);\n+\n+      for Reference_Type'Read use Read;\n+\n+      procedure Write\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : Reference_Type);\n+\n+      for Reference_Type'Write use Write;\n+\n    end Generic_Keys;\n \n private\n@@ -439,7 +457,7 @@ private\n    type Node_Access is access Node_Type;\n \n    type Node_Type is limited record\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n       Next    : Node_Access;\n    end record;\n "}, {"sha": "92c08749d9a05f9d23aaf6abc997399452462208", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -673,34 +673,51 @@ package body Ada.Containers.Indefinite_Vectors is\n    ------------------------\n \n    function Constant_Reference\n-     (Container : Vector;\n+     (Container : aliased Vector;\n       Position  : Cursor) return Constant_Reference_Type\n    is\n-   begin\n-      pragma Unreferenced (Container);\n+      E : Element_Access;\n \n+   begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n       if Position.Index > Position.Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n-      return\n-       (Element => Position.Container.Elements.EA (Position.Index).all'Access);\n+      E := Container.Elements.EA (Position.Index);\n+\n+      if E = null then\n+         raise Constraint_Error with \"element at Position is empty\";\n+      end if;\n+\n+      return (Element => E.all'Access);\n    end Constant_Reference;\n \n    function Constant_Reference\n-     (Container : Vector;\n-      Position  : Index_Type) return Constant_Reference_Type\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return Constant_Reference_Type\n    is\n+      E : Element_Access;\n+\n    begin\n-      if (Position) > Container.Last then\n+      if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      return (Element => Container.Elements.EA (Position).all'Access);\n+      E := Container.Elements.EA (Index);\n+\n+      if E = null then\n+         raise Constraint_Error with \"element at Index is empty\";\n+      end if;\n+\n+      return (Element => E.all'Access);\n    end Constant_Reference;\n \n    --------------\n@@ -2998,35 +3015,51 @@ package body Ada.Containers.Indefinite_Vectors is\n    ---------------\n \n    function Reference\n-     (Container : Vector;\n+     (Container : aliased in out Vector;\n       Position  : Cursor) return Reference_Type\n    is\n-   begin\n-      pragma Unreferenced (Container);\n+      E : Element_Access;\n \n+   begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n       if Position.Index > Position.Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n-      return\n-        (Element =>\n-           Position.Container.Elements.EA (Position.Index).all'Access);\n+      E := Container.Elements.EA (Position.Index);\n+\n+      if E = null then\n+         raise Constraint_Error with \"element at Position is empty\";\n+      end if;\n+\n+      return (Element => E.all'Access);\n    end Reference;\n \n    function Reference\n-     (Container : Vector;\n-      Position  : Index_Type) return Reference_Type\n+     (Container : aliased in out Vector;\n+      Index     : Index_Type) return Reference_Type\n    is\n+      E : Element_Access;\n+\n    begin\n-      if Position > Container.Last then\n+      if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      return (Element => Container.Elements.EA (Position).all'Access);\n+      E := Container.Elements.EA (Index);\n+\n+      if E = null then\n+         raise Constraint_Error with \"element at Index is empty\";\n+      end if;\n+\n+      return (Element => E.all'Access);\n    end Reference;\n \n    ---------------------"}, {"sha": "8f55d81ed65428c5c1aad82d1fd5ad2183671ea3", "filename": "gcc/ada/a-coinve.ads", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -150,18 +150,20 @@ package Ada.Containers.Indefinite_Vectors is\n    for Reference_Type'Read use Read;\n \n    function Constant_Reference\n-     (Container : Vector; Position : Cursor)    --  SHOULD BE ALIASED\n-   return Constant_Reference_Type;\n+     (Container : aliased Vector;\n+      Position  : Cursor) return Constant_Reference_Type;\n \n-   function Constant_Reference\n-     (Container : Vector; Position : Index_Type)\n-   return Constant_Reference_Type;\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Position  : Cursor) return Reference_Type;\n \n-   function Reference (Container : Vector; Position : Cursor)\n-   return Reference_Type;\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return Constant_Reference_Type;\n \n-   function Reference (Container : Vector; Position : Index_Type)\n-   return Reference_Type;\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Index     : Index_Type) return Reference_Type;\n \n    function To_Cursor\n      (Container : Vector;"}, {"sha": "a923871b148992ad0e8aacdbcf6e6519586d6f5d", "filename": "gcc/ada/a-comutr.adb", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -437,6 +437,36 @@ package body Ada.Containers.Multiway_Trees is\n       pragma Assert (Children_Count = Container_Count);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node = Root_Node (Container) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      --  Implement Vet for multiway tree???\n+      --  pragma Assert (Vet (Position),\n+      --                 \"Position cursor in Constant_Reference is bad\");\n+\n+      return (Element => Position.Node.Element'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -2000,24 +2030,30 @@ package body Ada.Containers.Multiway_Trees is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Constant_Reference_Type\n-   is\n-   begin\n-      pragma Unreferenced (Container);\n-\n-      return (Element => Position.Node.Element'Unrestricted_Access);\n-   end Constant_Reference;\n-\n    function Reference\n-     (Container : aliased Tree;\n+     (Container : aliased in out Tree;\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      pragma Unreferenced (Container);\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      if Position.Node = Root_Node (Container) then\n+         raise Program_Error with \"Position cursor designates root\";\n+      end if;\n+\n+      --  Implement Vet for multiway tree???\n+      --  pragma Assert (Vet (Position),\n+      --                 \"Position cursor in Constant_Reference is bad\");\n \n-      return (Element => Position.Node.Element'Unrestricted_Access);\n+      return (Element => Position.Node.Element'Access);\n    end Reference;\n \n    --------------------"}, {"sha": "20a91bb9a13a1dbf46ab5395b6cc299ec3f1f238", "filename": "gcc/ada/a-comutr.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-comutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-comutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -108,6 +108,14 @@ package Ada.Containers.Multiway_Trees is\n      (Element : not null access Element_Type) is private\n         with Implicit_Dereference => Element;\n \n+   function Constant_Reference\n+     (Container : aliased Tree;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Tree;\n+      Position  : Cursor) return Reference_Type;\n+\n    procedure Assign (Target : in out Tree; Source : Tree);\n \n    function Copy (Source : Tree) return Tree;\n@@ -341,7 +349,7 @@ private\n       Prev     : Tree_Node_Access;\n       Next     : Tree_Node_Access;\n       Children : Children_Type;\n-      Element  : Element_Type;\n+      Element  : aliased Element_Type;\n    end record;\n    pragma Convention (C, Tree_Node_Type);\n \n@@ -445,14 +453,6 @@ private\n \n    for Reference_Type'Write use Write;\n \n-   function Constant_Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Constant_Reference_Type;\n-\n-   function Reference\n-     (Container : aliased Tree;\n-      Position  : Cursor) return Reference_Type;\n-\n    Empty_Tree : constant Tree := (Controlled with others => <>);\n \n    No_Element : constant Cursor := (others => <>);"}, {"sha": "2e3523514e4660fe8464bd6b5c31a3a270bd3e84", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -478,6 +478,42 @@ package body Ada.Containers.Vectors is\n       end if;\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n+      if Position.Index > Position.Container.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      return (Element => Container.Elements.EA (Position.Index)'Access);\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return Constant_Reference_Type\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      else\n+         return (Element => Container.Elements.EA (Index)'Access);\n+      end if;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -2538,64 +2574,35 @@ package body Ada.Containers.Vectors is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : Vector;\n-      Position  : Cursor)    --  SHOULD BE ALIASED\n-      return Constant_Reference_Type\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Position  : Cursor) return Reference_Type\n    is\n    begin\n-      pragma Unreferenced (Container);\n-\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n-\n-      return\n-       (Element =>\n-          Position.Container.Elements.EA (Position.Index)'Access);\n-   end Constant_Reference;\n-\n-   function Constant_Reference\n-     (Container : Vector;\n-      Position  : Index_Type)\n-      return Constant_Reference_Type\n-   is\n-   begin\n-      if Position > Container.Last then\n-         raise Constraint_Error with \"Index is out of range\";\n-      else\n-         return (Element => Container.Elements.EA (Position)'Access);\n-      end if;\n-   end Constant_Reference;\n-\n-   function Reference (Container : Vector; Position : Cursor)\n-   return Reference_Type is\n-   begin\n-      pragma Unreferenced (Container);\n-\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n       if Position.Index > Position.Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n-      return\n-        (Element => Position.Container.Elements.EA (Position.Index)'Access);\n+      return (Element => Container.Elements.EA (Position.Index)'Access);\n    end Reference;\n \n-   function Reference (Container : Vector; Position : Index_Type)\n-   return Reference_Type is\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Index     : Index_Type) return Reference_Type\n+   is\n    begin\n-      if Position > Container.Last then\n+      if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       else\n-         return (Element => Container.Elements.EA (Position)'Access);\n+         return (Element => Container.Elements.EA (Index)'Access);\n       end if;\n    end Reference;\n "}, {"sha": "babf94e9c452d48c4e709714c508b1edfe1a9c49", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -189,18 +189,20 @@ package Ada.Containers.Vectors is\n    for Reference_Type'Read use Read;\n \n    function Constant_Reference\n-     (Container : Vector; Position : Cursor)    --  SHOULD BE ALIASED\n-   return Constant_Reference_Type;\n+     (Container : aliased Vector;\n+      Position  : Cursor) return Constant_Reference_Type;\n \n-   function Constant_Reference\n-     (Container : Vector; Position : Index_Type)\n-   return Constant_Reference_Type;\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Position  : Cursor) return Reference_Type;\n \n-   function Reference (Container : Vector; Position : Cursor)\n-   return Reference_Type;\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return Constant_Reference_Type;\n \n-   function Reference (Container : Vector; Position : Index_Type)\n-   return Reference_Type;\n+   function Reference\n+     (Container : aliased in out Vector;\n+      Index     : Index_Type) return Reference_Type;\n \n    procedure Assign (Target : in out Vector; Source : Vector);\n "}, {"sha": "c7153c5fcbb54e7a5edf6bfa2c6f255a8d4c075c", "filename": "gcc/ada/a-coorma.adb", "status": "modified", "additions": 58, "deletions": 5, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -322,12 +322,39 @@ package body Ada.Containers.Ordered_Maps is\n    -- Constant_Reference --\n    ------------------------\n \n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"Position cursor in Constant_Reference is bad\");\n+\n+      return (Element => Position.Node.Element'Access);\n+   end Constant_Reference;\n+\n    function Constant_Reference\n      (Container : Map;\n       Key       : Key_Type) return Constant_Reference_Type\n    is\n+      Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n    begin\n-      return (Element => Container.Element (Key)'Unrestricted_Access);\n+      if Node = null then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      return (Element => Node.Element'Access);\n    end Constant_Reference;\n \n    --------------\n@@ -1250,12 +1277,38 @@ package body Ada.Containers.Ordered_Maps is\n    ---------------\n \n    function Reference\n-     (Container : Map;\n-      Key       : Key_Type)\n-      return Reference_Type\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type\n    is\n    begin\n-      return (Element => Container.Element (Key)'Unrestricted_Access);\n+      if Position.Container = null then\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"Position cursor in function Reference is bad\");\n+\n+      return (Element => Position.Node.Element'Access);\n+   end Reference;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type\n+   is\n+      Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n+   begin\n+      if Node = null then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      return (Element => Node.Element'Access);\n    end Reference;\n \n    -------------"}, {"sha": "a58a4f5a2a2960bdb1796638ddab127386f2d2f6", "filename": "gcc/ada/a-coorma.ads", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -51,7 +51,7 @@ package Ada.Containers.Ordered_Maps is\n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n    type Map is tagged private with\n-      constant_Indexing => Constant_Reference,\n+      Constant_Indexing => Constant_Reference,\n       Variable_Indexing => Reference,\n       Default_Iterator  => Iterate,\n       Iterator_Element  => Element_Type;\n@@ -96,6 +96,31 @@ package Ada.Containers.Ordered_Maps is\n       Process   : not null access\n                    procedure (Key : Key_Type; Element : in out Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Position  : Cursor) return Reference_Type;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : aliased in out Map;\n+      Key       : Key_Type) return Reference_Type;\n+\n    procedure Assign (Target : in out Map; Source : Map);\n \n    function Copy (Source : Map) return Map;\n@@ -182,23 +207,6 @@ package Ada.Containers.Ordered_Maps is\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   type Reference_Type (Element : not null access Element_Type) is private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   function Constant_Reference\n-     (Container : Map;\n-      Key       : Key_Type)    --  SHOULD BE ALIASED???\n-      return Constant_Reference_Type;\n-\n-   function Reference (Container : Map; Key : Key_Type)\n-   return Reference_Type;\n-\n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n@@ -234,7 +242,7 @@ private\n       Right   : Node_Access;\n       Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n       Key     : Key_Type;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n    end record;\n \n    package Tree_Types is"}, {"sha": "41ebb5c0d71142eba88c4c68c67acd414048d147", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 107, "deletions": 51, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -331,6 +331,31 @@ package body Ada.Containers.Ordered_Sets is\n       return Node.Color;\n    end Color;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container.Tree, Position.Node),\n+         \"bad cursor in Constant_Reference\");\n+\n+      return (Element => Position.Node.Element'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -658,6 +683,25 @@ package body Ada.Containers.Ordered_Sets is\n                  else Cursor'(Container'Unrestricted_Access, Node));\n       end Ceiling;\n \n+      ------------------------\n+      -- Constant_Reference --\n+      ------------------------\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n+         Key       : Key_Type) return Constant_Reference_Type\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error with \"key not in set\";\n+         end if;\n+\n+         return (Element => Node.Element'Access);\n+      end Constant_Reference;\n+\n       --------------\n       -- Contains --\n       --------------\n@@ -784,6 +828,66 @@ package body Ada.Containers.Ordered_Sets is\n          return Key (Position.Node.Element);\n       end Key;\n \n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Item   : out Reference_Type)\n+      is\n+      begin\n+         raise Program_Error with \"attempt to stream reference\";\n+      end Read;\n+\n+      ------------------------------\n+      -- Reference_Preserving_Key --\n+      ------------------------------\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type\n+      is\n+      begin\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n+         end if;\n+\n+         pragma Assert\n+           (Vet (Container.Tree, Position.Node),\n+            \"bad cursor in function Reference_Preserving_Key\");\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Position has\n+         --  not changed.  ???\n+\n+         return (Element => Position.Node.Element'Access);\n+      end Reference_Preserving_Key;\n+\n+      function Reference_Preserving_Key\n+        (Container : aliased in out Set;\n+         Key       : Key_Type) return Reference_Type\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error with \"key not in set\";\n+         end if;\n+\n+         --  Some form of finalization will be required in order to actually\n+         --  check that the key-part of the element designated by Position has\n+         --  not changed.  ???\n+\n+         return (Element => Node.Element'Access);\n+      end Reference_Preserving_Key;\n+\n       -------------\n       -- Replace --\n       -------------\n@@ -867,41 +971,9 @@ package body Ada.Containers.Ordered_Sets is\n          raise Program_Error with \"key was modified\";\n       end Update_Element_Preserving_Key;\n \n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Constant_Reference_Type\n-      is\n-         Position : constant Cursor := Find (Container, Key);\n-\n-      begin\n-         if Position.Container = null then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n-\n-         return (Element => Position.Node.Element'Access);\n-      end Reference_Preserving_Key;\n-\n-      function Reference_Preserving_Key\n-        (Container : aliased in out Set;\n-         Key       : Key_Type) return Reference_Type\n-      is\n-         Position : constant Cursor := Find (Container, Key);\n-\n-      begin\n-         if Position.Container = null then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n-\n-         return (Element => Position.Node.Element'Access);\n-      end Reference_Preserving_Key;\n-\n-      procedure Read\n-        (Stream : not null access Root_Stream_Type'Class;\n-         Item   : out Reference_Type)\n-      is\n-      begin\n-         raise Program_Error with \"attempt to stream reference\";\n-      end Read;\n+      -----------\n+      -- Write --\n+      -----------\n \n       procedure Write\n         (Stream : not null access Root_Stream_Type'Class;\n@@ -1536,22 +1608,6 @@ package body Ada.Containers.Ordered_Sets is\n       raise Program_Error with \"attempt to stream reference\";\n    end Read;\n \n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Constant_Reference (Container : Set; Position : Cursor)\n-   return Constant_Reference_Type\n-   is\n-      pragma Unreferenced (Container);\n-   begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Element => Position.Node.Element'Access);\n-   end Constant_Reference;\n-\n    -------------\n    -- Replace --\n    -------------"}, {"sha": "cf28a7ccd1c5253a8c8c7c5349d4e83e1e12d493", "filename": "gcc/ada/a-coorse.ads", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -68,28 +68,6 @@ package Ada.Containers.Ordered_Sets is\n    package Set_Iterator_Interfaces is new\n      Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is\n-   private\n-   with\n-      Implicit_Dereference => Element;\n-\n-   procedure Write\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Write use Write;\n-\n-   function Constant_Reference\n-     (Container : Set; Position : Cursor)\n-   return Constant_Reference_Type;\n-\n-   procedure Read\n-     (Stream : not null access Root_Stream_Type'Class;\n-      Item   : out Constant_Reference_Type);\n-\n-   for Constant_Reference_Type'Read use Read;\n-\n    function \"=\" (Left, Right : Set) return Boolean;\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n@@ -113,6 +91,28 @@ package Ada.Containers.Ordered_Sets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is\n+   private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return Constant_Reference_Type;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n    procedure Assign (Target : in out Set; Source : Set);\n \n    function Copy (Source : Set) return Set;\n@@ -278,6 +278,10 @@ package Ada.Containers.Ordered_Sets is\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n+         Position  : Cursor) return Reference_Type;\n+\n+      function Constant_Reference\n+        (Container : aliased Set;\n          Key       : Key_Type) return Constant_Reference_Type;\n \n       function Reference_Preserving_Key"}, {"sha": "dac30475e49f7f473206d050e8b212d75baaf81b", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -2977,8 +2977,15 @@ package body Prj.Nmsc is\n                   \"library directory { does not exist\",\n                   Lib_Dir.Location, Project);\n \n-            elsif not Project.Externally_Built then\n+            --  Checks for object/source directories\n \n+            elsif not Project.Externally_Built\n+\n+              --  An aggregate library does not have sources or objects, so\n+              --  these tests are not required in this case.\n+\n+              and then Project.Qualifier /= Aggregate_Library\n+            then\n                --  Library directory cannot be the same as Object directory\n \n                if Project.Library_Dir.Name = Project.Object_Directory.Name then"}, {"sha": "db18a7ebec0b308c6f95eeb3832db49769d54f64", "filename": "gcc/ada/s-gearop.adb", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fs-gearop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fs-gearop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.adb?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 2006-2011, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2006-2012, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -311,11 +311,23 @@ package body System.Generic_Array_Operations is\n \n             if Max_Abs > 0.0 then\n                Switch_Row (M, N, Row, Max_Row);\n-               Divide_Row (M, N, Row, M (Row, J));\n+\n+               --  The temporaries below are necessary to force a copy of the\n+               --  value and avoid improper aliasing.\n+\n+               declare\n+                  Scale : constant Scalar := M (Row, J);\n+               begin\n+                  Divide_Row (M, N, Row, Scale);\n+               end;\n \n                for U in Row + 1 .. M'Last (1) loop\n-                  Sub_Row (N, U, Row, M (U, J));\n-                  Sub_Row (M, U, Row, M (U, J));\n+                  declare\n+                     Factor : constant Scalar := M (U, J);\n+                  begin\n+                     Sub_Row (N, U, Row, Factor);\n+                     Sub_Row (M, U, Row, Factor);\n+                  end;\n                end loop;\n \n                exit when Row >= M'Last (1);"}, {"sha": "d0b83ae05f4066a71b3ebb261d251f0c6e486d2b", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9423ca3fa65282b0ca58d33976c150f78e24f23/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=c9423ca3fa65282b0ca58d33976c150f78e24f23", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -888,9 +888,10 @@ package System.OS_Lib is\n    --  If the parent is using tasking, and needs to spawn subprocesses at\n    --  arbitrary times, one technique is for the parent to spawn (very early)\n    --  a particular spawn-manager subprocess whose job is to spawn other\n-   --  processes. The spawn-manager avoids tasking. The parent sends messages\n-   --  to the spawn-manager requesting it to spawn processes, using whatever\n-   --  inter-process communication mechanism you like, such as sockets.\n+   --  processes. The spawn-manager must avoid tasking. The parent sends\n+   --  messages to the spawn-manager requesting it to spawn processes, using\n+   --  whatever inter-process communication mechanism you like, such as\n+   --  sockets.\n \n    --  In short, mixing spawning of subprocesses with tasking is a tricky\n    --  business, and should be avoided if possible, but if it is necessary,"}]}