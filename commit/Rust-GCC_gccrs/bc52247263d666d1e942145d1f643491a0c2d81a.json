{"sha": "bc52247263d666d1e942145d1f643491a0c2d81a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM1MjI0NzI2M2Q2NjZkMWU5NDIxNDVkMWY2NDM0OTFhMGMyZDgxYQ==", "commit": {"author": {"name": "Kurt Garloff", "email": "garloff@suse.de", "date": "2003-03-02T21:18:16Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-03-02T21:18:16Z"}, "message": "params.def: Introduce parameter max-inline-insns-rtl for a separate limit for the RTL inliner.\n\n2003-03-02  Kurt Garloff  <garloff@suse.de>\n\n\t* params.def: Introduce parameter max-inline-insns-rtl for\n\ta separate limit for the RTL inliner.\n\t* params.h: Likewise.\n\t* integrate.c (function_cannot_inline_p): Use it.\n\t* toplev.c (decode_f_option): Set multiple parameters\n\tcontrolling inlining with -finline-limit.\n\t* params.def: Fix orthographic and typographic errors.\n\t* doc/invoke.texi: Document parameters controlling inlining\n\tand the way -finline-limit sets multiple of them.\n\n\t* tree.h (struct tree_decl): Introduce inlined_function_flag,\n\trecording whether the function became eligible for inlining\n\tby a compiler flag rather than the declaration.\n\tProvide DID_INLINE_FUNC macro to access it.\n\t* c-decl.c (grokdeclarator): Set DID_INLINE_FUNC.\n\t* cp/decl.c (grokfndecl): Likewise.\n\t* toplev.c (rest_of_compilation): Likewise.\n\t* cp/optimize (maybe_clone_body): Copy DID_INLINE_FUNC.\n\t* print-tree.c (print_node): Report it.\n\t* params.def: Introduce new max-inline-insns-auto limit.\n\t* params.h: Likewise.\n\t* tree-inline.c (inlinable_function_p): Apply it to functions\n\twith DID_INLINE_FUNC set.\n\t* toplev.c (decode_f_option): Initialize it from -finline-limit\n\tvalue.\n\t* doc/invoke.texi: Document new parameter.\n\nFrom-SVN: r63688", "tree": {"sha": "8779d656c10e23abf78abe1a1c94a499d158237b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8779d656c10e23abf78abe1a1c94a499d158237b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc52247263d666d1e942145d1f643491a0c2d81a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc52247263d666d1e942145d1f643491a0c2d81a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc52247263d666d1e942145d1f643491a0c2d81a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc52247263d666d1e942145d1f643491a0c2d81a/comments", "author": null, "committer": null, "parents": [{"sha": "f4ae98be562f298bbf51fd9b54ccce7f1ab0d0e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ae98be562f298bbf51fd9b54ccce7f1ab0d0e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4ae98be562f298bbf51fd9b54ccce7f1ab0d0e6"}], "stats": {"total": 211, "additions": 185, "deletions": 26}, "files": [{"sha": "898cdcd86eb048dbf986d385d715a3e45f6817f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -1,3 +1,32 @@\n+2003-03-02  Kurt Garloff  <garloff@suse.de>\n+\n+\t* params.def: Introduce parameter max-inline-insns-rtl for\n+\ta separate limit for the RTL inliner.\n+\t* params.h: Likewise.\n+\t* integrate.c (function_cannot_inline_p): Use it.\n+\t* toplev.c (decode_f_option): Set multiple parameters \n+\tcontrolling inlining with -finline-limit.\n+\t* params.def: Fix orthographic and typographic errors.\n+\t* doc/invoke.texi: Document parameters controlling inlining\n+\tand the way -finline-limit sets multiple of them.\n+\n+\t* tree.h (struct tree_decl): Introduce inlined_function_flag,\n+\trecording whether the function became eligible for inlining\n+\tby a compiler flag rather than the declaration.\n+\tProvide DID_INLINE_FUNC macro to access it.\n+\t* c-decl.c (grokdeclarator): Set DID_INLINE_FUNC.\n+\t* cp/decl.c (grokfndecl): Likewise.\n+\t* toplev.c (rest_of_compilation): Likewise.\n+\t* cp/optimize (maybe_clone_body): Copy DID_INLINE_FUNC.\n+\t* print-tree.c (print_node): Report it.\n+\t* params.def: Introduce new max-inline-insns-auto limit.\n+\t* params.h: Likewise.\n+\t* tree-inline.c (inlinable_function_p): Apply it to functions\n+\twith DID_INLINE_FUNC set.\n+\t* toplev.c (decode_f_option): Initialize it from -finline-limit\n+\tvalue.\n+\t* doc/invoke.texi: Document new parameter.\n+\n 2003-03-02  Geoffrey Keating  <geoffk@apple.com>\n \n \t* fix-header.c (read_scan_file): Don't reference simplify_path."}, {"sha": "4779406277f13974abd9f5216b20ee05df00a958", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -4567,6 +4567,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t   needed, and let dwarf2 know that the function is inlinable.  */\n \telse if (flag_inline_trees == 2 && initialized)\n \t  {\n+\t    if (!DECL_INLINE (decl))\n+\t\tDID_INLINE_FUNC (decl) = 1;\n \t    DECL_INLINE (decl) = 1;\n \t    DECL_DECLARED_INLINE_P (decl) = 0;\n \t  }"}, {"sha": "2f29c48175663616b4405b7a9afc1756138cd4c9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -8955,13 +8955,19 @@ grokfndecl (tree ctype,\n       DECL_NOT_REALLY_EXTERN (decl) = 1;\n     }\n \n+  DID_INLINE_FUNC (decl) = 0;\n   /* If the declaration was declared inline, mark it as such.  */\n   if (inlinep)\n     DECL_DECLARED_INLINE_P (decl) = 1;\n   /* We inline functions that are explicitly declared inline, or, when\n      the user explicitly asks us to, all functions.  */\n-  if (DECL_DECLARED_INLINE_P (decl) || flag_inline_trees == 2)\n+  if (DECL_DECLARED_INLINE_P (decl))\n     DECL_INLINE (decl) = 1;\n+  if (flag_inline_trees == 2 && !DECL_INLINE (decl))\n+    {\n+      DID_INLINE_FUNC (decl) = 1;\n+      DECL_INLINE (decl) = 1;\n+    }\n \n   DECL_EXTERNAL (decl) = 1;\n   if (quals != NULL_TREE && TREE_CODE (type) == FUNCTION_TYPE)\n@@ -14217,6 +14223,7 @@ start_method (tree declspecs, tree declarator, tree attrlist)\n \n   DECL_DECLARED_INLINE_P (fndecl) = 1;\n \n+  DID_INLINE_FUNC (fndecl) = 0;\n   if (flag_default_inline)\n     DECL_INLINE (fndecl) = 1;\n "}, {"sha": "d461b0d08b5c3d83d63abb4d249c44db09b01fe2", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -159,6 +159,7 @@ maybe_clone_body (tree fn)\n       /* Update CLONE's source position information to match FN's.  */\n       DECL_SOURCE_LOCATION (clone) = DECL_SOURCE_LOCATION (fn);\n       DECL_INLINE (clone) = DECL_INLINE (fn);\n+      DID_INLINE_FUNC (clone) = DID_INLINE_FUNC (fn);\n       DECL_DECLARED_INLINE_P (clone) = DECL_DECLARED_INLINE_P (fn);\n       DECL_COMDAT (clone) = DECL_COMDAT (fn);\n       DECL_WEAK (clone) = DECL_WEAK (fn);"}, {"sha": "54a283c287dff6341c12caa543602177ca86b0a5", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -3643,6 +3643,28 @@ the compilation faster and less code will be inlined (which presumably\n means slower programs).  This option is particularly useful for programs that\n use inlining heavily such as those based on recursive templates with C++.\n \n+Inlining is actually controlled by a number of parameters, which may be\n+specified individually by using @option{--param @var{name}=@var{value}}.\n+The @option{-finline-limit=@var{n}} option sets some of these parameters \n+as follows:\n+\n+@table @gcctabopt\n+ @item max-inline-insns\n+  is set to @var{n}.\n+ @item max-inline-insns-single\n+  is set to @var{n}/2.\n+ @item max-inline-insns-single-auto\n+  is set to @var{n}/2.\n+ @item min-inline-insns\n+  is set to 130 or @var{n}/4, whichever is smaller.\n+ @item max-inline-insns-rtl\n+  is set to @var{n}.\n+@end table\n+\n+Using @option{-finline-limit=600} thus results in the default settings\n+for these parameters.  See below for a documentation of the individual\n+parameters controlling inlining.\n+\n @emph{Note:} pseudo instruction represents, in this particular context, an\n abstract measurement of function's size.  In no way, it represents a count\n of assembly instructions and as such its exact meaning might change from one\n@@ -4466,10 +4488,53 @@ before flushing the current state and starting over.  Large functions\n with few branches or calls can create excessively large lists which\n needlessly consume memory and resources.\n \n+@item max-inline-insns-single\n+Several parameters control the tree inliner used in gcc.\n+This number sets the maximum number of instructions (counted in gcc's\n+internal representation) in a single function that the tree inliner \n+will consider for inlining.  This only affects functions declared\n+inline and methods implemented in a class declaration (C++).\n+The default value is 300.\n+\n+@item max-inline-insns-auto\n+When you use @option{-finline-functions} (included in @option{-O3}),\n+a lot of functions that would otherwise not be considered for inlining\n+by the compiler will be investigated.  To those functions, a different\n+(more restrictive) limit compared to functions declared inline can\n+be applied.\n+The default value is 300.\n+\n @item max-inline-insns\n-If an function contains more than this many instructions, it\n-will not be inlined.  This option is precisely equivalent to\n-@option{-finline-limit}.\n+The tree inliner does decrease the allowable size for single functions \n+to be inlined after we already inlined the number of instructions\n+given here by repeated inlining.  This number should be a factor of \n+two or more larger than the single function limit.\n+Higher numbers result in better runtime performance, but incur higher\n+compile-time resource (CPU time, memory) requirements and result in\n+larger binaries.  Very high values are not advisable, as too large\n+binaries may adversely affect runtime performance.\n+The default value is 600.\n+\n+@item max-inline-slope\n+After exceeding the maximum number of inlined instructions by repeated\n+inlining, a linear function is used to decrease the allowable size\n+for single functions.  The slope of that function is the negative\n+reciprocal of the number specified here.\n+The default value is 32.\n+\n+@item min-inline-insns\n+The repeated inlining is throttled more and more by the linear function\n+after exceeding the limit.  To avoid too much throttling, a minimum for\n+this function is specified here to allow repeated inlining for very small\n+functions even when a lot of repeated inlining already has been done.\n+The default value is 130.\n+\n+@item max-inline-insns-rtl\n+For languages that use the RTL inliner (this happens at a later stage\n+than tree inlining), you can set the maximum allowable size (counted \n+in RTL instructions) for the RTL inliner with this parameter.\n+The default value is 600.\n+\n \n @item max-unrolled-insns\n The maximum number of instructions that a loop should have if that loop"}, {"sha": "f26a94c66a1193f07ce65e00cf203ce5a9b0c590", "filename": "gcc/integrate.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -159,11 +159,13 @@ function_cannot_inline_p (fndecl)\n   tree last = tree_last (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n \n   /* For functions marked as inline increase the maximum size to\n-     MAX_INLINE_INSNS (-finline-limit-<n>).  For regular functions\n-     use the limit given by INTEGRATE_THRESHOLD.  */\n+     MAX_INLINE_INSNS_RTL (--param max-inline-insn-rtl=<n>). For\n+     regular functions use the limit given by INTEGRATE_THRESHOLD.\n+     Note that the RTL inliner is not used by the languages that use\n+     the tree inliner (C, C++).  */\n \n   int max_insns = (DECL_INLINE (fndecl))\n-\t\t   ? (MAX_INLINE_INSNS\n+\t\t   ? (MAX_INLINE_INSNS_RTL\n \t\t      + 8 * list_length (DECL_ARGUMENTS (fndecl)))\n \t\t   : INTEGRATE_THRESHOLD (fndecl);\n "}, {"sha": "451c1a8d729a86f6cd7287be7572ab1777061e09", "filename": "gcc/params.def", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -50,10 +50,22 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    gets decreased.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n \t  \"max-inline-insns-single\",\n-\t  \"The maximum number of instructions in a single function eliglible for inlining\",\n+\t  \"The maximum number of instructions in a single function eligible for inlining\",\n \t  300)\n \n-/* The repeated inlining limit. After this number of instructions \n+/* The single function inlining limit for functions that are\n+   inlined by virtue of -finline-functions (-O3).\n+   This limit should be chosen to be below or equal to the limit\n+   that is applied to functions marked inlined (or defined in the\n+   class declaration in C++) given by the \"max-inline-insns-single\"\n+   parameter.\n+   The default value is 300.  */\n+DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n+\t  \"max-inline-insns-auto\",\n+\t  \"The maximum number of instructions when automatically inlining\",\n+\t  300)\n+\n+/* The repeated inlining limit.  After this number of instructions \n    (in the internal gcc representation, not real machine instructions)\n    got inlined by repeated inlining, gcc starts to decrease the maximum\n    number of inlinable instructions in the tree inliner.\n@@ -62,24 +74,22 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n    could otherwise become very high.\n    It is recommended to set this value to twice the value of the single\n    function limit (set by the \"max-inline-insns-single\" parameter) or\n-   higher. The default value is 600.\n+   higher.  The default value is 600.\n    Higher values mean that more inlining is done, resulting in\n    better performance of the code, at the expense of higher \n    compile-time resource (time, memory) requirements and larger\n-   binaries.  \n-   This parameters also controls the maximum size of functions considered\n-   for inlining in the RTL inliner.  */\n+   binaries.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS,\n \t  \"max-inline-insns\",\n-\t  \"The maximuem number of instructions by repeated inlining before gcc starts to throttle inlining\",\n+\t  \"The maximum number of instructions by repeated inlining before gcc starts to throttle inlining\",\n \t  600)\n \n /* After the repeated inline limit has been exceeded (see\n    \"max-inline-insns\" parameter), a linear function is used to\n    decrease the size of single functions eligible for inlining.\n    The slope of this linear function is given the negative\n    reciprocal value (-1/x) of this parameter. \n-   The default vlue is 32.\n+   The default value is 32.\n    This linear function is used until it falls below a minimum\n    value specified by the \"min-inline-insns\" parameter.  */\n DEFPARAM (PARAM_MAX_INLINE_SLOPE,\n@@ -90,16 +100,26 @@ DEFPARAM (PARAM_MAX_INLINE_SLOPE,\n /* When gcc has inlined so many instructions (by repeated\n    inlining) that the throttling limits the inlining very much,\n    inlining for very small functions is still desirable to\n-   achieve good runtime performance. The size of single functions \n+   achieve good runtime performance.  The size of single functions \n    (measured in gcc instructions) which will still be eligible for \n-   inlining then is given by this parameter. It defaults to 130.\n+   inlining then is given by this parameter.  It defaults to 130.\n    Only much later (after exceeding 128 times the recursive limit)\n    inlining is cut down completely.  */\n DEFPARAM (PARAM_MIN_INLINE_INSNS,\n \t  \"min-inline-insns\",\n \t  \"The number of instructions in a single functions still eligible to inlining after a lot recursive inlining\",\n \t  130)\n \n+/* For languages that (still) use the RTL inliner, we can specify\n+   limits for the RTL inliner separately.\n+   The parameter here defines the maximum number of RTL instructions\n+   a function may have to be eligible for inlining in the RTL inliner.\n+   The default value is 600.  */\n+DEFPARAM (PARAM_MAX_INLINE_INSNS_RTL,\n+\t  \"max-inline-insns-rtl\",\n+\t  \"The maximum number of instructions for the RTL inliner\",\n+\t  600)\n+\n /* The maximum number of instructions to consider when looking for an\n    instruction to fill a delay slot.  If more than this arbitrary\n    number of instructions is searched, the time savings from filling"}, {"sha": "caddf853da5fe2ca1d971e61ef5495026e1d1150", "filename": "gcc/params.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -92,6 +92,10 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_MAX_INLINE_SLOPE)\n #define MIN_INLINE_INSNS \\\n   PARAM_VALUE (PARAM_MIN_INLINE_INSNS)\n+#define MAX_INLINE_INSNS_AUTO \\\n+  PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO)\n+#define MAX_INLINE_INSNS_RTL \\\n+  PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RTL)\n #define MAX_DELAY_SLOT_INSN_SEARCH \\\n   PARAM_VALUE (PARAM_MAX_DELAY_SLOT_INSN_SEARCH)\n #define MAX_DELAY_SLOT_LIVE_SEARCH \\"}, {"sha": "cd180719d6773bce565eedd20e0b9168ef688980", "filename": "gcc/print-tree.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -330,7 +330,9 @@ print_node (file, prefix, node, indent)\n       if (TREE_CODE (node) == TYPE_DECL && TYPE_DECL_SUPPRESS_DEBUG (node))\n \tfputs (\" suppress-debug\", file);\n \n-      if (TREE_CODE (node) == FUNCTION_DECL && DECL_INLINE (node))\n+      if (TREE_CODE (node) == FUNCTION_DECL && DID_INLINE_FUNC (node))\n+\tfputs (\" autoinline\", file);\n+      else if (TREE_CODE (node) == FUNCTION_DECL && DECL_INLINE (node))\n \tfputs (\" inline\", file);\n       if (TREE_CODE (node) == FUNCTION_DECL && DECL_BUILT_IN (node))\n \tfputs (\" built-in\", file);"}, {"sha": "215b3186c525a6f9f970e3ce8340ac92651ed9f7", "filename": "gcc/toplev.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -2481,12 +2481,16 @@ rest_of_compilation (decl)\n \t\t  goto exit_rest_of_compilation;\n \t\t}\n \t    }\n-\t  else\n-\t    /* ??? Note that this has the effect of making it look\n-\t\t like \"inline\" was specified for a function if we choose\n-\t\t to inline it.  This isn't quite right, but it's\n-\t\t probably not worth the trouble to fix.  */\n+\t  else {\n+\t    /* ??? Note that we used to just make it look like if\n+\t         the \"inline\" keyword was specified when we decide\n+\t         to inline it (because of -finline-functions).\n+\t         garloff@suse.de, 2002-04-24: Add another flag to\n+\t         actually record this piece of information.  */\n+\t    if (!DECL_INLINE (decl))\n+\t       DID_INLINE_FUNC (decl) = 1;\n \t    inlinable = DECL_INLINE (decl) = 1;\n+\t  }\n \t}\n \n       insns = get_insns ();\n@@ -4085,6 +4089,16 @@ decode_f_option (arg)\n \tread_integral_parameter (option_value, arg - 2,\n \t\t\t\t MAX_INLINE_INSNS);\n       set_param_value (\"max-inline-insns\", val);\n+      set_param_value (\"max-inline-insns-single\", val/2);\n+      set_param_value (\"max-inline-insns-auto\", val/2);\n+      set_param_value (\"max-inline-insns-rtl\", val);\n+      if (val/4 < MIN_INLINE_INSNS)\n+\t{\n+\t  if (val/4 > 10)\n+\t    set_param_value (\"min-inline-insns\", val/4);\n+\t  else\n+\t    set_param_value (\"min-inline-insns\", 10);\n+\t}\n     }\n   else if ((option_value = skip_leading_substring (arg, \"tls-model=\")))\n     {"}, {"sha": "5b5e77502f254336c10800a654c502cabefb6301", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -935,6 +935,7 @@ inlinable_function_p (fn, id)\n {\n   int inlinable;\n   int currfn_insns;\n+  int max_inline_insns_single = MAX_INLINE_INSNS_SINGLE;\n \n   /* If we've already decided this function shouldn't be inlined,\n      there's no need to check again.  */\n@@ -943,7 +944,13 @@ inlinable_function_p (fn, id)\n \n   /* Assume it is not inlinable.  */\n   inlinable = 0;\n-\n+       \n+  /* We may be here either because fn is declared inline or because\n+     we use -finline-functions.  For the second case, we are more\n+     restrictive.  */\n+  if (DID_INLINE_FUNC (fn))\n+    max_inline_insns_single = MAX_INLINE_INSNS_AUTO;\n+\t\n   /* The number of instructions (estimated) of current function.  */\n   currfn_insns = DECL_NUM_STMTS (fn) * INSNS_PER_STMT;\n \n@@ -962,7 +969,7 @@ inlinable_function_p (fn, id)\n      function to be of MAX_INLINE_INSNS_SINGLE size.  Make special\n      allowance for extern inline functions, though.  */\n   else if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n-\t   && currfn_insns > MAX_INLINE_INSNS_SINGLE)\n+\t   && currfn_insns > max_inline_insns_single)\n     ;\n   /* We can't inline functions that call __builtin_longjmp at all.\n      The non-local goto machenery really requires the destination"}, {"sha": "4dd753a085111666da9c1d5bcd2a0f4d4b4be7ad", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc52247263d666d1e942145d1f643491a0c2d81a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=bc52247263d666d1e942145d1f643491a0c2d81a", "patch": "@@ -1626,6 +1626,11 @@ struct tree_type GTY(())\n    where it is called.  */\n #define DECL_INLINE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inline_flag)\n \n+/* Nonzero in a FUNCTION_DECL means this function has been found inlinable\n+   only by virtue of -finline-functions  */\n+#define DID_INLINE_FUNC(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->decl.inlined_function_flag)\n+\n /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n #define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)\n \n@@ -1811,7 +1816,8 @@ struct tree_decl GTY(())\n   unsigned user_align : 1;\n   unsigned uninlinable : 1;\n   unsigned thread_local_flag : 1;\n-  /* Two unused bits.  */\n+  unsigned inlined_function_flag : 1;\n+  /* One unused bit.  */\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;"}]}