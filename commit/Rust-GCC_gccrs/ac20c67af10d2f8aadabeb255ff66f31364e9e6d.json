{"sha": "ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMyMGM2N2FmMTBkMmY4YWFkYWJlYjI1NWZmNjZmMzEzNjRlOWU2ZA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-09-23T15:42:21Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-09-23T15:42:21Z"}, "message": "cp-tree.h (scope_kind): Add new enumerator.\n\n\t* cp-tree.h (scope_kind): Add new enumerator.\n\t(keep_next_level): Change parameter type to bool.\n\t(begin_scope):  Change prototype.\n\t(pushlevel): Remove declaration.\n\t* decl.c (push_binding_level): Fold in begin_scope.  Remove.\n\t(struct cp_binding_level): Remove tag_tranparent field.  Make keep\n\tof bitsize one.\n\t(keep_next_level_flag): Make a bool.\n\t(cxx_scope_descriptor): Update scope names table\n\t(make_cxx_scope): Fold in begin_scope.  Remove..\n\t(namespace_scope_ht_size): New function.\n\t(begin_scope): Change prototype.  Return a scope.  Tidy.\n\t(kept_level_p): Update.\n\t(pushlevel): Remove.\n\t(maybe_push_cleanup_level): Simplify.\n\t(poplevel): Update for sk_cleanup and keep change.\n\t(print_binding_level): Likewise.\n\t(initial_push_namespace_scope): Fold in begin_scope.  Remove.\n\t(push_namespace): Update.\n\t(pushtag): Likewise.\n\t(lookup_tag): Likewise.\n\t(lookup_name_current_level): Likewise.\n\t(lookup_type_current_level): Likewise.\n\t(cxx_init_decl_processing): Likewise.\n\t(start_function): Likewise.\n\t(begin_function_body): Likewise.\n\t(start_method): Likewise.\n\t* pt.c (push_inline_template_parms_recursive): Likewise.\n\t(begin_template_parm_list): Likewise.\n\t(begin_specialization): Likewise.\n\t* semantics.c (do_pushlevel): Likewise.\n\t(begin_compound_stmt): Likewise.\n\t(begin_stmt_expr): Likewise.\n\nFrom-SVN: r71683", "tree": {"sha": "7ed60f69034fa22ef77ea47b08b2a73bc35cf78c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ed60f69034fa22ef77ea47b08b2a73bc35cf78c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3504b199c283afd4d48cbd0f786fa6fd33a11a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3504b199c283afd4d48cbd0f786fa6fd33a11a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3504b199c283afd4d48cbd0f786fa6fd33a11a13"}], "stats": {"total": 261, "additions": 146, "deletions": 115}, "files": [{"sha": "5804f9ff4dcff01104a1b1fde887ffbdfc398880", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "patch": "@@ -1,3 +1,39 @@\n+2003-09-22  Gabriel Dos Reis  <gcc@integrable-solutions.net>\n+\n+\t* cp-tree.h (scope_kind): Add new enumerator.\n+\t(keep_next_level): Change parameter type to bool.\n+\t(begin_scope):  Change prototype.\n+\t(pushlevel): Remove declaration.\n+\t* decl.c (push_binding_level): Fold in begin_scope.  Remove.\n+\t(struct cp_binding_level): Remove tag_tranparent field.  Make keep\n+\tof bitsize one.\n+\t(keep_next_level_flag): Make a bool.\n+\t(cxx_scope_descriptor): Update scope names table\n+\t(make_cxx_scope): Fold in begin_scope.  Remove..\n+\t(namespace_scope_ht_size): New function.\n+\t(begin_scope): Change prototype.  Return a scope.  Tidy.\n+\t(kept_level_p): Update.\n+\t(pushlevel): Remove.\n+\t(maybe_push_cleanup_level): Simplify.\n+\t(poplevel): Update for sk_cleanup and keep change.\n+\t(print_binding_level): Likewise.\n+\t(initial_push_namespace_scope): Fold in begin_scope.  Remove.\n+\t(push_namespace): Update.\n+\t(pushtag): Likewise.\n+\t(lookup_tag): Likewise.\n+\t(lookup_name_current_level): Likewise.\n+\t(lookup_type_current_level): Likewise.\n+\t(cxx_init_decl_processing): Likewise.\n+\t(start_function): Likewise.\n+\t(begin_function_body): Likewise.\n+\t(start_method): Likewise.\n+\t* pt.c (push_inline_template_parms_recursive): Likewise.\n+\t(begin_template_parm_list): Likewise.\n+\t(begin_specialization): Likewise.\n+\t* semantics.c (do_pushlevel): Likewise.\n+\t(begin_compound_stmt): Likewise.\n+\t(begin_stmt_expr): Likewise.\n+\n 2003-09-21  Richard Henderson  <rth@redhat.com>\n \n \t* class.c, cp-tree.h, decl.c, decl2.c, error.c, init.c,"}, {"sha": "5118b782bc0fb9ae7ad65756c5134d84162b8ce1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "patch": "@@ -2935,6 +2935,9 @@ typedef enum scope_kind {\n \t\t\tis initialized by using \"memset\" to set the\n \t\t\tcontents to zero, and the default scope kind\n \t\t\tis \"sk_block\".  */\n+  sk_cleanup,        /* A scope for (pseudo-)scope for cleanup.  It is\n+                        peusdo in that it is transparent to name lookup\n+                        activities.  */\n   sk_try,\t     /* A try-block.  */\n   sk_catch,          /* A catch-block.  */\n   sk_for,            /* The scope of the variable declared in a\n@@ -3609,7 +3612,6 @@ extern void adjust_clone_args\t\t\t(tree);\n extern int global_bindings_p\t\t\t(void);\n extern int kept_level_p\t\t\t\t(void);\n extern tree getdecls\t\t\t\t(void);\n-extern void pushlevel\t\t\t\t(int);\n extern void insert_block\t\t\t(tree);\n extern void set_block\t\t\t\t(tree);\n extern tree pushdecl\t\t\t\t(tree);\n@@ -3622,12 +3624,12 @@ extern void cxx_pop_function_context\t\t(struct function *);\n extern void cxx_mark_function_context\t\t(struct function *);\n extern int toplevel_bindings_p\t\t\t(void);\n extern int namespace_bindings_p\t\t\t(void);\n-extern void keep_next_level\t\t\t(int);\n+extern void keep_next_level (bool);\n extern scope_kind innermost_scope_kind          (void);\n extern int template_parm_scope_p\t\t(void);\n extern void set_class_shadows\t\t\t(tree);\n extern void maybe_push_cleanup_level\t\t(tree);\n-extern void begin_scope                         (scope_kind);\n+extern cxx_scope *begin_scope (scope_kind, tree);\n extern void finish_scope                        (void);\n extern void resume_level\t\t\t(struct cp_binding_level *);\n extern void delete_block\t\t\t(tree);"}, {"sha": "9538a1e9e22fce7e27ed51e12e61e0ecb9719f29", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 98, "deletions": 106, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "patch": "@@ -55,7 +55,6 @@ Boston, MA 02111-1307, USA.  */\n static tree grokparms (tree);\n static const char *redeclaration_error_message (tree, tree);\n \n-static void push_binding_level (cxx_scope *);\n static void pop_binding_level (void);\n static void suspend_binding_level (void);\n static void resume_binding_level (struct cp_binding_level *);\n@@ -382,19 +381,15 @@ struct cp_binding_level GTY(())\n        only valid if KIND == SK_TEMPLATE_PARMS.  */\n     bool explicit_spec_p : 1;\n \n-    /* 1 means make a BLOCK for this level regardless of all else.\n-       2 for temporary binding contours created by the compiler.  */\n-    unsigned keep : 2;\n+    /* true means make a BLOCK for this level regardless of all else.  */\n+    unsigned keep : 1;\n \n     /* Nonzero if this level can safely have additional\n        cleanup-needing variables added to it.  */\n     unsigned more_cleanups_ok : 1;\n     unsigned have_cleanups : 1;\n \n-    /* Nonzero if this level \"doesn't exist\" for tags.  */\n-    unsigned tag_transparent : 1;\n-\n-    /* 20 bits left to fill a 32-bit word.  */\n+    /* 22 bits left to fill a 32-bit word.  */\n   };\n \n #define NULL_BINDING_LEVEL ((struct cp_binding_level *) NULL)\n@@ -414,9 +409,9 @@ struct cp_binding_level GTY(())\n \n static GTY((deletable (\"\"))) struct cp_binding_level *free_binding_level;\n \n-/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n+/* true means unconditionally make a BLOCK for the next level pushed.  */\n \n-static int keep_next_level_flag;\n+static bool keep_next_level_flag;\n \n /* A TREE_LIST of VAR_DECLs.  The TREE_PURPOSE is a RECORD_TYPE or\n    UNION_TYPE; the TREE_VALUE is a VAR_DECL with that type.  At the\n@@ -452,6 +447,7 @@ cxx_scope_descriptor (cxx_scope *scope)\n      enumerators.  */\n   static const char* scope_kind_names[] = {\n     \"block-scope\",\n+    \"cleanup-scope\",\n     \"try-scope\",\n     \"catch-scope\",\n     \"for-scope\",\n@@ -461,8 +457,10 @@ cxx_scope_descriptor (cxx_scope *scope)\n     \"template-parameter-scope\",\n     \"template-explicit-spec-scope\"\n   };\n+  const scope_kind kind = scope->explicit_spec_p\n+    ? sk_template_spec : scope->kind;\n \n-  return scope_kind_names[scope->kind];\n+  return scope_kind_names[kind];\n }\n \n /* Output a debugging information about SCOPE when performning\n@@ -478,10 +476,27 @@ cxx_scope_debug (cxx_scope *scope, int line, const char *action)\n     verbatim (\"%s %s %p %d\\n\", action, desc, (void *) scope, line);\n }\n \n-/* Construct a scope that may be TAG-TRANSPARENT, the sub-blocks of\n-   which may be KEPT.  */\n-static inline cxx_scope *\n-make_cxx_scope (bool tag_transparent, int keep)\n+/* Return the estimated initial size of the hashtable of a NAMESPACE\n+   scope.  */\n+\n+static inline size_t\n+namespace_scope_ht_size (tree ns)\n+{\n+  tree name = DECL_NAME (ns);\n+\n+  return name == std_identifier\n+    ? NAMESPACE_STD_HT_SIZE\n+    : (name == global_scope_name\n+       ? GLOBAL_SCOPE_HT_SIZE\n+       : NAMESPACE_ORDINARY_HT_SIZE);\n+}\n+\n+/* Create a new KIND scope and make it the top of the active scopes stack.\n+   ENTITY is the scope of the associated C++ entity (namespace, class,\n+   function); it is NULL otherwise.  */\n+\n+cxx_scope *\n+begin_scope (scope_kind kind, tree entity)\n {\n   cxx_scope *scope;\n   \n@@ -493,31 +508,62 @@ make_cxx_scope (bool tag_transparent, int keep)\n     }\n   else\n     scope = ggc_alloc (sizeof (cxx_scope));\n-\n   memset (scope, 0, sizeof (cxx_scope));\n-  scope->tag_transparent = tag_transparent;\n-  scope->keep = keep;\n+\n+  scope->this_entity = entity;\n   scope->more_cleanups_ok = true;\n+  switch (kind)\n+    {\n+    case sk_cleanup:\n+      scope->keep = true;\n+      break;\n+      \n+    case sk_template_spec:\n+      scope->explicit_spec_p = true;\n+      kind = sk_template_parms;\n+      /* fall through */\n+    case sk_template_parms:\n+    case sk_block:\n+    case sk_try:\n+    case sk_catch:\n+    case sk_for:\n+    case sk_class:\n+    case sk_function_parms:\n+      scope->keep = keep_next_level_flag;\n+      break;\n \n-  return scope;\n-}\n+    case sk_namespace:\n+      scope->type_decls = binding_table_new (namespace_scope_ht_size (entity));\n+      NAMESPACE_LEVEL (entity) = scope;\n+      VARRAY_TREE_INIT (scope->static_decls,\n+                        DECL_NAME (entity) == std_identifier\n+                        || DECL_NAME (entity) == global_scope_name\n+                        ? 200 : 10,\n+                        \"Static declarations\");\n+      break;\n \n-static void\n-push_binding_level (cxx_scope *newlevel)\n-{\n-  /* Add this level to the front of the chain (stack) of levels that\n-     are active.  */\n-  newlevel->level_chain = current_binding_level;\n-  current_binding_level = newlevel;\n+    default:\n+      /* Should not happen.  */\n+      my_friendly_assert (false, 20030922);\n+      break;\n+    }\n+  scope->kind = kind;\n+\n+  /* Add it to the front of currently active scopes stack.  */\n+  scope->level_chain = current_binding_level;\n+  current_binding_level = scope;\n+  keep_next_level_flag = false;\n \n   if (ENABLE_SCOPE_CHECKING)\n     {\n-      newlevel->binding_depth = binding_depth;\n+      scope->binding_depth = binding_depth;\n       indent (binding_depth);\n-      cxx_scope_debug (newlevel, input_location.line, \"push\");\n+      cxx_scope_debug (scope, input_location.line, \"push\");\n       is_class_level = 0;\n       binding_depth++;\n     }\n+\n+  return scope;\n }\n \n /* Find the innermost enclosing class scope, and reset\n@@ -664,12 +710,12 @@ namespace_bindings_p (void)\n   return b->kind == sk_namespace;\n }\n \n-/* If KEEP is nonzero, make a BLOCK node for the next binding level,\n+/* If KEEP is true, make a BLOCK node for the next binding level,\n    unconditionally.  Otherwise, use the normal logic to decide whether\n    or not to create a BLOCK.  */\n \n void\n-keep_next_level (int keep)\n+keep_next_level (bool keep)\n {\n   keep_next_level_flag = keep;\n }\n@@ -681,9 +727,9 @@ kept_level_p (void)\n {\n   return (current_binding_level->blocks != NULL_TREE\n \t  || current_binding_level->keep\n+          || current_binding_level->kind == sk_cleanup\n \t  || current_binding_level->names != NULL_TREE\n-\t  || (current_binding_level->type_decls != NULL\n-\t      && !current_binding_level->tag_transparent));\n+\t  || current_binding_level->type_decls != NULL);\n }\n \n /* Returns the kind of the innermost scope.  */\n@@ -799,17 +845,6 @@ set_class_shadows (tree shadows)\n   class_binding_level->class_shadowed = shadows;\n }\n \n-/* Enter a new binding level.\n-   If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,\n-   not for that of tags.  */\n-\n-void\n-pushlevel (int tag_transparent)\n-{\n-  push_binding_level (make_cxx_scope (tag_transparent, keep_next_level_flag));\n-  keep_next_level_flag = 0;\n-}\n-\n /* We're defining an object of type TYPE.  If it needs a cleanup, but\n    we're not allowed to add any more objects with cleanups to the current\n    scope, create a new binding level.  */\n@@ -820,27 +855,11 @@ maybe_push_cleanup_level (tree type)\n   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n       && current_binding_level->more_cleanups_ok == 0)\n     {\n-      keep_next_level (2);\n-      pushlevel (1);\n+      begin_scope (sk_cleanup, NULL);\n       clear_last_expr ();\n       add_scope_stmt (/*begin_p=*/1, /*partial_p=*/1);\n     }\n }\n-  \n-/* Enter a new scope.  The KIND indicates what kind of scope is being\n-   created.  */\n-\n-void\n-begin_scope (scope_kind sk)\n-{\n-  pushlevel (0);\n-  if (sk == sk_template_spec)\n-    {\n-      current_binding_level->explicit_spec_p = true;\n-      sk = sk_template_parms;\n-    }\n-  current_binding_level->kind = sk;\n-}\n \n /* Exit the current scope.  */\n \n@@ -1116,12 +1135,13 @@ poplevel (int keep, int reverse, int functionbody)\n   tree block = NULL_TREE;\n   tree decl;\n   int leaving_for_scope;\n+  scope_kind kind;\n \n   timevar_push (TV_NAME_LOOKUP);\n \n   my_friendly_assert (current_binding_level->kind != sk_class, 19990916);\n \n-  real_functionbody = (current_binding_level->keep == 2\n+  real_functionbody = (current_binding_level->kind == sk_cleanup\n \t\t       ? ((functionbody = 0), tmp) : functionbody);\n   subblocks = functionbody >= 0 ? current_binding_level->blocks : 0;\n \n@@ -1133,7 +1153,7 @@ poplevel (int keep, int reverse, int functionbody)\n      rather than the end.  This hack is no longer used.  */\n   my_friendly_assert (keep == 0 || keep == 1, 0);\n \n-  if (current_binding_level->keep == 1)\n+  if (current_binding_level->keep)\n     keep = 1;\n \n   /* Any uses of undefined labels, and any defined labels, now operate\n@@ -1365,7 +1385,7 @@ poplevel (int keep, int reverse, int functionbody)\n       pop_labels (block);\n     }\n \n-  tmp = current_binding_level->keep;\n+  kind = current_binding_level->kind;\n \n   pop_binding_level ();\n   if (functionbody)\n@@ -1390,7 +1410,7 @@ poplevel (int keep, int reverse, int functionbody)\n     TREE_USED (block) = 1;\n \n   /* Take care of compiler's internal binding structures.  */\n-  if (tmp == 2)\n+  if (kind == sk_cleanup)\n     {\n       tree scope_stmts;\n \n@@ -1461,9 +1481,7 @@ pushlevel_class (void)\n   if (ENABLE_SCOPE_CHECKING)\n     is_class_level = 1;\n \n-  begin_scope (sk_class);\n-  class_binding_level = current_binding_level;\n-  class_binding_level->this_entity = current_class_type;\n+  class_binding_level = begin_scope (sk_class, current_class_type);\n }\n \n /* ...and a poplevel for class declarations.  */\n@@ -1770,8 +1788,6 @@ print_binding_level (struct cp_binding_level* lvl)\n   tree t;\n   int i = 0, len;\n   fprintf (stderr, \" blocks=\" HOST_PTR_PRINTF, (void *) lvl->blocks);\n-  if (lvl->tag_transparent)\n-    fprintf (stderr, \" tag-transparent\");\n   if (lvl->more_cleanups_ok)\n     fprintf (stderr, \" more-cleanups-ok\");\n   if (lvl->have_cleanups)\n@@ -1877,30 +1893,6 @@ print_binding_stack (void)\n    the identifier is polymorphic, with three possible values:\n    NULL_TREE, a list of \"cxx_binding\"s.  */\n \n-\n-/* Push the initial binding contour of NAMESPACE-scope.  Any subsequent\n-   push of NS is actually a resume.  */\n-static void\n-initial_push_namespace_scope (tree ns)\n-{\n-  tree name = DECL_NAME (ns);\n-  cxx_scope *scope;\n-\n-  begin_scope (sk_namespace);\n-  scope = current_binding_level;\n-  scope->type_decls = binding_table_new (name == std_identifier\n-                                         ? NAMESPACE_STD_HT_SIZE\n-                                         : (name == global_scope_name\n-                                            ? GLOBAL_SCOPE_HT_SIZE\n-                                            : NAMESPACE_ORDINARY_HT_SIZE));\n-  VARRAY_TREE_INIT (scope->static_decls,\n-                    name == std_identifier || name == global_scope_name\n-                    ? 200 : 10,\n-                    \"Static declarations\");\n-  scope->this_entity = ns;\n-  NAMESPACE_LEVEL (ns) = scope;\n-}\n-\n /* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n    select a name that is unique to this compilation unit.  */\n \n@@ -1954,7 +1946,7 @@ push_namespace (tree name)\n       d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n       DECL_CONTEXT (d) = FROB_CONTEXT (current_namespace);\n       d = pushdecl (d);\n-      initial_push_namespace_scope (d);\n+      begin_scope (sk_namespace, d);\n     }\n   else\n     resume_binding_level (NAMESPACE_LEVEL (d));\n@@ -2400,7 +2392,7 @@ push_local_name (tree decl)\n }\n \n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n-   Normally put it into the inner-most non-tag-transparent scope,\n+   Normally put it into the inner-most non-sk_cleanup scope,\n    but if GLOBALIZE is true, put it in the inner-most non-class scope.\n    The latter is needed for implicit declarations.  */\n \n@@ -2411,7 +2403,7 @@ pushtag (tree name, tree type, int globalize)\n \n   timevar_push (TV_NAME_LOOKUP);\n   b = current_binding_level;\n-  while (b->tag_transparent\n+  while (b->kind == sk_cleanup\n \t || (b->kind == sk_class\n \t     && (globalize\n \t\t /* We may be defining a new type in the initializer\n@@ -2553,7 +2545,7 @@ clear_anon_tags (void)\n     return;\n \n   b = current_binding_level;\n-  while (b->tag_transparent)\n+  while (b->kind == sk_cleanup)\n     b = b->level_chain;\n   if (b->type_decls != NULL)\n     binding_table_remove_anonymous_types (b->type_decls);\n@@ -5015,7 +5007,7 @@ follow_tag_typedef (tree type)\n    return the structure (or union or enum) definition for that name.\n    Searches binding levels from BINDING_SCOPE up to the global level.\n    If THISLEVEL_ONLY is nonzero, searches only the specified context\n-   (but skips any tag-transparent contexts to find one that is\n+   (but skips any sk_cleanup contexts to find one that is\n    meaningful for tags).\n    FORM says which kind of type the caller wants;\n    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.\n@@ -5103,7 +5095,7 @@ lookup_tag (enum tree_code form, tree name,\n               POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->type);\n             }\n \t  }\n-      if (thislevel_only && ! level->tag_transparent)\n+      if (thislevel_only && level->kind != sk_cleanup)\n \t{\n \t  if (level->kind == sk_template_parms && allow_template_parms_p)\n \t    {\n@@ -5869,7 +5861,7 @@ lookup_name_current_level (tree name)\n \t  if (BINDING_SCOPE (IDENTIFIER_BINDING (name)) == b)\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, IDENTIFIER_VALUE (name));\n \n-\t  if (b->keep == 2)\n+\t  if (b->kind == sk_cleanup)\n \t    b = b->level_chain;\n \t  else\n \t    break;\n@@ -5899,7 +5891,7 @@ lookup_type_current_level (tree name)\n \t  if (purpose_member (name, b->type_shadowed))\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n                                     REAL_IDENTIFIER_TYPE_VALUE (name));\n-\t  if (b->keep == 2)\n+\t  if (b->kind == sk_cleanup)\n \t    b = b->level_chain;\n \t  else\n \t    break;\n@@ -6100,7 +6092,7 @@ cxx_init_decl_processing (void)\n   my_friendly_assert (global_namespace == NULL_TREE, 375);\n   global_namespace = build_lang_decl (NAMESPACE_DECL, global_scope_name,\n                                       void_type_node);\n-  initial_push_namespace_scope (global_namespace);\n+  begin_scope (sk_namespace, global_namespace);\n \n   current_lang_name = NULL_TREE;\n \n@@ -13582,7 +13574,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n \tDECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n \n-  begin_scope (sk_function_parms);\n+  begin_scope (sk_function_parms, decl1);\n \n   ++function_depth;\n \n@@ -13834,7 +13826,7 @@ begin_function_body (void)\n     /* Always keep the BLOCK node associated with the outermost pair of\n        curly braces of a function.  These are needed for correct\n        operation of dwarfout.c.  */\n-    keep_next_level (1);\n+    keep_next_level (true);\n \n   stmt = begin_compound_stmt (/*has_no_scope=*/false);\n   COMPOUND_STMT_BODY_BLOCK (stmt) = 1;\n@@ -14159,7 +14151,7 @@ start_method (tree declspecs, tree declarator, tree attrlist)\n   cp_finish_decl (fndecl, NULL_TREE, NULL_TREE, 0);\n \n   /* Make a place for the parms */\n-  begin_scope (sk_function_parms);\n+  begin_scope (sk_function_parms, fndecl);\n \n   DECL_IN_AGGR_P (fndecl) = 1;\n   return fndecl;"}, {"sha": "aad6c6038ffa2fd48ded832f1e75e8658c34a278", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "patch": "@@ -352,7 +352,8 @@ push_inline_template_parms_recursive (tree parmlist, int levels)\n \t\t parms, current_template_parms);\n   TEMPLATE_PARMS_FOR_INLINE (current_template_parms) = 1;\n \n-  pushlevel (0);\n+  begin_scope (TREE_VEC_LENGTH (parms) ? sk_template_parms : sk_template_spec,\n+               NULL);\n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i) \n     {\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n@@ -609,7 +610,7 @@ begin_template_parm_list (void)\n \n      pushtag contains special code to call pushdecl_with_scope on the\n      TEMPLATE_DECL for S2.  */\n-  begin_scope (sk_template_parms);\n+  begin_scope (sk_template_parms, NULL);\n   ++processing_template_decl;\n   ++processing_template_parmlist;\n   note_template_header (0);\n@@ -653,7 +654,7 @@ check_specialization_scope (void)\n void\n begin_specialization (void)\n {\n-  begin_scope (sk_template_spec);\n+  begin_scope (sk_template_spec, NULL);\n   note_template_header (1);\n   check_specialization_scope ();\n }"}, {"sha": "6650bff7e277cd772c2823fd84f9fba8ca301db0", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac20c67af10d2f8aadabeb255ff66f31364e9e6d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ac20c67af10d2f8aadabeb255ff66f31364e9e6d", "patch": "@@ -360,7 +360,7 @@ do_pushlevel (scope_kind sk)\n     {\n       if (!processing_template_decl)\n \tadd_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n-      begin_scope (sk);\n+      begin_scope (sk, NULL);\n     }\n }\n \n@@ -1004,7 +1004,7 @@ begin_compound_stmt (bool has_no_scope)\n        statement-expression.  But, if it's a statement-expression with\n        a scopeless block, there's nothing to keep, and we don't want\n        to accidentally keep a block *inside* the scopeless block.  */ \n-    keep_next_level (0);\n+    keep_next_level (false);\n \n   return r;\n }\n@@ -1408,7 +1408,7 @@ begin_stmt_expr (void)\n \n   last_expr_type = NULL_TREE;\n   \n-  keep_next_level (1);\n+  keep_next_level (true);\n \n   return last_tree; \n }"}]}