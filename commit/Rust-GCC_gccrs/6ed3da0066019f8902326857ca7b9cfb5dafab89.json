{"sha": "6ed3da0066019f8902326857ca7b9cfb5dafab89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVkM2RhMDA2NjAxOWY4OTAyMzI2ODU3Y2E3YjljZmI1ZGFmYWI4OQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-07-07T13:00:43Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-07-07T13:00:43Z"}, "message": "auto-inc-dec.c, [...]: Fix comment typos.\n\n\t* auto-inc-dec.c, config/arm/arm.c,\n\tconfig/m32r/constraints.md, config/mips/mips.md,\n\tconfig/rs6000/rs6000.c, cselib.c, dce.c, df-core.c,\n\tdf-problems.c, df-scan.c, df.h, dse.c, gimplify.c,\n\ttree-if-conv.c, tree-ssa-sccvn.c, tree-ssa.c: Fix comment\n\ttypos.  Follow spelling conventions.\n\t* doc/invoke.texi, doc/rtl.texi: Fix typos.\n\nFrom-SVN: r126439", "tree": {"sha": "2df17d84a1e7c3d50ad947abc81829a2a46d4f60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2df17d84a1e7c3d50ad947abc81829a2a46d4f60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ed3da0066019f8902326857ca7b9cfb5dafab89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ed3da0066019f8902326857ca7b9cfb5dafab89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ed3da0066019f8902326857ca7b9cfb5dafab89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ed3da0066019f8902326857ca7b9cfb5dafab89/comments", "author": null, "committer": null, "parents": [{"sha": "acde59b4419ee48716341483ad5576b9420ecc34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acde59b4419ee48716341483ad5576b9420ecc34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acde59b4419ee48716341483ad5576b9420ecc34"}], "stats": {"total": 80, "additions": 45, "deletions": 35}, "files": [{"sha": "81bb7475af99d9e336d65414b045f9a4502e2361", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -1,3 +1,13 @@\n+2007-07-07  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* auto-inc-dec.c, config/arm/arm.c,\n+\tconfig/m32r/constraints.md, config/mips/mips.md,\n+\tconfig/rs6000/rs6000.c, cselib.c, dce.c, df-core.c,\n+\tdf-problems.c, df-scan.c, df.h, dse.c, gimplify.c,\n+\ttree-if-conv.c, tree-ssa-sccvn.c, tree-ssa.c: Fix comment\n+\ttypos.  Follow spelling conventions.\n+\t* doc/invoke.texi, doc/rtl.texi: Fix typos.\n+\n 2007-07-06  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/23488"}, {"sha": "bde2a75fb28076d6c3f8e66a08e5f156db8e9ae3", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -1276,7 +1276,7 @@ find_inc (bool first_try)\n \t next add or inc, not the next insn that used the\n \t reg.  Because we are going to increment the reg\n \t in this form, we need to make sure that there\n-\t were no interveining uses of reg.  */\n+\t were no intervening uses of reg.  */\n       if (inc_insn.insn != other_insn)\n \treturn false;\n     }"}, {"sha": "c1f37bffa6c46c73cf754050af8dca828a2506c8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -5822,8 +5822,8 @@ vfp3_const_double_index (rtx x)\n   gcc_assert (mantissa >= 16 && mantissa <= 31);\n \n   /* The value of 5 here would be 4 if GCC used IEEE754-like encoding (where\n-     normalised significands are in the range [1, 2). (Our mantissa is shifted\n-     left 4 places at this point relative to normalised IEEE754 values).  GCC\n+     normalized significands are in the range [1, 2). (Our mantissa is shifted\n+     left 4 places at this point relative to normalized IEEE754 values).  GCC\n      internally uses [0.5, 1) (see real.c), so the exponent returned from\n      REAL_EXP must be altered.  */\n   exponent = 5 - exponent;"}, {"sha": "6d8161f1e6b465a82686f115b1ca5120881701ef", "filename": "gcc/config/m32r/constraints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fconfig%2Fm32r%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fconfig%2Fm32r%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fconstraints.md?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -104,13 +104,13 @@\n \n ;; Extra constraints\n (define_constraint \"Q\"\n-  \"A symbolic addresse loadable when ld24.\"\n+  \"A symbolic address loadable when ld24.\"\n   (ior (and (match_test \"TARGET_ADDR24\")\n \t    (match_test \"GET_CODE (op) == LABEL_REF\"))\n        (match_test \"addr24_operand (op, VOIDmode)\")))\n \n (define_constraint \"R\"\n-  \"A symbolic addresse loadable with ld24 can't be used.\"\n+  \"A symbolic address loadable with ld24 can't be used.\"\n   (ior (and (match_test \"TARGET_ADDR32\")\n \t    (match_test \"GET_CODE (op) == LABEL_REF\"))\n        (match_test \"addr32_operand (op, VOIDmode)\")))"}, {"sha": "255d6e65c90a55511bb39d477134843a1da67638", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -256,7 +256,7 @@\n ;; logical      integer logical instructions\n ;; shift\tinteger shift instructions\n ;; slt\t\tset less than instructions\n-;; signext      sign extend instuctions\n+;; signext      sign extend instructions\n ;; clz\t\tthe clz and clo instructions\n ;; trap\t\ttrap if instructions\n ;; imul\t\tinteger multiply 2 operands"}, {"sha": "09c21ebf76db9cd259b83e8546c6b7b7f86b8596", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -15629,7 +15629,7 @@ rs6000_emit_epilogue (int sibcall)\n       else\n         {\n           /* Make r11 point to the start of the SPE save area.  We worried about\n-             not clobbering it when we were saving registers in the prolgoue.\n+             not clobbering it when we were saving registers in the prologue.\n              There's no need to worry here because the static chain is passed\n              anew to every function.  */\n           spe_save_area_ptr = gen_rtx_REG (Pmode, 11);"}, {"sha": "3528efb7e0ec74ed9bd44e2edee4cda30d2906f6", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -948,7 +948,7 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n \t      int regno = REGNO (orig);\n \t      \n \t      /* The only thing that we are not willing to do (this\n-\t\t is requirement of dse and if others potiential uses\n+\t\t is requirement of dse and if others potential uses\n \t\t need this function we should add a parm to control\n \t\t it) is that we will not substitute the\n \t\t STACK_POINTER_REGNUM, FRAME_POINTER or the"}, {"sha": "71823be10cfa7b18cd507cf48e0422963433ded3", "filename": "gcc/dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -398,7 +398,7 @@ prescan_insns_for_dce (bool fast)\n \n /* UD-based DSE routines. */\n \n-/* Mark instructions that define artifically-used registers, such as\n+/* Mark instructions that define artificially-used registers, such as\n    the frame pointer and the stack pointer.  */\n \n static void"}, {"sha": "4418d2c363d3f6716df9830ddd3c3e597d221e92", "filename": "gcc/df-core.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -207,7 +207,7 @@ There are four ways of doing the incremental scanning:\n    insns when only a small number of them have really changed.\n \n 4) Do it yourself - In this mechanism, the pass updates the insns\n-   itself using the low level df primatives.  Currently no pass does\n+   itself using the low level df primitives.  Currently no pass does\n    this, but it has the advantage that it is quite efficient given\n    that the pass generally has exact knowledge of what it is changing.  \n \n@@ -1502,7 +1502,7 @@ df_bb_delete (int bb_index)\n /* Verify that there is a place for everything and everything is in\n    its place.  This is too expensive to run after every pass in the\n    mainline.  However this is an excellent debugging tool if the\n-   dataflow infomation is not being updated properly.  You can just\n+   dataflow information is not being updated properly.  You can just\n    sprinkle calls in until you find the place that is changing an\n    underlying structure without calling the proper updating\n    routine.  */"}, {"sha": "010ff27d61ac03ab88cabae464e5c496971f161f", "filename": "gcc/df-problems.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -713,7 +713,7 @@ static struct df_problem problem_RU =\n   df_ru_top_dump,             /* Debugging start block.  */\n   df_ru_bottom_dump,          /* Debugging end block.  */\n   NULL,                       /* Incremental solution verify start.  */\n-  NULL,                       /* Incremental solution verfiy end.  */\n+  NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n   TV_DF_RU,                   /* Timing variable.  */\n   true                        /* Reset blocks on dropping out of blocks_to_analyze.  */\n@@ -1211,7 +1211,7 @@ static struct df_problem problem_RD =\n   df_rd_top_dump,             /* Debugging start block.  */\n   df_rd_bottom_dump,          /* Debugging end block.  */\n   NULL,                       /* Incremental solution verify start.  */\n-  NULL,                       /* Incremental solution verfiy end.  */\n+  NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n   TV_DF_RD,                   /* Timing variable.  */ \n   true                        /* Reset blocks on dropping out of blocks_to_analyze.  */\n@@ -3072,7 +3072,7 @@ static struct df_problem problem_UREC =\n   df_urec_top_dump,           /* Debugging start block.  */\n   df_urec_bottom_dump,        /* Debugging end block.  */\n   NULL,                       /* Incremental solution verify start.  */\n-  NULL,                       /* Incremental solution verfiy end.  */\n+  NULL,                       /* Incremental solution verify end.  */\n   &problem_LR,                /* Dependent problem.  */\n   TV_DF_UREC,                 /* Timing variable.  */ \n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n@@ -3553,7 +3553,7 @@ static struct df_problem problem_CHAIN =\n   df_chain_top_dump,          /* Debugging start block.  */\n   df_chain_bottom_dump,       /* Debugging end block.  */\n   NULL,                       /* Incremental solution verify start.  */\n-  NULL,                       /* Incremental solution verfiy end.  */\n+  NULL,                       /* Incremental solution verify end.  */\n   &problem_RD,                /* Dependent problem.  */\n   TV_DF_CHAIN,                /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n@@ -4138,7 +4138,7 @@ static struct df_problem problem_NOTE =\n   NULL,                       /* Debugging start block.  */\n   NULL,                       /* Debugging end block.  */\n   NULL,                       /* Incremental solution verify start.  */\n-  NULL,                       /* Incremental solution verfiy end.  */\n+  NULL,                       /* Incremental solution verify end.  */\n \n   /* Technically this is only dependent on the live registers problem\n      but it will produce information if built one of uninitialized"}, {"sha": "3b35928ea1a2ed6bcf6f4cb8d87251c2fefa26c7", "filename": "gcc/df-scan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -433,7 +433,7 @@ static struct df_problem problem_SCAN =\n   df_scan_start_block,        /* Debugging start block.  */\n   NULL,                       /* Debugging end block.  */\n   NULL,                       /* Incremental solution verify start.  */\n-  NULL,                       /* Incremental solution verfiy end.  */\n+  NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n   TV_DF_SCAN,                 /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n@@ -3432,7 +3432,7 @@ df_get_eh_block_artificial_uses (bitmap eh_block_artificial_uses)\n {\n   bitmap_clear (eh_block_artificial_uses);\n \n-  /* The following code (down thru the arg_pointer seting APPEARS\n+  /* The following code (down thru the arg_pointer setting APPEARS\n      to be necessary because there is nothing that actually\n      describes what the exception handling code may actually need\n      to keep alive.  */"}, {"sha": "7d8d767b026835ca2ad3fba526fec12645a17493", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -530,7 +530,7 @@ struct df\n      addresses.  It is incremented whenever a ref is created.  */\n   unsigned int ref_order;\n \n-  /* Problem specific control infomation.  */\n+  /* Problem specific control information.  */\n   enum df_changeable_flags changeable_flags;\n };\n "}, {"sha": "4f4d7d1f1bd5dfc4549c7141ca081af022ef86b6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -10390,7 +10390,7 @@ or @code{remainder} built-in functions: see @ref{Other Builtins} for details.\n This option will enable GCC to use RCPSS and RSQRTSS instructions (and their\n vectorized variants RCPPS and RSQRTPS) instead of DIVSS and SQRTSS (and their\n vectorized variants).  These instructions will be generated only when\n-@option{-funsafe-math-optimizatons} is enabled.\n+@option{-funsafe-math-optimizations} is enabled.\n \n @item -mpush-args\n @itemx -mno-push-args"}, {"sha": "247a22e9ad3c580d9580562a6cc0d81a1141370d", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -3370,7 +3370,7 @@ A list (chain of @code{insn_list} expressions) giving information about\n dependencies between instructions within a basic block.  Neither a jump\n nor a label may come between the related insns.  These are only used by\n the schedulers and by combine.  This is a deprecated data structure.\n-Def-use and use-def chains are now prefered. \n+Def-use and use-def chains are now preferred. \n \n @findex REG_NOTES\n @item REG_NOTES (@var{i})"}, {"sha": "1f7588df3476cfc0af5a84b7e549c9f1c26caf21", "filename": "gcc/dse.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -144,7 +144,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    ... <- A\n \n    flow would replace the right hand side of the second insn with a\n-   reference to r100.  Most of the infomation is available to add this\n+   reference to r100.  Most of the information is available to add this\n    to this pass.  It has not done it because it is a lot of work in\n    the case that either r100 is assigned to between the first and\n    second insn and/or the second insn is a load of part of the value\n@@ -303,7 +303,7 @@ struct insn_info\n      insn.  If the insn is deletable, it contains only one mem set.\n      But it could also contain clobbers.  Insns that contain more than\n      one mem set are not deletable, but each of those mems are here in\n-     order to provied info to delete other insns.  */\n+     order to provide info to delete other insns.  */\n   store_info_t store_rec;\n \n   /* The linked list of mem uses in this insn.  Only the reads from\n@@ -403,9 +403,9 @@ struct group_info\n   rtx canon_base_mem;\n \n   /* These two sets of two bitmaps are used to keep track of how many\n-     stores are actually referencing that postion from this base.  We\n+     stores are actually referencing that position from this base.  We\n      only do this for rtx bases as this will be used to assign\n-     postions in the bitmaps for the global problem.  Bit N is set in\n+     positions in the bitmaps for the global problem.  Bit N is set in\n      store1 on the first store for offset N.  Bit N is set in store2\n      for the second store to offset N.  This is all we need since we\n      only care about offsets that have two or more stores for them.\n@@ -420,9 +420,9 @@ struct group_info\n      deleted.  */\n   bitmap store1_n, store1_p, store2_n, store2_p;\n \n-  /* The postions in this bitmap have the same assignments as the in,\n+  /* The positions in this bitmap have the same assignments as the in,\n      out, gen and kill bitmaps.  This bitmap is all zeros except for\n-     the postions that are occupied by stores for this group.  */\n+     the positions that are occupied by stores for this group.  */\n   bitmap group_kill;\n \n   /* True if there are any positions that are to be processed\n@@ -434,7 +434,7 @@ struct group_info\n   bool frame_related;\n \n   /* The offset_map is used to map the offsets from this base into\n-     postions in the global bitmaps.  It is only created after all of\n+     positions in the global bitmaps.  It is only created after all of\n      the all of stores have been scanned and we know which ones we\n      care about.  */\n   int *offset_map_n, *offset_map_p; \n@@ -1265,7 +1265,7 @@ record_store (rtx body, bb_info_t bb_info)\n       bool delete = true;\n \n       /* Skip the clobbers. We delete the active insn if this insn\n-\t shaddows the set.  To have been put on the active list, it\n+\t shadows the set.  To have been put on the active list, it\n \t has exactly on set. */\n       while (!s_info->is_set)\n \ts_info = s_info->next;\n@@ -2017,7 +2017,7 @@ dse_step1 (void)\n \n    Assign each byte position in the stores that we are going to\n    analyze globally to a position in the bitmaps.  Returns true if\n-   there are any bit postions assigned.\n+   there are any bit positions assigned.\n ----------------------------------------------------------------------------*/\n \n static void\n@@ -2837,7 +2837,7 @@ dse_step5_nospill (void)\n \t\t}\n \t    }\n \t  /* We do want to process the local info if the insn was\n-\t     deleted.  For insntance, if the insn did a wild read, we\n+\t     deleted.  For instance, if the insn did a wild read, we\n \t     no longer need to trash the info.  */\n \t  if (insn_info->insn \n \t      && INSN_P (insn_info->insn)"}, {"sha": "bc87f39aefb75cf8ad9b4abc9f4c2d347102c4f6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -2141,7 +2141,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n \t   i++, p = TREE_CHAIN (p))\n \t{\n \t  /* We cannot distinguish a varargs function from the case\n-\t     of excess parameters, still defering the inlining decision\n+\t     of excess parameters, still deferring the inlining decision\n \t     to the callee is possible.  */\n \t  if (!p)\n \t    break;"}, {"sha": "c1ce57ee2974cac85ec414c942b6166a14968738", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -667,7 +667,7 @@ add_to_dst_predicate_list (struct loop * loop, edge e,\n \n /* During if-conversion aux field from basic block structure is used to hold\n    predicate list. Clean each basic block's predicate list for the given LOOP.\n-   Also clean aux field of succesor edges, used to hold true and false\n+   Also clean aux field of successor edges, used to hold true and false\n    condition from conditional expression.  */\n \n static void"}, {"sha": "755fb1d31e8ee9b8c19df76ebed0dac5b988442d", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -1399,7 +1399,7 @@ simplify_binary_expression (tree rhs)\n     }\n   result = fold_binary (TREE_CODE (rhs), TREE_TYPE (rhs), op0, op1);\n \n-  /* Make sure result is not a complex expression consiting\n+  /* Make sure result is not a complex expression consisting\n      of operators of operators (IE (a + b) + (a + c))\n      Otherwise, we will end up with unbounded expressions if\n      fold does anything at all.  */"}, {"sha": "db16f2315d0c7544bf4b9ea73b66058845d564e3", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ed3da0066019f8902326857ca7b9cfb5dafab89/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=6ed3da0066019f8902326857ca7b9cfb5dafab89", "patch": "@@ -1006,7 +1006,7 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n \n       /* Otherwise pointers/references are equivalent if their pointed\n \t to types are effectively the same.  We can strip qualifiers\n-\t on pointed-to types for further comparsion, which is done in\n+\t on pointed-to types for further comparison, which is done in\n \t the callee.  */\n       return useless_type_conversion_p (TREE_TYPE (outer_type),\n \t\t\t\t        TREE_TYPE (inner_type));"}]}