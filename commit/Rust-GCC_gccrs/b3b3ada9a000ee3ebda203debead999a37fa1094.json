{"sha": "b3b3ada9a000ee3ebda203debead999a37fa1094", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNiM2FkYTlhMDAwZWUzZWJkYTIwM2RlYmVhZDk5OWEzN2ZhMTA5NA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-11-14T11:41:14Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-11-14T11:41:14Z"}, "message": "[Ada] Crash on ignored Ghost assignment\n\nThis patch modifies the way analysis determine whether an assignment is\nan ignored Ghost assignment. This is now achieved by preanalyzing a copy\nof the left hand side in order to account for potential code generated\nby the left hand side itself.\n\nNo small reproducer possible.\n\n2018-11-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* ghost.adb (Ghost_Entity): New routine.\n\t(Mark_And_Set_Ghost_Assignment): Reimplemented.\n\t* sem_ch5.adb (Analyze_Assignment): Assess whether the target of\n\tthe assignment is an ignored Ghost entity before analyzing the\n\tleft hand side.\n\t* sem_ch8.adb (Find_Direct_Name): Update the subprogram\n\tsignature. Do not generate markers and references when they are\n\tnot desired.\n\t(Nvis_Messages): Do not execute when errors are not desired.\n\t(Undefined): Do not emit errors when they are not desired.\n\t* sem_ch8.ads (Find_Direct_Name): Update the subprogram\n\tsignature and comment on usage.\n\t* sem_util.adb (Ultimate_Prefix): New routine.\n\t* sem_util.ads (Ultimate_Prefix): New routine.\n\nFrom-SVN: r266120", "tree": {"sha": "f665ea118030a350634cee2721e5f769b12e3a7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f665ea118030a350634cee2721e5f769b12e3a7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3b3ada9a000ee3ebda203debead999a37fa1094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b3ada9a000ee3ebda203debead999a37fa1094", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b3ada9a000ee3ebda203debead999a37fa1094", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b3ada9a000ee3ebda203debead999a37fa1094/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f0f5de19093d4550b48d3a26f1869e8def3f7e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f0f5de19093d4550b48d3a26f1869e8def3f7e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f0f5de19093d4550b48d3a26f1869e8def3f7e8"}], "stats": {"total": 354, "additions": 224, "deletions": 130}, "files": [{"sha": "3d4053286e6c25a42f4b48f7f36d30260dc99ab5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b3b3ada9a000ee3ebda203debead999a37fa1094", "patch": "@@ -1,3 +1,20 @@\n+2018-11-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* ghost.adb (Ghost_Entity): New routine.\n+\t(Mark_And_Set_Ghost_Assignment): Reimplemented.\n+\t* sem_ch5.adb (Analyze_Assignment): Assess whether the target of\n+\tthe assignment is an ignored Ghost entity before analyzing the\n+\tleft hand side.\n+\t* sem_ch8.adb (Find_Direct_Name): Update the subprogram\n+\tsignature. Do not generate markers and references when they are\n+\tnot desired.\n+\t(Nvis_Messages): Do not execute when errors are not desired.\n+\t(Undefined): Do not emit errors when they are not desired.\n+\t* sem_ch8.ads (Find_Direct_Name): Update the subprogram\n+\tsignature and comment on usage.\n+\t* sem_util.adb (Ultimate_Prefix): New routine.\n+\t* sem_util.ads (Ultimate_Prefix): New routine.\n+\n 2018-11-14  Justin Squirek  <squirek@adacore.com>\n \n \t* sem_ch7.adb (Uninstall_Declarations): Add conditional to avoid"}, {"sha": "7bcfbdeca883810bf76789e0ed9f05d38e420e01", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=b3b3ada9a000ee3ebda203debead999a37fa1094", "patch": "@@ -34,6 +34,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n+with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n@@ -64,9 +65,10 @@ package body Ghost is\n    -- Local subprograms --\n    -----------------------\n \n-   function Ghost_Entity (N : Node_Id) return Entity_Id;\n-   --  Find the entity of a reference to a Ghost entity. Return Empty if there\n-   --  is no such entity.\n+   function Ghost_Entity (Ref : Node_Id) return Entity_Id;\n+   pragma Inline (Ghost_Entity);\n+   --  Obtain the entity of a Ghost entity from reference Ref. Return Empty if\n+   --  no such entity exists.\n \n    procedure Install_Ghost_Mode (Mode : Ghost_Mode_Type);\n    pragma Inline (Install_Ghost_Mode);\n@@ -829,24 +831,18 @@ package body Ghost is\n    -- Ghost_Entity --\n    ------------------\n \n-   function Ghost_Entity (N : Node_Id) return Entity_Id is\n-      Ref : Node_Id;\n+   function Ghost_Entity (Ref : Node_Id) return Entity_Id is\n+      Obj_Ref : constant Node_Id := Ultimate_Prefix (Ref);\n \n    begin\n-      --  When the reference denotes a subcomponent, recover the related\n+      --  When the reference denotes a subcomponent, recover the related whole\n       --  object (SPARK RM 6.9(1)).\n \n-      Ref := N;\n-      while Nkind_In (Ref, N_Explicit_Dereference,\n-                           N_Indexed_Component,\n-                           N_Selected_Component,\n-                           N_Slice)\n-      loop\n-         Ref := Prefix (Ref);\n-      end loop;\n+      if Is_Entity_Name (Obj_Ref) then\n+         return Entity (Obj_Ref);\n+\n+      --  Otherwise the reference cannot possibly denote a Ghost entity\n \n-      if Is_Entity_Name (Ref) then\n-         return Entity (Ref);\n       else\n          return Empty;\n       end if;\n@@ -1181,13 +1177,50 @@ package body Ghost is\n    -----------------------------------\n \n    procedure Mark_And_Set_Ghost_Assignment (N : Node_Id) is\n-      Id : Entity_Id;\n+      Orig_Lhs : constant Node_Id := Name (N);\n+      Orig_Ref : constant Node_Id := Ultimate_Prefix (Orig_Lhs);\n+\n+      Id  : Entity_Id;\n+      Ref : Node_Id;\n \n    begin\n+      --  A reference to a whole Ghost object (SPARK RM 6.9(1)) appears as an\n+      --  identifier. If the reference has not been analyzed yet, preanalyze a\n+      --  copy of the reference to discover the nature of its entity.\n+\n+      if Nkind (Orig_Ref) = N_Identifier and then not Analyzed (Orig_Ref) then\n+         Ref := New_Copy_Tree (Orig_Ref);\n+\n+         --  Alter the assignment statement by setting its left-hand side to\n+         --  the copy.\n+\n+         Set_Name   (N, Ref);\n+         Set_Parent (Ref, N);\n+\n+         --  Preanalysis is carried out by looking for a Ghost entity while\n+         --  suppressing all possible side effects.\n+\n+         Find_Direct_Name\n+           (N            => Ref,\n+            Errors_OK    => False,\n+            Marker_OK    => False,\n+            Reference_OK => False);\n+\n+         --  Restore the original state of the assignment statement\n+\n+         Set_Name (N, Orig_Lhs);\n+\n+      --  A potential reference to a Ghost entity is already properly resolved\n+      --  when the left-hand side is analyzed.\n+\n+      else\n+         Ref := Orig_Ref;\n+      end if;\n+\n       --  An assignment statement becomes Ghost when its target denotes a Ghost\n       --  object. Install the Ghost mode of the target.\n \n-      Id := Ghost_Entity (Name (N));\n+      Id := Ghost_Entity (Ref);\n \n       if Present (Id) then\n          if Is_Checked_Ghost_Entity (Id) then"}, {"sha": "d9c0644009e508845bf7f706e844722df4e555a9", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=b3b3ada9a000ee3ebda203debead999a37fa1094", "patch": "@@ -452,16 +452,16 @@ package body Sem_Ch5 is\n \n       --  Local variables\n \n+      Saved_GM  : constant Ghost_Mode_Type := Ghost_Mode;\n+      Saved_IGR : constant Node_Id         := Ignored_Ghost_Region;\n+      --  Save the Ghost-related attributes to restore on exit\n+\n       T1 : Entity_Id;\n       T2 : Entity_Id;\n \n       Save_Full_Analysis : Boolean := False;\n       --  Force initialization to facilitate static analysis\n \n-      Saved_GM  : constant Ghost_Mode_Type := Ghost_Mode;\n-      Saved_IGR : constant Node_Id         := Ignored_Ghost_Region;\n-      --  Save the Ghost-related attributes to restore on exit\n-\n    --  Start of processing for Analyze_Assignment\n \n    begin\n@@ -476,16 +476,12 @@ package body Sem_Ch5 is\n          Checks => True,\n          Modes  => True);\n \n-      --  Analyze the target of the assignment first in case the expression\n-      --  contains references to Ghost entities. The checks that verify the\n-      --  proper use of a Ghost entity need to know the enclosing context.\n-\n-      Analyze (Lhs);\n-\n       --  An assignment statement is Ghost when the left hand side denotes a\n       --  Ghost entity. Set the mode now to ensure that any nodes generated\n       --  during analysis and expansion are properly marked as Ghost.\n \n+      Mark_And_Set_Ghost_Assignment (N);\n+\n       if Has_Target_Names (N) then\n          Current_Assignment := N;\n          Expander_Mode_Save_And_Set (False);\n@@ -495,7 +491,7 @@ package body Sem_Ch5 is\n          Current_Assignment := Empty;\n       end if;\n \n-      Mark_And_Set_Ghost_Assignment (N);\n+      Analyze (Lhs);\n       Analyze (Rhs);\n \n       --  Ensure that we never do an assignment on a variable marked as"}, {"sha": "fd0e444657fd70ce783423c0902bc1c00c550562", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 115, "deletions": 100, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=b3b3ada9a000ee3ebda203debead999a37fa1094", "patch": "@@ -4843,7 +4843,12 @@ package body Sem_Ch8 is\n    -- Find_Direct_Name --\n    ----------------------\n \n-   procedure Find_Direct_Name (N : Node_Id) is\n+   procedure Find_Direct_Name\n+     (N            : Node_Id;\n+      Errors_OK    : Boolean := True;\n+      Marker_OK    : Boolean := True;\n+      Reference_OK : Boolean := True)\n+   is\n       E   : Entity_Id;\n       E2  : Entity_Id;\n       Msg : Boolean;\n@@ -5096,6 +5101,10 @@ package body Sem_Ch8 is\n          Item      : Node_Id;\n \n       begin\n+         if not Errors_OK then\n+            return;\n+         end if;\n+\n          --  Ada 2005 (AI-262): Generate a precise error concerning the\n          --  Beaujolais effect that was previously detected\n \n@@ -5263,7 +5272,8 @@ package body Sem_Ch8 is\n \n          --  Named aggregate should also be handled similarly ???\n \n-         if Nkind (N) = N_Identifier\n+         if Errors_OK\n+           and then Nkind (N) = N_Identifier\n            and then Nkind (Parent (N)) = N_Case_Statement_Alternative\n          then\n             declare\n@@ -5299,119 +5309,122 @@ package body Sem_Ch8 is\n          Set_Entity (N, Any_Id);\n          Set_Etype  (N, Any_Type);\n \n-         --  We use the table Urefs to keep track of entities for which we\n-         --  have issued errors for undefined references. Multiple errors\n-         --  for a single name are normally suppressed, however we modify\n-         --  the error message to alert the programmer to this effect.\n+         if Errors_OK then\n \n-         for J in Urefs.First .. Urefs.Last loop\n-            if Chars (N) = Chars (Urefs.Table (J).Node) then\n-               if Urefs.Table (J).Err /= No_Error_Msg\n-                 and then Sloc (N) /= Urefs.Table (J).Loc\n-               then\n-                  Error_Msg_Node_1 := Urefs.Table (J).Node;\n+            --  We use the table Urefs to keep track of entities for which we\n+            --  have issued errors for undefined references. Multiple errors\n+            --  for a single name are normally suppressed, however we modify\n+            --  the error message to alert the programmer to this effect.\n \n-                  if Urefs.Table (J).Nvis then\n-                     Change_Error_Text (Urefs.Table (J).Err,\n-                       \"& is not visible (more references follow)\");\n-                  else\n-                     Change_Error_Text (Urefs.Table (J).Err,\n-                       \"& is undefined (more references follow)\");\n-                  end if;\n+            for J in Urefs.First .. Urefs.Last loop\n+               if Chars (N) = Chars (Urefs.Table (J).Node) then\n+                  if Urefs.Table (J).Err /= No_Error_Msg\n+                    and then Sloc (N) /= Urefs.Table (J).Loc\n+                  then\n+                     Error_Msg_Node_1 := Urefs.Table (J).Node;\n \n-                  Urefs.Table (J).Err := No_Error_Msg;\n-               end if;\n+                     if Urefs.Table (J).Nvis then\n+                        Change_Error_Text (Urefs.Table (J).Err,\n+                          \"& is not visible (more references follow)\");\n+                     else\n+                        Change_Error_Text (Urefs.Table (J).Err,\n+                          \"& is undefined (more references follow)\");\n+                     end if;\n \n-               --  Although we will set Msg False, and thus suppress the\n-               --  message, we also set Error_Posted True, to avoid any\n-               --  cascaded messages resulting from the undefined reference.\n+                     Urefs.Table (J).Err := No_Error_Msg;\n+                  end if;\n \n-               Msg := False;\n-               Set_Error_Posted (N, True);\n-               return;\n-            end if;\n-         end loop;\n+                  --  Although we will set Msg False, and thus suppress the\n+                  --  message, we also set Error_Posted True, to avoid any\n+                  --  cascaded messages resulting from the undefined reference.\n \n-         --  If entry not found, this is first undefined occurrence\n+                  Msg := False;\n+                  Set_Error_Posted (N);\n+                  return;\n+               end if;\n+            end loop;\n \n-         if Nvis then\n-            Error_Msg_N (\"& is not visible!\", N);\n-            Emsg := Get_Msg_Id;\n+            --  If entry not found, this is first undefined occurrence\n \n-         else\n-            Error_Msg_N (\"& is undefined!\", N);\n-            Emsg := Get_Msg_Id;\n+            if Nvis then\n+               Error_Msg_N (\"& is not visible!\", N);\n+               Emsg := Get_Msg_Id;\n \n-            --  A very bizarre special check, if the undefined identifier\n-            --  is put or put_line, then add a special error message (since\n-            --  this is a very common error for beginners to make).\n+            else\n+               Error_Msg_N (\"& is undefined!\", N);\n+               Emsg := Get_Msg_Id;\n \n-            if Nam_In (Chars (N), Name_Put, Name_Put_Line) then\n-               Error_Msg_N -- CODEFIX\n-                 (\"\\\\possible missing `WITH Ada.Text_'I'O; \" &\n-                  \"USE Ada.Text_'I'O`!\", N);\n+               --  A very bizarre special check, if the undefined identifier\n+               --  is Put or Put_Line, then add a special error message (since\n+               --  this is a very common error for beginners to make).\n \n-            --  Another special check if N is the prefix of a selected\n-            --  component which is a known unit, add message complaining\n-            --  about missing with for this unit.\n+               if Nam_In (Chars (N), Name_Put, Name_Put_Line) then\n+                  Error_Msg_N -- CODEFIX\n+                    (\"\\\\possible missing `WITH Ada.Text_'I'O; \" &\n+                     \"USE Ada.Text_'I'O`!\", N);\n \n-            elsif Nkind (Parent (N)) = N_Selected_Component\n-              and then N = Prefix (Parent (N))\n-              and then Is_Known_Unit (Parent (N))\n-            then\n-               Error_Msg_Node_2 := Selector_Name (Parent (N));\n-               Error_Msg_N -- CODEFIX\n-                 (\"\\\\missing `WITH &.&;`\", Prefix (Parent (N)));\n-            end if;\n+               --  Another special check if N is the prefix of a selected\n+               --  component which is a known unit: add message complaining\n+               --  about missing with for this unit.\n+\n+               elsif Nkind (Parent (N)) = N_Selected_Component\n+                 and then N = Prefix (Parent (N))\n+                 and then Is_Known_Unit (Parent (N))\n+               then\n+                  Error_Msg_Node_2 := Selector_Name (Parent (N));\n+                  Error_Msg_N -- CODEFIX\n+                    (\"\\\\missing `WITH &.&;`\", Prefix (Parent (N)));\n+               end if;\n \n-            --  Now check for possible misspellings\n+               --  Now check for possible misspellings\n \n-            declare\n-               E      : Entity_Id;\n-               Ematch : Entity_Id := Empty;\n+               declare\n+                  E      : Entity_Id;\n+                  Ematch : Entity_Id := Empty;\n \n-               Last_Name_Id : constant Name_Id :=\n-                                Name_Id (Nat (First_Name_Id) +\n-                                           Name_Entries_Count - 1);\n+                  Last_Name_Id : constant Name_Id :=\n+                                   Name_Id (Nat (First_Name_Id) +\n+                                              Name_Entries_Count - 1);\n \n-            begin\n-               for Nam in First_Name_Id .. Last_Name_Id loop\n-                  E := Get_Name_Entity_Id (Nam);\n+               begin\n+                  for Nam in First_Name_Id .. Last_Name_Id loop\n+                     E := Get_Name_Entity_Id (Nam);\n \n-                  if Present (E)\n-                     and then (Is_Immediately_Visible (E)\n-                                 or else\n-                               Is_Potentially_Use_Visible (E))\n-                  then\n-                     if Is_Bad_Spelling_Of (Chars (N), Nam) then\n-                        Ematch := E;\n-                        exit;\n+                     if Present (E)\n+                        and then (Is_Immediately_Visible (E)\n+                                    or else\n+                                  Is_Potentially_Use_Visible (E))\n+                     then\n+                        if Is_Bad_Spelling_Of (Chars (N), Nam) then\n+                           Ematch := E;\n+                           exit;\n+                        end if;\n                      end if;\n-                  end if;\n-               end loop;\n+                  end loop;\n \n-               if Present (Ematch) then\n-                  Error_Msg_NE -- CODEFIX\n-                    (\"\\possible misspelling of&\", N, Ematch);\n-               end if;\n-            end;\n-         end if;\n+                  if Present (Ematch) then\n+                     Error_Msg_NE -- CODEFIX\n+                       (\"\\possible misspelling of&\", N, Ematch);\n+                  end if;\n+               end;\n+            end if;\n \n-         --  Make entry in undefined references table unless the full errors\n-         --  switch is set, in which case by refraining from generating the\n-         --  table entry, we guarantee that we get an error message for every\n-         --  undefined reference. The entry is not added if we are ignoring\n-         --  errors.\n+            --  Make entry in undefined references table unless the full errors\n+            --  switch is set, in which case by refraining from generating the\n+            --  table entry we guarantee that we get an error message for every\n+            --  undefined reference. The entry is not added if we are ignoring\n+            --  errors.\n+\n+            if not All_Errors_Mode and then Ignore_Errors_Enable = 0 then\n+               Urefs.Append (\n+                 (Node => N,\n+                  Err  => Emsg,\n+                  Nvis => Nvis,\n+                  Loc  => Sloc (N)));\n+            end if;\n \n-         if not All_Errors_Mode and then Ignore_Errors_Enable = 0 then\n-            Urefs.Append (\n-              (Node => N,\n-               Err  => Emsg,\n-               Nvis => Nvis,\n-               Loc  => Sloc (N)));\n+            Msg := True;\n          end if;\n-\n-         Msg := True;\n       end Undefined;\n \n       --  Local variables\n@@ -5834,7 +5847,7 @@ package body Sem_Ch8 is\n             --  If no homonyms were visible, the entity is unambiguous\n \n             if not Is_Overloaded (N) then\n-               if not Is_Actual_Parameter then\n+               if Reference_OK and then not Is_Actual_Parameter then\n                   Generate_Reference (E, N);\n                end if;\n             end if;\n@@ -5853,7 +5866,8 @@ package body Sem_Ch8 is\n             --  in SPARK mode where renamings are traversed for generating\n             --  local effects of subprograms.\n \n-            if Is_Object (E)\n+            if Reference_OK\n+              and then Is_Object (E)\n               and then Present (Renamed_Object (E))\n               and then not GNATprove_Mode\n             then\n@@ -5883,7 +5897,7 @@ package body Sem_Ch8 is\n                   --  Generate reference unless this is an actual parameter\n                   --  (see comment below)\n \n-                  if Is_Actual_Parameter then\n+                  if Reference_OK and then Is_Actual_Parameter then\n                      Generate_Reference (E, N);\n                      Set_Referenced (E, R);\n                   end if;\n@@ -5892,7 +5906,7 @@ package body Sem_Ch8 is\n             --  Normal case, not a label: generate reference\n \n             else\n-               if not Is_Actual_Parameter then\n+               if Reference_OK and then not Is_Actual_Parameter then\n \n                   --  Package or generic package is always a simple reference\n \n@@ -5961,9 +5975,10 @@ package body Sem_Ch8 is\n       --  reference is a write when it appears on the left hand side of an\n       --  assignment.\n \n-      if Needs_Variable_Reference_Marker\n-           (N        => N,\n-            Calls_OK => False)\n+      if Marker_OK\n+        and then Needs_Variable_Reference_Marker\n+                   (N        => N,\n+                    Calls_OK => False)\n       then\n          declare\n             Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;"}, {"sha": "b6024d7870e34b44c8848cb612c195839d373b6e", "filename": "gcc/ada/sem_ch8.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.ads?ref=b3b3ada9a000ee3ebda203debead999a37fa1094", "patch": "@@ -82,7 +82,11 @@ package Sem_Ch8 is\n    --  Subsidiaries of End_Use_Clauses. Also called directly for use clauses\n    --  appearing in context clauses.\n \n-   procedure Find_Direct_Name (N : Node_Id);\n+   procedure Find_Direct_Name\n+     (N            : Node_Id;\n+      Errors_OK    : Boolean := True;\n+      Marker_OK    : Boolean := True;\n+      Reference_OK : Boolean := True);\n    --  Given a direct name (Identifier or Operator_Symbol), this routine scans\n    --  the homonym chain for the name, searching for corresponding visible\n    --  entities to find the referenced entity (or in the case of overloading,\n@@ -99,6 +103,11 @@ package Sem_Ch8 is\n    --  entries in the current scope, and that will give all homonyms that are\n    --  declared before the point of call in the current scope. This is useful\n    --  for example in the processing for pragma Inline.\n+   --\n+   --  Flag Errors_OK should be set when error diagnostics are desired. Flag\n+   --  Marker_OK should be set when a N_Variable_Reference_Marker needs to be\n+   --  generated for a SPARK object in order to detect elaboration issues. Flag\n+   --  Reference_OK should be set when N must generate a cross reference.\n \n    procedure Find_Selected_Component (N : Node_Id);\n    --  Resolve various cases of selected components, recognize expanded names"}, {"sha": "58669dd39377dfa756143296a71b3d24ca966eff", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b3b3ada9a000ee3ebda203debead999a37fa1094", "patch": "@@ -25269,6 +25269,26 @@ package body Sem_Util is\n       end if;\n    end Type_Without_Stream_Operation;\n \n+   ---------------------\n+   -- Ultimate_Prefix --\n+   ---------------------\n+\n+   function Ultimate_Prefix (N : Node_Id) return Node_Id is\n+      Pref : Node_Id;\n+\n+   begin\n+      Pref := N;\n+      while Nkind_In (Pref, N_Explicit_Dereference,\n+                            N_Indexed_Component,\n+                            N_Selected_Component,\n+                            N_Slice)\n+      loop\n+         Pref := Prefix (Pref);\n+      end loop;\n+\n+      return Pref;\n+   end Ultimate_Prefix;\n+\n    ----------------------------\n    -- Unique_Defining_Entity --\n    ----------------------------"}, {"sha": "b287946e43ea75c1b564495c996963482a548b00", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b3ada9a000ee3ebda203debead999a37fa1094/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b3b3ada9a000ee3ebda203debead999a37fa1094", "patch": "@@ -2810,6 +2810,10 @@ package Sem_Util is\n    --  prevents the construction of a composite stream operation. If Op is\n    --  specified we check only for the given stream operation.\n \n+   function Ultimate_Prefix (N : Node_Id) return Node_Id;\n+   --  Obtain the \"outermost\" prefix of arbitrary node N. Return N if no such\n+   --  prefix exists.\n+\n    function Unique_Defining_Entity (N : Node_Id) return Entity_Id;\n    --  Return the entity that represents declaration N, so that different\n    --  views of the same entity have the same unique defining entity:"}]}