{"sha": "af96500eea72c674a5686b35c66202ef2bd9688f", "node_id": "C_kwDOANBUbNoAKGFmOTY1MDBlZWE3MmM2NzRhNTY4NmIzNWM2NjIwMmVmMmJkOTY4OGY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-11-11T09:12:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-11-11T13:31:51Z"}, "message": "tree-optimization/107618 - enhance copy propagation of constants\n\nThe following enhances copy propagation of constants to also see\nthrough simple operations like conversions but also operations with\notherwise constant operands.  That's required to fulfill the promise\n\n      /* Copy propagation also copy-propagates constants, this is necessary\n         to forward object-size and builtin folding results properly.  */\n      NEXT_PASS (pass_copy_prop);\n\nand avoid false diagnostics as shown in the testcase.  We're\nusing gimple_fold_stmt_to_constant_1 with not following SSA edges\nand accordingly adjust what stmts we simulate during SSA propagation.\n\n\tPR tree-optimization/107618\n\t* tree-ssa-copy.cc (stmt_may_generate_copy): Simulate all\n\tassignments with a single SSA use.\n\t(copy_prop_visit_assignment): Use gimple_fold_stmt_to_constant_1\n\tto perform simple constant folding.\n\t(copy_prop::visit_stmt): Visit all assignments.\n\n\t* gcc.dg/pr107618.c: New testcase.", "tree": {"sha": "ea5adc4eefb3f6fa63ae089208ed270781266bc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea5adc4eefb3f6fa63ae089208ed270781266bc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af96500eea72c674a5686b35c66202ef2bd9688f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af96500eea72c674a5686b35c66202ef2bd9688f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af96500eea72c674a5686b35c66202ef2bd9688f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af96500eea72c674a5686b35c66202ef2bd9688f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be2c74fdcd0e8d66c3667008ba2561ab5dcc379b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be2c74fdcd0e8d66c3667008ba2561ab5dcc379b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be2c74fdcd0e8d66c3667008ba2561ab5dcc379b"}], "stats": {"total": 59, "additions": 35, "deletions": 24}, "files": [{"sha": "9e73cc1f1a17ec3b36e991f63603e338e3ae58cd", "filename": "gcc/testsuite/gcc.dg/pr107618.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af96500eea72c674a5686b35c66202ef2bd9688f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr107618.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af96500eea72c674a5686b35c66202ef2bd9688f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr107618.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr107618.c?ref=af96500eea72c674a5686b35c66202ef2bd9688f", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Og\" } */\n+\n+void a(void) __attribute__((__warning__(\"\")));\n+int main(void)\n+{\n+  unsigned long b = __builtin_object_size(0, 0);\n+  if (__builtin_expect(b < 1, 0))\n+    a(); /* { dg-bogus \"warning\" } */\n+}"}, {"sha": "811161c223e4886a5379dcbfc67b437e198f17cb", "filename": "gcc/tree-ssa-copy.cc", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af96500eea72c674a5686b35c66202ef2bd9688f/gcc%2Ftree-ssa-copy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af96500eea72c674a5686b35c66202ef2bd9688f/gcc%2Ftree-ssa-copy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.cc?ref=af96500eea72c674a5686b35c66202ef2bd9688f", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-loop-niter.h\"\n+#include \"gimple-fold.h\"\n \n \n /* This file implements the copy propagation pass and provides a\n@@ -99,12 +100,16 @@ stmt_may_generate_copy (gimple *stmt)\n   if (gimple_vuse (stmt))\n     return false;\n \n+  /* If the assignment is from a constant it generates a useful copy.  */\n+  if (gimple_assign_single_p (stmt)\n+      && is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n+    return true;\n+\n   /* Otherwise, the only statements that generate useful copies are\n-     assignments whose RHS is just an SSA name that doesn't flow\n-     through abnormal edges.  */\n-  return ((gimple_assign_rhs_code (stmt) == SSA_NAME\n-\t   && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (stmt)))\n-\t  || is_gimple_min_invariant (gimple_assign_rhs1 (stmt)));\n+     assignments whose single SSA use doesn't flow through abnormal\n+     edges.  */\n+  tree rhs = single_ssa_tree_operand (stmt, SSA_OP_USE);\n+  return (rhs && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs));\n }\n \n \n@@ -197,26 +202,24 @@ dump_copy_of (FILE *file, tree var)\n static enum ssa_prop_result\n copy_prop_visit_assignment (gimple *stmt, tree *result_p)\n {\n-  tree lhs, rhs;\n-\n-  lhs = gimple_assign_lhs (stmt);\n-  rhs = valueize_val (gimple_assign_rhs1 (stmt));\n-\n-  if (TREE_CODE (lhs) == SSA_NAME)\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree rhs = gimple_fold_stmt_to_constant_1 (stmt, valueize_val);\n+  if (rhs\n+      && (TREE_CODE (rhs) == SSA_NAME\n+\t  || is_gimple_min_invariant (rhs)))\n     {\n-      /* Straight copy between two SSA names.  First, make sure that\n+      /* Straight copy between two SSA names or a constant.  Make sure that\n \t we can propagate the RHS into uses of LHS.  */\n       if (!may_propagate_copy (lhs, rhs))\n-\treturn SSA_PROP_VARYING;\n-\n-      *result_p = lhs;\n-      if (set_copy_of_val (*result_p, rhs))\n-\treturn SSA_PROP_INTERESTING;\n-      else\n-\treturn SSA_PROP_NOT_INTERESTING;\n+\trhs = lhs;\n     }\n+  else\n+    rhs = lhs;\n \n-  return SSA_PROP_VARYING;\n+  *result_p = lhs;\n+  if (set_copy_of_val (*result_p, rhs))\n+    return SSA_PROP_INTERESTING;\n+  return rhs != lhs ? SSA_PROP_NOT_INTERESTING : SSA_PROP_VARYING;\n }\n \n \n@@ -282,10 +285,8 @@ copy_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *result_p)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (gimple_assign_single_p (stmt)\n-      && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n-      && (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n-\t  || is_gimple_min_invariant (gimple_assign_rhs1 (stmt))))\n+  if (is_gimple_assign (stmt)\n+      && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n     {\n       /* If the statement is a copy assignment, evaluate its RHS to\n \t see if the lattice value of its output has changed.  */"}]}