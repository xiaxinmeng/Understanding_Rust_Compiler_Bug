{"sha": "5834bdc3d483d566dcfa41fae7923f9d587f0193", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgzNGJkYzNkNDgzZDU2NmRjZmE0MWZhZTc5MjNmOWQ1ODdmMDE5Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-06-09T09:43:37Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-06-09T09:43:37Z"}, "message": "re PR fortran/89365 (Inquiry functions for assumed rank objects fail)\n\n2019-06-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89365\n\t* gfortran.dg/assumed_rank_bounds_3.f90 : New test.\n\nFrom-SVN: r272090", "tree": {"sha": "2650376a134d3642e934dc101f91f5149a45b295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2650376a134d3642e934dc101f91f5149a45b295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5834bdc3d483d566dcfa41fae7923f9d587f0193", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5834bdc3d483d566dcfa41fae7923f9d587f0193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5834bdc3d483d566dcfa41fae7923f9d587f0193", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5834bdc3d483d566dcfa41fae7923f9d587f0193/comments", "author": null, "committer": null, "parents": [{"sha": "0002187783488808eb8658ee1b9e9c2111144f6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0002187783488808eb8658ee1b9e9c2111144f6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0002187783488808eb8658ee1b9e9c2111144f6f"}], "stats": {"total": 224, "additions": 224, "deletions": 0}, "files": [{"sha": "a1b884164de936a22c2d95d9836559bb8749cc1b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5834bdc3d483d566dcfa41fae7923f9d587f0193/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5834bdc3d483d566dcfa41fae7923f9d587f0193/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5834bdc3d483d566dcfa41fae7923f9d587f0193", "patch": "@@ -1,3 +1,8 @@\n+019-06-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89365\n+\t* gfortran.dg/assumed_rank_bounds_3.f90 : New test.\n+\n 2019-06-08  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/90786"}, {"sha": "0a428f2ed6f8ab86cc234cafd10897c897af7881", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_bounds_3.f90", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5834bdc3d483d566dcfa41fae7923f9d587f0193/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5834bdc3d483d566dcfa41fae7923f9d587f0193/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_bounds_3.f90?ref=5834bdc3d483d566dcfa41fae7923f9d587f0193", "patch": "@@ -0,0 +1,219 @@\n+! { dg-do run }\n+!\n+! This test case is inserted as a check. PR89365 inially asserted that\n+! gfortran was getting the bounds wrong for allocatable and pointer\n+! actual arguments. However, the reporter accepted that it is OK and\n+! this is the corrected version of his testcase, which fills a gap in\n+! the testsuite.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+module mod_ass_rank_inquiry\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  logical, parameter :: debug = .true.\n+  integer :: error_count = 0\n+!\n+! using inquiry functions for assumed rank objects\n+!\n+  contains\n+    subroutine foo_1(this)\n+      real(c_float) :: this(..)\n+      select case(rank(this))\n+      case(0)\n+         if (size(shape(this)) > 0 .or. size(lbound(this)) > 0 .or. &\n+              size(ubound(this)) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape / lbound  / ubound'\n+         end if\n+         if (size(this) /= 1) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size'\n+         end if\n+      case(1)\n+         if (sum(abs(shape(this) -  [4])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape'\n+         end if\n+         if (size(this) /= 4) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size', size(this)\n+         end if\n+         if (lbound(this,1) /= 1) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL lbound',lbound(this,1)\n+         end if\n+         if (ubound(this,1) /= 4) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL ubound',ubound(this,1)\n+         end if\n+      case(3)\n+         if (sum(abs(shape(this) - [ 2, 3, 4 ])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape'\n+         end if\n+         if (size(this) /= 2*3*4) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size'\n+         end if\n+         if (sum(abs(lbound(this) - [ 1, 1, 1 ])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL lbound'\n+         end if\n+         if (sum(abs(ubound(this)) - [ 2, 3, 4]) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL ubound'\n+         end if\n+      case default\n+         error_count = error_count + 1\n+      end select\n+    end subroutine foo_1\n+    subroutine foo_2(this)\n+      real(c_float), allocatable :: this(..)\n+      if (.not. allocated(this)) then\n+         error_count = error_count + 1\n+         if (debug) write(*,*) 'FAIL allocated'\n+      end if\n+      select case(rank(this))\n+      case(0)\n+         if (size(shape(this)) > 0 .or. size(lbound(this)) > 0 .or. &\n+              size(ubound(this)) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape / lbound  / ubound'\n+         end if\n+         if (size(this) /= 1) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size'\n+         end if\n+      case(1)\n+         if (sum(abs(shape(this) -  [4])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape'\n+         end if\n+         if (size(this) /= 4) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size', size(this)\n+         end if\n+         if (lbound(this,1) /= 2) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL lbound',lbound(this,1)\n+         end if\n+         if (ubound(this,1) /= 5) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL ubound',ubound(this,1)\n+         end if\n+      case(3)\n+         if (sum(abs(shape(this) - [ 2, 3, 4 ])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape'\n+         end if\n+         if (size(this) /= 2*3*4) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size'\n+         end if\n+         if (sum(abs(lbound(this) - [ 0, -1, 1 ])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL lbound', lbound(this)\n+         end if\n+         if (sum(abs(ubound(this)) - [ 2, 3, 4]) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL ubound', ubound(this)\n+         end if\n+      case default\n+         error_count = error_count + 1\n+      end select\n+    end subroutine foo_2\n+    subroutine foo_3(this)\n+      real(c_float), pointer :: this(..)\n+      if (.not. associated(this)) then\n+         error_count = error_count + 1\n+         if (debug) write(*,*) 'FAIL associated'\n+      end if\n+      select case(rank(this))\n+      case(0)\n+         if (size(shape(this)) > 0 .or. size(lbound(this)) > 0 .or. &\n+              size(ubound(this)) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape / lbound  / ubound'\n+         end if\n+         if (size(this) /= 1) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size'\n+         end if\n+      case(1)\n+         if (sum(abs(shape(this) -  [4])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape'\n+         end if\n+         if (size(this) /= 4) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size', size(this)\n+         end if\n+         if (lbound(this,1) /= 2) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL lbound',lbound(this,1)\n+         end if\n+         if (ubound(this,1) /= 5) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL ubound',ubound(this,1)\n+         end if\n+      case(3)\n+         if (sum(abs(shape(this) - [ 2, 3, 4 ])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL shape'\n+         end if\n+         if (size(this) /= 2*3*4) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL size'\n+         end if\n+         if (sum(abs(lbound(this) - [ 0, -1, 1 ])) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL lbound', lbound(this)\n+         end if\n+         if (sum(abs(ubound(this)) - [ 2, 3, 4]) > 0) then\n+            error_count = error_count + 1\n+            if (debug) write(*,*) 'FAIL ubound', ubound(this)\n+         end if\n+      case default\n+         error_count = error_count + 1\n+      end select\n+    end subroutine foo_3\n+end module mod_ass_rank_inquiry\n+program ass_rank_inquiry\n+  use mod_ass_rank_inquiry\n+  implicit none\n+  real, allocatable :: x, y(:), z(:,:,:)\n+  real, pointer :: xp, yp(:), zp(:,:,:)\n+\n+  allocate(x, y(2:5), z(0:1,-1:1,1:4))\n+  allocate(xp, yp(2:5), zp(0:1,-1:1,1:4))\n+\n+\n+  call foo_1(x)\n+  if (error_count > 0) write(*,*) 'FAIL: after scalar ',error_count\n+  call foo_1(y)\n+  if (error_count > 0) write(*,*) 'FAIL: after rank-1 ',error_count\n+  call foo_1(z)\n+  if (error_count > 0) write(*,*) 'FAIL: after rank-3 ',error_count\n+  call foo_2(x)\n+  if (error_count > 0) write(*,*) 'FAIL: after allocscalar ',error_count\n+  call foo_2(y)\n+  if (error_count > 0) write(*,*) 'FAIL: after allocrank-1 ',error_count\n+  call foo_2(z)\n+  if (error_count > 0) write(*,*) 'FAIL: after allocrank-3 ',error_count\n+  call foo_3(xp)\n+  if (error_count > 0) write(*,*) 'FAIL: after ptrscalar ',error_count\n+  call foo_3(yp)\n+  if (error_count > 0) write(*,*) 'FAIL: after ptrrank-1 ',error_count\n+  call foo_3(zp)\n+  if (error_count > 0) write(*,*) 'FAIL: after ptrrank-3 ',error_count\n+\n+  if (error_count == 0) then\n+    write(*,*) 'OK'\n+  else\n+    stop 1\n+  end if\n+\n+  deallocate(x, y, z)\n+  deallocate(xp, yp, zp)\n+end program ass_rank_inquiry"}]}