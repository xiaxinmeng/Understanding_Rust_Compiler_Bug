{"sha": "fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMyYzMyZTJhMWRlOTMzMmNmN2RiZTkwZjdiZDc2MDA5NDU5OTljMw==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-07-13T09:04:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-13T09:04:17Z"}, "message": "gnatcmd.adb, [...] (Immediate_Directory_Of): Removed.\n\n2009-07-13  Emmanuel Briot  <briot@adacore.com>\n\n\t* gnatcmd.adb, make.adb, mlib-prj.adb, prj-part.adb, mlib.adb,\n\tprj.adb, prj.ads, clean.adb, prj-nmsc.adb, prj-nmsc.ads, prj-pars.adb,\n\tprj-pars.ads, prj-conf.adb, prj-conf.ads, prj-tree.adb,\n\tprj-tree.ads (Immediate_Directory_Of): Removed.\n\t(Prj.Pars): Now parse the project simulating a default config file.\n\t(Add_Default_GNAT_Naming_Scheme): New subprogram\n\t(Check_Naming_Multi_Lang): Fix default value for Dot_Replacement.\n\tRemove gnatmake-specific parsing of source files.\n\t(Check_Illegal_Suffix): Renames Is_Illegal_Suffix, since it now raises\n\tthe error itself to provide more precise diagnostics.\n\t(Process_Exceptions_Unit_Based): Avoid duplicate error message when\n\ta unit belongs to several projects.\n\t(Copy_Interface_Sources): Search the full path of files to copy in the\n\tlist of sources of the application rather than in the list of units.\n\t(Parse_Project_And_Apply_Config): Do not reset the name of the main\n \tproject file.\n\t(Check_File): Use htables to find out whether a source is duplicated.\n\t(Add_Source): check whether the source or unit were already seen earlier\n\n\t* gcc-interface/Makefile.in: Update gnatmake dependencies.\n\nFrom-SVN: r149557", "tree": {"sha": "0248d58807123b435413867f377c3448a7f12aef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0248d58807123b435413867f377c3448a7f12aef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1629f7005208e42cede66374861c211c5a6d85e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1629f7005208e42cede66374861c211c5a6d85e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1629f7005208e42cede66374861c211c5a6d85e8"}], "stats": {"total": 1913, "additions": 695, "deletions": 1218}, "files": [{"sha": "51dddf508a43bc2a37f046f0d1ec8d866a0e7096", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -1,3 +1,26 @@\n+2009-07-13  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* gnatcmd.adb, make.adb, mlib-prj.adb, prj-part.adb, mlib.adb,\n+\tprj.adb, prj.ads, clean.adb, prj-nmsc.adb, prj-nmsc.ads, prj-pars.adb,\n+\tprj-pars.ads, prj-conf.adb, prj-conf.ads, prj-tree.adb,\n+\tprj-tree.ads (Immediate_Directory_Of): Removed.\n+\t(Prj.Pars): Now parse the project simulating a default config file.\n+\t(Add_Default_GNAT_Naming_Scheme): New subprogram\n+\t(Check_Naming_Multi_Lang): Fix default value for Dot_Replacement.\n+\tRemove gnatmake-specific parsing of source files.\n+\t(Check_Illegal_Suffix): Renames Is_Illegal_Suffix, since it now raises\n+\tthe error itself to provide more precise diagnostics.\n+\t(Process_Exceptions_Unit_Based): Avoid duplicate error message when\n+\ta unit belongs to several projects.\n+\t(Copy_Interface_Sources): Search the full path of files to copy in the\n+\tlist of sources of the application rather than in the list of units.\n+\t(Parse_Project_And_Apply_Config): Do not reset the name of the main\n+ \tproject file.\n+\t(Check_File): Use htables to find out whether a source is duplicated.\n+\t(Add_Source): check whether the source or unit were already seen earlier\n+\n+\t* gcc-interface/Makefile.in: Update gnatmake dependencies.\n+\n 2009-07-13  Robert Dewar  <dewar@adacore.com>\n \n \t* par-ch3.adb (P_Discrete_Choice_List): Choice can only be simple"}, {"sha": "64f8045710cc675cf92b27ebd01a6fc01eaf82dd", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -1391,8 +1391,7 @@ package body Clean is\n            (Project           => Main_Project,\n             In_Tree           => Project_Tree,\n             Project_File_Name => Project_File_Name.all,\n-            Packages_To_Check => Packages_To_Check_By_Gnatmake,\n-            Is_Config_File    => False);\n+            Packages_To_Check => Packages_To_Check_By_Gnatmake);\n \n          if Main_Project = No_Project then\n             Fail (\"\"\"\" & Project_File_Name.all & \"\"\" processing failed\");"}, {"sha": "ec0367de6f46692c39bdaf3e77303df4bf6cde1c", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -295,6 +295,7 @@ GNATMAKE_OBJS = a-except.o ali.o ali-util.o s-casuti.o \\\n  make.o makeusg.o makeutl.o mlib.o mlib-fil.o mlib-prj.o mlib-tgt.o \\\n  mlib-tgt-specific.o mlib-utl.o namet.o nlists.o opt.o osint.o osint-m.o \\\n  output.o prj.o prj-attr.o prj-attr-pm.o prj-com.o prj-dect.o prj-env.o \\\n+ prj-conf.o \\\n  prj-err.o prj-ext.o prj-nmsc.o prj-pars.o prj-part.o prj-proc.o prj-strt.o \\\n  prj-tree.o prj-util.o rident.o s-exctab.o s-secsta.o s-stalib.o s-stoele.o \\\n  scans.o scng.o sdefault.o sfn_scan.o s-purexc.o s-htable.o sinfo.o sinput.o \\"}, {"sha": "ef1cf3e712d480f8a81e1599bfba8d6dc2e18f88", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -365,7 +365,6 @@ procedure GNATCmd is\n                              new String'\n                                (Get_Name_String\n                                     (Proj.Project.Object_Directory.Name)     &\n-                                Directory_Separator                          &\n                                 B_Start.all                                  &\n                                 MLib.Fil.Ext_To\n                                   (Get_Name_String\n@@ -392,7 +391,6 @@ procedure GNATCmd is\n                              new String'\n                                (Get_Name_String\n                                     (Proj.Project.Object_Directory.Name)     &\n-                                Directory_Separator                          &\n                                 B_Start.all                                  &\n                                 Get_Name_String (Proj.Project.Library_Name)  &\n                                 \".ci\");\n@@ -514,7 +512,6 @@ procedure GNATCmd is\n                                (Get_Name_String\n                                  (Unit.File_Names\n                                    (Impl).Project. Object_Directory.Name)  &\n-                                Directory_Separator                        &\n                                 MLib.Fil.Ext_To\n                                   (Get_Name_String\n                                      (Unit.File_Names (Impl).Display_File),\n@@ -1077,16 +1074,15 @@ procedure GNATCmd is\n                         begin\n                            if Is_Regular_File\n                                 (Dir &\n-                                 Directory_Separator &\n                                  ALI_File (1 .. Last))\n                            then\n                               --  We have found the correct project, so we\n                               --  replace the file with the absolute path.\n \n                               Last_Switches.Table (J) :=\n                                 new String'\n-                                  (Dir & Directory_Separator &\n-                                   ALI_File (1 .. Last));\n+                                  (Dir\n+                                   & ALI_File (1 .. Last));\n \n                               --  And we are done\n \n@@ -1155,7 +1151,6 @@ procedure GNATCmd is\n                   Last_Switches.Increment_Last;\n                   Last_Switches.Table (Last_Switches.Last) :=\n                     new String'(Name_Buffer (1 .. Name_Len) &\n-                                Directory_Separator &\n                                 Executable_Name\n                                   (Base_Name (Arg (Arg'First .. Last))));\n                   exit;\n@@ -1784,8 +1779,7 @@ begin\n            (Project           => Project,\n             In_Tree           => Project_Tree,\n             Project_File_Name => Project_File.all,\n-            Packages_To_Check => Packages_To_Check,\n-            Is_Config_File    => False);\n+            Packages_To_Check => Packages_To_Check);\n \n          if Project = Prj.No_Project then\n             Fail (\"\"\"\" & Project_File.all & \"\"\" processing failed\");"}, {"sha": "3d370be24e71a7c88d329f0e95ab38e6d096dbda", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -1978,12 +1978,8 @@ package body Make is\n                   Name_Len := 0;\n                   Add_Str_To_Name_Buffer (Res_Obj_Dir);\n \n-                  if Name_Len > 1 and then\n-                    (Name_Buffer (Name_Len) = '/'\n-                       or else\n-                     Name_Buffer (Name_Len) = Directory_Separator)\n-                  then\n-                     Name_Len := Name_Len - 1;\n+                  if not Is_Directory_Separator (Name_Buffer (Name_Len)) then\n+                     Add_Char_To_Name_Buffer (Directory_Separator);\n                   end if;\n \n                   Obj_Dir := Name_Find;\n@@ -4450,8 +4446,8 @@ package body Make is\n                              (ALI_Project.Object_Directory.Name);\n                         end if;\n \n-                        if Name_Buffer (Name_Len) /=\n-                          Directory_Separator\n+                        if not Is_Directory_Separator\n+                          (Name_Buffer (Name_Len))\n                         then\n                            Add_Char_To_Name_Buffer (Directory_Separator);\n                         end if;\n@@ -5312,7 +5308,9 @@ package body Make is\n                   if not Is_Absolute_Path (Exec_File_Name) then\n                      Get_Name_String (Main_Project.Exec_Directory.Name);\n \n-                     if Name_Buffer (Name_Len) /= Directory_Separator then\n+                     if\n+                        not Is_Directory_Separator (Name_Buffer (Name_Len))\n+                     then\n                         Add_Char_To_Name_Buffer (Directory_Separator);\n                      end if;\n \n@@ -6867,8 +6865,7 @@ package body Make is\n            (Project           => Main_Project,\n             In_Tree           => Project_Tree,\n             Project_File_Name => Project_File_Name.all,\n-            Packages_To_Check => Packages_To_Check_By_Gnatmake,\n-            Is_Config_File    => False);\n+            Packages_To_Check => Packages_To_Check_By_Gnatmake);\n \n          --  The parsing of project files may have changed the current output\n \n@@ -7611,8 +7608,7 @@ package body Make is\n             --  separator.\n \n             if Argv (Argv'Last) = Directory_Separator then\n-               Object_Directory_Path :=\n-                 new String'(Argv);\n+               Object_Directory_Path := new String'(Argv);\n             else\n                Object_Directory_Path :=\n                  new String'(Argv & Directory_Separator);"}, {"sha": "c8aad89ab69f6c0f2aa78f1995510d5cf386c6a6", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -2152,20 +2152,12 @@ package body MLib.Prj is\n       First_Unit  : ALI.Unit_Id;\n       Second_Unit : ALI.Unit_Id;\n \n-      Data : Unit_Index;\n-\n       Copy_Subunits : Boolean := False;\n       --  When True, indicates that subunits, if any, need to be copied too\n \n       procedure Copy (File_Name : File_Name_Type);\n       --  Copy one source of the project to the target directory\n \n-      function Is_Same_Or_Extension\n-        (Extending : Project_Id;\n-         Extended  : Project_Id) return Boolean;\n-      --  Return True if project Extending is equal to or extends project\n-      --  Extended.\n-\n       ----------\n       -- Copy --\n       ----------\n@@ -2174,56 +2166,26 @@ package body MLib.Prj is\n          Success : Boolean;\n          pragma Warnings (Off, Success);\n \n+         Source : Standard.Prj.Source_Id;\n       begin\n-         Data := Units_Htable.Get_First (In_Tree.Units_HT);\n-\n-         Unit_Loop :\n-         while Data /= No_Unit_Index loop\n-            --  Find and copy the immediate or inherited source\n-\n-            for J in Data.File_Names'Range loop\n-               if Data.File_Names (J) /= null\n-                 and then Is_Same_Or_Extension\n-                   (For_Project, Data.File_Names (J).Project)\n-                 and then Data.File_Names (J).File = File_Name\n-               then\n-                  Copy_File\n-                    (Get_Name_String (Data.File_Names (J).Path.Name),\n-                     Target,\n-                     Success,\n-                     Mode => Overwrite,\n-                     Preserve => Preserve);\n-                  exit Unit_Loop;\n-               end if;\n-            end loop;\n-\n-            Data := Units_Htable.Get_Next (In_Tree.Units_HT);\n-         end loop Unit_Loop;\n+         Source := Find_Source\n+           (In_Tree, For_Project,\n+            In_Extended_Only => True,\n+            Base_Name => File_Name);\n+\n+         if Source /= No_Source\n+           and then not Source.Locally_Removed\n+           and then Source.Replaced_By = No_Source\n+         then\n+            Copy_File\n+              (Get_Name_String (Source.Path.Name),\n+               Target,\n+               Success,\n+               Mode     => Overwrite,\n+               Preserve => Preserve);\n+         end if;\n       end Copy;\n \n-      --------------------------\n-      -- Is_Same_Or_Extension --\n-      --------------------------\n-\n-      function Is_Same_Or_Extension\n-        (Extending : Project_Id;\n-         Extended  : Project_Id) return Boolean\n-      is\n-         Ext : Project_Id;\n-\n-      begin\n-         Ext := Extending;\n-         while Ext /= No_Project loop\n-            if Ext = Extended then\n-               return True;\n-            end if;\n-\n-            Ext := Ext.Extends;\n-         end loop;\n-\n-         return False;\n-      end Is_Same_Or_Extension;\n-\n    --  Start of processing for Copy_Interface_Sources\n \n    begin"}, {"sha": "5d029dbf38719048b83abf9498115f31cb58b8fc", "filename": "gcc/ada/mlib.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fmlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fmlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -55,7 +55,7 @@ package body MLib is\n          Write_Line (Output_File);\n       end if;\n \n-      Ar (Output_Dir & Directory_Separator &\n+      Ar (Output_Dir &\n           \"lib\" & Output_File & \".a\", Objects => Ofiles);\n    end Build_Library;\n "}, {"sha": "ea8fe9a66b64fd51113e4f005b3fdf02a2551e3f", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -34,7 +34,6 @@ with Prj.Proc;         use Prj.Proc;\n with Prj.Tree;         use Prj.Tree;\n with Prj.Util;         use Prj.Util;\n with Prj;              use Prj;\n-with Sinput.P;\n with Snames;           use Snames;\n with System.Case_Util; use System.Case_Util;\n with System;\n@@ -908,7 +907,9 @@ package body Prj.Conf is\n       Report_Error               : Put_Line_Access := null;\n       On_Load_Config             : Config_File_Hook := null;\n       Compiler_Driver_Mandatory  : Boolean := True;\n-      Allow_Duplicate_Basenames  : Boolean := False)\n+      Allow_Duplicate_Basenames  : Boolean := False;\n+      Reset_Tree                 : Boolean := True;\n+      When_No_Sources            : Error_Warning := Warning)\n    is\n       Main_Config_Project : Project_Id;\n       Success : Boolean;\n@@ -923,7 +924,8 @@ package body Prj.Conf is\n          Success                => Success,\n          From_Project_Node      => User_Project_Node,\n          From_Project_Node_Tree => Project_Node_Tree,\n-         Report_Error           => Report_Error);\n+         Report_Error           => Report_Error,\n+         Reset_Tree             => Reset_Tree);\n \n       if not Success then\n          Main_Project := No_Project;\n@@ -951,8 +953,6 @@ package body Prj.Conf is\n \n       --  Finish processing the user's project\n \n-      Sinput.P.Reset_First;\n-\n       Prj.Proc.Process_Project_Tree_Phase_2\n         (In_Tree                   => Project_Tree,\n          Project                   => Main_Project,\n@@ -961,7 +961,7 @@ package body Prj.Conf is\n          From_Project_Node_Tree    => Project_Node_Tree,\n          Report_Error              => Report_Error,\n          Current_Dir               => Current_Directory,\n-         When_No_Sources           => Warning,\n+         When_No_Sources           => When_No_Sources,\n          Compiler_Driver_Mandatory => Compiler_Driver_Mandatory,\n          Allow_Duplicate_Basenames => Allow_Duplicate_Basenames,\n          Is_Config_File            => False);\n@@ -1121,4 +1121,76 @@ package body Prj.Conf is\n       end if;\n    end Runtime_Name_For;\n \n+   ------------------------------------\n+   -- Add_Default_GNAT_Naming_Scheme --\n+   ------------------------------------\n+\n+   procedure Add_Default_GNAT_Naming_Scheme\n+     (Config_File  : in out Project_Node_Id;\n+      Project_Tree : Project_Node_Tree_Ref)\n+   is\n+      Name : Name_Id;\n+   begin\n+      if Config_File = Empty_Node then\n+         --  Create a dummy config file is none was found.\n+\n+         Name_Len := Auto_Cgpr'Length;\n+         Name_Buffer (1 .. Name_Len) := Auto_Cgpr;\n+         Name := Name_Find;\n+\n+         Config_File := Create_Project\n+           (In_Tree        => Project_Tree,\n+            Name           => Name,\n+            Full_Path      => Path_Name_Type (Name),\n+            Is_Config_File => True);\n+\n+         --  ??? This isn't strictly required, since Prj.Nmsc.Add_Language\n+         --  already has a workaround in the Ada_Only case. But it would be\n+         --  nicer to do it this way\n+         --  Likewise for the default language, hard-coded in\n+         --  Pjr.Nmsc.Check_Programming_Languages\n+\n+--           Update_Attribute_Value_In_Scenario\n+--             (Tree               => Project_Tree,\n+--              Project            => Config_File,\n+--              Scenario_Variables => No_Scenario,\n+--              Attribute          => \"default_language\",\n+--              Value              => \"Ada\");\n+--\n+--           Update_Attribute_Value_In_Scenario\n+--             (Tree               => Project_Tree,\n+--              Project            => Config_File,\n+--              Scenario_Variables => No_Scenario,\n+--              Attribute          => Separate_Suffix_Attribute,\n+--              Value              => \".adb\",\n+--              Attribute_Index    => \"Ada\");\n+--           Update_Attribute_Value_In_Scenario\n+--             (Tree               => Project_Tree,\n+--              Project            => Config_File,\n+--              Scenario_Variables => No_Scenario,\n+--              Attribute          => Spec_Suffix_Attribute,\n+--              Value              => \".ads\",\n+--              Attribute_Index    => \"Ada\");\n+--           Update_Attribute_Value_In_Scenario\n+--             (Tree               => Project_Tree,\n+--              Project            => Config_File,\n+--              Scenario_Variables => No_Scenario,\n+--              Attribute          => Impl_Suffix_Attribute,\n+--              Value              => \".adb\",\n+--              Attribute_Index    => \"Ada\");\n+--           Update_Attribute_Value_In_Scenario\n+--             (Tree               => Project_Tree,\n+--              Project            => Config_File,\n+--              Scenario_Variables => No_Scenario,\n+--              Attribute          => Dot_Replacement_Attribute,\n+--              Value              => \"-\");\n+--           Update_Attribute_Value_In_Scenario\n+--             (Tree               => Project_Tree,\n+--              Project            => Config_File,\n+--              Scenario_Variables => No_Scenario,\n+--              Attribute          => Casing_Attribute,\n+--              Value              => \"lowercase\");\n+      end if;\n+   end Add_Default_GNAT_Naming_Scheme;\n+\n end Prj.Conf;"}, {"sha": "80f28ab1cac9f1ed0801079e9372943a41ddec6b", "filename": "gcc/ada/prj-conf.ads", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-conf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-conf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.ads?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -99,10 +99,15 @@ package Prj.Conf is\n       Report_Error               : Put_Line_Access := null;\n       On_Load_Config             : Config_File_Hook := null;\n       Compiler_Driver_Mandatory  : Boolean := True;\n-      Allow_Duplicate_Basenames  : Boolean := False);\n+      Allow_Duplicate_Basenames  : Boolean := False;\n+      Reset_Tree                 : Boolean := True;\n+      When_No_Sources            : Error_Warning := Warning);\n    --  Same as above, except the project must already have been parsed through\n    --  Prj.Part.Parse, and only the processing of the project and the\n    --  configuration is done at this level.\n+   --  If Reset_Tree is true, all projects are first removed from the tree.\n+   --  When_No_Sources indicates what should be done when no sources are found\n+   --  for one of the languages of the project.\n \n    Invalid_Config : exception;\n \n@@ -162,6 +167,15 @@ package Prj.Conf is\n    --  projects, so that when the second phase of the processing is performed\n    --  these attributes are automatically taken into account.\n \n+   procedure Add_Default_GNAT_Naming_Scheme\n+     (Config_File  : in out Prj.Tree.Project_Node_Id;\n+      Project_Tree : Prj.Tree.Project_Node_Tree_Ref);\n+   --  A hook for Get_Or_Create_Configuration_File and\n+   --  Process_Project_And_Apply_Config that will create a new config file (in\n+   --  memory) and add the default GNAT naming scheme to it. Nothing is done\n+   --  if the config_file already exists, to avoid overriding what the user\n+   --  might have put in there.\n+\n    --------------\n    -- Runtimes --\n    --------------"}, {"sha": "4efe034da8491ce0486abc3b7c2d4467bb72416b", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 412, "deletions": 1024, "changes": 1436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -28,7 +28,6 @@ with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n with GNAT.HTable;\n \n with Err_Vars; use Err_Vars;\n-with Hostparm;\n with MLib.Tgt;\n with Opt;      use Opt;\n with Osint;    use Osint;\n@@ -165,8 +164,8 @@ package body Prj.Nmsc is\n \n    package Object_File_Names is new GNAT.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n-      Element    => File_Name_Type,\n-      No_Element => No_File,\n+      Element    => Source_Id,\n+      No_Element => No_Source,\n       Key        => File_Name_Type,\n       Hash       => Hash,\n       Equal      => \"=\");\n@@ -235,24 +234,23 @@ package body Prj.Nmsc is\n    procedure Add_Source\n      (Id                  : out Source_Id;\n       In_Tree             : Project_Tree_Ref;\n+      File_To_Source     : in out Files_Htable.Instance;\n       Project             : Project_Id;\n       Lang_Id             : Language_Ptr;\n       Kind                : Source_Kind;\n       File_Name           : File_Name_Type;\n       Display_File        : File_Name_Type;\n+      Allow_Duplicate_Basenames : Boolean;\n       Naming_Exception    : Boolean := False;\n       Path                : Path_Information := No_Path_Information;\n       Alternate_Languages : Language_List := null;\n       Unit                : Name_Id   := No_Name;\n-      Index               : Int       := 0;\n-      Source_To_Replace   : Source_Id := No_Source);\n+      Index               : Int       := 0);\n    --  Add a new source to the different lists: list of all sources in the\n    --  project tree, list of source of a project and list of sources of a\n    --  language.\n    --\n    --  If Path is specified, the file is also added to Source_Paths_HT.\n-   --  If Source_To_Replace is specified, it points to the source in the\n-   --  extended project that the new file is overriding.\n \n    function Canonical_Case_File_Name (Name : Name_Id) return File_Name_Type;\n    --  Same as Osint.Canonical_Case_File_Name but applies to Name_Id.\n@@ -278,11 +276,13 @@ package body Prj.Nmsc is\n    --  Check that a name is a valid Ada unit name\n \n    procedure Check_Package_Naming\n-     (Project        : Project_Id;\n-      In_Tree        : Project_Tree_Ref;\n-      Is_Config_File : Boolean;\n-      Bodies         : out Array_Element_Id;\n-      Specs          : out Array_Element_Id);\n+     (Project         : Project_Id;\n+      In_Tree         : Project_Tree_Ref;\n+      File_To_Source : in out Files_Htable.Instance;\n+      Is_Config_File  : Boolean;\n+      Allow_Duplicate_Basenames : Boolean;\n+      Bodies          : out Array_Element_Id;\n+      Specs           : out Array_Element_Id);\n    --  Check the naming scheme part of Data, and initialize the naming scheme\n    --  data in the config of the various languages. Is_Config_File should be\n    --  True if Project is a config file (.cgpr) This also returns the naming\n@@ -342,27 +342,6 @@ package body Prj.Nmsc is\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n-   procedure Check_And_Normalize_Unit_Names\n-     (Project    : Project_Id;\n-      In_Tree    : Project_Tree_Ref;\n-      List       : Array_Element_Id;\n-      Debug_Name : String);\n-   --  Check that a list of unit names contains only valid names. Casing\n-   --  is normalized where appropriate.\n-   --  Debug_Name is the name representing the list, and is used for debug\n-   --  output only.\n-\n-   procedure Find_Ada_Sources\n-     (Project               : Project_Id;\n-      In_Tree               : Project_Tree_Ref;\n-      Explicit_Sources_Only : Boolean;\n-      Proc_Data             : in out Processing_Data);\n-   --  Find all Ada sources by traversing all source directories. If\n-   --  Explicit_Sources_Only is True, then the sources found must belong to\n-   --  the list of sources specified explicitly in the project file. If\n-   --  Explicit_Sources_Only is False, then all sources matching the naming\n-   --  scheme are recorded.\n-\n    function Compute_Directory_Last (Dir : String) return Natural;\n    --  Return the index of the last significant character in Dir. This is used\n    --  to avoid duplicate '/' (slash) characters at the end of directory names.\n@@ -379,6 +358,7 @@ package body Prj.Nmsc is\n    procedure Search_Directories\n      (Project                   : Project_Id;\n       In_Tree                   : Project_Tree_Ref;\n+      File_To_Source           : in out Files_Htable.Instance;\n       For_All_Sources           : Boolean;\n       Allow_Duplicate_Basenames : Boolean;\n       Excluded                  : in out Excluded_Sources_Htable.Instance);\n@@ -392,9 +372,11 @@ package body Prj.Nmsc is\n    procedure Check_File\n      (Project                   : Project_Id;\n       In_Tree                   : Project_Tree_Ref;\n+      File_To_Source           : in out Files_Htable.Instance;\n       Path                      : Path_Name_Type;\n       File_Name                 : File_Name_Type;\n       Display_File_Name         : File_Name_Type;\n+      Locally_Removed           : Boolean;\n       For_All_Sources           : Boolean;\n       Allow_Duplicate_Basenames : Boolean);\n    --  Check if file File_Name is a valid source of the project. This is used\n@@ -464,7 +446,7 @@ package body Prj.Nmsc is\n    procedure Find_Sources\n      (Project   : Project_Id;\n       In_Tree   : Project_Tree_Ref;\n-      Proc_Data : in out Processing_Data;\n+      File_To_Source           : in out Files_Htable.Instance;\n       Allow_Duplicate_Basenames : Boolean;\n       Excluded                  : in out Excluded_Sources_Htable.Instance);\n    --  Process the Source_Files and Source_List_File attributes, and store the\n@@ -484,24 +466,17 @@ package body Prj.Nmsc is\n    --  compute its unit name. If Unit is set to No_Name on exit, none of the\n    --  other out parameters are relevant.\n \n-   procedure Get_Unit\n-     (In_Tree             : Project_Tree_Ref;\n-      Canonical_File_Name : File_Name_Type;\n-      Project             : Project_Id;\n-      Exception_Id        : out Ada_Naming_Exception_Id;\n-      Unit_Name           : out Name_Id;\n-      Unit_Kind           : out Spec_Or_Body);\n-   --  Find out, from a file name, the unit name, the unit kind and if a\n-   --  specific SFN pragma is needed. If the file name corresponds to no unit,\n-   --  then Unit_Name will be No_Name. If the file is a multi-unit source or an\n-   --  exception to the naming scheme, then Exception_Id is set to the unit or\n-   --  units that the source contains, and the other information are not set.\n-\n-   function Is_Illegal_Suffix\n-     (Suffix          : File_Name_Type;\n-      Dot_Replacement : File_Name_Type) return Boolean;\n-   --  Returns True if the string Suffix cannot be used as a spec suffix, a\n-   --  body suffix or a separate suffix.\n+   procedure Check_Illegal_Suffix\n+     (Project         : Project_Id;\n+      In_Tree         : Project_Tree_Ref;\n+      Suffix          : File_Name_Type;\n+      Dot_Replacement : File_Name_Type;\n+      Attribute_Name  : String;\n+      Location        : Source_Ptr);\n+   --  Display an error message if the given suffix is illegal for some reason.\n+   --  The name of the attribute we are testing is specified in Attribute_Name,\n+   --  which is used in the error message. Location is the location where the\n+   --  suffix is defined.\n \n    procedure Locate_Directory\n      (Project          : Project_Id;\n@@ -542,26 +517,6 @@ package body Prj.Nmsc is\n    --  Returns the path name of a (non project) file. Returns an empty string\n    --  if file cannot be found.\n \n-   procedure Prepare_Ada_Naming_Exceptions\n-     (List    : Array_Element_Id;\n-      In_Tree : Project_Tree_Ref;\n-      Kind    : Spec_Or_Body);\n-   --  Prepare the internal hash tables used for checking naming exceptions\n-   --  for Ada. Insert all elements of List in the tables.\n-\n-   procedure Record_Ada_Source\n-     (File_Name       : File_Name_Type;\n-      Path_Name       : Path_Name_Type;\n-      Project         : Project_Id;\n-      In_Tree         : Project_Tree_Ref;\n-      Proc_Data       : in out Processing_Data;\n-      Ada_Language    : Language_Ptr;\n-      Location        : Source_Ptr;\n-      Source_Recorded : in out Boolean);\n-   --  Put a unit in the list of units of a project, if the file name\n-   --  corresponds to a valid unit name. Ada_Language is a pointer to the\n-   --  Language_Data for \"Ada\" in Project.\n-\n    procedure Remove_Source\n      (Id          : Source_Id;\n       Replaced_By : Source_Id);\n@@ -684,28 +639,160 @@ package body Prj.Nmsc is\n    procedure Add_Source\n      (Id                  : out Source_Id;\n       In_Tree             : Project_Tree_Ref;\n+      File_To_Source     : in out Files_Htable.Instance;\n       Project             : Project_Id;\n       Lang_Id             : Language_Ptr;\n       Kind                : Source_Kind;\n       File_Name           : File_Name_Type;\n       Display_File        : File_Name_Type;\n+      Allow_Duplicate_Basenames : Boolean;\n       Naming_Exception    : Boolean := False;\n       Path                : Path_Information := No_Path_Information;\n       Alternate_Languages : Language_List := null;\n       Unit                : Name_Id   := No_Name;\n-      Index               : Int       := 0;\n-      Source_To_Replace   : Source_Id := No_Source)\n+      Index               : Int       := 0)\n    is\n-      Config : constant Language_Config := Lang_Id.Config;\n-      UData  : Unit_Index;\n+      Config    : constant Language_Config := Lang_Id.Config;\n+      UData     : Unit_Index;\n+      Add_Src   : Boolean;\n+      Source    : Source_Id;\n+      Prev_Unit : Unit_Index := No_Unit_Index;\n+      Source_To_Replace : Source_Id := No_Source;\n \n    begin\n+      --  Check if the same file name or unit is used in the prj tree\n+\n+      Add_Src := True;\n+      Source  := Files_Htable.Get (File_To_Source, File_Name);\n+\n+      if Unit /= No_Name then\n+         Prev_Unit := Units_Htable.Get (In_Tree.Units_HT, Unit);\n+      end if;\n+\n+      if Prev_Unit /= No_Unit_Index\n+        and then (Kind = Impl or Kind = Spec)\n+        and then Prev_Unit.File_Names (Kind) /= null\n+      then\n+         --  Suspicious, we need to check later whether this is authorized\n+         Add_Src := False;\n+         Source := Prev_Unit.File_Names (Kind);\n+\n+      elsif Source /= No_Source then\n+         if Source.Index = Index then\n+            Add_Src := False;\n+         end if;\n+      end if;\n+\n+      --  Duplication of file/unit in same project is allowed\n+      --  if order of source directories is known.\n+\n+      if Add_Src = False then\n+         Add_Src := True;\n+\n+         if Project = Source.Project then\n+            if Prev_Unit = No_Unit_Index then\n+               if Allow_Duplicate_Basenames then\n+                  Add_Src := True;\n+               elsif Project.Known_Order_Of_Source_Dirs then\n+                  Add_Src := False;\n+               else\n+                  Error_Msg_File_1 := File_Name;\n+                  Error_Msg\n+                    (Project, In_Tree, \"duplicate source file name {\",\n+                     No_Location);\n+                  Add_Src := False;\n+               end if;\n+\n+            else\n+               if Project.Known_Order_Of_Source_Dirs then\n+                  Add_Src := False;\n+\n+               --  We might be seeing the same file through a different path\n+               --  (for instance because of symbolic links)\n+\n+               elsif Source.Path.Name /= Path.Name then\n+                  Error_Msg_Name_1 := Unit;\n+                  Error_Msg\n+                    (Project, In_Tree, \"duplicate unit %%\",\n+                     No_Location);\n+                  Add_Src := False;\n+               end if;\n+            end if;\n+\n+            --  Do not allow the same unit name in different projects,\n+            --  except if one is extending the other.\n+\n+            --  For a file based language, the same file name replaces\n+            --  a file in a project being extended, but it is allowed\n+            --  to have the same file name in unrelated projects.\n+\n+         elsif Is_Extending (Project, Source.Project) then\n+            Source_To_Replace := Source;\n+\n+         elsif Prev_Unit /= No_Unit_Index\n+           and then not Source.Locally_Removed\n+         then\n+            if Path /= No_Path_Information then\n+               Error_Msg_Name_1 := Unit;\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"unit %% cannot belong to several projects\",\n+                  No_Location);\n+\n+               Error_Msg_Name_1 := Project.Name;\n+               Error_Msg_Name_2 := Name_Id (Path.Name);\n+               Error_Msg\n+                 (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n+\n+               Error_Msg_Name_1 := Source.Project.Name;\n+               Error_Msg_Name_2 := Name_Id (Source.Path.Display_Name);\n+               Error_Msg\n+                 (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n+\n+            else\n+               Error_Msg_Name_1 := Unit;\n+               Error_Msg_Name_2 := Source.Project.Name;\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"unit %% already belongs to project %%\",\n+                  No_Location);\n+            end if;\n+\n+            Add_Src := False;\n+\n+         elsif not Source.Locally_Removed\n+           and then not Allow_Duplicate_Basenames\n+           and then Lang_Id.Config.Kind = Unit_Based\n+         then\n+            Error_Msg_File_1 := File_Name;\n+            Error_Msg_File_2 := File_Name_Type (Source.Project.Name);\n+            Error_Msg\n+              (Project, In_Tree,\n+               \"{ is already a source of project {\",\n+               No_Location);\n+\n+            --  Add the file anyway, to avoid further warnings like \"language\n+            --  unknown\"\n+            Add_Src := True;\n+         end if;\n+      end if;\n+\n+      if not Add_Src then\n+         return;\n+      end if;\n+\n+      --  Add the new file\n+\n       Id := new Source_Data;\n \n       if Current_Verbosity = High then\n          Write_Str (\"Adding source File: \");\n          Write_Str (Get_Name_String (File_Name));\n \n+         if Index /= 0 then\n+            Write_Str (\" at\" & Index'Img);\n+         end if;\n+\n          if Lang_Id.Config.Kind = Unit_Based then\n             Write_Str (\" Unit: \");\n \n@@ -778,6 +865,8 @@ package body Prj.Nmsc is\n       if Source_To_Replace /= No_Source then\n          Remove_Source (Source_To_Replace, Id);\n       end if;\n+\n+      Files_Htable.Set (File_To_Source, File_Name, Id);\n    end Add_Source;\n \n    -------------------\n@@ -906,12 +995,10 @@ package body Prj.Nmsc is\n \n       Extending := Project.Extends /= No_Project;\n \n-      Check_Package_Naming (Project, In_Tree, Is_Config_File, Bodies, Specs);\n-\n-      if Get_Mode = Ada_Only then\n-         Prepare_Ada_Naming_Exceptions (Bodies, In_Tree, Impl);\n-         Prepare_Ada_Naming_Exceptions (Specs, In_Tree, Spec);\n-      end if;\n+      Check_Package_Naming\n+        (Project, In_Tree, Proc_Data.Units, Is_Config_File,\n+         Allow_Duplicate_Basenames => Allow_Duplicate_Basenames,\n+         Bodies => Bodies, Specs => Specs);\n \n       --  Find the sources\n \n@@ -2648,79 +2735,24 @@ package body Prj.Nmsc is\n       end if;\n    end Check_Interfaces;\n \n-   ------------------------------------\n-   -- Check_And_Normalize_Unit_Names --\n-   ------------------------------------\n-\n-   procedure Check_And_Normalize_Unit_Names\n-     (Project    : Project_Id;\n-      In_Tree    : Project_Tree_Ref;\n-      List       : Array_Element_Id;\n-      Debug_Name : String)\n-   is\n-      Current   : Array_Element_Id;\n-      Element   : Array_Element;\n-      Unit_Name : Name_Id;\n-\n-   begin\n-      if Current_Verbosity = High then\n-         Write_Line (\"  Checking unit names in \" & Debug_Name);\n-      end if;\n-\n-      Current := List;\n-      while Current /= No_Array_Element loop\n-         Element := In_Tree.Array_Elements.Table (Current);\n-         Element.Value.Value :=\n-           Name_Id (Canonical_Case_File_Name (Element.Value.Value));\n-\n-         --  Check that it contains a valid unit name\n-\n-         Get_Name_String (Element.Index);\n-         Check_Ada_Name (Name_Buffer (1 .. Name_Len), Unit_Name);\n-\n-         if Unit_Name = No_Name then\n-            Err_Vars.Error_Msg_Name_1 := Element.Index;\n-            Error_Msg\n-              (Project, In_Tree,\n-               \"%% is not a valid unit name.\",\n-               Element.Value.Location);\n-\n-         else\n-            if Current_Verbosity = High then\n-               Write_Str (\"    for unit: \");\n-               Write_Line (Get_Name_String (Unit_Name));\n-            end if;\n-\n-            Element.Index := Unit_Name;\n-            In_Tree.Array_Elements.Table (Current) := Element;\n-         end if;\n-\n-         Current := Element.Next;\n-      end loop;\n-   end Check_And_Normalize_Unit_Names;\n-\n    --------------------------\n    -- Check_Package_Naming --\n    --------------------------\n \n    procedure Check_Package_Naming\n-     (Project        : Project_Id;\n-      In_Tree        : Project_Tree_Ref;\n-      Is_Config_File : Boolean;\n-      Bodies         : out Array_Element_Id;\n-      Specs          : out Array_Element_Id)\n+     (Project         : Project_Id;\n+      In_Tree         : Project_Tree_Ref;\n+      File_To_Source : in out Files_Htable.Instance;\n+      Is_Config_File  : Boolean;\n+      Allow_Duplicate_Basenames : Boolean;\n+      Bodies          : out Array_Element_Id;\n+      Specs           : out Array_Element_Id)\n    is\n       Naming_Id : constant Package_Id :=\n                    Util.Value_Of (Name_Naming, Project.Decl.Packages, In_Tree);\n       Naming    : Package_Element;\n \n       Ada_Body_Suffix_Loc : Source_Ptr := No_Location;\n-      Ada_Spec_Suffix_Loc : Source_Ptr := No_Location;\n-\n-      procedure Check_Naming_Ada_Only;\n-      --  Does Check_Naming_Schemes processing in Ada_Only mode.\n-      --  If there is a package Naming, puts in Data.Naming the contents of\n-      --  this package.\n \n       procedure Check_Naming_Multi_Lang;\n       --  Does Check_Naming_Schemes processing for Multi_Language mode\n@@ -2873,13 +2905,9 @@ package body Prj.Nmsc is\n                Separate_Suffix := Canonical_Case_File_Name (Sep_Suffix.Value);\n                Sep_Suffix_Loc  := Sep_Suffix.Location;\n \n-               if Is_Illegal_Suffix (Separate_Suffix, Dot_Replacement) then\n-                  Err_Vars.Error_Msg_File_1 := Separate_Suffix;\n-                  Error_Msg\n-                    (Project, In_Tree,\n-                     \"{ is illegal for Separate_Suffix\",\n-                     Sep_Suffix.Location);\n-               end if;\n+               Check_Illegal_Suffix\n+                 (Project, In_Tree, Separate_Suffix,\n+                  Dot_Replacement, \"Separate_Suffix\", Sep_Suffix.Location);\n             end if;\n          end if;\n \n@@ -2945,9 +2973,11 @@ package body Prj.Nmsc is\n                   Add_Source\n                     (Id               => Source,\n                      In_Tree          => In_Tree,\n+                     File_To_Source  => File_To_Source,\n                      Project          => Project,\n                      Lang_Id          => Lang_Id,\n                      Kind             => Kind,\n+                     Allow_Duplicate_Basenames => Allow_Duplicate_Basenames,\n                      File_Name        => File_Name,\n                      Display_File     => File_Name_Type (Element.Value),\n                      Naming_Exception => True);\n@@ -2997,9 +3027,6 @@ package body Prj.Nmsc is\n          Index             : Int;\n          File_Name         : File_Name_Type;\n          Source            : Source_Id;\n-         Source_To_Replace : Source_Id := No_Source;\n-         Other_Project     : Project_Id;\n-         Iter              : Source_Iterator;\n \n       begin\n          case Kind is\n@@ -3057,182 +3084,32 @@ package body Prj.Nmsc is\n             end if;\n \n             if Unit /= No_Name then\n-\n-               --  Check if the source already exists\n-               --  ??? In Ada_Only mode (Record_Unit), we use a htable for\n-               --  efficiency\n-\n-               Source_To_Replace := No_Source;\n-               Iter := For_Each_Source (In_Tree);\n-\n-               loop\n-                  Source := Prj.Element (Iter);\n-                  exit when Source = No_Source\n-                    or else (Source.Unit /= null\n-                              and then Source.Unit.Name = Unit\n-                              and then Source.Index = Index);\n-                  Next (Iter);\n-               end loop;\n-\n-               if Source /= No_Source then\n-                  if Source.Kind /= Kind then\n-                     loop\n-                        Next (Iter);\n-                        Source := Prj.Element (Iter);\n-\n-                        exit when Source = No_Source\n-                          or else (Source.Unit /= null\n-                                    and then Source.Unit.Name = Unit\n-                                    and then Source.Index = Index);\n-                     end loop;\n-                  end if;\n-\n-                  if Source /= No_Source then\n-                     Other_Project := Source.Project;\n-\n-                     if Is_Extending (Project, Other_Project) then\n-                        Source_To_Replace := Source;\n-                        Source := No_Source;\n-\n-                     else\n-                        Error_Msg_Name_1 := Unit;\n-                        Error_Msg_Name_2 := Other_Project.Name;\n-                        Error_Msg\n-                          (Project,\n-                           In_Tree,\n-                           \"%% is already a source of project %%\",\n-                           Element.Value.Location);\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               if Source = No_Source then\n-                  Add_Source\n-                    (Id           => Source,\n-                     In_Tree      => In_Tree,\n-                     Project      => Project,\n-                     Lang_Id      => Lang_Id,\n-                     Kind         => Kind,\n-                     File_Name    => File_Name,\n-                     Display_File => File_Name_Type (Element.Value.Value),\n-                     Unit         => Unit,\n-                     Index        => Index,\n-                     Naming_Exception => True,\n-                     Source_To_Replace => Source_To_Replace);\n-               end if;\n+               Add_Source\n+                 (Id           => Source,\n+                  In_Tree      => In_Tree,\n+                  File_To_Source => File_To_Source,\n+                  Project      => Project,\n+                  Lang_Id      => Lang_Id,\n+                  Kind         => Kind,\n+                  File_Name    => File_Name,\n+                  Allow_Duplicate_Basenames => Allow_Duplicate_Basenames,\n+                  Display_File => File_Name_Type (Element.Value.Value),\n+                  Unit         => Unit,\n+                  Index        => Index,\n+                  Naming_Exception => True);\n             end if;\n \n             Exceptions := Element.Next;\n          end loop;\n       end Process_Exceptions_Unit_Based;\n \n-      ---------------------------\n-      -- Check_Naming_Ada_Only --\n-      ---------------------------\n-\n-      procedure Check_Naming_Ada_Only is\n-         Ada : constant Language_Ptr :=\n-                 Get_Language_From_Name (Project, \"ada\");\n-\n-         Casing_Defined : Boolean;\n-         Sep_Suffix_Loc : Source_Ptr;\n-\n-      begin\n-         --  If no language, then nothing to do\n-\n-         if Ada = null then\n-            return;\n-         end if;\n-\n-         declare\n-            Data : Lang_Naming_Data renames Ada.Config.Naming_Data;\n-\n-         begin\n-            --  The default value of separate suffix should be the same as the\n-            --  body suffix, so we need to compute that first.\n-\n-            Data.Separate_Suffix := Data.Body_Suffix;\n-            Write_Attr (\"Body_Suffix\", Get_Name_String (Data.Body_Suffix));\n-\n-            --  We'll need the dot replacement below, so compute it now\n-\n-            Check_Common\n-              (Dot_Replacement => Data.Dot_Replacement,\n-               Casing          => Data.Casing,\n-               Casing_Defined  => Casing_Defined,\n-               Separate_Suffix => Data.Separate_Suffix,\n-               Sep_Suffix_Loc  => Sep_Suffix_Loc);\n-\n-            Bodies := Util.Value_Of (Name_Body, Naming.Decl.Arrays, In_Tree);\n-\n-            if Bodies /= No_Array_Element then\n-               Check_And_Normalize_Unit_Names\n-                 (Project, In_Tree, Bodies, \"Naming.Bodies\");\n-            end if;\n-\n-            Specs := Util.Value_Of (Name_Spec, Naming.Decl.Arrays, In_Tree);\n-\n-            if Specs /= No_Array_Element then\n-               Check_And_Normalize_Unit_Names\n-                 (Project, In_Tree, Specs, \"Naming.Specs\");\n-            end if;\n-\n-            --  Check Spec_Suffix\n-\n-            if Is_Illegal_Suffix (Data.Spec_Suffix, Data.Dot_Replacement) then\n-               Err_Vars.Error_Msg_File_1 := Data.Spec_Suffix;\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"{ is illegal for Spec_Suffix\",\n-                  Ada_Spec_Suffix_Loc);\n-            end if;\n-\n-            Write_Attr (\"Spec_Suffix\", Get_Name_String (Data.Spec_Suffix));\n-\n-            --  Check Body_Suffix\n-\n-            if Is_Illegal_Suffix (Data.Body_Suffix, Data.Dot_Replacement) then\n-               Err_Vars.Error_Msg_File_1 := Data.Body_Suffix;\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"{ is illegal for Body_Suffix\",\n-                  Ada_Body_Suffix_Loc);\n-            end if;\n-\n-            --  Spec_Suffix cannot be equal to Body_Suffix or Separate_Suffix,\n-            --  since that would cause a clear ambiguity. Note that we do allow\n-            --  a Spec_Suffix to have the same termination as one of these,\n-            --  which causes a potential ambiguity, but we resolve that my\n-            --  matching the longest possible suffix.\n-\n-            if Data.Spec_Suffix = Data.Body_Suffix then\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"Body_Suffix (\"\"\"\n-                    &  Get_Name_String (Data.Body_Suffix)\n-                    &  \"\"\") cannot be the same as Spec_Suffix.\",\n-                  Ada_Body_Suffix_Loc);\n-            end if;\n-\n-            if Data.Body_Suffix /= Data.Separate_Suffix\n-              and then Data.Spec_Suffix = Data.Separate_Suffix\n-            then\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"Separate_Suffix (\"\"\"\n-                    & Get_Name_String (Data.Separate_Suffix)\n-                    & \"\"\") cannot be the same as Spec_Suffix.\",\n-                  Sep_Suffix_Loc);\n-            end if;\n-         end;\n-      end Check_Naming_Ada_Only;\n-\n       -----------------------------\n       -- Check_Naming_Multi_Lang --\n       -----------------------------\n \n       procedure Check_Naming_Multi_Lang is\n-         Dot_Replacement : File_Name_Type := No_File;\n+         Dot_Replacement : File_Name_Type :=\n+           File_Name_Type (First_Name_Id + Character'Pos ('-'));\n          Separate_Suffix : File_Name_Type := No_File;\n          Casing          : Casing_Type    := All_Lower_Case;\n          Casing_Defined  : Boolean;\n@@ -3269,11 +3146,6 @@ package body Prj.Nmsc is\n                   if Casing_Defined then\n                      Lang_Id.Config.Naming_Data.Casing := Casing;\n                   end if;\n-\n-                  if Separate_Suffix /= No_File then\n-                     Lang_Id.Config.Naming_Data.Separate_Suffix :=\n-                         Separate_Suffix;\n-                  end if;\n                end if;\n \n                Lang_Id := Lang_Id.Next;\n@@ -3297,14 +3169,24 @@ package body Prj.Nmsc is\n             if Suffix = Nil_Variable_Value then\n                Suffix := Value_Of\n                  (Name                    => Lang,\n-                  Attribute_Or_Array_Name => Name_Spec_Suffix,\n+                  Attribute_Or_Array_Name => Name_Specification_Suffix,\n                   In_Package              => Naming_Id,\n                   In_Tree                 => In_Tree);\n             end if;\n \n             if Suffix /= Nil_Variable_Value then\n                Lang_Id.Config.Naming_Data.Spec_Suffix :=\n                    File_Name_Type (Suffix.Value);\n+\n+               Check_Illegal_Suffix\n+                 (Project, In_Tree,\n+                  Lang_Id.Config.Naming_Data.Spec_Suffix,\n+                  Lang_Id.Config.Naming_Data.Dot_Replacement,\n+                  \"Spec_Suffix\", Suffix.Location);\n+\n+               Write_Attr\n+                 (\"Spec_Suffix\",\n+                  Get_Name_String (Lang_Id.Config.Naming_Data.Spec_Suffix));\n             end if;\n \n             --  Body_Suffix\n@@ -3325,14 +3207,68 @@ package body Prj.Nmsc is\n \n             if Suffix /= Nil_Variable_Value then\n                Lang_Id.Config.Naming_Data.Body_Suffix :=\n-                   File_Name_Type (Suffix.Value);\n+                 File_Name_Type (Suffix.Value);\n+\n+               --  The default value of separate suffix should be the same as\n+               --  the body suffix, so we need to compute that first.\n+\n+               if Separate_Suffix = No_File then\n+                  Lang_Id.Config.Naming_Data.Separate_Suffix :=\n+                    Lang_Id.Config.Naming_Data.Body_Suffix;\n+                  Write_Attr\n+                    (\"Sep_Suffix\",\n+                     Get_Name_String\n+                       (Lang_Id.Config.Naming_Data.Separate_Suffix));\n+               else\n+                  Lang_Id.Config.Naming_Data.Separate_Suffix :=\n+                    Separate_Suffix;\n+               end if;\n+\n+               Check_Illegal_Suffix\n+                 (Project, In_Tree,\n+                  Lang_Id.Config.Naming_Data.Body_Suffix,\n+                  Lang_Id.Config.Naming_Data.Dot_Replacement,\n+                  \"Body_Suffix\", Suffix.Location);\n+\n+               Write_Attr\n+                 (\"Body_Suffix\",\n+                  Get_Name_String (Lang_Id.Config.Naming_Data.Body_Suffix));\n+\n+            elsif Separate_Suffix /= No_File then\n+               Lang_Id.Config.Naming_Data.Separate_Suffix := Separate_Suffix;\n+            end if;\n+\n+            --  Spec_Suffix cannot be equal to Body_Suffix or Separate_Suffix,\n+            --  since that would cause a clear ambiguity. Note that we do allow\n+            --  a Spec_Suffix to have the same termination as one of these,\n+            --  which causes a potential ambiguity, but we resolve that my\n+            --  matching the longest possible suffix.\n+\n+            if Lang_Id.Config.Naming_Data.Spec_Suffix /= No_File\n+              and then Lang_Id.Config.Naming_Data.Spec_Suffix =\n+                Lang_Id.Config.Naming_Data.Body_Suffix\n+            then\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"Body_Suffix (\"\"\"\n+                  & Get_Name_String (Lang_Id.Config.Naming_Data.Body_Suffix)\n+                  & \"\"\") cannot be the same as Spec_Suffix.\",\n+                  Ada_Body_Suffix_Loc);\n             end if;\n \n-            --  ??? As opposed to what is done in Check_Naming_Ada_Only,\n-            --  we do not check whether spec_suffix=body_suffix, which\n-            --  should be illegal. Best would be to share this code into\n-            --  Check_Common, but we access the attributes from the project\n-            --  files slightly differently apparently.\n+            if Lang_Id.Config.Naming_Data.Body_Suffix /=\n+              Lang_Id.Config.Naming_Data.Separate_Suffix\n+              and then Lang_Id.Config.Naming_Data.Spec_Suffix =\n+                Lang_Id.Config.Naming_Data.Separate_Suffix\n+            then\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"Separate_Suffix (\"\"\"\n+                  & Get_Name_String\n+                    (Lang_Id.Config.Naming_Data.Separate_Suffix)\n+                  & \"\"\") cannot be the same as Spec_Suffix.\",\n+                  Sep_Suffix_Loc);\n+            end if;\n \n             Lang_Id := Lang_Id.Next;\n          end loop;\n@@ -3421,10 +3357,6 @@ package body Prj.Nmsc is\n             else\n                Value := In_Tree.Array_Elements.Table (Specs).Value;\n \n-               if Lang.Name = Name_Ada then\n-                  Ada_Spec_Suffix_Loc := Value.Location;\n-               end if;\n-\n                if Value.Kind = Single then\n                   Lang.Config.Naming_Data.Spec_Suffix :=\n                     Canonical_Case_File_Name (Value.Value);\n@@ -3480,13 +3412,7 @@ package body Prj.Nmsc is\n          end if;\n \n          Initialize_Naming_Data;\n-\n-         case Get_Mode is\n-            when Ada_Only =>\n-               Check_Naming_Ada_Only;\n-            when Multi_Language =>\n-               Check_Naming_Multi_Lang;\n-         end case;\n+         Check_Naming_Multi_Lang;\n       end if;\n    end Check_Package_Naming;\n \n@@ -4981,7 +4907,6 @@ package body Prj.Nmsc is\n                   Name_Len := 0;\n                   Add_Str_To_Name_Buffer\n                     (Get_Name_String (Project.Directory.Name));\n-                  Add_Char_To_Name_Buffer (Directory_Separator);\n                   Add_Str_To_Name_Buffer\n                     (Get_Name_String (Lib_Ref_Symbol_File.Value));\n                   Project.Symbol_Data.Reference := Name_Find;\n@@ -5030,7 +4955,6 @@ package body Prj.Nmsc is\n                                       Normalize_Pathname\n                                         (Get_Name_String\n                                            (Project.Object_Directory.Name) &\n-                                         Directory_Separator &\n                                          Name_Buffer (1 .. Name_Len),\n                                          Directory     => Current_Dir,\n                                          Resolve_Links =>\n@@ -5584,15 +5508,13 @@ package body Prj.Nmsc is\n                else\n                   declare\n                      Path              : constant String :=\n-                                           Get_Name_String (Path_Name.Name) &\n-                                           Directory_Separator;\n+                                           Get_Name_String (Path_Name.Name);\n                      Last_Path         : constant Natural :=\n                                            Compute_Directory_Last (Path);\n                      Path_Id           : Name_Id;\n                      Display_Path      : constant String :=\n                                            Get_Name_String\n-                                             (Path_Name.Display_Name) &\n-                                           Directory_Separator;\n+                                             (Path_Name.Display_Name);\n                      Last_Display_Path : constant Natural :=\n                                            Compute_Directory_Last\n                                              (Display_Path);\n@@ -6006,10 +5928,6 @@ package body Prj.Nmsc is\n       Name_Loc    : Name_Location;\n \n    begin\n-      if Get_Mode = Ada_Only then\n-         Source_Names.Reset;\n-      end if;\n-\n       if Current_Verbosity = High then\n          Write_Str  (\"Opening \"\"\");\n          Write_Str  (Path);\n@@ -6139,7 +6057,7 @@ package body Prj.Nmsc is\n \n       if Last = Filename'Last then\n          if Current_Verbosity = High then\n-            Write_Line (\"   No matching suffix\");\n+            Write_Line (\"     no matching suffix\");\n          end if;\n \n          return;\n@@ -6306,67 +6224,6 @@ package body Prj.Nmsc is\n       end if;\n    end Compute_Unit_Name;\n \n-   --------------\n-   -- Get_Unit --\n-   --------------\n-\n-   procedure Get_Unit\n-     (In_Tree             : Project_Tree_Ref;\n-      Canonical_File_Name : File_Name_Type;\n-      Project             : Project_Id;\n-      Exception_Id        : out Ada_Naming_Exception_Id;\n-      Unit_Name           : out Name_Id;\n-      Unit_Kind           : out Spec_Or_Body)\n-   is\n-      Info_Id  : Ada_Naming_Exception_Id :=\n-                   Ada_Naming_Exceptions.Get (Canonical_File_Name);\n-      VMS_Name : File_Name_Type;\n-      Kind     : Source_Kind;\n-      Lang     : Language_Ptr;\n-\n-   begin\n-      if Info_Id = No_Ada_Naming_Exception\n-        and then Hostparm.OpenVMS\n-      then\n-         VMS_Name := Canonical_File_Name;\n-         Get_Name_String (VMS_Name);\n-\n-         if Name_Buffer (Name_Len) = '.' then\n-            Name_Len := Name_Len - 1;\n-            VMS_Name := Name_Find;\n-         end if;\n-\n-         Info_Id := Ada_Naming_Exceptions.Get (VMS_Name);\n-      end if;\n-\n-      if Info_Id /= No_Ada_Naming_Exception then\n-         Exception_Id := Info_Id;\n-         Unit_Name := No_Name;\n-         Unit_Kind := Spec;\n-\n-      else\n-         Exception_Id := No_Ada_Naming_Exception;\n-         Lang := Get_Language_From_Name (Project, \"ada\");\n-\n-         if Lang = null then\n-            Unit_Name := No_Name;\n-            Unit_Kind := Spec;\n-         else\n-            Compute_Unit_Name\n-              (File_Name => Canonical_File_Name,\n-               Naming    => Lang.Config.Naming_Data,\n-               Kind      => Kind,\n-               Unit      => Unit_Name,\n-               In_Tree   => In_Tree);\n-\n-            case Kind is\n-               when Spec       => Unit_Kind := Spec;\n-               when Impl | Sep => Unit_Kind := Impl;\n-            end case;\n-         end if;\n-      end if;\n-   end Get_Unit;\n-\n    ----------\n    -- Hash --\n    ----------\n@@ -6376,44 +6233,62 @@ package body Prj.Nmsc is\n       return Header_Num (Unit.Unit mod 2048);\n    end Hash;\n \n-   -----------------------\n-   -- Is_Illegal_Suffix --\n-   -----------------------\n+   --------------------------\n+   -- Check_Illegal_Suffix --\n+   --------------------------\n \n-   function Is_Illegal_Suffix\n-     (Suffix          : File_Name_Type;\n-      Dot_Replacement : File_Name_Type) return Boolean\n+   procedure Check_Illegal_Suffix\n+     (Project         : Project_Id;\n+      In_Tree         : Project_Tree_Ref;\n+      Suffix          : File_Name_Type;\n+      Dot_Replacement : File_Name_Type;\n+      Attribute_Name  : String;\n+      Location        : Source_Ptr)\n    is\n       Suffix_Str : constant String := Get_Name_String (Suffix);\n \n    begin\n       if Suffix_Str'Length = 0 then\n-         return False;\n+         --  Always valid\n+         return;\n+\n       elsif Index (Suffix_Str, \".\") = 0 then\n-         return True;\n+         Err_Vars.Error_Msg_File_1 := Suffix;\n+         Error_Msg\n+           (Project, In_Tree,\n+            \"{ is illegal for \" & Attribute_Name & \": must have a dot\",\n+            Location);\n+         return;\n       end if;\n \n       --  Case of dot replacement is a single dot, and first character of\n       --  suffix is also a dot.\n \n-      if Get_Name_String (Dot_Replacement) = \".\"\n+      if Dot_Replacement /= No_File\n+        and then Get_Name_String (Dot_Replacement) = \".\"\n         and then Suffix_Str (Suffix_Str'First) = '.'\n       then\n          for Index in Suffix_Str'First + 1 .. Suffix_Str'Last loop\n \n-            --  Case of following dot\n+            --  If there are multiple dots in the name\n \n             if Suffix_Str (Index) = '.' then\n \n                --  It is illegal to have a letter following the initial dot\n \n-               return Is_Letter (Suffix_Str (Suffix_Str'First + 1));\n+               if Is_Letter (Suffix_Str (Suffix_Str'First + 1)) then\n+                  Err_Vars.Error_Msg_File_1 := Suffix;\n+                  Error_Msg\n+                    (Project, In_Tree,\n+                     \"{ is illegal for \" & Attribute_Name\n+                     & \": ambiguous prefix when Dot_Replacement is a dot\",\n+                     Location);\n+               end if;\n+               return;\n             end if;\n          end loop;\n       end if;\n-\n-      return False;\n-   end Is_Illegal_Suffix;\n+   end Check_Illegal_Suffix;\n \n    ----------------------\n    -- Locate_Directory --\n@@ -6433,7 +6308,7 @@ package body Prj.Nmsc is\n       Parent          : constant Path_Name_Type :=\n                           Project.Directory.Display_Name;\n       The_Parent      : constant String :=\n-                          Get_Name_String (Parent) & Directory_Separator;\n+                          Get_Name_String (Parent);\n       The_Parent_Last : constant Natural :=\n                           Compute_Directory_Last (The_Parent);\n       Full_Name       : File_Name_Type;\n@@ -6560,10 +6435,22 @@ package body Prj.Nmsc is\n             begin\n                Name_Len := Normed'Length;\n                Name_Buffer (1 .. Name_Len) := Normed;\n+\n+               --  Directories should always end with a directory separator\n+\n+               if Name_Buffer (Name_Len) /= Directory_Separator then\n+                  Add_Char_To_Name_Buffer (Directory_Separator);\n+               end if;\n+\n                Path.Display_Name := Name_Find;\n \n                Name_Len := Canonical_Path'Length;\n                Name_Buffer (1 .. Name_Len) := Canonical_Path;\n+\n+               if Name_Buffer (Name_Len) /= Directory_Separator then\n+                  Add_Char_To_Name_Buffer (Directory_Separator);\n+               end if;\n+\n                Path.Name := Name_Find;\n             end;\n          end if;\n@@ -6730,7 +6617,7 @@ package body Prj.Nmsc is\n    procedure Find_Sources\n      (Project                   : Project_Id;\n       In_Tree                   : Project_Tree_Ref;\n-      Proc_Data                 : in out Processing_Data;\n+      File_To_Source           : in out Files_Htable.Instance;\n       Allow_Duplicate_Basenames : Boolean;\n       Excluded                  : in out Excluded_Sources_Htable.Instance)\n    is\n@@ -6775,7 +6662,7 @@ package body Prj.Nmsc is\n             Name     : File_Name_Type;\n \n          begin\n-            if Get_Mode = Multi_Language then\n+--            if Get_Mode = Multi_Language then\n                if Current = Nil_String then\n                   Project.Languages := No_Language_Index;\n \n@@ -6789,7 +6676,7 @@ package body Prj.Nmsc is\n                      Project.Object_Directory := No_Path_Information;\n                   end if;\n                end if;\n-            end if;\n+--            end if;\n \n             while Current /= Nil_String loop\n                Element := In_Tree.String_Elements.Table (Current);\n@@ -6822,17 +6709,11 @@ package body Prj.Nmsc is\n                   end if;\n                end loop;\n \n-               --  In Multi_Language mode, check whether the file is already\n-               --  there: the same file name may be in the list. If the source\n-               --  is missing, the error will be on the first mention of the\n-               --  source file name.\n+               --  Check whether the file is already there: the same file name\n+               --  may be in the list. If the source is missing, the error will\n+               --  be on the first mention of the source file name.\n \n-               case Get_Mode is\n-                  when Ada_Only =>\n-                     Name_Loc := No_Name_Location;\n-                  when Multi_Language =>\n-                     Name_Loc := Source_Names.Get (Name);\n-               end case;\n+               Name_Loc := Source_Names.Get (Name);\n \n                if Name_Loc = No_Name_Location then\n                   Name_Loc :=\n@@ -6890,20 +6771,12 @@ package body Prj.Nmsc is\n          Has_Explicit_Sources := False;\n       end if;\n \n-      if Get_Mode = Ada_Only then\n-         Find_Ada_Sources\n-           (Project, In_Tree,\n-            Explicit_Sources_Only => Has_Explicit_Sources,\n-            Proc_Data             => Proc_Data);\n-\n-      else\n-         Search_Directories\n-           (Project, In_Tree,\n-            For_All_Sources           =>\n-              Sources.Default and then Source_List_File.Default,\n-            Allow_Duplicate_Basenames => Allow_Duplicate_Basenames,\n-            Excluded                  => Excluded);\n-      end if;\n+      Search_Directories\n+        (Project, In_Tree,\n+         File_To_Source  => File_To_Source,\n+         For_All_Sources  => Sources.Default and then Source_List_File.Default,\n+         Allow_Duplicate_Basenames => Allow_Duplicate_Basenames,\n+         Excluded                  => Excluded);\n \n       --  Check if all exceptions have been found. For Ada, it is an error if\n       --  an exception is not found. For other language, the source is simply\n@@ -6937,10 +6810,29 @@ package body Prj.Nmsc is\n                        (Project, In_Tree,\n                         \"source file %% for unit %% not found\",\n                         No_Location);\n+\n+                  else\n+                     --  Set the full path information since we know it\n+                     --  anyway\n+\n+                     Source.Path := Files_Htable.Get\n+                       (File_To_Source, Source.File).Path;\n+\n+                     if Current_Verbosity = High then\n+                        if Source.Path /= No_Path_Information then\n+                           Write_Line (\"Setting full path for \"\n+                                       & Get_Name_String (Source.File)\n+                                       & \" at\" & Source.Index'Img\n+                                       & \" to \"\n+                                       & Get_Name_String (Source.Path.Name));\n+                        end if;\n+                     end if;\n                   end if;\n                end if;\n \n-               Remove_Source (Source, No_Source);\n+               if Source.Path = No_Path_Information then\n+                  Remove_Source (Source, No_Source);\n+               end if;\n             end if;\n \n             Next (Iter);\n@@ -7012,154 +6904,6 @@ package body Prj.Nmsc is\n       Files_Htable.Reset (Proc_Data.Units);\n    end Free;\n \n-   ----------------------\n-   -- Find_Ada_Sources --\n-   ----------------------\n-\n-   procedure Find_Ada_Sources\n-     (Project               : Project_Id;\n-      In_Tree               : Project_Tree_Ref;\n-      Explicit_Sources_Only : Boolean;\n-      Proc_Data             : in out Processing_Data)\n-   is\n-      Source_Dir     : String_List_Id;\n-      Element        : String_Element;\n-      Dir            : Dir_Type;\n-      Dir_Has_Source : Boolean := False;\n-      NL             : Name_Location;\n-      Ada_Language   : Language_Ptr;\n-\n-   begin\n-      if Current_Verbosity = High then\n-         Write_Line (\"Looking for Ada sources:\");\n-      end if;\n-\n-      Ada_Language := Project.Languages;\n-      while Ada_Language /= No_Language_Index\n-        and then Ada_Language.Name /= Name_Ada\n-      loop\n-         Ada_Language := Ada_Language.Next;\n-      end loop;\n-\n-      --  We look in all source directories for the file names in the hash\n-      --  table Source_Names.\n-\n-      Source_Dir := Project.Source_Dirs;\n-      while Source_Dir /= Nil_String loop\n-         Dir_Has_Source := False;\n-         Element := In_Tree.String_Elements.Table (Source_Dir);\n-\n-         declare\n-            Dir_Path : constant String :=\n-                         Get_Name_String (Element.Display_Value) &\n-                           Directory_Separator;\n-            Dir_Last : constant Natural := Compute_Directory_Last (Dir_Path);\n-\n-         begin\n-            if Current_Verbosity = High then\n-               Write_Line (\"checking directory \"\"\" & Dir_Path & \"\"\"\");\n-            end if;\n-\n-            --  Look for all files in the current source directory\n-\n-            Open (Dir, Dir_Path (Dir_Path'First .. Dir_Last));\n-\n-            loop\n-               Read (Dir, Name_Buffer, Name_Len);\n-               exit when Name_Len = 0;\n-\n-               if Current_Verbosity = High then\n-                  Write_Line (\" Checking \" & Name_Buffer (1 .. Name_Len));\n-               end if;\n-\n-               declare\n-                  Name : constant File_Name_Type := Name_Find;\n-                  Canonical_Name : File_Name_Type;\n-\n-                  --  ??? We could probably optimize the following call: we\n-                  --  need to resolve links only once for the directory itself,\n-                  --  and then do a single call to readlink() for each file.\n-                  --  Unfortunately that would require Normalize_Pathname to\n-                  --  be changed so that it has the option of not resolving\n-                  --  links for its Directory parameter, only for Name.\n-\n-                  Path : constant String :=\n-                    Normalize_Pathname\n-                      (Name           => Name_Buffer (1 .. Name_Len),\n-                       Directory      => Dir_Path (Dir_Path'First .. Dir_Last),\n-                       Resolve_Links  => Opt.Follow_Links_For_Files,\n-                       Case_Sensitive => True);  -- no case folding\n-\n-                  Path_Name : Path_Name_Type;\n-                  To_Record : Boolean := False;\n-                  Location  : Source_Ptr;\n-\n-               begin\n-                  --  If the file was listed in the explicit list of sources,\n-                  --  mark it as such (since we'll need to report an error when\n-                  --  an explicit source was not found)\n-\n-                  if Explicit_Sources_Only then\n-                     Canonical_Name :=\n-                       Canonical_Case_File_Name (Name_Id (Name));\n-                     NL := Source_Names.Get (Canonical_Name);\n-                     To_Record := NL /= No_Name_Location and then not NL.Found;\n-\n-                     if To_Record then\n-                        NL.Found := True;\n-                        Location := NL.Location;\n-                        Source_Names.Set (Canonical_Name, NL);\n-                     end if;\n-\n-                  else\n-                     To_Record := True;\n-                     Location  := No_Location;\n-                  end if;\n-\n-                  if To_Record then\n-                     Name_Len := Path'Length;\n-                     Name_Buffer (1 .. Name_Len) := Path;\n-                     Path_Name := Name_Find;\n-\n-                     if Current_Verbosity = High then\n-                        Write_Line (\"  recording \" & Get_Name_String (Name));\n-                     end if;\n-\n-                     --  Register the source if it is an Ada compilation unit\n-\n-                     Record_Ada_Source\n-                       (File_Name       => Name,\n-                        Path_Name       => Path_Name,\n-                        Project         => Project,\n-                        In_Tree         => In_Tree,\n-                        Proc_Data       => Proc_Data,\n-                        Ada_Language    => Ada_Language,\n-                        Location        => Location,\n-                        Source_Recorded => Dir_Has_Source);\n-                  end if;\n-               end;\n-            end loop;\n-\n-            Close (Dir);\n-\n-         exception\n-            when others =>\n-               Close (Dir);\n-               raise;\n-         end;\n-\n-         if Dir_Has_Source then\n-            In_Tree.String_Elements.Table (Source_Dir).Flag := True;\n-         end if;\n-\n-         Source_Dir := Element.Next;\n-      end loop;\n-\n-      if Current_Verbosity = High then\n-         Write_Line (\"End looking for sources\");\n-      end if;\n-   end Find_Ada_Sources;\n-\n    -------------------------------\n    -- Check_File_Naming_Schemes --\n    -------------------------------\n@@ -7328,9 +7072,11 @@ package body Prj.Nmsc is\n    procedure Check_File\n      (Project                   : Project_Id;\n       In_Tree                   : Project_Tree_Ref;\n+      File_To_Source           : in out Files_Htable.Instance;\n       Path                      : Path_Name_Type;\n       File_Name                 : File_Name_Type;\n       Display_File_Name         : File_Name_Type;\n+      Locally_Removed           : Boolean;\n       For_All_Sources           : Boolean;\n       Allow_Duplicate_Basenames : Boolean)\n    is\n@@ -7343,14 +7089,11 @@ package body Prj.Nmsc is\n       Alternate_Languages   : Language_List;\n       Language              : Language_Ptr;\n       Source                : Source_Id;\n-      Add_Src               : Boolean;\n       Src_Ind               : Source_File_Index;\n       Unit                  : Name_Id;\n-      Source_To_Replace     : Source_Id := No_Source;\n       Display_Language_Name : Name_Id;\n       Lang_Kind             : Language_Kind;\n       Kind                  : Source_Kind := Spec;\n-      Iter                  : Source_Iterator;\n \n    begin\n       if Name_Loc = No_Name_Location then\n@@ -7403,6 +7146,8 @@ package body Prj.Nmsc is\n                      Override_Kind (Name_Loc.Source, Sep);\n                   end if;\n                end if;\n+\n+               Files_Htable.Set (File_To_Source, File_Name, Name_Loc.Source);\n             end if;\n          end if;\n       end if;\n@@ -7423,126 +7168,34 @@ package body Prj.Nmsc is\n \n             --  A file name in a list must be a source of a language\n \n-            if Name_Loc.Found then\n-               Error_Msg_File_1 := File_Name;\n-               Error_Msg\n-                 (Project,\n-                  In_Tree,\n-                  \"language unknown for {\",\n-                  Name_Loc.Location);\n+            if Get_Mode = Multi_Language then\n+               if Name_Loc.Found then\n+                  Error_Msg_File_1 := File_Name;\n+                  Error_Msg\n+                    (Project,\n+                     In_Tree,\n+                     \"language unknown for {\",\n+                     Name_Loc.Location);\n+               end if;\n             end if;\n \n          else\n-            --  Check if the same file name or unit is used in the prj tree\n-\n-            Iter := For_Each_Source (In_Tree);\n-            Add_Src := True;\n-            loop\n-               Source := Prj.Element (Iter);\n-               exit when Source = No_Source;\n-\n-               if Unit /= No_Name\n-                 and then Source.Unit /= No_Unit_Index\n-                 and then Source.Unit.Name = Unit\n-                 and then\n-                   ((Source.Kind = Spec and then Kind = Impl)\n-                       or else\n-                    (Source.Kind = Impl and then Kind = Spec))\n-               then\n-                  --  We found the \"other_part (source)\"\n-\n-                  null;\n-\n-               elsif (Unit /= No_Name\n-                      and then Source.Unit /= No_Unit_Index\n-                      and then Source.Unit.Name = Unit\n-                      and then\n-                        (Source.Kind = Kind\n-                           or else\n-                        (Source.Kind = Sep  and then Kind = Impl)\n-                           or else\n-                        (Source.Kind = Impl and then Kind = Sep)))\n-                 or else\n-                   (Unit = No_Name and then Source.File = File_Name)\n-               then\n-                  --  Duplication of file/unit in same project is only allowed\n-                  --  if order of source directories is known.\n-\n-                  if Project = Source.Project then\n-                     if Unit = No_Name then\n-                        if Allow_Duplicate_Basenames then\n-                           Add_Src := True;\n-                        elsif Project.Known_Order_Of_Source_Dirs then\n-                           Add_Src := False;\n-                        else\n-                           Error_Msg_File_1 := File_Name;\n-                           Error_Msg\n-                             (Project, In_Tree, \"duplicate source file name {\",\n-                              No_Location);\n-                           Add_Src := False;\n-                        end if;\n-\n-                     else\n-                        if Project.Known_Order_Of_Source_Dirs then\n-                           Add_Src := False;\n-                        else\n-                           Error_Msg_Name_1 := Unit;\n-                           Error_Msg\n-                             (Project, In_Tree, \"duplicate unit %%\",\n-                              No_Location);\n-                           Add_Src := False;\n-                        end if;\n-                     end if;\n-\n-                     --  Do not allow the same unit name in different projects,\n-                     --  except if one is extending the other.\n-\n-                     --  For a file based language, the same file name replaces\n-                     --  a file in a project being extended, but it is allowed\n-                     --  to have the same file name in unrelated projects.\n-\n-                  elsif Is_Extending (Project, Source.Project) then\n-                     Source_To_Replace := Source;\n-\n-                  elsif Unit /= No_Name\n-                    and then not Source.Locally_Removed\n-                  then\n-                     Error_Msg_Name_1 := Unit;\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"unit %% cannot belong to several projects\",\n-                        No_Location);\n-\n-                     Error_Msg_Name_1 := Project.Name;\n-                     Error_Msg_Name_2 := Name_Id (Path);\n-                     Error_Msg\n-                       (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n-\n-                     Error_Msg_Name_1 := Source.Project.Name;\n-                     Error_Msg_Name_2 := Name_Id (Source.Path.Display_Name);\n-                     Error_Msg\n-                       (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n-\n-                     Add_Src := False;\n-                  end if;\n-               end if;\n-\n-               Next (Iter);\n-            end loop;\n-\n-            if Add_Src then\n-               Add_Source\n-                 (Id                  => Source,\n-                  In_Tree             => In_Tree,\n-                  Project             => Project,\n-                  Lang_Id             => Language,\n-                  Kind                => Kind,\n-                  Alternate_Languages => Alternate_Languages,\n-                  File_Name           => File_Name,\n-                  Display_File        => Display_File_Name,\n-                  Unit                => Unit,\n-                  Path                => (Canonical_Path, Path),\n-                  Source_To_Replace   => Source_To_Replace);\n+            Add_Source\n+              (Id                  => Source,\n+               In_Tree             => In_Tree,\n+               File_To_Source     => File_To_Source,\n+               Project             => Project,\n+               Lang_Id             => Language,\n+               Kind                => Kind,\n+               Allow_Duplicate_Basenames => Allow_Duplicate_Basenames,\n+               Alternate_Languages => Alternate_Languages,\n+               File_Name           => File_Name,\n+               Display_File        => Display_File_Name,\n+               Unit                => Unit,\n+               Path                => (Canonical_Path, Path));\n+\n+            if Source /= No_Source then\n+               Source.Locally_Removed := Locally_Removed;\n             end if;\n          end if;\n       end if;\n@@ -7555,6 +7208,7 @@ package body Prj.Nmsc is\n    procedure Search_Directories\n      (Project                   : Project_Id;\n       In_Tree                   : Project_Tree_Ref;\n+      File_To_Source           : in out Files_Htable.Instance;\n       For_All_Sources           : Boolean;\n       Allow_Duplicate_Basenames : Boolean;\n       Excluded                  : in out Excluded_Sources_Htable.Instance)\n@@ -7644,6 +7298,7 @@ package body Prj.Nmsc is\n                            Path : Path_Name_Type;\n                            FF   : File_Found := Excluded_Sources_Htable.Get\n                                                   (Excluded, File_Name);\n+                           To_Remove : Boolean := False;\n \n                         begin\n                            Name_Len := Path_Name'Length;\n@@ -7661,20 +7316,29 @@ package body Prj.Nmsc is\n                                     Write_Str (Get_Name_String (File_Name));\n                                     Write_Line (\"\"\"\");\n                                  end if;\n-                              end if;\n \n-                           else\n-                              Check_File\n-                                (Project                   => Project,\n-                                 In_Tree                   => In_Tree,\n-                                 Path                      => Path,\n-                                 File_Name                 => File_Name,\n-                                 Display_File_Name         =>\n-                                   Display_File_Name,\n-                                 For_All_Sources           => For_All_Sources,\n-                                 Allow_Duplicate_Basenames =>\n-                                   Allow_Duplicate_Basenames);\n+                                 --  Will mark the file as removed, but we\n+                                 --  still need to add it to the list: if we\n+                                 --  don't, the file will not appear in the\n+                                 --  mapping file and will cause the compiler\n+                                 --  to fail\n+\n+                                 To_Remove := True;\n+                              end if;\n                            end if;\n+\n+                           Check_File\n+                             (Project                   => Project,\n+                              In_Tree                   => In_Tree,\n+                              File_To_Source           => File_To_Source,\n+                              Path                      => Path,\n+                              File_Name                 => File_Name,\n+                              Locally_Removed           => To_Remove,\n+                              Display_File_Name         =>\n+                                Display_File_Name,\n+                              For_All_Sources           => For_All_Sources,\n+                              Allow_Duplicate_Basenames =>\n+                                Allow_Duplicate_Basenames);\n                         end;\n                      end if;\n                   end loop;\n@@ -7881,7 +7545,6 @@ package body Prj.Nmsc is\n \n          Check_Object_File_Names : declare\n             Src_Id      : Source_Id;\n-            Source_Name : File_Name_Type;\n \n             procedure Check_Object (Src : Source_Id);\n             --  Check if object file name of the current source is already in\n@@ -7893,20 +7556,23 @@ package body Prj.Nmsc is\n             ------------------\n \n             procedure Check_Object (Src : Source_Id) is\n+               Source : Source_Id;\n             begin\n-               Source_Name := Object_File_Names.Get (Src.Object);\n+               Source := Object_File_Names.Get (Src.Object);\n \n-               if Source_Name /= No_File then\n+               if Source /= No_Source\n+                 and then Source = Src\n+               then\n                   Error_Msg_File_1 := Src.File;\n-                  Error_Msg_File_2 := Source_Name;\n+                  Error_Msg_File_2 := Source.File;\n                   Error_Msg\n                     (Project,\n                      In_Tree,\n                      \"{ and { have the same object file name\",\n                      No_Location);\n \n                else\n-                  Object_File_Names.Set (Src.Object, Src.File);\n+                  Object_File_Names.Set (Src.Object, Src);\n                end if;\n             end Check_Object;\n \n@@ -7979,18 +7645,14 @@ package body Prj.Nmsc is\n         or else (Get_Mode = Multi_Language\n                   and then Project.Languages /= No_Language_Index)\n       then\n-         if Get_Mode = Multi_Language then\n-            Load_Naming_Exceptions (Project, In_Tree, Excluded_Sources);\n-         end if;\n+         Load_Naming_Exceptions (Project, In_Tree, Excluded_Sources);\n \n          Find_Sources\n-           (Project, In_Tree, Proc_Data, Allow_Duplicate_Basenames,\n+           (Project, In_Tree, Proc_Data.Units, Allow_Duplicate_Basenames,\n             Excluded => Excluded_Sources);\n          Mark_Excluded_Sources;\n \n-         if Get_Mode = Multi_Language then\n-            Process_Sources_In_Multi_Language_Mode;\n-         end if;\n+         Process_Sources_In_Multi_Language_Mode;\n       end if;\n    end Look_For_Sources;\n \n@@ -8025,280 +7687,6 @@ package body Prj.Nmsc is\n       end if;\n    end Path_Name_Of;\n \n-   -----------------------------------\n-   -- Prepare_Ada_Naming_Exceptions --\n-   -----------------------------------\n-\n-   procedure Prepare_Ada_Naming_Exceptions\n-     (List    : Array_Element_Id;\n-      In_Tree : Project_Tree_Ref;\n-      Kind    : Spec_Or_Body)\n-   is\n-      Current : Array_Element_Id;\n-      Element : Array_Element;\n-      Unit    : Unit_Info;\n-\n-   begin\n-      --  Traverse the list\n-\n-      Current := List;\n-      while Current /= No_Array_Element loop\n-         Element := In_Tree.Array_Elements.Table (Current);\n-\n-         if Element.Index /= No_Name then\n-            Unit :=\n-              (Kind => Kind,\n-               Unit => Element.Index,\n-               Next => No_Ada_Naming_Exception);\n-            Reverse_Ada_Naming_Exceptions.Set\n-              (Unit, (Element.Value.Value, Element.Value.Index));\n-            Unit.Next :=\n-              Ada_Naming_Exceptions.Get (File_Name_Type (Element.Value.Value));\n-            Ada_Naming_Exception_Table.Increment_Last;\n-            Ada_Naming_Exception_Table.Table\n-              (Ada_Naming_Exception_Table.Last) := Unit;\n-            Ada_Naming_Exceptions.Set\n-              (File_Name_Type (Element.Value.Value),\n-               Ada_Naming_Exception_Table.Last);\n-         end if;\n-\n-         Current := Element.Next;\n-      end loop;\n-   end Prepare_Ada_Naming_Exceptions;\n-\n-   -----------------------\n-   -- Record_Ada_Source --\n-   -----------------------\n-\n-   procedure Record_Ada_Source\n-     (File_Name       : File_Name_Type;\n-      Path_Name       : Path_Name_Type;\n-      Project         : Project_Id;\n-      In_Tree         : Project_Tree_Ref;\n-      Proc_Data       : in out Processing_Data;\n-      Ada_Language    : Language_Ptr;\n-      Location        : Source_Ptr;\n-      Source_Recorded : in out Boolean)\n-   is\n-      Canonical_File : File_Name_Type;\n-      Canonical_Path : Path_Name_Type;\n-\n-      File_Recorded : Boolean := False;\n-      --  True when at least one file has been recorded\n-\n-      procedure Record_Unit\n-        (Unit_Name    : Name_Id;\n-         Unit_Ind     : Int := 0;\n-         Unit_Kind    : Spec_Or_Body;\n-         Needs_Pragma : Boolean);\n-      --  Register of the units contained in the source file (there is in\n-      --  general a single such unit except when exceptions to the naming\n-      --  scheme indicate there are several such units)\n-\n-      -----------------\n-      -- Record_Unit --\n-      -----------------\n-\n-      procedure Record_Unit\n-        (Unit_Name    : Name_Id;\n-         Unit_Ind     : Int := 0;\n-         Unit_Kind    : Spec_Or_Body;\n-         Needs_Pragma : Boolean)\n-      is\n-         UData : constant Unit_Index :=\n-                   Units_Htable.Get (In_Tree.Units_HT, Unit_Name);\n-         --  ??? Add_Source will look it up again, can we do that only once ?\n-\n-         Source       : Source_Id;\n-         To_Record    : Boolean := False;\n-         The_Location : Source_Ptr := Location;\n-         Unit_Prj     : Project_Id;\n-\n-      begin\n-         if Current_Verbosity = High then\n-            Write_Str  (\"   Putting \");\n-            Write_Str  (Get_Name_String (Unit_Name));\n-            Write_Line (\" in the unit list.\");\n-         end if;\n-\n-         --  The unit is already in the list, but may be it is only the other\n-         --  unit kind (spec or body), or what is in the unit list is a unit of\n-         --  a project we are extending.\n-\n-         if UData /= No_Unit_Index then\n-            if UData.File_Names (Unit_Kind) = null\n-              or else\n-                (UData.File_Names (Unit_Kind).File = Canonical_File\n-                  and then UData.File_Names (Unit_Kind).Locally_Removed)\n-              or else Is_Extending\n-                (Project.Extends, UData.File_Names (Unit_Kind).Project)\n-            then\n-               To_Record       := True;\n-\n-            --  If the same file is already in the list, do not add it again\n-\n-            elsif UData.File_Names (Unit_Kind).Project = Project\n-              and then\n-                (Project.Known_Order_Of_Source_Dirs\n-                  or else\n-                    UData.File_Names (Unit_Kind).Path.Name = Canonical_Path)\n-            then\n-               To_Record := False;\n-\n-            --  Else, same unit but not same file => It is an error to have two\n-            --  units with the same name and the same kind (spec or body).\n-\n-            else\n-               if The_Location = No_Location then\n-                  The_Location := Project.Location;\n-               end if;\n-\n-               Err_Vars.Error_Msg_Name_1 := Unit_Name;\n-               Error_Msg\n-                 (Project, In_Tree, \"duplicate unit %%\", The_Location);\n-\n-               Err_Vars.Error_Msg_Name_1 :=\n-                 UData.File_Names (Unit_Kind).Project.Name;\n-               Err_Vars.Error_Msg_File_1 :=\n-                 File_Name_Type (UData.File_Names (Unit_Kind).Path.Name);\n-               Error_Msg\n-                 (Project, In_Tree, \"\\   project file %%, {\", The_Location);\n-\n-               Err_Vars.Error_Msg_Name_1 := Project.Name;\n-               Err_Vars.Error_Msg_File_1 := File_Name_Type (Canonical_Path);\n-               Error_Msg\n-                 (Project, In_Tree, \"\\   project file %%, {\", The_Location);\n-\n-               To_Record := False;\n-            end if;\n-\n-         --  It is a new unit, create a new record\n-\n-         else\n-            --  First, check if there is no other unit with this file name in\n-            --  another project. If it is, report error but note we do that\n-            --  only for the first unit in the source file.\n-\n-            Unit_Prj := Files_Htable.Get (Proc_Data.Units, Canonical_File);\n-\n-            if not File_Recorded\n-              and then Unit_Prj /= No_Project\n-            then\n-               Error_Msg_File_1 := File_Name;\n-               Error_Msg_Name_1 := Unit_Prj.Name;\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"{ is already a source of project %%\",\n-                  Location);\n-\n-            else\n-               To_Record := True;\n-            end if;\n-         end if;\n-\n-         if To_Record then\n-            Files_Htable.Set (Proc_Data.Units, Canonical_File, Project);\n-            Add_Source\n-              (Id               => Source,\n-               In_Tree          => In_Tree,\n-               Project          => Project,\n-               Lang_Id          => Ada_Language,\n-               File_Name        => Canonical_File,\n-               Display_File     => File_Name,\n-               Unit             => Unit_Name,\n-               Path             => (Canonical_Path, Path_Name),\n-               Naming_Exception => Needs_Pragma,\n-               Kind             => Unit_Kind,\n-               Index            => Unit_Ind);\n-            Source_Recorded := True;\n-         end if;\n-      end Record_Unit;\n-\n-      Exception_Id : Ada_Naming_Exception_Id;\n-      Unit_Name    : Name_Id;\n-      Unit_Kind    : Spec_Or_Body;\n-      Unit_Ind     : Int := 0;\n-      Info         : Unit_Info;\n-      Name_Index   : Name_And_Index;\n-      Except_Name  : Name_And_Index := No_Name_And_Index;\n-      Needs_Pragma : Boolean;\n-\n-   begin\n-      Canonical_File := Canonical_Case_File_Name (Name_Id (File_Name));\n-      Canonical_Path :=\n-        Path_Name_Type (Canonical_Case_File_Name (Name_Id (Path_Name)));\n-\n-      --  Check the naming scheme to get extra file properties\n-\n-      Get_Unit\n-        (In_Tree             => In_Tree,\n-         Canonical_File_Name => Canonical_File,\n-         Project             => Project,\n-         Exception_Id        => Exception_Id,\n-         Unit_Name           => Unit_Name,\n-         Unit_Kind           => Unit_Kind);\n-\n-      Needs_Pragma := Exception_Id /= No_Ada_Naming_Exception;\n-\n-      if Exception_Id = No_Ada_Naming_Exception\n-        and then Unit_Name = No_Name\n-      then\n-         if Current_Verbosity = High then\n-            Write_Str  (\"   \"\"\");\n-            Write_Str  (Get_Name_String (Canonical_File));\n-            Write_Line (\"\"\" is not a valid source file name (ignored).\");\n-         end if;\n-         return;\n-      end if;\n-\n-      --  Check to see if the source has been hidden by an exception,\n-      --  but only if it is not an exception.\n-\n-      if not Needs_Pragma then\n-         Except_Name :=\n-           Reverse_Ada_Naming_Exceptions.Get\n-             ((Unit_Kind, Unit_Name, No_Ada_Naming_Exception));\n-\n-         if Except_Name /= No_Name_And_Index then\n-            if Current_Verbosity = High then\n-               Write_Str  (\"   \"\"\");\n-               Write_Str  (Get_Name_String (Canonical_File));\n-               Write_Str  (\"\"\" contains a unit that is found in \"\"\");\n-               Write_Str  (Get_Name_String (Except_Name.Name));\n-               Write_Line (\"\"\" (ignored).\");\n-            end if;\n-\n-            --  The file is not included in the source of the project since it\n-            --  is hidden by the exception. So, nothing else to do.\n-\n-            return;\n-         end if;\n-      end if;\n-\n-      --  The following loop registers the unit in the appropriate table. It\n-      --  will be executed multiple times when the file is a multi-unit file,\n-      --  in which case Exception_Id initially points to the first file and\n-      --  then to each other unit in the file.\n-\n-      loop\n-         if Exception_Id /= No_Ada_Naming_Exception then\n-            Info := Ada_Naming_Exception_Table.Table (Exception_Id);\n-            Exception_Id := Info.Next;\n-            Info.Next := No_Ada_Naming_Exception;\n-            Name_Index := Reverse_Ada_Naming_Exceptions.Get (Info);\n-\n-            Unit_Name := Info.Unit;\n-            Unit_Ind  := Name_Index.Index;\n-            Unit_Kind := Info.Kind;\n-         end if;\n-\n-         Record_Unit (Unit_Name, Unit_Ind, Unit_Kind, Needs_Pragma);\n-         File_Recorded := True;\n-\n-         exit when Exception_Id = No_Ada_Naming_Exception;\n-      end loop;\n-   end Record_Ada_Source;\n-\n    -------------------\n    -- Remove_Source --\n    -------------------\n@@ -8312,7 +7700,7 @@ package body Prj.Nmsc is\n    begin\n       if Current_Verbosity = High then\n          Write_Str (\"Removing source \");\n-         Write_Line (Get_Name_String (Id.File));\n+         Write_Line (Get_Name_String (Id.File) & \" at\" & Id.Index'Img);\n       end if;\n \n       if Replaced_By /= No_Source then"}, {"sha": "e5ebbcc8bdc178de28295c8b33f23d92b0b8ac58", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -83,6 +83,6 @@ private package Prj.Nmsc is\n private\n    type Processing_Data is record\n       Units : Files_Htable.Instance;\n-      --  Mapping from file base name to the project containing the file\n+      --  Mapping from file base name to the Source_Id of the file\n    end record;\n end Prj.Nmsc;"}, {"sha": "fa85c8cf37a209487eaeb17a1005299aa48088af", "filename": "gcc/ada/prj-pars.adb", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-pars.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-pars.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -27,9 +27,9 @@ with Ada.Exceptions; use Ada.Exceptions;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n \n with Output;   use Output;\n+with Prj.Conf; use Prj.Conf;\n with Prj.Err;  use Prj.Err;\n with Prj.Part;\n-with Prj.Proc;\n with Prj.Tree; use Prj.Tree;\n with Sinput.P;\n \n@@ -46,15 +46,15 @@ package body Prj.Pars is\n       Packages_To_Check : String_List_Access := All_Packages;\n       When_No_Sources   : Error_Warning := Error;\n       Report_Error      : Put_Line_Access := null;\n-      Reset_Tree        : Boolean := True;\n-      Is_Config_File    : Boolean := False)\n+      Reset_Tree        : Boolean := True)\n    is\n       Project_Node      : Project_Node_Id := Empty_Node;\n       The_Project       : Project_Id      := No_Project;\n       Success           : Boolean         := True;\n       Current_Dir       : constant String := Get_Current_Dir;\n       Project_Node_Tree : Prj.Tree.Project_Node_Tree_Ref;\n-\n+      Automatically_Generated : Boolean;\n+      Config_File_Path        : String_Access;\n    begin\n       Project_Node_Tree := new Project_Node_Tree_Data;\n       Prj.Tree.Initialize (Project_Node_Tree);\n@@ -69,22 +69,42 @@ package body Prj.Pars is\n          Always_Errout_Finalize => False,\n          Packages_To_Check      => Packages_To_Check,\n          Current_Directory      => Current_Dir,\n-         Is_Config_File         => Is_Config_File);\n+         Is_Config_File         => False);\n \n       --  If there were no error, process the tree\n \n       if Project_Node /= Empty_Node then\n-         Prj.Proc.Process\n-           (In_Tree                => In_Tree,\n-            Project                => The_Project,\n-            Success                => Success,\n-            From_Project_Node      => Project_Node,\n-            From_Project_Node_Tree => Project_Node_Tree,\n-            Report_Error           => Report_Error,\n-            Reset_Tree             => Reset_Tree,\n-            When_No_Sources        => When_No_Sources,\n-            Current_Dir            => Current_Dir,\n-            Is_Config_File         => Is_Config_File);\n+         begin\n+            --  No config file should be read from the disk for gnatmake.\n+            --  However, we will simulate one that only contains the\n+            --  default GNAT naming scheme.\n+\n+            Process_Project_And_Apply_Config\n+              (Main_Project               => The_Project,\n+               User_Project_Node          => Project_Node,\n+               Config_File_Name           => \"\",\n+               Autoconf_Specified         => False,\n+               Project_Tree               => In_Tree,\n+               Project_Node_Tree          => Project_Node_Tree,\n+               Packages_To_Check          => null,\n+               Allow_Automatic_Generation => False,\n+               Automatically_Generated    => Automatically_Generated,\n+               Config_File_Path           => Config_File_Path,\n+               Report_Error               => Report_Error,\n+               Normalized_Hostname        => \"\",\n+               Compiler_Driver_Mandatory  => False,\n+               Allow_Duplicate_Basenames  => False,\n+               On_Load_Config             =>\n+                 Add_Default_GNAT_Naming_Scheme'Access,\n+               Reset_Tree                 => Reset_Tree,\n+               When_No_Sources            => When_No_Sources);\n+\n+            Success := The_Project /= No_Project;\n+\n+         exception\n+            when Invalid_Config =>\n+               Success := False;\n+         end;\n \n          Prj.Err.Finalize;\n "}, {"sha": "2494dcb091771de9a5a67d27e7282a46e08a7a1d", "filename": "gcc/ada/prj-pars.ads", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-pars.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-pars.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.ads?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -37,8 +37,7 @@ package Prj.Pars is\n       Packages_To_Check : String_List_Access := All_Packages;\n       When_No_Sources   : Error_Warning := Error;\n       Report_Error      : Prj.Put_Line_Access := null;\n-      Reset_Tree        : Boolean := True;\n-      Is_Config_File    : Boolean := False);\n+      Reset_Tree        : Boolean := True);\n    --  Parse and process a project files and all its imported project files, in\n    --  the project tree In_Tree.\n    --  All the project files are parsed (through Prj.Tree) to create a tree in\n@@ -62,8 +61,5 @@ package Prj.Pars is\n    --\n    --  When Reset_Tree is True, all the project data are removed from the\n    --  project table before processing.\n-   --\n-   --  Is_Config_File should be set to True if the project represents a config\n-   --  file (.cgpr) since some specific checks apply.\n \n end Prj.Pars;"}, {"sha": "c411f2f6f6e075265484addba45c5bbdb5607ea5", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 18, "deletions": 74, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -214,12 +214,6 @@ package body Prj.Part is\n    --  Returns the path name of a project file. Returns an empty string\n    --  if project file cannot be found.\n \n-   function Immediate_Directory_Of\n-     (Path_Name : Path_Name_Type) return Path_Name_Type;\n-   --  Get the directory of the file with the specified path name.\n-   --  This includes the directory separator as the last character.\n-   --  Returns \"./\" if Path_Name contains no directory separator.\n-\n    function Project_Name_From\n      (Path_Name      : String;\n       Is_Config_File : Boolean) return Name_Id;\n@@ -249,10 +243,6 @@ package body Prj.Part is\n       --  Fake path name of the virtual extending project. The directory is\n       --  the same directory as the extending all project.\n \n-      Virtual_Dir_Id  : constant Path_Name_Type :=\n-        Immediate_Directory_Of (Path_Name_Of (Main_Project, In_Tree));\n-      --  The directory of the extending all project\n-\n       --  The source of the virtual extending project is something like:\n \n       --  project V$<project name> extends <project path> is\n@@ -266,15 +256,11 @@ package body Prj.Part is\n \n       --  Nodes that made up the virtual extending project\n \n-      Virtual_Project         : constant Project_Node_Id :=\n-                                  Default_Project_Node\n-                                    (In_Tree, N_Project);\n+      Virtual_Project         : Project_Node_Id;\n       With_Clause             : constant Project_Node_Id :=\n                                   Default_Project_Node\n                                     (In_Tree, N_With_Clause);\n-      Project_Declaration     : constant Project_Node_Id :=\n-                                  Default_Project_Node\n-                                    (In_Tree, N_Project_Declaration);\n+      Project_Declaration     : Project_Node_Id;\n       Source_Dirs_Declaration : constant Project_Node_Id :=\n                                   Default_Project_Node\n                                     (In_Tree, N_Declarative_Item);\n@@ -292,12 +278,6 @@ package body Prj.Part is\n                                     (In_Tree, N_Literal_String_List, List);\n \n    begin\n-      --  Get the virtual name id\n-\n-      Name_Len := Virtual_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := Virtual_Name;\n-      Virtual_Name_Id := Name_Find;\n-\n       --  Get the virtual path name\n \n       Get_Name_String (Path_Name_Of (Main_Project, In_Tree));\n@@ -314,6 +294,20 @@ package body Prj.Part is\n       Name_Len := Name_Len + Virtual_Name'Length;\n       Virtual_Path_Id := Name_Find;\n \n+      --  Get the virtual name id\n+\n+      Name_Len := Virtual_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Virtual_Name;\n+      Virtual_Name_Id := Name_Find;\n+\n+      Virtual_Project := Create_Project\n+        (In_Tree        => In_Tree,\n+         Name           => Virtual_Name_Id,\n+         Full_Path      => Virtual_Path_Id,\n+         Is_Config_File => False);\n+\n+      Project_Declaration := Project_Declaration_Of (Virtual_Project, In_Tree);\n+\n       --  With clause\n \n       Set_Name_Of (With_Clause, In_Tree, Virtual_Name_Id);\n@@ -325,13 +319,8 @@ package body Prj.Part is\n \n       --  Virtual project node\n \n-      Set_Name_Of (Virtual_Project, In_Tree, Virtual_Name_Id);\n-      Set_Path_Name_Of (Virtual_Project, In_Tree, Virtual_Path_Id);\n       Set_Location_Of\n         (Virtual_Project, In_Tree, Location_Of (Main_Project, In_Tree));\n-      Set_Directory_Of (Virtual_Project, In_Tree, Virtual_Dir_Id);\n-      Set_Project_Declaration_Of\n-        (Virtual_Project, In_Tree, Project_Declaration);\n       Set_Extended_Project_Path_Of\n         (Virtual_Project, In_Tree, Path_Name_Of (For_Project, In_Tree));\n \n@@ -361,54 +350,8 @@ package body Prj.Part is\n       Set_Current_Term (Source_Dirs_Term, In_Tree, Source_Dirs_List);\n \n       --  Source_Dirs empty list: nothing to do\n-\n-      --  Put virtual project into Projects_Htable\n-\n-      Prj.Tree.Tree_Private_Part.Projects_Htable.Set\n-        (T => In_Tree.Projects_HT,\n-         K => Virtual_Name_Id,\n-         E => (Name           => Virtual_Name_Id,\n-               Node           => Virtual_Project,\n-               Canonical_Path => No_Path,\n-               Extended       => False,\n-               Proj_Qualifier => Unspecified));\n    end Create_Virtual_Extending_Project;\n \n-   ----------------------------\n-   -- Immediate_Directory_Of --\n-   ----------------------------\n-\n-   function Immediate_Directory_Of\n-     (Path_Name : Path_Name_Type) return Path_Name_Type\n-   is\n-   begin\n-      Get_Name_String (Path_Name);\n-\n-      for Index in reverse 1 .. Name_Len loop\n-         if Name_Buffer (Index) = '/'\n-           or else Name_Buffer (Index) = Dir_Sep\n-         then\n-            --  Remove all chars after last directory separator from name\n-\n-            if Index > 1 then\n-               Name_Len := Index - 1;\n-\n-            else\n-               Name_Len := Index;\n-            end if;\n-\n-            return Name_Find;\n-         end if;\n-      end loop;\n-\n-      --  There is no directory separator in name. Return \"./\" or \".\\\"\n-\n-      Name_Len := 2;\n-      Name_Buffer (1) := '.';\n-      Name_Buffer (2) := Dir_Sep;\n-      return Name_Find;\n-   end Immediate_Directory_Of;\n-\n    -----------------------------------\n    -- Look_For_Virtual_Projects_For --\n    -----------------------------------\n@@ -1167,7 +1110,8 @@ package body Prj.Part is\n          Write_Eol;\n       end if;\n \n-      Project_Directory := Immediate_Directory_Of (Normed_Path_Name);\n+      Project_Directory := Path_Name_Type\n+        (Get_Directory (File_Name_Type (Normed_Path_Name)));\n \n       --  Is there any imported project?\n "}, {"sha": "ff5347239c083810a896c2dd3b099ec90216b688", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,6 +24,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Deallocation;\n+with Osint;                        use Osint;\n with Prj.Err;\n \n package body Prj.Tree is\n@@ -2820,4 +2821,45 @@ package body Prj.Tree is\n       return Unkept_Comments;\n    end There_Are_Unkept_Comments;\n \n+   --------------------\n+   -- Create_Project --\n+   --------------------\n+\n+   function Create_Project\n+     (In_Tree        : Project_Node_Tree_Ref;\n+      Name           : Name_Id;\n+      Full_Path      : Path_Name_Type;\n+      Is_Config_File : Boolean := False) return Project_Node_Id\n+   is\n+      Project   : Project_Node_Id;\n+      Qualifier : Project_Qualifier := Unspecified;\n+   begin\n+      Project := Default_Project_Node (In_Tree, N_Project);\n+      Set_Name_Of (Project, In_Tree, Name);\n+      Set_Directory_Of\n+        (Project, In_Tree,\n+         Path_Name_Type (Get_Directory (File_Name_Type (Full_Path))));\n+      Set_Path_Name_Of (Project, In_Tree, Full_Path);\n+\n+      Set_Project_Declaration_Of\n+        (Project, In_Tree,\n+         Default_Project_Node (In_Tree, N_Project_Declaration));\n+\n+      if Is_Config_File then\n+         Qualifier := Configuration;\n+      end if;\n+\n+      Prj.Tree.Tree_Private_Part.Projects_Htable.Set\n+        (In_Tree.Projects_HT,\n+         Name,\n+         Prj.Tree.Tree_Private_Part.Project_Name_And_Node'\n+         (Name           => Name,\n+          Canonical_Path => No_Path, --  ??? in GPS: Path_Name_Type (Name),\n+          Node           => Project,\n+          Extended       => False,\n+          Proj_Qualifier => Qualifier));\n+\n+      return Project;\n+   end Create_Project;\n+\n end Prj.Tree;"}, {"sha": "3f62d7934cb024c6bd3a3c879f2e9d203039e5e2", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -92,11 +92,11 @@ package Prj.Tree is\n \n    function Present (Node : Project_Node_Id) return Boolean;\n    pragma Inline (Present);\n-   --  Return True iff Node /= Empty_Node\n+   --  Return True if Node /= Empty_Node\n \n    function No (Node : Project_Node_Id) return Boolean;\n    pragma Inline (No);\n-   --  Return True iff Node = Empty_Node\n+   --  Return True if Node = Empty_Node\n \n    procedure Initialize (Tree : Project_Node_Tree_Ref);\n    --  Initialize the Project File tree: empty the Project_Nodes table\n@@ -108,6 +108,15 @@ package Prj.Tree is\n       And_Expr_Kind : Variable_Kind := Undefined) return Project_Node_Id;\n    --  Returns a Project_Node_Record with the specified Kind and Expr_Kind. All\n    --  the other components have default nil values.\n+   --  To create a node for a project itself, see Create_Project below instead\n+\n+   function Create_Project\n+     (In_Tree        : Project_Node_Tree_Ref;\n+      Name           : Name_Id;\n+      Full_Path      : Path_Name_Type;\n+      Is_Config_File : Boolean := False) return Project_Node_Id;\n+   --  Create a new node for a project and register it in the tree so that it\n+   --  can be retrieved later on\n \n    function Hash (N : Project_Node_Id) return Header_Num;\n    --  Used for hash tables where the key is a Project_Node_Id\n@@ -285,7 +294,9 @@ package Prj.Tree is\n      (Node    : Project_Node_Id;\n       In_Tree : Project_Node_Tree_Ref) return Path_Name_Type;\n    pragma Inline (Directory_Of);\n-   --  Only valid for N_Project nodes\n+   --  Only valid for N_Project nodes.\n+   --  Returns the directory that contains the project file. This always\n+   --  ends with a directory separator\n \n    function Expression_Kind_Of\n      (Node    : Project_Node_Id;"}, {"sha": "f9aca9278c1e7dd52b263456e48f4ddab58b8455", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -476,7 +476,8 @@ package body Prj is\n    function Find_Source\n      (In_Tree          : Project_Tree_Ref;\n       Project          : Project_Id;\n-      In_Imported_Only : Boolean;\n+      In_Imported_Only : Boolean := False;\n+      In_Extended_Only : Boolean := False;\n       Base_Name        : File_Name_Type) return Source_Id\n    is\n       Result : Source_Id  := No_Source;\n@@ -506,10 +507,21 @@ package body Prj is\n       procedure For_Imported_Projects is new For_Every_Project_Imported\n         (State => Source_Id, Action => Look_For_Sources);\n \n+      Proj : Project_Id;\n+\n    --  Start of processing for Find_Source\n \n    begin\n-      if In_Imported_Only then\n+      if In_Extended_Only then\n+         Proj := Project;\n+         while Proj /= No_Project loop\n+            Look_For_Sources (Proj, Result);\n+            exit when Result /= No_Source;\n+\n+            Proj := Proj.Extends;\n+         end loop;\n+\n+      elsif In_Imported_Only then\n          Look_For_Sources (Project, Result);\n \n          if Result = No_Source then"}, {"sha": "9d1dec2d56c941be34f160b69b62f3cc65f31c00", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2c32e2a1de9332cf7dbe90f7bd7600945999c3/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=fc2c32e2a1de9332cf7dbe90f7bd7600945999c3", "patch": "@@ -145,6 +145,7 @@ package Prj is\n       Name         : Path_Name_Type := No_Path;\n       Display_Name : Path_Name_Type := No_Path;\n    end record;\n+   --  Directory names always end with a directory separator\n \n    No_Path_Information : constant Path_Information := (No_Path, No_Path);\n \n@@ -1269,8 +1270,8 @@ package Prj is\n \n    package Files_Htable is new Simple_HTable\n      (Header_Num => Header_Num,\n-      Element    => Project_Id,\n-      No_Element => No_Project,\n+      Element    => Source_Id,\n+      No_Element => No_Source,\n       Key        => File_Name_Type,\n       Hash       => Hash,\n       Equal      => \"=\");\n@@ -1298,11 +1299,13 @@ package Prj is\n    function Find_Source\n      (In_Tree          : Project_Tree_Ref;\n       Project          : Project_Id;\n-      In_Imported_Only : Boolean;\n+      In_Imported_Only : Boolean := False;\n+      In_Extended_Only : Boolean := False;\n       Base_Name        : File_Name_Type) return Source_Id;\n    --  Find the first source file with the given name either in the whole tree\n    --  (if In_Imported_Only is False) or in the projects imported or extended\n-   --  by Project otherwise.\n+   --  by Project otherwise. In_Extended_Only implies In_Imported_Only, and\n+   --  will only look in Project and the projects it extends\n \n    -----------------------\n    -- Project_Tree_Data --"}]}