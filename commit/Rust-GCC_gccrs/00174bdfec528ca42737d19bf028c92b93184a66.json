{"sha": "00174bdfec528ca42737d19bf028c92b93184a66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAxNzRiZGZlYzUyOGNhNDI3MzdkMTliZjAyOGM5MmI5MzE4NGE2Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-11T16:36:56Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-09-11T16:36:56Z"}, "message": "* integrate.c: Fix formatting.\n\nFrom-SVN: r36319", "tree": {"sha": "01bd2a7d279da2bf60144ad3b45480d822bc4e30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01bd2a7d279da2bf60144ad3b45480d822bc4e30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00174bdfec528ca42737d19bf028c92b93184a66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00174bdfec528ca42737d19bf028c92b93184a66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00174bdfec528ca42737d19bf028c92b93184a66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00174bdfec528ca42737d19bf028c92b93184a66/comments", "author": null, "committer": null, "parents": [{"sha": "181d2ba0f3e7066f11abc08cf01f1d226eee2c85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181d2ba0f3e7066f11abc08cf01f1d226eee2c85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/181d2ba0f3e7066f11abc08cf01f1d226eee2c85"}], "stats": {"total": 158, "additions": 80, "deletions": 78}, "files": [{"sha": "ec9d5014d1f60a76596f95539aac1845cbfdb791", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00174bdfec528ca42737d19bf028c92b93184a66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00174bdfec528ca42737d19bf028c92b93184a66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00174bdfec528ca42737d19bf028c92b93184a66", "patch": "@@ -1,3 +1,7 @@\n+2000-09-11  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* integrate.c: Fix formatting.\n+\n 2000-09-11  Geoff Keating  <geoffk@cygnus.com>\n \n \t* alias.c (memrefs_conflict_p): An ADDRESSOF does conflict, sorry."}, {"sha": "70666750119546d8616185dad11e88243ccd159d", "filename": "gcc/integrate.c", "status": "modified", "additions": 76, "deletions": 78, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00174bdfec528ca42737d19bf028c92b93184a66/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00174bdfec528ca42737d19bf028c92b93184a66/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=00174bdfec528ca42737d19bf028c92b93184a66", "patch": "@@ -20,7 +20,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n \n@@ -63,7 +62,7 @@ extern struct obstack *function_maybepermanent_obstack;\n    : (8 * (8 + list_length (DECL_ARGUMENTS (DECL)))))\n #endif\n \n-/* Decide whether a function with a target specific attribute \n+/* Decide whether a function with a target specific attribute\n    attached can be inlined.  By default we disallow this.  */\n #ifndef FUNCTION_ATTRIBUTE_INLINABLE_P\n #define FUNCTION_ATTRIBUTE_INLINABLE_P(FNDECL) 0\n@@ -118,7 +117,7 @@ get_label_from_map (map, i)\n   rtx x = map->label_map[i];\n \n   if (x == NULL_RTX)\n-    x = map->label_map[i] = gen_label_rtx();\n+    x = map->label_map[i] = gen_label_rtx ();\n \n   return x;\n }\n@@ -316,7 +315,7 @@ initialize_for_inline (fndecl)\n }\n \n /* Copy NODE (which must be a DECL, but not a PARM_DECL).  The DECL\n-   originally was in the FROM_FN, but now it will be in the \n+   originally was in the FROM_FN, but now it will be in the\n    TO_FN.  */\n \n tree\n@@ -363,7 +362,7 @@ copy_decl_for_inlining (decl, from_fn, to_fn)\n   /* Set the context for the new declaration.  */\n   if (!DECL_CONTEXT (decl))\n     /* Globals stay global.  */\n-\t;\n+    ;\n   else if (DECL_CONTEXT (decl) != from_fn)\n     /* Things that weren't in the scope of the function we're inlining\n        from aren't in the scope we're inlining too, either.  */\n@@ -469,8 +468,8 @@ save_for_inline_nocopy (fndecl)\n \n static void\n save_parm_insns (insn, first_nonparm_insn)\n-    rtx insn;\n-    rtx first_nonparm_insn;\n+     rtx insn;\n+     rtx first_nonparm_insn;\n {\n   if (insn == NULL_RTX)\n     return;\n@@ -487,7 +486,7 @@ save_parm_insns (insn, first_nonparm_insn)\n \n \t  /* If this is a CALL_PLACEHOLDER insn then we need to look into the\n \t     three attached sequences: normal call, sibling call and tail\n-\t     recursion. */\n+\t     recursion.  */\n \t  if (GET_CODE (insn) == CALL_INSN\n \t      && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n \t    {\n@@ -560,9 +559,9 @@ process_reg_param (map, loc, copy)\n /* Used by duplicate_eh_handlers to map labels for the exception table */\n static struct inline_remap *eif_eh_map;\n \n-static rtx \n+static rtx\n expand_inline_function_eh_labelmap (label)\n-   rtx label;\n+     rtx label;\n {\n   int index = CODE_LABEL_NUMBER (label);\n   return get_label_from_map (eif_eh_map, index);\n@@ -579,7 +578,7 @@ compare_blocks (v1, v2)\n   tree b1 = *((const tree *) v1);\n   tree b2 = *((const tree *) v2);\n \n-  return ((char *) BLOCK_ABSTRACT_ORIGIN (b1) \n+  return ((char *) BLOCK_ABSTRACT_ORIGIN (b1)\n \t  - (char *) BLOCK_ABSTRACT_ORIGIN (b2));\n }\n \n@@ -777,7 +776,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \tmark_reg_pointer (arg_vals[i],\n \t\t\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (formal))));\n     }\n-\t\n+\n   /* Allocate the structures we use to remap things.  */\n \n   map = (struct inline_remap *) xmalloc (sizeof (struct inline_remap));\n@@ -985,7 +984,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  if (! structure_value_addr\n \t      || ! aggregate_value_p (DECL_RESULT (fndecl)))\n \t    abort ();\n-  \n+\n \t  /* Pass the function the address in which to return a structure\n \t     value.  Note that a constructor can cause someone to call us\n \t     with STRUCTURE_VALUE_ADDR, but the initialization takes place\n@@ -1051,7 +1050,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t{\n \t  /* Don't make BLKmode registers.  If this looks like\n \t     a BLKmode object being returned in a register, get\n-\t     the mode from that, otherwise abort. */\n+\t     the mode from that, otherwise abort.  */\n \t  if (departing_mode == BLKmode)\n \t    {\n \t      if (REG == GET_CODE (DECL_RTL (DECL_RESULT (fndecl))))\n@@ -1060,10 +1059,10 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t\t  arriving_mode = departing_mode;\n \t\t}\n \t      else\n-\t\tabort();\n+\t\tabort ();\n \t    }\n-\t      \n-\ttarget = gen_reg_rtx (departing_mode);\n+\n+\t  target = gen_reg_rtx (departing_mode);\n \t}\n \n       /* If function's value was promoted before return,\n@@ -1100,7 +1099,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   /* Initialize label_map.  get_label_from_map will actually make\n      the labels.  */\n-  bzero ((char *) &map->label_map [min_labelno],\n+  bzero ((char *) &map->label_map[min_labelno],\n \t (max_labelno - min_labelno) * sizeof (rtx));\n \n   /* Make copies of the decls of the symbols in the inline function, so that\n@@ -1119,7 +1118,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   /* Sort the block-map so that it will be easy to find remapped\n      blocks later.  */\n-  qsort (&VARRAY_TREE (map->block_map, 0), \n+  qsort (&VARRAY_TREE (map->block_map, 0),\n \t map->block_map->elements_used,\n \t sizeof (tree),\n \t compare_blocks);\n@@ -1156,7 +1155,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n     insert_block (block);\n   else\n     {\n-      BLOCK_CHAIN (block) \n+      BLOCK_CHAIN (block)\n \t= BLOCK_CHAIN (DECL_INITIAL (current_function_decl));\n       BLOCK_CHAIN (DECL_INITIAL (current_function_decl)) = block;\n     }\n@@ -1180,12 +1179,12 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   emit_line_note (input_filename, lineno);\n \n   /* If the function returns a BLKmode object in a register, copy it\n-     out of the temp register into a BLKmode memory object. */\n-  if (target \n+     out of the temp register into a BLKmode memory object.  */\n+  if (target\n       && TYPE_MODE (TREE_TYPE (TREE_TYPE (fndecl))) == BLKmode\n       && ! aggregate_value_p (TREE_TYPE (TREE_TYPE (fndecl))))\n     target = copy_blkmode_from_reg (0, target, TREE_TYPE (TREE_TYPE (fndecl)));\n-  \n+\n   if (structure_value_addr)\n     {\n       target = gen_rtx_MEM (TYPE_MODE (type),\n@@ -1213,18 +1212,18 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n /* Make copies of each insn in the given list using the mapping\n    computed in expand_inline_function. This function may call itself for\n    insns containing sequences.\n-   \n+\n    Copying is done in two passes, first the insns and then their REG_NOTES,\n    just like save_for_inline.\n \n    If static_chain_value is non-zero, it represents the context-pointer\n-   register for the function. */\n+   register for the function.  */\n \n static void\n copy_insn_list (insns, map, static_chain_value)\n-    rtx insns;\n-    struct inline_remap *map;\n-    rtx static_chain_value;\n+     rtx insns;\n+     struct inline_remap *map;\n+     rtx static_chain_value;\n {\n   register int i;\n   rtx insn;\n@@ -1260,7 +1259,7 @@ copy_insn_list (insns, map, static_chain_value)\n \t    break;\n \n \t  /* If the inline fn needs eh context, make sure that\n-\t     the current fn has one. */\n+\t     the current fn has one.  */\n \t  if (GET_CODE (pattern) == USE\n \t      && find_reg_note (insn, REG_EH_CONTEXT, 0) != 0)\n \t    get_eh_context ();\n@@ -1430,7 +1429,7 @@ copy_insn_list (insns, map, static_chain_value)\n \tcase CALL_INSN:\n \t  /* If this is a CALL_PLACEHOLDER insn then we need to copy the\n \t     three attached sequences: normal call, sibling call and tail\n-\t     recursion. */\n+\t     recursion.  */\n \t  if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n \t    {\n \t      rtx sequence[3];\n@@ -1439,7 +1438,7 @@ copy_insn_list (insns, map, static_chain_value)\n \t      for (i = 0; i < 3; i++)\n \t\t{\n \t\t  rtx seq;\n-\t\t  \n+\n \t\t  sequence[i] = NULL_RTX;\n \t\t  seq = XEXP (PATTERN (insn), i);\n \t\t  if (seq)\n@@ -1451,16 +1450,16 @@ copy_insn_list (insns, map, static_chain_value)\n \t\t    }\n \t\t}\n \n-\t      /* Find the new tail recursion label.  \n+\t      /* Find the new tail recursion label.\n \t         It will already be substituted into sequence[2].  */\n \t      tail_label = copy_rtx_and_substitute (XEXP (PATTERN (insn), 3),\n \t\t\t\t\t\t    map, 0);\n \n-\t      copy = emit_call_insn (gen_rtx_CALL_PLACEHOLDER (VOIDmode, \n-\t\t\t\t\t\t\tsequence[0],\n-\t\t\t\t\t\t\tsequence[1],\n-\t\t\t\t\t\t\tsequence[2],\n-\t\t\t\t\t\t\ttail_label));\n+\t      copy = emit_call_insn (gen_rtx_CALL_PLACEHOLDER (VOIDmode,\n+\t\t\t\t\t\t\t       sequence[0],\n+\t\t\t\t\t\t\t       sequence[1],\n+\t\t\t\t\t\t\t       sequence[2],\n+\t\t\t\t\t\t\t       tail_label));\n \t      break;\n \t    }\n \n@@ -1483,7 +1482,7 @@ copy_insn_list (insns, map, static_chain_value)\n #endif\n \t  try_constants (copy, map);\n \n-\t      /* Be lazy and assume CALL_INSNs clobber all hard registers.  */\n+\t  /* Be lazy and assume CALL_INSNs clobber all hard registers.  */\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    VARRAY_CONST_EQUIV (map->const_equiv_varray, i).rtx = 0;\n \t  break;\n@@ -1500,8 +1499,8 @@ copy_insn_list (insns, map, static_chain_value)\n \t  break;\n \n \tcase NOTE:\n-\t  /* NOTE_INSN_FUNCTION_END and NOTE_INSN_FUNCTION_BEG are \n-\t     discarded because it is important to have only one of \n+\t  /* NOTE_INSN_FUNCTION_END and NOTE_INSN_FUNCTION_BEG are\n+\t     discarded because it is important to have only one of\n \t     each in the current function.\n \n \t     NOTE_INSN_DELETED notes aren't useful (save_for_inline\n@@ -1527,16 +1526,16 @@ copy_insn_list (insns, map, static_chain_value)\n \t\t  rtx label\n \t\t    = get_label_from_map (map, NOTE_EH_HANDLER (copy));\n \n-                  /* we have to duplicate the handlers for the original */\n-                  if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG)\n-                    {\n-                      /* We need to duplicate the handlers for the EH region\n-                         and we need to indicate where the label map is */\n-                      eif_eh_map = map;\n-                      duplicate_eh_handlers (NOTE_EH_HANDLER (copy), \n-                                             CODE_LABEL_NUMBER (label),\n-                                             expand_inline_function_eh_labelmap);\n-                    }\n+\t\t  /* We have to duplicate the handlers for the original.  */\n+\t\t  if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG)\n+\t\t    {\n+\t\t      /* We need to duplicate the handlers for the EH region\n+\t\t\t and we need to indicate where the label map is */\n+\t\t      eif_eh_map = map;\n+\t\t      duplicate_eh_handlers (NOTE_EH_HANDLER (copy),\n+\t\t\t\t\t     CODE_LABEL_NUMBER (label),\n+\t\t\t\t\t     expand_inline_function_eh_labelmap);\n+\t\t    }\n \n \t\t  /* We have to forward these both to match the new exception\n \t\t     region.  */\n@@ -1550,12 +1549,12 @@ copy_insn_list (insns, map, static_chain_value)\n \t\t  tree *mapped_block_p;\n \n \t\t  mapped_block_p\n-\t\t    = (tree *) bsearch (NOTE_BLOCK (insn), \n+\t\t    = (tree *) bsearch (NOTE_BLOCK (insn),\n \t\t\t\t\t&VARRAY_TREE (map->block_map, 0),\n \t\t\t\t\tmap->block_map->elements_used,\n \t\t\t\t\tsizeof (tree),\n \t\t\t\t\tfind_block);\n-\t\t  \n+\n \t\t  if (!mapped_block_p)\n \t\t    abort ();\n \t\t  else\n@@ -1593,7 +1592,7 @@ copy_insn_list (insns, map, static_chain_value)\n \tapply_change_group ();\n \tREG_NOTES (map->insn_map[INSN_UID (insn)]) = note;\n \n-\t/* Finally, delete any REG_LABEL notes from the chain.  */\t          \n+\t/* Finally, delete any REG_LABEL notes from the chain.  */\n \tfor (; note; note = next)\n \t  {\n \t    next = XEXP (note, 1);\n@@ -1695,7 +1694,7 @@ integrate_decl_tree (let, map)\n \n   TREE_USED (new_block) = TREE_USED (let);\n   BLOCK_ABSTRACT_ORIGIN (new_block) = let;\n-  \n+\n   return new_block;\n }\n \f\n@@ -1810,7 +1809,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t      start_sequence ();\n \t      loc = assign_stack_temp (BLKmode, size, 1);\n \t      loc = XEXP (loc, 0);\n-\t      /* When arguments grow downward, the virtual incoming \n+\t      /* When arguments grow downward, the virtual incoming\n \t\t args pointer points to the top of the argument block,\n \t\t so the remapped location better do the same.  */\n #ifdef ARGS_GROW_DOWNWARD\n@@ -1887,7 +1886,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n       copy = gen_rtx_ADDRESSOF (mode,\n \t\t\t\tcopy_rtx_and_substitute (XEXP (orig, 0),\n \t\t\t\t\t\t\t map, for_lhs),\n-\t\t\t\t0, ADDRESSOF_DECL(orig));\n+\t\t\t\t0, ADDRESSOF_DECL (orig));\n       regno = ADDRESSOF_REGNO (orig);\n       if (map->reg_map[regno])\n \tregno = REGNO (map->reg_map[regno]);\n@@ -2007,13 +2006,12 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t\t\t  copy_rtx_and_substitute (constant, map, for_lhs)),\n \t\t\t 0);\n \t}\n-      else\n-        if (SYMBOL_REF_NEED_ADJUST (orig)) \n-          {\n-            eif_eh_map = map;\n-            return rethrow_symbol_map (orig, \n-                                       expand_inline_function_eh_labelmap);\n-          }\n+      else if (SYMBOL_REF_NEED_ADJUST (orig))\n+\t{\n+\t  eif_eh_map = map;\n+\t  return rethrow_symbol_map (orig,\n+\t\t\t\t     expand_inline_function_eh_labelmap);\n+\t}\n \n       return orig;\n \n@@ -2092,7 +2090,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n       if (SET_DEST (orig) == virtual_stack_vars_rtx\n \t  || SET_DEST (orig) == virtual_incoming_args_rtx)\n \t{\n-\t  /* In case a translation hasn't occurred already, make one now. */\n+\t  /* In case a translation hasn't occurred already, make one now.  */\n \t  rtx equiv_reg;\n \t  rtx equiv_loc;\n \t  HOST_WIDE_INT loc_offset;\n@@ -2103,7 +2101,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t\t\t\t\t  REGNO (equiv_reg)).rtx;\n \t  loc_offset\n \t    = GET_CODE (equiv_loc) == REG ? 0 : INTVAL (XEXP (equiv_loc, 1));\n-\t      \n+\n \t  return gen_rtx_SET (VOIDmode, SET_DEST (orig),\n \t\t\t      force_operand\n \t\t\t      (plus_constant\n@@ -2147,7 +2145,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n       XEXP (copy, 0) = copy_rtx_and_substitute (XEXP (orig, 0), map, 0);\n       MEM_COPY_ATTRIBUTES (copy, orig);\n       return copy;\n-      \n+\n     default:\n       break;\n     }\n@@ -2288,7 +2286,7 @@ try_constants (insn, map)\n    into insns; cse will do the latter task better.\n \n    This function is also used to adjust address of items previously addressed\n-   via the virtual stack variable or virtual incoming arguments registers. \n+   via the virtual stack variable or virtual incoming arguments registers.\n \n    If MEMONLY is nonzero, only make changes inside a MEM.  */\n \n@@ -2366,7 +2364,7 @@ subst_constants (loc, insn, map, memonly)\n \t  /* We can't call subst_constants on &SUBREG_REG (x) because any\n \t     constant or SUBREG wouldn't be valid inside our SUBEG.  Instead,\n \t     see what is inside, try to form the new SUBREG and see if that is\n-\t     valid.  We handle two cases: extracting a full word in an \n+\t     valid.  We handle two cases: extracting a full word in an\n \t     integral mode and extracting the low part.  */\n \t  subst_constants (&inner, NULL_RTX, map, 0);\n \n@@ -2470,7 +2468,7 @@ subst_constants (loc, insn, map, memonly)\n     }\n \n   format_ptr = GET_RTX_FORMAT (code);\n-  \n+\n   /* If the first operand is an expression, save its mode for later.  */\n   if (*format_ptr == 'e')\n     op0_mode = GET_MODE (XEXP (x, 0));\n@@ -2491,7 +2489,7 @@ subst_constants (loc, insn, map, memonly)\n \tcase 'i':\n \tcase 's':\n \tcase 'w':\n- \tcase 'n':\n+\tcase 'n':\n \tcase 't':\n \t  break;\n \n@@ -2551,7 +2549,7 @@ subst_constants (loc, insn, map, memonly)\n \t    }\n #endif\n \t  break;\n-      }\n+\t}\n \n       case '2':\n       case 'c':\n@@ -2601,7 +2599,7 @@ mark_stores (dest, x, data)\n     {\n       unsigned int uregno = regno;\n       unsigned int last_reg = (uregno >= FIRST_PSEUDO_REGISTER ? uregno\n-\t\t\t      : uregno + HARD_REGNO_NREGS (uregno, mode) - 1);\n+\t\t\t       : uregno + HARD_REGNO_NREGS (uregno, mode) - 1);\n       unsigned int i;\n \n       /* Ignore virtual stack var or virtual arg register since those\n@@ -2633,21 +2631,21 @@ set_block_origin_self (stmt)\n       BLOCK_ABSTRACT_ORIGIN (stmt) = stmt;\n \n       {\n-        register tree local_decl;\n+\tregister tree local_decl;\n \n-        for (local_decl = BLOCK_VARS (stmt);\n+\tfor (local_decl = BLOCK_VARS (stmt);\n \t     local_decl != NULL_TREE;\n \t     local_decl = TREE_CHAIN (local_decl))\n-          set_decl_origin_self (local_decl);\t/* Potential recursion.  */\n+\t  set_decl_origin_self (local_decl);\t/* Potential recursion.  */\n       }\n \n       {\n-        register tree subblock;\n+\tregister tree subblock;\n \n-        for (subblock = BLOCK_SUBBLOCKS (stmt);\n+\tfor (subblock = BLOCK_SUBBLOCKS (stmt);\n \t     subblock != NULL_TREE;\n \t     subblock = BLOCK_CHAIN (subblock))\n-          set_block_origin_self (subblock);\t/* Recurse.  */\n+\t  set_block_origin_self (subblock);\t/* Recurse.  */\n       }\n     }\n }"}]}