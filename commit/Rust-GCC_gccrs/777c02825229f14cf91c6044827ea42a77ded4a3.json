{"sha": "777c02825229f14cf91c6044827ea42a77ded4a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3YzAyODI1MjI5ZjE0Y2Y5MWM2MDQ0ODI3ZWE0MmE3N2RlZDRhMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-17T04:35:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-17T04:35:37Z"}, "message": "runtime: scan write barrier buffer conservatively\n    \n    In gccgo, we insert the write barriers in the frontend, and so we\n    cannot completely prevent write barriers on stack writes. So it\n    is possible for a bad pointer appearing in the write barrier\n    buffer. When flushing the write barrier, treat it the same as\n    sacnning the stack. In particular, don't mark a pointer if it\n    does not point to an allocated object. We already have similar\n    logic in greyobject. With this, hopefully, we can prevent an\n    unallocated object from being marked completely.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/190599\n\nFrom-SVN: r274598", "tree": {"sha": "3dd9baeb70c0752889ee56008eb3642fc4d3e76a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dd9baeb70c0752889ee56008eb3642fc4d3e76a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777c02825229f14cf91c6044827ea42a77ded4a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777c02825229f14cf91c6044827ea42a77ded4a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777c02825229f14cf91c6044827ea42a77ded4a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777c02825229f14cf91c6044827ea42a77ded4a3/comments", "author": null, "committer": null, "parents": [{"sha": "7aad42b91897c6b9fa3047efdd8d966a2788c159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aad42b91897c6b9fa3047efdd8d966a2788c159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aad42b91897c6b9fa3047efdd8d966a2788c159"}], "stats": {"total": 11, "additions": 9, "deletions": 2}, "files": [{"sha": "78597da64177f6c0fb78ada1b504a0ebec2e1a29", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777c02825229f14cf91c6044827ea42a77ded4a3/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777c02825229f14cf91c6044827ea42a77ded4a3/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=777c02825229f14cf91c6044827ea42a77ded4a3", "patch": "@@ -1,4 +1,4 @@\n-0f6d673d5b1a3474c3424cb6994ae8ff9baed255\n+838f926c93898767f0337122725a4f52a1335186\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "a27406e298761a4c8beaf0e6555a1d4947082399", "filename": "libgo/go/runtime/mwbbuf.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777c02825229f14cf91c6044827ea42a77ded4a3/libgo%2Fgo%2Fruntime%2Fmwbbuf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777c02825229f14cf91c6044827ea42a77ded4a3/libgo%2Fgo%2Fruntime%2Fmwbbuf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmwbbuf.go?ref=777c02825229f14cf91c6044827ea42a77ded4a3", "patch": "@@ -285,10 +285,17 @@ func wbBufFlush1(_p_ *p) {\n \t\t\t// path to reduce the rate of flushes?\n \t\t\tcontinue\n \t\t}\n-\t\tobj, span, objIndex := findObject(ptr, 0, 0, false)\n+\t\tobj, span, objIndex := findObject(ptr, 0, 0, !usestackmaps)\n \t\tif obj == 0 {\n \t\t\tcontinue\n \t\t}\n+\t\tif span.isFree(objIndex) {\n+\t\t\t// For gccgo, it is possible that we have a write barrier\n+\t\t\t// writing to unintialized stack memory. So we could see\n+\t\t\t// a bad pointer in the write barrier buffer. Don't mark\n+\t\t\t// it in this case.\n+\t\t\tcontinue\n+\t\t}\n \t\t// TODO: Consider making two passes where the first\n \t\t// just prefetches the mark bits.\n \t\tmbits := span.markBitsForIndex(objIndex)"}]}