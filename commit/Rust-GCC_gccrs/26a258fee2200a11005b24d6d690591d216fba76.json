{"sha": "26a258fee2200a11005b24d6d690591d216fba76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZhMjU4ZmVlMjIwMGExMTAwNWIyNGQ2ZDY5MDU5MWQyMTZmYmE3Ng==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1994-10-17T23:08:37Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1994-10-17T23:08:37Z"}, "message": "(expand_call, emit_library_call, emit_library_call_value):\n\nAllways adjust current_function_outgoing_args_size, even #ifndef\nACCUMULATE_OUTGOING_ARGS.  (Useful for stack overflow checking.)\n\nFrom-SVN: r8290", "tree": {"sha": "c58a1c7d9c5d610cff7b0fbf4d070b4548452198", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c58a1c7d9c5d610cff7b0fbf4d070b4548452198"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26a258fee2200a11005b24d6d690591d216fba76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a258fee2200a11005b24d6d690591d216fba76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26a258fee2200a11005b24d6d690591d216fba76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a258fee2200a11005b24d6d690591d216fba76/comments", "author": null, "committer": null, "parents": [{"sha": "c199879dc746375840363290d8d97b15b2d6bff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c199879dc746375840363290d8d97b15b2d6bff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c199879dc746375840363290d8d97b15b2d6bff9"}], "stats": {"total": 135, "additions": 71, "deletions": 64}, "files": [{"sha": "2002322afa49cd132bee225e8cb5c456c283c5a0", "filename": "gcc/calls.c", "status": "modified", "additions": 71, "deletions": 64, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26a258fee2200a11005b24d6d690591d216fba76/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26a258fee2200a11005b24d6d690591d216fba76/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=26a258fee2200a11005b24d6d690591d216fba76", "patch": "@@ -1353,98 +1353,103 @@ expand_call (exp, target, ignore)\n \t}\n       argblock = push_block (ARGS_SIZE_RTX (args_size), 0, 0);\n     }\n-  else if (must_preallocate)\n+  else\n     {\n       /* Note that we must go through the motions of allocating an argument\n \t block even if the size is zero because we may be storing args\n \t in the area reserved for register arguments, which may be part of\n \t the stack frame.  */\n+\n       int needed = args_size.constant;\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n       /* Store the maximum argument space used.  It will be pushed by the\n-\t prologue.\n-\n-\t Since the stack pointer will never be pushed, it is possible for\n-\t the evaluation of a parm to clobber something we have already\n-\t written to the stack.  Since most function calls on RISC machines\n-\t do not use the stack, this is uncommon, but must work correctly.\n-\t \n-\t Therefore, we save any area of the stack that was already written\n-\t and that we are using.  Here we set up to do this by making a new\n-\t stack usage map from the old one.  The actual save will be done\n-\t by store_one_arg. \n-\n-\t Another approach might be to try to reorder the argument\n-\t evaluations to avoid this conflicting stack usage.  */\n+\t prologue (if ACCUMULATE_OUTGOING_ARGS, or stack overflow checking). */\n \n       if (needed > current_function_outgoing_args_size)\n \tcurrent_function_outgoing_args_size = needed;\n \n+      if (must_preallocate)\n+\t{\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+\t  /* Since the stack pointer will never be pushed, it is possible for\n+\t     the evaluation of a parm to clobber something we have already\n+\t     written to the stack.  Since most function calls on RISC machines\n+\t     do not use the stack, this is uncommon, but must work correctly.\n+\n+\t     Therefore, we save any area of the stack that was already written\n+\t     and that we are using.  Here we set up to do this by making a new\n+\t     stack usage map from the old one.  The actual save will be done\n+\t     by store_one_arg. \n+\n+\t     Another approach might be to try to reorder the argument\n+\t     evaluations to avoid this conflicting stack usage.  */\n+\n #if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n-      /* Since we will be writing into the entire argument area, the\n-\t map must be allocated for its entire size, not just the part that\n-\t is the responsibility of the caller.  */\n-      needed += reg_parm_stack_space;\n+\t  /* Since we will be writing into the entire argument area, the\n+\t     map must be allocated for its entire size, not just the part that\n+\t     is the responsibility of the caller.  */\n+\t  needed += reg_parm_stack_space;\n #endif\n \n #ifdef ARGS_GROW_DOWNWARD\n-      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t\t needed + 1);\n+\t  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t     needed + 1);\n #else\n-      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use, needed);\n+\t  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t     needed);\n #endif\n-      stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+\t  stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n \n-      if (initial_highest_arg_in_use)\n-\tbcopy (initial_stack_usage_map, stack_usage_map,\n-\t       initial_highest_arg_in_use);\n+\t  if (initial_highest_arg_in_use)\n+\t    bcopy (initial_stack_usage_map, stack_usage_map,\n+\t\t   initial_highest_arg_in_use);\n \n-      if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n-\tbzero (&stack_usage_map[initial_highest_arg_in_use],\n-\t       highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n-      needed = 0;\n+\t  if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n+\t    bzero (&stack_usage_map[initial_highest_arg_in_use],\n+\t\t   highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n+\t  needed = 0;\n \n-      /* The address of the outgoing argument list must not be copied to a\n-\t register here, because argblock would be left pointing to the\n-\t wrong place after the call to allocate_dynamic_stack_space below. */\n+\t  /* The address of the outgoing argument list must not be copied to a\n+\t     register here, because argblock would be left pointing to the\n+\t     wrong place after the call to allocate_dynamic_stack_space below.\n+\t     */\n \n-      argblock = virtual_outgoing_args_rtx;\n+\t  argblock = virtual_outgoing_args_rtx;\n \n #else /* not ACCUMULATE_OUTGOING_ARGS */\n-      if (inhibit_defer_pop == 0)\n-\t{\n-\t  /* Try to reuse some or all of the pending_stack_adjust\n-\t     to get this space.  Maybe we can avoid any pushing.  */\n-\t  if (needed > pending_stack_adjust)\n+\t  if (inhibit_defer_pop == 0)\n \t    {\n-\t      needed -= pending_stack_adjust;\n-\t      pending_stack_adjust = 0;\n+\t      /* Try to reuse some or all of the pending_stack_adjust\n+\t\t to get this space.  Maybe we can avoid any pushing.  */\n+\t      if (needed > pending_stack_adjust)\n+\t\t{\n+\t\t  needed -= pending_stack_adjust;\n+\t\t  pending_stack_adjust = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  pending_stack_adjust -= needed;\n+\t\t  needed = 0;\n+\t\t}\n \t    }\n+\t  /* Special case this because overhead of `push_block' in this\n+\t     case is non-trivial.  */\n+\t  if (needed == 0)\n+\t    argblock = virtual_outgoing_args_rtx;\n \t  else\n-\t    {\n-\t      pending_stack_adjust -= needed;\n-\t      needed = 0;\n-\t    }\n-\t}\n-      /* Special case this because overhead of `push_block' in this\n-\t case is non-trivial.  */\n-      if (needed == 0)\n-\targblock = virtual_outgoing_args_rtx;\n-      else\n-\targblock = push_block (GEN_INT (needed), 0, 0);\n-\n-      /* We only really need to call `copy_to_reg' in the case where push\n-\t insns are going to be used to pass ARGBLOCK to a function\n-\t call in ARGS.  In that case, the stack pointer changes value\n-\t from the allocation point to the call point, and hence\n-\t the value of VIRTUAL_OUTGOING_ARGS_RTX changes as well.\n-\t But might as well always do it.  */\n-      argblock = copy_to_reg (argblock);\n+\t    argblock = push_block (GEN_INT (needed), 0, 0);\n+\n+\t  /* We only really need to call `copy_to_reg' in the case where push\n+\t     insns are going to be used to pass ARGBLOCK to a function\n+\t     call in ARGS.  In that case, the stack pointer changes value\n+\t     from the allocation point to the call point, and hence\n+\t     the value of VIRTUAL_OUTGOING_ARGS_RTX changes as well.\n+\t     But might as well always do it.  */\n+\t  argblock = copy_to_reg (argblock);\n #endif /* not ACCUMULATE_OUTGOING_ARGS */\n+\t}\n     }\n \n-\n #ifdef ACCUMULATE_OUTGOING_ARGS\n   /* The save/restore code in store_one_arg handles all cases except one:\n      a constructor call (including a C function returning a BLKmode struct)\n@@ -2276,9 +2281,10 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n #endif\n #endif\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n   if (args_size.constant > current_function_outgoing_args_size)\n     current_function_outgoing_args_size = args_size.constant;\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n   args_size.constant = 0;\n #endif\n \n@@ -2623,9 +2629,10 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n #endif\n #endif\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n   if (args_size.constant > current_function_outgoing_args_size)\n     current_function_outgoing_args_size = args_size.constant;\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n   args_size.constant = 0;\n #endif\n "}]}