{"sha": "3f41ffd8c39bedd88fbf0f7fcc42559397d69103", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y0MWZmZDhjMzliZWRkODhmYmYwZjdmY2M0MjU1OTM5N2Q2OTEwMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-05-22T00:31:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-05-22T00:31:36Z"}, "message": "call.c (build_op_delete_call): Ignore exception-specifications when looking for matching delete operators.\n\n\t* call.c (build_op_delete_call): Ignore exception-specifications\n\twhen looking for matching delete operators.\n\t* init.c (build_new_1): Compute whether or not the allocation\n\tfunction used is a placement allocation function or not, and\n\tcommunicate this information to build_op_delete_call.\n\nFrom-SVN: r42413", "tree": {"sha": "3d7688183b2a2137423e2873a5b2ff048d8d847a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d7688183b2a2137423e2873a5b2ff048d8d847a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f41ffd8c39bedd88fbf0f7fcc42559397d69103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f41ffd8c39bedd88fbf0f7fcc42559397d69103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f41ffd8c39bedd88fbf0f7fcc42559397d69103", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/comments", "author": null, "committer": null, "parents": [{"sha": "b1e6ab035edd172c58ef3acb91a9b955921d13f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1e6ab035edd172c58ef3acb91a9b955921d13f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1e6ab035edd172c58ef3acb91a9b955921d13f0"}], "stats": {"total": 129, "additions": 112, "deletions": 17}, "files": [{"sha": "5d6ca8f60209210afaa5ab4de69dacd4c69a1619", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3f41ffd8c39bedd88fbf0f7fcc42559397d69103", "patch": "@@ -1,3 +1,11 @@\n+2001-05-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (build_op_delete_call): Ignore exception-specifications\n+\twhen looking for matching delete operators.\n+\t* init.c (build_new_1): Compute whether or not the allocation\n+\tfunction used is a placement allocation function or not, and\n+\tcommunicate this information to build_op_delete_call.\n+\n 2001-05-21  Jason Merrill  <jason_merrill@redhat.com>\n \n \t* class.c (build_vtable_entry_ref): Lose vtbl parm.  Fix for new abi."}, {"sha": "5367cc55805472547a8f5119465b1c910d7ee326", "filename": "gcc/cp/call.c", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3f41ffd8c39bedd88fbf0f7fcc42559397d69103", "patch": "@@ -3545,7 +3545,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n      used to determine what the corresponding new looked like.\n    SIZE is the size of the memory block to be deleted.\n    FLAGS are the usual overloading flags.\n-   PLACEMENT is the corresponding placement new call, or 0.  */\n+   PLACEMENT is the corresponding placement new call, or NULL_TREE.  */\n \n tree\n build_op_delete_call (code, addr, size, flags, placement)\n@@ -3620,23 +3620,50 @@ build_op_delete_call (code, addr, size, flags, placement)\n \targtypes = tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t      tree_cons (NULL_TREE, sizetype, \n \t\t\t\t\t void_list_node));\n-\n       fntype = build_function_type (void_type_node, argtypes);\n-      fn = instantiate_type (fntype, fns, itf_no_attributes);\n \n-      if (fn != error_mark_node)\n+      /* Go through the `operator delete' functions looking for one\n+\t with a matching type.  */\n+      for (fn = BASELINK_P (fns) ? TREE_VALUE (fns) : fns; \n+\t   fn; \n+\t   fn = OVL_NEXT (fn))\n \t{\n-\t  /* Member functions.  */\n-\t  if (BASELINK_P (fns))\n-\t    enforce_access (type, fn);\n-\n-\t  if (pass == 0)\n-\t    args = tree_cons (NULL_TREE, addr, args);\n-\t  else\n-\t    args = tree_cons (NULL_TREE, addr, \n-\t\t\t      build_tree_list (NULL_TREE, size));\n-\t  return build_function_call (fn, args);\n+\t  tree t;\n+\n+\t  /* Exception specifications on the `delete' operator do not\n+\t     matter.  */\n+\t  t = build_exception_variant (TREE_TYPE (OVL_CURRENT (fn)),\n+\t\t\t\t       NULL_TREE);\n+\t  /* We also don't compare attributes.  We're really just\n+\t     trying to check the types of the first two parameters.  */\n+\t  if (comptypes (t, fntype, COMPARE_NO_ATTRIBUTES))\n+\t    break;\n \t}\n+\n+      /* If we found a match, we're done.  */\n+      if (fn)\n+\tbreak;\n+    }\n+\n+  /* If we have a matching function, call it.  */\n+  if (fn)\n+    {\n+      /* Make sure we have the actual function, and not an\n+\t OVERLOAD.  */\n+      fn = OVL_CURRENT (fn);\n+\n+      /* If the FN is a member function, make sure that it is\n+\t accessible.  */\n+      if (DECL_CLASS_SCOPE_P (fn))\n+\tenforce_access (type, fn);\n+\n+      if (pass == 0)\n+\targs = tree_cons (NULL_TREE, addr, args);\n+      else\n+\targs = tree_cons (NULL_TREE, addr, \n+\t\t\t  build_tree_list (NULL_TREE, size));\n+\n+      return build_function_call (fn, args);\n     }\n \n   /* If we are doing placement delete we do nothing if we don't find a"}, {"sha": "6bce1937652eda80f04f6c76778c0407ac093893", "filename": "gcc/cp/init.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3f41ffd8c39bedd88fbf0f7fcc42559397d69103", "patch": "@@ -2293,6 +2293,9 @@ build_new_1 (exp)\n      beginning of the storage allocated for an array-new expression in\n      order to store the number of elements.  */\n   tree cookie_size = NULL_TREE;\n+  /* True if the function we are calling is a placement allocation\n+     function.  */\n+  bool placement_allocation_fn_p;\n \n   placement = TREE_OPERAND (exp, 0);\n   type = TREE_OPERAND (exp, 1);\n@@ -2418,8 +2421,25 @@ build_new_1 (exp)\n   if (alloc_call == error_mark_node)\n     return error_mark_node;\n \n-  if (alloc_call == NULL_TREE)\n-    abort ();\n+  /* The ALLOC_CALL should be a CALL_EXPR, and the first operand\n+     should be the address of a known FUNCTION_DECL.  */\n+  my_friendly_assert (TREE_CODE (alloc_call) == CALL_EXPR, 20000521);\n+  t = TREE_OPERAND (alloc_call, 0);\n+  my_friendly_assert (TREE_CODE (t) == ADDR_EXPR, 20000521);\n+  t = TREE_OPERAND (t, 0);\n+  my_friendly_assert (TREE_CODE (t) == FUNCTION_DECL, 20000521);\n+  /* Now, check to see if this function is actually a placement\n+     allocation function.  This can happen even when PLACEMENT is NULL\n+     because we might have something like:\n+\n+       struct S { void* operator new (size_t, int i = 0); };\n+\n+     A call to `new S' will get this allocation function, even though\n+     there is no explicit placement argument.  If there is more than\n+     one argument, or there are variable arguments, then this is a\n+     placement allocation function.  */\n+  placement_allocation_fn_p \n+    = (type_num_arguments (TREE_TYPE (t)) > 1 || varargs_function_p (t));\n \n   /*        unless an allocation function is declared with an empty  excep-\n      tion-specification  (_except.spec_),  throw(), it indicates failure to\n@@ -2536,7 +2556,8 @@ build_new_1 (exp)\n \t  flags |= LOOKUP_SPECULATIVELY;\n \n \t  cleanup = build_op_delete_call (dcode, alloc_node, size, flags,\n-\t\t\t\t\t  alloc_call);\n+\t\t\t\t\t  (placement_allocation_fn_p \n+\t\t\t\t\t   ? alloc_call : NULL_TREE));\n \n \t  /* Ack!  First we allocate the memory.  Then we set our sentry\n \t     variable to true, and expand a cleanup that deletes the memory"}, {"sha": "35ec0bbac88c4d19701ce803fb9737a3a3f4b2b1", "filename": "gcc/testsuite/g++.old-deja/g++.other/new7.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f41ffd8c39bedd88fbf0f7fcc42559397d69103/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew7.C?ref=3f41ffd8c39bedd88fbf0f7fcc42559397d69103", "patch": "@@ -0,0 +1,39 @@\n+// Origin: philip_martin@ntlworld.com\n+\n+#include <new>\n+\n+extern \"C\" void abort();\n+\n+bool new_flag = false;\n+bool delete_flag = false;\n+\n+struct X {\n+  X()\n+  {\n+    throw 1;\n+  }\n+  void* operator new ( std::size_t n ) throw ( std::bad_alloc )\n+  {\n+    new_flag = true;\n+    return ::operator new( n );\n+  }\n+  void operator delete( void* p, std::size_t n ) throw()\n+  {\n+    delete_flag = true;\n+    ::operator delete( p );\n+  }\n+};\n+\n+int\n+main()\n+{\n+  try\n+    {\n+      X* x = new X; // gcc 3.0 fails to call operator delete when X::X throws\n+    }\n+  catch ( ... )\n+    {\n+    }\n+  if ( ! new_flag || ! delete_flag )\n+    ::abort();\n+}"}]}