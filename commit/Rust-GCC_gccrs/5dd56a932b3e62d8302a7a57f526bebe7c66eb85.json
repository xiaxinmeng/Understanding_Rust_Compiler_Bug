{"sha": "5dd56a932b3e62d8302a7a57f526bebe7c66eb85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRkNTZhOTMyYjNlNjJkODMwMmE3YTU3ZjUyNmJlYmU3YzY2ZWI4NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-12-09T10:51:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-12-09T10:51:44Z"}, "message": "* flow.c (recompute_reg_usage): Use basic block info to get loop_depth.\n\nFrom-SVN: r30843", "tree": {"sha": "6c6130018fdd982a23677a34b38a91d6e26c8d44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c6130018fdd982a23677a34b38a91d6e26c8d44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dd56a932b3e62d8302a7a57f526bebe7c66eb85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd56a932b3e62d8302a7a57f526bebe7c66eb85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dd56a932b3e62d8302a7a57f526bebe7c66eb85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd56a932b3e62d8302a7a57f526bebe7c66eb85/comments", "author": null, "committer": null, "parents": [{"sha": "e73ccf83b659d36880b3e6bd0ab9d935d4d8eacb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73ccf83b659d36880b3e6bd0ab9d935d4d8eacb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e73ccf83b659d36880b3e6bd0ab9d935d4d8eacb"}], "stats": {"total": 86, "additions": 41, "deletions": 45}, "files": [{"sha": "4834010b4d09db912bb291b2d799d3875509dc47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd56a932b3e62d8302a7a57f526bebe7c66eb85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd56a932b3e62d8302a7a57f526bebe7c66eb85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5dd56a932b3e62d8302a7a57f526bebe7c66eb85", "patch": "@@ -1,5 +1,7 @@\n Thu Dec  9 11:36:24 MET 1999 Jan Hubicka  <hubicka@freesoft.cz>\n \n+\t* flow.c (recompute_reg_usage): Use basic block info to get loop_depth.\n+\n \t* combine.c (try_combine, distribute_notes): Remove REG_N_REFS\n \tupdating code.\n "}, {"sha": "eb50c94abf59aefcf2167ede1d8fd38e2323846f", "filename": "gcc/flow.c", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd56a932b3e62d8302a7a57f526bebe7c66eb85/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd56a932b3e62d8302a7a57f526bebe7c66eb85/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5dd56a932b3e62d8302a7a57f526bebe7c66eb85", "patch": "@@ -5578,6 +5578,7 @@ recompute_reg_usage (f, loop_step)\n {\n   rtx insn;\n   int i, max_reg;\n+  int index;\n \n   /* Clear out the old data.  */\n   max_reg = max_reg_num ();\n@@ -5590,58 +5591,51 @@ recompute_reg_usage (f, loop_step)\n   /* Scan each insn in the chain and count how many times each register is\n      set/used.  */\n   loop_depth = 1;\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n+  for (index = 0; index < n_basic_blocks; index++)\n     {\n-      /* Keep track of loop depth.  */\n-      if (GET_CODE (insn) == NOTE)\n-\t{\n-\t  /* Look for loop boundaries.  */\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t    loop_depth -= loop_step;\n-\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t    loop_depth += loop_step;\n-\n-\t  /* If we have LOOP_DEPTH == 0, there has been a bookkeeping error. \n-\t     Abort now rather than setting register status incorrectly.  */\n-\t  if (loop_depth == 0)\n-\t    abort ();\n-\t}\n-      else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t{\n-\t  rtx links;\n+      basic_block bb = BASIC_BLOCK (index);\n+      loop_depth = bb->loop_depth;\n+      for (insn = bb->head; insn; insn = NEXT_INSN (insn))\n+ \t{\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    {\n+\t      rtx links;\n \n-\t  /* This call will increment REG_N_SETS for each SET or CLOBBER\n-\t     of a register in INSN.  It will also increment REG_N_REFS\n-\t     by the loop depth for each set of a register in INSN.  */\n-\t  count_reg_sets (PATTERN (insn));\n+\t      /* This call will increment REG_N_SETS for each SET or CLOBBER\n+\t\t of a register in INSN.  It will also increment REG_N_REFS\n+\t\t by the loop depth for each set of a register in INSN.  */\n+\t      count_reg_sets (PATTERN (insn));\n \n-\t  /* count_reg_sets does not detect autoincrement address modes, so\n-\t     detect them here by looking at the notes attached to INSN.  */\n-\t  for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n-\t    {\n-\t      if (REG_NOTE_KIND (links) == REG_INC)\n-\t\t/* Count (weighted) references, stores, etc.  This counts a\n-\t\t   register twice if it is modified, but that is correct.  */\n-\t\tREG_N_SETS (REGNO (XEXP (links, 0)))++;\n-\t    }\n+\t      /* count_reg_sets does not detect autoincrement address modes, so\n+\t\t detect them here by looking at the notes attached to INSN.  */\n+\t      for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n+\t\t{\n+\t\t  if (REG_NOTE_KIND (links) == REG_INC)\n+\t\t    /* Count (weighted) references, stores, etc.  This counts a\n+\t\t       register twice if it is modified, but that is correct.  */\n+\t\t    REG_N_SETS (REGNO (XEXP (links, 0)))++;\n+\t\t}\n \n-\t  /* This call will increment REG_N_REFS by the current loop depth for\n-\t     each reference to a register in INSN.  */\n-\t  count_reg_references (PATTERN (insn));\n+\t      /* This call will increment REG_N_REFS by the current loop depth for\n+\t\t each reference to a register in INSN.  */\n+\t      count_reg_references (PATTERN (insn));\n \n-\t  /* count_reg_references will not include counts for arguments to\n-\t     function calls, so detect them here by examining the\n-\t     CALL_INSN_FUNCTION_USAGE data.  */\n-\t  if (GET_CODE (insn) == CALL_INSN)\n-\t    {\n-\t      rtx note;\n+\t      /* count_reg_references will not include counts for arguments to\n+\t\t function calls, so detect them here by examining the\n+\t\t CALL_INSN_FUNCTION_USAGE data.  */\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\t{\n+\t\t  rtx note;\n \n-\t      for (note = CALL_INSN_FUNCTION_USAGE (insn);\n-\t\t   note;\n-\t\t   note = XEXP (note, 1))\n-\t\tif (GET_CODE (XEXP (note, 0)) == USE)\n-\t\t  count_reg_references (XEXP (XEXP (note, 0), 0));\n+\t\t  for (note = CALL_INSN_FUNCTION_USAGE (insn);\n+\t\t       note;\n+\t\t       note = XEXP (note, 1))\n+\t\t    if (GET_CODE (XEXP (note, 0)) == USE)\n+\t\t      count_reg_references (XEXP (XEXP (note, 0), 0));\n+\t\t}\n \t    }\n+\t  if (insn == bb->end)\n+\t    break;\n \t}\n     }\n }"}]}