{"sha": "5334d18ffa2ee58b84200c3df55723963b065dd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMzNGQxOGZmYTJlZTU4Yjg0MjAwYzNkZjU1NzIzOTYzYjA2NWRkNw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2009-04-10T14:03:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T14:03:49Z"}, "message": "exp_ch5.adb, [...]: Move the code that creates a call to the _Postconditions procedure in the case...\n\n2009-04-10  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch5.adb, exp_ch6.adb, sem_ch6.adb: Move the code that creates a\n\tcall to the _Postconditions procedure in the case of implicit returns\n\tfrom analysis to expansion. This eliminates some duplicated code. Use\n\tthe Postcondition_Proc to find the identity of this procedure during\n\texpansion.\n\nFrom-SVN: r145906", "tree": {"sha": "1a70b39918d3ed7340fb6e3fd20058de32aef1eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a70b39918d3ed7340fb6e3fd20058de32aef1eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5334d18ffa2ee58b84200c3df55723963b065dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5334d18ffa2ee58b84200c3df55723963b065dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5334d18ffa2ee58b84200c3df55723963b065dd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5334d18ffa2ee58b84200c3df55723963b065dd7/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "701b7fbbffdff1ebfe06bc014257e3e18abc93ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/701b7fbbffdff1ebfe06bc014257e3e18abc93ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/701b7fbbffdff1ebfe06bc014257e3e18abc93ef"}], "stats": {"total": 105, "additions": 52, "deletions": 53}, "files": [{"sha": "bd16930ac5759f1be3a099abc539c69869bf6674", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5334d18ffa2ee58b84200c3df55723963b065dd7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5334d18ffa2ee58b84200c3df55723963b065dd7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5334d18ffa2ee58b84200c3df55723963b065dd7", "patch": "@@ -1,3 +1,11 @@\n+2009-04-10  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch5.adb, exp_ch6.adb, sem_ch6.adb: Move the code that creates a\n+\tcall to the _Postconditions procedure in the case of implicit returns\n+\tfrom analysis to expansion. This eliminates some duplicated code. Use\n+\tthe Postcondition_Proc to find the identity of this procedure during\n+\texpansion.\n+\n 2009-04-10  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch6.adb: Minor code clean up."}, {"sha": "dfc983da087d3533a4200e6254d3f937323ace02", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5334d18ffa2ee58b84200c3df55723963b065dd7/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5334d18ffa2ee58b84200c3df55723963b065dd7/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=5334d18ffa2ee58b84200c3df55723963b065dd7", "patch": "@@ -3581,14 +3581,21 @@ package body Exp_Ch5 is\n       Lab_Node    : Node_Id;\n \n    begin\n-      --  Call postconditions procedure if procedure with active postconditions\n+      --  Call _Postconditions procedure if procedure with active\n+      --  postconditions. Here, we use the Postcondition_Proc attribute, which\n+      --  is needed for implicitly-generated returns. Functions never\n+      --  have implicitly-generated returns, and there's no room for\n+      --  Postcondition_Proc in E_Function, so we look up the identifier\n+      --  Name_uPostconditions for function returns (see\n+      --  Expand_Simple_Function_Return).\n \n       if Ekind (Scope_Id) = E_Procedure\n         and then Has_Postconditions (Scope_Id)\n       then\n+         pragma Assert (Present (Postcondition_Proc (Scope_Id)));\n          Insert_Action (N,\n            Make_Procedure_Call_Statement (Loc,\n-             Name => Make_Identifier (Loc, Name_uPostconditions)));\n+             Name => New_Reference_To (Postcondition_Proc (Scope_Id), Loc)));\n       end if;\n \n       --  If it is a return from a procedure do no extra steps"}, {"sha": "045bd046895097474659e7eaeb4206828af5801d", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5334d18ffa2ee58b84200c3df55723963b065dd7/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5334d18ffa2ee58b84200c3df55723963b065dd7/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5334d18ffa2ee58b84200c3df55723963b065dd7", "patch": "@@ -4080,7 +4080,34 @@ package body Exp_Ch6 is\n                Loc := Sloc (Last_Stm);\n             end if;\n \n-            Append_To (S, Make_Simple_Return_Statement (Loc));\n+            declare\n+               Rtn : constant Node_Id := Make_Simple_Return_Statement (Loc);\n+\n+            begin\n+               --  Append return statement, and set analyzed manually. We\n+               --  can't call Analyze on this return since the scope is wrong.\n+\n+               --  Note: it almost works to push the scope and then do the\n+               --  analyze call, but something goes wrong in some weird cases\n+               --  and it is not worth worrying about ???\n+\n+               Append_To (S, Rtn);\n+               Set_Analyzed (Rtn);\n+\n+               --  Call _Postconditions procedure if appropriate. We need to\n+               --  do this explicitly because we did not analyze the generated\n+               --  return statement above, so the call did not get inserted.\n+\n+               if Ekind (Spec_Id) = E_Procedure\n+                 and then Has_Postconditions (Spec_Id)\n+               then\n+                  pragma Assert (Present (Postcondition_Proc (Spec_Id)));\n+                  Insert_Action (Rtn,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Reference_To (Postcondition_Proc (Spec_Id), Loc)));\n+               end if;\n+            end;\n          end if;\n       end Add_Return;\n \n@@ -4282,8 +4309,7 @@ package body Exp_Ch6 is\n       end;\n \n       --  For a procedure, we add a return for all possible syntactic ends\n-      --  of the subprogram. Note that reanalysis is not necessary in this\n-      --  case since it would require a lot of work and accomplish nothing.\n+      --  of the subprogram.\n \n       if Ekind (Spec_Id) = E_Procedure\n         or else Ekind (Spec_Id) = E_Generic_Procedure"}, {"sha": "a5096403955d22c4b25bc127f5e8b4a103cc89dd", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5334d18ffa2ee58b84200c3df55723963b065dd7/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5334d18ffa2ee58b84200c3df55723963b065dd7/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5334d18ffa2ee58b84200c3df55723963b065dd7", "patch": "@@ -270,9 +270,10 @@ package body Sem_Ch6 is\n          Push_Scope (Stm_Entity);\n       end if;\n \n-      --  Check that pragma No_Return is obeyed\n+      --  Check that pragma No_Return is obeyed. Don't complain about the\n+      --  implicitly-generated return that is placed at the end.\n \n-      if No_Return (Scope_Id) then\n+      if No_Return (Scope_Id) and then Comes_From_Source (N) then\n          Error_Msg_N (\"RETURN statement not allowed (No_Return)\", N);\n       end if;\n \n@@ -1936,7 +1937,7 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n-      --  If a sep[arate spec is present, then deal with freezing issues\n+      --  If a separate spec is present, then deal with freezing issues\n \n       if Present (Spec_Id) then\n          Spec_Decl := Unit_Declaration_Node (Spec_Id);\n@@ -7850,40 +7851,12 @@ package body Sem_Ch6 is\n       Subp  : Entity_Id;\n       Parms : List_Id;\n \n-      procedure Add_Post_Call (Stms : List_Id; Post_Proc : Entity_Id);\n-      --  Add a call to Post_Proc at the end of the statement list\n-\n       function Grab_PPC (Nam : Name_Id) return Node_Id;\n       --  Prag contains an analyzed precondition or postcondition pragma.\n       --  This function copies the pragma, changes it to the corresponding\n       --  Check pragma and returns the Check pragma as the result. The\n       --  argument Nam is either Name_Precondition or Name_Postcondition.\n \n-      -------------------\n-      -- Add_Post_Call --\n-      -------------------\n-\n-      procedure Add_Post_Call (Stms : List_Id; Post_Proc : Entity_Id) is\n-         Last_Stm : Node_Id;\n-      begin\n-         --  Get last statement, ignoring irrelevant nodes\n-\n-         Last_Stm := Last (Stms);\n-         while Nkind (Last_Stm) in N_Pop_xxx_Label loop\n-            Prev (Last_Stm);\n-         end loop;\n-\n-         --  Append the call to the list. This is unnecessary (but harmless) if\n-         --  the end of the list is unreachable, so we do a simple check for\n-         --  Is_Transfer here.\n-\n-         if not Is_Transfer (Last_Stm) then\n-            Append_To (Stms,\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name => New_Reference_To (Post_Proc, Loc)));\n-         end if;\n-      end Add_Post_Call;\n-\n       --------------\n       -- Grab_PPC --\n       --------------\n@@ -8062,10 +8035,7 @@ package body Sem_Ch6 is\n                    Make_Defining_Identifier (Loc,\n                      Chars => Name_uPostconditions);\n             --  The entity for the _Postconditions procedure\n-            HSS : constant Node_Id := Handled_Statement_Sequence (N);\n-            Handler : Node_Id;\n          begin\n-\n             Prepend_To (Declarations (N),\n               Make_Subprogram_Body (Loc,\n                 Specification =>\n@@ -8079,22 +8049,10 @@ package body Sem_Ch6 is\n                   Make_Handled_Sequence_Of_Statements (Loc,\n                     Statements => Plist)));\n \n-            --  If this is a procedure, add a call to _postconditions to every\n-            --  place where it could return implicitly (not via a return\n-            --  statement, which are handled elsewhere). This is not necessary\n-            --  for functions, since functions always return via a return\n-            --  statement, or raise an exception.\n+            --  If this is a procedure, set the Postcondition_Proc attribute\n \n             if Etype (Subp) = Standard_Void_Type then\n-               Add_Post_Call (Statements (HSS), Post_Proc);\n-\n-               if Present (Exception_Handlers (HSS)) then\n-                  Handler := First_Non_Pragma (Exception_Handlers (HSS));\n-                  while Present (Handler) loop\n-                     Add_Post_Call (Statements (Handler), Post_Proc);\n-                     Next_Non_Pragma (Handler);\n-                  end loop;\n-               end if;\n+               Set_Postcondition_Proc (Spec_Id, Post_Proc);\n             end if;\n          end;\n "}]}