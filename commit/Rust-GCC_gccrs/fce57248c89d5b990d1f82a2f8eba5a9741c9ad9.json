{"sha": "fce57248c89d5b990d1f82a2f8eba5a9741c9ad9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNlNTcyNDhjODlkNWI5OTBkMWY4MmEyZjhlYmE1YTk3NDFjOWFkOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-05-24T14:05:20Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-05-24T14:05:20Z"}, "message": "Clean up PURE_SLP_STMT handling\n\nThe vectorizable_* routines had many instances of:\n\n        slp_node || PURE_SLP_STMT (stmt_info)\n\nwhich gives the misleading impression that we can have\n!slp_node && PURE_SLP_STMT (stmt_info).  In this context\nit's really enough to test slp_node on its own.\n\nThere are three cases:\n\n      loop vectorisation only:\n        vectorizable_foo called only with !slp_node\n\n      pure SLP:\n        vectorizable_foo called only with slp_node\n\n      hybrid SLP:\n        (e.g. a vector that's used in SLP statements and also in a reduction)\n        - vectorizable_foo called once with slp_node for the SLP uses.\n        - vectorizable_foo called once with !slp_node for the non-SLP uses.\n\nHybrid SLP isn't possible for stores, so I added an explicit assert\nfor that.\n\nI also made vectorizable_comparison static, to make it obvious that\nno other callers outside tree-vect-stmts.c could use it with the\n!slp && PURE_SLP_STMT combination.\n\nTested on aarch64-linux-gnu and x86_64-linux-gnu.\n\ngcc/\n\t* tree-vectorizer.h (vectorizable_comparison): Delete.\n\t* tree-vect-loop.c (vectorizable_reduction): Remove redundant\n\tPURE_SLP_STMT check.\n\t* tree-vect-stmts.c (vectorizable_call): Likewise.\n\t(vectorizable_simd_clone_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_store): Likewise.  Assert that we don't have\n\thybrid SLP.\n\t(vectorizable_comparison): Make static.  Remove redundant\n\tPURE_SLP_STMT check.\n\t(vect_transform_stmt): Assert that we always have an slp_node\n\tif PURE_SLP_STMT.\n\nFrom-SVN: r236642", "tree": {"sha": "fea3d6343aca03af342d9d4ea601fc7a7abb9a42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fea3d6343aca03af342d9d4ea601fc7a7abb9a42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1fb69400edb679142810fb86cc4c80254c60787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1fb69400edb679142810fb86cc4c80254c60787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1fb69400edb679142810fb86cc4c80254c60787"}], "stats": {"total": 65, "additions": 42, "deletions": 23}, "files": [{"sha": "6eac48e6e8e9fb764b2505ac9988df4318986deb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fce57248c89d5b990d1f82a2f8eba5a9741c9ad9", "patch": "@@ -1,3 +1,23 @@\n+2016-05-24  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vectorizable_comparison): Delete.\n+\t* tree-vect-loop.c (vectorizable_reduction): Remove redundant\n+\tPURE_SLP_STMT check.\n+\t* tree-vect-stmts.c (vectorizable_call): Likewise.\n+\t(vectorizable_simd_clone_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_condition): Likewise.\n+\t(vectorizable_store): Likewise.  Assert that we don't have\n+\thybrid SLP.\n+\t(vectorizable_comparison): Make static.  Remove redundant\n+\tPURE_SLP_STMT check.\n+\t(vect_transform_stmt): Assert that we always have an slp_node\n+\tif PURE_SLP_STMT.\n+\n 2016-05-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/neon.md (ashldi3_neon):  Replace comparison of INTVAL of"}, {"sha": "1471658da763d5f58df95023d0168f97b00fd5f3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=fce57248c89d5b990d1f82a2f8eba5a9741c9ad9", "patch": "@@ -5596,7 +5596,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n \n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     ncopies = 1;\n   else\n     ncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)"}, {"sha": "d9e9cbbba5c258afb12d29d98dfb52f68819ae6a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=fce57248c89d5b990d1f82a2f8eba5a9741c9ad9", "patch": "@@ -2342,7 +2342,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n     }\n \n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     ncopies = 1;\n   else if (modifier == NARROW && ifn == IFN_LAST)\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n@@ -2792,7 +2792,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* FORNOW */\n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     return false;\n \n   /* Process function arguments.  */\n@@ -3750,7 +3750,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     ncopies = 1;\n   else if (modifier == NARROW)\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n@@ -4231,7 +4231,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n@@ -4491,7 +4491,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n@@ -4922,7 +4922,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n@@ -5239,6 +5239,10 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       && TREE_CODE (scalar_dest) != MEM_REF)\n     return false;\n \n+  /* Cannot have hybrid store SLP -- that would mean storing to the\n+     same location twice.  */\n+  gcc_assert (slp == PURE_SLP_STMT (stmt_info));\n+\n   gcc_assert (gimple_assign_single_p (stmt));\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info), rhs_vectype = NULL_TREE;\n@@ -5250,7 +5254,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp || PURE_SLP_STMT (stmt_info))\n+  if (slp)\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n@@ -5332,9 +5336,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       grouped_store = true;\n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-      if (!slp\n-\t  && !PURE_SLP_STMT (stmt_info)\n-\t  && !STMT_VINFO_STRIDED_P (stmt_info))\n+      if (!slp && !STMT_VINFO_STRIDED_P (stmt_info))\n \t{\n \t  if (vect_store_lanes_supported (vectype, group_size))\n \t    store_lanes_p = true;\n@@ -5343,7 +5345,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n \n       if (STMT_VINFO_STRIDED_P (stmt_info)\n-\t  && (slp || PURE_SLP_STMT (stmt_info))\n+\t  && slp\n \t  && (group_size > nunits\n \t      || nunits % group_size != 0))\n \t{\n@@ -6252,7 +6254,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n-  if (slp || PURE_SLP_STMT (stmt_info))\n+  if (slp)\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n@@ -6305,9 +6307,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \n-      if (!slp\n-\t  && !PURE_SLP_STMT (stmt_info)\n-\t  && !STMT_VINFO_STRIDED_P (stmt_info))\n+      if (!slp && !STMT_VINFO_STRIDED_P (stmt_info))\n \t{\n \t  if (vect_load_lanes_supported (vectype, group_size))\n \t    load_lanes_p = true;\n@@ -6420,8 +6420,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     }\n   else if (STMT_VINFO_STRIDED_P (stmt_info))\n     {\n-      if ((grouped_load\n-\t   && (slp || PURE_SLP_STMT (stmt_info)))\n+      if (grouped_load\n+\t  && slp\n \t  && (group_size > nunits\n \t      || nunits % group_size != 0))\n \t{\n@@ -7499,7 +7499,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n \n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n@@ -7705,7 +7705,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n-bool\n+static bool\n vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t gimple **vec_stmt, tree reduc_def,\n \t\t\t slp_tree slp_node)\n@@ -7739,7 +7739,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   mask_type = vectype;\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  if (slp_node || PURE_SLP_STMT (stmt_info))\n+  if (slp_node)\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n@@ -8149,6 +8149,7 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   bool done;\n \n+  gcc_assert (slp_node || !PURE_SLP_STMT (stmt_info));\n   gimple *old_vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \n   switch (STMT_VINFO_TYPE (stmt_info))"}, {"sha": "5816006a4db9890a8d77927eaf638bd50a2beeba", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce57248c89d5b990d1f82a2f8eba5a9741c9ad9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=fce57248c89d5b990d1f82a2f8eba5a9741c9ad9", "patch": "@@ -1004,8 +1004,6 @@ extern void vect_remove_stores (gimple *);\n extern bool vect_analyze_stmt (gimple *, bool *, slp_tree);\n extern bool vectorizable_condition (gimple *, gimple_stmt_iterator *,\n \t\t\t\t    gimple **, tree, int, slp_tree);\n-extern bool vectorizable_comparison (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t     gimple **, tree, int, slp_tree);\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n \t\t\t\tunsigned int *, unsigned int *,\n \t\t\t\tstmt_vector_for_cost *,"}]}