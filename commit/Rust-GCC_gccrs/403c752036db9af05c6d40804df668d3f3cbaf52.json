{"sha": "403c752036db9af05c6d40804df668d3f3cbaf52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAzYzc1MjAzNmRiOWFmMDVjNmQ0MDgwNGRmNjY4ZDNmM2NiYWY1Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-08-05T12:36:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-08-05T12:36:34Z"}, "message": "re PR rtl-optimization/40924 (miscompiles with -O3 (seemingly related to attribute may_alias))\n\n\tPR rtl-optimization/40924\n\t* dse.c (canon_address): Before calling cselib_expand_value_rtx\n\tmake sure canon_rtx (mem_address) isn't simpler than\n\tcanon_rtx (expanded_mem_address).\n\n\t* g++.dg/torture/pr40924.C: New test.\n\nFrom-SVN: r150483", "tree": {"sha": "9a626f565d7bec81f41671e6ad4e4880cbb1f523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a626f565d7bec81f41671e6ad4e4880cbb1f523"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/403c752036db9af05c6d40804df668d3f3cbaf52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403c752036db9af05c6d40804df668d3f3cbaf52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/403c752036db9af05c6d40804df668d3f3cbaf52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403c752036db9af05c6d40804df668d3f3cbaf52/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64393e407db3350e25f53e252023f84f6e321c02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64393e407db3350e25f53e252023f84f6e321c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64393e407db3350e25f53e252023f84f6e321c02"}], "stats": {"total": 239, "additions": 190, "deletions": 49}, "files": [{"sha": "7fec75887b5ab11800df6f1b2c24eb980e6d6be7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403c752036db9af05c6d40804df668d3f3cbaf52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403c752036db9af05c6d40804df668d3f3cbaf52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=403c752036db9af05c6d40804df668d3f3cbaf52", "patch": "@@ -1,3 +1,10 @@\n+2009-08-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/40924\n+\t* dse.c (canon_address): Before calling cselib_expand_value_rtx\n+\tmake sure canon_rtx (mem_address) isn't simpler than\n+\tcanon_rtx (expanded_mem_address).\n+\n 2009-08-05  Li Feng  <nemokingdom@gmail.com>\n \n \t* graphite-sese-to-poly.c (build_pbb_drs): Remove build alias set"}, {"sha": "2338d3240ba93481c853d62ec7924353acb80fc1", "filename": "gcc/dse.c", "status": "modified", "additions": 67, "deletions": 49, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403c752036db9af05c6d40804df668d3f3cbaf52/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403c752036db9af05c6d40804df668d3f3cbaf52/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=403c752036db9af05c6d40804df668d3f3cbaf52", "patch": "@@ -1070,6 +1070,8 @@ canon_address (rtx mem,\n {\n   rtx mem_address = XEXP (mem, 0);\n   rtx expanded_address, address;\n+  int expanded;\n+\n   /* Make sure that cselib is has initialized all of the operands of\n      the address before asking it to do the subst.  */\n \n@@ -1114,72 +1116,88 @@ canon_address (rtx mem,\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  /* Use cselib to replace all of the reg references with the full\n-     expression.  This will take care of the case where we have \n+  /* First see if just canon_rtx (mem_address) is const or frame,\n+     if not, try cselib_expand_value_rtx and call canon_rtx on that.  */\n+  address = NULL_RTX;\n+  for (expanded = 0; expanded < 2; expanded++)\n+    {\n+      if (expanded)\n+\t{\n+\t  /* Use cselib to replace all of the reg references with the full\n+\t     expression.  This will take care of the case where we have \n \n-     r_x = base + offset;\n-     val = *r_x;\n+\t     r_x = base + offset;\n+\t     val = *r_x;\n    \n-     by making it into \n-\n-     val = *(base + offset);  \n-  */\n-\n-  expanded_address = cselib_expand_value_rtx (mem_address, scratch, 5);\n+\t     by making it into \n \n-  /* If this fails, just go with the mem_address.  */\n-  if (!expanded_address)\n-    expanded_address = mem_address;\n+\t     val = *(base + offset);  */\n \n-  /* Split the address into canonical BASE + OFFSET terms.  */\n-  address = canon_rtx (expanded_address);\n+\t  expanded_address = cselib_expand_value_rtx (mem_address,\n+\t\t\t\t\t\t      scratch, 5);\n \n-  *offset = 0;\n+\t  /* If this fails, just go with the address from first\n+\t     iteration.  */\n+\t  if (!expanded_address)\n+\t    break;\n+\t}\n+      else\n+\texpanded_address = mem_address;\n \n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\n   after cselib_expand address: \");\n-      print_inline_rtx (dump_file, expanded_address, 0);\n-      fprintf (dump_file, \"\\n\");\n+      /* Split the address into canonical BASE + OFFSET terms.  */\n+      address = canon_rtx (expanded_address);\n \n-      fprintf (dump_file, \"\\n   after canon_rtx address: \");\n-      print_inline_rtx (dump_file, address, 0);\n-      fprintf (dump_file, \"\\n\");\n-    }\n+      *offset = 0;\n \n-  if (GET_CODE (address) == CONST)\n-    address = XEXP (address, 0);\n+      if (dump_file)\n+\t{\n+\t  if (expanded)\n+\t    {\n+\t      fprintf (dump_file, \"\\n   after cselib_expand address: \");\n+\t      print_inline_rtx (dump_file, expanded_address, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n \n-  if (GET_CODE (address) == PLUS && CONST_INT_P (XEXP (address, 1)))\n-    {\n-      *offset = INTVAL (XEXP (address, 1));\n-      address = XEXP (address, 0);\n-    }\n+\t  fprintf (dump_file, \"\\n   after canon_rtx address: \");\n+\t  print_inline_rtx (dump_file, address, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n \n-  if (const_or_frame_p (address))\n-    {\n-      group_info_t group = get_group_info (address);\n+      if (GET_CODE (address) == CONST)\n+\taddress = XEXP (address, 0);\n \n-      if (dump_file)\n-\tfprintf (dump_file, \"  gid=%d offset=%d \\n\", group->id, (int)*offset);\n-      *base = NULL;\n-      *group_id = group->id;\n-    }\n-  else\n-    {\n-      *base = cselib_lookup (address, Pmode, true);\n-      *group_id = -1;\n+      if (GET_CODE (address) == PLUS\n+\t  && CONST_INT_P (XEXP (address, 1)))\n+\t{\n+\t  *offset = INTVAL (XEXP (address, 1));\n+\t  address = XEXP (address, 0);\n+\t}\n \n-      if (*base == NULL)\n+      if (const_or_frame_p (address))\n \t{\n+\t  group_info_t group = get_group_info (address);\n+\n \t  if (dump_file)\n-\t    fprintf (dump_file, \" no cselib val - should be a wild read.\\n\");\n-\t  return false;\n+\t    fprintf (dump_file, \"  gid=%d offset=%d \\n\",\n+\t\t     group->id, (int)*offset);\n+\t  *base = NULL;\n+\t  *group_id = group->id;\n+\t  return true;\n \t}\n+    }\n+\n+  *base = cselib_lookup (address, Pmode, true);\n+  *group_id = -1;\n+\n+  if (*base == NULL)\n+    {\n       if (dump_file)\n-\tfprintf (dump_file, \"  varying cselib base=%d offset = %d\\n\", \n-\t\t (*base)->value, (int)*offset);\n+\tfprintf (dump_file, \" no cselib val - should be a wild read.\\n\");\n+      return false;\n     }\n+  if (dump_file)\n+    fprintf (dump_file, \"  varying cselib base=%d offset = %d\\n\", \n+\t     (*base)->value, (int)*offset);\n   return true;\n }\n "}, {"sha": "e34aa8d8b2e91c2408107d07ab3e3f0198cfe254", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403c752036db9af05c6d40804df668d3f3cbaf52/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403c752036db9af05c6d40804df668d3f3cbaf52/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=403c752036db9af05c6d40804df668d3f3cbaf52", "patch": "@@ -1,3 +1,8 @@\n+2009-08-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/40924\n+\t* g++.dg/torture/pr40924.C: New test.\n+\n 2009-08-05  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c++/36069"}, {"sha": "9140da3ba3bc72765ad83302a77c79cbe0149104", "filename": "gcc/testsuite/g++.dg/torture/pr40924.C", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403c752036db9af05c6d40804df668d3f3cbaf52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr40924.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403c752036db9af05c6d40804df668d3f3cbaf52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr40924.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr40924.C?ref=403c752036db9af05c6d40804df668d3f3cbaf52", "patch": "@@ -0,0 +1,111 @@\n+// PR rtl-optimization/40924\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+\n+#define MAY_ALIAS __attribute__((__may_alias__))\n+\n+typedef struct { float v[2]; } floata;\n+typedef struct { int v[2]; } inta;\n+\n+typedef unsigned int uint MAY_ALIAS;\n+typedef signed int sint MAY_ALIAS;\n+typedef float flt MAY_ALIAS;\n+\n+static inline unsigned short\n+less_than (inta a, inta b)\n+{\n+  unsigned short r = 0;\n+  const uint *p1 = (const uint *) &a;\n+  const uint *p2 = (const uint *) &b;\n+  for (int i=0; i < 2; i++)\n+    if (p1[i] < p2[i]) r |= (1 << i);\n+  return r;\n+}\n+\n+static inline inta\n+multiply (inta b, inta c)\n+{\n+  inta r;\n+  sint *p3 = (sint *) &c;\n+  for (int i=0; i < 2; i++)\n+    r.v[i] = (int) (b.v[i] * p3[i] & 0xFFFFFFFF);\n+  return r;\n+}\n+\n+static inline floata\n+gather (inta indexes, const void *baseAddr)\n+{\n+  floata r;\n+\n+  sint *idx = (sint *) &indexes;\n+  flt *src = (flt *) baseAddr;\n+  for (int i=0; i < 2; i++)\n+    r.v[i] = *(src + idx[i]);\n+  return r;\n+}\n+\n+static inline inta\n+add (const inta &b, const inta &c)\n+{\n+  inta result;\n+  sint *r = (sint *) &result;\n+\n+  for (int i=0; i < 2; i++)\n+    r[i] = b.v[i] + c.v[i];\n+  return result;\n+}\n+\n+struct uintv\n+{\n+  inta data;\n+  inline uintv () { data.v[0] = 0; data.v[1] = 1; }\n+  inline uintv (unsigned int a)\n+  {\n+    for (int i=0; i < 2; i++)\n+      *(uint *) &data.v[i] = a;\n+  }\n+  inline uintv (inta x) : data (x) {}\n+  inline uintv operator* (const uintv &x) const\n+  { return multiply (data, x.data); }\n+  inline uintv operator+ (const uintv &x) const\n+  { return uintv (add (data, x.data)); }\n+  inline unsigned short operator< (const uintv &x) const\n+  { return less_than (data, x.data); }\n+};\n+\n+struct floatv\n+{\n+  floata data;\n+  explicit inline floatv (const uintv &x)\n+  {\n+    uint *p2 = (uint *) &x.data;\n+    for (int i=0; i < 2; i++)\n+      data.v[i] = p2[i];\n+  }\n+  inline floatv (const float *array, const uintv &indexes)\n+  {\n+    const uintv &offsets = indexes * uintv (1);\n+    data = gather (offsets.data, array);\n+  }\n+  unsigned short operator== (const floatv &x) const\n+  {\n+    unsigned short r = 0;\n+    for (int i=0; i < 2; i++)\n+      if (data.v[i] == x.data.v[i]) r |= (1 << i);\n+    return r;\n+  }\n+};\n+\n+int\n+main ()\n+{\n+  const float array[2] = { 2, 3 };\n+  for (uintv i; (i < 2) == 3; i = i + 2)\n+    {\n+      const floatv ii (i + 2);\n+      floatv a (array, i);\n+      if ((a == ii) != 3)\n+\tabort ();\n+    }\n+}"}]}