{"sha": "de99511b75b9c9a8c85b77f1019041a280da45bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU5OTUxMWI3NWI5YzlhOGM4NWI3N2YxMDE5MDQxYTI4MGRhNDViZg==", "commit": {"author": {"name": "J. Brobecker", "email": "brobecker@gnat.com", "date": "2004-01-09T14:08:21Z"}, "committer": {"name": "Joel Brobecker", "email": "brobecke@gcc.gnu.org", "date": "2004-01-09T14:08:21Z"}, "message": "dwarf2out.c (gen_enumeration_type_die): Return the DIE that we just created.\n\n        * dwarf2out.c (gen_enumeration_type_die): Return the DIE that\n        we just created.\n        (is_ada_subrange_type): DIEs for enumeration subtypes should be\n        emitted as subrange types too.\n        (subrange_type_die): Add handling of enumeration subtypes.\n\nFrom-SVN: r75582", "tree": {"sha": "9cf823123dad10932c60b71b6f318d801966df66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cf823123dad10932c60b71b6f318d801966df66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de99511b75b9c9a8c85b77f1019041a280da45bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de99511b75b9c9a8c85b77f1019041a280da45bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de99511b75b9c9a8c85b77f1019041a280da45bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de99511b75b9c9a8c85b77f1019041a280da45bf/comments", "author": null, "committer": null, "parents": [{"sha": "41b19a2d9a81731ff3199c9a2318ee1ed7fecf9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41b19a2d9a81731ff3199c9a2318ee1ed7fecf9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41b19a2d9a81731ff3199c9a2318ee1ed7fecf9f"}], "stats": {"total": 49, "additions": 39, "deletions": 10}, "files": [{"sha": "ef58d8fe35af9eac0d16bc77c609fe24d65f5a07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de99511b75b9c9a8c85b77f1019041a280da45bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de99511b75b9c9a8c85b77f1019041a280da45bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de99511b75b9c9a8c85b77f1019041a280da45bf", "patch": "@@ -1,3 +1,11 @@\n+2004-01-09  J. Brobecker  <brobecker@gnat.com>\n+\n+\t* dwarf2out.c (gen_enumeration_type_die): Return the DIE that\n+\twe just created.\n+\t(is_ada_subrange_type): DIEs for enumeration subtypes should be\n+\temitted as subrange types too.\n+\t(subrange_type_die): Add handling of enumeration subtypes.\n+\n 2004-01-08  Richard Henderson  <rth@redhat.com>\n \n \tPR opt/12441"}, {"sha": "ea68216c3a8be6820a8321562766e4a8302e6008", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de99511b75b9c9a8c85b77f1019041a280da45bf/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de99511b75b9c9a8c85b77f1019041a280da45bf/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=de99511b75b9c9a8c85b77f1019041a280da45bf", "patch": "@@ -3755,7 +3755,7 @@ static void gen_entry_point_die (tree, dw_die_ref);\n static void gen_inlined_enumeration_type_die (tree, dw_die_ref);\n static void gen_inlined_structure_type_die (tree, dw_die_ref);\n static void gen_inlined_union_type_die (tree, dw_die_ref);\n-static void gen_enumeration_type_die (tree, dw_die_ref);\n+static dw_die_ref gen_enumeration_type_die (tree, dw_die_ref);\n static dw_die_ref gen_formal_parameter_die (tree, dw_die_ref);\n static void gen_unspecified_parameters_die (tree, dw_die_ref);\n static void gen_formal_types_die (tree, dw_die_ref);\n@@ -7807,12 +7807,28 @@ simple_type_size_in_bits (tree type)\n static inline bool\n is_ada_subrange_type (tree type)\n {\n-  /* We do this for INTEGER_TYPEs that have names, parent types, and when\n-     we are compiling Ada code.  */\n-  return (TREE_CODE (type) == INTEGER_TYPE\n-\t  && TYPE_NAME (type) != 0 && TREE_TYPE (type) != 0\n-\t  && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n-\t  && TREE_UNSIGNED (TREE_TYPE (type)) && is_ada ());\n+  /* We should use a subrange type in the following situations:\n+     - For Ada modular types: These types are stored as integer subtypes\n+       of an unsigned integer type;\n+     - For subtypes of an Ada enumeration type: These types are stored\n+       as integer subtypes of enumeral types.\n+     \n+     This subrange type is mostly for the benefit of debugger users.\n+     A nameless type would therefore not be very useful, so no need\n+     to generate a subrange type in these cases.  */\n+  tree subtype = TREE_TYPE (type);\n+\n+  if (is_ada ()\n+      && TREE_CODE (type) == INTEGER_TYPE\n+      && TYPE_NAME (type) != NULL_TREE\n+      && subtype != NULL_TREE)\n+    {\n+      if (TREE_CODE (subtype) == INTEGER_TYPE && TREE_UNSIGNED (subtype))\n+        return true;\n+      if (TREE_CODE (subtype) == ENUMERAL_TYPE)\n+        return true;\n+    }\n+  return false;\n }\n \n /*  Given a pointer to a tree node for a subrange type, return a pointer\n@@ -7828,7 +7844,10 @@ subrange_type_die (tree type, dw_die_ref context_die)\n   if (context_die == NULL)\n     context_die = comp_unit_die;\n \n-  subtype_die = base_type_die (TREE_TYPE (type));\n+  if (TREE_CODE (TREE_TYPE (type)) == ENUMERAL_TYPE)\n+    subtype_die = gen_enumeration_type_die (TREE_TYPE (type), context_die);\n+  else\n+    subtype_die = base_type_die (TREE_TYPE (type));\n \n   if (TREE_CODE (name) == TYPE_DECL)\n     name = DECL_NAME (name);\n@@ -10346,7 +10365,7 @@ gen_inlined_union_type_die (tree type, dw_die_ref context_die)\n    enumerated type name/value is listed as a child of the enumerated type\n    DIE.  */\n \n-static void\n+static dw_die_ref\n gen_enumeration_type_die (tree type, dw_die_ref context_die)\n {\n   dw_die_ref type_die = lookup_type_die (type);\n@@ -10359,7 +10378,7 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n       add_name_attribute (type_die, type_tag (type));\n     }\n   else if (! TYPE_SIZE (type))\n-    return;\n+    return type_die;\n   else\n     remove_AT (type_die, DW_AT_declaration);\n \n@@ -10402,6 +10421,8 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n     }\n   else\n     add_AT_flag (type_die, DW_AT_declaration, 1);\n+\n+  return type_die;\n }\n \n /* Generate a DIE to represent either a real live formal parameter decl or to"}]}