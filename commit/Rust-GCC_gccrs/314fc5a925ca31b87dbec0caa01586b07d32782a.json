{"sha": "314fc5a925ca31b87dbec0caa01586b07d32782a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE0ZmM1YTkyNWNhMzFiODdkYmVjMGNhYTAxNTg2YjA3ZDMyNzgyYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1994-02-14T04:50:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1994-02-14T04:50:40Z"}, "message": "(output_epilog): Don't output a traceback table if\nflag_inhibit_size_directive is set.\n\nFrom-SVN: r6551", "tree": {"sha": "eb118189c94ae482692ea302255379a6ea2ab3be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb118189c94ae482692ea302255379a6ea2ab3be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/314fc5a925ca31b87dbec0caa01586b07d32782a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314fc5a925ca31b87dbec0caa01586b07d32782a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/314fc5a925ca31b87dbec0caa01586b07d32782a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314fc5a925ca31b87dbec0caa01586b07d32782a/comments", "author": null, "committer": null, "parents": [{"sha": "b0634e74674b37204acd5e6c5db534c80cc775b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0634e74674b37204acd5e6c5db534c80cc775b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0634e74674b37204acd5e6c5db534c80cc775b1"}], "stats": {"total": 344, "additions": 180, "deletions": 164}, "files": [{"sha": "e063e897b21b9738299168c7113e21c746f73e71", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 180, "deletions": 164, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/314fc5a925ca31b87dbec0caa01586b07d32782a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/314fc5a925ca31b87dbec0caa01586b07d32782a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=314fc5a925ca31b87dbec0caa01586b07d32782a", "patch": "@@ -1583,177 +1583,193 @@ output_epilog (file, size)\n     }\n \n   /* Output a traceback table here.  See /usr/include/sys/debug.h for info\n-     on its format.  */\n-  {\n-    char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-    int fixed_parms, float_parms, parm_info;\n-    int i;\n-\n-    /* Need label immediately before tbtab, so we can compute its offset\n-       from the function start.  */\n-    if (*fname == '*')\n-      ++fname;\n-    ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LT\");\n-    ASM_OUTPUT_LABEL (file, fname);\n-\n-    /* The .tbtab pseudo-op can only be used for the first eight\n-       expressions, since it can't handle the possibly variable length\n-       fields that follow.  However, if you omit the optional fields,\n-       the assembler outputs zeros for all optional fields anyways, giving each\n-       variable length field is minimum length (as defined in sys/debug.h).\n-       Thus we can not use the .tbtab pseudo-op at all.  */\n-\n-    /* An all-zero word flags the start of the tbtab, for debuggers that have\n-       to find it by searching forward from the entry point or from the\n-       current pc.  */\n-    fprintf (file, \"\\t.long 0\\n\");\n-\n-    /* Tbtab format type.  Use format type 0.  */\n-    fprintf (file, \"\\t.byte 0,\");\n-\n-    /* Language type.  Unfortunately, there doesn't seem to be any official way\n-       to get this info, so we use language_string.  C is 0.  C++ is 9.\n-       No number defined for Obj-C, so use the value for C for now.  */\n-    if (! strcmp (language_string, \"GNU C\")\n-\t|| ! strcmp (language_string, \"GNU Obj-C\"))\n-      i = 0;\n-    else if (! strcmp (language_string, \"GNU F77\"))\n-      i = 1;\n-    else if (! strcmp (language_string, \"GNU Ada\"))\n-      i = 3;\n-    else if (! strcmp (language_string, \"GNU PASCAL\"))\n-      i = 2;\n-    else if (! strcmp (language_string, \"GNU C++\"))\n-      i = 9;\n-    else\n-      abort ();\n-    fprintf (file, \"%d,\", i);\n-\n-    /* 8 single bit fields: global linkage (not set for C extern linkage,\n-       apparently a PL/I convention?), out-of-line epilogue/prologue, offset\n-       from start of procedure stored in tbtab, internal function, function\n-       has controlled storage, function has no toc, function uses fp,\n-       function logs/aborts fp operations.  */\n-    /* Assume that fp operations are used if any fp reg must be saved.  */\n-    fprintf (file, \"%d,\", (1 << 5) | ((first_fp_reg != 64) << 1));\n-\n-    /* 6 bitfields: function is interrupt handler, name present in proc table,\n-       function calls alloca, on condition directives (controls stack walks,\n-       3 bits), saves condition reg, saves link reg.  */\n-    /* The `function calls alloca' bit seems to be set whenever reg 31 is\n-       set up as a frame pointer, even when there is no alloca call.  */\n-    fprintf (file, \"%d,\",\n-\t     ((1 << 6) | (frame_pointer_needed << 5)\n-\t      | (must_save_cr () << 1) | (regs_ever_live[65])));\n-\n-    /* 3 bitfields: saves backchain, spare bit, number of fpr saved\n-       (6 bits).  */\n-    fprintf (file, \"%d,\",\n-\t     (must_push << 7) | (64 - first_fp_reg_to_save ()));\n-\n-    /* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */\n-    fprintf (file, \"%d,\", (32 - first_reg_to_save ()));\n-\n+     on its format.\n+\n+     We don't output a traceback table if -finhibit-size-directive was\n+     used.  The documentation for -finhibit-size-directive reads\n+     ``don't output a @code{.size} assembler directive, or anything\n+     else that would cause trouble if the function is split in the\n+     middle, and the two halves are placed at locations far apart in\n+     memory.''  The traceback table has this property, since it\n+     includes the offset from the start of the function to the\n+     traceback table itself.  */\n+  if (! flag_inhibit_size_directive)\n     {\n-      /* Compute the parameter info from the function decl argument list.  */\n-      tree decl;\n-      int next_parm_info_bit;\n-\n-      next_parm_info_bit = 31;\n-      parm_info = 0;\n-      fixed_parms = 0;\n-      float_parms = 0;\n-\n-      for (decl = DECL_ARGUMENTS (current_function_decl);\n-\t   decl; decl = TREE_CHAIN (decl))\n-\t{\n-\t  rtx parameter = DECL_INCOMING_RTL (decl);\n-\t  enum machine_mode mode = GET_MODE (parameter);\n-\n-\t  if (GET_CODE (parameter) == REG)\n-\t    {\n-\t      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t\t{\n-\t\t  int bits;\n-\n-\t\t  float_parms++;\n-\n-\t\t  if (mode == SFmode)\n-\t\t    bits = 0x2;\n-\t\t  else if (mode == DFmode)\n-\t\t    bits = 0x3;\n-\t\t  else\n-\t\t    abort ();\n-\n-\t\t  /* If only one bit will fit, don't or in this entry.  */\n-\t\t  if (next_parm_info_bit > 0)\n-\t\t    parm_info |= (bits << (next_parm_info_bit - 1));\n-\t\t  next_parm_info_bit -= 2;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fixed_parms += ((GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1))\n-\t\t\t\t  / UNITS_PER_WORD);\n-\t\t  next_parm_info_bit -= 1;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-    /* Number of fixed point parameters.  */\n-    /* This is actually the number of words of fixed point parameters; thus\n-       an 8 byte struct counts as 2; and thus the maximum value is 8.  */\n-    fprintf (file, \"%d,\", fixed_parms);\n-\n-    /* 2 bitfields: number of floating point parameters (7 bits), parameters\n-       all on stack.  */\n-    /* This is actually the number of fp registers that hold parameters;\n-       and thus the maximum value is 13.  */\n-    /* Set parameters on stack bit if parameters are not in their original\n-       registers, regardless of whether they are on the stack?  Xlc\n-       seems to set the bit when not optimizing.  */\n-    fprintf (file, \"%d\\n\", ((float_parms << 1) | (! optimize)));\n-\n-    /* Optional fields follow.  Some are variable length.  */\n-\n-    /* Parameter types, left adjusted bit fields: 0 fixed, 10 single float,\n-       11 double float.  */\n-    /* There is an entry for each parameter in a register, in the order that\n-       they occur in the parameter list.  Any intervening arguments on the\n-       stack are ignored.  If the list overflows a long (max possible length\n-       34 bits) then completely leave off all elements that don't fit.  */\n-    /* Only emit this long if there was at least one parameter.  */\n-    if (fixed_parms || float_parms)\n-      fprintf (file, \"\\t.long %d\\n\", parm_info);\n-\n-    /* Offset from start of code to tb table.  */\n-    fprintf (file, \"\\t.long \");\n-    ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LT\");\n-    RS6000_OUTPUT_BASENAME (file, fname);\n-    fprintf (file, \"-.\");\n-    RS6000_OUTPUT_BASENAME (file, fname);\n-    fprintf (file, \"\\n\");\n+      char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+      int fixed_parms, float_parms, parm_info;\n+      int i;\n+\n+      /* Need label immediately before tbtab, so we can compute its offset\n+\t from the function start.  */\n+      if (*fname == '*')\n+\t++fname;\n+      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LT\");\n+      ASM_OUTPUT_LABEL (file, fname);\n+\n+      /* The .tbtab pseudo-op can only be used for the first eight\n+\t expressions, since it can't handle the possibly variable\n+\t length fields that follow.  However, if you omit the optional\n+\t fields, the assembler outputs zeros for all optional fields\n+\t anyways, giving each variable length field is minimum length\n+\t (as defined in sys/debug.h).  Thus we can not use the .tbtab\n+\t pseudo-op at all.  */\n+\n+      /* An all-zero word flags the start of the tbtab, for debuggers\n+\t that have to find it by searching forward from the entry\n+\t point or from the current pc.  */\n+      fprintf (file, \"\\t.long 0\\n\");\n+\n+      /* Tbtab format type.  Use format type 0.  */\n+      fprintf (file, \"\\t.byte 0,\");\n+\n+      /* Language type.  Unfortunately, there doesn't seem to be any\n+\t official way to get this info, so we use language_string.  C\n+\t is 0.  C++ is 9.  No number defined for Obj-C, so use the\n+\t value for C for now.  */\n+      if (! strcmp (language_string, \"GNU C\")\n+\t  || ! strcmp (language_string, \"GNU Obj-C\"))\n+\ti = 0;\n+      else if (! strcmp (language_string, \"GNU F77\"))\n+\ti = 1;\n+      else if (! strcmp (language_string, \"GNU Ada\"))\n+\ti = 3;\n+      else if (! strcmp (language_string, \"GNU PASCAL\"))\n+\ti = 2;\n+      else if (! strcmp (language_string, \"GNU C++\"))\n+\ti = 9;\n+      else\n+\tabort ();\n+      fprintf (file, \"%d,\", i);\n+\n+      /* 8 single bit fields: global linkage (not set for C extern linkage,\n+\t apparently a PL/I convention?), out-of-line epilogue/prologue, offset\n+\t from start of procedure stored in tbtab, internal function, function\n+\t has controlled storage, function has no toc, function uses fp,\n+\t function logs/aborts fp operations.  */\n+      /* Assume that fp operations are used if any fp reg must be saved.  */\n+      fprintf (file, \"%d,\", (1 << 5) | ((first_fp_reg != 64) << 1));\n+\n+      /* 6 bitfields: function is interrupt handler, name present in\n+\t proc table, function calls alloca, on condition directives\n+\t (controls stack walks, 3 bits), saves condition reg, saves\n+\t link reg.  */\n+      /* The `function calls alloca' bit seems to be set whenever reg 31 is\n+\t set up as a frame pointer, even when there is no alloca call.  */\n+      fprintf (file, \"%d,\",\n+\t       ((1 << 6) | (frame_pointer_needed << 5)\n+\t\t| (must_save_cr () << 1) | (regs_ever_live[65])));\n+\n+      /* 3 bitfields: saves backchain, spare bit, number of fpr saved\n+\t (6 bits).  */\n+      fprintf (file, \"%d,\",\n+\t       (must_push << 7) | (64 - first_fp_reg_to_save ()));\n+\n+      /* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */\n+      fprintf (file, \"%d,\", (32 - first_reg_to_save ()));\n+\n+      {\n+\t/* Compute the parameter info from the function decl argument\n+\t   list.  */\n+\ttree decl;\n+\tint next_parm_info_bit;\n+\n+\tnext_parm_info_bit = 31;\n+\tparm_info = 0;\n+\tfixed_parms = 0;\n+\tfloat_parms = 0;\n+\n+\tfor (decl = DECL_ARGUMENTS (current_function_decl);\n+\t     decl; decl = TREE_CHAIN (decl))\n+\t  {\n+\t    rtx parameter = DECL_INCOMING_RTL (decl);\n+\t    enum machine_mode mode = GET_MODE (parameter);\n+\n+\t    if (GET_CODE (parameter) == REG)\n+\t      {\n+\t\tif (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t\t  {\n+\t\t    int bits;\n+\n+\t\t    float_parms++;\n+\n+\t\t    if (mode == SFmode)\n+\t\t      bits = 0x2;\n+\t\t    else if (mode == DFmode)\n+\t\t      bits = 0x3;\n+\t\t    else\n+\t\t      abort ();\n+\n+\t\t    /* If only one bit will fit, don't or in this entry.  */\n+\t\t    if (next_parm_info_bit > 0)\n+\t\t      parm_info |= (bits << (next_parm_info_bit - 1));\n+\t\t    next_parm_info_bit -= 2;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    fixed_parms += ((GET_MODE_SIZE (mode)\n+\t\t\t\t     + (UNITS_PER_WORD - 1))\n+\t\t\t\t    / UNITS_PER_WORD);\n+\t\t    next_parm_info_bit -= 1;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+      /* Number of fixed point parameters.  */\n+      /* This is actually the number of words of fixed point parameters; thus\n+\t an 8 byte struct counts as 2; and thus the maximum value is 8.  */\n+      fprintf (file, \"%d,\", fixed_parms);\n+\n+      /* 2 bitfields: number of floating point parameters (7 bits), parameters\n+\t all on stack.  */\n+      /* This is actually the number of fp registers that hold parameters;\n+\t and thus the maximum value is 13.  */\n+      /* Set parameters on stack bit if parameters are not in their original\n+\t registers, regardless of whether they are on the stack?  Xlc\n+\t seems to set the bit when not optimizing.  */\n+      fprintf (file, \"%d\\n\", ((float_parms << 1) | (! optimize)));\n+\n+      /* Optional fields follow.  Some are variable length.  */\n+\n+      /* Parameter types, left adjusted bit fields: 0 fixed, 10 single float,\n+\t 11 double float.  */\n+      /* There is an entry for each parameter in a register, in the order that\n+\t they occur in the parameter list.  Any intervening arguments on the\n+\t stack are ignored.  If the list overflows a long (max possible length\n+\t 34 bits) then completely leave off all elements that don't fit.  */\n+      /* Only emit this long if there was at least one parameter.  */\n+      if (fixed_parms || float_parms)\n+\tfprintf (file, \"\\t.long %d\\n\", parm_info);\n+\n+      /* Offset from start of code to tb table.  */\n+      fprintf (file, \"\\t.long \");\n+      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LT\");\n+      RS6000_OUTPUT_BASENAME (file, fname);\n+      fprintf (file, \"-.\");\n+      RS6000_OUTPUT_BASENAME (file, fname);\n+      fprintf (file, \"\\n\");\n \n-    /* Interrupt handler mask.  */\n-    /* Omit this long, since we never set the interrupt handler bit above.  */\n+      /* Interrupt handler mask.  */\n+      /* Omit this long, since we never set the interrupt handler bit\n+\t above.  */\n \n-    /* Number of CTL (controlled storage) anchors.  */\n-    /* Omit this long, since the has_ctl bit is never set above.  */\n+      /* Number of CTL (controlled storage) anchors.  */\n+      /* Omit this long, since the has_ctl bit is never set above.  */\n \n-    /* Displacement into stack of each CTL anchor.  */\n-    /* Omit this list of longs, because there are no CTL anchors.  */\n+      /* Displacement into stack of each CTL anchor.  */\n+      /* Omit this list of longs, because there are no CTL anchors.  */\n \n-    /* Length of function name.  */\n-    fprintf (file, \"\\t.short %d\\n\", strlen (fname));\n+      /* Length of function name.  */\n+      fprintf (file, \"\\t.short %d\\n\", strlen (fname));\n \n-    /* Function name.  */\n-    assemble_string (fname, strlen (fname));\n+      /* Function name.  */\n+      assemble_string (fname, strlen (fname));\n \n-    /* Register for alloca automatic storage; this is always reg 31.\n-       Only emit this if the alloca bit was set above.  */\n-    if (frame_pointer_needed)\n-      fprintf (file, \"\\t.byte 31\\n\");\n-  }\n+      /* Register for alloca automatic storage; this is always reg 31.\n+\t Only emit this if the alloca bit was set above.  */\n+      if (frame_pointer_needed)\n+\tfprintf (file, \"\\t.byte 31\\n\");\n+    }\n }\n \f\n /* Output a TOC entry.  We derive the entry name from what is"}]}