{"sha": "0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFlYTY0NjdkNTAyMmUzODU4YmZlZDVjZTVkMjRhYTg3N2JmZWQxYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-05-19T17:53:45Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-05-19T17:53:45Z"}, "message": "Multiple fixes: PRs 14692, 15274 and 15463\n\n\tPR c++/15463\n\t* loop-iv.c (iv_number_of_iterations):  Use trunc_int_for_mode on\n\tresult of inverse.\n\n\tPR rtl-optimization/15274\n\t* loop-iv.c (determine_max_iter, shorten_into_mode,\n\tiv_number_of_iterations): Handle constants correctly.\n\t* rtl.h (get_mode_bounds): Declaration changed.\n\t* stor-layout.c (get_mode_bounds): Return a constant suitable for\n\tthe target mode.\n\n\tPR rtl-optimization/14692\n\t* loop-unswitch.c (may_unswitch_on): Try folding the result.\n\t(unswitch_single_loop): Work correctly when may_unswitch_on\n\treturns a folded constant.\n\n\t* loop-iv.c (implies_p): Handle A < B ==> A + 1 <= B.\n\t* simplify-rtx.c (simplify_const_relational_operation): Optimize\n\tcomparisons with mode bounds.\n\n\t* function.c (struct temp_slot): Add new field prev.\n\t(free_after_compilation, init_temp_slots): Free new fields.\n\t(cut_slot_from_list, insert_slot_to_list,\n\ttemp_slots_at_level, max_slot_level, move_slot_to_level,\n\tmake_slot_available): New functions.\n\t(assign_stack_temp_for_type, combine_temp_slots,\n\tfind_temp_slot_from_address, preserve_temp_slots,\n\tpreserve_rtl_expr_result, free_temp_slots,\n\tfree_temps_for_rtl_expr, pop_temp_slots): Work with\n\tthe new structure of lists.\n\t(mark_all_temps_used): Removed.\n\t* function.h (struct function): Field x_temp_slots\n\treplaced by x_used_temp_slots and x_avail_temp_slots.\n\t(temp_slots): Replaced by ...\n\t(used_temp_slots, avail_temp_slots): New.\n\t* tree.h (mark_all_temps_used): Declaration removed.\n\n\t* loop-iv.c (mark_single_set, get_biv_step_1, iv_analyze,\n\tsimplify_using_assignment): Take the expression out of\n\tthe expr_list wrapper.\n\n\t* loop-iv.c (iv_number_of_iterations): Improve clasification of\n\tinfinite loops.\n\nFrom-SVN: r82028", "tree": {"sha": "0b36d07ee82475415ae29e4414267b5f3dd44411", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b36d07ee82475415ae29e4414267b5f3dd44411"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/comments", "author": null, "committer": null, "parents": [{"sha": "20cb64fd5cc597d456961e2d223c386c5950416c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20cb64fd5cc597d456961e2d223c386c5950416c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20cb64fd5cc597d456961e2d223c386c5950416c"}], "stats": {"total": 675, "additions": 470, "deletions": 205}, "files": [{"sha": "673dae6791aa8fba8f4518d7d1e659cdd1b3b40e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -1,3 +1,49 @@\n+2004-05-19  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\tPR c++/15463\n+\t* loop-iv.c (iv_number_of_iterations):  Use trunc_int_for_mode on\n+\tresult of inverse.\n+\n+\tPR rtl-optimization/15274\n+\t* loop-iv.c (determine_max_iter, shorten_into_mode,\n+\tiv_number_of_iterations): Handle constants correctly.\n+\t* rtl.h (get_mode_bounds): Declaration changed.\n+\t* stor-layout.c (get_mode_bounds): Return a constant suitable for\n+\tthe target mode.\n+\n+\tPR rtl-optimization/14692\n+\t* loop-unswitch.c (may_unswitch_on): Try folding the result.\n+\t(unswitch_single_loop): Work correctly when may_unswitch_on\n+\treturns a folded constant.\n+\n+\t* loop-iv.c (implies_p): Handle A < B ==> A + 1 <= B.\n+\t* simplify-rtx.c (simplify_const_relational_operation): Optimize\n+\tcomparisons with mode bounds.\n+\n+\t* function.c (struct temp_slot): Add new field prev.\n+\t(free_after_compilation, init_temp_slots): Free new fields.\n+\t(cut_slot_from_list, insert_slot_to_list,\n+\ttemp_slots_at_level, max_slot_level, move_slot_to_level,\n+\tmake_slot_available): New functions.\n+\t(assign_stack_temp_for_type, combine_temp_slots,\n+\tfind_temp_slot_from_address, preserve_temp_slots,\n+\tpreserve_rtl_expr_result, free_temp_slots,\n+\tfree_temps_for_rtl_expr, pop_temp_slots): Work with\n+\tthe new structure of lists.\n+\t(mark_all_temps_used): Removed.\n+\t* function.h (struct function): Field x_temp_slots\n+\treplaced by x_used_temp_slots and x_avail_temp_slots.\n+\t(temp_slots): Replaced by ...\n+\t(used_temp_slots, avail_temp_slots): New.\n+\t* tree.h (mark_all_temps_used): Declaration removed.\n+\n+\t* loop-iv.c (mark_single_set, get_biv_step_1, iv_analyze,\n+\tsimplify_using_assignment): Take the expression out of\n+\tthe expr_list wrapper.\n+\n+\t* loop-iv.c (iv_number_of_iterations): Improve clasification of\n+\tinfinite loops.\n+\n 2004-05-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* doc/tm.texi (TARGET_RTX_COSTS): Document that instruction"}, {"sha": "4c535c713836852e8b04ede4d1d29732657d4a38", "filename": "gcc/function.c", "status": "modified", "additions": 230, "deletions": 135, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -168,6 +168,9 @@ struct temp_slot GTY(())\n {\n   /* Points to next temporary slot.  */\n   struct temp_slot *next;\n+  /* Points to previous temporary slot.  */\n+  struct temp_slot *prev;\n+\n   /* The rtx to used to reference the slot.  */\n   rtx slot;\n   /* The rtx used to represent the address if not the address of the\n@@ -427,7 +430,8 @@ free_after_compilation (struct function *f)\n   f->varasm = NULL;\n   f->machine = NULL;\n \n-  f->x_temp_slots = NULL;\n+  f->x_avail_temp_slots = NULL;\n+  f->x_used_temp_slots = NULL;\n   f->arg_offset_rtx = NULL;\n   f->return_rtx = NULL;\n   f->internal_arg_pointer = NULL;\n@@ -605,6 +609,82 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n {\n   return assign_stack_local_1 (mode, size, align, cfun);\n }\n+\n+\f\n+/* Removes temporary slot TEMP from LIST.  */\n+\n+static void\n+cut_slot_from_list (struct temp_slot *temp, struct temp_slot **list)\n+{\n+  if (temp->next)\n+    temp->next->prev = temp->prev;\n+  if (temp->prev)\n+    temp->prev->next = temp->next;\n+  else\n+    *list = temp->next;\n+\n+  temp->prev = temp->next = NULL;\n+}\n+\n+/* Inserts temporary slot TEMP to LIST.  */\n+\n+static void\n+insert_slot_to_list (struct temp_slot *temp, struct temp_slot **list)\n+{\n+  temp->next = *list;\n+  if (*list)\n+    (*list)->prev = temp;\n+  temp->prev = NULL;\n+  *list = temp;\n+}\n+\n+/* Returns the list of used temp slots at LEVEL.  */\n+\n+static struct temp_slot **\n+temp_slots_at_level (int level)\n+{\n+  level++;\n+\n+  if (!used_temp_slots)\n+    VARRAY_GENERIC_PTR_INIT (used_temp_slots, 3, \"used_temp_slots\");\n+\n+  while (level >= (int) VARRAY_ACTIVE_SIZE (used_temp_slots))\n+    VARRAY_PUSH_GENERIC_PTR (used_temp_slots, NULL);\n+\n+  return (struct temp_slot **) &VARRAY_GENERIC_PTR (used_temp_slots, level);\n+}\n+\n+/* Returns the maximal temporary slot level.  */\n+\n+static int\n+max_slot_level (void)\n+{\n+  if (!used_temp_slots)\n+    return -1;\n+\n+  return VARRAY_ACTIVE_SIZE (used_temp_slots) - 1;\n+}\n+\n+/* Moves temporary slot TEMP to LEVEL.  */\n+\n+static void\n+move_slot_to_level (struct temp_slot *temp, int level)\n+{\n+  cut_slot_from_list (temp, temp_slots_at_level (temp->level));\n+  insert_slot_to_list (temp, temp_slots_at_level (level));\n+  temp->level = level;\n+}\n+\n+/* Make temporary slot TEMP available.  */\n+\n+static void\n+make_slot_available (struct temp_slot *temp)\n+{\n+  cut_slot_from_list (temp, temp_slots_at_level (temp->level));\n+  insert_slot_to_list (temp, &avail_temp_slots);\n+  temp->in_use = 0;\n+  temp->level = -1;\n+}\n \f\n /* Allocate a temporary stack slot and record it for possible later\n    reuse.\n@@ -628,7 +708,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n \t\t\t    tree type)\n {\n   unsigned int align;\n-  struct temp_slot *p, *best_p = 0;\n+  struct temp_slot *p, *best_p = 0, *selected = NULL, **pp;\n   rtx slot;\n \n   /* If SIZE is -1 it means that somebody tried to allocate a temporary\n@@ -650,24 +730,30 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n   /* Try to find an available, already-allocated temporary of the proper\n      mode which meets the size and alignment requirements.  Choose the\n      smallest one with the closest alignment.  */\n-  for (p = temp_slots; p; p = p->next)\n-    if (p->align >= align && p->size >= size && GET_MODE (p->slot) == mode\n-\t&& ! p->in_use\n-\t&& objects_must_conflict_p (p->type, type)\n-\t&& (best_p == 0 || best_p->size > p->size\n-\t    || (best_p->size == p->size && best_p->align > p->align)))\n-      {\n-\tif (p->align == align && p->size == size)\n-\t  {\n-\t    best_p = 0;\n-\t    break;\n-\t  }\n-\tbest_p = p;\n-      }\n+  for (p = avail_temp_slots; p; p = p->next)\n+    {\n+      if (p->align >= align && p->size >= size && GET_MODE (p->slot) == mode\n+\t  && objects_must_conflict_p (p->type, type)\n+\t  && (best_p == 0 || best_p->size > p->size\n+\t      || (best_p->size == p->size && best_p->align > p->align)))\n+\t{\n+\t  if (p->align == align && p->size == size)\n+\t    {\n+\t      selected = p;\n+\t      cut_slot_from_list (selected, &avail_temp_slots);\n+\t      best_p = 0;\n+\t      break;\n+\t    }\n+\t  best_p = p;\n+\t}\n+    }\n \n   /* Make our best, if any, the one to use.  */\n   if (best_p)\n     {\n+      selected = best_p;\n+      cut_slot_from_list (selected, &avail_temp_slots);\n+\n       /* If there are enough aligned bytes left over, make them into a new\n \t temp_slot so that the extra bytes don't get wasted.  Do this only\n \t for BLKmode slots, so that we can be sure of the alignment.  */\n@@ -690,8 +776,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n \t      p->address = 0;\n \t      p->rtl_expr = 0;\n \t      p->type = best_p->type;\n-\t      p->next = temp_slots;\n-\t      temp_slots = p;\n+\t      insert_slot_to_list (p, &avail_temp_slots);\n \n \t      stack_slot_list = gen_rtx_EXPR_LIST (VOIDmode, p->slot,\n \t\t\t\t\t\t   stack_slot_list);\n@@ -700,12 +785,10 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n \t      best_p->full_size = rounded_size;\n \t    }\n \t}\n-\n-      p = best_p;\n     }\n \n   /* If we still didn't find one, make a new temporary.  */\n-  if (p == 0)\n+  if (selected == 0)\n     {\n       HOST_WIDE_INT frame_offset_old = frame_offset;\n \n@@ -750,10 +833,11 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n       p->full_size = frame_offset - frame_offset_old;\n #endif\n       p->address = 0;\n-      p->next = temp_slots;\n-      temp_slots = p;\n+\n+      selected = p;\n     }\n \n+  p = selected;\n   p->in_use = 1;\n   p->addr_taken = 0;\n   p->rtl_expr = seq_rtl_expr;\n@@ -775,6 +859,8 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n       p->keep = keep;\n     }\n \n+  pp = temp_slots_at_level (p->level);\n+  insert_slot_to_list (p, pp);\n \n   /* Create a new MEM rtx to avoid clobbering MEM flags of old slots.  */\n   slot = gen_rtx_MEM (mode, XEXP (p->slot, 0));\n@@ -888,8 +974,7 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n void\n combine_temp_slots (void)\n {\n-  struct temp_slot *p, *q;\n-  struct temp_slot *prev_p, *prev_q;\n+  struct temp_slot *p, *q, *next, *next_q;\n   int num_slots;\n \n   /* We can't combine slots, because the information about which slot\n@@ -900,52 +985,50 @@ combine_temp_slots (void)\n   /* If there are a lot of temp slots, don't do anything unless\n      high levels of optimization.  */\n   if (! flag_expensive_optimizations)\n-    for (p = temp_slots, num_slots = 0; p; p = p->next, num_slots++)\n+    for (p = avail_temp_slots, num_slots = 0; p; p = p->next, num_slots++)\n       if (num_slots > 100 || (num_slots > 10 && optimize == 0))\n \treturn;\n \n-  for (p = temp_slots, prev_p = 0; p; p = prev_p ? prev_p->next : temp_slots)\n+  for (p = avail_temp_slots; p; p = next)\n     {\n       int delete_p = 0;\n \n-      if (! p->in_use && GET_MODE (p->slot) == BLKmode)\n-\tfor (q = p->next, prev_q = p; q; q = prev_q->next)\n-\t  {\n-\t    int delete_q = 0;\n-\t    if (! q->in_use && GET_MODE (q->slot) == BLKmode)\n-\t      {\n-\t\tif (p->base_offset + p->full_size == q->base_offset)\n-\t\t  {\n-\t\t    /* Q comes after P; combine Q into P.  */\n-\t\t    p->size += q->size;\n-\t\t    p->full_size += q->full_size;\n-\t\t    delete_q = 1;\n-\t\t  }\n-\t\telse if (q->base_offset + q->full_size == p->base_offset)\n-\t\t  {\n-\t\t    /* P comes after Q; combine P into Q.  */\n-\t\t    q->size += p->size;\n-\t\t    q->full_size += p->full_size;\n-\t\t    delete_p = 1;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    /* Either delete Q or advance past it.  */\n-\t    if (delete_q)\n-\t      prev_q->next = q->next;\n-\t    else\n-\t      prev_q = q;\n-\t  }\n-      /* Either delete P or advance past it.  */\n-      if (delete_p)\n+      next = p->next;\n+\n+      if (GET_MODE (p->slot) != BLKmode)\n+\tcontinue;\n+\n+      for (q = p->next; q; q = next_q)\n \t{\n-\t  if (prev_p)\n-\t    prev_p->next = p->next;\n-\t  else\n-\t    temp_slots = p->next;\n+       \t  int delete_q = 0;\n+\n+\t  next_q = q->next;\n+\n+\t  if (GET_MODE (q->slot) != BLKmode)\n+\t    continue;\n+\n+\t  if (p->base_offset + p->full_size == q->base_offset)\n+\t    {\n+\t      /* Q comes after P; combine Q into P.  */\n+\t      p->size += q->size;\n+\t      p->full_size += q->full_size;\n+\t      delete_q = 1;\n+\t    }\n+\t  else if (q->base_offset + q->full_size == p->base_offset)\n+\t    {\n+\t      /* P comes after Q; combine P into Q.  */\n+\t      q->size += p->size;\n+\t      q->full_size += p->full_size;\n+\t      delete_p = 1;\n+\t      break;\n+\t    }\n+\t  if (delete_q)\n+\t    cut_slot_from_list (q, &avail_temp_slots);\n \t}\n-      else\n-\tprev_p = p;\n+\n+      /* Either delete P or advance past it.  */\n+      if (delete_p)\n+\tcut_slot_from_list (p, &avail_temp_slots);\n     }\n }\n \f\n@@ -956,26 +1039,25 @@ find_temp_slot_from_address (rtx x)\n {\n   struct temp_slot *p;\n   rtx next;\n+  int i;\n \n-  for (p = temp_slots; p; p = p->next)\n-    {\n-      if (! p->in_use)\n-\tcontinue;\n-\n-      else if (XEXP (p->slot, 0) == x\n-\t       || p->address == x\n-\t       || (GET_CODE (x) == PLUS\n-\t\t   && XEXP (x, 0) == virtual_stack_vars_rtx\n-\t\t   && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t\t   && INTVAL (XEXP (x, 1)) >= p->base_offset\n-\t\t   && INTVAL (XEXP (x, 1)) < p->base_offset + p->full_size))\n-\treturn p;\n-\n-      else if (p->address != 0 && GET_CODE (p->address) == EXPR_LIST)\n-\tfor (next = p->address; next; next = XEXP (next, 1))\n-\t  if (XEXP (next, 0) == x)\n-\t    return p;\n-    }\n+  for (i = max_slot_level (); i >= 0; i--)\n+    for (p = *temp_slots_at_level (i); p; p = p->next)\n+      {\n+\tif (XEXP (p->slot, 0) == x\n+\t    || p->address == x\n+\t    || (GET_CODE (x) == PLUS\n+\t\t&& XEXP (x, 0) == virtual_stack_vars_rtx\n+\t\t&& GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t&& INTVAL (XEXP (x, 1)) >= p->base_offset\n+\t\t&& INTVAL (XEXP (x, 1)) < p->base_offset + p->full_size))\n+\t  return p;\n+\n+\telse if (p->address != 0 && GET_CODE (p->address) == EXPR_LIST)\n+\t  for (next = p->address; next; next = XEXP (next, 1))\n+\t    if (XEXP (next, 0) == x)\n+\t      return p;\n+      }\n \n   /* If we have a sum involving a register, see if it points to a temp\n      slot.  */\n@@ -1078,15 +1160,19 @@ mark_temp_addr_taken (rtx x)\n void\n preserve_temp_slots (rtx x)\n {\n-  struct temp_slot *p = 0;\n+  struct temp_slot *p = 0, *next;\n \n   /* If there is no result, we still might have some objects whose address\n      were taken, so we need to make sure they stay around.  */\n   if (x == 0)\n     {\n-      for (p = temp_slots; p; p = p->next)\n-\tif (p->in_use && p->level == temp_slot_level && p->addr_taken)\n-\t  p->level--;\n+      for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n+\t{\n+\t  next = p->next;\n+\n+\t  if (p->addr_taken)\n+\t    move_slot_to_level (p, temp_slot_level - 1);\n+\t}\n \n       return;\n     }\n@@ -1103,9 +1189,13 @@ preserve_temp_slots (rtx x)\n      taken.  */\n   if (p == 0 && (GET_CODE (x) != MEM || CONSTANT_P (XEXP (x, 0))))\n     {\n-      for (p = temp_slots; p; p = p->next)\n-\tif (p->in_use && p->level == temp_slot_level && p->addr_taken)\n-\t  p->level--;\n+      for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n+\t{\n+\t  next = p->next;\n+\n+\t  if (p->addr_taken)\n+\t    move_slot_to_level (p, temp_slot_level - 1);\n+\t}\n \n       return;\n     }\n@@ -1122,20 +1212,28 @@ preserve_temp_slots (rtx x)\n \n       if (p->level == temp_slot_level)\n \t{\n-\t  for (q = temp_slots; q; q = q->next)\n-\t    if (q != p && q->addr_taken && q->level == p->level)\n-\t      q->level--;\n+\t  for (q = *temp_slots_at_level (temp_slot_level); q; q = next)\n+\t    {\n+\t      next = q->next;\n \n-\t  p->level--;\n+\t      if (p != q && q->addr_taken)\n+\t\tmove_slot_to_level (q, temp_slot_level - 1);\n+\t    }\n+\n+\t  move_slot_to_level (p, temp_slot_level - 1);\n \t  p->addr_taken = 0;\n \t}\n       return;\n     }\n \n   /* Otherwise, preserve all non-kept slots at this level.  */\n-  for (p = temp_slots; p; p = p->next)\n-    if (p->in_use && p->level == temp_slot_level && ! p->keep)\n-      p->level--;\n+  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n+    {\n+      next = p->next;\n+\n+      if (!p->keep)\n+\tmove_slot_to_level (p, temp_slot_level - 1);\n+    }\n }\n \n /* X is the result of an RTL_EXPR.  If it is a temporary slot associated\n@@ -1158,7 +1256,7 @@ preserve_rtl_expr_result (rtx x)\n   p = find_temp_slot_from_address (XEXP (x, 0));\n   if (p != 0)\n     {\n-      p->level = MIN (p->level, temp_slot_level);\n+      move_slot_to_level (p, MIN (p->level, temp_slot_level));\n       p->rtl_expr = 0;\n     }\n \n@@ -1175,12 +1273,15 @@ preserve_rtl_expr_result (rtx x)\n void\n free_temp_slots (void)\n {\n-  struct temp_slot *p;\n+  struct temp_slot *p, *next;\n+\n+  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n+    {\n+      next = p->next;\n \n-  for (p = temp_slots; p; p = p->next)\n-    if (p->in_use && p->level == temp_slot_level && ! p->keep\n-\t&& p->rtl_expr == 0)\n-      p->in_use = 0;\n+      if (!p->keep && p->rtl_expr == 0)\n+\tmake_slot_available (p);\n+    }\n \n   combine_temp_slots ();\n }\n@@ -1190,37 +1291,26 @@ free_temp_slots (void)\n void\n free_temps_for_rtl_expr (tree t)\n {\n-  struct temp_slot *p;\n-\n-  for (p = temp_slots; p; p = p->next)\n-    if (p->rtl_expr == t)\n-      {\n-\t/* If this slot is below the current TEMP_SLOT_LEVEL, then it\n-\t   needs to be preserved.  This can happen if a temporary in\n-\t   the RTL_EXPR was addressed; preserve_temp_slots will move\n-\t   the temporary into a higher level.  */\n-\tif (temp_slot_level <= p->level)\n-\t  p->in_use = 0;\n-\telse\n-\t  p->rtl_expr = NULL_TREE;\n-      }\n-\n-  combine_temp_slots ();\n-}\n+  struct temp_slot *p, *next;\n \n-/* Mark all temporaries ever allocated in this function as not suitable\n-   for reuse until the current level is exited.  */\n-\n-void\n-mark_all_temps_used (void)\n-{\n-  struct temp_slot *p;\n-\n-  for (p = temp_slots; p; p = p->next)\n+  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n     {\n-      p->in_use = p->keep = 1;\n-      p->level = MIN (p->level, temp_slot_level);\n+      next = p->next;\n+\n+      if (p->rtl_expr == t)\n+\t{\n+\t  /* If this slot is below the current TEMP_SLOT_LEVEL, then it\n+\t     needs to be preserved.  This can happen if a temporary in\n+\t     the RTL_EXPR was addressed; preserve_temp_slots will move\n+\t     the temporary into a higher level.  */\n+\t  if (temp_slot_level <= p->level)\n+\t    make_slot_available (p);\n+\t  else\n+\t    p->rtl_expr = NULL_TREE;\n+\t}\n     }\n+\n+  combine_temp_slots ();\n }\n \n /* Push deeper into the nesting level for stack temporaries.  */\n@@ -1237,11 +1327,15 @@ push_temp_slots (void)\n void\n pop_temp_slots (void)\n {\n-  struct temp_slot *p;\n+  struct temp_slot *p, *next;\n \n-  for (p = temp_slots; p; p = p->next)\n-    if (p->in_use && p->level == temp_slot_level && p->rtl_expr == 0)\n-      p->in_use = 0;\n+  for (p = *temp_slots_at_level (temp_slot_level); p; p = next)\n+    {\n+      next = p->next;\n+\n+      if (p->rtl_expr == 0)\n+\tmake_slot_available (p);\n+    }\n \n   combine_temp_slots ();\n \n@@ -1254,7 +1348,8 @@ void\n init_temp_slots (void)\n {\n   /* We have not allocated any temporaries yet.  */\n-  temp_slots = 0;\n+  avail_temp_slots = 0;\n+  used_temp_slots = 0;\n   temp_slot_level = 0;\n   var_temp_slot_level = 0;\n   target_temp_slot_level = 0;"}, {"sha": "1a9c4c9f3e0fdafa6dadadb93964cfc84f7df86d", "filename": "gcc/function.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -322,8 +322,11 @@ struct function GTY(())\n      element in this vector is one less than MAX_PARM_REG, above.  */\n   rtx * GTY ((length (\"%h.x_max_parm_reg\"))) x_parm_reg_stack_loc;\n \n-  /* List of all temporaries allocated, both available and in use.  */\n-  struct temp_slot *x_temp_slots;\n+  /* List of all used temporaries allocated, by level.  */\n+  struct varray_head_tag * GTY((param_is (struct temp_slot))) x_used_temp_slots;\n+\n+  /* List of available temp slots.  */\n+  struct temp_slot *x_avail_temp_slots;\n \n   /* Current nesting level for temporaries.  */\n   int x_temp_slot_level;\n@@ -563,7 +566,8 @@ extern int trampolines_created;\n #define rtl_expr_chain (cfun->x_rtl_expr_chain)\n #define last_parm_insn (cfun->x_last_parm_insn)\n #define function_call_count (cfun->x_function_call_count)\n-#define temp_slots (cfun->x_temp_slots)\n+#define used_temp_slots (cfun->x_used_temp_slots)\n+#define avail_temp_slots (cfun->x_avail_temp_slots)\n #define temp_slot_level (cfun->x_temp_slot_level)\n #define target_temp_slot_level (cfun->x_target_temp_slot_level)\n #define var_temp_slot_level (cfun->x_var_temp_slot_level)"}, {"sha": "0e416c4e65fccc3ed2eb42701e8e744eafedadcd", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 97, "deletions": 23, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -254,7 +254,9 @@ mark_single_set (rtx insn, rtx set)\n   unsigned regno, uid;\n \n   src = find_reg_equal_equiv_note (insn);\n-  if (!src)\n+  if (src)\n+    src = XEXP (src, 0);\n+  else\n     src = SET_SRC (set);\n \n   if (!simple_set_p (SET_DEST (set), src))\n@@ -603,7 +605,9 @@ get_biv_step_1 (rtx insn, rtx reg,\n \n   set = single_set (insn);\n   rhs = find_reg_equal_equiv_note (insn);\n-  if (!rhs)\n+  if (rhs)\n+    rhs = XEXP (rhs, 0);\n+  else\n     rhs = SET_SRC (set);\n   lhs = SET_DEST (set);\n \n@@ -979,7 +983,9 @@ iv_analyze (rtx insn, rtx def, struct rtx_iv *iv)\n \n   set = single_set (insn);\n   rhs = find_reg_equal_equiv_note (insn);\n-  if (!rhs)\n+  if (rhs)\n+    rhs = XEXP (rhs, 0);\n+  else\n     rhs = SET_SRC (set);\n   code = GET_CODE (rhs);\n \n@@ -1203,7 +1209,7 @@ determine_max_iter (struct niter_desc *desc)\n \t}\n     }\n \n-  get_mode_bounds (desc->mode, desc->signed_p, &mmin, &mmax);\n+  get_mode_bounds (desc->mode, desc->signed_p, desc->mode, &mmin, &mmax);\n   nmax = INTVAL (mmax) - INTVAL (mmin);\n \n   if (GET_CODE (niter) == UDIV)\n@@ -1337,7 +1343,9 @@ simplify_using_assignment (rtx insn, rtx *expr, regset altered)\n     return;\n \n   rhs = find_reg_equal_equiv_note (insn);\n-  if (!rhs)\n+  if (rhs)\n+    rhs = XEXP (rhs, 0);\n+  else\n     rhs = SET_SRC (set);\n \n   if (!simple_rhs_p (rhs))\n@@ -1354,7 +1362,8 @@ simplify_using_assignment (rtx insn, rtx *expr, regset altered)\n static bool\n implies_p (rtx a, rtx b)\n {\n-  rtx op0, op1, r;\n+  rtx op0, op1, opb0, opb1, r;\n+  enum machine_mode mode;\n \n   if (GET_CODE (a) == EQ)\n     {\n@@ -1376,6 +1385,45 @@ implies_p (rtx a, rtx b)\n \t}\n     }\n \n+  /* A < B implies A + 1 <= B.  */\n+  if ((GET_CODE (a) == GT || GET_CODE (a) == LT)\n+      && (GET_CODE (b) == GE || GET_CODE (b) == LE))\n+    {\n+      op0 = XEXP (a, 0);\n+      op1 = XEXP (a, 1);\n+      opb0 = XEXP (b, 0);\n+      opb1 = XEXP (b, 1);\n+\n+      if (GET_CODE (a) == GT)\n+\t{\n+\t  r = op0;\n+\t  op0 = op1;\n+\t  op1 = r;\n+\t}\n+\n+      if (GET_CODE (b) == GE)\n+\t{\n+\t  r = opb0;\n+\t  opb0 = opb1;\n+\t  opb1 = r;\n+\t}\n+\n+      mode = GET_MODE (op0);\n+      if (mode != GET_MODE (opb0))\n+\tmode = VOIDmode;\n+      else if (mode == VOIDmode)\n+\t{\n+\t  mode = GET_MODE (op1);\n+\t  if (mode != GET_MODE (opb1))\n+\t    mode = VOIDmode;\n+\t}\n+\n+      if (mode != VOIDmode\n+\t  && rtx_equal_p (op1, opb1)\n+\t  && simplify_gen_binary (MINUS, mode, opb0, op0) == const1_rtx)\n+\treturn true;\n+    }\n+\n   return false;\n }\n \n@@ -1696,7 +1744,7 @@ shorten_into_mode (struct rtx_iv *iv, enum machine_mode mode,\n {\n   rtx mmin, mmax, cond_over, cond_under;\n \n-  get_mode_bounds (mode, signed_p, &mmin, &mmax);\n+  get_mode_bounds (mode, signed_p, iv->extend_mode, &mmin, &mmax);\n   cond_under = simplify_gen_relational (LT, SImode, iv->extend_mode,\n \t\t\t\t\tiv->base, mmin);\n   cond_over = simplify_gen_relational (GT, SImode, iv->extend_mode,\n@@ -1870,11 +1918,11 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n {\n   rtx op0, op1, delta, step, bound, may_xform, def_insn, tmp, tmp0, tmp1;\n   struct rtx_iv iv0, iv1, tmp_iv;\n-  rtx assumption;\n+  rtx assumption, may_not_xform;\n   enum rtx_code cond;\n   enum machine_mode mode, comp_mode;\n-  rtx mmin, mmax;\n-  unsigned HOST_WIDEST_INT s, size, d;\n+  rtx mmin, mmax, mode_mmin, mode_mmax;\n+  unsigned HOST_WIDEST_INT s, size, d, inv;\n   HOST_WIDEST_INT up, down, inc;\n   int was_sharp = false;\n \n@@ -1959,7 +2007,9 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   comp_mode = iv0.extend_mode;\n   mode = iv0.mode;\n   size = GET_MODE_BITSIZE (mode);\n-  get_mode_bounds (mode, (cond == LE || cond == LT), &mmin, &mmax);\n+  get_mode_bounds (mode, (cond == LE || cond == LT), comp_mode, &mmin, &mmax);\n+  mode_mmin = lowpart_subreg (mode, mmin, comp_mode);\n+  mode_mmax = lowpart_subreg (mode, mmax, comp_mode);\n \n   if (GET_CODE (iv0.step) != CONST_INT || GET_CODE (iv1.step) != CONST_INT)\n     goto fail;\n@@ -2001,7 +2051,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \tif (iv0.step == const0_rtx)\n \t  {\n \t    tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n-\t    assumption = simplify_gen_relational (EQ, SImode, mode, tmp, mmax);\n+\t    assumption = simplify_gen_relational (EQ, SImode, mode, tmp,\n+\t\t\t\t\t\t  mode_mmax);\n \t    if (assumption == const_true_rtx)\n \t      goto zero_iter;\n \t    iv0.base = simplify_gen_binary (PLUS, comp_mode,\n@@ -2010,7 +2061,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \telse\n \t  {\n \t    tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n-\t    assumption = simplify_gen_relational (EQ, SImode, mode, tmp, mmin);\n+\t    assumption = simplify_gen_relational (EQ, SImode, mode, tmp,\n+\t\t\t\t\t\t  mode_mmin);\n \t    if (assumption == const_true_rtx)\n \t      goto zero_iter;\n \t    iv1.base = simplify_gen_binary (PLUS, comp_mode,\n@@ -2035,7 +2087,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       if (iv0.step == const0_rtx)\n \t{\n \t  tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n-\t  if (rtx_equal_p (tmp, mmin))\n+\t  if (rtx_equal_p (tmp, mode_mmin))\n \t    {\n \t      desc->infinite =\n \t\t      alloc_EXPR_LIST (0, const_true_rtx, NULL_RTX);\n@@ -2045,7 +2097,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       else\n \t{\n \t  tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n-\t  if (rtx_equal_p (tmp, mmax))\n+\t  if (rtx_equal_p (tmp, mode_mmax))\n \t    {\n \t      desc->infinite =\n \t\t      alloc_EXPR_LIST (0, const_true_rtx, NULL_RTX);\n@@ -2070,6 +2122,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       delta = lowpart_subreg (mode, delta, comp_mode);\n       delta = simplify_gen_binary (UMOD, mode, delta, step);\n       may_xform = const0_rtx;\n+      may_not_xform = const_true_rtx;\n \n       if (GET_CODE (delta) == CONST_INT)\n \t{\n@@ -2094,6 +2147,9 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t      tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n \t      may_xform = simplify_gen_relational (cond, SImode, mode,\n \t\t\t\t\t\t   bound, tmp);\n+\t      may_not_xform = simplify_gen_relational (reverse_condition (cond),\n+\t\t\t\t\t\t       SImode, mode,\n+\t\t\t\t\t\t       bound, tmp);\n \t    }\n \t  else\n \t    {\n@@ -2103,6 +2159,9 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t      tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n \t      may_xform = simplify_gen_relational (cond, SImode, mode,\n \t\t\t\t\t\t   tmp, bound);\n+\t      may_not_xform = simplify_gen_relational (reverse_condition (cond),\n+\t\t\t\t\t\t       SImode, mode,\n+\t\t\t\t\t\t       tmp, bound);\n \t    }\n \t}\n \n@@ -2112,8 +2171,18 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t     completely senseless.  This is OK, as we would need this assumption\n \t     to determine the number of iterations anyway.  */\n \t  if (may_xform != const_true_rtx)\n-\t    desc->assumptions = alloc_EXPR_LIST (0, may_xform,\n-\t\t\t\t\t\t desc->assumptions);\n+\t    {\n+\t      /* If the step is a power of two and the final value we have\n+\t\t computed overflows, the cycle is infinite.  Otherwise it\n+\t\t is nontrivial to compute the number of iterations.  */\n+\t      s = INTVAL (step);\n+\t      if ((s & (s - 1)) == 0)\n+\t\tdesc->infinite = alloc_EXPR_LIST (0, may_not_xform,\n+\t\t\t\t\t\t  desc->infinite);\n+\t      else\n+\t\tdesc->assumptions = alloc_EXPR_LIST (0, may_xform,\n+\t\t\t\t\t\t     desc->assumptions);\n+\t    }\n \n \t  /* We are going to lose some information about upper bound on\n \t     number of iterations in this step, so record the information\n@@ -2122,8 +2191,10 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t  if (GET_CODE (iv1.base) == CONST_INT)\n \t    up = INTVAL (iv1.base);\n \t  else\n-\t    up = INTVAL (mmax) - inc;\n-\t  down = INTVAL (GET_CODE (iv0.base) == CONST_INT ? iv0.base : mmin);\n+\t    up = INTVAL (mode_mmax) - inc;\n+\t  down = INTVAL (GET_CODE (iv0.base) == CONST_INT\n+\t\t\t ? iv0.base\n+\t\t\t : mode_mmin);\n \t  desc->niter_max = (up - down) / inc + 1;\n \n \t  if (iv0.step == const0_rtx)\n@@ -2186,8 +2257,9 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       desc->infinite = alloc_EXPR_LIST (0, assumption, desc->infinite);\n \n       tmp = simplify_gen_binary (UDIV, mode, tmp1, GEN_INT (d));\n-      tmp = simplify_gen_binary (MULT, mode,\n-\t\t\t\t tmp, GEN_INT (inverse (s, size)));\n+      inv = inverse (s, size);\n+      inv = trunc_int_for_mode (inv, mode);\n+      tmp = simplify_gen_binary (MULT, mode, tmp, GEN_INT (inv));\n       desc->niter_expr = simplify_gen_binary (AND, mode, tmp, bound);\n     }\n   else\n@@ -2204,7 +2276,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t  tmp0 = lowpart_subreg (mode, iv0.base, comp_mode);\n \t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n \n-\t  bound = simplify_gen_binary (MINUS, mode, mmax, step);\n+\t  bound = simplify_gen_binary (MINUS, mode, mode_mmax,\n+\t\t\t\t       lowpart_subreg (mode, step, comp_mode));\n \t  assumption = simplify_gen_relational (cond, SImode, mode,\n \t\t\t\t\t\ttmp1, bound);\n \t  desc->assumptions =\n@@ -2227,7 +2300,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t  tmp0 = lowpart_subreg (mode, iv0.base, comp_mode);\n \t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n \n-\t  bound = simplify_gen_binary (MINUS, mode, mmin, step);\n+\t  bound = simplify_gen_binary (MINUS, mode, mode_mmin,\n+\t\t\t\t       lowpart_subreg (mode, step, comp_mode));\n \t  assumption = simplify_gen_relational (cond, SImode, mode,\n \t\t\t\t\t\tbound, tmp0);\n \t  desc->assumptions ="}, {"sha": "8f1f54f0d73c097fb2fd2095ae11f398a8057827", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -174,7 +174,7 @@ unswitch_loops (struct loops *loops)\n static rtx\n may_unswitch_on (basic_block bb, struct loop *loop, rtx *cinsn)\n {\n-  rtx test, at, insn, op[2];\n+  rtx test, at, insn, op[2], stest;\n   struct rtx_iv iv;\n   unsigned i;\n   enum machine_mode mode;\n@@ -233,6 +233,12 @@ may_unswitch_on (basic_block bb, struct loop *loop, rtx *cinsn)\n       return test;\n     }\n \n+  stest = simplify_gen_relational (GET_CODE (test), SImode,\n+\t\t\t\t   mode, op[0], op[1]);\n+  if (stest == const0_rtx\n+      || stest == const_true_rtx)\n+    return stest;\n+\n   return canon_condition (gen_rtx_fmt_ee (GET_CODE (test), SImode,\n \t\t\t\t\t  op[0], op[1]));\n }\n@@ -262,7 +268,7 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n   basic_block *bbs;\n   struct loop *nloop;\n   unsigned i;\n-  rtx cond, rcond, conds, rconds, acond, cinsn = NULL_RTX;\n+  rtx cond, rcond = NULL_RTX, conds, rconds, acond, cinsn = NULL_RTX;\n   int repeat;\n   edge e;\n \n@@ -331,13 +337,17 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n \t  return;\n \t}\n \n-      rcond = reversed_condition (cond);\n-      if (rcond)\n-\trcond = canon_condition (rcond);\n+      if (cond != const0_rtx\n+\t  && cond != const_true_rtx)\n+\t{\n+\t  rcond = reversed_condition (cond);\n+\t  if (rcond)\n+\t    rcond = canon_condition (rcond);\n \n-      /* Check whether the result can be predicted.  */\n-      for (acond = cond_checked; acond; acond = XEXP (acond, 1))\n-\tsimplify_using_condition (XEXP (acond, 0), &cond, NULL);\n+\t  /* Check whether the result can be predicted.  */\n+\t  for (acond = cond_checked; acond; acond = XEXP (acond, 1))\n+\t    simplify_using_condition (XEXP (acond, 0), &cond, NULL);\n+\t}\n \n       if (cond == const_true_rtx)\n \t{"}, {"sha": "cb6850a9927067bf2db65f32fe4f67277988ab65", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -2447,7 +2447,8 @@ extern void tracer (void);\n extern void variable_tracking_main (void);\n \n /* In stor-layout.c.  */\n-extern void get_mode_bounds (enum machine_mode, int, rtx *, rtx *);\n+extern void get_mode_bounds (enum machine_mode, int, enum machine_mode,\n+\t\t\t     rtx *, rtx *);\n \n /* In loop-unswitch.c  */\n extern rtx reversed_condition (rtx);"}, {"sha": "0bef69e986fc3499fa3ee7670c55328829218f83", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -2892,6 +2892,63 @@ simplify_const_relational_operation (enum rtx_code code,\n   /* Otherwise, there are some code-specific tests we can make.  */\n   else\n     {\n+      /* Optimize comparisons with upper and lower bounds.  */\n+      if (INTEGRAL_MODE_P (mode)\n+\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  rtx mmin, mmax;\n+\t  int sign;\n+\n+\t  if (code == GEU\n+\t      || code == LEU\n+\t      || code == GTU\n+\t      || code == LTU)\n+\t    sign = 0;\n+\t  else\n+\t    sign = 1;\n+\n+\t  get_mode_bounds (mode, sign, mode, &mmin, &mmax);\n+\n+\t  tem = NULL_RTX;\n+\t  switch (code)\n+\t    {\n+\t    case GEU:\n+\t    case GE:\n+\t      /* x >= min is always true.  */\n+\t      if (rtx_equal_p (trueop1, mmin))\n+\t\ttem = const_true_rtx;\n+\t      else \n+\t      break;\n+\n+\t    case LEU:\n+\t    case LE:\n+\t      /* x <= max is always true.  */\n+\t      if (rtx_equal_p (trueop1, mmax))\n+\t\ttem = const_true_rtx;\n+\t      break;\n+\n+\t    case GTU:\n+\t    case GT:\n+\t      /* x > max is always false.  */\n+\t      if (rtx_equal_p (trueop1, mmax))\n+\t\ttem = const0_rtx;\n+\t      break;\n+\n+\t    case LTU:\n+\t    case LT:\n+\t      /* x < min is always false.  */\n+\t      if (rtx_equal_p (trueop1, mmin))\n+\t\ttem = const0_rtx;\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t  if (tem == const0_rtx\n+\t      || tem == const_true_rtx)\n+\t    return tem;\n+\t}\n+\n       switch (code)\n \t{\n \tcase EQ:\n@@ -2904,33 +2961,6 @@ simplify_const_relational_operation (enum rtx_code code,\n \t    return const_true_rtx;\n \t  break;\n \n-\tcase GEU:\n-\t  /* Unsigned values are never negative.  */\n-\t  if (trueop1 == const0_rtx)\n-\t    return const_true_rtx;\n-\t  break;\n-\n-\tcase LTU:\n-\t  if (trueop1 == const0_rtx)\n-\t    return const0_rtx;\n-\t  break;\n-\n-\tcase LEU:\n-\t  /* Unsigned values are never greater than the largest\n-\t     unsigned value.  */\n-\t  if (GET_CODE (trueop1) == CONST_INT\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (trueop1) == GET_MODE_MASK (mode)\n-\t    && INTEGRAL_MODE_P (mode))\n-\t  return const_true_rtx;\n-\t  break;\n-\n-\tcase GTU:\n-\t  if (GET_CODE (trueop1) == CONST_INT\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (trueop1) == GET_MODE_MASK (mode)\n-\t      && INTEGRAL_MODE_P (mode))\n-\t    return const0_rtx;\n-\t  break;\n-\n \tcase LT:\n \t  /* Optimize abs(x) < 0.0.  */\n \t  if (trueop1 == CONST0_RTX (mode) && !HONOR_SNANS (mode))"}, {"sha": "e1137f5b9ff3b3670e2fba53fd7561ac2883f3b7", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -2160,26 +2160,32 @@ get_best_mode (int bitsize, int bitpos, unsigned int align,\n }\n \n /* Gets minimal and maximal values for MODE (signed or unsigned depending on\n-   SIGN).  */\n+   SIGN).  The returned constants are made to be usable in TARGET_MODE.  */\n \n void\n-get_mode_bounds (enum machine_mode mode, int sign, rtx *mmin, rtx *mmax)\n+get_mode_bounds (enum machine_mode mode, int sign,\n+\t\t enum machine_mode target_mode,\n+\t\t rtx *mmin, rtx *mmax)\n {\n-  int size = GET_MODE_BITSIZE (mode);\n+  unsigned size = GET_MODE_BITSIZE (mode);\n+  unsigned HOST_WIDE_INT min_val, max_val;\n \n   if (size > HOST_BITS_PER_WIDE_INT)\n     abort ();\n \n   if (sign)\n     {\n-      *mmin = GEN_INT (-((unsigned HOST_WIDE_INT) 1 << (size - 1)));\n-      *mmax = GEN_INT (((unsigned HOST_WIDE_INT) 1 << (size - 1)) - 1);\n+      min_val = -((unsigned HOST_WIDE_INT) 1 << (size - 1));\n+      max_val = ((unsigned HOST_WIDE_INT) 1 << (size - 1)) - 1;\n     }\n   else\n     {\n-      *mmin = const0_rtx;\n-      *mmax = GEN_INT (((unsigned HOST_WIDE_INT) 1 << (size - 1) << 1) - 1);\n+      min_val = 0;\n+      max_val = ((unsigned HOST_WIDE_INT) 1 << (size - 1) << 1) - 1;\n     }\n+\n+  *mmin = GEN_INT (trunc_int_for_mode (min_val, target_mode));\n+  *mmax = GEN_INT (trunc_int_for_mode (max_val, target_mode));\n }\n \n #include \"gt-stor-layout.h\""}, {"sha": "991c9fe86c9ed23b89517c150ebef376468d7d1f", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aea6467d5022e3858bfed5ce5d24aa877bfed1a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0aea6467d5022e3858bfed5ce5d24aa877bfed1a", "patch": "@@ -3539,7 +3539,6 @@ extern void put_var_into_stack (tree, int);\n extern void flush_addressof (tree);\n extern void setjmp_vars_warning (tree);\n extern void setjmp_args_warning (void);\n-extern void mark_all_temps_used (void);\n extern void init_temp_slots (void);\n extern void combine_temp_slots (void);\n extern void free_temp_slots (void);"}]}