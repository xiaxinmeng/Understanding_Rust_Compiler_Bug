{"sha": "d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE5YzBmNGI0Y2RmNGJkZmZhMzEzMjgzMjA3YWFiNmQyNTE4ZjM0Yw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2008-10-05T21:29:32Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2008-10-05T21:29:32Z"}, "message": "re PR debug/37410 (DW_TAG_imported_module is not in its DW_TAG_lexical_block)\n\n2008-09-30  Dodji Seketeli  <dodji@redhat.com>\ngcc/ChangeLog:\n\n\tPR c++/37410\n\t* dwarf2out.c (dwarf2out_imported_module_or_decl): Split this\n\t  function in two, making it call a new and reusable\n\t  dwarf2out_imported_module_or_decl() that takes the containing\n\t  BLOCK of the declaration in argument.\n\t  (dwarf2out_imported_module_or_decl_real): New function.\n\t  (decls_for_scope, gen_decl_die, dwarf2out_decl): Take\n\t  IMPORTED_DECL in account.\n\t* tree.def: Added IMPORTED_DECL node type.\n\t* tree.h: Added accessors for IMPORTED_DECL nodes.\n\t* tree.c (init_ttree): Initialise IMPORTED_DECL node type.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/37410\n\t* cp-gimplify.c (cp_gimplify_expr): For each USING_STMT\n\t  make sure an IMPORTED_DECL node is added to the BLOCK_VARS list\n\t  of the innermost containing BLOCK.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/37410\n\t* g++.dg/debug/dwarf2/imported-module.C: New test.\n\nFrom-SVN: r140895", "tree": {"sha": "d5227fd86e64dffe3a143d3c68ad3f1e06dab6a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5227fd86e64dffe3a143d3c68ad3f1e06dab6a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/comments", "author": null, "committer": null, "parents": [{"sha": "ebb479cd4d397e829eed460bd7ac9040204f8b5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb479cd4d397e829eed460bd7ac9040204f8b5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb479cd4d397e829eed460bd7ac9040204f8b5a"}], "stats": {"total": 250, "additions": 204, "deletions": 46}, "files": [{"sha": "c58932c9e27d78e67a87bb3672844de1bb17d017", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -1,3 +1,17 @@\n+2008-10-05  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/37410\n+\t* dwarf2out.c (dwarf2out_imported_module_or_decl): Split this\n+\tfunction in two, making it call a new and reusable\n+\tdwarf2out_imported_module_or_decl() that takes the containing\n+\tBLOCK of the declaration in argument.\n+\t(dwarf2out_imported_module_or_decl_real): New function.\n+\t(decls_for_scope, gen_decl_die, dwarf2out_decl): Take\n+\tIMPORTED_DECL in account.\n+\t* tree.def: Added IMPORTED_DECL node type.\n+\t* tree.h: Added accessors for IMPORTED_DECL nodes.\n+\t* tree.c (init_ttree): Initialise IMPORTED_DECL node type.\n+\n 2008-10-05  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* doc/gimple.texi: Fix some typos, wrap some long lines,"}, {"sha": "eeeb239b720202636c122c40ed2444b0792cf87c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -1,3 +1,10 @@\n+2008-10-05  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/37410\n+\t* cp-gimplify.c (cp_gimplify_expr): For each USING_STMT\n+\tmake sure an IMPORTED_DECL node is added to the BLOCK_VARS list\n+\tof the innermost containing BLOCK.\n+\n 2008-10-03  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/37719"}, {"sha": "a1542b9f80423aaadbf502f7f4333f77f327fbf6", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -508,6 +508,8 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   int saved_stmts_are_full_exprs_p = 0;\n   enum tree_code code = TREE_CODE (*expr_p);\n   enum gimplify_status ret;\n+  tree block = NULL;\n+  VEC(gimple, heap) *bind_expr_stack = NULL;\n \n   if (STATEMENT_CODE_P (code))\n     {\n@@ -574,8 +576,37 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       break;\n \n     case USING_STMT:\n-      /* Just ignore for now.  Eventually we will want to pass this on to\n-\t the debugger.  */\n+      /* Get the innermost inclosing GIMPLE_BIND that has a non NULL\n+         BLOCK, and append an IMPORTED_DECL to its\n+\t BLOCK_VARS chained list.  */\n+\n+      bind_expr_stack = gimple_bind_expr_stack ();\n+      if (bind_expr_stack)\n+\t{\n+\t  int i;\n+\t  for (i = VEC_length (gimple, bind_expr_stack) - 1; i >= 0; i--)\n+\t    if ((block = gimple_bind_block (VEC_index (gimple,\n+\t\t\t\t\t\t       bind_expr_stack,\n+\t\t\t\t\t\t       i))))\n+\t      break;\n+\t}\n+      if (block)\n+\t{\n+\t  tree using_directive;\n+\t  gcc_assert (TREE_OPERAND (*expr_p,0)\n+\t\t      && NAMESPACE_DECL_CHECK (TREE_OPERAND (*expr_p, 0)));\n+\n+\t  using_directive = make_node (IMPORTED_DECL);\n+\t  TREE_TYPE (using_directive) = void_type_node;\n+\n+\t  IMPORTED_DECL_ASSOCIATED_DECL (using_directive)\n+\t    = TREE_OPERAND (*expr_p, 0);\n+\t  DECL_NAME (using_directive)\n+\t    = DECL_NAME (TREE_OPERAND (*expr_p, 0));\n+\t  TREE_CHAIN (using_directive) = BLOCK_VARS (block);\n+\t  BLOCK_VARS (block) = using_directive;\n+\t}\n+      /* The USING_STMT won't appear in GIMPLE.  */\n       *expr_p = NULL;\n       ret = GS_ALL_DONE;\n       break;"}, {"sha": "0da373ce2a69fecc3febd0b7018f0a0b41ab5372", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -3484,20 +3484,19 @@ do_using_directive (tree name_space)\n   if (!toplevel_bindings_p ())\n     {\n       push_using_directive (name_space);\n-      context = current_scope ();\n     }\n   else\n     {\n       /* direct usage */\n       add_using_namespace (current_namespace, name_space, 0);\n       if (current_namespace != global_namespace)\n \tcontext = current_namespace;\n-    }\n \n-  /* Emit debugging info.  */\n-  if (!processing_template_decl)\n-    (*debug_hooks->imported_module_or_decl) (name_space, NULL_TREE,\n-\t\t\t\t\t     context, false);\n+      /* Emit debugging info.  */\n+      if (!processing_template_decl)\n+\t(*debug_hooks->imported_module_or_decl) (name_space, NULL_TREE,\n+\t\t\t\t\t\t context, false);\n+    }\n }\n \n /* Deal with a using-directive seen by the parser.  Currently we only"}, {"sha": "37bf21f07a2e9760ae616572e628d9c2acdef8c5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 80, "deletions": 38, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -4489,6 +4489,8 @@ static bool dwarf2out_ignore_block (const_tree);\n static void dwarf2out_global_decl (tree);\n static void dwarf2out_type_decl (tree, int);\n static void dwarf2out_imported_module_or_decl (tree, tree, tree, bool);\n+static void dwarf2out_imported_module_or_decl_1 (tree, tree, tree,\n+\t\t\t\t\t\t dw_die_ref);\n static void dwarf2out_abstract_function (tree);\n static void dwarf2out_var_location (rtx);\n static void dwarf2out_begin_function (tree);\n@@ -14918,6 +14920,9 @@ decls_for_scope (tree stmt, dw_die_ref context_die, int depth)\n \t  if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl)\n \t      && !(is_fortran () && TREE_PUBLIC (decl)))\n \t    ;\n+\t  else if (TREE_CODE (decl) == IMPORTED_DECL)\n+\t    dwarf2out_imported_module_or_decl_1 (decl, DECL_NAME (decl),\n+\t\t\t\t\t\t stmt, context_die);\n \t  else\n \t    gen_decl_die (decl, context_die);\n \t}\n@@ -15309,6 +15314,7 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n       break;\n \n     case NAMESPACE_DECL:\n+    case IMPORTED_DECL:\n       gen_namespace_die (decl);\n       break;\n \n@@ -15343,44 +15349,20 @@ dwarf2out_type_decl (tree decl, int local)\n }\n \n /* Output debug information for imported module or decl DECL.\n-   NAME is non-NULL name in context if the decl has been renamed.\n-   CHILD is true if decl is one of the renamed decls as part of\n-   importing whole module.  */\n-\n+   NAME is non-NULL name in the lexical block if the decl has been renamed.\n+   LEXICAL_BLOCK is the lexical block (which TREE_CODE is a BLOCK)\n+   that DECL belongs to.\n+   LEXICAL_BLOCK_DIE is the DIE of LEXICAL_BLOCK.  */\n static void\n-dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n-\t\t\t\t   bool child)\n+dwarf2out_imported_module_or_decl_1 (tree decl,\n+\t\t\t\t     tree name,\n+\t\t\t\t     tree lexical_block,\n+\t\t\t\t     dw_die_ref lexical_block_die)\n {\n-  dw_die_ref imported_die, at_import_die;\n-  dw_die_ref scope_die;\n   expanded_location xloc;\n+  dw_die_ref imported_die = NULL;\n+  dw_die_ref at_import_die;\n \n-  if (debug_info_level <= DINFO_LEVEL_TERSE)\n-    return;\n-\n-  gcc_assert (decl);\n-\n-  /* To emit DW_TAG_imported_module or DW_TAG_imported_decl, we need two DIEs.\n-     We need decl DIE for reference and scope die. First, get DIE for the decl\n-     itself.  */\n-\n-  /* Get the scope die for decl context. Use comp_unit_die for global module\n-     or decl. If die is not found for non globals, force new die.  */\n-  if (context\n-      && TYPE_P (context)\n-      && !should_emit_struct_debug (context, DINFO_USAGE_DIR_USE))\n-    return;\n-  scope_die = get_context_die (context);\n-\n-  if (child)\n-    {\n-      gcc_assert (scope_die->die_child);\n-      gcc_assert (scope_die->die_child->die_tag == DW_TAG_imported_module);\n-      gcc_assert (TREE_CODE (decl) != NAMESPACE_DECL);\n-      scope_die = scope_die->die_child;\n-    }\n-\n-  /* For TYPE_DECL or CONST_DECL, lookup TREE_TYPE.  */\n   if (TREE_CODE (decl) == TYPE_DECL || TREE_CODE (decl) == CONST_DECL)\n     {\n       if (is_base_type (TREE_TYPE (decl)))\n@@ -15398,6 +15380,19 @@ dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n \t  gcc_assert (at_import_die);\n \t}\n     }\n+  else if (TREE_CODE (decl) == IMPORTED_DECL)\n+    {\n+      tree imported_ns_decl;\n+      /* IMPORTED_DECL nodes that are not imported namespace are just not\n+         supported yet.  */\n+      gcc_assert (DECL_INITIAL (decl)\n+\t\t  && TREE_CODE (DECL_INITIAL (decl)) == NAMESPACE_DECL);\n+      imported_ns_decl = DECL_INITIAL (decl);\n+      at_import_die = lookup_decl_die (imported_ns_decl);\n+      if (!at_import_die)\n+\tat_import_die = force_decl_die (imported_ns_decl);\n+      gcc_assert (at_import_die);\n+    }\n   else\n     {\n       at_import_die = lookup_decl_die (decl);\n@@ -15421,20 +15416,66 @@ dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n \t}\n     }\n \n-  /* OK, now we have DIEs for decl as well as scope. Emit imported die.  */\n   if (TREE_CODE (decl) == NAMESPACE_DECL)\n-    imported_die = new_die (DW_TAG_imported_module, scope_die, context);\n+    imported_die = new_die (DW_TAG_imported_module,\n+\t\t\t    lexical_block_die,\n+\t\t\t    lexical_block);\n   else\n-    imported_die = new_die (DW_TAG_imported_declaration, scope_die, context);\n+    imported_die = new_die (DW_TAG_imported_declaration,\n+\t\t\t    lexical_block_die,\n+\t\t\t    lexical_block);\n \n   xloc = expand_location (input_location);\n   add_AT_file (imported_die, DW_AT_decl_file, lookup_filename (xloc.file));\n   add_AT_unsigned (imported_die, DW_AT_decl_line, xloc.line);\n   if (name)\n-    add_AT_string (imported_die, DW_AT_name, IDENTIFIER_POINTER (name));\n+    add_AT_string (imported_die, DW_AT_name,\n+\t\t   IDENTIFIER_POINTER (name));\n   add_AT_die_ref (imported_die, DW_AT_import, at_import_die);\n }\n \n+/* Output debug information for imported module or decl DECL.\n+   NAME is non-NULL name in context if the decl has been renamed.\n+   CHILD is true if decl is one of the renamed decls as part of\n+   importing whole module.  */\n+\n+static void\n+dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n+\t\t\t\t   bool child)\n+{\n+  /* dw_die_ref at_import_die;  */\n+  dw_die_ref scope_die;\n+\n+  if (debug_info_level <= DINFO_LEVEL_TERSE)\n+    return;\n+\n+  gcc_assert (decl);\n+\n+  /* To emit DW_TAG_imported_module or DW_TAG_imported_decl, we need two DIEs.\n+     We need decl DIE for reference and scope die. First, get DIE for the decl\n+     itself.  */\n+\n+  /* Get the scope die for decl context. Use comp_unit_die for global module\n+     or decl. If die is not found for non globals, force new die.  */\n+  if (context\n+      && TYPE_P (context)\n+      && !should_emit_struct_debug (context, DINFO_USAGE_DIR_USE))\n+    return;\n+  scope_die = get_context_die (context);\n+\n+  if (child)\n+    {\n+      gcc_assert (scope_die->die_child);\n+      gcc_assert (scope_die->die_child->die_tag == DW_TAG_imported_module);\n+      gcc_assert (TREE_CODE (decl) != NAMESPACE_DECL);\n+      scope_die = scope_die->die_child;\n+    }\n+\n+  /* OK, now we have DIEs for decl as well as scope. Emit imported die.  */\n+  dwarf2out_imported_module_or_decl_1 (decl, name, context, scope_die);\n+\n+}\n+\n /* Write the debugging output for DECL.  */\n \n void\n@@ -15519,6 +15560,7 @@ dwarf2out_decl (tree decl)\n       break;\n \n     case NAMESPACE_DECL:\n+    case IMPORTED_DECL:\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \treturn;\n       if (lookup_decl_die (decl) != NULL)"}, {"sha": "fb9f12692c6f881b069a5322c62ef06528bb3b1d", "filename": "gcc/print-tree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -926,6 +926,12 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \tcase TARGET_OPTION_NODE:\n \t  cl_target_option_print (file, indent + 4, TREE_TARGET_OPTION (node));\n \t  break;\n+\tcase IMPORTED_DECL:\n+\t  fprintf (file, \" imported declaration\");\n+\t  print_node_brief (file, \"associated declaration\",\n+\t\t\t    IMPORTED_DECL_ASSOCIATED_DECL (node),\n+\t\t\t    indent + 4);\n+\t  break;\n \n \tdefault:\n \t  if (EXCEPTIONAL_CLASS_P (node))"}, {"sha": "3edb676dcc817dd4799883339d52079a58e694ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -1,3 +1,9 @@\n+2008-10-05  Dodji Seketeli  <dodji@redhat.com>\n+\n+\n+\tPR c++/37410\n+\t* g++.dg/debug/dwarf2/imported-module.C: New test.\n+\n 2008-10-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/35680"}, {"sha": "7b25233f1ab24f0af0d468e739c56b3ff99d23ef", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/imported-module.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fimported-module.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fimported-module.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fimported-module.C?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -0,0 +1,35 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR debug/37410\n+// { dg-do compile }\n+\n+namespace A1\n+  {\n+    int aaa = 1;\n+  };\n+namespace A2\n+  {\n+    int aaa = 2;\n+  };\n+\n+int\n+foo (void)\n+{\n+  int x;\n+\n+  {\n+    int block_create;\n+    using namespace A1;\n+\n+    block_create = aaa; /* break1 */\n+  }\n+\n+  {\n+    int block_create;\n+    using namespace A2;\n+\n+    block_create = aaa; /* break2 */\n+  }\n+\n+  return x = 0;\n+}\n+"}, {"sha": "33ab8b7078bda38c3c5978034b7688ae4efc0ba1", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -343,6 +343,8 @@ init_ttree (void)\n   tree_contains_struct[CONST_DECL][TS_CONST_DECL] = 1;\n   tree_contains_struct[TYPE_DECL][TS_TYPE_DECL] = 1;\n   tree_contains_struct[FUNCTION_DECL][TS_FUNCTION_DECL] = 1;\n+  tree_contains_struct[IMPORTED_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[IMPORTED_DECL][TS_DECL_COMMON] = 1;\n \n   lang_hooks.init_ts ();\n }"}, {"sha": "bde59b7016ce5589de1c6a8f3c7a39239da7e8e4", "filename": "gcc/tree.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -371,6 +371,17 @@ DEFTREECODE (MEMORY_PARTITION_TAG, \"memory_partition_tag\", tcc_declaration, 0)\n    _DECLs, providing a hierarchy of names.  */\n DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", tcc_declaration, 0)\n \n+/* A declaration import.\n+   The C++ FE uses this to represent a using-directive; eg:\n+   \"using namespace foo\".\n+   But it could be used to represent any declaration import construct.\n+   Whenever a declaration import appears in a lexical block, the BLOCK node\n+   representing that lexical block in GIMPLE will contain an IMPORTED_DECL\n+   node, linked via BLOCK_VARS accessor of the said BLOCK.\n+   For a given NODE which code is IMPORTED_DECL,\n+   IMPORTED_DECL_ASSOCIATED_DECL (NODE) accesses the imported declaration.  */\n+DEFTREECODE (IMPORTED_DECL, \"imported_decl\", tcc_declaration, 0)\n+\n /* A translation unit.  This is not technically a declaration, since it\n    can't be looked up, but it's close enough.  */\n DEFTREECODE (TRANSLATION_UNIT_DECL, \"translation_unit_decl\",\\"}, {"sha": "85704e690949cdabc187cab4fdbe75dadac5360f", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19c0f4b4cdf4bdffa313283207aab6d2518f34c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d19c0f4b4cdf4bdffa313283207aab6d2518f34c", "patch": "@@ -3334,6 +3334,11 @@ struct tree_function_decl GTY(())\n #define TYPE_DECL_SUPPRESS_DEBUG(NODE) \\\n   (TYPE_DECL_CHECK (NODE)->decl_common.decl_flag_2)\n \n+/* Getter of the imported declaration associated to the\n+   IMPORTED_DECL node.  */\n+#define IMPORTED_DECL_ASSOCIATED_DECL(NODE) \\\n+(DECL_INITIAL (IMPORTED_DECL_CHECK (NODE)))\n+\n struct tree_type_decl GTY(())\n {\n   struct tree_decl_non_common common;"}]}