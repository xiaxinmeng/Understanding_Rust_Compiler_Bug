{"sha": "aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE2ZThlZDMzYTE4YTYxODVmODUyYjZkMDdhMjE2ODYzOGM3Y2YzOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-03-07T21:19:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-03-07T21:19:38Z"}, "message": "call.c (reference_binding): Remove REF_IS_VAR parameter.\n\n\n\t* call.c (reference_binding): Remove REF_IS_VAR parameter.\n\t(implicit_conversion): Adjust call to reference_binding.\n\t(make_temporary_var_for_ref_to_type): Add TYPE parameter.\n\t(initialize_reference): Adjust handling for references bound to\n\trvalues.\n\t* cp-tree.h (make_temporary_var_for_ref_to_temp): Change\n\tprototype.\n\t(real_non_cast_lvalue_p): New function.\n\t* cvt.c (build_up_reference): Adjust use of\n\tmake_temporary_var_for_ref_to_temp.\n\t* tree.c (real_non_cast_lvalue_p): New function.\n\n\t* g++.dg/init/ref4.C: New test.\n\nFrom-SVN: r63949", "tree": {"sha": "d541d77effe4c2a0317c197fe33a09d83658f481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d541d77effe4c2a0317c197fe33a09d83658f481"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/comments", "author": null, "committer": null, "parents": [{"sha": "5040d6912ccf32e1b3baed1e0a2d9dd475bbf853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5040d6912ccf32e1b3baed1e0a2d9dd475bbf853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5040d6912ccf32e1b3baed1e0a2d9dd475bbf853"}], "stats": {"total": 167, "additions": 121, "deletions": 46}, "files": [{"sha": "f11bba8a2718397b11ad2620377a8b87aa0ba18f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "patch": "@@ -1,3 +1,17 @@\n+2003-03-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (reference_binding): Remove REF_IS_VAR parameter.\n+\t(implicit_conversion): Adjust call to reference_binding.\n+\t(make_temporary_var_for_ref_to_type): Add TYPE parameter.\n+\t(initialize_reference): Adjust handling for references bound to\n+\trvalues.\n+\t* cp-tree.h (make_temporary_var_for_ref_to_temp): Change\n+\tprototype.\n+\t(real_non_cast_lvalue_p): New method.\n+\t* cvt.c (build_up_reference): Adjust use of\n+\tmake_temporary_var_for_ref_to_temp.\n+\t* tree.c (\n+\t \n 2003-03-07  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* except.c (init_exception_processing): Use C90 prototype style."}, {"sha": "a25da46784bdc28da4850d023027bdda0b0aecef", "filename": "gcc/cp/call.c", "status": "modified", "additions": 70, "deletions": 44, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "patch": "@@ -85,7 +85,7 @@ static struct z_candidate *add_function_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, tree, int);\n static tree implicit_conversion (tree, tree, tree, int);\n static tree standard_conversion (tree, tree, tree);\n-static tree reference_binding (tree, tree, tree, int, bool);\n+static tree reference_binding (tree, tree, tree, int);\n static tree non_reference (tree);\n static tree build_conv (enum tree_code, tree, tree);\n static bool is_subseq (tree, tree);\n@@ -1133,12 +1133,10 @@ direct_reference_binding (tree type, tree conv)\n    purposes of reference binding.  For lvalue binding, either pass a\n    reference type to FROM or an lvalue expression to EXPR.  If the\n    reference will be bound to a temporary, NEED_TEMPORARY_P is set for\n-   the conversion returned.  REF_IS_VAR is true iff the reference is\n-   a variable (rather than, say, a parameter declaration).  */\n+   the conversion returned.  */\n \n static tree\n-reference_binding (tree rto, tree rfrom, tree expr, int flags,\n-\t\t   bool ref_is_var)\n+reference_binding (tree rto, tree rfrom, tree expr, int flags)\n {\n   tree conv = NULL_TREE;\n   tree to = TREE_TYPE (rto);\n@@ -1250,22 +1248,14 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags,\n      -- The reference is bound to the object represented by the rvalue\n         or to a sub-object within that object.  \n \n-     -- A temporary of type \"cv1 T2\" [sic] is created, and a\n-        constructor is called to copy the entire rvalue object into\n-        the temporary.  The reference is bound to the temporary or to\n-        a sub-object within the temporary\n+     -- ...\n \t\n-     In general, we choose the first alternative, since it avoids the\n-     copy.  However, if REF_IS_VAR is true, then we cannot do that; we\n-     need to bind the reference to a temporary that wil live as long\n-     as the reference itself.\n-\n-     In the first alternative, the implicit conversion sequence is\n-     supposed to be same as we would obtain by generating a temporary.\n-     Fortunately, if the types are reference compatible, then this is\n-     either an identity conversion or the derived-to-base conversion,\n-     just as for direct binding.  */\n-  if (CLASS_TYPE_P (from) && compatible_p && !ref_is_var)\n+     We use the first alternative.  The implicit conversion sequence\n+     is supposed to be same as we would obtain by generating a\n+     temporary.  Fortunately, if the types are reference compatible,\n+     then this is either an identity conversion or the derived-to-base\n+     conversion, just as for direct binding.  */\n+  if (CLASS_TYPE_P (from) && compatible_p)\n     {\n       conv = build1 (IDENTITY_CONV, from, expr);\n       return direct_reference_binding (rto, conv);\n@@ -1321,7 +1311,7 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n   complete_type (to);\n \n   if (TREE_CODE (to) == REFERENCE_TYPE)\n-    conv = reference_binding (to, from, expr, flags, /*ref_is_var=*/false);\n+    conv = reference_binding (to, from, expr, flags);\n   else\n     conv = standard_conversion (to, from, expr);\n \n@@ -5849,19 +5839,14 @@ perform_implicit_conversion (tree type, tree expr)\n \n /* DECL is a VAR_DECL whose type is a REFERENCE_TYPE.  The reference\n    is being bound to a temporary.  Create and return a new VAR_DECL\n-   whose type is the underlying type of the reference.  */\n+   with the indicated TYPE; this variable will store the value to\n+   which the reference is bound.  */\n \n tree \n-make_temporary_var_for_ref_to_temp (tree decl)\n+make_temporary_var_for_ref_to_temp (tree decl, tree type)\n {\n-  tree type;\n   tree var;\n \n-  /* Get the type to which the reference refers.  */\n-  type = TREE_TYPE (decl);\n-  my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 200302);\n-  type = TREE_TYPE (type);\n-\n   /* Create the variable.  */\n   var = build_decl (VAR_DECL, NULL_TREE, type);\n   DECL_ARTIFICIAL (var) = 1;\n@@ -5905,8 +5890,7 @@ initialize_reference (tree type, tree expr, tree decl)\n   if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;\n \n-  conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL,\n-\t\t\t    decl != NULL_TREE);\n+  conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL);\n   if (!conv || ICS_BAD_FLAG (conv))\n     {\n       error (\"could not convert `%E' to `%T'\", expr, type);\n@@ -5918,7 +5902,7 @@ initialize_reference (tree type, tree expr, tree decl)\n        [class.temporary]\n \n        The temporary to which the reference is bound or the temporary\n-       that is the complete object to which the temporary is bound\n+       that is the complete object to which the reference is bound\n        persists for the lifetime of the reference.\n \n        The temporaries created during the evaluation of the expression\n@@ -5927,22 +5911,64 @@ initialize_reference (tree type, tree expr, tree decl)\n        full-expression in which they are created.\n \n      In that case, we store the converted expression into a new\n-     VAR_DECL in a new scope.  */\n+     VAR_DECL in a new scope.  \n+\n+     However, we want to be careful not to create temporaries when\n+     they are not required.  For example, given:\n+\n+       struct B {}; \n+       struct D : public B {};\n+       D f();\n+       const B& b = f();\n+\n+     there is no need to copy the return value from \"f\"; we can just\n+     extend its lifetime.  Similarly, given:\n+\n+       struct S {};\n+       struct T { operator S(); };\n+       T t;\n+       const S& s = t;\n+\n+    we can extend the lifetime of the returnn value of the conversion\n+    operator.  */\n   my_friendly_assert (TREE_CODE (conv) == REF_BIND, 20030302);\n-  if (decl && NEED_TEMPORARY_P (conv))\n+  if (decl)\n     {\n       tree var;\n-      \n-      /* Process the initializer for the declaration.  */\n-      expr = convert_like (TREE_OPERAND (conv, 0), expr);\n-      /* Create the temporary variable.  */\n-      var = make_temporary_var_for_ref_to_temp (decl);\n-      DECL_INITIAL (var) = expr;\n-      cp_finish_decl (var, expr, NULL_TREE, \n-\t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n+      tree base_conv_type;\n \n-      /* Use its address to initialize the reference variable.  */\n-      return build_nop (type, build_address (var));\n+      /* Skip over the REF_BIND.  */\n+      conv = TREE_OPERAND (conv, 0);\n+      /* If the next conversion is a BASE_CONV, skip that too -- but\n+\t remember that the conversion was required.  */\n+      if (TREE_CODE (conv) == BASE_CONV)\n+\t{\n+\t  my_friendly_assert (!NEED_TEMPORARY_P (conv), 20030307);\n+\t  base_conv_type = TREE_TYPE (conv);\n+\t  conv = TREE_OPERAND (conv, 0);\n+\t}\n+      else\n+\tbase_conv_type = NULL_TREE;\n+      /* Perform the remainder of the conversion.  */\n+      expr = convert_like (conv, expr);\n+      if (!real_non_cast_lvalue_p (expr))\n+\t{\n+\t  /* Create the temporary variable.  */\n+\t  var = make_temporary_var_for_ref_to_temp (decl, TREE_TYPE (expr));\n+\t  DECL_INITIAL (var) = expr;\n+\t  cp_finish_decl (var, expr, NULL_TREE, \n+\t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n+\t  /* Use its address to initialize the reference variable.  */\n+\t  expr = build_address (var);\n+\t}\n+      else\n+\t/* Take the address of EXPR.  */\n+\texpr = build_unary_op (ADDR_EXPR, expr, 0);\n+      /* If a BASE_CONV was required, perform it now.  */\n+      if (base_conv_type)\n+\texpr = (perform_implicit_conversion \n+\t\t(build_pointer_type (base_conv_type), expr));\n+      return build_nop (type, expr);\n     }\n \n   /* Perform the conversion.  */"}, {"sha": "53a4db6de87ce305965a167e95e7bea85c2335e1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "patch": "@@ -3581,7 +3581,7 @@ extern tree convert_for_arg_passing (tree, tree);\n extern tree cp_convert_parm_for_inlining        (tree, tree, tree);\n extern bool is_properly_derived_from (tree, tree);\n extern tree initialize_reference (tree, tree, tree);\n-extern tree make_temporary_var_for_ref_to_temp (tree);\n+extern tree make_temporary_var_for_ref_to_temp (tree, tree);\n extern tree strip_top_quals (tree);\n extern tree perform_implicit_conversion (tree, tree);\n extern tree in_charge_arg_for_name (tree);\n@@ -4226,6 +4226,7 @@ extern tree copy_base_binfos\t\t\t(tree, tree, tree);\n extern int member_p\t\t\t\t(tree);\n extern cp_lvalue_kind real_lvalue_p\t\t(tree);\n extern int non_cast_lvalue_p\t\t\t(tree);\n+extern cp_lvalue_kind real_non_cast_lvalue_p    (tree);\n extern int non_cast_lvalue_or_else\t\t(tree, const char *);\n extern tree build_min\t\t\t\t(enum tree_code, tree,\n \t\t\t\t\t\t\t ...);"}, {"sha": "88e802e14b0a3cda258d1958d096fb99eda67e97", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "patch": "@@ -358,7 +358,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n \t here because it needs to live as long as DECL.  */\n       tree targ = arg;\n \n-      arg = make_temporary_var_for_ref_to_temp (decl);\n+      arg = make_temporary_var_for_ref_to_temp (decl, TREE_TYPE (arg));\n \n       /* Process the initializer for the declaration.  */\n       DECL_INITIAL (arg) = targ;"}, {"sha": "94fe9fbd903e2e013c8651b2bbeea5fddd9fd5d1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "patch": "@@ -212,6 +212,18 @@ real_lvalue_p (ref)\n   return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/ 0, /*cast*/ 1);\n }\n \n+/* Returns the kind of lvalue that REF is, in the sense of\n+   [basic.lval].  This function should really be named lvalue_p; it\n+   computes the C++ definition of lvalue.  */\n+\n+cp_lvalue_kind\n+real_non_cast_lvalue_p (tree ref)\n+{\n+  return lvalue_p_1 (ref, \n+\t\t     /*treat_class_rvalues_as_lvalues=*/0, \n+\t\t     /*allow_cast_as_lvalue=*/0);\n+}\n+\n /* This differs from real_lvalue_p in that class rvalues are\n    considered lvalues.  */\n "}, {"sha": "27c6197d9f845d22e4a926c8edec22dbdc227955", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "patch": "@@ -1,3 +1,7 @@\n+2003-03-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/init/ref4.C: New test.\n+\n Fri Mar  7 17:41:07 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/i386-local2.c: Fix problems with certain versions of dejagnu."}, {"sha": "6b65d9925ab119e736ce2e93823b7edef2acfa2b", "filename": "gcc/testsuite/g++.dg/init/ref4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6e8ed33a18a6185f852b6d07a2168638c7cf39/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref4.C?ref=aa6e8ed33a18a6185f852b6d07a2168638c7cf39", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do run }\n+\n+int c;\n+\n+struct Base {\n+  Base() {}\n+  Base(const Base &) { ++c; }\n+  Base & operator = (const Base &);\n+};\n+\n+struct Derived : public Base {};\n+\n+const Base &b = Derived();\n+\n+int main()\n+{\n+  return c;  // No copies should be required.\n+}"}]}