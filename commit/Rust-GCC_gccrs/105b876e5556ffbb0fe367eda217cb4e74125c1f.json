{"sha": "105b876e5556ffbb0fe367eda217cb4e74125c1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1Yjg3NmU1NTU2ZmZiYjBmZTM2N2VkYTIxN2NiNGU3NDEyNWMxZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-01-12T18:29:54Z"}, "committer": {"name": "Denis Chertykov", "email": "denisc@gcc.gnu.org", "date": "2012-01-12T18:29:54Z"}, "message": "re PR other/50925 ([avr] ICE at spill_failure, at reload1.c:2118)\n\n\tPR target/50925\n\t* config/avr/avr-protos.h (avr_hard_regno_nregs): Declare.\n\t* config/avr/avr.c (avr_can_eliminate): Simplify.\n\t(avr_initial_elimination_offset): Likewise.\n\t(avr_prologue_setup_frame): Use hard_frame_pointer_rtx.\n\t(expand_epilogue): Likewise.\n\t(avr_legitimize_address): Gut.\n\t(avr_legitimize_reload_address): Use hard_frame_pointer_rtx.\n\t(avr_hard_regno_nregs): New.\n\t(avr_hard_regno_ok): Allow only Pmode for arg and frame_pointers.\n\t(avr_regno_mode_code_ok_for_base_b): Handle arg and frame pointers.\n\t* config/avr/avr.h (FIXED_REGISTERS): Adjust arg pointer,\n\tadd soft frame pointer.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(REGISTER_NAMES): Likewise.\n\t(HARD_REGNO_NREGS): Use avr_hard_regno_nregs.\n\t(HARD_FRAME_POINTER_REGNUM): New.\n\t(FRAME_POINTER_REGNUM): Use soft frame pointer.\n\t(ELIMINABLE_REGS): Eliminate from the soft frame pointer,\n\tremove the HARD_FRAME_POINTER self-elimination.\n\n\nCo-Authored-By: Denis Chertykov <chertykov@gmail.com>\n\nFrom-SVN: r183136", "tree": {"sha": "e889933a6e7bcc591d23cf6cfddc2fffc5cbe794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e889933a6e7bcc591d23cf6cfddc2fffc5cbe794"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/105b876e5556ffbb0fe367eda217cb4e74125c1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105b876e5556ffbb0fe367eda217cb4e74125c1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105b876e5556ffbb0fe367eda217cb4e74125c1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105b876e5556ffbb0fe367eda217cb4e74125c1f/comments", "author": null, "committer": null, "parents": [{"sha": "4643a68ec2e8c5b8fcce324a74fe83a87a976d0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4643a68ec2e8c5b8fcce324a74fe83a87a976d0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4643a68ec2e8c5b8fcce324a74fe83a87a976d0a"}], "stats": {"total": 230, "additions": 123, "deletions": 107}, "files": [{"sha": "837387da832521c7846997c70da7534a7eb11509", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b876e5556ffbb0fe367eda217cb4e74125c1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b876e5556ffbb0fe367eda217cb4e74125c1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=105b876e5556ffbb0fe367eda217cb4e74125c1f", "patch": "@@ -1,3 +1,28 @@\n+2012-01-09  Richard Henderson  <rth@redhat.com>\n+\t    Denis Chertykov  <chertykov@gmail.com>\n+\n+\tPR target/50925\n+\t* config/avr/avr-protos.h (avr_hard_regno_nregs): Declare.\n+\t* config/avr/avr.c (avr_can_eliminate): Simplify.\n+\t(avr_initial_elimination_offset): Likewise.\n+\t(avr_prologue_setup_frame): Use hard_frame_pointer_rtx.\n+\t(expand_epilogue): Likewise.\n+\t(avr_legitimize_address): Gut.\n+\t(avr_legitimize_reload_address): Use hard_frame_pointer_rtx.\n+\t(avr_hard_regno_nregs): New.\n+\t(avr_hard_regno_ok): Allow only Pmode for arg and frame_pointers.\n+\t(avr_regno_mode_code_ok_for_base_b): Handle arg and frame pointers.\n+\t* config/avr/avr.h (FIXED_REGISTERS): Adjust arg pointer,\n+\tadd soft frame pointer.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(REGISTER_NAMES): Likewise.\n+\t(HARD_REGNO_NREGS): Use avr_hard_regno_nregs.\n+\t(HARD_FRAME_POINTER_REGNUM): New.\n+\t(FRAME_POINTER_REGNUM): Use soft frame pointer.\n+\t(ELIMINABLE_REGS): Eliminate from the soft frame pointer,\n+\tremove the HARD_FRAME_POINTER self-elimination.\n+\n 2012-01-12  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/51756"}, {"sha": "8f6cb87a52991aabaa1d841ab7148e3163980951", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b876e5556ffbb0fe367eda217cb4e74125c1f/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b876e5556ffbb0fe367eda217cb4e74125c1f/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=105b876e5556ffbb0fe367eda217cb4e74125c1f", "patch": "@@ -109,6 +109,7 @@ extern int avr_jump_mode (rtx x, rtx insn);\n extern int test_hard_reg_class (enum reg_class rclass, rtx x);\n extern int jump_over_one_insn_p (rtx insn, rtx dest);\n \n+extern int avr_hard_regno_nregs (int regno, enum machine_mode mode);\n extern int avr_hard_regno_mode_ok (int regno, enum machine_mode mode);\n extern void final_prescan_insn (rtx insn, rtx *operand, int num_operands);\n extern int avr_simplify_comparison_p (enum machine_mode mode,"}, {"sha": "5d4dbd3fcccb69bea8ebcf028f0d5d104aa31d4a", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 45, "deletions": 59, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b876e5556ffbb0fe367eda217cb4e74125c1f/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b876e5556ffbb0fe367eda217cb4e74125c1f/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=105b876e5556ffbb0fe367eda217cb4e74125c1f", "patch": "@@ -686,31 +686,28 @@ avr_regs_to_save (HARD_REG_SET *set)\n /* Return true if register FROM can be eliminated via register TO.  */\n \n static bool\n-avr_can_eliminate (const int from, const int to)\n+avr_can_eliminate (int from ATTRIBUTE_UNUSED, int to)\n {\n-  return ((from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n-          || (frame_pointer_needed && to == FRAME_POINTER_REGNUM)\n-          || ((from == FRAME_POINTER_REGNUM \n-               || from == FRAME_POINTER_REGNUM + 1)\n-              && !frame_pointer_needed));\n+  return to == HARD_FRAME_POINTER_REGNUM;\n }\n \n /* Compute offset between arg_pointer and frame_pointer.  */\n \n int\n-avr_initial_elimination_offset (int from, int to)\n+avr_initial_elimination_offset (int from, int to ATTRIBUTE_UNUSED)\n {\n-  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return 0;\n-  else\n+  int offset = 0;\n+\n+  if (from == ARG_POINTER_REGNUM)\n     {\n-      int offset = frame_pointer_needed ? 2 : 0;\n-      int avr_pc_size = AVR_HAVE_EIJMP_EICALL ? 3 : 2;\n-      \n+      offset += AVR_HAVE_EIJMP_EICALL ? 3 : 2;\n+      offset += frame_pointer_needed ? 2 : 0;\n       offset += avr_regs_to_save (NULL);\n-      return (get_frame_size () + avr_outgoing_args_size()\n-              + avr_pc_size + 1 + offset);\n+      offset += get_frame_size ();\n+      offset += 1; /* post-dec stack space */\n     }\n+\n+  return offset;\n }\n \n /* Actual start of frame is virtual_stack_vars_rtx this is offset from \n@@ -902,12 +899,12 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n          notes to the front.  Thus we build them in the reverse order of\n          how we want dwarf2out to process them.  */\n \n-      /* The function does always set frame_pointer_rtx, but whether that\n+      /* The function does always set hard_frame_pointer_rtx, but whether that\n          is going to be permanent in the function is frame_pointer_needed.  */\n \n       add_reg_note (insn, REG_CFA_ADJUST_CFA,\n                     gen_rtx_SET (VOIDmode, (frame_pointer_needed\n-                                            ? frame_pointer_rtx\n+                                            ? hard_frame_pointer_rtx\n                                             : stack_pointer_rtx),\n                                  plus_constant (stack_pointer_rtx,\n                                                 -(size + live_seq))));\n@@ -952,7 +949,7 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n       if (frame_pointer_needed\n           && size == 0)\n         {\n-          insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+          insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n           RTX_FRAME_RELATED_P (insn) = 1;\n         }\n       \n@@ -987,15 +984,15 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n                       || !current_function_is_leaf);\n           \n           fp = my_fp = (frame_pointer_needed\n-                        ? frame_pointer_rtx\n+                        ? hard_frame_pointer_rtx\n                         : gen_rtx_REG (Pmode, REG_X));\n           \n           if (AVR_HAVE_8BIT_SP)\n             {\n               /* The high byte (r29) does not change:\n                  Prefer SUBI (1 cycle) over ABIW (2 cycles, same size).  */\n \n-              my_fp = all_regs_rtx[FRAME_POINTER_REGNUM];\n+              my_fp = all_regs_rtx[HARD_FRAME_POINTER_REGNUM];\n             }\n \n           /************  Method 1: Adjust frame pointer  ************/\n@@ -1260,13 +1257,13 @@ expand_epilogue (bool sibcall_p)\n       \n       if (!frame_pointer_needed)\n         {\n-          emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+          emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n         }\n \n       if (size)\n         {\n-          emit_move_insn (frame_pointer_rtx,\n-                          plus_constant (frame_pointer_rtx, size));\n+          emit_move_insn (hard_frame_pointer_rtx,\n+                          plus_constant (hard_frame_pointer_rtx, size));\n         }\n         \n       emit_insn (gen_epilogue_restores (gen_int_mode (live_seq, HImode)));\n@@ -1285,15 +1282,15 @@ expand_epilogue (bool sibcall_p)\n                   || !current_function_is_leaf);\n       \n       fp = my_fp = (frame_pointer_needed\n-                    ? frame_pointer_rtx\n+                    ? hard_frame_pointer_rtx\n                     : gen_rtx_REG (Pmode, REG_X));\n \n       if (AVR_HAVE_8BIT_SP)\n         {\n           /* The high byte (r29) does not change:\n              Prefer SUBI (1 cycle) over SBIW (2 cycles).  */\n                   \n-          my_fp = all_regs_rtx[FRAME_POINTER_REGNUM];\n+          my_fp = all_regs_rtx[HARD_FRAME_POINTER_REGNUM];\n         }\n               \n       /********** Method 1: Adjust fp register  **********/\n@@ -1534,37 +1531,8 @@ avr_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n    memory address for an operand of mode MODE  */\n \n static rtx\n-avr_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n+avr_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, enum machine_mode mode)\n {\n-  bool big_offset_p = false;\n-  \n-  x = oldx;\n-  \n-  if (GET_CODE (oldx) == PLUS\n-      && REG_P (XEXP (oldx, 0)))\n-    {\n-      if (REG_P (XEXP (oldx, 1)))\n-        x = force_reg (GET_MODE (oldx), oldx);\n-      else if (CONST_INT_P (XEXP (oldx, 1)))\n-        {\n-\t  int offs = INTVAL (XEXP (oldx, 1));\n-          if (frame_pointer_rtx != XEXP (oldx, 0)\n-              && offs > MAX_LD_OFFSET (mode))\n-            {\n-              big_offset_p = true;\n-              x = force_reg (GET_MODE (oldx), oldx);\n-            }\n-        }\n-    }\n-  \n-  if (avr_log.legitimize_address)\n-    {\n-      avr_edump (\"\\n%?: mode=%m\\n %r\\n\", mode, oldx);\n-\n-      if (x != oldx)\n-        avr_edump (\" %s --> %r\\n\", big_offset_p ? \"(big offset)\" : \"\", x);\n-    }\n-\n   return x;\n }\n \n@@ -1634,7 +1602,7 @@ avr_legitimize_reload_address (rtx *px, enum machine_mode mode,\n             }\n         }\n       else if (! (frame_pointer_needed\n-                  && XEXP (x, 0) == frame_pointer_rtx))\n+                  && XEXP (x, 0) == hard_frame_pointer_rtx))\n         {\n           push_reload (x, NULL_RTX, px, NULL,\n                        POINTER_REGS, GET_MODE (x), VOIDmode, 0, 0,\n@@ -8366,6 +8334,19 @@ extra_constraint_Q (rtx x)\n   return ok;\n }\n \n+/* Returns the number of registers required to hold a value of MODE.  */\n+\n+int\n+avr_hard_regno_nregs (int regno, enum machine_mode mode)\n+{\n+  /* The fake registers are designed to hold exactly a pointer.  */\n+  if (regno == ARG_POINTER_REGNUM || regno == FRAME_POINTER_REGNUM)\n+    return 1;\n+\n+  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+}\n+\n+\n /* Convert condition code CONDITION to the valid AVR condition code.  */\n \n RTX_CODE\n@@ -8789,6 +8770,10 @@ jump_over_one_insn_p (rtx insn, rtx dest)\n int\n avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n+  /* The fake registers are designed to hold exactly a pointer.  */\n+  if (regno == ARG_POINTER_REGNUM || regno == FRAME_POINTER_REGNUM)\n+    return mode == Pmode;\n+\n   /* NOTE: 8-bit values must not be disallowed for R28 or R29.\n         Disallowing QI et al. in these regs might lead to code like\n             (set (subreg:QI (reg:HI 28) n) ...)\n@@ -8812,7 +8797,6 @@ avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n     return 0;\n \n   /* All modes larger than 8 bits should start in an even register.  */\n-  \n   return !(regno & 1);\n }\n \n@@ -8872,7 +8856,8 @@ avr_regno_mode_code_ok_for_base_p (int regno,\n       && (regno == REG_X\n           || regno == REG_Y\n           || regno == REG_Z\n-          || regno == ARG_POINTER_REGNUM))\n+          || regno == ARG_POINTER_REGNUM\n+\t  || regno == FRAME_POINTER_REGNUM))\n     {\n       ok = true;\n     }\n@@ -8883,7 +8868,8 @@ avr_regno_mode_code_ok_for_base_p (int regno,\n       if (regno == REG_X\n           || regno == REG_Y\n           || regno == REG_Z\n-          || regno == ARG_POINTER_REGNUM)\n+          || regno == ARG_POINTER_REGNUM\n+\t  || regno == FRAME_POINTER_REGNUM)\n         {\n           ok = true;\n         }"}, {"sha": "a231b7f8b4db3228733f1fef23ca2a99497080d1", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b876e5556ffbb0fe367eda217cb4e74125c1f/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b876e5556ffbb0fe367eda217cb4e74125c1f/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=105b876e5556ffbb0fe367eda217cb4e74125c1f", "patch": "@@ -231,45 +231,47 @@ enum\n \n #define FIRST_PSEUDO_REGISTER 36\n \n-#define FIXED_REGISTERS {\\\n-  1,1,/* r0 r1 */\\\n-  0,0,/* r2 r3 */\\\n-  0,0,/* r4 r5 */\\\n-  0,0,/* r6 r7 */\\\n-  0,0,/* r8 r9 */\\\n-  0,0,/* r10 r11 */\\\n-  0,0,/* r12 r13 */\\\n-  0,0,/* r14 r15 */\\\n-  0,0,/* r16 r17 */\\\n-  0,0,/* r18 r19 */\\\n-  0,0,/* r20 r21 */\\\n-  0,0,/* r22 r23 */\\\n-  0,0,/* r24 r25 */\\\n-  0,0,/* r26 r27 */\\\n-  0,0,/* r28 r29 */\\\n-  0,0,/* r30 r31 */\\\n-  1,1,/*  STACK */\\\n-  1,1 /* arg pointer */  }\n+#define FIXED_REGISTERS {\t\t\t\\\n+  1,1,/* r0 r1 */\t\t\t\t\\\n+  0,0,/* r2 r3 */\t\t\t\t\\\n+  0,0,/* r4 r5 */\t\t\t\t\\\n+  0,0,/* r6 r7 */\t\t\t\t\\\n+  0,0,/* r8 r9 */\t\t\t\t\\\n+  0,0,/* r10 r11 */\t\t\t\t\\\n+  0,0,/* r12 r13 */\t\t\t\t\\\n+  0,0,/* r14 r15 */\t\t\t\t\\\n+  0,0,/* r16 r17 */\t\t\t\t\\\n+  0,0,/* r18 r19 */\t\t\t\t\\\n+  0,0,/* r20 r21 */\t\t\t\t\\\n+  0,0,/* r22 r23 */\t\t\t\t\\\n+  0,0,/* r24 r25 */\t\t\t\t\\\n+  0,0,/* r26 r27 */\t\t\t\t\\\n+  0,0,/* r28 r29 */\t\t\t\t\\\n+  0,0,/* r30 r31 */\t\t\t\t\\\n+  1,1,/*  STACK */\t\t\t\t\\\n+  1,  /* arg pointer */\t\t\t\t\\\n+  1   /* frame pointer */ }\n \n #define CALL_USED_REGISTERS {\t\t\t\\\n   1,1,/* r0 r1 */\t\t\t\t\\\n-    0,0,/* r2 r3 */\t\t\t\t\\\n-    0,0,/* r4 r5 */\t\t\t\t\\\n-    0,0,/* r6 r7 */\t\t\t\t\\\n-    0,0,/* r8 r9 */\t\t\t\t\\\n-    0,0,/* r10 r11 */\t\t\t\t\\\n-    0,0,/* r12 r13 */\t\t\t\t\\\n-    0,0,/* r14 r15 */\t\t\t\t\\\n-    0,0,/* r16 r17 */\t\t\t\t\\\n-    1,1,/* r18 r19 */\t\t\t\t\\\n-    1,1,/* r20 r21 */\t\t\t\t\\\n-    1,1,/* r22 r23 */\t\t\t\t\\\n-    1,1,/* r24 r25 */\t\t\t\t\\\n-    1,1,/* r26 r27 */\t\t\t\t\\\n-    0,0,/* r28 r29 */\t\t\t\t\\\n-    1,1,/* r30 r31 */\t\t\t\t\\\n-    1,1,/*  STACK */\t\t\t\t\\\n-    1,1 /* arg pointer */  }\n+  0,0,/* r2 r3 */\t\t\t\t\\\n+  0,0,/* r4 r5 */\t\t\t\t\\\n+  0,0,/* r6 r7 */\t\t\t\t\\\n+  0,0,/* r8 r9 */\t\t\t\t\\\n+  0,0,/* r10 r11 */\t\t\t\t\\\n+  0,0,/* r12 r13 */\t\t\t\t\\\n+  0,0,/* r14 r15 */\t\t\t\t\\\n+  0,0,/* r16 r17 */\t\t\t\t\\\n+  1,1,/* r18 r19 */\t\t\t\t\\\n+  1,1,/* r20 r21 */\t\t\t\t\\\n+  1,1,/* r22 r23 */\t\t\t\t\\\n+  1,1,/* r24 r25 */\t\t\t\t\\\n+  1,1,/* r26 r27 */\t\t\t\t\\\n+  0,0,/* r28 r29 */\t\t\t\t\\\n+  1,1,/* r30 r31 */\t\t\t\t\\\n+  1,1,/*  STACK */\t\t\t\t\\\n+  1,  /* arg pointer */\t\t\t\t\\\n+  1   /* frame pointer */ }\n \n #define REG_ALLOC_ORDER {\t\t\t\\\n     24,25,\t\t\t\t\t\\\n@@ -287,7 +289,7 @@ enum\n #define ADJUST_REG_ALLOC_ORDER order_regs_for_local_alloc ()\n \n \n-#define HARD_REGNO_NREGS(REGNO, MODE) ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#define HARD_REGNO_NREGS(REGNO, MODE) avr_hard_regno_nregs(REGNO, MODE)\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) avr_hard_regno_mode_ok(REGNO, MODE)\n \n@@ -337,17 +339,17 @@ enum reg_class {\n   {3 << REG_Z,0x00000000},      /* POINTER_Z_REGS, r30 - r31 */\t\t\\\n   {0x00000000,0x00000003},\t/* STACK_REG, STACK */\t\t\t\\\n   {(3 << REG_Y) | (3 << REG_Z),\t\t\t\t\t\t\\\n-     0x00000000},\t\t/* BASE_POINTER_REGS, r28 - r31 */\t\\\n+     0x0000000c},\t\t/* BASE_POINTER_REGS, r28 - r31,ap,fp */ \\\n   {(3 << REG_X) | (3 << REG_Y) | (3 << REG_Z),\t\t\t\t\\\n-     0x00000000},\t\t/* POINTER_REGS, r26 - r31 */\t\t\\\n+     0x0000000c},\t\t/* POINTER_REGS, r26 - r31 */\t\t\\\n   {(3 << REG_X) | (3 << REG_Y) | (3 << REG_Z) | (3 << REG_W),\t\t\\\n      0x00000000},\t\t/* ADDW_REGS, r24 - r31 */\t\t\\\n   {0x00ff0000,0x00000000},\t/* SIMPLE_LD_REGS r16 - r23 */          \\\n   {(3 << REG_X)|(3 << REG_Y)|(3 << REG_Z)|(3 << REG_W)|(0xff << 16),\t\\\n-     0x00000000},\t/* LD_REGS, r16 - r31 */\t\t\t\\\n+     0x0000000c},\t/* LD_REGS, r16 - r31 */\t\t\t\\\n   {0x0000ffff,0x00000000},\t/* NO_LD_REGS  r0 - r15 */              \\\n-  {0xffffffff,0x00000000},\t/* GENERAL_REGS, r0 - r31 */\t\t\\\n-  {0xffffffff,0x00000003}\t/* ALL_REGS */\t\t\t\t\\\n+  {0xffffffff,0x0000000c},\t/* GENERAL_REGS, r0 - r31 */\t\t\\\n+  {0xffffffff,0x0000000f}\t/* ALL_REGS */\t\t\t\t\\\n }\n \n #define REGNO_REG_CLASS(R) avr_regno_reg_class(R)\n@@ -378,18 +380,20 @@ enum reg_class {\n \n #define STACK_POINTER_REGNUM 32\n \n-#define FRAME_POINTER_REGNUM REG_Y\n+#define HARD_FRAME_POINTER_REGNUM REG_Y\n \n #define ARG_POINTER_REGNUM 34\n+#define FRAME_POINTER_REGNUM 35\n \n #define STATIC_CHAIN_REGNUM 2\n \n #define ELIMINABLE_REGS {\t\t\t\t\t\\\n-      {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n-\t{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\\\n-       ,{FRAME_POINTER_REGNUM+1,STACK_POINTER_REGNUM+1}}\n+     { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\t\\\n+     { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },\t\t\\\n+     { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\t\\\n+     { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM }}\n \n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\\\n   OFFSET = avr_initial_elimination_offset (FROM, TO)\n \n #define RETURN_ADDR_RTX(count, tem) avr_return_addr_rtx (count, tem)\n@@ -493,7 +497,7 @@ typedef struct avr_args {\n     \"r8\",\"r9\",\"r10\",\"r11\",\"r12\",\"r13\",\"r14\",\"r15\",\t\\\n     \"r16\",\"r17\",\"r18\",\"r19\",\"r20\",\"r21\",\"r22\",\"r23\",\t\\\n     \"r24\",\"r25\",\"r26\",\"r27\",\"r28\",\"r29\",\"r30\",\"r31\",\t\\\n-    \"__SP_L__\",\"__SP_H__\",\"argL\",\"argH\"}\n+    \"__SP_L__\",\"__SP_H__\",\"ap\",\"fp\"}\n \n #define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)\n "}]}