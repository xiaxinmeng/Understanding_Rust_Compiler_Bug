{"sha": "4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI0YjJlNThlMzE4ZjQ5MWJmYzhkOTM5MTI5YjZkNmZiZmE2NTBmOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-05T20:04:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-05T20:04:45Z"}, "message": "cp-tree.h (IDENTIFIER_GLOBAL_VALUE): Use get_namespace_value.\n\n\t* cp-tree.h (IDENTIFIER_GLOBAL_VALUE): Use get_namespace_value.\n\t(SET_IDENTIFIER_GLOBAL_VALUE): Use set_global_value.\n\t(IDENTIFIER_NAMESPACE_VALUE): Delete.\n\t* name-lookup.h (namespace_binding, set_namespace_binding):\n\tReplace\n\twith ...\n\t(get_namespace_value, set_global_value): ... these.\n\t(get_global_value_if_present, is_typename_at_global_scope):\n\tDelete.\n\t* decl.c (poplevel): Use get_namespace_value.\n\t(grokdeclarator): Use IDENTIFIER_GLOBAL_VALUE.\n\t* class.c (build_vtbl_initializer): Stash library decl in\n\tstatic var. Use IDENTIFIER_GLOBAL_VALUE.\n\t* except.c (do_get_exception_ptr, do_begin_catch, do_end_catch)\n\tdo_allocate_exception, do_free_exception, build_throw): Likewise.\n\t* init.c (throw_bad_array_new_length): Likewise.\n\t* rtti.c (throw_bad_cast, throw_bad_typeid): Likewise.\n\t* name-lookup.c (arg_assoc_namespace, pushdecl_maybe_friend_1)\n\tcheck_for_our_of_scope_variable, push_overloaded_decl_1): Use\n\tget_namespace_value.\n\t(set_namespace_binding_1): Rename to\n\t(set_namespace_binding): ... here.\n\t(set_global_value): New.\n\t(lookup_name_innermost_nonclass_level_1, push_namespace): Use\n\tget_namespace_value.\n\t* pt.c (listify): Use get_namespace_value.\n((--This line, and those below, will be ignored--\n\nM    cp/name-lookup.c\nM    cp/name-lookup.h\nM    cp/ChangeLog\nM    cp/except.c\nM    cp/class.c\nM    cp/pt.c\nM    cp/init.c\nM    cp/cp-tree.h\nM    cp/decl.c\nM    cp/rtti.c\n\nFrom-SVN: r247654", "tree": {"sha": "002453e2ee6e27c37bcedfa7b53ecacfcf61ee37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/002453e2ee6e27c37bcedfa7b53ecacfcf61ee37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "359b060e79c2fc423b733229205a9cfbcd634a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/359b060e79c2fc423b733229205a9cfbcd634a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/359b060e79c2fc423b733229205a9cfbcd634a0a"}], "stats": {"total": 409, "additions": 234, "deletions": 175}, "files": [{"sha": "f81b6863d0322e45a32b7a00831377aaf4d752bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -1,5 +1,30 @@\n 2017-05-05  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (IDENTIFIER_GLOBAL_VALUE): Use get_namespace_value.\n+\t(SET_IDENTIFIER_GLOBAL_VALUE): Use set_global_value.\n+\t(IDENTIFIER_NAMESPACE_VALUE): Delete.\n+\t* name-lookup.h (namespace_binding, set_namespace_binding): Replace\n+\twith ...\n+\t(get_namespace_value, set_global_value): ... these.\n+\t(get_global_value_if_present, is_typename_at_global_scope): Delete.\n+\t* decl.c (poplevel): Use get_namespace_value.\n+\t(grokdeclarator): Use IDENTIFIER_GLOBAL_VALUE.\n+\t* class.c (build_vtbl_initializer): Stash library decl in\n+\tstatic var. Use IDENTIFIER_GLOBAL_VALUE.\n+\t* except.c (do_get_exception_ptr, do_begin_catch, do_end_catch,\n+\tdo_allocate_exception, do_free_exception, build_throw): Likewise.\n+\t* init.c (throw_bad_array_new_length): Likewise.\n+\t* rtti.c (throw_bad_cast, throw_bad_typeid): Likewise.\n+\t* name-lookup.c (arg_assoc_namespace, pushdecl_maybe_friend_1,\n+\tcheck_for_our_of_scope_variable, push_overloaded_decl_1): Use\n+\tget_namespace_value.\n+\t(set_namespace_binding_1): Rename to\n+\t(set_namespace_binding): ... here.\n+\t(set_global_value): New.\n+\t(lookup_name_innermost_nonclass_level_1, push_namespace): Use\n+\tget_namespace_value.\n+\t* pt.c (listify): Use get_namespace_value.\n+\n \t* call.c (make_temporary_var_for_ref_to_temp): Push decl into\n \tcurrent scope.\n \t* lex.c (unqualified_name_lookup_error): Likewise."}, {"sha": "945406e8bdbca53755208943311597abd1d87f07", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -9769,11 +9769,18 @@ build_vtbl_initializer (tree binfo,\n \t  /* Likewise for deleted virtuals.  */\n \t  else if (DECL_DELETED_FN (fn_original))\n \t    {\n-\t      fn = get_identifier (\"__cxa_deleted_virtual\");\n-\t      if (!get_global_value_if_present (fn, &fn))\n-\t\tfn = push_library_fn (fn, (build_function_type_list\n-\t\t\t\t\t   (void_type_node, NULL_TREE)),\n-\t\t\t\t      NULL_TREE, ECF_NORETURN);\n+\t      static tree fn;\n+\n+\t      if (!fn)\n+\t\t{\n+\t\t  tree name = get_identifier (\"__cxa_deleted_virtual\");\n+\t\t  fn = IDENTIFIER_GLOBAL_VALUE (name);\n+\t\t  if (!fn)\n+\t\t    fn = push_library_fn\n+\t\t      (name,\n+\t\t       build_function_type_list (void_type_node, NULL_TREE),\n+\t\t       NULL_TREE, ECF_NORETURN);\n+\t\t}\n \t      if (!TARGET_VTABLE_USES_DESCRIPTORS)\n \t\tinit = fold_convert (vfunc_ptr_type_node,\n \t\t\t\t     build_fold_addr_expr (fn));"}, {"sha": "f8f9060efd68588ee00491f3b93a7b9431dffc45", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -554,13 +554,9 @@ struct GTY(()) ptrmem_cst {\n typedef struct ptrmem_cst * ptrmem_cst_t;\n \n #define IDENTIFIER_GLOBAL_VALUE(NODE) \\\n-  namespace_binding ((NODE), global_namespace)\n+  get_namespace_value (NULL_TREE, (NODE))\n #define SET_IDENTIFIER_GLOBAL_VALUE(NODE, VAL) \\\n-  set_namespace_binding ((NODE), global_namespace, (VAL))\n-#define IDENTIFIER_NAMESPACE_VALUE(NODE) \\\n-  namespace_binding ((NODE), current_namespace)\n-#define SET_IDENTIFIER_NAMESPACE_VALUE(NODE, VAL) \\\n-  set_namespace_binding ((NODE), current_namespace, (VAL))\n+  set_global_value ((NODE), (VAL))\n \n #define CLEANUP_P(NODE)\t\tTREE_LANG_FLAG_0 (TRY_BLOCK_CHECK (NODE))\n "}, {"sha": "bbdbda753bef82977bf17d453b1e00d0bc33e15c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -687,16 +687,13 @@ poplevel (int keep, int reverse, int functionbody)\n \t  && DECL_NAME (link))\n \t{\n \t  tree name = DECL_NAME (link);\n-\t  cxx_binding *ob;\n-\t  tree ns_binding;\n \n-\t  ob = outer_binding (name,\n-\t\t\t      IDENTIFIER_BINDING (name),\n-\t\t\t      /*class_p=*/true);\n+\t  cxx_binding *ob = outer_binding (name,\n+\t\t\t\t\t   IDENTIFIER_BINDING (name),\n+\t\t\t\t\t   /*class_p=*/true);\n+\t  tree ns_binding = NULL_TREE;\n \t  if (!ob)\n-\t    ns_binding = IDENTIFIER_NAMESPACE_VALUE (name);\n-\t  else\n-\t    ns_binding = NULL_TREE;\n+\t    ns_binding = get_namespace_value (current_namespace, name);\n \n \t  if (ob && ob->scope == current_binding_level->level_chain)\n \t    /* We have something like:\n@@ -10148,7 +10145,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    gcc_assert (flags == NO_SPECIAL);\n \t\t    flags = TYPENAME_FLAG;\n \t\t    sfk = sfk_conversion;\n-\t\t    if (is_typename_at_global_scope (dname))\n+\t\t    tree glob = IDENTIFIER_GLOBAL_VALUE (dname);\n+\t\t    if (glob && TREE_CODE (glob) == TYPE_DECL)\n \t\t      name = identifier_to_locale (IDENTIFIER_POINTER (dname));\n \t\t    else\n \t\t      name = \"<invalid operator>\";"}, {"sha": "b4fe07af4d0e6f1cf3e408568d6bb25b01359289", "filename": "gcc/cp/except.c", "status": "modified", "additions": 127, "deletions": 94, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -154,14 +154,17 @@ declare_library_fn (tree name, tree return_type, tree parm_type, int ecf_flags)\n static tree\n do_get_exception_ptr (void)\n {\n-  tree fn;\n+  static tree fn;\n \n-  fn = get_identifier (\"__cxa_get_exception_ptr\");\n-  if (!get_global_value_if_present (fn, &fn))\n+  if (!fn)\n     {\n-      /* Declare void* __cxa_get_exception_ptr (void *) throw().  */\n-      fn = declare_library_fn (fn, ptr_type_node, ptr_type_node,\n-\t\t\t       ECF_NOTHROW | ECF_PURE | ECF_LEAF | ECF_TM_PURE);\n+      tree name = get_identifier (\"__cxa_get_exception_ptr\");\n+      fn = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (!fn)\n+\t/* Declare void* __cxa_get_exception_ptr (void *) throw().  */\n+\tfn = declare_library_fn\n+\t  (name, ptr_type_node, ptr_type_node,\n+\t   ECF_NOTHROW | ECF_PURE | ECF_LEAF | ECF_TM_PURE);\n     }\n \n   return cp_build_function_call_nary (fn, tf_warning_or_error,\n@@ -174,22 +177,29 @@ do_get_exception_ptr (void)\n static tree\n do_begin_catch (void)\n {\n-  tree fn;\n+  static tree fn;\n \n-  fn = get_identifier (\"__cxa_begin_catch\");\n-  if (!get_global_value_if_present (fn, &fn))\n+  if (!fn)\n     {\n-      /* Declare void* __cxa_begin_catch (void *) throw().  */\n-      fn = declare_library_fn (fn, ptr_type_node, ptr_type_node, ECF_NOTHROW);\n-\n-      /* Create its transactional-memory equivalent.  */\n-      if (flag_tm)\n+      tree name = fn = get_identifier (\"__cxa_begin_catch\");\n+      fn = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (!fn)\n \t{\n-\t  tree fn2 = get_identifier (\"_ITM_cxa_begin_catch\");\n-\t  if (!get_global_value_if_present (fn2, &fn2))\n-\t    fn2 = declare_library_fn (fn2, ptr_type_node,\n-\t\t\t\t      ptr_type_node, ECF_NOTHROW | ECF_TM_PURE);\n-\t  record_tm_replacement (fn, fn2);\n+\t  /* Declare void* __cxa_begin_catch (void *) throw().  */\n+\t  fn = declare_library_fn\n+\t    (name, ptr_type_node, ptr_type_node, ECF_NOTHROW);\n+\n+\t  /* Create its transactional-memory equivalent.  */\n+\t  if (flag_tm)\n+\t    {\n+\t      tree itm_name = get_identifier (\"_ITM_cxa_begin_catch\");\n+\t      tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n+\t      if (!itm_fn)\n+\t\titm_fn = declare_library_fn\n+\t\t  (itm_name, ptr_type_node, ptr_type_node,\n+\t\t   ECF_NOTHROW | ECF_TM_PURE);\n+\t      record_tm_replacement (fn, itm_fn);\n+\t    }\n \t}\n     }\n \n@@ -221,26 +231,32 @@ dtor_nothrow (tree type)\n static tree\n do_end_catch (tree type)\n {\n-  tree fn, cleanup;\n+  static tree fn;\n \n-  fn = get_identifier (\"__cxa_end_catch\");\n-  if (!get_global_value_if_present (fn, &fn))\n+  if (!fn)\n     {\n-      /* Declare void __cxa_end_catch ().\n-         This can throw if the destructor for the exception throws.  */\n-      fn = push_void_library_fn (fn, void_list_node, 0);\n-\n-      /* Create its transactional-memory equivalent.  */\n-      if (flag_tm)\n+      tree name = get_identifier (\"__cxa_end_catch\");\n+      fn = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (!fn)\n \t{\n-\t  tree fn2 = get_identifier (\"_ITM_cxa_end_catch\");\n-\t  if (!get_global_value_if_present (fn2, &fn2))\n-\t    fn2 = push_void_library_fn (fn2, void_list_node, ECF_TM_PURE);\n-\t  record_tm_replacement (fn, fn2);\n+\t  /* Declare void __cxa_end_catch ().\n+\t     This can throw if the destructor for the exception throws.  */\n+\t  fn = push_void_library_fn (name, void_list_node, 0);\n+\n+\t  /* Create its transactional-memory equivalent.  */\n+\t  if (flag_tm)\n+\t    {\n+\t      tree itm_name = get_identifier (\"_ITM_cxa_end_catch\");\n+\t      tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n+\t      if (!itm_fn)\n+\t\titm_fn = push_void_library_fn\n+\t\t  (itm_name, void_list_node, ECF_TM_PURE);\n+\t      record_tm_replacement (fn, itm_fn);\n+\t    }\n \t}\n     }\n \n-  cleanup = cp_build_function_call_vec (fn, NULL, tf_warning_or_error);\n+  tree cleanup = cp_build_function_call_vec (fn, NULL, tf_warning_or_error);\n   TREE_NOTHROW (cleanup) = dtor_nothrow (type);\n \n   return cleanup;\n@@ -500,23 +516,28 @@ finish_eh_spec_block (tree raw_raises, tree eh_spec_block)\n static tree\n do_allocate_exception (tree type)\n {\n-  tree fn;\n+  static tree fn;\n \n-  fn = get_identifier (\"__cxa_allocate_exception\");\n-  if (!get_global_value_if_present (fn, &fn))\n+  if (!fn)\n     {\n-      /* Declare void *__cxa_allocate_exception(size_t) throw().  */\n-      fn = declare_library_fn (fn, ptr_type_node, size_type_node,\n-\t\t\t        ECF_NOTHROW | ECF_MALLOC);\n-\n-      if (flag_tm)\n+      tree name = get_identifier (\"__cxa_allocate_exception\");\n+      fn = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (!fn)\n \t{\n-\t  tree fn2 = get_identifier (\"_ITM_cxa_allocate_exception\");\n-\t  if (!get_global_value_if_present (fn2, &fn2))\n-\t    fn2 = declare_library_fn (fn2, ptr_type_node,\n-\t\t\t\t      size_type_node, \n-\t\t\t\t      ECF_NOTHROW | ECF_MALLOC | ECF_TM_PURE);\n-\t  record_tm_replacement (fn, fn2);\n+\t  /* Declare void *__cxa_allocate_exception(size_t) throw().  */\n+\t  fn = declare_library_fn (name, ptr_type_node, size_type_node,\n+\t\t\t\t   ECF_NOTHROW | ECF_MALLOC);\n+\n+\t  if (flag_tm)\n+\t    {\n+\t      tree itm_name = get_identifier (\"_ITM_cxa_allocate_exception\");\n+\t      tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n+\t      if (!itm_fn)\n+\t\titm_fn = declare_library_fn\n+\t\t  (itm_name, ptr_type_node, size_type_node, \n+\t\t   ECF_NOTHROW | ECF_MALLOC | ECF_TM_PURE);\n+\t      record_tm_replacement (fn, itm_fn);\n+\t    }\n \t}\n     }\n \n@@ -530,23 +551,28 @@ do_allocate_exception (tree type)\n static tree\n do_free_exception (tree ptr)\n {\n-  tree fn;\n+  static tree fn;\n \n-  fn = get_identifier (\"__cxa_free_exception\");\n-  if (!get_global_value_if_present (fn, &fn))\n+  if (!fn)\n     {\n-      /* Declare void __cxa_free_exception (void *) throw().  */\n-      fn = declare_library_fn (fn, void_type_node, ptr_type_node,\n-\t\t\t       ECF_NOTHROW | ECF_LEAF);\n-\n-      if (flag_tm)\n+      tree name = get_identifier (\"__cxa_free_exception\");\n+      fn = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (!fn)\n \t{\n-\t  tree fn2 = get_identifier (\"_ITM_cxa_free_exception\");\n-\t  if (!get_global_value_if_present (fn2, &fn2))\n-\t    fn2 = declare_library_fn (fn2, void_type_node,\n-\t\t\t\t      ptr_type_node,\n-\t\t\t\t      ECF_NOTHROW | ECF_LEAF | ECF_TM_PURE);\n-\t  record_tm_replacement (fn, fn2);\n+\t  /* Declare void __cxa_free_exception (void *) throw().  */\n+\t  fn = declare_library_fn (name, void_type_node, ptr_type_node,\n+\t\t\t\t   ECF_NOTHROW | ECF_LEAF);\n+\n+\t  if (flag_tm)\n+\t    {\n+\t      tree itm_name = get_identifier (\"_ITM_cxa_free_exception\");\n+\t      tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n+\t      if (!itm_fn)\n+\t\titm_fn = declare_library_fn\n+\t\t  (itm_name, void_type_node, ptr_type_node,\n+\t\t   ECF_NOTHROW | ECF_LEAF | ECF_TM_PURE);\n+\t      record_tm_replacement (fn, itm_fn);\n+\t    }\n \t}\n     }\n \n@@ -588,8 +614,6 @@ wrap_cleanups_r (tree *tp, int *walk_subtrees, void * /*data*/)\n tree\n build_throw (tree exp)\n {\n-  tree fn;\n-\n   if (exp == error_mark_node)\n     return exp;\n \n@@ -616,6 +640,7 @@ build_throw (tree exp)\n \n   if (exp)\n     {\n+      static tree throw_fn;\n       tree throw_type;\n       tree temp_type;\n       tree cleanup;\n@@ -631,23 +656,28 @@ build_throw (tree exp)\n \t  cleanup_type = build_pointer_type (tmp);\n \t}\n \n-      fn = get_identifier (\"__cxa_throw\");\n-      if (!get_global_value_if_present (fn, &fn))\n+      if (!throw_fn)\n \t{\n-\t  /* Declare void __cxa_throw (void*, void*, void (*)(void*)).  */\n-\t  /* ??? Second argument is supposed to be \"std::type_info*\".  */\n-\t  tmp = build_function_type_list (void_type_node,\n-\t\t\t\t\t  ptr_type_node, ptr_type_node,\n-\t\t\t\t\t  cleanup_type, NULL_TREE);\n-\t  fn = push_throw_library_fn (fn, tmp);\n-\n-\t  if (flag_tm)\n+\t  tree name = get_identifier (\"__cxa_throw\");\n+\t  throw_fn = IDENTIFIER_GLOBAL_VALUE (name);\n+\t  if (!throw_fn)\n \t    {\n-\t      tree fn2 = get_identifier (\"_ITM_cxa_throw\");\n-\t      if (!get_global_value_if_present (fn2, &fn2))\n-\t\tfn2 = push_throw_library_fn (fn2, tmp);\n-\t      apply_tm_attr (fn2, get_identifier (\"transaction_pure\"));\n-\t      record_tm_replacement (fn, fn2);\n+\t      /* Declare void __cxa_throw (void*, void*, void (*)(void*)).  */\n+\t      /* ??? Second argument is supposed to be \"std::type_info*\".  */\n+\t      tmp = build_function_type_list (void_type_node,\n+\t\t\t\t\t      ptr_type_node, ptr_type_node,\n+\t\t\t\t\t      cleanup_type, NULL_TREE);\n+\t      throw_fn = push_throw_library_fn (name, tmp);\n+\n+\t      if (flag_tm)\n+\t\t{\n+\t\t  tree itm_name = get_identifier (\"_ITM_cxa_throw\");\n+\t\t  tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n+\t\t  if (!itm_fn)\n+\t\t    itm_fn = push_throw_library_fn (itm_name, tmp);\n+\t\t  apply_tm_attr (itm_fn, get_identifier (\"transaction_pure\"));\n+\t\t  record_tm_replacement (throw_fn, itm_fn);\n+\t\t}\n \t    }\n \t}\n \n@@ -739,22 +769,22 @@ build_throw (tree exp)\n       cleanup = NULL_TREE;\n       if (type_build_dtor_call (TREE_TYPE (object)))\n \t{\n-\t  tree fn = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n-\t\t\t\t     complete_dtor_identifier, 0);\n-\t  fn = BASELINK_FUNCTIONS (fn);\n-\t  mark_used (fn);\n+\t  tree dtor_fn = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n+\t\t\t\t\t  complete_dtor_identifier, 0);\n+\t  dtor_fn = BASELINK_FUNCTIONS (dtor_fn);\n+\t  mark_used (dtor_fn);\n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (object)))\n \t    {\n-\t      cxx_mark_addressable (fn);\n+\t      cxx_mark_addressable (dtor_fn);\n \t      /* Pretend it's a normal function.  */\n-\t      cleanup = build1 (ADDR_EXPR, cleanup_type, fn);\n+\t      cleanup = build1 (ADDR_EXPR, cleanup_type, dtor_fn);\n \t    }\n \t}\n       if (cleanup == NULL_TREE)\n \tcleanup = build_int_cst (cleanup_type, 0);\n \n       /* ??? Indicate that this function call throws throw_type.  */\n-      tmp = cp_build_function_call_nary (fn, tf_warning_or_error,\n+      tmp = cp_build_function_call_nary (throw_fn, tf_warning_or_error,\n \t\t\t\t\t ptr, throw_type, cleanup, NULL_TREE);\n \n       /* Tack on the initialization stuff.  */\n@@ -763,21 +793,24 @@ build_throw (tree exp)\n   else\n     {\n       /* Rethrow current exception.  */\n+      static tree rethrow_fn;\n \n-      tree fn = get_identifier (\"__cxa_rethrow\");\n-      if (!get_global_value_if_present (fn, &fn))\n+      if (!rethrow_fn)\n \t{\n-\t  /* Declare void __cxa_rethrow (void).  */\n-\t  fn = push_throw_library_fn\n-\t    (fn, build_function_type_list (void_type_node, NULL_TREE));\n-\t}\n+\t  tree name = get_identifier (\"__cxa_rethrow\");\n+\t  rethrow_fn = IDENTIFIER_GLOBAL_VALUE (name);\n+\t  if (!rethrow_fn)\n+\t    /* Declare void __cxa_rethrow (void).  */\n+\t    rethrow_fn = push_throw_library_fn\n+\t      (name, build_function_type_list (void_type_node, NULL_TREE));\n \n-      if (flag_tm)\n-\tapply_tm_attr (fn, get_identifier (\"transaction_pure\"));\n+\t  if (flag_tm)\n+\t    apply_tm_attr (rethrow_fn, get_identifier (\"transaction_pure\"));\n+\t}\n \n       /* ??? Indicate that this function call allows exceptions of the type\n \t of the enclosing catch block (if known).  */\n-      exp = cp_build_function_call_vec (fn, NULL, tf_warning_or_error);\n+      exp = cp_build_function_call_vec (rethrow_fn, NULL, tf_warning_or_error);\n     }\n \n   exp = build1 (THROW_EXPR, void_type_node, exp);"}, {"sha": "00916d73a9103f3cb3c5d64047d383426dd0fd60", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -2402,10 +2402,16 @@ diagnose_uninitialized_cst_or_ref_member (tree type, bool using_new, bool compla\n tree\n throw_bad_array_new_length (void)\n {\n-  tree fn = get_identifier (\"__cxa_throw_bad_array_new_length\");\n-  if (!get_global_value_if_present (fn, &fn))\n-    fn = push_throw_library_fn (fn, build_function_type_list (sizetype,\n-\t\t\t\t\t\t\t      NULL_TREE));\n+  static tree fn;\n+  if (!fn)\n+    {\n+      tree name = get_identifier (\"__cxa_throw_bad_array_new_length\");\n+\n+      fn = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (!fn)\n+\tfn = push_throw_library_fn\n+\t  (name, build_function_type_list (sizetype, NULL_TREE));\n+    }\n \n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n }"}, {"sha": "f820c88cdd54eefce4b06b2a2f25197e91c1ce31", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -37,6 +37,8 @@ static cxx_binding *cxx_binding_make (tree value, tree type);\n static cp_binding_level *innermost_nonclass_level (void);\n static void set_identifier_type_value_with_scope (tree id, tree decl,\n \t\t\t\t\t\t  cp_binding_level *b);\n+static void set_namespace_binding (tree name, tree scope, tree val);\n+\n /* The bindings for a particular name in a particular scope.  */\n \n struct scope_binding {\n@@ -213,7 +215,7 @@ arg_assoc_namespace (struct arg_lookup *k, tree scope)\n       if (arg_assoc_namespace (k, TREE_PURPOSE (value)))\n \treturn true;\n \n-  value = namespace_binding (k->name, scope);\n+  value = get_namespace_value (scope, k->name);\n   if (!value)\n     return false;\n \n@@ -1248,7 +1250,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n       /* In case this decl was explicitly namespace-qualified, look it\n \t up in its namespace context.  */\n       if (DECL_NAMESPACE_SCOPE_P (x) && namespace_bindings_p ())\n-\tt = namespace_binding (name, DECL_CONTEXT (x));\n+\tt = get_namespace_value (DECL_CONTEXT (x), name);\n       else\n \tt = lookup_name_innermost_nonclass_level (name);\n \n@@ -1265,7 +1267,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t  t = innermost_non_namespace_value (name);\n \t  /* Or in the innermost namespace.  */\n \t  if (! t)\n-\t    t = namespace_binding (name, DECL_CONTEXT (x));\n+\t    t = get_namespace_value (DECL_CONTEXT (x), name);\n \t  /* Does it have linkage?  Note that if this isn't a DECL, it's an\n \t     OVERLOAD, which is OK.  */\n \t  if (t && DECL_P (t) && ! (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n@@ -1519,7 +1521,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t{\n \t  tree decl;\n \n-\t  decl = IDENTIFIER_NAMESPACE_VALUE (name);\n+\t  decl = get_namespace_value (current_namespace, name);\n \t  if (decl && TREE_CODE (decl) == OVERLOAD)\n \t    decl = OVL_FUNCTION (decl);\n \n@@ -1556,7 +1558,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t  || TREE_CODE (x) == NAMESPACE_DECL\n \t\t  || TREE_CODE (x) == CONST_DECL\n \t\t  || TREE_CODE (x) == TEMPLATE_DECL))\n-\t    SET_IDENTIFIER_NAMESPACE_VALUE (name, x);\n+\t    set_namespace_binding (name, current_namespace, x);\n \n \t  /* If new decl is `static' and an `extern' was seen previously,\n \t     warn about it.  */\n@@ -1566,7 +1568,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n       else\n \t{\n \t  /* Here to install a non-global value.  */\n-\t  tree oldglobal = IDENTIFIER_NAMESPACE_VALUE (name);\n+\t  tree oldglobal = get_namespace_value (current_namespace, name);\n \t  tree oldlocal = NULL_TREE;\n \t  cp_binding_level *oldscope = NULL;\n \t  cxx_binding *oldbinding = outer_binding (name, NULL, true);\n@@ -1605,7 +1607,8 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\toldlocal = DECL_SHADOWED_FOR_VAR (oldlocal);\n \n \t      if (oldlocal == NULL_TREE)\n-\t\toldlocal = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (d));\n+\t\toldlocal\n+\t\t  = get_namespace_value (current_namespace, DECL_NAME (d));\n \t    }\n \n \t  /* If this is an extern function declaration, see if we\n@@ -1969,7 +1972,7 @@ check_for_out_of_scope_variable (tree decl)\n     shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (shadowed)\n       ? DECL_SHADOWED_FOR_VAR (shadowed) : NULL_TREE;\n   if (!shadowed)\n-    shadowed = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (decl));\n+    shadowed = get_namespace_value (current_namespace, DECL_NAME (decl));\n   if (shadowed)\n     {\n       if (!DECL_ERROR_REPORTED (decl))\n@@ -2931,7 +2934,7 @@ push_overloaded_decl_1 (tree decl, int flags, bool is_friend)\n   int doing_global = (namespace_bindings_p () || !(flags & PUSH_LOCAL));\n \n   if (doing_global)\n-    old = namespace_binding (name, DECL_CONTEXT (decl));\n+    old = get_namespace_value (DECL_CONTEXT (decl), name);\n   else\n     old = lookup_name_innermost_nonclass_level (name);\n \n@@ -4016,20 +4019,22 @@ namespace_binding_1 (tree name, tree scope)\n   return binding ? binding->value : NULL_TREE;\n }\n \n+/* Return the binding for NAME in NS.  If NS is NULL, look in\n+   global_namespace.  */\n+\n tree\n-namespace_binding (tree name, tree scope)\n+get_namespace_value (tree ns, tree name)\n {\n-  tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = namespace_binding_1 (name, scope);\n+  if (!ns)\n+    ns = global_namespace;\n+  tree ret = namespace_binding_1 (name, ns);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n \n-/* Set the binding value for name in scope.  */\n-\n static void\n-set_namespace_binding_1 (tree name, tree scope, tree val)\n+set_namespace_binding (tree name, tree scope, tree val)\n {\n   cxx_binding *b;\n \n@@ -4047,13 +4052,16 @@ set_namespace_binding_1 (tree name, tree scope, tree val)\n     supplement_binding (b, val);\n }\n \n-/* Wrapper for set_namespace_binding_1.  */\n+/* Set NAME in the global namespace to VAL.  Does not add it to the\n+   list of things in the namespace.  */\n \n void\n-set_namespace_binding (tree name, tree scope, tree val)\n+set_global_value (tree name, tree val)\n {\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  set_namespace_binding_1 (name, scope, val);\n+\n+  set_namespace_binding (name, global_namespace, val);\n+\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n@@ -5815,7 +5823,7 @@ lookup_name_innermost_nonclass_level_1 (tree name)\n \n   if (b->kind == sk_namespace)\n     {\n-      t = IDENTIFIER_NAMESPACE_VALUE (name);\n+      t = get_namespace_value (current_namespace, name);\n \n       /* extern \"C\" function() */\n       if (t != NULL_TREE && TREE_CODE (t) == TREE_LIST)\n@@ -6467,7 +6475,7 @@ push_namespace (tree name)\n   if (anon)\n     {\n       name = anon_identifier;\n-      d = IDENTIFIER_NAMESPACE_VALUE (name);\n+      d = get_namespace_value (current_namespace, name);\n       if (d)\n \t/* Reopening anonymous namespace.  */\n \tneed_new = false;\n@@ -6476,7 +6484,7 @@ push_namespace (tree name)\n   else\n     {\n       /* Check whether this is an extended namespace definition.  */\n-      d = IDENTIFIER_NAMESPACE_VALUE (name);\n+      d = get_namespace_value (current_namespace, name);\n       if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n \t{\n \t  tree dna = DECL_NAMESPACE_ALIAS (d);"}, {"sha": "20845d314a62eef67dd51f5543c6a1af914f0817", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -311,8 +311,8 @@ extern tree pushdecl_with_scope (tree, cp_binding_level *, bool);\n extern tree lookup_name_prefer_type (tree, int);\n extern tree lookup_name_real (tree, int, int, bool, int, int);\n extern tree lookup_type_scope (tree, tag_scope);\n-extern tree namespace_binding (tree, tree);\n-extern void set_namespace_binding (tree, tree, tree);\n+extern tree get_namespace_value (tree ns, tree id);\n+extern void set_global_value (tree id, tree val);\n extern bool hidden_name_p (tree);\n extern tree remove_hidden_names (tree);\n extern tree lookup_qualified_name (tree, tree, int, bool, /*hidden*/bool = false);\n@@ -342,26 +342,4 @@ extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);\n extern void cp_emit_debug_info_for_using (tree, tree);\n \n-/* Set *DECL to the (non-hidden) declaration for ID at global scope,\n-   if present and return true; otherwise return false.  */\n-\n-inline bool\n-get_global_value_if_present (tree id, tree *decl)\n-{\n-  tree global_value = namespace_binding (id, global_namespace);\n-  if (global_value)\n-    *decl = global_value;\n-  return global_value != NULL;\n-}\n-\n-/* True is the binding of IDENTIFIER at global scope names a type.  */\n-\n-inline bool\n-is_typename_at_global_scope (tree id)\n-{\n-  tree global_value = namespace_binding (id, global_namespace);\n-\n-  return global_value && TREE_CODE (global_value) == TYPE_DECL;\n-}\n-\n #endif /* GCC_CP_NAME_LOOKUP_H */"}, {"sha": "61c3ac0c540bb445b13e6b946ff7b6e5922d957e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -24731,7 +24731,7 @@ make_constrained_auto (tree con, tree args)\n static tree\n listify (tree arg)\n {\n-  tree std_init_list = namespace_binding (init_list_identifier, std_node);\n+  tree std_init_list = get_namespace_value (std_node, init_list_identifier);\n   tree argvec;\n   if (!std_init_list || !DECL_CLASS_TEMPLATE_P (std_init_list))\n     {    "}, {"sha": "89d18914adfe6d87d80225ce250fab3aec483b70", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4b2e58e318f491bfc8d939129b6d6fbfa650f9/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4b4b2e58e318f491bfc8d939129b6d6fbfa650f9", "patch": "@@ -202,10 +202,15 @@ build_headof (tree exp)\n static tree\n throw_bad_cast (void)\n {\n-  tree fn = get_identifier (\"__cxa_bad_cast\");\n-  if (!get_global_value_if_present (fn, &fn))\n-    fn = push_throw_library_fn (fn, build_function_type_list (ptr_type_node,\n-\t\t\t\t\t\t\t      NULL_TREE));\n+  static tree fn;\n+  if (!fn)\n+    {\n+      tree name = get_identifier (\"__cxa_bad_cast\");\n+      fn = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (!fn)\n+\tfn = push_throw_library_fn\n+\t  (name, build_function_type_list (ptr_type_node, NULL_TREE));\n+    }\n \n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n }\n@@ -216,14 +221,17 @@ throw_bad_cast (void)\n static tree\n throw_bad_typeid (void)\n {\n-  tree fn = get_identifier (\"__cxa_bad_typeid\");\n-  if (!get_global_value_if_present (fn, &fn))\n+  static tree fn;\n+  if (!fn)\n     {\n-      tree t;\n-\n-      t = build_reference_type (const_type_info_type_node);\n-      t = build_function_type_list (t, NULL_TREE);\n-      fn = push_throw_library_fn (fn, t);\n+      tree name = get_identifier (\"__cxa_bad_typeid\");\n+      fn = IDENTIFIER_GLOBAL_VALUE (name);\n+      if (!fn)\n+\t{\n+\t  tree t = build_reference_type (const_type_info_type_node);\n+\t  t = build_function_type_list (t, NULL_TREE);\n+\t  fn = push_throw_library_fn (name, t);\n+\t}\n     }\n \n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);"}]}