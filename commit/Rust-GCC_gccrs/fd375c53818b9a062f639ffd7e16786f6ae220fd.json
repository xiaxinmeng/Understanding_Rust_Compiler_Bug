{"sha": "fd375c53818b9a062f639ffd7e16786f6ae220fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQzNzVjNTM4MThiOWEwNjJmNjM5ZmZkN2UxNjc4NmY2YWUyMjBmZA==", "commit": {"author": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2004-09-21T08:35:11Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2004-09-21T08:35:11Z"}, "message": "X500Principal.java: Replaced with GNU Crypto's version.\n\n2004-09-21  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* javax/security/auth/x500/X500Principal.java: Replaced with GNU\n\tCrypto's version.\n\nFrom-SVN: r87796", "tree": {"sha": "4e3aaf59143adcebc2054898b0853ffa84d1609f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e3aaf59143adcebc2054898b0853ffa84d1609f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd375c53818b9a062f639ffd7e16786f6ae220fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd375c53818b9a062f639ffd7e16786f6ae220fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd375c53818b9a062f639ffd7e16786f6ae220fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd375c53818b9a062f639ffd7e16786f6ae220fd/comments", "author": null, "committer": null, "parents": [{"sha": "6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f5ce93bab1c1ce6df0e71aa450f841f3d979bbc"}], "stats": {"total": 449, "additions": 420, "deletions": 29}, "files": [{"sha": "95f80fc582303d0ad3e455706fa7012d482027ca", "filename": "libjava/javax/security/auth/x500/X500Principal.java", "status": "modified", "additions": 420, "deletions": 29, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd375c53818b9a062f639ffd7e16786f6ae220fd/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500Principal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd375c53818b9a062f639ffd7e16786f6ae220fd/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500Principal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500Principal.java?ref=fd375c53818b9a062f639ffd7e16786f6ae220fd", "patch": "@@ -38,16 +38,38 @@\n \n package javax.security.auth.x500;\n \n-import gnu.java.security.x509.X500DistinguishedName;\n+import gnu.java.security.OID;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DEREncodingException;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n \n+import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.EOFException;\n import java.io.NotActiveException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.io.Reader;\n import java.io.Serializable;\n+import java.io.StringReader;\n+\n import java.security.Principal;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n public final class X500Principal implements Principal, Serializable\n {\n   private static final long serialVersionUID = -500463348111345721L;\n@@ -56,44 +78,66 @@ public final class X500Principal implements Principal, Serializable\n   // ------------------------------------------------------------------------\n \n   public static final String CANONICAL = \"CANONICAL\";\n-\n   public static final String RFC1779 = \"RFC1779\";\n-\n   public static final String RFC2253 = \"RFC2253\";\n \n-  private transient X500DistinguishedName name;\n+  private static final OID CN         = new OID(\"2.5.4.3\");\n+  private static final OID C          = new OID(\"2.5.4.6\");\n+  private static final OID L          = new OID(\"2.5.4.7\");\n+  private static final OID ST         = new OID(\"2.5.4.8\");\n+  private static final OID STREET     = new OID(\"2.5.4.9\");\n+  private static final OID O          = new OID(\"2.5.4.10\");\n+  private static final OID OU         = new OID(\"2.5.4.11\");\n+  private static final OID DC         = new OID(\"0.9.2342.19200300.100.1.25\");\n+  private static final OID UID        = new OID(\"0.9.2342.19200300.100.1.1\");\n+\n+  private transient List components;\n+  private transient Map currentRdn;\n+  private transient boolean fixed;\n+  private transient byte[] encoded;\n \n   // Constructors.\n   // ------------------------------------------------------------------------\n \n-  public X500Principal(String name)\n+  private X500Principal()\n   {\n-    if (name == null)\n-      throw new NullPointerException();\n-    this.name = new X500DistinguishedName(name);\n+    components = new LinkedList();\n+    currentRdn = new LinkedHashMap();\n+    components.add (currentRdn);\n   }\n \n-  public X500Principal(byte[] encoded)\n+  public X500Principal (String name)\n   {\n+    this();\n+    if (name == null)\n+      throw new NullPointerException();\n     try\n       {\n-        name = new X500DistinguishedName(encoded);\n+        parseString (name);\n       }\n     catch (IOException ioe)\n       {\n-        throw new IllegalArgumentException(ioe.toString());\n+        IllegalArgumentException iae = new IllegalArgumentException(\"malformed name\");\n+        iae.initCause (ioe);\n+        throw iae;\n+      }\n       }\n+\n+  public X500Principal (byte[] encoded)\n+  {\n+    this(new ByteArrayInputStream (encoded));\n   }\n \n-  public X500Principal(InputStream encoded)\n+  public X500Principal (InputStream encoded)\n   {\n+    this();\n     try\n       {\n-        name = new X500DistinguishedName(encoded);\n+        parseDer (encoded);\n       }\n     catch (IOException ioe)\n       {\n-        throw new IllegalArgumentException(ioe.toString());\n+        throw new IllegalArgumentException (ioe.toString());\n       }\n   }\n \n@@ -102,42 +146,389 @@ public X500Principal(InputStream encoded)\n \n   public boolean equals(Object o)\n   {\n-    return ((X500Principal) o).name.equals(name);\n+    if (!(o instanceof X500Principal))\n+      return false;\n+    if (size() != ((X500Principal) o).size())\n+      return false;\n+    for (int i = 0; i < size(); i++)\n+      {\n+        Map m = (Map) components.get (i);\n+        for (Iterator it2 = m.entrySet().iterator(); it2.hasNext(); )\n+          {\n+            Map.Entry e = (Map.Entry) it2.next();\n+            OID oid = (OID) e.getKey();\n+            String v1 = (String) e.getValue();\n+            String v2 = ((X500Principal) o).getComponent (oid, i);\n+            if (v2 == null)\n+              return false;\n+            if (!compressWS (v1).equalsIgnoreCase (compressWS (v2)))\n+              return false;\n+          }\n+      }\n+    return true;\n   }\n \n   public byte[] getEncoded()\n   {\n-    return name.getEncoded();\n+    if (encoded == null)\n+      encodeDer();\n+    return (byte[]) encoded.clone();\n   }\n \n   public String getName()\n   {\n-    return getName(RFC2253);\n+    return getName (RFC2253);\n+  }\n+\n+  public String getName (final String format)\n+  {\n+    boolean rfc2253 = RFC2253.equalsIgnoreCase (format) ||\n+      CANONICAL.equalsIgnoreCase (format);\n+    boolean rfc1779 = RFC1779.equalsIgnoreCase (format);\n+    boolean canon   = CANONICAL.equalsIgnoreCase (format);\n+    if (! (rfc2253 || rfc1779 || canon))\n+      throw new IllegalArgumentException (\"unsupported format \" + format);\n+    StringBuffer str = new StringBuffer();\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        Map m = (Map) it.next();\n+        for (Iterator it2 = m.entrySet().iterator(); it2.hasNext(); )\n+          {\n+            Map.Entry entry = (Map.Entry) it2.next();\n+            OID oid = (OID) entry.getKey();\n+            String value = (String) entry.getValue();\n+            if (oid.equals (CN))\n+              str.append (\"CN\");\n+            else if (oid.equals (C))\n+              str.append (\"C\");\n+            else if (oid.equals (L))\n+              str.append (\"L\");\n+            else if (oid.equals (ST))\n+              str.append (\"ST\");\n+            else if (oid.equals (STREET))\n+              str.append (\"STREET\");\n+            else if (oid.equals (O))\n+              str.append (\"O\");\n+            else if (oid.equals (OU))\n+              str.append (\"OU\");\n+            else if (oid.equals (DC) && rfc2253)\n+              str.append (\"DC\");\n+            else if (oid.equals (\"UID\") && rfc2253)\n+              str.append (\"UID\");\n+            else\n+              str.append (oid.toString());\n+            str.append('=');\n+            str.append(value);\n+            if (it2.hasNext())\n+              str.append('+');\n+          }\n+        if (it.hasNext())\n+          str.append(',');\n+      }\n+    if (canon)\n+      return str.toString().toUpperCase (Locale.US).toLowerCase (Locale.US);\n+    return str.toString();\n   }\n \n-  public String getName(String format)\n+  public String toString()\n   {\n-    if (format.equalsIgnoreCase(RFC2253))\n-      return name.toRFC2253();\n-    else if (format.equalsIgnoreCase(RFC1779))\n-      return name.toRFC1779();\n-    else if (format.equalsIgnoreCase(CANONICAL))\n-      return name.toCanonical();\n-    throw new IllegalArgumentException(\"unsupported format \" + format);\n+    return getName (RFC2253);\n   }\n \n   // Serialization methods.\n   // ------------------------------------------------------------------------\n \n-  private void writeObject(ObjectOutputStream out) throws IOException\n+  private void writeObject (ObjectOutputStream out) throws IOException\n   {\n-    out.writeObject(name.getEncoded());\n+    if (encoded != null)\n+      encodeDer();\n+    out.writeObject (encoded);\n   }\n \n-  private void readObject(ObjectInputStream in)\n+  private void readObject (ObjectInputStream in)\n     throws IOException, NotActiveException, ClassNotFoundException\n   {\n     byte[] buf = (byte[]) in.readObject();\n-    name = new X500DistinguishedName(buf);\n+    parseDer (new ByteArrayInputStream (buf));\n+  }\n+\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n+\n+  private int size()\n+  {\n+    return components.size();\n+  }\n+\n+  private String getComponent(OID oid, int rdn)\n+  {\n+    if (rdn >= size())\n+      return null;\n+    return (String) ((Map) components.get (rdn)).get (oid);\n+  }\n+\n+  private void encodeDer()\n+  {\n+    ArrayList name = new ArrayList(components.size());\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        Map m = (Map) it.next();\n+        if (m.isEmpty())\n+          continue;\n+        Set rdn = new HashSet();\n+        for (Iterator it2 = m.entrySet().iterator(); it2.hasNext(); )\n+          {\n+            Map.Entry e = (Map.Entry) it.next();\n+            ArrayList atav = new ArrayList(2);\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, e.getKey()));\n+            atav.add(new DERValue(DER.UTF8_STRING, e.getValue()));\n+            rdn.add(new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, atav));\n+          }\n+        name.add(new DERValue(DER.SET|DER.CONSTRUCTED, rdn));\n+      }\n+    DERValue val = new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, name);\n+    encoded = val.getEncoded();\n+  }\n+\n+  private int sep;\n+\n+  private void parseString(String str) throws IOException\n+  {\n+    Reader in = new StringReader(str);\n+    while (true)\n+      {\n+        String key = readAttributeType(in);\n+        if (key == null)\n+          break;\n+        String value = readAttributeValue(in);\n+        putComponent(key, value);\n+        if (sep == ',')\n+          newRelativeDistinguishedName();\n+      }\n+  }\n+\n+  private String readAttributeType(Reader in) throws IOException\n+  {\n+    StringBuffer buf = new StringBuffer();\n+    int ch;\n+    while ((ch = in.read()) != '=')\n+      {\n+        if (ch == -1)\n+          {\n+            if (buf.length() > 0)\n+              throw new EOFException();\n+            return null;\n+          }\n+        if (ch > 127)\n+          throw new IOException(\"Invalid char: \" + (char) ch);\n+        if (Character.isLetterOrDigit((char) ch) || ch == '-' || ch == '.')\n+          buf.append((char) ch);\n+        else\n+          throw new IOException(\"Invalid char: \" + (char) ch);\n+      }\n+    return buf.toString();\n+  }\n+\n+  private String readAttributeValue(Reader in) throws IOException\n+  {\n+    StringBuffer buf = new StringBuffer();\n+    int ch = in.read();\n+    if (ch == '#')\n+      {\n+        while (true)\n+          {\n+            ch = in.read();\n+            if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                || Character.isDigit((char) ch))\n+              buf.append((char) ch);\n+            else if (ch == '+' || ch == ',')\n+              {\n+                sep = ch;\n+                String hex = buf.toString();\n+                return new String(toByteArray(hex));\n+              }\n+            else\n+              throw new IOException(\"illegal character: \" + (char) ch);\n+          }\n+      }\n+    else if (ch == '\"')\n+      {\n+        while (true)\n+          {\n+            ch = in.read();\n+            if (ch == '\"')\n+              break;\n+            else if (ch == '\\\\')\n+              {\n+                ch = in.read();\n+                if (ch == -1)\n+                  throw new EOFException();\n+                if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                    || Character.isDigit((char) ch))\n+                  {\n+                    int i = Character.digit((char) ch, 16) << 4;\n+                    ch = in.read();\n+                    if (!(('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                          || Character.isDigit((char) ch)))\n+                      throw new IOException(\"illegal hex char\");\n+                    i |= Character.digit((char) ch, 16);\n+                    buf.append((char) i);\n+                  }\n+                else\n+                  buf.append((char) ch);\n+              }\n+            else\n+              buf.append((char) ch);\n+          }\n+        sep = in.read();\n+        if (sep != '+' || sep != ',')\n+          throw new IOException(\"illegal character: \" + (char) ch);\n+        return buf.toString();\n+      }\n+    else\n+      {\n+        while (true)\n+          {\n+            switch (ch)\n+              {\n+              case '+':\n+              case ',':\n+                sep = ch;\n+                return buf.toString();\n+              case '\\\\':\n+                ch = in.read();\n+                if (ch == -1)\n+                  throw new EOFException();\n+                if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                    || Character.isDigit((char) ch))\n+                  {\n+                    int i = Character.digit((char) ch, 16) << 4;\n+                    ch = in.read();\n+                    if (!(('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                          || Character.isDigit((char) ch)))\n+                      throw new IOException(\"illegal hex char\");\n+                    i |= Character.digit((char) ch, 16);\n+                    buf.append((char) i);\n+                  }\n+                else\n+                  buf.append((char) ch);\n+                break;\n+              case '=':\n+              case '<':\n+              case '>':\n+              case '#':\n+              case ';':\n+                throw new IOException(\"illegal character: \" + (char) ch);\n+              case -1:\n+                throw new EOFException();\n+              default:\n+                buf.append((char) ch);\n+              }\n+          }\n+      }\n+  }\n+\n+  private void parseDer (InputStream encoded) throws IOException\n+  {\n+    DERReader der = new DERReader (encoded);\n+    DERValue name = der.read();\n+    if (!name.isConstructed())\n+      throw new IOException (\"malformed Name\");\n+    this.encoded = name.getEncoded();\n+    int len = 0;\n+    while (len < name.getLength())\n+      {\n+        DERValue rdn = der.read();\n+        if (!rdn.isConstructed())\n+          throw new IOException (\"badly formed RDNSequence\");\n+        int len2 = 0;\n+        while (len2 < rdn.getLength())\n+          {\n+            DERValue atav = der.read();\n+            if (!atav.isConstructed())\n+              throw new IOException (\"badly formed AttributeTypeAndValue\");\n+            DERValue val = der.read();\n+            if (val.getTag() != DER.OBJECT_IDENTIFIER)\n+              throw new IOException (\"badly formed AttributeTypeAndValue\");\n+            OID oid = (OID) val.getValue();\n+            val = der.read();\n+            if (!(val.getValue() instanceof String))\n+              throw new IOException (\"badly formed AttributeTypeAndValue\");\n+            String value = (String) val.getValue();\n+            putComponent(oid, value);\n+            len2 += atav.getEncodedLength();\n+          }\n+        len += rdn.getEncodedLength();\n+        if (len < name.getLength())\n+          newRelativeDistinguishedName();\n+      }\n+  }\n+\n+  private void newRelativeDistinguishedName()\n+  {\n+    currentRdn = new LinkedHashMap();\n+    components.add(currentRdn);\n+  }\n+\n+  private void putComponent(OID oid, String value)\n+  {\n+    currentRdn.put(oid, value);\n+  }\n+\n+  private void putComponent(String name, String value)\n+  {\n+    name = name.trim().toLowerCase();\n+    if (name.equals(\"cn\"))\n+      putComponent(CN, value);\n+    else if (name.equals(\"c\"))\n+      putComponent(C, value);\n+    else if (name.equals(\"l\"))\n+      putComponent(L, value);\n+    else if (name.equals(\"street\"))\n+      putComponent(STREET, value);\n+    else if (name.equals(\"st\"))\n+      putComponent(ST, value);\n+    else if (name.equals(\"dc\"))\n+      putComponent(DC, value);\n+    else if (name.equals(\"uid\"))\n+      putComponent(UID, value);\n+    else\n+      putComponent(new OID(name), value);\n+  }\n+\n+  private static String compressWS(String str)\n+  {\n+    StringBuffer buf = new StringBuffer();\n+    char lastChar = 0;\n+    for (int i = 0; i < str.length(); i++)\n+      {\n+        char c = str.charAt(i);\n+        if (Character.isWhitespace(c))\n+          {\n+            if (!Character.isWhitespace(lastChar))\n+              buf.append(' ');\n+          }\n+        else\n+          buf.append(c);\n+        lastChar = c;\n+      }\n+    return buf.toString().trim();\n+  }\n+\n+  private static byte[] toByteArray (String str)\n+  {\n+    int limit = str.length();\n+    byte[] result = new byte[((limit + 1) / 2)];\n+    int i = 0, j = 0;\n+    if ((limit % 2) == 1)\n+      {\n+        result[j++] = (byte) Character.digit (str.charAt(i++), 16);\n+      }\n+    while (i < limit)\n+      {\n+        result[j  ]  = (byte) (Character.digit (str.charAt(i++), 16) << 4);\n+        result[j++] |= (byte)  Character.digit (str.charAt(i++), 16);\n+      }\n+    return result;\n   }\n }"}]}