{"sha": "a8fdc208b866c06f7266adeda8cc9ba63dd4cacc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThmZGMyMDhiODY2YzA2ZjcyNjZhZGVkYThjYzliYTYzZGQ0Y2FjYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-29T04:37:22Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-29T04:37:22Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r248", "tree": {"sha": "b592a23807031582a0140e889091b9b6be65495b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b592a23807031582a0140e889091b9b6be65495b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8fdc208b866c06f7266adeda8cc9ba63dd4cacc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fdc208b866c06f7266adeda8cc9ba63dd4cacc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8fdc208b866c06f7266adeda8cc9ba63dd4cacc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fdc208b866c06f7266adeda8cc9ba63dd4cacc/comments", "author": null, "committer": null, "parents": [{"sha": "0e48b5a21ba89dd535e99bb1704110a5a9ff0287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e48b5a21ba89dd535e99bb1704110a5a9ff0287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e48b5a21ba89dd535e99bb1704110a5a9ff0287"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "566b18fbb2330209dbd2c826428dc8ae16ed7e94", "filename": "gcc/reload1.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fdc208b866c06f7266adeda8cc9ba63dd4cacc/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fdc208b866c06f7266adeda8cc9ba63dd4cacc/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a8fdc208b866c06f7266adeda8cc9ba63dd4cacc", "patch": "@@ -366,7 +366,7 @@ init_reload ()\n \n   /* See if reg+reg is a valid (and offsettable) address.  */\n \n-  tem = gen_rtx (PLUS, Pmode, \n+  tem = gen_rtx (PLUS, Pmode,\n \t\t gen_rtx (REG, Pmode, FRAME_POINTER_REGNUM),\n \t\t gen_rtx (REG, Pmode, FRAME_POINTER_REGNUM));\n   /* This way, we make sure that reg+reg is an offsettable address.  */\n@@ -521,7 +521,7 @@ reload (first, global, dumpfile)\n   /* Initialize the save area information for caller-save, in case some\n      are needed.  */\n   init_save_areas ();\n-    \n+\n   /* Compute which hard registers are now in use\n      as homes for pseudo registers.\n      This is done here rather than (eg) in global_alloc\n@@ -570,7 +570,7 @@ reload (first, global, dumpfile)\n \t  rtx note = find_reg_note (insn, REG_EQUIV, 0);\n \t  if (note\n #ifdef LEGITIMATE_PIC_OPERAND_P\n-\t      && (! CONSTANT_P (XEXP (note, 0)) || ! flag_pic \n+\t      && (! CONSTANT_P (XEXP (note, 0)) || ! flag_pic\n \t\t  || LEGITIMATE_PIC_OPERAND_P (XEXP (note, 0)))\n #endif\n \t      )\n@@ -647,7 +647,7 @@ reload (first, global, dumpfile)\n #endif\n \n   /* Count the number of eliminable registers and build the FROM and TO\n-     REG rtx's.  Note that code in gen_rtx will cause, e.g., \n+     REG rtx's.  Note that code in gen_rtx will cause, e.g.,\n      gen_rtx (REG, Pmode, STACK_POINTER_REGNUM) to equal stack_pointer_rtx.\n      We depend on this.  */\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n@@ -839,7 +839,7 @@ reload (first, global, dumpfile)\n \t and constant, it is probably not addressable because the constant is\n \t out of range, in that case record the address; we will generate\n \t hairy code to compute the address in a register each time it is\n-\t needed. \n+\t needed.\n \n \t If the location is not addressable, but does not have one of the\n \t above forms, assign a stack slot.  We have to do this to avoid the\n@@ -868,7 +868,7 @@ reload (first, global, dumpfile)\n \t    else\n \t      {\n \t\t/* Make a new stack slot.  Then indicate that something\n-\t\t   changed so we go back and recompute offsets for \n+\t\t   changed so we go back and recompute offsets for\n \t\t   eliminable registers because the allocation of memory\n \t\t   below might change some offset.  reg_equiv_{mem,address}\n \t\t   will be set up for this pseudo on the next pass around\n@@ -879,7 +879,7 @@ reload (first, global, dumpfile)\n \t\tsomething_changed = 1;\n \t      }\n \t  }\n-\t\n+\n       /* If we allocated another psuedo to the stack, redo elimination\n \t bookkeeping.  */\n       if (something_changed)\n@@ -1024,7 +1024,7 @@ reload (first, global, dumpfile)\n \t\t}\n \n \t      /* If this insn has no reloads, we need not do anything except\n-\t\t in the case of a CALL_INSN when we have caller-saves and \n+\t\t in the case of a CALL_INSN when we have caller-saves and\n \t\t caller-save needs reloads.  */\n \n \t      if (n_reloads == 0\n@@ -1179,7 +1179,7 @@ reload (first, global, dumpfile)\n \t\t needed for this insn.   However, the spill register\n \t\t can be used by any reload of this insn, so we only\n \t\t need do something if no need for that class has\n-\t\t been recorded. \n+\t\t been recorded.\n \n \t\t The assumption that every CALL_INSN will trigger a\n \t\t caller-save is highly conservative, however, the number\n@@ -1279,7 +1279,7 @@ reload (first, global, dumpfile)\n \t     supports the sum of two registers for an address; see\n \t     find_address_reloads for details.  */\n \n-\t  caller_save_spill_class \n+\t  caller_save_spill_class\n \t    = double_reg_address_ok ? INDEX_REG_CLASS : BASE_REG_CLASS;\n \t  caller_save_group_size\n \t    = CLASS_MAX_NREGS (caller_save_spill_class, Pmode);\n@@ -1331,7 +1331,7 @@ reload (first, global, dumpfile)\n       count_possible_groups (group_size, group_mode, max_groups);\n \n       /* Now count all spill regs against the individual need,\n-\t This includes those counted above for groups, \n+\t This includes those counted above for groups,\n \t but not those previously counted for nongroups.\n \n \t Those that weren't counted_for_groups can also count against\n@@ -1373,7 +1373,7 @@ reload (first, global, dumpfile)\n \t no longer replace register C with register B and we need to disable\n \t such an elimination, if it exists.  This occurs often with A == ap,\n \t B == sp, and C == fp.  */\n-\t \n+\n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \t{\n \t  struct elim_table *op;\n@@ -1839,7 +1839,7 @@ count_possible_groups (group_size, group_mode, max_groups)\n \t\t  p = reg_class_superclasses[i];\n \t\t  while (*p != LIM_REG_CLASSES)\n \t\t    max_groups[(int) *p++]--;\n-\t\t  /* Don't count these registers again.  */ \n+\t\t  /* Don't count these registers again.  */\n \t\t  for (k = 0; k < group_size[i]; k++)\n \t\t    SET_HARD_REG_BIT (counted_for_groups, j + k);\n \t\t}\n@@ -2171,7 +2171,7 @@ set_label_offsets (x, insn, initial_p)\n \t/* If neither of the above cases is true, compare each offset\n \t   with those previously recorded and suppress any eliminations\n \t   where the offsets disagree.  */\n-\t  \n+\n \tfor (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n \t  if (offsets_at[CODE_LABEL_NUMBER (x)][i]\n \t      != (initial_p ? reg_eliminate[i].initial_offset\n@@ -2259,7 +2259,7 @@ set_label_offsets (x, insn, initial_p)\n \n static struct rtvec_def *old_asm_operands_vec, *new_asm_operands_vec;\n \n-/* Scan X and replace any eliminable registers (such as fp) with a \n+/* Scan X and replace any eliminable registers (such as fp) with a\n    replacement (such as sp), plus an offset.\n \n    MEM_MODE is the mode of an enclosing MEM.  We need this to know how\n@@ -2401,7 +2401,7 @@ eliminate_regs (x, mem_mode, insn)\n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  {\n \t    /* If one side is a PLUS and the other side is a pseudo that\n-\t       didn't get a hard register but has a reg_equiv_constant, \n+\t       didn't get a hard register but has a reg_equiv_constant,\n \t       we must replace the constant here since it may no longer\n \t       be in the position of any operand.  */\n \t    if (GET_CODE (new0) == PLUS && GET_CODE (new1) == REG\n@@ -2609,7 +2609,7 @@ eliminate_regs (x, mem_mode, insn)\n       if (GET_CODE (SET_DEST (x)) == REG)\n \t{\n \t  /* See if this is setting the replacement register for an\n-\t     elimination. \n+\t     elimination.\n \n \t     If DEST is the frame pointer, we do nothing because we assume that\n \t     all assignments to the frame pointer are for non-local gotos and\n@@ -2819,7 +2819,7 @@ eliminate_regs_in_insn (insn, replace)\n \tREG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, 0);\n       val = 1;\n     }\n-  \n+\n   /* Loop through all elimination pairs.  See if any have changed and\n      recalculate the number not at initial offset.\n \n@@ -2937,7 +2937,7 @@ spill_hard_reg (regno, global, dumpfile, cant_eliminate)\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_renumber[i] >= 0\n \t&& reg_renumber[i] <= regno\n-\t&& (reg_renumber[i] \n+\t&& (reg_renumber[i]\n \t    + HARD_REGNO_NREGS (reg_renumber[i],\n \t\t\t\tPSEUDO_REGNO_MODE (i))\n \t    > regno))\n@@ -2960,7 +2960,7 @@ spill_hard_reg (regno, global, dumpfile, cant_eliminate)\n \t\t *p != LIM_REG_CLASSES; p++)\n \t      if (basic_block_needs[(int) *p][reg_basic_block[i]] > 0)\n \t\tbreak;\n-\t  \n+\n \t    if (*p == LIM_REG_CLASSES)\n \t      continue;\n \t  }\n@@ -3278,7 +3278,7 @@ reload_as_needed (first, live_known)\n \t      int class;\n \n \t      /* If this block has not had spilling done for a\n-\t\t particular class, deactivate any optional reloads \n+\t\t particular class, deactivate any optional reloads\n \t\t of that class lest they try to use a spill-reg which isn't\n \t\t available here.  If we have any non-optionals that need a\n \t\t spill reg, abort.  */\n@@ -3448,7 +3448,7 @@ reload_reg_class_lower (p1, p2)\n {\n   register int r1 = *p1, r2 = *p2;\n   register int t;\n-  \n+\n   /* Consider required reloads before optional ones.  */\n   t = reload_optional[r1] - reload_optional[r2];\n   if (t != 0)\n@@ -3703,7 +3703,7 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \n   /* If we put this reload ahead, thinking it is a group,\n      then insist on finding a group.  Otherwise we can grab a\n-     reg that some other reload needs. \n+     reg that some other reload needs.\n      (That can happen when we have a 68000 DATA_OR_FP_REG\n      which is a group of data regs or one fp reg.)\n      We need not be so restrictive if there are no more reloads\n@@ -3948,7 +3948,7 @@ choose_reload_regs (insn, avoid_return_reg)\n #if 0  /* Not needed, now that we can always retry without inheritance.  */\n   /* See if we have more mandatory reloads than spill regs.\n      If so, then we cannot risk optimizations that could prevent\n-     reloads from sharing one spill register. \n+     reloads from sharing one spill register.\n \n      Since we will try finding a better register than reload_reg_rtx\n      unless it is equal to reload_in or reload_out, count such reloads.  */\n@@ -3957,7 +3957,7 @@ choose_reload_regs (insn, avoid_return_reg)\n     int tem = 0;\n #ifdef SMALL_REGISTER_CLASSES\n     int tem = (avoid_return_reg != 0);\n-#endif \n+#endif\n     for (j = 0; j < n_reloads; j++)\n       if (! reload_optional[j]\n \t  && (reload_in[j] != 0 || reload_out[j] != 0 || reload_secondary_p[j])\n@@ -3989,7 +3989,7 @@ choose_reload_regs (insn, avoid_return_reg)\n   /* In order to be certain of getting the registers we need,\n      we must sort the reloads into order of increasing register class.\n      Then our grabbing of reload registers will parallel the process\n-     that provided the reload registers. \n+     that provided the reload registers.\n \n      Also note whether any of the reloads wants a consecutive group of regs.\n      If so, record the maximum size of the group desired and what\n@@ -4544,7 +4544,7 @@ emit_reload_insns (insn)\n \n \t      /* If OLDEQUIV is a spill register, don't use it for this\n \t\t if any other reload needs it at an earlier stage of this insn\n-\t\t or at this stage.  */\t   \n+\t\t or at this stage.  */\n \t      if (spill_reg_order[regno] >= 0\n \t\t  && (! reload_reg_free_p (regno, reload_when_needed[j])\n \t\t      || ! reload_reg_free_before_p (regno,\n@@ -4719,10 +4719,10 @@ emit_reload_insns (insn)\n \t\t\t      new_icode = reload_in_optab[(int) mode];\n \t\t\t      if (new_icode != CODE_FOR_nothing\n \t\t\t\t  && ((insn_operand_predicate[(int) new_icode][0]\n-\t\t\t\t       && ! (insn_operand_predicate[(int) new_icode][0]\n+\t\t\t\t       && ! ((*insn_operand_predicate[(int) new_icode][0])\n \t\t\t\t\t     (reloadreg, mode)))\n-\t\t\t\t      || (insn_operand_predicate[(int) new_icode]\n-\t\t\t\t\t  && ! (insn_operand_predicate[(int) new_icode][1]\n+\t\t\t\t      || (insn_operand_predicate[(int) new_icode][1]\n+\t\t\t\t\t  && ! ((*insn_operand_predicate[(int) new_icode][1])\n \t\t\t\t\t\t(oldequiv, mode)))))\n \t\t\t\tnew_icode = CODE_FOR_nothing;\n \n@@ -4860,7 +4860,7 @@ emit_reload_insns (insn)\n \t{\n \t  register rtx reloadreg = reload_reg_rtx[j];\n \n-#if 0\t  \n+#if 0\n \t  /* We can't abort here because we need to support this for sched.c.\n \t     It's not terrible to miss a REG_DEAD note, but we should try\n \t     to figure out how to do this correctly.  */\n@@ -4900,7 +4900,7 @@ emit_reload_insns (insn)\n \t\t   && GET_CODE (reload_in[j]) == REG\n \t\t   && spill_reg_store[reload_spill_index[j]] == 0\n \t\t   && reload_inheritance_insn[j] != 0\n-\t\t   && find_regno_note (reload_inheritance_insn[j], REG_DEAD, \n+\t\t   && find_regno_note (reload_inheritance_insn[j], REG_DEAD,\n \t\t\t\t       REGNO (reload_reg_rtx[j])))\n \t    remove_death (REGNO (reload_reg_rtx[j]),\n \t\t\t  reload_inheritance_insn[j]);\n@@ -5258,7 +5258,7 @@ emit_reload_insns (insn)\n \n \t      /* If there are two separate reloads (one in and one out)\n \t\t for the same (hard or pseudo) reg,\n-\t\t leave reg_last_reload_reg set \n+\t\t leave reg_last_reload_reg set\n \t\t based on the output reload.\n \t\t Otherwise, set it from this input reload.  */\n \t      if (!reg_has_output_reload[nregno]\n@@ -5312,7 +5312,7 @@ gen_input_reload (reloadreg, in, before_insn)\n {\n   register rtx prev_insn = PREV_INSN (before_insn);\n \n-  /* How to do this reload can get quite tricky.  Normally, we are being \n+  /* How to do this reload can get quite tricky.  Normally, we are being\n      asked to reload a simple operand, such as a MEM, a constant, or a pseudo\n      register that didn't get a hard register.  In that case we can just\n      call emit_move_insn.\n@@ -5356,17 +5356,17 @@ gen_input_reload (reloadreg, in, before_insn)\n \t but we need to pass the insn as an operand to `recog' and it is\n \t simpler to emit and then delete the insn if not valid than to\n \t dummy things up.  */\n-      \n+\n       rtx move_operand, other_operand, insn;\n       int code;\n-      \n+\n       /* Since constraint checking is strict, commutativity won't be\n \t checked, so we need to do that here to avoid spurious failure\n \t if the add instruction is two-address and the second operand\n \t of the add is the same as the reload reg, which is frequently\n \t the case.  If the insn would be A = B + A, rearrange it so\n \t it will be A = A + B as constrain_operands expects. */\n-\t\n+\n       if (GET_CODE (XEXP (in, 1)) == REG\n \t  && REGNO (reloadreg) == REGNO (XEXP (in, 1)))\n \tin = gen_rtx (PLUS, GET_MODE (in), XEXP (in, 1), XEXP (in, 0));\n@@ -5526,7 +5526,7 @@ delete_output_reload (insn, j, output_reload_insn)\n }\n \n \f\n-/* Output reload-insns to reload VALUE into RELOADREG. \n+/* Output reload-insns to reload VALUE into RELOADREG.\n    VALUE is a autoincrement or autodecrement RTX whose operand\n    is a register or memory location;\n    so reloading involves incrementing that location."}]}