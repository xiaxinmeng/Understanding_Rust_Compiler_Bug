{"sha": "bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJiYmIxNmE4ODg5ODdhZWEwYjg1Y2UxMTMzY2YxZGFjNDU1N2VjYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-04-20T19:35:00Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-04-20T19:35:00Z"}, "message": "Fix enum conversions which are invalid in C++:\n\ngcc/:\n\tFix enum conversions which are invalid in C++:\n\t* auto-inc-dec.c (attempt_change): Change 0 to SET in function\n\tcall.\n\t* calls.c (store_one_arg): Change 0 to EXPAND_NORMAL in function\n\tcall.\n\t* cse.c (hash_rtx_cb): Change 0 to VOIDmode in function call.\n\t* dbgcnt.c (dbg_cnt_set_limit_by_name): Add cast to enum type.\n\t* dbxout.c (dbxout_symbol): Change 0 to VOIDmode in function\n\tcall.\n\t(dbxout_parms): Likewise.\n\t* df-core.c (df_set_flags): Change changeable_flags parameter to\n\tint.\n\t(df_clear_flags): Likewise.\n\t* df-problems.c (df_rd_bb_local_compute_process_def): Change\n\ttop_flag parameter to int.\n\t(df_chain_create_bb_process_use): Likewise.\n\t(df_chain_add_problem): Change chain_flags parameter to unsigned\n\tint.  Remove cast.\n\t* df-scan.c (df_ref_create): Change ref_flags parameter to int.\n\t(df_ref_create_structure, df_def_record_1): Likewise.\n\t(df_defs_record, df_uses_record, df_get_call_refs): Likewise.\n\t(df_notes_rescan): Change 0 to VOIDmode in function call.\n\t(df_get_call_refs, df_insn_refs_collect): Likewise.\n\t(df_bb_regs_collect): Likewise.\n\t(df_entry_block_defs_collect): Likewise.\n\t(df_exit_block_uses_collect): Likewise.\n\t* df.h: Update declarations.\n\t* double-int.c (double_int_divmod): Add cast to enum type.\n\t* dse.c (replace_inc_dec): Reverse parameters to gen_int_mode.\n\t* dwarf2out.c (new_reg_loc_descr): Add casts to enum type.\n\t(based_loc_descr): Likewise.\n\t(loc_descriptor_from_tree_1): Change first_op and second_op to\n\tenum dwarf_location_atom.  Add cast to enum type.\n\t* expmed.c (init_expmed): Change 0 to SET in function call.\n\t* expr.c (init_expr_target): Change 0 to VOIDmode in function\n\tcall.\n\t(expand_expr_real_1): Change 0 to EXPAND_NORMAL in function call.\n\t(do_store_flag): Likewise.\n\t* fixed-value.h (struct fixed_value): Change mode to enum\n\tmachine_mode.\n\t* function.c (assign_parms): Change 0 to VOIDmode in function\n\tcall.\n\t* genautomata.c (insert_automaton_decl): Change 1 to INSERT in\n\tfunction call.\n\t(insert_insn_decl, insert_decl, insert_state): Likewise.\n\t(automata_list_finish): Likewise.\n\t* genrecog.c (process_define_predicate): Add cast to enum type.\n\t* gensupport.c (init_predicate_table): Add cast to enum type.\n\t* gimple.c (gimple_build_return): Change 0 to ERROR_MARK in\n\tfunction call.\n\t(gimple_build_call_1, gimple_build_label): Likewise.\n\t(gimple_build_goto, gimple_build_asm_1): Likewise.\n\t(gimple_build_switch_1, gimple_build_cdt): Likewise.\n\t* gimple.h (GIMPLE_CHECK): Change 0 to ERROR_MARK in function\n\tcall.\n\t(enum fallback): Rename from enum fallback_t.\n\t(fallback_t): Typedef as int.\n\t* gimple-low.c (lower_builtin_setjmp): Change TSI_SAME_STMT to\n\tGSI_SAME_STMT in function call.\n\t* ira.c (setup_class_subset_and_memory_move_costs): Add casts to\n\tenum type.\n\t(setup_reg_class_relations): Likewise.\n\t(setup_reg_class_nregs): Change cl to int.  Add casts to enum\n\ttype.\n\t(setup_prohibited_class_mode_regs): Add cast to enum type.\n\t(setup_prohibited_mode_move_regs): Likewise.\n\t* ira-costs.c (record_reg_classes): Change rclass to enum\n\treg_class.\n\t(record_address_regs): Change i to enum reg_class.\n\t* lists.c (alloc_EXPR_LIST): Add cast to enum type.\n\t* machmode.h (GET_MODE_CLASS): Cast value to enum mode_class.\n\t(GET_MODE_WIDER_MODE): Cast value to enum machine_mode.\n\t(GET_MODE_2XWIDER_MODE): Likewise.\n\t(GET_CLASS_NARROWEST_MODE): Likewise.\n\t* omp-low.c (expand_omp_for): Add cast to enum type.\n\t* optabs.c (debug_optab_libfuncs): Add casts to enum type.\n\t* opts.c (enable_warning_as_error): Change kind to diagostic_t.\n\t* postreload.c (reload_cse_simplify_operands): Change rclass local\n\tto enum reg_class.\n\t* predict.c (combine_predictions_for_insn): Change best_predictor\n\tand predictor to enum br_predictor.\n\t(combine_predictions_for_bb): Likewise.\n\t(build_predict_expr): Change assignment to PREDICT_EXPR_OUTCOME to\n\tuse SET_PREDICT_EXPR_OUTCOME.\n\t* real.c (real_arithmetic): Change icode to code in function\n\tcall.\n\t* reginfo.c (init_move_cost): Add casts to enum type.\n\t(init_reg_sets_1, init_fake_stack_mems): Likewise.\n\t* regmove.c (regclass_compatible_p): Change class0 and class1 to\n\tenum reg_class.\n\t* reload.c (find_valid_class): Add casts to enum type.\n\t(push_reload): Change 0 to NO_REGS in function call.\n\t(find_reloads): Change this_alternative to array of enum\n\treg_class.  Remove some now-unnecessary casts.\n\t(make_memloc): Change 0 to VOIDmode in function call.\n\t* reload1.c (reload): Change 0 to VOIDmode in function call.\n\t(eliminate_regs_1, elimination_effects): Likewise.\n\t(eliminate_regs_in_insn): Likewise.\n\t(emit_input_reload_insns): Add cast to enum type.\n\t(delete_output_reload): Change 0 to VOIDmode in function call.\n\t* reorg.c (insn_sets_resource_p): Convert include_delayed_effects\n\tto enum type in function call.\n\t* tree.h (PREDICT_EXPR_OUTCOME): Add cast to enum type.\n\t(SET_PREDICT_EXPR_OUTCOME): Define.\n\t* tree-dump.c (get_dump_file_info): Change phase parameter to\n\tint.\n\t(get_dump_file_name, dump_begin, dump_enabled_p): Likewise.\n\t(dump_initialized_p, dump_flag_name, dump_end): Likewise.\n\t(dump_function): Likewise.\n\t* tree-dump.h: Update declarations.\n\t* tree-pass.h: Update declarations.\n\t* varasm.c (assemble_integer): Change mclass to enum mode_class.\n\t* config/arm/arm.c (thumb_legitimize_reload_address): Add cast to\n\tenum type.\n\t(arm_rtx_costs_1): Correct parenthesization.\n\t(arm_rtx_costs): Add casts to enum type.\n\t(adjacent_mem_locations): Reverse arguments to const_ok_for_op.\n\t(vfp_emit_fstmd): Use add_rg_note.\n\t(emit_multi_reg_push, emit_sfm): Likewise.\n\t(thumb_set_frame_pointer): Likewise.\n\t(arm_expand_prologue): Likewise.\n\t(arm_regno_class): Change return type to enum reg_class.\n\t(thumb1_expand_prologue): Use add_reg_note.\n\t* config/arm/arm-protos.h (arm_regno_class): Update declaration.\n\t* config/arm/arm.h (INITIALIZE_TRAMPOLINE): Change 0 to LCT_NORMAL\n\tin function call.\n\t* config/arm/gentune.sh: Add cast to enum type.\n\t* config/arm/arm-tune.md: Rebuild.\n\t* config/i386/i386.c (ix86_expand_prologue): Use add_reg_note.\n\t(ix86_split_fp_branch, predict_jump): Likewise.\n\t(ix86_expand_multi_arg_builtin): Change sub_code from enum\n\tinsn_code to enum rtx_code.\n\t(ix86_builtin_vectorized_function): Add cast to enum type.\n\t* config/i386/i386.md (truncdfsf2): Change slot to enum\n\tix86_stack_slot.\n\t(truncxf<mode>2, isinf<mode>2): Likewise.\n\t* config/i386/i386-c.c (ix86_pragma_target_parse): Add cast to\n\tenum type.\n\t* config/ia64/ia64.c (ia64_split_tmode_move): Use add_reg_note.\n\t(spill_restore_mem, do_spill, ia64_expand_prologue): Likewise.\n\t(insert_bundle_state): Change 1 to INSERT in function call.\n\t(ia64_add_bundle_selector_before): Likewise.\n\t* config/ia64/ia64.md (cpu attr): Add cast to enum type.\n\t(save_stack_nonlocal): Change 0 to LCT_NORMAL in function call.\n\t(restore_stack_nonlocal): Likewise.\n\t* config/mips/mips.h (MIPS_ICACHE_SYNC): Change 0 to LCT_NORMAL in\n\tfunction call.\n\t* config/mips/mips.c (mips_binary_cost): Change 0 to SET in\n\tfunction call.\n\t(mips_rtx_costs): Likewise.\n\t(mips_override_options): Add casts to enum type.\n\t* config/mips/sdemtk.h (MIPS_ICACHE_SYNC): Change 0 to LCT_NORMAL\n\tin function call.\n\t* config/pa/pa.c (legitimize_pic_address): Use add_reg_note.\n\t(store_reg, set_reg_plus_d): Likewise.\n\t(hppa_expand_prologue, hppa_profile_hook): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Add\n\tcast to enum type.\n\t(altivec_expand_vec_set_builtin): Change 0 to EXPAND_NORMAL in\n\tfunction call.\n\t(emit_unlikely_jump): Use add_reg_note.\n\t(rs6000_emit_allocate_stack): Likewise.\n\t(rs6000_frame_related, rs6000_emit_prologue): Likewise.\n\t(output_toc): Change 1 to INSERT in function call.\n\t(output_profile_hook): Change 0 to LCT_NORMAL in function call.\n\t(rs6000_initialize_trampoline): Likewise.\n\t(rs6000_init_dwarf_reg_sizes_extra): Change 0 to EXPAND_NORMAL in\n\tfunction call.\n\t* config/s390/s390.c (s390_rtx_costs): Add cast to enum type.\n\t(s390_expand_movmem): Change 0 to OPTAB_DIRECT in function call.\n\t(s390_expand_setmem, s390_expand_cmpmem): Likewise.\n\t(save_gprs): Use add_reg_note.\n\t(s390_emit_prologue): Likewise.\n\t(s390_expand_builtin): Change 0 to EXPAND_NORMAL in function\n\tcall.\n\t* config/sparc/sparc.c (sparc_expand_prologue): Use add_reg_note.\n\t(sparc_fold_builtin): Add cast to enum type.\n\t* config/spu/spu.c (spu_emit_branch_or_set): Change ior_code to\n\tenum insn_code.\n\t(spu_expand_prologue): Use add_reg_note.\n\t(expand_builtin_args): Change 0 to EXPAND_NORMAL in function\n\tcall.\n\n\t* c-parser.c (c_parser_attributes): Change VEC back to tree list.\n\t(c_parser_postfix_expression_after_primary): Get VEC for list of\n\targuments.  Get original types of arguments.  Call\n\tbuild_function_call_vec.\n\t(cached_expr_list_1, cached_expr_list_2): New static variables.\n\t(c_parser_expr_list): Change return type to VEC *.  Add\n\tp_orig_types parameter.  Change all callers.\n\t(c_parser_release_expr): New static function.\n\t(c_parser_vec_to_tree_list): New static function.\n\t* c-typeck.c (build_function_call): Rewrite to build a VEC and\n\tcall build_function_call_vec.\n\t(build_function_call_vec): New function, based on old\n\tbuild_function_call.\n\t(convert_arguments): Remove nargs and argarray parameters.  Change\n\tvalues to a VEC.  Add origtypes parameter.\n\t(build_modify_expr): Add rhs_origtype parameter.  Change all\n\tcallers.\n\t(convert_for_assignment): Add origtype parameter.  Change all\n\tcallers.  If warn_cxx_compat, check for conversion to an enum\n\ttype when calling a function.\n\t(store_init_value): Add origtype parameter.  Change all callers.\n\t(digest_init): Likewise.\n\t(struct init_node): Add origtype field.\n\t(add_pending_init): Add origtype parameter.  Change all callers.\n\t(output_init_element): Likewise.\n\t(output_pending_init_elements): Pass origtype from init_node to\n\toutput_init_element.\n\t(process_init_elemnt): Pass origtype from c_expr to\n\toutput_init_element.\n\t(c_finish_return): Add origtype parameter.  Change all callers.\n\t* c-common.c (sync_resolve_size): Change params to VEC *.  Change\n\tcaller.\n\t(sync_resolve_params): Likewise.\n\t(sync_resolve_return): Change params to first_param.  Change\n\tcaller.\n\t(resolve_overloaded_builtins): Change params to VEC *.  Change\n\tcallers.   Save first parameter around call to\n\tbuild_function_call_vec.\n\t* c-decl.c (finish_decl): Add origtype parameter.  Change all\n\tcallers.  Call build_function_call_vec rather than\n\tbuild_function_call for cleanup.\n\t* c-tree.h: Update declarations.\n\t* c-common.h: Update declarations.\n\t* stub-objc.c (objc_rewrite_function_call): Change parameter from\n\tparams to first_param.\n\t* target.h (struct gcc_target): Change resolve_overloaded_builtin\n\tparams parameter from tree to void *.\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n\tChange arglist parameter to have type void *, and to be a pointer\n\tto a VEC.\n\t* config/rs6000/rs6000-protos.h\n\t(altivec_resolve_overloaded_builtin): Update declaration.\n\t* config/spu/spu-c.c (spu_resolved_overloaded_builtin): Change\n\tfnargs parameter to have type void *, and to be a pointer to a\n\tVEC.  Call build_function_call_vec instead of\n\tbuild_function_call.\n\t* config/spu/spu-protos.h (spu_expand_builtin): Update\n\tdeclaration.\n\ngcc/cp/:\n\t* typeck.c (build_function_call_vec): New function.\n\t(cp_build_function_call): Only pass first parameter to\n\tobjc_rewrite_function_call.\n\t(build_modify_expr): Add rhs_origtype parameter.  Change all\n\tcallers.\n\t* decl.c (finish_decl): Add origtype parameter.  Change all\n\tcallers.\n\t* semantics.c (finish_call_expr): Pass VEC to\n\tresolve_overloaded_builtin.\n\ngcc/objc:\n\t* objc-act.c (objc_rewrite_function_call): Change parameter from\n\tparams to first_param.  Change all callers.\n\ngcc/testsuite:\n\t* gcc.dg/Wcxx-compat-3.c: New testcase.\n\nFrom-SVN: r146451", "tree": {"sha": "d88108cb1bacca1da6cfae95a807a42f3c5f612b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d88108cb1bacca1da6cfae95a807a42f3c5f612b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/comments", "author": null, "committer": null, "parents": [{"sha": "c2efda0dee082ae3f57bdb2c7b1ae2dbf07ddfcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2efda0dee082ae3f57bdb2c7b1ae2dbf07ddfcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2efda0dee082ae3f57bdb2c7b1ae2dbf07ddfcd"}], "stats": {"total": 1832, "additions": 1173, "deletions": 659}, "files": [{"sha": "16a34f4d6bc6bd30031cd7545b78cb17f50aaba1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,3 +1,249 @@\n+2009-04-20  Ian Lance Taylor  <iant@google.com>\n+\n+\tFix enum conversions which are invalid in C++:\n+\t* auto-inc-dec.c (attempt_change): Change 0 to SET in function\n+\tcall.\n+\t* calls.c (store_one_arg): Change 0 to EXPAND_NORMAL in function\n+\tcall.\n+\t* cse.c (hash_rtx_cb): Change 0 to VOIDmode in function call.\n+\t* dbgcnt.c (dbg_cnt_set_limit_by_name): Add cast to enum type.\n+\t* dbxout.c (dbxout_symbol): Change 0 to VOIDmode in function\n+\tcall.\n+\t(dbxout_parms): Likewise.\n+\t* df-core.c (df_set_flags): Change changeable_flags parameter to\n+\tint.\n+\t(df_clear_flags): Likewise.\n+\t* df-problems.c (df_rd_bb_local_compute_process_def): Change\n+\ttop_flag parameter to int.\n+\t(df_chain_create_bb_process_use): Likewise.\n+\t(df_chain_add_problem): Change chain_flags parameter to unsigned\n+\tint.  Remove cast.\n+\t* df-scan.c (df_ref_create): Change ref_flags parameter to int.\n+\t(df_ref_create_structure, df_def_record_1): Likewise.\n+\t(df_defs_record, df_uses_record, df_get_call_refs): Likewise.\n+\t(df_notes_rescan): Change 0 to VOIDmode in function call.\n+\t(df_get_call_refs, df_insn_refs_collect): Likewise.\n+\t(df_bb_regs_collect): Likewise.\n+\t(df_entry_block_defs_collect): Likewise.\n+\t(df_exit_block_uses_collect): Likewise.\n+\t* df.h: Update declarations.\n+\t* double-int.c (double_int_divmod): Add cast to enum type.\n+\t* dse.c (replace_inc_dec): Reverse parameters to gen_int_mode.\n+\t* dwarf2out.c (new_reg_loc_descr): Add casts to enum type.\n+\t(based_loc_descr): Likewise.\n+\t(loc_descriptor_from_tree_1): Change first_op and second_op to\n+\tenum dwarf_location_atom.  Add cast to enum type.\n+\t* expmed.c (init_expmed): Change 0 to SET in function call.\n+\t* expr.c (init_expr_target): Change 0 to VOIDmode in function\n+\tcall.\n+\t(expand_expr_real_1): Change 0 to EXPAND_NORMAL in function call.\n+\t(do_store_flag): Likewise.\n+\t* fixed-value.h (struct fixed_value): Change mode to enum\n+\tmachine_mode.\n+\t* function.c (assign_parms): Change 0 to VOIDmode in function\n+\tcall.\n+\t* genautomata.c (insert_automaton_decl): Change 1 to INSERT in\n+\tfunction call.\n+\t(insert_insn_decl, insert_decl, insert_state): Likewise.\n+\t(automata_list_finish): Likewise.\n+\t* genrecog.c (process_define_predicate): Add cast to enum type.\n+\t* gensupport.c (init_predicate_table): Add cast to enum type.\n+\t* gimple.c (gimple_build_return): Change 0 to ERROR_MARK in\n+\tfunction call.\n+\t(gimple_build_call_1, gimple_build_label): Likewise.\n+\t(gimple_build_goto, gimple_build_asm_1): Likewise.\n+\t(gimple_build_switch_1, gimple_build_cdt): Likewise.\n+\t* gimple.h (GIMPLE_CHECK): Change 0 to ERROR_MARK in function\n+\tcall.\n+\t(enum fallback): Rename from enum fallback_t.\n+\t(fallback_t): Typedef as int.\n+\t* gimple-low.c (lower_builtin_setjmp): Change TSI_SAME_STMT to\n+\tGSI_SAME_STMT in function call.\n+\t* ira.c (setup_class_subset_and_memory_move_costs): Add casts to\n+\tenum type.\n+\t(setup_reg_class_relations): Likewise.\n+\t(setup_reg_class_nregs): Change cl to int.  Add casts to enum\n+\ttype.\n+\t(setup_prohibited_class_mode_regs): Add cast to enum type.\n+\t(setup_prohibited_mode_move_regs): Likewise.\n+\t* ira-costs.c (record_reg_classes): Change rclass to enum\n+\treg_class.\n+\t(record_address_regs): Change i to enum reg_class.\n+\t* lists.c (alloc_EXPR_LIST): Add cast to enum type.\n+\t* machmode.h (GET_MODE_CLASS): Cast value to enum mode_class.\n+\t(GET_MODE_WIDER_MODE): Cast value to enum machine_mode.\n+\t(GET_MODE_2XWIDER_MODE): Likewise.\n+\t(GET_CLASS_NARROWEST_MODE): Likewise.\n+\t* omp-low.c (expand_omp_for): Add cast to enum type.\n+\t* optabs.c (debug_optab_libfuncs): Add casts to enum type.\n+\t* opts.c (enable_warning_as_error): Change kind to diagostic_t.\n+\t* postreload.c (reload_cse_simplify_operands): Change rclass local\n+\tto enum reg_class.\n+\t* predict.c (combine_predictions_for_insn): Change best_predictor\n+\tand predictor to enum br_predictor.\n+\t(combine_predictions_for_bb): Likewise.\n+\t(build_predict_expr): Change assignment to PREDICT_EXPR_OUTCOME to\n+\tuse SET_PREDICT_EXPR_OUTCOME.\n+\t* real.c (real_arithmetic): Change icode to code in function\n+\tcall.\n+\t* reginfo.c (init_move_cost): Add casts to enum type.\n+\t(init_reg_sets_1, init_fake_stack_mems): Likewise.\n+\t* regmove.c (regclass_compatible_p): Change class0 and class1 to\n+\tenum reg_class.\n+\t* reload.c (find_valid_class): Add casts to enum type.\n+\t(push_reload): Change 0 to NO_REGS in function call.\n+\t(find_reloads): Change this_alternative to array of enum\n+\treg_class.  Remove some now-unnecessary casts.\n+\t(make_memloc): Change 0 to VOIDmode in function call.\n+\t* reload1.c (reload): Change 0 to VOIDmode in function call.\n+\t(eliminate_regs_1, elimination_effects): Likewise.\n+\t(eliminate_regs_in_insn): Likewise.\n+\t(emit_input_reload_insns): Add cast to enum type.\n+\t(delete_output_reload): Change 0 to VOIDmode in function call.\n+\t* reorg.c (insn_sets_resource_p): Convert include_delayed_effects\n+\tto enum type in function call.\n+\t* tree.h (PREDICT_EXPR_OUTCOME): Add cast to enum type.\n+\t(SET_PREDICT_EXPR_OUTCOME): Define.\n+\t* tree-dump.c (get_dump_file_info): Change phase parameter to\n+\tint.\n+\t(get_dump_file_name, dump_begin, dump_enabled_p): Likewise.\n+\t(dump_initialized_p, dump_flag_name, dump_end): Likewise.\n+\t(dump_function): Likewise.\n+\t* tree-dump.h: Update declarations.\n+\t* tree-pass.h: Update declarations.\n+\t* varasm.c (assemble_integer): Change mclass to enum mode_class.\n+\t* config/arm/arm.c (thumb_legitimize_reload_address): Add cast to\n+\tenum type.\n+\t(arm_rtx_costs_1): Correct parenthesization.\n+\t(arm_rtx_costs): Add casts to enum type.\n+\t(adjacent_mem_locations): Reverse arguments to const_ok_for_op.\n+\t(vfp_emit_fstmd): Use add_rg_note.\n+\t(emit_multi_reg_push, emit_sfm): Likewise.\n+\t(thumb_set_frame_pointer): Likewise.\n+\t(arm_expand_prologue): Likewise.\n+\t(arm_regno_class): Change return type to enum reg_class.\n+\t(thumb1_expand_prologue): Use add_reg_note.\n+\t* config/arm/arm-protos.h (arm_regno_class): Update declaration.\n+\t* config/arm/arm.h (INITIALIZE_TRAMPOLINE): Change 0 to LCT_NORMAL\n+\tin function call.\n+\t* config/arm/gentune.sh: Add cast to enum type.\n+\t* config/arm/arm-tune.md: Rebuild.\n+\t* config/i386/i386.c (ix86_expand_prologue): Use add_reg_note.\n+\t(ix86_split_fp_branch, predict_jump): Likewise.\n+\t(ix86_expand_multi_arg_builtin): Change sub_code from enum\n+\tinsn_code to enum rtx_code.\n+\t(ix86_builtin_vectorized_function): Add cast to enum type.\n+\t* config/i386/i386.md (truncdfsf2): Change slot to enum\n+\tix86_stack_slot.\n+\t(truncxf<mode>2, isinf<mode>2): Likewise.\n+\t* config/i386/i386-c.c (ix86_pragma_target_parse): Add cast to\n+\tenum type.\n+\t* config/ia64/ia64.c (ia64_split_tmode_move): Use add_reg_note.\n+\t(spill_restore_mem, do_spill, ia64_expand_prologue): Likewise.\n+\t(insert_bundle_state): Change 1 to INSERT in function call.\n+\t(ia64_add_bundle_selector_before): Likewise.\n+\t* config/ia64/ia64.md (cpu attr): Add cast to enum type.\n+\t(save_stack_nonlocal): Change 0 to LCT_NORMAL in function call.\n+\t(restore_stack_nonlocal): Likewise.\n+\t* config/mips/mips.h (MIPS_ICACHE_SYNC): Change 0 to LCT_NORMAL in\n+\tfunction call.\n+\t* config/mips/mips.c (mips_binary_cost): Change 0 to SET in\n+\tfunction call.\n+\t(mips_rtx_costs): Likewise.\n+\t(mips_override_options): Add casts to enum type.\n+\t* config/mips/sdemtk.h (MIPS_ICACHE_SYNC): Change 0 to LCT_NORMAL\n+\tin function call.\n+\t* config/pa/pa.c (legitimize_pic_address): Use add_reg_note.\n+\t(store_reg, set_reg_plus_d): Likewise.\n+\t(hppa_expand_prologue, hppa_profile_hook): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Add\n+\tcast to enum type.\n+\t(altivec_expand_vec_set_builtin): Change 0 to EXPAND_NORMAL in\n+\tfunction call.\n+\t(emit_unlikely_jump): Use add_reg_note.\n+\t(rs6000_emit_allocate_stack): Likewise.\n+\t(rs6000_frame_related, rs6000_emit_prologue): Likewise.\n+\t(output_toc): Change 1 to INSERT in function call.\n+\t(output_profile_hook): Change 0 to LCT_NORMAL in function call.\n+\t(rs6000_initialize_trampoline): Likewise.\n+\t(rs6000_init_dwarf_reg_sizes_extra): Change 0 to EXPAND_NORMAL in\n+\tfunction call.\n+\t* config/s390/s390.c (s390_rtx_costs): Add cast to enum type.\n+\t(s390_expand_movmem): Change 0 to OPTAB_DIRECT in function call.\n+\t(s390_expand_setmem, s390_expand_cmpmem): Likewise.\n+\t(save_gprs): Use add_reg_note.\n+\t(s390_emit_prologue): Likewise.\n+\t(s390_expand_builtin): Change 0 to EXPAND_NORMAL in function\n+\tcall.\n+\t* config/sparc/sparc.c (sparc_expand_prologue): Use add_reg_note.\n+\t(sparc_fold_builtin): Add cast to enum type.\n+\t* config/spu/spu.c (spu_emit_branch_or_set): Change ior_code to\n+\tenum insn_code.\n+\t(spu_expand_prologue): Use add_reg_note.\n+\t(expand_builtin_args): Change 0 to EXPAND_NORMAL in function\n+\tcall.\n+\n+2009-04-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* c-parser.c (c_parser_attributes): Change VEC back to tree list.\n+\t(c_parser_postfix_expression_after_primary): Get VEC for list of\n+\targuments.  Get original types of arguments.  Call\n+\tbuild_function_call_vec.\n+\t(cached_expr_list_1, cached_expr_list_2): New static variables.\n+\t(c_parser_expr_list): Change return type to VEC *.  Add\n+\tp_orig_types parameter.  Change all callers.\n+\t(c_parser_release_expr): New static function.\n+\t(c_parser_vec_to_tree_list): New static function.\n+\t* c-typeck.c (build_function_call): Rewrite to build a VEC and\n+\tcall build_function_call_vec.\n+\t(build_function_call_vec): New function, based on old\n+\tbuild_function_call.\n+\t(convert_arguments): Remove nargs and argarray parameters.  Change\n+\tvalues to a VEC.  Add origtypes parameter.\n+\t(build_modify_expr): Add rhs_origtype parameter.  Change all\n+\tcallers.\n+\t(convert_for_assignment): Add origtype parameter.  Change all\n+\tcallers.  If warn_cxx_compat, check for conversion to an enum\n+\ttype when calling a function.\n+\t(store_init_value): Add origtype parameter.  Change all callers.\n+\t(digest_init): Likewise.\n+\t(struct init_node): Add origtype field.\n+\t(add_pending_init): Add origtype parameter.  Change all callers.\n+\t(output_init_element): Likewise.\n+\t(output_pending_init_elements): Pass origtype from init_node to\n+\toutput_init_element.\n+\t(process_init_elemnt): Pass origtype from c_expr to\n+\toutput_init_element.\n+\t(c_finish_return): Add origtype parameter.  Change all callers.\n+\t* c-common.c (sync_resolve_size): Change params to VEC *.  Change\n+\tcaller.\n+\t(sync_resolve_params): Likewise.\n+\t(sync_resolve_return): Change params to first_param.  Change\n+\tcaller.\n+\t(resolve_overloaded_builtins): Change params to VEC *.  Change\n+\tcallers.   Save first parameter around call to\n+\tbuild_function_call_vec.\n+\t* c-decl.c (finish_decl): Add origtype parameter.  Change all\n+\tcallers.  Call build_function_call_vec rather than\n+\tbuild_function_call for cleanup.\n+\t* c-tree.h: Update declarations.\n+\t* c-common.h: Update declarations.\n+\t* stub-objc.c (objc_rewrite_function_call): Change parameter from\n+\tparams to first_param.\n+\t* target.h (struct gcc_target): Change resolve_overloaded_builtin\n+\tparams parameter from tree to void *.\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tChange arglist parameter to have type void *, and to be a pointer\n+\tto a VEC.\n+\t* config/rs6000/rs6000-protos.h\n+\t(altivec_resolve_overloaded_builtin): Update declaration.\n+\t* config/spu/spu-c.c (spu_resolved_overloaded_builtin): Change\n+\tfnargs parameter to have type void *, and to be a pointer to a\n+\tVEC.  Call build_function_call_vec instead of\n+\tbuild_function_call.\n+\t* config/spu/spu-protos.h (spu_expand_builtin): Update\n+\tdeclaration.\n+\n 2009-04-20  Joey Ye  <joey.ye@intel.com>\n \t    Xuepeng Guo <xuepeng.guo@intel.com>\n \t    H.J. Lu  <hongjiu.lu@intel.com>"}, {"sha": "c871baa8aad1c8272dd8a46074c46fa0425fa7b3", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -520,10 +520,10 @@ attempt_change (rtx new_addr, rtx inc_reg)\n   PUT_MODE (mem_tmp, mode);\n   XEXP (mem_tmp, 0) = new_addr;\n \n-  old_cost = rtx_cost (mem, 0, speed) \n-    + rtx_cost (PATTERN (inc_insn.insn), 0, speed);\n-  new_cost = rtx_cost (mem_tmp, 0, speed);\n-  \n+  old_cost = (rtx_cost (mem, SET, speed)\n+\t      + rtx_cost (PATTERN (inc_insn.insn), SET, speed));\n+  new_cost = rtx_cost (mem_tmp, SET, speed);\n+\n   /* The first item of business is to see if this is profitable.  */\n   if (old_cost < new_cost)\n     {\n@@ -1559,4 +1559,3 @@ struct rtl_opt_pass pass_inc_dec =\n   TODO_df_finish,                       /* todo_flags_finish */\n  }\n };\n-"}, {"sha": "7e62258e4682f33c790355bed4e16a1ed6f21921", "filename": "gcc/c-common.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -8649,18 +8649,18 @@ builtin_type_for_size (int size, bool unsignedp)\n    Returns 0 if an error is encountered.  */\n \n static int\n-sync_resolve_size (tree function, tree params)\n+sync_resolve_size (tree function, VEC(tree,gc) *params)\n {\n   tree type;\n   int size;\n \n-  if (params == NULL)\n+  if (VEC_empty (tree, params))\n     {\n       error (\"too few arguments to function %qE\", function);\n       return 0;\n     }\n \n-  type = TREE_TYPE (TREE_VALUE (params));\n+  type = TREE_TYPE (VEC_index (tree, params, 0));\n   if (TREE_CODE (type) != POINTER_TYPE)\n     goto incompatible;\n \n@@ -8683,27 +8683,29 @@ sync_resolve_size (tree function, tree params)\n    was encountered; true on success.  */\n \n static bool\n-sync_resolve_params (tree orig_function, tree function, tree params)\n+sync_resolve_params (tree orig_function, tree function, VEC(tree, gc) *params)\n {\n   tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n   tree ptype;\n   int number;\n+  unsigned int parmnum;\n \n   /* We've declared the implementation functions to use \"volatile void *\"\n      as the pointer parameter, so we shouldn't get any complaints from the\n      call to check_function_arguments what ever type the user used.  */\n   arg_types = TREE_CHAIN (arg_types);\n-  ptype = TREE_TYPE (TREE_TYPE (TREE_VALUE (params)));\n+  ptype = TREE_TYPE (TREE_TYPE (VEC_index (tree, params, 0)));\n   number = 2;\n \n   /* For the rest of the values, we need to cast these to FTYPE, so that we\n      don't get warnings for passing pointer types, etc.  */\n+  parmnum = 0;\n   while (arg_types != void_list_node)\n     {\n       tree val;\n \n-      params = TREE_CHAIN (params);\n-      if (params == NULL)\n+      ++parmnum;\n+      if (VEC_length (tree, params) <= parmnum)\n \t{\n \t  error (\"too few arguments to function %qE\", orig_function);\n \t  return false;\n@@ -8712,10 +8714,10 @@ sync_resolve_params (tree orig_function, tree function, tree params)\n       /* ??? Ideally for the first conversion we'd use convert_for_assignment\n \t so that we get warnings for anything that doesn't match the pointer\n \t type.  This isn't portable across the C and C++ front ends atm.  */\n-      val = TREE_VALUE (params);\n+      val = VEC_index (tree, params, parmnum);\n       val = convert (ptype, val);\n       val = convert (TREE_VALUE (arg_types), val);\n-      TREE_VALUE (params) = val;\n+      VEC_replace (tree, params, parmnum, val);\n \n       arg_types = TREE_CHAIN (arg_types);\n       number++;\n@@ -8725,7 +8727,7 @@ sync_resolve_params (tree orig_function, tree function, tree params)\n      being \"an optional list of variables protected by the memory barrier\".\n      No clue what that's supposed to mean, precisely, but we consider all\n      call-clobbered variables to be protected so we're safe.  */\n-  TREE_CHAIN (params) = NULL;\n+  VEC_truncate (tree, params, parmnum + 1);\n \n   return true;\n }\n@@ -8735,9 +8737,9 @@ sync_resolve_params (tree orig_function, tree function, tree params)\n    PARAMS.  */\n \n static tree\n-sync_resolve_return (tree params, tree result)\n+sync_resolve_return (tree first_param, tree result)\n {\n-  tree ptype = TREE_TYPE (TREE_TYPE (TREE_VALUE (params)));\n+  tree ptype = TREE_TYPE (TREE_TYPE (first_param));\n   ptype = TYPE_MAIN_VARIANT (ptype);\n   return convert (ptype, result);\n }\n@@ -8752,7 +8754,7 @@ sync_resolve_return (tree params, tree result)\n    continue.  */\n \n tree\n-resolve_overloaded_builtin (tree function, tree params)\n+resolve_overloaded_builtin (tree function, VEC(tree,gc) *params)\n {\n   enum built_in_function orig_code = DECL_FUNCTION_CODE (function);\n   switch (DECL_BUILT_IN_CLASS (function))\n@@ -8789,7 +8791,7 @@ resolve_overloaded_builtin (tree function, tree params)\n     case BUILT_IN_LOCK_RELEASE_N:\n       {\n \tint n = sync_resolve_size (function, params);\n-\ttree new_function, result;\n+\ttree new_function, first_param, result;\n \n \tif (n == 0)\n \t  return error_mark_node;\n@@ -8798,10 +8800,11 @@ resolve_overloaded_builtin (tree function, tree params)\n \tif (!sync_resolve_params (function, new_function, params))\n \t  return error_mark_node;\n \n-\tresult = build_function_call (new_function, params);\n+\tfirst_param = VEC_index (tree, params, 0);\n+\tresult = build_function_call_vec (new_function, params, NULL);\n \tif (orig_code != BUILT_IN_BOOL_COMPARE_AND_SWAP_N\n \t    && orig_code != BUILT_IN_LOCK_RELEASE_N)\n-\t  result = sync_resolve_return (params, result);\n+\t  result = sync_resolve_return (first_param, result);\n \n \treturn result;\n       }"}, {"sha": "dcadbdd45ad8c3550a3eae6961b91504cbd4c8a0", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -415,7 +415,7 @@ extern tree add_stmt (tree);\n extern void push_cleanup (tree, tree, bool);\n extern tree pushdecl_top_level (tree);\n extern tree pushdecl (tree);\n-extern tree build_modify_expr (location_t, tree, enum tree_code, tree);\n+extern tree build_modify_expr (location_t, tree, enum tree_code, tree, tree);\n extern tree build_indirect_ref (location_t, tree, const char *);\n \n extern int c_expand_decl (tree);\n@@ -922,7 +922,9 @@ extern void c_do_switch_warnings (splay_tree, location_t, tree, tree);\n \n extern tree build_function_call (tree, tree);\n \n-extern tree resolve_overloaded_builtin (tree, tree);\n+extern tree build_function_call_vec (tree, VEC(tree,gc) *, VEC(tree,gc) *);\n+\n+extern tree resolve_overloaded_builtin (tree, VEC(tree,gc) *);\n \n extern tree finish_label_address_expr (tree, location_t);\n "}, {"sha": "6dc2a6ac41ea3778fd62b5429fe39374d0507cae", "filename": "gcc/c-decl.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -2791,7 +2791,7 @@ c_make_fname_decl (tree id, int type_dep)\n \t    /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n     }\n \n-  finish_decl (decl, init, NULL_TREE);\n+  finish_decl (decl, init, NULL_TREE, NULL_TREE);\n \n   return decl;\n }\n@@ -3364,11 +3364,12 @@ c_maybe_initialize_eh (void)\n \n /* Finish processing of a declaration;\n    install its initial value.\n+   If ORIGTYPE is not NULL_TREE, it is the original type of INIT.\n    If the length of an array type is not known before,\n    it must be determined now, from the initial value, or it is an error.  */\n \n void\n-finish_decl (tree decl, tree init, tree asmspec_tree)\n+finish_decl (tree decl, tree init, tree origtype, tree asmspec_tree)\n {\n   tree type;\n   int was_incomplete = (DECL_SIZE (decl) == 0);\n@@ -3390,7 +3391,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n     init = 0;\n \n   if (init)\n-    store_init_value (decl, init);\n+    store_init_value (decl, init, origtype);\n \n   if (c_dialect_objc () && (TREE_CODE (decl) == VAR_DECL\n \t\t\t    || TREE_CODE (decl) == FUNCTION_DECL\n@@ -3643,11 +3644,14 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  tree cleanup_id = TREE_VALUE (TREE_VALUE (attr));\n \t  tree cleanup_decl = lookup_name (cleanup_id);\n \t  tree cleanup;\n+\t  VEC(tree,gc) *vec;\n \n \t  /* Build \"cleanup(&decl)\" for the destructor.  */\n \t  cleanup = build_unary_op (input_location, ADDR_EXPR, decl, 0);\n-\t  cleanup = build_tree_list (NULL_TREE, cleanup);\n-\t  cleanup = build_function_call (cleanup_decl, cleanup);\n+\t  vec = VEC_alloc (tree, gc, 1);\n+\t  VEC_quick_push (tree, vec, cleanup);\n+\t  cleanup = build_function_call_vec (cleanup_decl, vec, NULL);\n+\t  VEC_free (tree, gc, vec);\n \n \t  /* Don't warn about decl unused; the cleanup uses it.  */\n \t  TREE_USED (decl) = 1;\n@@ -3690,7 +3694,7 @@ push_parm_decl (const struct c_parm *parm)\n \n   decl = pushdecl (decl);\n \n-  finish_decl (decl, NULL_TREE, NULL_TREE);\n+  finish_decl (decl, NULL_TREE, NULL_TREE, NULL_TREE);\n }\n \n /* Mark all the parameter declarations to date as forward decls.\n@@ -3740,7 +3744,7 @@ build_compound_literal (tree type, tree init, bool non_const)\n   TREE_USED (decl) = 1;\n   TREE_TYPE (decl) = type;\n   TREE_READONLY (decl) = TYPE_READONLY (type);\n-  store_init_value (decl, init);\n+  store_init_value (decl, init, NULL_TREE);\n \n   if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n     {\n@@ -4678,7 +4682,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\ttree decl = build_decl (TYPE_DECL, NULL_TREE, type);\n \t\tDECL_ARTIFICIAL (decl) = 1;\n \t\tpushdecl (decl);\n-\t\tfinish_decl (decl, NULL_TREE, NULL_TREE);\n+\t\tfinish_decl (decl, NULL_TREE, NULL_TREE, NULL_TREE);\n \t\tTYPE_NAME (type) = decl;\n \t      }\n \n@@ -5527,7 +5531,7 @@ grokfield (location_t loc,\n \t\t\t  width ? &width : NULL, decl_attrs, NULL, NULL,\n \t\t\t  DEPRECATED_NORMAL);\n \n-  finish_decl (value, NULL_TREE, NULL_TREE);\n+  finish_decl (value, NULL_TREE, NULL_TREE, NULL_TREE);\n   DECL_INITIAL (value) = width;\n \n   return value;\n@@ -6814,7 +6818,7 @@ finish_function (void)\n       && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (fndecl)))\n       == integer_type_node && flag_isoc99)\n     {\n-      tree stmt = c_finish_return (integer_zero_node);\n+      tree stmt = c_finish_return (integer_zero_node, NULL_TREE);\n       /* Hack.  We don't want the middle-end to warn that this return\n \t is unreachable, so we mark its location as special.  Using\n \t UNKNOWN_LOCATION has the problem that it gets clobbered in"}, {"sha": "b574559d928d7a8386daf84b3f75814fe2261e3c", "filename": "gcc/c-omp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -142,7 +142,7 @@ c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n   /* There are lots of warnings, errors, and conversions that need to happen\n      in the course of interpreting a statement.  Use the normal mechanisms\n      to do this, and then take it apart again.  */\n-  x = build_modify_expr (input_location, lhs, code, rhs);\n+  x = build_modify_expr (input_location, lhs, code, rhs, NULL_TREE);\n   if (x == error_mark_node)\n     return error_mark_node;\n   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);  \n@@ -260,7 +260,7 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t      fail = true;\n \t    }\n \n-\t  init = build_modify_expr (elocus, decl, NOP_EXPR, init);\n+\t  init = build_modify_expr (elocus, decl, NOP_EXPR, init, NULL_TREE);\n \t}\n       gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n       gcc_assert (TREE_OPERAND (init, 0) == decl);"}, {"sha": "e5129dce7e8e49189d107241098675294ce46f39", "filename": "gcc/c-parser.c", "status": "modified", "additions": 120, "deletions": 24, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -916,7 +916,10 @@ static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n \t\t\t\t\t\t\t\tstruct c_expr);\n static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n-static tree c_parser_expr_list (c_parser *, bool, bool);\n+static VEC(tree,gc) *c_parser_expr_list (c_parser *, bool, bool,\n+\t\t\t\t\t VEC(tree,gc) **);\n+static void c_parser_release_expr_list (VEC(tree,gc) *);\n+static tree c_parser_vec_to_tree_list (VEC(tree,gc) *);\n static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n@@ -1230,7 +1233,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t      if (d != error_mark_node)\n \t\t{\n \t\t  maybe_warn_string_init (TREE_TYPE (d), init);\n-\t\t  finish_decl (d, init.value, asm_name);\n+\t\t  finish_decl (d, init.value, init.original_type, asm_name);\n \t\t}\n \t    }\n \t  else\n@@ -1239,7 +1242,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t\t\t\t   chainon (postfix_attrs,\n \t\t\t\t\t    all_prefix_attrs));\n \t      if (d)\n-\t\tfinish_decl (d, NULL_TREE, asm_name);\n+\t\tfinish_decl (d, NULL_TREE, NULL_TREE, asm_name);\n \t    }\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n@@ -2786,6 +2789,7 @@ c_parser_attributes (c_parser *parser)\n \t     || c_parser_next_token_is (parser, CPP_KEYWORD))\n \t{\n \t  tree attr, attr_name, attr_args;\n+\t  VEC(tree,gc) *expr_list;\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n \t      c_parser_consume_token (parser);\n@@ -2864,18 +2868,24 @@ c_parser_attributes (c_parser *parser)\n \t\tattr_args = build_tree_list (NULL_TREE, arg1);\n \t      else\n \t\t{\n+\t\t  tree tree_list;\n \t\t  c_parser_consume_token (parser);\n-\t\t  attr_args = tree_cons (NULL_TREE, arg1,\n-\t\t\t\t\t c_parser_expr_list (parser, false,\n-\t\t\t\t\t\t\t     true));\n+\t\t  expr_list = c_parser_expr_list (parser, false, true, NULL);\n+\t\t  tree_list = c_parser_vec_to_tree_list (expr_list);\n+\t\t  attr_args = tree_cons (NULL_TREE, arg1, tree_list);\n+\t\t  c_parser_release_expr_list (expr_list);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t\tattr_args = NULL_TREE;\n \t      else\n-\t\tattr_args = c_parser_expr_list (parser, false, true);\n+\t\t{\n+\t\t  expr_list = c_parser_expr_list (parser, false, true, NULL);\n+\t\t  attr_args = c_parser_vec_to_tree_list (expr_list);\n+\t\t  c_parser_release_expr_list (expr_list);\n+\t\t}\n \t    }\n \t  attr = build_tree_list (attr_name, attr_args);\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -3739,12 +3749,13 @@ c_parser_statement_after_labels (c_parser *parser)\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n-\t      stmt = c_finish_return (NULL_TREE);\n+\t      stmt = c_finish_return (NULL_TREE, NULL_TREE);\n \t      c_parser_consume_token (parser);\n \t    }\n \t  else\n \t    {\n-\t      stmt = c_finish_return (c_parser_expression_conv (parser).value);\n+\t      struct c_expr expr = c_parser_expression_conv (parser);\n+\t      stmt = c_finish_return (expr.value, expr.original_type);\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n@@ -4434,7 +4445,8 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n   c_parser_consume_token (parser);\n   rhs = c_parser_expr_no_commas (parser, NULL);\n   rhs = default_function_array_conversion (rhs);\n-  ret.value = build_modify_expr (op_location, lhs.value, code, rhs.value);\n+  ret.value = build_modify_expr (op_location, lhs.value, code, rhs.value,\n+\t\t\t\t rhs.original_type);\n   if (code == NOP_EXPR)\n     ret.original_code = MODIFY_EXPR;\n   else\n@@ -5622,7 +5634,9 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t\t\t\t\t   struct c_expr expr)\n {\n   struct c_expr orig_expr;\n-  tree ident, idx, exprlist;\n+  tree ident, idx;\n+  VEC(tree,gc) *exprlist;\n+  VEC(tree,gc) *origtypes;\n   location_t loc = c_parser_peek_token (parser)->location;\n   while (true)\n     {\n@@ -5643,20 +5657,26 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  /* Function call.  */\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-\t    exprlist = NULL_TREE;\n+\t    exprlist = NULL;\n \t  else\n-\t    exprlist = c_parser_expr_list (parser, true, false);\n+\t    exprlist = c_parser_expr_list (parser, true, false, &origtypes);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  orig_expr = expr;\n-\t  expr.value = build_function_call (expr.value, exprlist);\n+\t  expr.value = build_function_call_vec (expr.value, exprlist,\n+\t\t\t\t\t\torigtypes);\n \t  expr.original_code = ERROR_MARK;\n \t  if (TREE_CODE (expr.value) == INTEGER_CST\n \t      && TREE_CODE (orig_expr.value) == FUNCTION_DECL\n \t      && DECL_BUILT_IN_CLASS (orig_expr.value) == BUILT_IN_NORMAL\n \t      && DECL_FUNCTION_CODE (orig_expr.value) == BUILT_IN_CONSTANT_P)\n \t    expr.original_code = C_MAYBE_CONST_EXPR;\n \t  expr.original_type = NULL;\n+\t  if (exprlist != NULL)\n+\t    {\n+\t      c_parser_release_expr_list (exprlist);\n+\t      c_parser_release_expr_list (origtypes);\n+\t    }\n \t  break;\n \tcase CPP_DOT:\n \t  /* Structure element reference.  */\n@@ -5788,17 +5808,55 @@ c_parser_expression_conv (c_parser *parser)\n      nonempty-expr-list , assignment-expression\n */\n \n-static tree\n-c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p)\n+/* We cache two vectors, to save most allocation and deallocation.  */\n+static GTY((deletable)) VEC(tree,gc) *cached_expr_list_1;\n+static GTY((deletable)) VEC(tree,gc) *cached_expr_list_2;\n+\n+static VEC(tree,gc) *\n+c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n+\t\t    VEC(tree,gc) **p_orig_types)\n {\n+  VEC(tree,gc) *ret;\n+  VEC(tree,gc) *orig_types;\n   struct c_expr expr;\n-  tree ret, cur;\n+\n+  if (cached_expr_list_1 != NULL)\n+    {\n+      ret = cached_expr_list_1;\n+      cached_expr_list_1 = NULL;\n+      VEC_truncate (tree, ret, 0);\n+    }\n+  else if (cached_expr_list_2 != NULL)\n+    {\n+      ret = cached_expr_list_2;\n+      cached_expr_list_2 = NULL;\n+      VEC_truncate (tree, ret, 0);\n+    }\n+  else\n+    ret = VEC_alloc (tree, gc, 16);\n+\n+  if (p_orig_types == NULL)\n+    orig_types = NULL;\n+  else\n+    {\n+      if (cached_expr_list_2 != NULL)\n+\t{\n+\t  orig_types = cached_expr_list_2;\n+\t  cached_expr_list_2 = NULL;\n+\t  VEC_truncate (tree, orig_types, 0);\n+\t}\n+      else\n+\torig_types = VEC_alloc (tree, gc, 16);\n+    }\n+\n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n     expr = default_function_array_conversion (expr);\n   if (fold_p)\n     expr.value = c_fully_fold (expr.value, false, NULL);\n-  ret = cur = build_tree_list (NULL_TREE, expr.value);\n+  VEC_quick_push (tree, ret, expr.value);\n+  if (orig_types != NULL)\n+    VEC_quick_push (tree, orig_types, expr.original_type);\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       c_parser_consume_token (parser);\n@@ -5807,11 +5865,45 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p)\n \texpr = default_function_array_conversion (expr);\n       if (fold_p)\n \texpr.value = c_fully_fold (expr.value, false, NULL);\n-      cur = TREE_CHAIN (cur) = build_tree_list (NULL_TREE, expr.value);\n+      VEC_safe_push (tree, gc, ret, expr.value);\n+      if (orig_types != NULL)\n+\tVEC_safe_push (tree, gc, orig_types, expr.original_type);\n     }\n+  if (orig_types != NULL)\n+    *p_orig_types = orig_types;\n   return ret;\n }\n \n+/* Release a vector returned by c_parser_expr_list.  */\n+\n+static void\n+c_parser_release_expr_list (VEC(tree,gc) *vec)\n+{\n+  if (cached_expr_list_1 == NULL)\n+    cached_expr_list_1 = vec;\n+  else if (cached_expr_list_2 == NULL)\n+    cached_expr_list_2 = vec;\n+  else\n+    VEC_free (tree, gc, vec);\n+}\n+\n+/* Convert a vector, as returned by c_parser_expr_list, to a\n+   tree_list.  */\n+\n+static tree\n+c_parser_vec_to_tree_list (VEC(tree,gc) *vec)\n+{\n+  tree ret = NULL_TREE;\n+  tree *pp = &ret;\n+  unsigned int i;\n+  tree t;\n+  for (i = 0; VEC_iterate (tree, vec, i, t); ++i)\n+    {\n+      *pp = build_tree_list (NULL, t);\n+      pp = &TREE_CHAIN (*pp);\n+    }\n+  return ret;\n+}\n \f\n /* Parse Objective-C-specific constructs.  */\n \n@@ -6682,18 +6774,21 @@ c_parser_objc_message_args (c_parser *parser)\n static tree\n c_parser_objc_keywordexpr (c_parser *parser)\n {\n-  tree list = c_parser_expr_list (parser, true, true);\n-  if (TREE_CHAIN (list) == NULL_TREE)\n+  tree ret;\n+  VEC(tree,gc) *expr_list = c_parser_expr_list (parser, true, true, NULL);\n+  if (VEC_length (tree, expr_list) == 1)\n     {\n       /* Just return the expression, remove a level of\n \t indirection.  */\n-      return TREE_VALUE (list);\n+      ret = VEC_index (tree, expr_list, 0);\n     }\n   else\n     {\n       /* We have a comma expression, we will collapse later.  */\n-      return list;\n+      ret = c_parser_vec_to_tree_list (expr_list);\n     }\n+  c_parser_release_expr_list (expr_list);\n+  return ret;\n }\n \n \f\n@@ -7738,7 +7833,8 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \t  init_exp = c_parser_expr_no_commas (parser, NULL);\n \t  init_exp = default_function_array_conversion (init_exp);\n \t  init = build_modify_expr (init_loc,\n-\t\t\t\t    decl, NOP_EXPR, init_exp.value);\n+\t\t\t\t    decl, NOP_EXPR, init_exp.value,\n+\t\t\t\t    init_exp.original_type);\n \t  init = c_process_expr_stmt (init);\n \n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");"}, {"sha": "f4a2e71bf0f873501fab38f9f4c26db3b784471d", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -500,7 +500,7 @@ extern void undeclared_variable (tree, location_t);\n extern tree declare_label (tree);\n extern tree define_label (location_t, tree);\n extern void c_maybe_initialize_eh (void);\n-extern void finish_decl (tree, tree, tree);\n+extern void finish_decl (tree, tree, tree, tree);\n extern tree finish_enum (tree, tree, tree);\n extern void finish_function (void);\n extern tree finish_struct (tree, tree, tree);\n@@ -595,7 +595,7 @@ extern tree build_conditional_expr (tree, bool, tree, tree);\n extern tree build_compound_expr (tree, tree);\n extern tree c_cast_expr (struct c_type_name *, tree);\n extern tree build_c_cast (tree, tree);\n-extern void store_init_value (tree, tree);\n+extern void store_init_value (tree, tree, tree);\n extern void error_init (const char *);\n extern void pedwarn_init (location_t, int opt, const char *);\n extern void maybe_warn_string_init (tree, struct c_expr);\n@@ -621,7 +621,7 @@ extern tree c_begin_stmt_expr (void);\n extern tree c_finish_stmt_expr (tree);\n extern tree c_process_expr_stmt (tree);\n extern tree c_finish_expr_stmt (tree);\n-extern tree c_finish_return (tree);\n+extern tree c_finish_return (tree, tree);\n extern tree c_finish_bc_stmt (tree *, bool);\n extern tree c_finish_goto_label (tree);\n extern tree c_finish_goto_ptr (tree);"}, {"sha": "7fc55e230e4413e7d94209df1ce118bb3d2d44e5", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 161, "deletions": 81, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -87,22 +87,23 @@ static int comp_target_types (tree, tree);\n static int function_types_compatible_p (const_tree, const_tree);\n static int type_lists_compatible_p (const_tree, const_tree);\n static tree lookup_field (tree, tree);\n-static int convert_arguments (int, tree *, tree, tree, tree, tree);\n+static int convert_arguments (tree, VEC(tree,gc) *, VEC(tree,gc) *, tree,\n+\t\t\t      tree);\n static tree pointer_diff (tree, tree);\n-static tree convert_for_assignment (tree, tree, enum impl_conv, bool,\n+static tree convert_for_assignment (tree, tree, tree, enum impl_conv, bool,\n \t\t\t\t    tree, tree, int);\n static tree valid_compound_expr_initializer (tree, tree);\n static void push_string (const char *);\n static void push_member_name (tree);\n static int spelling_length (void);\n static char *print_spelling (char *);\n static void warning_init (int, const char *);\n-static tree digest_init (tree, tree, bool, bool, int);\n-static void output_init_element (tree, bool, tree, tree, int, bool);\n+static tree digest_init (tree, tree, tree, bool, bool, int);\n+static void output_init_element (tree, tree, bool, tree, tree, int, bool);\n static void output_pending_init_elements (int);\n static int set_designator (int);\n static void push_range_stack (tree);\n-static void add_pending_init (tree, tree, bool);\n+static void add_pending_init (tree, tree, tree, bool);\n static void set_nonincremental_init (void);\n static void set_nonincremental_init_from_string (tree);\n static tree find_init_member (tree);\n@@ -2409,6 +2410,29 @@ c_expr_sizeof_type (struct c_type_name *t)\n \n tree\n build_function_call (tree function, tree params)\n+{\n+  VEC(tree,gc) *vec;\n+  tree ret;\n+\n+  vec = VEC_alloc (tree, gc, list_length (params));\n+  for (; params; params = TREE_CHAIN (params))\n+    VEC_quick_push (tree, vec, TREE_VALUE (params));\n+  ret = build_function_call_vec (function, vec, NULL);\n+  VEC_free (tree, gc, vec);\n+  return ret;\n+}\n+\n+/* Build a function call to function FUNCTION with parameters PARAMS.\n+   ORIGTYPES, if not NULL, is a vector of types; each element is\n+   either NULL or the original type of the corresponding element in\n+   PARAMS.  The original type may differ from TREE_TYPE of the\n+   parameter for enums.  FUNCTION's data type may be a function type\n+   or pointer-to-function.  This function changes the elements of\n+   PARAMS.  */\n+\n+tree\n+build_function_call_vec (tree function, VEC(tree,gc) *params,\n+\t\t\t VEC(tree,gc) *origtypes)\n {\n   tree fntype, fundecl = 0;\n   tree name = NULL_TREE, result;\n@@ -2439,7 +2463,9 @@ build_function_call (tree function, tree params)\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n-  function = objc_rewrite_function_call (function, params);\n+  if (!VEC_empty (tree, params))\n+    function = objc_rewrite_function_call (function,\n+\t\t\t\t\t   VEC_index (tree, params, 0));\n \n   function = c_fully_fold (function, false, NULL);\n \n@@ -2464,10 +2490,8 @@ build_function_call (tree function, tree params)\n   /* Convert the parameters to the types declared in the\n      function prototype, or apply default promotions.  */\n \n-  nargs = list_length (params);\n-  argarray = (tree *) alloca (nargs * sizeof (tree));\n-  nargs = convert_arguments (nargs, argarray, TYPE_ARG_TYPES (fntype), \n-\t\t\t     params, function, fundecl);\n+  nargs = convert_arguments (TYPE_ARG_TYPES (fntype), params, origtypes,\n+\t\t\t     function, fundecl);\n   if (nargs < 0)\n     return error_mark_node;\n \n@@ -2496,7 +2520,8 @@ build_function_call (tree function, tree params)\n       /* Before the abort, allow the function arguments to exit or\n \t call longjmp.  */\n       for (i = 0; i < nargs; i++)\n-\ttrap = build2 (COMPOUND_EXPR, void_type_node, argarray[i], trap);\n+\ttrap = build2 (COMPOUND_EXPR, void_type_node,\n+\t\t       VEC_index (tree, params, i), trap);\n \n       if (VOID_TYPE_P (return_type))\n \t{\n@@ -2521,6 +2546,8 @@ build_function_call (tree function, tree params)\n \t}\n     }\n \n+  argarray = VEC_address (tree, params);\n+\n   /* Check that arguments to builtin functions match the expectations.  */\n   if (fundecl\n       && DECL_BUILT_IN (fundecl)\n@@ -2559,34 +2586,31 @@ build_function_call (tree function, tree params)\n   return require_complete_type (result);\n }\n \f\n-/* Convert the argument expressions in the list VALUES\n-   to the types in the list TYPELIST.  The resulting arguments are\n-   stored in the array ARGARRAY which has size NARGS.\n+/* Convert the argument expressions in the vector VALUES\n+   to the types in the list TYPELIST.\n \n    If TYPELIST is exhausted, or when an element has NULL as its type,\n    perform the default conversions.\n \n-   PARMLIST is the chain of parm decls for the function being called.\n-   It may be 0, if that info is not available.\n-   It is used only for generating error messages.\n+   ORIGTYPES is the original types of the expressions in VALUES.  This\n+   holds the type of enum values which have been converted to integral\n+   types.  It may be NULL.\n \n    FUNCTION is a tree for the called function.  It is used only for\n    error messages, where it is formatted with %qE.\n \n    This is also where warnings about wrong number of args are generated.\n \n-   VALUES is a chain of TREE_LIST nodes with the elements of the list\n-   in the TREE_VALUE slots of those nodes.\n-\n    Returns the actual number of arguments processed (which may be less\n-   than NARGS in some error situations), or -1 on failure.  */\n+   than the length of VALUES in some error situations), or -1 on\n+   failure.  */\n \n static int\n-convert_arguments (int nargs, tree *argarray,\n-\t\t   tree typelist, tree values, tree function, tree fundecl)\n+convert_arguments (tree typelist, VEC(tree,gc) *values,\n+\t\t   VEC(tree,gc) *origtypes, tree function, tree fundecl)\n {\n-  tree typetail, valtail;\n-  int parmnum;\n+  tree typetail, val;\n+  unsigned int parmnum;\n   const bool type_generic = fundecl\n     && lookup_attribute (\"type generic\", TYPE_ATTRIBUTES(TREE_TYPE (fundecl)));\n   bool type_generic_remove_excess_precision = false;\n@@ -2626,20 +2650,20 @@ convert_arguments (int nargs, tree *argarray,\n     }\n \n   /* Scan the given expressions and types, producing individual\n-     converted arguments and storing them in ARGARRAY.  */\n+     converted arguments.  */\n \n-  for (valtail = values, typetail = typelist, parmnum = 0;\n-       valtail;\n-       valtail = TREE_CHAIN (valtail), parmnum++)\n+  for (typetail = typelist, parmnum = 0;\n+       VEC_iterate (tree, values, parmnum, val);\n+       ++parmnum)\n     {\n       tree type = typetail ? TREE_VALUE (typetail) : 0;\n-      tree val = TREE_VALUE (valtail);\n       tree valtype = TREE_TYPE (val);\n       tree rname = function;\n       int argnum = parmnum + 1;\n       const char *invalid_func_diag;\n       bool excess_precision = false;\n       bool npc;\n+      tree parmval;\n \n       if (type == void_type_node)\n \t{\n@@ -2675,7 +2699,6 @@ convert_arguments (int nargs, tree *argarray,\n       if (type != 0)\n \t{\n \t  /* Formal parm type is specified by a function prototype.  */\n-\t  tree parmval;\n \n \t  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n \t    {\n@@ -2684,6 +2707,8 @@ convert_arguments (int nargs, tree *argarray,\n \t    }\n \t  else\n \t    {\n+\t      tree origtype;\n+\n \t      /* Optionally warn about conversions that\n \t\t differ from the default conversions.  */\n \t      if (warn_traditional_conversion || warn_traditional)\n@@ -2812,7 +2837,11 @@ convert_arguments (int nargs, tree *argarray,\n \t\t sake of better warnings from convert_and_check.  */\n \t      if (excess_precision)\n \t\tval = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n-\t      parmval = convert_for_assignment (type, val, ic_argpass, npc,\n+\t      origtype = (origtypes == NULL\n+\t\t\t  ? NULL_TREE\n+\t\t\t  : VEC_index (tree, origtypes, parmnum));\n+\t      parmval = convert_for_assignment (type, val, origtype,\n+\t\t\t\t\t\tic_argpass, npc,\n \t\t\t\t\t\tfundecl, function,\n \t\t\t\t\t\tparmnum + 1);\n \n@@ -2821,23 +2850,22 @@ convert_arguments (int nargs, tree *argarray,\n \t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n \t\tparmval = default_conversion (parmval);\n \t    }\n-\t  argarray[parmnum] = parmval;\n \t}\n       else if (TREE_CODE (valtype) == REAL_TYPE\n \t       && (TYPE_PRECISION (valtype)\n \t\t   < TYPE_PRECISION (double_type_node))\n \t       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (valtype)))\n         {\n \t  if (type_generic)\n-\t    argarray[parmnum] = val;\n+\t    parmval = val;\n \t  else\n \t    /* Convert `float' to `double'.  */\n-\t    argarray[parmnum] = convert (double_type_node, val);\n+\t    parmval = convert (double_type_node, val);\n \t}\n       else if (excess_precision && !type_generic)\n \t/* A \"double\" argument with excess precision being passed\n \t   without a prototype or in variable arguments.  */\n-\targarray[parmnum] = convert (valtype, val);\n+\tparmval = convert (valtype, val);\n       else if ((invalid_func_diag =\n \t\ttargetm.calls.invalid_arg_for_unprototyped_fn (typelist, fundecl, val)))\n \t{\n@@ -2846,13 +2874,15 @@ convert_arguments (int nargs, tree *argarray,\n \t}\n       else\n \t/* Convert `short' and `char' to full-size `int'.  */\n-\targarray[parmnum] = default_conversion (val);\n+\tparmval = default_conversion (val);\n+\n+      VEC_replace (tree, values, parmnum, parmval);\n \n       if (typetail)\n \ttypetail = TREE_CHAIN (typetail);\n     }\n \n-  gcc_assert (parmnum == nargs);\n+  gcc_assert (parmnum == VEC_length (tree, values));\n \n   if (typetail != 0 && TREE_VALUE (typetail) != void_type_node)\n     {\n@@ -4069,7 +4099,7 @@ build_c_cast (tree type, tree expr)\n \t\t   \"ISO C forbids casts to union type\");\n \t  t = digest_init (type,\n \t\t\t   build_constructor_single (type, field, value),\n-\t\t\t   false, true, 0);\n+\t\t\t   NULL_TREE, false, true, 0);\n \t  TREE_CONSTANT (t) = TREE_CONSTANT (value);\n \t  return t;\n \t}\n@@ -4263,12 +4293,15 @@ c_cast_expr (struct c_type_name *type_name, tree expr)\n    MODIFYCODE is the code for a binary operator that we use\n    to combine the old value of LHS with RHS to get the new value.\n    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.\n+   If RHS_ORIGTYPE is not NULL_TREE, it is the original type of RHS,\n+   which may differ from TREE_TYPE (RHS) for an enum value.\n \n    LOCATION is the location of the MODIFYCODE operator.  */\n \n tree\n build_modify_expr (location_t location,\n-\t\t   tree lhs, enum tree_code modifycode, tree rhs)\n+\t\t   tree lhs, enum tree_code modifycode, tree rhs,\n+\t\t   tree rhs_origtype)\n {\n   tree result;\n   tree newrhs;\n@@ -4298,7 +4331,7 @@ build_modify_expr (location_t location,\n   if (TREE_CODE (lhs) == C_MAYBE_CONST_EXPR)\n     {\n       tree inner = build_modify_expr (location, C_MAYBE_CONST_EXPR_EXPR (lhs),\n-\t\t\t\t      modifycode, rhs);\n+\t\t\t\t      modifycode, rhs, rhs_origtype);\n       if (inner == error_mark_node)\n \treturn error_mark_node;\n       result = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (inner),\n@@ -4318,6 +4351,10 @@ build_modify_expr (location_t location,\n       lhs = stabilize_reference (lhs);\n       newrhs = build_binary_op (location,\n \t\t\t\tmodifycode, lhs, rhs, 1);\n+\n+      /* The original type of the right hand side is no longer\n+\t meaningful.  */\n+      rhs_origtype = NULL_TREE;\n     }\n \n   /* Give an error for storing in something that is 'const'.  */\n@@ -4362,8 +4399,8 @@ build_modify_expr (location_t location,\n   newrhs = c_fully_fold (newrhs, false, NULL);\n   if (rhs_semantic_type)\n     newrhs = build1 (EXCESS_PRECISION_EXPR, rhs_semantic_type, newrhs);\n-  newrhs = convert_for_assignment (lhstype, newrhs, ic_assign, npc,\n-\t\t\t\t   NULL_TREE, NULL_TREE, 0);\n+  newrhs = convert_for_assignment (lhstype, newrhs, rhs_origtype, ic_assign,\n+\t\t\t\t   npc, NULL_TREE, NULL_TREE, 0);\n   if (TREE_CODE (newrhs) == ERROR_MARK)\n     return error_mark_node;\n \n@@ -4392,15 +4429,17 @@ build_modify_expr (location_t location,\n   if (olhstype == TREE_TYPE (result))\n     return result;\n \n-  result = convert_for_assignment (olhstype, result, ic_assign, false,\n-\t\t\t\t   NULL_TREE, NULL_TREE, 0);\n+  result = convert_for_assignment (olhstype, result, rhs_origtype, ic_assign,\n+\t\t\t\t   false, NULL_TREE, NULL_TREE, 0);\n   protected_set_expr_location (result, location);\n   return result;\n }\n \f\n-/* Convert value RHS to type TYPE as preparation for an assignment\n-   to an lvalue of type TYPE.  NULL_POINTER_CONSTANT says whether RHS\n-   was a null pointer constant before any folding.\n+/* Convert value RHS to type TYPE as preparation for an assignment to\n+   an lvalue of type TYPE.  If ORIGTYPE is not NULL_TREE, it is the\n+   original type of RHS; this differs from TREE_TYPE (RHS) for enum\n+   types.  NULL_POINTER_CONSTANT says whether RHS was a null pointer\n+   constant before any folding.\n    The real work of conversion is done by `convert'.\n    The purpose of this function is to generate error messages\n    for assignments that are not allowed in C.\n@@ -4411,8 +4450,8 @@ build_modify_expr (location_t location,\n    PARMNUM is the number of the argument, for printing in error messages.  */\n \n static tree\n-convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n-\t\t\tbool null_pointer_constant,\n+convert_for_assignment (tree type, tree rhs, tree origtype,\n+\t\t\tenum impl_conv errtype, bool null_pointer_constant,\n \t\t\ttree fundecl, tree function, int parmnum)\n {\n   enum tree_code codel = TREE_CODE (type);\n@@ -4504,6 +4543,31 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       objc_ok = objc_compare_types (type, rhstype, parmno, rname);\n     }\n \n+  if (warn_cxx_compat)\n+    {\n+      tree checktype = origtype != NULL_TREE ? origtype : rhstype;\n+      if (checktype != error_mark_node\n+\t  && TREE_CODE (type) == ENUMERAL_TYPE\n+\t  && TYPE_MAIN_VARIANT (checktype) != TYPE_MAIN_VARIANT (type))\n+\t{\n+\t  /* FIXME: Until the gcc source code is converted, we only\n+\t     warn about parameter passing.  We will add the other\n+\t     cases when bootstrap succeeds with them.  */\n+\t  if (errtype == ic_argpass)\n+\t    {\n+\t      WARN_FOR_ASSIGNMENT (input_location, OPT_Wc___compat,\n+\t\t\t\t   G_(\"enum conversion when passing argument \"\n+\t\t\t\t      \"%d of %qE is invalid in C++\"),\n+\t\t\t\t   G_(\"enum conversion in assignment is \"\n+\t\t\t\t      \"invalid in C++\"),\n+\t\t\t\t   G_(\"enum conversion in initialization is \"\n+\t\t\t\t      \"invalid in C++\"),\n+\t\t\t\t   G_(\"enum conversion in return is \"\n+\t\t\t\t      \"invalid in C++\"));\n+\t    }\n+\t}\n+    }\n+\n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype))\n     return rhs;\n \n@@ -4945,10 +5009,11 @@ valid_compound_expr_initializer (tree value, tree endtype)\n /* Perform appropriate conversions on the initial value of a variable,\n    store it in the declaration DECL,\n    and print any error messages that are appropriate.\n+   If ORIGTYPE is not NULL_TREE, it is the original type of INIT.\n    If the init is invalid, store an ERROR_MARK.  */\n \n void\n-store_init_value (tree decl, tree init)\n+store_init_value (tree decl, tree init, tree origtype)\n {\n   tree value, type;\n   bool npc = false;\n@@ -4963,7 +5028,7 @@ store_init_value (tree decl, tree init)\n \n   if (init)\n     npc = null_pointer_constant_p (init);\n-  value = digest_init (type, init, npc, true, TREE_STATIC (decl));\n+  value = digest_init (type, init, origtype, npc, true, TREE_STATIC (decl));\n \n   /* Store the expression if valid; else report error.  */\n \n@@ -5194,6 +5259,8 @@ maybe_warn_string_init (tree type, struct c_expr expr)\n /* Digest the parser output INIT as an initializer for type TYPE.\n    Return a C expression of type TYPE to represent the initial value.\n \n+   If ORIGTYPE is not NULL_TREE, it is the original type of INIT.\n+\n    NULL_POINTER_CONSTANT is true if INIT is a null pointer constant.\n \n    If INIT is a string constant, STRICT_STRING is true if it is\n@@ -5204,7 +5271,7 @@ maybe_warn_string_init (tree type, struct c_expr expr)\n    elements are seen.  */\n \n static tree\n-digest_init (tree type, tree init, bool null_pointer_constant,\n+digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \t     bool strict_string, int require_constant)\n {\n   enum tree_code code = TREE_CODE (type);\n@@ -5431,8 +5498,8 @@ digest_init (tree type, tree init, bool null_pointer_constant,\n \n       /* Added to enable additional -Wmissing-format-attribute warnings.  */\n       if (TREE_CODE (TREE_TYPE (inside_init)) == POINTER_TYPE)\n-\tinside_init = convert_for_assignment (type, inside_init, ic_init,\n-\t\t\t\t\t      null_pointer_constant,\n+\tinside_init = convert_for_assignment (type, inside_init, origtype,\n+\t\t\t\t\t      ic_init, null_pointer_constant,\n \t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n       return inside_init;\n     }\n@@ -5451,7 +5518,7 @@ digest_init (tree type, tree init, bool null_pointer_constant,\n \tinside_init = build1 (EXCESS_PRECISION_EXPR, semantic_type,\n \t\t\t      inside_init);\n       inside_init\n-\t= convert_for_assignment (type, inside_init, ic_init,\n+\t= convert_for_assignment (type, inside_init, origtype, ic_init,\n \t\t\t\t  null_pointer_constant,\n \t\t\t\t  NULL_TREE, NULL_TREE, 0);\n \n@@ -5549,6 +5616,7 @@ struct init_node\n   int balance;\n   tree purpose;\n   tree value;\n+  tree origtype;\n };\n \n /* Tree of pending elements at this constructor level.\n@@ -6418,15 +6486,16 @@ set_init_label (tree fieldname)\n \f\n /* Add a new initializer to the tree of pending initializers.  PURPOSE\n    identifies the initializer, either array index or field in a structure.\n-   VALUE is the value of that index or field.\n+   VALUE is the value of that index or field.  If ORIGTYPE is not\n+   NULL_TREE, it is the original type of VALUE.\n \n    IMPLICIT is true if value comes from pop_init_level (1),\n    the new initializer has been merged with the existing one\n    and thus no warnings should be emitted about overriding an\n    existing initializer.  */\n \n static void\n-add_pending_init (tree purpose, tree value, bool implicit)\n+add_pending_init (tree purpose, tree value, tree origtype, bool implicit)\n {\n   struct init_node *p, **q, *r;\n \n@@ -6452,6 +6521,7 @@ add_pending_init (tree purpose, tree value, bool implicit)\n \t\t    warning_init (OPT_Woverride_init, \"initialized field overwritten\");\n \t\t}\n \t      p->value = value;\n+\t      p->origtype = origtype;\n \t      return;\n \t    }\n \t}\n@@ -6478,6 +6548,7 @@ add_pending_init (tree purpose, tree value, bool implicit)\n \t\t    warning_init (OPT_Woverride_init, \"initialized field overwritten\");\n \t\t}\n \t      p->value = value;\n+\t      p->origtype = origtype;\n \t      return;\n \t    }\n \t}\n@@ -6486,6 +6557,7 @@ add_pending_init (tree purpose, tree value, bool implicit)\n   r = GGC_NEW (struct init_node);\n   r->purpose = purpose;\n   r->value = value;\n+  r->origtype = origtype;\n \n   *q = r;\n   r->parent = p;\n@@ -6661,7 +6733,7 @@ set_nonincremental_init (void)\n     return;\n \n   FOR_EACH_CONSTRUCTOR_ELT (constructor_elements, ix, index, value)\n-    add_pending_init (index, value, false);\n+    add_pending_init (index, value, NULL_TREE, false);\n   constructor_elements = 0;\n   if (TREE_CODE (constructor_type) == RECORD_TYPE)\n     {\n@@ -6751,7 +6823,7 @@ set_nonincremental_init_from_string (tree str)\n \t}\n \n       value = build_int_cst_wide (type, val[1], val[0]);\n-      add_pending_init (purpose, value, false);\n+      add_pending_init (purpose, value, NULL_TREE, false);\n     }\n \n   constructor_incremental = 0;\n@@ -6816,6 +6888,7 @@ find_init_member (tree field)\n /* \"Output\" the next constructor element.\n    At top level, really output it to assembler code now.\n    Otherwise, collect it in a list from which we will make a CONSTRUCTOR.\n+   If ORIGTYPE is not NULL_TREE, it is the original type of VALUE.\n    TYPE is the data type that the containing data type wants here.\n    FIELD is the field (a FIELD_DECL) or the index that this element fills.\n    If VALUE is a string constant, STRICT_STRING is true if it is\n@@ -6832,8 +6905,8 @@ find_init_member (tree field)\n    existing initializer.  */\n \n static void\n-output_init_element (tree value, bool strict_string, tree type, tree field,\n-\t\t     int pending, bool implicit)\n+output_init_element (tree value, tree origtype, bool strict_string, tree type,\n+\t\t     tree field, int pending, bool implicit)\n {\n   tree semantic_type = NULL_TREE;\n   constructor_elt *celt;\n@@ -6914,7 +6987,7 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \n   if (semantic_type)\n     value = build1 (EXCESS_PRECISION_EXPR, semantic_type, value);\n-  value = digest_init (type, value, npc, strict_string,\n+  value = digest_init (type, value, origtype, npc, strict_string,\n \t\t       require_constant_value);\n   if (value == error_mark_node)\n     {\n@@ -6934,7 +7007,7 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t  && tree_int_cst_lt (field, constructor_unfilled_index))\n \tset_nonincremental_init ();\n \n-      add_pending_init (field, value, implicit);\n+      add_pending_init (field, value, origtype, implicit);\n       return;\n     }\n   else if (TREE_CODE (constructor_type) == RECORD_TYPE\n@@ -6960,7 +7033,7 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t    }\n \t}\n \n-      add_pending_init (field, value, implicit);\n+      add_pending_init (field, value, origtype, implicit);\n       return;\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE\n@@ -7043,7 +7116,7 @@ output_pending_init_elements (int all)\n \t{\n \t  if (tree_int_cst_equal (elt->purpose,\n \t\t\t\t  constructor_unfilled_index))\n-\t    output_init_element (elt->value, true,\n+\t    output_init_element (elt->value, elt->origtype, true,\n \t\t\t\t TREE_TYPE (constructor_type),\n \t\t\t\t constructor_unfilled_index, 0, false);\n \t  else if (tree_int_cst_lt (constructor_unfilled_index,\n@@ -7097,7 +7170,8 @@ output_pending_init_elements (int all)\n \t  if (tree_int_cst_equal (elt_bitpos, ctor_unfilled_bitpos))\n \t    {\n \t      constructor_unfilled_fields = elt->purpose;\n-\t      output_init_element (elt->value, true, TREE_TYPE (elt->purpose),\n+\t      output_init_element (elt->value, elt->origtype, true,\n+\t\t\t\t   TREE_TYPE (elt->purpose),\n \t\t\t\t   elt->purpose, 0, false);\n \t    }\n \t  else if (tree_int_cst_lt (ctor_unfilled_bitpos, elt_bitpos))\n@@ -7292,8 +7366,9 @@ process_init_element (struct c_expr value, bool implicit)\n \t  if (value.value)\n \t    {\n \t      push_member_name (constructor_fields);\n-\t      output_init_element (value.value, strict_string,\n-\t\t\t\t   fieldtype, constructor_fields, 1, implicit);\n+\t      output_init_element (value.value, value.original_type,\n+\t\t\t\t   strict_string, fieldtype,\n+\t\t\t\t   constructor_fields, 1, implicit);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n@@ -7382,8 +7457,9 @@ process_init_element (struct c_expr value, bool implicit)\n \t  if (value.value)\n \t    {\n \t      push_member_name (constructor_fields);\n-\t      output_init_element (value.value, strict_string,\n-\t\t\t\t   fieldtype, constructor_fields, 1, implicit);\n+\t      output_init_element (value.value, value.original_type,\n+\t\t\t\t   strict_string, fieldtype,\n+\t\t\t\t   constructor_fields, 1, implicit);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n@@ -7432,8 +7508,9 @@ process_init_element (struct c_expr value, bool implicit)\n \t  if (value.value)\n \t    {\n \t      push_array_bounds (tree_low_cst (constructor_index, 1));\n-\t      output_init_element (value.value, strict_string,\n-\t\t\t\t   elttype, constructor_index, 1, implicit);\n+\t      output_init_element (value.value, value.original_type,\n+\t\t\t\t   strict_string, elttype,\n+\t\t\t\t   constructor_index, 1, implicit);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \n@@ -7461,8 +7538,9 @@ process_init_element (struct c_expr value, bool implicit)\n \n \t  /* Now output the actual element.  */\n \t  if (value.value)\n-\t    output_init_element (value.value, strict_string,\n-\t\t\t\t elttype, constructor_index, 1, implicit);\n+\t    output_init_element (value.value, value.original_type,\n+\t\t\t\t strict_string, elttype,\n+\t\t\t\t constructor_index, 1, implicit);\n \n \t  constructor_index\n \t    = size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);\n@@ -7486,8 +7564,9 @@ process_init_element (struct c_expr value, bool implicit)\n       else\n \t{\n \t  if (value.value)\n-\t    output_init_element (value.value, strict_string,\n-\t\t\t\t constructor_type, NULL_TREE, 1, implicit);\n+\t    output_init_element (value.value, value.original_type,\n+\t\t\t\t strict_string, constructor_type,\n+\t\t\t\t NULL_TREE, 1, implicit);\n \t  constructor_fields = 0;\n \t}\n \n@@ -7718,10 +7797,11 @@ c_finish_goto_ptr (tree expr)\n }\n \n /* Generate a C `return' statement.  RETVAL is the expression for what\n-   to return, or a null pointer for `return;' with no value.  */\n+   to return, or a null pointer for `return;' with no value.  If\n+   ORIGTYPE is not NULL_TREE, it is the original type of RETVAL.  */\n \n tree\n-c_finish_return (tree retval)\n+c_finish_return (tree retval, tree origtype)\n {\n   tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl)), ret_stmt;\n   bool no_warning = false;\n@@ -7768,8 +7848,8 @@ c_finish_return (tree retval)\n     }\n   else\n     {\n-      tree t = convert_for_assignment (valtype, retval, ic_return, npc,\n-\t\t\t\t       NULL_TREE, NULL_TREE, 0);\n+      tree t = convert_for_assignment (valtype, retval, origtype, ic_return,\n+\t\t\t\t       npc, NULL_TREE, NULL_TREE, 0);\n       tree res = DECL_RESULT (current_function_decl);\n       tree inner;\n "}, {"sha": "c05c2880c7cb34c21b85d9ae0ffa3e00e86da696", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -4233,7 +4233,8 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t\t    - int_size_in_bytes (TREE_TYPE (pval))\n \t\t    + partial);\n \t  size_rtx = expand_expr (size_in_bytes (TREE_TYPE (pval)),\n-\t\t\t\t  NULL_RTX, TYPE_MODE (sizetype), 0);\n+\t\t\t\t  NULL_RTX, TYPE_MODE (sizetype),\n+\t\t\t\t  EXPAND_NORMAL);\n \t}\n \n       parm_align = arg->locate.boundary;"}, {"sha": "6019dc697df269296e99fb9b1e2a459eaa7b6fb0", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Prototypes for exported functions defined in arm.c and pe.c\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009 Free Software Foundation, Inc.\n    Contributed by Richard Earnshaw (rearnsha@arm.com)\n    Minor hacks by Nick Clifton (nickc@cygnus.com)\n \n@@ -26,7 +26,7 @@\n extern void arm_override_options (void);\n extern void arm_optimization_options (int, int);\n extern int use_return_insn (int, rtx);\n-extern int arm_regno_class (int);\n+extern enum reg_class arm_regno_class (int);\n extern void arm_load_pic_register (unsigned long);\n extern int arm_volatile_func (void);\n extern const char *arm_output_epilogue (rtx);"}, {"sha": "4d8ae2f11bc1019f16df743a5d0cc14426054956", "filename": "gcc/config/arm/arm-tune.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Farm-tune.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Farm-tune.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-tune.md?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -2,4 +2,4 @@\n ;; Generated automatically by gentune.sh from arm-cores.def\n (define_attr \"tune\"\n \t\"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,cortexa8,cortexa9,cortexr4,cortexr4f,cortexm3,cortexm1\"\n-\t(const (symbol_ref \"arm_tune\")))\n+\t(const (symbol_ref \"((enum attr_tune) arm_tune)\")))"}, {"sha": "80d12676ca00913d1fd19d18ec6b23d9fc0869c9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -4784,7 +4784,7 @@ thumb_legitimize_reload_address (rtx *x_p,\n \n       x = copy_rtx (x);\n       push_reload (orig_x, NULL_RTX, x_p, NULL, MODE_BASE_REG_CLASS (mode),\n-\t\t   Pmode, VOIDmode, 0, 0, opnum, type);\n+\t\t   Pmode, VOIDmode, 0, 0, opnum, (enum reload_type) type);\n       return x;\n     }\n \n@@ -4801,7 +4801,7 @@ thumb_legitimize_reload_address (rtx *x_p,\n \n       x = copy_rtx (x);\n       push_reload (orig_x, NULL_RTX, x_p, NULL, MODE_BASE_REG_CLASS (mode),\n-\t\t   Pmode, VOIDmode, 0, 0, opnum, type);\n+\t\t   Pmode, VOIDmode, 0, 0, opnum, (enum reload_type) type);\n       return x;\n     }\n \n@@ -5465,7 +5465,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       return true;\n \n     case ABS:\n-      if (GET_MODE_CLASS (mode == MODE_FLOAT))\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n \t  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n \t    {\n@@ -5821,10 +5821,12 @@ arm_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t       bool speed)\n {\n   if (!speed)\n-    return arm_size_rtx_costs (x, code, outer_code, total);\n+    return arm_size_rtx_costs (x, (enum rtx_code) code,\n+\t\t\t       (enum rtx_code) outer_code, total);\n   else\n-    return all_cores[(int)arm_tune].rtx_costs (x, code, outer_code, total,\n-\t\t\t\t\t       speed);\n+    return all_cores[(int)arm_tune].rtx_costs (x, (enum rtx_code) code,\n+\t\t\t\t\t       (enum rtx_code) outer_code,\n+\t\t\t\t\t       total, speed);\n }\n \n /* RTX costs for cores with a slow MUL implementation.  Thumb-2 is not\n@@ -7408,7 +7410,7 @@ adjacent_mem_locations (rtx a, rtx b)\n       /* Don't accept any offset that will require multiple\n \t instructions to handle, since this would cause the\n \t arith_adjacentmem pattern to output an overlong sequence.  */\n-      if (!const_ok_for_op (PLUS, val0) || !const_ok_for_op (PLUS, val1))\n+      if (!const_ok_for_op (val0, PLUS) || !const_ok_for_op (val1, PLUS))\n \treturn 0;\n \n       /* Don't allow an eliminable register: register elimination can make\n@@ -10214,8 +10216,7 @@ vfp_emit_fstmd (int base_reg, int count)\n     }\n \n   par = emit_insn (par);\n-  REG_NOTES (par) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n-\t\t\t\t       REG_NOTES (par));\n+  add_reg_note (par, REG_FRAME_RELATED_EXPR, dwarf);\n   RTX_FRAME_RELATED_P (par) = 1;\n \n   return count * 8;\n@@ -12498,8 +12499,8 @@ emit_multi_reg_push (unsigned long mask)\n   RTX_FRAME_RELATED_P (tmp) = 1;\n   XVECEXP (dwarf, 0, 0) = tmp;\n \n-  REG_NOTES (par) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n-\t\t\t\t       REG_NOTES (par));\n+  add_reg_note (par, REG_FRAME_RELATED_EXPR, dwarf);\n+\n   return par;\n }\n \n@@ -12565,8 +12566,8 @@ emit_sfm (int base_reg, int count)\n   XVECEXP (dwarf, 0, 0) = tmp;\n \n   par = emit_insn (par);\n-  REG_NOTES (par) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n-\t\t\t\t       REG_NOTES (par));\n+  add_reg_note (par, REG_FRAME_RELATED_EXPR, dwarf);\n+\n   return par;\n }\n \n@@ -12985,8 +12986,7 @@ thumb_set_frame_pointer (arm_stack_offsets *offsets)\n       dwarf = gen_rtx_SET (VOIDmode, hard_frame_pointer_rtx,\n \t\t\t   plus_constant (stack_pointer_rtx, amount));\n       RTX_FRAME_RELATED_P (dwarf) = 1;\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n-\t\t\t\t\t    REG_NOTES (insn));\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n     }\n \n   RTX_FRAME_RELATED_P (insn) = 1;\n@@ -13049,8 +13049,7 @@ arm_expand_prologue (void)\n       dwarf = gen_rtx_SET (VOIDmode, r0, dwarf);\n       insn = gen_movsi (r0, stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t    dwarf, REG_NOTES (insn));\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n       emit_insn (insn);\n       emit_insn (gen_andsi3 (r1, r0, GEN_INT (~(HOST_WIDE_INT)7)));\n       emit_insn (gen_movsi (stack_pointer_rtx, r1));\n@@ -13117,8 +13116,7 @@ arm_expand_prologue (void)\n \t\t\t\t   plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t  -fp_offset));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t\t    dwarf, REG_NOTES (insn));\n+\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n \t    }\n \t  else\n \t    {\n@@ -14670,7 +14668,8 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n \n /* For efficiency and historical reasons LO_REGS, HI_REGS and CC_REGS are\n    not used in arm mode.  */\n-int\n+\n+enum reg_class\n arm_regno_class (int regno)\n {\n   if (TARGET_THUMB1)\n@@ -17631,9 +17630,7 @@ thumb1_expand_prologue (void)\n \t\t\t       plus_constant (stack_pointer_rtx,\n \t\t\t\t\t      -amount));\n \t  RTX_FRAME_RELATED_P (dwarf) = 1;\n-\t  REG_NOTES (insn)\n-\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n-\t\t\t\t REG_NOTES (insn));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n \t}\n     }\n "}, {"sha": "b55c65cf16dcf4f47c670d42cabde525cb8c348f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1915,7 +1915,7 @@ typedef struct\n \t\t\t\t\t      TARGET_32BIT ? 12 : 16)),\t\\\n \t\t  FNADDR);\t\t\t\t\t\t\\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\t\\\n-\t\t     0, VOIDmode, 2, TRAMP, Pmode,\t\t\t\\\n+\t\t     LCT_NORMAL, VOIDmode, 2, TRAMP, Pmode,\t\t\\\n \t\t     plus_constant (TRAMP, TRAMPOLINE_SIZE), Pmode);\t\\\n }\n #endif"}, {"sha": "7c309c75f558ecfdb26076448be27148e262b00d", "filename": "gcc/config/arm/gentune.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Fgentune.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Farm%2Fgentune.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fgentune.sh?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -9,4 +9,4 @@ allcores=`awk -F'[(, \t]+' '/^ARM_CORE/ { cores = cores$3\",\" } END { print cores\n \n echo \"(define_attr \\\"tune\\\"\"\n echo \"\t\\\"$allcores\\\"\" | sed -e 's/,\"$/\"/'\n-echo \"\t(const (symbol_ref \\\"arm_tune\\\")))\"\n+echo \"\t(const (symbol_ref \\\"((enum attr_tune) arm_tune)\\\")))\""}, {"sha": "d35ea7626a70267e7e0410c54081809872ffc534", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for macro/preprocessor support on the ia-32.\n-   Copyright (C) 2008\n+   Copyright (C) 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -297,14 +297,14 @@ ix86_pragma_target_parse (tree args, tree pop_target)\n   ix86_target_macros_internal (prev_isa & diff_isa,\n \t\t\t       prev_arch,\n \t\t\t       prev_tune,\n-\t\t\t       prev_opt->fpmath,\n+\t\t\t       (enum fpmath_unit) prev_opt->fpmath,\n \t\t\t       cpp_undef);\n \n   /* Define all of the macros for new options that were just turned on.  */\n   ix86_target_macros_internal (cur_isa & diff_isa,\n \t\t\t       cur_arch,\n \t\t\t       cur_tune,\n-\t\t\t       cur_opt->fpmath,\n+\t\t\t       (enum fpmath_unit) cur_opt->fpmath,\n \t\t\t       cpp_define);\n \n   return true;"}, {"sha": "6e60fb7e70b44e2990ebb7d9b523454728c0acab", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -8333,8 +8333,7 @@ ix86_expand_prologue (void)\n       RTX_FRAME_RELATED_P (insn) = 1;\n       t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-allocate));\n       t = gen_rtx_SET (VOIDmode, stack_pointer_rtx, t);\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t    t, REG_NOTES (insn));\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, t);\n \n       if (eax_live)\n \t{\n@@ -14886,31 +14885,22 @@ ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n \t\t\t\t\t\t\t\t    label),\n \t\t\t\t\t\t pc_rtx)));\n       if (bypass_probability >= 0)\n-\tREG_NOTES (i)\n-\t  = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t       GEN_INT (bypass_probability),\n-\t\t\t       REG_NOTES (i));\n+\tadd_reg_note (i, REG_BR_PROB, GEN_INT (bypass_probability));\n     }\n   i = emit_jump_insn (gen_rtx_SET\n \t\t      (VOIDmode, pc_rtx,\n \t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n \t\t\t\t\t     condition, target1, target2)));\n   if (probability >= 0)\n-    REG_NOTES (i)\n-      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t   GEN_INT (probability),\n-\t\t\t   REG_NOTES (i));\n+    add_reg_note (i, REG_BR_PROB, GEN_INT (probability));\n   if (second != NULL_RTX)\n     {\n       i = emit_jump_insn (gen_rtx_SET\n \t\t\t  (VOIDmode, pc_rtx,\n \t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode, second, target1,\n \t\t\t\t\t\t target2)));\n       if (second_probability >= 0)\n-\tREG_NOTES (i)\n-\t  = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t       GEN_INT (second_probability),\n-\t\t\t       REG_NOTES (i));\n+\tadd_reg_note (i, REG_BR_PROB, GEN_INT (second_probability));\n     }\n   if (label != NULL_RTX)\n     emit_label (label);\n@@ -17108,10 +17098,7 @@ predict_jump (int prob)\n {\n   rtx insn = get_last_insn ();\n   gcc_assert (JUMP_P (insn));\n-  REG_NOTES (insn)\n-    = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t GEN_INT (prob),\n-\t\t\t REG_NOTES (insn));\n+  add_reg_note (insn, REG_BR_PROB, GEN_INT (prob));\n }\n \n /* Helper function for the string operations below.  Dest VARIABLE whether\n@@ -23914,7 +23901,7 @@ ix86_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n static rtx\n ix86_expand_multi_arg_builtin (enum insn_code icode, tree exp, rtx target,\n \t\t\t       enum multi_arg_type m_type,\n-\t\t\t       enum insn_code sub_code)\n+\t\t\t       enum rtx_code sub_code)\n {\n   rtx pat;\n   int i;\n@@ -25401,7 +25388,8 @@ ix86_builtin_vectorized_function (unsigned int fn, tree type_out,\n \n   /* Dispatch to a handler for a vectorization library.  */\n   if (ix86_veclib_handler)\n-    return (*ix86_veclib_handler)(fn, type_out, type_in);\n+    return (*ix86_veclib_handler) ((enum built_in_function) fn, type_out,\n+\t\t\t\t   type_in);\n \n   return NULL_TREE;\n }"}, {"sha": "777a72cb9a6f7982f38e8c763b785f90d749a904", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -4375,7 +4375,9 @@\n     ;\n   else\n     {\n-      int slot = virtuals_instantiated ? SLOT_TEMP : SLOT_VIRTUAL;\n+      enum ix86_stack_slot slot = (virtuals_instantiated\n+\t\t\t\t   ? SLOT_TEMP\n+\t\t\t\t   : SLOT_VIRTUAL);\n       rtx temp = assign_386_stack_local (SFmode, slot);\n       emit_insn (gen_truncdfsf2_with_temp (operands[0], operands[1], temp));\n       DONE;\n@@ -4560,7 +4562,9 @@\n     }\n   else\n     {\n-      int slot = virtuals_instantiated ? SLOT_TEMP : SLOT_VIRTUAL;\n+     enum ix86_stack_slot slot = (virtuals_instantiated\n+\t\t\t\t  ? SLOT_TEMP\n+\t\t\t\t  : SLOT_VIRTUAL);\n       operands[2] = assign_386_stack_local (<MODE>mode, slot);\n     }\n })\n@@ -5730,7 +5734,9 @@\n     }\n   else\n     {\n-      int slot = virtuals_instantiated ? SLOT_TEMP : SLOT_VIRTUAL;\n+      enum ix86_stack_slot slot = (virtuals_instantiated\n+\t\t\t\t   ? SLOT_TEMP\n+\t\t\t\t   : SLOT_VIRTUAL);\n       operands[2] = assign_386_stack_local (DImode, slot);\n     }\n })\n@@ -18984,7 +18990,9 @@\n     emit_insn (gen_fxam<mode>2_i387_with_temp (scratch, operands[1]));\n   else\n     {\n-      int slot = virtuals_instantiated ? SLOT_TEMP : SLOT_VIRTUAL;\n+      enum ix86_stack_slot slot = (virtuals_instantiated\n+\t\t\t\t   ? SLOT_TEMP\n+\t\t\t\t   : SLOT_VIRTUAL);\n       rtx temp = assign_386_stack_local (<MODE>mode, slot);\n \n       emit_move_insn (temp, operands[1]);"}, {"sha": "7cccb6be2cc567222b8df5e2729eef3b3c09fe4b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1311,9 +1311,7 @@ ia64_split_tmode_move (rtx operands[])\n       && (GET_CODE (XEXP (EXP, 0)) == POST_MODIFY\t\t\t\\\n \t  || GET_CODE (XEXP (EXP, 0)) == POST_INC\t\t\t\\\n \t  || GET_CODE (XEXP (EXP, 0)) == POST_DEC))\t\t\t\\\n-    REG_NOTES (INSN) = gen_rtx_EXPR_LIST (REG_INC,\t\t\t\\\n-\t\t\t\t\t  XEXP (XEXP (EXP, 0), 0),\t\\\n-\t\t\t\t\t  REG_NOTES (INSN))\n+    add_reg_note (insn, REG_INC, XEXP (XEXP (EXP, 0), 0))\n \n   insn = emit_insn (gen_rtx_SET (VOIDmode, out[0], in[0]));\n   MAYBE_ADD_REG_INC_NOTE (insn, in[0]);\n@@ -2770,9 +2768,8 @@ spill_restore_mem (rtx reg, HOST_WIDE_INT cfa_off)\n \t\t\t\t   gen_rtx_PLUS (DImode,\n \t\t\t\t\t\t spill_fill_data.iter_reg[iter],\n \t\t\t\t\t\t disp_rtx));\n-\t  REG_NOTES (spill_fill_data.prev_insn[iter])\n-\t    = gen_rtx_EXPR_LIST (REG_INC, spill_fill_data.iter_reg[iter],\n-\t\t\t\t REG_NOTES (spill_fill_data.prev_insn[iter]));\n+\t  add_reg_note (spill_fill_data.prev_insn[iter],\n+\t\t\tREG_INC, spill_fill_data.iter_reg[iter]);\n \t}\n       else\n \t{\n@@ -2889,13 +2886,11 @@ do_spill (rtx (*move_fn) (rtx, rtx, rtx), rtx reg, HOST_WIDE_INT cfa_off,\n \t  off = current_frame_info.total_size - cfa_off;\n \t}\n \n-      REG_NOTES (insn)\n-\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_MEM (GET_MODE (reg),\n-\t\t\t\t\t  plus_constant (base, off)),\n-\t\t\t     frame_reg),\n-\t\tREG_NOTES (insn));\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t    gen_rtx_SET (VOIDmode,\n+\t\t\t\t gen_rtx_MEM (GET_MODE (reg),\n+\t\t\t\t\t      plus_constant (base, off)),\n+\t\t\t\t frame_reg));\n     }\n }\n \n@@ -3095,16 +3090,12 @@ ia64_expand_prologue (void)\n \t{\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  if (GET_CODE (offset) != CONST_INT)\n-\t    {\n-\t      REG_NOTES (insn)\n-\t\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t     gen_rtx_PLUS (DImode,\n-\t\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t\t   frame_size_rtx)),\n-\t\t\tREG_NOTES (insn));\n-\t    }\n+\t    add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t  gen_rtx_SET (VOIDmode,\n+\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t       gen_rtx_PLUS (DImode,\n+\t\t\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t\t\t     frame_size_rtx)));\n \t}\n \n       /* ??? At this point we must generate a magic insn that appears to\n@@ -3171,10 +3162,8 @@ ia64_expand_prologue (void)\n \t  /* ??? Denote pr spill/fill by a DImode move that modifies all\n \t     64 hard registers.  */\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  REG_NOTES (insn)\n-\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\tgen_rtx_SET (VOIDmode, alt_reg, reg),\n-\t\t\tREG_NOTES (insn));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_rtx_SET (VOIDmode, alt_reg, reg));\n \n \t  /* Even if we're not going to generate an epilogue, we still\n \t     need to save the register so that EH works.  */\n@@ -3533,16 +3522,12 @@ ia64_expand_epilogue (int sibcall_p)\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n       if (GET_CODE (offset) != CONST_INT)\n-\t{\n-\t  REG_NOTES (insn)\n-\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t     gen_rtx_PLUS (DImode,\n-\t\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t\t   frame_size_rtx)),\n-\t\t\tREG_NOTES (insn));\n-\t}\n+\tadd_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t      gen_rtx_SET (VOIDmode,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   gen_rtx_PLUS (DImode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t frame_size_rtx)));\n     }\n \n   if (cfun->machine->ia64_eh_epilogue_bsp)\n@@ -7931,7 +7916,7 @@ insert_bundle_state (struct bundle_state *bundle_state)\n {\n   void **entry_ptr;\n \n-  entry_ptr = htab_find_slot (bundle_state_table, bundle_state, 1);\n+  entry_ptr = htab_find_slot (bundle_state_table, bundle_state, INSERT);\n   if (*entry_ptr == NULL)\n     {\n       bundle_state->next = index_to_bundle_states [bundle_state->insn_num];\n@@ -8295,9 +8280,7 @@ ia64_add_bundle_selector_before (int template0, rtx insn)\n \t      if (find_reg_note (insn, REG_EH_REGION, NULL_RTX))\n \t\tnote = NULL_RTX;\n \t      else\n-\t\tREG_NOTES (insn)\n-\t\t  = gen_rtx_EXPR_LIST (REG_EH_REGION, XEXP (note, 0),\n-\t\t\t\t       REG_NOTES (insn));\n+\t\tadd_reg_note (insn, REG_EH_REGION, XEXP (note, 0));\n \t    }\n \t}\n     }"}, {"sha": "51a01e4e15e0b02348eec0251ae0bd4fca61d3af", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n ;; IA-64 Machine description template\n-;; Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n-;; Free Software Foundation, Inc.\n+;; Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+;; 2009 Free Software Foundation, Inc.\n ;; Contributed by James E. Wilson <wilson@cygnus.com> and\n ;;\t\t  David Mosberger <davidm@hpl.hp.com>.\n \n@@ -116,7 +116,8 @@\n \n ;; Processor type.  This attribute must exactly match the processor_type\n ;; enumeration in ia64.h.\n-(define_attr \"cpu\" \"itanium,itanium2\" (const (symbol_ref \"ia64_tune\")))\n+(define_attr \"cpu\" \"itanium,itanium2\"\n+  (const (symbol_ref \"((enum attr_cpu) ia64_tune)\")))\n \n ;; Instruction type.  This primarily determines how instructions can be\n ;; packed in bundles, and secondarily affects scheduling to function units.\n@@ -6076,7 +6077,7 @@\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t\t \\\"__ia64_save_stack_nonlocal\\\"),\n-\t\t     0, VOIDmode, 2, XEXP (operands[0], 0), Pmode,\n+\t\t     LCT_NORMAL, VOIDmode, 2, XEXP (operands[0], 0), Pmode,\n \t\t     operands[1], Pmode);\n   DONE;\n })\n@@ -6154,7 +6155,7 @@\n {\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t\t\t \"__ia64_restore_stack_nonlocal\"),\n-\t\t     0, VOIDmode, 1,\n+\t\t     LCT_NORMAL, VOIDmode, 1,\n \t\t     copy_to_reg (XEXP (operands[1], 0)), Pmode);\n   DONE;\n })"}, {"sha": "8e3cdcfa6d8e5b96b1597b3a854ff3e73bd9d3ec", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -3312,7 +3312,7 @@ mips_binary_cost (rtx x, int single_cost, int double_cost)\n   else\n     cost = single_cost;\n   return (cost\n-\t  + rtx_cost (XEXP (x, 0), 0, !optimize_size)\n+\t  + rtx_cost (XEXP (x, 0), SET, !optimize_size)\n \t  + rtx_cost (XEXP (x, 1), GET_CODE (x), !optimize_size));\n }\n \n@@ -3531,7 +3531,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t  && UINTVAL (XEXP (x, 1)) == 0xffffffff)\n \t{\n \t  *total = (mips_zero_extend_cost (mode, XEXP (x, 0))\n-\t\t    + rtx_cost (XEXP (x, 0), 0, speed));\n+\t\t    + rtx_cost (XEXP (x, 0), SET, speed));\n \t  return true;\n \t}\n       /* Fall through.  */\n@@ -3563,7 +3563,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total,\n     case LO_SUM:\n       /* Low-part immediates need an extended MIPS16 instruction.  */\n       *total = (COSTS_N_INSNS (TARGET_MIPS16 ? 2 : 1)\n-\t\t+ rtx_cost (XEXP (x, 0), 0, speed));\n+\t\t+ rtx_cost (XEXP (x, 0), SET, speed));\n       return true;\n \n     case LT:\n@@ -3603,17 +3603,17 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t  if (GET_CODE (op0) == MULT && GET_CODE (XEXP (op0, 0)) == NEG)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op0, 0), 0), 0, speed)\n-\t\t\t+ rtx_cost (XEXP (op0, 1), 0, speed)\n-\t\t\t+ rtx_cost (op1, 0, speed));\n+\t\t\t+ rtx_cost (XEXP (XEXP (op0, 0), 0), SET, speed)\n+\t\t\t+ rtx_cost (XEXP (op0, 1), SET, speed)\n+\t\t\t+ rtx_cost (op1, SET, speed));\n \t      return true;\n \t    }\n \t  if (GET_CODE (op1) == MULT)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (op0, 0, speed)\n-\t\t\t+ rtx_cost (XEXP (op1, 0), 0, speed)\n-\t\t\t+ rtx_cost (XEXP (op1, 1), 0, speed));\n+\t\t\t+ rtx_cost (op0, SET, speed)\n+\t\t\t+ rtx_cost (XEXP (op1, 0), SET, speed)\n+\t\t\t+ rtx_cost (XEXP (op1, 1), SET, speed));\n \t      return true;\n \t    }\n \t}\n@@ -3654,9 +3654,9 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t      && GET_CODE (XEXP (op, 0)) == MULT)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 0), 0, speed)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 1), 0, speed)\n-\t\t\t+ rtx_cost (XEXP (op, 1), 0, speed));\n+\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 0), SET, speed)\n+\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 1), SET, speed)\n+\t\t\t+ rtx_cost (XEXP (op, 1), SET, speed));\n \t      return true;\n \t    }\n \t}\n@@ -3694,9 +3694,10 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t  if (outer_code == SQRT || GET_CODE (XEXP (x, 1)) == SQRT)\n \t    /* An rsqrt<mode>a or rsqrt<mode>b pattern.  Count the\n \t       division as being free.  */\n-\t    *total = rtx_cost (XEXP (x, 1), 0, speed);\n+\t    *total = rtx_cost (XEXP (x, 1), SET, speed);\n \t  else\n-\t    *total = mips_fp_div_cost (mode) + rtx_cost (XEXP (x, 1), 0, speed);\n+\t    *total = (mips_fp_div_cost (mode)\n+\t\t      + rtx_cost (XEXP (x, 1), SET, speed));\n \t  return true;\n \t}\n       /* Fall through.  */\n@@ -3724,7 +3725,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t      && CONST_INT_P (XEXP (x, 1))\n \t      && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n \t    {\n-\t      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), 0, speed);\n+\t      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), SET, speed);\n \t      return true;\n \t    }\n \t  *total = COSTS_N_INSNS (mips_idiv_insns ());\n@@ -14465,8 +14466,8 @@ mips_override_options (void)\n   /* Set up mips_hard_regno_mode_ok.  */\n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n     for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-      mips_hard_regno_mode_ok[(int)mode][regno]\n-\t= mips_hard_regno_mode_ok_p (regno, mode);\n+      mips_hard_regno_mode_ok[mode][regno]\n+\t= mips_hard_regno_mode_ok_p (regno, (enum machine_mode) mode);\n \n   /* Function to allocate machine-dependent function status.  */\n   init_machine_status = &mips_init_machine_status;"}, {"sha": "30faa196a52660a5132c0a8d6a7416e309ed9210", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -2441,7 +2441,7 @@ typedef struct mips_args {\n   /* Flush both caches.  We need to flush the data cache in case\t\\\n      the system has a write-back cache.  */\t\t\t\t\\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mips_cache_flush_func),\t\\\n-\t\t     0, VOIDmode, 3, ADDR, Pmode, SIZE, Pmode,\t\t\\\n+\t\t     LCT_NORMAL, VOIDmode, 3, ADDR, Pmode, SIZE, Pmode,\t\\\n \t\t     GEN_INT (3), TYPE_MODE (integer_type_node))\n \n /* A C statement to initialize the variable parts of a trampoline."}, {"sha": "adaaa25e6cde7d4a9c97006cb04206be5be9aa81", "filename": "gcc/config/mips/sdemtk.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fmips%2Fsdemtk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fmips%2Fsdemtk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsdemtk.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.\n    MIPS SDE version, for use with the SDE C library rather than newlib.\n-   Copyright (C) 2007, 2008\n+   Copyright (C) 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -86,7 +86,7 @@ extern void mips_sync_icache (void *beg, unsigned long len);\n #undef MIPS_ICACHE_SYNC\n #define MIPS_ICACHE_SYNC(ADDR, SIZE)\t\t\t\t\t\\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mips_cache_flush_func),\t\\\n-\t\t     0, VOIDmode, 2, ADDR, Pmode,\t\t\t\\\n+\t\t     LCT_NORMAL, VOIDmode, 2, ADDR, Pmode,\t\t\\\n \t\t     SIZE, TYPE_MODE (sizetype))\n \n /* This version of _mcount does not pop 2 words from the stack.  */"}, {"sha": "0f42d6bd98cdd7047cd4bc37dd50b22fa70e246f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -684,7 +684,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       insn = emit_insn (gen_rtx_SET (VOIDmode, reg, orig));\n \n       /* Put a REG_EQUAL note on this insn, so that it can be optimized.  */\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig, REG_NOTES (insn));\n+      add_reg_note (insn, REG_EQUAL, orig);\n \n       /* During and after reload, we need to generate a REG_LABEL_OPERAND note\n \t and update LABEL_NUSES because this is not done automatically.  */\n@@ -3395,11 +3395,9 @@ store_reg (int reg, HOST_WIDE_INT disp, int base)\n       insn = emit_move_insn (tmpreg, gen_rtx_PLUS (Pmode, tmpreg, basereg));\n       if (DO_FRAME_NOTES)\n \t{\n-\t  REG_NOTES (insn)\n-\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (VOIDmode, tmpreg,\n-\t\t\t     gen_rtx_PLUS (Pmode, basereg, delta)),\n-                REG_NOTES (insn));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_rtx_SET (VOIDmode, tmpreg,\n+\t\t\t\t     gen_rtx_PLUS (Pmode, basereg, delta)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       dest = gen_rtx_MEM (word_mode, tmpreg);\n@@ -3415,16 +3413,13 @@ store_reg (int reg, HOST_WIDE_INT disp, int base)\n       dest = gen_rtx_MEM (word_mode, gen_rtx_LO_SUM (Pmode, tmpreg, delta));\n       insn = emit_move_insn (dest, src);\n       if (DO_FRAME_NOTES)\n-\t{\n-\t  REG_NOTES (insn)\n-\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_MEM (word_mode,\n-\t\t\t\t\t  gen_rtx_PLUS (word_mode, basereg,\n-\t\t\t\t\t\t\tdelta)),\n-                             src),\n-                REG_NOTES (insn));\n-\t}\n+\tadd_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t      gen_rtx_SET (VOIDmode,\n+\t\t\t\t   gen_rtx_MEM (word_mode,\n+\t\t\t\t\t\tgen_rtx_PLUS (word_mode,\n+\t\t\t\t\t\t\t      basereg,\n+\t\t\t\t\t\t\t      delta)),\n+\t\t\t\t   src));\n     }\n \n   if (DO_FRAME_NOTES)\n@@ -3484,11 +3479,9 @@ set_reg_plus_d (int reg, int base, HOST_WIDE_INT disp, int note)\n       insn = emit_move_insn (gen_rtx_REG (Pmode, reg),\n \t\t\t     gen_rtx_PLUS (Pmode, tmpreg, basereg));\n       if (DO_FRAME_NOTES)\n-\tREG_NOTES (insn)\n-\t  = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t      gen_rtx_SET (VOIDmode, tmpreg,\n-\t\t\t   gen_rtx_PLUS (Pmode, basereg, delta)),\n-\t      REG_NOTES (insn));\n+\tadd_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t      gen_rtx_SET (VOIDmode, tmpreg,\n+\t\t\t\t   gen_rtx_PLUS (Pmode, basereg, delta)));\n     }\n   else\n     {\n@@ -3912,10 +3905,8 @@ hppa_expand_prologue (void)\n \t\t    {\n \t\t      rtx mem = gen_rtx_MEM (DFmode,\n \t\t\t\t\t     plus_constant (base, offset));\n-\t\t      REG_NOTES (insn)\n-\t\t\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t     gen_rtx_SET (VOIDmode, mem, reg),\n-\t\t\t\t\t     REG_NOTES (insn));\n+\t\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t\t    gen_rtx_SET (VOIDmode, mem, reg));\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -3932,10 +3923,8 @@ hppa_expand_prologue (void)\n \t\t      RTX_FRAME_RELATED_P (setl) = 1;\n \t\t      RTX_FRAME_RELATED_P (setr) = 1;\n \t\t      vec = gen_rtvec (2, setl, setr);\n-\t\t      REG_NOTES (insn)\n-\t\t\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t     gen_rtx_SEQUENCE (VOIDmode, vec),\n-\t\t\t\t\t     REG_NOTES (insn));\n+\t\t      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t\t    gen_rtx_SEQUENCE (VOIDmode, vec));\n \t\t    }\n \t\t}\n \t      offset += GET_MODE_SIZE (DFmode);\n@@ -4353,8 +4342,7 @@ hppa_profile_hook (int label_no)\n \n   /* Indicate the _mcount call cannot throw, nor will it execute a\n      non-local goto.  */\n-  REG_NOTES (call_insn)\n-    = gen_rtx_EXPR_LIST (REG_EH_REGION, constm1_rtx, REG_NOTES (call_insn));\n+  add_reg_note (call_insn, REG_EH_REGION, constm1_rtx);\n }\n \n /* Fetch the return address for the frame COUNT steps up from"}, {"sha": "ebcb11116aa32bf94650c4477788aa61f5e783b2", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for the C front end on the POWER and PowerPC architectures.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n    Contributed by Zack Weinberg <zack@codesourcery.com>\n@@ -2993,13 +2993,15 @@ altivec_build_resolved_builtin (tree *args, int n,\n    support Altivec's overloaded builtins.  */\n \n tree\n-altivec_resolve_overloaded_builtin (tree fndecl, tree arglist)\n+altivec_resolve_overloaded_builtin (tree fndecl, void *passed_arglist)\n {\n+  VEC(tree,gc) *arglist = (VEC(tree,gc) *) passed_arglist;\n+  unsigned int nargs = VEC_length (tree, arglist);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   tree fnargs = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n   tree types[3], args[3];\n   const struct altivec_builtin_types *desc;\n-  int n;\n+  unsigned int n;\n \n   if (fcode < ALTIVEC_BUILTIN_OVERLOADED_FIRST\n       || fcode > ALTIVEC_BUILTIN_OVERLOADED_LAST)\n@@ -3016,33 +3018,27 @@ altivec_resolve_overloaded_builtin (tree fndecl, tree arglist)\n       VEC(constructor_elt,gc) *vec;\n       const char *name = fcode == ALTIVEC_BUILTIN_VEC_SPLATS ? \"vec_splats\": \"vec_promote\";\n \n-      if (!arglist)\n+      if (nargs == 0)\n \t{\n \t  error (\"%s only accepts %d arguments\", name, (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE)+1 );\n \t  return error_mark_node;\n \t}\n-      if (fcode == ALTIVEC_BUILTIN_VEC_SPLATS && TREE_CHAIN (arglist))\n+      if (fcode == ALTIVEC_BUILTIN_VEC_SPLATS && nargs != 1)\n \t{\n \t  error (\"%s only accepts 1 argument\", name);\n \t  return error_mark_node;\n \t}\n-      if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE && !TREE_CHAIN (arglist))\n+      if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE && nargs != 2)\n \t{\n \t  error (\"%s only accepts 2 arguments\", name);\n \t  return error_mark_node;\n \t}\n       /* Ignore promote's element argument.  */\n       if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE\n-\t  && TREE_CHAIN (TREE_CHAIN (arglist)))\n-\t{\n-\t  error (\"%s only accepts 2 arguments\", name);\n-\t  return error_mark_node;\n-\t}\n-      if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE\n-\t  && !INTEGRAL_TYPE_P (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))))\n+\t  && !INTEGRAL_TYPE_P (TREE_TYPE (VEC_index (tree, arglist, 1))))\n \tgoto bad;\n \n-      arg = TREE_VALUE (arglist);\n+      arg = VEC_index (tree, arglist, 0);\n       type = TREE_TYPE (arg);\n       if (!SCALAR_FLOAT_TYPE_P (type)\n \t  && !INTEGRAL_TYPE_P (type))\n@@ -3093,15 +3089,14 @@ altivec_resolve_overloaded_builtin (tree fndecl, tree arglist)\n       tree innerptrtype;\n \n       /* No second argument. */\n-      if (!arglist || !TREE_CHAIN (arglist)\n-\t  || TREE_CHAIN (TREE_CHAIN (arglist)))\n+      if (nargs != 2)\n \t{\n \t  error (\"vec_extract only accepts 2 arguments\");\n \t  return error_mark_node;\n \t}\n \n-      arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg1 = TREE_VALUE (arglist);\n+      arg2 = VEC_index (tree, arglist, 1);\n+      arg1 = VEC_index (tree, arglist, 0);\n       arg1_type = TREE_TYPE (arg1);\n \n       if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n@@ -3149,18 +3144,16 @@ altivec_resolve_overloaded_builtin (tree fndecl, tree arglist)\n       tree innerptrtype;\n       \n       /* No second or third arguments. */\n-      if (!arglist || !TREE_CHAIN (arglist)\n-\t  || !TREE_CHAIN (TREE_CHAIN (arglist))\n-\t  || TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))))\n+      if (nargs != 3)\n \t{\n \t  error (\"vec_insert only accepts 3 arguments\");\n \t  return error_mark_node;\n \t}\n \n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = VEC_index (tree, arglist, 0);\n+      arg1 = VEC_index (tree, arglist, 1);\n       arg1_type = TREE_TYPE (arg1);\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg2 = VEC_index (tree, arglist, 2);\n \n       if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n \tgoto bad; \n@@ -3198,11 +3191,11 @@ altivec_resolve_overloaded_builtin (tree fndecl, tree arglist)\n     }\n \n   for (n = 0;\n-       !VOID_TYPE_P (TREE_VALUE (fnargs)) && arglist;\n-       fnargs = TREE_CHAIN (fnargs), arglist = TREE_CHAIN (arglist), n++)\n+       !VOID_TYPE_P (TREE_VALUE (fnargs)) && n < nargs;\n+       fnargs = TREE_CHAIN (fnargs), n++)\n     {\n       tree decl_type = TREE_VALUE (fnargs);\n-      tree arg = TREE_VALUE (arglist);\n+      tree arg = VEC_index (tree, arglist, n);\n       tree type;\n \n       if (arg == error_mark_node)\n@@ -3248,7 +3241,7 @@ altivec_resolve_overloaded_builtin (tree fndecl, tree arglist)\n \n   /* If the number of arguments did not match the prototype, return NULL\n      and the generic code will issue the appropriate error message.  */\n-  if (!VOID_TYPE_P (TREE_VALUE (fnargs)) || arglist)\n+  if (!VOID_TYPE_P (TREE_VALUE (fnargs)) || nargs > 0)\n     return NULL;\n \n   if (n == 0)\n@@ -3281,4 +3274,3 @@ altivec_resolve_overloaded_builtin (tree fndecl, tree arglist)\n   error (\"invalid parameter combination for AltiVec intrinsic\");\n   return error_mark_node;\n }\n-"}, {"sha": "c898d51e3a3c655c6cfddb311bc94610c813ed02", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -134,7 +134,7 @@ extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, int, int);\n extern int function_arg_boundary (enum machine_mode, tree);\n extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n-extern tree altivec_resolve_overloaded_builtin (tree, tree);\n+extern tree altivec_resolve_overloaded_builtin (tree, void *);\n extern rtx rs6000_function_value (const_tree, const_tree);\n extern rtx rs6000_libcall_value (enum machine_mode);\n extern rtx rs6000_va_arg (tree, tree);"}, {"sha": "69ef4d209cfdb1d601213ed81e394d829f6a03d3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1346,7 +1346,7 @@ rs6000_init_hard_regno_mode_ok (void)\n \n   for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n     for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-      if (rs6000_hard_regno_mode_ok (r, m))\n+      if (rs6000_hard_regno_mode_ok (r, (enum machine_mode) m))\n \trs6000_hard_regno_mode_ok_p[m][r] = true;\n }\n \n@@ -8560,8 +8560,8 @@ altivec_expand_vec_set_builtin (tree exp)\n   mode1 = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));\n   gcc_assert (VECTOR_MODE_P (tmode));\n \n-  op0 = expand_expr (arg0, NULL_RTX, tmode, 0);\n-  op1 = expand_expr (arg1, NULL_RTX, mode1, 0);\n+  op0 = expand_expr (arg0, NULL_RTX, tmode, EXPAND_NORMAL);\n+  op1 = expand_expr (arg1, NULL_RTX, mode1, EXPAND_NORMAL);\n   elt = get_element_number (TREE_TYPE (arg0), arg2);\n \n   if (GET_MODE (op1) != mode1 && GET_MODE (op1) != VOIDmode)\n@@ -14035,7 +14035,7 @@ emit_unlikely_jump (rtx cond, rtx label)\n \n   x = gen_rtx_IF_THEN_ELSE (VOIDmode, cond, label, pc_rtx);\n   x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n-  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n+  add_reg_note (x, REG_BR_PROB, very_unlikely);\n }\n \n /* A subroutine of the atomic operation splitters.  Emit a load-locked\n@@ -15628,12 +15628,10 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12, int copy_r11)\n   set_mem_alias_set (mem, get_frame_alias_set ());\n \n   RTX_FRAME_RELATED_P (insn) = 1;\n-  REG_NOTES (insn) =\n-    gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t       gen_rtx_SET (VOIDmode, stack_reg,\n-\t\t\t\t    gen_rtx_PLUS (Pmode, stack_reg,\n-\t\t\t\t\t\t  GEN_INT (-size))),\n-\t\t       REG_NOTES (insn));\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\tgen_rtx_SET (VOIDmode, stack_reg,\n+\t\t\t     gen_rtx_PLUS (Pmode, stack_reg,\n+\t\t\t\t\t   GEN_INT (-size))));\n }\n \n /* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced\n@@ -15714,9 +15712,7 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n     }\n \n   RTX_FRAME_RELATED_P (insn) = 1;\n-  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\treal,\n-\t\t\t\t\tREG_NOTES (insn));\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR, real);\n }\n \n /* Returns an insn that has a vrsave set operation with the\n@@ -16341,9 +16337,7 @@ rs6000_emit_prologue (void)\n \t We use CR2_REGNO (70) to be compatible with gcc-2.95 on Linux.  */\n       set = gen_rtx_SET (VOIDmode, cr_save_rtx,\n \t\t\t gen_rtx_REG (SImode, CR2_REGNO));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t    set,\n-\t\t\t\t\t    REG_NOTES (insn));\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, set);\n     }\n \n   /* Do any required saving of fpr's.  If only one or two to save, do\n@@ -16599,10 +16593,7 @@ rs6000_emit_prologue (void)\n \t  insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  set = gen_rtx_SET (VOIDmode, cr_save_rtx, magic_eh_cr_reg);\n-\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t\tset,\n-\t\t\t\t\t\tREG_NOTES (insn));\n-\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, set);\n \t}\n       insn = emit_move_insn (mem, cr_save_rtx);\n \n@@ -18132,7 +18123,7 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n       h->key_mode = mode;\n       h->labelno = labelno;\n \n-      found = htab_find_slot (toc_hash_table, h, 1);\n+      found = htab_find_slot (toc_hash_table, h, INSERT);\n       if (*found == NULL)\n \t*found = h;\n       else  /* This is indeed a duplicate.\n@@ -18553,7 +18544,8 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n # define NO_PROFILE_COUNTERS 0\n #endif\n       if (NO_PROFILE_COUNTERS)\n-\temit_library_call (init_one_libfunc (RS6000_MCOUNT), 0, VOIDmode, 0);\n+\temit_library_call (init_one_libfunc (RS6000_MCOUNT),\n+\t\t\t   LCT_NORMAL, VOIDmode, 0);\n       else\n \t{\n \t  char buf[30];\n@@ -18564,8 +18556,8 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n \t  label_name = (*targetm.strip_name_encoding) (ggc_strdup (buf));\n \t  fun = gen_rtx_SYMBOL_REF (Pmode, label_name);\n \n-\t  emit_library_call (init_one_libfunc (RS6000_MCOUNT), 0, VOIDmode, 1,\n-\t\t\t     fun, Pmode);\n+\t  emit_library_call (init_one_libfunc (RS6000_MCOUNT),\n+\t\t\t     LCT_NORMAL, VOIDmode, 1, fun, Pmode);\n \t}\n     }\n   else if (DEFAULT_ABI == ABI_DARWIN)\n@@ -18584,7 +18576,7 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n \tcaller_addr_regno = 0;\n #endif\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mcount_name),\n-\t\t\t 0, VOIDmode, 1,\n+\t\t\t LCT_NORMAL, VOIDmode, 1,\n \t\t\t gen_rtx_REG (Pmode, caller_addr_regno), Pmode);\n     }\n }\n@@ -20487,7 +20479,7 @@ rs6000_initialize_trampoline (rtx addr, rtx fnaddr, rtx cxt)\n     case ABI_DARWIN:\n     case ABI_V4:\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__trampoline_setup\"),\n-\t\t\t FALSE, VOIDmode, 4,\n+\t\t\t LCT_NORMAL, VOIDmode, 4,\n \t\t\t addr, Pmode,\n \t\t\t GEN_INT (rs6000_trampoline_size ()), SImode,\n \t\t\t fnaddr, Pmode,\n@@ -22730,7 +22722,7 @@ rs6000_init_dwarf_reg_sizes_extra (tree address)\n     {\n       int i;\n       enum machine_mode mode = TYPE_MODE (char_type_node);\n-      rtx addr = expand_expr (address, NULL_RTX, VOIDmode, 0);\n+      rtx addr = expand_expr (address, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n       rtx mem = gen_rtx_MEM (BLKmode, addr);\n       rtx value = gen_int_mode (4, mode);\n "}, {"sha": "5c1f1b17f2b096b7e0cb4c0f937cc42c818b3ee8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on IBM S/390 and zSeries\n    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,\n-   2007, 2008 Free Software Foundation, Inc.\n+   2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n                   Ulrich Weigand (uweigand@de.ibm.com) and\n                   Andreas Krebbel (Andreas.Krebbel@de.ibm.com).\n@@ -2320,9 +2320,9 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t    *total = s390_cost->madbr;\n \t  else\n \t    *total = s390_cost->maebr;\n-\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), MULT, speed) \n-\t    + rtx_cost (XEXP (XEXP (x, 0), 1), MULT, speed) \n-\t    + rtx_cost (XEXP (x, 1), code, speed);\n+\t  *total += (rtx_cost (XEXP (XEXP (x, 0), 0), MULT, speed)\n+\t\t     + rtx_cost (XEXP (XEXP (x, 0), 1), MULT, speed)\n+\t\t     + rtx_cost (XEXP (x, 1), (enum rtx_code) code, speed));\n \t  return true;  /* Do not do an additional recursive descent.  */\n \t}\n       *total = COSTS_N_INSNS (1);\n@@ -3909,11 +3909,13 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n       dst = change_address (dst, VOIDmode, dst_addr);\n       src = change_address (src, VOIDmode, src_addr);\n \n-      temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n+      temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1,\n+\t\t\t   OPTAB_DIRECT);\n       if (temp != count)\n         emit_move_insn (count, temp);\n \n-      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1, 0);\n+      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1,\n+\t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n@@ -3928,7 +3930,8 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n       s390_load_address (src_addr,\n \t\t\t gen_rtx_PLUS (Pmode, src_addr, GEN_INT (256)));\n \n-      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n+      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1,\n+\t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n@@ -4011,7 +4014,8 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n       dst = change_address (dst, VOIDmode, dst_addr);\n \n       if (val == const0_rtx)\n-        temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n+        temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1,\n+\t\t\t     OPTAB_DIRECT);\n       else\n \t{\n \t  dstp1 = adjust_address (dst, VOIDmode, 1);\n@@ -4024,12 +4028,14 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n \t  emit_cmp_and_jump_insns (count, const1_rtx,\n \t\t\t\t   EQ, NULL_RTX, mode, 1, end_label);\n \n-\t  temp = expand_binop (mode, add_optab, count, GEN_INT (-2), count, 1, 0);\n+\t  temp = expand_binop (mode, add_optab, count, GEN_INT (-2), count, 1,\n+\t\t\t       OPTAB_DIRECT);\n \t}\n       if (temp != count)\n         emit_move_insn (count, temp);\n \n-      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1, 0);\n+      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1,\n+\t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n@@ -4045,7 +4051,8 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n       s390_load_address (dst_addr,\n \t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n \n-      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n+      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1,\n+\t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n@@ -4117,11 +4124,13 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n       op0 = change_address (op0, VOIDmode, addr0);\n       op1 = change_address (op1, VOIDmode, addr1);\n \n-      temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);\n+      temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1,\n+\t\t\t   OPTAB_DIRECT);\n       if (temp != count)\n         emit_move_insn (count, temp);\n \n-      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1, 0);\n+      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1,\n+\t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n@@ -4142,7 +4151,8 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n       s390_load_address (addr1,\n \t\t\t gen_rtx_PLUS (Pmode, addr1, GEN_INT (256)));\n \n-      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);\n+      temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1,\n+\t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n@@ -7490,9 +7500,7 @@ save_gprs (rtx base, int offset, int first, int last)\n \t\t\t\t GEN_INT (last - 6 + 1));\n       note = PATTERN (note);\n \n-      REG_NOTES (insn) =\n-\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t   note, REG_NOTES (insn));\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);\n \n       for (i = 0; i < XVECLEN (note, 0); i++)\n \tif (GET_CODE (XVECEXP (note, 0, i)) == SET)\n@@ -7704,6 +7712,7 @@ s390_emit_prologue (void)\n   if (cfun_frame_layout.frame_size > 0)\n     {\n       rtx frame_off = GEN_INT (-cfun_frame_layout.frame_size);\n+      rtx real_frame_off;\n \n       if (s390_stack_size)\n   \t{\n@@ -7781,12 +7790,11 @@ s390_emit_prologue (void)\n \t}\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n-      REG_NOTES (insn) =\n-\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t   gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t     gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t       GEN_INT (-cfun_frame_layout.frame_size))),\n-\t\t\t   REG_NOTES (insn));\n+      real_frame_off = GEN_INT (-cfun_frame_layout.frame_size);\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t    gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t       real_frame_off)));\n \n       /* Set backchain.  */\n \n@@ -7838,12 +7846,10 @@ s390_emit_prologue (void)\n \t    insn = save_fpr (temp_reg, offset, i);\n \t    offset += 8;\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t    REG_NOTES (insn) =\n-\t      gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t      gen_rtx_MEM (DFmode, addr),\n-\t\t\t\t\t      gen_rtx_REG (DFmode, i)),\n-\t\t\t\t REG_NOTES (insn));\n+\t    add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t  gen_rtx_SET (VOIDmode,\n+\t\t\t\t       gen_rtx_MEM (DFmode, addr),\n+\t\t\t\t       gen_rtx_REG (DFmode, i)));\n \t  }\n     }\n \n@@ -8725,7 +8731,7 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n       insn_op = &insn_data[icode].operand[arity + nonvoid];\n \n-      op[arity] = expand_expr (arg, NULL_RTX, insn_op->mode, 0);\n+      op[arity] = expand_expr (arg, NULL_RTX, insn_op->mode, EXPAND_NORMAL);\n \n       if (!(*insn_op->predicate) (op[arity], insn_op->mode))\n \top[arity] = copy_to_mode_reg (insn_op->mode, op[arity]);"}, {"sha": "62d025f4cebddb3053d53248646cd29f4e80bbad", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for SPARC.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n    64-bit SPARC-V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n@@ -4082,10 +4082,8 @@ sparc_expand_prologue (void)\n \t  rtx reg = gen_rtx_REG (Pmode, 1);\n \t  emit_move_insn (reg, GEN_INT (-actual_fsize));\n \t  insn = emit_insn (gen_stack_pointer_inc (reg));\n-\t  REG_NOTES (insn) =\n-\t    gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t       gen_stack_pointer_inc (GEN_INT (-actual_fsize)),\n-\t\t\t       REG_NOTES (insn));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_stack_pointer_inc (GEN_INT (-actual_fsize)));\n \t}\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -8255,13 +8253,14 @@ sparc_fold_builtin (tree fndecl, tree arglist, bool ignore)\n {\n   tree arg0, arg1, arg2;\n   tree rtype = TREE_TYPE (TREE_TYPE (fndecl));\n+  enum insn_code icode = (enum insn_code) DECL_FUNCTION_CODE (fndecl);\n \n   if (ignore\n-      && DECL_FUNCTION_CODE (fndecl) != CODE_FOR_alignaddrsi_vis\n-      && DECL_FUNCTION_CODE (fndecl) != CODE_FOR_alignaddrdi_vis)\n+      && icode != CODE_FOR_alignaddrsi_vis\n+      && icode != CODE_FOR_alignaddrdi_vis)\n     return fold_convert (rtype, integer_zero_node);\n \n-  switch (DECL_FUNCTION_CODE (fndecl))\n+  switch (icode)\n     {\n     case CODE_FOR_fexpand_vis:\n       arg0 = TREE_VALUE (arglist);\n@@ -8297,8 +8296,8 @@ sparc_fold_builtin (tree fndecl, tree arglist, bool ignore)\n \t  tree inner_type = TREE_TYPE (rtype);\n \t  tree elts0 = TREE_VECTOR_CST_ELTS (arg0);\n \t  tree elts1 = TREE_VECTOR_CST_ELTS (arg1);\n-\t  tree n_elts = sparc_handle_vis_mul8x16 (DECL_FUNCTION_CODE (fndecl),\n-\t\t\t\t\t\t  inner_type, elts0, elts1);\n+\t  tree n_elts = sparc_handle_vis_mul8x16 (icode, inner_type, elts0,\n+\t\t\t\t\t\t  elts1);\n \n \t  return build_vector (rtype, n_elts);\n \t}"}, {"sha": "2ae57ba44c050b16fc28027d52a2c4ddb646648b", "filename": "gcc/config/spu/spu-c.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fspu%2Fspu-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fspu%2Fspu-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-c.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n    This file is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License as published by the Free\n@@ -96,11 +96,13 @@ spu_macro_to_expand (cpp_reader *pfile, const cpp_token *tok)\n /* target hook for resolve_overloaded_builtin(). Returns a function call\n    RTX if we can resolve the overloaded builtin */\n tree\n-spu_resolve_overloaded_builtin (tree fndecl, tree fnargs)\n+spu_resolve_overloaded_builtin (tree fndecl, void *passed_args)\n {\n #define SCALAR_TYPE_P(t) (INTEGRAL_TYPE_P (t) \\\n \t\t\t  || SCALAR_FLOAT_TYPE_P (t) \\\n \t\t\t  || POINTER_TYPE_P (t))\n+  VEC(tree,gc) *fnargs = (VEC(tree,gc) *) passed_args;\n+  unsigned int nargs = VEC_length (tree, fnargs);\n   spu_function_code new_fcode, fcode =\n     DECL_FUNCTION_CODE (fndecl) - END_BUILTINS;\n   struct spu_builtin_description *desc;\n@@ -121,23 +123,23 @@ spu_resolve_overloaded_builtin (tree fndecl, tree fnargs)\n     {\n       tree decl = spu_builtins[new_fcode].fndecl;\n       tree params = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-      tree arg, param;\n-      int p;\n+      tree param;\n+      unsigned int p;\n \n-      for (param = params, arg = fnargs, p = 0;\n+      for (param = params, p = 0;\n \t   param != void_list_node;\n-\t   param = TREE_CHAIN (param), arg = TREE_CHAIN (arg), p++)\n+\t   param = TREE_CHAIN (param), p++)\n \t{\n \t  tree var, arg_type, param_type = TREE_VALUE (param);\n \n-\t  if (!arg)\n+\t  if (p < nargs)\n \t    {\n \t      error (\"insufficient arguments to overloaded function %s\",\n \t\t     desc->name);\n \t      return error_mark_node;\n \t    }\n \n-\t  var = TREE_VALUE (arg);\n+\t  var = VEC_index (tree, fnargs, p);\n \n \t  if (TREE_CODE (var) == NON_LVALUE_EXPR)\n \t    var = TREE_OPERAND (var, 0);\n@@ -165,7 +167,7 @@ spu_resolve_overloaded_builtin (tree fndecl, tree fnargs)\n \t}\n       if (param == void_list_node)\n \t{\n-\t  if (arg)\n+\t  if (p != nargs)\n \t    {\n \t      error (\"too many arguments to overloaded function %s\",\n \t\t     desc->name);\n@@ -184,7 +186,7 @@ spu_resolve_overloaded_builtin (tree fndecl, tree fnargs)\n       return error_mark_node;\n     }\n \n-  return build_function_call (match, fnargs);\n+  return build_function_call_vec (match, fnargs, NULL);\n #undef SCALAR_TYPE_P\n }\n "}, {"sha": "07eb654c7f3f622349111fc6a8e6e5fedb7a6093", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n    This file is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License as published by the Free\n@@ -90,7 +90,7 @@ extern void spu_expand_vector_init (rtx target, rtx vals);\n extern void spu_init_expanders (void);\n \n /* spu-c.c */\n-extern tree spu_resolve_overloaded_builtin (tree fndecl, tree fnargs);\n+extern tree spu_resolve_overloaded_builtin (tree fndecl, void *fnargs);\n extern rtx spu_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t\t\t       enum machine_mode mode, int ignore);\n extern rtx spu_expand_builtin (tree, rtx, rtx, enum machine_mode, int);"}, {"sha": "b0ba7ceebd2a8ed9b03ea4187f306a571776e4d3", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -786,7 +786,8 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n   rtx target = operands[0];\n   enum machine_mode comp_mode;\n   enum machine_mode op_mode;\n-  enum spu_comp_code scode, eq_code, ior_code;\n+  enum spu_comp_code scode, eq_code;\n+  enum insn_code ior_code;\n   int index;\n   int eq_test = 0;\n \n@@ -1886,8 +1887,7 @@ spu_expand_prologue (void)\n \t}\n       RTX_FRAME_RELATED_P (insn) = 1;\n       real = gen_addsi3 (sp_reg, sp_reg, GEN_INT (-total_size));\n-      REG_NOTES (insn) =\n-\tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, real, REG_NOTES (insn));\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, real);\n \n       if (total_size > 2000)\n \t{\n@@ -1904,9 +1904,7 @@ spu_expand_prologue (void)\n \t  insn = frame_emit_add_imm (fp_reg, sp_reg, fp_offset, scratch_reg_0);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  real = gen_addsi3 (fp_reg, sp_reg, GEN_INT (fp_offset));\n-\t  REG_NOTES (insn) = \n-\t    gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t       real, REG_NOTES (insn));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, real);\n           REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = STACK_BOUNDARY;\n \t}\n     }\n@@ -5892,7 +5890,7 @@ expand_builtin_args (struct spu_builtin_description *d, tree exp,\n       tree arg = CALL_EXPR_ARG (exp, a);\n       if (arg == 0)\n \tabort ();\n-      ops[i] = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n+      ops[i] = expand_expr (arg, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n     }\n \n   /* The insn pattern may have additional operands (SCRATCH).\n@@ -6291,4 +6289,3 @@ spu_section_type_flags (tree decl, const char *name, int reloc)\n     return SECTION_BSS;\n   return default_section_type_flags (decl, name, reloc);\n }\n-"}, {"sha": "0d014f57a17883bd9126353641f23f3c3e0a0eaf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,3 +1,15 @@\n+2009-04-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* typeck.c (build_function_call_vec): New function.\n+\t(cp_build_function_call): Only pass first parameter to\n+\tobjc_rewrite_function_call.\n+\t(build_modify_expr): Add rhs_origtype parameter.  Change all\n+\tcallers.\n+\t* decl.c (finish_decl): Add origtype parameter.  Change all\n+\tcallers.\n+\t* semantics.c (finish_call_expr): Pass VEC to\n+\tresolve_overloaded_builtin.\n+\n 2009-04-20  Ian Lance Taylor  <iant@google.com>\n \n \t* cp-tree.h (base_access): Change typedef to int."}, {"sha": "a20b8c4c565213f6f0131079dd27560e8fcc710c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -774,7 +774,7 @@ get_vtable_decl (tree type, int complete)\n   if (complete)\n     {\n       DECL_EXTERNAL (decl) = 1;\n-      finish_decl (decl, NULL_TREE, NULL_TREE);\n+      finish_decl (decl, NULL_TREE, NULL_TREE, NULL_TREE);\n     }\n \n   return decl;"}, {"sha": "e3fed778e8037544eaf8a488bfb1e8ea6688a653", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -4346,7 +4346,7 @@ extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int,\n extern void start_decl_1\t\t\t(tree, bool);\n extern bool check_array_initializer\t\t(tree, tree, tree);\n extern void cp_finish_decl\t\t\t(tree, tree, bool, tree, int);\n-extern void finish_decl\t\t\t\t(tree, tree, tree);\n+extern void finish_decl\t\t\t\t(tree, tree, tree, tree);\n extern int cp_complete_array_type\t\t(tree *, tree, bool);\n extern tree build_ptrmemfunc_type\t\t(tree);\n extern tree build_ptrmem_type\t\t\t(tree, tree);"}, {"sha": "9aebe2af9c147944700f88a8b96bd17f441e0cf2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -5868,7 +5868,8 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n /* This is here for a midend callback from c-common.c.  */\n \n void\n-finish_decl (tree decl, tree init, tree asmspec_tree)\n+finish_decl (tree decl, tree init, tree origtype ATTRIBUTE_UNUSED,\n+\t     tree asmspec_tree)\n {\n   cp_finish_decl (decl, init, /*init_const_expr_p=*/false, asmspec_tree, 0);\n }\n@@ -5895,7 +5896,7 @@ declare_global_var (tree name, tree type)\n      library), then it is possible that our declaration will be merged\n      with theirs by pushdecl.  */\n   decl = pushdecl (decl);\n-  finish_decl (decl, NULL_TREE, NULL_TREE);\n+  finish_decl (decl, NULL_TREE, NULL_TREE, NULL_TREE);\n   pop_from_top_level ();\n \n   return decl;\n@@ -12480,7 +12481,7 @@ start_method (cp_decl_specifier_seq *declspecs,\n \t}\n     }\n \n-  finish_decl (fndecl, NULL_TREE, NULL_TREE);\n+  finish_decl (fndecl, NULL_TREE, NULL_TREE, NULL_TREE);\n \n   /* Make a place for the parms.  */\n   begin_scope (sk_function_parms, fndecl);"}, {"sha": "12876adb47a658ae17cc5e7ff6c5ac55d427dbcb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1001,7 +1001,7 @@ grokbitfield (const cp_declarator *declarator,\n       error (\"static member %qD cannot be a bit-field\", value);\n       return NULL_TREE;\n     }\n-  finish_decl (value, NULL_TREE, NULL_TREE);\n+  finish_decl (value, NULL_TREE, NULL_TREE, NULL_TREE);\n \n   if (width != error_mark_node)\n     {"}, {"sha": "d8b2e7c5e92d189798401b9709500094038d4be0", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -3556,7 +3556,7 @@ pushdecl_top_level_1 (tree x, tree *init, bool is_friend)\n   push_to_top_level ();\n   x = pushdecl_namespace_level (x, is_friend);\n   if (init)\n-    finish_decl (x, *init, NULL_TREE);\n+    finish_decl (x, *init, NULL_TREE, NULL_TREE);\n   pop_from_top_level ();\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n }"}, {"sha": "b58b9f1f8efd317da91f15fbe8e9f5be76c8d1fe", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -10774,7 +10774,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t  init = t;\n \t\t      }\n \n-\t\t    finish_decl (decl, init, NULL_TREE);\n+\t\t    finish_decl (decl, init, NULL_TREE, NULL_TREE);\n \t\t  }\n \t      }\n \t  }\n@@ -15577,7 +15577,7 @@ instantiate_decl (tree d, int defer_ok,\n \n       /* Enter the scope of D so that access-checking works correctly.  */\n       push_nested_class (DECL_CONTEXT (d));\n-      finish_decl (d, init, NULL_TREE);\n+      finish_decl (d, init, NULL_TREE, NULL_TREE);\n       pop_nested_class ();\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)"}, {"sha": "68419fa8319cc0a79ff1cdb9584f3627f95799f3", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* RunTime Type Identification\n    Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2006, 2007, 2008\n+   2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Mostly written by Jason Merrill (jason@cygnus.com).\n \n@@ -1519,7 +1519,7 @@ emit_tinfo_decl (tree decl)\n       init = get_pseudo_ti_init (type, get_pseudo_ti_index (type));\n       DECL_INITIAL (decl) = init;\n       mark_used (decl);\n-      finish_decl (decl, init, NULL_TREE);\n+      finish_decl (decl, init, NULL_TREE, NULL_TREE);\n       return true;\n     }\n   else"}, {"sha": "0183239f359e4a889388594ec3fffbdda21f0c2a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1987,7 +1987,15 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p,\n       if (TREE_CODE (fn) == FUNCTION_DECL\n \t  && (DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL\n \t      || DECL_BUILT_IN_CLASS (fn) == BUILT_IN_MD))\n-\tresult = resolve_overloaded_builtin (fn, args);\n+\t{\n+\t  VEC(tree,gc)* vec = VEC_alloc (tree, gc, list_length (args));\n+\t  tree p;\n+\n+\t  for (p = args; p != NULL_TREE; p = TREE_CHAIN (p))\n+\t    VEC_quick_push (tree, vec, TREE_VALUE (p));\n+\t  result = resolve_overloaded_builtin (fn, vec);\n+\t  VEC_free (tree, gc, vec);\n+\t}\n \n       if (!result)\n \t/* A call to a namespace-scope function.  */\n@@ -4121,7 +4129,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n   cond = cp_build_binary_op (elocus,\n \t\t\t     TREE_CODE (cond), decl, diff,\n \t\t\t     tf_warning_or_error);\n-  incr = build_modify_expr (elocus, decl, PLUS_EXPR, incr);\n+  incr = build_modify_expr (elocus, decl, PLUS_EXPR, incr, NULL_TREE);\n \n   orig_body = *body;\n   *body = push_stmt_list ();"}, {"sha": "9084b5e10e0e66db933c99e345f01abaf6c0b12e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -2857,6 +2857,28 @@ build_function_call (tree function, tree params)\n   return cp_build_function_call (function, params, tf_warning_or_error);\n }\n \n+/* Used by the C-common bits.  */\n+tree\n+build_function_call_vec (tree function, VEC(tree,gc) *params,\n+\t\t\t VEC(tree,gc) *origtypes ATTRIBUTE_UNUSED)\n+{\n+  tree p;\n+  tree *pp;\n+  unsigned int i;\n+  tree t;\n+\n+  /* FIXME: Should just change cp_build_function_call to use a\n+     VEC.  */\n+  p = NULL_TREE;\n+  pp = &p;\n+  for (i = 0; VEC_iterate (tree, params, i, t); ++i)\n+    {\n+      *pp = build_tree_list (NULL, t);\n+      pp = &TREE_CHAIN (*pp);\n+    }\n+  return cp_build_function_call (function, p, tf_warning_or_error);\n+}\n+\n tree\n cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n {\n@@ -2870,7 +2892,8 @@ cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n-  function = objc_rewrite_function_call (function, params);\n+  if (params != NULL_TREE)\n+    function = objc_rewrite_function_call (function, TREE_VALUE (params));\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */\n@@ -5840,7 +5863,8 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n /* For use from the C common bits.  */\n tree\n build_modify_expr (location_t location ATTRIBUTE_UNUSED,\n-\t\t   tree lhs, enum tree_code modifycode, tree rhs)\n+\t\t   tree lhs, enum tree_code modifycode, tree rhs,\n+\t\t   tree rhs_origtype ATTRIBUTE_UNUSED)\n {\n   return cp_build_modify_expr (lhs, modifycode, rhs, tf_warning_or_error);\n }"}, {"sha": "c238efd6e4e05a949c990d2d0d986a7a14dd189e", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Common subexpression elimination for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -2329,14 +2329,14 @@ hash_rtx_cb (const_rtx x, enum machine_mode mode,\n \t      goto repeat;\n \t    }\n           \n-\t  hash += hash_rtx_cb (XEXP (x, i), 0, do_not_record_p,\n+\t  hash += hash_rtx_cb (XEXP (x, i), VOIDmode, do_not_record_p,\n                                hash_arg_in_memory_p,\n                                have_reg_qty, cb);\n \t  break;\n \n \tcase 'E':\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    hash += hash_rtx_cb (XVECEXP (x, i, j), 0, do_not_record_p,\n+\t    hash += hash_rtx_cb (XVECEXP (x, i, j), VOIDmode, do_not_record_p,\n                                  hash_arg_in_memory_p,\n                                  have_reg_qty, cb);\n \t  break;\n@@ -6997,4 +6997,3 @@ struct rtl_opt_pass pass_cse2 =\n   TODO_verify_flow                      /* todo_flags_finish */\n  }\n };\n-"}, {"sha": "859aabff9d90ffb3b7257168a8941a09a8156483", "filename": "gcc/dbgcnt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdbgcnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdbgcnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Debug counter for debugging support\n-   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -88,7 +88,7 @@ dbg_cnt_set_limit_by_name (const char *name, int len, int value)\n   if (i < 0)\n     return false;\n \n-  dbg_cnt_set_limit_by_index (i, value);\n+  dbg_cnt_set_limit_by_index ((enum debug_counter) i, value);\n   return true;\n }\n "}, {"sha": "edad611f089f117d5dcd800663e511b70690fa8d", "filename": "gcc/dbxout.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Output dbx-format symbol table information from GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -2811,7 +2811,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n       if (!decl_rtl)\n \tDBXOUT_DECR_NESTING_AND_RETURN (0);\n \n-      decl_rtl = eliminate_regs (decl_rtl, 0, NULL_RTX);\n+      decl_rtl = eliminate_regs (decl_rtl, VOIDmode, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n       if (current_function_uses_only_leaf_regs)\n \tleaf_renumber_regs_insn (decl_rtl);\n@@ -3316,8 +3316,9 @@ dbxout_parms (tree parms)\n \t/* Perform any necessary register eliminations on the parameter's rtl,\n \t   so that the debugging output will be accurate.  */\n \tDECL_INCOMING_RTL (parms)\n-\t  = eliminate_regs (DECL_INCOMING_RTL (parms), 0, NULL_RTX);\n-\tSET_DECL_RTL (parms, eliminate_regs (DECL_RTL (parms), 0, NULL_RTX));\n+\t  = eliminate_regs (DECL_INCOMING_RTL (parms), VOIDmode, NULL_RTX);\n+\tSET_DECL_RTL (parms,\n+\t\t      eliminate_regs (DECL_RTL (parms), VOIDmode, NULL_RTX));\n #ifdef LEAF_REG_REMAP\n \tif (current_function_uses_only_leaf_regs)\n \t  {"}, {"sha": "e25d0e5faa3808b7dafd7d58045f24cea3b5433a", "filename": "gcc/df-core.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -475,7 +475,7 @@ df_add_problem (struct df_problem *problem)\n    returned.  If a flag is not allowed to be changed this will fail if\n    checking is enabled.  */\n enum df_changeable_flags\n-df_set_flags (enum df_changeable_flags changeable_flags)\n+df_set_flags (int changeable_flags)\n {\n   enum df_changeable_flags old_flags = df->changeable_flags;\n   df->changeable_flags |= changeable_flags;\n@@ -487,7 +487,7 @@ df_set_flags (enum df_changeable_flags changeable_flags)\n    returned.  If a flag is not allowed to be changed this will fail if\n    checking is enabled.  */\n enum df_changeable_flags\n-df_clear_flags (enum df_changeable_flags changeable_flags)\n+df_clear_flags (int changeable_flags)\n {\n   enum df_changeable_flags old_flags = df->changeable_flags;\n   df->changeable_flags &= ~changeable_flags;"}, {"sha": "a4853273214aa7131793d1ffb79df8b28954fa79", "filename": "gcc/df-problems.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -321,7 +321,7 @@ df_rd_alloc (bitmap all_blocks)\n static void\n df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info, \n \t\t\t\t    df_ref *def_rec,\n-\t\t\t\t    enum df_ref_flags top_flag)\n+\t\t\t\t    int top_flag)\n {\n   while (*def_rec)\n     {\n@@ -2025,7 +2025,7 @@ df_chain_reset (bitmap blocks_to_clear ATTRIBUTE_UNUSED)\n static void\n df_chain_create_bb_process_use (bitmap local_rd,\n \t\t\t\tdf_ref *use_rec,\n-\t\t\t\tenum df_ref_flags top_flag)\n+\t\t\t\tint top_flag)\n {\n   bitmap_iterator bi;\n   unsigned int def_index;\n@@ -2325,10 +2325,10 @@ static struct df_problem problem_CHAIN =\n    solution.  */\n \n void\n-df_chain_add_problem (enum df_chain_flags chain_flags)\n+df_chain_add_problem (unsigned int chain_flags)\n {\n   df_add_problem (&problem_CHAIN);\n-  df_chain->local_flags = (unsigned int)chain_flags;\n+  df_chain->local_flags = chain_flags;\n   df_chain->out_of_date_transfer_functions = BITMAP_ALLOC (NULL);\n }\n \n@@ -3931,5 +3931,3 @@ df_simulate_finalize_forwards (basic_block bb, bitmap live)\n \tbitmap_clear_bit (live, DF_REF_REGNO (def));\n     }\n }\n-\n-"}, {"sha": "fe00af2d3ec939961fbd172ccaa7dc092aa5e1ce", "filename": "gcc/df-scan.c", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -100,24 +100,24 @@ static struct df_mw_hardreg * df_null_mw_rec[1];\n static void df_ref_record (enum df_ref_class, struct df_collection_rec *,\n \t\t\t   rtx, rtx *, \n \t\t\t   basic_block, struct df_insn_info *,\n-\t\t\t   enum df_ref_type, enum df_ref_flags,\n+\t\t\t   enum df_ref_type, int ref_flags,\n \t\t\t   int, int, enum machine_mode);\n static void df_def_record_1 (struct df_collection_rec *, rtx,\n \t\t\t     basic_block, struct df_insn_info *,\n-\t\t\t     enum df_ref_flags);\n+\t\t\t     int ref_flags);\n static void df_defs_record (struct df_collection_rec *, rtx,\n \t\t\t    basic_block, struct df_insn_info *,\n-\t\t\t    enum df_ref_flags);\n+\t\t\t    int ref_flags);\n static void df_uses_record (enum df_ref_class, struct df_collection_rec *,\n \t\t\t    rtx *, enum df_ref_type,\n \t\t\t    basic_block, struct df_insn_info *,\n-\t\t\t    enum df_ref_flags, \n+\t\t\t    int ref_flags, \n \t\t\t    int, int, enum machine_mode);\n \n static df_ref df_ref_create_structure (enum df_ref_class, \n \t\t\t\t       struct df_collection_rec *, rtx, rtx *, \n \t\t\t\t       basic_block, struct df_insn_info *,\n-\t\t\t\t       enum df_ref_type, enum df_ref_flags,\n+\t\t\t\t       enum df_ref_type, int ref_flags,\n \t\t\t\t       int, int, enum machine_mode);\n \n static void df_insn_refs_collect (struct df_collection_rec*, \n@@ -708,7 +708,7 @@ df_ref\n df_ref_create (rtx reg, rtx *loc, rtx insn, \n \t       basic_block bb,\n \t       enum df_ref_type ref_type, \n-\t       enum df_ref_flags ref_flags,\n+\t       int ref_flags,\n \t       int width, int offset, enum machine_mode mode)\n {\n   df_ref ref;\n@@ -2146,7 +2146,7 @@ df_notes_rescan (rtx insn)\n \t    case REG_EQUAL:\n \t      df_uses_record (DF_REF_REGULAR, &collection_rec,\n \t\t\t      &XEXP (note, 0), DF_REF_REG_USE,\n-\t\t\t      bb, insn_info, DF_REF_IN_NOTE, -1, -1, 0);\n+\t\t\t      bb, insn_info, DF_REF_IN_NOTE, -1, -1, VOIDmode);\n \t    default:\n \t      break;\n \t    }\n@@ -2691,7 +2691,7 @@ df_ref_create_structure (enum df_ref_class cl,\n \t\t\t rtx reg, rtx *loc, \n \t\t\t basic_block bb, struct df_insn_info *info,\n \t\t\t enum df_ref_type ref_type, \n-\t\t\t enum df_ref_flags ref_flags,\n+\t\t\t int ref_flags,\n \t\t\t int width, int offset, enum machine_mode mode)\n {\n   df_ref this_ref = NULL;\n@@ -2789,7 +2789,7 @@ df_ref_record (enum df_ref_class cl,\n                rtx reg, rtx *loc, \n \t       basic_block bb, struct df_insn_info *insn_info,\n \t       enum df_ref_type ref_type, \n-\t       enum df_ref_flags ref_flags,\n+\t       int ref_flags,\n \t       int width, int offset, enum machine_mode mode) \n {\n   unsigned int regno;\n@@ -2878,7 +2878,7 @@ df_read_modify_subreg_p (rtx x)\n static void\n df_def_record_1 (struct df_collection_rec *collection_rec,\n                  rtx x, basic_block bb, struct df_insn_info *insn_info,\n-\t\t enum df_ref_flags flags)\n+\t\t int flags)\n {\n   rtx *loc;\n   rtx dst;\n@@ -2971,7 +2971,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n static void\n df_defs_record (struct df_collection_rec *collection_rec, \n                 rtx x, basic_block bb, struct df_insn_info *insn_info,\n-\t\tenum df_ref_flags flags)\n+\t\tint flags)\n {\n   RTX_CODE code = GET_CODE (x);\n \n@@ -3009,7 +3009,7 @@ static void\n df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n                 rtx *loc, enum df_ref_type ref_type,\n \t\tbasic_block bb, struct df_insn_info *insn_info,\n-\t\tenum df_ref_flags flags,\n+\t\tint flags,\n \t\tint width, int offset, enum machine_mode mode)\n {\n   RTX_CODE code;\n@@ -3322,7 +3322,7 @@ static void\n df_get_call_refs (struct df_collection_rec * collection_rec,\n                   basic_block bb, \n                   struct df_insn_info *insn_info,\n-                  enum df_ref_flags flags)\n+                  int flags)\n {\n   rtx note;\n   bitmap_iterator bi;\n@@ -3347,7 +3347,8 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n     {\n       if (GET_CODE (XEXP (note, 0)) == USE)\n         df_uses_record (DF_REF_REGULAR, collection_rec, &XEXP (XEXP (note, 0), 0),\n-\t\t\tDF_REF_REG_USE, bb, insn_info, flags, -1, -1, 0);\n+\t\t\tDF_REF_REG_USE, bb, insn_info, flags, -1, -1,\n+\t\t\tVOIDmode);\n       else if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n \t{\n \t  if (REG_P (XEXP (XEXP (note, 0), 0)))\n@@ -3359,25 +3360,28 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t    }\n \t  else\n \t    df_uses_record (DF_REF_REGULAR, collection_rec, &XEXP (note, 0),\n-\t\t            DF_REF_REG_USE, bb, insn_info, flags, -1, -1, 0);\n+\t\t            DF_REF_REG_USE, bb, insn_info, flags, -1, -1,\n+\t\t\t    VOIDmode);\n \t}\n     }\n \n   /* The stack ptr is used (honorarily) by a CALL insn.  */\n   df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n \t\t NULL, bb, insn_info, DF_REF_REG_USE,\n \t\t DF_REF_CALL_STACK_USAGE | flags, \n-\t\t -1, -1, 0);\n+\t\t -1, -1, VOIDmode);\n \n   /* Calls may also reference any of the global registers,\n      so they are recorded as used.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (global_regs[i])\n       {\n \tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn_info, DF_REF_REG_USE, flags, -1, -1, 0);\n+\t\t       NULL, bb, insn_info, DF_REF_REG_USE, flags, -1, -1,\n+\t\t       VOIDmode);\n \tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn_info, DF_REF_REG_DEF, flags, -1, -1, 0);\n+\t\t       NULL, bb, insn_info, DF_REF_REG_DEF, flags, -1, -1,\n+\t\t       VOIDmode);\n       }\n \n   is_sibling_call = SIBLING_CALL_P (insn_info->insn);\n@@ -3392,7 +3396,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n         df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[ui], \n \t\t       NULL, bb, insn_info, DF_REF_REG_DEF,\n \t\t       DF_REF_MAY_CLOBBER | flags, \n-\t\t       -1, -1, 0);\n+\t\t       -1, -1, VOIDmode);\n     }\n \n   BITMAP_FREE (defs_generated);\n@@ -3430,19 +3434,19 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n         case REG_EQUAL:\n           df_uses_record (DF_REF_REGULAR, collection_rec,\n                           &XEXP (note, 0), DF_REF_REG_USE,\n-                          bb, insn_info, DF_REF_IN_NOTE, -1, -1, 0);\n+                          bb, insn_info, DF_REF_IN_NOTE, -1, -1, VOIDmode);\n           break;\n         case REG_NON_LOCAL_GOTO:\n           /* The frame ptr is used by a non-local goto.  */\n           df_ref_record (DF_REF_BASE, collection_rec,\n                          regno_reg_rtx[FRAME_POINTER_REGNUM],\n                          NULL, bb, insn_info,\n-                         DF_REF_REG_USE, 0, -1, -1, 0);\n+                         DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n           df_ref_record (DF_REF_BASE, collection_rec,\n                          regno_reg_rtx[HARD_FRAME_POINTER_REGNUM],\n                          NULL, bb, insn_info,\n-                         DF_REF_REG_USE, 0, -1, -1, 0);\n+                         DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n #endif\n           break;\n         default:\n@@ -3457,7 +3461,7 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n   /* Record the register uses.  */\n   df_uses_record (DF_REF_REGULAR, collection_rec,\n \t\t  &PATTERN (insn_info->insn), DF_REF_REG_USE, bb, insn_info, 0, \n-\t\t  -1, -1, 0);\n+\t\t  -1, -1, VOIDmode);\n \n   /* DF_REF_CONDITIONAL needs corresponding USES. */\n   if (is_cond_exec)\n@@ -3540,7 +3544,8 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n \t  if (regno == INVALID_REGNUM)\n \t    break;\n \t  df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[regno], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, 0);\n+\t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1,\n+\t\t\t VOIDmode);\n \t}\n     }\n #endif\n@@ -3549,7 +3554,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n      non-local goto.  */\n   if (bb->flags & BB_NON_LOCAL_GOTO_TARGET)\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, hard_frame_pointer_rtx, NULL,\n-\t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, 0);\n+\t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, VOIDmode);\n  \n   /* Add the artificial uses.  */\n   if (bb->index >= NUM_FIXED_BLOCKS)\n@@ -3563,7 +3568,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n       EXECUTE_IF_SET_IN_BITMAP (au, 0, regno, bi)\n \t{\n \t  df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[regno], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n+\t\t\t bb, NULL, DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n \t}\n     }\n \n@@ -3864,7 +3869,8 @@ df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n   EXECUTE_IF_SET_IN_BITMAP (entry_block_defs, 0, i, bi)\n     {\n       df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL, \n-\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0, -1, -1, 0);\n+\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0, -1, -1,\n+\t\t     VOIDmode);\n     }\n \n   df_canonize_collection_rec (collection_rec);\n@@ -4025,7 +4031,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n \n   EXECUTE_IF_SET_IN_BITMAP (exit_block_uses, 0, i, bi)\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n+\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n \n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n   /* It is deliberate that this is not put in the exit block uses but\n@@ -4035,7 +4041,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n       && bb_has_eh_pred (EXIT_BLOCK_PTR)\n       && fixed_regs[ARG_POINTER_REGNUM])\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[ARG_POINTER_REGNUM], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, 0);\n+\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n #endif\n \n   df_canonize_collection_rec (collection_rec);"}, {"sha": "3462b453c452da6f50a8b488fbc1cbe7757c9bd7", "filename": "gcc/df.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -879,8 +879,8 @@ extern struct df *df;\n /* Functions defined in df-core.c.  */\n \n extern void df_add_problem (struct df_problem *);\n-extern enum df_changeable_flags df_set_flags (enum df_changeable_flags);\n-extern enum df_changeable_flags df_clear_flags (enum df_changeable_flags);\n+extern enum df_changeable_flags df_set_flags (int);\n+extern enum df_changeable_flags df_clear_flags (int);\n extern void df_set_blocks (bitmap);\n extern void df_remove_problem (struct dataflow *);\n extern void df_finish_pass (bool);\n@@ -945,7 +945,7 @@ extern void df_lr_verify_transfer_functions (void);\n extern void df_live_verify_transfer_functions (void);\n extern void df_live_add_problem (void);\n extern void df_live_set_all_dirty (void);\n-extern void df_chain_add_problem (enum df_chain_flags);\n+extern void df_chain_add_problem (unsigned int);\n extern void df_byte_lr_add_problem (void);\n extern int df_byte_lr_get_regno_start (unsigned int);\n extern int df_byte_lr_get_regno_len (unsigned int);\n@@ -972,7 +972,7 @@ extern void df_grow_reg_info (void);\n extern void df_grow_insn_info (void);\n extern void df_scan_blocks (void);\n extern df_ref df_ref_create (rtx, rtx *, rtx,basic_block, \n-\t\t\t\t     enum df_ref_type, enum df_ref_flags,\n+\t\t\t\t     enum df_ref_type, int ref_flags,\n \t\t\t\t     int, int, enum machine_mode);\n extern void df_ref_remove (df_ref);\n extern struct df_insn_info * df_insn_create_insn_record (rtx);"}, {"sha": "93c7ca45c5822fae91b2826336b3f3279b3e5e48", "filename": "gcc/double-int.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Operations with long integers.\n-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -211,8 +211,9 @@ double_int_divmod (double_int a, double_int b, bool uns, unsigned code,\n {\n   double_int ret;\n \n-  div_and_round_double (code, uns, a.low, a.high, b.low, b.high,\n-\t\t\t&ret.low, &ret.high, &mod->low, &mod->high);\n+  div_and_round_double ((enum tree_code) code, uns, a.low, a.high,\n+\t\t\tb.low, b.high, &ret.low, &ret.high,\n+\t\t\t&mod->low, &mod->high);\n   return ret;\n }\n "}, {"sha": "e0e685bf0c961942633ad568559dd3a459053596", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -826,7 +826,7 @@ replace_inc_dec (rtx *r, void *d)\n     case POST_INC:\n       {\n \trtx r1 = XEXP (x, 0);\n-\trtx c = gen_int_mode (Pmode, data->size);\n+\trtx c = gen_int_mode (data->size, Pmode);\n \temit_insn_before (gen_rtx_SET (Pmode, r1, \n \t\t\t\t       gen_rtx_PLUS (Pmode, r1, c)),\n \t\t\t  data->insn);\n@@ -837,7 +837,7 @@ replace_inc_dec (rtx *r, void *d)\n     case POST_DEC:\n       {\n \trtx r1 = XEXP (x, 0);\n-\trtx c = gen_int_mode (Pmode, -data->size);\n+\trtx c = gen_int_mode (-data->size, Pmode);\n \temit_insn_before (gen_rtx_SET (Pmode, r1, \n \t\t\t\t       gen_rtx_PLUS (Pmode, r1, c)),\n \t\t\t  data->insn);"}, {"sha": "f2da4ac1f50768588455bcf71b1177ca408919a4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -3866,12 +3866,13 @@ new_reg_loc_descr (unsigned int reg,  unsigned HOST_WIDE_INT offset)\n   if (offset)\n     {\n       if (reg <= 31)\n-\treturn new_loc_descr (DW_OP_breg0 + reg, offset, 0);\n+\treturn new_loc_descr ((enum dwarf_location_atom) (DW_OP_breg0 + reg),\n+\t\t\t      offset, 0);\n       else\n \treturn new_loc_descr (DW_OP_bregx, reg, offset);\n     }\n   else if (reg <= 31)\n-    return new_loc_descr (DW_OP_reg0 + reg, 0, 0);\n+    return new_loc_descr ((enum dwarf_location_atom) (DW_OP_reg0 + reg), 0, 0);\n   else\n    return new_loc_descr (DW_OP_regx, reg, 0);\n }\n@@ -9866,7 +9867,8 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n \n   regno = dbx_reg_number (reg);\n   if (regno <= 31)\n-    result = new_loc_descr (DW_OP_breg0 + regno, offset, 0);\n+    result = new_loc_descr ((enum dwarf_location_atom) (DW_OP_breg0 + regno),\n+\t\t\t    offset, 0);\n   else\n     result = new_loc_descr (DW_OP_bregx, regno, offset);\n \n@@ -10394,8 +10396,8 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       if (DECL_THREAD_LOCAL_P (loc))\n \t{\n \t  rtx rtl;\n-\t  unsigned first_op;\n-\t  unsigned second_op;\n+\t  enum dwarf_location_atom first_op;\n+\t  enum dwarf_location_atom second_op;\n \n \t  if (targetm.have_tls)\n \t    {\n@@ -10409,7 +10411,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t     \t  module.  */\n \t      if (DECL_EXTERNAL (loc) && !targetm.binds_local_p (loc))\n \t\treturn 0;\n-\t      first_op = INTERNAL_DW_OP_tls_addr;\n+\t      first_op = (enum dwarf_location_atom) INTERNAL_DW_OP_tls_addr;\n \t      second_op = DW_OP_GNU_push_tls_address;\n \t    }\n \t  else"}, {"sha": "acbc09b1b87e93667af04abc6ee4b9bbc6c5562d", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -208,7 +208,7 @@ init_expmed (void)\n   for (speed = 0; speed < 2; speed++)\n     {\n       crtl->maybe_hot_insn_p = speed;\n-      zero_cost[speed] = rtx_cost (const0_rtx, 0, speed);\n+      zero_cost[speed] = rtx_cost (const0_rtx, SET, speed);\n \n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   mode != VOIDmode;"}, {"sha": "7935c67cf674b09e9c00469801530501ea1019c1", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -267,7 +267,7 @@ init_expr_target (void)\n   reg = gen_rtx_REG (VOIDmode, -1);\n \n   insn = rtx_alloc (INSN);\n-  pat = gen_rtx_SET (0, NULL_RTX, NULL_RTX);\n+  pat = gen_rtx_SET (VOIDmode, NULL_RTX, NULL_RTX);\n   PATTERN (insn) = pat;\n \n   for (mode = VOIDmode; (int) mode < NUM_MACHINE_MODES;\n@@ -8453,7 +8453,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  || mode != ptr_mode)\n \t{\n \t  expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n-\t\t\t   subtarget, &op0, &op1, 0);\n+\t\t\t   subtarget, &op0, &op1, EXPAND_NORMAL);\n \t  if (op0 == const0_rtx)\n \t    return op1;\n \t  if (op1 == const0_rtx)\n@@ -8625,11 +8625,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t  if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subexp0, 0))))\n \t\t    expand_operands (TREE_OPERAND (subexp0, 0),\n \t\t\t\t     TREE_OPERAND (subexp1, 0),\n-\t\t\t\t     NULL_RTX, &op0, &op1, 0);\n+\t\t\t\t     NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \t\t  else\n \t\t    expand_operands (TREE_OPERAND (subexp0, 0),\n \t\t\t\t     TREE_OPERAND (subexp1, 0),\n-\t\t\t\t     NULL_RTX, &op1, &op0, 0);\n+\t\t\t\t     NULL_RTX, &op1, &op0, EXPAND_NORMAL);\n \n \t\t  goto binop3;\n \t\t}\n@@ -8706,7 +8706,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    }\n \t}\n       expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n-\t\t       subtarget, &op0, &op1, 0);\n+\t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n       return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n \n     case TRUNC_DIV_EXPR:\n@@ -8726,7 +8726,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t then if the divisor is constant can optimize the case\n \t where some terms of the dividend have coeffs divisible by it.  */\n       expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n-\t\t       subtarget, &op0, &op1, 0);\n+\t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n       return expand_divmod (0, code, mode, op0, op1, target, unsignedp);\n \n     case RDIV_EXPR:\n@@ -8739,7 +8739,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n       expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n-\t\t       subtarget, &op0, &op1, 0);\n+\t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n       return expand_divmod (1, code, mode, op0, op1, target, unsignedp);\n \n     case FIXED_CONVERT_EXPR:\n@@ -8816,7 +8816,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n \ttarget = gen_reg_rtx (mode);\n       expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n-\t\t       target, &op0, &op1, 0);\n+\t\t       target, &op0, &op1, EXPAND_NORMAL);\n \n       /* First try to do it with a special MIN or MAX instruction.\n \t If that does not win, use a conditional jump to select the proper\n@@ -9324,7 +9324,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         tree oprnd0 = TREE_OPERAND (exp, 0);\n         tree oprnd1 = TREE_OPERAND (exp, 1);\n \n-        expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, 0);\n+        expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n         target = expand_widen_pattern_expr (exp, op0, NULL_RTX, op1,\n                                             target, unsignedp);\n         return target;\n@@ -9345,7 +9345,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_EXTRACT_ODD_EXPR:\n       {\n         expand_operands (TREE_OPERAND (exp, 0),  TREE_OPERAND (exp, 1),\n-                         NULL_RTX, &op0, &op1, 0);\n+                         NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n         this_optab = optab_for_tree_code (code, type, optab_default);\n         temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,\n                              OPTAB_WIDEN);\n@@ -9357,7 +9357,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VEC_INTERLEAVE_LOW_EXPR:\n       {\n         expand_operands (TREE_OPERAND (exp, 0),  TREE_OPERAND (exp, 1),\n-                         NULL_RTX, &op0, &op1, 0);\n+                         NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n         this_optab = optab_for_tree_code (code, type, optab_default);\n         temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,\n                              OPTAB_WIDEN);\n@@ -9405,7 +9405,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttree oprnd0 = TREE_OPERAND (exp, 0);\n \ttree oprnd1 = TREE_OPERAND (exp, 1);\n \n-\texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, 0);\n+\texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \ttarget = expand_widen_pattern_expr (exp, op0, op1, NULL_RTX,\n \t\t\t\t\t    target, unsignedp);\n \tgcc_assert (target);\n@@ -9446,7 +9446,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   /* Here to do an ordinary binary operator.  */\n  binop:\n   expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n-\t\t   subtarget, &op0, &op1, 0);\n+\t\t   subtarget, &op0, &op1, EXPAND_NORMAL);\n  binop2:\n   this_optab = optab_for_tree_code (code, type, optab_default);\n  binop3:\n@@ -9825,7 +9825,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n       || GET_MODE (subtarget) != operand_mode)\n     subtarget = 0;\n \n-  expand_operands (arg0, arg1, subtarget, &op0, &op1, 0);\n+  expand_operands (arg0, arg1, subtarget, &op0, &op1, EXPAND_NORMAL);\n \n   if (target == 0)\n     target = gen_reg_rtx (mode);"}, {"sha": "d6e67794b048f714a949e4f734bb327dbf74cf31", "filename": "gcc/fixed-value.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ffixed-value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ffixed-value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Fixed-point arithmetic support.\n-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -26,8 +26,8 @@ along with GCC; see the file COPYING3.  If not see\n \n struct fixed_value GTY(())\n {\n-  double_int data;\t/* Store data up to 2 wide integers.  */\n-  unsigned int mode;\t/* Use machine mode to know IBIT and FBIT.  */\n+  double_int data;\t\t/* Store data up to 2 wide integers.  */\n+  enum machine_mode mode;\t/* Use machine mode to know IBIT and FBIT.  */\n };\n \n #define FIXED_VALUE_TYPE struct fixed_value"}, {"sha": "2c97597edd7682ff102a90e6e9305020bdc5f136", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -3249,7 +3249,7 @@ assign_parms (tree fndecl)\n     = (all.stack_args_size.var == 0 ? GEN_INT (-all.stack_args_size.constant)\n        : expand_expr (size_diffop (all.stack_args_size.var,\n \t\t\t\t   size_int (-all.stack_args_size.constant)),\n-\t\t      NULL_RTX, VOIDmode, 0));\n+\t\t      NULL_RTX, VOIDmode, EXPAND_NORMAL));\n #else\n   crtl->args.arg_offset_rtx = ARGS_SIZE_RTX (all.stack_args_size);\n #endif"}, {"sha": "0f5a40867049f9821b7997b94cf3795fc1a9487f", "filename": "gcc/genautomata.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1796,7 +1796,7 @@ insert_automaton_decl (decl_t automaton_decl)\n {\n   void **entry_ptr;\n \n-  entry_ptr = htab_find_slot (automaton_decl_table, automaton_decl, 1);\n+  entry_ptr = htab_find_slot (automaton_decl_table, automaton_decl, INSERT);\n   if (*entry_ptr == NULL)\n     *entry_ptr = (void *) automaton_decl;\n   return (decl_t) *entry_ptr;\n@@ -1895,7 +1895,7 @@ insert_insn_decl (decl_t insn_decl)\n {\n   void **entry_ptr;\n \n-  entry_ptr = htab_find_slot (insn_decl_table, insn_decl, 1);\n+  entry_ptr = htab_find_slot (insn_decl_table, insn_decl, INSERT);\n   if (*entry_ptr == NULL)\n     *entry_ptr = (void *) insn_decl;\n   return (decl_t) *entry_ptr;\n@@ -1996,7 +1996,7 @@ insert_decl (decl_t decl)\n {\n   void **entry_ptr;\n \n-  entry_ptr = htab_find_slot (decl_table, decl, 1);\n+  entry_ptr = htab_find_slot (decl_table, decl, INSERT);\n   if (*entry_ptr == NULL)\n     *entry_ptr = (void *) decl;\n   return (decl_t) *entry_ptr;\n@@ -3748,7 +3748,7 @@ insert_state (state_t state)\n {\n   void **entry_ptr;\n \n-  entry_ptr = htab_find_slot (state_table, (void *) state, 1);\n+  entry_ptr = htab_find_slot (state_table, (void *) state, INSERT);\n   if (*entry_ptr == NULL)\n     *entry_ptr = (void *) state;\n   return (state_t) *entry_ptr;\n@@ -4104,7 +4104,7 @@ automata_list_finish (void)\n   if (current_automata_list == NULL)\n     return NULL;\n   entry_ptr = htab_find_slot (automata_list_table,\n-\t\t\t      (void *) current_automata_list, 1);\n+\t\t\t      (void *) current_automata_list, INSERT);\n   if (*entry_ptr == NULL)\n     *entry_ptr = (void *) current_automata_list;\n   else"}, {"sha": "004fbf82ecbe572ea89b507e8ba2662dcf9a13cb", "filename": "gcc/genrecog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to recognize rtl as insns.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -378,7 +378,7 @@ process_define_predicate (rtx desc)\n \n   for (i = 0; i < NUM_RTX_CODE; i++)\n     if (codes[i] != N)\n-      add_predicate_code (pred, i);\n+      add_predicate_code (pred, (enum rtx_code) i);\n \n   add_predicate (pred);\n }"}, {"sha": "28eb5b3f433516c92a73dcfdf05930fd659744b3", "filename": "gcc/gensupport.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Support routines for the various generation passes.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -1404,7 +1404,7 @@ init_predicate_table (void)\n       if (std_preds[i].allows_const_p)\n \tfor (j = 0; j < NUM_RTX_CODE; j++)\n \t  if (GET_RTX_CLASS (j) == RTX_CONST_OBJ)\n-\t    add_predicate_code (pred, j);\n+\t    add_predicate_code (pred, (enum rtx_code) j);\n       \n       add_predicate (pred);\n     }"}, {"sha": "d35ba8b805500d8e87c09639ff34d05903bf824e", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -829,7 +829,7 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n \n   /* Build 'goto CONT_LABEL' and insert.  */\n   g = gimple_build_goto (cont_label);\n-  gsi_insert_before (gsi, g, TSI_SAME_STMT);\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   /* Build 'NEXT_LABEL:' and insert.  */\n   g = gimple_build_label (next_label);"}, {"sha": "e499e491a07076f64a5e7af2eeba4a380eb60c02", "filename": "gcc/gimple.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Gimple IR support functions.\n \n-   Copyright 2007, 2008 Free Software Foundation, Inc.\n+   Copyright 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Aldy Hernandez <aldyh@redhat.com>\n \n This file is part of GCC.\n@@ -271,7 +271,7 @@ gimple_build_with_ops_stat (enum gimple_code code, enum tree_code subcode,\n gimple\n gimple_build_return (tree retval)\n {\n-  gimple s = gimple_build_with_ops (GIMPLE_RETURN, 0, 1);\n+  gimple s = gimple_build_with_ops (GIMPLE_RETURN, ERROR_MARK, 1);\n   if (retval)\n     gimple_return_set_retval (s, retval);\n   return s;\n@@ -284,7 +284,7 @@ gimple_build_return (tree retval)\n static inline gimple\n gimple_build_call_1 (tree fn, unsigned nargs)\n {\n-  gimple s = gimple_build_with_ops (GIMPLE_CALL, 0, nargs + 3);\n+  gimple s = gimple_build_with_ops (GIMPLE_CALL, ERROR_MARK, nargs + 3);\n   if (TREE_CODE (fn) == FUNCTION_DECL)\n     fn = build_fold_addr_expr (fn);\n   gimple_set_op (s, 1, fn);\n@@ -544,7 +544,7 @@ gimple_cond_set_condition_from_tree (gimple stmt, tree cond)\n gimple\n gimple_build_label (tree label)\n {\n-  gimple p = gimple_build_with_ops (GIMPLE_LABEL, 0, 1);\n+  gimple p = gimple_build_with_ops (GIMPLE_LABEL, ERROR_MARK, 1);\n   gimple_label_set_label (p, label);\n   return p;\n }\n@@ -554,7 +554,7 @@ gimple_build_label (tree label)\n gimple\n gimple_build_goto (tree dest)\n {\n-  gimple p = gimple_build_with_ops (GIMPLE_GOTO, 0, 1);\n+  gimple p = gimple_build_with_ops (GIMPLE_GOTO, ERROR_MARK, 1);\n   gimple_goto_set_dest (p, dest);\n   return p;\n }\n@@ -600,7 +600,8 @@ gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n   gimple p;\n   int size = strlen (string);\n \n-  p = gimple_build_with_ops (GIMPLE_ASM, 0, ninputs + noutputs + nclobbers);\n+  p = gimple_build_with_ops (GIMPLE_ASM, ERROR_MARK,\n+\t\t\t     ninputs + noutputs + nclobbers);\n \n   p->gimple_asm.ni = ninputs;\n   p->gimple_asm.no = noutputs;\n@@ -776,7 +777,8 @@ static inline gimple\n gimple_build_switch_1 (unsigned nlabels, tree index, tree default_label)\n {\n   /* nlabels + 1 default label + 1 index.  */\n-  gimple p = gimple_build_with_ops (GIMPLE_SWITCH, 0, nlabels + 1 + 1);\n+  gimple p = gimple_build_with_ops (GIMPLE_SWITCH, ERROR_MARK,\n+\t\t\t\t    nlabels + 1 + 1);\n   gimple_switch_set_index (p, index);\n   gimple_switch_set_default_label (p, default_label);\n   return p;\n@@ -1046,7 +1048,7 @@ gimple_build_omp_single (gimple_seq body, tree clauses)\n gimple\n gimple_build_cdt (tree type, tree ptr)\n {\n-  gimple p = gimple_build_with_ops (GIMPLE_CHANGE_DYNAMIC_TYPE, 0, 2);\n+  gimple p = gimple_build_with_ops (GIMPLE_CHANGE_DYNAMIC_TYPE, ERROR_MARK, 2);\n   gimple_cdt_set_new_type (p, type);\n   gimple_cdt_set_location (p, ptr);\n "}, {"sha": "05c514e438eb5dc5a4aae5a594d37ec8b898934b", "filename": "gcc/gimple.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -69,7 +69,7 @@ extern void gimple_check_failed (const_gimple, const char *, int,          \\\n     const_gimple __gs = (GS);\t\t\t\t\t\t\\\n     if (gimple_code (__gs) != (CODE))\t\t\t\t\t\\\n       gimple_check_failed (__gs, __FILE__, __LINE__, __FUNCTION__,\t\\\n-\t  \t\t   (CODE), 0);\t\t\t\t\t\\\n+\t  \t\t   (CODE), ERROR_MARK);\t\t\t\t\\\n   } while (0)\n #else  /* not ENABLE_GIMPLE_CHECKING  */\n #define GIMPLE_CHECK(GS, CODE)\t\t\t(void)0\n@@ -930,7 +930,7 @@ typedef bool (*gimple_predicate)(tree);\n \n \n /* FIXME we should deduce this from the predicate.  */\n-typedef enum fallback_t {\n+enum fallback {\n   fb_none = 0,\t\t/* Do not generate a temporary.  */\n \n   fb_rvalue = 1,\t/* Generate an rvalue to hold the result of a\n@@ -942,7 +942,9 @@ typedef enum fallback_t {\n   fb_mayfail = 4,\t/* Gimplification may fail.  Error issued\n \t\t\t   afterwards.  */\n   fb_either= fb_rvalue | fb_lvalue\n-} fallback_t;\n+};\n+\n+typedef int fallback_t;\n \n enum gimplify_status {\n   GS_ERROR\t= -2,\t/* Something Bad Seen.  */"}, {"sha": "513b1fba882fc421706268e4ae6e3fc93ced0637", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* IRA hard register and memory cost calculation for allocnos.\n-   Copyright (C) 2006, 2007, 2008\n+   Copyright (C) 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n \n@@ -205,7 +205,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n     {\n       enum reg_class classes[MAX_RECOG_OPERANDS];\n       int allows_mem[MAX_RECOG_OPERANDS];\n-      int rclass;\n+      enum reg_class rclass;\n       int alt_fail = 0;\n       int alt_cost = 0, op_cost_add;\n \n@@ -672,7 +672,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t{\n \t  unsigned int regno = REGNO (ops[!i]);\n \t  enum machine_mode mode = GET_MODE (ops[!i]);\n-\t  int rclass;\n+\t  enum reg_class rclass;\n \t  unsigned int nr;\n \n \t  if (regno < FIRST_PSEUDO_REGISTER)\n@@ -886,7 +886,8 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n     case REG:\n       {\n \tstruct costs *pp;\n-\tint i, k;\n+\tenum reg_class i;\n+\tint k;\n \n \tif (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t  break;"}, {"sha": "df5e7957009cbe8d2c96f70288b25cfad92a61d1", "filename": "gcc/ira.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -515,8 +515,10 @@ setup_class_subset_and_memory_move_costs (void)\n       if (cl != (int) NO_REGS)\n \tfor (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n \t  {\n-\t    ira_memory_move_cost[mode][cl][0] = MEMORY_MOVE_COST (mode, cl, 0);\n-\t    ira_memory_move_cost[mode][cl][1] = MEMORY_MOVE_COST (mode, cl, 1);\n+\t    ira_memory_move_cost[mode][cl][0] =\n+\t      MEMORY_MOVE_COST (mode, (enum reg_class) cl, 0);\n+\t    ira_memory_move_cost[mode][cl][1] =\n+\t      MEMORY_MOVE_COST (mode, (enum reg_class) cl, 1);\n \t    /* Costs for NO_REGS are used in cost calculation on the\n \t       1st pass when the preferred register classes are not\n \t       known yet.  In this case we take the best scenario.  */\n@@ -981,8 +983,8 @@ setup_reg_class_relations (void)\n \t\t  if (cl3 == LIM_REG_CLASSES)\n \t\t    break;\n \t\t  if (reg_class_subset_p (ira_reg_class_intersect[cl1][cl2],\n-\t\t\t\t\t  cl3))\n-\t\t    ira_reg_class_intersect[cl1][cl2] = cl3;\n+\t\t\t\t\t  (enum reg_class) cl3))\n+\t\t    ira_reg_class_intersect[cl1][cl2] = (enum reg_class) cl3;\n \t\t}\n \t      ira_reg_class_union[cl1][cl2] = reg_class_subunion[cl1][cl2];\n \t      continue;\n@@ -1133,14 +1135,14 @@ int ira_max_nregs;\n static void\n setup_reg_class_nregs (void)\n {\n-  int m;\n-  enum reg_class cl;\n+  int cl, m;\n \n   ira_max_nregs = -1;\n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     for (m = 0; m < MAX_MACHINE_MODE; m++)\n       {\n-\tira_reg_class_nregs[cl][m] = CLASS_MAX_NREGS (cl, m);\n+\tira_reg_class_nregs[cl][m] = CLASS_MAX_NREGS ((enum reg_class) cl,\n+\t\t\t\t\t\t      (enum machine_mode) m);\n \tif (ira_max_nregs < ira_reg_class_nregs[cl][m])\n \t  ira_max_nregs = ira_reg_class_nregs[cl][m];\n       }\n@@ -1169,7 +1171,7 @@ setup_prohibited_class_mode_regs (void)\n \t  for (k = ira_class_hard_regs_num[cl] - 1; k >= 0; k--)\n \t    {\n \t      hard_regno = ira_class_hard_regs[cl][k];\n-\t      if (! HARD_REGNO_MODE_OK (hard_regno, j))\n+\t      if (! HARD_REGNO_MODE_OK (hard_regno, (enum machine_mode) j))\n \t\tSET_HARD_REG_BIT (prohibited_class_mode_regs[cl][j],\n \t\t\t\t  hard_regno);\n \t    }\n@@ -1306,7 +1308,7 @@ setup_prohibited_mode_move_regs (void)\n       SET_HARD_REG_SET (ira_prohibited_mode_move_regs[i]);\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n \t{\n-\t  if (! HARD_REGNO_MODE_OK (j, i))\n+\t  if (! HARD_REGNO_MODE_OK (j, (enum machine_mode) i))\n \t    continue;\n \t  SET_REGNO (test_reg1, j);\n \t  PUT_MODE (test_reg1, i);"}, {"sha": "998467103053b382b509ad7af1f624c0e4f5631a", "filename": "gcc/lists.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,7 @@\n /* List management for the GCC expander.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   1999, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -140,7 +141,7 @@ alloc_EXPR_LIST (int kind, rtx val, rtx next)\n       PUT_REG_NOTE_KIND (r, kind);\n     }\n   else\n-    r = gen_rtx_EXPR_LIST (kind, val, next);\n+    r = gen_rtx_EXPR_LIST ((enum machine_mode) kind, val, next);\n \n   return r;\n }"}, {"sha": "936a36e6a0dc32cb7134cdc7ba7d8135e9a8cecd", "filename": "gcc/machmode.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Machine mode definitions for GCC; included by rtl.h and tree.h.\n    Copyright (C) 1991, 1993, 1994, 1996, 1998, 1999, 2000, 2001, 2003,\n-   2007, 2008  Free Software Foundation, Inc.\n+   2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -41,7 +41,7 @@ enum mode_class { MODE_CLASSES, MAX_MODE_CLASS };\n    (integer, floating, complex, etc.)  */\n \n extern const unsigned char mode_class[NUM_MACHINE_MODES];\n-#define GET_MODE_CLASS(MODE)  mode_class[MODE]\n+#define GET_MODE_CLASS(MODE)  ((enum mode_class) mode_class[MODE])\n \n /* Nonzero if MODE is an integral mode.  */\n #define INTEGRAL_MODE_P(MODE)\t\t\t\\\n@@ -219,10 +219,10 @@ extern const unsigned char mode_nunits[NUM_MACHINE_MODES];\n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n \n extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n-#define GET_MODE_WIDER_MODE(MODE) mode_wider[MODE]\n+#define GET_MODE_WIDER_MODE(MODE) ((enum machine_mode) mode_wider[MODE])\n \n extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];\n-#define GET_MODE_2XWIDER_MODE(MODE) mode_2xwider[MODE]\n+#define GET_MODE_2XWIDER_MODE(MODE) ((enum machine_mode) mode_2xwider[MODE])\n \n /* Return the mode for data of a given size SIZE and mode class CLASS.\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n@@ -257,7 +257,8 @@ extern unsigned get_mode_alignment (enum machine_mode);\n /* For each class, get the narrowest mode in that class.  */\n \n extern const unsigned char class_narrowest_mode[MAX_MODE_CLASS];\n-#define GET_CLASS_NARROWEST_MODE(CLASS) class_narrowest_mode[CLASS]\n+#define GET_CLASS_NARROWEST_MODE(CLASS) \\\n+  ((enum machine_mode) class_narrowest_mode[CLASS])\n \n /* Define the integer modes whose sizes are BITS_PER_UNIT and BITS_PER_WORD\n    and the mode whose class is Pmode and whose size is POINTER_SIZE.  */"}, {"sha": "704e118429ae7c271159461343f42c419d50e081", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,3 +1,8 @@\n+2009-04-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* objc-act.c (objc_rewrite_function_call): Change parameter from\n+\tparams to first_param.  Change all callers.\n+\n 2009-03-30  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR bootstrap/39583"}, {"sha": "a45ff27b45d712959d91c4aac960b04a03a6e294", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1482,7 +1482,7 @@ start_var_decl (tree type, const char *name)\n static void\n finish_var_decl (tree var, tree initializer)\n {\n-  finish_decl (var, initializer, NULL_TREE);\n+  finish_decl (var, initializer, NULL_TREE, NULL_TREE);\n   /* Ensure that the variable actually gets output.  */\n   mark_decl_referenced (var);\n   /* Mark the decl to avoid \"defined but not used\" warning.  */\n@@ -8346,7 +8346,7 @@ objc_get_parm_info (int have_ellipsis)\n \n       TREE_CHAIN (parm_info) = NULL_TREE;\n       parm_info = pushdecl (parm_info);\n-      finish_decl (parm_info, NULL_TREE, NULL_TREE);\n+      finish_decl (parm_info, NULL_TREE, NULL_TREE, NULL_TREE);\n       parm_info = next;\n     }\n   arg_info = get_parm_info (have_ellipsis);\n@@ -8737,14 +8737,15 @@ get_super_receiver (void)\n \t/* This prevents `unused variable' warnings when compiling with -Wall.  */\n \tTREE_USED (UOBJC_SUPER_decl) = 1;\n \tlang_hooks.decls.pushdecl (UOBJC_SUPER_decl);\n-        finish_decl (UOBJC_SUPER_decl, NULL_TREE, NULL_TREE);\n+        finish_decl (UOBJC_SUPER_decl, NULL_TREE, NULL_TREE, NULL_TREE);\n \tUOBJC_SUPER_scope = objc_get_current_scope ();\n       }\n \n       /* Set receiver to self.  */\n       super_expr = objc_build_component_ref (UOBJC_SUPER_decl, self_id);\n       super_expr = build_modify_expr (input_location, \n-\t\t\t\t      super_expr, NOP_EXPR, self_decl);\n+\t\t\t\t      super_expr, NOP_EXPR, self_decl,\n+\t\t\t\t      NULL_TREE);\n       super_expr_list = super_expr;\n \n       /* Set class to begin searching.  */\n@@ -8760,7 +8761,8 @@ get_super_receiver (void)\n \t\t\t\t\t  ((TREE_CODE (objc_method_context)\n \t\t\t\t\t    == INSTANCE_METHOD_DECL)\n \t\t\t\t\t   ? ucls_super_ref\n-\t\t\t\t\t   : uucls_super_ref));\n+\t\t\t\t\t   : uucls_super_ref),\n+\t\t\t\t\t  NULL_TREE);\n \t}\n \n       else\n@@ -8810,7 +8812,8 @@ get_super_receiver (void)\n \t  super_expr\n \t    = build_modify_expr (input_location, super_expr, NOP_EXPR,\n \t\t\t\t build_c_cast (TREE_TYPE (super_expr),\n-\t\t\t\t\t       super_class));\n+\t\t\t\t\t       super_class),\n+\t\t\t\t NULL_TREE);\n \t}\n \n       super_expr_list = build_compound_expr (super_expr_list, super_expr);\n@@ -9508,7 +9511,7 @@ objc_lookup_ivar (tree other, tree id)\n    needs to be done if we are calling a function through a cast.  */\n \n tree\n-objc_rewrite_function_call (tree function, tree params)\n+objc_rewrite_function_call (tree function, tree first_param)\n {\n   if (TREE_CODE (function) == NOP_EXPR\n       && TREE_CODE (TREE_OPERAND (function, 0)) == ADDR_EXPR\n@@ -9517,7 +9520,7 @@ objc_rewrite_function_call (tree function, tree params)\n     {\n       function = build3 (OBJ_TYPE_REF, TREE_TYPE (function),\n \t\t\t TREE_OPERAND (function, 0),\n-\t\t\t TREE_VALUE (params), size_zero_node);\n+\t\t\t first_param, size_zero_node);\n     }\n \n   return function;"}, {"sha": "5a25e95c33aa00d9999cdc3be06db4ac889b5ae3", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -4561,7 +4561,8 @@ expand_omp_for (struct omp_region *region)\n \t  next_ix += BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT\n \t\t     - BUILT_IN_GOMP_LOOP_STATIC_NEXT;\n \t}\n-      expand_omp_for_generic (region, &fd, start_ix, next_ix);\n+      expand_omp_for_generic (region, &fd, (enum built_in_function) start_ix,\n+\t\t\t      (enum built_in_function) next_ix);\n     }\n \n   update_ssa (TODO_update_ssa_only_virtuals);"}, {"sha": "74c14f1d094949ab988404fa3fe672f750462093", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Expand the basic unary and binary arithmetic operations, for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -6688,7 +6688,7 @@ debug_optab_libfuncs (void)\n \trtx l;\n \n \to = &optab_table[i];\n-\tl = optab_libfunc (o, j);\n+\tl = optab_libfunc (o, (enum machine_mode) j);\n \tif (l)\n \t  {\n \t    gcc_assert (GET_CODE (l) == SYMBOL_REF);\n@@ -6708,7 +6708,8 @@ debug_optab_libfuncs (void)\n \t  rtx l;\n \n \t  o = &convert_optab_table[i];\n-\t  l = convert_optab_libfunc (o, j, k);\n+\t  l = convert_optab_libfunc (o, (enum machine_mode) j,\n+\t\t\t\t     (enum machine_mode) k);\n \t  if (l)\n \t    {\n \t      gcc_assert (GET_CODE (l) == SYMBOL_REF);"}, {"sha": "f047fc3d5411ac389bf2211ead2d260385ddebd4", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -2323,7 +2323,7 @@ enable_warning_as_error (const char *arg, int value, unsigned int lang_mask)\n     }\n   else\n     {\n-      int kind = value ? DK_ERROR : DK_WARNING;\n+      diagnostic_t kind = value ? DK_ERROR : DK_WARNING;\n       diagnostic_classify_diagnostic (global_dc, option_index, kind);\n       \n       /* -Werror=foo implies -Wfoo.  */"}, {"sha": "c87c60b6644631d447fd833257a1a58820d72755", "filename": "gcc/postreload.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,6 +1,6 @@\n /* Perform simple optimizations to clean up the result of reload.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -519,7 +519,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t{\n-\t  int rclass = (int) NO_REGS;\n+\t  enum reg_class rclass = NO_REGS;\n \n \t  if (! TEST_HARD_REG_BIT (equiv_regs[i], regno))\n \t    continue;\n@@ -580,7 +580,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t      op_alt_regno[i][j] = regno;\n \t\t    }\n \t\t  j++;\n-\t\t  rclass = (int) NO_REGS;\n+\t\t  rclass = NO_REGS;\n \t\t  break;\n \t\t}\n \t      p += CONSTRAINT_LEN (c, p);\n@@ -1610,4 +1610,3 @@ struct rtl_opt_pass pass_postreload_cse =\n   TODO_dump_func                        /* todo_flags_finish */\n  }\n };\n-"}, {"sha": "e3fc6cedf75e7f069b20ba881d98efabfd2fa154", "filename": "gcc/predict.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Branch prediction routines for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -654,7 +654,7 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n   rtx *pnote;\n   rtx note;\n   int best_probability = PROB_EVEN;\n-  int best_predictor = END_PREDICTORS;\n+  enum br_predictor best_predictor = END_PREDICTORS;\n   int combined_probability = REG_BR_PROB_BASE / 2;\n   int d;\n   bool first_match = false;\n@@ -677,7 +677,7 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     if (REG_NOTE_KIND (note) == REG_BR_PRED)\n       {\n-\tint predictor = INTVAL (XEXP (XEXP (note, 0), 0));\n+\tenum br_predictor predictor = INTVAL (XEXP (XEXP (note, 0), 0));\n \tint probability = INTVAL (XEXP (XEXP (note, 0), 1));\n \n \tfound = true;\n@@ -723,7 +723,7 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n     {\n       if (REG_NOTE_KIND (*pnote) == REG_BR_PRED)\n \t{\n-\t  int predictor = INTVAL (XEXP (XEXP (*pnote, 0), 0));\n+\t  enum br_predictor predictor = INTVAL (XEXP (XEXP (*pnote, 0), 0));\n \t  int probability = INTVAL (XEXP (XEXP (*pnote, 0), 1));\n \n \t  dump_prediction (dump_file, predictor, probability, bb,\n@@ -765,7 +765,7 @@ static void\n combine_predictions_for_bb (basic_block bb)\n {\n   int best_probability = PROB_EVEN;\n-  int best_predictor = END_PREDICTORS;\n+  enum br_predictor best_predictor = END_PREDICTORS;\n   int combined_probability = REG_BR_PROB_BASE / 2;\n   int d;\n   bool first_match = false;\n@@ -813,7 +813,7 @@ combine_predictions_for_bb (basic_block bb)\n \t by predictor with smallest index.  */\n       for (pred = (struct edge_prediction *) *preds; pred; pred = pred->ep_next)\n \t{\n-\t  int predictor = pred->ep_predictor;\n+\t  enum br_predictor predictor = pred->ep_predictor;\n \t  int probability = pred->ep_probability;\n \n \t  if (pred->ep_edge != first)\n@@ -888,7 +888,7 @@ combine_predictions_for_bb (basic_block bb)\n     {\n       for (pred = (struct edge_prediction *) *preds; pred; pred = pred->ep_next)\n \t{\n-\t  int predictor = pred->ep_predictor;\n+\t  enum br_predictor predictor = pred->ep_predictor;\n \t  int probability = pred->ep_probability;\n \n \t  if (pred->ep_edge != EDGE_SUCC (bb, 0))\n@@ -2185,7 +2185,7 @@ build_predict_expr (enum br_predictor predictor, enum prediction taken)\n {\n   tree t = build1 (PREDICT_EXPR, void_type_node,\n \t\t   build_int_cst (NULL, predictor));\n-  PREDICT_EXPR_OUTCOME (t) = taken;\n+  SET_PREDICT_EXPR_OUTCOME (t, taken);\n   return t;\n }\n "}, {"sha": "1a63ecdb140ef385e2975e2911fee9f67222369b", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1000,7 +1000,7 @@ real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n   enum tree_code code = icode;\n \n   if (op0->decimal || (op1 && op1->decimal))\n-    return decimal_real_arithmetic (r, icode, op0, op1);\n+    return decimal_real_arithmetic (r, code, op0, op1);\n \n   switch (code)\n     {"}, {"sha": "5ab67ef5b00a90819ccbce1a178a4ab1e9496315", "filename": "gcc/reginfo.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -277,7 +277,8 @@ init_move_cost (enum machine_mode m)\n \t    cost = 65535;\n \t  else\n \t    {\n-\t      cost = REGISTER_MOVE_COST (m, i, j);\n+\t      cost = REGISTER_MOVE_COST (m, (enum reg_class) i,\n+\t\t\t\t\t (enum reg_class) j);\n \t      gcc_assert (cost < 65535);\n \t    }\n \t  all_match &= (last_move_cost[i][j] == cost);\n@@ -327,12 +328,12 @@ init_move_cost (enum machine_mode m)\n \t      gcc_assert (cost <= 65535);\n \t      move_cost[m][i][j] = cost;\n \n-\t      if (reg_class_subset_p (i, j))\n+\t      if (reg_class_subset_p ((enum reg_class) i, (enum reg_class) j))\n \t\tmay_move_in_cost[m][i][j] = 0;\n \t      else\n \t\tmay_move_in_cost[m][i][j] = cost;\n \n-\t      if (reg_class_subset_p (j, i))\n+\t      if (reg_class_subset_p ((enum reg_class) j, (enum reg_class) i))\n \t\tmay_move_out_cost[m][i][j] = 0;\n \t      else\n \t\tmay_move_out_cost[m][i][j] = cost;\n@@ -589,11 +590,13 @@ init_reg_sets_1 (void)\n       HARD_REG_SET ok_regs;\n       CLEAR_HARD_REG_SET (ok_regs);\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (!fixed_regs [j] && HARD_REGNO_MODE_OK (j, m))\n+\tif (!fixed_regs [j] && HARD_REGNO_MODE_OK (j, (enum machine_mode) m))\n \t  SET_HARD_REG_BIT (ok_regs, j);\n-      \n+\n       for (i = 0; i < N_REG_CLASSES; i++)\n-\tif ((unsigned) CLASS_MAX_NREGS (i, m) <= reg_class_size[i]\n+\tif (((unsigned) CLASS_MAX_NREGS ((enum reg_class) i,\n+\t\t\t\t\t (enum machine_mode) m)\n+\t     <= reg_class_size[i])\n \t    && hard_reg_set_intersect_p (ok_regs, reg_class_contents[i]))\n \t  {\n \t     contains_reg_of_mode [i][m] = 1;\n@@ -676,9 +679,9 @@ void\n init_fake_stack_mems (void)\n {\n   int i;\n-  \n+\n   for (i = 0; i < MAX_MACHINE_MODE; i++)\n-    top_of_stack[i] = gen_rtx_MEM (i, stack_pointer_rtx);\n+    top_of_stack[i] = gen_rtx_MEM ((enum machine_mode) i, stack_pointer_rtx);\n }\n \n "}, {"sha": "53618b2193c1c2260a0e2c352889e6a28fc5084b", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -58,13 +58,12 @@ struct match {\n };\n \n static int find_matches (rtx, struct match *);\n-static int regclass_compatible_p (int, int);\n static int fixup_match_2 (rtx, rtx, rtx, rtx);\n \n /* Return nonzero if registers with CLASS1 and CLASS2 can be merged without\n    causing too much register allocation problems.  */\n static int\n-regclass_compatible_p (int class0, int class1)\n+regclass_compatible_p (enum reg_class class0, enum reg_class class1)\n {\n   return (class0 == class1\n \t  || (reg_class_subset_p (class0, class1)\n@@ -1353,4 +1352,3 @@ struct rtl_opt_pass pass_regmove =\n   TODO_ggc_collect                      /* todo_flags_finish */\n  }\n };\n-"}, {"sha": "6181224e74784fb774dbf92e79ec7484f6df8871", "filename": "gcc/reload.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -685,15 +685,16 @@ find_valid_class (enum machine_mode outer ATTRIBUTE_UNUSED,\n \n       if (bad || !good)\n \tcontinue;\n-      cost = REGISTER_MOVE_COST (outer, rclass, dest_class);\n+      cost = REGISTER_MOVE_COST (outer, (enum reg_class) rclass, dest_class);\n \n       if ((reg_class_size[rclass] > best_size\n \t   && (best_cost < 0 || best_cost >= cost))\n \t  || best_cost > cost)\n \t{\n \t  best_class = rclass;\n \t  best_size = reg_class_size[rclass];\n-\t  best_cost = REGISTER_MOVE_COST (outer, rclass, dest_class);\n+\t  best_cost = REGISTER_MOVE_COST (outer, (enum reg_class) rclass,\n+\t\t\t\t\t  dest_class);\n \t}\n     }\n \n@@ -1516,7 +1517,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t value for the incoming operand (same as outgoing one).  */\n       if (rld[i].reg_rtx == out\n \t  && (REG_P (in) || CONSTANT_P (in))\n-\t  && 0 != find_equiv_reg (in, this_insn, 0, REGNO (out),\n+\t  && 0 != find_equiv_reg (in, this_insn, NO_REGS, REGNO (out),\n \t\t\t\t  static_reload_reg_p, i, inmode))\n \trld[i].in = out;\n     }\n@@ -2565,7 +2566,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   enum reload_usage { RELOAD_READ, RELOAD_READ_WRITE, RELOAD_WRITE } modified[MAX_RECOG_OPERANDS];\n   int no_input_reloads = 0, no_output_reloads = 0;\n   int n_alternatives;\n-  int this_alternative[MAX_RECOG_OPERANDS];\n+  enum reg_class this_alternative[MAX_RECOG_OPERANDS];\n   char this_alternative_match_win[MAX_RECOG_OPERANDS];\n   char this_alternative_win[MAX_RECOG_OPERANDS];\n   char this_alternative_offmemok[MAX_RECOG_OPERANDS];\n@@ -3059,7 +3060,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\tforce_reload = 1;\n \t    }\n \n-\t  this_alternative[i] = (int) NO_REGS;\n+\t  this_alternative[i] = NO_REGS;\n \t  this_alternative_win[i] = 0;\n \t  this_alternative_match_win[i] = 0;\n \t  this_alternative_offmemok[i] = 0;\n@@ -3146,7 +3147,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t       this combination, because we can't reload it.  */\n \t\t    if (this_alternative_offmemok[m]\n \t\t\t&& MEM_P (recog_data.operand[m])\n-\t\t\t&& this_alternative[m] == (int) NO_REGS\n+\t\t\t&& this_alternative[m] == NO_REGS\n \t\t\t&& ! this_alternative_win[m])\n \t\t      bad = 1;\n \n@@ -3162,7 +3163,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t    if (this_alternative_win[m])\n \t\t      losers++;\n \t\t    this_alternative_win[m] = 0;\n-\t\t    if (this_alternative[m] == (int) NO_REGS)\n+\t\t    if (this_alternative[m] == NO_REGS)\n \t\t      bad = 1;\n \t\t    /* But count the pair only once in the total badness of\n \t\t       this alternative, if the pair can be a dummy reload.\n@@ -3211,8 +3212,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t      case 'p':\n \t\t/* All necessary reloads for an address_operand\n \t\t   were handled in find_reloads_address.  */\n-\t\tthis_alternative[i]\n-\t\t  = (int) base_reg_class (VOIDmode, ADDRESS, SCRATCH);\n+\t\tthis_alternative[i] = base_reg_class (VOIDmode, ADDRESS,\n+\t\t\t\t\t\t      SCRATCH);\n \t\twin = 1;\n \t\tbadop = 0;\n \t\tbreak;\n@@ -3371,7 +3372,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t      case 'r':\n \t\tthis_alternative[i]\n-\t\t  = (int) reg_class_subunion[this_alternative[i]][(int) GENERAL_REGS];\n+\t\t  = reg_class_subunion[this_alternative[i]][(int) GENERAL_REGS];\n \t\tgoto reg;\n \n \t      default:\n@@ -3417,8 +3418,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t\t\t/* If we didn't already win, we can reload\n \t\t\t   the address into a base register.  */\n-\t\t\tthis_alternative[i]\n-\t\t\t  = (int) base_reg_class (VOIDmode, ADDRESS, SCRATCH);\n+\t\t\tthis_alternative[i] = base_reg_class (VOIDmode,\n+\t\t\t\t\t\t\t      ADDRESS,\n+\t\t\t\t\t\t\t      SCRATCH);\n \t\t\tbadop = 0;\n \t\t\tbreak;\n \t\t      }\n@@ -3430,9 +3432,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t  }\n \n \t\tthis_alternative[i]\n-\t\t  = (int) (reg_class_subunion\n-\t\t\t   [this_alternative[i]]\n-\t\t\t   [(int) REG_CLASS_FROM_CONSTRAINT (c, p)]);\n+\t\t  = (reg_class_subunion\n+\t\t     [this_alternative[i]]\n+\t\t     [(int) REG_CLASS_FROM_CONSTRAINT (c, p)]);\n \t      reg:\n \t\tif (GET_MODE (operand) == BLKmode)\n \t\t  break;\n@@ -3449,7 +3451,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t  /* If this operand could be handled with a reg,\n \t     and some reg is allowed, then this operand can be handled.  */\n-\t  if (winreg && this_alternative[i] != (int) NO_REGS)\n+\t  if (winreg && this_alternative[i] != NO_REGS)\n \t    badop = 0;\n \n \t  /* Record which operands fit this alternative.  */\n@@ -3468,7 +3470,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\tbad = 1;\n \t      /* Alternative loses if it has no regs for a reg operand.  */\n \t      if (REG_P (operand)\n-\t\t  && this_alternative[i] == (int) NO_REGS\n+\t\t  && this_alternative[i] == NO_REGS\n \t\t  && this_alternative_matches[i] < 0)\n \t\tbad = 1;\n \n@@ -3481,14 +3483,13 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t precisely the same as in the code below that calls\n \t\t force_const_mem.  */\n \t      if (CONST_POOL_OK_P (operand)\n-\t\t  && ((PREFERRED_RELOAD_CLASS (operand,\n-\t\t\t\t\t       (enum reg_class) this_alternative[i])\n+\t\t  && ((PREFERRED_RELOAD_CLASS (operand, this_alternative[i])\n \t\t       == NO_REGS)\n \t\t      || no_input_reloads)\n \t\t  && operand_mode[i] != VOIDmode)\n \t\t{\n \t\t  const_to_mem = 1;\n-\t\t  if (this_alternative[i] != (int) NO_REGS)\n+\t\t  if (this_alternative[i] != NO_REGS)\n \t\t    losers++;\n \t\t}\n \n@@ -3508,19 +3509,17 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t LIMIT_RELOAD_CLASS, but we don't check that\n \t\t here.  */\n \n-\t      if (! CONSTANT_P (operand)\n-\t\t  && (enum reg_class) this_alternative[i] != NO_REGS)\n+\t      if (! CONSTANT_P (operand) && this_alternative[i] != NO_REGS)\n \t\t{\n-\t\t  if (PREFERRED_RELOAD_CLASS\n-\t\t\t(operand, (enum reg_class) this_alternative[i])\n+\t\t  if (PREFERRED_RELOAD_CLASS (operand, this_alternative[i])\n \t\t      == NO_REGS)\n \t\t    reject = 600;\n \n #ifdef PREFERRED_OUTPUT_RELOAD_CLASS\n \t\t  if (operand_type[i] == RELOAD_FOR_OUTPUT\n-\t\t      && PREFERRED_OUTPUT_RELOAD_CLASS\n-\t\t\t   (operand, (enum reg_class) this_alternative[i])\n-\t\t         == NO_REGS)\n+\t\t      && (PREFERRED_OUTPUT_RELOAD_CLASS (operand,\n+\t\t\t\t\t\t\tthis_alternative[i])\n+\t\t\t  == NO_REGS))\n \t\t    reject = 600;\n #endif\n \t\t}\n@@ -3568,7 +3567,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t     because we might otherwise exhaust the class.  */\n \n \t  if (! win && ! did_match\n-\t      && this_alternative[i] != (int) NO_REGS\n+\t      && this_alternative[i] != NO_REGS\n \t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n \t      && reg_class_size [(int) preferred_class[i]] > 0\n \t      && ! SMALL_REGISTER_CLASS_P (preferred_class[i]))\n@@ -3582,7 +3581,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t     common case anyway.  */\n \t\t  if (reg_class_subset_p (preferred_class[i],\n \t\t\t\t\t  this_alternative[i]))\n-\t\t    this_alternative[i] = (int) preferred_class[i];\n+\t\t    this_alternative[i] = preferred_class[i];\n \t\t  else\n \t\t    reject += (2 + 2 * pref_or_nothing[i]);\n \t\t}\n@@ -4767,7 +4766,8 @@ make_memloc (rtx ad, int regno)\n   /* We must rerun eliminate_regs, in case the elimination\n      offsets have changed.  */\n   rtx tem\n-    = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0, NULL_RTX), 0);\n+    = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], VOIDmode, NULL_RTX),\n+\t    0);\n \n   /* If TEM might contain a pseudo, we must copy it to avoid\n      modifying it when we do the substitution for the reload.  */"}, {"sha": "d31578d96ab51ec5cec4921838bebf8b3b64e932", "filename": "gcc/reload1.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -997,7 +997,8 @@ reload (rtx first, int global)\n       for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n \tif (reg_renumber[i] < 0 && reg_equiv_memory_loc[i])\n \t  {\n-\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], 0, NULL_RTX);\n+\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], VOIDmode,\n+\t\t\t\t    NULL_RTX);\n \n \t    if (strict_memory_address_p (GET_MODE (regno_reg_rtx[i]),\n \t\t\t\t\t XEXP (x, 0)))\n@@ -2809,7 +2810,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \n     case USE:\n       /* Handle insn_list USE that a call to a pure function may generate.  */\n-      new_rtx = eliminate_regs_1 (XEXP (x, 0), 0, insn, false);\n+      new_rtx = eliminate_regs_1 (XEXP (x, 0), VOIDmode, insn, false);\n       if (new_rtx != XEXP (x, 0))\n \treturn gen_rtx_USE (GET_MODE (x), new_rtx);\n       return x;\n@@ -3050,8 +3051,8 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n \t      }\n \t}\n \n-      elimination_effects (SET_DEST (x), 0);\n-      elimination_effects (SET_SRC (x), 0);\n+      elimination_effects (SET_DEST (x), VOIDmode);\n+      elimination_effects (SET_SRC (x), VOIDmode);\n       return;\n \n     case MEM:\n@@ -3349,7 +3350,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n     }\n \n   /* Determine the effects of this insn on elimination offsets.  */\n-  elimination_effects (old_body, 0);\n+  elimination_effects (old_body, VOIDmode);\n \n   /* Eliminate all eliminable registers occurring in operands that\n      can be handled by reload.  */\n@@ -3390,7 +3391,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t    in_plus = true;\n \n \t  substed_operand[i]\n-\t    = eliminate_regs_1 (recog_data.operand[i], 0,\n+\t    = eliminate_regs_1 (recog_data.operand[i], VOIDmode,\n \t\t\t        replace ? insn : NULL_RTX,\n \t\t\t\tis_set_src || in_plus);\n \t  if (substed_operand[i] != orig_operand[i])\n@@ -3520,7 +3521,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n      the pre-passes.  */\n   if (val && REG_NOTES (insn) != 0)\n     REG_NOTES (insn)\n-      = eliminate_regs_1 (REG_NOTES (insn), 0, REG_NOTES (insn), true);\n+      = eliminate_regs_1 (REG_NOTES (insn), VOIDmode, REG_NOTES (insn), true);\n \n   return val;\n }\n@@ -7087,7 +7088,8 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t  else if (new_class == NO_REGS)\n \t    {\n \t      if (reload_adjust_reg_for_icode (&second_reload_reg,\n-\t\t\t\t\t       third_reload_reg, sri.icode))\n+\t\t\t\t\t       third_reload_reg,\n+\t\t\t\t\t       (enum insn_code) sri.icode))\n \t\ticode = sri.icode, third_reload_reg = 0;\n \t      else\n \t\toldequiv = old, real_oldequiv = real_old;\n@@ -7117,7 +7119,8 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t  if (reload_adjust_reg_for_temp (&intermediate, NULL,\n \t\t\t\t\t\t  new_class, mode)\n \t\t      && reload_adjust_reg_for_icode (&third_reload_reg, NULL,\n-\t\t\t\t\t\t      sri2.icode))\n+\t\t\t\t\t\t      ((enum insn_code)\n+\t\t\t\t\t\t       sri2.icode)))\n \t\t    {\n \t\t      second_reload_reg = intermediate;\n \t\t      tertiary_icode = sri2.icode;\n@@ -8414,7 +8417,7 @@ delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n \t\t\t\t\treg, 0);\n   if (substed)\n     n_occurrences += count_occurrences (PATTERN (insn),\n-\t\t\t\t\teliminate_regs (substed, 0,\n+\t\t\t\t\teliminate_regs (substed, VOIDmode,\n \t\t\t\t\t\t\tNULL_RTX), 0);\n   for (i1 = reg_equiv_alt_mem_list[REGNO (reg)]; i1; i1 = XEXP (i1, 1))\n     {"}, {"sha": "059bf755e7967062f32d89406670fb64d7cdc362", "filename": "gcc/reorg.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -318,7 +318,10 @@ insn_sets_resource_p (rtx insn, struct resources *res,\n   struct resources insn_sets;\n \n   CLEAR_RESOURCE (&insn_sets);\n-  mark_set_resources (insn, &insn_sets, 0, include_delayed_effects);\n+  mark_set_resources (insn, &insn_sets, 0,\n+\t\t      (include_delayed_effects\n+\t\t       ? MARK_SRC_DEST_CALL\n+\t\t       : MARK_SRC_DEST));\n   return resource_conflicts_p (&insn_sets, res);\n }\n \f"}, {"sha": "a907d51d684d49fed601b5018ca21627d1e17d26", "filename": "gcc/stub-objc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstub-objc.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -2,7 +2,7 @@\n    that are called from within the C and C++ front-ends,\n    respectively.\n    Copyright (C) 1991, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n-   2004, 2005, 2007  Free Software Foundation, Inc.\n+   2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -81,7 +81,7 @@ objc_type_quals_match (tree ARG_UNUSED (ltyp), tree ARG_UNUSED (rtyp))\n }\n \n tree\n-objc_rewrite_function_call (tree function, tree ARG_UNUSED (params))\n+objc_rewrite_function_call (tree function, tree ARG_UNUSED (first_param))\n {\n   return function;\n }"}, {"sha": "f3d3361e2336623a2034cc093fba4d01882eb1c1", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -553,10 +553,12 @@ struct gcc_target\n \t\t\t  enum machine_mode mode, int ignore);\n \n   /* Select a replacement for a target-specific builtin.  This is done\n-     *before* regular type checking, and so allows the target to implement\n-     a crude form of function overloading.  The result is a complete\n-     expression that implements the operation.  */\n-  tree (*resolve_overloaded_builtin) (tree decl, tree params);\n+     *before* regular type checking, and so allows the target to\n+     implement a crude form of function overloading.  The result is a\n+     complete expression that implements the operation.  PARAMS really\n+     has type VEC(tree,gc)*, but we don't want to include tree.h\n+     here.  */\n+  tree (*resolve_overloaded_builtin) (tree decl, void *params);\n \n   /* Fold a target-specific builtin.  */\n   tree (* fold_builtin) (tree fndecl, tree arglist, bool ignore);"}, {"sha": "aba13101c69eba5e19d0643279586e0bebf9fd7d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,3 +1,7 @@\n+2009-04-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Wcxx-compat-3.c: New testcase.\n+\n 2009-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/pack13.ad[sb]: New test."}, {"sha": "306167314e8d2bf7debd59e09848831961429c6d", "filename": "gcc/testsuite/gcc.dg/Wcxx-compat-3.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-3.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wc++-compat\" } */\n+enum E1 { A, B, C };\n+enum E2 { D, E, F };\n+extern void f2 (enum E1);\n+\n+void\n+f1 ()\n+{\n+  int a = A;\n+  enum E1 e1;\n+  enum E2 e2;\n+\n+  f2 (0);\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+  f2 (A);\n+  f2 (D);\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+  f2 (a);\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+  f2 (e1);\n+  f2 (e2);\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+  f2 ((A));\n+  f2 (a ? A : B);\n+  f2 ((enum E1) 0);\n+  f2 ((enum E1) D);\n+  f2 ((enum E1) a);\n+  f2 ((enum E1) e2);\n+}\n+\n+struct s1 { enum E1 e1 : 3; };\n+struct s2 { enum E2 e2 : 3; };\n+\n+void\n+f3 (struct s1 sv1, struct s2 sv2)\n+{\n+  f2 (sv1.e1);\n+  f2 (sv2.e2);\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+}\n+\n+void\n+f4 (struct s1 *pv1, struct s2 *pv2)\n+{\n+  f2 (pv1->e1);\n+  f2 (pv2->e2);\t/* { dg-warning \"invalid in C\\[+\\]\\[+\\]\" } */\n+}\n+\n+/* Match all extra informative notes.  */\n+/* { dg-message \"note: expected '\\[^\\n'\\]*' but argument is of type '\\[^\\n'\\]*'\" \"note: expected\" { target *-*-* } 0 } */"}, {"sha": "893da7ab1048ab7dff1cb78a310123da28d08226", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>\n \n@@ -855,11 +855,11 @@ dump_register (const char *suffix, const char *swtch, const char *glob,\n /* Return the dump_file_info for the given phase.  */\n \n struct dump_file_info *\n-get_dump_file_info (enum tree_dump_index phase)\n+get_dump_file_info (int phase)\n {\n   if (phase < TDI_end)\n     return &dump_files[phase];\n-  else if (phase - TDI_end >= extra_dump_files_in_use)\n+  else if ((size_t) (phase - TDI_end) >= extra_dump_files_in_use)\n     return NULL;\n   else\n     return extra_dump_files + (phase - TDI_end);\n@@ -870,7 +870,7 @@ get_dump_file_info (enum tree_dump_index phase)\n    If the dump is not enabled, returns NULL.  */\n \n char *\n-get_dump_file_name (enum tree_dump_index phase)\n+get_dump_file_name (int phase)\n {\n   char dump_id[10];\n   struct dump_file_info *dfi;\n@@ -907,7 +907,7 @@ get_dump_file_name (enum tree_dump_index phase)\n    Multiple calls will reopen and append to the dump file.  */\n \n FILE *\n-dump_begin (enum tree_dump_index phase, int *flag_ptr)\n+dump_begin (int phase, int *flag_ptr)\n {\n   char *name;\n   struct dump_file_info *dfi;\n@@ -935,7 +935,7 @@ dump_begin (enum tree_dump_index phase, int *flag_ptr)\n    TDI_tree_all, return nonzero if any dump is enabled.  */\n \n int\n-dump_enabled_p (enum tree_dump_index phase)\n+dump_enabled_p (int phase)\n {\n   if (phase == TDI_tree_all)\n     {\n@@ -958,7 +958,7 @@ dump_enabled_p (enum tree_dump_index phase)\n /* Returns nonzero if tree dump PHASE has been initialized.  */\n \n int\n-dump_initialized_p (enum tree_dump_index phase)\n+dump_initialized_p (int phase)\n {\n   struct dump_file_info *dfi = get_dump_file_info (phase);\n   return dfi->state > 0;\n@@ -967,7 +967,7 @@ dump_initialized_p (enum tree_dump_index phase)\n /* Returns the switch name of PHASE.  */\n \n const char *\n-dump_flag_name (enum tree_dump_index phase)\n+dump_flag_name (int phase)\n {\n   struct dump_file_info *dfi = get_dump_file_info (phase);\n   return dfi->swtch;\n@@ -977,7 +977,7 @@ dump_flag_name (enum tree_dump_index phase)\n    dump_begin.  */\n \n void\n-dump_end (enum tree_dump_index phase ATTRIBUTE_UNUSED, FILE *stream)\n+dump_end (int phase ATTRIBUTE_UNUSED, FILE *stream)\n {\n   fclose (stream);\n }\n@@ -1098,7 +1098,7 @@ dump_switch_p (const char *arg)\n /* Dump FUNCTION_DECL FN as tree dump PHASE.  */\n \n void\n-dump_function (enum tree_dump_index phase, tree fn)\n+dump_function (int phase, tree fn)\n {\n   FILE *stream;\n   int flags;\n@@ -1116,5 +1116,3 @@ enable_rtl_dump_file (void)\n {\n   return dump_enable_all (TDF_RTL | TDF_DETAILS | TDF_BLOCKS) > 0;\n }\n-\n-"}, {"sha": "558e1c1c952375f8fc4204a4226c631449365746", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1,5 +1,5 @@\n /* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 1999, 2000, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>\n \n@@ -89,7 +89,7 @@ extern void dump_string_field (dump_info_p, const char *, const char *);\n extern void dump_stmt (dump_info_p, const_tree);\n extern void queue_and_dump_index (dump_info_p, const char *, const_tree, int);\n extern void queue_and_dump_type (dump_info_p, const_tree);\n-extern void dump_function (enum tree_dump_index, tree);\n+extern void dump_function (int, tree);\n extern void dump_function_to_file (tree, FILE *, int);\n extern void debug_function (tree, int);\n extern int dump_flag (dump_info_p, int, const_tree);"}, {"sha": "cb95fe61a9a794628d8b4eebb8da9d07dac7e4c0", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -77,22 +77,22 @@ enum tree_dump_index\n \t\t\t\t\t   a gimple stmt.  */\n /* In tree-dump.c */\n \n-extern char *get_dump_file_name (enum tree_dump_index);\n-extern int dump_enabled_p (enum tree_dump_index);\n-extern int dump_initialized_p (enum tree_dump_index);\n-extern FILE *dump_begin (enum tree_dump_index, int *);\n-extern void dump_end (enum tree_dump_index, FILE *);\n+extern char *get_dump_file_name (int);\n+extern int dump_enabled_p (int);\n+extern int dump_initialized_p (int);\n+extern FILE *dump_begin (int, int *);\n+extern void dump_end (int, FILE *);\n extern void dump_node (const_tree, int, FILE *);\n extern int dump_switch_p (const char *);\n-extern const char *dump_flag_name (enum tree_dump_index);\n+extern const char *dump_flag_name (int);\n \n /* Global variables used to communicate with passes.  */\n extern FILE *dump_file;\n extern int dump_flags;\n extern const char *dump_file_name;\n \n /* Return the dump_file_info for the given phase.  */\n-extern struct dump_file_info *get_dump_file_info (enum tree_dump_index);\n+extern struct dump_file_info *get_dump_file_info (int);\n \n /* Describe one pass; this is the common part shared across different pass\n    types.  */"}, {"sha": "5e2ee38e4ef538a0bf6313f92b1de83e7ee55d68", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -1124,7 +1124,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n   (CASE_LABEL_EXPR_CHECK (NODE)->base.addressable_flag)\n \n #define PREDICT_EXPR_OUTCOME(NODE) \\\n-  (PREDICT_EXPR_CHECK(NODE)->base.addressable_flag)\n+  ((enum prediction) (PREDICT_EXPR_CHECK(NODE)->base.addressable_flag))\n+#define SET_PREDICT_EXPR_OUTCOME(NODE, OUTCOME) \\\n+  (PREDICT_EXPR_CHECK(NODE)->base.addressable_flag = (int) OUTCOME)\n #define PREDICT_EXPR_PREDICTOR(NODE) \\\n   ((enum br_predictor)tree_low_cst (TREE_OPERAND (PREDICT_EXPR_CHECK (NODE), 0), 0))\n "}, {"sha": "9a611e0164ff99316d8406f6b30b05d99e3faea1", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbbb16a888987aea0b85ce1133cf1dac4557ecc/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=bbbbb16a888987aea0b85ce1133cf1dac4557ecc", "patch": "@@ -2637,7 +2637,7 @@ assemble_integer (rtx x, unsigned int size, unsigned int align, int force)\n       enum machine_mode omode, imode;\n       unsigned int subalign;\n       unsigned int subsize, i;\n-      unsigned char mclass;\n+      enum mode_class mclass;\n \n       subsize = size > UNITS_PER_WORD? UNITS_PER_WORD : 1;\n       subalign = MIN (align, subsize * BITS_PER_UNIT);"}]}