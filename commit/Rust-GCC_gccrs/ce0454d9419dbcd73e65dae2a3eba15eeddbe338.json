{"sha": "ce0454d9419dbcd73e65dae2a3eba15eeddbe338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UwNDU0ZDk0MTlkYmNkNzNlNjVkYWUyYTNlYmExNWVlZGRiZTMzOA==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2019-08-01T17:14:53Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2019-08-01T17:14:53Z"}, "message": "sort.cc: introduce gcc_sort_r\n\n\t* sort.cc (sort_r_ctx): New struct.\n\t(reorder23): Make templated on context type.\n\t(reorder45): Ditto.\n\t(cmp1): Ditto.  Adjust signature.\n\t(netsort): Ditto.\n\t(mergesort): Ditto.\n\t[CHECKING_P] (cmp2to3): New static function.  Use it...\n\t(gcc_qsort) [CHECKING_P]: ...here.\n\t(gcc_sort_r): New function.\n\t* system.h (sort_r_cmp_fn): New function typedef.\n\t(qsort_chk): Adjust signature.\n\t(gcc_sort_r): Declare.\n\t* vec.c (qsort_chk_error): Adjust.\n\t(qsort_chk): Adjust.\n\nFrom-SVN: r273977", "tree": {"sha": "77afb8b4e0b9aa4081ff1695ebd5ff725a38b365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77afb8b4e0b9aa4081ff1695ebd5ff725a38b365"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce0454d9419dbcd73e65dae2a3eba15eeddbe338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce0454d9419dbcd73e65dae2a3eba15eeddbe338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce0454d9419dbcd73e65dae2a3eba15eeddbe338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f339eb66071559a02a0c05b3ee89fc8352969bc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f339eb66071559a02a0c05b3ee89fc8352969bc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f339eb66071559a02a0c05b3ee89fc8352969bc9"}], "stats": {"total": 107, "additions": 89, "deletions": 18}, "files": [{"sha": "e6a5b20451f08ae64dc956127df587d9c98a13f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce0454d9419dbcd73e65dae2a3eba15eeddbe338", "patch": "@@ -1,3 +1,20 @@\n+2019-08-01  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* sort.cc (sort_r_ctx): New struct.\n+\t(reorder23): Make templated on context type.\n+\t(reorder45): Ditto.\n+\t(cmp1): Ditto.  Adjust signature.\n+\t(netsort): Ditto.\n+\t(mergesort): Ditto.\n+\t[CHECKING_P] (cmp2to3): New static function.  Use it...\n+\t(gcc_qsort) [CHECKING_P]: ...here.\n+\t(gcc_sort_r): New function.\n+\t* system.h (sort_r_cmp_fn): New function typedef.\n+\t(qsort_chk): Adjust signature.\n+\t(gcc_sort_r): Declare.\n+\t* vec.c (qsort_chk_error): Adjust.\n+\t(qsort_chk): Adjust.\n+\n 2019-08-01  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (has_abnormal_preds): Remove global var."}, {"sha": "73a9f7ed7c5bf751279a506d9fa15a56d19cae0a", "filename": "gcc/sort.cc", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/gcc%2Fsort.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/gcc%2Fsort.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsort.cc?ref=ce0454d9419dbcd73e65dae2a3eba15eeddbe338", "patch": "@@ -58,8 +58,25 @@ struct sort_ctx\n   size_t nlim; // limit for network sort\n };\n \n+/* Like sort_ctx, but for use with qsort_r-style comparators.  Several\n+   functions in this file are templates that work with either context type.  */\n+struct sort_r_ctx\n+{\n+  void          *data;\n+  sort_r_cmp_fn *cmp_;\n+  char   *out;\n+  size_t n;\n+  size_t size;\n+  size_t nlim;\n+  int cmp (const void *a, const void *b)\n+  {\n+    return cmp_ (a, b, data);\n+  }\n+};\n+\n /* Helper for netsort. Permute, possibly in-place, 2 or 3 elements,\n    placing E0 to C->OUT, E1 to C->OUT + C->SIZE, and so on.  */\n+template<typename sort_ctx>\n static void\n reorder23 (sort_ctx *c, char *e0, char *e1, char *e2)\n {\n@@ -90,6 +107,7 @@ do {                                                     \\\n }\n \n /* Like reorder23, but permute 4 or 5 elements.  */\n+template<typename sort_ctx>\n static void\n reorder45 (sort_ctx *c, char *e0, char *e1, char *e2, char *e3, char *e4)\n {\n@@ -127,21 +145,23 @@ do {                                                     \\\n    Return E0^E1 if E0 compares less than E1, zero otherwise.\n    This is noinline to avoid code growth and confine invocation\n    to a single call site, assisting indirect branch prediction.  */\n+template<typename sort_ctx>\n noinline static intptr_t\n-cmp1 (char *e0, char *e1, cmp_fn *cmp)\n+cmp1 (char *e0, char *e1, sort_ctx *c)\n {\n   intptr_t x = (intptr_t)e0 ^ (intptr_t)e1;\n-  return x & (cmp (e0, e1) >> 31);\n+  return x & (c->cmp (e0, e1) >> 31);\n }\n \n /* Execute network sort on 2 to 5 elements from IN, placing them into C->OUT.\n    IN may be equal to C->OUT, in which case elements are sorted in place.  */\n+template<typename sort_ctx>\n static void\n netsort (char *in, sort_ctx *c)\n {\n #define CMP(e0, e1)                   \\\n do {                                  \\\n-  intptr_t x = cmp1 (e1, e0, c->cmp); \\\n+  intptr_t x = cmp1 (e1, e0, c);      \\\n   e0 = (char *)((intptr_t)e0 ^ x);    \\\n   e1 = (char *)((intptr_t)e1 ^ x);    \\\n } while (0)\n@@ -176,6 +196,7 @@ do {                                  \\\n /* Execute merge sort on N elements from IN, placing them into OUT,\n    using TMP as temporary storage if IN is equal to OUT.\n    This is a stable sort if netsort is used only for 2 or 3 elements.  */\n+template<typename sort_ctx>\n static void\n mergesort (char *in, sort_ctx *c, size_t n, char *out, char *tmp)\n {\n@@ -217,6 +238,17 @@ do {                                            \\\n   memcpy (out, l, r - out);\n }\n \n+#if CHECKING_P\n+/* Adapter for using two-argument comparators in functions expecting the\n+   three-argument sort_r_cmp_fn type.  */\n+static int\n+cmp2to3 (const void *a, const void *b, void *c)\n+{\n+  return ((cmp_fn *)c) (a, b);\n+}\n+#endif\n+\n+/* Replacement for C qsort.  */\n void\n gcc_qsort (void *vbase, size_t n, size_t size, cmp_fn *cmp)\n {\n@@ -235,10 +267,30 @@ gcc_qsort (void *vbase, size_t n, size_t size, cmp_fn *cmp)\n   if (buf != scratch)\n     free (buf);\n #if CHECKING_P\n-  qsort_chk (vbase, n, size, cmp);\n+  qsort_chk (vbase, n, size, cmp2to3, (void*)cmp);\n+#endif\n+}\n+\n+/* Substitute for Glibc qsort_r.  */\n+void\n+gcc_sort_r (void *vbase, size_t n, size_t size, sort_r_cmp_fn *cmp, void *data)\n+{\n+  if (n < 2)\n+    return;\n+  char *base = (char *)vbase;\n+  sort_r_ctx c = {data, cmp, base, n, size, 5};\n+  long long scratch[32];\n+  size_t bufsz = (n / 2) * size;\n+  void *buf = bufsz <= sizeof scratch ? scratch : xmalloc (bufsz);\n+  mergesort (base, &c, n, base, (char *)buf);\n+  if (buf != scratch)\n+    free (buf);\n+#if CHECKING_P\n+  qsort_chk (vbase, n, size, cmp, data);\n #endif\n }\n \n+/* Stable sort, signature-compatible to C qsort.  */\n void\n gcc_stablesort (void *vbase, size_t n, size_t size, cmp_fn *cmp)\n {"}, {"sha": "56af544b70b41167d5309ba6b116ce0c8bc5ab08", "filename": "gcc/system.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=ce0454d9419dbcd73e65dae2a3eba15eeddbe338", "patch": "@@ -1197,13 +1197,14 @@ helper_const_non_const_cast (const char *p)\n /* Get definitions of HOST_WIDE_INT.  */\n #include \"hwint.h\"\n \n-/* GCC qsort API-compatible functions: except in release-checking compilers,\n-   redirect 4-argument qsort calls to gcc_qsort; keep 1-argument invocations\n-   corresponding to vec::qsort (cmp): they use C qsort internally anyway.  */\n-void qsort_chk (void *, size_t, size_t, int (*)(const void *, const void *));\n+typedef int sort_r_cmp_fn (const void *, const void *, void *);\n+void qsort_chk (void *, size_t, size_t, sort_r_cmp_fn *, void *);\n+void gcc_sort_r (void *, size_t, size_t, sort_r_cmp_fn *, void *);\n void gcc_qsort (void *, size_t, size_t, int (*)(const void *, const void *));\n void gcc_stablesort (void *, size_t, size_t,\n \t\t     int (*)(const void *, const void *));\n+/* Redirect four-argument qsort calls to gcc_qsort; one-argument invocations\n+   correspond to vec::qsort, and use C qsort internally.  */\n #define PP_5th(a1, a2, a3, a4, a5, ...) a5\n #undef qsort\n #define qsort(...) PP_5th (__VA_ARGS__, gcc_qsort, 3, 2, qsort, 0) (__VA_ARGS__)"}, {"sha": "bac5eb753a3cc821ff416cc9bd3d753cab689eaa", "filename": "gcc/vec.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0454d9419dbcd73e65dae2a3eba15eeddbe338/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=ce0454d9419dbcd73e65dae2a3eba15eeddbe338", "patch": "@@ -192,21 +192,23 @@ dump_vec_loc_statistics (void)\n ATTRIBUTE_NORETURN ATTRIBUTE_COLD\n static void\n qsort_chk_error (const void *p1, const void *p2, const void *p3,\n-\t\t int (*cmp) (const void *, const void *))\n+\t\t sort_r_cmp_fn *cmp, void *data)\n {\n   if (!p3)\n     {\n-      int r1 = cmp (p1, p2), r2 = cmp (p2, p1);\n-      error (\"qsort comparator not anti-commutative: %d, %d\", r1, r2);\n+      int r1 = cmp (p1, p2, data), r2 = cmp (p2, p1, data);\n+      error (\"qsort comparator not anti-symmetric: %d, %d\", r1, r2);\n     }\n   else if (p1 == p2)\n     {\n-      int r = cmp (p1, p3);\n+      int r = cmp (p1, p3, data);\n       error (\"qsort comparator non-negative on sorted output: %d\", r);\n     }\n   else\n     {\n-      int r1 = cmp (p1, p2), r2 = cmp (p2, p3), r3 = cmp (p1, p3);\n+      int r1 = cmp (p1, p2, data);\n+      int r2 = cmp (p2, p3, data);\n+      int r3 = cmp (p1, p3, data);\n       error (\"qsort comparator not transitive: %d, %d, %d\", r1, r2, r3);\n     }\n   internal_error (\"qsort checking failed\");\n@@ -215,8 +217,7 @@ qsort_chk_error (const void *p1, const void *p2, const void *p3,\n /* Verify anti-symmetry and transitivity for comparator CMP on sorted array\n    of N SIZE-sized elements pointed to by BASE.  */\n void\n-qsort_chk (void *base, size_t n, size_t size,\n-\t   int (*cmp)(const void *, const void *))\n+qsort_chk (void *base, size_t n, size_t size, sort_r_cmp_fn *cmp, void *data)\n {\n #if 0\n #define LIM(n) (n)\n@@ -225,9 +226,9 @@ qsort_chk (void *base, size_t n, size_t size,\n #define LIM(n) ((n) <= 16 ? (n) : 12 + floor_log2 (n))\n #endif\n #define ELT(i) ((const char *) base + (i) * size)\n-#define CMP(i, j) cmp (ELT (i), ELT (j))\n-#define ERR2(i, j) qsort_chk_error (ELT (i), ELT (j), NULL, cmp)\n-#define ERR3(i, j, k) qsort_chk_error (ELT (i), ELT (j), ELT (k), cmp)\n+#define CMP(i, j) cmp (ELT (i), ELT (j), data)\n+#define ERR2(i, j) qsort_chk_error (ELT (i), ELT (j), NULL, cmp, data)\n+#define ERR3(i, j, k) qsort_chk_error (ELT (i), ELT (j), ELT (k), cmp, data)\n   size_t i1, i2, i, j;\n   /* This outer loop iterates over maximum spans [i1, i2) such that\n      elements within each span compare equal to each other.  */"}]}