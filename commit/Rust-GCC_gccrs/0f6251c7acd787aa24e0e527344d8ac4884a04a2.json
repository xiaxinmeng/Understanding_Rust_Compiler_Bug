{"sha": "0f6251c7acd787aa24e0e527344d8ac4884a04a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY2MjUxYzdhY2Q3ODdhYTI0ZTBlNTI3MzQ0ZDhhYzQ4ODRhMDRhMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:30:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:30:27Z"}, "message": "[multiple changes]\n\n2016-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* layout.adb (Set_Elem_Alignment): Extend setting of alignment\n\tto subtypes that are not first subtypes.\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.ads (Collect_Inherited_Class_Wide_Conditions):\n\tSimplify interface.\n\t* sem_prag.adb (Collect_Inherited_Class_Wide_Conditions): Insert\n\tgenerated pragmas after subprogram declaration, rather than in\n\tthe corresponding subprogram body.\n\t* sem_ch6.adb (New_Overloaded_Entity): In GNATProve\n\tmode, if the operation is overridding, call\n\tCollect_Inherited_Class_Wide_Conditions to generate the\n\tcorresponding pragmas immediately after the corresponding\n\tsubprogram declaration.\n\n2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n\n\t* spark_xrefs.ads (Xref_Index, Scope_Index, File_Index): restrict\n\ttype to natural numbers.\n\t(Stype): document code characters for concurrent entities.\n\n2016-04-18  Olivier Hainque  <hainque@adacore.com>\n\n\t* targparm.ads: Update the Frontend_Exceptions default internal\n\tvalue.\n\t(Frontend_Exceptions_On_Target): Change default value to True.\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Refine error\n\tdetection when a selected component in the body of a synchronized\n\ttype is a reference to an object of the same type declared\n\telsewhere. The construct is legal if the prefix of the selected\n\tcomponent includes an explicit dereference at any point.\n\nFrom-SVN: r235118", "tree": {"sha": "4edfa88d7a11a5e1fa7511f1f5b7e7a102dd9e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4edfa88d7a11a5e1fa7511f1f5b7e7a102dd9e98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f6251c7acd787aa24e0e527344d8ac4884a04a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6251c7acd787aa24e0e527344d8ac4884a04a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f6251c7acd787aa24e0e527344d8ac4884a04a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6251c7acd787aa24e0e527344d8ac4884a04a2/comments", "author": null, "committer": null, "parents": [{"sha": "070d862dde98557eab8c9ecb0adb4ca504503777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070d862dde98557eab8c9ecb0adb4ca504503777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070d862dde98557eab8c9ecb0adb4ca504503777"}], "stats": {"total": 345, "additions": 229, "deletions": 116}, "files": [{"sha": "0d7e257ba7db7baf864b7ece7ab6606564ea069f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0f6251c7acd787aa24e0e527344d8ac4884a04a2", "patch": "@@ -1,3 +1,41 @@\n+2016-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* layout.adb (Set_Elem_Alignment): Extend setting of alignment\n+\tto subtypes that are not first subtypes.\n+\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.ads (Collect_Inherited_Class_Wide_Conditions):\n+\tSimplify interface.\n+\t* sem_prag.adb (Collect_Inherited_Class_Wide_Conditions): Insert\n+\tgenerated pragmas after subprogram declaration, rather than in\n+\tthe corresponding subprogram body.\n+\t* sem_ch6.adb (New_Overloaded_Entity): In GNATProve\n+\tmode, if the operation is overridding, call\n+\tCollect_Inherited_Class_Wide_Conditions to generate the\n+\tcorresponding pragmas immediately after the corresponding\n+\tsubprogram declaration.\n+\n+2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* spark_xrefs.ads (Xref_Index, Scope_Index, File_Index): restrict\n+\ttype to natural numbers.\n+\t(Stype): document code characters for concurrent entities.\n+\n+2016-04-18  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* targparm.ads: Update the Frontend_Exceptions default internal\n+\tvalue.\n+\t(Frontend_Exceptions_On_Target): Change default value to True.\n+\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Selected_Component): Refine error\n+\tdetection when a selected component in the body of a synchronized\n+\ttype is a reference to an object of the same type declared\n+\telsewhere. The construct is legal if the prefix of the selected\n+\tcomponent includes an explicit dereference at any point.\n+\n 2016-04-18  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch3.adb (Analyze_Object_Declaration): Do not consider"}, {"sha": "15f94a43768cb6e42fe78d6b8969cdce9c21541f", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 103, "deletions": 69, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=0f6251c7acd787aa24e0e527344d8ac4884a04a2", "patch": "@@ -3268,80 +3268,114 @@ package body Layout is\n          elsif Alignment (E) = A then\n             null;\n \n-         --  Now we come to the difficult cases where we have inherited an\n-         --  alignment and size, but overridden the size but not the alignment.\n-\n-         elsif Has_Size_Clause (E) or else Has_Object_Size_Clause (E) then\n-\n-            --  This is tricky, it might be thought that we should try to\n-            --  inherit the alignment, since that's what the RM implies, but\n-            --  that leads to complex rules and oddities. Consider for example:\n-\n-            --    type R is new Character;\n-            --    for R'Size use 16;\n-\n-            --  It seems quite bogus in this case to inherit an alignment of 1\n-            --  from the parent type Character. Furthermore, if that's what the\n-            --  programmer really wanted for some odd reason, then he could\n-            --  specify the alignment directly.\n-\n-            --  Furthermore we really don't want to inherit the alignment in\n-            --  the case of a specified Object_Size for a subtype, since then\n-            --  there would be no way of overriding to give a reasonable value\n-            --  (we don't have an Object_Subtype attribute). Consider:\n-\n-            --    subtype R is Character;\n-            --    for R'Object_Size use 16;\n-\n-            --  If we inherit the alignment of 1, then we have an inefficient\n-            --  alignment for the subtype, which cannot be fixed.\n-\n-            --  So we make the decision that if Size (or Object_Size) is given\n-            --  (and, in the case of a first subtype, the alignment is not set\n-            --  with a specific alignment clause), we reset the alignment to\n-            --  the appropriate value for the specified size. This is a nice\n-            --  simple rule to implement and document.\n-\n-            --  There is one slight glitch, which is that a confirming size\n-            --  clause can now change the alignment, which, if we really think\n-            --  that confirming rep clauses should have no effect, is a no-no.\n-\n-            --    type R is new Character;\n-            --    for R'Alignment use 2;\n-            --    type S is new R;\n-            --    for S'Size use Character'Size;\n-\n-            --  Now the alignment of S is changed to 1 instead of 2 as a result\n-            --  of applying the above rule to the confirming rep clause for S.\n-            --  Not clear this is worth worrying about. If we recorded whether\n-            --  a size clause was confirming we could avoid this, but right now\n-            --  we have no way of doing that or easily figuring it out, so we\n-            --  don't bother.\n-\n-            --  Historical note: in versions of GNAT prior to Nov 6th, 2011, an\n-            --  odd distinction was made between inherited alignments larger\n-            --  than the computed alignment (where the larger alignment was\n-            --  inherited) and inherited alignments smaller than the computed\n-            --  alignment (where the smaller alignment was overridden). This\n-            --  was a dubious fix to get around an ACATS problem which seems\n-            --  to have disappeared anyway, and in any case, this peculiarity\n-            --  was never documented.\n+         else\n+            --  Now we come to the difficult cases of subtypes for which we\n+            --  have inherited an alignment different from the computed one.\n+            --  We resort to the presence of alignment and size clauses to\n+            --  guide our choices. Note that they can generally be present\n+            --  only on the first subtype (except for Object_Size) and that\n+            --  we need to look at the Rep_Item chain to correctly handle\n+            --  derived types.\n \n-            Init_Alignment (E, A);\n+            declare\n+               FST : constant Entity_Id := First_Subtype (E);\n \n-         --  If no Size (or Object_Size) was specified, then we inherited the\n-         --  object size, so we should inherit the alignment as well and not\n-         --  modify it. This takes care of cases like:\n+               function Has_Attribute_Clause\n+                 (E  : Entity_Id;\n+                  Id : Attribute_Id) return Boolean;\n+               --  Wrapper around Get_Attribute_Definition_Clause which tests\n+               --  for the presence of the specified attribute clause.\n \n-         --    type R is new Integer;\n-         --    for R'Alignment use 1;\n-         --    subtype S is R;\n+               --------------------------\n+               -- Has_Attribute_Clause --\n+               --------------------------\n \n-         --  Here we have R with a default Object_Size of 32, and a specified\n-         --  alignment of 1, and it seeems right for S to inherit both values.\n+               function Has_Attribute_Clause\n+                 (E  : Entity_Id;\n+                  Id : Attribute_Id) return Boolean is\n+               begin\n+                  return Present (Get_Attribute_Definition_Clause (E, Id));\n+               end Has_Attribute_Clause;\n \n-         else\n-            null;\n+            begin\n+               --  If the alignment comes from a clause, then we respect it.\n+               --  Consider for example:\n+\n+               --    type R is new Character;\n+               --    for R'Alignment use 1;\n+               --    for R'Size use 16;\n+               --    subtype S is R;\n+\n+               --  Here R has a specified size of 16 and a specified alignment\n+               --  of 1, and it seems right for S to inherit both values.\n+\n+               if Has_Attribute_Clause (FST, Attribute_Alignment) then\n+                  null;\n+\n+               --  Now we come to the cases where we have inherited alignment\n+               --  and size, and overridden the size but not the alignment.\n+\n+               elsif Has_Attribute_Clause (FST, Attribute_Size)\n+                 or else Has_Attribute_Clause (FST, Attribute_Object_Size)\n+                 or else Has_Attribute_Clause (E, Attribute_Object_Size)\n+               then\n+                  --  This is tricky, it might be thought that we should try to\n+                  --  inherit the alignment, since that's what the RM implies,\n+                  --  but that leads to complex rules and oddities. Consider\n+                  --  for example:\n+\n+                  --    type R is new Character;\n+                  --    for R'Size use 16;\n+\n+                  --  It seems quite bogus in this case to inherit an alignment\n+                  --  of 1 from the parent type Character. Furthermore, if that\n+                  --  is what the programmer really wanted for some odd reason,\n+                  --  then he could specify the alignment directly.\n+\n+                  --  Moreover we really don't want to inherit the alignment in\n+                  --  the case of a specified Object_Size for a subtype, since\n+                  --  there would be no way of overriding to give a reasonable\n+                  --  value (as we don't have an Object_Alignment attribute).\n+                  --  Consider for example:\n+\n+                  --    subtype R is Character;\n+                  --    for R'Object_Size use 16;\n+\n+                  --  If we inherit the alignment of 1, then it will be very\n+                  --  inefficient for the subtype and this cannot be fixed.\n+\n+                  --  So we make the decision that if Size (or Object_Size) is\n+                  --  given and the alignment is not specified with a clause,\n+                  --  we reset the alignment to the appropriate value for the\n+                  --  specified size. This is a nice simple rule to implement\n+                  --  and document.\n+\n+                  --  There is a theoretical glitch, which is that a confirming\n+                  --  size clause could now change the alignment, which, if we\n+                  --  really think that confirming rep clauses should have no\n+                  --  effect, could be seen as a no-no. However that's already\n+                  --  implemented by Alignment_Check_For_Size_Change so we do\n+                  --  not change the philosophy here.\n+\n+                  --  Historical note: in versions prior to Nov 6th, 2011, an\n+                  --  odd distinction was made between inherited alignments\n+                  --  larger than the computed alignment (where the larger\n+                  --  alignment was inherited) and inherited alignments smaller\n+                  --  than the computed alignment (where the smaller alignment\n+                  --  was overridden). This was a dubious fix to get around an\n+                  --  ACATS problem which seems to have disappeared anyway, and\n+                  --  in any case, this peculiarity was never documented.\n+\n+                  Init_Alignment (E, A);\n+\n+               --  If no Size (or Object_Size) was specified, then we have\n+               --  inherited the object size, so we should also inherit the\n+               --  alignment and not modify it.\n+\n+               else\n+                  null;\n+               end if;\n+            end;\n          end if;\n       end;\n    end Set_Elem_Alignment;"}, {"sha": "04b9dbd9f4c3a0009aeff0fd24a955cfef042c4d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=0f6251c7acd787aa24e0e527344d8ac4884a04a2", "patch": "@@ -4657,21 +4657,44 @@ package body Sem_Ch4 is\n          end loop;\n \n          --  If the scope is a current instance, the prefix cannot be an\n-         --  expression of the same type (that would represent an attempt\n-         --  to reach an internal operation of another synchronized object).\n+         --  expression of the same type, unless the selector designates a\n+         --  public operation (otherwise that would represent an attempt to\n+         --  reach an internal entity of another synchronized object).\n          --  This is legal if prefix is an access to such type and there is\n-         --  a dereference.\n+         --  a dereference, or is a component with a dereferenced prefix.\n \n-         if In_Scope\n-           and then not Is_Entity_Name (Name)\n-           and then Nkind (Name) /= N_Explicit_Dereference\n-         then\n-            Error_Msg_NE\n-              (\"invalid reference to internal operation of some object of \"\n-               & \"type &\", N, Type_To_Use);\n-            Set_Entity (Sel, Any_Id);\n-            Set_Etype  (Sel, Any_Type);\n-            return;\n+         if In_Scope and then not Is_Entity_Name (Name) then\n+            declare\n+\n+               function Has_Dereference (N : Node_Id) return Boolean;\n+               --  Check whether prefix includes a dereference at any level.\n+\n+               ---------------------\n+               -- Has_Dereference --\n+               ---------------------\n+\n+               function Has_Dereference (N : Node_Id) return Boolean is\n+               begin\n+                  if Nkind (N) = N_Explicit_Dereference then\n+                     return True;\n+                  elsif\n+                    Nkind_In (N, N_Selected_Component, N_Indexed_Component)\n+                  then\n+                     return Has_Dereference (Prefix (N));\n+                  else\n+                     return False;\n+                  end if;\n+               end Has_Dereference;\n+\n+            begin\n+               if not Has_Dereference (Name) then\n+                  Error_Msg_NE (\"invalid reference to internal operation \"\n+                     & \"of some object of type &\", N, Type_To_Use);\n+                  Set_Entity (Sel, Any_Id);\n+                  Set_Etype  (Sel, Any_Type);\n+                  return;\n+               end if;\n+            end;\n          end if;\n \n          --  If there is no visible entity with the given name or none of the"}, {"sha": "0e03ff6a3dafbdc33128016e8b9078f573210932", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0f6251c7acd787aa24e0e527344d8ac4884a04a2", "patch": "@@ -3761,15 +3761,7 @@ package body Sem_Ch6 is\n       end if;\n \n       --  When generating code, inherited pre/postconditions are handled when\n-      --  expanding the corresponding contract. In GNATprove the annotations\n-      --  must be processed when the body is analyzed.\n-\n-      if GNATprove_Mode\n-        and then Present (Spec_Id)\n-        and then Present (Overridden_Operation (Spec_Id))\n-      then\n-         Collect_Inherited_Class_Wide_Conditions (Spec_Id, N);\n-      end if;\n+      --  expanding the corresponding contract.\n \n       --  Ada 2005 (AI-262): In library subprogram bodies, after the analysis\n       --  of the specification we have to install the private withed units.\n@@ -9946,6 +9938,13 @@ package body Sem_Ch6 is\n                         Set_Convention (S, Convention (E));\n                         Check_Dispatching_Operation (S, E);\n \n+                        --  In GNATprove_Mode, create the pragmas corresponding\n+                        --  to inherited class-wide conditions.\n+\n+                        if GNATprove_Mode then\n+                           Collect_Inherited_Class_Wide_Conditions (S);\n+                        end if;\n+\n                      else\n                         Check_Dispatching_Operation (S, Empty);\n                      end if;"}, {"sha": "173b14b4430c23f037586eba8f0622947f89c9c7", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0f6251c7acd787aa24e0e527344d8ac4884a04a2", "patch": "@@ -26759,35 +26759,48 @@ package body Sem_Prag is\n    -- Collect_Inherited_Class_Wide_Conditions --\n    ---------------------------------------------\n \n-   procedure Collect_Inherited_Class_Wide_Conditions\n-     (Subp : Entity_Id;\n-      Bod  : Node_Id)\n-   is\n+   procedure Collect_Inherited_Class_Wide_Conditions (Subp : Entity_Id) is\n       Parent_Subp : constant Entity_Id := Overridden_Operation (Subp);\n       Prags       : constant Node_Id   := Contract (Parent_Subp);\n       Prag        : Node_Id;\n+      New_Prag    : Node_Id;\n+      Installed   : Boolean;\n \n    begin\n-      --  Iterate over the contract to find inherited class-wide pre- and\n-      --  postconditions.\n+      Installed := False;\n+\n+      --  Iterate over the contract of the overridden subprogram  to find\n+      --  inherited class-wide pre- and postconditions.\n \n       if Present (Prags) then\n          Prag := Pre_Post_Conditions (Prags);\n \n          while Present (Prag) loop\n             if Nam_In (Pragma_Name (Prag), Name_Precondition,\n                                            Name_Postcondition)\n+              and then Class_Present (Prag)\n             then\n-               if No (Declarations (Bod)) then\n-                  Set_Declarations (Bod, Empty_List);\n+               --  The generated pragma must be analyzed in the context of\n+               --  the subprogram, to make its formals visible.\n+\n+               if not Installed then\n+                  Installed := True;\n+                  Push_Scope (Subp);\n+                  Install_Formals (Subp);\n                end if;\n \n-               Append_To (Declarations (Bod),\n-                 Build_Pragma_Check_Equivalent (Prag, Subp, Parent_Subp));\n+               New_Prag :=\n+                 Build_Pragma_Check_Equivalent (Prag, Subp, Parent_Subp);\n+               Insert_After (Unit_Declaration_Node (Subp), New_Prag);\n+               Preanalyze (New_Prag);\n             end if;\n \n             Prag := Next_Pragma (Prag);\n          end loop;\n+\n+         if Installed then\n+            End_Scope;\n+         end if;\n       end if;\n    end Collect_Inherited_Class_Wide_Conditions;\n "}, {"sha": "7afb6e662fa695fe9e058f6dbe9f9366949b1aad", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=0f6251c7acd787aa24e0e527344d8ac4884a04a2", "patch": "@@ -311,12 +311,12 @@ package Sem_Prag is\n    --  state, variable or package instantiation denoted by Item_Id requires the\n    --  use of indicator/option Part_Of. If this is the case, emit an error.\n \n-   procedure Collect_Inherited_Class_Wide_Conditions\n-     (Subp : Entity_Id;\n-      Bod  : Node_Id);\n-   --  When analyzing an overriding subprogram, check whether the overridden\n-   --  operations have class-wide pre/postconditions, and generate the\n-   --  corresponding pragmas.\n+   procedure Collect_Inherited_Class_Wide_Conditions (Subp : Entity_Id);\n+   --  In GNATprove mode, when analyzing an overriding subprogram, check\n+   --  whether the overridden operations have class-wide pre/postconditions,\n+   --  and generate the corresponding pragmas. The pragmas are inserted after\n+   --  the subprogram declaration, together with those generated for other\n+   --  aspects of the subprogram.\n \n    procedure Collect_Subprogram_Inputs_Outputs\n      (Subp_Id      : Entity_Id;"}, {"sha": "eb95f733103e3860acbbac7fb088ae83308e4de0", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=0f6251c7acd787aa24e0e527344d8ac4884a04a2", "patch": "@@ -209,9 +209,10 @@ package SPARK_Xrefs is\n \n    --  The following table records SPARK cross-references\n \n-   type Xref_Index is new Int;\n+   type Xref_Index is new Nat;\n    --  Used to index values in this table. Values start at 1 and are assigned\n-   --  sequentially as entries are constructed.\n+   --  sequentially as entries are constructed; value 0 is used temporarily\n+   --  until a proper value is determined.\n \n    type SPARK_Xref_Record is record\n       Entity_Name : String_Ptr;\n@@ -268,9 +269,11 @@ package SPARK_Xrefs is\n    --  This table keeps track of the scopes and the corresponding starting and\n    --  ending indexes (From, To) in the Xref table.\n \n-   type Scope_Index is new Int;\n+   type Scope_Index is new Nat;\n    --  Used to index values in this table. Values start at 1 and are assigned\n-   --  sequentially as entries are constructed.\n+   --  sequentially as entries are constructed; value 0 indicates that no\n+   --  entries have been constructed and is also used until a proper value is\n+   --  determined.\n \n    type SPARK_Scope_Record is record\n       Scope_Name : String_Ptr;\n@@ -296,8 +299,10 @@ package SPARK_Xrefs is\n       Stype : Character;\n       --  Indicates type of scope, using code used in ALI file:\n       --    K = package\n-      --    V = function\n+      --    T = task\n       --    U = procedure\n+      --    V = function\n+      --    Y = entry\n \n       Col : Nat;\n       --  Column number for the scope\n@@ -329,9 +334,10 @@ package SPARK_Xrefs is\n    --  This table keeps track of the units and the corresponding starting and\n    --  ending indexes (From, To) in the Scope table.\n \n-   type File_Index is new Int;\n+   type File_Index is new Nat;\n    --  Used to index values in this table. Values start at 1 and are assigned\n-   --  sequentially as entries are constructed.\n+   --  sequentially as entries are constructed; value 0 indicates that no\n+   --  entries have been constructed.\n \n    type SPARK_File_Record is record\n       File_Name : String_Ptr;"}, {"sha": "9964425baf43e6226865f3a0450f6a6894d10a8b", "filename": "gcc/ada/targparm.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Ftargparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6251c7acd787aa24e0e527344d8ac4884a04a2/gcc%2Fada%2Ftargparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.ads?ref=0f6251c7acd787aa24e0e527344d8ac4884a04a2", "patch": "@@ -261,7 +261,7 @@ package Targparm is\n    --    Back-End Setjmp/Longjmp Exceptions\n \n    --      With this approach, the back end also handles the generation and\n-   --      handling of exceptions, using setjmp/longjmp to setup receivers and\n+   --      handling of exceptions, using setjmp/longjmp to set up receivers and\n    --      propagate. AT-END actions on exceptional paths are also taken care\n    --      of by the back end and the front end doesn't need to generate\n    --      explicit exception handlers for these.\n@@ -271,7 +271,7 @@ package Targparm is\n    --      The following switches specify whether we're using a front-end or a\n    --      back-end mechanism and whether this is a zero-cost or a sjlj scheme.\n \n-   --      The per switch default values correspond to the default value of\n+   --      The per-switch default values correspond to the default value of\n    --      Opt.Exception_Mechanism.\n \n    ZCX_By_Default_On_Target : Boolean := False;"}]}