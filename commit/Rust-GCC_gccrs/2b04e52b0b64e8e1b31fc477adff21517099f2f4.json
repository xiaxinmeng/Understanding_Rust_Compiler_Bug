{"sha": "2b04e52b0b64e8e1b31fc477adff21517099f2f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIwNGU1MmIwYjY0ZThlMWIzMWZjNDc3YWRmZjIxNTE3MDk5ZjJmNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-28T18:19:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-28T18:19:23Z"}, "message": "i386.md (attribute mode): Add \"TI\".\n\n\n\t* i386.md (attribute mode): Add \"TI\".\n\t(movsf_1): Add pxor support; remove constant propagation splitter.\n\t(movdf_integer): Likewise.\n\t(movdf_nointeger): Likewise.\n\t(movxf constant prop splitter): Handle all modes; update for SSE.\n\t* i386.h (CONST_DOUBLE_OK_FOR_LETTER): Add 'H' for SSE constants.\n\t* i386.c (standard_80387_constant_p): Rewrite.\n\t(standard_sse_constant_p): New.\n\t* i386-protos.h (standard_sse_constant_p): New.\n\nFrom-SVN: r40132", "tree": {"sha": "fba1f7899c2e2be5a348e381e14839a438f41dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fba1f7899c2e2be5a348e381e14839a438f41dea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b04e52b0b64e8e1b31fc477adff21517099f2f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b04e52b0b64e8e1b31fc477adff21517099f2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b04e52b0b64e8e1b31fc477adff21517099f2f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b04e52b0b64e8e1b31fc477adff21517099f2f4/comments", "author": null, "committer": null, "parents": [{"sha": "a46d1d38ae9c0e71f9d3effb106f9214ba8a6cec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a46d1d38ae9c0e71f9d3effb106f9214ba8a6cec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a46d1d38ae9c0e71f9d3effb106f9214ba8a6cec"}], "stats": {"total": 161, "additions": 77, "deletions": 84}, "files": [{"sha": "e42a4063e4e97fe79278773e77cef88e1cc4ac7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b04e52b0b64e8e1b31fc477adff21517099f2f4", "patch": "@@ -1,3 +1,15 @@\n+Wed Feb 28 19:18:23 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (attribute mode): Add \"TI\".\n+\t(movsf_1): Add pxor support; remove constant propagation splitter.\n+\t(movdf_integer): Likewise.\n+\t(movdf_nointeger): Likewise.\n+\t(movxf constant prop splitter): Handle all modes; update for SSE.\n+\t* i386.h (CONST_DOUBLE_OK_FOR_LETTER): Add 'H' for SSE constants.\n+\t* i386.c (standard_80387_constant_p): Rewrite.\n+\t(standard_sse_constant_p): New.\n+\t* i386-protos.h (standard_sse_constant_p): New.\n+\n Wed Feb 28 19:05:37 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (sse_setccsf, sse_setccdf): New."}, {"sha": "60b2998100e88d74bd1d9cc1fdc457cd6d089848", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=2b04e52b0b64e8e1b31fc477adff21517099f2f4", "patch": "@@ -40,6 +40,7 @@ extern void ix86_output_block_profiler PARAMS ((FILE *, int));\n extern int ix86_aligned_p PARAMS ((rtx));\n \n extern int standard_80387_constant_p PARAMS ((rtx));\n+extern int standard_sse_constant_p PARAMS ((rtx));\n extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n \n extern int const_int_1_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "88ba6d1e42fe80f12888aaeb9144fc0caa60df2c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2b04e52b0b64e8e1b31fc477adff21517099f2f4", "patch": "@@ -1644,40 +1644,29 @@ int\n standard_80387_constant_p (x)\n      rtx x;\n {\n-  if (GET_CODE (x) != CONST_DOUBLE)\n+  if (GET_CODE (x) != CONST_DOUBLE || !FLOAT_MODE_P (GET_MODE (x)))\n     return -1;\n-\n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-  {\n-    REAL_VALUE_TYPE d;\n-    jmp_buf handler;\n-    int is0, is1;\n-\n-    if (setjmp (handler))\n-      return 0;\n-\n-    set_float_handler (handler);\n-    REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n-    is0 = REAL_VALUES_EQUAL (d, dconst0) && !REAL_VALUE_MINUS_ZERO (d);\n-    is1 = REAL_VALUES_EQUAL (d, dconst1);\n-    set_float_handler (NULL_PTR);\n-\n-    if (is0)\n-      return 1;\n-\n-    if (is1)\n-      return 2;\n-\n-    /* Note that on the 80387, other constants, such as pi,\n-       are much slower to load as standard constants\n-       than to load from doubles in memory!  */\n-    /* ??? Not true on K6: all constants are equal cost.  */\n-  }\n-#endif\n-\n+  /* Note that on the 80387, other constants, such as pi, that we should support\n+     too.  On some machines, these are much slower to load as standard constant,\n+     than to load from doubles in memory.  */\n+  if (x == CONST0_RTX (GET_MODE (x)))\n+    return 1;\n+  if (x == CONST1_RTX (GET_MODE (x)))\n+    return 2;\n   return 0;\n }\n \n+/* Return 1 if X is FP constant we can load to SSE register w/o using memory.\n+ */\n+int\n+standard_sse_constant_p (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) != CONST_DOUBLE)\n+    return -1;\n+  return (x == CONST0_RTX (GET_MODE (x)));\n+}\n+\n /* Returns 1 if OP contains a symbol reference */\n \n int"}, {"sha": "1086757b5300338bed067e7d43c8e25c6da5084d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2b04e52b0b64e8e1b31fc477adff21517099f2f4", "patch": "@@ -1136,7 +1136,8 @@ enum reg_class\n    load 0.0 into the function value register.  */\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'G' ? standard_80387_constant_p (VALUE) : 0)\n+  ((C) == 'G' ? standard_80387_constant_p (VALUE) \\\n+   : ((C) == 'H' ? standard_sse_constant_p (VALUE) : 0))\n \n /* Place additional restrictions on the register class to use when it\n    is necessary to be able to hold a value of mode MODE in a reload"}, {"sha": "d6a751e1299d562e84b1ad609c8f7d611ce791b6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 43, "deletions": 53, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b04e52b0b64e8e1b31fc477adff21517099f2f4/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2b04e52b0b64e8e1b31fc477adff21517099f2f4", "patch": "@@ -107,7 +107,7 @@\n   (const_string \"other\"))\n \n ;; Main data type used by the insn\n-(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,unknownfp,SF,DF,XF\"\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,unknownfp,SF,DF,XF,TI\"\n   (const_string \"unknown\"))\n \n ;; Set for i387 operations.\n@@ -2198,8 +2198,8 @@\n    (set (mem:SF (reg:SI 7)) (match_dup 1))])\n \n (define_insn \"*movsf_1\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#xr,m,f#xr,r#xf,m,x#rf,m\")\n-\t(match_operand:SF 1 \"general_operand\" \"fm#rx,f#rx,G,rmF#fx,Fr#fx,xm#rf,x#rf\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#xr,m,f#xr,r#xf,m,x#rf,x#rf,x#rf,m\")\n+\t(match_operand:SF 1 \"general_operand\" \"fm#rx,f#rx,G,rmF#fx,Fr#fx,H,x,xm#rf,x#rf\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (reload_in_progress || reload_completed\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n@@ -2237,36 +2237,22 @@\n     case 4:\n       return \\\"mov{l}\\\\t{%1, %0|%0, %1}\\\";\n     case 5:\n+      return \\\"pxor\\\\t%0, %0\\\";\n     case 6:\n-      if (TARGET_PARTIAL_REG_DEPENDENCY\n-\t  && register_operand (operands[0], VOIDmode)\n-\t  && register_operand (operands[1], VOIDmode))\n+      if (TARGET_PARTIAL_REG_DEPENDENCY)\n \treturn \\\"movaps\\\\t{%1, %0|%0, %1}\\\";\n+      else\n+\treturn \\\"movss\\\\t{%1, %0|%0, %1}\\\";\n+    case 7:\n+    case 8:\n       return \\\"movss\\\\t{%1, %0|%0, %1}\\\";\n \n     default:\n       abort();\n     }\n }\"\n-  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,sse,sse\")\n-   (set_attr \"mode\" \"SF,SF,SF,SI,SI,SF,SF\")])\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SF 1 \"memory_operand\" \"\"))]\n-  \"reload_completed\n-   && GET_CODE (operands[1]) == MEM\n-   && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n-   && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n-   && !(SSE_REG_P (operands[0]) \n-        || (GET_CODE (operands[0]) == SUBREG && SSE_REG_P (operands[0])))\n-   && (!(FP_REG_P (operands[0]) || \n-\t (GET_CODE (operands[0]) == SUBREG\n-\t  && FP_REG_P (SUBREG_REG (operands[0]))))\n-       || standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0))))\"\n-  [(set (match_dup 0)\n-\t(match_dup 1))]\n-  \"operands[1] = get_pool_constant (XEXP (operands[1], 0));\")\n+  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,sse,sse,sse,sse\")\n+   (set_attr \"mode\" \"SF,SF,SF,SI,SI,TI,SF,SF,SF\")])\n \n (define_insn \"*swapsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"+f\")\n@@ -2375,8 +2361,8 @@\n ;; when optimizing for size.\n \n (define_insn \"*movdf_nointeger\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#Y,m,f#Y,*r,o,Y#f,m\")\n-\t(match_operand:DF 1 \"general_operand\" \"fm#Y,f#Y,G,*roF,F*r,Ym#f,Y#f\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#Y,m,f#Y,*r,o,Y#f,Y#f,Y#f,m\")\n+\t(match_operand:DF 1 \"general_operand\" \"fm#Y,f#Y,G,*roF,F*r,H,Y#f,YHm#f,Y#f\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (optimize_size || !TARGET_INTEGER_DFMODE_MOVES)\n    && (reload_in_progress || reload_completed\n@@ -2415,23 +2401,26 @@\n     case 4:\n       return \\\"#\\\";\n     case 5:\n+      return \\\"pxor\\\\t%0, %0\\\";\n     case 6:\n-      if (TARGET_PARTIAL_REG_DEPENDENCY\n-\t  && register_operand (operands[0], VOIDmode)\n-\t  && register_operand (operands[1], VOIDmode))\n+      if (TARGET_PARTIAL_REG_DEPENDENCY)\n \treturn \\\"movapd\\\\t{%1, %0|%0, %1}\\\";\n-      return \\\"movsd\\\\t{%1, %0|%0, %1}\\\";\n+      else\n+\treturn \\\"movsd\\\\t{%1, %0|%0, %1}\\\";\n+    case 7:\n+    case 8:\n+        return \\\"movsd\\\\t{%1, %0|%0, %1}\\\";\n \n     default:\n       abort();\n     }\n }\"\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sse,sse\")\n-   (set_attr \"mode\" \"DF,DF,DF,SI,SI,DF,DF\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sse,sse,sse,sse\")\n+   (set_attr \"mode\" \"DF,DF,DF,SI,SI,TI,DF,DF,DF\")])\n \n (define_insn \"*movdf_integer\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#Yr,m,f#Yr,r#Yf,o,Y#rf,m\")\n-\t(match_operand:DF 1 \"general_operand\" \"fm#Yr,f#Yr,G,roF#Yf,Fr#Yf,Ym#rf,Y#rf\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#Yr,m,f#Yr,r#Yf,o,Y#rf,Y#rf,Y#rf,m\")\n+\t(match_operand:DF 1 \"general_operand\" \"fm#Yr,f#Yr,G,roF#Yf,Fr#Yf,H,Y#rf,Ym#rf,Y#rf\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && !optimize_size && TARGET_INTEGER_DFMODE_MOVES\n    && (reload_in_progress || reload_completed\n@@ -2471,15 +2460,22 @@\n       return \\\"#\\\";\n \n     case 5:\n+      return \\\"pxor\\\\t%0, %0\\\";\n     case 6:\n+      if (TARGET_PARTIAL_REG_DEPENDENCY)\n+\treturn \\\"movapd\\\\t{%1, %0|%0, %1}\\\";\n+      else\n+\treturn \\\"movsd\\\\t{%1, %0|%0, %1}\\\";\n+    case 7:\n+    case 8:\n       return \\\"movsd\\\\t{%1, %0|%0, %1}\\\";\n \n     default:\n       abort();\n     }\n }\"\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sse,sse\")\n-   (set_attr \"mode\" \"DF,DF,DF,SI,SI,DF,DF\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sse,sse,sse,sse\")\n+   (set_attr \"mode\" \"DF,DF,DF,SI,SI,TI,DF,DF,DF\")])\n \n (define_split\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n@@ -2496,20 +2492,6 @@\n    (set (match_dup 3) (match_dup 6))]\n   \"if (ix86_split_long_move (operands)) DONE;\")\n \n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(match_operand:DF 1 \"memory_operand\" \"\"))]\n-  \"reload_completed\n-   && GET_CODE (operands[1]) == MEM\n-   && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n-   && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n-   && !(SSE_REG_P (operands[0]) \n-        || (GET_CODE (operands[0]) == SUBREG && SSE_REG_P (operands[0])))\n-   && standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0)))\"\n-  [(set (match_dup 0)\n-\t(match_dup 1))]\n-  \"operands[1] = get_pool_constant (XEXP (operands[1], 0));\")\n-\n (define_insn \"*swapdf\"\n   [(set (match_operand:DF 0 \"register_operand\" \"+f\")\n \t(match_operand:DF 1 \"register_operand\" \"+f\"))\n@@ -2895,10 +2877,18 @@\n \t(match_operand 1 \"memory_operand\" \"\"))]\n   \"reload_completed\n    && GET_CODE (operands[1]) == MEM\n-   && (GET_MODE (operands[0]) == XFmode || GET_MODE (operands[0]) == TFmode)\n+   && (GET_MODE (operands[0]) == XFmode || GET_MODE (operands[0]) == TFmode\n+       || GET_MODE (operands[0]) == SFmode || GET_MODE (operands[0]) == DFmode)\n    && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n    && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0))\n-   && standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0)))\"\n+   && (!(SSE_REG_P (operands[0]) || \n+\t (GET_CODE (operands[0]) == SUBREG\n+\t  && SSE_REG_P (SUBREG_REG (operands[0]))))\n+       || standard_sse_constant_p (get_pool_constant (XEXP (operands[1], 0))))\n+   && (!(FP_REG_P (operands[0]) || \n+\t (GET_CODE (operands[0]) == SUBREG\n+\t  && FP_REG_P (SUBREG_REG (operands[0]))))\n+       || standard_80387_constant_p (get_pool_constant (XEXP (operands[1], 0))))\"\n   [(set (match_dup 0)\n \t(match_dup 1))]\n   \"operands[1] = get_pool_constant (XEXP (operands[1], 0));\")"}]}