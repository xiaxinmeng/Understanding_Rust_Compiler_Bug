{"sha": "3e978d3094f29abe03d271d63cdc16930c5e51de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U5NzhkMzA5NGYyOWFiZTAzZDI3MWQ2M2NkYzE2OTMwYzVlNTFkZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-08-20T05:45:43Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-08-20T05:45:43Z"}, "message": "re PR fortran/28601 (ICE on reexport of renamed type)\n\n2006-08-20 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/28601\n\tPR fortran/28630\n\t* gfortran.h : Eliminate gfc_dt_list structure and reference\n\tto it in gfc_namespace.\n\t* resolve.c (resolve_fl_derived): Remove the building of the\n\tlist of derived types for the current namespace.\n\t* symbol.c (find_renamed_type): New function to find renamed\n\tderived types by symbol name rather than symtree name.\n\t(gfc_use_derived): Search parent namespace for identical\n\tderived type and use it, even if local version is complete,\n\texcept in interface bodies. Ensure that renamed derived types\n\tare found by call to find_renamed_type. Recurse for derived\n\ttype components.\n\t(gfc_free_dt_list): Remove.\n\t(gfc_free_namespace): Remove call to previous.\n\t* trans-types.c (copy_dt_decls_ifequal): Remove.\n\t(gfc_get_derived_type): Remove all the paraphenalia for\n\tassociation of derived types, including calls to previous.\n\t* match.c (gfc_match_allocate): Call gfc_use_derived to\n\tassociate any derived types that are being allocated.\n\n\tPR fortran/20886\n\t* resolve.c (resolve_actual_arglist): The passing of\n\ta generic procedure name as an actual argument is an\n\terror.\n\n\tPR fortran/28735\n\t* resolve.c (resolve_variable): Check for a symtree before\n\tresolving references.\n\n\tPR fortran/28762\n\t* primary.c (match_variable): Return MATCH_NO if the symbol\n\tis that of the program.\n\n\tPR fortran/28425\n\t* trans-expr.c (gfc_trans_subcomponent_assign): Translate\n\tderived type component expressions other than another derived\n\ttype constructor.\n\n\tPR fortran/28496\n\t* expr.c (find_array_section): Correct errors in\n\tthe handling of a missing start value for the\n\tindex triplet in an array reference.\n\n\tPR fortran/18111\n\t* trans-decl.c (gfc_build_dummy_array_decl): Before resetting\n\treference to backend_decl, set it DECL_ARTIFICIAL.\n\t(gfc_get_symbol_decl): Likewise for original dummy decl, when\n\ta copy is made of an array.\n\t(create_function_arglist): Likewise for the _entry paramter\n\tin entry_masters.\n\t(build_entry_thunks): Likewise for dummies in entry thunks.\n\n\tPR fortran/28600\n\t* trans-decl.c (gfc_get_symbol_decl): Ensure that the\n\tDECL_CONTEXT of the length of a character dummy is the\n\tsame as that of the symbol declaration.\n\n\tPR fortran/28771\n\t* decl.c (add_init_expr_to_sym): Remove setting of charlen for\n\tan initializer of an assumed charlen variable.\n\n\tPR fortran/28660\n\t* trans-decl.c (generate_expr_decls): New function.\n\t(generate_dependency_declarations): New function.\n\t(generate_local_decl): Call previous if not either a dummy or\n\ta declaration in an entry master.\n\n2006-08-20 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/28630\n\t* gfortran.dg/used_types_2.f90: New test.\n\n\tPR fortran/28601\n\t* gfortran.dg/used_types_3.f90: New test.\n\n\tPR fortran/20886\n\t* gfortran.dg/generic_actual_arg.f90: New test.\n\n\tPR fortran/28735\n\t* gfortran.dg/module_private_array_refs_1.f90: New test.\n\n\tPR fortran/28762\n\t* gfortran.dg/program_name_1.f90: New test.\n\n\tPR fortran/28425\n\t* gfortran.dg/derived_constructor_comps_1.f90: New test.\n\n\tPR fortran/28496\n\t* gfortran.dg/array_initializer_2.f90: New test.\n\n\tPR fortran/18111\n\t* gfortran.dg/unused_artificial_dummies_1.f90: New test. \n\n\tPR fortran/28600\n\t* gfortran.dg/assumed_charlen_function_4.f90: New test.\n\n\tPR fortran/28771\n\t* gfortran.dg/assumed_charlen_in_main.f90: New test.\n\n\tPR fortran/28660\n\t* gfortran.dg/dependent_decls_1.f90: New test.\n\nFrom-SVN: r116268", "tree": {"sha": "71dfb9f1b62446b012c3d02523650d372761d864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71dfb9f1b62446b012c3d02523650d372761d864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e978d3094f29abe03d271d63cdc16930c5e51de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e978d3094f29abe03d271d63cdc16930c5e51de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e978d3094f29abe03d271d63cdc16930c5e51de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e978d3094f29abe03d271d63cdc16930c5e51de/comments", "author": null, "committer": null, "parents": [{"sha": "84572ba5d3d1c95dab9674077163107b0edbd337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84572ba5d3d1c95dab9674077163107b0edbd337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84572ba5d3d1c95dab9674077163107b0edbd337"}], "stats": {"total": 859, "additions": 723, "deletions": 136}, "files": [{"sha": "bbcee7a9f4c595bbd28563e14d536da0c45dcbc2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -1,3 +1,73 @@\n+2006-08-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28601\n+\tPR fortran/28630\n+\t* gfortran.h : Eliminate gfc_dt_list structure and reference\n+\tto it in gfc_namespace.\n+\t* resolve.c (resolve_fl_derived): Remove the building of the\n+\tlist of derived types for the current namespace.\n+\t* symbol.c (find_renamed_type): New function to find renamed\n+\tderived types by symbol name rather than symtree name.\n+\t(gfc_use_derived): Search parent namespace for identical\n+\tderived type and use it, even if local version is complete,\n+\texcept in interface bodies. Ensure that renamed derived types\n+\tare found by call to find_renamed_type. Recurse for derived\n+\ttype components.\n+\t(gfc_free_dt_list): Remove.\n+\t(gfc_free_namespace): Remove call to previous.\n+\t* trans-types.c (copy_dt_decls_ifequal): Remove.\n+\t(gfc_get_derived_type): Remove all the paraphenalia for\n+\tassociation of derived types, including calls to previous.\n+\t* match.c (gfc_match_allocate): Call gfc_use_derived to\n+\tassociate any derived types that are being allocated.\n+\n+\tPR fortran/20886\n+\t* resolve.c (resolve_actual_arglist): The passing of\n+\ta generic procedure name as an actual argument is an\n+\terror.\n+\n+\tPR fortran/28735\n+\t* resolve.c (resolve_variable): Check for a symtree before\n+\tresolving references.\n+\n+\tPR fortran/28762\n+\t* primary.c (match_variable): Return MATCH_NO if the symbol\n+\tis that of the program.\n+\n+\tPR fortran/28425\n+\t* trans-expr.c (gfc_trans_subcomponent_assign): Translate\n+\tderived type component expressions other than another derived\n+\ttype constructor.\n+\n+\tPR fortran/28496\n+\t* expr.c (find_array_section): Correct errors in\n+\tthe handling of a missing start value for the\n+\tindex triplet in an array reference.\n+\n+\tPR fortran/18111\n+\t* trans-decl.c (gfc_build_dummy_array_decl): Before resetting\n+\treference to backend_decl, set it DECL_ARTIFICIAL.\n+\t(gfc_get_symbol_decl): Likewise for original dummy decl, when\n+\ta copy is made of an array.\n+\t(create_function_arglist): Likewise for the _entry paramter\n+\tin entry_masters.\n+\t(build_entry_thunks): Likewise for dummies in entry thunks.\n+\n+\tPR fortran/28600\n+\t* trans-decl.c (gfc_get_symbol_decl): Ensure that the\n+\tDECL_CONTEXT of the length of a character dummy is the\n+\tsame as that of the symbol declaration.\n+\n+\tPR fortran/28771\n+\t* decl.c (add_init_expr_to_sym): Remove setting of charlen for\n+\tan initializer of an assumed charlen variable.\n+\n+\tPR fortran/28660\n+\t* trans-decl.c (generate_expr_decls): New function.\n+\t(generate_dependency_declarations): New function.\n+\t(generate_local_decl): Call previous if not either a dummy or\n+\ta declaration in an entry master.\n+\n 2006-08-19  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/25217"}, {"sha": "79310e9dfbead117f58822230795a5323e8beb0d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -875,12 +875,6 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n \t      sym->ts.cl = gfc_get_charlen ();\n \t      sym->ts.cl->next = gfc_current_ns->cl_list;\n \t      gfc_current_ns->cl_list = sym->ts.cl;\n-\n-\t      if (init->expr_type == EXPR_CONSTANT)\n-\t\tsym->ts.cl->length =\n-\t\t\tgfc_int_expr (init->value.character.length);\n-\t      else if (init->expr_type == EXPR_ARRAY)\n-\t\tsym->ts.cl->length = gfc_copy_expr (init->ts.cl->length);\n \t    }\n \t  /* Update initializer character length according symbol.  */\n \t  else if (sym->ts.cl->length->expr_type == EXPR_CONSTANT)"}, {"sha": "b1f064d0720c542d893504c51492527b04979f3c", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -1014,6 +1014,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   int rank;\n   int d;\n   long unsigned one = 1;\n+  mpz_t start[GFC_MAX_DIMENSIONS];\n   mpz_t end[GFC_MAX_DIMENSIONS];\n   mpz_t stride[GFC_MAX_DIMENSIONS];\n   mpz_t delta[GFC_MAX_DIMENSIONS];\n@@ -1052,6 +1053,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   for (d = 0; d < rank; d++)\n     {\n       mpz_init (delta[d]);\n+      mpz_init (start[d]);\n       mpz_init (end[d]);\n       mpz_init (ctr[d]);\n       mpz_init (stride[d]);\n@@ -1085,15 +1087,16 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \tmpz_set_ui (stride[d], one);\n \n       /* Obtain the start value for the index.  */\n-      if (begin->value.integer)\n-\t  mpz_set (ctr[d], begin->value.integer);\n+      if (begin)\n+\t  mpz_set (start[d], begin->value.integer);\n       else\n \t{\n \t  if (mpz_cmp_si (stride[d], 0) < 0)\n-\t    mpz_set (ctr[d], upper->value.integer);\n+\t    mpz_set (start[d], upper->value.integer);\n \t  else\n-\t    mpz_set (ctr[d], lower->value.integer);\n+\t    mpz_set (start[d], lower->value.integer);\n \t}\n+      mpz_set (ctr[d], start[d]);\n \n       /* Obtain the end value for the index.  */\n       if (finish)\n@@ -1171,7 +1174,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t  if (mpz_cmp_ui (stride[d], 0) > 0 ?\n \t\tmpz_cmp (ctr[d], tmp_mpz) > 0 :\n \t\tmpz_cmp (ctr[d], tmp_mpz) < 0)\n-\t    mpz_set (ctr[d], ref->u.ar.start[d]->value.integer);\n+\t    mpz_set (ctr[d], start[d]);\n \t  else\n \t    mpz_set_ui (stop, 0);\n \t}\n@@ -1205,6 +1208,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   for (d = 0; d < rank; d++)\n     {\n       mpz_clear (delta[d]);\n+      mpz_clear (start[d]);\n       mpz_clear (end[d]);\n       mpz_clear (ctr[d]);\n       mpz_clear (stride[d]);"}, {"sha": "14e2ce6bdb0c97d7f6453f3026090bc03a543a0e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -927,17 +927,6 @@ typedef struct gfc_symtree\n }\n gfc_symtree;\n \n-/* A linked list of derived types in the namespace.  */\n-typedef struct gfc_dt_list\n-{\n-  struct gfc_symbol *derived;\n-  struct gfc_dt_list *next;\n-}\n-gfc_dt_list;\n-\n-#define gfc_get_dt_list() gfc_getmem(sizeof(gfc_dt_list))\n-\n-\n /* A namespace describes the contents of procedure, module or\n    interface block.  */\n /* ??? Anything else use these?  */\n@@ -1000,9 +989,6 @@ typedef struct gfc_namespace\n   /* A list of all alternate entry points to this procedure (or NULL).  */\n   gfc_entry_list *entries;\n \n-  /* A list of all derived types in this procedure (or NULL).  */\n-  gfc_dt_list *derived_types;\n-\n   /* Set to 1 if namespace is a BLOCK DATA program unit.  */\n   int is_block_data;\n }"}, {"sha": "e6a7689b0189b786dc404cbcc20856f206ede9f1", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -1798,6 +1798,9 @@ gfc_match_allocate (void)\n \t  goto cleanup;\n \t}\n \n+      if (tail->expr->ts.type == BT_DERIVED)\n+\ttail->expr->ts.derived = gfc_use_derived (tail->expr->ts.derived);\n+\n       if (gfc_match_char (',') != MATCH_YES)\n \tbreak;\n "}, {"sha": "c0ed3643a40d0f5947a544ab02878ea66474e6eb", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -2295,6 +2295,10 @@ match_variable (gfc_expr ** result, int equiv_flag, int host_flag)\n     case FL_VARIABLE:\n       break;\n \n+    case FL_PROGRAM:\n+      return MATCH_NO;\n+      break;\n+\n     case FL_UNKNOWN:\n       if (gfc_add_flavor (&sym->attr, FL_VARIABLE,\n \t\t\t  sym->name, NULL) == FAILURE)"}, {"sha": "3924dc69aa91add6be9dce29517ebd59563e37cd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -858,6 +858,13 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n \t\t\t &e->where);\n \t    }\n \n+\t  if (sym->attr.generic)\n+\t    {\n+\t      gfc_error (\"GENERIC non-INTRINSIC procedure '%s' is not \"\n+\t\t         \"allowed as an actual argument at %L\", sym->name,\n+\t\t\t &e->where);\n+\t    }\n+\n \t  /* If the symbol is the function that names the current (or\n \t     parent) scope, then we really have a variable reference.  */\n \n@@ -2883,10 +2890,10 @@ resolve_variable (gfc_expr * e)\n \n   t = SUCCESS;\n \n-  if (e->ref && resolve_ref (e) == FAILURE)\n+  if (e->symtree == NULL)\n     return FAILURE;\n \n-  if (e->symtree == NULL)\n+  if (e->ref && resolve_ref (e) == FAILURE)\n     return FAILURE;\n \n   sym = e->symtree->n.sym;\n@@ -5360,7 +5367,6 @@ static try\n resolve_fl_derived (gfc_symbol *sym)\n {\n   gfc_component *c;\n-  gfc_dt_list * dt_list;\n   int i;\n \n   for (c = sym->components; c != NULL; c = c->next)\n@@ -5423,12 +5429,6 @@ resolve_fl_derived (gfc_symbol *sym)\n \t}\n     }\n     \n-  /* Add derived type to the derived type list.  */\n-  dt_list = gfc_get_dt_list ();\n-  dt_list->next = sym->ns->derived_types;\n-  dt_list->derived = sym;\n-  sym->ns->derived_types = dt_list;\n-\n   return SUCCESS;\n }\n "}, {"sha": "801e85acec0ec4941ea48f42a2472ef2cc2c90f0", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 79, "deletions": 21, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -1364,6 +1364,33 @@ gfc_add_component (gfc_symbol * sym, const char *name, gfc_component ** componen\n }\n \n \n+/* Recursive search for a renamed derived type.  */\n+\n+static gfc_symbol *\n+find_renamed_type (gfc_symbol * der, gfc_symtree * st)\n+{\n+  gfc_symbol *sym = NULL;\n+\n+  if (st == NULL)\n+    return NULL;\n+\n+  sym = find_renamed_type (der, st->left);\n+  if (sym != NULL)\n+    return sym;\n+\n+  sym = find_renamed_type (der, st->right);\n+  if (sym != NULL)\n+    return sym;\n+\n+  if (strcmp (der->name, st->n.sym->name) == 0\n+\t&& st->n.sym->attr.use_assoc\n+\t&& st->n.sym->attr.flavor == FL_DERIVED\n+\t&& gfc_compare_derived_types (der, st->n.sym))\n+    sym = st->n.sym;\n+\n+  return sym;\n+}\n+\n /* Recursive function to switch derived types of all symbol in a\n    namespace.  */\n \n@@ -1408,20 +1435,68 @@ gfc_use_derived (gfc_symbol * sym)\n   gfc_symbol *s;\n   gfc_typespec *t;\n   gfc_symtree *st;\n+  gfc_component *c;\n   int i;\n \n-  if (sym->components != NULL)\n-    return sym;               /* Already defined.  */\n-\n   if (sym->ns->parent == NULL)\n-    goto bad;\n+    {\n+      /* Already defined in highest possible namespace.  */\n+      if (sym->components != NULL)\n+\treturn sym;\n+\n+      /*  There is no scope for finding a definition elsewhere.  */\n+      else\n+\tgoto bad;\n+    }\n+  else\n+    {\n+      /* This type can only be locally associated.  */\n+      if (!(sym->attr.use_assoc || sym->attr.sequence))\n+\treturn sym;\n+\n+      /* Derived types must be defined within an interface.  */\n+      if (gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY)\n+\treturn sym;\n+    }\n \n+  /* Look in parent namespace for a derived type of the same name.  */\n   if (gfc_find_symbol (sym->name, sym->ns->parent, 1, &s))\n     {\n       gfc_error (\"Symbol '%s' at %C is ambiguous\", sym->name);\n       return NULL;\n     }\n \n+  if (s == NULL || s->attr.flavor != FL_DERIVED)\n+    {\n+      /* Check to see if type has been renamed in parent namespace.\n+\t Leave cleanup of local symbols until the end of the\n+\t compilation because doing it here is complicated by\n+\t multiple association with the same type.  */\n+      s = find_renamed_type (sym, sym->ns->parent->sym_root);\n+      if (s != NULL)\n+\t{\n+\t  switch_types (sym->ns->sym_root, sym, s);\n+\t  return s;\n+\t}\n+\n+      /* The local definition is all that there is.  */\n+      if (sym->components != NULL)\n+\t{\n+\t  /* Non-pointer derived type components have already been checked\n+\t     but pointer types need to be correctly associated.  */\n+\t  for (c = sym->components; c; c = c->next)\n+\t    if (c->ts.type == BT_DERIVED && c->pointer)\n+\t      c->ts.derived = gfc_use_derived (c->ts.derived);\n+\n+\t  return sym;\n+\t}\n+    }\n+\n+  /* Although the parent namespace has a derived type of the same name, it is\n+     not an identical derived type and so cannot be used.  */\n+  if (s != NULL && sym->components != NULL && !gfc_compare_derived_types (s, sym))\n+    return sym;\n+\n   if (s == NULL || s->attr.flavor != FL_DERIVED)\n     goto bad;\n \n@@ -2440,21 +2515,6 @@ free_sym_tree (gfc_symtree * sym_tree)\n }\n \n \n-/* Free a derived type list.  */\n-\n-static void\n-gfc_free_dt_list (gfc_dt_list * dt)\n-{\n-  gfc_dt_list *n;\n-\n-  for (; dt; dt = n)\n-    {\n-      n = dt->next;\n-      gfc_free (dt);\n-    }\n-}\n-\n-\n /* Free the gfc_equiv_info's.  */\n \n static void\n@@ -2517,8 +2577,6 @@ gfc_free_namespace (gfc_namespace * ns)\n   gfc_free_equiv (ns->equiv);\n   gfc_free_equiv_lists (ns->equiv_lists);\n \n-  gfc_free_dt_list (ns->derived_types);\n-\n   for (i = GFC_INTRINSIC_BEGIN; i != GFC_INTRINSIC_END; i++)\n     gfc_free_interface (ns->operator[i]);\n "}, {"sha": "855c98216c56c537a3275ef83a6d07caf8800f73", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 131, "deletions": 3, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -728,6 +728,7 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n       /* We now have an expression for the element size, so create a fully\n \t qualified type.  Reset sym->backend decl or this will just return the\n \t old type.  */\n+      DECL_ARTIFICIAL (sym->backend_decl) = 1;\n       sym->backend_decl = NULL_TREE;\n       type = gfc_sym_type (sym);\n       packed = 2;\n@@ -884,16 +885,27 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  if (TREE_CODE (length) == VAR_DECL\n \t      && DECL_CONTEXT (length) == NULL_TREE)\n \t    {\n-\t      gfc_add_decl_to_function (length);\n+\t      /* Add the string length to the same context as the symbol.  */\n+\t      if (DECL_CONTEXT (sym->backend_decl) == current_function_decl)\n+\t        gfc_add_decl_to_function (length);\n+\t      else\n+\t\tgfc_add_decl_to_parent_function (length);\n+\n+\t      gcc_assert (DECL_CONTEXT (sym->backend_decl) ==\n+\t\t\t    DECL_CONTEXT (length));\n+\n \t      gfc_defer_symbol_init (sym);\n \t    }\n \t}\n \n       /* Use a copy of the descriptor for dummy arrays.  */\n       if (sym->attr.dimension && !TREE_USED (sym->backend_decl))\n         {\n-          sym->backend_decl =\n-            gfc_build_dummy_array_decl (sym, sym->backend_decl);\n+\t  decl = gfc_build_dummy_array_decl (sym, sym->backend_decl);\n+\t  /* Prevent the dummy from being detected as unused if it is copied.  */\n+\t  if (sym->backend_decl != NULL && decl != sym->backend_decl)\n+\t    DECL_ARTIFICIAL (sym->backend_decl) = 1;\n+\t  sym->backend_decl = decl;\n \t}\n \n       TREE_USED (sym->backend_decl) = 1;\n@@ -1284,6 +1296,7 @@ create_function_arglist (gfc_symbol * sym)\n       DECL_ARG_TYPE (parm) = type;\n       TREE_READONLY (parm) = 1;\n       gfc_finish_decl (parm, NULL_TREE);\n+      DECL_ARTIFICIAL (parm) = 1;\n \n       arglist = chainon (arglist, parm);\n       typelist = TREE_CHAIN (typelist);\n@@ -1603,6 +1616,7 @@ build_entry_thunks (gfc_namespace * ns)\n \t  if (thunk_formal)\n \t    {\n \t      /* Pass the argument.  */\n+\t      DECL_ARTIFICIAL (thunk_formal->sym->backend_decl) = 1;\n \t      args = tree_cons (NULL_TREE, thunk_formal->sym->backend_decl,\n \t\t\t\targs);\n \t      if (formal->sym->ts.type == BT_CHARACTER)\n@@ -2743,6 +2757,112 @@ gfc_generate_contained_functions (gfc_namespace * parent)\n }\n \n \n+/* Drill down through expressions for the array specification bounds and\n+   character length calling generate_local_decl for all those variables\n+   that have not already been declared.  */\n+\n+static void\n+generate_local_decl (gfc_symbol *);\n+\n+static void\n+generate_expr_decls (gfc_symbol *sym, gfc_expr *e)\n+{\n+  gfc_actual_arglist *arg;\n+  gfc_ref *ref;\n+  int i;\n+\n+  if (e == NULL)\n+    return;\n+\n+  switch (e->expr_type)\n+    {\n+    case EXPR_FUNCTION:\n+      for (arg = e->value.function.actual; arg; arg = arg->next)\n+\tgenerate_expr_decls (sym, arg->expr);\n+      break;\n+\n+    /* If the variable is not the same as the dependent, 'sym', and\n+       it is not marked as being declared and it is in the same\n+       namespace as 'sym', add it to the local declarations.  */\n+    case EXPR_VARIABLE:\n+      if (sym == e->symtree->n.sym\n+\t    || e->symtree->n.sym->mark\n+\t    || e->symtree->n.sym->ns != sym->ns)\n+\treturn;\n+\n+      generate_local_decl (e->symtree->n.sym);\n+      break;\n+\n+    case EXPR_OP:\n+      generate_expr_decls (sym, e->value.op.op1);\n+      generate_expr_decls (sym, e->value.op.op2);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  if (e->ref)\n+    {\n+      for (ref = e->ref; ref; ref = ref->next)\n+\t{\n+\t  switch (ref->type)\n+\t    {\n+\t    case REF_ARRAY:\n+\t      for (i = 0; i < ref->u.ar.dimen; i++)\n+\t\t{\n+\t\t  generate_expr_decls (sym, ref->u.ar.start[i]);\n+\t\t  generate_expr_decls (sym, ref->u.ar.end[i]);\n+\t\t  generate_expr_decls (sym, ref->u.ar.stride[i]);\n+\t\t}\n+\t      break;\n+\n+\t    case REF_SUBSTRING:\n+\t      generate_expr_decls (sym, ref->u.ss.start);\n+\t      generate_expr_decls (sym, ref->u.ss.end);\n+\t      break;\n+\n+\t    case REF_COMPONENT:\n+\t      if (ref->u.c.component->ts.type == BT_CHARACTER\n+\t\t    && ref->u.c.component->ts.cl->length->expr_type\n+\t\t\t\t\t\t!= EXPR_CONSTANT)\n+\t\tgenerate_expr_decls (sym, ref->u.c.component->ts.cl->length);\n+\n+\t      if (ref->u.c.component->as)\n+\t        for (i = 0; i < ref->u.c.component->as->rank; i++)\n+\t\t  {\n+\t\t    generate_expr_decls (sym, ref->u.c.component->as->lower[i]);\n+\t\t    generate_expr_decls (sym, ref->u.c.component->as->upper[i]);\n+\t\t  }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Check for dependencies in the character length and array spec. */\n+\n+static void\n+generate_dependency_declarations (gfc_symbol *sym)\n+{\n+  int i;\n+\n+  if (sym->ts.type == BT_CHARACTER\n+\t&& sym->ts.cl->length->expr_type != EXPR_CONSTANT)\n+    generate_expr_decls (sym, sym->ts.cl->length);\n+\n+  if (sym->as && sym->as->rank)\n+    {\n+      for (i = 0; i < sym->as->rank; i++)\n+\t{\n+          generate_expr_decls (sym, sym->as->lower[i]);\n+          generate_expr_decls (sym, sym->as->upper[i]);\n+\t}\n+    }\n+}\n+\n+\n /* Generate decls for all local variables.  We do this to ensure correct\n    handling of expressions which only appear in the specification of\n    other functions.  */\n@@ -2752,6 +2872,14 @@ generate_local_decl (gfc_symbol * sym)\n {\n   if (sym->attr.flavor == FL_VARIABLE)\n     {\n+      /* Check for dependencies in the array specification and string\n+\tlength, adding the necessary declarations to the function.  We\n+\tmark the symbol now, as well as in traverse_ns, to prevent\n+\tgetting stuck in a circular dependency.  */\n+      sym->mark = 1;\n+      if (!sym->attr.dummy && !sym->ns->proc_name->attr.entry_master)\n+        generate_dependency_declarations (sym);\n+\n       if (sym->attr.referenced)\n         gfc_get_symbol_decl (sym);\n       else if (sym->attr.dummy && warn_unused_parameter)"}, {"sha": "b1bd2170638729e5ff44101dd9f6c54431fa267b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -2669,9 +2669,19 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n     }\n   else if (expr->ts.type == BT_DERIVED)\n     {\n-      /* Nested derived type.  */\n-      tmp = gfc_trans_structure_assign (dest, expr);\n-      gfc_add_expr_to_block (&block, tmp);\n+      if (expr->expr_type != EXPR_STRUCTURE)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr (&se, expr);\n+\t  gfc_add_modify_expr (&block, dest,\n+\t\t\t       fold_convert (TREE_TYPE (dest), se.expr));\n+\t}\n+      else\n+\t{\n+\t  /* Nested constructors.  */\n+\t  tmp = gfc_trans_structure_assign (dest, expr);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n     }\n   else\n     {"}, {"sha": "3eb1f2cc06d11a3016eef8d64cd6dbb8e5c05870", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 75, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -1411,59 +1411,15 @@ gfc_add_field_to_struct (tree *fieldlist, tree context,\n }\n \n \n-/* Copy the backend_decl and component backend_decls if\n-   the two derived type symbols are \"equal\", as described\n-   in 4.4.2 and resolved by gfc_compare_derived_types.  */\n-\n-static int\n-copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to)\n-{\n-  gfc_component *to_cm;\n-  gfc_component *from_cm;\n-\n-  if (from->backend_decl == NULL\n-\t|| !gfc_compare_derived_types (from, to))\n-    return 0;\n-\n-  to->backend_decl = from->backend_decl;\n-\n-  to_cm = to->components;\n-  from_cm = from->components;\n-\n-  /* Copy the component declarations.  If a component is itself\n-     a derived type, we need a copy of its component declarations.\n-     This is done by recursing into gfc_get_derived_type and\n-     ensures that the component's component declarations have\n-     been built.  If it is a character, we need the character \n-     length, as well.  */\n-  for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)\n-    {\n-      to_cm->backend_decl = from_cm->backend_decl;\n-      if (from_cm->ts.type == BT_DERIVED)\n-\tgfc_get_derived_type (to_cm->ts.derived);\n-\n-      else if (from_cm->ts.type == BT_CHARACTER)\n-\tto_cm->ts.cl->backend_decl = from_cm->ts.cl->backend_decl;\n-    }\n-\n-  return 1;\n-}\n-\n-\n-/* Build a tree node for a derived type.  If there are equal\n-   derived types, with different local names, these are built\n-   at the same time.  If an equal derived type has been built\n-   in a parent namespace, this is used.  */\n+/* Build a tree node for a derived type.  */\n \n static tree\n gfc_get_derived_type (gfc_symbol * derived)\n {\n   tree typenode, field, field_type, fieldlist;\n   gfc_component *c;\n-  gfc_dt_list *dt;\n-  gfc_namespace * ns;\n \n-  gcc_assert (derived && derived->attr.flavor == FL_DERIVED);\n+  gcc_assert (derived);\n \n   /* derived->backend_decl != 0 means we saw it before, but its\n      components' backend_decl may have not been built.  */\n@@ -1477,29 +1433,6 @@ gfc_get_derived_type (gfc_symbol * derived)\n     }\n   else\n     {\n-      /* In a module, if an equal derived type is already available in the\n-\t specification block, use its backend declaration and those of its\n-\t components, rather than building anew so that potential dummy and\n-\t actual arguments use the same TREE_TYPE.  Non-module structures,\n-\t need to be built, if found, because the order of visits to the \n-\t namespaces is different.  */\n-\n-      for (ns = derived->ns->parent; ns; ns = ns->parent)\n-\t{\n-\t  for (dt = ns->derived_types; dt; dt = dt->next)\n-\t    {\n-\t      if (derived->module == NULL\n-\t\t    && dt->derived->backend_decl == NULL\n-\t\t    && gfc_compare_derived_types (dt->derived, derived))\n-\t\tgfc_get_derived_type (dt->derived);\n-\n-\t      if (copy_dt_decls_ifequal (dt->derived, derived))\n-\t\tbreak;\n-\t    }\n-\t  if (derived->backend_decl)\n-\t    goto other_equal_dts;\n-\t}\n-\n       /* We see this derived type first time, so build the type node.  */\n       typenode = make_node (RECORD_TYPE);\n       TYPE_NAME (typenode) = get_identifier (derived->name);\n@@ -1578,12 +1511,6 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n   derived->backend_decl = typenode;\n \n-other_equal_dts:\n-  /* Add this backend_decl to all the other, equal derived types and\n-     their components in this namespace.  */\n-  for (dt = derived->ns->derived_types; dt; dt = dt->next)\n-    copy_dt_decls_ifequal (derived, dt->derived);\n-\n   return derived->backend_decl;\n }\n "}, {"sha": "ad646c5613cae457a6182c8a2bbf5d5fd839688d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -1,3 +1,38 @@\n+2006-08-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28630\n+\t* gfortran.dg/used_types_2.f90: New test.\n+\n+\tPR fortran/28601\n+\t* gfortran.dg/used_types_3.f90: New test.\n+\n+\tPR fortran/20886\n+\t* gfortran.dg/generic_actual_arg.f90: New test.\n+\n+\tPR fortran/28735\n+\t* gfortran.dg/module_private_array_refs_1.f90: New test.\n+\n+\tPR fortran/28762\n+\t* gfortran.dg/program_name_1.f90: New test.\n+\n+\tPR fortran/28425\n+\t* gfortran.dg/derived_constructor_comps_1.f90: New test.\n+\n+\tPR fortran/28496\n+\t* gfortran.dg/array_initializer_2.f90: New test.\n+\n+\tPR fortran/18111\n+\t* gfortran.dg/unused_artificial_dummies_1.f90: New test. \n+\n+\tPR fortran/28600\n+\t* gfortran.dg/assumed_charlen_function_4.f90: New test.\n+\n+\tPR fortran/28771\n+\t* gfortran.dg/assumed_charlen_in_main.f90: New test.\n+\n+\tPR fortran/28660\n+\t* gfortran.dg/dependent_decls_1.f90: New test.\n+\n 2006-08-19  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/25217"}, {"sha": "a1a5bdf024a361c14974ec644b5c74bde121ca44", "filename": "gcc/testsuite/gfortran.dg/array_initializer_2.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_initializer_2.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+! Tests the fix for PR28496 in which initializer array constructors with\n+! a missing initial array index would cause an ICE.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+! Based on original test case from Samir Nordin  <snordin_ng@yahoo.fr> \n+!\n+  integer, dimension(3), parameter :: a=(/1,2,3/)\n+  integer, dimension(3), parameter :: b=(/a(:)/)\n+  integer, dimension(3,3), parameter :: c=reshape ((/(i, i = 1,9)/),(/3,3/))\n+  integer, dimension(2,3), parameter :: d=reshape ((/c(:2:-1,:)/),(/2,3/))\n+  integer, dimension(3,3), parameter :: e=reshape ((/a(:),a(:)+3,a(:)+6/),(/3,3/))\n+  integer, dimension(2,3), parameter :: f=reshape ((/c(2:1:-1,:)/),(/2,3/))\n+  if (any (b .ne. (/1,2,3/))) call abort ()\n+  if (any (reshape(d,(/6/)) .ne. (/3, 2, 6, 5, 9, 8/))) call abort () \n+  if (any (reshape(f,(/6/)) .ne. (/2, 1, 5, 4, 8, 7/))) call abort () \n+end"}, {"sha": "9c96ba4d69fa705a9395fb3abcd76ffd64fb5124", "filename": "gcc/testsuite/gfortran.dg/assumed_charlen_function_4.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_4.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! Tests the fix for PR28600 in which the declaration for the\n+! character length n, would be given the DECL_CONTEXT of 'gee'\n+! thus causing an ICE.\n+!\n+! Contributed by Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+!\n+subroutine bar(s, n)\n+ integer n\n+ character s*(n)\n+ character*3, dimension(:), pointer :: m\n+ s = \"\"\n+contains\n+ subroutine gee\n+    m(1) = s(1:3)\n+ end subroutine gee\n+end subroutine bar"}, {"sha": "a29bdb9d5d023036f909c4b80312be288709a405", "filename": "gcc/testsuite/gfortran.dg/assumed_charlen_in_main.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_in_main.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_in_main.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_in_main.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Tests the fix for PR28771 in which an assumed character length variable with an initializer could\n+! survive in the main program without causing an error.\n+!\n+! Contributed by Martin Reinecke  <martin@mpa-garching.mpg.de>\n+!\n+program test\n+  character(len=*), parameter :: foo = 'test'     ! Parameters must work.\n+  character(len=4) :: bar = foo\n+  character(len=*) :: foobar = 'This should fail' ! {  dg-error \"must be a dummy\" }\n+  print *, bar\n+end\n+"}, {"sha": "675c4a0d00d6ef45bec36657c87b350d1dfa9b7f", "filename": "gcc/testsuite/gfortran.dg/dependent_decls_1.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependent_decls_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependent_decls_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependent_decls_1.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+! Tests the fix for pr28660 in which the order of dependent declarations\n+! would get scrambled in the compiled code.\n+!\n+! Contributed by Erik Edelmann  <erik.edelmann@iki.fi>\n+!\n+program bar\n+    implicit none\n+    real :: x(10)\n+    call foo1 (x)\n+    call foo2 (x)\n+    call foo3 (x)\n+contains\n+    subroutine foo1 (xmin)\n+        real, intent(inout) :: xmin(:)\n+        real :: x(size(xmin)+1)           ! The declaration for r would be added\n+        real :: r(size(x)-2)              ! to the function before that of x\n+        xmin = r\n+        if (size(r) .ne. 9) call abort ()\n+        if (size(x) .ne. 11) call abort ()\n+    end subroutine foo1\n+    subroutine foo2 (xmin)                ! This version was OK because of the\n+        real, intent(inout) :: xmin(:)    ! renaming of r which pushed it up\n+        real :: x(size(xmin)+3)           ! the symtree.\n+        real :: zr(size(x)-6)\n+        xmin = zr\n+        if (size(zr) .ne. 7) call abort ()\n+        if (size(x) .ne. 13) call abort ()\n+    end subroutine foo2\n+    subroutine foo3 (xmin)\n+        real, intent(inout) :: xmin(:)\n+        character(size(x)+2) :: y         ! host associated x\n+        character(len(y)+3) :: z          ! This did not work for any combination\n+        real :: r(len(z)-10)              ! of names.\n+        xmin = r\n+        if (size(r) .ne. 5) call abort ()\n+        if (len(z) .ne. 15) call abort ()\n+    end subroutine foo3\n+end program bar"}, {"sha": "1c02a31c7a319855d0d8317b8b8f78dbef73a7c0", "filename": "gcc/testsuite/gfortran.dg/derived_constructor_comps_1.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_1.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+!\n+! Tests fix for PR28425 in which anything other than a constructor would\n+! not work for derived type components in a structure constructor.\n+!\n+! Original version sent by Vivek Rao on 18 Jan 06\n+! Modified by Steve Kargl to remove IO\n+!\n+module foo_mod\n+\n+  implicit none\n+\n+  type :: date_m\n+     integer :: month\n+  end type date_m\n+\n+  type :: file_info\n+     type(date_m) :: date\n+  end type file_info\n+\n+end module foo_mod\n+\n+program prog\n+\n+  use foo_mod\n+\n+  implicit none\n+  type(date_m)  :: dat\n+  type(file_info) :: xx\n+\n+  type(date_m), parameter :: christmas = date_m (12)\n+\n+  dat = date_m(1)\n+\n+  xx = file_info(date_m(-1))  ! This always worked - a constructor\n+  if (xx%date%month /= -1) call abort\n+\n+  xx = file_info(dat)         ! This was the original PR - a variable\n+  if (xx%date%month /= 1) call abort\n+\n+  xx = file_info(foo(2))      ! ...functions were also broken\n+  if (xx%date%month /= 2) call abort\n+\n+  xx = file_info(christmas)   ! ...and parameters\n+  if (xx%date%month /= 12) call abort\n+\n+\n+contains\n+\n+  function foo (i) result (ans)\n+     integer :: i\n+     type(date_m) :: ans\n+     ans = date_m(i)\n+  end function foo\n+\n+end program prog"}, {"sha": "93a6588592fa8770edef60806f1f8982b83fffe0", "filename": "gcc/testsuite/gfortran.dg/generic_actual_arg.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_actual_arg.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_actual_arg.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_actual_arg.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+! Tests fix for PR20886 in which the passing of a generic procedure as\n+! an actual argument was not detected.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk> \n+!\n+MODULE TEST\n+INTERFACE CALCULATION\n+  MODULE PROCEDURE C1,C2\n+END INTERFACE\n+CONTAINS\n+SUBROUTINE C1(r)\n+ INTEGER :: r\n+END SUBROUTINE\n+SUBROUTINE C2(r)\n+ REAL :: r\n+END SUBROUTINE\n+END MODULE TEST\n+    \n+USE TEST\n+CALL F(CALCULATION) ! { dg-error \"GENERIC non-INTRINSIC procedure\" } \n+END\n+\n+SUBROUTINE F()\n+END SUBROUTINE\n\\ No newline at end of file"}, {"sha": "2b239747b63a1d461e8f68038a5b32706c8fe4c4", "filename": "gcc/testsuite/gfortran.dg/module_private_array_refs_1.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_private_array_refs_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_private_array_refs_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_private_array_refs_1.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do compile }\n+! This tests the fix for PR28735 in which an ICE would be triggered in resolve_ref\n+! because the references to 'a' and 'b' in the dummy arguments of mysub have\n+! no symtrees in module bar, being private there.\n+!\n+! Contributed by  Andrew Sampson  <adsspamtrap01@yahoo.com>\n+!\n+!-- foo.F -----------------------------------------------\n+module foo\n+  implicit none\n+  public\n+  integer, allocatable :: a(:), b(:)\n+end module foo\n+\n+!-- bar.F ---------------------------------------------\n+module bar\n+  use foo\n+  implicit none\n+  private                !  This triggered the ICE\n+  public :: mysub        !  since a and b are not public\n+\n+contains\n+\n+  subroutine mysub(n, parray1)\n+    integer, intent(in) :: n\n+    real, dimension(a(n):b(n)) :: parray1\n+    if ((n == 1) .and. size(parray1, 1) /= 10) call abort ()\n+    if ((n == 2) .and. size(parray1, 1) /= 42) call abort ()\n+  end subroutine mysub\n+end module bar\n+\n+!-- sub.F -------------------------------------------------------\n+subroutine sub()\n+\n+  use foo\n+  use bar\n+  real :: z(100)\n+  allocate (a(2), b(2))\n+  a = (/1, 6/)\n+  b = (/10, 47/)\n+  call mysub (1, z)\n+  call mysub (2, z)\n+\n+  return\n+end\n+\n+!-- MAIN ------------------------------------------------------\n+  use bar\n+  call sub ()\n+end\n+"}, {"sha": "6d6c79bb06d9e87489ceefafd616376792af514b", "filename": "gcc/testsuite/gfortran.dg/program_name_1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fprogram_name_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fprogram_name_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprogram_name_1.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! Tests the fix for PR28762 in which the program name would cause\n+! the compiler to test the write statement as a variable thereby generating\n+! an \"Expecting VARIABLE\" error.\n+!\n+! Contributed by David Ham  <David@ham.dropbear.id.au>\n+!\n+program write\n+  integer :: debuglevel = 1\n+  if (0 < debuglevel) write (*,*) \"Hello World\"\n+end program write"}, {"sha": "68ceee7af331844b3d0bd5af96fdaae08d056861", "filename": "gcc/testsuite/gfortran.dg/unused_artificial_dummies_1.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Funused_artificial_dummies_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Funused_artificial_dummies_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funused_artificial_dummies_1.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+! { dg-options \"-Wunused-variable -Wunused-parameter\" }\n+! This tests the fix for PR18111 in which some artificial declarations\n+! were being listed as unused parameters:\n+! (i) Array dummies, where a copy is made;\n+! (ii) The dummies of \"entry thunks\" (ie. the articial procedures that\n+! represent ENTRYs and call the \"entry_master\" function; and\n+! (iii) The __entry parameter of the entry_master function, which\n+! indentifies the calling entry thunk.\n+! All of these have DECL_ARTIFICIAL (tree) set.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module foo\n+  implicit none\n+contains\n+\n+!This is the original problem\n+\n+  subroutine bar(arg1, arg2, arg3, arg4, arg5)\n+    character(len=80), intent(in) :: arg1\n+    character(len=80), dimension(:), intent(in) :: arg2\n+    integer, dimension(arg4), intent(in) :: arg3\n+    integer, intent(in) :: arg4\n+    character(len=arg4), intent(in) :: arg5\n+    print *, arg1, arg2, arg3, arg4, arg5\n+  end subroutine bar\n+\n+! This ICED with the first version of the fix because gfc_build_dummy_array_decl\n+! sometimes NULLS sym->backend_decl; taken from aliasing_dummy_1.f90\n+\n+  subroutine foo1 (slist, i)\n+    character(*), dimension(*) :: slist\n+    integer i\n+    write (slist(i), '(2hi=,i3)') i\n+  end subroutine foo1\n+\n+! This tests the additions to the fix that prevent the dummies of entry thunks\n+! and entry_master __entry parameters from being listed as unused.\n+\n+  function f1 (a)\n+    integer, dimension (2, 2) :: a, b, f1, e1\n+    f1 (:, :) = 15 + a\n+    return\n+  entry e1 (b)\n+    e1 (:, :) = 42 + b\n+  end function\n+\n+end module foo"}, {"sha": "167323c0cb14658a6234a83e429dca0020a8d813", "filename": "gcc/testsuite/gfortran.dg/used_types_2.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_2.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! Tests the fix for PR28630, in which a contained,\n+! derived type function caused an ICE if its definition\n+! was both host and use associated.\n+!\n+! Contributed by Mark Hesselink <mhesseli@alumni.caltech.edu>\n+!\n+MODULE types\n+   TYPE :: t\n+      INTEGER :: i\n+   END TYPE\n+END MODULE types\n+\n+MODULE foo\n+   USE types\n+CONTAINS\n+   FUNCTION bar (x) RESULT(r)\n+      USE types\n+      REAL, INTENT(IN) :: x\n+      TYPE(t) :: r\n+      r = t(0)\n+   END FUNCTION bar\n+END MODULE\n+\n+\n+LOGICAL FUNCTION foobar (x)\n+   USE foo\n+   REAL, INTENT(IN) :: x\n+   TYPE(t) :: c\n+   foobar = .FALSE.\n+   c = bar (x)\n+END FUNCTION foobar\n+"}, {"sha": "8273ee420ea20d477c936e3b90e537b6f4d8eb3c", "filename": "gcc/testsuite/gfortran.dg/used_types_3.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e978d3094f29abe03d271d63cdc16930c5e51de/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_3.f90?ref=3e978d3094f29abe03d271d63cdc16930c5e51de", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do compile }\n+! Test the fix for PR28601 in which line 55 would produce an ICE\n+! because the rhs and lhs derived times were not identically\n+! associated and so could not be cast.\n+!\n+! Contributed by Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+!\n+module modA\n+implicit none\n+save\n+private\n+\n+type, public :: typA\n+integer :: i\n+end type typA\n+\n+type, public :: atom\n+type(typA), pointer :: ofTypA(:,:)\n+end type atom\n+end module modA\n+\n+!!! re-name and re-export typA as typB:\n+module modB\n+use modA, only: typB => typA\n+implicit none\n+save\n+private\n+\n+public typB\n+end module modB\n+\n+!!! mixed used of typA and typeB:\n+module modC\n+use modB\n+implicit none\n+save\n+private\n+contains\n+\n+subroutine buggy(a)\n+use modA, only: atom\n+! use modB, only: typB\n+! use modA, only: typA\n+implicit none\n+type(atom),intent(inout) :: a\n+target :: a\n+! *** end of interface ***\n+\n+type(typB), pointer :: ofTypB(:,:)\n+! type(typA), pointer :: ofTypB(:,:)\n+integer :: i,j,k\n+\n+ofTypB => a%ofTypA\n+\n+a%ofTypA(i,j) = ofTypB(k,j)\n+end subroutine buggy\n+end module modC"}]}