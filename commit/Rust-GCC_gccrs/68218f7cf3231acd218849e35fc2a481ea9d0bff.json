{"sha": "68218f7cf3231acd218849e35fc2a481ea9d0bff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgyMThmN2NmMzIzMWFjZDIxODg0OWUzNWZjMmE0ODFlYTlkMGJmZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-20T09:27:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-20T09:27:50Z"}, "message": "[multiple changes]\n\n2009-04-20  Arnaud Charlet  <charlet@adacore.com>\n\n\t* switch-c.adb (Scan_Front_End_Switches): Disable inspector mode in\n\tASIS mode.\n\n2009-04-20  Geert Bosch  <bosch@adacore.com>\n\n\t* a-tifiio.adb (Put): Avoid generating too many digits for certain\n\tfixed types with smalls that are neither integer or the reciprocal\n\tof an integer.\n\n2009-04-20  Bob Duff  <duff@adacore.com>\n\n\t* uname.ads: Minor comment fix.\n\n\t* types.ads: Minor comment fix.\n\nFrom-SVN: r146382", "tree": {"sha": "adf7787ef9569dd63423802893ba7751405a5553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adf7787ef9569dd63423802893ba7751405a5553"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68218f7cf3231acd218849e35fc2a481ea9d0bff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68218f7cf3231acd218849e35fc2a481ea9d0bff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68218f7cf3231acd218849e35fc2a481ea9d0bff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68218f7cf3231acd218849e35fc2a481ea9d0bff/comments", "author": null, "committer": null, "parents": [{"sha": "21a495fba4c18d2a025e75c4938964eb1a70df28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21a495fba4c18d2a025e75c4938964eb1a70df28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21a495fba4c18d2a025e75c4938964eb1a70df28"}], "stats": {"total": 189, "additions": 126, "deletions": 63}, "files": [{"sha": "204592b0b53ca6ac00b0aa9e6aa08d4f6493bfd7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=68218f7cf3231acd218849e35fc2a481ea9d0bff", "patch": "@@ -1,3 +1,20 @@\n+2009-04-20  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* switch-c.adb (Scan_Front_End_Switches): Disable inspector mode in\n+\tASIS mode.\n+\n+2009-04-20  Geert Bosch  <bosch@adacore.com>\n+\n+\t* a-tifiio.adb (Put): Avoid generating too many digits for certain\n+\tfixed types with smalls that are neither integer or the reciprocal\n+\tof an integer.\n+\n+2009-04-20  Bob Duff  <duff@adacore.com>\n+\n+\t* uname.ads: Minor comment fix.\n+\n+\t* types.ads: Minor comment fix.\n+\n 2009-04-20  Pascal Obry  <obry@adacore.com>\n \n \t* adaint.c (__gnat_get_libraries_from_registry): Fix code to"}, {"sha": "22926f82cd84f8bb966107f44cab6ce1cffdac41", "filename": "gcc/ada/a-tifiio.adb", "status": "modified", "additions": 91, "deletions": 56, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tifiio.adb?ref=68218f7cf3231acd218849e35fc2a481ea9d0bff", "patch": "@@ -296,8 +296,6 @@ package body Ada.Text_IO.Fixed_IO is\n    --  True iff a numerator and denominator can be calculated such that\n    --  their ratio exactly represents the small of Num\n \n-   --  Local Subprograms\n-\n    procedure Put\n      (To   : out String;\n       Last : out Natural;\n@@ -423,14 +421,6 @@ package body Ada.Text_IO.Fixed_IO is\n       Neg : constant Boolean := (Item < 0.0);\n       Pos : Integer := 0;  -- Next digit X has value X * 10.0**Pos;\n \n-      Y, Z : Int64;\n-      E : constant Integer := Boolean'Pos (not Exact)\n-                                *  (Max_Digits - 1 + Scale);\n-      D : constant Integer := Boolean'Pos (Exact)\n-                                * Integer'Min (A, Max_Digits - (Num'Fore - 1))\n-                            + Boolean'Pos (not Exact)\n-                                * (Scale - 1);\n-\n       procedure Put_Character (C : Character);\n       pragma Inline (Put_Character);\n       --  Add C to the output string To, updating Last\n@@ -442,7 +432,7 @@ package body Ada.Text_IO.Fixed_IO is\n       --  digit, Pos must not be changed outside Put_Digit anymore\n \n       procedure Put_Int64 (X : Int64; Scale : Integer);\n-      --  Output the decimal number X * 10**Scale\n+      --  Output the decimal number abs X * 10**Scale.\n \n       procedure Put_Scaled\n         (X, Y, Z : Int64;\n@@ -548,7 +538,10 @@ package body Ada.Text_IO.Fixed_IO is\n             Put_Digit (0);\n          end loop;\n \n-         --  If Pos is less than Scale now, reset to equal Scale\n+         --  If and only if more than one digit is output before the decimal\n+         --  point, pos will be unequal to scale when outputting the first\n+         --  digit.\n+         pragma Assert (Pos = Scale or else Last = To'First - 1);\n \n          Pos := Scale;\n \n@@ -564,60 +557,87 @@ package body Ada.Text_IO.Fixed_IO is\n          A       : Field;\n          E       : Integer)\n       is\n-         N  : constant Natural := (A + Max_Digits - 1) / Max_Digits + 1;\n-         Q  : array (1 .. N) of Int64 := (others => 0);\n-\n-         XX : Int64 := X;\n-         YY : Int64 := Y;\n-         AA : Field := A;\n+         pragma Assert (E >= -Max_Digits);\n+         AA : constant Field := E + A;\n+         N  : constant Natural := (AA + Max_Digits - 1) / Max_Digits + 1;\n+         Q  : array (0 .. N - 1) of Int64 := (others => 0);\n+         --  Each element of Q has Max_Digits decimal digits, except\n+         --  the last, which has eAA rem Max_Digits. Only Q (Q'First)\n+         --  may have an absolute value equal to or larger than 10**Max_Digits.\n+         --  Only the absolute value of the elements is not significant, not\n+         --  the sign.\n+\n+         XX    : Int64 := X;\n+         YY    : Int64 := Y;\n \n       begin\n          for J in Q'Range loop\n             exit when XX = 0;\n \n-            Scaled_Divide (XX, YY, Z, Q (J), XX, Round => AA = 0);\n+            if J > 0 then\n+               YY := 10**(Integer'Min (Max_Digits, AA - (J - 1) * Max_Digits));\n+            end if;\n \n-            --  As the last block of digits is rounded, a carry may have to\n-            --  be propagated to the more significant digits. Since the last\n-            --  block may have less than Max_Digits, the test for this block\n-            --  is specialized.\n+            Scaled_Divide (XX, YY, Z, Q (J), R => XX, Round => False);\n+         end loop;\n \n-            --  The absolute value of the left-most digit block may equal\n-            --  10*Max_Digits, as no carry can be propagated from there.\n-            --  The final output routines need to be prepared to handle\n-            --  this specific case.\n+         if -E > A then\n+            pragma Assert (N = 1);\n \n-            if (Q (J) = YY or -Q (J) = YY) and then J > Q'First then\n-               if Q (J) < 0 then\n-                  Q (J - 1) := Q (J - 1) + 1;\n+            Discard_Extra_Digits :\n+            declare\n+               Factor : constant Int64 := 10**(-E - A);\n+            begin\n+               --  The scaling factors were such that the first division\n+               --  produced more digits than requested. So divide away extra\n+               --  digits and compute new remainder for later rounding.\n+\n+               if abs (Q (0) rem Factor) >= Factor / 2 then\n+                  Q (0) := abs (Q (0) / Factor) + 1;\n                else\n-                  Q (J - 1) := Q (J - 1) - 1;\n+                  Q (0) := Q (0) / Factor;\n                end if;\n \n-               Q (J) := 0;\n+               XX := 0;\n+            end Discard_Extra_Digits;\n+         end if;\n \n-               Propagate_Carry :\n-               for J in reverse Q'First + 1 .. Q'Last loop\n-                  if Q (J) >= 10**Max_Digits then\n-                     Q (J - 1) := Q (J - 1) + 1;\n-                     Q (J) := Q (J) - 10**Max_Digits;\n+         --  At this point XX is a remainder and we need to determine if\n+         --  the quotient in Q must be rounded away from zero.\n+         --  As XX is less than the divisor, it is safe to take its absolute\n+         --  without chance of overflow. The check to see if XX is at least\n+         --  half the absolute value of the divisor must be done carefully to\n+         --  avoid overflow or lose precision.\n \n-                  elsif Q (J) <= -10**Max_Digits then\n-                     Q (J - 1) := Q (J - 1) - 1;\n-                     Q (J) := Q (J) + 10**Max_Digits;\n-                  end if;\n-               end loop Propagate_Carry;\n-            end if;\n+         XX := abs XX;\n \n-            YY := -10**Integer'Min (Max_Digits, AA);\n-            AA := AA - Integer'Min (Max_Digits, AA);\n-         end loop;\n+         if XX >= 2**62\n+            or else (Z < 0 and then (-XX) * 2 <= Z)\n+            or else (Z >= 0 and then XX * 2 >= Z)\n+         then\n+            --  OK, rounding is necessary. As the sign is not significant,\n+            --  take advantage of the fact that an extra negative value will\n+            --  always be available when propagating the carry.\n+\n+            Q (Q'Last) := -abs Q (Q'Last) - 1;\n+\n+            Propagate_Carry :\n+            for J in reverse 1 .. Q'Last loop\n+               if Q (J) = YY or else Q (J) = -YY then\n+                  Q (J) := 0;\n+                  Q (J - 1) := -abs Q (J - 1) - 1;\n+\n+               else\n+                  exit Propagate_Carry;\n+               end if;\n+            end loop Propagate_Carry;\n+         end if;\n \n          for J in Q'First .. Q'Last - 1 loop\n-            Put_Int64 (Q (J), E - (J - Q'First) * Max_Digits);\n+            Put_Int64 (Q (J), E - J * Max_Digits);\n          end loop;\n \n-         Put_Int64 (Q (Q'Last), E - A);\n+         Put_Int64 (Q (Q'Last), -A);\n       end Put_Scaled;\n \n    --  Start of processing for Put\n@@ -652,20 +672,35 @@ package body Ada.Text_IO.Fixed_IO is\n       end if;\n \n       if Exact then\n-         Y := Int64'Min (Int64 (-Num'Small), -1) * 10**Integer'Max (0, D);\n-         Z := Int64'Min (Int64 (-(1.0 / Num'Small)), -1)\n-                                                 * 10**Integer'Max (0, -D);\n-      else\n-         Y := Int64 (-(Num'Small * 10.0**E));\n-         Z := -10**Max_Digits;\n+         declare\n+            D : constant Integer := Integer'Min (A, Max_Digits\n+                                                            - (Num'Fore - 1));\n+            Y : constant Int64   := Int64'Min (Int64 (-Num'Small), -1)\n+                                     * 10**Integer'Max (0, D);\n+            Z : constant Int64   := Int64'Min (Int64 (-(1.0 / Num'Small)), -1)\n+                                     * 10**Integer'Max (0, -D);\n+         begin\n+            Put_Scaled (X, Y, Z, A, -D);\n+         end;\n+\n+      else -- not Exact\n+         declare\n+            E : constant Integer := Max_Digits - 1 + Scale;\n+            D : constant Integer := Scale - 1;\n+            Y : constant Int64   := Int64 (-Num'Small * 10.0**E);\n+            Z : constant Int64   := -10**Max_Digits;\n+         begin\n+            Put_Scaled (X, Y, Z, A, -D);\n+         end;\n       end if;\n \n-      Put_Scaled (X, Y, Z, A - D, -D);\n-\n       --  If only zero digits encountered, unit digit has not been output yet\n \n       if Last < To'First then\n          Pos := 0;\n+\n+      elsif Last > To'Last then\n+         raise Layout_Error; -- Not enough room in the output variable\n       end if;\n \n       --  Always output digits up to the first one after the decimal point"}, {"sha": "dc8538363de46249882d0c0bcd7214b7c72968f9", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=68218f7cf3231acd218849e35fc2a481ea9d0bff", "patch": "@@ -257,12 +257,23 @@ package body Switch.C is\n                         Set_Dotted_Debug_Flag (C);\n                         Store_Compilation_Switch (\"-gnatd.\" & C);\n \n-                        --  Disable front-end inlining in inspector mode\n                         --  ??? Change this when we use a non debug flag to\n                         --  enable inspector mode.\n \n                         if C = 'I' then\n-                           Front_End_Inlining := False;\n+                           if ASIS_Mode then\n+                              --  Do not enable inspector mode in ASIS mode,\n+                              --  since the two switches are incompatible.\n+\n+                              Inspector_Mode := False;\n+\n+                           else\n+                              --  In inspector mode, we need back-end rep info\n+                              --  annotations and disable front-end inlining.\n+\n+                              Back_Annotate_Rep_Info := True;\n+                              Front_End_Inlining := False;\n+                           end if;\n                         end if;\n                      else\n                         Set_Debug_Flag (C);"}, {"sha": "98bcbdbf9a2df1a3d193b7f1621c1b6c89332722", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=68218f7cf3231acd218849e35fc2a481ea9d0bff", "patch": "@@ -450,8 +450,8 @@ package Types is\n    ------------------------------\n \n    --  Element list Id values are used to identify element lists stored in the\n-   --  tree (see package Tree for further details). They are formed by adding a\n-   --  bias (Element_List_Bias) to subscript values in the same array that is\n+   --  tree (see package Atree for further details). They are formed by adding\n+   --  a bias (Element_List_Bias) to subscript values in the same array that is\n    --  used for node list headers.\n \n    type Elist_Id is range Elist_Low_Bound .. Elist_High_Bound;"}, {"sha": "d5220408085388d4b3ec384dcbc5a12475e24957", "filename": "gcc/ada/uname.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2Funame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68218f7cf3231acd218849e35fc2a481ea9d0bff/gcc%2Fada%2Funame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funame.ads?ref=68218f7cf3231acd218849e35fc2a481ea9d0bff", "patch": "@@ -48,9 +48,9 @@ package Uname is\n    --    %b  for package/subprogram/generic bodies and subunits\n \n    --  Unit names are stored in the names table, and referred to by the\n-   --  corresponding Name_Id values. The subtype Unit_Name, which is a\n-   --  synonym for Name_Id, is used to indicate that a Name_Id value that\n-   --  holds a unit name (as defined above) is expected.\n+   --  corresponding Name_Id values. The type Unit_Name_Type, derived from\n+   --  Name_Id, is used to indicate that a Name_Id value that holds a unit name\n+   --  (as defined above) is expected.\n \n    --  Note: as far as possible the conventions for unit names are encapsulated\n    --  in this package. The one exception is that package Fname, which provides"}]}