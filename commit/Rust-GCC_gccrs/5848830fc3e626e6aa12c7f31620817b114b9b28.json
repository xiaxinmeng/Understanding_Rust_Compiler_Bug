{"sha": "5848830fc3e626e6aa12c7f31620817b114b9b28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg0ODgzMGZjM2U2MjZlNmFhMTJjN2YzMTYyMDgxN2IxMTRiOWIyOA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@nowt.org", "date": "2004-03-24T17:20:16Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-03-24T17:20:16Z"}, "message": "config.gcc: Add --with-abi=\n\n\t* config.gcc <arm>: Add --with-abi=\n\t* config/arm/arm-protos.h (arm_get_frame_size, thumb_get_frame_size,\n\tthumb_far_jump_used): Remove prototypes.\n\t(arm_needs_doubleword_align): Add prototype.\n\t(thumb_compute_initial_elimination_offset): Ditto.\n\t* config/arm/arm.c (arm_get_frame_offsets): New function.\n\t(use_return_insn, output_return_instruction, arm_output_epilogue,\n\tarm_output_function_epilogue, arm_compute_initial_elimination_offset,\n\tarm_expand_prologue, thumb_expand_epilogue): Use it.\n\t(arm_abi, target_abi_name, all_arm_abis): New variables.\n\t(arm_override_options): Set them.  Set structure padding for AAPCS.\n\t(arm_return_in_memory): Update ABI check.\n\t(arm_init_cumulative_args): Initialize can_split.\n\t(arm_needs_doubleword_align): New function.\n\t(arm_function_arg): Don't split args after pushing to stack. Handle\n\tdoubleword/even reg alignment.\n\t(arm_va_arg): Handle all doubleword aligned args.\n\t(add_minpoolforward ref, dump_minpool, push_minpool_fix): Align based\n\ton ABI, not CPU.\n\t(arm_compute_save_reg0_reg12_mask): Fix comment.\n\t(thumb_get_frame_size, thumb_get_frame_size): Remove.\n\t(thumb_jump_far_used_p): Remove superfluous argument.  Return save\n\tvalue for alignment.\n\t(thumb_unexpanded_epilogue, thumb_output_function_prologue): Change\n\tto match.\n\t(thumb_compute_initial_elimination_offset): New function.\n\t(thumb_expand_prologue): Use arm_get_frame_offsets.  Remove\n\tunneccessary rounding.\n\t* config/arm/arm.h (target_abi_name): Declare.\n\t(ARM_DOUBLEWORD_ALIGN, DOUBLEWORD_ALIGNMENT, TARGET_IWMMXT_ABI,\n\tarm_abi_type, ARM_DEFAULT_ABI): Define.\n\t(ARM_FLAG_ATPCS): Remove.\n\t(TARGET_OPTIONS, OPTION_DEFAULT_SPECS): Add -mabi=.\n\t(BIGGEST_ALIGNMENT, PREFERRED_STACK_BOUNDARY, STACK_BOUNDARY): Use it.\n\t(ADJUST_FIELD_ALIGN, DATA_ALIGNMENT, LOCAL_ALIGNMENT,\n\tTYPE_NEEDS_IWMMXT_ALIGNMENT): Remove.\n\t(LIBCALL_VALUE, FUNCTION_VALUE_REGNO_P, FUNCTION_ARG_REGNO_P):\n\tContitionalize on ABI, not CPU.\n\t(struct arm_stack_offsets): Define.\n\t(struct machine_function): Add stack_offsets.  Remove frame_size.\n\t(FUNCTION_ARG_PARTIAL_NREGS): Don't split if previous args have been\n\tpushed.\n\t(FUNCTION_ARG_ADVANCE, FUNCTION_ARG_BOUNDARY): Handle general\n\tdoubleword alignment.\n\t(THUMB_INITIAL_ELIMINATION_OFFSET,\n\tARM_INITIAL_ELIMINATION_OFFSET): Remove.\n\t(INITIAL_ELIMINATION_OFFSET): Call functions directly.\n\t* config/arm/arm.md (align_8): Enable for all targets.\n\t* config/arm/netbsd-elf.h (TARGET_DEFAULT): Remove TARGET_ATPCS.\n\t(ARM_DEFAULT_ABI): Define.\n\t* doc/invoke.texi <ARM>: Document -mabi=. Update documentation for\n\t-mstructure-size-boundary.\n\nFrom-SVN: r79921", "tree": {"sha": "a94720070e991dfe64bb18f210744799e935aef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a94720070e991dfe64bb18f210744799e935aef3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5848830fc3e626e6aa12c7f31620817b114b9b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5848830fc3e626e6aa12c7f31620817b114b9b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5848830fc3e626e6aa12c7f31620817b114b9b28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5848830fc3e626e6aa12c7f31620817b114b9b28/comments", "author": {"login": "pbrook", "id": 182159, "node_id": "MDQ6VXNlcjE4MjE1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/182159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pbrook", "html_url": "https://github.com/pbrook", "followers_url": "https://api.github.com/users/pbrook/followers", "following_url": "https://api.github.com/users/pbrook/following{/other_user}", "gists_url": "https://api.github.com/users/pbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/pbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pbrook/subscriptions", "organizations_url": "https://api.github.com/users/pbrook/orgs", "repos_url": "https://api.github.com/users/pbrook/repos", "events_url": "https://api.github.com/users/pbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/pbrook/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4a76c01dbc8f3c3acff5ef3b44cc19249299a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4a76c01dbc8f3c3acff5ef3b44cc19249299a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4a76c01dbc8f3c3acff5ef3b44cc19249299a20"}], "stats": {"total": 979, "additions": 534, "deletions": 445}, "files": [{"sha": "f6c465078e02c245012e6e956feb083ae855c8e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5848830fc3e626e6aa12c7f31620817b114b9b28", "patch": "@@ -1,3 +1,58 @@\n+2004-03-24  Paul Brook  <paul@nowt.org>\n+\n+\t* config.gcc <arm>: Add --with-abi=\n+\t* config/arm/arm-protos.h (arm_get_frame_size, thumb_get_frame_size,\n+\tthumb_far_jump_used): Remove prototypes.\n+\t(arm_needs_doubleword_align): Add prototype.\n+\t(thumb_compute_initial_elimination_offset): Ditto.\n+\t* config/arm/arm.c (arm_get_frame_offsets): New function.\n+\t(use_return_insn, output_return_instruction, arm_output_epilogue,\n+\tarm_output_function_epilogue, arm_compute_initial_elimination_offset,\n+\tarm_expand_prologue, thumb_expand_epilogue): Use it.\n+\t(arm_abi, target_abi_name, all_arm_abis): New variables.\n+\t(arm_override_options): Set them.  Set structure padding for AAPCS.\n+\t(arm_return_in_memory): Update ABI check.\n+\t(arm_init_cumulative_args): Initialize can_split.\n+\t(arm_needs_doubleword_align): New function.\n+\t(arm_function_arg): Don't split args after pushing to stack. Handle\n+\tdoubleword/even reg alignment.\n+\t(arm_va_arg): Handle all doubleword aligned args.\n+\t(add_minpoolforward ref, dump_minpool, push_minpool_fix): Align based\n+\ton ABI, not CPU.\n+\t(arm_compute_save_reg0_reg12_mask): Fix comment.\n+\t(thumb_get_frame_size, thumb_get_frame_size): Remove.\n+\t(thumb_jump_far_used_p): Remove superfluous argument.  Return save\n+\tvalue for alignment.\n+\t(thumb_unexpanded_epilogue, thumb_output_function_prologue): Change\n+\tto match.\n+\t(thumb_compute_initial_elimination_offset): New function.\n+\t(thumb_expand_prologue): Use arm_get_frame_offsets.  Remove\n+\tunneccessary rounding.\n+\t* config/arm/arm.h (target_abi_name): Declare.\n+\t(ARM_DOUBLEWORD_ALIGN, DOUBLEWORD_ALIGNMENT, TARGET_IWMMXT_ABI,\n+\tarm_abi_type, ARM_DEFAULT_ABI): Define.\n+\t(ARM_FLAG_ATPCS): Remove.\n+\t(TARGET_OPTIONS, OPTION_DEFAULT_SPECS): Add -mabi=.\n+\t(BIGGEST_ALIGNMENT, PREFERRED_STACK_BOUNDARY, STACK_BOUNDARY): Use it.\n+\t(ADJUST_FIELD_ALIGN, DATA_ALIGNMENT, LOCAL_ALIGNMENT,\n+\tTYPE_NEEDS_IWMMXT_ALIGNMENT): Remove.\n+\t(LIBCALL_VALUE, FUNCTION_VALUE_REGNO_P, FUNCTION_ARG_REGNO_P):\n+\tContitionalize on ABI, not CPU.\n+\t(struct arm_stack_offsets): Define.\n+\t(struct machine_function): Add stack_offsets.  Remove frame_size.\n+\t(FUNCTION_ARG_PARTIAL_NREGS): Don't split if previous args have been\n+\tpushed.\n+\t(FUNCTION_ARG_ADVANCE, FUNCTION_ARG_BOUNDARY): Handle general\n+\tdoubleword alignment.\n+\t(THUMB_INITIAL_ELIMINATION_OFFSET,\n+\tARM_INITIAL_ELIMINATION_OFFSET): Remove.\n+\t(INITIAL_ELIMINATION_OFFSET): Call functions directly.\n+\t* config/arm/arm.md (align_8): Enable for all targets.\n+\t* config/arm/netbsd-elf.h (TARGET_DEFAULT): Remove TARGET_ATPCS.\n+\t(ARM_DEFAULT_ABI): Define.\n+\t* doc/invoke.texi <ARM>: Document -mabi=. Update documentation for\n+\t-mstructure-size-boundary.\n+\n 2004-03-24  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* configure.ac: Check for -Wno-variadic-macros; don't use"}, {"sha": "8d7f0d04d207dbe7e6618cb311b5c0f70d4b8d44", "filename": "gcc/config.gcc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=5848830fc3e626e6aa12c7f31620817b114b9b28", "patch": "@@ -2226,7 +2226,7 @@ fi\n \t\t;;\n \n \tarm*-*-*)\n-\t\tsupported_defaults=\"arch cpu float tune fpu\"\n+\t\tsupported_defaults=\"arch cpu float tune fpu abi\"\n \t\tfor which in cpu tune; do\n \t\t\teval \"val=\\$with_$which\"\n \t\t\tcase \"$val\" in\n@@ -2280,13 +2280,24 @@ fi\n \t\t\t# OK\n \t\t\t;;\n \t\t*)\n-\t\t\techo \"Unknown fpu used in --with-fpu=$fpu\" 2>&1\n+\t\t\techo \"Unknown fpu used in --with-fpu=$with_fpu\" 2>&1\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\n+\t\tcase \"$with_abi\" in\n+\t\t\"\" \\\n+\t\t| apcs-gnu | atpcs | aapcs | iwmmxt )\n+\t\t\t#OK\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"Unknown ABI used in --with-abi=$with_abi\"\n \t\t\texit 1\n \t\t\t;;\n \t\tesac\n \n \t\tif test \"x$with_arch\" != x && test \"x$with_cpu\" != x; then\n-\t\t\techo \"Warning: --with-arch overrides --with-cpu\" 1>&2\n+\t\t\techo \"Warning: --with-arch overrides --with-cpu=$with_cpu\" 1>&2\n \t\tfi\n \t\t;;\n "}, {"sha": "986f1eca78efcc2fdb212d28399bf55a8dda7f4c", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=5848830fc3e626e6aa12c7f31620817b114b9b28", "patch": "@@ -31,12 +31,13 @@ extern void arm_finalize_pic (int);\n extern int arm_volatile_func (void);\n extern const char *arm_output_epilogue (rtx);\n extern void arm_expand_prologue (void);\n-extern HOST_WIDE_INT arm_get_frame_size\t(void);\n extern const char *arm_strip_name_encoding (const char *);\n extern void arm_asm_output_labelref (FILE *, const char *);\n extern unsigned long arm_current_func_type (void);\n extern unsigned int arm_compute_initial_elimination_offset (unsigned int,\n \t\t\t\t\t\t\t    unsigned int);\n+extern HOST_WIDE_INT thumb_compute_initial_elimination_offset (unsigned int,\n+\t\t\t\t\t\t\t       unsigned int);\n \n #ifdef TREE_CODE\n extern int arm_return_in_memory (tree);\n@@ -157,6 +158,7 @@ extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern rtx arm_va_arg (tree, tree);\n extern int arm_function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n \t\t\t\t\t       enum machine_mode, tree, int);\n+extern bool arm_needs_doubleword_align (enum machine_mode, tree);\n #endif\n \n #if defined AOF_ASSEMBLER \n@@ -175,9 +177,7 @@ extern int arm_float_words_big_endian (void);\n \n /* Thumb functions.  */\n extern void arm_init_expanders (void);\n-extern int thumb_far_jump_used_p (int);\n extern const char *thumb_unexpanded_epilogue (void);\n-extern HOST_WIDE_INT thumb_get_frame_size (void);\n extern void thumb_expand_prologue (void);\n extern void thumb_expand_epilogue (void);\n #ifdef TREE_CODE"}, {"sha": "a957a130f43f9f83e993158dfeb6ff165323d741", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 369, "deletions": 322, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5848830fc3e626e6aa12c7f31620817b114b9b28", "patch": "@@ -59,6 +59,7 @@ typedef struct minipool_fixup   Mfix;\n const struct attribute_spec arm_attribute_table[];\n \n /* Forward function declarations.  */\n+static arm_stack_offsets *arm_get_frame_offsets (void);\n static void arm_add_gc_roots (void);\n static int arm_gen_constant (enum rtx_code, enum machine_mode, HOST_WIDE_INT,\n \t\t\t     rtx, rtx, int, int);\n@@ -67,6 +68,7 @@ static int arm_address_register_rtx_p (rtx, int);\n static int arm_legitimate_index_p (enum machine_mode, rtx, RTX_CODE, int);\n static int thumb_base_register_rtx_p (rtx, enum machine_mode, int);\n inline static int thumb_index_register_rtx_p (rtx, int);\n+static int thumb_far_jump_used_p (void);\n static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n static rtx emit_multi_reg_push (int);\n static rtx emit_sfm (int, int);\n@@ -284,6 +286,9 @@ enum fputype arm_fpu_tune;\n /* Whether to use floating point hardware.  */\n enum float_abi_type arm_float_abi;\n \n+/* Which ABI to use.  */\n+enum arm_abi_type arm_abi;\n+\n /* What program mode is the cpu running in? 26-bit mode or 32-bit mode.  */\n enum prog_mode_type arm_prgmode;\n \n@@ -296,6 +301,9 @@ const char * target_fpe_name = NULL;\n /* Set by the -mfloat-abi=... option.  */\n const char * target_float_abi_name = NULL;\n \n+/* Set by the -mabi=... option.  */\n+const char * target_abi_name = NULL;\n+\n /* Used to parse -mstructure_size_boundary command line option.  */\n const char * structure_size_string = NULL;\n int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n@@ -510,6 +518,23 @@ static const struct float_abi all_float_abis[] =\n };\n \n \n+struct abi_name\n+{\n+  const char *name;\n+  enum arm_abi_type abi_type;\n+};\n+\n+\n+/* Available values for -mabi=.  */\n+\n+static const struct abi_name arm_all_abis[] =\n+{\n+  {\"apcs-gnu\",    ARM_ABI_APCS},\n+  {\"atpcs\",   ARM_ABI_ATPCS},\n+  {\"aapcs\",   ARM_ABI_AAPCS},\n+  {\"iwmmxt\",  ARM_ABI_IWMMXT}\n+};\n+\n /* Return the number of bits set in VALUE.  */\n static unsigned\n bit_count (unsigned long value)\n@@ -814,8 +839,27 @@ arm_override_options (void)\n   arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;\n   arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;\n \n-  if (TARGET_IWMMXT && (! TARGET_ATPCS))\n-    target_flags |= ARM_FLAG_ATPCS;    \n+  if (target_abi_name)\n+    {\n+      for (i = 0; i < ARRAY_SIZE (arm_all_abis); i++)\n+\t{\n+\t  if (streq (arm_all_abis[i].name, target_abi_name))\n+\t    {\n+\t      arm_abi = arm_all_abis[i].abi_type;\n+\t      break;\n+\t    }\n+\t}\n+      if (i == ARRAY_SIZE (arm_all_abis))\n+\terror (\"invalid ABI option: -mabi=%s\", target_abi_name);\n+    }\n+  else\n+    arm_abi = ARM_DEFAULT_ABI;\n+\n+  if (TARGET_IWMMXT && !ARM_DOUBLEWORD_ALIGN)\n+    error (\"iwmmxt requires an AAPCS compatible ABI for proper operation\");\n+\n+  if (TARGET_IWMMXT_ABI && !TARGET_IWMMXT)\n+    error (\"iwmmxt abi requires an iwmmxt capable cpu\");\n \n   arm_fp_model = ARM_FP_MODEL_UNKNOWN;\n   if (target_fpu_name == NULL && target_fpe_name != NULL)\n@@ -908,14 +952,20 @@ arm_override_options (void)\n   \n   arm_prgmode = TARGET_APCS_32 ? PROG_MODE_PROG32 : PROG_MODE_PROG26;\n   \n+  /* Override the default structure alignment for AAPCS ABI.  */\n+  if (arm_abi == ARM_ABI_AAPCS)\n+    arm_structure_size_boundary = 8;\n+\n   if (structure_size_string != NULL)\n     {\n       int size = strtol (structure_size_string, NULL, 0);\n-      \n-      if (size == 8 || size == 32)\n+\n+      if (size == 8 || size == 32\n+\t  || (ARM_DOUBLEWORD_ALIGN && size == 64))\n \tarm_structure_size_boundary = size;\n       else\n-\twarning (\"structure size boundary can only be set to 8 or 32\");\n+\twarning (\"structure size boundary can only be set to %s\",\n+\t\t ARM_DOUBLEWORD_ALIGN ? \"8, 32 or 64\": \"8 or 32\");\n     }\n \n   if (arm_pic_register_string != NULL)\n@@ -1109,6 +1159,7 @@ use_return_insn (int iscond, rtx sibling)\n   unsigned int func_type;\n   unsigned long saved_int_regs;\n   unsigned HOST_WIDE_INT stack_adjust;\n+  arm_stack_offsets *offsets;\n \n   /* Never use a return instruction before reload has run.  */\n   if (!reload_completed)\n@@ -1125,7 +1176,8 @@ use_return_insn (int iscond, rtx sibling)\n   if (IS_INTERRUPT (func_type) && frame_pointer_needed)\n     return 0;\n \n-  stack_adjust = arm_get_frame_size () + current_function_outgoing_args_size;\n+  offsets = arm_get_frame_offsets ();\n+  stack_adjust = offsets->outgoing_args - offsets->saved_regs;\n \n   /* As do variadic functions.  */\n   if (current_function_pretend_args_size\n@@ -2018,9 +2070,9 @@ arm_return_in_memory (tree type)\n \n   size = int_size_in_bytes (type);\n \n-  if (TARGET_ATPCS)\n+  if (arm_abi != ARM_ABI_APCS)\n     {\n-      /* ATPCS returns aggregate types in memory only if they are\n+      /* ATPCS and later return aggregate types in memory only if they are\n \t larger than a word (or are variable size).  */\n       return (size < 0 || size > UNITS_PER_WORD);\n     }\n@@ -2143,6 +2195,7 @@ arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n   /* On the ARM, the offset starts at 0.  */\n   pcum->nregs = ((fntype && aggregate_value_p (TREE_TYPE (fntype), fntype)) ? 1 : 0);\n   pcum->iwmmxt_nregs = 0;\n+  pcum->can_split = true;\n   \n   pcum->call_cookie = CALL_NORMAL;\n \n@@ -2178,6 +2231,19 @@ arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n     }\n }\n \n+\n+/* Return true if mode/type need doubleword alignment.  */\n+bool\n+arm_needs_doubleword_align (enum machine_mode mode, tree type)\n+{\n+  return (mode == DImode\n+\t  || mode == DFmode\n+\t  || VECTOR_MODE_SUPPORTED_P (mode)\n+\t  || (mode == BLKmode\n+\t      && TYPE_ALIGN (type) > PARM_BOUNDARY));\n+}\n+\n+\n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -2193,37 +2259,44 @@ arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n \n rtx\n arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n-\t\t  tree type ATTRIBUTE_UNUSED, int named)\n+\t\t  tree type, int named)\n {\n-  if (TARGET_REALLY_IWMMXT)\n+  int nregs;\n+\n+  /* Varargs vectors are treated the same as long long.\n+     named_count avoids having to change the way arm handles 'named' */\n+  if (TARGET_IWMMXT_ABI\n+      && VECTOR_MODE_SUPPORTED_P (mode)\n+      && pcum->named_count > pcum->nargs + 1)\n     {\n-      if (VECTOR_MODE_SUPPORTED_P (mode))\n+      if (pcum->iwmmxt_nregs <= 9)\n+\treturn gen_rtx_REG (mode, pcum->iwmmxt_nregs + FIRST_IWMMXT_REGNUM);\n+      else\n \t{\n-\t  /* varargs vectors are treated the same as long long.\n-\t     named_count avoids having to change the way arm handles 'named' */\n-\t  if (pcum->named_count <= pcum->nargs + 1)\n-\t    {\n-\t      if (pcum->nregs == 1)\n-\t\tpcum->nregs += 1;\n-\t      if (pcum->nregs <= 2)\n-\t\treturn gen_rtx_REG (mode, pcum->nregs);\n-\t      else\n-\t\treturn NULL_RTX;\n-\t    }\n-\t  else if (pcum->iwmmxt_nregs <= 9)\n-\t    return gen_rtx_REG (mode, pcum->iwmmxt_nregs + FIRST_IWMMXT_REGNUM);\n-\t  else\n-\t    return NULL_RTX;\n+\t  pcum->can_split = false;\n+\t  return NULL_RTX;\n \t}\n-      else if ((mode == DImode || mode == DFmode) && pcum->nregs & 1)\n-\tpcum->nregs += 1;\n     }\n \n+  /* Put doubleword aligned quantities in even register pairs.  */\n+  if (pcum->nregs & 1\n+      && ARM_DOUBLEWORD_ALIGN\n+      && arm_needs_doubleword_align (mode, type))\n+    pcum->nregs++;\n+\n   if (mode == VOIDmode)\n     /* Compute operand 2 of the call insn.  */\n     return GEN_INT (pcum->call_cookie);\n-  \n-  if (!named || pcum->nregs >= NUM_ARG_REGS)\n+\n+  /* Only allow splitting an arg between regs and memory if all preceeding\n+     args were allocated to regs.  For args passed by reference we only count\n+     the reference pointer.  */\n+  if (pcum->can_split)\n+    nregs = 1;\n+  else\n+    nregs = ARM_NUM_REGS2 (mode, type);\n+\n+  if (!named || pcum->nregs + nregs > NUM_ARG_REGS)\n     return NULL_RTX;\n   \n   return gen_rtx_REG (mode, pcum->nregs);\n@@ -2245,24 +2318,27 @@ arm_function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n rtx\n arm_va_arg (tree valist, tree type)\n {\n+  int align;\n+\n   /* Variable sized types are passed by reference.  */\n   if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n       rtx addr = std_expand_builtin_va_arg (valist, build_pointer_type (type));\n       return gen_rtx_MEM (ptr_mode, force_reg (Pmode, addr));\n     }\n \n-  if (FUNCTION_ARG_BOUNDARY (TYPE_MODE (type), NULL) == IWMMXT_ALIGNMENT)\n+  align = FUNCTION_ARG_BOUNDARY (TYPE_MODE (type), type);\n+  if (align > PARM_BOUNDARY)\n     {\n-      tree minus_eight;\n+      tree mask;\n       tree t;\n \n       /* Maintain 64-bit alignment of the valist pointer by\n \t constructing:   valist = ((valist + (8 - 1)) & -8).  */\n-      minus_eight = build_int_2 (- (IWMMXT_ALIGNMENT / BITS_PER_UNIT), -1);\n-      t = build_int_2 ((IWMMXT_ALIGNMENT / BITS_PER_UNIT) - 1, 0);\n+      mask = build_int_2 (- (align / BITS_PER_UNIT), -1);\n+      t = build_int_2 ((align / BITS_PER_UNIT) - 1, 0);\n       t = build (PLUS_EXPR,    TREE_TYPE (valist), valist, t);\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, minus_eight);\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, mask);\n       t = build (MODIFY_EXPR,  TREE_TYPE (valist), valist, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6846,7 +6922,7 @@ add_minipool_forward_ref (Mfix *fix)\n \t we have not already found an insertion point, then\n \t make sure that all such 8-byte aligned quantities are\n \t placed at the start of the pool.  */\n-      if (TARGET_REALLY_IWMMXT\n+      if (ARM_DOUBLEWORD_ALIGN\n \t  && max_mp == NULL\n \t  && fix->fix_size == 8\n \t  && mp->fix_size != 8)\n@@ -7030,7 +7106,8 @@ add_minipool_backward_ref (Mfix *fix)\n \t    {\n \t      /* For now, we do not allow the insertion of 8-byte alignment\n \t\t requiring nodes anywhere but at the start of the pool.  */\n-\t      if (TARGET_REALLY_IWMMXT && fix->fix_size == 8 && mp->fix_size != 8)\n+\t      if (ARM_DOUBLEWORD_ALIGN\n+\t\t  && fix->fix_size == 8 && mp->fix_size != 8)\n \t\treturn NULL;\n \t      else\n \t\tmin_mp = mp;\n@@ -7049,7 +7126,7 @@ add_minipool_backward_ref (Mfix *fix)\n \t     we have not already found an insertion point, then\n \t     make sure that all such 8-byte aligned quantities are\n \t     placed at the start of the pool.  */\n-\t  else if (TARGET_REALLY_IWMMXT\n+\t  else if (ARM_DOUBLEWORD_ALIGN\n \t\t   && min_mp == NULL\n \t\t   && fix->fix_size == 8\n \t\t   && mp->fix_size < 8)\n@@ -7147,7 +7224,7 @@ dump_minipool (rtx scan)\n   Mnode * nmp;\n   int align64 = 0;\n \n-  if (TARGET_REALLY_IWMMXT)\n+  if (ARM_DOUBLEWORD_ALIGN)\n     for (mp = minipool_vector_head; mp != NULL; mp = mp->next)\n       if (mp->refcount > 0 && mp->fix_size == 8)\n \t{\n@@ -7389,11 +7466,11 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n   if (fix->forwards == 0 && fix->backwards == 0)\n     abort ();\n \n-  /* With iWMMXt enabled, the pool is aligned to an 8-byte boundary.\n+  /* With AAPCS/iWMMXt enabled, the pool is aligned to an 8-byte boundary.\n      So there might be an empty word before the start of the pool.\n      Hence we reduce the forward range by 4 to allow for this\n      possibility.  */\n-  if (TARGET_REALLY_IWMMXT && fix->fix_size == 8)\n+  if (ARM_DOUBLEWORD_ALIGN && fix->fix_size == 8)\n     fix->forwards -= 4;\n \n   if (dump_file)\n@@ -8651,8 +8728,7 @@ output_ascii_pseudo_op (FILE *stream, const unsigned char *p, int len)\n }\n \f\n /* Compute the register sabe mask for registers 0 through 12\n-   inclusive.  This code is used by both arm_compute_save_reg_mask\n-   and arm_compute_initial_elimination_offset.  */\n+   inclusive.  This code is used by arm_compute_save_reg_mask.  */\n static unsigned long\n arm_compute_save_reg0_reg12_mask (void)\n {\n@@ -8798,6 +8874,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n   int reg;\n   unsigned long live_regs_mask;\n   unsigned long func_type;\n+  arm_stack_offsets *offsets;\n \n   func_type = arm_current_func_type ();\n \n@@ -8896,9 +8973,10 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t     points to the base of the saved core registers.  */\n \t  if (live_regs_mask & (1 << SP_REGNUM))\n \t    {\n-\t      unsigned HOST_WIDE_INT stack_adjust =\n-\t\tarm_get_frame_size () + current_function_outgoing_args_size;\n-\t      \n+\t      unsigned HOST_WIDE_INT stack_adjust;\n+\n+\t      offsets = arm_get_frame_offsets ();\n+\t      stack_adjust = offsets->outgoing_args - offsets->saved_regs;\n \t      if (stack_adjust != 0 && stack_adjust != 4)\n \t\tabort ();\n \n@@ -9128,12 +9206,12 @@ arm_output_epilogue (rtx sibling)\n      frame that is $fp + 4 for a non-variadic function.  */\n   int floats_offset = 0;\n   rtx operands[3];\n-  int frame_size = arm_get_frame_size ();\n   FILE * f = asm_out_file;\n   rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n   unsigned int lrm_count = 0;\n   int really_return = (sibling == NULL);\n   int start_reg;\n+  arm_stack_offsets *offsets;\n \n   /* If we have already generated the return instruction\n      then it is futile to generate anything else.  */\n@@ -9164,14 +9242,13 @@ arm_output_epilogue (rtx sibling)\n        be doing a return,  so we can't tail-call.  */\n     abort ();\n   \n+  offsets = arm_get_frame_offsets ();\n   saved_regs_mask = arm_compute_save_reg_mask ();\n \n   if (TARGET_IWMMXT)\n     lrm_count = bit_count (saved_regs_mask);\n \n-  /* XXX We should adjust floats_offset for any anonymous args, and then\n-     re-adjust vfp_offset below to compensate.  */\n-\n+  floats_offset = offsets->saved_args;\n   /* Compute how far away the floats will be.  */\n   for (reg = 0; reg <= LAST_ARM_REGNUM; reg++)\n     if (saved_regs_mask & (1 << reg))\n@@ -9180,7 +9257,7 @@ arm_output_epilogue (rtx sibling)\n   if (frame_pointer_needed)\n     {\n       /* This variable is for the Virtual Frame Pointer, not VFP regs.  */\n-      int vfp_offset = 4;\n+      int vfp_offset = offsets->frame;\n \n       if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n@@ -9332,8 +9409,7 @@ arm_output_epilogue (rtx sibling)\n          be reset correctly to the original value, should an interrupt\n          occur.  If the stack pointer already points at the right\n          place, then omit the subtraction.  */\n-      if (((frame_size + current_function_outgoing_args_size + floats_offset)\n-\t   != 4 * (1 + (int) bit_count (saved_regs_mask)))\n+      if (offsets->outgoing_args != (1 + (int) bit_count (saved_regs_mask))\n \t  || current_function_calls_alloca)\n \tasm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\", SP_REGNUM, FP_REGNUM,\n \t\t     4 * bit_count (saved_regs_mask));\n@@ -9347,11 +9423,10 @@ arm_output_epilogue (rtx sibling)\n   else\n     {\n       /* Restore stack pointer if necessary.  */\n-      if (frame_size + current_function_outgoing_args_size != 0)\n+      if (offsets->outgoing_args != offsets->saved_regs)\n \t{\n \t  operands[0] = operands[1] = stack_pointer_rtx;\n-\t  operands[2] = GEN_INT (frame_size\n-\t\t\t\t + current_function_outgoing_args_size);\n+\t  operands[2] = GEN_INT (offsets->outgoing_args - offsets->saved_regs);\n \t  output_add_immediate (operands);\n \t}\n \n@@ -9517,8 +9592,10 @@ arm_output_epilogue (rtx sibling)\n \n static void\n arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n-\t\t\t      HOST_WIDE_INT frame_size)\n+\t\t\t      HOST_WIDE_INT frame_size ATTRIBUTE_UNUSED)\n {\n+  arm_stack_offsets *offsets;\n+\n   if (TARGET_THUMB)\n     {\n       /* ??? Probably not safe to set this here, since it assumes that a\n@@ -9529,11 +9606,11 @@ arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n   else\n     {\n       /* We need to take into account any stack-frame rounding.  */\n-      frame_size = arm_get_frame_size ();\n+      offsets = arm_get_frame_offsets ();\n \n       if (use_return_insn (FALSE, NULL)\n \t  && return_used_this_function\n-\t  && (frame_size + current_function_outgoing_args_size) != 0\n+\t  && offsets->saved_regs != offsets->outgoing_args\n \t  && !frame_pointer_needed)\n \tabort ();\n \n@@ -9763,82 +9840,173 @@ emit_sfm (int base_reg, int count)\n \n   The sign of the number returned reflects the direction of stack\n   growth, so the values are positive for all eliminations except\n-  from the soft frame pointer to the hard frame pointer.  */\n-unsigned int\n-arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n+  from the soft frame pointer to the hard frame pointer.\n+\n+  SFP may point just inside the local variables block to ensure correct\n+  alignment.  */\n+\n+\n+/* Calculate stack offsets.  These are used to calculate register elimination\n+   offsets and in prologue/epilogue code.  */\n+\n+static arm_stack_offsets *\n+arm_get_frame_offsets (void)\n {\n-  unsigned int local_vars    = arm_get_frame_size ();\n-  unsigned int outgoing_args = current_function_outgoing_args_size;\n-  unsigned int stack_frame;\n-  unsigned int call_saved_registers;\n+  struct arm_stack_offsets *offsets;\n   unsigned long func_type;\n+  int leaf;\n+  bool new_block;\n+  int saved;\n+  HOST_WIDE_INT frame_size;\n+\n+  offsets = &cfun->machine->stack_offsets;\n   \n-  func_type = arm_current_func_type ();\n+  /* We need to know if we are a leaf function.  Unfortunately, it\n+     is possible to be called after start_sequence has been called,\n+     which causes get_insns to return the insns for the sequence,\n+     not the function, which will cause leaf_function_p to return\n+     the incorrect result.\n \n-  /* Volatile functions never return, so there is\n-     no need to save call saved registers.  */\n-  call_saved_registers = 0;\n-  if (! IS_VOLATILE (func_type))\n+     to know about leaf functions once reload has completed, and the\n+     frame size cannot be changed after that time, so we can safely\n+     use the cached value.  */\n+\n+  if (reload_completed)\n+    return offsets;\n+\n+  /* Initialy this is the size of the local variables.  It will translated\n+     into an offset once we have determined the size of preceeding data.  */\n+  frame_size = ROUND_UP_WORD (get_frame_size ());\n+\n+  leaf = leaf_function_p ();\n+\n+  /* Space for variadic functions.  */\n+  offsets->saved_args = current_function_pretend_args_size;\n+\n+  offsets->frame = offsets->saved_args + (frame_pointer_needed ? 4 : 0);\n+\n+  if (TARGET_ARM)\n     {\n-      unsigned int reg_mask;\n-      unsigned int reg;\n-      bool new_block;\n-\n-      /* Make sure that we compute which registers will be saved\n-\t on the stack using the same algorithm that is used by\n-\t the prologue creation code.  */\n-      reg_mask = arm_compute_save_reg_mask ();\n-\n-      /* Now count the number of bits set in save_reg_mask.\n-\t If we have already counted the registers in the stack\n-\t frame, do not count them again.  Non call-saved registers\n-\t might be saved in the call-save area of the stack, if\n-\t doing so will preserve the stack's alignment.  Hence we\n-\t must count them here.  For each set bit we need 4 bytes\n-\t of stack space.  */\n-      if (frame_pointer_needed)\n-\treg_mask &= 0x07ff;\n-      call_saved_registers += 4 * bit_count (reg_mask);\n+      unsigned int regno;\n \n-      /* If the hard floating point registers are going to be\n-\t used then they must be saved on the stack as well.\n-         Each register occupies 12 bytes of stack space.  */\n-      for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n-\tif (regs_ever_live[reg] && ! call_used_regs[reg])\n-\t  call_saved_registers += 12;\n+      saved = bit_count (arm_compute_save_reg_mask ()) * 4;\n \n-      /* Likewise VFP regs.  */\n-      if (TARGET_HARD_FLOAT && TARGET_VFP)\n+      /* We know that SP will be doubleword aligned on entry, and we must\n+\t preserve that condition at any subroutine call.  We also require the\n+\t soft frame pointer to be doubleword aligned.  */\n+\n+      if (TARGET_REALLY_IWMMXT)\n \t{\n-\t  new_block = TRUE;\n-\t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n+\t  /* Check for the call-saved iWMMXt registers.  */\n+\t  for (regno = FIRST_IWMMXT_REGNUM;\n+\t       regno <= LAST_IWMMXT_REGNUM;\n+\t       regno++)\n+\t    if (regs_ever_live [regno] && ! call_used_regs [regno])\n+\t      saved += 8;\n+\t}\n+\n+      func_type = arm_current_func_type ();\n+      if (! IS_VOLATILE (func_type))\n+\t{\n+\t  /* Space for saved FPA registers.  */\n+\t  for (regno = FIRST_FPA_REGNUM; regno <= LAST_FPA_REGNUM; regno++)\n+\t  if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\t    saved += 12;\n+\n+\t  /* Space for saved VFP registers.  */\n+\t  if (TARGET_HARD_FLOAT && TARGET_VFP)\n \t    {\n-\t      if ((regs_ever_live[reg] && !call_used_regs[reg])\n-\t\t  || (regs_ever_live[reg + 1] && !call_used_regs[reg + 1]))\n+\t      new_block = TRUE;\n+\t      for (regno = FIRST_VFP_REGNUM;\n+\t\t   regno < LAST_VFP_REGNUM;\n+\t\t   regno += 2)\n \t\t{\n-\t\t  if (new_block)\n+\t\t  if ((regs_ever_live[regno] && !call_used_regs[regno])\n+\t\t      || (regs_ever_live[regno + 1]\n+\t\t\t  && !call_used_regs[regno + 1]))\n \t\t    {\n-\t\t      call_saved_registers += 4;\n-\t\t      new_block = FALSE;\n+\t\t      if (new_block)\n+\t\t\t{\n+\t\t\t  saved += 4;\n+\t\t\t  new_block = FALSE;\n+\t\t\t}\n+\t\t      saved += 8;\n \t\t    }\n-\t\t  call_saved_registers += 8;\n+\t\t  else\n+\t\t    new_block = TRUE;\n \t\t}\n-\t      else\n-\t\tnew_block = TRUE;\n \t    }\n \t}\n+    }\n+  else /* TARGET_THUMB */\n+    {\n+      int reg;\n+      int count_regs;\n+\n+      saved = 0;\n+      count_regs = 0;\n+      for (reg = 8; reg < 13; reg ++)\n+\tif (THUMB_REG_PUSHED_P (reg))\n+\t  count_regs ++;\n+      if (count_regs)\n+\tsaved += 4 * count_regs;\n+      count_regs = 0;\n+      for (reg = 0; reg <= LAST_LO_REGNUM; reg ++)\n+\tif (THUMB_REG_PUSHED_P (reg))\n+\t  count_regs ++;\n+      if (count_regs || ! leaf_function_p ()\n+\t  || thumb_far_jump_used_p ())\n+\tsaved += 4 * (count_regs + 1);\n+      if (TARGET_BACKTRACE)\n+\t{\n+\t  if ((count_regs & 0xFF) == 0 && (regs_ever_live[3] != 0))\n+\t    saved += 20;\n+\t  else\n+\t    saved += 16;\n+\t}\n+    }\n \n-      if (TARGET_REALLY_IWMMXT)\n-\t/* Check for the call-saved iWMMXt registers.  */\n-\tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n-\t  if (regs_ever_live[reg] && ! call_used_regs [reg])\n-\t    call_saved_registers += 8;\n+  /* Saved registers include the stack frame.  */\n+  offsets->saved_regs = offsets->saved_args + saved;\n+  offsets->soft_frame = offsets->saved_regs;\n+  /* A leaf function does not need any stack alignment if it has nothing\n+     on the stack.  */\n+  if (leaf && frame_size == 0)\n+    {\n+      offsets->outgoing_args = offsets->soft_frame;\n+      return offsets;\n+    }\n+\n+  /* Ensure SFP has the correct alignment.  */\n+  if (ARM_DOUBLEWORD_ALIGN\n+      && (offsets->soft_frame & 7))\n+    offsets->soft_frame += 4;\n+\n+  offsets->outgoing_args = offsets->soft_frame + frame_size\n+\t\t\t   + current_function_outgoing_args_size;\n+\n+  if (ARM_DOUBLEWORD_ALIGN)\n+    {\n+      /* Ensure SP remains doubleword aligned.  */\n+      if (offsets->outgoing_args & 7)\n+\toffsets->outgoing_args += 4;\n+      if (offsets->outgoing_args & 7)\n+\tabort ();\n     }\n \n-  /* The stack frame contains 4 registers - the old frame pointer,\n-     the old stack pointer, the return address and PC of the start\n-     of the function.  */\n-  stack_frame = frame_pointer_needed ? 16 : 0;\n+  return offsets;\n+}\n+\n+\n+/* Calculate the realative offsets for the different stack pointers.  Positive\n+   offsets are in the direction of stack growth.  */\n+\n+unsigned int\n+arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n+{\n+  arm_stack_offsets *offsets;\n+\n+  offsets = arm_get_frame_offsets ();\n \n   /* OK, now we have enough information to compute the distances.\n      There must be an entry in these switch tables for each pair\n@@ -9855,24 +10023,22 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \tcase FRAME_POINTER_REGNUM:\n \t  /* This is the reverse of the soft frame pointer\n \t     to hard frame pointer elimination below.  */\n-\t  if (call_saved_registers == 0 && stack_frame == 0)\n-\t    return 0;\n-\t  return (call_saved_registers + stack_frame - 4);\n+\t  return offsets->soft_frame - offsets->saved_args;\n \n \tcase ARM_HARD_FRAME_POINTER_REGNUM:\n \t  /* If there is no stack frame then the hard\n \t     frame pointer and the arg pointer coincide.  */\n-\t  if (stack_frame == 0 && call_saved_registers != 0)\n+\t  if (offsets->frame == offsets->saved_regs)\n \t    return 0;\n-\t  /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */\n-\t  return (frame_pointer_needed\n-\t\t  && current_function_needs_context\n-\t\t  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;\n+          /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */\n+          return (frame_pointer_needed\n+                  && current_function_needs_context\n+                  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;\n \n \tcase STACK_POINTER_REGNUM:\n \t  /* If nothing has been pushed on the stack at all\n \t     then this will return -4.  This *is* correct!  */\n-\t  return call_saved_registers + stack_frame + local_vars + outgoing_args - 4;\n+\t  return offsets->outgoing_args - (offsets->saved_args + 4);\n \n \tdefault:\n \t  abort ();\n@@ -9890,12 +10056,11 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \t     stack frame.  The soft frame pointer to the bottom entry\n \t     in the stack frame.  If there is no stack frame at all,\n \t     then they are identical.  */\n-\t  if (call_saved_registers == 0 && stack_frame == 0)\n-\t    return 0;\n-\t  return - (call_saved_registers + stack_frame - 4);\n+\n+\t  return offsets->frame - offsets->soft_frame;\n \n \tcase STACK_POINTER_REGNUM:\n-\t  return local_vars + outgoing_args;\n+\t  return offsets->outgoing_args - offsets->soft_frame;\n \n \tdefault:\n \t  abort ();\n@@ -9912,107 +10077,6 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n     }\n }\n \n-/* Calculate the size of the stack frame, taking into account any\n-   padding that is required to ensure stack-alignment.  */\n-HOST_WIDE_INT\n-arm_get_frame_size (void)\n-{\n-  int regno;\n-\n-  int base_size = ROUND_UP_WORD (get_frame_size ());\n-  int entry_size = 0;\n-  unsigned long func_type = arm_current_func_type ();\n-  int leaf;\n-  bool new_block;\n-\n-  if (! TARGET_ARM)\n-    abort();\n-\n-  if (! TARGET_ATPCS)\n-    return base_size;\n-\n-  /* We need to know if we are a leaf function.  Unfortunately, it\n-     is possible to be called after start_sequence has been called,\n-     which causes get_insns to return the insns for the sequence,\n-     not the function, which will cause leaf_function_p to return\n-     the incorrect result.\n-\n-     To work around this, we cache the computed frame size.  This\n-     works because we will only be calling RTL expanders that need\n-     to know about leaf functions once reload has completed, and the\n-     frame size cannot be changed after that time, so we can safely\n-     use the cached value.  */\n-\n-  if (reload_completed)\n-    return cfun->machine->frame_size;\n-\n-  leaf = leaf_function_p ();\n-\n-  /* A leaf function does not need any stack alignment if it has nothing\n-     on the stack.  */\n-  if (leaf && base_size == 0)\n-    {\n-      cfun->machine->frame_size = 0;\n-      return 0;\n-    }\n-\n-  /* We know that SP will be word aligned on entry, and we must\n-     preserve that condition at any subroutine call.  But those are\n-     the only constraints.  */\n-\n-  /* Space for variadic functions.  */\n-  if (current_function_pretend_args_size)\n-    entry_size += current_function_pretend_args_size;\n-\n-  /* Space for saved registers.  */\n-  entry_size += bit_count (arm_compute_save_reg_mask ()) * 4;\n-\n-  if (! IS_VOLATILE (func_type))\n-    {\n-      /* Space for saved FPA registers.  */\n-      for (regno = FIRST_FPA_REGNUM; regno <= LAST_FPA_REGNUM; regno++)\n-      if (regs_ever_live[regno] && ! call_used_regs[regno])\n-\tentry_size += 12;\n-\n-      /* Space for saved VFP registers.  */\n-      if (TARGET_HARD_FLOAT && TARGET_VFP)\n-\t{\n-\t  new_block = TRUE;\n-\t  for (regno = FIRST_VFP_REGNUM; regno < LAST_VFP_REGNUM; regno += 2)\n-\t    {\n-\t      if ((regs_ever_live[regno] && !call_used_regs[regno])\n-\t\t  || (regs_ever_live[regno + 1] && !call_used_regs[regno + 1]))\n-\t\t{\n-\t\t  if (new_block)\n-\t\t    {\n-\t\t      entry_size += 4;\n-\t\t      new_block = FALSE;\n-\t\t    }\n-\t\t  entry_size += 8;\n-\t\t}\n-\t      else\n-\t\tnew_block = TRUE;\n-\t    }\n-\t}\n-    }\n-\n-  if (TARGET_REALLY_IWMMXT)\n-    {\n-      /* Check for the call-saved iWMMXt registers.  */\n-      for (regno = FIRST_IWMMXT_REGNUM; regno <= LAST_IWMMXT_REGNUM; regno++)\n-\tif (regs_ever_live [regno] && ! call_used_regs [regno])\n-\t  entry_size += 8;\n-    }\n-\n-  if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n-    base_size += 4;\n-  if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n-    abort ();\n-\n-  cfun->machine->frame_size = base_size;\n-\n-  return base_size;\n-}\n \n /* Generate the prologue instructions for entry into an ARM function.  */\n void\n@@ -10026,7 +10090,9 @@ arm_expand_prologue (void)\n   unsigned long func_type;\n   int fp_offset = 0;\n   int saved_pretend_args = 0;\n+  int saved_regs = 0;\n   unsigned int args_to_push;\n+  arm_stack_offsets *offsets;\n \n   func_type = arm_current_func_type ();\n \n@@ -10172,6 +10238,7 @@ arm_expand_prologue (void)\n   if (live_regs_mask)\n     {\n       insn = emit_multi_reg_push (live_regs_mask);\n+      saved_regs += bit_count (live_regs_mask) * 4;\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n@@ -10184,6 +10251,7 @@ arm_expand_prologue (void)\n \t  insn = emit_insn (gen_rtx_SET (VOIDmode, insn,\n \t\t\t\t\t gen_rtx_REG (V2SImode, reg)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  saved_regs += 8;\n \t}\n \n   if (! IS_VOLATILE (func_type))\n@@ -10202,6 +10270,7 @@ arm_expand_prologue (void)\n \t\tinsn = emit_insn (gen_rtx_SET (VOIDmode, insn,\n \t\t\t\t\t       gen_rtx_REG (XFmode, reg)));\n \t\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t\tsaved_regs += 12;\n \t      }\n \t}\n       else\n@@ -10225,6 +10294,7 @@ arm_expand_prologue (void)\n \t\t    {\n \t\t      insn = emit_sfm (reg + 1, start_reg - reg);\n \t\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t      saved_regs += (reg - start_reg) * 12;\n \t\t    }\n \t\t  start_reg = reg - 1;\n \t\t}\n@@ -10233,6 +10303,7 @@ arm_expand_prologue (void)\n \t  if (start_reg != reg)\n \t    {\n \t      insn = emit_sfm (reg + 1, start_reg - reg);\n+\t      saved_regs += (reg - start_reg) * 12;\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t}\n@@ -10250,6 +10321,7 @@ arm_expand_prologue (void)\n \t\t      insn = vfp_emit_fstmx (start_reg,\n \t\t\t\t\t    (reg - start_reg) / 2);\n \t\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t      saved_regs += (start_reg - reg) * 4 + 4;\n \t\t    }\n \t\t  start_reg = reg + 2;\n \t\t}\n@@ -10259,6 +10331,7 @@ arm_expand_prologue (void)\n \t      insn = vfp_emit_fstmx (start_reg,\n \t\t\t\t    (reg - start_reg) / 2);\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      saved_regs += (start_reg - reg) * 4 + 4;\n \t    }\n \t}\n     }\n@@ -10289,14 +10362,16 @@ arm_expand_prologue (void)\n \t}\n     }\n \n-  amount = GEN_INT (-(arm_get_frame_size ()\n-\t\t      + current_function_outgoing_args_size));\n-\n-  if (amount != const0_rtx)\n+  offsets = arm_get_frame_offsets ();\n+  if (offsets->outgoing_args != offsets->saved_args + saved_regs)\n     {\n       /* This add can produce multiple insns for a large constant, so we\n \t need to get tricky.  */\n       rtx last = get_last_insn ();\n+\n+      amount = GEN_INT (offsets->saved_args + saved_regs\n+\t\t\t- offsets->outgoing_args);\n+\n       insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t    amount));\n       do\n@@ -12618,8 +12693,8 @@ thumb_shiftable_const (unsigned HOST_WIDE_INT val)\n \n /* Returns nonzero if the current function contains,\n    or might contain a far jump.  */\n-int\n-thumb_far_jump_used_p (int in_prologue)\n+static int\n+thumb_far_jump_used_p (void)\n {\n   rtx insn;\n \n@@ -12637,7 +12712,7 @@ thumb_far_jump_used_p (int in_prologue)\n   /* If this function is not being called from the prologue/epilogue\n      generation code then it must be being called from the\n      INITIAL_ELIMINATION_OFFSET macro.  */\n-  if (!in_prologue)\n+  if (!(ARM_DOUBLEWORD_ALIGN || reload_completed))\n     {\n       /* In this case we know that we are being asked about the elimination\n \t of the arg pointer register.  If that register is not being used,\n@@ -12656,7 +12731,10 @@ thumb_far_jump_used_p (int in_prologue)\n \n \t A false negative will not result in bad code being generated, but it\n \t will result in a needless push and pop of the link register.  We\n-\t hope that this does not occur too often.  */\n+\t hope that this does not occur too often.\n+\n+\t If we need doubleword stack alignment this could affect the other\n+\t elimination offsets so we can't risk getting it wrong.  */\n       if (regs_ever_live [ARG_POINTER_REGNUM])\n \tcfun->machine->arg_pointer_live = 1;\n       else if (!cfun->machine->arg_pointer_live)\n@@ -12807,7 +12885,7 @@ thumb_unexpanded_epilogue (void)\n     }\n \n   had_to_push_lr = (live_regs_mask || !leaf_function\n-\t\t    || thumb_far_jump_used_p (1));\n+\t\t    || thumb_far_jump_used_p ());\n   \n   if (TARGET_BACKTRACE\n       && ((live_regs_mask & 0xFF) == 0)\n@@ -12913,100 +12991,66 @@ arm_init_expanders (void)\n   init_machine_status = arm_init_machine_status;\n }\n \n-HOST_WIDE_INT\n-thumb_get_frame_size (void)\n-{\n-  int regno;\n \n-  int base_size = ROUND_UP_WORD (get_frame_size ());\n-  int count_regs = 0;\n-  int entry_size = 0;\n-  int leaf;\n-\n-  if (! TARGET_THUMB)\n-    abort ();\n+/* Like arm_compute_initial_elimination offset.  Simpler because\n+   THUMB_HARD_FRAME_POINTER isn't actually the ABI specified frame pointer.  */\n \n-  if (! TARGET_ATPCS)\n-    return base_size;\n-\n-  /* We need to know if we are a leaf function.  Unfortunately, it\n-     is possible to be called after start_sequence has been called,\n-     which causes get_insns to return the insns for the sequence,\n-     not the function, which will cause leaf_function_p to return\n-     the incorrect result.\n-\n-     To work around this, we cache the computed frame size.  This\n-     works because we will only be calling RTL expanders that need\n-     to know about leaf functions once reload has completed, and the\n-     frame size cannot be changed after that time, so we can safely\n-     use the cached value.  */\n-\n-  if (reload_completed)\n-    return cfun->machine->frame_size;\n-\n-  leaf = leaf_function_p ();\n-\n-  /* A leaf function does not need any stack alignment if it has nothing\n-     on the stack.  */\n-  if (leaf && base_size == 0)\n-    {\n-      cfun->machine->frame_size = 0;\n-      return 0;\n-    }\n-\n-  /* We know that SP will be word aligned on entry, and we must\n-     preserve that condition at any subroutine call.  But those are\n-     the only constraints.  */\n-\n-  /* Space for variadic functions.  */\n-  if (current_function_pretend_args_size)\n-    entry_size += current_function_pretend_args_size;\n+HOST_WIDE_INT\n+thumb_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n+{\n+  arm_stack_offsets *offsets;\n \n-  /* Space for pushed lo registers.  */\n-  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n-    if (THUMB_REG_PUSHED_P (regno))\n-      count_regs++;\n+  offsets = arm_get_frame_offsets ();\n \n-  /* Space for backtrace structure.  */\n-  if (TARGET_BACKTRACE)\n+  switch (from)\n     {\n-      if (count_regs == 0 && regs_ever_live[LAST_ARG_REGNUM] != 0)\n-\tentry_size += 20;\n-      else\n-\tentry_size += 16;\n-    }\n+    case ARG_POINTER_REGNUM:\n+      switch (to)\n+\t{\n+\tcase STACK_POINTER_REGNUM:\n+\t  return offsets->outgoing_args - offsets->saved_args;\n \n-  if (count_regs || !leaf || thumb_far_jump_used_p (1))\n-    count_regs++;\t/* LR */\n+\tcase FRAME_POINTER_REGNUM:\n+\t  return offsets->soft_frame - offsets->saved_args;\n \n-  entry_size += count_regs * 4;\n-  count_regs = 0;\n+\tcase THUMB_HARD_FRAME_POINTER_REGNUM:\n+\tcase ARM_HARD_FRAME_POINTER_REGNUM:\n+\t  return offsets->saved_regs - offsets->saved_args;\n \n-  /* Space for pushed hi regs.  */\n-  for (regno = 8; regno < 13; regno++)\n-    if (THUMB_REG_PUSHED_P (regno))\n-      count_regs++;\n+\tdefault:\n+\t  abort();\n+\t}\n+      break;\n \n-  entry_size += count_regs * 4;\n+    case FRAME_POINTER_REGNUM:\n+      switch (to)\n+\t{\n+\tcase STACK_POINTER_REGNUM:\n+\t  return offsets->outgoing_args - offsets->soft_frame;\n \n-  if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n-    base_size += 4;\n-  if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n-    abort ();\n+\tcase THUMB_HARD_FRAME_POINTER_REGNUM:\n+\tcase ARM_HARD_FRAME_POINTER_REGNUM:\n+\t  return offsets->saved_regs - offsets->soft_frame;\n \n-  cfun->machine->frame_size = base_size;\n+\tdefault:\n+\t  abort();\n+\t}\n+      break;\n \n-  return base_size;\n+    default:\n+      abort ();\n+    }\n }\n \n+\n /* Generate the rest of a function's prologue.  */\n void\n thumb_expand_prologue (void)\n {\n   rtx insn, dwarf;\n \n-  HOST_WIDE_INT amount = (thumb_get_frame_size ()\n-\t\t\t  + current_function_outgoing_args_size);\n+  HOST_WIDE_INT amount;\n+  arm_stack_offsets *offsets;\n   unsigned long func_type;\n \n   func_type = arm_current_func_type ();\n@@ -13021,16 +13065,18 @@ thumb_expand_prologue (void)\n       return;\n     }\n \n+  offsets = arm_get_frame_offsets ();\n+\n   if (frame_pointer_needed)\n     {\n-      insn = emit_insn (gen_movsi (hard_frame_pointer_rtx, stack_pointer_rtx));\n+      insn = emit_insn (gen_movsi (hard_frame_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  amount = offsets->outgoing_args - offsets->saved_regs;\n   if (amount)\n     {\n-      amount = ROUND_UP_WORD (amount);\n-      \n       if (amount < 512)\n \t{\n \t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n@@ -13129,20 +13175,21 @@ thumb_expand_prologue (void)\n void\n thumb_expand_epilogue (void)\n {\n-  HOST_WIDE_INT amount = (thumb_get_frame_size ()\n-\t\t\t  + current_function_outgoing_args_size);\n+  HOST_WIDE_INT amount;\n+  arm_stack_offsets *offsets;\n   int regno;\n \n   /* Naked functions don't have prologues.  */\n   if (IS_NAKED (arm_current_func_type ()))\n     return;\n \n+  offsets = arm_get_frame_offsets ();\n+  amount = offsets->outgoing_args - offsets->saved_regs;\n+\n   if (frame_pointer_needed)\n     emit_insn (gen_movsi (stack_pointer_rtx, hard_frame_pointer_rtx));\n   else if (amount)\n     {\n-      amount = ROUND_UP_WORD (amount);\n-      \n       if (amount < 512)\n \temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t       GEN_INT (amount)));\n@@ -13257,7 +13304,7 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n     if (THUMB_REG_PUSHED_P (regno))\n       live_regs_mask |= 1 << regno;\n \n-  if (live_regs_mask || !leaf_function_p () || thumb_far_jump_used_p (1))\n+  if (live_regs_mask || !leaf_function_p () || thumb_far_jump_used_p ())\n     live_regs_mask |= 1 << LR_REGNUM;\n \n   if (TARGET_BACKTRACE)"}, {"sha": "fa8b8f9e0a45cf1fd92d34413676a7ccd95cd077", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 73, "deletions": 107, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=5848830fc3e626e6aa12c7f31620817b114b9b28", "patch": "@@ -140,6 +140,8 @@ extern const char *target_fpu_name;\n extern const char *target_fpe_name;\n /* Whether to use floating point hardware.  */\n extern const char *target_float_abi_name;\n+/* Which ABI to use.  */\n+extern const char *target_abi_name;\n /* Define the information needed to generate branch insns.  This is\n    stored from the compare operation.  */\n extern GTY(()) rtx arm_compare_op0;\n@@ -433,11 +435,8 @@ extern GTY(()) rtx aof_pic_label;\n    destination is non-Thumb aware.  */\n #define THUMB_FLAG_CALLER_SUPER_INTERWORKING\t(1 << 20)\n \n-/* Nonzero means to use ARM/Thumb Procedure Call Standard conventions.  */\n-#define ARM_FLAG_ATPCS\t\t(1 << 21)\n-\n /* Fix invalid Cirrus instruction combinations by inserting NOPs.  */\n-#define CIRRUS_FIX_INVALID_INSNS (1 << 22)\n+#define CIRRUS_FIX_INVALID_INSNS (1 << 21)\n \n #define TARGET_APCS_FRAME\t\t(target_flags & ARM_FLAG_APCS_FRAME)\n #define TARGET_POKE_FUNCTION_NAME\t(target_flags & ARM_FLAG_POKE)\n@@ -446,7 +445,6 @@ extern GTY(()) rtx aof_pic_label;\n #define TARGET_APCS_STACK\t\t(target_flags & ARM_FLAG_APCS_STACK)\n #define TARGET_APCS_FLOAT\t\t(target_flags & ARM_FLAG_APCS_FLOAT)\n #define TARGET_APCS_REENT\t\t(target_flags & ARM_FLAG_APCS_REENT)\n-#define TARGET_ATPCS\t\t\t(target_flags & ARM_FLAG_ATPCS)\n #define TARGET_MMU_TRAPS\t\t(target_flags & ARM_FLAG_MMU_TRAPS)\n #define TARGET_SOFT_FLOAT\t\t(arm_float_abi == ARM_FLOAT_ABI_SOFT)\n #define TARGET_SOFT_FLOAT_ABI\t\t(arm_float_abi != ARM_FLOAT_ABI_HARD)\n@@ -456,6 +454,7 @@ extern GTY(()) rtx aof_pic_label;\n #define TARGET_VFP\t\t\t(arm_fp_model == ARM_FP_MODEL_VFP)\n #define TARGET_IWMMXT\t\t\t(arm_arch_iwmmxt)\n #define TARGET_REALLY_IWMMXT\t\t(TARGET_IWMMXT && TARGET_ARM)\n+#define TARGET_IWMMXT_ABI (TARGET_ARM && arm_abi == ARM_ABI_IWMMXT)\n #define TARGET_BIG_END\t\t\t(target_flags & ARM_FLAG_BIG_END)\n #define TARGET_INTERWORK\t\t(target_flags & ARM_FLAG_INTERWORK)\n #define TARGET_LITTLE_WORDS\t\t(target_flags & ARM_FLAG_LITTLE_WORDS)\n@@ -574,7 +573,8 @@ extern GTY(()) rtx aof_pic_label;\n   {\"structure-size-boundary=\", & structure_size_string,\t\t\t\\\n    N_(\"Specify the minimum bit alignment of structures\"), 0},\t\t\\\n   {\"pic-register=\", & arm_pic_register_string,\t\t\t\t\\\n-   N_(\"Specify the register to be used for PIC addressing\"), 0}\t\t\\\n+   N_(\"Specify the register to be used for PIC addressing\"), 0},\t\\\n+  {\"abi=\", &target_abi_name, N_(\"Specify an ABI\"), 0}\t\t\t\\\n }\n \n /* Support for a compile-time default CPU, et cetera.  The rules are:\n@@ -585,14 +585,16 @@ extern GTY(()) rtx aof_pic_label;\n      by -march).\n    --with-float is ignored if -mhard-float, -msoft-float or -mfloat-abi are\n    specified.\n-   --with-fpu is ignored if -mfpu is specified.  */\n+   --with-fpu is ignored if -mfpu is specified.\n+   --with-abi is ignored is -mabi is specified.  */\n #define OPTION_DEFAULT_SPECS \\\n   {\"arch\", \"%{!march=*:%{!mcpu=*:-march=%(VALUE)}}\" }, \\\n   {\"cpu\", \"%{!march=*:%{!mcpu=*:-mcpu=%(VALUE)}}\" }, \\\n   {\"tune\", \"%{!mcpu=*:%{!mtune=*:-mtune=%(VALUE)}}\" }, \\\n   {\"float\", \\\n     \"%{!msoft-float:%{!mhard-float:%{!mfloat-abi=*:-mfloat-abi=%(VALUE)}}}\" }, \\\n-  {\"fpu\", \"%{!mfpu=*:-mfpu=%(VALUE)}\"},\n+  {\"fpu\", \"%{!mfpu=*:-mfpu=%(VALUE)}\"}, \\\n+  {\"abi\", \"%{!mabi=*:-mabi=%(VALUE)}\"},\n \n struct arm_cpu_select\n {\n@@ -682,6 +684,21 @@ extern enum float_abi_type arm_float_abi;\n #define FPUTYPE_DEFAULT FPUTYPE_MAVERICK\n #endif\n \n+/* Which ABI to use.  */\n+enum arm_abi_type\n+{\n+  ARM_ABI_APCS,\n+  ARM_ABI_ATPCS,\n+  ARM_ABI_AAPCS,\n+  ARM_ABI_IWMMXT\n+};\n+\n+extern enum arm_abi_type arm_abi;\n+\n+#ifndef ARM_DEFAULT_ABI\n+#define ARM_DEFAULT_ABI ARM_ABI_APCS\n+#endif\n+\n /* Nonzero if this chip supports the ARM Architecture 3M extensions.  */\n extern int arm_arch3m;\n \n@@ -811,13 +828,17 @@ extern int arm_is_6_or_7;\n \n #define UNITS_PER_WORD\t4\n \n-#define PARM_BOUNDARY  \t32\n+/* True if natural alignment is used for doubleword types.  */\n+#define ARM_DOUBLEWORD_ALIGN \\\n+    (arm_abi == ARM_ABI_AAPCS || arm_abi == ARM_ABI_IWMMXT)\n+#define DOUBLEWORD_ALIGNMENT 64\n \n-#define IWMMXT_ALIGNMENT   64\n+#define PARM_BOUNDARY  \t32\n \n-#define STACK_BOUNDARY  32\n+#define STACK_BOUNDARY  (ARM_DOUBLEWORD_ALIGN ? DOUBLEWORD_ALIGNMENT : 32)\n \n-#define PREFERRED_STACK_BOUNDARY (TARGET_ATPCS ? 64 : 32)\n+#define PREFERRED_STACK_BOUNDARY \\\n+    (arm_abi == ARM_ABI_ATPCS ? 64 : STACK_BOUNDARY)\n \n #define FUNCTION_BOUNDARY  32\n \n@@ -828,62 +849,30 @@ extern int arm_is_6_or_7;\n \n #define EMPTY_FIELD_BOUNDARY  32\n \n-#define BIGGEST_ALIGNMENT  (TARGET_REALLY_IWMMXT ? 64 : 32)\n-\n-#define TYPE_NEEDS_IWMMXT_ALIGNMENT(TYPE)\t\\\n- (TARGET_REALLY_IWMMXT\t\t\t\t\\\n-   && ((TREE_CODE (TYPE) == VECTOR_TYPE) || (TYPE_MODE (TYPE) == DImode) || (TYPE_MODE (TYPE) == DFmode)))\n+#define BIGGEST_ALIGNMENT (ARM_DOUBLEWORD_ALIGN ? DOUBLEWORD_ALIGNMENT : 32)\n \n /* XXX Blah -- this macro is used directly by libobjc.  Since it\n    supports no vector modes, cut out the complexity and fall back\n    on BIGGEST_FIELD_ALIGNMENT.  */\n #ifdef IN_TARGET_LIBS\n #define BIGGEST_FIELD_ALIGNMENT 64\n-#else\n-/* An expression for the alignment of a structure field FIELD if the\n-   alignment computed in the usual way is COMPUTED.  GCC uses this\n-   value instead of the value in `BIGGEST_ALIGNMENT' or\n-   `BIGGEST_FIELD_ALIGNMENT', if defined, for structure fields only.  */\n-#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED)\t\t\\\n-  (TYPE_NEEDS_IWMMXT_ALIGNMENT (TREE_TYPE (FIELD))\t\\\n-   ? IWMMXT_ALIGNMENT\t\t\t\t\t\\\n-   : (COMPUTED))\n #endif\n \n-/* If defined, a C expression to compute the alignment for a static variable.\n-   TYPE is the data type, and ALIGN is the alignment that the object\n-   would ordinarily have.  The value of this macro is used instead of that\n-   alignment to align the object.\n-\n-   If this macro is not defined, then ALIGN is used.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN) \\\n-  (TYPE_NEEDS_IWMMXT_ALIGNMENT (TYPE) ? IWMMXT_ALIGNMENT : ALIGN)\n-\n-/* If defined, a C expression to compute the alignment for a\n-   variables in the local store.  TYPE is the data type, and\n-   BASIC-ALIGN is the alignment that the object would ordinarily\n-   have.  The value of this macro is used instead of that alignment\n-   to align the object.\n-\n-   If this macro is not defined, then BASIC-ALIGN is used.  */\n-#define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n-  (TYPE_NEEDS_IWMMXT_ALIGNMENT (TYPE) ? IWMMXT_ALIGNMENT : ALIGN)\n-\n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT_FACTOR (TARGET_THUMB || ! arm_tune_xscale ? 1 : 2)\n     \n #define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\\\n-  ((TARGET_REALLY_IWMMXT && TREE_CODE (EXP) == VECTOR_TYPE) ? IWMMXT_ALIGNMENT : \\\n-   (TREE_CODE (EXP) == STRING_CST\t\t\t\t\\\n-    && (ALIGN) < BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR)\t\\\n-   ? BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR : (ALIGN))\n+   ((TREE_CODE (EXP) == STRING_CST\t\t\t\t\\\n+     && (ALIGN) < BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR)\t\\\n+    ? BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR : (ALIGN))\n \n /* Setting STRUCTURE_SIZE_BOUNDARY to 32 produces more efficient code, but the\n    value set in previous versions of this toolchain was 8, which produces more\n    compact structures.  The command line option -mstructure_size_boundary=<n>\n    can be used to change this value.  For compatibility with the ARM SDK\n    however the value should be left at 32.  ARM SDT Reference Manual (ARM DUI\n-   0020D) page 2-20 says \"Structures are aligned on word boundaries\".  */\n+   0020D) page 2-20 says \"Structures are aligned on word boundaries\".\n+   The AAPCS specifies a value of 8.  */\n #define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary\n extern int arm_structure_size_boundary;\n \n@@ -1728,7 +1717,7 @@ enum reg_class\n    : TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\t\t\t\\\n      && GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n    ? gen_rtx_REG (MODE, FIRST_CIRRUS_FP_REGNUM) \t\t\t\\\n-   : TARGET_REALLY_IWMMXT && VECTOR_MODE_SUPPORTED_P (MODE)\t\t\\\n+   : TARGET_IWMMXT_ABI && VECTOR_MODE_SUPPORTED_P (MODE)\t\\\n    ? gen_rtx_REG (MODE, FIRST_IWMMXT_REGNUM) \t\t\t\t\\\n    : gen_rtx_REG (MODE, ARG_REGISTER (1)))\n \n@@ -1746,7 +1735,7 @@ enum reg_class\n   ((REGNO) == ARG_REGISTER (1) \\\n    || (TARGET_ARM && ((REGNO) == FIRST_CIRRUS_FP_REGNUM)\t\t\\\n        && TARGET_HARD_FLOAT && TARGET_MAVERICK)\t\t\t\t\\\n-   || (TARGET_ARM && ((REGNO) == FIRST_IWMMXT_REGNUM) && TARGET_IWMMXT) \\\n+   || ((REGNO) == FIRST_IWMMXT_REGNUM && TARGET_IWMMXT_ABI) \\\n    || (TARGET_ARM && ((REGNO) == FIRST_FPA_REGNUM)\t\t\t\\\n        && TARGET_HARD_FLOAT && TARGET_FPA))\n \n@@ -1800,6 +1789,22 @@ enum reg_class\n #define IS_NAKED(t)        \t(t & ARM_FT_NAKED)\n #define IS_NESTED(t)       \t(t & ARM_FT_NESTED)\n \n+\n+/* Structure used to hold the function stack frame layout.  Offsets are\n+   relative to the stack pointer on function entry.  Positive offsets are\n+   in the direction of stack growth.\n+   Only soft_frame is used in thumb mode.  */\n+\n+typedef struct arm_stack_offsets GTY(())\n+{\n+  int saved_args;\t/* ARG_POINTER_REGNUM.  */\n+  int frame;\t\t/* ARM_HARD_FRAME_POINTER_REGNUM.  */\n+  int saved_regs;\n+  int soft_frame;\t/* FRAME_POINTER_REGNUM.  */\n+  int outgoing_args;\t/* STACK_POINTER_REGNUM.  */\n+}\n+arm_stack_offsets;\n+\n /* A C structure for machine-specific, per-function data.\n    This is added to the cfun structure.  */\n typedef struct machine_function GTY(())\n@@ -1813,7 +1818,7 @@ typedef struct machine_function GTY(())\n   /* Records if the save of LR has been eliminated.  */\n   int lr_save_eliminated;\n   /* The size of the stack frame.  Only valid after reload.  */\n-  int frame_size;\n+  arm_stack_offsets stack_offsets;\n   /* Records the type of the current function.  */\n   unsigned long func_type;\n   /* Record if the function has a variable argument list.  */\n@@ -1837,6 +1842,7 @@ typedef struct\n   int nargs;\n   /* One of CALL_NORMAL, CALL_LONG or CALL_SHORT.  */\n   int call_cookie;\n+  int can_split;\n } CUMULATIVE_ARGS;\n \n /* Define where to put the arguments to a function.\n@@ -1866,7 +1872,8 @@ typedef struct\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n   (VECTOR_MODE_SUPPORTED_P (MODE) ? 0 :\t\t\t\t\\\n        NUM_ARG_REGS > (CUM).nregs\t\t\t\t\\\n-   && (NUM_ARG_REGS < ((CUM).nregs + ARM_NUM_REGS2 (MODE, TYPE)))\t\\\n+   && (NUM_ARG_REGS < ((CUM).nregs + ARM_NUM_REGS2 (MODE, TYPE))\t\\\n+   && (CUM).can_split)\t\t\t\t\t\t\\\n    ?   NUM_ARG_REGS - (CUM).nregs : 0)\n \n /* A C expression that indicates when an argument must be passed by\n@@ -1889,26 +1896,26 @@ typedef struct\n    (TYPE is null for libcalls where that information may not be available.)  */\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n   (CUM).nargs += 1;\t\t\t\t\t\\\n-  if (VECTOR_MODE_SUPPORTED_P (MODE))\t\t\t\\\n-     if ((CUM).named_count <= (CUM).nargs)\t\t\\\n-        (CUM).nregs += 2;\t\t\t\t\\\n-     else\t\t\t\t\t\t\\\n-        (CUM).iwmmxt_nregs += 1;\t\t\t\\\n+  if (VECTOR_MODE_SUPPORTED_P (MODE)\t\t\t\\\n+      && (CUM).named_count > (CUM).nargs)\t\t\\\n+    (CUM).iwmmxt_nregs += 1;\t\t\t\t\\\n   else\t\t\t\t\t\t\t\\\n-  (CUM).nregs += ARM_NUM_REGS2 (MODE, TYPE)\n+    (CUM).nregs += ARM_NUM_REGS2 (MODE, TYPE)\n \n /* If defined, a C expression that gives the alignment boundary, in bits, of an\n    argument with the specified mode and type.  If it is not defined,\n    `PARM_BOUNDARY' is used for all arguments.  */\n #define FUNCTION_ARG_BOUNDARY(MODE,TYPE) \\\n-  (TARGET_REALLY_IWMMXT && (VALID_IWMMXT_REG_MODE (MODE) || ((MODE) == DFmode)) \\\n-   ? IWMMXT_ALIGNMENT : PARM_BOUNDARY)\n+   ((ARM_DOUBLEWORD_ALIGN && arm_needs_doubleword_align (MODE, TYPE)) \\\n+   ? DOUBLEWORD_ALIGNMENT \\\n+   : PARM_BOUNDARY )\n \n /* 1 if N is a possible register number for function argument passing.\n    On the ARM, r0-r3 are used to pass args.  */\n #define FUNCTION_ARG_REGNO_P(REGNO)\t\\\n    (IN_RANGE ((REGNO), 0, 3)\t\t\\\n-    || (TARGET_REALLY_IWMMXT && IN_RANGE ((REGNO), FIRST_IWMMXT_REGNUM, FIRST_IWMMXT_REGNUM + 9)))\n+    || (TARGET_IWMMXT_ABI\t\t\\\n+\t&& IN_RANGE ((REGNO), FIRST_IWMMXT_REGNUM, FIRST_IWMMXT_REGNUM + 9)))\n \n /* Implement `va_arg'.  */\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n@@ -2030,53 +2037,12 @@ typedef struct\n      \n /* Define the offset between two registers, one to be eliminated, and the\n    other its replacement, at the start of a routine.  */\n-#define ARM_INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (OFFSET) = arm_compute_initial_elimination_offset (FROM, TO);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Note:  This macro must match the code in thumb_function_prologue().  */\n-#define THUMB_INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  (OFFSET) = 0;\t\t\t\t\t\t\t\t\\\n-  if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int count_regs = 0;\t\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\t\t\\\n-      for (regno = 8; regno < 13; regno ++)\t\t\t\t\\\n-        if (THUMB_REG_PUSHED_P (regno))\t\t\t\t\t\\\n-          count_regs ++;\t\t\t\t\t\t\\\n-      if (count_regs)\t\t\t\t\t\t\t\\\n-\t(OFFSET) += 4 * count_regs;\t\t\t\t\t\\\n-      count_regs = 0;\t\t\t\t\t\t\t\\\n-      for (regno = 0; regno <= LAST_LO_REGNUM; regno ++)\t\t\\\n-        if (THUMB_REG_PUSHED_P (regno))\t\t\t\t\t\\\n-\t  count_regs ++;\t\t\t\t\t\t\\\n-      if (count_regs || ! leaf_function_p () || thumb_far_jump_used_p (0))\\\n-\t(OFFSET) += 4 * (count_regs + 1);\t\t\t\t\\\n-      if (TARGET_BACKTRACE)\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-\t  if ((count_regs & 0xFF) == 0 && (regs_ever_live[3] != 0))\t\\\n-\t    (OFFSET) += 20;\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    (OFFSET) += 16;\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (OFFSET) += current_function_outgoing_args_size;\t\t\t\\\n-      (OFFSET) += thumb_get_frame_size ();\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n   if (TARGET_ARM)\t\t\t\t\t\t\t\\\n-    ARM_INITIAL_ELIMINATION_OFFSET (FROM, TO, OFFSET);\t\t\t\\\n+    (OFFSET) = arm_compute_initial_elimination_offset (FROM, TO);\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n-    THUMB_INITIAL_ELIMINATION_OFFSET (FROM, TO, OFFSET)\n-     \n+    (OFFSET) = thumb_compute_initial_elimination_offset (FROM, TO)\n+\n /* Special case handling of the location of arguments passed on the stack.  */\n #define DEBUGGER_ARG_OFFSET(value, addr) value ? value : arm_debugger_arg_offset (value, addr)\n      "}, {"sha": "0a5fbd2994783d6bfeab9a9a283dee932547784c", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5848830fc3e626e6aa12c7f31620817b114b9b28", "patch": "@@ -10102,7 +10102,7 @@\n \n (define_insn \"align_8\"\n   [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN8)]\n-  \"TARGET_REALLY_IWMMXT\"\n+  \"TARGET_EITHER\"\n   \"*\n   assemble_align (64);\n   return \\\"\\\";"}, {"sha": "76bda04f24d67a8f67820597a6abcc96c41f925d", "filename": "gcc/config/arm/netbsd-elf.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h?ref=5848830fc3e626e6aa12c7f31620817b114b9b28", "patch": "@@ -38,10 +38,12 @@\n   (ARM_FLAG_APCS_32\t\t\t\\\n    | ARM_FLAG_SOFT_FLOAT\t\t\\\n    | ARM_FLAG_APCS_FRAME\t\t\\\n-   | ARM_FLAG_ATPCS\t\t\t\\\n    | ARM_FLAG_MMU_TRAPS\t\t\t\\\n    | TARGET_ENDIAN_DEFAULT)\n \n+#undef ARM_DEFAULT_ABI\n+#define ARM_DEFAULT_ABI ARM_ABI_ATPCS\n+\n #define TARGET_OS_CPP_BUILTINS()\t\\\n   do\t\t\t\t\t\\\n     {\t\t\t\t\t\\"}, {"sha": "1e6b36bdb406d5b206dc4546a7920cb79ba0a966", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5848830fc3e626e6aa12c7f31620817b114b9b28/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5848830fc3e626e6aa12c7f31620817b114b9b28", "patch": "@@ -368,6 +368,7 @@ in the following sections.\n \n @emph{ARM Options}\n @gccoptlist{-mapcs-frame  -mno-apcs-frame @gol\n+-mabi=@var{name} @gol\n -mapcs-26  -mapcs-32 @gol\n -mapcs-stack-check  -mno-apcs-stack-check @gol\n -mapcs-float  -mno-apcs-float @gol\n@@ -6413,6 +6414,11 @@ These @samp{-m} options are defined for Advanced RISC Machines (ARM)\n architectures:\n \n @table @gcctabopt\n+@item -mabi=@var{name}\n+@opindex mabi\n+Generate code for the specified ABI.  Permissible values are: @samp{apcs-gnu},\n+@samp{atpcs}, @samp{aapcs} and @samp{iwmmxt}.\n+\n @item -mapcs-frame\n @opindex mapcs-frame\n Generate a stack frame that is compliant with the ARM Procedure Call\n@@ -6635,14 +6641,16 @@ floating point values.\n @item -mstructure-size-boundary=@var{n}\n @opindex mstructure-size-boundary\n The size of all structures and unions will be rounded up to a multiple\n-of the number of bits set by this option.  Permissible values are 8 and\n-32.  The default value varies for different toolchains.  For the COFF\n-targeted toolchain the default value is 8.  Specifying the larger number\n-can produce faster, more efficient code, but can also increase the size\n-of the program.  The two values are potentially incompatible.  Code\n-compiled with one value cannot necessarily expect to work with code or\n-libraries compiled with the other value, if they exchange information\n-using structures or unions.\n+of the number of bits set by this option.  Permissible values are 8, 32\n+and 64.  The default value varies for different toolchains.  For the COFF\n+targeted toolchain the default value is 8.  A value of 64 is only allowed\n+if the underlying ABI supports it.\n+\n+Specifying the larger number can produce faster, more efficient code, but\n+can also increase the size of the program.  Different values are potentially\n+incompatible.  Code compiled with one value cannot necessarily expect to\n+work with code or libraries compiled with annother value, if they exchange\n+information using structures or unions.\n \n @item -mabort-on-noreturn\n @opindex mabort-on-noreturn"}]}