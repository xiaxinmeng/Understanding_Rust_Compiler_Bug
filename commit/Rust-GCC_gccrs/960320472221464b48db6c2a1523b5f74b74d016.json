{"sha": "960320472221464b48db6c2a1523b5f74b74d016", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYwMzIwNDcyMjIxNDY0YjQ4ZGI2YzJhMTUyM2I1Zjc0Yjc0ZDAxNg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-10-13T22:26:36Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-10-13T22:26:36Z"}, "message": "PR c++/71912 - [6/7 regression] flexible array in struct in union rejected\n\ngcc/cp/ChangeLog:\n\n\tPR c++/71912\n\t* class.c (struct flexmems_t):  Add members.\n\t(find_flexarrays): Add arguments.  Correct handling of anonymous\n\tstructs.\n\t(diagnose_flexarrays): Adjust to issue warnings in addition to errors.\n\t(check_flexarrays): Add argument.\n\t(diagnose_invalid_flexarray): New functions.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/71912\n\t* g++.dg/ext/flexary4.C: Adjust.\n\t* g++.dg/ext/flexary5.C: Same.\n\t* g++.dg/ext/flexary9.C: Same.\n\t* g++.dg/ext/flexary19.C: New test.\n\t* g++.dg/ext/flexary18.C: New test.\n\t* g++.dg/torture/pr64312.C: Add a dg-error directive to an ill-formed\n\tregression test.\n        * g++.dg/compat/struct-layout-1_generate.c (subfield): Add argument.\n        Avoid generating a flexible array member in an array.\n\nFrom-SVN: r241143", "tree": {"sha": "3a71752f8a6dd2bdac0321e7226ba6861d5ea8cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a71752f8a6dd2bdac0321e7226ba6861d5ea8cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/960320472221464b48db6c2a1523b5f74b74d016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/960320472221464b48db6c2a1523b5f74b74d016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/960320472221464b48db6c2a1523b5f74b74d016", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/960320472221464b48db6c2a1523b5f74b74d016/comments", "author": null, "committer": null, "parents": [{"sha": "253abb2a156c6ea7d1631bbe9da32070fdfe901b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/253abb2a156c6ea7d1631bbe9da32070fdfe901b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/253abb2a156c6ea7d1631bbe9da32070fdfe901b"}], "stats": {"total": 1000, "additions": 895, "deletions": 105}, "files": [{"sha": "cc161761396e6b7d7a3a54aa9feac77289ab3c61", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -1,3 +1,13 @@\n+2016-10-13  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/71912\n+\t* class.c (struct flexmems_t):  Add members.\n+\t(find_flexarrays): Add arguments.  Correct handling of anonymous\n+\tstructs.\n+\t(diagnose_flexarrays): Adjust to issue warnings in addition to errors.\n+\t(check_flexarrays): Add argument.\n+\t(diagnose_invalid_flexarray): New functions.\n+\n 2016-10-13  Jakub Jelinek  <jakub@redhat.com>\n \t    Jason Merrill  <jason@redhat.com>\n \n@@ -39,6 +49,7 @@\n \n \t* decl.c (mark_inline_variable): New.\n \n+>>>>>>> .r241142\n 2016-10-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* decl2.c: Include memmodel.h."}, {"sha": "46f1bac347c2d766862d8ad4ce9b71a42a82ab4c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 224, "deletions": 69, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -147,11 +147,12 @@ static void check_methods (tree);\n static void remove_zero_width_bit_fields (tree);\n static bool accessible_nvdtor_p (tree);\n \n-/* Used by find_flexarrays and related.  */\n+/* Used by find_flexarrays and related functions.  */\n struct flexmems_t;\n-static void find_flexarrays (tree, flexmems_t *);\n static void diagnose_flexarrays (tree, const flexmems_t *);\n-static void check_flexarrays (tree, flexmems_t * = NULL);\n+static void find_flexarrays (tree, flexmems_t *, bool = false,\n+\t\t\t     tree = NULL_TREE, tree = NULL_TREE);\n+static void check_flexarrays (tree, flexmems_t * = NULL, bool = false);\n static void check_bases (tree, int *, int *);\n static void check_bases_and_members (tree);\n static tree create_vtable_ptr (tree, tree *);\n@@ -6692,52 +6693,147 @@ field_nonempty_p (const_tree fld)\n   return false;\n }\n \n-/* Used by find_flexarrays and related.  */\n-struct flexmems_t {\n+/* Used by find_flexarrays and related functions.  */\n+\n+struct flexmems_t\n+{\n   /* The first flexible array member or non-zero array member found\n-     in order of layout.  */\n+     in the order of layout.  */\n   tree array;\n   /* First non-static non-empty data member in the class or its bases.  */\n   tree first;\n-  /* First non-static non-empty data member following either the flexible\n-     array member, if found, or the zero-length array member.  */\n-  tree after;\n+  /* The first non-static non-empty data member following either\n+     the flexible array member, if found, or the zero-length array member\n+     otherwise.  AFTER[1] refers to the first such data member of a union\n+     of which the struct containing the flexible array member or zero-length\n+     array is a member, or NULL when no such union exists.  This element is\n+     only used during searching, not for diagnosing problems.  AFTER[0]\n+     refers to the first such data member that is not a member of such\n+     a union.  */\n+  tree after[2];\n+\n+  /* Refers to a struct (not union) in which the struct of which the flexible\n+     array is member is defined.  Used to diagnose strictly (according to C)\n+     invalid uses of the latter structs.  */\n+  tree enclosing;\n };\n \n /* Find either the first flexible array member or the first zero-length\n-   array, in that order or preference, among members of class T (but not\n-   its base classes), and set members of FMEM accordingly.  */\n+   array, in that order of preference, among members of class T (but not\n+   its base classes), and set members of FMEM accordingly.\n+   BASE_P is true if T is a base class of another class.\n+   PUN is set to the outermost union in which the flexible array member\n+   (or zero-length array) is defined if one such union exists, otherwise\n+   to NULL.\n+   Similarly, PSTR is set to a data member of the outermost struct of\n+   which the flexible array is a member if one such struct exists,\n+   otherwise to NULL.  */\n \n static void\n-find_flexarrays (tree t, flexmems_t *fmem)\n+find_flexarrays (tree t, flexmems_t *fmem, bool base_p,\n+\t\t tree pun /* = NULL_TREE */,\n+\t\t tree pstr /* = NULL_TREE */)\n {\n-  for (tree fld = TYPE_FIELDS (t), next; fld; fld = next)\n+  /* Set the \"pointer\" to the outermost enclosing union if not set\n+     yet and maintain it for the remainder of the recursion.   */\n+  if (!pun && TREE_CODE (t) == UNION_TYPE)\n+    pun = t;\n+\n+  for (tree fld = TYPE_FIELDS (t); fld; fld = DECL_CHAIN (fld))\n     {\n-      /* Find the next non-static data member if it exists.  */\n-      for (next = fld;\n-\t   (next = DECL_CHAIN (next))\n-\t     && TREE_CODE (next) != FIELD_DECL; );\n+      if (fld == error_mark_node)\n+\treturn;\n \n-      tree fldtype = TREE_TYPE (fld);\n-      if (TREE_CODE (fld) != TYPE_DECL\n-\t  && RECORD_OR_UNION_TYPE_P (fldtype)\n-\t  && TYPE_UNNAMED_P (fldtype))\n-\t{\n-\t  /* Members of anonymous structs and unions are treated as if\n-\t     they were members of the containing class.  Descend into\n-\t     the anonymous struct or union and find a flexible array\n-\t     member or zero-length array among its fields.  */\n-\t  find_flexarrays (fldtype, fmem);\n+      /* Is FLD a typedef for an anonymous struct?  */\n+\n+      /* FIXME: Note that typedefs (as well as arrays) need to be fully\n+\t handled elsewhere so that errors like the following are detected\n+\t as well:\n+\t   typedef struct { int i, a[], j; } S;   // bug c++/72753\n+\t   S s [2];                               // bug c++/68489\n+      */\n+      if (TREE_CODE (fld) == TYPE_DECL\n+\t  && DECL_IMPLICIT_TYPEDEF_P (fld)\n+\t  && CLASS_TYPE_P (TREE_TYPE (fld))\n+\t  && anon_aggrname_p (DECL_NAME (fld)))\n+\t{\n+\t  /* Check the nested unnamed type referenced via a typedef\n+\t     independently of FMEM (since it's not a data member of\n+\t     the enclosing class).  */\n+\t  check_flexarrays (TREE_TYPE (fld));\n \t  continue;\n \t}\n \n-      /* Skip anything that's not a (non-static) data member.  */\n-      if (TREE_CODE (fld) != FIELD_DECL)\n+      /* Skip anything that's GCC-generated or not a (non-static) data\n+\t member.  */\n+      if (DECL_ARTIFICIAL (fld) || TREE_CODE (fld) != FIELD_DECL)\n \tcontinue;\n \n-      /* Skip virtual table pointers.  */\n-      if (DECL_ARTIFICIAL (fld))\n-\tcontinue;\n+      /* Type of the member.  */\n+      tree fldtype = TREE_TYPE (fld);\n+      if (fldtype == error_mark_node)\n+\treturn;\n+\n+      /* Determine the type of the array element or object referenced\n+\t by the member so that it can be checked for flexible array\n+\t members if it hasn't been yet.  */\n+      tree eltype = fldtype;\n+      while (TREE_CODE (eltype) == ARRAY_TYPE\n+\t     || TREE_CODE (eltype) == POINTER_TYPE\n+\t     || TREE_CODE (eltype) == REFERENCE_TYPE)\n+\teltype = TREE_TYPE (eltype);\n+\n+      if (RECORD_OR_UNION_TYPE_P (eltype))\n+\t{\n+\t  if (fmem->array && !fmem->after[bool (pun)])\n+\t    {\n+\t      /* Once the member after the flexible array has been found\n+\t\t we're done.  */\n+\t      fmem->after[bool (pun)] = fld;\n+\t      break;\n+\t    }\n+\n+\t  if (eltype == fldtype || TYPE_UNNAMED_P (eltype))\n+\t    {\n+\t      /* Descend into the non-static member struct or union and try\n+\t\t to find a flexible array member or zero-length array among\n+\t\t its members.  This is only necessary for anonymous types\n+\t\t and types in whose context the current type T has not been\n+\t\t defined (the latter must not be checked again because they\n+\t\t are already in the process of being checked by one of the\n+\t\t recursive calls).  */\n+\n+\t      tree first = fmem->first;\n+\t      tree array = fmem->array;\n+\n+\t      /* If this member isn't anonymous and a prior non-flexible array\n+\t\t member has been seen in one of the enclosing structs, clear\n+\t\t the FIRST member since it doesn't contribute to the flexible\n+\t\t array struct's members.  */\n+\t      if (first && !array && !ANON_AGGR_TYPE_P (eltype))\n+\t\tfmem->first = NULL_TREE;\n+\n+\t      find_flexarrays (eltype, fmem, false, pun,\n+\t\t\t       !pstr && TREE_CODE (t) == RECORD_TYPE ? fld : pstr);\n+\n+\t      if (fmem->array != array)\n+\t\tcontinue;\n+\n+\t      if (first && !array && !ANON_AGGR_TYPE_P (eltype))\n+\t\t{\n+\t\t  /* Restore the FIRST member reset above if no flexible\n+\t\t     array member has been found in this member's struct.  */\n+\t\t  fmem->first = first;\n+\t\t}\n+\n+\t      /* If the member struct contains the first flexible array\n+\t\t member, or if this member is a base class, continue to\n+\t\t the next member and avoid setting the FMEM->NEXT pointer\n+\t\t to point to it.  */\n+\t      if (base_p)\n+\t\tcontinue;\n+\t    }\n+\t}\n \n       if (field_nonempty_p (fld))\n \t{\n@@ -6748,8 +6844,8 @@ find_flexarrays (tree t, flexmems_t *fmem)\n \t  /* Remember the first non-static data member after the flexible\n \t     array member, if one has been found, or the zero-length array\n \t     if it has been found.  */\n-\t  if (!fmem->after && fmem->array)\n-\t    fmem->after = fld;\n+\t  if (fmem->array && !fmem->after[bool (pun)])\n+\t    fmem->after[bool (pun)] = fld;\n \t}\n \n       /* Skip non-arrays.  */\n@@ -6765,13 +6861,16 @@ find_flexarrays (tree t, flexmems_t *fmem)\n \t\t such field or a flexible array member has been seen to\n \t\t handle the pathological and unlikely case of multiple\n \t\t such members.  */\n-\t      if (!fmem->after)\n-\t\tfmem->after = fld;\n+\t      if (!fmem->after[bool (pun)])\n+\t\tfmem->after[bool (pun)] = fld;\n \t    }\n \t  else if (integer_all_onesp (TYPE_MAX_VALUE (TYPE_DOMAIN (fldtype))))\n-\t    /* Remember the first zero-length array unless a flexible array\n-\t       member has already been seen.  */\n-\t    fmem->array = fld;\n+\t    {\n+\t      /* Remember the first zero-length array unless a flexible array\n+\t\t member has already been seen.  */\n+\t      fmem->array = fld;\n+\t      fmem->enclosing = pstr;\n+\t    }\n \t}\n       else\n \t{\n@@ -6782,66 +6881,110 @@ find_flexarrays (tree t, flexmems_t *fmem)\n \t\t reset the after pointer.  */\n \t      if (TYPE_DOMAIN (TREE_TYPE (fmem->array)))\n \t\t{\n+\t\t  fmem->after[bool (pun)] = NULL_TREE;\n \t\t  fmem->array = fld;\n-\t\t  fmem->after = NULL_TREE;\n+\t\t  fmem->enclosing = pstr;\n \t\t}\n \t    }\n \t  else\n-\t    fmem->array = fld;\n+\t    {\n+\t      fmem->array = fld;\n+\t      fmem->enclosing = pstr;\n+\t    }\n \t}\n     }\n }\n \n+/* Diagnose a strictly (by the C standard) invalid use of a struct with\n+   a flexible array member (or the zero-length array extension).  */\n+\n+static void\n+diagnose_invalid_flexarray (const flexmems_t *fmem)\n+{\n+  if (fmem->array && fmem->enclosing\n+      && pedwarn (location_of (fmem->enclosing), OPT_Wpedantic,\n+\t\t  TYPE_DOMAIN (TREE_TYPE (fmem->array))\n+\t\t  ? G_(\"invalid use of %q#T with a zero-size array \"\n+\t\t       \"in %q#D\")\n+\t\t  : G_(\"invalid use of %q#T with a flexible array member \"\n+\t\t       \"in %q#T\"),\n+\t\t  DECL_CONTEXT (fmem->array),\n+\t\t  DECL_CONTEXT (fmem->enclosing)))\n+    inform (DECL_SOURCE_LOCATION (fmem->array),\n+\t    \"array member %q#D declared here\", fmem->array);\n+}\n+\n /* Issue diagnostics for invalid flexible array members or zero-length\n    arrays that are not the last elements of the containing class or its\n    base classes or that are its sole members.  */\n \n static void\n diagnose_flexarrays (tree t, const flexmems_t *fmem)\n {\n-  /* Members of anonymous structs and unions are considered to be members\n-     of the containing struct or union.  */\n-  if (TYPE_UNNAMED_P (t) || !fmem->array)\n+  if (!fmem->array)\n     return;\n \n+  if (fmem->first && !fmem->after[0])\n+    {\n+      diagnose_invalid_flexarray (fmem);\n+      return;\n+    }\n+\n+  /* Has a diagnostic been issued?  */\n+  bool diagd = false;\n+\n   const char *msg = 0;\n \n   if (TYPE_DOMAIN (TREE_TYPE (fmem->array)))\n     {\n-      if (fmem->after)\n+      if (fmem->after[0])\n \tmsg = G_(\"zero-size array member %qD not at end of %q#T\");\n       else if (!fmem->first)\n \tmsg = G_(\"zero-size array member %qD in an otherwise empty %q#T\");\n \n-      if (msg && pedwarn (DECL_SOURCE_LOCATION (fmem->array),\n-\t\t\t  OPT_Wpedantic, msg, fmem->array, t))\n+      if (msg)\n+\t{\n+\t  location_t loc = DECL_SOURCE_LOCATION (fmem->array);\n \n-\tinform (location_of (t), \"in the definition of %q#T\", t);\n+\t  if (pedwarn (loc, OPT_Wpedantic, msg, fmem->array, t))\n+\t    {\n+\t      inform (location_of (t), \"in the definition of %q#T\", t);\n+\t      diagd = true;\n+\t    }\n+\t}\n     }\n   else\n     {\n-      if (fmem->after)\n+      if (fmem->after[0])\n \tmsg = G_(\"flexible array member %qD not at end of %q#T\");\n       else if (!fmem->first)\n \tmsg = G_(\"flexible array member %qD in an otherwise empty %q#T\");\n \n       if (msg)\n \t{\n-\t  error_at (DECL_SOURCE_LOCATION (fmem->array), msg,\n-\t\t    fmem->array, t);\n+\t  location_t loc = DECL_SOURCE_LOCATION (fmem->array);\n+\t  diagd = true;\n+\n+\t  error_at (loc, msg, fmem->array, t);\n \n \t  /* In the unlikely event that the member following the flexible\n-\t     array member is declared in a different class, point to it.\n+\t     array member is declared in a different class, or the member\n+\t     overlaps another member of a common union, point to it.\n \t     Otherwise it should be obvious.  */\n-\t  if (fmem->after\n-\t      && (DECL_CONTEXT (fmem->after) != DECL_CONTEXT (fmem->array)))\n-\t      inform (DECL_SOURCE_LOCATION (fmem->after),\n+\t  if (fmem->after[0]\n+\t      && ((DECL_CONTEXT (fmem->after[0])\n+\t\t   != DECL_CONTEXT (fmem->array))))\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION (fmem->after[0]),\n \t\t      \"next member %q#D declared here\",\n-\t\t      fmem->after);\n-\n-\t  inform (location_of (t), \"in the definition of %q#T\", t);\n+\t\t      fmem->after[0]);\n+\t      inform (location_of (t), \"in the definition of %q#T\", t);\n+\t    }\n \t}\n     }\n+\n+  if (!diagd && fmem->array && fmem->enclosing)\n+    diagnose_invalid_flexarray (fmem);\n }\n \n \n@@ -6854,26 +6997,29 @@ diagnose_flexarrays (tree t, const flexmems_t *fmem)\n    that fails the checks.  */\n \n static void\n-check_flexarrays (tree t, flexmems_t *fmem /* = NULL */)\n+check_flexarrays (tree t, flexmems_t *fmem /* = NULL */,\n+\t\t  bool base_p /* = false */)\n {\n   /* Initialize the result of a search for flexible array and zero-length\n      array members.  Avoid doing any work if the most interesting FMEM data\n      have already been populated.  */\n   flexmems_t flexmems = flexmems_t ();\n   if (!fmem)\n     fmem = &flexmems;\n-  else if (fmem->array && fmem->first && fmem->after)\n+  else if (fmem->array && fmem->first && fmem->after[0])\n     return;\n \n+  tree fam = fmem->array;\n+\n   /* Recursively check the primary base class first.  */\n   if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     {\n       tree basetype = BINFO_TYPE (CLASSTYPE_PRIMARY_BINFO (t));\n-      check_flexarrays (basetype, fmem);\n+      check_flexarrays (basetype, fmem, true);\n     }\n \n   /* Recursively check the base classes.  */\n-  int nbases = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n+  int nbases = TYPE_BINFO (t) ? BINFO_N_BASE_BINFOS (TYPE_BINFO (t)) : 0;\n   for (int i = 0; i < nbases; ++i)\n     {\n       tree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (t), i);\n@@ -6887,7 +7033,7 @@ check_flexarrays (tree t, flexmems_t *fmem /* = NULL */)\n \tcontinue;\n \n       /* Check the base class.  */\n-      check_flexarrays (BINFO_TYPE (base_binfo), fmem);\n+      check_flexarrays (BINFO_TYPE (base_binfo), fmem, /*base_p=*/true);\n     }\n \n   if (fmem == &flexmems)\n@@ -6904,17 +7050,26 @@ check_flexarrays (tree t, flexmems_t *fmem /* = NULL */)\n \t  /* Check the virtual base class.  */\n \t  tree basetype = TREE_TYPE (base_binfo);\n \n-\t  check_flexarrays (basetype, fmem);\n+\t  check_flexarrays (basetype, fmem, /*base_p=*/true);\n \t}\n     }\n \n-  /* Search the members of the current (derived) class.  */\n-  find_flexarrays (t, fmem);\n+  /* Is the type unnamed (and therefore a member of it potentially\n+     an anonymous struct or union)?  */\n+  bool maybe_anon_p = TYPE_UNNAMED_P (t);\n \n-  if (fmem == &flexmems)\n+  /* Search the members of the current (possibly derived) class, skipping\n+     unnamed structs and unions since those could be anonymous.  */\n+  if (fmem != &flexmems || !maybe_anon_p)\n+    find_flexarrays (t, fmem, base_p || fam != fmem->array);\n+\n+  if (fmem == &flexmems && !maybe_anon_p)\n     {\n-      /* Issue diagnostics for invalid flexible and zero-length array members\n-\t found in base classes or among the members of the current class.  */\n+      /* Issue diagnostics for invalid flexible and zero-length array\n+\t members found in base classes or among the members of the current\n+\t class.  Ignore anonymous structs and unions whose members are\n+\t considered to be members of the enclosing class and thus will\n+\t be diagnosed when checking it.  */\n       diagnose_flexarrays (t, fmem);\n     }\n }"}, {"sha": "2978ca6f6eae53b804e777ca946b58b36bae42e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -25,6 +25,19 @@\n \t* gcc.target/arm/scd42-2.c: Fix existing logic to skip if -mcpu\n \tis incompatible\twith Xscale.\n \n+2016-10-13  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/71912\n+\t* g++.dg/ext/flexary4.C: Adjust.\n+\t* g++.dg/ext/flexary5.C: Same.\n+\t* g++.dg/ext/flexary9.C: Same.\n+\t* g++.dg/ext/flexary19.C: New test.\n+\t* g++.dg/ext/flexary18.C: New test.\n+\t* g++.dg/torture/pr64312.C: Add a dg-error directive to an ill-formed\n+\tregression test.\n+        * g++.dg/compat/struct-layout-1_generate.c (subfield): Add argument.\n+        Avoid generating a flexible array member in an array.\n+\n 2016-10-13  Martin Sebor  <msebor@redhat.com>\n \n \t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Cast 0 to wint_t\n@@ -1853,6 +1866,12 @@\n \t* gcc.target/msp430/function-attributes-2.c: New test.\n \t* gcc.target/msp430/function-attributes-3.c: New test.\n \n+2015-04-18  Martin Sebor  <msebor@redhat.com>\n+\n+\t* gfortran.dg/pr32627.f03 (strptr): Change size to match the number\n+\tof non-nul characters.\n+\t* gfortran.dg/substr_6.f90: Make the NUL character visible on stdout\n+\n 2016-09-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/cpp0x/gen-attrs-61.C: New test."}, {"sha": "8b620e46da82ee679059b77a2b397ef39123492d", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -495,7 +495,16 @@ struct types attrib_array_types[] = {\n #define HASH_SIZE 32749\n static struct entry *hash_table[HASH_SIZE];\n \n-static int idx, limidx, output_one, short_enums;\n+/* The index of the current type being output.  */\n+static int idx;\n+\n+/* The maximum index of the type(s) to output.  */\n+static int limidx;\n+\n+/* Set to non-zero to output a single type in response to the -i option\n+   (which sets LIMIDX to the index of the type to output.  */\n+static int output_one;\n+static int short_enums;\n static const char *destdir;\n static const char *srcdir;\n static const char *srcdir_safe;\n@@ -535,6 +544,7 @@ switchfiles (int fields)\n       fputs (\"failed to create test files\\n\", stderr);\n       exit (1);\n     }\n+\n   for (i = 0; i < NDG_OPTIONS; i++)\n     fprintf (outfile, dg_options[i], \"\", srcdir_safe);\n   fprintf (outfile, \"\\n\\\n@@ -607,9 +617,14 @@ getrandll (void)\n \n /* Generate a subfield.  The object pointed to by FLEX is set to a non-zero\n    value when the generated field is a flexible array member.  When set, it\n-   prevents subsequent fields from being generated (a flexible array mem*/\n+   prevents subsequent fields from being generated (a flexible array member\n+   must be the last member of the struct it's defined in).  ARRAY is non-\n+   zero when the enclosing structure is part of an array.  In that case,\n+   avoid generating a flexible array member as a subfield (such a member\n+   would be invalid).  */\n+\n int\n-subfield (struct entry *e, char *letter, int *flex)\n+subfield (struct entry *e, char *letter, int *flex, int array)\n {\n   int i, type;\n   char buf[20];\n@@ -664,7 +679,14 @@ subfield (struct entry *e, char *letter, int *flex)\n \t}\n \n       for (i = 1; !*flex && i <= e[0].len; )\n-\ti += subfield (e + i, letter, flex);\n+\t{\n+\t  /* Avoid generating flexible array members if the enclosing\n+\t     type is an array.  */\n+\t  int array\n+\t    = (e[0].etype == ETYPE_STRUCT_ARRAY\n+\t       || e[0].etype == ETYPE_UNION_ARRAY);\n+\t    i += subfield (e + i, letter, flex, array);\n+\t}\n \n       switch (type)\n \t{\n@@ -685,7 +707,7 @@ subfield (struct entry *e, char *letter, int *flex)\n     case ETYPE_ARRAY:\n       if (e[0].etype == ETYPE_ARRAY)\n \t{\n-\t  if (e[0].arr_len == 255)\n+\t  if (!array && e[0].arr_len == 255)\n \t    {\n \t      *flex = 1;\n  \t      snprintf (buf, 20, \"%c[]\", *letter);\n@@ -1141,6 +1163,7 @@ e_insert (struct entry *e)\n   hash_table[hval % HASH_SIZE] = e;\n }\n \n+/* Output a single type.  */\n void\n output (struct entry *e)\n {\n@@ -1169,7 +1192,7 @@ output (struct entry *e)\n \n   int flex = 0;\n   for (i = 1; i <= e[0].len; )\n-    i += subfield (e + i, &c, &flex);\n+    i += subfield (e + i, &c, &flex, 0);\n   \n   fputs (\",\", outfile);\n   c = 'a';"}, {"sha": "435342541e578358853b0d79d06f6147aac14949", "filename": "gcc/testsuite/g++.dg/ext/flexary18.C", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary18.C?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -0,0 +1,213 @@\n+// PR c++/71912 - [6/7 regression] flexible array in struct in union rejected\n+// { dg-do compile }\n+// { dg-additional-options \"-Wpedantic -Wno-error=pedantic\" }\n+\n+#if __cplusplus\n+\n+namespace pr71912 {\n+\n+#endif\n+\n+struct foo {\n+  int a;\n+  char s[];                             // { dg-message \"array member .char pr71912::foo::s \\\\\\[\\\\\\]. declared here\" }\n+};\n+\n+struct bar {\n+  double d;\n+  char t[];\n+};\n+\n+struct baz {\n+  union {\n+    struct foo f;\n+    struct bar b;\n+  }\n+  // The definition of struct foo is fine but the use of struct foo\n+  // in the definition of u below is what's invalid and must be clearly\n+  // diagnosed.\n+    u;                                  // { dg-warning \"invalid use of .struct pr71912::foo. with a flexible array member in .struct pr71912::baz.\" }\n+};\n+\n+struct xyyzy {\n+  union {\n+    struct {\n+      int a;\n+      char s[];                         // { dg-message \"declared here\" }\n+    } f;\n+    struct {\n+      double d;\n+      char t[];\n+    } b;\n+  } u;                                  // { dg-warning \"invalid use\" }\n+};\n+\n+struct baz b;\n+struct xyyzy x;\n+\n+#if __cplusplus\n+\n+}\n+\n+#endif\n+\n+// The following definitions aren't strictly valid but, like those above,\n+// are accepted for compatibility with GCC (in C mode).  They are benign\n+// in that the flexible array member is at the highest offset within\n+// the outermost type and doesn't overlap with other members except for\n+// those of the union.\n+union UnionStruct1 {\n+  struct { int n1, a[]; } s;\n+  int n2;\n+};\n+\n+union UnionStruct2 {\n+  struct { int n1, a1[]; } s1;\n+  struct { int n2, a2[]; } s2;\n+  int n3;\n+};\n+\n+union UnionStruct3 {\n+  struct { int n1, a1[]; } s1;\n+  struct { double n2, a2[]; } s2;\n+  char n3;\n+};\n+\n+union UnionStruct4 {\n+  struct { int n1, a1[]; } s1;\n+  struct { struct { int n2, a2[]; } s2; } s3;\n+  char n3;\n+};\n+\n+union UnionStruct5 {\n+  struct { struct { int n1, a1[]; } s1; } s2;   // { dg-warning \"invalid use\" }\n+  struct { double n2, a2[]; } s3;\n+  char n3;\n+};\n+\n+union UnionStruct6 {\n+  struct { struct { int n1, a1[]; } s1; } s2;   // { dg-warning \"invalid use\" }\n+  struct { struct { int n2, a2[]; } s3; } s4;\n+  char n3;\n+};\n+\n+union UnionStruct7 {\n+  struct { int n1, a1[]; } s1;\n+  struct { double n2, a2[]; } s2;\n+  struct { struct { int n3, a3[]; } s3; } s4;\n+};\n+\n+union UnionStruct8 {\n+  struct { int n1, a1[]; } s1;\n+  struct { struct { int n2, a2[]; } s2; } s3;\n+  struct { struct { int n3, a3[]; } s4; } s5;\n+};\n+\n+union UnionStruct9 {\n+  struct { struct { int n1, a1[]; } s1; } s2;   // { dg-warning \"invalid use\" }\n+  struct { struct { int n2, a2[]; } s3; } s4;\n+  struct { struct { int n3, a3[]; } s5; } s6;\n+};\n+\n+struct StructUnion1 {\n+  union {\n+    struct { int n1, a1[]; } s1;        // { dg-message \"declared here\" }\n+    struct { double n2, a2[]; } s2;\n+    char n3;\n+  } u;                                  // { dg-warning \"invalid use\" }\n+};\n+\n+// The following are invalid and rejected.\n+struct StructUnion2 {\n+  union {\n+    struct { int n1, a1[]; } s1;        // { dg-error \"not at end\" }\n+  } u;\n+  char n3;                              // { dg-message \"next member\" }\n+};\n+\n+struct StructUnion3 {\n+  union {\n+    struct { int n1, a1[]; } s1;        // { dg-error \"not at end\" }\n+    struct { double n2, a2[]; } s2;\n+  } u;\n+  char n3;                              // { dg-message \"next member\" }\n+};\n+\n+struct StructUnion4 {\n+  union {\n+    struct { int n1, a1[]; } s1;        // { dg-error \"not at end\" }\n+  } u1;\n+  union {\n+    struct { double n2, a2[]; } s2;\n+  } u2;                                 // { dg-message \"next member\" }\n+};\n+\n+struct StructUnion5 {\n+  union {\n+    union {\n+      struct { int n1, a1[]; } s1;      // { dg-message \"declared here\" }\n+    } u1;\n+    union { struct { int n2, a2[]; } s2; } u2;\n+  } u;                                  // { dg-warning \"invalid use\" }\n+};\n+\n+struct StructUnion6 {\n+  union {\n+    struct { int n1, a1[]; } s1;        // { dg-message \"declared here\" }\n+    union { struct { int n2, a2[]; } s2; } u2;\n+  } u;                                  // { dg-warning \"invalid use\" }\n+};\n+\n+struct StructUnion7 {\n+  union {\n+    union {\n+      struct { double n2, a2[]; } s2;   // { dg-message \"declared here\" }\n+    } u2;\n+    struct { int n1, a1[]; } s1;\n+  } u;                                  // { dg-warning \"invalid use\" }\n+};\n+\n+struct StructUnion8 {\n+  struct {\n+    union {\n+      union {\n+\tstruct { int n1, a1[]; } s1;    // { dg-error \"not at end\" }\n+      } u1;\n+      union {\n+\tstruct { double n2, a2[]; } s2;\n+      } u2;\n+    } u;\n+  } s1;\n+\n+  struct {\n+    union {\n+      union {\n+\tstruct { int n1, a1[]; } s1;\n+      } u1;\n+      union {\n+\tstruct { double n2, a2[]; } s2;\n+      } u2;\n+    } u; } s2;                              // { dg-message \"next member\" }\n+};\n+\n+struct StructUnion9 {                       // { dg-message \"in the definition\" }\n+  struct A1 {\n+    union B1 {\n+      union C1 {\n+\tstruct Sx1 { int n1, a1[]; } sx1;   // { dg-error \"not at end\" }\n+      } c1;\n+      union D1 {\n+\tstruct Sx2 { double n2, a2[]; } sx2;\n+      } d1;\n+    } b1;                                   // { dg-warning \"invalid use\" }\n+  } a1;\n+\n+  struct A2 {\n+    union B2 {\n+      union C2 {\n+\tstruct Sx3 { int n3, a3[]; } sx3;   // { dg-message \"declared here\" }\n+      } c2;\n+      union D2 { struct Sx4 { double n4, a4[]; } sx4; } d2;\n+    } b2;                                   // { dg-warning \"invalid use\" }\n+  } a2;                                     // { dg-message \"next member\" }\n+};"}, {"sha": "27d08ec225d09aad54d2a9d6dece1d096ad3c643", "filename": "gcc/testsuite/g++.dg/ext/flexary19.C", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary19.C?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -0,0 +1,343 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-Wpedantic -Wno-error=pedantic\" }\n+\n+// Verify that flexible array members are recognized as either valid\n+// or invalid in anonymous structs (a G++ extension) and C++ anonymous\n+// unions as well as in structs and unions that look anonymous but\n+// aren't.\n+struct S1\n+{\n+  int i;\n+\n+  // The following declares a named data member of an unnamed struct\n+  // (i.e., it is not an anonymous struct).\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s;\n+};\n+\n+struct S2\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s[1];\n+};\n+\n+struct S3\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s[];\n+};\n+\n+struct S4\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s[2];\n+};\n+\n+struct S5\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s[1][2];\n+};\n+\n+struct S6\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s[][2];\n+};\n+\n+struct S7\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } *s;\n+};\n+\n+struct S8\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } **s;\n+};\n+\n+struct S9\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } *s[1];\n+};\n+\n+struct S10\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } *s[];\n+};\n+\n+struct S11\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } **s[1];\n+};\n+\n+struct S12\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } **s[];\n+};\n+\n+struct S13\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } **s[2];\n+};\n+\n+struct S14\n+{\n+  int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } &s;\n+};\n+\n+struct S15\n+{\n+  int i;\n+\n+  typedef struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } T15;\n+};\n+\n+struct S16\n+{\n+  int i;\n+\n+  struct {          // { dg-warning \"invalid use\" }\n+    // A flexible array as a sole member of an anonymous struct is\n+    // rejected with an error in C mode but emits just a pedantic\n+    // warning in C++.  Other than excessive pedantry there is no\n+    // reason to reject it.\n+    int a[];\n+  };                // { dg-warning \"anonymous struct\" }\n+};\n+\n+struct S17\n+{\n+  int i;\n+\n+  union {           // anonymous union\n+    int a[];        // { dg-error \"flexible array member in union\" }\n+  };\n+};\n+\n+struct S18\n+{\n+  int i;\n+\n+  struct {\n+    int j, a[];     // { dg-message \"declared here\" }\n+  } s;              // { dg-warning \"invalid use\" }\n+};\n+\n+struct S19\n+{\n+  int i;\n+\n+  struct {          // { dg-warning \"invalid use\" }\n+    int j, a[];     // { dg-message \"declared here\" }\n+  };                // { dg-warning \"anonymous struct\" }\n+};\n+\n+struct S20\n+{\n+  static int i;\n+  typedef int A[];\n+\n+  struct {\n+    int j;\n+    A a;            // { dg-message \"declared here\" }\n+  } s;              // { dg-warning \"invalid use\" }\n+};\n+\n+struct S21\n+{\n+  static int i;\n+  typedef int A[];\n+\n+  struct {          // { dg-warning \"invalid use\" }\n+    int j;\n+    A a;            // { dg-message \"declared here\" }\n+  };                // { dg-warning \"anonymous struct\" }\n+};\n+\n+struct S22\n+{\n+  struct S22S {\n+    static int i;\n+\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s;\n+};\n+\n+struct S23\n+{\n+  struct {\n+    static int i;   // { dg-error \"static data member\" }\n+\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  };                // { dg-warning \"anonymous struct\" }\n+};\n+\n+struct S24\n+{\n+  static int i;\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s;\n+};\n+\n+struct S25\n+{\n+  int i;\n+\n+  struct {\n+    int j, a[];     // { dg-message \"declared here\" }\n+  } s;              // { dg-warning \"invalid use\" }\n+\n+  // Verify that a static data member of the enclosing class doesn't\n+  // cause infinite recursion or some such badness.\n+  static S25 s2;\n+};\n+\n+struct S26\n+{\n+  template <class>\n+  struct S26S {\n+    static int a;\n+  };\n+\n+  struct {\n+    int a[];        // { dg-error \"in an otherwise empty\" }\n+  } s;\n+};\n+\n+struct S27\n+{\n+  S27 *p;\n+  int a[];\n+};\n+\n+struct S28\n+{\n+  struct A {\n+    struct B {\n+      S28 *ps28;\n+      A   *pa;\n+      B   *pb;\n+    } b, *pb;\n+    A *pa;\n+  } a, *pa;\n+\n+  S28::A *pa2;\n+  S28::A::B *pb;\n+\n+  int flexarray[];\n+};\n+\n+// Verify that the notes printed along with the warnings point to the types\n+// or members they should point to and mention the correct relationships\n+// with the flexible array members.\n+namespace Notes\n+{\n+union A\n+{\n+  struct {\n+    struct {\n+      int i, a[];   // { dg-message \"declared here\" }\n+    } c;            // { dg-warning \"invalid use\" }\n+  } d;\n+  int j;\n+};\n+\n+union B\n+{\n+  struct {\n+    struct {        // { dg-warning \"invalid use\" }\n+      int i, a[];   // { dg-message \"declared here\" }\n+    };              // { dg-warning \"anonymous struct\" }\n+  };                // { dg-warning \"anonymous struct\" }\n+  int j;\n+};\n+\n+}\n+\n+typedef struct Opaque* P29;\n+struct S30 { P29 p; };\n+struct S31 { S30 s; };\n+\n+typedef struct { } S32;\n+typedef struct { S32 *ps32; } S33;\n+typedef struct\n+{\n+  S33 *ps33;\n+} S34;\n+\n+struct S35\n+{\n+  struct A {\n+    int i1, a1[];\n+  };\n+\n+  struct B {\n+    int i2, a2[];\n+  };\n+\n+  typedef struct {\n+    int i3, a3[];\n+  } C;\n+\n+  typedef struct {\n+    int i4, a4[];\n+  } D;\n+\n+  typedef A A2;\n+  typedef B B2;\n+  typedef C C2;\n+  typedef D D2;\n+};\n+"}, {"sha": "29d6bddf3365364d41b2cd4f38f28cc69dbbfe38", "filename": "gcc/testsuite/g++.dg/ext/flexary4.C", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary4.C?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -102,31 +102,28 @@ struct Sx17 {\n   int a_0 [0];\n };\n \n-// Empty structs are a GCC extension that (in C++ only) is treated\n-// as if it had a single member of type char.  Therefore, a struct\n+// An empty struct is treated as if it had a single member of type\n+// char but the member cannot be accessed.  Therefore, a struct\n // containing a flexible array member followed by an empty struct\n // is diagnosed to prevent the former subobject from sharing space\n // with the latter.\n struct Sx18 {\n   int a_x [];               // { dg-error \"flexible array member\" }\n-  struct S { };\n+  struct { /* empty */ } s;\n };\n \n-// Anonymous structs and unions are another GCC extension.  Since\n-// they cannot be named and thus used to store the size of a flexible\n-// array member, a struct containing both is diagnosed as if\n-// the flexible array member appeared alone.\n+// Anonymous structs are a G++ extension.  Members of anonymous structs\n+// are treated as if they were declared in the enclosing class.\n struct Sx19 {\n-  struct S { };\n-  union U { };\n-  int a_x [];               // { dg-error \"in an otherwise empty\" }\n+  struct { int i; };        // anonymous struct\n+  int a_x [];\n };\n \n-// Unlike in the case above, a named member of an anonymous struct\n-// prevents a subsequent flexible array member from being diagnosed.\n+// Unlike in the case above, a named struct is not anonymous and\n+// so doesn't contribute its member to that of the enclosing struct.\n struct Sx20 {\n-  struct S { } s;\n-  int a_x [];\n+  struct S { int i; };\n+  int a_x [];               // { dg-error \"in an otherwise empty\" }\n };\n \n struct Sx21 {\n@@ -298,6 +295,15 @@ struct Anon1 {\n \n ASSERT_AT_END (Anon1, good);\n \n+struct NotAnon1 {\n+  int n;\n+  // The following is not an anonymous struct -- the type is unnamed\n+  // but the object has a name.\n+  struct {\n+    int bad[];              // { dg-error \"otherwise empty\" }\n+  } name;\n+};\n+\n struct Anon2 {\n   struct {\n     int n;\n@@ -352,7 +358,6 @@ struct Anon7 {\n   int n;\n };\n \n-\n struct Six {\n   int i;\n   int a[];"}, {"sha": "d6d8e32818f4bbf078674d5d65ef9b384f96fcb1", "filename": "gcc/testsuite/g++.dg/ext/flexary5.C", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary5.C?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -64,19 +64,29 @@ struct D5: E1, E2, NE { char a[]; };\n \n ASSERT_AT_END (D5, a);   // { dg-warning \"offsetof within non-standard-layout\" }\n \n-struct A2x {\n+struct A2x_1 {\n   size_t n;\n-  size_t a[];   // { dg-error \"not at end of .struct D6.| D7.| D8.\" }\n+  size_t a[];   // { dg-error \"not at end of .struct D6.\" }\n+};\n+\n+struct A2x_2 {\n+  size_t n;\n+  size_t a[];   // { dg-error \"not at end of .struct D7.\" }\n+};\n+\n+struct A2x_3 {\n+  size_t n;\n+  size_t a[];   // { dg-error \"not at end of .struct D8.\" }\n };\n \n // Verify that the flexible array member in A2x above is diagnosed\n // for each of the three struct defintions below which also derive\n // from another struct with a flexible array member.\n-struct D6: A2x, E1, A1x { };\n-struct D7: E1, A2x, E2, A1x { };\n-struct D8: E1, E2, A2x, A1x { };\n+struct D6: A2x_1, E1, A1x { };\n+struct D7: E1, A2x_2, E2, A1x { };\n+struct D8: E1, E2, A2x_3, A1x { };\n \n-struct DA2x: A2x { };\n+struct DA2x: A2x_1 { };\n \n struct D9: DA2x, E1, E2 { };\n \n@@ -194,16 +204,27 @@ struct NE2: NE { };\n struct D28: NE1, AA6x { };\n struct D29: AA6x, NE1 { };\n \n-// Verify that a flexible array member in a virtual base class is not\n-// diagnosed.\n struct A7x {\n   size_t n;\n-  size_t a[];\n+  size_t a[];               // { dg-error \"flexible array member .A7x::a. not at end of .struct D33.\" }\n };\n \n+// Verify that a flexible array member in a virtual base class is not\n+// diagnosed.\n struct DA7xV1: virtual A7x { };\n struct DA7xV2: virtual A7x { };\n \n struct D30: DA7xV1, DA7xV2 { };\n struct D31: DA7xV1, DA7xV2 { };\n struct D32: D30, D31 { };\n+\n+// Verify the diagnostic when the flexible array is in an anonymous struct.\n+struct A8x {\n+  struct {                  // { dg-message \"next member .A8x::<unnamed struct> A8x::<anonymous>. declared here\" }\n+    size_t n;\n+    size_t a[];\n+  };\n+};\n+\n+struct D33:                 // { dg-message \"in the definition of .struct D33.\" }\n+  A7x, A8x { };"}, {"sha": "07eb966ae47aa72b16d548401470d35638449f93", "filename": "gcc/testsuite/g++.dg/ext/flexary9.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary9.C?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -281,15 +281,15 @@ struct S_S_S_x {\n \n struct Anon1 {\n   int n;\n-  struct {\n-    int good[0];            // { dg-warning \"zero-size array\" }\n+  struct {                  // { dg-warning \"invalid use \\[^\\n\\r\\]* with a zero-size array\" }\n+    int good[0];            // { dg-warning \"forbids zero-size array\" }\n   };                        // { dg-warning \"anonymous struct\" }\n };\n \n ASSERT_AT_END (Anon1, good);\n \n struct Anon2 {\n-  struct {\n+  struct {                  // { dg-warning \"invalid use\" }\n     int n;\n     struct {\n       int good[0];          // { dg-warning \"zero-size array\" }\n@@ -300,7 +300,7 @@ struct Anon2 {\n ASSERT_AT_END (Anon2, good);\n \n struct Anon3 {\n-  struct {\n+  struct {                  // { dg-warning \"invalid use\" }\n     struct {\n       int n;\n       int good[0];          // { dg-warning \"zero-size array\" }"}, {"sha": "c7a56d7bfca9fe3b28c3f21dc92b74cb92f79bf4", "filename": "gcc/testsuite/g++.dg/torture/pr64312.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64312.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960320472221464b48db6c2a1523b5f74b74d016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64312.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64312.C?ref=960320472221464b48db6c2a1523b5f74b74d016", "patch": "@@ -44,7 +44,7 @@ class F\n {\n public:\n   int nelems;\n-  int elems[];\n+  int elems[];   // { dg-error \"not at end\" }\n   int *\n   m_fn1 ()\n   {\n@@ -88,7 +88,7 @@ public:\n       m_impl->~any_incrementable_iterator_interface ();\n   }\n   G m_buffer;\n-  any_incrementable_iterator_interface *m_impl;\n+  any_incrementable_iterator_interface *m_impl;   // { dg-message \"next member\" }\n };\n template <class Reference> class K : public I<any_iterator<Reference> >\n {"}]}