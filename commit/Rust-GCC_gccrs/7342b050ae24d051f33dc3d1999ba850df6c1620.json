{"sha": "7342b050ae24d051f33dc3d1999ba850df6c1620", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM0MmIwNTBhZTI0ZDA1MWYzM2RjM2QxOTk5YmE4NTBkZjZjMTYyMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-28T23:12:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-28T23:12:39Z"}, "message": "Initial revision\n\nFrom-SVN: r19476", "tree": {"sha": "c31d47ee1983ef26d596586cbffc9f7abb8b0a1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c31d47ee1983ef26d596586cbffc9f7abb8b0a1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7342b050ae24d051f33dc3d1999ba850df6c1620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7342b050ae24d051f33dc3d1999ba850df6c1620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7342b050ae24d051f33dc3d1999ba850df6c1620", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7342b050ae24d051f33dc3d1999ba850df6c1620/comments", "author": null, "committer": null, "parents": [{"sha": "f60d62486ed0f3555859e1531c512b91ae6165e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60d62486ed0f3555859e1531c512b91ae6165e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f60d62486ed0f3555859e1531c512b91ae6165e3"}], "stats": {"total": 222, "additions": 222, "deletions": 0}, "files": [{"sha": "515892dfb867d4bf8933d0289a2656ab23cd52b7", "filename": "gcc/intl/loadmsgcat.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7342b050ae24d051f33dc3d1999ba850df6c1620/gcc%2Fintl%2Floadmsgcat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7342b050ae24d051f33dc3d1999ba850df6c1620/gcc%2Fintl%2Floadmsgcat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl%2Floadmsgcat.c?ref=7342b050ae24d051f33dc3d1999ba850df6c1620", "patch": "@@ -0,0 +1,222 @@\n+/* Load needed message catalogs.\n+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+# include <config.h>\n+#endif\n+\n+#include <fcntl.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined STDC_HEADERS || defined _LIBC\n+# include <stdlib.h>\n+#endif\n+\n+#if defined HAVE_UNISTD_H || defined _LIBC\n+# include <unistd.h>\n+#endif\n+\n+#if (defined HAVE_MMAP && defined HAVE_MUNMAP) || defined _LIBC\n+# include <sys/mman.h>\n+#endif\n+\n+#include \"gettext.h\"\n+#include \"gettextP.h\"\n+\n+/* @@ end of prolog @@ */\n+\n+#ifdef _LIBC\n+/* Rename the non ISO C functions.  This is required by the standard\n+   because some ISO C functions will require linking with this object\n+   file and the name space must not be polluted.  */\n+# define open   __open\n+# define close  __close\n+# define read   __read\n+# define mmap   __mmap\n+# define munmap __munmap\n+#endif\n+\n+/* We need a sign, whether a new catalog was loaded, which can be associated\n+   with all translations.  This is important if the translations are\n+   cached by one of GCC's features.  */\n+int _nl_msg_cat_cntr = 0;\n+\n+\n+/* Load the message catalogs specified by FILENAME.  If it is no valid\n+   message catalog do nothing.  */\n+void\n+internal_function\n+_nl_load_domain (domain_file)\n+     struct loaded_l10nfile *domain_file;\n+{\n+  int fd;\n+  size_t size;\n+  struct stat st;\n+  struct mo_file_header *data = (struct mo_file_header *) -1;\n+#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \\\n+    || defined _LIBC\n+  int use_mmap = 0;\n+#endif\n+  struct loaded_domain *domain;\n+\n+  domain_file->decided = 1;\n+  domain_file->data = NULL;\n+\n+  /* If the record does not represent a valid locale the FILENAME\n+     might be NULL.  This can happen when according to the given\n+     specification the locale file name is different for XPG and CEN\n+     syntax.  */\n+  if (domain_file->filename == NULL)\n+    return;\n+\n+  /* Try to open the addressed file.  */\n+  fd = open (domain_file->filename, O_RDONLY);\n+  if (fd == -1)\n+    return;\n+\n+  /* We must know about the size of the file.  */\n+  if (fstat (fd, &st) != 0\n+      || (size = (size_t) st.st_size) != st.st_size\n+      || size < sizeof (struct mo_file_header))\n+    {\n+      /* Something went wrong.  */\n+      close (fd);\n+      return;\n+    }\n+\n+#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \\\n+    || defined _LIBC\n+  /* Now we are ready to load the file.  If mmap() is available we try\n+     this first.  If not available or it failed we try to load it.  */\n+  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,\n+\t\t\t\t\t MAP_PRIVATE, fd, 0);\n+\n+  if (data != (struct mo_file_header *) -1)\n+    {\n+      /* mmap() call was successful.  */\n+      close (fd);\n+      use_mmap = 1;\n+    }\n+#endif\n+\n+  /* If the data is not yet available (i.e. mmap'ed) we try to load\n+     it manually.  */\n+  if (data == (struct mo_file_header *) -1)\n+    {\n+      size_t to_read;\n+      char *read_ptr;\n+\n+      data = (struct mo_file_header *) malloc (size);\n+      if (data == NULL)\n+\treturn;\n+\n+      to_read = size;\n+      read_ptr = (char *) data;\n+      do\n+\t{\n+\t  long int nb = (long int) read (fd, read_ptr, to_read);\n+\t  if (nb == -1)\n+\t    {\n+\t      close (fd);\n+\t      return;\n+\t    }\n+\n+\t  read_ptr += nb;\n+\t  to_read -= nb;\n+\t}\n+      while (to_read > 0);\n+\n+      close (fd);\n+    }\n+\n+  /* Using the magic number we can test whether it really is a message\n+     catalog file.  */\n+  if (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED)\n+    {\n+      /* The magic number is wrong: not a message catalog file.  */\n+#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \\\n+    || defined _LIBC\n+      if (use_mmap)\n+\tmunmap ((caddr_t) data, size);\n+      else\n+#endif\n+\tfree (data);\n+      return;\n+    }\n+\n+  domain_file->data\n+    = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));\n+  if (domain_file->data == NULL)\n+    return;\n+\n+  domain = (struct loaded_domain *) domain_file->data;\n+  domain->data = (char *) data;\n+#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \\\n+    || defined _LIBC\n+  domain->use_mmap = use_mmap;\n+#endif\n+  domain->mmap_size = size;\n+  domain->must_swap = data->magic != _MAGIC;\n+\n+  /* Fill in the information about the available tables.  */\n+  switch (W (domain->must_swap, data->revision))\n+    {\n+    case 0:\n+      domain->nstrings = W (domain->must_swap, data->nstrings);\n+      domain->orig_tab = (struct string_desc *)\n+\t((char *) data + W (domain->must_swap, data->orig_tab_offset));\n+      domain->trans_tab = (struct string_desc *)\n+\t((char *) data + W (domain->must_swap, data->trans_tab_offset));\n+      domain->hash_size = W (domain->must_swap, data->hash_tab_size);\n+      domain->hash_tab = (nls_uint32 *)\n+\t((char *) data + W (domain->must_swap, data->hash_tab_offset));\n+      break;\n+    default:\n+      /* This is an illegal revision.  */\n+#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \\\n+    || defined _LIBC\n+      if (use_mmap)\n+\tmunmap ((caddr_t) data, size);\n+      else\n+#endif\n+\tfree (data);\n+      free (domain);\n+      domain_file->data = NULL;\n+      return;\n+    }\n+\n+  /* Show that one domain is changed.  This might make some cached\n+     translations invalid.  */\n+  ++_nl_msg_cat_cntr;\n+}\n+\n+\n+#ifdef _LIBC\n+void\n+internal_function\n+_nl_unload_domain (domain)\n+     struct loaded_domain *domain;\n+{\n+  if (domain->use_mmap)\n+    munmap ((caddr_t) domain->data, domain->mmap_size);\n+  else\n+    free ((void *) domain->data);\n+\n+  free (domain);\n+}\n+#endif"}]}