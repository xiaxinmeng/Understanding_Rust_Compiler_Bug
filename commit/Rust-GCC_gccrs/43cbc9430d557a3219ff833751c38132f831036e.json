{"sha": "43cbc9430d557a3219ff833751c38132f831036e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNjYmM5NDMwZDU1N2EzMjE5ZmY4MzM3NTFjMzgxMzJmODMxMDM2ZQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "1999-12-24T01:00:46Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "1999-12-24T01:00:46Z"}, "message": "natObject.cc (notify): Throw message with IllegalMonitorStateException.\n\n1999-12-22  Bryce McKinlay  <bryce@albatross.co.nz>\n\n        * java/lang/natObject.cc (notify): Throw message with\n        IllegalMonitorStateException.\n        (notifyAll): Ditto.\n        (wait): Ditto.\n        * java/lang/Thread.java (isInterrupted): Don't clear interrupt_flag.\n        (isInterrupted_): New function, which does clear interrupt_flag.\n        (interrupt): Use `isInterrupted_'.\n        * java/lang/natThread.cc (interrupt): Add comment.\n        (join): Set `Prev' in joiner loop.\n        Change various calls to `isInterrupted' to use `isInterrupted_'.\n        * posix-threads.cc (_Jv_CondWait): Allways use pthread_cond_timedwait\n        on linux. Set result to 0 on an interrupt. Test interrupted status\n        of java Thread object directly.\n        FLAG_INTERRUPTED: removed.\n        (_Jv_ThreadStart): Throw OutOfMemoryError if pthread_create fails.\n        (_Jv_ThreadInterrupt): Don't set FLAG_INTERRUPTED.\n        (_Jv_InitThreads): Don't block SIGINT.\n        (_Jv_ThreadWait): Don't configure SIGINT handler.\n\nFrom-SVN: r31082", "tree": {"sha": "42d8776b8882e3c389088fa07c0348d511ab5edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42d8776b8882e3c389088fa07c0348d511ab5edf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43cbc9430d557a3219ff833751c38132f831036e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43cbc9430d557a3219ff833751c38132f831036e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43cbc9430d557a3219ff833751c38132f831036e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43cbc9430d557a3219ff833751c38132f831036e/comments", "author": null, "committer": null, "parents": [{"sha": "07875628ee1bbcc753b44b4d962779d577cd605a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07875628ee1bbcc753b44b4d962779d577cd605a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07875628ee1bbcc753b44b4d962779d577cd605a"}], "stats": {"total": 172, "additions": 108, "deletions": 64}, "files": [{"sha": "cfdd9860e89d1517d10923fd692a3647d45acccb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43cbc9430d557a3219ff833751c38132f831036e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43cbc9430d557a3219ff833751c38132f831036e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=43cbc9430d557a3219ff833751c38132f831036e", "patch": "@@ -1,3 +1,24 @@\n+1999-12-22  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/lang/natObject.cc (notify): Throw message with\n+\tIllegalMonitorStateException.\n+\t(notifyAll): Ditto.\n+\t(wait): Ditto.\n+\t* java/lang/Thread.java (isInterrupted): Don't clear interrupt_flag.\n+\t(isInterrupted_): New function, which does clear interrupt_flag.\n+\t(interrupt): Use `isInterrupted_'.\n+\t* java/lang/natThread.cc (interrupt): Add comment.\n+\t(join): Set `prev' in joiner loop.\n+\tChange various calls to `isInterrupted' to use `isInterrupted_'.\n+\t* posix-threads.cc (_Jv_CondWait): Allways use pthread_cond_timedwait\n+\ton linux. Set result to 0 on an interrupt. Test interrupted status\n+\tof java Thread object directly. \n+\tFLAG_INTERRUPTED: removed.\n+\t(_Jv_ThreadStart): Throw OutOfMemoryError if pthread_create fails.\n+\t(_Jv_ThreadInterrupt): Don't set FLAG_INTERRUPTED.\n+\t(_Jv_InitThreads): Don't block SIGINT.\n+\t(_Jv_ThreadWait): Don't configure SIGINT handler.\n+\n 1999-12-21  Tom Tromey  <tromey@cygnus.com>\n \n \t* mauve-libgcj: Added java.lang.reflect.Modifier.toString12."}, {"sha": "3d9f9fbd9f5686a4b4b6c79c62f38235f5113114", "filename": "libjava/java/lang/natObject.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43cbc9430d557a3219ff833751c38132f831036e/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43cbc9430d557a3219ff833751c38132f831036e/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=43cbc9430d557a3219ff833751c38132f831036e", "patch": "@@ -175,7 +175,8 @@ java::lang::Object::notify (void)\n     sync_init ();\n   _Jv_SyncInfo *si = (_Jv_SyncInfo *) sync_info;\n   if (_Jv_CondNotify (&si->condition, &si->mutex))\n-    JvThrow (new IllegalMonitorStateException);\n+    JvThrow (new IllegalMonitorStateException(JvNewStringLatin1 \n+                                              (\"current thread not owner\")));\n }\n \n void\n@@ -185,7 +186,8 @@ java::lang::Object::notifyAll (void)\n     sync_init ();\n   _Jv_SyncInfo *si = (_Jv_SyncInfo *) sync_info;\n   if (_Jv_CondNotifyAll (&si->condition, &si->mutex))\n-    JvThrow (new IllegalMonitorStateException);\n+    JvThrow (new IllegalMonitorStateException(JvNewStringLatin1 \n+                                              (\"current thread not owner\")));\n }\n \n void\n@@ -197,7 +199,8 @@ java::lang::Object::wait (jlong timeout, jint nanos)\n     JvThrow (new IllegalArgumentException);\n   _Jv_SyncInfo *si = (_Jv_SyncInfo *) sync_info;\n   if (_Jv_CondWait (&si->condition, &si->mutex, timeout, nanos))\n-    JvThrow (new IllegalMonitorStateException);\n+    JvThrow (new IllegalMonitorStateException(JvNewStringLatin1 \n+                                              (\"current thread not owner\")));\n   if (Thread::interrupted())\n     JvThrow (new InterruptedException);\n }"}, {"sha": "8239f17da18670482e8edcfb7da193c9da6688dc", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43cbc9430d557a3219ff833751c38132f831036e/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43cbc9430d557a3219ff833751c38132f831036e/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=43cbc9430d557a3219ff833751c38132f831036e", "patch": "@@ -130,10 +130,13 @@ java::lang::Thread::interrupt (void)\n   // another thread to exit.\n   natThread *nt = (natThread *) data;\n   _Jv_MutexLock (&nt->interrupt_mutex);\n+  // Notify the interrupt condition to interrupt sleep() and join() calls.\n   _Jv_CondNotify (&nt->interrupt_cond, &nt->interrupt_mutex);\n-  _Jv_MutexUnlock (&nt->interrupt_mutex);\n-\n+  // Send a signal to the target thread to interrupt system calls. On Linux,\n+  // this will also interrupt the target thread from *any* _Jv_CondWait call,\n+  // ie wait(). This behaviour is not portable, however.\n   _Jv_ThreadInterrupt (nt->thread);\n+  _Jv_MutexUnlock (&nt->interrupt_mutex);\n }\n \n void\n@@ -145,7 +148,7 @@ java::lang::Thread::join (jlong millis, jint nanos)\n     _Jv_Throw (new IllegalArgumentException);\n \n   Thread *current = currentThread ();\n-  if (current->isInterrupted ())\n+  if (current->isInterrupted_ ())\n     _Jv_Throw (new InterruptedException);\n \n   // Update the list of all threads waiting for this thread to exit.\n@@ -199,11 +202,12 @@ java::lang::Thread::join (jlong millis, jint nanos)\n \t  t->next = 0;\n \t  break;\n \t}\n+      prev = t;\n     }\n   JvAssert (t != NULL);\n   _Jv_MonitorExit (this);\n \n-  if (current->isInterrupted ())\n+  if (current->isInterrupted_ ())\n     _Jv_Throw (new InterruptedException);\n }\n \n@@ -240,7 +244,7 @@ java::lang::Thread::sleep (jlong millis, jint nanos)\n     ++nanos;\n \n   Thread *current = currentThread ();\n-  if (current->isInterrupted ())\n+  if (current->isInterrupted_ ())\n     _Jv_Throw (new InterruptedException);\n \n   // We use a condition variable to implement sleeping so that an\n@@ -253,7 +257,7 @@ java::lang::Thread::sleep (jlong millis, jint nanos)\n \t\t  millis, nanos);\n   }\n \n-  if (current->isInterrupted ())\n+  if (current->isInterrupted_ ())\n     _Jv_Throw (new InterruptedException);\n }\n "}, {"sha": "cf18aced81c03c0fb3a10736083c0c2083de4806", "filename": "libjava/posix-threads.cc", "status": "modified", "additions": 71, "deletions": 55, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43cbc9430d557a3219ff833751c38132f831036e/libjava%2Fposix-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43cbc9430d557a3219ff833751c38132f831036e/libjava%2Fposix-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix-threads.cc?ref=43cbc9430d557a3219ff833751c38132f831036e", "patch": "@@ -27,11 +27,14 @@ extern \"C\"\n #include <time.h>\n #include <signal.h>\n #include <errno.h>\n+#include <limits.h>\n \n #include <gcj/cni.h>\n #include <jvm.h>\n #include <java/lang/Thread.h>\n #include <java/lang/System.h>\n+#include <java/lang/Long.h>\n+#include <java/lang/OutOfMemoryError.h>\n \n // This is used to implement thread startup.\n struct starter\n@@ -58,7 +61,7 @@ static int non_daemon_count;\n \n // The signal to use when interrupting a thread.\n #ifdef LINUX_THREADS\n-  // LinuxThreads usurps both SIGUSR1 and SIGUSR2.\n+  // LinuxThreads (prior to glibc 2.1) usurps both SIGUSR1 and SIGUSR2.\n #  define INTR SIGHUP\n #else /* LINUX_THREADS */\n #  define INTR SIGUSR2\n@@ -72,8 +75,6 @@ static int non_daemon_count;\n #define FLAG_START   0x01\n // Thread is daemon.\n #define FLAG_DAEMON  0x02\n-// Thread was interrupted by _Jv_ThreadInterrupt.\n-#define FLAG_INTERRUPTED  0x04\n \n \f\n \n@@ -86,58 +87,82 @@ _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n \n   int r;\n   pthread_mutex_t *pmu = _Jv_PthreadGetMutex (mu);\n-  struct timespec ts; \n+  struct timespec ts;\n   jlong m, m2, startTime;\n   bool done_sleeping = false;\n \n   if (millis == 0 && nanos == 0)\n-    r = pthread_cond_wait (cv, pmu);\n+    {\n+#ifdef LINUX_THREADS\n+      // pthread_cond_timedwait can be interrupted by a signal on linux, while\n+      // pthread_cond_wait can not. So pthread_cond_timedwait() forever.\n+      m = java::lang::Long::MAX_VALUE;\n+      ts.tv_sec = LONG_MAX;\n+      ts.tv_nsec = 0;\n+#endif\n+    }\n   else\n     {\n       startTime = java::lang::System::currentTimeMillis();\n       m = millis + startTime;\n+      ts.tv_sec = m / 1000; \n+      ts.tv_nsec = ((m % 1000) * 1000000) + nanos; \n+    }\n \n-      do\n-\t{  \n-\t  ts.tv_sec = m / 1000; \n-\t  ts.tv_nsec = ((m % 1000) * 1000000) + nanos; \n+  java::lang::Thread *current = _Jv_ThreadCurrent();\n \n+  do\n+    {\n+      r = EINTR;\n+      // Check to ensure the thread hasn't already been interrupted.\n+      if (!(current->isInterrupted ()))\n+        {\n+#ifdef LINUX_THREADS\t\n+\t  // FIXME: in theory, interrupt() could be called on this thread\n+\t  // between the test above and the wait below, resulting in the \n+\t  // interupt() call failing. I don't see a way to fix this \n+\t  // without significant changes to the implementation.\n \t  r = pthread_cond_timedwait (cv, pmu, &ts);\n-\n-\t  if (r == EINTR)\n+#else\n+\t  if (millis == 0 && nanos == 0)\n+\t    r = pthread_cond_wait (cv, pmu);\n+\t  else\t  \n+\t    r = pthread_cond_timedwait (cv, pmu, &ts);\t  \n+#endif\n+\t}\n+      \n+      if (r == EINTR)\n+\t{\n+\t  /* We were interrupted by a signal.  Either this is\n+\t     because we were interrupted intentionally (i.e. by\n+\t     Thread.interrupt()) or by the GC if it is\n+\t     signal-based.  */\n+\t  if (current->isInterrupted ())\n \t    {\n-\t      /* We were interrupted by a signal.  Either this is\n-\t\t because we were interrupted intentionally (i.e. by\n-\t\t Thread.interrupt()) or by the GC if it is\n-\t\t signal-based.  */\n-\t      _Jv_Thread_t *current = _Jv_ThreadCurrentData();\n-\t      if (current->flags & FLAG_INTERRUPTED)\n+\t      r = 0;\n+              done_sleeping = true;\n+            }\n+\t  else\n+            {\n+\t      /* We were woken up by the GC or another signal.  */\n+\t      m2 = java::lang::System::currentTimeMillis ();\n+\t      if (m2 >= m)\n \t\t{\n-                  current->flags &= ~(FLAG_INTERRUPTED);\n-                  done_sleeping = true;\n-                }\n-\t      else\n-                {\n-\t\t  /* We were woken up by the GC or another signal.  */\n-\t\t  m2 = java::lang::System::currentTimeMillis ();\n-\t\t  if (m2 >= m)\n-\t\t    {\n-\t\t      r = 0;\n-\t\t      done_sleeping = true;\n-\t\t    }\n+\t\t  r = 0;\n+\t\t  done_sleeping = true;\n \t\t}\n \t    }\n-\t  else if (r == ETIMEDOUT)\n-\t    {\n-\t      /* A timeout is a normal result.  */\n-\t      r = 0;\n-\t      done_sleeping = true;\n-\t    }\n-\t  else\n-\t    done_sleeping = true;\n \t}\n-      while (! done_sleeping);\n+      else if (r == ETIMEDOUT)\n+\t{\n+\t  /* A timeout is a normal result.  */\n+\t  r = 0;\n+\t  done_sleeping = true;\n+\t}\n+      else\n+\tdone_sleeping = true;\n     }\n+  while (! done_sleeping);\n \n   return r != 0;\n }\n@@ -272,20 +297,12 @@ _Jv_InitThreads (void)\n   sigemptyset (&act.sa_mask);\n   act.sa_flags = 0;\n   sigaction (INTR, &act, NULL);\n-\n-  // Arrange for SIGINT to be blocked to all threads.  It is only\n-  // deliverable to the master thread.\n-  sigset_t mask;\n-  sigemptyset (&mask);\n-  sigaddset (&mask, SIGINT);\n-  pthread_sigmask (SIG_BLOCK, &mask, NULL);\n }\n \n void\n _Jv_ThreadInitData (_Jv_Thread_t **data, java::lang::Thread *)\n {\n   _Jv_Thread_t *info = new _Jv_Thread_t;\n-\n   info->flags = 0;\n \n   // FIXME register a finalizer for INFO here.\n@@ -361,20 +378,20 @@ _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n     }\n   else\n     data->flags |= FLAG_DAEMON;\n-  pthread_create (&data->thread, &attr, really_start, (void *) info);\n-\n+  int r = pthread_create (&data->thread, &attr, really_start, (void *) info);\n+  \n   pthread_attr_destroy (&attr);\n+\n+  if (r)\n+    {\n+      const char* msg = \"Cannot create additional threads\";\n+      JvThrow (new java::lang::OutOfMemoryError (JvNewStringUTF (msg)));\n+    }\n }\n \n void\n _Jv_ThreadWait (void)\n {\n-  // Arrange for SIGINT to be delivered to the master thread.\n-  sigset_t mask;\n-  sigemptyset (&mask);\n-  sigaddset (&mask, SIGINT);\n-  pthread_sigmask (SIG_UNBLOCK, &mask, NULL);\n-\n   pthread_mutex_lock (&daemon_mutex);\n   if (non_daemon_count)\n     pthread_cond_wait (&daemon_cond, &daemon_mutex);\n@@ -384,6 +401,5 @@ _Jv_ThreadWait (void)\n void\n _Jv_ThreadInterrupt (_Jv_Thread_t *data)\n {\n-  data->flags |= FLAG_INTERRUPTED; \n   pthread_kill (data->thread, INTR);\n }"}]}