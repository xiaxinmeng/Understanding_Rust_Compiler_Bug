{"sha": "41472af8777035219decfe1cb4742ce2b3ed8e38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE0NzJhZjg3NzcwMzUyMTlkZWNmZTFjYjQ3NDJjZTJiM2VkOGUzOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-06-25T15:14:41Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-06-25T15:14:41Z"}, "message": "invoke.texi (-fstrict-aliasing): Document.\n\n\t* invoke.texi (-fstrict-aliasing): Document.\n\t* rtl.texi (MEM_ALIAS_SET): Document.\n\t* flags.h (flag_strict_aliasing): Declare.\n\t* toplev.c (flag_strict_aliasing): Define.\n\t(f_options): Add -strict-aliasing.\n\t(main): Set flag_strict_aliasing if -O2 or higher.\n\t* tree.h (tree_type): Add alias_set field.\n\t(TYPE_ALIAS_SET): New macro.\n\t(TYPE_ALIAS_SET_KNOWN_P): Likewise.\n\t(get_alias_set): Declare.\n\t* tree.c (lang_get_alias_set): Define.\n\t(make_node): Initialize TYPE_ALIAS_SET.\n\t(get_alias_set): New function.\n\t* print-tree.c (print_node): Dump the alias set for a type.\n\t* c-tree.h (c_get_alias_set): Declare.\n\t* c-common.c (c_get_alias_set): New function.\n\t* c-decl.c (init_decl_processing): Set lang_get_alias_set.\n\t* expr.c (protect_from_queue): Propogage alias sets.\n\t(expand_assignment): Calculate alias set for new MEMs.\n\t(expand_expr): Likewise.\n\t* function.c (put_var_into_stack): Likewise.\n\t(put_reg_into_stack): Likewise.\n\t(gen_mem_addressof): Likewise.\n\t(assign_parms): Likewise.\n\t* stmt.c (expand_decl): Likewise.\n\t* varasm.c (make_decl_rtl): Eliminate redundant clearing of\n\tDECL_RTL.  Calculate alias set for new MEMs.\n\t* rtl.def (REG): Add dummy operand.\n\t(MEM): Add extra operand to store the MEM_ALIAS_SET.\n\t* rtl.h (MEM_ALIAS_SET): New macro.\n\t(gen_rtx_MEM): Declare.\n\t* emit-rtl.c (gen_rtx_MEM): New function.\n\t* gengenrtl.c (sepcial_rtx): Make MEMs special.\n\t* alias.c (CHECK_ALIAS_SETS_FOR_CONSISTENCY): New macro.\n\t(DIFFERENT_ALIAS_SETS_P): Likewise.\n\t(canon_rtx): Propogate the alias set to the new MEM.\n\t(true_dependence): Check the alias sets.\n\t(anti_dependence): Likewise.\n\t(output_dependence): Likewise.\n\t* explow.c (stabilize): Progoate alias sets.\n\t* integrate.c (copy_rtx_and_substitute): Likewise.\n\t* final.c (alter_subreg): Make sure not to leave MEM_IN_STRUCT_P\n\tin an unpredictable state.  Propogate alias sets.\n\t* reload1.c (reload): Clear MEM_ALIAS_SET for new MEMs about which\n\twe have no alias information.\n\nFrom-SVN: r20719", "tree": {"sha": "af8828e1df0f3e051eb29c58c7d958cd177e474d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af8828e1df0f3e051eb29c58c7d958cd177e474d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41472af8777035219decfe1cb4742ce2b3ed8e38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41472af8777035219decfe1cb4742ce2b3ed8e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41472af8777035219decfe1cb4742ce2b3ed8e38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41472af8777035219decfe1cb4742ce2b3ed8e38/comments", "author": null, "committer": null, "parents": [{"sha": "9c606f693ddca43b89097388cfdeeffaead030df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c606f693ddca43b89097388cfdeeffaead030df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c606f693ddca43b89097388cfdeeffaead030df"}], "stats": {"total": 387, "additions": 369, "deletions": 18}, "files": [{"sha": "b9ada6d08513366c6814a57af848dfd70e27ebd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -1,3 +1,57 @@\n+Thu Jun 25 15:08:16 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* invoke.texi (-fstrict-aliasing): Document.\n+\t* rtl.texi (MEM_ALIAS_SET): Document.\n+\n+\t* flags.h (flag_strict_aliasing): Declare.\n+\t* toplev.c (flag_strict_aliasing): Define.\n+\t(f_options): Add -strict-aliasing.\n+\t(main): Set flag_strict_aliasing if -O2 or higher.\n+\n+\t* tree.h (tree_type): Add alias_set field.\n+\t(TYPE_ALIAS_SET): New macro.\n+\t(TYPE_ALIAS_SET_KNOWN_P): Likewise.\n+\t(get_alias_set): Declare.\n+\t* tree.c (lang_get_alias_set): Define.\n+\t(make_node): Initialize TYPE_ALIAS_SET.\n+\t(get_alias_set): New function.\n+\t* print-tree.c (print_node): Dump the alias set for a type.\n+\n+\t* c-tree.h (c_get_alias_set): Declare.\n+\t* c-common.c (c_get_alias_set): New function.\n+\t* c-decl.c (init_decl_processing): Set lang_get_alias_set.\n+\n+\t* expr.c (protect_from_queue): Propogage alias sets.\n+\t(expand_assignment): Calculate alias set for new MEMs.\n+\t(expand_expr): Likewise.\n+\t* function.c (put_var_into_stack): Likewise.\n+\t(put_reg_into_stack): Likewise.\n+\t(gen_mem_addressof): Likewise.\n+\t(assign_parms): Likewise.\n+\t* stmt.c (expand_decl): Likewise.\n+\t* varasm.c (make_decl_rtl): Eliminate redundant clearing of\n+\tDECL_RTL.  Calculate alias set for new MEMs. \n+\n+\t* rtl.def (REG): Add dummy operand.\n+\t(MEM): Add extra operand to store the MEM_ALIAS_SET.\n+\t* rtl.h (MEM_ALIAS_SET): New macro.\n+\t(gen_rtx_MEM): Declare.\n+\t* emit-rtl.c (gen_rtx_MEM): New function.\n+\t* gengenrtl.c (sepcial_rtx): Make MEMs special.\n+\n+\t* alias.c (CHECK_ALIAS_SETS_FOR_CONSISTENCY): New macro.\n+\t(DIFFERENT_ALIAS_SETS_P): Likewise.\n+\t(canon_rtx): Propogate the alias set to the new MEM.\n+\t(true_dependence): Check the alias sets.\n+\t(anti_dependence): Likewise.\n+\t(output_dependence): Likewise.\n+\t* explow.c (stabilize): Progoate alias sets.\n+\t* integrate.c (copy_rtx_and_substitute): Likewise.\n+\t* final.c (alter_subreg): Make sure not to leave MEM_IN_STRUCT_P\n+\tin an unpredictable state.  Propogate alias sets.\n+\t* reload1.c (reload): Clear MEM_ALIAS_SET for new MEMs about which\n+\twe have no alias information.\n+\t\n Thu Jun 25 16:59:18 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* except.h (CATCH_ALL_TYPE): Definition moved to eh-common.h."}, {"sha": "ab65bc4d8eacbd06045ce543ef1f64831b9ec117", "filename": "gcc/alias.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -42,6 +42,28 @@ static rtx find_base_value\t\tPROTO((rtx));\n \n #define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n \n+/* Perform a basic sanity check.  Namely, that there are\t\n+   no alias sets if we're not doing strict aliasing.  This helps     \n+   to catch bugs whereby someone uses PUT_CODE, but doesn't clear\n+   MEM_ALIAS_SET, or where a MEM is allocated in some way other\n+   than by the use of gen_rtx_MEM, and the MEM_ALIAS_SET is not\n+   cleared.  */\t\t\t\n+#ifdef ENABLE_CHECKING\t\n+#define CHECK_ALIAS_SETS_FOR_CONSISTENCY(MEM1, MEM2)\t\\\n+  (!flag_strict_aliasing\t\t\t\t\\\n+   && (MEM_ALIAS_SET (MEM1) || MEM_ALIAS_SET (MEM2))\t\\\n+   ? (abort (), 0) : 0)\n+#else \n+#define CHECK_ALIAS_SETS_FOR_CONSISTENCY(MEM1, MEM2) 0\n+#endif\n+\n+/* Returns nonzero if MEM1 and MEM2 do not alias because they are in\n+   different alias sets.  */\n+#define DIFFERENT_ALIAS_SETS_P(MEM1, MEM2)\t\t\\\n+  (CHECK_ALIAS_SETS_FOR_CONSISTENCY(MEM1, MEM2),\t\\\n+   MEM_ALIAS_SET (MEM1) && MEM_ALIAS_SET (MEM2)\t\t\\\n+   && MEM_ALIAS_SET (MEM1) != MEM_ALIAS_SET (MEM2))\n+\n /* Cap the number of passes we make over the insns propagating alias\n    information through set chains.\n \n@@ -372,6 +394,7 @@ canon_rtx (x)\n \t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n \t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n+\t  MEM_ALIAS_SET (new) = MEM_ALIAS_SET (x);\n \t  x = new;\n \t}\n     }\n@@ -874,6 +897,9 @@ true_dependence (mem, mem_mode, x, varies)\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n+  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n+    return 0;\n+\n   /* If X is an unchanging read, then it can't possibly conflict with any\n      non-unchanging store.  It may conflict with an unchanging write though,\n      because there may be a single store to this address to initialize it.\n@@ -947,6 +973,9 @@ anti_dependence (mem, x)\n   x = canon_rtx (x);\n   mem = canon_rtx (mem);\n \n+  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n+    return 0;\n+\n   x_addr = XEXP (x, 0);\n   mem_addr = XEXP (mem, 0);\n \n@@ -978,6 +1007,9 @@ output_dependence (mem, x)\n   x = canon_rtx (x);\n   mem = canon_rtx (mem);\n \n+  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n+    return 0;\n+\n   return (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n \t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n \t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)"}, {"sha": "245fedb97be344908cf20188f8d18c6bd3a29403", "filename": "gcc/c-common.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -2880,3 +2880,90 @@ c_build_type_variant (type, constp, volatilep)\n \t\t\t     TYPE_DOMAIN (type));\n   return build_type_variant (type, constp, volatilep);\n }\n+\n+/* Return the typed-based alias set for T, which may be an expression\n+   or a type.  */\n+\n+int\n+c_get_alias_set (t)\n+     tree t;\n+{\n+  static int next_set = 0;\n+  tree type;\n+\n+  if (t == error_mark_node)\n+    return 0;\n+\n+  type = (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+    ? t :  TREE_TYPE (t);\n+\n+  if (type == error_mark_node)\n+    return 0;\n+\n+  if (TYPE_ALIAS_SET_KNOWN_P (type))\n+    /* If we've already calculated the value, just return it.  */\n+    return TYPE_ALIAS_SET (type);\n+\n+  if (TREE_CODE (t) == BIT_FIELD_REF)\n+    /* Perhaps reads and writes to this piece of data alias fields\n+       neighboring the bitfield.  Perhaps that's impossible.  For now,\n+       let's just assume that bitfields can alias everything, which is\n+       the conservative assumption.  */\n+    return 0;\n+  if (TREE_CODE (t) == COMPONENT_REF\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)\n+    /* Permit type-punning when accessing a union, provided the\n+       access is directly through the union.  For example, this code does\n+       not permit taking the address of a union member and then\n+       storing through it.  Even the type-punning allowed here is a\n+       GCC extension, albeit a common and useful one; the C standard\n+       says that such accesses have implementation-defined behavior.  */ \n+    return 0;\n+  else if (TYPE_MAIN_VARIANT (type) != type)\n+    {\n+      /* The C standard specifically allows aliasing between\n+\t cv-qualified variants of types.  */\n+      TYPE_ALIAS_SET (type) = c_get_alias_set (TYPE_MAIN_VARIANT (type));\n+      return TYPE_ALIAS_SET (type);\n+    }\n+  else if (TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      tree signed_variant;\n+\n+      /* The C standard specifically allows aliasing between signed and\n+\t unsigned variants of the same type.  We treat the signed\n+\t variant as canonical.  */\n+      signed_variant = signed_type (type);\n+\n+      if (signed_variant != type)\n+\t{\n+\t  TYPE_ALIAS_SET (type) = c_get_alias_set (signed_variant);\n+\t  return TYPE_ALIAS_SET (type);\n+\t}\n+      else if (signed_variant == signed_char_type_node)\n+\t/* The C standard guarantess that any object may be accessed\n+\t   via an lvalue that has character type.  We don't have to\n+\t   check for unsigned_char_type_node or char_type_node because\n+\t   we are specifically looking at the signed variant.  */\n+\t{\n+\t  TYPE_ALIAS_SET (type) = 0;\n+\t  return TYPE_ALIAS_SET (type);\n+\t}\n+    }\n+  else if (TREE_CODE (type) == RECORD_TYPE\n+\t   || TREE_CODE (type) == UNION_TYPE)\n+    {\n+      /* If TYPE is a struct or union type then we're reading or\n+\t writing an entire struct.  Thus, we don't know anything about\n+\t aliasing.  (In theory, such an access can only alias objects\n+\t whose type is the same as one of the fields, recursively, but\n+\t we don't yet make any use of that information.)  */\n+      TYPE_ALIAS_SET (type) = 0;\n+      return TYPE_ALIAS_SET (type);\n+    }\n+\n+  /* TYPE is something we haven't seen before.  Put it in a new alias\n+     set.  */\n+  TYPE_ALIAS_SET (type) = ++next_set;\n+  return TYPE_ALIAS_SET (type);\n+}"}, {"sha": "15eb740b976002264e5924d3770198a6e1ec83d1", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -3513,6 +3513,8 @@ init_decl_processing ()\n   init_iterators ();\n \n   incomplete_decl_finalize_hook = finish_incomplete_decl;\n+\n+  lang_get_alias_set = &c_get_alias_set;\n }\n \n /* Return a definition for a builtin function named NAME and whose data type"}, {"sha": "3a9f4f83b7866db97e492a7871d443fdea224cde", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -164,6 +164,7 @@ extern void declare_function_name               PROTO((void));\n extern void decl_attributes                     PROTO((tree, tree, tree));\n extern void init_function_format_info\t\tPROTO((void));\n extern void check_function_format\t\tPROTO((tree, tree, tree));\n+extern int c_get_alias_set                      PROTO((tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error                     PROTO((enum tree_code));"}, {"sha": "8f1b50188bf8d06c53e27e437efcf08089f28f30", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -301,6 +301,20 @@ gen_rtx_REG (mode, regno)\n   return gen_rtx_raw_REG (mode, regno);\n }\n \n+rtx\n+gen_rtx_MEM (mode, addr)\n+     enum machine_mode mode;\n+     rtx addr;\n+{\n+  rtx rt = gen_rtx_raw_MEM (mode, addr);\n+\n+  /* This field is not cleared by the mere allocation of the rtx, so\n+     we clear it here.  */\n+  MEM_ALIAS_SET (rt) = 0;\n+\n+  return rt;\n+}\n+\n /* rtx gen_rtx (code, mode, [element1, ..., elementn])\n **\n **\t    This routine generates an RTX of the size specified by"}, {"sha": "cd50563be526bd72213e101bc0b50c339a9f1da9", "filename": "gcc/explow.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -592,6 +592,11 @@ stabilize (x)\n       MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (x) || GET_CODE (addr) == PLUS;\n       RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (x);\n       MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (x);\n+\n+      /* Since the new MEM is just like the old X, it can alias only\n+\t the things that X could.  */\n+      MEM_ALIAS_SET (mem) = MEM_ALIAS_SET (x);\n+\n       return mem;\n     }\n   return x;"}, {"sha": "bc19068afaa88e007e21098ea152bc19b5cc8200", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -415,6 +415,7 @@ protect_from_queue (x, modify)\n \t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n \t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n+\t  MEM_ALIAS_SET (new) = MEM_ALIAS_SET (x);\n \n \t  if (QUEUED_INSN (y))\n \t    {\n@@ -3063,7 +3064,11 @@ expand_assignment (to, from, want_value, suggest_reg)\n      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */\n \n   if (to_rtx == 0)\n-    to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n+    {\n+      to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n+      if (GET_CODE (to_rtx) == MEM)\n+\tMEM_ALIAS_SET (to_rtx) = get_alias_set (to);\n+    }\n \n   /* Don't move directly into a return register.  */\n   if (TREE_CODE (to) == RESULT_DECL && GET_CODE (to_rtx) == REG)\n@@ -5719,6 +5724,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t&& AGGREGATE_TYPE_P (TREE_TYPE (exp2))))\n \t  MEM_IN_STRUCT_P (temp) = 1;\n \tMEM_VOLATILE_P (temp) = TREE_THIS_VOLATILE (exp) | flag_volatile;\n+\tMEM_ALIAS_SET (temp) = get_alias_set (exp);\n \n \t/* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY\n \t   here, because, in C and C++, the fact that a location is accessed\n@@ -6094,6 +6100,10 @@ expand_expr (exp, target, tmode, modifier)\n \t  op0 = change_address (op0, mode1,\n \t\t\t\tplus_constant (XEXP (op0, 0),\n \t\t\t\t\t       (bitpos / BITS_PER_UNIT)));\n+\n+\tif (GET_CODE (op0) == MEM)\n+\t  MEM_ALIAS_SET (op0) = get_alias_set (exp);\n+\n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n \t  mark_reg_pointer (XEXP (op0, 0), alignment);\n "}, {"sha": "794bedf70b1dc78e64b6140384413850cea4e391", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -3020,6 +3020,8 @@ alter_subreg (x)\n \t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (y))));\n       PUT_CODE (x, MEM);\n       MEM_VOLATILE_P (x) = MEM_VOLATILE_P (y);\n+      MEM_IN_STRUCT_P (x) = MEM_IN_STRUCT_P (y);\n+      MEM_ALIAS_SET (x) = MEM_ALIAS_SET (y);\n       XEXP (x, 0) = plus_constant (XEXP (y, 0), offset);\n     }\n "}, {"sha": "2b62325bb2960ae1e05f0aa38dc80984d86d3ede", "filename": "gcc/flags.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -432,6 +432,12 @@ extern int flag_pack_struct;\n    The value is ignored if flag_alias_check is 0.  */\n extern int flag_argument_noalias;\n \n+/* Nonzero if we should do (language-dependent) alias analysis.\n+   Typically, this analysis will assume that expressions of certain\n+   types do not alias expressions of certain other types.  Only used\n+   if alias analysis (in general) is enabled.  */\n+extern int flag_strict_aliasing;\n+\n /* Emit code to check for stack overflow; also may cause large objects\n    to be allocated dynamically.  */\n extern int flag_stack_check;"}, {"sha": "f3d33d0cc399b6d9bf1e46e39b039744c230f949", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -1466,6 +1466,7 @@ put_var_into_stack (decl)\n       /* Change the CONCAT into a combined MEM for both parts.  */\n       PUT_CODE (reg, MEM);\n       MEM_VOLATILE_P (reg) = MEM_VOLATILE_P (XEXP (reg, 0));\n+      MEM_ALIAS_SET (reg) = get_alias_set (decl);\n \n       /* The two parts are in memory order already.\n \t Use the lower parts address as ours.  */\n@@ -1538,6 +1539,7 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n      case it was set for other reasons.  For instance, it is set for\n      __builtin_va_alist.  */\n   MEM_IN_STRUCT_P (reg) = AGGREGATE_TYPE_P (type) | MEM_IN_STRUCT_P (new);\n+  MEM_ALIAS_SET (reg) = get_alias_set (type);\n \n   /* Now make sure that all refs to the variable, previously made\n      when it was a register, are fixed up to be valid again.  */\n@@ -2735,6 +2737,7 @@ gen_mem_addressof (reg, decl)\n   PUT_MODE (reg, DECL_MODE (decl));\n   MEM_VOLATILE_P (reg) = TREE_SIDE_EFFECTS (decl);\n   MEM_IN_STRUCT_P (reg) = AGGREGATE_TYPE_P (type);\n+  MEM_ALIAS_SET (reg) = get_alias_set (decl);\n \n   if (TREE_USED (decl) || DECL_INITIAL (decl) != 0)\n     fixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type));\n@@ -3908,6 +3911,7 @@ assign_parms (fndecl, second_time)\n \t     is readonly.  */\n \t  MEM_IN_STRUCT_P (stack_parm) = aggregate;\n \t  RTX_UNCHANGING_P (stack_parm) = TREE_READONLY (parm);\n+\t  MEM_ALIAS_SET (stack_parm) = get_alias_set (parm);\n \t}\n \n       /* If this parameter was passed both in registers and in the stack,"}, {"sha": "ade07ff4b6c63285831f47150254f467484b6f9b", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -129,7 +129,8 @@ special_rtx (idx)\n      int idx;\n {\n   return (strcmp (defs[idx].enumname, \"CONST_INT\") == 0\n-\t  || strcmp (defs[idx].enumname, \"REG\") == 0);\n+\t  || strcmp (defs[idx].enumname, \"REG\") == 0\n+\t  || strcmp (defs[idx].enumname, \"MEM\") == 0);\n }\n \n static void"}, {"sha": "38a900a9768351ecbf37d7f9d38ba6f60768b929", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -2688,6 +2688,7 @@ copy_rtx_and_substitute (orig, map)\n       XEXP (copy, 0) = copy_rtx_and_substitute (XEXP (orig, 0), map);\n       MEM_IN_STRUCT_P (copy) = MEM_IN_STRUCT_P (orig);\n       MEM_VOLATILE_P (copy) = MEM_VOLATILE_P (orig);\n+      MEM_ALIAS_SET (copy) = MEM_ALIAS_SET (orig);\n \n       /* If doing function inlining, this MEM might not be const in the\n \t function that it is being inlined into, and thus may not be"}, {"sha": "3bc197f9b667eb9ae5190f987f5a38d2d658515a", "filename": "gcc/invoke.texi", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -156,7 +156,7 @@ in the following sections.\n -frerun-cse-after-loop  -frerun-loop-opt -fschedule-insns\n -fschedule-insns2  -fstrength-reduce  -fthread-jumps\n -funroll-all-loops  -funroll-loops\n--fmove-all-movables  -freduce-all-givs\n+-fmove-all-movables  -freduce-all-givs -fstrict-aliasing\n -O  -O0  -O1  -O2  -O3 -Os\n @end smallexample\n \n@@ -2419,6 +2419,57 @@ Some machines only support 2 operands per instruction.  On such\n machines, GNU CC might have to do extra copies.  The @samp{-fregmove}\n option overrides the default for the machine to do the copy before\n register allocation.\n+\n+@item -fstrict-aliasing\n+Allows the compiler to assume the strictest aliasing rules applicable to\n+the language being compiled.  For C (and C++), this activates\n+optimizations based on the type of expressions.  In particular, an\n+object of one type is assumed never to reside at the same address as an\n+object of a different type, unless the types are almost the same.  For\n+example, an @code{unsigned int} can alias an @code{int}, but not a\n+@code{void*} or a @code{double}.  A character type may alias any other\n+type.  \n+\n+Pay special attention to code like this:\n+@example\n+union a_union @{ \n+  int i;\n+  double d;\n+@};\n+\n+int f() @{\n+  a_union t;\n+  t.d = 3.0;\n+  return t.i;\n+@}\n+@end example\n+The practice of reading from a different union member than the one most\n+recently written to (called ``type-punning'') is common.  Even with\n+@samp{-fstrict-aliasing}, type-punning is allowed, provided the memory\n+is accessed through the union type.  So, the code above will work as\n+expected.  However, this code might not:\n+@example\n+int f() @{ \n+  a_union t;\n+  int* ip;\n+  t.d = 3.0;\n+  ip = &t.i;\n+  return *ip;\n+@}\n+@end example\n+\n+This option is not enabled by default at any optimization level because\n+it is new and has yet to be subjected to thorough testing.  You may\n+of course enable it manually with @samp{-fstrict-aliasing}.\n+\n+@ifset INTERNALS\n+Every language that wishes to perform language-specific alias analysis\n+should define a function that computes, given an @code{tree}\n+node, an alias set for the node.  Nodes in different alias sets are not\n+allowed to alias.  For an example, see the C front-end function\n+@code{c_get_alias_set}.\n+@end ifset\n+\n @end table\n \n @node Preprocessor Options"}, {"sha": "6163b1ff91cc3ffc9a36a23ebef0e1bd5ec5271a", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -479,6 +479,7 @@ print_node (file, prefix, node, indent)\n \n       fprintf (file, \" align %d\", TYPE_ALIGN (node));\n       fprintf (file, \" symtab %d\", TYPE_SYMTAB_ADDRESS (node));\n+      fprintf (file, \" alias set %d\", TYPE_ALIAS_SET (node));\n \n       print_node (file, \"attributes\", TYPE_ATTRIBUTES (node), indent + 4);\n "}, {"sha": "9601691f9f9f4fa384f441ac1e499098397139c7", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -2095,6 +2095,9 @@ reload (first, global, dumpfile)\n \t      XEXP (reg, 0) = addr;\n \t      REG_USERVAR_P (reg) = 0;\n \t      MEM_IN_STRUCT_P (reg) = in_struct;\n+\t      /* We have no alias information about this newly created\n+\t\t MEM.  */\n+\t      MEM_ALIAS_SET (reg) = 0;\n \t      PUT_CODE (reg, MEM);\n \t    }\n \t  else if (reg_equiv_mem[i])"}, {"sha": "a00d3f1d7c57adcd9bfd5616f3aeba9fea71e6e1", "filename": "gcc/rtl.def", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -537,10 +537,16 @@ DEF_RTL_EXPR(CONST, \"const\", \"e\", 'o')\n    by a SET whose first operand is (PC).  */\n DEF_RTL_EXPR(PC, \"pc\", \"\", 'o')\n \n-/* A register.  The \"operand\" is the register number, accessed\n-   with the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n-   than a hardware register is being referred to.  */\n-DEF_RTL_EXPR(REG, \"reg\", \"i\", 'o')\n+/* A register.  The \"operand\" is the register number, accessed with\n+   the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n+   than a hardware register is being referred to.  The second operand\n+   doesn't really exist.  Unfortunately, however, the compiler\n+   implicitly assumes that a REG can be transformed in place into a\n+   MEM, and therefore that a REG is at least as big as a MEM.  To\n+   avoid this memory overhead, which is likely to be substantial,\n+   search for uses of PUT_CODE that turn REGs into MEMs, and fix them\n+   somehow.  Then, the trailing `0' can be removed here.  */\n+DEF_RTL_EXPR(REG, \"reg\", \"i0\", 'o')\n \n /* A scratch register.  This represents a register used only within a\n    single insn.  It will be turned into a REG during register allocation\n@@ -578,9 +584,11 @@ DEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", 'x')\n    in DECL_RTLs and during RTL generation, but not in the insn chain.  */\n DEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", 'o')\n \n-/* A memory location; operand is the address.\n-   Can be nested inside a VOLATILE.  */\n-DEF_RTL_EXPR(MEM, \"mem\", \"e\", 'o')\n+/* A memory location; operand is the address.  Can be nested inside a\n+   VOLATILE.  The second operand is the alias set to which this MEM\n+   belongs.  We use `0' instead of `i' for this field so that the\n+   field need not be specified in machine descriptions.  */\n+DEF_RTL_EXPR(MEM, \"mem\", \"e0\", 'o')\n \n /* Reference to an assembler label in the code for this function.\n    The operand is a CODE_LABEL found in the insn chain."}, {"sha": "af85d823738eaa89cff28b6a696be2d3b1cc7629", "filename": "gcc/rtl.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -561,6 +561,17 @@ extern char *note_insn_name[];\n /* For a MEM rtx, 1 if it refers to a field of an aggregate.  */\n #define MEM_IN_STRUCT_P(RTX) ((RTX)->in_struct)\n \n+/* For a MEM rtx, the alias set.  If 0, this MEM is not in any alias\n+   set, and may alias anything.  Otherwise, the MEM can only alias\n+   MEMs in the same alias set.  This value is set in a\n+   language-dependent manner in the front-end, and should not be\n+   altered in the back-end.  These set numbers are tested for zero,\n+   and compared for equality; they have no other significance.  In\n+   some front-ends, these numbers may correspond in some way to types,\n+   or other language-level entities, but they need not, and the\n+   back-end makes no such assumptions.  */\n+#define MEM_ALIAS_SET(RTX) (XINT (RTX, 1))\n+\n /* For a LABEL_REF, 1 means that this reference is to a label outside the\n    loop containing the reference.  */\n #define LABEL_OUTSIDE_LOOP_P(RTX) ((RTX)->in_struct)\n@@ -1057,11 +1068,13 @@ extern rtx static_chain_incoming_rtx;\n #include \"genrtl.h\"\n #endif\n \n-/* There are two RTL codes that require special attention; the generation\n-   functions included above do the raw handling.  */\n+/* There are some RTL codes that require special attention; the\n+   generation functions included above do the raw handling.  If you\n+   add to this list, modify special_rtx in gengenrtl.c as well.  */\n \n extern rtx gen_rtx_CONST_INT PROTO((enum machine_mode, HOST_WIDE_INT));\n extern rtx gen_rtx_REG PROTO((enum machine_mode, int));\n+extern rtx gen_rtx_MEM PROTO((enum machine_mode, rtx));\n \n /* We need the cast here to ensure that we get the same result both with\n    and without prototypes.  */"}, {"sha": "4d5139956dc9b1870931d4a42beb2d39ec3dcaed", "filename": "gcc/rtl.texi", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -287,9 +287,9 @@ to access them.\n @section Flags in an RTL Expression\n @cindex flags in RTL expression\n \n-RTL expressions contain several flags (one-bit bitfields) that are used\n-in certain types of expression.  Most often they are accessed with the\n-following macros:\n+RTL expressions contain several flags (one-bit bitfields) and other\n+values that are used in certain types of expression.  Most often they\n+are accessed with the following macros:\n \n @table @code\n @findex MEM_VOLATILE_P\n@@ -310,6 +310,15 @@ structure, union or array, or to a component of one.  Zero for\n references to a scalar variable or through a pointer to a scalar.\n Stored in the @code{in_struct} field and printed as @samp{/s}.\n \n+@findex MEM_ALIAS_SET\n+@item MEM_ALIAS_SET (@var{x})\n+In @code{mem} expressions, the alias set to which @var{x} belongs.  If\n+zero, @var{x} is not in any alias set, and may alias anything.  If\n+nonzero, @var{x} may only alias objects in the same alias set.  This\n+value is set (in a language-specific manner) by the front-end.  This\n+field is not a bit-field; it is in an integer, found as the second\n+argument to the @code{mem}.\n+\n @findex REG_LOOP_TEST_P\n @cindex @code{reg} and @samp{/s}\n @cindex @code{in_struct}, in @code{reg}"}, {"sha": "43cf7f82ec264e75e5a6dc7d500f721e244da0d5", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -3178,6 +3178,8 @@ expand_decl (decl)\n       if (flag_float_store && TREE_CODE (type) == REAL_TYPE)\n \tMEM_VOLATILE_P (DECL_RTL (decl)) = 1;\n #endif\n+\n+      MEM_ALIAS_SET (DECL_RTL (decl)) = get_alias_set (decl);\n     }\n   else\n     /* Dynamic-size object: must push space on the stack.  */"}, {"sha": "d51dc60eb95ff4e3a20cda616028253254684789", "filename": "gcc/toplev.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -711,6 +711,12 @@ int flag_regmove = 0;\n    This defaults to 0 for C.  */\n int flag_argument_noalias = 0;\n \n+/* Nonzero if we should do (language-dependent) alias analysis.\n+   Typically, this analysis will assume that expressions of certain\n+   types do not alias expressions of certain other types.  Only used\n+   if alias analysis (in general) is enabled.  */\n+int flag_strict_aliasing = 0;\n+\n /* Table of language-independent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE\n@@ -782,6 +788,7 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"argument-alias\", &flag_argument_noalias, 0},\n   {\"argument-noalias\", &flag_argument_noalias, 1},\n   {\"argument-noalias-global\", &flag_argument_noalias, 2},\n+  {\"strict-aliasing\", &flag_strict_aliasing, 1},\n   {\"check-memory-usage\", &flag_check_memory_usage, 1},\n   {\"prefix-function-name\", &flag_prefix_function_name, 1}\n };\n@@ -3839,6 +3846,9 @@ main (argc, argv, envp)\n       flag_schedule_insns_after_reload = 1;\n #endif\n       flag_regmove = 1;\n+      /* We don't set flag_strict_aliasing here because we're still\n+\t testing the functionality.  After it has been tested, it\n+\t should be turned on here.  */\n     }\n \n   if (optimize >= 3)"}, {"sha": "de5a1791af1e7d16ff515a63c12d8b4611032941", "filename": "gcc/tree.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -261,6 +261,10 @@ static int next_decl_uid;\n /* Unique id for next type created.  */\n static int next_type_uid = 1;\n \n+/* The language-specific function for alias analysis.  If NULL, the\n+   language does not do any special alias analysis.  */\n+int (*lang_get_alias_set) PROTO((tree));\n+\n /* Here is how primitive or already-canonicalized types' hash\n    codes are made.  */\n #define TYPE_HASH(TYPE) ((unsigned long) (TYPE) & 0777777)\n@@ -1112,6 +1116,9 @@ make_node (code)\n #ifdef SET_DEFAULT_TYPE_ATTRIBUTES\n       SET_DEFAULT_TYPE_ATTRIBUTES (t);\n #endif\n+      /* Note that we have not yet computed the alias set for this\n+\t type.  */\n+      TYPE_ALIAS_SET (t) = -1;\n       break;\n \n     case 'c':\n@@ -5019,3 +5026,17 @@ expr_check (node, ignored, file, line, nofatal)\n   return node;\n }\n #endif\n+\n+/* Return the alias set for T, which may be either a type or an\n+   expression.  */\n+\n+int get_alias_set (t)\n+     tree t;\n+{\n+  if (!flag_strict_aliasing || !lang_get_alias_set)\n+    /* If we're not doing any lanaguage-specific alias analysis, just\n+       assume everything aliases everything else.  */\n+    return 0;\n+  else\n+    return (*lang_get_alias_set) (t);\n+}"}, {"sha": "be62730706b05db3b954b4363cf547a1a4ffa617", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -776,6 +776,18 @@ struct tree_block\n #define TYPE_OBSTACK(NODE) (TYPE_CHECK (NODE)->type.obstack)\n #define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n \n+/* The (language-specific) typed-based alias set for this type.\n+   Objects whose TYPE_ALIAS_SETs are different cannot alias each\n+   other.  If the TYPE_ALIAS_SET is -1, no alias set has yet been\n+   assigned to this type.  If the TYPE_ALIAS_SET is 0, objects of this\n+   type can alias objects of any type.  */\n+#define TYPE_ALIAS_SET(NODE) (TYPE_CHECK (NODE)->type.alias_set)\n+\n+/* Nonzero iff the typed-based alias set for this type has been\n+   calculated.  */\n+#define TYPE_ALIAS_SET_KNOWN_P(NODE) \\\n+  (TYPE_CHECK (NODE)->type.alias_set != -1)\n+\n /* A TREE_LIST of IDENTIFIER nodes of the attributes that apply\n    to this type.  */\n #define TYPE_ATTRIBUTES(NODE) (TYPE_CHECK (NODE)->type.attributes)\n@@ -870,6 +882,7 @@ struct tree_type\n   union tree_node *noncopied_parts;\n   union tree_node *context;\n   struct obstack *obstack;\n+  int alias_set;\n   /* Points to a structure whose details depend on the language in use.  */\n   struct lang_type *lang_specific;\n };\n@@ -1811,6 +1824,8 @@ extern tree get_file_function_name\t\tPROTO((int));\n extern tree get_set_constructor_bits\t\tPROTO((tree, char *, int));\n extern tree get_set_constructor_bytes\t\tPROTO((tree,\n \t\t\t\t\t\t       unsigned char *, int));\n+extern int get_alias_set                        PROTO((tree));\n+extern int (*lang_get_alias_set)                PROTO((tree));\n \f\n /* In stmt.c */\n "}, {"sha": "4ba0e08d187b80a428af63df5fbe4753fd56fd6d", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41472af8777035219decfe1cb4742ce2b3ed8e38/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=41472af8777035219decfe1cb4742ce2b3ed8e38", "patch": "@@ -662,8 +662,6 @@ make_decl_rtl (decl, asmspec, top_level)\n      same DECL node.  Don't discard the RTL already made.  */\n   if (DECL_RTL (decl) == 0)\n     {\n-      DECL_RTL (decl) = 0;\n-\n       /* First detect errors in declaring global registers.  */\n       if (TREE_CODE (decl) != FUNCTION_DECL\n \t  && DECL_REGISTER (decl) && reg_number == -1)\n@@ -767,7 +765,8 @@ make_decl_rtl (decl, asmspec, top_level)\n \n \t  DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl),\n \t\t\t\t\t gen_rtx_SYMBOL_REF (Pmode, name));\n-\n+\t  MEM_ALIAS_SET (DECL_RTL (decl)) = get_alias_set (decl);\n+\t    \n \t  /* If this variable is to be treated as volatile, show its\n \t     tree node has side effects.  If it has side effects, either\n \t     because of this test or from TREE_THIS_VOLATILE also"}]}