{"sha": "6ddb62884fb6c35cabf02f665cd29376746e983e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRkYjYyODg0ZmI2YzM1Y2FiZjAyZjY2NWNkMjkzNzY3NDZlOTgzZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-10T06:42:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-10T06:42:08Z"}, "message": "compiler: Use backend interface for slice info.\n\nFrom-SVN: r206509", "tree": {"sha": "c6fc9b9ae5c829e02e94e913745e0def82608611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6fc9b9ae5c829e02e94e913745e0def82608611"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ddb62884fb6c35cabf02f665cd29376746e983e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ddb62884fb6c35cabf02f665cd29376746e983e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ddb62884fb6c35cabf02f665cd29376746e983e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ddb62884fb6c35cabf02f665cd29376746e983e/comments", "author": null, "committer": null, "parents": [{"sha": "7f003d8337f2901787e9b3e77347fab06c315a6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f003d8337f2901787e9b3e77347fab06c315a6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f003d8337f2901787e9b3e77347fab06c315a6c"}], "stats": {"total": 460, "additions": 322, "deletions": 138}, "files": [{"sha": "6f2f24367aaad6dc6fc08ca3b7dd4b22df184fea", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 253, "deletions": 73, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=6ddb62884fb6c35cabf02f665cd29376746e983e", "patch": "@@ -3060,6 +3060,9 @@ class Type_conversion_expression : public Expression\n   Expression*\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   bool\n   do_is_constant() const;\n \n@@ -3203,6 +3206,25 @@ Type_conversion_expression::do_lower(Gogo*, Named_object*,\n   return this;\n }\n \n+// Flatten a type conversion by using a temporary variable for the slice\n+// in slice to string conversions.\n+\n+Expression*\n+Type_conversion_expression::do_flatten(Gogo*, Named_object*,\n+                                       Statement_inserter* inserter)\n+{\n+  if (this->type()->is_string_type()\n+      && this->expr_->type()->is_slice_type()\n+      && !this->expr_->is_variable())\n+    {\n+      Temporary_statement* temp =\n+          Statement::make_temporary(NULL, this->expr_, this->location());\n+      inserter->insert(temp);\n+      this->expr_ = Expression::make_temporary_reference(temp, this->location());\n+    }\n+  return this;\n+}\n+\n // Return whether a type conversion is a constant.\n \n bool\n@@ -3361,47 +3383,24 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n     }\n   else if (type->is_string_type() && expr_type->is_slice_type())\n     {\n-      if (!DECL_P(expr_tree))\n-\texpr_tree = save_expr(expr_tree);\n-\n-      Type* int_type = Type::lookup_integer_type(\"int\");\n-      tree int_type_tree = type_to_tree(int_type->get_backend(gogo));\n-\n+      Location location = this->location();\n       Array_type* a = expr_type->array_type();\n       Type* e = a->element_type()->forwarded();\n       go_assert(e->integer_type() != NULL);\n-      tree valptr = fold_convert(const_ptr_type_node,\n-\t\t\t\t a->value_pointer_tree(gogo, expr_tree));\n-      tree len = a->length_tree(gogo, expr_tree);\n-      len = fold_convert_loc(this->location().gcc_location(), int_type_tree,\n-                             len);\n+      go_assert(this->expr_->is_variable());\n+\n+      Runtime::Function code;\n       if (e->integer_type()->is_byte())\n-\t{\n-\t  static tree byte_array_to_string_fndecl;\n-\t  ret = Gogo::call_builtin(&byte_array_to_string_fndecl,\n-\t\t\t\t   this->location(),\n-\t\t\t\t   \"__go_byte_array_to_string\",\n-\t\t\t\t   2,\n-\t\t\t\t   type_tree,\n-\t\t\t\t   const_ptr_type_node,\n-\t\t\t\t   valptr,\n-\t\t\t\t   int_type_tree,\n-\t\t\t\t   len);\n-\t}\n+        code = Runtime::BYTE_ARRAY_TO_STRING;\n       else\n-\t{\n-\t  go_assert(e->integer_type()->is_rune());\n-\t  static tree int_array_to_string_fndecl;\n-\t  ret = Gogo::call_builtin(&int_array_to_string_fndecl,\n-\t\t\t\t   this->location(),\n-\t\t\t\t   \"__go_int_array_to_string\",\n-\t\t\t\t   2,\n-\t\t\t\t   type_tree,\n-\t\t\t\t   const_ptr_type_node,\n-\t\t\t\t   valptr,\n-\t\t\t\t   int_type_tree,\n-\t\t\t\t   len);\n-\t}\n+        {\n+          go_assert(e->integer_type()->is_rune());\n+          code = Runtime::INT_ARRAY_TO_STRING;\n+        }\n+      Expression* valptr = a->get_value_pointer(gogo, this->expr_);\n+      Expression* len = a->get_length(gogo, this->expr_);\n+      Expression* a2s_expr = Runtime::make_call(code, location, 2, valptr, len);\n+      ret = a2s_expr->get_tree(context);\n     }\n   else if (type->is_slice_type() && expr_type->is_string_type())\n     {\n@@ -6595,6 +6594,7 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n     {\n       std::swap(left_type, right_type);\n       std::swap(left_tree, right_tree);\n+      std::swap(left_expr, right_expr);\n     }\n \n   if (right_type->is_nil_type())\n@@ -6603,7 +6603,8 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n \t  && left_type->array_type()->length() == NULL)\n \t{\n \t  Array_type* at = left_type->array_type();\n-\t  left_tree = at->value_pointer_tree(context->gogo(), left_tree);\n+          left_expr = at->get_value_pointer(context->gogo(), left_expr);\n+          left_tree = left_expr->get_tree(context);\n \t  right_tree = fold_convert(TREE_TYPE(left_tree), null_pointer_node);\n \t}\n       else if (left_type->interface_type() != NULL)\n@@ -7037,6 +7038,9 @@ class Builtin_call_expression : public Call_expression\n   Expression*\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   bool\n   do_is_constant() const;\n \n@@ -7367,6 +7371,36 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n   return this;\n }\n \n+// Flatten a builtin call expression.  This turns the arguments of copy and\n+// append into temporary expressions.\n+\n+Expression*\n+Builtin_call_expression::do_flatten(Gogo*, Named_object*,\n+                                    Statement_inserter* inserter)\n+{\n+  if (this->code_ == BUILTIN_APPEND\n+      || this->code_ == BUILTIN_COPY)\n+    {\n+      Location loc = this->location();\n+      Type* at = this->args()->front()->type();\n+      for (Expression_list::iterator pa = this->args()->begin();\n+           pa != this->args()->end();\n+           ++pa)\n+        {\n+          if ((*pa)->is_nil_expression())\n+            *pa = Expression::make_slice_composite_literal(at, NULL, loc);\n+          if (!(*pa)->is_variable())\n+            {\n+              Temporary_statement* temp =\n+                  Statement::make_temporary(NULL, *pa, loc);\n+              inserter->insert(temp);\n+              *pa = Expression::make_temporary_reference(temp, loc);\n+            }\n+        }\n+    }\n+  return this;\n+}\n+\n // Lower a make expression.\n \n Expression*\n@@ -8503,7 +8537,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t    return error_mark_node;\n \t\t  }\n \t\tthis->seen_ = true;\n-\t\tval_tree = arg_type->array_type()->length_tree(gogo, arg_tree);\n+\t\tExpression* len = arg_type->array_type()->get_length(gogo, arg);\n+\t\tval_tree = len->get_tree(context);\n \t\tthis->seen_ = false;\n \t      }\n \t    else if (arg_type->map_type() != NULL)\n@@ -8543,8 +8578,9 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t    return error_mark_node;\n \t\t  }\n \t\tthis->seen_ = true;\n-\t\tval_tree = arg_type->array_type()->capacity_tree(gogo,\n-\t\t\t\t\t\t\t\t arg_tree);\n+\t\tExpression* cap =\n+\t\t    arg_type->array_type()->get_capacity(gogo, arg);\n+\t\tval_tree = cap->get_tree(context);\n \t\tthis->seen_ = false;\n \t      }\n \t    else if (arg_type->channel_type() != NULL)\n@@ -8848,9 +8884,11 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \n \tType* arg1_type = arg1->type();\n \tArray_type* at = arg1_type->array_type();\n-\targ1_tree = save_expr(arg1_tree);\n-\ttree arg1_val = at->value_pointer_tree(gogo, arg1_tree);\n-\ttree arg1_len = at->length_tree(gogo, arg1_tree);\n+\tgo_assert(arg1->is_variable());\n+\tExpression* arg1_valptr = at->get_value_pointer(gogo, arg1);\n+\tExpression* arg1_len_expr = at->get_length(gogo, arg1);\n+\ttree arg1_val = arg1_valptr->get_tree(context);\n+\ttree arg1_len = arg1_len_expr->get_tree(context);\n \tif (arg1_val == error_mark_node || arg1_len == error_mark_node)\n \t  return error_mark_node;\n \n@@ -8860,9 +8898,11 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tif (arg2_type->is_slice_type())\n \t  {\n \t    at = arg2_type->array_type();\n-\t    arg2_tree = save_expr(arg2_tree);\n-\t    arg2_val = at->value_pointer_tree(gogo, arg2_tree);\n-\t    arg2_len = at->length_tree(gogo, arg2_tree);\n+\t    go_assert(arg2->is_variable());\n+\t    Expression* arg2_valptr = at->get_value_pointer(gogo, arg2);\n+\t    Expression* arg2_len_expr = at->get_length(gogo, arg2);\n+\t    arg2_val = arg2_valptr->get_tree(context);\n+\t    arg2_len = arg2_len_expr->get_tree(context);\n \t  }\n \telse\n \t  {\n@@ -8950,23 +8990,15 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t  }\n \telse\n \t  {\n-\t    arg2_tree = Expression::convert_for_assignment(context, at,\n-\t\t\t\t\t\t\t   arg2->type(),\n-\t\t\t\t\t\t\t   arg2_tree,\n-\t\t\t\t\t\t\t   location);\n-\t    if (arg2_tree == error_mark_node)\n+\t    go_assert(arg2->is_variable());\n+\t    arg2_val =\n+\t\tat->get_value_pointer(gogo, arg2)->get_tree(context);\n+\t    arg2_len = at->get_length(gogo, arg2)->get_tree(context);\n+\t    Btype* element_btype = element_type->get_backend(gogo);\n+\t    tree element_type_tree = type_to_tree(element_btype);\n+\t    if (element_type_tree == error_mark_node)\n \t      return error_mark_node;\n-\n-\t    arg2_tree = save_expr(arg2_tree);\n-\n-\t     arg2_val = at->value_pointer_tree(gogo, arg2_tree);\n-\t     arg2_len = at->length_tree(gogo, arg2_tree);\n-\n-\t     Btype* element_btype = element_type->get_backend(gogo);\n-\t     tree element_type_tree = type_to_tree(element_btype);\n-\t     if (element_type_tree == error_mark_node)\n-\t       return error_mark_node;\n-\t     element_size = TYPE_SIZE_UNIT(element_type_tree);\n+\t    element_size = TYPE_SIZE_UNIT(element_type_tree);\n \t  }\n \n \targ2_val = fold_convert_loc(location.gcc_location(), ptr_type_node,\n@@ -10370,6 +10402,9 @@ class Array_index_expression : public Expression\n   void\n   do_check_types(Gogo*);\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   Expression*\n   do_copy()\n   {\n@@ -10611,6 +10646,22 @@ Array_index_expression::do_check_types(Gogo*)\n     }\n }\n \n+// Flatten array indexing by using a temporary variable for slices.\n+\n+Expression*\n+Array_index_expression::do_flatten(Gogo*, Named_object*,\n+                                   Statement_inserter* inserter)\n+{\n+  Location loc = this->location();\n+  if (this->array_->type()->is_slice_type() && !this->array_->is_variable())\n+    {\n+      Temporary_statement* temp = Statement::make_temporary(NULL, this->array_, loc);\n+      inserter->insert(temp);\n+      this->array_ = Expression::make_temporary_reference(temp, loc);\n+    }\n+  return this;\n+}\n+\n // Return whether this expression is addressable.\n \n bool\n@@ -10643,22 +10694,17 @@ Array_index_expression::do_get_tree(Translate_context* context)\n       go_assert(this->array_->type()->is_error());\n       return error_mark_node;\n     }\n+  go_assert(!array_type->is_slice_type() || this->array_->is_variable());\n \n   tree type_tree = type_to_tree(array_type->get_backend(gogo));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n \n-  tree array_tree = this->array_->get_tree(context);\n-  if (array_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  if (array_type->length() == NULL && !DECL_P(array_tree))\n-    array_tree = save_expr(array_tree);\n-\n   tree length_tree = NULL_TREE;\n   if (this->end_ == NULL || this->end_->is_nil_expression())\n     {\n-      length_tree = array_type->length_tree(gogo, array_tree);\n+      Expression* len = array_type->get_length(gogo, this->array_);\n+      length_tree = len->get_tree(context);\n       if (length_tree == error_mark_node)\n \treturn error_mark_node;\n       length_tree = save_expr(length_tree);\n@@ -10667,7 +10713,8 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   tree capacity_tree = NULL_TREE;\n   if (this->end_ != NULL)\n     {\n-      capacity_tree = array_type->capacity_tree(gogo, array_tree);\n+      Expression* cap = array_type->get_capacity(gogo, this->array_);\n+      capacity_tree = cap->get_tree(context);\n       if (capacity_tree == error_mark_node)\n \treturn error_mark_node;\n       capacity_tree = save_expr(capacity_tree);\n@@ -10732,13 +10779,18 @@ Array_index_expression::do_get_tree(Translate_context* context)\n       if (array_type->length() != NULL)\n \t{\n \t  // Fixed array.\n+\t  tree array_tree = this->array_->get_tree(context);\n+\t  if (array_tree == error_mark_node)\n+\t    return error_mark_node;\n \t  return build4(ARRAY_REF, TREE_TYPE(type_tree), array_tree,\n \t\t\tstart_tree, NULL_TREE, NULL_TREE);\n \t}\n       else\n \t{\n \t  // Open array.\n-\t  tree values = array_type->value_pointer_tree(gogo, array_tree);\n+          Expression* valptr =\n+              array_type->get_value_pointer(gogo, this->array_);\n+\t  tree values = valptr->get_tree(context);\n \t  Type* element_type = array_type->element_type();\n \t  Btype* belement_type = element_type->get_backend(gogo);\n \t  tree element_type_tree = type_to_tree(belement_type);\n@@ -10820,7 +10872,8 @@ Array_index_expression::do_get_tree(Translate_context* context)\n                                                  start_tree),\n \t\t\t\telement_size);\n \n-  tree value_pointer = array_type->value_pointer_tree(gogo, array_tree);\n+  Expression* valptr = array_type->get_value_pointer(gogo, this->array_);\n+  tree value_pointer = valptr->get_tree(context);\n   if (value_pointer == error_mark_node)\n     return error_mark_node;\n \n@@ -14133,6 +14186,22 @@ Expression::is_nonconstant_composite_literal() const\n     }\n }\n \n+// Return true if this is a variable or temporary_variable.\n+\n+bool\n+Expression::is_variable() const\n+{\n+  switch (this->classification_)\n+    {\n+    case EXPRESSION_VAR_REFERENCE:\n+    case EXPRESSION_TEMPORARY_REFERENCE:\n+    case EXPRESSION_SET_AND_USE_TEMPORARY:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n // Return true if this is a reference to a local variable.\n \n bool\n@@ -14574,6 +14643,117 @@ Expression::make_type_info(Type* type, Type_info type_info)\n   return new Type_info_expression(type, type_info);\n }\n \n+// An expression that evaluates to some characteristic of a slice.\n+// This is used when indexing, bound-checking, or nil checking a slice.\n+\n+class Slice_info_expression : public Expression\n+{\n+ public:\n+  Slice_info_expression(Expression* slice, Slice_info slice_info,\n+                        Location location)\n+    : Expression(EXPRESSION_SLICE_INFO, location),\n+      slice_(slice), slice_info_(slice_info)\n+  { }\n+\n+ protected:\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Slice_info_expression(this->slice_->copy(), this->slice_info_,\n+                                     this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context* context);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+  void\n+  do_issue_nil_check()\n+  { this->slice_->issue_nil_check(); }\n+\n+ private:\n+  // The slice for which we are getting information.\n+  Expression* slice_;\n+  // What information we want.\n+  Slice_info slice_info_;\n+};\n+\n+// Return the type of the slice info.\n+\n+Type*\n+Slice_info_expression::do_type()\n+{\n+  switch (this->slice_info_)\n+    {\n+    case SLICE_INFO_VALUE_POINTER:\n+      return Type::make_pointer_type(\n+          this->slice_->type()->array_type()->element_type());\n+    case SLICE_INFO_LENGTH:\n+    case SLICE_INFO_CAPACITY:\n+        return Type::lookup_integer_type(\"int\");\n+    default:\n+      go_unreachable();\n+    }\n+}\n+\n+// Return slice information in GENERIC.\n+\n+tree\n+Slice_info_expression::do_get_tree(Translate_context* context)\n+{\n+  Gogo* gogo = context->gogo();\n+\n+  Bexpression* bslice = tree_to_expr(this->slice_->get_tree(context));\n+  Bexpression* ret;\n+  switch (this->slice_info_)\n+    {\n+    case SLICE_INFO_VALUE_POINTER:\n+    case SLICE_INFO_LENGTH:\n+    case SLICE_INFO_CAPACITY:\n+      ret = gogo->backend()->struct_field_expression(bslice, this->slice_info_,\n+                                                     this->location());\n+      break;\n+    default:\n+      go_unreachable();\n+    }\n+  return expr_to_tree(ret);\n+}\n+\n+// Dump ast representation for a type info expression.\n+\n+void\n+Slice_info_expression::do_dump_expression(\n+    Ast_dump_context* ast_dump_context) const\n+{\n+  ast_dump_context->ostream() << \"sliceinfo(\";\n+  this->slice_->dump_expression(ast_dump_context);\n+  ast_dump_context->ostream() << \",\";\n+  ast_dump_context->ostream() << \n+      (this->slice_info_ == SLICE_INFO_VALUE_POINTER ? \"values\" \n+    : this->slice_info_ == SLICE_INFO_LENGTH ? \"length\"\n+    : this->slice_info_ == SLICE_INFO_CAPACITY ? \"capacity \"\n+    : \"unknown\");\n+  ast_dump_context->ostream() << \")\";\n+}\n+\n+// Make a slice info expression.\n+\n+Expression*\n+Expression::make_slice_info(Expression* slice, Slice_info slice_info,\n+                            Location location)\n+{\n+  return new Slice_info_expression(slice, slice_info, location);\n+}\n+\n // An expression which evaluates to the offset of a field within a\n // struct.  This, like Type_info_expression, q.v., is only used to\n // initialize fields of a type descriptor."}, {"sha": "abebbd16961b3c49338c812714d5721e893ef0b9", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=6ddb62884fb6c35cabf02f665cd29376746e983e", "patch": "@@ -102,6 +102,7 @@ class Expression\n     EXPRESSION_RECEIVE,\n     EXPRESSION_TYPE_DESCRIPTOR,\n     EXPRESSION_TYPE_INFO,\n+    EXPRESSION_SLICE_INFO,\n     EXPRESSION_STRUCT_FIELD_OFFSET,\n     EXPRESSION_MAP_DESCRIPTOR,\n     EXPRESSION_LABEL_ADDR\n@@ -339,6 +340,22 @@ class Expression\n   static Expression*\n   make_type_info(Type* type, Type_info);\n \n+  // Make an expression that evaluates to some characteristic of a\n+  // slice.  For simplicity, the enum values must match the field indexes\n+  // in the underlying struct.\n+  enum Slice_info\n+    {\n+      // The underlying data of the slice.\n+      SLICE_INFO_VALUE_POINTER,\n+      // The length of the slice.\n+      SLICE_INFO_LENGTH,\n+      // The capacity of the slice.\n+      SLICE_INFO_CAPACITY\n+    };\n+\n+  static Expression*\n+  make_slice_info(Expression* slice, Slice_info, Location);\n+\n   // Make an expression which evaluates to the offset of a field in a\n   // struct.  This is only used for type descriptors, so there is no\n   // location parameter.\n@@ -544,6 +561,10 @@ class Expression\n   bool\n   is_nonconstant_composite_literal() const;\n \n+  // Return true if this is a variable or temporary variable.\n+  bool\n+  is_variable() const;\n+\n   // Return true if this is a reference to a local variable.\n   bool\n   is_local_variable() const;"}, {"sha": "6ecc6cd0f0f48a706189bcc4fc1b0e1279d53557", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=6ddb62884fb6c35cabf02f665cd29376746e983e", "patch": "@@ -2846,6 +2846,15 @@ Flatten::expression(Expression** pexpr)\n   return TRAVERSE_SKIP_COMPONENTS;\n }\n \n+// Flatten a block.\n+\n+void\n+Gogo::flatten_block(Named_object* function, Block* block)\n+{\n+  Flatten flatten(this, function);\n+  block->traverse(&flatten);\n+}\n+\n // Flatten an expression.  INSERTER may be NULL, in which case the\n // expression had better not need to create any temporaries.\n "}, {"sha": "3f2808781b741a4aceaede9c5f1345eac274d5a3", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=6ddb62884fb6c35cabf02f665cd29376746e983e", "patch": "@@ -487,6 +487,10 @@ class Gogo\n   void\n   lower_constant(Named_object*);\n \n+  // Flatten all the statements in a block.\n+  void\n+  flatten_block(Named_object* function, Block*);\n+\n   // Flatten an expression.\n   void\n   flatten_expression(Named_object* function, Statement_inserter*, Expression**);"}, {"sha": "d195ab9845a1f4ccc531df190ba579cb26853a34", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=6ddb62884fb6c35cabf02f665cd29376746e983e", "patch": "@@ -2471,6 +2471,7 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n   gogo->add_block(b, location);\n \n   gogo->lower_block(function, b);\n+  gogo->flatten_block(function, b);\n \n   // We already ran the determine_types pass, so we need to run it\n   // just for the call statement now.  The other types are known."}, {"sha": "2935523dd2aa546c50f50f97cc2a4433310e79fb", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 25, "deletions": 56, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=6ddb62884fb6c35cabf02f665cd29376746e983e", "patch": "@@ -6000,84 +6000,53 @@ Array_type::finish_backend_element(Gogo* gogo)\n     }\n }\n \n-// Return a tree for a pointer to the values in ARRAY.\n+// Return an expression for a pointer to the values in ARRAY.\n \n-tree\n-Array_type::value_pointer_tree(Gogo*, tree array) const\n+Expression*\n+Array_type::get_value_pointer(Gogo*, Expression* array) const\n {\n-  tree ret;\n   if (this->length() != NULL)\n     {\n       // Fixed array.\n-      ret = fold_convert(build_pointer_type(TREE_TYPE(TREE_TYPE(array))),\n-\t\t\t build_fold_addr_expr(array));\n+      go_assert(array->type()->array_type() != NULL);\n+      Type* etype = array->type()->array_type()->element_type();\n+      array = Expression::make_unary(OPERATOR_AND, array, array->location());\n+      return Expression::make_cast(Type::make_pointer_type(etype), array,\n+                                   array->location());\n     }\n-  else\n-    {\n-      // Open array.\n-      tree field = TYPE_FIELDS(TREE_TYPE(array));\n-      go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n-\t\t\t\"__values\") == 0);\n-      ret = fold_build3(COMPONENT_REF, TREE_TYPE(field), array, field,\n-\t\t\tNULL_TREE);\n-    }\n-  if (TREE_CONSTANT(array))\n-    TREE_CONSTANT(ret) = 1;\n-  return ret;\n+\n+  // Open array.\n+  return Expression::make_slice_info(array,\n+                                     Expression::SLICE_INFO_VALUE_POINTER,\n+                                     array->location());\n }\n \n-// Return a tree for the length of the array ARRAY which has this\n+// Return an expression for the length of the array ARRAY which has this\n // type.\n \n-tree\n-Array_type::length_tree(Gogo* gogo, tree array)\n+Expression*\n+Array_type::get_length(Gogo*, Expression* array) const\n {\n   if (this->length_ != NULL)\n-    {\n-      if (TREE_CODE(array) == SAVE_EXPR)\n-\treturn this->get_length_tree(gogo);\n-      else\n-\t{\n-\t  tree len = this->get_length_tree(gogo);\n-\t  return omit_one_operand(TREE_TYPE(len), len, array);\n-\t}\n-    }\n+    return this->length_;\n \n   // This is an open array.  We need to read the length field.\n-\n-  tree type = TREE_TYPE(array);\n-  go_assert(TREE_CODE(type) == RECORD_TYPE);\n-\n-  tree field = DECL_CHAIN(TYPE_FIELDS(type));\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n-\n-  tree ret = build3(COMPONENT_REF, TREE_TYPE(field), array, field, NULL_TREE);\n-  if (TREE_CONSTANT(array))\n-    TREE_CONSTANT(ret) = 1;\n-  return ret;\n+  return Expression::make_slice_info(array, Expression::SLICE_INFO_LENGTH,\n+                                     array->location());\n }\n \n-// Return a tree for the capacity of the array ARRAY which has this\n+// Return an expression for the capacity of the array ARRAY which has this\n // type.\n \n-tree\n-Array_type::capacity_tree(Gogo* gogo, tree array)\n+Expression*\n+Array_type::get_capacity(Gogo*, Expression* array) const\n {\n   if (this->length_ != NULL)\n-    {\n-      tree len = this->get_length_tree(gogo);\n-      return omit_one_operand(TREE_TYPE(len), len, array);\n-    }\n+    return this->length_;\n \n   // This is an open array.  We need to read the capacity field.\n-\n-  tree type = TREE_TYPE(array);\n-  go_assert(TREE_CODE(type) == RECORD_TYPE);\n-\n-  tree field = DECL_CHAIN(DECL_CHAIN(TYPE_FIELDS(type)));\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n-\n-  return build3(COMPONENT_REF, TREE_TYPE(field), array, field, NULL_TREE);\n+  return Expression::make_slice_info(array, Expression::SLICE_INFO_CAPACITY,\n+                                     array->location());\n }\n \n // Export."}, {"sha": "980436a103797ef31cbef165323c0cf0a2e1f32f", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ddb62884fb6c35cabf02f665cd29376746e983e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=6ddb62884fb6c35cabf02f665cd29376746e983e", "patch": "@@ -2312,17 +2312,17 @@ class Array_type : public Type\n   array_has_hidden_fields(const Named_type* within, std::string* reason) const\n   { return this->element_type_->has_hidden_fields(within, reason); }\n \n-  // Return a tree for the pointer to the values in an array.\n-  tree\n-  value_pointer_tree(Gogo*, tree array) const;\n+  // Return an expression for the pointer to the values in an array.\n+  Expression*\n+  get_value_pointer(Gogo*, Expression* array) const;\n \n-  // Return a tree for the length of an array with this type.\n-  tree\n-  length_tree(Gogo*, tree array);\n+  // Return an expression for the length of an array with this type.\n+  Expression*\n+  get_length(Gogo*, Expression* array) const;\n \n-  // Return a tree for the capacity of an array with this type.\n-  tree\n-  capacity_tree(Gogo*, tree array);\n+  // Return an expression for the capacity of an array with this type.\n+  Expression*\n+  get_capacity(Gogo*, Expression* array) const;\n \n   // Import an array type.\n   static Array_type*"}]}