{"sha": "ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNkM2I3M2M2ZGRlOWQ3YjYxYjgxMWIzY2FiM2FjODIzYjYzYzE4MQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-09-21T19:58:23Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-09-21T19:58:23Z"}, "message": "re PR fortran/37583 (ICE \"insert_bbt(): Duplicate key\" for self-calling ENTRY subprogram)\n\n2008-09-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/37583\n\t* decl.c (scalarize_intrinsic_call): Both subroutines and\n\tfunctions can give a true for get_proc_mame's last argument so\n\tremove the &&gfc_current_ns->proc_name->attr.function.\n\tresolve.c (resolve_actual_arglist): Add check for recursion by\n\treference to procedure as actual argument.\n\n2008-09-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/37583\n\t* gfortran.dg/entry_18.f90: New test.\n\nFrom-SVN: r140532", "tree": {"sha": "b68949529b16170ec70aaa2df94ddaeea09ee265", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b68949529b16170ec70aaa2df94ddaeea09ee265"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/comments", "author": null, "committer": null, "parents": [{"sha": "19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5"}], "stats": {"total": 62, "additions": 60, "deletions": 2}, "files": [{"sha": "e36241391577abb3ab10dcc394cf863c7fed623c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "patch": "@@ -1,3 +1,12 @@\n+2008-09-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/37583\n+\t* decl.c (scalarize_intrinsic_call): Both subroutines and\n+\tfunctions can give a true for get_proc_mame's last argument so\n+\tremove the &&gfc_current_ns->proc_name->attr.function.\n+\tresolve.c (resolve_actual_arglist): Add check for recursion by\n+\treference to procedure as actual argument.\n+\n 2008-09-21  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/35846"}, {"sha": "370ac10b3a94c3666f44b5da5dc1311b5063a0cd", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "patch": "@@ -4639,8 +4639,7 @@ gfc_match_entry (void)\n      created symbols attached to the current namespace.  */\n   if (get_proc_name (name, &entry,\n \t\t     gfc_current_ns->parent != NULL\n-\t\t     && module_procedure\n-\t\t     && gfc_current_ns->proc_name->attr.function))\n+\t\t     && module_procedure))\n     return MATCH_ERROR;\n \n   proc = gfc_current_block ();"}, {"sha": "a7c62c30532dd31ce09de347d2ea58f5bfe5bda9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "patch": "@@ -1176,6 +1176,15 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t  /* Just in case a specific was found for the expression.  */\n \t  sym = e->symtree->n.sym;\n \n+\t  if (sym->attr.entry && sym->ns->entries\n+\t\t&& sym->ns == gfc_current_ns\n+\t\t&& !sym->ns->entries->sym->attr.recursive)\n+\t    {\n+\t      gfc_error (\"Reference to ENTRY '%s' at %L is recursive, but procedure \"\n+\t\t\t \"'%s' is not declared as RECURSIVE\",\n+\t\t\t sym->name, &e->where, sym->ns->entries->sym->name);\n+\t    }\n+\n \t  /* If the symbol is the function that names the current (or\n \t     parent) scope, then we really have a variable reference.  */\n "}, {"sha": "c1ee1f89719b98fd5c63a53b04c96de38a50de05", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "patch": "@@ -1,3 +1,8 @@\n+2008-09-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/37583\n+\t* gfortran.dg/entry_18.f90: New test.\n+\n 2008-09-21  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/35846"}, {"sha": "e00aea7d6b81a3ac7ca5a42a3d221ed674eaf56f", "filename": "gcc/testsuite/gfortran.dg/entry_18.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecd3b73c6dde9d7b61b811b3cab3ac823b63c181/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_18.f90?ref=ecd3b73c6dde9d7b61b811b3cab3ac823b63c181", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! Test fix for PR37583, in which:\n+! (i) the reference to glocal prior to the ENTRY caused an internal\n+! error and\n+! (ii) the need for a RECURSIVE attribute was ignored.\n+!\n+! Contributed by Arjen Markus <arjen.markus@wldelft.nl>\n+!\n+module gsub\n+contains\n+recursive subroutine suba( g )   ! prefix with \"RECURSIVE\"\n+   interface\n+       real function g(x)\n+       real x\n+       end function\n+   end interface\n+   real :: x, y\n+   call mysub( glocala )\n+   return\n+entry glocala( x, y )\n+   y = x\n+end subroutine\n+subroutine subb( g )\n+   interface\n+       real function g(x)\n+       real x\n+       end function\n+   end interface\n+   real :: x, y\n+   call mysub( glocalb ) ! { dg-error \"is recursive\" }\n+   return\n+entry glocalb( x, y )\n+   y = x\n+end subroutine\n+end module\n+! { dg-final { cleanup-modules \"gsub\" } }"}]}