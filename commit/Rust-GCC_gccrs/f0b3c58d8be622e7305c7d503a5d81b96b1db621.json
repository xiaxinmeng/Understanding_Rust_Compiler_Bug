{"sha": "f0b3c58d8be622e7305c7d503a5d81b96b1db621", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBiM2M1OGQ4YmU2MjJlNzMwNWM3ZDUwM2E1ZDgxYjk2YjFkYjYyMQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-06-24T11:04:02Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-06-24T11:04:02Z"}, "message": "re PR fortran/32298 (MINLOC / MAXLOC: off-by one for PARAMETER arrays)\n\n2007-06-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/32298\n\tPR fortran/31726\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Calculate\n\tthe offset between the loop counter and the position as\n\tdefined. Add the offset within the loop so that the mask acts\n\tcorrectly.  Do not advance the location on the basis that it\n\tis zero.\n\n2007-06-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31726\n\t* gfortran.dg/minmaxloc_1.f90: New test.\n\n\tPR fortran/32298\n\t* gfortran.dg/minmaxloc_2.f90: New test.\n\nFrom-SVN: r125983", "tree": {"sha": "16520c1ec2271712b293e5a3adfbf883bb1af809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16520c1ec2271712b293e5a3adfbf883bb1af809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0b3c58d8be622e7305c7d503a5d81b96b1db621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0b3c58d8be622e7305c7d503a5d81b96b1db621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0b3c58d8be622e7305c7d503a5d81b96b1db621", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0b3c58d8be622e7305c7d503a5d81b96b1db621/comments", "author": null, "committer": null, "parents": [{"sha": "dbb233964c4801a60b3a17c5213317efff9f93d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb233964c4801a60b3a17c5213317efff9f93d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbb233964c4801a60b3a17c5213317efff9f93d6"}], "stats": {"total": 197, "additions": 186, "deletions": 11}, "files": [{"sha": "e3876fc3ab0b3be10ff409189ac100f39243fb9c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f0b3c58d8be622e7305c7d503a5d81b96b1db621", "patch": "@@ -1,3 +1,13 @@\n+2007-06-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/32298\n+\tPR fortran/31726\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Calculate\n+\tthe offset between the loop counter and the position as\n+\tdefined. Add the offset within the loop so that the mask acts\n+\tcorrectly.  Do not advance the location on the basis that it\n+\tis zero.\n+\n 2007-06-22  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/31473"}, {"sha": "874b1081de668d91aafed493e7f326dac7b85b4b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f0b3c58d8be622e7305c7d503a5d81b96b1db621", "patch": "@@ -1928,6 +1928,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   tree tmp;\n   tree elsetmp;\n   tree ifbody;\n+  tree offset;\n   gfc_loopinfo loop;\n   gfc_actual_arglist *actual;\n   gfc_ss *arrayss;\n@@ -1947,6 +1948,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n \n   /* Initialize the result.  */\n   pos = gfc_create_var (gfc_array_index_type, \"pos\");\n+  offset = gfc_create_var (gfc_array_index_type, \"offset\");\n   type = gfc_typenode_for_spec (&expr->ts);\n \n   /* Walk the arguments.  */\n@@ -2045,15 +2047,28 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   /* Assign the value to the limit...  */\n   gfc_add_modify_expr (&ifblock, limit, arrayse.expr);\n \n-  /* Remember where we are.  */\n-  gfc_add_modify_expr (&ifblock, pos, loop.loopvar[0]);\n+  /* Remember where we are.  An offset must be added to the loop\n+     counter to obtain the required position.  */\n+  if (loop.temp_dim)\n+    tmp = build_int_cst (gfc_array_index_type, 1);\n+  else\n+    tmp =fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t gfc_index_one_node, loop.from[0]);\n+  gfc_add_modify_expr (&block, offset, tmp);\n+\n+  tmp = build2 (PLUS_EXPR, TREE_TYPE (pos),\n+\t\tloop.loopvar[0], offset);\n+  gfc_add_modify_expr (&ifblock, pos, tmp);\n \n   ifbody = gfc_finish_block (&ifblock);\n \n-  /* If it is a more extreme value or pos is still zero.  */\n+  /* If it is a more extreme value or pos is still zero and the value\n+     equal to the limit.  */\n+  tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\tbuild2 (EQ_EXPR, boolean_type_node, pos, gfc_index_zero_node),\n+\t\tbuild2 (EQ_EXPR, boolean_type_node, arrayse.expr, limit));\n   tmp = build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t  build2 (op, boolean_type_node, arrayse.expr, limit),\n-\t\t  build2 (EQ_EXPR, boolean_type_node, pos, gfc_index_zero_node));\n+\t\tbuild2 (op, boolean_type_node, arrayse.expr, limit), tmp);\n   tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -2098,12 +2113,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n     }\n   gfc_cleanup_loop (&loop);\n \n-  /* Return a value in the range 1..SIZE(array).  */\n-  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, loop.from[0],\n-\t\t     gfc_index_one_node);\n-  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, pos, tmp);\n-  /* And convert to the required type.  */\n-  se->expr = convert (type, tmp);\n+  se->expr = convert (type, pos);\n }\n \n static void"}, {"sha": "17bddb1a54a744e81365262cd97b732bef977959", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f0b3c58d8be622e7305c7d503a5d81b96b1db621", "patch": "@@ -1,3 +1,11 @@\n+2007-06-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31726\n+\t* gfortran.dg/minmaxloc_1.f90: New test.\n+\n+\tPR fortran/32298\n+\t* gfortran.dg/minmaxloc_2.f90: New test.\n+\n 2007-06-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gcc.dg/visibility-12.c: New test."}, {"sha": "fcdf7952e6682348837bf6ea11f37898a767a9c3", "filename": "gcc/testsuite/gfortran.dg/minmaxloc_1.f90", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_1.f90?ref=f0b3c58d8be622e7305c7d503a5d81b96b1db621", "patch": "@@ -0,0 +1,118 @@\n+! { dg-do run }\n+! Check max/minloc.\n+! PR fortran/31726\n+!\n+program test\n+  implicit none\n+  integer :: i(1), j(-1:1), res(1)\n+  logical, volatile :: m(3), m2(3)\n+  m = (/ .false., .false., .false. /)\n+  m2 = (/ .false., .true., .false. /)\n+  call check(1, 0, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=.FALSE.))\n+  call check(2, 0, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=m))\n+  call check(3, 2, MAXLOC((/ 42, 23, 11 /), DIM=1, MASK=m2))\n+  call check(4, 0, MAXLOC(i(1:0), DIM=1, MASK=.TRUE.))\n+  call check(5, 0, MAXLOC(i(1:0), DIM=1, MASK=.FALSE.))\n+  call check(6, 0, MAXLOC(i(1:0), DIM=1, MASK=m(1:0)))\n+  call check(7, 0, MAXLOC(i(1:0), DIM=1))\n+  call check(8, 0, MINLOC((/ 42, 23, 11 /), DIM=1, MASK=.FALSE.))\n+  call check(9, 0, MINLOC((/ 42, 23, 11 /), DIM=1, MASK=m))\n+  call check(10, 0, MINLOC(i(1:0), DIM=1, MASK=.FALSE.))\n+  call check(11,0, MINLOC(i(1:0), DIM=1, MASK=m(1:0)))\n+  call check(12,0, MINLOC(i(1:0), DIM=1, MASK=.TRUE.))\n+  call check(13,0, MINLOC(i(1:0), DIM=1))\n+\n+  j = (/ 1, 2, 1 /); call check(14, 2, MAXLOC(j, DIM=1))\n+  j = (/ 1, 2, 3 /); call check(15, 3, MAXLOC(j, DIM=1))\n+  j = (/ 3, 2, 1 /); call check(16, 1, MAXLOC(j, DIM=1))\n+  j = (/ 1, 2, 1 /); call check(17, 1, MINLOC(j, DIM=1))\n+  j = (/ 1, 2, 3 /); call check(18, 1, MINLOC(j, DIM=1))\n+  j = (/ 3, 2, 1 /); call check(19, 3, MINLOC(j, DIM=1))\n+\n+  j = (/ 1, 2, 1 /); call check(20, 2, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 3 /); call check(21, 3, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 3, 2, 1 /); call check(22, 1, MAXLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 1 /); call check(23, 1, MINLOC(j, DIM=1,mask=.true.))\n+  j = (/ 1, 2, 3 /); call check(24, 1, MINLOC(j, DIM=1,mask=.true.))\n+  j = (/ 3, 2, 1 /); call check(25, 3, MINLOC(j, DIM=1,mask=.true.))\n+\n+  j = (/ 1, 2, 1 /); call check(26, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 3 /); call check(27, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 3, 2, 1 /); call check(28, 0, MAXLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 1 /); call check(29, 0, MINLOC(j, DIM=1,mask=.false.))\n+  j = (/ 1, 2, 3 /); call check(30, 0, MINLOC(j, DIM=1,mask=.false.))\n+  j = (/ 3, 2, 1 /); call check(31, 0, MINLOC(j, DIM=1,mask=.false.))\n+\n+  j = (/ 1, 2, 1 /); call check(32, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 3 /); call check(33, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 3, 2, 1 /); call check(34, 0, MAXLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 1 /); call check(35, 0, MINLOC(j, DIM=1,mask=m))\n+  j = (/ 1, 2, 3 /); call check(36, 0, MINLOC(j, DIM=1,mask=m))\n+  j = (/ 3, 2, 1 /); call check(37, 0, MINLOC(j, DIM=1,mask=m))\n+\n+  j = (/ 1, 2, 1 /); call check(38, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 3 /); call check(39, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 3, 2, 1 /); call check(40, 2, MAXLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 1 /); call check(41, 2, MINLOC(j, DIM=1,mask=m2))\n+  j = (/ 1, 2, 3 /); call check(42, 2, MINLOC(j, DIM=1,mask=m2))\n+  j = (/ 3, 2, 1 /); call check(43, 2, MINLOC(j, DIM=1,mask=m2))\n+\n+! Check the library minloc and maxloc\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=.FALSE.); call check(44, 0,  res(1))\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=m); call check(45, 0,  res(1))\n+  res = MAXLOC((/ 42, 23, 11 /), MASK=m2); call check(46, 2,  res(1))\n+  res = MAXLOC(i(1:0), MASK=.TRUE.); call check(47, 0,  res(1))\n+  res = MAXLOC(i(1:0), MASK=.FALSE.); call check(48, 0,  res(1))\n+  res = MAXLOC(i(1:0), MASK=m(1:0)); call check(49, 0,  res(1))\n+  res = MAXLOC(i(1:0)); call check(50, 0,  res(1))\n+  res = MINLOC((/ 42, 23, 11 /), MASK=.FALSE.); call check(51, 0, res(1))\n+  res = MINLOC((/ 42, 23, 11 /), MASK=m); call check(52, 0, res(1))\n+  res = MINLOC(i(1:0), MASK=.FALSE.); call check(53, 0, res(1))\n+  res = MINLOC(i(1:0), MASK=m(1:0)); call check(54,0, res(1))\n+  res = MINLOC(i(1:0), MASK=.TRUE.); call check(55,0, res(1))\n+  res = MINLOC(i(1:0)); call check(56,0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j); call check(57, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j); call check(58, 3,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j); call check(59, 1,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j); call check(60, 1, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j); call check(61, 1, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j); call check(62, 3, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=.true.); call check(63, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=.true.); call check(65, 3,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=.true.); call check(66, 1,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=.true.); call check(67, 1, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=.true.); call check(68, 1, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=.true.); call check(69, 3, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=.false.); call check(70, 0,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=.false.); call check(71, 0,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=.false.); call check(72, 0,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=.false.); call check(73, 0, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=.false.); call check(74, 0, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=.false.); call check(75, 0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=m); call check(76, 0,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=m); call check(77, 0,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=m); call check(78, 0,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=m); call check(79, 0, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=m); call check(80, 0, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=m);call check(81, 0, res(1))\n+\n+  j = (/ 1, 2, 1 /); res = MAXLOC(j,mask=m2); call check(82, 2,  res(1))\n+  j = (/ 1, 2, 3 /); res = MAXLOC(j,mask=m2); call check(83, 2,  res(1))\n+  j = (/ 3, 2, 1 /); res = MAXLOC(j,mask=m2); call check(84, 2,  res(1))\n+  j = (/ 1, 2, 1 /); res = MINLOC(j,mask=m2); call check(85, 2, res(1))\n+  j = (/ 1, 2, 3 /); res = MINLOC(j,mask=m2); call check(86, 2, res(1))\n+  j = (/ 3, 2, 1 /); res = MINLOC(j,mask=m2); call check(87, 2, res(1))\n+\n+contains\n+subroutine check(n, i,j)\n+  integer, value, intent(in) :: i,j,n\n+  if(i /= j) then\n+     call abort()\n+!    print *, 'ERROR: Test',n,' expected ',i,' received ', j\n+  end if\n+end subroutine check\n+end program"}, {"sha": "a4fd7ae5e77fa63749eb65089e106aaf55f20388", "filename": "gcc/testsuite/gfortran.dg/minmaxloc_2.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0b3c58d8be622e7305c7d503a5d81b96b1db621/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmaxloc_2.f90?ref=f0b3c58d8be622e7305c7d503a5d81b96b1db621", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! Tests the fix for PR32298, in which the scalarizer would generate\n+! a temporary in the course of evaluating MINLOC or MAXLOC, thereby\n+! setting the start of the scalarizer loop to zero.\n+!\n+! Contributed by Jens Bischoff <jens.bischoff@freenet.de> \n+!\n+PROGRAM ERR_MINLOC\n+\n+   INTEGER, PARAMETER :: N = 7\n+\n+   DOUBLE PRECISION, DIMENSION (N), PARAMETER :: A &\n+     = (/ 0.3D0, 0.455D0, 0.6D0, 0.7D0, 0.72D0, 0.76D0, 0.79D0 /)\n+\n+   DOUBLE PRECISION :: B\n+   INTEGER          :: I, J(N), K(N)\n+\n+  DO I = 1, N\n+    B = A(I)\n+    J(I) = MINLOC (ABS (A - B), 1)\n+    K(I) = MAXLOC (ABS (A - B), 1)\n+  END DO\n+\n+  if (any (J .NE. (/1,2,3,4,5,6,7/))) call abort ()\n+  if (any (K .NE. (/7,7,1,1,1,1,1/))) call abort ()\n+\n+  STOP\n+\n+END PROGRAM ERR_MINLOC"}]}