{"sha": "da4029679e2be30dc78f3f3a016226f6e2299abb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE0MDI5Njc5ZTJiZTMwZGM3OGYzZjNhMDE2MjI2ZjZlMjI5OWFiYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-07-03T11:48:47Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-07-03T11:48:47Z"}, "message": "ASAN: handle addressable params (PR sanitize/81040).\n\n2017-07-03  Martin Liska  <mliska@suse.cz>\n\n\tPR sanitize/81040\n\t* g++.dg/asan/function-argument-1.C: New test.\n\t* g++.dg/asan/function-argument-2.C: New test.\n\t* g++.dg/asan/function-argument-3.C: New test.\n2017-07-03  Martin Liska  <mliska@suse.cz>\n\n\tPR sanitize/81040\n\t* sanopt.c (rewrite_usage_of_param): New function.\n\t(sanitize_rewrite_addressable_params): Likewise.\n\t(pass_sanopt::execute): Call rewrite_usage_of_param.\n\nFrom-SVN: r249903", "tree": {"sha": "87b35ad9ae9f27b7dc9ca3acafa2088e9bff3d82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87b35ad9ae9f27b7dc9ca3acafa2088e9bff3d82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da4029679e2be30dc78f3f3a016226f6e2299abb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4029679e2be30dc78f3f3a016226f6e2299abb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da4029679e2be30dc78f3f3a016226f6e2299abb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4029679e2be30dc78f3f3a016226f6e2299abb/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b6d447f20948b35804fd780f8f1a237c9d36826f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d447f20948b35804fd780f8f1a237c9d36826f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6d447f20948b35804fd780f8f1a237c9d36826f"}], "stats": {"total": 249, "additions": 244, "deletions": 5}, "files": [{"sha": "905c6916262d03191acbcb5dccde50806f017b05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da4029679e2be30dc78f3f3a016226f6e2299abb", "patch": "@@ -1,8 +1,21 @@\n+2017-07-03  Martin Liska  <mliska@suse.cz>\n+\n+\tPR sanitize/81040\n+\t* sanopt.c (rewrite_usage_of_param): New function.\n+\t(sanitize_rewrite_addressable_params): Likewise.\n+\t(pass_sanopt::execute): Call rewrite_usage_of_param.\n+\n 2017-07-03  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-loop.c (vect_create_epilog_for_reduction): Revert\n \tback to using VIEW_CONVERT_EXPR.\n \n+2017-07-03  Martin Liska  <mliska@suse.cz>\n+\n+\tPR other/78366\n+\t* doc/extend.texi: Document when a resolver function is\n+\tgenerated for target_clones.\n+\n 2017-07-03  Martin Liska  <mliska@suse.cz>\n \n \t* asan.c (asan_emit_stack_protection): Unpoison just red zones"}, {"sha": "03ba8fc436c187f52cbd482fbbbef8262c22a781", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=da4029679e2be30dc78f3f3a016226f6e2299abb", "patch": "@@ -3278,16 +3278,16 @@ are the same as for @code{target} attribute.\n For instance, on an x86, you could compile a function with\n @code{target_clones(\"sse4.1,avx\")}.  GCC creates two function clones,\n one compiled with @option{-msse4.1} and another with @option{-mavx}.\n-It also creates a resolver function (see the @code{ifunc} attribute\n-above) that dynamically selects a clone suitable for current\n-architecture.\n \n On a PowerPC, you can compile a function with\n @code{target_clones(\"cpu=power9,default\")}.  GCC will create two\n function clones, one compiled with @option{-mcpu=power9} and another\n-with the default options.  It also creates a resolver function (see\n+with the default options.\n+\n+It also creates a resolver function (see\n the @code{ifunc} attribute above) that dynamically selects a clone\n-suitable for current architecture.\n+suitable for current architecture.  The resolver is created only if there\n+is a usage of a function with @code{target_clones} attribute.\n \n @item unused\n @cindex @code{unused} function attribute"}, {"sha": "7692f6a9db716c793ed8423b5359a08cbced235c", "filename": "gcc/sanopt.c", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=da4029679e2be30dc78f3f3a016226f6e2299abb", "patch": "@@ -37,6 +37,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-ssa.h\"\n #include \"tree-phinodes.h\"\n #include \"ssa-iterators.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+#include \"cfghooks.h\"\n+#include \"tree-dfa.h\"\n+#include \"tree-ssa.h\"\n \n /* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */\n@@ -858,6 +864,135 @@ sanitize_asan_mark_poison (void)\n     }\n }\n \n+/* Rewrite all usages of tree OP which is a PARM_DECL with a VAR_DECL\n+   that is it's DECL_VALUE_EXPR.  */\n+\n+static tree\n+rewrite_usage_of_param (tree *op, int *walk_subtrees, void *)\n+{\n+  if (TREE_CODE (*op) == PARM_DECL && DECL_HAS_VALUE_EXPR_P (*op))\n+    {\n+      *op = DECL_VALUE_EXPR (*op);\n+      *walk_subtrees = 0;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* For a given function FUN, rewrite all addressable parameters so that\n+   a new automatic variable is introduced.  Right after function entry\n+   a parameter is assigned to the variable.  */\n+\n+static void\n+sanitize_rewrite_addressable_params (function *fun)\n+{\n+  gimple *g;\n+  gimple_seq stmts = NULL;\n+  bool has_any_addressable_param = false;\n+  auto_vec<tree> clear_value_expr_list;\n+\n+  for (tree arg = DECL_ARGUMENTS (current_function_decl);\n+       arg; arg = DECL_CHAIN (arg))\n+    {\n+      if (TREE_ADDRESSABLE (arg) && !TREE_ADDRESSABLE (TREE_TYPE (arg)))\n+\t{\n+\t  TREE_ADDRESSABLE (arg) = 0;\n+\t  /* The parameter is no longer addressable.  */\n+\t  tree type = TREE_TYPE (arg);\n+\t  has_any_addressable_param = true;\n+\n+\t  /* Create a new automatic variable.  */\n+\t  tree var = build_decl (DECL_SOURCE_LOCATION (arg),\n+\t\t\t\t VAR_DECL, DECL_NAME (arg), type);\n+\t  TREE_ADDRESSABLE (var) = 1;\n+\t  DECL_ARTIFICIAL (var) = 1;\n+\n+\t  gimple_add_tmp_var (var);\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Rewriting parameter whose address is taken: %s\\n\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (arg)));\n+\n+\t  gcc_assert (!DECL_HAS_VALUE_EXPR_P (arg));\n+\t  DECL_HAS_VALUE_EXPR_P (arg) = 1;\n+\t  SET_DECL_VALUE_EXPR (arg, var);\n+\n+\t  SET_DECL_PT_UID (var, DECL_PT_UID (arg));\n+\n+\t  /* Assign value of parameter to newly created variable.  */\n+\t  if ((TREE_CODE (type) == COMPLEX_TYPE\n+\t       || TREE_CODE (type) == VECTOR_TYPE))\n+\t    {\n+\t      /* We need to create a SSA name that will be used for the\n+\t\t assignment.  */\n+\t      DECL_GIMPLE_REG_P (arg) = 1;\n+\t      tree tmp = get_or_create_ssa_default_def (cfun, arg);\n+\t      g = gimple_build_assign (var, tmp);\n+\t      gimple_set_location (g, DECL_SOURCE_LOCATION (arg));\n+\t      gimple_seq_add_stmt (&stmts, g);\n+\t    }\n+\t  else\n+\t    {\n+\t      g = gimple_build_assign (var, arg);\n+\t      gimple_set_location (g, DECL_SOURCE_LOCATION (arg));\n+\t      gimple_seq_add_stmt (&stmts, g);\n+\t    }\n+\n+\t  if (target_for_debug_bind (arg))\n+\t    {\n+\t      g = gimple_build_debug_bind (arg, var, NULL);\n+\t      gimple_seq_add_stmt (&stmts, g);\n+\t      clear_value_expr_list.safe_push (arg);\n+\t    }\n+\t}\n+    }\n+\n+  if (!has_any_addressable_param)\n+    return;\n+\n+  /* Replace all usages of PARM_DECLs with the newly\n+     created variable VAR.  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple_stmt_iterator it = gsi_for_stmt (stmt);\n+\t  walk_gimple_stmt (&it, NULL, rewrite_usage_of_param, NULL);\n+\t}\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = dyn_cast<gphi *> (gsi_stmt (gsi));\n+          for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t    {\n+\t      hash_set<tree> visited_nodes;\n+\t      walk_tree (gimple_phi_arg_def_ptr (phi, i),\n+\t\t\t rewrite_usage_of_param, NULL, &visited_nodes);\n+\t    }\n+\t}\n+    }\n+\n+  /* Unset value expr for parameters for which we created debug bind\n+     expressions.  */\n+  unsigned i;\n+  tree arg;\n+  FOR_EACH_VEC_ELT (clear_value_expr_list, i, arg)\n+    {\n+      DECL_HAS_VALUE_EXPR_P (arg) = 0;\n+      SET_DECL_VALUE_EXPR (arg, NULL_TREE);\n+    }\n+\n+  /* Insert default assignments at the beginning of a function.  */\n+  basic_block entry_bb = ENTRY_BLOCK_PTR_FOR_FN (fun);\n+  entry_bb = split_edge (single_succ_edge (entry_bb));\n+\n+  gimple_stmt_iterator gsi = gsi_start_bb (entry_bb);\n+  gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n+}\n+\n unsigned int\n pass_sanopt::execute (function *fun)\n {\n@@ -891,6 +1026,9 @@ pass_sanopt::execute (function *fun)\n       sanitize_asan_mark_poison ();\n     }\n \n+  if (asan_sanitize_stack_p ())\n+    sanitize_rewrite_addressable_params (fun);\n+\n   bool use_calls = ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD < INT_MAX\n     && asan_num_accesses >= ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD;\n "}, {"sha": "09d9d7b339783238c6918f284063eca1b5027a41", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=da4029679e2be30dc78f3f3a016226f6e2299abb", "patch": "@@ -1,3 +1,10 @@\n+2017-07-03  Martin Liska  <mliska@suse.cz>\n+\n+\tPR sanitize/81040\n+\t* g++.dg/asan/function-argument-1.C: New test.\n+\t* g++.dg/asan/function-argument-2.C: New test.\n+\t* g++.dg/asan/function-argument-3.C: New test.\n+\n 2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.dg/vect/bb-slp-pr65935.c: Expect SLP to be used in main"}, {"sha": "148c4628316b86979dd212095c3f6e26c236bf29", "filename": "gcc/testsuite/g++.dg/asan/function-argument-1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-1.C?ref=da4029679e2be30dc78f3f3a016226f6e2299abb", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do run }\n+// { dg-shouldfail \"asan\" }\n+\n+struct A\n+{\n+  int a[5];\n+};\n+\n+static __attribute__ ((noinline)) int\n+goo (A *a)\n+{\n+  int *ptr = &a->a[0];\n+  return *(volatile int *) (ptr - 1);\n+}\n+\n+__attribute__ ((noinline)) int\n+foo (A arg)\n+{\n+  return goo (&arg);\n+}\n+\n+int\n+main ()\n+{\n+  return foo (A ());\n+}\n+\n+// { dg-output \"ERROR: AddressSanitizer: stack-buffer-underflow on address.*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"READ of size . at.*\" }\n+// { dg-output \".*'arg' <== Memory access at offset \\[0-9\\]* underflows this variable.*\" }"}, {"sha": "3a7c33bdaaa43e53fe1c71ccf9966d35952ea0a7", "filename": "gcc/testsuite/g++.dg/asan/function-argument-2.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-2.C?ref=da4029679e2be30dc78f3f3a016226f6e2299abb", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do run }\n+// { dg-shouldfail \"asan\" }\n+\n+static __attribute__ ((noinline)) int\n+goo (int *a)\n+{\n+  return *(volatile int *)a;\n+}\n+\n+__attribute__ ((noinline)) int\n+foo (char arg)\n+{\n+  return goo ((int *)&arg);\n+}\n+\n+int\n+main ()\n+{\n+  return foo (12);\n+}\n+\n+// { dg-output \"ERROR: AddressSanitizer: stack-buffer-overflow on address.*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"READ of size . at.*\" }\n+// { dg-output \".*'arg' <== Memory access at offset \\[0-9\\]* partially overflows this variable.*\" }"}, {"sha": "14617ba84258bb3ed6246d0876f1cce345408201", "filename": "gcc/testsuite/g++.dg/asan/function-argument-3.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da4029679e2be30dc78f3f3a016226f6e2299abb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Ffunction-argument-3.C?ref=da4029679e2be30dc78f3f3a016226f6e2299abb", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do run }\n+// { dg-shouldfail \"asan\" }\n+\n+typedef int v4si __attribute__ ((vector_size (16)));\n+\n+static __attribute__ ((noinline)) int\n+goo (v4si *a)\n+{\n+  return (*(volatile v4si *) (a + 1))[2];\n+}\n+\n+__attribute__ ((noinline)) int\n+foo (v4si arg)\n+{\n+  return goo (&arg);\n+}\n+\n+int\n+main ()\n+{\n+  v4si v = {1,2,3,4};\n+  return foo (v);\n+}\n+\n+// { dg-output \"ERROR: AddressSanitizer: stack-buffer-overflow on address.*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"READ of size . at.*\" }\n+// { dg-output \".*'arg' <== Memory access at offset \\[0-9\\]* overflows this variable.*\" }"}]}