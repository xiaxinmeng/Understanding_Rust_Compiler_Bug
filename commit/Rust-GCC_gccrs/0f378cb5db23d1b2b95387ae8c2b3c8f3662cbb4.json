{"sha": "0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYzNzhjYjVkYjIzZDFiMmI5NTM4N2FlOGMyYjNjOGYzNjYyY2JiNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-25T19:23:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-25T19:23:15Z"}, "message": "ipa-cp.c (ipcp_discover_new_direct_edges): If something was turned to direct call update the summary.\n\n\n\t* ipa-cp.c (ipcp_discover_new_direct_edges): If something was turned\n\tto direct call update the summary.\n\t* ipa-inline-transform.c (inline_call): Sanity check that summaries\n\tmatch the predicted effect; fix updating of summary after edge\n\tredirection.\n\t* ipa-inline-analysis.c (inline_node_duplication_hook): Do not try\n\tto update the summary and recompute it instead.\n\t(estimate_function_body_sizes): Fix self size estimation; double\n\tcheck that it agrees with inline_update_overall_summary.\n\t(estimate_edge_size_and_time): Handle devirtualizaiton costs.\n\t(estimate_edge_devirt_benefit): Update to be called from\n\testimate_edge_size_and_time.\n\t(estimate_calls_size_and_time): Update.\n\t(estimate_node_size_and_time): Watch overflows.\n\t(inline_merge_summary): Likewise.\n\t* ipa-prob.c: Include ipa-inline.h\n\t(ipa_make_edge_direct_to_target): After redirection update the summary.\n\nFrom-SVN: r192821", "tree": {"sha": "81e2371d565ef985b588b64d19e5b6de88ca0df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81e2371d565ef985b588b64d19e5b6de88ca0df3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/comments", "author": null, "committer": null, "parents": [{"sha": "0d198936b908bcf4aa4138ae86774955c9db6854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d198936b908bcf4aa4138ae86774955c9db6854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d198936b908bcf4aa4138ae86774955c9db6854"}], "stats": {"total": 202, "additions": 128, "deletions": 74}, "files": [{"sha": "826a58d0521ad307c37b382b01f7b022fa3bf8f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "patch": "@@ -1,3 +1,23 @@\n+2012-10-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-cp.c (ipcp_discover_new_direct_edges): If something was turned\n+\tto direct call update the summary.\n+\t* ipa-inline-transform.c (inline_call): Sanity check that summaries\n+\tmatch the predicted effect; fix updating of summary after edge\n+\tredirection.\n+\t* ipa-inline-analysis.c (inline_node_duplication_hook): Do not try\n+\tto update the summary and recompute it instead.\n+\t(estimate_function_body_sizes): Fix self size estimation; double\n+\tcheck that it agrees with inline_update_overall_summary.\n+\t(estimate_edge_size_and_time): Handle devirtualizaiton costs.\n+\t(estimate_edge_devirt_benefit): Update to be called from\n+\testimate_edge_size_and_time.\n+\t(estimate_calls_size_and_time): Update.\n+\t(estimate_node_size_and_time): Watch overflows.\n+\t(inline_merge_summary): Likewise.\n+\t* ipa-prob.c: Include ipa-inline.h\n+\t(ipa_make_edge_direct_to_target): After redirection update the summary.\n+\n 2012-10-25  Cary Coutant  <ccoutant@google.com>\n \n \tPR debug/55063"}, {"sha": "8f8053fa480453fdda0a504ae09b601e89ca82d6", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "patch": "@@ -1688,6 +1688,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t\t\t\tVEC (tree, heap) *known_vals)\n {\n   struct cgraph_edge *ie, *next_ie;\n+  bool found = false;\n \n   for (ie = node->indirect_calls; ie; ie = next_ie)\n     {\n@@ -1696,8 +1697,14 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n       next_ie = ie->next_callee;\n       target = ipa_get_indirect_edge_target (ie, known_vals, NULL, NULL);\n       if (target)\n-\tipa_make_edge_direct_to_target (ie, target);\n+\t{\n+\t  ipa_make_edge_direct_to_target (ie, target);\n+\t  found = true;\n+\t}\n     }\n+  /* Turning calls to direct calls will improve overall summary.  */\n+  if (found)\n+    inline_update_overall_summary (node);\n }\n \n /* Vector of pointers which for linked lists of clones of an original crgaph"}, {"sha": "915f5f2059bf399dd7c9d8833e5de708a8f2f770", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 74, "deletions": 69, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "patch": "@@ -1081,7 +1081,6 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n       struct predicate true_pred = true_predicate ();\n       size_time_entry *e;\n       int optimized_out_size = 0;\n-      gcov_type optimized_out_time = 0;\n       bool inlined_to_p = false;\n       struct cgraph_edge *edge;\n \n@@ -1123,10 +1122,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t\t\t\t\t     possible_truths,\n \t\t\t\t\t\t\t     info);\n \t  if (false_predicate_p (&new_predicate))\n-\t    {\n-\t      optimized_out_size += e->size;\n-\t      optimized_out_time += e->time;\n-\t    }\n+\t    optimized_out_size += e->size;\n \t  else\n \t    account_size_time (info, e->size, e->time, &new_predicate);\n \t}\n@@ -1149,9 +1145,6 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t      && !false_predicate_p (es->predicate))\n \t    {\n \t      optimized_out_size += es->call_stmt_size * INLINE_SIZE_SCALE;\n-\t      optimized_out_time += (es->call_stmt_time\n-\t\t\t\t     * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE)\n-\t\t\t\t     * edge->frequency);\n \t      edge->frequency = 0;\n \t    }\n \t  edge_set_predicate (edge, &new_predicate);\n@@ -1174,9 +1167,6 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t      && !false_predicate_p (es->predicate))\n \t    {\n \t      optimized_out_size += es->call_stmt_size * INLINE_SIZE_SCALE;\n-\t      optimized_out_time += (es->call_stmt_time\n-\t\t\t\t     * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE)\n-\t\t\t\t     * edge->frequency);\n \t      edge->frequency = 0;\n \t    }\n \t  edge_set_predicate (edge, &new_predicate);\n@@ -1193,22 +1183,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t about updating self sizes, because size vectors already contains\n \t sizes of the calees.  */\n       gcc_assert (!inlined_to_p \n-\t\t  || (!optimized_out_size && !optimized_out_time));\n-\n-      info->size -= optimized_out_size / INLINE_SIZE_SCALE;\n-      info->self_size -= optimized_out_size / INLINE_SIZE_SCALE;\n-      gcc_assert (info->size > 0);\n-      gcc_assert (info->self_size > 0);\n-\n-      optimized_out_time /= INLINE_TIME_SCALE;\n-      if (optimized_out_time > MAX_TIME)\n-\toptimized_out_time = MAX_TIME;\n-      info->time -= optimized_out_time;\n-      info->self_time -= optimized_out_time;\n-      if (info->time < 0)\n-\tinfo->time = 0;\n-      if (info->self_time < 0)\n-\tinfo->self_time = 0;\n+\t\t  || !optimized_out_size);\n     }\n   else\n     {\n@@ -1226,6 +1201,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t  set_hint_predicate (&info->loop_stride, p);\n \t}\n     }\n+  inline_update_overall_summary (dst);\n }\n \n \n@@ -2405,8 +2381,6 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      struct predicate p;\n \n \t      this_time *= freq;\n-\t      time += this_time;\n-\t      size += this_size;\n \n \t      prob = eliminated_by_inlining_prob (stmt);\n \t      if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n@@ -2420,6 +2394,12 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      else\n \t\tp = true_predicate ();\n \n+\t      if (!false_predicate_p (&p))\n+\t\t{\n+\t\t  time += this_time;\n+\t\t  size += this_size;\n+\t\t}\n+\n \t      /* We account everything but the calls.  Calls have their own\n \t\t size/time info attached to cgraph edges.  This is necessary\n \t\t in order to make the cost disappear after inlining.  */\n@@ -2621,6 +2601,12 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   info->size = info->self_size;\n   info->stack_frame_offset = 0;\n   info->estimated_stack_size = info->estimated_self_stack_size;\n+#ifdef ENABLE_CHECKING\n+  inline_update_overall_summary (node);\n+  gcc_assert (info->time == info->self_time\n+\t      && info->size == info->self_size);\n+#endif\n+\n   pop_cfun ();\n }\n \n@@ -2655,51 +2641,35 @@ struct gimple_opt_pass pass_inline_parameters =\n };\n \n \n-/* Increase SIZE and TIME for size and time needed to handle edge E.  */\n-\n-static void\n-estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n-\t\t\t     int prob)\n-{\n-  struct inline_edge_summary *es = inline_edge_summary (e);\n-  *size += es->call_stmt_size * INLINE_SIZE_SCALE;\n-  *time += (es->call_stmt_time * prob / REG_BR_PROB_BASE\n-\t    * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE));\n-  if (*time > MAX_TIME * INLINE_TIME_SCALE)\n-    *time = MAX_TIME * INLINE_TIME_SCALE;\n-}\n-\n-\n /* Estimate benefit devirtualizing indirect edge IE, provided KNOWN_VALS and\n    KNOWN_BINFOS.  */\n \n static bool\n estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n-\t\t\t      int *size, int *time, int prob,\n+\t\t\t      int *size, int *time,\n \t\t\t      VEC (tree, heap) *known_vals,\n \t\t\t      VEC (tree, heap) *known_binfos,\n \t\t\t      VEC (ipa_agg_jump_function_p, heap) *known_aggs)\n {\n   tree target;\n-  int time_diff, size_diff;\n   struct cgraph_node *callee;\n   struct inline_summary *isummary;\n \n   if (!known_vals && !known_binfos)\n     return false;\n+  if (!flag_indirect_inlining)\n+    return false;\n \n   target = ipa_get_indirect_edge_target (ie, known_vals, known_binfos,\n \t\t\t\t\t known_aggs);\n   if (!target)\n     return false;\n \n   /* Account for difference in cost between indirect and direct calls.  */\n-  size_diff = ((eni_size_weights.indirect_call_cost - eni_size_weights.call_cost)\n-\t        * INLINE_SIZE_SCALE);\n-  *size -= size_diff;\n-  time_diff = ((eni_time_weights.indirect_call_cost - eni_time_weights.call_cost)\n-\t       * INLINE_TIME_SCALE * prob / REG_BR_PROB_BASE);\n-  *time -= time_diff;\n+  *size -= (eni_size_weights.indirect_call_cost - eni_size_weights.call_cost);\n+  *time -= (eni_time_weights.indirect_call_cost - eni_time_weights.call_cost);\n+  gcc_checking_assert (*time >= 0);\n+  gcc_checking_assert (*size >= 0);\n \n   callee = cgraph_get_node (target);\n   if (!callee || !callee->analyzed)\n@@ -2708,6 +2678,34 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   return isummary->inlinable;\n }\n \n+/* Increase SIZE and TIME for size and time needed to handle edge E.  */\n+\n+static inline void\n+estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n+\t\t\t     int prob,\n+\t\t\t     VEC (tree, heap) *known_vals,\n+\t\t\t     VEC (tree, heap) *known_binfos,\n+\t\t\t     VEC (ipa_agg_jump_function_p, heap) *known_aggs,\n+\t\t\t     inline_hints *hints)\n+\t\n+{\n+  struct inline_edge_summary *es = inline_edge_summary (e);\n+  int call_size = es->call_stmt_size;\n+  int call_time = es->call_stmt_time;\n+  if (!e->callee\n+      && estimate_edge_devirt_benefit (e, &call_size, &call_time,\n+\t\t\t\t       known_vals, known_binfos, known_aggs)\n+      && hints\n+      && cgraph_maybe_hot_edge_p (e))\n+    *hints |= INLINE_HINT_indirect_call;\n+  *size += call_size * INLINE_SIZE_SCALE;\n+  *time += call_time * prob / REG_BR_PROB_BASE\n+\t    * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE);\n+  if (*time > MAX_TIME * INLINE_TIME_SCALE)\n+    *time = MAX_TIME * INLINE_TIME_SCALE;\n+}\n+\n+\n \n /* Increase SIZE and TIME for size and time needed to handle all calls in NODE.\n    POSSIBLE_TRUTHS, KNOWN_VALS and KNOWN_BINFOS describe context of the call\n@@ -2731,7 +2729,9 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n \t    {\n \t      /* Predicates of calls shall not use NOT_CHANGED codes,\n \t\t sowe do not need to compute probabilities.  */\n-\t      estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n+\t      estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE,\n+\t\t\t\t\t   known_vals, known_binfos, known_aggs,\n+\t\t\t\t\t   hints);\n \t    }\n \t  else\n \t    estimate_calls_size_and_time (e->callee, size, time, hints,\n@@ -2743,14 +2743,9 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n       if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n-\t{\n-\t  estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n-\t  if (estimate_edge_devirt_benefit (e, size, time, REG_BR_PROB_BASE,\n-\t\t\t\t\t    known_vals, known_binfos, known_aggs)\n-\t      && hints\n-\t      && cgraph_maybe_hot_edge_p (e))\n-\t    *hints |= INLINE_HINT_indirect_call;\n-\t}\n+\testimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE,\n+\t\t\t\t     known_vals, known_binfos, known_aggs,\n+\t\t\t\t     hints);\n     }\n }\n \n@@ -2772,7 +2767,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n {\n   struct inline_summary *info = inline_summary (node);\n   size_time_entry *e;\n-  int size = 0, time = 0;\n+  int size = 0;\n+  int time = 0;\n   inline_hints hints = 0;\n   int i;\n \n@@ -2801,6 +2797,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     if (evaluate_predicate (&e->predicate, possible_truths))\n       {\n \tsize += e->size;\n+\tgcc_checking_assert (e->time >= 0);\n+        gcc_checking_assert (time >= 0);\n \tif (!inline_param_summary)\n \t  time += e->time;\n \telse\n@@ -2809,10 +2807,17 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\t\t      &e->predicate,\n \t\t\t\t\t      possible_truths,\n \t\t\t\t\t      inline_param_summary);\n-\t    time += e->time * prob / REG_BR_PROB_BASE;\n+\t    gcc_checking_assert (prob >= 0);\n+\t    gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n+\t    time += ((gcov_type)e->time * prob) / REG_BR_PROB_BASE;\n \t  }\n+        if (time > MAX_TIME * INLINE_TIME_SCALE)\n+            time = MAX_TIME * INLINE_TIME_SCALE;\n+        gcc_checking_assert (time >= 0);\n \t\t\t\t\t         \n       }\n+  gcc_checking_assert (size >= 0);\n+  gcc_checking_assert (time >= 0);\n \n   if (info->loop_iterations\n       && !evaluate_predicate (info->loop_iterations, possible_truths))\n@@ -2821,18 +2826,18 @@ estimate_node_size_and_time (struct cgraph_node *node,\n       && !evaluate_predicate (info->loop_stride, possible_truths))\n     hints |=INLINE_HINT_loop_stride;\n \n-  if (time > MAX_TIME * INLINE_TIME_SCALE)\n-    time = MAX_TIME * INLINE_TIME_SCALE;\n \n   estimate_calls_size_and_time (node, &size, &time, &hints, possible_truths,\n \t\t\t\tknown_vals, known_binfos, known_aggs);\n-  time = (time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n-  size = (size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n+  gcc_checking_assert (size >= 0);\n+  gcc_checking_assert (time >= 0);\n+  time = RDIV (time, INLINE_TIME_SCALE);\n+  size = RDIV (size, INLINE_SIZE_SCALE);\n \n \n   if (dump_file\n       && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n   size:%i time:%i\\n\", size, time);\n+    fprintf (dump_file, \"\\n   size:%i time:%i\\n\", (int)size, (int)time);\n   if (ret_time)\n     *ret_time = time;\n   if (ret_size)\n@@ -3224,7 +3229,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t  int prob = predicate_probability (callee_info->conds,\n \t\t\t\t\t    &e->predicate,\n \t\t\t\t\t    clause, es->param);\n-\t  add_time = add_time * prob / REG_BR_PROB_BASE;\n+\t  add_time = ((gcov_type)add_time * prob) / REG_BR_PROB_BASE;\n \t  if (add_time > MAX_TIME * INLINE_TIME_SCALE)\n \t    add_time = MAX_TIME * INLINE_TIME_SCALE;\n \t  if (prob != REG_BR_PROB_BASE"}, {"sha": "60a29628aee33c40a5177804ffe5e5bb029d8a66", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "patch": "@@ -209,6 +209,12 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   struct cgraph_node *to = NULL;\n   struct cgraph_edge *curr = e;\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+  bool new_edges_found = false;\n+\n+#ifdef ENABLE_CHECKING\n+  int estimated_growth = estimate_edge_growth (e);\n+  bool predicated = inline_edge_summary (e)->predicate != NULL;\n+#endif\n \n   /* Don't inline inlined edges.  */\n   gcc_assert (e->inline_failed);\n@@ -248,19 +254,28 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   old_size = inline_summary (to)->size;\n   inline_merge_summary (e);\n+  if (optimize)\n+    new_edges_found = ipa_propagate_indirect_call_infos (curr, new_edges);\n   if (update_overall_summary)\n    inline_update_overall_summary (to);\n   new_size = inline_summary (to)->size;\n+#ifdef ENABLE_CHECKING\n+  /* Verify that estimated growth match real growth.  Allow off-by-one\n+     error due to INLINE_SIZE_SCALE roudoff errors.  */\n+  gcc_assert (!update_overall_summary || !overall_size\n+\t      || abs (estimated_growth - (new_size - old_size)) <= 1\n+\t      /* FIXME: a hack.  Edges with false predicate are accounted\n+\t\t wrong, we should remove them from callgraph.  */\n+\t      || predicated);\n+#endif\n+   \n   if (overall_size)\n     *overall_size += new_size - old_size;\n   ncalls_inlined++;\n \n   /* This must happen after inline_merge_summary that rely on jump\n      functions of callee to not be updated.  */\n-  if (optimize)\n-    return ipa_propagate_indirect_call_infos (curr, new_edges);\n-  else\n-    return false;\n+  return new_edges_found;\n }\n \n "}, {"sha": "e9e4602e9a05b833dc7a49adf7e184080937b807", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=0f378cb5db23d1b2b95387ae8c2b3c8f3662cbb4", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"tree-pass.h\"\n #include \"tree-inline.h\"\n+#include \"ipa-inline.h\"\n #include \"gimple.h\"\n #include \"flags.h\"\n #include \"diagnostic.h\"\n@@ -2100,6 +2101,7 @@ struct cgraph_edge *\n ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n {\n   struct cgraph_node *callee;\n+  struct inline_edge_summary *es = inline_edge_summary (ie);\n \n   if (TREE_CODE (target) == ADDR_EXPR)\n     target = TREE_OPERAND (target, 0);\n@@ -2115,6 +2117,11 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n   gcc_assert (!callee->global.inlined_to);\n \n   cgraph_make_edge_direct (ie, callee);\n+  es = inline_edge_summary (ie);\n+  es->call_stmt_size -= (eni_size_weights.indirect_call_cost\n+\t\t\t - eni_size_weights.call_cost);\n+  es->call_stmt_time -= (eni_time_weights.indirect_call_cost\n+\t\t\t - eni_time_weights.call_cost);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"ipa-prop: Discovered %s call to a known target \""}]}