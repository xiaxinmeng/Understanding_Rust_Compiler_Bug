{"sha": "6458033dde6a2db8e5dd2a140805b58a3ed3747f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ1ODAzM2RkZTZhMmRiOGU1ZGQyYTE0MDgwNWI1OGEzZWQzNzQ3Zg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-02-09T13:48:34Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-02-09T13:48:34Z"}, "message": "[multiple changes]\n\n1999-02-09 16:42 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n\t* cppfiles.c (finclude):  Handle pipes properly under old BSD\n          derivatives.\n1999-02-09 16:42 -0500  Melissa O'Neill <oneill@cs.sfu.ca>\n\t* system.h: Provide fallback definitions for S_ISCHR,\n          S_ISSOCK, S_ISFIFO, O_NONBLOCK, and O_NOCTTY.\n\nFrom-SVN: r25111", "tree": {"sha": "15001c4ddc6e98d67f3c219961f582253c3b7649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15001c4ddc6e98d67f3c219961f582253c3b7649"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6458033dde6a2db8e5dd2a140805b58a3ed3747f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6458033dde6a2db8e5dd2a140805b58a3ed3747f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6458033dde6a2db8e5dd2a140805b58a3ed3747f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6458033dde6a2db8e5dd2a140805b58a3ed3747f/comments", "author": null, "committer": null, "parents": [{"sha": "8ec65f13b03f68893379947b8611a280cabe5b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec65f13b03f68893379947b8611a280cabe5b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ec65f13b03f68893379947b8611a280cabe5b74"}], "stats": {"total": 72, "additions": 70, "deletions": 2}, "files": [{"sha": "c3759169a52ca732795db2b3d712c3ce462012d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6458033dde6a2db8e5dd2a140805b58a3ed3747f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6458033dde6a2db8e5dd2a140805b58a3ed3747f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6458033dde6a2db8e5dd2a140805b58a3ed3747f", "patch": "@@ -1,3 +1,13 @@\n+1999-02-09 16:42 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n+\n+\t* cppfiles.c (finclude):  Handle pipes properly under old BSD\n+          derivatives.\n+\n+1999-02-09 16:42 -0500  Melissa O'Neill <oneill@cs.sfu.ca>\n+\n+\t* system.h: Provide fallback definitions for S_ISCHR,\n+          S_ISSOCK, S_ISFIFO, O_NONBLOCK, and O_NOCTTY.\n+\n 1999-02-09 10:30 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n \n \t* cpplib.c (do_define): Allow redefining __STDC__ with -D."}, {"sha": "b43d280abd4bdbdb3fece4d6def070944b2cc506", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6458033dde6a2db8e5dd2a140805b58a3ed3747f/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6458033dde6a2db8e5dd2a140805b58a3ed3747f/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=6458033dde6a2db8e5dd2a140805b58a3ed3747f", "patch": "@@ -683,11 +683,27 @@ finclude (pfile, fd, ihash)\n \n   fp = CPP_BUFFER (pfile);\n \n+  /* If fd points to a plain file, we know how big it is, so we can\n+     allocate the buffer all at once.  If fd is a pipe or terminal, we\n+     can't.  Most C source files are 4k or less, so we guess that.  If\n+     fd is something weird, like a block device or a directory, we\n+     don't want to read it at all.\n+\n+     Unfortunately, different systems use different st.st_mode values\n+     for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and\n+     zero the entire struct stat except a couple fields.  Hence the\n+     mess below.\n+\n+     In all cases, read_and_prescan will resize the buffer if it\n+     turns out there's more data than we thought.  */\n+\n   if (S_ISREG (st.st_mode))\n     {\n       /* off_t might have a wider range than size_t - in other words,\n \t the max size of a file might be bigger than the address\n-\t space, and we need to detect that now. */\n+\t space.  We can't handle a file that large.  (Anyone with\n+         a single source file bigger than 4GB needs to rethink\n+\t their coding style.)  */\n       st_size = (size_t) st.st_size;\n       if ((unsigned HOST_WIDE_INT) st_size\n \t  != (unsigned HOST_WIDE_INT) st.st_size)\n@@ -696,7 +712,11 @@ finclude (pfile, fd, ihash)\n \t  goto fail;\n \t}\n     }\n-  else if (S_ISFIFO (st.st_mode) || (S_ISCHR (st.st_mode) && isatty (fd)))\n+  else if (S_ISFIFO (st.st_mode) || S_ISSOCK (st.st_mode)\n+\t   /* Some 4.x (x<4) derivatives have a bug that makes fstat() of a\n+\t      socket or pipe return a stat struct with most fields zeroed.  */\n+\t   || (st.st_mode == 0 && st.st_nlink == 0 && st.st_size == 0)\n+\t   || (S_ISCHR (st.st_mode) && isatty (fd)))\n     {\n       /* Cannot get its file size before reading.  4k is a decent\n          first guess. */\n@@ -743,6 +763,11 @@ finclude (pfile, fd, ihash)\n   return 0;\n }\n \n+/* Given a path FNAME, extract the directory component and place it\n+   onto the actual_dirs list.  Return a pointer to the allocated\n+   file_name_list structure.  These structures are used to implement\n+   current-directory \"\" include searching. */\n+\n static struct file_name_list *\n actual_directory (pfile, fname)\n      cpp_reader *pfile;"}, {"sha": "f0c4208b2e8388a210e09c969959c9a642b6166c", "filename": "gcc/system.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6458033dde6a2db8e5dd2a140805b58a3ed3747f/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6458033dde6a2db8e5dd2a140805b58a3ed3747f/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=6458033dde6a2db8e5dd2a140805b58a3ed3747f", "patch": "@@ -422,6 +422,39 @@ extern void abort ();\n #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)\n #endif\n \n+/* Test if something is a character special file.  */\n+#ifndef S_ISCHR\n+#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)\n+#endif\n+\n+/* Test if something is a socket.  */\n+#ifndef S_ISSOCK\n+# ifdef S_IFSOCK\n+#   define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)\n+# else\n+#   define S_ISSOCK(m) 0\n+# endif\n+#endif\n+\n+/* Test if something is a FIFO.  */\n+#ifndef S_ISFIFO\n+# ifdef S_IFIFO\n+#  define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)\n+# else\n+#  define S_ISFIFO(m) 0\n+# endif\n+#endif\n+\n+/* Approximate O_NONBLOCK.  */\n+#ifndef O_NONBLOCK\n+#define O_NONBLOCK O_NDELAY\n+#endif\n+\n+/* Approximate O_NOCTTY.  */\n+#ifndef O_NOCTTY\n+#define O_NOCTTY 0\n+#endif\n+\n /* Get libiberty declarations. */\n #include \"libiberty.h\"\n "}]}