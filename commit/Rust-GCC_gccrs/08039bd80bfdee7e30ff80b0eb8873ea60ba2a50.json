{"sha": "08039bd80bfdee7e30ff80b0eb8873ea60ba2a50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgwMzliZDgwYmZkZWU3ZTMwZmY4MGIwZWI4ODczZWE2MGJhMmE1MA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-12T19:41:51Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-12T19:41:51Z"}, "message": "fold-const.c (omit_two_operands): New function.\n\n\n\t* fold-const.c (omit_two_operands): New function.\n\t* tree.h (omit_two_operands): Prototype here.\n\t* builtins.c (fold_builtin_unordered_cmp): New function to lower\n\tC99 unordered comparison builtins to the appropriate tree nodes.\n\t(fold_builtin_1): Use fold_builtin_unordered_cmp to lower\n\tBUILT_IN_ISGREATER, BUILT_IN_ISGREATEREQUAL, BUILT_IN_ISLESS,\n\tBUILT_IN_ISLESSEQUAL and BUILT_IN_ISLESSGREATER.  Manually lower\n\tBUILT_IN_ISUNORDERED comparisons to an UNORDERED_EXPR tree node.\n\t(simplify_builtin_memcmp, simplify_builtin_strncmp,\n\tsimplify_builtin_strncat, simplify_builtin_strspn): Use the new\n\tomit_two_operands function to build the required COMPOUND_EXPRs.\n\nFrom-SVN: r83040", "tree": {"sha": "7e11e3760e9116204227c10877ce045689c9dece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e11e3760e9116204227c10877ce045689c9dece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/comments", "author": null, "committer": null, "parents": [{"sha": "a2a2059fd77eb8c30c0534cbc766c21072a9829a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2a2059fd77eb8c30c0534cbc766c21072a9829a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2a2059fd77eb8c30c0534cbc766c21072a9829a"}], "stats": {"total": 123, "additions": 100, "deletions": 23}, "files": [{"sha": "69df57bf8148f8519e8a34a57db2bed3a8f467bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08039bd80bfdee7e30ff80b0eb8873ea60ba2a50", "patch": "@@ -1,3 +1,17 @@\n+2004-06-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (omit_two_operands): New function.\n+\t* tree.h (omit_two_operands): Prototype here.\n+\t* builtins.c (fold_builtin_unordered_cmp): New function to lower\n+\tC99 unordered comparison builtins to the appropriate tree nodes.\n+\t(fold_builtin_1): Use fold_builtin_unordered_cmp to lower\n+\tBUILT_IN_ISGREATER, BUILT_IN_ISGREATEREQUAL, BUILT_IN_ISLESS,\n+\tBUILT_IN_ISLESSEQUAL and BUILT_IN_ISLESSGREATER.  Manually lower\n+\tBUILT_IN_ISUNORDERED comparisons to an UNORDERED_EXPR tree node.\n+\t(simplify_builtin_memcmp, simplify_builtin_strncmp,\n+\tsimplify_builtin_strncat, simplify_builtin_strspn): Use the new\n+\tomit_two_operands function to build the required COMPOUND_EXPRs.\n+\n 2004-06-12  Steven Bosscher <stevenb@suse.de>,\n \t    Andreas Jaeger  <aj@suse.de>\n "}, {"sha": "78611ca6fe684b3512dbfc07302552924ac4aed4", "filename": "gcc/builtins.c", "status": "modified", "additions": 62, "deletions": 23, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=08039bd80bfdee7e30ff80b0eb8873ea60ba2a50", "patch": "@@ -168,6 +168,8 @@ static tree fold_builtin_toascii (tree);\n static tree fold_builtin_isdigit (tree);\n static tree fold_builtin_fabs (tree, tree);\n static tree fold_builtin_abs (tree, tree);\n+static tree fold_builtin_unordered_cmp (tree, tree, enum tree_code,\n+\t\t\t\t\tenum tree_code);\n \n static tree simplify_builtin_memcmp (tree);\n static tree simplify_builtin_strcmp (tree);\n@@ -7608,6 +7610,33 @@ fold_builtin_abs (tree arglist, tree type)\n   return fold (build1 (ABS_EXPR, type, arg));\n }\n \n+/* Fold a call to an unordered comparison function such as\n+   __builtin_isgreater().  ARGLIST is the funtion's argument list\n+   and TYPE is the functions return type.  UNORDERED_CODE and\n+   ORDERED_CODE are comparison codes that give the opposite of\n+   the desired result.  UNORDERED_CODE is used for modes that can\n+   hold NaNs and ORDERED_CODE is used for the rest.  */\n+\n+static tree\n+fold_builtin_unordered_cmp (tree arglist, tree type,\n+\t\t\t    enum tree_code unordered_code,\n+\t\t\t    enum tree_code ordered_code)\n+{\n+  enum tree_code code;\n+  tree arg0, arg1;\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  code = MODE_HAS_NANS (TYPE_MODE (TREE_TYPE (arg0))) ? unordered_code\n+\t\t\t\t\t\t      : ordered_code;\n+  return fold (build1 (TRUTH_NOT_EXPR, type,\n+\t\t       fold (build2 (code, type, arg0, arg1))));\n+}\n+\n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n@@ -8160,6 +8189,28 @@ fold_builtin_1 (tree exp)\n     case BUILT_IN_COPYSIGNL:\n       return fold_builtin_copysign (arglist, type);\n \n+    case BUILT_IN_ISGREATER:\n+      return fold_builtin_unordered_cmp (arglist, type, UNLE_EXPR, LE_EXPR);\n+    case BUILT_IN_ISGREATEREQUAL:\n+      return fold_builtin_unordered_cmp (arglist, type, UNLT_EXPR, LT_EXPR);\n+    case BUILT_IN_ISLESS:\n+      return fold_builtin_unordered_cmp (arglist, type, UNGE_EXPR, GE_EXPR);\n+    case BUILT_IN_ISLESSEQUAL:\n+      return fold_builtin_unordered_cmp (arglist, type, UNGT_EXPR, GT_EXPR);\n+    case BUILT_IN_ISLESSGREATER:\n+      return fold_builtin_unordered_cmp (arglist, type, UNEQ_EXPR, EQ_EXPR);\n+\n+    case BUILT_IN_ISUNORDERED:\n+      if (validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+\t{\n+\t  tree arg0 = TREE_VALUE (arglist);\n+\t  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\t  if (!MODE_HAS_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t    return omit_two_operands (type, integer_zero_node, arg0, arg1);\n+\t  return fold (build2 (UNORDERED_EXPR, type, arg0, arg1));\n+\t}\n+      break;\n+\n     default:\n       break;\n     }\n@@ -8772,13 +8823,9 @@ simplify_builtin_memcmp (tree arglist)\n \n   /* If the len parameter is zero, return zero.  */\n   if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n-    {\n-      /* Evaluate and ignore arg1 and arg2 in case they have\n-         side-effects.  */\n-      return build2 (COMPOUND_EXPR, integer_type_node, arg1,\n-\t\t     build2 (COMPOUND_EXPR, integer_type_node,\n-\t\t\t     arg2, integer_zero_node));\n-    }\n+    /* Evaluate and ignore arg1 and arg2 in case they have side-effects.  */\n+    return omit_two_operands (integer_type_node, integer_zero_node,\n+\t\t\t      arg1, arg2);\n \n   p1 = c_getstr (arg1);\n   p2 = c_getstr (arg2);\n@@ -8913,13 +8960,9 @@ simplify_builtin_strncmp (tree arglist)\n \n   /* If the len parameter is zero, return zero.  */\n   if (integer_zerop (arg3))\n-    {\n-      /* Evaluate and ignore arg1 and arg2 in case they have\n-\t side-effects.  */\n-      return build2 (COMPOUND_EXPR, integer_type_node, arg1,\n-\t\t     build2 (COMPOUND_EXPR, integer_type_node,\n-\t\t\t     arg2, integer_zero_node));\n-    }\n+    /* Evaluate and ignore arg1 and arg2 in case they have side-effects.  */\n+    return omit_two_operands (integer_type_node, integer_zero_node,\n+\t\t\t      arg1, arg2);\n \n   /* If arg1 and arg2 are equal (and not volatile), return zero.  */\n   if (operand_equal_p (arg1, arg2, 0))\n@@ -9030,8 +9073,7 @@ simplify_builtin_strncat (tree arglist)\n       /* If the requested length is zero, or the src parameter string\n           length is zero, return the dst parameter.  */\n       if (integer_zerop (len) || (p && *p == '\\0'))\n-\treturn build2 (COMPOUND_EXPR, TREE_TYPE (dst), src,\n-\t\t       build2 (COMPOUND_EXPR, integer_type_node, len, dst));\n+        return omit_two_operands (TREE_TYPE (dst), dst, src, len);\n \n       /* If the requested len is greater than or equal to the string\n          length, call strcat.  */\n@@ -9089,13 +9131,10 @@ simplify_builtin_strspn (tree arglist)\n \n       /* If either argument is \"\", return 0.  */\n       if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n-\t{\n-\t  /* Evaluate and ignore both arguments in case either one has\n-\t     side-effects.  */\n-\t  return build2 (COMPOUND_EXPR, integer_type_node, s1,\n-\t\t\t build2 (COMPOUND_EXPR, integer_type_node,\n-\t\t\t\t s2, integer_zero_node));\n-\t}\n+\t/* Evaluate and ignore both arguments in case either one has\n+\t   side-effects.  */\n+\treturn omit_two_operands (integer_type_node, integer_zero_node,\n+\t\t\t\t  s1, s2);\n       return 0;\n     }\n }"}, {"sha": "02f4128af49f4c11b32843137c4834280c80167b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=08039bd80bfdee7e30ff80b0eb8873ea60ba2a50", "patch": "@@ -2828,6 +2828,29 @@ pedantic_omit_one_operand (tree type, tree result, tree omitted)\n \n   return pedantic_non_lvalue (t);\n }\n+\n+/* Return a tree for the case when the result of an expression is RESULT\n+   converted to TYPE and OMITTED1 and OMITTED2 were previously operands\n+   of the expression but are now not needed.\n+\n+   If OMITTED1 or OMITTED2 has side effects, they must be evaluated.\n+   If both OMITTED1 and OMITTED2 have side effects, OMITTED1 is\n+   evaluated before OMITTED2.  Otherwise, if neither has side effects,\n+   just do the conversion of RESULT to TYPE.  */\n+\n+tree\n+omit_two_operands (tree type, tree result, tree omitted1, tree omitted2)\n+{\n+  tree t = fold_convert (type, result);\n+\n+  if (TREE_SIDE_EFFECTS (omitted2))\n+    t = build2 (COMPOUND_EXPR, type, omitted2, t);\n+  if (TREE_SIDE_EFFECTS (omitted1))\n+    t = build2 (COMPOUND_EXPR, type, omitted1, t);\n+\n+  return TREE_CODE (t) != COMPOUND_EXPR ? non_lvalue (t) : t;\n+}\n+\n \f\n /* Return a simplified tree node for the truth-negation of ARG.  This\n    never alters ARG itself.  We assume that ARG is an operation that"}, {"sha": "e0ba912becda878dd4dcc01d4d0783a488b693b9", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08039bd80bfdee7e30ff80b0eb8873ea60ba2a50/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=08039bd80bfdee7e30ff80b0eb8873ea60ba2a50", "patch": "@@ -3508,6 +3508,7 @@ enum operand_equal_flag\n extern int operand_equal_p (tree, tree, unsigned int);\n \n extern tree omit_one_operand (tree, tree, tree);\n+extern tree omit_two_operands (tree, tree, tree, tree);\n extern tree invert_truthvalue (tree);\n extern tree nondestructive_fold_unary_to_constant (enum tree_code, tree, tree);\n extern tree nondestructive_fold_binary_to_constant (enum tree_code, tree, tree, tree);"}]}