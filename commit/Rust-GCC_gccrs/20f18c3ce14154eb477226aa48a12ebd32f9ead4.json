{"sha": "20f18c3ce14154eb477226aa48a12ebd32f9ead4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBmMThjM2NlMTQxNTRlYjQ3NzIyNmFhNDhhMTJlYmQzMmY5ZWFkNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-01-23T18:54:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-01-23T18:54:08Z"}, "message": "re PR c++/55189 (enable -Wreturn-type by default)\n\n\tPR c++/55189\n\t* cp-tree.h (struct language_function): Add infinite_loop and\n\tinfinite_loops.\n\t(current_function_infinite_loop): New.\n\t* semantics.c (begin_maybe_infinite_loop, end_maybe_infinite_loop)\n\t(break_maybe_infinite_loop): New.\n\t(finish_while_stmt_cond, finish_while_stmt, begin_do_stmt)\n\t(finish_do_stmt, finish_for_cond, finish_for_stmt)\n\t(begin_range_for_stmt): Use them.\n\t* decl.c (finish_function): Don't warn about missing return\n\tif current_function_infinite_loop.\n\t* pt.c (instantiate_decl): Copy current_function_infinite_loop.\n\t* parser.c (cp_parser_jump_statement): Call break_maybe_infinite_loop.\n\nFrom-SVN: r207001", "tree": {"sha": "b80e9c1dd9cea4b9e0fd4dafbb7b382397e04a7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b80e9c1dd9cea4b9e0fd4dafbb7b382397e04a7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20f18c3ce14154eb477226aa48a12ebd32f9ead4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f18c3ce14154eb477226aa48a12ebd32f9ead4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20f18c3ce14154eb477226aa48a12ebd32f9ead4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f18c3ce14154eb477226aa48a12ebd32f9ead4/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "928d850fcd999ed82cf5f2cfb4e24779f973e2d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928d850fcd999ed82cf5f2cfb4e24779f973e2d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928d850fcd999ed82cf5f2cfb4e24779f973e2d4"}], "stats": {"total": 165, "additions": 163, "deletions": 2}, "files": [{"sha": "24282044fee1e2966bcf27ae7473c95e1fcecf8c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=20f18c3ce14154eb477226aa48a12ebd32f9ead4", "patch": "@@ -1,5 +1,19 @@\n 2014-01-23  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/55189\n+\t* cp-tree.h (struct language_function): Add infinite_loop and\n+\tinfinite_loops.\n+\t(current_function_infinite_loop): New.\n+\t* semantics.c (begin_maybe_infinite_loop, end_maybe_infinite_loop)\n+\t(break_maybe_infinite_loop): New.\n+\t(finish_while_stmt_cond, finish_while_stmt, begin_do_stmt)\n+\t(finish_do_stmt, finish_for_cond, finish_for_stmt)\n+\t(begin_range_for_stmt): Use them.\n+\t* decl.c (finish_function): Don't warn about missing return\n+\tif current_function_infinite_loop.\n+\t* pt.c (instantiate_decl): Copy current_function_infinite_loop.\n+\t* parser.c (cp_parser_jump_statement): Call break_maybe_infinite_loop.\n+\n \t* call.c (build_op_delete_call): Use make_tree_vector and\n \trelease_tree_vector.\n "}, {"sha": "ab75db837abafbd31052ec6ee15dc7b6aa125da8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=20f18c3ce14154eb477226aa48a12ebd32f9ead4", "patch": "@@ -1127,6 +1127,7 @@ struct GTY(()) language_function {\n   BOOL_BITFIELD returns_value : 1;\n   BOOL_BITFIELD returns_null : 1;\n   BOOL_BITFIELD returns_abnormally : 1;\n+  BOOL_BITFIELD infinite_loop: 1;\n   BOOL_BITFIELD x_in_function_try_handler : 1;\n   BOOL_BITFIELD x_in_base_initializer : 1;\n \n@@ -1136,6 +1137,9 @@ struct GTY(()) language_function {\n   htab_t GTY((param_is(struct named_label_entry))) x_named_labels;\n   cp_binding_level *bindings;\n   vec<tree, va_gc> *x_local_names;\n+  /* Tracking possibly infinite loops.  This is a vec<tree> only because\n+     vec<bool> doesn't work with gtype.  */\n+  vec<tree, va_gc> *infinite_loops;\n   htab_t GTY((param_is (struct cxx_int_tree_map))) extern_decl_map;\n };\n \n@@ -1194,6 +1198,12 @@ struct GTY(()) language_function {\n #define current_function_returns_abnormally \\\n   cp_function_chain->returns_abnormally\n \n+/* Set to 0 at beginning of a function definition, set to 1 if we see an\n+   obvious infinite loop.  This can have false positives and false\n+   negatives, so it should only be used as a heuristic.  */\n+\n+#define current_function_infinite_loop cp_function_chain->infinite_loop\n+\n /* Nonzero if we are processing a base initializer.  Zero elsewhere.  */\n #define in_base_initializer cp_function_chain->x_in_base_initializer\n \n@@ -5671,6 +5681,7 @@ extern bool perform_or_defer_access_check\t(tree, tree, tree,\n extern int stmts_are_full_exprs_p\t\t(void);\n extern void init_cp_semantics\t\t\t(void);\n extern tree do_poplevel\t\t\t\t(tree);\n+extern void break_maybe_infinite_loop\t\t(void);\n extern void add_decl_expr\t\t\t(tree);\n extern tree maybe_cleanup_point_expr_void\t(tree);\n extern tree finish_expr_stmt\t\t\t(tree);"}, {"sha": "f4819a6c9cb244b447ffc846303899036f7db300", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=20f18c3ce14154eb477226aa48a12ebd32f9ead4", "patch": "@@ -14000,6 +14000,8 @@ finish_function (int flags)\n       && !current_function_returns_value && !current_function_returns_null\n       /* Don't complain if we abort or throw.  */\n       && !current_function_returns_abnormally\n+      /* Don't complain if there's an infinite loop.  */\n+      && !current_function_infinite_loop\n       /* Don't complain if we are declared noreturn.  */\n       && !TREE_THIS_VOLATILE (fndecl)\n       && !DECL_NAME (DECL_RESULT (fndecl))\n@@ -14064,6 +14066,7 @@ finish_function (int flags)\n       f->x_return_value = NULL;\n       f->bindings = NULL;\n       f->extern_decl_map = NULL;\n+      f->infinite_loops = NULL;\n     }\n   /* Clear out the bits we don't need.  */\n   local_names = NULL;"}, {"sha": "e12a5289e031253607b53a5e73d9c1c3ec386478", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=20f18c3ce14154eb477226aa48a12ebd32f9ead4", "patch": "@@ -10641,6 +10641,8 @@ cp_parser_jump_statement (cp_parser* parser)\n \t  gcc_assert ((in_statement & IN_SWITCH_STMT)\n \t\t      || in_statement == IN_ITERATION_STMT);\n \t  statement = finish_break_stmt ();\n+\t  if (in_statement == IN_ITERATION_STMT)\n+\t    break_maybe_infinite_loop ();\n \t  break;\n \tcase IN_OMP_BLOCK:\n \t  error_at (token->location, \"invalid exit from OpenMP structured block\");"}, {"sha": "930ca292c85b4589f1d0b08ded5cbceacdc791a9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=20f18c3ce14154eb477226aa48a12ebd32f9ead4", "patch": "@@ -19670,6 +19670,10 @@ instantiate_decl (tree d, int defer_ok,\n \t     so that finish_function knows where we are.  */\n \t  input_location\n \t    = DECL_STRUCT_FUNCTION (code_pattern)->function_end_locus;\n+\n+\t  /* Remember if we saw an infinite loop in the template.  */\n+\t  current_function_infinite_loop\n+\t    = DECL_STRUCT_FUNCTION (code_pattern)->language->infinite_loop;\n \t}\n \n       /* We don't need the local specializations any more.  */"}, {"sha": "3a8dacad8ce2934d652ae400a5e4d73d0e4fde2e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=20f18c3ce14154eb477226aa48a12ebd32f9ead4", "patch": "@@ -486,6 +486,62 @@ push_cleanup (tree decl, tree cleanup, bool eh_only)\n   CLEANUP_BODY (stmt) = push_stmt_list ();\n }\n \n+/* Simple infinite loop tracking for -Wreturn-type.  We keep a stack of all\n+   the current loops, represented by 'NULL_TREE' if we've seen a possible\n+   exit, and 'error_mark_node' if not.  This is currently used only to\n+   suppress the warning about a function with no return statements, and\n+   therefore we don't bother noting returns as possible exits.  We also\n+   don't bother with gotos.  */\n+\n+static void\n+begin_maybe_infinite_loop (tree cond)\n+{\n+  /* Only track this while parsing a function, not during instantiation.  */\n+  if (!cfun || (DECL_TEMPLATE_INSTANTIATION (current_function_decl)\n+\t\t&& !processing_template_decl))\n+    return;\n+  bool maybe_infinite = true;\n+  if (cond)\n+    {\n+      cond = fold_non_dependent_expr (cond);\n+      cond = maybe_constant_value (cond);\n+      maybe_infinite = integer_nonzerop (cond);\n+    }\n+  vec_safe_push (cp_function_chain->infinite_loops,\n+\t\t maybe_infinite ? error_mark_node : NULL_TREE);\n+\n+}\n+\n+/* A break is a possible exit for the current loop.  */\n+\n+void\n+break_maybe_infinite_loop (void)\n+{\n+  if (!cfun)\n+    return;\n+  cp_function_chain->infinite_loops->last() = NULL_TREE;\n+}\n+\n+/* If we reach the end of the loop without seeing a possible exit, we have\n+   an infinite loop.  */\n+\n+static void\n+end_maybe_infinite_loop (tree cond)\n+{\n+  if (!cfun || (DECL_TEMPLATE_INSTANTIATION (current_function_decl)\n+\t\t&& !processing_template_decl))\n+    return;\n+  tree current = cp_function_chain->infinite_loops->pop();\n+  if (current != NULL_TREE)\n+    {\n+      cond = fold_non_dependent_expr (cond);\n+      cond = maybe_constant_value (cond);\n+      if (integer_nonzerop (cond))\n+\tcurrent_function_infinite_loop = 1;\n+    }\n+}\n+\n+\n /* Begin a conditional that might contain a declaration.  When generating\n    normal code, we want the declaration to appear before the statement\n    containing the conditional.  When generating template code, we want the\n@@ -732,7 +788,9 @@ begin_while_stmt (void)\n void\n finish_while_stmt_cond (tree cond, tree while_stmt, bool ivdep)\n {\n-  finish_cond (&WHILE_COND (while_stmt), maybe_convert_cond (cond));\n+  cond = maybe_convert_cond (cond);\n+  finish_cond (&WHILE_COND (while_stmt), cond);\n+  begin_maybe_infinite_loop (cond);\n   if (ivdep && cond != error_mark_node)\n     WHILE_COND (while_stmt) = build2 (ANNOTATE_EXPR,\n \t\t\t\t      TREE_TYPE (WHILE_COND (while_stmt)),\n@@ -747,6 +805,7 @@ finish_while_stmt_cond (tree cond, tree while_stmt, bool ivdep)\n void\n finish_while_stmt (tree while_stmt)\n {\n+  end_maybe_infinite_loop (boolean_true_node);\n   WHILE_BODY (while_stmt) = do_poplevel (WHILE_BODY (while_stmt));\n }\n \n@@ -757,6 +816,7 @@ tree\n begin_do_stmt (void)\n {\n   tree r = build_stmt (input_location, DO_STMT, NULL_TREE, NULL_TREE);\n+  begin_maybe_infinite_loop (boolean_true_node);\n   add_stmt (r);\n   DO_BODY (r) = push_stmt_list ();\n   return r;\n@@ -784,6 +844,7 @@ void\n finish_do_stmt (tree cond, tree do_stmt, bool ivdep)\n {\n   cond = maybe_convert_cond (cond);\n+  end_maybe_infinite_loop (cond);\n   if (ivdep && cond != error_mark_node)\n     cond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t   build_int_cst (integer_type_node, annot_expr_ivdep_kind));\n@@ -891,7 +952,9 @@ finish_for_init_stmt (tree for_stmt)\n void\n finish_for_cond (tree cond, tree for_stmt, bool ivdep)\n {\n-  finish_cond (&FOR_COND (for_stmt), maybe_convert_cond (cond));\n+  cond = maybe_convert_cond (cond);\n+  finish_cond (&FOR_COND (for_stmt), cond);\n+  begin_maybe_infinite_loop (cond);\n   if (ivdep && cond != error_mark_node)\n     FOR_COND (for_stmt) = build2 (ANNOTATE_EXPR,\n \t\t\t\t  TREE_TYPE (FOR_COND (for_stmt)),\n@@ -940,6 +1003,8 @@ finish_for_expr (tree expr, tree for_stmt)\n void\n finish_for_stmt (tree for_stmt)\n {\n+  end_maybe_infinite_loop (boolean_true_node);\n+\n   if (TREE_CODE (for_stmt) == RANGE_FOR_STMT)\n     RANGE_FOR_BODY (for_stmt) = do_poplevel (RANGE_FOR_BODY (for_stmt));\n   else\n@@ -968,6 +1033,8 @@ begin_range_for_stmt (tree scope, tree init)\n {\n   tree r;\n \n+  begin_maybe_infinite_loop (boolean_false_node);\n+\n   r = build_stmt (input_location, RANGE_FOR_STMT,\n \t\t  NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE);\n "}, {"sha": "1c4d5b8d1d563f46e0f1b9ae71380d704353f075", "filename": "gcc/testsuite/g++.dg/warn/Wreturn-type-9.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-type-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f18c3ce14154eb477226aa48a12ebd32f9ead4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-type-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-type-9.C?ref=20f18c3ce14154eb477226aa48a12ebd32f9ead4", "patch": "@@ -0,0 +1,60 @@\n+// related to PR c++/55189\n+// { dg-options \"-Wreturn-type\" }\n+\n+int f1()\n+{\n+  while (true) { }\n+}\n+int f2()\n+{\n+  while (true) { break; }\n+} // { dg-warning \"no return statement\" }\n+\n+int f3()\n+{\n+  for (;;) {}\n+}\n+int f4()\n+{\n+  for (;;) {break;}\n+} // { dg-warning \"no return statement\" }\n+\n+int f5()\n+{\n+  do {} while(true);\n+}\n+int f6()\n+{\n+  do {break;} while(true);\n+} // { dg-warning \"no return statement\" }\n+\n+int f7()\n+{\n+  for(;;)\n+    while (true) {break;}\n+}\n+\n+int f8()\n+{\n+  for(;;)\n+    {\n+      while (true) {}\n+      break;\n+    }\n+}\n+\n+template <class T>\n+T f9()\n+{\n+  for(;;) { }\n+}\n+\n+template int f9();\n+\n+template <class T>\n+T f10()\n+{\n+  for(;;) { break; }\n+} // { dg-warning \"no return statement\" }\n+\n+template int f10();"}]}