{"sha": "b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "node_id": "C_kwDOANBUbNoAKGIxYzlhYzE0YTA2YTJjMGRkNGFjYjg3NThmM2M4OGMyYzYxMGEzMWU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-07T20:00:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-07T20:00:19Z"}, "message": "Merge #1367\n\n1367: Initial support for matches on tuples r=dafaust a=dafaust\n\nInitial work on supporting more complex match expressions, starting with tuples. It's proven to be quite a bit more complicated than I originally expected. Still this implementation is very naive, probably very poor performance, and skips all the nuanced stuff like bindings in patterns and pattern guards.\r\n\r\nOverview\r\nThe general idea is that we lower `MatchExpr`s to `SWITCH_EXPR` trees, but a switch can only operate on one value at a time. When scrutinizing a tuple, we can't build a switch that checks all the elements at once. So instead, just before lowering to trees, we construct a new set of nested match expressions which tests the tuple one element at a time, and is (hopefully) semantically identical to the original match. These new nested matches are simplified, so that each one tests only one thing and therefore *can* lower directly to a `SWITCH_EXPR`.\r\n\r\nTo see an example, this\r\n```text\r\nmatch (tupA, tupB, tupC) {\r\n  (a1, b1, c1) => { blk1 }\r\n  (a2, b2, c2) => { blk2 }\r\n  (a1, b3, c3) => { blk3 }\r\n  ...\r\n  _ => { blk4 }\r\n}\r\n```\r\nafter one step becomes\r\n```text\r\nmatch tupA {\r\n  a1 => {\r\n    match (tupB, tupC) {\r\n      (b1, c1) => { blk1 }\r\n      (b3, c3) => { blk3 }\r\n      ...\r\n      _ => { blk4 }\r\n    }\r\n  a2 => {\r\n    match (tupB, tupC) {\r\n      (b2, c2) => { blk2 }\r\n      ...\r\n      _ => { blk4 }\r\n    }\r\n  }\r\n  _ => { blk4 }\r\n}\r\n```\r\nRepeat until all matches are fully simplified, then compile it all into trees.\r\n\r\nNow, we might end up with a lot of duplicated basic blocks here as a result, but the optimization in GENERIC and GIMPLE (further on in gcc) is very good and knows how to take care of that for us.\r\n\r\nThis approach seems somewhat similar to how rustc lowers HIR to MIR, which is hopefully a good sign :)\r\n\r\nAddresses: #1081\n\nCo-authored-by: David Faust <david.faust@oracle.com>", "tree": {"sha": "2592a09086138cd82b633cd1902f9c62cc52dcf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2592a09086138cd82b633cd1902f9c62cc52dcf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixztTCRBK7hj4Ov3rIwAA7wEIACwmIHYUJ9nKFY2NDoKIIAqR\nKNTXszkVVyMRmOfwn9VkcM8IB9oBpSnGfYq0QzBYbSTaIrLhXLZE+qgPCF83QelP\n3dxiyoCq1r8Cwoe0G97QoCAC91IEbWGAwIXUygAnWc5Np+WkNcBH7yVnOZz9+UnB\nA/PM+qMv37Rt6mtnCsQONjMCVb8iXnqAS6rqBR3GxMJeTxWMM6auIf2TWdHOe98S\ndpsyIzpu0DpX/vKk9Sn5HNVvkNQXxyOc5Os4D+HZ6Ek/1baudwgs1mKyXEad8Qyf\n98rml65vpMW4Orl8F4X90jwiqZ4+RNKA6YhqcHr0lUUJtfpmm5khBlp8a2x+sdA=\n=cSmW\n-----END PGP SIGNATURE-----\n", "payload": "tree 2592a09086138cd82b633cd1902f9c62cc52dcf5\nparent a5c82a1d2b430585b915801a2ae1b73f1ea65f60\nparent b7c4aa942fa828038106105524af2c568acca7ac\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1657224019 +0000\ncommitter GitHub <noreply@github.com> 1657224019 +0000\n\nMerge #1367\n\n1367: Initial support for matches on tuples r=dafaust a=dafaust\n\nInitial work on supporting more complex match expressions, starting with tuples. It's proven to be quite a bit more complicated than I originally expected. Still this implementation is very naive, probably very poor performance, and skips all the nuanced stuff like bindings in patterns and pattern guards.\r\n\r\nOverview\r\nThe general idea is that we lower `MatchExpr`s to `SWITCH_EXPR` trees, but a switch can only operate on one value at a time. When scrutinizing a tuple, we can't build a switch that checks all the elements at once. So instead, just before lowering to trees, we construct a new set of nested match expressions which tests the tuple one element at a time, and is (hopefully) semantically identical to the original match. These new nested matches are simplified, so that each one tests only one thing and therefore *can* lower directly to a `SWITCH_EXPR`.\r\n\r\nTo see an example, this\r\n```text\r\nmatch (tupA, tupB, tupC) {\r\n  (a1, b1, c1) => { blk1 }\r\n  (a2, b2, c2) => { blk2 }\r\n  (a1, b3, c3) => { blk3 }\r\n  ...\r\n  _ => { blk4 }\r\n}\r\n```\r\nafter one step becomes\r\n```text\r\nmatch tupA {\r\n  a1 => {\r\n    match (tupB, tupC) {\r\n      (b1, c1) => { blk1 }\r\n      (b3, c3) => { blk3 }\r\n      ...\r\n      _ => { blk4 }\r\n    }\r\n  a2 => {\r\n    match (tupB, tupC) {\r\n      (b2, c2) => { blk2 }\r\n      ...\r\n      _ => { blk4 }\r\n    }\r\n  }\r\n  _ => { blk4 }\r\n}\r\n```\r\nRepeat until all matches are fully simplified, then compile it all into trees.\r\n\r\nNow, we might end up with a lot of duplicated basic blocks here as a result, but the optimization in GENERIC and GIMPLE (further on in gcc) is very good and knows how to take care of that for us.\r\n\r\nThis approach seems somewhat similar to how rustc lowers HIR to MIR, which is hopefully a good sign :)\r\n\r\nAddresses: #1081\n\nCo-authored-by: David Faust <david.faust@oracle.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5c82a1d2b430585b915801a2ae1b73f1ea65f60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c82a1d2b430585b915801a2ae1b73f1ea65f60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c82a1d2b430585b915801a2ae1b73f1ea65f60"}, {"sha": "b7c4aa942fa828038106105524af2c568acca7ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c4aa942fa828038106105524af2c568acca7ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c4aa942fa828038106105524af2c568acca7ac"}], "stats": {"total": 519, "additions": 494, "deletions": 25}, "files": [{"sha": "3740c801d6f5de0b66a66229f7ab1be66f5b08f7", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 447, "deletions": 25, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "patch": "@@ -181,6 +181,369 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n \t\t\t\t\t\tknown_valid, expr.get_locus ());\n }\n \n+// Helper for sort_tuple_patterns.\n+// Determine whether Patterns a and b are really the same pattern.\n+// FIXME: This is a nasty hack to avoid properly implementing a comparison\n+//        for Patterns, which we really probably do want at some point.\n+static bool\n+patterns_mergeable (HIR::Pattern *a, HIR::Pattern *b)\n+{\n+  if (!a || !b)\n+    return false;\n+\n+  HIR::Pattern::PatternType pat_type = a->get_pattern_type ();\n+  if (b->get_pattern_type () != pat_type)\n+    return false;\n+\n+  switch (pat_type)\n+    {\n+      case HIR::Pattern::PatternType::PATH: {\n+\t// FIXME: this is far too naive\n+\tHIR::PathPattern &aref = *static_cast<HIR::PathPattern *> (a);\n+\tHIR::PathPattern &bref = *static_cast<HIR::PathPattern *> (b);\n+\tif (aref.get_num_segments () != bref.get_num_segments ())\n+\t  return false;\n+\n+\tconst auto &asegs = aref.get_segments ();\n+\tconst auto &bsegs = bref.get_segments ();\n+\tfor (size_t i = 0; i < asegs.size (); i++)\n+\t  {\n+\t    if (asegs[i].as_string () != bsegs[i].as_string ())\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+      break;\n+      case HIR::Pattern::PatternType::LITERAL: {\n+\tHIR::LiteralPattern &aref = *static_cast<HIR::LiteralPattern *> (a);\n+\tHIR::LiteralPattern &bref = *static_cast<HIR::LiteralPattern *> (b);\n+\treturn aref.get_literal ().is_equal (bref.get_literal ());\n+      }\n+      break;\n+      case HIR::Pattern::PatternType::IDENTIFIER: {\n+\t// TODO\n+      }\n+      break;\n+    case HIR::Pattern::PatternType::WILDCARD:\n+      return true;\n+      break;\n+\n+      // TODO\n+\n+    default:;\n+    }\n+  return false;\n+}\n+\n+// A little container for rearranging the patterns and cases in a match\n+// expression while simplifying.\n+struct PatternMerge\n+{\n+  std::unique_ptr<HIR::MatchCase> wildcard;\n+  std::vector<std::unique_ptr<HIR::Pattern>> heads;\n+  std::vector<std::vector<HIR::MatchCase>> cases;\n+};\n+\n+// Helper for simplify_tuple_match.\n+// For each tuple pattern in a given match, pull out the first elt of the\n+// tuple and construct a new MatchCase with the remaining tuple elts as the\n+// pattern. Return a mapping from each _unique_ first tuple element to a\n+// vec of cases for a new match.\n+//\n+// FIXME: This used to be a std::map<Pattern, Vec<MatchCase>>, but it doesn't\n+// actually work like we want - the Pattern includes an HIR ID, which is unique\n+// per Pattern object. This means we don't have a good means for comparing\n+// Patterns. It would probably be best to actually implement a means of\n+// properly comparing patterns, and then use an actual map.\n+//\n+static struct PatternMerge\n+sort_tuple_patterns (HIR::MatchExpr &expr)\n+{\n+  rust_assert (expr.get_scrutinee_expr ()->get_expression_type ()\n+\t       == HIR::Expr::ExprType::Tuple);\n+\n+  struct PatternMerge result;\n+  result.wildcard = nullptr;\n+  result.heads = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+  result.cases = std::vector<std::vector<HIR::MatchCase>> ();\n+\n+  for (auto &match_case : expr.get_match_cases ())\n+    {\n+      HIR::MatchArm &case_arm = match_case.get_arm ();\n+\n+      // FIXME: Note we are only dealing with the first pattern in the arm.\n+      // The patterns vector in the arm might hold many patterns, which are the\n+      // patterns separated by the '|' token. Rustc abstracts these as \"Or\"\n+      // patterns, and part of its simplification process is to get rid of them.\n+      // We should get rid of the ORs too, maybe here or earlier than here?\n+      auto pat = case_arm.get_patterns ()[0]->clone_pattern ();\n+\n+      // Record wildcards so we can add them in inner matches.\n+      if (pat->get_pattern_type () == HIR::Pattern::PatternType::WILDCARD)\n+\t{\n+\t  // The *whole* pattern is a wild card (_).\n+\t  result.wildcard\n+\t    = std::unique_ptr<HIR::MatchCase> (new HIR::MatchCase (match_case));\n+\t  continue;\n+\t}\n+\n+      rust_assert (pat->get_pattern_type ()\n+\t\t   == HIR::Pattern::PatternType::TUPLE);\n+\n+      auto ref = *static_cast<HIR::TuplePattern *> (pat.get ());\n+\n+      rust_assert (ref.has_tuple_pattern_items ());\n+\n+      auto items\n+\t= HIR::TuplePattern (ref).get_items ()->clone_tuple_pattern_items ();\n+      if (items->get_pattern_type ()\n+\t  == HIR::TuplePatternItems::TuplePatternItemType::MULTIPLE)\n+\t{\n+\t  auto items_ref\n+\t    = *static_cast<HIR::TuplePatternItemsMultiple *> (items.get ());\n+\n+\t  // Pop the first pattern out\n+\t  auto patterns = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+\t  auto first = items_ref.get_patterns ()[0]->clone_pattern ();\n+\t  for (auto p = items_ref.get_patterns ().begin () + 1;\n+\t       p != items_ref.get_patterns ().end (); p++)\n+\t    {\n+\t      patterns.push_back ((*p)->clone_pattern ());\n+\t    }\n+\n+\t  // if there is only one pattern left, don't make a tuple out of it\n+\t  std::unique_ptr<HIR::Pattern> result_pattern;\n+\t  if (patterns.size () == 1)\n+\t    {\n+\t      result_pattern = std::move (patterns[0]);\n+\t    }\n+\t  else\n+\t    {\n+\t      auto new_items = std::unique_ptr<HIR::TuplePatternItems> (\n+\t\tnew HIR::TuplePatternItemsMultiple (std::move (patterns)));\n+\n+\t      // Construct a TuplePattern from the rest of the patterns\n+\t      result_pattern = std::unique_ptr<HIR::Pattern> (\n+\t\tnew HIR::TuplePattern (ref.get_pattern_mappings (),\n+\t\t\t\t       std::move (new_items),\n+\t\t\t\t       ref.get_locus ()));\n+\t    }\n+\n+\t  // I don't know why we need to make foo separately here but\n+\t  // using the { new_tuple } syntax in new_arm constructor does not\n+\t  // compile.\n+\t  auto foo = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+\t  foo.emplace_back (std::move (result_pattern));\n+\t  HIR::MatchArm new_arm (std::move (foo), Location (), nullptr,\n+\t\t\t\t AST::AttrVec ());\n+\n+\t  HIR::MatchCase new_case (match_case.get_mappings (), new_arm,\n+\t\t\t\t   match_case.get_expr ()->clone_expr ());\n+\n+\t  bool pushed = false;\n+\t  for (size_t i = 0; i < result.heads.size (); i++)\n+\t    {\n+\t      if (patterns_mergeable (result.heads[i].get (), first.get ()))\n+\t\t{\n+\t\t  result.cases[i].push_back (new_case);\n+\t\t  pushed = true;\n+\t\t}\n+\t    }\n+\n+\t  if (!pushed)\n+\t    {\n+\t      result.heads.push_back (std::move (first));\n+\t      result.cases.push_back ({new_case});\n+\t    }\n+\t}\n+      else /* TuplePatternItemType::RANGED */\n+\t{\n+\t  // FIXME\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+// Helper for CompileExpr::visit (HIR::MatchExpr).\n+// Given a MatchExpr where the scrutinee is some kind of tuple, build an\n+// equivalent match where only one element of the tuple is examined at a time.\n+// This resulting match can then be lowered to a SWITCH_EXPR tree directly.\n+//\n+// The approach is as follows:\n+// 1. Split the scrutinee and each pattern into the first (head) and the\n+//    rest (tail).\n+// 2. Build a mapping of unique pattern heads to the cases (tail and expr)\n+//    that shared that pattern head in the original match.\n+//    (This is the job of sort_tuple_patterns ()).\n+// 3. For each unique pattern head, build a new MatchCase where the pattern\n+//    is the unique head, and the expression is a new match where:\n+//    - The scrutinee is the tail of the original scrutinee\n+//    - The cases are are those built by the mapping in step 2, i.e. the\n+//      tails of the patterns and the corresponing expressions from the\n+//      original match expression.\n+// 4. Do this recursively for each inner match, until there is nothing more\n+//    to simplify.\n+// 5. Build the resulting match which scrutinizes the head of the original\n+//    scrutinee, using the cases built in step 3.\n+static HIR::MatchExpr\n+simplify_tuple_match (HIR::MatchExpr &expr)\n+{\n+  if (expr.get_scrutinee_expr ()->get_expression_type ()\n+      != HIR::Expr::ExprType::Tuple)\n+    return expr;\n+\n+  auto ref = *static_cast<HIR::TupleExpr *> (expr.get_scrutinee_expr ().get ());\n+\n+  auto &tail = ref.get_tuple_elems ();\n+  rust_assert (tail.size () > 1);\n+\n+  auto head = std::move (tail[0]);\n+  tail.erase (tail.begin (), tail.begin () + 1);\n+\n+  // e.g.\n+  // match (tupA, tupB, tupC) {\n+  //   (a1, b1, c1) => { blk1 },\n+  //   (a2, b2, c2) => { blk2 },\n+  //   (a1, b3, c3) => { blk3 },\n+  // }\n+  // tail = (tupB, tupC)\n+  // head = tupA\n+\n+  // Make sure the tail is only a tuple if it consists of at least 2 elements.\n+  std::unique_ptr<HIR::Expr> remaining;\n+  if (tail.size () == 1)\n+    remaining = std::move (tail[0]);\n+  else\n+    remaining = std::unique_ptr<HIR::Expr> (\n+      new HIR::TupleExpr (ref.get_mappings (), std::move (tail),\n+\t\t\t  AST::AttrVec (), ref.get_outer_attrs (),\n+\t\t\t  ref.get_locus ()));\n+\n+  // e.g.\n+  // a1 -> [(b1, c1) => { blk1 },\n+  //        (b3, c3) => { blk3 }]\n+  // a2 -> [(b2, c2) => { blk2 }]\n+  struct PatternMerge map = sort_tuple_patterns (expr);\n+\n+  std::vector<HIR::MatchCase> cases;\n+  // Construct the inner match for each unique first elt of the tuple\n+  // patterns\n+  for (size_t i = 0; i < map.heads.size (); i++)\n+    {\n+      auto inner_match_cases = map.cases[i];\n+\n+      // If there is a wildcard at the outer match level, then need to\n+      // propegate the wildcard case into *every* inner match.\n+      // FIXME: It is probably not correct to add this unconditionally, what if\n+      // we have a pattern like (a, _, c)? Then there is already a wildcard in\n+      // the inner matches, and having two will cause two 'default:' blocks\n+      // which is an error.\n+      if (map.wildcard != nullptr)\n+\t{\n+\t  inner_match_cases.push_back (*(map.wildcard.get ()));\n+\t}\n+\n+      // match (tupB, tupC) {\n+      //   (b1, c1) => { blk1 },\n+      //   (b3, c3) => { blk3 }\n+      // }\n+      HIR::MatchExpr inner_match (expr.get_mappings (),\n+\t\t\t\t  remaining->clone_expr (), inner_match_cases,\n+\t\t\t\t  AST::AttrVec (), expr.get_outer_attrs (),\n+\t\t\t\t  expr.get_locus ());\n+\n+      inner_match = simplify_tuple_match (inner_match);\n+\n+      auto outer_arm_pat = std::vector<std::unique_ptr<HIR::Pattern>> ();\n+      outer_arm_pat.emplace_back (map.heads[i]->clone_pattern ());\n+\n+      HIR::MatchArm outer_arm (std::move (outer_arm_pat), expr.get_locus ());\n+\n+      // Need to move the inner match to the heap and put it in a unique_ptr to\n+      // build the actual match case of the outer expression\n+      // auto inner_expr = std::unique_ptr<HIR::Expr> (new HIR::MatchExpr\n+      // (inner_match));\n+      auto inner_expr = inner_match.clone_expr ();\n+\n+      // a1 => match (tupB, tupC) { ... }\n+      HIR::MatchCase outer_case (expr.get_mappings (), outer_arm,\n+\t\t\t\t std::move (inner_expr));\n+\n+      cases.push_back (outer_case);\n+    }\n+\n+  // If there was a wildcard, make sure to include it at the outer match level\n+  // too.\n+  if (map.wildcard != nullptr)\n+    {\n+      cases.push_back (*(map.wildcard.get ()));\n+    }\n+\n+  // match tupA {\n+  //   a1 => match (tupB, tupC) {\n+  //     (b1, c1) => { blk1 },\n+  //     (b3, c3) => { blk3 }\n+  //   }\n+  //   a2 => match (tupB, tupC) {\n+  //     (b2, c2) => { blk2 }\n+  //   }\n+  // }\n+  HIR::MatchExpr outer_match (expr.get_mappings (), std::move (head), cases,\n+\t\t\t      AST::AttrVec (), expr.get_outer_attrs (),\n+\t\t\t      expr.get_locus ());\n+\n+  return outer_match;\n+}\n+\n+// Helper for CompileExpr::visit (HIR::MatchExpr).\n+// Check that the scrutinee of EXPR is a valid kind of expression to match on.\n+// Return the TypeKind of the scrutinee if it is valid, or TyTy::TypeKind::ERROR\n+// if not.\n+static TyTy::TypeKind\n+check_match_scrutinee (HIR::MatchExpr &expr, Context *ctx)\n+{\n+  TyTy::BaseType *scrutinee_expr_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_scrutinee_expr ()->get_mappings ().get_hirid (),\n+\t&scrutinee_expr_tyty))\n+    {\n+      return TyTy::TypeKind::ERROR;\n+    }\n+\n+  TyTy::TypeKind scrutinee_kind = scrutinee_expr_tyty->get_kind ();\n+  rust_assert ((TyTy::is_primitive_type_kind (scrutinee_kind)\n+\t\t&& scrutinee_kind != TyTy::TypeKind::NEVER)\n+\t       || scrutinee_kind == TyTy::TypeKind::ADT\n+\t       || scrutinee_kind == TyTy::TypeKind::TUPLE);\n+\n+  if (scrutinee_kind == TyTy::TypeKind::ADT)\n+    {\n+      // this will need to change but for now the first pass implementation,\n+      // lets assert this is the case\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (scrutinee_expr_tyty);\n+      rust_assert (adt->is_enum ());\n+      rust_assert (adt->number_of_variants () > 0);\n+    }\n+  else if (scrutinee_kind == TyTy::TypeKind::FLOAT)\n+    {\n+      // FIXME: CASE_LABEL_EXPR does not support floating point types.\n+      // Find another way to compile these.\n+      rust_sorry_at (expr.get_locus (),\n+\t\t     \"match on floating-point types is not yet supported\");\n+    }\n+\n+  TyTy::BaseType *expr_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &expr_tyty))\n+    {\n+      return TyTy::TypeKind::ERROR;\n+    }\n+\n+  return scrutinee_kind;\n+}\n+\n void\n CompileExpr::visit (HIR::MatchExpr &expr)\n {\n@@ -213,36 +576,13 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n        the control flow graph.  */\n   // DEFTREECODE (CASE_LABEL_EXPR, \"case_label_expr\", tcc_statement, 4)\n \n-  TyTy::BaseType *scrutinee_expr_tyty = nullptr;\n-  if (!ctx->get_tyctx ()->lookup_type (\n-\texpr.get_scrutinee_expr ()->get_mappings ().get_hirid (),\n-\t&scrutinee_expr_tyty))\n+  TyTy::TypeKind scrutinee_kind = check_match_scrutinee (expr, ctx);\n+  if (scrutinee_kind == TyTy::TypeKind::ERROR)\n     {\n       translated = error_mark_node;\n       return;\n     }\n \n-  TyTy::TypeKind scrutinee_kind = scrutinee_expr_tyty->get_kind ();\n-  rust_assert ((TyTy::is_primitive_type_kind (scrutinee_kind)\n-\t\t&& scrutinee_kind != TyTy::TypeKind::NEVER)\n-\t       || scrutinee_kind == TyTy::TypeKind::ADT);\n-\n-  if (scrutinee_kind == TyTy::TypeKind::ADT)\n-    {\n-      // this will need to change but for now the first pass implementation,\n-      // lets assert this is the case\n-      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (scrutinee_expr_tyty);\n-      rust_assert (adt->is_enum ());\n-      rust_assert (adt->number_of_variants () > 0);\n-    }\n-  else if (scrutinee_kind == TyTy::TypeKind::FLOAT)\n-    {\n-      // FIXME: CASE_LABEL_EXPR does not support floating point types.\n-      // Find another way to compile these.\n-      rust_sorry_at (expr.get_locus (),\n-\t\t     \"match on floating-point types is not yet supported\");\n-    }\n-\n   TyTy::BaseType *expr_tyty = nullptr;\n   if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n \t\t\t\t       &expr_tyty))\n@@ -290,6 +630,88 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n \t  scrutinee_first_record_expr, 0,\n \t  expr.get_scrutinee_expr ()->get_locus ());\n     }\n+  else if (scrutinee_kind == TyTy::TypeKind::TUPLE)\n+    {\n+      // match on tuple becomes a series of nested switches, with one level\n+      // for each element of the tuple from left to right.\n+      auto exprtype = expr.get_scrutinee_expr ()->get_expression_type ();\n+      switch (exprtype)\n+\t{\n+\t  case HIR::Expr::ExprType::Tuple: {\n+\t    // Build an equivalent expression which is nicer to lower.\n+\t    HIR::MatchExpr outer_match = simplify_tuple_match (expr);\n+\n+\t    // We've rearranged the match into something that lowers better\n+\t    // to GENERIC trees.\n+\t    // For actually doing the lowering we need to compile the match\n+\t    // we've just made. But we're half-way through compiling the\n+\t    // original one.\n+\t    // ...\n+\t    // For now, let's just replace the original with the rearranged one\n+\t    // we just made, and compile that instead. What could go wrong? :)\n+\t    //\n+\t    // FIXME: What about when we decide a temporary is needed above?\n+\t    //        We might have already pushed a statement for it that\n+\t    //        we no longer need. Probably need to rearrange the order\n+\t    //        of these steps.\n+\t    expr = outer_match;\n+\n+\t    scrutinee_kind = check_match_scrutinee (expr, ctx);\n+\t    if (scrutinee_kind == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\ttranslated = error_mark_node;\n+\t\treturn;\n+\t      }\n+\n+\t    // Now compile the scrutinee of the simplified match.\n+\t    // FIXME: this part is duplicated from above.\n+\t    match_scrutinee_expr\n+\t      = CompileExpr::Compile (expr.get_scrutinee_expr ().get (), ctx);\n+\n+\t    if (TyTy::is_primitive_type_kind (scrutinee_kind))\n+\t      {\n+\t\tmatch_scrutinee_expr_qualifier_expr = match_scrutinee_expr;\n+\t      }\n+\t    else if (scrutinee_kind == TyTy::TypeKind::ADT)\n+\t      {\n+\t\t// need to access qualifier the field, if we use QUAL_UNION_TYPE\n+\t\t// this would be DECL_QUALIFIER i think. For now this will just\n+\t\t// access the first record field and its respective qualifier\n+\t\t// because it will always be set because this is all a big\n+\t\t// special union\n+\t\ttree scrutinee_first_record_expr\n+\t\t  = ctx->get_backend ()->struct_field_expression (\n+\t\t    match_scrutinee_expr, 0,\n+\t\t    expr.get_scrutinee_expr ()->get_locus ());\n+\t\tmatch_scrutinee_expr_qualifier_expr\n+\t\t  = ctx->get_backend ()->struct_field_expression (\n+\t\t    scrutinee_first_record_expr, 0,\n+\t\t    expr.get_scrutinee_expr ()->get_locus ());\n+\t      }\n+\t    else\n+\t      {\n+\t\t// FIXME: There are other cases, but it better not be a Tuple\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\t  break;\n+\n+\t  case HIR::Expr::ExprType::Ident: {\n+\t    // FIXME\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::Expr::ExprType::Path: {\n+\t    // FIXME\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n   else\n     {\n       // FIXME: match on other types of expressions not yet implemented."}, {"sha": "ff4c39e4a2a521d10a330912b0393d2d29e1c4bb", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "patch": "@@ -122,6 +122,12 @@ struct Literal\n \n   // Returns whether literal is in an invalid state.\n   bool is_error () const { return value_as_string == \"\"; }\n+\n+  bool is_equal (Literal &other)\n+  {\n+    return value_as_string == other.value_as_string && type == other.type\n+\t   && type_hint == other.type_hint;\n+  }\n };\n \n /* Base statement abstract class. Note that most \"statements\" are not allowed in"}, {"sha": "1874062891267671b82c1cc3db5f56203dab6acd", "filename": "gcc/testsuite/rust/execute/torture/match_tuple1.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_tuple1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_tuple1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_tuple1.rs?ref=b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "patch": "@@ -0,0 +1,41 @@\n+// { dg-output \"x:15\\ny:20\\n\" }\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+enum Foo {\n+    A,\n+    B,\n+}\n+\n+fn inspect(f: Foo, g: u8) -> i32 {\n+    match (f, g) {\n+        (Foo::A, 1) => {\n+            return 5;\n+        }\n+\n+        (Foo::A, 2) => {\n+            return 10;\n+        }\n+\n+        (Foo::B, 2) => {\n+            return 15;\n+        }\n+\n+        _ => {\n+            return 20;\n+        }\n+    }\n+    return 25;\n+}\n+\n+fn main () -> i32 {\n+    let x = inspect (Foo::B, 2);\n+    let y = inspect (Foo::B, 1);\n+\n+    printf (\"x:%d\\n\" as *const str as *const i8, x);\n+    printf (\"y:%d\\n\" as *const str as *const i8, y);\n+\n+    y - x - 5\n+}"}]}