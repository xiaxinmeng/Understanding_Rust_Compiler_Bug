{"sha": "6a0d6e7ca9b9e338e82572db79c26168684a7441", "node_id": "C_kwDOANBUbNoAKDZhMGQ2ZTdjYTliOWUzMzhlODI1NzJkYjc5YzI2MTY4Njg0YTc0NDE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-15T09:22:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-15T09:22:30Z"}, "message": "openmp: Make finalize_task_copyfn order reproduceable [PR104517]\n\nThe following testcase fails -fcompare-debug, because finalize_task_copyfn\nwas invoked from splay tree destruction, whose order can in some cases\ndepend on -g/-g0.  The fix is to queue the task stmts that need copyfn\nin a vector and run finalize_task_copyfn on elements of that vector.\n\n2022-02-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/104517\n\t* omp-low.cc (task_cpyfns): New variable.\n\t(delete_omp_context): Don't call finalize_task_copyfn from here.\n\t(create_task_copyfn): Push task_stmt into task_cpyfns.\n\t(execute_lower_omp): Call finalize_task_copyfn here on entries from\n\ttask_cpyfns vector and release the vector.\n\n\t* gcc.dg/gomp/pr104517.c: New test.", "tree": {"sha": "27dd704fd392c491ede77c75bdf6834799e37649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27dd704fd392c491ede77c75bdf6834799e37649"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a0d6e7ca9b9e338e82572db79c26168684a7441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0d6e7ca9b9e338e82572db79c26168684a7441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a0d6e7ca9b9e338e82572db79c26168684a7441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0d6e7ca9b9e338e82572db79c26168684a7441/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c3309e3d0f5cb8f298f7604848d115f0992e04f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c3309e3d0f5cb8f298f7604848d115f0992e04f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c3309e3d0f5cb8f298f7604848d115f0992e04f"}], "stats": {"total": 63, "additions": 60, "deletions": 3}, "files": [{"sha": "77176efe715ea3b1964111b074f8490636f71f54", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0d6e7ca9b9e338e82572db79c26168684a7441/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0d6e7ca9b9e338e82572db79c26168684a7441/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=6a0d6e7ca9b9e338e82572db79c26168684a7441", "patch": "@@ -191,6 +191,7 @@ static int target_nesting_level;\n static bitmap task_shared_vars;\n static bitmap global_nonaddressable_vars;\n static vec<omp_context *> taskreg_contexts;\n+static vec<gomp_task *> task_cpyfns;\n \n static void scan_omp (gimple_seq *, omp_context *);\n static tree scan_omp_1_op (tree *, int *, void *);\n@@ -1082,9 +1083,6 @@ delete_omp_context (splay_tree_value value)\n \tDECL_ABSTRACT_ORIGIN (t) = NULL;\n     }\n \n-  if (is_task_ctx (ctx))\n-    finalize_task_copyfn (as_a <gomp_task *> (ctx->stmt));\n-\n   if (ctx->task_reduction_map)\n     {\n       ctx->task_reductions.release ();\n@@ -11951,6 +11949,7 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)\n   size_t looptempno = 0;\n \n   child_fn = gimple_omp_task_copy_fn (task_stmt);\n+  task_cpyfns.safe_push (task_stmt);\n   child_cfun = DECL_STRUCT_FUNCTION (child_fn);\n   gcc_assert (child_cfun->cfg == NULL);\n   DECL_SAVED_TREE (child_fn) = alloc_stmt_list ();\n@@ -14475,6 +14474,10 @@ execute_lower_omp (void)\n       && (TREE_CODE (TREE_TYPE (DECL_ARGUMENTS (current_function_decl)))\n \t  == POINTER_TYPE))\n     remove_member_access_dummy_vars (DECL_INITIAL (current_function_decl));\n+\n+  for (auto task_stmt : task_cpyfns)\n+    finalize_task_copyfn (task_stmt);\n+  task_cpyfns.release ();\n   return 0;\n }\n "}, {"sha": "efb3175beb3dd6a7102545efbc35e2ebdfa181f5", "filename": "gcc/testsuite/gcc.dg/gomp/pr104517.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0d6e7ca9b9e338e82572db79c26168684a7441/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr104517.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0d6e7ca9b9e338e82572db79c26168684a7441/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr104517.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr104517.c?ref=6a0d6e7ca9b9e338e82572db79c26168684a7441", "patch": "@@ -0,0 +1,54 @@\n+/* PR debug/104517 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fcompare-debug -fopenmp -fno-tree-ter -save-temps\" } */\n+\n+enum {\n+  omp_default_mem_alloc,\n+  omp_large_cap_mem_alloc,\n+  omp_const_mem_alloc,\n+  omp_high_bw_mem_alloc\n+} omp_allocator_handle_t;\n+\n+int t, bar_nte, bar_tl, bar_i3, bar_dd;\n+\n+#pragma omp threadprivate(t)\n+#pragma omp declare target\n+int f, l, ll, r, r2;\n+#pragma omp end declare target\n+\n+void\n+bar (int *idp, int s, int nth, int g, int nta, int fi, int pp, int *q,\n+     int ntm)\n+{\n+  int p = 0, i2 = 0, i1 = 0, m = 0, d = 0;\n+\n+#pragma omp target parallel for                               \\\n+  device(p) firstprivate (f) allocate (f) in_reduction(+:r2)\n+  for (int i = 0; i < 4; i++)\n+    ll++;\n+\n+#pragma omp target parallel for                                         \\\n+  device(d) map (m)                                                     \\\n+  if (target: p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) \\\n+  if (parallel: i2) reduction(+:r) num_threads (nth) linear (ll)        \\\n+  schedule(static) collapse(1) nowait depend(inout: d) allocate (f)     \\\n+  in_reduction(+:r2)\n+  for (int i = 0; i < 4; i++)\n+    ll++;\n+\n+#pragma omp taskloop simd firstprivate(f) lastprivate(s) grainsize(g) \\\n+  collapse(1) untied if (i1) final(fi) mergeable nogroup              \\\n+  priority(pp) linear(ll) aligned(q) allocate(f)\n+  for (int i = 0; i < 4; i++)\n+    ll++;\n+\n+#pragma omp taskloop simd firstprivate(f) lastprivate(s) num_tasks(nta) \\\n+  collapse(1) if (i1) final(fi) priority(pp) safelen(8) simdlen(4)      \\\n+  linear(ll) aligned(q) nontemporal(ntm) order(concurrent) allocate(f)\n+  for (int i = 0; i < 4; i++)\n+    ll++;\n+\n+#pragma omp parallel master firstprivate(f) shared(nth) proc_bind(spread) \\\n+  copyin(t) allocate(f)\n+  ;\n+}"}]}