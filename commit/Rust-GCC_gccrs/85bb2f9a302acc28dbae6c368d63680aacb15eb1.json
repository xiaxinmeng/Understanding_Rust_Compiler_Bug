{"sha": "85bb2f9a302acc28dbae6c368d63680aacb15eb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODViYjJmOWEzMDJhY2MyOGRiYWU2YzM2OGQ2MzY4MGFhY2IxNWViMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-01-30T11:19:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-01-30T11:19:47Z"}, "message": "re PR target/83008 ([performance] Is it better to avoid extra instructions in data passing between loops?)\n\n2018-01-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/83008\n\t* tree-vect-slp.c (vect_analyze_slp_cost_1): Properly cost\n\tinvariant and constant vector uses in stmts when they need\n\tmore than one stmt.\n\nFrom-SVN: r257181", "tree": {"sha": "072e291e2ce4aaf94d47041c5794b28c544d145e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/072e291e2ce4aaf94d47041c5794b28c544d145e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85bb2f9a302acc28dbae6c368d63680aacb15eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85bb2f9a302acc28dbae6c368d63680aacb15eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85bb2f9a302acc28dbae6c368d63680aacb15eb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85bb2f9a302acc28dbae6c368d63680aacb15eb1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "924d6d0b69ac1db29335100e81406f5e6cd04ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924d6d0b69ac1db29335100e81406f5e6cd04ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/924d6d0b69ac1db29335100e81406f5e6cd04ff3"}], "stats": {"total": 63, "additions": 54, "deletions": 9}, "files": [{"sha": "7be83e9930d4d62803fdff2f58df87ef079cf6a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bb2f9a302acc28dbae6c368d63680aacb15eb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bb2f9a302acc28dbae6c368d63680aacb15eb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85bb2f9a302acc28dbae6c368d63680aacb15eb1", "patch": "@@ -1,3 +1,10 @@\n+2018-01-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/83008\n+\t* tree-vect-slp.c (vect_analyze_slp_cost_1): Properly cost\n+\tinvariant and constant vector uses in stmts when they need\n+\tmore than one stmt.\n+\n 2018-01-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR bootstrap/84017"}, {"sha": "ca28632d6ba92b234860517d59a124535b67e527", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bb2f9a302acc28dbae6c368d63680aacb15eb1/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bb2f9a302acc28dbae6c368d63680aacb15eb1/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=85bb2f9a302acc28dbae6c368d63680aacb15eb1", "patch": "@@ -1911,18 +1911,56 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n       enum vect_def_type dt;\n       if (!op || op == lhs)\n \tcontinue;\n-      if (vect_is_simple_use (op, stmt_info->vinfo, &def_stmt, &dt))\n+      if (vect_is_simple_use (op, stmt_info->vinfo, &def_stmt, &dt)\n+\t  && (dt == vect_constant_def || dt == vect_external_def))\n \t{\n \t  /* Without looking at the actual initializer a vector of\n \t     constants can be implemented as load from the constant pool.\n-\t     ???  We need to pass down stmt_info for a vector type\n-\t     even if it points to the wrong stmt.  */\n-\t  if (dt == vect_constant_def)\n-\t    record_stmt_cost (prologue_cost_vec, 1, vector_load,\n-\t\t\t      stmt_info, 0, vect_prologue);\n-\t  else if (dt == vect_external_def)\n-\t    record_stmt_cost (prologue_cost_vec, 1, vec_construct,\n-\t\t\t      stmt_info, 0, vect_prologue);\n+\t     When all elements are the same we can use a splat.  */\n+\t  tree vectype = get_vectype_for_scalar_type (TREE_TYPE (op));\n+\t  unsigned group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n+\t  unsigned num_vects_to_check;\n+\t  unsigned HOST_WIDE_INT const_nunits;\n+\t  unsigned nelt_limit;\n+\t  if (TYPE_VECTOR_SUBPARTS (vectype).is_constant (&const_nunits)\n+\t      && ! multiple_p (const_nunits, group_size))\n+\t    {\n+\t      num_vects_to_check = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n+\t      nelt_limit = const_nunits;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If either the vector has variable length or the vectors\n+\t         are composed of repeated whole groups we only need to\n+\t\t cost construction once.  All vectors will be the same.  */\n+\t      num_vects_to_check = 1;\n+\t      nelt_limit = group_size;\n+\t    }\n+\t  tree elt = NULL_TREE;\n+\t  unsigned nelt = 0;\n+\t  for (unsigned j = 0; j < num_vects_to_check * nelt_limit; ++j)\n+\t    {\n+\t      unsigned si = j % group_size;\n+\t      if (nelt == 0)\n+\t\telt = gimple_op (SLP_TREE_SCALAR_STMTS (node)[si], i);\n+\t      /* ???  We're just tracking whether all operands of a single\n+\t\t vector initializer are the same, ideally we'd check if\n+\t\t we emitted the same one already.  */\n+\t      else if (elt != gimple_op (SLP_TREE_SCALAR_STMTS (node)[si], i))\n+\t\telt = NULL_TREE;\n+\t      nelt++;\n+\t      if (nelt == nelt_limit)\n+\t\t{\n+\t\t  /* ???  We need to pass down stmt_info for a vector type\n+\t\t     even if it points to the wrong stmt.  */\n+\t\t  record_stmt_cost (prologue_cost_vec, 1,\n+\t\t\t\t    dt == vect_external_def\n+\t\t\t\t    ? (elt ? scalar_to_vec : vec_construct)\n+\t\t\t\t    : vector_load,\n+\t\t\t\t    stmt_info, 0, vect_prologue);\n+\t\t  nelt = 0;\n+\t\t}\n+\t    }\n \t}\n     }\n "}]}