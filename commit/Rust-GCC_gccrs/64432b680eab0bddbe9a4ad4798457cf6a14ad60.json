{"sha": "64432b680eab0bddbe9a4ad4798457cf6a14ad60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ0MzJiNjgwZWFiMGJkZGJlOWE0YWQ0Nzk4NDU3Y2Y2YTE0YWQ2MA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2020-12-17T18:02:37Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2020-12-17T18:04:21Z"}, "message": "vect, aarch64: Extend SVE vs Advanced SIMD costing decisions in vect_better_loop_vinfo_p\n\nWhile experimenting with some backend costs for Advanced SIMD and SVE I\nhit many cases where GCC would pick SVE for VLA auto-vectorisation even when\nthe backend very clearly presented cheaper costs for Advanced SIMD.\nFor a simple float addition loop the SVE costs were:\n\nvec.c:9:21: note:  Cost model analysis:\n  Vector inside of loop cost: 28\n  Vector prologue cost: 2\n  Vector epilogue cost: 0\n  Scalar iteration cost: 10\n  Scalar outside cost: 0\n  Vector outside cost: 2\n  prologue iterations: 0\n  epilogue iterations: 0\n  Minimum number of vector iterations: 1\n  Calculated minimum iters for profitability: 4\n\nand for Advanced SIMD (Neon) they're:\n\nvec.c:9:21: note:  Cost model analysis:\n  Vector inside of loop cost: 11\n  Vector prologue cost: 0\n  Vector epilogue cost: 0\n  Scalar iteration cost: 10\n  Scalar outside cost: 0\n  Vector outside cost: 0\n  prologue iterations: 0\n  epilogue iterations: 0\n  Calculated minimum iters for profitability: 0\nvec.c:9:21: note:    Runtime profitability threshold = 4\n\nyet the SVE one was always picked. With guidance from Richard this seems\nto be due to the vinfo comparisons in vect_better_loop_vinfo_p, in\nparticular the part with the big comment explaining the\nestimated_rel_new * 2 <= estimated_rel_old heuristic.\n\nThis patch extends the comparisons by introducing a three-way estimate\nkind for poly_int values that the backend can distinguish.\nThis allows vect_better_loop_vinfo_p to ask for minimum, maximum and\nlikely estimates and pick Advanced SIMD overs SVE when it is clearly cheaper.\n\ngcc/\n\t* target.h (enum poly_value_estimate_kind): Define.\n\t(estimated_poly_value): Take an estimate kind argument.\n\t* target.def (estimated_poly_value): Update definition for the\n\tabove.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (estimated_poly_value): Update prototype.\n\t* tree-vect-loop.c (vect_better_loop_vinfo_p): Use min, max and\n\tlikely estimates of VF to pick between vinfos.\n\t* config/aarch64/aarch64.c (aarch64_cmp_autovec_modes): Use\n\testimated_poly_value instead of aarch64_estimated_poly_value.\n\t(aarch64_estimated_poly_value): Take a kind argument and handle\n\tit.", "tree": {"sha": "c88d7613be91dc9c472634980e0de2f9a8897c37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c88d7613be91dc9c472634980e0de2f9a8897c37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64432b680eab0bddbe9a4ad4798457cf6a14ad60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64432b680eab0bddbe9a4ad4798457cf6a14ad60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64432b680eab0bddbe9a4ad4798457cf6a14ad60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64432b680eab0bddbe9a4ad4798457cf6a14ad60/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d7a40fa60fb8b9870cfd053a37fc67404353ee2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7a40fa60fb8b9870cfd053a37fc67404353ee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d7a40fa60fb8b9870cfd053a37fc67404353ee2"}], "stats": {"total": 148, "additions": 96, "deletions": 52}, "files": [{"sha": "67b4c91dbe4807efe463a89fa5f522caa064a7f4", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=64432b680eab0bddbe9a4ad4798457cf6a14ad60", "patch": "@@ -17367,8 +17367,6 @@ aarch64_simd_container_mode (scalar_mode mode, poly_int64 width)\n   return word_mode;\n }\n \n-static HOST_WIDE_INT aarch64_estimated_poly_value (poly_int64);\n-\n /* Compare an SVE mode SVE_M and an Advanced SIMD mode ASIMD_M\n    and return whether the SVE mode should be preferred over the\n    Advanced SIMD one in aarch64_autovectorize_vector_modes.  */\n@@ -17401,8 +17399,8 @@ aarch64_cmp_autovec_modes (machine_mode sve_m, machine_mode asimd_m)\n     return maybe_gt (nunits_sve, nunits_asimd);\n \n   /* Otherwise estimate the runtime width of the modes involved.  */\n-  HOST_WIDE_INT est_sve = aarch64_estimated_poly_value (nunits_sve);\n-  HOST_WIDE_INT est_asimd = aarch64_estimated_poly_value (nunits_asimd);\n+  HOST_WIDE_INT est_sve = estimated_poly_value (nunits_sve);\n+  HOST_WIDE_INT est_asimd = estimated_poly_value (nunits_asimd);\n \n   /* Preferring SVE means picking it first unless the Advanced SIMD mode\n      is clearly wider.  */\n@@ -23195,19 +23193,38 @@ aarch64_speculation_safe_value (machine_mode mode,\n \n /* Implement TARGET_ESTIMATED_POLY_VALUE.\n    Look into the tuning structure for an estimate.\n-   VAL.coeffs[1] is multiplied by the number of VQ chunks over the initial\n-   Advanced SIMD 128 bits.  */\n+   KIND specifies the type of requested estimate: min, max or likely.\n+   For cores with a known SVE width all three estimates are the same.\n+   For generic SVE tuning we want to distinguish the maximum estimate from\n+   the minimum and likely ones.\n+   The likely estimate is the same as the minimum in that case to give a\n+   conservative behavior of auto-vectorizing with SVE when it is a win\n+   even for 128-bit SVE.\n+   When SVE width information is available VAL.coeffs[1] is multiplied by\n+   the number of VQ chunks over the initial Advanced SIMD 128 bits.  */\n \n static HOST_WIDE_INT\n-aarch64_estimated_poly_value (poly_int64 val)\n+aarch64_estimated_poly_value (poly_int64 val,\n+\t\t\t      poly_value_estimate_kind kind\n+\t\t\t\t= POLY_VALUE_LIKELY)\n {\n   enum aarch64_sve_vector_bits_enum width_source\n     = aarch64_tune_params.sve_width;\n \n-  /* If we still don't have an estimate, use the default.  */\n+  /* If there is no core-specific information then the minimum and likely\n+     values are based on 128-bit vectors and the maximum is based on\n+     the architectural maximum of 2048 bits.  */\n   if (width_source == SVE_SCALABLE)\n-    return default_estimated_poly_value (val);\n+    switch (kind)\n+      {\n+      case POLY_VALUE_MIN:\n+      case POLY_VALUE_LIKELY:\n+\treturn val.coeffs[0];\n+      case POLY_VALUE_MAX:\n+\t  return val.coeffs[0] + val.coeffs[1] * 15;\n+      }\n \n+  /* If the core provides width information, use that.  */\n   HOST_WIDE_INT over_128 = width_source - 128;\n   return val.coeffs[0] + val.coeffs[1] * over_128 / 128;\n }"}, {"sha": "900d584d178118282ba9a63f40626c09a9676698", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=64432b680eab0bddbe9a4ad4798457cf6a14ad60", "patch": "@@ -7005,9 +7005,12 @@ delay slot branches filled using the basic filler is often still desirable\n as the delay slot can hide a pipeline bubble.\n @end deftypefn\n \n-@deftypefn {Target Hook} HOST_WIDE_INT TARGET_ESTIMATED_POLY_VALUE (poly_int64 @var{val})\n+@deftypefn {Target Hook} HOST_WIDE_INT TARGET_ESTIMATED_POLY_VALUE (poly_int64 @var{val}, poly_value_estimate_kind @var{kind})\n Return an estimate of the runtime value of @var{val}, for use in\n-things like cost calculations or profiling frequencies.  The default\n+things like cost calculations or profiling frequencies.  @var{kind} is used\n+to ask for the minimum, maximum, and likely estimates of the value through\n+the @code{POLY_VALUE_MIN}, @code{POLY_VALUE_MAX} and\n+@code{POLY_VALUE_LIKELY} values.  The default\n implementation returns the lowest possible value of @var{val}.\n @end deftypefn\n "}, {"sha": "d5ed0dfda4fdadc9cab64e13ca154c2162af9c68", "filename": "gcc/target.def", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=64432b680eab0bddbe9a4ad4798457cf6a14ad60", "patch": "@@ -3851,9 +3851,12 @@ default_new_address_profitable_p)\n DEFHOOK\n (estimated_poly_value,\n  \"Return an estimate of the runtime value of @var{val}, for use in\\n\\\n-things like cost calculations or profiling frequencies.  The default\\n\\\n+things like cost calculations or profiling frequencies.  @var{kind} is used\\n\\\n+to ask for the minimum, maximum, and likely estimates of the value through\\n\\\n+the @code{POLY_VALUE_MIN}, @code{POLY_VALUE_MAX} and\\n\\\n+@code{POLY_VALUE_LIKELY} values.  The default\\n\\\n implementation returns the lowest possible value of @var{val}.\",\n- HOST_WIDE_INT, (poly_int64 val),\n+ HOST_WIDE_INT, (poly_int64 val, poly_value_estimate_kind kind),\n  default_estimated_poly_value)\n \n /* Permit speculative instructions in delay slots during delayed-branch "}, {"sha": "68ef5194b6c4e1e8e317d0c108082a9a4b2963c9", "filename": "gcc/target.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=64432b680eab0bddbe9a4ad4798457cf6a14ad60", "patch": "@@ -252,6 +252,13 @@ enum type_context_kind {\n   TCTX_CAPTURE_BY_COPY\n };\n \n+enum poly_value_estimate_kind\n+{\n+  POLY_VALUE_MIN,\n+  POLY_VALUE_MAX,\n+  POLY_VALUE_LIKELY\n+};\n+\n extern bool verify_type_context (location_t, type_context_kind, const_tree,\n \t\t\t\t bool = false);\n \n@@ -272,12 +279,13 @@ extern struct gcc_target targetm;\n    provides a rough guess.  */\n \n static inline HOST_WIDE_INT\n-estimated_poly_value (poly_int64 x)\n+estimated_poly_value (poly_int64 x,\n+\t\t      poly_value_estimate_kind kind = POLY_VALUE_LIKELY)\n {\n   if (NUM_POLY_INT_COEFFS == 1)\n     return x.coeffs[0];\n   else\n-    return targetm.estimated_poly_value (x);\n+    return targetm.estimated_poly_value (x, kind);\n }\n \n #ifdef GCC_TM_H"}, {"sha": "d616fb73bdfdc1efbad69ad463afe0348d3641c4", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=64432b680eab0bddbe9a4ad4798457cf6a14ad60", "patch": "@@ -1757,7 +1757,7 @@ default_slow_unaligned_access (machine_mode, unsigned int)\n /* The default implementation of TARGET_ESTIMATED_POLY_VALUE.  */\n \n HOST_WIDE_INT\n-default_estimated_poly_value (poly_int64 x)\n+default_estimated_poly_value (poly_int64 x, poly_value_estimate_kind)\n {\n   return x.coeffs[0];\n }"}, {"sha": "688538a4521c740d6982c23a4d3ea0e02c16f901", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 49, "deletions": 36, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64432b680eab0bddbe9a4ad4798457cf6a14ad60/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=64432b680eab0bddbe9a4ad4798457cf6a14ad60", "patch": "@@ -2773,43 +2773,56 @@ vect_better_loop_vinfo_p (loop_vec_info new_loop_vinfo,\n \n   /* Check whether the (fractional) cost per scalar iteration is lower\n      or higher: new_inside_cost / new_vf vs. old_inside_cost / old_vf.  */\n-  poly_widest_int rel_new = (new_loop_vinfo->vec_inside_cost\n-\t\t\t     * poly_widest_int (old_vf));\n-  poly_widest_int rel_old = (old_loop_vinfo->vec_inside_cost\n-\t\t\t     * poly_widest_int (new_vf));\n-  if (maybe_lt (rel_old, rel_new))\n-    {\n-      /* When old_loop_vinfo uses a variable vectorization factor,\n-\t we know that it has a lower cost for at least one runtime VF.\n-\t However, we don't know how likely that VF is.\n-\n-\t One option would be to compare the costs for the estimated VFs.\n-\t The problem is that that can put too much pressure on the cost\n-\t model.  E.g. if the estimated VF is also the lowest possible VF,\n-\t and if old_loop_vinfo is 1 unit worse than new_loop_vinfo\n-\t for the estimated VF, we'd then choose new_loop_vinfo even\n-\t though (a) new_loop_vinfo might not actually be better than\n-\t old_loop_vinfo for that VF and (b) it would be significantly\n-\t worse at larger VFs.\n-\n-\t Here we go for a hacky compromise: pick new_loop_vinfo if it is\n-\t no more expensive than old_loop_vinfo even after doubling the\n-\t estimated old_loop_vinfo VF.  For all but trivial loops, this\n-\t ensures that we only pick new_loop_vinfo if it is significantly\n-\t better than old_loop_vinfo at the estimated VF.  */\n-      if (rel_new.is_constant ())\n-\treturn false;\n-\n-      HOST_WIDE_INT new_estimated_vf = estimated_poly_value (new_vf);\n-      HOST_WIDE_INT old_estimated_vf = estimated_poly_value (old_vf);\n-      widest_int estimated_rel_new = (new_loop_vinfo->vec_inside_cost\n-\t\t\t\t      * widest_int (old_estimated_vf));\n-      widest_int estimated_rel_old = (old_loop_vinfo->vec_inside_cost\n-\t\t\t\t      * widest_int (new_estimated_vf));\n-      return estimated_rel_new * 2 <= estimated_rel_old;\n-    }\n-  if (known_lt (rel_new, rel_old))\n+  poly_int64 rel_new = new_loop_vinfo->vec_inside_cost * old_vf;\n+  poly_int64 rel_old = old_loop_vinfo->vec_inside_cost * new_vf;\n+\n+  HOST_WIDE_INT est_rel_new_min\n+    = estimated_poly_value (rel_new, POLY_VALUE_MIN);\n+  HOST_WIDE_INT est_rel_new_max\n+    = estimated_poly_value (rel_new, POLY_VALUE_MAX);\n+\n+  HOST_WIDE_INT est_rel_old_min\n+    = estimated_poly_value (rel_old, POLY_VALUE_MIN);\n+  HOST_WIDE_INT est_rel_old_max\n+    = estimated_poly_value (rel_old, POLY_VALUE_MAX);\n+\n+  /* Check first if we can make out an unambigous total order from the minimum\n+     and maximum estimates.  */\n+  if (est_rel_new_min < est_rel_old_min\n+      && est_rel_new_max < est_rel_old_max)\n     return true;\n+  else if (est_rel_old_min < est_rel_new_min\n+\t   && est_rel_old_max < est_rel_new_max)\n+    return false;\n+  /* When old_loop_vinfo uses a variable vectorization factor,\n+     we know that it has a lower cost for at least one runtime VF.\n+     However, we don't know how likely that VF is.\n+\n+     One option would be to compare the costs for the estimated VFs.\n+     The problem is that that can put too much pressure on the cost\n+     model.  E.g. if the estimated VF is also the lowest possible VF,\n+     and if old_loop_vinfo is 1 unit worse than new_loop_vinfo\n+     for the estimated VF, we'd then choose new_loop_vinfo even\n+     though (a) new_loop_vinfo might not actually be better than\n+     old_loop_vinfo for that VF and (b) it would be significantly\n+     worse at larger VFs.\n+\n+     Here we go for a hacky compromise: pick new_loop_vinfo if it is\n+     no more expensive than old_loop_vinfo even after doubling the\n+     estimated old_loop_vinfo VF.  For all but trivial loops, this\n+     ensures that we only pick new_loop_vinfo if it is significantly\n+     better than old_loop_vinfo at the estimated VF.  */\n+\n+  if (est_rel_old_min != est_rel_new_min\n+      || est_rel_old_max != est_rel_new_max)\n+    {\n+      HOST_WIDE_INT est_rel_new_likely\n+\t= estimated_poly_value (rel_new, POLY_VALUE_LIKELY);\n+      HOST_WIDE_INT est_rel_old_likely\n+\t= estimated_poly_value (rel_old, POLY_VALUE_LIKELY);\n+\n+      return est_rel_new_likely * 2 <= est_rel_old_likely;\n+    }\n \n   /* If there's nothing to choose between the loop bodies, see whether\n      there's a difference in the prologue and epilogue costs.  */"}]}