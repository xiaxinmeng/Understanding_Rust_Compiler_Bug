{"sha": "ca5ff10546e612eff3d5e225b62b44ddf656cfbf", "node_id": "C_kwDOANBUbNoAKGNhNWZmMTA1NDZlNjEyZWZmM2Q1ZTIyNWI2MmI0NGRkZjY1NmNmYmY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-03T17:47:01Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-03T17:47:01Z"}, "message": "analyzer: use std::unique_ptr for custom_edge_info pointers\n\ngcc/analyzer/ChangeLog:\n\t* checker-path.cc (rewind_event::rewind_event): Update for usage of\n\tstd::unique_ptr on custom_edge_info.\n\t* engine.cc (exploded_node::on_longjmp): Likewise.\n\t(exploded_edge::exploded_edge): Likewise.\n\t(exploded_edge::~exploded_edge): Delete.\n\t(exploded_graph::add_function_entry): Update for usage of\n\tstd::unique_ptr on custom_edge_info.\n\t(exploded_graph::add_edge): Likewise.\n\t(add_tainted_args_callback): Likewise.\n\t(exploded_graph::maybe_create_dynamic_call): Likewise.\n\t(exploded_graph::process_node): Likewise.\n\t* exploded-graph.h (exploded_edge::~exploded_edge): Delete.\n\t(exploded_edge::m_custom_info): Use std::unique_ptr.\n\t(exploded_edge::add_edge): Likewise.\n\t* sm-signal.cc (register_signal_handler::impl_transition): Use\n\tmake_unique.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "6b555bcf2bfacdc0c38eeea91a1e442d9fbd64e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b555bcf2bfacdc0c38eeea91a1e442d9fbd64e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca5ff10546e612eff3d5e225b62b44ddf656cfbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca5ff10546e612eff3d5e225b62b44ddf656cfbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca5ff10546e612eff3d5e225b62b44ddf656cfbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a9b395b1e4542c79b250b756346816a9b72d859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9b395b1e4542c79b250b756346816a9b72d859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a9b395b1e4542c79b250b756346816a9b72d859"}], "stats": {"total": 67, "additions": 25, "deletions": 42}, "files": [{"sha": "49940ce839e1958832784c147b2ffcb6536d3eea", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=ca5ff10546e612eff3d5e225b62b44ddf656cfbf", "patch": "@@ -1037,7 +1037,7 @@ rewind_event::rewind_event (const exploded_edge *eedge,\n   m_rewind_info (rewind_info),\n   m_eedge (eedge)\n {\n-  gcc_assert (m_eedge->m_custom_info == m_rewind_info);\n+  gcc_assert (m_eedge->m_custom_info.get () == m_rewind_info);\n }\n \n /* class rewind_from_longjmp_event : public rewind_event.  */"}, {"sha": "c7bc63e48a58015d0e9ad2d23eff1dfa0fcb7ecd", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=ca5ff10546e612eff3d5e225b62b44ddf656cfbf", "patch": "@@ -1878,7 +1878,7 @@ exploded_node::on_longjmp (exploded_graph &eg,\n     {\n       exploded_edge *eedge\n \t= eg.add_edge (const_cast<exploded_node *> (this), next, NULL,\n-\t\t       new rewind_info_t (tmp_setjmp_record, longjmp_call));\n+\t\t       make_unique<rewind_info_t> (tmp_setjmp_record, longjmp_call));\n \n       /* For any diagnostics that were queued here (such as leaks) we want\n \t the checker_path to show the rewinding events after the \"final event\"\n@@ -2089,19 +2089,12 @@ rewind_info_t::add_events_to_path (checker_path *emission_path,\n \n exploded_edge::exploded_edge (exploded_node *src, exploded_node *dest,\n \t\t\t      const superedge *sedge,\n-\t\t\t      custom_edge_info *custom_info)\n+\t\t\t      std::unique_ptr<custom_edge_info> custom_info)\n : dedge<eg_traits> (src, dest), m_sedge (sedge),\n-  m_custom_info (custom_info)\n+  m_custom_info (std::move (custom_info))\n {\n }\n \n-/* exploded_edge's dtor.  */\n-\n-exploded_edge::~exploded_edge ()\n-{\n-  delete m_custom_info;\n-}\n-\n /* Implementation of dedge::dump_dot vfunc for exploded_edge.\n    Use the label of the underlying superedge, if any.  */\n \n@@ -2709,25 +2702,22 @@ exploded_graph::add_function_entry (function *fun)\n   program_state state (m_ext_state);\n   state.push_frame (m_ext_state, fun);\n \n-  custom_edge_info *edge_info = NULL;\n+  std::unique_ptr<custom_edge_info> edge_info = NULL;\n \n   if (lookup_attribute (\"tainted_args\", DECL_ATTRIBUTES (fun->decl)))\n     {\n       if (mark_params_as_tainted (&state, fun->decl, m_ext_state))\n-\tedge_info = new tainted_args_function_info (fun->decl);\n+\tedge_info = make_unique<tainted_args_function_info> (fun->decl);\n     }\n \n   if (!state.m_valid)\n     return NULL;\n \n   exploded_node *enode = get_or_create_node (point, state, NULL);\n   if (!enode)\n-    {\n-      delete edge_info;\n-      return NULL;\n-    }\n+    return NULL;\n \n-  add_edge (m_origin, enode, NULL, edge_info);\n+  add_edge (m_origin, enode, NULL, std::move (edge_info));\n \n   m_functions_with_enodes.add (fun);\n \n@@ -2925,18 +2915,19 @@ exploded_graph::get_or_create_node (const program_point &point,\n \n /* Add an exploded_edge from SRC to DEST, recording its association\n    with SEDGE (which may be NULL), and, if non-NULL, taking ownership\n-   of REWIND_INFO.\n+   of CUSTOM_INFO.\n    Return the newly-created eedge.  */\n \n exploded_edge *\n exploded_graph::add_edge (exploded_node *src, exploded_node *dest,\n \t\t\t  const superedge *sedge,\n-\t\t\t  custom_edge_info *custom_info)\n+\t\t\t    std::unique_ptr<custom_edge_info> custom_info)\n {\n   if (get_logger ())\n     get_logger ()->log (\"creating edge EN: %i -> EN: %i\",\n \t\t\tsrc->m_index, dest->m_index);\n-  exploded_edge *e = new exploded_edge (src, dest, sedge, custom_info);\n+  exploded_edge *e = new exploded_edge (src, dest, sedge,\n+\t\t\t\t\tstd::move (custom_info));\n   digraph<eg_traits>::add_edge (e);\n   return e;\n }\n@@ -3183,9 +3174,8 @@ add_tainted_args_callback (exploded_graph *eg, tree field, tree fndecl,\n \t}\n     }\n \n-  tainted_args_call_info *info\n-    = new tainted_args_call_info (field, fndecl, loc);\n-  eg->add_edge (eg->get_origin (), enode, NULL, info);\n+  eg->add_edge (eg->get_origin (), enode, NULL,\n+\t\tmake_unique<tainted_args_call_info> (field, fndecl, loc));\n }\n \n /* Callback for walk_tree for finding callbacks within initializers;\n@@ -3782,7 +3772,7 @@ exploded_graph::maybe_create_dynamic_call (const gcall *call,\n \t\t\t\t\t\t     node);\n \t  if (enode)\n \t    add_edge (node,enode, NULL,\n-\t\t      new dynamic_call_info_t (call));\n+\t\t      make_unique<dynamic_call_info_t> (call));\n \t  return true;\n \t}\n     }\n@@ -4108,8 +4098,10 @@ exploded_graph::process_node (exploded_node *node)\n \t   instances.  For example, to handle a \"realloc\" call, we\n \t   might split into 3 states, for the \"failure\",\n \t   \"resizing in place\", and \"moving to a new buffer\" cases.  */\n-\tfor (auto edge_info : path_ctxt.get_custom_eedge_infos ())\n+\tfor (auto edge_info_iter : path_ctxt.get_custom_eedge_infos ())\n \t  {\n+\t    /* Take ownership of the edge infos from the path_ctxt.  */\n+\t    std::unique_ptr<custom_edge_info> edge_info (edge_info_iter);\n \t    if (logger)\n \t      {\n \t\tlogger->start_log_line ();\n@@ -4136,18 +4128,12 @@ exploded_graph::process_node (exploded_node *node)\n \t\texploded_node *next2\n \t\t  = get_or_create_node (next_point, bifurcated_new_state, node);\n \t\tif (next2)\n-\t\t  {\n-\t\t    /* Take ownership of edge_info.  */\n-\t\t    add_edge (node, next2, NULL, edge_info);\n-\t\t  }\n-\t\telse\n-\t\t  delete edge_info;\n+\t\t  add_edge (node, next2, NULL, std::move (edge_info));\n \t      }\n \t    else\n \t      {\n \t\tif (logger)\n \t\t  logger->log (\"infeasible state, not adding node\");\n-\t\tdelete edge_info;\n \t      }\n \t  }\n       }\n@@ -4303,7 +4289,7 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\t\t\t\t\t   node);\n \t\tif (enode)\n \t\t  add_edge (node, enode, NULL,\n-\t\t\t    new dynamic_call_info_t (call, true));\n+\t\t\t    make_unique<dynamic_call_info_t> (call, true));\n \t      }\n \t  }\n       }"}, {"sha": "27e688173b547e44eca22c924788f56b0c2e709d", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=ca5ff10546e612eff3d5e225b62b44ddf656cfbf", "patch": "@@ -367,8 +367,7 @@ class exploded_edge : public dedge<eg_traits>\n  public:\n   exploded_edge (exploded_node *src, exploded_node *dest,\n \t\t const superedge *sedge,\n-\t\t custom_edge_info *custom_info);\n-  ~exploded_edge ();\n+\t\t std::unique_ptr<custom_edge_info> custom_info);\n   void dump_dot (graphviz_out *gv, const dump_args_t &args)\n     const final override;\n   void dump_dot_label (pretty_printer *pp) const;\n@@ -380,10 +379,8 @@ class exploded_edge : public dedge<eg_traits>\n \n   /* NULL for most edges; will be non-NULL for special cases\n      such as an unwind from a longjmp to a setjmp, or when\n-     a signal is delivered to a signal-handler.\n-\n-     Owned by this class.  */\n-  custom_edge_info *m_custom_info;\n+     a signal is delivered to a signal-handler.  */\n+  std::unique_ptr<custom_edge_info> m_custom_info;\n \n private:\n   DISABLE_COPY_AND_ASSIGN (exploded_edge);\n@@ -801,7 +798,7 @@ class exploded_graph : public digraph<eg_traits>\n \t\t\t\t     exploded_node *enode_for_diag);\n   exploded_edge *add_edge (exploded_node *src, exploded_node *dest,\n \t\t\t   const superedge *sedge,\n-\t\t\t   custom_edge_info *custom = NULL);\n+\t\t\t   std::unique_ptr<custom_edge_info> custom = NULL);\n \n   per_program_point_data *\n   get_or_create_per_program_point_data (const program_point &);"}, {"sha": "08476b63df0973822c281f0ee220c98c5cfe2eb7", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5ff10546e612eff3d5e225b62b44ddf656cfbf/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=ca5ff10546e612eff3d5e225b62b44ddf656cfbf", "patch": "@@ -279,7 +279,7 @@ class register_signal_handler : public custom_transition\n \t\t\t\t\t\t       src_enode);\n     if (dst_enode)\n       eg->add_edge (src_enode, dst_enode, NULL, /*state_change (),*/\n-\t\t    new signal_delivery_edge_info_t ());\n+\t\t    make_unique<signal_delivery_edge_info_t> ());\n   }\n \n   const signal_state_machine &m_sm;"}]}