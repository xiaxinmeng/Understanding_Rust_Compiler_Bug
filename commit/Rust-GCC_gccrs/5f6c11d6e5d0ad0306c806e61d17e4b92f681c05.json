{"sha": "5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY2YzExZDZlNWQwYWQwMzA2YzgwNmU2MWQxN2U0YjkyZjY4MWMwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-01-12T00:07:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-12T00:07:36Z"}, "message": "Makefile.in (OBJECTS): Add sbitmap.o.\n\n        * Makefile.in (OBJECTS): Add sbitmap.o.\n        (BASIC_BLOCK_H): Add sbitmap.h.\n        * basic-block.h: Move simple bitmap code to sbitmap.h.\n        * flow.c: Move simple bitmap code to sbitmap.c\n        * sbitmap.h, sbitmap.c: New files.\n\nFrom-SVN: r24628", "tree": {"sha": "a670b120baed589656a2a75147186bd9959e5141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a670b120baed589656a2a75147186bd9959e5141"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/comments", "author": null, "committer": null, "parents": [{"sha": "ca7cdae3ed47b4f7a1e97ec2c936d17bc97d9abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7cdae3ed47b4f7a1e97ec2c936d17bc97d9abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca7cdae3ed47b4f7a1e97ec2c936d17bc97d9abe"}], "stats": {"total": 1209, "additions": 606, "deletions": 603}, "files": [{"sha": "e94632380762312dc3cce6a69da5111b26b77b83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "patch": "@@ -1,3 +1,11 @@\n+Tue Jan 12 00:06:00 1999  Richard Henderson  <rth@cygnus.com>\n+\n+        * Makefile.in (OBJECTS): Add sbitmap.o.\n+        (BASIC_BLOCK_H): Add sbitmap.h.\n+        * basic-block.h: Move simple bitmap code to sbitmap.h.\n+        * flow.c: Move simple bitmap code to sbitmap.c\n+        * sbitmap.h, sbitmap.c: New files.\n+\n Mon Jan 11 23:51:50 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.h (TARGET_SWITCHES): Document switches."}, {"sha": "4db32f0571f35def98167341657f929ae3239ea2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "patch": "@@ -655,7 +655,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n- mbchar.o dyn-string.o splay-tree.o graph.o\n+ mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -731,7 +731,7 @@ CONFIG_H =\n RTL_BASE_H = rtl.h rtl.def machmode.h machmode.def\n RTL_H = $(RTL_BASE_H) genrtl.h\n TREE_H = tree.h real.h tree.def machmode.h machmode.def tree-check.h\n-BASIC_BLOCK_H = basic-block.h bitmap.h\n+BASIC_BLOCK_H = basic-block.h bitmap.h sbitmap.h\n DEMANGLE_H = $(srcdir)/../include/demangle.h\n RECOG_H = recog.h\n EXPR_H = expr.h insn-codes.h\n@@ -1298,7 +1298,8 @@ c-iterate.o: c-iterate.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n     flags.h toplev.h $(EXPR_H)\n mbchar.o: mbchar.c $(CONFIG_H) system.h mbchar.h\n graph.o: graph.c $(CONFIG_H) system.h toplev.h flags.h output.h $(RTL_H) \\\n-    hard-reg-set.h basic-block.h\n+    hard-reg-set.h $(BASIC_BLOCK_H)\n+sbitmap.o: sbitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H)\n \n collect2$(exeext): collect2.o tlink.o hash.o cplus-dem.o underscore.o \\\n \tversion.o choose-temp.o mkstemp.o $(LIBDEPS)"}, {"sha": "d54ffe8b26c51890344a36adf28bf1aaf6e79725", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 104, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "patch": "@@ -20,6 +20,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n #include \"bitmap.h\"\n+#include \"sbitmap.h\"\n \n typedef bitmap regset;\t\t/* Head of register set linked list.  */\n \n@@ -188,114 +189,12 @@ extern void free_regset_vector PROTO ((regset *, int nelts));\n extern int *uid_block_number;\n #define BLOCK_NUM(INSN)    uid_block_number[INSN_UID (INSN)]\n \n-extern void compute_preds_succs PROTO ((int_list_ptr *, int_list_ptr *,\n-\t\t\t\t        int *, int *));\n extern void dump_bb_data       PROTO ((FILE *, int_list_ptr *, int_list_ptr *,\n \t\t\t\t       int));\n extern void free_bb_mem        PROTO ((void));\n extern void free_basic_block_vars\tPROTO ((int));\n \n-\f\n-/* Simple bitmaps.\n-   It's not clear yet whether using bitmap.[ch] will be a win.\n-   It should be straightforward to convert so for now we keep things simple\n-   while more important issues are dealt with.  */\n-\n-#define SBITMAP_ELT_BITS HOST_BITS_PER_WIDE_INT\n-#define SBITMAP_ELT_TYPE unsigned HOST_WIDE_INT\n-\n-typedef struct simple_bitmap_def {\n-  /* Number of bits.  */\n-  int n_bits;\n-  /* Size in elements.  */\n-  int size;\n-  /* Size in bytes.  */\n-  int bytes;\n-  /* The elements.  */\n-  SBITMAP_ELT_TYPE elms[1];\n-} *sbitmap;\n-\n-typedef SBITMAP_ELT_TYPE *sbitmap_ptr;\n-\n-/* Return the set size needed for N elements.  */\n-#define SBITMAP_SET_SIZE(n) (((n) + SBITMAP_ELT_BITS - 1) / SBITMAP_ELT_BITS)\n-\n-/* set bit number bitno in the bitmap */\n-#define SET_BIT(bitmap, bitno) \\\n-do { \\\n-  (bitmap)->elms [(bitno) / SBITMAP_ELT_BITS] |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS; \\\n-} while (0)\n-\n-/* test if bit number bitno in the bitmap is set */\n-#define TEST_BIT(bitmap, bitno) \\\n-((bitmap)->elms [(bitno) / SBITMAP_ELT_BITS] & ((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS))\n-\n-/* reset bit number bitno in the bitmap  */\n-#define RESET_BIT(bitmap, bitno) \\\n-do { \\\n-  (bitmap)->elms [(bitno) / SBITMAP_ELT_BITS] &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS); \\\n-} while (0)\n-\n-/* Loop over all elements of SBITSET, starting with MIN.  */\n-#define EXECUTE_IF_SET_IN_SBITMAP(SBITMAP, MIN, N, CODE)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  unsigned int bit_num_ = (MIN) % (unsigned) SBITMAP_ELT_BITS;\t\t\\\n-  unsigned int word_num_ = (MIN) / (unsigned) SBITMAP_ELT_BITS;\t\t\\\n-  unsigned int size_ = (SBITMAP)->size;\t\t\t\t\t\\\n-  SBITMAP_ELT_TYPE *ptr_ = (SBITMAP)->elms;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  while (word_num_ < size_)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      SBITMAP_ELT_TYPE word_ = ptr_[word_num_];\t\t\t\t\\\n-      if (word_ != 0)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  for (; bit_num_ < SBITMAP_ELT_BITS; ++bit_num_)\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      SBITMAP_ELT_TYPE mask_ = (SBITMAP_ELT_TYPE)1 << bit_num_;\t\\\n-\t      if ((word_ & mask_) != 0)\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  word_ &= ~mask_;\t\t\t\t\t\\\n-\t\t  (N) = word_num_ * SBITMAP_ELT_BITS + bit_num_;\t\\\n-\t\t  CODE;\t\t\t\t\t\t\t\\\n-\t\t  if (word_ == 0)\t\t\t\t\t\\\n-\t\t    break;\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      bit_num_ = 0;\t\t\t\t\t\t\t\\\n-      word_num_++;\t\t\t\t\t\t\t\\\n-   }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define sbitmap_free(map)\t\tfree(map)\n-#define sbitmap_vector_free(vec)\tfree(vec)\n-\n-extern void dump_sbitmap PROTO ((FILE *, sbitmap));\n-extern void dump_sbitmap_vector PROTO ((FILE *, char *, char *,\n-\t\t\t\t\tsbitmap *, int));\n-extern sbitmap sbitmap_alloc PROTO ((int));\n-extern sbitmap *sbitmap_vector_alloc PROTO ((int, int));\n-extern void sbitmap_copy PROTO ((sbitmap, sbitmap));\n-extern void sbitmap_zero PROTO ((sbitmap));\n-extern void sbitmap_ones PROTO ((sbitmap));\n-extern void sbitmap_vector_zero PROTO ((sbitmap *, int));\n-extern void sbitmap_vector_ones PROTO ((sbitmap *, int));\n-extern int sbitmap_union_of_diff PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n-extern void sbitmap_difference PROTO ((sbitmap, sbitmap, sbitmap));\n-extern void sbitmap_not PROTO ((sbitmap, sbitmap));\n-extern int sbitmap_a_or_b_and_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n-extern int sbitmap_a_and_b_or_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n-extern int sbitmap_a_and_b PROTO ((sbitmap, sbitmap, sbitmap));\n-extern int sbitmap_a_or_b PROTO ((sbitmap, sbitmap, sbitmap));\n-extern void sbitmap_intersect_of_predsucc PROTO ((sbitmap, sbitmap *,\n-\t\t\t\t\t\t  int, int_list_ptr *));\n-extern void sbitmap_intersect_of_predecessors PROTO ((sbitmap, sbitmap *, int,\n-\t\t\t\t\t\t      int_list_ptr *));\n-extern void sbitmap_intersect_of_successors PROTO ((sbitmap, sbitmap *, int,\n-\t\t\t\t\t\t    int_list_ptr *));\n-extern void sbitmap_union_of_predecessors PROTO ((sbitmap, sbitmap *, int,\n-\t\t\t\t\t\t  int_list_ptr *));\n-extern void sbitmap_union_of_successors PROTO ((sbitmap, sbitmap *, int,\n-\t\t\t\t\t\tint_list_ptr *));\n+extern void compute_preds_succs PROTO ((int_list_ptr *, int_list_ptr *,\n+                                        int *, int *));\n extern void compute_dominators PROTO ((sbitmap *, sbitmap *,\n \t\t\t\t       int_list_ptr *, int_list_ptr *));"}, {"sha": "fa19d9eb8b8b74e620abd5725ec3cdb46602275e", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 496, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "patch": "@@ -3505,509 +3505,13 @@ dump_bb_data (file, preds, succs, live_info)\n   fprintf (file, \"\\n\");\n }\n \n-void\n-dump_sbitmap (file, bmap)\n-     FILE *file;\n-     sbitmap bmap;\n-{\n-  int i,j,n;\n-  int set_size = bmap->size;\n-  int total_bits = bmap->n_bits;\n-\n-  fprintf (file, \"  \");\n-  for (i = n = 0; i < set_size && n < total_bits; i++)\n-    {\n-      for (j = 0; j < SBITMAP_ELT_BITS && n < total_bits; j++, n++)\n-\t{\n-\t  if (n != 0 && n % 10 == 0)\n-\t    fprintf (file, \" \");\n-\t  fprintf (file, \"%d\", (bmap->elms[i] & (1L << j)) != 0);\n-\t}\n-    }\n-  fprintf (file, \"\\n\");\n-}\n-\n-void\n-dump_sbitmap_vector (file, title, subtitle, bmaps, n_maps)\n-     FILE *file;\n-     char *title, *subtitle;\n-     sbitmap *bmaps;\n-     int n_maps;\n-{\n-  int bb;\n-\n-  fprintf (file, \"%s\\n\", title);\n-  for (bb = 0; bb < n_maps; bb++)\n-    {\n-      fprintf (file, \"%s %d\\n\", subtitle, bb);\n-      dump_sbitmap (file, bmaps[bb]);\n-    }\n-  fprintf (file, \"\\n\");\n-}\n-\n /* Free basic block data storage.  */\n \n void\n free_bb_mem ()\n {\n   free_int_list (&pred_int_list_blocks);\n }\n-\f\n-/* Bitmap manipulation routines.  */\n-\n-/* Allocate a simple bitmap of N_ELMS bits.  */\n-\n-sbitmap\n-sbitmap_alloc (n_elms)\n-     int n_elms;\n-{\n-  int bytes, size, amt;\n-  sbitmap bmap;\n-\n-  size = SBITMAP_SET_SIZE (n_elms);\n-  bytes = size * sizeof (SBITMAP_ELT_TYPE);\n-  amt = (sizeof (struct simple_bitmap_def)\n-\t + bytes - sizeof (SBITMAP_ELT_TYPE));\n-  bmap = (sbitmap) xmalloc (amt);\n-  bmap->n_bits = n_elms;\n-  bmap->size = size;\n-  bmap->bytes = bytes;\n-  return bmap;\n-}\n-\n-/* Allocate a vector of N_VECS bitmaps of N_ELMS bits.  */\n-\n-sbitmap *\n-sbitmap_vector_alloc (n_vecs, n_elms)\n-     int n_vecs, n_elms;\n-{\n-  int i, bytes, offset, elm_bytes, size, amt, vector_bytes;\n-  sbitmap *bitmap_vector;\n-\n-  size = SBITMAP_SET_SIZE (n_elms);\n-  bytes = size * sizeof (SBITMAP_ELT_TYPE);\n-  elm_bytes = (sizeof (struct simple_bitmap_def)\n-\t       + bytes - sizeof (SBITMAP_ELT_TYPE));\n-  vector_bytes = n_vecs * sizeof (sbitmap *);\n-\n-  /* Round up `vector_bytes' to account for the alignment requirements\n-     of an sbitmap.  One could allocate the vector-table and set of sbitmaps\n-     separately, but that requires maintaining two pointers or creating\n-     a cover struct to hold both pointers (so our result is still just\n-     one pointer).  Neither is a bad idea, but this is simpler for now.  */\n-  {\n-    /* Based on DEFAULT_ALIGNMENT computation in obstack.c.  */\n-    struct { char x; SBITMAP_ELT_TYPE y; } align;\n-    int alignment = (char *) & align.y - & align.x;\n-    vector_bytes = (vector_bytes + alignment - 1) & ~ (alignment - 1);\n-  }\n-\n-  amt = vector_bytes + (n_vecs * elm_bytes);\n-  bitmap_vector = (sbitmap *) xmalloc (amt);\n-\n-  for (i = 0, offset = vector_bytes;\n-       i < n_vecs;\n-       i++, offset += elm_bytes)\n-    {\n-      sbitmap b = (sbitmap) ((char *) bitmap_vector + offset);\n-      bitmap_vector[i] = b;\n-      b->n_bits = n_elms;\n-      b->size = size;\n-      b->bytes = bytes;\n-    }\n-\n-  return bitmap_vector;\n-}\n-\n-/* Copy sbitmap SRC to DST.  */\n-\n-void\n-sbitmap_copy (dst, src)\n-     sbitmap dst, src;\n-{\n-  bcopy ((PTR) src->elms, (PTR) dst->elms, sizeof (SBITMAP_ELT_TYPE) * dst->size);\n-}\n-\n-/* Zero all elements in a bitmap.  */\n-\n-void\n-sbitmap_zero (bmap)\n-     sbitmap bmap;\n-{\n-  bzero ((char *) bmap->elms, bmap->bytes);\n-}\n-\n-/* Set to ones all elements in a bitmap.  */\n-\n-void\n-sbitmap_ones (bmap)\n-     sbitmap bmap;\n-{\n-  memset (bmap->elms, -1, bmap->bytes);\n-}\n-\n-/* Zero a vector of N_VECS bitmaps.  */\n-\n-void\n-sbitmap_vector_zero (bmap, n_vecs)\n-     sbitmap *bmap;\n-     int n_vecs;\n-{\n-  int i;\n-\n-  for (i = 0; i < n_vecs; i++)\n-    sbitmap_zero (bmap[i]);\n-}\n-\n-/* Set to ones a vector of N_VECS bitmaps.  */\n-\n-void\n-sbitmap_vector_ones (bmap, n_vecs)\n-     sbitmap *bmap;\n-     int n_vecs;\n-{\n-  int i;\n-\n-  for (i = 0; i < n_vecs; i++)\n-    sbitmap_ones (bmap[i]);\n-}\n-\n-/* Set DST to be A union (B - C).\n-   DST = A | (B & ~C).\n-   Return non-zero if any change is made.  */\n-\n-int\n-sbitmap_union_of_diff (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n-{\n-  int i,changed;\n-  sbitmap_ptr dstp, ap, bp, cp;\n-\n-  changed = 0;\n-  dstp = dst->elms;\n-  ap = a->elms;\n-  bp = b->elms;\n-  cp = c->elms;\n-  for (i = 0; i < dst->size; i++)\n-    {\n-      SBITMAP_ELT_TYPE tmp = *ap | (*bp & ~*cp);\n-      if (*dstp != tmp)\n-\tchanged = 1;\n-      *dstp = tmp;\n-      dstp++; ap++; bp++; cp++;\n-    }\n-  return changed;\n-}\n-\n-/* Set bitmap DST to the bitwise negation of the bitmap SRC.  */\n-\n-void\n-sbitmap_not (dst, src)\n-     sbitmap dst, src;\n-{\n-  int i;\n-  sbitmap_ptr dstp, ap;\n-\n-  dstp = dst->elms;\n-  ap = src->elms;\n-  for (i = 0; i < dst->size; i++)\n-    {\n-      SBITMAP_ELT_TYPE tmp = ~(*ap);\n-      *dstp = tmp;\n-      dstp++; ap++;\n-    }\n-}\n-\n-/* Set the bits in DST to be the difference between the bits\n-   in A and the bits in B. i.e. dst = a - b.\n-   The - operator is implemented as a & (~b).  */\n-\n-void\n-sbitmap_difference (dst, a, b)\n-     sbitmap dst, a, b;\n-{\n-  int i;\n-  sbitmap_ptr dstp, ap, bp;\n-\n-  dstp = dst->elms;\n-  ap = a->elms;\n-  bp = b->elms;\n-  for (i = 0; i < dst->size; i++)\n-    *dstp++ = *ap++ & (~*bp++);\n-}\n-\n-/* Set DST to be (A and B)).\n-   Return non-zero if any change is made.  */\n-\n-int\n-sbitmap_a_and_b (dst, a, b)\n-     sbitmap dst, a, b;\n-{\n-  int i,changed;\n-  sbitmap_ptr dstp, ap, bp;\n-\n-  changed = 0;\n-  dstp = dst->elms;\n-  ap = a->elms;\n-  bp = b->elms;\n-  for (i = 0; i < dst->size; i++)\n-    {\n-      SBITMAP_ELT_TYPE tmp = *ap & *bp;\n-      if (*dstp != tmp)\n-\tchanged = 1;\n-      *dstp = tmp;\n-      dstp++; ap++; bp++;\n-    }\n-  return changed;\n-}\n-/* Set DST to be (A or B)).\n-   Return non-zero if any change is made.  */\n-\n-int\n-sbitmap_a_or_b (dst, a, b)\n-     sbitmap dst, a, b;\n-{\n-  int i,changed;\n-  sbitmap_ptr dstp, ap, bp;\n-\n-  changed = 0;\n-  dstp = dst->elms;\n-  ap = a->elms;\n-  bp = b->elms;\n-  for (i = 0; i < dst->size; i++)\n-    {\n-      SBITMAP_ELT_TYPE tmp = *ap | *bp;\n-      if (*dstp != tmp)\n-\tchanged = 1;\n-      *dstp = tmp;\n-      dstp++; ap++; bp++;\n-    }\n-  return changed;\n-}\n-\n-/* Set DST to be (A or (B and C)).\n-   Return non-zero if any change is made.  */\n-\n-int\n-sbitmap_a_or_b_and_c (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n-{\n-  int i,changed;\n-  sbitmap_ptr dstp, ap, bp, cp;\n-\n-  changed = 0;\n-  dstp = dst->elms;\n-  ap = a->elms;\n-  bp = b->elms;\n-  cp = c->elms;\n-  for (i = 0; i < dst->size; i++)\n-    {\n-      SBITMAP_ELT_TYPE tmp = *ap | (*bp & *cp);\n-      if (*dstp != tmp)\n-\tchanged = 1;\n-      *dstp = tmp;\n-      dstp++; ap++; bp++; cp++;\n-    }\n-  return changed;\n-}\n-\n-/* Set DST to be (A ann (B or C)).\n-   Return non-zero if any change is made.  */\n-\n-int\n-sbitmap_a_and_b_or_c (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n-{\n-  int i,changed;\n-  sbitmap_ptr dstp, ap, bp, cp;\n-\n-  changed = 0;\n-  dstp = dst->elms;\n-  ap = a->elms;\n-  bp = b->elms;\n-  cp = c->elms;\n-  for (i = 0; i < dst->size; i++)\n-    {\n-      SBITMAP_ELT_TYPE tmp = *ap & (*bp | *cp);\n-      if (*dstp != tmp)\n-\tchanged = 1;\n-      *dstp = tmp;\n-      dstp++; ap++; bp++; cp++;\n-    }\n-  return changed;\n-}\n-\n-/* Set the bitmap DST to the intersection of SRC of all predecessors or\n-   successors of block number BB (PRED_SUCC says which).  */\n-\n-void\n-sbitmap_intersect_of_predsucc (dst, src, bb, pred_succ)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n-     int_list_ptr *pred_succ;\n-{\n-  int_list_ptr ps;\n-  int ps_bb;\n-  int set_size = dst->size;\n-\n-  ps = pred_succ[bb];\n-\n-  /* It is possible that there are no predecessors(/successors).\n-     This can happen for example in unreachable code.  */\n-\n-  if (ps == NULL)\n-    {\n-      /* In APL-speak this is the `and' reduction of the empty set and thus\n-\t the result is the identity for `and'.  */\n-      sbitmap_ones (dst);\n-      return;\n-    }\n-\n-  /* Set result to first predecessor/successor.  */\n-\n-  for ( ; ps != NULL; ps = ps->next)\n-    {\n-      ps_bb = INT_LIST_VAL (ps);\n-      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n-\tcontinue;\n-      sbitmap_copy (dst, src[ps_bb]);\n-      /* Break out since we're only doing first predecessor.  */\n-      break;\n-    }\n-  if (ps == NULL)\n-    return;\n-\n-  /* Now do the remaining predecessors/successors.  */\n-\n-  for (ps = ps->next; ps != NULL; ps = ps->next)\n-    {\n-      int i;\n-      sbitmap_ptr p,r;\n-\n-      ps_bb = INT_LIST_VAL (ps);\n-      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n-\tcontinue;\n-\n-      p = src[ps_bb]->elms;\n-      r = dst->elms;\n-\n-      for (i = 0; i < set_size; i++)\n-\t*r++ &= *p++;\n-    }\n-}\n-\n-/* Set the bitmap DST to the intersection of SRC of all predecessors\n-   of block number BB.  */\n-\n-void\n-sbitmap_intersect_of_predecessors (dst, src, bb, s_preds)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n-     int_list_ptr *s_preds;\n-{\n-  sbitmap_intersect_of_predsucc (dst, src, bb, s_preds);\n-}\n-\n-/* Set the bitmap DST to the intersection of SRC of all successors\n-   of block number BB.  */\n-\n-void\n-sbitmap_intersect_of_successors (dst, src, bb, s_succs)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n-     int_list_ptr *s_succs;\n-{\n-  sbitmap_intersect_of_predsucc (dst, src, bb, s_succs);\n-}\n-\n-/* Set the bitmap DST to the union of SRC of all predecessors/successors of\n-   block number BB.  */\n-\n-void\n-sbitmap_union_of_predsucc (dst, src, bb, pred_succ)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n-     int_list_ptr *pred_succ;\n-{\n-  int_list_ptr ps;\n-  int ps_bb;\n-  int set_size = dst->size;\n-\n-  ps = pred_succ[bb];\n-\n-  /* It is possible that there are no predecessors(/successors).\n-     This can happen for example in unreachable code.  */\n-\n-  if (ps == NULL)\n-    {\n-      /* In APL-speak this is the `or' reduction of the empty set and thus\n-\t the result is the identity for `or'.  */\n-      sbitmap_zero (dst);\n-      return;\n-    }\n-\n-  /* Set result to first predecessor/successor.  */\n-\n-  for ( ; ps != NULL; ps = ps->next)\n-    {\n-      ps_bb = INT_LIST_VAL (ps);\n-      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n-\tcontinue;\n-      sbitmap_copy (dst, src[ps_bb]);\n-      /* Break out since we're only doing first predecessor.  */\n-      break;\n-    }\n-  if (ps == NULL)\n-    return;\n-\n-  /* Now do the remaining predecessors/successors.  */\n-\n-  for (ps = ps->next; ps != NULL; ps = ps->next)\n-    {\n-      int i;\n-      sbitmap_ptr p,r;\n-\n-      ps_bb = INT_LIST_VAL (ps);\n-      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n-\tcontinue;\n-\n-      p = src[ps_bb]->elms;\n-      r = dst->elms;\n-\n-      for (i = 0; i < set_size; i++)\n-\t*r++ |= *p++;\n-    }\n-}\n-\n-/* Set the bitmap DST to the union of SRC of all predecessors of\n-   block number BB.  */\n-\n-void\n-sbitmap_union_of_predecessors (dst, src, bb, s_preds)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n-     int_list_ptr *s_preds;\n-{\n-  sbitmap_union_of_predsucc (dst, src, bb, s_preds);\n-}\n-\n-/* Set the bitmap DST to the union of SRC of all predecessors of\n-   block number BB.  */\n-\n-void\n-sbitmap_union_of_successors (dst, src, bb, s_succ)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n-     int_list_ptr *s_succ;\n-{\n-  sbitmap_union_of_predsucc (dst, src, bb, s_succ);\n-}\n \n /* Compute dominator relationships.  */\n void"}, {"sha": "db47d327ea5e3a257c7d920a9bcc26164bef8efb", "filename": "gcc/sbitmap.c", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "patch": "@@ -0,0 +1,469 @@\n+/* Simple bitmaps.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"basic-block.h\"\n+\n+/* Bitmap manipulation routines.  */\n+\n+/* Allocate a simple bitmap of N_ELMS bits.  */\n+\n+sbitmap\n+sbitmap_alloc (n_elms)\n+     int n_elms;\n+{\n+  int bytes, size, amt;\n+  sbitmap bmap;\n+\n+  size = SBITMAP_SET_SIZE (n_elms);\n+  bytes = size * sizeof (SBITMAP_ELT_TYPE);\n+  amt = (sizeof (struct simple_bitmap_def)\n+\t + bytes - sizeof (SBITMAP_ELT_TYPE));\n+  bmap = (sbitmap) xmalloc (amt);\n+  bmap->n_bits = n_elms;\n+  bmap->size = size;\n+  bmap->bytes = bytes;\n+  return bmap;\n+}\n+\n+/* Allocate a vector of N_VECS bitmaps of N_ELMS bits.  */\n+\n+sbitmap *\n+sbitmap_vector_alloc (n_vecs, n_elms)\n+     int n_vecs, n_elms;\n+{\n+  int i, bytes, offset, elm_bytes, size, amt, vector_bytes;\n+  sbitmap *bitmap_vector;\n+\n+  size = SBITMAP_SET_SIZE (n_elms);\n+  bytes = size * sizeof (SBITMAP_ELT_TYPE);\n+  elm_bytes = (sizeof (struct simple_bitmap_def)\n+\t       + bytes - sizeof (SBITMAP_ELT_TYPE));\n+  vector_bytes = n_vecs * sizeof (sbitmap *);\n+\n+  /* Round up `vector_bytes' to account for the alignment requirements\n+     of an sbitmap.  One could allocate the vector-table and set of sbitmaps\n+     separately, but that requires maintaining two pointers or creating\n+     a cover struct to hold both pointers (so our result is still just\n+     one pointer).  Neither is a bad idea, but this is simpler for now.  */\n+  {\n+    /* Based on DEFAULT_ALIGNMENT computation in obstack.c.  */\n+    struct { char x; SBITMAP_ELT_TYPE y; } align;\n+    int alignment = (char *) & align.y - & align.x;\n+    vector_bytes = (vector_bytes + alignment - 1) & ~ (alignment - 1);\n+  }\n+\n+  amt = vector_bytes + (n_vecs * elm_bytes);\n+  bitmap_vector = (sbitmap *) xmalloc (amt);\n+\n+  for (i = 0, offset = vector_bytes;\n+       i < n_vecs;\n+       i++, offset += elm_bytes)\n+    {\n+      sbitmap b = (sbitmap) ((char *) bitmap_vector + offset);\n+      bitmap_vector[i] = b;\n+      b->n_bits = n_elms;\n+      b->size = size;\n+      b->bytes = bytes;\n+    }\n+\n+  return bitmap_vector;\n+}\n+\n+/* Copy sbitmap SRC to DST.  */\n+\n+void\n+sbitmap_copy (dst, src)\n+     sbitmap dst, src;\n+{\n+  bcopy (src->elms, dst->elms, sizeof (SBITMAP_ELT_TYPE) * dst->size);\n+}\n+\n+/* Zero all elements in a bitmap.  */\n+\n+void\n+sbitmap_zero (bmap)\n+     sbitmap bmap;\n+{\n+  bzero ((char *) bmap->elms, bmap->bytes);\n+}\n+\n+/* Set to ones all elements in a bitmap.  */\n+\n+void\n+sbitmap_ones (bmap)\n+     sbitmap bmap;\n+{\n+  memset (bmap->elms, -1, bmap->bytes);\n+}\n+\n+/* Zero a vector of N_VECS bitmaps.  */\n+\n+void\n+sbitmap_vector_zero (bmap, n_vecs)\n+     sbitmap *bmap;\n+     int n_vecs;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_vecs; i++)\n+    sbitmap_zero (bmap[i]);\n+}\n+\n+/* Set to ones a vector of N_VECS bitmaps.  */\n+\n+void\n+sbitmap_vector_ones (bmap, n_vecs)\n+     sbitmap *bmap;\n+     int n_vecs;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_vecs; i++)\n+    sbitmap_ones (bmap[i]);\n+}\n+\n+/* Set DST to be A union (B - C).\n+   DST = A | (B & ~C).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_union_of_diff (dst, a, b, c)\n+     sbitmap dst, a, b, c;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp, cp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  cp = c->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap | (*bp & ~*cp);\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++; cp++;\n+    }\n+  return changed;\n+}\n+\n+/* Set bitmap DST to the bitwise negation of the bitmap SRC.  */\n+\n+void\n+sbitmap_not (dst, src)\n+     sbitmap dst, src;\n+{\n+  int i;\n+  sbitmap_ptr dstp, ap;\n+\n+  dstp = dst->elms;\n+  ap = src->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = ~(*ap);\n+      *dstp = tmp;\n+      dstp++; ap++;\n+    }\n+}\n+\n+/* Set the bits in DST to be the difference between the bits\n+   in A and the bits in B. i.e. dst = a - b.\n+   The - operator is implemented as a & (~b).  */\n+\n+void\n+sbitmap_difference (dst, a, b)\n+     sbitmap dst, a, b;\n+{\n+  int i;\n+  sbitmap_ptr dstp, ap, bp;\n+\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  for (i = 0; i < dst->size; i++)\n+    *dstp++ = *ap++ & (~*bp++);\n+}\n+\n+/* Set DST to be (A and B)).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_a_and_b (dst, a, b)\n+     sbitmap dst, a, b;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap & *bp;\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++;\n+    }\n+  return changed;\n+}\n+/* Set DST to be (A or B)).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_a_or_b (dst, a, b)\n+     sbitmap dst, a, b;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap | *bp;\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++;\n+    }\n+  return changed;\n+}\n+\n+/* Set DST to be (A or (B and C)).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_a_or_b_and_c (dst, a, b, c)\n+     sbitmap dst, a, b, c;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp, cp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  cp = c->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap | (*bp & *cp);\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++; cp++;\n+    }\n+  return changed;\n+}\n+\n+/* Set DST to be (A ann (B or C)).\n+   Return non-zero if any change is made.  */\n+\n+int\n+sbitmap_a_and_b_or_c (dst, a, b, c)\n+     sbitmap dst, a, b, c;\n+{\n+  int i,changed;\n+  sbitmap_ptr dstp, ap, bp, cp;\n+\n+  changed = 0;\n+  dstp = dst->elms;\n+  ap = a->elms;\n+  bp = b->elms;\n+  cp = c->elms;\n+  for (i = 0; i < dst->size; i++)\n+    {\n+      SBITMAP_ELT_TYPE tmp = *ap & (*bp | *cp);\n+      if (*dstp != tmp)\n+\tchanged = 1;\n+      *dstp = tmp;\n+      dstp++; ap++; bp++; cp++;\n+    }\n+  return changed;\n+}\n+\n+/* Set the bitmap DST to the intersection of SRC of all predecessors or\n+   successors of block number BB (PRED_SUCC says which).  */\n+\n+void\n+sbitmap_intersect_of_predsucc (dst, src, bb, pred_succ)\n+     sbitmap dst;\n+     sbitmap *src;\n+     int bb;\n+     int_list_ptr *pred_succ;\n+{\n+  int_list_ptr ps;\n+  int ps_bb;\n+  int set_size = dst->size;\n+\n+  ps = pred_succ[bb];\n+\n+  /* It is possible that there are no predecessors(/successors).\n+     This can happen for example in unreachable code.  */\n+\n+  if (ps == NULL)\n+    {\n+      /* In APL-speak this is the `and' reduction of the empty set and thus\n+\t the result is the identity for `and'.  */\n+      sbitmap_ones (dst);\n+      return;\n+    }\n+\n+  /* Set result to first predecessor/successor.  */\n+\n+  for ( ; ps != NULL; ps = ps->next)\n+    {\n+      ps_bb = INT_LIST_VAL (ps);\n+      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n+\tcontinue;\n+      sbitmap_copy (dst, src[ps_bb]);\n+      /* Break out since we're only doing first predecessor.  */\n+      break;\n+    }\n+  if (ps == NULL)\n+    return;\n+\n+  /* Now do the remaining predecessors/successors.  */\n+\n+  for (ps = ps->next; ps != NULL; ps = ps->next)\n+    {\n+      int i;\n+      sbitmap_ptr p,r;\n+\n+      ps_bb = INT_LIST_VAL (ps);\n+      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n+\tcontinue;\n+\n+      p = src[ps_bb]->elms;\n+      r = dst->elms;\n+\n+      for (i = 0; i < set_size; i++)\n+\t*r++ &= *p++;\n+    }\n+}\n+\n+/* Set the bitmap DST to the union of SRC of all predecessors/successors of\n+   block number BB.  */\n+\n+void\n+sbitmap_union_of_predsucc (dst, src, bb, pred_succ)\n+     sbitmap dst;\n+     sbitmap *src;\n+     int bb;\n+     int_list_ptr *pred_succ;\n+{\n+  int_list_ptr ps;\n+  int ps_bb;\n+  int set_size = dst->size;\n+\n+  ps = pred_succ[bb];\n+\n+  /* It is possible that there are no predecessors(/successors).\n+     This can happen for example in unreachable code.  */\n+\n+  if (ps == NULL)\n+    {\n+      /* In APL-speak this is the `or' reduction of the empty set and thus\n+\t the result is the identity for `or'.  */\n+      sbitmap_zero (dst);\n+      return;\n+    }\n+\n+  /* Set result to first predecessor/successor.  */\n+\n+  for ( ; ps != NULL; ps = ps->next)\n+    {\n+      ps_bb = INT_LIST_VAL (ps);\n+      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n+\tcontinue;\n+      sbitmap_copy (dst, src[ps_bb]);\n+      /* Break out since we're only doing first predecessor.  */\n+      break;\n+    }\n+  if (ps == NULL)\n+    return;\n+\n+  /* Now do the remaining predecessors/successors.  */\n+\n+  for (ps = ps->next; ps != NULL; ps = ps->next)\n+    {\n+      int i;\n+      sbitmap_ptr p,r;\n+\n+      ps_bb = INT_LIST_VAL (ps);\n+      if (ps_bb == ENTRY_BLOCK || ps_bb == EXIT_BLOCK)\n+\tcontinue;\n+\n+      p = src[ps_bb]->elms;\n+      r = dst->elms;\n+\n+      for (i = 0; i < set_size; i++)\n+\t*r++ |= *p++;\n+    }\n+}\n+\n+void\n+dump_sbitmap (file, bmap)\n+     FILE *file;\n+     sbitmap bmap;\n+{\n+  int i,j,n;\n+  int set_size = bmap->size;\n+  int total_bits = bmap->n_bits;\n+\n+  fprintf (file, \"  \");\n+  for (i = n = 0; i < set_size && n < total_bits; i++)\n+    {\n+      for (j = 0; j < SBITMAP_ELT_BITS && n < total_bits; j++, n++)\n+\t{\n+\t  if (n != 0 && n % 10 == 0)\n+\t    fprintf (file, \" \");\n+\t  fprintf (file, \"%d\", (bmap->elms[i] & (1L << j)) != 0);\n+\t}\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+void\n+dump_sbitmap_vector (file, title, subtitle, bmaps, n_maps)\n+     FILE *file;\n+     char *title, *subtitle;\n+     sbitmap *bmaps;\n+     int n_maps;\n+{\n+  int bb;\n+\n+  fprintf (file, \"%s\\n\", title);\n+  for (bb = 0; bb < n_maps; bb++)\n+    {\n+      fprintf (file, \"%s %d\\n\", subtitle, bb);\n+      dump_sbitmap (file, bmaps[bb]);\n+    }\n+  fprintf (file, \"\\n\");\n+}"}, {"sha": "350142d809de9d45cdca2450cf51d0b2fcb8b10f", "filename": "gcc/sbitmap.h", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6c11d6e5d0ad0306c806e61d17e4b92f681c05/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=5f6c11d6e5d0ad0306c806e61d17e4b92f681c05", "patch": "@@ -0,0 +1,122 @@\n+/* Simple bitmaps.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* It's not clear yet whether using bitmap.[ch] will be a win.\n+   It should be straightforward to convert so for now we keep things simple\n+   while more important issues are dealt with.  */\n+\n+#define SBITMAP_ELT_BITS HOST_BITS_PER_WIDE_INT\n+#define SBITMAP_ELT_TYPE unsigned HOST_WIDE_INT\n+\n+typedef struct simple_bitmap_def {\n+  /* Number of bits.  */\n+  int n_bits;\n+  /* Size in elements.  */\n+  int size;\n+  /* Size in bytes.  */\n+  int bytes;\n+  /* The elements.  */\n+  SBITMAP_ELT_TYPE elms[1];\n+} *sbitmap;\n+\n+typedef SBITMAP_ELT_TYPE *sbitmap_ptr;\n+\n+/* Return the set size needed for N elements.  */\n+#define SBITMAP_SET_SIZE(n) (((n) + SBITMAP_ELT_BITS - 1) / SBITMAP_ELT_BITS)\n+\n+/* set bit number bitno in the bitmap */\n+#define SET_BIT(bitmap, bitno)\t\t\t\t\t\\\n+  ((bitmap)->elms [(bitno) / SBITMAP_ELT_BITS]\t\t\t\\\n+   |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS)\n+\n+/* test if bit number bitno in the bitmap is set */\n+#define TEST_BIT(bitmap, bitno) \\\n+((bitmap)->elms [(bitno) / SBITMAP_ELT_BITS] >> (bitno) % SBITMAP_ELT_BITS & 1)\n+\n+/* reset bit number bitno in the bitmap  */\n+#define RESET_BIT(bitmap, bitno)\t\t\t\t\\\n+  ((bitmap)->elms [(bitno) / SBITMAP_ELT_BITS]\t\t\t\\\n+   &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS))\n+\n+/* Loop over all elements of SBITSET, starting with MIN.  */\n+#define EXECUTE_IF_SET_IN_SBITMAP(SBITMAP, MIN, N, CODE)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  unsigned int bit_num_ = (MIN) % (unsigned) SBITMAP_ELT_BITS;\t\t\\\n+  unsigned int word_num_ = (MIN) / (unsigned) SBITMAP_ELT_BITS;\t\t\\\n+  unsigned int size_ = (SBITMAP)->size;\t\t\t\t\t\\\n+  SBITMAP_ELT_TYPE *ptr_ = (SBITMAP)->elms;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  while (word_num_ < size_)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      SBITMAP_ELT_TYPE word_ = ptr_[word_num_];\t\t\t\t\\\n+      if (word_ != 0)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  for (; bit_num_ < SBITMAP_ELT_BITS; ++bit_num_)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      SBITMAP_ELT_TYPE mask_ = (SBITMAP_ELT_TYPE)1 << bit_num_;\t\\\n+\t      if ((word_ & mask_) != 0)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  word_ &= ~mask_;\t\t\t\t\t\\\n+\t\t  (N) = word_num_ * SBITMAP_ELT_BITS + bit_num_;\t\\\n+\t\t  CODE;\t\t\t\t\t\t\t\\\n+\t\t  if (word_ == 0)\t\t\t\t\t\\\n+\t\t    break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      bit_num_ = 0;\t\t\t\t\t\t\t\\\n+      word_num_++;\t\t\t\t\t\t\t\\\n+   }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#define sbitmap_free(map)\t\tfree(map)\n+#define sbitmap_vector_free(vec)\tfree(vec)\n+\n+extern void dump_sbitmap PROTO ((FILE *, sbitmap));\n+extern void dump_sbitmap_vector PROTO ((FILE *, char *, char *,\n+\t\t\t\t\tsbitmap *, int));\n+\n+extern sbitmap sbitmap_alloc PROTO ((int));\n+extern sbitmap *sbitmap_vector_alloc PROTO ((int, int));\n+\n+extern void sbitmap_copy PROTO ((sbitmap, sbitmap));\n+extern void sbitmap_zero PROTO ((sbitmap));\n+extern void sbitmap_ones PROTO ((sbitmap));\n+extern void sbitmap_vector_zero PROTO ((sbitmap *, int));\n+extern void sbitmap_vector_ones PROTO ((sbitmap *, int));\n+\n+extern int sbitmap_union_of_diff PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern void sbitmap_difference PROTO ((sbitmap, sbitmap, sbitmap));\n+extern void sbitmap_not PROTO ((sbitmap, sbitmap));\n+extern int sbitmap_a_or_b_and_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_and_b_or_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_and_b PROTO ((sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_or_b PROTO ((sbitmap, sbitmap, sbitmap));\n+\n+struct int_list;\n+extern void sbitmap_intersect_of_predsucc PROTO ((sbitmap, sbitmap *,\n+\t\t\t\t\t\t  int, struct int_list **));\n+#define sbitmap_intersect_of_predecessors  sbitmap_intersect_of_predsucc\n+#define sbitmap_intersect_of_successors    sbitmap_intersect_of_predsucc\n+\n+extern void sbitmap_union_of_predsucc PROTO ((sbitmap, sbitmap *, int,\n+\t\t\t\t\t      struct int_list **));\n+#define sbitmap_union_of_predecessors  sbitmap_union_of_predsucc\n+#define sbitmap_union_of_successors    sbitmap_union_of_predsucc"}]}