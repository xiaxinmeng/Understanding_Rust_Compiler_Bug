{"sha": "22e5c8fa3c715dad01545ad6feb78c8e577d1578", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlNWM4ZmEzYzcxNWRhZDAxNTQ1YWQ2ZmViNzhjOGU1NzdkMTU3OA==", "commit": {"author": {"name": "Carlo Wood", "email": "carlo@alinoe.com", "date": "2003-11-12T02:18:37Z"}, "committer": {"name": "Carlo Wood", "email": "carlo@gcc.gnu.org", "date": "2003-11-12T02:18:37Z"}, "message": "re PR libstdc++/12947 (Demangler bug)\n\nPR libstdc++/12947\n* bits/demangle.h\n(_GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS): Added.\n(_GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME): Added.\n(session<Allocator>::next_peek() const): Added.\n(decode_non_negative_decimal_integer(string_type&)):\nRenamed from decode_decimal_integer(string_type&).\n(session<Allocator>::decode_nested_name):\nDecode <template_param> as well.\n(session<Allocator>::add_substitution):\nHandle <template-param> for <nested-name>'s.\n(enum xary_nt): Added.\n(struct entry_st): Added member `xary_nt type' instead of `bool unary'.\n(symbol_name_table_c): Updated for `entry_st::type' and additional\noperators (unary `operator+' and `sizeof(type)').\n(offset_table_c): Updated for new operators (causing a new hash map).\n(decode_operator_name): Match the updated hash map.\n(session<Allocator>::decode_expression):\nSupport for `sizeof ([typename] type)' (st),\ndependent names (sr) and casting operator (cv).  Handle\n`entry_st::type'.  Handle _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\nand _GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME.\n(session<Allocator>::decode_type_with_postfix):\nSupport `extern \"C\"' function types (FY).\n* testsuite/demangle/regression/cw-16.cc: Added tests for the\nadded functionality.\n* testsuite/demangle/regression/3111-2.cc: sizeof now has a space\nappended.\n\nFrom-SVN: r73480", "tree": {"sha": "21e108bce915a46c5affc71fe109874f7875bfde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21e108bce915a46c5affc71fe109874f7875bfde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22e5c8fa3c715dad01545ad6feb78c8e577d1578", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e5c8fa3c715dad01545ad6feb78c8e577d1578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22e5c8fa3c715dad01545ad6feb78c8e577d1578", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e5c8fa3c715dad01545ad6feb78c8e577d1578/comments", "author": {"login": "CarloWood", "id": 590303, "node_id": "MDQ6VXNlcjU5MDMwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/590303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CarloWood", "html_url": "https://github.com/CarloWood", "followers_url": "https://api.github.com/users/CarloWood/followers", "following_url": "https://api.github.com/users/CarloWood/following{/other_user}", "gists_url": "https://api.github.com/users/CarloWood/gists{/gist_id}", "starred_url": "https://api.github.com/users/CarloWood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CarloWood/subscriptions", "organizations_url": "https://api.github.com/users/CarloWood/orgs", "repos_url": "https://api.github.com/users/CarloWood/repos", "events_url": "https://api.github.com/users/CarloWood/events{/privacy}", "received_events_url": "https://api.github.com/users/CarloWood/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "729bf8ab4a3f8e4e83266e249211e4304d5a542c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729bf8ab4a3f8e4e83266e249211e4304d5a542c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/729bf8ab4a3f8e4e83266e249211e4304d5a542c"}], "stats": {"total": 392, "additions": 298, "deletions": 94}, "files": [{"sha": "985729da7bd3297cedb36576225f49b0eaa729a7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e5c8fa3c715dad01545ad6feb78c8e577d1578/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e5c8fa3c715dad01545ad6feb78c8e577d1578/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=22e5c8fa3c715dad01545ad6feb78c8e577d1578", "patch": "@@ -1,3 +1,34 @@\n+2003-11-12  Carlo Wood  <carlo@alinoe.com>\n+\n+        PR libstdc++/12947\n+\t* bits/demangle.h\n+\t(_GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS): Added.\n+\t(_GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME): Added.\n+\t(session<Allocator>::next_peek() const): Added.\n+\t(decode_non_negative_decimal_integer(string_type&)):\n+\tRenamed from decode_decimal_integer(string_type&).\n+\t(session<Allocator>::decode_nested_name):\n+\tDecode <template_param> as well.\n+\t(session<Allocator>::add_substitution):\n+\tHandle <template-param> for <nested-name>'s.\n+\t(enum xary_nt): Added.\n+\t(struct entry_st): Added member `xary_nt type' instead of `bool unary'.\n+\t(symbol_name_table_c): Updated for `entry_st::type' and additional\n+\toperators (unary `operator+' and `sizeof(type)').\n+\t(offset_table_c): Updated for new operators (causing a new hash map).\n+\t(decode_operator_name): Match the updated hash map.\n+\t(session<Allocator>::decode_expression):\n+\tSupport for `sizeof ([typename] type)' (st),\n+\tdependent names (sr) and casting operator (cv).  Handle\n+\t`entry_st::type'.  Handle _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n+\tand _GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME.\n+\t(session<Allocator>::decode_type_with_postfix):\n+\tSupport `extern \"C\"' function types (FY).\n+\t* testsuite/demangle/regression/cw-16.cc: Added tests for the\n+\tadded functionality.\n+\t* testsuite/demangle/regression/3111-2.cc: sizeof now has a space\n+\tappended.\n+\n 2003-11-11  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/12875"}, {"sha": "af8cff9645c8452916549118d59eeb67059b6a43", "filename": "libstdc++-v3/include/bits/demangle.h", "status": "modified", "additions": 253, "deletions": 92, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e5c8fa3c715dad01545ad6feb78c8e577d1578/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e5c8fa3c715dad01545ad6feb78c8e577d1578/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h?ref=22e5c8fa3c715dad01545ad6feb78c8e577d1578", "patch": "@@ -28,6 +28,10 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n+// This file implements demangling of \"C++ ABI for Itanium\"-mangled symbol\n+// and type names as described in Revision 1.73 of the C++ ABI as can be found\n+// at http://www.codesourcery.com/cxx-abi/abi.html#mangling\n+\n #ifndef _DEMANGLER_H\n #define _DEMANGLER_H 1\n \n@@ -67,6 +71,15 @@\n // Default behaviour:\t\t\t\t\t4\n // Use also an explicit cast for int in literals:\t(int)4\n \n+// _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n+// Default behaviour:\t\t\t\t\t(i) < (3), sizeof (int)\n+// Don't output spaces around operators in expressions:\t(i)<(3), sizeof(int)\n+\n+// _GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME\n+// Default behaviour:\t\t\t\t\tsizeof (X::t)\n+// Put 'typename' infront of <nested-name> types\n+// inside a 'sizeof':\t\t\t\t\tsizeof (typename X::t)\n+\n namespace __gnu_cxx\n {\n   namespace demangler\n@@ -362,6 +375,10 @@ namespace __gnu_cxx\n \tcurrent(void) const\n \t{ return (M_pos > M_maxpos) ? 0 : M_str[M_pos]; }\n \n+\tchar\n+\tnext_peek(void) const\n+\t{ return (M_pos >= M_maxpos) ? 0 : M_str[M_pos + 1]; }\n+\n \tchar\n \tnext(void)\n \t{ return (M_pos >= M_maxpos) ? 0 : M_str[++M_pos]; }\n@@ -406,7 +423,7 @@ namespace __gnu_cxx\n \t    qualifier_list<Allocator>* qualifiers = NULL);\n \tbool decode_unqualified_name(string_type& output);\n \tbool decode_unscoped_name(string_type& output);\n-\tbool decode_decimal_integer(string_type& output);\n+\tbool decode_non_negative_decimal_integer(string_type& output);\n \tbool decode_special_name(string_type& output);\n       };\n \n@@ -465,6 +482,8 @@ namespace __gnu_cxx\n \t\t    subst += \"::\";\n \t\t  if (current() == 'S')\n \t\t    decode_substitution(subst);\n+\t\t  else if (current() == 'T')\n+\t\t    decode_template_param(subst);\n \t\t  else\n \t\t    decode_unqualified_name(subst);\n \t\t}\n@@ -500,13 +519,14 @@ namespace __gnu_cxx\n     inline char tolower(char c) { return isupper(c) ? c - 'A' + 'a' : c; }\n \n     //\n-    // <decimal-integer> ::= 0\n-    //                   ::= 1|2|3|4|5|6|7|8|9 [<digit>+]\n-    // <digit>           ::= 0|1|2|3|4|5|6|7|8|9\n+    // <non-negative decimal integer> ::= 0\n+    //                                ::= 1|2|3|4|5|6|7|8|9 [<digit>+]\n+    // <digit>                        ::= 0|1|2|3|4|5|6|7|8|9\n     //\n     template<typename Allocator>\n       bool\n-      session<Allocator>::decode_decimal_integer(string_type& output)\n+      session<Allocator>::\n+\t  decode_non_negative_decimal_integer(string_type& output)\n       {\n \tchar c = current();\n \tif (c == '0')\n@@ -527,20 +547,20 @@ namespace __gnu_cxx\n \treturn M_result;\n       }\n \n-    // <number> ::= [n] <decimal-integer>\n+    // <number> ::= [n] <non-negative decimal integer>\n     //\n     template<typename Allocator>\n       bool\n       session<Allocator>::decode_number(string_type& output)\n       {\n \t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_number\");\n \tif (current() != 'n')\n-\t  decode_decimal_integer(output);\n+\t  decode_non_negative_decimal_integer(output);\n \telse\n \t{\n \t  output += '-';\n \t  eat_current();\n-\t  decode_decimal_integer(output);\n+\t  decode_non_negative_decimal_integer(output);\n \t}\n \t_GLIBCXX_DEMANGLER_RETURN;\n       }\n@@ -924,6 +944,7 @@ namespace __gnu_cxx\n     //   na\t\t\t\t# new[]\n     //   dl\t\t\t\t# delete        \n     //   da\t\t\t\t# delete[]      \n+    //   ps\t\t\t\t# + (unary)\n     //   ng\t\t\t\t# - (unary)     \n     //   ad\t\t\t\t# & (unary)     \n     //   de\t\t\t\t# * (unary)     \n@@ -965,37 +986,36 @@ namespace __gnu_cxx\n     //   pt\t\t\t\t# ->            \n     //   cl\t\t\t\t# ()            \n     //   ix\t\t\t\t# []            \n-    //   qu\t\t\t\t# ?             \n-    //   sz\t\t\t\t# sizeof        \n-    //   sr\t\t\t\t# scope resolution (::), see below        \n+    //   qu\t\t\t\t# ?\n+    //   st\t\t\t\t# sizeof (a type)\n+    //   sz\t\t\t\t# sizeof (an expression)\n     //   cv <type>\t\t\t# (cast)        \n     //   v <digit> <source-name>\t# vendor extended operator\n     //\n-    //\n     // Symbol operator codes exist of two characters, we need to find a\n     // quick hash so that their names can be looked up in a table.\n     //\n     // The puzzle :)\n     // Shift the rows so that there is at most one character per column.\n     //\n-    // A perfect solution:\n+    // A perfect solution (Oh no, it's THE MATRIX!):\n     //                                              horizontal\n-    //    .....................................     offset + 'a'\n-    // a, ||a||d|||||||||n||||s||||||||||||||||||\t    2\n-    // c, || || ||lm|o||| |||| ||||||||||||||||||\t   -3\n-    // d, || a| |e  | ||l |||| |||v||||||||||||||\t    3\n-    // e, ||  | |   o q|  |||| ||| ||||||||||||||\t   -4\n-    // g, |e  | |      |  t||| ||| ||||||||||||||\t   -3\n-    // i, |   | |      |   ||| ||| ||||||||||x|||    12\n-    // l, |   | |      e   ||| ||| ||st|||||| |||\t    9\n-    // m, |   | |          ||| ||| |i  lm|||| |||\t   18\n-    // n, a   e g          ||t |w| |     |||| |||\t    0\n-    // o,                  ||  | | |     ||o| r||\t   19\n-    // p,                  lm  p | t     || |  ||\t    6\n-    // q,                        |       || u  ||\t   14\n-    // r,                        |       |m    |s\t   20\n-    // s,                        r       z     | \t    6\n-    //    .....................................\n+    //    .......................................   offset + 'a'\n+    // a, a||d|||||||||n||||s||||||||||||||||||||       0\n+    // c,  || |||||||lm o||| ||||||||||||||||||||       0\n+    // d,  || a|||e||    l|| ||||||v|||||||||||||       4\n+    // e,  ||  ||| ||     || |||o|q |||||||||||||       8\n+    // g,  ||  ||| ||     || e|| |  ||||||||t||||      15\n+    // i,  ||  ||| ||     ||  || |  |||||||| |||x      15\n+    // l,  |e  ||| ||     st  || |  |||||||| |||       -2\n+    // m,  |   |i| lm         || |  |||||||| |||       -2\n+    // n,  a   e g            t| w  |||||||| |||        1\n+    // o,                      |    ||||o||r |||       16\n+    // p,                      |    ||lm |p  st|       17\n+    // q,                      |    u|   |     |        6\n+    // r,                      m     s   |     |        9\n+    // s,                                t     z       12\n+    //    .......................................\n     // ^            ^__ second character\n     // |___ first character\n     //\n@@ -1021,65 +1041,71 @@ namespace __gnu_cxx\n       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n       //   a    b    c    d    e    f    g    h    i    j    k\n-      0, -95,   0,-100, -94,-101,   0,-100,   0, -85,   0,   0,\n+      0, -97,   0, -97, -93, -89,   0, -82,   0, -82,   0,   0,\n       //   l    m    n    o    p    q    r    s    t    u    v\n-\t -88, -79, -97, -78, -91, -83, -77, -91,   0,   0,   0,\n+\t -99, -99, -96, -81, -80, -91, -88, -85,   0,   0,   0,\n #else\n       //   a    b    c    d    e    f    g    h    i    j    k\n-      0, 161,   0, 156, 162, 155,   0, 156,   0, 171,   0,   0,\n+      0, 159,   0, 159, 163, 167,   0, 174,   0, 174,   0,   0,\n       //   l    m    n    o    p    q    r    s    t    u    v\n-\t 168, 177, 159, 178, 165, 173, 179, 165,   0,   0,   0,\n+\t 157, 157, 160, 175, 176, 165, 168, 171,   0,   0,   0,\n #endif\n       // ... more zeros\n     };\n \n+    enum xary_nt {\n+      unary,\n+      binary,\n+      trinary\n+    };\n+\n     struct entry_st\n     {\n       char const* opcode;\n       char const* symbol_name;\n-      bool unary;\n+      xary_nt type;\n     };\n \n     entry_st const symbol_name_table_c[39] = {\n-      { \"na\",  \"operator new[]\", true },\n-      { \"ge\",  \"operator>=\", false },\n-      { \"aa\",  \"operator&&\", false },\n-      { \"da\",  \"operator delete[]\", true },\n-      { \"ne\",  \"operator!=\", false },\n-      { \"ad\",  \"operator&\", true },\t// unary\n-      { \"ng\",  \"operator-\", true },\t// unary\n-      { \"de\",  \"operator*\", true },\t// unary\n-      { \"cl\",  \"operator()\", true },\n-      { \"cm\",  \"operator,\", false },\n-      { \"eo=\", \"operator^\", false },\n-      { \"co\",  \"operator~\", false },\n-      { \"eq\",  \"operator==\", false },\n-      { \"le\",  \"operator<=\", false },\n-      { \"dl\",  \"operator delete\", true },\n-      { \"an=\", \"operator&\", false },\n-      { \"gt\",  \"operator>\", false },\n-      { \"pl=\", \"operator+\", false },\n-      { \"pm\",  \"operator->*\", false },\n-      { \"nt\",  \"operator!\", true },\n-      { \"as=\", \"operator\", false },\n-      { \"pp\",  \"operator++\", true },\n-      { \"nw\",  \"operator new\", true },\n-      { \"sr\",  \"::\", true },\n-      { \"dv=\", \"operator/\", false },\n-      { \"pt\",  \"operator->\", false },\n-      { \"mi=\", \"operator-\", false },\n-      { \"ls=\", \"operator<<\", false },\n-      { \"lt\",  \"operator<\", false },\n-      { \"ml=\", \"operator*\", false },\n-      { \"mm\",  \"operator--\", true },\n-      { \"sz\",  \"sizeof\", true },\n-      { \"rm=\", \"operator%\", false },\n-      { \"oo\",  \"operator||\", false },\n-      { \"qu\",  \"operator?\", false },\n-      { \"ix\",  \"operator[]\", true },\n-      { \"or=\", \"operator|\", false },\n-      { \"\", NULL, false },\n-      { \"rs=\", \"operator>>\", false }\n+      { \"aa\",  \"operator&&\", binary },\n+      { \"na\",  \"operator new[]\", unary },\n+      { \"le\",  \"operator<=\", binary },\n+      { \"ad\",  \"operator&\", unary },\n+      { \"da\",  \"operator delete[]\", unary },\n+      { \"ne\",  \"operator!=\", binary },\n+      { \"mi=\", \"operator-\", binary },\n+      { \"ng\",  \"operator-\", unary },\n+      { \"de\",  \"operator*\", unary },\n+      { \"ml=\", \"operator*\", binary },\n+      { \"mm\",  \"operator--\", unary },\n+      { \"cl\",  \"operator()\", unary },\n+      { \"cm\",  \"operator,\", binary },\n+      { \"an=\", \"operator&\", binary },\n+      { \"co\",  \"operator~\", binary },\n+      { \"dl\",  \"operator delete\", unary },\n+      { \"ls=\", \"operator<<\", binary },\n+      { \"lt\",  \"operator<\", binary },\n+      { \"as=\", \"operator\", binary },\n+      { \"ge\",  \"operator>=\", binary },\n+      { \"nt\",  \"operator!\", unary },\n+      { \"rm=\", \"operator%\", binary },\n+      { \"eo=\", \"operator^\", binary },\n+      { \"nw\",  \"operator new\", unary },\n+      { \"eq\",  \"operator==\", binary },\n+      { \"dv=\", \"operator/\", binary },\n+      { \"qu\",  \"operator?\", trinary },\n+      { \"rs=\", \"operator>>\", binary },\n+      { \"pl=\", \"operator+\", binary },\n+      { \"pm\",  \"operator->*\", binary },\n+      { \"oo\",  \"operator||\", binary },\n+      { \"st\",  \"sizeof\", unary },\n+      { \"pp\",  \"operator++\", unary },\n+      { \"or=\", \"operator|\", binary },\n+      { \"gt\",  \"operator>\", binary },\n+      { \"ps\",  \"operator+\", unary },\n+      { \"pt\",  \"operator->\", binary },\n+      { \"sz\",  \"sizeof\", unary },\n+      { \"ix\",  \"operator[]\", unary }\n     };\n \n     template<typename Allocator>\n@@ -1110,11 +1136,11 @@ namespace __gnu_cxx\n \t      if (opcode1 != current())\n \t\toutput += '=';\n \t      eat_current();\n-\t      if (hash == 27 || hash == 28)\n+\t      if (hash == 16 || hash == 17)\n \t\tM_template_args_need_space = true;\n \t      _GLIBCXX_DEMANGLER_RETURN;\n \t    }\n-\t    else if (opcode0 == 'c' && opcode1 == 'v')\n+\t    else if (opcode0 == 'c' && opcode1 == 'v')\t// casting operator\n \t    {\n \t      eat_current();\n \t      output += \"operator \";\n@@ -1141,10 +1167,15 @@ namespace __gnu_cxx\n     //\n     // <expression> ::= <unary operator-name> <expression>\n     //              ::= <binary operator-name> <expression> <expression>\n+    //              ::= <trinary operator-name> <expression> <expression> <expression>\n+    //              ::= st <type>\n+    //              ::= <template-param>\n+    //              ::= sr <type> <unqualified-name>                   # dependent name\n+    //              ::= sr <type> <unqualified-name> <template-args>   # dependent template-id\n     //              ::= <expr-primary>\n     //\n-    // <expr-primary> ::= <template-param>\t\t# Starts with a T\n-    //                ::= L <type> <value number> E\t# literal\n+    // <expr-primary> ::= L <type> <value number> E     # integer literal\n+    //                ::= L <type> <value float> E\t# floating literal\n     //                ::= L <mangled-name> E\t\t# external name\n     //\n     template<typename Allocator>\n@@ -1167,6 +1198,86 @@ namespace __gnu_cxx\n \t  eat_current();\n \t  _GLIBCXX_DEMANGLER_RETURN;\n \t}\n+\telse if (current() == 's')\n+\t{\n+\t  char opcode1 = next();\n+\t  if (opcode1 == 't' || opcode1 == 'z')\n+\t  {\n+\t    eat_current();\n+#ifdef _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n+\t    output += \"sizeof(\";\n+#else\n+\t    output += \"sizeof (\";\n+#endif\n+\t    if (opcode1 == 't')\n+\t    {\n+\t      // I cannot think of a mangled name that is valid for both cases\n+\t      // when just replacing the 't' by a 'z' or vica versa, which\n+\t      // indicates that there is no ambiguity that dictates the need\n+\t      // for a seperate \"st\" case, except to be able catch invalid\n+\t      // mangled names.  However there CAN be ambiguity in the demangled\n+\t      // name when there are both a type and a symbol of the same name,\n+\t      // which then leads to different encoding (of course) with\n+\t      // sizeof (type) or sizeof (expression) respectively, but that\n+\t      // ambiguity is not per se related to \"sizeof\" except that that\n+\t      // is the only place where both a type AND an expression are valid\n+\t      // in as part of a (template function) type.\n+\t      //\n+\t      // Example:\n+\t      //\n+\t      // struct B { typedef int t; };\n+\t      // struct A : public B { static int t[2]; };\n+\t      // template<int i, int j> struct C { typedef int q; };\n+\t      // template<int i, typename T>\n+\t      //   void f(typename C<sizeof (typename T::t),\n+\t      //                     sizeof (T::t)>::q) { }\n+\t      // void instantiate() { f<5, A>(0); }\n+\t      //\n+\t      // Leads to _Z1fILi5E1AEvN1CIXstN1T1tEEXszsrS2_1tEE1qE which\n+\t      // demangles as\n+\t      // void f<5, A>(C<sizeof (T::t), sizeof (T::t)>::q)\n+\t      //\n+\t      // This is ambiguity is very unlikely to happen and it is kind\n+\t      // of fuzzy to detect when adding a 'typename' makes sense.\n+\t      //\n+#ifdef _GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME\n+\t      // We can only get here inside a template parameter,\n+\t      // so this is syntactically correct if the given type is\n+\t      // a typedef.  The only disadvantage is that it is inconsistent\n+\t      // with all other places where the 'typename' keyword should be\n+\t      // used and we don't.\n+\t      // With this, the above example will demangle as\n+\t      // void f<5, A>(C<sizeof (typename T::t), sizeof (T::t)>::q)\n+\t      if (current() == 'N' ||\t// <nested-name>\n+\t      \t\t\t\t// This should be a safe bet.\n+\t          (current() == 'S' &&\n+\t\t   next_peek() == 't'))\t// std::something, guess that\n+\t\t   \t\t\t// this involves a typedef.\n+\t\toutput += \"typename \";\n+#endif\n+\t      if (!decode_type(output))\n+\t\t_GLIBCXX_DEMANGLER_FAILURE;\n+\t    }\n+\t    else\n+\t    {\n+\t      if (!decode_expression(output))\n+\t\t_GLIBCXX_DEMANGLER_FAILURE;\n+\t    }\n+\t    output += ')';\n+\t    _GLIBCXX_DEMANGLER_RETURN;\n+\t  }\n+\t  else if (current() == 'r')\n+\t  {\n+\t    eat_current();\n+\t    if (!decode_type(output))\n+\t      _GLIBCXX_DEMANGLER_FAILURE;\n+\t    output += \"::\";\n+\t    if (!decode_unqualified_name(output))\n+\t      _GLIBCXX_DEMANGLER_FAILURE;\n+\t    if (current() != 'I' || decode_template_args(output))\n+\t      _GLIBCXX_DEMANGLER_RETURN;\n+\t  }\n+\t}\n \telse\n \t{\n \t  char opcode0 = current();\n@@ -1187,33 +1298,59 @@ namespace __gnu_cxx\n \t      if (entry.opcode[0] == opcode0 && entry.opcode[1] == opcode1\n \t\t  && (opcode1 == current() || entry.opcode[2] == '='))\n \t      {\n-\t\tchar const* p = entry.symbol_name;\n-\t\tif (!strncmp(\"operator\", p, 8))\n-\t\t  p += 8;\n-\t\tif (*p == ' ')\n-\t\t  ++p;\n-\t\tif (entry.unary)\n-\t\t  output += p;\n+\t\tchar const* op = entry.symbol_name + 8;\t// Skip \"operator\".\n+\t\tif (*op == ' ')\t\t\t\t// operator new and delete.\n+\t\t  ++op;\n+\t\tif (entry.type == unary)\n+\t\t  output += op;\n \t\tbool is_eq = (opcode1 != current());\n \t\teat_current();\n \t\toutput += '(';\n \t\tif (!decode_expression(output))\n \t\t  _GLIBCXX_DEMANGLER_FAILURE;\n \t\toutput += ')';\n-\t\tif (!entry.unary)\n+\t\tif (entry.type != unary)\n \t\t{\n+#ifndef _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n \t\t  output += ' ';\n-\t\t  output += p;\n+#endif\n+\t\t  output += op;\n \t\t  if (is_eq)\n \t\t    output += '=';\n+#ifndef _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n \t\t  output += ' ';\n+#endif\n \t\t  output += '(';\n \t\t  if (!decode_expression(output))\n \t\t    _GLIBCXX_DEMANGLER_FAILURE;\n \t\t  output += ')';\n+\t\t  if (entry.type == trinary)\n+\t\t  {\n+#ifdef _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n+\t\t    output += \":(\";\n+#else\n+\t\t    output += \" : (\";\n+#endif\n+\t\t    if (!decode_expression(output))\n+\t\t      _GLIBCXX_DEMANGLER_FAILURE;\n+\t\t    output += ')';\n+\t\t  }\n \t\t}\n \t\t_GLIBCXX_DEMANGLER_RETURN;\n \t      }\n+\t      else if (opcode0 == 'c' &&\n+\t               opcode1 == 'v')\t\t// casting operator.\n+\t      {\n+\t\teat_current();\n+\t\toutput += '(';\n+\t\tif (!decode_type(output))\n+\t\t  _GLIBCXX_DEMANGLER_FAILURE;\n+\t\toutput += \")(\";\n+\t\tif (!decode_expression(output))\n+\t\t  _GLIBCXX_DEMANGLER_FAILURE;\n+\t\toutput += ')';\n+\t\t_GLIBCXX_DEMANGLER_RETURN;\n+\t      }\n \t    }\n \t  }\n \t}\n@@ -1223,8 +1360,9 @@ namespace __gnu_cxx\n     //\n     // <template-args> ::= I <template-arg>+ E\n     // <template-arg> ::= <type>\t\t\t# type or template\n-    //                ::= L <type> <value number> E\t# literal\n-    //                ::= L_Z <encoding> E\t\t# external name\n+    //                ::= L <type> <value number> E\t# integer literal\n+    //                ::= L <type> <value float> E\t# floating literal\n+    //                ::= L <mangled-name> E\t\t# external name\n     //                ::= X <expression> E\t\t# expression\n     template<typename Allocator>\n       bool\n@@ -1282,7 +1420,12 @@ namespace __gnu_cxx\n       }\n \n     // <bare-function-type> ::=\n-    //   <signature type>+\t\t# types are parameter types\n+    //   <signature type>+\t\t# Types are parameter types.\n+    //\n+    // Note that the possible return type of the <bare-function-type>\n+    // has already been eaten before we call this function.  This makes\n+    // our <bare-function-type> slightly different from the one in\n+    // the C++-ABI description.\n     //\n     template<typename Allocator>\n       bool\n@@ -1673,6 +1816,7 @@ namespace __gnu_cxx\n \t    }\n \t    case 'M':\n \t    {\n+\t      // <pointer-to-member-type> ::= M <class type> <member type>\n \t      // <Q>M<C> or <Q>M<C><Q2>F<R><B>E\n \t      eat_current();\n \t      string_type class_type;\n@@ -1773,9 +1917,17 @@ namespace __gnu_cxx\n \t  {\n \t    case 'F':\n \t    {\n+\t      // <function-type> ::= F [Y] <bare-function-type> E\n+\t      //\n+\t      // Note that g++ never generates the 'Y', but we try to\n+\t      // demangle it anyway.\n+\t      bool extern_C = (next() == 'Y');\n+\t      if (extern_C)\n+\t\teat_current();\n+\t        \n \t      // <Q>F<R><B>E \t\t==> R (Q)B\n \t      //     substitution: \"<R>\", \"<B>\" (<B> recursive) and \"F<R><B>E\".\n-\t      eat_current();\n+\n \t      // Return type.\n \t      if (!decode_type_with_postfix(prefix, postfix))\n \t\t  // Substitution: \"<R>\".\n@@ -1802,6 +1954,8 @@ namespace __gnu_cxx\n \t      qualifiers->decode_qualifiers(prefix, postfix);\n \t\t  // substitution: all qualified types, if any.\n \t      prefix += \")\";\n+\t      if (extern_C)\n+\t        prefix += \" [extern \\\"C\\\"] \";\n \t      prefix += bare_function_type;\n \t      break;\n \t    }\n@@ -1925,10 +2079,12 @@ namespace __gnu_cxx\n     //\n     // <prefix> ::= <prefix> <unqualified-name>\n     //          ::= <template-prefix> <template-args>\n+    //          ::= <template-param>\n     //          ::= # empty\n     //          ::= <substitution>\n     //\n     // <template-prefix> ::= <prefix> <template unqualified-name>\n+    //                   ::= <template-param>\n     //                   ::= <substitution>\n     //\n     template<typename Allocator>\n@@ -1982,7 +2138,12 @@ namespace __gnu_cxx\n \t  }\n \t  else\n \t  {\n-\t    if (!decode_unqualified_name(output))\n+\t    if (current() == 'T')\n+\t    {\n+\t      if (!decode_template_param(output))\n+\t\t_GLIBCXX_DEMANGLER_FAILURE;\n+\t    }\n+\t    else if (!decode_unqualified_name(output))\n \t      _GLIBCXX_DEMANGLER_FAILURE;\n \t    if (current() != 'E')\n \t    {\n@@ -2148,7 +2309,7 @@ namespace __gnu_cxx\n \n     // <unscoped-name> ::=\n     //   <unqualified-name>\t\t# Starts not with an 'S'\n-    //   St <unqualified-name>\t# ::std::\n+    //   St <unqualified-name>\t\t# ::std::\n     //\n     template<typename Allocator>\n       bool"}, {"sha": "24e03ea07fc780b6728c66082686d4d0784e6b02", "filename": "libstdc++-v3/testsuite/demangle/regression/3111-2.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e5c8fa3c715dad01545ad6feb78c8e577d1578/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2F3111-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e5c8fa3c715dad01545ad6feb78c8e577d1578/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2F3111-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2F3111-2.cc?ref=22e5c8fa3c715dad01545ad6feb78c8e577d1578", "patch": "@@ -32,7 +32,7 @@ int main()\n   // verify_demangle(\"_Z1fAszL_ZZNK1N1A1fEvE3foo_0E_i\", \n   //       \"f(int[sizeof(N::A::f() const::foo())])\");\n   verify_demangle(\"_Z1fAszL_ZZNK1N1A1fEvE3foo_0E_i\", \n-\t\t  \"f(int [sizeof(N::A::f() const::foo)])\");\n+\t\t  \"f(int [sizeof (N::A::f() const::foo)])\");\n \n   return 0;\n }"}, {"sha": "6ca0cd7ef168a7a4be25810746ccc30a739c6dad", "filename": "libstdc++-v3/testsuite/demangle/regression/cw-16.cc", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e5c8fa3c715dad01545ad6feb78c8e577d1578/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e5c8fa3c715dad01545ad6feb78c8e577d1578/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc?ref=22e5c8fa3c715dad01545ad6feb78c8e577d1578", "patch": "@@ -22,13 +22,25 @@\n \n #include <testsuite_hooks.h>\n \n-// libcwd tests\n+// Torturing by Carlo Wood.\n int main()\n {\n   using namespace __gnu_test;\n \n+// 2003/11/07, libstdc++/12736\n verify_demangle(\"_Z3fooIA6_KiEvA9_KT_rVPrS4_\",\n \t\t\"void foo<int const [6]>(int const [9][6], int const restrict (* volatile restrict) [9][6])\");\n+// 2003/11/12, libstdc++/12947\n+verify_demangle(\"_Z1fILi5E1AEvN1CIXqugtT_Li0ELi1ELi2EEE1qE\",\n+                \"void f<5, A>(C<((5) > (0)) ? (1) : (2)>::q)\");\n+verify_demangle(\"_Z1fILi5EEvN1AIXcvimlT_Li22EEE1qE\",\n+                \"void f<5>(A<(int)((5) * (22))>::q)\");\n+verify_demangle(\"_Z1fPFYPFiiEiE\",\n+                \"f(int (*)(int) (*) [extern \\\"C\\\"] (int))\");\n+verify_demangle(\"_Z1fI1XENT_1tES2_\",\n+                \"X::t f<X>(X::t)\");\n+verify_demangle(\"_Z1fILi5E1AEvN1CIXstN1T1tEEXszsrS2_1tEE1qE\",\n+                \"void f<5, A>(C<sizeof (T::t), sizeof (T::t)>::q)\");\n \n   return 0;\n }"}]}