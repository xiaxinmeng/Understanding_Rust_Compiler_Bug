{"sha": "b523ee1f4b139532ecffb2bf707e65cfc5a837fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyM2VlMWY0YjEzOTUzMmVjZmZiMmJmNzA3ZTY1Y2ZjNWE4MzdmZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-23T16:14:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-23T16:35:47Z"}, "message": "Emit debug info for integral variables first\n\nThis makes it possible for global dynamic types to reference the DIE of\nthese integral variables.\n\ngcc/ada/ChangeLog:\n\t* gcc-interface/utils.c (gnat_write_global_declarations): Output\n\tintegral global variables first and the imported functions later.", "tree": {"sha": "9e0be3d5a4157a2a1c210f5ac1da45b7bb7d270e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e0be3d5a4157a2a1c210f5ac1da45b7bb7d270e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b523ee1f4b139532ecffb2bf707e65cfc5a837fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b523ee1f4b139532ecffb2bf707e65cfc5a837fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b523ee1f4b139532ecffb2bf707e65cfc5a837fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b523ee1f4b139532ecffb2bf707e65cfc5a837fe/comments", "author": null, "committer": null, "parents": [{"sha": "ce36abee27776e8cf8eee220b6acab45a53fe61f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce36abee27776e8cf8eee220b6acab45a53fe61f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce36abee27776e8cf8eee220b6acab45a53fe61f"}], "stats": {"total": 42, "additions": 25, "deletions": 17}, "files": [{"sha": "a96fde668bef129c335feee8e640e803040e3ba4", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b523ee1f4b139532ecffb2bf707e65cfc5a837fe/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b523ee1f4b139532ecffb2bf707e65cfc5a837fe/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=b523ee1f4b139532ecffb2bf707e65cfc5a837fe", "patch": "@@ -5880,38 +5880,46 @@ gnat_write_global_declarations (void)\n \t  }\n     }\n \n-  /* Output debug information for all global type declarations first.  This\n+  /* First output the integral global variables, so that they can be referenced\n+     as bounds by the global dynamic types.  Skip external variables, unless we\n+     really need to emit debug info for them:, e.g. imported variables.  */\n+  FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n+    if (TREE_CODE (iter) == VAR_DECL\n+\t&& INTEGRAL_TYPE_P (TREE_TYPE (iter))\n+\t&& (!DECL_EXTERNAL (iter) || !DECL_IGNORED_P (iter)))\n+      rest_of_decl_compilation (iter, true, 0);\n+\n+  /* Now output debug information for the global type declarations.  This\n      ensures that global types whose compilation hasn't been finalized yet,\n      for example pointers to Taft amendment types, have their compilation\n      finalized in the right context.  */\n   FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n     if (TREE_CODE (iter) == TYPE_DECL && !DECL_IGNORED_P (iter))\n       debug_hooks->type_decl (iter, false);\n \n-  /* Output imported functions.  */\n+  /* Then output the other global variables.  We need to do that after the\n+     information for global types is emitted so that they are finalized.  */\n   FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n-    if (TREE_CODE (iter) == FUNCTION_DECL\n-\t&& DECL_EXTERNAL (iter)\n-\t&& DECL_INITIAL (iter) == NULL\n-\t&& !DECL_IGNORED_P (iter)\n-\t&& DECL_FUNCTION_IS_DEF (iter))\n-      debug_hooks->early_global_decl (iter);\n+    if (TREE_CODE (iter) == VAR_DECL\n+\t&& !INTEGRAL_TYPE_P (TREE_TYPE (iter))\n+\t&& (!DECL_EXTERNAL (iter) || !DECL_IGNORED_P (iter)))\n+      rest_of_decl_compilation (iter, true, 0);\n \n-  /* Output global constants.  */\n+  /* Output debug information for the global constants.  */\n   FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n     if (TREE_CODE (iter) == CONST_DECL && !DECL_IGNORED_P (iter))\n       debug_hooks->early_global_decl (iter);\n \n-  /* Then output the global variables.  We need to do that after the debug\n-     information for global types is emitted so that they are finalized.  Skip\n-     external global variables, unless we need to emit debug info for them:\n-     this is useful for imported variables, for instance.  */\n+  /* Output it for the imported functions.  */\n   FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n-    if (TREE_CODE (iter) == VAR_DECL\n-\t&& (!DECL_EXTERNAL (iter) || !DECL_IGNORED_P (iter)))\n-      rest_of_decl_compilation (iter, true, 0);\n+    if (TREE_CODE (iter) == FUNCTION_DECL\n+\t&& DECL_EXTERNAL (iter)\n+\t&& DECL_INITIAL (iter) == NULL\n+\t&& !DECL_IGNORED_P (iter)\n+\t&& DECL_FUNCTION_IS_DEF (iter))\n+      debug_hooks->early_global_decl (iter);\n \n-  /* Output the imported modules/declarations.  In GNAT, these are only\n+  /* Output it for the imported modules/declarations.  In GNAT, these are only\n      materializing subprogram.  */\n   FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n    if (TREE_CODE (iter) == IMPORTED_DECL && !DECL_IGNORED_P (iter))"}]}