{"sha": "fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNmYjlmOTY1ZWM4ZGNlYTY3M2Y0NWQ1OGQwMzMwOWU5YzViODRkOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-02-10T10:28:07Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-02-10T10:28:07Z"}, "message": "cp-tree.h (get_template_base): Don't declare.\n\n\t* cp-tree.h (get_template_base): Don't declare.\n\t(dfs_walk): Declare.\n\t(dfs_unmark): Likewise.\n\t(markedp): Likewise.\n\t* pt.c (unify): Remove duplicate declaration.  Pass tparms and\n\ttargs to get_template_base.\n\t(get_template_base_recursive): Move here from search.c.  Check to\n\tsee that the base found can be instantiated to form the desired\n\ttype.\n\t(get_template_base): Likewise.\n\t(get_class_bindings): Simplify.\n\t* search.c (get_template_base_recursive): Move to pt.c.\n\t(get_template_base): Likewise.\n\t(markedp): Make it global.\n\t(dfs_walk): Likewise.\n\t(dfs_unmark): Likewise.\n\nFrom-SVN: r25126", "tree": {"sha": "46af3a1e3394c0b6b5f881822340fcedc826bd53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46af3a1e3394c0b6b5f881822340fcedc826bd53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/comments", "author": null, "committer": null, "parents": [{"sha": "ef30399b50248459021d6a08ea569432700c1a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef30399b50248459021d6a08ea569432700c1a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef30399b50248459021d6a08ea569432700c1a86"}], "stats": {"total": 275, "additions": 173, "deletions": 102}, "files": [{"sha": "1eb28f0e257dda0ed1632e7bc51f423d52f2d989", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "patch": "@@ -1,3 +1,22 @@\n+1999-02-09  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (get_template_base): Don't declare.\n+\t(dfs_walk): Declare.\n+\t(dfs_unmark): Likewise.\n+\t(markedp): Likewise.\n+\t* pt.c (unify): Remove duplicate declaration.  Pass tparms and\n+\ttargs to get_template_base.\n+\t(get_template_base_recursive): Move here from search.c.  Check to\n+\tsee that the base found can be instantiated to form the desired\n+\ttype.\n+\t(get_template_base): Likewise.\n+\t(get_class_bindings): Simplify.\n+\t* search.c (get_template_base_recursive): Move to pt.c.\n+\t(get_template_base): Likewise.\n+\t(markedp): Make it global.\n+\t(dfs_walk): Likewise.\n+\t(dfs_unmark): Likewise.\n+\t\n 1999-02-07  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (maybe_process_partial_specialization): Complain about"}, {"sha": "1bc67cff2a8eb84f53ac112ebc65ee5a8099e3f4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "patch": "@@ -3147,8 +3147,10 @@ extern void init_search_processing\t\tPROTO((void));\n extern void reinit_search_statistics\t\tPROTO((void));\n extern tree current_scope\t\t\tPROTO((void));\n extern tree lookup_conversions\t\t\tPROTO((tree));\n-extern tree get_template_base\t\t\tPROTO((tree, tree));\n extern tree binfo_for_vtable\t\t\tPROTO((tree));\n+extern void dfs_walk                            PROTO((tree, void (*) (tree), int (*) (tree)));\n+extern void dfs_unmark                          PROTO((tree));\n+extern int  markedp                             PROTO((tree));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PROTO((tree));"}, {"sha": "5b2e3a2dc35f14385f214bf83f69decfbde9adeb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 121, "deletions": 14, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "patch": "@@ -77,7 +77,6 @@ static tree saved_trees;\n #define UNIFY_ALLOW_DERIVED 4\n #define UNIFY_ALLOW_INTEGER 8\n \n-static int unify PROTO((tree, tree, tree, tree, int, int*));\n static int resolve_overloaded_unification PROTO((tree, tree, tree, tree,\n \t\t\t\t\t\t unification_kind_t, int,\n \t\t\t\t\t\t int*));\n@@ -137,6 +136,9 @@ static tree process_partial_specialization PROTO((tree));\n static void set_current_access_from_decl PROTO((tree));\n static void check_default_tmpl_args PROTO((tree, tree, int, int));\n static tree tsubst_call_declarator_parms PROTO((tree, tree, tree));\n+static tree get_template_base_recursive PROTO((tree, tree, int *, tree, tree,\n+\t\t\t\t\t       tree, int)); \n+static tree get_template_base PROTO((tree, tree, int *, tree, tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -7360,6 +7362,120 @@ try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n   return 1;\n }\n \n+/* Subroutine of get_template_base.  */\n+\n+static tree\n+get_template_base_recursive (tparms, targs, explicit_mask,\n+\t\t\t     binfo, rval, template,\n+\t\t\t     via_virtual)\n+     tree tparms;\n+     tree targs;\n+     int *explicit_mask;\n+     tree binfo;\n+     tree rval;\n+     tree template;\n+     int via_virtual;\n+{\n+  tree binfos;\n+  int i, n_baselinks;\n+  tree type = BINFO_TYPE (binfo);\n+  tree tmpl = CLASSTYPE_TI_TEMPLATE (template);\n+\n+  if (CLASSTYPE_TEMPLATE_INFO (type)\n+      && CLASSTYPE_TI_TEMPLATE (type) == tmpl)\n+    {\n+      /* Copy the TPARMS and TARGS since we're only doing a\n+\t speculative unification here.  */\n+      tree copy_of_tparms;\n+      tree copy_of_targs;\n+      \n+      push_momentary ();\n+      push_expression_obstack ();\n+      copy_of_tparms = copy_node (tparms);\n+      copy_of_targs = copy_node (targs);\n+      pop_obstacks ();\n+      \n+      i = unify (copy_of_tparms,\n+\t\t copy_of_targs,\n+\t\t CLASSTYPE_TI_ARGS (template),\n+\t\t CLASSTYPE_TI_ARGS (type),\n+\t\t UNIFY_ALLOW_NONE, explicit_mask);\n+\n+      pop_momentary ();\n+\n+      if (i == 0)\n+\t{\n+\t  if (rval == NULL_TREE || rval == type)\n+\t    return type;\n+\t  else\n+\t    return error_mark_node;\n+\t}\n+    }\n+\n+  binfos = BINFO_BASETYPES (binfo);\n+  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  /* Process base types.  */\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+\n+      /* Find any specific instance of a virtual base, when searching with\n+\t a binfo...  */\n+      if (BINFO_MARKED (base_binfo) == 0)\n+\t{\n+\t  int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n+\n+\t  /* When searching for a non-virtual, we cannot mark\n+\t     virtually found binfos.  */\n+\t  if (! this_virtual)\n+\t    SET_BINFO_MARKED (base_binfo);\n+\n+\t  rval = get_template_base_recursive (tparms, targs, explicit_mask,\n+\t\t\t\t\t      base_binfo, rval,\n+\t\t\t\t\t      template, this_virtual);\n+\t  if (rval == error_mark_node)\n+\t    return rval;\n+\t}\n+    }\n+\n+  return rval;\n+}\n+\n+/* Given a template type TEMPLATE and a class type or binfo node BINFO,\n+   find the unique base type in BINFO that is an instance of TEMPLATE.\n+   If there are more than one, return error_mark_node.  TEMPLATE may\n+   be the type of a partial specialization, as well as a plain\n+   template type.  Used by unify.  */\n+\n+static tree\n+get_template_base (tparms, targs, explicit_mask, template, binfo)\n+     tree tparms;\n+     tree targs;\n+     int *explicit_mask;\n+     tree template;\n+     tree binfo;\n+{\n+  tree type = NULL_TREE, rval;\n+\n+  if (TREE_CODE (binfo) == TREE_VEC)\n+    type = BINFO_TYPE (binfo);\n+  else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n+    {\n+      type = complete_type (binfo);\n+      binfo = TYPE_BINFO (type);\n+    }\n+  else\n+    my_friendly_abort (92);\n+\n+  rval = get_template_base_recursive (tparms, targs, explicit_mask,\n+\t\t\t\t      binfo, NULL_TREE,\n+\t\t\t\t      template, 0); \n+  dfs_walk (binfo, dfs_unmark, markedp);\n+\n+  return rval;\n+}\n+\n /* Returns the level of DECL, which declares a template parameter.  */\n \n int\n@@ -7766,7 +7882,8 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t       The call to get_template_base also handles the case\n \t       where PARM and ARG are the same type, i.e., where no\n \t       derivation is involved.  */\n-\t    t = get_template_base (CLASSTYPE_TI_TEMPLATE (parm), arg);\n+\t    t = get_template_base (tparms, targs, explicit_mask,\n+\t\t\t\t   parm, arg);\n \t  else if (CLASSTYPE_TEMPLATE_INFO (arg) \n \t\t   && (CLASSTYPE_TI_TEMPLATE (parm) \n \t\t       == CLASSTYPE_TI_TEMPLATE (arg)))\n@@ -8059,18 +8176,8 @@ get_class_bindings (tparms, parms, args)\n \n   args = innermost_args (args);\n \n-  for (i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n-    {\n-      switch (unify (tparms, vec, \n-\t\t     TREE_VEC_ELT (parms, i), TREE_VEC_ELT (args, i),\n-\t\t     UNIFY_ALLOW_NONE, 0))\n-\t{\n-\tcase 0:\n-\t  break;\n-\tcase 1:\n-\t  return NULL_TREE;\n-\t}\n-    }\n+  if (unify (tparms, vec, parms, args, UNIFY_ALLOW_NONE, 0))\n+    return NULL_TREE;\n \n   for (i =  0; i < ntparms; ++i)\n     if (! TREE_VEC_ELT (vec, i))"}, {"sha": "1edfdf8875c7966d202a1e2439f07b3d5bdb2652", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 87, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "patch": "@@ -86,9 +86,6 @@ static int lookup_fnfields_here PROTO((tree, tree));\n static int is_subobject_of_p PROTO((tree, tree));\n static int hides PROTO((tree, tree));\n static tree virtual_context PROTO((tree, tree, tree));\n-static tree get_template_base_recursive\n-\tPROTO((tree, tree, tree, int));\n-static void dfs_walk PROTO((tree, void (*) (tree), int (*) (tree)));\n static void dfs_check_overlap PROTO((tree));\n static int dfs_no_overlap_yet PROTO((tree));\n static void envelope_add_decl PROTO((tree, tree, tree *));\n@@ -100,7 +97,6 @@ static void expand_upcast_fixups\n static void fixup_virtual_upcast_offsets\n \tPROTO((tree, tree, int, int, tree, tree, tree, tree,\n \t       tree *));\n-static int markedp PROTO((tree));\n static int unmarkedp PROTO((tree));\n static int marked_vtable_pathp PROTO((tree));\n static int unmarked_vtable_pathp PROTO((tree));\n@@ -110,7 +106,6 @@ static int dfs_debug_unmarkedp PROTO((tree));\n static void dfs_debug_mark PROTO((tree));\n static void dfs_find_vbases PROTO((tree));\n static void dfs_clear_vbase_slots PROTO((tree));\n-static void dfs_unmark PROTO((tree));\n static void dfs_init_vbase_pointers PROTO((tree));\n static void dfs_get_vbase_types PROTO((tree));\n static void dfs_pushdecls PROTO((tree));\n@@ -2102,7 +2097,7 @@ convert_pointer_to_single_level (to_type, expr)\n    dfs_init_vbase_pointers is the work function, as otherwise there\n    would be no record.  */\n \n-static void\n+void\n dfs_walk (binfo, fn, qfn)\n      tree binfo;\n      void (*fn) PROTO((tree));\n@@ -2201,7 +2196,7 @@ dfs_search (binfo, fn, start)\n   return fn (binfo);\n }\n \n-static int markedp (binfo) tree binfo;\n+int markedp (binfo) tree binfo;\n { return BINFO_MARKED (binfo); }\n static int unmarkedp (binfo) tree binfo;\n { return BINFO_MARKED (binfo) == 0; }\n@@ -2252,7 +2247,7 @@ dfs_mark (binfo) tree binfo;\n { SET_BINFO_MARKED (binfo); }\n #endif\n \n-static void\n+void\n dfs_unmark (binfo) tree binfo;\n { CLEAR_BINFO_MARKED (binfo); }\n \n@@ -3347,85 +3342,6 @@ lookup_conversions (type)\n   return conversions;\n }\n \n-/* Subroutine of get_template_base.  */\n-\n-static tree\n-get_template_base_recursive (binfo, rval, template, via_virtual)\n-     tree binfo, template, rval;\n-     int via_virtual;\n-{\n-  tree binfos;\n-  int i, n_baselinks;\n-  tree type = BINFO_TYPE (binfo);\n-\n-  if (CLASSTYPE_TEMPLATE_INFO (type)\n-      && CLASSTYPE_TI_TEMPLATE (type) == template)\n-    {\n-      if (rval == NULL_TREE || rval == type)\n-\treturn type;\n-      else\n-\treturn error_mark_node;\n-    }\n-\n-  binfos = BINFO_BASETYPES (binfo);\n-  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  /* Process base types.  */\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-      /* Find any specific instance of a virtual base, when searching with\n-\t a binfo...  */\n-      if (BINFO_MARKED (base_binfo) == 0)\n-\t{\n-\t  int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n-\n-\t  /* When searching for a non-virtual, we cannot mark\n-\t     virtually found binfos.  */\n-\t  if (! this_virtual)\n-\t    SET_BINFO_MARKED (base_binfo);\n-\n-\t  rval = get_template_base_recursive\n-\t    (base_binfo, rval, template, this_virtual);\n-\t  if (rval == error_mark_node)\n-\t    return rval;\n-\t}\n-    }\n-\n-  return rval;\n-}\n-\n-/* Given a class template TEMPLATE and a class type or binfo node BINFO,\n-   find the unique base type in BINFO that is an instance of TEMPLATE.\n-   If there are more than one, return error_mark_node.  Used by unify.  */\n-\n-tree\n-get_template_base (template, binfo)\n-     register tree template, binfo;\n-{\n-  tree type = NULL_TREE, rval;\n-\n-  if (TREE_CODE (binfo) == TREE_VEC)\n-    type = BINFO_TYPE (binfo);\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n-    {\n-      type = complete_type (binfo);\n-      binfo = TYPE_BINFO (type);\n-    }\n-  else\n-    my_friendly_abort (92);\n-\n-  if (CLASSTYPE_TEMPLATE_INFO (type)\n-      && CLASSTYPE_TI_TEMPLATE (type) == template)\n-    return type;\n-\n-  rval = get_template_base_recursive (binfo, NULL_TREE, template, 0);\n-  dfs_walk (binfo, dfs_unmark, markedp);\n-\n-  return rval;\n-}\n-\n /* Check whether the empty class indicated by EMPTY_BINFO is also present\n    at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */\n "}, {"sha": "a87b2a7566eb854ca0adf012c577a1d124bd9838", "filename": "gcc/testsuite/g++.old-deja/g++.pt/deduct1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfb9f965ec8dcea673f45d58d03309e9c5b84d9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct1.C?ref=fcfb9f965ec8dcea673f45d58d03309e9c5b84d9", "patch": "@@ -0,0 +1,27 @@\n+// Build don't link:\n+\n+template<class CoordinateSystem, class MeshTag>\n+struct Mesh { };\n+\n+struct RectGrid { };\n+\n+struct RectMesh { };\n+\n+struct Cartesian { };\n+\n+template<class CS>\n+struct Mesh<CS, RectGrid> { };\n+\n+template<class CS>\n+struct Mesh<CS, RectMesh> : public Mesh<CS, RectGrid> { };\n+\n+template<class CS>\n+void foo(const Mesh<CS, RectGrid> &)\n+{\n+}\n+\n+int main()\n+{\n+  Mesh<Cartesian, RectMesh> m;\n+  foo(m);\n+}"}]}