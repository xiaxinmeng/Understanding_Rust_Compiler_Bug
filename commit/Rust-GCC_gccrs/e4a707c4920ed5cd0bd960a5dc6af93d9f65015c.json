{"sha": "e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRhNzA3YzQ5MjBlZDVjZDBiZDk2MGE1ZGM2YWY5M2Q5ZjY1MDE1Yw==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-09-02T06:04:34Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-09-02T06:04:34Z"}, "message": "tree-vectorizer.h (get_later_stmt): New function.\n\n\n\t* tree-vectorizer.h (get_later_stmt): New function.\n\t(vect_analyze_data_ref_dependences): Add argument.\n\t* tree-vect-loop.c (vect_analyze_loop): Update call to\n\tvect_analyze_data_ref_dependences.\n\t* tree-vect-data-refs.c (vect_drs_dependent_in_basic_block):\n\tNew function.\n\t(vect_analyze_data_ref_dependence): Add argument for basic block\n\tdependencies. Check dependencies in basic block vectorization.\n\t(vect_analyze_data_ref_dependences): Add argument and update call to\n\tvect_analyze_data_ref_dependences.\n\t* tree-vect-slp.c (vect_find_last_store_in_slp_instance): New.\n\t(vect_bb_vectorizable_with_dependencies): New.\n\t(vect_slp_analyze_bb): Check dependencies in basic block.\n\t(vect_schedule_slp_instance): Insert stores before the last store in\n\tSLP instance.\n\nFrom-SVN: r163757", "tree": {"sha": "9c9e5da9865d27af8587c2639c172cccde7e0437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c9e5da9865d27af8587c2639c172cccde7e0437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "282ac51f24b21591be9bfbc8570fc63d33f0a5f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282ac51f24b21591be9bfbc8570fc63d33f0a5f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/282ac51f24b21591be9bfbc8570fc63d33f0a5f6"}], "stats": {"total": 329, "additions": 315, "deletions": 14}, "files": [{"sha": "c54610f1ac9b289d4cceb8161c5f4091d61842f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -1,3 +1,21 @@\n+2010-09-02  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.h (get_later_stmt): New function.\n+\t(vect_analyze_data_ref_dependences): Add argument.\n+\t* tree-vect-loop.c (vect_analyze_loop): Update call to\n+\tvect_analyze_data_ref_dependences.\n+\t* tree-vect-data-refs.c (vect_drs_dependent_in_basic_block):\n+\tNew function.\n+\t(vect_analyze_data_ref_dependence): Add argument for basic block\n+\tdependencies. Check dependencies in basic block vectorization.\n+\t(vect_analyze_data_ref_dependences): Add argument and update call to\n+\tvect_analyze_data_ref_dependences.\n+\t* tree-vect-slp.c (vect_find_last_store_in_slp_instance): New.\n+\t(vect_bb_vectorizable_with_dependencies): New.\n+\t(vect_slp_analyze_bb): Check dependencies in basic block.\n+\t(vect_schedule_slp_instance): Insert stores before the last store in\n+\tSLP instance.\n+\n 2010-09-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/45476"}, {"sha": "03c55d00c4055a920626a0a4a42d8c7034efc6af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -1,3 +1,11 @@\n+2010-09-02  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/bb-slp-8.c: Separate the interesting part and the\n+\tcheck into different basic blocks. Expect vectorization if misaligned\n+\tstores are supported. \n+\t* gcc.dg/vect/bb-slp-8a.c: New test.\n+\t* gcc.dg/vect/bb-slp-8b.c: New test.\n+\n 2010-09-01  Steve Ellcey  <sje@cup.hp.com>\n \n \t* gfortran.dg/vect/fast-math-pr38969.f90: Skip if not vectorizing."}, {"sha": "e45c0b8e3888f0a9c5ed1f640fd38fe803656864", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-8.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -15,7 +15,8 @@ main1 (unsigned int x, unsigned int y, unsigned int *pin, unsigned int *pout)\n   int i;\n   unsigned int a0, a1, a2, a3;\n  \n-  /* pin and pout may alias.  */\n+  /* pin and pout may alias. But since all the loads are before the first store\n+     the basic block is vectorizable.  */\n   a0 = *pin++ + 23;\n   a1 = *pin++ + 142;\n   a2 = *pin++ + 2;\n@@ -26,6 +27,9 @@ main1 (unsigned int x, unsigned int y, unsigned int *pin, unsigned int *pout)\n   *pout++ = a2 * x;\n   *pout++ = a3 * y;\n \n+  if (i)\n+    __asm__ volatile (\"\" : : : \"memory\");\n+\n   /* Check results.  */\n   if (out[0] != (in[0] + 23) * x\n       || out[1] != (in[1] + 142) * y\n@@ -45,6 +49,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\"  { target vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"slp\" } } */\n   "}, {"sha": "e46e931bcd1b02013f2f1cda052e1df7e3cc36c7", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-8a.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8a.c?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y, unsigned int *pin, unsigned int *pout)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+ \n+  /* pin and pout may alias, and loads and stores are mixed. The basic block \n+     cannot be vectorized.  */\n+  a0 = *pin++ + 23;\n+  *pout++ = a0 * x;\n+  a1 = *pin++ + 142;\n+  *pout++ = a1 * y;\n+  a2 = *pin++ + 2;\n+  *pout++ = a2 * x;\n+  a3 = *pin++ + 31;\n+  *pout++ = a3 * y;\n+\n+  if (i)\n+    __asm__ volatile (\"\" : : : \"memory\");\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3, &in[0], &out[0]);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "384acd7241a63191158af4cc7745bac24b5f4962", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-8b.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8b.c?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[0];\n+ \n+  /* pin and pout are different, so despite the fact that loads and stores \n+     are mixed the basic block is vectorizable.  */\n+  a0 = *pin++ + 23;\n+  *pout++ = a0 * x;\n+  a1 = *pin++ + 142;\n+  *pout++ = a1 * y;\n+  a2 = *pin++ + 2;\n+  *pout++ = a2 * x;\n+  a3 = *pin++ + 31;\n+  *pout++ = a3 * y;\n+\n+  if (i)\n+    __asm__ volatile (\"\" : : : \"memory\");\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\"  { target vect_hw_misalign } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "c76c60bd3466d8ca660825bfb009b5c8c66ed310", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 77, "deletions": 7, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -322,6 +322,64 @@ vect_equal_offsets (tree offset1, tree offset2)\n }\n \n \n+/* Check dependence between DRA and DRB for basic block vectorization.  */\n+\n+static bool\n+vect_drs_dependent_in_basic_block (struct data_reference *dra,\n+                                   struct data_reference *drb)\n+{\n+  HOST_WIDE_INT type_size_a, type_size_b, init_a, init_b;\n+  gimple earlier_stmt;\n+\n+  /* We only call this function for pairs of loads and stores, but we verify\n+     it here.  */\n+  if (DR_IS_READ (dra) == DR_IS_READ (drb))\n+    {\n+      if (DR_IS_READ (dra))\n+        return false;\n+      else\n+        return true;\n+    }\n+\n+  /* Check that the data-refs have same bases and offsets. If not, we can't\n+     determine if they are dependent.  */\n+  if ((DR_BASE_ADDRESS (dra) != DR_BASE_ADDRESS (drb)\n+       && (TREE_CODE (DR_BASE_ADDRESS (dra)) != ADDR_EXPR\n+           || TREE_CODE (DR_BASE_ADDRESS (drb)) != ADDR_EXPR\n+           || TREE_OPERAND (DR_BASE_ADDRESS (dra), 0)\n+           != TREE_OPERAND (DR_BASE_ADDRESS (drb),0)))\n+      || !vect_equal_offsets (DR_OFFSET (dra), DR_OFFSET (drb)))\n+    return true;\n+\n+  /* Check the types.  */\n+  type_size_a = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))));\n+  type_size_b = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n+\n+  if (type_size_a != type_size_b\n+      || !types_compatible_p (TREE_TYPE (DR_REF (dra)),\n+                              TREE_TYPE (DR_REF (drb))))\n+    return true;\n+\n+  init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n+  init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n+\n+  /* Two different locations - no dependence.  */\n+  if (init_a != init_b)\n+    return false;\n+\n+  /* We have a read-write dependence. Check that the load is before the store.\n+     When we vectorize basic blocks, vector load can be only before \n+     corresponding scalar load, and vector store can be only after its\n+     corresponding scalar store. So the order of the acceses is preserved in \n+     case the load is before the store.  */\n+  earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));   \n+  if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n /* Function vect_check_interleaving.\n \n    Check if DRA and DRB are a part of interleaving. In case they are, insert\n@@ -495,7 +553,8 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n \n static bool\n vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n-                                  loop_vec_info loop_vinfo, int *max_vf)\n+                                  loop_vec_info loop_vinfo, int *max_vf,\n+                                  bool *data_dependence_in_bb)\n {\n   unsigned int i;\n   struct loop *loop = NULL;\n@@ -554,10 +613,14 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n \n-      /* Mark the statements as unvectorizable.  */\n-      STMT_VINFO_VECTORIZABLE (stmtinfo_a) = false;\n-      STMT_VINFO_VECTORIZABLE (stmtinfo_b) = false;\n+      /* We do not vectorize basic blocks with write-write dependencies.  */\n+      if (!DR_IS_READ (dra) && !DR_IS_READ (drb))\n+        return true;\n \n+      /* We deal with read-write dependencies in basic blocks later (by\n+         verifying that all the loads in the basic block are before all the\n+         stores).  */\n+      *data_dependence_in_bb = true;\n       return false;\n     }\n \n@@ -577,7 +640,12 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n \n-      return true;\n+      /* Do not vectorize basic blcoks with write-write dependences.  */\n+      if (!DR_IS_READ (dra) && !DR_IS_READ (drb))\n+        return true;\n+\n+      /* Check if this dependence is allowed in basic block vectorization.  */ \n+      return vect_drs_dependent_in_basic_block (dra, drb);\n     }\n \n   /* Loop-based vectorization and known data dependence.  */\n@@ -678,7 +746,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \n bool\n vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n-                                   bb_vec_info bb_vinfo, int *max_vf)\n+                                   bb_vec_info bb_vinfo, int *max_vf,\n+                                   bool *data_dependence_in_bb)\n {\n   unsigned int i;\n   VEC (ddr_p, heap) *ddrs = NULL;\n@@ -693,7 +762,8 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n     ddrs = BB_VINFO_DDRS (bb_vinfo);\n \n   FOR_EACH_VEC_ELT (ddr_p, ddrs, i, ddr)\n-    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n+    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf,\n+\t\t\t\t\t  data_dependence_in_bb))\n       return false;\n \n   return true;"}, {"sha": "2ed8c7663efb770355081d9d3c1a8f586be9fb56", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -1378,7 +1378,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n loop_vec_info\n vect_analyze_loop (struct loop *loop)\n {\n-  bool ok;\n+  bool ok, dummy;\n   loop_vec_info loop_vinfo;\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n   int min_vf = 2;\n@@ -1444,7 +1444,7 @@ vect_analyze_loop (struct loop *loop)\n      the dependences.\n      FORNOW: fail at the first data dependence that we encounter.  */\n \n-  ok = vect_analyze_data_ref_dependences (loop_vinfo, NULL, &max_vf);\n+  ok = vect_analyze_data_ref_dependences (loop_vinfo, NULL, &max_vf, &dummy);\n   if (!ok\n       || max_vf < min_vf)\n     {"}, {"sha": "f560ac29e42390f47f5518813dfc853bafc121e1", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -1082,6 +1082,24 @@ vect_find_first_load_in_slp_instance (slp_instance instance)\n }\n \n \n+/* Find the last store in SLP INSTANCE.  */\n+static gimple\n+vect_find_last_store_in_slp_instance (slp_instance instance)\n+{\n+  int i;\n+  slp_tree node;\n+  gimple last_store = NULL, store;\n+\n+  node = SLP_INSTANCE_TREE (instance);\n+  for (i = 0;\n+       VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, store);\n+       i++)\n+    last_store = get_later_stmt (store, last_store);\n+\n+  return last_store;\n+}\n+\n+\n /* Analyze an SLP instance starting from a group of strided stores. Call\n    vect_build_slp_tree to build a tree of packed stmts if possible.\n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n@@ -1503,6 +1521,42 @@ vect_slp_analyze_operations (bb_vec_info bb_vinfo)\n   return true;\n }\n \n+/* Check if loads and stores are mixed in the basic block (in that\n+   case if we are not sure that the accesses differ, we can't vectorize the\n+   basic block). Also return FALSE in case that there is statement marked as\n+   not vectorizable.  */\n+\n+static bool\n+vect_bb_vectorizable_with_dependencies (bb_vec_info bb_vinfo)\n+{\n+  basic_block bb = BB_VINFO_BB (bb_vinfo);\n+  gimple_stmt_iterator si;\n+  bool detected_store = false;\n+  gimple stmt;\n+  struct data_reference *dr;\n+\n+  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      stmt = gsi_stmt (si);\n+\n+      /* We can't allow not analyzed statements, since they may contain data\n+         accesses.  */ \n+      if (!STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n+        return false;\n+\n+      if (!STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))\n+        continue;\n+\n+      dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n+      if (DR_IS_READ (dr) && detected_store)\n+        return false;\n+\n+      if (!DR_IS_READ (dr))\n+        detected_store = true;\n+    }\n+\n+  return true;\n+}\n \n /* Check if vectorization of the basic block is profitable.  */\n \n@@ -1585,6 +1639,8 @@ vect_slp_analyze_bb (basic_block bb)\n   gimple_stmt_iterator gsi;\n   int min_vf = 2;\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n+  bool data_dependence_in_bb = false;\n+\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"===vect_slp_analyze_bb===\\n\");\n@@ -1632,8 +1688,11 @@ vect_slp_analyze_bb (basic_block bb)\n       return NULL;\n     }\n \n-   if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo, &max_vf)\n-       || min_vf > max_vf)\n+   if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo, &max_vf, \n+                                           &data_dependence_in_bb)\n+       || min_vf > max_vf\n+       || (data_dependence_in_bb \n+           && !vect_bb_vectorizable_with_dependencies (bb_vinfo)))\n      {\n        if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t fprintf (vect_dump, \"not vectorized: unhandled data dependence \"\n@@ -2420,6 +2479,14 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   else\n     si = gsi_for_stmt (stmt);\n \n+  /* Stores should be inserted just before the last store.  */\n+  if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n+      && REFERENCE_CLASS_P (gimple_get_lhs (stmt)))\n+    { \n+      gimple last_store = vect_find_last_store_in_slp_instance (instance);\n+      si = gsi_for_stmt (last_store);\n+    }\n+\n   is_store = vect_transform_stmt (stmt, &si, &strided_store, node, instance);\n   return is_store;\n }"}, {"sha": "9d6e0acb57ad06589a79169f15b70b52a5a73bd0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a707c4920ed5cd0bd960a5dc6af93d9f65015c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e4a707c4920ed5cd0bd960a5dc6af93d9f65015c", "patch": "@@ -633,6 +633,32 @@ get_earlier_stmt (gimple stmt1, gimple stmt2)\n     return stmt2;\n }\n \n+static inline gimple\n+get_later_stmt (gimple stmt1, gimple stmt2)\n+{\n+  unsigned int uid1, uid2;\n+\n+  if (stmt1 == NULL)\n+    return stmt2;\n+\n+  if (stmt2 == NULL)\n+    return stmt1;\n+\n+  uid1 = gimple_uid (stmt1);\n+  uid2 = gimple_uid (stmt2);\n+\n+  if (uid1 == 0 || uid2 == 0)\n+    return NULL;\n+\n+  gcc_assert (uid1 <= VEC_length (vec_void_p, stmt_vec_info_vec));\n+  gcc_assert (uid2 <= VEC_length (vec_void_p, stmt_vec_info_vec));\n+\n+  if (uid1 > uid2)\n+    return stmt1;\n+  else\n+    return stmt2;\n+}\n+\n static inline bool\n is_pattern_stmt_p (stmt_vec_info stmt_info)\n {\n@@ -776,7 +802,7 @@ extern enum dr_alignment_support vect_supportable_dr_alignment\n extern tree vect_get_smallest_scalar_type (gimple, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n extern bool vect_analyze_data_ref_dependences (loop_vec_info, bb_vec_info,\n-\t\t\t\t\t       int *);\n+\t\t\t\t\t       int *, bool *);\n extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n extern bool vect_analyze_data_refs_alignment (loop_vec_info, bb_vec_info);\n extern bool vect_verify_datarefs_alignment (loop_vec_info, bb_vec_info);"}]}