{"sha": "7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RiN2VkM2NiZDJkYmYxN2JlNzNmMjU0OTQ0YzI4ZDcyZGUxOWNhOQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-12-09T21:25:11Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-12-09T21:25:11Z"}, "message": "tm.texi (TARGET_IRA_COVER_CLASSES): Modify description.\n\n2008-12-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* doc/tm.texi (TARGET_IRA_COVER_CLASSES): Modify description.\n\n\t* doc/invoke.texi (-fira-region): Describe new option.\n\t(-fira-algorithm): Change the values.\n\n\t* ira-conflicts.c (build_conflict_bit_table,\n\tbuild_allocno_conflicts): Use ira_reg_classes_intersect_p.\n\t(ira_build_conflicts): Use flag flag_ira_region instead of\n\tflag_ira_algorithm.  Prohibit usage of callee-saved likely spilled\n\tbase registers for allocnos crossing calls.\n\n\t* flags.h (enum ira_algorithm): Redefine.\n\t(enum ira_region): New.\n\t(flag_ira_region): New.\n\n\t* cfgloopanal.c (estimate_reg_pressure_cost): Use flag_ira_region\n\tinstead of flag_ira_algorithm.\n\n\t* toplev.c (flag_ira_algorithm): Change the initial value.\n\t(flag_ira_region): New.\n\n\t* ira-int.h (ira_reg_classes_intersect_p,\n\tira_reg_class_super_classes): New.\n\n\t* ira-color.c (update_copy_costs): Use\n\tira_reg_classes_intersect_p.  Use right class to find hard reg\n\tindex.\n\t(update_conflict_hard_regno_costs): Ditto.  Add a new parameter.\n\t(assign_hard_reg): Ditto.  Pass additional argument to\n\tupdate_conflict_hard_regno_costs.  Do not uncoalesce for priority\n\tcoloring.\n\t(allocno_priorities, setup_allocno_priorities,\n\tallocno_priority_compare_func): Move before color_allocnos.\n\t(color_allocnos): Add priority coloring.  Use flag flag_ira_region\n\tinstead of flag_ira_algorithm.\n\t(move_spill_restore): Check classes of the same reg allocno from\n\tdifferent regions.\n\t(update_curr_costs): Use ira_reg_classes_intersect_p.\n\t(ira_reassign_conflict_allocnos): Ditto.\n\n\t* opts.c (decode_options): Always set up flag_ira.  Set up\n\tflag_ira_algorithm.  Warn CB can not be used for architecture.\n\t(common_handle_option): Modify code for -fira-algorithm.  Add code\n\tto process -fira-region.\n\n\t* ira-lives.c (update_allocno_pressure_excess_length): Process\n\tsuperclasses too.\n\t(set_allocno_live, clear_allocno_live, mark_reg_live,\n\tmark_reg_dead, process_bb_node_lives): Ditto.\n\n\t* ira-emit.c (ira_emit): Fix insn codes.\n\t\n\t* ira-build.c (propagate_allocno_info): Use flag flag_ira_region\n\tinstead of flag_ira_algorithm.\n\t(allocno_range_compare_func): Ignore classes for priority\n\tcoloring.\n\t(setup_min_max_conflict_allocno_ids): Ditto.\n\t(ira_flattening): Use ira_reg_classes_intersect_p.\n\n\t* genpreds.c (write_enum_constraint_num): Output\n\tCONSTRAINT__LIMIT.\n\t\n\t* common.opt (fira-algorithm): Modify.\n\t(fira-region): New.\n\n\t* ira.c (setup_class_hard_regs): Initialize.\n\t(setup_cover_and_important_classes): Modify code setting class\n\trelated info for priority coloring.\n\t(setup_class_translate): Ditto.\n\t(ira_reg_classes_intersect_p, ira_reg_class_super_classes): New.\n\t(setup_reg_class_intersect_union): Rename to\n\tsetup_reg_class_relations.  Add code for setting up new variables.\n\t(find_reg_class_closure): Do not check targetm.ira_cover_classes.\n\t(ira): Use flag flag_ira_region instead of flag_ira_algorithm.\n\n\t* ira-costs.c (common_classes): New.\n\t(print_costs): Use flag flag_ira_region instead of\n\tflag_ira_algorithm.\n\t(find_allocno_class_costs): Ditto.  Use common_classes.  Translate\n\talt_class.\n\t(ira_costs): Allocate/deallocate common_classes.\n\t\n\t* config/m32c/m32.h (REG_ALLOC_ORDER): Add reg 19.\n\t(REG_CLASS_CONTENTS, reg_class, REG_CLASS_NAMES): New entries for\n\tR02A_REGS.\n\n\t* reload1.c (choose_reload_regs): Use MODE_INT for partial ints in\n\tsmallest_mode_for_size.\n\nFrom-SVN: r142610", "tree": {"sha": "42be312c545d91eee361dc8d399923279541e6a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42be312c545d91eee361dc8d399923279541e6a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2e5d002a9e6764888b19b70711501011f1ff1bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e5d002a9e6764888b19b70711501011f1ff1bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e5d002a9e6764888b19b70711501011f1ff1bfe"}], "stats": {"total": 1014, "additions": 719, "deletions": 295}, "files": [{"sha": "a80bdf5497737ac763024f1e548a7795d95713a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -1,3 +1,94 @@\n+2008-12-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* doc/tm.texi (TARGET_IRA_COVER_CLASSES): Modify description.\n+\n+\t* doc/invoke.texi (-fira-region): Describe new option.\n+\t(-fira-algorithm): Change the values.\n+\n+\t* ira-conflicts.c (build_conflict_bit_table,\n+\tbuild_allocno_conflicts): Use ira_reg_classes_intersect_p.\n+\t(ira_build_conflicts): Use flag flag_ira_region instead of\n+\tflag_ira_algorithm.  Prohibit usage of callee-saved likely spilled\n+\tbase registers for allocnos crossing calls.\n+\n+\t* flags.h (enum ira_algorithm): Redefine.\n+\t(enum ira_region): New.\n+\t(flag_ira_region): New.\n+\n+\t* cfgloopanal.c (estimate_reg_pressure_cost): Use flag_ira_region\n+\tinstead of flag_ira_algorithm.\n+\n+\t* toplev.c (flag_ira_algorithm): Change the initial value.\n+\t(flag_ira_region): New.\n+\n+\t* ira-int.h (ira_reg_classes_intersect_p,\n+\tira_reg_class_super_classes): New.\n+\n+\t* ira-color.c (update_copy_costs): Use\n+\tira_reg_classes_intersect_p.  Use right class to find hard reg\n+\tindex.\n+\t(update_conflict_hard_regno_costs): Ditto.  Add a new parameter.\n+\t(assign_hard_reg): Ditto.  Pass additional argument to\n+\tupdate_conflict_hard_regno_costs.  Do not uncoalesce for priority\n+\tcoloring.\n+\t(allocno_priorities, setup_allocno_priorities,\n+\tallocno_priority_compare_func): Move before color_allocnos.\n+\t(color_allocnos): Add priority coloring.  Use flag flag_ira_region\n+\tinstead of flag_ira_algorithm.\n+\t(move_spill_restore): Check classes of the same reg allocno from\n+\tdifferent regions.\n+\t(update_curr_costs): Use ira_reg_classes_intersect_p.\n+\t(ira_reassign_conflict_allocnos): Ditto.\n+\n+\t* opts.c (decode_options): Always set up flag_ira.  Set up\n+\tflag_ira_algorithm.  Warn CB can not be used for architecture.\n+\t(common_handle_option): Modify code for -fira-algorithm.  Add code\n+\tto process -fira-region.\n+\n+\t* ira-lives.c (update_allocno_pressure_excess_length): Process\n+\tsuperclasses too.\n+\t(set_allocno_live, clear_allocno_live, mark_reg_live,\n+\tmark_reg_dead, process_bb_node_lives): Ditto.\n+\n+\t* ira-emit.c (ira_emit): Fix insn codes.\n+\t\n+\t* ira-build.c (propagate_allocno_info): Use flag flag_ira_region\n+\tinstead of flag_ira_algorithm.\n+\t(allocno_range_compare_func): Ignore classes for priority\n+\tcoloring.\n+\t(setup_min_max_conflict_allocno_ids): Ditto.\n+\t(ira_flattening): Use ira_reg_classes_intersect_p.\n+\n+\t* genpreds.c (write_enum_constraint_num): Output\n+\tCONSTRAINT__LIMIT.\n+\t\n+\t* common.opt (fira-algorithm): Modify.\n+\t(fira-region): New.\n+\n+\t* ira.c (setup_class_hard_regs): Initialize.\n+\t(setup_cover_and_important_classes): Modify code setting class\n+\trelated info for priority coloring.\n+\t(setup_class_translate): Ditto.\n+\t(ira_reg_classes_intersect_p, ira_reg_class_super_classes): New.\n+\t(setup_reg_class_intersect_union): Rename to\n+\tsetup_reg_class_relations.  Add code for setting up new variables.\n+\t(find_reg_class_closure): Do not check targetm.ira_cover_classes.\n+\t(ira): Use flag flag_ira_region instead of flag_ira_algorithm.\n+\n+\t* ira-costs.c (common_classes): New.\n+\t(print_costs): Use flag flag_ira_region instead of\n+\tflag_ira_algorithm.\n+\t(find_allocno_class_costs): Ditto.  Use common_classes.  Translate\n+\talt_class.\n+\t(ira_costs): Allocate/deallocate common_classes.\n+\t\n+\t* config/m32c/m32.h (REG_ALLOC_ORDER): Add reg 19.\n+\t(REG_CLASS_CONTENTS, reg_class, REG_CLASS_NAMES): New entries for\n+\tR02A_REGS.\n+\n+\t* reload1.c (choose_reload_regs): Use MODE_INT for partial ints in\n+\tsmallest_mode_for_size.\n+\t\n 2008-12-10  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/rs6000/linux-unwind.h (get_regs): Constify casts."}, {"sha": "88c5e9562648bf36d978be18b763870b66a67d55", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -396,8 +396,8 @@ estimate_reg_pressure_cost (unsigned n_new, unsigned n_old, bool speed)\n        one.  */\n     cost = target_spill_cost [speed] * n_new;\n \n-  if (optimize && flag_ira && (flag_ira_algorithm == IRA_ALGORITHM_REGIONAL\n-\t\t\t       || flag_ira_algorithm == IRA_ALGORITHM_MIXED)\n+  if (optimize && flag_ira && (flag_ira_region == IRA_REGION_ALL\n+\t\t\t       || flag_ira_region == IRA_REGION_MIXED)\n       && number_of_loops () <= (unsigned) IRA_MAX_LOOPS_NUM)\n     /* IRA regional allocation deals with high register pressure\n        better.  So decrease the cost (to do more accurate the cost"}, {"sha": "4ffe1fd0518c562b37dba97e4e6ebc2b4481ffe8", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -683,7 +683,11 @@ Use integrated register allocator.\n \n fira-algorithm=\n Common Joined RejectNegative\n--fira-algorithm=[regional|CB|mixed] Set the used IRA algorithm\n+-fira-algorithm=[CB|priority] Set the used IRA algorithm\n+\n+fira-region=\n+Common Joined RejectNegative\n+-fira-region=[one|all|mixed] Set regions for IRA\n \n fira-coalesce\n Common Report Var(flag_ira_coalesce) Init(0)"}, {"sha": "2292a33bb5aac78903d28441215b7fe3db645269", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -224,7 +224,7 @@ machine_function;\n \n #define REG_ALLOC_ORDER { \\\n \t0, 1, 2, 3, 4, 5, /* r0..r3, a0, a1 */ \\\n-\t12, 13, 14, 15, 16, 17, 18, /* mem0..mem7 */  \\\n+        12, 13, 14, 15, 16, 17, 18, 19, /* mem0..mem7 */\t\\\n \t6, 7, 8, 9, 10, 11 /* sb, fb, sp, pc, flg, ap */ }\n \n /* How Values Fit in Registers */\n@@ -270,6 +270,7 @@ machine_function;\n   { 0x000001f0 }, /* PS  - a0 a1 sb fp sp */\\\n   { 0x0000000f }, /* SI  - r0r2 r1r3 a0a1 */\\\n   { 0x0000003f }, /* HI  - r0 r1 r2 r3 a0 a1 */\\\n+  { 0x00000033 }, /* R02A  - r0r2 a0 a1 */ \\\n   { 0x0000003f }, /* RA  - r0..r3 a0 a1 */\\\n   { 0x0000007f }, /* GENERAL */\\\n   { 0x00000400 }, /* FLG */\\\n@@ -308,6 +309,7 @@ enum reg_class\n   PS_REGS,\n   SI_REGS,\n   HI_REGS,\n+  R02A_REGS,\n   RA_REGS,\n   GENERAL_REGS,\n   FLG_REGS,\n@@ -348,6 +350,7 @@ enum reg_class\n \"PS_REGS\", \\\n \"SI_REGS\", \\\n \"HI_REGS\", \\\n+\"R02A_REGS\", \\\n \"RA_REGS\", \\\n \"GENERAL_REGS\", \\\n \"FLG_REGS\", \\"}, {"sha": "66d28c77f9ce0d4a1253ac4b578081c7ecfd6b8d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -338,7 +338,7 @@ Objective-C and Objective-C++ Dialects}.\n -finline-small-functions -fipa-cp -fipa-cp-clone -fipa-matrix-reorg -fipa-pta @gol \n -fipa-pure-const -fipa-reference -fipa-struct-reorg @gol\n -fipa-type-escape -fira -fira-algorithm=@var{algorithm} @gol\n--fira-coalesce -fno-ira-share-save-slots @gol\n+-fira-region=@var{region} -fira-coalesce -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n -floop-block -floop-interchange -floop-strip-mine @gol\n@@ -5728,17 +5728,25 @@ allocation.  It is a default if @acronym{IRA} has been ported for the\n target.\n \n @item -fira-algorithm=@var{algorithm}\n-Use specified algorithm for the integrated register allocator.  The\n-@var{algorithm} argument should be one of @code{regional}, @code{CB},\n-or @code{mixed}.  The second algorithm specifies Chaitin-Briggs\n-coloring, the first one specifies regional coloring based on\n-Chaitin-Briggs coloring, and the third one which is the default\n-specifies a mix of Chaitin-Briggs and regional algorithms where loops\n-with small register pressure are ignored.  The first algorithm can\n-give best result for machines with small size and irregular register\n-set, the second one is faster and generates decent code and the\n-smallest size code, and the mixed algorithm usually give the best\n-results in most cases and for most architectures.\n+Use specified coloring algorithm for the integrated register\n+allocator.  The @var{algorithm} argument should be @code{priority} or\n+@code{CB}.  The first algorithm specifies Chow's priority coloring,\n+the second one specifies Chaitin-Briggs coloring.  The second\n+algorithm can be unimplemented for some architectures.  If it is\n+implemented, it is the default because Chaitin-Briggs coloring as a\n+rule generates a better code.\n+\n+@item -fira-region=@var{region}\n+Use specified regions for the integrated register allocator.  The\n+@var{region} argument should be one of @code{all}, @code{mixed}, or\n+@code{one}.  The first value means using all loops as register\n+allocation regions, the second value which is the default means using\n+all loops except for loops with small register pressure as the\n+regions, and third one means using all function as a single region.\n+The first value can give best result for machines with small size and\n+irregular register set, the third one results in faster and generates\n+decent code and the smallest size code, and the default value usually\n+give the best results in most cases and for most architectures.\n \n @item -fira-coalesce\n @opindex fira-coalesce"}, {"sha": "5a76a6e5e69b2875187b3649f38dd6d015ba1233", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -2841,7 +2841,8 @@ options have been processed. It is then re-examined by every call to\n The default implementation returns @code{IRA_COVER_CLASSES}, if defined,\n otherwise there is no default implementation.  You must define either this\n macro or @code{IRA_COVER_CLASSES} in order to use the integrated register\n-allocator for the target.\n+allocator with Chaitin-Briggs coloring. If the macro is not defined,\n+the only available coloring algorithm is Chow's priority coloring.\n @end deftypefn\n \n @defmac IRA_COVER_CLASSES"}, {"sha": "0fff4f2acd7a336db32cf096fba06a8b23130b84", "filename": "gcc/flags.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -209,13 +209,22 @@ extern int flag_dump_rtl_in_asm;\n /* The algorithm used for the integrated register allocator (IRA).  */\n enum ira_algorithm\n {\n-  IRA_ALGORITHM_REGIONAL,\n   IRA_ALGORITHM_CB,\n-  IRA_ALGORITHM_MIXED\n+  IRA_ALGORITHM_PRIORITY\n };\n \n extern enum ira_algorithm flag_ira_algorithm;\n \n+/* The regions used for the integrated register allocator (IRA).  */\n+enum ira_region\n+{\n+  IRA_REGION_ONE,\n+  IRA_REGION_ALL,\n+  IRA_REGION_MIXED\n+};\n+\n+extern enum ira_region flag_ira_region;\n+\n extern unsigned int flag_ira_verbose;\n \n \f"}, {"sha": "84b2e90d9e058445c8b6662fb4715d83304266ea", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -959,7 +959,7 @@ write_enum_constraint_num (void)\n \t \"  CONSTRAINT__UNKNOWN = 0\", stdout);\n   FOR_ALL_CONSTRAINTS (c)\n     printf (\",\\n  CONSTRAINT_%s\", c->c_name);\n-  puts (\"\\n};\\n\");\n+  puts (\",\\n  CONSTRAINT__LIMIT\\n};\\n\");\n }\n \n /* Write out a function which looks at a string and determines what"}, {"sha": "9e47333d46e572a5821b76dcfb86f2f92dd8dc1d", "filename": "gcc/ira-build.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -1583,8 +1583,8 @@ propagate_allocno_info (void)\n   ira_loop_tree_node_t parent;\n   enum reg_class cover_class;\n \n-  if (flag_ira_algorithm != IRA_ALGORITHM_REGIONAL\n-      && flag_ira_algorithm != IRA_ALGORITHM_MIXED)\n+  if (flag_ira_region != IRA_REGION_ALL\n+      && flag_ira_region != IRA_REGION_MIXED)\n     return;\n   for (i = max_reg_num () - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n     for (a = ira_regno_allocno_map[i];\n@@ -2116,17 +2116,19 @@ setup_min_max_allocno_live_range_point (void)\n }\n \n /* Sort allocnos according to their live ranges.  Allocnos with\n-   smaller cover class are put first.  Allocnos with the same cove\n-   class are ordered according their start (min).  Allocnos with the\n-   same start are ordered according their finish (max).  */\n+   smaller cover class are put first unless we use priority coloring.\n+   Allocnos with the same cove class are ordered according their start\n+   (min).  Allocnos with the same start are ordered according their\n+   finish (max).  */\n static int\n allocno_range_compare_func (const void *v1p, const void *v2p)\n {\n   int diff;\n   ira_allocno_t a1 = *(const ira_allocno_t *) v1p;\n   ira_allocno_t a2 = *(const ira_allocno_t *) v2p;\n \n-  if ((diff = ALLOCNO_COVER_CLASS (a1) - ALLOCNO_COVER_CLASS (a2)) != 0)\n+  if (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+      && (diff = ALLOCNO_COVER_CLASS (a1) - ALLOCNO_COVER_CLASS (a2)) != 0)\n     return diff;\n   if ((diff = ALLOCNO_MIN (a1) - ALLOCNO_MIN (a2)) != 0)\n     return diff;\n@@ -2161,7 +2163,7 @@ sort_conflict_id_allocno_map (void)\n static void\n setup_min_max_conflict_allocno_ids (void)\n {\n-  enum reg_class cover_class;\n+  int cover_class;\n   int i, j, min, max, start, finish, first_not_finished, filled_area_start;\n   int *live_range_min, *last_lived;\n   ira_allocno_t a;\n@@ -2174,7 +2176,9 @@ setup_min_max_conflict_allocno_ids (void)\n       a = ira_conflict_id_allocno_map[i];\n       if (a == NULL)\n \tcontinue;\n-      if (cover_class != ALLOCNO_COVER_CLASS (a))\n+      if (cover_class < 0\n+\t  || (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+\t      && cover_class != (int) ALLOCNO_COVER_CLASS (a)))\n \t{\n \t  cover_class = ALLOCNO_COVER_CLASS (a);\n \t  min = i;\n@@ -2208,7 +2212,9 @@ setup_min_max_conflict_allocno_ids (void)\n       a = ira_conflict_id_allocno_map[i];\n       if (a == NULL)\n \tcontinue;\n-      if (cover_class != ALLOCNO_COVER_CLASS (a))\n+      if (cover_class < 0\n+\t  || (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+\t      && cover_class != (int) ALLOCNO_COVER_CLASS (a)))\n \t{\n \t  cover_class = ALLOCNO_COVER_CLASS (a);\n \t  for (j = 0; j < ira_max_point; j++)\n@@ -2503,7 +2509,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t\t{\n \t\t  ira_allocno_t live_a = ira_allocnos[n];\n \n-\t\t  if (cover_class == ALLOCNO_COVER_CLASS (live_a)\n+\t\t  if (ira_reg_classes_intersect_p\n+\t\t      [cover_class][ALLOCNO_COVER_CLASS (live_a)]\n \t\t      /* Don't set up conflict for the allocno with itself.  */\n \t\t      && num != (int) n)\n \t\t    ira_add_allocno_conflict (a, live_a);"}, {"sha": "c9cb1845fe4774fdaf86e8a3854c6db851a7d429", "filename": "gcc/ira-color.c", "status": "modified", "additions": 196, "deletions": 110, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -279,7 +279,8 @@ update_copy_costs (ira_allocno_t allocno, bool decr_p)\n \t  else\n \t    gcc_unreachable ();\n \n-\t  if (cover_class != ALLOCNO_COVER_CLASS (another_allocno)\n+\t  cover_class = ALLOCNO_COVER_CLASS (another_allocno);\n+\t  if (! ira_reg_classes_intersect_p[rclass][cover_class]\n \t      || ALLOCNO_ASSIGNED_P (another_allocno))\n \t    continue;\n \n@@ -301,6 +302,8 @@ update_copy_costs (ira_allocno_t allocno, bool decr_p)\n \t    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n \t     cover_class, 0,\n \t     ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n+\t  i = ira_class_hard_reg_index[cover_class][hard_regno];\n+\t  ira_assert (i >= 0);\n \t  ALLOCNO_UPDATED_HARD_REG_COSTS (another_allocno)[i] += update_cost;\n \t  ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno)[i]\n \t    += update_cost;\n@@ -311,17 +314,19 @@ update_copy_costs (ira_allocno_t allocno, bool decr_p)\n   while (get_next_update_cost (&allocno, &divisor));\n }\n \n-/* This function updates COSTS (decrease if DECR_P) by conflict costs\n-   of the unassigned allocnos connected by copies with allocnos in\n-   update_cost_queue.  This update increases chances to remove some\n-   copies.  */\n+/* This function updates COSTS (decrease if DECR_P) for hard_registers\n+   of COVER_CLASS by conflict costs of the unassigned allocnos\n+   connected by copies with allocnos in update_cost_queue.  This\n+   update increases chances to remove some copies.  */\n static void\n-update_conflict_hard_regno_costs (int *costs, bool decr_p)\n+update_conflict_hard_regno_costs (int *costs, enum reg_class cover_class,\n+\t\t\t\t  bool decr_p)\n {\n   int i, cost, class_size, freq, mult, div, divisor;\n+  int index, hard_regno;\n   int *conflict_costs;\n   bool cont_p;\n-  enum reg_class cover_class;\n+  enum reg_class another_cover_class;\n   ira_allocno_t allocno, another_allocno;\n   ira_copy_t cp, next_cp;\n \n@@ -340,16 +345,17 @@ update_conflict_hard_regno_costs (int *costs, bool decr_p)\n \t  }\n \telse\n \t  gcc_unreachable ();\n-\tcover_class = ALLOCNO_COVER_CLASS (allocno);\n-\tif (cover_class != ALLOCNO_COVER_CLASS (another_allocno)\n+ \tanother_cover_class = ALLOCNO_COVER_CLASS (another_allocno);\n+ \tif (! ira_reg_classes_intersect_p[cover_class][another_cover_class]\n \t    || ALLOCNO_ASSIGNED_P (another_allocno)\n \t    || ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n \t\t\t\t\t (another_allocno)))\n \t  continue;\n-\tclass_size = ira_class_hard_regs_num[cover_class];\n+\tclass_size = ira_class_hard_regs_num[another_cover_class];\n \tira_allocate_and_copy_costs\n \t  (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n-\t   cover_class, ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n+\t   another_cover_class,\n+\t   ALLOCNO_CONFLICT_HARD_REG_COSTS (another_allocno));\n \tconflict_costs\n \t  = ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno);\n \tif (conflict_costs == NULL)\n@@ -364,13 +370,18 @@ update_conflict_hard_regno_costs (int *costs, bool decr_p)\n \t    cont_p = false;\n \t    for (i = class_size - 1; i >= 0; i--)\n \t      {\n+\t\thard_regno = ira_class_hard_regs[another_cover_class][i];\n+\t\tira_assert (hard_regno >= 0);\n+\t\tindex = ira_class_hard_reg_index[cover_class][hard_regno];\n+\t\tif (index < 0)\n+\t\t  continue;\n \t\tcost = conflict_costs [i] * mult / div;\n \t\tif (cost == 0)\n \t\t  continue;\n \t\tcont_p = true;\n \t\tif (decr_p)\n \t\t  cost = -cost;\n-\t\tcosts[i] += cost;\n+\t\tcosts[index] += cost;\n \t      }\n \t  }\n \t/* Probably 5 hops will be enough.  */\n@@ -429,11 +440,11 @@ static bool\n assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n {\n   HARD_REG_SET conflicting_regs;\n-  int i, j, hard_regno, best_hard_regno, class_size;\n+  int i, j, k, hard_regno, best_hard_regno, class_size;\n   int cost, mem_cost, min_cost, full_cost, min_full_cost, add_cost;\n   int *a_costs;\n   int *conflict_costs;\n-  enum reg_class cover_class, rclass;\n+  enum reg_class cover_class, rclass, conflict_cover_class;\n   enum machine_mode mode;\n   ira_allocno_t a, conflict_allocno;\n   ira_allocno_conflict_iterator aci;\n@@ -490,7 +501,9 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n \tif (retry_p || bitmap_bit_p (consideration_allocno_bitmap,\n \t\t\t\t     ALLOCNO_NUM (conflict_allocno)))\n \t  {\n-\t    ira_assert (cover_class == ALLOCNO_COVER_CLASS (conflict_allocno));\n+\t    conflict_cover_class = ALLOCNO_COVER_CLASS (conflict_allocno);\n+\t    ira_assert (ira_reg_classes_intersect_p\n+\t\t\t[cover_class][conflict_cover_class]);\n \t    if (allocno_coalesced_p)\n \t      {\n \t\tif (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n@@ -501,7 +514,8 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n \t      }\n \t    if (ALLOCNO_ASSIGNED_P (conflict_allocno))\n \t      {\n-\t\tif ((hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno)) >= 0)\n+\t\tif ((hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno)) >= 0\n+\t\t    && ira_class_hard_reg_index[cover_class][hard_regno] >= 0)\n \t\t  {\n \t\t    IOR_HARD_REG_SET\n \t\t      (conflicting_regs,\n@@ -511,20 +525,27 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n \t\t\t\t\t       conflicting_regs))\n \t\t      goto fail;\n \t\t  }\n-\t\tcontinue;\n \t      }\n \t    else if (! ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n \t\t\t\t\t\t (conflict_allocno)))\n \t      {\n \t\tira_allocate_and_copy_costs\n \t\t  (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno),\n-\t\t   cover_class,\n+\t\t   conflict_cover_class,\n \t\t   ALLOCNO_CONFLICT_HARD_REG_COSTS (conflict_allocno));\n \t\tconflict_costs\n \t\t  = ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno);\n \t\tif (conflict_costs != NULL)\n \t\t  for (j = class_size - 1; j >= 0; j--)\n-\t\t    full_costs[j] -= conflict_costs[j];\n+ \t\t    {\n+ \t\t      hard_regno = ira_class_hard_regs[cover_class][j];\n+ \t\t      ira_assert (hard_regno >= 0);\n+ \t\t      k = (ira_class_hard_reg_index\n+ \t\t\t   [conflict_cover_class][hard_regno]);\n+ \t\t      if (k < 0)\n+ \t\t\tcontinue;\n+ \t\t      full_costs[j] -= conflict_costs[k];\n+ \t\t    }\n \t\tqueue_update_cost (conflict_allocno, COST_HOP_DIVISOR);\n \t      }\n \t  }\n@@ -533,7 +554,7 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n     }\n   /* Take into account preferences of allocnos connected by copies to\n      the conflict allocnos.  */\n-  update_conflict_hard_regno_costs (full_costs, true);\n+  update_conflict_hard_regno_costs (full_costs, cover_class, true);\n \n   /* Take preferences of allocnos connected by copies into\n      account.  */\n@@ -545,7 +566,7 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n       if (a == allocno)\n \tbreak;\n     }\n-  update_conflict_hard_regno_costs (full_costs, false);\n+  update_conflict_hard_regno_costs (full_costs, cover_class, false);\n   min_cost = min_full_cost = INT_MAX;\n   /* We don't care about giving callee saved registers to allocnos no\n      living through calls because call clobbered registers are\n@@ -594,7 +615,8 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n       best_hard_regno = -1;\n     }\n  fail:\n-  if (best_hard_regno < 0\n+  if (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+      && best_hard_regno < 0\n       && ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno) != allocno)\n     {\n       for (j = 0, a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n@@ -1605,6 +1627,10 @@ coalesce_allocnos (bool reload_p)\n \t    {\n \t      next_cp = cp->next_first_allocno_copy;\n \t      regno = ALLOCNO_REGNO (cp->second);\n+\t      /* For priority coloring we coalesce allocnos only with\n+\t\t the same cover class not with intersected cover\n+\t\t classes as it were possible.  It is done for\n+\t\t simplicity.  */\n \t      if ((reload_p\n \t\t   || (ALLOCNO_COVER_CLASS (cp->second) == cover_class\n \t\t       && ALLOCNO_MODE (cp->second) == mode))\n@@ -1659,43 +1685,156 @@ coalesce_allocnos (bool reload_p)\n   ira_free (sorted_copies);\n }\n \n+/* Map: allocno number -> allocno priority.  */\n+static int *allocno_priorities;\n+\n+/* Set up priorities for N allocnos in array\n+   CONSIDERATION_ALLOCNOS.  */\n+static void\n+setup_allocno_priorities (ira_allocno_t *consideration_allocnos, int n)\n+{\n+  int i, length, nrefs, priority, max_priority, mult;\n+  ira_allocno_t a;\n+\n+  max_priority = 0;\n+  for (i = 0; i < n; i++)\n+    {\n+      a = consideration_allocnos[i];\n+      nrefs = ALLOCNO_NREFS (a);\n+      ira_assert (nrefs >= 0);\n+      mult = floor_log2 (ALLOCNO_NREFS (a)) + 1;\n+      ira_assert (mult >= 0);\n+      allocno_priorities[ALLOCNO_NUM (a)]\n+\t= priority\n+\t= (mult\n+\t   * (ALLOCNO_MEMORY_COST (a) - ALLOCNO_COVER_CLASS_COST (a))\n+\t   * ira_reg_class_nregs[ALLOCNO_COVER_CLASS (a)][ALLOCNO_MODE (a)]);\n+      if (priority < 0)\n+\tpriority = -priority;\n+      if (max_priority < priority)\n+\tmax_priority = priority;\n+    }\n+  mult = max_priority == 0 ? 1 : INT_MAX / max_priority;\n+  for (i = 0; i < n; i++)\n+    {\n+      a = consideration_allocnos[i];\n+      length = ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n+      if (length <= 0)\n+\tlength = 1;\n+      allocno_priorities[ALLOCNO_NUM (a)]\n+\t= allocno_priorities[ALLOCNO_NUM (a)] * mult / length;\n+    }\n+}\n+\n+/* Sort allocnos according to their priorities which are calculated\n+   analogous to ones in file `global.c'.  */\n+static int\n+allocno_priority_compare_func (const void *v1p, const void *v2p)\n+{\n+  ira_allocno_t a1 = *(const ira_allocno_t *) v1p;\n+  ira_allocno_t a2 = *(const ira_allocno_t *) v2p;\n+  int pri1, pri2;\n+\n+  pri1 = allocno_priorities[ALLOCNO_NUM (a1)];\n+  pri2 = allocno_priorities[ALLOCNO_NUM (a2)];\n+  if (pri2 - pri1)\n+    return pri2 - pri1;\n+\n+  /* If regs are equally good, sort by allocnos, so that the results of\n+     qsort leave nothing to chance.  */\n+  return ALLOCNO_NUM (a1) - ALLOCNO_NUM (a2);\n+}\n+\n /* Chaitin-Briggs coloring for allocnos in COLORING_ALLOCNO_BITMAP\n    taking into account allocnos in CONSIDERATION_ALLOCNO_BITMAP.  */\n static void\n color_allocnos (void)\n {\n-  unsigned int i;\n+  unsigned int i, n;\n   bitmap_iterator bi;\n   ira_allocno_t a;\n \n   allocno_coalesced_p = false;\n   processed_coalesced_allocno_bitmap = ira_allocate_bitmap ();\n   if (flag_ira_coalesce)\n     coalesce_allocnos (false);\n-  /* Put the allocnos into the corresponding buckets.  */\n-  colorable_allocno_bucket = NULL;\n-  uncolorable_allocno_bucket = NULL;\n-  EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n+  if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n     {\n-      a = ira_allocnos[i];\n-      if (ALLOCNO_COVER_CLASS (a) == NO_REGS)\n+      n = 0;\n+      EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n \t{\n-\t  ALLOCNO_HARD_REGNO (a) = -1;\n-\t  ALLOCNO_ASSIGNED_P (a) = true;\n-\t  ira_assert (ALLOCNO_UPDATED_HARD_REG_COSTS (a) == NULL);\n-\t  ira_assert (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) == NULL);\n-\t  if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t  a = ira_allocnos[i];\n+\t  if (ALLOCNO_COVER_CLASS (a) == NO_REGS)\n \t    {\n-\t      fprintf (ira_dump_file, \"      Spill\");\n-\t      print_coalesced_allocno (a);\n-\t      fprintf (ira_dump_file, \"\\n\");\n+\t      ALLOCNO_HARD_REGNO (a) = -1;\n+\t      ALLOCNO_ASSIGNED_P (a) = true;\n+\t      ira_assert (ALLOCNO_UPDATED_HARD_REG_COSTS (a) == NULL);\n+\t      ira_assert (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) == NULL);\n+\t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t\t{\n+\t\t  fprintf (ira_dump_file, \"      Spill\");\n+\t\t  print_coalesced_allocno (a);\n+\t\t  fprintf (ira_dump_file, \"\\n\");\n+\t\t}\n+\t      continue;\n \t    }\n-\t  continue;\n+\t  sorted_allocnos[n++] = a;\n \t}\n-      put_allocno_into_bucket (a);\n+      if (n != 0)\n+\t{\n+\t  setup_allocno_priorities (sorted_allocnos, n);\n+\t  qsort (sorted_allocnos, n, sizeof (ira_allocno_t),\n+\t\t allocno_priority_compare_func);\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      a = sorted_allocnos[i];\n+\t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t\t{\n+\t\t  fprintf (ira_dump_file, \"      \");\n+\t\t  print_coalesced_allocno (a);\n+\t\t  fprintf (ira_dump_file, \"  -- \");\n+\t\t}\n+\t      if (assign_hard_reg (a, false))\n+\t\t{\n+\t\t  if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t\t    fprintf (ira_dump_file, \"assign hard reg %d\\n\",\n+\t\t\t     ALLOCNO_HARD_REGNO (a));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t\t    fprintf (ira_dump_file, \"assign memory\\n\");\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* Put the allocnos into the corresponding buckets.  */\n+      colorable_allocno_bucket = NULL;\n+      uncolorable_allocno_bucket = NULL;\n+      EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n+\t{\n+\t  a = ira_allocnos[i];\n+\t  if (ALLOCNO_COVER_CLASS (a) == NO_REGS)\n+\t    {\n+\t      ALLOCNO_HARD_REGNO (a) = -1;\n+\t      ALLOCNO_ASSIGNED_P (a) = true;\n+\t      ira_assert (ALLOCNO_UPDATED_HARD_REG_COSTS (a) == NULL);\n+\t      ira_assert (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) == NULL);\n+\t      if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n+\t\t{\n+\t\t  fprintf (ira_dump_file, \"      Spill\");\n+\t\t  print_coalesced_allocno (a);\n+\t\t  fprintf (ira_dump_file, \"\\n\");\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  put_allocno_into_bucket (a);\n+\t}\n+      push_allocnos_to_stack ();\n+      pop_allocnos_from_stack ();\n     }\n-  push_allocnos_to_stack ();\n-  pop_allocnos_from_stack ();\n   if (flag_ira_coalesce)\n     /* We don't need coalesced allocnos for ira_reassign_pseudos.  */\n     EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n@@ -1796,8 +1935,8 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n   /* Color all mentioned allocnos including transparent ones.  */\n   color_allocnos ();\n   /* Process caps.  They are processed just once.  */\n-  if (flag_ira_algorithm == IRA_ALGORITHM_MIXED\n-      || flag_ira_algorithm == IRA_ALGORITHM_REGIONAL)\n+  if (flag_ira_region == IRA_REGION_MIXED\n+      || flag_ira_region == IRA_REGION_ALL)\n     EXECUTE_IF_SET_IN_BITMAP (loop_tree_node->all_allocnos, 0, j, bi)\n       {\n \ta = ira_allocnos[j];\n@@ -1806,9 +1945,9 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t/* Remove from processing in the next loop.  */\n \tbitmap_clear_bit (consideration_allocno_bitmap, j);\n \trclass = ALLOCNO_COVER_CLASS (a);\n-\tif ((flag_ira_algorithm == IRA_ALGORITHM_MIXED\n-\t     && loop_tree_node->reg_pressure[rclass]\n-\t     <= ira_available_class_regs[rclass]))\n+\tif (flag_ira_region == IRA_REGION_MIXED\n+\t    && (loop_tree_node->reg_pressure[rclass]\n+\t\t<= ira_available_class_regs[rclass]))\n \t  {\n \t    mode = ALLOCNO_MODE (a);\n \t    hard_regno = ALLOCNO_HARD_REGNO (a);\n@@ -1843,6 +1982,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t  mode = ALLOCNO_MODE (a);\n \t  rclass = ALLOCNO_COVER_CLASS (a);\n \t  hard_regno = ALLOCNO_HARD_REGNO (a);\n+\t  /* Use hard register class here.  ??? */\n \t  if (hard_regno >= 0)\n \t    {\n \t      index = ira_class_hard_reg_index[rclass][hard_regno];\n@@ -1854,9 +1994,10 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t  if (subloop_allocno == NULL\n \t      || ALLOCNO_CAP (subloop_allocno) != NULL)\n \t    continue;\n+\t  ira_assert (ALLOCNO_COVER_CLASS (subloop_allocno) == rclass);\n \t  ira_assert (bitmap_bit_p (subloop_node->all_allocnos,\n \t\t\t\t    ALLOCNO_NUM (subloop_allocno)));\n-\t  if (flag_ira_algorithm == IRA_ALGORITHM_MIXED\n+\t  if ((flag_ira_region == IRA_REGION_MIXED)\n \t      && (loop_tree_node->reg_pressure[rclass]\n \t\t  <= ira_available_class_regs[rclass]))\n \t    {\n@@ -2002,6 +2143,7 @@ move_spill_restore (void)\n \t      subloop_allocno = subloop_node->regno_allocno_map[regno];\n \t      if (subloop_allocno == NULL)\n \t\tcontinue;\n+\t      ira_assert (rclass == ALLOCNO_COVER_CLASS (subloop_allocno));\n \t      /* We have accumulated cost.  To get the real cost of\n \t\t allocno usage in the loop we should subtract costs of\n \t\t the subloop allocnos.  */\n@@ -2027,6 +2169,7 @@ move_spill_restore (void)\n \t  if ((parent = loop_node->parent) != NULL\n \t      && (parent_allocno = parent->regno_allocno_map[regno]) != NULL)\n \t    {\n+\t      ira_assert (rclass == ALLOCNO_COVER_CLASS (parent_allocno));\n \t      exit_freq\t= ira_loop_edge_freq (loop_node, regno, true);\n \t      enter_freq = ira_loop_edge_freq (loop_node, regno, false);\n \t      if ((hard_regno2 = ALLOCNO_HARD_REGNO (parent_allocno)) < 0)\n@@ -2094,13 +2237,15 @@ update_curr_costs (ira_allocno_t a)\n \t}\n       else\n \tgcc_unreachable ();\n-      if (cover_class != ALLOCNO_COVER_CLASS (another_a)\n+      if (! ira_reg_classes_intersect_p[cover_class][ALLOCNO_COVER_CLASS\n+\t\t\t\t\t\t     (another_a)]\n \t  || ! ALLOCNO_ASSIGNED_P (another_a)\n \t  || (hard_regno = ALLOCNO_HARD_REGNO (another_a)) < 0)\n \tcontinue;\n       rclass = REGNO_REG_CLASS (hard_regno);\n       i = ira_class_hard_reg_index[cover_class][hard_regno];\n-      ira_assert (i >= 0);\n+      if (i < 0)\n+\tcontinue;\n       cost = (cp->first == a\n \t      ? ira_register_move_cost[mode][rclass][cover_class]\n \t      : ira_register_move_cost[mode][cover_class][rclass]);\n@@ -2116,66 +2261,6 @@ update_curr_costs (ira_allocno_t a)\n     }\n }\n \n-/* Map: allocno number -> allocno priority.  */\n-static int *allocno_priorities;\n-\n-/* Set up priorities for N allocnos in array\n-   CONSIDERATION_ALLOCNOS.  */\n-static void\n-setup_allocno_priorities (ira_allocno_t *consideration_allocnos, int n)\n-{\n-  int i, length, nrefs, priority, max_priority, mult;\n-  ira_allocno_t a;\n-\n-  max_priority = 0;\n-  for (i = 0; i < n; i++)\n-    {\n-      a = consideration_allocnos[i];\n-      nrefs = ALLOCNO_NREFS (a);\n-      ira_assert (nrefs >= 0);\n-      mult = floor_log2 (ALLOCNO_NREFS (a)) + 1;\n-      ira_assert (mult >= 0);\n-      allocno_priorities[ALLOCNO_NUM (a)]\n-\t= priority\n-\t= (mult\n-\t   * (ALLOCNO_MEMORY_COST (a) - ALLOCNO_COVER_CLASS_COST (a))\n-\t   * ira_reg_class_nregs[ALLOCNO_COVER_CLASS (a)][ALLOCNO_MODE (a)]);\n-      if (priority < 0)\n-\tpriority = -priority;\n-      if (max_priority < priority)\n-\tmax_priority = priority;\n-    }\n-  mult = max_priority == 0 ? 1 : INT_MAX / max_priority;\n-  for (i = 0; i < n; i++)\n-    {\n-      a = consideration_allocnos[i];\n-      length = ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n-      if (length <= 0)\n-\tlength = 1;\n-      allocno_priorities[ALLOCNO_NUM (a)]\n-\t= allocno_priorities[ALLOCNO_NUM (a)] * mult / length;\n-    }\n-}\n-\n-/* Sort allocnos according to their priorities which are calculated\n-   analogous to ones in file `global.c'.  */\n-static int\n-allocno_priority_compare_func (const void *v1p, const void *v2p)\n-{\n-  ira_allocno_t a1 = *(const ira_allocno_t *) v1p;\n-  ira_allocno_t a2 = *(const ira_allocno_t *) v2p;\n-  int pri1, pri2;\n-\n-  pri1 = allocno_priorities[ALLOCNO_NUM (a1)];\n-  pri2 = allocno_priorities[ALLOCNO_NUM (a2)];\n-  if (pri2 - pri1)\n-    return pri2 - pri1;\n-\n-  /* If regs are equally good, sort by allocnos, so that the results of\n-     qsort leave nothing to chance.  */\n-  return ALLOCNO_NUM (a1) - ALLOCNO_NUM (a2);\n-}\n-\n /* Try to assign hard registers to the unassigned allocnos and\n    allocnos conflicting with them or conflicting with allocnos whose\n    regno >= START_REGNO.  The function is called after ira_flattening,\n@@ -2215,7 +2300,8 @@ ira_reassign_conflict_allocnos (int start_regno)\n \tcontinue;\n       FOR_EACH_ALLOCNO_CONFLICT (a, conflict_a, aci)\n \t{\n-\t  ira_assert (cover_class == ALLOCNO_COVER_CLASS (conflict_a));\n+\t  ira_assert (ira_reg_classes_intersect_p\n+\t\t      [cover_class][ALLOCNO_COVER_CLASS (conflict_a)]);\n \t  if (bitmap_bit_p (allocnos_to_color, ALLOCNO_NUM (conflict_a)))\n \t    continue;\n \t  bitmap_set_bit (allocnos_to_color, ALLOCNO_NUM (conflict_a));"}, {"sha": "ff116b5da8a1f53adb0abd49f6c33668137eba1b", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -114,7 +114,8 @@ build_conflict_bit_table (void)\n \t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, j)\n \t    {\n \t      live_a = ira_allocnos[j];\n-\t      if (cover_class == ALLOCNO_COVER_CLASS (live_a)\n+\t      if (ira_reg_classes_intersect_p\n+\t\t  [cover_class][ALLOCNO_COVER_CLASS (live_a)]\n \t\t  /* Don't set up conflict for the allocno with itself.  */\n \t\t  && num != (int) j)\n \t\t{\n@@ -555,8 +556,8 @@ build_allocno_conflicts (ira_allocno_t a)\n \t\t\t   ALLOCNO_MIN (a), ALLOCNO_MAX (a), i, asi)\n     {\n       another_a = ira_conflict_id_allocno_map[i];\n-      ira_assert (ALLOCNO_COVER_CLASS (a)\n-\t\t  == ALLOCNO_COVER_CLASS (another_a));\n+      ira_assert (ira_reg_classes_intersect_p\n+\t\t  [ALLOCNO_COVER_CLASS (a)][ALLOCNO_COVER_CLASS (another_a)]);\n       collected_conflict_allocnos[px++] = another_a;\n     }\n   if (ira_conflict_vector_profitable_p (a, px))\n@@ -592,8 +593,8 @@ build_allocno_conflicts (ira_allocno_t a)\n \t\t\t   ALLOCNO_MIN (a), ALLOCNO_MAX (a), i, asi)\n     {\n       another_a = ira_conflict_id_allocno_map[i];\n-      ira_assert (ALLOCNO_COVER_CLASS (a)\n-\t\t  == ALLOCNO_COVER_CLASS (another_a));\n+      ira_assert (ira_reg_classes_intersect_p\n+\t\t  [ALLOCNO_COVER_CLASS (a)][ALLOCNO_COVER_CLASS (another_a)]);\n       if ((another_parent_a = ALLOCNO_CAP (another_a)) == NULL\n \t  && (another_parent_a = (parent->regno_allocno_map\n \t\t\t\t  [ALLOCNO_REGNO (another_a)])) == NULL)\n@@ -740,15 +741,16 @@ ira_build_conflicts (void)\n {\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n+  HARD_REG_SET temp_hard_reg_set;\n \n   if (optimize)\n     {\n       build_conflict_bit_table ();\n       build_conflicts ();\n       ira_traverse_loop_tree (true, ira_loop_tree_root, NULL, add_copies);\n       /* We need finished conflict table for the subsequent call.  */\n-      if (flag_ira_algorithm == IRA_ALGORITHM_REGIONAL\n-\t  || flag_ira_algorithm == IRA_ALGORITHM_MIXED)\n+      if (flag_ira_region == IRA_REGION_ALL\n+\t  || flag_ira_region == IRA_REGION_MIXED)\n \tpropagate_copies ();\n       /* Now we can free memory for the conflict table (see function\n \t build_allocno_conflicts for details).  */\n@@ -759,6 +761,14 @@ ira_build_conflicts (void)\n \t}\n       ira_free (conflicts);\n     }\n+  if (! CLASS_LIKELY_SPILLED_P (BASE_REG_CLASS))\n+    CLEAR_HARD_REG_SET (temp_hard_reg_set);\n+  else\n+    {\n+      COPY_HARD_REG_SET (temp_hard_reg_set, reg_class_contents[BASE_REG_CLASS]);\n+      AND_COMPL_HARD_REG_SET (temp_hard_reg_set, ira_no_alloc_regs);\n+      AND_HARD_REG_SET (temp_hard_reg_set, call_used_reg_set);\n+    }\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       if (ALLOCNO_CALLS_CROSSED_NUM (a) == 0)\n@@ -775,9 +785,15 @@ ira_build_conflicts (void)\n \t{\n \t  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n \t\t\t    no_caller_save_reg_set);\n+\t  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n+\t\t\t    temp_hard_reg_set);\n \t  if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\t    IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n-\t\t\t      no_caller_save_reg_set);\n+\t    {\n+\t      IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t\t\t\tno_caller_save_reg_set);\n+\t      IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t\t\t\ttemp_hard_reg_set);\n+\t    }\n \t}\n     }\n   if (optimize && internal_flag_ira_verbose > 2 && ira_dump_file != NULL)"}, {"sha": "a2df9bde9ae06e0f2da32d87da609cca28a3d2ab", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -105,6 +105,9 @@ static enum reg_class *allocno_pref;\n /* Allocated buffers for allocno_pref.  */\n static enum reg_class *allocno_pref_buffer;\n \n+/* Record register class of each allocno with the same regno.  */\n+static enum reg_class *common_classes;\n+\n /* Execution frequency of the current insn.  */\n static int frequency;\n \n@@ -1082,8 +1085,8 @@ print_costs (FILE *f)\n \t    {\n \t      fprintf (f, \" %s:%d\", reg_class_names[rclass],\n \t\t       COSTS_OF_ALLOCNO (allocno_costs, i)->cost[k]);\n-\t      if (flag_ira_algorithm == IRA_ALGORITHM_REGIONAL\n-\t\t  || flag_ira_algorithm == IRA_ALGORITHM_MIXED)\n+\t      if (flag_ira_region == IRA_REGION_ALL\n+\t\t  || flag_ira_region == IRA_REGION_MIXED)\n \t\tfprintf (f, \",%d\", COSTS_OF_ALLOCNO (total_costs, i)->cost[k]);\n \t    }\n \t}\n@@ -1173,7 +1176,7 @@ find_allocno_class_costs (void)\n \t  int rclass, a_num, parent_a_num;\n \t  ira_loop_tree_node_t parent;\n \t  int best_cost, allocno_cost;\n-\t  enum reg_class best, alt_class, common_class;\n+\t  enum reg_class best, alt_class;\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t  int inc_dec_p = false;\n #endif\n@@ -1187,8 +1190,8 @@ find_allocno_class_costs (void)\n \t       a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t    {\n \t      a_num = ALLOCNO_NUM (a);\n-\t      if ((flag_ira_algorithm == IRA_ALGORITHM_REGIONAL\n-\t\t   || flag_ira_algorithm == IRA_ALGORITHM_MIXED)\n+\t      if ((flag_ira_region == IRA_REGION_ALL\n+\t\t   || flag_ira_region == IRA_REGION_MIXED)\n \t\t  && (parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) != NULL\n \t\t  && (parent_a = parent->regno_allocno_map[i]) != NULL\n \t\t  /* There are no caps yet.  */\n@@ -1247,6 +1250,7 @@ find_allocno_class_costs (void)\n \t\t      > reg_class_size[alt_class]))\n \t\talt_class = reg_class_subunion[alt_class][rclass];\n \t    }\n+\t  alt_class = ira_class_translate[alt_class];\n \t  if (pass == flag_expensive_optimizations)\n \t    {\n \t      if (best_cost > temp_costs->mem_cost)\n@@ -1260,18 +1264,22 @@ find_allocno_class_costs (void)\n \t\t\t i, reg_class_names[best], reg_class_names[alt_class]);\n \t    }\n \t  if (best_cost > temp_costs->mem_cost)\n-\t    common_class = NO_REGS;\n+\t    common_classes[i] = NO_REGS;\n+\t  else if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n+\t    /* Make the common class the biggest class of best and\n+\t       alt_class.  */\n+\t    common_classes[i] = alt_class == NO_REGS ? best : alt_class;\n \t  else\n \t    /* Make the common class a cover class.  Remember all\n \t       allocnos with the same regno should have the same cover\n \t       class.  */\n-\t    common_class = ira_class_translate[best];\n+\t    common_classes[i] = ira_class_translate[best];\n \t  for (a = ira_regno_allocno_map[i];\n \t       a != NULL;\n \t       a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t    {\n \t      a_num = ALLOCNO_NUM (a);\n-\t      if (common_class == NO_REGS)\n+\t      if (common_classes[i] == NO_REGS)\n \t\tbest = NO_REGS;\n \t      else\n \t\t{\t      \n@@ -1283,7 +1291,7 @@ find_allocno_class_costs (void)\n \t\t  for (k = 0; k < cost_classes_num; k++)\n \t\t    {\n \t\t      rclass = cost_classes[k];\n-\t\t      if (! ira_class_subset_p[rclass][common_class])\n+\t\t      if (! ira_class_subset_p[rclass][common_classes[i]])\n \t\t\tcontinue;\n \t\t      /* Ignore classes that are too small for this\n \t\t\t operand or invalid for an operand that was\n@@ -1319,6 +1327,8 @@ find_allocno_class_costs (void)\n \t\t    }\n \t\t  ALLOCNO_COVER_CLASS_COST (a) = allocno_cost;\n \t\t}\n+\t      ira_assert (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY\n+\t\t\t  || ira_class_translate[best] == common_classes[i]);\n \t      if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL\n \t\t  && (pass == 0 || allocno_pref[a_num] != best))\n \t\t{\n@@ -1330,7 +1340,7 @@ find_allocno_class_costs (void)\n \t\t\t     ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n \t\t  fprintf (ira_dump_file, \") best %s, cover %s\\n\",\n \t\t\t   reg_class_names[best],\n-\t\t\t   reg_class_names[ira_class_translate[best]]);\n+\t\t\t   reg_class_names[common_classes[i]]);\n \t\t}\n \t      allocno_pref[a_num] = best;\n \t    }\n@@ -1439,7 +1449,7 @@ setup_allocno_cover_class_and_costs (void)\n     {\n       i = ALLOCNO_NUM (a);\n       mode = ALLOCNO_MODE (a);\n-      cover_class = ira_class_translate[allocno_pref[i]];\n+      cover_class = common_classes[ALLOCNO_REGNO (a)];\n       ira_assert (allocno_pref[i] == NO_REGS || cover_class != NO_REGS);\n       ALLOCNO_MEMORY_COST (a) = COSTS_OF_ALLOCNO (allocno_costs, i)->mem_cost;\n       ira_set_allocno_cover_class (a, cover_class);\n@@ -1572,6 +1582,9 @@ ira_costs (void)\n   allocno_pref_buffer\n     = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n \t\t\t\t       * ira_allocnos_num);\n+  common_classes\n+    = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n+\t\t\t\t       * max_reg_num ());\n   find_allocno_class_costs ();\n   setup_allocno_cover_class_and_costs ();\n   /* Because we could process operands only as subregs, check mode of\n@@ -1580,6 +1593,7 @@ ira_costs (void)\n     if (ira_register_move_cost[ALLOCNO_MODE (a)] == NULL\n \t&& have_regs_of_mode[ALLOCNO_MODE (a)])\n       ira_init_register_move_cost (ALLOCNO_MODE (a));\n+  ira_free (common_classes);\n   ira_free (allocno_pref_buffer);\n   ira_free (total_costs);\n   ira_free (allocno_costs);"}, {"sha": "536d6ee47f4d6c1f8a1816fa4071690e189d06e2", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -1025,6 +1025,7 @@ void\n ira_emit (bool loops_p)\n {\n   basic_block bb;\n+  rtx insn;\n   edge_iterator ei;\n   edge e;\n   ira_allocno_t a;\n@@ -1085,6 +1086,14 @@ ira_emit (bool loops_p)\n   ira_free (allocno_last_set_check);\n   ira_free (allocno_last_set);\n   commit_edge_insertions ();\n+  /* Fix insn codes.  It is necessary to do it before reload because\n+     reload assumes initial insn codes defined.  The insn codes can be\n+     invalidated by CFG infrastructure for example in jump\n+     redirection.  */\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS_REVERSE (bb, insn)\n+      if (INSN_P (insn))\n+\trecog_memoized (insn);\n   ira_free (at_bb_end);\n   ira_free (at_bb_start);\n }"}, {"sha": "1fc6da265e2f9b3eee2b077898150b0623807659", "filename": "gcc/ira-int.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -819,6 +819,16 @@ extern enum reg_class ira_class_translate[N_REG_CLASSES];\n    taking all hard-registers including fixed ones into account.  */\n extern enum reg_class ira_reg_class_intersect[N_REG_CLASSES][N_REG_CLASSES];\n \n+/* True if the two classes (that is calculated taking only hard\n+   registers available for allocation into account) are\n+   intersected.  */\n+extern bool ira_reg_classes_intersect_p[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* Classes with end marker LIM_REG_CLASSES which are intersected with\n+   given class (the first index).  That includes given class itself.\n+   This is calculated taking only hard registers available for\n+   allocation into account.  */\n+extern enum reg_class ira_reg_class_super_classes[N_REG_CLASSES][N_REG_CLASSES];\n /* The biggest important class inside of union of the two classes\n    (that is calculated taking only hard registers available for\n    allocation into account).  If the both classes contain no hard"}, {"sha": "c7868f39a54fd8cb1a4477932531975b896f4e81", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 113, "deletions": 73, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -117,18 +117,23 @@ make_regno_born (int regno)\n static void\n update_allocno_pressure_excess_length (ira_allocno_t a)\n {\n-  int start;\n-  enum reg_class cover_class;\n+  int start, i;\n+  enum reg_class cover_class, cl;\n   allocno_live_range_t p;\n \n   cover_class = ALLOCNO_COVER_CLASS (a);\n-  if (high_pressure_start_point[cover_class] < 0)\n-    return;\n-  p = ALLOCNO_LIVE_RANGES (a);\n-  ira_assert (p != NULL);\n-  start = (high_pressure_start_point[cover_class] > p->start\n-\t   ? high_pressure_start_point[cover_class] : p->start);\n-  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a) += curr_point - start + 1;\n+  for (i = 0;\n+       (cl = ira_reg_class_super_classes[cover_class][i]) != LIM_REG_CLASSES;\n+       i++)\n+    {\n+      if (high_pressure_start_point[cl] < 0)\n+\tcontinue;\n+      p = ALLOCNO_LIVE_RANGES (a);\n+      ira_assert (p != NULL);\n+      start = (high_pressure_start_point[cl] > p->start\n+\t       ? high_pressure_start_point[cl] : p->start);\n+      ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a) += curr_point - start + 1;\n+    }\n }\n \n /* Process the death of register REGNO.  This updates hard_regs_live\n@@ -165,8 +170,8 @@ static int curr_reg_pressure[N_REG_CLASSES];\n static void\n set_allocno_live (ira_allocno_t a)\n {\n-  int nregs;\n-  enum reg_class cover_class;\n+  int i;\n+  enum reg_class cover_class, cl;\n \n   /* Invalidate because it is referenced.  */\n   allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n@@ -176,15 +181,17 @@ set_allocno_live (ira_allocno_t a)\n   IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a), hard_regs_live);\n   IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), hard_regs_live);\n   cover_class = ALLOCNO_COVER_CLASS (a);\n-  nregs = ira_reg_class_nregs[cover_class][ALLOCNO_MODE (a)];\n-  curr_reg_pressure[cover_class] += nregs;\n-  if (high_pressure_start_point[cover_class] < 0\n-      && (curr_reg_pressure[cover_class]\n-\t  > ira_available_class_regs[cover_class]))\n-    high_pressure_start_point[cover_class] = curr_point;\n-  if (curr_bb_node->reg_pressure[cover_class]\n-      < curr_reg_pressure[cover_class])\n-    curr_bb_node->reg_pressure[cover_class] = curr_reg_pressure[cover_class];\n+  for (i = 0;\n+       (cl = ira_reg_class_super_classes[cover_class][i]) != LIM_REG_CLASSES;\n+       i++)\n+    {\n+      curr_reg_pressure[cl] += ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n+      if (high_pressure_start_point[cl] < 0\n+\t  && (curr_reg_pressure[cl] > ira_available_class_regs[cl]))\n+\thigh_pressure_start_point[cl] = curr_point;\n+      if (curr_bb_node->reg_pressure[cl] < curr_reg_pressure[cl])\n+\tcurr_bb_node->reg_pressure[cl] = curr_reg_pressure[cl];\n+    }\n }\n \n /* Mark allocno A as currently not living and update current register\n@@ -193,26 +200,40 @@ set_allocno_live (ira_allocno_t a)\n static void\n clear_allocno_live (ira_allocno_t a)\n {\n-  unsigned int i;\n-  enum reg_class cover_class;\n+  int i;\n+  unsigned int j;\n+  enum reg_class cover_class, cl;\n+  bool set_p;\n \n   /* Invalidate because it is referenced.  */\n   allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n   if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n     {\n       cover_class = ALLOCNO_COVER_CLASS (a);\n-      curr_reg_pressure[cover_class]\n-\t-= ira_reg_class_nregs[cover_class][ALLOCNO_MODE (a)];\n-      ira_assert (curr_reg_pressure[cover_class] >= 0);\n-      if (high_pressure_start_point[cover_class] >= 0\n-\t  && (curr_reg_pressure[cover_class]\n-\t      <= ira_available_class_regs[cover_class]))\n+      set_p = false;\n+      for (i = 0;\n+\t   (cl = ira_reg_class_super_classes[cover_class][i])\n+\t     != LIM_REG_CLASSES;\n+\t   i++)\n \t{\n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\t    {\n-\t      update_allocno_pressure_excess_length (ira_allocnos[i]);\n-\t    }\n-\t  high_pressure_start_point[cover_class] = -1;\n+\t  curr_reg_pressure[cl] -= ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n+\t  ira_assert (curr_reg_pressure[cl] >= 0);\n+\t  if (high_pressure_start_point[cl] >= 0\n+\t      && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n+\t    set_p = true;\n+\t}\n+      if (set_p)\n+\t{\n+\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, j)\n+\t    update_allocno_pressure_excess_length (ira_allocnos[j]);\n+\t  for (i = 0;\n+\t       (cl = ira_reg_class_super_classes[cover_class][i])\n+\t\t != LIM_REG_CLASSES;\n+\t       i++)\n+\t    if (high_pressure_start_point[cl] >= 0\n+\t\t&& curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n+\t      high_pressure_start_point[cl] = -1;\n+\t  \n \t}\n     }\n   sparseset_clear_bit (allocnos_live, ALLOCNO_NUM (a));\n@@ -225,7 +246,7 @@ clear_allocno_live (ira_allocno_t a)\n static void\n mark_reg_live (rtx reg)\n {\n-  int regno;\n+  int i, regno;\n \n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n@@ -249,28 +270,34 @@ mark_reg_live (rtx reg)\n   else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n-      enum reg_class cover_class;\n+      enum reg_class cover_class, cl;\n \n       while (regno < last)\n \t{\n \t  if (! TEST_HARD_REG_BIT (hard_regs_live, regno)\n \t      && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n \t    {\n \t      cover_class = ira_hard_regno_cover_class[regno];\n-\t      if (cover_class != NO_REGS)\n+\t      for (i = 0;\n+\t\t   (cl = ira_reg_class_super_classes[cover_class][i])\n+\t\t     != LIM_REG_CLASSES;\n+\t\t   i++)\n \t\t{\n-\t\t  curr_reg_pressure[cover_class]++;\n-\t\t  if (high_pressure_start_point[cover_class] < 0\n-\t\t      && (curr_reg_pressure[cover_class]\n-\t\t\t  > ira_available_class_regs[cover_class]))\n-\t\t    high_pressure_start_point[cover_class] = curr_point;\n+\t\t  curr_reg_pressure[cl]++;\n+\t\t  if (high_pressure_start_point[cl] < 0\n+\t\t      && (curr_reg_pressure[cl]\n+\t\t\t  > ira_available_class_regs[cl]))\n+\t\t    high_pressure_start_point[cl] = curr_point;\n \t\t}\n \t      make_regno_born (regno);\n-\t      if (cover_class != NO_REGS\n-\t\t  && (curr_bb_node->reg_pressure[cover_class]\n-\t\t      < curr_reg_pressure[cover_class]))\n-\t\tcurr_bb_node->reg_pressure[cover_class]\n-\t\t  = curr_reg_pressure[cover_class];\n+\t      for (i = 0;\n+\t\t   (cl = ira_reg_class_super_classes[cover_class][i])\n+\t\t     != LIM_REG_CLASSES;\n+\t\t   i++)\n+\t\t{\n+\t\t  if (curr_bb_node->reg_pressure[cl] < curr_reg_pressure[cl])\n+\t\t    curr_bb_node->reg_pressure[cl] = curr_reg_pressure[cl];\n+\t\t}\n \t    }\n \t  regno++;\n \t}\n@@ -317,30 +344,41 @@ mark_reg_dead (rtx reg)\n     }\n   else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n-      unsigned int i;\n+      int i;\n+      unsigned int j;\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n-      enum reg_class cover_class;\n+      enum reg_class cover_class, cl;\n+      bool set_p;\n \n       while (regno < last)\n \t{\n \t  if (TEST_HARD_REG_BIT (hard_regs_live, regno))\n \t    {\n+\t      set_p = false;\n \t      cover_class = ira_hard_regno_cover_class[regno];\n-\t      if (cover_class != NO_REGS)\n+\t      for (i = 0;\n+\t\t   (cl = ira_reg_class_super_classes[cover_class][i])\n+\t\t     != LIM_REG_CLASSES;\n+\t\t   i++)\n+  \t\t{\n+\t\t  curr_reg_pressure[cl]--;\n+\t\t  if (high_pressure_start_point[cl] >= 0\n+\t\t      && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n+\t\t    set_p = true;\n+\t\t  ira_assert (curr_reg_pressure[cl] >= 0);\n+\t\t}\n+\t      if (set_p)\n \t\t{\n-\t\t  curr_reg_pressure[cover_class]--;\n-\t\t  if (high_pressure_start_point[cover_class] >= 0\n-\t\t      && (curr_reg_pressure[cover_class]\n-\t\t\t  <= ira_available_class_regs[cover_class]))\n-\t\t    {\n-\t\t      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\t\t\t{\n-\t\t\t  update_allocno_pressure_excess_length\n-\t\t\t    (ira_allocnos[i]);\n-\t\t\t}\n-\t\t      high_pressure_start_point[cover_class] = -1;\n-\t\t    }\n-\t\t  ira_assert (curr_reg_pressure[cover_class] >= 0);\n+\t\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, j)\n+\t\t    update_allocno_pressure_excess_length (ira_allocnos[j]);\n+\t\t  for (i = 0;\n+\t\t       (cl = ira_reg_class_super_classes[cover_class][i])\n+\t\t\t != LIM_REG_CLASSES;\n+\t\t       i++)\n+\t\t    if (high_pressure_start_point[cl] >= 0\n+\t\t\t&& (curr_reg_pressure[cl]\n+\t\t\t    <= ira_available_class_regs[cl]))\n+\t\t      high_pressure_start_point[cl] = -1;\n \t\t}\n \t      make_regno_dead (regno);\n \t    }\n@@ -807,18 +845,20 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (hard_regs_live, i))\n \t  {\n-\t    enum reg_class cover_class;\n+\t    enum reg_class cover_class, cl;\n \t    \n-\t    cover_class = ira_hard_regno_cover_class[i];\n-\t    if (cover_class == NO_REGS)\n-\t      continue;\n-\t    curr_reg_pressure[cover_class]++;\n-\t    if (curr_bb_node->reg_pressure[cover_class]\n-\t\t< curr_reg_pressure[cover_class])\n-\t      curr_bb_node->reg_pressure[cover_class]\n-\t\t= curr_reg_pressure[cover_class];\n-\t    ira_assert (curr_reg_pressure[cover_class]\n-\t\t\t<= ira_available_class_regs[cover_class]);\n+\t    cover_class = ira_class_translate[REGNO_REG_CLASS (i)];\n+\t    for (j = 0;\n+\t\t (cl = ira_reg_class_super_classes[cover_class][j])\n+\t\t   != LIM_REG_CLASSES;\n+\t\t j++)\n+\t      {\n+\t\tcurr_reg_pressure[cl]++;\n+\t\tif (curr_bb_node->reg_pressure[cl] < curr_reg_pressure[cl])\n+\t\t  curr_bb_node->reg_pressure[cl] = curr_reg_pressure[cl];\n+\t\tira_assert (curr_reg_pressure[cl]\n+\t\t\t    <= ira_available_class_regs[cl]);\n+\t      }\n \t  }\n       EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n \t{"}, {"sha": "44f7032bf3197ad3c9d3a4b4ff27451009f6e381", "filename": "gcc/ira.c", "status": "modified", "additions": 156, "deletions": 46, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -434,6 +434,8 @@ setup_class_hard_regs (void)\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       CLEAR_HARD_REG_SET (processed_hard_reg_set);\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tira_class_hard_reg_index[cl][0] = -1;\n       for (n = 0, i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t{\n #ifdef REG_ALLOC_ORDER\n@@ -714,22 +716,72 @@ enum reg_class ira_important_classes[N_REG_CLASSES];\n    classes.  */\n int ira_important_class_nums[N_REG_CLASSES];\n \n-/* Check IRA_COVER_CLASSES and sets the four global variables defined\n-   above.  */\n+/* Set the four global variables defined above.  */\n static void\n setup_cover_and_important_classes (void)\n {\n-  int i, j;\n+  int i, j, n;\n+  bool set_p, eq_p;\n   enum reg_class cl;\n-  const enum reg_class *classes;\n+  const enum reg_class *cover_classes;\n   HARD_REG_SET temp_hard_regset2;\n+  static enum reg_class classes[LIM_REG_CLASSES + 1];\n+\n+  if (targetm.ira_cover_classes == NULL)\n+    cover_classes = NULL;\n+  else\n+    cover_classes = targetm.ira_cover_classes ();\n+  if (cover_classes == NULL)\n+    ira_assert (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY);\n+  else\n+    {\n+      for (i = 0; (cl = cover_classes[i]) != LIM_REG_CLASSES; i++)\n+\tclasses[i] = cl;\n+      classes[i] = LIM_REG_CLASSES;\n+    }\n+\n+  if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n+    {\n+      n = 0;\n+      for (i = 0; i <= LIM_REG_CLASSES; i++)\n+\t{\n+\t  if (i == NO_REGS)\n+\t    continue;\n+#ifdef CONSTRAINT__LIMIT\n+\t  for (j = 0; j < CONSTRAINT__LIMIT; j++)\n+\t    if ((int) regclass_for_constraint (j) == i)\n+\t      break;\n+\t  if (j < CONSTRAINT__LIMIT)\n+\t    {\n+\t      classes[n++] = i;\n+\t      continue;\n+\t    }\n+#endif\n+\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n+\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t  for (j = 0; j < LIM_REG_CLASSES; j++)\n+\t    {\n+\t      if (i == j)\n+\t\tcontinue;\n+\t      COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[j]);\n+\t      AND_COMPL_HARD_REG_SET (temp_hard_regset2,\n+\t\t\t\t      no_unit_alloc_regs);\n+\t      if (hard_reg_set_equal_p (temp_hard_regset,\n+\t\t\t\t\ttemp_hard_regset2))\n+\t\t    break;\n+\t    }\n+\t  if (j >= i)\n+\t    classes[n++] = i;\n+\t}\n+      classes[n] = LIM_REG_CLASSES;\n+    }\n \n-  classes = targetm.ira_cover_classes ();\n   ira_reg_class_cover_size = 0;\n   for (i = 0; (cl = classes[i]) != LIM_REG_CLASSES; i++)\n     {\n       for (j = 0; j < i; j++)\n-\tif (reg_classes_intersect_p (cl, classes[j]))\n+\tif (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY\n+\t    && reg_classes_intersect_p (cl, classes[j]))\n \t  gcc_unreachable ();\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n@@ -742,22 +794,34 @@ setup_cover_and_important_classes (void)\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       if (! hard_reg_set_empty_p (temp_hard_regset))\n-\tfor (j = 0; j < ira_reg_class_cover_size; j++)\n-\t  {\n-\t    COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-\t    AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t    COPY_HARD_REG_SET (temp_hard_regset2,\n-\t\t\t       reg_class_contents[ira_reg_class_cover[j]]);\n-\t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-\t    if (cl == ira_reg_class_cover[j]\n-\t\t|| (hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2)\n-\t\t    && ! hard_reg_set_equal_p (temp_hard_regset,\n-\t\t\t\t\t       temp_hard_regset2)))\n-\t      {\n-\t\tira_important_class_nums[cl] = ira_important_classes_num;\n-\t\tira_important_classes[ira_important_classes_num++] = cl;\n-\t      }\n-\t  }\n+\t{\n+\t  set_p = eq_p = false;\n+\t  for (j = 0; j < ira_reg_class_cover_size; j++)\n+\t    {\n+\t      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t      COPY_HARD_REG_SET (temp_hard_regset2,\n+\t\t\t\t reg_class_contents[ira_reg_class_cover[j]]);\n+\t      AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t      if (cl == ira_reg_class_cover[j])\n+\t\t{\n+\t\t  eq_p = false;\n+\t\t  set_p = true;\n+\t\t  break;\n+\t\t}\n+\t      else if (hard_reg_set_equal_p (temp_hard_regset,\n+\t\t\t\t\t     temp_hard_regset2))\n+\t\teq_p = true;\n+\t      else if (hard_reg_set_subset_p (temp_hard_regset,\n+\t\t\t\t\t      temp_hard_regset2))\n+\t\tset_p = true;\n+\t    }\n+\t  if (set_p && ! eq_p)\n+\t    {\n+\t      ira_important_class_nums[cl] = ira_important_classes_num;\n+\t      ira_important_classes[ira_important_classes_num++] = cl;\n+\t    }\n+\t}\n     }\n }\n \n@@ -776,25 +840,44 @@ setup_class_translate (void)\n \n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     ira_class_translate[cl] = NO_REGS;\n+  \n+  if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n+    for (cl = 0; cl < LIM_REG_CLASSES; cl++)\n+      {\n+\tCOPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\tfor (i = 0; i < ira_reg_class_cover_size; i++)\n+\t  {\n+\t    HARD_REG_SET temp_hard_regset2;\n+\t    \n+\t    cover_class = ira_reg_class_cover[i];\n+\t    COPY_HARD_REG_SET (temp_hard_regset2,\n+\t\t\t       reg_class_contents[cover_class]);\n+\t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n+\t    if (hard_reg_set_equal_p (temp_hard_regset, temp_hard_regset2))\n+\t      ira_class_translate[cl] = cover_class;\n+\t  }\n+      }\n   for (i = 0; i < ira_reg_class_cover_size; i++)\n     {\n       cover_class = ira_reg_class_cover[i];\n-      for (cl_ptr = &alloc_reg_class_subclasses[cover_class][0];\n-\t   (cl = *cl_ptr) != LIM_REG_CLASSES;\n-\t   cl_ptr++)\n-\t{\n-\t  if (ira_class_translate[cl] == NO_REGS)\n-\t    ira_class_translate[cl] = cover_class;\n+      if (flag_ira_algorithm != IRA_ALGORITHM_PRIORITY)\n+\tfor (cl_ptr = &alloc_reg_class_subclasses[cover_class][0];\n+\t     (cl = *cl_ptr) != LIM_REG_CLASSES;\n+\t     cl_ptr++)\n+\t  {\n+\t    if (ira_class_translate[cl] == NO_REGS)\n+\t      ira_class_translate[cl] = cover_class;\n #ifdef ENABLE_IRA_CHECKING\n-\t  else\n-\t    {\n-\t      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-\t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t      if (! hard_reg_set_empty_p (temp_hard_regset))\n-\t\tgcc_unreachable ();\n-\t    }\n+\t    else\n+\t      {\n+\t\tCOPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t\tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t\tif (! hard_reg_set_empty_p (temp_hard_regset))\n+\t\t  gcc_unreachable ();\n+\t      }\n #endif\n-\t}\n+\t  }\n       ira_class_translate[cover_class] = cover_class;\n     }\n   /* For classes which are not fully covered by a cover class (in\n@@ -842,6 +925,17 @@ setup_class_translate (void)\n    account.  */\n enum reg_class ira_reg_class_intersect[N_REG_CLASSES][N_REG_CLASSES];\n \n+/* True if the two classes (that is calculated taking only hard\n+   registers available for allocation into account) are\n+   intersected.  */\n+bool ira_reg_classes_intersect_p[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* Important classes with end marker LIM_REG_CLASSES which are\n+   supersets with given important class (the first index).  That\n+   includes given class itself.  This is calculated taking only hard\n+   registers available for allocation into account.  */\n+enum reg_class ira_reg_class_super_classes[N_REG_CLASSES][N_REG_CLASSES];\n+\n /* The biggest important reg_class inside of union of the two\n    reg_classes (that is calculated taking only hard registers\n    available for allocation into account).  If the both reg_classes\n@@ -851,17 +945,23 @@ enum reg_class ira_reg_class_intersect[N_REG_CLASSES][N_REG_CLASSES];\n    reg_class_subunion value.  */\n enum reg_class ira_reg_class_union[N_REG_CLASSES][N_REG_CLASSES];\n \n-/* Set up IRA_REG_CLASS_INTERSECT and IRA_REG_CLASS_UNION.  */\n+/* Set up the above reg class relations.  */\n static void\n-setup_reg_class_intersect_union (void)\n+setup_reg_class_relations (void)\n {\n   int i, cl1, cl2, cl3;\n   HARD_REG_SET intersection_set, union_set, temp_set2;\n+  bool important_class_p[N_REG_CLASSES];\n \n+  memset (important_class_p, 0, sizeof (important_class_p));\n+  for (i = 0; i < ira_important_classes_num; i++)\n+    important_class_p[ira_important_classes[i]] = true;\n   for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n     {\n+      ira_reg_class_super_classes[cl1][0] = LIM_REG_CLASSES;\n       for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n \t{\n+\t  ira_reg_classes_intersect_p[cl1][cl2] = false;\n \t  ira_reg_class_intersect[cl1][cl2] = NO_REGS;\n \t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl1]);\n \t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n@@ -882,6 +982,19 @@ setup_reg_class_intersect_union (void)\n \t      ira_reg_class_union[cl1][cl2] = reg_class_subunion[cl1][cl2];\n \t      continue;\n \t    }\n+\t  ira_reg_classes_intersect_p[cl1][cl2]\n+\t    = hard_reg_set_intersect_p (temp_hard_regset, temp_set2);\n+\t  if (important_class_p[cl1] && important_class_p[cl2]\n+\t      && hard_reg_set_subset_p (temp_hard_regset, temp_set2))\n+\t    {\n+\t      enum reg_class *p;\n+\n+\t      p = &ira_reg_class_super_classes[cl1][0];\n+\t      while (*p != LIM_REG_CLASSES)\n+\t\tp++;\n+\t      *p++ = (enum reg_class) cl2;\n+\t      *p = LIM_REG_CLASSES;\n+\t    }\n \t  ira_reg_class_union[cl1][cl2] = NO_REGS;\n \t  COPY_HARD_REG_SET (intersection_set, reg_class_contents[cl1]);\n \t  AND_HARD_REG_SET (intersection_set, reg_class_contents[cl2]);\n@@ -966,12 +1079,9 @@ static void\n find_reg_class_closure (void)\n {\n   setup_reg_subclasses ();\n-  if (targetm.ira_cover_classes)\n-    {\n-      setup_cover_and_important_classes ();\n-      setup_class_translate ();\n-      setup_reg_class_intersect_union ();\n-    }\n+  setup_cover_and_important_classes ();\n+  setup_class_translate ();\n+  setup_reg_class_relations ();\n }\n \n \f\n@@ -1804,8 +1914,8 @@ ira (FILE *f)\n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"Building IRA IR\\n\");\n   loops_p = ira_build (optimize\n-\t\t       && (flag_ira_algorithm == IRA_ALGORITHM_REGIONAL\n-\t\t\t   || flag_ira_algorithm == IRA_ALGORITHM_MIXED));\n+\t\t       && (flag_ira_region == IRA_REGION_ALL\n+\t\t\t   || flag_ira_region == IRA_REGION_MIXED));\n \n   saved_flag_ira_share_spill_slots = flag_ira_share_spill_slots;\n   if (too_high_register_pressure_p ())"}, {"sha": "42e3beeb9267bd27a7c02ca0850e3af06778ad2c", "filename": "gcc/opts.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -870,9 +870,11 @@ decode_options (unsigned int argc, const char **argv)\n \t}\n     }\n   \n-  /* Use IRA if it is implemented for the target.  */\n-  if (targetm.ira_cover_classes)\n-    flag_ira = 1;\n+  flag_ira = 1;\n+  /* Use priority coloring if cover classes is not defined for the\n+     target.  */\n+  if (targetm.ira_cover_classes == NULL)\n+    flag_ira_algorithm = IRA_ALGORITHM_PRIORITY;\n \n   /* -O1 optimizations.  */\n   opt1 = (optimize >= 1);\n@@ -1096,10 +1098,12 @@ decode_options (unsigned int argc, const char **argv)\n   if (!flag_sel_sched_pipelining)\n     flag_sel_sched_pipelining_outer_loops = 0;\n \n-  if (flag_ira && !targetm.ira_cover_classes)\n+  if (flag_ira && !targetm.ira_cover_classes\n+      && flag_ira_algorithm == IRA_ALGORITHM_CB)\n     {\n-      inform (input_location, \"-fira does not work on this architecture\");\n-      flag_ira = 0;\n+      inform (input_location,\n+\t      \"-fira-algorithm=CB does not work on this architecture\");\n+      flag_ira_algorithm = IRA_ALGORITHM_PRIORITY;\n     }\n \n   /* Save the current optimization options if this is the first call.  */\n@@ -1976,16 +1980,25 @@ common_handle_option (size_t scode, const char *arg, int value,\n       break;\n \n     case OPT_fira_algorithm_:\n-      if (!strcmp (arg, \"regional\"))\n-\tflag_ira_algorithm = IRA_ALGORITHM_REGIONAL;\n-      else if (!strcmp (arg, \"CB\"))\n+      if (!strcmp (arg, \"CB\"))\n \tflag_ira_algorithm = IRA_ALGORITHM_CB;\n-      else if (!strcmp (arg, \"mixed\"))\n-\tflag_ira_algorithm = IRA_ALGORITHM_MIXED;\n+      else if (!strcmp (arg, \"priority\"))\n+\tflag_ira_algorithm = IRA_ALGORITHM_PRIORITY;\n       else\n \twarning (0, \"unknown ira algorithm \\\"%s\\\"\", arg);\n       break;\n \n+    case OPT_fira_region_:\n+      if (!strcmp (arg, \"one\"))\n+\tflag_ira_region = IRA_REGION_ONE;\n+      else if (!strcmp (arg, \"all\"))\n+\tflag_ira_region = IRA_REGION_ALL;\n+      else if (!strcmp (arg, \"mixed\"))\n+\tflag_ira_region = IRA_REGION_MIXED;\n+      else\n+\twarning (0, \"unknown ira region \\\"%s\\\"\", arg);\n+      break;\n+\n     case OPT_fira_verbose_:\n       flag_ira_verbose = value;\n       break;"}, {"sha": "ffde2bf94d821c7e6573a54eb5952d1ea1324b8e", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -6084,9 +6084,10 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t    need_mode = mode;\n \t\t  else\n \t\t    need_mode\n-\t\t      = smallest_mode_for_size (GET_MODE_BITSIZE (mode)\n-\t\t\t\t\t\t+ byte * BITS_PER_UNIT,\n-\t\t\t\t\t\tGET_MODE_CLASS (mode));\n+\t\t      = smallest_mode_for_size\n+\t\t        (GET_MODE_BITSIZE (mode) + byte * BITS_PER_UNIT,\n+\t\t\t GET_MODE_CLASS (mode) == MODE_PARTIAL_INT\n+\t\t\t ? MODE_INT : GET_MODE_CLASS (mode));\n \n \t\t  if ((GET_MODE_SIZE (GET_MODE (last_reg))\n \t\t       >= GET_MODE_SIZE (need_mode))"}, {"sha": "8417cfed6cbe29f917f0a3f2d57a17fbc8835d58", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7db7ed3cbd2dbf17be73f254944c28d72de19ca9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=7db7ed3cbd2dbf17be73f254944c28d72de19ca9", "patch": "@@ -271,9 +271,11 @@ int flag_next_runtime = 0;\n \n enum tls_model flag_tls_default = TLS_MODEL_GLOBAL_DYNAMIC;\n \n-/* Set the default algorithm for the integrated register allocator.  */\n+/* Set the default region and algorithm for the integrated register\n+   allocator.  */\n \n-enum ira_algorithm flag_ira_algorithm = IRA_ALGORITHM_MIXED;\n+enum ira_algorithm flag_ira_algorithm = IRA_ALGORITHM_CB;\n+enum ira_region flag_ira_region = IRA_REGION_MIXED;\n \n /* Set the default value for -fira-verbose.  */\n "}]}