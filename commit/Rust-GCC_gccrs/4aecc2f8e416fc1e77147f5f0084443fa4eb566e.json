{"sha": "4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFlY2MyZjhlNDE2ZmMxZTc3MTQ3ZjVmMDA4NDQ0M2ZhNGViNTY2ZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-05-18T21:02:59Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-05-18T21:02:59Z"}, "message": "decl.c (change_qualified_type): New static function.\n\n\t* gcc-interface/decl.c (change_qualified_type): New static function.\n\t(gnat_to_gnu_entity): Use it throughout to add qualifiers on types.\n\t<E_Array_Type>: Set TYPE_VOLATILE on the array type directly.\n\t<E_Array_Subtype>: Likewise.\n\tDo not set flags on an UNCONSTRAINED_ARRAY_TYPE directly.\n\t(gnat_to_gnu_component_type): Likewise.\n\t(gnat_to_gnu_param): Likewise.\n\nFrom-SVN: r210588", "tree": {"sha": "4055a929917460b23b15b54f79d110c7118953cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4055a929917460b23b15b54f79d110c7118953cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/comments", "author": null, "committer": null, "parents": [{"sha": "08b8b90cff5b5626b2a240a18e63e917e2e19a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b8b90cff5b5626b2a240a18e63e917e2e19a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b8b90cff5b5626b2a240a18e63e917e2e19a20"}], "stats": {"total": 125, "additions": 76, "deletions": 49}, "files": [{"sha": "c29b5ad0ff7ce09f136e3acb2fc513efcc8d86a7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "patch": "@@ -1,3 +1,13 @@\n+2014-05-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (change_qualified_type): New static function.\n+\t(gnat_to_gnu_entity): Use it throughout to add qualifiers on types.\n+\t<E_Array_Type>: Set TYPE_VOLATILE on the array type directly.\n+\t<E_Array_Subtype>: Likewise.\n+\tDo not set flags on an UNCONSTRAINED_ARRAY_TYPE directly.\n+\t(gnat_to_gnu_component_type): Likewise.\n+\t(gnat_to_gnu_param): Likewise.\n+\n 2014-05-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* fe.h (Set_Present_Expr): Move around."}, {"sha": "d448430e466df641f723888b762f3b78704793bc", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "patch": "@@ -145,6 +145,7 @@ static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);\n+static tree change_qualified_type (tree, int);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (tree, Entity_Id);\n static bool compile_time_known_address_p (Node_Id);\n@@ -1047,9 +1048,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   Note that we need to preserve the volatility of the renamed\n \t\t   object through the indirection.  */\n \t\tif (TREE_THIS_VOLATILE (gnu_expr) && !TYPE_VOLATILE (gnu_type))\n-\t\t  gnu_type = build_qualified_type (gnu_type,\n-\t\t\t\t\t\t   (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t\t    | TYPE_QUAL_VOLATILE));\n+\t\t  gnu_type\n+\t\t    = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \t\tgnu_type = build_reference_type (gnu_type);\n \t\tinner_const_flag = TREE_READONLY (gnu_expr);\n \t\tconst_flag = true;\n@@ -1107,9 +1107,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     || imported_p\n \t\t     || Present (Address_Clause (gnat_entity)))))\n \t    && !TYPE_VOLATILE (gnu_type))\n-\t  gnu_type = build_qualified_type (gnu_type,\n-\t\t\t\t\t   (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t    | TYPE_QUAL_VOLATILE));\n+\t  gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \n \t/* If we are defining an aliased object whose nominal subtype is\n \t   unconstrained, the object is a record that contains both the\n@@ -1408,8 +1406,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \tif (const_flag)\n-\t  gnu_type = build_qualified_type (gnu_type, (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t\t      | TYPE_QUAL_CONST));\n+\t  gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_CONST);\n \n \t/* Convert the expression to the type of the object except in the\n \t   case where the object's type is unconstrained or the object's type\n@@ -2243,6 +2240,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      SET_TYPE_MODE (tem, BLKmode);\n \t  }\n \n+\tTYPE_VOLATILE (tem) = Treat_As_Volatile (gnat_entity);\n+\n \t/* If an alignment is specified, use it if valid.  But ignore it\n \t   for the original type of packed array types.  If the alignment\n \t   was requested with an explicit alignment clause, state so.  */\n@@ -2595,6 +2594,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tSET_TYPE_MODE (gnu_type, BLKmode);\n \t    }\n \n+\t  TYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n+\n \t  /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n \t  TYPE_STUB_DECL (gnu_type)\n \t    = create_type_stub_decl (gnu_entity_name, gnu_type);\n@@ -2725,9 +2726,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \t      if (Treat_As_Volatile (gnat_entity))\n \t\tgnu_type\n-\t\t  = build_qualified_type (gnu_type,\n-\t\t\t\t\t  TYPE_QUALS (gnu_type)\n-\t\t\t\t\t  | TYPE_QUAL_VOLATILE);\n+\t\t  = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \t      /* Make it artificial only if the base type was artificial too.\n \t\t That's sort of \"morally\" true and will make it possible for\n \t\t the debugger to look it up by name in DWARF, which is needed\n@@ -3218,9 +3217,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && Is_By_Reference_Type (gnat_entity))\n \t  SET_TYPE_MODE (gnu_type, BLKmode);\n \n-\t/* We used to remove the associations of the discriminants and _Parent\n-\t   for validity checking but we may need them if there's a Freeze_Node\n-\t   for a subtype used in this record.  */\n \tTYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n \n \t/* Fill in locations of fields.  */\n@@ -3917,9 +3913,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t&& TREE_CODE (gnu_desig_type) != UNCONSTRAINED_ARRAY_TYPE)\n \t      {\n \t\tgnu_desig_type\n-\t\t  = build_qualified_type\n-\t\t    (gnu_desig_type,\n-\t\t     TYPE_QUALS (gnu_desig_type) | TYPE_QUAL_CONST);\n+\t\t  = change_qualified_type (gnu_desig_type, TYPE_QUAL_CONST);\n \n \t\t/* Some extra processing is required if we are building a\n \t\t   pointer to an incomplete type (in the GCC sense).  We might\n@@ -4623,18 +4617,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (TREE_CODE (gnu_return_type) == VOID_TYPE)\n \t  const_flag = false;\n \n-\tgnu_type\n-\t  = build_qualified_type (gnu_type,\n-\t\t\t\t  TYPE_QUALS (gnu_type)\n-\t\t\t\t  | (TYPE_QUAL_CONST * const_flag)\n-\t\t\t\t  | (TYPE_QUAL_VOLATILE * volatile_flag));\n+\tif (const_flag || volatile_flag)\n+\t  {\n+\t    const int quals\n+\t      = (const_flag ? TYPE_QUAL_CONST : 0)\n+\t\t| (volatile_flag ? TYPE_QUAL_VOLATILE : 0);\n \n-\tif (has_stub)\n-\t  gnu_stub_type\n-\t    = build_qualified_type (gnu_stub_type,\n-\t\t\t\t    TYPE_QUALS (gnu_stub_type)\n-\t\t\t\t    | (TYPE_QUAL_CONST * const_flag)\n-\t\t\t\t    | (TYPE_QUAL_VOLATILE * volatile_flag));\n+\t    gnu_type = change_qualified_type (gnu_type, quals);\n+\n+\t    if (has_stub)\n+\t      gnu_stub_type = change_qualified_type (gnu_stub_type, quals);\n+\t  }\n \n \t/* If we have a builtin decl for that function, use it.  Check if the\n \t   profiles are compatible and warn if they are not.  The checker is\n@@ -4900,8 +4893,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_size = NULL_TREE;\n \t}\n \n-      /* If the alignment hasn't already been processed and this is\n-\t not an unconstrained array, see if an alignment is specified.\n+      /* If the alignment has not already been processed and this is not\n+\t an unconstrained array type, see if an alignment is specified.\n \t If not, we pick a default alignment for atomic objects.  */\n       if (align != 0 || TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE)\n \t;\n@@ -5088,19 +5081,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t}\n \t    }\n \n-      if (Treat_As_Volatile (gnat_entity))\n-\tgnu_type\n-\t  = build_qualified_type (gnu_type,\n-\t\t\t\t  TYPE_QUALS (gnu_type) | TYPE_QUAL_VOLATILE);\n-\n       if (Is_Atomic (gnat_entity))\n \tcheck_ok_for_atomic (gnu_type, gnat_entity, false);\n \n-      if (Present (Alignment_Clause (gnat_entity)))\n-\tTYPE_USER_ALIGN (gnu_type) = 1;\n+      /* If this is not an unconstrained array type, set some flags.  */\n+      if (TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE)\n+\t{\n+\t  if (Treat_As_Volatile (gnat_entity))\n+\t    gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \n-      if (Universal_Aliasing (gnat_entity))\n-\tTYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (gnu_type)) = 1;\n+\t  if (Present (Alignment_Clause (gnat_entity)))\n+\t    TYPE_USER_ALIGN (gnu_type) = 1;\n+\n+\t  if (Universal_Aliasing (gnat_entity))\n+\t    TYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (gnu_type)) = 1;\n+\t}\n \n       if (!gnu_decl)\n \tgnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n@@ -5648,9 +5643,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n     }\n \n   if (Has_Volatile_Components (gnat_array))\n-    gnu_type\n-      = build_qualified_type (gnu_type,\n-\t\t\t      TYPE_QUALS (gnu_type) | TYPE_QUAL_VOLATILE);\n+    gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \n   return gnu_type;\n }\n@@ -5708,9 +5701,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   if (ro_param\n       && TREE_CODE (gnu_param_type) != UNCONSTRAINED_ARRAY_TYPE\n       && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_param_type)))\n-    gnu_param_type = build_qualified_type (gnu_param_type,\n-\t\t\t\t\t   (TYPE_QUALS (gnu_param_type)\n-\t\t\t\t\t    | TYPE_QUAL_CONST));\n+    gnu_param_type = change_qualified_type (gnu_param_type, TYPE_QUAL_CONST);\n \n   /* For foreign conventions, pass arrays as pointers to the element type.\n      First check for unconstrained array and get the underlying array.  */\n@@ -5760,9 +5751,8 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n       gnu_param_type = TREE_TYPE (gnu_param_type);\n \n       if (ro_param)\n-\tgnu_param_type = build_qualified_type (gnu_param_type,\n-\t\t\t\t\t       (TYPE_QUALS (gnu_param_type)\n-\t\t\t\t\t\t| TYPE_QUAL_CONST));\n+\tgnu_param_type\n+\t  = change_qualified_type (gnu_param_type, TYPE_QUAL_CONST);\n \n       gnu_param_type = build_pointer_type (gnu_param_type);\n     }\n@@ -5799,7 +5789,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n       gnu_param_type = build_reference_type (gnu_param_type);\n       if (restrict_p)\n \tgnu_param_type\n-\t  = build_qualified_type (gnu_param_type, TYPE_QUAL_RESTRICT);\n+\t  = change_qualified_type (gnu_param_type, TYPE_QUAL_RESTRICT);\n       by_ref = true;\n     }\n \n@@ -5865,6 +5855,15 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   return gnu_param;\n }\n \n+/* Like build_qualified_type, but TYPE_QUALS is added to the existing\n+   qualifiers on TYPE.  */\n+\n+static tree\n+change_qualified_type (tree type, int type_quals)\n+{\n+  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);\n+}\n+\n /* Return true if DISCR1 and DISCR2 represent the same discriminant.  */\n \n static bool"}, {"sha": "fcb47f4ed3fb9b8248ccc88143160e25476689ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "patch": "@@ -1,3 +1,7 @@\n+2014-05-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/volatile12.ad[sb]: New test.\n+\n 2014-05-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/enum3.adb: New test."}, {"sha": "91f3831ecde865ecd0e619483403c52518c726c8", "filename": "gcc/testsuite/gnat.dg/volatile12.adb", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile12.adb?ref=4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "patch": "@@ -0,0 +1,7 @@\n+-- { dg-do compile }\n+\n+package body Volatile12 is\n+\n+   procedure Proc (A : Arr) is begin null; end;\n+\n+end Volatile12;"}, {"sha": "c37d249aa0ac2cd29125082b36da44e667a4171e", "filename": "gcc/testsuite/gnat.dg/volatile12.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aecc2f8e416fc1e77147f5f0084443fa4eb566e/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvolatile12.ads?ref=4aecc2f8e416fc1e77147f5f0084443fa4eb566e", "patch": "@@ -0,0 +1,7 @@\n+package Volatile12 is\n+\n+   type Arr is array (Integer range <>) of Integer with Volatile;\n+\n+   procedure Proc (A : Arr);\n+\n+end Volatile12;"}]}