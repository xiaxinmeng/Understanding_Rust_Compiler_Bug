{"sha": "1a09197cb1bc05a71d1866d1220937289da02c5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEwOTE5N2NiMWJjMDVhNzFkMTg2NmQxMjIwOTM3Mjg5ZGEwMmM1ZQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2019-09-23T17:37:54Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2019-09-23T17:37:54Z"}, "message": "PR c++/91844 - Implement CWG 2352, Similar types and reference binding.\n\n\t* call.c (reference_related_p): Use similar_type_p instead of\n\tsame_type_p.\n\t(reference_compatible_p): Update implementation to match CWG 2352.\n\t* cp-tree.h (similar_type_p): Declare.\n\t* typeck.c (similar_type_p): New.\n\n\t* g++.dg/cpp0x/pr33930.C: Add dg-error.\n\t* g++.dg/cpp0x/ref-bind1.C: New test.\n\t* g++.dg/cpp0x/ref-bind2.C: New test.\n\t* g++.dg/cpp0x/ref-bind3.C: New test.\n\t* g++.old-deja/g++.pt/spec35.C: Remove dg-error.\n\nFrom-SVN: r276058", "tree": {"sha": "aefb9cfa8c4542ee2235dc93fa2107880eaf40b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aefb9cfa8c4542ee2235dc93fa2107880eaf40b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a09197cb1bc05a71d1866d1220937289da02c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a09197cb1bc05a71d1866d1220937289da02c5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a09197cb1bc05a71d1866d1220937289da02c5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a09197cb1bc05a71d1866d1220937289da02c5e/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba2b30dc9fa9190101b3eb7ae10415b54ca25e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba2b30dc9fa9190101b3eb7ae10415b54ca25e7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba2b30dc9fa9190101b3eb7ae10415b54ca25e7a"}], "stats": {"total": 159, "additions": 143, "deletions": 16}, "files": [{"sha": "7ccc7cddf51c53f5eb5b401bc3139f096ad0fc7a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -1,3 +1,12 @@\n+2019-09-23  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/91844 - Implement CWG 2352, Similar types and reference binding.\n+\t* call.c (reference_related_p): Use similar_type_p instead of\n+\tsame_type_p.\n+\t(reference_compatible_p): Update implementation to match CWG 2352.\n+\t* cp-tree.h (similar_type_p): Declare.\n+\t* typeck.c (similar_type_p): New.\n+\n 2019-09-22  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/91819 - ICE with operator++ and enum."}, {"sha": "28b3f332b5daa0a54637f5779d917f353f14146b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -1530,9 +1530,8 @@ reference_related_p (tree t1, tree t2)\n   /* [dcl.init.ref]\n \n      Given types \"cv1 T1\" and \"cv2 T2,\" \"cv1 T1\" is reference-related\n-     to \"cv2 T2\" if T1 is the same type as T2, or T1 is a base class\n-     of T2.  */\n-  return (same_type_p (t1, t2)\n+     to \"cv2 T2\" if T1 is similar to T2, or T1 is a base class of T2.  */\n+  return (similar_type_p (t1, t2)\n \t  || (CLASS_TYPE_P (t1) && CLASS_TYPE_P (t2)\n \t      && DERIVED_FROM_P (t1, t2)));\n }\n@@ -1545,14 +1544,15 @@ reference_compatible_p (tree t1, tree t2)\n   /* [dcl.init.ref]\n \n      \"cv1 T1\" is reference compatible with \"cv2 T2\" if\n-       * T1 is reference-related to T2 or\n-       * T2 is \"noexcept function\" and T1 is \"function\", where the\n-         function types are otherwise the same,\n-     and cv1 is the same cv-qualification as, or greater cv-qualification\n-     than, cv2.  */\n-  return ((reference_related_p (t1, t2)\n-\t   || fnptr_conv_p (t1, t2))\n-\t  && at_least_as_qualified_p (t1, t2));\n+     a prvalue of type \"pointer to cv2 T2\" can be converted to the type\n+     \"pointer to cv1 T1\" via a standard conversion sequence.  */\n+  tree ptype1 = build_pointer_type (t1);\n+  tree ptype2 = build_pointer_type (t2);\n+  conversion *conv = standard_conversion (ptype1, ptype2, NULL_TREE,\n+\t\t\t\t\t  /*c_cast_p=*/false, 0, tf_none);\n+  if (!conv || conv->bad_p)\n+    return false;\n+  return true;\n }\n \n /* A reference of the indicated TYPE is being bound directly to the"}, {"sha": "9c0f3949c685fb989ae37451f01e2fcf169ee057", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -7361,6 +7361,7 @@ enum { ce_derived, ce_type, ce_normal, ce_exact };\n extern bool comp_except_specs\t\t\t(const_tree, const_tree, int);\n extern bool comptypes\t\t\t\t(tree, tree, int);\n extern bool same_type_ignoring_top_level_qualifiers_p (tree, tree);\n+extern bool similar_type_p\t\t\t(tree, tree);\n extern bool compparms\t\t\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(int, int);"}, {"sha": "f427c4f4d3e464b1270adce8cb0523cc8c8b41ac", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -1530,6 +1530,33 @@ same_type_ignoring_top_level_qualifiers_p (tree type1, tree type2)\n   return same_type_p (type1, type2);\n }\n \n+/* Returns nonzero iff TYPE1 and TYPE2 are similar, as per [conv.qual].  */\n+\n+bool\n+similar_type_p (tree type1, tree type2)\n+{\n+  if (type1 == error_mark_node || type2 == error_mark_node)\n+    return false;\n+\n+  /* Informally, two types are similar if, ignoring top-level cv-qualification:\n+     * they are the same type; or\n+     * they are both pointers, and the pointed-to types are similar; or\n+     * they are both pointers to member of the same class, and the types of\n+       the pointed-to members are similar; or\n+     * they are both arrays of the same size or both arrays of unknown bound,\n+       and the array element types are similar.  */\n+\n+  if (same_type_ignoring_top_level_qualifiers_p (type1, type2))\n+    return true;\n+\n+  /* FIXME This ought to handle ARRAY_TYPEs too.  */\n+  if ((TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n+      || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2)))\n+    return comp_ptr_ttypes_const (type1, type2);\n+\n+  return false;\n+}\n+\n /* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */\n \n bool"}, {"sha": "f381bb24f762ebece72e9256960294423a244728", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -1,3 +1,12 @@\n+2019-09-23  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/91844 - Implement CWG 2352, Similar types and reference binding.\n+\t* g++.dg/cpp0x/pr33930.C: Add dg-error.\n+\t* g++.dg/cpp0x/ref-bind1.C: New test.\n+\t* g++.dg/cpp0x/ref-bind2.C: New test.\n+\t* g++.dg/cpp0x/ref-bind3.C: New test.\n+\t* g++.old-deja/g++.pt/spec35.C: Remove dg-error.\n+\n 2019-09-23  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.dg/ucnid-5-utf8.c: Skip unless ucn is supported."}, {"sha": "ba5b4b943c81a97e521f04631d75fead2d8a85ca", "filename": "gcc/testsuite/g++.dg/cpp0x/pr33930.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr33930.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr33930.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr33930.C?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -6,5 +6,5 @@ int& foo( type&& ggg );\n \n void bar( int* someptr )\n {\n-  int& x = foo( someptr );\n+  int& x = foo( someptr ); // { dg-error \"cannot bind non-const lvalue reference\" }\n }"}, {"sha": "af6140a1f440b90aba8e33000e9974b32a83091e", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-bind1.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind1.C?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -0,0 +1,44 @@\n+// PR c++/91844 - Implement CWG 2352, Similar types and reference binding.\n+// { dg-do compile { target c++11 } }\n+\n+// These should bind directly to ptr, so no -Wreturn-local-addr warnings.\n+int *ptr;\n+\n+const int *const &\n+fn1 ()\n+{\n+  return ptr;\n+}\n+\n+int **const ptr2 = nullptr;\n+const int *const *const &\n+fn2 ()\n+{\n+  return ptr2;\n+}\n+\n+int (*ptr3)[10];\n+using T = const int (*const)[10];\n+\n+T&\n+fn3 ()\n+{\n+  return ptr3;\n+}\n+\n+int (**ptr4)[5] = nullptr;\n+using T2 = const int (*const *const)[5];\n+\n+T2&\n+fn4 ()\n+{\n+  return ptr4;\n+}\n+\n+const int **ptr5 = nullptr;\n+\n+const int *const *const &\n+fn5 ()\n+{\n+  return ptr5;\n+}"}, {"sha": "967c59e06fd685a6d46167a0f3f1b05379ae8d8a", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-bind2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind2.C?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/91844 - Implement CWG 2352, Similar types and reference binding.\n+// { dg-do compile { target c++11 } }\n+\n+// \"const int *\" and \"int *\" are reference-related, and 5.4.4.\n+// says that in that case, if the reference is an rvalue reference,\n+// the initializer expression shall not be an lvalue.\n+\n+int &f (const int *&&);\n+\n+void\n+fn (int *p)\n+{\n+  const int *&&r = p; // { dg-error \"cannot bind rvalue reference\" }\n+  f (p); // { dg-error \"cannot bind rvalue reference\" }\n+}"}, {"sha": "16e1bfe6cccc6f7495bd64a54ccbd9ebc8ace86f", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-bind3.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-bind3.C?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/91844 - Implement CWG 2352, Similar types and reference binding.\n+// { dg-do compile { target c++11 } }\n+\n+template<typename T> int f (const T *const &); // (1)\n+template<typename T> int f (T *const &); // (2)\n+template<typename T> int f (T *); // (3)\n+\n+/* Before CWG 2352, (2) was a better match than (1), but (2) and (3) were\n+   equally good, so there was an ambiguity.  (2) was better than (1) because\n+   (1) required a qualification conversion whereas (2) didn't.  But with this\n+   CWG, (1) no longer requires a qualification conversion, because the types\n+   \"const int* const\" and \"int *\" are now considered reference-related and we\n+   bind directly, and (1) is more specialized than (2).  And (1) is also a\n+   better match than (3).  */\n+\n+void\n+g (int *p, const int *q, const int *const r)\n+{\n+  f (p); // calls (1)\n+  f (q); // calls (1)\n+  f (r); // calls (1)\n+}"}, {"sha": "93e953df7e7e0b15e3ec57cdb71a2ecde5e52c0d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec35.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a09197cb1bc05a71d1866d1220937289da02c5e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec35.C?ref=1a09197cb1bc05a71d1866d1220937289da02c5e", "patch": "@@ -14,17 +14,17 @@ template <typename T> int Foo (T &);  // { dg-message \"note\" } candidate\n template <typename T> int Qux (T);    // { dg-message \"note\" } \n template <typename T> int Qux (T const &);  // { dg-message \"note\" } candidate\n \n-template <typename T> int Bar (T const *const &); // { dg-message \"note\" } \n-template <typename T> int Bar (T *const &);       // { dg-message \"note\" } candidate\n-template <typename T> int Bar (T *);              // { dg-message \"note\" } candidate\n+template <typename T> int Bar (T const *const &);\n+template <typename T> int Bar (T *const &);\n+template <typename T> int Bar (T *);\n \n template <typename T> int Baz (T *const &);       // { dg-message \"note\" } \n template <typename T> int Baz (T *);              // { dg-message \"note\" } candidate\n \n int Baz (int const *ptr, int *ptr2)\n {\n   Baz (ptr2);   // { dg-error \"ambiguous\" } \n-  Bar (ptr2);   // { dg-error \"ambiguous\" } \n+  Bar (ptr2);\n   Foo (ptr2);   // { dg-error \"ambiguous\" } \n   Qux (ptr2);   // { dg-error \"ambiguous\" } \n   return 0;"}]}