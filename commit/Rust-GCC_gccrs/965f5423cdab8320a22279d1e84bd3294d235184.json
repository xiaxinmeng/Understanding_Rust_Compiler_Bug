{"sha": "965f5423cdab8320a22279d1e84bd3294d235184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY1ZjU0MjNjZGFiODMyMGEyMjI3OWQxZTg0YmQzMjk0ZDIzNTE4NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-12-14T11:20:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-14T11:20:27Z"}, "message": "i386.c (ix86_fpmath, [...]): New.\n\nFri Dec 14 12:05:14 CET 2001  Jan Hubicka  <jh@suse.cz>\n\n\t* i386.c (ix86_fpmath, ix86_fpmath_string): New.\n\t(override_option): Set ix86_fpmath.\n\t* i386.h (MASK_MIX_SSE_I387): Remove.\n\t(TARGET_SSE_MATH): New.\n\t(TARGET_MIX_SSE_I387): Use ix86_fpmath.\n\t(TARGET_SWITCHES): Remove \"mix-sse-i387\".\n\t(fpmath_unit): New enum.\n\t(ix86_fpmath, ix86_fpmath_string): Declare.\n\t* i386.md (swapsf): Fix condition.\n\t(add?f, sub?f, mul?f, div?f, sqrt?f, min?f): Use TARGET_SSE_MATH.\n\t(fp_?f_*_nosse): New.\n\t(fp_*): Use TARGET_SSE_MATH.\n\t* invoke.texi (-mfpmath): Document.\n\t(-msse2): Add.\n\nFrom-SVN: r47999", "tree": {"sha": "1d2e0ade9803c9559e66c4185f49776d5660b896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d2e0ade9803c9559e66c4185f49776d5660b896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/965f5423cdab8320a22279d1e84bd3294d235184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965f5423cdab8320a22279d1e84bd3294d235184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/965f5423cdab8320a22279d1e84bd3294d235184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965f5423cdab8320a22279d1e84bd3294d235184/comments", "author": null, "committer": null, "parents": [{"sha": "009c32817af8cfcdef68d05da04a930c448dd4f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009c32817af8cfcdef68d05da04a930c448dd4f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/009c32817af8cfcdef68d05da04a930c448dd4f3"}], "stats": {"total": 270, "additions": 223, "deletions": 47}, "files": [{"sha": "71453bb12680569485eec9e532ecea4c86ec2cb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=965f5423cdab8320a22279d1e84bd3294d235184", "patch": "@@ -1,3 +1,20 @@\n+Fri Dec 14 12:05:14 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_fpmath, ix86_fpmath_string): New.\n+\t(override_option): Set ix86_fpmath.\n+\t* i386.h (MASK_MIX_SSE_I387): Remove.\n+\t(TARGET_SSE_MATH): New.\n+\t(TARGET_MIX_SSE_I387): Use ix86_fpmath.\n+\t(TARGET_SWITCHES): Remove \"mix-sse-i387\".\n+\t(fpmath_unit): New enum.\n+\t(ix86_fpmath, ix86_fpmath_string): Declare.\n+\t* i386.md (swapsf): Fix condition.\n+\t(add?f, sub?f, mul?f, div?f, sqrt?f, min?f): Use TARGET_SSE_MATH.\n+\t(fp_?f_*_nosse): New.\n+\t(fp_*): Use TARGET_SSE_MATH.\n+\t* invoke.texi (-mfpmath): Document.\n+\t(-msse2): Add.\n+\n 2001-12-14  Jason Merrill  <jason@redhat.com>\n \n \t* dwarf2out.c (output_die): Print the string in the comment for"}, {"sha": "55113a5e67ac05770bc0bfea56b0fae9a2cddc11", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=965f5423cdab8320a22279d1e84bd3294d235184", "patch": "@@ -578,12 +578,16 @@ enum cmodel ix86_cmodel;\n /* which cpu are we scheduling for */\n enum processor_type ix86_cpu;\n \n+/* which unit we are generating floating point math for */\n+enum fpmath_unit ix86_fpmath;\n+\n /* which instruction set architecture to use.  */\n int ix86_arch;\n \n /* Strings to hold which cpu and instruction set architecture  to use.  */\n const char *ix86_cpu_string;\t\t/* for -mcpu=<xxx> */\n const char *ix86_arch_string;\t\t/* for -march=<xxx> */\n+const char *ix86_fpmath_string;\t\t/* for -mfpmath=<xxx> */\n \n /* # of registers to use to pass arguments.  */\n const char *ix86_regparm_string;\n@@ -1066,8 +1070,45 @@ override_options ()\n       if (TARGET_RTD)\n \terror (\"-mrtd calling convention not supported in the 64bit mode\");\n       /* Enable by default the SSE and MMX builtins.  */\n-      target_flags |= MASK_SSE2 | MASK_SSE | MASK_MMX | MASK_128BIT_LONG_DOUBLE;\n+      target_flags |= (MASK_SSE2 | MASK_SSE | MASK_MMX | MASK_128BIT_LONG_DOUBLE);\n+      ix86_fpmath = FPMATH_SSE;\n      }\n+  else\n+    ix86_fpmath = FPMATH_387;\n+\n+  if (ix86_fpmath_string != 0)\n+    {\n+      if (! strcmp (ix86_fpmath_string, \"387\"))\n+\tix86_fpmath = FPMATH_387;\n+      else if (! strcmp (ix86_fpmath_string, \"sse\"))\n+\t{\n+\t  if (!TARGET_SSE)\n+\t    {\n+\t      warning (\"SSE instruction set disabled, using 387 arithmetics\");\n+\t      ix86_fpmath = FPMATH_387;\n+\t    }\n+\t  else\n+\t    ix86_fpmath = FPMATH_SSE;\n+\t}\n+      else if (! strcmp (ix86_fpmath_string, \"387,sse\")\n+\t       || ! strcmp (ix86_fpmath_string, \"sse,387\"))\n+\t{\n+\t  if (!TARGET_SSE)\n+\t    {\n+\t      warning (\"SSE instruction set disabled, using 387 arithmetics\");\n+\t      ix86_fpmath = FPMATH_387;\n+\t    }\n+\t  else if (!TARGET_80387)\n+\t    {\n+\t      warning (\"387 instruction set disabled, using SSE arithmetics\");\n+\t      ix86_fpmath = FPMATH_SSE;\n+\t    }\n+\t  else\n+\t    ix86_fpmath = FPMATH_SSE | FPMATH_387;\n+\t}\n+      else \n+\terror (\"bad value (%s) for -mfpmath= switch\", ix86_fpmath_string);\n+    }\n \n   /* It makes no sense to ask for just SSE builtins, so MMX is also turned\n      on by -msse.  */\n@@ -8117,8 +8158,8 @@ ix86_expand_fp_movcc (operands)\n \n   /* For SF/DFmode conditional moves based on comparisons\n      in same mode, we may want to use SSE min/max instructions.  */\n-  if (((TARGET_SSE && GET_MODE (operands[0]) == SFmode)\n-       || (TARGET_SSE2 && GET_MODE (operands[0]) == DFmode))\n+  if (((TARGET_SSE_MATH && GET_MODE (operands[0]) == SFmode)\n+       || (TARGET_SSE2 && TARGET_SSE_MATH && GET_MODE (operands[0]) == DFmode))\n       && GET_MODE (ix86_compare_op0) == GET_MODE (operands[0])\n       /* The SSE comparisons does not support the LTGT/UNEQ pair.  */\n       && (!TARGET_IEEE_FP"}, {"sha": "b6e567ee1d7669b02f4460fdd179e6607f4dc9c8", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=965f5423cdab8320a22279d1e84bd3294d235184", "patch": "@@ -272,7 +272,9 @@ extern const int x86_epilogue_using_move, x86_decompose_lea;\n \n #define TARGET_SSE ((target_flags & (MASK_SSE | MASK_SSE2)) != 0)\n #define TARGET_SSE2 ((target_flags & MASK_SSE2) != 0)\n-#define TARGET_MIX_SSE_I387 ((target_flags & MASK_MIX_SSE_I387) != 0)\n+#define TARGET_SSE_MATH ((ix86_fpmath & FPMATH_SSE) != 0)\n+#define TARGET_MIX_SSE_I387 ((ix86_fpmath & FPMATH_SSE) \\\n+\t\t\t     && (ix86_fpmath & FPMATH_387))\n #define TARGET_MMX ((target_flags & MASK_MMX) != 0)\n #define TARGET_3DNOW ((target_flags & MASK_3DNOW) != 0)\n #define TARGET_3DNOW_A ((target_flags & MASK_3DNOW_A) != 0)\n@@ -365,10 +367,6 @@ extern const int x86_epilogue_using_move, x86_decompose_lea;\n   { \"no-sse2\",\t\t\t -MASK_SSE2, N_(\"\") },\t\t\t      \\\n   { \"no-sse2\",\t\t\t MASK_SSE2_SET,\t\t\t\t      \\\n     N_(\"Do not support MMX, SSE and SSE2 builtins and code generation\") },    \\\n-  { \"mix-sse-i387\",\t\t MASK_MIX_SSE_I387,\t\t\t      \\\n-    N_(\"Use both SSE and i387 instruction sets for floating point arithmetics\") },\\\n-  { \"no-mix-sse-i387\",\t\t-MASK_MIX_SSE_I387,\t\t\t      \\\n-    N_(\"Do not use both SSE and i387 instruction sets for floating point arithmetics\") },\\\n   { \"128bit-long-double\",\t MASK_128BIT_LONG_DOUBLE,\t\t      \\\n     N_(\"sizeof(long double) is 16\") },\t\t\t\t\t      \\\n   { \"96bit-long-double\",\t-MASK_128BIT_LONG_DOUBLE,\t\t      \\\n@@ -404,8 +402,14 @@ enum processor_type\n   PROCESSOR_PENTIUM4,\n   PROCESSOR_max\n };\n+enum fpmath_unit\n+{\n+  FPMATH_387 = 1,\n+  FPMATH_SSE = 2\n+};\n \n extern enum processor_type ix86_cpu;\n+extern enum fpmath_unit ix86_fpmath;\n \n extern int ix86_arch;\n \n@@ -421,6 +425,8 @@ extern int ix86_arch;\n #define TARGET_OPTIONS\t\t\t\t\t\t\\\n { { \"cpu=\",\t\t&ix86_cpu_string,\t\t\t\\\n     N_(\"Schedule code for given CPU\")},\t\t\t\t\\\n+  { \"fpmath=\",\t\t&ix86_fpmath_string,\t\t\t\\\n+    N_(\"Generate floating point mathematics using given instruction set\")},\\\n   { \"arch=\",\t\t&ix86_arch_string,\t\t\t\\\n     N_(\"Generate code for given CPU\")},\t\t\t\t\\\n   { \"regparm=\",\t\t&ix86_regparm_string,\t\t\t\\\n@@ -1271,7 +1277,7 @@ enum reg_class\n #define SSE_REG_P(n) (REG_P (n) && SSE_REGNO_P (REGNO (n)))\n \n #define SSE_FLOAT_MODE_P(m) \\\n-  ((TARGET_SSE && (m) == SFmode) || (TARGET_SSE2 && (m) == DFmode))\n+  ((TARGET_SSE_MATH && (m) == SFmode) || (TARGET_SSE2 && (m) == DFmode))\n \n #define MMX_REGNO_P(n) ((n) >= FIRST_MMX_REG && (n) <= LAST_MMX_REG)\n #define MMX_REG_P(xop) (REG_P (xop) && MMX_REGNO_P (REGNO (xop)))\n@@ -3112,6 +3118,7 @@ extern enum cmodel ix86_cmodel;\n /* Variables in i386.c */\n extern const char *ix86_cpu_string;\t\t/* for -mcpu=<xxx> */\n extern const char *ix86_arch_string;\t\t/* for -march=<xxx> */\n+extern const char *ix86_fpmath_string;\t\t/* for -mfpmath=<xxx> */\n extern const char *ix86_regparm_string;\t\t/* # registers to use to pass args */\n extern const char *ix86_align_loops_string;\t/* power of two alignment for loops */\n extern const char *ix86_align_jumps_string;\t/* power of two alignment for non-loop jumps */"}, {"sha": "edd3f039e5bbc5197f863d86178d8c39c249ebf3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 103, "deletions": 36, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=965f5423cdab8320a22279d1e84bd3294d235184", "patch": "@@ -2776,7 +2776,7 @@\n \t(match_operand:SF 1 \"register_operand\" \"+f\"))\n    (set (match_dup 1)\n \t(match_dup 0))]\n-  \"reload_completed || !TARGET_SSE2\"\n+  \"reload_completed || !TARGET_SSE\"\n {\n   if (STACK_TOP_P (operands[0]))\n     return \"fxch\\t%1\";\n@@ -6890,14 +6890,14 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(plus:DF (match_operand:DF 1 \"register_operand\" \"\")\n \t\t (match_operand:DF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE2\"\n+  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"\")\n \n (define_expand \"addsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(plus:SF (match_operand:SF 1 \"register_operand\" \"\")\n \t\t (match_operand:SF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"\")\n \f\n ;; Subtract instructions\n@@ -7207,14 +7207,14 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(minus:DF (match_operand:DF 1 \"register_operand\" \"\")\n \t\t  (match_operand:DF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE2\"\n+  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"\")\n \n (define_expand \"subsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(minus:SF (match_operand:SF 1 \"register_operand\" \"\")\n \t\t  (match_operand:SF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"\")\n \f\n ;; Multiply instructions\n@@ -7533,14 +7533,14 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"\")\n \t\t (match_operand:DF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE2\"\n+  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"\")\n \n (define_expand \"mulsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(mult:SF (match_operand:SF 1 \"register_operand\" \"\")\n \t\t (match_operand:SF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"\")\n \f\n ;; Divide instructions\n@@ -7587,14 +7587,14 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n  \t(div:DF (match_operand:DF 1 \"register_operand\" \"\")\n  \t\t(match_operand:DF 2 \"nonimmediate_operand\" \"\")))]\n-   \"TARGET_80387 || TARGET_SSE2\"\n+   \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n    \"\")\n  \n (define_expand \"divsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(div:SF (match_operand:SF 1 \"register_operand\" \"\")\n \t\t(match_operand:SF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"\")\n \f\n ;; Remainder instructions.\n@@ -13849,12 +13849,26 @@\n \n ;; Gcc is slightly more smart about handling normal two address instructions\n ;; so use special patterns for add and mull.\n+(define_insn \"*fop_sf_comm_nosse\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(match_operator:SF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:SF 1 \"register_operand\" \"%0\")\n+\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm\")]))]\n+  \"TARGET_80387 && !TARGET_SSE_MATH\n+   && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+\t(if_then_else (match_operand:SF 3 \"mult_operator\" \"\") \n+\t   (const_string \"fmul\")\n+\t   (const_string \"fop\")))\n+   (set_attr \"mode\" \"SF\")])\n+\n (define_insn \"*fop_sf_comm\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f#x,x#f\")\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:SF 1 \"register_operand\" \"%0,0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm#x,xm#f\")]))]\n-  \"TARGET_80387 && (!TARGET_SSE || TARGET_MIX_SSE_I387)\n+  \"TARGET_80387 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n    && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -13870,17 +13884,31 @@\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:SF 1 \"register_operand\" \"%0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_SSE && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n+  \"TARGET_SSE_MATH && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"mode\" \"SF\")])\n \n+(define_insn \"*fop_df_comm_nosse\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(match_operator:DF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:DF 1 \"register_operand\" \"%0\")\n+\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm\")]))]\n+  \"TARGET_80387 && (!TARGET_SSE2 || !TARGET_SSE_MATH)\n+   && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+\t(if_then_else (match_operand:SF 3 \"mult_operator\" \"\") \n+\t   (const_string \"fmul\")\n+\t   (const_string \"fop\")))\n+   (set_attr \"mode\" \"DF\")])\n+\n (define_insn \"*fop_df_comm\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f#Y,Y#f\")\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:DF 1 \"register_operand\" \"%0,0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm#Y,Ym#f\")]))]\n-  \"TARGET_80387 && (!TARGET_SSE2 || TARGET_MIX_SSE_I387)\n+  \"TARGET_80387 && TARGET_SSE_MATH && TARGET_SSE2 && TARGET_MIX_SSE_I387\n    && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -13896,7 +13924,7 @@\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:DF 1 \"register_operand\" \"%0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\")]))]\n-  \"TARGET_SSE2\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\n    && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set_attr \"type\" \"sse\")\n@@ -13929,12 +13957,30 @@\n            (const_string \"fop\")))\n    (set_attr \"mode\" \"XF\")])\n \n+(define_insn \"*fop_sf_1_nosse\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:SF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"0,fm\")\n+\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n+  \"TARGET_80387 && !TARGET_SSE_MATH\n+   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:SF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:SF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"mode\" \"SF\")])\n+\n (define_insn \"*fop_sf_1\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f,x\")\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"0,fm,0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0,xm#f\")]))]\n-  \"TARGET_80387 && (!TARGET_SSE || TARGET_MIX_SSE_I387)\n+  \"TARGET_80387 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n    && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n@@ -13954,7 +14000,7 @@\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:SF 1 \"register_operand\" \"0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_SSE\n+  \"TARGET_SSE_MATH\n    && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set_attr \"type\" \"sse\")\n@@ -13966,7 +14012,7 @@\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t  [(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"m,?r\"))\n \t   (match_operand:SF 2 \"register_operand\" \"0,0\")]))]\n-  \"TARGET_80387 && TARGET_USE_FIOP && !TARGET_SSE\"\n+  \"TARGET_80387 && TARGET_USE_FIOP && !TARGET_SSE_MATH\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (cond [(match_operand:SF 3 \"mult_operator\" \"\") \n@@ -13984,7 +14030,7 @@\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t  [(match_operand:SF 1 \"register_operand\" \"0,0\")\n \t   (float:SF (match_operand:SI 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n-  \"TARGET_80387 && TARGET_USE_FIOP && !TARGET_SSE\"\n+  \"TARGET_80387 && TARGET_USE_FIOP && !TARGET_SSE_MATH\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (cond [(match_operand:SF 3 \"mult_operator\" \"\") \n@@ -13997,12 +14043,31 @@\n    (set_attr \"ppro_uops\" \"many\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*fop_df_1_nosse\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(match_operator:DF 3 \"binary_fp_operator\"\n+\t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"0,fm\")\n+\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n+  \"TARGET_80387 && (!TARGET_SSE2 || !TARGET_SSE_MATH)\n+   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"* return output_387_binary_op (insn, operands);\"\n+  [(set (attr \"type\") \n+        (cond [(match_operand:DF 3 \"mult_operator\" \"\") \n+                 (const_string \"fmul\")\n+               (match_operand:DF 3 \"div_operator\" \"\") \n+                 (const_string \"fdiv\")\n+              ]\n+              (const_string \"fop\")))\n+   (set_attr \"mode\" \"DF\")])\n+\n+\n (define_insn \"*fop_df_1\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f#Y,f#Y,Y#f\")\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"0,fm,0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0,Ym#f\")]))]\n-  \"TARGET_80387 && (!TARGET_SSE2 || TARGET_MIX_SSE_I387)\n+  \"TARGET_80387 && TARGET_SSE2 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n    && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n@@ -14022,7 +14087,7 @@\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:DF 1 \"register_operand\" \"0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\")]))]\n-  \"TARGET_SSE\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\n    && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set_attr \"type\" \"sse\")])\n@@ -14033,7 +14098,7 @@\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t   [(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"m,?r\"))\n \t    (match_operand:DF 2 \"register_operand\" \"0,0\")]))]\n-  \"TARGET_80387 && TARGET_USE_FIOP && !TARGET_SSE2\"\n+  \"TARGET_80387 && TARGET_USE_FIOP && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (cond [(match_operand:DF 3 \"mult_operator\" \"\") \n@@ -14051,7 +14116,7 @@\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t   [(match_operand:DF 1 \"register_operand\" \"0,0\")\n \t    (float:DF (match_operand:SI 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n-  \"TARGET_80387 && TARGET_USE_FIOP && !TARGET_SSE2\"\n+  \"TARGET_80387 && TARGET_USE_FIOP && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (cond [(match_operand:DF 3 \"mult_operator\" \"\") \n@@ -14087,7 +14152,7 @@\n \t  [(match_operand:DF 1 \"register_operand\" \"0,f\")\n \t   (float_extend:DF\n \t    (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0\"))]))]\n-  \"TARGET_80387 && !TARGET_SSE2\"\n+  \"TARGET_80387 && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (cond [(match_operand:DF 3 \"mult_operator\" \"\") \n@@ -14421,17 +14486,18 @@\n (define_expand \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(sqrt:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n-  \"(! TARGET_NO_FANCY_MATH_387 && TARGET_80387) || TARGET_SSE2\"\n+  \"(! TARGET_NO_FANCY_MATH_387 && TARGET_80387)\n+   || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n {\n-  if (!TARGET_SSE2)\n+  if (!TARGET_SSE2 || !TARGET_SSE_MATH)\n     operands[1] = force_reg (DFmode, operands[1]);\n })\n \n (define_insn \"sqrtdf2_1\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f#Y,Y#f\")\n \t(sqrt:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0#Y,Ym#f\")))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\n-   && (TARGET_SSE2 && TARGET_MIX_SSE_I387)\"\n+   && (TARGET_SSE2 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387)\"\n   \"@\n    fsqrt\n    sqrtsd\\t{%1, %0|%0, %1}\"\n@@ -14442,7 +14508,7 @@\n (define_insn \"sqrtdf2_1_sse_only\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=Y\")\n \t(sqrt:DF (match_operand:DF 1 \"nonimmediate_operand\" \"Ym\")))]\n-  \"TARGET_SSE2 && (!TARGET_80387 || !TARGET_MIX_SSE_I387)\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH && (!TARGET_80387 || !TARGET_MIX_SSE_I387)\"\n   \"sqrtsd\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"mode\" \"DF\")\n@@ -14452,7 +14518,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\n-   && (!TARGET_SSE2 && !TARGET_MIX_SSE_I387)\"\n+   && (!TARGET_SSE2 && TARGET_SSE_MATH && !TARGET_MIX_SSE_I387)\"\n   \"fsqrt\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")\n@@ -14462,7 +14528,8 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(sqrt:DF (float_extend:DF\n \t\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && !TARGET_SSE2\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\n+   && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"fsqrt\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")\n@@ -15963,7 +16030,7 @@\n \t\t\t   (match_dup 1)\n \t\t\t   (match_dup 2)))\n      (clobber (reg:CC 17))])]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n   \"#\")\n \n (define_insn \"*mindf\"\n@@ -15973,7 +16040,7 @@\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SSE2 && TARGET_IEEE_FP\"\n+  \"TARGET_SSE2 && TARGET_IEEE_FP && TARGET_SSE_MATH\"\n   \"#\")\n \n (define_insn \"*mindf_nonieee\"\n@@ -15983,7 +16050,7 @@\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SSE2 && !TARGET_IEEE_FP\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH && !TARGET_IEEE_FP\"\n   \"#\")\n \n (define_split\n@@ -16031,7 +16098,7 @@\n \t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))]\n-  \"TARGET_SSE2 && reload_completed\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH && reload_completed\"\n   \"minsd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"mode\" \"DF\")])\n@@ -16124,7 +16191,7 @@\n \t\t\t   (match_dup 1)\n \t\t\t   (match_dup 2)))\n      (clobber (reg:CC 17))])]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n   \"#\")\n \n (define_insn \"*maxdf\"\n@@ -16134,7 +16201,7 @@\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SSE2 && TARGET_IEEE_FP\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH && TARGET_IEEE_FP\"\n   \"#\")\n \n (define_insn \"*maxdf_nonieee\"\n@@ -16144,7 +16211,7 @@\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))\n    (clobber (reg:CC 17))]\n-  \"TARGET_SSE2 && !TARGET_IEEE_FP\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH && !TARGET_IEEE_FP\"\n   \"#\")\n \n (define_split\n@@ -16191,7 +16258,7 @@\n \t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))]\n-  \"TARGET_SSE2 && reload_completed\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH && reload_completed\"\n   \"maxsd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"mode\" \"DF\")])"}, {"sha": "03def553eb148012440a2ad5b6a476cde104c296", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965f5423cdab8320a22279d1e84bd3294d235184/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=965f5423cdab8320a22279d1e84bd3294d235184", "patch": "@@ -473,12 +473,12 @@ in the following sections.\n \n @emph{i386 and x86-64 Options}\n @gccoptlist{\n--mcpu=@var{cpu-type}  -march=@var{cpu-type} @gol\n+-mcpu=@var{cpu-type}  -march=@var{cpu-type} -mfpmath=@var{unit} @gol\n -mintel-syntax -mieee-fp  -mno-fancy-math-387 @gol\n -mno-fp-ret-in-387  -msoft-float  -msvr3-shlib @gol\n -mno-wide-multiply  -mrtd  -malign-double @gol\n -mpreferred-stack-boundary=@var{num} @gol\n--mmmx  -msse  -m3dnow @gol\n+-mmmx  -msse -msse2 -msse-math -m3dnow @gol\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n -m96bit-long-double  -mregparm=@var{num}  -momit-leaf-frame-pointer @gol\n@@ -7513,6 +7513,48 @@ These options are synonyms for @option{-mcpu=i386}, @option{-mcpu=i486},\n @option{-mcpu=pentium}, and @option{-mcpu=pentiumpro} respectively.\n These synonyms are deprecated.\n \n+@item -mfpmath=@var{unit}\n+@opindex march\n+generate floating point arithmetics for selected unit @var{unit}.  the choices\n+for @var{unit} are:\n+\n+@table @samp\n+@item 387\n+Use the standard 387 floating point coprocessor present majority of chips and\n+emulated otherwise.  Code compiled with this option will run almost everywhere.\n+The temporary results are computed in 80bit precesion instead of precision\n+specified by the type resulting in slightly different results compared to most\n+of other chips. See @option{-ffloat-store} for more detailed description.\n+\n+This is the default choice for i386 compiler.\n+\n+@item sse\n+Use scalar floating point instructions present in the SSE instruction set.\n+This instruction set is supported by Pentium3 and newer chips, in the AMD line\n+by Athlon-4, Athlon-xp and Athlon-mp chips.  The earlier version of SSE\n+instruction set supports only single precision arithmetics, thus the double and\n+extended precision arithmetics is still done using 387.  Later version, present\n+only in Pentium4 and the future AMD x86-64 chips supports double precision\n+arithmetics too.\n+\n+For i387 you need to use @option{-march=@var{cpu-type}}, @option{-msse} or\n+@option{-msse2} switches to enable SSE extensions and make this option\n+effective.  For x86-64 compiler, these extensions are enabled by default.\n+\n+The resulting code should be considerably faster in majority of cases and avoid\n+the numerical instability problems of 387 code, but may break some existing\n+code that expects temporaries to be 80bit.\n+\n+This is the default choice for x86-64 compiler.\n+\n+@item sse,387\n+Attempt to utilize both instruction sets at once.  This effectivly double the\n+amount of available registers and on chips with separate execution units for\n+387 and SSE the execution resources too.  Use this option with care, as it is\n+still experimental, because gcc register allocator does not model separate\n+functional units well resulting in instable performance.\n+@end table\n+\n @item -mintel-syntax\n @opindex mintel-syntax\n Emit assembly using Intel syntax opcodes instead of AT&T syntax.\n@@ -7663,6 +7705,8 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mno-mmx\n @item -msse\n @itemx -mno-sse\n+@item -msse2\n+@itemx -mno-sse2\n @item -m3dnow\n @itemx -mno-3dnow\n @opindex mmmx"}]}