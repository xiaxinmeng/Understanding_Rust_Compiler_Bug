{"sha": "b850de4faa9430a721ffeee7aacd968c2b1befad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg1MGRlNGZhYTk0MzBhNzIxZmZlZWU3YWFjZDk2OGMyYjFiZWZhZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-03-27T02:17:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-03-27T02:17:48Z"}, "message": "c-common.h (DECL_NUM_STMTS): New macro.\n\n\t* c-common.h (DECL_NUM_STMTS): New macro.\n\t* c-decl.c (duplicate_decls): Copy DECL_NUM_STMTS, not\n\tDECL_FRAME_SIZE.\n\t(pushdecl): Likewise.\n\t* c-semantics.c (add_stmt): Update DECL_NUM_STMTS.\n\t* integrate.c (expand_inline_function): Don't check\n\tDECL_FRAME_SIZE.\n\t* print-tree.c (print_node): Don't print it.\n\t* toplev.c (rest_of_compilation): Don't try to inline when\n\tflag_no_inline is on.\n\t* tree.h (DECL_FRAME_SIZE): Remove.\n\t(tree_decl): Adjust accordingly.\n\n\t* Makefile.in (optimize.o): Depend on params.h.\n\t(duplicate_decls): Copy DECL_NUM_STMTS, not DECL_FRAME_SIZE.\n\t(init_decl_processing): Set flag_no_inline when doing\n\tinlining-on-trees.\n\t* optimize.c: Include params.h.\n\t(struct inline_data): Improve documentation of FNS.  Add\n\tFIRST_INLINED_FN, INLINED_STMTS, and CLONING_P.\n\t(INSNS_PER_STMT): New macro.\n\t(remap_block): Use CLONING_P.\n\t(inlinable_function_p): Don't inline big functions.\n\t(expand_call_inline): Keep track of how much inlining we've done.\n\t(optimize_function): Set FIRST_INLINED_FN.\n\t(maybe_clone_body): Set CLONING_P.\n\t* semantics.c (simplify_aggr_init_exprs_r): Fix typing problems in\n\ttree nodes.\n\t(genrtl_finish_function): Clear DECL_DEFER_OUTPUT before calling\n\trest_of_compilation.  Clear DECL_RTL for local variables\n\tafterwards.\n\t(clear_decl_rtl): New function.\n\n\t* com.c (duplicate_decls): Don't copy DECL_FRAME_SIZE.\n\n\t* parse.h (DECL_END_SOURCE_LINE): Don't rely on DECL_FRAME_SIZE.\n\nFrom-SVN: r40859", "tree": {"sha": "948316451d83b15b776dfaed5ddc3be0ef0528cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/948316451d83b15b776dfaed5ddc3be0ef0528cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b850de4faa9430a721ffeee7aacd968c2b1befad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b850de4faa9430a721ffeee7aacd968c2b1befad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b850de4faa9430a721ffeee7aacd968c2b1befad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b850de4faa9430a721ffeee7aacd968c2b1befad/comments", "author": null, "committer": null, "parents": [{"sha": "29bb79cf262441c925d8f89bbe3c67cddded3402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29bb79cf262441c925d8f89bbe3c67cddded3402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29bb79cf262441c925d8f89bbe3c67cddded3402"}], "stats": {"total": 211, "additions": 171, "deletions": 40}, "files": [{"sha": "645be42d376c0cfefcc2cf23459f164467a53fa1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -1,3 +1,18 @@\n+2001-03-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.h (DECL_NUM_STMTS): New macro.\n+\t* c-decl.c (duplicate_decls): Copy DECL_NUM_STMTS, not\n+\tDECL_FRAME_SIZE.\n+\t(pushdecl): Likewise.\n+\t* c-semantics.c (add_stmt): Update DECL_NUM_STMTS.\n+\t* integrate.c (expand_inline_function): Don't check\n+\tDECL_FRAME_SIZE.\n+\t* print-tree.c (print_node): Don't print it.\n+\t* toplev.c (rest_of_compilation): Don't try to inline when\n+\tflag_no_inline is on.\n+\t* tree.h (DECL_FRAME_SIZE): Remove.\n+\t(tree_decl): Adjust accordingly.\n+\t\n 2001-03-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* combine.c (try_combine): Use memcpy, not bcopy."}, {"sha": "acc23e499f0f33509b97f4c59072994253cd5592", "filename": "gcc/c-common.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -337,6 +337,13 @@ struct c_lang_decl {\n   (((struct c_lang_decl *) DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))) \\\n    ->saved_tree)\n \n+/* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this is\n+     the approximate number of statements in this function.  There is\n+     no need for this number to be exact; it is only used in various\n+     heuristics regarding optimization.  */\n+#define DECL_NUM_STMTS(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n+\n extern void c_mark_lang_decl                    PARAMS ((struct c_lang_decl *));\n \n /* The variant of the C language being processed.  Each C language"}, {"sha": "941083236b24854a3d22ece6772e0b71d299966c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -2009,7 +2009,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t}\n       /* Also preserve various other info from the definition.  */\n       else if (! new_is_definition)\n-\tDECL_FRAME_SIZE (newdecl) = DECL_FRAME_SIZE (olddecl);\n+\tDECL_NUM_STMTS (newdecl) = DECL_NUM_STMTS (olddecl);\n       if (! new_is_definition)\n \t{\n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n@@ -2372,7 +2372,7 @@ pushdecl (x)\n \t\t      DECL_INITIAL (x) = (current_function_decl == oldglobal\n \t\t\t\t\t  ? 0 : DECL_INITIAL (oldglobal));\n \t\t      DECL_SAVED_INSNS (x) = DECL_SAVED_INSNS (oldglobal);\n-\t\t      DECL_FRAME_SIZE (x) = DECL_FRAME_SIZE (oldglobal);\n+\t\t      DECL_NUM_STMTS (x) = DECL_NUM_STMTS (oldglobal);\n \t\t      DECL_ARGUMENTS (x) = DECL_ARGUMENTS (oldglobal);\n \t\t      DECL_RESULT (x) = DECL_RESULT (oldglobal);\n \t\t      TREE_ASM_WRITTEN (x) = TREE_ASM_WRITTEN (oldglobal);"}, {"sha": "6f2ca2c9cfcfc0bb6e2edc0d24090e00712eb57f", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -75,6 +75,11 @@ add_stmt (t)\n   /* When we expand a statement-tree, we must know whether or not the\n      statements are full-expresions.  We record that fact here.  */\n   STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p ();\n+\n+  /* Keep track of the number of statements in this function.  */\n+  if (current_function_decl)\n+    ++DECL_NUM_STMTS (current_function_decl);\n+\n   return t;\n }\n "}, {"sha": "cdf1637c61d277a119bf6b304b43a367fe2be1f1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -1,3 +1,25 @@\n+2001-03-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (optimize.o): Depend on params.h.\n+\t(duplicate_decls): Copy DECL_NUM_STMTS, not DECL_FRAME_SIZE.\n+\t(init_decl_processing): Set flag_no_inline when doing\n+\tinlining-on-trees.\n+\t* optimize.c: Include params.h.\n+\t(struct inline_data): Improve documentation of FNS.  Add\n+\tFIRST_INLINED_FN, INLINED_STMTS, and CLONING_P.\n+\t(INSNS_PER_STMT): New macro.\n+\t(remap_block): Use CLONING_P.\n+\t(inlinable_function_p): Don't inline big functions.\n+\t(expand_call_inline): Keep track of how much inlining we've done.\n+\t(optimize_function): Set FIRST_INLINED_FN.\n+\t(maybe_clone_body): Set CLONING_P.\n+\t* semantics.c (simplify_aggr_init_exprs_r): Fix typing problems in\n+\ttree nodes.\n+\t(genrtl_finish_function): Clear DECL_DEFER_OUTPUT before calling\n+\trest_of_compilation.  Clear DECL_RTL for local variables\n+\tafterwards.\n+\t(clear_decl_rtl): New function.\n+\t\t\n 2001-03-26  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tImplement DR 209"}, {"sha": "d96853356885ae5b25c1158c7d670e58a51ce154", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -297,7 +297,7 @@ cp/semantics.o: cp/semantics.c $(CXX_TREE_H) cp/lex.h except.h toplev.h \\\n   flags.h $(GGC_H) output.h $(RTL_H) $(TIMEVAR_H)\n cp/dump.o: cp/dump.c $(CXX_TREE_H) c-dump.h\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) rtl.h integrate.h insn-config.h \\\n-  input.h\n+  input.h params.h\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) toplev.h\n \n cp/parse.o: cp/parse.c $(CXX_TREE_H) flags.h cp/lex.h except.h output.h \\"}, {"sha": "92ee8edb7ac2b33d19a78fc6fd3c30a170d53e86", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -3692,7 +3692,7 @@ duplicate_decls (newdecl, olddecl)\n \t      SET_DECL_RTL (newdecl, DECL_RTL (olddecl));\n \t    }\n \t  else\n-\t    DECL_FRAME_SIZE (newdecl) = DECL_FRAME_SIZE (olddecl);\n+\t    DECL_NUM_STMTS (newdecl) = DECL_NUM_STMTS (olddecl);\n \n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n \t  if ((DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl)))\n@@ -6346,7 +6346,10 @@ init_decl_processing ()\n   if (! flag_permissive && ! pedantic)\n     flag_pedantic_errors = 1;\n   if (!flag_no_inline)\n-    flag_inline_trees = 1;\n+    {\n+      flag_inline_trees = 1;\n+      flag_no_inline = 1;\n+    }\n \n   /* Initially, C.  */\n   current_lang_name = lang_name_c;"}, {"sha": "f7f957509c28a8b6015ed2d50a1dbea75837c878", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"varray.h\"\n #include \"ggc.h\"\n+#include \"params.h\"\n \n /* To Do:\n \n@@ -50,8 +51,13 @@ typedef struct inline_data\n   /* A stack of the functions we are inlining.  For example, if we are\n      compiling `f', which calls `g', which calls `h', and we are\n      inlining the body of `h', the stack will contain, `h', followed\n-     by `g', followed by `f'.  */\n+     by `g', followed by `f'.  The first few elements of the stack may\n+     contain other functions that we know we should not recurse into,\n+     even though they are not directly being inlined.  */\n   varray_type fns;\n+  /* The index of the first element of FNS that really represents an\n+     inlined function.  */\n+  unsigned first_inlined_fn;\n   /* The label to jump to when a return statement is encountered.  If\n      this value is NULL, then return statements will simply be\n      remapped as return statements, rather than as jumps.  */\n@@ -66,6 +72,14 @@ typedef struct inline_data\n   varray_type target_exprs;\n   /* A list of the functions current function has inlined.  */\n   varray_type inlined_fns;\n+  /* The approximate number of statements we have inlined in the\n+     current call stack.  */\n+  int inlined_stmts;\n+  /* We use the same mechanism to build clones that we do to perform\n+     inlining.  However, there are a few places where we need to\n+     distinguish between those two situations.  This flag is true nif\n+     we are cloning, rather than inlining.  */\n+  bool cloning_p;\n } inline_data;\n \n /* Prototypes.  */\n@@ -82,6 +96,11 @@ static void remap_block PARAMS ((tree, tree, inline_data *));\n static void copy_scope_stmt PARAMS ((tree *, int *, inline_data *));\n static tree calls_setjmp_r PARAMS ((tree *, int *, void *));\n \n+/* The approximate number of instructions per statement.  This number\n+   need not be particularly accurate; it is used only to make\n+   decisions about when a function is too big to inline.  */\n+#define INSNS_PER_STMT (10)\n+\n /* Remap DECL during the copying of the BLOCK tree for the function.\n    DATA is really an `inline_data *'.  */\n \n@@ -199,9 +218,10 @@ remap_block (scope_stmt, decls, id)\n       /* We put the BLOCK_VARS in reverse order; fix that now.  */\n       BLOCK_VARS (new_block) = nreverse (BLOCK_VARS (new_block));\n       fn = VARRAY_TREE (id->fns, 0);\n-      if (fn == current_function_decl)\n-\t/* We're building a clone; DECL_INITIAL is still error_mark_node, and\n-\t   current_binding_level is the parm binding level.  */\n+      if (id->cloning_p)\n+\t/* We're building a clone; DECL_INITIAL is still\n+\t   error_mark_node, and current_binding_level is the parm\n+\t   binding level.  */\n \tinsert_block (new_block);\n       else\n \t{\n@@ -583,6 +603,9 @@ inlinable_function_p (fn, id)\n   /* We can't inline varargs functions.  */\n   else if (varargs_function_p (fn))\n     ;\n+  /* We can't inline functions that are too big.  */\n+  else if (DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS)\n+    ;\n   /* All is well.  We can inline this function.  Traditionally, GCC\n      has refused to inline functions using alloca, or functions whose\n      values are returned in a PARALLEL, and a few other such obscure\n@@ -593,6 +616,13 @@ inlinable_function_p (fn, id)\n   /* Squirrel away the result so that we don't have to check again.  */\n   DECL_UNINLINABLE (fn) = !inlinable;\n \n+  /* Even if this function is not itself too big to inline, it might\n+     be that we've done so much inlining already that we don't want to\n+     risk inlining any more.  */\n+  if ((DECL_NUM_STMTS (fn) + id->inlined_stmts) * INSNS_PER_STMT \n+      > MAX_INLINE_INSNS)\n+    inlinable = 0;\n+\n   /* We can inline a template instantiation only if it's fully\n      instantiated.  */\n   if (inlinable\n@@ -830,10 +860,19 @@ expand_call_inline (tp, walk_subtrees, data)\n      the equivalent inlined version either.  */\n   TREE_USED (*tp) = 1;\n \n+  /* Our function now has more statements than it did before.  */\n+  DECL_NUM_STMTS (VARRAY_TREE (id->fns, 0)) += DECL_NUM_STMTS (fn);\n+  id->inlined_stmts += DECL_NUM_STMTS (VARRAY_TREE (id->fns, 0));\n+\n   /* Recurse into the body of the just inlined function.  */\n   expand_calls_inline (inlined_body, id);\n   VARRAY_POP (id->fns);\n \n+  /* If we've returned to the top level, clear out the record of how\n+     much inlining has been done.  */\n+  if (VARRAY_ACTIVE_SIZE (id->fns) == id->first_inlined_fn)\n+    id->inlined_stmts = 0;\n+\n   /* Don't walk into subtrees.  We've already handled them above.  */\n   *walk_subtrees = 0;\n \n@@ -904,6 +943,10 @@ optimize_function (fn)\n       /* Create the list of functions this call will inline.  */\n       VARRAY_TREE_INIT (id.inlined_fns, 32, \"inlined_fns\");\n \n+      /* Keep track of the low-water mark, i.e., the point where\n+\t the first real inlining is represented in ID.FNS.  */\n+      id.first_inlined_fn = VARRAY_ACTIVE_SIZE (id.fns);\n+\n       /* Replace all calls to inline functions with the bodies of those\n \t functions.  */\n       expand_calls_inline (&DECL_SAVED_TREE (fn), &id);\n@@ -1011,6 +1054,10 @@ maybe_clone_body (fn)\n       VARRAY_PUSH_TREE (id.fns, clone);\n       VARRAY_PUSH_TREE (id.fns, fn);\n \n+      /* Cloning is treated slightly differently from inlining.  Set\n+\t CLONING_P so that its clear which operation we're performing.  */\n+      id.cloning_p = true;\n+\n       /* Remap the parameters.  */\n       id.decl_map = splay_tree_new (splay_tree_compare_pointers,\n \t\t\t\t    NULL, NULL);"}, {"sha": "5406b3e3bd0dacf054eab925e47e1ec5e43279e5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -59,6 +59,7 @@ static void genrtl_named_return_value PARAMS ((void));\n static void cp_expand_stmt PARAMS ((tree));\n static void genrtl_start_function PARAMS ((tree));\n static void genrtl_finish_function PARAMS ((tree));\n+static tree clear_decl_rtl PARAMS ((tree *, int *, void *));\n \n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n \n@@ -2241,7 +2242,6 @@ simplify_aggr_init_exprs_r (tp, walk_subtrees, data)\n   tree args;\n   tree slot;\n   tree type;\n-  tree call_type;\n   int copy_from_buffer_p;\n \n   aggr_init_expr = *tp;\n@@ -2264,17 +2264,20 @@ simplify_aggr_init_exprs_r (tp, walk_subtrees, data)\n   args = TREE_OPERAND (aggr_init_expr, 1);\n   slot = TREE_OPERAND (aggr_init_expr, 2);\n   type = TREE_TYPE (aggr_init_expr);\n-  call_type = type;\n   if (AGGR_INIT_VIA_CTOR_P (aggr_init_expr))\n     {\n       /* Replace the first argument with the address of the third\n \t argument to the AGGR_INIT_EXPR.  */\n-      call_type = build_pointer_type (type);\n       mark_addressable (slot);\n-      args = tree_cons (NULL_TREE, build1 (ADDR_EXPR, call_type, slot),\n+      args = tree_cons (NULL_TREE, \n+\t\t\tbuild1 (ADDR_EXPR, \n+\t\t\t\tbuild_pointer_type (TREE_TYPE (slot)),\n+\t\t\t\tslot),\n \t\t\tTREE_CHAIN (args));\n     }\n-  call_expr = build (CALL_EXPR, call_type, fn, args, NULL_TREE);\n+  call_expr = build (CALL_EXPR, \n+\t\t     TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n+\t\t     fn, args, NULL_TREE);\n   TREE_SIDE_EFFECTS (call_expr) = 1;\n \n   /* If we're using the non-reentrant PCC calling convention, then we\n@@ -2681,6 +2684,10 @@ genrtl_finish_function (fn)\n   if (function_depth > 1)\n     ggc_push_context ();\n \n+  /* There's no need to defer outputting this function any more; we\n+     know we want to output it.  */\n+  DECL_DEFER_OUTPUT (fn) = 0;\n+\n   /* Run the optimizers and output the assembler code for this\n      function.  */\n   rest_of_compilation (fn);\n@@ -2721,28 +2728,54 @@ genrtl_finish_function (fn)\n \n   --function_depth;\n \n-  if (!DECL_SAVED_INSNS (fn)\n-      && !(flag_inline_trees && DECL_INLINE (fn)))\n+  /* If we don't need the RTL for this function anymore, stop pointing\n+     to it.  That's especially important for LABEL_DECLs, since you\n+     can reach all the instructions in the function from the\n+     CODE_LABEL stored in the DECL_RTL for the LABEL_DECL.  */\n+  if (!DECL_SAVED_INSNS (fn))\n     {\n       tree t;\n \n-      /* Stop pointing to the local nodes about to be freed.  */\n-      /* But DECL_INITIAL must remain nonzero so we know this\n-\t was an actual function definition.  */\n-      DECL_INITIAL (fn) = error_mark_node;\n+      /* Walk the BLOCK-tree, clearing DECL_RTL for LABEL_DECLs and\n+\t non-static local variables.  */\n+      walk_tree_without_duplicates (&DECL_SAVED_TREE (fn),\n+\t\t\t\t    clear_decl_rtl,\n+\t\t\t\t    NULL);\n+\n+      /* Clear out the RTL for the arguments.  */\n       for (t = DECL_ARGUMENTS (fn); t; t = TREE_CHAIN (t))\n \t{\n \t  SET_DECL_RTL (t, NULL_RTX);\n \t  DECL_INCOMING_RTL (t) = NULL_RTX;\n \t}\n-    }\n \n+      if (!(flag_inline_trees && DECL_INLINE (fn)))\n+\t/* DECL_INITIAL must remain nonzero so we know this was an\n+\t   actual function definition.  */\n+\tDECL_INITIAL (fn) = error_mark_node;\n+    }\n+  \n   /* Let the error reporting routines know that we're outside a\n      function.  For a nested function, this value is used in\n      pop_cp_function_context and then reset via pop_function_context.  */\n   current_function_decl = NULL_TREE;\n }\n \n+/* Clear out the DECL_RTL for the non-static variables in BLOCK and\n+   its sub-blocks.  */\n+\n+static tree\n+clear_decl_rtl (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  if (nonstatic_local_decl_p (*tp)) \n+    SET_DECL_RTL (*tp, NULL_RTX);\n+    \n+  return NULL_TREE;\n+}\n+\n /* Perform initialization related to this module.  */\n \n void"}, {"sha": "5c7ee808ad2db16ebe1a210cc6e2f36cc96a0f74", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -1,3 +1,7 @@\n+Mon Mar 26 18:13:30 2001  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* com.c (duplicate_decls): Don't copy DECL_FRAME_SIZE.\n+\n Mon Mar 19 15:05:39 2001  Mark Mitchell  <mark@codesourcery.com>\n \n \t* com.c (builtin_function): Use SET_DECL_ASSEMBLER_NAME."}, {"sha": "749b72fd04dd33f45454587ad4af49efbf2c6801", "filename": "gcc/f/com.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -13743,8 +13743,6 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);\n \t  DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n \t}\n-      else\n-\tDECL_FRAME_SIZE (newdecl) = DECL_FRAME_SIZE (olddecl);\n \n       DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n       DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);"}, {"sha": "76104c06f396e4db3310b06fa6c943cbe01a96eb", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -892,9 +892,6 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t     incoming arg rtx values are expanded now so that we can be\n \t     sure we have enough slots in the const equiv map since the\n \t     store_expr call can easily blow the size estimate.  */\n-\t  if (DECL_FRAME_SIZE (fndecl) != 0)\n-\t    copy_rtx_and_substitute (virtual_stack_vars_rtx, map, 0);\n-\n \t  if (DECL_SAVED_INSNS (fndecl)->args_size != 0)\n \t    copy_rtx_and_substitute (virtual_incoming_args_rtx, map, 0);\n \t}"}, {"sha": "397f670c1ed9d92b2e0a4449fd138bef4c042763", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -1,3 +1,7 @@\n+2001-03-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* parse.h (DECL_END_SOURCE_LINE): Don't rely on DECL_FRAME_SIZE.\n+\n 2001-03-26  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* parse.y (find_as_inner_class): Follow current package"}, {"sha": "3ca2141da548212890a37cd71a79a133d2c488f2", "filename": "gcc/java/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -720,7 +720,7 @@ typedef struct _jdeplist {\n #define CURRENT_OSB(C) (C)->osb_number [(C)->osb_depth]\n \n /* Macro for the xreferencer */\n-#define DECL_END_SOURCE_LINE(DECL)       DECL_FRAME_SIZE (DECL)\n+#define DECL_END_SOURCE_LINE(DECL)       (DECL_CHECK (DECL)->decl.u1.i)\n #define DECL_INHERITED_SOURCE_LINE(DECL) (DECL_CHECK (DECL)->decl.u2.i)\n      \n /* Parser context data structure. */"}, {"sha": "54a598eea4ecfc798974aa7dc12464459a0849e3", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -402,11 +402,6 @@ print_node (file, prefix, node, indent)\n \t\t       DECL_OFFSET_ALIGN (node));\n \t    }\n \t}\n-      else if (DECL_INLINE (node))\n-\t{\n-\t  fprintf (file, \" frame_size \");\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, DECL_FRAME_SIZE (node));\n-\t}\n       else if (DECL_BUILT_IN (node))\n \t{\n \t  if (DECL_BUILT_IN_CLASS (node) == BUILT_IN_MD)"}, {"sha": "3c7d0ab74aa63134b42c4652c39d3564e0b1d86c", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -2775,7 +2775,8 @@ rest_of_compilation (decl)\n \t  }\n \n       /* If requested, consider whether to make this function inline.  */\n-      if (DECL_INLINE (decl) || flag_inline_functions)\n+      if ((DECL_INLINE (decl) && !flag_no_inline) \n+\t  || flag_inline_functions)\n \t{\n \t  timevar_push (TV_INTEGRATION);\n \t  lose = function_cannot_inline_p (decl);"}, {"sha": "f1470afb9a6430ad69d55358e6aec1c0bdb34d90", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b850de4faa9430a721ffeee7aacd968c2b1befad/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b850de4faa9430a721ffeee7aacd968c2b1befad", "patch": "@@ -1396,9 +1396,6 @@ struct tree_type\n #define DECL_INCOMING_RTL(NODE) (PARM_DECL_CHECK (NODE)->decl.u2.r)\n /* For FUNCTION_DECL, if it is inline, holds the saved insn chain.  */\n #define DECL_SAVED_INSNS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u2.f)\n-/* For FUNCTION_DECL, if it is inline,\n-   holds the size of the stack frame, as an integer.  */\n-#define DECL_FRAME_SIZE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n /* For FUNCTION_DECL, if it is built-in,\n    this identifies which built-in operation it is.  */\n #define DECL_FUNCTION_CODE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u1.f)\n@@ -1691,12 +1688,15 @@ struct tree_decl\n   unsigned lang_flag_6 : 1;\n   unsigned lang_flag_7 : 1;\n \n-  /* For a FUNCTION_DECL, if inline, this is the size of frame needed.\n-     If built-in, this is the code for which built-in function.\n-     For other kinds of decls, this is DECL_ALIGN and DECL_OFFSET_ALIGN.  */\n   union {\n-    HOST_WIDE_INT i;\n+    /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n+       DECL_FUNCTION_CODE.  */\n     enum built_in_function f;\n+    /* In a FUNCITON_DECL for which DECL_BUILT_IN does not hold, this\n+       is used by language-dependent code.  */\n+    HOST_WIDE_INT i;\n+    /* DECL_ALIGN and DECL_OFFSET_ALIGN.  (These are not used for\n+       FUNCTION_DECLs).  */\n     struct {unsigned int align : 24; unsigned int off_align : 8;} a;\n   } u1;\n "}]}