{"sha": "2dcfc8722b6146e479039a2f8994050c772b25e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRjZmM4NzIyYjYxNDZlNDc5MDM5YTJmODk5NDA1MGM3NzJiMjVlNg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-05-02T08:16:12Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-05-02T08:16:12Z"}, "message": "Postpone print of --help=* option.\n\n2019-05-02  Martin Liska  <mliska@suse.cz>\n\n\t* gcc.c (process_command): Add dummy file only\n\tif n_infiles == 0.\n\t* opts-global.c (decode_options): Pass lang_mask.\n\t* opts.c (print_help): New function.\n\t(finish_options): Print --help if help_option_argument\n\tis set.\n\t(common_handle_option): Factor out content of OPT__help_\n\tinto print_help.\n\t* opts.h (finish_options): Add new argument.\n\nFrom-SVN: r270788", "tree": {"sha": "1fa0518e606198867e6361602184e0b1795ca3db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fa0518e606198867e6361602184e0b1795ca3db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dcfc8722b6146e479039a2f8994050c772b25e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dcfc8722b6146e479039a2f8994050c772b25e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dcfc8722b6146e479039a2f8994050c772b25e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dcfc8722b6146e479039a2f8994050c772b25e6/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "786e0e5239529de9a4254fe8411a0e8f843e721a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786e0e5239529de9a4254fe8411a0e8f843e721a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786e0e5239529de9a4254fe8411a0e8f843e721a"}], "stats": {"total": 289, "additions": 158, "deletions": 131}, "files": [{"sha": "a6ce52335d5de2bb187de434c008a4ee3435a2be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2dcfc8722b6146e479039a2f8994050c772b25e6", "patch": "@@ -1,3 +1,15 @@\n+2019-05-02  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc.c (process_command): Add dummy file only\n+\tif n_infiles == 0.\n+\t* opts-global.c (decode_options): Pass lang_mask.\n+\t* opts.c (print_help): New function.\n+\t(finish_options): Print --help if help_option_argument\n+\tis set.\n+\t(common_handle_option): Factor out content of OPT__help_\n+\tinto print_help.\n+\t* opts.h (finish_options): Add new argument.\n+\n 2019-05-02  Martin Liska  <mliska@suse.cz>\n \n \tPR target/88809"}, {"sha": "a1003a5cdf93affa0c345c6f61606d4e2edd4624", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=2dcfc8722b6146e479039a2f8994050c772b25e6", "patch": "@@ -4751,10 +4751,9 @@ process_command (unsigned int decoded_options_count,\n     }\n \n   /* Ensure we only invoke each subprocess once.  */\n-  if (print_subprocess_help || print_help_list || print_version)\n+  if (n_infiles == 0\n+      && (print_subprocess_help || print_help_list || print_version))\n     {\n-      n_infiles = 0;\n-\n       /* Create a dummy input file, so that we can pass\n \t the help option on to the various sub-processes.  */\n       add_infile (\"help-dummy\", \"c\");"}, {"sha": "f110fe1026fb87c5bdd8f7c104946c1f3c6e008f", "filename": "gcc/opts-global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2Fopts-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2Fopts-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-global.c?ref=2dcfc8722b6146e479039a2f8994050c772b25e6", "patch": "@@ -314,7 +314,7 @@ decode_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \t\t\tloc, lang_mask,\n \t\t\t&handlers, dc);\n \n-  finish_options (opts, opts_set, loc);\n+  finish_options (opts, opts_set, loc, lang_mask);\n }\n \n /* Hold command-line options associated with stack limitation.  */"}, {"sha": "286bb8f5402bc2e07119e29c9b53284dd5196bd1", "filename": "gcc/opts.c", "status": "modified", "additions": 141, "deletions": 126, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=2dcfc8722b6146e479039a2f8994050c772b25e6", "patch": "@@ -855,12 +855,18 @@ control_options_for_live_patching (struct gcc_options *opts,\n     }\n }\n \n+/* --help option argument if set.  */\n+const char *help_option_argument = NULL;\n+\n+static void print_help (struct gcc_options *opts, unsigned int lang_mask);\n+\n+\n /* After all options at LOC have been read into OPTS and OPTS_SET,\n    finalize settings of those options and diagnose incompatible\n    combinations.  */\n void\n finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n-\t\tlocation_t loc)\n+\t\tlocation_t loc, unsigned int lang_mask)\n {\n   enum unwind_info_type ui_except;\n \n@@ -1224,6 +1230,10 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \t\t\t\t\t opts->x_flag_live_patching,\n \t\t\t\t\t loc);\n     }\n+\n+  /* Print --help=* if used.  */\n+  if (help_option_argument != NULL)\n+    print_help (opts, lang_mask);\n }\n \n #define LEFT_COLUMN\t27\n@@ -2054,6 +2064,135 @@ check_alignment_argument (location_t loc, const char *flag, const char *name)\n   parse_and_check_align_values (flag, name, align_result, true, loc);\n }\n \n+/* Print help when OPT__help_ is set.  */\n+\n+static void\n+print_help (struct gcc_options *opts, unsigned int lang_mask)\n+{\n+  const char *a = help_option_argument;\n+  unsigned int include_flags = 0;\n+  /* Note - by default we include undocumented options when listing\n+     specific classes.  If you only want to see documented options\n+     then add \",^undocumented\" to the --help= option.  E.g.:\n+\n+     --help=target,^undocumented  */\n+  unsigned int exclude_flags = 0;\n+\n+  if (lang_mask == CL_DRIVER)\n+    return;\n+\n+  /* Walk along the argument string, parsing each word in turn.\n+     The format is:\n+     arg = [^]{word}[,{arg}]\n+     word = {optimizers|target|warnings|undocumented|\n+     params|common|<language>}  */\n+  while (*a != 0)\n+    {\n+      static const struct\n+\t{\n+\t  const char *string;\n+\t  unsigned int flag;\n+\t}\n+      specifics[] =\n+\t{\n+\t    { \"optimizers\", CL_OPTIMIZATION },\n+\t    { \"target\", CL_TARGET },\n+\t    { \"warnings\", CL_WARNING },\n+\t    { \"undocumented\", CL_UNDOCUMENTED },\n+\t    { \"params\", CL_PARAMS },\n+\t    { \"joined\", CL_JOINED },\n+\t    { \"separate\", CL_SEPARATE },\n+\t    { \"common\", CL_COMMON },\n+\t    { NULL, 0 }\n+\t};\n+      unsigned int *pflags;\n+      const char *comma;\n+      unsigned int lang_flag, specific_flag;\n+      unsigned int len;\n+      unsigned int i;\n+\n+      if (*a == '^')\n+\t{\n+\t  ++a;\n+\t  if (*a == '\\0')\n+\t    {\n+\t      error (\"missing argument to %qs\", \"--help=^\");\n+\t      break;\n+\t    }\n+\t  pflags = &exclude_flags;\n+\t}\n+      else\n+\tpflags = &include_flags;\n+\n+      comma = strchr (a, ',');\n+      if (comma == NULL)\n+\tlen = strlen (a);\n+      else\n+\tlen = comma - a;\n+      if (len == 0)\n+\t{\n+\t  a = comma + 1;\n+\t  continue;\n+\t}\n+\n+      /* Check to see if the string matches an option class name.  */\n+      for (i = 0, specific_flag = 0; specifics[i].string != NULL; i++)\n+\tif (strncasecmp (a, specifics[i].string, len) == 0)\n+\t  {\n+\t    specific_flag = specifics[i].flag;\n+\t    break;\n+\t  }\n+\n+      /* Check to see if the string matches a language name.\n+\t Note - we rely upon the alpha-sorted nature of the entries in\n+\t the lang_names array, specifically that shorter names appear\n+\t before their longer variants.  (i.e. C before C++).  That way\n+\t when we are attempting to match --help=c for example we will\n+\t match with C first and not C++.  */\n+      for (i = 0, lang_flag = 0; i < cl_lang_count; i++)\n+\tif (strncasecmp (a, lang_names[i], len) == 0)\n+\t  {\n+\t    lang_flag = 1U << i;\n+\t    break;\n+\t  }\n+\n+      if (specific_flag != 0)\n+\t{\n+\t  if (lang_flag == 0)\n+\t    *pflags |= specific_flag;\n+\t  else\n+\t    {\n+\t      /* The option's argument matches both the start of a\n+\t\t language name and the start of an option class name.\n+\t\t We have a special case for when the user has\n+\t\t specified \"--help=c\", but otherwise we have to issue\n+\t\t a warning.  */\n+\t      if (strncasecmp (a, \"c\", len) == 0)\n+\t\t*pflags |= lang_flag;\n+\t      else\n+\t\twarning (0,\n+\t\t\t \"--help argument %q.*s is ambiguous, \"\n+\t\t\t \"please be more specific\",\n+\t\t\t len, a);\n+\t    }\n+\t}\n+      else if (lang_flag != 0)\n+\t*pflags |= lang_flag;\n+      else\n+\twarning (0,\n+\t\t \"unrecognized argument to --help= option: %q.*s\",\n+\t\t len, a);\n+\n+      if (comma == NULL)\n+\tbreak;\n+      a = comma + 1;\n+    }\n+\n+  if (include_flags)\n+    print_specific_help (include_flags, exclude_flags, 0, opts,\n+\t\t\t lang_mask);\n+}\n+\n /* Handle target- and language-independent options.  Return zero to\n    generate an \"unknown option\" message.  Only options that need\n    extra handling need to be listed here; if you simply want\n@@ -2121,131 +2260,7 @@ common_handle_option (struct gcc_options *opts,\n \n     case OPT__help_:\n       {\n-\tconst char *a = arg;\n-\tunsigned int include_flags = 0;\n-\t/* Note - by default we include undocumented options when listing\n-\t   specific classes.  If you only want to see documented options\n-\t   then add \",^undocumented\" to the --help= option.  E.g.:\n-\n-\t   --help=target,^undocumented  */\n-\tunsigned int exclude_flags = 0;\n-\n-\tif (lang_mask == CL_DRIVER)\n-\t  break;\n-\n-\t/* Walk along the argument string, parsing each word in turn.\n-\t   The format is:\n-\t   arg = [^]{word}[,{arg}]\n-\t   word = {optimizers|target|warnings|undocumented|\n-\t\t   params|common|<language>}  */\n-\twhile (*a != 0)\n-\t  {\n-\t    static const struct\n-\t    {\n-\t      const char *string;\n-\t      unsigned int flag;\n-\t    }\n-\t    specifics[] =\n-\t    {\n-\t      { \"optimizers\", CL_OPTIMIZATION },\n-\t      { \"target\", CL_TARGET },\n-\t      { \"warnings\", CL_WARNING },\n-\t      { \"undocumented\", CL_UNDOCUMENTED },\n-\t      { \"params\", CL_PARAMS },\n-\t      { \"joined\", CL_JOINED },\n-\t      { \"separate\", CL_SEPARATE },\n-\t      { \"common\", CL_COMMON },\n-\t      { NULL, 0 }\n-\t    };\n-\t    unsigned int *pflags;\n-\t    const char *comma;\n-\t    unsigned int lang_flag, specific_flag;\n-\t    unsigned int len;\n-\t    unsigned int i;\n-\n-\t    if (*a == '^')\n-\t      {\n-\t\t++a;\n-\t\tif (*a == '\\0')\n-\t\t  {\n-\t\t    error_at (loc, \"missing argument to %qs\", \"--help=^\");\n-\t\t    break;\n-\t\t  }\n-\t\tpflags = &exclude_flags;\n-\t      }\n-\t    else\n-\t      pflags = &include_flags;\n-\n-\t    comma = strchr (a, ',');\n-\t    if (comma == NULL)\n-\t      len = strlen (a);\n-\t    else\n-\t      len = comma - a;\n-\t    if (len == 0)\n-\t      {\n-\t\ta = comma + 1;\n-\t\tcontinue;\n-\t      }\n-\n-\t    /* Check to see if the string matches an option class name.  */\n-\t    for (i = 0, specific_flag = 0; specifics[i].string != NULL; i++)\n-\t      if (strncasecmp (a, specifics[i].string, len) == 0)\n-\t\t{\n-\t\t  specific_flag = specifics[i].flag;\n-\t\t  break;\n-\t\t}\n-\n-\t    /* Check to see if the string matches a language name.\n-\t       Note - we rely upon the alpha-sorted nature of the entries in\n-\t       the lang_names array, specifically that shorter names appear\n-\t       before their longer variants.  (i.e. C before C++).  That way\n-\t       when we are attempting to match --help=c for example we will\n-\t       match with C first and not C++.  */\n-\t    for (i = 0, lang_flag = 0; i < cl_lang_count; i++)\n-\t      if (strncasecmp (a, lang_names[i], len) == 0)\n-\t\t{\n-\t\t  lang_flag = 1U << i;\n-\t\t  break;\n-\t\t}\n-\n-\t    if (specific_flag != 0)\n-\t      {\n-\t\tif (lang_flag == 0)\n-\t\t  *pflags |= specific_flag;\n-\t\telse\n-\t\t  {\n-\t\t    /* The option's argument matches both the start of a\n-\t\t       language name and the start of an option class name.\n-\t\t       We have a special case for when the user has\n-\t\t       specified \"--help=c\", but otherwise we have to issue\n-\t\t       a warning.  */\n-\t\t    if (strncasecmp (a, \"c\", len) == 0)\n-\t\t      *pflags |= lang_flag;\n-\t\t    else\n-\t\t      warning_at (loc, 0,\n-\t\t\t\t  \"--help argument %q.*s is ambiguous, \"\n-\t\t\t\t  \"please be more specific\",\n-\t\t\t\t  len, a);\n-\t\t  }\n-\t      }\n-\t    else if (lang_flag != 0)\n-\t      *pflags |= lang_flag;\n-\t    else\n-\t      warning_at (loc, 0,\n-\t\t\t  \"unrecognized argument to --help= option: %q.*s\",\n-\t\t\t  len, a);\n-\n-\t    if (comma == NULL)\n-\t      break;\n-\t    a = comma + 1;\n-\t  }\n-\n-\tif (include_flags)\n-\t  {\n-\t    target_option_override_hook ();\n-\t    print_specific_help (include_flags, exclude_flags, 0, opts,\n-\t\t\t\t lang_mask);\n-\t  }\n+\thelp_option_argument = arg;\n \topts->x_exit_after_options = true;\n \tbreak;\n       }"}, {"sha": "6e99eaddbaf5e81a12bb11b1464310d8e9857eb9", "filename": "gcc/opts.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dcfc8722b6146e479039a2f8994050c772b25e6/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=2dcfc8722b6146e479039a2f8994050c772b25e6", "patch": "@@ -418,7 +418,8 @@ extern bool target_handle_option (struct gcc_options *opts,\n \t\t\t\t  void (*target_option_override_hook) (void));\n extern void finish_options (struct gcc_options *opts,\n \t\t\t    struct gcc_options *opts_set,\n-\t\t\t    location_t loc);\n+\t\t\t    location_t loc,\n+\t\t\t    unsigned int lang_mask);\n extern void default_options_optimization (struct gcc_options *opts,\n \t\t\t\t\t  struct gcc_options *opts_set,\n \t\t\t\t\t  struct cl_decoded_option *decoded_options,"}]}