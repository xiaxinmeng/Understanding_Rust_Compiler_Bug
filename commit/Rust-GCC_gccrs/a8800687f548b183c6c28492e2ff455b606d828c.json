{"sha": "a8800687f548b183c6c28492e2ff455b606d828c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg4MDA2ODdmNTQ4YjE4M2M2YzI4NDkyZTJmZjQ1NWI2MDZkODI4Yw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2009-02-10T14:00:46Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2009-02-10T14:00:46Z"}, "message": "re PR target/39119 (Update classification of aggregates with __m256)\n\ngcc/\n\n2009-02-10  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/39119\n\t* config/i386/i386.c (x86_64_reg_class): Remove X86_64_AVX_CLASS.\n\t(x86_64_reg_class_name): Removed.\n\t(classify_argument): Return 0 if bytes > 32.  Return 0 if the\n\tfirst one isn't X86_64_SSE_CLASS or any other ones aren't\n\tX86_64_SSEUP_CLASS when size > 16bytes.  Don't turn\n\tX86_64_SSEUP_CLASS into X86_64_SSE_CLASS if the preceded one\n\tis X86_64_SSEUP_CLASS.  Set AVX modes to 1 X86_64_SSE_CLASS\n\tand 3 X86_64_SSEUP_CLASS.\n\t(construct_container): Remove X86_64_AVX_CLASS.  Handle 4\n\tregisters with 1 X86_64_SSE_CLASS and 3 X86_64_SSEUP_CLASS.\n\ngcc/testsuite/\n\n2009-02-10  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/39119\n\t* gcc.target/x86_64/abi/avx/abi-avx.exp: New.\n\t* gcc.target/x86_64/abi/avx/args.h: Likewise.\n\t* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.\n\t* gcc.target/x86_64/abi/avx/avx-check.h: Likewise.\n\t* gcc.target/x86_64/abi/avx/test_m256_returning.c: Likewise.\n\t* gcc.target/x86_64/abi/avx/test_passing_m256.c: Likewise.\n\t* gcc.target/x86_64/abi/avx/test_passing_structs.c: Likewise.\n\t* gcc.target/x86_64/abi/avx/test_passing_unions.c: Likewise.\n\nFrom-SVN: r144058", "tree": {"sha": "e3d95e4d270dbd6adc7a351ffd73f3c02764c0ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3d95e4d270dbd6adc7a351ffd73f3c02764c0ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8800687f548b183c6c28492e2ff455b606d828c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8800687f548b183c6c28492e2ff455b606d828c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8800687f548b183c6c28492e2ff455b606d828c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8800687f548b183c6c28492e2ff455b606d828c/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7459b6c53c4633371442d020051707bfcfcbdf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7459b6c53c4633371442d020051707bfcfcbdf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7459b6c53c4633371442d020051707bfcfcbdf1"}], "stats": {"total": 831, "additions": 814, "deletions": 17}, "files": [{"sha": "d18f8cc1c22eba507b1f2f3a6843e21b8d3a7888", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -1,3 +1,17 @@\n+2009-02-10  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/39119\n+\t* config/i386/i386.c (x86_64_reg_class): Remove X86_64_AVX_CLASS.\n+\t(x86_64_reg_class_name): Removed.\n+\t(classify_argument): Return 0 if bytes > 32.  Return 0 if the\n+\tfirst one isn't X86_64_SSE_CLASS or any other ones aren't\n+\tX86_64_SSEUP_CLASS when size > 16bytes.  Don't turn\n+\tX86_64_SSEUP_CLASS into X86_64_SSE_CLASS if the preceded one\n+\tis X86_64_SSEUP_CLASS.  Set AVX modes to 1 X86_64_SSE_CLASS\n+\tand 3 X86_64_SSEUP_CLASS.\n+\t(construct_container): Remove X86_64_AVX_CLASS.  Handle 4\n+\tregisters with 1 X86_64_SSE_CLASS and 3 X86_64_SSEUP_CLASS.\n+\n 2009-02-10  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/rs6000/rs6000.md (allocate_stack): Always use an update"}, {"sha": "7c25a1870263f4331ea92acef0a9e7b03ce8b450", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -1773,7 +1773,6 @@ enum x86_64_reg_class\n     X86_64_NO_CLASS,\n     X86_64_INTEGER_CLASS,\n     X86_64_INTEGERSI_CLASS,\n-    X86_64_AVX_CLASS,\n     X86_64_SSE_CLASS,\n     X86_64_SSESF_CLASS,\n     X86_64_SSEDF_CLASS,\n@@ -1783,11 +1782,6 @@ enum x86_64_reg_class\n     X86_64_COMPLEX_X87_CLASS,\n     X86_64_MEMORY_CLASS\n   };\n-static const char * const x86_64_reg_class_name[] =\n-{\n-  \"no\", \"integer\", \"integerSI\", \"sse\", \"sseSF\", \"sseDF\",\n-  \"sseup\", \"x87\", \"x87up\", \"cplx87\", \"no\"\n-};\n \n #define MAX_CLASSES 4\n \n@@ -4863,8 +4857,8 @@ classify_argument (enum machine_mode mode, const_tree type,\n       tree field;\n       enum x86_64_reg_class subclasses[MAX_CLASSES];\n \n-      /* On x86-64 we pass structures larger than 16 bytes on the stack.  */\n-      if (bytes > 16)\n+      /* On x86-64 we pass structures larger than 32 bytes on the stack.  */\n+      if (bytes > 32)\n \treturn 0;\n \n       for (i = 0; i < words; i++)\n@@ -4974,6 +4968,20 @@ classify_argument (enum machine_mode mode, const_tree type,\n \t  gcc_unreachable ();\n \t}\n \n+      if (words > 2)\n+\t{\n+\t  /* When size > 16 bytes, if the first one isn't\n+\t     X86_64_SSE_CLASS or any other ones aren't\n+\t     X86_64_SSEUP_CLASS, everything should be passed in\n+\t     memory.  */\n+\t  if (classes[0] != X86_64_SSE_CLASS)\n+\t      return 0;\n+\n+\t  for (i = 1; i < words; i++)\n+\t    if (classes[i] != X86_64_SSEUP_CLASS)\n+\t      return 0;\n+\t}\n+\n       /* Final merger cleanup.  */\n       for (i = 0; i < words; i++)\n \t{\n@@ -4983,10 +4991,15 @@ classify_argument (enum machine_mode mode, const_tree type,\n \t    return 0;\n \n \t  /* The X86_64_SSEUP_CLASS should be always preceded by\n-\t     X86_64_SSE_CLASS.  */\n+\t     X86_64_SSE_CLASS or X86_64_SSEUP_CLASS.  */\n \t  if (classes[i] == X86_64_SSEUP_CLASS\n-\t      && (i == 0 || classes[i - 1] != X86_64_SSE_CLASS))\n-\t    classes[i] = X86_64_SSE_CLASS;\n+\t      && classes[i - 1] != X86_64_SSE_CLASS\n+\t      && classes[i - 1] != X86_64_SSEUP_CLASS)\n+\t    {\n+\t      /* The first one should never be X86_64_SSEUP_CLASS.  */\n+\t      gcc_assert (i != 0);\n+\t      classes[i] = X86_64_SSE_CLASS;\n+\t    }\n \n \t  /*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */\n \t  if (classes[i] == X86_64_X87UP_CLASS\n@@ -5107,8 +5120,11 @@ classify_argument (enum machine_mode mode, const_tree type,\n     case V16HImode:\n     case V4DFmode:\n     case V4DImode:\n-      classes[0] = X86_64_AVX_CLASS;\n-      return 1;\n+      classes[0] = X86_64_SSE_CLASS;\n+      classes[1] = X86_64_SSEUP_CLASS;\n+      classes[2] = X86_64_SSEUP_CLASS;\n+      classes[3] = X86_64_SSEUP_CLASS;\n+      return 4;\n     case V4SFmode:\n     case V4SImode:\n     case V16QImode:\n@@ -5165,7 +5181,6 @@ examine_argument (enum machine_mode mode, const_tree type, int in_return,\n       case X86_64_INTEGERSI_CLASS:\n \t(*int_nregs)++;\n \tbreak;\n-      case X86_64_AVX_CLASS:\n       case X86_64_SSE_CLASS:\n       case X86_64_SSESF_CLASS:\n       case X86_64_SSEDF_CLASS:\n@@ -5264,7 +5279,6 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n       case X86_64_INTEGER_CLASS:\n       case X86_64_INTEGERSI_CLASS:\n \treturn gen_rtx_REG (mode, intreg[0]);\n-      case X86_64_AVX_CLASS:\n       case X86_64_SSE_CLASS:\n       case X86_64_SSESF_CLASS:\n       case X86_64_SSEDF_CLASS:\n@@ -5281,6 +5295,13 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n   if (n == 2 && regclass[0] == X86_64_SSE_CLASS\n       && regclass[1] == X86_64_SSEUP_CLASS && mode != BLKmode)\n     return gen_rtx_REG (mode, SSE_REGNO (sse_regno));\n+  if (n == 4\n+      && regclass[0] == X86_64_SSE_CLASS\n+      && regclass[1] == X86_64_SSEUP_CLASS\n+      && regclass[2] == X86_64_SSEUP_CLASS\n+      && regclass[3] == X86_64_SSEUP_CLASS\n+      && mode != BLKmode)\n+    return gen_rtx_REG (mode, SSE_REGNO (sse_regno));\n \n   if (n == 2\n       && regclass[0] == X86_64_X87_CLASS && regclass[1] == X86_64_X87UP_CLASS)\n@@ -5331,14 +5352,22 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n \t    break;\n \t  case X86_64_SSE_CLASS:\n \t    if (i < n - 1 && regclass[i + 1] == X86_64_SSEUP_CLASS)\n-\t      tmpmode = TImode;\n+\t      {\n+\t\tif (regclass[i + 2] == X86_64_SSEUP_CLASS\n+\t\t    || regclass[i + 3] == X86_64_SSEUP_CLASS)\n+\t\t  tmpmode = OImode;\n+\t\telse\n+\t\t  tmpmode = TImode;\n+\t      }\n \t    else\n \t      tmpmode = DImode;\n \t    exp [nexps++] = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t       gen_rtx_REG (tmpmode,\n \t\t\t\t\t\t\t    SSE_REGNO (sse_regno)),\n \t\t\t\t\t       GEN_INT (i*8));\n-\t    if (tmpmode == TImode)\n+\t    if (tmpmode == OImode)\n+\t      i += 3;\n+\t    else if (tmpmode == TImode)\n \t      i++;\n \t    sse_regno++;\n \t    break;"}, {"sha": "15a7facc31ff4ca889a3921e2e5239dd28acf4db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -1,3 +1,15 @@\n+2009-02-10  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/39119\n+\t* gcc.target/x86_64/abi/avx/abi-avx.exp: New.\n+\t* gcc.target/x86_64/abi/avx/args.h: Likewise.\n+\t* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.\n+\t* gcc.target/x86_64/abi/avx/avx-check.h: Likewise.\n+\t* gcc.target/x86_64/abi/avx/test_m256_returning.c: Likewise.\n+\t* gcc.target/x86_64/abi/avx/test_passing_m256.c: Likewise.\n+\t* gcc.target/x86_64/abi/avx/test_passing_structs.c: Likewise.\n+\t* gcc.target/x86_64/abi/avx/test_passing_unions.c: Likewise.\n+\n 2009-02-09  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/39109"}, {"sha": "e5561283d304a268fc65e508b6673bbd8543fb8c", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/abi-avx.exp", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fabi-avx.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fabi-avx.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fabi-avx.exp?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -0,0 +1,50 @@\n+# Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# The x86-64 AVX ABI testsuite needs one additional assembler file for most\n+# testcases.  For simplicity we will just link it into each test.\n+\n+load_lib c-torture.exp\n+load_lib target-supports.exp\n+load_lib torture-options.exp\n+\n+if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n+     || ![is-effective-target lp64]\n+     || ![is-effective-target avx] } then {\n+  return\n+}\n+\n+\n+torture-init\n+set-torture-options $C_TORTURE_OPTIONS\n+set additional_flags \"-W -Wall -mavx\"\n+\n+foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {\n+    if {[runtest_file_p $runtests $src]} {\n+\tif { ([istarget *-*-darwin*]) } then {\n+\t    # FIXME: Darwin isn't tested.\n+\t    c-torture-execute [list $src \\\n+\t\t\t\t    $srcdir/$subdir/asm-support-darwin.s] \\\n+\t\t\t\t    $additional_flags\n+\t} else {\n+\t    c-torture-execute [list $src \\\n+\t\t\t\t    $srcdir/$subdir/asm-support.S] \\\n+\t\t\t\t    $additional_flags\n+\t}\n+    }\n+}\n+\n+torture-finish"}, {"sha": "5fa4a5e6c42b86dd0495feb5d9d82bf2519a4fd9", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/args.h", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fargs.h?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -0,0 +1,180 @@\n+#ifndef INCLUDED_ARGS_H\n+#define INCLUDED_ARGS_H\n+\n+#include <immintrin.h>\n+#include <string.h>\n+\n+/* Assertion macro.  */\n+#define assert(test) if (!(test)) abort()\n+\n+#ifdef __GNUC__\n+#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n+#else\n+#define ATTRIBUTE_UNUSED\n+#endif\n+\n+/* This defines the calling sequences for integers and floats.  */\n+#define I0 rdi\n+#define I1 rsi\n+#define I2 rdx\n+#define I3 rcx\n+#define I4 r8\n+#define I5 r9\n+#define F0 ymm0\n+#define F1 ymm1\n+#define F2 ymm2\n+#define F3 ymm3\n+#define F4 ymm4\n+#define F5 ymm5\n+#define F6 ymm6\n+#define F7 ymm7\n+\n+typedef union {\n+  float _float[8];\n+  double _double[4];\n+  long _long[4];\n+  int _int[8];\n+  unsigned long _ulong[4];\n+  __m64 _m64[4];\n+  __m128 _m128[2];\n+  __m256 _m256[1];\n+} YMM_T;\n+\n+typedef union {\n+  float _float;\n+  double _double;\n+  long double _ldouble;\n+  unsigned long _ulong[2];\n+} X87_T;\n+extern void (*callthis)(void);\n+extern unsigned long rax,rbx,rcx,rdx,rsi,rdi,rsp,rbp,r8,r9,r10,r11,r12,r13,r14,r15;\n+YMM_T ymm_regs[16];\n+X87_T x87_regs[8];\n+extern volatile unsigned long volatile_var;\n+extern void snapshot (void);\n+extern void snapshot_ret (void);\n+#define WRAP_CALL(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot)\n+#define WRAP_RET(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot_ret)\n+\n+/* Clear all integer registers.  */\n+#define clear_int_hardware_registers \\\n+  asm __volatile__ (\"xor %%rax, %%rax\\n\\t\" \\\n+\t\t    \"xor %%rbx, %%rbx\\n\\t\" \\\n+\t\t    \"xor %%rcx, %%rcx\\n\\t\" \\\n+\t\t    \"xor %%rdx, %%rdx\\n\\t\" \\\n+\t\t    \"xor %%rsi, %%rsi\\n\\t\" \\\n+\t\t    \"xor %%rdi, %%rdi\\n\\t\" \\\n+\t\t    \"xor %%r8, %%r8\\n\\t\" \\\n+\t\t    \"xor %%r9, %%r9\\n\\t\" \\\n+\t\t    \"xor %%r10, %%r10\\n\\t\" \\\n+\t\t    \"xor %%r11, %%r11\\n\\t\" \\\n+\t\t    \"xor %%r12, %%r12\\n\\t\" \\\n+\t\t    \"xor %%r13, %%r13\\n\\t\" \\\n+\t\t    \"xor %%r14, %%r14\\n\\t\" \\\n+\t\t    \"xor %%r15, %%r15\\n\\t\" \\\n+\t\t    ::: \"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \\\n+\t\t    \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\");\n+\n+/* This is the list of registers available for passing arguments. Not all of\n+   these are used or even really available.  */\n+struct IntegerRegisters\n+{\n+  unsigned long rax, rbx, rcx, rdx, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15;\n+};\n+struct FloatRegisters\n+{\n+  double mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7;\n+  long double st0, st1, st2, st3, st4, st5, st6, st7;\n+  YMM_T ymm0, ymm1, ymm2, ymm3, ymm4, ymm5, ymm6, ymm7, ymm8, ymm9,\n+        ymm10, ymm11, ymm12, ymm13, ymm14, ymm15;\n+};\n+\n+/* Implemented in scalarargs.c  */\n+extern struct IntegerRegisters iregs;\n+extern struct FloatRegisters fregs;\n+extern unsigned int num_iregs, num_fregs;\n+\n+#define check_int_arguments do { \\\n+  assert (num_iregs <= 0 || iregs.I0 == I0); \\\n+  assert (num_iregs <= 1 || iregs.I1 == I1); \\\n+  assert (num_iregs <= 2 || iregs.I2 == I2); \\\n+  assert (num_iregs <= 3 || iregs.I3 == I3); \\\n+  assert (num_iregs <= 4 || iregs.I4 == I4); \\\n+  assert (num_iregs <= 5 || iregs.I5 == I5); \\\n+  } while (0)\n+\n+#define check_char_arguments check_int_arguments\n+#define check_short_arguments check_int_arguments\n+#define check_long_arguments check_int_arguments\n+\n+/* Clear register struct.  */\n+#define clear_struct_registers \\\n+  rax = rbx = rcx = rdx = rdi = rsi = rbp = rsp \\\n+    = r8 = r9 = r10 = r11 = r12 = r13 = r14 = r15 = 0; \\\n+  memset (&iregs, 0, sizeof (iregs)); \\\n+  memset (&fregs, 0, sizeof (fregs)); \\\n+  memset (ymm_regs, 0, sizeof (ymm_regs)); \\\n+  memset (x87_regs, 0, sizeof (x87_regs));\n+\n+/* Clear both hardware and register structs for integers.  */\n+#define clear_int_registers \\\n+  clear_struct_registers \\\n+  clear_int_hardware_registers\n+\n+/* TODO: Do the checking.  */\n+#define check_f_arguments(T) do { \\\n+  assert (num_fregs <= 0 || fregs.ymm0._ ## T [0] == ymm_regs[0]._ ## T [0]); \\\n+  assert (num_fregs <= 1 || fregs.ymm1._ ## T [0] == ymm_regs[1]._ ## T [0]); \\\n+  assert (num_fregs <= 2 || fregs.ymm2._ ## T [0] == ymm_regs[2]._ ## T [0]); \\\n+  assert (num_fregs <= 3 || fregs.ymm3._ ## T [0] == ymm_regs[3]._ ## T [0]); \\\n+  assert (num_fregs <= 4 || fregs.ymm4._ ## T [0] == ymm_regs[4]._ ## T [0]); \\\n+  assert (num_fregs <= 5 || fregs.ymm5._ ## T [0] == ymm_regs[5]._ ## T [0]); \\\n+  assert (num_fregs <= 6 || fregs.ymm6._ ## T [0] == ymm_regs[6]._ ## T [0]); \\\n+  assert (num_fregs <= 7 || fregs.ymm7._ ## T [0] == ymm_regs[7]._ ## T [0]); \\\n+  } while (0)\n+\n+#define check_float_arguments check_f_arguments(float)\n+#define check_double_arguments check_f_arguments(double)\n+\n+#define check_vector_arguments(T,O) do { \\\n+  assert (num_fregs <= 0 \\\n+\t  || memcmp (((char *) &fregs.ymm0) + (O), \\\n+\t\t     &ymm_regs[0], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 1 \\\n+\t  || memcmp (((char *) &fregs.ymm1) + (O), \\\n+\t\t     &ymm_regs[1], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 2 \\\n+\t  || memcmp (((char *) &fregs.ymm2) + (O), \\\n+\t\t     &ymm_regs[2], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 3 \\\n+\t  || memcmp (((char *) &fregs.ymm3) + (O), \\\n+\t\t     &ymm_regs[3], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 4 \\\n+\t  || memcmp (((char *) &fregs.ymm4) + (O), \\\n+\t\t     &ymm_regs[4], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 5 \\\n+\t  || memcmp (((char *) &fregs.ymm5) + (O), \\\n+\t\t     &ymm_regs[5], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 6 \\\n+\t  || memcmp (((char *) &fregs.ymm6) + (O), \\\n+\t\t     &ymm_regs[6], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 7 \\\n+\t  || memcmp (((char *) &fregs.ymm7) + (O), \\\n+\t\t     &ymm_regs[7], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  } while (0)\n+\n+#define check_m64_arguments check_vector_arguments(m64, 0)\n+#define check_m128_arguments check_vector_arguments(m128, 0)\n+#define check_m256_arguments check_vector_arguments(m256, 0)\n+\n+#endif /* INCLUDED_ARGS_H  */"}, {"sha": "96c1c051fc2ffa86b21e2eac0e820d98ab068750", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fasm-support.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fasm-support.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Fasm-support.S?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -0,0 +1,80 @@\n+\t.file\t\"snapshot.S\"\n+\t.text\n+\t.p2align 4,,15\n+.globl snapshot\n+\t.type\tsnapshot, @function\n+snapshot:\n+.LFB3:\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rbx, rbx(%rip)\n+\tmovq\t%rcx, rcx(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tmovq\t%rdi, rdi(%rip)\n+\tmovq\t%rsi, rsi(%rip)\n+\tmovq\t%rbp, rbp(%rip)\n+\tmovq\t%rsp, rsp(%rip)\n+\tmovq\t%r8, r8(%rip)\n+\tmovq\t%r9, r9(%rip)\n+\tmovq\t%r10, r10(%rip)\n+\tmovq\t%r11, r11(%rip)\n+\tmovq\t%r12, r12(%rip)\n+\tmovq\t%r13, r13(%rip)\n+\tmovq\t%r14, r14(%rip)\n+\tmovq\t%r15, r15(%rip)\n+\tvmovdqu\t%ymm0, ymm_regs+0(%rip)\n+\tvmovdqu\t%ymm1, ymm_regs+32(%rip)\n+\tvmovdqu\t%ymm2, ymm_regs+32*2(%rip)\n+\tvmovdqu\t%ymm3, ymm_regs+32*3(%rip)\n+\tvmovdqu\t%ymm4, ymm_regs+32*4(%rip)\n+\tvmovdqu\t%ymm5, ymm_regs+32*5(%rip)\n+\tvmovdqu\t%ymm6, ymm_regs+32*6(%rip)\n+\tvmovdqu\t%ymm7, ymm_regs+32*7(%rip)\n+\tvmovdqu\t%ymm8, ymm_regs+32*8(%rip)\n+\tvmovdqu\t%ymm9, ymm_regs+32*9(%rip)\n+\tvmovdqu\t%ymm10, ymm_regs+32*10(%rip)\n+\tvmovdqu\t%ymm11, ymm_regs+32*11(%rip)\n+\tvmovdqu\t%ymm12, ymm_regs+32*12(%rip)\n+\tvmovdqu\t%ymm13, ymm_regs+32*13(%rip)\n+\tvmovdqu\t%ymm14, ymm_regs+32*14(%rip)\n+\tvmovdqu\t%ymm15, ymm_regs+32*15(%rip)\n+\tjmp\t*callthis(%rip)\n+.LFE3:\n+\t.size\tsnapshot, .-snapshot\n+\n+\t.p2align 4,,15\n+.globl snapshot_ret\n+\t.type\tsnapshot_ret, @function\n+snapshot_ret:\n+\tmovq\t%rdi, rdi(%rip)\n+\tcall\t*callthis(%rip)\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tvmovdqu\t%ymm0, ymm_regs+0(%rip)\n+\tvmovdqu\t%ymm1, ymm_regs+32(%rip)\n+\tfstpt\tx87_regs(%rip)\n+\tfstpt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs(%rip)\n+\tret\n+\t.size\tsnapshot_ret, .-snapshot_ret\n+\n+\t.comm\tcallthis,8,8\n+\t.comm\trax,8,8\n+\t.comm\trbx,8,8\n+\t.comm\trcx,8,8\n+\t.comm\trdx,8,8\n+\t.comm\trsi,8,8\n+\t.comm\trdi,8,8\n+\t.comm\trsp,8,8\n+\t.comm\trbp,8,8\n+\t.comm\tr8,8,8\n+\t.comm\tr9,8,8\n+\t.comm\tr10,8,8\n+\t.comm\tr11,8,8\n+\t.comm\tr12,8,8\n+\t.comm\tr13,8,8\n+\t.comm\tr14,8,8\n+\t.comm\tr15,8,8\n+\t.comm\tymm_regs,512,32\n+\t.comm\tx87_regs,128,32\n+\t.comm   volatile_var,8,8"}, {"sha": "7f1f8f9fc5c789e160c1ca2d8bb95d569a5d3575", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/avx-check.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Favx-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Favx-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Favx-check.h?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -0,0 +1,28 @@\n+#include <stdlib.h>\n+#include \"cpuid.h\"\n+\n+static void avx_test (void);\n+\n+int\n+main ()\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+ \n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  /* Run AVX test only if host has AVX support.  */\n+  if (ecx & bit_AVX)\n+    {\n+      avx_test ();\n+#ifdef DEBUG\n+      printf (\"PASSED\\n\");\n+#endif\n+    }\n+#ifdef DEBUG\n+  else\n+    printf (\"SKIPPED\\n\");\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "072d839623f1bc60b35234d981bdebe95c236147", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/test_m256_returning.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_m256_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_m256_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_m256_returning.c?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -0,0 +1,32 @@\n+#include <stdio.h>\n+#include \"avx-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+__m256\n+fun_test_returning___m256 (void)\n+{\n+  volatile_var++;\n+  return (__m256){73,0,0,0,0,0,0,0};\n+}\n+\n+__m256 test_256;\n+\n+static void\n+avx_test (void)\n+{\n+  unsigned failed = 0;\n+  YMM_T ymmt1, ymmt2;\n+\n+  clear_struct_registers;\n+  test_256 = (__m256){73,0,0,0,0,0,0,0};\n+  ymmt1._m256[0] = test_256;\n+  ymmt2._m256[0] = WRAP_RET (fun_test_returning___m256)();\n+  if (memcmp (&ymmt1, &ymmt2, sizeof (ymmt2)) != 0)\n+    printf (\"fail m256\\n\"), failed++;\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "ffc3ec36bf75541a0e5f26162ddddbc5ebc46256", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/test_passing_m256.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_m256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_m256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_m256.c?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -0,0 +1,168 @@\n+#include <stdio.h>\n+#include \"avx-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  YMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+fun_check_passing_m256_8_values (__m256 i0 ATTRIBUTE_UNUSED, __m256 i1 ATTRIBUTE_UNUSED, __m256 i2 ATTRIBUTE_UNUSED, __m256 i3 ATTRIBUTE_UNUSED, __m256 i4 ATTRIBUTE_UNUSED, __m256 i5 ATTRIBUTE_UNUSED, __m256 i6 ATTRIBUTE_UNUSED, __m256 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m256);\n+  compare (values.i1, i1, __m256);\n+  compare (values.i2, i2, __m256);\n+  compare (values.i3, i3, __m256);\n+  compare (values.i4, i4, __m256);\n+  compare (values.i5, i5, __m256);\n+  compare (values.i6, i6, __m256);\n+  compare (values.i7, i7, __m256);\n+}\n+\n+void\n+fun_check_passing_m256_8_regs (__m256 i0 ATTRIBUTE_UNUSED, __m256 i1 ATTRIBUTE_UNUSED, __m256 i2 ATTRIBUTE_UNUSED, __m256 i3 ATTRIBUTE_UNUSED, __m256 i4 ATTRIBUTE_UNUSED, __m256 i5 ATTRIBUTE_UNUSED, __m256 i6 ATTRIBUTE_UNUSED, __m256 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m256_arguments;\n+}\n+\n+void\n+fun_check_passing_m256_20_values (__m256 i0 ATTRIBUTE_UNUSED, __m256 i1 ATTRIBUTE_UNUSED, __m256 i2 ATTRIBUTE_UNUSED, __m256 i3 ATTRIBUTE_UNUSED, __m256 i4 ATTRIBUTE_UNUSED, __m256 i5 ATTRIBUTE_UNUSED, __m256 i6 ATTRIBUTE_UNUSED, __m256 i7 ATTRIBUTE_UNUSED, __m256 i8 ATTRIBUTE_UNUSED, __m256 i9 ATTRIBUTE_UNUSED, __m256 i10 ATTRIBUTE_UNUSED, __m256 i11 ATTRIBUTE_UNUSED, __m256 i12 ATTRIBUTE_UNUSED, __m256 i13 ATTRIBUTE_UNUSED, __m256 i14 ATTRIBUTE_UNUSED, __m256 i15 ATTRIBUTE_UNUSED, __m256 i16 ATTRIBUTE_UNUSED, __m256 i17 ATTRIBUTE_UNUSED, __m256 i18 ATTRIBUTE_UNUSED, __m256 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m256);\n+  compare (values.i1, i1, __m256);\n+  compare (values.i2, i2, __m256);\n+  compare (values.i3, i3, __m256);\n+  compare (values.i4, i4, __m256);\n+  compare (values.i5, i5, __m256);\n+  compare (values.i6, i6, __m256);\n+  compare (values.i7, i7, __m256);\n+  compare (values.i8, i8, __m256);\n+  compare (values.i9, i9, __m256);\n+  compare (values.i10, i10, __m256);\n+  compare (values.i11, i11, __m256);\n+  compare (values.i12, i12, __m256);\n+  compare (values.i13, i13, __m256);\n+  compare (values.i14, i14, __m256);\n+  compare (values.i15, i15, __m256);\n+  compare (values.i16, i16, __m256);\n+  compare (values.i17, i17, __m256);\n+  compare (values.i18, i18, __m256);\n+  compare (values.i19, i19, __m256);\n+}\n+\n+void\n+fun_check_passing_m256_20_regs (__m256 i0 ATTRIBUTE_UNUSED, __m256 i1 ATTRIBUTE_UNUSED, __m256 i2 ATTRIBUTE_UNUSED, __m256 i3 ATTRIBUTE_UNUSED, __m256 i4 ATTRIBUTE_UNUSED, __m256 i5 ATTRIBUTE_UNUSED, __m256 i6 ATTRIBUTE_UNUSED, __m256 i7 ATTRIBUTE_UNUSED, __m256 i8 ATTRIBUTE_UNUSED, __m256 i9 ATTRIBUTE_UNUSED, __m256 i10 ATTRIBUTE_UNUSED, __m256 i11 ATTRIBUTE_UNUSED, __m256 i12 ATTRIBUTE_UNUSED, __m256 i13 ATTRIBUTE_UNUSED, __m256 i14 ATTRIBUTE_UNUSED, __m256 i15 ATTRIBUTE_UNUSED, __m256 i16 ATTRIBUTE_UNUSED, __m256 i17 ATTRIBUTE_UNUSED, __m256 i18 ATTRIBUTE_UNUSED, __m256 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m256_arguments;\n+}\n+\n+\n+#define def_check_passing8(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7); \\\n+  \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7);\n+\n+#define def_check_passing20(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, _i18, _i19, _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  values.i10.TYPE[0] = _i10; \\\n+  values.i11.TYPE[0] = _i11; \\\n+  values.i12.TYPE[0] = _i12; \\\n+  values.i13.TYPE[0] = _i13; \\\n+  values.i14.TYPE[0] = _i14; \\\n+  values.i15.TYPE[0] = _i15; \\\n+  values.i16.TYPE[0] = _i16; \\\n+  values.i17.TYPE[0] = _i17; \\\n+  values.i18.TYPE[0] = _i18; \\\n+  values.i19.TYPE[0] = _i19; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, _i18, _i19); \\\n+  \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11, _i12, _i13, _i14, _i15, _i16, _i17, _i18, _i19);\n+\n+void\n+test_m256_on_stack ()\n+{\n+  __m256 x[8];\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    x[i] = (__m256){32+i, 0, 0, 0, 0, 0, 0, 0};\n+  pass = \"m256-8\";\n+  def_check_passing8(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], fun_check_passing_m256_8_values, fun_check_passing_m256_8_regs, _m256);\n+}\n+\n+void\n+test_too_many_m256 ()\n+{\n+  __m256 x[20];\n+  int i;\n+  for (i = 0; i < 20; i++)\n+    x[i] = (__m256){32+i, 0, 0, 0, 0, 0, 0, 0};\n+  pass = \"m256-20\";\n+  def_check_passing20(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16], x[17], x[18], x[19], fun_check_passing_m256_20_values, fun_check_passing_m256_20_regs, _m256);\n+}\n+\n+static void\n+avx_test (void)\n+{\n+  test_m256_on_stack ();\n+  test_too_many_m256 ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "9a8f71dbb8f57ad6a2681bc69acf3e6f5bc01405", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/test_passing_structs.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_structs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_structs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_structs.c?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -0,0 +1,61 @@\n+#include \"avx-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+struct m256_struct\n+{\n+  __m256 x;\n+};\n+\n+struct m256_2_struct\n+{\n+  __m256 x1, x2;\n+};\n+\n+/* Check that the struct is passed as the individual members in fregs.  */\n+void\n+check_struct_passing1 (struct m256_struct ms1 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms2 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms3 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms4 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms5 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms6 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms7 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_struct_passing2 (struct m256_2_struct ms ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ms.x1 == rsp+8);\n+  assert ((unsigned long)&ms.x2 == rsp+40);\n+}\n+\n+static void\n+avx_test (void)\n+{\n+  struct m256_struct m256s [8];\n+  struct m256_2_struct m256_2s = { \n+      { 48.394, 39.3, -397.9, 3484.9, -8.394, -93.3, 7.9, 84.94 },\n+      { -8.394, -3.3, -39.9, 34.9, 7.9, 84.94, -48.394, 39.3 }\n+  };\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    m256s[i].x = (__m256){32+i, 0, i, 0, -i, 0, i - 12, i + 8};\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    fregs.ymm0._m256[i] = m256s[i].x;\n+  num_fregs = 8;\n+  WRAP_CALL (check_struct_passing1)(m256s[0], m256s[1], m256s[2], m256s[3],\n+\t\t\t\t    m256s[4], m256s[5], m256s[6], m256s[7]);\n+  WRAP_CALL (check_struct_passing2)(m256_2s);\n+}"}, {"sha": "f83209b276773a05ef78e43f18bc65e6484975b5", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx/test_passing_unions.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8800687f548b183c6c28492e2ff455b606d828c/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx%2Ftest_passing_unions.c?ref=a8800687f548b183c6c28492e2ff455b606d828c", "patch": "@@ -0,0 +1,143 @@\n+#include \"avx-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+union un1\n+{\n+  __m256 x;\n+  float f;\n+};\n+\n+union un2\n+{\n+  __m256 x;\n+  double d;\n+};\n+\n+union un3\n+{\n+  __m256 x;\n+  __m128 v;\n+};\n+\n+union un4\n+{\n+  __m256 x;\n+  long double ld;\n+};\n+\n+union un5\n+{\n+  __m256 x;\n+  int i;\n+};\n+\n+void\n+check_union_passing1(union un1 u1 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u2 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u3 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u4 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u5 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u6 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u7 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing2(union un2 u1 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u2 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u3 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u4 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u5 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u6 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u7 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing3(union un3 u1 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u2 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u3 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u4 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u5 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u6 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u7 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing4(union un4 u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.ld == rsp+8);\n+}\n+\n+void\n+check_union_passing5(union un5 u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.i == rsp+8);\n+}\n+\n+#define check_union_passing1 WRAP_CALL(check_union_passing1)\n+#define check_union_passing2 WRAP_CALL(check_union_passing2)\n+#define check_union_passing3 WRAP_CALL(check_union_passing3)\n+#define check_union_passing4 WRAP_CALL(check_union_passing4)\n+#define check_union_passing5 WRAP_CALL(check_union_passing5)\n+\n+static void\n+avx_test (void)\n+{\n+  union un1 u1[8];\n+  union un2 u2[8];\n+  union un3 u3[8];\n+  union un4 u4;\n+  union un5 u5;\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    u1[i].x = (__m256){32+i, 0, i, 0, -i, 0, i - 12, i + 8};\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    fregs.ymm0._m256[i] = u1[i].x;\n+  num_fregs = 8;\n+  check_union_passing1(u1[0], u1[1], u1[2], u1[3],\n+\t\t       u1[4], u1[5], u1[6], u1[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u2[i].x = u1[i].x;\n+      fregs.ymm0._m256[i] = u2[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing2(u2[0], u2[1], u2[2], u2[3],\n+\t\t       u2[4], u2[5], u2[6], u2[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u3[i].x = u1[i].x;\n+      fregs.ymm0._m256[i] = u3[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing3(u3[0], u3[1], u3[2], u3[3],\n+\t\t       u3[4], u3[5], u3[6], u3[7]);\n+\n+  check_union_passing4(u4);\n+  check_union_passing5(u5);\n+}"}]}