{"sha": "aea9695ca5c18f6aba6d429b0a593411f37b5c0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVhOTY5NWNhNWMxOGY2YWJhNmQ0MjliMGE1OTM0MTFmMzdiNWMwZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2002-01-22T11:33:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2002-01-22T11:33:52Z"}, "message": "dwarf2out.c (equate_decl_number_to_die): Add \"int\" to decls.\n\n\t* dwarf2out.c (equate_decl_number_to_die): Add \"int\" to decls.\n\t(loc_descriptor_from_tree, case CALL_EXPR, case ADDR_EXPR): New.\n\t(add_bound_info, default): If can't find a context, make a\n\tSAVE_EXPR.\n\t(dwarf2out_finish): Check for SAVE_EXPR in node->created_for.\n\nFrom-SVN: r49069", "tree": {"sha": "3b6acf09ef6a5765b5f60b8c1bf03e15f8f64eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b6acf09ef6a5765b5f60b8c1bf03e15f8f64eee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aea9695ca5c18f6aba6d429b0a593411f37b5c0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea9695ca5c18f6aba6d429b0a593411f37b5c0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea9695ca5c18f6aba6d429b0a593411f37b5c0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea9695ca5c18f6aba6d429b0a593411f37b5c0f/comments", "author": null, "committer": null, "parents": [{"sha": "ffe154a99092262507639ca75a17d602491d416b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe154a99092262507639ca75a17d602491d416b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe154a99092262507639ca75a17d602491d416b"}], "stats": {"total": 48, "additions": 46, "deletions": 2}, "files": [{"sha": "0f91fb5e17d3d8db2097f00a73421e1bbb48b471", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea9695ca5c18f6aba6d429b0a593411f37b5c0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea9695ca5c18f6aba6d429b0a593411f37b5c0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aea9695ca5c18f6aba6d429b0a593411f37b5c0f", "patch": "@@ -1,3 +1,11 @@\n+Tue Jan 22 06:26:33 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* dwarf2out.c (equate_decl_number_to_die): Add \"int\" to decls.\n+\t(loc_descriptor_from_tree, case CALL_EXPR, case ADDR_EXPR): New.\n+\t(add_bound_info, default): If can't find a context, make a\n+\tSAVE_EXPR.\n+\t(dwarf2out_finish): Check for SAVE_EXPR in node->created_for.\n+\n 2002-01-22  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* c-typeck.c (parser_build_binary_op): If result from"}, {"sha": "18fcfb0db5c54ea513bbb19fb2d54ffcffc5aa3d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea9695ca5c18f6aba6d429b0a593411f37b5c0f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea9695ca5c18f6aba6d429b0a593411f37b5c0f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=aea9695ca5c18f6aba6d429b0a593411f37b5c0f", "patch": "@@ -5116,8 +5116,8 @@ equate_decl_number_to_die (decl, decl_die)\n      tree decl;\n      dw_die_ref decl_die;\n {\n-  unsigned decl_id = DECL_UID (decl);\n-  unsigned num_allocated;\n+  unsigned int decl_id = DECL_UID (decl);\n+  unsigned int num_allocated;\n \n   if (decl_id >= decl_die_table_allocated)\n     {\n@@ -7973,6 +7973,24 @@ loc_descriptor_from_tree (loc, addressp)\n \t the names of types.  */\n       return 0;\n \n+    case CALL_EXPR:\n+      return 0;\n+\n+    case ADDR_EXPR:\n+      /* We can support this only if we can look through conversions and\n+\t find an INDIRECT_EXPR.  */\n+      for (loc = TREE_OPERAND (loc, 0);\n+\t   TREE_CODE (loc) == CONVERT_EXPR || TREE_CODE (loc) == NOP_EXPR\n+\t   || TREE_CODE (loc) == NON_LVALUE_EXPR\n+\t   || TREE_CODE (loc) == VIEW_CONVERT_EXPR\n+\t   || TREE_CODE (loc) == SAVE_EXPR;\n+\t   loc = TREE_OPERAND (loc, 0))\n+\t;\n+\n+       return (TREE_CODE (loc) == INDIRECT_REF\n+\t       ? loc_descriptor_from_tree (TREE_OPERAND (loc, 0), addressp)\n+\t       : 0);\n+\n     case VAR_DECL:\n     case PARM_DECL:\n       {\n@@ -9077,6 +9095,15 @@ add_bound_info (subrange_die, bound_attr, bound)\n \telse\n \t  ctx = lookup_decl_die (current_function_decl);\n \n+\t/* If we weren't able to find a context, it's most likely the case\n+\t   that we are processing the return type of the function.  So\n+\t   make a SAVE_EXPR to point to it and have the limbo DIE code\n+\t   find the proper die.  The save_expr function doesn't always\n+\t   make a SAVE_EXPR, so do it ourselves.  */\n+\tif (ctx == 0)\n+\t  bound = build (SAVE_EXPR, TREE_TYPE (bound), bound,\n+\t\t\t current_function_decl, NULL_TREE);\n+\n \tdecl_die = new_die (DW_TAG_variable, ctx, bound);\n \tadd_AT_flag (decl_die, DW_AT_artificial, 1);\n \tadd_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n@@ -12013,6 +12040,15 @@ dwarf2out_finish (input_filename)\n \t    add_child_die (origin->die_parent, die);\n \t  else if (die == comp_unit_die)\n \t    ;\n+\t  /* If this was an expression for a bound involved in a function\n+\t     return type, it may be a SAVE_EXPR for which we weren't able\n+\t     to find a DIE previously.  So try now.  */\n+\t  else if (node->created_for\n+\t\t   && TREE_CODE (node->created_for) == SAVE_EXPR\n+\t\t   && 0 != (origin = (lookup_decl_die\n+\t\t\t\t      (SAVE_EXPR_CONTEXT\n+\t\t\t\t       (node->created_for)))))\n+\t    add_child_die (origin, die);\n \t  else if (node->created_for\n \t\t   && ((DECL_P (node->created_for)\n \t\t        && (context = DECL_CONTEXT (node->created_for)))"}]}