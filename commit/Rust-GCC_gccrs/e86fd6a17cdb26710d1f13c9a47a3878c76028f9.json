{"sha": "e86fd6a17cdb26710d1f13c9a47a3878c76028f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg2ZmQ2YTE3Y2RiMjY3MTBkMWYxM2M5YTQ3YTM4NzhjNzYwMjhmOQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-04T17:59:15Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-04T18:07:53Z"}, "message": "Add Ranger temporal cache\n\nAdd a timestamp to supplement the global range cache to detect when a value\nmay become stale.\n\n\tgcc/\n\tPR tree-optimization/97515\n\t* gimple-range-cache.h (class ranger_cache): New prototypes plus\n\ttemporal cache pointer.\n\t* gimple-range-cache.cc (struct range_timestamp): New.\n\t(class temporal_cache): New.\n\t(temporal_cache::temporal_cache): New.\n\t(temporal_cache::~temporal_cache): New.\n\t(temporal_cache::get_timestamp): New.\n\t(temporal_cache::set_dependency): New.\n\t(temporal_cache::temporal_value): New.\n\t(temporal_cache::current_p): New.\n\t(temporal_cache::set_timestamp): New.\n\t(temporal_cache::set_always_current): New.\n\t(ranger_cache::ranger_cache): Allocate the temporal cache.\n\t(ranger_cache::~ranger_cache): Free temporal cache.\n\t(ranger_cache::get_non_stale_global_range): New.\n\t(ranger_cache::set_global_range): Add a timestamp.\n\t(ranger_cache::register_dependency): New.  Add timestamp dependency.\n\t* gimple-range.cc (gimple_ranger::range_of_range_op): Add operand\n\tdependencies.\n\t(gimple_ranger::range_of_phi): Ditto.\n\t(gimple_ranger::range_of_stmt): Check if global range is stale, and\n\trecalculate if so.\n\tgcc/testsuite/\n\t* gcc.dg/pr97515.c: Check listing for folding of entire function.", "tree": {"sha": "28e836b34524e1129f1ceb70527d301c8483fe53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28e836b34524e1129f1ceb70527d301c8483fe53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e86fd6a17cdb26710d1f13c9a47a3878c76028f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86fd6a17cdb26710d1f13c9a47a3878c76028f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86fd6a17cdb26710d1f13c9a47a3878c76028f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/comments", "author": null, "committer": null, "parents": [{"sha": "9c1125c121423a9948fa39e71ef89ba4059a2fad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c1125c121423a9948fa39e71ef89ba4059a2fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c1125c121423a9948fa39e71ef89ba4059a2fad"}], "stats": {"total": 206, "additions": 196, "deletions": 10}, "files": [{"sha": "b01563c83f9dc340d2605d7fb3b2d49d9912fa9b", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=e86fd6a17cdb26710d1f13c9a47a3878c76028f9", "patch": "@@ -476,6 +476,140 @@ ssa_global_cache::dump (FILE *f)\n   fputc ('\\n', f);\n }\n \n+// --------------------------------------------------------------------------\n+\n+\n+// This struct provides a timestamp for a global range calculation.\n+// it contains the time counter, as well as a limited number of ssa-names\n+// that it is dependent upon.  If the timestamp for any of the dependent names\n+// Are newer, then this range could need updating.\n+\n+struct range_timestamp\n+{\n+  unsigned time;\n+  unsigned ssa1;\n+  unsigned ssa2;\n+};\n+\n+// This class will manage the timestamps for each ssa_name.\n+// When a value is calcualted, its timestamp is set to the current time.\n+// The ssanames it is dependent on have already been calculated, so they will\n+// have older times.  If one fo those values is ever calculated again, it\n+// will get a newer timestamp, and the \"current_p\" check will fail.\n+\n+class temporal_cache\n+{\n+public:\n+  temporal_cache ();\n+  ~temporal_cache ();\n+  bool current_p (tree name) const;\n+  void set_timestamp (tree name);\n+  void set_dependency (tree name, tree dep);\n+  void set_always_current (tree name);\n+private:\n+  unsigned temporal_value (unsigned ssa) const;\n+  const range_timestamp *get_timestamp (unsigned ssa) const;\n+  range_timestamp *get_timestamp (unsigned ssa);\n+\n+  unsigned m_current_time;\n+  vec <range_timestamp> m_timestamp;\n+};\n+\n+\n+inline\n+temporal_cache::temporal_cache ()\n+{\n+  m_current_time = 1;\n+  m_timestamp.create (0);\n+  m_timestamp.safe_grow_cleared (num_ssa_names);\n+}\n+\n+inline\n+temporal_cache::~temporal_cache ()\n+{\n+  m_timestamp.release ();\n+}\n+\n+// Return a pointer to the timetamp for ssa-name at index SSA, if there is\n+// one, otherwise return NULL.\n+\n+inline const range_timestamp *\n+temporal_cache::get_timestamp (unsigned ssa) const\n+{\n+  if (ssa >= m_timestamp.length ())\n+    return NULL;\n+  return &(m_timestamp[ssa]);\n+}\n+\n+// Return a reference to the timetamp for ssa-name at index SSA.  If the index\n+// is past the end of the vector, extend the vector.\n+\n+inline range_timestamp *\n+temporal_cache::get_timestamp (unsigned ssa)\n+{\n+  if (ssa >= m_timestamp.length ())\n+    m_timestamp.safe_grow_cleared (num_ssa_names + 20);\n+  return &(m_timestamp[ssa]);\n+}\n+\n+// This routine will fill NAME's next operand slot with DEP if DEP is a valid\n+// SSA_NAME and there is a free slot.\n+\n+inline void\n+temporal_cache::set_dependency (tree name, tree dep)\n+{\n+  if (dep && TREE_CODE (dep) == SSA_NAME)\n+    {\n+      gcc_checking_assert (get_timestamp (SSA_NAME_VERSION (name)));\n+      range_timestamp& ts = *(get_timestamp (SSA_NAME_VERSION (name)));\n+      if (!ts.ssa1)\n+\tts.ssa1 = SSA_NAME_VERSION (dep);\n+      else if (!ts.ssa2 && ts.ssa1 != SSA_NAME_VERSION (name))\n+\tts.ssa2 = SSA_NAME_VERSION (dep);\n+    }\n+}\n+\n+// Return the timestamp value for SSA, or 0 if there isnt one.\n+inline unsigned\n+temporal_cache::temporal_value (unsigned ssa) const\n+{\n+  const range_timestamp *ts = get_timestamp (ssa);\n+  return ts ? ts->time : 0;\n+}\n+\n+// Return TRUE if the timestampe for NAME is newer than any of its dependents.\n+\n+bool\n+temporal_cache::current_p (tree name) const\n+{\n+  const range_timestamp *ts = get_timestamp (SSA_NAME_VERSION (name));\n+  if (!ts || ts->time == 0)\n+    return true;\n+  // Any non-registered dependencies will have a value of 0 and thus be older.\n+  // Return true if time is newer than either dependent.\n+  return ts->time > temporal_value (ts->ssa1)\n+\t && ts->time > temporal_value (ts->ssa2);\n+}\n+\n+// This increments the global timer and sets the timestamp for NAME.\n+\n+inline void\n+temporal_cache::set_timestamp (tree name)\n+{\n+  gcc_checking_assert (get_timestamp (SSA_NAME_VERSION (name)));\n+  get_timestamp (SSA_NAME_VERSION (name))->time = ++m_current_time;\n+}\n+\n+// Set the timestamp to 0, marking it as \"always up to date\".\n+\n+inline void\n+temporal_cache::set_always_current (tree name)\n+{\n+  gcc_checking_assert (get_timestamp (SSA_NAME_VERSION (name)));\n+  get_timestamp (SSA_NAME_VERSION (name))->time = 0;\n+}\n+\n+\n // --------------------------------------------------------------------------\n \n ranger_cache::ranger_cache (gimple_ranger &q) : query (q)\n@@ -488,10 +622,12 @@ ranger_cache::ranger_cache (gimple_ranger &q) : query (q)\n   m_poor_value_list.create (0);\n   m_poor_value_list.safe_grow_cleared (20);\n   m_poor_value_list.truncate (0);\n+  m_temporal = new temporal_cache;\n }\n \n ranger_cache::~ranger_cache ()\n {\n+  delete m_temporal;\n   m_poor_value_list.release ();\n   m_workback.release ();\n   m_update_list.release ();\n@@ -529,6 +665,32 @@ ranger_cache::get_global_range (irange &r, tree name) const\n   return m_globals.get_global_range (r, name);\n }\n \n+// Get the global range for NAME, and return in R if the value is not stale.\n+// If the range is set, but is stale, mark it current and return false.\n+// If it is not set pick up the legacy global value, mark it current, and\n+// return false.\n+// Note there is always a value returned in R. The return value indicates\n+// whether that value is an up-to-date calculated value or not..\n+\n+bool\n+ranger_cache::get_non_stale_global_range (irange &r, tree name)\n+{\n+  if (m_globals.get_global_range (r, name))\n+    {\n+      if (m_temporal->current_p (name))\n+\treturn true;\n+    }\n+  else\n+    {\n+      // Global has never been accessed, so pickup the legacy global value.\n+      r = gimple_range_global (name);\n+      m_globals.set_global_range (name, r);\n+    }\n+  // After a stale check failure, mark the value as always current until a\n+  // new one is set.\n+  m_temporal->set_always_current (name);\n+  return false;\n+}\n //  Set the global range of NAME to R.\n \n void\n@@ -546,6 +708,18 @@ ranger_cache::set_global_range (tree name, const irange &r)\n \n       propagate_updated_value (name, bb);\n     }\n+  // Mark the value as up-to-date.\n+  m_temporal->set_timestamp (name);\n+}\n+\n+// Register a dependency on DEP to name.  If the timestamp for DEP is ever\n+// greateer than the timestamp for NAME, then it is newer and NAMEs value\n+// becomes stale.\n+\n+void\n+ranger_cache::register_dependency (tree name, tree dep)\n+{\n+  m_temporal->set_dependency (name, dep);\n }\n \n // Push a request for a new lookup in block BB of name.  Return true if"}, {"sha": "c5749fefb5f53b1da071950bbb6eebe0f59bf9dc", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=e86fd6a17cdb26710d1f13c9a47a3878c76028f9", "patch": "@@ -97,7 +97,9 @@ class ranger_cache : public gori_compute_cache\n   bool block_range (irange &r, basic_block bb, tree name, bool calc = true);\n \n   bool get_global_range (irange &r, tree name) const;\n+  bool get_non_stale_global_range (irange &r, tree name);\n   void set_global_range (tree name, const irange &r);\n+  void register_dependency (tree name, tree dep);\n \n   non_null_ref m_non_null;\n \n@@ -106,6 +108,7 @@ class ranger_cache : public gori_compute_cache\n private:\n   ssa_global_cache m_globals;\n   block_range_cache m_on_entry;\n+  class temporal_cache *m_temporal;\n   void add_to_update (basic_block bb);\n   void fill_block_cache (tree name, basic_block bb, basic_block def_bb);\n   void propagate_cache (tree name);"}, {"sha": "ef65e00cc1d3db6d24361a582c9242780e70b063", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=e86fd6a17cdb26710d1f13c9a47a3878c76028f9", "patch": "@@ -415,12 +415,20 @@ bool\n gimple_ranger::range_of_range_op (irange &r, gimple *s)\n {\n   int_range_max range1, range2;\n+  tree lhs = gimple_get_lhs (s);\n   tree type = gimple_expr_type (s);\n   gcc_checking_assert (irange::supports_type_p (type));\n \n   tree op1 = gimple_range_operand1 (s);\n   tree op2 = gimple_range_operand2 (s);\n \n+  if (lhs)\n+    {\n+      // Register potential dependencies for stale value tracking.\n+      m_cache.register_dependency (lhs, op1);\n+      m_cache.register_dependency (lhs, op2);\n+    }\n+\n   if (range_of_non_trivial_assignment (r, s))\n     return true;\n \n@@ -501,6 +509,9 @@ gimple_ranger::range_of_phi (irange &r, gphi *phi)\n       tree arg = gimple_phi_arg_def (phi, x);\n       edge e = gimple_phi_arg_edge (phi, x);\n \n+      // Register potential dependencies for stale value tracking.\n+      m_cache.register_dependency (phi_def, arg);\n+\n       range_on_edge (arg_range, e, arg);\n       r.union_ (arg_range);\n       // Once the value reaches varying, stop looking.\n@@ -1009,18 +1020,12 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n   if (!gimple_range_ssa_p (name))\n     return false;\n \n-  // If this STMT has already been processed, return that value.\n-  if (m_cache.get_global_range (r, name))\n+  // Check if the stmt has already been processed, and is not stale.\n+  if (m_cache.get_non_stale_global_range (r, name))\n     return true;\n \n-  // Avoid infinite recursion by initializing global cache\n-  int_range_max tmp = gimple_range_global (name);\n-  m_cache.set_global_range (name, tmp);\n-\n+  // Otherwise calculate a new value and save it.\n   calc_stmt (r, s, name);\n-\n-  if (is_a<gphi *> (s))\n-    r.intersect (tmp);\n   m_cache.set_global_range (name, r);\n   return true;\n }"}, {"sha": "84f145a261fff7373cfc387b0902b40612da8cd6", "filename": "gcc/testsuite/gcc.dg/pr97515.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97515.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86fd6a17cdb26710d1f13c9a47a3878c76028f9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97515.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97515.c?ref=e86fd6a17cdb26710d1f13c9a47a3878c76028f9", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2\" } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n \n int\n e7 (int gg)\n@@ -19,3 +19,7 @@ e7 (int gg)\n \n   return xe;\n }\n+\n+/* EVRP should be able to reduce this to a single goto.  */\n+ \n+/* { dg-final { scan-tree-dump-times \"goto\" 1 \"evrp\" } } */"}]}