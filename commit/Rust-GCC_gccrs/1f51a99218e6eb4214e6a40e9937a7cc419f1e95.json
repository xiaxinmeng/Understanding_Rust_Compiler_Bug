{"sha": "1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY1MWE5OTIxOGU2ZWI0MjE0ZTZhNDBlOTkzN2E3Y2M0MTlmMWU5NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-02-18T22:42:07Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-02-18T22:42:07Z"}, "message": "semantics.c (deferred_type_access_control): Walk the entire type_lookups list.\n\n        * semantics.c (deferred_type_access_control): Walk the entire\n        type_lookups list.\n        (save_type_access_control): Rename from\n        initial_deferred_type_access_control.  Just remember the value.\n        (decl_type_access_control): New fn.\n        (begin_function_definition): Use deferred_type_access_control, after\n        we've started the function.  Set type_lookups to error_mark_node.\n        * parse.y (frob_specs, fn.def1): Adjust.\n        (parse_decl0, parse_field, parse_field0, parse_bitfield): New fns.\n        (parse_end_decl, parse_bitfield0, parse_method): New fns.\n        (fn.def2, initdcl, initdcl0_innards, nomods_initdcl0): Use them.\n        (after_type_component_declarator0): Likewise.\n        (after_type_component_declarator): Likewise.\n        (notype_component_declarator): Likewise.\n        * cp-tree.h: Adjust.\n\n        * decl.c (redeclaration_error_message): Allow redeclaration of\n        namespace-scope decls.\n\nFrom-SVN: r32059", "tree": {"sha": "684bc3c3537e59eeb5cfab653c80b41fd9a188bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/684bc3c3537e59eeb5cfab653c80b41fd9a188bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/comments", "author": null, "committer": null, "parents": [{"sha": "6d1e16d74e7d55c8a0d38076850356f9e83951ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1e16d74e7d55c8a0d38076850356f9e83951ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d1e16d74e7d55c8a0d38076850356f9e83951ab"}], "stats": {"total": 2314, "additions": 1203, "deletions": 1111}, "files": [{"sha": "00f0f3a069439163dbe3297b215ee429846a9a35", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "patch": "@@ -1,3 +1,24 @@\n+2000-02-18  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* semantics.c (deferred_type_access_control): Walk the entire\n+\ttype_lookups list.\n+\t(save_type_access_control): Rename from \n+\tinitial_deferred_type_access_control.  Just remember the value.\n+\t(decl_type_access_control): New fn.\n+\t(begin_function_definition): Use deferred_type_access_control, after\n+\twe've started the function.  Set type_lookups to error_mark_node.\n+\t* parse.y (frob_specs, fn.def1): Adjust.\n+\t(parse_decl0, parse_field, parse_field0, parse_bitfield): New fns.\n+\t(parse_end_decl, parse_bitfield0, parse_method): New fns.\n+\t(fn.def2, initdcl, initdcl0_innards, nomods_initdcl0): Use them.\n+\t(after_type_component_declarator0): Likewise.\n+\t(after_type_component_declarator): Likewise.\n+\t(notype_component_declarator): Likewise.\n+\t* cp-tree.h: Adjust.\n+\n+\t* decl.c (redeclaration_error_message): Allow redeclaration of \n+\tnamespace-scope decls.\n+\n 2000-02-18  Martin von Loewis  <loewis@informatik.hu-berlin.de>\n \n \t* typeck2.c (my_friendly_abort): Use GCCBUGURL."}, {"sha": "8f3408d8f67c049bec35f4cb14ee6f1b3a0ece45", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "patch": "@@ -4177,9 +4177,9 @@ extern tree finish_qualified_call_expr          PARAMS ((tree, tree));\n extern tree finish_label_address_expr           PARAMS ((tree));\n extern tree finish_unary_op_expr                PARAMS ((enum tree_code, tree));\n extern tree finish_id_expr                      PARAMS ((tree));\n-extern void deferred_type_access_control\tPARAMS ((void));\n-extern void initial_deferred_type_access_control PARAMS ((tree));\n-extern int begin_function_definition            PARAMS ((tree, tree, tree));\n+extern void save_type_access_control\t\tPARAMS ((tree));\n+extern void decl_type_access_control\t\tPARAMS ((tree));\n+extern int begin_function_definition            PARAMS ((tree, tree));\n extern tree begin_constructor_declarator        PARAMS ((tree, tree));\n extern tree finish_declarator                   PARAMS ((tree, tree, tree, tree, int));\n extern void finish_translation_unit             PARAMS ((void));"}, {"sha": "0b8e318f22d1daf82c7743c8c43caeed08554959", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "patch": "@@ -4585,7 +4585,7 @@ redeclaration_error_message (newdecl, olddecl)\n \treturn \"redefinition of `%#D'\";\n       return 0;\n     }\n-  else if (toplevel_bindings_p ())\n+  else if (toplevel_bindings_p () || DECL_NAMESPACE_SCOPE_P (newdecl))\n     {\n       /* Objects declared at top level:  */\n       /* If at least one is a reference, it's ok.  */"}, {"sha": "66e2a91892460e4ea51b0afc5fb61bfe5140004a", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 965, "deletions": 934, "changes": 1899, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=1f51a99218e6eb4214e6a40e9937a7cc419f1e95"}, {"sha": "000ab1df02c9f632242d98594edd8f24be02d017", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 173, "deletions": 142, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "patch": "@@ -62,13 +62,38 @@ extern int end_of_file;\n    error message if the user supplies an empty conditional expression.  */\n static const char *cond_stmt_keyword;\n \n-static tree empty_parms PARAMS ((void));\n-static void parse_decl PARAMS ((tree, tree, tree, tree, int, tree *));\n-\n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n int used_extern_spec;\n \n+/* List of types and structure classes of the current declaration.  */\n+static tree current_declspecs;\n+\n+/* List of prefix attributes in effect.\n+   Prefix attributes are parsed by the reserved_declspecs and declmods\n+   rules.  They create a list that contains *both* declspecs and attrs.  */\n+/* ??? It is not clear yet that all cases where an attribute can now appear in\n+   a declspec list have been updated.  */\n+static tree prefix_attributes;\n+\n+/* When defining an aggregate, this is the kind of the most recent one\n+   being defined.  (For example, this might be class_type_node.)  */\n+static tree current_aggr;\n+\n+/* When defining an enumeration, this is the type of the enumeration.  */\n+static tree current_enum_type;\n+\n+static tree empty_parms PARAMS ((void));\n+static tree parse_decl0 PARAMS ((tree, tree, tree, tree, int));\n+static tree parse_decl PARAMS ((tree, tree, int));\n+static void parse_end_decl PARAMS ((tree, tree, tree));\n+static tree parse_field0 PARAMS ((tree, tree, tree, tree, tree, tree));\n+static tree parse_field PARAMS ((tree, tree, tree, tree));\n+static tree parse_bitfield0 PARAMS ((tree, tree, tree, tree, tree));\n+static tree parse_bitfield PARAMS ((tree, tree, tree));\n+static tree parse_method PARAMS ((tree, tree, tree));\n+static void frob_specs PARAMS ((tree, tree)); \n+\n /* Cons up an empty parameter list.  */\n static inline tree\n empty_parms ()\n@@ -83,6 +108,108 @@ empty_parms ()\n   return parms;\n }\n \n+/* Record the decl-specifiers, attributes and type lookups from the\n+   decl-specifier-seq in a declaration.  */\n+\n+static void\n+frob_specs (specs_attrs, lookups)\n+     tree specs_attrs, lookups;\n+{\n+  save_type_access_control (lookups);\n+  split_specs_attrs (specs_attrs, &current_declspecs, &prefix_attributes);\n+  if (current_declspecs\n+      && TREE_CODE (current_declspecs) != TREE_LIST)\n+    current_declspecs = build_decl_list (NULL_TREE, current_declspecs);\n+  if (have_extern_spec && !used_extern_spec)\n+    {\n+      current_declspecs = decl_tree_cons (NULL_TREE, \n+\t\t\t\t\t  get_identifier (\"extern\"), \n+\t\t\t\t\t  current_declspecs);\n+      used_extern_spec = 1;\n+    }\n+}\n+\n+static tree\n+parse_decl (declarator, attributes, initialized)\n+     tree declarator, attributes;\n+     int initialized;\n+{\n+  return start_decl (declarator, current_declspecs, initialized,\n+\t\t     attributes, prefix_attributes);\n+}\n+\n+static tree\n+parse_decl0 (declarator, specs_attrs, lookups, attributes, initialized)\n+     tree declarator, specs_attrs, lookups, attributes;\n+     int initialized;\n+{\n+  frob_specs (specs_attrs, lookups);\n+  return parse_decl (declarator, attributes, initialized);\n+}\n+\n+static void\n+parse_end_decl (decl, init, asmspec)\n+     tree decl, init, asmspec;\n+{\n+  decl_type_access_control (decl);\n+  cp_finish_decl (decl, init, asmspec, init ? LOOKUP_ONLYCONVERTING : 0);\n+}\n+\n+static tree\n+parse_field (declarator, attributes, asmspec, init)\n+     tree declarator, attributes, asmspec, init;\n+{\n+  tree d = grokfield (declarator, current_declspecs, init, asmspec,\n+\t\t      build_tree_list (attributes, prefix_attributes));\n+  decl_type_access_control (d);\n+  return d;\n+}\n+\n+static tree\n+parse_field0 (declarator, specs_attrs, lookups, attributes, asmspec, init)\n+     tree declarator, specs_attrs, lookups, attributes, asmspec, init;\n+{\n+  frob_specs (specs_attrs, lookups);\n+  return parse_field (declarator, attributes, asmspec, init);\n+}\n+\n+static tree\n+parse_bitfield (declarator, attributes, width)\n+     tree declarator, attributes, width;\n+{\n+  tree d = grokbitfield (declarator, current_declspecs, width);\n+  cplus_decl_attributes (d, attributes, prefix_attributes);\n+  decl_type_access_control (d);\n+  return d;\n+}\n+\n+static tree\n+parse_bitfield0 (declarator, specs_attrs, lookups, attributes, width)\n+     tree declarator, specs_attrs, lookups, attributes, width;\n+{\n+  frob_specs (specs_attrs, lookups);\n+  return parse_bitfield (declarator, attributes, width);\n+}\n+\n+static tree\n+parse_method (declarator, specs_attrs, lookups)\n+     tree declarator, specs_attrs, lookups;\n+{\n+  tree d;\n+  frob_specs (specs_attrs, lookups);\n+  d = start_method (current_declspecs, declarator, prefix_attributes);\n+  decl_type_access_control (d);\n+  return d;\n+}\n+\n+void\n+cp_parse_init ()\n+{\n+  ggc_add_tree_root (&current_declspecs, 1);\n+  ggc_add_tree_root (&prefix_attributes, 1);\n+  ggc_add_tree_root (&current_aggr, 1);\n+  ggc_add_tree_root (&current_enum_type, 1);\n+}\n %}\n \n %start program\n@@ -291,71 +418,9 @@ empty_parms ()\n %token END_OF_SAVED_INPUT\n \f\n %{\n-/* List of types and structure classes of the current declaration.  */\n-static tree current_declspecs;\n-\n-/* List of prefix attributes in effect.\n-   Prefix attributes are parsed by the reserved_declspecs and declmods\n-   rules.  They create a list that contains *both* declspecs and attrs.  */\n-/* ??? It is not clear yet that all cases where an attribute can now appear in\n-   a declspec list have been updated.  */\n-static tree prefix_attributes;\n-\n-/* When defining an aggregate, this is the kind of the most recent one\n-   being defined.  (For example, this might be class_type_node.)  */\n-static tree current_aggr;\n-\n-/* When defining an enumeration, this is the type of the enumeration.  */\n-static tree current_enum_type;\n-\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n-\n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n-extern tree combine_strings\t\tPARAMS ((tree));\n-\n-static void\n-frob_specs (specs_attrs, lookups)\n-  tree specs_attrs;\n-  tree lookups;\n-{\n-  initial_deferred_type_access_control (lookups);\n-  split_specs_attrs (specs_attrs, &current_declspecs, &prefix_attributes);\n-  if (current_declspecs\n-      && TREE_CODE (current_declspecs) != TREE_LIST)\n-    current_declspecs = build_decl_list (NULL_TREE, current_declspecs);\n-}\n-\n-static void\n-parse_decl (declarator, specs_attrs, lookups, attributes, initialized, decl)\n-  tree declarator;\n-  tree specs_attrs;\n-  tree lookups;\n-  tree attributes;\n-  int initialized;\n-  tree* decl;\n-{\n-  frob_specs (specs_attrs, lookups);\n-\n-  if (have_extern_spec && !used_extern_spec)\n-    {\n-      current_declspecs = decl_tree_cons (NULL_TREE, \n-\t\t\t\t\t  get_identifier (\"extern\"), \n-\t\t\t\t\t  current_declspecs);\n-      used_extern_spec = 1;\n-    }\n-  *decl = start_decl (declarator, current_declspecs, initialized,\n-\t\t      attributes, prefix_attributes);\n-}\n-\n-void\n-cp_parse_init ()\n-{\n-  ggc_add_tree_root (&current_declspecs, 1);\n-  ggc_add_tree_root (&prefix_attributes, 1);\n-  ggc_add_tree_root (&current_aggr, 1);\n-  ggc_add_tree_root (&current_enum_type, 1);\n-}\n %}\n \f\n %%\n@@ -707,19 +772,19 @@ constructor_declarator:\n \n fn.def1:\n \t  typed_declspecs declarator\n-\t\t{ if (!begin_function_definition ($1.t, $1.lookups, $2))\n+\t\t{ if (!begin_function_definition ($1.t, $2))\n \t\t    YYERROR1; }\n \t| declmods notype_declarator\n-\t\t{ if (!begin_function_definition ($1.t, NULL_TREE, $2))\n+\t\t{ if (!begin_function_definition ($1.t, $2))\n \t\t    YYERROR1; }\n \t| notype_declarator\n-\t\t{ if (!begin_function_definition (NULL_TREE, NULL_TREE, $1))\n+\t\t{ if (!begin_function_definition (NULL_TREE, $1))\n \t\t    YYERROR1; }\n \t| declmods constructor_declarator\n-\t\t{ if (!begin_function_definition ($1.t, NULL_TREE, $2))\n+\t\t{ if (!begin_function_definition ($1.t, $2))\n \t\t    YYERROR1; }\n \t| constructor_declarator\n-\t\t{ if (!begin_function_definition (NULL_TREE, NULL_TREE, $1))\n+\t\t{ if (!begin_function_definition (NULL_TREE, $1))\n \t\t    YYERROR1; }\n \t;\n \n@@ -738,40 +803,27 @@ component_constructor_declarator:\n    reduce/reduce conflict introduced by these rules.  */\n fn.def2:\n \t  declmods component_constructor_declarator\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n-\t\t  attrs = build_tree_list (attrs, NULL_TREE);\n-\t\t  $$ = start_method (specs, $2, attrs);\n+\t\t{ $$ = parse_method ($2, $1.t, $1.lookups);\n \t\t rest_of_mdef:\n \t\t  if (! $$)\n \t\t    YYERROR1;\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  reinit_parse_for_method (yychar, $$); }\n \t| component_constructor_declarator\n-\t\t{ $$ = start_method (NULL_TREE, $1, NULL_TREE); \n+\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE); \n \t\t  goto rest_of_mdef; }\n \t| typed_declspecs declarator\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n-\t\t  attrs = build_tree_list (attrs, NULL_TREE);\n-\t\t  initial_deferred_type_access_control ($1.lookups);\n-\t\t  $$ = start_method (specs, $2, attrs); goto rest_of_mdef; }\n+\t\t{ $$ = parse_method ($2, $1.t, $1.lookups); goto rest_of_mdef;}\n \t| declmods notype_declarator\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n-\t\t  attrs = build_tree_list (attrs, NULL_TREE);\n-\t\t  $$ = start_method (specs, $2, attrs); goto rest_of_mdef; }\n+\t\t{ $$ = parse_method ($2, $1.t, $1.lookups); goto rest_of_mdef;}\n \t| notype_declarator\n-\t\t{ $$ = start_method (NULL_TREE, $$, NULL_TREE); \n+\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE); \n \t\t  goto rest_of_mdef; }\n \t| declmods constructor_declarator\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n-\t\t  attrs = build_tree_list (attrs, NULL_TREE);\n-\t\t  $$ = start_method (specs, $2, attrs); goto rest_of_mdef; }\n+\t\t{ $$ = parse_method ($2, $1.t, $1.lookups); goto rest_of_mdef;}\n \t| constructor_declarator\n-\t\t{ $$ = start_method (NULL_TREE, $$, NULL_TREE); \n+\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE); \n \t\t  goto rest_of_mdef; }\n \t;\n \n@@ -1040,12 +1092,11 @@ condition:\n \t\t    }\n \t\t  }\n \t\t  current_declspecs = $1.t;\n-\t\t  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1,\n-\t\t\t\t\t  $4, /*prefix_attributes*/ NULL_TREE);\n+\t\t  $<ttype>$ = parse_decl ($<ttype>2, $4, 1);\n \t\t}\n \t  init\n \t\t{ \n-\t\t  cp_finish_decl ($<ttype>6, $7, $4, LOOKUP_ONLYCONVERTING);\n+\t\t  parse_end_decl ($<ttype>6, $7, $4);\n \t\t  $$ = convert_from_reference ($<ttype>6); \n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n \t\t    cp_error (\"definition of array `%#D' in condition\", $$); \n@@ -1884,20 +1935,14 @@ maybeasm:\n \n initdcl:\n \t  declarator maybeasm maybe_attribute '='\n-\t\t{\n-\t\t  deferred_type_access_control ();\n-\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1,\n-\t\t\t\t\t  $3, prefix_attributes);\n-\t\t}\n+\t\t{ $<ttype>$ = parse_decl ($<ttype>1, $3, 1); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>5, $6, $2, LOOKUP_ONLYCONVERTING); }\n+\t\t{ parse_end_decl ($<ttype>5, $6, $2); }\n \t| declarator maybeasm maybe_attribute\n \t\t{\n-\t\t  deferred_type_access_control ();\n-\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0,\n-\t\t\t\t\t  $3, prefix_attributes);\n-\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 0);\n+\t\t  $<ttype>$ = parse_decl ($<ttype>1, $3, 0);\n+\t\t  parse_end_decl ($<ttype>$, NULL_TREE, $2);\n \t\t}\n \t;\n \n@@ -1909,18 +1954,16 @@ initdcl:\n \t   we need that reduce so we prefer fn.def1 when appropriate.  */\n initdcl0_innards:\n \t  maybe_attribute '='\n-\t\t{ parse_decl ($<ttype>-1, $<ftype>-2.t, $<ftype>-2.lookups,\n-\t\t\t      $1, 1, &$<ttype>$); }\n+\t\t{ $<ttype>$ = parse_decl0 ($<ttype>-1, $<ftype>-2.t,\n+\t\t\t\t\t   $<ftype>-2.lookups, $1, 1); }\n           /* Note how the declaration of the variable is in effect\n \t     while its init is parsed! */ \n \t  init\n-\t\t{ cp_finish_decl ($<ttype>3, $4, $<ttype>0,\n-\t\t\t\t  LOOKUP_ONLYCONVERTING); }\n+\t\t{ parse_end_decl ($<ttype>3, $4, $<ttype>0); }\n \t| maybe_attribute\n-\t\t{ tree d;\n-\t\t  parse_decl ($<ttype>-1, $<ftype>-2.t, $<ftype>-2.lookups,\n-\t\t\t      $1, 0, &d);\n-\t\t  cp_finish_decl (d, NULL_TREE, $<ttype>0, 0); }\n+\t\t{ tree d = parse_decl0 ($<ttype>-1, $<ftype>-2.t,\n+\t\t\t\t\t$<ftype>-2.lookups, $1, 0);\n+\t\t  parse_end_decl (d, NULL_TREE, $<ttype>0); }\n   \t;\n   \n initdcl0:\n@@ -1941,9 +1984,8 @@ nomods_initdcl0:\n           initdcl0_innards \n             {}\n \t| constructor_declarator maybeasm maybe_attribute\n-\t\t{ tree d;\n-\t\t  parse_decl ($1, NULL_TREE, NULL_TREE, $3, 0, &d);\n-\t\t  cp_finish_decl (d, NULL_TREE, $2, 0); }\n+\t\t{ tree d = parse_decl0 ($1, NULL_TREE, NULL_TREE, $3, 0);\n+\t\t  parse_end_decl (d, NULL_TREE, $2); }\n \t;\n \n /* the * rules are dummies to accept the Apollo extended syntax\n@@ -2552,53 +2594,42 @@ component_declarator:\n \n after_type_component_declarator0:\n \t  after_type_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ frob_specs ($<ftype>0.t, $<ftype>0.lookups);\n-\t\t  $$ = grokfield ($$, current_declspecs, $4, $2,\n-\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n+\t\t{ $$ = parse_field0 ($1, $<ftype>0.t, $<ftype>0.lookups,\n+\t\t\t\t     $3, $2, $4); }\n \t| TYPENAME ':' expr_no_commas maybe_attribute\n-\t\t{ frob_specs ($<ftype>0.t, $<ftype>0.lookups);\n-\t\t  $$ = grokbitfield ($$, current_declspecs, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ $$ = parse_bitfield0 ($1, $<ftype>0.t, $<ftype>0.lookups,\n+\t\t\t\t\t$4, $3); }\n \t;\n \n notype_component_declarator0:\n \t  notype_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ frob_specs ($<ftype>0.t, $<ftype>0.lookups);\n-\t\t  $$ = grokfield ($$, current_declspecs, $4, $2,\n-\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n+\t\t{ $$ = parse_field0 ($1, $<ftype>0.t, $<ftype>0.lookups,\n+\t\t\t\t     $3, $2, $4); }\n \t| constructor_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ frob_specs ($<ftype>0.t, $<ftype>0.lookups);\n-\t\t  $$ = grokfield ($$, current_declspecs, $4, $2,\n-\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n+\t\t{ $$ = parse_field0 ($1, $<ftype>0.t, $<ftype>0.lookups,\n+\t\t\t\t     $3, $2, $4); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n-\t\t{ frob_specs ($<ftype>0.t, $<ftype>0.lookups);\n-\t\t  $$ = grokbitfield ($$, current_declspecs, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ $$ = parse_bitfield0 ($1, $<ftype>0.t, $<ftype>0.lookups,\n+\t\t\t\t\t$4, $3); }\n \t| ':' expr_no_commas maybe_attribute\n-\t\t{ frob_specs ($<ftype>0.t, $<ftype>0.lookups);\n-\t\t  $$ = grokbitfield (NULL_TREE, current_declspecs, $2);\n-\t\t  cplus_decl_attributes ($$, $3, prefix_attributes); }\n+\t\t{ $$ = parse_bitfield0 (NULL_TREE, $<ftype>0.t,\n+\t\t\t\t\t$<ftype>0.lookups, $3, $2); }\n \t;\n \n after_type_component_declarator:\n \t  after_type_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, current_declspecs, $4, $2,\n-\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n+\t\t{ $$ = parse_field ($1, $3, $2, $4); }\n \t| TYPENAME ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ $$ = parse_bitfield ($1, $4, $3); }\n \t;\n \n notype_component_declarator:\n \t  notype_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, current_declspecs, $4, $2,\n-\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n+\t\t{ $$ = parse_field ($1, $3, $2, $4); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n-\t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n+\t\t{ $$ = parse_bitfield ($1, $4, $3); }\n \t| ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokbitfield (NULL_TREE, current_declspecs, $2);\n-\t\t  cplus_decl_attributes ($$, $3, prefix_attributes); }\n+\t\t{ $$ = parse_bitfield (NULL_TREE, $3, $2); }\n \t;\n \n enumlist_opt:"}, {"sha": "7d7f9617476bad748ed8bed0b5ddc5ad7216e0a8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "patch": "@@ -1097,15 +1097,14 @@ friend_accessible_p (scope, type, decl, binfo)\n    When we are done with the decl-specifier-seq, we record the lookups we've\n      seen in the lookups field of the typed_declspecs nonterminal.\n    When we process the first declarator, either in parse_decl or\n-     begin_function_definition, we call initial_deferred_type_access_control,\n-     which processes any lookups from within that declarator, stores the\n-     lookups from the decl-specifier-seq in current_type_lookups, and sets\n-     type_lookups to error_mark_node.\n-   Subsequent declarators process current_type_lookups again to make sure\n-     that the types are accessible to all of the declarators.  Any lookups\n-     within subsequent declarators are processed immediately.\n-   Within a function, type_lookups is error_mark_node, so all lookups are\n-     processed immediately.  */\n+     begin_function_definition, we call save_type_access_control,\n+     which stores the lookups from the decl-specifier-seq in\n+     current_type_lookups.\n+   As we finish with each declarator, we process everything in type_lookups\n+     via decl_type_access_control, which resets type_lookups to the value of\n+     current_type_lookups for subsequent declarators.\n+   When we enter a function, we set type_lookups to error_mark_node, so all\n+     lookups are processed immediately.  */\n \n void\n type_access_control (type, val)"}, {"sha": "a7213628bde73b6e5477d7fa12199511885a6d1d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f51a99218e6eb4214e6a40e9937a7cc419f1e95/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "patch": "@@ -1695,10 +1695,10 @@ static tree current_type_lookups;\n /* Perform deferred access control for types used in the type of a\n    declaration.  */\n \n-void\n+static void\n deferred_type_access_control ()\n {\n-  tree lookup = current_type_lookups;\n+  tree lookup = type_lookups;\n \n   if (lookup == error_mark_node)\n     return;\n@@ -1707,46 +1707,56 @@ deferred_type_access_control ()\n     enforce_access (TREE_PURPOSE (lookup), TREE_VALUE (lookup));\n }\n \n-/* Perform deferred access control for types used in the type of a\n-   declaration.  Called for the first declarator in a declaration.  */\n-\n void\n-initial_deferred_type_access_control (lookups)\n-     tree lookups;\n+decl_type_access_control (decl)\n+     tree decl;\n {\n-  tree lookup = type_lookups;\n+  tree save_fn;\n \n-  /* First perform the checks for the current declarator; they will have\n-     been added to type_lookups since typed_declspecs saved the copy that\n-     we have been passed.  */\n-  if (lookup != error_mark_node)\n-    for (; lookup != lookups; lookup = TREE_CHAIN (lookup))\n-      enforce_access (TREE_PURPOSE (lookup), TREE_VALUE (lookup));\n+  if (type_lookups == error_mark_node)\n+    return;\n+\n+  save_fn = current_function_decl;\n+\n+  if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n+    current_function_decl = decl;\n \n-  current_type_lookups = lookups;\n-  type_lookups = error_mark_node;\n   deferred_type_access_control ();\n-}    \n+\n+  current_function_decl = save_fn;\n+  \n+  /* Now strip away the checks for the current declarator; they were\n+     added to type_lookups after typed_declspecs saved the copy that\n+     ended up in current_type_lookups.  */\n+  type_lookups = current_type_lookups;\n+}\n+\n+void\n+save_type_access_control (lookups)\n+     tree lookups;\n+{\n+  current_type_lookups = lookups;\n+}\n \n /* Begin a function definition declared with DECL_SPECS and\n    DECLARATOR.  Returns non-zero if the function-declaration is\n    legal.  */\n \n int\n-begin_function_definition (decl_specs, lookups, declarator)\n+begin_function_definition (decl_specs, declarator)\n      tree decl_specs;\n-     tree lookups;\n      tree declarator;\n {\n   tree specs;\n   tree attrs;\n \n-  initial_deferred_type_access_control (lookups);\n-  \n   split_specs_attrs (decl_specs, &specs, &attrs);\n   if (!start_function (specs, declarator, attrs, SF_DEFAULT))\n     return 0;\n-  \n+\n+  deferred_type_access_control ();\n+  type_lookups = error_mark_node;\n+\n   reinit_parse_for_function ();\n   /* The things we're about to see are not directly qualified by any\n      template headers we've seen thus far.  */"}]}