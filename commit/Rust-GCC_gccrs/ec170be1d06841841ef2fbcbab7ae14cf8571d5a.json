{"sha": "ec170be1d06841841ef2fbcbab7ae14cf8571d5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMxNzBiZTFkMDY4NDE4NDFlZjJmYmNiYWI3YWUxNGNmODU3MWQ1YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-04-25T15:10:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-19T08:17:12Z"}, "message": "[Ada] Small cleanup in Apply_Range_Check implementation\n\n2020-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* checks.ads (Apply_Static_Length_Check): Move up.\n\t(Apply_Range_Check): Add parameter Insert_Node.\n\t* checks.adb (Apply_Selected_Range_Checks): Merge into...\n\t(Apply_Range_Check): ...this.  Add parameter Insert_Node,\n\tpass it as Warn_Node to Selected_Range_Checks and use it\n\tas insertion point for the checks.\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): Rewrite block\n\tdealing with the range checks for the subtype indication.\n\tUse local variable and call Apply_Range_Check in both cases.", "tree": {"sha": "eb86b0280754f0c22933323a339eeb828a6c0b27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb86b0280754f0c22933323a339eeb828a6c0b27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec170be1d06841841ef2fbcbab7ae14cf8571d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec170be1d06841841ef2fbcbab7ae14cf8571d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec170be1d06841841ef2fbcbab7ae14cf8571d5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec170be1d06841841ef2fbcbab7ae14cf8571d5a/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d48bb126eac73c0d1e311eb4084a6f62742fbf76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d48bb126eac73c0d1e311eb4084a6f62742fbf76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d48bb126eac73c0d1e311eb4084a6f62742fbf76"}], "stats": {"total": 309, "additions": 137, "deletions": 172}, "files": [{"sha": "b22d6f38fdbaf1bf51dd301b6ae9a57db6573888", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 101, "deletions": 122, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec170be1d06841841ef2fbcbab7ae14cf8571d5a/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec170be1d06841841ef2fbcbab7ae14cf8571d5a/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=ec170be1d06841841ef2fbcbab7ae14cf8571d5a", "patch": "@@ -240,16 +240,6 @@ package body Checks is\n    --  described for the above routines. The Do_Static flag indicates that\n    --  only a static check is to be done.\n \n-   procedure Apply_Selected_Range_Checks\n-     (Expr       : Node_Id;\n-      Target_Typ : Entity_Id;\n-      Source_Typ : Entity_Id;\n-      Do_Static  : Boolean);\n-   --  This is the subprogram that does all the work for Apply_Range_Check.\n-   --  Expr, Target_Typ and Source_Typ are as described for the above\n-   --  routine. The Do_Static flag indicates that only a static check is\n-   --  to be done.\n-\n    procedure Compute_Range_For_Arithmetic_Op\n      (Op       : Node_Kind;\n       Lo_Left  : Uint;\n@@ -364,8 +354,8 @@ package body Checks is\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id;\n       Warn_Node  : Node_Id) return Check_Result;\n-   --  Like Apply_Selected_Range_Checks, except it doesn't modify anything,\n-   --  just returns a list of nodes as described in the spec of this package\n+   --  Like Apply_Range_Checks, except it doesn't modify anything, just\n+   --  returns a list of nodes as described in the spec of this package\n    --  for the Range_Check function.\n \n    ------------------------------\n@@ -2910,13 +2900,107 @@ package body Checks is\n    -----------------------\n \n    procedure Apply_Range_Check\n-     (Expr       : Node_Id;\n-      Target_Typ : Entity_Id;\n-      Source_Typ : Entity_Id := Empty)\n+     (Expr        : Node_Id;\n+      Target_Typ  : Entity_Id;\n+      Source_Typ  : Entity_Id := Empty;\n+      Insert_Node : Node_Id   := Empty)\n    is\n+      Checks_On : constant Boolean :=\n+                    not Index_Checks_Suppressed (Target_Typ)\n+                      or else\n+                    not Range_Checks_Suppressed (Target_Typ);\n+\n+      Loc : constant Source_Ptr := Sloc (Expr);\n+\n+      Cond     : Node_Id;\n+      R_Cno    : Node_Id;\n+      R_Result : Check_Result;\n+\n    begin\n-      Apply_Selected_Range_Checks\n-        (Expr, Target_Typ, Source_Typ, Do_Static => False);\n+      --  Only apply checks when generating code. In GNATprove mode, we do not\n+      --  apply the checks, but we still call Selected_Range_Checks to possibly\n+      --  issue errors on SPARK code when a run-time error can be detected at\n+      --  compile time.\n+\n+      if not GNATprove_Mode then\n+         if not Expander_Active or not Checks_On then\n+            return;\n+         end if;\n+      end if;\n+\n+      R_Result :=\n+        Selected_Range_Checks (Expr, Target_Typ, Source_Typ, Insert_Node);\n+\n+      if GNATprove_Mode then\n+         return;\n+      end if;\n+\n+      for J in 1 .. 2 loop\n+         R_Cno := R_Result (J);\n+         exit when No (R_Cno);\n+\n+         --  The range check requires runtime evaluation. Depending on what its\n+         --  triggering condition is, the check may be converted into a compile\n+         --  time constraint check.\n+\n+         if Nkind (R_Cno) = N_Raise_Constraint_Error\n+           and then Present (Condition (R_Cno))\n+         then\n+            Cond := Condition (R_Cno);\n+\n+            --  Insert the range check before the related context. Note that\n+            --  this action analyses the triggering condition.\n+\n+            if Present (Insert_Node) then\n+               Insert_Action (Insert_Node, R_Cno);\n+            else\n+               Insert_Action (Expr, R_Cno);\n+            end if;\n+\n+            --  The triggering condition evaluates to True, the range check\n+            --  can be converted into a compile time constraint check.\n+\n+            if Is_Entity_Name (Cond)\n+              and then Entity (Cond) = Standard_True\n+            then\n+               --  Since an N_Range is technically not an expression, we have\n+               --  to set one of the bounds to C_E and then just flag the\n+               --  N_Range. The warning message will point to the lower bound\n+               --  and complain about a range, which seems OK.\n+\n+               if Nkind (Expr) = N_Range then\n+                  Apply_Compile_Time_Constraint_Error\n+                    (Low_Bound (Expr),\n+                     \"static range out of bounds of}??\",\n+                     CE_Range_Check_Failed,\n+                     Ent => Target_Typ,\n+                     Typ => Target_Typ);\n+\n+                  Set_Raises_Constraint_Error (Expr);\n+\n+               else\n+                  Apply_Compile_Time_Constraint_Error\n+                    (Expr,\n+                     \"static value out of range of}??\",\n+                     CE_Range_Check_Failed,\n+                     Ent => Target_Typ,\n+                     Typ => Target_Typ);\n+               end if;\n+            end if;\n+\n+         --  The range check raises Constraint_Error explicitly\n+\n+         elsif Present (Insert_Node) then\n+            R_Cno :=\n+              Make_Raise_Constraint_Error (Sloc (Insert_Node),\n+                Reason => CE_Range_Check_Failed);\n+\n+            Insert_Action (Insert_Node, R_Cno);\n+\n+         else\n+            Install_Static_Check (R_Cno, Loc);\n+         end if;\n+      end loop;\n    end Apply_Range_Check;\n \n    ------------------------------\n@@ -3429,111 +3513,6 @@ package body Checks is\n       end loop;\n    end Apply_Selected_Length_Checks;\n \n-   ---------------------------------\n-   -- Apply_Selected_Range_Checks --\n-   ---------------------------------\n-\n-   procedure Apply_Selected_Range_Checks\n-     (Expr       : Node_Id;\n-      Target_Typ : Entity_Id;\n-      Source_Typ : Entity_Id;\n-      Do_Static  : Boolean)\n-   is\n-      Checks_On : constant Boolean :=\n-                    not Index_Checks_Suppressed (Target_Typ)\n-                      or else\n-                    not Range_Checks_Suppressed (Target_Typ);\n-\n-      Loc : constant Source_Ptr := Sloc (Expr);\n-\n-      Cond     : Node_Id;\n-      R_Cno    : Node_Id;\n-      R_Result : Check_Result;\n-\n-   begin\n-      --  Only apply checks when generating code. In GNATprove mode, we do not\n-      --  apply the checks, but we still call Selected_Range_Checks to possibly\n-      --  issue errors on SPARK code when a run-time error can be detected at\n-      --  compile time.\n-\n-      if not GNATprove_Mode then\n-         if not Expander_Active or not Checks_On then\n-            return;\n-         end if;\n-      end if;\n-\n-      R_Result :=\n-        Selected_Range_Checks (Expr, Target_Typ, Source_Typ, Empty);\n-\n-      if GNATprove_Mode then\n-         return;\n-      end if;\n-\n-      for J in 1 .. 2 loop\n-         R_Cno := R_Result (J);\n-         exit when No (R_Cno);\n-\n-         --  The range check requires runtime evaluation. Depending on what its\n-         --  triggering condition is, the check may be converted into a compile\n-         --  time constraint check.\n-\n-         if Nkind (R_Cno) = N_Raise_Constraint_Error\n-           and then Present (Condition (R_Cno))\n-         then\n-            Cond := Condition (R_Cno);\n-\n-            --  Insert the range check before the related context. Note that\n-            --  this action analyses the triggering condition.\n-\n-            Insert_Action (Expr, R_Cno);\n-\n-            --  The triggering condition evaluates to True, the range check\n-            --  can be converted into a compile time constraint check.\n-\n-            if Is_Entity_Name (Cond)\n-              and then Entity (Cond) = Standard_True\n-            then\n-               --  Since an N_Range is technically not an expression, we have\n-               --  to set one of the bounds to C_E and then just flag the\n-               --  N_Range. The warning message will point to the lower bound\n-               --  and complain about a range, which seems OK.\n-\n-               if Nkind (Expr) = N_Range then\n-                  Apply_Compile_Time_Constraint_Error\n-                    (Low_Bound (Expr),\n-                     \"static range out of bounds of}??\",\n-                     CE_Range_Check_Failed,\n-                     Ent => Target_Typ,\n-                     Typ => Target_Typ);\n-\n-                  Set_Raises_Constraint_Error (Expr);\n-\n-               else\n-                  Apply_Compile_Time_Constraint_Error\n-                    (Expr,\n-                     \"static value out of range of}??\",\n-                     CE_Range_Check_Failed,\n-                     Ent => Target_Typ,\n-                     Typ => Target_Typ);\n-               end if;\n-\n-            --  If we were only doing a static check, or if checks are not\n-            --  on, then we want to delete the check, since it is not needed.\n-            --  We do this by replacing the if statement by a null statement\n-\n-            elsif Do_Static then\n-               Remove_Warning_Messages (R_Cno);\n-               Rewrite (R_Cno, Make_Null_Statement (Loc));\n-            end if;\n-\n-         --  The range check raises Constraint_Error explicitly\n-\n-         else\n-            Install_Static_Check (R_Cno, Loc);\n-         end if;\n-      end loop;\n-   end Apply_Selected_Range_Checks;\n-\n    -------------------------------\n    -- Apply_Static_Length_Check --\n    -------------------------------"}, {"sha": "46fdda86c003b2e0682bba6606af66eac2203c0e", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec170be1d06841841ef2fbcbab7ae14cf8571d5a/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec170be1d06841841ef2fbcbab7ae14cf8571d5a/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=ec170be1d06841841ef2fbcbab7ae14cf8571d5a", "patch": "@@ -578,10 +578,20 @@ package Checks is\n    --  which the check is to be done. Used to filter out specific cases where\n    --  the check is superfluous.\n \n-   procedure Apply_Range_Check\n+   procedure Apply_Static_Length_Check\n      (Expr       : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty);\n+   --  Tries to determine statically whether the two array types source type\n+   --  and Target_Typ have the same length. If it can be determined at compile\n+   --  time that they do not, then an N_Raise_Constraint_Error node replaces\n+   --  Expr, and a warning message is issued.\n+\n+   procedure Apply_Range_Check\n+     (Expr        : Node_Id;\n+      Target_Typ  : Entity_Id;\n+      Source_Typ  : Entity_Id := Empty;\n+      Insert_Node : Node_Id   := Empty);\n    --  For a Node of kind N_Range, constructs a range check action that tests\n    --  first that the range is not null and then that the range is contained in\n    --  the Target_Typ range.\n@@ -606,14 +616,8 @@ package Checks is\n    --  The source type is used by type conversions to unconstrained array\n    --  types to retrieve the corresponding bounds.\n \n-   procedure Apply_Static_Length_Check\n-     (Expr       : Node_Id;\n-      Target_Typ : Entity_Id;\n-      Source_Typ : Entity_Id := Empty);\n-   --  Tries to determine statically whether the two array types source type\n-   --  and Target_Typ have the same length. If it can be determined at compile\n-   --  time that they do not, then an N_Raise_Constraint_Error node replaces\n-   --  Expr, and a warning message is issued.\n+   --  Insert_Node indicates the node where the check should be inserted.\n+   --  If it is empty, then the check is inserted directly at Expr instead.\n \n    procedure Apply_Scalar_Range_Check\n      (Expr       : Node_Id;"}, {"sha": "e33e3b35912376b0652229048170b29a0348dd7f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 23, "deletions": 41, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec170be1d06841841ef2fbcbab7ae14cf8571d5a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec170be1d06841841ef2fbcbab7ae14cf8571d5a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ec170be1d06841841ef2fbcbab7ae14cf8571d5a", "patch": "@@ -5266,7 +5266,6 @@ package body Sem_Ch3 is\n       Skip : Boolean := False)\n    is\n       Id       : constant Entity_Id := Defining_Identifier (N);\n-      R_Checks : Check_Result;\n       T        : Entity_Id;\n \n    begin\n@@ -5791,63 +5790,46 @@ package body Sem_Ch3 is\n \n       --  Check that Constraint_Error is raised for a scalar subtype indication\n       --  when the lower or upper bound of a non-null range lies outside the\n-      --  range of the type mark.\n+      --  range of the type mark. Likewise for an array subtype, but check the\n+      --  compatibility for each index.\n \n       if Nkind (Subtype_Indication (N)) = N_Subtype_Indication then\n-         if Is_Scalar_Type (Etype (Id))\n-           and then Scalar_Range (Id) /=\n-                    Scalar_Range\n-                      (Etype (Subtype_Mark (Subtype_Indication (N))))\n-         then\n-            Apply_Range_Check\n-              (Scalar_Range (Id),\n-               Etype (Subtype_Mark (Subtype_Indication (N))));\n-\n-         --  In the array case, check compatibility for each index\n+         declare\n+            Indic_Typ    : constant Entity_Id :=\n+                             Etype (Subtype_Mark (Subtype_Indication (N)));\n+            Subt_Index   : Node_Id;\n+            Target_Index : Node_Id;\n \n-         elsif Is_Array_Type (Etype (Id)) and then Present (First_Index (Id))\n-         then\n-            --  This really should be a subprogram that finds the indications\n-            --  to check???\n+         begin\n+            if Is_Scalar_Type (Etype (Id))\n+              and then Scalar_Range (Id) /= Scalar_Range (Indic_Typ)\n+            then\n+               Apply_Range_Check (Scalar_Range (Id), Indic_Typ);\n \n-            declare\n-               Subt_Index   : Node_Id := First_Index (Id);\n-               Target_Index : Node_Id :=\n-                                First_Index (Etype\n-                                  (Subtype_Mark (Subtype_Indication (N))));\n+            elsif Is_Array_Type (Etype (Id))\n+              and then Present (First_Index (Id))\n+            then\n+               Subt_Index   := First_Index (Id);\n+               Target_Index := First_Index (Indic_Typ);\n \n-            begin\n                while Present (Subt_Index) loop\n                   if ((Nkind (Subt_Index) = N_Identifier\n                         and then Ekind (Entity (Subt_Index)) in Scalar_Kind)\n                        or else Nkind (Subt_Index) = N_Subtype_Indication)\n                     and then\n                       Nkind (Scalar_Range (Etype (Subt_Index))) = N_Range\n                   then\n-                     declare\n-                        Target_Typ : constant Entity_Id :=\n-                                       Etype (Target_Index);\n-                     begin\n-                        R_Checks :=\n-                          Get_Range_Checks\n-                            (Scalar_Range (Etype (Subt_Index)),\n-                             Target_Typ,\n-                             Etype (Subt_Index),\n-                             Defining_Identifier (N));\n-\n-                        Insert_Range_Checks\n-                          (R_Checks,\n-                           N,\n-                           Target_Typ,\n-                           Sloc (Defining_Identifier (N)));\n-                     end;\n+                     Apply_Range_Check\n+                       (Scalar_Range (Etype (Subt_Index)),\n+                        Etype (Target_Index),\n+                        Insert_Node => N);\n                   end if;\n \n                   Next_Index (Subt_Index);\n                   Next_Index (Target_Index);\n                end loop;\n-            end;\n-         end if;\n+            end if;\n+         end;\n       end if;\n \n       Set_Optimize_Alignment_Flags (Id);"}]}