{"sha": "8403c2cf5f66758fc78a01a675b0d218fded0202", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQwM2MyY2Y1ZjY2NzU4ZmM3OGEwMWE2NzViMGQyMThmZGVkMDIwMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-24T14:07:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-24T14:07:18Z"}, "message": "re PR target/63679 ([AArch64] Failure to constant fold.)\n\n2014-11-24  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/63679\n\t* tree-ssa-sccvn.c: Include ipa-ref.h, plugin-api.h and cgraph.h.\n\t(copy_reference_ops_from_ref): Fix non-constant ADDR_EXPR case\n\tto properly leave off at -1.\n\t(fully_constant_vn_reference_p): Generalize folding from\n\tconstant initializers.\n\t(vn_reference_lookup_3): When looking through aggregate copies\n\thandle offsetted reads and try simplifying the result to\n\ta constant.\n\t* gimple-fold.h (fold_ctor_reference): Export.\n\t* gimple-fold.c (fold_ctor_reference): Likewise.\n\n\t* gcc.dg/tree-ssa/ssa-fre-42.c: New testcase.\n\t* gcc.dg/tree-ssa/20030807-5.c: Avoid folding read from global to zero.\n\t* gcc.target/i386/ssetype-1.c: Likewise.\n\t* gcc.target/i386/ssetype-3.c: Likewise.\n\t* gcc.target/i386/ssetype-5.c: Likewise.\n\nFrom-SVN: r218019", "tree": {"sha": "67f5be1ec46132969be310c870c5591ebbadbab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67f5be1ec46132969be310c870c5591ebbadbab2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8403c2cf5f66758fc78a01a675b0d218fded0202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8403c2cf5f66758fc78a01a675b0d218fded0202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8403c2cf5f66758fc78a01a675b0d218fded0202", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8403c2cf5f66758fc78a01a675b0d218fded0202/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "34a4625c52673828ff9b1eac7f68b5d23b58c5f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a4625c52673828ff9b1eac7f68b5d23b58c5f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34a4625c52673828ff9b1eac7f68b5d23b58c5f5"}], "stats": {"total": 189, "additions": 159, "deletions": 30}, "files": [{"sha": "cadd82f65c72d7d3382f3fb53ade8f5c33d6ae6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -1,3 +1,17 @@\n+2014-11-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63679\n+\t* tree-ssa-sccvn.c: Include ipa-ref.h, plugin-api.h and cgraph.h.\n+\t(copy_reference_ops_from_ref): Fix non-constant ADDR_EXPR case\n+\tto properly leave off at -1.\n+\t(fully_constant_vn_reference_p): Generalize folding from\n+\tconstant initializers.\n+\t(vn_reference_lookup_3): When looking through aggregate copies\n+\thandle offsetted reads and try simplifying the result to\n+\ta constant.\n+\t* gimple-fold.h (fold_ctor_reference): Export.\n+\t* gimple-fold.c (fold_ctor_reference): Likewise.\n+\n 2014-11-24  Petr Murzin  <petr.murzin@intel.com>\n \n \t* simplify-rtx.c (simplify_ternary_operation): Simplify"}, {"sha": "98ec1176a7c90aaa5408a5c18530742f1f3f05ad", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -4788,10 +4788,6 @@ gimple_fold_stmt_to_constant (gimple stmt, tree (*valueize) (tree))\n /* The following set of functions are supposed to fold references using\n    their constant initializers.  */\n \n-static tree fold_ctor_reference (tree type, tree ctor,\n-\t\t\t\t unsigned HOST_WIDE_INT offset,\n-\t\t\t\t unsigned HOST_WIDE_INT size, tree);\n-\n /* See if we can find constructor defining value of BASE.\n    When we know the consructor with constant offset (such as\n    base is array[40] and we do know constructor of array), then\n@@ -5027,7 +5023,7 @@ fold_nonarray_ctor_reference (tree type, tree ctor,\n /* CTOR is value initializing memory, fold reference of type TYPE and size SIZE\n    to the memory at bit OFFSET.  */\n \n-static tree\n+tree\n fold_ctor_reference (tree type, tree ctor, unsigned HOST_WIDE_INT offset,\n \t\t     unsigned HOST_WIDE_INT size, tree from_decl)\n {"}, {"sha": "7574de85d184b151b5e1b60dfc2cc0680e92d649", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -39,6 +39,8 @@ extern tree follow_single_use_edges (tree);\n extern tree gimple_fold_stmt_to_constant_1 (gimple, tree (*) (tree),\n \t\t\t\t\t    tree (*) (tree) = no_follow_ssa_edges);\n extern tree gimple_fold_stmt_to_constant (gimple, tree (*) (tree));\n+extern tree fold_ctor_reference (tree, tree, unsigned HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT, tree);\n extern tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));\n extern tree fold_const_aggregate_ref (tree);\n extern tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree,"}, {"sha": "7db895bd2a227073191e292982fbea6d67962f13", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -1,3 +1,12 @@\n+2014-11-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63679\n+\t* gcc.dg/tree-ssa/ssa-fre-42.c: New testcase.\n+\t* gcc.dg/tree-ssa/20030807-5.c: Avoid folding read from global to zero.\n+\t* gcc.target/i386/ssetype-1.c: Likewise.\n+\t* gcc.target/i386/ssetype-3.c: Likewise.\n+\t* gcc.target/i386/ssetype-5.c: Likewise.\n+\n 2014-11-24  Jonathan Wakely  <jwakely@redhat.com>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "2397644129f7f596c4e9920dd7d1a35c9bb06cfd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030807-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-5.c?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -13,7 +13,7 @@ struct rtx_def\n   unsigned int unchanging:1;\n \n };\n-static rtx current_sym_addr;\n+rtx current_sym_addr;\n \n int\n foo ()"}, {"sha": "c90bb0de957e6039cf2e2f684eecddd8c2465ec0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-42.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-42.c?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"-O -fdump-tree-fre1\" } */\n+\n+extern void abort (void);\n+\n+struct X { int a[128]; };\n+static const struct X a = { 0, 1, 2, 3 };\n+/* Prevent gimplify_modify_expr_rhs / gimplify_init_constructor from\n+   expanding the aggregate copy below inline.  */\n+static const struct X A __attribute__((alias(\"a\")));\n+struct X *q;\n+int __attribute__((noinline))\n+foo ()\n+{\n+  struct X b = A;\n+  int *p = &b.a[2];\n+  /* Prevent SRA from decomposing b.  */\n+  q = &b;\n+  return *p;\n+}\n+\n+int main()\n+{\n+  if (foo() != 2)\n+    abort ();\n+  return 0;\n+}\n+\n+/* Verify the aggregate copy we want to look through is still in place.  */\n+/* { dg-final { scan-tree-dump \"b = A;\" \"fre1\" } } */\n+/* Verify we have propagated the element read all the way to the return.  */\n+/* { dg-final { scan-tree-dump \"return 2\" \"fre1\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "34185dd01f294877b3004d80b935be51eb92268c", "filename": "gcc/testsuite/gcc.target/i386/ssetype-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-1.c?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -14,7 +14,7 @@\n \n #include <xmmintrin.h>\n \n-static __m128d magic_a, magic_b;\n+__m128d magic_a, magic_b;\n \n __m128d\n t1(void)"}, {"sha": "c2eff2be1348a09ec7d0c10968f9791331899e83", "filename": "gcc/testsuite/gcc.target/i386/ssetype-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-3.c?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -13,7 +13,7 @@\n \n #include <xmmintrin.h>\n \n-static __m128 magic_a, magic_b;\n+__m128 magic_a, magic_b;\n __m128\n t1(void)\n {"}, {"sha": "2dd2de4f0c6b445fa5f52c7c04040c76fcd274fe", "filename": "gcc/testsuite/gcc.target/i386/ssetype-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssetype-5.c?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -13,7 +13,7 @@\n /* Verify that we generate proper instruction with memory operand.  */\n \n #include <xmmintrin.h>\n-static __m128i magic_a, magic_b;\n+__m128i magic_a, magic_b;\n __m128i\n t1(void)\n {"}, {"sha": "8b3f2c7f058e9075a7bdd9076eda67670a237da0", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 95, "deletions": 21, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8403c2cf5f66758fc78a01a675b0d218fded0202/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=8403c2cf5f66758fc78a01a675b0d218fded0202", "patch": "@@ -65,6 +65,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-sccvn.h\"\n #include \"tree-cfg.h\"\n #include \"domwalk.h\"\n+#include \"ipa-ref.h\"\n+#include \"plugin-api.h\"\n+#include \"cgraph.h\"\n \n /* This algorithm is based on the SCC algorithm presented by Keith\n    Cooper and L. Taylor Simpson in \"SCC-Based Value numbering\"\n@@ -920,7 +923,7 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \t      temp.op0 = ref;\n \t      break;\n \t    }\n-\t  /* Fallthrough.  */\n+\t  break;\n \t  /* These are only interesting for their operands, their\n \t     existence, and their type.  They will never be the last\n \t     ref in the chain of references (IE they require an\n@@ -1325,24 +1328,66 @@ fully_constant_vn_reference_p (vn_reference_t ref)\n \t}\n     }\n \n-  /* Simplify reads from constant strings.  */\n-  else if (op->opcode == ARRAY_REF\n-\t   && TREE_CODE (op->op0) == INTEGER_CST\n-\t   && integer_zerop (op->op1)\n-\t   && operands.length () == 2)\n+  /* Simplify reads from constants or constant initializers.  */\n+  else if (BITS_PER_UNIT == 8\n+\t   && is_gimple_reg_type (ref->type)\n+\t   && (!INTEGRAL_TYPE_P (ref->type)\n+\t       || TYPE_PRECISION (ref->type) % BITS_PER_UNIT == 0))\n     {\n-      vn_reference_op_t arg0;\n-      arg0 = &operands[1];\n-      if (arg0->opcode == STRING_CST\n-\t  && (TYPE_MODE (op->type)\n-\t      == TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0->op0))))\n-\t  && GET_MODE_CLASS (TYPE_MODE (op->type)) == MODE_INT\n-\t  && GET_MODE_SIZE (TYPE_MODE (op->type)) == 1\n-\t  && tree_int_cst_sgn (op->op0) >= 0\n-\t  && compare_tree_int (op->op0, TREE_STRING_LENGTH (arg0->op0)) < 0)\n-\treturn build_int_cst_type (op->type,\n-\t\t\t\t   (TREE_STRING_POINTER (arg0->op0)\n-\t\t\t\t    [TREE_INT_CST_LOW (op->op0)]));\n+      HOST_WIDE_INT off = 0;\n+      HOST_WIDE_INT size = tree_to_shwi (TYPE_SIZE (ref->type));\n+      if (size % BITS_PER_UNIT != 0\n+\t  || size > MAX_BITSIZE_MODE_ANY_MODE)\n+\treturn NULL_TREE;\n+      size /= BITS_PER_UNIT;\n+      unsigned i;\n+      for (i = 0; i < operands.length (); ++i)\n+\t{\n+\t  if (operands[i].off == -1)\n+\t    return NULL_TREE;\n+\t  off += operands[i].off;\n+\t  if (operands[i].opcode == MEM_REF)\n+\t    {\n+\t      ++i;\n+\t      break;\n+\t    }\n+\t}\n+      vn_reference_op_t base = &operands[--i];\n+      tree ctor = error_mark_node;\n+      tree decl = NULL_TREE;\n+      if (TREE_CODE_CLASS (base->opcode) == tcc_constant)\n+\tctor = base->op0;\n+      else if (base->opcode == MEM_REF\n+\t       && base[1].opcode == ADDR_EXPR\n+\t       && (TREE_CODE (TREE_OPERAND (base[1].op0, 0)) == VAR_DECL\n+\t\t   || TREE_CODE (TREE_OPERAND (base[1].op0, 0)) == CONST_DECL))\n+\t{\n+\t  decl = TREE_OPERAND (base[1].op0, 0);\n+\t  ctor = ctor_for_folding (decl);\n+\t}\n+      if (ctor == NULL_TREE)\n+\treturn build_zero_cst (ref->type);\n+      else if (ctor != error_mark_node)\n+\t{\n+\t  if (decl)\n+\t    {\n+\t      tree res = fold_ctor_reference (ref->type, ctor,\n+\t\t\t\t\t      off * BITS_PER_UNIT,\n+\t\t\t\t\t      size * BITS_PER_UNIT, decl);\n+\t      if (res)\n+\t\t{\n+\t\t  STRIP_USELESS_TYPE_CONVERSION (res);\n+\t\t  if (is_gimple_min_invariant (res))\n+\t\t    return res;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned char buf[MAX_BITSIZE_MODE_ANY_MODE / BITS_PER_UNIT];\n+\t      if (native_encode_expr (ctor, buf, size, off) > 0)\n+\t\treturn native_interpret_expr (ref->type, buf, size);\n+\t    }\n+\t}\n     }\n \n   return NULL_TREE;\n@@ -1850,11 +1895,20 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t may fail when comparing types for compatibility.  But we really\n \t don't care here - further lookups with the rewritten operands\n \t will simply fail if we messed up types too badly.  */\n+      HOST_WIDE_INT extra_off = 0;\n       if (j == 0 && i >= 0\n \t  && lhs_ops[0].opcode == MEM_REF\n-\t  && lhs_ops[0].off != -1\n-\t  && (lhs_ops[0].off == vr->operands[i].off))\n-\ti--, j--;\n+\t  && lhs_ops[0].off != -1)\n+\t{\n+\t  if (lhs_ops[0].off == vr->operands[i].off)\n+\t    i--, j--;\n+\t  else if (vr->operands[i].opcode == MEM_REF\n+\t\t   && vr->operands[i].off != -1)\n+\t    {\n+\t      extra_off = vr->operands[i].off - lhs_ops[0].off;\n+\t      i--, j--;\n+\t    }\n+\t}\n \n       /* i now points to the first additional op.\n \t ???  LHS may not be completely contained in VR, one or more\n@@ -1865,6 +1919,20 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \n       /* Now re-write REF to be based on the rhs of the assignment.  */\n       copy_reference_ops_from_ref (gimple_assign_rhs1 (def_stmt), &rhs);\n+\n+      /* Apply an extra offset to the inner MEM_REF of the RHS.  */\n+      if (extra_off != 0)\n+\t{\n+\t  if (rhs.length () < 2\n+\t      || rhs[0].opcode != MEM_REF\n+\t      || rhs[0].off == -1)\n+\t    return (void *)-1;\n+\t  rhs[0].off += extra_off;\n+\t  rhs[0].op0 = int_const_binop (PLUS_EXPR, rhs[0].op0,\n+\t\t\t\t\tbuild_int_cst (TREE_TYPE (rhs[0].op0),\n+\t\t\t\t\t\t       extra_off));\n+\t}\n+\n       /* We need to pre-pend vr->operands[0..i] to rhs.  */\n       vec<vn_reference_op_s> old = vr->operands;\n       if (i + 1 + rhs.length () > vr->operands.length ())\n@@ -1882,6 +1950,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \tshared_lookup_references = vr->operands;\n       vr->hashcode = vn_reference_compute_hash (vr);\n \n+      /* Try folding the new reference to a constant.  */\n+      tree val = fully_constant_vn_reference_p (vr);\n+      if (val)\n+\treturn vn_reference_lookup_or_insert_for_pieces\n+\t\t (vuse, vr->set, vr->type, vr->operands, val);\n+\n       /* Adjust *ref from the new operands.  */\n       if (!ao_ref_init_from_vn_reference (&r, vr->set, vr->type, vr->operands))\n \treturn (void *)-1;"}]}