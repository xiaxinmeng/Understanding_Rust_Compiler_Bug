{"sha": "b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0NGFhN2I5NTllNGI5YThiMTQyMGJjMTFkZDVmZjZmZGM0MTliZg==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2006-10-23T20:17:45Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2006-10-23T20:17:45Z"}, "message": "* config/xtensa/lib1funcs.asm: Use C-style comments.\n\nFrom-SVN: r117982", "tree": {"sha": "953847bab0ded60003fea38ca317c0d92519fcf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/953847bab0ded60003fea38ca317c0d92519fcf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf/comments", "author": null, "committer": null, "parents": [{"sha": "c79efc4d2a3f51f42e2b120c9536a262776f2840", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c79efc4d2a3f51f42e2b120c9536a262776f2840", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c79efc4d2a3f51f42e2b120c9536a262776f2840"}], "stats": {"total": 142, "additions": 73, "deletions": 69}, "files": [{"sha": "26a10a8a773e8c59da36ffd5c020e296e91c2ea9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf", "patch": "@@ -1,3 +1,7 @@\n+2006-10-23  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/lib1funcs.asm: Use C-style comments.\n+\n 2006-10-23 Rafael Avila de Espindola  <rafael.espindola@gmail.com>\n \n \t* tree.c (local_define_builtin): Replace calls to"}, {"sha": "6392fa2a87f19e0e081a45a2c26ef5fe46dba31a", "filename": "gcc/config/xtensa/lib1funcs.asm", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm?ref=b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf", "patch": "@@ -30,8 +30,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"xtensa-config.h\"\n \n-# Define macros for the ABS and ADDX* instructions to handle cases\n-# where they are not included in the Xtensa processor configuration.\n+/* Define macros for the ABS and ADDX* instructions to handle cases\n+   where they are not included in the Xtensa processor configuration.  */\n \n \t.macro\tdo_abs dst, src, tmp\n #if XCHAL_HAVE_ABS\n@@ -70,10 +70,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #endif\n \t.endm\n \n-# Define macros for leaf function entry and return, supporting either the\n-# standard register windowed ABI or the non-windowed call0 ABI.  These\n-# macros do not allocate any extra stack space, so they only work for\n-# leaf functions that do not need to spill anything to the stack.\n+/* Define macros for leaf function entry and return, supporting either the\n+   standard register windowed ABI or the non-windowed call0 ABI.  These\n+   macros do not allocate any extra stack space, so they only work for\n+   leaf functions that do not need to spill anything to the stack.  */\n \n \t.macro leaf_entry reg, size\n #if XCHAL_HAVE_WINDOWED && !__XTENSA_CALL0_ABI__\n@@ -126,20 +126,20 @@ __mulsi3:\n \n #else /* !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MAC16 */\n \n-\t# Multiply one bit at a time, but unroll the loop 4x to better\n-\t# exploit the addx instructions and avoid overhead.\n-\t# Peel the first iteration to save a cycle on init.\n+\t/* Multiply one bit at a time, but unroll the loop 4x to better\n+\t   exploit the addx instructions and avoid overhead.\n+\t   Peel the first iteration to save a cycle on init.  */\n \n-\t# Avoid negative numbers.\n-\txor\ta5, a2, a3  # top bit is 1 iff one of the inputs is negative\n+\t/* Avoid negative numbers.  */\n+\txor\ta5, a2, a3\t/* Top bit is 1 if one input is negative.  */\n \tdo_abs\ta3, a3, a6\n \tdo_abs\ta2, a2, a6\n \n-\t# Swap so the second argument is smaller.\n+\t/* Swap so the second argument is smaller.  */\n \tsub\ta7, a2, a3\n \tmov\ta4, a3\n-\tmovgez\ta4, a2, a7  # a4 = max(a2, a3) \n-\tmovltz\ta3, a2, a7  # a3 = min(a2, a3)\n+\tmovgez\ta4, a2, a7\t/* a4 = max (a2, a3) */\n+\tmovltz\ta3, a2, a7\t/* a3 = min (a2, a3) */\n \n \tmovi\ta2, 0\n \textui\ta6, a3, 0, 1\n@@ -196,10 +196,10 @@ __mulsi3:\n #endif /* L_mulsi3 */\n \n \n-# Define a macro for the NSAU (unsigned normalize shift amount)\n-# instruction, which computes the number of leading zero bits,\n-# to handle cases where it is not included in the Xtensa processor\n-# configuration.\n+/* Define a macro for the NSAU (unsigned normalize shift amount)\n+   instruction, which computes the number of leading zero bits,\n+   to handle cases where it is not included in the Xtensa processor\n+   configuration.  */\n \n \t.macro\tdo_nsau cnt, val, tmp, a\n #if XCHAL_HAVE_NSA\n@@ -260,19 +260,19 @@ __nsau_data:\n \t.type\t__udivsi3,@function\n __udivsi3:\n \tleaf_entry sp, 16\n-\tbltui\ta3, 2, .Lle_one\t# check if the divisor <= 1\n+\tbltui\ta3, 2, .Lle_one\t/* check if the divisor <= 1 */\n \n-\tmov\ta6, a2\t\t# keep dividend in a6\n-\tdo_nsau\ta5, a6, a2, a7\t# dividend_shift = nsau(dividend)\n-\tdo_nsau\ta4, a3, a2, a7\t# divisor_shift = nsau(divisor)\n+\tmov\ta6, a2\t\t/* keep dividend in a6 */\n+\tdo_nsau\ta5, a6, a2, a7\t/* dividend_shift = nsau (dividend) */\n+\tdo_nsau\ta4, a3, a2, a7\t/* divisor_shift = nsau (divisor) */\n \tbgeu\ta5, a4, .Lspecial\n \n-\tsub\ta4, a4, a5\t# count = divisor_shift - dividend_shift\n+\tsub\ta4, a4, a5\t/* count = divisor_shift - dividend_shift */\n \tssl\ta4\n-\tsll\ta3, a3\t\t# divisor <<= count\n-\tmovi\ta2, 0\t\t# quotient = 0\n+\tsll\ta3, a3\t\t/* divisor <<= count */\n+\tmovi\ta2, 0\t\t/* quotient = 0 */\n \n-\t# test-subtract-and-shift loop; one quotient bit on each iteration\n+\t/* test-subtract-and-shift loop; one quotient bit on each iteration */\n #if XCHAL_HAVE_LOOPS\n \tloopnez\ta4, .Lloopend\n #endif /* XCHAL_HAVE_LOOPS */\n@@ -290,22 +290,22 @@ __udivsi3:\n .Lloopend:\n \n \tbltu\ta6, a3, .Lreturn\n-\taddi\ta2, a2, 1\t# increment quotient if dividend >= divisor\n+\taddi\ta2, a2, 1\t/* increment quotient if dividend >= divisor */\n .Lreturn:\n \tleaf_return\n \n .Lle_one:\n-\tbeqz\ta3, .Lerror\t# if divisor == 1, return the dividend\n+\tbeqz\ta3, .Lerror\t/* if divisor == 1, return the dividend */\n \tleaf_return\n \n .Lspecial:\n-\t# return dividend >= divisor\n+\t/* return dividend >= divisor */\n \tbltu\ta6, a3, .Lreturn0\n \tmovi\ta2, 1\n \tleaf_return\n \n .Lerror:\n-\t# just return 0; could throw an exception\n+\t/* just return 0; could throw an exception */\n \n .Lreturn0:\n \tmovi\ta2, 0\n@@ -321,20 +321,20 @@ __udivsi3:\n \t.type\t__divsi3,@function\n __divsi3:\n \tleaf_entry sp, 16\n-\txor\ta7, a2, a3\t# sign = dividend ^ divisor\n-\tdo_abs\ta6, a2, a4\t# udividend = abs(dividend)\n-\tdo_abs\ta3, a3, a4\t# udivisor = abs(divisor)\n-\tbltui\ta3, 2, .Lle_one\t# check if udivisor <= 1\n-\tdo_nsau\ta5, a6, a2, a8\t# udividend_shift = nsau(udividend)\n-\tdo_nsau\ta4, a3, a2, a8\t# udivisor_shift = nsau(udivisor)\n+\txor\ta7, a2, a3\t/* sign = dividend ^ divisor */\n+\tdo_abs\ta6, a2, a4\t/* udividend = abs (dividend) */\n+\tdo_abs\ta3, a3, a4\t/* udivisor = abs (divisor) */\n+\tbltui\ta3, 2, .Lle_one\t/* check if udivisor <= 1 */\n+\tdo_nsau\ta5, a6, a2, a8\t/* udividend_shift = nsau (udividend) */\n+\tdo_nsau\ta4, a3, a2, a8\t/* udivisor_shift = nsau (udivisor) */\n \tbgeu\ta5, a4, .Lspecial\n \n-\tsub\ta4, a4, a5\t# count = udivisor_shift - udividend_shift\n+\tsub\ta4, a4, a5\t/* count = udivisor_shift - udividend_shift */\n \tssl\ta4\n-\tsll\ta3, a3\t\t# udivisor <<= count\n-\tmovi\ta2, 0\t\t# quotient = 0\n+\tsll\ta3, a3\t\t/* udivisor <<= count */\n+\tmovi\ta2, 0\t\t/* quotient = 0 */\n \n-\t# test-subtract-and-shift loop; one quotient bit on each iteration\n+\t/* test-subtract-and-shift loop; one quotient bit on each iteration */\n #if XCHAL_HAVE_LOOPS\n \tloopnez\ta4, .Lloopend\n #endif /* XCHAL_HAVE_LOOPS */\n@@ -352,27 +352,27 @@ __divsi3:\n .Lloopend:\n \n \tbltu\ta6, a3, .Lreturn\n-\taddi\ta2, a2, 1\t# increment quotient if udividend >= udivisor\n+\taddi\ta2, a2, 1\t/* increment if udividend >= udivisor */\n .Lreturn:\n \tneg\ta5, a2\n-\tmovltz\ta2, a5, a7\t# return (sign < 0) ? -quotient : quotient\n+\tmovltz\ta2, a5, a7\t/* return (sign < 0) ? -quotient : quotient */\n \tleaf_return\n \n .Lle_one:\n \tbeqz\ta3, .Lerror\n-\tneg\ta2, a6\t\t# if udivisor == 1, then return...\n-\tmovgez\ta2, a6, a7\t# (sign < 0) ? -udividend : udividend\n+\tneg\ta2, a6\t\t/* if udivisor == 1, then return... */\n+\tmovgez\ta2, a6, a7\t/* (sign < 0) ? -udividend : udividend */\n \tleaf_return\n \n .Lspecial:\n-\tbltu\ta6, a3, .Lreturn0 #  if dividend < divisor, return 0\n+\tbltu\ta6, a3, .Lreturn0 /* if dividend < divisor, return 0 */\n \tmovi\ta2, 1\n \tmovi\ta4, -1\n-\tmovltz\ta2, a4, a7\t# else return (sign < 0) ? -1 :\t 1 \n+\tmovltz\ta2, a4, a7\t/* else return (sign < 0) ? -1 : 1 */\n \tleaf_return\n \n .Lerror:\n-\t# just return 0; could throw an exception\n+\t/* just return 0; could throw an exception */\n \n .Lreturn0:\n \tmovi\ta2, 0\n@@ -388,17 +388,17 @@ __divsi3:\n \t.type\t__umodsi3,@function\n __umodsi3:\n \tleaf_entry sp, 16\n-\tbltui\ta3, 2, .Lle_one\t# check if the divisor is <= 1\n+\tbltui\ta3, 2, .Lle_one\t/* check if the divisor is <= 1 */\n \n-\tdo_nsau\ta5, a2, a6, a7\t# dividend_shift = nsau(dividend)\n-\tdo_nsau\ta4, a3, a6, a7\t# divisor_shift = nsau(divisor)\n+\tdo_nsau\ta5, a2, a6, a7\t/* dividend_shift = nsau (dividend) */\n+\tdo_nsau\ta4, a3, a6, a7\t/* divisor_shift = nsau (divisor) */\n \tbgeu\ta5, a4, .Lspecial\n \n-\tsub\ta4, a4, a5\t# count = divisor_shift - dividend_shift\n+\tsub\ta4, a4, a5\t/* count = divisor_shift - dividend_shift */\n \tssl\ta4\n-\tsll\ta3, a3\t\t# divisor <<= count\n+\tsll\ta3, a3\t\t/* divisor <<= count */\n \n-\t# test-subtract-and-shift loop\n+\t/* test-subtract-and-shift loop */\n #if XCHAL_HAVE_LOOPS\n \tloopnez\ta4, .Lloopend\n #endif /* XCHAL_HAVE_LOOPS */\n@@ -415,13 +415,13 @@ __umodsi3:\n \n .Lspecial:\n \tbltu\ta2, a3, .Lreturn\n-\tsub\ta2, a2, a3\t# subtract once more if dividend >= divisor\n+\tsub\ta2, a2, a3\t/* subtract once more if dividend >= divisor */\n .Lreturn:\n \tleaf_return\n \n .Lle_one:\n-\t# the divisor is either 0 or 1, so just return 0.\n-\t# someday we may want to throw an exception if the divisor is 0.\n+\t/* The divisor is either 0 or 1, so just return 0.\n+\t   Someday we may want to throw an exception if the divisor is 0.  */\n \tmovi\ta2, 0\n \tleaf_return\n \t.size\t__umodsi3,.-__umodsi3\n@@ -435,19 +435,19 @@ __umodsi3:\n \t.type\t__modsi3,@function\n __modsi3:\n \tleaf_entry sp, 16\n-\tmov\ta7, a2\t\t# save original (signed) dividend\n-\tdo_abs\ta2, a2, a4\t# udividend = abs(dividend)\n-\tdo_abs\ta3, a3, a4\t# udivisor = abs(divisor)\n-\tbltui\ta3, 2, .Lle_one\t# check if udivisor <= 1\n-\tdo_nsau\ta5, a2, a6, a8\t# udividend_shift = nsau(udividend)\n-\tdo_nsau\ta4, a3, a6, a8\t# udivisor_shift = nsau(udivisor)\n+\tmov\ta7, a2\t\t/* save original (signed) dividend */\n+\tdo_abs\ta2, a2, a4\t/* udividend = abs (dividend) */\n+\tdo_abs\ta3, a3, a4\t/* udivisor = abs (divisor) */\n+\tbltui\ta3, 2, .Lle_one\t/* check if udivisor <= 1 */\n+\tdo_nsau\ta5, a2, a6, a8\t/* udividend_shift = nsau (udividend) */\n+\tdo_nsau\ta4, a3, a6, a8\t/* udivisor_shift = nsau (udivisor) */\n \tbgeu\ta5, a4, .Lspecial\n \n-\tsub\ta4, a4, a5\t# count = udivisor_shift - udividend_shift\n+\tsub\ta4, a4, a5\t/* count = udivisor_shift - udividend_shift */\n \tssl\ta4\n-\tsll\ta3, a3\t\t# udivisor <<= count\n+\tsll\ta3, a3\t\t/* udivisor <<= count */\n \n-\t# test-subtract-and-shift loop\n+\t/* test-subtract-and-shift loop */\n #if XCHAL_HAVE_LOOPS\n \tloopnez\ta4, .Lloopend\n #endif /* XCHAL_HAVE_LOOPS */\n@@ -464,16 +464,16 @@ __modsi3:\n \n .Lspecial:\n \tbltu\ta2, a3, .Lreturn\n-\tsub\ta2, a2, a3\t# subtract once more if udividend >= udivisor\n+\tsub\ta2, a2, a3\t/* subtract again if udividend >= udivisor */\n .Lreturn:\n \tbgez\ta7, .Lpositive\n-\tneg\ta2, a2\t\t# if (dividend < 0), return -udividend\n+\tneg\ta2, a2\t\t/* if (dividend < 0), return -udividend */\n .Lpositive:\t\n \tleaf_return\n \n .Lle_one:\n-\t# udivisor is either 0 or 1, so just return 0.\n-\t# someday we may want to throw an exception if udivisor is 0.\n+\t/* udivisor is either 0 or 1, so just return 0.\n+\t   Someday we may want to throw an exception if udivisor is 0.  */\n \tmovi\ta2, 0\n \tleaf_return\n \t.size\t__modsi3,.-__modsi3"}]}