{"sha": "9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI4NWUwZjY5NDk2OWRjMmQxZDkyNTczNzhkZGY2YzhlZjQyZGUzYw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-11-26T09:46:36Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-11-27T20:27:13Z"}, "message": "d: Add float and double overloads for all core.math intrinsics\n\nFor the math intrinsics: cos, fabs, ldexp, rint, rndtol, and sin, new\noverloads have been added to the core.math module for matching float and\ndouble types.  These have been implemented in the compiler.\n\nA recent change to dump_function_to_file started triggering some\nscan-tree-dump tests to FAIL, these have been adjusted as well when\nupdating the test.\n\ngcc/d/ChangeLog:\n\n\t* intrinsics.cc (maybe_expand_intrinsic): Handle new intrinsics.\n\t* intrinsics.def (INTRINSIC_COS): Add float and double overloads.\n\t(INTRINSIC_FABS): Likewise.\n\t(INTRINSIC_LDEXP): Likewise.\n\t(INTRINSIC_RINT): Likewise.\n\t(INTRINSIC_RNDTOL): Likewise.\n\t(INTRINSIC_SIN): Likewise.\n\t(INTRINSIC_TOPREC): Adjust signature.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 5e4492c4.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/intrinsics.d: Adjust patterns in scan-tree-dump.", "tree": {"sha": "438e40733f271a6c62e4df462073b45e16cd249d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438e40733f271a6c62e4df462073b45e16cd249d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67138ea1b041fe1637da6b3568f064f172d9358c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67138ea1b041fe1637da6b3568f064f172d9358c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67138ea1b041fe1637da6b3568f064f172d9358c"}], "stats": {"total": 239, "additions": 151, "deletions": 88}, "files": [{"sha": "4196ed3c552e7a5ccaaaaaf86cfcc4dc23125136", "filename": "gcc/d/intrinsics.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/gcc%2Fd%2Fintrinsics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/gcc%2Fd%2Fintrinsics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.cc?ref=9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "patch": "@@ -814,10 +814,14 @@ maybe_expand_intrinsic (tree callexp)\n     case INTRINSIC_CEIL:\n     case INTRINSIC_CEILF:\n     case INTRINSIC_CEILL:\n+    case INTRINSIC_COS:\n+    case INTRINSIC_COSF:\n     case INTRINSIC_COSL:\n     case INTRINSIC_EXP:\n     case INTRINSIC_EXP2:\n     case INTRINSIC_EXPM1:\n+    case INTRINSIC_FABS:\n+    case INTRINSIC_FABSF:\n     case INTRINSIC_FABSL:\n     case INTRINSIC_FLOOR:\n     case INTRINSIC_FLOORF:\n@@ -828,9 +832,15 @@ maybe_expand_intrinsic (tree callexp)\n     case INTRINSIC_LOG:\n     case INTRINSIC_LOG10:\n     case INTRINSIC_LOG2:\n+    case INTRINSIC_RINT:\n+    case INTRINSIC_RINTF:\n     case INTRINSIC_RINTL:\n+    case INTRINSIC_RNDTOL:\n+    case INTRINSIC_RNDTOLF:\n     case INTRINSIC_RNDTOLL:\n     case INTRINSIC_ROUND:\n+    case INTRINSIC_SIN:\n+    case INTRINSIC_SINF:\n     case INTRINSIC_SINL:\n     case INTRINSIC_SQRT:\n     case INTRINSIC_SQRTF:\n@@ -844,6 +854,8 @@ maybe_expand_intrinsic (tree callexp)\n \n     case INTRINSIC_FMAX:\n     case INTRINSIC_FMIN:\n+    case INTRINSIC_LDEXP:\n+    case INTRINSIC_LDEXPF:\n     case INTRINSIC_LDEXPL:\n       code = intrinsic_decls[intrinsic].built_in;\n       gcc_assert (code != BUILT_IN_NONE);"}, {"sha": "c05a66628657cf96b6165f2f1591f23a4bd0de4d", "filename": "gcc/d/intrinsics.def", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/gcc%2Fd%2Fintrinsics.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/gcc%2Fd%2Fintrinsics.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.def?ref=9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "patch": "@@ -93,22 +93,34 @@ DEF_D_BUILTIN (NEGSL, NONE, \"negs\", \"core.checkedint\", \"FNaNbNiNflKbZl\")\n \n /* core.math intrinsics.  */\n \n+DEF_D_BUILTIN (COSF, COSF, \"cos\", \"core.math\", \"FNaNbNiNffZf\")\n+DEF_D_BUILTIN (COS, COS, \"cos\", \"core.math\", \"FNaNbNiNfdZd\")\n DEF_D_BUILTIN (COSL, COSL, \"cos\", \"core.math\", \"FNaNbNiNfeZe\")\n+DEF_D_BUILTIN (FABSF, FABSL, \"fabs\", \"core.math\", \"FNaNbNiNffZf\")\n+DEF_D_BUILTIN (FABS, FABS, \"fabs\", \"core.math\", \"FNaNbNiNfdZd\")\n DEF_D_BUILTIN (FABSL, FABSL, \"fabs\", \"core.math\", \"FNaNbNiNfeZe\")\n+DEF_D_BUILTIN (LDEXPF, LDEXPF, \"ldexp\", \"core.math\", \"FNaNbNiNffiZf\")\n+DEF_D_BUILTIN (LDEXP, LDEXP, \"ldexp\", \"core.math\", \"FNaNbNiNfdiZd\")\n DEF_D_BUILTIN (LDEXPL, LDEXPL, \"ldexp\", \"core.math\", \"FNaNbNiNfeiZe\")\n+DEF_D_BUILTIN (RINTF, RINTF, \"rint\", \"core.math\", \"FNaNbNiNffZf\")\n+DEF_D_BUILTIN (RINT, RINT, \"rint\", \"core.math\", \"FNaNbNiNfdZd\")\n DEF_D_BUILTIN (RINTL, RINTL, \"rint\", \"core.math\", \"FNaNbNiNfeZe\")\n \n-/* Not sure if `llroundl' stands as a good replacement for the expected\n+/* Not sure if `llround{f,l}' stands as a good replacement for the expected\n    behavior of `rndtol()'.  */\n+DEF_D_BUILTIN (RNDTOLF, LLROUNDF, \"rndtol\", \"core.math\", \"FNaNbNiNffZl\")\n+DEF_D_BUILTIN (RNDTOL, LLROUND, \"rndtol\", \"core.math\", \"FNaNbNiNfdZl\")\n DEF_D_BUILTIN (RNDTOLL, LLROUNDL, \"rndtol\", \"core.math\", \"FNaNbNiNfeZl\")\n \n+DEF_D_BUILTIN (SINF, SINF, \"sin\", \"core.math\", \"FNaNbNiNffZf\")\n+DEF_D_BUILTIN (SIN, SIN, \"sin\", \"core.math\", \"FNaNbNiNfdZd\")\n DEF_D_BUILTIN (SINL, SINL, \"sin\", \"core.math\", \"FNaNbNiNfeZe\")\n DEF_D_BUILTIN (SQRTF, SQRTF, \"sqrt\", \"core.math\", \"FNaNbNiNffZf\")\n DEF_D_BUILTIN (SQRT, SQRT, \"sqrt\", \"core.math\", \"FNaNbNiNfdZd\")\n DEF_D_BUILTIN (SQRTL, SQRTL, \"sqrt\", \"core.math\", \"FNaNbNiNfeZe\")\n-DEF_D_BUILTIN (TOPRECF, NONE, \"toPrec\", \"core.math\", \"FNaNbNffZI1T\")\n-DEF_D_BUILTIN (TOPREC, NONE, \"toPrec\", \"core.math\", \"FNaNbNfdZI1T\")\n-DEF_D_BUILTIN (TOPRECL, NONE, \"toPrec\", \"core.math\", \"FNaNbNfeZI1T\")\n+DEF_D_BUILTIN (TOPRECF, NONE, \"toPrec\", \"core.math\", \"FfZI1T\")\n+DEF_D_BUILTIN (TOPREC, NONE, \"toPrec\", \"core.math\", \"FdZI1T\")\n+DEF_D_BUILTIN (TOPRECL, NONE, \"toPrec\", \"core.math\", \"FeZI1T\")\n \n /* std.math intrinsics.  */\n "}, {"sha": "a7752370582c4e8f8fd4453ff0c7e8e735535fcb", "filename": "gcc/testsuite/gdc.dg/intrinsics.d", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d?ref=9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "patch": "@@ -8,116 +8,140 @@ import core.stdc.stdarg;\n //////////////////////////////////////////////////////\n // core.bitop\n \n-// { dg-final { scan-tree-dump-not \" bsf \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_ctz \" \"original\" } }\n int test_bsf(uint a) { return bsf(a); }\n+// { dg-final { scan-tree-dump \" __builtin_ctz(l|ll) \" \"original\" } }\n int test_bsf(ulong a) { return bsf(a); }\n-// { dg-final { scan-tree-dump-not \" bsr \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_clz \" \"original\" } }\n int test_bsr(uint a) { return bsr(a); }\n+// { dg-final { scan-tree-dump \" __builtin_clz(l|ll) \" \"original\" } }\n int test_bsr(ulong a) { return bsr(a); }\n-// { dg-final { scan-tree-dump-not \" bt \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = bt \" \"original\" } }\n int test_bt(size_t *a, size_t b) { return bt(a, b); }\n-// { dg-final { scan-tree-dump-not \" btc \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = btc \" \"original\" } }\n int test_btc(size_t *a, size_t b) { return btc(a, b); }\n-// { dg-final { scan-tree-dump-not \" btr \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = btr \" \"original\" } }\n int test_btr(size_t *a, size_t b) { return btr(a, b); }\n-// { dg-final { scan-tree-dump-not \" bts \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = bts \" \"original\" } }\n int test_bts(size_t *a, size_t b) { return bts(a, b); }\n-// { dg-final { scan-tree-dump-not \" bswap \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_bswap32 \" \"original\" } }\n uint test_bswap(uint a) { return bswap(a); }\n+// { dg-final { scan-tree-dump \" __builtin_bswap64 \" \"original\" } }\n ulong test_bswap(ulong a) { return bswap(a); }\n-// { dg-final { scan-tree-dump-not \" popcnt \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_popcount \" \"original\" } }\n int test_popcnt(uint a) { return popcnt(a); }\n+// { dg-final { scan-tree-dump \" __builtin_popcount(l|ll) \" \"original\" } }\n int test_popcnt(ulong a) { return popcnt(a); }\n-// { dg-final { scan-tree-dump-not \" volatileLoad \" \"original\" } }\n+// { dg-final { scan-tree-dump \"\\\\(volatile ubyte \\\\*\\\\) a;\" \"original\" } }\n ubyte test_volatileLoad(ubyte *a) { return volatileLoad(a); }\n+// { dg-final { scan-tree-dump \"\\\\(volatile ushort \\\\*\\\\) a;\" \"original\" } }\n ushort test_volatileLoad(ushort *a) { return volatileLoad(a); }\n+// { dg-final { scan-tree-dump \"\\\\(volatile uint \\\\*\\\\) a;\" \"original\" } }\n uint test_volatileLoad(uint *a) { return volatileLoad(a); }\n+// { dg-final { scan-tree-dump \"\\\\(volatile ulong \\\\*\\\\) a;\" \"original\" } }\n ulong test_volatileLoad(ulong *a) { return volatileLoad(a); }\n-// { dg-final { scan-tree-dump-not \" volatileStore \" \"original\" } }\n+// { dg-final { scan-tree-dump \"\\\\(volatile ubyte \\\\*\\\\) a = b\" \"original\" } }\n void test_volatileStore(ubyte *a, ubyte b) { return volatileStore(a, b); }\n+// { dg-final { scan-tree-dump \"\\\\(volatile ushort \\\\*\\\\) a = b\" \"original\" } }\n void test_volatileStore(ushort *a, ushort b) { return volatileStore(a, b); }\n+// { dg-final { scan-tree-dump \"\\\\(volatile uint \\\\*\\\\) a = b\" \"original\" } }\n void test_volatileStore(uint *a, uint b) { return volatileStore(a, b); }\n+// { dg-final { scan-tree-dump \"\\\\(volatile ulong \\\\*\\\\) a = b\" \"original\" } }\n void test_volatileStore(ulong *a, ulong b) { return volatileStore(a, b); }\n-// { dg-final { scan-tree-dump-not \" rol \" \"original\" } }\n+// { dg-final { scan-tree-dump \" a r<< b;\" \"original\" } }\n ubyte test_rol(ubyte a, uint b) { return rol!ubyte(a, b); }\n+// { dg-final { scan-tree-dump \" a r>> 31;\" \"original\" } }\n uint test_rol(uint a) { return rol!(1, uint)(a); }\n-// { dg-final { scan-tree-dump-not \" ror \" \"original\" } }\n+// { dg-final { scan-tree-dump \" a r>> b;\" \"original\" } }\n ushort test_ror(ushort a, uint b) { return ror!ushort(a, b); }\n+// { dg-final { scan-tree-dump \" a r>> 1;\" \"original\" } }\n ulong test_ror(ulong a) { return ror!(1, ulong)(a); }\n \n //////////////////////////////////////////////////////\n // core.checkedint\n \n-// { dg-final { scan-tree-dump-not \" adds \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = adds \" \"original\" } }\n int test_adds(int a, int b, ref bool c) { return adds(a, b, c); }\n long test_adds(long a, long b, ref bool c) { return adds(a, b, c); }\n-// { dg-final { scan-tree-dump-not \" addu \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = addu \" \"original\" } }\n uint test_addu(uint a, uint b, ref bool c) { return addu(a, b, c); }\n ulong test_addu(ulong a, ulong b, ref bool c) { return addu(a, b, c); }\n-// { dg-final { scan-tree-dump-not \" subs \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = subs \" \"original\" } }\n int test_subs(int a, int b, ref bool c) { return subs(a, b, c); }\n long test_subs(long a, long b, ref bool c) { return subs(a, b, c); }\n-// { dg-final { scan-tree-dump-not \" subu \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = subu \" \"original\" } }\n uint test_subu(uint a, uint b, ref bool c) { return subu(a, b, c); }\n ulong test_subu(ulong a, ulong b, ref bool c) { return subu(a, b, c); }\n-// { dg-final { scan-tree-dump-not \" negs \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = negs \" \"original\" } }\n int test_negs(int a, ref bool b) { return negs(a, b); }\n long test_negs(long a, ref bool b) { return negs(a, b); }\n-// { dg-final { scan-tree-dump-not \" muls \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = muls \" \"original\" } }\n int test_muls(int a, int b, ref bool c) { return muls(a, b, c); }\n long test_muls(long a, long b, ref bool c) { return muls(a, b, c); }\n-// { dg-final { scan-tree-dump-not \" mulu \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = mulu \" \"original\" } }\n uint test_mulu(uint a, uint b, ref bool c) { return mulu(a, b, c); }\n ulong test_mulu(ulong a, uint b, ref bool c) { return mulu(a, b, c); }\n ulong test_mulu(ulong a, ulong b, ref bool c) { return mulu(a, b, c); }\n \n //////////////////////////////////////////////////////\n // core.math\n \n-// { dg-final { scan-tree-dump-not \" cos \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_cosf \" \"original\" } }\n float test_cos(float a) { return cos(a); }\n+// { dg-final { scan-tree-dump \" __builtin_cos \" \"original\" } }\n double test_cos(double a) { return cos(a); }\n+// { dg-final { scan-tree-dump \" __builtin_cosl \" \"original\" } }\n real test_cos(real a) { return cos(a); }\n-// { dg-final { scan-tree-dump-not \" sin \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_sinf \" \"original\" } }\n float test_sin(float a) { return sin(a); }\n+// { dg-final { scan-tree-dump \" __builtin_sin \" \"original\" } }\n double test_sin(double a) { return sin(a); }\n+// { dg-final { scan-tree-dump \" __builtin_sinl \" \"original\" } }\n real test_sin(real a) { return sin(a); }\n-// { dg-final { scan-tree-dump-not \" rndtol \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_llroundf \" \"original\" } }\n long test_rndtol(float a) { return rndtol(a); }\n+// { dg-final { scan-tree-dump \" __builtin_llround \" \"original\" } }\n long test_rndtol(double a) { return rndtol(a); }\n+// { dg-final { scan-tree-dump \" __builtin_llroundl \" \"original\" } }\n long test_rndtol(real a) { return rndtol(a); }\n-// { dg-final { scan-tree-dump-not \" sqrt \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_sqrtf \" \"original\" } }\n float test_sqrt(float a) { return sqrt(a); }\n+// { dg-final { scan-tree-dump \" __builtin_sqrt \" \"original\" } }\n double test_sqrt(double a) { return sqrt(a); }\n+// { dg-final { scan-tree-dump \" __builtin_sqrtl \" \"original\" } }\n real test_sqrt(real a) { return sqrt(a); }\n-// { dg-final { scan-tree-dump-not \" ldexp \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_ldexpf \" \"original\" } }\n float test_ldexp(float a, int b) { return ldexp(a, b); }\n+// { dg-final { scan-tree-dump \" __builtin_ldexp \" \"original\" } }\n double test_ldexp(double a, int b) { return ldexp(a, b); }\n+// { dg-final { scan-tree-dump \" __builtin_ldexpl \" \"original\" } }\n real test_ldexp(real a, int b) { return ldexp(a, b); }\n-// { dg-final { scan-tree-dump-not \" fabs \" \"original\" } }\n+// { dg-final { scan-tree-dump-not \" <retval> = fabs \" \"original\" } }\n float test_fabs(float a) { return fabs(a); }\n double test_fabs(double a) { return fabs(a); }\n real test_fabs(real a) { return fabs(a); }\n-// { dg-final { scan-tree-dump-not \" rint \" \"original\" } }\n+// { dg-final { scan-tree-dump \" __builtin_rintf \" \"original\" } }\n float test_rint(float a) { return rint(a); }\n+// { dg-final { scan-tree-dump \" __builtin_rint \" \"original\" } }\n double test_rint(double a) { return rint(a); }\n+// { dg-final { scan-tree-dump \" __builtin_rintl \" \"original\" } }\n real test_rint(real a) { return rint(a); }\n-// { dg-final { scan-tree-dump-not \" toPrec \" \"original\" } }\n-float test_toPrec(float a) { return toPrec!float(a); }\n-float test_toPrec(double a) { return toPrec!float(a); }\n-float test_toPrec(real a) { return toPrec!float(a); }\n+// { dg-final { scan-tree-dump-not \" <retval> = toPrec \" \"original\" } }\n+float test_toPrecf(float a) { return toPrec!float(a); }\n+float test_toPrecf(double a) { return toPrec!float(a); }\n+float test_toPrecf(real a) { return toPrec!float(a); }\n double test_toPrec(float a) { return toPrec!double(a); }\n double test_toPrec(double a) { return toPrec!double(a); }\n double test_toPrec(real a) { return toPrec!double(a); }\n-real test_toPrec(float a) { return toPrec!real(a); }\n-real test_toPrec(double a) { return toPrec!real(a); }\n-real test_toPrec(real a) { return toPrec!real(a); }\n+real test_toPrecl(float a) { return toPrec!real(a); }\n+real test_toPrecl(double a) { return toPrec!real(a); }\n+real test_toPrecl(real a) { return toPrec!real(a); }\n \n //////////////////////////////////////////////////////\n // core.stdc.stdarg\n \n // { dg-final { scan-tree-dump-not \" va_arg \" \"original\" } }\n-void test_va_arg(...) { int a; return va_arg!int(_argptr, a); }\n+void test_va_argc(...) { int a; return va_arg!int(_argptr, a); }\n int test_va_arg(...) { return va_arg!int(_argptr); }\n // { dg-final { scan-tree-dump-not \" va_start \" \"original\" } }\n void test_va_start(int a, ...) { return va_start(_argptr, a); }"}, {"sha": "91154eebdc9680a5428998534002beff1ba410a7", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "patch": "@@ -1,4 +1,4 @@\n-58560d5163381b0f1c893bd0d035b7a0a1631f92\n+5e4492c45172110b035591f5961b9f9f5adf6f13\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "4d46b67d2a313029701d122d5d9ccd35186afeb0", "filename": "libphobos/libdruntime/core/math.d", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/libphobos%2Flibdruntime%2Fcore%2Fmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9285e0f694969dc2d1d9257378ddf6c8ef42de3c/libphobos%2Flibdruntime%2Fcore%2Fmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fmath.d?ref=9285e0f694969dc2d1d9257378ddf6c8ef42de3c", "patch": "@@ -1,4 +1,4 @@\n-\ufeff// Written in the D programming language.\n+// Written in the D programming language.\n \n /**\n  * Builtin mathematical intrinsics\n@@ -19,15 +19,26 @@\n  *      GT = &gt;\n  *\n  * Copyright: Copyright Digital Mars 2000 - 2011.\n- * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n- * Authors:   $(WEB digitalmars.com, Walter Bright),\n+ * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n+ * Authors:   $(HTTP digitalmars.com, Walter Bright),\n  *                        Don Clugston\n  */\n module core.math;\n \n public:\n @nogc:\n+nothrow:\n+@safe:\n \n+/*****************************************\n+ * Returns x rounded to a long value using the FE_TONEAREST rounding mode.\n+ * If the integer value of x is\n+ * greater than long.max, the result is\n+ * indeterminate.\n+ */\n+extern (C) real rndtonl(real x);\n+\n+pure:\n /***********************************\n  * Returns cosine of x. x is in radians.\n  *\n@@ -40,7 +51,9 @@ public:\n  *      Results are undefined if |x| >= $(POWER 2,64).\n  */\n \n-real cos(real x) @safe pure nothrow;       /* intrinsic */\n+float cos(float x);     /* intrinsic */\n+double cos(double x);   /* intrinsic */ /// ditto\n+real cos(real x);       /* intrinsic */ /// ditto\n \n /***********************************\n  * Returns sine of x. x is in radians.\n@@ -55,24 +68,20 @@ real cos(real x) @safe pure nothrow;       /* intrinsic */\n  *      Results are undefined if |x| >= $(POWER 2,64).\n  */\n \n-real sin(real x) @safe pure nothrow;       /* intrinsic */\n+float sin(float x);     /* intrinsic */\n+double sin(double x);   /* intrinsic */ /// ditto\n+real sin(real x);       /* intrinsic */ /// ditto\n \n /*****************************************\n  * Returns x rounded to a long value using the current rounding mode.\n  * If the integer value of x is\n  * greater than long.max, the result is\n  * indeterminate.\n  */\n-long rndtol(real x) @safe pure nothrow;    /* intrinsic */\n \n-\n-/*****************************************\n- * Returns x rounded to a long value using the FE_TONEAREST rounding mode.\n- * If the integer value of x is\n- * greater than long.max, the result is\n- * indeterminate.\n- */\n-extern (C) real rndtonl(real x);\n+long rndtol(float x);   /* intrinsic */\n+long rndtol(double x);  /* intrinsic */ /// ditto\n+long rndtol(real x);    /* intrinsic */ /// ditto\n \n /***************************************\n  * Compute square root of x.\n@@ -85,57 +94,65 @@ extern (C) real rndtonl(real x);\n  *      )\n  */\n \n-@safe pure nothrow\n-{\n-    float sqrt(float x);    /* intrinsic */\n-    double sqrt(double x);  /* intrinsic */ /// ditto\n-    real sqrt(real x);      /* intrinsic */ /// ditto\n-}\n+float sqrt(float x);    /* intrinsic */\n+double sqrt(double x);  /* intrinsic */ /// ditto\n+real sqrt(real x);      /* intrinsic */ /// ditto\n \n /*******************************************\n  * Compute n * 2$(SUPERSCRIPT exp)\n  * References: frexp\n  */\n \n-real ldexp(real n, int exp) @safe pure nothrow;    /* intrinsic */\n+float ldexp(float n, int exp);   /* intrinsic */\n+double ldexp(double n, int exp); /* intrinsic */ /// ditto\n+real ldexp(real n, int exp);     /* intrinsic */ /// ditto\n \n unittest {\n     static if (real.mant_dig == 113)\n     {\n-        assert(ldexp(1, -16384) == 0x1p-16384L);\n-        assert(ldexp(1, -16382) == 0x1p-16382L);\n+        assert(ldexp(1.0L, -16384) == 0x1p-16384L);\n+        assert(ldexp(1.0L, -16382) == 0x1p-16382L);\n     }\n     else static if (real.mant_dig == 106)\n     {\n-        assert(ldexp(1,  1023) == 0x1p1023L);\n-        assert(ldexp(1, -1022) == 0x1p-1022L);\n-        assert(ldexp(1, -1021) == 0x1p-1021L);\n+        assert(ldexp(1.0L,  1023) == 0x1p1023L);\n+        assert(ldexp(1.0L, -1022) == 0x1p-1022L);\n+        assert(ldexp(1.0L, -1021) == 0x1p-1021L);\n     }\n     else static if (real.mant_dig == 64)\n     {\n-        assert(ldexp(1, -16384) == 0x1p-16384L);\n-        assert(ldexp(1, -16382) == 0x1p-16382L);\n+        assert(ldexp(1.0L, -16384) == 0x1p-16384L);\n+        assert(ldexp(1.0L, -16382) == 0x1p-16382L);\n     }\n     else static if (real.mant_dig == 53)\n     {\n-        assert(ldexp(1,  1023) == 0x1p1023L);\n-        assert(ldexp(1, -1022) == 0x1p-1022L);\n-        assert(ldexp(1, -1021) == 0x1p-1021L);\n+        assert(ldexp(1.0L,  1023) == 0x1p1023L);\n+        assert(ldexp(1.0L, -1022) == 0x1p-1022L);\n+        assert(ldexp(1.0L, -1021) == 0x1p-1021L);\n     }\n     else\n         assert(false, \"Only 128bit, 80bit and 64bit reals expected here\");\n }\n \n /*******************************\n- * Returns |x|\n- *\n+ * Compute the absolute value.\n  *      $(TABLE_SV\n  *      $(TR $(TH x)                 $(TH fabs(x)))\n  *      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0) )\n  *      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )\n  *      )\n+ * It is implemented as a compiler intrinsic.\n+ * Params:\n+ *      x = floating point value\n+ * Returns: |x|\n+ * References: equivalent to `std.math.fabs`\n  */\n-real fabs(real x) @safe pure nothrow;      /* intrinsic */\n+@safe pure nothrow @nogc\n+{\n+    float  fabs(float  x);\n+    double fabs(double x); /// ditto\n+    real   fabs(real   x); /// ditto\n+}\n \n /**********************************\n  * Rounds x to the nearest integer value, using the current rounding\n@@ -145,22 +162,29 @@ real fabs(real x) @safe pure nothrow;      /* intrinsic */\n  * $(B nearbyint) performs\n  * the same operation, but does not set the FE_INEXACT exception.\n  */\n-real rint(real x) @safe pure nothrow;      /* intrinsic */\n+float rint(float x);    /* intrinsic */\n+double rint(double x);  /* intrinsic */ /// ditto\n+real rint(real x);      /* intrinsic */ /// ditto\n \n /***********************************\n  * Building block functions, they\n  * translate to a single x87 instruction.\n  */\n-\n-real yl2x(real x, real y)   @safe pure nothrow;       // y * log2(x)\n-real yl2xp1(real x, real y) @safe pure nothrow;       // y * log2(x + 1)\n+// y * log2(x)\n+float yl2x(float x, float y);    /* intrinsic */\n+double yl2x(double x, double y);  /* intrinsic */ /// ditto\n+real yl2x(real x, real y);      /* intrinsic */ /// ditto\n+// y * log2(x +1)\n+float yl2xp1(float x, float y);    /* intrinsic */\n+double yl2xp1(double x, double y);  /* intrinsic */ /// ditto\n+real yl2xp1(real x, real y);      /* intrinsic */ /// ditto\n \n unittest\n {\n     version (INLINE_YL2X)\n     {\n-        assert(yl2x(1024, 1) == 10);\n-        assert(yl2xp1(1023, 1) == 10);\n+        assert(yl2x(1024.0L, 1) == 10);\n+        assert(yl2xp1(1023.0L, 1) == 10);\n     }\n }\n \n@@ -179,31 +203,22 @@ unittest\n  * Returns:\n  *      f in precision of type `T`\n  */\n-@safe pure nothrow\n T toPrec(T:float)(float f) { pragma(inline, false); return f; }\n /// ditto\n-@safe pure nothrow\n T toPrec(T:float)(double f) { pragma(inline, false); return cast(T) f; }\n /// ditto\n-@safe pure nothrow\n T toPrec(T:float)(real f)  { pragma(inline, false); return cast(T) f; }\n /// ditto\n-@safe pure nothrow\n T toPrec(T:double)(float f) { pragma(inline, false); return f; }\n /// ditto\n-@safe pure nothrow\n T toPrec(T:double)(double f) { pragma(inline, false); return f; }\n /// ditto\n-@safe pure nothrow\n T toPrec(T:double)(real f)  { pragma(inline, false); return cast(T) f; }\n /// ditto\n-@safe pure nothrow\n T toPrec(T:real)(float f) { pragma(inline, false); return f; }\n /// ditto\n-@safe pure nothrow\n T toPrec(T:real)(double f) { pragma(inline, false); return f; }\n /// ditto\n-@safe pure nothrow\n T toPrec(T:real)(real f)  { pragma(inline, false); return f; }\n \n @safe unittest"}]}