{"sha": "ce152ef8360320d27e1aacba9af8fdc4e1649941", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxNTJlZjgzNjAzMjBkMjdlMWFhY2JhOWFmOGZkYzRlMTY0OTk0MQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "2000-05-25T15:21:51Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2000-05-25T15:21:51Z"}, "message": "except.c (func_eh_entry): Add emitted field.\n\n2000-05-25  Andrew MacLeod  <amacleod@cygnus.com>\n            Andrew Haley  <aph@cygnus.com>\n\n\t* except.c  (func_eh_entry): Add emitted field.\n\t(new_eh_region_entry): Set emitted field to 0;\n\t(output_exception_table_entry): Only emit previously un-emitted data,\n\tand send it to the eh_data section.\n\t(output_exception_table): Break out common parts. Output\n\texception table for entire compilation unit to eh_data section.\n\t(output_exception_table_data): Common parts of output_exception_table.\n\tSend output to eh_data section.\n\t(output_function_exception_table): Output exception table data for\n\ta single function to eh_data section.\n\t(free_exception_table): New external to free the table.\n\t* except.h (free_exception_table): Add prototype.\n\t(output_function_exception_table): Add prototype.\n\t* final.c (final_end_function): Output function exception table\n\tfor IA64_UNWIND_INFO.\n\t(final_scan_insn): Emit any unwind directives for an insn.\n\n\t* frame-dwarf2.c: New file containing all DWARF 2 specific code\n\tfrom frame.c.\n\t* frame.c: Remove all DWARF 2 specific code.\n\t* config/ia64/frame-ia64.c: New file.\n\t(gthread_stuff): Make all gthread available with\n\tIA64_UNWIND_INFO.\n\t(dwarf_fde): Define an IA64 struct for dwarf_fde.\n\t(__register_frame_info, __register_frame): Move to common area of file.\n\t(__register_frame_info_table, __register_frame_table): Move to common i\n\tarea.\n\t(__deregister_frame_info, __deregister_frame): Move to common area.\n\t(__frame_init, find_fde): New versions for IA64_UNWIND_INFO.\n\t(read_uleb128): New version for ia64.\n\t(get_unwind_record): Read the next IA-64 unwind record.\n\t(read_R_record): Read a region header record.\n\t(process_a_b_reg_code): X record helper.\n\t(read_X_record): Read an X format record.\n\t(read_B_record): Read a B format record.\n\t(P3_record_types): List of record types matching the P3 format.\n\t(P7_record_types): List of record types matching the P7 format.\n\t(P8_record_types): List of record types matching the P8 format.\n\t(read_P_record): Read a P format record.\n\t(init_ia64_reg_loc): Set default fields for a register.\n\t(init_ia64_unwind_frame): Set defaults for all register records.\n\t(execute_one_ia64_descriptor): Execute one descriptor record.\n\t(rse_address_add): Calculate the position of a local reg in memory.\n\t(normalize_reg_loc): Turn a location descriptor into a memory address.\n\t(maybe_normalize_reg_loc): Only normalize a descriptor if it falls\n\twithin a specified PC offset range.\n\t(get_real_reg_value): Given a register location, retrieve its value.\n\t(set_real_reg_value): Change the value of a register location.\n\t(copy_reg_value): Copy reg values, if needed.\n\t(copy_saved_reg_state): Copy all registers that need to be copied.\n\t(process_state_between): Normalize all frame register records that\n\tfall within the specified PC range.\n\t(frame_translate): Take a processed frame description, and turn\n\teverything into addresses.\n\t(build_ia64_frame_state ): Find and create frame state record for a PC.\n\t(get_personality): Get the personality routine for a given frame.\n\t(get_except_table): Get the exception table for a given frame.\n\t(record_name): Unwind record names for debugging.\n\t(print_record): Print and unwind record.\n\t(print_all_records): Print an entire unwind image.\n\t(__ia64_backtrace): Print a backtrace.\n\t(ia64_backtrace_helper): New function.\n\t(__register_frame_info_aux): New function.\n\t* config/ia64/crtend.asm (__do_frame_setup_aux): New function.\n\n\t* frame.h (enum unw_record_type): New unwind record types.\n\t(struct unw_p_record, unw_b_record, unw_x_record) : New unwind records.\n\t(struct unw_r_record, unwind_record): New unwind record structs.\n\t(struct unwind_info_ptr): Unwind information layout.\n\t(IA64_UNW_LOC_TYPE_*): Macros for different types for location\n\tdescriptors.\n\t(struct ia64_reg_loc): Register location description.\n\t(struct ia64_frame_state): Location of all registers in a frame.\n\t(struct object): Add pc_base and fde_end for IA64_UNWIND_INFO.\n\t* libgcc2.c (__ia64_personality_v1): Personality routine.\n\t(__calc_caller_bsp): Calculate the bsp register for the caller's\n\tframe.\n\t(ia64_throw_helper): Figure out who to return to and set up the\n\tregisters.\n\t(__throw): Throw routine.\n\n\t* output.h (assemble_eh_align, assemble_eh_label): New functions\n\tto generate EH info where we want it.\n\t(assemble_eh_integer): New function.\n\t* toplev.c (compile_file): Output module level exception table for\n\tnon-ia64 targets.\n\t(main): Set exceptions_via_longjump and flag_new_exceptions based\n\ton IA64_UNWIND_INFO too.\n\n\t* varasm.c (assemble_eh_label): Generate a label via\n\tASM_OUTPUT_EH_LABEL if it has been specified.\n\t(assemble_eh_align): Generate an alignment directive via\n\tASM_OUTPUT_EH_ALIGN if it has been specified.\n\t(assemble_eh_label): Generate an integer value via\n\tASM_OUTPUT_EH_type if they have been specified.\n\t* config/ia64/ia64.c (rtx_needs_barrier): Add flushrs.\n\t(ia64_init_builtins): Add __builtin_ia64_bsp\n\tand __builtin_ia64_flushrs.\n\t(ia64_expand_builtin): Add IA64_BUILTIN_BSP and\n\tIA64_BUILTIN_FLUSHRS.\n\t* config/ia64/ia64.h (ia64_builtins): Add IA64_BUILTIN_BSP and\n\tIA64_BUILTIN_FLUSHRS.\n\n\t* config/ia64/ia64.md (flushrs): New insn to flush the register\n\tstack.  Add to unspec list.\n\n\t* config/ia64/crtbegin.asm (frame_object): Change size.\n\t(__do_frame_setup_aux): New function.\n\t* config/ia64/crtend.asm: call __do_frame_setup_aux.\n\t* config/ia64/t-ia64 (LIB2ADDEH): Add.\n\t* Makefile.in (LIB2ADDEH): Add.\n\t(LIB2ADD): Use LIB2ADDEH.\n\nCo-Authored-By: Andrew Haley <aph@cygnus.com>\n\nFrom-SVN: r34169", "tree": {"sha": "feadfb24e9829d3678b304cad386af16dda71a31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feadfb24e9829d3678b304cad386af16dda71a31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce152ef8360320d27e1aacba9af8fdc4e1649941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce152ef8360320d27e1aacba9af8fdc4e1649941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce152ef8360320d27e1aacba9af8fdc4e1649941", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce152ef8360320d27e1aacba9af8fdc4e1649941/comments", "author": null, "committer": null, "parents": [{"sha": "c66265e4833fb9553699839453725586cc248fc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c66265e4833fb9553699839453725586cc248fc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c66265e4833fb9553699839453725586cc248fc3"}], "stats": {"total": 3685, "additions": 3022, "deletions": 663}, "files": [{"sha": "43a8e4f93a08e413547eddf94718bf14337f33b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -1,3 +1,119 @@\n+2000-05-25  Andrew MacLeod  <amacleod@cygnus.com>\n+            Andrew Haley  <aph@cygnus.com>\n+\n+\t* except.c  (func_eh_entry): Add emitted field.\n+\t(new_eh_region_entry): Set emitted field to 0;\n+\t(output_exception_table_entry): Only emit previously un-emitted data,\n+\tand send it to the eh_data section.\n+\t(output_exception_table): Break out common parts. Output\n+\texception table for entire compilation unit to eh_data section.\n+\t(output_exception_table_data): Common parts of output_exception_table.\n+\tSend output to eh_data section.\n+\t(output_function_exception_table): Output exception table data for\n+\ta single function to eh_data section.\n+\t(free_exception_table): New external to free the table.\n+\t* except.h (free_exception_table): Add prototype.\n+\t(output_function_exception_table): Add prototype.\n+\t* final.c (final_end_function): Output function exception table\n+\tfor IA64_UNWIND_INFO.\n+\t(final_scan_insn): Emit any unwind directives for an insn.\n+\n+\t* frame-dwarf2.c: New file containing all DWARF 2 specific code\n+\tfrom frame.c.\n+\t* frame.c: Remove all DWARF 2 specific code.\n+\t* config/ia64/frame-ia64.c: New file.\n+\t(gthread_stuff): Make all gthread available with \n+\tIA64_UNWIND_INFO.\n+\t(dwarf_fde): Define an IA64 struct for dwarf_fde.\n+\t(__register_frame_info, __register_frame): Move to common area of file.\n+\t(__register_frame_info_table, __register_frame_table): Move to common i\n+\tarea.\n+\t(__deregister_frame_info, __deregister_frame): Move to common area.\n+\t(__frame_init, find_fde): New versions for IA64_UNWIND_INFO.\n+\t(read_uleb128): New version for ia64.\n+\t(get_unwind_record): Read the next IA-64 unwind record.\n+\t(read_R_record): Read a region header record.\n+\t(process_a_b_reg_code): X record helper.\n+\t(read_X_record): Read an X format record.\n+\t(read_B_record): Read a B format record.\n+\t(P3_record_types): List of record types matching the P3 format.\n+\t(P7_record_types): List of record types matching the P7 format.\n+\t(P8_record_types): List of record types matching the P8 format.\n+\t(read_P_record): Read a P format record.\n+\t(init_ia64_reg_loc): Set default fields for a register.\n+\t(init_ia64_unwind_frame): Set defaults for all register records.\n+\t(execute_one_ia64_descriptor): Execute one descriptor record.\n+\t(rse_address_add): Calculate the position of a local reg in memory.\n+\t(normalize_reg_loc): Turn a location descriptor into a memory address.\n+\t(maybe_normalize_reg_loc): Only normalize a descriptor if it falls \n+\twithin a specified PC offset range.\n+\t(get_real_reg_value): Given a register location, retrieve its value.\n+\t(set_real_reg_value): Change the value of a register location.\n+\t(copy_reg_value): Copy reg values, if needed.\n+\t(copy_saved_reg_state): Copy all registers that need to be copied.\n+\t(process_state_between): Normalize all frame register records that\n+\tfall within the specified PC range.\n+\t(frame_translate): Take a processed frame description, and turn \n+\teverything into addresses.\n+\t(build_ia64_frame_state ): Find and create frame state record for a PC.\n+\t(get_personality): Get the personality routine for a given frame.\n+\t(get_except_table): Get the exception table for a given frame.\n+\t(record_name): Unwind record names for debugging.\n+\t(print_record): Print and unwind record.\n+\t(print_all_records): Print an entire unwind image.\n+\t(__ia64_backtrace): Print a backtrace.\n+\t(ia64_backtrace_helper): New function.\n+\t(__register_frame_info_aux): New function.\n+\t* config/ia64/crtend.asm (__do_frame_setup_aux): New function.\n+\n+\t* frame.h (enum unw_record_type): New unwind record types.\n+\t(struct unw_p_record, unw_b_record, unw_x_record) : New unwind records.\n+\t(struct unw_r_record, unwind_record): New unwind record structs.\n+\t(struct unwind_info_ptr): Unwind information layout.\n+\t(IA64_UNW_LOC_TYPE_*): Macros for different types for location \n+\tdescriptors.\n+\t(struct ia64_reg_loc): Register location description.\n+\t(struct ia64_frame_state): Location of all registers in a frame.\n+\t(struct object): Add pc_base and fde_end for IA64_UNWIND_INFO.\n+\t* libgcc2.c (__ia64_personality_v1): Personality routine.\n+\t(__calc_caller_bsp): Calculate the bsp register for the caller's\n+\tframe.\n+\t(ia64_throw_helper): Figure out who to return to and set up the \n+\tregisters.\n+\t(__throw): Throw routine.\n+\n+\t* output.h (assemble_eh_align, assemble_eh_label): New functions\n+\tto generate EH info where we want it.\t\n+\t(assemble_eh_integer): New function.\n+\t* toplev.c (compile_file): Output module level exception table for\n+\tnon-ia64 targets.\n+\t(main): Set exceptions_via_longjump and flag_new_exceptions based \n+\ton IA64_UNWIND_INFO too.\n+\n+\t* varasm.c (assemble_eh_label): Generate a label via\n+\tASM_OUTPUT_EH_LABEL if it has been specified.\n+\t(assemble_eh_align): Generate an alignment directive via \n+\tASM_OUTPUT_EH_ALIGN if it has been specified.\n+\t(assemble_eh_label): Generate an integer value via\n+\tASM_OUTPUT_EH_type if they have been specified.\n+\t* config/ia64/ia64.c (rtx_needs_barrier): Add flushrs.\n+\t(ia64_init_builtins): Add __builtin_ia64_bsp\n+\tand __builtin_ia64_flushrs.\t\n+\t(ia64_expand_builtin): Add IA64_BUILTIN_BSP and\n+\tIA64_BUILTIN_FLUSHRS.\n+\t* config/ia64/ia64.h (ia64_builtins): Add IA64_BUILTIN_BSP and\n+\tIA64_BUILTIN_FLUSHRS.\n+\n+\t* config/ia64/ia64.md (flushrs): New insn to flush the register\n+\tstack.  Add to unspec list.\n+\n+\t* config/ia64/crtbegin.asm (frame_object): Change size.\n+\t(__do_frame_setup_aux): New function.\n+\t* config/ia64/crtend.asm: call __do_frame_setup_aux.\n+\t* config/ia64/t-ia64 (LIB2ADDEH): Add.\n+\t* Makefile.in (LIB2ADDEH): Add.\n+\t(LIB2ADD): Use LIB2ADDEH.\n+\t\n 2000-05-24  Richard Henderson  <rth@cygnus.com>\n \n \t* recog.c (offsettable_address_p): If mode size is zero, assume"}, {"sha": "c362db2b131050aeadff4278032a94d1471b85c8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -367,6 +367,9 @@ LIBGCC2_INCLUDES =\n # Additional target-dependent options for compiling libgcc2.a.\n TARGET_LIBGCC2_CFLAGS =\n \n+# Addition sources to handle exceptions; overridden by some targets.\n+LIB2ADDEH = $(srcdir)/frame-dwarf2.c\n+\n # libgcc1-test target (must also be overridable for a target)\n LIBGCC1_TEST = libgcc1-test\n \n@@ -951,7 +954,7 @@ libgcc2.ready: $(GCC_PASSES) stmp-int-hdrs $(STMP_FIXPROTO)\n \t\ttouch libgcc2.ready; \\\n \tfi\n \n-LIB2ADD = $(srcdir)/frame.c $(LIB2FUNCS_EXTRA) $(LANG_LIB2FUNCS)\n+LIB2ADD = $(LIB2ADDEH) $(LIB2FUNCS_EXTRA) $(LANG_LIB2FUNCS)\n \n libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) xgcc$(exeext)\n \tobjext='$(objext)' \\"}, {"sha": "0e49e20662d3707a8e694c5d5c0deebf9da2a23c", "filename": "gcc/config/ia64/crtbegin.asm", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -61,10 +61,10 @@ __dso_handle:\n \t/* ??? How can we rationally keep this size correct?  */\n .section .bss\n \t.type frame_object#,@object\n-\t.size frame_object#,56\n+\t.size frame_object#,64\n \t.align 8\n frame_object:\n-\t.zero 56\n+\t.zero 64\n \n /*\n  * Fragment of the ELF _fini routine that invokes our dtor cleanup.\n@@ -296,3 +296,38 @@ __do_frame_setup:\n #endif\n .weak __deregister_frame_info#\n .weak __register_frame_info#\n+\n+\t.text\n+\t.align 16\n+\t.global\t__do_frame_setup_aux#\n+\t.proc\t__do_frame_setup_aux#\n+__do_frame_setup_aux:\n+\t/*\n+\t\tif (__register_frame_info_aux)\n+\t\t  __register_frame_info_aux(__EH_FRAME_END__)\n+\t*/\n+        alloc loc0 = ar.pfs, 0, 3, 1, 0\n+        addl r14 = @ltoff(@fptr(__register_frame_info_aux#)), gp\n+        mov loc1 = b0\n+        ;;\n+\t// r16 contains the address of a pointer to __EH_FRAME_END__.\n+        ld8 out0 = [r16]\n+        ld8 r15 = [r14]\n+\tmov loc2 = gp\n+        ;;\n+        cmp.eq p6, p7 = 0, r15\n+        (p6) br.cond.dptk 1f\n+        ld8 r8 = [r15], 8\n+        ;;\n+        ld8 gp = [r15]\n+        mov b6 = r8\n+        ;;\n+        br.call.sptk.many b0 = b6\n+\t;;\n+1:\n+\tmov gp = loc2\n+        mov ar.pfs = loc0\n+        mov b0 = loc1\n+        br.ret.sptk.many b0\n+\t.endp\t__do_frame_setup#\n+.weak __register_frame_info_aux#"}, {"sha": "9216cfc7fb74be3358a59f83343e82bef64009d9", "filename": "gcc/config/ia64/crtend.asm", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtend.asm?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -110,3 +110,25 @@ __do_global_ctors_aux:\n \t  ;;\n \t}\n \t.endp __do_global_ctors_aux#\n+\n+.section .init,\"ax\",\"progbits\"\n+\t{ .mlx\n+\t  // __do_frame_setup_aux is in crtbegin.asm\n+\t  movl r2 = @gprel(__do_frame_setup_aux#)\n+\t  ;;\n+\t}\n+\t{ .mii\n+\t  nop.m 0\n+\t  add r2 = r2, gp\n+\t  ;;\n+\t  mov b6 = r2\n+\t}\n+\t{ .mib\n+\t  // __do_frame_setup_aux needs the address of __EH_FRAME_END__,\n+\t  // so we pass it in r16.  This is rather evil, but we have no\n+\t  // output registers.\n+          addl r16 = @ltoff(__EH_FRAME_END__#), gp\n+\t  br.call.sptk.many b0 = b6\n+\t  ;;\n+        }\n+"}, {"sha": "763bc49c0bceb676e6be72f814f5dca1316675bc", "filename": "gcc/config/ia64/frame-ia64.c", "status": "added", "additions": 1608, "deletions": 0, "changes": 1608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fframe-ia64.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -0,0 +1,1608 @@\n+/* Subroutines needed for unwinding IA-64 standard format stack frame\n+   info for exception handling.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod  <amacleod@cygnus.com>\n+                  Andrew Haley  <aph@cygnus.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/* It is incorrect to include config.h here, because this file is being\n+   compiled for the target, and hence definitions concerning only the host\n+   do not apply.  */\n+\n+#include \"tconfig.h\"\n+\n+/* We disable this when inhibit_libc, so that gcc can still be built without\n+   needing header files first.  */\n+/* ??? This is not a good solution, since prototypes may be required in\n+   some cases for correct code.  See also libgcc2.c/crtstuff.c.  */\n+#ifndef inhibit_libc\n+/* fixproto guarantees these system headers exist. */\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+#else\n+#include <stddef.h>\n+#ifndef malloc\n+extern void *malloc (size_t);\n+#endif\n+#ifndef free\n+extern void free (void *);\n+#endif\n+#endif\n+\n+#include \"defaults.h\"\n+#include \"gthr.h\"\n+\n+/* Define a mutex for frame information modification. */\n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n+#else\n+static __gthread_mutex_t object_mutex;\n+#endif\n+\n+/* This is undefined below if we need it to be an actual function.  */\n+#define init_object_mutex_once()\n+\n+/* Some types used by the DWARF 2 spec.  */\n+\n+typedef          int  sword __attribute__ ((mode (SI)));\n+typedef unsigned int  uword __attribute__ ((mode (SI)));\n+typedef unsigned int  uaddr __attribute__ ((mode (pointer)));\n+typedef          int  saddr __attribute__ ((mode (pointer)));\n+typedef unsigned char ubyte;\n+\n+static void bad_record (unsigned char*, int) __attribute__ ((__noreturn__));\n+\n+#if __GTHREADS\n+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n+\n+/* Helper for init_object_mutex_once.  */\n+\n+static void\n+init_object_mutex (void)\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&object_mutex);\n+}\n+\n+/* Call this to arrange to initialize the object mutex.  */\n+\n+#undef init_object_mutex_once\n+static void\n+init_object_mutex_once (void)\n+{\n+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+  __gthread_once (&once, init_object_mutex);\n+}\n+\n+#endif /* __GTHREAD_MUTEX_INIT_FUNCTION */\n+#endif /* __GTHREADS */\n+\n+/* This structure represents a single unwind table entry.  We lie and say\n+   its the dwarf_fde structure to use the common object in frame.h */\n+\n+typedef struct dwarf_fde\n+{\n+  long start_offset;\n+  long end_offset;\n+  long unwind_offset;\n+} unwind_table_entry;\n+  \n+/* Defining dwarf_fde allows us to use the common object registration.  */\n+typedef unwind_table_entry dwarf_fde;\n+typedef unwind_table_entry fde;\n+\n+#include \"frame.h\" \n+\n+static struct object *objects = NULL;\n+\n+static inline saddr\n+fde_compare (fde *x, fde *y)\n+{\n+  return (saddr)x->start_offset - (saddr)y->start_offset;\n+}\n+\n+#include \"frame.c\"\n+\n+/* called from crtend.o to register the end of the unwind info for an\n+   object.  */\n+void\n+__register_frame_info_aux (struct dwarf_fde *end)\n+{\n+  objects->fde_end = end;\n+}\n+  \n+static void\n+frame_init (struct object *ob)\n+{\n+  int count = 0;  /* reserve one for the dummy last entry.  */\n+  fde_accumulator accu;\n+  unwind_table_entry *ptr = ob->fde_begin;\n+\n+  if (ptr == 0)\n+    return;\n+\n+  /* Count the number of entries objects.  */\n+  for ( ; ptr < ob->fde_end; ptr++)\n+    count++;\n+\n+  ob->pc_begin = (void *)(uaddr) - 1;\n+  ob->pc_end = 0;\n+\n+  start_fde_sort (&accu, count);\n+  for (ptr = ob->fde_begin; ptr < ob->fde_end; ptr++)\n+  {\n+    if (ob->pc_base + ptr->start_offset < ob->pc_begin)\n+      ob->pc_begin = ob->pc_base + ptr->start_offset;\n+    if (ob->pc_base + ptr->end_offset > ob->pc_end)\n+      ob->pc_end = ob->pc_base + ptr->end_offset;\n+    fde_insert (&accu, (fde *)ptr);\n+  }\n+\n+  ob->fde_array = end_fde_sort (&accu, count);\n+  ob->count = count;\n+}\n+\n+/* Return a pointer to the FDE for the function containing PC.  */\n+\n+static fde *\n+find_fde (void *pc, void **pc_base)\n+{\n+  struct object *ob;\n+  size_t lo, hi;\n+\n+  *pc_base = NULL;\n+\n+  init_object_mutex_once ();\n+  __gthread_mutex_lock (&object_mutex);\n+\n+  for (ob = objects; ob; ob = ob->next)\n+    {\n+      if (ob->pc_begin == 0)\n+\tframe_init (ob);\n+      if (pc >= ob->pc_begin && pc < ob->pc_end)\n+\tbreak;\n+    }\n+\n+  __gthread_mutex_unlock (&object_mutex);\n+\n+  if (ob == 0)\n+    return 0;\n+\n+  *pc_base = ob->pc_base;\n+  /* Standard binary search algorithm.  */\n+  for (lo = 0, hi = ob->count; lo < hi; )\n+    {\n+      size_t i = (lo + hi) / 2;\n+      fde *f = ob->fde_array[i];\n+\n+      if (pc - ob->pc_base < f->start_offset)\n+\thi = i;\n+      else if (pc - ob->pc_base >= f->end_offset)\n+\tlo = i + 1;\n+      else\n+\treturn f;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Decode the unsigned LEB128 constant at BUF and return it. The value at\n+   MEM is updated to reflect the next position in the buffer.  */\n+\n+static unsigned long\n+read_uleb128 (unsigned char **mem)\n+{\n+  unsigned shift = 0;\n+  unsigned long result = 0;\n+  unsigned char *buf = *mem;\n+\n+  while (1)\n+    {\n+      unsigned long byte = *buf++;\n+      result |= (byte & 0x7f) << shift;\n+      if ((byte & 0x80) == 0)\n+        break;\n+      shift += 7;\n+    }\n+  *mem = buf;\n+  return result;\n+}\n+\n+static void\n+bad_record (ptr, offset)\n+     unsigned char *ptr;\n+     int offset;\n+{\n+#if 0\n+  printf (\"Bad unwind record format value '%x' at offset %d in record %p\\n\",\n+  \t  *(ptr + offset), offset , ptr);\n+#endif  \n+  abort ();\n+}\n+\n+static unsigned char *read_R_record (unwind_record *, unsigned char, unsigned char *);\n+static unsigned char *read_X_record (unwind_record *, unsigned char, unsigned char *);\n+static unsigned char *read_B_record (unwind_record *, unsigned char, unsigned char *);\n+static unsigned char *read_P_record (unwind_record *, unsigned char, unsigned char *);\n+\n+\n+/* This routine will determine what type of record the memory pointer\n+   is refering to, and fill in the appropriate fields for that record type. \n+   PROLOGUE_FLAG is TRUE if we are currently processing a PROLOGUE\n+   body. \n+   DATA is a pointer to an unwind record which will be filled in.\n+   PTR is a pointer to the current location in the unwind table where we\n+   will read the next record from.  \n+   The return value is the start of the next record.  */\n+\n+extern unsigned char *\n+get_unwind_record (prologue_flag, data, ptr)\n+    int prologue_flag;\n+    unwind_record *data;\n+    unsigned char *ptr;\n+{\n+  unsigned char val = *ptr++;\n+\n+  if ((val & 0x80) == 0)\n+    {\n+      return read_R_record (data, val, ptr);\n+    }\n+\n+  if (val == UNW_X1 || val == UNW_X2 || val == UNW_X3 || val == UNW_X4)\n+    return read_X_record (data, val, ptr);\n+\n+  if (prologue_flag)\n+    return read_P_record (data, val, ptr);\n+  else\n+    return read_B_record (data, val, ptr);\n+}\n+\n+\n+static unsigned char *\n+read_R_record (data, val, ptr)\n+     unwind_record *data;\n+     unsigned char val;\n+     unsigned char *ptr;\n+{\n+  if ((val & 0x40) == 0)\n+    {\n+      /* R1 format.  */\n+      if (val & 0x20)\n+        data->type = body;\n+      else\n+        data->type = prologue;\n+      data->record.r.rlen = (val & 0x1f);\n+      return ptr;\n+    }\n+\n+  if ((val & 0xF8) == UNW_R2)\n+    {\n+      /* R2 format.  */\n+      unsigned char mask = (val & 0x07) << 1;\n+      if (*ptr & 0x80) \n+        mask = mask | 1;\n+      data->type = prologue_gr;\n+      data->record.r.mask = mask;\n+      data->record.r.grsave = (*ptr++ & 0x7f);\n+      data->record.r.rlen = read_uleb128 (&ptr);\n+      return ptr;\n+    }\n+\n+  if ((val & 0xFC) == UNW_R3)\n+    {\n+      /* R3 format.  */\n+      val = (val & 0x03);\n+      if (val == 0)\n+        data->type = prologue;\n+      else\n+        if (val == 1)\n+\t  data->type = body;\n+\telse\n+\t  bad_record (ptr - 1, 0);\n+      data->record.r.rlen = read_uleb128 (&ptr);\n+      return ptr;\n+    }\n+  bad_record (ptr - 1, 0);\n+}\n+\n+static void\n+process_a_b_reg_code(data, val)\n+     unwind_record *data;\n+     unsigned char val;\n+{\n+  int code = (val & 0x60) >> 5;\n+  int reg = (val & 0x1f);\n+  switch (code) \n+    {\n+      case 0:\n+\tdata->record.x.reg = GR_REG (reg);\n+        break;\n+      case 1:\n+\tdata->record.x.reg = FR_REG (reg);\n+        break;\n+      case 2:\n+\tdata->record.x.reg = BR_REG (reg);\n+        break;\n+      case 3:\n+        /* TODO. We need to encode the specialty regs here. The table is \n+\t   on page B-9 of the runtime manual (under the X1 description.) */\n+        break;\n+    }\n+}\n+\n+static unsigned char *\n+read_X_record (data, val, ptr)\n+     unwind_record *data;\n+     unsigned char val;\n+     unsigned char *ptr;\n+{\n+  unsigned long tmp;\n+  int byte1, byte2;\n+  switch (val) \n+    {\n+      case UNW_X1:\n+        byte1 = *ptr++;\n+\tdata->record.x.t = read_uleb128 (&ptr);\n+\ttmp = read_uleb128 (&ptr);\n+\tif ((byte1 & 0x80) == 0)\n+\t  {\n+\t    data->type = spill_psprel;\n+\t    data->record.x.pspoff = tmp;\n+\t  }\n+\telse\n+\t  {\n+\t    data->type = spill_sprel;\n+\t    data->record.x.spoff = tmp;\n+\t  }\n+\tprocess_a_b_reg_code (data, byte1);\n+\treturn ptr;\n+      case UNW_X4:\n+        byte1 = *ptr++;\n+\tdata->record.x.qp = PR_REG (byte1 & 0x3f);\n+\tdata->type = spill_reg_p;\n+      case UNW_X2:\n+        {\n+\t  int xy;\n+\t  int treg;\n+\t  /* Only set type if we didn't fall through the UNW_X4 case.  */\n+\t  if (val == UNW_X2)\n+\t    data->type = spill_reg;\n+\t  byte1 = *ptr++;\n+\t  byte2 = *ptr++;\n+\t  process_a_b_reg_code (data, byte1);\n+\t  xy = (((byte1 >> 7) << 1 ) | (byte2 >> 7));\n+\t  treg = (byte2 & 0x7f);\n+\t  switch (xy) \n+\t    {\n+\t      case 0:\n+\t        data->record.x.treg = GR_REG (treg);\n+\t        break;\n+\t      case 1:\n+\t        data->record.x.treg = FR_REG (treg);\n+\t        break;\n+\t      case 2:\n+\t        data->record.x.treg = BR_REG (treg);\n+\t        break;\n+\t      case 3:\n+\t        bad_record (ptr - 3, 2);\n+\t    }\n+\t  data->record.x.t = read_uleb128 (&ptr);\n+        }\n+\treturn ptr;\n+      case UNW_X3:\n+        byte1 = *ptr++;\n+\tbyte2 = *ptr++;\n+\tdata->record.x.qp = PR_REG (byte1 & 0x3f);\n+\tprocess_a_b_reg_code (data, byte2);\n+\tdata->record.x.t = read_uleb128 (&ptr);\n+\ttmp = read_uleb128 (&ptr);\n+\tif ((byte1 & 0x80) == 0)\n+\t  {\n+\t    data->type = spill_psprel_p;\n+\t    data->record.x.pspoff = tmp;\n+\t  }\n+\telse\n+\t  {\n+\t    data->type = spill_sprel_p;\n+\t    data->record.x.spoff = tmp;\n+\t  }\t\n+\treturn ptr;\n+      default:\n+\tbad_record (ptr - 1, 0);\n+    }\n+  return NULL;\n+}\n+\n+static unsigned char *\n+read_B_record (data, val, ptr)\n+     unwind_record *data;\n+     unsigned char val;\n+     unsigned char *ptr;\n+{\n+  if ((val & 0xc0) == 0x80)\n+    {\n+      /* B1 format.  */\n+      if ((val & 0x20) == 0)\n+        data->type = label_state;\n+      else\n+        data->type = copy_state;\n+      data->record.b.label = (val & 0x1f);\n+      return ptr;\n+    }\n+  \n+  if ((val & 0xe0) == 0xc0)\n+    {\n+      /* B2 format.  */\n+      data->type = epilogue;\n+      data->record.b.ecount = (val & 0x1f);\n+      data->record.b.t = read_uleb128 (&ptr);\n+      return ptr;\n+    }\n+\n+  if (val == UNW_B3)\n+    {\n+      /* B3 format.  */\n+      data->type = epilogue;\n+      data->record.b.t = read_uleb128 (&ptr);\n+      data->record.b.ecount = read_uleb128 (&ptr);\n+      return ptr;\n+    }\n+\n+  if (val == UNW_B4)\n+    {\n+      /* B4 format, with r == 0.  */\n+      data->type = label_state;\n+      data->record.b.label = read_uleb128 (&ptr);\n+      return ptr;\n+    }\n+\n+  if (val == (UNW_B4 | 0x08))\n+    {\n+      /* B4 format, with r == 1.  */\n+      data->type = copy_state;\n+      data->record.b.label = read_uleb128 (&ptr);\n+      return ptr;\n+    }\n+\n+  bad_record (ptr - 1, 0);\n+\n+}\n+\n+/* This array is used to set the TYPE field for format P3.  */\n+static unw_record_type P3_record_types[] = {\n+  psp_gr, rp_gr, pfs_gr, preds_gr, unat_gr, lc_gr, rp_br, rnat_gr,\n+  bsp_gr, bspstore_gr, fpsr_gr, priunat_gr };\n+\n+/* This array is used to set the TYPE field for format P7.  */\n+static unw_record_type P7_record_types[] = {\n+  mem_stack_f, mem_stack_v, spill_base, psp_sprel, rp_when, rp_psprel,\n+  pfs_when, pfs_psprel, preds_when, preds_psprel, lc_when, lc_psprel,\n+  unat_when, unat_psprel, fpsr_when, fpsr_psprel };\n+\n+/* These values and the array are used to determine which additional ULEB128\n+   fields are required for the P7 format.  */\n+#define P7_T_SIZE\t0\n+#define P7_T\t\t1\n+#define P7_PSPOFF       2\n+#define P7_SPOFF\t3\n+static unsigned char P7_additional_fields [] = {\n+   P7_T_SIZE, P7_T, P7_PSPOFF, P7_SPOFF, P7_T, P7_PSPOFF, \n+   P7_T, P7_PSPOFF, P7_T, P7_PSPOFF, P7_T, P7_PSPOFF, P7_T, P7_PSPOFF };\n+\n+/* This array is used to set the TYPE field for format P8. \n+   Note that entry 0 is not used in this array, so it is filled with\n+   rp_spel for completely arbitrary reasons.  */\n+static unw_record_type P8_record_types[] = {\n+  rp_sprel, rp_sprel, pfs_sprel, preds_sprel, lc_sprel, unat_sprel, fpsr_sprel, \n+  bsp_when, bsp_psprel, bsp_sprel, bspstore_when, bspstore_psprel,\n+  bspstore_sprel, rnat_when, rnat_psprel, rnat_sprel, priunat_when_gr,\n+  priunat_psprel, priunat_sprel, priunat_when_mem };\n+\n+/* These values and the array are used to determine which additional ULEB128\n+   fields are required for the P8 format.  */\n+#define P8_T\t\t0\n+#define P8_PSPOFF       1\n+#define P8_SPOFF\t2\n+static unsigned char P8_additional_fields [] = {\n+  P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF,\n+  P8_T, P8_PSPOFF, P8_SPOFF, P8_T, P8_PSPOFF, P8_SPOFF,\n+  P8_T, P8_PSPOFF, P8_SPOFF, P8_T, P8_PSPOFF, P8_SPOFF, P8_T };\n+\n+\n+static unsigned char *\n+read_P_record (data, val, ptr)\n+     unwind_record *data;\n+     unsigned char val;\n+     unsigned char *ptr;\n+{\n+  if ((val & 0xe0) == 0x80)\n+    {\n+      /* P1 format.  */\n+      data->type = br_mem;\n+      data->record.p.brmask = (val & 0x1f);\n+      return ptr;\n+    }\n+\n+  if ((val & 0xf0) == 0xa0)\n+    {\n+      /* P2 format.  */\n+      int byte1;\n+      data->type = br_gr;\n+      byte1 = *ptr++;\n+      data->record.p.brmask = (val & 0x0f) << 1 + (byte1 >> 7);\n+      data->record.p.gr = GR_REG (byte1 & 0x7f);\n+      return ptr;\n+    }\n+\n+  if ((val & 0xf8) == 0xB0)\n+    {\n+      /* P3 format.  */\n+      int byte1 = *ptr++;\n+      int r = ((val & 0x07) << 1) + (byte1 >> 7);\n+      data->type = P3_record_types[r];\n+      if (r == 6)\n+        data->record.p.br = BR_REG (byte1 & 0x7f);\n+      else\n+        data->record.p.gr = GR_REG (byte1 & 0x7f);\n+      if (r > 11)\n+        bad_record (ptr - 2, 0);\n+      return ptr;\n+    }\n+\n+  if (val == UNW_P4)\n+    {\n+      /* P4 format.  Currently unimplemented.  */\n+      int len = 0;  /* TODO.. get prologue rlen. */\n+      int size = (len * 2 + 7) / 8;\n+\n+      data->type = spill_mask;\n+      data->record.p.imask = (unsigned char *) malloc (size);\n+      /* memcpy (data->record.p.imask, ptr, size);  */\n+      return ptr+size;\n+    }\n+\n+  if (val == UNW_P5)\n+    {\n+      /* P5 format.  */\n+      int byte1 = *ptr++;\n+      int byte2 = *ptr++;\n+      int byte3 = *ptr++;\n+      data->type = frgr_mem;\n+      data->record.p.grmask = (byte1 >> 4);\n+      data->record.p.frmask = ((byte1 & 0x0f) << 16) | (byte2 << 8) | byte3;\n+      return ptr;\n+    }\n+  \n+  if ((val & 0xe0) == UNW_P6)\n+    {\n+      /* P6 format.  */\n+      if ((val & 0x10) == 0)\n+        data->type = fr_mem;\n+      else\n+        data->type = gr_mem;\n+      data->record.p.rmask = (val & 0x0f);\n+      return ptr;\n+    }\n+  \n+  if ((val & 0xf0) == UNW_P7)\n+    {\n+      /* P7 format.  */\n+      int r = (val & 0x0f);\n+      data->type = P7_record_types[r];\n+      switch (P7_additional_fields[r])\n+        {\n+\t  case P7_T_SIZE:\n+\t    data->record.p.t = read_uleb128 (&ptr);\n+\t    data->record.p.size = read_uleb128 (&ptr);\n+\t    break;\n+\t  case P7_T:\n+\t    data->record.p.t = read_uleb128 (&ptr);\n+\t    break;\n+\t  case P7_PSPOFF:\n+\t    data->record.p.pspoff = read_uleb128 (&ptr);\n+\t    break;\n+\t  case P7_SPOFF:\n+\t    data->record.p.spoff = read_uleb128 (&ptr);\n+\t    break;\n+\t}\n+      return ptr;\n+    }\n+ \n+  if (val == UNW_P8)\n+    {\n+      /* P8 format.  */\n+      int r = *ptr++;\n+      data->type = P8_record_types[r];\n+      switch (P8_additional_fields[r])\n+        {\n+\t  case P8_T:\n+\t    data->record.p.t = read_uleb128 (&ptr);\n+\t    break;\n+\t  case P8_PSPOFF:\n+\t    data->record.p.pspoff = read_uleb128 (&ptr);\n+\t    break;\n+\t  case P8_SPOFF:\n+\t    data->record.p.spoff = read_uleb128 (&ptr);\n+\t    break;\n+\t}\n+      return ptr;\n+    }\n+  \n+  if (val == UNW_P9)\n+    {\n+      /* P9 format.  */\n+      int byte1 = *ptr++;\n+      int byte2 = *ptr++;\n+      data->type = gr_gr;\n+      data->record.p.grmask = (byte1 & 0x0f);\n+      data->record.p.gr = GR_REG (byte2 & 0x7f);\n+      return ptr;\n+    }\n+  \n+  if (val == UNW_P10)\n+    {\n+      /* P10 format.  */\n+      int abi = *ptr++;\n+      int context = *ptr++;\n+      /* TODO. something about abi entries.  */\n+      return ptr;\n+    }\n+\n+  return ptr;\n+}\n+\n+\f\n+/* Frame processing routines.  */\n+\n+/* Initialize a single register structure.  */\n+static void \n+init_ia64_reg_loc (reg, size)\n+     ia64_reg_loc *reg;\n+     short size;\n+{\n+  reg->when = -1;\n+  reg->loc_type = IA64_UNW_LOC_TYPE_NONE;\n+  reg->l.mem = (void *)0;\n+  reg->reg_size = size;\n+}\n+\n+/* Iniitialize an entire frame to the default of nothing.  */\n+static void\n+init_ia64_unwind_frame (frame) \n+     ia64_frame_state *frame ;\n+{\n+  int x;\n+  \n+  for (x = 0; x < 4; x++)\n+    init_ia64_reg_loc (&frame->gr[x], 8);\n+  for (x = 0; x < 20; x++)\n+    init_ia64_reg_loc (&frame->fr[x], 16);\n+  for (x = 0; x < 5; x++)\n+    init_ia64_reg_loc (&frame->br[x], 8);\n+\n+  init_ia64_reg_loc (&frame->rp, 8);\n+  init_ia64_reg_loc (&frame->fpsr, 8);\n+  init_ia64_reg_loc (&frame->bsp, 8);\n+  init_ia64_reg_loc (&frame->bspstore, 8);\n+  init_ia64_reg_loc (&frame->rnat, 8);\n+  init_ia64_reg_loc (&frame->pfs, 8);\n+  init_ia64_reg_loc (&frame->unat, 8);\n+  init_ia64_reg_loc (&frame->lc, 8);\n+  init_ia64_reg_loc (&frame->pr, 8);\n+  init_ia64_reg_loc (&frame->priunat, 8);\n+  init_ia64_reg_loc (&frame->sp, 8);\n+  init_ia64_reg_loc (&frame->psp, 8);\n+  init_ia64_reg_loc (&frame->spill_base, 8);\n+}\n+\n+/* This fuction will process a single descriptor.\n+   addr is a pointer to the descriptor record to read, \n+   frame is the current frame state structure, which will be\n+     modified to reflect this descriptor.\n+   len is the length of a prologue region, or -1 if it wasn't one.\n+   the return value is a pointer to the start of the next descriptor.  */\n+\n+static void *\n+execute_one_ia64_descriptor (addr, frame, len)\n+     void *addr;\n+     ia64_frame_state *frame;\n+     long *len;\n+{\n+  unwind_record r;\n+  ia64_reg_loc *loc_ptr = NULL;\n+  int grmask = 0, frmask = 0;\n+\n+  *len = -1;\n+  addr = get_unwind_record (1, &r, addr);\n+\n+  /* process it in 2 phases, the first phase will either do the work,\n+     or set up a pointer to the records we care about \n+     (ie a special purpose ar perhaps, and the second will actually \n+     fill in the record.  */\n+  switch (r.type) \n+    {\n+      case prologue:\n+      case body:\n+\t*len = r.record.r.rlen;\n+\tbreak;\n+      case prologue_gr:\n+        {\n+\t  int val, reg;\n+\n+\t  *len = r.record.r.rlen;\n+\t  val = r.record.r.mask;\n+\t  reg = r.record.r.grsave;\n+\t  if (val & 0x08)\n+\t    {\n+\t      frame->rp.when = 0;\n+\t      frame->rp.loc_type  = IA64_UNW_LOC_TYPE_GR;\n+\t      frame->rp.l.regno = reg++;\n+\t    }\n+\t  if (val & 0x04)\n+\t    {\n+\t      frame->pfs.when = 0;\n+\t      frame->pfs.loc_type  = IA64_UNW_LOC_TYPE_GR;\n+\t      frame->pfs.l.regno = reg++;\n+\t    }\n+\t  if (val & 0x02)\n+\t    {\n+\t      frame->psp.when = 0;\n+\t      frame->psp.loc_type  = IA64_UNW_LOC_TYPE_GR;\n+\t      frame->psp.l.regno = reg++;\n+\t    }\n+\t  if (val & 0x01)\n+\t    {\n+\t      frame->pr.when = 0;\n+\t      frame->pr.loc_type  = IA64_UNW_LOC_TYPE_GR;\n+\t      frame->pr.l.regno = reg++;\n+\t    }\n+\t  break;\n+\t}\n+      case mem_stack_f:\n+      case mem_stack_v:\n+        frame->sp.when = r.record.p.t; \n+\tframe->sp.l.offset = r.record.p.size;\n+\tframe->sp.loc_type = IA64_UNW_LOC_TYPE_OFFSET;\n+\tbreak;\n+      case psp_gr:\n+      case psp_sprel:\n+        loc_ptr = &frame->psp;\n+\tbreak;\n+      case rp_br:\n+      case rp_gr:\n+      case rp_when:\n+      case rp_psprel:\n+      case rp_sprel:\n+        loc_ptr = &frame->rp;\n+\tbreak;\n+      case pfs_gr:\n+      case pfs_when:\n+      case pfs_psprel:\n+      case pfs_sprel:\n+        loc_ptr = &frame->pfs;\n+\tbreak;\n+      case preds_gr:\n+      case preds_when:\n+      case preds_psprel:\n+      case preds_sprel:\n+        loc_ptr = &frame->pr;\n+\tbreak;\n+      case unat_gr:\n+      case unat_when:\n+      case unat_psprel:\n+      case unat_sprel:\n+        loc_ptr = &frame->unat;\n+\tbreak;\n+      case lc_gr:\n+      case lc_when:\n+      case lc_psprel:\n+      case lc_sprel:\n+        loc_ptr = &frame->lc;\n+\tbreak;\n+      case fpsr_gr:\n+      case fpsr_when:\n+      case fpsr_psprel:\n+      case fpsr_sprel:\n+        loc_ptr = &frame->fpsr;\n+\tbreak;\n+      case priunat_gr:\n+      case priunat_sprel:\n+      case priunat_when_gr:\n+      case priunat_when_mem:\n+      case priunat_psprel:\n+        loc_ptr = &frame->priunat;\n+\tbreak;\n+      case bsp_gr:\n+      case bsp_sprel:\n+      case bsp_when:\n+      case bsp_psprel:\n+        loc_ptr = &frame->bsp;\n+\tbreak;\n+      case bspstore_gr:\n+      case bspstore_sprel:\n+      case bspstore_when:\n+      case bspstore_psprel:\n+        loc_ptr = &frame->bspstore;\n+\tbreak;\n+      case rnat_gr:\n+      case rnat_sprel:\n+      case rnat_when:\n+      case rnat_psprel:\n+        loc_ptr = &frame->rnat;\n+\tbreak;\n+      case spill_base:\n+        loc_ptr = &frame->spill_base;\n+\tbreak;\n+      case fr_mem:\n+        frmask = r.record.p.rmask;\n+\tbreak;\n+      case gr_mem:\n+        grmask = r.record.p.rmask;\n+\tbreak;\n+      case frgr_mem:\n+        frmask = r.record.p.frmask;\n+        grmask = r.record.p.grmask;\n+\tbreak;\n+      case br_mem:\n+        {\n+\t  int x, mask = 0x01;\n+\t  int saved = r.record.p.brmask;\n+\t  for (x = 0; x < 5; x++)\n+\t    {\n+\t      if (saved & mask)\n+\t\tframe->br[x].loc_type = IA64_UNW_LOC_TYPE_SPILLBASE;\n+\t      mask = mask << 1;\n+\t    }\n+\t  break;\n+\t}\n+      case br_gr:\n+        {\n+\t  int x, mask = 0x01;\n+\t  int reg = r.record.p.gr;\n+\t  int saved = r.record.p.brmask;\n+\t  for (x = 0; x < 5; x++)\n+\t    {\n+\t      if (saved & mask)\n+\t        {\n+\t\t  frame->br[x].loc_type = IA64_UNW_LOC_TYPE_GR;\n+\t\t  frame->br[x].l.regno = reg++;\n+\t\t}\n+\t      mask = mask << 1;\n+\t    }\n+\t  break;\n+\t}\n+      case gr_gr:\n+        {\n+\t  int x, mask = 0x01;\n+\t  int reg = r.record.p.gr;\n+\t  int saved = r.record.p.grmask;\n+\t  for (x = 0; x < 4; x++)\n+\t    {\n+\t      if (saved & mask)\n+\t        {\n+\t\t  frame->br[x].loc_type = IA64_UNW_LOC_TYPE_GR;\n+\t\t  frame->br[x].l.regno = reg++;\n+\t\t}\n+\t      mask = mask << 1;\n+\t    }\n+\t  break;\n+\t}\n+      case spill_mask:\n+        /* TODO.  */\n+\tbreak;\n+      case epilogue:\n+        /* TODO.  */\n+\tbreak;\n+      case label_state:\n+        /* TODO.  */\n+\tbreak;\n+      case copy_state: \n+        /* TODO. */\n+\tbreak;\n+      case spill_psprel:\n+      case spill_sprel:\n+      case spill_reg:\n+      case spill_psprel_p:\n+      case spill_sprel_p:\n+      case spill_reg_p:\n+        /* TODO. */\n+\tbreak;\n+      default:\n+\tabort ();\n+\tbreak;\n+    }\n+\n+  if (frmask)\n+    {\n+      int x, mask = 0x01;\n+      for (x = 0; x < 20; x++)\n+\t{\n+\t  if (frmask & mask)\n+\t    frame->fr[x].loc_type = IA64_UNW_LOC_TYPE_SPILLBASE;\n+\t  mask = mask << 1;\n+\t}\n+    }\n+\n+  if (grmask)\n+    {\n+      int x, mask = 0x01;\n+      for (x = 0; x < 4; x++)\n+\t{\n+\t  if (grmask & mask)\n+\t    frame->gr[x].loc_type = IA64_UNW_LOC_TYPE_SPILLBASE;\n+\t  mask = mask << 1;\n+\t}\n+    }\n+\n+  /* If there is more to do:  */\n+  if (loc_ptr != NULL)\n+    switch (r.type) \n+      {\n+\tcase psp_gr:\n+\tcase rp_gr:\n+\tcase pfs_gr:\n+\tcase preds_gr:\n+\tcase unat_gr:\n+\tcase lc_gr:\n+\tcase fpsr_gr:\n+\tcase priunat_gr:\n+\tcase bsp_gr:\n+\tcase bspstore_gr:\n+\tcase rnat_gr:\n+\t  loc_ptr->loc_type = IA64_UNW_LOC_TYPE_GR;\n+\t  loc_ptr->l.regno = r.record.p.gr;\n+\t  break;\n+\tcase rp_br:\n+\t  loc_ptr->loc_type = IA64_UNW_LOC_TYPE_BR;\n+\t  loc_ptr->l.regno = r.record.p.br;\n+\t  break;\n+\tcase rp_when:\n+\tcase pfs_when:\n+\tcase preds_when:\n+\tcase unat_when:\n+\tcase lc_when:\n+\tcase fpsr_when:\n+\tcase priunat_when_gr:\n+\tcase priunat_when_mem:\n+\tcase bsp_when:\n+\tcase bspstore_when:\n+\tcase rnat_when:\n+\t  loc_ptr->when = r.record.p.t;\n+\t  break;\n+\tcase rp_psprel:\n+\tcase pfs_psprel:\n+\tcase preds_psprel:\n+\tcase unat_psprel:\n+\tcase lc_psprel:\n+\tcase fpsr_psprel:\n+\tcase priunat_psprel:\n+\tcase bsp_psprel:\n+\tcase bspstore_psprel:\n+\tcase rnat_psprel:\n+\tcase spill_base:\n+\t  loc_ptr->loc_type = IA64_UNW_LOC_TYPE_PSPOFF;\n+\t  loc_ptr->l.offset = r.record.p.pspoff;\n+\t  break;\n+\tcase psp_sprel:\n+\tcase rp_sprel:\n+\tcase pfs_sprel:\n+\tcase preds_sprel:\n+\tcase unat_sprel:\n+\tcase lc_sprel:\n+\tcase fpsr_sprel:\n+\tcase priunat_sprel:\n+\tcase bsp_sprel:\n+\tcase bspstore_sprel:\n+\tcase rnat_sprel:\n+\t  loc_ptr->loc_type = IA64_UNW_LOC_TYPE_SPOFF;\n+\t  loc_ptr->l.offset = r.record.p.spoff;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t  break;\n+      }\n+  return addr;\n+}\n+\n+\n+#define IS_NaT_COLLECTION_ADDR(addr) ((((long)(addr) >> 3) & 0x3f) == 0x3f)\n+\n+/* Returns the address of the slot that's NSLOTS slots away from\n+   the address ADDR. NSLOTS may be positive or negative. */\n+static void *\n+rse_address_add(unsigned char *addr, int nslots)\n+{\n+  unsigned char *new_addr;\n+  int mandatory_nat_slots = nslots / 63;\n+  int direction = nslots < 0 ? -1 : 1;\n+\n+  new_addr = addr + 8 * (nslots + mandatory_nat_slots);\n+\n+  if (((long)new_addr >> 9)  != ((long)(addr + 8 * 64 * mandatory_nat_slots) >> 9))\n+    new_addr += 8 * direction;\n+\n+  if (IS_NaT_COLLECTION_ADDR(new_addr))\n+    new_addr += 8 * direction;\n+\n+  return new_addr;\n+}\n+\n+\n+/* Normalize a record to originate in either a register or memory \n+   location.  */\n+static void\n+normalize_reg_loc (frame, reg)\n+     ia64_frame_state *frame;\n+     ia64_reg_loc *reg;\n+{\n+  unsigned char *tmp;\n+  switch (reg->loc_type)\n+    {\n+      case IA64_UNW_LOC_TYPE_MEM:\n+        /* Already done.  */\n+        break;\n+      case IA64_UNW_LOC_TYPE_GR:\n+        /* If the register its saved in is a LOCAL register, we know\n+\t   its actually in memory, so we'll pick it up from there.  */\n+        if (reg->l.regno >= 32 && frame->my_bsp != 0)\n+\t  {\n+\t   /* Get from backing store.  */\n+\t    tmp = rse_address_add(frame->my_bsp, reg->l.regno - 32);\n+\t    reg->l.mem = tmp;\n+\t    reg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n+\t  }\n+        break;\n+      case IA64_UNW_LOC_TYPE_FR:\n+        /* If the register its saved in is a LOCAL register, we know\n+\t   its actually in memory, so we'll pick it up from there.  */\n+        if (reg->l.regno >= 32)\n+\t  {\n+\t   /* TODO. get from backing store.  */\n+\t  }\n+        break;\n+      case IA64_UNW_LOC_TYPE_BR:\n+        break;\n+      case IA64_UNW_LOC_TYPE_SPOFF:\n+        /* offset from the stack pointer, calculate the memory address\n+\t   now.  */\n+\ttmp = (unsigned char *)frame->my_sp + reg->l.offset * 4;\n+\treg->l.mem = tmp;\n+\treg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n+        break;\n+      case IA64_UNW_LOC_TYPE_PSPOFF:\n+        /* Actualy go get the value of the PSP add the offset, and thats \n+\t   the mem location we can find this value at. */\n+\ttmp = (*(unsigned char **)(frame->psp.l.mem)) + 16 - reg->l.offset * 4;\n+\treg->l.mem = tmp;\n+\treg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n+        break;\n+      case IA64_UNW_LOC_TYPE_SPILLBASE:\n+        /* located at the current spill base memory location, and we\n+\t   have to bump it as well. */\n+\treg->l.mem = frame->spill_base.l.mem;\n+\treg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n+\tframe->spill_base.l.mem += 8;\n+        break;\n+    }\n+\n+}\n+/* this function looks at a reg_loc and determines if its going\n+   to be an executed record or not between time start and end.  \n+   It is executed if it is exectued at START time. It is NOT\n+   executed if it happens at END time. */\n+static void \n+maybe_normalize_reg_loc (frame, reg, start, end)\n+     ia64_frame_state *frame;\n+     ia64_reg_loc *reg;\n+     int start, end;\n+{\n+  if (reg->loc_type != IA64_UNW_LOC_TYPE_NONE \n+      && reg->when >= start && reg->when < end)\n+    normalize_reg_loc (frame, reg);\n+}\n+\n+\n+/* Only works for 8 byte or less registers.  */\n+void *\n+__get_real_reg_value (reg)\n+     ia64_reg_loc *reg;\n+{\n+  if (reg->loc_type == IA64_UNW_LOC_TYPE_MEM)\n+    return *((void **)(reg->l.mem));\n+  \n+  /* All registers should be in memory if we've saved them. Local \n+     registers will be in backing store.  */\n+  abort ();\n+}\n+\n+void\n+__set_real_reg_value (reg, val) \n+     ia64_reg_loc *reg;\n+     void *val;\n+{\n+  if (reg->loc_type == IA64_UNW_LOC_TYPE_MEM)\n+    {\n+      void **ptr = reg->l.mem;\n+      *ptr = val;\n+      return;\n+    }\n+  abort ();\n+}\n+\n+static void\n+copy_reg_value (src, dest)\n+     ia64_reg_loc *src;\n+     ia64_reg_loc *dest;\n+{\n+  void **p = dest->l.mem;\n+  if (src->loc_type == IA64_UNW_LOC_TYPE_NONE)\n+    return;\n+  \n+  if (src->reg_size != dest->reg_size)\n+    abort ();\n+  if (src->reg_size <= 8)\n+    *p = __get_real_reg_value (src);\n+  else\n+    {\n+      void **d;\n+      if (src->reg_size> 16)\n+        abort ();\n+      if (dest->loc_type != IA64_UNW_LOC_TYPE_MEM)\n+        abort ();\n+      d = (void **)(dest->l.mem);\n+      *p++ = *d++;\n+      *p = *d;\n+    }\n+  return;\n+}\n+\n+/* Copy the values of any relevant saved registers in one frame \n+   to another for unwinding.  */\n+void \n+__copy_saved_reg_state (dest, src)\n+     ia64_frame_state *dest;\n+     ia64_frame_state *src;\n+{\n+  int x;\n+  for (x = 0; x < 4 ; x++)\n+    copy_reg_value (&src->gr[x], &dest->gr[x]);\n+  for (x = 0; x < 20 ; x++)\n+    copy_reg_value (&src->fr[x], &dest->fr[x]);\n+  for (x = 0; x < 5 ; x++)\n+    copy_reg_value (&src->br[x], &dest->br[x]);\n+      \n+  copy_reg_value (&src->fpsr, &dest->fpsr);\n+  copy_reg_value (&src->rnat, &dest->rnat);\n+  copy_reg_value (&src->unat, &dest->unat);\n+  copy_reg_value (&src->lc, &dest->lc);\n+  copy_reg_value (&src->pr, &dest->pr);\n+  copy_reg_value (&src->priunat, &dest->priunat);\n+  copy_reg_value (&src->pfs, &dest->pfs);\n+}\n+\n+\n+static void \n+process_state_between (frame, start, end)\n+     ia64_frame_state *frame;\n+     int start, end;\n+{\n+  int x;\n+  /* PSP, RP, SP, and PFS are handled seperately from here. */\n+\n+  /* GR's, FR's and BR's are saved at an arbitrary point, so we\n+      should handle them at teh very beginning.  */\n+  if (start == 0)\n+    {\n+      for (x = 0; x < 4 ; x++)\n+\tnormalize_reg_loc (frame, &frame->gr[x]);\n+      for (x = 0; x < 20 ; x++)\n+\tnormalize_reg_loc (frame, &frame->fr[x]);\n+      for (x = 0; x < 5 ; x++)\n+\tnormalize_reg_loc (frame, &frame->br[x]);\n+    }\n+  \n+  maybe_normalize_reg_loc (frame, &frame->fpsr, start, end);\n+  maybe_normalize_reg_loc (frame, &frame->bsp, start, end);\n+  maybe_normalize_reg_loc (frame, &frame->bspstore, start, end);\n+  maybe_normalize_reg_loc (frame, &frame->rnat, start, end);\n+  maybe_normalize_reg_loc (frame, &frame->unat, start, end);\n+  maybe_normalize_reg_loc (frame, &frame->lc, start, end);\n+  maybe_normalize_reg_loc (frame, &frame->pr, start, end);\n+  maybe_normalize_reg_loc (frame, &frame->priunat, start, end);\n+}\n+\n+/* This function will take a frame state, and translate all the location\n+   records into actual memory address, or register numbers, based on\n+   what the ia64_reg_loc fields require to actually go get the values.  \n+   (ie, this translates SPOFF and PSPOFF, etc into MEM types. \n+   frame is the frame to be changed.\n+   unwind_time is the insn slot number we are unwinding to.  Anything \n+     that has a WHEN record beyond this time is cleared since it\n+     isn't relevant.  */\n+static void\n+frame_translate (frame, unwind_time)\n+     ia64_frame_state *frame;\n+     long unwind_time;\n+{\n+  /* First, establish values of PFS and PSP and RP, if needed.  */\n+\n+  normalize_reg_loc (frame, &frame->pfs);\n+  normalize_reg_loc (frame, &frame->psp);\n+  normalize_reg_loc (frame, &frame->rp);\n+ \n+  if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE)\n+    return;\n+\n+  /* The stack pointer at the function start is the PSP value\n+     saved away.  */\n+  frame->my_sp = __get_real_reg_value (&frame->psp);\n+\n+  if (frame->psp.loc_type != IA64_UNW_LOC_TYPE_MEM)\n+    abort ();\n+\n+  /* spill base is set up off the PSP register, which should now \n+     have its value. */\n+  normalize_reg_loc (frame, &frame->spill_base);\n+\n+  /* If the SP is adjusted, process records up to where it\n+     is adjusted, then adjust it, then process the rest.  */\n+  if (frame->sp.when >= 0)\n+    {\n+      process_state_between (frame, 0, frame->sp.when);\n+      if (frame->sp.loc_type != IA64_UNW_LOC_TYPE_OFFSET)\n+\tabort ();\n+      frame->my_sp = \n+\t      (unsigned char *)frame->my_sp - frame->sp.l.offset;\n+      process_state_between (frame, frame->sp.when, unwind_time);\n+    }\n+  else\n+    process_state_between (frame, 0, unwind_time);\n+}\n+\n+/* this function will set a frame_state with all the required fields\n+   from a functions unwind descriptors.\n+   pc is the location we need info up until (ie, the unwind point)\n+   frame is the frame_state structure to be set up.\n+   Returns a pointer to the unwind info pointer for the frame.  */\n+unwind_info_ptr *\n+__build_ia64_frame_state (pc, frame, bsp, pc_base_ptr)\n+     unsigned char *pc;\n+     ia64_frame_state *frame;\n+     void *bsp;\n+     void **pc_base_ptr;\n+{\n+  long len;\n+  int region_offset = 0;\n+  int last_region_size = 0;\n+  void *addr, *end;\n+  unwind_table_entry *entry;\n+  unsigned char *start_pc;\n+  void *pc_base;\n+  int pc_offset;\n+  struct unwind_info_ptr *unw_info_ptr;\n+\n+  entry = find_fde (pc, &pc_base);\n+  if (!entry)\n+    return 0;\n+\n+  start_pc = pc_base + entry->start_offset;\n+  unw_info_ptr = ((struct unwind_info_ptr *)(pc_base + entry->unwind_offset));\n+  addr = unw_info_ptr->unwind_descriptors;\n+  end = addr + unw_info_ptr->length * 8;\n+  pc_offset = (pc - start_pc) / 16 * 3;\n+\n+  init_ia64_unwind_frame (frame);\n+  frame->my_bsp = bsp;\n+\n+  /* stop when we get to the end of the descriptor list, or if we\n+     encounter a region whose initial offset is already past the\n+     PC we are unwinding too.  */\n+\n+  while (addr < end && pc_offset > region_offset)\n+    {\n+      /* First one must be a record header.  */\n+      addr = execute_one_ia64_descriptor (addr, frame, &len);\n+      if (len > 0)\n+        {\n+\t  region_offset += last_region_size;\n+\t  last_region_size = len;\n+\t}\n+    }\n+  /* Now we go get the actual values.  */\n+  frame_translate (frame, pc_offset);\n+  if (pc_base_ptr)\n+    *pc_base_ptr = pc_base;\n+  return unw_info_ptr;\n+}\n+\n+/* Given an unwind info pointer, return the personailty routine.  */\n+void *\n+__get_personality (ptr)\n+     unwind_info_ptr *ptr;\n+{\n+  void **p;\n+  p = (void **) (ptr->unwind_descriptors + ptr->length * 8);\n+  return *p;\n+}\n+\n+void *\n+__get_except_table (ptr)\n+     unwind_info_ptr *ptr;\n+{\n+  void **p, *table;\n+  p = (void **) (ptr->unwind_descriptors + ptr->length * 8);\n+  /* If there is no personality, there is no handler data.  */\n+  if (*p == 0)\n+    return 0;\n+  table = (void *) (ptr->unwind_descriptors + ptr->length * 8 + 8);\n+  return table;\n+}\n+\n+/* Given a PFS value, and the current BSp, calculate the BSp of the caller.  */\n+void *\n+__calc_caller_bsp (pfs, bsp)\n+     long pfs;\n+     unsigned char *bsp;\n+{\n+  int size_of_locals;\n+\n+  /* The PFS looks like :  xxxx SOL:7 SOF:7. The SOF is bits 0-7 and SOL \n+     is bits 8-15. We only care about SOL.  */\n+\n+  size_of_locals = (pfs >> 7) & 0x7f;\n+  return rse_address_add (bsp, -size_of_locals);\n+}\n+\n+static int \n+ia64_backtrace_helper (void **array, void *throw_pc, \n+\t\t       ia64_frame_state *throw_frame,\n+\t\t       ia64_frame_state *frame, void *bsp, int size)\n+{\n+  void *pc = NULL;\n+  int frame_count = 0;\n+  unwind_info_ptr *info;\n+\n+  __builtin_ia64_flushrs ();      /*  Make the local register stacks available.  */\n+\n+  /* Start at our stack frame, get our state.  */\n+  info = __build_ia64_frame_state (throw_pc, throw_frame, bsp, NULL);\n+\n+  *frame = *throw_frame;\n+\n+  while (info && frame_count < size)\n+    {\n+      pc = array[frame_count++] = __get_real_reg_value (&frame->rp);\n+      --pc;\n+      bsp = __calc_caller_bsp \n+\t((long)__get_real_reg_value (&frame->pfs), frame->my_bsp);\n+      info = __build_ia64_frame_state (pc, frame, bsp, NULL);\n+      if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE) /* We've finished. */\n+\tbreak;\n+    }\n+\n+  return frame_count;\n+}\n+\n+/* This is equivalent to glibc's backtrace(). */\n+  \n+int\n+__ia64_backtrace (void **array, int size)\n+{\n+  ia64_frame_state my_frame;\n+  ia64_frame_state originator;\t/* For the context handler is in.  */\n+  void *bsp;\n+ \n+  /* Do any necessary initialization to access arbitrary stack frames.\n+     This forces gcc to save memory in our stack frame for saved\n+     registers. */\n+  __builtin_unwind_init ();\n+\n+label_ia64:\n+  bsp = __builtin_ia64_bsp ();\n+  \n+  return ia64_backtrace_helper (array, &&label_ia64, &my_frame, \n+\t\t\t\t&originator, bsp, size);\n+}\n+\n+\f\n+\n+#ifndef inhibit_libc\n+\n+#if 0\n+#undef NULL;\n+#include <stdio.h>\n+\n+/* Routines required to generate debug info for the ia64\n+   unwind descriptors.  */\n+\n+static unsigned char *record_name[] = { \n+  \"prologue\", \"prologue_gr\", \"body\", \"mem_stack_f\", \"mem_stack_v\", \"psp_gr\", \n+  \"psp_sprel\", \"rp_when\", \"rp_gr\", \"rp_br\", \"rp_psprel\", \"rp_sprel\", \n+  \"pfs_when\", \"pfs_gr\", \"pfs_psprel\", \"pfs_sprel\", \"preds_when\", \"preds_gr\", \n+  \"preds_psprel\", \"preds_sprel\", \"fr_mem\", \"frgr_mem\", \"gr_gr\", \"gr_mem\", \n+  \"br_mem\", \"br_gr\", \"spill_base\", \"spill_mask\", \"unat_when\", \"unat_gr\", \n+  \"unat_psprel\", \"unat_sprel\", \"lc_when\", \"lc_gr\", \"lc_psprel\", \"lc_sprel\", \n+  \"fpsr_when\", \"fpsr_gr\", \"fpsr_psprel\", \"fpsr_sprel\", \"priunat_when_gr\", \n+  \"priunat_when_mem\", \"priunat_gr\", \"priunat_psprel\", \"priunat_sprel\", \n+  \"bsp_when\", \"bsp_gr\", \"bsp_psprel\", \"bsp_sprel\", \"bspstore_when\", \n+  \"bspstore_gr\", \"bspstore_psprel\", \"bspstore_sprel\", \"rnat_when\", \"rnat_gr\", \n+  \"rnat_psprel\", \"rnat_sprel\", \"epilogue\", \"label_state\", \"copy_state\", \n+  \"spill_psprel\", \"spill_sprel\", \"spill_reg\", \"spill_psprel_p\", \n+  \"spill_sprel_p\",\"spill_reg_p\" \n+};\n+\n+\n+\n+static void\n+print_record (f, ptr)\n+     FILE *f;\n+     unwind_record *ptr;\n+{\n+  fprintf (f, \" %s \",record_name[ptr->type]);\n+  switch (ptr->type) \n+    {\n+      case prologue:\n+      case body:\n+\tfprintf (f, \"(R1) rlen = %d\", ptr->record.r.rlen);\n+\tbreak;\n+      case prologue_gr:\n+\tfprintf (f, \"(R2) rlen = %d : \", ptr->record.r.rlen);\n+\tfprintf (f, \"grmask = %x, grsave = r%d\", ptr->record.r.mask, \n+\t\t\t\t\t\t ptr->record.r.grsave);\n+\tbreak;\n+      case mem_stack_f:\n+      case mem_stack_v:\n+\tfprintf (f, \"(P7) t = %d, size = %d\", ptr->record.p.t, \n+\t\t\t\t\t ptr->record.p.size);\n+\tbreak;\n+      case psp_gr:\n+      case rp_gr:\n+      case pfs_gr:\n+      case preds_gr:\n+      case unat_gr:\n+      case lc_gr:\n+      case fpsr_gr:\n+      case priunat_gr:\n+      case bsp_gr:\n+      case bspstore_gr:\n+      case rnat_gr:\n+\tfprintf (f, \"(P3) r%d\", ptr->record.p.gr);\n+\tbreak;\n+      case rp_br:\n+\tfprintf (f, \"(P3) b%d\", ptr->record.p.br);\n+\tbreak;\n+      case psp_sprel:\n+\tfprintf (f, \"(P7) spoff = %d\", ptr->record.p.spoff);\n+\tbreak;\n+      case rp_when:\n+      case pfs_when:\n+      case preds_when:\n+      case unat_when:\n+      case lc_when:\n+      case fpsr_when:\n+\tfprintf (f, \"(P7) t = %d\", ptr->record.p.t);\n+\tbreak;\n+      case rp_psprel:\n+      case pfs_psprel:\n+      case preds_psprel:\n+      case unat_psprel:\n+      case lc_psprel:\n+      case fpsr_psprel:\n+      case spill_base:\n+\tfprintf (f, \"(P7) pspoff = %d\", ptr->record.p.pspoff, 0);\n+\tbreak;\n+      case rp_sprel:\n+      case pfs_sprel:\n+      case preds_sprel:\n+      case unat_sprel:\n+      case lc_sprel:\n+      case fpsr_sprel:\n+      case priunat_sprel:\n+      case bsp_sprel:\n+      case bspstore_sprel:\n+      case rnat_sprel:\n+\tfprintf (f, \"(P8) spoff = %d\", ptr->record.p.spoff);\n+\tbreak;\n+      case fr_mem:\n+      case gr_mem:\n+\tfprintf (f, \"(P6) rmask = %x\", ptr->record.p.rmask);\n+\tbreak;\n+      case frgr_mem:\n+\tfprintf (f, \"(P5) grmask = %x,  frmask = %x\", ptr->record.p.grmask, \n+\t\t\t\t\t\t ptr->record.p.frmask);\n+\tbreak;\n+      case gr_gr:\n+\tfprintf (f, \"(P9) grmask = %x  gr = r%d\\n\", ptr->record.p.grmask, \n+\t\t\t\t\t       ptr->record.p.gr);\n+\tbreak;\n+      case br_mem:\n+\tfprintf (f, \"(P1) brmask = %x\", ptr->record.p.brmask);\n+\tbreak;\n+      case br_gr:\n+\tfprintf (f, \"(P2) brmask = %x,  gr = r%d\", ptr->record.p.brmask, \n+\t\t\t\t\t      ptr->record.p.gr);\n+\tbreak;\n+      case spill_mask:\n+\tfprintf (f, \"spill mask....  unimplemented\");\n+\tbreak;\n+      case priunat_when_gr:\n+      case priunat_when_mem:\n+      case bsp_when:\n+      case bspstore_when:\n+      case rnat_when:\n+\tfprintf (f, \"(P8) t = %d\\n\", ptr->record.p.t);\n+\tbreak;\n+      case priunat_psprel:\n+      case bsp_psprel:\n+      case bspstore_psprel:\n+      case rnat_psprel:\n+\tfprintf (f, \"(P8) pspoff = %d\", ptr->record.p.pspoff);\n+\tbreak;\n+      case epilogue:\n+\tfprintf (f, \"epilogue record unimplemented.\");\n+\tbreak;\n+      case label_state:\n+\tfprintf (f, \"label_state record unimplemented.\");\n+\tbreak;\n+      case copy_state:\n+\tfprintf (f, \"copy_state record unimplemented.\");\n+\tbreak;\n+      case spill_psprel:\n+      case spill_sprel:\n+      case spill_reg:\n+      case spill_psprel_p:\n+      case spill_sprel_p:\n+      case spill_reg_p:\n+\tfprintf (f, \"spill_* record unimplemented.\");\n+\tbreak;\n+      default:\n+\tfprintf (f, \"record_type_not_valid\");\n+\tbreak;\n+    }\n+  fprintf (f, \"\\n\");\n+  \n+}\n+\n+static void\n+print_all_records (f, mem, size)\n+     FILE *f;\n+     unsigned char *mem;\n+     int size;\n+{\n+  unsigned char *end = mem + size;\n+  unwind_record r;\n+\n+  fprintf (f, \"UNWIND IMAGE:\\n\");\n+  while (mem < end) \n+    {\n+      mem = get_unwind_record (1, &r, mem);\n+      print_record (f, &r);\n+    }\n+  fprintf (f, \"--end unwind image--\\n\\n\");\n+}\n+#endif /* If 0 */\n+#endif /* inhibit_libc */"}, {"sha": "34c6b2bf5fd5ed3c711d3550892691097bfb9e0a", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -2606,6 +2606,8 @@ rtx_needs_barrier (x, flags, pred)\n           break;\n \tcase 20: /* mov = ar.bsp */\n           break;\n+\tcase 21: /* flushrs */\n+          break;\n \n \tdefault:\n \t  abort ();\n@@ -3329,6 +3331,12 @@ ia64_init_builtins ()\n \n   def_builtin (\"__sync_lock_release_di\", void_ftype_pdi, IA64_BUILTIN_LOCK_RELEASE_DI);\n \n+  def_builtin (\"__builtin_ia64_bsp\", build_function_type (ptr_type_node, endlink), IA64_BUILTIN_BSP);\n+\n+  def_builtin (\"__builtin_ia64_flushrs\", \n+\t       build_function_type (void_type_node, endlink), \n+\t       IA64_BUILTIN_FLUSHRS);\n+\n   /* Add all builtins that are operations on two args. */\n   for (i=0, d = bdesc_2argsi; i < sizeof(bdesc_2argsi) / sizeof *d; i++, d++)\n     def_builtin (d->name, si_ftype_psi_si, d->code);\n@@ -3743,6 +3751,19 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n       emit_insn (gen_movdi (op0, GEN_INT(0)));\n       return 0;\n \n+    case IA64_BUILTIN_BSP:\n+      {\n+\trtx reg = gen_reg_rtx (DImode);\n+\temit_insn (gen_bsp_value (reg));\n+\treturn reg;\n+      }\n+\n+    case IA64_BUILTIN_FLUSHRS:\n+      {\n+\temit_insn (gen_flushrs ());\n+\treturn 0;\n+      }\n+\n     default:\n       break;\n     }"}, {"sha": "cf8b6ead0dcae30518143891c133b62d13c86d49", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -2893,7 +2893,10 @@ enum ia64_builtins\n \n   IA64_BUILTIN_LOCK_TEST_AND_SET_DI,\n \n-  IA64_BUILTIN_LOCK_RELEASE_DI\n+  IA64_BUILTIN_LOCK_RELEASE_DI,\n+\n+  IA64_BUILTIN_BSP,\n+  IA64_BUILTIN_FLUSHRS\n };\n \n /* Codes for expand_compare_and_swap and expand_swap_and_compare. */"}, {"sha": "c7453c7ebd24bd6b7ed07d72786fdd80d1f6817c", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -48,6 +48,10 @@\n \n ;; ??? Add function unit scheduling info for Itanium (TM) processor.\n \n+;; ??? The explicit stop in the flushrs pattern is not ideal.  It\n+;; would be better if rtx_needs_barrier took care of this, but this is\n+;; something that can be fixed later.\n+\n ;; Unspec usage:\n ;;\n ;; unspec:\n@@ -66,6 +70,7 @@\n ;;\t18\tfetch_and_op\n ;;\t19\tfetchadd_acq\n ;;\t20\tbsp_value\n+;;\t21\tflushrs\n ;;\n ;; unspec_volatile:\n ;;\t0\talloc\n@@ -3243,6 +3248,12 @@\n    mov ar.rsc=r19\\;\"\n   [(set_attr \"type\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"flushrs\"\n+  [(unspec [(const_int 0)] 21)]\n+  \"\"\n+  \";; \\; flushrs\"\n+  [(set_attr \"type\" \"M\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::"}, {"sha": "057db84f2654885ae5a07068dd42201eee3af6a0", "filename": "gcc/config/ia64/t-ia64", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Ft-ia64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fconfig%2Fia64%2Ft-ia64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-ia64?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -39,3 +39,5 @@ crtendS.o: $(srcdir)/config/ia64/crtend.asm $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) -DSHARED -c -o crtendS.o -x assembler-with-cpp $(srcdir)/config/ia64/crtend.asm\n \n EXTRA_HEADERS = $(srcdir)/config/ia64/ia64intrin.h\n+LIB2ADDEH = $(srcdir)/config/ia64/frame-ia64.c\n+"}, {"sha": "627c32ffbf48c7d687cae20be1f8481e7d698828", "filename": "gcc/except.c", "status": "modified", "additions": 74, "deletions": 29, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -698,6 +698,7 @@ struct func_eh_entry\n   int range_number;   /* EH region number from EH NOTE insn's.  */\n   rtx rethrow_label;  /* Label for rethrow.  */\n   int rethrow_ref;    /* Is rethrow_label referenced?  */\n+  int emitted;        /* 1 if this entry has been emitted in assembly file.  */\n   struct handler_info *handlers;\n };\n \n@@ -739,7 +740,8 @@ new_eh_region_entry (note_eh_region, rethrow)\n   else\n     function_eh_regions[current_func_eh_entry].rethrow_label = rethrow;\n   function_eh_regions[current_func_eh_entry].handlers = NULL;\n-\n+  function_eh_regions[current_func_eh_entry].emitted = 0;\n+ \n   return current_func_eh_entry++;\n }\n \n@@ -2221,40 +2223,44 @@ output_exception_table_entry (file, n)\n   else\n     rethrow = NULL_RTX;\n \n+  if (function_eh_regions[index].emitted)\n+    return;\n+  function_eh_regions[index].emitted  = 1;\n+\n   for ( ; handler != NULL || rethrow != NULL_RTX; handler = handler->next)\n     {\n       /* rethrow label should indicate the LAST entry for a region */\n       if (rethrow != NULL_RTX && (handler == NULL || handler->next == NULL))\n         {\n           ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", n);\n-          assemble_label(buf);\n+          assemble_eh_label(buf);\n           rethrow = NULL_RTX;\n         }\n \n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHB\", n);\n       sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n-      assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+      assemble_eh_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHE\", n);\n       sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n-      assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+      assemble_eh_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n       \n       if (handler == NULL)\n-        assemble_integer (GEN_INT (0), POINTER_SIZE / BITS_PER_UNIT, 1);\n+        assemble_eh_integer (GEN_INT (0), POINTER_SIZE / BITS_PER_UNIT, 1);\n       else\n         {\n           ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", handler->handler_number);\n           sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n-          assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+          assemble_eh_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n         }\n \n       if (flag_new_exceptions)\n         {\n           if (handler == NULL || handler->type_info == NULL)\n-            assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+            assemble_eh_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n           else\n             if (handler->type_info == CATCH_ALL_TYPE)\n-              assemble_integer (GEN_INT (CATCH_ALL_TYPE), \n+              assemble_eh_integer (GEN_INT (CATCH_ALL_TYPE), \n                                              POINTER_SIZE / BITS_PER_UNIT, 1);\n             else\n               output_constant ((tree)(handler->type_info), \n@@ -2288,61 +2294,100 @@ set_exception_version_code (code)\n   version_code = code;\n }\n \n-\n+/* Free the EH table structures.  */\n void\n-output_exception_table ()\n+free_exception_table ()\n+{\n+  free (eh_table);\n+  clear_function_eh_region ();\n+}\n+  \n+/* Output the common content of an exception table.  */\n+void\n+output_exception_table_data ()\n {\n   int i;\n   char buf[256];\n   extern FILE *asm_out_file;\n \n-  if (! doing_eh (0) || ! eh_table)\n-    return;\n-\n-  exception_section ();\n-\n-  /* Beginning marker for table.  */\n-  assemble_align (GET_MODE_ALIGNMENT (ptr_mode));\n-  assemble_label (\"__EXCEPTION_TABLE__\");\n-\n   if (flag_new_exceptions)\n     {\n-      assemble_integer (GEN_INT (NEW_EH_RUNTIME), \n+      assemble_eh_integer (GEN_INT (NEW_EH_RUNTIME), \n                                         POINTER_SIZE / BITS_PER_UNIT, 1);\n-      assemble_integer (GEN_INT (language_code), 2 , 1); \n-      assemble_integer (GEN_INT (version_code), 2 , 1);\n+      assemble_eh_integer (GEN_INT (language_code), 2 , 1); \n+      assemble_eh_integer (GEN_INT (version_code), 2 , 1);\n \n       /* Add enough padding to make sure table aligns on a pointer boundry. */\n       i = GET_MODE_ALIGNMENT (ptr_mode) / BITS_PER_UNIT - 4;\n       for ( ; i < 0; i = i + GET_MODE_ALIGNMENT (ptr_mode) / BITS_PER_UNIT)\n         ;\n       if (i != 0)\n-        assemble_integer (const0_rtx, i , 1);\n+        assemble_eh_integer (const0_rtx, i , 1);\n \n       /* Generate the label for offset calculations on rethrows.  */\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", 0);\n-      assemble_label(buf);\n+      assemble_eh_label(buf);\n     }\n \n   for (i = 0; i < eh_table_size; ++i)\n     output_exception_table_entry (asm_out_file, eh_table[i]);\n \n-  free (eh_table);\n-  clear_function_eh_region ();\n+}\n+\n+/* Output an exception table for the entire compilation unit.  */\n+void\n+output_exception_table ()\n+{\n+  char buf[256];\n+  extern FILE *asm_out_file;\n+\n+  if (! doing_eh (0) || ! eh_table)\n+    return;\n+\n+  exception_section ();\n+\n+  /* Beginning marker for table.  */\n+  assemble_eh_align (GET_MODE_ALIGNMENT (ptr_mode));\n+  assemble_eh_label (\"__EXCEPTION_TABLE__\");\n+\n+  output_exception_table_data ();\n \n   /* Ending marker for table.  */\n   /* Generate the label for end of table. */\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", CODE_LABEL_NUMBER (final_rethrow));\n-  assemble_label(buf);\n-  assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+  assemble_eh_label(buf);\n+  assemble_eh_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n   /* For binary compatibility, the old __throw checked the second\n      position for a -1, so we should output at least 2 -1's */\n   if (! flag_new_exceptions)\n-    assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+    assemble_eh_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n   putc ('\\n', asm_out_file);\t\t/* blank line */\n }\n+\n+/* Used by the ia64 unwind format to output data for an individual \n+   function.  */\n+void\n+output_function_exception_table ()\n+{\n+  extern FILE *asm_out_file;\n+\n+  if (! doing_eh (0) || ! eh_table)\n+    return;\n+\n+#ifdef HANDLER_SECTION\n+  HANDLER_SECTION;\n+#endif\n+\n+  output_exception_table_data ();\n+\n+  /* Ending marker for table.  */\n+  assemble_eh_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+\n+  putc ('\\n', asm_out_file);           /* blank line */\n+}\n+\n \f\n /* Emit code to get EH context.\n    "}, {"sha": "c02507c8e37b4d6346084b8db0aac1e51fb38b99", "filename": "gcc/except.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -355,6 +355,15 @@ extern int exception_table_p\t\t\tPARAMS ((void));\n \n extern void output_exception_table\t\tPARAMS ((void));\n \n+/* Free the exception table.  */\n+\n+extern void free_exception_table\t\tPARAMS((void));\n+\n+/* Used by the ia64 unwind format to output data for an individual \n+   function.  */\n+\n+extern void output_function_exception_table\tPARAMS((void));\n+\n /* Given a return address in ADDR, determine the address we should use\n    to find the corresponding EH region.  */\n "}, {"sha": "9d1ca33dd2cec270f9e768d51ff445d5e49d1783", "filename": "gcc/final.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -1827,6 +1827,10 @@ final_end_function (first, file, optimize)\n \n   bb_func_label_num = -1;\t/* not in function, nuke label # */\n \n+#ifdef IA64_UNWIND_INFO\n+  output_function_exception_table ();\n+#endif\n+\n   /* If FUNCTION_EPILOGUE is not defined, then the function body\n      itself contains return instructions wherever needed.  */\n }\n@@ -2968,6 +2972,9 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tif (prescan > 0)\n \t  break;\n \n+#ifdef IA64_UNWIND_INFO\n+\tIA64_UNWIND_EMIT (asm_out_file, insn);\n+#endif\n \t/* Output assembler code from the template.  */\n \n \toutput_asm_insn (template, recog_data.operand);"}, {"sha": "fb2e9fb61599330ed2644eb55755fae4812293ad", "filename": "gcc/frame-dwarf2.c", "status": "added", "additions": 663, "deletions": 0, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fframe-dwarf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fframe-dwarf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe-dwarf2.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -0,0 +1,663 @@\n+/* Subroutines needed for unwinding DWARF 2 format stack frame info\n+   for exception handling.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Jason Merrill <jason@cygnus.com>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* It is incorrect to include config.h here, because this file is being\n+   compiled for the target, and hence definitions concerning only the host\n+   do not apply.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+\n+#include \"defaults.h\"\n+\n+#ifdef DWARF2_UNWIND_INFO\n+#include \"dwarf2.h\"\n+#include \"frame.h\"\n+#include \"gthr.h\"\n+\n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n+#else\n+static __gthread_mutex_t object_mutex;\n+#endif\n+\n+/* Don't use `fancy_abort' here even if config.h says to use it.  */\n+#ifdef abort\n+#undef abort\n+#endif\n+\n+/* Some types used by the DWARF 2 spec.  */\n+\n+typedef          int  sword __attribute__ ((mode (SI)));\n+typedef unsigned int  uword __attribute__ ((mode (SI)));\n+typedef unsigned int  uaddr __attribute__ ((mode (pointer)));\n+typedef          int  saddr __attribute__ ((mode (pointer)));\n+typedef unsigned char ubyte;\n+\n+/* Terminology:\n+   CIE - Common Information Element\n+   FDE - Frame Descriptor Element\n+\n+   There is one per function, and it describes where the function code\n+   is located, and what the register lifetimes and stack layout are\n+   within the function.\n+\n+   The data structures are defined in the DWARF specfication, although\n+   not in a very readable way (see LITERATURE).\n+\n+   Every time an exception is thrown, the code needs to locate the FDE\n+   for the current function, and starts to look for exception regions\n+   from that FDE. This works in a two-level search:\n+   a) in a linear search, find the shared image (i.e. DLL) containing\n+      the PC\n+   b) using the FDE table for that shared object, locate the FDE using\n+      binary search (which requires the sorting).  */   \n+\n+/* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,\n+   to distinguish it from a valid FDE.  FDEs are aligned to an addressing\n+   unit boundary, but the fields within are unaligned.  */\n+\n+struct dwarf_cie {\n+  uword length;\n+  sword CIE_id;\n+  ubyte version;\n+  char augmentation[0];\n+} __attribute__ ((packed, aligned (__alignof__ (void *))));\n+\n+/* The first few fields of an FDE.  */\n+\n+struct dwarf_fde {\n+  uword length;\n+  sword CIE_delta;\n+  void* pc_begin;\n+  uaddr pc_range;\n+} __attribute__ ((packed, aligned (__alignof__ (void *))));\n+\n+typedef struct dwarf_fde fde;\n+\n+/* Objects to be searched for frame unwind info.  */\n+\n+static struct object *objects;\n+\n+/* The information we care about from a CIE.  */\n+\n+struct cie_info {\n+  char *augmentation;\n+  void *eh_ptr;\n+  int code_align;\n+  int data_align;\n+  unsigned ra_regno;\n+};\n+\n+/* The current unwind state, plus a saved copy for DW_CFA_remember_state.  */\n+\n+struct frame_state_internal\n+{\n+  struct frame_state s;\n+  struct frame_state_internal *saved_state;\n+};\n+\f\n+/* This is undefined below if we need it to be an actual function.  */\n+#define init_object_mutex_once()\n+\n+#if __GTHREADS\n+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n+\n+/* Helper for init_object_mutex_once.  */\n+\n+static void\n+init_object_mutex (void)\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&object_mutex);\n+}\n+\n+/* Call this to arrange to initialize the object mutex.  */\n+\n+#undef init_object_mutex_once\n+static void\n+init_object_mutex_once (void)\n+{\n+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+  __gthread_once (&once, init_object_mutex);\n+}\n+\n+#endif /* __GTHREAD_MUTEX_INIT_FUNCTION */\n+#endif /* __GTHREADS */\n+\f  \n+/* Decode the unsigned LEB128 constant at BUF into the variable pointed to\n+   by R, and return the new value of BUF.  */\n+\n+static void *\n+decode_uleb128 (unsigned char *buf, unsigned *r)\n+{\n+  unsigned shift = 0;\n+  unsigned result = 0;\n+\n+  while (1)\n+    {\n+      unsigned byte = *buf++;\n+      result |= (byte & 0x7f) << shift;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+      shift += 7;\n+    }\n+  *r = result;\n+  return buf;\n+}\n+\n+/* Decode the signed LEB128 constant at BUF into the variable pointed to\n+   by R, and return the new value of BUF.  */\n+\n+static void *\n+decode_sleb128 (unsigned char *buf, int *r)\n+{\n+  unsigned shift = 0;\n+  unsigned result = 0;\n+  unsigned byte;\n+\n+  while (1)\n+    {\n+      byte = *buf++;\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+    }\n+  if (shift < (sizeof (*r) * 8) && (byte & 0x40) != 0)\n+    result |= - (1 << shift);\n+\n+  *r = result;\n+  return buf;\n+}\n+\n+/* Read unaligned data from the instruction buffer.  */\n+\n+union unaligned {\n+  void *p;\n+  unsigned b2 __attribute__ ((mode (HI)));\n+  unsigned b4 __attribute__ ((mode (SI)));\n+  unsigned b8 __attribute__ ((mode (DI)));\n+} __attribute__ ((packed));\n+static inline void *\n+read_pointer (void *p)\n+{ union unaligned *up = p; return up->p; }\n+static inline unsigned\n+read_1byte (void *p)\n+{ return *(unsigned char *)p; }\n+static inline unsigned\n+read_2byte (void *p)\n+{ union unaligned *up = p; return up->b2; }\n+static inline unsigned\n+read_4byte (void *p)\n+{ union unaligned *up = p; return up->b4; }\n+static inline unsigned long\n+read_8byte (void *p)\n+{ union unaligned *up = p; return up->b8; }\n+\f\n+/* Ordering function for FDEs.  Functions can't overlap, so we just compare\n+   their starting addresses.  */\n+\n+static inline saddr\n+fde_compare (fde *x, fde *y)\n+{\n+  return (saddr)x->pc_begin - (saddr)y->pc_begin;\n+}\n+\n+/* Return the address of the FDE after P.  */\n+\n+static inline fde *\n+next_fde (fde *p)\n+{\n+  return (fde *)(((char *)p) + p->length + sizeof (p->length));\n+}\n+\n+#include \"frame.c\"\n+\n+static size_t\n+count_fdes (fde *this_fde)\n+{\n+  size_t count;\n+\n+  for (count = 0; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      /* Skip CIEs and linked once FDE entries.  */\n+      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n+\tcontinue;\n+\n+      ++count;\n+    }\n+\n+  return count;\n+}\n+\n+static void\n+add_fdes (fde *this_fde, fde_accumulator *accu, void **beg_ptr, void **end_ptr)\n+{\n+  void *pc_begin = *beg_ptr;\n+  void *pc_end = *end_ptr;\n+\n+  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      /* Skip CIEs and linked once FDE entries.  */\n+      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n+\tcontinue;\n+\n+      fde_insert (accu, this_fde);\n+\n+      if (this_fde->pc_begin < pc_begin)\n+\tpc_begin = this_fde->pc_begin;\n+      if (this_fde->pc_begin + this_fde->pc_range > pc_end)\n+\tpc_end = this_fde->pc_begin + this_fde->pc_range;\n+    }\n+\n+  *beg_ptr = pc_begin;\n+  *end_ptr = pc_end;\n+}\n+\n+/* search this fde table for the one containing the pc */\n+static fde *\n+search_fdes (fde *this_fde, void *pc)\n+{\n+  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      /* Skip CIEs and linked once FDE entries.  */\n+      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n+\tcontinue;\n+\n+      if ((uaddr)((char *)pc - (char *)this_fde->pc_begin) < this_fde->pc_range)\n+\treturn this_fde;\n+    }\n+  return NULL;\n+}\n+\n+/* Set up a sorted array of pointers to FDEs for a loaded object.  We\n+   count up the entries before allocating the array because it's likely to\n+   be faster.  We can be called multiple times, should we have failed to\n+   allocate a sorted fde array on a previous occasion.  */\n+\n+static void\n+frame_init (struct object* ob)\n+{\n+  size_t count;\n+  fde_accumulator accu;\n+  void *pc_begin, *pc_end;\n+  fde **array;\n+\n+  if (ob->pc_begin)\n+    count = ob->count;\n+  else if (ob->fde_array)\n+    {\n+      fde **p = ob->fde_array;\n+      for (count = 0; *p; ++p)\n+\tcount += count_fdes (*p);\n+    }\n+  else\n+    count = count_fdes (ob->fde_begin);\n+  ob->count = count;\n+\n+  if (!start_fde_sort (&accu, count) && ob->pc_begin)\n+    return;\n+\n+  pc_begin = (void*)(uaddr)-1;\n+  pc_end = 0;\n+\n+  if (ob->fde_array)\n+    {\n+      fde **p = ob->fde_array;\n+      for (; *p; ++p)\n+\tadd_fdes (*p, &accu, &pc_begin, &pc_end);\n+    }\n+  else\n+    add_fdes (ob->fde_begin, &accu, &pc_begin, &pc_end);\n+\n+  array = end_fde_sort (&accu, count);\n+  if (array)\n+    ob->fde_array = array;\n+  ob->pc_begin = pc_begin;\n+  ob->pc_end = pc_end;\n+}\n+\n+/* Return a pointer to the FDE for the function containing PC.  */\n+\n+static fde *\n+find_fde (void *pc)\n+{\n+  struct object *ob;\n+  size_t lo, hi;\n+\n+  init_object_mutex_once ();\n+  __gthread_mutex_lock (&object_mutex);\n+\n+  /* Linear search through the objects, to find the one containing the pc. */\n+  for (ob = objects; ob; ob = ob->next)\n+    {\n+      if (ob->pc_begin == 0)\n+\tframe_init (ob);\n+      if (pc >= ob->pc_begin && pc < ob->pc_end)\n+\tbreak;\n+    }\n+\n+  if (ob == 0)\n+    {\n+      __gthread_mutex_unlock (&object_mutex);\n+      return 0;\n+    }\n+\n+  if (!ob->fde_array || (void *)ob->fde_array == (void *)ob->fde_begin)\n+    frame_init (ob);\n+\n+  if (ob->fde_array && (void *)ob->fde_array != (void *)ob->fde_begin)\n+    {\n+      __gthread_mutex_unlock (&object_mutex);\n+      \n+      /* Standard binary search algorithm.  */\n+      for (lo = 0, hi = ob->count; lo < hi; )\n+\t{\n+\t  size_t i = (lo + hi) / 2;\n+\t  fde *f = ob->fde_array[i];\n+\n+\t  if (pc < f->pc_begin)\n+\t    hi = i;\n+\t  else if (pc >= f->pc_begin + f->pc_range)\n+\t    lo = i + 1;\n+\t  else\n+\t    return f;\n+\t}\n+    }\n+  else\n+    {\n+      /* Long slow labourious linear search, cos we've no memory. */\n+      fde *f;\n+      \n+      if (ob->fde_array)\n+\t{\n+\t  fde **p = ob->fde_array;\n+\t  \n+\t  do\n+\t    {\n+\t      f = search_fdes (*p, pc);\n+\t      if (f)\n+\t\tbreak;\n+\t      p++;\n+\t    }\n+\t  while (*p);\n+\t}\n+      else\n+\tf = search_fdes (ob->fde_begin, pc);\n+      __gthread_mutex_unlock (&object_mutex);\n+      return f;\n+    }\n+  return 0;\n+}\n+\f\n+static inline struct dwarf_cie *\n+get_cie (fde *f)\n+{\n+  return ((void *)&f->CIE_delta) - f->CIE_delta;\n+}\n+\n+/* Extract any interesting information from the CIE for the translation\n+   unit F belongs to.  */\n+\n+static void *\n+extract_cie_info (fde *f, struct cie_info *c)\n+{\n+  void *p;\n+  int i;\n+\n+  c->augmentation = get_cie (f)->augmentation;\n+\n+  if (strcmp (c->augmentation, \"\") != 0\n+      && strcmp (c->augmentation, \"eh\") != 0\n+      && c->augmentation[0] != 'z')\n+    return 0;\n+\n+  p = c->augmentation + strlen (c->augmentation) + 1;\n+\n+  if (strcmp (c->augmentation, \"eh\") == 0)\n+    {\n+      c->eh_ptr = read_pointer (p);\n+      p += sizeof (void *);\n+    }\n+  else\n+    c->eh_ptr = 0;\n+\n+  p = decode_uleb128 (p, &c->code_align);\n+  p = decode_sleb128 (p, &c->data_align);\n+  c->ra_regno = *(unsigned char *)p++;\n+\n+  /* If the augmentation starts with 'z', we now see the length of the\n+     augmentation fields.  */\n+  if (c->augmentation[0] == 'z')\n+    {\n+      p = decode_uleb128 (p, &i);\n+      p += i;\n+    }\n+\n+  return p;\n+}\n+\n+/* Decode one instruction's worth of DWARF 2 call frame information.\n+   Used by __frame_state_for.  Takes pointers P to the instruction to\n+   decode, STATE to the current register unwind information, INFO to the\n+   current CIE information, and PC to the current PC value.  Returns a\n+   pointer to the next instruction.  */\n+\n+static void *\n+execute_cfa_insn (void *p, struct frame_state_internal *state,\n+\t\t  struct cie_info *info, void **pc)\n+{\n+  unsigned insn = *(unsigned char *)p++;\n+  unsigned reg;\n+  int offset;\n+\n+  if (insn & DW_CFA_advance_loc)\n+    *pc += ((insn & 0x3f) * info->code_align);\n+  else if (insn & DW_CFA_offset)\n+    {\n+      reg = (insn & 0x3f);\n+      p = decode_uleb128 (p, &offset);\n+      if (reg == state->s.cfa_reg)\n+\t/* Don't record anything about this register; it's only used to\n+\t   reload SP in the epilogue.  We don't want to copy in SP\n+\t   values for outer frames; we handle restoring SP specially.  */;\n+      else\n+\t{\n+\t  offset *= info->data_align;\n+\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n+\t  state->s.reg_or_offset[reg] = offset;\n+\t}\n+    }\n+  else if (insn & DW_CFA_restore)\n+    {\n+      reg = (insn & 0x3f);\n+      state->s.saved[reg] = REG_UNSAVED;\n+    }\n+  else switch (insn)\n+    {\n+    case DW_CFA_set_loc:\n+      *pc = read_pointer (p);\n+      p += sizeof (void *);\n+      break;\n+    case DW_CFA_advance_loc1:\n+      *pc += read_1byte (p);\n+      p += 1;\n+      break;\n+    case DW_CFA_advance_loc2:\n+      *pc += read_2byte (p);\n+      p += 2;\n+      break;\n+    case DW_CFA_advance_loc4:\n+      *pc += read_4byte (p);\n+      p += 4;\n+      break;\n+\n+    case DW_CFA_offset_extended:\n+      p = decode_uleb128 (p, &reg);\n+      p = decode_uleb128 (p, &offset);\n+      if (reg == state->s.cfa_reg)\n+\t/* Don't record anything; see above.  */;\n+      else\n+\t{\n+\t  offset *= info->data_align;\n+\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n+\t  state->s.reg_or_offset[reg] = offset;\n+\t}\n+      break;\n+    case DW_CFA_restore_extended:\n+      p = decode_uleb128 (p, &reg);\n+      state->s.saved[reg] = REG_UNSAVED;\n+      break;\n+\n+    case DW_CFA_undefined:\n+    case DW_CFA_same_value:\n+    case DW_CFA_nop:\n+      break;\n+\n+    case DW_CFA_register:\n+      {\n+\tunsigned reg2;\n+\tp = decode_uleb128 (p, &reg);\n+\tp = decode_uleb128 (p, &reg2);\n+\tstate->s.saved[reg] = REG_SAVED_REG;\n+\tstate->s.reg_or_offset[reg] = reg2;\n+      }\n+      break;\n+\n+    case DW_CFA_def_cfa:\n+      p = decode_uleb128 (p, &reg);\n+      p = decode_uleb128 (p, &offset);\n+      state->s.cfa_reg = reg;\n+      state->s.cfa_offset = offset;\n+      break;\n+    case DW_CFA_def_cfa_register:\n+      p = decode_uleb128 (p, &reg);\n+      state->s.cfa_reg = reg;\n+      break;\n+    case DW_CFA_def_cfa_offset:\n+      p = decode_uleb128 (p, &offset);\n+      state->s.cfa_offset = offset;\n+      break;\n+      \n+    case DW_CFA_remember_state:\n+      {\n+\tstruct frame_state_internal *save =\n+\t  (struct frame_state_internal *)\n+\t  malloc (sizeof (struct frame_state_internal));\n+\tmemcpy (save, state, sizeof (struct frame_state_internal));\n+\tstate->saved_state = save;\n+      }\n+      break;\n+    case DW_CFA_restore_state:\n+      {\n+\tstruct frame_state_internal *save = state->saved_state;\n+\tmemcpy (state, save, sizeof (struct frame_state_internal));\n+\tfree (save);\n+      }\n+      break;\n+\n+      /* FIXME: Hardcoded for SPARC register window configuration.  */\n+    case DW_CFA_GNU_window_save:\n+      for (reg = 16; reg < 32; ++reg)\n+\t{\n+\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n+\t  state->s.reg_or_offset[reg] = (reg - 16) * sizeof (void *);\n+\t}\n+      break;\n+\n+    case DW_CFA_GNU_args_size:\n+      p = decode_uleb128 (p, &offset);\n+      state->s.args_size = offset;\n+      break;\n+\n+    case DW_CFA_GNU_negative_offset_extended:\n+      p = decode_uleb128 (p, &reg);\n+      p = decode_uleb128 (p, &offset);\n+      offset *= info->data_align;\n+      state->s.saved[reg] = REG_SAVED_OFFSET;\n+      state->s.reg_or_offset[reg] = -offset;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+  return p;\n+}\n+\f\n+/* Called from __throw to find the registers to restore for a given\n+   PC_TARGET.  The caller should allocate a local variable of `struct\n+   frame_state' (declared in frame.h) and pass its address to STATE_IN.  */\n+\n+struct frame_state *\n+__frame_state_for (void *pc_target, struct frame_state *state_in)\n+{\n+  fde *f;\n+  void *insn, *end, *pc;\n+  struct cie_info info;\n+  struct frame_state_internal state;\n+\n+  f = find_fde (pc_target);\n+  if (f == 0)\n+    return 0;\n+\n+  insn = extract_cie_info (f, &info);\n+  if (insn == 0)\n+    return 0;\n+\n+  memset (&state, 0, sizeof (state));\n+  state.s.retaddr_column = info.ra_regno;\n+  state.s.eh_ptr = info.eh_ptr;\n+\n+  /* First decode all the insns in the CIE.  */\n+  end = next_fde ((fde*) get_cie (f));\n+  while (insn < end)\n+    insn = execute_cfa_insn (insn, &state, &info, 0);\n+\n+  insn = ((fde *)f) + 1;\n+\n+  if (info.augmentation[0] == 'z')\n+    {\n+      int i;\n+      insn = decode_uleb128 (insn, &i);\n+      insn += i;\n+    }\n+\n+  /* Then the insns in the FDE up to our target PC.  */\n+  end = next_fde (f);\n+  pc = f->pc_begin;\n+  while (insn < end && pc <= pc_target)\n+    insn = execute_cfa_insn (insn, &state, &info, &pc);\n+\n+  memcpy (state_in, &state.s, sizeof (state.s));\n+  return state_in;\n+}\n+#endif /* DWARF2_UNWIND_INFO */"}, {"sha": "e1448e315f0ade65690332fbf0dc177459e6626d", "filename": "gcc/frame.c", "status": "modified", "additions": 0, "deletions": 629, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fframe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fframe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -29,216 +29,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* It is incorrect to include config.h here, because this file is being\n-   compiled for the target, and hence definitions concerning only the host\n-   do not apply.  */\n-\n-#include \"tconfig.h\"\n-#include \"tsystem.h\"\n-\n-#include \"defaults.h\"\n-\n-#ifdef DWARF2_UNWIND_INFO\n-#include \"dwarf2.h\"\n-#include \"frame.h\"\n-#include \"gthr.h\"\n-\n-#ifdef __GTHREAD_MUTEX_INIT\n-static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n-#else\n-static __gthread_mutex_t object_mutex;\n-#endif\n-\n-/* Don't use `fancy_abort' here even if config.h says to use it.  */\n-#ifdef abort\n-#undef abort\n-#endif\n-\n-/* Some types used by the DWARF 2 spec.  */\n-\n-typedef          int  sword __attribute__ ((mode (SI)));\n-typedef unsigned int  uword __attribute__ ((mode (SI)));\n-typedef unsigned int  uaddr __attribute__ ((mode (pointer)));\n-typedef          int  saddr __attribute__ ((mode (pointer)));\n-typedef unsigned char ubyte;\n-\n-/* Terminology:\n-   CIE - Common Information Element\n-   FDE - Frame Descriptor Element\n-\n-   There is one per function, and it describes where the function code\n-   is located, and what the register lifetimes and stack layout are\n-   within the function.\n-\n-   The data structures are defined in the DWARF specfication, although\n-   not in a very readable way (see LITERATURE).\n-\n-   Every time an exception is thrown, the code needs to locate the FDE\n-   for the current function, and starts to look for exception regions\n-   from that FDE. This works in a two-level search:\n-   a) in a linear search, find the shared image (i.e. DLL) containing\n-      the PC\n-   b) using the FDE table for that shared object, locate the FDE using\n-      binary search (which requires the sorting).  */   \n-\n-/* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,\n-   to distinguish it from a valid FDE.  FDEs are aligned to an addressing\n-   unit boundary, but the fields within are unaligned.  */\n-\n-struct dwarf_cie {\n-  uword length;\n-  sword CIE_id;\n-  ubyte version;\n-  char augmentation[0];\n-} __attribute__ ((packed, aligned (__alignof__ (void *))));\n-\n-/* The first few fields of an FDE.  */\n-\n-struct dwarf_fde {\n-  uword length;\n-  sword CIE_delta;\n-  void* pc_begin;\n-  uaddr pc_range;\n-} __attribute__ ((packed, aligned (__alignof__ (void *))));\n-\n-typedef struct dwarf_fde fde;\n-\n-/* Objects to be searched for frame unwind info.  */\n-\n-static struct object *objects;\n-\n-/* The information we care about from a CIE.  */\n-\n-struct cie_info {\n-  char *augmentation;\n-  void *eh_ptr;\n-  int code_align;\n-  int data_align;\n-  unsigned ra_regno;\n-};\n-\n-/* The current unwind state, plus a saved copy for DW_CFA_remember_state.  */\n-\n-struct frame_state_internal\n-{\n-  struct frame_state s;\n-  struct frame_state_internal *saved_state;\n-};\n-\f\n-/* This is undefined below if we need it to be an actual function.  */\n-#define init_object_mutex_once()\n-\n-#if __GTHREADS\n-#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n-\n-/* Helper for init_object_mutex_once.  */\n-\n-static void\n-init_object_mutex (void)\n-{\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&object_mutex);\n-}\n-\n-/* Call this to arrange to initialize the object mutex.  */\n-\n-#undef init_object_mutex_once\n-static void\n-init_object_mutex_once (void)\n-{\n-  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n-  __gthread_once (&once, init_object_mutex);\n-}\n-\n-#endif /* __GTHREAD_MUTEX_INIT_FUNCTION */\n-#endif /* __GTHREADS */\n-\f  \n-/* Decode the unsigned LEB128 constant at BUF into the variable pointed to\n-   by R, and return the new value of BUF.  */\n-\n-static void *\n-decode_uleb128 (unsigned char *buf, unsigned *r)\n-{\n-  unsigned shift = 0;\n-  unsigned result = 0;\n-\n-  while (1)\n-    {\n-      unsigned byte = *buf++;\n-      result |= (byte & 0x7f) << shift;\n-      if ((byte & 0x80) == 0)\n-\tbreak;\n-      shift += 7;\n-    }\n-  *r = result;\n-  return buf;\n-}\n-\n-/* Decode the signed LEB128 constant at BUF into the variable pointed to\n-   by R, and return the new value of BUF.  */\n-\n-static void *\n-decode_sleb128 (unsigned char *buf, int *r)\n-{\n-  unsigned shift = 0;\n-  unsigned result = 0;\n-  unsigned byte;\n-\n-  while (1)\n-    {\n-      byte = *buf++;\n-      result |= (byte & 0x7f) << shift;\n-      shift += 7;\n-      if ((byte & 0x80) == 0)\n-\tbreak;\n-    }\n-  if (shift < (sizeof (*r) * 8) && (byte & 0x40) != 0)\n-    result |= - (1 << shift);\n-\n-  *r = result;\n-  return buf;\n-}\n-\n-/* Read unaligned data from the instruction buffer.  */\n-\n-union unaligned {\n-  void *p;\n-  unsigned b2 __attribute__ ((mode (HI)));\n-  unsigned b4 __attribute__ ((mode (SI)));\n-  unsigned b8 __attribute__ ((mode (DI)));\n-} __attribute__ ((packed));\n-static inline void *\n-read_pointer (void *p)\n-{ union unaligned *up = p; return up->p; }\n-static inline unsigned\n-read_1byte (void *p)\n-{ return *(unsigned char *)p; }\n-static inline unsigned\n-read_2byte (void *p)\n-{ union unaligned *up = p; return up->b2; }\n-static inline unsigned\n-read_4byte (void *p)\n-{ union unaligned *up = p; return up->b4; }\n-static inline unsigned long\n-read_8byte (void *p)\n-{ union unaligned *up = p; return up->b8; }\n-\f\n-/* Ordering function for FDEs.  Functions can't overlap, so we just compare\n-   their starting addresses.  */\n-\n-static inline saddr\n-fde_compare (fde *x, fde *y)\n-{\n-  return (saddr)x->pc_begin - (saddr)y->pc_begin;\n-}\n-\n-/* Return the address of the FDE after P.  */\n-\n-static inline fde *\n-next_fde (fde *p)\n-{\n-  return (fde *)(((char *)p) + p->length + sizeof (p->length));\n-}\n-\n /* Sorting an array of FDEs by address.\n    (Ideally we would have the linker sort the FDEs so we don't have to do\n    it at run time. But the linkers are not yet prepared for this.)  */\n@@ -452,377 +242,6 @@ end_fde_sort (fde_accumulator *accu, size_t count)\n   return accu->linear.array;\n }\n \n-static size_t\n-count_fdes (fde *this_fde)\n-{\n-  size_t count;\n-\n-  for (count = 0; this_fde->length != 0; this_fde = next_fde (this_fde))\n-    {\n-      /* Skip CIEs and linked once FDE entries.  */\n-      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n-\tcontinue;\n-\n-      ++count;\n-    }\n-\n-  return count;\n-}\n-\n-static void\n-add_fdes (fde *this_fde, fde_accumulator *accu, void **beg_ptr, void **end_ptr)\n-{\n-  void *pc_begin = *beg_ptr;\n-  void *pc_end = *end_ptr;\n-\n-  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n-    {\n-      /* Skip CIEs and linked once FDE entries.  */\n-      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n-\tcontinue;\n-\n-      fde_insert (accu, this_fde);\n-\n-      if (this_fde->pc_begin < pc_begin)\n-\tpc_begin = this_fde->pc_begin;\n-      if (this_fde->pc_begin + this_fde->pc_range > pc_end)\n-\tpc_end = this_fde->pc_begin + this_fde->pc_range;\n-    }\n-\n-  *beg_ptr = pc_begin;\n-  *end_ptr = pc_end;\n-}\n-\n-/* search this fde table for the one containing the pc */\n-static fde *\n-search_fdes (fde *this_fde, void *pc)\n-{\n-  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n-    {\n-      /* Skip CIEs and linked once FDE entries.  */\n-      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n-\tcontinue;\n-\n-      if ((uaddr)((char *)pc - (char *)this_fde->pc_begin) < this_fde->pc_range)\n-\treturn this_fde;\n-    }\n-  return NULL;\n-}\n-\n-/* Set up a sorted array of pointers to FDEs for a loaded object.  We\n-   count up the entries before allocating the array because it's likely to\n-   be faster.  We can be called multiple times, should we have failed to\n-   allocate a sorted fde array on a previous occasion.  */\n-\n-static void\n-frame_init (struct object* ob)\n-{\n-  size_t count;\n-  fde_accumulator accu;\n-  void *pc_begin, *pc_end;\n-  fde **array;\n-\n-  if (ob->pc_begin)\n-    count = ob->count;\n-  else if (ob->fde_array)\n-    {\n-      fde **p = ob->fde_array;\n-      for (count = 0; *p; ++p)\n-\tcount += count_fdes (*p);\n-    }\n-  else\n-    count = count_fdes (ob->fde_begin);\n-  ob->count = count;\n-\n-  if (!start_fde_sort (&accu, count) && ob->pc_begin)\n-    return;\n-\n-  pc_begin = (void*)(uaddr)-1;\n-  pc_end = 0;\n-\n-  if (ob->fde_array)\n-    {\n-      fde **p = ob->fde_array;\n-      for (; *p; ++p)\n-\tadd_fdes (*p, &accu, &pc_begin, &pc_end);\n-    }\n-  else\n-    add_fdes (ob->fde_begin, &accu, &pc_begin, &pc_end);\n-\n-  array = end_fde_sort (&accu, count);\n-  if (array)\n-    ob->fde_array = array;\n-  ob->pc_begin = pc_begin;\n-  ob->pc_end = pc_end;\n-}\n-\n-/* Return a pointer to the FDE for the function containing PC.  */\n-\n-static fde *\n-find_fde (void *pc)\n-{\n-  struct object *ob;\n-  size_t lo, hi;\n-\n-  init_object_mutex_once ();\n-  __gthread_mutex_lock (&object_mutex);\n-\n-  /* Linear search through the objects, to find the one containing the pc. */\n-  for (ob = objects; ob; ob = ob->next)\n-    {\n-      if (ob->pc_begin == 0)\n-\tframe_init (ob);\n-      if (pc >= ob->pc_begin && pc < ob->pc_end)\n-\tbreak;\n-    }\n-\n-  if (ob == 0)\n-    {\n-      __gthread_mutex_unlock (&object_mutex);\n-      return 0;\n-    }\n-\n-  if (!ob->fde_array || (void *)ob->fde_array == (void *)ob->fde_begin)\n-    frame_init (ob);\n-\n-  if (ob->fde_array && (void *)ob->fde_array != (void *)ob->fde_begin)\n-    {\n-      __gthread_mutex_unlock (&object_mutex);\n-      \n-      /* Standard binary search algorithm.  */\n-      for (lo = 0, hi = ob->count; lo < hi; )\n-\t{\n-\t  size_t i = (lo + hi) / 2;\n-\t  fde *f = ob->fde_array[i];\n-\n-\t  if (pc < f->pc_begin)\n-\t    hi = i;\n-\t  else if (pc >= f->pc_begin + f->pc_range)\n-\t    lo = i + 1;\n-\t  else\n-\t    return f;\n-\t}\n-    }\n-  else\n-    {\n-      /* Long slow labourious linear search, cos we've no memory. */\n-      fde *f;\n-      \n-      if (ob->fde_array)\n-\t{\n-\t  fde **p = ob->fde_array;\n-\t  \n-\t  do\n-\t    {\n-\t      f = search_fdes (*p, pc);\n-\t      if (f)\n-\t\tbreak;\n-\t      p++;\n-\t    }\n-\t  while (*p);\n-\t}\n-      else\n-\tf = search_fdes (ob->fde_begin, pc);\n-      __gthread_mutex_unlock (&object_mutex);\n-      return f;\n-    }\n-  return 0;\n-}\n-\f\n-static inline struct dwarf_cie *\n-get_cie (fde *f)\n-{\n-  return ((void *)&f->CIE_delta) - f->CIE_delta;\n-}\n-\n-/* Extract any interesting information from the CIE for the translation\n-   unit F belongs to.  */\n-\n-static void *\n-extract_cie_info (fde *f, struct cie_info *c)\n-{\n-  void *p;\n-  int i;\n-\n-  c->augmentation = get_cie (f)->augmentation;\n-\n-  if (strcmp (c->augmentation, \"\") != 0\n-      && strcmp (c->augmentation, \"eh\") != 0\n-      && c->augmentation[0] != 'z')\n-    return 0;\n-\n-  p = c->augmentation + strlen (c->augmentation) + 1;\n-\n-  if (strcmp (c->augmentation, \"eh\") == 0)\n-    {\n-      c->eh_ptr = read_pointer (p);\n-      p += sizeof (void *);\n-    }\n-  else\n-    c->eh_ptr = 0;\n-\n-  p = decode_uleb128 (p, &c->code_align);\n-  p = decode_sleb128 (p, &c->data_align);\n-  c->ra_regno = *(unsigned char *)p++;\n-\n-  /* If the augmentation starts with 'z', we now see the length of the\n-     augmentation fields.  */\n-  if (c->augmentation[0] == 'z')\n-    {\n-      p = decode_uleb128 (p, &i);\n-      p += i;\n-    }\n-\n-  return p;\n-}\n-\n-/* Decode one instruction's worth of DWARF 2 call frame information.\n-   Used by __frame_state_for.  Takes pointers P to the instruction to\n-   decode, STATE to the current register unwind information, INFO to the\n-   current CIE information, and PC to the current PC value.  Returns a\n-   pointer to the next instruction.  */\n-\n-static void *\n-execute_cfa_insn (void *p, struct frame_state_internal *state,\n-\t\t  struct cie_info *info, void **pc)\n-{\n-  unsigned insn = *(unsigned char *)p++;\n-  unsigned reg;\n-  int offset;\n-\n-  if (insn & DW_CFA_advance_loc)\n-    *pc += ((insn & 0x3f) * info->code_align);\n-  else if (insn & DW_CFA_offset)\n-    {\n-      reg = (insn & 0x3f);\n-      p = decode_uleb128 (p, &offset);\n-      if (reg == state->s.cfa_reg)\n-\t/* Don't record anything about this register; it's only used to\n-\t   reload SP in the epilogue.  We don't want to copy in SP\n-\t   values for outer frames; we handle restoring SP specially.  */;\n-      else\n-\t{\n-\t  offset *= info->data_align;\n-\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n-\t  state->s.reg_or_offset[reg] = offset;\n-\t}\n-    }\n-  else if (insn & DW_CFA_restore)\n-    {\n-      reg = (insn & 0x3f);\n-      state->s.saved[reg] = REG_UNSAVED;\n-    }\n-  else switch (insn)\n-    {\n-    case DW_CFA_set_loc:\n-      *pc = read_pointer (p);\n-      p += sizeof (void *);\n-      break;\n-    case DW_CFA_advance_loc1:\n-      *pc += read_1byte (p);\n-      p += 1;\n-      break;\n-    case DW_CFA_advance_loc2:\n-      *pc += read_2byte (p);\n-      p += 2;\n-      break;\n-    case DW_CFA_advance_loc4:\n-      *pc += read_4byte (p);\n-      p += 4;\n-      break;\n-\n-    case DW_CFA_offset_extended:\n-      p = decode_uleb128 (p, &reg);\n-      p = decode_uleb128 (p, &offset);\n-      if (reg == state->s.cfa_reg)\n-\t/* Don't record anything; see above.  */;\n-      else\n-\t{\n-\t  offset *= info->data_align;\n-\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n-\t  state->s.reg_or_offset[reg] = offset;\n-\t}\n-      break;\n-    case DW_CFA_restore_extended:\n-      p = decode_uleb128 (p, &reg);\n-      state->s.saved[reg] = REG_UNSAVED;\n-      break;\n-\n-    case DW_CFA_undefined:\n-    case DW_CFA_same_value:\n-    case DW_CFA_nop:\n-      break;\n-\n-    case DW_CFA_register:\n-      {\n-\tunsigned reg2;\n-\tp = decode_uleb128 (p, &reg);\n-\tp = decode_uleb128 (p, &reg2);\n-\tstate->s.saved[reg] = REG_SAVED_REG;\n-\tstate->s.reg_or_offset[reg] = reg2;\n-      }\n-      break;\n-\n-    case DW_CFA_def_cfa:\n-      p = decode_uleb128 (p, &reg);\n-      p = decode_uleb128 (p, &offset);\n-      state->s.cfa_reg = reg;\n-      state->s.cfa_offset = offset;\n-      break;\n-    case DW_CFA_def_cfa_register:\n-      p = decode_uleb128 (p, &reg);\n-      state->s.cfa_reg = reg;\n-      break;\n-    case DW_CFA_def_cfa_offset:\n-      p = decode_uleb128 (p, &offset);\n-      state->s.cfa_offset = offset;\n-      break;\n-      \n-    case DW_CFA_remember_state:\n-      {\n-\tstruct frame_state_internal *save =\n-\t  (struct frame_state_internal *)\n-\t  malloc (sizeof (struct frame_state_internal));\n-\tmemcpy (save, state, sizeof (struct frame_state_internal));\n-\tstate->saved_state = save;\n-      }\n-      break;\n-    case DW_CFA_restore_state:\n-      {\n-\tstruct frame_state_internal *save = state->saved_state;\n-\tmemcpy (state, save, sizeof (struct frame_state_internal));\n-\tfree (save);\n-      }\n-      break;\n-\n-      /* FIXME: Hardcoded for SPARC register window configuration.  */\n-    case DW_CFA_GNU_window_save:\n-      for (reg = 16; reg < 32; ++reg)\n-\t{\n-\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n-\t  state->s.reg_or_offset[reg] = (reg - 16) * sizeof (void *);\n-\t}\n-      break;\n-\n-    case DW_CFA_GNU_args_size:\n-      p = decode_uleb128 (p, &offset);\n-      state->s.args_size = offset;\n-      break;\n-\n-    case DW_CFA_GNU_negative_offset_extended:\n-      p = decode_uleb128 (p, &reg);\n-      p = decode_uleb128 (p, &offset);\n-      offset *= info->data_align;\n-      state->s.saved[reg] = REG_SAVED_OFFSET;\n-      state->s.reg_or_offset[reg] = -offset;\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-  return p;\n-}\n-\f\n /* Called from crtbegin.o to register the unwind info for an object.  */\n \n void\n@@ -917,51 +336,3 @@ __deregister_frame (void *begin)\n   free (__deregister_frame_info (begin));\n }\n \n-/* Called from __throw to find the registers to restore for a given\n-   PC_TARGET.  The caller should allocate a local variable of `struct\n-   frame_state' (declared in frame.h) and pass its address to STATE_IN.  */\n-\n-struct frame_state *\n-__frame_state_for (void *pc_target, struct frame_state *state_in)\n-{\n-  fde *f;\n-  void *insn, *end, *pc;\n-  struct cie_info info;\n-  struct frame_state_internal state;\n-\n-  f = find_fde (pc_target);\n-  if (f == 0)\n-    return 0;\n-\n-  insn = extract_cie_info (f, &info);\n-  if (insn == 0)\n-    return 0;\n-\n-  memset (&state, 0, sizeof (state));\n-  state.s.retaddr_column = info.ra_regno;\n-  state.s.eh_ptr = info.eh_ptr;\n-\n-  /* First decode all the insns in the CIE.  */\n-  end = next_fde ((fde*) get_cie (f));\n-  while (insn < end)\n-    insn = execute_cfa_insn (insn, &state, &info, 0);\n-\n-  insn = ((fde *)f) + 1;\n-\n-  if (info.augmentation[0] == 'z')\n-    {\n-      int i;\n-      insn = decode_uleb128 (insn, &i);\n-      insn += i;\n-    }\n-\n-  /* Then the insns in the FDE up to our target PC.  */\n-  end = next_fde (f);\n-  pc = f->pc_begin;\n-  while (insn < end && pc <= pc_target)\n-    insn = execute_cfa_insn (insn, &state, &info, &pc);\n-\n-  memcpy (state_in, &state.s, sizeof (state.s));\n-  return state_in;\n-}\n-#endif /* DWARF2_UNWIND_INFO */"}, {"sha": "384e5eb66ca80c6b9e535df22b566625ae659b92", "filename": "gcc/frame.h", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fframe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fframe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.h?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -50,9 +50,15 @@ typedef struct frame_state\n    keep the copies synchronized!  */\n \n struct object {\n+#ifdef IA64_UNWIND_INFO\n+  void *pc_base;        /* This field will be set by find_fde. */\n+#endif\n   void *pc_begin;\n   void *pc_end;\n   struct dwarf_fde *fde_begin;\n+#ifdef IA64_UNWIND_INFO\n+  struct dwarf_fde *fde_end;\n+#endif\n   struct dwarf_fde **fde_array;\n   size_t count;\n   struct object *next;\n@@ -87,3 +93,184 @@ extern void *__deregister_frame_info (void *);\n    Returns NULL on failure, otherwise returns STATE_IN.  */\n \n extern struct frame_state *__frame_state_for (void *, struct frame_state *);\n+\n+#ifdef IA64_UNWIND_INFO\n+\n+/* This is the information required for unwind records in an ia64\n+   object file. This is required by GAS and the compiler runtime. */\n+\n+/* These are the starting point masks for the various types of\n+   unwind records. To create a record of type R3 for instance, one\n+   starts by using the value UNW_R3 and or-ing in any other required values. \n+   These values are also unique (in context), so they can be used to identify \n+   the various record types as well. UNW_Bx and some UNW_Px do have the\n+   same value, but Px can only occur in a prologue context, and Bx in\n+   a body context.  */\n+\n+#define UNW_R1\t0x00\n+#define UNW_R2\t0x40\n+#define UNW_R3\t0x60\n+#define UNW_P1\t0x80\n+#define UNW_P2\t0xA0\n+#define UNW_P3\t0xB0\n+#define UNW_P4\t0xB8\n+#define UNW_P5\t0xB9\n+#define UNW_P6\t0xC0\n+#define UNW_P7\t0xE0\n+#define UNW_P8\t0xF0\n+#define UNW_P9\t0xF1\n+#define UNW_P10\t0xFF\n+#define UNW_X1\t0xF9\n+#define UNW_X2\t0xFA\n+#define UNW_X3\t0xFB\n+#define UNW_X4\t0xFC\n+#define UNW_B1\t0x80\n+#define UNW_B2\t0xC0\n+#define UNW_B3\t0xE0\n+#define UNW_B4\t0xF0\n+\n+/* These are all the various types of unwind records.  */\n+\n+typedef enum\n+{\n+  prologue, prologue_gr, body, mem_stack_f, mem_stack_v, psp_gr, psp_sprel,\n+  rp_when, rp_gr, rp_br, rp_psprel, rp_sprel, pfs_when, pfs_gr, pfs_psprel,\n+  pfs_sprel, preds_when, preds_gr, preds_psprel, preds_sprel,\n+  fr_mem, frgr_mem, gr_gr, gr_mem, br_mem, br_gr, spill_base, spill_mask,\n+  unat_when, unat_gr, unat_psprel, unat_sprel, lc_when, lc_gr, lc_psprel,\n+  lc_sprel, fpsr_when, fpsr_gr, fpsr_psprel, fpsr_sprel, \n+  priunat_when_gr, priunat_when_mem, priunat_gr, priunat_psprel, \n+  priunat_sprel, bsp_when, bsp_gr, bsp_psprel, bsp_sprel, bspstore_when,\n+  bspstore_gr, bspstore_psprel, bspstore_sprel, rnat_when, rnat_gr,\n+  rnat_psprel, rnat_sprel, epilogue, label_state, copy_state,\n+  spill_psprel, spill_sprel, spill_reg, spill_psprel_p, spill_sprel_p,\n+  spill_reg_p\n+} unw_record_type;\n+\n+\n+/* These structures declare the fields that can be used in each of the \n+   4 record formats, R, P, B and X.  */\n+\n+typedef struct unw_r_record\n+{\n+  unsigned long rlen;\n+  unsigned short mask;\n+  unsigned short grsave;\n+} unw_r_record;\n+\n+typedef struct unw_p_record\n+{\n+  void *imask;\n+  unsigned long t;\n+  unsigned long size;\n+  unsigned long spoff;\n+  unsigned long br;\n+  unsigned long pspoff;\n+  unsigned short gr;\n+  unsigned short rmask;\n+  unsigned short grmask;\n+  unsigned long frmask;\n+  unsigned short brmask;\n+} unw_p_record;\n+\n+typedef struct unw_b_record\n+{\n+  unsigned long t;\n+  unsigned long label;\n+  unsigned short ecount;\n+} unw_b_record;\n+\n+typedef struct unw_x_record\n+{\n+  unsigned long t;\n+  unsigned long spoff;\n+  unsigned long pspoff;\n+  unsigned short reg;\n+  unsigned short treg;\n+  unsigned short qp;\n+  unsigned short xy;   /* Value of the XY field..  */\n+} unw_x_record;\n+\n+/* This structure is used to determine the specific record type and \n+   its fields.  */\n+typedef struct unwind_record\n+{\n+  unw_record_type type;\n+  union {\n+    unw_r_record r;\n+    unw_p_record p;\n+    unw_b_record b;\n+    unw_x_record x;\n+  } record;\n+} unwind_record;\n+\n+#define IA64_UNW_LOC_TYPE_NONE\t\t0\n+#define IA64_UNW_LOC_TYPE_MEM\t\t1\n+#define IA64_UNW_LOC_TYPE_GR\t\t2\n+#define IA64_UNW_LOC_TYPE_FR\t\t3\n+#define IA64_UNW_LOC_TYPE_BR\t\t4\n+#define IA64_UNW_LOC_TYPE_SPOFF\t\t5\n+#define IA64_UNW_LOC_TYPE_PSPOFF\t6\n+#define IA64_UNW_LOC_TYPE_OFFSET\t7\n+#define IA64_UNW_LOC_TYPE_SPILLBASE\t8\n+\n+typedef struct ia64_reg_loc \n+{\n+  long when;\t\t/* PC relative offset from start of function. */\n+  union {\t\t/* In memory or another register?  */\n+    void *mem;\n+    int regno;\n+    int offset;\n+  } l;\n+  short loc_type;\t/* Where to find value.  */\n+  short reg_size;\n+} ia64_reg_loc;\n+\n+/* Frame information record.  */\n+\n+typedef struct ia64_frame_state\n+{\n+  ia64_reg_loc gr[4];\t/* gr4 to  gr7.  */\n+  ia64_reg_loc fr[20];\t/* fr2 to fr5, fr16 to fr31.  */\n+  ia64_reg_loc br[5];\t/* br1 to  br5.  */\n+  ia64_reg_loc rp;\n+  ia64_reg_loc fpsr;\n+  ia64_reg_loc bsp;\n+  ia64_reg_loc bspstore;\n+  ia64_reg_loc rnat;\n+  ia64_reg_loc pfs;\n+  ia64_reg_loc unat;\n+  ia64_reg_loc lc;\n+  ia64_reg_loc pr;\n+  ia64_reg_loc priunat;\n+  ia64_reg_loc sp;\n+  ia64_reg_loc psp;\n+  ia64_reg_loc spill_base;\n+  void *my_sp;\n+  void *my_bsp;\n+} ia64_frame_state;\n+\n+/* This structure represents the start of an unwind information pointer.  \n+   'unwind_descriptors' is the beginninng of the unwind descriptors, which\n+   use up 'length' bytes of storage.  */\n+\n+typedef struct unwind_info_ptr \n+{\n+  unsigned short version;\n+  unsigned short flags;\n+  unsigned int length;\n+  unsigned char unwind_descriptors[1];\n+} unwind_info_ptr;\n+\n+\n+extern unwind_info_ptr *__build_ia64_frame_state (unsigned char *, \n+\t\t\t\t\t\t  ia64_frame_state *, void *,\n+\t\t\t\t\t\t  void **);\n+extern void *__get_real_reg_value (ia64_reg_loc *);\n+extern void *__get_personality (unwind_info_ptr *);\n+extern void *__get_except_table (unwind_info_ptr *);\n+extern void __set_real_reg_value (ia64_reg_loc *, void *);\n+void *__calc_caller_bsp (long, unsigned char *);\n+void __copy_saved_reg_state (ia64_frame_state *, ia64_frame_state *);\n+#endif   /* IA64_UNWIND_INFO  */\n+"}, {"sha": "822d84e08517c7696f1e154767490bdf68b3ff38", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -3940,6 +3940,173 @@ __rethrow (void *index)\n }\n #endif /* DWARF2_UNWIND_INFO */\n \n+#ifdef IA64_UNWIND_INFO\n+#include \"frame.h\"\n+\n+/* Return handler to which we want to transfer control, NULL if we don't\n+   intend to handle this exception here.  */\n+void *\n+__ia64_personality_v1 (void *pc, old_exception_table *table)\n+{\n+  if (table)\n+    {\n+      int pos;\n+      int best = -1;\n+\n+      for (pos = 0; table[pos].start_region != (void *) -1; ++pos)\n+        {\n+          if (table[pos].start_region <= pc && table[pos].end_region > pc)\n+            {\n+              /* This can apply.  Make sure it is at least as small as\n+                 the previous best.  */\n+              if (best == -1 || (table[pos].end_region <= table[best].end_region\n+                        && table[pos].start_region >= table[best].start_region))\n+                best = pos;\n+            }\n+          /* It is sorted by starting PC within a function.  */\n+          else if (best >= 0 && table[pos].start_region > pc)\n+            break;\n+        }\n+      if (best != -1)\n+        return table[best].exception_handler;\n+    }\n+  return (void *) 0;\n+}\n+\n+static void\n+ia64_throw_helper (throw_pc, throw_frame, caller, throw_bsp)\n+     void *throw_pc;\n+     ia64_frame_state *throw_frame;\n+     ia64_frame_state *caller;\n+     void *throw_bsp;\n+{\n+  unwind_info_ptr *info;\n+  void *pc, *handler = NULL;\n+  void *pc_base;\n+  int frame_count;\n+  void *bsp;\n+\n+  __builtin_ia64_flushrs ();      /*  Make the local register stacks available.  */\n+\n+  /* Start at our stack frame, get our state.  */\n+  __build_ia64_frame_state (throw_pc, throw_frame, throw_bsp, &pc_base);\n+\n+  /* Now we have to find the proper frame for pc, and see if there\n+     is a handler for it. if not, we keep going back frames until\n+     we do find one. Otherwise we call uncaught ().  */\n+\n+  frame_count = 0;\n+  memcpy (caller, throw_frame, sizeof (*caller));\n+  while (!handler)\n+    {\n+      void *(*personality) ();\n+      void *eh_table;\n+\n+      frame_count++;\n+      /* We only care about the RP right now, so we dont need to keep\n+         any other information about a call frame right now.  */\n+      pc = __get_real_reg_value (&caller->rp) - 1;\n+      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs), caller->my_bsp);\n+      info = __build_ia64_frame_state (pc, caller, bsp, &pc_base);\n+\n+      /* If we couldn't find the next frame, we lose.  */\n+      if (! info)\n+\tbreak;\n+\n+      personality = __get_personality (info); \n+      /* TODO Haven't figured out how to actually load the personality address\n+         yet, so just always default to the one we expect for now.  */\n+      if (personality != 0)\n+\tpersonality = __ia64_personality_v1;\n+      eh_table = __get_except_table (info);\n+      /* If there is no personality routine, we'll keep unwinding.  */\n+      if (personality)\n+\t/* Pass a segment relative PC address to the personality routine,\n+\t   because the unwind_info section uses segrel relocs.  */\n+\thandler = personality (pc - pc_base, eh_table);\n+    }\n+  \n+  if (!handler)\n+   __terminate ();\n+\n+  /* Handler is a segment relative address, so we must adjust it here.  */\n+  handler += (long) pc_base;\n+\n+  /* If we found a handler, we need to unwind the stack to that point.\n+     We do this by copying saved values from previous frames into the\n+     save slot for the throw_frame saved slots.  when __throw returns,\n+     it'll pickup the correct values.  */\n+  \n+  /* Start with where __throw saved things, and copy each saved register\n+     of each previous frame until we get to the one before we're \n+     throwing back to.  */\n+  memcpy (caller, throw_frame, sizeof (*caller));\n+  for ( ; frame_count > 0; frame_count--)\n+    {\n+      pc = __get_real_reg_value (&caller->rp) - 1;\n+      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs), caller->my_bsp);\n+      __build_ia64_frame_state (pc, caller, bsp, &pc_base);\n+      /* Any regs that were saved can be put in the throw frame now.  */\n+      /* We don't want to copy any saved register from the \n+         target destination, but we do want to load up it's frame.  */\n+      if (frame_count > 1)\n+\t__copy_saved_reg_state (throw_frame, caller);\n+    }\n+\n+  /* Set return address of the throw frame to the handler. */\n+  __set_real_reg_value (&throw_frame->rp, handler);\n+\n+  /* TODO, do we need to do anything to make the values we wrote 'stick'? */\n+  /* DO we need to go through the whole loadrs seqeunce?  */\n+\n+}\n+\n+void\n+__throw ()\n+{\n+  struct eh_context *eh = (*get_eh_context) ();\n+  ia64_frame_state my_frame;\n+  ia64_frame_state originator;\t/* For the context handler is in.  */\n+  void *bsp, *tmp_bsp;\n+  long offset;\n+\n+  /* This is required for C++ semantics.  We must call terminate if we\n+     try and rethrow an exception, when there is no exception currently\n+     active.  */\n+  if (! eh->info)\n+    __terminate ();\n+\n+  __builtin_unwind_init ();\n+label_ia64:\n+  /* We have to call another routine to actually process the frame \n+     information, which will force all of __throw's local registers into\n+     backing store.  */\n+\n+  /* Get the value of ar.bsp while we're here.  */\n+\n+  bsp = __builtin_ia64_bsp ();\n+  ia64_throw_helper (&&label_ia64, &my_frame, &originator, bsp);\n+\n+  /* Now we have to fudge the bsp by the amount in our (__throw)\n+     frame marker, since the return is going to adjust it by that much. */\n+\n+  tmp_bsp = __calc_caller_bsp ((long)__get_real_reg_value (&my_frame.pfs), \n+\t\t\t     my_frame.my_bsp);\n+  offset = (char *)my_frame.my_bsp - (char *)tmp_bsp;\n+  tmp_bsp = (char *)originator.my_bsp + offset;\n+\n+  /* A throw handler is trated like a  non-local goto, which is architeched\n+     to set the FP (or PSP) in r7 before branching.  gr[0-3] map to \n+     r4-r7, so we want gr[3].  */\n+  __set_real_reg_value (&my_frame.gr[3], __get_real_reg_value (&originator.psp));\n+\n+  __builtin_eh_return (tmp_bsp, offset, originator.my_sp);\n+\n+  /* The return address was already set by throw_helper.  */\n+}\n+\n+#endif /* IA64_UNWIND_INFO  */\n+\n #endif /* L_eh */\n \f\n #ifdef L_pure"}, {"sha": "ad78d23d1ab2f9668993194551716f19baf0ed31", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -292,6 +292,7 @@ extern void assemble_zeros\t\tPARAMS ((int));\n \n /* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\n extern void assemble_align\t\tPARAMS ((int));\n+extern void assemble_eh_align\t\tPARAMS ((int));\n \n /* Assemble a string constant with the specified C string as contents.  */\n extern void assemble_string\t\tPARAMS ((const char *, int));\n@@ -306,6 +307,7 @@ extern void assemble_global\t\tPARAMS ((const char *));\n \n /* Assemble a label named NAME.  */\n extern void assemble_label\t\tPARAMS ((const char *));\n+extern void assemble_eh_label\t\tPARAMS ((const char *));\n \n /* Output to FILE a reference to the assembler name of a C-level name NAME.\n    If NAME starts with a *, the rest of NAME is output verbatim.\n@@ -321,6 +323,7 @@ extern void assemble_name\t\tPARAMS ((FILE *, const char *));\n    Return 1 if we were able to output the constant, otherwise 0.  If FORCE is\n    non-zero, abort if we can't output the constant.  */\n extern int assemble_integer\t\tPARAMS ((rtx, int, int));\n+extern int assemble_eh_integer\t\tPARAMS ((rtx, int, int));\n \n #ifdef EMUSHORT\n /* Assemble the floating-point constant D into an object of size MODE.  */"}, {"sha": "30ef18a743680180422d7325db4eddb5b2346f3b", "filename": "gcc/toplev.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -2336,8 +2336,11 @@ compile_file (name)\n     /* Now that all possible functions have been output, we can dump\n        the exception table.  */\n \n+#ifndef IA64_UNWIND_INFO\n     output_exception_table ();\n-\n+#endif\n+    free_exception_table ();\n+    \n     check_global_declarations (vec, len);\n \n     /* Clean up.  */\n@@ -4604,11 +4607,23 @@ main (argc, argv)\n     {\n #ifdef DWARF2_UNWIND_INFO\n       exceptions_via_longjmp = ! DWARF2_UNWIND_INFO;\n+#else\n+#ifdef IA64_UNWIND_INFO\n+      exceptions_via_longjmp = ! IA64_UNWIND_INFO;\n #else\n       exceptions_via_longjmp = 1;\n+#endif\n #endif\n     }\n \n+  /* Since each function gets its own handler data, we can't support the\n+     new model currently, since it depend on a specific rethrow label\n+     which is declared at the front of the table, and we can only\n+     have one such symbol in a file.  */\n+#ifdef IA64_UNWIND_INFO\n+  flag_new_exceptions = 0;\n+#endif\n+\n   /* Set up the align_*_log variables, defaulting them to 1 if they\n      were still unset.  */\n   if (align_loops <= 0) align_loops = 1;"}, {"sha": "1731839480cdcf2281cdec04dac74ff3cd8d7da8", "filename": "gcc/varasm.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce152ef8360320d27e1aacba9af8fdc4e1649941/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ce152ef8360320d27e1aacba9af8fdc4e1649941", "patch": "@@ -4836,3 +4836,74 @@ init_varasm_once ()\n \t\tmark_const_hash_entry);\n   ggc_add_string_root (&in_named_name, 1);\n }\n+\n+/* Extra support for EH values.  */\n+void\n+assemble_eh_label (name)\n+     const char *name;\n+{\n+#ifdef ASM_OUTPUT_EH_LABEL\n+  ASM_OUTPUT_EH_LABEL (asm_out_file, name);\n+#else\n+  assemble_label (name);\n+#endif\n+}\n+\n+/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\n+\n+void\n+assemble_eh_align (align)\n+     int align;\n+{\n+#ifdef ASM_OUTPUT_EH_ALIGN\n+  if (align > BITS_PER_UNIT)\n+    ASM_OUTPUT_EH_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+#else\n+  assemble_align (align);\n+#endif\n+}\n+\n+\n+/* On some platforms, we may want to specify a special mechansim to\n+   output EH data when generating with a function..  */\n+int\n+assemble_eh_integer (x, size, force)\n+     rtx x;\n+     int size;\n+     int force;\n+{\n+\n+  switch (size)\n+    {\n+#ifdef ASM_OUTPUT_EH_CHAR\n+    case 1:\n+      ASM_OUTPUT_EH_CHAR (asm_out_file, x);\n+      return 1;\n+#endif\n+\n+#ifdef ASM_OUTPUT_EH_SHORT\n+    case 2:\n+      ASM_OUTPUT_EH_SHORT (asm_out_file, x);\n+      return 1;\n+#endif\n+\n+#ifdef ASM_OUTPUT_EH_INT\n+    case 4:\n+      ASM_OUTPUT_EH_INT (asm_out_file, x);\n+      return 1;\n+#endif\n+\n+#ifdef ASM_OUTPUT_EH_DOUBLE_INT\n+    case 8:\n+      ASM_OUTPUT_EH_DOUBLE_INT (asm_out_file, x);\n+      return 1;\n+#endif\n+\n+    default:\n+      break;\n+    }\n+  return (assemble_integer (x, size, force));\n+}\n+\n+\n+"}]}