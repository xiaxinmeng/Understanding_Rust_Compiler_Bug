{"sha": "c5be6c3a9dd0b3a12c15d729629a574e1967e58d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzViZTZjM2E5ZGQwYjNhMTJjMTVkNzI5NjI5YTU3NGUxOTY3ZTU4ZA==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2010-10-05T09:29:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-05T09:29:14Z"}, "message": "prj-nmsc.adb, [...] (Expand_Subdirectory_Pattern): New subprogram.\n\n2010-10-05  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-nmsc.adb, prj-err.adb (Expand_Subdirectory_Pattern): New\n\tsubprogram.\n\tExtract some code from Get_Directories, to share with the handling\n        of aggregate projects (for the Project_Files attributes)\n\nFrom-SVN: r164970", "tree": {"sha": "9baec89c57ba344dd6fd2d832bedd242dbdf84d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9baec89c57ba344dd6fd2d832bedd242dbdf84d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5be6c3a9dd0b3a12c15d729629a574e1967e58d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5be6c3a9dd0b3a12c15d729629a574e1967e58d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5be6c3a9dd0b3a12c15d729629a574e1967e58d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5be6c3a9dd0b3a12c15d729629a574e1967e58d/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0a786e30d405d181e936f76317e3f1c896d4bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a786e30d405d181e936f76317e3f1c896d4bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a786e30d405d181e936f76317e3f1c896d4bfa"}], "stats": {"total": 633, "additions": 319, "deletions": 314}, "files": [{"sha": "aec714cd3013b894ba84b47156a1c23592d50914", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be6c3a9dd0b3a12c15d729629a574e1967e58d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be6c3a9dd0b3a12c15d729629a574e1967e58d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c5be6c3a9dd0b3a12c15d729629a574e1967e58d", "patch": "@@ -1,3 +1,10 @@\n+2010-10-05  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-nmsc.adb, prj-err.adb (Expand_Subdirectory_Pattern): New\n+\tsubprogram.\n+\tExtract some code from Get_Directories, to share with the handling\n+\tof aggregate projects (for the Project_Files attributes)\n+\n 2010-10-05  Emmanuel Briot  <briot@adacore.com>\n \n \t* gnatcmd.adb, prj-proc.adb, prj-part.adb, prj-ext.adb, prj-ext.ads,"}, {"sha": "4f5aea10b439c5654ed16761780024b546999453", "filename": "gcc/ada/prj-err.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be6c3a9dd0b3a12c15d729629a574e1967e58d/gcc%2Fada%2Fprj-err.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be6c3a9dd0b3a12c15d729629a574e1967e58d/gcc%2Fada%2Fprj-err.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-err.adb?ref=c5be6c3a9dd0b3a12c15d729629a574e1967e58d", "patch": "@@ -95,6 +95,10 @@ package body Prj.Err is\n          --  so we shouldn't report errors for projects that the user has no\n          --  access to in any case.\n \n+         if Current_Verbosity = High then\n+            Write_Line (\"Error in in-memory project, ignored\");\n+         end if;\n+\n          return;\n       end if;\n "}, {"sha": "f992f7ee14a647ced447b4f4c080374dd2c6f758", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 308, "deletions": 314, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be6c3a9dd0b3a12c15d729629a574e1967e58d/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be6c3a9dd0b3a12c15d729629a574e1967e58d/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=c5be6c3a9dd0b3a12c15d729629a574e1967e58d", "patch": "@@ -211,6 +211,33 @@ package body Prj.Nmsc is\n    --  exceptions, and copied into the Source_Names and Unit_Exceptions tables\n    --  as appropriate.\n \n+   type Search_Type is (Search_Files, Search_Directories);\n+   pragma Unreferenced (Search_Files);\n+\n+   generic\n+      with procedure Callback\n+        (Path_Id         : Path_Name_Type;\n+         Display_Path_Id : Path_Name_Type;\n+         Pattern_Index   : Natural);\n+   procedure Expand_Subdirectory_Pattern\n+     (Project       : Project_Id;\n+      Data          : in out Tree_Processing_Data;\n+      Patterns      : String_List_Id;\n+      Search_For    : Search_Type;\n+      Resolve_Links : Boolean);\n+   --  Search the subdirectories of Project's directory for files or\n+   --  directories that match the globbing patterns found in Patterns (for\n+   --  instance \"**/*.adb\"). Typically, Patterns will be the value of the\n+   --  Source_Dirs or Excluded_Source_Dirs attributes.\n+   --  Every time such a file or directory is found, the callback is called.\n+   --  Resolve_Links indicates whether we should resolve links while\n+   --  normalizing names.\n+   --  In the callback, Pattern_Index is the index within Patterns where the\n+   --  expanded pattern was found (1 for the first element of Patterns and\n+   --  all its matching directories, then 2,...).\n+   --  We use a generic and not an access-to-subprogram because in some cases\n+   --  this code is compiled with the restriction No_Implicit_Dynamic_Code\n+\n    procedure Add_Source\n      (Id                  : out Source_Id;\n       Data                : in out Tree_Processing_Data;\n@@ -4853,19 +4880,6 @@ package body Prj.Nmsc is\n      (Project : Project_Id;\n       Data    : in out Tree_Processing_Data)\n    is\n-      package Recursive_Dirs is new GNAT.Dynamic_HTables.Simple_HTable\n-        (Header_Num => Header_Num,\n-         Element    => Boolean,\n-         No_Element => False,\n-         Key        => Path_Name_Type,\n-         Hash       => Hash,\n-         Equal      => \"=\");\n-      --  Hash table stores recursive source directories, to avoid looking\n-      --  several times, and to avoid cycles that may be introduced by symbolic\n-      --  links.\n-\n-      Visited : Recursive_Dirs.Instance;\n-\n       Object_Dir  : constant Variable_Value :=\n                       Util.Value_Of\n                         (Name_Object_Dir, Project.Decl.Attributes, Data.Tree);\n@@ -4894,34 +4908,29 @@ package body Prj.Nmsc is\n \n       Languages : constant Variable_Value :=\n                       Prj.Util.Value_Of\n-                        (Name_Languages, Project.Decl.Attributes, Data.Tree);\n+          (Name_Languages, Project.Decl.Attributes, Data.Tree);\n \n-      procedure Find_Source_Dirs\n-        (From     : File_Name_Type;\n-         Location : Source_Ptr;\n-         Rank     : Natural;\n-         Removed  : Boolean := False);\n-      --  Find one or several source directories, and add (or remove, if\n-      --  Removed is True) them to list of source directories of the project.\n+      Remove_Source_Dirs : Boolean := False;\n \n       procedure Add_To_Or_Remove_From_Source_Dirs\n         (Path_Id         : Path_Name_Type;\n          Display_Path_Id : Path_Name_Type;\n-         Rank            : Natural;\n-         Removed         : Boolean);\n+         Rank            : Natural);\n       --  When Removed = False, the directory Path_Id to the list of\n       --  source_dirs if not already in the list. When Removed = True,\n       --  removed directory Path_Id if in the list.\n \n+      procedure Find_Source_Dirs is new Expand_Subdirectory_Pattern\n+        (Add_To_Or_Remove_From_Source_Dirs);\n+\n       ---------------------------------------\n       -- Add_To_Or_Remove_From_Source_Dirs --\n       ---------------------------------------\n \n       procedure Add_To_Or_Remove_From_Source_Dirs\n         (Path_Id         : Path_Name_Type;\n          Display_Path_Id : Path_Name_Type;\n-         Rank            : Natural;\n-         Removed         : Boolean)\n+         Rank            : Natural)\n       is\n          List       : String_List_Id;\n          Prev       : String_List_Id;\n@@ -4945,7 +4954,7 @@ package body Prj.Nmsc is\n \n          --  The directory is in the list if List is not Nil_String\n \n-         if not Removed and then List = Nil_String then\n+         if not Remove_Source_Dirs and then List = Nil_String then\n             if Current_Verbosity = High then\n                Write_Str  (\"   Adding Source Dir=\");\n                Write_Line (Get_Name_String (Display_Path_Id));\n@@ -4991,7 +5000,7 @@ package body Prj.Nmsc is\n             Data.Tree.Number_Lists.Table (Last_Src_Dir_Rank) :=\n               (Number => Rank, Next => No_Number_List);\n \n-         elsif Removed and then List /= Nil_String then\n+         elsif Remove_Source_Dirs and then List /= Nil_String then\n \n             --  Remove source dir, if present\n \n@@ -5010,247 +5019,6 @@ package body Prj.Nmsc is\n          end if;\n       end Add_To_Or_Remove_From_Source_Dirs;\n \n-      ----------------------\n-      -- Find_Source_Dirs --\n-      ----------------------\n-\n-      procedure Find_Source_Dirs\n-        (From     : File_Name_Type;\n-         Location : Source_Ptr;\n-         Rank     : Natural;\n-         Removed  : Boolean := False)\n-      is\n-         Directory : constant String := Get_Name_String (From);\n-\n-         procedure Recursive_Find_Dirs (Path : Name_Id);\n-         --  Find all the subdirectories (recursively) of Path and add them\n-         --  to the list of source directories of the project.\n-\n-         -------------------------\n-         -- Recursive_Find_Dirs --\n-         -------------------------\n-\n-         procedure Recursive_Find_Dirs (Path : Name_Id) is\n-            Dir  : Dir_Type;\n-            Name : String (1 .. 250);\n-            Last : Natural;\n-\n-            Non_Canonical_Path : Path_Name_Type := No_Path;\n-            Canonical_Path     : Path_Name_Type := No_Path;\n-\n-            The_Path : constant String :=\n-                         Normalize_Pathname\n-                           (Get_Name_String (Path),\n-                            Directory     =>\n-                              Get_Name_String (Project.Directory.Display_Name),\n-                            Resolve_Links => Opt.Follow_Links_For_Dirs) &\n-                         Directory_Separator;\n-\n-            The_Path_Last : constant Natural :=\n-                              Compute_Directory_Last (The_Path);\n-\n-         begin\n-            Name_Len := The_Path_Last - The_Path'First + 1;\n-            Name_Buffer (1 .. Name_Len) :=\n-              The_Path (The_Path'First .. The_Path_Last);\n-            Non_Canonical_Path := Name_Find;\n-            Canonical_Path :=\n-              Path_Name_Type\n-                (Canonical_Case_File_Name (Name_Id (Non_Canonical_Path)));\n-\n-            --  To avoid processing the same directory several times, check\n-            --  if the directory is already in Recursive_Dirs. If it is, then\n-            --  there is nothing to do, just return. If it is not, put it there\n-            --  and continue recursive processing.\n-\n-            if not Removed then\n-               if Recursive_Dirs.Get (Visited, Canonical_Path) then\n-                  return;\n-               else\n-                  Recursive_Dirs.Set (Visited, Canonical_Path, True);\n-               end if;\n-            end if;\n-\n-            Add_To_Or_Remove_From_Source_Dirs\n-              (Path_Id         => Canonical_Path,\n-               Display_Path_Id => Non_Canonical_Path,\n-               Rank            => Rank,\n-               Removed         => Removed);\n-\n-            --  Now look for subdirectories. Do that even when this directory\n-            --  is already in the list, because some of its subdirectories may\n-            --  not be in the list yet.\n-\n-            Open (Dir, The_Path (The_Path'First .. The_Path_Last));\n-\n-            loop\n-               Read (Dir, Name, Last);\n-               exit when Last = 0;\n-\n-               if Name (1 .. Last) /= \".\"\n-                 and then Name (1 .. Last) /= \"..\"\n-               then\n-                  --  Avoid . and .. directories\n-\n-                  if Current_Verbosity = High then\n-                     Write_Str  (\"   Checking \");\n-                     Write_Line (Name (1 .. Last));\n-                  end if;\n-\n-                  declare\n-                     Path_Name : constant String :=\n-                                   Normalize_Pathname\n-                                     (Name           => Name (1 .. Last),\n-                                      Directory      =>\n-                                        The_Path\n-                                          (The_Path'First .. The_Path_Last),\n-                                      Resolve_Links  =>\n-                                        Opt.Follow_Links_For_Dirs,\n-                                      Case_Sensitive => True);\n-\n-                  begin\n-                     if Is_Directory (Path_Name) then\n-\n-                        --  We have found a new subdirectory, call self\n-\n-                        Name_Len := Path_Name'Length;\n-                        Name_Buffer (1 .. Name_Len) := Path_Name;\n-                        Recursive_Find_Dirs (Name_Find);\n-                     end if;\n-                  end;\n-               end if;\n-            end loop;\n-\n-            Close (Dir);\n-\n-         exception\n-            when Directory_Error =>\n-               null;\n-         end Recursive_Find_Dirs;\n-\n-      --  Start of processing for Find_Source_Dirs\n-\n-      begin\n-         if Current_Verbosity = High and then not Removed then\n-            Write_Str (\"Find_Source_Dirs (\"\"\");\n-            Write_Str (Directory);\n-            Write_Str (\",\");\n-            Write_Str (Rank'Img);\n-            Write_Line (\"\"\")\");\n-         end if;\n-\n-         --  First, check if we are looking for a directory tree, indicated\n-         --  by \"/**\" at the end.\n-\n-         if Directory'Length >= 3\n-           and then Directory (Directory'Last - 1 .. Directory'Last) = \"**\"\n-           and then (Directory (Directory'Last - 2) = '/'\n-                       or else\n-                     Directory (Directory'Last - 2) = Directory_Separator)\n-         then\n-            Name_Len := Directory'Length - 3;\n-\n-            if Name_Len = 0 then\n-\n-               --  Case of \"/**\": all directories in file system\n-\n-               Name_Len := 1;\n-               Name_Buffer (1) := Directory (Directory'First);\n-\n-            else\n-               Name_Buffer (1 .. Name_Len) :=\n-                 Directory (Directory'First .. Directory'Last - 3);\n-            end if;\n-\n-            if Current_Verbosity = High then\n-               Write_Str (\"Looking for all subdirectories of \"\"\");\n-               Write_Str (Name_Buffer (1 .. Name_Len));\n-               Write_Line (\"\"\"\");\n-            end if;\n-\n-            declare\n-               Base_Dir : constant File_Name_Type := Name_Find;\n-               Root_Dir : constant String :=\n-                            Normalize_Pathname\n-                              (Name      => Name_Buffer (1 .. Name_Len),\n-                               Directory =>\n-                                 Get_Name_String\n-                                   (Project.Directory.Display_Name),\n-                               Resolve_Links  =>\n-                                 Opt.Follow_Links_For_Dirs,\n-                               Case_Sensitive => True);\n-               Has_Error : Boolean := False;\n-\n-            begin\n-               if Root_Dir'Length = 0 then\n-                  Err_Vars.Error_Msg_File_1 := Base_Dir;\n-                  Error_Or_Warning\n-                    (Data.Flags, Data.Flags.Missing_Source_Files,\n-                     \"{ is not a valid directory.\", Location, Project);\n-                  Has_Error := Data.Flags.Missing_Source_Files = Error;\n-               end if;\n-\n-               if not Has_Error then\n-\n-                  --  We have an existing directory, we register it and all of\n-                  --  its subdirectories.\n-\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"Looking for source directories:\");\n-                  end if;\n-\n-                  Name_Len := Root_Dir'Length;\n-                  Name_Buffer (1 .. Name_Len) := Root_Dir;\n-                  Recursive_Find_Dirs (Name_Find);\n-\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"End of looking for source directories.\");\n-                  end if;\n-               end if;\n-            end;\n-\n-         --  We have a single directory\n-\n-         else\n-            declare\n-               Path_Name  : Path_Information;\n-               Dir_Exists : Boolean;\n-               Has_Error  : Boolean := False;\n-\n-            begin\n-               Locate_Directory\n-                 (Project     => Project,\n-                  Name        => From,\n-                  Path        => Path_Name,\n-                  Dir_Exists  => Dir_Exists,\n-                  Data        => Data,\n-                  Must_Exist  => False);\n-\n-               if not Dir_Exists then\n-                  Err_Vars.Error_Msg_File_1 := From;\n-                  Error_Or_Warning\n-                    (Data.Flags, Data.Flags.Missing_Source_Files,\n-                     \"{ is not a valid directory\", Location, Project);\n-                  Has_Error := Data.Flags.Missing_Source_Files = Error;\n-               end if;\n-\n-               if not Has_Error then\n-\n-                  --  Links have been resolved if necessary, and Path_Name\n-                  --  always ends with a directory separator.\n-\n-                  Add_To_Or_Remove_From_Source_Dirs\n-                    (Path_Id         => Path_Name.Name,\n-                     Display_Path_Id => Path_Name.Display_Name,\n-                     Rank            => Rank,\n-                     Removed         => Removed);\n-               end if;\n-            end;\n-         end if;\n-\n-         Recursive_Dirs.Reset (Visited);\n-      end Find_Source_Dirs;\n-\n       --  Local declarations\n \n       Dir_Exists : Boolean;\n@@ -5422,62 +5190,41 @@ package body Prj.Nmsc is\n          --  No Source_Dirs specified: the single source directory is the one\n          --  containing the project file.\n \n+         Remove_Source_Dirs := False;\n          Add_To_Or_Remove_From_Source_Dirs\n            (Path_Id         => Project.Directory.Name,\n             Display_Path_Id => Project.Directory.Display_Name,\n-            Rank            => 1,\n-            Removed         => False);\n+            Rank            => 1);\n \n       else\n-         declare\n-            Source_Dir : String_List_Id;\n-            Element    : String_Element;\n-            Rank       : Natural;\n-         begin\n-            --  Process the source directories for each element of the list\n-\n-            Source_Dir := Source_Dirs.Values;\n-            Rank := 0;\n-            while Source_Dir /= Nil_String loop\n-               Element := Data.Tree.String_Elements.Table (Source_Dir);\n-               Rank := Rank + 1;\n-               Find_Source_Dirs\n-                 (File_Name_Type (Element.Value), Element.Location, Rank);\n-               Source_Dir := Element.Next;\n-            end loop;\n-\n-            if Project.Source_Dirs = Nil_String\n-              and then Project.Qualifier = Standard\n-            then\n-               Error_Msg\n-                 (Data.Flags,\n-                  \"a standard project cannot have no source directories\",\n-                  Source_Dirs.Location, Project);\n-            end if;\n-         end;\n+         Remove_Source_Dirs := False;\n+         Find_Source_Dirs\n+           (Project         => Project,\n+            Data            => Data,\n+            Patterns        => Source_Dirs.Values,\n+            Search_For      => Search_Directories,\n+            Resolve_Links   => Opt.Follow_Links_For_Dirs);\n+\n+         if Project.Source_Dirs = Nil_String\n+           and then Project.Qualifier = Standard\n+         then\n+            Error_Msg\n+              (Data.Flags,\n+               \"a standard project cannot have no source directories\",\n+               Source_Dirs.Location, Project);\n+         end if;\n       end if;\n \n       if not Excluded_Source_Dirs.Default\n         and then Excluded_Source_Dirs.Values /= Nil_String\n       then\n-         declare\n-            Source_Dir : String_List_Id;\n-            Element    : String_Element;\n-\n-         begin\n-            --  Process the source directories for each element of the list\n-\n-            Source_Dir := Excluded_Source_Dirs.Values;\n-            while Source_Dir /= Nil_String loop\n-               Element := Data.Tree.String_Elements.Table (Source_Dir);\n-               Find_Source_Dirs\n-                 (File_Name_Type (Element.Value),\n-                  Element.Location,\n-                  0,\n-                  Removed => True);\n-               Source_Dir := Element.Next;\n-            end loop;\n-         end;\n+         Remove_Source_Dirs := True;\n+         Find_Source_Dirs\n+           (Project         => Project,\n+            Data            => Data,\n+            Patterns        => Excluded_Source_Dirs.Values,\n+            Search_For      => Search_Directories,\n+            Resolve_Links   => Opt.Follow_Links_For_Dirs);\n       end if;\n \n       if Current_Verbosity = High then\n@@ -6933,6 +6680,253 @@ package body Prj.Nmsc is\n       end if;\n    end Check_File;\n \n+   ---------------------------------\n+   -- Expand_Subdirectory_Pattern --\n+   ---------------------------------\n+\n+   procedure Expand_Subdirectory_Pattern\n+     (Project       : Project_Id;\n+      Data          : in out Tree_Processing_Data;\n+      Patterns      : String_List_Id;\n+      Search_For    : Search_Type;\n+      Resolve_Links : Boolean)\n+   is\n+      pragma Unreferenced (Search_For);\n+      Project_Dir : constant String :=\n+        Get_Name_String (Project.Directory.Display_Name);\n+\n+      package Recursive_Dirs is new GNAT.Dynamic_HTables.Simple_HTable\n+        (Header_Num => Header_Num,\n+         Element    => Boolean,\n+         No_Element => False,\n+         Key        => Path_Name_Type,\n+         Hash       => Hash,\n+         Equal      => \"=\");\n+      --  Hash table stores recursive source directories, to avoid looking\n+      --  several times, and to avoid cycles that may be introduced by symbolic\n+      --  links.\n+\n+      Visited : Recursive_Dirs.Instance;\n+\n+      procedure Find_Pattern\n+        (Pattern : String; Rank : Natural; Location : Source_Ptr);\n+      --  Find a specific pattern\n+\n+      procedure Recursive_Find_Dirs (Normalized_Path : String; Rank : Natural);\n+      --  Search all the subdirectories (recursively) of Path\n+\n+      -------------------------\n+      -- Recursive_Find_Dirs --\n+      -------------------------\n+\n+      procedure Recursive_Find_Dirs\n+        (Normalized_Path : String; Rank : Natural)\n+      is\n+         Dir  : Dir_Type;\n+         Name : String (1 .. 250);\n+         Last : Natural;\n+\n+         Non_Canonical_Path : Path_Name_Type := No_Path;\n+         Canonical_Path     : Path_Name_Type := No_Path;\n+\n+         The_Path_Last : constant Natural :=\n+           Compute_Directory_Last (Normalized_Path);\n+\n+      begin\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer\n+           (Normalized_Path (Normalized_Path'First .. The_Path_Last));\n+         Non_Canonical_Path := Name_Find;\n+\n+         Canonical_Path :=\n+           Path_Name_Type\n+             (Canonical_Case_File_Name (Name_Id (Non_Canonical_Path)));\n+\n+         if Recursive_Dirs.Get (Visited, Canonical_Path) then\n+            return;\n+         end if;\n+\n+         Recursive_Dirs.Set (Visited, Canonical_Path, True);\n+\n+         Callback (Canonical_Path, Non_Canonical_Path, Rank);\n+\n+         Open (Dir, Normalized_Path (Normalized_Path'First .. The_Path_Last));\n+\n+         loop\n+            Read (Dir, Name, Last);\n+            exit when Last = 0;\n+\n+            if Name (1 .. Last) /= \".\"\n+              and then Name (1 .. Last) /= \"..\"\n+            then\n+               if Current_Verbosity = High then\n+                  Write_Str  (\"   Checking \");\n+                  Write_Line (Name (1 .. Last));\n+               end if;\n+\n+               declare\n+                  Path_Name : constant String :=\n+                    Normalize_Pathname\n+                      (Name           => Name (1 .. Last),\n+                       Directory      =>\n+                         Normalized_Path\n+                           (Normalized_Path'First .. The_Path_Last),\n+                       Resolve_Links  => Resolve_Links)\n+                    & Directory_Separator;\n+               begin\n+                  if Is_Directory (Path_Name) then\n+                     Recursive_Find_Dirs (Path_Name, Rank);\n+                  end if;\n+               end;\n+            end if;\n+         end loop;\n+\n+         Close (Dir);\n+\n+      exception\n+         when Directory_Error =>\n+            null;\n+      end Recursive_Find_Dirs;\n+\n+      ------------------\n+      -- Find_Pattern --\n+      ------------------\n+\n+      procedure Find_Pattern\n+        (Pattern : String; Rank : Natural; Location : Source_Ptr) is\n+      begin\n+         if Current_Verbosity = High then\n+            Write_Str (\"Expand_Subdirectory_Pattern (\"\"\");\n+            Write_Str (Pattern);\n+            Write_Line (\"\"\")\");\n+         end if;\n+\n+         --  First, check if we are looking for a directory tree, indicated\n+         --  by \"/**\" at the end.\n+\n+         if Pattern'Length >= 3\n+           and then Pattern (Pattern'Last - 1 .. Pattern'Last) = \"**\"\n+           and then (Pattern (Pattern'Last - 2) = '/'\n+                     or else Pattern (Pattern'Last - 2) = Directory_Separator)\n+         then\n+            Name_Len := Pattern'Length - 3;\n+\n+            if Name_Len = 0 then\n+\n+               --  Case of \"/**\": all directories in file system\n+\n+               Name_Len := 1;\n+               Name_Buffer (1) := Pattern (Pattern'First);\n+\n+            else\n+               Name_Buffer (1 .. Name_Len) :=\n+                 Pattern (Pattern'First .. Pattern'Last - 3);\n+            end if;\n+\n+            if Current_Verbosity = High then\n+               Write_Str (\"Looking for all subdirectories of \"\"\");\n+               Write_Str (Name_Buffer (1 .. Name_Len));\n+               Write_Line (\"\"\"\");\n+            end if;\n+\n+            declare\n+               Base_Dir : constant File_Name_Type := Name_Find;\n+               Root_Dir : constant String :=\n+                 Normalize_Pathname\n+                   (Name          => Name_Buffer (1 .. Name_Len),\n+                    Directory     => Project_Dir,\n+                    Resolve_Links => Resolve_Links);\n+               Has_Error : Boolean := False;\n+\n+            begin\n+               if Root_Dir'Length = 0 then\n+                  Err_Vars.Error_Msg_File_1 := Base_Dir;\n+                  Error_Or_Warning\n+                    (Data.Flags, Data.Flags.Missing_Source_Files,\n+                     \"{ is not a valid directory.\", Location, Project);\n+                  Has_Error := Data.Flags.Missing_Source_Files = Error;\n+               end if;\n+\n+               if not Has_Error then\n+\n+                  --  We have an existing directory, we register it and all of\n+                  --  its subdirectories.\n+\n+                  if Current_Verbosity = High then\n+                     Write_Line (\"Looking for source directories:\");\n+                  end if;\n+\n+                  if Root_Dir (Root_Dir'Last) /= Directory_Separator then\n+                     Recursive_Find_Dirs\n+                       (Root_Dir & Directory_Separator, Rank);\n+                  else\n+                     Recursive_Find_Dirs (Root_Dir, Rank);\n+                  end if;\n+\n+                  if Current_Verbosity = High then\n+                     Write_Line (\"End of looking for source directories.\");\n+                  end if;\n+               end if;\n+            end;\n+\n+            --  We have a single directory\n+\n+         else\n+            declare\n+               Directory  : File_Name_Type;\n+               Path_Name  : Path_Information;\n+               Dir_Exists : Boolean;\n+               Has_Error  : Boolean := False;\n+\n+            begin\n+               Name_Len := Pattern'Length;\n+               Name_Buffer (1 .. Name_Len) := Pattern;\n+               Directory := Name_Find;\n+\n+               Locate_Directory\n+                 (Project     => Project,\n+                  Name        => Directory,\n+                  Path        => Path_Name,\n+                  Dir_Exists  => Dir_Exists,\n+                  Data        => Data,\n+                  Must_Exist  => False);\n+\n+               if not Dir_Exists then\n+                  Err_Vars.Error_Msg_File_1 := Directory;\n+                  Error_Or_Warning\n+                    (Data.Flags, Data.Flags.Missing_Source_Files,\n+                     \"{ is not a valid directory\", Location, Project);\n+                  Has_Error := Data.Flags.Missing_Source_Files = Error;\n+               end if;\n+\n+               if not Has_Error then\n+\n+                  --  Links have been resolved if necessary, and Path_Name\n+                  --  always ends with a directory separator.\n+\n+                  Callback (Path_Name.Name, Path_Name.Display_Name, Rank);\n+               end if;\n+            end;\n+         end if;\n+      end Find_Pattern;\n+\n+      --  Start of processing for Expand_Subdirectory_Pattern\n+\n+      Pattern_Id : String_List_Id := Patterns;\n+      Element    : String_Element;\n+      Rank       : Natural := 1;\n+   begin\n+      while Pattern_Id /= Nil_String loop\n+         Element := Data.Tree.String_Elements.Table (Pattern_Id);\n+         Find_Pattern\n+           (Get_Name_String (Element.Value), Rank, Element.Location);\n+         Rank := Rank + 1;\n+         Pattern_Id := Element.Next;\n+      end loop;\n+\n+      Recursive_Dirs.Reset (Visited);\n+   end Expand_Subdirectory_Pattern;\n+\n    ------------------------\n    -- Search_Directories --\n    ------------------------"}]}