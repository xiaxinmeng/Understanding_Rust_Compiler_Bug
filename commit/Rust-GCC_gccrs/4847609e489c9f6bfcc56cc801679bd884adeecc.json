{"sha": "4847609e489c9f6bfcc56cc801679bd884adeecc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg0NzYwOWU0ODljOWY2YmZjYzU2Y2M4MDE2NzliZDg4NGFkZWVjYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-07-25T21:03:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-07-25T21:03:34Z"}, "message": "typeck.c (inline_conversion): Remove.\n\n\t* typeck.c (inline_conversion): Remove.\n\t(cp_build_function_call): Do not use inline_conversion.\n\t* decl.c (duplicate_decls): Do not insist on inline being declared\n\tearly.\n\t(start_cleanup_fn): Do not assume that INLINE flags prevent function\n\tfrom being output.  We now remove static functions always.\n\t(finish_function): Do return warning on all static functions.\n\t* call.c (build_over_call): Do not use inline_conversion.\n\t* cp-tree.h (possibly_inlined_p): Declare.\n\t(inline_conversion): Remove.\n\t* pt.c (instantiate_decl): Use possibly_inlined_p predicate.\n\t* decl2.c (cp_write_global_declarations): Likewise.\n\t(mark_used): Likewise.\n\t(possibly_inlined_p): New functions.\n\nFrom-SVN: r138150", "tree": {"sha": "d3bfc3661c16812927eeef09a645e03c0bedb445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3bfc3661c16812927eeef09a645e03c0bedb445"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4847609e489c9f6bfcc56cc801679bd884adeecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4847609e489c9f6bfcc56cc801679bd884adeecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4847609e489c9f6bfcc56cc801679bd884adeecc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4847609e489c9f6bfcc56cc801679bd884adeecc/comments", "author": null, "committer": null, "parents": [{"sha": "1fc8feb560d1cca0c0a6189a8635b05de8a8fa3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc8feb560d1cca0c0a6189a8635b05de8a8fa3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fc8feb560d1cca0c0a6189a8635b05de8a8fa3d"}], "stats": {"total": 91, "additions": 48, "deletions": 43}, "files": [{"sha": "be50af5301dd2bc5572041bb2334c23fadb1b734", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4847609e489c9f6bfcc56cc801679bd884adeecc", "patch": "@@ -1,3 +1,20 @@\n+2008-07-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* typeck.c (inline_conversion): Remove.\n+\t(cp_build_function_call): Do not use inline_conversion.\n+\t* decl.c (duplicate_decls): Do not insist on inline being declared\n+\tearly.\n+\t(start_cleanup_fn): Do not assume that INLINE flags prevent function\n+\tfrom being output.  We now remove static functions always.\n+\t(finish_function): Do return warning on all static functions.\n+\t* call.c (build_over_call): Do not use inline_conversion.\n+\t* cp-tree.h (possibly_inlined_p): Declare.\n+\t(inline_conversion): Remove.\n+\t* pt.c (instantiate_decl): Use possibly_inlined_p predicate.\n+\t* decl2.c (cp_write_global_declarations): Likewise.\n+\t(mark_used): Likewise.\n+\t(possibly_inlined_p): New functions.\n+\n 2008-07-25  Jason Merrill  <jason@redhat.com>\n \n \t* class.c (type_has_user_provided_default_constructor): Handle"}, {"sha": "cb07c82f1ab884913c7e35c42808a3cc2ff5ad2d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4847609e489c9f6bfcc56cc801679bd884adeecc", "patch": "@@ -5400,8 +5400,6 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \tfn = build_vfn_ref (argarray[0], DECL_VINDEX (fn));\n       TREE_TYPE (fn) = t;\n     }\n-  else if (DECL_INLINE (fn))\n-    fn = inline_conversion (fn);\n   else\n     fn = build_addr_func (fn);\n "}, {"sha": "13c1797795f782ee0eef91e6c7e444a64a63c6d6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4847609e489c9f6bfcc56cc801679bd884adeecc", "patch": "@@ -4334,6 +4334,7 @@ extern void mark_needed\t\t\t\t(tree);\n extern bool decl_needed_p\t\t\t(tree);\n extern void note_vague_linkage_fn\t\t(tree);\n extern tree build_artificial_parm\t\t(tree, tree);\n+extern bool possibly_inlined_p\t\t\t(tree);\n \n /* in error.c */\n extern void init_error\t\t\t\t(void);\n@@ -4812,7 +4813,6 @@ extern int comp_cv_qual_signature\t\t(tree, tree);\n extern tree cxx_sizeof_or_alignof_expr\t\t(tree, enum tree_code, bool);\n extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool);\n extern tree cxx_sizeof_nowarn                   (tree);\n-extern tree inline_conversion\t\t\t(tree);\n extern tree is_bitfield_expr_with_lowered_type  (const_tree);\n extern tree unlowered_expr_type                 (const_tree);\n extern tree decay_conversion\t\t\t(tree);"}, {"sha": "b762f680d8339736f2ca656b404bcd603bd41c6a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4847609e489c9f6bfcc56cc801679bd884adeecc", "patch": "@@ -1551,14 +1551,6 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\t\t\t olddecl);\n \t\t  }\n \t      }\n-\n-\t  if (DECL_DECLARED_INLINE_P (newdecl)\n-\t      && ! DECL_DECLARED_INLINE_P (olddecl)\n-\t      && TREE_ADDRESSABLE (olddecl) && warn_inline)\n-\t    {\n-\t      warning (0, \"%q#D was used before it was declared inline\", newdecl);\n-\t      warning (0, \"%Jprevious non-inline declaration here\", olddecl);\n-\t    }\n \t}\n     }\n \n@@ -5954,8 +5946,6 @@ start_cleanup_fn (void)\n      actually needed.  It is unlikely that it will be inlined, since\n      it is only called via a function pointer, but we avoid unnecessary\n      emissions this way.  */\n-  DECL_INLINE (fndecl) = 1;\n-  DECL_DECLARED_INLINE_P (fndecl) = 1;\n   DECL_INTERFACE_KNOWN (fndecl) = 1;\n   /* Build the parameter.  */\n   if (use_cxa_atexit)\n@@ -12011,13 +12001,15 @@ finish_function (int flags)\n       /* Don't complain if we abort or throw.  */\n       && !current_function_returns_abnormally\n       && !DECL_NAME (DECL_RESULT (fndecl))\n-      /* Normally, with -Wreturn-type, flow will complain.  Unless we're an\n-\t inline function, as we might never be compiled separately.  */\n-      && (DECL_INLINE (fndecl) || processing_template_decl)\n+      && !TREE_NO_WARNING (fndecl)\n       /* Structor return values (if any) are set by the compiler.  */\n       && !DECL_CONSTRUCTOR_P (fndecl)\n       && !DECL_DESTRUCTOR_P (fndecl))\n-    warning (OPT_Wreturn_type, \"no return statement in function returning non-void\");\n+    {\n+      warning (OPT_Wreturn_type,\n+ \t       \"no return statement in function returning non-void\");\n+      TREE_NO_WARNING (fndecl) = 1;\n+    }\n \n   /* Store the end of the function, so that we get good line number\n      info for the epilogue.  */"}, {"sha": "a156e32dcdb9227dfbb991677f1f14a08034bbde", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4847609e489c9f6bfcc56cc801679bd884adeecc", "patch": "@@ -3422,7 +3422,7 @@ cp_write_global_declarations (void)\n \t{\n \t  /* Does it need synthesizing?  */\n \t  if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n-\t      && (! DECL_REALLY_EXTERN (decl) || DECL_INLINE (decl)))\n+\t      && (! DECL_REALLY_EXTERN (decl) || possibly_inlined_p (decl)))\n \t    {\n \t      /* Even though we're already at the top-level, we push\n \t\t there again.  That way, when we pop back a few lines\n@@ -3683,6 +3683,22 @@ check_default_args (tree x)\n     }\n }\n \n+/* Return true if function DECL can be inlined.  This is used to force\n+   instantiation of methods that might be interesting for inlining.  */\n+bool\n+possibly_inlined_p (tree decl)\n+{\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+  if (DECL_UNINLINABLE (decl))\n+    return false;\n+  if (!optimize)\n+    return DECL_DECLARED_INLINE_P (decl);\n+  /* When optimizing, we might inline everything when flatten\n+     attribute or heuristics inlining for size or autoinlining\n+     is used.  */\n+  return true;\n+}\n+\n /* Mark DECL (either a _DECL or a BASELINK) as \"used\" in the program.\n    If DECL is a specialization or implicitly declared class member,\n    generate the actual definition.  */\n@@ -3780,8 +3796,9 @@ mark_used (tree decl)\n \t   && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n \t   && (!DECL_EXPLICIT_INSTANTIATION (decl)\n \t       || (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t   && DECL_INLINE (DECL_TEMPLATE_RESULT\n-\t\t\t\t   (template_for_substitution (decl))))\n+\t\t   && possibly_inlined_p\n+\t\t       (DECL_TEMPLATE_RESULT (\n+\t\t         template_for_substitution (decl))))\n \t       /* We need to instantiate static data members so that there\n \t\t  initializers are available in integral constant\n \t\t  expressions.  */"}, {"sha": "b47ee5e6b3f842d6c178e8cf3efbf0fdde6210f6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4847609e489c9f6bfcc56cc801679bd884adeecc", "patch": "@@ -15144,7 +15144,8 @@ instantiate_decl (tree d, int defer_ok,\n   if (external_p\n       /* ... but we instantiate inline functions so that we can inline\n \t them and ... */\n-      && ! (TREE_CODE (d) == FUNCTION_DECL && DECL_INLINE (d))\n+      && ! (TREE_CODE (d) == FUNCTION_DECL\n+\t    && possibly_inlined_p (d))\n       /* ... we instantiate static data members whose values are\n \t needed in integral constant expressions.  */\n       && ! (TREE_CODE (d) == VAR_DECL\n@@ -15221,8 +15222,7 @@ instantiate_decl (tree d, int defer_ok,\n       /* Instantiate inline functions so that the inliner can do its\n \t job, even though we'll not be emitting a copy of this\n \t function.  */\n-      if (!(TREE_CODE (d) == FUNCTION_DECL\n-\t    && DECL_DECLARED_INLINE_P (d)))\n+      if (!(TREE_CODE (d) == FUNCTION_DECL && possibly_inlined_p (d)))\n \tgoto out;\n     }\n "}, {"sha": "fcf52dc9db42b67bd2d234c174bb0a46f455f7b0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4847609e489c9f6bfcc56cc801679bd884adeecc/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4847609e489c9f6bfcc56cc801679bd884adeecc", "patch": "@@ -1698,18 +1698,6 @@ perform_integral_promotions (tree expr)\n   return expr;\n }\n \n-/* Take the address of an inline function without setting TREE_ADDRESSABLE\n-   or TREE_USED.  */\n-\n-tree\n-inline_conversion (tree exp)\n-{\n-  if (TREE_CODE (exp) == FUNCTION_DECL)\n-    exp = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (exp)), exp);\n-\n-  return exp;\n-}\n-\n /* Returns nonzero iff exp is a STRING_CST or the result of applying\n    decay_conversion to one.  */\n \n@@ -2828,14 +2816,7 @@ cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n \tpedwarn (OPT_pedantic, \n \t\t \"ISO C++ forbids calling %<::main%> from within program\");\n \n-      /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n-\t (because calling an inline function does not mean the function\n-\t needs to be separately compiled).  */\n-\n-      if (DECL_INLINE (function))\n-\tfunction = inline_conversion (function);\n-      else\n-\tfunction = build_addr_func (function);\n+      function = build_addr_func (function);\n     }\n   else\n     {"}]}