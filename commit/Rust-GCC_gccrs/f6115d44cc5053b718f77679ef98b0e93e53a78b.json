{"sha": "f6115d44cc5053b718f77679ef98b0e93e53a78b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxMTVkNDRjYzUwNTNiNzE4Zjc3Njc5ZWY5OGIwZTkzZTUzYTc4Yg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2015-03-03T21:57:40Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2015-03-03T21:57:40Z"}, "message": "rl78-real.md (*addqi_real): Allow SADDR types for inc/dec.\n\n* config/rl78/rl78-real.md (*addqi_real): Allow SADDR types for\ninc/dec.\n(*addhi3_real): Likewise.\n* config/rl78/rl78-virt.md (*inc<mode>3_virt): Additional\npattern to match incrementing memory.\n* config/rl78/predicates.md (rl78_1_2_operand): New.\n* config/rl78/rl78.c (rl78_force_nonfar_3): Allow far mem-mem if\nit's the same and only mem.\n(rl78_alloc_physical_registers_op2): If there's effectively only\none MEM, transcode it into HL.\n(rl78_far_p): Reject addresses that aren't legitimate.\n\nFrom-SVN: r221164", "tree": {"sha": "b65c48df3c7c3220b2fcf01d2911f9bc100b1295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b65c48df3c7c3220b2fcf01d2911f9bc100b1295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6115d44cc5053b718f77679ef98b0e93e53a78b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6115d44cc5053b718f77679ef98b0e93e53a78b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6115d44cc5053b718f77679ef98b0e93e53a78b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6115d44cc5053b718f77679ef98b0e93e53a78b/comments", "author": null, "committer": null, "parents": [{"sha": "bf66b9b45c6cf6bccd2791d7c091759b2ad35437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf66b9b45c6cf6bccd2791d7c091759b2ad35437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf66b9b45c6cf6bccd2791d7c091759b2ad35437"}], "stats": {"total": 74, "additions": 67, "deletions": 7}, "files": [{"sha": "10f36fa3558747ceb3b5f4cd36b4c91f239a586a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6115d44cc5053b718f77679ef98b0e93e53a78b", "patch": "@@ -1,3 +1,17 @@\n+2015-03-03  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/rl78/rl78-real.md (*addqi_real): Allow SADDR types for\n+\tinc/dec.\n+\t(*addhi3_real): Likewise.\n+\t* config/rl78/rl78-virt.md (*inc<mode>3_virt): Additional\n+\tpattern to match incrementing memory.\n+\t* config/rl78/predicates.md (rl78_1_2_operand): New.\n+\t* config/rl78/rl78.c (rl78_force_nonfar_3): Allow far mem-mem if\n+\tit's the same and only mem.\n+\t(rl78_alloc_physical_registers_op2): If there's effectively only\n+\tone MEM, transcode it into HL.\n+\t(rl78_far_p): Reject addresses that aren't legitimate.\n+\n 2015-03-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* fold-const.c (round_up_loc): Cast divisor to HOST_WIDE_INT before"}, {"sha": "66e7e44827d08f192b3d1c1b148f3e8fe00d4c51", "filename": "gcc/config/rl78/predicates.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2Fconfig%2Frl78%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2Fconfig%2Frl78%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Fpredicates.md?ref=f6115d44cc5053b718f77679ef98b0e93e53a78b", "patch": "@@ -58,6 +58,21 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), 0, 255)\")))\n \n+(define_predicate \"rl78_incdec_memory_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"rl78_far_p (op)\n+|| satisfies_constraint_Wsa (op)\n+|| satisfies_constraint_Whl (op)\n+|| satisfies_constraint_Wh1 (op)\n+|| satisfies_constraint_Wab (op)\")\n+  )\n+)\n+\n+(define_predicate \"rl78_1_2_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 1, 2)\n+\t\t   || IN_RANGE (INTVAL (op), -2, -1)\")))\n+\n (define_predicate \"rl78_24_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) == 2 || INTVAL (op) == 4\")))"}, {"sha": "cfd9742a5d7090f0d5d83a8b1d401cac41daeddb", "filename": "gcc/config/rl78/rl78-real.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2Fconfig%2Frl78%2Frl78-real.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2Fconfig%2Frl78%2Frl78-real.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-real.md?ref=f6115d44cc5053b718f77679ef98b0e93e53a78b", "patch": "@@ -113,22 +113,22 @@\n ;;---------- Arithmetic ------------------------\n \n (define_insn \"*addqi3_real\"\n-  [(set (match_operand:QI          0 \"rl78_nonimmediate_operand\"  \"=rvWabWhlWh1,rvWabWhlWh1,a,*bcdehl,Wsa\")\n+  [(set (match_operand:QI          0 \"rl78_nonimmediate_operand\"  \"=rvWabWhlWh1Wsa,rvWabWhlWh1Wsa,a,*bcdehl,Wsa\")\n \t(plus:QI (match_operand:QI 1 \"rl78_general_operand\"  \"%0,0,0,0,0\")\n \t\t (match_operand:QI 2 \"rl78_general_operand\" \"K,L,RWhlWh1Wabi,a,i\")))\n    ]\n   \"rl78_real_insns_ok ()\"\n   \"@\n-    inc\\t%0\n-    dec\\t%0\n+    inc\\t%p0\n+    dec\\t%p0\n     add\\t%0, %2\n     add\\t%0, %2\n     add\\t%0, %2\"\n   [(set (attr \"update_Z\") (const_string \"update_Z\"))]\n )\n \n (define_insn \"*addhi3_real\"\n-  [(set (match_operand:HI          0 \"rl78_nonimmediate_operand\"  \"=vABDTWh1Wab,vABDTWh1Wab,v,v,A,S,S,A\")\n+  [(set (match_operand:HI          0 \"rl78_nonimmediate_operand\"  \"=vABDTWhlWh1WabWsa,vABDTWhlWh1WabWsa,v,v,A,S,S,A\")\n \t(plus:HI (match_operand:HI 1 \"rl78_general_operand\"  \"%0,0,0,0,0,0,0,S\")\n \t\t (match_operand:HI 2 \"\" \"K,L,N,O,RWh1WhlWabiv,Int8Qs8,J,Ri\")))\n    ]"}, {"sha": "c29db26da80509164b82b8b368f0e6c94da9d266", "filename": "gcc/config/rl78/rl78-virt.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-virt.md?ref=f6115d44cc5053b718f77679ef98b0e93e53a78b", "patch": "@@ -85,6 +85,15 @@\n \n ;;---------- Arithmetic ------------------------\n \n+(define_insn \"*inc<mode>3_virt\"\n+  [(set (match_operand:QHI           0 \"rl78_incdec_memory_operand\" \"=vm\")\n+\t(plus:QHI (match_operand:QHI 1 \"rl78_incdec_memory_operand\" \"0\")\n+\t\t  (match_operand:QHI 2 \"rl78_1_2_operand\" \"KLNO\")))\n+   ]\n+  \"rl78_virt_insns_ok ()\"\n+  \"v.inc\\t%0, %1, %2\"\n+)\n+\n (define_insn \"*add<mode>3_virt\"\n   [(set (match_operand:QHI           0 \"rl78_nonfar_nonimm_operand\" \"=vY,S\")\n \t(plus:QHI (match_operand:QHI 1 \"rl78_nonfar_operand\" \"viY,0\")"}, {"sha": "0c577c4414e02c421d1a3c845337db5d4e036cd0", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6115d44cc5053b718f77679ef98b0e93e53a78b/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=f6115d44cc5053b718f77679ef98b0e93e53a78b", "patch": "@@ -579,6 +579,13 @@ rl78_force_nonfar_3 (rtx *operands, rtx (*gen)(rtx,rtx,rtx))\n   int did = 0;\n   rtx temp_reg = NULL;\n \n+  /* As an exception, we allow two far operands if they're identical\n+     and the third operand is not a MEM.  This allows global variables\n+     to be incremented, for example.  */\n+  if (rtx_equal_p (operands[0], operands[1])\n+      && ! MEM_P (operands[2]))\n+    return 0;\n+\n   /* FIXME: Likewise.  */\n   if (rl78_far_p (operands[1]))\n     {\n@@ -970,6 +977,12 @@ rl78_far_p (rtx x)\n   fprintf (stderr, \"\\033[35mrl78_far_p: \"); debug_rtx (x);\n   fprintf (stderr, \" = %d\\033[0m\\n\", MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR);\n #endif\n+\n+  /* Not all far addresses are legitimate, because the devirtualizer\n+     can't handle them.  */\n+  if (! rl78_as_legitimate_address (GET_MODE (x), XEXP (x, 0), false, ADDR_SPACE_FAR))\n+    return 0;\n+\n   return GET_MODE_BITSIZE (rl78_addr_space_address_mode (MEM_ADDR_SPACE (x))) == 32;\n }\n \n@@ -3007,9 +3020,18 @@ rl78_alloc_physical_registers_op2 (rtx_insn * insn)\n \n   if (rtx_equal_p (OP (0), OP (1)))\n     {\n-      OP (0) =\n-      OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n-      OP (2) = transcode_memory_rtx (OP (2), HL, insn);\n+      if (MEM_P (OP (2)))\n+\t{\n+\t  OP (0) =\n+\t  OP (1) = transcode_memory_rtx (OP (1), DE, insn);\n+\t  OP (2) = transcode_memory_rtx (OP (2), HL, insn);\n+\t}\n+      else\n+\t{\n+\t  OP (0) =\n+\t  OP (1) = transcode_memory_rtx (OP (1), HL, insn);\n+\t  OP (2) = transcode_memory_rtx (OP (2), DE, insn);\n+\t}\n     }\n   else if (rtx_equal_p (OP (0), OP (2)))\n     {"}]}