{"sha": "4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU5ZDU4ZDE2NzY3YjFiYzY4NmYwYzRiM2JkMmRhMjVkYzcxZThmMw==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2019-11-08T13:52:56Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2019-11-08T13:52:56Z"}, "message": "[vect] PR 92351: When peeling for alignment make alignment of epilogues unknown\n\ngcc/ChangeLog:\n2019-11-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\tPR tree-optimization/92351\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): When we are\n\tpeeling the main loop for alignment, make sure to set the misalignment\n\tof the epilogue's data references to DR_MISALIGNMENT_UNKNOWN.\n\ngcc/testsuite/ChangeLog:\n2019-11-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\tPR tree-optimization/92351\n\t* gcc.dg/vect/vect-peel-2.c: Disable epilogue vectorization and\n\tsplit the source of this test to...\n\t* gcc.dg/vect/vect-peel-2-src.c: ... This.\n\t* gcc.dg/vect/vect-peel-2-epilogues.c: New test.\n\nFrom-SVN: r277974", "tree": {"sha": "795f7853092339a2e3fdb5c58960edf7e4cd39dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/795f7853092339a2e3fdb5c58960edf7e4cd39dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14df3a17aa243fd58be2aa03f787a2da5c94ae97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14df3a17aa243fd58be2aa03f787a2da5c94ae97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14df3a17aa243fd58be2aa03f787a2da5c94ae97"}], "stats": {"total": 128, "additions": 81, "deletions": 47}, "files": [{"sha": "b61665df3e80de23f6016ec0d7f79ac3239f3e29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "patch": "@@ -1,3 +1,10 @@\n+2019-11-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tPR tree-optimization/92351\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): When we are\n+\tpeeling the main loop for alignment, make sure to set the misalignment\n+\tof the epilogue's data references to DR_MISALIGNMENT_UNKNOWN.\n+\n 2019-11-08  Richard Biener  <rguenther@suse.de>\n \n \t* dbgcnt.def (ivopts_loop): Add."}, {"sha": "55b0c5abe02868e17aff4c1f7aab5e8d8467a37c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "patch": "@@ -1,3 +1,11 @@\n+2019-11-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tPR tree-optimization/92351\n+\t* gcc.dg/vect/vect-peel-2.c: Disable epilogue vectorization and\n+\tsplit the source of this test to...\n+\t* gcc.dg/vect/vect-peel-2-src.c: ... This.\n+\t* gcc.dg/vect/vect-peel-2-epilogues.c: New test.\n+\n 2019-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.c-torture/compile/20191108-1.c: New test."}, {"sha": "c06fa442fafa36855d285d2336e0d69ee9bffe03", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-2-epilogues.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2-epilogues.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2-epilogues.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2-epilogues.c?ref=4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"vect-peel-2-src.c\""}, {"sha": "f6fc134c8705567a628dcd62c053ad6f2ca2904d", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-2-src.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2-src.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2-src.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2-src.c?ref=4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "patch": "@@ -0,0 +1,48 @@\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+/* unaligned store.  */\n+\n+int ib[N+7];\n+\n+__attribute__ ((noinline))\n+int main1 ()\n+{\n+  int i;\n+  int ia[N+1];\n+\n+  /* The store is aligned and the loads are misaligned with the same \n+     misalignment. Cost model is disabled. If misaligned stores are supported,\n+     we peel according to the loads to align them.  */\n+  for (i = 0; i <= N; i++)\n+    {\n+      ia[i] = ib[i+2] + ib[i+6];\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      if (ia[i] != ib[i+2] + ib[i+6])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i <= N+6; i++)\n+    {\n+      asm volatile (\"\" : \"+r\" (i));\n+      ib[i] = i;\n+    }\n+\n+  return main1 ();\n+}\n+"}, {"sha": "65e70bd44170c63ce3bc25c6a7ecf426ddcd39b1", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-2.c", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c?ref=4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "patch": "@@ -1,52 +1,8 @@\n /* { dg-require-effective-target vect_int } */\n+/* Disabling epilogues until we find a better way to deal with scans.  */\n+/* { dg-additional-options \"--param vect-epilogues-nomask=0\" } */\n \n-#include <stdarg.h>\n-#include \"tree-vect.h\"\n-\n-#define N 128\n-\n-/* unaligned store.  */\n-\n-int ib[N+7];\n-\n-__attribute__ ((noinline))\n-int main1 ()\n-{\n-  int i;\n-  int ia[N+1];\n-\n-  /* The store is aligned and the loads are misaligned with the same \n-     misalignment. Cost model is disabled. If misaligned stores are supported,\n-     we peel according to the loads to align them.  */\n-  for (i = 0; i <= N; i++)\n-    {\n-      ia[i] = ib[i+2] + ib[i+6];\n-    }\n-\n-  /* check results:  */\n-  for (i = 1; i <= N; i++)\n-    {\n-      if (ia[i] != ib[i+2] + ib[i+6])\n-        abort ();\n-    }\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{ \n-  int i;\n-\n-  check_vect ();\n-\n-  for (i = 0; i <= N+6; i++)\n-    {\n-      asm volatile (\"\" : \"+r\" (i));\n-      ib[i] = i;\n-    }\n-\n-  return main1 ();\n-}\n+#include \"vect-peel-2-src.c\"\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */"}, {"sha": "88f14e73d65acd3026d72a2698212f4f0a5a6409", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=4e9d58d16767b1bc686f0c4b3bd2da25dc71e8f3", "patch": "@@ -938,6 +938,18 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n     = exact_div (vect_calculate_target_alignment (dr_info), BITS_PER_UNIT);\n   DR_TARGET_ALIGNMENT (dr_info) = vector_alignment;\n \n+  /* If the main loop has peeled for alignment we have no way of knowing\n+     whether the data accesses in the epilogues are aligned.  We can't at\n+     compile time answer the question whether we have entered the main loop or\n+     not.  Fixes PR 92351.  */\n+  if (loop_vinfo)\n+    {\n+      loop_vec_info orig_loop_vinfo = LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo);\n+      if (orig_loop_vinfo\n+\t  && LOOP_VINFO_PEELING_FOR_ALIGNMENT (orig_loop_vinfo) != 0)\n+\treturn;\n+    }\n+\n   unsigned HOST_WIDE_INT vect_align_c;\n   if (!vector_alignment.is_constant (&vect_align_c))\n     return;"}]}