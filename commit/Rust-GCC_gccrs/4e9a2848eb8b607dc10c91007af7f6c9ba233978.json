{"sha": "4e9a2848eb8b607dc10c91007af7f6c9ba233978", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU5YTI4NDhlYjhiNjA3ZGMxMGM5MTAwN2FmN2Y2YzliYTIzMzk3OA==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-09-03T08:17:00Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-09-03T08:17:00Z"}, "message": "[NDS32] Refine the implementation and consider CFA restore information for stack push/pop multiple.\n\n\t* config/nds32/nds32.c (nds32_gen_stack_push_multiple): Rename to ...\n\t(nds32_emit_stack_push_multiple): ... this.\n\t(nds32_gen_stack_pop_multiple): Rename to ...\n\t(nds32_emit_stack_pop_multiple): ... this and consider CFA restore\n\tinformation.\n\nFrom-SVN: r214851", "tree": {"sha": "dddc95a545f054b8bbad5c1e2150ecf1a71afd25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dddc95a545f054b8bbad5c1e2150ecf1a71afd25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e9a2848eb8b607dc10c91007af7f6c9ba233978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9a2848eb8b607dc10c91007af7f6c9ba233978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9a2848eb8b607dc10c91007af7f6c9ba233978", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9a2848eb8b607dc10c91007af7f6c9ba233978/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7d19263fe7c484b127c133eb33e9743f0642e5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d19263fe7c484b127c133eb33e9743f0642e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d19263fe7c484b127c133eb33e9743f0642e5e"}], "stats": {"total": 105, "additions": 69, "deletions": 36}, "files": [{"sha": "ccd106294866c3d692ae8e504628b48ce56d0a08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9a2848eb8b607dc10c91007af7f6c9ba233978/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9a2848eb8b607dc10c91007af7f6c9ba233978/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e9a2848eb8b607dc10c91007af7f6c9ba233978", "patch": "@@ -1,3 +1,11 @@\n+2014-09-03  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32.c (nds32_gen_stack_push_multiple): Rename to ...\n+\t(nds32_emit_stack_push_multiple): ... this.\n+\t(nds32_gen_stack_pop_multiple): Rename to ...\n+\t(nds32_emit_stack_pop_multiple): ... this and consider CFA restore\n+\tinformation.\n+\n 2014-09-03  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \tPR target/61078"}, {"sha": "22762c716ca796c8cf16dbc6dfb2854631d74d26", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 61, "deletions": 36, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9a2848eb8b607dc10c91007af7f6c9ba233978/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9a2848eb8b607dc10c91007af7f6c9ba233978/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=4e9a2848eb8b607dc10c91007af7f6c9ba233978", "patch": "@@ -347,15 +347,15 @@ nds32_compute_stack_frame (void)\n    The overall concept are:\n      \"push registers to memory\",\n      \"adjust stack pointer\".  */\n-static rtx\n-nds32_gen_stack_push_multiple (rtx Rb, rtx Re,\n-\t\t\t       rtx En4 ATTRIBUTE_UNUSED)\n+static void\n+nds32_emit_stack_push_multiple (rtx Rb, rtx Re, rtx En4)\n {\n   int regno;\n   int extra_count;\n   int num_use_regs;\n   int par_index;\n   int offset;\n+  int save_fp, save_gp, save_lp;\n \n   rtx reg;\n   rtx mem;\n@@ -382,13 +382,18 @@ nds32_gen_stack_push_multiple (rtx Rb, rtx Re,\n                 (set (reg:SI SP_REGNUM)\n                      (plus (reg:SI SP_REGNUM) (const_int -32)))]) */\n \n+  /* Determine whether we need to save $fp, $gp, or $lp.  */\n+  save_fp = INTVAL (En4) & 0x8;\n+  save_gp = INTVAL (En4) & 0x4;\n+  save_lp = INTVAL (En4) & 0x2;\n+\n   /* Calculate the number of registers that will be pushed.  */\n   extra_count = 0;\n-  if (cfun->machine->fp_size)\n+  if (save_fp)\n     extra_count++;\n-  if (cfun->machine->gp_size)\n+  if (save_gp)\n     extra_count++;\n-  if (cfun->machine->lp_size)\n+  if (save_lp)\n     extra_count++;\n   /* Note that Rb and Re may be SP_REGNUM.  DO NOT count it in.  */\n   if (REGNO (Rb) == SP_REGNUM && REGNO (Re) == SP_REGNUM)\n@@ -411,7 +416,7 @@ nds32_gen_stack_push_multiple (rtx Rb, rtx Re,\n       /* Rb and Re may be SP_REGNUM.\n          We need to break this loop immediately.  */\n       if (regno == SP_REGNUM)\n-        break;\n+\tbreak;\n \n       reg = gen_rtx_REG (SImode, regno);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -425,7 +430,7 @@ nds32_gen_stack_push_multiple (rtx Rb, rtx Re,\n     }\n \n   /* Create (set mem fp), (set mem gp), and (set mem lp) if necessary.  */\n-  if (cfun->machine->fp_size)\n+  if (save_fp)\n     {\n       reg = gen_rtx_REG (SImode, FP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -437,7 +442,7 @@ nds32_gen_stack_push_multiple (rtx Rb, rtx Re,\n       offset = offset + 4;\n       par_index++;\n     }\n-  if (cfun->machine->gp_size)\n+  if (save_gp)\n     {\n       reg = gen_rtx_REG (SImode, GP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -449,7 +454,7 @@ nds32_gen_stack_push_multiple (rtx Rb, rtx Re,\n       offset = offset + 4;\n       par_index++;\n     }\n-  if (cfun->machine->lp_size)\n+  if (save_lp)\n     {\n       reg = gen_rtx_REG (SImode, LP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -473,29 +478,35 @@ nds32_gen_stack_push_multiple (rtx Rb, rtx Re,\n   XVECEXP (parallel_insn, 0, par_index) = adjust_sp_rtx;\n   RTX_FRAME_RELATED_P (adjust_sp_rtx) = 1;\n \n-  return parallel_insn;\n+  parallel_insn = emit_insn (parallel_insn);\n+\n+  /* The insn rtx 'parallel_insn' will change frame layout.\n+     We need to use RTX_FRAME_RELATED_P so that GCC is able to\n+     generate CFI (Call Frame Information) stuff.  */\n+  RTX_FRAME_RELATED_P (parallel_insn) = 1;\n }\n \n /* Function to create a parallel rtx pattern\n    which presents stack pop multiple behavior.\n    The overall concept are:\n      \"pop registers from memory\",\n      \"adjust stack pointer\".  */\n-static rtx\n-nds32_gen_stack_pop_multiple (rtx Rb, rtx Re,\n-\t\t\t      rtx En4 ATTRIBUTE_UNUSED)\n+static void\n+nds32_emit_stack_pop_multiple (rtx Rb, rtx Re, rtx En4)\n {\n   int regno;\n   int extra_count;\n   int num_use_regs;\n   int par_index;\n   int offset;\n+  int save_fp, save_gp, save_lp;\n \n   rtx reg;\n   rtx mem;\n   rtx pop_rtx;\n   rtx adjust_sp_rtx;\n   rtx parallel_insn;\n+  rtx dwarf = NULL_RTX;\n \n   /* We need to provide a customized rtx which contains\n      necessary information for data analysis,\n@@ -516,13 +527,18 @@ nds32_gen_stack_pop_multiple (rtx Rb, rtx Re,\n                 (set (reg:SI SP_REGNUM)\n                      (plus (reg:SI SP_REGNUM) (const_int 32)))]) */\n \n+  /* Determine whether we need to restore $fp, $gp, or $lp.  */\n+  save_fp = INTVAL (En4) & 0x8;\n+  save_gp = INTVAL (En4) & 0x4;\n+  save_lp = INTVAL (En4) & 0x2;\n+\n   /* Calculate the number of registers that will be poped.  */\n   extra_count = 0;\n-  if (cfun->machine->fp_size)\n+  if (save_fp)\n     extra_count++;\n-  if (cfun->machine->gp_size)\n+  if (save_gp)\n     extra_count++;\n-  if (cfun->machine->lp_size)\n+  if (save_lp)\n     extra_count++;\n   /* Note that Rb and Re may be SP_REGNUM.  DO NOT count it in.  */\n   if (REGNO (Rb) == SP_REGNUM && REGNO (Re) == SP_REGNUM)\n@@ -545,7 +561,7 @@ nds32_gen_stack_pop_multiple (rtx Rb, rtx Re,\n       /* Rb and Re may be SP_REGNUM.\n          We need to break this loop immediately.  */\n       if (regno == SP_REGNUM)\n-        break;\n+\tbreak;\n \n       reg = gen_rtx_REG (SImode, regno);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -556,10 +572,12 @@ nds32_gen_stack_pop_multiple (rtx Rb, rtx Re,\n       RTX_FRAME_RELATED_P (pop_rtx) = 1;\n       offset = offset + 4;\n       par_index++;\n+\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n     }\n \n   /* Create (set fp mem), (set gp mem), and (set lp mem) if necessary.  */\n-  if (cfun->machine->fp_size)\n+  if (save_fp)\n     {\n       reg = gen_rtx_REG (SImode, FP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -570,8 +588,10 @@ nds32_gen_stack_pop_multiple (rtx Rb, rtx Re,\n       RTX_FRAME_RELATED_P (pop_rtx) = 1;\n       offset = offset + 4;\n       par_index++;\n+\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n     }\n-  if (cfun->machine->gp_size)\n+  if (save_gp)\n     {\n       reg = gen_rtx_REG (SImode, GP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -582,8 +602,10 @@ nds32_gen_stack_pop_multiple (rtx Rb, rtx Re,\n       RTX_FRAME_RELATED_P (pop_rtx) = 1;\n       offset = offset + 4;\n       par_index++;\n+\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n     }\n-  if (cfun->machine->lp_size)\n+  if (save_lp)\n     {\n       reg = gen_rtx_REG (SImode, LP_REGNUM);\n       mem = gen_frame_mem (SImode, plus_constant (Pmode,\n@@ -594,6 +616,8 @@ nds32_gen_stack_pop_multiple (rtx Rb, rtx Re,\n       RTX_FRAME_RELATED_P (pop_rtx) = 1;\n       offset = offset + 4;\n       par_index++;\n+\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n     }\n \n   /* Create (set sp sp+x).  */\n@@ -604,9 +628,19 @@ nds32_gen_stack_pop_multiple (rtx Rb, rtx Re,\n \t\t   stack_pointer_rtx,\n \t\t   plus_constant (Pmode, stack_pointer_rtx, offset));\n   XVECEXP (parallel_insn, 0, par_index) = adjust_sp_rtx;\n-  RTX_FRAME_RELATED_P (adjust_sp_rtx) = 1;\n \n-  return parallel_insn;\n+  /* Tell gcc we adjust SP in this insn.  */\n+  dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, copy_rtx (adjust_sp_rtx), dwarf);\n+\n+  parallel_insn = emit_insn (parallel_insn);\n+\n+  /* The insn rtx 'parallel_insn' will change frame layout.\n+     We need to use RTX_FRAME_RELATED_P so that GCC is able to\n+     generate CFI (Call Frame Information) stuff.  */\n+  RTX_FRAME_RELATED_P (parallel_insn) = 1;\n+\n+  /* Add CFI info by manual.  */\n+  REG_NOTES (parallel_insn) = dwarf;\n }\n \n /* Function to create a parallel rtx pattern\n@@ -2629,7 +2663,7 @@ nds32_expand_prologue (void)\n   Rb = gen_rtx_REG (SImode, cfun->machine->callee_saved_regs_first_regno);\n   Re = gen_rtx_REG (SImode, cfun->machine->callee_saved_regs_last_regno);\n \n-  /* push_insn = gen_stack_push_multiple(first_regno, last_regno),\n+  /* nds32_emit_stack_push_multiple(first_regno, last_regno),\n      the pattern 'stack_push_multiple' is implemented in nds32.md.\n      For En4 field, we have to calculate its constant value.\n      Refer to Andes ISA for more information.  */\n@@ -2647,14 +2681,7 @@ nds32_expand_prologue (void)\n   if (!(REGNO (Rb) == SP_REGNUM && REGNO (Re) == SP_REGNUM && en4_const == 0))\n     {\n       /* Create multiple push instruction rtx.  */\n-      push_insn = nds32_gen_stack_push_multiple (Rb, Re, GEN_INT (en4_const));\n-      /* Emit rtx into instructions list and receive INSN rtx form.  */\n-      push_insn = emit_insn (push_insn);\n-\n-      /* The insn rtx 'push_insn' will change frame layout.\n-         We need to use RTX_FRAME_RELATED_P so that GCC is able to\n-         generate CFI (Call Frame Information) stuff.  */\n-      RTX_FRAME_RELATED_P (push_insn) = 1;\n+      nds32_emit_stack_push_multiple (Rb, Re, GEN_INT (en4_const));\n     }\n \n   /* Check frame_pointer_needed to see\n@@ -2791,7 +2818,7 @@ nds32_expand_epilogue (void)\n   Rb = gen_rtx_REG (SImode, cfun->machine->callee_saved_regs_first_regno);\n   Re = gen_rtx_REG (SImode, cfun->machine->callee_saved_regs_last_regno);\n \n-  /* pop_insn = gen_stack_pop_multiple(first_regno, last_regno),\n+  /* nds32_emit_stack_pop_multiple(first_regno, last_regno),\n      the pattern 'stack_pop_multiple' is implementad in nds32.md.\n      For En4 field, we have to calculate its constant value.\n      Refer to Andes ISA for more information.  */\n@@ -2809,9 +2836,7 @@ nds32_expand_epilogue (void)\n   if (!(REGNO (Rb) == SP_REGNUM && REGNO (Re) == SP_REGNUM && en4_const == 0))\n     {\n       /* Create multiple pop instruction rtx.  */\n-      pop_insn = nds32_gen_stack_pop_multiple (Rb, Re, GEN_INT (en4_const));\n-      /* Emit pop instruction.  */\n-      emit_insn (pop_insn);\n+      nds32_emit_stack_pop_multiple (Rb, Re, GEN_INT (en4_const));\n     }\n \n   /* Generate return instruction by using"}]}