{"sha": "4302db79108595d94210a96941129013edf335af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMwMmRiNzkxMDg1OTVkOTQyMTBhOTY5NDExMjkwMTNlZGYzMzVhZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-02-13T16:33:00Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-02-13T16:33:00Z"}, "message": "* config/h8300/h8300.md (a peephole2): New.\n\nFrom-SVN: r62842", "tree": {"sha": "a35b24a991f577abbe191ac58a24ba422a7920fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a35b24a991f577abbe191ac58a24ba422a7920fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4302db79108595d94210a96941129013edf335af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4302db79108595d94210a96941129013edf335af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4302db79108595d94210a96941129013edf335af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4302db79108595d94210a96941129013edf335af/comments", "author": null, "committer": null, "parents": [{"sha": "6b603eb999cdf19bb27cdaf7b3433582d1c04356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b603eb999cdf19bb27cdaf7b3433582d1c04356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b603eb999cdf19bb27cdaf7b3433582d1c04356"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "4bb5a9a42f3f9f778bae81b7cb8627b255e5ed03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4302db79108595d94210a96941129013edf335af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4302db79108595d94210a96941129013edf335af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4302db79108595d94210a96941129013edf335af", "patch": "@@ -1,3 +1,7 @@\n+2003-02-13  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300.md (a peephole2): New.\n+\n 2003-02-13  Robert Lipe <robertlipe@usa.net>\n             Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n "}, {"sha": "8796dc03d0034ea24cb6a881e99cc750f5acf41e", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4302db79108595d94210a96941129013edf335af/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4302db79108595d94210a96941129013edf335af/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=4302db79108595d94210a96941129013edf335af", "patch": "@@ -3435,6 +3435,36 @@\n \t\t      (pc)))]\n   \"\")\n \n+;; (compare:SI (reg) (const_int)) takes 6 bytes, so we try to achieve\n+;; the equivalent with shorter sequences.  Here is the summary.\n+;;\n+;; reg  const_int                 use     insn\n+;; live    -2                     eq/ne   copy and inc.l\n+;; live    -1                     eq/ne   copy and inc.l\n+;; live     1                     eq/ne   copy and dec.l\n+;; live     2                     eq/ne   copy and dec.l\n+;; dead    -6                     eq/ne   adds and inc.l\n+;; dead    -5                     eq/ne   adds and inc.l\n+;; dead    -4                     eq/ne   adds and test\n+;; dead    -3                     eq/ne   adds and inc.l\n+;; dead    -2                     eq/ne   inc.l\n+;; dead    -1                     eq/ne   inc.l\n+;; dead     1                     eq/ne   dec.l\n+;; dead     2                     eq/ne   dec.l\n+;; dead 0x000000?? except 1 and 2 eq/ne   xor.b and test\n+;; dead 0x0000??00                eq/ne   xor.b and test\n+;; dead 0x0000ffff                eq/ne   not.w and test\n+;; dead 0xffff0000                eq/ne   not.w and test\n+;; dead     1                     geu/ltu and.b and test\n+;; dead     3                     geu/ltu and.b and test\n+;; dead     7                     geu/ltu and.b and test\n+;; dead    15                     geu/ltu and.b and test\n+;; dead    31                     geu/ltu and.b and test\n+;; dead    63                     geu/ltu and.b and test\n+;; dead   127                     geu/ltu and.b and test\n+;; dead   255                     geu/ltu and.b and test\n+;; dead 65535                     geu/ltu mov.w\n+\n ;; For a small constant, it is cheaper to actually do the subtraction\n ;; and then test the register.\n \n@@ -3480,6 +3510,38 @@\n   \"operands[1] = GEN_INT (- INTVAL (operands[1]));\n    split_adds_subs (SImode, operands, 1);\")\n \n+;; For certain (in)equaltity comparisions against a constant, we can\n+;; XOR the register with the constant, and test the register against\n+;; 0.\n+\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 3 \"eqne_operator\"\n+\t\t\t[(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"(TARGET_H8300H || TARGET_H8300S)\n+   && peep2_reg_dead_p (1, operands[0])\n+   && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])\n+       || (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])\n+       || INTVAL (operands[1]) == 0x0000ffff\n+       || INTVAL (operands[1]) == 0xffff0000)\n+   && INTVAL (operands[1]) != 1\n+   && INTVAL (operands[1]) != 2\"\n+  [(set (match_dup 0)\n+\t(xor:SI (match_dup 0)\n+\t\t(match_dup 1)))\n+   (set (cc0)\n+\t(match_dup 0))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  \"\")\n+\n ;; Transform A <= 1 to (A & 0xfffffffe) == 0.\n \n (define_peephole2"}]}