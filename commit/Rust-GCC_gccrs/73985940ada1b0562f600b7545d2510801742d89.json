{"sha": "73985940ada1b0562f600b7545d2510801742d89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM5ODU5NDBhZGExYjA1NjJmNjAwYjc1NDVkMjUxMDgwMTc0MmQ4OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-04-30T19:17:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-30T19:17:07Z"}, "message": "sparc.c (emit_soft_tfmode_libcall, [...]): New.\n\n        * config/sparc/sparc.c (emit_soft_tfmode_libcall,\n        emit_soft_tfmode_binop, emit_soft_tfmode_unop, emit_soft_tfmode_cvt,\n        emit_hard_tfmode_operation, emit_tfmode_binop, emit_tfmode_unop,\n        emit_tfmode_cvt): New.\n        * config/sparc/sparc.md (extendsftf2, extenddftf2, trunctfsf2,\n        trunctfdf2, floatsitf2, floatunssitf2, floatditf2, floatunsditf2,\n        fix_trunctfsi2, fixuns_trunctfsi2, fix_trunctfdi2, fixuns_trunctfdi2,\n        addtf3, subtf3, multf3, divtf3, sqrttf2): Use them.\n        * config/sparc/sparc-protos.h: Update.\n\nFrom-SVN: r52965", "tree": {"sha": "ccfb5273841555a25d920b0dfea74223027cd4c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccfb5273841555a25d920b0dfea74223027cd4c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73985940ada1b0562f600b7545d2510801742d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73985940ada1b0562f600b7545d2510801742d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73985940ada1b0562f600b7545d2510801742d89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73985940ada1b0562f600b7545d2510801742d89/comments", "author": null, "committer": null, "parents": [{"sha": "5cdd50a59159258c25a53b0a2bcee9c8d6081812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cdd50a59159258c25a53b0a2bcee9c8d6081812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cdd50a59159258c25a53b0a2bcee9c8d6081812"}], "stats": {"total": 799, "additions": 364, "deletions": 435}, "files": [{"sha": "174a7ee18fd902eb4d0620a3afe1e41023df734c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73985940ada1b0562f600b7545d2510801742d89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73985940ada1b0562f600b7545d2510801742d89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73985940ada1b0562f600b7545d2510801742d89", "patch": "@@ -1,3 +1,15 @@\n+2002-04-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/sparc/sparc.c (emit_soft_tfmode_libcall,\n+\temit_soft_tfmode_binop, emit_soft_tfmode_unop, emit_soft_tfmode_cvt,\n+\temit_hard_tfmode_operation, emit_tfmode_binop, emit_tfmode_unop,\n+\temit_tfmode_cvt): New.\n+\t* config/sparc/sparc.md (extendsftf2, extenddftf2, trunctfsf2,\n+\ttrunctfdf2, floatsitf2, floatunssitf2, floatditf2, floatunsditf2,\n+\tfix_trunctfsi2, fixuns_trunctfsi2, fix_trunctfdi2, fixuns_trunctfdi2,\n+\taddtf3, subtf3, multf3, divtf3, sqrttf2): Use them.\n+\t* config/sparc/sparc-protos.h: Update.\n+\n 2002-04-30  Janis Johnson  <janis187@us.ibm.com>\n \n \t* install.texi (Final install): Add to the list of info to include"}, {"sha": "5f6343bf9accfcbfcfe6b7422f036d28fe30a80e", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73985940ada1b0562f600b7545d2510801742d89/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73985940ada1b0562f600b7545d2510801742d89/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=73985940ada1b0562f600b7545d2510801742d89", "patch": "@@ -74,6 +74,9 @@ extern enum machine_mode select_cc_mode PARAMS ((enum rtx_code, rtx, rtx));\n extern rtx gen_compare_reg PARAMS ((enum rtx_code code, rtx, rtx));\n extern void sparc_emit_float_lib_cmp PARAMS ((rtx, rtx, enum rtx_code));\n extern void sparc_emit_floatunsdi PARAMS ((rtx [2]));\n+extern void emit_tfmode_binop PARAMS ((enum rtx_code, rtx *));\n+extern void emit_tfmode_unop PARAMS ((enum rtx_code, rtx *));\n+extern void emit_tfmode_cvt PARAMS ((enum rtx_code, rtx *));\n /* This function handles all v9 scc insns */\n extern int gen_v9_scc PARAMS ((enum rtx_code, rtx *));\n extern void sparc_initialize_trampoline PARAMS ((rtx, rtx, rtx));"}, {"sha": "0bac7c9afc96ef85e99eb62e1a3f75f18d3a1212", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73985940ada1b0562f600b7545d2510801742d89/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73985940ada1b0562f600b7545d2510801742d89/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=73985940ada1b0562f600b7545d2510801742d89", "patch": "@@ -168,6 +168,12 @@ static void sparc_sched_init PARAMS ((FILE *, int, int));\n static int sparc_use_dfa_pipeline_interface PARAMS ((void));\n static int sparc_use_sched_lookahead PARAMS ((void));\n static rtx sparc_cycle_display PARAMS ((int, rtx));\n+\n+static void emit_soft_tfmode_libcall PARAMS ((const char *, int, rtx *));\n+static void emit_soft_tfmode_binop PARAMS ((enum rtx_code, rtx *));\n+static void emit_soft_tfmode_unop PARAMS ((enum rtx_code, rtx *));\n+static void emit_soft_tfmode_cvt PARAMS ((enum rtx_code, rtx *));\n+static void emit_hard_tfmode_operation PARAMS ((enum rtx_code, rtx *));\n \f\n /* Option handling.  */\n \n@@ -2456,6 +2462,304 @@ gen_df_reg (reg, low)\n   return gen_rtx_REG (DFmode, regno);\n }\n \f\n+/* Generate a call to FUNC with OPERANDS.  Operand 0 is the return value.\n+   Unlike normal calls, TFmode operands are passed by reference.  It is\n+   assumed that no more than 3 operands are required.  */\n+\n+static void\n+emit_soft_tfmode_libcall (func_name, nargs, operands)\n+     const char *func_name;\n+     int nargs;\n+     rtx *operands;\n+{\n+  rtx ret_slot = NULL, arg[3], func_sym;\n+  int i;\n+\n+  /* We only expect to be called for conversions, unary, and binary ops.  */\n+  if (nargs < 2 || nargs > 3)\n+    abort ();\n+\n+  for (i = 0; i < nargs; ++i)\n+    {\n+      rtx this_arg = operands[i];\n+      rtx this_slot;\n+\n+      /* TFmode arguments and return values are passed by reference.  */\n+      if (GET_MODE (this_arg) == TFmode)\n+\t{\n+\t  if (GET_CODE (this_arg) == MEM)\n+\t    this_arg = XEXP (this_arg, 0);\n+\t  else if (CONSTANT_P (this_arg))\n+\t    {\n+\t      this_slot = force_const_mem (TFmode, this_arg);\n+\t      this_arg = XEXP (this_slot, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      this_slot = assign_stack_temp (TFmode, GET_MODE_SIZE (TFmode), 0);\n+\n+\t      /* Operand 0 is the return value.  We'll copy it out later.  */\n+\t      if (i > 0)\n+\t\temit_move_insn (this_slot, this_arg);\n+\t      else\n+\t\tret_slot = this_slot;\n+\n+\t      this_arg = XEXP (this_slot, 0);\n+\t    }\n+\t}\n+\n+      arg[i] = this_arg;\n+    }\n+\n+  func_sym = gen_rtx_SYMBOL_REF (Pmode, func_name);\n+\n+  if (GET_MODE (operands[0]) == TFmode)\n+    {\n+      if (nargs == 2)\n+\temit_library_call (func_sym, LCT_NORMAL, VOIDmode, 2,\n+\t\t\t   arg[0], GET_MODE (arg[0]),\n+\t\t\t   arg[1], GET_MODE (arg[1]));\n+      else\n+\temit_library_call (func_sym, LCT_NORMAL, VOIDmode, 3,\n+\t\t\t   arg[0], GET_MODE (arg[0]),\n+\t\t\t   arg[1], GET_MODE (arg[1]),\n+\t\t\t   arg[2], GET_MODE (arg[2]));\n+\n+      if (ret_slot)\n+\temit_move_insn (operands[0], ret_slot);\n+    }\n+  else\n+    {\n+      rtx ret;\n+\n+      if (nargs != 2)\n+\tabort ();\n+\n+      ret = emit_library_call_value (func_sym, operands[0], LCT_NORMAL,\n+\t\t\t\t     GET_MODE (operands[0]), 1,\n+\t\t\t\t     arg[1], GET_MODE (arg[1]));\n+\n+      if (ret != operands[0])\n+\temit_move_insn (operands[0], ret);\n+    }\n+}\n+\n+/* Expand soft-float TFmode calls to sparc abi routines.  */\n+\n+static void\n+emit_soft_tfmode_binop (code, operands)\n+     enum rtx_code code;\n+     rtx *operands;\n+{\n+  const char *func;\n+\n+  switch (code)\n+    {\n+    case PLUS:\n+      func = \"_Qp_add\";\n+      break;\n+    case MINUS:\n+      func = \"_Qp_sub\";\n+      break;\n+    case MULT:\n+      func = \"_Qp_mul\";\n+      break;\n+    case DIV:\n+      func = \"_Qp_div\";\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  emit_soft_tfmode_libcall (func, 3, operands);\n+}\n+\n+static void\n+emit_soft_tfmode_unop (code, operands)\n+     enum rtx_code code;\n+     rtx *operands;\n+{\n+  const char *func;\n+\n+  switch (code)\n+    {\n+    case SQRT:\n+      func = \"_Qp_sqrt\";\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  emit_soft_tfmode_libcall (func, 2, operands);\n+}\n+\n+static void\n+emit_soft_tfmode_cvt (code, operands)\n+     enum rtx_code code;\n+     rtx *operands;\n+{\n+  const char *func;\n+\n+  switch (code)\n+    {\n+    case FLOAT_EXTEND:\n+      switch (GET_MODE (operands[1]))\n+\t{\n+\tcase SFmode:\n+\t  func = \"_Qp_stoq\";\n+\t  break;\n+\tcase DFmode:\n+\t  func = \"_Qp_dtoq\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case FLOAT_TRUNCATE:\n+      switch (GET_MODE (operands[0]))\n+\t{\n+\tcase SFmode:\n+\t  func = \"_Qp_qtos\";\n+\t  break;\n+\tcase DFmode:\n+\t  func = \"_Qp_qtod\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case FLOAT:\n+      switch (GET_MODE (operands[1]))\n+\t{\n+\tcase SImode:\n+\t  func = \"_Qp_itoq\";\n+\t  break;\n+\tcase DImode:\n+\t  func = \"_Qp_xtoq\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case UNSIGNED_FLOAT:\n+      switch (GET_MODE (operands[1]))\n+\t{\n+\tcase SImode:\n+\t  func = \"_Qp_uitoq\";\n+\t  break;\n+\tcase DImode:\n+\t  func = \"_Qp_uxtoq\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case FIX:\n+      switch (GET_MODE (operands[0]))\n+\t{\n+\tcase SImode:\n+\t  func = \"_Qp_qtoi\";\n+\t  break;\n+\tcase DImode:\n+\t  func = \"_Qp_qtox\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case UNSIGNED_FIX:\n+      switch (GET_MODE (operands[0]))\n+\t{\n+\tcase SImode:\n+\t  func = \"_Qp_qtoui\";\n+\t  break;\n+\tcase DImode:\n+\t  func = \"_Qp_qtoux\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  emit_soft_tfmode_libcall (func, 2, operands);\n+}\n+\n+/* Expand a hard-float tfmode operation.  All arguments must be in\n+   registers.  */\n+\n+static void\n+emit_hard_tfmode_operation (code, operands)\n+     enum rtx_code code;\n+     rtx *operands;\n+{\n+  rtx op, dest;\n+\n+  if (GET_RTX_CLASS (code) == '1')\n+    {\n+      operands[1] = force_reg (GET_MODE (operands[1]), operands[1]);\n+      op = gen_rtx_fmt_e (code, GET_MODE (operands[0]), operands[1]);\n+    }\n+  else\n+    {\n+      operands[1] = force_reg (GET_MODE (operands[1]), operands[1]);\n+      operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n+      op = gen_rtx_fmt_ee (code, GET_MODE (operands[0]),\n+\t\t\t   operands[1], operands[2]);\n+    }\n+\n+  if (register_operand (operands[0], VOIDmode))\n+    dest = operands[0];\n+  else\n+    dest = gen_reg_rtx (GET_MODE (operands[0]));\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, op));\n+\n+  if (dest != operands[0])\n+    emit_move_insn (operands[0], dest);\n+}\n+\n+void\n+emit_tfmode_binop (code, operands)\n+     enum rtx_code code;\n+     rtx *operands;\n+{\n+  if (TARGET_HARD_QUAD)\n+    emit_hard_tfmode_operation (code, operands);\n+  else\n+    emit_soft_tfmode_binop (code, operands);\n+}\n+\n+void\n+emit_tfmode_unop (code, operands)\n+     enum rtx_code code;\n+     rtx *operands;\n+{\n+  if (TARGET_HARD_QUAD)\n+    emit_hard_tfmode_operation (code, operands);\n+  else\n+    emit_soft_tfmode_unop (code, operands);\n+}\n+\n+void\n+emit_tfmode_cvt (code, operands)\n+     enum rtx_code code;\n+     rtx *operands;\n+{\n+  if (TARGET_HARD_QUAD)\n+    emit_hard_tfmode_operation (code, operands);\n+  else\n+    emit_soft_tfmode_cvt (code, operands);\n+}\n+\f\n /* Return nonzero if a return peephole merging return with\n    setting of output register is ok.  */\n int"}, {"sha": "db12cfe479b0117bb599eceb3868d0753343a4a4", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 45, "deletions": 435, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73985940ada1b0562f600b7545d2510801742d89/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73985940ada1b0562f600b7545d2510801742d89/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=73985940ada1b0562f600b7545d2510801742d89", "patch": "@@ -5220,31 +5220,11 @@\n    (set_attr \"fptype\" \"double\")])\n \n (define_expand \"extendsftf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(float_extend:TF\n-\t (match_operand:SF 1 \"register_operand\" \"f\")))]\n+\t (match_operand:SF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0;\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[0];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_stoq\\\"), LCT_NORMAL,\n-\t\t\t VOIDmode, 2,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t operands[1], SFmode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_cvt (FLOAT_EXTEND, operands); DONE;\")\n \n (define_insn \"*extendsftf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n@@ -5255,31 +5235,11 @@\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"extenddftf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(float_extend:TF\n-\t (match_operand:DF 1 \"register_operand\" \"e\")))]\n+\t (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0;\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[0];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_dtoq\\\"), LCT_NORMAL,\n-\t\t\t VOIDmode, 2,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t operands[1], DFmode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_cvt (FLOAT_EXTEND, operands); DONE;\")\n \n (define_insn \"*extenddftf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n@@ -5299,30 +5259,11 @@\n    (set_attr \"fptype\" \"double\")])\n \n (define_expand \"trunctfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(float_truncate:SF\n-\t (match_operand:TF 1 \"register_operand\" \"e\")))]\n+\t (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0;\n-\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n-\t}\n-      else\n-\tslot0 = operands[1];\n-\n-      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtos\\\"),\n-\t\t\t       operands[0], LCT_NORMAL, SFmode, 1,\n-\t\t\t       XEXP (slot0, 0), Pmode);\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_cvt (FLOAT_TRUNCATE, operands); DONE;\")\n \n (define_insn \"*trunctfsf2_hq\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n@@ -5333,30 +5274,11 @@\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"trunctfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(float_truncate:DF\n-\t (match_operand:TF 1 \"register_operand\" \"e\")))]\n+\t (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0;\n-\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n-\t}\n-      else\n-\tslot0 = operands[1];\n-\n-      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtod\\\"),\n-\t\t\t       operands[0], LCT_NORMAL, DFmode, 1,\n-\t\t\t       XEXP (slot0, 0), Pmode);\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_cvt (FLOAT_TRUNCATE, operands); DONE;\")\n \n (define_insn \"*trunctfdf2_hq\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n@@ -5385,30 +5307,10 @@\n    (set_attr \"fptype\" \"double\")])\n \n (define_expand \"floatsitf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(float:TF (match_operand:SI 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(float:TF (match_operand:SI 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0;\n-\n-      if (GET_CODE (operands[1]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[1];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_itoq\\\"), 0,\n-\t\t\t VOIDmode, 2,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t operands[1], SImode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_cvt (FLOAT, operands); DONE;\")\n \n (define_insn \"*floatsitf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n@@ -5418,27 +5320,10 @@\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"floatunssitf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(unsigned_float:TF (match_operand:SI 1 \"register_operand\" \"e\")))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(unsigned_float:TF (match_operand:SI 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n-  \"\n-{\n-  rtx slot0;\n-\n-  if (GET_CODE (operands[1]) != MEM)\n-    slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-  else\n-    slot0 = operands[1];\n-\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_uitoq\\\"), 0,\n-\t\t     VOIDmode, 2,\n-\t\t     XEXP (slot0, 0), Pmode,\n-\t\t     operands[1], SImode);\n-\n-  if (GET_CODE (operands[0]) != MEM)\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-  DONE;\n-}\")\n+  \"emit_tfmode_cvt (UNSIGNED_FLOAT, operands); DONE;\")\n \n ;; Now the same for 64 bit sources.\n \n@@ -5471,30 +5356,10 @@\n   \"sparc_emit_floatunsdi (operands); DONE;\")\n \n (define_expand \"floatditf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(float:TF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(float:TF (match_operand:DI 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU && TARGET_V9 && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0;\n-\n-      if (GET_CODE (operands[1]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[1];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_xtoq\\\"), 0,\n-\t\t\t VOIDmode, 2,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t operands[1], DImode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_cvt (FLOAT, operands); DONE;\")\n \n (define_insn \"*floatditf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n@@ -5504,27 +5369,10 @@\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"floatunsditf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(unsigned_float:TF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(unsigned_float:TF (match_operand:DI 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n-  \"\n-{\n-  rtx slot0;\n-\n-  if (GET_CODE (operands[1]) != MEM)\n-    slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-  else\n-    slot0 = operands[1];\n-\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_uxtoq\\\"), 0,\n-\t\t     VOIDmode, 2,\n-\t\t     XEXP (slot0, 0), Pmode,\n-\t\t     operands[1], DImode);\n-\n-  if (GET_CODE (operands[0]) != MEM)\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-  DONE;\n-}\")\n+  \"emit_tfmode_cvt (UNSIGNED_FLOAT, operands); DONE;\")\n \n ;; Convert a float to an actual integer.\n ;; Truncation is performed as part of the conversion.\n@@ -5546,58 +5394,23 @@\n    (set_attr \"fptype\" \"double\")])\n \n (define_expand \"fix_trunctfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n-\t(fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(fix:SI (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0;\n-\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n-\t}\n-      else\n-\tslot0 = operands[1];\n-\n-      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtoi\\\"),\n-\t\t\t       operands[0], LCT_NORMAL, SImode, 1,\n-\t\t\t       XEXP (slot0, 0), Pmode);\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_cvt (FIX, operands); DONE;\")\n \n (define_insn \"*fix_trunctfsi2_hq\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n-\t(fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+\t(fix:SI (match_operand:TF 1 \"register_operand\" \"e\")))]\n   \"TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fqtoi\\\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"fixuns_trunctfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n-\t(unsigned_fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(unsigned_fix:SI (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n-  \"\n-{\n-  rtx slot0;\n-\n-  if (GET_CODE (operands[1]) != MEM)\n-    {\n-      slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n-    }\n-  else\n-    slot0 = operands[1];\n-\n-  emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtoui\\\"),\n-\t\t\t   operands[0], LCT_NORMAL, SImode, 1,\n-\t\t\t   XEXP (slot0, 0), Pmode);\n-  DONE;\n-}\")\n+  \"emit_tfmode_cvt (UNSIGNED_FIX, operands); DONE;\")\n \n ;; Now the same, for V9 targets\n \n@@ -5618,59 +5431,23 @@\n    (set_attr \"fptype\" \"double\")])\n \n (define_expand \"fix_trunctfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n-\t(fix:DI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(fix:DI (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_V9 && TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0;\n-\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n-\t}\n-      else\n-\tslot0 = operands[1];\n-\n-      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtox\\\"),\n-\t\t\t       operands[0], LCT_NORMAL, DImode, 1,\n-\t\t\t       XEXP (slot0, 0), Pmode);\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_cvt (FIX, operands); DONE;\")\n \n (define_insn \"*fix_trunctfdi2_hq\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n-\t(fix:DI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+\t(fix:DI (match_operand:TF 1 \"register_operand\" \"e\")))]\n   \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fqtox\\\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_expand \"fixuns_trunctfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n-\t(unsigned_fix:DI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(unsigned_fix:DI (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n-  \"\n-{\n-  rtx slot0;\n-\n-  if (GET_CODE (operands[1]) != MEM)\n-    {\n-      slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n-    }\n-  else\n-    slot0 = operands[1];\n-\n-  emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtoux\\\"),\n-\t\t\t   operands[0], LCT_NORMAL, DImode, 1,\n-\t\t\t   XEXP (slot0, 0), Pmode);\n-  DONE;\n-}\")\n-\n+  \"emit_tfmode_cvt (UNSIGNED_FIX, operands); DONE;\")\n \f\n ;;- arithmetic instructions\n \n@@ -7570,42 +7347,7 @@\n \t(plus:TF (match_operand:TF 1 \"general_operand\" \"\")\n \t\t (match_operand:TF 2 \"general_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0, slot1, slot2;\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[0];\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n-\t}\n-      else\n-\tslot1 = operands[1];\n-      if (GET_CODE (operands[2]) != MEM)\n-\t{\n-\t  slot2 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot2, operands[2]));\n-\t}\n-      else\n-\tslot2 = operands[2];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_add\\\"), 0,\n-\t\t\t VOIDmode, 3,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t XEXP (slot1, 0), Pmode,\n-\t\t\t XEXP (slot2, 0), Pmode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_binop (PLUS, operands); DONE;\")\n \n (define_insn \"*addtf3_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n@@ -7637,42 +7379,7 @@\n \t(minus:TF (match_operand:TF 1 \"general_operand\" \"\")\n \t\t  (match_operand:TF 2 \"general_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0, slot1, slot2;\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[0];\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n-\t}\n-      else\n-\tslot1 = operands[1];\n-      if (GET_CODE (operands[2]) != MEM)\n-\t{\n-\t  slot2 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot2, operands[2]));\n-\t}\n-      else\n-\tslot2 = operands[2];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_sub\\\"), 0,\n-\t\t\t VOIDmode, 3,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t XEXP (slot1, 0), Pmode,\n-\t\t\t XEXP (slot2, 0), Pmode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_binop (MINUS, operands); DONE;\")\n \n (define_insn \"*subtf3_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n@@ -7704,42 +7411,7 @@\n \t(mult:TF (match_operand:TF 1 \"general_operand\" \"\")\n \t\t (match_operand:TF 2 \"general_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0, slot1, slot2;\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[0];\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n-\t}\n-      else\n-\tslot1 = operands[1];\n-      if (GET_CODE (operands[2]) != MEM)\n-\t{\n-\t  slot2 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot2, operands[2]));\n-\t}\n-      else\n-\tslot2 = operands[2];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_mul\\\"), 0,\n-\t\t\t VOIDmode, 3,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t XEXP (slot1, 0), Pmode,\n-\t\t\t XEXP (slot2, 0), Pmode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_binop (MULT, operands); DONE;\")\n \n (define_insn \"*multf3_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n@@ -7788,42 +7460,7 @@\n \t(div:TF (match_operand:TF 1 \"general_operand\" \"\")\n \t\t(match_operand:TF 2 \"general_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0, slot1, slot2;\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[0];\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n-\t}\n-      else\n-\tslot1 = operands[1];\n-      if (GET_CODE (operands[2]) != MEM)\n-\t{\n-\t  slot2 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot2, operands[2]));\n-\t}\n-      else\n-\tslot2 = operands[2];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_div\\\"), 0,\n-\t\t\t VOIDmode, 3,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t XEXP (slot1, 0), Pmode,\n-\t\t\t XEXP (slot2, 0), Pmode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_binop (DIV, operands); DONE;\")\n \n ;; don't have timing for quad-prec. divide.\n (define_insn \"*divtf3_hq\"\n@@ -8072,37 +7709,10 @@\n   [(set_attr \"type\" \"fpmove\")])\n \n (define_expand \"sqrttf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(sqrt:TF (match_operand:TF 1 \"register_operand\" \"e\")))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(sqrt:TF (match_operand:TF 1 \"general_operand\" \"\")))]\n   \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n-  \"\n-{\n-  if (! TARGET_HARD_QUAD)\n-    {\n-      rtx slot0, slot1;\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      else\n-\tslot0 = operands[0];\n-      if (GET_CODE (operands[1]) != MEM)\n-\t{\n-\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n-\t}\n-      else\n-\tslot1 = operands[1];\n-\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_sqrt\\\"), 0,\n-\t\t\t VOIDmode, 2,\n-\t\t\t XEXP (slot0, 0), Pmode,\n-\t\t\t XEXP (slot1, 0), Pmode);\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n-      DONE;\n-    }\n-}\")\n+  \"emit_tfmode_unop (SQRT, operands); DONE;\")\n \n (define_insn \"*sqrttf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")"}]}