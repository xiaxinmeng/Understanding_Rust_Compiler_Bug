{"sha": "3543e114c6226e545f9bb30cec4f448e8f20ff4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU0M2UxMTRjNjIyNmU1NDVmOWJiMzBjZWM0ZjQ0OGU4ZjIwZmY0Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-09-22T10:55:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-22T10:55:21Z"}, "message": "cp-tree.h (struct lang_type_class): Remove marked flags, add diamond_shaped and repeated_base flags.\n\n\t* cp-tree.h (struct lang_type_class): Remove marked flags, add\n\tdiamond_shaped and repeated_base flags.  Reorder to keep 8-bit blocks.\n\t(TYPE_MARKED_P): New.\n\t(CLASSTYPE_DIAMOND_SHAPED_P, CLASSTYPE_REPEATED_BASE_P): New.\n\t(CLASSTYPE_MARKED_N, SET_CLASSTYPE_MARKED_N,\n\tCLEAR_CLASSTYPE_MARKED_N): Remove.\n\t(CLASSTYPE_MARKED_*, SET_CLASSTYPE_MARKED_*,\n\tCLEAR_CLASSTYPE_MARKED_*): Remove.\n\t* decl.c (xref_basetypes): Use TYPE_MARKED_P. Determine diamond\n\tshaped and repeated base properties.\n\t* lex.c (cxx_make_type): Don't clear TYPE_ALIAS_SET.\n\t* rtti.c (dfs_class_hint_mark, dfs_class_hint_unmark,\n\tclass_hint_flags): Remove.\n\t(get_pseudo_ti_init): Use CLASSTYPE_REPEATED_BASE_P and\n\tCLASSTYPE_DIAMOND_SHAPED_P.\n\nFrom-SVN: r87853", "tree": {"sha": "6a55baf581488592472eb340d2cc7a5cb3e0aa46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a55baf581488592472eb340d2cc7a5cb3e0aa46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3543e114c6226e545f9bb30cec4f448e8f20ff4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3543e114c6226e545f9bb30cec4f448e8f20ff4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3543e114c6226e545f9bb30cec4f448e8f20ff4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3543e114c6226e545f9bb30cec4f448e8f20ff4f/comments", "author": null, "committer": null, "parents": [{"sha": "0e64e323b0a71f96919613619e2dd4176226d653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e64e323b0a71f96919613619e2dd4176226d653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e64e323b0a71f96919613619e2dd4176226d653"}], "stats": {"total": 189, "additions": 75, "deletions": 114}, "files": [{"sha": "f88f663fedf1a1ff03b313c3594f25c296ec4889", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3543e114c6226e545f9bb30cec4f448e8f20ff4f", "patch": "@@ -1,3 +1,21 @@\n+2004-09-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (struct lang_type_class): Remove marked flags, add\n+\tdiamond_shaped and repeated_base flags.  Reorder to keep 8-bit blocks.\n+\t(TYPE_MARKED_P): New.\n+\t(CLASSTYPE_DIAMOND_SHAPED_P, CLASSTYPE_REPEATED_BASE_P): New.\n+\t(CLASSTYPE_MARKED_N, SET_CLASSTYPE_MARKED_N,\n+\tCLEAR_CLASSTYPE_MARKED_N): Remove.\n+\t(CLASSTYPE_MARKED_*, SET_CLASSTYPE_MARKED_*,\n+\tCLEAR_CLASSTYPE_MARKED_*): Remove.\n+\t* decl.c (xref_basetypes): Use TYPE_MARKED_P. Determine diamond\n+\tshaped and repeated base properties.\n+\t* lex.c (cxx_make_type): Don't clear TYPE_ALIAS_SET.\n+\t* rtti.c (dfs_class_hint_mark, dfs_class_hint_unmark,\n+\tclass_hint_flags): Remove.\n+\t(get_pseudo_ti_init): Use CLASSTYPE_REPEATED_BASE_P and\n+\tCLASSTYPE_DIAMOND_SHAPED_P.\n+\t\n 2004-09-21  Ziemowit Laski  <zlaski@apple.com>\n \n \t* cp-lang.c (LANG_HOOKS_FOLD_OBJ_TYPE_REF): Moved here from"}, {"sha": "417d179ff0dd34f444b9dd1bc376efd5fd23e239", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 20, "deletions": 47, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3543e114c6226e545f9bb30cec4f448e8f20ff4f", "patch": "@@ -56,7 +56,6 @@ struct diagnostic_context;\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       DECL_INITIALIZED_P (in VAR_DECL)\n    2: IDENTIFIER_OPNAME_P (in IDENTIFIER_NODE)\n-      TYPE_POLYMORPHIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n       STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n@@ -73,6 +72,7 @@ struct diagnostic_context;\n       DECL_VTABLE_OR_VTT_P (in VAR_DECL)\n    6: IDENTIFIER_REPO_CHOSEN (in IDENTIFIER_NODE)\n       DECL_CONSTRUCTION_VTABLE_P (in VAR_DECL)\n+      TYPE_MARKED_P (in _TYPE)\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: TYPE_DEPENDENT_P\n@@ -1001,22 +1001,23 @@ struct lang_type_class GTY(())\n   unsigned non_zero_init : 1;\n   unsigned empty_p : 1;\n \n-  unsigned marks: 6;\n   unsigned vec_new_uses_cookie : 1;\n   unsigned declared_class : 1;\n-\n+  unsigned diamond_shaped : 1;\n+  unsigned repeated_base : 1;\n   unsigned being_defined : 1;\n   unsigned redefined : 1;\n   unsigned debug_requested : 1;\n-  unsigned use_template : 2;\n   unsigned fields_readonly : 1;\n+  \n+  unsigned use_template : 2;\n   unsigned ptrmemfunc_flag : 1;\n   unsigned was_anonymous : 1;\n-\n   unsigned lazy_default_ctor : 1;\n   unsigned lazy_copy_ctor : 1;\n   unsigned lazy_assignment_op : 1;\n   unsigned has_const_init_ref : 1;\n+  \n   unsigned has_complex_init_ref : 1;\n   unsigned has_complex_assign_ref : 1;\n   unsigned non_aggregate : 1;\n@@ -1029,7 +1030,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 8;\n+  unsigned dummy : 12;\n \n   tree primary_base;\n   VEC (tree_pair_s) *vcall_indices;\n@@ -1158,6 +1159,19 @@ struct lang_type GTY(())\n    convenient, don't reprocess any methods that appear in its redefinition.  */\n #define TYPE_REDEFINED(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->redefined)\n \n+/* Mark bits for repeated base checks.  */\n+#define TYPE_MARKED_P(NODE) TREE_LANG_FLAG_6 (TYPE_CHECK (NODE))\n+\n+/* Non-zero if the class NODE has multiple paths to the same (virtual)\n+   base object.  */\n+#define CLASSTYPE_DIAMOND_SHAPED_P(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK(NODE)->diamond_shaped)\n+\n+/* Non-zero if the class NODE has multiple instances of the same base\n+   type.  */\n+#define CLASSTYPE_REPEATED_BASE_P(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK(NODE)->repeated_base)\n+\n /* The member function with which the vtable will be emitted:\n    the first noninline non-pure-virtual member function.  NULL_TREE\n    if there is no key function or if this is a class template */\n@@ -1203,47 +1217,6 @@ struct lang_type GTY(())\n #define CLASSTYPE_DESTRUCTORS(NODE) \\\n   (VEC_index (tree, CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_DESTRUCTOR_SLOT))\n \n-/* Mark bits for depth-first and breath-first searches.  */\n-\n-/* Get the value of the Nth mark bit.  */\n-#define CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\\\n-  (((CLASS_TYPE_P (NODE) ? LANG_TYPE_CLASS_CHECK (NODE)->marks\t\\\n-     : ((unsigned) TYPE_ALIAS_SET (NODE))) & (1 << (N))) != 0)\n-\n-/* Set the Nth mark bit.  */\n-#define SET_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\\\n-  (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\\\n-   ? (void) (LANG_TYPE_CLASS_CHECK (NODE)->marks |= (1 << (N)))\t\\\n-   : (void) (TYPE_ALIAS_SET (NODE) |= (1 << (N))))\n-\n-/* Clear the Nth mark bit.  */\n-#define CLEAR_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\\\n-  (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\\\n-   ? (void) (LANG_TYPE_CLASS_CHECK (NODE)->marks &= ~(1 << (N)))\t\\\n-   : (void) (TYPE_ALIAS_SET (NODE) &= ~(1 << (N))))\n-\n-/* Get the value of the mark bits.  */\n-#define CLASSTYPE_MARKED(NODE) CLASSTYPE_MARKED_N (NODE, 0)\n-#define CLASSTYPE_MARKED2(NODE) CLASSTYPE_MARKED_N (NODE, 1)\n-#define CLASSTYPE_MARKED3(NODE) CLASSTYPE_MARKED_N (NODE, 2)\n-#define CLASSTYPE_MARKED4(NODE) CLASSTYPE_MARKED_N (NODE, 3)\n-#define CLASSTYPE_MARKED5(NODE) CLASSTYPE_MARKED_N (NODE, 4)\n-#define CLASSTYPE_MARKED6(NODE) CLASSTYPE_MARKED_N (NODE, 5)\n-\n-/* Macros to modify the above flags */\n-#define SET_CLASSTYPE_MARKED(NODE)    SET_CLASSTYPE_MARKED_N (NODE, 0)\n-#define CLEAR_CLASSTYPE_MARKED(NODE)  CLEAR_CLASSTYPE_MARKED_N (NODE, 0)\n-#define SET_CLASSTYPE_MARKED2(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 1)\n-#define CLEAR_CLASSTYPE_MARKED2(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 1)\n-#define SET_CLASSTYPE_MARKED3(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 2)\n-#define CLEAR_CLASSTYPE_MARKED3(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 2)\n-#define SET_CLASSTYPE_MARKED4(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 3)\n-#define CLEAR_CLASSTYPE_MARKED4(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 3)\n-#define SET_CLASSTYPE_MARKED5(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 4)\n-#define CLEAR_CLASSTYPE_MARKED5(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 4)\n-#define SET_CLASSTYPE_MARKED6(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 5)\n-#define CLEAR_CLASSTYPE_MARKED6(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 5)\n-\n /* A dictionary of the nested user-defined-types (class-types, or enums)\n    found within this class.  This table includes nested member class\n    templates.  */"}, {"sha": "73f54d92809067ae43baa04bb9b4525a4e128668", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3543e114c6226e545f9bb30cec4f448e8f20ff4f", "patch": "@@ -9228,7 +9228,7 @@ xref_basetypes (tree ref, tree base_list)\n \t}\n     }\n \n-  SET_CLASSTYPE_MARKED (ref);\n+  TYPE_MARKED_P (ref) = 1;\n \n   /* The binfo slot should be empty, unless this is an (ill-formed)\n      redefinition.  */\n@@ -9286,15 +9286,15 @@ xref_basetypes (tree ref, tree base_list)\n \t  continue;\n \t}\n \n-      if (CLASSTYPE_MARKED (basetype))\n+      if (TYPE_MARKED_P (basetype))\n \t{\n \t  if (basetype == ref)\n \t    error (\"recursive type `%T' undefined\", basetype);\n \t  else\n \t    error (\"duplicate base type `%T' invalid\", basetype);\n \t  continue;\n \t}\n-      SET_CLASSTYPE_MARKED (basetype);\n+      TYPE_MARKED_P (basetype) = 1;\n \n       if (TYPE_FOR_JAVA (basetype) && (current_lang_depth () == 0))\n \tTYPE_FOR_JAVA (ref) = 1;\n@@ -9313,6 +9313,10 @@ xref_basetypes (tree ref, tree base_list)\n \t    |= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n \t  TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n \t  TYPE_HAS_CONVERSION (ref) |= TYPE_HAS_CONVERSION (basetype);\n+\t  CLASSTYPE_DIAMOND_SHAPED_P (ref)\n+\t    |= CLASSTYPE_DIAMOND_SHAPED_P (basetype);\n+\t  CLASSTYPE_REPEATED_BASE_P (ref)\n+\t    |= CLASSTYPE_REPEATED_BASE_P (basetype);\n \t}\n \n       base_binfo = copy_binfo (base_binfo, basetype, ref,\n@@ -9324,10 +9328,36 @@ xref_basetypes (tree ref, tree base_list)\n       BINFO_BASE_ACCESS_APPEND (binfo, access);\n     }\n \n+  if (VEC_space (tree, CLASSTYPE_VBASECLASSES (ref), 1))\n+    /* If we have space in the vbase vector, we must have shared at\n+       least one of them, and are therefore diamond shaped.  */\n+    CLASSTYPE_DIAMOND_SHAPED_P (ref) = 1;\n+\n   /* Unmark all the types.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-    CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (base_binfo));\n-  CLEAR_CLASSTYPE_MARKED (ref);\n+    TYPE_MARKED_P (BINFO_TYPE (base_binfo)) = 0;\n+  TYPE_MARKED_P (ref) = 0;\n+\n+  /* Now see if we have a repeated base type.  */\n+  if (!CLASSTYPE_REPEATED_BASE_P (ref))\n+    {\n+      for (base_binfo = binfo; base_binfo;\n+\t   base_binfo = TREE_CHAIN (base_binfo))\n+\t{\n+\t  if (TYPE_MARKED_P (BINFO_TYPE (base_binfo)))\n+\t    {\n+\t      CLASSTYPE_REPEATED_BASE_P (ref) = 1;\n+\t      break;\n+\t    }\n+\t  TYPE_MARKED_P (BINFO_TYPE (base_binfo)) = 1;\n+\t}\n+      for (base_binfo = binfo; base_binfo;\n+\t   base_binfo = TREE_CHAIN (base_binfo))\n+\tif (TYPE_MARKED_P (BINFO_TYPE (base_binfo)))\n+\t  TYPE_MARKED_P (BINFO_TYPE (base_binfo)) = 0;\n+\telse\n+\t  break;\n+    }\n }\n \n \f"}, {"sha": "5addca4988b3bbb7625bbeb5cdeaf34ad2ae4f81", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=3543e114c6226e545f9bb30cec4f448e8f20ff4f", "patch": "@@ -782,11 +782,6 @@ cxx_make_type (enum tree_code code)\n       SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, finfo->interface_unknown);\n       CLASSTYPE_INTERFACE_ONLY (t) = finfo->interface_only;\n     }\n-  else\n-    /* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,\n-       TYPE_ALIAS_SET is initialized to -1 by default, so we must\n-       clear it here.  */\n-    TYPE_ALIAS_SET (t) = 0;\n \n   return t;\n }"}, {"sha": "2dc05ad3cab8d87dc87127ed730073454e3fa36d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3543e114c6226e545f9bb30cec4f448e8f20ff4f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=3543e114c6226e545f9bb30cec4f448e8f20ff4f", "patch": "@@ -89,9 +89,6 @@ static int qualifier_flags (tree);\n static bool target_incomplete_p (tree);\n static tree tinfo_base_init (tree, tree);\n static tree generic_initializer (tree, tree);\n-static tree dfs_class_hint_mark (tree, void *);\n-static tree dfs_class_hint_unmark (tree, void *);\n-static int class_hint_flags (tree);\n static tree class_initializer (tree, tree, tree);\n static tree create_pseudo_type_info (const char *, int, ...);\n static tree get_pseudo_ti_init (tree, tree);\n@@ -924,59 +921,6 @@ ptm_initializer (tree desc, tree target)\n   return init;  \n }\n \n-/* Check base BINFO to set hint flags in *DATA, which is really an int.\n-   We use CLASSTYPE_MARKED to tag types we've found as non-virtual bases and\n-   CLASSTYPE_MARKED2 to tag those which are virtual bases. Remember it is\n-   possible for a type to be both a virtual and non-virtual base.  */\n-\n-static tree\n-dfs_class_hint_mark (tree binfo, void *data)\n-{\n-  tree basetype = BINFO_TYPE (binfo);\n-  int *hint = (int *) data;\n-  \n-  if (BINFO_VIRTUAL_P (binfo))\n-    {\n-      if (CLASSTYPE_MARKED (basetype))\n-        *hint |= 1;\n-      if (CLASSTYPE_MARKED2 (basetype))\n-        *hint |= 2;\n-      SET_CLASSTYPE_MARKED2 (basetype);\n-    }\n-  else\n-    {\n-      if (CLASSTYPE_MARKED (basetype) || CLASSTYPE_MARKED2 (basetype))\n-        *hint |= 1;\n-      SET_CLASSTYPE_MARKED (basetype);\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Clear the base's dfs marks, after searching for duplicate bases.  */\n-\n-static tree\n-dfs_class_hint_unmark (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{\n-  tree basetype = BINFO_TYPE (binfo);\n-  \n-  CLEAR_CLASSTYPE_MARKED (basetype);\n-  CLEAR_CLASSTYPE_MARKED2 (basetype);\n-  return NULL_TREE;\n-}\n-\n-/* Determine the hint flags describing the features of a class's hierarchy.  */\n-\n-static int\n-class_hint_flags (tree type)\n-{\n-  int hint_flags = 0;\n-  \n-  dfs_walk (TYPE_BINFO (type), dfs_class_hint_mark, NULL, &hint_flags);\n-  dfs_walk (TYPE_BINFO (type), dfs_class_hint_unmark, NULL, NULL);\n-  \n-  return hint_flags;\n-}\n-        \n /* Return the CONSTRUCTOR expr for a type_info of class TYPE.\n    DESC provides information about the particular __class_type_info derivation,\n    which adds hint flags and TRAIL initializers to the type_info base.  */\n@@ -1058,7 +1002,8 @@ get_pseudo_ti_init (tree type, tree var_desc)\n \t}\n       else\n         {\n-\t  int hint = class_hint_flags (type);\n+\t  int hint = ((CLASSTYPE_REPEATED_BASE_P (type) << 0)\n+\t\t      | (CLASSTYPE_DIAMOND_SHAPED_P (type) << 1));\n \t  tree binfo = TYPE_BINFO (type);\n           int nbases = BINFO_N_BASE_BINFOS (binfo);\n \t  VEC (tree) *base_accesses = BINFO_BASE_ACCESSES (binfo);"}]}