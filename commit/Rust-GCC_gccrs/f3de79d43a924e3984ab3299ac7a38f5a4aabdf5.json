{"sha": "f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNkZTc5ZDQzYTkyNGUzOTg0YWIzMjk5YWM3YTM4ZjVhNGFhYmRmNQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-05-24T20:59:00Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-05-24T20:59:00Z"}, "message": "array: Clean useless white chars.\n\n2014-05-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/profile/array: Clean useless white chars.\n\t* include/profile/base.h: Likewise.\n\t* include/profile/iterator_tracker.h: Likewise.\n\t* include/profile/bitset: Code cleanup and remove not instrumented code.\n\t* include/profile/deque: Likewise.\n\t* include/profile/forward_list: Likewise.\n\t* include/profile/list (std::__profile::_List_profile<>): New.\n\t(std::__profile::list<>): Inherit from latter and adapt.\n\t* include/profile/impl/profiler_map_to_unordered_map.h: Generalize\n\tadvise to match any ordered to unordered container conversion.\n\t* include/profile/ordered_base.h (std::__profile::_Ordered_profile<>):\n\tNew.\n\t* include/Makefile.am: Add latter.\n\t* include/Makefile.in: Regenerate.\n\t* include/profile/map.h (std::__profile::map<>): Inherit from latter,\n\tremove not instrumented code.\n\t* include/profile/multimap.h (std::__profile::multimap<>): Likewise.\n\t* include/profile/set.h (std::__profile::set<>): Likewise.\n\t* include/profile/multiset.h (std::__profile::multiset<>): Likewise.\n\t* include/profile/unordered_base.h: Add some line feed.\n\t* include/profile/unordered_map: Clean useless white chars and replace\n\tspaces with tabs.\n\t* include/profile/unordered_set: Likewise.\n\t* include/profile/vector (std::__profile::_Vector_profile_pre<>): New.\n\t(std::__profile::_Vector_profile_post<>): New.\n\t(std::__profile::vector<>): Inherit from latter and adapt.\n\nFrom-SVN: r210900", "tree": {"sha": "65ff4aace7fa5361717e93817b514d7d6b2a13e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65ff4aace7fa5361717e93817b514d7d6b2a13e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/comments", "author": null, "committer": null, "parents": [{"sha": "1ebfdcab6bfc359e1f23a2801935806b46455007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ebfdcab6bfc359e1f23a2801935806b46455007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ebfdcab6bfc359e1f23a2801935806b46455007"}], "stats": {"total": 3535, "additions": 1581, "deletions": 1954}, "files": [{"sha": "c2e7127b56a5735b2a1cc8c76d6c76b947bbe97c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -1,3 +1,32 @@\n+2014-05-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/profile/array: Clean useless white chars.\n+\t* include/profile/base.h: Likewise.\n+\t* include/profile/iterator_tracker.h: Likewise.\n+\t* include/profile/bitset: Code cleanup and remove not instrumented code.\n+\t* include/profile/deque: Likewise.\n+\t* include/profile/forward_list: Likewise.\n+\t* include/profile/list (std::__profile::_List_profile<>): New.\n+\t(std::__profile::list<>): Inherit from latter and adapt.\n+\t* include/profile/impl/profiler_map_to_unordered_map.h: Generalize\n+\tadvise to match any ordered to unordered container conversion.\n+\t* include/profile/ordered_base.h (std::__profile::_Ordered_profile<>):\n+\tNew.\n+\t* include/Makefile.am: Add latter.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/profile/map.h (std::__profile::map<>): Inherit from latter,\n+\tremove not instrumented code.\n+\t* include/profile/multimap.h (std::__profile::multimap<>): Likewise.\n+\t* include/profile/set.h (std::__profile::set<>): Likewise.\n+\t* include/profile/multiset.h (std::__profile::multiset<>): Likewise.\n+\t* include/profile/unordered_base.h: Add some line feed.\n+\t* include/profile/unordered_map: Clean useless white chars and replace\n+\tspaces with tabs.\n+\t* include/profile/unordered_set: Likewise.\n+\t* include/profile/vector (std::__profile::_Vector_profile_pre<>): New.\n+\t(std::__profile::_Vector_profile_post<>): New.\n+\t(std::__profile::vector<>): Inherit from latter and adapt.\n+\n 2014-05-23  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/60793"}, {"sha": "a079ff6af0bf1cda06ee69cb173ba3fe2176a8fd", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -816,6 +816,7 @@ profile_headers = \\\n \t${profile_srcdir}/map.h \\\n \t${profile_srcdir}/multimap.h \\\n \t${profile_srcdir}/multiset.h \\\n+\t${profile_srcdir}/ordered_base.h \\\n \t${profile_srcdir}/set \\\n \t${profile_srcdir}/set.h \\\n \t${profile_srcdir}/iterator_tracker.h"}, {"sha": "502f04e04905794c0ebc1830ad3b822238157456", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -1079,6 +1079,7 @@ profile_headers = \\\n \t${profile_srcdir}/map.h \\\n \t${profile_srcdir}/multimap.h \\\n \t${profile_srcdir}/multiset.h \\\n+\t${profile_srcdir}/ordered_base.h \\\n \t${profile_srcdir}/set \\\n \t${profile_srcdir}/set.h \\\n \t${profile_srcdir}/iterator_tracker.h"}, {"sha": "3561c761525ed362c609c656ffefba5d67a06646", "filename": "libstdc++-v3/include/profile/array", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Farray?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -83,19 +83,19 @@ namespace __profile\n       end() const noexcept\n       { return const_iterator(data() + _Nm); }\n \n-      reverse_iterator \n+      reverse_iterator\n       rbegin() noexcept\n       { return reverse_iterator(end()); }\n \n-      const_reverse_iterator \n+      const_reverse_iterator\n       rbegin() const noexcept\n       { return const_reverse_iterator(end()); }\n \n-      reverse_iterator \n+      reverse_iterator\n       rend() noexcept\n       { return reverse_iterator(begin()); }\n \n-      const_reverse_iterator \n+      const_reverse_iterator\n       rend() const noexcept\n       { return const_reverse_iterator(begin()); }\n \n@@ -107,22 +107,22 @@ namespace __profile\n       cend() const noexcept\n       { return const_iterator(data() + _Nm); }\n \n-      const_reverse_iterator \n+      const_reverse_iterator\n       crbegin() const noexcept\n       { return const_reverse_iterator(end()); }\n \n-      const_reverse_iterator \n+      const_reverse_iterator\n       crend() const noexcept\n       { return const_reverse_iterator(begin()); }\n \n       // Capacity.\n-      constexpr size_type \n+      constexpr size_type\n       size() const noexcept { return _Nm; }\n \n-      constexpr size_type \n+      constexpr size_type\n       max_size() const noexcept { return _Nm; }\n \n-      constexpr bool \n+      constexpr bool\n       empty() const noexcept { return size() == 0; }\n \n       // Element access.\n@@ -157,23 +157,23 @@ namespace __profile\n \t     _AT_Type::_S_ref(_M_elems, 0));\n       }\n \n-      reference \n+      reference\n       front() noexcept\n       { return *begin(); }\n \n-      constexpr const_reference \n+      constexpr const_reference\n       front() const noexcept\n       { return _AT_Type::_S_ref(_M_elems, 0); }\n \n-      reference \n+      reference\n       back() noexcept\n       { return _Nm ? *(end() - 1) : *end(); }\n \n-      constexpr const_reference \n+      constexpr const_reference\n       back() const noexcept\n       {\n \treturn _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)\n- \t           : _AT_Type::_S_ref(_M_elems, 0);\t  \n+\t\t   : _AT_Type::_S_ref(_M_elems, 0);\n       }\n \n       pointer\n@@ -187,7 +187,7 @@ namespace __profile\n \n   // Array comparisons.\n   template<typename _Tp, std::size_t _Nm>\n-    inline bool \n+    inline bool\n     operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n     { return std::equal(__one.begin(), __one.end(), __two.begin()); }\n \n@@ -199,9 +199,9 @@ namespace __profile\n   template<typename _Tp, std::size_t _Nm>\n     inline bool\n     operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)\n-    { \n+    {\n       return std::lexicographical_compare(__a.begin(), __a.end(),\n-\t\t\t\t\t  __b.begin(), __b.end()); \n+\t\t\t\t\t  __b.begin(), __b.end());\n     }\n \n   template<typename _Tp, std::size_t _Nm>"}, {"sha": "9ca0c3f4aba84c3891639cb172aa811b8661238e", "filename": "libstdc++-v3/include/profile/base.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbase.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -40,9 +40,9 @@\n  * @namespace std::__profile\n  * @brief GNU profile code, replaces standard behavior with profile behavior.\n  */\n-namespace std _GLIBCXX_VISIBILITY(default) \n-{ \n-  namespace __profile { } \n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+  namespace __profile { }\n }\n \n /**"}, {"sha": "651f25cd885e825e6e2cd63b672bacd926c12a17", "filename": "libstdc++-v3/include/profile/bitset", "status": "modified", "additions": 11, "deletions": 148, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fbitset?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -35,68 +35,22 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __profile\n {\n-  /// Class std::bitset wrapper with performance instrumentation.\n+  /// Class std::bitset wrapper with performance instrumentation, none at the\n+  /// moment.\n   template<size_t _Nb>\n     class bitset\n     : public _GLIBCXX_STD_C::bitset<_Nb>\n     {\n       typedef _GLIBCXX_STD_C::bitset<_Nb> _Base;\n \n     public:\n-      // bit reference:\n-      class reference\n-      : private _Base::reference\n-      {\n-\ttypedef typename _Base::reference _Base_ref;\n-\n-\tfriend class bitset;\n-\treference();\n-\n-\treference(const _Base_ref& __base, bitset* __seq) _GLIBCXX_NOEXCEPT\n-\t: _Base_ref(__base)\n-\t{ }\n-\n-      public:\n-\treference(const reference& __x) _GLIBCXX_NOEXCEPT\n-\t: _Base_ref(__x)\n-\t{ }\n-\n-\treference&\n-\toperator=(bool __x) _GLIBCXX_NOEXCEPT\n-\t{\n-\t  *static_cast<_Base_ref*>(this) = __x;\n-\t  return *this;\n-\t}\n-\n-\treference&\n-\toperator=(const reference& __x) _GLIBCXX_NOEXCEPT\n-\t{\n-\t  *static_cast<_Base_ref*>(this) = __x;\n-\t  return *this;\n-\t}\n-\n-\tbool\n-\toperator~() const _GLIBCXX_NOEXCEPT\n-\t{\n-\t  return ~(*static_cast<const _Base_ref*>(this));\n-\t}\n-\n-\toperator bool() const _GLIBCXX_NOEXCEPT\n-\t{\n-\t  return *static_cast<const _Base_ref*>(this);\n-\t}\n-\n-\treference&\n-\tflip() _GLIBCXX_NOEXCEPT\n-\t{\n-\t  _Base_ref::flip();\n-\t  return *this;\n-\t}\n-      };\n-\n       // 23.3.5.1 constructors:\n-      _GLIBCXX_CONSTEXPR bitset() _GLIBCXX_NOEXCEPT\n+#if __cplusplus < 201103L\n+      bitset()\n       : _Base() { }\n+#else\n+      constexpr bitset() = default;\n+#endif\n \n #if __cplusplus >= 201103L\n       constexpr bitset(unsigned long long __val) noexcept\n@@ -106,8 +60,8 @@ namespace __profile\n       : _Base(__val) { }\n \n       template<typename _CharT, typename _Traits, typename _Alloc>\n-        explicit\n-        bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __str,\n+\texplicit\n+\tbitset(const std::basic_string<_CharT, _Traits, _Alloc>& __str,\n \t       typename std::basic_string<_CharT, _Traits, _Alloc>::size_type\n \t       __pos = 0,\n \t       typename std::basic_string<_CharT, _Traits, _Alloc>::size_type\n@@ -129,8 +83,8 @@ namespace __profile\n \n #if __cplusplus >= 201103L\n       template<typename _CharT>\n-        explicit\n-        bitset(const _CharT* __str,\n+\texplicit\n+\tbitset(const _CharT* __str,\n \t       typename std::basic_string<_CharT>::size_type __n\n \t       = std::basic_string<_CharT>::npos,\n \t       _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))\n@@ -221,92 +175,6 @@ namespace __profile\n \treturn *this;\n       }\n \n-      // element access:\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 11. Bitset minor problems\n-      reference\n-      operator[](size_t __pos)\n-      {\n-\treturn reference(_M_base()[__pos], this);\n-      }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 11. Bitset minor problems\n-      _GLIBCXX_CONSTEXPR bool\n-      operator[](size_t __pos) const\n-      {\n-\treturn _Base::operator[](__pos);\n-      }\n-\n-      using _Base::to_ulong;\n-#if __cplusplus >= 201103L\n-      using _Base::to_ullong;\n-#endif\n-\n-      template <typename _CharT, typename _Traits, typename _Alloc>\n-        std::basic_string<_CharT, _Traits, _Alloc>\n-        to_string() const\n-        { return _M_base().template to_string<_CharT, _Traits, _Alloc>(); }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 396. what are characters zero and one.\n-      template<class _CharT, class _Traits, class _Alloc>\n-\tstd::basic_string<_CharT, _Traits, _Alloc>\n-\tto_string(_CharT __zero, _CharT __one = _CharT('1')) const\n-\t{\n-\t  return _M_base().template\n-\t    to_string<_CharT, _Traits, _Alloc>(__zero, __one);\n-\t}\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 434. bitset::to_string() hard to use.\n-      template<typename _CharT, typename _Traits>\n-        std::basic_string<_CharT, _Traits, std::allocator<_CharT> >\n-        to_string() const\n-        { return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 853. to_string needs updating with zero and one.\n-      template<class _CharT, class _Traits>\n-\tstd::basic_string<_CharT, _Traits, std::allocator<_CharT> >\n-\tto_string(_CharT __zero, _CharT __one = _CharT('1')) const\n-\t{ return to_string<_CharT, _Traits,\n-\t                   std::allocator<_CharT> >(__zero, __one); }\n-\n-      template<typename _CharT>\n-        std::basic_string<_CharT, std::char_traits<_CharT>,\n-                          std::allocator<_CharT> >\n-        to_string() const\n-        {\n-          return to_string<_CharT, std::char_traits<_CharT>,\n-                           std::allocator<_CharT> >();\n-        }\n-\n-      template<class _CharT>\n-\tstd::basic_string<_CharT, std::char_traits<_CharT>,\n-\t                  std::allocator<_CharT> >\n-\tto_string(_CharT __zero, _CharT __one = _CharT('1')) const\n-\t{\n-\t  return to_string<_CharT, std::char_traits<_CharT>,\n-\t                   std::allocator<_CharT> >(__zero, __one);\n-\t}\n-\n-      std::basic_string<char, std::char_traits<char>, std::allocator<char> >\n-      to_string() const\n-      {\n-\treturn to_string<char,std::char_traits<char>,std::allocator<char> >();\n-      }\n-\n-      std::basic_string<char, std::char_traits<char>, std::allocator<char> >\n-      to_string(char __zero, char __one = '1') const\n-      {\n-\treturn to_string<char, std::char_traits<char>,\n-\t                 std::allocator<char> >(__zero, __one);\n-      }\n-\n-      using _Base::count;\n-      using _Base::size;\n-\n       bool\n       operator==(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT\n       { return _M_base() == __rhs; }\n@@ -315,11 +183,6 @@ namespace __profile\n       operator!=(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT\n       { return _M_base() != __rhs; }\n \n-      using _Base::test;\n-      using _Base::all;\n-      using _Base::any;\n-      using _Base::none;\n-\n       bitset<_Nb>\n       operator<<(size_t __pos) const _GLIBCXX_NOEXCEPT\n       { return bitset<_Nb>(_M_base() << __pos); }"}, {"sha": "13513f4bdc76d0200a174983499fd9373ee0bbce", "filename": "libstdc++-v3/include/profile/deque", "status": "modified", "additions": 32, "deletions": 327, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fdeque?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -43,26 +43,29 @@ namespace __profile\n       typedef  _GLIBCXX_STD_C::deque<_Tp, _Allocator> _Base;\n \n     public:\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n-\n-      typedef typename _Base::iterator             iterator;\n-      typedef typename _Base::const_iterator       const_iterator;\n-      typedef typename _Base::reverse_iterator     reverse_iterator;\n-      typedef typename _Base::const_reverse_iterator const_reverse_iterator;\n-\n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n-\n-      typedef _Tp\t\t\t\t    value_type;\n-      typedef _Allocator\t\t\t    allocator_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::value_type\t\tvalue_type;\n \n       // 23.2.1.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       deque()\n       : _Base() { }\n+      deque(const deque& __x)\n+      : _Base(__x) { }\n+\n+      ~deque() { }\n+#else\n+      deque() = default;\n+      deque(const deque&) = default;\n+      deque(deque&&) = default;\n+\n+      ~deque() = default;\n+\n+      deque(initializer_list<value_type> __l,\n+\t    const _Allocator& __a = _Allocator())\n+      : _Base(__l, __a) { }\n+#endif\n \n       explicit\n       deque(const _Allocator& __a)\n@@ -89,346 +92,48 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-        deque(_InputIterator __first, _InputIterator __last,\n+\tdeque(_InputIterator __first, _InputIterator __last,\n \t      const _Allocator& __a = _Allocator())\n \t: _Base(__first, __last, __a)\n-        { }\n-\n-      deque(const deque& __x)\n-      : _Base(__x) { }\n+\t{ }\n \n       deque(const _Base& __x)\n       : _Base(__x) { }\n \n-#if __cplusplus >= 201103L\n-      deque(deque&& __x)\n-      : _Base(std::move(__x))\n-      { }\n-\n-      deque(initializer_list<value_type> __l,\n-\t    const allocator_type& __a = allocator_type())\n-      : _Base(__l, __a) { }\n-#endif\n-\n-      ~deque() _GLIBCXX_NOEXCEPT { }\n-\n+#if __cplusplus < 201103L\n       deque&\n       operator=(const deque& __x)\n       {\n-\t*static_cast<_Base*>(this) = __x;\n+\t_M_base() = __x;\n \treturn *this;\n       }\n+#else\n+      deque&\n+      operator=(const deque&) = default;\n \n-#if __cplusplus >= 201103L\n       deque&\n-      operator=(deque&& __x) noexcept\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\n-      }\n+      operator=(deque&&) = default;\n \n       deque&\n       operator=(initializer_list<value_type> __l)\n       {\n-\t*static_cast<_Base*>(this) = __l;\n+\t_M_base() = __l;\n \treturn *this;\n       }\n #endif\n \n-#if __cplusplus >= 201103L\n-      template<typename _InputIterator,\n-\t       typename = std::_RequireInputIter<_InputIterator>>\n-#else\n-      template<typename _InputIterator>\n-#endif\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n-\t  _Base::assign(__first, __last);\n-\t}\n-\n-      void\n-      assign(size_type __n, const _Tp& __t)\n-      {\n-\t_Base::assign(__n, __t);\n-      }\n-\n-#if __cplusplus >= 201103L\n-      void\n-      assign(initializer_list<value_type> __l)\n-      {\n-\t_Base::assign(__l);\n-      }\n-#endif\n-\n-      using _Base::get_allocator;\n-\n-      // iterators:\n-      iterator\n-      begin() _GLIBCXX_NOEXCEPT\n-      { return iterator(_Base::begin()); }\n-\n-      const_iterator\n-      begin() const _GLIBCXX_NOEXCEPT\n-      { return const_iterator(_Base::begin()); }\n-\n-      iterator\n-      end() _GLIBCXX_NOEXCEPT\n-      { return iterator(_Base::end()); }\n-\n-      const_iterator\n-      end() const _GLIBCXX_NOEXCEPT\n-      { return const_iterator(_Base::end()); }\n-\n-      reverse_iterator\n-      rbegin() _GLIBCXX_NOEXCEPT\n-      { return reverse_iterator(end()); }\n-\n-      const_reverse_iterator\n-      rbegin() const _GLIBCXX_NOEXCEPT\n-      { return const_reverse_iterator(end()); }\n-\n-      reverse_iterator\n-      rend() _GLIBCXX_NOEXCEPT\n-      { return reverse_iterator(begin()); }\n-\n-      const_reverse_iterator\n-      rend() const _GLIBCXX_NOEXCEPT\n-      { return const_reverse_iterator(begin()); }\n-\n-#if __cplusplus >= 201103L\n-      const_iterator\n-      cbegin() const noexcept\n-      { return const_iterator(_Base::begin()); }\n-\n-      const_iterator\n-      cend() const noexcept\n-      { return const_iterator(_Base::end()); }\n-\n-      const_reverse_iterator\n-      crbegin() const noexcept\n-      { return const_reverse_iterator(end()); }\n-\n-      const_reverse_iterator\n-      crend() const noexcept\n-      { return const_reverse_iterator(begin()); }\n-#endif\n-\n-      // 23.2.1.2 capacity:\n-      using _Base::size;\n-      using _Base::max_size;\n-\n-#if __cplusplus >= 201103L\n-      void\n-      resize(size_type __sz)\n-      {\n-\t_Base::resize(__sz);\n-      }\n-\n-      void\n-      resize(size_type __sz, const _Tp& __c)\n-      {\n-\t_Base::resize(__sz, __c);\n-      }\n-#else\n       void\n-      resize(size_type __sz, _Tp __c = _Tp())\n-      {\n-\t_Base::resize(__sz, __c);\n-      }\n-#endif\n-\n+      swap(deque& __x)\n #if __cplusplus >= 201103L\n-      using _Base::shrink_to_fit;\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n-\n-      using _Base::empty;\n-\n-      // element access:\n-      reference\n-      operator[](size_type __n) _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _M_base()[__n];\n-      }\n-\n-      const_reference\n-      operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _M_base()[__n];\n-      }\n-\n-      using _Base::at;\n-\n-      reference\n-      front() _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _Base::front();\n-      }\n-\n-      const_reference\n-      front() const _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _Base::front();\n-      }\n-\n-      reference\n-      back() _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _Base::back();\n-      }\n-\n-      const_reference\n-      back() const _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _Base::back();\n-      }\n-\n-      // 23.2.1.3 modifiers:\n-      void\n-      push_front(const _Tp& __x)\n-      {\n-\t_Base::push_front(__x);\n-      }\n-\n-      void\n-      push_back(const _Tp& __x)\n-      {\n-\t_Base::push_back(__x);\n-      }\n-\n-#if __cplusplus >= 201103L\n-      void\n-      push_front(_Tp&& __x)\n-      { emplace_front(std::move(__x)); }\n-\n-      void\n-      push_back(_Tp&& __x)\n-      { emplace_back(std::move(__x)); }\n-\n-      template<typename... _Args>\n-        void\n-        emplace_front(_Args&&... __args)\n-\t{\n-\t  _Base::emplace_front(std::forward<_Args>(__args)...);\n-\t}\n-\n-      template<typename... _Args>\n-        void\n-        emplace_back(_Args&&... __args)\n-\t{\n-\t  _Base::emplace_back(std::forward<_Args>(__args)...);\n-\t}\n-\n-      template<typename... _Args>\n-        iterator\n-        emplace(const_iterator __position, _Args&&... __args)\n-\t{\n-\t  typename _Base::iterator __res = _Base::emplace(__position,\n-\t\t\t\t\t    std::forward<_Args>(__args)...);\n-\t  return iterator(__res);\n-\t}\n-#endif\n-\n-      iterator\n-#if __cplusplus >= 201103L\n-      insert(const_iterator __position, const _Tp& __x)\n-#else\n-      insert(iterator __position, const _Tp& __x)\n-#endif\n-      {\n-\ttypename _Base::iterator __res = _Base::insert(__position, __x);\n-\treturn iterator(__res);\n-      }\n-\n-#if __cplusplus >= 201103L\n-      iterator\n-      insert(const_iterator __position, _Tp&& __x)\n-      { return emplace(__position, std::move(__x)); }\n-\n-      iterator\n-      insert(const_iterator __p, initializer_list<value_type> __l)\n-      { return _Base::insert(__p, __l); }\n-#endif\n-\n-#if __cplusplus >= 201103L\n-      iterator\n-      insert(const_iterator __position, size_type __n, const _Tp& __x)\n-      { return _Base::insert(__position, __n, __x); }\n-#else\n-      void\n-      insert(iterator __position, size_type __n, const _Tp& __x)\n-      { _Base::insert(__position, __n, __x); }\n-#endif\n-\n-#if __cplusplus >= 201103L\n-      template<typename _InputIterator,\n-\t       typename = std::_RequireInputIter<_InputIterator>>\n-        iterator\n-        insert(const_iterator __position,\n-\t       _InputIterator __first, _InputIterator __last)\n-        { return _Base::insert(__position, __first, __last); }\n-#else\n-      template<typename _InputIterator>\n-        void\n-        insert(iterator __position,\n-\t       _InputIterator __first, _InputIterator __last)\n-        { _Base::insert(__position, __first, __last); }\n-#endif\n-\n-      void\n-      pop_front() _GLIBCXX_NOEXCEPT\n-      {\n-\t_Base::pop_front();\n-      }\n-\n-      void\n-      pop_back() _GLIBCXX_NOEXCEPT\n-      {\n-\t_Base::pop_back();\n-      }\n-\n-      iterator\n-#if __cplusplus >= 201103L\n-      erase(const_iterator __position)\n-#else\n-      erase(iterator __position)\t\n-#endif\n-      {\n-\treturn _Base::erase(__position);\n-      }\n-\n-      iterator\n-#if __cplusplus >= 201103L\n-      erase(const_iterator __first, const_iterator __last)\n-#else\n-      erase(iterator __first, iterator __last)\n-#endif\n-      {\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 151. can't currently clear() empty container\n-        return _Base::erase(__first, __last);\n-      }\n-\n-      void\n-      swap(deque& __x) _GLIBCXX_NOEXCEPT\n-      {\n-\t_Base::swap(__x);\n-      }\n-\n-      void\n-      clear() _GLIBCXX_NOEXCEPT\n-      {\n-\t_Base::clear();\n-      }\n+      { _Base::swap(__x); }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n     };\n \n   template<typename _Tp, typename _Alloc>"}, {"sha": "290e4f9d703ad8c736731f48d9182ef88dde7843", "filename": "libstdc++-v3/include/profile/forward_list", "status": "modified", "additions": 74, "deletions": 41, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fforward_list?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -46,13 +46,9 @@ namespace __profile\n     {\n       typedef _GLIBCXX_STD_C::forward_list<_Tp, _Alloc> _Base;\n \n-      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n-        rebind<_GLIBCXX_STD_C::_Fwd_list_node<_Tp>>::other _Node_alloc_type;\n-\n-      typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;\n-\n     public:\n-      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::size_type\t\tsize_type;\n+      typedef typename _Base::const_iterator\tconst_iterator;\n \n       // 23.2.3.1 construct/copy/destroy:\n       explicit\n@@ -73,98 +69,135 @@ namespace __profile\n       { }\n \n       forward_list(size_type __n, const _Tp& __value,\n-                   const _Alloc& __al = _Alloc())\n+\t\t   const _Alloc& __al = _Alloc())\n       : _Base(__n, __value, __al)\n       { }\n \n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        forward_list(_InputIterator __first, _InputIterator __last,\n-                     const _Alloc& __al = _Alloc())\n-        : _Base(__first, __last, __al)\n-        { }\n-\n-      forward_list(const forward_list& __list)\n-      : _Base(__list)\n-      { }\n+\tforward_list(_InputIterator __first, _InputIterator __last,\n+\t\t     const _Alloc& __al = _Alloc())\n+\t: _Base(__first, __last, __al)\n+\t{ }\n \n-      forward_list(forward_list&& __list) noexcept\n-      : _Base(std::move(__list)) { }\n+      forward_list(const forward_list&) = default;\n+      forward_list(forward_list&&) = default;\n \n       forward_list(std::initializer_list<_Tp> __il,\n-                   const _Alloc& __al = _Alloc())\n+\t\t   const _Alloc& __al = _Alloc())\n       : _Base(__il, __al)\n       { }\n \n-      ~forward_list() noexcept\n-      { }\n+      ~forward_list() = default;\n \n       forward_list&\n-      operator=(const forward_list& __list)\n-      {\n-\tstatic_cast<_Base&>(*this) = __list;\n-\treturn *this;\n-      }\n+      operator=(const forward_list&) = default;\n \n       forward_list&\n-      operator=(forward_list&& __list)\n-      noexcept(_Node_alloc_traits::_S_nothrow_move())\n-      {\n-\tstatic_cast<_Base&>(*this) = std::move(__list);\n-\treturn *this;\n-      }\n+      operator=(forward_list&&) = default;\n \n       forward_list&\n       operator=(std::initializer_list<_Tp> __il)\n       {\n-\tstatic_cast<_Base&>(*this) = __il;\n-        return *this;\n+\t_M_base() = __il;\n+\treturn *this;\n       }\n \n+      void\n+      swap(forward_list& __fl)\n+\tnoexcept( noexcept(declval<_Base>().swap(__fl)) )\n+      { _Base::swap(__fl); }\n+\n+      void\n+      splice_after(const_iterator __pos, forward_list&& __fl)\n+      { _Base::splice_after(__pos, std::move(__fl)); }\n+\n+      void\n+      splice_after(const_iterator __pos, forward_list& __list)\n+      { _Base::splice_after(__pos, __list); }\n+\n+      void\n+      splice_after(const_iterator __pos, forward_list&& __list,\n+\t\t   const_iterator __i)\n+      { _Base::splice_after(__pos, std::move(__list), __i); }\n+\n+      void\n+      splice_after(const_iterator __pos, forward_list& __list,\n+\t\t   const_iterator __i)\n+      { _Base::splice_after(__pos, __list, __i); }\n+\n+      void\n+      splice_after(const_iterator __pos, forward_list&& __list,\n+\t\t   const_iterator __before, const_iterator __last)\n+      { _Base::splice_after(__pos, std::move(__list), __before, __last); }\n+\n+      void\n+      splice_after(const_iterator __pos, forward_list& __list,\n+\t\t   const_iterator __before, const_iterator __last)\n+      { _Base::splice_after(__pos, __list, __before, __last); }\n+\n+      void\n+      merge(forward_list&& __list)\n+      { _Base::merge(std::move(__list)); }\n+\n+      void\n+      merge(forward_list& __list)\n+      { _Base::merge(__list); }\n+\n+      template<typename _Comp>\n+\tvoid\n+\tmerge(forward_list&& __list, _Comp __comp)\n+\t{ _Base::merge(std::move(__list), __comp); }\n+\n+      template<typename _Comp>\n+\tvoid\n+\tmerge(forward_list& __list, _Comp __comp)\n+\t{ _Base::merge(__list, __comp); }\n+\n       _Base&\n-      _M_base() noexcept       { return *this; }\n+      _M_base() noexcept\t{ return *this; }\n \n       const _Base&\n-      _M_base() const noexcept { return *this; }\n+      _M_base() const noexcept\t{ return *this; }\n     };\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator==(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return __lx._M_base() == __ly._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<(const forward_list<_Tp, _Alloc>& __lx,\n-              const forward_list<_Tp, _Alloc>& __ly)\n+\t      const forward_list<_Tp, _Alloc>& __ly)\n     { return __lx._M_base() < __ly._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__lx == __ly); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>(const forward_list<_Tp, _Alloc>& __lx,\n-              const forward_list<_Tp, _Alloc>& __ly)\n+\t      const forward_list<_Tp, _Alloc>& __ly)\n     { return (__ly < __lx); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__lx < __ly); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<=(const forward_list<_Tp, _Alloc>& __lx,\n-               const forward_list<_Tp, _Alloc>& __ly)\n+\t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__ly < __lx); }\n \n   /// See std::forward_list::swap()."}, {"sha": "c1b2da1076596eca934343da53cee4ed5a655f9b", "filename": "libstdc++-v3/include/profile/impl/profiler_map_to_unordered_map.h", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -40,15 +40,15 @@ namespace __gnu_profile\n   __log2(std::size_t __size)\n   {\n     for (int __bit_count = sizeof(std::size_t) - 1; __bit_count >= 0;\n-\t -- __bit_count) \n+\t -- __bit_count)\n       if ((2 << __bit_count) & __size)\n \treturn __bit_count;\n     return 0;\n   }\n \n   inline float\n   __map_insert_cost(std::size_t __size)\n-  { return (_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor).__value \n+  { return (_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor).__value\n \t    * static_cast<float>(__log2(__size))); }\n \n   inline float\n@@ -61,7 +61,7 @@ namespace __gnu_profile\n   { return (_GLIBCXX_PROFILE_DATA(__map_find_cost_factor).__value\n \t    * static_cast<float>(__log2(__size))); }\n \n-  /** @brief A map-to-unordered_map instrumentation line in the \n+  /** @brief A map-to-unordered_map instrumentation line in the\n       object table.  */\n   class __map2umap_info\n   : public __object_info_base\n@@ -70,9 +70,9 @@ namespace __gnu_profile\n     __map2umap_info()\n     : _M_insert(0), _M_erase(0), _M_find(0), _M_iterate(0),\n       _M_umap_cost(0.0), _M_map_cost(0.0), _M_valid(true) { }\n-    \n+\n     __map2umap_info(__stack_t __stack)\n-    : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0), \n+    : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0),\n       _M_iterate(0), _M_umap_cost(0.0), _M_map_cost(0.0), _M_valid(true) { }\n \n     virtual ~__map2umap_info() { }\n@@ -108,32 +108,38 @@ namespace __gnu_profile\n \n     std::string\n     __advice() const\n-    { return \"change std::map to std::unordered_map\"; }\n+    { return \"prefer an unordered container\"; }\n \n     void\n     __record_insert(std::size_t __size, std::size_t __count)\n     {\n-      _M_insert += __count;\n-      _M_map_cost += __count * __map_insert_cost(__size);\n-      _M_umap_cost\n-\t+= (__count\n-\t    * _GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor).__value);\n+      ++_M_insert;\n+      if (__count)\n+\t{\n+\t  _M_map_cost += __count * __map_insert_cost(__size);\n+\t  _M_umap_cost\n+\t    += (__count\n+\t\t* _GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor).__value);\n+\t}\n     }\n \n     void\n     __record_erase(std::size_t __size, std::size_t __count)\n     {\n-      _M_erase += __count;\n-      _M_map_cost += __count * __map_erase_cost(__size);\n-      _M_umap_cost\n-\t+= (__count\n-\t    * _GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor).__value);\n+      ++_M_erase;\n+      if (__count)\n+\t{\n+\t  _M_map_cost += __count * __map_erase_cost(__size);\n+\t  _M_umap_cost\n+\t    += (__count\n+\t\t* _GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor).__value);\n+\t}\n     }\n \n     void\n     __record_find(std::size_t __size)\n     {\n-      _M_find += 1;\n+      ++_M_find;\n       _M_map_cost += __map_find_cost(__size);\n       _M_umap_cost += _GLIBCXX_PROFILE_DATA(__umap_find_cost_factor).__value;\n     }\n@@ -165,9 +171,9 @@ namespace __gnu_profile\n   };\n \n \n-  /** @brief A map-to-unordered_map instrumentation line in the \n+  /** @brief A map-to-unordered_map instrumentation line in the\n       stack table.  */\n-  class __map2umap_stack_info \n+  class __map2umap_stack_info\n   : public __map2umap_info\n   {\n   public:\n@@ -177,12 +183,12 @@ namespace __gnu_profile\n \n   /** @brief Map-to-unordered_map instrumentation producer.  */\n   class __trace_map2umap\n-  : public __trace_base<__map2umap_info, __map2umap_stack_info> \n+  : public __trace_base<__map2umap_info, __map2umap_stack_info>\n   {\n   public:\n     __trace_map2umap()\n     : __trace_base<__map2umap_info, __map2umap_stack_info>()\n-    { __id = \"map-to-unordered-map\"; }\n+    { __id = \"ordered-to-unordered\"; }\n   };\n \n   inline void\n@@ -193,7 +199,7 @@ namespace __gnu_profile\n   __trace_map_to_unordered_map_report(FILE* __f,\n \t\t\t\t      __warning_vector_t& __warnings)\n   {\n-    if (_GLIBCXX_PROFILE_DATA(_S_map2umap)) \n+    if (_GLIBCXX_PROFILE_DATA(_S_map2umap))\n       {\n \t_GLIBCXX_PROFILE_DATA(_S_map2umap)->__collect_warnings(__warnings);\n \t_GLIBCXX_PROFILE_DATA(_S_map2umap)->__write(__f);\n@@ -220,7 +226,7 @@ namespace __gnu_profile\n   }\n \n   inline void\n-  __trace_map_to_unordered_map_insert(const void* __obj, \n+  __trace_map_to_unordered_map_insert(const void* __obj,\n \t\t\t\t      std::size_t __size, std::size_t __count)\n   {\n     if (!__profcxx_init())\n@@ -234,13 +240,13 @@ namespace __gnu_profile\n   }\n \n   inline void\n-  __trace_map_to_unordered_map_erase(const void* __obj, \n+  __trace_map_to_unordered_map_erase(const void* __obj,\n \t\t\t\t     std::size_t __size, std::size_t __count)\n   {\n-    if (!__profcxx_init()) \n+    if (!__profcxx_init())\n       return;\n \n-    __map2umap_info* __info \n+    __map2umap_info* __info\n       = _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n     if (__info)\n@@ -268,7 +274,7 @@ namespace __gnu_profile\n \n     __map2umap_info* __info\n       = _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n-    \n+\n     if (__info)\n       __info->__record_iterate(__count);\n   }"}, {"sha": "9b2aeab5e834d08b37d37201e5540c5726547f63", "filename": "libstdc++-v3/include/profile/iterator_tracker.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fiterator_tracker.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fiterator_tracker.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fiterator_tracker.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -35,9 +35,8 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __profile\n {\n-\n   template<typename _Iterator, typename _Sequence>\n-    class __iterator_tracker \n+    class __iterator_tracker\n     {\n       typedef __iterator_tracker _Self;\n \n@@ -49,12 +48,12 @@ namespace __profile\n       typedef std::iterator_traits<_Iterator> _Traits;\n \n     public:\n-      typedef _Iterator\t\t              _Base_iterator;\n-      typedef typename _Traits::iterator_category iterator_category; \n-      typedef typename _Traits::value_type        value_type;\n-      typedef typename _Traits::difference_type   difference_type;\n-      typedef typename _Traits::reference         reference;\n-      typedef typename _Traits::pointer           pointer;\n+      typedef _Iterator\t\t\t\t\t_Base_iterator;\n+      typedef typename _Traits::iterator_category\titerator_category;\n+      typedef typename _Traits::value_type\t\tvalue_type;\n+      typedef typename _Traits::difference_type\t\tdifference_type;\n+      typedef typename _Traits::reference\t\treference;\n+      typedef typename _Traits::pointer\t\t\tpointer;\n \n       __iterator_tracker() _GLIBCXX_NOEXCEPT\n       : _M_current(), _M_ds(0) { }\n@@ -67,7 +66,7 @@ namespace __profile\n       : _M_current(__x._M_current), _M_ds(__x._M_ds) { }\n \n       template<typename _MutableIterator>\n-        __iterator_tracker(const __iterator_tracker<_MutableIterator,\n+\t__iterator_tracker(const __iterator_tracker<_MutableIterator,\n \t\t\t   typename __gnu_cxx::__enable_if\n \t\t\t   <(std::__are_same<_MutableIterator, typename\n \t\t\t     _Sequence::iterator::_Base_iterator>::__value),\n@@ -76,7 +75,7 @@ namespace __profile\n \n       _Iterator\n       base() const _GLIBCXX_NOEXCEPT { return _M_current; }\n-  \n+\n       /**\n        * @brief Conversion to underlying non-debug iterator to allow\n        * better interaction with non-profile containers.\n@@ -199,7 +198,7 @@ namespace __profile\n   template<typename _Iterator, typename _Sequence>\n     inline bool\n     operator!=(const __iterator_tracker<_Iterator, _Sequence>& __lhs,\n-               const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n+\t       const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() != __rhs.base(); }\n "}, {"sha": "438b440108c25116d293d0f544f09a0a5b12043e", "filename": "libstdc++-v3/include/profile/list", "status": "modified", "additions": 151, "deletions": 243, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -30,81 +30,109 @@\n #define _GLIBCXX_PROFILE_LIST 1\n \n #include <list>\n-#include <profile/base.h> \n-#include <profile/iterator_tracker.h> \n+#include <profile/base.h>\n+#include <profile/iterator_tracker.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __profile\n {\n+  template<typename _List>\n+    class _List_profile\n+    {\n+      _List&\n+      _M_conjure()\n+      { return *static_cast<_List*>(this); }\n+\n+    public:\n+      _List_profile() _GLIBCXX_NOEXCEPT\n+      {\n+\t__profcxx_list_construct(&_M_conjure()); \t// list2slist\n+\t__profcxx_list_construct2(&_M_conjure()); \t// list2vector\n+      }\n+\n+#if __cplusplus >= 201103L\n+      _List_profile(const _List_profile&) noexcept\n+      : _List_profile() { }\n+      _List_profile(_List_profile&&) noexcept\n+      : _List_profile() { }\n+\n+      _List_profile&\n+      operator=(const _List_profile&) = default;\n+      _List_profile&\n+      operator=(_List_profile&&) = default;\n+#endif\n+\n+      ~_List_profile()\n+      {\n+\t__profcxx_list_destruct(&_M_conjure());\n+\t__profcxx_list_destruct2(&_M_conjure());\n+      }\n+    };\n+\n   /** @brief List wrapper with performance instrumentation.  */\n-template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n+  template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n     class list\n-    : public _GLIBCXX_STD_C::list<_Tp, _Allocator>\n+    : public _GLIBCXX_STD_C::list<_Tp, _Allocator>,\n+      public _List_profile<list<_Tp, _Allocator> >\n     {\n-      typedef _GLIBCXX_STD_C::list<_Tp, _Allocator> _Base;\n+      typedef _GLIBCXX_STD_C::list<_Tp, _Allocator>\t_Base;\n \n     public:\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n-      typedef __iterator_tracker<typename _Base::iterator, list>        \n-\t\t\t\t                    iterator;\n-      typedef __iterator_tracker<typename _Base::const_iterator, list>  \n-                                                    const_iterator;\n+      typedef __iterator_tracker<typename _Base::iterator, list>\n+\t\t\t\t\t\t\titerator;\n+      typedef __iterator_tracker<typename _Base::const_iterator, list>\n+\t\t\t\t\t\t\tconst_iterator;\n \n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n \n-      typedef _Tp\t\t\t\t    value_type;\n-      typedef _Allocator\t\t\t    allocator_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n-      typedef std::reverse_iterator<iterator>       reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef _Tp\t\t\t\t\tvalue_type;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n \n       // 23.2.2.1 construct/copy/destroy:\n \n-      list() _GLIBCXX_NOEXCEPT\n-      : _Base()\n-      {\n-        __profcxx_list_construct(this); \t// list2slist\n-        __profcxx_list_construct2(this); \t// list2vector\n-      }\n+#if __cplusplus < 201103L\n+      list() { }\n+      list(const list& __x)\n+      : _Base(__x) { }\n+\n+      ~list() { }\n+#else\n+      list() = default;\n+      list(const list&) = default;\n+      list(list&&) = default;\n+      ~list() = default;\n+\n+      list(initializer_list<value_type> __l,\n+\t   const allocator_type& __a = allocator_type())\n+      : _Base(__l, __a) { }\n+#endif\n \n       explicit\n       list(const _Allocator& __a) _GLIBCXX_NOEXCEPT\n-      : _Base(__a) \n-      {\n-        __profcxx_list_construct(this); \t// list2slist\n-        __profcxx_list_construct2(this); \t// list2vector\n-      }\n+      : _Base(__a) { }\n \n #if __cplusplus >= 201103L\n       explicit\n       list(size_type __n)\n-      : _Base(__n) \n-      {\n-        __profcxx_list_construct(this); \n-        __profcxx_list_construct2(this); \n-      }\n+      : _Base(__n) { }\n \n       list(size_type __n, const _Tp& __value,\n \t   const _Allocator& __a = _Allocator())\n-      : _Base(__n, __value, __a) \n-      {\n-        __profcxx_list_construct(this); \n-        __profcxx_list_construct2(this); \n-      }\n+      : _Base(__n, __value, __a) { }\n #else\n       explicit\n       list(size_type __n, const _Tp& __value = _Tp(),\n \t   const _Allocator& __a = _Allocator())\n-      : _Base(__n, __value, __a) \n-      {\n-        __profcxx_list_construct(this); \n-        __profcxx_list_construct2(this); \n-      }\n+      : _Base(__n, __value, __a) { }\n #endif\n \n #if __cplusplus >= 201103L\n@@ -115,91 +143,33 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n #endif\n       list(_InputIterator __first, _InputIterator __last,\n \t   const _Allocator& __a = _Allocator())\n-      : _Base(__first, __last, __a)\n-      {\n-        __profcxx_list_construct(this); \n-        __profcxx_list_construct2(this); \n-      }\n-\n-      list(const list& __x)\n-      : _Base(__x) \n-      {\n-        __profcxx_list_construct(this); \n-        __profcxx_list_construct2(this); \n-      }\n+      : _Base(__first, __last, __a) { }\n \n       list(const _Base& __x)\n-      : _Base(__x) \n-      {\n-        __profcxx_list_construct(this); \n-        __profcxx_list_construct2(this); \n-      }\n-\n-#if __cplusplus >= 201103L\n-      list(list&& __x) noexcept\n-      : _Base(std::move(__x))\n-      {\n-        __profcxx_list_construct(this); \n-        __profcxx_list_construct2(this); \n-      }\n-\n-      list(initializer_list<value_type> __l,\n-           const allocator_type& __a = allocator_type())\n-        : _Base(__l, __a) { }\n-#endif\n-\n-      ~list() _GLIBCXX_NOEXCEPT\n-      { \n-        __profcxx_list_destruct(this); \n-        __profcxx_list_destruct2(this); \n-      }\n+      : _Base(__x) { }\n \n+#if __cplusplus < 201103L\n       list&\n       operator=(const list& __x)\n       {\n-\tstatic_cast<_Base&>(*this) = __x;\n+\t_M_base() = __x;\n \treturn *this;\n       }\n+#else\n+      list&\n+      operator=(const list&) = default;\n \n-#if __cplusplus >= 201103L\n       list&\n-      operator=(list&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\n-      }\n+      operator=(list&&) = default;\n \n       list&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tstatic_cast<_Base&>(*this) = __l;\n+\t_M_base() = __l;\n \treturn *this;\n       }\n-\n-      void\n-      assign(initializer_list<value_type> __l)\n-      {\t_Base::assign(__l); }\n #endif\n \n-#if __cplusplus >= 201103L\n-      template<typename _InputIterator,\n-\t       typename = std::_RequireInputIter<_InputIterator>>\n-#else\n-      template<class _InputIterator>\n-#endif\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        { _Base::assign(__first, __last); }\n-\n-      void\n-      assign(size_type __n, const _Tp& __t)\n-      {\t_Base::assign(__n, __t); }\n-\n-      using _Base::get_allocator;\n-\n       // iterators:\n       iterator\n       begin() _GLIBCXX_NOEXCEPT\n@@ -212,29 +182,29 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n       iterator\n       end() _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_list_rewind(this);\n-        return iterator(_Base::end(), this);\n+\t__profcxx_list_rewind(this);\n+\treturn iterator(_Base::end(), this);\n       }\n \n       const_iterator\n       end() const _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_list_rewind(this);\n-        return const_iterator(_Base::end(), this);\n+\t__profcxx_list_rewind(this);\n+\treturn const_iterator(_Base::end(), this);\n       }\n \n       reverse_iterator\n       rbegin() _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_list_rewind(this);\n-        return reverse_iterator(end());\n+\t__profcxx_list_rewind(this);\n+\treturn reverse_iterator(end());\n       }\n \n       const_reverse_iterator\n       rbegin() const _GLIBCXX_NOEXCEPT\n-      { \n-        __profcxx_list_rewind(this);\n-        return const_reverse_iterator(end());\n+      {\n+\t__profcxx_list_rewind(this);\n+\treturn const_reverse_iterator(end());\n       }\n \n       reverse_iterator\n@@ -248,11 +218,11 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n #if __cplusplus >= 201103L\n       const_iterator\n       cbegin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return const_iterator(_Base::cbegin(), this); }\n \n       const_iterator\n       cend() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return const_iterator(_Base::cend(), this); }\n \n       const_reverse_iterator\n       crbegin() const noexcept\n@@ -264,89 +234,50 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n #endif\n \n       // 23.2.2.2 capacity:\n-      using _Base::empty;\n-      using _Base::size;\n-      using _Base::max_size;\n-\n-#if __cplusplus >= 201103L\n-      void\n-      resize(size_type __sz)\n-      { _Base::resize(__sz); }\n-\n-      void\n-      resize(size_type __sz, const _Tp& __c)\n-      { _Base::resize(__sz, __c); }\n-#else\n-      void\n-      resize(size_type __sz, _Tp __c = _Tp())\n-      { _Base::resize(__sz, __c); }\n-#endif\n-\n-      // element access:\n-      reference\n-      front() _GLIBCXX_NOEXCEPT\n-      { return _Base::front(); }\n-\n-      const_reference\n-      front() const _GLIBCXX_NOEXCEPT\n-      { return _Base::front(); }\n-\n       reference\n       back() _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_list_rewind(this);\n+\t__profcxx_list_rewind(this);\n \treturn _Base::back();\n       }\n \n       const_reference\n       back() const _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_list_rewind(this);\n+\t__profcxx_list_rewind(this);\n \treturn _Base::back();\n       }\n \n       // 23.2.2.3 modifiers:\n       void\n       push_front(const value_type& __x)\n       {\n-        __profcxx_list_invalid_operator(this);\n-        __profcxx_list_operation(this);\n-        _Base::push_front(__x);\n+\t__profcxx_list_invalid_operator(this);\n+\t__profcxx_list_operation(this);\n+\t_Base::push_front(__x);\n       }\n \n-#if __cplusplus >= 201103L\n-      using _Base::emplace_front;\n-#endif\n-\n       void\n       pop_front() _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_list_operation(this);\n+\t__profcxx_list_operation(this);\n \t_Base::pop_front();\n       }\n \n-      using _Base::push_back;\n-\n-#if __cplusplus >= 201103L\n-      using _Base::emplace_back;\n-#endif\n-\n       void\n       pop_back() _GLIBCXX_NOEXCEPT\n       {\n-\titerator __victim = end();\n-\t--__victim;\n \t_Base::pop_back();\n-        __profcxx_list_rewind(this);\n+\t__profcxx_list_rewind(this);\n       }\n \n #if __cplusplus >= 201103L\n       template<typename... _Args>\n-        iterator\n-        emplace(const_iterator __position, _Args&&... __args)\n+\titerator\n+\templace(const_iterator __position, _Args&&... __args)\n \t{\n \t  return iterator(_Base::emplace(__position.base(),\n-                                         std::forward<_Args>(__args)...),\n+\t\t\t\t\t std::forward<_Args>(__args)...),\n \t\t\t  this);\n \t}\n #endif\n@@ -358,39 +289,39 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n       insert(iterator __position, const _Tp& __x)\n #endif\n       {\n-        _M_profile_insert(this, __position, size());\n-        return iterator(_Base::insert(__position.base(), __x), this);\n+\t_M_profile_insert(this, __position, this->size());\n+\treturn iterator(_Base::insert(__position.base(), __x), this);\n       }\n \n #if __cplusplus >= 201103L\n       iterator\n       insert(const_iterator __position, _Tp&& __x)\n       {\n-        _M_profile_insert(this, __position, size());\n-        return iterator(_Base::emplace(__position.base(), std::move(__x)),\n-                        this); \n+\t_M_profile_insert(this, __position, this->size());\n+\treturn iterator(_Base::emplace(__position.base(), std::move(__x)),\n+\t\t\tthis);\n       }\n \n       iterator\n       insert(const_iterator __position, initializer_list<value_type> __l)\n       {\n-        _M_profile_insert(this, __position, size());\n-        return iterator(_Base::insert(__position.base(), __l), this);\n+\t_M_profile_insert(this, __position, this->size());\n+\treturn iterator(_Base::insert(__position.base(), __l), this);\n       }\n #endif\n \n #if __cplusplus >= 201103L\n       iterator\n       insert(const_iterator __position, size_type __n, const _Tp& __x)\n       {\n-        _M_profile_insert(this, __position, size());\n+\t_M_profile_insert(this, __position, this->size());\n \treturn iterator(_Base::insert(__position.base(), __n, __x), this);\n       }\n #else\n       void\n       insert(iterator __position, size_type __n, const _Tp& __x)\n       {\n-        _M_profile_insert(this, __position, size());\n+\t_M_profile_insert(this, __position, this->size());\n \t_Base::insert(__position.base(), __n, __x);\n       }\n #endif\n@@ -399,20 +330,20 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n \titerator\n-        insert(const_iterator __position, _InputIterator __first,\n+\tinsert(const_iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n \t{\n-\t  _M_profile_insert(this, __position, size());\n+\t  _M_profile_insert(this, __position, this->size());\n \t  return iterator(_Base::insert(__position.base(), __first, __last),\n \t\t\t  this);\n \t}\n #else\n       template<class _InputIterator>\n-        void\n-        insert(iterator __position, _InputIterator __first,\n+\tvoid\n+\tinsert(iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n \t{\n-\t  _M_profile_insert(this, __position, size());\n+\t  _M_profile_insert(this, __position, this->size());\n \t  _Base::insert(__position.base(), __first, __last);\n \t}\n #endif\n@@ -439,12 +370,11 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n \n       void\n       swap(list& __x)\n+#if __cplusplus >= 201103L\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n+#endif\n       {\t_Base::swap(__x); }\n \n-      void\n-      clear() _GLIBCXX_NOEXCEPT\n-      {\t_Base::clear(); }\n-\n       // 23.2.2.4 list operations:\n       void\n #if __cplusplus >= 201103L\n@@ -488,9 +418,6 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n \t     iterator __last)\n #endif\n       {\n-\t// We used to perform the splice_alloc check:  not anymore, redundant\n-\t// after implementing the relevant bits of N1599.\n-\n \t_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),\n \t\t      __first.base(), __last.base());\n       }\n@@ -515,12 +442,12 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n       }\n \n       template<class _Predicate>\n-        void\n-        remove_if(_Predicate __pred)\n-        {\n+\tvoid\n+\tremove_if(_Predicate __pred)\n+\t{\n \t  for (iterator __x = begin(); __x != end(); )\n \t    {\n-              __profcxx_list_operation(this);\n+\t      __profcxx_list_operation(this);\n \t      if (__pred(*__x))\n \t\t__x = erase(__x);\n \t      else\n@@ -538,7 +465,7 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n \titerator __next = __first;\n \twhile (++__next != __last)\n \t  {\n-            __profcxx_list_operation(this);\n+\t    __profcxx_list_operation(this);\n \t    if (*__first == *__next)\n \t      erase(__next);\n \t    else\n@@ -548,17 +475,17 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n       }\n \n       template<class _BinaryPredicate>\n-        void\n-        unique(_BinaryPredicate __binary_pred)\n-        {\n+\tvoid\n+\tunique(_BinaryPredicate __binary_pred)\n+\t{\n \t  iterator __first = begin();\n \t  iterator __last = end();\n \t  if (__first == __last)\n \t    return;\n \t  iterator __next = __first;\n \t  while (++__next != __last)\n \t    {\n-              __profcxx_list_operation(this);\n+\t      __profcxx_list_operation(this);\n \t      if (__binary_pred(*__first, *__next))\n \t\terase(__next);\n \t      else\n@@ -573,12 +500,7 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n #else\n       merge(list& __x)\n #endif\n-      {\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 300. list::merge() specification incomplete\n-\tif (this != &__x)\n-\t  { _Base::merge(_GLIBCXX_MOVE(__x._M_base())); }\n-      }\n+      { _Base::merge(_GLIBCXX_MOVE(__x._M_base())); }\n \n #if __cplusplus >= 201103L\n       void\n@@ -587,63 +509,49 @@ template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n #endif\n \n       template<class _Compare>\n-        void\n+\tvoid\n #if __cplusplus >= 201103L\n-        merge(list&& __x, _Compare __comp)\n+\tmerge(list&& __x, _Compare __comp)\n #else\n-        merge(list& __x, _Compare __comp)\n+\tmerge(list& __x, _Compare __comp)\n #endif\n-        {\n-\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t  // 300. list::merge() specification incomplete\n-\t  if (this != &__x)\n-\t    { _Base::merge(_GLIBCXX_MOVE(__x._M_base()), __comp); }\n-\t}\n+\t{ _Base::merge(_GLIBCXX_MOVE(__x._M_base()), __comp); }\n \n #if __cplusplus >= 201103L\n       template<typename _Compare>\n-        void\n-        merge(list& __x, _Compare __comp)\n-        { this->merge(std::move(__x), __comp); }\n+\tvoid\n+\tmerge(list& __x, _Compare __comp)\n+\t{ this->merge(std::move(__x), __comp); }\n #endif\n \n-      void\n-      sort() { _Base::sort(); }\n-\n-      template<typename _StrictWeakOrdering>\n-        void\n-        sort(_StrictWeakOrdering __pred) { _Base::sort(__pred); }\n-\n-      using _Base::reverse;\n-\n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       void _M_profile_find() const\n       { }\n \n-      void _M_profile_iterate(int __rewind = 0) const \n+      void _M_profile_iterate(int __rewind = 0) const\n       {\n-        __profcxx_list_operation(this);\n-        __profcxx_list_iterate(this); \n-        if (__rewind)\n-          __profcxx_list_rewind(this);\n+\t__profcxx_list_operation(this);\n+\t__profcxx_list_iterate(this);\n+\tif (__rewind)\n+\t  __profcxx_list_rewind(this);\n       }\n \n     private:\n       size_type\n       _M_profile_insert(void* obj, const_iterator __pos, size_type __size)\n       {\n-        size_type __shift = 0;\n-        typename _Base::const_iterator __it = __pos.base();\n-        for (; __it != _Base::end(); ++__it)\n-          __shift++;\n-        __profcxx_list_rewind(this);\n-        __profcxx_list_operation(this);\n-        __profcxx_list_insert(this, __shift, __size);\n+\tsize_type __shift = 0;\n+\ttypename _Base::const_iterator __it = __pos.base();\n+\tfor (; __it != _Base::end(); ++__it)\n+\t  __shift++;\n+\t__profcxx_list_rewind(this);\n+\t__profcxx_list_operation(this);\n+\t__profcxx_list_insert(this, __shift, __size);\n       }\n     };\n "}, {"sha": "88a560775bae09746d06257ea3113faab2759ea0", "filename": "libstdc++-v3/include/profile/map.h", "status": "modified", "additions": 180, "deletions": 232, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -28,8 +28,8 @@\n #ifndef _GLIBCXX_PROFILE_MAP_H\n #define _GLIBCXX_PROFILE_MAP_H 1\n \n-#include <utility>\n #include <profile/base.h>\n+#include <profile/ordered_base.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -39,106 +39,88 @@ namespace __profile\n   template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n     class map\n-    : public _GLIBCXX_STD_C::map<_Key, _Tp, _Compare, _Allocator>\n+    : public _GLIBCXX_STD_C::map<_Key, _Tp, _Compare, _Allocator>,\n+      public _Ordered_profile<map<_Key, _Tp, _Compare, _Allocator> >\n     {\n       typedef _GLIBCXX_STD_C::map<_Key, _Tp, _Compare, _Allocator> _Base;\n \n-#if __cplusplus >= 201103L\n-      typedef __gnu_cxx::__alloc_traits<_Allocator> _Alloc_traits;\n-#endif\n-\n     public:\n       // types:\n-      typedef _Key                                  key_type;\n-      typedef _Tp                                   mapped_type;\n-      typedef std::pair<const _Key, _Tp>            value_type;\n-      typedef _Compare                              key_compare;\n-      typedef _Allocator                            allocator_type;\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n-\n-      typedef typename _Base::iterator       iterator;\n-      typedef typename _Base::const_iterator       const_iterator;\n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n-      typedef std::reverse_iterator<iterator>       reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Tp\t\t\t\t\tmapped_type;\n+      typedef typename _Base::value_type\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n+\n+      typedef typename _Base::iterator\t\t\titerator;\n+      typedef typename _Base::const_iterator\t\tconst_iterator;\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+      typedef typename _Base::reverse_iterator\t\treverse_iterator;\n+      typedef typename _Base::const_reverse_iterator\tconst_reverse_iterator;\n \n       // 23.3.1.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       map()\n-      : _Base()\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+      : _Base() { }\n+      map(const map& __x)\n+\t: _Base(__x) { }\n+      ~map()\n+      { }\n+#else\n+      map() = default;\n+      map(const map&) = default;\n+      map(map&&) = default;\n+      ~map() = default;\n+#endif\n \n       explicit\n       map(const _Compare& __comp,\n \t  const _Allocator& __a = _Allocator())\n-      : _Base(__comp, __a)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+      : _Base(__comp, __a) { }\n \n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n #else\n       template<typename _InputIterator>\n #endif\n-        map(_InputIterator __first, _InputIterator __last,\n+\tmap(_InputIterator __first, _InputIterator __last,\n \t    const _Compare& __comp = _Compare(),\n \t    const _Allocator& __a = _Allocator())\n-\t: _Base(__first, __last, __comp, __a)\n-        { __profcxx_map_to_unordered_map_construct(this); }\n-\n-      map(const map& __x)\n-      : _Base(__x)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+\t: _Base(__first, __last, __comp, __a) { }\n \n       map(const _Base& __x)\n-      : _Base(__x)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+      : _Base(__x) { }\n \n #if __cplusplus >= 201103L\n-      map(map&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _Base(std::move(__x))\n-      { __profcxx_map_to_unordered_map_construct(this); }\n-\n       map(initializer_list<value_type> __l,\n \t  const _Compare& __c = _Compare(),\n-\t  const allocator_type& __a = allocator_type())\n-      : _Base(__l, __c, __a)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+\t  const _Allocator& __a = _Allocator())\n+      : _Base(__l, __c, __a) { }\n \n       explicit\n-      map(const allocator_type& __a)\n-\t: _Base(__a)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+      map(const _Allocator& __a)\n+      : _Base(__a) { }\n \n-      map(const map& __x, const allocator_type& __a)\n-      : _Base(__x, __a)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+      map(const map& __x, const _Allocator& __a)\n+      : _Base(__x, __a) { }\n \n-      map(map&& __x, const allocator_type& __a)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value\n-\t       && _Alloc_traits::_S_always_equal())\n-      : _Base(std::move(__x), __a)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+      map(map&& __x, const _Allocator& __a)\n+      noexcept( noexcept(_Base(std::move(__x), __a)) )\n+      : _Base(std::move(__x), __a) { }\n \n-      map(initializer_list<value_type> __l, const allocator_type& __a)\n-      : _Base(__l, __a)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+      map(initializer_list<value_type> __l, const _Allocator& __a)\n+      : _Base(__l, __a) { }\n \n       template<typename _InputIterator>\n-        map(_InputIterator __first, _InputIterator __last,\n-\t    const allocator_type& __a)\n-\t  : _Base(__first, __last, __a)\n-      { __profcxx_map_to_unordered_map_construct(this); }\n+\tmap(_InputIterator __first, _InputIterator __last,\n+\t    const _Allocator& __a)\n+\t: _Base(__first, __last, __a) { }\n #endif\n \n-      ~map() _GLIBCXX_NOEXCEPT\n-      { __profcxx_map_to_unordered_map_destruct(this); }\n-\n #if __cplusplus < 201103L\n       map&\n       operator=(const map& __x)\n@@ -161,113 +143,79 @@ namespace __profile\n       }\n #endif\n \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 133. map missing get_allocator()\n-      using _Base::get_allocator;\n-\n-      // iterators:\n-      iterator \n-      begin() _GLIBCXX_NOEXCEPT\n-      { return _Base::begin(); }\n-\n-      const_iterator\n-      begin() const _GLIBCXX_NOEXCEPT\n-      { return _Base::begin(); }\n-\n-      iterator\n-      end() _GLIBCXX_NOEXCEPT\n-      { return _Base::end(); }\n-\n-      const_iterator\n-      end() const _GLIBCXX_NOEXCEPT\n-      { return _Base::end(); }\n-\n       reverse_iterator\n       rbegin() _GLIBCXX_NOEXCEPT\n-      { \n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return reverse_iterator(end()); \n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rbegin();\n       }\n \n       const_reverse_iterator\n       rbegin() const _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return const_reverse_iterator(end());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rbegin();\n       }\n \n       reverse_iterator\n       rend() _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return reverse_iterator(begin());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rend();\n       }\n \n       const_reverse_iterator\n       rend() const _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return const_reverse_iterator(begin());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rend();\n       }\n \n #if __cplusplus >= 201103L\n-      const_iterator\n-      cbegin() const noexcept\n-      { return const_iterator(_Base::begin()); }\n-\n-      const_iterator\n-      cend() const noexcept\n-      { return const_iterator(_Base::end()); }\n-\n       const_reverse_iterator\n       crbegin() const noexcept\n       {\n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return const_reverse_iterator(end());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::crbegin();\n       }\n \n       const_reverse_iterator\n       crend() const noexcept\n       {\n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return const_reverse_iterator(begin());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::crend();\n       }\n #endif\n \n-      // capacity:\n-      using _Base::empty;\n-      using _Base::size;\n-      using _Base::max_size;\n-\n       // 23.3.1.2 element access:\n       mapped_type&\n       operator[](const key_type& __k)\n       {\n-        __profcxx_map_to_unordered_map_find(this, size());\n-        return _Base::operator[](__k);\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::operator[](__k);\n       }\n \n #if __cplusplus >= 201103L\n       mapped_type&\n       operator[](key_type&& __k)\n       {\n-        __profcxx_map_to_unordered_map_find(this, size());\n-        return _Base::operator[](std::move(__k));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::operator[](std::move(__k));\n       }\n #endif\n \n       mapped_type&\n       at(const key_type& __k)\n       {\n-        __profcxx_map_to_unordered_map_find(this, size());\n-        return _Base::at(__k);\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::at(__k);\n       }\n \n       const mapped_type&\n       at(const key_type& __k) const\n       {\n-        __profcxx_map_to_unordered_map_find(this, size());\n-        return _Base::at(__k);\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::at(__k);\n       }\n \n       // modifiers:\n@@ -276,89 +224,77 @@ namespace __profile\n \tstd::pair<iterator, bool>\n \templace(_Args&&... __args)\n \t{\n-\t  __profcxx_map_to_unordered_map_insert(this, size(), 1);\n-\t  auto __res = _Base::emplace(std::forward<_Args>(__args)...);\n-\t  return std::pair<iterator, bool>(iterator(__res.first),\n-\t\t\t\t\t   __res.second);\n+\t  // The cost is the same whether or not the element is inserted so we\n+\t  // always report insertion of 1 element.\n+\t  __profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\t  return _Base::emplace(std::forward<_Args>(__args)...);\n \t}\n \n       template<typename... _Args>\n \titerator\n \templace_hint(const_iterator __pos, _Args&&... __args)\n \t{\n-\t  size_type size_before = size();\n-\t  auto __res = _Base::emplace_hint(__pos,\n-\t\t\t\t\t   std::forward<_Args>(__args)...);\n+\t  auto size_before = this->size();\n+\t  auto __res = _Base::emplace_hint(__pos, std::forward<_Args>(__args)...);\n \t  __profcxx_map_to_unordered_map_insert(this, size_before,\n-\t\t\t\t\t\tsize() - size_before);\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n \t  return __res;\n \t}\n #endif\n \n       std::pair<iterator, bool>\n       insert(const value_type& __x)\n       {\n-        __profcxx_map_to_unordered_map_insert(this, size(), 1);\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, bool> __res = _Base::insert(__x);\n-\treturn std::pair<iterator, bool>(iterator(__res.first),\n-\t\t\t\t\t __res.second);\n+\t__profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\treturn _Base::insert(__x);\n       }\n \n #if __cplusplus >= 201103L\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        std::pair<iterator, bool>\n-        insert(_Pair&& __x)\n-        {\n-\t  __profcxx_map_to_unordered_map_insert(this, size(), 1);\n-\t  typedef typename _Base::iterator _Base_iterator;\n-\t  std::pair<_Base_iterator, bool> __res\n-\t    = _Base::insert(std::forward<_Pair>(__x));\n-\t  return std::pair<iterator, bool>(iterator(__res.first),\n-\t\t\t\t\t   __res.second);\n+\tstd::pair<iterator, bool>\n+\tinsert(_Pair&& __x)\n+\t{\n+\t  __profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\t  return _Base::insert(std::forward<_Pair>(__x));\n \t}\n #endif\n \n #if __cplusplus >= 201103L\n       void\n       insert(std::initializer_list<value_type> __list)\n-      { \n-        size_type size_before = size();\n-        _Base::insert(__list); \n-        __profcxx_map_to_unordered_map_insert(this, size_before, \n-\t\t\t\t\t      size() - size_before);\n-      }\n+      { insert(__list.begin(), __list.end()); }\n #endif\n \n       iterator\n #if __cplusplus >= 201103L\n-      insert(const_iterator __position, const value_type& __x)\n+      insert(const_iterator __pos, const value_type& __x)\n #else\n-      insert(iterator __position, const value_type& __x)\n+      insert(iterator __pos, const value_type& __x)\n #endif\n       {\n-        size_type size_before = size();\n-\titerator __i = iterator(_Base::insert(__position, __x));\n-        __profcxx_map_to_unordered_map_insert(this, size_before,\n-\t\t\t\t\t      size() - size_before);\n-\treturn __i;\n+\tsize_type size_before = this->size();\n+\titerator __res = _Base::insert(__pos, __x);\n+\t\n+\t__profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\treturn __res;\n       }\n \n #if __cplusplus >= 201103L\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(const_iterator __position, _Pair&& __x)\n-        {\n-\t  size_type size_before = size();\n-\t  iterator __i\n-\t    = iterator(_Base::insert(__position, std::forward<_Pair>(__x)));\n-\t  __profcxx_map_to_unordered_map_insert(this, size_before, \n-\t\t\t\t\t\tsize() - size_before);\n-\t  return __i;\n+\titerator\n+\tinsert(const_iterator __pos, _Pair&& __x)\n+\t{\n+\t  size_type size_before = this->size();\n+\t  auto __res = _Base::insert(__pos, std::forward<_Pair>(__x));\n+\t\n+\t  __profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\t  return __res;\n       }\n #endif\n \n@@ -368,173 +304,185 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        {\n-          size_type size_before = size();\n-\t  _Base::insert(__first, __last);\n-          __profcxx_map_to_unordered_map_insert(this, size_before, \n-                                                size() - size_before);\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n+\t  for (; __first != __last; ++__first)\n+\t    insert(*__first);\n \t}\n \n #if __cplusplus >= 201103L\n       iterator\n       erase(const_iterator __position)\n       {\n-\titerator __i = _Base::erase(__position);\n-        __profcxx_map_to_unordered_map_erase(this, size(), 1);\n-        return __i;\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__position);\n       }\n \n       iterator\n       erase(iterator __position)\n-      { return erase(const_iterator(__position)); }\n+      {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__position);\n+      }\n #else\n       void\n       erase(iterator __position)\n       {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n \t_Base::erase(__position);\n-        __profcxx_map_to_unordered_map_erase(this, size(), 1);\n       }\n #endif\n \n       size_type\n       erase(const key_type& __x)\n       {\n-\titerator __victim = find(__x);\n-\tif (__victim == end())\n-\t  return 0;\n-\telse\n-\t{\n-\t  _Base::erase(__victim);\n-\t  return 1;\n-\t}\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__x);\n       }\n \n #if __cplusplus >= 201103L\n       iterator\n       erase(const_iterator __first, const_iterator __last)\n-      { return iterator(_Base::erase(__first, __last)); }\n+      {\n+\tif (__first != __last)\n+\t  {\n+\t    iterator __ret;\n+\t    for (; __first != __last;)\n+\t      __ret = erase(__first++);\n+\t    return __ret;\n+\t  }\n+\telse\n+\t  return _Base::erase(__first, __last);\n+      }\n #else\n       void\n       erase(iterator __first, iterator __last)\n-      { _Base::erase(__first, __last); }\n+      {\n+\tfor (; __first != __last;)\n+\t  erase(__first++);\n+      }\n #endif\n \n       void\n       swap(map& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       { _Base::swap(__x); }\n \n-      void\n-      clear() _GLIBCXX_NOEXCEPT\n-      { this->erase(begin(), end()); }\n-\n-      // observers:\n-      using _Base::key_comp;\n-      using _Base::value_comp;\n-\n       // 23.3.1.3 map operations:\n       iterator\n       find(const key_type& __x)\n       {\n-        __profcxx_map_to_unordered_map_find(this, size());\n-        return iterator(_Base::find(__x));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::find(__x);\n       }\n \n       const_iterator\n       find(const key_type& __x) const\n       {\n-        __profcxx_map_to_unordered_map_find(this, size());\n-        return const_iterator(_Base::find(__x));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::find(__x);\n       }\n \n       size_type\n       count(const key_type& __x) const\n       {\n-        __profcxx_map_to_unordered_map_find(this, size());\n-        return _Base::count(__x);\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::count(__x);\n       }\n \n       iterator\n       lower_bound(const key_type& __x)\n-      { \n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return iterator(_Base::lower_bound(__x)); \n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::lower_bound(__x);\n       }\n \n       const_iterator\n       lower_bound(const key_type& __x) const\n-      { \n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return const_iterator(_Base::lower_bound(__x)); \n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::lower_bound(__x);\n       }\n \n       iterator\n       upper_bound(const key_type& __x)\n-      { \n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return iterator(_Base::upper_bound(__x)); \n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::upper_bound(__x);\n       }\n \n       const_iterator\n       upper_bound(const key_type& __x) const\n-      { \n-        __profcxx_map_to_unordered_map_invalidate(this);\n-        return const_iterator(_Base::upper_bound(__x)); \n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::upper_bound(__x);\n       }\n \n       std::pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-\t_Base::equal_range(__x);\n-\treturn std::make_pair(iterator(__res.first),\n-\t\t\t      iterator(__res.second));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::equal_range(__x);\n       }\n \n       std::pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       {\n-        __profcxx_map_to_unordered_map_find(this, size());\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n-\t_Base::equal_range(__x);\n-\treturn std::make_pair(const_iterator(__res.first),\n-\t\t\t      const_iterator(__res.second));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::equal_range(__x);\n       }\n \n-      _Base& \n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _Base&\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n-\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n+\n+    private:\n+      /** If hint is used we consider that the map and unordered_map\n+       * operations have equivalent insertion cost so we do not update metrics\n+       * about it.\n+       * Note that to find out if hint has been used is libstdc++\n+       * implementation dependant.\n+       */\n+      bool\n+      _M_hint_used(const_iterator __hint, iterator __res)\n+      {\n+\treturn (__hint == __res ||\n+\t\t(__hint == this->end() && ++__res == this->end()) ||\n+\t\t(__hint != this->end() && (++__hint == __res ||\n+\t\t\t\t\t   ++__res == --__hint)));\n+      }\n     };\n \n   template<typename _Key, typename _Tp,\n \t   typename _Compare, typename _Allocator>\n     inline bool\n     operator==(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n \t       const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n-    { \n+    {\n       __profcxx_map_to_unordered_map_invalidate(&__lhs);\n       __profcxx_map_to_unordered_map_invalidate(&__rhs);\n-      return __lhs._M_base() == __rhs._M_base(); \n+      return __lhs._M_base() == __rhs._M_base();\n     }\n \n   template<typename _Key, typename _Tp,\n \t   typename _Compare, typename _Allocator>\n     inline bool\n     operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __lhs,\n \t       const map<_Key, _Tp, _Compare, _Allocator>& __rhs)\n-    { \n+    {\n       __profcxx_map_to_unordered_map_invalidate(&__lhs);\n       __profcxx_map_to_unordered_map_invalidate(&__rhs);\n-      return __lhs._M_base() != __rhs._M_base(); \n+      return __lhs._M_base() != __rhs._M_base();\n     }\n \n   template<typename _Key, typename _Tp,\n@@ -545,7 +493,7 @@ namespace __profile\n     {\n       __profcxx_map_to_unordered_map_invalidate(&__lhs);\n       __profcxx_map_to_unordered_map_invalidate(&__rhs);\n-      return __lhs._M_base() < __rhs._M_base(); \n+      return __lhs._M_base() < __rhs._M_base();\n     }\n \n   template<typename _Key, typename _Tp,"}, {"sha": "0605d61d806419c94a11890f3451b6262c309836", "filename": "libstdc++-v3/include/profile/multimap.h", "status": "modified", "additions": 203, "deletions": 149, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -29,7 +29,8 @@\n #ifndef _GLIBCXX_PROFILE_MULTIMAP_H\n #define _GLIBCXX_PROFILE_MULTIMAP_H 1\n \n-#include <utility>\n+#include <profile/base.h>\n+#include <profile/ordered_base.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -39,38 +40,44 @@ namespace __profile\n   template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n     class multimap\n-    : public _GLIBCXX_STD_C::multimap<_Key, _Tp, _Compare, _Allocator>\n+    : public _GLIBCXX_STD_C::multimap<_Key, _Tp, _Compare, _Allocator>,\n+      public _Ordered_profile<map<_Key, _Tp, _Compare, _Allocator> >\n     {\n       typedef _GLIBCXX_STD_C::multimap<_Key, _Tp, _Compare, _Allocator> _Base;\n \n-#if __cplusplus >= 201103L\n-      typedef __gnu_cxx::__alloc_traits<_Allocator> _Alloc_traits;\n-#endif\n-\n     public:\n       // types:\n-      typedef _Key\t\t\t\t     key_type;\n-      typedef _Tp\t\t\t\t     mapped_type;\n-      typedef std::pair<const _Key, _Tp>             value_type;\n-      typedef _Compare                               key_compare;\n-      typedef _Allocator                             allocator_type;\n-      typedef typename _Base::reference              reference;\n-      typedef typename _Base::const_reference        const_reference;\n-\n-      typedef typename _Base::iterator               iterator;\n-      typedef typename _Base::const_iterator         const_iterator;\n-      typedef typename _Base::reverse_iterator       reverse_iterator;\n-      typedef typename _Base::const_reverse_iterator const_reverse_iterator;\n-\n-      typedef typename _Base::size_type              size_type;\n-      typedef typename _Base::difference_type        difference_type;\n-      typedef typename _Base::pointer                pointer;\n-      typedef typename _Base::const_pointer          const_pointer;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Tp\t\t\t\t\tmapped_type;\n+      typedef std::pair<const _Key, _Tp>\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n+\n+      typedef typename _Base::iterator\t\t\titerator;\n+      typedef typename _Base::const_iterator\t\tconst_iterator;\n+      typedef typename _Base::reverse_iterator\t\treverse_iterator;\n+      typedef typename _Base::const_reverse_iterator\tconst_reverse_iterator;\n+\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n \n       // 23.3.1.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       multimap()\n       : _Base() { }\n+      multimap(const multimap& __x)\n+      : _Base(__x) { }\n+      ~multimap() { }\n+#else\n+      multimap() = default;\n+      multimap(const multimap&) = default;\n+      multimap(multimap&&) = default;\n+      ~multimap() = default;\n+#endif\n \n       explicit multimap(const _Compare& __comp,\n \t\t\tconst _Allocator& __a = _Allocator())\n@@ -82,49 +89,40 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-      multimap(_InputIterator __first, _InputIterator __last,\n-\t       const _Compare& __comp = _Compare(),\n-\t       const _Allocator& __a = _Allocator())\n-      : _Base(__first, __last, __comp, __a) { }\n-\n-#if __cplusplus < 201103L\n-      multimap(const multimap& __x)\n-      : _Base(__x) { }\n-#else\n-      multimap(const multimap&) = default;\n-      multimap(multimap&&) = default;\n+\tmultimap(_InputIterator __first, _InputIterator __last,\n+\t\t const _Compare& __comp = _Compare(),\n+\t\t const _Allocator& __a = _Allocator())\n+\t: _Base(__first, __last, __comp, __a) { }\n \n+#if __cplusplus >= 201103L\n       multimap(initializer_list<value_type> __l,\n \t       const _Compare& __c = _Compare(),\n-\t       const allocator_type& __a = allocator_type())\n+\t       const _Allocator& __a = _Allocator())\n       : _Base(__l, __c, __a) { }\n \n       explicit\n-      multimap(const allocator_type& __a)\n-\t: _Base(__a) { }\n+      multimap(const _Allocator& __a)\n+      : _Base(__a) { }\n \n-      multimap(const multimap& __x, const allocator_type& __a)\n+      multimap(const multimap& __x, const _Allocator& __a)\n       : _Base(__x, __a) { }\n \n-      multimap(multimap&& __x, const allocator_type& __a)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value\n-\t       && _Alloc_traits::_S_always_equal())\n+      multimap(multimap&& __x, const _Allocator& __a)\n+      noexcept( noexcept(_Base(std::move(__x), __a)) )\n       : _Base(std::move(__x), __a) { }\n \n-      multimap(initializer_list<value_type> __l, const allocator_type& __a)\n+      multimap(initializer_list<value_type> __l, const _Allocator& __a)\n       : _Base(__l, __a) { }\n \n       template<typename _InputIterator>\n-        multimap(_InputIterator __first, _InputIterator __last,\n-\t    const allocator_type& __a)\n-\t  : _Base(__first, __last, __a) { }\n+\tmultimap(_InputIterator __first, _InputIterator __last,\n+\t\t const _Allocator& __a)\n+\t: _Base(__first, __last, __a) { }\n #endif\n \n       multimap(const _Base& __x)\n       : _Base(__x) { }\n \n-      ~multimap() _GLIBCXX_NOEXCEPT { }\n-\n #if __cplusplus < 201103L\n       multimap&\n       operator=(const multimap& __x)\n@@ -147,117 +145,125 @@ namespace __profile\n       }\n #endif\n \n-      using _Base::get_allocator;\n-\n-      // iterators:\n-      iterator\n-      begin() _GLIBCXX_NOEXCEPT\n-      { return iterator(_Base::begin()); }\n-\n-      const_iterator\n-      begin() const _GLIBCXX_NOEXCEPT\n-      { return const_iterator(_Base::begin()); }\n-\n-      iterator\n-      end() _GLIBCXX_NOEXCEPT\n-      { return iterator(_Base::end()); }\n-\n-      const_iterator\n-      end() const _GLIBCXX_NOEXCEPT\n-      { return const_iterator(_Base::end()); }\n-\n       reverse_iterator\n       rbegin() _GLIBCXX_NOEXCEPT\n-      { return reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rbegin();\n+      }\n \n       const_reverse_iterator\n       rbegin() const _GLIBCXX_NOEXCEPT\n-      { return const_reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rbegin();\n+      }\n \n       reverse_iterator\n       rend() _GLIBCXX_NOEXCEPT\n-      { return reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rend();\n+      }\n \n       const_reverse_iterator\n       rend() const _GLIBCXX_NOEXCEPT\n-      { return const_reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rend();\n+      }\n \n #if __cplusplus >= 201103L\n-      const_iterator\n-      cbegin() const noexcept\n-      { return const_iterator(_Base::begin()); }\n-\n-      const_iterator\n-      cend() const noexcept\n-      { return const_iterator(_Base::end()); }\n-\n       const_reverse_iterator\n       crbegin() const noexcept\n-      { return const_reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::crbegin();\n+      }\n \n       const_reverse_iterator\n       crend() const noexcept\n-      { return const_reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::crend();\n+      }\n #endif\n \n-      // capacity:\n-      using _Base::empty;\n-      using _Base::size;\n-      using _Base::max_size;\n-\n       // modifiers:\n #if __cplusplus >= 201103L\n       template<typename... _Args>\n \titerator\n \templace(_Args&&... __args)\n \t{\n-\t  return iterator(_Base::emplace(std::forward<_Args>(__args)...));\n+\t  __profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\t  return _Base::emplace(std::forward<_Args>(__args)...);\n \t}\n \n       template<typename... _Args>\n \titerator\n \templace_hint(const_iterator __pos, _Args&&... __args)\n \t{\n-\t  return iterator(_Base::emplace_hint(__pos,\n-\t\t\t\t\t      std::forward<_Args>(__args)...));\n+\t  auto size_before = this->size();\n+\t  auto __res\n+\t    = _Base::emplace_hint(__pos, std::forward<_Args>(__args)...);\n+\t  __profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\t  return __res;\n \t}\n #endif\n-      \n+\n       iterator\n       insert(const value_type& __x)\n-      { return iterator(_Base::insert(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\treturn _Base::insert(__x);\n+      }\n \n #if __cplusplus >= 201103L\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(_Pair&& __x)\n-        { return iterator(_Base::insert(std::forward<_Pair>(__x))); }\n+\titerator\n+\tinsert(_Pair&& __x)\n+\t{\n+\t  __profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\t  return _Base::insert(std::forward<_Pair>(__x));\n+\t}\n #endif\n \n #if __cplusplus >= 201103L\n       void\n       insert(std::initializer_list<value_type> __list)\n-      { _Base::insert(__list); }\n+      { insert(__list.begin(), __list.end()); }\n #endif\n \n       iterator\n #if __cplusplus >= 201103L\n-      insert(const_iterator __position, const value_type& __x)\n+      insert(const_iterator __pos, const value_type& __x)\n #else\n-      insert(iterator __position, const value_type& __x)\n+      insert(iterator __pos, const value_type& __x)\n #endif\n-      { return iterator(_Base::insert(__position, __x)); }\n+      {\n+\tsize_type size_before = this->size();\n+\titerator __res = _Base::insert(__pos, __x);\n+\t__profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\treturn __res;\n+      }\n \n #if __cplusplus >= 201103L\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(const_iterator __position, _Pair&& __x)\n-        { return iterator(_Base::insert(__position,\n-\t\t\t\t\tstd::forward<_Pair>(__x))); }\n+\titerator\n+\tinsert(const_iterator __pos, _Pair&& __x)\n+\t{\n+\t  size_type size_before = this->size();\n+\t  auto __res = _Base::insert(__pos, std::forward<_Pair>(__x));\n+\t  __profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\t  return __res;\n+\t}\n #endif\n \n #if __cplusplus >= 201103L\n@@ -266,115 +272,163 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        { _Base::insert(__first, __last); }\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n+\t  for (; __first != __last; ++__first)\n+\t    insert(*__first);\n+\t}\n \n #if __cplusplus >= 201103L\n       iterator\n-      erase(const_iterator __position)\n-      { return iterator(_Base::erase(__position)); }\n+      erase(const_iterator __pos)\n+      {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__pos);\n+      }\n \n       iterator\n-      erase(iterator __position)\n-      { return iterator(_Base::erase(__position)); }\n+      erase(iterator __pos)\n+      {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__pos);\n+      }\n #else\n       void\n-      erase(iterator __position)\n-      { _Base::erase(__position); }\n+      erase(iterator __pos)\n+      {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\t_Base::erase(__pos);\n+      }\n #endif\n \n       size_type\n       erase(const key_type& __x)\n       {\n-\tstd::pair<iterator, iterator> __victims = this->equal_range(__x);\n-\tsize_type __count = 0;\n-\twhile (__victims.first != __victims.second)\n-\t{\n-\t  iterator __victim = __victims.first++;\n-\t  _Base::erase(__victim);\n-\t  ++__count;\n-\t}\n-\treturn __count;\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__x);\n       }\n \n #if __cplusplus >= 201103L\n       iterator\n       erase(const_iterator __first, const_iterator __last)\n-      { return iterator(_Base::erase(__first, __last)); }\n+      {\n+\tif (__first != __last)\n+\t  {\n+\t    iterator __ret;\n+\t    for (; __first != __last;)\n+\t      __ret = erase(__first++);\n+\t    return __ret;\n+\t  }\n+\telse\n+\t  return _Base::erase(__first, __last);\n+      }\n #else\n       void\n       erase(iterator __first, iterator __last)\n-      { _Base::erase(__first, __last); }\n+      {\n+\tfor (; __first != __last;)\n+\t  erase(__first++);\n+      }\n #endif\n \n       void\n       swap(multimap& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       { _Base::swap(__x); }\n \n-      void\n-      clear() _GLIBCXX_NOEXCEPT\n-      { this->erase(begin(), end()); }\n-\n-      // observers:\n-      using _Base::key_comp;\n-      using _Base::value_comp;\n-\n       // 23.3.1.3 multimap operations:\n       iterator\n       find(const key_type& __x)\n-      { return iterator(_Base::find(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::find(__x);\n+      }\n \n       const_iterator\n       find(const key_type& __x) const\n-      { return const_iterator(_Base::find(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::find(__x);\n+      }\n \n-      using _Base::count;\n+      size_type\n+      count(const key_type& __x) const\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::count(__x);\n+      }\n \n       iterator\n       lower_bound(const key_type& __x)\n-      { return iterator(_Base::lower_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::lower_bound(__x);\n+      }\n \n       const_iterator\n       lower_bound(const key_type& __x) const\n-      { return const_iterator(_Base::lower_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::lower_bound(__x);\n+      }\n \n       iterator\n       upper_bound(const key_type& __x)\n-      { return iterator(_Base::upper_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::upper_bound(__x);\n+      }\n \n       const_iterator\n       upper_bound(const key_type& __x) const\n-      { return const_iterator(_Base::upper_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::upper_bound(__x);\n+      }\n \n       std::pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-\t_Base::equal_range(__x);\n-\treturn std::make_pair(iterator(__res.first),\n-\t\t\t      iterator(__res.second));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::equal_range(__x);\n       }\n \n       std::pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n-\t_Base::equal_range(__x);\n-\treturn std::make_pair(const_iterator(__res.first),\n-\t\t\t      const_iterator(__res.second));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::equal_range(__x);\n       }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n+\n+    private:\n+      /** If hint is used we consider that the map and unordered_map\n+       * operations have equivalent insertion cost so we do not update metrics\n+       * about it.\n+       * Note that to find out if hint has been used is libstdc++\n+       * implementation dependant.\n+       */\n+      bool\n+      _M_hint_used(const_iterator __hint, iterator __res)\n+      {\n+\treturn (__hint == __res ||\n+\t\t(__hint == this->end() && ++__res == this->end()) ||\n+\t\t(__hint != this->end() && (++__hint == __res ||\n+\t\t\t\t\t   ++__res == --__hint)));\n+      }\n     };\n \n   template<typename _Key, typename _Tp,"}, {"sha": "63b9e80a5eec093594080fd1157cee301137b7a7", "filename": "libstdc++-v3/include/profile/multiset.h", "status": "modified", "additions": 189, "deletions": 133, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -29,7 +29,8 @@\n #ifndef _GLIBCXX_PROFILE_MULTISET_H\n #define _GLIBCXX_PROFILE_MULTISET_H 1\n \n-#include <utility>\n+#include <profile/base.h>\n+#include <profile/ordered_base.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -39,38 +40,45 @@ namespace __profile\n   template<typename _Key, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<_Key> >\n     class multiset\n-    : public _GLIBCXX_STD_C::multiset<_Key, _Compare, _Allocator>\n+    : public _GLIBCXX_STD_C::multiset<_Key, _Compare, _Allocator>,\n+      public _Ordered_profile<multiset<_Key, _Compare, _Allocator> >\n     {\n       typedef _GLIBCXX_STD_C::multiset<_Key, _Compare, _Allocator> _Base;\n \n-#if __cplusplus >= 201103L\n-      typedef __gnu_cxx::__alloc_traits<_Allocator> _Alloc_traits;\n-#endif\n-\n     public:\n       // types:\n-      typedef _Key\t\t\t\t     key_type;\n-      typedef _Key\t\t\t\t     value_type;\n-      typedef _Compare\t\t\t\t     key_compare;\n-      typedef _Compare\t\t\t\t     value_compare;\n-      typedef _Allocator\t\t\t     allocator_type;\n-      typedef typename _Base::reference\t             reference;\n-      typedef typename _Base::const_reference        const_reference;\n-\n-      typedef typename _Base::iterator               iterator;\n-      typedef typename _Base::const_iterator         const_iterator;\n-      typedef typename _Base::reverse_iterator       reverse_iterator;\n-      typedef typename _Base::const_reverse_iterator const_reverse_iterator;\n-\n-      typedef typename _Base::size_type              size_type;\n-      typedef typename _Base::difference_type        difference_type;\n-      typedef typename _Base::pointer                pointer;\n-      typedef typename _Base::const_pointer          const_pointer;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Key\t\t\t\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef _Compare\t\t\t\t\tvalue_compare;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n+\n+      typedef typename _Base::iterator\t\t\titerator;\n+      typedef typename _Base::const_iterator\t\tconst_iterator;\n+      typedef typename _Base::reverse_iterator\t\treverse_iterator;\n+      typedef typename _Base::const_reverse_iterator\tconst_reverse_iterator;\n+\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n \n       // 23.3.3.1 construct/copy/destroy:\n \n+#if __cplusplus < 201103L\n       multiset()\n       : _Base() { }\n+      multiset(const multiset& __x)\n+      : _Base(__x) { }\n+      ~multiset() { }\n+#else\n+      multiset() = default;\n+      multiset(const multiset&) = default;\n+      multiset(multiset&&) = default;\n+      ~multiset() = default;\n+#endif\n \n       explicit multiset(const _Compare& __comp,\n \t\t\tconst _Allocator& __a = _Allocator())\n@@ -82,49 +90,40 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-        multiset(_InputIterator __first, _InputIterator __last,\n+\tmultiset(_InputIterator __first, _InputIterator __last,\n \t\t const _Compare& __comp = _Compare(),\n \t\t const _Allocator& __a = _Allocator())\n \t: _Base(__first, __last, __comp, __a) { }\n \n-#if __cplusplus < 201103L\n-      multiset(const multiset& __x)\n-      : _Base(__x) { }\n-#else\n-      multiset(const multiset&) = default;\n-      multiset(multiset&&) = default;\n-\n+#if __cplusplus >= 201103L\n       multiset(initializer_list<value_type> __l,\n \t       const _Compare& __comp = _Compare(),\n \t       const allocator_type& __a = allocator_type())\n       : _Base(__l, __comp, __a) { }\n \n       explicit\n       multiset(const allocator_type& __a)\n-\t: _Base(__a) { }\n+      : _Base(__a) { }\n \n       multiset(const multiset& __x, const allocator_type& __a)\n       : _Base(__x, __a) { }\n \n       multiset(multiset&& __x, const allocator_type& __a)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value\n-\t       && _Alloc_traits::_S_always_equal())\n+      noexcept( noexcept(_Base(std::move(__x), __a)) )\n       : _Base(std::move(__x), __a) { }\n \n       multiset(initializer_list<value_type> __l, const allocator_type& __a)\n       : _Base(__l, __a) { }\n \n       template<typename _InputIterator>\n-        multiset(_InputIterator __first, _InputIterator __last,\n-\t    const allocator_type& __a)\n-\t  : _Base(__first, __last, __a) { }\n+\tmultiset(_InputIterator __first, _InputIterator __last,\n+\t\t const allocator_type& __a)\n+\t: _Base(__first, __last, __a) { }\n #endif\n \n       multiset(const _Base& __x)\n       : _Base(__x) { }\n \n-      ~multiset() _GLIBCXX_NOEXCEPT { }\n-\n #if __cplusplus < 201103L\n       multiset&\n       operator=(const multiset& __x)\n@@ -147,98 +146,112 @@ namespace __profile\n       }\n #endif\n \n-      using _Base::get_allocator;\n-\n       // iterators:\n-      iterator\n-      begin() _GLIBCXX_NOEXCEPT\n-      { return iterator(_Base::begin()); }\n-\n-      const_iterator\n-      begin() const _GLIBCXX_NOEXCEPT\n-      { return const_iterator(_Base::begin()); }\n-\n-      iterator\n-      end() _GLIBCXX_NOEXCEPT\n-      { return iterator(_Base::end()); }\n-\n-      const_iterator\n-      end() const _GLIBCXX_NOEXCEPT\n-      { return const_iterator(_Base::end()); }\n-\n       reverse_iterator\n       rbegin() _GLIBCXX_NOEXCEPT\n-      { return reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rbegin();\n+      }\n \n       const_reverse_iterator\n       rbegin() const _GLIBCXX_NOEXCEPT\n-      { return const_reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rbegin();\n+      }\n \n       reverse_iterator\n       rend() _GLIBCXX_NOEXCEPT\n-      { return reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rend();\n+      }\n \n       const_reverse_iterator\n       rend() const _GLIBCXX_NOEXCEPT\n-      { return const_reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rend();\n+      }\n \n #if __cplusplus >= 201103L\n-      const_iterator\n-      cbegin() const noexcept\n-      { return const_iterator(_Base::begin()); }\n-\n-      const_iterator\n-      cend() const noexcept\n-      { return const_iterator(_Base::end()); }\n-\n       const_reverse_iterator\n       crbegin() const noexcept\n-      { return const_reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::crbegin();\n+      }\n \n       const_reverse_iterator\n       crend() const noexcept\n-      { return const_reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::crend();\n+      }\n #endif\n \n-      // capacity:\n-      using _Base::empty;\n-      using _Base::size;\n-      using _Base::max_size;\n-\n       // modifiers:\n #if __cplusplus >= 201103L\n       template<typename... _Args>\n \titerator\n \templace(_Args&&... __args)\n-\t{ return iterator(_Base::emplace(std::forward<_Args>(__args)...)); }\n+\t{\n+\t  // The cost is the same whether or not the element is inserted so we\n+\t  // always report insertion of 1 element.\n+\t  __profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\t  return _Base::emplace(std::forward<_Args>(__args)...);\n+\t}\n \n       template<typename... _Args>\n \titerator\n \templace_hint(const_iterator __pos, _Args&&... __args)\n \t{\n-\t  return iterator(_Base::emplace_hint(__pos,\n-\t\t\t\t\t      std::forward<_Args>(__args)...));\n+\t  auto size_before = this->size();\n+\t  auto __res = _Base::emplace_hint(__pos, std::forward<_Args>(__args)...);\n+\t  __profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\t  return __res;\n \t}\n #endif\n \n       iterator\n       insert(const value_type& __x)\n-      { return iterator(_Base::insert(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\treturn _Base::insert(__x);\n+      }\n \n #if __cplusplus >= 201103L\n       iterator\n       insert(value_type&& __x)\n-      { return iterator(_Base::insert(std::move(__x))); }\n+      {\n+\t__profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\treturn _Base::insert(std::move(__x));\n+      }\n #endif\n \n       iterator\n-      insert(const_iterator __position, const value_type& __x)\n-      { return iterator(_Base::insert(__position, __x)); }\n+      insert(const_iterator __pos, const value_type& __x)\n+      {\n+\tsize_type size_before = this->size();\n+\titerator __res = _Base::insert(__pos, __x);\n+\t\n+\t__profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\treturn __res;\n+      }\n \n #if __cplusplus >= 201103L\n       iterator\n-      insert(const_iterator __position, value_type&& __x)\n-      { return iterator(_Base::insert(__position, std::move(__x))); }\n+      insert(const_iterator __pos, value_type&& __x)\n+      {\n+\tauto size_before = this->size();\n+\tauto __res = _Base::insert(__pos, std::move(__x));\n+\t__profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t      _M_hint_used(__pos, __res) ? 0 : 1);\n+\treturn __res;\n+      }\n #endif\n \n #if __cplusplus >= 201103L\n@@ -247,126 +260,169 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        { _Base::insert(__first, __last); }\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n+\t  for (; __first != __last; ++__first)\n+\t    insert(*__first);\n+\t}\n \n #if __cplusplus >= 201103L\n       void\n       insert(initializer_list<value_type> __l)\n-      { _Base::insert(__l); }\n+      { insert(__l.begin(), __l.end()); }\n #endif\n \n #if __cplusplus >= 201103L\n       iterator\n-      erase(const_iterator __position)\n-      { return iterator(_Base::erase(__position)); }\n+      erase(const_iterator __pos)\n+      {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__pos);\n+      }\n #else\n       void\n-      erase(iterator __position)\n-      { _Base::erase(__position); }\n+      erase(iterator __pos)\n+      {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\t_Base::erase(__pos);\n+      }\n #endif\n \n       size_type\n       erase(const key_type& __x)\n       {\n-\tstd::pair<iterator, iterator> __victims = this->equal_range(__x);\n-\tsize_type __count = 0;\n-\twhile (__victims.first != __victims.second)\n-\t{\n-\t  iterator __victim = __victims.first++;\n-\t  _Base::erase(__victim);\n-\t  ++__count;\n-\t}\n-\treturn __count;\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__x);\n       }\n \n #if __cplusplus >= 201103L\n       iterator\n       erase(const_iterator __first, const_iterator __last)\n-      { return iterator(_Base::erase(__first, __last)); }\n+      {\n+\tif (__first != __last)\n+\t  {\n+\t    iterator __ret;\n+\t    for (; __first != __last;)\n+\t      __ret = erase(__first++);\n+\t    return __ret;\n+\t  }\n+\telse\n+\t  return _Base::erase(__first, __last);\n+      }\n #else\n       void\n       erase(iterator __first, iterator __last)\n-      { _Base::erase(__first, __last); }\n+      {\n+\tfor (; __first != __last;)\n+\t  erase(__first++);\n+      }\n #endif\n \n       void\n       swap(multiset& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       { _Base::swap(__x); }\n \n-      void\n-      clear() _GLIBCXX_NOEXCEPT\n-      { this->erase(begin(), end()); }\n-\n-      // observers:\n-      using _Base::key_comp;\n-      using _Base::value_comp;\n-\n       // multiset operations:\n       iterator\n       find(const key_type& __x)\n-      { return iterator(_Base::find(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::find(__x);\n+      }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 214. set::find() missing const overload\n       const_iterator\n       find(const key_type& __x) const\n-      { return const_iterator(_Base::find(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::find(__x);\n+      }\n \n-      using _Base::count;\n+      size_type\n+      count(const key_type& __x) const\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::count(__x);\n+      }\n \n       iterator\n       lower_bound(const key_type& __x)\n-      { return iterator(_Base::lower_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::lower_bound(__x);\n+      }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 214. set::find() missing const overload\n       const_iterator\n       lower_bound(const key_type& __x) const\n-      { return const_iterator(_Base::lower_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::lower_bound(__x);\n+      }\n \n       iterator\n       upper_bound(const key_type& __x)\n-      { return iterator(_Base::upper_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::upper_bound(__x);\n+      }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 214. set::find() missing const overload\n       const_iterator\n       upper_bound(const key_type& __x) const\n-      { return const_iterator(_Base::upper_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::upper_bound(__x);\n+      }\n \n       std::pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__x);\n-\treturn std::make_pair(iterator(__res.first),\n-\t\t\t      iterator(__res.second));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::equal_range(__x);\n       }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 214. set::find() missing const overload\n       std::pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__x);\n-\treturn std::make_pair(const_iterator(__res.first),\n-\t\t\t      const_iterator(__res.second));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::equal_range(__x);\n       }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n-\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n+\n+    private:\n+      /** If hint is used we consider that the map and unordered_map\n+       * operations have equivalent insertion cost so we do not update metrics\n+       * about it.\n+       * Note that to find out if hint has been used is libstdc++\n+       * implementation dependant.\n+       */\n+      bool\n+      _M_hint_used(const_iterator __hint, iterator __res)\n+      {\n+\treturn (__hint == __res ||\n+\t\t(__hint == this->end() && ++__res == this->end()) ||\n+\t\t(__hint != this->end() && (++__hint == __res ||\n+\t\t\t\t\t   ++__res == --__hint)));\n+      }\n     };\n \n   template<typename _Key, typename _Compare, typename _Allocator>"}, {"sha": "c76adfc48f0261fd06bdea139f582930b3c7a472", "filename": "libstdc++-v3/include/profile/ordered_base.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fordered_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fordered_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fordered_base.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -0,0 +1,65 @@\n+// Profiling unordered containers implementation details -*- C++ -*-\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file profile/ordered_base.h\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_ORDERED\n+#define _GLIBCXX_PROFILE_ORDERED 1\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace __profile\n+{\n+  template<typename _Cont>\n+    class _Ordered_profile\n+    {\n+      _Cont&\n+      _M_conjure()\n+      { return *static_cast<_Cont*>(this); }\n+\n+    public:\n+      _Ordered_profile() _GLIBCXX_NOEXCEPT\n+      { __profcxx_map_to_unordered_map_construct(&_M_conjure()); }\n+\n+#if __cplusplus >= 201103L\n+      _Ordered_profile(const _Ordered_profile&) noexcept\n+      : _Ordered_profile() { }\n+      _Ordered_profile(_Ordered_profile&&) noexcept\n+      : _Ordered_profile() { }\n+\n+      _Ordered_profile&\n+      operator=(const _Ordered_profile&) = default;\n+      _Ordered_profile&\n+      operator=(_Ordered_profile&&) = default;\n+#endif\n+\n+      ~_Ordered_profile()\n+      { __profcxx_map_to_unordered_map_destruct(&_M_conjure()); }\n+    };\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "ced035041a8958783f07c9616af323fd1634b714", "filename": "libstdc++-v3/include/profile/set.h", "status": "modified", "additions": 181, "deletions": 153, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -29,17 +29,19 @@\n #ifndef _GLIBCXX_PROFILE_SET_H\n #define _GLIBCXX_PROFILE_SET_H 1\n \n-#include <utility>\n+#include <profile/base.h>\n+#include <profile/ordered_base.h>\n \n-namespace std _GLIBCXX_VISIBILITY(default) \n+namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __profile\n {\n   /// Class std::set wrapper with performance instrumentation.\n   template<typename _Key, typename _Compare = std::less<_Key>,\n \t   typename _Allocator = std::allocator<_Key> >\n     class set\n-    : public _GLIBCXX_STD_C::set<_Key,_Compare,_Allocator>\n+    : public _GLIBCXX_STD_C::set<_Key,_Compare,_Allocator>,\n+      public _Ordered_profile<set<_Key, _Compare, _Allocator> >\n     {\n       typedef _GLIBCXX_STD_C::set<_Key, _Compare, _Allocator> _Base;\n \n@@ -49,28 +51,36 @@ namespace __profile\n \n     public:\n       // types:\n-      typedef _Key\t\t\t\t    key_type;\n-      typedef _Key\t\t\t\t    value_type;\n-      typedef _Compare\t\t\t\t    key_compare;\n-      typedef _Compare\t\t\t\t    value_compare;\n-      typedef _Allocator\t\t\t    allocator_type;\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n-\n-      typedef typename _Base::iterator               iterator;\n-      typedef typename _Base::const_iterator         const_iterator;\n-      typedef typename _Base::reverse_iterator       reverse_iterator;\n-      typedef typename _Base::const_reverse_iterator const_reverse_iterator;\n-\n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Key\t\t\t\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef _Compare\t\t\t\t\tvalue_compare;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n+\n+      typedef typename _Base::iterator\t\t\titerator;\n+      typedef typename _Base::const_iterator\t\tconst_iterator;\n+      typedef typename _Base::reverse_iterator\t\treverse_iterator;\n+      typedef typename _Base::const_reverse_iterator\tconst_reverse_iterator;\n+\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n \n       // 23.3.3.1 construct/copy/destroy:\n-\n+#if __cplusplus < 201103L\n       set()\n       : _Base() { }\n+      set(const set& __x)\n+      : _Base(__x) { }\n+      ~set() { }\n+#else\n+      set() = default;\n+      set(const set&) = default;\n+      set(set&&) = default;\n+      ~set() = default;\n+#endif\n \n       explicit set(const _Compare& __comp,\n \t\t   const _Allocator& __a = _Allocator())\n@@ -82,49 +92,40 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-        set(_InputIterator __first, _InputIterator __last,\n+\tset(_InputIterator __first, _InputIterator __last,\n \t    const _Compare& __comp = _Compare(),\n \t    const _Allocator& __a = _Allocator())\n \t: _Base(__first, __last, __comp, __a) { }\n \n-#if __cplusplus < 201103L\n-      set(const set& __x)\n-      : _Base(__x) { }\n-#else\n-      set(const set&) = default;\n-      set(set&&) = default;\n-\n+#if __cplusplus >= 201103L\n       set(initializer_list<value_type> __l,\n \t  const _Compare& __comp = _Compare(),\n-\t  const allocator_type& __a = allocator_type())\n+\t  const _Allocator& __a = _Allocator())\n       : _Base(__l, __comp, __a) { }\n \n       explicit\n-      set(const allocator_type& __a)\n-\t: _Base(__a) { }\n+      set(const _Allocator& __a)\n+      : _Base(__a) { }\n \n-      set(const set& __x, const allocator_type& __a)\n+      set(const set& __x, const _Allocator& __a)\n       : _Base(__x, __a) { }\n \n-      set(set&& __x, const allocator_type& __a)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value\n-\t       && _Alloc_traits::_S_always_equal())\n+      set(set&& __x, const _Allocator& __a)\n+      noexcept( noexcept(_Base(std::move(__x), __a)) )\n       : _Base(std::move(__x), __a) { }\n \n-      set(initializer_list<value_type> __l, const allocator_type& __a)\n+      set(initializer_list<value_type> __l, const _Allocator& __a)\n       : _Base(__l, __a) { }\n \n       template<typename _InputIterator>\n-        set(_InputIterator __first, _InputIterator __last,\n-\t    const allocator_type& __a)\n-\t  : _Base(__first, __last, __a) { }\n+\tset(_InputIterator __first, _InputIterator __last,\n+\t    const _Allocator& __a)\n+\t: _Base(__first, __last, __a) { }\n #endif\n \n       set(const _Base& __x)\n       : _Base(__x) { }\n \n-      ~set() _GLIBCXX_NOEXCEPT { }\n-\n #if __cplusplus < 201103L\n       set&\n       operator=(const set& __x)\n@@ -147,108 +148,98 @@ namespace __profile\n       }\n #endif\n \n-      using _Base::get_allocator;\n-\n-      // iterators:\n-      iterator\n-      begin() _GLIBCXX_NOEXCEPT\n-      { return iterator(_Base::begin()); }\n-\n-      const_iterator\n-      begin() const _GLIBCXX_NOEXCEPT\n-      { return const_iterator(_Base::begin()); }\n-\n-      iterator\n-      end() _GLIBCXX_NOEXCEPT\n-      { return iterator(_Base::end()); }\n-\n-      const_iterator\n-      end() const _GLIBCXX_NOEXCEPT\n-      { return const_iterator(_Base::end()); }\n-\n       reverse_iterator\n       rbegin() _GLIBCXX_NOEXCEPT\n-      { return reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rbegin();\n+      }\n \n       const_reverse_iterator\n       rbegin() const _GLIBCXX_NOEXCEPT\n-      { return const_reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rbegin();\n+      }\n \n       reverse_iterator\n       rend() _GLIBCXX_NOEXCEPT\n-      { return reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rend();\n+      }\n \n       const_reverse_iterator\n       rend() const _GLIBCXX_NOEXCEPT\n-      { return const_reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::rend();\n+      }\n \n #if __cplusplus >= 201103L\n-      const_iterator\n-      cbegin() const noexcept\n-      { return const_iterator(_Base::begin()); }\n-\n-      const_iterator\n-      cend() const noexcept\n-      { return const_iterator(_Base::end()); }\n-\n       const_reverse_iterator\n       crbegin() const noexcept\n-      { return const_reverse_iterator(end()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::crbegin();\n+      }\n \n       const_reverse_iterator\n       crend() const noexcept\n-      { return const_reverse_iterator(begin()); }\n+      {\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::crend();\n+      }\n #endif\n \n-      // capacity:\n-      using _Base::empty;\n-      using _Base::size;\n-      using _Base::max_size;\n-\n       // modifiers:\n #if __cplusplus >= 201103L\n       template<typename... _Args>\n \tstd::pair<iterator, bool>\n \templace(_Args&&... __args)\n \t{\n-\t  auto __res = _Base::emplace(std::forward<_Args>(__args)...);\n-\t  return std::pair<iterator, bool>(iterator(__res.first),\n-\t\t\t\t\t   __res.second);\n+\t  __profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\t  return _Base::emplace(std::forward<_Args>(__args)...);\n \t}\n \n       template<typename... _Args>\n \titerator\n \templace_hint(const_iterator __pos, _Args&&... __args)\n \t{\n-\t  return iterator(_Base::emplace_hint(__pos,\n-\t\t\t\t\t      std::forward<_Args>(__args)...));\n+\t  auto size_before = this->size();\n+\t  auto __res\n+\t    = _Base::emplace_hint(__pos, std::forward<_Args>(__args)...);\n+\t  __profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\t  return __res;\n \t}\n #endif\n \n       std::pair<iterator, bool>\n       insert(const value_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, bool> __res = _Base::insert(__x);\n-\treturn std::pair<iterator, bool>(iterator(__res.first),\n-\t\t\t\t\t __res.second);\n+\t__profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\treturn _Base::insert(__x);\n       }\n \n #if __cplusplus >= 201103L\n       std::pair<iterator, bool>\n       insert(value_type&& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, bool> __res\n-\t  = _Base::insert(std::move(__x));\n-\treturn std::pair<iterator, bool>(iterator(__res.first),\n-\t\t\t\t\t __res.second);\n+\t__profcxx_map_to_unordered_map_insert(this, this->size(), 1);\n+\treturn _Base::insert(std::move(__x));\n       }\n #endif\n \n       iterator\n-      insert(const_iterator __position, const value_type& __x)\n-      { return iterator(_Base::insert(__position, __x)); }\n+      insert(const_iterator __pos, const value_type& __x)\n+      {\n+\tsize_type size_before = this->size();\n+\titerator __res = _Base::insert(__pos, __x);\n+\t__profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t_M_hint_used(__pos, __res) ? 0 : 1);\n+\treturn __res;\n+      }\n \n #if __cplusplus >= 201103L\n       iterator\n@@ -262,125 +253,162 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        { _Base::insert(__first, __last); }\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n+\t  for (; __first != __last; ++__first)\n+\t    insert(*__first);\n+\t}\n \n #if __cplusplus >= 201103L\n       void\n       insert(initializer_list<value_type> __l)\n-      { _Base::insert(__l); }\n+      { insert(__l.begin(), __l.end()); }\n #endif\n \n #if __cplusplus >= 201103L\n       iterator\n-      erase(const_iterator __position)\n-      { return iterator(_Base::erase(__position)); }\n+      erase(const_iterator __pos)\n+      {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__pos);\n+      }\n #else\n       void\n-      erase(iterator __position)\n-      { _Base::erase(__position); }\n+      erase(iterator __pos)\n+      {\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\t_Base::erase(__pos);\n+      }\n #endif\n \n       size_type\n       erase(const key_type& __x)\n       {\n-\titerator __victim = find(__x);\n-\tif (__victim == end())\n-          return 0;\n-\telse\n-        {\n-\t  _Base::erase(__victim);\n-\t  return 1;\n-        }\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_erase(this, this->size(), 1);\n+\treturn _Base::erase(__x);\n       }\n \n #if __cplusplus >= 201103L\n       iterator\n       erase(const_iterator __first, const_iterator __last)\n-      { return iterator(_Base::erase(__first, __last)); }\n+      {\n+\tif (__first != __last)\n+\t  {\n+\t    iterator __ret;\n+\t    for (; __first != __last;)\n+\t      __ret = erase(__first++);\n+\t    return __ret;\n+\t  }\n+\n+\treturn _Base::erase(__first, __last);\n+      }\n #else\n       void\n       erase(iterator __first, iterator __last)\n-      { _Base::erase(__first, __last); }\n+      {\n+\tfor (; __first != __last;)\n+\t     erase(__first++);\n+      }\n #endif\n \n       void\n       swap(set& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n       { _Base::swap(__x); }\n \n-      void\n-      clear() _GLIBCXX_NOEXCEPT\n-      { this->erase(begin(), end()); }\n-\n-      // observers:\n-      using _Base::key_comp;\n-      using _Base::value_comp;\n-\n       // set operations:\n       iterator\n       find(const key_type& __x)\n-      { return iterator(_Base::find(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::find(__x);\n+      }\n \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 214. set::find() missing const overload\n       const_iterator\n       find(const key_type& __x) const\n-      { return const_iterator(_Base::find(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::find(__x);\n+      }\n \n-      using _Base::count;\n+      size_type\n+      count(const key_type& __x) const\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::count(__x);\n+      }\n \n       iterator\n       lower_bound(const key_type& __x)\n-      { return iterator(_Base::lower_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::lower_bound(__x);\n+      }\n \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 214. set::find() missing const overload\n       const_iterator\n       lower_bound(const key_type& __x) const\n-      { return const_iterator(_Base::lower_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::lower_bound(__x);\n+      }\n \n       iterator\n       upper_bound(const key_type& __x)\n-      { return iterator(_Base::upper_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::upper_bound(__x);\n+      }\n \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 214. set::find() missing const overload\n       const_iterator\n       upper_bound(const key_type& __x) const\n-      { return const_iterator(_Base::upper_bound(__x)); }\n+      {\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\t__profcxx_map_to_unordered_map_invalidate(this);\n+\treturn _Base::upper_bound(__x);\n+      }\n \n-      std::pair<iterator,iterator>\n+      std::pair<iterator, iterator>\n       equal_range(const key_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__x);\n-\treturn std::make_pair(iterator(__res.first),\n-\t\t\t      iterator(__res.second));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::equal_range(__x);\n       }\n \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 214. set::find() missing const overload\n-      std::pair<const_iterator,const_iterator>\n+      std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__x);\n-\treturn std::make_pair(const_iterator(__res.first),\n-\t\t\t      const_iterator(__res.second));\n+\t__profcxx_map_to_unordered_map_find(this, this->size());\n+\treturn _Base::equal_range(__x);\n       }\n \n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT       { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n-\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n+\n+    private:\n+      /** If hint is used we consider that the map and unordered_map\n+       * operations have equivalent insertion cost so we do not update metrics\n+       * about it.\n+       * Note that to find out if hint has been used is libstdc++\n+       * implementation dependant.\n+       */\n+      bool\n+      _M_hint_used(const_iterator __hint, iterator __res)\n+      {\n+\treturn (__hint == __res ||\n+\t\t(__hint == this->end() && ++__res == this->end()) ||\n+\t\t(__hint != this->end() && (++__hint == __res ||\n+\t\t\t\t\t   ++__res == --__hint)));\n+      }\n     };\n \n   template<typename _Key, typename _Compare, typename _Allocator>"}, {"sha": "283f87ce715df52096380c163bfde9bb0a258a4f", "filename": "libstdc++-v3/include/profile/unordered_base.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_base.h?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -157,7 +157,7 @@ namespace __profile\n       _Unordered_profile()\n       {\n \tauto& __uc = _M_conjure();\n-        __profcxx_hashtable_construct(&__uc, __uc.bucket_count());\n+\t__profcxx_hashtable_construct(&__uc, __uc.bucket_count());\n \t__profcxx_hashtable_construct2(&__uc);\n       }\n       _Unordered_profile(const _Unordered_profile&)\n@@ -168,8 +168,8 @@ namespace __profile\n       ~_Unordered_profile() noexcept\n       {\n \tauto& __uc = _M_conjure();\n-        __profcxx_hashtable_destruct(&__uc, __uc.bucket_count(), __uc.size());\n-        _M_profile_destruct();\n+\t__profcxx_hashtable_destruct(&__uc, __uc.bucket_count(), __uc.size());\n+\t_M_profile_destruct();\n       }\n \n       _Unordered_profile&\n@@ -210,6 +210,7 @@ namespace __profile\n \t  auto __lend = __uc.end(__bkt);\n \t  for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n \t    ++__chain;\n+\n \t  if (__chain)\n \t    {\n \t      ++__chain;\n@@ -245,6 +246,7 @@ namespace __profile\n \t\t  __pit = __it;\n \t\t}\n \t    }\n+\n \t  if (__chain)\n \t    {\n \t      ++__chain;"}, {"sha": "e13c069e58e0c73f886083c9a39b7acfd5c14d69", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 117, "deletions": 131, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -56,73 +56,66 @@ namespace __profile\n       typedef typename _GLIBCXX_STD_BASE _Base;\n \n       _Base&\n-      _M_base() noexcept       { return *this; }\n+      _M_base() noexcept\t{ return *this; }\n \n       const _Base&\n-      _M_base() const noexcept { return *this; }\n+      _M_base() const noexcept\t{ return *this; }\n \n     public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::difference_type difference_type;\n-      typedef typename _Base::reference       reference;\n-      typedef typename _Base::const_reference const_reference;\n-      typedef typename _Base::mapped_type      mapped_type;\n-\n-      typedef typename _Base::iterator iterator;\n-      typedef typename _Base::const_iterator const_iterator;\n+      typedef typename _Base::size_type\t\tsize_type;\n+      typedef typename _Base::hasher\t\thasher;\n+      typedef typename _Base::key_equal\t\tkey_equal;\n+      typedef typename _Base::allocator_type\tallocator_type;\n+      typedef typename _Base::key_type\t\tkey_type;\n+      typedef typename _Base::value_type\tvalue_type;\n+      typedef typename _Base::difference_type\tdifference_type;\n+      typedef typename _Base::reference\t\treference;\n+      typedef typename _Base::const_reference\tconst_reference;\n+      typedef typename _Base::mapped_type\tmapped_type;\n+\n+      typedef typename _Base::iterator\t\titerator;\n+      typedef typename _Base::const_iterator\tconst_iterator;\n \n       explicit\n       unordered_map(size_type __n = 10,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-\t: _Base(__n, __hf, __eql, __a)\n-      { }\n+      : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n-        unordered_map(_InputIterator __f, _InputIterator __l,\n+\tunordered_map(_InputIterator __f, _InputIterator __l,\n \t\t      size_type __n = 0,\n \t\t      const hasher& __hf = hasher(),\n \t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n-\t  : _Base(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t: _Base(__f, __l, __n, __hf, __eql, __a) { }\n \n       unordered_map(const unordered_map&) = default;\n \n       unordered_map(const _Base& __x)\n-\t: _Base(__x)\n-      { }\n+      : _Base(__x) { }\n \n       unordered_map(unordered_map&&) = default;\n \n       explicit\n       unordered_map(const allocator_type& __a)\n-\t: _Base(__a)\n-      { }\n+      : _Base(__a) { }\n \n       unordered_map(const unordered_map& __umap,\n \t\t    const allocator_type& __a)\n-\t: _Base(__umap, __a)\n-      { }\n+      : _Base(__umap, __a) { }\n \n       unordered_map(unordered_map&& __umap,\n \t\t    const allocator_type& __a)\n-\t: _Base(std::move(__umap._M_base()), __a)\n-      { }\n+      : _Base(std::move(__umap._M_base()), __a) { }\n \n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-\t: _Base(__l, __n, __hf, __eql, __a)\n-      { }\n+      : _Base(__l, __n, __hf, __eql, __a) { }\n \n       unordered_map&\n       operator=(const unordered_map&) = default;\n@@ -140,9 +133,9 @@ namespace __profile\n       void\n       clear() noexcept\n       {\n-        __profcxx_hashtable_destruct(this, _Base::bucket_count(),\n+\t__profcxx_hashtable_destruct(this, _Base::bucket_count(),\n \t\t\t\t     _Base::size());\n-        this->_M_profile_destruct();\n+\tthis->_M_profile_destruct();\n \t_Base::clear();\n       }\n \n@@ -170,81 +163,81 @@ namespace __profile\n \n       void\n       insert(std::initializer_list<value_type> __l)\n-      { \n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__l);\n-        _M_profile_resize(__old_size); \n+      {\n+\tsize_type __old_size = _Base::bucket_count();\n+\t_Base::insert(__l);\n+\t_M_profile_resize(__old_size);\n       }\n \n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        std::pair<iterator, bool> __res = _Base::insert(__obj);\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\tstd::pair<iterator, bool> __res = _Base::insert(__obj);\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       iterator\n       insert(const_iterator __iter, const value_type& __v)\n-      { \n-        size_type __old_size = _Base::bucket_count(); \n-        iterator __res = _Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size); \n-        return __res;\n+      {\n+\tsize_type __old_size = _Base::bucket_count();\n+\titerator __res = _Base::insert(__iter, __v);\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        std::pair<iterator, bool>\n-        insert(_Pair&& __obj)\n-        {\n+\tstd::pair<iterator, bool>\n+\tinsert(_Pair&& __obj)\n+\t{\n \t  size_type __old_size = _Base::bucket_count();\n \t  std::pair<iterator, bool> __res\n \t    = _Base::insert(std::forward<_Pair>(__obj));\n-\t  _M_profile_resize(__old_size); \n+\t  _M_profile_resize(__old_size);\n \t  return __res;\n \t}\n \n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(const_iterator __iter, _Pair&& __v)\n-        { \n-\t  size_type __old_size = _Base::bucket_count(); \n+\titerator\n+\tinsert(const_iterator __iter, _Pair&& __v)\n+\t{\n+\t  size_type __old_size = _Base::bucket_count();\n \t  iterator __res = _Base::insert(__iter, std::forward<_Pair>(__v));\n-\t  _M_profile_resize(__old_size); \n+\t  _M_profile_resize(__old_size);\n \t  return __res;\n \t}\n \n       template<typename _InputIter>\n-        void\n-        insert(_InputIter __first, _InputIter __last)\n-        {\n-\t  size_type __old_size = _Base::bucket_count(); \n+\tvoid\n+\tinsert(_InputIter __first, _InputIter __last)\n+\t{\n+\t  size_type __old_size = _Base::bucket_count();\n \t  _Base::insert(__first, __last);\n-\t  _M_profile_resize(__old_size); \n+\t  _M_profile_resize(__old_size);\n \t}\n \n       // operator[]\n       mapped_type&\n       operator[](const _Key& __k)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        mapped_type& __res = _M_base()[__k];\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\tmapped_type& __res = _M_base()[__k];\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       mapped_type&\n       operator[](_Key&& __k)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        mapped_type& __res = _M_base()[std::move(__k)];\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\tmapped_type& __res = _M_base()[std::move(__k)];\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       void\n@@ -256,7 +249,7 @@ namespace __profile\n       {\n \tsize_type __old_size = _Base::bucket_count();\n \t_Base::rehash(__n);\n-\t_M_profile_resize(__old_size); \n+\t_M_profile_resize(__old_size);\n       }\n \n     private:\n@@ -305,76 +298,69 @@ namespace __profile\n       public _Unordered_profile<unordered_multimap<_Key, _Tp,\n \t\t\t\t\t\t   _Hash, _Pred, _Alloc>,\n \t\t\t\tfalse>\n-    {      \n+    {\n       typedef typename _GLIBCXX_STD_BASE _Base;\n \n       _Base&\n-      _M_base() noexcept       { return *this; }\n+      _M_base() noexcept\t{ return *this; }\n \n       const _Base&\n-      _M_base() const noexcept { return *this; }\n+      _M_base() const noexcept\t{ return *this; }\n \n     public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::difference_type difference_type;\n-      typedef typename _Base::reference       reference;\n-      typedef typename _Base::const_reference const_reference;\n-\n-      typedef typename _Base::iterator iterator;\n-      typedef typename _Base::const_iterator const_iterator;\n+      typedef typename _Base::size_type\t\tsize_type;\n+      typedef typename _Base::hasher\t\thasher;\n+      typedef typename _Base::key_equal\t\tkey_equal;\n+      typedef typename _Base::allocator_type\tallocator_type;\n+      typedef typename _Base::key_type\t\tkey_type;\n+      typedef typename _Base::value_type\tvalue_type;\n+      typedef typename _Base::difference_type\tdifference_type;\n+      typedef typename _Base::reference\t\treference;\n+      typedef typename _Base::const_reference\tconst_reference;\n+\n+      typedef typename _Base::iterator\t\titerator;\n+      typedef typename _Base::const_iterator\tconst_iterator;\n \n       explicit\n       unordered_multimap(size_type __n = 10,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-\t: _Base(__n, __hf, __eql, __a)\n-      { }\n+      : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n-        unordered_multimap(_InputIterator __f, _InputIterator __l,\n+\tunordered_multimap(_InputIterator __f, _InputIterator __l,\n \t\t\t   size_type __n = 0,\n \t\t\t   const hasher& __hf = hasher(),\n \t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n-\t  : _Base(__f, __l, __n, __hf, __eql, __a)\n-      { }\n+\t: _Base(__f, __l, __n, __hf, __eql, __a) { }\n \n       unordered_multimap(const unordered_multimap&) = default;\n \n       unordered_multimap(const _Base& __x)\n-\t: _Base(__x)\n-      { }\n+      : _Base(__x) { }\n \n       unordered_multimap(unordered_multimap&&) = default;\n \n       explicit\n       unordered_multimap(const allocator_type& __a)\n-\t: _Base(__a)\n-      { }\n+      : _Base(__a) { }\n \n       unordered_multimap(const unordered_multimap& __ummap,\n \t\t\t const allocator_type& __a)\n-\t: _Base(__ummap._M_base(), __a)\n-      { }\n+      : _Base(__ummap._M_base(), __a) { }\n \n       unordered_multimap(unordered_multimap&& __ummap,\n \t\t\t const allocator_type& __a)\n-\t: _Base(std::move(__ummap._M_base()), __a)\n-      { }\n+      : _Base(std::move(__ummap._M_base()), __a) { }\n \n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__l, __n, __hf, __eql, __a)\n-      { }\n+      : _Base(__l, __n, __hf, __eql, __a) { }\n \n       unordered_multimap&\n       operator=(const unordered_multimap&) = default;\n@@ -392,7 +378,7 @@ namespace __profile\n       void\n       clear() noexcept\n       {\n-\t__profcxx_hashtable_destruct(this, _Base::bucket_count(), \n+\t__profcxx_hashtable_destruct(this, _Base::bucket_count(),\n \t\t\t\t     _Base::size());\n \tthis->_M_profile_destruct();\n \t_Base::clear();\n@@ -422,61 +408,61 @@ namespace __profile\n \n       void\n       insert(std::initializer_list<value_type> __l)\n-      { \n-        size_type __old_size = _Base::bucket_count();\n-        _Base::insert(__l);\n-        _M_profile_resize(__old_size);\n+      {\n+\tsize_type __old_size = _Base::bucket_count();\n+\t_Base::insert(__l);\n+\t_M_profile_resize(__old_size);\n       }\n \n       iterator\n       insert(const value_type& __obj)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        iterator __res = _Base::insert(__obj);\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\titerator __res = _Base::insert(__obj);\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       iterator\n       insert(const_iterator __iter, const value_type& __v)\n-      { \n-        size_type __old_size = _Base::bucket_count(); \n-        iterator __res = _Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size); \n-        return __res;\n+      {\n+\tsize_type __old_size = _Base::bucket_count();\n+\titerator __res = _Base::insert(__iter, __v);\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(_Pair&& __obj)\n-        {\n+\titerator\n+\tinsert(_Pair&& __obj)\n+\t{\n \t  size_type __old_size = _Base::bucket_count();\n \t  iterator __res = _Base::insert(std::forward<_Pair>(__obj));\n-\t  _M_profile_resize(__old_size); \n+\t  _M_profile_resize(__old_size);\n \t  return __res;\n \t}\n \n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(const_iterator __iter, _Pair&& __v)\n-        {\n-\t  size_type __old_size = _Base::bucket_count(); \n+\titerator\n+\tinsert(const_iterator __iter, _Pair&& __v)\n+\t{\n+\t  size_type __old_size = _Base::bucket_count();\n \t  iterator __res = _Base::insert(__iter, std::forward<_Pair>(__v));\n-\t  _M_profile_resize(__old_size); \n+\t  _M_profile_resize(__old_size);\n \t  return __res;\n \t}\n \n       template<typename _InputIter>\n-        void\n-        insert(_InputIter __first, _InputIter __last)\n-        {\n-\t  size_type __old_size = _Base::bucket_count(); \n+\tvoid\n+\tinsert(_InputIter __first, _InputIter __last)\n+\t{\n+\t  size_type __old_size = _Base::bucket_count();\n \t  _Base::insert(__first, __last);\n-\t  _M_profile_resize(__old_size); \n+\t  _M_profile_resize(__old_size);\n \t}\n \n       void\n@@ -487,18 +473,18 @@ namespace __profile\n       void\n       rehash(size_type __n)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        _Base::rehash(__n);\n-        _M_profile_resize(__old_size); \n+\tsize_type __old_size = _Base::bucket_count();\n+\t_Base::rehash(__n);\n+\t_M_profile_resize(__old_size);\n       }\n \n     private:\n       void\n       _M_profile_resize(size_type __old_size)\n       {\n \tsize_type __new_size = _Base::bucket_count();\n-        if (__old_size != __new_size)\n-          __profcxx_hashtable_resize(this, __old_size, __new_size);\n+\tif (__old_size != __new_size)\n+\t  __profcxx_hashtable_resize(this, __old_size, __new_size);\n       }\n   };\n "}, {"sha": "c42ddfeda620b7ef339ef8c05ff84c8a11efc227", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -44,7 +44,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n namespace __profile\n {\n   /** @brief Unordered_set wrapper with performance instrumentation.  */\n-  template<typename _Key, \n+  template<typename _Key,\n \t   typename _Hash = std::hash<_Key>,\n \t   typename _Pred = std::equal_to<_Key>,\n \t   typename _Alloc =  std::allocator<_Key> >\n@@ -62,18 +62,18 @@ namespace __profile\n       _M_base() const noexcept { return *this; }\n \n     public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type  allocator_type;\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::difference_type difference_type;\n-      typedef typename _Base::reference       reference;\n-      typedef typename _Base::const_reference const_reference;\n-\n-      typedef typename _Base::iterator iterator;\n-      typedef typename _Base::const_iterator const_iterator;\n+      typedef typename _Base::size_type\t\tsize_type;\n+      typedef typename _Base::hasher\t\thasher;\n+      typedef typename _Base::key_equal\t\tkey_equal;\n+      typedef typename _Base::allocator_type\tallocator_type;\n+      typedef typename _Base::key_type\t\tkey_type;\n+      typedef typename _Base::value_type\tvalue_type;\n+      typedef typename _Base::difference_type\tdifference_type;\n+      typedef typename _Base::reference\t\treference;\n+      typedef typename _Base::const_reference\tconst_reference;\n+\n+      typedef typename _Base::iterator\t\titerator;\n+      typedef typename _Base::const_iterator\tconst_iterator;\n \n       explicit\n       unordered_set(size_type __n = 10,\n@@ -84,7 +84,7 @@ namespace __profile\n       { }\n \n       template<typename _InputIterator>\n-        unordered_set(_InputIterator __f, _InputIterator __l,\n+\tunordered_set(_InputIterator __f, _InputIterator __l,\n \t\t      size_type __n = 0,\n \t\t      const hasher& __hf = hasher(),\n \t\t      const key_equal& __eql = key_equal(),\n@@ -144,10 +144,10 @@ namespace __profile\n       void\n       clear() noexcept\n       {\n-        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n-                                     _Base::size());\n-        this->_M_profile_destruct();\n-        _Base::clear();\n+\t__profcxx_hashtable_destruct(this, _Base::bucket_count(),\n+\t\t\t\t     _Base::size());\n+\tthis->_M_profile_destruct();\n+\t_Base::clear();\n       }\n \n       template<typename... _Args>\n@@ -174,63 +174,63 @@ namespace __profile\n \n       void\n       insert(std::initializer_list<value_type> __l)\n-      { \n-        size_type __old_size = _Base::bucket_count();\n-        _Base::insert(__l); \n-        _M_profile_resize(__old_size); \n+      {\n+\tsize_type __old_size = _Base::bucket_count();\n+\t_Base::insert(__l);\n+\t_M_profile_resize(__old_size);\n       }\n \n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        std::pair<iterator, bool> __res = _Base::insert(__obj);\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\tstd::pair<iterator, bool> __res = _Base::insert(__obj);\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       iterator\n       insert(const_iterator __iter, const value_type& __v)\n-      { \n-        size_type __old_size = _Base::bucket_count(); \n-        iterator __res = _Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size); \n-        return __res;\n+      {\n+\tsize_type __old_size = _Base::bucket_count();\n+\titerator __res = _Base::insert(__iter, __v);\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       std::pair<iterator, bool>\n       insert(value_type&& __obj)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        std::pair<iterator, bool> __res = _Base::insert(std::move(__obj));\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\tstd::pair<iterator, bool> __res = _Base::insert(std::move(__obj));\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       iterator\n       insert(const_iterator __iter, value_type&& __v)\n-      { \n-        size_type __old_size = _Base::bucket_count();\n-        iterator __res = _Base::insert(__iter, std::move(__v));\n-        _M_profile_resize(__old_size); \n-        return __res;\n+      {\n+\tsize_type __old_size = _Base::bucket_count();\n+\titerator __res = _Base::insert(__iter, std::move(__v));\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       template<typename _InputIter>\n-        void\n-        insert(_InputIter __first, _InputIter __last)\n-        {\n-\t  size_type __old_size = _Base::bucket_count(); \n+\tvoid\n+\tinsert(_InputIter __first, _InputIter __last)\n+\t{\n+\t  size_type __old_size = _Base::bucket_count();\n \t  _Base::insert(__first, __last);\n-\t  _M_profile_resize(__old_size); \n+\t  _M_profile_resize(__old_size);\n \t}\n \n       void\n       rehash(size_type __n)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        _Base::rehash(__n);\n-        _M_profile_resize(__old_size); \n+\tsize_type __old_size = _Base::bucket_count();\n+\t_Base::rehash(__n);\n+\t_M_profile_resize(__old_size);\n       }\n \n     private:\n@@ -287,10 +287,10 @@ namespace __profile\n \n     public:\n       typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::hasher\t  hasher;\n       typedef typename _Base::key_equal       key_equal;\n       typedef typename _Base::allocator_type  allocator_type;\n-      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::key_type\tkey_type;\n       typedef typename _Base::value_type      value_type;\n       typedef typename _Base::difference_type difference_type;\n       typedef typename _Base::reference       reference;\n@@ -308,7 +308,7 @@ namespace __profile\n       { }\n \n       template<typename _InputIterator>\n-        unordered_multiset(_InputIterator __f, _InputIterator __l,\n+\tunordered_multiset(_InputIterator __f, _InputIterator __l,\n \t\t\t   size_type __n = 0,\n \t\t\t   const hasher& __hf = hasher(),\n \t\t\t   const key_equal& __eql = key_equal(),\n@@ -368,10 +368,10 @@ namespace __profile\n       void\n       clear() noexcept\n       {\n-        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n-                                     _Base::size());\n-        this->_M_profile_destruct();\n-        _Base::clear();\n+\t__profcxx_hashtable_destruct(this, _Base::bucket_count(),\n+\t\t\t\t     _Base::size());\n+\tthis->_M_profile_destruct();\n+\t_Base::clear();\n       }\n \n       template<typename... _Args>\n@@ -397,72 +397,72 @@ namespace __profile\n \n       void\n       insert(std::initializer_list<value_type> __l)\n-      { \n-        size_type __old_size = _Base::bucket_count();\n-        _Base::insert(__l); \n-        _M_profile_resize(__old_size); \n+      {\n+\tsize_type __old_size = _Base::bucket_count();\n+\t_Base::insert(__l);\n+\t_M_profile_resize(__old_size);\n       }\n \n       iterator\n       insert(const value_type& __obj)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        iterator __res = _Base::insert(__obj);\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\titerator __res = _Base::insert(__obj);\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       iterator\n       insert(const_iterator __iter, const value_type& __v)\n       {\n-        size_type __old_size = _Base::bucket_count(); \n-        iterator __res = _Base::insert(__iter, __v);\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\titerator __res = _Base::insert(__iter, __v);\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       iterator\n       insert(value_type&& __obj)\n       {\n \tsize_type __old_size = _Base::bucket_count();\n-        iterator __res = _Base::insert(std::move(__obj));\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\titerator __res = _Base::insert(std::move(__obj));\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       iterator\n       insert(const_iterator __iter, value_type&& __v)\n       {\n-        size_type __old_size = _Base::bucket_count(); \n-        iterator __res = _Base::insert(__iter, std::move(__v));\n-        _M_profile_resize(__old_size); \n-        return __res;\n+\tsize_type __old_size = _Base::bucket_count();\n+\titerator __res = _Base::insert(__iter, std::move(__v));\n+\t_M_profile_resize(__old_size);\n+\treturn __res;\n       }\n \n       template<typename _InputIter>\n-        void\n-        insert(_InputIter __first, _InputIter __last)\n-        {\n-\t  size_type __old_size = _Base::bucket_count(); \n+\tvoid\n+\tinsert(_InputIter __first, _InputIter __last)\n+\t{\n+\t  size_type __old_size = _Base::bucket_count();\n \t  _Base::insert(__first, __last);\n-\t  _M_profile_resize(__old_size); \n+\t  _M_profile_resize(__old_size);\n \t}\n \n       void\n       rehash(size_type __n)\n       {\n-        size_type __old_size = _Base::bucket_count();\n-        _Base::rehash(__n);\n-        _M_profile_resize(__old_size); \n+\tsize_type __old_size = _Base::bucket_count();\n+\t_Base::rehash(__n);\n+\t_M_profile_resize(__old_size);\n       }\n \n     private:\n       void\n       _M_profile_resize(size_type __old_size)\n       {\n \tsize_type __new_size = _Base::bucket_count();\n-        if (__old_size != __new_size)\n-          __profcxx_hashtable_resize(this, __old_size, __new_size);\n+\tif (__old_size != __new_size)\n+\t  __profcxx_hashtable_resize(this, __old_size, __new_size);\n       }\n    };\n "}, {"sha": "0933ca34cc2843bb5378e8b60408b3756ffc8ea2", "filename": "libstdc++-v3/include/profile/vector", "status": "modified", "additions": 195, "deletions": 252, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector?ref=f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "patch": "@@ -37,87 +37,134 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __profile\n {\n-  template<typename _Tp,\n-\t   typename _Allocator = std::allocator<_Tp> >\n-    class vector\n-    : public _GLIBCXX_STD_C::vector<_Tp, _Allocator>\n+  template<typename _Vector>\n+    class _Vector_profile_pre\n     {\n-      typedef _GLIBCXX_STD_C::vector<_Tp, _Allocator> _Base;\n+      _Vector&\n+      _M_conjure()\n+      { return *static_cast<_Vector*>(this); }\n+\n+    public:\n+#if __cplusplus >= 201103L\n+      _Vector_profile_pre() = default;\n+      _Vector_profile_pre(const _Vector_profile_pre&) = default;\n+      _Vector_profile_pre(_Vector_profile_pre&&) = default;\n+\n+      _Vector_profile_pre&\n+      operator=(const _Vector_profile_pre&) = default;\n \n-      typedef typename _Base::iterator _Base_iterator;\n-      typedef typename _Base::const_iterator _Base_const_iterator;\n+      _Vector_profile_pre&\n+      operator=(_Vector_profile_pre&&) noexcept\n+      { _M_profile_destruct(); }\n+#endif\n+\n+      void\n+      _M_profile_destruct()\n+      {\n+\t__profcxx_vector_destruct2(&_M_conjure());\n+\t__profcxx_vector_destruct(&_M_conjure(),\n+\t\t\t\t  _M_conjure().capacity(), _M_conjure().size());\n+      }\n+    };\n+\n+  template<typename _Vector>\n+    class _Vector_profile_post\n+    {\n+      _Vector&\n+      _M_conjure()\n+      { return *static_cast<_Vector*>(this); }\n+\n+    protected:\n+      _Vector_profile_post() _GLIBCXX_NOEXCEPT\n+      {\n+\t__profcxx_vector_construct(&_M_conjure(), _M_conjure().capacity());\n+\t__profcxx_vector_construct2(&_M_conjure());\t\n+      }\n \n #if __cplusplus >= 201103L\n-      typedef __gnu_cxx::__alloc_traits<_Allocator>  _Alloc_traits;\n+      _Vector_profile_post(const _Vector_profile_post&) noexcept\n+      : _Vector_profile_post() { }\n+      _Vector_profile_post(_Vector_profile_post&&) noexcept\n+      : _Vector_profile_post() { }\n+\n+      _Vector_profile_post&\n+      operator=(const _Vector_profile_post&) = default;\n+      _Vector_profile_post&\n+      operator=(_Vector_profile_post&&) = default;\n #endif\n \n+      ~_Vector_profile_post()\n+      { _M_conjure()._M_profile_destruct(); }\n+    };\n+\n+  template<typename _Tp,\n+\t   typename _Allocator = std::allocator<_Tp> >\n+    class vector\n+    : public _Vector_profile_pre<vector<_Tp, _Allocator> >,\n+      public _GLIBCXX_STD_C::vector<_Tp, _Allocator>,\n+      public _Vector_profile_post<vector<_Tp, _Allocator> >\n+    {\n+      typedef _GLIBCXX_STD_C::vector<_Tp, _Allocator>\t_Base;\n+\n+      typedef typename _Base::iterator\t\t\t_Base_iterator;\n+      typedef typename _Base::const_iterator\t\t_Base_const_iterator;\n+\n     public:\n-      typedef typename _Base::reference             reference;\n-      typedef typename _Base::const_reference       const_reference;\n+      typedef typename _Base::reference\t\t\treference;\n+      typedef typename _Base::const_reference\t\tconst_reference;\n \n       typedef __iterator_tracker<_Base_iterator, vector>\n-                                                    iterator;\n+\t\t\t\t\t\t\titerator;\n       typedef __iterator_tracker<_Base_const_iterator, vector>\n-\t\t\t\t                    const_iterator;\n-\n-      typedef typename _Base::size_type             size_type;\n-      typedef typename _Base::difference_type       difference_type;\n-\n-      typedef _Tp\t\t\t\t    value_type;\n-      typedef _Allocator\t\t\t    allocator_type;\n-      typedef typename _Base::pointer               pointer;\n-      typedef typename _Base::const_pointer         const_pointer;\n-      typedef std::reverse_iterator<iterator>       reverse_iterator;\n-      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n-      \n+\t\t\t\t\t\t\tconst_iterator;\n+\n+      typedef typename _Base::size_type\t\t\tsize_type;\n+      typedef typename _Base::difference_type\t\tdifference_type;\n+\n+      typedef _Tp\t\t\t\t\tvalue_type;\n+      typedef _Allocator\t\t\t\tallocator_type;\n+      typedef typename _Base::pointer\t\t\tpointer;\n+      typedef typename _Base::const_pointer\t\tconst_pointer;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n+\n       _Base&\n-      _M_base() _GLIBCXX_NOEXCEPT { return *this; }\n+      _M_base() _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       const _Base&\n-      _M_base() const _GLIBCXX_NOEXCEPT { return *this; }\n+      _M_base() const _GLIBCXX_NOEXCEPT\t{ return *this; }\n \n       // 23.2.4.1 construct/copy/destroy:\n \n-      vector() _GLIBCXX_NOEXCEPT\n-      : _Base()\n-      {\n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n+#if __cplusplus < 201103L\n+      vector()\n+      { }\n+\n+      vector(const vector& __x)\n+      : _Base(__x) { }\n+#else\n+      vector() = default;\n+      vector(const vector&) = default;\n+      vector(vector&&) = default;\n+#endif\n \n       explicit\n       vector(const _Allocator& __a) _GLIBCXX_NOEXCEPT\n-      : _Base(__a)\n-      {\n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n+      : _Base(__a) { }\n \n #if __cplusplus >= 201103L\n       explicit\n       vector(size_type __n, const _Allocator& __a = _Allocator())\n-      : _Base(__n, __a)\n-      {\n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n+      : _Base(__n, __a) { }\n \n       vector(size_type __n, const _Tp& __value,\n \t     const _Allocator& __a = _Allocator())\n-      :  _Base(__n, __value, __a)\n-      {\n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n+      : _Base(__n, __value, __a) { }\n #else\n       explicit\n       vector(size_type __n, const _Tp& __value = _Tp(),\n \t     const _Allocator& __a = _Allocator())\n-      : _Base(__n, __value, __a)\n-      {\n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n+      : _Base(__n, __value, __a) { }\n #endif\n \n #if __cplusplus >= 201103L\n@@ -126,91 +173,48 @@ namespace __profile\n #else\n       template<typename _InputIterator>\n #endif\n-        vector(_InputIterator __first, _InputIterator __last,\n+\tvector(_InputIterator __first, _InputIterator __last,\n \t       const _Allocator& __a = _Allocator())\n-\t: _Base(__first, __last, __a)\n-        {\n-\t  __profcxx_vector_construct(this, this->capacity());\n-\t  __profcxx_vector_construct2(this);\n-\t}\n+\t: _Base(__first, __last, __a) { }\n \n-      vector(const vector& __x)\n-      : _Base(__x) \n-      {\n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n-\n-      /// Construction from a release-mode vector\n+      /// Construction from a normal-mode vector\n       vector(const _Base& __x)\n-      : _Base(__x) \n-      { \n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n+      : _Base(__x) { }\n \n #if __cplusplus >= 201103L\n-      vector(vector&& __x) noexcept\n-      : _Base(std::move(__x))\n-      {\n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n-\n       vector(const _Base& __x, const _Allocator& __a)\n-      : _Base(__x, __a)\n-      { \n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n+      : _Base(__x, __a) { }\n \n       vector(vector&& __x, const _Allocator& __a)\n-      : _Base(std::move(__x), __a)\n-      {\n-        __profcxx_vector_construct(this, this->capacity());\n-        __profcxx_vector_construct2(this);\n-      }\n+      : _Base(std::move(__x), __a) { }\n \n       vector(initializer_list<value_type> __l,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__l, __a) { }\n #endif\n \n-      ~vector() _GLIBCXX_NOEXCEPT\n-      {\n-        __profcxx_vector_destruct(this, this->capacity(), this->size());\n-        __profcxx_vector_destruct2(this);\n-      }\n-\n+#if __cplusplus < 201103L\n       vector&\n       operator=(const vector& __x)\n       {\n-        static_cast<_Base&>(*this) = __x;\n-        return *this;\n+\t_M_base() = __x;\n+\treturn *this;\n       }\n+#else\n+      vector&\n+      operator=(const vector&) = default;\n \n-#if __cplusplus >= 201103L\n       vector&\n-      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n-      {\n-\t__profcxx_vector_destruct(this, this->capacity(), this->size());\n-\t__profcxx_vector_destruct2(this);\n-\tstatic_cast<_Base&>(*this) = std::move(__x);\n-\treturn *this;\n-      }\n+      operator=(vector&&) = default;\n \n       vector&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tstatic_cast<_Base&>(*this) = __l;\n+\t_M_base() = __l;\n \treturn *this;\n       }\n #endif\n \n-      using _Base::assign;\n-      using _Base::get_allocator;\n-\n-\n       // iterators:\n       iterator\n       begin() _GLIBCXX_NOEXCEPT\n@@ -263,301 +267,240 @@ namespace __profile\n #endif\n \n       // 23.2.4.2 capacity:\n-      using _Base::size;\n-      using _Base::max_size;\n \n #if __cplusplus >= 201103L\n       void\n       resize(size_type __sz)\n       {\n-        __profcxx_vector_invalid_operator(this);\n-        _M_profile_resize(this, this->capacity(), __sz);\n-        _Base::resize(__sz);\n+\t__profcxx_vector_invalid_operator(this);\n+\t_M_profile_resize(this->capacity(), __sz);\n+\t_Base::resize(__sz);\n       }\n \n       void\n       resize(size_type __sz, const _Tp& __c)\n       {\n-        __profcxx_vector_invalid_operator(this);\n-        _M_profile_resize(this, this->capacity(), __sz);\n-        _Base::resize(__sz, __c);\n+\t__profcxx_vector_invalid_operator(this);\n+\t_M_profile_resize(this->capacity(), __sz);\n+\t_Base::resize(__sz, __c);\n       }\n #else\n       void\n       resize(size_type __sz, _Tp __c = _Tp())\n       {\n-        __profcxx_vector_invalid_operator(this);\n-        _M_profile_resize(this, this->capacity(), __sz);\n-        _Base::resize(__sz, __c);\n+\t__profcxx_vector_invalid_operator(this);\n+\t_M_profile_resize(this->capacity(), __sz);\n+\t_Base::resize(__sz, __c);\n       }\n #endif\n \n-#if __cplusplus >= 201103L\n-      using _Base::shrink_to_fit;\n-#endif\n-\n-      using _Base::empty;\n-\n       // element access:\n       reference\n       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_vector_invalid_operator(this);\n-        return _M_base()[__n];\n+\t__profcxx_vector_invalid_operator(this);\n+\treturn _M_base()[__n];\n       }\n       const_reference\n       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_vector_invalid_operator(this);\n-        return _M_base()[__n];\n-      }\n-\n-      using _Base::at;\n-\n-      reference\n-      front() _GLIBCXX_NOEXCEPT\n-      { \n-        return _Base::front();\n-      }\n-\n-      const_reference\n-      front() const _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _Base::front();\n+\t__profcxx_vector_invalid_operator(this);\n+\treturn _M_base()[__n];\n       }\n \n-      reference\n-      back() _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _Base::back();\n-      }\n-\n-      const_reference\n-      back() const _GLIBCXX_NOEXCEPT\n-      {\n-\treturn _Base::back();\n-      }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // DR 464. Suggestion for new member functions in standard containers.\n-      using _Base::data;\n-\n       // 23.2.4.3 modifiers:\n       void\n       push_back(const _Tp& __x)\n       {\n-        size_type __old_size = this->capacity();\n+\tsize_type __old_size = this->capacity();\n \t_Base::push_back(__x);\n-        _M_profile_resize(this, __old_size, this->capacity());\n+\t_M_profile_resize(__old_size, this->capacity());\n       }\n \n #if __cplusplus >= 201103L\n       void\n       push_back(_Tp&& __x)\n       {\n-        size_type __old_size = this->capacity();\n-        _Base::push_back(std::move(__x));\n-        _M_profile_resize(this, __old_size, this->capacity());\n+\tsize_type __old_size = this->capacity();\n+\t_Base::push_back(std::move(__x));\n+\t_M_profile_resize(__old_size, this->capacity());\n       }\n \n #endif\n \n       iterator\n #if __cplusplus >= 201103L\n-      insert(const_iterator __position, const _Tp& __x)\n+      insert(const_iterator __pos, const _Tp& __x)\n #else\n-      insert(iterator __position, const _Tp& __x)\n+      insert(iterator __pos, const _Tp& __x)\n #endif\n       {\n-        __profcxx_vector_insert(this, __position.base() - _Base::begin(),\n-                                this->size());\n-        size_type __old_size = this->capacity();\n-\t_Base_iterator __res = _Base::insert(__position.base(), __x);\n-        _M_profile_resize(this, __old_size, this->capacity());\n+\t__profcxx_vector_insert(this, __pos.base() - _Base::begin(),\n+\t\t\t\tthis->size());\n+\tsize_type __old_size = this->capacity();\n+\t_Base_iterator __res = _Base::insert(__pos.base(), __x);\n+\t_M_profile_resize(__old_size, this->capacity());\n \treturn iterator(__res, this);\n       }\n \n #if __cplusplus >= 201103L\n       iterator\n-      insert(const_iterator __position, _Tp&& __x)\n+      insert(const_iterator __pos, _Tp&& __x)\n       {\n-        __profcxx_vector_insert(this, __position.base() - _Base::cbegin(),\n-                                this->size());\n-        size_type __old_size = this->capacity();\n-\t_Base_iterator __res = _Base::insert(__position.base(), __x);\n-        _M_profile_resize(this, __old_size, this->capacity());\n+\t__profcxx_vector_insert(this, __pos.base() - _Base::cbegin(),\n+\t\t\t\tthis->size());\n+\tsize_type __old_size = this->capacity();\n+\t_Base_iterator __res = _Base::insert(__pos.base(), __x);\n+\t_M_profile_resize(__old_size, this->capacity());\n \treturn iterator(__res, this);\n       }\n \n       template<typename... _Args>\n-        iterator\n-        emplace(const_iterator __position, _Args&&... __args)\n-        {\n-\t  _Base_iterator __res = _Base::emplace(__position.base(),\n+\titerator\n+\templace(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  _Base_iterator __res = _Base::emplace(__pos.base(),\n \t\t\t\t\t\tstd::forward<_Args>(__args)...);\n \t  return iterator(__res, this);\n \t}\n \n       iterator\n-      insert(const_iterator __position, initializer_list<value_type> __l)\n-      { return this->insert(__position, __l.begin(), __l.end()); }\n-#endif\n-\n-#if __cplusplus >= 201103L\n-      void\n-      swap(vector&& __x)\n-      {\n-        _Base::swap(__x);\n-      }\n+      insert(const_iterator __pos, initializer_list<value_type> __l)\n+      { return this->insert(__pos, __l.begin(), __l.end()); }\n #endif\n \n       void\n       swap(vector& __x)\n #if __cplusplus >= 201103L\n-      noexcept(_Alloc_traits::_S_nothrow_swap())\n+\tnoexcept( noexcept(declval<_Base>().swap(__x)) )\n #endif\n-      {\n-        _Base::swap(__x);\n-      }\n+      { _Base::swap(__x); }\n \n #if __cplusplus >= 201103L\n       iterator\n-      insert(const_iterator __position, size_type __n, const _Tp& __x)\n+      insert(const_iterator __pos, size_type __n, const _Tp& __x)\n       {\n-        __profcxx_vector_insert(this, __position.base() - _Base::cbegin(),\n-                                this->size());\n-        size_type __old_size = this->capacity();\n-        _Base_iterator __res = _Base::insert(__position, __n, __x);\n-        _M_profile_resize(this, __old_size, this->capacity());\n+\t__profcxx_vector_insert(this, __pos.base() - _Base::cbegin(),\n+\t\t\t\tthis->size());\n+\tsize_type __old_size = this->capacity();\n+\t_Base_iterator __res = _Base::insert(__pos, __n, __x);\n+\t_M_profile_resize(__old_size, this->capacity());\n \treturn iterator(__res, this);\n       }\n #else\n       void\n-      insert(iterator __position, size_type __n, const _Tp& __x)\n+      insert(iterator __pos, size_type __n, const _Tp& __x)\n       {\n-        __profcxx_vector_insert(this, __position.base() - _Base::begin(),\n-                                this->size());\n-        size_type __old_size = this->capacity();\n-        _Base::insert(__position, __n, __x);\n-        _M_profile_resize(this, __old_size, this->capacity());\n+\t__profcxx_vector_insert(this, __pos.base() - _Base::begin(),\n+\t\t\t\tthis->size());\n+\tsize_type __old_size = this->capacity();\n+\t_Base::insert(__pos, __n, __x);\n+\t_M_profile_resize(__old_size, this->capacity());\n       }\n #endif\n \n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n \titerator\n-\tinsert(const_iterator __position,\n+\tinsert(const_iterator __pos,\n \t       _InputIterator __first, _InputIterator __last)\n-        {\n-\t  __profcxx_vector_insert(this, __position.base() - _Base::cbegin(),\n+\t{\n+\t  __profcxx_vector_insert(this, __pos.base() - _Base::cbegin(),\n \t\t\t\t  this->size());\n \t  size_type __old_size = this->capacity();\n-\t  _Base_iterator __res = _Base::insert(__position, __first, __last);\n-\t  _M_profile_resize(this, __old_size, this->capacity());\n+\t  _Base_iterator __res = _Base::insert(__pos, __first, __last);\n+\t  _M_profile_resize(__old_size, this->capacity());\n \t  return iterator(__res, this);\n \t}\n #else\n       template<typename _InputIterator>\n \tvoid\n-\tinsert(iterator __position,\n+\tinsert(iterator __pos,\n \t       _InputIterator __first, _InputIterator __last)\n-        {\n-\t  __profcxx_vector_insert(this, __position.base() - _Base::begin(),\n+\t{\n+\t  __profcxx_vector_insert(this, __pos.base() - _Base::begin(),\n \t\t\t\t  this->size());\n \t  size_type __old_size = this->capacity();\n-\t  _Base::insert(__position, __first, __last);\n-\t  _M_profile_resize(this, __old_size, this->capacity());\n+\t  _Base::insert(__pos, __first, __last);\n+\t  _M_profile_resize(__old_size, this->capacity());\n \t}\n #endif\n \n       iterator\n #if __cplusplus >= 201103L\n-      erase(const_iterator __position)\n+      erase(const_iterator __pos)\n #else\n-      erase(iterator __position)\t\n+      erase(iterator __pos)\t\n #endif\n-      {\n-\t_Base_iterator __res = _Base::erase(__position.base());\n-\treturn iterator(__res, this);\n-      }\n+      { return iterator(_Base::erase(__pos.base()), this); }\n \n       iterator\n #if __cplusplus >= 201103L\n       erase(const_iterator __first, const_iterator __last)\n #else\n       erase(iterator __first, iterator __last)\n #endif\n-      {\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 151. can't currently clear() empty container\n-\t_Base_iterator __res = _Base::erase(__first.base(), __last.base());\n-\treturn iterator(__res, this);\n-      }\n+      { return iterator(_Base::erase(__first.base(), __last.base()), this); }\n \n       void\n       clear() _GLIBCXX_NOEXCEPT\n       {\n-        __profcxx_vector_destruct(this, this->capacity(), this->size());\n-        __profcxx_vector_destruct2(this);\n-        _Base::clear();\n+\tthis->_M_profile_destruct();\n+\t_Base::clear();\n       }\n \n-      inline void _M_profile_find() const \n-      { \n-        __profcxx_vector_find(this, size()); \n-      }\n+      inline void _M_profile_find() const\n+      { __profcxx_vector_find(this, this->size()); }\n \n-      inline void _M_profile_iterate(int __rewind = 0) const \n-      { \n-        __profcxx_vector_iterate(this); \n-      }\n+      inline void _M_profile_iterate(int __rewind = 0) const\n+      { __profcxx_vector_iterate(this); }\n \n     private:\n-      void _M_profile_resize(void* obj, size_type __old_size, \n-                             size_type __new_size)\n+      void _M_profile_resize(size_type __old_size, size_type __new_size)\n       {\n-        if (__old_size < __new_size) {\n-          __profcxx_vector_resize(this, this->size(), __new_size);\n-          __profcxx_vector_resize2(this, this->size(), __new_size);\n-        }\n+\tif (__old_size < __new_size)\n+\t  {\n+\t    __profcxx_vector_resize(this, this->size(), __new_size);\n+\t    __profcxx_vector_resize2(this, this->size(), __new_size);\n+\t  }\n       }\n     };\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator==(const vector<_Tp, _Alloc>& __lhs,\n-           const vector<_Tp, _Alloc>& __rhs)\n+\t       const vector<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() == __rhs._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const vector<_Tp, _Alloc>& __lhs,\n-           const vector<_Tp, _Alloc>& __rhs)\n+\t       const vector<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() != __rhs._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<(const vector<_Tp, _Alloc>& __lhs,\n-          const vector<_Tp, _Alloc>& __rhs)\n+\t      const vector<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() < __rhs._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<=(const vector<_Tp, _Alloc>& __lhs,\n-           const vector<_Tp, _Alloc>& __rhs)\n+\t       const vector<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() <= __rhs._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>=(const vector<_Tp, _Alloc>& __lhs,\n-           const vector<_Tp, _Alloc>& __rhs)\n+\t       const vector<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() >= __rhs._M_base(); }\n \n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>(const vector<_Tp, _Alloc>& __lhs,\n-          const vector<_Tp, _Alloc>& __rhs)\n+\t      const vector<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() > __rhs._M_base(); }\n \n   template<typename _Tp, typename _Alloc>"}]}