{"sha": "d43d5ef7b552483264f6af5a831bdef1d1cd55cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQzZDVlZjdiNTUyNDgzMjY0ZjZhZjVhODMxYmRlZjFkMWNkNTVjYg==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2005-07-04T13:31:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-04T13:31:24Z"}, "message": "a-convec.ads, [...]: Declaration of subtype Extended_Index was changed.\n\n2005-07-04  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-convec.ads, a-coinve.ads: Declaration of subtype Extended_Index\n\twas changed.\n\t* a-coinve.adb: Perform constraint checks explicitly.\n\nFrom-SVN: r101597", "tree": {"sha": "44bfd5c7d3bbfa64205b95de570d167845fe6f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44bfd5c7d3bbfa64205b95de570d167845fe6f12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d43d5ef7b552483264f6af5a831bdef1d1cd55cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43d5ef7b552483264f6af5a831bdef1d1cd55cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43d5ef7b552483264f6af5a831bdef1d1cd55cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43d5ef7b552483264f6af5a831bdef1d1cd55cb/comments", "author": null, "committer": null, "parents": [{"sha": "c8effb4f399d8f1d59c2a2aafdfbfeaf1313de73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8effb4f399d8f1d59c2a2aafdfbfeaf1313de73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8effb4f399d8f1d59c2a2aafdfbfeaf1313de73"}], "stats": {"total": 1081, "additions": 602, "deletions": 479}, "files": [{"sha": "be49e39be7f5ed49e82dd35eed382875930cf8c4", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 600, "deletions": 475, "changes": 1075, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43d5ef7b552483264f6af5a831bdef1d1cd55cb/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43d5ef7b552483264f6af5a831bdef1d1cd55cb/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=d43d5ef7b552483264f6af5a831bdef1d1cd55cb", "patch": "@@ -76,7 +76,7 @@ package body Ada.Containers.Indefinite_Vectors is\n                   end if;\n                exception\n                   when others =>\n-                     for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                     for J in Index_Type'First .. I - 1 loop\n                         Free (Elements (J));\n                      end loop;\n \n@@ -106,7 +106,7 @@ package body Ada.Containers.Indefinite_Vectors is\n                   end if;\n                exception\n                   when others =>\n-                     for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                     for J in Index_Type'First .. I - 1 loop\n                         Free (Elements (J));\n                      end loop;\n \n@@ -120,60 +120,67 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=\n+         Last_As_Int : constant Int'Base :=  -- TODO: handle overflow\n                          Int (Index_Type'First) + Int (LN) + Int (RN) - 1;\n \n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-         LE : Elements_Type renames\n-                Left.Elements (Index_Type'First .. Left.Last);\n+         declare\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         RE : Elements_Type renames\n-                Right.Elements (Index_Type'First .. Right.Last);\n+            LE : Elements_Type renames\n+                   Left.Elements (Index_Type'First .. Left.Last);\n \n-         Elements : Elements_Access :=\n-                      new Elements_Type (Index_Type'First .. Last);\n+            RE : Elements_Type renames\n+                   Right.Elements (Index_Type'First .. Right.Last);\n \n-         I : Index_Type'Base := Index_Type'Pred (Index_Type'First);\n+            Elements : Elements_Access :=\n+                         new Elements_Type (Index_Type'First .. Last);\n \n-      begin\n-         for LI in LE'Range loop\n-            I := Index_Type'Succ (I);\n+            I : Index_Type'Base := No_Index;\n \n-            begin\n-               if LE (LI) /= null then\n-                  Elements (I) := new Element_Type'(LE (LI).all);\n-               end if;\n-            exception\n-               when others =>\n-                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n-                     Free (Elements (J));\n-                  end loop;\n+         begin\n+            for LI in LE'Range loop\n+               I := I + 1;\n \n-                  Free (Elements);\n-                  raise;\n-            end;\n-         end loop;\n+               begin\n+                  if LE (LI) /= null then\n+                     Elements (I) := new Element_Type'(LE (LI).all);\n+                  end if;\n+               exception\n+                  when others =>\n+                     for J in Index_Type'First .. I - 1 loop\n+                        Free (Elements (J));\n+                     end loop;\n \n-         for RI in RE'Range loop\n-            I := Index_Type'Succ (I);\n+                     Free (Elements);\n+                     raise;\n+               end;\n+            end loop;\n \n-            begin\n-               if RE (RI) /= null then\n-                  Elements (I) := new Element_Type'(RE (RI).all);\n-               end if;\n-            exception\n-               when others =>\n-                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n-                     Free (Elements (J));\n-                  end loop;\n+            for RI in RE'Range loop\n+               I := I + 1;\n \n-                  Free (Elements);\n-                  raise;\n-            end;\n-         end loop;\n+               begin\n+                  if RE (RI) /= null then\n+                     Elements (I) := new Element_Type'(RE (RI).all);\n+                  end if;\n+               exception\n+                  when others =>\n+                     for J in Index_Type'First .. I - 1 loop\n+                        Free (Elements (J));\n+                     end loop;\n \n-         return (Controlled with Elements, Last, 0, 0);\n+                     Free (Elements);\n+                     raise;\n+               end;\n+            end loop;\n+\n+            return (Controlled with Elements, Last, 0, 0);\n+         end;\n       end;\n    end \"&\";\n \n@@ -205,49 +212,51 @@ package body Ada.Containers.Indefinite_Vectors is\n          Last_As_Int : constant Int'Base :=\n                          Int (Index_Type'First) + Int (LN);\n \n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-         LE : Elements_Type renames\n-                Left.Elements (Index_Type'First .. Left.Last);\n+         declare\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         Elements : Elements_Access :=\n-                      new Elements_Type (Index_Type'First .. Last);\n+            LE : Elements_Type renames\n+                   Left.Elements (Index_Type'First .. Left.Last);\n+\n+            Elements : Elements_Access :=\n+                        new Elements_Type (Index_Type'First .. Last);\n+\n+         begin\n+            for I in LE'Range loop\n+               begin\n+                  if LE (I) /= null then\n+                     Elements (I) := new Element_Type'(LE (I).all);\n+                  end if;\n+               exception\n+                  when others =>\n+                     for J in Index_Type'First .. I - 1 loop\n+                        Free (Elements (J));\n+                     end loop;\n+\n+                     Free (Elements);\n+                     raise;\n+               end;\n+            end loop;\n \n-      begin\n-         for I in LE'Range loop\n             begin\n-               if LE (I) /= null then\n-                  Elements (I) := new Element_Type'(LE (I).all);\n-               end if;\n+               Elements (Elements'Last) := new Element_Type'(Right);\n             exception\n                when others =>\n-                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n+                  for J in Index_Type'First .. Elements'Last - 1 loop\n                      Free (Elements (J));\n                   end loop;\n \n                   Free (Elements);\n                   raise;\n             end;\n-         end loop;\n-\n-         begin\n-            Elements (Elements'Last) := new Element_Type'(Right);\n-         exception\n-            when others =>\n-               declare\n-                  subtype J_Subtype is Index_Type'Base range\n-                    Index_Type'First .. Index_Type'Pred (Elements'Last);\n-               begin\n-                  for J in J_Subtype loop\n-                     Free (Elements (J));\n-                  end loop;\n-               end;\n \n-               Free (Elements);\n-               raise;\n+            return (Controlled with Elements, Last, 0, 0);\n          end;\n-\n-         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end \"&\";\n \n@@ -279,72 +288,86 @@ package body Ada.Containers.Indefinite_Vectors is\n          Last_As_Int : constant Int'Base :=\n                          Int (Index_Type'First) + Int (RN);\n \n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n-\n-         RE : Elements_Type renames\n-                Right.Elements (Index_Type'First .. Right.Last);\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-         Elements : Elements_Access :=\n-                      new Elements_Type (Index_Type'First .. Last);\n+         declare\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         I : Index_Type'Base := Index_Type'First;\n+            RE : Elements_Type renames\n+                   Right.Elements (Index_Type'First .. Right.Last);\n \n-      begin\n-         begin\n-            Elements (I) := new Element_Type'(Left);\n-         exception\n-            when others =>\n-               Free (Elements);\n-               raise;\n-         end;\n+            Elements : Elements_Access :=\n+                         new Elements_Type (Index_Type'First .. Last);\n \n-         for RI in RE'Range loop\n-            I := Index_Type'Succ (I);\n+            I : Index_Type'Base := Index_Type'First;\n \n+         begin\n             begin\n-               if RE (RI) /= null then\n-                  Elements (I) := new Element_Type'(RE (RI).all);\n-               end if;\n+               Elements (I) := new Element_Type'(Left);\n             exception\n                when others =>\n-                  for J in Index_Type'First .. Index_Type'Pred (I) loop\n-                     Free (Elements (J));\n-                  end loop;\n-\n                   Free (Elements);\n                   raise;\n             end;\n-         end loop;\n \n-         return (Controlled with Elements, Last, 0, 0);\n+            for RI in RE'Range loop\n+               I := I + 1;\n+\n+               begin\n+                  if RE (RI) /= null then\n+                     Elements (I) := new Element_Type'(RE (RI).all);\n+                  end if;\n+               exception\n+                  when others =>\n+                     for J in Index_Type'First .. I - 1 loop\n+                        Free (Elements (J));\n+                     end loop;\n+\n+                     Free (Elements);\n+                     raise;\n+               end;\n+            end loop;\n+\n+            return (Controlled with Elements, Last, 0, 0);\n+         end;\n       end;\n    end \"&\";\n \n    function \"&\" (Left, Right : Element_Type) return Vector is\n-      subtype IT is Index_Type'Base range\n-        Index_Type'First .. Index_Type'Succ (Index_Type'First);\n+   begin\n+      if Index_Type'First >= Index_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n \n-      Elements : Elements_Access := new Elements_Type (IT);\n+      declare\n+         Last : constant Index_Type := Index_Type'First + 1;\n \n-   begin\n-      begin\n-         Elements (Elements'First) := new Element_Type'(Left);\n-      exception\n-         when others =>\n-            Free (Elements);\n-            raise;\n-      end;\n+         subtype ET is Elements_Type (Index_Type'First .. Last);\n \n+         Elements : Elements_Access := new ET;\n       begin\n-         Elements (Elements'Last) := new Element_Type'(Right);\n-      exception\n-         when others =>\n-            Free (Elements (Elements'First));\n-            Free (Elements);\n-            raise;\n-      end;\n+         begin\n+            Elements (Elements'First) := new Element_Type'(Left);\n+         exception\n+            when others =>\n+               Free (Elements);\n+               raise;\n+         end;\n \n-      return (Controlled with Elements, Elements'Last, 0, 0);\n+         begin\n+            Elements (Elements'Last) := new Element_Type'(Right);\n+         exception\n+            when others =>\n+               Free (Elements (Elements'First));\n+               Free (Elements);\n+               raise;\n+         end;\n+\n+         return (Controlled with Elements, Elements'Last, 0, 0);\n+      end;\n    end \"&\";\n \n    ---------\n@@ -362,17 +385,6 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       for J in Index_Type'First .. Left.Last loop\n-         --  NOTE:\n-         --  I think it's a bounded error to read or otherwise manipulate\n-         --  an \"empty\" element, which here means that it has the value\n-         --  null.  If it's a bounded error then an exception might\n-         --  propagate, or it might not.  We take advantage of that\n-         --  permission here to allow empty elements to be compared.\n-         --\n-         --  Whether this is the right decision I'm not really sure.  If\n-         --  you have a contrary argument then let me know.\n-         --  END NOTE.\n-\n          if Left.Elements (J) = null then\n             if Right.Elements (J) /= null then\n                return False;\n@@ -383,7 +395,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          elsif Left.Elements (J).all /= Right.Elements (J).all then\n             return False;\n-\n          end if;\n       end loop;\n \n@@ -396,20 +407,15 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    procedure Adjust (Container : in out Vector) is\n    begin\n-      if Container.Elements = null then\n-         return;\n-      end if;\n-\n-      if Container.Elements'Length = 0\n-        or else Container.Last < Index_Type'First\n-      then\n+      if Container.Last = No_Index then\n          Container.Elements := null;\n          return;\n       end if;\n \n       declare\n          E : Elements_Type renames Container.Elements.all;\n          L : constant Index_Type := Container.Last;\n+\n       begin\n          Container.Elements := null;\n          Container.Last := No_Index;\n@@ -438,9 +444,13 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n+      if Container.Last = Index_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n+\n       Insert\n         (Container,\n-         Index_Type'Succ (Container.Last),\n+         Container.Last + 1,\n          New_Item);\n    end Append;\n \n@@ -454,9 +464,13 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n+      if Container.Last = Index_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n+\n       Insert\n         (Container,\n-         Index_Type'Succ (Container.Last),\n+         Container.Last + 1,\n          New_Item,\n          Count);\n    end Append;\n@@ -522,12 +536,12 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Program_Error;\n       end if;\n \n-      for J in reverse Index_Type'First .. Container.Last loop\n+      while Container.Last >= Index_Type'First loop\n          declare\n-            X : Element_Access := Container.Elements (J);\n+            X : Element_Access := Container.Elements (Container.Last);\n          begin\n-            Container.Elements (J) := null;\n-            Container.Last := Index_Type'Pred (J);\n+            Container.Elements (Container.Last) := null;\n+            Container.Last := Container.Last - 1;\n             Free (X);\n          end;\n       end loop;\n@@ -575,37 +589,53 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         I_As_Int : constant Int := Int (Index);\n-\n+         Index_As_Int    : constant Int := Int (Index);\n          Old_Last_As_Int : constant Int := Int (Container.Last);\n \n+         --  TODO: somewhat vestigial...fix.\n          Count1 : constant Int'Base := Int (Count);\n-         Count2 : constant Int'Base := Old_Last_As_Int - I_As_Int + 1;\n+         Count2 : constant Int'Base := Old_Last_As_Int - Index_As_Int + 1;\n+         N      : constant Int'Base := Int'Min (Count1, Count2);\n \n-         N : constant Int'Base := Int'Min (Count1, Count2);\n+         J_As_Int : constant Int'Base := Index_As_Int + N;\n+         E        : Elements_Type renames Container.Elements.all;\n \n-         J_As_Int : constant Int'Base := I_As_Int + N;\n-         J        : constant Index_Type'Base := Index_Type'Base (J_As_Int);\n+      begin\n+         if J_As_Int > Old_Last_As_Int then\n+            while Container.Last >= Index loop\n+               declare\n+                  K : constant Index_Type := Container.Last;\n+                  X : Element_Access := E (K);\n \n-         E : Elements_Type renames Container.Elements.all;\n+               begin\n+                  E (K) := null;\n+                  Container.Last := K - 1;\n+                  Free (X);\n+               end;\n+            end loop;\n \n-         New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n+         else\n+            declare\n+               J : constant Index_Type := Index_Type (J_As_Int);\n \n-         New_Last : constant Extended_Index :=\n-                      Extended_Index (New_Last_As_Int);\n+               New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n+               New_Last        : constant Index_Type :=\n+                                   Index_Type (New_Last_As_Int);\n \n-      begin\n-         for K in Index .. Index_Type'Pred (J) loop\n-            declare\n-               X : Element_Access := E (K);\n             begin\n-               E (K) := null;\n-               Free (X);\n-            end;\n-         end loop;\n+               for K in Index .. J - 1 loop\n+                  declare\n+                     X : Element_Access := E (K);\n+                  begin\n+                     E (K) := null;\n+                     Free (X);\n+                  end;\n+               end loop;\n \n-         E (Index .. New_Last) := E (J .. Container.Last);\n-         Container.Last := New_Last;\n+               E (Index .. New_Last) := E (J .. Container.Last);\n+               Container.Last := New_Last;\n+            end;\n+         end if;\n       end;\n    end Delete;\n \n@@ -664,21 +694,35 @@ package body Ada.Containers.Indefinite_Vectors is\n      (Container : in out Vector;\n       Count     : Count_Type := 1)\n    is\n-      Index : Int'Base;\n+      N : constant Count_Type := Length (Container);\n \n    begin\n-      if Count = 0 then\n+      if Count = 0\n+        or else N = 0\n+      then\n          return;\n       end if;\n \n-      if Count >= Length (Container) then\n-         Clear (Container);\n-         return;\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n-      Index := Int'Base (Container.Last) - Int'Base (Count) + 1;\n+      declare\n+         E : Elements_Type renames Container.Elements.all;\n \n-      Delete (Container, Index_Type'Base (Index), Count);\n+      begin\n+         for Indx in 1 .. Count_Type'Min (Count, N) loop\n+            declare\n+               J : constant Index_Type := Container.Last;\n+               X : Element_Access := E (J);\n+\n+            begin\n+               E (J) := null;\n+               Container.Last := J - 1;\n+               Free (X);\n+            end;\n+         end loop;\n+      end;\n    end Delete_Last;\n \n    -------------\n@@ -689,14 +733,20 @@ package body Ada.Containers.Indefinite_Vectors is\n      (Container : Vector;\n       Index     : Index_Type) return Element_Type\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n    begin\n-      return Container.Elements (T'(Index)).all;\n+      if Index > Container.Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Container.Elements (Index).all;\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Element (Position.Container.all, Position.Index);\n    end Element;\n \n@@ -970,10 +1020,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       New_Last_As_Int : Int'Base;\n       New_Last        : Index_Type;\n \n-      Index : Extended_Index;  -- TODO: see note in a-convec.adb.\n-\n-      Dst_Last : Index_Type;\n-      Dst      : Elements_Access;\n+      Dst : Elements_Access;\n \n    begin\n       if Before < Index_Type'First then\n@@ -995,35 +1042,28 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       begin\n          New_Last_As_Int := Old_Last_As_Int + N;\n+\n+         if New_Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n+\n          New_Last := Index_Type (New_Last_As_Int);\n       end;\n \n       if Container.Busy > 0 then\n          raise Program_Error;\n       end if;\n \n-      declare\n-         Old_First_As_Int : constant Int := Int (Before);\n-\n-         New_First_As_Int : constant Int'Base := Old_First_As_Int + N;\n-\n-      begin\n-         Index := Extended_Index (New_First_As_Int);  --  TODO\n-      end;\n-\n       if Container.Elements = null then\n-         declare\n-            subtype Elements_Subtype is\n-              Elements_Type (Index_Type'First .. New_Last);\n-         begin\n-            Container.Elements := new Elements_Subtype;\n-            Container.Last := Index_Type'Pred (Index_Type'First);\n+         Container.Elements :=\n+           new Elements_Type (Index_Type'First .. New_Last);\n \n-            for J in Container.Elements'Range loop\n-               Container.Elements (J) := new Element_Type'(New_Item);\n-               Container.Last := J;\n-            end loop;\n-         end;\n+         Container.Last := No_Index;\n+\n+         for J in Container.Elements'Range loop\n+            Container.Elements (J) := new Element_Type'(New_Item);\n+            Container.Last := J;\n+         end loop;\n \n          return;\n       end if;\n@@ -1032,105 +1072,116 @@ package body Ada.Containers.Indefinite_Vectors is\n          declare\n             E : Elements_Type renames Container.Elements.all;\n          begin\n-            E (Index .. New_Last) := E (Before .. Container.Last);\n-            Container.Last := New_Last;\n+            if Before <= Container.Last then\n+               declare\n+                  Index_As_Int : constant Int'Base :=\n+                                   Index_Type'Pos (Before) + N;\n+\n+                  Index : constant Index_Type := Index_Type (Index_As_Int);\n+\n+                  J : Index_Type'Base := Before;\n \n-            --  NOTE:\n-            --  Now we do the allocation.  If it fails, we can propagate the\n-            --  exception and invariants are more or less satisfied.  The\n-            --  issue is that we have some slots still null, and the client\n-            --  has no way of detecting whether the slot is null (unless we\n-            --  give him a way).\n-            --\n-            --  Another way is to allocate a subarray on the stack, do the\n-            --  allocation into that array, and if that success then do\n-            --  the insertion proper.  The issue there is that you have to\n-            --  allocate the subarray on the stack, and that may fail if the\n-            --  subarray is long.\n-            --\n-            --  Or we could try to roll-back the changes: deallocate the\n-            --  elements we have successfully deallocated, and then copy\n-            --  the elements ptrs back to their original posns.\n-            --  END NOTE.\n-\n-            --  NOTE: I have written the loop manually here.  I could\n-            --  have done it this way too:\n-            --    E (Before .. Index_Type'Pred (Index)) :=\n-            --      (others => new Element_Type'New_Item);\n-            --  END NOTE.\n-\n-            for J in Before .. Index_Type'Pred (Index) loop\n                begin\n-                  E (J) := new Element_Type'(New_Item);\n+                  E (Index .. New_Last) := E (Before .. Container.Last);\n+                  Container.Last := New_Last;\n+\n+                  while J < Index loop\n+                     E (J) := new Element_Type'(New_Item);\n+                     J := J + 1;\n+                  end loop;\n                exception\n                   when others =>\n-                     E (J .. Index_Type'Pred (Index)) := (others => null);\n+                     E (J .. Index - 1) := (others => null);\n                      raise;\n                end;\n-            end loop;\n+\n+            else\n+               for J in Before .. New_Last loop\n+                  E (J) := new Element_Type'(New_Item);\n+                  Container.Last := J;\n+               end loop;\n+            end if;\n          end;\n \n          return;\n       end if;\n \n       declare\n-         First : constant Int := Int (Index_Type'First);\n-\n+         First    : constant Int := Int (Index_Type'First);\n          New_Size : constant Int'Base := New_Last_As_Int - First + 1;\n-         Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n-\n-         Size, Dst_Last_As_Int : Int'Base;\n+         Size     : Int'Base := Int'Max (1, Container.Elements'Length);\n \n       begin\n-         if New_Size >= Max_Size / 2 then\n-            Dst_Last := Index_Type'Last;\n+         while Size < New_Size loop\n+            if Size > Int'Last / 2 then\n+               Size := Int'Last;\n+               exit;\n+            end if;\n \n-         else\n-            Size := Container.Elements'Length;\n+            Size := 2 * Size;\n+         end loop;\n \n-            if Size = 0 then\n-               Size := 1;\n-            end if;\n+         --  TODO: The following calculations aren't quite right, since\n+         --  there will be overflow if Index_Type'Range is very large\n+         --  (e.g. this package is instantiated with a 64-bit integer).\n+         --  END TODO.\n \n-            while Size < New_Size loop\n-               Size := 2 * Size;\n-            end loop;\n+         declare\n+            Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n+         begin\n+            if Size > Max_Size then\n+               Size := Max_Size;\n+            end if;\n+         end;\n \n-            Dst_Last_As_Int := First + Size - 1;\n-            Dst_Last := Index_Type (Dst_Last_As_Int);\n-         end if;\n+         declare\n+            Dst_Last : constant Index_Type := Index_Type (First + Size - 1);\n+         begin\n+            Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+         end;\n       end;\n \n-      Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+      if Before <= Container.Last then\n+         declare\n+            Index_As_Int : constant Int'Base :=\n+                             Index_Type'Pos (Before) + N;\n \n-      declare\n-         Src : Elements_Type renames Container.Elements.all;\n+            Index : constant Index_Type := Index_Type (Index_As_Int);\n \n-      begin\n-         Dst (Index_Type'First .. Index_Type'Pred (Before)) :=\n-           Src (Index_Type'First .. Index_Type'Pred (Before));\n+            Src : Elements_Access := Container.Elements;\n \n-         Dst (Index .. New_Last) := Src (Before .. Container.Last);\n-      end;\n+         begin\n+            Dst (Index_Type'First .. Before - 1) :=\n+              Src (Index_Type'First .. Before - 1);\n \n-      declare\n-         X : Elements_Access := Container.Elements;\n-      begin\n-         Container.Elements := Dst;\n-         Container.Last := New_Last;\n+            Dst (Index .. New_Last) := Src (Before .. Container.Last);\n \n-         Free (X);\n-      end;\n+            Container.Elements := Dst;\n+            Container.Last := New_Last;\n+            Free (Src);\n+\n+            for J in Before .. Index - 1 loop\n+               Dst (J) := new Element_Type'(New_Item);\n+            end loop;\n+         end;\n \n-      --  NOTE:\n-      --  Now do the allocation.  If the allocation fails,\n-      --  then the worst thing is that we have a few null slots.\n-      --  Our invariants are otherwise satisfied.\n-      --  END NOTE.\n+      else\n+         declare\n+            Src : Elements_Access := Container.Elements;\n \n-      for J in Before .. Index_Type'Pred (Index) loop\n-         Dst (J) := new Element_Type'(New_Item);\n-      end loop;\n+         begin\n+            Dst (Index_Type'First .. Container.Last) :=\n+              Src (Index_Type'First .. Container.Last);\n+\n+            Container.Elements := Dst;\n+            Free (Src);\n+\n+            for J in Before .. New_Last loop\n+               Dst (J) := new Element_Type'(New_Item);\n+               Container.Last := J;\n+            end loop;\n+         end;\n+      end if;\n    end Insert;\n \n    procedure Insert\n@@ -1157,79 +1208,74 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       Insert_Space (Container, Before, Count => N);\n \n-      if Container'Address = New_Item'Address then\n-         declare\n-            Dst_Last_As_Int : constant Int'Base :=\n-                                Int'Base (Before) + Int'Base (N) - 1;\n+      declare\n+         Dst_Last_As_Int : constant Int'Base :=\n+                             Int'Base (Before) + Int'Base (N) - 1;\n \n-            Dst_Last : constant Index_Type := Index_Type (Dst_Last_As_Int);\n+         Dst_Last : constant Index_Type := Index_Type (Dst_Last_As_Int);\n \n-            Dst_Index : Index_Type'Base := Index_Type'Pred (Before);\n+         Dst : Elements_Type renames\n+                 Container.Elements (Before .. Dst_Last);\n \n-            Dst : Elements_Type renames\n-                    Container.Elements (Before .. Dst_Last);\n+         Dst_Index : Index_Type'Base := Before - 1;\n \n-         begin\n+      begin\n+         if Container'Address /= New_Item'Address then\n             declare\n-               subtype Src_Index_Subtype is Index_Type'Base range\n-                 Index_Type'First .. Index_Type'Pred (Before);\n-\n                Src : Elements_Type renames\n-                       Container.Elements (Src_Index_Subtype);\n+                       New_Item.Elements (Index_Type'First .. New_Item.Last);\n \n             begin\n                for Src_Index in Src'Range loop\n-                  Dst_Index := Index_Type'Succ (Dst_Index);\n+                  Dst_Index := Dst_Index + 1;\n \n                   if Src (Src_Index) /= null then\n                      Dst (Dst_Index) := new Element_Type'(Src (Src_Index).all);\n                   end if;\n                end loop;\n             end;\n \n-            declare\n-               subtype Src_Index_Subtype is Index_Type'Base range\n-                 Index_Type'Succ (Dst_Last) .. Container.Last;\n+            return;\n+         end if;\n \n-               Src : Elements_Type renames\n-                       Container.Elements (Src_Index_Subtype);\n+         declare\n+            subtype Src_Index_Subtype is Index_Type'Base range\n+              Index_Type'First .. Before - 1;\n \n-            begin\n-               for Src_Index in Src'Range loop\n-                  Dst_Index := Index_Type'Succ (Dst_Index);\n+            Src : Elements_Type renames\n+                    Container.Elements (Src_Index_Subtype);\n \n-                  if Src (Src_Index) /= null then\n-                     Dst (Dst_Index) := new Element_Type'(Src (Src_Index).all);\n-                  end if;\n-               end loop;\n-            end;\n-         end;\n+         begin\n+            for Src_Index in Src'Range loop\n+               Dst_Index := Dst_Index + 1;\n \n-      else\n-         declare\n-            Dst_Last_As_Int : constant Int'Base :=\n-                                Int'Base (Before) + Int'Base (N) - 1;\n+               if Src (Src_Index) /= null then\n+                  Dst (Dst_Index) := new Element_Type'(Src (Src_Index).all);\n+               end if;\n+            end loop;\n+         end;\n \n-            Dst_Last : constant Index_Type := Index_Type (Dst_Last_As_Int);\n+         if Dst_Last = Container.Last then\n+            return;\n+         end if;\n \n-            Dst_Index : Index_Type'Base := Index_Type'Pred (Before);\n+         declare\n+            subtype Src_Index_Subtype is Index_Type'Base range\n+              Dst_Last + 1 .. Container.Last;\n \n             Src : Elements_Type renames\n-                    New_Item.Elements (Index_Type'First .. New_Item.Last);\n+                    Container.Elements (Src_Index_Subtype);\n \n-            Dst : Elements_Type renames\n-                    Container.Elements (Before .. Dst_Last);\n          begin\n             for Src_Index in Src'Range loop\n-               Dst_Index := Index_Type'Succ (Dst_Index);\n+               Dst_Index := Dst_Index + 1;\n \n                if Src (Src_Index) /= null then\n                   Dst (Dst_Index) := new Element_Type'(Src (Src_Index).all);\n                end if;\n             end loop;\n          end;\n-\n-      end if;\n+      end;\n    end Insert;\n \n    procedure Insert\n@@ -1253,7 +1299,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -1291,7 +1342,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -1323,7 +1379,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -1362,7 +1423,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -1386,10 +1452,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       New_Last_As_Int : Int'Base;\n       New_Last        : Index_Type;\n \n-      Index : Extended_Index;  --  TODO: see a-convec.adb.\n-\n-      Dst_Last : Index_Type;\n-      Dst      : Elements_Access;\n+      Dst : Elements_Access;\n \n    begin\n       if Before < Index_Type'First then\n@@ -1411,97 +1474,110 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       begin\n          New_Last_As_Int := Old_Last_As_Int + N;\n+\n+         if New_Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n+\n          New_Last := Index_Type (New_Last_As_Int);\n       end;\n \n       if Container.Busy > 0 then\n          raise Program_Error;\n       end if;\n \n-      declare\n-         Old_First_As_Int : constant Int := Int (Before);\n-\n-         New_First_As_Int : constant Int'Base := Old_First_As_Int + N;\n-\n-      begin\n-         Index := Extended_Index (New_First_As_Int);  --  TODO\n-      end;\n-\n       if Container.Elements = null then\n-         declare\n-            subtype Elements_Subtype is\n-              Elements_Type (Index_Type'First .. New_Last);\n-         begin\n-            Container.Elements := new Elements_Subtype;\n-            Container.Last := New_Last;\n-         end;\n+         Container.Elements :=\n+           new Elements_Type (Index_Type'First .. New_Last);\n \n+         Container.Last := New_Last;\n          return;\n       end if;\n \n       if New_Last <= Container.Elements'Last then\n          declare\n             E : Elements_Type renames Container.Elements.all;\n+\n          begin\n-            E (Index .. New_Last) := E (Before .. Container.Last);\n-            E (Before .. Index_Type'Pred (Index)) := (others => null);\n+            if Before <= Container.Last then\n+               declare\n+                  Index_As_Int : constant Int'Base :=\n+                                   Index_Type'Pos (Before) + N;\n \n-            Container.Last := New_Last;\n+                  Index : constant Index_Type := Index_Type (Index_As_Int);\n+\n+               begin\n+                  E (Index .. New_Last) := E (Before .. Container.Last);\n+                  E (Before .. Index - 1) := (others => null);\n+               end;\n+            end if;\n          end;\n \n+         Container.Last := New_Last;\n          return;\n       end if;\n \n       declare\n-         First : constant Int := Int (Index_Type'First);\n-\n-         New_Size : constant Int'Base :=\n-                      Int (New_Last_As_Int) - First + 1;\n-\n-         Max_Size : constant Int'Base :=\n-                      Int (Index_Type'Last) - First + 1;\n-\n-         Size, Dst_Last_As_Int : Int'Base;\n+         First    : constant Int := Int (Index_Type'First);\n+         New_Size : constant Int'Base := New_Last_As_Int - First + 1;\n+         Size     : Int'Base := Int'Max (1, Container.Elements'Length);\n \n       begin\n-         if New_Size >= Max_Size / 2 then\n-            Dst_Last := Index_Type'Last;\n+         while Size < New_Size loop\n+            if Size > Int'Last / 2 then\n+               Size := Int'Last;\n+               exit;\n+            end if;\n \n-         else\n-            Size := Container.Elements'Length;\n+            Size := 2 * Size;\n+         end loop;\n \n-            if Size = 0 then\n-               Size := 1;\n-            end if;\n+         --  TODO: The following calculations aren't quite right, since\n+         --  there will be overflow if Index_Type'Range is very large\n+         --  (e.g. this package is instantiated with a 64-bit integer).\n+         --  END TODO.\n \n-            while Size < New_Size loop\n-               Size := 2 * Size;\n-            end loop;\n+         declare\n+            Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n+         begin\n+            if Size > Max_Size then\n+               Size := Max_Size;\n+            end if;\n+         end;\n \n-            Dst_Last_As_Int := First + Size - 1;\n-            Dst_Last := Index_Type (Dst_Last_As_Int);\n-         end if;\n+         declare\n+            Dst_Last : constant Index_Type := Index_Type (First + Size - 1);\n+         begin\n+            Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+         end;\n       end;\n \n-      Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n-\n       declare\n-         Src : Elements_Type renames Container.Elements.all;\n+         Src : Elements_Access := Container.Elements;\n \n       begin\n-         Dst (Index_Type'First .. Index_Type'Pred (Before)) :=\n-           Src (Index_Type'First .. Index_Type'Pred (Before));\n+         if Before <= Container.Last then\n+            declare\n+               Index_As_Int : constant Int'Base :=\n+                                Index_Type'Pos (Before) + N;\n \n-         Dst (Index .. New_Last) := Src (Before .. Container.Last);\n-      end;\n+               Index : constant Index_Type := Index_Type (Index_As_Int);\n+\n+            begin\n+               Dst (Index_Type'First .. Before - 1) :=\n+                 Src (Index_Type'First .. Before - 1);\n+\n+               Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+            end;\n+\n+         else\n+            Dst (Index_Type'First .. Container.Last) :=\n+              Src (Index_Type'First .. Container.Last);\n+         end if;\n \n-      declare\n-         X : Elements_Access := Container.Elements;\n-      begin\n          Container.Elements := Dst;\n          Container.Last := New_Last;\n-\n-         Free (X);\n+         Free (Src);\n       end;\n    end Insert_Space;\n \n@@ -1535,7 +1611,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -1620,7 +1701,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       L : constant Int := Int (Container.Last);\n       F : constant Int := Int (Index_Type'First);\n       N : constant Int'Base := L - F + 1;\n+\n    begin\n+      if N > Count_Type'Pos (Count_Type'Last) then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Count_Type (N);\n    end Length;\n \n@@ -1644,16 +1730,13 @@ package body Ada.Containers.Indefinite_Vectors is\n       Clear (Target);\n \n       declare\n-         X : Elements_Access := Target.Elements;\n+         Target_Elements : constant Elements_Access := Target.Elements;\n       begin\n-         Target.Elements := null;\n-         Free (X);\n+         Target.Elements := Source.Elements;\n+         Source.Elements := Target_Elements;\n       end;\n \n-      Target.Elements := Source.Elements;\n       Target.Last := Source.Last;\n-\n-      Source.Elements := null;\n       Source.Last := No_Index;\n    end Move;\n \n@@ -1668,7 +1751,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Position.Index < Position.Container.Last then\n-         return (Position.Container, Index_Type'Succ (Position.Index));\n+         return (Position.Container, Position.Index + 1);\n       end if;\n \n       return No_Element;\n@@ -1685,7 +1768,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Position.Index < Position.Container.Last then\n-         Position.Index := Index_Type'Succ (Position.Index);\n+         Position.Index := Position.Index + 1;\n       else\n          Position := No_Element;\n       end if;\n@@ -1723,7 +1806,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Position.Index > Index_Type'First then\n-         Position.Index := Index_Type'Pred (Position.Index);\n+         Position.Index := Position.Index - 1;\n       else\n          Position := No_Element;\n       end if;\n@@ -1736,7 +1819,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Position.Index > Index_Type'First then\n-         return (Position.Container, Index_Type'Pred (Position.Index));\n+         return (Position.Container, Position.Index - 1);\n       end if;\n \n       return No_Element;\n@@ -1751,21 +1834,20 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in Element_Type))\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n-\n-      E : Element_Type renames Container.Elements (T'(Index)).all;\n-\n       V : Vector renames Container'Unrestricted_Access.all;\n       B : Natural renames V.Busy;\n       L : Natural renames V.Lock;\n \n    begin\n+      if Index > Container.Last then\n+         raise Constraint_Error;\n+      end if;\n+\n       B := B + 1;\n       L := L + 1;\n \n       begin\n-         Process (E);\n+         Process (V.Elements (Index).all);\n       exception\n          when others =>\n             L := L - 1;\n@@ -1782,6 +1864,10 @@ package body Ada.Containers.Indefinite_Vectors is\n       Process  : not null access procedure (Element : in Element_Type))\n    is\n    begin\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       Query_Element (Position.Container.all, Position.Index, Process);\n    end Query_Element;\n \n@@ -1808,7 +1894,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       for J in Count_Type range 1 .. Length loop\n-         Last := Index_Type'Succ (Last);\n+         Last := Last + 1;\n \n          Boolean'Read (Stream, B);\n \n@@ -1830,22 +1916,29 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index     : Index_Type;\n       By        : Element_Type)\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n-\n-      X : Element_Access := Container.Elements (T'(Index));\n-\n    begin\n+      if Index > Container.Last then\n+         raise Constraint_Error;\n+      end if;\n+\n       if Container.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n-      Container.Elements (T'(Index)) := new Element_Type'(By);\n-      Free (X);\n+      declare\n+         X : Element_Access := Container.Elements (Index);\n+      begin\n+         Container.Elements (Index) := new Element_Type'(By);\n+         Free (X);\n+      end;\n    end Replace_Element;\n \n    procedure Replace_Element (Position : Cursor; By : Element_Type) is\n    begin\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       Replace_Element (Position.Container.all, Position.Index, By);\n    end Replace_Element;\n \n@@ -1885,11 +1978,11 @@ package body Ada.Containers.Indefinite_Vectors is\n                  Elements_Type (Array_Index_Subtype);\n \n                X : Elements_Access := Container.Elements;\n+\n             begin\n                Container.Elements := new Array_Subtype'(Src);\n                Free (X);\n             end;\n-\n          end if;\n \n          return;\n@@ -1900,14 +1993,20 @@ package body Ada.Containers.Indefinite_Vectors is\n             Last_As_Int : constant Int'Base :=\n                             Int (Index_Type'First) + Int (Capacity) - 1;\n \n-            Last : constant Index_Type :=\n-                     Index_Type (Last_As_Int);\n+         begin\n+            if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+               raise Constraint_Error;\n+            end if;\n \n-            subtype Array_Subtype is\n-              Elements_Type (Index_Type'First .. Last);\n+            declare\n+               Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         begin\n-            Container.Elements := new Array_Subtype;\n+               subtype Array_Subtype is\n+                 Elements_Type (Index_Type'First .. Last);\n+\n+            begin\n+               Container.Elements := new Array_Subtype;\n+            end;\n          end;\n \n          return;\n@@ -1935,7 +2034,6 @@ package body Ada.Containers.Indefinite_Vectors is\n                Container.Elements := new Array_Subtype'(Src);\n                Free (X);\n             end;\n-\n          end if;\n \n          return;\n@@ -1953,28 +2051,35 @@ package body Ada.Containers.Indefinite_Vectors is\n          Last_As_Int : constant Int'Base :=\n                          Int (Index_Type'First) + Int (Capacity) - 1;\n \n-         Last        : constant Index_Type := Index_Type (Last_As_Int);\n-\n-         subtype Array_Subtype is\n-           Elements_Type (Index_Type'First .. Last);\n-\n-         X : Elements_Access := Container.Elements;\n-\n       begin\n-         Container.Elements := new Array_Subtype;\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n          declare\n-            Src : Elements_Type renames\n-                    X (Index_Type'First .. Container.Last);\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            Tgt : Elements_Type renames\n-                    Container.Elements (Index_Type'First .. Container.Last);\n+            subtype Array_Subtype is\n+              Elements_Type (Index_Type'First .. Last);\n+\n+            X : Elements_Access := Container.Elements;\n \n          begin\n-            Tgt := Src;\n-         end;\n+            Container.Elements := new Array_Subtype;\n \n-         Free (X);\n+            declare\n+               Src : Elements_Type renames\n+                       X (Index_Type'First .. Container.Last);\n+\n+               Tgt : Elements_Type renames\n+                       Container.Elements (Index_Type'First .. Container.Last);\n+\n+            begin\n+               Tgt := Src;\n+            end;\n+\n+            Free (X);\n+         end;\n       end;\n    end Reserve_Capacity;\n \n@@ -2087,42 +2192,36 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      if Length = 0 then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n       if Container.Busy > 0 then\n          raise Program_Error;\n       end if;\n \n-      declare\n-         Last_As_Int : constant Int'Base :=\n-                         Int (Index_Type'First) + Int (Length) - 1;\n-\n-         Last        : constant Index_Type :=\n-                         Index_Type (Last_As_Int);\n-\n-      begin\n-         if Length > N then\n-            if Length > Capacity (Container) then\n-               Reserve_Capacity (Container, Capacity => Length);\n-            end if;\n-\n-            Container.Last := Last;\n-            return;\n-         end if;\n-\n-         for Indx in reverse Index_Type'Succ (Last) .. Container.Last loop\n+      if Length < N then\n+         for Index in 1 .. N - Length loop\n             declare\n-               X : Element_Access := Container.Elements (Indx);\n+               J : constant Index_Type := Container.Last;\n+               X : Element_Access := Container.Elements (J);\n \n             begin\n-               Container.Elements (Indx) := null;\n-               Container.Last := Index_Type'Pred (Container.Last);\n+               Container.Elements (J) := null;\n+               Container.Last := J - 1;\n                Free (X);\n             end;\n          end loop;\n+\n+         return;\n+      end if;\n+\n+      if Length > Capacity (Container) then\n+         Reserve_Capacity (Container, Capacity => Length);\n+      end if;\n+\n+      declare\n+         Last_As_Int : constant Int'Base :=\n+                         Int (Index_Type'First) + Int (Length) - 1;\n+\n+      begin\n+         Container.Last := Index_Type (Last_As_Int);\n       end;\n    end Set_Length;\n \n@@ -2134,19 +2233,27 @@ package body Ada.Containers.Indefinite_Vectors is\n      (Container : Vector;\n       I, J      : Index_Type)\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n+   begin\n+      if I > Container.Last\n+        or else J > Container.Last\n+      then\n+         raise Constraint_Error;\n+      end if;\n \n-      EI : Element_Type renames Container.Elements (T'(I)).all;\n-      EJ : Element_Type renames Container.Elements (T'(J)).all;\n+      if I = J then\n+         return;\n+      end if;\n \n-   begin\n       if Container.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n       declare\n-         EI_Copy : constant Element_Type := EI;\n+         EI : Element_Access renames Container.Elements (I);\n+         EJ : Element_Access renames Container.Elements (J);\n+\n+         EI_Copy : constant Element_Access := EI;\n+\n       begin\n          EI := EJ;\n          EJ := EI_Copy;\n@@ -2215,10 +2322,17 @@ package body Ada.Containers.Indefinite_Vectors is\n       declare\n          First       : constant Int := Int (Index_Type'First);\n          Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : constant Index_Type := Index_Type (Last_As_Int);\n-         Elements    : constant Elements_Access :=\n-                         new Elements_Type (Index_Type'First .. Last);\n+         Last        : Index_Type;\n+         Elements    : Elements_Access;\n+\n       begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Last := Index_Type (Last_As_Int);\n+         Elements := new Elements_Type (Index_Type'First .. Last);\n+\n          return (Controlled with Elements, Last, 0, 0);\n       end;\n    end To_Vector;\n@@ -2235,24 +2349,34 @@ package body Ada.Containers.Indefinite_Vectors is\n       declare\n          First       : constant Int := Int (Index_Type'First);\n          Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : constant Index_Type := Index_Type (Last_As_Int);\n-         Elements    : Elements_Access :=\n-                         new Elements_Type (Index_Type'First .. Last);\n+         Last        : Index_Type'Base;\n+         Elements    : Elements_Access;\n+\n       begin\n-         for Indx in Elements'Range loop\n-            begin\n-               Elements (Indx) := new Element_Type'(New_Item);\n-            exception\n-               when others =>\n-                  for J in Index_Type'First .. Index_Type'Pred (Indx) loop\n-                     Free (Elements (J));\n-                  end loop;\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-                  Free (Elements);\n-                  raise;\n-            end;\n+         Last := Index_Type (Last_As_Int);\n+         Elements := new Elements_Type (Index_Type'First .. Last);\n \n-         end loop;\n+         Last := Index_Type'First;\n+\n+         begin\n+            loop\n+               Elements (Last) := new Element_Type'(New_Item);\n+               exit when Last = Elements'Last;\n+               Last := Last + 1;\n+            end loop;\n+         exception\n+            when others =>\n+               for J in Index_Type'First .. Last - 1 loop\n+                  Free (Elements (J));\n+               end loop;\n+\n+               Free (Elements);\n+               raise;\n+         end;\n \n          return (Controlled with Elements, Last, 0, 0);\n       end;\n@@ -2267,21 +2391,20 @@ package body Ada.Containers.Indefinite_Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n-\n-      E : Element_Type renames Container.Elements (T'(Index)).all;\n-\n       V : Vector renames Container'Unrestricted_Access.all;\n       B : Natural renames V.Busy;\n       L : Natural renames V.Lock;\n \n    begin\n+      if Index > Container.Last then\n+         raise Constraint_Error;\n+      end if;\n+\n       B := B + 1;\n       L := L + 1;\n \n       begin\n-         Process (E);\n+         Process (V.Elements (Index).all);\n       exception\n          when others =>\n             L := L - 1;\n@@ -2298,6 +2421,10 @@ package body Ada.Containers.Indefinite_Vectors is\n       Process  : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       Update_Element (Position.Container.all, Position.Index, Process);\n    end Update_Element;\n \n@@ -2327,9 +2454,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  There's another way to do this.  Instead a separate\n             --  Boolean for each element, you could write a Boolean\n             --  followed by a count of how many nulls or non-nulls\n-            --  follow in the array.  Alternately you could use a\n-            --  signed integer, and use the sign as the indicator\n-            --  of null-ness.\n+            --  follow in the array.\n \n             if E (Indx) = null then\n                Boolean'Write (Stream, False);"}, {"sha": "e2a4de9539cf1c9137938699d7f0bef3c33d0c1a", "filename": "gcc/ada/a-coinve.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43d5ef7b552483264f6af5a831bdef1d1cd55cb/gcc%2Fada%2Fa-coinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43d5ef7b552483264f6af5a831bdef1d1cd55cb/gcc%2Fada%2Fa-coinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.ads?ref=d43d5ef7b552483264f6af5a831bdef1d1cd55cb", "patch": "@@ -48,8 +48,7 @@ pragma Preelaborate (Indefinite_Vectors);\n \n    subtype Extended_Index is Index_Type'Base\n      range Index_Type'First - 1 ..\n-            Index_Type'Last +\n-            Boolean'Pos (Index_Type'Base'Last > Index_Type'Last);\n+           Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n "}, {"sha": "9c4e76a02b3cea4910340eb543c9657399ae3d50", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43d5ef7b552483264f6af5a831bdef1d1cd55cb/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43d5ef7b552483264f6af5a831bdef1d1cd55cb/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=d43d5ef7b552483264f6af5a831bdef1d1cd55cb", "patch": "@@ -46,8 +46,7 @@ pragma Preelaborate (Vectors);\n \n    subtype Extended_Index is Index_Type'Base\n      range Index_Type'First - 1 ..\n-           Index_Type'Last +\n-              Boolean'Pos (Index_Type'Base'Last > Index_Type'Last);\n+           Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n "}]}