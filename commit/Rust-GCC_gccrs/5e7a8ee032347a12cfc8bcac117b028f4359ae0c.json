{"sha": "5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU3YThlZTAzMjM0N2ExMmNmYzhiY2FjMTE3YjAyOGY0MzU5YWUwYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-18T11:43:45Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-18T11:43:45Z"}, "message": "s390.c: Follow spelling convention.\n\n\t* config/s390/s390.c: Follow spelling convention.\n\t* config/sh/lib1funcs.asm: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/sh/sh.h: Likewise.\n\t* config/sparc/sparc.c: Likewise.\n\t* config/sparc/sparc.h: Likewise.\n\t* config/sparc/sparc.md: Likewise.\n\t* config/stormy16/stormy16.c: Likewise.\n\t* config/stormy16/stormy16.h: Likewise.\n\t* config/v850/v850.c: Likewise.\n\t* config/v850/v850.h: Likewise.\n\t* config/vax/vax.c: Likewise.\n\t* config/vax/vax.h: Likewise.\n\nFrom-SVN: r57276", "tree": {"sha": "dbbc439fc42504750f53ed2a6d46af05dd6eee4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbbc439fc42504750f53ed2a6d46af05dd6eee4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/comments", "author": null, "committer": null, "parents": [{"sha": "a2f2457fa482356b5996a084d037d79fdc1a556f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f2457fa482356b5996a084d037d79fdc1a556f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2f2457fa482356b5996a084d037d79fdc1a556f"}], "stats": {"total": 128, "additions": 72, "deletions": 56}, "files": [{"sha": "fcf11dd27d0c2e0218d564edf3f6e18511b3c855", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -1,3 +1,19 @@\n+2002-09-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/s390/s390.c: Follow spelling convention.\n+\t* config/sh/lib1funcs.asm: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/sh/sh.h: Likewise.\n+\t* config/sparc/sparc.c: Likewise.\n+\t* config/sparc/sparc.h: Likewise.\n+\t* config/sparc/sparc.md: Likewise.\n+\t* config/stormy16/stormy16.c: Likewise.\n+\t* config/stormy16/stormy16.h: Likewise.\n+\t* config/v850/v850.c: Likewise.\n+\t* config/v850/v850.h: Likewise.\n+\t* config/vax/vax.c: Likewise.\n+\t* config/vax/vax.h: Likewise.\n+\n 2002-09-18  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rs60000/rs6000.c (rs6000_emit_move): Handle V1DImode moves."}, {"sha": "877014d5e6c6159064502a8cb1e6dbcf0a1dcb01", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -797,7 +797,7 @@ s390_extract_qi (op, mode, part)\n    LEVEL is the optimization level specified; 2 if `-O2' is\n    specified, 1 if `-O' is specified, and 0 if neither is specified.\n \n-   SIZE is non-zero if `-Os' is specified and zero otherwise.  */\n+   SIZE is nonzero if `-Os' is specified and zero otherwise.  */\n \n void\n optimization_options (level, size)"}, {"sha": "f37b54372931de77747e2fd8ecfb04ca808ae1f7", "filename": "gcc/config/sh/lib1funcs.asm", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flib1funcs.asm?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -1607,10 +1607,10 @@ LOCAL(no_lo_adj):\n    would require a lot of instructions to do the shifts just right.  Using\n    the full 64 bit shift result to multiply with the divisor would require\n    four extra instructions for the upper 32 bits (shift / mulu / shift / sub).\n-   Fortunately, if the upper 32 bits of the shift result are non-zero, we\n+   Fortunately, if the upper 32 bits of the shift result are nonzero, we\n    know that the rest after taking this partial result into account will\n    fit into 32 bits.  So we just clear the upper 32 bits of the rest if the\n-   upper 32 bits of the partial result are non-zero.  */\n+   upper 32 bits of the partial result are nonzero.  */\n #endif /* __SHMEDIA__ */\n #endif /* L_udivdi3 */\n \n@@ -1755,10 +1755,10 @@ LOCAL(no_lo_adj):\n    would require a lot of instructions to do the shifts just right.  Using\n    the full 64 bit shift result to multiply with the divisor would require\n    four extra instructions for the upper 32 bits (shift / mulu / shift / sub).\n-   Fortunately, if the upper 32 bits of the shift result are non-zero, we\n+   Fortunately, if the upper 32 bits of the shift result are nonzero, we\n    know that the rest after taking this partial result into account will\n    fit into 32 bits.  So we just clear the upper 32 bits of the rest if the\n-   upper 32 bits of the partial result are non-zero.  */\n+   upper 32 bits of the partial result are nonzero.  */\n #endif /* __SHMEDIA__ */\n #endif /* L_umoddi3 */\n "}, {"sha": "3521c4711b1857fa770b76b490c9320edd7060bb", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -2508,7 +2508,7 @@ dump_table (scan)\n   pool_window_last = 0;\n }\n \n-/* Return non-zero if constant would be an ok source for a\n+/* Return nonzero if constant would be an ok source for a\n    mov.w instead of a mov.l.  */\n \n static int\n@@ -2520,7 +2520,7 @@ hi_const (src)\n \t  && INTVAL (src) <= 32767);\n }\n \n-/* Non-zero if the insn is a move instruction which needs to be fixed.  */\n+/* Nonzero if the insn is a move instruction which needs to be fixed.  */\n \n /* ??? For a DImode/DFmode moves, we don't need to fix it if each half of the\n    CONST_DOUBLE input value is CONST_OK_FOR_I.  For a SFmode move, we don't\n@@ -6429,7 +6429,7 @@ branch_dest (branch)\n   return INSN_ADDRESSES (dest_uid);\n }\n \f\n-/* Return non-zero if REG is not used after INSN.\n+/* Return nonzero if REG is not used after INSN.\n    We assume REG is a reload reg, and therefore does\n    not live past labels.  It may live past calls or jumps though.  */\n int\n@@ -6971,7 +6971,7 @@ sh_can_redirect_branch (branch1, branch2)\n   return 0;\n }\n \n-/* Return non-zero if register old_reg can be renamed to register new_reg.  */\n+/* Return nonzero if register old_reg can be renamed to register new_reg.  */\n int\n sh_hard_regno_rename_ok (old_reg, new_reg)\n      unsigned int old_reg ATTRIBUTE_UNUSED;"}, {"sha": "a06984fadfe529dcabb8b9ced88528597179a97e", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -1528,7 +1528,7 @@ enum sh_arg_class { SH_ARG_INT = 0, SH_ARG_FLOAT = 1 };\n struct sh_args {\n     int arg_count[2];\n     int force_mem;\n-  /* Non-zero if a prototype is available for the function.  */\n+  /* Nonzero if a prototype is available for the function.  */\n     int prototype_p;\n   /* The number of an odd floating-point register, that should be used\n      for the next argument of type float.  */"}, {"sha": "11ee0603c76ff1940e0ea3cc06a8f4ded5a58b56", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -455,7 +455,7 @@ v9_regcmp_p (code)\n \f\n /* Operand constraints.  */\n \n-/* Return non-zero only if OP is a register of mode MODE,\n+/* Return nonzero only if OP is a register of mode MODE,\n    or const0_rtx.  */\n \n int\n@@ -476,7 +476,7 @@ reg_or_0_operand (op, mode)\n   return 0;\n }\n \n-/* Return non-zero only if OP is const1_rtx.  */\n+/* Return nonzero only if OP is const1_rtx.  */\n \n int\n const1_operand (op, mode)\n@@ -3074,7 +3074,7 @@ short_branch (uid1, uid2)\n   return 0;\n }\n \n-/* Return non-zero if REG is not used after INSN.\n+/* Return nonzero if REG is not used after INSN.\n    We assume REG is a reload reg, and therefore does\n    not live past labels or calls or jumps.  */\n int\n@@ -5370,11 +5370,11 @@ sparc_va_arg (valist, type)\n    XEXP (OP, 0) is assumed to be a condition code register (integer or\n    floating point) and its mode specifies what kind of comparison we made.\n \n-   REVERSED is non-zero if we should reverse the sense of the comparison.\n+   REVERSED is nonzero if we should reverse the sense of the comparison.\n \n-   ANNUL is non-zero if we should generate an annulling branch.\n+   ANNUL is nonzero if we should generate an annulling branch.\n \n-   NOOP is non-zero if we have to follow this branch by a noop.\n+   NOOP is nonzero if we have to follow this branch by a noop.\n \n    INSN, if set, is the insn.  */\n \n@@ -5803,11 +5803,11 @@ sparc_emit_floatunsdi (operands)\n    operand number of the reg.  OP is the conditional expression.  The mode\n    of REG says what kind of comparison we made.\n \n-   REVERSED is non-zero if we should reverse the sense of the comparison.\n+   REVERSED is nonzero if we should reverse the sense of the comparison.\n \n-   ANNUL is non-zero if we should generate an annulling branch.\n+   ANNUL is nonzero if we should generate an annulling branch.\n \n-   NOOP is non-zero if we have to follow this branch by a noop.  */\n+   NOOP is nonzero if we have to follow this branch by a noop.  */\n \n char *\n output_v9branch (op, dest, reg, label, reversed, annul, noop, insn)"}, {"sha": "313da6e8e549938e61875f93955510fc017a2f8a", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -411,7 +411,7 @@ extern int target_flags;\n #define MASK_V9 0x40\n #define TARGET_V9 (target_flags & MASK_V9)\n \n-/* Non-zero to generate code that uses the instructions deprecated in\n+/* Nonzero to generate code that uses the instructions deprecated in\n    the v9 architecture.  This option only applies to v9 systems.  */\n /* ??? This isn't user selectable yet.  It's used to enable such insns\n    on 32 bit v9 systems and for the moment they're permanently disabled\n@@ -423,7 +423,7 @@ extern int target_flags;\n #define MASK_ISA \\\n (MASK_V8 + MASK_SPARCLITE + MASK_SPARCLET + MASK_V9 + MASK_DEPRECATED_V8_INSNS)\n \n-/* Non-zero means don't pass `-assert pure-text' to the linker.  */\n+/* Nonzero means don't pass `-assert pure-text' to the linker.  */\n #define MASK_IMPURE_TEXT 0x100\n #define TARGET_IMPURE_TEXT (target_flags & MASK_IMPURE_TEXT)\n \n@@ -446,7 +446,7 @@ extern int target_flags;\n #define MASK_HARD_QUAD 0x800\n #define TARGET_HARD_QUAD (target_flags & MASK_HARD_QUAD)\n \n-/* Non-zero on little-endian machines.  */\n+/* Nonzero on little-endian machines.  */\n /* ??? Little endian support currently only exists for sparclet-aout and\n    sparc64-elf configurations.  May eventually want to expand the support\n    to all targets, but for now it's kept local to only those two.  */\n@@ -467,14 +467,14 @@ extern int target_flags;\n \n /* 0x20000,0x40000 unused */\n \n-/* Non-zero means use a stack bias of 2047.  Stack offsets are obtained by\n+/* Nonzero means use a stack bias of 2047.  Stack offsets are obtained by\n    adding 2047 to %sp.  This option is for v9 only and is the default.  */\n #define MASK_STACK_BIAS 0x80000\n #define TARGET_STACK_BIAS (target_flags & MASK_STACK_BIAS)\n \n /* 0x100000,0x200000 unused */\n \n-/* Non-zero means -m{,no-}fpu was passed on the command line.  */\n+/* Nonzero means -m{,no-}fpu was passed on the command line.  */\n #define MASK_FPU_SET 0x400000\n #define TARGET_FPU_SET (target_flags & MASK_FPU_SET)\n \n@@ -948,7 +948,7 @@ do\t\t\t\t\t\t\t\t\\\n \tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     /* If the user has passed -f{fixed,call-{used,saved}}-g5 */\t\\\n-    /* then honour it.  */\t\t\t\t\t\\\n+    /* then honor it.  */\t\t\t\t\t\\\n     if (TARGET_ARCH32 && fixed_regs[5])\t\t\t\t\\\n       fixed_regs[5] = 1;\t\t\t\t\t\\\n     else if (TARGET_ARCH64 && fixed_regs[5] == 2)\t\t\\\n@@ -973,7 +973,7 @@ do\t\t\t\t\t\t\t\t\\\n \t  fixed_regs[regno] = 1;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     /* If the user has passed -f{fixed,call-{used,saved}}-g2 */\t\\\n-    /* then honour it.  Likewise with g3 and g4.  */\t\t\\\n+    /* then honor it.  Likewise with g3 and g4.  */\t\t\\\n     if (fixed_regs[2] == 2)\t\t\t\t\t\\\n       fixed_regs[2] = ! TARGET_APP_REGS;\t\t\t\\\n     if (fixed_regs[3] == 2)\t\t\t\t\t\\\n@@ -1723,8 +1723,8 @@ extern char leaf_reg_remap[];\n \n struct sparc_args {\n   int words;       /* number of words passed so far */\n-  int prototype_p; /* non-zero if a prototype is present */\n-  int libcall_p;   /* non-zero if a library call */\n+  int prototype_p; /* nonzero if a prototype is present */\n+  int libcall_p;   /* nonzero if a library call */\n };\n #define CUMULATIVE_ARGS struct sparc_args\n \n@@ -2493,7 +2493,7 @@ do {                                                                    \\\n    processing is needed.  */\n #define SELECT_CC_MODE(OP,X,Y)  select_cc_mode ((OP), (X), (Y))\n \n-/* Return non-zero if MODE implies a floating point inequality can be\n+/* Return nonzero if MODE implies a floating point inequality can be\n    reversed.  For SPARC this is always true because we have a full\n    compliment of ordered and unordered comparisons, but until generic\n    code knows how to reverse it correctly we keep the old definition.  */"}, {"sha": "27f86f7c448dd47b16d983fff59b0280252fc137", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -3462,7 +3462,7 @@\n ;; SPARC V9 conditional move instructions.\n \n ;; We can handle larger constants here for some flavors, but for now we keep\n-;; it simple and only allow those constants supported by all flavours.\n+;; it simple and only allow those constants supported by all flavors.\n ;; Note that emit_conditional_move canonicalizes operands 2,3 so that operand\n ;; 3 contains the constant if one is present, but we handle either for\n ;; generality (sparc.c puts a constant in operand 2)."}, {"sha": "62b8656730d99892c2e14cd252456e14f5593694", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -254,7 +254,7 @@ xstormy16_split_cbranch (mode, label, comparison, dest, carry)\n \n    OP is the conditional expression, or NULL for branch-always.\n \n-   REVERSED is non-zero if we should reverse the sense of the comparison.\n+   REVERSED is nonzero if we should reverse the sense of the comparison.\n \n    INSN is the insn.  */\n \n@@ -331,7 +331,7 @@ xstormy16_output_cbranch_hi (op, label, reversed, insn)\n \n    OP is the conditional expression (OP is never NULL_RTX).\n \n-   REVERSED is non-zero if we should reverse the sense of the comparison.\n+   REVERSED is nonzero if we should reverse the sense of the comparison.\n \n    INSN is the insn.  */\n \n@@ -1170,7 +1170,7 @@ xstormy16_build_va_list ()\n   return record;\n }\n \n-/* Implement the stdarg/varargs va_start macro.  STDARG_P is non-zero if this\n+/* Implement the stdarg/varargs va_start macro.  STDARG_P is nonzero if this\n    is stdarg.h instead of varargs.h.  VALIST is the tree of the va_list\n    variable to initialize.  NEXTARG is the machine independent notion of the\n    'next' argument after the variable arguments.  */"}, {"sha": "f9ed30a90ab8b01cd2a9b014b2e1ebafe25bb1f6", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -632,7 +632,7 @@ enum reg_class\n \n /* Certain machines have the property that some registers cannot be copied to\n    some other registers without using memory.  Define this macro on those\n-   machines to be a C expression that is non-zero if objects of mode M in\n+   machines to be a C expression that is nonzero if objects of mode M in\n    registers of CLASS1 can only be copied to registers of class CLASS2 by\n    storing a register of CLASS1 into memory and loading that memory location\n    into a register of CLASS2.\n@@ -675,15 +675,15 @@ enum reg_class\n    few registers of certain classes that there would not be enough registers to\n    use as spill registers if this were done.\n \n-   Define `SMALL_REGISTER_CLASSES' to be an expression with a non-zero value on\n-   these machines.  When this macro has a non-zero value, the compiler allows\n+   Define `SMALL_REGISTER_CLASSES' to be an expression with a nonzero value on\n+   these machines.  When this macro has a nonzero value, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers but\n    avoids extending the lifetime of these registers.\n \n-   It is always safe to define this macro with a non-zero value, but if you\n+   It is always safe to define this macro with a nonzero value, but if you\n    unnecessarily define it, you will reduce the amount of optimizations that\n    can be performed in some cases.  If you do not define this macro with a\n-   non-zero value when it is required, the compiler will run out of spill\n+   nonzero value when it is required, the compiler will run out of spill\n    registers and print a fatal error message.  For most machines, you should\n    not define this macro at all.  */\n /* #define SMALL_REGISTER_CLASSES */\n@@ -1062,7 +1062,7 @@ enum reg_class\n   {ARG_POINTER_REGNUM,\t HARD_FRAME_POINTER_REGNUM},\t\\\n }\n \n-/* A C expression that returns non-zero if the compiler is allowed to try to\n+/* A C expression that returns nonzero if the compiler is allowed to try to\n    replace register number FROM with register number TO.  This macro need only\n    be defined if `ELIMINABLE_REGS' is defined, and will usually be the constant\n    1, since most of the cases preventing register elimination are things that\n@@ -1242,7 +1242,7 @@ enum reg_class\n    You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n    this macro to determine if this argument is of a type that must be passed in\n    the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns non-zero for such an argument, the compiler will abort.  If\n+   returns nonzero for such an argument, the compiler will abort.  If\n    `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n    stack and then loaded into a register.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t  \\\n@@ -1724,7 +1724,7 @@ enum reg_class\n #define BUILD_VA_LIST_TYPE(NODE) \\\n   ((NODE) = xstormy16_build_va_list ())\n \n-/* Implement the stdarg/varargs va_start macro.  STDARG_P is non-zero if this\n+/* Implement the stdarg/varargs va_start macro.  STDARG_P is nonzero if this\n    is stdarg.h instead of varargs.h.  VALIST is the tree of the va_list\n    variable to initialize.  NEXTARG is the machine independent notion of the\n    'next' argument after the variable arguments.  If not defined, a standard\n@@ -2368,10 +2368,10 @@ do {\t\t\t\t\t\t\t\\\n    times greater than aligned accesses, for example if they are emulated in a\n    trap handler.\n \n-   When this macro is non-zero, the compiler will act as if `STRICT_ALIGNMENT'\n-   were non-zero when generating code for block moves.  This can cause\n+   When this macro is nonzero, the compiler will act as if `STRICT_ALIGNMENT'\n+   were nonzero when generating code for block moves.  This can cause\n    significantly more instructions to be produced.  Therefore, do not set this\n-   macro non-zero if unaligned accesses only add a cycle or two to the time for\n+   macro nonzero if unaligned accesses only add a cycle or two to the time for\n    a memory access.\n \n    If the value of this macro is always zero, it need not be defined.  */\n@@ -2613,7 +2613,7 @@ do {\t\t\t\t\t\t\t\\\n /* #define ASM_OUTPUT_ASCII(STREAM, PTR, LEN) */\n \n /* You may define this macro as a C expression.  You should define the\n-   expression to have a non-zero value if GNU CC should output the\n+   expression to have a nonzero value if GNU CC should output the\n    constant pool for a function before the code for the function, or\n    a zero value if GNU CC should output the constant pool after the\n    function.  If you do not define this macro, the usual case, GNU CC\n@@ -3758,7 +3758,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* A C expression that is nonzero if on this machine the number of bits\n    actually used for the count of a shift operation is equal to the number of\n    bits needed to represent the size of the object being shifted.  When this\n-   macro is non-zero, the compiler will assume that it is safe to omit a\n+   macro is nonzero, the compiler will assume that it is safe to omit a\n    sign-extend, zero-extend, and certain bitwise `and' instructions that\n    truncates the count of a shift operation.  On machines that have\n    instructions that act on bitfields at variable positions, which may include\n@@ -3869,7 +3869,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    instructions.  */\n /* #define STORE_FLAG_VALUE */\n \n-/* A C expression that gives a non-zero floating point value that is returned\n+/* A C expression that gives a nonzero floating point value that is returned\n    when comparison operators with floating-point results are true.  Define this\n    macro on machine that have comparison operations that return floating-point\n    values.  If there are no such operations, do not define this macro.  */"}, {"sha": "b14ff1a3fc24a65a38c7241bc0dbe264197428fd", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -2368,7 +2368,7 @@ register_is_ok_for_epilogue (op, mode)\n           && (((REGNO (op) >= 20) && REGNO (op) <= 31)));\n }\n \n-/* Return non-zero if the given RTX is suitable for collapsing into\n+/* Return nonzero if the given RTX is suitable for collapsing into\n    jump to a function epilogue.  */\n int\n pattern_is_ok_for_epilogue (op, mode)\n@@ -2547,7 +2547,7 @@ construct_restore_jr (op)\n }\n \n \n-/* Return non-zero if the given RTX is suitable for collapsing into\n+/* Return nonzero if the given RTX is suitable for collapsing into\n    a jump to a function prologue.  */\n int\n pattern_is_ok_for_prologue (op, mode)\n@@ -2947,7 +2947,7 @@ v850_insert_attributes (decl, attr_ptr)\n     }\n }\n \n-/* Return non-zero if the given RTX is suitable\n+/* Return nonzero if the given RTX is suitable\n    for collapsing into a DISPOSE instruction.  */\n \n int\n@@ -3137,7 +3137,7 @@ construct_dispose_instruction (op)\n   return buff;\n }\n \n-/* Return non-zero if the given RTX is suitable\n+/* Return nonzero if the given RTX is suitable\n    for collapsing into a PREPARE instruction.  */\n \n int"}, {"sha": "9d5200b9a757f0bd7b83cf0a610c0f56fb105ddf", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -249,7 +249,7 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n    LEVEL is the optimization level specified; 2 if `-O2' is\n    specified, 1 if `-O' is specified, and 0 if neither is specified.\n \n-   SIZE is non-zero if `-Os' is specified, 0 otherwise.  \n+   SIZE is nonzero if `-Os' is specified, 0 otherwise.  \n \n    You should not use this macro to change options that are not\n    machine-specific.  These should uniformly selected by the same\n@@ -664,7 +664,7 @@ enum reg_class\n  { ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM },\t\t\t\\\n  { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}\t\t\t\\\n \n-/* A C expression that returns non-zero if the compiler is allowed to\n+/* A C expression that returns nonzero if the compiler is allowed to\n    try to replace register number FROM-REG with register number\n    TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n    defined, and will usually be the constant 1, since most of the"}, {"sha": "c00189f3a7e5b98d5a34af762fbf025c939d33be", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -318,7 +318,7 @@ print_operand_address (file, addr)\n       else\n \tabort ();\n \n-      /* If REG1 is non-zero, figure out if it is a base or index register.  */\n+      /* If REG1 is nonzero, figure out if it is a base or index register.  */\n       if (reg1)\n \t{\n \t  if (breg != 0 || (offset && GET_CODE (offset) == MEM))"}, {"sha": "e51f064c2b24756a64d29e6795d94ddfb8665de8", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7a8ee032347a12cfc8bcac117b028f4359ae0c/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=5e7a8ee032347a12cfc8bcac117b028f4359ae0c", "patch": "@@ -630,7 +630,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    || GET_CODE (X) == CONST_INT)\n \n \n-/* Non-zero if X is an address which can be indirected.  External symbols\n+/* Nonzero if X is an address which can be indirected.  External symbols\n    could be in a sharable image library, so we disallow those.  */\n \n #define INDIRECTABLE_ADDRESS_P(X)  \\\n@@ -645,7 +645,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define INDIRECTABLE_CONSTANT_ADDRESS_P(X) CONSTANT_ADDRESS_P(X)\n \n-/* Non-zero if X is an address which can be indirected.  */\n+/* Nonzero if X is an address which can be indirected.  */\n #define INDIRECTABLE_ADDRESS_P(X)  \\\n   (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n    || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\"}]}