{"sha": "d37e6b50362c82ee6bcb630a949e7e38830901ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM3ZTZiNTAzNjJjODJlZTZiY2I2MzBhOTQ5ZTdlMzg4MzA5MDFiYQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-08-09T20:19:30Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-08-09T20:19:30Z"}, "message": "ggc-common.c (ggc_rlimit_bound): Don't check RSS limit.\n\n\t* ggc-common.c (ggc_rlimit_bound): Don't check RSS limit.\n\tCheck DATA limit only if there's no AS limit.  Ignore insanely\n\tlow DATA limits.\n\t(ggc_min_heapsize_heuristic): Don't divide AS or RSS limits by 8,\n\tbut take care that the AS limit isn't overrun.\n\t* doc/invoke.texi: Update documentation of min-heapsize parameter.\n\nFrom-SVN: r85722", "tree": {"sha": "df6c93a853578b39eba773b6fd6680e05533dc64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df6c93a853578b39eba773b6fd6680e05533dc64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d37e6b50362c82ee6bcb630a949e7e38830901ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d37e6b50362c82ee6bcb630a949e7e38830901ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d37e6b50362c82ee6bcb630a949e7e38830901ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d37e6b50362c82ee6bcb630a949e7e38830901ba/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "56b043c808696e62bde8e722741432a2b3caa032", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b043c808696e62bde8e722741432a2b3caa032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b043c808696e62bde8e722741432a2b3caa032"}], "stats": {"total": 94, "additions": 63, "deletions": 31}, "files": [{"sha": "8ce8ab9705d53941928861c9d36bd3dd6dd2d923", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d37e6b50362c82ee6bcb630a949e7e38830901ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d37e6b50362c82ee6bcb630a949e7e38830901ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d37e6b50362c82ee6bcb630a949e7e38830901ba", "patch": "@@ -1,3 +1,12 @@\n+2004-08-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* ggc-common.c (ggc_rlimit_bound): Don't check RSS limit.\n+\tCheck DATA limit only if there's no AS limit.  Ignore insanely\n+\tlow DATA limits.\n+\t(ggc_min_heapsize_heuristic): Don't divide AS or RSS limits by 8,\n+\tbut take care that the AS limit isn't overrun.\n+\t* doc/invoke.texi: Update documentation of min-heapsize parameter.\n+\n 2004-08-09  Jeff Law  <law@redhat.com>\n \n \t* Makefile.in (OBJC-common): Add tree-ssa-threadupdate.c"}, {"sha": "bf41ffb426a636bfc9596e7e059eab3fee26b365", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d37e6b50362c82ee6bcb630a949e7e38830901ba/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d37e6b50362c82ee6bcb630a949e7e38830901ba/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d37e6b50362c82ee6bcb630a949e7e38830901ba", "patch": "@@ -5310,7 +5310,7 @@ generation.\n \n The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when\n RAM >= 1GB.  If @code{getrlimit} is available, the notion of \"RAM\" is\n-the smallest of actual RAM, RLIMIT_RSS, RLIMIT_DATA and RLIMIT_AS.  If\n+the smallest of actual RAM and RLIMIT_DATA or RLIMIT_AS.  If\n GCC is not able to calculate RAM on a particular platform, the lower\n bound of 30% is used.  Setting this parameter and\n @option{ggc-min-heapsize} to zero causes a full collection to occur at\n@@ -5325,14 +5325,14 @@ by @option{ggc-min-expand}% beyond @option{ggc-min-heapsize}.  Again,\n tuning this may improve compilation speed, and has no effect on code\n generation.\n \n-The default is RAM/8, with a lower bound of 4096 (four megabytes) and an\n-upper bound of 131072 (128 megabytes).  If @code{getrlimit} is\n-available, the notion of \"RAM\" is the smallest of actual RAM,\n-RLIMIT_RSS, RLIMIT_DATA and RLIMIT_AS.  If GCC is not able to calculate\n-RAM on a particular platform, the lower bound is used.  Setting this\n-parameter very large effectively disables garbage collection.  Setting\n-this parameter and @option{ggc-min-expand} to zero causes a full\n-collection to occur at every opportunity.\n+The default is the smaller of RAM/8, RLIMIT_RSS, or a limit which\n+tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but\n+with a lower bound of 4096 (four megabytes) and an upper bound of\n+131072 (128 megabytes).  If GCC is not able to calculate RAM on a\n+particular platform, the lower bound is used.  Setting this parameter\n+very large effectively disables garbage collection.  Setting this\n+parameter and @option{ggc-min-expand} to zero causes a full collection\n+to occur at every opportunity.\n \n @item max-reload-search-insns\n The maximum number of instruction reload should look backward for equivalent"}, {"sha": "5c99175d663e5bdda0bcf2293291fd674a9a955b", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d37e6b50362c82ee6bcb630a949e7e38830901ba/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d37e6b50362c82ee6bcb630a949e7e38830901ba/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=d37e6b50362c82ee6bcb630a949e7e38830901ba", "patch": "@@ -669,30 +669,34 @@ mmap_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n }\n #endif /* HAVE_MMAP_FILE */\n \n-/* Modify the bound based on rlimits.  Keep the smallest number found.  */\n+/* Modify the bound based on rlimits.  */\n static double\n ggc_rlimit_bound (double limit)\n {\n #if defined(HAVE_GETRLIMIT)\n   struct rlimit rlim;\n-# ifdef RLIMIT_RSS\n-  if (getrlimit (RLIMIT_RSS, &rlim) == 0\n+# if defined (RLIMIT_AS)\n+  /* RLIMIT_AS is what POSIX says is the limit on mmap.  Presumably\n+     any OS which has RLIMIT_AS also has a working mmap that GCC will use.  */\n+  if (getrlimit (RLIMIT_AS, &rlim) == 0\n       && rlim.rlim_cur != (rlim_t) RLIM_INFINITY\n       && rlim.rlim_cur < limit)\n     limit = rlim.rlim_cur;\n-# endif\n-# ifdef RLIMIT_DATA\n+# elif defined (RLIMIT_DATA)\n+  /* ... but some older OSs bound mmap based on RLIMIT_DATA, or we\n+     might be on an OS that has a broken mmap.  (Others don't bound\n+     mmap at all, apparently.)  */\n   if (getrlimit (RLIMIT_DATA, &rlim) == 0\n       && rlim.rlim_cur != (rlim_t) RLIM_INFINITY\n-      && rlim.rlim_cur < limit)\n-    limit = rlim.rlim_cur;\n-# endif\n-# ifdef RLIMIT_AS\n-  if (getrlimit (RLIMIT_AS, &rlim) == 0\n-      && rlim.rlim_cur != (rlim_t) RLIM_INFINITY\n-      && rlim.rlim_cur < limit)\n+      && rlim.rlim_cur < limit\n+      /* Darwin has this horribly bogus default setting of\n+\t RLIMIT_DATA, to 6144Kb.  No-one notices because RLIMIT_DATA\n+\t appears to be ignored.  Ignore such silliness.  If a limit\n+\t this small was actually effective for mmap, GCC wouldn't even\n+\t start up.  */\n+      && rlim.rlim_cur >= 8 * 1024 * 1024)\n     limit = rlim.rlim_cur;\n-# endif\n+# endif /* RLIMIT_AS or RLIMIT_DATA */\n #endif /* HAVE_GETRLIMIT */\n \n   return limit;\n@@ -721,20 +725,39 @@ ggc_min_expand_heuristic (void)\n int\n ggc_min_heapsize_heuristic (void)\n {\n-  double min_heap_kbytes = physmem_total();\n-\n-  /* Adjust for rlimits.  */\n-  min_heap_kbytes = ggc_rlimit_bound (min_heap_kbytes);\n+  double phys_kbytes = physmem_total();\n+  double limit_kbytes = ggc_rlimit_bound (phys_kbytes * 2);\n \n-  min_heap_kbytes /= 1024; /* Convert to Kbytes.  */\n+  phys_kbytes /= 1024; /* Convert to Kbytes.  */\n+  limit_kbytes /= 1024;\n \n   /* The heuristic is RAM/8, with a lower bound of 4M and an upper\n      bound of 128M (when RAM >= 1GB).  */\n-  min_heap_kbytes /= 8;\n-  min_heap_kbytes = MAX (min_heap_kbytes, 4 * 1024);\n-  min_heap_kbytes = MIN (min_heap_kbytes, 128 * 1024);\n+  phys_kbytes /= 8;\n+\n+#if defined(HAVE_GETRLIMIT) && defined (RLIMIT_RSS)\n+  /* Try not to overrun the RSS limit while doing garbage collection.  \n+     The RSS limit is only advisory, so no margin is subtracted.  */\n+ {\n+   struct rlimit rlim;\n+   if (getrlimit (RLIMIT_RSS, &rlim) == 0\n+       && rlim.rlim_cur != (rlim_t) RLIM_INFINITY)\n+     phys_kbytes = MIN (phys_kbytes, rlim.rlim_cur / 1024);\n+ }\n+# endif\n+\n+  /* Don't blindly run over our data limit; do GC at least when the\n+     *next* GC would be within 16Mb of the limit.  If GCC does hit the\n+     data limit, compilation will fail, so this tries to be\n+     conservative.  */\n+  limit_kbytes = MAX (0, limit_kbytes - 16 * 1024);\n+  limit_kbytes = (limit_kbytes * 100) / (110 + ggc_min_expand_heuristic());\n+  phys_kbytes = MIN (phys_kbytes, limit_kbytes);\n+\n+  phys_kbytes = MAX (phys_kbytes, 4 * 1024);\n+  phys_kbytes = MIN (phys_kbytes, 128 * 1024);\n \n-  return min_heap_kbytes;\n+  return phys_kbytes;\n }\n \n void"}]}