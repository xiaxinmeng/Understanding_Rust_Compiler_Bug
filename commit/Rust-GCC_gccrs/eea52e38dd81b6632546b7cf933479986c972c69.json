{"sha": "eea52e38dd81b6632546b7cf933479986c972c69", "node_id": "C_kwDOANBUbNoAKGVlYTUyZTM4ZGQ4MWI2NjMyNTQ2YjdjZjkzMzQ3OTk4NmM5NzJjNjk", "commit": {"author": {"name": "Andrew Carlotti", "email": "andrew.carlotti@arm.com", "date": "2022-10-04T17:21:57Z"}, "committer": {"name": "Andrew Carlotti", "email": "andrew.carlotti@arm.com", "date": "2022-11-21T16:00:51Z"}, "message": "Refactor number_of_iterations_popcount\n\nThis includes various changes to improve clarity, and to enable the code\nto be more similar to the clz and ctz idiom recognition added in\nsubsequent patches.\n\nWe create new number_of_iterations_bitcount function, which will be used\nto call the other bit-counting recognition functions added in subsequent\npatches, as well as a generic comment describing the loop structures\nthat are common to each idiom. Some of the variables in\nnumber_of_iterations_popcount are given more descriptive names, and the\npopcount expression builder is extracted into a separate function.\n\nAs part of the refactoring, we also fix a bug where the max loop count\nfor modes shorter than an integer would be incorrectly computed as if\nthe input mode were actually an integer.\n\nWe also ensure that niter->max takes into account the final value for\nniter->niter (after any folding and simplifying), since if the latter is a\nconstant, then record_estimate mandates that the two values are equivalent.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-loop-niter.cc\n\t(number_of_iterations_exit_assumptions): Modify to call...\n\t(number_of_iterations_bitcount): ...this new function.\n\t(number_of_iterations_popcount): Now called by the above.\n\tRefactor, and extract popcount expression builder to...\n\t(build_popcount_expr): this new function.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/popcount-max.c: New test.", "tree": {"sha": "fa24b0afe74b834c489ea624c494c64b5c663125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa24b0afe74b834c489ea624c494c64b5c663125"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eea52e38dd81b6632546b7cf933479986c972c69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea52e38dd81b6632546b7cf933479986c972c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eea52e38dd81b6632546b7cf933479986c972c69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea52e38dd81b6632546b7cf933479986c972c69/comments", "author": {"login": "andrewcarlotti", "id": 11681428, "node_id": "MDQ6VXNlcjExNjgxNDI4", "avatar_url": "https://avatars.githubusercontent.com/u/11681428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcarlotti", "html_url": "https://github.com/andrewcarlotti", "followers_url": "https://api.github.com/users/andrewcarlotti/followers", "following_url": "https://api.github.com/users/andrewcarlotti/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcarlotti/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcarlotti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcarlotti/subscriptions", "organizations_url": "https://api.github.com/users/andrewcarlotti/orgs", "repos_url": "https://api.github.com/users/andrewcarlotti/repos", "events_url": "https://api.github.com/users/andrewcarlotti/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcarlotti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andrewcarlotti", "id": 11681428, "node_id": "MDQ6VXNlcjExNjgxNDI4", "avatar_url": "https://avatars.githubusercontent.com/u/11681428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcarlotti", "html_url": "https://github.com/andrewcarlotti", "followers_url": "https://api.github.com/users/andrewcarlotti/followers", "following_url": "https://api.github.com/users/andrewcarlotti/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcarlotti/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcarlotti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcarlotti/subscriptions", "organizations_url": "https://api.github.com/users/andrewcarlotti/orgs", "repos_url": "https://api.github.com/users/andrewcarlotti/repos", "events_url": "https://api.github.com/users/andrewcarlotti/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcarlotti/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe985a236327c9d95a1b667abe7eb31afc9eb61c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe985a236327c9d95a1b667abe7eb31afc9eb61c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe985a236327c9d95a1b667abe7eb31afc9eb61c"}], "stats": {"total": 322, "additions": 191, "deletions": 131}, "files": [{"sha": "ca7204cbc3cea636183408e24d7dd36d702ffdb2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/popcount-max.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea52e38dd81b6632546b7cf933479986c972c69/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount-max.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea52e38dd81b6632546b7cf933479986c972c69/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount-max.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount-max.c?ref=eea52e38dd81b6632546b7cf933479986c972c69", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-loop-optimize -fdump-tree-optimized\" } */\n+\n+#define PREC (__CHAR_BIT__)\n+\n+int count1 (unsigned char b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb &= b - 1;\n+\tc++;\n+    }\n+    if (c <= PREC)\n+      return 0;\n+    else\n+      return 34567;\n+}\n+\n+int count2 (unsigned char b) {\n+    int c = 0;\n+\n+    while (b) {\n+\tb &= b - 1;\n+\tc++;\n+    }\n+    if (c <= PREC - 1)\n+      return 0;\n+    else\n+      return 76543;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"34567\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"76543\" 1 \"optimized\" } } */"}, {"sha": "fece876099c1687569d6351e7d2416ea6acae5b5", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 158, "deletions": 131, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea52e38dd81b6632546b7cf933479986c972c69/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea52e38dd81b6632546b7cf933479986c972c69/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=eea52e38dd81b6632546b7cf933479986c972c69", "patch": "@@ -2026,6 +2026,48 @@ number_of_iterations_cond (class loop *loop,\n   return ret;\n }\n \n+/* Return an expression that computes the popcount of src.  */\n+\n+static tree\n+build_popcount_expr (tree src)\n+{\n+  tree fn;\n+  int prec = TYPE_PRECISION (TREE_TYPE (src));\n+  int i_prec = TYPE_PRECISION (integer_type_node);\n+  int li_prec = TYPE_PRECISION (long_integer_type_node);\n+  int lli_prec = TYPE_PRECISION (long_long_integer_type_node);\n+  if (prec <= i_prec)\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNT);\n+  else if (prec == li_prec)\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTL);\n+  else if (prec == lli_prec || prec == 2 * lli_prec)\n+    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTLL);\n+  else\n+    return NULL_TREE;\n+\n+  tree utype = unsigned_type_for (TREE_TYPE (src));\n+  src = fold_convert (utype, src);\n+  if (prec < i_prec)\n+    src = fold_convert (unsigned_type_node, src);\n+  tree call;\n+  if (prec == 2 * lli_prec)\n+    {\n+      tree src1 = fold_convert (long_long_unsigned_type_node,\n+\t\t\t\tfold_build2 (RSHIFT_EXPR, TREE_TYPE (src),\n+\t\t\t\t\t     unshare_expr (src),\n+\t\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t    lli_prec)));\n+      tree src2 = fold_convert (long_long_unsigned_type_node, src);\n+      tree call1 = build_call_expr (fn, 1, src1);\n+      tree call2 = build_call_expr (fn, 1, src2);\n+      call = fold_build2 (PLUS_EXPR, integer_type_node, call1, call2);\n+    }\n+  else\n+    call = build_call_expr (fn, 1, src);\n+\n+  return call;\n+}\n+\n /* Utility function to check if OP is defined by a stmt\n    that is a val - 1.  */\n \n@@ -2041,45 +2083,18 @@ ssa_defined_by_minus_one_stmt_p (tree op, tree val)\n \t  && integer_minus_onep (gimple_assign_rhs2 (stmt)));\n }\n \n-/* See if LOOP is a popcout implementation, determine NITER for the loop\n+/* See comment below for number_of_iterations_bitcount.\n+   For popcount, we have:\n \n-   We match:\n-   <bb 2>\n-   goto <bb 4>\n+   modify:\n+   _1 = iv_1 + -1\n+   iv_2 = iv_1 & _1\n \n-   <bb 3>\n-   _1 = b_11 + -1\n-   b_6 = _1 & b_11\n-\n-   <bb 4>\n-   b_11 = PHI <b_5(D)(2), b_6(3)>\n+   test:\n+   if (iv != 0)\n \n-   exit block\n-   if (b_11 != 0)\n-\tgoto <bb 3>\n-   else\n-\tgoto <bb 5>\n-\n-   OR we match copy-header version:\n-   if (b_5 != 0)\n-\tgoto <bb 3>\n-   else\n-\tgoto <bb 4>\n-\n-   <bb 3>\n-   b_11 = PHI <b_5(2), b_6(3)>\n-   _1 = b_11 + -1\n-   b_6 = _1 & b_11\n-\n-   exit block\n-   if (b_6 != 0)\n-\tgoto <bb 3>\n-   else\n-\tgoto <bb 4>\n-\n-   If popcount pattern, update NITER accordingly.\n-   i.e., set NITER to  __builtin_popcount (b)\n-   return true if we did, false otherwise.\n+   modification count:\n+   popcount (src)\n \n  */\n \n@@ -2088,138 +2103,150 @@ number_of_iterations_popcount (loop_p loop, edge exit,\n \t\t\t       enum tree_code code,\n \t\t\t       class tree_niter_desc *niter)\n {\n-  bool adjust = true;\n-  tree iter;\n+  bool modify_before_test = true;\n   HOST_WIDE_INT max;\n-  adjust = true;\n-  tree fn = NULL_TREE;\n-\n-  /* Check loop terminating branch is like\n-     if (b != 0).  */\n-  gimple *stmt = last_stmt (exit->src);\n-  if (!stmt\n-      || gimple_code (stmt) != GIMPLE_COND\n+\n+  /* Check that condition for staying inside the loop is like\n+     if (iv != 0).  */\n+  gimple *cond_stmt = last_stmt (exit->src);\n+  if (!cond_stmt\n+      || gimple_code (cond_stmt) != GIMPLE_COND\n       || code != NE_EXPR\n-      || !integer_zerop (gimple_cond_rhs (stmt))\n-      || TREE_CODE (gimple_cond_lhs (stmt)) != SSA_NAME)\n+      || !integer_zerop (gimple_cond_rhs (cond_stmt))\n+      || TREE_CODE (gimple_cond_lhs (cond_stmt)) != SSA_NAME)\n     return false;\n \n-  gimple *and_stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (stmt));\n+  tree iv_2 = gimple_cond_lhs (cond_stmt);\n+  gimple *iv_2_stmt = SSA_NAME_DEF_STMT (iv_2);\n \n-  /* Depending on copy-header is performed, feeding PHI stmts might be in\n-     the loop header or loop latch, handle this.  */\n-  if (gimple_code (and_stmt) == GIMPLE_PHI\n-      && gimple_bb (and_stmt) == loop->header\n-      && gimple_phi_num_args (and_stmt) == 2\n-      && (TREE_CODE (gimple_phi_arg_def (and_stmt,\n+  /* If the test comes before the iv modification, then these will actually be\n+     iv_1 and a phi node.  */\n+  if (gimple_code (iv_2_stmt) == GIMPLE_PHI\n+      && gimple_bb (iv_2_stmt) == loop->header\n+      && gimple_phi_num_args (iv_2_stmt) == 2\n+      && (TREE_CODE (gimple_phi_arg_def (iv_2_stmt,\n \t\t\t\t\t loop_latch_edge (loop)->dest_idx))\n \t  == SSA_NAME))\n     {\n-      /* SSA used in exit condition is defined by PHI stmt\n-\tb_11 = PHI <b_5(D)(2), b_6(3)>\n-\tfrom the PHI stmt, get the and_stmt\n-\tb_6 = _1 & b_11.  */\n-      tree t = gimple_phi_arg_def (and_stmt, loop_latch_edge (loop)->dest_idx);\n-      and_stmt = SSA_NAME_DEF_STMT (t);\n-      adjust = false;\n+      /* iv_2 is actually one of the inputs to the phi.  */\n+      iv_2 = gimple_phi_arg_def (iv_2_stmt, loop_latch_edge (loop)->dest_idx);\n+      iv_2_stmt = SSA_NAME_DEF_STMT (iv_2);\n+      modify_before_test = false;\n     }\n \n-  /* Make sure it is indeed an and stmt (b_6 = _1 & b_11).  */\n-  if (!is_gimple_assign (and_stmt)\n-      || gimple_assign_rhs_code (and_stmt) != BIT_AND_EXPR)\n+  /* Make sure iv_2_stmt is an and stmt (iv_2 = _1 & iv_1).  */\n+  if (!is_gimple_assign (iv_2_stmt)\n+      || gimple_assign_rhs_code (iv_2_stmt) != BIT_AND_EXPR)\n     return false;\n \n-  tree b_11 = gimple_assign_rhs1 (and_stmt);\n-  tree _1 = gimple_assign_rhs2 (and_stmt);\n+  tree iv_1 = gimple_assign_rhs1 (iv_2_stmt);\n+  tree _1 = gimple_assign_rhs2 (iv_2_stmt);\n \n-  /* Check that _1 is defined by _b11 + -1 (_1 = b_11 + -1).\n-     Also make sure that b_11 is the same in and_stmt and _1 defining stmt.\n+  /* Check that _1 is defined by (_1 = iv_1 + -1).\n+     Also make sure that _1 is the same in and_stmt and _1 defining stmt.\n      Also canonicalize if _1 and _b11 are revrsed.  */\n-  if (ssa_defined_by_minus_one_stmt_p (b_11, _1))\n-    std::swap (b_11, _1);\n-  else if (ssa_defined_by_minus_one_stmt_p (_1, b_11))\n+  if (ssa_defined_by_minus_one_stmt_p (iv_1, _1))\n+    std::swap (iv_1, _1);\n+  else if (ssa_defined_by_minus_one_stmt_p (_1, iv_1))\n     ;\n   else\n     return false;\n-  /* Check the recurrence:\n-   ... = PHI <b_5(2), b_6(3)>.  */\n-  gimple *phi = SSA_NAME_DEF_STMT (b_11);\n+\n+  /* Check the recurrence.  */\n+  gimple *phi = SSA_NAME_DEF_STMT (iv_1);\n   if (gimple_code (phi) != GIMPLE_PHI\n       || (gimple_bb (phi) != loop_latch_edge (loop)->dest)\n-      || (gimple_assign_lhs (and_stmt)\n-\t  != gimple_phi_arg_def (phi, loop_latch_edge (loop)->dest_idx)))\n+      || (iv_2 != gimple_phi_arg_def (phi, loop_latch_edge (loop)->dest_idx)))\n     return false;\n \n-  /* We found a match. Get the corresponding popcount builtin.  */\n+  /* We found a match.  */\n   tree src = gimple_phi_arg_def (phi, loop_preheader_edge (loop)->dest_idx);\n-  if (TYPE_PRECISION (TREE_TYPE (src)) <= TYPE_PRECISION (integer_type_node))\n-    fn = builtin_decl_implicit (BUILT_IN_POPCOUNT);\n-  else if (TYPE_PRECISION (TREE_TYPE (src))\n-\t   == TYPE_PRECISION (long_integer_type_node))\n-    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTL);\n-  else if (TYPE_PRECISION (TREE_TYPE (src))\n-\t   == TYPE_PRECISION (long_long_integer_type_node)\n-\t   || (TYPE_PRECISION (TREE_TYPE (src))\n-\t       == 2 * TYPE_PRECISION (long_long_integer_type_node)))\n-    fn = builtin_decl_implicit (BUILT_IN_POPCOUNTLL);\n+  int src_precision = TYPE_PRECISION (TREE_TYPE (src));\n \n-  if (!fn)\n+  /* Get the corresponding popcount builtin.  */\n+  tree expr = build_popcount_expr (src);\n+\n+  if (!expr)\n     return false;\n \n-  /* Update NITER params accordingly  */\n-  tree utype = unsigned_type_for (TREE_TYPE (src));\n-  src = fold_convert (utype, src);\n-  if (TYPE_PRECISION (TREE_TYPE (src)) < TYPE_PRECISION (integer_type_node))\n-    src = fold_convert (unsigned_type_node, src);\n-  tree call;\n-  if (TYPE_PRECISION (TREE_TYPE (src))\n-      == 2 * TYPE_PRECISION (long_long_integer_type_node))\n+  max = src_precision;\n+\n+  tree may_be_zero = boolean_false_node;\n+\n+  if (modify_before_test)\n     {\n-      int prec = TYPE_PRECISION (long_long_integer_type_node);\n-      tree src1 = fold_convert (long_long_unsigned_type_node,\n-\t\t\t\tfold_build2 (RSHIFT_EXPR, TREE_TYPE (src),\n-\t\t\t\t\t     unshare_expr (src),\n-\t\t\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t\t\t    prec)));\n-      tree src2 = fold_convert (long_long_unsigned_type_node, src);\n-      call = build_call_expr (fn, 1, src1);\n-      call = fold_build2 (PLUS_EXPR, TREE_TYPE (call), call,\n-\t\t\t  build_call_expr (fn, 1, src2));\n-      call = fold_convert (utype, call);\n+      expr = fold_build2 (MINUS_EXPR, integer_type_node, expr,\n+\t\t\t  integer_one_node);\n+      max = max - 1;\n+      may_be_zero = fold_build2 (EQ_EXPR, boolean_type_node, src,\n+\t\t\t\t      build_zero_cst (TREE_TYPE (src)));\n     }\n-  else\n-    call = fold_convert (utype, build_call_expr (fn, 1, src));\n-  if (adjust)\n-    iter = fold_build2 (MINUS_EXPR, utype, call, build_int_cst (utype, 1));\n-  else\n-    iter = call;\n \n-  if (TREE_CODE (call) == INTEGER_CST)\n-    max = tree_to_uhwi (call);\n-  else\n-    max = TYPE_PRECISION (TREE_TYPE (src));\n-  if (adjust)\n-    max = max - 1;\n+  expr = fold_convert (unsigned_type_node, expr);\n \n-  niter->niter = iter;\n   niter->assumptions = boolean_true_node;\n+  niter->may_be_zero = simplify_using_initial_conditions (loop, may_be_zero);\n+  niter->niter = simplify_using_initial_conditions(loop, expr);\n \n-  if (adjust)\n-    {\n-      tree may_be_zero = fold_build2 (EQ_EXPR, boolean_type_node, src,\n-\t\t\t\t      build_zero_cst (TREE_TYPE (src)));\n-      niter->may_be_zero\n-\t= simplify_using_initial_conditions (loop, may_be_zero);\n-    }\n+  if (TREE_CODE (niter->niter) == INTEGER_CST)\n+    niter->max = tree_to_uhwi (niter->niter);\n   else\n-    niter->may_be_zero = boolean_false_node;\n+    niter->max = max;\n \n-  niter->max = max;\n   niter->bound = NULL_TREE;\n   niter->cmp = ERROR_MARK;\n   return true;\n }\n \n+/* See if LOOP contains a bit counting idiom. The idiom consists of two parts:\n+   1. A modification to the induction variabler;.\n+   2. A test to determine whether or not to exit the loop.\n+\n+   These can come in either order - i.e.:\n+\n+   <bb 3>\n+   iv_1 = PHI <src(2), iv_2(4)>\n+   if (test (iv_1))\n+     goto <bb 4>\n+   else\n+     goto <bb 5>\n+\n+   <bb 4>\n+   iv_2 = modify (iv_1)\n+   goto <bb 3>\n+\n+   OR\n+\n+   <bb 3>\n+   iv_1 = PHI <src(2), iv_2(4)>\n+   iv_2 = modify (iv_1)\n+\n+   <bb 4>\n+   if (test (iv_2))\n+     goto <bb 3>\n+   else\n+     goto <bb 5>\n+\n+   The second form can be generated by copying the loop header out of the loop.\n+\n+   In the first case, the number of latch executions will be equal to the\n+   number of induction variable modifications required before the test fails.\n+\n+   In the second case (modify_before_test), if we assume that the number of\n+   modifications required before the test fails is nonzero, then the number of\n+   latch executions will be one less than this number.\n+\n+   If we recognise the pattern, then we update niter accordingly, and return\n+   true.  */\n+\n+static bool\n+number_of_iterations_bitcount (loop_p loop, edge exit,\n+\t\t\t       enum tree_code code,\n+\t\t\t       class tree_niter_desc *niter)\n+{\n+  return number_of_iterations_popcount (loop, exit, code, niter);\n+}\n+\n /* Substitute NEW_TREE for OLD in EXPR and fold the result.\n    If VALUEIZE is non-NULL then OLD and NEW_TREE are ignored and instead\n    all SSA names are replaced with the result of calling the VALUEIZE\n@@ -2758,7 +2785,7 @@ number_of_iterations_exit_assumptions (class loop *loop, edge exit,\n   tree iv0_niters = NULL_TREE;\n   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),\n \t\t\t      op0, &iv0, safe ? &iv0_niters : NULL, false))\n-    return number_of_iterations_popcount (loop, exit, code, niter);\n+    return number_of_iterations_bitcount (loop, exit, code, niter);\n   tree iv1_niters = NULL_TREE;\n   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),\n \t\t\t      op1, &iv1, safe ? &iv1_niters : NULL, false))"}]}