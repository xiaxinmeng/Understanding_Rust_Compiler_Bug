{"sha": "046c58907ec85884042d9937ea9c25ef9fe57b1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ2YzU4OTA3ZWM4NTg4NDA0MmQ5OTM3ZWE5YzI1ZWY5ZmU1N2IxZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-03-17T21:32:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-03-17T21:32:34Z"}, "message": "c: Handle C_TYPE_INCOMPLETE_VARS even for ENUMERAL_TYPEs [PR94172]\n\nThe following testcases ICE, because they contain extern variable\ndeclarations with incomplete enum types that is later completed and after\nthat those variables are accessed.  The ICEs are because the vars then may have\nincorrect DECL_MODE etc., e.g. in the first case the var has SImode\nDECL_MODE (the guessed mode for the enum), but the enum then actually has\nDImode because its enumerators don't fit into unsigned int.\n\nThe following patch fixes it by using C_TYPE_INCOMPLETE_VARS not just on\nincomplete struct/union types, but also incomplete enum types.\nTYPE_VFIELD can't be used as it is TYPE_MIN_VALUE on ENUMERAL_TYPE,\nthankfully TYPE_LANG_SLOT_1 has been used in the C FE only on\nFUNCTION_TYPEs.\n\n2020-03-17  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c/94172\n\t* c-tree.h (C_TYPE_INCOMPLETE_VARS): Define to TYPE_LANG_SLOT_1\n\tinstead of TYPE_VFIELD, and support it on {RECORD,UNION,ENUMERAL}_TYPE.\n\t(TYPE_ACTUAL_ARG_TYPES): Check that it is only used on FUNCTION_TYPEs.\n\t* c-decl.c (pushdecl): Push C_TYPE_INCOMPLETE_VARS also to\n\tENUMERAL_TYPEs.\n\t(finish_incomplete_vars): New function, moved from finish_struct.  Use\n\trelayout_decl instead of layout_decl.\n\t(finish_struct): Remove obsolete comment about C_TYPE_INCOMPLETE_VARS\n\tbeing TYPE_VFIELD.  Use finish_incomplete_vars.\n\t(finish_enum): Clear C_TYPE_INCOMPLETE_VARS.  Call\n\tfinish_incomplete_vars.\n\t* c-typeck.c (c_build_qualified_type): Clear C_TYPE_INCOMPLETE_VARS\n\talso on ENUMERAL_TYPEs.\n\n\t* gcc.dg/pr94172-1.c: New test.\n\t* gcc.dg/pr94172-2.c: New test.", "tree": {"sha": "1c251780db917516b9122df787d68a65310b0e3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c251780db917516b9122df787d68a65310b0e3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/046c58907ec85884042d9937ea9c25ef9fe57b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/046c58907ec85884042d9937ea9c25ef9fe57b1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/046c58907ec85884042d9937ea9c25ef9fe57b1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/046c58907ec85884042d9937ea9c25ef9fe57b1d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd0b71242738a1901405f421b352e4f6c30ff7c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0b71242738a1901405f421b352e4f6c30ff7c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd0b71242738a1901405f421b352e4f6c30ff7c5"}], "stats": {"total": 117, "additions": 89, "deletions": 28}, "files": [{"sha": "25f8f5b6b7bd6b47f7276ca74e2986d539d70bee", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=046c58907ec85884042d9937ea9c25ef9fe57b1d", "patch": "@@ -1,3 +1,20 @@\n+2020-03-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/94172\n+\t* c-tree.h (C_TYPE_INCOMPLETE_VARS): Define to TYPE_LANG_SLOT_1\n+\tinstead of TYPE_VFIELD, and support it on {RECORD,UNION,ENUMERAL}_TYPE.\n+\t(TYPE_ACTUAL_ARG_TYPES): Check that it is only used on FUNCTION_TYPEs.\n+\t* c-decl.c (pushdecl): Push C_TYPE_INCOMPLETE_VARS also to\n+\tENUMERAL_TYPEs.\n+\t(finish_incomplete_vars): New function, moved from finish_struct.  Use\n+\trelayout_decl instead of layout_decl.\n+\t(finish_struct): Remove obsolete comment about C_TYPE_INCOMPLETE_VARS\n+\tbeing TYPE_VFIELD.  Use finish_incomplete_vars.\n+\t(finish_enum): Clear C_TYPE_INCOMPLETE_VARS.  Call\n+\tfinish_incomplete_vars.\n+\t* c-typeck.c (c_build_qualified_type): Clear C_TYPE_INCOMPLETE_VARS\n+\talso on ENUMERAL_TYPEs.\n+\n 2020-03-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/94179"}, {"sha": "ed5163dd46583265b3d89e3359c0e90d58c148c1", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=046c58907ec85884042d9937ea9c25ef9fe57b1d", "patch": "@@ -3312,7 +3312,8 @@ pushdecl (tree x)\n \telement = TREE_TYPE (element);\n       element = TYPE_MAIN_VARIANT (element);\n \n-      if (RECORD_OR_UNION_TYPE_P (element)\n+      if ((RECORD_OR_UNION_TYPE_P (element)\n+\t   || TREE_CODE (element) == ENUMERAL_TYPE)\n \t  && (TREE_CODE (x) != TYPE_DECL\n \t      || TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE)\n \t  && !COMPLETE_TYPE_P (element))\n@@ -8354,6 +8355,26 @@ field_decl_cmp (const void *x_p, const void *y_p)\n   return 1;\n }\n \n+/* If this structure or union completes the type of any previous\n+   variable declaration, lay it out and output its rtl.  */\n+static void\n+finish_incomplete_vars (tree incomplete_vars, bool toplevel)\n+{\n+  for (tree x = incomplete_vars; x; x = TREE_CHAIN (x))\n+    {\n+      tree decl = TREE_VALUE (x);\n+      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+\tlayout_array_type (TREE_TYPE (decl));\n+      if (TREE_CODE (decl) != TYPE_DECL)\n+\t{\n+\t  relayout_decl (decl);\n+\t  if (c_dialect_objc ())\n+\t    objc_check_decl (decl);\n+\t  rest_of_decl_compilation (decl, toplevel, 0);\n+\t}\n+    }\n+}\n+\n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n    LOC is the location of the RECORD_TYPE or UNION_TYPE's definition.\n    FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n@@ -8612,13 +8633,6 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n       warning_at (loc, 0, \"union cannot be made transparent\");\n     }\n \n-  /* Note: C_TYPE_INCOMPLETE_VARS overloads TYPE_VFIELD which is used\n-     in dwarf2out via rest_of_decl_compilation below and means\n-     something totally different.  Since we will be clearing\n-     C_TYPE_INCOMPLETE_VARS shortly after we iterate through them,\n-     clear it ahead of time and avoid problems in dwarf2out.  Ideally,\n-     C_TYPE_INCOMPLETE_VARS should use some language specific\n-     node.  */\n   tree incomplete_vars = C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (t));\n   for (x = TYPE_MAIN_VARIANT (t); x; x = TYPE_NEXT_VARIANT (x))\n     {\n@@ -8639,21 +8653,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, toplevel);\n \n-  /* If this structure or union completes the type of any previous\n-     variable declaration, lay it out and output its rtl.  */\n-  for (x = incomplete_vars; x; x = TREE_CHAIN (x))\n-    {\n-      tree decl = TREE_VALUE (x);\n-      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\tlayout_array_type (TREE_TYPE (decl));\n-      if (TREE_CODE (decl) != TYPE_DECL)\n-\t{\n-\t  layout_decl (decl, 0);\n-\t  if (c_dialect_objc ())\n-\t    objc_check_decl (decl);\n-\t  rest_of_decl_compilation (decl, toplevel, 0);\n-\t}\n-    }\n+  finish_incomplete_vars (incomplete_vars, toplevel);\n \n   /* If we're inside a function proper, i.e. not file-scope and not still\n      parsing parameters, then arrange for the size of a variable sized type\n@@ -8932,8 +8932,10 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   TYPE_LANG_SPECIFIC (enumtype) = lt;\n \n   /* Fix up all variant types of this enum type.  */\n+  tree incomplete_vars = C_TYPE_INCOMPLETE_VARS (TYPE_MAIN_VARIANT (enumtype));\n   for (tem = TYPE_MAIN_VARIANT (enumtype); tem; tem = TYPE_NEXT_VARIANT (tem))\n     {\n+      C_TYPE_INCOMPLETE_VARS (tem) = NULL_TREE;\n       if (tem == enumtype)\n \tcontinue;\n       TYPE_VALUES (tem) = TYPE_VALUES (enumtype);\n@@ -8952,6 +8954,8 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (enumtype, toplevel);\n \n+  finish_incomplete_vars (incomplete_vars, toplevel);\n+\n   /* If this enum is defined inside a struct, add it to\n      struct_types.  */\n   if (warn_cxx_compat"}, {"sha": "364d7e033984567a9f6d7d6051c524bc9b963b6b", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=046c58907ec85884042d9937ea9c25ef9fe57b1d", "patch": "@@ -38,9 +38,12 @@ along with GCC; see the file COPYING3.  If not see\n    nonzero if the definition of the type has already started.  */\n #define C_TYPE_BEING_DEFINED(TYPE) TYPE_LANG_FLAG_0 (TYPE)\n \n-/* In an incomplete RECORD_TYPE or UNION_TYPE, a list of variable\n-   declarations whose type would be completed by completing that type.  */\n-#define C_TYPE_INCOMPLETE_VARS(TYPE) TYPE_VFIELD (TYPE)\n+/* In an incomplete RECORD_TYPE, UNION_TYPE or ENUMERAL_TYPE, a list of\n+   variable declarations whose type would be completed by completing\n+   that type.  */\n+#define C_TYPE_INCOMPLETE_VARS(TYPE) \\\n+  TYPE_LANG_SLOT_1 (TREE_CHECK4 (TYPE, RECORD_TYPE, UNION_TYPE, \\\n+\t\t\t\t QUAL_UNION_TYPE, ENUMERAL_TYPE))\n \n /* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n    keyword.  C_RID_CODE (node) is then the RID_* value of the keyword.  */\n@@ -108,7 +111,8 @@ along with GCC; see the file COPYING3.  If not see\n /* For FUNCTION_TYPE, a hidden list of types of arguments.  The same as\n    TYPE_ARG_TYPES for functions with prototypes, but created for functions\n    without prototypes.  */\n-#define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_LANG_SLOT_1 (NODE)\n+#define TYPE_ACTUAL_ARG_TYPES(NODE) \\\n+  TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n \n /* For a CONSTRUCTOR, whether some initializer contains a\n    subexpression meaning it is not a constant expression.  */"}, {"sha": "385bf3a1c7b392b48200b2c57af0f0c844994989", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=046c58907ec85884042d9937ea9c25ef9fe57b1d", "patch": "@@ -15207,7 +15207,8 @@ c_build_qualified_type (tree type, int type_quals, tree orig_qual_type,\n \t\t   : build_qualified_type (type, type_quals));\n   /* A variant type does not inherit the list of incomplete vars from the\n      type main variant.  */\n-  if (RECORD_OR_UNION_TYPE_P (var_type)\n+  if ((RECORD_OR_UNION_TYPE_P (var_type)\n+       || TREE_CODE (var_type) == ENUMERAL_TYPE)\n       && TYPE_MAIN_VARIANT (var_type) != var_type)\n     C_TYPE_INCOMPLETE_VARS (var_type) = 0;\n   return var_type;"}, {"sha": "dae22c277640e104295c6569ed648035c3e5c9b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=046c58907ec85884042d9937ea9c25ef9fe57b1d", "patch": "@@ -1,5 +1,9 @@\n 2020-03-17  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c/94172\n+\t* gcc.dg/pr94172-1.c: New test.\n+\t* gcc.dg/pr94172-2.c: New test.\n+\n \tPR c++/90995\n \t* g++.dg/cpp0x/enum40.C: New test.\n "}, {"sha": "12f84af42dd5073c1f31a973d31395fea6dd0978", "filename": "gcc/testsuite/gcc.dg/pr94172-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94172-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94172-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94172-1.c?ref=046c58907ec85884042d9937ea9c25ef9fe57b1d", "patch": "@@ -0,0 +1,12 @@\n+/* PR c/94172 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+extern enum E e;\n+enum E { l = 0x100000000ULL };\n+\n+unsigned long long\n+foo (void)\n+{\n+  return e;\n+}"}, {"sha": "bb7b060d7b26c67bc0ab8abbefb9a1c4f6376335", "filename": "gcc/testsuite/gcc.dg/pr94172-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94172-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046c58907ec85884042d9937ea9c25ef9fe57b1d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94172-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr94172-2.c?ref=046c58907ec85884042d9937ea9c25ef9fe57b1d", "patch": "@@ -0,0 +1,19 @@\n+/* PR c/94172 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -g -fshort-enums\" } */\n+\n+extern enum E e;\n+extern void bar (int a);\n+enum E { F };\n+\n+void\n+foo (int a)\n+{\n+  int l = e;\n+  if (a)\n+    {\n+      __asm volatile (\"nop\");\n+      l = 0;\n+    }\n+  bar (l);\n+}"}]}