{"sha": "e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIxMDJlZmMwMDI0ZWEyM2FkOTRlMWJmMWJjYmZjNDQ4M2FhZGJiMw==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2010-07-27T18:18:25Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2010-07-27T18:18:25Z"}, "message": "Multiple exit loop handling in ivopts. Regression tested on x86-64/linux\n\nFrom-SVN: r162585", "tree": {"sha": "993e15fabfe51307753a6cddfe97eba0f624a2a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/993e15fabfe51307753a6cddfe97eba0f624a2a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01d2a0c17018a57fcc6a17f5ddc24fc5d6d7c684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d2a0c17018a57fcc6a17f5ddc24fc5d6d7c684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d2a0c17018a57fcc6a17f5ddc24fc5d6d7c684"}], "stats": {"total": 109, "additions": 82, "deletions": 27}, "files": [{"sha": "e4435ba45ea34055205540b9c1627174d2e718d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3", "patch": "@@ -1,3 +1,12 @@\n+2010-07-27  Xinliang David Li  <davidxl@google.com>\n+\n+\t* tree-ssa-loop-ivopts.c (niter_for_exit): New parameter.\n+\t(niter_for_single_dom_exit): Passes additional parameter.\n+\t(iv_period): Fix comments.\n+\t(may_eliminate_iv): Handles multiple exit loops properly.\n+\t(free_tree_niter_desc): New function.\n+\t(free_loop_data): Frees up loop iteration descriptors.\n+\n 2010-07-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/44542"}, {"sha": "30ddb75520db0fa9b102401202ac9aae7c52e5b7", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 73, "deletions": 27, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=e2102efc0024ea23ad94e1bf1bcbfc4483aadbb3", "patch": "@@ -718,9 +718,10 @@ contains_abnormal_ssa_name_p (tree expr)\n     EXIT of DATA->current_loop, or NULL if something goes wrong.  */\n \n static tree\n-niter_for_exit (struct ivopts_data *data, edge exit)\n+niter_for_exit (struct ivopts_data *data, edge exit,\n+                struct tree_niter_desc **desc_p)\n {\n-  struct tree_niter_desc desc;\n+  struct tree_niter_desc* desc = NULL;\n   tree niter;\n   void **slot;\n \n@@ -739,19 +740,24 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n \t being zero).  Also, we cannot safely work with ssa names that\n \t appear in phi nodes on abnormal edges, so that we do not create\n \t overlapping life ranges for them (PR 27283).  */\n+      desc = XNEW (struct tree_niter_desc);\n       if (number_of_iterations_exit (data->current_loop,\n-\t\t\t\t     exit, &desc, true)\n-\t  && integer_zerop (desc.may_be_zero)\n-     \t  && !contains_abnormal_ssa_name_p (desc.niter))\n-\tniter = desc.niter;\n+\t\t\t\t     exit, desc, true)\n+\t  && integer_zerop (desc->may_be_zero)\n+     \t  && !contains_abnormal_ssa_name_p (desc->niter))\n+\tniter = desc->niter;\n       else\n \tniter = NULL_TREE;\n \n-      *pointer_map_insert (data->niters, exit) = niter;\n+      desc->niter = niter;\n+      slot = pointer_map_insert (data->niters, exit);\n+      *slot = desc;\n     }\n   else\n-    niter = (tree) *slot;\n+    niter = ((struct tree_niter_desc *) *slot)->niter;\n \n+  if (desc_p)\n+    *desc_p = (struct tree_niter_desc *) *slot;\n   return niter;\n }\n \n@@ -767,7 +773,7 @@ niter_for_single_dom_exit (struct ivopts_data *data)\n   if (!exit)\n     return NULL;\n \n-  return niter_for_exit (data, exit);\n+  return niter_for_exit (data, exit, NULL);\n }\n \n /* Initializes data structures used by the iv optimization pass, stored\n@@ -4005,15 +4011,20 @@ iv_period (struct iv *iv)\n \n   gcc_assert (step && TREE_CODE (step) == INTEGER_CST);\n \n-  /* Period of the iv is gcd (step, type range).  Since type range is power\n-     of two, it suffices to determine the maximum power of two that divides\n-     step.  */\n-  pow2div = num_ending_zeros (step);\n   type = unsigned_type_for (TREE_TYPE (step));\n+  /* Period of the iv is lcm (step, type_range)/step -1,\n+     i.e., N*type_range/step - 1. Since type range is power\n+     of two, N == (step >> num_of_ending_zeros_binary (step),\n+     so the final result is\n+\n+       (type_range >> num_of_ending_zeros_binary (step)) - 1\n+\n+  */\n+  pow2div = num_ending_zeros (step);\n \n   period = build_low_bits_mask (type,\n-\t\t\t\t(TYPE_PRECISION (type)\n-\t\t\t\t - tree_low_cst (pow2div, 1)));\n+                                (TYPE_PRECISION (type)\n+                                 - tree_low_cst (pow2div, 1)));\n \n   return period;\n }\n@@ -4047,6 +4058,7 @@ may_eliminate_iv (struct ivopts_data *data,\n   tree nit, period;\n   struct loop *loop = data->current_loop;\n   aff_tree bnd;\n+  struct tree_niter_desc *desc = NULL;\n \n   if (TREE_CODE (cand->iv->step) != INTEGER_CST)\n     return false;\n@@ -4065,7 +4077,7 @@ may_eliminate_iv (struct ivopts_data *data,\n   if (flow_bb_inside_loop_p (loop, exit->dest))\n     return false;\n \n-  nit = niter_for_exit (data, exit);\n+  nit = niter_for_exit (data, exit, &desc);\n   if (!nit)\n     return false;\n \n@@ -4077,27 +4089,46 @@ may_eliminate_iv (struct ivopts_data *data,\n   /* If the number of iterations is constant, compare against it directly.  */\n   if (TREE_CODE (nit) == INTEGER_CST)\n     {\n-      if (!tree_int_cst_lt (nit, period))\n-\treturn false;\n+      /* See cand_value_at.  */\n+      if (stmt_after_increment (loop, cand, use->stmt))\n+        {\n+          if (!tree_int_cst_lt (nit, period))\n+            return false;\n+        }\n+      else\n+        {\n+          if (tree_int_cst_lt (period, nit))\n+            return false;\n+        }\n     }\n \n   /* If not, and if this is the only possible exit of the loop, see whether\n      we can get a conservative estimate on the number of iterations of the\n      entire loop and compare against that instead.  */\n-  else if (loop_only_exit_p (loop, exit))\n+  else\n     {\n       double_int period_value, max_niter;\n-      if (!estimated_loop_iterations (loop, true, &max_niter))\n-\treturn false;\n+\n+      max_niter = desc->max;\n+      if (stmt_after_increment (loop, cand, use->stmt))\n+        max_niter = double_int_add (max_niter, double_int_one);\n       period_value = tree_to_double_int (period);\n-      if (double_int_ucmp (max_niter, period_value) >= 0)\n-\treturn false;\n+      if (double_int_ucmp (max_niter, period_value) > 0)\n+        {\n+          /* See if we can take advantage of infered loop bound information.  */\n+          if (loop_only_exit_p (loop, exit))\n+            {\n+              if (!estimated_loop_iterations (loop, true, &max_niter))\n+                return false;\n+              /* The loop bound is already adjusted by adding 1.  */\n+              if (double_int_ucmp (max_niter, period_value) > 0)\n+                return false;\n+            }\n+          else\n+            return false;\n+        }\n     }\n \n-  /* Otherwise, punt.  */\n-  else\n-    return false;\n-\n   cand_value_at (loop, cand, use->stmt, nit, &bnd);\n \n   *bound = aff_combination_to_tree (&bnd);\n@@ -4108,6 +4139,7 @@ may_eliminate_iv (struct ivopts_data *data,\n   return true;\n }\n \n+\n /* Determines cost of basing replacement of USE on CAND in a condition.  */\n \n static bool\n@@ -5779,6 +5811,19 @@ remove_unused_ivs (struct ivopts_data *data)\n   BITMAP_FREE (toremove);\n }\n \n+/* Frees memory occupied by struct tree_niter_desc in *VALUE. Callback\n+   for pointer_map_traverse.  */\n+\n+static bool\n+free_tree_niter_desc (const void *key ATTRIBUTE_UNUSED, void **value,\n+                      void *data ATTRIBUTE_UNUSED)\n+{\n+  struct tree_niter_desc *const niter = (struct tree_niter_desc *) *value;\n+\n+  free (niter);\n+  return true;\n+}\n+\n /* Frees data allocated by the optimization of a single loop.  */\n \n static void\n@@ -5790,6 +5835,7 @@ free_loop_data (struct ivopts_data *data)\n \n   if (data->niters)\n     {\n+      pointer_map_traverse (data->niters, free_tree_niter_desc, NULL);\n       pointer_map_destroy (data->niters);\n       data->niters = NULL;\n     }"}]}