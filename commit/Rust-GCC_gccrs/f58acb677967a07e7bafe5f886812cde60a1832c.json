{"sha": "f58acb677967a07e7bafe5f886812cde60a1832c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU4YWNiNjc3OTY3YTA3ZTdiYWZlNWY4ODY4MTJjZGU2MGExODMyYw==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-12-09T21:29:02Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-12-09T21:29:02Z"}, "message": "Remove change of Oct 4.\n\nFrom-SVN: r13256", "tree": {"sha": "2b0e10ab4c2868af5644f9a7e28ea9014d612695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b0e10ab4c2868af5644f9a7e28ea9014d612695"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f58acb677967a07e7bafe5f886812cde60a1832c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f58acb677967a07e7bafe5f886812cde60a1832c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f58acb677967a07e7bafe5f886812cde60a1832c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f58acb677967a07e7bafe5f886812cde60a1832c/comments", "author": null, "committer": null, "parents": [{"sha": "b925394ae6fa25cb868824eaed0f7b4ccf4190f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b925394ae6fa25cb868824eaed0f7b4ccf4190f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b925394ae6fa25cb868824eaed0f7b4ccf4190f2"}], "stats": {"total": 266, "additions": 63, "deletions": 203}, "files": [{"sha": "a28c503cdafa885b0fa1ce8afc55492cd3d5c8ed", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f58acb677967a07e7bafe5f886812cde60a1832c/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f58acb677967a07e7bafe5f886812cde60a1832c/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f58acb677967a07e7bafe5f886812cde60a1832c", "patch": "@@ -2593,32 +2593,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n \f\n-/* Helper macros to decide if the rtl of some instruction\n-   will cause problems due to register shortage.  */\n-\n-/* ??? flags.h is not self-contained */\n-extern int flag_omit_frame_pointer;\n-/* ??? neither is function.h */\n-extern struct function *outer_function_chain;\n-/* ??? neither is expr.h */\n-extern int current_function_calls_alloca;\n-/* ??? No header file for  rtx_equal_function_value_matters */\n-extern int rtx_equal_function_value_matters;\n-\n-#define N_REGS_USED(op) \\\n-  (GET_CODE (op) == MEM \\\n-   ? (GET_CODE (XEXP (op, 0)) == PLUS \\\n-      ? (rtx_varies_p (XEXP (XEXP (op, 0), 0)) \\\n-         + rtx_varies_p (XEXP (XEXP (op, 0), 1))) \\\n-      : rtx_varies_p (XEXP (op, 0))) \\\n-   : (GET_CODE (op) == REG ? HARD_REGNO_NREGS (REGNO (op), GET_MODE (op)) : 0))\n-\n-#define N_ALLOCATABLE_REGISTERS\t\t\t\t\t\t\\\n-  (6 - (flag_pic != 0) - (outer_function_chain != 0)                    \\\n-   + (flag_omit_frame_pointer && ! rtx_equal_function_value_matters     \\\n-      && ! current_function_calls_alloca))\n-\f\n-\n /* Functions in i386.c */\n extern void override_options ();\n extern void order_regs_for_local_alloc ();"}, {"sha": "fa969b5c4f52d1f533274782ad19538538de1ae3", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 63, "deletions": 177, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f58acb677967a07e7bafe5f886812cde60a1832c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f58acb677967a07e7bafe5f886812cde60a1832c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f58acb677967a07e7bafe5f886812cde60a1832c", "patch": "@@ -1128,9 +1128,7 @@\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], SFmode))\n-      && (N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-\t  < N_ALLOCATABLE_REGISTERS))\n+      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], SFmode)))\n     {\n       rtx (*genfunc) PROTO((rtx, rtx)) = (push_operand (operands[0], SFmode))\n \t\t\t\t\t\t? gen_movsf_push\n@@ -1236,8 +1234,7 @@\n   [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n \t(match_operand:SF 1 \"memory_operand\" \"m\"))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-   < N_ALLOCATABLE_REGISTERS\"\n+  \"\"\n   \"*\n {\n   output_asm_insn (AS2 (mov%L2,%1,%2), operands);\n@@ -1248,10 +1245,7 @@\n (define_insn \"movsf_normal\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=*rfm,*rf,f,!*rm\")\n \t(match_operand:SF 1 \"general_operand\" \"*rf,*rfm,fG,fF\"))]\n-  \"! TARGET_MOVE || GET_CODE (operands[0]) != MEM\n-   || GET_CODE (operands[1]) != MEM\n-   || (N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-       == N_ALLOCATABLE_REGISTERS)\"\n+  \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM) || (GET_CODE (operands[1]) != MEM)\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n@@ -1329,9 +1323,7 @@\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], DFmode))\n-      && (N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-\t  < N_ALLOCATABLE_REGISTERS))\n+      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], DFmode)))\n     {\n       rtx (*genfunc) PROTO((rtx, rtx)) = (push_operand (operands[0], DFmode))\n \t\t\t\t\t\t? gen_movdf_push\n@@ -1431,18 +1423,15 @@\n \t(match_operand:DF 1 \"memory_operand\" \"o,o\"))\n    (clobber (match_scratch:SI 2 \"=&r,&r\"))\n    (clobber (match_scratch:SI 3 \"=&r,X\"))]\n-  \"N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-   < N_ALLOCATABLE_REGISTERS\"\n+  \"\"\n   \"* return output_move_memory (operands, insn, GET_MODE_SIZE (DFmode), 2, 4);\")\n \n ;; For the purposes of regclass, prefer FLOAT_REGS.\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,fm,!*rf,!*rm\")\n \t(match_operand:DF 1 \"general_operand\" \"fmG,f,*rfm,*rfF\"))]\n-  \"! TARGET_MOVE || GET_CODE (operands[0]) != MEM\n-   || GET_CODE (operands[1]) != MEM\n-   || (N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-       == N_ALLOCATABLE_REGISTERS)\"\n+  \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM)\n+   || (GET_CODE (operands[1]) != MEM)\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n@@ -1521,9 +1510,7 @@\n   if (TARGET_MOVE\n       && (reload_in_progress | reload_completed) == 0\n       && GET_CODE (operands[0]) == MEM\n-      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], XFmode))\n-      && (N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-\t  < N_ALLOCATABLE_REGISTERS))\n+      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], XFmode)))\n     {\n       rtx (*genfunc) PROTO((rtx, rtx)) = (push_operand (operands[0], XFmode))\n \t\t\t\t\t\t? gen_movxf_push\n@@ -1621,17 +1608,14 @@\n \t(match_operand:XF 1 \"memory_operand\" \"o,o\"))\n    (clobber (match_scratch:SI 2 \"=&r,&r\"))\n    (clobber (match_scratch:SI 3 \"=&r,X\"))]\n-  \"N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-   < N_ALLOCATABLE_REGISTERS\"\n+  \"\"\n   \"* return output_move_memory (operands, insn, GET_MODE_SIZE (XFmode), 2, 4);\")\n \n (define_insn \"\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,fm,!*rf,!*rm\")\n \t(match_operand:XF 1 \"general_operand\" \"fmG,f,*rfm,*rfF\"))]\n-  \"! TARGET_MOVE || GET_CODE (operands[0]) != MEM\n-   || GET_CODE (operands[1]) != MEM\n-   || (N_REGS_USED (operands[0]) + N_REGS_USED (operands[1])\n-       == N_ALLOCATABLE_REGISTERS)\"\n+  \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM)\n+   || (GET_CODE (operands[1]) != MEM)\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n@@ -2610,7 +2594,7 @@\n (define_expand \"floatdixf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"\")\n \t(float:XF (match_operand:DI 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && LONG_DOUBLE_TYPE_SIZE == 96\"\n   \"\")\n \n ;; This will convert from SImode or DImode to MODE_FLOAT.\n@@ -2719,16 +2703,12 @@\n \f\n ;;- add instructions\n \n-(define_insn \"*addsidi3_1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,&r,r,o,o\")\n+(define_insn \"addsidi3_1\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,!&r,!r,o,!o\")\n \t(plus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,o,riF,riF,o\")\n \t\t (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"o,ri,ri,roi,roi,ri,ri\"))))\n    (clobber (match_scratch:SI 3 \"=X,X,X,X,X,X,&r\"))]\n-  \"((rtx_equal_p (operands[0], operands[1]) ? 0\n-     : (N_REGS_USED (operands[0])\n-\t+ (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)))\n-    + N_REGS_USED (operands[1]) + N_REGS_USED (operands[2]))\n-   <= N_ALLOCATABLE_REGISTERS\"\n+  \"\"\n   \"*\n {\n   rtx low[3], high[3], xops[7], temp;\n@@ -2771,16 +2751,12 @@\n   RET;\n }\")\n \n-(define_insn \"*addsidi3_2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,&r,r,o,o\")\n-\t(plus:DI (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"o,ri,ri,o,ri,ri,ri\"))\n-\t\t (match_operand:DI 1 \"general_operand\" \"0,0,0,roiF,roiF,riF,o\")))\n-   (clobber (match_scratch:SI 3 \"=X,X,X,X,X,X,&r\"))]\n-  \"((rtx_equal_p (operands[0], operands[2]) ? 0\n-     : (N_REGS_USED (operands[0])\n-\t+ (GET_CODE (operands[0]) == MEM && GET_CODE (operands[2]) == MEM)))\n-    + N_REGS_USED (operands[1]) + N_REGS_USED (operands[2]))\n-   <= N_ALLOCATABLE_REGISTERS\"\n+(define_insn \"addsidi3_2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,&r,!&r,r,o,o,!o\")\n+\t(plus:DI (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"o,ri,ri,o,o,ri,ri,i,r\"))\n+\t\t (match_operand:DI 1 \"general_operand\" \"0,0,0,iF,ro,roiF,riF,o,o\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,X,X,X,X,X,&r,&r\"))]\n+  \"\"\n   \"*\n {\n   rtx low[3], high[3], xops[7], temp;\n@@ -2853,49 +2829,12 @@\n   RET;\n }\")\n \n-(define_expand \"adddi3\"\n-  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (plus:DI (match_operand:DI 1 \"general_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"general_operand\" \"\")))\n-\t      (clobber (match_scratch:SI 3 \"\"))])]\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,o,!&r,!o,!o\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0iF,or,riF,o\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"o,riF,or,or,oriF,o\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,&r,X,&r,&r\"))]\n   \"\"\n-  \"\n-{\n-  if ((((rtx_equal_p (operands[0], operands[1])\n-\t || rtx_equal_p (operands[0], operands[2]))\n-\t? (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM\n-\t   && GET_CODE (operands[2]) == MEM)\n-\t: N_REGS_USED (operands[0]) + (GET_CODE (operands[0]) == MEM))\n-       + N_REGS_USED (operands[1]) + N_REGS_USED (operands[2]))\n-      > N_ALLOCATABLE_REGISTERS)\n-    {\n-      if (GET_CODE (operands[0]) == REG)\n-\t{\n-\t  gen_movdi (operands[0], operands[1]);\n-\t  operands[1] = operands[0];\n-\t}\n-      else\n-\t{\n-\t  rtx tmp = force_reg (DImode, operands[0]);\n-\t  emit_insn (gen_adddi3 (tmp, operands[1], operands[2]));\n-\t  emit_insn (gen_movdi (operands[0], tmp));\n-\t  DONE;\n-\t}\n-    }\n-}\")\n-\n-(define_insn \"*adddi3_1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,&ro,o,&r,o,o,o\")\n-\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,or,riF,riF,o\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"o,riF,o,oriF,riF,o,o\")))\n-   (clobber (match_scratch:SI 3 \"=X,X,&r,X,&r,&r,&r\"))]\n-  \"(((rtx_equal_p (operands[0], operands[1])\n-      || rtx_equal_p (operands[0], operands[2]))\n-     ? (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM\n-\t&& GET_CODE (operands[2]) == MEM)\n-     : N_REGS_USED (operands[0]) + (GET_CODE (operands[0]) == MEM))\n-    + N_REGS_USED (operands[1]) + N_REGS_USED (operands[2]))\n-   <= N_ALLOCATABLE_REGISTERS\"\n   \"*\n {\n   rtx low[3], high[3], xops[7], temp;\n@@ -3166,16 +3105,12 @@\n \f\n ;;- subtract instructions\n \n-(define_insn \"*subsidi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=&r,ro,&r,o,o\")\n-\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,roiF,riF,o\")\n-\t\t  (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"o,ri,roi,ri,ri\"))))\n-   (clobber (match_scratch:SI 3 \"=X,X,X,X,&r\"))]\n-  \"((rtx_equal_p (operands[0], operands[1]) ? 0\n-     : (N_REGS_USED (operands[0])\n-\t+ (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)))\n-    + N_REGS_USED (operands[1]) + N_REGS_USED (operands[2]))\n-   <= N_ALLOCATABLE_REGISTERS\"\n+(define_insn \"subsidi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,&r,!&r,o,o,!o\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0iF,0,roiF,roiF,riF,o,o\")\n+\t\t  (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"o,ri,ri,o,ri,i,r\"))))\n+   (clobber (match_scratch:SI 3 \"=X,X,X,X,X,&r,&r\"))]\n+  \"\"\n   \"*\n {\n   rtx low[3], high[3], xops[7];\n@@ -3218,43 +3153,12 @@\n   RET;\n }\")\n \n-(define_expand \"subdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (minus:DI (match_operand:DI 1 \"general_operand\" \"\")\n-\t\t\t     (match_operand:DI 2 \"general_operand\" \"\")))\n-\t      (clobber (match_scratch:SI 3 \"\"))])]\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,o,o,!&r,!o\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0iF,or,roiF,roiF\")\n+\t\t  (match_operand:DI 2 \"general_operand\" \"or,riF,or,iF,roiF,roiF\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,&r,&r,X,&r\"))]\n   \"\"\n-  \"\n-{\n-  if (((rtx_equal_p (operands[0], operands[1]) ? 0\n-\t: N_REGS_USED (operands[0]) + (GET_CODE (operands[0]) == MEM))\n-       + N_REGS_USED (operands[1]) + N_REGS_USED (operands[2]))\n-      > N_ALLOCATABLE_REGISTERS)\n-    {\n-      if (GET_CODE (operands[0]) == REG)\n-\t{\n-\t  gen_movdi (operands[0], operands[1]);\n-\t  operands[1] = operands[0];\n-\t}\n-      else\n-\t{\n-\t  rtx tmp = force_reg (DImode, operands[0]);\n-\t  emit_insn (gen_subdi3 (tmp, operands[1], operands[2]));\n-\t  emit_insn (gen_movdi (operands[0], tmp));\n-\t  DONE;\n-\t}\n-    }\n-}\")\n-\n-(define_insn \"*subdi3_1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,&ro,&r,o,o\")\n-\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,roiF,riF,o\")\n-\t\t  (match_operand:DI 2 \"general_operand\" \"o,riF,roiF,riF,o\")))\n-   (clobber (match_scratch:SI 3 \"=X,X,X,&r,&r\"))]\n-  \"((rtx_equal_p (operands[0], operands[1]) ? 0\n-     : N_REGS_USED (operands[0]) + (GET_CODE (operands[0]) == MEM))\n-    + N_REGS_USED (operands[1]) + N_REGS_USED (operands[2]))\n-   <= N_ALLOCATABLE_REGISTERS\"\n   \"*\n {\n   rtx low[3], high[3], xops[7];\n@@ -4191,8 +4095,7 @@\n ;; separately, making all shifts emit pairs of shift double and normal\n ;; shift.  Since sh[lr]d does not shift more than 31 bits, and we wish to\n ;; support a 63 bit shift, each shift where the count is in a reg expands\n-;; to three pairs.  If the overall shift is by N bits, then the first two\n-;; pairs shift by N / 2 and the last pair by N & 1.\n+;; to a pair of shifts, a branch, a shift by 32 and a label.\n \n ;; If the shift count is a constant, we need never emit more than one\n ;; shift pair, instead using moves and sign extension for counts greater\n@@ -4257,34 +4160,28 @@\n (define_insn \"ashldi3_non_const_int\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"register_operand\" \"c\")))\n-   (clobber (match_dup 2))]\n+\t\t   (match_operand:QI 2 \"register_operand\" \"c\")))]\n   \"\"\n   \"*\n {\n   rtx xops[4], low[1], high[1];\n+  static HOST_WIDE_INT ashldi_label_number;\n \n   CC_STATUS_INIT;\n \n   split_di (operands, 1, low, high);\n   xops[0] = operands[2];\n-  xops[1] = const1_rtx;\n+  xops[1] = GEN_INT (32);\n   xops[2] = low[0];\n   xops[3] = high[0];\n \n-  output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n-\n-  output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);\n-  output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n-  output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);\n-  output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n-\n-  xops[1] = GEN_INT (7);\t\t\t/* shift count & 1 */\n-\n-  output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n-\n   output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);\n   output_asm_insn (AS2 (sal%L2,%0,%2), xops);\n+  output_asm_insn (AS2 (test%B0,%1,%b0), xops);\n+  asm_fprintf (asm_out_file, \\\"\\\\tje %LLASHLDI%d\\\\n\\\", ashldi_label_number);\n+  output_asm_insn (AS2 (mov%L3,%2,%3), xops);\t/* Fast shift by 32 */\n+  output_asm_insn (AS2 (xor%L2,%2,%2), xops);\n+  asm_fprintf (asm_out_file, \\\"%LLASHLDI%d:\\\\n\\\", ashldi_label_number++);\n \n   RET;\n }\")\n@@ -4451,34 +4348,29 @@\n (define_insn \"ashrdi3_non_const_int\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"register_operand\" \"c\")))\n-   (clobber (match_dup 2))]\n+\t\t     (match_operand:QI 2 \"register_operand\" \"c\")))]\n   \"\"\n   \"*\n {\n   rtx xops[4], low[1], high[1];\n+  static HOST_WIDE_INT ashrdi_label_number;\n \n   CC_STATUS_INIT;\n \n   split_di (operands, 1, low, high);\n   xops[0] = operands[2];\n-  xops[1] = const1_rtx;\n+  xops[1] = GEN_INT (32);\n   xops[2] = low[0];\n   xops[3] = high[0];\n \n-  output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n-\n-  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n-  output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n-  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n-  output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n-\n-  xops[1] = GEN_INT (7);\t\t\t/* shift count & 1 */\n-\n-  output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n-\n   output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n   output_asm_insn (AS2 (sar%L3,%0,%3), xops);\n+  output_asm_insn (AS2 (test%B0,%1,%b0), xops);\n+  asm_fprintf (asm_out_file, \\\"\\\\tje %LLASHRDI%d\\\\n\\\", ashrdi_label_number);\n+  xops[1] = GEN_INT (31);\n+  output_asm_insn (AS2 (mov%L2,%3,%2), xops);\n+  output_asm_insn (AS2 (sar%L3,%1,%3), xops);\t/* shift by 32 */\n+  asm_fprintf (asm_out_file, \\\"%LLASHRDI%d:\\\\n\\\", ashrdi_label_number++);\n \n   RET;\n }\")\n@@ -4611,34 +4503,28 @@\n (define_insn \"lshrdi3_non_const_int\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"register_operand\" \"c\")))\n-   (clobber (match_dup 2))]\n+\t\t     (match_operand:QI 2 \"register_operand\" \"c\")))]\n   \"\"\n   \"*\n {\n   rtx xops[4], low[1], high[1];\n+  static HOST_WIDE_INT lshrdi_label_number;\n \n   CC_STATUS_INIT;\n \n   split_di (operands, 1, low, high);\n   xops[0] = operands[2];\n-  xops[1] = const1_rtx;\n+  xops[1] = GEN_INT (32);\n   xops[2] = low[0];\n   xops[3] = high[0];\n \n-  output_asm_insn (AS2 (ror%B0,%1,%0), xops);\t/* shift count / 2 */\n-\n-  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n-  output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n-  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n-  output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n-\n-  xops[1] = GEN_INT (7);\t\t\t/* shift count & 1 */\n-\n-  output_asm_insn (AS2 (shr%B0,%1,%0), xops);\n-\n   output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);\n   output_asm_insn (AS2 (shr%L3,%0,%3), xops);\n+  output_asm_insn (AS2 (test%B0,%1,%b0), xops);\n+  asm_fprintf (asm_out_file, \\\"\\\\tje %LLLSHRDI%d\\\\n\\\", lshrdi_label_number);\n+  output_asm_insn (AS2 (mov%L2,%3,%2), xops);\t/* Fast shift by 32 */\n+  output_asm_insn (AS2 (xor%L3,%3,%3), xops);\n+  asm_fprintf (asm_out_file, \\\"%LLLSHRDI%d:\\\\n\\\", lshrdi_label_number++);\n \n   RET;\n }\")"}]}