{"sha": "e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTliOWZhNGNkYWVkZDQwYWI0MjljMGM5OGU4ODAxYWUwMzlhMzNlOQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-03-12T18:04:16Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-03-12T18:04:16Z"}, "message": "PR tree-optimization/83456 - -Wrestrict false positive on a non-overlapping memcpy in an inline function\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/83456\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Avoid warning\n\tfor perfectly overlapping calls to memcpy.\n\t(gimple_fold_builtin_memory_chk): Same.\n\t(gimple_fold_builtin_strcpy): Handle no-warning.\n\t(gimple_fold_builtin_stxcpy_chk): Same.\n\t* tree-ssa-strlen.c (maybe_diag_stxncpy_trunc): Handle no-warning.\n\ngcc/c-family/ChangeLog:\n\n\tPR tree-optimization/83456\n\t* gcc/c-family/c-common.c (check_function_restrict): Return bool.\n\tRestore checking of bounded built-in functions.\n\t(check_function_arguments): Also return the result\n\tof warn_for_restrict.\n\t* gcc/c-family/c-common.c (check_function_restrict): Return bool.\n\t* gcc/c-family/c-warn.c (warn_for_restrict): Return bool.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/83456\n\t* c-c++-common/Wrestrict-2.c: Remove test cases.\n\t* c-c++-common/Wrestrict.c: Same.\n\t* gcc.dg/Wrestrict-12.c: New test.\n\t* gcc.dg/Wrestrict-14.c: New test.\n\nFrom-SVN: r258455", "tree": {"sha": "3fbe1a5f54834ad2c8f3f4f8d5572933ad7b9ae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fbe1a5f54834ad2c8f3f4f8d5572933ad7b9ae0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df4cfec5540bfb982bfec374346493bed6608fa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4cfec5540bfb982bfec374346493bed6608fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4cfec5540bfb982bfec374346493bed6608fa4"}], "stats": {"total": 473, "additions": 380, "deletions": 93}, "files": [{"sha": "bc771c64a6148bfa7b2f3d3d7bcaffa8b45c6d96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -1,3 +1,13 @@\n+2018-03-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/83456\n+\t* gimple-fold.c (gimple_fold_builtin_memory_op): Avoid warning\n+\tfor perfectly overlapping calls to memcpy.\n+\t(gimple_fold_builtin_memory_chk): Same.\n+\t(gimple_fold_builtin_strcpy): Handle no-warning.\n+\t(gimple_fold_builtin_stxcpy_chk): Same.\n+\t* tree-ssa-strlen.c (maybe_diag_stxncpy_trunc): Handle no-warning.\n+\n 2018-03-12  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.c (abi_v4_pass_in_fpr): Add bool \"named\""}, {"sha": "259445365c4232171407cede8bb1a0d292e35482", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -1,3 +1,13 @@\n+2018-03-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/83456\n+\t* gcc/c-family/c-common.c (check_function_restrict): Return bool.\n+\tRestore checking of bounded built-in functions.\n+\t(check_function_arguments): Also return the result\n+\tof warn_for_restrict.\n+\t* gcc/c-family/c-common.c (check_function_restrict): Return bool.\n+\t* gcc/c-family/c-warn.c (warn_for_restrict): Return bool.\n+\n 2018-03-02  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/84171"}, {"sha": "e1df1d3b73bfad849f48b57e1446be722025aa4b", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -5309,10 +5309,11 @@ check_function_sentinel (const_tree fntype, int nargs, tree *argarray)\n     }\n }\n \n-/* Check that the same argument isn't passed to restrict arguments\n-   and other arguments.  */\n+/* Check that the same argument isn't passed to two or more\n+   restrict-qualified formal and issue a -Wrestrict warning\n+   if it is.  Return true if a warning has been issued.  */\n \n-static void\n+static bool\n check_function_restrict (const_tree fndecl, const_tree fntype,\n \t\t\t int nargs, tree *argarray)\n {\n@@ -5322,11 +5323,14 @@ check_function_restrict (const_tree fndecl, const_tree fntype,\n   if (fndecl\n       && TREE_CODE (fndecl) == FUNCTION_DECL)\n     {\n-      /* Skip checking built-ins here.  They are checked in more\n-\t detail elsewhere.  */\n+      /* Avoid diagnosing calls built-ins with a zero size/bound\n+\t here.  They are checked in more detail elsewhere.  */\n       if (DECL_BUILT_IN (fndecl)\n-\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-\treturn;\n+\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+\t  && nargs == 3\n+\t  && TREE_CODE (argarray[2]) == INTEGER_CST\n+\t  && integer_zerop (argarray[2]))\n+\treturn false;\n \n       if (DECL_ARGUMENTS (fndecl))\n \tparms = DECL_ARGUMENTS (fndecl);\n@@ -5335,6 +5339,8 @@ check_function_restrict (const_tree fndecl, const_tree fntype,\n   for (i = 0; i < nargs; i++)\n     TREE_VISITED (argarray[i]) = 0;\n \n+  bool warned = false;\n+\n   for (i = 0; i < nargs && parms && parms != void_list_node; i++)\n     {\n       tree type;\n@@ -5351,11 +5357,13 @@ check_function_restrict (const_tree fndecl, const_tree fntype,\n       if (POINTER_TYPE_P (type)\n \t  && TYPE_RESTRICT (type)\n \t  && !TYPE_READONLY (TREE_TYPE (type)))\n-\twarn_for_restrict (i, argarray, nargs);\n+\twarned |= warn_for_restrict (i, argarray, nargs);\n     }\n \n   for (i = 0; i < nargs; i++)\n     TREE_VISITED (argarray[i]) = 0;\n+\n+  return warned;\n }\n \n /* Helper for check_function_nonnull; given a list of operands which\n@@ -5596,8 +5604,10 @@ attribute_fallthrough_p (tree attr)\n \n \f\n /* Check for valid arguments being passed to a function with FNTYPE.\n-   There are NARGS arguments in the array ARGARRAY.  LOC should be used for\n-   diagnostics.  Return true if -Wnonnull warning has been diagnosed.  */\n+   There are NARGS arguments in the array ARGARRAY.  LOC should be used\n+   for diagnostics.  Return true if either -Wnonnull or -Wrestrict has\n+   been issued.  */\n+\n bool\n check_function_arguments (location_t loc, const_tree fndecl, const_tree fntype,\n \t\t\t  int nargs, tree *argarray, vec<location_t> *arglocs)\n@@ -5620,7 +5630,7 @@ check_function_arguments (location_t loc, const_tree fndecl, const_tree fntype,\n     check_function_sentinel (fntype, nargs, argarray);\n \n   if (warn_restrict)\n-    check_function_restrict (fndecl, fntype, nargs, argarray);\n+    warned_p |= check_function_restrict (fndecl, fntype, nargs, argarray);\n   return warned_p;\n }\n "}, {"sha": "6cf7614f68207c9ea26e293aa2e9600c3af53df8", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -1269,7 +1269,7 @@ extern void warnings_for_convert_and_check (location_t, tree, tree, tree);\n extern void c_do_switch_warnings (splay_tree, location_t, tree, tree, bool,\n \t\t\t\t  bool);\n extern void warn_for_omitted_condop (location_t, tree);\n-extern void warn_for_restrict (unsigned, tree *, unsigned);\n+extern bool warn_for_restrict (unsigned, tree *, unsigned);\n \n /* Places where an lvalue, or modifiable lvalue, may be required.\n    Used to select diagnostic messages in lvalue_error and"}, {"sha": "51c376b7c37fdda2671e831da97df03a823789a0", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -2372,14 +2372,15 @@ maybe_warn_bool_compare (location_t loc, enum tree_code code, tree op0,\n }\n \n /* Warn if an argument at position param_pos is passed to a\n-   restrict-qualified param, and it aliases with another argument.  */\n+   restrict-qualified param, and it aliases with another argument.\n+   Return true if a warning has been issued.  */\n \n-void\n+bool\n warn_for_restrict (unsigned param_pos, tree *argarray, unsigned nargs)\n {\n   tree arg = argarray[param_pos];\n   if (TREE_VISITED (arg) || integer_zerop (arg))\n-    return;\n+    return false;\n \n   location_t loc = EXPR_LOC_OR_LOC (arg, input_location);\n   gcc_rich_location richloc (loc);\n@@ -2395,13 +2396,13 @@ warn_for_restrict (unsigned param_pos, tree *argarray, unsigned nargs)\n       tree current_arg = argarray[i];\n       if (operand_equal_p (arg, current_arg, 0))\n \t{\n-\t  TREE_VISITED (current_arg) = 1; \n+\t  TREE_VISITED (current_arg) = 1;\n \t  arg_positions.safe_push (i + 1);\n \t}\n     }\n \n   if (arg_positions.is_empty ())\n-    return;\n+    return false;\n \n   int pos;\n   FOR_EACH_VEC_ELT (arg_positions, i, pos)\n@@ -2411,13 +2412,13 @@ warn_for_restrict (unsigned param_pos, tree *argarray, unsigned nargs)\n \trichloc.add_range (EXPR_LOCATION (arg), false);\n     }\n \n-  warning_n (&richloc, OPT_Wrestrict, arg_positions.length (),\n-\t     \"passing argument %i to restrict-qualified parameter\"\n-\t     \" aliases with argument %Z\",\n-\t     \"passing argument %i to restrict-qualified parameter\"\n-\t     \" aliases with arguments %Z\",\n-\t     param_pos + 1, arg_positions.address (),\n-\t     arg_positions.length ());\n+  return warning_n (&richloc, OPT_Wrestrict, arg_positions.length (),\n+\t\t    \"passing argument %i to restrict-qualified parameter\"\n+\t\t    \" aliases with argument %Z\",\n+\t\t    \"passing argument %i to restrict-qualified parameter\"\n+\t\t    \" aliases with arguments %Z\",\n+\t\t    param_pos + 1, arg_positions.address (),\n+\t\t    arg_positions.length ());\n }\n \n /* Callback function to determine whether an expression TP or one of its"}, {"sha": "7771988b83782d0bdcf64d40fe3a68a9678591d5", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -682,11 +682,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n   tree destvar, srcvar;\n   location_t loc = gimple_location (stmt);\n \n-  tree func = gimple_call_fndecl (stmt);\n   bool nowarn = gimple_no_warning_p (stmt);\n-  bool check_overlap = (DECL_FUNCTION_CODE (func) != BUILT_IN_MEMMOVE\n-\t\t\t&& DECL_FUNCTION_CODE (func) != BUILT_IN_MEMMOVE_CHK\n-\t\t\t&& !nowarn);\n \n   /* If the LEN parameter is a constant zero or in range where\n      the only valid value is zero, return DEST.  */\n@@ -713,13 +709,7 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n     {\n       /* Avoid diagnosing exact overlap in calls to __builtin_memcpy.\n \t It's safe and may even be emitted by GCC itself (see bug\n-\t 32667).  However, diagnose it in explicit calls to the memcpy\n-\t function.  */\n-      if (check_overlap && *IDENTIFIER_POINTER (DECL_NAME (func)) != '_')\n-      \twarning_at (loc, OPT_Wrestrict,\n-      \t\t    \"%qD source argument is the same as destination\",\n-      \t\t    func);\n-\n+\t 32667).  */\n       unlink_stmt_vdef (stmt);\n       if (gimple_vdef (stmt) && TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)\n \trelease_ssa_name (gimple_vdef (stmt));\n@@ -1622,11 +1612,14 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n   if (operand_equal_p (src, dest, 0))\n     {\n-      tree func = gimple_call_fndecl (stmt);\n+      if (!gimple_no_warning_p (stmt))\n+\t{\n+\t  tree func = gimple_call_fndecl (stmt);\n \n-      warning_at (loc, OPT_Wrestrict,\n-\t\t  \"%qD source argument is the same as destination\",\n-\t\t  func);\n+\t  warning_at (loc, OPT_Wrestrict,\n+\t\t      \"%qD source argument is the same as destination\",\n+\t\t      func);\n+\t}\n \n       replace_call_with_value (gsi, dest);\n       return true;\n@@ -2499,15 +2492,6 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n      (resp. DEST+LEN for __mempcpy_chk).  */\n   if (fcode != BUILT_IN_MEMSET_CHK && operand_equal_p (src, dest, 0))\n     {\n-      if (fcode != BUILT_IN_MEMMOVE && fcode != BUILT_IN_MEMMOVE_CHK)\n-\t{\n-\t  tree func = gimple_call_fndecl (stmt);\n-\n-\t  warning_at (loc, OPT_Wrestrict,\n-\t\t      \"%qD source argument is the same as destination\",\n-\t\t      func);\n-\t}\n-\n       if (fcode != BUILT_IN_MEMPCPY_CHK)\n \t{\n \t  replace_call_with_value (gsi, dest);\n@@ -2609,11 +2593,14 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n   if (fcode == BUILT_IN_STRCPY_CHK && operand_equal_p (src, dest, 0))\n     {\n-      tree func = gimple_call_fndecl (stmt);\n+      if (!gimple_no_warning_p (stmt))\n+\t{\n+\t  tree func = gimple_call_fndecl (stmt);\n \n-      warning_at (loc, OPT_Wrestrict,\n-\t\t  \"%qD source argument is the same as destination\",\n-\t\t  func);\n+\t  warning_at (loc, OPT_Wrestrict,\n+\t\t      \"%qD source argument is the same as destination\",\n+\t\t      func);\n+\t}\n \n       replace_call_with_value (gsi, dest);\n       return true;"}, {"sha": "a5e3408c4c4d28b6b47b2814a23a0f13ad038610", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -1,3 +1,18 @@\n+2018-03-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/83456\n+\t* c-c++-common/Wrestrict-2.c: Remove test cases.\n+\t* c-c++-common/Wrestrict.c: Same.\n+\t* gcc.dg/Wrestrict-12.c: New test.\n+\t* gcc.dg/Wrestrict-14.c: New test.\n+Index: gcc/c-family/c-common.c\n+===================================================================\n+--- gcc/c-family/c-common.c\t(revision 258366)\n++++ gcc/c-family/c-common.c\t(working copy)\n+@@ -5309,10 +5309,11 @@ check_function_sentinel (const_tree fntype, int na\n+     }\n+ }\n+\n 2018-03-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* g++.dg/pr84821.C: New test."}, {"sha": "c3e9ac82d6412ec8e68b2effd834e937ed7b3d0e", "filename": "gcc/testsuite/c-c++-common/Wrestrict-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict-2.c?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -12,13 +12,13 @@\n \n static void wrap_memcpy (void *d, const void *s, size_t n)\n {\n-  memcpy (d, s, n);   /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n+  memcpy (d, s, n);   /* { dg-warning \"accessing 2 bytes at offsets 0 and 1 overlaps 1 byte at offset 1\" \"memcpy\" } */\n }\n \n-void call_memcpy (void *d, size_t n)\n+void call_memcpy (char *d)\n {\n-  const void *s = d;\n-  wrap_memcpy (d, s, n);\n+  const void *s = d + 1;\n+  wrap_memcpy (d, s, 2);\n }\n \n "}, {"sha": "36a1ffa412c45f7695a6a0160990f16368d2d7ee", "filename": "gcc/testsuite/c-c++-common/Wrestrict.c", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -52,7 +52,6 @@ void test_memcpy_cst (void *d, const void *s)\n   } while (0)\n \n   T (a, a, 0);\n-  T (a, s = a, 3);           /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n \n   /* This isn't detected because memcpy calls with small power-of-2 sizes\n      are intentionally folded into safe copies equivalent to memmove.\n@@ -63,19 +62,6 @@ void test_memcpy_cst (void *d, const void *s)\n   T (a, a + 3, 3);\n   T (a, a + 3, 5);           /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n \n-  {\n-    char a[3] = { 1, 2, 3 };\n-\n-    /* Verify that a call to memcpy with an exact overlap is diagnosed\n-       (also tested above) but an excplicit one to __builtin_memcpy is\n-       not.  See bug 32667 for the rationale.  */\n-    (memcpy)(a, a, sizeof a);   /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n-    sink (a);\n-\n-    __builtin_memcpy (a, a, sizeof a);\n-    sink (a);\n-  }\n-\n   {\n     char a[3][7];\n     sink (a);\n@@ -116,11 +102,6 @@ void test_memcpy_cst (void *d, const void *s)\n     memcpy (d, s, sizeof x.a);\n     sink (&x);\n \n-    d = x.a;\n-    s = x.a;\n-    memcpy (d, s, sizeof x.a);    /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n-    sink (&x);\n-\n     d = x.a + 4;\n     s = x.b;\n     memcpy (d, s, sizeof x.a);    /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n@@ -447,22 +428,10 @@ void test_memcpy_var (char *d, const char *s)\n {\n   size_t n = unsigned_value ();\n \n+  /* Since no copying takes place no warning should be issued.  */\n   memcpy (d, d, 0);\n   sink (d);\n \n-  memcpy (d, d, n);               /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n-  sink (d);\n-\n-  memcpy (d, &d[0], n);           /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n-  sink (d);\n-\n-  memcpy (&d[0], d,  n);          /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n-  sink (d);\n-\n-  s = d;\n-  memcpy (d, s, n);               /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n-  sink (d);\n-\n   /* The following overlaps if n is greater than 1.  */\n   s = d + 1;\n   memcpy (d, s, n);\n@@ -499,10 +468,6 @@ void test_memcpy_var (char *d, const char *s)\n   s = d + 5;\n   n = 7;\n   memcpy (d, s, n);               /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n-\n-  n = UR (0, 1);\n-  s = d;\n-  memcpy (d, s, n);               /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n }\n \n \n@@ -941,7 +906,7 @@ void test_strncpy_range (char *d, size_t n)\n \n   /* The following overlaps except in the unlikely case that value ()\n      is zero, so it's diagnosed.  */\n-  T (\"012\", a, a, n);             /* { dg-warning \"source argument is the same as destination \" \"strncpy\" } */\n+  T (\"012\", a, a, n);             /* { dg-warning \"\\\\\\[-Wrestrict]\" \"strncpy\" } */\n }\n \n "}, {"sha": "84ab6b50d8b39e1808ee7861d9a8a619339c33fe", "filename": "gcc/testsuite/gcc.dg/Wrestrict-12.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-12.c?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -0,0 +1,66 @@\n+/* PR tree-optimization/83456 - -Wrestrict false positive on\n+   a non-overlapping memcpy in an inline function\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wrestrict -ftrack-macro-expansion=0\" }  */\n+\n+extern void* memcpy (void*, const void*, __SIZE_TYPE__);\n+\n+/* Test case from comment #0.  */\n+\n+inline void pr83456_comment0 (void *d, void *s, unsigned N)\n+{\n+  if (s != d)\n+    memcpy (d, s, N);\n+}\n+\n+void call_pr83456_comment0 (void* src)\n+{\n+  pr83456_comment0 (src, src, 1);\n+}\n+\n+\n+/* Test case from comment #1.  */\n+\n+char a[4];\n+\n+void pr83456_comment1 (unsigned n)\n+{\n+  for (int i = 0; i < 1; i++)\n+    {\n+      if (!i)\n+\tcontinue;\n+\n+      memcpy (a, a, n);\n+    }\n+}\n+\n+/* Test case from comment #2.  */\n+\n+struct netdevice {\n+  void *priv;\n+};\n+\n+struct ip_tunnel {\n+  struct netdevice *dev;\n+  int ip6rd[3];\n+};\n+\n+struct sit_net {\n+  struct netdevice *fb_tunnel_dev;\n+};\n+\n+void ipip6_tunnel_clone_6rd (struct netdevice *dev, struct sit_net *sitn)\n+{\n+  struct ip_tunnel *t = dev->priv;\n+  if (t->dev == sitn->fb_tunnel_dev)\n+    return;\n+\n+  struct ip_tunnel *t0 = sitn->fb_tunnel_dev->priv;\n+  memcpy(&t->ip6rd, &t0->ip6rd, sizeof(t->ip6rd));\n+}\n+\n+void sit_init_net (struct sit_net *sitn, struct netdevice *fb_tunnel_dev)\n+{\n+  sitn->fb_tunnel_dev = fb_tunnel_dev;\n+  ipip6_tunnel_clone_6rd (sitn->fb_tunnel_dev, sitn);\n+}"}, {"sha": "b919fa644d39c309dad60201a4ea2b82bfd9b409", "filename": "gcc/testsuite/gcc.dg/Wrestrict-14.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-14.c?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -0,0 +1,221 @@\n+/* PR tree-optimization/83456 - -Wrestrict false positive on a non-overlapping\n+   memcpy in an inline function\n+   Verify that calls to built-in functions are diagnosed when the pointer\n+   arguments to their restrict-qualified parameters are the same (the absence\n+   of the false positives reported in PR 83456 is tested in Wrestrict-12.c.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wrestrict -Wno-stringop-truncation\" }  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memcpy (void* restrict, const void* restrict, size_t);\n+extern void* mempcpy (void* restrict, const void* restrict, size_t);\n+extern char* stpncpy (char* restrict, const char* restrict, size_t);\n+extern char* stpcpy (char* restrict, const char* restrict);\n+extern char* strncat (char* restrict, const char* restrict, size_t);\n+extern char* strcat (char* restrict, const char* restrict);\n+extern char* strncpy (char* restrict, const char* restrict, size_t);\n+extern char* strcpy (char* restrict, const char* restrict);\n+\n+struct S\n+{\n+  char a[4];\n+  char *p;\n+} s;\n+\n+void sink (void*);\n+\n+void test_memcpy (char *p, struct S *q, size_t n)\n+{\n+  /* The behavior of memcpy() is undefined only when when copying takes\n+     place between overlapping objects.  Since a call with a size of zero\n+     does nothing, it should not be diagnosed.  */\n+  memcpy (p, p, 0);\n+  sink (p);\n+\n+  memcpy (p, p, 1);               /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  memcpy (p, p, n);               /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  memcpy (q->a, q->a, 0);\n+  sink (q);\n+\n+  memcpy (q->p, q->p, 1);         /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  memcpy (&q->a[0], q->a, n);     /* { dg-warning \"\\\\\\[-Wrestrict]\" \"bug ????\" { xfail *-*-* } } */\n+  sink (q);\n+\n+  memcpy (q, q->a, n);            /* { dg-warning \"\\\\\\[-Wrestrict]\" \"bug ????\" { xfail *-*-* } } */\n+  sink (q);\n+}\n+\n+void test_mempcpy (char *p, struct S *q, size_t n)\n+{\n+  mempcpy (p, p, 0);\n+  sink (p);\n+\n+  mempcpy (p, p, 1);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  mempcpy (p, p, n);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  mempcpy (q->a, q->a, 0);\n+  sink (q);\n+\n+  mempcpy (q->p, q->p, 1);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  mempcpy (&q->a[0], q->a, n);    /* { dg-warning \"\\\\\\[-Wrestrict]\" \"bug ????\" { xfail *-*-* } } */\n+  sink (q);\n+\n+  mempcpy (q, q->a, n);           /* { dg-warning \"\\\\\\[-Wrestrict]\" \"bug ????\" { xfail *-*-* } } */\n+  sink (q);\n+}\n+\n+void test_strncat (char *p, struct S *q, size_t n)\n+{\n+  strncat (p, p, 0);\n+  sink (p);\n+\n+  strncat (p, p, 1);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strncat (p, p, n);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strncat (q->a, q->a, n);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strncat (&q->a[0], &q->a[0], n);/* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strncat (q->a, &q->a[0], n);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strncat (q->p, &q->p[0], n);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+}\n+\n+void test_strcat (char *p, struct S *q, size_t n)\n+{\n+  strcat (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strcat (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strcat (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strcat (q->a, q->a);            /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strcat (&q->a[0], &q->a[0]);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strcat (q->a, &q->a[0]);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strcat (q->p, &q->p[0]);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+}\n+\n+void test_stpncpy (char *p, struct S *q, size_t n)\n+{\n+  stpncpy (p, p, 0);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  stpncpy (p, p, 1);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  stpncpy (p, p, n);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  stpncpy (q->a, q->a, n);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  stpncpy (&q->a[0], &q->a[0], n);/* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  stpncpy (q->a, &q->a[0], n);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  stpncpy (q->p, &q->p[0], n);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+}\n+\n+void test_stpcpy (char *p, struct S *q, size_t n)\n+{\n+  stpcpy (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  stpcpy (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  stpcpy (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  stpcpy (q->a, q->a);            /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  stpcpy (&q->a[0], &q->a[0]);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  stpcpy (q->a, &q->a[0]);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  stpcpy (q->p, &q->p[0]);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+}\n+\n+void test_strncpy (char *p, struct S *q, size_t n)\n+{\n+  strncpy (p, p, 0);\n+  sink (p);\n+\n+  strncpy (p, p, 1);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strncpy (p, p, n);              /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strncpy (q->a, q->a, n);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strncpy (&q->a[0], &q->a[0], n);/* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strncpy (q->a, &q->a[0], n);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strncpy (q->p, &q->p[0], n);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+}\n+\n+void test_strcpy (char *p, struct S *q, size_t n)\n+{\n+  strcpy (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strcpy (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strcpy (p, p);                  /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (p);\n+\n+  strcpy (q->a, q->a);            /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strcpy (&q->a[0], &q->a[0]);    /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strcpy (q->a, &q->a[0]);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+\n+  strcpy (q->p, &q->p[0]);        /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+  sink (q);\n+}"}, {"sha": "33004b6870d29594985b47ca40e3fcb21bdb3050", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=e9b9fa4cdaedd40ab429c0c98e8801ae039a33e9", "patch": "@@ -1801,6 +1801,8 @@ bool\n maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n {\n   gimple *stmt = gsi_stmt (gsi);\n+  if (gimple_no_warning_p (stmt))\n+    return false;\n \n   wide_int cntrange[2];\n "}]}