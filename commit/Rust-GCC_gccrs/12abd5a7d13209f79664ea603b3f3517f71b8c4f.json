{"sha": "12abd5a7d13209f79664ea603b3f3517f71b8c4f", "node_id": "C_kwDOANBUbNoAKDEyYWJkNWE3ZDEzMjA5Zjc5NjY0ZWE2MDNiM2YzNTE3ZjcxYjhjNGY", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2022-12-15T19:11:05Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2022-12-15T19:19:19Z"}, "message": "IRA: Check that reg classes contain a hard reg of given mode in reg move cost calculation\n\nIRA calculates wrong AVR costs for moving general hard regs of SFmode.  To\ncalculate the costs we did not exclude sub-classes which do not contain\nhard regs of given mode.  This was the reason for spilling a pseudo in the\nPR. The patch fixes this.\n\n        PR rtl-optimization/90706\n\ngcc/ChangeLog:\n\n\t* ira-costs.cc: Include print-rtl.h.\n\t(record_reg_classes, scan_one_insn): Add code to print debug info.\n\t* ira.cc (ira_init_register_move_cost): Check that at least one hard\n\treg of the mode are in the class contents to calculate the\n\tregister move costs.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/avr/pr90706.c: New.", "tree": {"sha": "33ef2dedc4b7ed559a43cd0d965bdf3eefc850eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33ef2dedc4b7ed559a43cd0d965bdf3eefc850eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12abd5a7d13209f79664ea603b3f3517f71b8c4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12abd5a7d13209f79664ea603b3f3517f71b8c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12abd5a7d13209f79664ea603b3f3517f71b8c4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12abd5a7d13209f79664ea603b3f3517f71b8c4f/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b775b4c48a3cc4ef5c50e56144aea02da2e9cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b775b4c48a3cc4ef5c50e56144aea02da2e9cc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b775b4c48a3cc4ef5c50e56144aea02da2e9cc6"}], "stats": {"total": 123, "additions": 112, "deletions": 11}, "files": [{"sha": "732a0edd4c1d26c517046fa17942964d1df42696", "filename": "gcc/ira-costs.cc", "status": "modified", "additions": 93, "deletions": 9, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12abd5a7d13209f79664ea603b3f3517f71b8c4f/gcc%2Fira-costs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12abd5a7d13209f79664ea603b3f3517f71b8c4f/gcc%2Fira-costs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.cc?ref=12abd5a7d13209f79664ea603b3f3517f71b8c4f", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira-int.h\"\n #include \"addresses.h\"\n #include \"reload.h\"\n+#include \"print-rtl.h\"\n \n /* The flags is set up every time when we calculate pseudo register\n    classes through function ira_set_pseudo_classes.  */\n@@ -503,6 +504,18 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n   int insn_allows_mem[MAX_RECOG_OPERANDS];\n   move_table *move_in_cost, *move_out_cost;\n   short (*mem_cost)[2];\n+  const char *p;\n+\n+  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+    {\n+      fprintf (ira_dump_file, \"    Processing insn %u\", INSN_UID (insn));\n+      if (INSN_CODE (insn) >= 0\n+\t  && (p = get_insn_name (INSN_CODE (insn))) != NULL)\n+\tfprintf (ira_dump_file, \" {%s}\", p);\n+      fprintf (ira_dump_file, \" (freq=%d)\\n\",\n+\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn)));\n+      dump_insn_slim (ira_dump_file, insn);\n+  }\n \n   for (i = 0; i < n_ops; i++)\n     insn_allows_mem[i] = 0;\n@@ -526,6 +539,21 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  continue;\n \t}\n \n+      if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+\t{\n+\t  fprintf (ira_dump_file, \"      Alt %d:\", alt);\n+\t  for (i = 0; i < n_ops; i++)\n+\t    {\n+\t      p = constraints[i];\n+\t      if (*p == '\\0')\n+\t\tcontinue;\n+\t      fprintf (ira_dump_file, \"  (%d) \", i);\n+\t      for (; *p != '\\0' && *p != ',' && *p != '#'; p++)\n+\t\tfputc (*p, ira_dump_file);\n+\t    }\n+\t  fprintf (ira_dump_file, \"\\n\");\n+\t}\n+      \n       for (i = 0; i < n_ops; i++)\n \t{\n \t  unsigned char c;\n@@ -593,12 +621,16 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     register, this alternative can't be used.  */\n \n \t\t  if (classes[j] == NO_REGS)\n-\t\t    alt_fail = 1;\n-\t\t  /* Otherwise, add to the cost of this alternative\n-\t\t     the cost to copy the other operand to the hard\n-\t\t     register used for this operand.  */\n+\t\t    {\n+\t\t      alt_fail = 1;\n+\t\t    }\n \t\t  else\n-\t\t    alt_cost += copy_cost (ops[j], mode, classes[j], 1, NULL);\n+\t\t    /* Otherwise, add to the cost of this alternative the cost\n+\t\t       to copy the other operand to the hard register used for\n+\t\t       this operand.  */\n+\t\t    {\n+\t\t      alt_cost += copy_cost (ops[j], mode, classes[j], 1, NULL);\n+\t\t    }\n \t\t}\n \t      else\n \t\t{\n@@ -1021,18 +1053,45 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n       for (i = 0; i < n_ops; i++)\n \tif (REG_P (ops[i]) && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t  {\n+\t    int old_cost;\n+\t    bool cost_change_p = false;\n \t    struct costs *pp = op_costs[i], *qq = this_op_costs[i];\n \t    int *pp_costs = pp->cost, *qq_costs = qq->cost;\n \t    int scale = 1 + (recog_data.operand_type[i] == OP_INOUT);\n \t    cost_classes_t cost_classes_ptr\n \t      = regno_cost_classes[REGNO (ops[i])];\n \n-\t    pp->mem_cost = MIN (pp->mem_cost,\n+\t    old_cost = pp->mem_cost;\n+\t    pp->mem_cost = MIN (old_cost,\n \t\t\t\t(qq->mem_cost + op_cost_add) * scale);\n \n+\t    if (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n+\t\t&& pp->mem_cost < old_cost)\n+\t      {\n+\t\tcost_change_p = true;\n+\t\tfprintf (ira_dump_file, \"        op %d(r=%u) new costs MEM:%d\",\n+\t\t\t i, REGNO(ops[i]), pp->mem_cost);\n+\t      }\n \t    for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t      pp_costs[k]\n-\t\t= MIN (pp_costs[k], (qq_costs[k] + op_cost_add) * scale);\n+\t      {\n+\t\told_cost = pp_costs[k];\n+\t\tpp_costs[k]\n+\t\t  = MIN (old_cost, (qq_costs[k] + op_cost_add) * scale);\n+\t\tif (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n+\t\t    && pp_costs[k] < old_cost)\n+\t\t  {\n+\t\t    if (!cost_change_p)\n+\t\t      fprintf (ira_dump_file, \"        op %d(r=%u) new costs\",\n+\t\t\t       i, REGNO(ops[i]));\n+\t\t    cost_change_p = true;\n+\t\t    fprintf (ira_dump_file, \" %s:%d\",\n+\t\t\t     reg_class_names[cost_classes_ptr->classes[k]],\n+\t\t\t     pp_costs[k]);\n+\t\t  }\n+\t      }\n+\t    if (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n+\t\t&& cost_change_p)\n+\t      fprintf (ira_dump_file, \"\\n\");\n \t  }\n     }\n \n@@ -1506,6 +1565,18 @@ scan_one_insn (rtx_insn *insn)\n \n   record_operand_costs (insn, pref);\n \n+  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+    {\n+      const char *p;\n+      fprintf (ira_dump_file, \"    Final costs after insn %u\", INSN_UID (insn));\n+      if (INSN_CODE (insn) >= 0\n+\t  && (p = get_insn_name (INSN_CODE (insn))) != NULL)\n+\tfprintf (ira_dump_file, \" {%s}\", p);\n+      fprintf (ira_dump_file, \" (freq=%d)\\n\",\n+\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn)));\n+      dump_insn_slim (ira_dump_file, insn);\n+    }\n+\n   /* Now add the cost for each operand to the total costs for its\n      allocno.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n@@ -1521,7 +1592,7 @@ scan_one_insn (rtx_insn *insn)\n \t  struct costs *q = op_costs[i];\n \t  int *p_costs = p->cost, *q_costs = q->cost;\n \t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-\t  int add_cost;\n+\t  int add_cost = 0;\n \t  \n \t  /* If the already accounted for the memory \"cost\" above, don't\n \t     do so again.  */\n@@ -1533,14 +1604,27 @@ scan_one_insn (rtx_insn *insn)\n \t      else\n \t\tp->mem_cost += add_cost;\n \t    }\n+\t  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+\t    {\n+\t      fprintf (ira_dump_file, \"        op %d(r=%u) MEM:%d(+%d)\",\n+\t\t       i, REGNO(op), p->mem_cost, add_cost);\n+\t    }\n \t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n \t    {\n \t      add_cost = q_costs[k];\n \t      if (add_cost > 0 && INT_MAX - add_cost < p_costs[k])\n \t\tp_costs[k] = INT_MAX;\n \t      else\n \t\tp_costs[k] += add_cost;\n+\t      if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+\t\t{\n+\t\t  fprintf (ira_dump_file, \" %s:%d(+%d)\",\n+\t\t\t   reg_class_names[cost_classes_ptr->classes[k]],\n+\t\t\t   p_costs[k], add_cost);\n+\t\t}\n \t    }\n+\t  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+\t    fprintf (ira_dump_file, \"\\n\");\n \t}\n     }\n   return insn;"}, {"sha": "cb4bfca739d42c979022fbc65df6a4c42c4fed1b", "filename": "gcc/ira.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12abd5a7d13209f79664ea603b3f3517f71b8c4f/gcc%2Fira.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12abd5a7d13209f79664ea603b3f3517f71b8c4f/gcc%2Fira.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.cc?ref=12abd5a7d13209f79664ea603b3f3517f71b8c4f", "patch": "@@ -1627,14 +1627,22 @@ ira_init_register_move_cost (machine_mode mode)\n \t\t *p2 != LIM_REG_CLASSES; p2++)\n \t      if (ira_class_hard_regs_num[*p2] > 0\n \t\t  && (ira_reg_class_max_nregs[*p2][mode]\n-\t\t      <= ira_class_hard_regs_num[*p2]))\n+\t\t      <= ira_class_hard_regs_num[*p2])\n+\t\t  && hard_reg_set_intersect_p (ok_regs,\n+\t\t\t\t\t       reg_class_contents[cl1])\n+\t\t  && hard_reg_set_intersect_p (ok_regs,\n+\t\t\t\t\t       reg_class_contents[*p2]))\n \t\tcost = MAX (cost, ira_register_move_cost[mode][cl1][*p2]);\n \t    \n \t    for (p1 = &reg_class_subclasses[cl1][0];\n \t\t *p1 != LIM_REG_CLASSES; p1++)\n \t      if (ira_class_hard_regs_num[*p1] > 0\n \t\t  && (ira_reg_class_max_nregs[*p1][mode]\n-\t\t      <= ira_class_hard_regs_num[*p1]))\n+\t\t      <= ira_class_hard_regs_num[*p1])\n+\t\t  && hard_reg_set_intersect_p (ok_regs,\n+\t\t\t\t\t       reg_class_contents[cl2])\n+\t\t  && hard_reg_set_intersect_p (ok_regs,\n+\t\t\t\t\t       reg_class_contents[*p1]))\n \t\tcost = MAX (cost, ira_register_move_cost[mode][*p1][cl2]);\n \t    \n \t    ira_assert (cost <= 65535);"}, {"sha": "4b9bcbe115271bd084c0295cec6503912e31180b", "filename": "gcc/testsuite/gcc.target/avr/pr90706.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12abd5a7d13209f79664ea603b3f3517f71b8c4f/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12abd5a7d13209f79664ea603b3f3517f71b8c4f/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c?ref=12abd5a7d13209f79664ea603b3f3517f71b8c4f", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os\" } */\n+ \n+unsigned char check(float x)\n+{\n+   return (0.0 < x);\n+}\n+ /* { dg-final { scan-assembler-not \"ldd\" } } */\n+ /* { dg-final { scan-assembler-not \"std\" } } */"}]}