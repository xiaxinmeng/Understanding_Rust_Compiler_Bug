{"sha": "28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhiNmI5YjJkM2E1MTQxZDVlOTA1NWVkODg0ZDVkZGM1ZTVkYzMzNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-27T12:57:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-27T12:57:35Z"}, "message": "* loop.c (load_mems)  Don't use hard registers for the hoisting.\n\n\t* unroll.c (unroll_loop): Avoid overflow in the n_iterations\n\tcalculation; rename const_equiv array in the preconditioning code\n\tfrom loop_unroll to loop_unroll_precondition\n\nFrom-SVN: r33480", "tree": {"sha": "172d402a32e47ad7c82ca5132277d43782e4df26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/172d402a32e47ad7c82ca5132277d43782e4df26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335/comments", "author": null, "committer": null, "parents": [{"sha": "af4464eb46fd1fcec3a8f69b320fa069f3d179a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af4464eb46fd1fcec3a8f69b320fa069f3d179a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af4464eb46fd1fcec3a8f69b320fa069f3d179a0"}], "stats": {"total": 20, "additions": 18, "deletions": 2}, "files": [{"sha": "5268b8f10616f675d9f47da92eb009fd149c5e14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335", "patch": "@@ -1,3 +1,11 @@\n+Thu Apr 27 14:54:22 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop.c (load_mems)  Don't use hard registers for the hoisting.\n+\n+\t* unroll.c (unroll_loop): Avoid overflow in the n_iterations\n+\tcalculation; rename const_equiv array in the preconditioning code\n+\tfrom loop_unroll to loop_unroll_precondition\n+\n 2000-04-27  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (struct propagate_block_info): Remove new_dead, new_live;"}, {"sha": "02ac5d721a649a84d7ce69dd8d45327e1452c193", "filename": "gcc/loop.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335", "patch": "@@ -9887,7 +9887,13 @@ load_mems (loop)\n \t\t{\n \t\t  if (CONSTANT_P (equiv->loc))\n \t\t    const_equiv = equiv;\n-\t\t  else if (GET_CODE (equiv->loc) == REG)\n+\t\t  else if (GET_CODE (equiv->loc) == REG\n+\t\t\t   /* Extending hard register lifetimes cuases crash\n+\t\t\t      on SRC targets.  Doing so on non-SRC is\n+\t\t\t      probably also not good idea, since we most\n+\t\t\t      probably have pseudoregister equivalence as\n+\t\t\t      well.  */\n+\t\t\t   && REGNO (equiv->loc) >= FIRST_PSEUDO_REGISTER)\n \t\t    best_equiv = equiv;\n \t\t}\n \t      /* Use the constant equivalence if that is cheap enough.  */"}, {"sha": "6ecef3246129b710dd22bebfd85a8fe69ff134e9", "filename": "gcc/unroll.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=28b6b9b2d3a5141d5e9055ed884d5ddc5e5dc335", "patch": "@@ -385,6 +385,8 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n       return;\n     }\n   else if (loop_info->n_iterations > 0\n+\t   /* Avoid overflow in the next expression.  */\n+\t   && loop_info->n_iterations < MAX_UNROLLED_INSNS\n \t   && loop_info->n_iterations * insn_count < MAX_UNROLLED_INSNS)\n     {\n       unroll_number = loop_info->n_iterations;\n@@ -906,7 +908,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t  map->reg_map = (rtx *) xmalloc (maxregnum * sizeof (rtx));\n \n \t  VARRAY_CONST_EQUIV_INIT (map->const_equiv_varray, maxregnum,\n-\t\t\t\t   \"unroll_loop\");\n+\t\t\t\t   \"unroll_loop_precondition\");\n \t  global_const_equiv_varray = map->const_equiv_varray;\n \n \t  init_reg_map (map, maxregnum);"}]}