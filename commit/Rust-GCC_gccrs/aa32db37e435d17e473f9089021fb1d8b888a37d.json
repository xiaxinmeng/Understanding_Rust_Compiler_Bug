{"sha": "aa32db37e435d17e473f9089021fb1d8b888a37d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEzMmRiMzdlNDM1ZDE3ZTQ3M2Y5MDg5MDIxZmIxZDhiODg4YTM3ZA==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2015-07-14T23:16:43Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2015-07-14T23:16:43Z"}, "message": "predicates.md (pop_operation): New.\n\n2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Cesar Philippidis  <cesar@codesourcery.com>\n\t    Chung-Lin Tang  <cltang@codesourcery.com>\n\n\tgcc/\n\t* config/nios2/predicates.md (pop_operation): New.\n\t(ldwm_operation, stwm_operation): New.\n\t(nios2_hard_register_operand): New.\n\t* config/nios2/nios2-protos.h (pop_operation_p): Declare.\n\t(ldstwm_operation_p): Declare.\n\t(gen_ldstwm_peep): Declare.\n\t* config/nios2/nios2.c: (nios2_ldst_parallel): Declare.\n\t(base_reg_adjustment_p): New.\n\t(pop_operation_p): New.\n\t(CDX_LDSTWM_VALID_REGS_0, CDX_LDSTWM_VALID_REGS_1): Define.\n\t(nios2_ldstwm_regset_p): New.\n\t(ldstwm_operation_p): New.\n\t(gen_ldst): New.\n\t(nios2_ldst_parallel): New.\n\t(struct ldswm_operand): Declare.\n\t(compare_ldstwm_operands): New.\n\t(can_use_cdx_ldstw): New.\n\t(gen_ldstwm_peep): New.\n\t* config/nios2/nios2-ldstwm.sml: New.\n\t* config/nios2/nios2.md: Include ldstwm.md.\n\t* config/nios2/ldstwm.md: Generated.\n\n\tgcc/testsuite/\n\t* gcc.target/nios2/cdx-ldstwm-1.c: New.\n\t* gcc.target/nios2/cdx-ldstwm-2.c: New.\n\nCo-Authored-By: Cesar Philippidis <cesar@codesourcery.com>\nCo-Authored-By: Chung-Lin Tang <cltang@codesourcery.com>\n\nFrom-SVN: r225798", "tree": {"sha": "c3c61e120f7c564f6dda267aaadbc265d34d0e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3c61e120f7c564f6dda267aaadbc265d34d0e80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa32db37e435d17e473f9089021fb1d8b888a37d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa32db37e435d17e473f9089021fb1d8b888a37d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa32db37e435d17e473f9089021fb1d8b888a37d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa32db37e435d17e473f9089021fb1d8b888a37d/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3bbbe009de4f810f7240eae51e45d861582ecf79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbbe009de4f810f7240eae51e45d861582ecf79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bbbe009de4f810f7240eae51e45d861582ecf79"}], "stats": {"total": 5068, "additions": 5068, "deletions": 0}, "files": [{"sha": "ea870244f520555adf73c701c47bbba6d0ef60c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -1,3 +1,29 @@\n+2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* config/nios2/predicates.md (pop_operation): New.\n+\t(ldwm_operation, stwm_operation): New.\n+\t(nios2_hard_register_operand): New.\n+\t* config/nios2/nios2-protos.h (pop_operation_p): Declare.\n+\t(ldstwm_operation_p): Declare.\n+\t(gen_ldstwm_peep): Declare.\n+\t* config/nios2/nios2.c: (nios2_ldst_parallel): Declare.\n+\t(base_reg_adjustment_p): New.\n+\t(pop_operation_p): New.\n+\t(CDX_LDSTWM_VALID_REGS_0, CDX_LDSTWM_VALID_REGS_1): Define.\n+\t(nios2_ldstwm_regset_p): New.\n+\t(ldstwm_operation_p): New.\n+\t(gen_ldst): New.\n+\t(nios2_ldst_parallel): New.\n+\t(struct ldswm_operand): Declare.\n+\t(compare_ldstwm_operands): New.\n+\t(can_use_cdx_ldstw): New.\n+\t(gen_ldstwm_peep): New.\n+\t* config/nios2/nios2-ldstwm.sml: New.\n+\t* config/nios2/nios2.md: Include ldstwm.md.\n+\t* config/nios2/ldstwm.md: Generated.\n+\n 2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n \t    Chung-Lin Tang  <cltang@codesourcery.com>"}, {"sha": "828bf494c692682b9b174d3cb7e8fd06b54c0c74", "filename": "gcc/config/nios2/ldstwm.md", "status": "added", "additions": 4190, "deletions": 0, "changes": 4190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fldstwm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fldstwm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fldstwm.md?ref=aa32db37e435d17e473f9089021fb1d8b888a37d"}, {"sha": "baff780b050fbff184b010a7864659574566d3eb", "filename": "gcc/config/nios2/nios2-ldstwm.sml", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fnios2-ldstwm.sml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fnios2-ldstwm.sml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2-ldstwm.sml?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -0,0 +1,277 @@\n+(* Auto-generate Nios II R2 CDX ldwm/stwm/push.n/pop.n patterns\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+   Contributed by Mentor Graphics.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.\n+\n+   This is a Standard ML program.  There are multiple Standard ML\n+   implementations widely available.  We recommend the MLton optimizing\n+   SML compiler, due to its ease of creating a standalone executable.\n+\n+     http://www.mlton.org/\n+\n+   Or from your favourite OS's friendly packaging system. Tested with\n+   MLton Release 20130715, though other versions will probably work too.\n+\n+   Run with:\n+     mlton -output a.out /path/to/gcc/config/nios2/nios2-ldstwm.sml\n+     ./a.out >/path/to/gcc/config/nios2/ldstwm.md\n+*)\n+\n+datatype ld_st = ld | st;    \n+datatype push_pop = push | pop;\n+datatype inc_dec = inc | dec;\n+\n+fun for ls f = map f ls;\n+fun conds cond str = if cond then str else \"\";\n+fun ints n = if n>=0 then (Int.toString n) else (\"-\" ^ (Int.toString (~n)));\n+\n+fun pushpop_pattern pptype n fp =\n+    let \n+\tval sp_reg = \"(reg:SI SP_REGNO)\";\n+\tval ra_reg = \"(reg:SI RA_REGNO)\";\n+\tval fp_reg = \"(reg:SI FP_REGNO)\";\n+\n+\tfun sets lhs rhs = \"(set \" ^ lhs ^\n+\t\t\t   (if pptype=push then \" \"\n+\t\t\t    else \" \") ^ rhs ^ \")\";\n+\tval sp_adj =\n+\t    \"(set \" ^ sp_reg ^ \"\\n          \" ^\n+\t    \"(plus:SI \" ^ sp_reg ^\n+\t    \" (match_operand 1 \\\"const_int_operand\\\" \\\"\\\")))\";\n+\n+\tfun reg i regi = \"(reg:SI \" ^ (ints regi) ^ \")\";\n+\tfun mem i opndi =\n+\t    if pptype=push then\n+\t\t\"(mem:SI (plus:SI (reg:SI SP_REGNO) (const_int \" ^ (ints (~4*i)) ^ \")))\"\n+\t    else\n+\t\t\"(match_operand:SI \" ^\n+\t\t(ints opndi) ^ \" \\\"stack_memory_operand\\\" \\\"\\\")\";\n+\n+\tval start = 1 + (if fp then 2 else 1);\n+\tval lim = n + (if fp then 2 else 1);\n+\tfun set_elt i regi opndi =\n+\t    if pptype=push then (sets (mem i opndi) (reg i regi))\n+\t    else (sets (reg i regi) (mem i opndi));\n+\tfun get_elt_list (i, regi, opndi) =\n+\t    if i > lim then []\n+\t    else (set_elt i regi opndi) :: get_elt_list (i+1, regi-1, opndi+1);\n+\n+\tval set_elements = get_elt_list (start, 16+n-1, start+1);\n+\n+\tval ra_set = if pptype=push then sets (mem 1 2) ra_reg\n+\t\t     else sets ra_reg (mem 1 2);\n+\tval fp_set = (conds fp (if pptype=push then sets (mem 2 3) fp_reg\n+\t\t\t\telse sets fp_reg (mem 2 3)));\n+\tval ret = (conds (pptype=pop) \"(return)\");\n+\tval element_list =\n+\t    List.filter (fn x => x<>\"\")\n+\t\t\t([ret, sp_adj, ra_set, fp_set] @ set_elements);\n+\n+\tfun reg_index i = 16 + n - i;\n+\tfun pop_opnds 0 spl = (conds fp (\"fp\" ^ spl)) ^ \"ra\"\n+\t  | pop_opnds n spl = \"r\" ^ (ints (reg_index n)) ^ spl ^ (pop_opnds (n-1) spl);\n+\tfun push_opnds 0 spl = \"ra\" ^ (conds fp (spl ^ \"fp\"))\n+\t  | push_opnds n spl = (push_opnds (n-1) spl) ^ spl ^ \"r\" ^ (ints (reg_index n));\n+\n+\tval spadj_opnd = if pptype=push then 2 else (start+n);\n+\tval spadj = ints spadj_opnd;\n+\tval regsave_num = n + (if fp then 2 else 1);\n+\n+\tval ppname = if pptype=push then \"push\" else \"pop\";\n+\tval name = if pptype=push then \"push\" ^ \"_\" ^ (push_opnds n \"_\")\n+\t\t   else \"pop\" ^ \"_\" ^ (pop_opnds n \"_\");\n+    in\n+\t\"(define_insn \\\"*cdx_\" ^ name ^ \"\\\"\\n\" ^\n+\t\"  [(match_parallel 0 \\\"\" ^\n+\t(conds (pptype=pop) \"pop_operation\") ^ \"\\\"\\n\" ^\n+\t\"    [\" ^ (String.concatWith (\"\\n     \") element_list) ^ \"])]\\n\" ^\n+\t\"   \\\"TARGET_HAS_CDX && XVECLEN (operands[0], 0) == \" ^\n+\t(ints (length element_list)) ^\n+\t(conds (pptype=push)\n+\t       (\"\\n    && (-INTVAL (operands[1]) & 3) == 0\\n\" ^\n+\t\t\"    && (-INTVAL (operands[1]) - \" ^\n+\t\t(ints (4*regsave_num)) ^ \") <= 60\")) ^\n+\t\"\\\"\\n\" ^\n+\t(if pptype=pop then\n+\t     \"{\\n\" ^\n+\t     \"  rtx x = XEXP (operands[\" ^ spadj ^ \"], 0);\\n\" ^\n+\t     \"  operands[\" ^ spadj ^ \"] = REG_P (x) ? const0_rtx : XEXP (x, 1);\\n\" ^\n+\t     \"  return \\\"pop.n\\\\\\\\t{\" ^ (pop_opnds n \", \") ^ \"}, %\" ^ spadj ^ \"\\\";\\n\" ^\n+\t     \"}\\n\"\n+\t else\n+\t     \"{\\n\" ^\n+\t     \"  operands[\" ^ spadj ^ \"] = \" ^\n+\t     \"GEN_INT (-INTVAL (operands[1]) - \" ^ (ints (4*regsave_num)) ^ \");\\n\" ^\n+\t     \"  return \\\"push.n\\\\\\\\t{\" ^ (push_opnds n \", \") ^ \"}, %\" ^ spadj ^ \"\\\";\\n\" ^\n+\t     \"}\\n\") ^\n+\t\"  [(set_attr \\\"type\\\" \\\"\" ^ ppname ^ \"\\\")])\\n\\n\"\n+    end;\n+\n+fun ldstwm_pattern ldst n id wb pc =\n+    let\n+\tval ldstwm = (if ldst=ld then \"ldwm\" else \"stwm\");\n+\tval name = \"*cdx_\" ^ ldstwm ^ (Int.toString n) ^\n+\t\t   (if id=inc then \"_inc\" else \"_dec\") ^\n+\t\t   (conds wb \"_wb\") ^ (conds pc \"_ret\");\n+\tval base_reg_referenced_p = ref false;\n+\tval base_regno = ints (n+1);\n+\tfun plus_addr base offset =\n+\t    \"(plus:SI \" ^ base ^ \" (const_int \" ^ (ints offset) ^ \"))\";\n+\tfun base_reg () =\n+\t    if !base_reg_referenced_p then\n+\t\t\"(match_dup \" ^ base_regno ^ \")\"\n+\t    else (base_reg_referenced_p := true;\n+\t\t  \"(match_operand:SI \" ^ base_regno ^\n+\t\t  \" \\\"register_operand\\\" \\\"\" ^ (conds wb \"+&\") ^ \"r\\\")\");\n+\tfun reg i = \"(match_operand:SI \" ^ (ints i) ^\n+\t\t    \" \\\"nios2_hard_register_operand\\\" \\\"\" ^\n+\t\t    (conds (ldst=ld) \"\") ^ \"\\\")\";\n+\n+\tfun addr 1 = if id=inc then base_reg ()\n+\t\t     else plus_addr (base_reg ()) (~4)\n+\t  | addr i = let val offset = if id=inc then (i-1)*4 else (~i*4)\n+\t\t     in plus_addr (base_reg ()) offset end;\n+\n+\tfun mem i = \"(mem:SI \" ^ (addr i) ^ \")\";\n+\tfun lhs i = if ldst=ld then reg i else mem i;\n+\tfun rhs i = if ldst=st then reg i else mem i;\n+\tfun sets lhs rhs = \"(set \" ^ lhs ^ \"\\n          \" ^ rhs ^ \")\";\n+\tfun set_elements i =\n+\t    if i > n then []\n+\t    else (sets (lhs i) (rhs i)) :: (set_elements (i+1));\n+\n+\tfun opnds 1 = \"%1\"\n+\t  | opnds n = opnds(n-1) ^ \", %\" ^ (Int.toString n);\n+\n+\tval asm_template = ldstwm ^ \"\\\\\\\\t{\" ^ (opnds n) ^ \"}\" ^\n+\t\t\t   (if id=inc\n+\t\t\t    then \", (%\" ^ base_regno ^ \")++\"\n+\t\t\t    else \", --(%\" ^ base_regno ^ \")\") ^\n+\t\t\t   (conds wb \", writeback\") ^\n+\t\t\t   (conds pc \", ret\");\n+\tval wbtmp =\n+\t    if wb then\n+\t\t(sets (base_reg ())\n+\t\t      (plus_addr (base_reg ())\n+\t\t\t\t ((if id=inc then n else ~n)*4)))\n+\t    else \"\";\n+\tval pctmp = conds pc \"(return)\";\n+\tval set_list = List.filter (fn x => x<>\"\")\n+\t\t\t\t   ([pctmp, wbtmp] @ (set_elements 1));\n+    in\n+\tif ldst=st andalso pc then \"\"\n+\telse\n+\t    \"(define_insn \\\"\" ^ name ^ \"\\\"\\n\" ^\n+\t    \"  [(match_parallel 0 \\\"\" ^ ldstwm ^  \"_operation\\\"\\n\" ^\n+\t    \"    [\" ^ (String.concatWith (\"\\n     \") set_list) ^ \"])]\\n\" ^\n+\t    \"   \\\"TARGET_HAS_CDX && XVECLEN (operands[0], 0) == \" ^\n+\t    (ints (length set_list)) ^ \"\\\"\\n\" ^\n+\t    \"   \\\"\" ^ asm_template ^ \"\\\"\\n\" ^\n+\t    \"  [(set_attr \\\"type\\\" \\\"\" ^ ldstwm ^ \"\\\")])\\n\\n\"\n+    end;\n+\n+fun peephole_pattern ldst n scratch_p =\n+    let\n+\tfun sets lhs rhs = \"(set \" ^ lhs ^ \"\\n        \" ^ rhs ^ \")\";\n+\tfun single_set i indent =\n+\t    let val reg = \"(match_operand:SI \" ^ (ints i) ^\n+\t\t\t  \" \\\"register_operand\\\" \\\"\\\")\";\n+\t\tval mem = \"(match_operand:SI \" ^ (ints (i+n)) ^\n+\t\t\t  \" \\\"memory_operand\\\" \\\"\\\")\";\n+\t    in\n+\t\tif ldst=ld then sets reg mem\n+\t\telse sets mem reg\n+\t    end;\n+\n+\tfun single_sets i =\n+\t    if i=n then []\n+\t    else (single_set i \"   \") :: (single_sets (i+1));\n+\n+\tval scratch = ints (2*n);\n+\tval peephole_elements =\n+\t    let val tmp = single_sets 0 in\n+\t\tif scratch_p\n+\t\tthen ([\"(match_scratch:SI \" ^ scratch ^ \" \\\"r\\\")\"] @\n+\t\t      tmp @\n+\t\t      [\"(match_dup \" ^ scratch ^ \")\"])\n+\t\telse tmp\n+\t    end;\n+    in\n+\t\"(define_peephole2\\n\" ^\n+\t\"  [\" ^ (String.concatWith (\"\\n   \") peephole_elements) ^ \"]\\n\" ^\n+\t\"  \\\"TARGET_HAS_CDX\\\"\\n\" ^\n+\t\"  [(const_int 0)]\\n\" ^\n+\t\"{\\n\" ^\n+\t\"  if (gen_ldstwm_peep (\" ^\n+\t(if ldst=st then \"false\" else \"true\") ^ \", \" ^ (ints n) ^ \", \" ^ \n+\t(if scratch_p then (\"operands[\" ^ scratch ^ \"]\") else \"NULL_RTX\") ^\n+\t\", operands))\\n\" ^\n+\t\"    DONE;\\n\" ^\n+\t\"  else\\n\" ^\n+\t\"    FAIL;\\n\" ^\n+\t\"})\\n\\n\"\n+    end;\n+\n+\n+print\n+(\"/* Nios II R2 CDX ldwm/stwm/push.h/pop.n instruction patterns.\\n\" ^\n+ \"   This file was automatically generated using nios2-ldstwm.sml.\\n\" ^\n+ \"   Please do not edit manually.\\n\" ^\n+ \"\\n\" ^\n+ \"   Copyright (C) 2014-2015 Free Software Foundation, Inc.\\n\" ^\n+ \"   Contributed by Mentor Graphics.\\n\" ^\n+ \"\\n\" ^\n+ \"   This file is part of GCC.\\n\" ^\n+ \"\\n\" ^\n+ \"   GCC is free software; you can redistribute it and/or modify it\\n\" ^\n+ \"   under the terms of the GNU General Public License as published\\n\" ^\n+ \"   by the Free Software Foundation; either version 3, or (at your\\n\" ^\n+ \"   option) any later version.\\n\" ^\n+ \"\\n\" ^\n+ \"   GCC is distributed in the hope that it will be useful, but WITHOUT\\n\" ^\n+ \"   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\\n\" ^\n+ \"   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\\n\" ^\n+ \"   License for more details.\\n\" ^\n+ \"\\n\" ^\n+ \"   You should have received a copy of the GNU General Public License and\\n\" ^\n+ \"   a copy of the GCC Runtime Library Exception along with this program;\\n\" ^\n+ \"   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\\n\" ^\n+ \"   <http://www.gnu.org/licenses/>.  */\\n\\n\");\n+\n+fun seq a b = if a=b then [b]\n+\t      else a :: (seq (if a<b then a+1 else a-1) b);\n+\n+(* push/pop patterns *)\n+for (seq 0 8) (fn n =>\n+  for [push, pop] (fn p =>\n+    for [true, false] (fn fp =>\n+       print (pushpop_pattern p n fp))));\n+\n+(* ldwm/stwm patterns *)\n+for [ld, st] (fn l =>\n+  for (seq 1 12) (fn n =>\n+    for [inc, dec] (fn id =>\n+      for [true, false] (fn wb =>\n+        for [true, false] (fn pc =>\n+          print (ldstwm_pattern l n id wb pc))))));\n+\n+(* peephole patterns *)\n+for [ld, st] (fn l =>\n+  for (seq 12 2) (fn n =>\n+    print (peephole_pattern l n true)));\n+"}, {"sha": "f30f813b0e0662aab2b9a03e41d562c44e8678af", "filename": "gcc/config/nios2/nios2-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -52,6 +52,10 @@ extern bool nios2_unspec_reloc_p (rtx);\n extern int nios2_label_align (rtx);\n extern bool nios2_cdx_narrow_form_p (rtx_insn *);\n \n+extern bool pop_operation_p (rtx);\n+extern bool ldstwm_operation_p (rtx, bool);\n+extern bool gen_ldstwm_peep (bool, int, rtx, rtx *);\n+\n extern void nios2_adjust_reg_alloc_order (void);\n \n #ifdef TREE_CODE"}, {"sha": "bf8f4084ce21da3aa9ac5c952fef2700ea6fb60d", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -71,6 +71,8 @@ static void nios2_load_pic_register (void);\n static void nios2_register_custom_code (unsigned int, enum nios2_ccs_code, int);\n static const char *nios2_unspec_reloc_name (int);\n static void nios2_register_builtin_fndecl (unsigned, tree);\n+static rtx nios2_ldst_parallel (bool, bool, bool, rtx, int,\n+\t\t\t\tunsigned HOST_WIDE_INT, bool);\n \n /* Threshold for data being put into the small data/bss area, instead\n    of the normal data area (references to the small data/bss area take\n@@ -456,6 +458,25 @@ restore_reg (int regno, unsigned offset)\n   RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n+/* This routine tests for the base register update SET in load/store\n+   multiple RTL insns, used in pop_operation_p and ldstwm_operation_p.  */\n+static bool\n+base_reg_adjustment_p (rtx set, rtx *base_reg, rtx *offset)\n+{\n+  if (GET_CODE (set) == SET\n+      && REG_P (SET_DEST (set))\n+      && GET_CODE (SET_SRC (set)) == PLUS\n+      && REG_P (XEXP (SET_SRC (set), 0))\n+      && rtx_equal_p (SET_DEST (set), XEXP (SET_SRC (set), 0))\n+      && CONST_INT_P (XEXP (SET_SRC (set), 1)))\n+    {\n+      *base_reg = XEXP (SET_SRC (set), 0);\n+      *offset = XEXP (SET_SRC (set), 1);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Temp regno used inside prologue/epilogue.  */\n #define TEMP_REG_NUM 8\n \n@@ -4030,6 +4051,432 @@ nios2_cdx_narrow_form_p (rtx_insn *insn)\n   return false;\n }\n \n+/* Main function to implement the pop_operation predicate that\n+   check pop.n insn pattern integrity.  The CDX pop.n patterns mostly\n+   hardcode the restored registers, so the main checking is for the\n+   SP offsets.  */\n+bool\n+pop_operation_p (rtx op)\n+{\n+  int i;\n+  HOST_WIDE_INT last_offset = -1, len = XVECLEN (op, 0);\n+  rtx base_reg, offset;\n+\n+  if (len < 3 /* At least has a return, SP-update, and RA restore.  */\n+      || GET_CODE (XVECEXP (op, 0, 0)) != RETURN\n+      || !base_reg_adjustment_p (XVECEXP (op, 0, 1), &base_reg, &offset)\n+      || !rtx_equal_p (base_reg, stack_pointer_rtx)\n+      || !CONST_INT_P (offset)\n+      || (INTVAL (offset) & 3) != 0)\n+    return false;\n+\n+  for (i = len - 1; i > 1; i--)\n+    {\n+      rtx set = XVECEXP (op, 0, i);\n+      rtx curr_base_reg, curr_offset;\n+\n+      if (GET_CODE (set) != SET || !MEM_P (SET_SRC (set))\n+\t  || !split_mem_address (XEXP (SET_SRC (set), 0),\n+\t\t\t\t &curr_base_reg, &curr_offset)\n+\t  || !rtx_equal_p (base_reg, curr_base_reg)\n+\t  || !CONST_INT_P (curr_offset))\n+\treturn false;\n+      if (i == len - 1)\n+\t{\n+\t  last_offset = INTVAL (curr_offset);\n+\t  if ((last_offset & 3) != 0 || last_offset > 60)\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  last_offset += 4;\n+\t  if (INTVAL (curr_offset) != last_offset)\n+\t    return false;\n+\t}\n+    }\n+  if (last_offset < 0 || last_offset + 4 != INTVAL (offset))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Masks of registers that are valid for CDX ldwm/stwm instructions.\n+   The instruction can encode subsets drawn from either R2-R13 or\n+   R14-R23 + FP + RA.  */\n+#define CDX_LDSTWM_VALID_REGS_0 0x00003ffc\n+#define CDX_LDSTWM_VALID_REGS_1 0x90ffc000\n+\n+static bool\n+nios2_ldstwm_regset_p (unsigned int regno, unsigned int *regset)\n+{\n+  if (*regset == 0)\n+    {\n+      if (CDX_LDSTWM_VALID_REGS_0 & (1 << regno))\n+\t*regset = CDX_LDSTWM_VALID_REGS_0;\n+      else if (CDX_LDSTWM_VALID_REGS_1 & (1 << regno))\n+\t*regset = CDX_LDSTWM_VALID_REGS_1;\n+      else\n+\treturn false;\n+      return true;\n+    }\n+  else\n+    return (*regset & (1 << regno)) != 0;\n+}\n+\n+/* Main function to implement ldwm_operation/stwm_operation\n+   predicates that check ldwm/stwm insn pattern integrity.  */\n+bool\n+ldstwm_operation_p (rtx op, bool load_p)\n+{\n+  int start, i, end = XVECLEN (op, 0) - 1, last_regno = -1;\n+  unsigned int regset = 0;\n+  rtx base_reg, offset;  \n+  rtx first_elt = XVECEXP (op, 0, 0);\n+  bool inc_p = true;\n+  bool wb_p = base_reg_adjustment_p (first_elt, &base_reg, &offset);\n+  if (GET_CODE (XVECEXP (op, 0, end)) == RETURN)\n+    end--;\n+  start = wb_p ? 1 : 0;\n+  for (i = start; i <= end; i++)\n+    {\n+      int regno;\n+      rtx reg, mem, elt = XVECEXP (op, 0, i);\n+      /* Return early if not a SET at all.  */\n+      if (GET_CODE (elt) != SET)\n+\treturn false;\n+      reg = load_p ? SET_DEST (elt) : SET_SRC (elt);\n+      mem = load_p ? SET_SRC (elt) : SET_DEST (elt);\n+      if (!REG_P (reg) || !MEM_P (mem))\n+\treturn false;\n+      regno = REGNO (reg);\n+      if (!nios2_ldstwm_regset_p (regno, &regset))\n+\treturn false;\n+      /* If no writeback to determine direction, use offset of first MEM.  */\n+      if (wb_p)\n+\tinc_p = INTVAL (offset) > 0;\n+      else if (i == start)\n+\t{\n+\t  rtx first_base, first_offset;\n+\t  if (!split_mem_address (XEXP (mem, 0),\n+\t\t\t\t  &first_base, &first_offset))\n+\t    return false;\n+\t  base_reg = first_base;\n+\t  inc_p = INTVAL (first_offset) >= 0;\n+\t}\n+      /* Ensure that the base register is not loaded into.  */\n+      if (load_p && regno == (int) REGNO (base_reg))\n+\treturn false;\n+      /* Check for register order inc/dec integrity.  */\n+      if (last_regno >= 0)\n+\t{\n+\t  if (inc_p && last_regno >= regno)\n+\t    return false;\n+\t  if (!inc_p && last_regno <= regno)\n+\t    return false;\n+\t}\n+      last_regno = regno;\n+    }\n+  return true;\n+}\n+\n+/* Helper for nios2_ldst_parallel, for generating a parallel vector\n+   SET element.  */\n+static rtx\n+gen_ldst (bool load_p, int regno, rtx base_mem, int offset)\n+{\n+  rtx reg = gen_rtx_REG (SImode, regno);\n+  rtx mem = adjust_address_nv (base_mem, SImode, offset);\n+  return gen_rtx_SET (load_p ? reg : mem,\n+\t\t      load_p ? mem : reg);\n+}\n+\n+/* A general routine for creating the body RTL pattern of\n+   ldwm/stwm/push.n/pop.n insns.\n+   LOAD_P: true/false for load/store direction.\n+   REG_INC_P: whether registers are incrementing/decrementing in the\n+   *RTL vector* (not necessarily the order defined in the ISA specification).\n+   OFFSET_INC_P: Same as REG_INC_P, but for the memory offset order.\n+   BASE_MEM: starting MEM.\n+   BASE_UPDATE: amount to update base register; zero means no writeback.\n+   REGMASK: register mask to load/store.\n+   RET_P: true if to tag a (return) element at the end.\n+\n+   Note that this routine does not do any checking. It's the job of the\n+   caller to do the right thing, and the insn patterns to do the\n+   safe-guarding.  */\n+static rtx\n+nios2_ldst_parallel (bool load_p, bool reg_inc_p, bool offset_inc_p,\n+\t\t     rtx base_mem, int base_update,\n+\t\t     unsigned HOST_WIDE_INT regmask, bool ret_p)\n+{\n+  rtvec p;\n+  int regno, b = 0, i = 0, n = 0, len = popcount_hwi (regmask);\n+  if (ret_p) len++, i++, b++;\n+  if (base_update != 0) len++, i++;\n+  p = rtvec_alloc (len);\n+  for (regno = (reg_inc_p ? 0 : 31);\n+       regno != (reg_inc_p ? 32 : -1);\n+       regno += (reg_inc_p ? 1 : -1))\n+    if ((regmask & (1 << regno)) != 0)\n+      {\n+\tint offset = (offset_inc_p ? 4 : -4) * n++;\n+\tRTVEC_ELT (p, i++) = gen_ldst (load_p, regno, base_mem, offset);\n+      }\n+  if (ret_p)\n+    RTVEC_ELT (p, 0) = ret_rtx;\n+  if (base_update != 0)\n+    {\n+      rtx reg, offset;\n+      if (!split_mem_address (XEXP (base_mem, 0), &reg, &offset))\n+\tgcc_unreachable ();\n+      RTVEC_ELT (p, b) =\n+\tgen_rtx_SET (reg, plus_constant (Pmode, reg, base_update));\n+    }\n+  return gen_rtx_PARALLEL (VOIDmode, p);\n+}\n+\n+/* CDX ldwm/stwm peephole optimization pattern related routines.  */\n+\n+/* Data structure and sorting function for ldwm/stwm peephole optimizers.  */\n+struct ldstwm_operand\n+{\n+  int offset;\t/* Offset from base register.  */\n+  rtx reg;\t/* Register to store at this offset.  */\n+  rtx mem;\t/* Original mem.  */\n+  bool bad;\t/* True if this load/store can't be combined.  */\n+  bool rewrite; /* True if we should rewrite using scratch.  */\n+};\n+\n+static int\n+compare_ldstwm_operands (const void *arg1, const void *arg2)\n+{\n+  const struct ldstwm_operand *op1 = (const struct ldstwm_operand *) arg1;\n+  const struct ldstwm_operand *op2 = (const struct ldstwm_operand *) arg2;\n+  if (op1->bad)\n+    return op2->bad ? 0 : 1;\n+  else if (op2->bad)\n+    return -1;\n+  else\n+    return op1->offset - op2->offset;\n+}\n+\n+/* Helper function: return true if a load/store using REGNO with address\n+   BASEREG and offset OFFSET meets the constraints for a 2-byte CDX ldw.n,\n+   stw.n, ldwsp.n, or stwsp.n instruction.  */\n+static bool\n+can_use_cdx_ldstw (int regno, int basereg, int offset)\n+{\n+  if (CDX_REG_P (regno) && CDX_REG_P (basereg)\n+      && (offset & 0x3) == 0 && 0 <= offset && offset < 0x40)\n+    return true;\n+  else if (basereg == SP_REGNO\n+\t   && offset >= 0 && offset < 0x80 && (offset & 0x3) == 0)\n+    return true;\n+  return false;\n+}\n+\n+/* This function is called from peephole2 optimizers to try to merge\n+   a series of individual loads and stores into a ldwm or stwm.  It\n+   can also rewrite addresses inside the individual loads and stores\n+   using a common base register using a scratch register and smaller\n+   offsets if that allows them to use CDX ldw.n or stw.n instructions\n+   instead of 4-byte loads or stores.\n+   N is the number of insns we are trying to merge.  SCRATCH is non-null\n+   if there is a scratch register available.  The OPERANDS array contains\n+   alternating REG (even) and MEM (odd) operands.  */\n+bool\n+gen_ldstwm_peep (bool load_p, int n, rtx scratch, rtx *operands)\n+{\n+  /* CDX ldwm/stwm instructions allow a maximum of 12 registers to be\n+     specified.  */\n+#define MAX_LDSTWM_OPS 12\n+  struct ldstwm_operand sort[MAX_LDSTWM_OPS];\n+  int basereg = -1;\n+  int baseoffset;\n+  int i, m, lastoffset, lastreg;\n+  unsigned int regmask = 0, usemask = 0, regset;\n+  bool needscratch;\n+  int newbasereg;\n+  int nbytes;\n+\n+  if (!TARGET_HAS_CDX)\n+    return false;\n+  if (n < 2 || n > MAX_LDSTWM_OPS)\n+    return false;\n+\n+  /* Check all the operands for validity and initialize the sort array.\n+     The places where we return false here are all situations that aren't\n+     expected to ever happen -- invalid patterns, invalid registers, etc.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      rtx base, offset;\n+      rtx reg = operands[i];\n+      rtx mem = operands[i + n];\n+      int r, o, regno;\n+      bool bad = false;\n+\n+      if (!REG_P (reg) || !MEM_P (mem))\n+\treturn false;\n+\n+      regno = REGNO (reg);\n+      if (regno > 31)\n+\treturn false;\n+      if (load_p && (regmask & (1 << regno)) != 0)\n+\treturn false;\n+      regmask |= 1 << regno;\n+\n+      if (!split_mem_address (XEXP (mem, 0), &base, &offset))\n+\treturn false;\n+      r = REGNO (base);\n+      o = INTVAL (offset);\n+\n+      if (basereg == -1)\n+\tbasereg = r;\n+      else if (r != basereg)\n+\tbad = true;\n+      usemask |= 1 << r;\n+\n+      sort[i].bad = bad;\n+      sort[i].rewrite = false;\n+      sort[i].offset = o;\n+      sort[i].reg = reg;\n+      sort[i].mem = mem;\n+    }\n+\n+  /* If we are doing a series of register loads, we can't safely reorder\n+     them if any of the regs used in addr expressions are also being set.  */\n+  if (load_p && (regmask & usemask))\n+    return false;\n+\n+  /* Sort the array by increasing mem offset order, then check that\n+     offsets are valid and register order matches mem order.  At the\n+     end of this loop, m is the number of loads/stores we will try to\n+     combine; the rest are leftovers.  */\n+  qsort (sort, n, sizeof (struct ldstwm_operand), compare_ldstwm_operands);\n+\n+  baseoffset = sort[0].offset;\n+  needscratch = baseoffset != 0;\n+  if (needscratch && !scratch)\n+    return false;\n+\n+  lastreg = regmask = regset = 0;\n+  lastoffset = baseoffset;\n+  for (m = 0; m < n && !sort[m].bad; m++)\n+    {\n+      int thisreg = REGNO (sort[m].reg);\n+      if (sort[m].offset != lastoffset\n+\t  || (m > 0 && lastreg >= thisreg)\n+\t  || !nios2_ldstwm_regset_p (thisreg, &regset))\n+\tbreak;\n+      lastoffset += 4;\n+      lastreg = thisreg;\n+      regmask |= (1 << thisreg);\n+    }\n+\n+  /* For loads, make sure we are not overwriting the scratch reg.\n+     The peephole2 pattern isn't supposed to match unless the register is\n+     unused all the way through, so this isn't supposed to happen anyway.  */\n+  if (load_p\n+      && needscratch\n+      && ((1 << REGNO (scratch)) & regmask) != 0)\n+    return false;\n+  newbasereg = needscratch ? (int) REGNO (scratch) : basereg;\n+\n+  /* We may be able to combine only the first m of the n total loads/stores\n+     into a single instruction.  If m < 2, there's no point in emitting\n+     a ldwm/stwm at all, but we might be able to do further optimizations\n+     if we have a scratch.  We will count the instruction lengths of the\n+     old and new patterns and store the savings in nbytes.  */\n+  if (m < 2)\n+    {\n+      if (!needscratch)\n+\treturn false;\n+      m = 0;\n+      nbytes = 0;\n+    }\n+  else\n+    nbytes = -4;  /* Size of ldwm/stwm.  */\n+  if (needscratch)\n+    {\n+      int bo = baseoffset > 0 ? baseoffset : -baseoffset;\n+      if (CDX_REG_P (newbasereg)\n+\t  && CDX_REG_P (basereg)\n+\t  && bo <= 128 && bo > 0 && (bo & (bo - 1)) == 0)\n+\tnbytes -= 2;  /* Size of addi.n/subi.n.  */\n+      else\n+\tnbytes -= 4;  /* Size of non-CDX addi.  */\n+    }\n+\n+  /* Count the size of the input load/store instructions being replaced.  */\n+  for (i = 0; i < m; i++)\n+    if (can_use_cdx_ldstw (REGNO (sort[i].reg), basereg, sort[i].offset))\n+      nbytes += 2;\n+    else\n+      nbytes += 4;\n+\n+  /* We may also be able to save a bit if we can rewrite non-CDX\n+     load/stores that can't be combined into the ldwm/stwm into CDX\n+     load/stores using the scratch reg.  For example, this might happen\n+     if baseoffset is large, by bringing in the offsets in the load/store\n+     instructions within the range that fits in the CDX instruction.  */\n+  if (needscratch && CDX_REG_P (newbasereg))\n+    for (i = m; i < n && !sort[i].bad; i++)\n+      if (!can_use_cdx_ldstw (REGNO (sort[i].reg), basereg, sort[i].offset)\n+\t  && can_use_cdx_ldstw (REGNO (sort[i].reg), newbasereg,\n+\t\t\t\tsort[i].offset - baseoffset))\n+\t{\n+\t  sort[i].rewrite = true;\n+\t  nbytes += 2;\n+\t}\n+\n+  /* Are we good to go?  */\n+  if (nbytes <= 0)\n+    return false;\n+\n+  /* Emit the scratch load.  */\n+  if (needscratch)\n+    emit_insn (gen_rtx_SET (scratch, XEXP (sort[0].mem, 0)));\n+\n+  /* Emit the ldwm/stwm insn.  */\n+  if (m > 0)\n+    {\n+      rtvec p = rtvec_alloc (m);\n+      for (i = 0; i < m; i++)\n+\t{\n+\t  int offset = sort[i].offset;\n+\t  rtx mem, reg = sort[i].reg;\n+\t  rtx base_reg = gen_rtx_REG (Pmode, newbasereg);\n+\t  if (needscratch)\n+\t    offset -= baseoffset;\n+\t  mem = gen_rtx_MEM (SImode, plus_constant (Pmode, base_reg, offset));\n+\t  if (load_p)\n+\t    RTVEC_ELT (p, i) = gen_rtx_SET (reg, mem);\n+\t  else\n+\t    RTVEC_ELT (p, i) = gen_rtx_SET (mem, reg);\n+\t}\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+    }\n+\n+  /* Emit any leftover load/stores as individual instructions, doing\n+     the previously-noted rewrites to use the scratch reg.  */\n+  for (i = m; i < n; i++)\n+    {\n+      rtx reg = sort[i].reg;\n+      rtx mem = sort[i].mem;\n+      if (sort[i].rewrite)\n+\t{\n+\t  int offset = sort[i].offset - baseoffset;\n+\t  mem = gen_rtx_MEM (SImode, plus_constant (Pmode, scratch, offset));\n+\t}\n+      if (load_p)\n+\temit_move_insn (reg, mem);\n+      else\n+\temit_move_insn (mem, reg);\n+    }\n+  return true;\n+}\n+\n /* Implement TARGET_MACHINE_DEPENDENT_REORG:\n    We use this hook when emitting CDX code to enforce the 4-byte\n    alignment requirement for labels that are used as the targets of"}, {"sha": "e0b85c190107c2c5771601db859ee02fba774957", "filename": "gcc/config/nios2/nios2.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fnios2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fnios2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.md?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -1169,3 +1169,6 @@\n   emit_move_insn (operands[0], gen_rtx_REG (Pmode, TP_REGNO));\n   DONE;\n })\n+;; Include the ldwm/stwm/push.n/pop.n patterns and peepholes.\n+(include \"ldstwm.md\")\n+"}, {"sha": "3f2d441c4ea19d1baa2ee4921070780edde72256", "filename": "gcc/config/nios2/predicates.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Fconfig%2Fnios2%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fpredicates.md?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -94,6 +94,30 @@\n                                          false));\n })\n \n+(define_special_predicate \"pop_operation\"\n+  (match_code \"parallel\")\n+{\n+  return pop_operation_p (op);\n+})\n+\n+(define_special_predicate \"ldwm_operation\"\n+  (match_code \"parallel\")\n+{\n+  return ldstwm_operation_p (op, /*load_p=*/true);\n+})\n+\n+(define_special_predicate \"stwm_operation\"\n+  (match_code \"parallel\")\n+{\n+  return ldstwm_operation_p (op, /*load_p=*/false);\n+})\n+\n+(define_predicate \"nios2_hard_register_operand\"\n+  (match_code \"reg\")\n+{\n+  return GP_REG_P (REGNO (op));\n+})\n+\n (define_predicate \"stack_memory_operand\"\n   (match_code \"mem\")\n {"}, {"sha": "d022c4c2dfd2a30b313ccd88ab93ce6e1ba6c0ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -1,3 +1,10 @@\n+2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* gcc.target/nios2/cdx-ldstwm-1.c: New.\n+\t* gcc.target/nios2/cdx-ldstwm-2.c: New.\n+\n 2015-07-14  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n \t    Chung-Lin Tang  <cltang@codesourcery.com>"}, {"sha": "7beeea15e2fb739350c482ed260cf812c6bd835b", "filename": "gcc/testsuite/gcc.target/nios2/cdx-ldstwm-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-ldstwm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-ldstwm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-ldstwm-1.c?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O3 -fomit-frame-pointer -funroll-all-loops -finline-functions -march=r2 -mcdx -w\" } */\n+\n+/* Based on gcc.c-torture/compile/920501-23.c.\n+   This test used to result in assembler errors with R2 CDX because of\n+   a bug in regrename; it wasn't re-validating insns after renaming, so\n+   ldwm/stwm instructions with incorrect registers were being emitted.  */\n+\n+typedef unsigned char qi;\n+typedef unsigned short hi;\n+typedef unsigned long si;\n+typedef unsigned long long di;\n+subi(a){return 100-a;}\n+add(a,b){return a+b;}\n+mul(a){return 85*a;}\n+memshift(p)unsigned*p;{unsigned x;for(;;){x=*p++>>16;if(x)return x;}}\n+ldw(xp)si*xp;{return xp[4];}\n+ldws_m(xp)si*xp;{si x;do{x=xp[3];xp+=3;}while(x);}\n+postinc_si(p)si*p;{si x;for(;;){x=*p++;if(x)return x;}}\n+preinc_si(p)si*p;{si x;for(;;){x=*++p;if(x)return x;}}\n+postinc_di(p)di*p;{di x;for(;;){x=*p++;if(x)return x;}}\n+preinc_di(p)di*p;{di x;for(;;){x=*++p;if(x)return x;}}\n+inc_overlap(p,a)di*p;{do{p=*(di**)p;p=(di*)((int)p+4);}while(*p);}\n+di move_di(p,p2)di*p,*p2;{di x=p;p2=((di*)x)[1];return p2[1];}"}, {"sha": "0e69534dcc1b1deb53c9af2703fef872874beeeb", "filename": "gcc/testsuite/gcc.target/nios2/cdx-ldstwm-2.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-ldstwm-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa32db37e435d17e473f9089021fb1d8b888a37d/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-ldstwm-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnios2%2Fcdx-ldstwm-2.c?ref=aa32db37e435d17e473f9089021fb1d8b888a37d", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-O3 -fomit-frame-pointer -funroll-loops -march=r2 -mcdx -w\" } */\n+\n+/* Based on gcc.c-torture/execute/20021120-1.c.\n+   This test used to result in assembler errors with R2 CDX because of\n+   a bug in regrename; it wasn't re-validating insns after renaming, so\n+   ldwm/stwm instructions with incorrect registers were being emitted.  */\n+\n+/* Macros to emit \"L Nxx R\" for each octal number xx between 000 and 037.  */\n+#define OP1(L, N, R, I, J) L N##I##J R\n+#define OP2(L, N, R, I) \\\n+    OP1(L, N, R, 0, I), OP1(L, N, R, 1, I), \\\n+    OP1(L, N, R, 2, I), OP1(L, N, R, 3, I)\n+#define OP(L, N, R) \\\n+    OP2(L, N, R, 0), OP2(L, N, R, 1), OP2(L, N, R, 2), OP2(L, N, R, 3), \\\n+    OP2(L, N, R, 4), OP2(L, N, R, 5), OP2(L, N, R, 6), OP2(L, N, R, 7)\n+\n+/* Declare 32 unique variables with prefix N.  */\n+#define DECLARE(N) OP (, N,)\n+\n+/* Copy 32 variables with prefix N from the array at ADDR.\n+   Leave ADDR pointing to the end of the array.  */\n+#define COPYIN(N, ADDR) OP (, N, = *(ADDR++))\n+\n+/* Likewise, but copy the other way.  */\n+#define COPYOUT(N, ADDR) OP (*(ADDR++) =, N,)\n+\n+/* Add the contents of the array at ADDR to 32 variables with prefix N.\n+   Leave ADDR pointing to the end of the array.  */\n+#define ADD(N, ADDR) OP (, N, += *(ADDR++))\n+\n+volatile double gd[32];\n+volatile float gf[32];\n+\n+void foo (int n)\n+{\n+  double DECLARE(d);\n+  float DECLARE(f);\n+  volatile double *pd;\n+  volatile float *pf;\n+  int i;\n+\n+  pd = gd; COPYIN (d, pd);\n+  for (i = 0; i < n; i++)\n+    {\n+      pf = gf; COPYIN (f, pf);\n+      pd = gd; ADD (d, pd);\n+      pd = gd; ADD (d, pd);\n+      pd = gd; ADD (d, pd);\n+      pf = gf; COPYOUT (f, pf);\n+    }\n+  pd = gd; COPYOUT (d, pd);\n+}\n+\n+int main ()\n+{\n+  int i;\n+\n+  for (i = 0; i < 32; i++)\n+    gd[i] = i, gf[i] = i;\n+  foo (1);\n+  for (i = 0; i < 32; i++)\n+    if (gd[i] != i * 4 || gf[i] != i)\n+      abort ();\n+  exit (0);\n+}"}]}