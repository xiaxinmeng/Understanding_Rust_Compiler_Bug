{"sha": "a0ad3539f415e3f925691340ce389c0dc0819c91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhZDM1MzlmNDE1ZTNmOTI1NjkxMzQwY2UzODljMGRjMDgxOWM5MQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2007-02-22T17:03:48Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2007-02-22T17:03:48Z"}, "message": "dwarf2out.c (add_AT_string): Call ggc_strdup once per string.\n\n        * dwarf2out.c (add_AT_string): Call ggc_strdup once per string.\n        (type_tag): Use lang_hooks.dwarf_name instead of DECL_NAME.\n\n        * cp-tree.h (TFF_NO_OUTER_SCOPE): New formatting flag.\n        * error.c (dump_aggr_type, dump_simple_decl, dump_decl,\n        dump_function_decl): Guard emitting outer scopes by new flag.\n        * cp-lang.c (cxx_dwarf_name): New function.\n        (LANG_HOOKS_DWARF_NAME): Define to cxx_dwarf_name.\n        * pt.c (classtype_mangled_name, mangle_class_name_for_template):\n        Remove functions.\n        (push_template_decl_real, lookup_template_class): Remove calls\n        to above functions.\n\nFrom-SVN: r122230", "tree": {"sha": "b9429c7e1446e9672a2be1a81499cfcc7a228646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9429c7e1446e9672a2be1a81499cfcc7a228646"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0ad3539f415e3f925691340ce389c0dc0819c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ad3539f415e3f925691340ce389c0dc0819c91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ad3539f415e3f925691340ce389c0dc0819c91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ad3539f415e3f925691340ce389c0dc0819c91/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3502aa8d46d9cd008916170a635b2bf3a5d5125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3502aa8d46d9cd008916170a635b2bf3a5d5125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3502aa8d46d9cd008916170a635b2bf3a5d5125"}], "stats": {"total": 218, "additions": 74, "deletions": 144}, "files": [{"sha": "0c8ccb90f291bebcd24e10c87d1a65f99ba5917e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0ad3539f415e3f925691340ce389c0dc0819c91", "patch": "@@ -1,11 +1,17 @@\n+2007-02-22  Michael Matz  <matz@suse.de\n+\n+\tPR c++/29433\n+\t* dwarf2out.c (add_AT_string): Call ggc_strdup once per string.\n+\t(type_tag): Use lang_hooks.dwarf_name instead of DECL_NAME.\n+\n 2007-02-22  Ian Lance Taylor  <iant@google.com>\n \n \tPR debug/30898\n \t* dwarf2out.c (concatn_mem_loc_descriptor): New static function.\n \t(mem_loc_descriptor): Call it.\n \n 2007-02-22  Zdenek Dvorak  <dvorakz@suse.cz>\n-            Ira Rosen  <irar@il.ibm.com>\n+\t    Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-data-ref.c (ptr_ptr_may_alias_p): Take alias sets into account.\n "}, {"sha": "63dddf944eb071179d4403def6ea917003d09a14", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a0ad3539f415e3f925691340ce389c0dc0819c91", "patch": "@@ -1,3 +1,16 @@\n+2007-02-22  Michael Matz  <matz@suse.de>\n+\n+\tPR c++/29433\n+\t* cp-tree.h (TFF_UNQUALIFIED_NAME): New formatting flag.\n+\t* error.c (dump_aggr_type, dump_simple_decl, dump_decl,\n+\tdump_function_decl): Guard emitting outer scopes by new flag.\n+\t* cp-lang.c (cxx_dwarf_name): New function.\n+\t(LANG_HOOKS_DWARF_NAME): Define to cxx_dwarf_name.\n+\t* pt.c (classtype_mangled_name, mangle_class_name_for_template):\n+\tRemove functions.\n+\t(push_template_decl_real, lookup_template_class): Remove calls\n+\tto above functions.\n+\n 2007-02-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (build_new_method_call): Ensure that explicit calls of"}, {"sha": "507641c36bd5df336052f6b72cd197ed541d19df", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=a0ad3539f415e3f925691340ce389c0dc0819c91", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02110-1301, USA.  */\n \n enum c_language_kind c_language = clk_cxx;\n static void cp_init_ts (void);\n+static const char * cxx_dwarf_name (tree t, int verbosity);\n \n /* Lang hooks common to C++ and ObjC++ are declared in cp/cp-objcp-common.h;\n    consequently, there should be very few hooks below.  */\n@@ -46,6 +47,8 @@ static void cp_init_ts (void);\n #define LANG_HOOKS_INIT cxx_init\n #undef LANG_HOOKS_DECL_PRINTABLE_NAME\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tcxx_printable_name\n+#undef LANG_HOOKS_DWARF_NAME\n+#define LANG_HOOKS_DWARF_NAME cxx_dwarf_name\n #undef LANG_HOOKS_FOLD_OBJ_TYPE_REF\n #define LANG_HOOKS_FOLD_OBJ_TYPE_REF cp_fold_obj_type_ref\n #undef LANG_HOOKS_INIT_TS\n@@ -138,6 +141,17 @@ cp_init_ts (void)\n \n }\n \n+static const char *\n+cxx_dwarf_name (tree t, int verbosity)\n+{\n+  gcc_assert (DECL_P (t));\n+\n+  if (verbosity >= 2)\n+    return decl_as_string (t, TFF_DECL_SPECIFIERS | TFF_UNQUALIFIED_NAME);\n+\n+  return cxx_printable_name (t, verbosity);\n+}\n+\n void\n finish_file (void)\n {"}, {"sha": "a070411e6253d54a7a589e4db5e82cebb6335a2a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a0ad3539f415e3f925691340ce389c0dc0819c91", "patch": "@@ -3647,7 +3647,9 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n        template-declaration.\n    TFF_TEMPLATE_NAME: show only template-name.\n    TFF_EXPR_IN_PARENS: parenthesize expressions.\n-   TFF_NO_FUNCTION_ARGUMENTS: don't show function arguments.  */\n+   TFF_NO_FUNCTION_ARGUMENTS: don't show function arguments.\n+   TFF_UNQUALIFIED_NAME: do not print the qualifying scope of the\n+       top-level entity.  */\n \n #define TFF_PLAIN_IDENTIFIER\t\t\t(0)\n #define TFF_SCOPE\t\t\t\t(1)\n@@ -3661,6 +3663,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define TFF_TEMPLATE_NAME\t\t\t(1 << 8)\n #define TFF_EXPR_IN_PARENS\t\t\t(1 << 9)\n #define TFF_NO_FUNCTION_ARGUMENTS\t\t(1 << 10)\n+#define TFF_UNQUALIFIED_NAME\t\t\t(1 << 11)\n \n /* Returns the TEMPLATE_DECL associated to a TEMPLATE_TEMPLATE_PARM\n    node.  */"}, {"sha": "5779805d80ce796343d94234b324557be50f1521", "filename": "gcc/cp/error.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a0ad3539f415e3f925691340ce389c0dc0819c91", "patch": "@@ -447,7 +447,10 @@ dump_aggr_type (tree t, int flags)\n \t\t&& TYPE_LANG_SPECIFIC (t) && CLASSTYPE_TEMPLATE_INFO (t)\n \t\t&& (TREE_CODE (CLASSTYPE_TI_TEMPLATE (t)) != TEMPLATE_DECL\n \t\t    || PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)));\n-      dump_scope (CP_DECL_CONTEXT (name), flags | TFF_SCOPE);\n+      \n+      if (! (flags & TFF_UNQUALIFIED_NAME))\n+\tdump_scope (CP_DECL_CONTEXT (name), flags | TFF_SCOPE);\n+      flags &= ~TFF_UNQUALIFIED_NAME;\n       if (tmplate)\n \t{\n \t  /* Because the template names are mangled, we have to locate\n@@ -697,11 +700,14 @@ dump_simple_decl (tree t, tree type, int flags)\n {\n   if (flags & TFF_DECL_SPECIFIERS)\n     {\n-      dump_type_prefix (type, flags);\n+      dump_type_prefix (type, flags & ~TFF_UNQUALIFIED_NAME);\n       pp_maybe_space (cxx_pp);\n     }\n-  if (!DECL_INITIAL (t) || TREE_CODE (DECL_INITIAL (t)) != TEMPLATE_PARM_INDEX)\n+  if (! (flags & TFF_UNQUALIFIED_NAME)\n+      && (!DECL_INITIAL (t)\n+\t  || TREE_CODE (DECL_INITIAL (t)) != TEMPLATE_PARM_INDEX))\n     dump_scope (CP_DECL_CONTEXT (t), flags);\n+  flags &= ~TFF_UNQUALIFIED_NAME;\n   if (DECL_NAME (t))\n     dump_decl (DECL_NAME (t), flags);\n   else\n@@ -763,7 +769,9 @@ dump_decl (tree t, int flags)\n \tpp_cxx_declaration (cxx_pp, t);\n       else\n \t{\n-\t  dump_scope (CP_DECL_CONTEXT (t), flags);\n+\t  if (! (flags & TFF_UNQUALIFIED_NAME))\n+\t    dump_scope (CP_DECL_CONTEXT (t), flags);\n+\t  flags &= ~TFF_UNQUALIFIED_NAME;\n \t  if (DECL_NAME (t) == NULL_TREE)\n \t    pp_identifier (cxx_pp, \"<unnamed>\");\n \t  else\n@@ -998,7 +1006,9 @@ dump_function_decl (tree t, int flags)\n   tree template_args = NULL_TREE;\n   tree template_parms = NULL_TREE;\n   int show_return = flags & TFF_RETURN_TYPE || flags & TFF_DECL_SPECIFIERS;\n+  int do_outer_scope = ! (flags & TFF_UNQUALIFIED_NAME);\n \n+  flags &= ~TFF_UNQUALIFIED_NAME;\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n \n@@ -1040,7 +1050,9 @@ dump_function_decl (tree t, int flags)\n     dump_type_prefix (TREE_TYPE (fntype), flags);\n \n   /* Print the function name.  */\n-  if (cname)\n+  if (!do_outer_scope)\n+    /* Nothing.  */;\n+  else if (cname)\n     {\n       dump_type (cname, flags);\n       pp_cxx_colon_colon (cxx_pp);"}, {"sha": "8ade0a095c5f31c46337dd99140293a7f4a8c5ca", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 132, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a0ad3539f415e3f925691340ce389c0dc0819c91", "patch": "@@ -106,8 +106,6 @@ static void add_pending_template (tree);\n static int push_tinst_level (tree);\n static void pop_tinst_level (void);\n static void reopen_tinst_level (tree);\n-static tree classtype_mangled_name (tree);\n-static char* mangle_class_name_for_template (const char *, tree, tree);\n static tree tsubst_initializer_list (tree, tree);\n static tree get_class_bindings (tree, tree, tree);\n static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t,\n@@ -3349,14 +3347,7 @@ push_template_decl_real (tree decl, bool is_friend)\n   info = tree_cons (tmpl, args, NULL_TREE);\n \n   if (DECL_IMPLICIT_TYPEDEF_P (decl))\n-    {\n-      SET_TYPE_TEMPLATE_INFO (TREE_TYPE (tmpl), info);\n-      if ((!ctx || TREE_CODE (ctx) != FUNCTION_DECL)\n-\t  && TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n-\t  /* Don't change the name if we've already set it up.  */\n-\t  && !IDENTIFIER_TEMPLATE (DECL_NAME (decl)))\n-\tDECL_NAME (decl) = classtype_mangled_name (TREE_TYPE (decl));\n-    }\n+    SET_TYPE_TEMPLATE_INFO (TREE_TYPE (tmpl), info);\n   else if (DECL_LANG_SPECIFIC (decl))\n     DECL_TEMPLATE_INFO (decl) = info;\n \n@@ -4301,124 +4292,6 @@ comp_template_args (tree oldargs, tree newargs)\n   return 1;\n }\n \n-/* Given class template name and parameter list, produce a user-friendly name\n-   for the instantiation.  */\n-\n-static char *\n-mangle_class_name_for_template (const char* name, tree parms, tree arglist)\n-{\n-  static struct obstack scratch_obstack;\n-  static char *scratch_firstobj;\n-  int i, nparms;\n-\n-  if (!scratch_firstobj)\n-    gcc_obstack_init (&scratch_obstack);\n-  else\n-    obstack_free (&scratch_obstack, scratch_firstobj);\n-  scratch_firstobj = (char *) obstack_alloc (&scratch_obstack, 1);\n-\n-#define ccat(C)\tobstack_1grow (&scratch_obstack, (C));\n-#define cat(S)\tobstack_grow (&scratch_obstack, (S), strlen (S))\n-\n-  cat (name);\n-  ccat ('<');\n-  nparms = TREE_VEC_LENGTH (parms);\n-  arglist = INNERMOST_TEMPLATE_ARGS (arglist);\n-  gcc_assert (nparms == TREE_VEC_LENGTH (arglist));\n-  for (i = 0; i < nparms; i++)\n-    {\n-      tree parm;\n-      tree arg;\n-\n-      parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n-      arg = TREE_VEC_ELT (arglist, i);\n-\n-      if (parm == error_mark_node)\n-\tcontinue;\n-\n-      if (i)\n-\tccat (',');\n-\n-      if (TREE_CODE (parm) == TYPE_DECL)\n-\t{\n-\t  cat (type_as_string (arg, TFF_CHASE_TYPEDEF));\n-\t  continue;\n-\t}\n-      else if (TREE_CODE (parm) == TEMPLATE_DECL)\n-\t{\n-\t  if (TREE_CODE (arg) == TEMPLATE_DECL)\n-\t    {\n-\t      /* Already substituted with real template.  Just output\n-\t\t the template name here */\n-\t      tree context = DECL_CONTEXT (arg);\n-\t      if (context)\n-\t\t{\n-\t\t  /* The template may be defined in a namespace, or\n-\t\t     may be a member template.  */\n-\t\t  gcc_assert (TREE_CODE (context) == NAMESPACE_DECL\n-\t\t\t      || CLASS_TYPE_P (context));\n-\t\t  cat (decl_as_string (DECL_CONTEXT (arg),\n-\t\t\t\t      TFF_PLAIN_IDENTIFIER));\n-\t\t  cat (\"::\");\n-\t\t}\n-\t      cat (IDENTIFIER_POINTER (DECL_NAME (arg)));\n-\t    }\n-\t  else\n-\t    /* Output the parameter declaration.  */\n-\t    cat (type_as_string (arg, TFF_CHASE_TYPEDEF));\n-\t  continue;\n-\t}\n-      else\n-\tgcc_assert (TREE_CODE (parm) == PARM_DECL);\n-\n-      /* No need to check arglist against parmlist here; we did that\n-\t in coerce_template_parms, called from lookup_template_class.  */\n-      cat (expr_as_string (arg, TFF_PLAIN_IDENTIFIER));\n-    }\n-  {\n-    char *bufp = obstack_next_free (&scratch_obstack);\n-    int offset = 0;\n-    while (bufp[offset - 1] == ' ')\n-      offset--;\n-    obstack_blank_fast (&scratch_obstack, offset);\n-\n-    /* B<C<char> >, not B<C<char>> */\n-    if (bufp[offset - 1] == '>')\n-      ccat (' ');\n-  }\n-  ccat ('>');\n-  ccat ('\\0');\n-  return (char *) obstack_base (&scratch_obstack);\n-}\n-\n-static tree\n-classtype_mangled_name (tree t)\n-{\n-  if (CLASSTYPE_TEMPLATE_INFO (t)\n-      /* Specializations have already had their names set up in\n-\t lookup_template_class.  */\n-      && !CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n-    {\n-      tree tmpl = most_general_template (CLASSTYPE_TI_TEMPLATE (t));\n-\n-      /* For non-primary templates, the template parameters are\n-\t implicit from their surrounding context.  */\n-      if (PRIMARY_TEMPLATE_P (tmpl))\n-\t{\n-\t  tree name = DECL_NAME (tmpl);\n-\t  char *mangled_name = mangle_class_name_for_template\n-\t    (IDENTIFIER_POINTER (name),\n-\t     DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n-\t     CLASSTYPE_TI_ARGS (t));\n-\t  tree id = get_identifier (mangled_name);\n-\t  IDENTIFIER_TEMPLATE (id) = name;\n-\t  return id;\n-\t}\n-    }\n-\n-  return TYPE_IDENTIFIER (t);\n-}\n-\n static void\n add_pending_template (tree d)\n {\n@@ -4965,10 +4838,6 @@ lookup_template_class (tree d1,\n \t   the instantiation and exit above.  */\n \ttsubst_enum (template_type, t, arglist);\n \n-      /* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO\n-\t is set up.  */\n-      if (TREE_CODE (t) != ENUMERAL_TYPE)\n-\tDECL_NAME (type_decl) = classtype_mangled_name (t);\n       if (is_partial_instantiation)\n \t/* If the type makes use of template parameters, the\n \t   code that generates debugging information will crash.  */"}, {"sha": "3f2dbba930cdecfa0170e61ba3726bfa1b08dc21", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ad3539f415e3f925691340ce389c0dc0819c91/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a0ad3539f415e3f925691340ce389c0dc0819c91", "patch": "@@ -5039,9 +5039,15 @@ add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)\n   slot = htab_find_slot_with_hash (debug_str_hash, str,\n \t\t\t\t   htab_hash_string (str), INSERT);\n   if (*slot == NULL)\n-    *slot = ggc_alloc_cleared (sizeof (struct indirect_string_node));\n-  node = (struct indirect_string_node *) *slot;\n-  node->str = ggc_strdup (str);\n+    {\n+      node = (struct indirect_string_node *)\n+\t       ggc_alloc_cleared (sizeof (struct indirect_string_node));\n+      node->str = ggc_strdup (str);\n+      *slot = node;\n+    }\n+  else\n+    node = (struct indirect_string_node *) *slot;\n+\n   node->refcount++;\n \n   attr.dw_attr = attr_kind;\n@@ -11251,10 +11257,17 @@ type_tag (tree type)\n \t involved.  */\n       else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t       && ! DECL_IGNORED_P (TYPE_NAME (type)))\n-\tt = DECL_NAME (TYPE_NAME (type));\n+\t{\n+\t  /* We want to be extra verbose.  Don't call dwarf_name if\n+\t     DECL_NAME isn't set.  The default hook for decl_printable_name\n+\t     doesn't like that, and in this context it's correct to return\n+\t     0, instead of \"<anonymous>\" or the like.  */\n+\t  if (DECL_NAME (TYPE_NAME (type)))\n+\t    name = lang_hooks.dwarf_name (TYPE_NAME (type), 2);\n+\t}\n \n       /* Now get the name as a string, or invent one.  */\n-      if (t != 0)\n+      if (!name && t != 0)\n \tname = IDENTIFIER_POINTER (t);\n     }\n "}]}