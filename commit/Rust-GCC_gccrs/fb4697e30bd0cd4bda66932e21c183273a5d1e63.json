{"sha": "fb4697e30bd0cd4bda66932e21c183273a5d1e63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI0Njk3ZTMwYmQwY2Q0YmRhNjY5MzJlMjFjMTgzMjczYTVkMWU2Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-05T12:50:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-05T12:50:45Z"}, "message": "re PR tree-optimization/91091 ([missed optimization] Missing optimization in unaliased pointers)\n\n2019-07-05  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91091\n\t* tree-ssa-alias.h (get_continuation_for_phi): Add tbaa_p parameter.\n\t(walk_non_aliased_vuses): Likewise.\n\t* tree-ssa-alias.c (maybe_skip_until): Pass down tbaa_p.\n\t(get_continuation_for_phi): New tbaa_p parameter and pass\n\tit down.\n\t(walk_non_aliased_vuses): Likewise.\n\t* ipa-prop.c (determine_known_aggregate_parts): Adjust.\n\t* tree-ssa-pre.c (translate_vuse_through_block): Likewise.\n\t* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr):\n\tLikewise.\n\t* tree-ssa-sccvn.c (struct vn_walk_cb_data): Add tbaa_p flag.\n\t(adjust_offsets_for_equal_base_address): New function.\n\t(vn_reference_lookup_3): Use it to catch more base equivalences.\n\tHandle and pass down tbaa_p flag.\n\t(vn_reference_lookup_pieces): Adjust.\n\t(vn_reference_lookup): Remove alias-set altering, instead pass\n\tdown false as tbaa_p.\n\n\t* gcc.dg/tree-ssa/pr91091-2.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-fre-70.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-71.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-72.c: Likewise.\n\nFrom-SVN: r273135", "tree": {"sha": "392c65691fc7f7d8fd6d1dce0b8283095de689d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/392c65691fc7f7d8fd6d1dce0b8283095de689d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb4697e30bd0cd4bda66932e21c183273a5d1e63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4697e30bd0cd4bda66932e21c183273a5d1e63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4697e30bd0cd4bda66932e21c183273a5d1e63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4697e30bd0cd4bda66932e21c183273a5d1e63/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75fad0a98919da8212be4efc479d098499f4f1c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75fad0a98919da8212be4efc479d098499f4f1c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75fad0a98919da8212be4efc479d098499f4f1c3"}], "stats": {"total": 197, "additions": 163, "deletions": 34}, "files": [{"sha": "6dd97ab13e684243f09d992935c737b3928ce62d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -1,3 +1,24 @@\n+2019-07-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91091\n+\t* tree-ssa-alias.h (get_continuation_for_phi): Add tbaa_p parameter.\n+\t(walk_non_aliased_vuses): Likewise.\n+\t* tree-ssa-alias.c (maybe_skip_until): Pass down tbaa_p.\n+\t(get_continuation_for_phi): New tbaa_p parameter and pass\n+\tit down.\n+\t(walk_non_aliased_vuses): Likewise.\n+\t* ipa-prop.c (determine_known_aggregate_parts): Adjust.\n+\t* tree-ssa-pre.c (translate_vuse_through_block): Likewise.\n+\t* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr):\n+\tLikewise.\n+\t* tree-ssa-sccvn.c (struct vn_walk_cb_data): Add tbaa_p flag.\n+\t(adjust_offsets_for_equal_base_address): New function.\n+\t(vn_reference_lookup_3): Use it to catch more base equivalences.\n+\tHandle and pass down tbaa_p flag.\n+\t(vn_reference_lookup_pieces): Adjust.\n+\t(vn_reference_lookup): Remove alias-set altering, instead pass\n+\tdown false as tbaa_p.\n+\n 2019-07-05  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91091"}, {"sha": "f5f8c75363110c389dab8bc444b0f9b564b204ef", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -1678,7 +1678,8 @@ determine_known_aggregate_parts (gcall *call, tree arg,\n \n       if (gimple_code (stmt) == GIMPLE_PHI)\n \t{\n-\t  dom_vuse = get_continuation_for_phi (stmt, &r, *aa_walk_budget_p,\n+\t  dom_vuse = get_continuation_for_phi (stmt, &r, true,\n+\t\t\t\t\t       *aa_walk_budget_p,\n \t\t\t\t\t       &visited, false, NULL, NULL);\n \t  continue;\n \t}"}, {"sha": "5656a5b2e48ba47ace5dac10b021754142d9d0a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -1,3 +1,11 @@\n+2019-07-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91091\n+\t* gcc.dg/tree-ssa/pr91091-2.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-fre-70.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-71.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-72.c: Likewise.\n+\n 2019-07-05  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91091"}, {"sha": "b578de79cf1dbaa0389ccfd3ffbff21421ff3594", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr91091-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr91091-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr91091-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr91091-2.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+\n+struct s { int x; };\n+struct t { int x; };\n+\n+void swap(struct s* p, struct t* q)\n+{\n+  p->x = q->x;\n+  q->x = p->x;\n+}\n+\n+/* The second statement is redundant.  */\n+/* { dg-final { scan-tree-dump-times \"x = \" 1 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \" = \\[^;\\]*x;\" 1 \"fre1\" } } */"}, {"sha": "612d7531243d351811f6adcdb94b0d718ea5cf77", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-70.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-70.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-70.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-70.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple -O -fdump-tree-fre1\" } */\n+\n+__GIMPLE (ssa, startwith(\"fre\")) char foo(char *p)\n+{\n+  char _1;\n+\n+__BB(2):\n+  __MEM <char[4]> (p) = _Literal (char[4]) {};\n+  _1 = __MEM <char> (p + 1);\n+  return _1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 0;\" \"fre1\" } } */"}, {"sha": "edc8899d225897c818f5aea07181c3228869ad69", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-71.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-71.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-71.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-71.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple -O -fdump-tree-fre1-details\" } */\n+\n+__GIMPLE (ssa, startwith(\"fre\")) char foo(char *p)\n+{\n+  char _1;\n+\n+__BB(2):\n+  __MEM <int> (p) = 0;\n+  _1 = __MEM <char> (p + 1);\n+  return _1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 0;\" \"fre1\" } } */"}, {"sha": "b95709fa46f0cba398f112d9ec6ef26d8c5cf35e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-72.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-72.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-72.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-72.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple -O -fdump-tree-fre1\" } */\n+\n+__GIMPLE (ssa,startwith(\"fre\")) char foo(char *p, int i)\n+{\n+  char _1;\n+\n+__BB(2):\n+  __MEM <int> (p) = i_2(D);\n+  _1 = __MEM <char> (p + 1);\n+  return _1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"BIT_FIELD_REF\" \"fre1\" } } */"}, {"sha": "b5e980d57e27f06786886d4e65bfb39aabdc7a19", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -3054,8 +3054,8 @@ stmt_kills_ref_p (gimple *stmt, tree ref)\n \n static bool\n maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,\n-\t\t  ao_ref *ref, tree vuse, unsigned int &limit, bitmap *visited,\n-\t\t  bool abort_on_visited,\n+\t\t  ao_ref *ref, tree vuse, bool tbaa_p, unsigned int &limit,\n+\t\t  bitmap *visited, bool abort_on_visited,\n \t\t  void *(*translate)(ao_ref *, tree, void *, bool *),\n \t\t  void *data)\n {\n@@ -3089,7 +3089,7 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,\n \t  /* An already visited PHI node ends the walk successfully.  */\n \t  if (bitmap_bit_p (*visited, SSA_NAME_VERSION (PHI_RESULT (def_stmt))))\n \t    return !abort_on_visited;\n-\t  vuse = get_continuation_for_phi (def_stmt, ref, limit,\n+\t  vuse = get_continuation_for_phi (def_stmt, ref, tbaa_p, limit,\n \t\t\t\t\t   visited, abort_on_visited,\n \t\t\t\t\t   translate, data);\n \t  if (!vuse)\n@@ -3104,7 +3104,7 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,\n \t  if ((int)limit <= 0)\n \t    return false;\n \t  --limit;\n-\t  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))\n+\t  if (stmt_may_clobber_ref_p_1 (def_stmt, ref, tbaa_p))\n \t    {\n \t      bool disambiguate_only = true;\n \t      if (translate\n@@ -3136,7 +3136,7 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,\n    Returns NULL_TREE if no suitable virtual operand can be found.  */\n \n tree\n-get_continuation_for_phi (gimple *phi, ao_ref *ref,\n+get_continuation_for_phi (gimple *phi, ao_ref *ref, bool tbaa_p,\n \t\t\t  unsigned int &limit, bitmap *visited,\n \t\t\t  bool abort_on_visited,\n \t\t\t  void *(*translate)(ao_ref *, tree, void *, bool *),\n@@ -3179,7 +3179,8 @@ get_continuation_for_phi (gimple *phi, ao_ref *ref,\n       arg1 = PHI_ARG_DEF (phi, i);\n       if (arg1 == arg0)\n \t;\n-      else if (! maybe_skip_until (phi, arg0, dom, ref, arg1, limit, visited,\n+      else if (! maybe_skip_until (phi, arg0, dom, ref, arg1, tbaa_p,\n+\t\t\t\t   limit, visited,\n \t\t\t\t   abort_on_visited,\n \t\t\t\t   /* Do not translate when walking over\n \t\t\t\t      backedges.  */\n@@ -3223,7 +3224,7 @@ get_continuation_for_phi (gimple *phi, ao_ref *ref,\n    TODO: Cache the vector of equivalent vuses per ref, vuse pair.  */\n \n void *\n-walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n+walk_non_aliased_vuses (ao_ref *ref, tree vuse, bool tbaa_p,\n \t\t\tvoid *(*walker)(ao_ref *, tree, void *),\n \t\t\tvoid *(*translate)(ao_ref *, tree, void *, bool *),\n \t\t\ttree (*valueize)(tree),\n@@ -3264,7 +3265,7 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n       if (gimple_nop_p (def_stmt))\n \tbreak;\n       else if (gimple_code (def_stmt) == GIMPLE_PHI)\n-\tvuse = get_continuation_for_phi (def_stmt, ref, limit,\n+\tvuse = get_continuation_for_phi (def_stmt, ref, tbaa_p, limit,\n \t\t\t\t\t &visited, translated, translate, data);\n       else\n \t{\n@@ -3274,7 +3275,7 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n \t      break;\n \t    }\n \t  --limit;\n-\t  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))\n+\t  if (stmt_may_clobber_ref_p_1 (def_stmt, ref, tbaa_p))\n \t    {\n \t      if (!translate)\n \t\tbreak;"}, {"sha": "ddd28ec3c75b50c56ed76d38a0ffaad85d611a68", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -131,11 +131,11 @@ extern bool call_may_clobber_ref_p (gcall *, tree);\n extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *);\n extern bool stmt_kills_ref_p (gimple *, tree);\n extern bool stmt_kills_ref_p (gimple *, ao_ref *);\n-extern tree get_continuation_for_phi (gimple *, ao_ref *,\n+extern tree get_continuation_for_phi (gimple *, ao_ref *, bool,\n \t\t\t\t      unsigned int &, bitmap *, bool,\n \t\t\t\t      void *(*)(ao_ref *, tree, void *, bool *),\n \t\t\t\t      void *);\n-extern void *walk_non_aliased_vuses (ao_ref *, tree,\n+extern void *walk_non_aliased_vuses (ao_ref *, tree, bool,\n \t\t\t\t     void *(*)(ao_ref *, tree, void *),\n \t\t\t\t     void *(*)(ao_ref *, tree, void *, bool *),\n \t\t\t\t     tree (*)(tree), unsigned &, void *);"}, {"sha": "231ac00c1d1c11b5185f092895dd037008afc6b2", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -1185,8 +1185,8 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,\n \t  bitmap visited = NULL;\n \t  /* Try to find a vuse that dominates this phi node by skipping\n \t     non-clobbering statements.  */\n-\t  vuse = get_continuation_for_phi (phi, &ref, cnt, &visited, false,\n-\t\t\t\t\t   NULL, NULL);\n+\t  vuse = get_continuation_for_phi (phi, &ref, true,\n+\t\t\t\t\t   cnt, &visited, false, NULL, NULL);\n \t  if (visited)\n \t    BITMAP_FREE (visited);\n \t}"}, {"sha": "6d4ad7558636eae0b1a13ffd28588117e944aed8", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -1648,9 +1648,16 @@ vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n \n struct vn_walk_cb_data\n {\n+  vn_walk_cb_data (vn_reference_t vr_, tree *last_vuse_ptr_,\n+                   vn_lookup_kind vn_walk_kind_, bool tbaa_p_)\n+    : vr (vr_), last_vuse_ptr (last_vuse_ptr_), vn_walk_kind (vn_walk_kind_),\n+      tbaa_p (tbaa_p_)\n+    {}\n+\n   vn_reference_t vr;\n   tree *last_vuse_ptr;\n   vn_lookup_kind vn_walk_kind;\n+  bool tbaa_p;\n };\n \n /* Callback for walk_non_aliased_vuses.  Adjusts the vn_reference_t VR_\n@@ -1927,6 +1934,33 @@ class rpo_elim : public eliminate_dom_walker\n static rpo_elim *rpo_avail;\n basic_block vn_context_bb;\n \n+/* Return true if BASE1 and BASE2 can be adjusted so they have the\n+   same address and adjust *OFFSET1 and *OFFSET2 accordingly.\n+   Otherwise return false.  */\n+\n+static bool\n+adjust_offsets_for_equal_base_address (tree base1, poly_int64 *offset1,\n+\t\t\t\t       tree base2, poly_int64 *offset2)\n+{\n+  poly_int64 soff;\n+  if (TREE_CODE (base1) == MEM_REF\n+      && TREE_CODE (base2) == MEM_REF)\n+    {\n+      if (mem_ref_offset (base1).to_shwi (&soff))\n+\t{\n+\t  base1 = TREE_OPERAND (base1, 0);\n+\t  *offset1 += soff * BITS_PER_UNIT;\n+\t}\n+      if (mem_ref_offset (base2).to_shwi (&soff))\n+\t{\n+\t  base2 = TREE_OPERAND (base2, 0);\n+\t  *offset2 += soff * BITS_PER_UNIT;\n+\t}\n+      return operand_equal_p (base1, base2, 0);\n+    }\n+  return operand_equal_p (base1, base2, OEP_ADDRESS_OF);\n+}\n+\n /* Callback for walk_non_aliased_vuses.  Tries to perform a lookup\n    from the statement defining VUSE and if not successful tries to\n    translate *REFP and VR_ through an aggregate copy at the definition\n@@ -1966,7 +2000,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t\t\t\t\t      get_alias_set (lhs),\n \t\t\t\t\t\t      TREE_TYPE (lhs), lhs_ops);\n \t  if (lhs_ref_ok\n-\t      && !refs_may_alias_p_1 (ref, &lhs_ref, true))\n+\t      && !refs_may_alias_p_1 (ref, &lhs_ref, data->tbaa_p))\n \t    {\n \t      *disambiguate_only = true;\n \t      return NULL;\n@@ -2055,7 +2089,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t}\n     }\n \n-  if (*disambiguate_only)\n+  /* If we are looking for redundant stores do not create new hashtable\n+     entries from aliasing defs with made up alias-sets.  */\n+  if (*disambiguate_only || !data->tbaa_p)\n     return (void *)-1;\n \n   /* If we cannot constrain the size of the reference we cannot\n@@ -2186,7 +2222,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t\t\t       &offset2, &size2, &maxsize2, &reverse);\n       if (known_size_p (maxsize2)\n \t  && known_eq (maxsize2, size2)\n-\t  && operand_equal_p (base, base2, 0)\n+\t  && adjust_offsets_for_equal_base_address (base, &offset,\n+\t\t\t\t\t\t    base2, &offset2)\n \t  && known_subrange_p (offset, maxsize, offset2, size2))\n \t{\n \t  tree val = build_zero_cst (vr->type);\n@@ -2213,15 +2250,20 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t   && is_gimple_min_invariant (SSA_VAL (gimple_assign_rhs1 (def_stmt))))))\n     {\n       tree base2;\n-      HOST_WIDE_INT offset2, size2;\n+      poly_int64 offset2, size2, maxsize2;\n+      HOST_WIDE_INT offset2i;\n       bool reverse;\n-      base2 = get_ref_base_and_extent_hwi (gimple_assign_lhs (def_stmt),\n-\t\t\t\t\t   &offset2, &size2, &reverse);\n+      base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n+\t\t\t\t       &offset2, &size2, &maxsize2, &reverse);\n       if (base2\n \t  && !reverse\n-\t  && size2 % BITS_PER_UNIT == 0\n-\t  && offset2 % BITS_PER_UNIT == 0\n-\t  && operand_equal_p (base, base2, 0)\n+\t  && known_eq (maxsize2, size2)\n+\t  && multiple_p (size2, BITS_PER_UNIT)\n+\t  && multiple_p (offset2, BITS_PER_UNIT)\n+\t  && adjust_offsets_for_equal_base_address (base, &offset,\n+\t\t\t\t\t\t    base2, &offset2)\n+\t  && offset.is_constant (&offseti)\n+\t  && offset2.is_constant (&offset2i)\n \t  && known_subrange_p (offseti, maxsizei, offset2, size2))\n \t{\n \t  /* We support up to 512-bit values (for V8DFmode).  */\n@@ -2233,12 +2275,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t    rhs = SSA_VAL (rhs);\n \t  len = native_encode_expr (rhs,\n \t\t\t\t    buffer, sizeof (buffer),\n-\t\t\t\t    (offseti - offset2) / BITS_PER_UNIT);\n+\t\t\t\t    (offseti - offset2i) / BITS_PER_UNIT);\n \t  if (len > 0 && len * BITS_PER_UNIT >= maxsizei)\n \t    {\n \t      tree type = vr->type;\n \t      /* Make sure to interpret in a type that has a range\n-\t         covering the whole access size.  */\n+\t\t covering the whole access size.  */\n \t      if (INTEGRAL_TYPE_P (vr->type)\n \t\t  && maxsizei != TYPE_PRECISION (vr->type))\n \t\ttype = build_nonstandard_integer_type (maxsizei,\n@@ -2283,7 +2325,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n       if (!reverse\n \t  && known_size_p (maxsize2)\n \t  && known_eq (maxsize2, size2)\n-\t  && operand_equal_p (base, base2, 0)\n+\t  && adjust_offsets_for_equal_base_address (base, &offset,\n+\t\t\t\t\t\t    base2, &offset2)\n \t  && known_subrange_p (offset, maxsize, offset2, size2)\n \t  /* ???  We can't handle bitfield precision extracts without\n \t     either using an alternate type for the BIT_FIELD_REF and\n@@ -2653,10 +2696,10 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,\n     {\n       ao_ref r;\n       unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n-      vn_walk_cb_data data = { &vr1, NULL, kind };\n+      vn_walk_cb_data data (&vr1, NULL, kind, true);\n       if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))\n \t*vnresult =\n-\t  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,\n+\t  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, true,\n \t\t\t\t\t\t  vn_reference_lookup_2,\n \t\t\t\t\t\t  vn_reference_lookup_3,\n \t\t\t\t\t\t  vuse_valueize, limit, &data);\n@@ -2693,7 +2736,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n   vr1.operands = operands\n     = valueize_shared_reference_ops_from_ref (op, &valuezied_anything);\n   vr1.type = TREE_TYPE (op);\n-  vr1.set = tbaa_p ? get_alias_set (op) : 0;\n+  vr1.set = get_alias_set (op);\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n   if ((cst = fully_constant_vn_reference_p (&vr1)))\n     return cst;\n@@ -2710,11 +2753,9 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n \t  || !ao_ref_init_from_vn_reference (&r, vr1.set, vr1.type,\n \t\t\t\t\t     vr1.operands))\n \tao_ref_init (&r, op);\n-      if (! tbaa_p)\n-\tr.ref_alias_set = r.base_alias_set = 0;\n-      vn_walk_cb_data data = { &vr1, last_vuse_ptr, kind };\n+      vn_walk_cb_data data (&vr1, last_vuse_ptr, kind, tbaa_p);\n       wvnresult =\n-\t(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,\n+\t(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, tbaa_p,\n \t\t\t\t\t\tvn_reference_lookup_2,\n \t\t\t\t\t\tvn_reference_lookup_3,\n \t\t\t\t\t\tvuse_valueize, limit, &data);"}, {"sha": "838cf8fa31d6facef391a318357e010ab1a39e1d", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4697e30bd0cd4bda66932e21c183273a5d1e63/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=fb4697e30bd0cd4bda66932e21c183273a5d1e63", "patch": "@@ -298,7 +298,7 @@ avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p)\n \t    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n \t    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)),\n \t\tref.base_alias_set = ref.ref_alias_set = tbaa_p ? -1 : 0, true)\n-\t    && walk_non_aliased_vuses (&ref, vuse2, vuse_eq, NULL, NULL,\n+\t    && walk_non_aliased_vuses (&ref, vuse2, true, vuse_eq, NULL, NULL,\n \t\t\t\t       limit, vuse1) != NULL))\n \t{\n \t  if (insert)"}]}