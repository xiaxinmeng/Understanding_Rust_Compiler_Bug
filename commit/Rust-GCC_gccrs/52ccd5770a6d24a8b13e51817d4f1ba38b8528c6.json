{"sha": "52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJjY2Q1NzcwYTZkMjRhOGIxM2U1MTgxN2Q0ZjFiYTM4Yjg1MjhjNg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2006-08-26T21:55:28Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2006-08-26T21:55:28Z"}, "message": "arith.h: Update Copyright dates.\n\n2006-08-26  Steven G. Kargl  <kargls@comcast.net>\n\n\t* arith.h: Update Copyright dates.  Fix whitespace.\n\t* arith.c: Update Copyright dates.  Fix whitespace.  Fix comments.\n\t(gfc_arith_done_1): Clean up pedantic_min_int and subnormal.\n\nFrom-SVN: r116480", "tree": {"sha": "df0a6554d2681ea684caaae14f57577800be48ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df0a6554d2681ea684caaae14f57577800be48ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6/comments", "author": null, "committer": null, "parents": [{"sha": "02ec74b9d26c400f219a1975a1d39e03c39b3c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ec74b9d26c400f219a1975a1d39e03c39b3c0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ec74b9d26c400f219a1975a1d39e03c39b3c0c"}], "stats": {"total": 184, "additions": 108, "deletions": 76}, "files": [{"sha": "aa2b4fa2210ea341a68c331cb0e1a956f84ee04a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "patch": "@@ -1,3 +1,9 @@\n+2006-08-26  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* arith.h: Update Copyright dates.  Fix whitespace.\n+\t* arith.c: Update Copyright dates.  Fix whitespace.  Fix comments.\n+\t(gfc_arith_done_1): Clean up pedantic_min_int and subnormal.\n+\n 2006-08-26  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.texi: Note variable initialization causes SAVE attribute."}, {"sha": "884d810c99b52e50cacabde0daf24da04de2f970", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 99, "deletions": 74, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "patch": "@@ -1,6 +1,6 @@\n /* Compiler arithmetic\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -22,8 +22,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* Since target arithmetic must be done on the host, there has to\n    be some way of evaluating arithmetic expressions as the host\n-   would evaluate them.  We use the GNU MP library to do arithmetic,\n-   and this file provides the interface.  */\n+   would evaluate them.  We use the GNU MP library and the MPFR\n+   library to do arithmetic, and this file provides the interface.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -123,7 +123,6 @@ arctangent2 (mpfr_t y, mpfr_t x, mpfr_t result)\n     }\n \n   mpfr_clear (t);\n-\n }\n \n \n@@ -182,11 +181,11 @@ gfc_arith_init_1 (void)\n   mpfr_init (a);\n   mpz_init (r);\n \n-  /* Convert the minimum/maximum values for each kind into their\n+  /* Convert the minimum and maximum values for each kind into their\n      GNU MP representation.  */\n   for (int_info = gfc_integer_kinds; int_info->kind != 0; int_info++)\n     {\n-      /* Huge */\n+      /* Huge  */\n       mpz_set_ui (r, int_info->radix);\n       mpz_pow_ui (r, r, int_info->digits);\n \n@@ -215,7 +214,7 @@ gfc_arith_init_1 (void)\n       mpz_add (int_info->max_int, int_info->huge, int_info->huge);\n       mpz_add_ui (int_info->max_int, int_info->max_int, 1);\n \n-      /* Range */\n+      /* Range  */\n       mpfr_set_z (a, int_info->huge, GFC_RND_MODE);\n       mpfr_log10 (a, a, GFC_RND_MODE);\n       mpfr_trunc (a, a);\n@@ -234,60 +233,61 @@ gfc_arith_init_1 (void)\n       mpfr_init (c);\n \n       /* huge(x) = (1 - b**(-p)) * b**(emax-1) * b  */\n-      /* a = 1 - b**(-p) */\n+      /* a = 1 - b**(-p)  */\n       mpfr_set_ui (a, 1, GFC_RND_MODE);\n       mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n       mpfr_pow_si (b, b, -real_info->digits, GFC_RND_MODE);\n       mpfr_sub (a, a, b, GFC_RND_MODE);\n \n-      /* c = b**(emax-1) */\n+      /* c = b**(emax-1)  */\n       mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n       mpfr_pow_ui (c, b, real_info->max_exponent - 1, GFC_RND_MODE);\n \n-      /* a = a * c = (1 - b**(-p)) * b**(emax-1) */\n+      /* a = a * c = (1 - b**(-p)) * b**(emax-1)  */\n       mpfr_mul (a, a, c, GFC_RND_MODE);\n \n-      /* a = (1 - b**(-p)) * b**(emax-1) * b */\n+      /* a = (1 - b**(-p)) * b**(emax-1) * b  */\n       mpfr_mul_ui (a, a, real_info->radix, GFC_RND_MODE);\n \n       mpfr_init (real_info->huge);\n       mpfr_set (real_info->huge, a, GFC_RND_MODE);\n \n-      /* tiny(x) = b**(emin-1) */\n+      /* tiny(x) = b**(emin-1)  */\n       mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n       mpfr_pow_si (b, b, real_info->min_exponent - 1, GFC_RND_MODE);\n \n       mpfr_init (real_info->tiny);\n       mpfr_set (real_info->tiny, b, GFC_RND_MODE);\n \n-      /* subnormal (x) = b**(emin - digit) */\n+      /* subnormal (x) = b**(emin - digit)  */\n       mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n       mpfr_pow_si (b, b, real_info->min_exponent - real_info->digits,\n \t\t   GFC_RND_MODE);\n \n       mpfr_init (real_info->subnormal);\n       mpfr_set (real_info->subnormal, b, GFC_RND_MODE);\n \n-      /* epsilon(x) = b**(1-p) */\n+      /* epsilon(x) = b**(1-p)  */\n       mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n       mpfr_pow_si (b, b, 1 - real_info->digits, GFC_RND_MODE);\n \n       mpfr_init (real_info->epsilon);\n       mpfr_set (real_info->epsilon, b, GFC_RND_MODE);\n \n-      /* range(x) = int(min(log10(huge(x)), -log10(tiny)) */\n+      /* range(x) = int(min(log10(huge(x)), -log10(tiny))  */\n       mpfr_log10 (a, real_info->huge, GFC_RND_MODE);\n       mpfr_log10 (b, real_info->tiny, GFC_RND_MODE);\n       mpfr_neg (b, b, GFC_RND_MODE);\n \n+      /* a = min(a, b)  */\n       if (mpfr_cmp (a, b) > 0)\n-\tmpfr_set (a, b, GFC_RND_MODE);\t\t/* a = min(a, b) */\n+\tmpfr_set (a, b, GFC_RND_MODE);\n \n       mpfr_trunc (a, a);\n       gfc_mpfr_to_mpz (r, a);\n       real_info->range = mpz_get_si (r);\n \n-      /* precision(x) = int((p - 1) * log10(b)) + k */\n+      /* precision(x) = int((p - 1) * log10(b)) + k  */\n       mpfr_set_ui (a, real_info->radix, GFC_RND_MODE);\n       mpfr_log10 (a, a, GFC_RND_MODE);\n \n@@ -296,8 +296,7 @@ gfc_arith_init_1 (void)\n       gfc_mpfr_to_mpz (r, a);\n       real_info->precision = mpz_get_si (r);\n \n-      /* If the radix is an integral power of 10, add one to the\n-         precision.  */\n+      /* If the radix is an integral power of 10, add one to the precision.  */\n       for (i = 10; i <= real_info->radix; i *= 10)\n \tif (i == real_info->radix)\n \t  real_info->precision++;\n@@ -323,6 +322,7 @@ gfc_arith_done_1 (void)\n     {\n       mpz_clear (ip->min_int);\n       mpz_clear (ip->max_int);\n+      mpz_clear (ip->pedantic_min_int);\n       mpz_clear (ip->huge);\n     }\n \n@@ -331,6 +331,7 @@ gfc_arith_done_1 (void)\n       mpfr_clear (rp->epsilon);\n       mpfr_clear (rp->huge);\n       mpfr_clear (rp->tiny);\n+      mpfr_clear (rp->subnormal);\n     }\n }\n \n@@ -411,10 +412,10 @@ gfc_check_real_range (mpfr_t p, int kind)\n     }\n   else if (mpfr_cmp (q, gfc_real_kinds[i].tiny) < 0)\n     {\n-      /* MPFR operates on a numbers with a given precision and enormous\n-\texponential range.  To represent subnormal numbers the exponent is\n+      /* MPFR operates on a number with a given precision and enormous\n+\texponential range.  To represent subnormal numbers, the exponent is\n \tallowed to become smaller than emin, but always retains the full\n-\tprecision.  This function resets unused bits to 0 to alleviate\n+\tprecision.  This code resets unused bits to 0 to alleviate\n \trounding problems.  Note, a future version of MPFR will have a\n  \tmpfr_subnormalize() function, which handles this truncation in a\n \tmore efficient and robust way.  */\n@@ -428,7 +429,7 @@ gfc_check_real_range (mpfr_t p, int kind)\n       for (j = k; j < gfc_real_kinds[i].digits; j++)\n \tbin[j] = '0';\n       /* Need space for '0.', bin, 'E', and e */\n-      s = (char *) gfc_getmem (strlen(bin)+10);\n+      s = (char *) gfc_getmem (strlen(bin) + 10);\n       sprintf (s, \"0.%sE%d\", bin, (int) e);\n       mpfr_set_str (q, s, gfc_real_kinds[i].radix, GMP_RNDN);\n \n@@ -451,8 +452,7 @@ gfc_check_real_range (mpfr_t p, int kind)\n }\n \n \n-/* Function to return a constant expression node of a given type and\n-   kind.  */\n+/* Function to return a constant expression node of a given type and kind.  */\n \n gfc_expr *\n gfc_constant_result (bt type, int kind, locus * where)\n@@ -611,7 +611,6 @@ gfc_range_check (gfc_expr * e)\n \tmpfr_set_inf (e->value.complex.i, mpfr_sgn (e->value.complex.i));\n       if (rc == ARITH_NAN)\n \tmpfr_set_nan (e->value.complex.i);\n-\n       break;\n \n     default:\n@@ -792,9 +791,6 @@ gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       break;\n \n     case BT_COMPLEX:\n-\n-      /* FIXME:  possible numericals problem.  */\n-\n       gfc_set_model (op1->value.complex.r);\n       mpfr_init (x);\n       mpfr_init (y);\n@@ -809,7 +805,6 @@ gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n       mpfr_clear (x);\n       mpfr_clear (y);\n-\n       break;\n \n     default:\n@@ -872,7 +867,6 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       mpfr_init (y);\n       mpfr_init (div);\n \n-      /* FIXME: possible numerical problems.  */\n       mpfr_mul (x, op2->value.complex.r, op2->value.complex.r, GFC_RND_MODE);\n       mpfr_mul (y, op2->value.complex.i, op2->value.complex.i, GFC_RND_MODE);\n       mpfr_add (div, x, y, GFC_RND_MODE);\n@@ -892,7 +886,6 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       mpfr_clear (x);\n       mpfr_clear (y);\n       mpfr_clear (div);\n-\n       break;\n \n     default:\n@@ -919,7 +912,6 @@ complex_reciprocal (gfc_expr * op)\n   mpfr_init (re);\n   mpfr_init (im);\n \n-  /* FIXME:  another possible numerical problem.  */\n   mpfr_mul (mod, op->value.complex.r, op->value.complex.r, GFC_RND_MODE);\n   mpfr_mul (a, op->value.complex.i, op->value.complex.i, GFC_RND_MODE);\n   mpfr_add (mod, mod, a, GFC_RND_MODE);\n@@ -1038,7 +1030,6 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \t\t\t  result->value.integer);\n \t      mpz_clear (unity_z);\n \t    }\n-\n \t  break;\n \n \tcase BT_REAL:\n@@ -1140,7 +1131,7 @@ gfc_compare_expr (gfc_expr * op1, gfc_expr * op2)\n \n \n /* Compare a pair of complex numbers.  Naturally, this is only for\n-   equality/nonequality.  */\n+   equality and nonequality.  */\n \n static int\n compare_complex (gfc_expr * op1, gfc_expr * op2)\n@@ -1150,13 +1141,12 @@ compare_complex (gfc_expr * op1, gfc_expr * op2)\n }\n \n \n-/* Given two constant strings and the inverse collating sequence,\n-   compare the strings.  We return -1 for a<b, 0 for a==b and 1 for\n-   a>b.  If the xcoll_table is NULL, we use the processor's default\n-   collating sequence.  */\n+/* Given two constant strings and the inverse collating sequence, compare the\n+   strings.  We return -1 for a < b, 0 for a == b and 1 for a > b.  If the\n+   xcoll_table is NULL, we use the processor's default collating sequence.  */\n \n int\n-gfc_compare_string (gfc_expr * a, gfc_expr * b, const int *xcoll_table)\n+gfc_compare_string (gfc_expr * a, gfc_expr * b, const int * xcoll_table)\n {\n   int len, alen, blen, i, ac, bc;\n \n@@ -1168,7 +1158,7 @@ gfc_compare_string (gfc_expr * a, gfc_expr * b, const int *xcoll_table)\n   for (i = 0; i < len; i++)\n     {\n       /* We cast to unsigned char because default char, if it is signed,\n-         would lead to ac<0 for string[i] > 127.  */\n+         would lead to ac < 0 for string[i] > 127.  */\n       ac = (unsigned char) ((i < alen) ? a->value.character.string[i] : ' ');\n       bc = (unsigned char) ((i < blen) ? b->value.character.string[i] : ' ');\n \n@@ -1509,7 +1499,8 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n   switch (operator)\n     {\n-    case INTRINSIC_NOT:\t/* Logical unary */\n+    /* Logical unary  */\n+    case INTRINSIC_NOT:\n       if (op1->ts.type != BT_LOGICAL)\n \tgoto runtime;\n \n@@ -1519,7 +1510,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n       unary = 1;\n       break;\n \n-      /* Logical binary operators */\n+    /* Logical binary operators  */\n     case INTRINSIC_OR:\n     case INTRINSIC_AND:\n     case INTRINSIC_NEQV:\n@@ -1533,8 +1524,9 @@ eval_intrinsic (gfc_intrinsic_op operator,\n       unary = 0;\n       break;\n \n+    /* Numeric unary  */\n     case INTRINSIC_UPLUS:\n-    case INTRINSIC_UMINUS:\t/* Numeric unary */\n+    case INTRINSIC_UMINUS:\n       if (!gfc_numeric_ts (&op1->ts))\n \tgoto runtime;\n \n@@ -1549,9 +1541,10 @@ eval_intrinsic (gfc_intrinsic_op operator,\n       unary = 1;\n       break;\n \n+    /* Additional restrictions for ordering relations.  */\n     case INTRINSIC_GE:\n-    case INTRINSIC_LT:\t\t/* Additional restrictions  */\n-    case INTRINSIC_LE:          /* for ordering relations.  */\n+    case INTRINSIC_LT:\n+    case INTRINSIC_LE:\n     case INTRINSIC_GT:\n       if (op1->ts.type == BT_COMPLEX || op2->ts.type == BT_COMPLEX)\n \t{\n@@ -1560,8 +1553,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \t  goto runtime;\n \t}\n \n-      /* else fall through */\n-\n+    /* Fall through  */\n     case INTRINSIC_EQ:\n     case INTRINSIC_NE:\n       if (op1->ts.type == BT_CHARACTER && op2->ts.type == BT_CHARACTER)\n@@ -1572,17 +1564,18 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \t  break;\n \t}\n \n-      /* else fall through */\n-\n+    /* Fall through  */\n+    /* Numeric binary  */\n     case INTRINSIC_PLUS:\n     case INTRINSIC_MINUS:\n     case INTRINSIC_TIMES:\n     case INTRINSIC_DIVIDE:\n-    case INTRINSIC_POWER:\t/* Numeric binary */\n+    case INTRINSIC_POWER:\n       if (!gfc_numeric_ts (&op1->ts) || !gfc_numeric_ts (&op2->ts))\n \tgoto runtime;\n \n-      /* Insert any necessary type conversions to make the operands compatible.  */\n+      /* Insert any necessary type conversions to make the operands\n+\t compatible.  */\n \n       temp.expr_type = EXPR_OP;\n       gfc_clear_ts (&temp.ts);\n@@ -1604,7 +1597,8 @@ eval_intrinsic (gfc_intrinsic_op operator,\n       unary = 0;\n       break;\n \n-    case INTRINSIC_CONCAT:\t/* Character binary */\n+    /* Character binary  */\n+    case INTRINSIC_CONCAT:\n       if (op1->ts.type != BT_CHARACTER || op2->ts.type != BT_CHARACTER)\n \tgoto runtime;\n \n@@ -1628,16 +1622,16 @@ eval_intrinsic (gfc_intrinsic_op operator,\n   if (op1->from_H\n       || (op1->expr_type != EXPR_CONSTANT\n \t  && (op1->expr_type != EXPR_ARRAY\n-\t    || !gfc_is_constant_expr (op1)\n-\t    || !gfc_expanded_ac (op1))))\n+\t      || !gfc_is_constant_expr (op1)\n+\t      || !gfc_expanded_ac (op1))))\n     goto runtime;\n \n   if (op2 != NULL\n       && (op2->from_H\n-\t|| (op2->expr_type != EXPR_CONSTANT\n-\t  && (op2->expr_type != EXPR_ARRAY\n-\t    || !gfc_is_constant_expr (op2)\n-\t    || !gfc_expanded_ac (op2)))))\n+\t  || (op2->expr_type != EXPR_CONSTANT\n+\t      && (op2->expr_type != EXPR_ARRAY\n+\t      || !gfc_is_constant_expr (op2)\n+\t      || !gfc_expanded_ac (op2)))))\n     goto runtime;\n \n   if (unary)\n@@ -1646,7 +1640,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n     rc = reduce_binary (eval.f3, op1, op2, &result);\n \n   if (rc != ARITH_OK)\n-    {\t\t\t\t/* Something went wrong */\n+    { /* Something went wrong.  */\n       gfc_error (gfc_arith_error (rc), &op1->where);\n       return NULL;\n     }\n@@ -1656,7 +1650,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n   return result;\n \n runtime:\n-  /* Create a run-time expression */\n+  /* Create a run-time expression.  */\n   result = gfc_get_expr ();\n   result->ts = temp.ts;\n \n@@ -1673,8 +1667,9 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n \n /* Modify type of expression for zero size array.  */\n+\n static gfc_expr *\n-eval_type_intrinsic0 (gfc_intrinsic_op operator, gfc_expr *op)\n+eval_type_intrinsic0 (gfc_intrinsic_op operator, gfc_expr * op)\n {\n   if (op == NULL)\n     gfc_internal_error (\"eval_type_intrinsic0(): op NULL\");\n@@ -1776,115 +1771,132 @@ eval_intrinsic_f3 (gfc_intrinsic_op operator,\n }\n \n \n-\n gfc_expr *\n gfc_uplus (gfc_expr * op)\n {\n   return eval_intrinsic_f2 (INTRINSIC_UPLUS, gfc_arith_uplus, op, NULL);\n }\n \n+\n gfc_expr *\n gfc_uminus (gfc_expr * op)\n {\n   return eval_intrinsic_f2 (INTRINSIC_UMINUS, gfc_arith_uminus, op, NULL);\n }\n \n+\n gfc_expr *\n gfc_add (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_PLUS, gfc_arith_plus, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_subtract (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_MINUS, gfc_arith_minus, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_multiply (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_TIMES, gfc_arith_times, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_divide (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_DIVIDE, gfc_arith_divide, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_power (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_POWER, gfc_arith_power, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_concat (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_CONCAT, gfc_arith_concat, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_and (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_AND, gfc_arith_and, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_or (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_OR, gfc_arith_or, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_not (gfc_expr * op1)\n {\n   return eval_intrinsic_f2 (INTRINSIC_NOT, gfc_arith_not, op1, NULL);\n }\n \n+\n gfc_expr *\n gfc_eqv (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_EQV, gfc_arith_eqv, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_neqv (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_NEQV, gfc_arith_neqv, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_eq (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_EQ, gfc_arith_eq, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_ne (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_NE, gfc_arith_ne, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_gt (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_GT, gfc_arith_gt, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_ge (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_GE, gfc_arith_ge, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_lt (gfc_expr * op1, gfc_expr * op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_LT, gfc_arith_lt, op1, op2);\n }\n \n+\n gfc_expr *\n gfc_le (gfc_expr * op1, gfc_expr * op2)\n {\n@@ -1895,13 +1907,13 @@ gfc_le (gfc_expr * op1, gfc_expr * op2)\n /* Convert an integer string to an expression node.  */\n \n gfc_expr *\n-gfc_convert_integer (const char *buffer, int kind, int radix, locus * where)\n+gfc_convert_integer (const char * buffer, int kind, int radix, locus * where)\n {\n   gfc_expr *e;\n   const char *t;\n \n   e = gfc_constant_result (BT_INTEGER, kind, where);\n-  /* a leading plus is allowed, but not by mpz_set_str */\n+  /* A leading plus is allowed, but not by mpz_set_str.  */\n   if (buffer[0] == '+')\n     t = buffer + 1;\n   else\n@@ -1915,7 +1927,7 @@ gfc_convert_integer (const char *buffer, int kind, int radix, locus * where)\n /* Convert a real string to an expression node.  */\n \n gfc_expr *\n-gfc_convert_real (const char *buffer, int kind, locus * where)\n+gfc_convert_real (const char * buffer, int kind, locus * where)\n {\n   gfc_expr *e;\n \n@@ -1989,6 +2001,7 @@ arith_error (arith rc, gfc_typespec * from, gfc_typespec * to, locus * where)\n      NaN, etc.  */\n }\n \n+\n /* Convert integers to integers.  */\n \n gfc_expr *\n@@ -2269,28 +2282,35 @@ gfc_log2log (gfc_expr * src, int kind)\n   return result;\n }\n \n+\n /* Convert logical to integer.  */\n \n gfc_expr *\n gfc_log2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n+\n   result = gfc_constant_result (BT_INTEGER, kind, &src->where);\n   mpz_set_si (result->value.integer, src->value.logical);\n+\n   return result;\n }\n \n+\n /* Convert integer to logical.  */\n \n gfc_expr *\n gfc_int2log (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n+\n   result = gfc_constant_result (BT_LOGICAL, kind, &src->where);\n   result->value.logical = (mpz_cmp_si (src->value.integer, 0) != 0);\n+\n   return result;\n }\n \n+\n /* Convert Hollerith to integer. The constant will be padded or truncated.  */\n \n gfc_expr *\n@@ -2320,12 +2340,13 @@ gfc_hollerith2int (gfc_expr * src, int kind)\n   if (len < kind)\n     memset (&result->value.character.string[len], ' ', kind - len);\n \n-  result->value.character.string[kind] = '\\0'; /* For debugger */\n+  result->value.character.string[kind] = '\\0'; /* For debugger  */\n   result->value.character.length = kind;\n \n   return result;\n }\n \n+\n /* Convert Hollerith to real. The constant will be padded or truncated.  */\n \n gfc_expr *\n@@ -2355,12 +2376,13 @@ gfc_hollerith2real (gfc_expr * src, int kind)\n   if (len < kind)\n     memset (&result->value.character.string[len], ' ', kind - len);\n \n-  result->value.character.string[kind] = '\\0'; /* For debugger */\n+  result->value.character.string[kind] = '\\0'; /* For debugger.  */\n   result->value.character.length = kind;\n \n   return result;\n }\n \n+\n /* Convert Hollerith to complex. The constant will be padded or truncated.  */\n \n gfc_expr *\n@@ -2392,12 +2414,13 @@ gfc_hollerith2complex (gfc_expr * src, int kind)\n   if (len < kind)\n     memset (&result->value.character.string[len], ' ', kind - len);\n \n-  result->value.character.string[kind] = '\\0'; /* For debugger */\n+  result->value.character.string[kind] = '\\0'; /* For debugger  */\n   result->value.character.length = kind;\n \n   return result;\n }\n \n+\n /* Convert Hollerith to character. */\n \n gfc_expr *\n@@ -2413,6 +2436,7 @@ gfc_hollerith2character (gfc_expr * src, int kind)\n   return result;\n }\n \n+\n /* Convert Hollerith to logical. The constant will be padded or truncated.  */\n \n gfc_expr *\n@@ -2442,14 +2466,15 @@ gfc_hollerith2logical (gfc_expr * src, int kind)\n   if (len < kind)\n     memset (&result->value.character.string[len], ' ', kind - len);\n \n-  result->value.character.string[kind] = '\\0'; /* For debugger */\n+  result->value.character.string[kind] = '\\0'; /* For debugger  */\n   result->value.character.length = kind;\n \n   return result;\n }\n \n+\n /* Returns an initializer whose value is one higher than the value of the\n-   LAST_INITIALIZER argument.  If that is argument is NULL, the\n+   LAST_INITIALIZER argument.  If the argument is NULL, the\n    initializers value will be set to zero.  The initializer's kind\n    will be set to gfc_c_int_kind.\n \n@@ -2458,7 +2483,7 @@ gfc_hollerith2logical (gfc_expr * src, int kind)\n    here if an initializer exceeds gfc_c_int_kind.  */\n \n gfc_expr *\n-gfc_enum_initializer (gfc_expr *last_initializer, locus where)\n+gfc_enum_initializer (gfc_expr * last_initializer, locus where)\n {\n   gfc_expr *result;\n \n@@ -2485,7 +2510,7 @@ gfc_enum_initializer (gfc_expr *last_initializer, locus where)\n   else\n     {\n       /* Control comes here, if it's the very first enumerator and no\n-         initializer has been given.  It will be initialized to ZERO (0). */\n+         initializer has been given.  It will be initialized to zero.  */\n       mpz_set_si (result->value.integer, 0);\n     }\n "}, {"sha": "b674165a81f678cd9eb81ced504fdf090e357ca2", "filename": "gcc/fortran/arith.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6/gcc%2Ffortran%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6/gcc%2Ffortran%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.h?ref=52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "patch": "@@ -1,5 +1,6 @@\n /* Compiler arithmetic header.\n-   Copyright (C) 2000, 2001, 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Steven Bosscher\n \n This file is part of GCC.\n@@ -29,7 +30,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    to a mpz_t, so declare a function for this as well.  */\n \n void arctangent2 (mpfr_t, mpfr_t, mpfr_t);\n-void gfc_mpfr_to_mpz(mpz_t, mpfr_t);\n+void gfc_mpfr_to_mpz (mpz_t, mpfr_t);\n void gfc_set_model_kind (int);\n void gfc_set_model (mpfr_t);\n "}]}