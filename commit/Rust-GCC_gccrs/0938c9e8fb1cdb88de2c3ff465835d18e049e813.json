{"sha": "0938c9e8fb1cdb88de2c3ff465835d18e049e813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzOGM5ZThmYjFjZGI4OGRlMmMzZmY0NjU4MzVkMThlMDQ5ZTgxMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-11-02T09:34:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-11-02T09:34:54Z"}, "message": "Makefile.in (targhooks.o, reload.o): Update dependencies.\n\n\t* Makefile.in (targhooks.o, reload.o): Update dependencies.\n\t(GTFILES): Add targhooks.c.\n\t(gt-targhooks.h): New rule; depend on s-gtype.\n\t* target.h (direct_pool_load_p): New hook.\n\t* target-def.h (TARGET_DIRECT_POOL_LOAD_P): New macro.\n\t(TARGET_INITIALIZER): Include it.\n\t* targhooks.h (default_direct_pool_load_p): Declare.\n\t(hook_bool_machine_mode_true): Declare.\n\t* targhooks.c: Include insn-config.h, recog.h, ggc.h and\n\tgt-targhooks.h.\n\t(pool_symbol): New variable.\n\t(default_direct_pool_load_p): New function.\n\t(hook_bool_machine_mode_true): New function.\n\t* reload.c: Include target.h.\n\t(find_reloads): If an alternative will force a constant into memory,\n\tcount an extra reload if constant pool symbols are not valid\n\taddresses.  If an alternative uses memory to move values between\n\tregisters, count the move as two reloads rather than one.\n\t* config/s390/s390.c (TARGET_DIRECT_POOL_LOAD_P): Define.\n\t* doc/tm.texi (TARGET_DIRECT_POOL_LOAD_P): Document.\n\nFrom-SVN: r73196", "tree": {"sha": "417cb41087b6a363102c51ebf7a4358bd360b492", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/417cb41087b6a363102c51ebf7a4358bd360b492"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0938c9e8fb1cdb88de2c3ff465835d18e049e813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0938c9e8fb1cdb88de2c3ff465835d18e049e813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0938c9e8fb1cdb88de2c3ff465835d18e049e813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0938c9e8fb1cdb88de2c3ff465835d18e049e813/comments", "author": null, "committer": null, "parents": [{"sha": "e69cdc1237a4be0650026452ee57b886f1b1dbbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69cdc1237a4be0650026452ee57b886f1b1dbbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69cdc1237a4be0650026452ee57b886f1b1dbbe"}], "stats": {"total": 115, "additions": 111, "deletions": 4}, "files": [{"sha": "dd9854a20993bbf6ce70f832d04ef2791b2387fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -1,3 +1,26 @@\n+2003-11-02  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* Makefile.in (targhooks.o, reload.o): Update dependencies.\n+\t(GTFILES): Add targhooks.c.\n+\t(gt-targhooks.h): New rule; depend on s-gtype.\n+\t* target.h (direct_pool_load_p): New hook.\n+\t* target-def.h (TARGET_DIRECT_POOL_LOAD_P): New macro.\n+\t(TARGET_INITIALIZER): Include it.\n+\t* targhooks.h (default_direct_pool_load_p): Declare.\n+\t(hook_bool_machine_mode_true): Declare.\n+\t* targhooks.c: Include insn-config.h, recog.h, ggc.h and\n+\tgt-targhooks.h.\n+\t(pool_symbol): New variable.\n+\t(default_direct_pool_load_p): New function.\n+\t(hook_bool_machine_mode_true): New function.\n+\t* reload.c: Include target.h.\n+\t(find_reloads): If an alternative will force a constant into memory,\n+\tcount an extra reload if constant pool symbols are not valid\n+\taddresses.  If an alternative uses memory to move values between\n+\tregisters, count the move as two reloads rather than one.\n+\t* config/s390/s390.c (TARGET_DIRECT_POOL_LOAD_P): Define.\n+\t* doc/tm.texi (TARGET_DIRECT_POOL_LOAD_P): Document.\n+\n 2003-11-02  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR optimization/12799"}, {"sha": "88184f31008a96c170fc2a34c86b78bc70f29e7d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -1522,7 +1522,7 @@ opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \\\n \toutput.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h\n targhooks.o : targhooks.c targhooks.h $(CONFIG_H) $(SYSTEM_H) \\\n \tcoretypes.h $(TREE_H) $(TM_H) $(RTL_H) $(TM_P_H) function.h \\\n-\toutput.h toplev.h\n+\toutput.h toplev.h insn-config.h $(RECOG_H) $(GGC_H) gt-targhooks.h\n \n toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n    function.h flags.h xcoffout.h input.h $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) \\\n@@ -1765,7 +1765,7 @@ ra-rewrite.o : ra-rewrite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H)\n    output.h except.h ra.h reload.h insn-config.h\n reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h output.h \\\n    $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) hard-reg-set.h insn-config.h \\\n-   $(REGS_H) function.h real.h toplev.h $(TM_P_H)\n+   $(REGS_H) function.h real.h toplev.h $(TM_P_H) $(TARGET_H)\n reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) real.h flags.h \\\n    $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(RECOG_H) output.h function.h toplev.h $(TM_P_H) \\\n@@ -2074,7 +2074,8 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \\\n   $(srcdir)/profile.c $(srcdir)/ra-build.c $(srcdir)/regclass.c \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/langhooks.c \\\n   $(srcdir)/sdbout.c $(srcdir)/stmt.c $(srcdir)/stor-layout.c \\\n-  $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n+  $(srcdir)/stringpool.c $(srcdir)/targhooks.c $(srcdir)/tree.c \\\n+  $(srcdir)/varasm.c \\\n   $(out_file) \\\n   @all_gtfiles@\n \n@@ -2091,7 +2092,7 @@ gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h \\\n gt-dwarf2out.h gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h \\\n gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parse.h \\\n gt-c-pragma.h gtype-c.h gt-input.h gt-cfglayout.h \\\n-gt-stringpool.h gt-langhooks.h : s-gtype ; @true\n+gt-stringpool.h gt-targhooks.h gt-langhooks.h : s-gtype ; @true\n \n gtyp-gen.h: Makefile\n \techo \"/* This file is machine generated.  Do not edit.  */\" > tmp-gtyp.h"}, {"sha": "ede221e35288dd641c1566b4fc23803bf11572f9", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -134,6 +134,8 @@ static tree s390_build_builtin_va_list (void);\n #define TARGET_RTX_COSTS s390_rtx_costs\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST s390_address_cost\n+#undef TARGET_DIRECT_POOL_LOAD_P\n+#define TARGET_DIRECT_POOL_LOAD_P hook_bool_machine_mode_true\n \n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG s390_reorg"}, {"sha": "51167f83cb84857c48f1010a09f59ebd435ecbe8", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -5402,6 +5402,19 @@ should probably only be given to addresses with different numbers of\n registers on machines with lots of registers.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_DIRECT_POOL_LOAD_P (enum machine_mode @var{m})\n+This hook should return true if values of mode @var{m} can usually be loaded\n+directly from the constant pool, without using an intermediate register\n+to hold the address.\n+\n+The hook is only a heuristic, it has no bearing on correctness.\n+If it returns false, reload will be less likely to force constants\n+into memory.\n+\n+The default definition returns true if an ordinary local symbol is\n+a valid address.\n+@end deftypefn\n+\n @node Scheduling\n @section Adjusting the Instruction Scheduler\n "}, {"sha": "13dd25ed06120b7ed2cf16d197380ca7b9df0039", "filename": "gcc/reload.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -104,6 +104,7 @@ a register with any other reload.  */\n #include \"output.h\"\n #include \"function.h\"\n #include \"toplev.h\"\n+#include \"target.h\"\n \n #ifndef REGNO_MODE_OK_FOR_BASE_P\n #define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) REGNO_OK_FOR_BASE_P (REGNO)\n@@ -3369,6 +3370,11 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t  const_to_mem = 1;\n \t\t  if (this_alternative[i] != (int) NO_REGS)\n \t\t    losers++;\n+\n+\t\t  /* If constant pool symbols are not valid addresses,\n+\t\t     count an extra reload for the address.  */\n+\t\t  if (!targetm.direct_pool_load_p (operand_mode[i]))\n+\t\t    losers++;\n \t\t}\n \n \t      /* If we can't reload this value at all, reject this\n@@ -3394,6 +3400,21 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t       && ! const_to_mem)\n \t\tbad = 1;\n \n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t      /* If this alternative would use memory to move a value\n+\t\t between registers, it would need two reloads, one for\n+\t\t the load and one for the store.  Account for the extra\n+\t\t reload here.  */\n+\t      if (GET_CODE (operand) == REG\n+\t\t  && REGNO (operand) < FIRST_PSEUDO_REGISTER\n+\t\t  && this_alternative[i] != NO_REGS\n+\t\t  && (SECONDARY_MEMORY_NEEDED\n+\t\t      (this_alternative[i],\n+\t\t       REGNO_REG_CLASS (REGNO (operand)),\n+\t\t       GET_MODE (operand))))\n+\t\tlosers++;\n+#endif\n+\n \t      /* We prefer to reload pseudos over reloading other things,\n \t\t since such reloads may be able to be eliminated later.\n \t\t If we are reloading a SCRATCH, we won't be generating any"}, {"sha": "c4eeb93430089250d53c151e64e25b48c0c4bbf8", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -262,6 +262,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n /* In cse.c.  */\n #define TARGET_ADDRESS_COST default_address_cost\n \n+#define TARGET_DIRECT_POOL_LOAD_P default_direct_pool_load_p\n+\n /* In builtins.c.  */\n #define TARGET_INIT_BUILTINS hook_void_void\n #define TARGET_EXPAND_BUILTIN default_expand_builtin\n@@ -377,6 +379,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_VECTOR_OPAQUE_P,\t\t\t\\\n   TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_ADDRESS_COST,\t\t\t\t\\\n+  TARGET_DIRECT_POOL_LOAD_P,\t\t\t\\\n   TARGET_DWARF_REGISTER_SPAN,                   \\\n   TARGET_MACHINE_DEPENDENT_REORG,\t\t\\\n   TARGET_BUILD_BUILTIN_VA_LIST,\t\t\t\\"}, {"sha": "fbea5207c906e2ad8b3d52da28534ddf28c5cab2", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -370,6 +370,8 @@ struct gcc_target\n      invalid addresses.  */\n   int (* address_cost) (rtx x);\n \n+  bool (* direct_pool_load_p) (enum machine_mode);\n+\n   /* Given a register, this hook should return a parallel of registers\n      to represent where to find the register pieces.  Define this hook\n      if the register and its mode are represented in Dwarf in"}, {"sha": "9be6786b53bc5377d17b505e56bcdd5a78ba2e87", "filename": "gcc/targhooks.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -61,6 +61,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"tm_p.h\"\n #include \"target-def.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"ggc.h\"\n \n void\n default_external_libcall (rtx fun ATTRIBUTE_UNUSED)\n@@ -196,9 +199,45 @@ default_pretend_outgoing_varargs_named(CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n #endif\n }\n \n+/* A SYMBOL_REF for a local symbol.  Used by default_direct_pool_load_p.  */\n+\n+static GTY(()) rtx pool_symbol;\n+\n+/* See whether a local symbol is a valid address for MODE.  If so, assume\n+   that constant pool symbols are also valid addresses, otherwise assume\n+   that they aren't.\n+\n+   ??? This is only an approximation.  We can't test constant pool\n+   symbols directly without forcing something into the constant pool.  */\n+\n+bool\n+default_direct_pool_load_p (enum machine_mode mode)\n+{\n+  if (pool_symbol == 0)\n+    {\n+      char label[256];\n+\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", 0);\n+      pool_symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n+      SYMBOL_REF_FLAGS (pool_symbol) = SYMBOL_FLAG_LOCAL;\n+    }\n+  return memory_address_p (mode, pool_symbol);\n+}\n+\n /* Generic hook that takes a CUMULATIVE_ARGS pointer and returns true.  */\n+\n bool\n hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS * a ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n+\n+/* Generic hook that takes a machine mode and returns true.  */\n+\n+bool\n+hook_bool_machine_mode_true (enum machine_mode a ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+#include \"gt-targhooks.h\""}, {"sha": "f188ce201b28ab420ed372bf3c1081430e3b7bb1", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0938c9e8fb1cdb88de2c3ff465835d18e049e813/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=0938c9e8fb1cdb88de2c3ff465835d18e049e813", "patch": "@@ -32,4 +32,7 @@ extern void default_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode\n extern bool default_strict_argument_naming (CUMULATIVE_ARGS *);\n extern bool default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n \n+extern bool default_direct_pool_load_p (enum machine_mode);\n+\n extern bool hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS *);\n+extern bool hook_bool_machine_mode_true (enum machine_mode);"}]}