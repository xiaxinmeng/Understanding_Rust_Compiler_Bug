{"sha": "eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlZmFlMGVjMzU5MDRlODU0ZDRmOGEwOTdmZGIzZTdjNjc4YWZmOA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-02-06T08:24:22Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-02-06T08:24:22Z"}, "message": "cppfiles.c (read_and_prescan): Bump input pointer before possibly branching off to the backslash code.\n\n\t* cppfiles.c (read_and_prescan) [case SPECCASE_QUESTION]: Bump\n\tinput pointer before possibly branching off to the backslash\n\tcode.\n\t* cpphash.c (macroexpand): Correctly delete \\r escapes when\n\tstringifying parameters.\n\t* cpplib.c (copy_rest_of_line): Go directly to skip_block_comment\n\tif we can; bail out early if we hit a line comment.\n\t(handle_directive): Treat '# 123' in an .S file just like\n\t'# <punctuation>'.  Discard the shifted '#' if we hit '#\\n'.\n\tReturn 1 for '# not_a_directive'.\n\t(get_directive_token): Pop macro buffers here, so that\n\tcpp_get_token can't sneakily move past a newline.\n\tAdd sanity checks.\n\t(cpp_get_token): goto randomchar if handle_directive returns 0.\n\nFrom-SVN: r31819", "tree": {"sha": "b4662b68daf63cc7cf16c2fab569a5dde8daa2ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4662b68daf63cc7cf16c2fab569a5dde8daa2ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/comments", "author": null, "committer": null, "parents": [{"sha": "1316f1f7fcb21e1f5c807f2a3a84f177674e0e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1316f1f7fcb21e1f5c807f2a3a84f177674e0e5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1316f1f7fcb21e1f5c807f2a3a84f177674e0e5b"}], "stats": {"total": 198, "additions": 157, "deletions": 41}, "files": [{"sha": "e0894f9b28b0af27f74c55e556b34d170ca3ae06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "patch": "@@ -1,5 +1,20 @@\n 2000-02-05  Zack Weinberg  <zack@wolery.cumb.org>\n \n+\t* cppfiles.c (read_and_prescan) [case SPECCASE_QUESTION]: Bump\n+\tinput pointer before possibly branching off to the backslash\n+\tcode.\n+\t* cpphash.c (macroexpand): Correctly delete \\r escapes when\n+\tstringifying parameters.\n+\t* cpplib.c (copy_rest_of_line): Go directly to skip_block_comment\n+\tif we can; bail out early if we hit a line comment.\n+\t(handle_directive): Treat '# 123' in an .S file just like\n+\t'# <punctuation>'.  Discard the shifted '#' if we hit '#\\n'.\n+\tReturn 1 for '# not_a_directive'.\n+\t(get_directive_token): Pop macro buffers here, so that\n+\tcpp_get_token can't sneakily move past a newline.\n+\tAdd sanity checks. \n+\t(cpp_get_token): goto randomchar if handle_directive returns 0.\n+\n \t* cppalloc.c: Update copyright.\n \t* cpplib.c: Merge all the static function prototypes into one\n \tblock."}, {"sha": "36e330572eae053f022fa7b702a34eff1b2795f1", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "patch": "@@ -1017,6 +1017,7 @@ read_and_prescan (pfile, fp, desc, len)\n \t\t    *op++ = '?';\n \t\t    break;\n \t\t  }\n+\t\tip += 2;\n \t\tif (CPP_OPTIONS (pfile)->warn_trigraphs)\n \t\t  {\n \t\t    unsigned long col;\n@@ -1042,7 +1043,6 @@ read_and_prescan (pfile, fp, desc, len)\n \t\t    *op++ = '?';\n \t\t    *op++ = d;\n \t\t  }\n-\t\tip += 2;\n \t      }\n \t    }\n \t}"}, {"sha": "64491c577622cf6aa3d2fa66ed7e12cea471935e", "filename": "gcc/cpphash.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "patch": "@@ -1158,18 +1158,17 @@ macroexpand (pfile, hp)\n \n \t\t      if (!in_string)\n \t\t\t{\n+\t\t\t  /* Delete \"\\r \" and \"\\r-\" escapes.  */\n+\t\t\t  if (c == '\\r')\n+\t\t\t    {\n+\t\t\t      i++;\n+\t\t\t      continue;\n+\t\t\t    }\n \t\t\t  /* Internal sequences of whitespace are\n \t\t\t     replaced by one space except within\n \t\t\t     a string or char token. */\n-\t\t\t  if (is_space(c))\n+\t\t\t  else if (is_space(c))\n \t\t\t    {\n-\t\t\t      if (CPP_WRITTEN (pfile) > (unsigned) arg->stringified\n-\t\t\t\t  && (CPP_PWRITTEN (pfile))[-1] == '\\r')\n-\t\t\t\t{\n-\t\t\t\t  /* \"\\r \" escape markers are removed */\n-\t\t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n-\t\t\t\t  continue;\n-\t\t\t\t}\n \t\t\t      if (need_space == 0)\n \t\t\t\tneed_space = 1;\n \t\t\t      continue;"}, {"sha": "40c3c3a94b63bd70addd76230ff1914b630b8bca", "filename": "gcc/cpplib.c", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "patch": "@@ -468,15 +468,18 @@ copy_rest_of_line (pfile)\n \t  parse_string (pfile, c);\n \t  continue;\n \tcase '/':\n-\t  if (PEEKC() == '*' && CPP_TRADITIONAL (pfile))\n+\t  if (PEEKC() == '*')\n \t    {\n-\t      CPP_PUTS (pfile, \"/**/\", 4);\n-\t      skip_comment (pfile, c);\n+\t      if (CPP_TRADITIONAL (pfile))\n+\t\tCPP_PUTS (pfile, \"/**/\", 4);\n+\t      skip_block_comment (pfile);\n \t      continue;\n \t    }\n \t  /* else fall through */\n \tcase '-':\n \t  c = skip_comment (pfile, c);\n+\t  if (c == ' ')\n+\t    return;\n \t  break;\n \n \tcase '\\f':\n@@ -527,10 +530,7 @@ handle_directive (pfile)\n   if (c >= '0' && c <= '9')\n     {\n       if (CPP_OPTIONS (pfile)->lang_asm)\n-\t{\n-\t  skip_rest_of_line (pfile);\n-\t  return 1;\n-\t}\n+\treturn 0;\n \n       if (CPP_PEDANTIC (pfile)\n \t  && ! CPP_PREPROCESSED (pfile)\n@@ -552,21 +552,20 @@ handle_directive (pfile)\n   ident_length = CPP_PWRITTEN (pfile) - ident;\n   if (ident_length == 0)\n     {\n-      /* A line of just `#' becomes blank.  */\n-      if (PEEKC() == '\\n')\n-\treturn 1;\n-      else\n-\treturn 0;\n+      /* A line of just `#' becomes blank.  A line with something\n+         other than an identifier after the # is reparsed as a non-\n+         directive line.  */\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      return (PEEKC() == '\\n');\n     }\n \n-  /*\n-   * Decode the keyword and call the appropriate expansion\n-   * routine, after moving the input pointer up to the next line.\n-   */\n+  /* Decode the keyword and call the appropriate expansion routine.  */\n   for (kt = directive_table; ; kt++)\n     {\n       if (kt->length <= 0)\n-\treturn 0;\n+\t/* # identifier, but not a legit directive.  Pass onward as a\n+\t   CPP_DIRECTIVE token anyway - let the consumer worry about it.  */\n+\treturn 1;\n       if (kt->length == ident_length\n \t  && !strncmp (kt->name, ident, ident_length)) \n \tbreak;\n@@ -983,26 +982,43 @@ static enum cpp_token\n get_directive_token (pfile)\n      cpp_reader *pfile;\n {\n+  long old_written = CPP_WRITTEN (pfile);\n+  enum cpp_token token;\n+\n   for (;;)\n     {\n-      long old_written = CPP_WRITTEN (pfile);\n-      enum cpp_token token;\n       cpp_skip_hspace (pfile);\n       if (PEEKC () == '\\n')\n-\t  return CPP_VSPACE;\n+\treturn CPP_VSPACE;\n+\n       token = cpp_get_token (pfile);\n-      switch (token)\n-      {\n-      case CPP_POP:\n-\t  if (! CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t      return token;\n-\t  /* ... else fall though ...  */\n-      case CPP_HSPACE:  case CPP_COMMENT:\n+      /* token could be hspace at the beginning of a macro.  */\n+      if (token == CPP_HSPACE || token == CPP_COMMENT)\n+\t{\n \t  CPP_SET_WRITTEN (pfile, old_written);\n-\t  break;\n-      default:\n+\t  continue;\n+\t}\n+\n+      /* token cannot be vspace, it would have been caught above.  */\n+      if (token == CPP_VSPACE)\n+\t{\n+\t  cpp_fatal (pfile, \"VSPACE in get_directive_token\");\n \t  return token;\n-      }\n+\t}\n+\n+      /* token cannot be POP unless the buffer is a macro buffer.  */\n+      if (token != CPP_POP)\n+\treturn token;\n+\n+      if (! CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+\t{\n+\t  cpp_fatal (pfile, \"POP of file buffer in get_directive_token\");\n+\t  return token;\n+\t}\n+\n+      /* We must pop the buffer by hand, else cpp_get_token might hand\n+\t us whitespace or newline on the next invocation.  */\n+      cpp_pop_buffer (pfile);\n     }\n }\n \f\n@@ -2246,7 +2262,7 @@ if_directive_name (pfile, ifs)\n \n /* Get the next token, and add it to the text in pfile->token_buffer.\n    Return the kind of token we got.  */\n-  \n+\n enum cpp_token\n cpp_get_token (pfile)\n      cpp_reader *pfile;\n@@ -2345,7 +2361,7 @@ cpp_get_token (pfile)\n \t  if (handle_directive (pfile))\n \t    return CPP_DIRECTIVE;\n \t  pfile->only_seen_white = 0;\n-\t  return CPP_OTHER;\n+\t  goto randomchar;\n \n \tcase '\\\"':\n \tcase '\\'':"}, {"sha": "64647e25a8c330115256f99039fd50378400c903", "filename": "gcc/testsuite/gcc.dg/lineno-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Ftestsuite%2Fgcc.dg%2Flineno-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Ftestsuite%2Fgcc.dg%2Flineno-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flineno-2.c?ref=eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+\n+/* Test #line with and without macros for the line number.  */\n+\n+#define L 90\n+\n+#line 44\n+int i = __LINE__;\n+\n+#line L\n+int j = __LINE__;\n+\n+#line 14  /* N.B. the _next_ line is line 14.  */\n+\n+int main(void)\n+{\n+  if (i != 44)\n+    abort ();\n+  if (j != 90)\n+    abort ();\n+  if (__LINE__ != 21)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "56e148489bc707594ffe664242f1522371dfd2cd", "filename": "gcc/testsuite/gcc.dg/strpaste.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrpaste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrpaste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrpaste.c?ref=eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+\n+/* Regression test for stringizing and token pasting.\n+   We got internal escape markers in the strings.  */\n+\n+#include <string.h>\n+\n+#define S(x) _S(x)\n+#define _S(x) #x\n+\n+#define I 1\n+static const char s1[] = S(I.1);\n+static const char t1[] = \"1.1\";\n+\n+#define f h\n+#define h(a) a+f\n+static const char s2[] = S( f(1)(2) );\n+static const char t2[] = \"1+h(2)\";\n+\n+#undef I\n+#undef f\n+#undef h\n+\n+int\n+main(void)\n+{\n+  if (strcmp (s1, t1))\n+    abort ();\n+\n+  if (strcmp (s2, t2))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "62ac10339afaf5035356e6283f53b28c4d5028df", "filename": "gcc/testsuite/gcc.dg/trigraphs.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Ftestsuite%2Fgcc.dg%2Ftrigraphs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaefae0ec35904e854d4f8a097fdb3e7c678aff8/gcc%2Ftestsuite%2Fgcc.dg%2Ftrigraphs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftrigraphs.c?ref=eaefae0ec35904e854d4f8a097fdb3e7c678aff8", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-ansi\" } */\n+\n+/* Basic tests for trigraph conversion.\n+   All of them are here, but not in all possible contexts.  *??/\n+/\n+\n+??=include <stdio.h>\n+\n+??=define TWELVE 1??/\n+2\n+\n+static const char str??(??) = \"0123456789??/n\";\n+\n+int\n+main(void)\n+??<\n+  if (sizeof str != TWELVE)\n+    abort ();\n+\n+  if ((5 ??' 3) != 6)\n+    abort ();\n+\n+  if ((5 ??! 3) != 7)\n+    abort ();\n+\n+  return 0;\n+??>"}]}