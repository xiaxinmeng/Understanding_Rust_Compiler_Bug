{"sha": "ef2925370ee74f7b0d0845affc35b0030848b5ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYyOTI1MzcwZWU3NGY3YjBkMDg0NWFmZmMzNWIwMDMwODQ4YjVhZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-06-04T10:20:32Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-06-04T10:20:32Z"}, "message": "re PR fortran/37336 ([F03] Finish derived-type finalization)\n\n2013-06-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/37336\n        * trans.h (gfc_build_final_call): Remove prototype.\n        (gfc_add_finalizer_call): Add prototype.\n        * trans-array.c (gfc_trans_dealloc_allocated): Support\n        * finalization.\n        (structure_alloc_comps): Update caller.\n        (gfc_trans_deferred_array): Call finalizer.\n        * trans-array.h (gfc_trans_dealloc_allocated): Update prototype.\n        * trans-decl.c (gfc_trans_deferred_vars): Don't\n        * deallocate/finalize\n        variables of the main program.\n        * trans-expr.c (gfc_conv_procedure_call): Support finalization.\n        * trans-openmp.c (gfc_omp_clause_dtor,\n        gfc_trans_omp_array_reduction): Update calls.\n        * trans-stmt.c (gfc_trans_deallocate): Avoid double deallocation\n        of alloc components.\n        * trans.c (gfc_add_finalizer_call): New function.\n        (gfc_deallocate_with_status,\n        gfc_deallocate_scalar_with_status): Call it\n        (gfc_build_final_call): Fix handling of scalar coarrays,\n        move up in the file and make static.\n\n2013-06-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/37336\n        * gfortran.dg/finalize_12.f90: New.\n        * gfortran.dg/alloc_comp_basics_1.f90: Add BLOCK for\n        end of scope finalization.\n        * gfortran.dg/alloc_comp_constructor_1.f90: Ditto.\n        * gfortran.dg/allocatable_scalar_9.f90: Ditto.\n        * gfortran.dg/auto_dealloc_2.f90: Ditto.\n        * gfortran.dg/class_19.f03: Ditto.\n        * gfortran.dg/coarray_lib_alloc_1.f90: Ditto.\n        * gfortran.dg/coarray_lib_alloc_2.f90: Ditto.\n        * gfortran.dg/extends_14.f03: Ditto.\n        * gfortran.dg/move_alloc_4.f90: Ditto.\n        * gfortran.dg/typebound_proc_27.f03: Ditto.\n\nFrom-SVN: r199643", "tree": {"sha": "bc5eafdea238518ce5c6c9b8cd674dc39145b8b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc5eafdea238518ce5c6c9b8cd674dc39145b8b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef2925370ee74f7b0d0845affc35b0030848b5ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef2925370ee74f7b0d0845affc35b0030848b5ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef2925370ee74f7b0d0845affc35b0030848b5ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef2925370ee74f7b0d0845affc35b0030848b5ae/comments", "author": null, "committer": null, "parents": [{"sha": "aadaf24ef0336560cb808406da288878a6120ca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aadaf24ef0336560cb808406da288878a6120ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aadaf24ef0336560cb808406da288878a6120ca2"}], "stats": {"total": 1029, "additions": 869, "deletions": 160}, "files": [{"sha": "d8ff752e588389a4a4ba2f1fc315be1e3adc9b83", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -1,3 +1,25 @@\n+2013-06-04  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/37336\n+\t* trans.h (gfc_build_final_call): Remove prototype.\n+\t(gfc_add_finalizer_call): Add prototype.\n+\t* trans-array.c (gfc_trans_dealloc_allocated): Support finalization.\n+\t(structure_alloc_comps): Update caller.\n+\t(gfc_trans_deferred_array): Call finalizer.\n+\t* trans-array.h (gfc_trans_dealloc_allocated): Update prototype.\n+\t* trans-decl.c (gfc_trans_deferred_vars): Don't deallocate/finalize\n+\tvariables of the main program.\n+\t* trans-expr.c (gfc_conv_procedure_call): Support finalization.\n+\t* trans-openmp.c (gfc_omp_clause_dtor,\n+\tgfc_trans_omp_array_reduction): Update calls.\n+\t* trans-stmt.c (gfc_trans_deallocate): Avoid double deallocation\n+\tof alloc components.\n+\t* trans.c (gfc_add_finalizer_call): New function.\n+\t(gfc_deallocate_with_status,\n+\tgfc_deallocate_scalar_with_status): Call it\n+\t(gfc_build_final_call): Fix handling of scalar coarrays,\n+\tmove up in the file and make static.\n+\n 2013-06-01  Janus Weil  <janus@gcc.gnu.org>\n \t    Mikael Morin  <mikael@gcc.gnu.org>\n "}, {"sha": "89f26d7d976604a074df3e2e5dd6e475d2bd1cd3", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -7247,7 +7247,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n /* Generate code to deallocate an array, if it is allocated.  */\n \n tree\n-gfc_trans_dealloc_allocated (tree descriptor, bool coarray)\n+gfc_trans_dealloc_allocated (tree descriptor, bool coarray, gfc_expr *expr)\n {\n   tree tmp;\n   tree var;\n@@ -7263,7 +7263,7 @@ gfc_trans_dealloc_allocated (tree descriptor, bool coarray)\n      are already deallocated are ignored.  */\n   tmp = gfc_deallocate_with_status (coarray ? descriptor : var, NULL_TREE,\n \t\t\t\t    NULL_TREE, NULL_TREE, NULL_TREE, true,\n-\t\t\t\t    NULL, coarray);\n+\t\t\t\t    expr, coarray);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n@@ -7552,7 +7552,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    {\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n-\t      tmp = gfc_trans_dealloc_allocated (comp, c->attr.codimension);\n+\t      tmp = gfc_trans_dealloc_allocated (comp, c->attr.codimension, NULL);\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n \t  else if (c->attr.allocatable)\n@@ -7584,7 +7584,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n \t        tmp = gfc_trans_dealloc_allocated (comp,\n-\t\t\t\t\tCLASS_DATA (c)->attr.codimension);\n+\t\t\t\t\tCLASS_DATA (c)->attr.codimension, NULL);\n \t      else\n \t\t{\n \t\t  tmp = gfc_deallocate_scalar_with_status (comp, NULL_TREE, true, NULL,\n@@ -8296,7 +8296,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n   stmtblock_t cleanup;\n   locus loc;\n   int rank;\n-  bool sym_has_alloc_comp;\n+  bool sym_has_alloc_comp, has_finalizer;\n \n   sym_has_alloc_comp = (sym->ts.type == BT_DERIVED\n \t\t\t|| sym->ts.type == BT_CLASS)\n@@ -8383,8 +8383,12 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n \n   /* Allocatable arrays need to be freed when they go out of scope.\n      The allocatable components of pointers must not be touched.  */\n-  if (sym_has_alloc_comp && !(sym->attr.function || sym->attr.result)\n-      && !sym->attr.pointer && !sym->attr.save)\n+  has_finalizer = sym->ts.type == BT_CLASS || sym->ts.type == BT_DERIVED\n+\t\t   ? gfc_is_finalizable (sym->ts.u.derived, NULL) : false;\n+  if ((!sym->attr.allocatable || !has_finalizer)\n+      && sym_has_alloc_comp && !(sym->attr.function || sym->attr.result)\n+      && !sym->attr.pointer && !sym->attr.save\n+      && !sym->ns->proc_name->attr.is_main_program)\n     {\n       int rank;\n       rank = sym->as ? sym->as->rank : 0;\n@@ -8393,10 +8397,13 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n     }\n \n   if (sym->attr.allocatable && (sym->attr.dimension || sym->attr.codimension)\n-      && !sym->attr.save && !sym->attr.result)\n+      && !sym->attr.save && !sym->attr.result\n+      && !sym->ns->proc_name->attr.is_main_program)\n     {\n       tmp = gfc_trans_dealloc_allocated (sym->backend_decl,\n-\t\t\t\t\t sym->attr.codimension);\n+\t\t\t\t\t sym->attr.codimension,\n+\t\t\t\t\t has_finalizer\n+\t\t\t\t\t ? gfc_lval_expr_from_sym (sym) : NULL);\n       gfc_add_expr_to_block (&cleanup, tmp);\n     }\n "}, {"sha": "8d9e46187c569d4632f01ff397dd7bc89ccd7fd1", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -42,7 +42,7 @@ void gfc_trans_dummy_array_bias (gfc_symbol *, tree, gfc_wrapped_block *);\n /* Generate entry and exit code for g77 calling convention arrays.  */\n void gfc_trans_g77_array (gfc_symbol *, gfc_wrapped_block *);\n /* Generate code to deallocate an array, if it is allocated.  */\n-tree gfc_trans_dealloc_allocated (tree, bool);\n+tree gfc_trans_dealloc_allocated (tree, bool, gfc_expr *);\n \n tree gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank);\n "}, {"sha": "b0e3ffc21bdc5377353a0d9cfcd5945b8b4f33a7", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -3872,7 +3872,8 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \n \t      /* Deallocate when leaving the scope. Nullifying is not\n \t\t needed.  */\n-\t      if (!sym->attr.result && !sym->attr.dummy)\n+\t      if (!sym->attr.result && !sym->attr.dummy\n+\t\t  && !sym->ns->proc_name->attr.is_main_program)\n \t\t{\n \t\t  if (sym->ts.type == BT_CLASS\n \t\t      && CLASS_DATA (sym)->attr.codimension)"}, {"sha": "9d073457db14150ea24c724597cc891b083a46bb", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -4274,10 +4274,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      if (e->ts.type == BT_CLASS)\n \t\t\tptr = gfc_class_data_get (ptr);\n \n-\t\t      tmp = gfc_deallocate_with_status (ptr, NULL_TREE,\n-\t\t\t\t\t\t\tNULL_TREE, NULL_TREE,\n-\t\t\t\t\t\t\tNULL_TREE, true, NULL,\n-\t\t\t\t\t\t\tfalse);\n+\t\t      tmp = gfc_deallocate_scalar_with_status (ptr, NULL_TREE,\n+\t\t\t\t\t\t\t       true, e, e->ts);\n \t\t      gfc_add_expr_to_block (&block, tmp);\n \t\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t\t\t     void_type_node, ptr,\n@@ -4409,8 +4407,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t  else\n \t\t    tmp = gfc_finish_block (&block);\n \n-\t\t      gfc_add_expr_to_block (&se->pre, tmp);\n-}\n+\t\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\t\t}\n \n \t      /* The conversion does not repackage the reference to a class\n \t         array - _data descriptor.  */\n@@ -4511,7 +4509,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t{\n \t\t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t     parmse.expr);\n-\t\t  tmp = gfc_trans_dealloc_allocated (tmp, false);\n+\t\t  tmp = gfc_trans_dealloc_allocated (tmp, false, e);\n \t\t  if (fsym->attr.optional\n \t\t      && e->expr_type == EXPR_VARIABLE\n \t\t      && e->symtree->n.sym->attr.optional)"}, {"sha": "2765561e889ebafbf430f475941eb8f3e244805c", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -325,7 +325,7 @@ gfc_omp_clause_dtor (tree clause ATTRIBUTE_UNUSED, tree decl)\n \n   /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n      to be deallocated if they were allocated.  */\n-  return gfc_trans_dealloc_allocated (decl, false);\n+  return gfc_trans_dealloc_allocated (decl, false, NULL);\n }\n \n \n@@ -707,7 +707,8 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       gfc_start_block (&block);\n       gfc_add_expr_to_block (&block, gfc_trans_assignment (e3, e4, false,\n \t\t\t     true));\n-      gfc_add_expr_to_block (&block, gfc_trans_dealloc_allocated (decl, false));\n+      gfc_add_expr_to_block (&block, gfc_trans_dealloc_allocated (decl, false,\n+\t\t\t\t\t\t\t\t  NULL));\n       stmt = gfc_finish_block (&block);\n     }\n   else"}, {"sha": "e2d0110ba96ed398cfa8ba1b2246f947baae5e65", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -5398,7 +5398,8 @@ gfc_trans_deallocate (gfc_code *code)\n \n       if (expr->rank || gfc_is_coarray (expr))\n \t{\n-\t  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)\n+\t  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp\n+\t      && !gfc_is_finalizable (expr->ts.u.derived, NULL))\n \t    {\n \t      gfc_ref *ref;\n \t      gfc_ref *last = NULL;"}, {"sha": "a1ea3008ff7390a03eca93af97761a1549c14300", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 221, "deletions": 128, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -838,6 +838,223 @@ gfc_call_free (tree var)\n }\n \n \n+/* Build a call to a FINAL procedure, which finalizes \"var\".  */\n+\n+static tree\n+gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,\n+\t\t      bool fini_coarray, gfc_expr *class_size)\n+{\n+  stmtblock_t block;\n+  gfc_se se;\n+  tree final_fndecl, array, size, tmp;\n+  symbol_attribute attr;\n+\n+  gcc_assert (final_wrapper->expr_type == EXPR_VARIABLE);\n+  gcc_assert (var);\n+\n+  gfc_init_se (&se, NULL);\n+  gfc_conv_expr (&se, final_wrapper);\n+  final_fndecl = se.expr;\n+  if (POINTER_TYPE_P (TREE_TYPE (final_fndecl)))\n+    final_fndecl = build_fold_indirect_ref_loc (input_location, final_fndecl);\n+\n+  if (ts.type == BT_DERIVED)\n+    {\n+      tree elem_size;\n+\n+      gcc_assert (!class_size);\n+      elem_size = gfc_typenode_for_spec (&ts);\n+      elem_size = TYPE_SIZE_UNIT (elem_size);\n+      size = fold_convert (gfc_array_index_type, elem_size);\n+\n+      gfc_init_se (&se, NULL);\n+      se.want_pointer = 1;\n+      if (var->rank)\n+\t{\n+\t  se.descriptor_only = 1;\n+\t  gfc_conv_expr_descriptor (&se, var);\n+\t  array = se.expr;\n+\t}\n+      else\n+\t{\n+\t  gfc_conv_expr (&se, var);\n+\t  gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n+\t  array = se.expr;\n+\n+\t  /* No copy back needed, hence set attr's allocatable/pointer\n+\t     to zero.  */\n+\t  gfc_clear_attr (&attr);\n+\t  gfc_init_se (&se, NULL);\n+\t  array = gfc_conv_scalar_to_descriptor (&se, array, attr);\n+\t  gcc_assert (se.post.head == NULL_TREE);\n+\t}\n+    }\n+  else\n+    {\n+      gfc_expr *array_expr;\n+      gcc_assert (class_size);\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, class_size);\n+      gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n+      size = se.expr;\n+\n+      array_expr = gfc_copy_expr (var);\n+      gfc_init_se (&se, NULL);\n+      se.want_pointer = 1;\n+      if (array_expr->rank)\n+\t{\n+\t  gfc_add_class_array_ref (array_expr);\n+\t  se.descriptor_only = 1;\n+\t  gfc_conv_expr_descriptor (&se, array_expr);\n+\t  array = se.expr;\n+\t}\n+      else\n+\t{\n+\t  gfc_add_data_component (array_expr);\n+\t  gfc_conv_expr (&se, array_expr);\n+\t  gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n+\t  array = se.expr;\n+\t  if (TREE_CODE (array) == ADDR_EXPR\n+\t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (array, 0))))\n+\t    tmp = TREE_OPERAND (array, 0);\n+\n+\t  if (!gfc_is_coarray (array_expr))\n+\t    {\n+\t      /* No copy back needed, hence set attr's allocatable/pointer\n+\t\t to zero.  */\n+\t      gfc_clear_attr (&attr);\n+\t      gfc_init_se (&se, NULL);\n+\t      array = gfc_conv_scalar_to_descriptor (&se, array, attr);\n+\t    }\n+\t  gcc_assert (se.post.head == NULL_TREE);\n+\t}\n+      gfc_free_expr (array_expr);\n+    }\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (array)))\n+    array = gfc_build_addr_expr (NULL, array);\n+\n+  gfc_start_block (&block);\n+  gfc_add_block_to_block (&block, &se.pre);\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t     final_fndecl, 3, array,\n+\t\t\t     size, fini_coarray ? boolean_true_node\n+\t\t\t\t\t\t: boolean_false_node);\n+  gfc_add_block_to_block (&block, &se.post);\n+  gfc_add_expr_to_block (&block, tmp);\n+  return gfc_finish_block (&block);\n+}\n+\n+\n+/* Add a call to the finalizer, using the passed *expr. Returns\n+   true when a finalizer call has been inserted.  */\n+\n+bool\n+gfc_add_finalizer_call (stmtblock_t *block, gfc_expr *expr2)\n+{\n+  tree tmp;\n+  gfc_ref *ref;\n+  gfc_expr *expr;\n+  gfc_expr *final_expr = NULL;\n+  gfc_expr *elem_size = NULL;\n+  bool has_finalizer = false;\n+\n+  if (!expr2 || (expr2->ts.type != BT_DERIVED && expr2->ts.type != BT_CLASS))\n+    return false;\n+\n+  if (expr2->ts.type == BT_DERIVED)\n+    {\n+      gfc_is_finalizable (expr2->ts.u.derived, &final_expr);\n+      if (!final_expr)\n+        return false;\n+    }\n+\n+  /* If we have a class array, we need go back to the class\n+     container. */\n+  expr = gfc_copy_expr (expr2);\n+\n+  if (expr->ref && expr->ref->next && !expr->ref->next->next\n+      && expr->ref->next->type == REF_ARRAY\n+      && expr->ref->type == REF_COMPONENT\n+      && strcmp (expr->ref->u.c.component->name, \"_data\") == 0)\n+    {\n+      gfc_free_ref_list (expr->ref);\n+      expr->ref = NULL;\n+    }\n+  else\n+    for (ref = expr->ref; ref; ref = ref->next)\n+      if (ref->next && ref->next->next && !ref->next->next->next\n+         && ref->next->next->type == REF_ARRAY\n+         && ref->next->type == REF_COMPONENT\n+         && strcmp (ref->next->u.c.component->name, \"_data\") == 0)\n+       {\n+         gfc_free_ref_list (ref->next);\n+         ref->next = NULL;\n+       }\n+\n+  if (expr->ts.type == BT_CLASS)\n+    {\n+      has_finalizer = gfc_is_finalizable (expr->ts.u.derived, NULL);\n+\n+      if (!expr2->rank && !expr2->ref && CLASS_DATA (expr2->symtree->n.sym)->as)\n+\texpr->rank = CLASS_DATA (expr2->symtree->n.sym)->as->rank;\n+\n+      final_expr = gfc_copy_expr (expr);\n+      gfc_add_vptr_component (final_expr);\n+      gfc_add_component_ref (final_expr, \"_final\");\n+\n+      elem_size = gfc_copy_expr (expr);\n+      gfc_add_vptr_component (elem_size);\n+      gfc_add_component_ref (elem_size, \"_size\");\n+    }\n+\n+  gcc_assert (final_expr->expr_type == EXPR_VARIABLE);\n+\n+  tmp = gfc_build_final_call (expr->ts, final_expr, expr,\n+\t\t\t      false, elem_size);\n+\n+  if (expr->ts.type == BT_CLASS && !has_finalizer)\n+    {\n+      tree cond;\n+      gfc_se se;\n+\n+      gfc_init_se (&se, NULL);\n+      se.want_pointer = 1;\n+      gfc_conv_expr (&se, final_expr);\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      se.expr, build_int_cst (TREE_TYPE (se.expr), 0));\n+\n+      /* For CLASS(*) not only sym->_vtab->_final can be NULL\n+\t but already sym->_vtab itself.  */\n+      if (UNLIMITED_POLY (expr))\n+\t{\n+\t  tree cond2;\n+\t  gfc_expr *vptr_expr;\n+\n+\t  vptr_expr = gfc_copy_expr (expr);\n+\t  gfc_add_vptr_component (vptr_expr);\n+\n+\t  gfc_init_se (&se, NULL);\n+\t  se.want_pointer = 1;\n+\t  gfc_conv_expr (&se, vptr_expr);\n+\t  gfc_free_expr (vptr_expr);\n+\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   se.expr,\n+\t\t\t\t   build_int_cst (TREE_TYPE (se.expr), 0));\n+\t  cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t\t  boolean_type_node, cond2, cond);\n+\t}\n+\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     cond, tmp, build_empty_stmt (input_location));\n+    }\n+\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  return true;\n+}\n+\n \n /* User-deallocate; we emit the code directly from the front-end, and the\n    logic is the same as the previous library function:\n@@ -930,6 +1147,7 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \n   /* When POINTER is not NULL, we free it.  */\n   gfc_start_block (&non_null);\n+  gfc_add_finalizer_call (&non_null, expr);\n   if (!coarray || gfc_option.coarray != GFC_FCOARRAY_LIB)\n     {\n       tmp = build_call_expr_loc (input_location,\n@@ -1022,125 +1240,6 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n }\n \n \n-/* Build a call to a FINAL procedure, which finalizes \"var\".  */\n-\n-tree\n-gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,\n-\t\t      bool fini_coarray, gfc_expr *class_size)\n-{\n-  stmtblock_t block;\n-  gfc_se se;\n-  tree final_fndecl, array, size, tmp;\n-  symbol_attribute attr;\n-\n-  gcc_assert (final_wrapper->expr_type == EXPR_VARIABLE);\n-  gcc_assert (var);\n-\n-  gfc_init_se (&se, NULL);\n-  gfc_conv_expr (&se, final_wrapper);\n-  final_fndecl = se.expr;\n-  if (POINTER_TYPE_P (TREE_TYPE (final_fndecl)))\n-    final_fndecl = build_fold_indirect_ref_loc (input_location, final_fndecl);\n-\n-  attr = gfc_expr_attr (var);\n-\n-  if (ts.type == BT_DERIVED)\n-    {\n-      tree elem_size;\n-\n-      gcc_assert (!class_size);\n-      elem_size = gfc_typenode_for_spec (&ts);\n-      elem_size = TYPE_SIZE_UNIT (elem_size);\n-      size = fold_convert (gfc_array_index_type, elem_size);\n-\n-      gfc_init_se (&se, NULL);\n-      se.want_pointer = 1;\n-      if (var->rank || attr.dimension\n-\t  || (attr.codimension && attr.allocatable\n-\t      && gfc_option.coarray == GFC_FCOARRAY_LIB))\n-\t{\n-\t  if (var->rank == 0)\n-\t    se.want_coarray = 1;\n-\t  se.descriptor_only = 1;\n-\t  gfc_conv_expr_descriptor (&se, var);\n-\t  array = se.expr;\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (array)))\n-\t    array = gfc_build_addr_expr (NULL, array);\n-\t}\n-      else\n-\t{\n-\t  gfc_clear_attr (&attr);\n-\t  gfc_conv_expr (&se, var);\n-\t  gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n-\t  array = se.expr;\n-\t  if (TREE_CODE (array) == ADDR_EXPR\n-\t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (array, 0))))\n-\t    tmp = TREE_OPERAND (array, 0);\n-\n-\t  gfc_init_se (&se, NULL);\n-\t  array = gfc_conv_scalar_to_descriptor (&se, array, attr);\n-\t  array = gfc_build_addr_expr (NULL, array);\n-\t  gcc_assert (se.post.head == NULL_TREE);\n-\t}\n-    }\n-  else\n-    {\n-      gfc_expr *array_expr;\n-      gcc_assert (class_size);\n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr (&se, class_size);\n-      gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n-      size = se.expr;\n-\n-      array_expr = gfc_copy_expr (var);\n-      gfc_init_se (&se, NULL);\n-      se.want_pointer = 1;\n-      if (array_expr->rank || attr.dimension\n-\t  || (attr.codimension && attr.allocatable\n-\t      && gfc_option.coarray == GFC_FCOARRAY_LIB))\n-\t{\n-\t  gfc_add_class_array_ref (array_expr);\n-\t  if (array_expr->rank == 0)\n-\t    se.want_coarray = 1;\n-\t  se.descriptor_only = 1;\n-\t  gfc_conv_expr_descriptor (&se, array_expr);\n-\t  array = se.expr;\n-\t  if (! POINTER_TYPE_P (TREE_TYPE (array)))\n-\t    array = gfc_build_addr_expr (NULL, array);\n-\t}\n-      else\n-\t{\n-\t  gfc_clear_attr (&attr);\n-\t  gfc_add_data_component (array_expr);\n-\t  gfc_conv_expr (&se, array_expr);\n-\t  gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n-\t  array = se.expr;\n-\t  if (TREE_CODE (array) == ADDR_EXPR\n-\t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (array, 0))))\n-\t    tmp = TREE_OPERAND (array, 0);\n-\n-\t  /* attr: Argument is neither a pointer/allocatable,\n-\t     i.e. no copy back needed */\n-\t  gfc_init_se (&se, NULL);\n-\t  array = gfc_conv_scalar_to_descriptor (&se, array, attr);\n-\t  array = gfc_build_addr_expr (NULL, array);\n-\t  gcc_assert (se.post.head == NULL_TREE);\n-\t}\n-      gfc_free_expr (array_expr);\n-    }\n-\n-  gfc_start_block (&block);\n-  gfc_add_block_to_block (&block, &se.pre);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t     final_fndecl, 3, array,\n-\t\t\t     size, fini_coarray ? boolean_true_node\n-\t\t\t\t\t\t: boolean_false_node);\n-  gfc_add_block_to_block (&block, &se.post);\n-  gfc_add_expr_to_block (&block, tmp);\n-  return gfc_finish_block (&block);\n-}\n-\n-\n /* Generate code for deallocation of allocatable scalars (variables or\n    components). Before the object itself is freed, any allocatable\n    subcomponents are being deallocated.  */\n@@ -1151,6 +1250,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n {\n   stmtblock_t null, non_null;\n   tree cond, tmp, error;\n+  bool finalizable;\n \n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n \t\t\t  build_int_cst (TREE_TYPE (pointer), 0));\n@@ -1195,20 +1295,13 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n   gfc_start_block (&non_null);\n \n   /* Free allocatable components.  */\n-  if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n+  finalizable = gfc_add_finalizer_call (&non_null, expr);\n+  if (!finalizable && ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n     {\n       tmp = build_fold_indirect_ref_loc (input_location, pointer);\n       tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0);\n       gfc_add_expr_to_block (&non_null, tmp);\n     }\n-  else if (ts.type == BT_CLASS\n-\t   && ts.u.derived->components->ts.u.derived->attr.alloc_comp)\n-    {\n-      tmp = build_fold_indirect_ref_loc (input_location, pointer);\n-      tmp = gfc_deallocate_alloc_comp (ts.u.derived->components->ts.u.derived,\n-\t\t\t\t       tmp, 0);\n-      gfc_add_expr_to_block (&non_null, tmp);\n-    }\n \n   tmp = build_call_expr_loc (input_location,\n \t\t\t     builtin_decl_explicit (BUILT_IN_FREE), 1,"}, {"sha": "06cb63d8132f1d443b199dc53d4d579788de716c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -352,8 +352,7 @@ tree gfc_vtable_final_get (tree);\n tree gfc_get_vptr_from_expr (tree);\n tree gfc_get_class_array_ref (tree, tree);\n tree gfc_copy_class_to_class (tree, tree, tree);\n-tree gfc_build_final_call (gfc_typespec, gfc_expr *, gfc_expr *, bool,\n-\t\t\t   gfc_expr *);\n+bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);\n void gfc_conv_derived_to_class (gfc_se *, gfc_expr *, gfc_typespec, tree, bool,\n \t\t\t\tbool);\n void gfc_conv_class_to_class (gfc_se *, gfc_expr *, gfc_typespec, bool, bool,"}, {"sha": "9197b57b290b5a9fed589eecc094e10bb2898e71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -1,4 +1,20 @@\n-2013-06-03  Manfred Schwarb  <manfred99@gmx.ch>\n+2013-06-04  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/37336\n+\t* gfortran.dg/finalize_12.f90: New.\n+\t* gfortran.dg/alloc_comp_basics_1.f90: Add BLOCK for\n+\tend of scope finalization.\n+\t* gfortran.dg/alloc_comp_constructor_1.f90: Ditto.\n+\t* gfortran.dg/allocatable_scalar_9.f90: Ditto.\n+\t* gfortran.dg/auto_dealloc_2.f90: Ditto.\n+\t* gfortran.dg/class_19.f03: Ditto.\n+\t* gfortran.dg/coarray_lib_alloc_1.f90: Ditto.\n+\t* gfortran.dg/coarray_lib_alloc_2.f90: Ditto.\n+\t* gfortran.dg/extends_14.f03: Ditto.\n+\t* gfortran.dg/move_alloc_4.f90: Ditto.\n+\t* gfortran.dg/typebound_proc_27.f03: Ditto.\n+\n+2013-06-04  Manfred Schwarb  <manfred99@gmx.ch>\n \n \t* gfortran.dg/bounds_check_7.f90: Remove \"! {\".\n \t* gfortran.dg/coarray_poly_3.f90: Remove inactive, broken dg-*."}, {"sha": "65724fe4b7227afb29c54620d5ca887915b69b03", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_1.f90", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_1.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -33,8 +33,10 @@ program alloc\n         integer, allocatable :: a2(:)\n     end type alloc2\n \n-    type(alloc2) :: b\n     integer :: i\n+\n+  BLOCK  ! To ensure that the allocatables are freed at the end of the scope\n+    type(alloc2) :: b\n     type(alloc2), allocatable :: c(:)\n \n     if (allocated(b%a2) .OR. allocated(b%a1)) then\n@@ -64,7 +66,7 @@ program alloc\n     deallocate(c)\n \n     ! 7 calls to _gfortran_deallocate (b (3) and c(4) goes aout of scope)\n-\n+  END BLOCK\n contains\n \n     subroutine allocate_alloc2(b)"}, {"sha": "8003c0514779b78bd73caf4f7eb2228b36516754", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_1.f90", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_1.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -19,9 +19,12 @@ Program test_constructor\n         type(thytype), allocatable :: q(:)\r\n     end type mytype\r\n \r\n-    type (mytype) :: x\r\n     type (thytype) :: foo = thytype(reshape ([43, 100, 54, 76], [2,2]))\r\n     integer :: y(0:1, -1:0) = reshape ([42, 99, 55, 77], [2,2])\r\n+\r\n+  BLOCK ! Add scoping unit as the vars are otherwise implicitly SAVEd\r\n+\r\n+    type (mytype) :: x\r\n     integer, allocatable :: yy(:,:)\r\n     type (thytype), allocatable :: bar(:)\r\n     integer :: i\r\n@@ -70,7 +73,7 @@ Program test_constructor\n \r\n     ! Check that passing the constructor to a procedure works\r\n     call check_mytype (mytype(y, [foo, foo]))\r\n-\r\n+  END BLOCK\r\n contains\r\n \r\n     subroutine check_mytype(x)\r"}, {"sha": "fd0b4dbf216926eae6b2b84a834d94f54ff5a7f8", "filename": "gcc/testsuite/gfortran.dg/allocatable_scalar_9.f90", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_scalar_9.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -28,10 +28,12 @@ module m\n end module m\n \n use m\n+block ! Start new scoping unit as otherwise the vars are implicitly SAVEd\n type(t1) :: na1, a1, aa1(:)\n type(t2) :: na2, a2, aa2(:)\n type(t3) :: na3, a3, aa3(:)\n type(t4) :: na4, a4, aa4(:)\n+\n allocatable :: a1, a2, a3, a4, aa1, aa2, aa3,aa4\n \n if(allocated(a1)) call abort()\n@@ -47,6 +49,7 @@ end module m\n if(allocated(na2%b2)) call abort()\n if(allocated(na3%b3)) call abort()\n if(allocated(na4%b4)) call abort()\n+end block\n end\n \n ! { dg-final { scan-tree-dump-times \"__builtin_free\" 32 \"original\" } }"}, {"sha": "f47ec87c46fbeda201edc66f722546ef2d13eff2", "filename": "gcc/testsuite/gfortran.dg/auto_dealloc_2.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_dealloc_2.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -11,11 +11,12 @@ program test\n   integer, allocatable :: i(:)\n end type\n \n+block ! New block as the main program implies SAVE\n type(t) :: a\n \n call init(a)\n call init(a)\n-\n+end block\n contains\n \n   subroutine init(x)"}, {"sha": "428015c99ecab1bb269b5994fff5eff7039a811b", "filename": "gcc/testsuite/gfortran.dg/class_19.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -39,5 +39,5 @@ program main\n \n end program main\n \n-! { dg-final { scan-tree-dump-times \"__builtin_free\" 15 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 12 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "926d531ef7d84209a624ff7ca09540d2b1f7e154", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_1.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -4,6 +4,7 @@\n ! Allocate/deallocate with libcaf.\n !\n \n+ subroutine test()\n  integer(4), allocatable :: xx[:], yy(:)[:]\n  integer :: stat\n  character(len=200) :: errmsg"}, {"sha": "472e0beb71982579351d10ab84a9e15ec862f31c", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_2.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -4,6 +4,7 @@\n ! Allocate/deallocate with libcaf.\n !\n \n+ subroutine test()\n  type t\n  end type t\n  class(t), allocatable :: xx[:], yy(:)[:]"}, {"sha": "15e38ff90811a324faf8ac1c2fb6932f02a2f02c", "filename": "gcc/testsuite/gfortran.dg/extends_14.f03", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_14.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_14.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_14.f03?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -16,12 +16,13 @@ program evolve_aflow\n   type, extends(state_t) :: astate_t\n   end type\n \n+ block ! New scoping unit as \"a\"/\"b\" are otherwise implicitly SAVEd\n   type(astate_t) :: a,b\n \n   allocate(a%U(1000))\n \n   a = b\n-\n+ end block\n end program \n \n ! { dg-final { scan-tree-dump-times \"__builtin_free\" 3 \"original\" } }"}, {"sha": "f1508ec8135975c2ed2b337b8f45c68de3bb31b3", "filename": "gcc/testsuite/gfortran.dg/finalize_12.f90", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_12.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -0,0 +1,175 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/37336\n+!\n+module m\n+  implicit none\n+  type t\n+    integer :: i\n+  contains\n+    final :: fini, fini2\n+  end type t\n+  integer :: global_count1, global_count2\n+contains\n+  subroutine fini(x)\n+    type(t) :: x\n+    !print *, 'fini:',x%i\n+    if (global_count1 == -1) call abort ()\n+    if (x%i /= 42) call abort() \n+    x%i = 33\n+    global_count1 = global_count1 + 1\n+  end subroutine fini\n+  subroutine fini2(x)\n+    type(t) :: x(:)\n+    !print *, 'fini2', x%i\n+    if (global_count2 == -1) call abort ()\n+    if (size(x) /= 5) call abort()\n+    if (any (x%i /= [1,2,3,4,5]) .and. any (x%i /= [6,7,8,9,10])) call abort() \n+    x%i = 33\n+    global_count2 = global_count2 + 10\n+  end subroutine fini2\n+end module m\n+\n+program pp\n+  use m\n+  implicit none\n+  type(t), allocatable :: ya\n+  class(t), allocatable :: yc\n+  type(t), allocatable :: yaa(:)\n+  class(t), allocatable :: yca(:)\n+\n+  type(t), allocatable :: ca[:]\n+  class(t), allocatable :: cc[:]\n+  type(t), allocatable :: caa(:)[:]\n+  class(t), allocatable :: cca(:)[:]\n+\n+  global_count1 = -1\n+  global_count2 = -1\n+  allocate (ya, yc, yaa(5), yca(5))\n+  global_count1 = 0\n+  global_count2 = 0\n+  ya%i = 42\n+  yc%i = 42\n+  yaa%i = [1,2,3,4,5]\n+  yca%i = [1,2,3,4,5]\n+\n+  call foo(ya, yc, yaa, yca)\n+  if (global_count1 /= 2) call abort ()\n+  if (global_count2 /= 20) call abort ()\n+\n+  ! Coarray finalization\n+  allocate (ca[*], cc[*], caa(5)[*], cca(5)[*])\n+  global_count1 = 0\n+  global_count2 = 0\n+  ca%i = 42\n+  cc%i = 42\n+  caa%i = [1,2,3,4,5]\n+  cca%i = [1,2,3,4,5]\n+  deallocate (ca, cc, caa, cca)\n+  if (global_count1 /= 2) call abort ()\n+  if (global_count2 /= 20) call abort ()\n+  global_count1 = -1\n+  global_count2 = -1\n+\n+  block\n+    type(t), allocatable :: za\n+    class(t), allocatable :: zc\n+    type(t), allocatable :: zaa(:)\n+    class(t), allocatable :: zca(:)\n+\n+    ! Test intent(out) finalization\n+    allocate (za, zc, zaa(5), zca(5))\n+    global_count1 = 0\n+    global_count2 = 0\n+    za%i = 42\n+    zc%i = 42\n+    zaa%i = [1,2,3,4,5]\n+    zca%i = [1,2,3,4,5]\n+\n+    call foo(za, zc, zaa, zca)\n+    if (global_count1 /= 2) call abort ()\n+    if (global_count2 /= 20) call abort ()\n+\n+    ! Test intent(out) finalization with optional\n+    call foo_opt()\n+    call opt()\n+\n+    ! Test intent(out) finalization with optional\n+    allocate (za, zc, zaa(5), zca(5))\n+    global_count1 = 0\n+    global_count2 = 0\n+    za%i = 42\n+    zc%i = 42\n+    zaa%i = [1,2,3,4,5]\n+    zca%i = [1,2,3,4,5]\n+\n+    call foo_opt(za, zc, zaa, zca)\n+    if (global_count1 /= 2) call abort ()\n+    if (global_count2 /= 20) call abort ()\n+\n+    ! Test DEALLOCATE finalization\n+    allocate (za, zc, zaa(5), zca(5))\n+    global_count1 = 0\n+    global_count2 = 0\n+    za%i = 42\n+    zc%i = 42\n+    zaa%i = [1,2,3,4,5]\n+    zca%i = [6,7,8,9,10]\n+    deallocate (za, zc, zaa, zca)\n+    if (global_count1 /= 2) call abort ()\n+    if (global_count2 /= 20) call abort ()\n+\n+    ! Test end-of-scope finalization\n+    allocate (za, zc, zaa(5), zca(5))\n+    global_count1 = 0\n+    global_count2 = 0\n+    za%i = 42\n+    zc%i = 42\n+    zaa%i = [1,2,3,4,5]\n+    zca%i = [6,7,8,9,10]\n+  end block\n+\n+  if (global_count1 /= 2) call abort ()\n+  if (global_count2 /= 20) call abort ()\n+\n+  ! Test that no end-of-scope finalization occurs\n+  ! for SAVED variable in main\n+  allocate (ya, yc, yaa(5), yca(5))\n+  global_count1 = -1\n+  global_count2 = -1\n+\n+contains\n+\n+  subroutine opt(xa, xc, xaa, xca)\n+    type(t),  allocatable, optional :: xa\n+    class(t), allocatable, optional :: xc\n+    type(t),  allocatable, optional :: xaa(:)\n+    class(t), allocatable, optional :: xca(:)\n+    call foo_opt(xc, xc, xaa)\n+    !call foo_opt(xa, xc, xaa, xca) ! FIXME: Fails (ICE) due to PR 57445\n+  end subroutine opt\n+  subroutine foo_opt(xa, xc, xaa, xca)\n+    type(t),  allocatable, intent(out), optional :: xa\n+    class(t), allocatable, intent(out), optional :: xc\n+    type(t),  allocatable, intent(out), optional :: xaa(:)\n+    class(t), allocatable, intent(out), optional :: xca(:)\n+\n+    if (.not. present(xa)) &\n+      return\n+    if (allocated (xa)) call abort ()\n+    if (allocated (xc)) call abort ()\n+    if (allocated (xaa)) call abort ()\n+    if (allocated (xca)) call abort ()\n+  end subroutine foo_opt\n+  subroutine foo(xa, xc, xaa, xca)\n+    type(t),  allocatable, intent(out) :: xa\n+    class(t), allocatable, intent(out) :: xc\n+    type(t),  allocatable, intent(out) :: xaa(:)\n+    class(t), allocatable, intent(out) :: xca(:)\n+    if (allocated (xa)) call abort ()\n+    if (allocated (xc)) call abort ()\n+    if (allocated (xaa)) call abort ()\n+    if (allocated (xca)) call abort ()\n+  end subroutine foo\n+end program"}, {"sha": "78b20acd5d7ab76d3948c243fd5b31adac689856", "filename": "gcc/testsuite/gfortran.dg/finalize_13.f90", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_13.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -0,0 +1,161 @@\n+! { dg-do run }\n+!\n+! PR fortran/37336\n+!\n+module m\n+  implicit none\n+  type t\n+    integer :: i\n+  contains\n+    final :: fini3, fini2, fini_elm\n+  end type t\n+\n+  type, extends(t) :: t2\n+    integer :: j\n+  contains\n+    final :: f2ini2, f2ini_elm\n+  end type t2\n+\n+  logical :: elem_call\n+  logical :: rank2_call\n+  logical :: rank3_call\n+  integer :: cnt, cnt2\n+  integer :: fini_call\n+\n+contains\n+  subroutine fini2 (x)\n+    type(t), intent(in), contiguous :: x(:,:)\n+    if (.not. rank2_call) call abort ()\n+    if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n+    !print *, 'fini2:', x%i\n+    if (any (x%i /= reshape([11, 12, 21, 22, 31, 32], [2,3]))) call abort()\n+    fini_call = fini_call + 1\n+  end subroutine\n+\n+  subroutine fini3 (x)\n+    type(t), intent(in) :: x(2,2,*)\n+    integer :: i,j,k\n+    if (.not. elem_call) call abort ()\n+    if (.not. rank3_call) call abort ()\n+    if (cnt2 /= 9) call abort()\n+    if (cnt /= 1) call abort()\n+      do i = 1, 2\n+        do j = 1, 2\n+          do k = 1, 2\n+            !print *, k,j,i,x(k,j,i)%i\n+            if (x(k,j,i)%i /= k+10*j+100*i) call abort()\n+          end do \n+        end do\n+      end do\n+    fini_call = fini_call + 1\n+  end subroutine\n+\n+  impure elemental subroutine fini_elm (x)\n+    type(t), intent(in) :: x\n+    if (.not. elem_call) call abort ()\n+    if (rank3_call) call abort ()\n+    if (cnt2 /= 6) call abort()\n+    if (cnt /= x%i) call abort()\n+    !print *, 'fini_elm:', cnt, x%i\n+    fini_call = fini_call + 1\n+    cnt = cnt + 1\n+  end subroutine\n+\n+  subroutine f2ini2 (x)\n+    type(t2), intent(in), target :: x(:,:)\n+    if (.not. rank2_call) call abort ()\n+    if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n+    !print *, 'f2ini2:', x%i\n+    !print *, 'f2ini2:', x%j\n+    if (any (x%i /= reshape([11, 12, 21, 22, 31, 32], [2,3]))) call abort()\n+    if (any (x%j /= 100*reshape([11, 12, 21, 22, 31, 32], [2,3]))) call abort()\n+    fini_call = fini_call + 1\n+  end subroutine\n+\n+  impure elemental subroutine f2ini_elm (x)\n+    type(t2), intent(in) :: x\n+    integer, parameter :: exprected(*) &\n+            = [111, 112, 121, 122, 211, 212, 221, 222]\n+\n+    if (.not. elem_call) call abort ()\n+    !print *, 'f2ini_elm:', cnt2, x%i, x%j\n+    if (rank3_call) then\n+      if (x%i /= exprected(cnt2)) call abort ()  \n+      if (x%j /= 1000*exprected(cnt2)) call abort ()  \n+    else\n+      if (cnt2 /= x%i .or. cnt2*10 /= x%j) call abort()\n+    end if\n+    cnt2 = cnt2 + 1\n+    fini_call = fini_call + 1\n+  end subroutine\n+end module m\n+\n+\n+program test\n+  use m\n+  implicit none\n+  class(t), save, allocatable :: y(:), z(:,:), zz(:,:,:)\n+  target :: z, zz\n+  integer :: i,j,k\n+\n+  elem_call = .false.\n+  rank2_call = .false.\n+  rank3_call = .false.\n+  allocate (t2 :: y(5))\n+  select type (y)\n+    type is (t2)\n+      do i = 1, 5\n+        y(i)%i = i\n+        y(i)%j = i*10\n+      end do\n+  end select\n+  cnt = 1\n+  cnt2 = 1\n+  fini_call = 0\n+  elem_call = .true.\n+  deallocate (y)\n+  if (fini_call /= 10) call abort ()\n+\n+  elem_call = .false.\n+  rank2_call = .false.\n+  rank3_call = .false.\n+  allocate (t2 :: z(2,3))\n+  select type (z)\n+    type is (t2)\n+      do i = 1, 3\n+        do j = 1, 2\n+          z(j,i)%i = j+10*i\n+          z(j,i)%j = (j+10*i)*100\n+        end do\n+      end do\n+  end select\n+  cnt = 1\n+  cnt2 = 1\n+  fini_call = 0\n+  rank2_call = .true.\n+  deallocate (z)\n+  if (fini_call /= 2) call abort ()\n+\n+  elem_call = .false.\n+  rank2_call = .false.\n+  rank3_call = .false.\n+  allocate (t2 :: zz(2,2,2))\n+  select type (zz)\n+    type is (t2)\n+      do i = 1, 2\n+        do j = 1, 2\n+          do k = 1, 2\n+            zz(k,j,i)%i = k+10*j+100*i\n+            zz(k,j,i)%j = (k+10*j+100*i)*1000\n+          end do \n+        end do\n+      end do\n+  end select\n+  cnt = 1\n+  cnt2 = 1\n+  fini_call = 0\n+  rank3_call = .true.\n+  elem_call = .true.\n+  deallocate (zz)\n+  if (fini_call /= 2*2*2+1) call abort ()\n+end program test"}, {"sha": "edec8841ee627da5844d02a46a8951355766086c", "filename": "gcc/testsuite/gfortran.dg/finalize_14.f90", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_14.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -0,0 +1,220 @@\n+! { dg-do compile }\n+!\n+! PR fortran/37336\n+!\n+! Started to fail when finalization was added.\n+!\n+! Contributed by  Ian Chivers  in PR fortran/44465\n+! \n+module shape_module\n+\n+  type shape_type\n+    integer   :: x_=0\n+    integer   :: y_=0\n+    contains\n+    procedure , pass(this) :: getx\n+    procedure , pass(this) :: gety\n+    procedure , pass(this) :: setx\n+    procedure , pass(this) :: sety\n+    procedure , pass(this) :: moveto\n+    procedure , pass(this) :: draw\n+  end type shape_type\n+\n+interface assignment(=)\n+  module procedure generic_shape_assign\n+end interface\n+\n+contains\n+\n+  integer function getx(this)\n+    implicit none\n+    class (shape_type) , intent(in) :: this\n+    getx=this%x_\n+  end function getx\n+\n+  integer function gety(this)\n+    implicit none\n+    class (shape_type) , intent(in) :: this\n+    gety=this%y_\n+  end function gety\n+\n+  subroutine setx(this,x)\n+    implicit none\n+    class (shape_type), intent(inout) :: this\n+    integer , intent(in) :: x\n+    this%x_=x\n+  end subroutine setx\n+\n+  subroutine sety(this,y)\n+    implicit none\n+    class (shape_type), intent(inout) :: this\n+    integer , intent(in) :: y\n+    this%y_=y\n+  end subroutine sety\n+\n+  subroutine moveto(this,newx,newy)\n+    implicit none\n+    class (shape_type), intent(inout) :: this\n+    integer , intent(in) :: newx\n+    integer , intent(in) :: newy\n+    this%x_=newx\n+    this%y_=newy\n+  end subroutine moveto\n+\n+  subroutine draw(this)\n+    implicit none\n+    class (shape_type), intent(in) :: this\n+    print *,' x = ' , this%x_\n+    print *,' y = ' , this%y_\n+  end subroutine draw\n+\n+  subroutine generic_shape_assign(lhs,rhs)\n+  implicit none\n+    class (shape_type) , intent(out) , allocatable :: lhs\n+    class (shape_type) , intent(in) :: rhs\n+      print *,' In generic_shape_assign'\n+      if ( allocated(lhs) ) then\n+        deallocate(lhs)\n+      end if\n+      allocate(lhs,source=rhs)\n+  end subroutine generic_shape_assign\n+  \n+end module shape_module\n+\n+! Circle_p.f90\n+\n+module circle_module\n+\n+use shape_module\n+\n+type , extends(shape_type) :: circle_type\n+\n+  integer :: radius_\n+\n+  contains\n+\n+  procedure , pass(this) :: getradius\n+  procedure , pass(this) :: setradius\n+  procedure , pass(this) :: draw => draw_circle\n+\n+end type circle_type\n+\n+  contains\n+\n+  integer function getradius(this)\n+  implicit none\n+  class (circle_type) , intent(in) :: this\n+    getradius=this%radius_\n+  end function getradius\n+\n+  subroutine setradius(this,radius)\n+  implicit none\n+  class (circle_type) , intent(inout) :: this\n+  integer , intent(in) :: radius\n+    this%radius_=radius\n+  end subroutine setradius\n+\n+  subroutine draw_circle(this)\n+  implicit none\n+    class (circle_type), intent(in) :: this\n+    print *,' x = ' , this%x_\n+    print *,' y = ' , this%y_\n+    print *,' radius = ' , this%radius_\n+  end subroutine draw_circle\n+\n+end module circle_module\n+\n+\n+! Rectangle_p.f90\n+\n+module rectangle_module\n+\n+use shape_module\n+\n+type , extends(shape_type) :: rectangle_type\n+\n+  integer :: width_\n+  integer :: height_\n+\n+  contains\n+\n+  procedure , pass(this) :: getwidth\n+  procedure , pass(this) :: setwidth\n+  procedure , pass(this) :: getheight\n+  procedure , pass(this) :: setheight\n+  procedure , pass(this) :: draw => draw_rectangle\n+\n+end type rectangle_type\n+\n+  contains\n+\n+  integer function getwidth(this)\n+  implicit none\n+  class (rectangle_type) , intent(in) :: this\n+    getwidth=this%width_\n+  end function getwidth\n+\n+  subroutine setwidth(this,width)\n+  implicit none\n+  class (rectangle_type) , intent(inout) :: this\n+  integer , intent(in) :: width\n+    this%width_=width\n+  end subroutine setwidth\n+\n+  integer function getheight(this)\n+  implicit none\n+  class (rectangle_type) , intent(in) :: this\n+    getheight=this%height_\n+  end function getheight\n+\n+  subroutine setheight(this,height)\n+  implicit none\n+  class (rectangle_type) , intent(inout) :: this\n+  integer , intent(in) :: height\n+    this%height_=height\n+  end subroutine setheight\n+\n+  subroutine draw_rectangle(this)\n+  implicit none\n+    class (rectangle_type), intent(in) :: this\n+    print *,' x = ' , this%x_\n+    print *,' y = ' , this%y_\n+    print *,' width = ' , this%width_\n+    print *,' height = ' , this%height_\n+\n+  end subroutine draw_rectangle\n+\n+end module rectangle_module\n+\n+\n+\n+program polymorphic\n+\n+use shape_module\n+use circle_module\n+use rectangle_module\n+\n+implicit none\n+\n+type shape_w\n+  class (shape_type) , allocatable :: shape_v\n+end type shape_w\n+\n+type (shape_w) , dimension(3) :: p\n+\n+  print *,' shape '\n+\n+  p(1)%shape_v=shape_type(10,20)\n+  call p(1)%shape_v%draw()\n+\n+  print *,' circle '\n+\n+  p(2)%shape_v=circle_type(100,200,300)\n+  call p(2)%shape_v%draw()\n+\n+  print *,' rectangle '\n+\n+  p(3)%shape_v=rectangle_type(1000,2000,3000,4000)\n+  call p(3)%shape_v%draw()\n+\n+end program polymorphic"}, {"sha": "b23ef70bb935cce8b13610faa2be72b0a78ad4c5", "filename": "gcc/testsuite/gfortran.dg/move_alloc_4.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_4.f90?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -10,13 +10,14 @@ program testmv3\n     integer, allocatable  :: ia(:), ja(:)\n   end type\n \n+ block ! For auto-dealloc, as PROGRAM implies SAVE\n   type(bar), allocatable :: sm,sm2\n \n   allocate(sm)\n   allocate(sm%ia(10),sm%ja(10))\n \n   call move_alloc(sm2,sm)\n-\n+ end block\n end program testmv3 \n \n ! { dg-final { scan-tree-dump-times \"__builtin_free\" 9 \"original\" } }"}, {"sha": "ce845a03b069b2d30ae625430a0ac9c383a28a67", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_27.f03", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_27.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2925370ee74f7b0d0845affc35b0030848b5ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_27.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_27.f03?ref=ef2925370ee74f7b0d0845affc35b0030848b5ae", "patch": "@@ -33,6 +33,7 @@ program prog\n \n   use m\n \n+ block ! Start new scoping unit as PROGRAM implies SAVE\n   type(tx) :: this\n   type(tx), target :: that\n   type(tx), pointer :: p\n@@ -64,6 +65,7 @@ program prog\n   !print *,this%i\n   if(any (this%i /= [8, 9])) call abort()\n \n+ end block\n end program prog\n \n !"}]}