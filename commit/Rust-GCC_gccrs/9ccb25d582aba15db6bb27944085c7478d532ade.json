{"sha": "9ccb25d582aba15db6bb27944085c7478d532ade", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNjYjI1ZDU4MmFiYTE1ZGI2YmIyNzk0NDA4NWM3NDc4ZDUzMmFkZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-11-27T07:09:20Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-11-27T07:09:20Z"}, "message": "tree.h (mark_tree_hashtable): New function.\n\n\t* tree.h (mark_tree_hashtable): New function.\n\t* tree.c (mark_tree_hashtable_entry): New function.\n\t(mark_tree_hashtable): Likewise.\n\n\t* tree.c (struct list_hash): Remove.\n\t(list_hash_table): Make it be an htab.\n\t(struct list_proxy): New type.\n\t(list_hash_eq): New function.\n\t(list_hash_pieces): Renamed from ...\n\t(list_hash): ... this.\n\t(list_hash_lookup): Remove.\n\t(list_hash_add): Remove.\n\t(hash_tree_cons): Use the generic hashtable.\n\t(mark_list_hash): Remove.\n\t(init_tree): Create the hashtable.\n\nFrom-SVN: r37783", "tree": {"sha": "0f3bff8650362598772997ba22bded572eefeb8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f3bff8650362598772997ba22bded572eefeb8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ccb25d582aba15db6bb27944085c7478d532ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccb25d582aba15db6bb27944085c7478d532ade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ccb25d582aba15db6bb27944085c7478d532ade", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccb25d582aba15db6bb27944085c7478d532ade/comments", "author": null, "committer": null, "parents": [{"sha": "ea8136058d7d1f3214da4ff8aaa16ea5de780b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea8136058d7d1f3214da4ff8aaa16ea5de780b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea8136058d7d1f3214da4ff8aaa16ea5de780b0e"}], "stats": {"total": 200, "additions": 109, "deletions": 91}, "files": [{"sha": "099d51c890fe5c17ac9a40d427535c2bd12f4edd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ccb25d582aba15db6bb27944085c7478d532ade", "patch": "@@ -1,3 +1,9 @@\n+2000-11-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* tree.h (mark_tree_hashtable): New function.\n+\t* tree.c (mark_tree_hashtable_entry): New function.\n+\t(mark_tree_hashtable): Likewise.\n+\n 2000-11-27  Michael Meissner  <meissner@redhat.com>\n \n \t* d30v-protos.h (srelational_si_operator): Correctly spell"}, {"sha": "7b36db17751cf532e6f259d77e982c6687786003", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9ccb25d582aba15db6bb27944085c7478d532ade", "patch": "@@ -1,3 +1,17 @@\n+2000-11-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* tree.c (struct list_hash): Remove.\n+\t(list_hash_table): Make it be an htab.\n+\t(struct list_proxy): New type.\n+\t(list_hash_eq): New function.\n+\t(list_hash_pieces): Renamed from ...\n+\t(list_hash): ... this.\n+\t(list_hash_lookup): Remove.\n+\t(list_hash_add): Remove.\n+\t(hash_tree_cons): Use the generic hashtable.\n+\t(mark_list_hash): Remove.\n+\t(init_tree): Create the hashtable.\n+\n 2000-11-25  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* method.c (build_mangled_C9x_name): Rename to"}, {"sha": "517a5cc3e04d1d45f8e7754c395069cae4bea7f5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 64, "deletions": 91, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9ccb25d582aba15db6bb27944085c7478d532ade", "patch": "@@ -35,13 +35,12 @@ Boston, MA 02111-1307, USA.  */\n static tree bot_manip PARAMS ((tree *, int *, void *));\n static tree bot_replace PARAMS ((tree *, int *, void *));\n static tree build_cplus_array_type_1 PARAMS ((tree, tree));\n-static void list_hash_add PARAMS ((int, tree));\n-static int list_hash PARAMS ((tree, tree, tree));\n-static tree list_hash_lookup PARAMS ((int, tree, tree, tree));\n+static int list_hash_eq PARAMS ((const void *, const void *));\n+static hashval_t list_hash_pieces PARAMS ((tree, tree, tree));\n+static hashval_t list_hash PARAMS ((const void *));\n static cp_lvalue_kind lvalue_p_1 PARAMS ((tree, int));\n static tree no_linkage_helper PARAMS ((tree *, int *, void *));\n static tree build_srcloc PARAMS ((const char *, int));\n-static void mark_list_hash PARAMS ((void *));\n static tree mark_local_for_remap_r PARAMS ((tree *, int *, void *));\n static tree cp_unsave_r PARAMS ((tree *, int *, void *));\n static void cp_unsave PARAMS ((tree *));\n@@ -695,38 +694,52 @@ unshare_base_binfos (binfo)\n /* Hashing of lists so that we don't make duplicates.\n    The entry point is `list_hash_canon'.  */\n \n-/* Each hash table slot is a bucket containing a chain\n-   of these structures.  */\n-\n-struct list_hash\n-{\n-  struct list_hash *next;\t/* Next structure in the bucket.  */\n-  int hashcode;\t\t\t/* Hash code of this list.  */\n-  tree list;\t\t\t/* The list recorded here.  */\n-};\n-\n /* Now here is the hash table.  When recording a list, it is added\n    to the slot whose index is the hash code mod the table size.\n    Note that the hash table is used for several kinds of lists.\n    While all these live in the same table, they are completely independent,\n    and the hash code is computed differently for each of these.  */\n \n-#define TYPE_HASH_SIZE 59\n-static struct list_hash *list_hash_table[TYPE_HASH_SIZE];\n+static htab_t list_hash_table;\n+\n+struct list_proxy \n+{\n+  tree purpose;\n+  tree value;\n+  tree chain;\n+};\n+\n+/* Compare ENTRY (an entry in the hash table) with DATA (a list_proxy\n+   for a node we are thinking about adding).  */\n+\n+static int\n+list_hash_eq (entry, data)\n+     const void *entry;\n+     const void *data;\n+{\n+  tree t = (tree) entry;\n+  struct list_proxy *proxy = (struct list_proxy *) data;\n+\n+  return (TREE_VALUE (t) == proxy->value\n+\t  && TREE_PURPOSE (t) == proxy->purpose\n+\t  && TREE_CHAIN (t) == proxy->chain);\n+}\n \n /* Compute a hash code for a list (chain of TREE_LIST nodes\n    with goodies in the TREE_PURPOSE, TREE_VALUE, and bits of the\n    TREE_COMMON slots), by adding the hash codes of the individual entries.  */\n \n-static int\n-list_hash (purpose, value, chain)\n-     tree purpose, value, chain;\n+static hashval_t\n+list_hash_pieces (purpose, value, chain)\n+     tree purpose;\n+     tree value;\n+     tree chain;\n {\n-  register int hashcode = 0;\n-\n+  hashval_t hashcode = 0;\n+  \n   if (chain)\n     hashcode += TYPE_HASH (chain);\n-\n+  \n   if (value)\n     hashcode += TYPE_HASH (value);\n   else\n@@ -738,72 +751,44 @@ list_hash (purpose, value, chain)\n   return hashcode;\n }\n \n-/* Look in the type hash table for a type isomorphic to TYPE.\n-   If one is found, return it.  Otherwise return 0.  */\n+/* Hash an already existing TREE_LIST.  */\n \n-static tree\n-list_hash_lookup (hashcode, purpose, value, chain)\n-     int hashcode;\n-     tree purpose, value, chain;\n+static hashval_t\n+list_hash (p)\n+     const void *p;\n {\n-  register struct list_hash *h;\n-\n-  for (h = list_hash_table[hashcode % TYPE_HASH_SIZE]; h; h = h->next)\n-    if (h->hashcode == hashcode\n-\t&& TREE_PURPOSE (h->list) == purpose\n-\t&& TREE_VALUE (h->list) == value\n-\t&& TREE_CHAIN (h->list) == chain)\n-      return h->list;\n-  return 0;\n-}\n-\n-/* Add an entry to the list-hash-table\n-   for a list TYPE whose hash code is HASHCODE.  */\n-\n-static void\n-list_hash_add (hashcode, list)\n-     int hashcode;\n-     tree list;\n-{\n-  register struct list_hash *h;\n-\n-  h = (struct list_hash *) obstack_alloc (&permanent_obstack, sizeof (struct list_hash));\n-  h->hashcode = hashcode;\n-  h->list = list;\n-  h->next = list_hash_table[hashcode % TYPE_HASH_SIZE];\n-  list_hash_table[hashcode % TYPE_HASH_SIZE] = h;\n+  tree t = (tree) p;\n+  return list_hash_pieces (TREE_PURPOSE (t), \n+\t\t\t   TREE_VALUE (t), \n+\t\t\t   TREE_CHAIN (t));\n }\n \n /* Given list components PURPOSE, VALUE, AND CHAIN, return the canonical\n    object for an identical list if one already exists.  Otherwise, build a\n    new one, and record it as the canonical object.  */\n \n-/* Set to 1 to debug without canonicalization.  Never set by program.  */\n-\n-static int debug_no_list_hash = 0;\n-\n tree\n hash_tree_cons (purpose, value, chain)\n      tree purpose, value, chain;\n {\n-  tree t;\n   int hashcode = 0;\n-\n-  if (! debug_no_list_hash)\n-    {\n-      hashcode = list_hash (purpose, value, chain);\n-      t = list_hash_lookup (hashcode, purpose, value, chain);\n-      if (t)\n-\treturn t;\n-    }\n-\n-  t = tree_cons (purpose, value, chain);\n-\n-  /* If this is a new list, record it for later reuse.  */\n-  if (! debug_no_list_hash)\n-    list_hash_add (hashcode, t);\n-\n-  return t;\n+  PTR* slot;\n+  struct list_proxy proxy;\n+\n+  /* Hash the list node.  */\n+  hashcode = list_hash_pieces (purpose, value, chain);\n+  /* Create a proxy for the TREE_LIST we would like to create.  We\n+     don't actually create it so as to avoid creating garbage.  */\n+  proxy.purpose = purpose;\n+  proxy.value = value;\n+  proxy.chain = chain;\n+  /* See if it is already in the table.  */\n+  slot = htab_find_slot_with_hash (list_hash_table, &proxy, hashcode,\n+\t\t\t\t   INSERT);\n+  /* If not, create a new node.  */\n+  if (!*slot)\n+    *slot = (PTR) tree_cons (purpose, value, chain);\n+  return *slot;\n }\n \n /* Constructor for hashed lists.  */\n@@ -2382,18 +2367,6 @@ make_ptrmem_cst (type, member)\n   return ptrmem_cst;\n }\n \n-/* Mark ARG (which is really a list_hash_table **) for GC.  */\n-\n-static void\n-mark_list_hash (arg)\n-     void *arg;\n-{\n-  struct list_hash *lh;\n-\n-  for (lh = * ((struct list_hash **) arg); lh; lh = lh->next)\n-    ggc_mark_tree (lh->list);\n-}\n-\n /* Initialize tree.c.  */\n \n void\n@@ -2402,10 +2375,10 @@ init_tree ()\n   make_lang_type_fn = cp_make_lang_type;\n   lang_unsave = cp_unsave;\n   lang_statement_code_p = cp_statement_code_p;\n-  ggc_add_root (list_hash_table, \n-\t\tARRAY_SIZE (list_hash_table),\n-\t\tsizeof (struct list_hash *),\n-\t\tmark_list_hash);\n+  list_hash_table = htab_create (31, list_hash, list_hash_eq, NULL);\n+  ggc_add_root (&list_hash_table, 1, \n+\t\tsizeof (list_hash_table),\n+\t\tmark_tree_hashtable);\n }\n \n /* The SAVE_EXPR pointed to by TP is being copied.  If ST contains"}, {"sha": "acc744619b3a625d28379ac0768940477acbd0a2", "filename": "gcc/tree.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9ccb25d582aba15db6bb27944085c7478d532ade", "patch": "@@ -170,6 +170,7 @@ static unsigned int type_hash_hash PARAMS ((const void*));\n static void print_type_hash_statistics PARAMS((void));\n static int mark_hash_entry PARAMS((void **, void *));\n static void finish_vector_type PARAMS((tree));\n+static int mark_tree_hashtable_entry PARAMS((void **, void *));\n \n /* If non-null, these are language-specific helper functions for\n    unsave_expr_now.  If present, LANG_UNSAVE is called before its\n@@ -3184,6 +3185,29 @@ mark_type_hash (arg)\n   htab_traverse (t, mark_hash_entry, 0);\n }\n \n+/* Mark the hashtable slot pointed to by ENTRY (which is really a\n+   `tree**') for GC.  */\n+\n+static int\n+mark_tree_hashtable_entry (entry, data)\n+     void **entry;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  ggc_mark_tree ((tree) *entry);\n+  return 1;\n+}\n+\n+/* Mark ARG (which is really a htab_t whose slots are trees) for \n+   GC.  */\n+\n+void\n+mark_tree_hashtable (arg)\n+     void *arg;\n+{\n+  htab_t t = *(htab_t *) arg;\n+  htab_traverse (t, mark_tree_hashtable_entry, 0);\n+}\n+\n static void\n print_type_hash_statistics ()\n {"}, {"sha": "822ecf3d88b4cc8a5e3d3f978ef7e94d42091028", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccb25d582aba15db6bb27944085c7478d532ade/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9ccb25d582aba15db6bb27944085c7478d532ade", "patch": "@@ -2666,6 +2666,7 @@ extern void gcc_obstack_init\t\tPARAMS ((struct obstack *));\n extern void init_obstacks\t\tPARAMS ((void));\n extern void build_common_tree_nodes\tPARAMS ((int));\n extern void build_common_tree_nodes_2\tPARAMS ((int));\n+extern void mark_tree_hashtable         PARAMS ((void *));\n \n /* In function.c */\n extern void setjmp_protect_args\t\tPARAMS ((void));"}]}