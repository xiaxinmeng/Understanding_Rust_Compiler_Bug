{"sha": "4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc5ODYzMGNiMGFhOTliMzQ5N2ExNmIzZTFhNWVlMGUxMmExNzYwYg==", "commit": {"author": {"name": "P.J. Darcy", "email": "darcypj@us.ibm.com", "date": "2004-09-22T13:57:40Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-09-22T13:57:40Z"}, "message": "s390-protos.h (s390_emit_tpf_eh_return): Add prototype.\n\n2004-09-22  P.J. Darcy  <darcypj@us.ibm.com>\n\n\t* config/s390/s390-protos.h (s390_emit_tpf_eh_return): Add prototype.\n\t* config/s390/s390.c (s390_emit_tpf_eh_return): New function.\n\t* config/s390/s390.h (TARGET_TPF): New macro.\n\t* config/s390/s390.md (\"eh_return\"): New expander.\n\t* config/s390/t-tpf (LIB2ADDEH): Use unwind-dw2-fde.c rather than\n\tunwind-dw2-fde-glibc.c.  Add config/s390/tpf-eh.c.\n\t(LIB2ADDEHDEP): Remove unwind-dw2-fde.c.\n\t* config/s390/tpf.h (TARGET_TPF): Define to 1.\n\t(STACK_POINTER_OFFSET): Increase to 448.\n\t(TARGET_DEFAULT): Set -mtpf-trace on as default.\n\t(TPF_LOC_DIFF_OFFSET): New macro.\n\t(ASM_PREFERRED_EH_DATA_FORMAT): Redefine to always use absolute\n\tencoding.\n\t(__isPATrange): Add prototype.\n\t(MD_FALLBACK_FRAME_STATE_FOR): Define.\n\t* config/s390/tpf-eh.c: New file.\n\nFrom-SVN: r87857", "tree": {"sha": "5ea4cb91c0ccfc079c8ba527aecfba6dfff616d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ea4cb91c0ccfc079c8ba527aecfba6dfff616d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/comments", "author": null, "committer": null, "parents": [{"sha": "6a97296a060b9e053ae598076ffa14c41a5b6f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a97296a060b9e053ae598076ffa14c41a5b6f39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a97296a060b9e053ae598076ffa14c41a5b6f39"}], "stats": {"total": 332, "additions": 325, "deletions": 7}, "files": [{"sha": "1a95e0446a3063e064cb9ca7165f8ffc046da6d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "patch": "@@ -1,3 +1,22 @@\n+2004-09-22  P.J. Darcy  <darcypj@us.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_emit_tpf_eh_return): Add prototype.\n+\t* config/s390/s390.c (s390_emit_tpf_eh_return): New function.\n+\t* config/s390/s390.h (TARGET_TPF): New macro.\n+\t* config/s390/s390.md (\"eh_return\"): New expander.\n+\t* config/s390/t-tpf (LIB2ADDEH): Use unwind-dw2-fde.c rather than\n+\tunwind-dw2-fde-glibc.c.  Add config/s390/tpf-eh.c.\n+\t(LIB2ADDEHDEP): Remove unwind-dw2-fde.c.\n+\t* config/s390/tpf.h (TARGET_TPF): Define to 1.\n+\t(STACK_POINTER_OFFSET): Increase to 448.\n+\t(TARGET_DEFAULT): Set -mtpf-trace on as default.\n+\t(TPF_LOC_DIFF_OFFSET): New macro.\n+\t(ASM_PREFERRED_EH_DATA_FORMAT): Redefine to always use absolute\n+\tencoding.\n+\t(__isPATrange): Add prototype.\n+\t(MD_FALLBACK_FRAME_STATE_FOR): Define.\n+\t* config/s390/tpf-eh.c: New file.\n+\n 2004-09-22  Diego Novillo  <dnovillo@redhat.com>\n \n \t* fold-const.c (fold): Avoid non INTEGER_TYPEs when widening"}, {"sha": "8b5a263d98bffd67ec707f9879b0d9ce1c0ab970", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "patch": "@@ -95,6 +95,7 @@ extern rtx s390_gen_rtx_const_DI (int, int);\n extern void s390_output_dwarf_dtprel (FILE*, int, rtx);\n extern int s390_agen_dep_p (rtx, rtx);\n extern rtx s390_load_got (void);\n+extern void s390_emit_tpf_eh_return (rtx);\n \n #endif /* RTX_CODE */\n "}, {"sha": "5d838ef715c256ae85768c9857d0031af1799b6a", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "patch": "@@ -8017,5 +8017,25 @@ s390_conditional_register_usage (void)\n     }\n }\n \n+/* Corresponding function to eh_return expander.  */\n+\n+static GTY(()) rtx s390_tpf_eh_return_symbol;\n+void\n+s390_emit_tpf_eh_return (rtx target)\n+{\n+  rtx insn, reg;\n+\n+  if (!s390_tpf_eh_return_symbol)\n+    s390_tpf_eh_return_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tpf_eh_return\");\n+\n+  reg = gen_rtx_REG (Pmode, 2);\n+\n+  emit_move_insn (reg, target);\n+  insn = s390_emit_call (s390_tpf_eh_return_symbol, NULL_RTX, reg,\n+                                     gen_rtx_REG (Pmode, RETURN_REGNUM));\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), reg);\n+\n+  emit_move_insn (EH_RETURN_HANDLER_RTX, reg);\n+}\n \n #include \"gt-s390.h\""}, {"sha": "5b083aadbe67c67dcd1d5ea2f8e378040dabea4b", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "patch": "@@ -80,6 +80,9 @@ extern const char *s390_stack_guard_string;\n \n /* Run-time target specification.  */\n \n+/* This will be overridden by OS headers.  */\n+#define TARGET_TPF 0\n+\n /* Target CPU builtins.  */\n #define TARGET_CPU_CPP_BUILTINS()\t\t\t\\\n   do\t\t\t\t\t\t\t\\"}, {"sha": "8c65145f41924caa7176025c55c5f79d95a9e234", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "patch": "@@ -7504,3 +7504,15 @@\n \t\t\t GEN_INT (0x7fffffff)));\n   DONE;\n })\n+\n+;; Instruction definition to expand eh_return macro to support\n+;; swapping in special linkage return addresses.\n+\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"register_operand\" \"\"))]\n+  \"TARGET_TPF\"\n+{\n+  s390_emit_tpf_eh_return (operands[0]);\n+  DONE;\n+})\n+"}, {"sha": "76d2c23a8b0755837c1650712c8e6422f168f0de", "filename": "gcc/config/s390/t-tpf", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Ft-tpf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Ft-tpf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ft-tpf?ref=4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "patch": "@@ -7,7 +7,8 @@ TARGET_LIBGCC2_CFLAGS = -fPIC\n # the symbol versions that glibc used.\n SHLIB_MAPFILES += $(srcdir)/config/s390/libgcc-glibc.ver\n \n-# Use unwind-dw2-fde-glibc\n-LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-glibc.c \\\n-  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c\n-LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c\n+# Use unwind-dw2-fde and extra tpf-eh support routines.\n+LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n+  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c \\\n+  $(srcdir)/config/s390/tpf-eh.c\n+LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h"}, {"sha": "1ce01ab56eaeccbe7f519631c2aeceeddb510ec5", "filename": "gcc/config/s390/tpf-eh.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Ftpf-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Ftpf-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ftpf-eh.c?ref=4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "patch": "@@ -0,0 +1,183 @@\n+/* Exception handling routines for TPF.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by P.J. Darcy (darcypj@us.ibm.com).\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#define __USE_GNU 1\n+#define _GNU_SOURCE\n+#include <dlfcn.h>\n+#undef __USE_GNU\n+#undef _GNU_SOURCE\n+\n+#define CURRENT_STACK_PTR() \\\n+  ({ register unsigned long int *stack_ptr asm (\"%r15\"); stack_ptr; })\n+\n+#define PREVIOUS_STACK_PTR() \\\n+  ((unsigned long int *)(*(CURRENT_STACK_PTR())))\n+\n+#define RA_OFFSET_FROM_START_OF_STACK_FRAME 112\n+#define CURRENT_STACK_PTR_OFFSET 120\n+#define TPFRA_OFFSET_FROM_START_OF_STACK_FRAME 168\n+#define MIN_PATRANGE 0x10000\n+#define MAX_PATRANGE 0x800000\n+#define INVALID_RETURN 0\n+\n+/* Function Name: __isPATrange\n+   Parameters passed into it:  address to check\n+   Return Value: A 1 if address is in pat code \"range\", 0 if not\n+   Description: This function simply checks to see if the address\n+   passed to it is in the CP pat code range.  */\n+\n+unsigned int __isPATrange(void *addr) \n+{\n+  if (addr > (void *)MIN_PATRANGE && addr < (void *)MAX_PATRANGE)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Function Name: __tpf_eh_return\n+   Parameters passed into it: Destination address to jump to.\n+   Return Value: Converted Destination address if a Pat Stub exists.\n+   Description: This function swaps the uwinding return address\n+      with the cp stub code.  The original target return address is\n+      then stored into the tpf return address field.  The cp stub\n+      code is searched for by climbing back up the stack and\n+      comparing the tpf stored return address object address to\n+      that of the targets object address.  */\n+\n+void *__tpf_eh_return (void *target) \n+{\n+  Dl_info targetcodeInfo, currentcodeInfo;\n+  int retval;\n+  void *current, *stackptr;\n+  unsigned long int shifter;\n+\n+  /* Get code info for target return's address.  */\n+  retval = dladdr (target, &targetcodeInfo);\n+\n+  /* Get the return address of the stack frame to be replaced by\n+     the exception unwinder.  So that the __cxa_throw return is\n+     replaced by the target return.  */\n+  current = (void *) *((unsigned long int *)\n+                 ((*((unsigned long int *)*(PREVIOUS_STACK_PTR()))) \n+                             + RA_OFFSET_FROM_START_OF_STACK_FRAME));\n+\n+  /* Ensure the code info is valid (for target).  */\n+  if (retval != INVALID_RETURN) \n+    {\n+      /* Now check to see if the current RA is a PAT\n+         stub return address.  */\n+      if ( __isPATrange(current)) \n+        {\n+          /* It was!  Then go into the TPF private stack area and fetch\n+             the real address.  */\n+          current = (void *) *((unsigned long int *) \n+                           ((unsigned long int)*((unsigned long int *)\n+                           *(PREVIOUS_STACK_PTR())) \n+                           +TPFRA_OFFSET_FROM_START_OF_STACK_FRAME));\n+        }\n+\n+      /* Get code info for current return address.  */\n+      retval = dladdr (current, &currentcodeInfo);\n+\n+      /* Ensure the code info is valid (for current frame).  */\n+      if (retval != INVALID_RETURN) \n+        {\n+          /* Get the stack pointer of the stack frame to be replaced by\n+             the exception unwinder.  So that we can begin our climb\n+             there.  */\n+          stackptr = (void *) (*((unsigned long int *)\n+                      (*((unsigned long int *)(*(PREVIOUS_STACK_PTR()))))));\n+\n+          /* Begin looping through stack frames.  Stop if invalid\n+             code information is retrieved or if a match between the\n+             current stack frame iteration shared object's address \n+             matches that of the target, calculated above.  */\n+          while (retval != INVALID_RETURN\n+                 && targetcodeInfo.dli_fbase != currentcodeInfo.dli_fbase)\n+            {\n+              /* Get return address based on our stackptr iterator.  */\n+              current = (void *) *((unsigned long int *) \n+                     (stackptr+RA_OFFSET_FROM_START_OF_STACK_FRAME));\n+\n+              /* Is it a Pat Stub?  */\n+              if (__isPATrange (current)) \n+                {\n+                  /* Yes it was, get real return address \n+                     in TPF stack area.  */\n+                  current = (void *) *((unsigned long int *) \n+                         (stackptr+TPFRA_OFFSET_FROM_START_OF_STACK_FRAME));\n+                }\n+\n+              /* Get codeinfo on RA so that we can figure out\n+                 the module address.  */\n+              retval = dladdr (current, &currentcodeInfo);\n+\n+              /* Check that codeinfo for current stack frame is valid.\n+                 Then compare the module address of current stack frame\n+                 to target stack frame to determine if we have the pat\n+                 stub address we want.  */\n+              if (retval != INVALID_RETURN\n+                  && targetcodeInfo.dli_fbase == currentcodeInfo.dli_fbase)\n+                {\n+                  /* Yes!  They are in the same module.  Now store the\n+                     real target address into the TPF stack area of\n+                     the target frame we are jumping to.  */\n+                  *((unsigned long int *)(*((unsigned long int *) \n+                          (*PREVIOUS_STACK_PTR() + CURRENT_STACK_PTR_OFFSET))\n+                          + TPFRA_OFFSET_FROM_START_OF_STACK_FRAME)) \n+                          = (unsigned long int) target;\n+\n+                  /* Before returning the desired pat stub address to\n+                     the exception handling unwinder so that it can \n+                     actually do the \"leap\" shift out the low order \n+                     bit designated to determine if we are in 64BIT mode.\n+                     This is nececcary for CTOA stubs.\n+                     Otherwise we leap one byte past where we want to \n+                     go to in the TPF pat stub linkage code.  */\n+                  shifter = *((unsigned long int *) \n+                       (stackptr + RA_OFFSET_FROM_START_OF_STACK_FRAME));\n+\n+                  shifter &= ~1ul;\n+\n+                  return (void *) shifter;\n+                }\n+\n+              /* Desired module pat stub not found ...\n+                 Bump stack frame iterator.  */\n+              stackptr = (void *) *(unsigned long int *) stackptr;\n+            }\n+        }\n+    }\n+\n+  /* No pat stub found, could be a problem?  Simply return unmodified\n+     target address.  */\n+  return target;\n+}\n+"}, {"sha": "587d373d6b745b46d1aa16132d7bb23b4ba0c915", "filename": "gcc/config/s390/tpf.h", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Ftpf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4798630cb0aa99b3497a16b3e1a5ee0e12a1760b/gcc%2Fconfig%2Fs390%2Ftpf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ftpf.h?ref=4798630cb0aa99b3497a16b3e1a5ee0e12a1760b", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for target OS TPF for GNU compiler, for IBM S/390 hardware\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n    Contributed by P.J. Darcy (darcypj@us.ibm.com),\n                   Hartmut Penner (hpenner@de.ibm.com), and\n                   Ulrich Weigand (uweigand@de.ibm.com).\n@@ -25,6 +25,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define _TPF_H\n \n /* TPF wants the following macros defined/undefined as follows.  */\n+#undef TARGET_TPF\n+#define TARGET_TPF 1\n #undef ASM_APP_ON\n #define ASM_APP_ON \"#APP\\n\"\n #undef ASM_APP_OFF\n@@ -50,11 +52,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* TPF OS specific stack-pointer offset.  */\n #undef STACK_POINTER_OFFSET\n-#define STACK_POINTER_OFFSET \t\t280\n+#define STACK_POINTER_OFFSET \t\t448\n+/* TPF stack placeholder offset.  */\n+#undef TPF_LOC_DIFF_OFFSET\n+#define TPF_LOC_DIFF_OFFSET             168\n \n /* When building for TPF, set a generic default target that is 64 bits.  */\n #undef TARGET_DEFAULT\n-#define TARGET_DEFAULT             0x33\n+#define TARGET_DEFAULT             0xb3\n+\n+/* Exception handling.  */\n+\n+/* Select a format to encode pointers in exception handling data.  */\n+#undef ASM_PREFERRED_EH_DATA_FORMAT\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) DW_EH_PE_absptr\n \n /* TPF OS specific compiler settings.  */\n #undef TARGET_OS_CPP_BUILTINS\n@@ -108,5 +119,73 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n         %{rdynamic:-export-dynamic} \\\n         %{!dynamic-linker:-dynamic-linker /lib/ld64.so}}}\"\n \n+extern unsigned int __isPATrange (void *);\n+\n+/* Exceptions macro defined for TPF so that functions without \n+   dwarf frame information can be used with exceptions.  */\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)               \\\n+  do                                                                    \\\n+    {                                                                   \\\n+      unsigned long int regs_;                                          \\\n+      unsigned long int new_cfa_;                                       \\\n+      int i_;                                                           \\\n+                                                                        \\\n+      if ((CONTEXT)->cfa == NULL)                                       \\\n+        goto SUCCESS;                                                   \\\n+                                                                        \\\n+      /* Are we going through special linkage code?  */                 \\\n+      if (__isPATrange((CONTEXT)->ra))                                  \\\n+        {                                                               \\\n+          /* No stack frame.   */                                       \\\n+          (FS)->cfa_how = CFA_REG_OFFSET;                               \\\n+          (FS)->cfa_reg = 15;                                           \\\n+          (FS)->cfa_offset = STACK_POINTER_OFFSET;                      \\\n+                                                                        \\\n+          /* All registers remain unchanged ...  */                     \\\n+          for (i_ = 0; i_ < 32; i_++)                                   \\\n+            {                                                           \\\n+              (FS)->regs.reg[i_].how = REG_SAVED_REG;                   \\\n+              (FS)->regs.reg[i_].loc.reg = i_;                          \\\n+            }                                                           \\\n+                                                                        \\\n+          /* ... except for %r14, which is stored at CFA-112            \\\n+             and used as return address.  */                            \\\n+          (FS)->regs.reg[14].how = REG_SAVED_OFFSET;                    \\\n+          (FS)->regs.reg[14].loc.offset =                               \\\n+            TPF_LOC_DIFF_OFFSET - STACK_POINTER_OFFSET;                 \\\n+          (FS)->retaddr_column = 14;                                    \\\n+                                                                        \\\n+          goto SUCCESS;                                                 \\\n+                                                                        \\\n+        }                                                               \\\n+                                                                        \\\n+      regs_ = *((unsigned long int *)                                   \\\n+        (((unsigned long int) (CONTEXT)->cfa) - STACK_POINTER_OFFSET)); \\\n+      new_cfa_ = regs_ + STACK_POINTER_OFFSET;                          \\\n+      (FS)->cfa_how = CFA_REG_OFFSET;                                   \\\n+      (FS)->cfa_reg = 15;                                               \\\n+      (FS)->cfa_offset = new_cfa_ -                                     \\\n+        (unsigned long int) (CONTEXT)->cfa + STACK_POINTER_OFFSET;      \\\n+                                                                        \\\n+      for (i_ = 0; i_ < 16; i_++)                                       \\\n+        {                                                               \\\n+          (FS)->regs.reg[i_].how = REG_SAVED_OFFSET;                    \\\n+          (FS)->regs.reg[i_].loc.offset =                               \\\n+            (regs_+(i_*8)) - new_cfa_;                                  \\\n+        }                                                               \\\n+                                                                        \\\n+      for (i_ = 0; i_ < 4; i_++)                                        \\\n+        {                                                               \\\n+          (FS)->regs.reg[16+i_].how = REG_SAVED_OFFSET;                 \\\n+          (FS)->regs.reg[16+i_].loc.offset =                            \\\n+            (regs_+(16*8)+(i_*8)) - new_cfa_;                           \\\n+        }                                                               \\\n+                                                                        \\\n+      (FS)->retaddr_column = 14;                                        \\\n+                                                                        \\\n+      goto SUCCESS;                                                     \\\n+                                                                        \\\n+    } while (0)\n+\n #endif /* ! _TPF_H */\n "}]}