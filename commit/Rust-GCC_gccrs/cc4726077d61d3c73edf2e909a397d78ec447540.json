{"sha": "cc4726077d61d3c73edf2e909a397d78ec447540", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M0NzI2MDc3ZDYxZDNjNzNlZGYyZTkwOWEzOTdkNzhlYzQ0NzU0MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-07-16T13:41:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-07-16T13:41:41Z"}, "message": "read-md.h (file_location): New structure.\n\ngcc/\n\t* read-md.h (file_location): New structure.\n\t(directive_handler_t): Take a file_location rather than a line number.\n\t(message_at, error_at): Declare.\n\t(read_skip_construct): Delete.\n\t* read-md.c (message_with_line_1): Replace with...\n\t(message_at_1): ...this new function.\n\t(message_at, error_at): New functions.\n\t(message_with_line, error_with_line): Update to use message_at_1.\n\t(handle_enum): Take a file_location rather than a line number\n\tand use error_at for error reporting.\n\t(handle_include): Likewise.\n\t(read_skip_construct): Likewise.  Make static.\n\t(handle_file): Update after above changes.  Pass a file_location\n\trather than a line number to handle_directive.\n\t* gensupport.c (queue_elem): Replace separate filename and lineno\n\twith a file_location.\n\t(queue_pattern): Replace filename and lineno arguments with a\n\tfile_location.  Update after change to queue_elem.\n\t(process_define_predicate): Replace lineno argument with a\n\tfile_location and use error_at for error reporting.  Update\n\tafter above changes.\n\t(process_rtx): Likewise.\n\t(subst_pattern_match): Likewise.\n\t(get_alternatives_number): Likewise.\n\t(alter_predicate_for_insn): Likewise.\n\t(rtx_handle_directive): Likewise.\n\t(is_predicable): Update after above changes, using error_at rather\n\tthan error_with_line.\n\t(has_subst_attribute): Likewise.\n\t(identify_predicable_attribute): Likewise.\n\t(alter_attrs_for_subst_insn): Likewise.\n\t(process_one_cond_exec): Likewise.\n\t(process_substs_on_one_elem): Likewise.\n\t(process_define_subst): Likewise.\n\t(check_define_attr_duplicates): Likewise.\n\t(read_md_rtx): Update after change to queue_elem.\n\nFrom-SVN: r225879", "tree": {"sha": "a86b33cb3517b785698d786a2d59d9caef97b308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a86b33cb3517b785698d786a2d59d9caef97b308"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc4726077d61d3c73edf2e909a397d78ec447540", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc4726077d61d3c73edf2e909a397d78ec447540", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc4726077d61d3c73edf2e909a397d78ec447540", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc4726077d61d3c73edf2e909a397d78ec447540/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e2e5efadd0147f249be5bd4e32f91c9e571824b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2e5efadd0147f249be5bd4e32f91c9e571824b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2e5efadd0147f249be5bd4e32f91c9e571824b"}], "stats": {"total": 311, "additions": 182, "deletions": 129}, "files": [{"sha": "1a11667792e748a4ed1bbd6f5bf12381f5f97b2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4726077d61d3c73edf2e909a397d78ec447540/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4726077d61d3c73edf2e909a397d78ec447540/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc4726077d61d3c73edf2e909a397d78ec447540", "patch": "@@ -1,3 +1,42 @@\n+2015-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* read-md.h (file_location): New structure.\n+\t(directive_handler_t): Take a file_location rather than a line number.\n+\t(message_at, error_at): Declare.\n+\t(read_skip_construct): Delete.\n+\t* read-md.c (message_with_line_1): Replace with...\n+\t(message_at_1): ...this new function.\n+\t(message_at, error_at): New functions.\n+\t(message_with_line, error_with_line): Update to use message_at_1.\n+\t(handle_enum): Take a file_location rather than a line number\n+\tand use error_at for error reporting.\n+\t(handle_include): Likewise.\n+\t(read_skip_construct): Likewise.  Make static.\n+\t(handle_file): Update after above changes.  Pass a file_location\n+\trather than a line number to handle_directive.\n+\t* gensupport.c (queue_elem): Replace separate filename and lineno\n+\twith a file_location.\n+\t(queue_pattern): Replace filename and lineno arguments with a\n+\tfile_location.  Update after change to queue_elem.\n+\t(process_define_predicate): Replace lineno argument with a\n+\tfile_location and use error_at for error reporting.  Update\n+\tafter above changes.\n+\t(process_rtx): Likewise.\n+\t(subst_pattern_match): Likewise.\n+\t(get_alternatives_number): Likewise.\n+\t(alter_predicate_for_insn): Likewise.\n+\t(rtx_handle_directive): Likewise.\n+\t(is_predicable): Update after above changes, using error_at rather\n+\tthan error_with_line.\n+\t(has_subst_attribute): Likewise.\n+\t(identify_predicable_attribute): Likewise.\n+\t(alter_attrs_for_subst_insn): Likewise.\n+\t(process_one_cond_exec): Likewise.\n+\t(process_substs_on_one_elem): Likewise.\n+\t(process_define_subst): Likewise.\n+\t(check_define_attr_duplicates): Likewise.\n+\t(read_md_rtx): Update after change to queue_elem.\n+\n 2015-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* genoutput.c (next_index_number): Delete."}, {"sha": "8ec7a22b314623adccdf456c729c598d9bafce59", "filename": "gcc/gensupport.c", "status": "modified", "additions": 81, "deletions": 105, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4726077d61d3c73edf2e909a397d78ec447540/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4726077d61d3c73edf2e909a397d78ec447540/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=cc4726077d61d3c73edf2e909a397d78ec447540", "patch": "@@ -65,8 +65,7 @@ static htab_t condition_table;\n struct queue_elem\n {\n   rtx data;\n-  const char *filename;\n-  int lineno;\n+  file_location loc;\n   struct queue_elem *next;\n   /* In a DEFINE_INSN that came from a DEFINE_INSN_AND_SPLIT, SPLIT\n      points to the generated DEFINE_SPLIT.  */\n@@ -91,17 +90,12 @@ static struct queue_elem **other_tail = &other_queue;\n static struct queue_elem *define_subst_attr_queue;\n static struct queue_elem **define_subst_attr_tail = &define_subst_attr_queue;\n \n-static struct queue_elem *queue_pattern (rtx, struct queue_elem ***,\n-\t\t\t\t\t const char *, int);\n-\n static void remove_constraints (rtx);\n-static void process_rtx (rtx, int);\n \n static int is_predicable (struct queue_elem *);\n static void identify_predicable_attribute (void);\n static int n_alternatives (const char *);\n static void collect_insn_data (rtx, int *, int *);\n-static rtx alter_predicate_for_insn (rtx, int, int, int);\n static const char *alter_test_for_insn (struct queue_elem *,\n \t\t\t\t\tstruct queue_elem *);\n static char *shift_output_template (char *, const char *, int);\n@@ -114,8 +108,6 @@ static void init_predicate_table (void);\n static void record_insn_name (int, const char *);\n \n static bool has_subst_attribute (struct queue_elem *, struct queue_elem *);\n-static bool subst_pattern_match (rtx, rtx, int);\n-static int get_alternatives_number (rtx, int *, int);\n static const char * alter_output_for_subst_insn (rtx, int);\n static void alter_attrs_for_subst_insn (struct queue_elem *, int);\n static void process_substs_on_one_elem (struct queue_elem *,\n@@ -363,22 +355,21 @@ valid_predicate_name_p (const char *name)\n   return true;\n }\n \n-/* Process define_predicate directive DESC, which appears on line number\n-   LINENO.  Compute the set of codes that can be matched, and record this\n-   as a known predicate.  */\n+/* Process define_predicate directive DESC, which appears at location LOC.\n+   Compute the set of codes that can be matched, and record this as a known\n+   predicate.  */\n \n static void\n-process_define_predicate (rtx desc, int lineno)\n+process_define_predicate (rtx desc, file_location loc)\n {\n   struct pred_data *pred;\n   char codes[NUM_RTX_CODE];\n   int i;\n \n   if (!valid_predicate_name_p (XSTR (desc, 0)))\n     {\n-      error_with_line (lineno,\n-\t\t       \"%s: predicate name must be a valid C function name\",\n-\t\t       XSTR (desc, 0));\n+      error_at (loc, \"%s: predicate name must be a valid C function name\",\n+\t\tXSTR (desc, 0));\n       return;\n     }\n \n@@ -389,7 +380,7 @@ process_define_predicate (rtx desc, int lineno)\n   if (GET_CODE (desc) == DEFINE_SPECIAL_PREDICATE)\n     pred->special = true;\n \n-  compute_test_codes (XEXP (desc, 1), lineno, codes);\n+  compute_test_codes (XEXP (desc, 1), loc.lineno, codes);\n \n   for (i = 0; i < NUM_RTX_CODE; i++)\n     if (codes[i] != N)\n@@ -406,12 +397,11 @@ process_define_predicate (rtx desc, int lineno)\n \n static struct queue_elem *\n queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n-\t       const char *filename, int lineno)\n+\t       file_location loc)\n {\n   struct queue_elem *e = XNEW (struct queue_elem);\n   e->data = pattern;\n-  e->filename = filename;\n-  e->lineno = lineno;\n+  e->loc = loc;\n   e->next = NULL;\n   e->split = NULL;\n   **list_tail = e;\n@@ -452,8 +442,7 @@ add_define_attr (const char *name)\n   XEXP (t1, 2) = rtx_alloc (CONST_STRING);\n   XSTR (XEXP (t1, 2), 0) = \"yes\";\n   e->data = t1;\n-  e->filename = \"built-in\";\n-  e->lineno = -1;\n+  e->loc = file_location (\"built-in\", -1);\n   e->next = define_attr_queue;\n   define_attr_queue = e;\n \n@@ -495,41 +484,41 @@ remove_constraints (rtx part)\n /* Process a top level rtx in some way, queuing as appropriate.  */\n \n static void\n-process_rtx (rtx desc, int lineno)\n+process_rtx (rtx desc, file_location loc)\n {\n   switch (GET_CODE (desc))\n     {\n     case DEFINE_INSN:\n-      queue_pattern (desc, &define_insn_tail, read_md_filename, lineno);\n+      queue_pattern (desc, &define_insn_tail, loc);\n       break;\n \n     case DEFINE_COND_EXEC:\n-      queue_pattern (desc, &define_cond_exec_tail, read_md_filename, lineno);\n+      queue_pattern (desc, &define_cond_exec_tail, loc);\n       break;\n \n     case DEFINE_SUBST:\n-      queue_pattern (desc, &define_subst_tail, read_md_filename, lineno);\n+      queue_pattern (desc, &define_subst_tail, loc);\n       break;\n \n     case DEFINE_SUBST_ATTR:\n-      queue_pattern (desc, &define_subst_attr_tail, read_md_filename, lineno);\n+      queue_pattern (desc, &define_subst_attr_tail, loc);\n       break;\n \n     case DEFINE_ATTR:\n     case DEFINE_ENUM_ATTR:\n-      queue_pattern (desc, &define_attr_tail, read_md_filename, lineno);\n+      queue_pattern (desc, &define_attr_tail, loc);\n       break;\n \n     case DEFINE_PREDICATE:\n     case DEFINE_SPECIAL_PREDICATE:\n-      process_define_predicate (desc, lineno);\n+      process_define_predicate (desc, loc);\n       /* Fall through.  */\n \n     case DEFINE_CONSTRAINT:\n     case DEFINE_REGISTER_CONSTRAINT:\n     case DEFINE_MEMORY_CONSTRAINT:\n     case DEFINE_ADDRESS_CONSTRAINT:\n-      queue_pattern (desc, &define_pred_tail, read_md_filename, lineno);\n+      queue_pattern (desc, &define_pred_tail, loc);\n       break;\n \n     case DEFINE_INSN_AND_SPLIT:\n@@ -570,17 +559,14 @@ process_rtx (rtx desc, int lineno)\n \tXVEC (desc, 4) = attr;\n \n \t/* Queue them.  */\n-\tinsn_elem\n-\t  = queue_pattern (desc, &define_insn_tail, read_md_filename,\n-\t\t\t   lineno);\n-\tsplit_elem\n-\t  = queue_pattern (split, &other_tail, read_md_filename, lineno);\n+\tinsn_elem = queue_pattern (desc, &define_insn_tail, loc);\n+\tsplit_elem = queue_pattern (split, &other_tail, loc);\n \tinsn_elem->split = split_elem;\n \tbreak;\n       }\n \n     default:\n-      queue_pattern (desc, &other_tail, read_md_filename, lineno);\n+      queue_pattern (desc, &other_tail, loc);\n       break;\n     }\n }\n@@ -614,8 +600,7 @@ is_predicable (struct queue_elem *elem)\n \tcase SET_ATTR_ALTERNATIVE:\n \t  if (strcmp (XSTR (sub, 0), \"predicable\") == 0)\n \t    {\n-\t      error_with_line (elem->lineno,\n-\t\t\t       \"multiple alternatives for `predicable'\");\n+\t      error_at (elem->loc, \"multiple alternatives for `predicable'\");\n \t      return 0;\n \t    }\n \t  break;\n@@ -634,8 +619,7 @@ is_predicable (struct queue_elem *elem)\n \t  /* ??? It would be possible to handle this if we really tried.\n \t     It's not easy though, and I'm not going to bother until it\n \t     really proves necessary.  */\n-\t  error_with_line (elem->lineno,\n-\t\t\t   \"non-constant value for `predicable'\");\n+\t  error_at (elem->loc, \"non-constant value for `predicable'\");\n \t  return 0;\n \n \tdefault:\n@@ -655,8 +639,7 @@ is_predicable (struct queue_elem *elem)\n   if (strcmp (value, predicable_false) == 0)\n     return 0;\n \n-  error_with_line (elem->lineno,\n-\t\t   \"unknown value `%s' for `predicable' attribute\", value);\n+  error_at (elem->loc, \"unknown value `%s' for `predicable' attribute\", value);\n   return 0;\n }\n \n@@ -728,15 +711,13 @@ has_subst_attribute (struct queue_elem *elem, struct queue_elem *subst_elem)\n \t  /* Only (set_attr \"subst\" \"yes/no\") and\n \t\t  (set (attr \"subst\" (const_string \"yes/no\")))\n \t     are currently allowed.  */\n-\t  error_with_line (elem->lineno,\n-\t\t\t   \"unsupported value for `%s'\", subst_name);\n+\t  error_at (elem->loc, \"unsupported value for `%s'\", subst_name);\n \t  return false;\n \n \tcase SET_ATTR_ALTERNATIVE:\n-\t  error_with_line (elem->lineno,\n-\t\t\t   \"%s: `set_attr_alternative' is unsupported by \"\n-\t\t\t   \"`define_subst'\",\n-\t\t\t   XSTR (elem->data, 0));\n+\t  error_at (elem->loc,\n+\t\t    \"%s: `set_attr_alternative' is unsupported by \"\n+\t\t    \"`define_subst'\", XSTR (elem->data, 0));\n \t  return false;\n \n \n@@ -753,16 +734,16 @@ has_subst_attribute (struct queue_elem *elem, struct queue_elem *subst_elem)\n   if (strcmp (value, subst_false) == 0)\n     return false;\n \n-  error_with_line (elem->lineno,\n-\t\t   \"unknown value `%s' for `%s' attribute\", value, subst_name);\n+  error_at (elem->loc, \"unknown value `%s' for `%s' attribute\",\n+\t    value, subst_name);\n   return false;\n }\n \n /* Compare RTL-template of original define_insn X to input RTL-template of\n    define_subst PT.  Return 1 if the templates match, 0 otherwise.\n    During the comparison, the routine also fills global_array OPERAND_DATA.  */\n static bool\n-subst_pattern_match (rtx x, rtx pt, int lineno)\n+subst_pattern_match (rtx x, rtx pt, file_location loc)\n {\n   RTX_CODE code, code_pt;\n   int i, j, len;\n@@ -837,7 +818,7 @@ subst_pattern_match (rtx x, rtx pt, int lineno)\n \t    return false;\n \t  for (j = 0; j < XVECLEN (pt, 2); j++)\n \t    if (!subst_pattern_match (XVECEXP (x, x_vecexp_pos, j),\n-\t\t\t\t      XVECEXP (pt, 2, j), lineno))\n+\t\t\t\t      XVECEXP (pt, 2, j), loc))\n \t      return false;\n \t}\n \n@@ -851,7 +832,7 @@ subst_pattern_match (rtx x, rtx pt, int lineno)\n \t  if (GET_RTX_LENGTH (code) != XVECLEN (pt, 2))\n \t    return false;\n \t  for (j = 0; j < XVECLEN (pt, 2); j++)\n-\t    if (!subst_pattern_match (XEXP (x, j), XVECEXP (pt, 2, j), lineno))\n+\t    if (!subst_pattern_match (XEXP (x, j), XVECEXP (pt, 2, j), loc))\n \t      return false;\n \t}\n \n@@ -870,8 +851,8 @@ subst_pattern_match (rtx x, rtx pt, int lineno)\n       /* Currently interface for these constructions isn't defined -\n \t probably they aren't needed in input template of define_subst at all.\n \t So, for now their usage in define_subst is forbidden.  */\n-      error_with_line (lineno, \"%s cannot be used in define_subst\",\n-\t\t       GET_RTX_NAME (code_pt));\n+      error_at (loc, \"%s cannot be used in define_subst\",\n+\t\tGET_RTX_NAME (code_pt));\n     }\n \n   gcc_assert (code != MATCH_PAR_DUP\n@@ -900,16 +881,16 @@ subst_pattern_match (rtx x, rtx pt, int lineno)\n \t  continue;\n \n \tcase 'e': case 'u':\n-\t  if (!subst_pattern_match (XEXP (x, i), XEXP (pt, i), lineno))\n+\t  if (!subst_pattern_match (XEXP (x, i), XEXP (pt, i), loc))\n \t    return false;\n \t  break;\n \tcase 'E':\n \t  {\n \t    if (XVECLEN (x, i) != XVECLEN (pt, i))\n \t      return false;\n \t    for (j = 0; j < XVECLEN (pt, i); j++)\n-\t      if (!subst_pattern_match (XVECEXP (x, i, j), XVECEXP (pt, i, j),\n-\t\t\t\t\tlineno))\n+\t      if (!subst_pattern_match (XVECEXP (x, i, j),\n+\t\t\t\t\tXVECEXP (pt, i, j), loc))\n \t\treturn false;\n \t    break;\n \t  }\n@@ -936,8 +917,8 @@ identify_predicable_attribute (void)\n     if (strcmp (XSTR (elem->data, 0), \"predicable\") == 0)\n       goto found;\n \n-  error_with_line (define_cond_exec_queue->lineno,\n-\t\t   \"attribute `predicable' not defined\");\n+  error_at (define_cond_exec_queue->loc,\n+\t    \"attribute `predicable' not defined\");\n   return;\n \n  found:\n@@ -946,7 +927,7 @@ identify_predicable_attribute (void)\n   p_true = strchr (p_false, ',');\n   if (p_true == NULL || strchr (++p_true, ',') != NULL)\n     {\n-      error_with_line (elem->lineno, \"attribute `predicable' is not a boolean\");\n+      error_at (elem->loc, \"attribute `predicable' is not a boolean\");\n       free (p_false);\n       return;\n     }\n@@ -962,13 +943,13 @@ identify_predicable_attribute (void)\n       break;\n \n     case CONST:\n-      error_with_line (elem->lineno, \"attribute `predicable' cannot be const\");\n+      error_at (elem->loc, \"attribute `predicable' cannot be const\");\n       free (p_false);\n       return;\n \n     default:\n-      error_with_line (elem->lineno,\n-\t\t       \"attribute `predicable' must have a constant default\");\n+      error_at (elem->loc,\n+\t\t\"attribute `predicable' must have a constant default\");\n       free (p_false);\n       return;\n     }\n@@ -979,8 +960,8 @@ identify_predicable_attribute (void)\n     predicable_default = 0;\n   else\n     {\n-      error_with_line (elem->lineno,\n-\t\t       \"unknown value `%s' for `predicable' attribute\", value);\n+      error_at (elem->loc, \"unknown value `%s' for `predicable' attribute\",\n+\t\tvalue);\n       free (p_false);\n     }\n }\n@@ -1004,9 +985,9 @@ n_alternatives (const char *s)\n    with different number of alternatives, error is emitted, and the\n    routine returns 0.  If all match_operands in PATTERN have the same\n    number of alternatives, it's stored in N_ALT, and the routine returns 1.\n-   Argument LINENO is used in when the error is emitted.  */\n+   LOC is the location of PATTERN, for error reporting.  */\n static int\n-get_alternatives_number (rtx pattern, int *n_alt, int lineno)\n+get_alternatives_number (rtx pattern, int *n_alt, file_location loc)\n {\n   const char *fmt;\n   enum rtx_code code;\n@@ -1029,9 +1010,8 @@ get_alternatives_number (rtx pattern, int *n_alt, int lineno)\n \n       else if (i && i != *n_alt)\n \t{\n-\t  error_with_line (lineno,\n-\t\t\t   \"wrong number of alternatives in operand %d\",\n-\t\t\t   XINT (pattern, 0));\n+\t  error_at (loc, \"wrong number of alternatives in operand %d\",\n+\t\t    XINT (pattern, 0));\n \t  return 0;\n \t}\n \n@@ -1046,8 +1026,8 @@ get_alternatives_number (rtx pattern, int *n_alt, int lineno)\n       switch (fmt[i])\n \t{\n \tcase 'e': case 'u':\n-\t  if (!get_alternatives_number (XEXP (pattern, i), n_alt, lineno))\n-\t\treturn 0;\n+\t  if (!get_alternatives_number (XEXP (pattern, i), n_alt, loc))\n+\t    return 0;\n \t  break;\n \n \tcase 'V':\n@@ -1056,9 +1036,8 @@ get_alternatives_number (rtx pattern, int *n_alt, int lineno)\n \n \tcase 'E':\n \t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n-\t    if (!get_alternatives_number (XVECEXP (pattern, i, j),\n-\t\t\t\t\t  n_alt, lineno))\n-\t\treturn 0;\n+\t    if (!get_alternatives_number (XVECEXP (pattern, i, j), n_alt, loc))\n+\t      return 0;\n \t  break;\n \n \tcase 'i': case 'r': case 'w': case '0': case 's': case 'S': case 'T':\n@@ -1130,7 +1109,8 @@ collect_insn_data (rtx pattern, int *palt, int *pmax)\n }\n \n static rtx\n-alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n+alter_predicate_for_insn (rtx pattern, int alt, int max_op,\n+\t\t\t  file_location loc)\n {\n   const char *fmt;\n   enum rtx_code code;\n@@ -1145,8 +1125,8 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n \n \tif (n_alternatives (c) != 1)\n \t  {\n-\t    error_with_line (lineno, \"too many alternatives for operand %d\",\n-\t\t\t     XINT (pattern, 0));\n+\t    error_at (loc, \"too many alternatives for operand %d\",\n+\t\t      XINT (pattern, 0));\n \t    return NULL;\n \t  }\n \n@@ -1188,8 +1168,7 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n       switch (fmt[i])\n \t{\n \tcase 'e': case 'u':\n-\t  r = alter_predicate_for_insn (XEXP (pattern, i), alt,\n-\t\t\t\t\tmax_op, lineno);\n+\t  r = alter_predicate_for_insn (XEXP (pattern, i), alt, max_op, loc);\n \t  if (r == NULL)\n \t    return r;\n \t  break;\n@@ -1198,7 +1177,7 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n \t  for (j = XVECLEN (pattern, i) - 1; j >= 0; --j)\n \t    {\n \t      r = alter_predicate_for_insn (XVECEXP (pattern, i, j),\n-\t\t\t\t\t    alt, max_op, lineno);\n+\t\t\t\t\t    alt, max_op, loc);\n \t      if (r == NULL)\n \t\treturn r;\n \t    }\n@@ -1449,10 +1428,10 @@ alter_attrs_for_subst_insn (struct queue_elem * elem, int n_dup)\n \n \tcase SET_ATTR_ALTERNATIVE:\n \tcase SET:\n-\t  error_with_line (elem->lineno,\n-\t\t\t   \"%s: `define_subst' does not support attributes \"\n-\t\t\t   \"assigned by `set' and `set_attr_alternative'\",\n-\t\t\t   XSTR (elem->data, 0));\n+\t  error_at (elem->loc,\n+\t\t    \"%s: `define_subst' does not support attributes \"\n+\t\t    \"assigned by `set' and `set_attr_alternative'\",\n+\t\t    XSTR (elem->data, 0));\n \t  return;\n \n \tdefault:\n@@ -1702,13 +1681,13 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n \n       if (XVECLEN (ce_elem->data, 0) != 1)\n \t{\n-\t  error_with_line (ce_elem->lineno, \"too many patterns in predicate\");\n+\t  error_at (ce_elem->loc, \"too many patterns in predicate\");\n \t  return;\n \t}\n \n       pred = copy_rtx (XVECEXP (ce_elem->data, 0, 0));\n       pred = alter_predicate_for_insn (pred, alternatives, max_operand,\n-\t\t\t\t       ce_elem->lineno);\n+\t\t\t\t       ce_elem->loc);\n       if (pred == NULL)\n \treturn;\n \n@@ -1754,8 +1733,7 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n \t patterns into the define_insn chain just after their generator\n \t is something we'll have to experiment with.  */\n \n-      queue_pattern (insn, &other_tail, insn_elem->filename,\n-\t\t     insn_elem->lineno);\n+      queue_pattern (insn, &other_tail, insn_elem->loc);\n \n       if (!insn_elem->split)\n \tcontinue;\n@@ -1779,8 +1757,7 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n \t  XVECEXP (split, 2, i) = pattern;\n \t}\n       /* Add the new split to the queue.  */\n-      queue_pattern (split, &other_tail, read_md_filename,\n-\t\t     insn_elem->split->lineno);\n+      queue_pattern (split, &other_tail, insn_elem->split->loc);\n     }\n }\n \n@@ -1819,14 +1796,14 @@ process_substs_on_one_elem (struct queue_elem *elem,\n \t{\n \t  if (!subst_pattern_match (XVECEXP (elem->data, 1, j),\n \t\t\t\t    XVECEXP (subst_elem->data, 1, j),\n-\t\t\t\t    subst_elem->lineno))\n+\t\t\t\t    subst_elem->loc))\n \t    {\n \t      patterns_match = 0;\n \t      break;\n \t    }\n \n \t  if (!get_alternatives_number (XVECEXP (elem->data, 1, j),\n-\t\t\t\t\t&alternatives, subst_elem->lineno))\n+\t\t\t\t\t&alternatives, subst_elem->loc))\n \t    {\n \t      patterns_match = 0;\n \t      break;\n@@ -1839,7 +1816,7 @@ process_substs_on_one_elem (struct queue_elem *elem,\n \t{\n \t  if (!get_alternatives_number (XVECEXP (subst_elem->data, 3, j),\n \t\t\t\t\t&alternatives_subst,\n-\t\t\t\t\tsubst_elem->lineno))\n+\t\t\t\t\tsubst_elem->loc))\n \t    {\n \t      patterns_match = 0;\n \t      break;\n@@ -2224,10 +2201,10 @@ process_define_subst (void)\n \tif (strcmp (XSTR (elem->data, 0), XSTR (elem_attr->data, 1)) == 0)\n \t    goto found;\n \n-      error_with_line (elem->lineno,\n-\t\t       \"%s: `define_subst' must have at least one \"\n-\t\t       \"corresponding `define_subst_attr'\",\n-\t\t       XSTR (elem->data, 0));\n+      error_at (elem->loc,\n+\t\t\"%s: `define_subst' must have at least one \"\n+\t\t\"corresponding `define_subst_attr'\",\n+\t\tXSTR (elem->data, 0));\n       return;\n \n       found:\n@@ -2247,7 +2224,7 @@ process_define_subst (void)\n /* A read_md_files callback for reading an rtx.  */\n \n static void\n-rtx_handle_directive (int lineno, const char *rtx_name)\n+rtx_handle_directive (file_location loc, const char *rtx_name)\n {\n   auto_vec<rtx, 32> subrtxs;\n   if (!read_rtx (rtx_name, &subrtxs))\n@@ -2256,7 +2233,7 @@ rtx_handle_directive (int lineno, const char *rtx_name)\n   rtx x;\n   unsigned int i;\n   FOR_EACH_VEC_ELT (subrtxs, i, x)\n-    process_rtx (x, lineno);\n+    process_rtx (x, loc);\n }\n \n /* Comparison function for the mnemonic hash table.  */\n@@ -2506,8 +2483,7 @@ check_define_attr_duplicates ()\n       /* Duplicate.  */\n       if (*slot)\n \t{\n-\t  error_with_line (elem->lineno, \"redefinition of attribute '%s'\",\n-\t\t\t   attr_name);\n+\t  error_at (elem->loc, \"redefinition of attribute '%s'\", attr_name);\n \t  htab_delete (attr_htab);\n \t  return;\n \t}\n@@ -2588,8 +2564,8 @@ read_md_rtx (int *lineno, int *seqnr)\n   elem = *queue;\n   *queue = elem->next;\n   desc = elem->data;\n-  read_md_filename = elem->filename;\n-  *lineno = elem->lineno;\n+  read_md_filename = elem->loc.filename;\n+  *lineno = elem->loc.lineno;\n   *seqnr = sequence_num;\n \n   free (elem);"}, {"sha": "d93b11687e5ebaca3dde97dcd04c9a2cc7148997", "filename": "gcc/read-md.c", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4726077d61d3c73edf2e909a397d78ec447540/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4726077d61d3c73edf2e909a397d78ec447540/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=cc4726077d61d3c73edf2e909a397d78ec447540", "patch": "@@ -245,13 +245,38 @@ print_c_condition (const char *cond)\n    of the current MD file.  */\n \n static void ATTRIBUTE_PRINTF(2,0)\n-message_with_line_1 (int lineno, const char *msg, va_list ap)\n+message_at_1 (file_location loc, const char *msg, va_list ap)\n {\n-  fprintf (stderr, \"%s:%d: \", read_md_filename, lineno);\n+  fprintf (stderr, \"%s:%d: \", loc.filename, loc.lineno);\n   vfprintf (stderr, msg, ap);\n   fputc ('\\n', stderr);\n }\n \n+/* A printf-like function for reporting a message against location LOC.  */\n+\n+void\n+message_at (file_location loc, const char *msg, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, msg);\n+  message_at_1 (loc, msg, ap);\n+  va_end (ap);\n+}\n+\n+/* Like message_at, but treat the condition as an error.  */\n+\n+void\n+error_at (file_location loc, const char *msg, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, msg);\n+  message_at_1 (loc, msg, ap);\n+  va_end (ap);\n+  have_error = 1;\n+}\n+\n /* A printf-like function for reporting an error against line LINENO\n    in the current MD file.  */\n \n@@ -261,7 +286,7 @@ message_with_line (int lineno, const char *msg, ...)\n   va_list ap;\n \n   va_start (ap, msg);\n-  message_with_line_1 (lineno, msg, ap);\n+  message_at_1 (file_location (read_md_filename, lineno), msg, ap);\n   va_end (ap);\n }\n \n@@ -273,7 +298,7 @@ error_with_line (int lineno, const char *msg, ...)\n   va_list ap;\n \n   va_start (ap, msg);\n-  message_with_line_1 (lineno, msg, ap);\n+  message_at_1 (file_location (read_md_filename, lineno), msg, ap);\n   va_end (ap);\n   have_error = 1;\n }\n@@ -593,8 +618,8 @@ read_string (int star_if_braced)\n /* Skip the rest of a construct that started at line LINENO and that\n    is currently nested by DEPTH levels of parentheses.  */\n \n-void\n-read_skip_construct (int depth, int lineno)\n+static void\n+read_skip_construct (int depth, file_location loc)\n {\n   struct md_name name;\n   int c;\n@@ -604,7 +629,7 @@ read_skip_construct (int depth, int lineno)\n       c = read_skip_spaces ();\n       if (c == EOF)\n \t{\n-\t  error_with_line (lineno, \"unterminated construct\");\n+\t  error_at (loc, \"unterminated construct\");\n \t  exit (1);\n \t}\n       switch (c)\n@@ -794,7 +819,7 @@ md_decimal_string (int number)\n    directive is a define_enum rather than a define_c_enum.  */\n \n static void\n-handle_enum (int lineno, bool md_p)\n+handle_enum (file_location loc, bool md_p)\n {\n   char *enum_name, *value_name;\n   struct md_name name;\n@@ -809,8 +834,8 @@ handle_enum (int lineno, bool md_p)\n     {\n       def = (struct enum_type *) *slot;\n       if (def->md_p != md_p)\n-\terror_with_line (lineno, \"redefining `%s' as a different type of enum\",\n-\t\t\t enum_name);\n+\terror_at (loc, \"redefining `%s' as a different type of enum\",\n+\t\t  enum_name);\n     }\n   else\n     {\n@@ -831,7 +856,7 @@ handle_enum (int lineno, bool md_p)\n     {\n       if (c == EOF)\n \t{\n-\t  error_with_line (lineno, \"unterminated construct\");\n+\t  error_at (loc, \"unterminated construct\");\n \t  exit (1);\n \t}\n       unread_char (c);\n@@ -883,7 +908,7 @@ traverse_enum_types (htab_trav callback, void *info)\n    which the \"include\" occurred.  */\n \n static void\n-handle_include (int lineno, directive_handler_t handle_directive)\n+handle_include (file_location loc, directive_handler_t handle_directive)\n {\n   const char *filename;\n   const char *old_filename;\n@@ -926,7 +951,7 @@ handle_include (int lineno, directive_handler_t handle_directive)\n   if (input_file == NULL)\n     {\n       free (pathname);\n-      error_with_line (lineno, \"include file `%s' not found\", filename);\n+      error_at (loc, \"include file `%s' not found\", filename);\n       return;\n     }\n \n@@ -961,28 +986,28 @@ static void\n handle_file (directive_handler_t handle_directive)\n {\n   struct md_name directive;\n-  int c, lineno;\n+  int c;\n \n   read_md_lineno = 1;\n   while ((c = read_skip_spaces ()) != EOF)\n     {\n-      lineno = read_md_lineno;\n+      file_location loc (read_md_filename, read_md_lineno);\n       if (c != '(')\n \tfatal_expected_char ('(', c);\n \n       read_name (&directive);\n       if (strcmp (directive.string, \"define_constants\") == 0)\n \thandle_constants ();\n       else if (strcmp (directive.string, \"define_enum\") == 0)\n-\thandle_enum (lineno, true);\n+\thandle_enum (loc, true);\n       else if (strcmp (directive.string, \"define_c_enum\") == 0)\n-\thandle_enum (lineno, false);\n+\thandle_enum (loc, false);\n       else if (strcmp (directive.string, \"include\") == 0)\n-\thandle_include (lineno, handle_directive);\n+\thandle_include (loc, handle_directive);\n       else if (handle_directive)\n-\thandle_directive (lineno, directive.string);\n+\thandle_directive (loc, directive.string);\n       else\n-\tread_skip_construct (1, lineno);\n+\tread_skip_construct (1, loc);\n \n       c = read_skip_spaces ();\n       if (c != ')')"}, {"sha": "54d0abe3e4a78713195a7d56358659b19a441bb2", "filename": "gcc/read-md.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4726077d61d3c73edf2e909a397d78ec447540/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4726077d61d3c73edf2e909a397d78ec447540/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=cc4726077d61d3c73edf2e909a397d78ec447540", "patch": "@@ -22,6 +22,18 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"obstack.h\"\n \n+/* Records a position in the file.  */\n+struct file_location {\n+  file_location () {}\n+  file_location (const char *, int);\n+\n+  const char *filename;\n+  int lineno;\n+};\n+\n+inline file_location::file_location (const char *filename_in, int lineno_in)\n+  : filename (filename_in), lineno (lineno_in) {}\n+\n /* Holds one symbol or number in the .md file.  */\n struct md_name {\n   /* The name as it appeared in the .md file.  Names are syntactically\n@@ -79,10 +91,10 @@ struct enum_type {\n };\n \n /* A callback that handles a single .md-file directive, up to but not\n-   including the closing ')'.  It takes two arguments: the line number on\n-   which the directive started, and the name of the directive.  The next\n+   including the closing ')'.  It takes two arguments: the file position\n+   at which the directive started, and the name of the directive.  The next\n    unread character is the optional space after the directive name.  */\n-typedef void (*directive_handler_t) (int, const char *);\n+typedef void (*directive_handler_t) (file_location, const char *);\n \n extern const char *in_fname;\n extern FILE *read_md_file;\n@@ -122,6 +134,8 @@ extern void fprint_md_ptr_loc (FILE *, const void *);\n extern const char *join_c_conditions (const char *, const char *);\n extern void print_c_condition (const char *);\n extern void fprint_c_condition (FILE *, const char *);\n+extern void message_at (file_location, const char *, ...) ATTRIBUTE_PRINTF_2;\n+extern void error_at (file_location, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void message_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void error_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void fatal_with_file_and_line (const char *, ...)\n@@ -131,7 +145,6 @@ extern int read_skip_spaces (void);\n extern void read_name (struct md_name *);\n extern char *read_quoted_string (void);\n extern char *read_string (int);\n-extern void read_skip_construct (int, int);\n extern int n_comma_elts (const char *);\n extern const char *scan_comma_elt (const char **);\n extern void upcase_string (char *);"}]}