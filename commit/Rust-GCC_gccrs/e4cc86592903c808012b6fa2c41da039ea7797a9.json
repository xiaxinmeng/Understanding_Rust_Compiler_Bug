{"sha": "e4cc86592903c808012b6fa2c41da039ea7797a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRjYzg2NTkyOTAzYzgwODAxMmI2ZmEyYzQxZGEwMzllYTc3OTdhOQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@purist.soma.redhat.com", "date": "2000-09-15T07:06:46Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-09-15T07:06:46Z"}, "message": "locale.cc (locale::name()): Implement.\n\n\n2000-09-14  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* src/locale.cc (locale::name()): Implement.\n\t(_Impl(size_t __numfacets, size_t __refs, bool __namep = false,\n\tstring __name = \"*\")): Change signature.\n\t(locale::classic): Initialize the \"C\" locale as a named locale.\n\t* bits/localefwd.h (locale): Change _M_num_references to\n\t_M_references. Eliminate _M_cached_name_ok. Rename _M_cached_name\n\tto _M_name.\n\t* bits/localefwd.h: Tweaks.\n\t* src/localename.cc: Tweaks.\n\t* testsuite/22_locale/ctor_copy_dtor.cc (test01): Add tests.\n\t(test01): Fix.\n\n\t* bits/basic_string.h: Consistency check, change _M_state ->\n\t_M_references.\n\nFrom-SVN: r36426", "tree": {"sha": "3eb665cfaeb7c4dbc09fba08e0af0ee02b14b527", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eb665cfaeb7c4dbc09fba08e0af0ee02b14b527"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4cc86592903c808012b6fa2c41da039ea7797a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4cc86592903c808012b6fa2c41da039ea7797a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4cc86592903c808012b6fa2c41da039ea7797a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4cc86592903c808012b6fa2c41da039ea7797a9/comments", "author": null, "committer": null, "parents": [{"sha": "ff94c747653bba7f146f1f8304286d82f17d8ae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff94c747653bba7f146f1f8304286d82f17d8ae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff94c747653bba7f146f1f8304286d82f17d8ae9"}], "stats": {"total": 579, "additions": 310, "deletions": 269}, "files": [{"sha": "5547d6cc6406d84a0669c7f7d34c24968fe36003", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e4cc86592903c808012b6fa2c41da039ea7797a9", "patch": "@@ -1,3 +1,20 @@\n+2000-09-14  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+\n+\t* src/locale.cc (locale::name()): Implement.\n+\t(_Impl(size_t __numfacets, size_t __refs, bool __namep = false,\n+\tstring __name = \"*\")): Change signature.\n+\t(locale::classic): Initialize the \"C\" locale as a named locale.\n+\t* bits/localefwd.h (locale): Change _M_num_references to\n+\t_M_references. Eliminate _M_cached_name_ok. Rename _M_cached_name\n+\tto _M_name.\n+\t* bits/localefwd.h: Tweaks.\n+\t* src/localename.cc: Tweaks.\n+\t* testsuite/22_locale/ctor_copy_dtor.cc (test01): Add tests.\n+\t(test01): Fix.\n+\n+\t* bits/basic_string.h: Consistency check, change _M_state ->\n+\t_M_references.\n+\n 2000-09-14  Brendan Kehoe  <brendan@zen.org>\n \n         * bits/string.tcc (_Rep::_S_max_size): Use typename for its size_type\n@@ -13,7 +30,7 @@\n \t* bits/std_ostream.h (ends(basic_ostream<_CharT, _Traits>& __os)):\n \tChange __eos to _S_eos.\n \t\n-2000-09-13  Benjamin Kosnik  <bkoz@redhat.com>\n+2000-09-13  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n \n \t* testsuite/22_locale/static_members.cc: New file.\n \t* testsuite/22_locale/ctor_copy_dtor.cc: New file."}, {"sha": "60795f7b72e5354bfbe232009a5b36aae093d201", "filename": "libstdc++-v3/bits/basic_string.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fbasic_string.h?ref=e4cc86592903c808012b6fa2c41da039ea7797a9", "patch": "@@ -105,7 +105,7 @@ namespace std {\n       //      _CharT() where the interface does not require it.\n       //   2. _M_capacity >= _M_length\n       //      Allocated memory is always _M_capacity + (1 * sizeof(_CharT)).\n-      //   3. _M_state has three states:\n+      //   3. _M_references has three states:\n       //      -1: leaked, one reference, no ref-copies allowed, non-const.\n       //       0: one reference, non-const.\n       //     n>0: n + 1 references, operations require a lock, const.\n@@ -136,23 +136,23 @@ namespace std {\n \n \tsize_type \t\t_M_length;\n \tsize_type \t\t_M_capacity;\n-\t_Atomic_word\t\t_M_state;\n+\t_Atomic_word\t\t_M_references;\n \t\n         bool\n \t_M_is_leaked() const\n-        { return _M_state < 0; }\n+        { return _M_references < 0; }\n \n         bool\n \t_M_is_shared() const\n-        { return _M_state > 0; }\n+        { return _M_references > 0; }\n \n         void\n \t_M_set_leaked() \n-        { _M_state = -1; }\n+        { _M_references = -1; }\n \n         void\n \t_M_set_sharable() \n-        { _M_state = 0; }\n+        { _M_references = 0; }\n \n \t_CharT* \n \t_M_refdata() throw()\n@@ -174,7 +174,7 @@ namespace std {\n \tvoid \n \t_M_dispose(const _Alloc& __a)\n \t{ \n-\t  if (__exchange_and_add(&_M_state, -1) <= 0)  \n+\t  if (__exchange_and_add(&_M_references, -1) <= 0)  \n \t    _M_destroy(__a); \n \t}  // XXX MT\n \n@@ -184,7 +184,7 @@ namespace std {\n \t_CharT* \n \t_M_refcopy() throw()\n \t{ \n-\t  __atomic_add(&_M_state, 1); \n+\t  __atomic_add(&_M_references, 1); \n \t  return _M_refdata(); \n \t}  // XXX MT\n "}, {"sha": "a0b4a26d2680348572f1f1ee134a88e6887020d3", "filename": "libstdc++-v3/bits/localefwd.h", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h?ref=e4cc86592903c808012b6fa2c41da039ea7797a9", "patch": "@@ -250,9 +250,9 @@ namespace std\n     explicit  \n     locale(const char* __std_name);\n \n-    locale(const locale& __other, const char* __std_name, category __cats);\n+    locale(const locale& __other, const char* __std_name, category __cat);\n \n-    locale(const locale& __other, const locale& __one, category __cats);\n+    locale(const locale& __other, const locale& __one, category __cat);\n \n     template<typename _Facet>\n       locale(const locale& __other, _Facet* __f);\n@@ -300,6 +300,8 @@ namespace std\n     // Current global reference locale\n     static _Impl* \t_S_global;  \n \n+    static const int \t_S_num_categories = _Count_ones<all>::_S_count;\n+\n     explicit \n     locale(_Impl*) throw();\n \n@@ -309,9 +311,6 @@ namespace std\n \n     static int  \n     _S_normalize_category(int);\n-\n-    static const int \n-    _S_num_categories = _Count_ones<all>::_S_count;\n   };\n \n \n@@ -337,12 +336,11 @@ namespace std\n \n   private:\n     // Data Members.\n-    size_t \t\t\t\t_M_num_references;\n+    size_t \t\t\t\t_M_references;\n     __vec_facet* \t\t\t_M_facets;\n     __vec_string* \t\t\t_M_category_names;\n     bool \t\t\t\t_M_has_name;\n-    bool \t\t\t\t_M_cached_name_ok;\n-    string \t\t\t\t_M_cached_name;\n+    string \t\t\t\t_M_name;\n     static const locale::id* const \t_S_id_collate[];\n     static const locale::id* const \t_S_id_ctype[];\n     static const locale::id* const \t_S_id_monetary[];\n@@ -353,12 +351,12 @@ namespace std\n \n     inline void \n     _M_add_reference() throw()\n-    { ++_M_num_references; }  // XXX MT\n+    { ++_M_references; }  // XXX MT\n \n     inline void \n     _M_remove_reference() throw()\n     {\n-      if (_M_num_references-- == 0)  // XXX MT\n+      if (_M_references-- == 0)  // XXX MT\n \t{\n \t  try { \n \t    delete this; \n@@ -370,7 +368,7 @@ namespace std\n \n     _Impl(const _Impl&, size_t __refs);\n     _Impl(const _Impl&, const string&, category, size_t __refs);\n-    _Impl(size_t __facets, size_t __refs);\n+    _Impl(size_t __facets, size_t __refs, bool __has_name, string __name);\n    ~_Impl() throw();\n \n     void \n@@ -409,7 +407,7 @@ namespace std\n     _M_construct_messages(const char*);\n \n     category \n-    _M_normalize_category_names(const string&, category __cats);\n+    _M_normalize_category_names(const string&, category __cat);\n   };\n \n   // class locale inlines, that need declaration of locale::_Imp\n@@ -428,6 +426,7 @@ namespace std\n       _M_impl = new _Impl(*__other._M_impl, 0);\n       _M_impl->_M_install_facet(&_Facet::id, __f);\n       _M_impl->_M_has_name = false;\n+      _M_impl->_M_name = \"*\";\n     }\n \n   locale::~locale() throw()\n@@ -447,7 +446,7 @@ namespace std\n     ~facet() {};\n \n   private:\n-    size_t _M_num_references;\n+    size_t _M_references;\n \n     void \n     _M_add_reference() throw();"}, {"sha": "c5f4fcf789f26b3ec07042ed39f5e4dd8fbf0bdb", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 61, "deletions": 130, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=e4cc86592903c808012b6fa2c41da039ea7797a9", "patch": "@@ -40,6 +40,7 @@\n #ifdef _GLIBCPP_USE_WCHAR_T  \n   #include <bits/std_cwctype.h>     // for towupper, etc.\n #endif\n+\n namespace std {\n \n   // Definitions for static const data members of locale.\n@@ -550,134 +551,50 @@ namespace std {\n     return __incl_prec;\n   }\n \n-  // locale::_Impl\n-  locale::_Impl::\n-  ~_Impl() throw()\n-  {\n-    std::vector<facet*>::iterator it = _M_facets->begin();\n-    for (; it != _M_facets->end(); ++it)\n-      (*it)->_M_remove_reference();\n-    delete _M_facets;\n-    delete _M_category_names;\n-  }\n \n-  locale::_Impl::\n-  _Impl(size_t __numfacets, size_t __refs)\n-  : _M_num_references(__refs - 1), _M_facets(0), _M_category_names(0), \n-    _M_has_name(false), _M_cached_name_ok(false), _M_cached_name(string (\"*\"))\n-  { \n-    typedef vector<facet*, allocator<facet*> > __vec_facet;\n-    typedef vector<string, allocator<string> > __vec_string;\n-\n-    auto_ptr<__vec_facet> __pvf(new __vec_facet(__numfacets, (facet*)0));\n-    auto_ptr<__vec_string> __pcn(new __vec_string(_S_num_categories, \n-\t\t\t\t\t\t  string(\"*\")));\n-    _M_facets = __pvf.release();\n-    _M_category_names = __pcn.release();\n-  }\n-  \n-  locale::_Impl::\n-  _Impl(const _Impl& __other, size_t __refs)\n-  : _M_num_references(__refs), _M_facets(0), _M_category_names(0), \n-    _M_has_name(__other._M_has_name), \n-    _M_cached_name_ok(__other._M_cached_name_ok), \n-    _M_cached_name(__other._M_cached_name)\n+  locale::locale(const char* __name)\n   {\n-    typedef vector<facet*, allocator<facet*> > __vec_facet;\n-    typedef vector<string, allocator<string> > __vec_string;\n-\n-    auto_ptr<__vec_facet> __pvf(new __vec_facet(*(__other._M_facets)));\n-    auto_ptr<__vec_string> \n-      __pcn(new __vec_string(*(__other._M_category_names)));\n-\n-    std::vector<facet*>::iterator __it = __pvf->begin();\n-    for (; __it != __pvf->end(); ++__it)\n-      (*__it)->_M_add_reference();\n-\n-    // These must be last since in the presence of an exception, the \n-    // destructor for 'this' won't run until AFTER execution has passed  \n-    // the closing brace of the constructor.\n-    _M_facets = __pvf.release();\n-    _M_category_names = __pcn.release();\n-  }\n-  \n-  void\n-  locale::_Impl::\n-  _M_replace_categories(const _Impl* __other, category __cats)\n-  {\n-    assert((__cats & locale::all) && !(__cats & ~locale::all));\n-    \n-    unsigned mask = (locale::all & -(unsigned)locale::all);\n-    for (unsigned ix = 0; (-mask & __cats) != 0; ++ix, (mask <<= 1))\n+    _S_initialize();\n+    if (strcmp(__name, \"C\") == 0 || strcmp(__name, \"POSIX\") == 0)\n+      (_M_impl = _S_classic)->_M_add_reference();\n+    else\n       {\n-\tif (mask & __cats)\n-\t  {\n-\t    _M_replace_category(__other, _S_facet_categories[ix]);\n-\t    (*_M_category_names)[ix] = (*(__other->_M_category_names))[ix];\n-\t  }\n+\t// Might throw:\n+\t_M_impl = new _Impl(*_S_classic, __name, all, 1);\n+        _M_impl->_M_has_name = true;\n       }\n   }\n \n-  void\n-  locale::_Impl::\n-  _M_replace_category(const _Impl* __other, const locale::id* const* __idpp)\n-  {\n-    for (; *__idpp; ++__idpp)\n-      _M_replace_facet(__other, *__idpp);\n-  }\n-  \n-  void\n-  locale::_Impl::\n-  _M_replace_facet(const _Impl* __other, const locale::id* __idp)\n-  {\n-    size_t __index = __idp->_M_index;\n-    if (__index == 0 \n-\t|| __other->_M_facets->size() <= __index \n-\t|| (*(__other->_M_facets))[__index] == 0)\n-      throw runtime_error(\"no locale facet\");\n-\t\n-    _M_install_facet(__idp, (*(__other->_M_facets))[__index]); \n-  }\n+  locale::locale(const locale& __other, const char* __name, category __cat)\n+  : _M_impl(new _Impl(*__other._M_impl, __name, _S_normalize_category(__cat), 1))\n+  { }\n \n-  void\n-  locale::_Impl::\n-  _M_install_facet(const locale::id* __idp, facet* __fp)\n+  bool\n+  locale::operator==(const locale& __rhs) const throw()\n   {\n-    if (__fp == 0)\n-      return;\n-\n-    size_t& __index = __idp->_M_index;\n-    if (!__index)\n-      __index = ++locale::id::_S_highwater;  // XXX MT\n-\n-    if (__index >= _M_facets->size())\n-      _M_facets->resize(__index + 1, 0);  // might throw\n-    facet*& __fpr = (*_M_facets)[__index];\n-    // Order matters, here:\n-    __fp->_M_add_reference();\n-    if (__fpr) \n-      __fpr->_M_remove_reference();\n-    __fpr = __fp;\n+    return((this->name() != \"*\" && this->name() == __rhs.name())\n+\t   || _M_impl == __rhs._M_impl);\n   }\n- \n+\n   locale::locale(_Impl* __ip) throw()\n   : _M_impl(__ip)\n   { __ip->_M_add_reference(); }\n \n-  locale::locale(const locale& __other, const locale& __one, category __cats)\n+  locale::locale(const locale& __other, const locale& __one, category __cat)\n   {\n-    __cats = _S_normalize_category(__cats);    // might throw\n+    __cat = _S_normalize_category(__cat);    // might throw\n     _M_impl = new _Impl(*__other._M_impl, 1);  // might throw\n \n     try { \n-      _M_impl->_M_replace_categories(__one._M_impl, __cats); \n+      _M_impl->_M_replace_categories(__one._M_impl, __cat); \n     }\n     catch (...) { \n       _M_impl->_M_remove_reference(); \n       throw; \n     }\n \n-    _M_impl->_M_cached_name_ok = false;\n+    // XXX\n+    //    _M_impl->_M_cached_name_ok = false;\n     if (!__other._M_impl->_M_has_name)\n       _M_impl->_M_has_name = false;\n   }\n@@ -707,10 +624,7 @@ namespace std {\n \n   string\n   locale::name() const\n-  {\n-    // XXX not done\n-    return \"*\";\n-  }\n+  { return _M_impl->_M_name; }\n \n   locale const&\n   locale::classic()\n@@ -722,7 +636,8 @@ namespace std {\n \ttry {\n \t  // 26 Standard facets, 2 references.\n \t  // One reference for _M_classic, one for _M_global\n-\t  _S_classic = _S_global = new _Impl(26, 2);\n+\t  _S_classic = new _Impl(26, 2, true, \"C\");\n+\t  _S_global = _S_classic; \n \n \t  // collate category\n \t  _S_classic->_M_facet_init(new std::collate<char>);\n@@ -784,48 +699,64 @@ namespace std {\n   }\n \n   int\n-  locale::_S_normalize_category(int __cats) \n+  locale::_S_normalize_category(int __cat) \n   {\n-    if ((__cats & all) && !(__cats & ~all))\n-      return __cats;\n-\n-    // NB: May be a C-style \"LC_ALL\" category; convert.\n-    switch (__cats)\n+    int __ret;\n+    if ((__cat & all) && !(__cat & ~all))\n+      __ret = __cat;\n+    else\n       {\n-      case LC_COLLATE:  return collate; \n-      case LC_CTYPE:    return ctype;\n-      case LC_MONETARY: return monetary;\n-      case LC_NUMERIC:  return numeric;\n-      case LC_TIME:     return time; \n+\t// NB: May be a C-style \"LC_ALL\" category; convert.\n+\tswitch (__cat)\n+\t  {\n+\t  case LC_COLLATE:  \n+\t    __ret = collate; \n+\t    break;\n+\t  case LC_CTYPE:    \n+\t    __ret = ctype;\n+\t    break;\n+\t  case LC_MONETARY: \n+\t    __ret = monetary;\n+\t    break;\n+\t  case LC_NUMERIC:  \n+\t    __ret = numeric;\n+\t    break;\n+\t  case LC_TIME:     \n+\t    __ret = time; \n+\t    break;\n #ifdef _GLIBCPP_HAVE_LC_MESSAGES\n-      case LC_MESSAGES: return messages;\n+\t  case LC_MESSAGES: \n+\t    __ret = messages;\n+\t    break;\n #endif\t\n-      case LC_ALL:      return all;\n+\t  case LC_ALL:      \n+\t    __ret = all;\n+\t    break;\n+\t  default:\n+\t    throw runtime_error(\"bad locale category\");\n+\t  }\n       }\n-    \n-    // XXX Should throw derived class here\n-    throw runtime_error(\"bad locale category\");\n-    /* NOTREACHED */\n+    return __ret;\n   }\n \n   locale::facet::\n   facet(size_t __refs) throw()\n-  : _M_num_references(__refs - 1) \n+  : _M_references(__refs - 1) \n   { }\n \n   void  \n   locale::facet::\n   _M_add_reference() throw()\n   { \n     if (this) \n-      ++_M_num_references; \n+      ++_M_references; \n   }                     // XXX MT\n \n   void  \n   locale::facet::\n   _M_remove_reference() throw()\n   {\n-    if (this && _M_num_references-- == 0)\n+    if (this && _M_references-- == 0)\n       {\n         try { \n \t  delete this; "}, {"sha": "baa3bee7799b4090b12f3fcb531a9736969f2a90", "filename": "libstdc++-v3/src/localename.cc", "status": "modified", "additions": 178, "deletions": 106, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc?ref=e4cc86592903c808012b6fa2c41da039ea7797a9", "patch": "@@ -1,5 +1,4 @@\n-\n-// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,34 +31,81 @@\n #include <bits/std_cstring.h>\n #include <bits/std_cassert.h>\n #include <bits/std_vector.h>\n+#include <bits/std_stdexcept.h>\n \n namespace std {\n \n-/////////////////////////////\n-// locale::_Impl constructors\n-/////////////////////////////\n+  locale::_Impl::\n+  ~_Impl() throw()\n+  {\n+    std::vector<facet*>::iterator it = _M_facets->begin();\n+    for (; it != _M_facets->end(); ++it)\n+      (*it)->_M_remove_reference();\n+    delete _M_facets;\n+    delete _M_category_names;\n+  }\n \n-  // construct specific categories, leaving unselected ones alone\n-  //////////\n-  locale::_Impl::_Impl(const _Impl& other,const string& name, category cats,\n-\t\t       size_t refs)\n-  : _M_num_references(refs)\n+  // This constructor is used to correctly initialize the standard,\n+  // required facets.\n+  locale::_Impl::\n+  _Impl(size_t __numfacets, size_t __refs, bool __has_name = false, \n+\tstring __name = \"*\")\n+  : _M_references(__refs - 1), _M_facets(0), _M_category_names(0), \n+    _M_has_name(__has_name), _M_name(__name)\n+  { \n+    typedef vector<facet*, allocator<facet*> > __vec_facet;\n+    typedef vector<string, allocator<string> > __vec_string;\n+\n+    auto_ptr<__vec_facet> __pvf(new __vec_facet(__numfacets, (facet*)0));\n+    auto_ptr<__vec_string> __pcn(new __vec_string(_S_num_categories, _M_name));\n+    _M_facets = __pvf.release();\n+    _M_category_names = __pcn.release();\n+  }\n+  \n+  locale::_Impl::\n+  _Impl(const _Impl& __other, size_t __refs)\n+  : _M_references(__refs - 1), _M_facets(0), _M_category_names(0), \n+    _M_has_name(__other._M_has_name), _M_name(__other._M_name)\n+  {\n+    typedef vector<facet*, allocator<facet*> > __vec_facet;\n+    typedef vector<string, allocator<string> > __vec_string;\n+\n+    auto_ptr<__vec_facet> __pvf(new __vec_facet(*(__other._M_facets)));\n+    auto_ptr<__vec_string> \n+      __pcn(new __vec_string(*(__other._M_category_names)));\n+\n+    std::vector<facet*>::iterator __it = __pvf->begin();\n+    for (; __it != __pvf->end(); ++__it)\n+      (*__it)->_M_add_reference();\n+\n+    // These must be last since in the presence of an exception, the \n+    // destructor for 'this' won't run until AFTER execution has passed  \n+    // the closing brace of the constructor.\n+    _M_facets = __pvf.release();\n+    _M_category_names = __pcn.release();\n+  }\n+\n+  // Construct specific categories, leaving unselected ones alone\n+  locale::_Impl::\n+  _Impl(const _Impl& __other, const string& __name, category __cat, \n+\tsize_t __refs)\n+    : _M_references(__refs - 1)\n     //  , _M_facets(other._M_facets)\n     //  , _M_category_names(other._M_category_names)\n-    , _M_has_name(other._M_has_name), _M_cached_name_ok(false)\n+    , _M_has_name(__other._M_has_name), _M_name(__other._M_name)\n   {\n #if 1\n     typedef vector<facet*, allocator<facet*> > __vec_facet;\n     typedef vector<string, allocator<string> > __vec_string;\n     try {\n-      _M_facets = new __vec_facet(*(other._M_facets));\n+      _M_facets = new __vec_facet(*(__other._M_facets));\n     }\n     catch (...) {\n       delete _M_facets;\n       throw;\n     }\n     try {\n-       _M_category_names = new __vec_string(*(other._M_category_names));\n+       _M_category_names = new __vec_string(*(__other._M_category_names));\n     }\n     catch (...) {\n       delete _M_category_names;\n@@ -70,7 +116,7 @@ namespace std {\n     // static void(_Impl::* const ctors[]) (const char*) = \n     static void(_Impl::* ctors[]) (const char*) = \n     {\n-      //  NB: order must match the decl order in class locale.\n+      //  NB: Order must match the decl order in class locale.\n       &locale::_Impl::_M_construct_collate,\n       &locale::_Impl::_M_construct_ctype,\n       &locale::_Impl::_M_construct_monetary,\n@@ -81,111 +127,167 @@ namespace std {\n     };\n     \n     _S_initialize();\n-    std::vector<facet*>::iterator it = _M_facets->begin();\n-    for (; it != _M_facets->end(); ++it)\n-      (*it)->_M_add_reference();\n+    std::vector<facet*>::iterator __it = _M_facets->begin();\n+    for (; __it != _M_facets->end(); ++__it)\n+      (*__it)->_M_add_reference();\n \n     try {\n-      category classix = _S_normalize_category(cats);  // might throw\n-      _M_normalize_category_names(name, classix);\n+      category __ccategory = _S_normalize_category(__cat);  // might throw\n+      _M_normalize_category_names(__name, __ccategory);\n \t\n       unsigned mask = (locale::all & -(unsigned)locale::all);\n-      for (unsigned ix = 0; (-mask & cats) != 0; ++ix, (mask <<= 1))\n+      for (unsigned ix = 0; (-mask & __cat) != 0; ++ix, (mask <<= 1))\n \t{\n-\t  if (!(mask & cats))\n+\t  if (!(mask & __cat))\n \t    continue;\n \t  \n-\t  if (mask & classix)\n+\t  if (mask & __ccategory)\n \t    _M_replace_category(_S_classic, _S_facet_categories[ix]);\n \t  else\n-\t    (this->*ctors[ix]) (name.c_str());\n+\t    (this->*ctors[ix]) (__name.c_str());\n \t}\n     }\n     catch (...) {\n-      it = _M_facets->begin();\n-      for (; it != _M_facets->end(); ++it)\n-\t(*it)->_M_remove_reference();\n+      __it = _M_facets->begin();\n+      for (; __it != _M_facets->end(); ++__it)\n+\t(*__it)->_M_remove_reference();\n       throw;\n     }\n   }\n+  \n+  void\n+  locale::_Impl::\n+  _M_replace_categories(const _Impl* __other, category __cat)\n+  {\n+    assert((__cat & locale::all) && !(__cat & ~locale::all));\n+    \n+    unsigned int __mask = locale::all & -static_cast<unsigned int>(locale::all);\n+    for (unsigned int __ix = 0; (-__mask & __cat) != 0; ++__ix, (__mask <<= 1))\n+      {\n+\tif (__mask & __cat)\n+\t  {\n+\t    _M_replace_category(__other, _S_facet_categories[__ix]);\n+\t    (*_M_category_names)[__ix] = (*(__other->_M_category_names))[__ix];\n+\t  }\n+      }\n+  }\n+\n+  void\n+  locale::_Impl::\n+  _M_replace_category(const _Impl* __other, const locale::id* const* __idpp)\n+  {\n+    for (; *__idpp; ++__idpp)\n+      _M_replace_facet(__other, *__idpp);\n+  }\n+  \n+  void\n+  locale::_Impl::\n+  _M_replace_facet(const _Impl* __other, const locale::id* __idp)\n+  {\n+    size_t __index = __idp->_M_index;\n+    if (__index == 0 \n+\t|| __other->_M_facets->size() <= __index \n+\t|| (*(__other->_M_facets))[__index] == 0)\n+      throw runtime_error(\"no locale facet\");\n+\t\n+    _M_install_facet(__idp, (*(__other->_M_facets))[__index]); \n+  }\n+\n+  void\n+  locale::_Impl::\n+  _M_install_facet(const locale::id* __idp, facet* __fp)\n+  {\n+    if (__fp == 0)\n+      return;\n+\n+    size_t& __index = __idp->_M_index;\n+    if (!__index)\n+      __index = ++locale::id::_S_highwater;  // XXX MT\n \n-  //////////\n+    if (__index >= _M_facets->size())\n+      _M_facets->resize(__index + 1, 0);  // might throw\n+    facet*& __fpr = (*_M_facets)[__index];\n+    // Order matters, here:\n+    __fp->_M_add_reference();\n+    if (__fpr) \n+      __fpr->_M_remove_reference();\n+    __fpr = __fp;\n+  }\n+ \n   locale::category\n   locale::_Impl::_M_normalize_category_names(const string&, \n-\t\t\t\t\t     locale::category cats)\n+\t\t\t\t\t     locale::category __cat)\n   {\n-\n     // The problem to be solved here is that locale names\n-    //   generally have one of two forms: they might have\n-    //   only one component, such as \"en_US\"; or they might\n-    //   have six, such as \"en_US fr_FR en_US C C C\", where\n-    //   each component names a category.  Each vendor has\n-    //   a different order of categories.  Each vendor uses\n-    //   a different format:\n-    //      AIX uses \"C C C C C C\"\n-    //      Sun uses \"/C/C/C/C/C/C\"\n-    //      HP uses  \"/0:C;1:C;2:C;3:C;4:C;5:C;6:C;/\"\n-    //        (where the 0th element is for LC_ALL.)\n-    //   Most systems (except AIX) permit the long form only for\n-    //   setlocale(LC_ALL,...), and require the short form for\n-    //   other calls.  All this matters because locale names are\n-    //   supposed to be compatible between locale(\"\") and\n-    //   setlocale(..., \"\") constructors.\n+    // generally have one of two forms: they might have\n+    // only one component, such as \"en_US\"; or they might\n+    // have six, such as \"en_US fr_FR en_US C C C\", where\n+    // each component names a category.  Each vendor has\n+    // a different order of categories.  Each vendor uses\n+    // a different format:\n+    //    AIX uses \"C C C C C C\"\n+    //    Sun uses \"/C/C/C/C/C/C\"\n+    //    HP uses  \"/0:C;1:C;2:C;3:C;4:C;5:C;6:C;/\"\n+    //    (where the 0th element is for LC_ALL.)\n+    // Most systems (except AIX) permit the long form only for\n+    // setlocale(LC_ALL,...), and require the short form for\n+    // other calls.  All this matters because locale names are\n+    // supposed to be compatible between locale(\"\") and\n+    // setlocale(..., \"\") constructors.\n     \n-    return cats;\n+    return __cat;\n #if 0 /* XXX not done */\n     unsigned mask = (locale::all & -(unsigned)locale::all);\n-    for (unsigned ix = 0; (-mask & cats) != 0; ++ix, (mask <<= 1))\n+    for (unsigned ix = 0; (-mask & __cat) != 0; ++ix, (mask <<= 1))\n       {\n \t\n       }\n #endif\n   }\n \n-  //////////\n   void \n-  locale::_Impl::_M_construct_collate(const char* /*name*/)\n+  locale::_Impl::_M_construct_collate(const char* /*__name*/)\n   {\n #if 0\n-    _M_facet_init(new std::collate_byname<char>(name));\n-    _M_facet_init(new std::collate_byname<wchar_t>(name));\n+    _M_facet_init(new std::collate_byname<char>(__name));\n+    _M_facet_init(new std::collate_byname<wchar_t>(__name));\n #endif\n   }\n \n   void \n-  locale::_Impl::_M_construct_ctype(const char* /*name*/)\n+  locale::_Impl::_M_construct_ctype(const char* /*__name*/)\n   {\n #if 0\n-    _M_facet_init(new std::ctype_byname<char>(name));\n-    _M_facet_init(new std::ctype_byname<wchar_t>(name));\n-    _M_facet_init(new std::codecvt_byname<char,char,mbstate_t>(name));\n-    _M_facet_init(new std::codecvt_byname<wchar_t,char,mbstate_t>(name));\n+    _M_facet_init(new std::ctype_byname<char>(__name));\n+    _M_facet_init(new std::ctype_byname<wchar_t>(__name));\n+    _M_facet_init(new std::codecvt_byname<char, char, mbstate_t>(__name));\n+    _M_facet_init(new std::codecvt_byname<wchar_t, char, mbstate_t>(__name));\n #endif\n   }\n     \n   void \n-  locale::_Impl::_M_construct_monetary(const char* /*name*/)\n+  locale::_Impl::_M_construct_monetary(const char* /*__name*/)\n   {\n #if 0\n-    _M_facet_init(new std::moneypunct_byname<char,false>(name));\n-    _M_facet_init(new std::moneypunct_byname<wchar_t,false>(name));\n-    _M_facet_init(new std::moneypunct_byname<char,true >(name));\n-    _M_facet_init(new std::moneypunct_byname<wchar_t,true >(name));\n+    _M_facet_init(new std::moneypunct_byname<char, false>(__name));\n+    _M_facet_init(new std::moneypunct_byname<wchar_t, false>(__name));\n+    _M_facet_init(new std::moneypunct_byname<char, true >(__name));\n+    _M_facet_init(new std::moneypunct_byname<wchar_t, true >(__name));\n \n     locale::_M_initialize();\n-    _M_replace_facet(locale::_S_classic, &std::money_get<char>(name)::id);\n-    _M_replace_facet(locale::_S_classic, &std::money_get<wchar_t>(name)::id);\n-    _M_replace_facet(locale::_S_classic, &std::money_put<char>(name)::id);\n-    _M_replace_facet(locale::_S_classic, &std::money_put<wchar_t>(name)::id);\n+    _M_replace_facet(locale::_S_classic, &std::money_get<char>(__name)::id);\n+    _M_replace_facet(locale::_S_classic, &std::money_get<wchar_t>(__name)::id);\n+    _M_replace_facet(locale::_S_classic, &std::money_put<char>(__name)::id);\n+    _M_replace_facet(locale::_S_classic, &std::money_put<wchar_t>(__name)::id);\n #endif\n   }\n     \n   void \n-  locale::_Impl::_M_construct_numeric(const char* /*name*/)\n+  locale::_Impl::_M_construct_numeric(const char* /*__name*/)\n   {\n #if 0\n-    _M_facet_init(new std::numpunct_byname<char>(name));\n-    _M_facet_init(new std::numpunct_byname<wchar_t>(name));\n+    _M_facet_init(new std::numpunct_byname<char>(__name));\n+    _M_facet_init(new std::numpunct_byname<wchar_t>(__name));\n \n     locale::_M_initialize();\n     _M_replace_facet(locale::_S_classic, &std::num_get<char>::id);\n@@ -196,55 +298,25 @@ namespace std {\n   }\n     \n   void \n-  locale::_Impl::_M_construct_time(const char* /*name*/)\n+  locale::_Impl::_M_construct_time(const char* /*__name*/)\n   {\n #if 0\n-    _M_facet_init(new std::time_get_byname<char>(name));\n-    _M_facet_init(new std::time_get_byname<wchar_t>(name));\n-    _M_facet_init(new std::time_put_byname<char>(name));\n-    _M_facet_init(new std::time_put_byname<wchar_t>(name));\n+    _M_facet_init(new std::time_get_byname<char>(__name));\n+    _M_facet_init(new std::time_get_byname<wchar_t>(__name));\n+    _M_facet_init(new std::time_put_byname<char>(__name));\n+    _M_facet_init(new std::time_put_byname<wchar_t>(__name));\n #endif\n   }\n     \n   void \n-  locale::_Impl::_M_construct_messages(const char* /*name*/)\n+  locale::_Impl::_M_construct_messages(const char* /*__name*/)\n   {\n #if 0\n-    _M_facet_init(new std::messages_byname<char>(name));\n-    _M_facet_init(new std::messages_byname<wchar_t>(name));\n+    _M_facet_init(new std::messages_byname<char>(__name));\n+    _M_facet_init(new std::messages_byname<wchar_t>(__name));\n #endif\n   }\n+}\n \n-  //////////////////////\n-  // locale constructors\n-  //////////////////////\n-  \n-  ////////\n-  locale::locale(const char* std_name)\n-  {\n-    _S_initialize();\n-    if (strcmp(std_name, \"C\") == 0 || strcmp(std_name, \"POSIX\"))\n-      (_M_impl = _S_classic)->_M_add_reference();\n-    else\n-      {\n-\t// might throw:\n-\t_M_impl = new _Impl(*_S_classic, string(std_name), all, 1);\n-        _M_impl->_M_has_name = true;\n-      }\n-  }\n-\n-  /////////\n-  locale::locale(const locale& other, const char* std_name, category cats)\n-  : _M_impl(new _Impl(*other._M_impl, string(std_name),\n-\t\t      _S_normalize_category(cats), 1))  // might throw\n-  { }\n \n-  ///////\n-  bool\n-  locale::operator==(const locale& __rhs) const throw()\n-  {\n-    return(_M_impl == __rhs._M_impl \n-\t   || (this->name() != \"*\" && this->name() == __rhs.name()));\n-  }\n \n-}"}, {"sha": "d276dc875ea1e7d113ac26ce459c5acae6787c42", "filename": "libstdc++-v3/testsuite/22_locale/ctor_copy_dtor.cc", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4cc86592903c808012b6fa2c41da039ea7797a9/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc?ref=e4cc86592903c808012b6fa2c41da039ea7797a9", "patch": "@@ -21,6 +21,7 @@\n // 22.1.1.2 locale constructors and destructors [lib.locale.cons]\n \n #include <locale>\n+#include <stdexcept>\n #include <debug_assert.h>\n \n typedef std::codecvt<char, char, mbstate_t> ccodecvt;\n@@ -35,25 +36,46 @@ void test01()\n \n   // construct a locale object with the C facet\n   const locale& \tloc01 = locale::classic();\n-  // construct a locale object with the specialized facet.\n-  locale                loc02(locale::classic(), new gnu_codecvt);\n-  VERIFY ( loc01 != loc02 );\n-  VERIFY ( !(loc01 == loc02) );\n \n   // 1\n+  // template <class Facet> locale(const locale& other, Facet* f)\n+  // construct a locale object with the specialized facet.\n+  locale loc02(locale::classic(), new gnu_codecvt);\n+  VERIFY (loc01 != loc02);\n+  VERIFY (loc02.name() == \"*\");\n+\n+  // 2\n   // locale() throw()\n   locale loc03;\n-  VERIFY ( loc03 == loc01);\n-  locale loc04 = global(loc02);\n+  VERIFY (loc03 == loc01);\n+  VERIFY (loc03.name() == \"C\");\n+  locale loc04 = locale::global(loc02);\n   locale loc05;\n   VERIFY (loc05 != loc03);\n   VERIFY (loc05 == loc02);\n \n-#if  0\n-  str1 = cloc.name();\n-  str2 = loc.name();  \n-  VERIFY( loc(str1, str2) == false );\n- #endif\n+  // 3\n+  // explicit locale(const char* std_name)\n+  locale loc06(\"fr_FR\");\n+  VERIFY (loc06 != loc01);  \n+  VERIFY (loc06 != loc02);  \n+  VERIFY (loc06.name() == \"fr_FR\");\n+  locale loc07(\"\");\n+  VERIFY (loc07 != loc01);  \n+  VERIFY (loc07 != loc02);  \n+  VERIFY (loc06.name() == \"\");\n+  try\n+    { locale loc08(static_cast<const char*>(NULL)); }\n+  catch(runtime_error& obj)\n+    { VERIFY (true); }\n+  catch(...)\n+    { VERIFY (false); }\n+\n+  // 4\n+  // locale(const locale& other, const char* std_name, category)\n+  \n+\n+\n }\n \n int main ()"}]}