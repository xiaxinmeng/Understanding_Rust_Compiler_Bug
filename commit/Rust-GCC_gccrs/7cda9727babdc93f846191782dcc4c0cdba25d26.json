{"sha": "7cda9727babdc93f846191782dcc4c0cdba25d26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NkYTk3MjdiYWJkYzkzZjg0NjE5MTc4MmRjYzRjMGNkYmEyNWQyNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2011-08-31T08:40:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-31T08:40:22Z"}, "message": "s-taprop-vxworks.adb, [...]: Minor reformatting.\n\n2011-08-31  Robert Dewar  <dewar@adacore.com>\n\n\t* s-taprop-vxworks.adb, sem_ch5.adb, s-taprop-tru64.adb, exp_alfa.adb,\n\ts-taprop-vms.adb, bindgen.adb, s-mudido.adb, s-mudido.ads,\n\tsem_res.adb, expander.adb, s-taprop-mingw.adb, s-taprop-linux.adb,\n\ts-taprop-solaris.adb, s-mudido-affinity.adb, vms_conv.adb,\n\ts-taprop-irix.adb, s-taprop.ads, s-taskin.adb, s-taskin.ads,\n\ts-taprop-hpux-dce.adb, a-chtgbo.adb, s-taprop-posix.adb: Minor\n\treformatting.\n\nFrom-SVN: r178357", "tree": {"sha": "d9b4cce8e8d74851b26f0940edbef384eadeaf11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9b4cce8e8d74851b26f0940edbef384eadeaf11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cda9727babdc93f846191782dcc4c0cdba25d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cda9727babdc93f846191782dcc4c0cdba25d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cda9727babdc93f846191782dcc4c0cdba25d26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cda9727babdc93f846191782dcc4c0cdba25d26/comments", "author": null, "committer": null, "parents": [{"sha": "0a190dfd4af27afb8eaf03082af81acbb5bf8a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a190dfd4af27afb8eaf03082af81acbb5bf8a80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a190dfd4af27afb8eaf03082af81acbb5bf8a80"}], "stats": {"total": 798, "additions": 410, "deletions": 388}, "files": [{"sha": "a1a20095def0e3f3a57cef1995f28f08a25388d7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1,3 +1,13 @@\n+2011-08-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-taprop-vxworks.adb, sem_ch5.adb, s-taprop-tru64.adb, exp_alfa.adb,\n+\ts-taprop-vms.adb, bindgen.adb, s-mudido.adb, s-mudido.ads,\n+\tsem_res.adb, expander.adb, s-taprop-mingw.adb, s-taprop-linux.adb,\n+\ts-taprop-solaris.adb, s-mudido-affinity.adb, vms_conv.adb,\n+\ts-taprop-irix.adb, s-taprop.ads, s-taskin.adb, s-taskin.ads,\n+\ts-taprop-hpux-dce.adb, a-chtgbo.adb, s-taprop-posix.adb: Minor\n+\treformatting.\n+\n 2011-08-31  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch12 (Check_Private_View): Revert previous change."}, {"sha": "9e7da11e7e6fdff997d9e294c564dcb48a55c65d", "filename": "gcc/ada/a-chtgbo.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fa-chtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fa-chtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -139,6 +139,14 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n       N : Nodes_Type renames HT.Nodes;\n \n    begin\n+      --  This subprogram \"deallocates\" a node by relinking the node off of the\n+      --  active list and onto the free list. Previously it would flag index\n+      --  value 0 as an error. The precondition was weakened, so that index\n+      --  value 0 is now allowed, and this value is interpreted to mean \"do\n+      --  nothing\". This makes its behavior analogous to the behavior of\n+      --  Ada.Unchecked_Conversion, and allows callers to avoid having to add\n+      --  special-case checks at the point of call.\n+\n       if X = 0 then\n          return;\n       end if;"}, {"sha": "f5a2bdcecad7a5afc1eeb9997add0a19ed5c321c", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -240,7 +240,9 @@ package body Bindgen is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Check_File_In_Partition (File_Name : String; Flag : out Boolean);\n+   procedure Check_File_In_Partition\n+     (File_Name : String;\n+      Flag      : out Boolean);\n    --  If the file indicated by File_Name is in the partition the Flag is set\n    --  to True, False otherwise.\n \n@@ -401,7 +403,9 @@ package body Bindgen is\n    -----------------------------\n \n    procedure Check_File_In_Partition\n-     (File_Name : String; Flag : out Boolean) is\n+     (File_Name : String;\n+      Flag      : out Boolean)\n+   is\n    begin\n       for J in Units.First .. Units.Last loop\n          if Get_Name_String (Units.Table (J).Sfile) = File_Name then"}, {"sha": "f0bdc805cbd58bb679c57f3eba0038326b513a88", "filename": "gcc/ada/exp_alfa.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fexp_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fexp_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -45,8 +45,8 @@ package body Exp_Alfa is\n    procedure Expand_Alfa_Call (N : Node_Id);\n    --  This procedure contains common processing for function and procedure\n    --  calls:\n-   --  * expansion of actuals to introduce necessary temporaries\n-   --  * replacement of renaming by subprogram renamed\n+   --    * expansion of actuals to introduce necessary temporaries\n+   --    * replacement of renaming by subprogram renamed\n \n    procedure Expand_Alfa_N_Attribute_Reference (N : Node_Id);\n    --  Expand attributes 'Old and 'Result only\n@@ -89,7 +89,6 @@ package body Exp_Alfa is\n \n          when others =>\n             null;\n-\n       end case;\n    end Expand_Alfa;\n "}, {"sha": "65d6efb921e277714c5ca1a704b369e5825ae23f", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 243, "deletions": 239, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -23,30 +23,30 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;     use Atree;\n-with Debug_A;   use Debug_A;\n-with Errout;    use Errout;\n-with Exp_Aggr;  use Exp_Aggr;\n-with Exp_Alfa;  use Exp_Alfa;\n-with Exp_Attr;  use Exp_Attr;\n-with Exp_Ch2;   use Exp_Ch2;\n-with Exp_Ch3;   use Exp_Ch3;\n-with Exp_Ch4;   use Exp_Ch4;\n-with Exp_Ch5;   use Exp_Ch5;\n-with Exp_Ch6;   use Exp_Ch6;\n-with Exp_Ch7;   use Exp_Ch7;\n-with Exp_Ch8;   use Exp_Ch8;\n-with Exp_Ch9;   use Exp_Ch9;\n-with Exp_Ch11;  use Exp_Ch11;\n-with Exp_Ch12;  use Exp_Ch12;\n-with Exp_Ch13;  use Exp_Ch13;\n-with Exp_Prag;  use Exp_Prag;\n-with Opt;       use Opt;\n-with Rtsfind;   use Rtsfind;\n-with Sem;       use Sem;\n-with Sem_Ch8;   use Sem_Ch8;\n-with Sem_Util;  use Sem_Util;\n-with Sinfo;     use Sinfo;\n+with Atree;    use Atree;\n+with Debug_A;  use Debug_A;\n+with Errout;   use Errout;\n+with Exp_Aggr; use Exp_Aggr;\n+with Exp_Alfa; use Exp_Alfa;\n+with Exp_Attr; use Exp_Attr;\n+with Exp_Ch2;  use Exp_Ch2;\n+with Exp_Ch3;  use Exp_Ch3;\n+with Exp_Ch4;  use Exp_Ch4;\n+with Exp_Ch5;  use Exp_Ch5;\n+with Exp_Ch6;  use Exp_Ch6;\n+with Exp_Ch7;  use Exp_Ch7;\n+with Exp_Ch8;  use Exp_Ch8;\n+with Exp_Ch9;  use Exp_Ch9;\n+with Exp_Ch11; use Exp_Ch11;\n+with Exp_Ch12; use Exp_Ch12;\n+with Exp_Ch13; use Exp_Ch13;\n+with Exp_Prag; use Exp_Prag;\n+with Opt;      use Opt;\n+with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n with Table;\n \n package body Expander is\n@@ -127,336 +127,340 @@ package body Expander is\n       else\n          Debug_A_Entry (\"expanding  \", N);\n \n-         --  Processing depends on node kind. For full details on the expansion\n-         --  activity required in each case, see bodies of corresponding expand\n-         --  routines.\n-\n          begin\n+            --  In ALFA mode we only need a very limited subset of the usual\n+            --  expansions. This limited subset is implemented in Expand_Alfa.\n+\n             if ALFA_Mode then\n                Expand_Alfa (N);\n \n+            --  Here for normal non-ALFA mode\n+\n             else\n+               --  Processing depends on node kind. For full details on the\n+               --  expansion activity required in each case, see bodies of\n+               --  corresponding expand routines.\n \n                case Nkind (N) is\n \n-               when N_Abort_Statement =>\n-                  Expand_N_Abort_Statement (N);\n+                  when N_Abort_Statement =>\n+                     Expand_N_Abort_Statement (N);\n \n-               when N_Accept_Statement =>\n-                  Expand_N_Accept_Statement (N);\n+                  when N_Accept_Statement =>\n+                     Expand_N_Accept_Statement (N);\n \n-               when N_Aggregate =>\n-                  Expand_N_Aggregate (N);\n+                  when N_Aggregate =>\n+                     Expand_N_Aggregate (N);\n \n-               when N_Allocator =>\n-                  Expand_N_Allocator (N);\n+                  when N_Allocator =>\n+                     Expand_N_Allocator (N);\n \n-               when N_And_Then =>\n-                  Expand_N_And_Then (N);\n+                  when N_And_Then =>\n+                     Expand_N_And_Then (N);\n \n-               when N_Assignment_Statement =>\n-                  Expand_N_Assignment_Statement (N);\n+                  when N_Assignment_Statement =>\n+                     Expand_N_Assignment_Statement (N);\n \n-               when N_Asynchronous_Select =>\n-                  Expand_N_Asynchronous_Select (N);\n+                  when N_Asynchronous_Select =>\n+                     Expand_N_Asynchronous_Select (N);\n \n-               when N_Attribute_Definition_Clause =>\n-                  Expand_N_Attribute_Definition_Clause (N);\n+                  when N_Attribute_Definition_Clause =>\n+                     Expand_N_Attribute_Definition_Clause (N);\n \n-               when N_Attribute_Reference =>\n-                  Expand_N_Attribute_Reference (N);\n+                  when N_Attribute_Reference =>\n+                     Expand_N_Attribute_Reference (N);\n \n-               when N_Block_Statement =>\n-                  Expand_N_Block_Statement (N);\n+                  when N_Block_Statement =>\n+                     Expand_N_Block_Statement (N);\n \n-               when N_Case_Expression =>\n-                  Expand_N_Case_Expression (N);\n+                  when N_Case_Expression =>\n+                     Expand_N_Case_Expression (N);\n \n-               when N_Case_Statement =>\n-                  Expand_N_Case_Statement (N);\n+                  when N_Case_Statement =>\n+                     Expand_N_Case_Statement (N);\n \n-               when N_Conditional_Entry_Call =>\n-                  Expand_N_Conditional_Entry_Call (N);\n+                  when N_Conditional_Entry_Call =>\n+                     Expand_N_Conditional_Entry_Call (N);\n \n-               when N_Conditional_Expression =>\n-                  Expand_N_Conditional_Expression (N);\n+                  when N_Conditional_Expression =>\n+                     Expand_N_Conditional_Expression (N);\n \n-               when N_Delay_Relative_Statement =>\n-                  Expand_N_Delay_Relative_Statement (N);\n+                  when N_Delay_Relative_Statement =>\n+                     Expand_N_Delay_Relative_Statement (N);\n \n-               when N_Delay_Until_Statement =>\n-                  Expand_N_Delay_Until_Statement (N);\n+                  when N_Delay_Until_Statement =>\n+                     Expand_N_Delay_Until_Statement (N);\n \n-               when N_Entry_Body =>\n-                  Expand_N_Entry_Body (N);\n+                  when N_Entry_Body =>\n+                     Expand_N_Entry_Body (N);\n \n-               when N_Entry_Call_Statement =>\n-                  Expand_N_Entry_Call_Statement (N);\n+                  when N_Entry_Call_Statement =>\n+                     Expand_N_Entry_Call_Statement (N);\n \n-               when N_Entry_Declaration =>\n-                  Expand_N_Entry_Declaration (N);\n+                  when N_Entry_Declaration =>\n+                     Expand_N_Entry_Declaration (N);\n \n-               when N_Exception_Declaration =>\n-                  Expand_N_Exception_Declaration (N);\n+                  when N_Exception_Declaration =>\n+                     Expand_N_Exception_Declaration (N);\n \n-               when N_Exception_Renaming_Declaration =>\n-                  Expand_N_Exception_Renaming_Declaration (N);\n+                  when N_Exception_Renaming_Declaration =>\n+                     Expand_N_Exception_Renaming_Declaration (N);\n \n-               when N_Exit_Statement =>\n-                  Expand_N_Exit_Statement (N);\n+                  when N_Exit_Statement =>\n+                     Expand_N_Exit_Statement (N);\n \n-               when N_Expanded_Name =>\n-                  Expand_N_Expanded_Name (N);\n+                  when N_Expanded_Name =>\n+                     Expand_N_Expanded_Name (N);\n \n-               when N_Explicit_Dereference =>\n-                  Expand_N_Explicit_Dereference (N);\n+                  when N_Explicit_Dereference =>\n+                     Expand_N_Explicit_Dereference (N);\n \n-               when N_Expression_With_Actions =>\n-                  Expand_N_Expression_With_Actions (N);\n+                  when N_Expression_With_Actions =>\n+                     Expand_N_Expression_With_Actions (N);\n \n-               when N_Extended_Return_Statement =>\n-                  Expand_N_Extended_Return_Statement (N);\n+                  when N_Extended_Return_Statement =>\n+                     Expand_N_Extended_Return_Statement (N);\n \n-               when N_Extension_Aggregate =>\n-                  Expand_N_Extension_Aggregate (N);\n+                  when N_Extension_Aggregate =>\n+                     Expand_N_Extension_Aggregate (N);\n \n-               when N_Free_Statement =>\n-                  Expand_N_Free_Statement (N);\n+                  when N_Free_Statement =>\n+                     Expand_N_Free_Statement (N);\n \n-               when N_Freeze_Entity =>\n-                  Expand_N_Freeze_Entity (N);\n+                  when N_Freeze_Entity =>\n+                     Expand_N_Freeze_Entity (N);\n \n-               when N_Full_Type_Declaration =>\n-                  Expand_N_Full_Type_Declaration (N);\n+                  when N_Full_Type_Declaration =>\n+                     Expand_N_Full_Type_Declaration (N);\n \n-               when N_Function_Call =>\n-                  Expand_N_Function_Call (N);\n+                  when N_Function_Call =>\n+                     Expand_N_Function_Call (N);\n \n-               when N_Generic_Instantiation =>\n-                  Expand_N_Generic_Instantiation (N);\n+                  when N_Generic_Instantiation =>\n+                     Expand_N_Generic_Instantiation (N);\n \n-               when N_Goto_Statement =>\n-                  Expand_N_Goto_Statement (N);\n+                  when N_Goto_Statement =>\n+                     Expand_N_Goto_Statement (N);\n \n-               when N_Handled_Sequence_Of_Statements =>\n-                  Expand_N_Handled_Sequence_Of_Statements (N);\n+                  when N_Handled_Sequence_Of_Statements =>\n+                     Expand_N_Handled_Sequence_Of_Statements (N);\n \n-               when N_Identifier =>\n-                  Expand_N_Identifier (N);\n+                  when N_Identifier =>\n+                     Expand_N_Identifier (N);\n \n-               when N_Indexed_Component =>\n-                  Expand_N_Indexed_Component (N);\n+                  when N_Indexed_Component =>\n+                     Expand_N_Indexed_Component (N);\n \n-               when N_If_Statement =>\n-                  Expand_N_If_Statement (N);\n+                  when N_If_Statement =>\n+                     Expand_N_If_Statement (N);\n \n-               when N_In =>\n-                  Expand_N_In (N);\n+                  when N_In =>\n+                     Expand_N_In (N);\n \n-               when N_Loop_Statement =>\n-                  Expand_N_Loop_Statement (N);\n+                  when N_Loop_Statement =>\n+                     Expand_N_Loop_Statement (N);\n \n-               when N_Not_In =>\n-                  Expand_N_Not_In (N);\n+                  when N_Not_In =>\n+                     Expand_N_Not_In (N);\n \n-               when N_Null =>\n-                  Expand_N_Null (N);\n+                  when N_Null =>\n+                     Expand_N_Null (N);\n \n-               when N_Object_Declaration =>\n-                  Expand_N_Object_Declaration (N);\n+                  when N_Object_Declaration =>\n+                     Expand_N_Object_Declaration (N);\n \n-               when N_Object_Renaming_Declaration =>\n-                  Expand_N_Object_Renaming_Declaration (N);\n+                  when N_Object_Renaming_Declaration =>\n+                     Expand_N_Object_Renaming_Declaration (N);\n \n-               when N_Op_Add =>\n-                  Expand_N_Op_Add (N);\n+                  when N_Op_Add =>\n+                     Expand_N_Op_Add (N);\n \n-               when N_Op_Abs =>\n-                  Expand_N_Op_Abs (N);\n+                  when N_Op_Abs =>\n+                     Expand_N_Op_Abs (N);\n \n-               when N_Op_And =>\n-                  Expand_N_Op_And (N);\n+                  when N_Op_And =>\n+                     Expand_N_Op_And (N);\n \n-               when N_Op_Concat =>\n-                  Expand_N_Op_Concat (N);\n+                  when N_Op_Concat =>\n+                     Expand_N_Op_Concat (N);\n \n-               when N_Op_Divide =>\n-                  Expand_N_Op_Divide (N);\n+                  when N_Op_Divide =>\n+                     Expand_N_Op_Divide (N);\n \n-               when N_Op_Eq =>\n-                  Expand_N_Op_Eq (N);\n+                  when N_Op_Eq =>\n+                     Expand_N_Op_Eq (N);\n \n-               when N_Op_Expon =>\n-                  Expand_N_Op_Expon (N);\n+                  when N_Op_Expon =>\n+                     Expand_N_Op_Expon (N);\n \n-               when N_Op_Ge =>\n-                  Expand_N_Op_Ge (N);\n+                  when N_Op_Ge =>\n+                     Expand_N_Op_Ge (N);\n \n-               when N_Op_Gt =>\n-                  Expand_N_Op_Gt (N);\n+                  when N_Op_Gt =>\n+                     Expand_N_Op_Gt (N);\n \n-               when N_Op_Le =>\n-                  Expand_N_Op_Le (N);\n+                  when N_Op_Le =>\n+                     Expand_N_Op_Le (N);\n \n-               when N_Op_Lt =>\n-                  Expand_N_Op_Lt (N);\n+                  when N_Op_Lt =>\n+                     Expand_N_Op_Lt (N);\n \n-               when N_Op_Minus =>\n-                  Expand_N_Op_Minus (N);\n+                  when N_Op_Minus =>\n+                     Expand_N_Op_Minus (N);\n \n-               when N_Op_Mod =>\n-                  Expand_N_Op_Mod (N);\n+                  when N_Op_Mod =>\n+                     Expand_N_Op_Mod (N);\n \n-               when N_Op_Multiply =>\n-                  Expand_N_Op_Multiply (N);\n+                  when N_Op_Multiply =>\n+                     Expand_N_Op_Multiply (N);\n \n-               when N_Op_Ne =>\n-                  Expand_N_Op_Ne (N);\n+                  when N_Op_Ne =>\n+                     Expand_N_Op_Ne (N);\n \n-               when N_Op_Not =>\n-                  Expand_N_Op_Not (N);\n+                  when N_Op_Not =>\n+                     Expand_N_Op_Not (N);\n \n-               when N_Op_Or =>\n-                  Expand_N_Op_Or (N);\n+                  when N_Op_Or =>\n+                     Expand_N_Op_Or (N);\n \n-               when N_Op_Plus =>\n-                  Expand_N_Op_Plus (N);\n+                  when N_Op_Plus =>\n+                     Expand_N_Op_Plus (N);\n \n-               when N_Op_Rem =>\n-                  Expand_N_Op_Rem (N);\n+                  when N_Op_Rem =>\n+                     Expand_N_Op_Rem (N);\n \n-               when N_Op_Rotate_Left =>\n-                  Expand_N_Op_Rotate_Left (N);\n+                  when N_Op_Rotate_Left =>\n+                     Expand_N_Op_Rotate_Left (N);\n \n-               when N_Op_Rotate_Right =>\n-                  Expand_N_Op_Rotate_Right (N);\n+                  when N_Op_Rotate_Right =>\n+                     Expand_N_Op_Rotate_Right (N);\n \n-               when N_Op_Shift_Left =>\n-                  Expand_N_Op_Shift_Left (N);\n+                  when N_Op_Shift_Left =>\n+                     Expand_N_Op_Shift_Left (N);\n \n-               when N_Op_Shift_Right =>\n-                  Expand_N_Op_Shift_Right (N);\n+                  when N_Op_Shift_Right =>\n+                     Expand_N_Op_Shift_Right (N);\n \n-               when N_Op_Shift_Right_Arithmetic =>\n-                  Expand_N_Op_Shift_Right_Arithmetic (N);\n+                  when N_Op_Shift_Right_Arithmetic =>\n+                     Expand_N_Op_Shift_Right_Arithmetic (N);\n \n-               when N_Op_Subtract =>\n-                  Expand_N_Op_Subtract (N);\n+                  when N_Op_Subtract =>\n+                     Expand_N_Op_Subtract (N);\n \n-               when N_Op_Xor =>\n-                  Expand_N_Op_Xor (N);\n+                  when N_Op_Xor =>\n+                     Expand_N_Op_Xor (N);\n \n-               when N_Or_Else =>\n-                  Expand_N_Or_Else (N);\n+                  when N_Or_Else =>\n+                     Expand_N_Or_Else (N);\n \n-               when N_Package_Body =>\n-                  Expand_N_Package_Body (N);\n+                  when N_Package_Body =>\n+                     Expand_N_Package_Body (N);\n \n-               when N_Package_Declaration =>\n-                  Expand_N_Package_Declaration (N);\n+                  when N_Package_Declaration =>\n+                     Expand_N_Package_Declaration (N);\n \n-               when N_Package_Renaming_Declaration =>\n-                  Expand_N_Package_Renaming_Declaration (N);\n+                  when N_Package_Renaming_Declaration =>\n+                     Expand_N_Package_Renaming_Declaration (N);\n \n-               when N_Subprogram_Renaming_Declaration =>\n-                  Expand_N_Subprogram_Renaming_Declaration (N);\n+                  when N_Subprogram_Renaming_Declaration =>\n+                     Expand_N_Subprogram_Renaming_Declaration (N);\n \n-               when N_Pragma =>\n-                  Expand_N_Pragma (N);\n+                  when N_Pragma =>\n+                     Expand_N_Pragma (N);\n \n-               when N_Procedure_Call_Statement =>\n-                  Expand_N_Procedure_Call_Statement (N);\n+                  when N_Procedure_Call_Statement =>\n+                     Expand_N_Procedure_Call_Statement (N);\n \n-               when N_Protected_Type_Declaration =>\n-                  Expand_N_Protected_Type_Declaration (N);\n+                  when N_Protected_Type_Declaration =>\n+                     Expand_N_Protected_Type_Declaration (N);\n \n-               when N_Protected_Body =>\n-                  Expand_N_Protected_Body (N);\n+                  when N_Protected_Body =>\n+                     Expand_N_Protected_Body (N);\n \n-               when N_Qualified_Expression =>\n-                  Expand_N_Qualified_Expression (N);\n+                  when N_Qualified_Expression =>\n+                     Expand_N_Qualified_Expression (N);\n \n-               when N_Quantified_Expression  =>\n-                  Expand_N_Quantified_Expression (N);\n+                  when N_Quantified_Expression  =>\n+                     Expand_N_Quantified_Expression (N);\n \n-               when N_Raise_Statement =>\n-                  Expand_N_Raise_Statement (N);\n+                  when N_Raise_Statement =>\n+                     Expand_N_Raise_Statement (N);\n \n-               when N_Raise_Constraint_Error =>\n-                  Expand_N_Raise_Constraint_Error (N);\n+                  when N_Raise_Constraint_Error =>\n+                     Expand_N_Raise_Constraint_Error (N);\n \n-               when N_Raise_Program_Error =>\n-                  Expand_N_Raise_Program_Error (N);\n+                  when N_Raise_Program_Error =>\n+                     Expand_N_Raise_Program_Error (N);\n \n-               when N_Raise_Storage_Error =>\n-                  Expand_N_Raise_Storage_Error (N);\n+                  when N_Raise_Storage_Error =>\n+                     Expand_N_Raise_Storage_Error (N);\n \n-               when N_Real_Literal =>\n-                  Expand_N_Real_Literal (N);\n+                  when N_Real_Literal =>\n+                     Expand_N_Real_Literal (N);\n \n-               when N_Record_Representation_Clause =>\n-                  Expand_N_Record_Representation_Clause (N);\n+                  when N_Record_Representation_Clause =>\n+                     Expand_N_Record_Representation_Clause (N);\n \n-               when N_Requeue_Statement =>\n-                  Expand_N_Requeue_Statement (N);\n+                  when N_Requeue_Statement =>\n+                     Expand_N_Requeue_Statement (N);\n \n-               when N_Simple_Return_Statement =>\n-                  Expand_N_Simple_Return_Statement (N);\n+                  when N_Simple_Return_Statement =>\n+                     Expand_N_Simple_Return_Statement (N);\n \n-               when N_Selected_Component =>\n-                  Expand_N_Selected_Component (N);\n+                  when N_Selected_Component =>\n+                     Expand_N_Selected_Component (N);\n \n-               when N_Selective_Accept =>\n-                  Expand_N_Selective_Accept (N);\n+                  when N_Selective_Accept =>\n+                     Expand_N_Selective_Accept (N);\n \n-               when N_Single_Task_Declaration =>\n-                  Expand_N_Single_Task_Declaration (N);\n+                  when N_Single_Task_Declaration =>\n+                     Expand_N_Single_Task_Declaration (N);\n \n-               when N_Slice =>\n-                  Expand_N_Slice (N);\n+                  when N_Slice =>\n+                     Expand_N_Slice (N);\n \n-               when N_Subtype_Indication =>\n-                  Expand_N_Subtype_Indication (N);\n+                  when N_Subtype_Indication =>\n+                     Expand_N_Subtype_Indication (N);\n \n-               when N_Subprogram_Body =>\n-                  Expand_N_Subprogram_Body (N);\n+                  when N_Subprogram_Body =>\n+                     Expand_N_Subprogram_Body (N);\n \n-               when N_Subprogram_Body_Stub =>\n-                  Expand_N_Subprogram_Body_Stub (N);\n+                  when N_Subprogram_Body_Stub =>\n+                     Expand_N_Subprogram_Body_Stub (N);\n \n-               when N_Subprogram_Declaration =>\n-                  Expand_N_Subprogram_Declaration (N);\n+                  when N_Subprogram_Declaration =>\n+                     Expand_N_Subprogram_Declaration (N);\n \n-               when N_Subprogram_Info =>\n-                  Expand_N_Subprogram_Info (N);\n+                  when N_Subprogram_Info =>\n+                     Expand_N_Subprogram_Info (N);\n \n-               when N_Task_Body =>\n-                  Expand_N_Task_Body (N);\n+                  when N_Task_Body =>\n+                     Expand_N_Task_Body (N);\n \n-               when N_Task_Type_Declaration =>\n-                  Expand_N_Task_Type_Declaration (N);\n+                  when N_Task_Type_Declaration =>\n+                     Expand_N_Task_Type_Declaration (N);\n \n-               when N_Timed_Entry_Call =>\n-                  Expand_N_Timed_Entry_Call (N);\n+                  when N_Timed_Entry_Call =>\n+                     Expand_N_Timed_Entry_Call (N);\n \n-               when N_Type_Conversion =>\n-                  Expand_N_Type_Conversion (N);\n+                  when N_Type_Conversion =>\n+                     Expand_N_Type_Conversion (N);\n \n-               when N_Unchecked_Expression =>\n-                  Expand_N_Unchecked_Expression (N);\n+                  when N_Unchecked_Expression =>\n+                     Expand_N_Unchecked_Expression (N);\n \n-               when N_Unchecked_Type_Conversion =>\n-                  Expand_N_Unchecked_Type_Conversion (N);\n+                  when N_Unchecked_Type_Conversion =>\n+                     Expand_N_Unchecked_Type_Conversion (N);\n \n-               when N_Variant_Part =>\n-                  Expand_N_Variant_Part (N);\n+                  when N_Variant_Part =>\n+                     Expand_N_Variant_Part (N);\n \n-               --  For all other node kinds, no expansion activity is required\n+                  --  For all other node kinds, no expansion activity required\n \n-               when others => null;\n+                  when others =>\n+                     null;\n \n                end case;\n-\n             end if;\n \n          exception"}, {"sha": "aa92773b009eca63547b0ba876223f1978f8dd98", "filename": "gcc/ada/s-mudido-affinity.adb", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-mudido-affinity.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-mudido-affinity.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mudido-affinity.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -45,8 +45,8 @@ package body System.Multiprocessors.Dispatching_Domains is\n    -- Local data --\n    ----------------\n \n-   Dispatching_Domain_Tasks :\n-     array (CPU'First .. Number_Of_CPUs) of Natural := (others => 0);\n+   Dispatching_Domain_Tasks : array (CPU'First .. Number_Of_CPUs) of Natural :=\n+                                (others => 0);\n    --  We need to store whether there are tasks allocated to concrete\n    --  processors in the default system dispatching domain because we need to\n    --  check it before creating a new dispatching domain.\n@@ -88,7 +88,7 @@ package body System.Multiprocessors.Dispatching_Domains is\n      (Domain : in out Dispatching_Domain;\n       CPU    : CPU_Range := Not_A_Specific_CPU;\n       T      : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n+                 Ada.Task_Identification.Current_Task)\n    is\n       Target : constant ST.Task_Id := Convert_Ids (T);\n \n@@ -135,13 +135,15 @@ package body System.Multiprocessors.Dispatching_Domains is\n       use type System.Tasking.Task_Id;\n \n       Valid_System_Domain : constant Boolean :=\n-        (First > CPU'First and then\n-           not (System_Dispatching_Domain (CPU'First .. First - 1) =\n-                (CPU'First .. First - 1 => False)))\n-          or else\n-        (Last < Number_Of_CPUs and then\n-           not (System_Dispatching_Domain (Last + 1 .. Number_Of_CPUs) =\n-                (Last + 1 .. Number_Of_CPUs => False)));\n+        (First > CPU'First\n+          and then\n+            not (System_Dispatching_Domain (CPU'First .. First - 1) =\n+                                         (CPU'First .. First - 1 => False)))\n+                  or else (Last < Number_Of_CPUs\n+                            and then not\n+                              (System_Dispatching_Domain\n+                                (Last + 1 .. Number_Of_CPUs) =\n+                                  (Last + 1 .. Number_Of_CPUs => False)));\n       --  Constant that indicates whether there would exist a non-empty system\n       --  dispatching domain after the creation of this dispatching domain.\n \n@@ -231,7 +233,9 @@ package body System.Multiprocessors.Dispatching_Domains is\n    -----------------------------\n \n    procedure Delay_Until_And_Set_CPU\n-     (Delay_Until_Time : Ada.Real_Time.Time; CPU : CPU_Range) is\n+     (Delay_Until_Time : Ada.Real_Time.Time;\n+      CPU              : CPU_Range)\n+   is\n    begin\n       --  Not supported atomically by the underlying operating systems.\n       --  Operating systems use to migrate the task immediately after the call\n@@ -258,8 +262,8 @@ package body System.Multiprocessors.Dispatching_Domains is\n \n    function Get_CPU\n      (T : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n-      return CPU_Range is\n+            Ada.Task_Identification.Current_Task) return CPU_Range\n+   is\n    begin\n       return Convert_Ids (T).Common.Base_CPU;\n    end Get_CPU;\n@@ -270,8 +274,8 @@ package body System.Multiprocessors.Dispatching_Domains is\n \n    function Get_Dispatching_Domain\n      (T : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n-      return Dispatching_Domain is\n+            Ada.Task_Identification.Current_Task) return Dispatching_Domain\n+   is\n    begin\n       return Dispatching_Domain (Convert_Ids (T).Common.Domain);\n    end Get_Dispatching_Domain;\n@@ -317,7 +321,7 @@ package body System.Multiprocessors.Dispatching_Domains is\n    procedure Set_CPU\n      (CPU : CPU_Range;\n       T   : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n+              Ada.Task_Identification.Current_Task)\n    is\n       Target : constant ST.Task_Id := Convert_Ids (T);\n \n@@ -366,8 +370,8 @@ package body System.Multiprocessors.Dispatching_Domains is\n       --  Change the number of tasks attached to a given task in the system\n       --  domain if needed.\n \n-      if not Dispatching_Domains_Frozen and then\n-        (Domain = null or else Domain = ST.System_Domain)\n+      if not Dispatching_Domains_Frozen\n+        and then (Domain = null or else Domain = ST.System_Domain)\n       then\n          --  Reduce the number of tasks attached to the CPU from which this\n          --  task is being moved, if needed."}, {"sha": "990a7bc63421c1fed6883b9a6de1b318b168717b", "filename": "gcc/ada/s-mudido.adb", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-mudido.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-mudido.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mudido.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -54,10 +54,9 @@ package body System.Multiprocessors.Dispatching_Domains is\n      (Domain : in out Dispatching_Domain;\n       CPU    : CPU_Range := Not_A_Specific_CPU;\n       T      : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n+                 Ada.Task_Identification.Current_Task)\n    is\n       pragma Unreferenced (Domain, CPU, T);\n-\n    begin\n       raise Dispatching_Domain_Error with \"dispatching domains not supported\";\n    end Assign_Task;\n@@ -68,7 +67,6 @@ package body System.Multiprocessors.Dispatching_Domains is\n \n    function Create (First, Last : CPU) return Dispatching_Domain is\n       pragma Unreferenced (First, Last);\n-\n    begin\n       raise Dispatching_Domain_Error with \"dispatching domains not supported\";\n       return System_Dispatching_Domain;\n@@ -79,10 +77,10 @@ package body System.Multiprocessors.Dispatching_Domains is\n    -----------------------------\n \n    procedure Delay_Until_And_Set_CPU\n-     (Delay_Until_Time : Ada.Real_Time.Time; CPU : CPU_Range)\n+     (Delay_Until_Time : Ada.Real_Time.Time;\n+      CPU              : CPU_Range)\n    is\n       pragma Unreferenced (Delay_Until_Time, CPU);\n-\n    begin\n       raise Dispatching_Domain_Error with \"dispatching domains not supported\";\n    end Delay_Until_And_Set_CPU;\n@@ -102,11 +100,9 @@ package body System.Multiprocessors.Dispatching_Domains is\n \n    function Get_CPU\n      (T : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n-      return CPU_Range\n+            Ada.Task_Identification.Current_Task) return CPU_Range\n    is\n       pragma Unreferenced (T);\n-\n    begin\n       return Not_A_Specific_CPU;\n    end Get_CPU;\n@@ -117,11 +113,9 @@ package body System.Multiprocessors.Dispatching_Domains is\n \n    function Get_Dispatching_Domain\n      (T : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n-      return Dispatching_Domain\n+            Ada.Task_Identification.Current_Task) return Dispatching_Domain\n    is\n       pragma Unreferenced (T);\n-\n    begin\n       return System_Dispatching_Domain;\n    end Get_Dispatching_Domain;\n@@ -132,7 +126,6 @@ package body System.Multiprocessors.Dispatching_Domains is\n \n    function Get_First_CPU (Domain : Dispatching_Domain) return CPU is\n       pragma Unreferenced (Domain);\n-\n    begin\n       return CPU'First;\n    end Get_First_CPU;\n@@ -143,7 +136,6 @@ package body System.Multiprocessors.Dispatching_Domains is\n \n    function Get_Last_CPU (Domain : Dispatching_Domain) return CPU is\n       pragma Unreferenced (Domain);\n-\n    begin\n       return Number_Of_CPUs;\n    end Get_Last_CPU;\n@@ -155,10 +147,9 @@ package body System.Multiprocessors.Dispatching_Domains is\n    procedure Set_CPU\n      (CPU : CPU_Range;\n       T   : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n+              Ada.Task_Identification.Current_Task)\n    is\n       pragma Unreferenced (CPU, T);\n-\n    begin\n       raise Dispatching_Domain_Error with \"dispatching domains not supported\";\n    end Set_CPU;"}, {"sha": "635a847d2024ef17d6519715914e51015f96df63", "filename": "gcc/ada/s-mudido.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-mudido.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-mudido.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mudido.ads?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -39,31 +39,31 @@ package System.Multiprocessors.Dispatching_Domains is\n \n    function Get_Dispatching_Domain\n      (T : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n-      return Dispatching_Domain;\n+            Ada.Task_Identification.Current_Task) return Dispatching_Domain;\n \n    procedure Assign_Task\n      (Domain : in out Dispatching_Domain;\n       CPU    : CPU_Range := Not_A_Specific_CPU;\n       T      : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task);\n+                 Ada.Task_Identification.Current_Task);\n \n    procedure Set_CPU\n      (CPU : CPU_Range;\n       T   : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task);\n+              Ada.Task_Identification.Current_Task);\n \n    function Get_CPU\n      (T : Ada.Task_Identification.Task_Id :=\n-        Ada.Task_Identification.Current_Task)\n-      return CPU_Range;\n+            Ada.Task_Identification.Current_Task) return CPU_Range;\n \n    procedure Delay_Until_And_Set_CPU\n-     (Delay_Until_Time : Ada.Real_Time.Time; CPU : CPU_Range);\n+     (Delay_Until_Time : Ada.Real_Time.Time;\n+      CPU              : CPU_Range);\n \n private\n    type Dispatching_Domain is new System.Tasking.Dispatching_Domain_Access;\n \n    System_Dispatching_Domain : constant Dispatching_Domain :=\n-     Dispatching_Domain (System.Tasking.System_Domain);\n+                                 Dispatching_Domain\n+                                   (System.Tasking.System_Domain);\n end System.Multiprocessors.Dispatching_Domains;"}, {"sha": "6bc89fc087ae86ef6a3a6b1c7869a1bd62f8ce88", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1247,6 +1247,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_Task_Affinity (T : ST.Task_Id) is\n       pragma Unreferenced (T);\n+\n    begin\n       --  Setting task affinity is not supported by the underlying system\n "}, {"sha": "bfa425e9b45ebeea57ee93f920778b16af6fff53", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1348,6 +1348,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_Task_Affinity (T : ST.Task_Id) is\n       pragma Unreferenced (T);\n+\n    begin\n       --  Setting task affinity is not supported by the underlying system\n "}, {"sha": "6b3eb0b3ec22f3132c088d2eddd21290ed31955c", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -885,6 +885,7 @@ package body System.Task_Primitives.Operations is\n       elsif T.Common.Domain /= null then\n          declare\n             CPU_Set : aliased cpu_set_t := (bits => (others => False));\n+\n          begin\n             --  Set the affinity to all the processors belonging to the\n             --  dispatching domain.\n@@ -1365,7 +1366,6 @@ package body System.Task_Primitives.Operations is\n       if pthread_setaffinity_np'Address /= System.Null_Address then\n          declare\n             CPU_Set : access cpu_set_t := null;\n-\n             Result  : Interfaces.C.int;\n \n          begin\n@@ -1374,6 +1374,7 @@ package body System.Task_Primitives.Operations is\n             --  domain, if any.\n \n             if T.Common.Base_CPU /= Multiprocessors.Not_A_Specific_CPU then\n+\n                --  Set the affinity to an unique CPU\n \n                CPU_Set := new cpu_set_t'(bits => (others => False));\n@@ -1389,9 +1390,10 @@ package body System.Task_Primitives.Operations is\n             --  Handle dispatching domains\n \n             elsif T.Common.Domain /= null and then\n-              (T.Common.Domain /= ST.System_Domain or else\n-               T.Common.Domain.all /= (Multiprocessors.CPU'First ..\n-                                       Multiprocessors.Number_Of_CPUs => True))\n+              (T.Common.Domain /= ST.System_Domain\n+                or else T.Common.Domain.all /=\n+                          (Multiprocessors.CPU'First ..\n+                           Multiprocessors.Number_Of_CPUs => True))\n             then\n                --  Set the affinity to all the processors belonging to the\n                --  dispatching domain. To avoid changing CPU affinities when\n@@ -1414,9 +1416,7 @@ package body System.Task_Primitives.Operations is\n             if CPU_Set /= null then\n                Result :=\n                  pthread_setaffinity_np\n-                   (T.Common.LL.Thread,\n-                    CPU_SETSIZE / 8,\n-                    CPU_Set);\n+                   (T.Common.LL.Thread, CPU_SETSIZE / 8, CPU_Set);\n                pragma Assert (Result = 0);\n             end if;\n          end;"}, {"sha": "4d31ca1aa2f815e08c590013508a3f54adc52b7f", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1187,6 +1187,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_True (S : in out Suspension_Object) is\n       Result : BOOL;\n+\n    begin\n       SSL.Abort_Defer.all;\n \n@@ -1203,6 +1204,7 @@ package body System.Task_Primitives.Operations is\n \n          Result := SetEvent (S.CV);\n          pragma Assert (Result = Win32.TRUE);\n+\n       else\n          S.State := True;\n       end if;\n@@ -1226,6 +1228,7 @@ package body System.Task_Primitives.Operations is\n       EnterCriticalSection (S.L'Access);\n \n       if S.Waiting then\n+\n          --  Program_Error must be raised upon calling Suspend_Until_True\n          --  if another task is already waiting on that suspension object\n          --  (ARM D.10 par. 10).\n@@ -1235,6 +1238,7 @@ package body System.Task_Primitives.Operations is\n          SSL.Abort_Undefer.all;\n \n          raise Program_Error;\n+\n       else\n          --  Suspend the task if the state is False. Otherwise, the task\n          --  continues its execution, and the state of the suspension object\n@@ -1246,6 +1250,7 @@ package body System.Task_Primitives.Operations is\n             LeaveCriticalSection (S.L'Access);\n \n             SSL.Abort_Undefer.all;\n+\n          else\n             S.Waiting := True;\n \n@@ -1268,8 +1273,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_Exit --\n    ----------------\n \n-   --  Dummy versions.  The only currently working versions is for solaris\n-   --  (native).\n+   --  Dummy versions, currently this only works for solaris (native)\n \n    function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n@@ -1365,8 +1369,9 @@ package body System.Task_Primitives.Operations is\n          --  The CPU numbering in pragma CPU starts at 1 while the subprogram\n          --  to set the affinity starts at 0, therefore we must substract 1.\n \n-         Result := SetThreadIdealProcessor\n-           (T.Common.LL.Thread, ProcessorId (T.Common.Base_CPU) - 1);\n+         Result :=\n+           SetThreadIdealProcessor\n+             (T.Common.LL.Thread, ProcessorId (T.Common.Base_CPU) - 1);\n          pragma Assert (Result = 1);\n \n       --  Task_Info\n@@ -1381,17 +1386,20 @@ package body System.Task_Primitives.Operations is\n \n       --  Dispatching domains\n \n-      elsif T.Common.Domain /= null and then\n-              (T.Common.Domain /= ST.System_Domain or else\n-               T.Common.Domain.all /= (Multiprocessors.CPU'First ..\n-                                       Multiprocessors.Number_Of_CPUs => True))\n+      elsif T.Common.Domain /= null\n+        and then (T.Common.Domain /= ST.System_Domain\n+                   or else\n+                     T.Common.Domain.all /=\n+                       (Multiprocessors.CPU'First ..\n+                        Multiprocessors.Number_Of_CPUs => True))\n       then\n          declare\n             CPU_Set : DWORD := 0;\n \n          begin\n             for Proc in T.Common.Domain'Range loop\n                if T.Common.Domain (Proc) then\n+\n                   --  The thread affinity mask is a bit vector in which each\n                   --  bit represents a logical processor.\n "}, {"sha": "440d94149b98f95e8cc9acd51c0cfd12588bc7cf", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1455,6 +1455,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_Task_Affinity (T : ST.Task_Id) is\n       pragma Unreferenced (T);\n+\n    begin\n       --  Setting task affinity is not supported by the underlying system\n "}, {"sha": "278b32c1101aa4566f4daf6f5315973632dfb485", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1947,7 +1947,7 @@ package body System.Task_Primitives.Operations is\n       --  pragma CPU\n \n       if T.Common.Base_CPU /=\n-        System.Multiprocessors.Not_A_Specific_CPU\n+           System.Multiprocessors.Not_A_Specific_CPU\n       then\n          --  The CPU numbering in pragma CPU starts at 1 while the subprogram\n          --  to set the affinity starts at 0, therefore we must substract 1.\n@@ -1968,6 +1968,7 @@ package body System.Task_Primitives.Operations is\n \n             if T.Common.Task_Info.CPU = ANY_CPU then\n                Result := 0;\n+\n                Proc := 0;\n                while Proc < Last_Proc loop\n                   Result := p_online (Proc, PR_STATUS);\n@@ -1988,6 +1989,7 @@ package body System.Task_Primitives.Operations is\n                then\n                   raise Invalid_CPU_Number;\n                end if;\n+\n                Result :=\n                  processor_bind\n                    (P_LWPID, id_t (T.Common.LL.LWP),\n@@ -1998,15 +2000,15 @@ package body System.Task_Primitives.Operations is\n \n       --  Handle dispatching domains\n \n-      elsif T.Common.Domain /= null and then\n-              (T.Common.Domain /= ST.System_Domain or else\n-               T.Common.Domain.all /= (Multiprocessors.CPU'First ..\n-                                       Multiprocessors.Number_Of_CPUs => True))\n+      elsif T.Common.Domain /= null\n+        and then (T.Common.Domain /= ST.System_Domain\n+                   or else T.Common.Domain.all /=\n+                             (Multiprocessors.CPU'First ..\n+                              Multiprocessors.Number_Of_CPUs => True))\n       then\n          declare\n             CPU_Set : aliased psetid_t;\n-\n-            Result : int;\n+            Result  : int;\n \n          begin\n             Result := pset_create (CPU_Set'Access);\n@@ -2016,9 +2018,9 @@ package body System.Task_Primitives.Operations is\n             --  dispatching domain.\n \n             for Proc in T.Common.Domain'Range loop\n+\n                --  The Ada CPU numbering starts at 1 while the subprogram to\n-               --  set the affinity starts at 0, therefore we must substract\n-               --  1.\n+               --  set the affinity starts at 0, therefore we must substract 1.\n \n                if T.Common.Domain (Proc) then\n                   Result :="}, {"sha": "2fe24419f3d5033be1cd77d072e504ad74da916b", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1361,6 +1361,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_Task_Affinity (T : ST.Task_Id) is\n       pragma Unreferenced (T);\n+\n    begin\n       --  Setting task affinity is not supported by the underlying system\n "}, {"sha": "1cfafbbb55ac9f27e01b0ca3ef9f4639fabc9c9a", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1260,6 +1260,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Set_Task_Affinity (T : ST.Task_Id) is\n       pragma Unreferenced (T);\n+\n    begin\n       --  Setting task affinity is not supported by the underlying system\n "}, {"sha": "068e5eb649c81375d8db1612ce6358a933592892", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1411,9 +1411,9 @@ package body System.Task_Primitives.Operations is\n       --  pragma CPU\n \n       if T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n-         --  Ada 2012 pragma CPU uses CPU numbers starting from 1, while\n-         --  on VxWorks the first CPU is identified by a 0, so we need to\n-         --  adjust.\n+\n+         --  Ada 2012 pragma CPU uses CPU numbers starting from 1, while on\n+         --  VxWorks the first CPU is identified by a 0, so we need to adjust.\n \n          Result :=\n            taskCpuAffinitySet\n@@ -1422,33 +1422,34 @@ package body System.Task_Primitives.Operations is\n       --  Task_Info\n \n       elsif T.Common.Task_Info /= Unspecified_Task_Info then\n-         Result :=\n-           taskCpuAffinitySet (T.Common.LL.Thread, T.Common.Task_Info);\n+         Result := taskCpuAffinitySet (T.Common.LL.Thread, T.Common.Task_Info);\n \n       --  Handle dispatching domains\n \n-      elsif T.Common.Domain /= null and then\n-              (T.Common.Domain /= ST.System_Domain or else\n-               T.Common.Domain.all /= (Multiprocessors.CPU'First ..\n-                                       Multiprocessors.Number_Of_CPUs => True))\n+      elsif T.Common.Domain /= null\n+        and then (T.Common.Domain /= ST.System_Domain\n+                   or else T.Common.Domain.all /=\n+                             (Multiprocessors.CPU'First ..\n+                              Multiprocessors.Number_Of_CPUs => True))\n       then\n          declare\n             CPU_Set : unsigned := 0;\n+\n          begin\n             --  Set the affinity to all the processors belonging to the\n             --  dispatching domain.\n \n             for Proc in T.Common.Domain'Range loop\n                if T.Common.Domain (Proc) then\n+\n                   --  The thread affinity mask is a bit vector in which each\n                   --  bit represents a logical processor.\n \n                   CPU_Set := CPU_Set + 2 ** (Integer (Proc) - 1);\n                end if;\n             end loop;\n \n-            Result :=\n-              taskMaskAffinitySet (T.Common.LL.Thread, CPU_Set);\n+            Result := taskMaskAffinitySet (T.Common.LL.Thread, CPU_Set);\n          end;\n       end if;\n    end Set_Task_Affinity;"}, {"sha": "feb6f558c1fb7bf7d5cdfe8e9a021954b9299480", "filename": "gcc/ada/s-taprop.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taprop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop.ads?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -549,6 +549,7 @@ package System.Task_Primitives.Operations is\n \n    procedure Set_Task_Affinity (T : ST.Task_Id);\n    --  Enforce at the operating system level the task affinity defined in the\n-   --  Ada Task Control Block.\n+   --  Ada Task Control Block. Has no effect if the underlying operating system\n+   --  does not support this capability.\n \n end System.Task_Primitives.Operations;"}, {"sha": "01a4a465097d54530535abef54ee463982528e8e", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -224,8 +224,10 @@ package body System.Tasking is\n       --  into account. Use Number_Of_CPUs to know the exact number of\n       --  processors in the system at execution time.\n \n-      System_Domain := new Dispatching_Domain'\n-        (Multiprocessors.CPU'First .. Multiprocessors.Number_Of_CPUs => True);\n+      System_Domain :=\n+        new Dispatching_Domain'\n+          (Multiprocessors.CPU'First .. Multiprocessors.Number_Of_CPUs =>\n+             True);\n \n       T.Common.Domain := System_Domain;\n "}, {"sha": "47d9caca0e945a1407567bcfb66fbfb3465416dd", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -394,8 +394,7 @@ package System.Tasking is\n    type Dispatching_Domain_Access is access Dispatching_Domain;\n \n    System_Domain : Dispatching_Domain_Access;\n-   --  All processors belong to the default system dispatching domain at start\n-   --  up.\n+   --  All processors belong to default system dispatching domain at start up\n \n    ------------------------------------\n    -- Task related other definitions --\n@@ -419,18 +418,17 @@ package System.Tasking is\n \n    function Storage_Size (T : Task_Id) return System.Parameters.Size_Type;\n    --  Retrieve from the TCB of the task the allocated size of its stack,\n-   --  either the system default or the size specified by a pragma. This\n-   --  is in general a non-static value that can depend on discriminants\n-   --  of the task.\n+   --  either the system default or the size specified by a pragma. This is in\n+   --  general a non-static value that can depend on discriminants of the task.\n \n    type Bit_Array is array (Integer range <>) of Boolean;\n    pragma Pack (Bit_Array);\n \n    subtype Debug_Event_Array is Bit_Array (1 .. 16);\n \n    Global_Task_Debug_Event_Set : Boolean := False;\n-   --  Set True when running under debugger control and a task debug\n-   --  event signal has been requested.\n+   --  Set True when running under debugger control and a task debug event\n+   --  signal has been requested.\n \n    ----------------------------------------------\n    -- Ada_Task_Control_Block (ATCB) definition --"}, {"sha": "951f2184c669501585d5c7ba815427bc070fd040", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -2250,15 +2250,13 @@ package body Sem_Ch5 is\n          Analyze (Subt);\n       end if;\n \n-      --  If the domain of iteration is an expression, create a declaration\n-      --  for it, so that finalization actions are introduced outside of the\n-      --  loop.\n+      --  If domain of iteration is an expression, create a declaration for it,\n+      --  so that finalization actions are introduced outside of the loop.\n \n       if not Is_Entity_Name (Iter_Name) then\n          declare\n-            Id : constant Entity_Id := Make_Temporary (Loc, 'R', Iter_Name);\n-\n-            Decl   : Node_Id;\n+            Id   : constant Entity_Id := Make_Temporary (Loc, 'R', Iter_Name);\n+            Decl : Node_Id;\n \n          begin\n             Typ := Etype (Iter_Name);"}, {"sha": "3ef284e54c235484836feb7eb303fa5229dd00c3", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -8101,8 +8101,8 @@ package body Sem_Res is\n          Resolve (Condition (N), Typ);\n          Expander_Mode_Restore;\n \n-      --  In ALFA mode, we need expansion in order to introduce properly the\n-      --  necessary transient scopes.\n+      --  In ALFA mode, we need normal expansion in order to properly introduce\n+      --  the necessary transient scopes.\n \n       else\n          Resolve (Condition (N), Typ);"}, {"sha": "5cde2a2e160bd4ad100b07986569e83fd3660390", "filename": "gcc/ada/vms_conv.adb", "status": "modified", "additions": 37, "deletions": 50, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cda9727babdc93f846191782dcc4c0cdba25d26/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=7cda9727babdc93f846191782dcc4c0cdba25d26", "patch": "@@ -1804,8 +1804,8 @@ package body VMS_Conv is\n                      --  because the corresponding switch --unchecked... is\n                      --  for gnatmake, not for the compiler.\n \n-                     if Cargs and then\n-                       Sw.Name.all = \"/UNCHECKED_SHARED_LIB_IMPORTS\"\n+                     if Cargs\n+                       and then Sw.Name.all = \"/UNCHECKED_SHARED_LIB_IMPORTS\"\n                      then\n                         Cargs := False;\n                      end if;\n@@ -1825,6 +1825,7 @@ package body VMS_Conv is\n                      case Sw.Translation is\n                         when T_Direct =>\n                            Place_Unix_Switches (Sw.Unix_String);\n+\n                            if SwP < Arg'Last\n                              and then Arg (SwP + 1) = '='\n                            then\n@@ -1863,8 +1864,8 @@ package body VMS_Conv is\n                                  Arg_Idx := Argv'First;\n                                  Next_Arg_Idx :=\n                                    Get_Arg_End (Argv.all, Arg_Idx);\n-                                 Arg := new String'\n-                                   (Argv (Arg_Idx .. Next_Arg_Idx));\n+                                 Arg :=\n+                                   new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n                                  goto Tryagain_After_Coalesce;\n                               end if;\n \n@@ -1892,9 +1893,8 @@ package body VMS_Conv is\n                                  while P2 < Endp\n                                    and then Arg (P2 + 1) /= ','\n                                  loop\n-                                    --  A wildcard directory spec on\n-                                    --  VMS will contain either * or\n-                                    --  % or ...\n+                                    --  A wildcard directory spec on VMS will\n+                                    --  contain either * or % or ...\n \n                                     if Arg (P2) = '*' then\n                                        Dir_Is_Wild := True;\n@@ -1928,15 +1928,12 @@ package body VMS_Conv is\n                                         (Arg (SwP .. P2), True);\n \n                                     for J in Dir_List.all'Range loop\n-                                       Place_Unix_Switches\n-                                         (Sw.Unix_String);\n-                                       Place_Lower\n-                                         (Dir_List.all (J).all);\n+                                       Place_Unix_Switches (Sw.Unix_String);\n+                                       Place_Lower (Dir_List.all (J).all);\n                                     end loop;\n \n                                  else\n-                                    Place_Unix_Switches\n-                                      (Sw.Unix_String);\n+                                    Place_Unix_Switches (Sw.Unix_String);\n                                     Place_Lower\n                                       (To_Canonical_Dir_Spec\n                                          (Arg (SwP .. P2), False).all);\n@@ -1956,37 +1953,33 @@ package body VMS_Conv is\n                            else\n                               Place_Unix_Switches (Sw.Unix_String);\n \n-                              --  Some switches end in \"=\". No space\n-                              --  here\n+                              --  Some switches end in \"=\", no space here\n \n                               if Sw.Unix_String\n-                                (Sw.Unix_String'Last) /= '='\n+                                      (Sw.Unix_String'Last) /= '='\n                               then\n                                  Place (' ');\n                               end if;\n \n                               Place_Lower\n                                 (To_Canonical_Dir_Spec\n-                                   (Arg (SwP + 2 .. Arg'Last),\n-                                    False).all);\n+                                   (Arg (SwP + 2 .. Arg'Last), False).all);\n                            end if;\n \n                         when T_File | T_No_Space_File =>\n                            if SwP + 2 > Arg'Last then\n-                              Put (Standard_Error,\n-                                   \"missing file for: \");\n+                              Put (Standard_Error, \"missing file for: \");\n                               Put_Line (Standard_Error, Arg.all);\n                               Errors := Errors + 1;\n \n                            else\n                               Place_Unix_Switches (Sw.Unix_String);\n \n-                              --  Some switches end in \"=\". No space\n-                              --  here.\n+                              --  Some switches end in \"=\", no space here.\n \n                               if Sw.Translation = T_File\n                                 and then Sw.Unix_String\n-                                  (Sw.Unix_String'Last) /= '='\n+                                           (Sw.Unix_String'Last) /= '='\n                               then\n                                  Place (' ');\n                               end if;\n@@ -2004,14 +1997,13 @@ package body VMS_Conv is\n                            else\n                               Put (Standard_Error, \"argument for \");\n                               Put (Standard_Error, Sw.Name.all);\n-                              Put_Line\n-                                (Standard_Error, \" must be numeric\");\n+                              Put_Line (Standard_Error, \" must be numeric\");\n                               Errors := Errors + 1;\n                            end if;\n \n                         when T_Alphanumplus =>\n                            if OK_Alphanumerplus\n-                             (Arg (SwP + 2 .. Arg'Last))\n+                                (Arg (SwP + 2 .. Arg'Last))\n                            then\n                               Place_Unix_Switches (Sw.Unix_String);\n                               Place (Arg (SwP + 2 .. Arg'Last));\n@@ -2026,28 +2018,28 @@ package body VMS_Conv is\n \n                         when T_String =>\n \n-                           --  A String value must be extended to the\n-                           --  end of the Argv, otherwise strings like\n-                           --  \"foo/bar\" get split at the slash.\n+                           --  A String value must be extended to the end of\n+                           --  the Argv, otherwise strings like \"foo/bar\" get\n+                           --  split at the slash.\n \n-                           --  The beginning and ending of the string\n-                           --  are flagged with embedded nulls which\n-                           --  are removed when building the Spawn\n-                           --  call. Nulls are use because they won't\n-                           --  show up in a /? output. Quotes aren't\n-                           --  used because that would make it\n+                           --  The beginning and ending of the string are\n+                           --  flagged with embedded nulls which are removed\n+                           --  when building the Spawn call. Nulls are use\n+                           --  because they won't show up in a /? output.\n+                           --  Quotes aren't used because that would make it\n                            --  difficult to embed them.\n \n                            Place_Unix_Switches (Sw.Unix_String);\n \n                            if Next_Arg_Idx /= Argv'Last then\n                               Next_Arg_Idx := Argv'Last;\n-                              Arg := new String'\n-                                (Argv (Arg_Idx .. Next_Arg_Idx));\n+                              Arg :=\n+                                new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n \n                               SwP := Arg'First;\n-                              while SwP < Arg'Last and then\n-                              Arg (SwP + 1) /= '=' loop\n+                              while SwP < Arg'Last\n+                                and then Arg (SwP + 1) /= '='\n+                              loop\n                                  SwP := SwP + 1;\n                               end loop;\n                            end if;\n@@ -2072,10 +2064,9 @@ package body VMS_Conv is\n                               Make_Commands_Active := null;\n \n                            else\n-                              --  Set source of new commands, also\n-                              --  setting this non-null indicates that\n-                              --  we are in the special commands mode\n-                              --  for processing the -xargs case.\n+                              --  Set source of new commands, also setting this\n+                              --  non-null indicates that we are in the special\n+                              --  commands mode for processing the -xargs case.\n \n                               Make_Commands_Active :=\n                                 Matching_Name\n@@ -2087,8 +2078,7 @@ package body VMS_Conv is\n \n                         when T_Options =>\n                            if SwP + 1 > Arg'Last then\n-                              Place_Unix_Switches\n-                                (Sw.Options.Unix_String);\n+                              Place_Unix_Switches (Sw.Options.Unix_String);\n                               SwP := Endp + 1;\n \n                            elsif Arg (SwP + 2) /= '(' then\n@@ -2109,7 +2099,6 @@ package body VMS_Conv is\n \n                            while SwP <= Endp loop\n                               P2 := SwP;\n-\n                               while P2 < Endp\n                                 and then Arg (P2 + 1) /= ','\n                               loop\n@@ -2122,17 +2111,15 @@ package body VMS_Conv is\n                                                     Sw.Options);\n \n                               if Opt /= null then\n-                                 Place_Unix_Switches\n-                                   (Opt.Unix_String);\n+                                 Place_Unix_Switches (Opt.Unix_String);\n                               end if;\n \n                               SwP := P2 + 2;\n                            end loop;\n \n                         when T_Other =>\n                            Place_Unix_Switches\n-                             (new String'(Sw.Unix_String.all &\n-                                          Arg.all));\n+                             (new String'(Sw.Unix_String.all & Arg.all));\n \n                      end case;\n                   end if;"}]}