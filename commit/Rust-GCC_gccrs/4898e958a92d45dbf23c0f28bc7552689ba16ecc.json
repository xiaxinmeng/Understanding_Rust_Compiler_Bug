{"sha": "4898e958a92d45dbf23c0f28bc7552689ba16ecc", "node_id": "C_kwDOANBUbNoAKDQ4OThlOTU4YTkyZDQ1ZGJmMjNjMGYyOGJjNzU1MjY4OWJhMTZlY2M", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-07T08:35:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-07T08:35:16Z"}, "message": "Implement intra-procedural dataflow in ipa-modref flags propagation.\n\nimplement the (long promised) intraprocedural dataflow for\npropagating eaf flags, so we can handle parameters that participate\nin loops in SSA graphs. Typical example are acessors that walk linked\nlists, for example.\n\nI implemented dataflow using the standard iteration over BBs in RPO some time\nago, but did not like it becuase it had measurable compile time impact with\nvery small code quality effect. This is why I kept mainline to do the DFS walk\ninstead. The reason is that we care about flags of SSA names that corresponds\nto parameters and those can be often determined from a small fraction of the\nSSA graph so solving dataflow for all SSA names in a function is a waste.\n\nThis patch implements dataflow more carefully.  The DFS walk is kept in place to\nsolve acyclic cases and discover the relevat part of SSA graph into new graph\n(which is similar to one used for inter-procedrual dataflow - we only need to\nknow the edges and if the access is direct or derefernced).  The RPO iterative\ndataflow then works on this simplified graph.\n\nThis seems to be fast in practice. For GCC linktime we do dataflow for 4881\nfunctions. Out of that 4726 finishes in one iteration, 144 in two and 10 in 3.\n\nOverall 31979 functions are analysed, so we do dataflow only for bit over of\n10% of cases.  131123 edges are visited by the solver.  I measured no compile\ntime impact of this.\n\ngcc/ChangeLog:\n\n\t* ipa-modref.c (modref_lattice): Add do_dataflow,\n\tchanged and propagate_to fields.\n\t(modref_lattice::release): Free propagate_to\n\t(modref_lattice::merge): Do not give up early on unknown\n\tlattice values.\n\t(modref_lattice::merge_deref): Likewise.\n\t(modref_eaf_analysis): Update toplevel comment.\n\t(modref_eaf_analysis::analyze_ssa_name): Record postponned ssa names;\n\tdo optimistic dataflow initialization.\n\t(modref_eaf_analysis::merge_with_ssa_name): Build dataflow graph.\n\t(modref_eaf_analysis::propagate): New member function.\n\t(analyze_parms): Update to new API of modref_eaf_analysis.", "tree": {"sha": "e248250b2eac942ca4aa44afc5564d0caa0a3bd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e248250b2eac942ca4aa44afc5564d0caa0a3bd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4898e958a92d45dbf23c0f28bc7552689ba16ecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4898e958a92d45dbf23c0f28bc7552689ba16ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4898e958a92d45dbf23c0f28bc7552689ba16ecc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4898e958a92d45dbf23c0f28bc7552689ba16ecc/comments", "author": null, "committer": null, "parents": [{"sha": "9defce622893f87d954e0089e0ea79e1e388a480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9defce622893f87d954e0089e0ea79e1e388a480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9defce622893f87d954e0089e0ea79e1e388a480"}], "stats": {"total": 244, "additions": 224, "deletions": 20}, "files": [{"sha": "5209fbdfbf4d4d4c096beaa67c4b17f73e0edef9", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 224, "deletions": 20, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4898e958a92d45dbf23c0f28bc7552689ba16ecc/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4898e958a92d45dbf23c0f28bc7552689ba16ecc/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=4898e958a92d45dbf23c0f28bc7552689ba16ecc", "patch": "@@ -752,8 +752,9 @@ record_access (modref_records *tt, ao_ref *ref)\n   modref_access_node a = get_access (ref);\n   if (dump_file)\n     {\n-       fprintf (dump_file, \"   - Recording base_set=%i ref_set=%i parm=%i\\n\",\n-\t\tbase_set, ref_set, a.parm_index);\n+       fprintf (dump_file, \"   - Recording base_set=%i ref_set=%i \",\n+\t\tbase_set, ref_set);\n+       dump_access (&a, dump_file);\n     }\n   tt->insert (base_set, ref_set, a, false);\n }\n@@ -816,9 +817,9 @@ record_access_lto (modref_records_lto *tt, ao_ref *ref)\n       fprintf (dump_file, \" (alias set %i) ref type:\",\n \t       base_type ? get_alias_set (base_type) : 0);\n       print_generic_expr (dump_file, ref_type);\n-      fprintf (dump_file, \" (alias set %i) parm:%i\\n\",\n-\t       ref_type ? get_alias_set (ref_type) : 0,\n-\t       a.parm_index);\n+      fprintf (dump_file, \" (alias set %i) \",\n+\t       ref_type ? get_alias_set (ref_type) : 0);\n+       dump_access (&a, dump_file);\n     }\n \n   tt->insert (base_type, ref_type, a, false);\n@@ -1456,14 +1457,32 @@ class modref_lattice\n public:\n   /* EAF flags of the SSA name.  */\n   eaf_flags_t flags;\n-  /* DFS bookkkeeping: we don't do real dataflow yet.  */\n+  /* Used during DFS walk to mark names where final value was determined\n+     without need for dataflow.  */\n   bool known;\n+  /* Used during DFS walk to mark open vertices (for cycle detection).  */\n   bool open;\n+  /* Set during DFS walk for names that needs dataflow propagation.  */\n+  bool do_dataflow;\n+  /* Used during the iterative dataflow.  */\n+  bool changed;\n \n   /* When doing IPA analysis we can not merge in callee escape points;\n      Only remember them and do the merging at IPA propagation time.  */\n   vec <escape_point, va_heap, vl_ptr> escape_points;\n \n+  /* Representation of a graph for dataaflow.  This graph is built on-demand\n+     using modref_eaf_analysis::analyze_ssa and later solved by\n+     modref_eaf_analysis::propagate.\n+     Each edge represents the fact that flags of current lattice should be\n+     propagated to lattice of SSA_NAME.  */\n+  struct propagate_edge\n+  {\n+    int ssa_name;\n+    bool deref;\n+  };\n+  vec <propagate_edge, va_heap, vl_ptr> propagate_to;\n+\n   void init ();\n   void release ();\n   bool merge (const modref_lattice &with);\n@@ -1495,6 +1514,7 @@ void\n modref_lattice::release ()\n {\n   escape_points.release ();\n+  propagate_to.release ();\n }\n \n /* Dump lattice to OUT; indent with INDENT spaces.  */\n@@ -1587,7 +1607,7 @@ bool\n modref_lattice::merge (const modref_lattice &with)\n {\n   if (!with.known)\n-    return merge (0);\n+    do_dataflow = true;\n \n   bool changed = merge (with.flags);\n \n@@ -1608,7 +1628,7 @@ bool\n modref_lattice::merge_deref (const modref_lattice &with, bool ignore_stores)\n {\n   if (!with.known)\n-    return merge (0);\n+    do_dataflow = true;\n \n   bool changed = merge (deref_flags (with.flags, ignore_stores));\n \n@@ -1646,13 +1666,24 @@ modref_lattice::merge_direct_store ()\n   return merge (~(EAF_UNUSED | EAF_NOCLOBBER));\n }\n \n-/* Analyzer of EAF flags.  */\n+/* Analyzer of EAF flags.\n+   This is genrally dataflow problem over the SSA graph, however we only\n+   care about flags of few selected ssa names (arguments, return slot and\n+   static chain).  So we first call analyze_ssa_name on all relevant names\n+   and perform a DFS walk to discover SSA names where flags needs to be\n+   determined.  For acyclic graphs we try to determine final flags during\n+   this walk.  Once cycles or recursin depth is met we enlist SSA names\n+   for dataflow which is done by propagate call.\n+\n+   After propagation the flags can be obtained using get_ssa_name_flags.  */\n \n class modref_eaf_analysis\n {\n public:\n-  /* Compute flags for NAME.  */\n+  /* Mark NAME as relevant for analysis.  */\n   void analyze_ssa_name (tree name);\n+  /* Dataflow slover.  */\n+  void propagate ();\n   /* Return flags computed earlier for NAME.  */\n   int get_ssa_name_flags (tree name)\n   {\n@@ -1673,7 +1704,7 @@ class modref_eaf_analysis\n   ~modref_eaf_analysis ()\n   {\n     gcc_checking_assert (!m_depth);\n-    if (m_ipa)\n+    if (m_ipa || m_names_to_propagate.length ())\n       for (unsigned int i = 0; i < num_ssa_names; i++)\n \tm_lattice[i].release ();\n   }\n@@ -1685,6 +1716,8 @@ class modref_eaf_analysis\n   int m_depth;\n   /* Propagation lattice for individual ssa names.  */\n   auto_vec<modref_lattice> m_lattice;\n+  auto_vec<tree> m_deferred_names;\n+  auto_vec<int> m_names_to_propagate;\n \n   void merge_with_ssa_name (tree dest, tree src, bool deref);\n   void merge_call_lhs_flags (gcall *call, int arg, tree name, bool deref);\n@@ -1773,26 +1806,27 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n   int index = SSA_NAME_VERSION (name);\n \n   /* See if value is already computed.  */\n-  if (m_lattice[index].known)\n+  if (m_lattice[index].known || m_lattice[index].do_dataflow)\n    return;\n   if (m_lattice[index].open)\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n-\t\t \"%*sGiving up on a cycle in SSA graph\\n\",\n+\t\t \"%*sCycle in SSA graph\\n\",\n \t\t m_depth * 4, \"\");\n       return;\n     }\n+  /* Recursion guard.  */\n+  m_lattice[index].init ();\n   if (m_depth == param_modref_max_depth)\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n-\t\t \"%*sGiving up on max depth\\n\",\n+\t\t \"%*sMax recursion depth reached; postponing\\n\",\n \t\t m_depth * 4, \"\");\n+      m_deferred_names.safe_push (name);\n       return;\n     }\n-  /* Recursion guard.  */\n-  m_lattice[index].init ();\n \n   if (dump_file)\n     {\n@@ -2072,7 +2106,8 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n       m_lattice[index].dump (dump_file, m_depth * 4 + 2);\n     }\n   m_lattice[index].open = false;\n-  m_lattice[index].known = true;\n+  if (!m_lattice[index].do_dataflow)\n+    m_lattice[index].known = true;\n }\n \n /* Propagate info from SRC to DEST.  If DEREF it true, assume that SRC\n@@ -2084,13 +2119,168 @@ modref_eaf_analysis::merge_with_ssa_name (tree dest, tree src, bool deref)\n   int index = SSA_NAME_VERSION (dest);\n   int src_index = SSA_NAME_VERSION (src);\n \n+  /* Merging lattice with itself is a no-op.  */\n+  if (!deref && src == dest)\n+    return;\n+\n   m_depth++;\n   analyze_ssa_name (src);\n   m_depth--;\n   if (deref)\n     m_lattice[index].merge_deref (m_lattice[src_index], false);\n   else\n     m_lattice[index].merge (m_lattice[src_index]);\n+\n+  /* If we failed to produce final solution add an edge to the dataflow\n+     graph.  */\n+  if (!m_lattice[src_index].known)\n+    {\n+      modref_lattice::propagate_edge e = {index, deref};\n+\n+      if (!m_lattice[src_index].propagate_to.length ())\n+\tm_names_to_propagate.safe_push (src_index);\n+      m_lattice[src_index].propagate_to.safe_push (e);\n+      m_lattice[src_index].changed = true;\n+      m_lattice[src_index].do_dataflow = true;\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"%*sWill propgate from ssa_name %i to %i%s\\n\",\n+\t\t m_depth * 4 + 4,\n+\t\t \"\", src_index, index, deref ? \" (deref)\" : \"\");\n+    }\n+}\n+\n+/* In the case we deferred some SSA names, reprocess them.  In the case some\n+   dataflow edges were introduced, do the actual iterative dataflow.  */\n+\n+void\n+modref_eaf_analysis::propagate ()\n+{\n+  int iterations = 0;\n+  size_t i;\n+  int index;\n+  bool changed = true;\n+\n+  while (m_deferred_names.length ())\n+    {\n+      tree name = m_deferred_names.pop ();\n+      m_lattice[SSA_NAME_VERSION (name)].open = false;\n+      if (dump_file)\n+\tfprintf (dump_file, \"Analyzing deferred SSA name\\n\");\n+      analyze_ssa_name (name);\n+    }\n+\n+  if (!m_names_to_propagate.length ())\n+    return;\n+  if (dump_file)\n+    fprintf (dump_file, \"Propagating EAF flags\\n\");\n+\n+  /* Compute reverse postorder.  */\n+  auto_vec <int> rpo;\n+  struct stack_entry\n+  {\n+    int name;\n+    unsigned pos;\n+  };\n+  auto_vec <struct stack_entry> stack;\n+  int pos = m_names_to_propagate.length () - 1;\n+\n+  rpo.safe_grow (m_names_to_propagate.length (), true);\n+  stack.reserve_exact (m_names_to_propagate.length ());\n+\n+  /* We reuse known flag for RPO DFS walk bookeeping.  */\n+  if (flag_checking)\n+    FOR_EACH_VEC_ELT (m_names_to_propagate, i, index)\n+      gcc_assert (!m_lattice[index].known && m_lattice[index].changed);\n+\n+  FOR_EACH_VEC_ELT (m_names_to_propagate, i, index)\n+    {\n+      if (!m_lattice[index].known)\n+\t{\n+\t  stack_entry e = {index, 0};\n+\n+\t  stack.quick_push (e);\n+\t  m_lattice[index].known = true;\n+\t}\n+      while (stack.length ())\n+\t{\n+\t  bool found = false;\n+\t  int index1 = stack.last ().name;\n+\n+\t  while (stack.last ().pos < m_lattice[index1].propagate_to.length ())\n+\t    {\n+\t      int index2 = m_lattice[index1]\n+\t\t      .propagate_to[stack.last ().pos].ssa_name;\n+\n+\t      stack.last ().pos++;\n+\t      if (!m_lattice[index2].known\n+\t\t  && m_lattice[index2].propagate_to.length ())\n+\t\t{\n+\t\t  stack_entry e = {index2, 0};\n+\n+\t\t  stack.quick_push (e);\n+\t\t  m_lattice[index2].known = true;\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (!found\n+\t      && stack.last ().pos == m_lattice[index1].propagate_to.length ())\n+\t    {\n+\t      rpo[pos--] = index1;\n+\t      stack.pop ();\n+\t    }\n+\t}\n+    }\n+\n+  /* Perform itrative dataflow.  */\n+  while (changed)\n+    {\n+      changed = false;\n+      iterations++;\n+      if (dump_file)\n+\tfprintf (dump_file, \" iteration %i\\n\", iterations);\n+      FOR_EACH_VEC_ELT (rpo, i, index)\n+\t{\n+\t  if (m_lattice[index].changed)\n+\t    {\n+\t      size_t j;\n+\n+\t      m_lattice[index].changed = false;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"  Visiting ssa name %i\\n\", index);\n+\t      for (j = 0; j < m_lattice[index].propagate_to.length (); j++)\n+\t\t{\n+\t\t  bool ch;\n+\t\t  int target = m_lattice[index].propagate_to[j].ssa_name;\n+\t\t  bool deref = m_lattice[index].propagate_to[j].deref;\n+\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"   Propagating flags of ssa name\"\n+\t\t\t     \" %i to %i%s\\n\",\n+\t\t\t     index, target, deref ? \" (deref)\" : \"\");\n+\t\t  m_lattice[target].known = true;\n+\t\t  if (!m_lattice[index].propagate_to[j].deref)\n+\t\t    ch = m_lattice[target].merge (m_lattice[index]);\n+\t\t  else\n+\t\t    ch = m_lattice[target].merge_deref (m_lattice[index],\n+\t\t\t\t\t\t\tfalse);\n+\t\t  if (!ch)\n+\t\t    continue;\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"   New lattice: \");\n+\t\t      m_lattice[target].dump (dump_file);\n+\t\t    }\n+\t\t  if (target <= (int)i)\n+\t\t    changed = true;\n+\t\t  m_lattice[target].changed = true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (dump_file)\n+    fprintf (dump_file, \"EAF flags propagated in %i iterations\\n\", iterations);\n }\n \n /* Record escape points of PARM_INDEX according to LATTICE.  */\n@@ -2151,6 +2341,23 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \n   modref_eaf_analysis eaf_analysis (ipa);\n \n+  /* Determine all SSA names we need to know flags for.  */\n+  for (tree parm = DECL_ARGUMENTS (current_function_decl); parm;\n+       parm = TREE_CHAIN (parm))\n+    {\n+      tree name = ssa_default_def (cfun, parm);\n+      if (name)\n+\teaf_analysis.analyze_ssa_name (name);\n+    }\n+  if (retslot)\n+    eaf_analysis.analyze_ssa_name (retslot);\n+  if (static_chain)\n+    eaf_analysis.analyze_ssa_name (static_chain);\n+\n+  /* Do the dataflow.  */\n+  eaf_analysis.propagate ();\n+\n+  /* Store results to summaries.  */\n   for (tree parm = DECL_ARGUMENTS (current_function_decl); parm; parm_index++,\n        parm = TREE_CHAIN (parm))\n     {\n@@ -2175,7 +2382,6 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t    }\n \t  continue;\n \t}\n-      eaf_analysis.analyze_ssa_name (name);\n       int flags = eaf_analysis.get_ssa_name_flags (name);\n \n       /* Eliminate useless flags so we do not end up storing unnecessary\n@@ -2204,7 +2410,6 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n     }\n   if (retslot)\n     {\n-      eaf_analysis.analyze_ssa_name (retslot);\n       int flags = eaf_analysis.get_ssa_name_flags (retslot);\n \n       flags = remove_useless_eaf_flags (flags, ecf_flags, false);\n@@ -2220,7 +2425,6 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n     }\n   if (static_chain)\n     {\n-      eaf_analysis.analyze_ssa_name (static_chain);\n       int flags = eaf_analysis.get_ssa_name_flags (static_chain);\n \n       flags = remove_useless_eaf_flags (flags, ecf_flags, false);"}]}