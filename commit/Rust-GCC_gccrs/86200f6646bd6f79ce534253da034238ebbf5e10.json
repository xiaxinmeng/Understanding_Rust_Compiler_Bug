{"sha": "86200f6646bd6f79ce534253da034238ebbf5e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyMDBmNjY0NmJkNmY3OWNlNTM0MjUzZGEwMzQyMzhlYmJmNWUxMA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-10-22T13:58:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T13:58:49Z"}, "message": "a-except-2005.adb (Rmsg_18): New message text.\n\n2010-10-22  Robert Dewar  <dewar@adacore.com>\n\n\t* a-except-2005.adb (Rmsg_18): New message text.\n\t* a-except.adb (Rmsg_18): New message text.\n\t* atree.adb (List25): New function\n\t(Set_List25): New procedure\n\t* atree.ads (List25): New function\n\t(Set_List25): New procedure\n\t* einfo.adb (Static_Predicate): Is now a list\n\t(OK_To_Reference): Present in all entities\n\t* einfo.ads (Static_Predicate): Is now a list\n\t(OK_To_Reference): Applies to all entities\n\t* exp_ch13.adb (Build_Predicate_Function): Moved to Sem_Ch13\n\t* sem_attr.adb (Bad_Attribute_For_Predicate): Call\n\tBad_Predicated_Subtype_Use.\n\t* sem_case.ads, sem_case.adb: Major surgery to deal with predicated\n\tsubtype case.\n\t* sem_ch13.adb (Build_Predicate_Function): Moved from Exp_Ch13 to\n\tSem_Ch13.\n\t(Build_Static_Predicate): New procedure handles static predicates.\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): Delay freeze on subtype\n\twith no constraint if ancestor subtype has predicates.\n\t(Analyze_Variant_Part): New calling sequence for Analyze_Choices\n\t* sem_ch4.adb (Junk_Operand): Don't complain about OK_To_Reference\n\tentity.\n\t(Analyze_Case_Expression): New calling sequence for Analyze_Choices\n\t* sem_ch5.adb (Analyze_Case_Statement): New calling sequence for\n\tAnalyze_Choices.\n\t* sem_util.ads, sem_util.adb (Bad_Predicated_Subtype_Use): New procedure\n\t* types.ads (PE_Bad_Predicated_Generic_Type): Replaces\n\tPE_Bad_Attribute_For_Predicate.\n\t* atree.h: Add definition of List25.\n\nFrom-SVN: r165828", "tree": {"sha": "0f29daae91540971a73fc67b6f90224da6b55447", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f29daae91540971a73fc67b6f90224da6b55447"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86200f6646bd6f79ce534253da034238ebbf5e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86200f6646bd6f79ce534253da034238ebbf5e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86200f6646bd6f79ce534253da034238ebbf5e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86200f6646bd6f79ce534253da034238ebbf5e10/comments", "author": null, "committer": null, "parents": [{"sha": "497b37aded1f085d996b5bd67ec4c62b26810912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497b37aded1f085d996b5bd67ec4c62b26810912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497b37aded1f085d996b5bd67ec4c62b26810912"}], "stats": {"total": 1436, "additions": 919, "deletions": 517}, "files": [{"sha": "e5274a749ccbec9351eff02b26fa57c6c1f91446", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -1,3 +1,36 @@\n+2010-10-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-except-2005.adb (Rmsg_18): New message text.\n+\t* a-except.adb (Rmsg_18): New message text.\n+\t* atree.adb (List25): New function\n+\t(Set_List25): New procedure\n+\t* atree.ads (List25): New function\n+\t(Set_List25): New procedure\n+\t* einfo.adb (Static_Predicate): Is now a list\n+\t(OK_To_Reference): Present in all entities\n+\t* einfo.ads (Static_Predicate): Is now a list\n+\t(OK_To_Reference): Applies to all entities\n+\t* exp_ch13.adb (Build_Predicate_Function): Moved to Sem_Ch13\n+\t* sem_attr.adb (Bad_Attribute_For_Predicate): Call\n+\tBad_Predicated_Subtype_Use.\n+\t* sem_case.ads, sem_case.adb: Major surgery to deal with predicated\n+\tsubtype case.\n+\t* sem_ch13.adb (Build_Predicate_Function): Moved from Exp_Ch13 to\n+\tSem_Ch13.\n+\t(Build_Static_Predicate): New procedure handles static predicates.\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): Delay freeze on subtype\n+\twith no constraint if ancestor subtype has predicates.\n+\t(Analyze_Variant_Part): New calling sequence for Analyze_Choices\n+\t* sem_ch4.adb (Junk_Operand): Don't complain about OK_To_Reference\n+\tentity.\n+\t(Analyze_Case_Expression): New calling sequence for Analyze_Choices\n+\t* sem_ch5.adb (Analyze_Case_Statement): New calling sequence for\n+\tAnalyze_Choices.\n+\t* sem_util.ads, sem_util.adb (Bad_Predicated_Subtype_Use): New procedure\n+\t* types.ads (PE_Bad_Predicated_Generic_Type): Replaces\n+\tPE_Bad_Attribute_For_Predicate.\n+\t* atree.h: Add definition of List25.\n+\n 2010-10-22  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* gnatlink.adb (Process_Binder_File): Remove CLI-specific code, now"}, {"sha": "cbf1e4deb89117509ef50fe0519c167b1e2d6eb4", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -588,8 +588,8 @@ package body Ada.Exceptions is\n    Rmsg_16 : constant String := \"attempt to take address of\"       &\n                                 \" intrinsic subprogram\"            & NUL;\n    Rmsg_17 : constant String := \"all guards closed\"                & NUL;\n-   Rmsg_18 : constant String := \"attribute not allowed for \"       &\n-                                \" generic subtype with predicate\"  & NUL;\n+   Rmsg_18 : constant String := \"improper use of generic subtype\"  &\n+                                \" with predicate\"                  & NUL;\n    Rmsg_19 : constant String := \"Current_Task referenced in entry\" &\n                                 \" body\"                            & NUL;\n    Rmsg_20 : constant String := \"duplicated entry address\"         & NUL;"}, {"sha": "e80e264fe0fd9640d6c0f2ee3e06b4525f45226a", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -520,8 +520,8 @@ package body Ada.Exceptions is\n    Rmsg_16 : constant String := \"attempt to take address of\"       &\n                                 \" intrinsic subprogram\"            & NUL;\n    Rmsg_17 : constant String := \"all guards closed\"                & NUL;\n-   Rmsg_18 : constant String := \"attribute not allowed for \"       &\n-                                \" generic subtype with predicate\"  & NUL;\n+   Rmsg_18 : constant String := \"improper use of generic subtype\"  &\n+                                \" with predicate\"                  & NUL;\n    Rmsg_19 : constant String := \"Current_Task referenced in entry\" &\n                                 \" body\"                            & NUL;\n    Rmsg_20 : constant String := \"duplicated entry address\"         & NUL;"}, {"sha": "5426fab7d026da22d7997a61a06493d0dc789a73", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -2400,6 +2400,12 @@ package body Atree is\n          return List_Id (Nodes.Table (N + 2).Field7);\n       end List14;\n \n+      function List25 (N : Node_Id) return List_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return List_Id (Nodes.Table (N + 4).Field7);\n+      end List25;\n+\n       function Elist1 (N : Node_Id) return Elist_Id is\n          pragma Assert (N <= Nodes.Last);\n          Value : constant Union_Id := Nodes.Table (N).Field1;\n@@ -4657,6 +4663,12 @@ package body Atree is\n          Nodes.Table (N + 2).Field7 := Union_Id (Val);\n       end Set_List14;\n \n+      procedure Set_List25 (N : Node_Id; Val : List_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 4).Field7 := Union_Id (Val);\n+      end Set_List25;\n+\n       procedure Set_Elist1 (N : Node_Id; Val : Elist_Id) is\n       begin\n          Nodes.Table (N).Field1 := Union_Id (Val);"}, {"sha": "51921cdb994313d38bafb864d47fc38eaf02b4b5", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -1096,6 +1096,9 @@ package Atree is\n       function List14 (N : Node_Id) return List_Id;\n       pragma Inline (List14);\n \n+      function List25 (N : Node_Id) return List_Id;\n+      pragma Inline (List25);\n+\n       function Elist1 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist1);\n \n@@ -2159,6 +2162,9 @@ package Atree is\n       procedure Set_List14 (N : Node_Id; Val : List_Id);\n       pragma Inline (Set_List14);\n \n+      procedure Set_List25 (N : Node_Id; Val : List_Id);\n+      pragma Inline (Set_List25);\n+\n       procedure Set_Elist1 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist1);\n "}, {"sha": "4cef407ebd5dce680ade0f8e4f46164b59f710bc", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -421,6 +421,7 @@ extern Node_Id Current_Error_Node;\n #define List5(N)      Field5  (N)\n #define List10(N)     Field10 (N)\n #define List14(N)     Field14 (N)\n+#define List25(N)     Field25 (N)\n \n #define Elist1(N)     Field1  (N)\n #define Elist2(N)     Field2  (N)"}, {"sha": "50463979ca3ff22a66aaa5f12f205a493bfc95aa", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -215,7 +215,7 @@ package body Einfo is\n    --    Debug_Renaming_Link             Node25\n    --    DT_Offset_To_Top_Func           Node25\n    --    PPC_Wrapper                     Node25\n-   --    Static_Predicate                Node25\n+   --    Static_Predicate                List25\n    --    Task_Body_Procedure             Node25\n \n    --    Dispatch_Table_Wrappers         Elist26\n@@ -2316,7 +2316,6 @@ package body Einfo is\n \n    function OK_To_Reference (Id : E) return B is\n    begin\n-      pragma Assert (Is_Type (Id));\n       return Flag249 (Id);\n    end OK_To_Reference;\n \n@@ -2621,10 +2620,10 @@ package body Einfo is\n       return Node24 (Id);\n    end Spec_PPC_List;\n \n-   function Static_Predicate (Id : E) return N is\n+   function Static_Predicate (Id : E) return S is\n    begin\n       pragma Assert (Is_Discrete_Type (Id));\n-      return Node25 (Id);\n+      return List25 (Id);\n    end Static_Predicate;\n \n    function Storage_Size_Variable (Id : E) return E is\n@@ -4811,7 +4810,6 @@ package body Einfo is\n \n    procedure Set_OK_To_Reference (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Type (Id));\n       Set_Flag249 (Id, V);\n    end Set_OK_To_Reference;\n \n@@ -5127,14 +5125,14 @@ package body Einfo is\n       Set_Node24 (Id, V);\n    end Set_Spec_PPC_List;\n \n-   procedure Set_Static_Predicate (Id : E; V : N) is\n+   procedure Set_Static_Predicate (Id : E; V : S) is\n    begin\n       pragma Assert\n         (Ekind_In (Id, E_Enumeration_Subtype,\n                        E_Modular_Integer_Subtype,\n                        E_Signed_Integer_Subtype)\n           and then Has_Predicates (Id));\n-      Set_Node25 (Id, V);\n+      Set_List25 (Id, V);\n    end Set_Static_Predicate;\n \n    procedure Set_Storage_Size_Variable (Id : E; V : E) is"}, {"sha": "6b5a14ac356ecddf5286d80cb799864b00c26b7a", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -3152,10 +3152,10 @@ package Einfo is\n --       formals as a value of type Pos.\n \n --    OK_To_Reference (Flag249)\n---       Present in all entities for types and subtypes. If set it indicates\n---       that a naked reference to the type is permitted within an expression\n---       that is being analyzed or preanalyed (for example, a type name may\n---       be referenced within the Invariant aspect expression for the type).\n+--       Present in all entities. If set it indicates that a naked reference to\n+--       the entity is permitted within an expression that is being preanalyzed\n+--       (for example, a type name may be referenced within the Invariant\n+--       or Predicate aspect expression for a type).\n \n --    OK_To_Rename (Flag247)\n --       Present only in entities for variables. If this flag is set, it\n@@ -3609,11 +3609,14 @@ package Einfo is\n --       textual appearance. Note that this includes precondition/postcondition\n --       pragmas generated to correspond to Pre/Post aspects.\n \n---    Static_Predicate (Node25)\n+--    Static_Predicate (List25)\n --       Present in discrete types/subtypes with predicates (Has_Predicates\n---       set True). Set for a subtype that has a predicate that is considered\n---       static. Points to the fully analyzed predicate expression, which is\n---       always a membership test (possibly a set membership).\n+--       set True). Points to a list of expression and N_Range nodes that\n+--       represent the predicate in canonical form. The canonical form has\n+--       entries sorted in ascending order, with all duplicates eliminated,\n+--       and adjacent ranges coalesced, so that there is always a gap in the\n+--       values between successive entries. The entries in this list are\n+--       fully analyzed.\n \n --    Storage_Size_Variable (Node15) [implementation base type only]\n --       Present in access types and task type entities. This flag is set\n@@ -4735,6 +4738,7 @@ package Einfo is\n    --    Needs_Debug_Info                    (Flag147)\n    --    Never_Set_In_Source                 (Flag115)\n    --    No_Return                           (Flag113)\n+   --    OK_To_Reference                     (Flag249)\n    --    Overlays_Constant                   (Flag243)\n    --    Referenced                          (Flag156)\n    --    Referenced_As_LHS                   (Flag36)\n@@ -4817,7 +4821,6 @@ package Einfo is\n    --    Known_To_Have_Preelab_Init          (Flag207)\n    --    Must_Be_On_Byte_Boundary            (Flag183)\n    --    Must_Have_Preelab_Init              (Flag208)\n-   --    OK_To_Reference                     (Flag249)\n    --    Optimize_Alignment_Space            (Flag241)\n    --    Optimize_Alignment_Time             (Flag242)\n    --    Size_Depends_On_Discriminant        (Flag177)\n@@ -5073,7 +5076,7 @@ package Einfo is\n    --    First_Literal                       (Node17)\n    --    Scalar_Range                        (Node20)\n    --    Enum_Pos_To_Rep                     (Node23)   (type only)\n-   --    Static_Predicate                    (Node25)\n+   --    Static_Predicate                    (List25)\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Contiguous_Rep                  (Flag181)\n    --    Has_Enumeration_Rep_Clause          (Flag66)\n@@ -5275,7 +5278,7 @@ package Einfo is\n    --    Modulus                             (Uint17)    (base type only)\n    --    Original_Array_Type                 (Node21)\n    --    Scalar_Range                        (Node20)\n-   --    Static_Predicate                    (Node25)\n+   --    Static_Predicate                    (List25)\n    --    Non_Binary_Modulus                  (Flag58)    (base type only)\n    --    Has_Biased_Representation           (Flag139)\n    --    Type_Low_Bound                      (synth)\n@@ -5545,7 +5548,7 @@ package Einfo is\n    --  E_Signed_Integer_Type\n    --  E_Signed_Integer_Subtype\n    --    Scalar_Range                        (Node20)\n-   --    Static_Predicate                    (Node25)\n+   --    Static_Predicate                    (List25)\n    --    Has_Biased_Representation           (Flag139)\n    --    Type_Low_Bound                      (synth)\n    --    Type_High_Bound                     (synth)\n@@ -6241,7 +6244,7 @@ package Einfo is\n    function Small_Value                         (Id : E) return R;\n    function Spec_Entity                         (Id : E) return E;\n    function Spec_PPC_List                       (Id : E) return N;\n-   function Static_Predicate                    (Id : E) return N;\n+   function Static_Predicate                    (Id : E) return S;\n    function Storage_Size_Variable               (Id : E) return E;\n    function Static_Elaboration_Desired          (Id : E) return B;\n    function Static_Initialization               (Id : E) return N;\n@@ -6829,7 +6832,7 @@ package Einfo is\n    procedure Set_Small_Value                     (Id : E; V : R);\n    procedure Set_Spec_Entity                     (Id : E; V : E);\n    procedure Set_Spec_PPC_List                   (Id : E; V : N);\n-   procedure Set_Static_Predicate                (Id : E; V : N);\n+   procedure Set_Static_Predicate                (Id : E; V : S);\n    procedure Set_Storage_Size_Variable           (Id : E; V : E);\n    procedure Set_Static_Elaboration_Desired      (Id : E; V : B);\n    procedure Set_Static_Initialization           (Id : E; V : N);"}, {"sha": "f3de66c6a12b7c467e71ba588604b251f0079756", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 0, "deletions": 329, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -26,8 +26,6 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n-with Elists;   use Elists;\n-with Errout;   use Errout;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Imgv; use Exp_Imgv;\n@@ -39,8 +37,6 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n@@ -54,313 +50,6 @@ with Validsw;  use Validsw;\n \n package body Exp_Ch13 is\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Build_Predicate_Function\n-     (Typ   : Entity_Id;\n-      FDecl : out Node_Id;\n-      FBody : out Node_Id);\n-   --  If Typ has predicates (indicated by Has_Predicates being set for Typ,\n-   --  then either there are pragma Invariant entries on the rep chain for the\n-   --  type (note that Predicate aspects are converted to pragam Predicate), or\n-   --  there are inherited aspects from a parent type, or ancestor subtypes,\n-   --  or interfaces. This procedure builds the spec and body for the Predicate\n-   --  function that tests these predicates, returning them in PDecl and Pbody\n-   --  and setting Predicate_Procedure for Typ. In some error situations no\n-   --  procedure is built, in which case PDecl/PBody are empty on return.\n-\n-   ------------------------------\n-   -- Build_Predicate_Function --\n-   ------------------------------\n-\n-   --  The procedure that is constructed here has the form\n-\n-   --  function typPredicate (Ixxx : typ) return Boolean is\n-   --  begin\n-   --     return\n-   --        exp1 and then exp2 and then ...\n-   --        and then typ1Predicate (typ1 (Ixxx))\n-   --        and then typ2Predicate (typ2 (Ixxx))\n-   --        and then ...;\n-   --  end typPredicate;\n-\n-   --  Here exp1, and exp2 are expressions from Predicate pragmas. Note that\n-   --  this is the point at which these expressions get analyzed, providing the\n-   --  required delay, and typ1, typ2, are entities from which predicates are\n-   --  inherited. Note that we do NOT generate Check pragmas, that's because we\n-   --  use this function even if checks are off, e.g. for membership tests.\n-\n-   procedure Build_Predicate_Function\n-     (Typ   : Entity_Id;\n-      FDecl : out Node_Id;\n-      FBody : out Node_Id)\n-   is\n-      Loc  : constant Source_Ptr := Sloc (Typ);\n-      Spec : Node_Id;\n-      SId  : Entity_Id;\n-\n-      Expr : Node_Id;\n-      --  This is the expression for the return statement in the function. It\n-      --  is build by connecting the component predicates with AND THEN.\n-\n-      procedure Add_Call (T : Entity_Id);\n-      --  Includes a call to the predicate function for type T in Expr if T\n-      --  has predicates and Predicate_Function (T) is non-empty.\n-\n-      procedure Add_Predicates;\n-      --  Appends expressions for any Predicate pragmas in the rep item chain\n-      --  Typ to Expr. Note that we look only at items for this exact entity.\n-      --  Inheritance of predicates for the parent type is done by calling the\n-      --  Predicate_Function of the parent type, using Add_Call above.\n-\n-      Object_Name : constant Name_Id := New_Internal_Name ('I');\n-      --  Name for argument of Predicate procedure\n-\n-      --------------\n-      -- Add_Call --\n-      --------------\n-\n-      procedure Add_Call (T : Entity_Id) is\n-         Exp : Node_Id;\n-\n-      begin\n-         if Present (T) and then Present (Predicate_Function (T)) then\n-            Set_Has_Predicates (Typ);\n-\n-            --  Build the call to the predicate function of T\n-\n-            Exp :=\n-              Make_Predicate_Call\n-                (T,\n-                 Convert_To (T,\n-                   Make_Identifier (Loc, Chars => Object_Name)));\n-\n-            --  Add call to evolving expression, using AND THEN if needed\n-\n-            if No (Expr) then\n-               Expr := Exp;\n-            else\n-               Expr :=\n-                 Make_And_Then (Loc,\n-                   Left_Opnd  => Relocate_Node (Expr),\n-                   Right_Opnd => Exp);\n-            end if;\n-\n-            --  Output info message on inheritance if required\n-\n-            if Opt.List_Inherited_Aspects then\n-               Error_Msg_Sloc := Sloc (Predicate_Function (T));\n-               Error_Msg_Node_2 := T;\n-               Error_Msg_N (\"?info: & inherits predicate from & #\", Typ);\n-            end if;\n-         end if;\n-      end Add_Call;\n-\n-      --------------------\n-      -- Add_Predicates --\n-      --------------------\n-\n-      procedure Add_Predicates is\n-         Ritem : Node_Id;\n-         Arg1  : Node_Id;\n-         Arg2  : Node_Id;\n-\n-         function Replace_Node (N : Node_Id) return Traverse_Result;\n-         --  Process single node for traversal to replace type references\n-\n-         procedure Replace_Type is new Traverse_Proc (Replace_Node);\n-         --  Traverse an expression changing every occurrence of an entity\n-         --  reference to type T with a reference to the object argument.\n-\n-         ------------------\n-         -- Replace_Node --\n-         ------------------\n-\n-         function Replace_Node (N : Node_Id) return Traverse_Result is\n-         begin\n-            --  Case of entity name referencing the type\n-\n-            if Is_Entity_Name (N) and then Entity (N) = Typ then\n-\n-               --  Replace with object\n-\n-               Rewrite (N,\n-                 Make_Identifier (Loc,\n-                   Chars => Object_Name));\n-\n-               --  All done with this node\n-\n-               return Skip;\n-\n-            --  Not an occurrence of the type entity, keep going\n-\n-            else\n-               return OK;\n-            end if;\n-         end Replace_Node;\n-\n-      --  Start of processing for Add_Predicates\n-\n-      begin\n-         Ritem := First_Rep_Item (Typ);\n-         while Present (Ritem) loop\n-            if Nkind (Ritem) = N_Pragma\n-              and then Pragma_Name (Ritem) = Name_Predicate\n-            then\n-               Arg1 := First (Pragma_Argument_Associations (Ritem));\n-               Arg2 := Next (Arg1);\n-\n-               Arg1 := Get_Pragma_Arg (Arg1);\n-               Arg2 := Get_Pragma_Arg (Arg2);\n-\n-               --  See if this predicate pragma is for the current type\n-\n-               if Entity (Arg1) = Typ then\n-\n-                  --  We have a match, this entry is for our subtype\n-\n-                  --  First We need to replace any occurrences of the name of\n-                  --  the type with references to the object. We do this by\n-                  --  first doing a preanalysis, to identify all the entities,\n-                  --  then we traverse looking for the type entity, doing the\n-                  --  needed substitution. The preanalysis is done with the\n-                  --  special OK_To_Reference flag set on the type, so that if\n-                  --  we get an occurrence of this type, it will be recognized\n-                  --  as legitimate.\n-\n-                  Set_OK_To_Reference (Typ, True);\n-                  Preanalyze_Spec_Expression (Arg2, Standard_Boolean);\n-                  Set_OK_To_Reference (Typ, False);\n-                  Replace_Type (Arg2);\n-\n-                  --  OK, replacement complete, now we can add the expression\n-\n-                  if No (Expr) then\n-                     Expr := Relocate_Node (Arg2);\n-                  else\n-                     Expr :=\n-                       Make_And_Then (Loc,\n-                         Left_Opnd  => Relocate_Node (Expr),\n-                         Right_Opnd => Relocate_Node (Arg2));\n-                  end if;\n-               end if;\n-            end if;\n-\n-            Next_Rep_Item (Ritem);\n-         end loop;\n-      end Add_Predicates;\n-\n-   --  Start of processing for Build_Predicate_Function\n-\n-   begin\n-      --  Initialize for construction of statement list\n-\n-      Expr  := Empty;\n-      FDecl := Empty;\n-      FBody := Empty;\n-\n-      --  Return if already built or if type does not have predicates\n-\n-      if not Has_Predicates (Typ)\n-        or else Present (Predicate_Function (Typ))\n-      then\n-         return;\n-      end if;\n-\n-      --  Add Predicates for the current type\n-\n-      Add_Predicates;\n-\n-      --  Add predicates for ancestor if present\n-\n-      declare\n-         Atyp : constant Entity_Id := Nearest_Ancestor (Typ);\n-      begin\n-         if Present (Atyp) then\n-            Add_Call (Atyp);\n-         end if;\n-      end;\n-\n-      --  Add predicates of any interfaces of a tagged type\n-\n-      if Is_Tagged_Type (Typ) then\n-         declare\n-            Iface_List : Elist_Id;\n-            Elmt       : Elmt_Id;\n-\n-         begin\n-            Collect_Interfaces (Typ, Iface_List);\n-\n-            if Present (Iface_List) then\n-               loop\n-                  Elmt := First_Elmt (Iface_List);\n-                  exit when No (Elmt);\n-\n-                  Add_Call (Node (Elmt));\n-                  Remove_Elmt (Iface_List, Elmt);\n-               end loop;\n-            end if;\n-         end;\n-      end if;\n-\n-      if Present (Expr) then\n-\n-         --  Build function declaration\n-\n-         pragma Assert (Has_Predicates (Typ));\n-         SId :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n-         Set_Has_Predicates (SId);\n-         Set_Predicate_Function (Typ, SId);\n-\n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => SId,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier =>\n-                   Make_Defining_Identifier (Loc, Chars => Object_Name),\n-                 Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n-             Result_Definition        =>\n-               New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-         FDecl :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification => Spec);\n-\n-         --  Build function body\n-\n-         SId :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n-\n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => SId,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier =>\n-                   Make_Defining_Identifier (Loc, Chars => Object_Name),\n-                 Parameter_Type =>\n-                   New_Occurrence_Of (Typ, Loc))),\n-             Result_Definition        =>\n-               New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-         FBody :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              => Spec,\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (\n-                   Make_Simple_Return_Statement (Loc,\n-                     Expression => Expr))));\n-      end if;\n-   end Build_Predicate_Function;\n-\n    ------------------------------------------\n    -- Expand_N_Attribute_Definition_Clause --\n    ------------------------------------------\n@@ -725,24 +414,6 @@ package body Exp_Ch13 is\n          Rewrite (N, Make_Null_Statement (Sloc (N)));\n       end if;\n \n-      --  If freezing a type entity which has predicates, this is where we\n-      --  build and insert the predicate function for the type.\n-\n-      if Is_Type (E) and then Has_Predicates (E) then\n-         declare\n-            FDecl : Node_Id;\n-            FBody : Node_Id;\n-\n-         begin\n-            Build_Predicate_Function (E, FDecl, FBody);\n-\n-            if Present (FDecl) then\n-               Insert_After (N, FBody);\n-               Insert_After (N, FDecl);\n-            end if;\n-         end;\n-      end if;\n-\n       --  Pop scope if we installed one for the analysis\n \n       if In_Other_Scope then"}, {"sha": "20a7829dd0b3c3039a74da6b199a58ad84460840", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -215,7 +215,8 @@ package body Sem_Attr is\n       --  Output error message for use of a predicate (First, Last, Range) not\n       --  allowed with a type that has predicates. If the type is a generic\n       --  actual, then the message is a warning, and we generate code to raise\n-      --  program error with an appropriate reason.\n+      --  program error with an appropriate reason. No error message is given\n+      --  for internally generated uses of the attributes.\n \n       procedure Check_Array_Or_Scalar_Type;\n       --  Common procedure used by First, Last, Range attribute to check\n@@ -838,23 +839,10 @@ package body Sem_Attr is\n \n       procedure Bad_Attribute_For_Predicate is\n       begin\n-         if Has_Predicates (P_Type) then\n+         if Comes_From_Source (N) then\n             Error_Msg_Name_1 := Aname;\n-\n-            if Is_Generic_Actual_Type (P_Type) then\n-               Error_Msg_F\n-                 (\"type& has predicates, attribute % not allowed?\", P);\n-               Error_Msg_F\n-                 (\"\\?Program_Error will be raised at run time\", P);\n-               Rewrite (N,\n-                 Make_Raise_Program_Error (Loc,\n-                   Reason => PE_Bad_Attribute_For_Predicate));\n-\n-            else\n-               Error_Msg_F\n-                 (\"type& has predicates, attribute % not allowed\", P);\n-               Error_Attr;\n-            end if;\n+            Bad_Predicated_Subtype_Use\n+              (P_Type, N, \"type& has predicates, attribute % not allowed\");\n          end if;\n       end Bad_Attribute_For_Predicate;\n "}, {"sha": "216d709d6bc7ba2b7c03ed7f2f6704a41c64dc4f", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 146, "deletions": 91, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -32,7 +32,6 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n-with Sem_Case; use Sem_Case;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n@@ -43,23 +42,31 @@ with Sinfo;    use Sinfo;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n+with Ada.Unchecked_Deallocation;\n+\n with GNAT.Heap_Sort_G;\n \n package body Sem_Case is\n \n+   type Choice_Bounds is record\n+     Lo   : Node_Id;\n+     Hi   : Node_Id;\n+     Node : Node_Id;\n+   end record;\n+   --  Represent one choice bounds entry with Lo and Hi values, Node points\n+   --  to the choice node itself.\n+\n+   type Choice_Table_Type is array (Nat range <>) of Choice_Bounds;\n+   --  Table type used to sort the choices present in a case statement, array\n+   --  aggregate or record variant. The actual entries are stored in 1 .. Last,\n+   --  but we have a 0 entry for convenience in sorting.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   type Sort_Choice_Table_Type is array (Nat range <>) of Choice_Bounds;\n-   --  This new array type is used as the actual table type for sorting\n-   --  discrete choices. The reason for not using Choice_Table_Type, is that\n-   --  in Sort_Choice_Table_Type we reserve entry 0 for the sorting algorithm\n-   --  (this is not absolutely necessary but it makes the code more\n-   --  efficient).\n-\n    procedure Check_Choices\n-     (Choice_Table   : in out Sort_Choice_Table_Type;\n+     (Choice_Table   : in out Choice_Table_Type;\n       Bounds_Type    : Entity_Id;\n       Subtyp         : Entity_Id;\n       Others_Present : Boolean;\n@@ -101,7 +108,7 @@ package body Sem_Case is\n    -------------------\n \n    procedure Check_Choices\n-     (Choice_Table    : in out Sort_Choice_Table_Type;\n+     (Choice_Table   : in out Choice_Table_Type;\n       Bounds_Type    : Entity_Id;\n       Subtyp         : Entity_Id;\n       Others_Present : Boolean;\n@@ -321,7 +328,9 @@ package body Sem_Case is\n             Issue_Msg (Prev_Hi + 1, Lo - 1);\n          end if;\n \n-         Prev_Hi := Hi;\n+         if Hi > Prev_Hi then\n+            Prev_Hi := Hi;\n+         end if;\n       end loop;\n \n       if not Others_Present and then Expr_Value (Bounds_Hi) > Hi then\n@@ -511,7 +520,7 @@ package body Sem_Case is\n    --  Start of processing for Expand_Others_Choice\n \n    begin\n-      if Case_Table'Length = 0 then\n+      if Case_Table'Last = 0 then\n \n          --  Special case: only an others case is present.\n          --  The others case covers the full range of the type.\n@@ -537,9 +546,9 @@ package body Sem_Case is\n          Exp_Hi := Type_High_Bound (Base_Type (Choice_Type));\n       end if;\n \n-      Lo := Expr_Value (Case_Table (Case_Table'First).Lo);\n-      Hi := Expr_Value (Case_Table (Case_Table'First).Hi);\n-      Previous_Hi := Expr_Value (Case_Table (Case_Table'First).Hi);\n+      Lo := Expr_Value (Case_Table (1).Lo);\n+      Hi := Expr_Value (Case_Table (1).Hi);\n+      Previous_Hi := Expr_Value (Case_Table (1).Hi);\n \n       --  Build the node for any missing choices that are smaller than any\n       --  explicit choices given in the case.\n@@ -551,7 +560,7 @@ package body Sem_Case is\n       --  Build the nodes representing any missing choices that lie between\n       --  the explicit ones given in the case.\n \n-      for J in Case_Table'First + 1 .. Case_Table'Last loop\n+      for J in 2 .. Case_Table'Last loop\n          Lo := Expr_Value (Case_Table (J).Lo);\n          Hi := Expr_Value (Case_Table (J).Hi);\n \n@@ -588,7 +597,6 @@ package body Sem_Case is\n \n    procedure No_OP (C : Node_Id) is\n       pragma Warnings (Off, C);\n-\n    begin\n       null;\n    end No_OP;\n@@ -599,27 +607,39 @@ package body Sem_Case is\n \n    package body Generic_Choices_Processing is\n \n+      --  The following type is used to gather the entries for the choice\n+      --  table, so that we can then allocate the right length.\n+\n+      type Link;\n+      type Link_Ptr is access all Link;\n+\n+      type Link is record\n+         Val : Choice_Bounds;\n+         Nxt : Link_Ptr;\n+      end record;\n+\n+      procedure Free is new Ada.Unchecked_Deallocation (Link, Link_Ptr);\n+\n       ---------------------\n       -- Analyze_Choices --\n       ---------------------\n \n       procedure Analyze_Choices\n         (N              : Node_Id;\n          Subtyp         : Entity_Id;\n-         Choice_Table   : out Choice_Table_Type;\n-         Last_Choice    : out Nat;\n          Raises_CE      : out Boolean;\n          Others_Present : out Boolean)\n       is\n-         pragma Assert (Choice_Table'First = 1);\n-\n          E : Entity_Id;\n \n          Enode : Node_Id;\n          --  This is where we post error messages for bounds out of range\n \n-         Nb_Choices        : constant Nat := Choice_Table'Length;\n-         Sort_Choice_Table : Sort_Choice_Table_Type (0 .. Nb_Choices);\n+         Choice_List : Link_Ptr := null;\n+         --  Gather list of choices\n+\n+         Num_Choices : Nat := 0;\n+         --  Number of entries in Choice_List\n \n          Choice_Type : constant Entity_Id := Base_Type (Subtyp);\n          --  The actual type against which the discrete choices are resolved.\n@@ -648,13 +668,17 @@ package body Sem_Case is\n          Kind   : Node_Kind;\n          --  The node kind of the current Choice\n \n+         Delete_Choice : Boolean;\n+         --  Set to True to delete the current choice\n+\n          Others_Choice : Node_Id := Empty;\n          --  Remember others choice if it is present (empty otherwise)\n \n          procedure Check (Choice : Node_Id; Lo, Hi : Node_Id);\n          --  Checks the validity of the bounds of a choice. When the bounds\n-         --  are static and no error occurred the bounds are entered into the\n-         --  choices table so that they can be sorted later on.\n+         --  are static and no error occurred the bounds are collected for\n+         --  later entry into the choices table so that they can be sorted\n+         --  later on.\n \n          -----------\n          -- Check --\n@@ -706,8 +730,7 @@ package body Sem_Case is\n \n                --  If the choice is an entity name, then it is a type, and we\n                --  want to post the message on the reference to this entity.\n-               --  Otherwise we want to post it on the lower bound of the\n-               --  range.\n+               --  Otherwise post it on the lower bound of the range.\n \n                if Is_Entity_Name (Choice) then\n                   Enode := Choice;\n@@ -751,22 +774,20 @@ package body Sem_Case is\n                end if;\n             end if;\n \n-            --  Store bounds in the table\n+            --  Collect bounds in the list\n \n             --  Note: we still store the bounds, even if they are out of range,\n             --  since this may prevent unnecessary cascaded errors for values\n             --  that are covered by such an excessive range.\n \n-            Last_Choice := Last_Choice + 1;\n-            Sort_Choice_Table (Last_Choice).Lo   := Lo;\n-            Sort_Choice_Table (Last_Choice).Hi   := Hi;\n-            Sort_Choice_Table (Last_Choice).Node := Choice;\n+            Choice_List :=\n+              new Link'(Val => (Lo, Hi, Choice), Nxt => Choice_List);\n+            Num_Choices := Num_Choices + 1;\n          end Check;\n \n       --  Start of processing for Analyze_Choices\n \n       begin\n-         Last_Choice    := 0;\n          Raises_CE      := False;\n          Others_Present := False;\n \n@@ -811,6 +832,7 @@ package body Sem_Case is\n             else\n                Choice := First (Get_Choices (Alt));\n                while Present (Choice) loop\n+                  Delete_Choice := False;\n                   Analyze (Choice);\n                   Kind := Nkind (Choice);\n \n@@ -834,7 +856,45 @@ package body Sem_Case is\n                      else\n                         E := Entity (Choice);\n \n-                        if not Is_Static_Subtype (E) then\n+                        --  Case of predicated subtype\n+\n+                        if Has_Predicates (E) then\n+\n+                           --  Use of non-static predicate is an error\n+\n+                           if not Is_Discrete_Type (E)\n+                             or else No (Static_Predicate (E))\n+                           then\n+                              Bad_Predicated_Subtype_Use\n+                                (E, N,\n+                                 \"cannot use subtype&  with non-static \"\n+                                 & \"predicate as case alternative\");\n+\n+                              --  Static predicate case\n+\n+                           else\n+                              declare\n+                                 Copy : constant List_Id := Empty_List;\n+                                 P    : Node_Id;\n+                                 C    : Node_Id;\n+\n+                              begin\n+                                 P := First (Static_Predicate (E));\n+                                 while Present (P) loop\n+                                    C := New_Copy (P);\n+                                    Set_Sloc (C, Sloc (Choice));\n+                                    Append_To (Copy, C);\n+                                    Next (P);\n+                                 end loop;\n+\n+                                 Insert_List_After (Choice, Copy);\n+                                 Delete_Choice := True;\n+                              end;\n+                           end if;\n+\n+                        --  Not predicated subtype case\n+\n+                        elsif not Is_Static_Subtype (E) then\n                            Process_Non_Static_Choice (Choice);\n                         else\n                            Check\n@@ -848,6 +908,8 @@ package body Sem_Case is\n                      Resolve_Discrete_Subtype_Indication\n                        (Choice, Expected_Type);\n \n+                     --  Here for other than predicated subtype case\n+\n                      if Etype (Choice) /= Any_Type then\n                         declare\n                            C : constant Node_Id := Constraint (Choice);\n@@ -911,7 +973,18 @@ package body Sem_Case is\n                      Check (Choice, Choice, Choice);\n                   end if;\n \n-                  Next (Choice);\n+                  --  Move to next choice, deleting the current one if the\n+                  --  flag requesting this deletion is set True.\n+\n+                  declare\n+                     C : constant Node_Id := Choice;\n+                  begin\n+                     Next (Choice);\n+\n+                     if Delete_Choice then\n+                        Remove (C);\n+                     end if;\n+                  end;\n                end loop;\n \n                Process_Associated_Node (Alt);\n@@ -920,66 +993,48 @@ package body Sem_Case is\n             Next (Alt);\n          end loop;\n \n-         Check_Choices\n-           (Sort_Choice_Table (0 .. Last_Choice),\n-            Bounds_Type,\n-            Subtyp,\n-            Others_Present or else (Choice_Type = Universal_Integer),\n-            N);\n-\n-         --  Now copy the sorted discrete choices\n-\n-         for J in 1 .. Last_Choice loop\n-            Choice_Table (Choice_Table'First - 1 + J) := Sort_Choice_Table (J);\n-         end loop;\n+         --  Now we can create the Choice_Table, since we know how long\n+         --  it needs to be so we can allocate exactly the right length.\n \n-         --  If no others choice we are all done, otherwise we have one more\n-         --  step, which is to set the Others_Discrete_Choices field of the\n-         --  others choice (to contain all otherwise unspecified choices).\n-         --  Skip this if CE is known to be raised.\n+         declare\n+            Choice_Table : Choice_Table_Type (0 .. Num_Choices);\n \n-         if Others_Present and not Raises_CE then\n-            Expand_Others_Choice\n-              (Case_Table    => Choice_Table (1 .. Last_Choice),\n-               Others_Choice => Others_Choice,\n-               Choice_Type   => Bounds_Type);\n-         end if;\n+         begin\n+            --  Now copy the items we collected in the linked list into this\n+            --  newly allocated table (leave entry 0 unused for sorting).\n+\n+            declare\n+               T : Link_Ptr;\n+            begin\n+               for J in 1 .. Num_Choices loop\n+                  T := Choice_List;\n+                  Choice_List := T.Nxt;\n+                  Choice_Table (J) := T.Val;\n+                  Free (T);\n+               end loop;\n+            end;\n+\n+            Check_Choices\n+              (Choice_Table,\n+               Bounds_Type,\n+               Subtyp,\n+               Others_Present or else (Choice_Type = Universal_Integer),\n+               N);\n+\n+            --  If no others choice we are all done, otherwise we have one more\n+            --  step, which is to set the Others_Discrete_Choices field of the\n+            --  others choice (to contain all otherwise unspecified choices).\n+            --  Skip this if CE is known to be raised.\n+\n+            if Others_Present and not Raises_CE then\n+               Expand_Others_Choice\n+                 (Case_Table    => Choice_Table,\n+                  Others_Choice => Others_Choice,\n+                  Choice_Type   => Bounds_Type);\n+            end if;\n+         end;\n       end Analyze_Choices;\n \n-      -----------------------\n-      -- Number_Of_Choices --\n-      -----------------------\n-\n-      function Number_Of_Choices (N : Node_Id) return Nat is\n-         Alt : Node_Id;\n-         --  A case statement alternative or a record variant\n-\n-         Choice : Node_Id;\n-         Count  : Nat := 0;\n-\n-      begin\n-         if No (Get_Alternatives (N)) then\n-            return 0;\n-         end if;\n-\n-         Alt := First_Non_Pragma (Get_Alternatives (N));\n-         while Present (Alt) loop\n-\n-            Choice := First (Get_Choices (Alt));\n-            while Present (Choice) loop\n-               if Nkind (Choice) /= N_Others_Choice then\n-                  Count := Count + 1;\n-               end if;\n-\n-               Next (Choice);\n-            end loop;\n-\n-            Next_Non_Pragma (Alt);\n-         end loop;\n-\n-         return Count;\n-      end Number_Of_Choices;\n-\n    end Generic_Choices_Processing;\n \n end Sem_Case;"}, {"sha": "ccee41f02a9bf941268a3b894bb7869f0cfddbef", "filename": "gcc/ada/sem_case.ads", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_case.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_case.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.ads?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -34,16 +34,6 @@ with Types; use Types;\n \n package Sem_Case is\n \n-   type Choice_Bounds is record\n-     Lo   : Node_Id;\n-     Hi   : Node_Id;\n-     Node : Node_Id;\n-   end record;\n-\n-   type Choice_Table_Type is array (Pos range <>) of Choice_Bounds;\n-   --  Table type used to sort the choices present in a case statement,\n-   --  array aggregate or record variant.\n-\n    procedure No_OP (C : Node_Id);\n    --  The no-operation routine. Does absolutely nothing. Can be used\n    --  in the following generic for the parameter Process_Empty_Choice.\n@@ -75,40 +65,16 @@ package Sem_Case is\n \n    package Generic_Choices_Processing is\n \n-      function Number_Of_Choices (N : Node_Id) return Nat;\n-      --  Iterates through the choices of N, (N can be a case expression, case\n-      --  statement, array aggregate or record variant), counting all the\n-      --  Choice nodes except for the Others choice.\n-\n       procedure Analyze_Choices\n         (N              : Node_Id;\n          Subtyp         : Entity_Id;\n-         Choice_Table   : out Choice_Table_Type;\n-         Last_Choice    : out Nat;\n          Raises_CE      : out Boolean;\n          Others_Present : out Boolean);\n       --  From a case expression, case statement, array aggregate or record\n       --  variant N, this routine analyzes the corresponding list of discrete\n       --  choices. Subtyp is the subtype of the discrete choices. The type\n       --  against which the discrete choices must be resolved is its base type.\n       --\n-      --  On entry Choice_Table must be big enough to contain all the discrete\n-      --  choices encountered. The lower bound of Choice_Table must be one.\n-      --\n-      --  On exit Choice_Table contains all the static and non empty discrete\n-      --  choices in sorted order. Last_Choice gives the position of the last\n-      --  valid choice in Choice_Table, Choice_Table'First contains the first.\n-      --  We can have Last_Choice < Choice_Table'Last for one (or several) of\n-      --  the following reasons:\n-      --\n-      --    (a) The list of choices contained a non static choice\n-      --\n-      --    (b) The list of choices contained an empty choice\n-      --        (something like \"1 .. 0 => \")\n-      --\n-      --    (c) One of the bounds of a discrete choice contains an\n-      --        error or raises constraint error.\n-      --\n       --  In one of the bounds of a discrete choice raises a constraint\n       --  error the flag Raise_CE is set.\n       --"}, {"sha": "909fe8f1cebc1240980feb6281d93f547861e88a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 633, "deletions": 0, "changes": 633, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -77,6 +77,23 @@ package body Sem_Ch13 is\n    --  inherited from a derived type that is no longer appropriate for the\n    --  new Esize value. In this case, we reset the Alignment to unknown.\n \n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Build_Predicate_Function\n+     (Typ   : Entity_Id;\n+      FDecl : out Node_Id;\n+      FBody : out Node_Id);\n+   --  If Typ has predicates (indicated by Has_Predicates being set for Typ,\n+   --  then either there are pragma Invariant entries on the rep chain for the\n+   --  type (note that Predicate aspects are converted to pragam Predicate), or\n+   --  there are inherited aspects from a parent type, or ancestor subtypes,\n+   --  or interfaces. This procedure builds the spec and body for the Predicate\n+   --  function that tests these predicates, returning them in PDecl and Pbody\n+   --  and setting Predicate_Procedure for Typ. In some error situations no\n+   --  procedure is built, in which case PDecl/PBody are empty on return.\n+\n    function Get_Alignment_Value (Expr : Node_Id) return Uint;\n    --  Given the expression for an alignment value, returns the corresponding\n    --  Uint value. If the value is inappropriate, then error messages are\n@@ -3038,6 +3055,23 @@ package body Sem_Ch13 is\n       end if;\n \n       Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n+\n+      --  If we have a type with predicates, build predicate function\n+\n+      if Is_Type (E) and then Has_Predicates (E) then\n+         declare\n+            FDecl : Node_Id;\n+            FBody : Node_Id;\n+\n+         begin\n+            Build_Predicate_Function (E, FDecl, FBody);\n+\n+            if Present (FDecl) then\n+               Insert_After (N, FBody);\n+               Insert_After (N, FDecl);\n+            end if;\n+         end;\n+      end if;\n    end Analyze_Freeze_Entity;\n \n    ------------------------------------------\n@@ -3773,6 +3807,605 @@ package body Sem_Ch13 is\n       end if;\n    end Build_Invariant_Procedure;\n \n+   ------------------------------\n+   -- Build_Predicate_Function --\n+   ------------------------------\n+\n+   --  The procedure that is constructed here has the form\n+\n+   --  function typPredicate (Ixxx : typ) return Boolean is\n+   --  begin\n+   --     return\n+   --        exp1 and then exp2 and then ...\n+   --        and then typ1Predicate (typ1 (Ixxx))\n+   --        and then typ2Predicate (typ2 (Ixxx))\n+   --        and then ...;\n+   --  end typPredicate;\n+\n+   --  Here exp1, and exp2 are expressions from Predicate pragmas. Note that\n+   --  this is the point at which these expressions get analyzed, providing the\n+   --  required delay, and typ1, typ2, are entities from which predicates are\n+   --  inherited. Note that we do NOT generate Check pragmas, that's because we\n+   --  use this function even if checks are off, e.g. for membership tests.\n+\n+   procedure Build_Predicate_Function\n+     (Typ   : Entity_Id;\n+      FDecl : out Node_Id;\n+      FBody : out Node_Id)\n+   is\n+      Loc  : constant Source_Ptr := Sloc (Typ);\n+      Spec : Node_Id;\n+      SId  : Entity_Id;\n+\n+      Expr : Node_Id;\n+      --  This is the expression for the return statement in the function. It\n+      --  is build by connecting the component predicates with AND THEN.\n+\n+      procedure Add_Call (T : Entity_Id);\n+      --  Includes a call to the predicate function for type T in Expr if T\n+      --  has predicates and Predicate_Function (T) is non-empty.\n+\n+      procedure Add_Predicates;\n+      --  Appends expressions for any Predicate pragmas in the rep item chain\n+      --  Typ to Expr. Note that we look only at items for this exact entity.\n+      --  Inheritance of predicates for the parent type is done by calling the\n+      --  Predicate_Function of the parent type, using Add_Call above.\n+\n+      procedure Build_Static_Predicate;\n+      --  This function is called to process a static predicate, and put it in\n+      --  canonical form and store it in Static_Predicate (Typ).\n+\n+      Object_Name : constant Name_Id := New_Internal_Name ('I');\n+      --  Name for argument of Predicate procedure\n+\n+      --------------\n+      -- Add_Call --\n+      --------------\n+\n+      procedure Add_Call (T : Entity_Id) is\n+         Exp : Node_Id;\n+\n+      begin\n+         if Present (T) and then Present (Predicate_Function (T)) then\n+            Set_Has_Predicates (Typ);\n+\n+            --  Build the call to the predicate function of T\n+\n+            Exp :=\n+              Make_Predicate_Call\n+                (T,\n+                 Convert_To (T,\n+                   Make_Identifier (Loc, Chars => Object_Name)));\n+\n+            --  Add call to evolving expression, using AND THEN if needed\n+\n+            if No (Expr) then\n+               Expr := Exp;\n+            else\n+               Expr :=\n+                 Make_And_Then (Loc,\n+                   Left_Opnd  => Relocate_Node (Expr),\n+                   Right_Opnd => Exp);\n+            end if;\n+\n+            --  Output info message on inheritance if required\n+\n+            if Opt.List_Inherited_Aspects then\n+               Error_Msg_Sloc := Sloc (Predicate_Function (T));\n+               Error_Msg_Node_2 := T;\n+               Error_Msg_N (\"?info: & inherits predicate from & #\", Typ);\n+            end if;\n+         end if;\n+      end Add_Call;\n+\n+      --------------------\n+      -- Add_Predicates --\n+      --------------------\n+\n+      procedure Add_Predicates is\n+         Ritem : Node_Id;\n+         Arg1  : Node_Id;\n+         Arg2  : Node_Id;\n+\n+         function Replace_Node (N : Node_Id) return Traverse_Result;\n+         --  Process single node for traversal to replace type references\n+\n+         procedure Replace_Type is new Traverse_Proc (Replace_Node);\n+         --  Traverse an expression changing every occurrence of an entity\n+         --  reference to type T with a reference to the object argument.\n+\n+         ------------------\n+         -- Replace_Node --\n+         ------------------\n+\n+         function Replace_Node (N : Node_Id) return Traverse_Result is\n+         begin\n+            --  Case of entity name referencing the type\n+\n+            if Is_Entity_Name (N) and then Entity (N) = Typ then\n+\n+               --  Replace with object\n+\n+               Rewrite (N,\n+                 Make_Identifier (Loc,\n+                   Chars => Object_Name));\n+\n+               --  All done with this node\n+\n+               return Skip;\n+\n+            --  Not an occurrence of the type entity, keep going\n+\n+            else\n+               return OK;\n+            end if;\n+         end Replace_Node;\n+\n+      --  Start of processing for Add_Predicates\n+\n+      begin\n+         Ritem := First_Rep_Item (Typ);\n+         while Present (Ritem) loop\n+            if Nkind (Ritem) = N_Pragma\n+              and then Pragma_Name (Ritem) = Name_Predicate\n+            then\n+               Arg1 := First (Pragma_Argument_Associations (Ritem));\n+               Arg2 := Next (Arg1);\n+\n+               Arg1 := Get_Pragma_Arg (Arg1);\n+               Arg2 := Get_Pragma_Arg (Arg2);\n+\n+               --  See if this predicate pragma is for the current type\n+\n+               if Entity (Arg1) = Typ then\n+\n+                  --  We have a match, this entry is for our subtype\n+\n+                  --  First We need to replace any occurrences of the name of\n+                  --  the type with references to the object. We do this by\n+                  --  first doing a preanalysis, to identify all the entities,\n+                  --  then we traverse looking for the type entity, doing the\n+                  --  needed substitution. The preanalysis is done with the\n+                  --  special OK_To_Reference flag set on the type, so that if\n+                  --  we get an occurrence of this type, it will be recognized\n+                  --  as legitimate.\n+\n+                  Set_OK_To_Reference (Typ, True);\n+                  Preanalyze_Spec_Expression (Arg2, Standard_Boolean);\n+                  Set_OK_To_Reference (Typ, False);\n+                  Replace_Type (Arg2);\n+\n+                  --  OK, replacement complete, now we can add the expression\n+\n+                  if No (Expr) then\n+                     Expr := Relocate_Node (Arg2);\n+\n+                  --  There already was a predicate, so add to it\n+\n+                  else\n+                     Expr :=\n+                       Make_And_Then (Loc,\n+                         Left_Opnd  => Relocate_Node (Expr),\n+                         Right_Opnd => Relocate_Node (Arg2));\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Next_Rep_Item (Ritem);\n+         end loop;\n+      end Add_Predicates;\n+\n+      ----------------------------\n+      -- Build_Static_Predicate --\n+      ----------------------------\n+\n+      procedure Build_Static_Predicate is\n+         Exp : Node_Id;\n+         Alt : Node_Id;\n+\n+         Non_Static : Boolean := False;\n+         --  Set True if something non-static is found\n+\n+         Plist : List_Id := No_List;\n+         --  The entries in Plist are either static expressions which represent\n+         --  a possible value, or ranges of values. Subtype marks don't appear,\n+         --  since we expand them out.\n+\n+         Lo, Hi : Uint;\n+         --  Low bound and high bound values of static subtype of Typ\n+\n+         procedure Process_Entry (N : Node_Id);\n+         --  Process one entry (range or value or subtype mark)\n+\n+         -------------------\n+         -- Process_Entry --\n+         -------------------\n+\n+         procedure Process_Entry (N : Node_Id) is\n+            SLo, SHi : Uint;\n+            --  Low and high bounds of range in list\n+\n+            P : Node_Id;\n+\n+            function Build_Val (V : Uint) return Node_Id;\n+            --  Return an analyzed N_Identifier node referencing this value\n+\n+            function Build_Range (Lo, Hi : Uint) return Node_Id;\n+            --  Return an analyzed N_Range node referencing this range\n+\n+            function Lo_Val (N : Node_Id) return Uint;\n+            --  Given static expression or static range, gets expression value\n+            --  or low bound of range.\n+\n+            function Hi_Val (N : Node_Id) return Uint;\n+            --  Given static expression or static range, gets expression value\n+            --  of high bound of range.\n+\n+            -----------------\n+            -- Build_Range --\n+            -----------------\n+\n+            function Build_Range (Lo, Hi : Uint) return Node_Id is\n+               Result : Node_Id;\n+            begin\n+               if Lo = Hi then\n+                  return Build_Val (Hi);\n+               else\n+                  Result :=\n+                    Make_Range (Sloc (N),\n+                      Low_Bound  => Build_Val (Lo),\n+                      High_Bound => Build_Val (Hi));\n+                  Set_Etype (Result, Typ);\n+                  Set_Analyzed (Result);\n+                  return Result;\n+               end if;\n+            end Build_Range;\n+\n+            ---------------\n+            -- Build_Val --\n+            ---------------\n+\n+            function Build_Val (V : Uint) return Node_Id is\n+               Result : Node_Id;\n+\n+            begin\n+               if Is_Enumeration_Type (Typ) then\n+                  Result := Get_Enum_Lit_From_Pos (Typ, V, Sloc (N));\n+               else\n+                  Result := Make_Integer_Literal (Sloc (N), Intval => V);\n+               end if;\n+\n+               Set_Etype (Result, Typ);\n+               Set_Is_Static_Expression (Result);\n+               Set_Analyzed (Result);\n+               return Result;\n+            end Build_Val;\n+\n+            ------------\n+            -- Hi_Val --\n+            ------------\n+\n+            function Hi_Val (N : Node_Id) return Uint is\n+            begin\n+               if Nkind (N) = N_Identifier then\n+                  return Expr_Value (N);\n+               else\n+                  return Expr_Value (High_Bound (N));\n+               end if;\n+            end Hi_Val;\n+\n+            ------------\n+            -- Lo_Val --\n+            ------------\n+\n+            function Lo_Val (N : Node_Id) return Uint is\n+            begin\n+               if Nkind (N) = N_Identifier then\n+                  return Expr_Value (N);\n+               else\n+                  return Expr_Value (Low_Bound (N));\n+               end if;\n+            end Lo_Val;\n+\n+         --  Start of processing for Process_Entry\n+\n+         begin\n+            --  Range case\n+\n+            if Nkind (N) = N_Range then\n+               if not Is_Static_Expression (Low_Bound (N))\n+                    or else\n+                  not Is_Static_Expression (High_Bound (N))\n+               then\n+                  Non_Static := True;\n+                  return;\n+               else\n+                  SLo := Lo_Val (N);\n+                  SHi := Hi_Val (N);\n+               end if;\n+\n+            --  Identifier case\n+\n+            else pragma Assert (Nkind (N) = N_Identifier);\n+\n+               --  Static expression case\n+\n+               if Is_Static_Expression (N) then\n+                  SLo := Lo_Val (N);\n+                  SHi := Hi_Val (N);\n+\n+               --  Type case\n+\n+               elsif Is_Type (Entity (N)) then\n+\n+                  --  If type has static predicates, process them recursively\n+\n+                  if Present (Static_Predicate (Entity (N))) then\n+                     P := First (Static_Predicate (Entity (N)));\n+                     while Present (P) loop\n+                        Process_Entry (P);\n+\n+                        if Non_Static then\n+                           return;\n+                        else\n+                           Next (P);\n+                        end if;\n+                     end loop;\n+\n+                     return;\n+\n+                  --  For static subtype without predicates, get range\n+\n+                  elsif Is_Static_Subtype (Entity (N))\n+                    and then not Has_Predicates (Entity (N))\n+                  then\n+                     SLo := Expr_Value (Type_Low_Bound  (Entity (N)));\n+                     SHi := Expr_Value (Type_High_Bound (Entity (N)));\n+\n+                  --  Any other type makes us non-static\n+\n+                  else\n+                     Non_Static := True;\n+                     return;\n+                  end if;\n+\n+               --  Any other kind of identifier in predicate (e.g. a non-static\n+               --  expression value) means this is not a static predicate.\n+\n+               else\n+                  Non_Static := True;\n+                  return;\n+               end if;\n+            end if;\n+\n+            --  Here with SLo and SHi set for (possibly single element) range\n+            --  of entry to insert in Plist. Non-static if out of range.\n+\n+            if SLo < Lo or else SHi > Hi then\n+               Non_Static := True;\n+               return;\n+            end if;\n+\n+            --  If no Plist currently, create it\n+\n+            if No (Plist) then\n+               Plist := New_List (Build_Range (SLo, SHi));\n+               return;\n+\n+            --  Otherwise search Plist for insertion point\n+\n+            else\n+               P := First (Plist);\n+               loop\n+                  --  Case of inserting before current entry\n+\n+                  if SHi < Lo_Val (P) - 1 then\n+                     Insert_Before (P, Build_Range (SLo, SHi));\n+                     exit;\n+\n+                  --  Case of belongs past current entry\n+\n+                  elsif SLo > Hi_Val (P) + 1 then\n+\n+                     --  End of list case\n+\n+                     if No (Next (P)) then\n+                        Append_To (Plist, Build_Range (SLo, SHi));\n+                        exit;\n+\n+                     --  Else just move to next item on list\n+\n+                     else\n+                        Next (P);\n+                     end if;\n+\n+                  --  Case of extending current entyr, and in overlap cases\n+                  --  may also eat up entries past this one.\n+\n+                  else\n+                     declare\n+                        New_Lo : constant Uint := UI_Min (Lo_Val (P), SLo);\n+                        New_Hi : Uint          := UI_Max (Hi_Val (P), SHi);\n+\n+                     begin\n+                        --  See if there are entries past us that we eat up\n+\n+                        while Present (Next (P))\n+                          and then Lo_Val (Next (P)) <= New_Hi + 1\n+                        loop\n+                           New_Hi := Hi_Val (Next (P));\n+                           Remove (Next (P));\n+                        end loop;\n+\n+                        --  We now need to replace the current node P with\n+                        --  a new entry New_Lo .. New_Hi.\n+\n+                        Insert_After (P, Build_Range (New_Lo, New_Hi));\n+                        Remove (P);\n+                        exit;\n+                     end;\n+                  end if;\n+               end loop;\n+            end if;\n+         end Process_Entry;\n+\n+      --  Start of processing for Build_Static_Predicate\n+\n+      begin\n+         --  Immediately non-static if our subtype is non static, or we\n+         --  do not have an appropriate discrete subtype in the first place.\n+\n+         if not Ekind_In (Typ, E_Enumeration_Subtype,\n+                               E_Modular_Integer_Subtype,\n+                               E_Signed_Integer_Subtype)\n+           or else not Is_Static_Subtype (Typ)\n+         then\n+            return;\n+         end if;\n+\n+         Lo := Expr_Value (Type_Low_Bound  (Typ));\n+         Hi := Expr_Value (Type_High_Bound (Typ));\n+\n+         --  Check if we have membership predicate\n+\n+         if Nkind (Expr) = N_In then\n+            Exp := Expr;\n+\n+         --  Allow qualified expression with membership predicate inside\n+\n+         elsif Nkind (Expr) = N_Qualified_Expression\n+           and then Nkind (Expression (Expr)) = N_In\n+         then\n+            Exp := Expression (Expr);\n+\n+         --  Anything else cannot be a static predicate\n+\n+         else\n+            return;\n+         end if;\n+\n+         --  We have a membership operation, so we have a potentially static\n+         --  predicate, collect and canonicalize the entries in the list.\n+\n+         if Present (Right_Opnd (Exp)) then\n+            Process_Entry (Right_Opnd (Exp));\n+\n+            if Non_Static then\n+               return;\n+            end if;\n+\n+         else\n+            Alt := First (Alternatives (Exp));\n+            while Present (Alt) loop\n+               Process_Entry (Alt);\n+\n+               if Non_Static then\n+                  return;\n+               end if;\n+\n+               Next (Alt);\n+            end loop;\n+         end if;\n+\n+         --  Processing was successful and all entries were static, so\n+         --  now we can store the result as the predicate list.\n+\n+         Set_Static_Predicate (Typ, Plist);\n+      end Build_Static_Predicate;\n+\n+   --  Start of processing for Build_Predicate_Function\n+\n+   begin\n+      --  Initialize for construction of statement list\n+\n+      Expr  := Empty;\n+      FDecl := Empty;\n+      FBody := Empty;\n+\n+      --  Return if already built or if type does not have predicates\n+\n+      if not Has_Predicates (Typ)\n+        or else Present (Predicate_Function (Typ))\n+      then\n+         return;\n+      end if;\n+\n+      --  Add Predicates for the current type\n+\n+      Add_Predicates;\n+\n+      --  Add predicates for ancestor if present\n+\n+      declare\n+         Atyp : constant Entity_Id := Nearest_Ancestor (Typ);\n+      begin\n+         if Present (Atyp) then\n+            Add_Call (Atyp);\n+         end if;\n+      end;\n+\n+      --  If we have predicates, build the function\n+\n+      if Present (Expr) then\n+\n+         --  Deal with static predicate case\n+\n+         Build_Static_Predicate;\n+\n+         --  Build function declaration\n+\n+         pragma Assert (Has_Predicates (Typ));\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+         Set_Has_Predicates (SId);\n+         Set_Predicate_Function (Typ, SId);\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc, Chars => Object_Name),\n+                 Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+         FDecl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification => Spec);\n+\n+         --  Build function body\n+\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc, Chars => Object_Name),\n+                 Parameter_Type =>\n+                   New_Occurrence_Of (Typ, Loc))),\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+         FBody :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Spec,\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Make_Simple_Return_Statement (Loc,\n+                     Expression => Expr))));\n+      end if;\n+   end Build_Predicate_Function;\n+\n    -----------------------------------\n    -- Check_Constant_Address_Clause --\n    -----------------------------------"}, {"sha": "9371952fd5e3fa7932de0c84e13e78f594dff697", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -3842,7 +3842,14 @@ package body Sem_Ch3 is\n       Set_Is_Ada_2005_Only  (Id, Is_Ada_2005_Only  (T));\n       Set_Is_Ada_2012_Only  (Id, Is_Ada_2012_Only  (T));\n       Set_Convention        (Id, Convention        (T));\n-      Set_Has_Predicates    (Id, Has_Predicates    (T));\n+\n+      --  If ancestor has predicates then so does the subtype, and in addition\n+      --  we must delay the freeze to properly arrange predicate inheritance.\n+\n+      if Has_Predicates (T) then\n+         Set_Has_Predicates (Id);\n+         Set_Has_Delayed_Freeze (Id);\n+      end if;\n \n       --  In the case where there is no constraint given in the subtype\n       --  indication, Process_Subtype just returns the Subtype_Mark, so its\n@@ -4292,13 +4299,9 @@ package body Sem_Ch3 is\n       Discr_Name : Node_Id;\n       Discr_Type : Entity_Id;\n \n-      Case_Table     : Choice_Table_Type (1 .. Number_Of_Choices (N));\n-      Last_Choice    : Nat;\n       Dont_Care      : Boolean;\n       Others_Present : Boolean := False;\n \n-      pragma Warnings (Off, Case_Table);\n-      pragma Warnings (Off, Last_Choice);\n       pragma Warnings (Off, Dont_Care);\n       pragma Warnings (Off, Others_Present);\n       --  We don't care about the assigned values of any of these\n@@ -4332,8 +4335,7 @@ package body Sem_Ch3 is\n \n       --  Call the instantiated Analyze_Choices which does the rest of the work\n \n-      Analyze_Choices\n-        (N, Discr_Type, Case_Table, Last_Choice, Dont_Care, Others_Present);\n+      Analyze_Choices (N, Discr_Type, Dont_Care, Others_Present);\n    end Analyze_Variant_Part;\n \n    ----------------------------"}, {"sha": "45a4a218d6c0311e6e585e01c6b34646b46242f0", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -1137,7 +1137,6 @@ package body Sem_Ch4 is\n       Exp_Type  : Entity_Id;\n       Exp_Btype : Entity_Id;\n \n-      Last_Choice    : Nat;\n       Dont_Care      : Boolean;\n       Others_Present : Boolean;\n \n@@ -1154,8 +1153,6 @@ package body Sem_Ch4 is\n            Process_Associated_Node   => No_OP);\n       use Case_Choices_Processing;\n \n-      Case_Table : Choice_Table_Type (1 .. Number_Of_Choices (N));\n-\n       -----------------------------\n       -- Non_Static_Choice_Error --\n       -----------------------------\n@@ -1252,8 +1249,7 @@ package body Sem_Ch4 is\n \n       --  Call instantiated Analyze_Choices which does the rest of the work\n \n-      Analyze_Choices\n-        (N, Exp_Type, Case_Table, Last_Choice, Dont_Care, Others_Present);\n+      Analyze_Choices (N, Exp_Type, Dont_Care, Others_Present);\n \n       if Exp_Type = Universal_Integer and then not Others_Present then\n          Error_Msg_N\n@@ -5563,6 +5559,13 @@ package body Sem_Ch4 is\n          return False;\n       end if;\n \n+      --  If OK_To_Reference is set for the entity, then don't complain, it\n+      --  means we are doing a preanalysis in which such complaints are wrong.\n+\n+      if OK_To_Reference (Entity (Enode)) then\n+         return False;\n+      end if;\n+\n       --  Now test the entity we got to see if it is a bad case\n \n       case Ekind (Entity (Enode)) is"}, {"sha": "79ff1d2e68bbd884c77176c9f9ab2020b7cf1e3c", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -1018,12 +1018,6 @@ package body Sem_Ch5 is\n          Analyze_Statements (Statements (Alternative));\n       end Process_Statements;\n \n-      --  Table to record choices. Put after subprograms since we make\n-      --  a call to Number_Of_Choices to get the right number of entries.\n-\n-      Case_Table : Choice_Table_Type (1 .. Number_Of_Choices (N));\n-      pragma Warnings (Off, Case_Table);\n-\n    --  Start of processing for Analyze_Case_Statement\n \n    begin\n@@ -1096,8 +1090,7 @@ package body Sem_Ch5 is\n \n       --  Call instantiated Analyze_Choices which does the rest of the work\n \n-      Analyze_Choices\n-        (N, Exp_Type, Case_Table, Last_Choice, Dont_Care, Others_Present);\n+      Analyze_Choices (N, Exp_Type, Dont_Care, Others_Present);\n \n       if Exp_Type = Universal_Integer and then not Others_Present then\n          Error_Msg_N (\"case on universal integer requires OTHERS choice\", Exp);"}, {"sha": "ed34826646c8a185a1120c8df5401d22c69c503b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -329,6 +329,30 @@ package body Sem_Util is\n       end if;\n    end Apply_Compile_Time_Constraint_Error;\n \n+   --------------------------------\n+   -- Bad_Predicated_Subtype_Use --\n+   --------------------------------\n+\n+   procedure Bad_Predicated_Subtype_Use\n+     (Typ : Entity_Id;\n+      N   : Node_Id;\n+      Msg : String)\n+   is\n+   begin\n+      if Has_Predicates (Typ) then\n+         if Is_Generic_Actual_Type (Typ) then\n+            Error_Msg_F (Msg & '?', Typ);\n+            Error_Msg_F (\"\\Program_Error will be raised at run time?\", Typ);\n+            Insert_Action (N,\n+              Make_Raise_Program_Error (Sloc (N),\n+                Reason => PE_Bad_Predicated_Generic_Type));\n+\n+         else\n+            Error_Msg_F (Msg, Typ);\n+         end if;\n+      end if;\n+   end Bad_Predicated_Subtype_Use;\n+\n    --------------------------\n    -- Build_Actual_Subtype --\n    --------------------------"}, {"sha": "4031b243c4a818ecdc366aeaa16f90537eca59e9", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -93,6 +93,20 @@ package Sem_Util is\n    --  not end with a ? (this is used when the caller wants to parameterize\n    --  whether an error or warning is given.\n \n+   procedure Bad_Predicated_Subtype_Use\n+     (Typ : Entity_Id;\n+      N   : Node_Id;\n+      Msg : String);\n+   --  This is called when Typ, a predicated subtype, is used in a context\n+   --  which does not allow the use of a predicated subtype. Msg will be\n+   --  passed to Error_Msg_F to output an appropriate message. The caller\n+   --  should set up any insertions other than the & for the type itself.\n+   --  Note that if Typ is a generic actual type, then the message will be\n+   --  output as a warning, and a raise Program_Error is inserted using\n+   --  Insert_Action with node N as the insertion point. Node N also supplies\n+   --  the source location for construction of the raise node. If Typ is NOT a\n+   --  type with predicates this call has no effect.\n+\n    function Build_Actual_Subtype\n      (T : Entity_Id;\n       N : Node_Or_Entity_Id) return Node_Id;"}, {"sha": "ee2966c86a75fe49b6740be44923fb28e2e035a8", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86200f6646bd6f79ce534253da034238ebbf5e10/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=86200f6646bd6f79ce534253da034238ebbf5e10", "patch": "@@ -789,7 +789,7 @@ package Types is\n       PE_Accessibility_Check_Failed,     -- 15\n       PE_Address_Of_Intrinsic,           -- 16\n       PE_All_Guards_Closed,              -- 17\n-      PE_Bad_Attribute_For_Predicate,    -- 18\n+      PE_Bad_Predicated_Generic_Type,    -- 18\n       PE_Current_Task_In_Entry_Body,     -- 19\n       PE_Duplicated_Entry_Address,       -- 20\n       PE_Explicit_Raise,                 -- 21"}]}