{"sha": "8fdffa48c57f13b90556bc179150d24efdeeeef5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkZmZhNDhjNTdmMTNiOTA1NTZiYzE3OTE1MGQyNGVmZGVlZWVmNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-04T21:26:58Z"}, "committer": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-05T06:06:18Z"}, "message": "libcc1: use variadic templates for callbacks\n\nThis patch completes the transition of libcc1 from the use of separate\ntemplate functions for different arities to the use of variadic\nfunctions.  This is how I had wanted it to work from the very\nbeginning, and is possible now with C++11.\n\nI had thought that variadic callbacks required C++17, but it turns out\nthat the approach taken here is basically equivalent to std::apply --\njust a bit wordier.\n\nlibcc1\n\n\t* rpc.hh (argument_wrapper) <get>: Replace cast operator.\n\t(argument_wrapper<T *>) <get>: Likewise.\n\t(unmarshall): Add std::tuple overloads.\n\t(callback): Remove.\n\t(class invoker): New.\n\t* libcp1plugin.cc (plugin_init): Update.\n\t* libcp1.cc (libcp1::add_callbacks): Update.\n\t* libcc1plugin.cc (plugin_init): Update.\n\t* libcc1.cc (libcc1::add_callbacks): Update.\n\t* connection.cc (cc1_plugin::connection::do_wait): Update.", "tree": {"sha": "6b946a1fe949ce299c120d384e8d844eeab0ad87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b946a1fe949ce299c120d384e8d844eeab0ad87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fdffa48c57f13b90556bc179150d24efdeeeef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdffa48c57f13b90556bc179150d24efdeeeef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fdffa48c57f13b90556bc179150d24efdeeeef5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdffa48c57f13b90556bc179150d24efdeeeef5/comments", "author": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee75ca6b72e4235aa48d6fb30c5cd274f2ff6b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee75ca6b72e4235aa48d6fb30c5cd274f2ff6b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee75ca6b72e4235aa48d6fb30c5cd274f2ff6b67"}], "stats": {"total": 290, "additions": 88, "deletions": 202}, "files": [{"sha": "45560b9b790eea22e46d0e6d4272066c93d5bcd6", "filename": "libcc1/connection.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Fconnection.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Fconnection.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fconnection.cc?ref=8fdffa48c57f13b90556bc179150d24efdeeeef5", "patch": "@@ -129,7 +129,7 @@ cc1_plugin::connection::do_wait (bool want_result)\n \t\t  return FAIL;\n \n \t\tcallback_ftype *callback\n-\t\t  = m_callbacks.find_callback (method_name);\n+\t\t  = m_callbacks.find_callback (method_name.get ());\n \t\t// The call to CALLBACK is where we may end up in a\n \t\t// reentrant call.\n \t\tif (callback == NULL || !callback (this))"}, {"sha": "febadc8420b0a420d5491f8b53c0655f6da7598a", "filename": "libcc1/libcc1.cc", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Flibcc1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Flibcc1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1.cc?ref=8fdffa48c57f13b90556bc179150d24efdeeeef5", "patch": "@@ -143,15 +143,13 @@ void\n libcc1::add_callbacks ()\n {\n   cc1_plugin::callback_ftype *fun\n-    = cc1_plugin::callback<int,\n-\t\t\t   enum gcc_c_oracle_request,\n-\t\t\t   const char *,\n-\t\t\t   c_call_binding_oracle>;\n+    = cc1_plugin::invoker<int,\n+\t\t\t  enum gcc_c_oracle_request,\n+\t\t\t  const char *>::invoke<c_call_binding_oracle>;\n   connection->add_callback (\"binding_oracle\", fun);\n \n-  fun = cc1_plugin::callback<gcc_address,\n-\t\t\t     const char *,\n-\t\t\t     c_call_symbol_address>;\n+  fun = cc1_plugin::invoker<gcc_address,\n+\t\t\t    const char *>::invoke<c_call_symbol_address>;\n   connection->add_callback (\"address_oracle\", fun);\n }\n "}, {"sha": "4d6a3a11ee221268ea20c0fa26fe2f7fe96f9bbd", "filename": "libcc1/libcc1plugin.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Flibcc1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Flibcc1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1plugin.cc?ref=8fdffa48c57f13b90556bc179150d24efdeeeef5", "patch": "@@ -762,46 +762,46 @@ plugin_init (struct plugin_name_args *plugin_info,\n #define GCC_METHOD0(R, N)\t\t\t\\\n   {\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\\\n-      = cc1_plugin::callback<R, plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\\\n   }\n #define GCC_METHOD1(R, N, A)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\t\\\n-      = cc1_plugin::callback<R, A, plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\t\\\n   }\n #define GCC_METHOD2(R, N, A, B)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\t\\\n-      = cc1_plugin::callback<R, A, B, plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A, B>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\t\\\n   }\n #define GCC_METHOD3(R, N, A, B, C)\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\t\\\n-      = cc1_plugin::callback<R, A, B, C, plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A, B, C>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\t\\\n   }\n #define GCC_METHOD4(R, N, A, B, C, D)\t\t\\\n   {\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\\\n-      = cc1_plugin::callback<R, A, B, C, D,\t\\\n-\t\t\t     plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A, B, C,\t\t\\\n+\t\t\t    D>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\\\n   }\n #define GCC_METHOD5(R, N, A, B, C, D, E)\t\\\n   {\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\\\n-      = cc1_plugin::callback<R, A, B, C, D, E,\t\\\n-\t\t\t     plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A, B, C, D,\t\\\n+\t\t\t    E>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\\\n   }\n #define GCC_METHOD7(R, N, A, B, C, D, E, F, G)\t\t\\\n   {\t\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\t\\\n-      = cc1_plugin::callback<R, A, B, C, D, E, F, G,\t\\\n-\t\t\t     plugin_ ## N>;\t\t\\\n+      = cc1_plugin::invoker<R, A, B, C, D,\t\t\\\n+\t\t\t    E, F, G>::invoke<plugin_ ## N>;\t\t\\\n     current_context->add_callback (# N, fun);\t\t\\\n   }\n "}, {"sha": "a93349833901a55d6322df77a58e03fb3f61d0d9", "filename": "libcc1/libcp1.cc", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Flibcp1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Flibcp1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1.cc?ref=8fdffa48c57f13b90556bc179150d24efdeeeef5", "patch": "@@ -166,23 +166,18 @@ void\n libcp1::add_callbacks ()\n {\n   cc1_plugin::callback_ftype *fun\n-    = cc1_plugin::callback<int,\n-\t\t\t   enum gcc_cp_oracle_request,\n-\t\t\t   const char *,\n-\t\t\t   cp_call_binding_oracle>;\n+    = cc1_plugin::invoker<int, enum gcc_cp_oracle_request,\n+\t\t\t  const char *>::invoke<cp_call_binding_oracle>;\n   connection->add_callback (\"binding_oracle\", fun);\n \n-  fun = cc1_plugin::callback<gcc_address,\n-\t\t\t     const char *,\n-\t\t\t     cp_call_symbol_address>;\n+  fun = cc1_plugin::invoker<gcc_address,\n+\t\t\t    const char *>::invoke<cp_call_symbol_address>;\n   connection->add_callback (\"address_oracle\", fun);\n \n-  fun = cc1_plugin::callback<int,\n-\t\t\t     cp_call_enter_scope>;\n+  fun = cc1_plugin::invoker<int>::invoke<cp_call_enter_scope>;\n   connection->add_callback (\"enter_scope\", fun);\n \n-  fun = cc1_plugin::callback<int,\n-\t\t\t     cp_call_leave_scope>;\n+  fun = cc1_plugin::invoker<int>::invoke<cp_call_leave_scope>;\n   connection->add_callback (\"leave_scope\", fun);\n }\n "}, {"sha": "79694b9196411ab71a8ad5934c12b2e6a1b7c4ac", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=8fdffa48c57f13b90556bc179150d24efdeeeef5", "patch": "@@ -3509,46 +3509,46 @@ plugin_init (struct plugin_name_args *plugin_info,\n #define GCC_METHOD0(R, N)\t\t\t\\\n   {\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\\\n-      = cc1_plugin::callback<R, plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\\\n   }\n #define GCC_METHOD1(R, N, A)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\t\\\n-      = cc1_plugin::callback<R, A, plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\t\\\n   }\n #define GCC_METHOD2(R, N, A, B)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\t\\\n-      = cc1_plugin::callback<R, A, B, plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A, B>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\t\\\n   }\n #define GCC_METHOD3(R, N, A, B, C)\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\t\\\n-      = cc1_plugin::callback<R, A, B, C, plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A, B, C>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\t\\\n   }\n #define GCC_METHOD4(R, N, A, B, C, D)\t\t\\\n   {\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\\\n-      = cc1_plugin::callback<R, A, B, C, D,\t\\\n-\t\t\t     plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A, B, C,\t\t\\\n+\t\t\t    D>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\\\n   }\n #define GCC_METHOD5(R, N, A, B, C, D, E)\t\\\n   {\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\\\n-      = cc1_plugin::callback<R, A, B, C, D, E,\t\\\n-\t\t\t     plugin_ ## N>;\t\\\n+      = cc1_plugin::invoker<R, A, B, C,\t\t\\\n+\t\t\t    D, E>::invoke<plugin_ ## N>;\t\\\n     current_context->add_callback (# N, fun);\t\\\n   }\n #define GCC_METHOD7(R, N, A, B, C, D, E, F, G)\t\t\\\n   {\t\t\t\t\t\t\t\\\n     cc1_plugin::callback_ftype *fun\t\t\t\\\n-      = cc1_plugin::callback<R, A, B, C, D, E, F, G,\t\\\n-\t\t\t     plugin_ ## N>;\t\t\\\n+      = cc1_plugin::invoker<R, A, B, C,\t\t\t\\\n+\t\t\t    D, E, F, G>::invoke<plugin_ ## N>;\t\t\\\n     current_context->add_callback (# N, fun);\t\t\\\n   }\n "}, {"sha": "8e43fa146dcc8c7fff28db0804550f6182faf9aa", "filename": "libcc1/rpc.hh", "status": "modified", "additions": 56, "deletions": 163, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Frpc.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdffa48c57f13b90556bc179150d24efdeeeef5/libcc1%2Frpc.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Frpc.hh?ref=8fdffa48c57f13b90556bc179150d24efdeeeef5", "patch": "@@ -43,7 +43,7 @@ namespace cc1_plugin\n     argument_wrapper (const argument_wrapper &) = delete;\n     argument_wrapper &operator= (const argument_wrapper &) = delete;\n \n-    operator T () const { return m_object; }\n+    T get () const { return m_object; }\n \n     status unmarshall (connection *conn)\n     {\n@@ -68,7 +68,7 @@ namespace cc1_plugin\n \n     typedef typename std::remove_const<T>::type type;\n \n-    operator const type * () const\n+    const type *get () const\n     {\n       return m_object.get ();\n     }\n@@ -88,17 +88,14 @@ namespace cc1_plugin\n   };\n \n   // There are two kinds of template functions here: \"call\" and\n-  // \"callback\".  \"call\" is implemented with variadic templates, but\n-  // \"callback\" is repeated multiple times to handle different numbers\n-  // of arguments.  (This could be improved with C++17 and\n-  // std::apply.)\n+  // \"invoker\".\n \n   // The \"call\" template is used for making a remote procedure call.\n   // It starts a query ('Q') packet, marshalls its arguments, waits\n   // for a result, and finally reads and returns the result via an\n   // \"out\" parameter.\n \n-  // The \"callback\" template is used when receiving a remote procedure\n+  // The \"invoker\" template is used when receiving a remote procedure\n   // call.  This template function is suitable for use with the\n   // \"callbacks\" and \"connection\" classes.  It decodes incoming\n   // arguments, passes them to the wrapped function, and finally\n@@ -123,175 +120,71 @@ namespace cc1_plugin\n     return OK;\n   }\n \n-  template<typename R, R (*func) (connection *)>\n-  status\n-  callback (connection *conn)\n+  // The base case -- just return OK.\n+  template<int I, typename... T>\n+  typename std::enable_if<I == sizeof... (T), status>::type\n+  unmarshall (connection *, std::tuple<T...> &)\n   {\n-    R result;\n-\n-    if (!unmarshall_check (conn, 0))\n-      return FAIL;\n-    result = func (conn);\n-    if (!conn->send ('R'))\n-      return FAIL;\n-    return marshall (conn, result);\n-  }\n-\n-  template<typename R, typename A, R (*func) (connection *, A)>\n-  status\n-  callback (connection *conn)\n-  {\n-    argument_wrapper<A> arg;\n-    R result;\n-\n-    if (!unmarshall_check (conn, 1))\n-      return FAIL;\n-    if (!arg.unmarshall (conn))\n-      return FAIL;\n-    result = func (conn, arg);\n-    if (!conn->send ('R'))\n-      return FAIL;\n-    return marshall (conn, result);\n+    return OK;\n   }\n \n-  template<typename R, typename A1, typename A2, R (*func) (connection *,\n-\t\t\t\t\t\t\t    A1, A2)>\n-  status\n-  callback (connection *conn)\n+  // Unmarshall this argument, then unmarshall all subsequent args.\n+  template<int I, typename... T>\n+  typename std::enable_if<I < sizeof... (T), status>::type\n+  unmarshall (connection *conn, std::tuple<T...> &value)\n   {\n-    argument_wrapper<A1> arg1;\n-    argument_wrapper<A2> arg2;\n-    R result;\n-\n-    if (!unmarshall_check (conn, 2))\n-      return FAIL;\n-    if (!arg1.unmarshall (conn))\n-      return FAIL;\n-    if (!arg2.unmarshall (conn))\n+    if (!std::get<I> (value).unmarshall (conn))\n       return FAIL;\n-    result = func (conn, arg1, arg2);\n-    if (!conn->send ('R'))\n-      return FAIL;\n-    return marshall (conn, result);\n+    return unmarshall<I + 1, T...> (conn, value);\n   }\n \n-  template<typename R, typename A1, typename A2, typename A3,\n-\t   R (*func) (connection *, A1, A2, A3)>\n-  status\n-  callback (connection *conn)\n+  // Wrap a static function that is suitable for use as a callback.\n+  // This is a template function inside a template class to work\n+  // around limitations with multiple variadic packs.\n+  template<typename R, typename... Arg>\n+  class invoker\n   {\n-    argument_wrapper<A1> arg1;\n-    argument_wrapper<A2> arg2;\n-    argument_wrapper<A3> arg3;\n-    R result;\n+    // Base case -- we can call the function.\n+    template<int I, R func (connection *, Arg...), typename... T>\n+    static typename std::enable_if<I == sizeof... (Arg), R>::type\n+    call (connection *conn, const std::tuple<argument_wrapper<Arg>...> &,\n+\t  T... args)\n+    {\n+      return func (conn, args...);\n+    }\n \n-    if (!unmarshall_check (conn, 3))\n-      return FAIL;\n-    if (!arg1.unmarshall (conn))\n-      return FAIL;\n-    if (!arg2.unmarshall (conn))\n-      return FAIL;\n-    if (!arg3.unmarshall (conn))\n-      return FAIL;\n-    result = func (conn, arg1, arg2, arg3);\n-    if (!conn->send ('R'))\n-      return FAIL;\n-    return marshall (conn, result);\n-  }\n+    // Unpack one argument and continue the recursion.\n+    template<int I, R func (connection *, Arg...), typename... T>\n+    static typename std::enable_if<I < sizeof... (Arg), R>::type\n+    call (connection *conn, const std::tuple<argument_wrapper<Arg>...> &value,\n+\t  T... args)\n+    {\n+      return call<I + 1, func> (conn, value, args...,\n+\t\t\t\tstd::get<I> (value).get ());\n+    }\n \n-  template<typename R, typename A1, typename A2, typename A3, typename A4,\n-\t   R (*func) (connection *, A1, A2, A3, A4)>\n-  status\n-  callback (connection *conn)\n-  {\n-    argument_wrapper<A1> arg1;\n-    argument_wrapper<A2> arg2;\n-    argument_wrapper<A3> arg3;\n-    argument_wrapper<A4> arg4;\n-    R result;\n+  public:\n \n-    if (!unmarshall_check (conn, 4))\n-      return FAIL;\n-    if (!arg1.unmarshall (conn))\n-      return FAIL;\n-    if (!arg2.unmarshall (conn))\n-      return FAIL;\n-    if (!arg3.unmarshall (conn))\n-      return FAIL;\n-    if (!arg4.unmarshall (conn))\n-      return FAIL;\n-    result = func (conn, arg1, arg2, arg3, arg4);\n-    if (!conn->send ('R'))\n-      return FAIL;\n-    return marshall (conn, result);\n-  }\n+    // A callback function that reads arguments from the connection,\n+    // calls the wrapped function, and then sends the result back on\n+    // the connection.\n+    template<R func (connection *, Arg...)>\n+    static status\n+    invoke (connection *conn)\n+    {\n+      if (!unmarshall_check (conn, sizeof... (Arg)))\n+\treturn FAIL;\n+      std::tuple<argument_wrapper<Arg>...> wrapped;\n+      if (!unmarshall<0> (conn, wrapped))\n+\treturn FAIL;\n \n-  template<typename R, typename A1, typename A2, typename A3, typename A4,\n-\t   typename A5, R (*func) (connection *, A1, A2, A3, A4, A5)>\n-  status\n-  callback (connection *conn)\n-  {\n-    argument_wrapper<A1> arg1;\n-    argument_wrapper<A2> arg2;\n-    argument_wrapper<A3> arg3;\n-    argument_wrapper<A4> arg4;\n-    argument_wrapper<A5> arg5;\n-    R result;\n-\n-    if (!unmarshall_check (conn, 5))\n-      return FAIL;\n-    if (!arg1.unmarshall (conn))\n-      return FAIL;\n-    if (!arg2.unmarshall (conn))\n-      return FAIL;\n-    if (!arg3.unmarshall (conn))\n-      return FAIL;\n-    if (!arg4.unmarshall (conn))\n-      return FAIL;\n-    if (!arg5.unmarshall (conn))\n-      return FAIL;\n-    result = func (conn, arg1, arg2, arg3, arg4, arg5);\n-    if (!conn->send ('R'))\n-      return FAIL;\n-    return marshall (conn, result);\n-  }\n+      R result = call<0, func> (conn, wrapped);\n \n-  template<typename R, typename A1, typename A2, typename A3, typename A4,\n-\t   typename A5, typename A6, typename A7,\n-\t   R (*func) (connection *, A1, A2, A3, A4, A5, A6, A7)>\n-  status\n-  callback (connection *conn)\n-  {\n-    argument_wrapper<A1> arg1;\n-    argument_wrapper<A2> arg2;\n-    argument_wrapper<A3> arg3;\n-    argument_wrapper<A4> arg4;\n-    argument_wrapper<A5> arg5;\n-    argument_wrapper<A6> arg6;\n-    argument_wrapper<A7> arg7;\n-    R result;\n-\n-    if (!unmarshall_check (conn, 7))\n-      return FAIL;\n-    if (!arg1.unmarshall (conn))\n-      return FAIL;\n-    if (!arg2.unmarshall (conn))\n-      return FAIL;\n-    if (!arg3.unmarshall (conn))\n-      return FAIL;\n-    if (!arg4.unmarshall (conn))\n-      return FAIL;\n-    if (!arg5.unmarshall (conn))\n-      return FAIL;\n-    if (!arg6.unmarshall (conn))\n-      return FAIL;\n-    if (!arg7.unmarshall (conn))\n-      return FAIL;\n-    result = func (conn, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n-    if (!conn->send ('R'))\n-      return FAIL;\n-    return marshall (conn, result);\n-  }\n+      if (!conn->send ('R'))\n+\treturn FAIL;\n+      return marshall (conn, result);\n+    }\n+  };\n };\n \n #endif // CC1_PLUGIN_RPC_HH"}]}