{"sha": "049d28935129d6c2daa4993899f25a27e7b239af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ5ZDI4OTM1MTI5ZDZjMmRhYTQ5OTM4OTlmMjVhMjdlN2IyMzlhZg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2011-09-10T00:47:02Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-09-10T00:47:02Z"}, "message": "tuple: Use everywhere std::size_t...\n\n2011-09-09  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/std/tuple: Use everywhere std::size_t... instead of int...\n\t* include/std/functional: Likewise.\n\t* include/std/scoped_allocator: Likewise.\n\t* include/bits/stl_pair.h: Likewise.\n\nFrom-SVN: r178746", "tree": {"sha": "154eda56aed65fcdc4a80fc2f24a7aa86d2dfc02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/154eda56aed65fcdc4a80fc2f24a7aa86d2dfc02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/049d28935129d6c2daa4993899f25a27e7b239af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049d28935129d6c2daa4993899f25a27e7b239af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/049d28935129d6c2daa4993899f25a27e7b239af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049d28935129d6c2daa4993899f25a27e7b239af/comments", "author": null, "committer": null, "parents": [{"sha": "25e723bdecca5da30b51aa3a00889550e7c6a6c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e723bdecca5da30b51aa3a00889550e7c6a6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e723bdecca5da30b51aa3a00889550e7c6a6c5"}], "stats": {"total": 57, "additions": 32, "deletions": 25}, "files": [{"sha": "64f7551cc37c9518e55cb340379957bc553994e3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=049d28935129d6c2daa4993899f25a27e7b239af", "patch": "@@ -1,3 +1,10 @@\n+2011-09-09  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/std/tuple: Use everywhere std::size_t... instead of int...\n+\t* include/std/functional: Likewise.\n+\t* include/std/scoped_allocator: Likewise.\n+\t* include/bits/stl_pair.h: Likewise.\n+\n 2011-09-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/50336"}, {"sha": "bb33cc6437d938a71a10f2cbd016c291f41c0365", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=049d28935129d6c2daa4993899f25a27e7b239af", "patch": "@@ -79,7 +79,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename...>\n     class tuple;\n \n-  template<int...>\n+  template<std::size_t...>\n     struct _Index_tuple;\n #endif\n \n@@ -206,7 +206,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstatic _Tp\n \t__cons(tuple<_Args...>&&);\n \n-      template<typename _Tp, typename... _Args, int... _Indexes>\n+      template<typename _Tp, typename... _Args, std::size_t... _Indexes>\n \tstatic _Tp\n \t__do_cons(tuple<_Args...>&&, const _Index_tuple<_Indexes...>&);\n #endif"}, {"sha": "4a04eca896973cbf6b3233227ef67a743b7fb948", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=049d28935129d6c2daa4993899f25a27e7b239af", "patch": "@@ -914,7 +914,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    * template handles the case where it is safe to use @c\n    * tuple_element.\n    */\n-  template<int __i, typename _Tuple, bool _IsSafe>\n+  template<std::size_t __i, typename _Tuple, bool _IsSafe>\n     struct _Safe_tuple_element_impl\n     : tuple_element<__i, _Tuple> { };\n \n@@ -923,7 +923,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    * specialization handles the case where it is not safe to use @c\n    * tuple_element. We just return @c _No_tuple_element.\n    */\n-  template<int __i, typename _Tuple>\n+  template<std::size_t __i, typename _Tuple>\n     struct _Safe_tuple_element_impl<__i, _Tuple, false>\n     {\n       typedef _No_tuple_element type;\n@@ -933,10 +933,10 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    * Like tuple_element, but returns @c _No_tuple_element when\n    * tuple_element would return an error.\n    */\n- template<int __i, typename _Tuple>\n+ template<std::size_t __i, typename _Tuple>\n    struct _Safe_tuple_element\n    : _Safe_tuple_element_impl<__i, _Tuple,\n-\t\t\t      (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n+\t\t\t      (__i < tuple_size<_Tuple>::value)>\n    { };\n \n   /**\n@@ -999,7 +999,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     private:\n       // Invokes the underlying function object __arg by unpacking all\n       // of the arguments in the tuple.\n-      template<typename _CVArg, typename... _Args, int... _Indexes>\n+      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>\n \tauto\n \t__call(_CVArg& __arg, tuple<_Args...>& __tuple,\n \t       const _Index_tuple<_Indexes...>&) const volatile\n@@ -1112,14 +1112,14 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     };\n \n   // std::get<I> for volatile-qualified tuples\n-  template<size_t _Ind, typename... _Tp>\n+  template<std::size_t _Ind, typename... _Tp>\n     inline auto\n     __volget(volatile tuple<_Tp...>& __tuple)\n     -> typename tuple_element<_Ind, tuple<_Tp...>>::type volatile&\n     { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }\n \n   // std::get<I> for const-volatile-qualified tuples\n-  template<size_t _Ind, typename... _Tp>\n+  template<std::size_t _Ind, typename... _Tp>\n     inline auto\n     __volget(const volatile tuple<_Tp...>& __tuple)\n     -> typename tuple_element<_Ind, tuple<_Tp...>>::type const volatile&\n@@ -1141,7 +1141,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       tuple<_Bound_args...> _M_bound_args;\n \n       // Call unqualified\n-      template<typename _Result, typename... _Args, int... _Indexes>\n+      template<typename _Result, typename... _Args, std::size_t... _Indexes>\n \t_Result\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)\n \t{\n@@ -1150,7 +1150,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as const\n-      template<typename _Result, typename... _Args, int... _Indexes>\n+      template<typename _Result, typename... _Args, std::size_t... _Indexes>\n \t_Result\n \t__call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const\n \t{\n@@ -1159,7 +1159,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as volatile\n-      template<typename _Result, typename... _Args, int... _Indexes>\n+      template<typename _Result, typename... _Args, std::size_t... _Indexes>\n \t_Result\n \t__call_v(tuple<_Args...>&& __args,\n \t\t _Index_tuple<_Indexes...>) volatile\n@@ -1169,7 +1169,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as const volatile\n-      template<typename _Result, typename... _Args, int... _Indexes>\n+      template<typename _Result, typename... _Args, std::size_t... _Indexes>\n \t_Result\n \t__call_c_v(tuple<_Args...>&& __args,\n \t\t   _Index_tuple<_Indexes...>) const volatile\n@@ -1272,7 +1272,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \tstruct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };\n \n       // Call unqualified\n-      template<typename _Res, typename... _Args, int... _Indexes>\n+      template<typename _Res, typename... _Args, std::size_t... _Indexes>\n \t_Result\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n \t    typename __disable_if_void<_Res>::type = 0)\n@@ -1282,7 +1282,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call unqualified, return void\n-      template<typename _Res, typename... _Args, int... _Indexes>\n+      template<typename _Res, typename... _Args, std::size_t... _Indexes>\n \tvoid\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n \t    typename __enable_if_void<_Res>::type = 0)\n@@ -1292,7 +1292,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as const\n-      template<typename _Res, typename... _Args, int... _Indexes>\n+      template<typename _Res, typename... _Args, std::size_t... _Indexes>\n \t_Result\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n \t    typename __disable_if_void<_Res>::type = 0) const\n@@ -1302,7 +1302,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as const, return void\n-      template<typename _Res, typename... _Args, int... _Indexes>\n+      template<typename _Res, typename... _Args, std::size_t... _Indexes>\n \tvoid\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n \t    typename __enable_if_void<_Res>::type = 0) const\n@@ -1312,7 +1312,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as volatile\n-      template<typename _Res, typename... _Args, int... _Indexes>\n+      template<typename _Res, typename... _Args, std::size_t... _Indexes>\n \t_Result\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n \t    typename __disable_if_void<_Res>::type = 0) volatile\n@@ -1322,7 +1322,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as volatile, return void\n-      template<typename _Res, typename... _Args, int... _Indexes>\n+      template<typename _Res, typename... _Args, std::size_t... _Indexes>\n \tvoid\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n \t    typename __enable_if_void<_Res>::type = 0) volatile\n@@ -1332,7 +1332,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as const volatile\n-      template<typename _Res, typename... _Args, int... _Indexes>\n+      template<typename _Res, typename... _Args, std::size_t... _Indexes>\n \t_Result\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n \t    typename __disable_if_void<_Res>::type = 0) const volatile\n@@ -1342,7 +1342,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t}\n \n       // Call as const volatile, return void\n-      template<typename _Res, typename... _Args, int... _Indexes>\n+      template<typename _Res, typename... _Args, std::size_t... _Indexes>\n \tvoid\n \t__call(tuple<_Args...>&& __args,\n \t       _Index_tuple<_Indexes...>,\n@@ -1533,7 +1533,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n     private:\n \n-      template<int... _Indices>\n+      template<std::size_t... _Indices>\n         typename result_of<_Callable(_Args...)>::type\n         _M_invoke(_Index_tuple<_Indices...>)\n         {"}, {"sha": "9fd53db6133a54039a5b99a83dce51ef6a542e94", "filename": "libstdc++-v3/include/std/scoped_allocator", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator?ref=049d28935129d6c2daa4993899f25a27e7b239af", "patch": "@@ -234,7 +234,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           return __a_traits::select_on_container_copy_construction(__a);\n         }\n \n-      template<int... _Indices>\n+      template<std::size_t... _Indices>\n         scoped_allocator_adaptor(tuple<const _OuterAlloc&,\n                                        const _InnerAllocs&...> __refs,\n                                  _Index_tuple<_Indices...>)"}, {"sha": "515fb4ea001102279a8f8aded396f02b5b4f63aa", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049d28935129d6c2daa4993899f25a27e7b239af/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=049d28935129d6c2daa4993899f25a27e7b239af", "patch": "@@ -1011,7 +1011,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * Stores a tuple of indices. Used by bind() to extract the elements\n    * in a tuple. \n    */\n-  template<int... _Indexes>\n+  template<std::size_t... _Indexes>\n     struct _Index_tuple\n     {\n       typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;\n@@ -1042,7 +1042,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n   template<class _T1, class _T2>\n-    template<typename _Tp, typename... _Args, int... _Indexes>\n+    template<typename _Tp, typename... _Args, std::size_t... _Indexes>\n       inline _Tp\n       pair<_T1, _T2>::__do_cons(tuple<_Args...>&& __tuple,\n \t\t\t\tconst _Index_tuple<_Indexes...>&)"}]}