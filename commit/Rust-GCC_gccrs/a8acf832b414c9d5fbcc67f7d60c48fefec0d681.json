{"sha": "a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThhY2Y4MzJiNDE0YzlkNWZiY2M2N2Y3ZDYwYzQ4ZmVmZWMwZDY4MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-29T14:13:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-29T14:13:37Z"}, "message": "[multiple changes]\n\n2013-01-29  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Document all Ada 2005 and Ada 2012 pragmas as\n\tbeing available as implementation-defined pragmas in earlier\n\tversions of Ada.\n\n2013-01-29  Vincent Celier  <celier@adacore.com>\n\n\t* clean.adb (Delete): On VMS, delete all versions of the file.\n\nFrom-SVN: r195537", "tree": {"sha": "76c00a4cf2bdbf76dbcc97d0709e6bce48271194", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76c00a4cf2bdbf76dbcc97d0709e6bce48271194"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8acf832b414c9d5fbcc67f7d60c48fefec0d681/comments", "author": null, "committer": null, "parents": [{"sha": "42f1d66133be06839a62c257d0f56db2b321d994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f1d66133be06839a62c257d0f56db2b321d994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f1d66133be06839a62c257d0f56db2b321d994"}], "stats": {"total": 229, "additions": 221, "deletions": 8}, "files": [{"sha": "c466f7073de5f4d78fd23a6c2da7bd9e7164454d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8acf832b414c9d5fbcc67f7d60c48fefec0d681/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8acf832b414c9d5fbcc67f7d60c48fefec0d681/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "patch": "@@ -1,3 +1,13 @@\n+2013-01-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Document all Ada 2005 and Ada 2012 pragmas as\n+\tbeing available as implementation-defined pragmas in earlier\n+\tversions of Ada.\n+\n+2013-01-29  Vincent Celier  <celier@adacore.com>\n+\n+\t* clean.adb (Delete): On VMS, delete all versions of the file.\n+\n 2013-01-29  Robert Dewar  <dewar@adacore.com>\n \n \t* par-ch6.adb (No_Constraint_Maybe_Expr_Func): New procedure."}, {"sha": "560ceb7d33ee8b859acc39a2572e7b3ca8199884", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8acf832b414c9d5fbcc67f7d60c48fefec0d681/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8acf832b414c9d5fbcc67f7d60c48fefec0d681/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "patch": "@@ -1250,7 +1250,19 @@ package body Clean is\n            or else Is_Writable_File (Full_Name (1 .. Last))\n            or else Is_Symbolic_Link (Full_Name (1 .. Last))\n          then\n-            Delete_File (Full_Name (1 .. Last), Success);\n+            --  On VMS, we have to delete all versions of the file\n+\n+            if OpenVMS_On_Target then\n+               Delete_File (Full_Name (1 .. Last) & \";*\", Success);\n+\n+            --  Otherwise just delete the specified file\n+\n+            else\n+               Delete_File (Full_Name (1 .. Last), Success);\n+            end if;\n+\n+         --  Here if no deletion required\n+\n          else\n             Success := False;\n          end if;"}, {"sha": "15d1901c8d447cc2a64a24da85f10f96f03ed007", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 198, "deletions": 7, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8acf832b414c9d5fbcc67f7d60c48fefec0d681/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8acf832b414c9d5fbcc67f7d60c48fefec0d681/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "patch": "@@ -128,9 +128,12 @@ Implementation Defined Pragmas\n * Pragma CPP_Constructor::\n * Pragma CPP_Virtual::\n * Pragma CPP_Vtable::\n+* Pragma CPU::\n * Pragma Debug::\n * Pragma Debug_Policy::\n+* Pragma Default_Storage_Pool::\n * Pragma Detect_Blocking::\n+* Pragma Dispatching_Domain::\n * Pragma Elaboration_Checks::\n * Pragma Eliminate::\n * Pragma Export_Exception::\n@@ -155,6 +158,8 @@ Implementation Defined Pragmas\n * Pragma Import_Object::\n * Pragma Import_Procedure::\n * Pragma Import_Valued_Procedure::\n+* Pragma Independent::\n+* Pragma Independent_Components::\n * Pragma Initialize_Scalars::\n * Pragma Inline_Always::\n * Pragma Inline_Generic::\n@@ -182,15 +187,19 @@ Implementation Defined Pragmas\n * Pragma Optimize_Alignment::\n * Pragma Ordered::\n * Pragma Overflow_Mode::\n+* Pragma Partition_Elaboration_Policy::\n * Pragma Passive::\n * Pragma Persistent_BSS::\n * Pragma Polling::\n * Pragma Postcondition::\n * Pragma Precondition::\n+* Pragma Preelaborable_Initialization::\n+* Pragma Priority_Specific_Dispatching::\n * Pragma Profile (Ravenscar)::\n * Pragma Profile (Restricted)::\n * Pragma Psect_Object::\n * Pragma Pure_Function::\n+* Pragma Relative_Deadline::\n * Pragma Remote_Access_Type::\n * Pragma Restriction_Warnings::\n * Pragma Shared::\n@@ -868,9 +877,12 @@ consideration, the use of these pragmas should be minimized.\n * Pragma CPP_Constructor::\n * Pragma CPP_Virtual::\n * Pragma CPP_Vtable::\n+* Pragma CPU::\n * Pragma Debug::\n * Pragma Debug_Policy::\n+* Pragma Default_Storage_Pool::\n * Pragma Detect_Blocking::\n+* Pragma Dispatching_Domain::\n * Pragma Elaboration_Checks::\n * Pragma Eliminate::\n * Pragma Export_Exception::\n@@ -895,6 +907,8 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Import_Object::\n * Pragma Import_Procedure::\n * Pragma Import_Valued_Procedure::\n+* Pragma Independent::\n+* Pragma Independent_Components::\n * Pragma Initialize_Scalars::\n * Pragma Inline_Always::\n * Pragma Inline_Generic::\n@@ -922,15 +936,19 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Optimize_Alignment::\n * Pragma Ordered::\n * Pragma Overflow_Mode::\n+* Pragma Partition_Elaboration_Policy::\n * Pragma Passive::\n * Pragma Persistent_BSS::\n * Pragma Polling::\n * Pragma Postcondition::\n * Pragma Precondition::\n+* Pragma Preelaborable_Initialization::\n+* Pragma Priority_Specific_Dispatching::\n * Pragma Profile (Ravenscar)::\n * Pragma Profile (Restricted)::\n * Pragma Psect_Object::\n * Pragma Pure_Function::\n+* Pragma Relative_Deadline::\n * Pragma Remote_Access_Type::\n * Pragma Restriction_Warnings::\n * Pragma Shared::\n@@ -1210,6 +1228,9 @@ pragma Assertion_Policy (CHECK | DISABLE | IGNORE);\n @end smallexample\n \n @noindent\n+This is a standard Ada 2005 pragma that is available as an\n+implementation-defined pragma in earlier versions of Ada.\n+\n If the argument is @code{CHECK}, then assertions are enabled.\n If the argument is @code{IGNORE}, then assertions are ignored.\n This pragma overrides the effect of the @option{-gnata} switch on the\n@@ -2039,6 +2060,21 @@ the same object layout than the G++ compiler.\n \n See @ref{Interfacing to C++} for related information.\n \n+@node Pragma CPU\n+@unnumberedsec Pragma CPU\n+@findex CPU\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma CPU (EXPRESSSION);\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2012, but is available in all earlier\n+versions of Ada as an implementation-defined pragma.\n+See Ada 2012 Reference Manual for details.\n+\n @node Pragma Debug\n @unnumberedsec Pragma Debug\n @findex Debug\n@@ -2089,6 +2125,21 @@ be useful when the pragma argument references subprograms\n in a with'ed package which is replaced by a dummy package\n for the final build.\n \n+@node Pragma Default_Storage_Pool\n+@unnumberedsec Pragma Default_Storage_Pool\n+@findex Default_Storage_Pool\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Default_Storage_Pool (storage_pool_NAME | null);\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2012, but is available in all earlier\n+versions of Ada as an implementation-defined pragma.\n+See Ada 2012 Reference Manual for details.\n+\n @node Pragma Detect_Blocking\n @unnumberedsec Pragma Detect_Blocking\n @findex Detect_Blocking\n@@ -2100,10 +2151,28 @@ pragma Detect_Blocking;\n @end smallexample\n \n @noindent\n+This is a standard pragma in Ada 2005, that is available in all earlier\n+versions of Ada as an implementation-defined pragma.\n+\n This is a configuration pragma that forces the detection of potentially\n blocking operations within a protected operation, and to raise Program_Error\n if that happens.\n \n+@node Pragma Dispatching_Domain\n+@unnumberedsec Pragma Dispatching_Domain\n+@findex Dispatching_Domain\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Dispatching_Domain (EXPRESSION);\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2012, but is available in all earlier\n+versions of Ada as an implementation-defined pragma.\n+See Ada 2012 Reference Manual for details.\n+\n @node Pragma Elaboration_Checks\n @unnumberedsec Pragma Elaboration_Checks\n @cindex Elaboration control\n@@ -2825,7 +2894,8 @@ This is an Ada 2012 representation pragma which applies to protected, task\n and synchronized interface primitives. The use of pragma Implemented provides\n a way to impose a static requirement on the overriding operation by adhering\n to one of the three implementation kids: entry, protected procedure or any of\n-the above.\n+the above. This pragma is available in all earlier versions of Ada as an\n+implementation-defined pragma.\n \n @smallexample @c ada\n type Synch_Iface is synchronized interface;\n@@ -3151,6 +3221,48 @@ Note that it is important to use this pragma in conjunction with a separate\n pragma Import that specifies the desired convention, since otherwise the\n default convention is Ada, which is almost certainly not what is required.\n \n+@node Pragma Independent\n+@unnumberedsec Pragma Independent\n+@findex Independent\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Independent (Local_NAME);\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2012 mode (which also provides an aspect\n+of the same name). It is also available as an implementation-defined\n+pragma in all earlier versions. It specifies that the\n+designated object or all objects of the designated type must be\n+independently addressable. This means that separate tasks can safely\n+manipulate such objects. For example, if two comonents of a record are\n+independent, then two separate tasks may access these two components.\n+This may place\n+constraints on the representation of the object (for instance prohibiting\n+tight packing).\n+\n+@node Pragma Independent_Components\n+@unnumberedsec Pragma Independent_Components\n+@findex Independent_Components\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Independent_Components (Local_NAME);\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2012 mode (which also provides an aspect\n+of the same name). It is also available as an implementation-defined\n+pragma in all earlier versions. It specifies that the components of the\n+designated object or all objects of the designated type must be\n+independently addressable. This means that separate tasks can safely\n+manipulate separate components in the composite object. this may place\n+constraints on the representation of the object (for instance prohibiting\n+tight packing).\n+\n @node Pragma Initialize_Scalars\n @unnumberedsec Pragma Initialize_Scalars\n @findex Initialize_Scalars\n@@ -3846,8 +3958,9 @@ an exception. Another use of this pragma is to suppress incorrect warnings\n about missing returns in functions, where the last statement of a function\n statement sequence is a call to such a procedure.\n \n-Note that in Ada 2005 mode, this pragma is part of the language, and is\n-identical in effect to the pragma as implemented in Ada 95 mode.\n+Note that in Ada 2005 mode, this pragma is part of the language. It is\n+available in all earlier versions of Ada as an implementation-defined\n+pragma.\n \n @node Pragma No_Strict_Aliasing\n @unnumberedsec Pragma No_Strict_Aliasing\n@@ -4259,6 +4372,23 @@ overflow checking, but does not affect the overflow mode.\n The pragma @code{Unsuppress (Overflow_Check)} unsuppresses (enables)\n overflow checking, but does not affect the overflow mode.\n \n+@node Pragma Partition_Elaboration_Policy\n+@unnumberedsec Pragma Partition_Elaboration_Policy\n+@findex Partition_Elaboration_Policy\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Partition_Elaboration_Policy (POLICY_IDENTIFIER);\n+\n+POLICY_IDENTIFIER ::= Concurrent | Sequential\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2005, but is available in all earlier\n+versions of Ada as an implementation-defined pragma.\n+See Ada 2012 Reference Manual for details.\n+\n @node Pragma Passive\n @unnumberedsec Pragma Passive\n @findex Passive\n@@ -4511,6 +4641,45 @@ inlining (-gnatN option set) are accepted and legality-checked\n by the compiler, but are ignored at run-time even if postcondition\n checking is enabled.\n \n+@node Pragma Preelaborable_Initialization\n+@unnumberedsec Pragma Preelaborable_Initialization\n+@findex Preelaborable_Initialization\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Preelaborable_Initialization (DIRECT_NAME);\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2005, but is available in all earlier\n+versions of Ada as an implementation-defined pragma.\n+See Ada 2012 Reference Manual for details.\n+\n+@node Pragma Priority_Specific_Dispatching\n+@unnumberedsec Pragma Priority_Specific_Dispatching\n+@findex Priority_Specific_Dispatching\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Priority_Specific_Dispatching (\n+   POLICY_IDENTIFIER,\n+   first_priority_EXPRESSION,\n+   last_priority_EXPRESSION)\n+\n+POLICY_IDENTIFIER ::=\n+   EDF_Across_Priorities            |\n+   FIFO_Within_Priorities           |\n+   Non_Preemptive_Within_Priorities |\n+   Round_Robin_Within_Priorities\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2005, but is available in all earlier\n+versions of Ada as an implementation-defined pragma.\n+See Ada 2012 Reference Manual for details.\n+\n @node Pragma Precondition\n @unnumberedsec Pragma Precondition\n @cindex Preconditions\n@@ -4566,11 +4735,13 @@ checking is enabled.\n Syntax:\n \n @smallexample @c ada\n-pragma Profile (Ravenscar);\n+pragma Profile (Ravenscar | Restricted);\n @end smallexample\n \n @noindent\n-A configuration pragma that establishes the following set of configuration\n+This pragma is standard in Ada 2005, but is available in all earlier\n+versions of Ada as an implementation-defined pragma. This is a\n+configuration pragma that establishes the following set of configuration\n pragmas:\n \n @table @code\n@@ -4666,7 +4837,9 @@ pragma Profile (Restricted);\n @end smallexample\n \n @noindent\n-A configuration pragma that establishes the following set of restrictions:\n+This is an implementation-defined version of the standard pragma defined\n+in Ada 2005. It is available in all versions of Ada. It is a\n+configuration pragma that establishes the following set of restrictions:\n \n @itemize @bullet\n @item No_Abort_Statements\n@@ -4774,6 +4947,21 @@ function is also considered pure from an optimization point of view, but the\n unit is not a Pure unit in the categorization sense. So for example, a function\n thus marked is free to @code{with} non-pure units.\n \n+@node Pragma Relative_Deadline\n+@unnumberedsec Pragma Relative_Deadline\n+@findex Relative_Deadline\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Relative_Deadline (time_span_EXPRESSSION);\n+@end smallexample\n+\n+@noindent\n+This pragma is standard in Ada 2005, but is available in all earlier\n+versions of Ada as an implementation-defined pragma.\n+See Ada 2012 Reference Manual for details.\n+\n @node Pragma Remote_Access_Type\n @unnumberedsec Pragma Remote_Access_Type\n @findex Remote_Access_Type\n@@ -5605,7 +5793,7 @@ equivalent to a C union. It was introduced as a GNAT implementation defined\n pragma in the GNAT Ada 95 mode. Ada 2005 includes an extended version of this\n pragma, making it language defined, and GNAT fully implements this extended\n version in all language modes (Ada 83, Ada 95, and Ada 2005). For full\n-details, consult the Ada 2005 Reference Manual, section B.3.3.\n+details, consult the Ada 2012 Reference Manual, section B.3.3.\n \n @node Pragma Unimplemented_Unit\n @unnumberedsec Pragma Unimplemented_Unit\n@@ -5826,6 +6014,9 @@ code depends on the checks for its correct functioning, so that the code\n will compile correctly even if the compiler switches are set to suppress\n checks.\n \n+This pragma is standard in Ada 2005. It is available in all earlier versions\n+of Ada as an implementation-defined pragma.\n+\n @node Pragma Use_VADS_Size\n @unnumberedsec Pragma Use_VADS_Size\n @cindex @code{Size}, VADS compatibility"}]}