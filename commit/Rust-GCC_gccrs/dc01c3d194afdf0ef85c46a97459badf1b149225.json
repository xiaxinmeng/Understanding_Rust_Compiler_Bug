{"sha": "dc01c3d194afdf0ef85c46a97459badf1b149225", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwMWMzZDE5NGFmZGYwZWY4NWM0NmE5NzQ1OWJhZGYxYjE0OTIyNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-28T20:45:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-28T20:45:40Z"}, "message": "Work towards NEXT_INSN/PREV_INSN requiring insns as their params\n\ngcc/\n2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n\n\t* cfgexpand.c (pass_expand::execute): Strengthen local \"after\"\n\tfrom rtx to rtx_insn *.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Replace use of local\n\trtx \"note\" with new local rtx_insn * \"new_head\" when calculating\n\thead insn of new basic block.\n\t* combine.c (combine_split_insns): Strengthen return type and local\n\t\"ret\" from rtx to rtx_insn *.\n\t(likely_spilled_retval_p): Likewise for locals \"use\" and \"p\".\n\t(try_combine): Eliminate local \"m_split\", splitting into new\n\tlocals \"m_split_insn\" and \"m_split_pat\".\n\t(find_split_point): Strengthen local \"seq\" from rtx into\n\trtx_insn *.\n\t* config/spu/spu.c (spu_machine_dependent_reorg): Likewise for\n\tlocals \"label\", \"branch\".\n\t* config/spu/spu.md (define_expand \"smulsi3_highpart\"): Likewise\n\tfor local \"insn\".\n\t(define_expand \"umulsi3_highpart\"): Likewise for local \"insn\".\n\t* dse.c (note_add_store_info): Likewise for fields \"first\",\n\t\"current\".\n\t(note_add_store): Likewise for local \"insn\".\n\t(emit_inc_dec_insn_before): Likewise for locals \"insn\",\n\t\"new_insn\", \"cur\".\n\t(find_shift_sequence): Likewise for locals \"shift_seq\", \"insn\".\n\t(replace_read): Likewise for locals \"insns\", \"this_insn\".\n\t* dwarf2cfi.c (dw_trace_info): Likewise for field \"eh_head\".\n\t(notice_eh_throw): Likewise for param \"insn\".\n\t(before_next_cfi_note): Likewise for return type, param, and local\n\t\"prev\".\n\t(connect_traces): Likewise for local \"note\".\n\t* emit-rtl.c (reset_all_used_flags): Likewise for local \"p\".\n\t(verify_rtl_sharing): Likewise.\n\t(unshare_all_rtl_in_chain): Likewise for param \"insn\".\n\t(get_first_nonnote_insn): Likewise for local \"insn\".\n\t(get_last_nonnote_insn): Likewise.  Introduce local rtx_sequence *\n\t\"seq\" and use its methods to clarify things.\n\t(next_insn): Strengthen return type from rtx to rtx_insn *.\n\tRename param \"insn\" to \"uncast_insn\" and reintroduce \"insn\" as a\n\tlocal rtx_insn * using a checked cast, dropping a checked cast\n\tmade redundant by this change.  Use a cast to and method of\n\trtx_sequence to clarify the code.\n\t(previous_insn): Rename param \"insn\" to \"uncast_insn\" and\n\treintroduce \"insn\" as a local rtx_insn * using a checked cast,\n\tdropping a checked cast made redundant by this change.  Use a cast\n\tto and method of rtx_sequence to clarify the code.\n\t(next_nonnote_insn): Rename param \"insn\" to \"uncast_insn\" and\n\treintroduce \"insn\" as a local rtx_insn * using a checked cast,\n\tdropping a checked cast made redundant by this change.\n\t(next_nonnote_insn_bb): Likewise.\n\t(prev_nonnote_insn): Likewise.\n\t(prev_nonnote_insn_bb): Likewise.\n\t(next_nondebug_insn): Likewise.\n\t(prev_nondebug_insn): Likewise.\n\t(next_nonnote_nondebug_insn): Likewise.\n\t(prev_nonnote_nondebug_insn): Likewise.\n\t(next_real_insn): Likewise.\n\t(prev_real_insn): Likewise.\n\t(next_active_insn): Likewise.\n\t(prev_active_insn): Likewise.\n\t(next_cc0_user): Likewise.  Use rtx_sequence and a method for\n\tclarity.\n\t(prev_cc0_setter): Likewise.\n\t(try_split): Rename param \"trial\" to \"uncast_trial\" and\n\treintroduce \"insn\" as a local rtx_insn * using a checked cast,\n\tdropping checked casts made redundant by this change.\n\tStrengthen locals \"seq\", \"tem\", \"insn_last\", \"insn\", \"next\" from\n\trtx to rtx_insn *.\n\t(remove_insn): Rename param \"insn\" to \"uncast_insn\" and\n\treintroduce \"insn\" as a local rtx_insn * using a checked cast.\n\t(emit_pattern_after_setloc): Likewise for param \"after\", as\n\t\"uncast_after\".\n\t(emit_pattern_after): Likewise.  Strengthen local \"prev\" from\n\trtx to rtx_insn *.\n\t(emit_pattern_before_setloc): Rename param \"before\" to\n\t\"uncast_before\" and reintroduce \"before\" as a local rtx_insn *\n\tusing a checked cast.  Strengthen locals \"first\", \"last\" from\n\trtx to rtx_insn *.\n\t(emit_pattern_before): Likewise rename/cast param \"before\" to\n\t\"uncast_before\". Strengthen local \"next\" from rtx to rtx_insn *.\n\t* except.c (copy_reg_eh_region_note_forward): Strengthen param\n\t\"first\" and local \"insn\" from rtx to rtx_insn *.\n\t(copy_reg_eh_region_note_backward): Likewise for param \"last\"\n\tand local \"insn\".\n\t* expr.c (fixup_args_size_notes): Rename param \"last\" to\n\t\"uncast_last\" and reintroduce \"last\" as a local rtx_insn *\n\tusing a checked cast.  Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t* function.c (set_insn_locations): Strengthen param \"insn\" from\n\trtx to rtx_insn *.\n\t(record_insns): Likewise for param \"insns\" and local \"tmp\".\n\t(active_insn_between): Rename param \"tail\" to\n\t\"uncast_tail\" and reintroduce \"tail\" as a local rtx_insn *\n\tusing a checked cast.\n\t(thread_prologue_and_epilogue_insns): Split out top-level local\n\trtx \"seq\" into three different rtx_insn * locals.  Strengthen\n\tlocal \"prologue_seq\" from rtx to rtx_insn *.\n\t* gcse.c (insert_insn_end_basic_block): Strenghen local \"insn\"\n\tfrom rtx to rtx_insn *.\n\t* haifa-sched.c (initiate_bb_reg_pressure_info): Likewise.\n\t(priority): Likewise for locals \"prev_first\", \"twin\".\n\t(setup_insn_max_reg_pressure): Likewise for param \"after\".\n\t(sched_setup_bb_reg_pressure_info): Likewise.\n\t(no_real_insns_p): Strengthen params from const_rtx to\n\tconst rtx_insn *.\n\t(schedule_block): Strengthen local \"next_tail\" from rtx to\n\trtx_insn *.\n\t* ifcvt.c (find_active_insn_before): Strengthen return type and\n\tparam \"insn\" from rtx to rtx_insn *.\n\t(find_active_insn_after): Likewise.\n\t(cond_exec_process_insns): Likewise for param \"start\" and local \"insn\".\n\t(cond_exec_process_if_block): Likewise for locals \"then_start\",\n\t\"then_end\", \"else_start\", \"else_end\", \"insn\", \"start\", \"end\", \"from\".\n\t(noce_process_if_block): Likewise for local \"jump\".\n\t(merge_if_block): Likewise for two locals named \"end\".\n\t(cond_exec_find_if_block): Likewise for local \"last_insn\".\n\t* jump.c (delete_related_insns): Rename param \"insn\" to\n\t\"uncast_insn\" and reintroduce \"insn\" as a local rtx_insn * using a\n\tchecked cast.  Strengthen local \"p\" from rtx to rtx_insn *.\n\t* lra-constraints.c (inherit_reload_reg): Replace NULL_RTX with\n\tNULL.\n\t(split_reg): Likewise.\n\t* lra.c (lra_process_new_insns): Likewise.\n\t* modulo-sched.c (permute_partial_schedule): Strengthen param\n\t\"last\" from rtx to rtx_insn *.\n\t* optabs.c (add_equal_note): Likewise for param \"insns\" and local\n\t\"last_insn\".\n\t(expand_binop_directly): Add checked casts to rtx_insn * within\n\tNEXT_INSN (pat) uses.\n\t(expand_unop_direct): Likewise.\n\t(maybe_emit_unop_insn): Likewise.\n\t* recog.c (peep2_attempt): Strengthen locals \"last\",\n\t\"before_try\", \"x\" from rtx to rtx_insn *.\n\t* reorg.c (optimize_skip): Strengthen return type and local\n\t\"delay_list\" from rtx to rtx_insn_list *.  Strengthen param \"insn\"\n\tand locals \"trial\", \"next_trial\" from rtx to rtx_insn *.\n\t* resource.c (next_insn_no_annul): Strengthen return type and\n\tparam \"insn\" from rtx to rtx_insn *.  Use a cast to and method of\n\trtx_sequence to clarify the code.\n\t(mark_referenced_resources): Add a checked cast to rtx_insn *\n\twithin PREV_INSN (x).\n\t(find_dead_or_set_registers): Strengthen return type, param\n\t\"target\", locals \"insn\", \"next\", \"jump_insn\", \"this_jump_insn\"\n\tfrom rtx to rtx_insn *.  Strengthen param \"jump_target\" from rtx *\n\tto rtx_insn **.\n\t(mark_target_live_regs): Strengthen params \"insns\" and \"target\",\n\tlocals \"insn\", \"jump_target\", \"start_insn\", \"stop_insn\" from rtx\n\tto rtx_insn *.  Use cast to and method of rtx_sequence to clarify\n\tthe code.\n\t* resource.h (mark_target_live_regs): Strengthen params 1 and 2\n\tfrom rtx to rtx_insn *.\n\t* rtl.h (copy_reg_eh_region_note_forward): Strengthen second param\n\tfrom rtx to rtx_insn *.\n\t(copy_reg_eh_region_note_backward): Likewise.\n\t(unshare_all_rtl_in_chain): Likewise for sole param.\n\t(dump_rtl_slim): Strengthen second and third params from const_rtx\n\tto const rtx_insn *.\n\t* sched-deps.c (sched_free_deps): Strengthen params \"head\" and\n\t\"tail\" and locals \"insn\", \"next_tail\" from rtx to rtx_insn *.\n\t* sched-ebb.c (init_ready_list): Strengthen locals \"prev_head\",\n\t\"next_tail\" from rtx to rtx_insn *.\n\t(begin_move_insn): Likewise for local \"next\".\n\t* sched-int.h (sched_free_deps): Likewise for first and second\n\tparams.\n\t(no_real_insns_p): Strengthen both params from const_rtx to\n\tconst rtx_insn *.\n\t(sched_setup_bb_reg_pressure_info): Strengthen second params from\n\trtx to rtx_insn *.\n\t* sched-rgn.c (init_ready_list): Likewise for locals \"prev_head\",\n\t\"next_tail\".\n\t* sched-vis.c (dump_rtl_slim): Strengthen params \"first\", \"last\"\n\tand locals \"insn\", \"tail\" from const_rtx to const rtx_insn *.\n\t(rtl_dump_bb_for_graph): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(debug_rtl_slim): Strengthen params \"first\" and \"last\" from\n\tconst_rtx to const rtx_insn *.\n\t* shrink-wrap.c (try_shrink_wrapping): Strengthen param\n\t\"prologue_seq\" and locals \"seq\", \"p_insn\" from rtx to rtx_insn *.\n\t(convert_to_simple_return): Likewise for param \"returnjump\".\n\t* shrink-wrap.h (try_shrink_wrapping): Likewise for param\n\t\"prologue_seq\".\n\t(convert_to_simple_return): Likewise for param \"returnjump\".\n\t* valtrack.c (propagate_for_debug): Likewise for params\n\t\"insn\", \"last\".\n\t* valtrack.h (propagate_for_debug): Likewise for second param.\n\nFrom-SVN: r214693", "tree": {"sha": "e248d452a91447eef690b32a97167db7834457e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e248d452a91447eef690b32a97167db7834457e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc01c3d194afdf0ef85c46a97459badf1b149225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc01c3d194afdf0ef85c46a97459badf1b149225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc01c3d194afdf0ef85c46a97459badf1b149225", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc01c3d194afdf0ef85c46a97459badf1b149225/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ba24b7b5fc19c54d86000260cf697c1dd9ab303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba24b7b5fc19c54d86000260cf697c1dd9ab303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba24b7b5fc19c54d86000260cf697c1dd9ab303"}], "stats": {"total": 739, "additions": 490, "deletions": 249}, "files": [{"sha": "e486eb4130756f1a3c8d84f1045713665c58f604", "filename": "gcc/ChangeLog", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -1,3 +1,189 @@\n+2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cfgexpand.c (pass_expand::execute): Strengthen local \"after\"\n+\tfrom rtx to rtx_insn *.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Replace use of local\n+\trtx \"note\" with new local rtx_insn * \"new_head\" when calculating\n+\thead insn of new basic block.\n+\t* combine.c (combine_split_insns): Strengthen return type and local\n+\t\"ret\" from rtx to rtx_insn *.\n+\t(likely_spilled_retval_p): Likewise for locals \"use\" and \"p\".\n+\t(try_combine): Eliminate local \"m_split\", splitting into new\n+\tlocals \"m_split_insn\" and \"m_split_pat\".\n+\t(find_split_point): Strengthen local \"seq\" from rtx into\n+\trtx_insn *.\n+\t* config/spu/spu.c (spu_machine_dependent_reorg): Likewise for\n+\tlocals \"label\", \"branch\".\n+\t* config/spu/spu.md (define_expand \"smulsi3_highpart\"): Likewise\n+\tfor local \"insn\".\n+\t(define_expand \"umulsi3_highpart\"): Likewise for local \"insn\".\n+\t* dse.c (note_add_store_info): Likewise for fields \"first\",\n+\t\"current\".\n+\t(note_add_store): Likewise for local \"insn\".\n+\t(emit_inc_dec_insn_before): Likewise for locals \"insn\",\n+\t\"new_insn\", \"cur\".\n+\t(find_shift_sequence): Likewise for locals \"shift_seq\", \"insn\".\n+\t(replace_read): Likewise for locals \"insns\", \"this_insn\".\n+\t* dwarf2cfi.c (dw_trace_info): Likewise for field \"eh_head\".\n+\t(notice_eh_throw): Likewise for param \"insn\".\n+\t(before_next_cfi_note): Likewise for return type, param, and local\n+\t\"prev\".\n+\t(connect_traces): Likewise for local \"note\".\n+\t* emit-rtl.c (reset_all_used_flags): Likewise for local \"p\".\n+\t(verify_rtl_sharing): Likewise.\n+\t(unshare_all_rtl_in_chain): Likewise for param \"insn\".\n+\t(get_first_nonnote_insn): Likewise for local \"insn\".\n+\t(get_last_nonnote_insn): Likewise.  Introduce local rtx_sequence *\n+\t\"seq\" and use its methods to clarify things.\n+\t(next_insn): Strengthen return type from rtx to rtx_insn *.\n+\tRename param \"insn\" to \"uncast_insn\" and reintroduce \"insn\" as a\n+\tlocal rtx_insn * using a checked cast, dropping a checked cast\n+\tmade redundant by this change.  Use a cast to and method of\n+\trtx_sequence to clarify the code.\n+\t(previous_insn): Rename param \"insn\" to \"uncast_insn\" and\n+\treintroduce \"insn\" as a local rtx_insn * using a checked cast,\n+\tdropping a checked cast made redundant by this change.  Use a cast\n+\tto and method of rtx_sequence to clarify the code.\n+\t(next_nonnote_insn): Rename param \"insn\" to \"uncast_insn\" and\n+\treintroduce \"insn\" as a local rtx_insn * using a checked cast,\n+\tdropping a checked cast made redundant by this change.\n+\t(next_nonnote_insn_bb): Likewise.\n+\t(prev_nonnote_insn): Likewise.\n+\t(prev_nonnote_insn_bb): Likewise.\n+\t(next_nondebug_insn): Likewise.\n+\t(prev_nondebug_insn): Likewise.\n+\t(next_nonnote_nondebug_insn): Likewise.\n+\t(prev_nonnote_nondebug_insn): Likewise.\n+\t(next_real_insn): Likewise.\n+\t(prev_real_insn): Likewise.\n+\t(next_active_insn): Likewise.\n+\t(prev_active_insn): Likewise.\n+\t(next_cc0_user): Likewise.  Use rtx_sequence and a method for\n+\tclarity.\n+\t(prev_cc0_setter): Likewise.\n+\t(try_split): Rename param \"trial\" to \"uncast_trial\" and\n+\treintroduce \"insn\" as a local rtx_insn * using a checked cast,\n+\tdropping checked casts made redundant by this change.\n+\tStrengthen locals \"seq\", \"tem\", \"insn_last\", \"insn\", \"next\" from\n+\trtx to rtx_insn *.\n+\t(remove_insn): Rename param \"insn\" to \"uncast_insn\" and\n+\treintroduce \"insn\" as a local rtx_insn * using a checked cast.\n+\t(emit_pattern_after_setloc): Likewise for param \"after\", as\n+\t\"uncast_after\".\n+\t(emit_pattern_after): Likewise.  Strengthen local \"prev\" from\n+\trtx to rtx_insn *.\n+\t(emit_pattern_before_setloc): Rename param \"before\" to\n+\t\"uncast_before\" and reintroduce \"before\" as a local rtx_insn *\n+\tusing a checked cast.  Strengthen locals \"first\", \"last\" from\n+\trtx to rtx_insn *.\n+\t(emit_pattern_before): Likewise rename/cast param \"before\" to\n+\t\"uncast_before\". Strengthen local \"next\" from rtx to rtx_insn *.\n+\t* except.c (copy_reg_eh_region_note_forward): Strengthen param\n+\t\"first\" and local \"insn\" from rtx to rtx_insn *.\n+\t(copy_reg_eh_region_note_backward): Likewise for param \"last\"\n+\tand local \"insn\".\n+\t* expr.c (fixup_args_size_notes): Rename param \"last\" to\n+\t\"uncast_last\" and reintroduce \"last\" as a local rtx_insn *\n+\tusing a checked cast.  Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t* function.c (set_insn_locations): Strengthen param \"insn\" from\n+\trtx to rtx_insn *.\n+\t(record_insns): Likewise for param \"insns\" and local \"tmp\".\n+\t(active_insn_between): Rename param \"tail\" to\n+\t\"uncast_tail\" and reintroduce \"tail\" as a local rtx_insn *\n+\tusing a checked cast.\n+\t(thread_prologue_and_epilogue_insns): Split out top-level local\n+\trtx \"seq\" into three different rtx_insn * locals.  Strengthen\n+\tlocal \"prologue_seq\" from rtx to rtx_insn *.\n+\t* gcse.c (insert_insn_end_basic_block): Strenghen local \"insn\"\n+\tfrom rtx to rtx_insn *.\n+\t* haifa-sched.c (initiate_bb_reg_pressure_info): Likewise.\n+\t(priority): Likewise for locals \"prev_first\", \"twin\".\n+\t(setup_insn_max_reg_pressure): Likewise for param \"after\".\n+\t(sched_setup_bb_reg_pressure_info): Likewise.\n+\t(no_real_insns_p): Strengthen params from const_rtx to\n+\tconst rtx_insn *.\n+\t(schedule_block): Strengthen local \"next_tail\" from rtx to\n+\trtx_insn *.\n+\t* ifcvt.c (find_active_insn_before): Strengthen return type and\n+\tparam \"insn\" from rtx to rtx_insn *.\n+\t(find_active_insn_after): Likewise.\n+\t(cond_exec_process_insns): Likewise for param \"start\" and local \"insn\".\n+\t(cond_exec_process_if_block): Likewise for locals \"then_start\",\n+\t\"then_end\", \"else_start\", \"else_end\", \"insn\", \"start\", \"end\", \"from\".\n+\t(noce_process_if_block): Likewise for local \"jump\".\n+\t(merge_if_block): Likewise for two locals named \"end\".\n+\t(cond_exec_find_if_block): Likewise for local \"last_insn\".\n+\t* jump.c (delete_related_insns): Rename param \"insn\" to\n+\t\"uncast_insn\" and reintroduce \"insn\" as a local rtx_insn * using a\n+\tchecked cast.  Strengthen local \"p\" from rtx to rtx_insn *.\n+\t* lra-constraints.c (inherit_reload_reg): Replace NULL_RTX with\n+\tNULL.\n+\t(split_reg): Likewise.\n+\t* lra.c (lra_process_new_insns): Likewise.\n+\t* modulo-sched.c (permute_partial_schedule): Strengthen param\n+\t\"last\" from rtx to rtx_insn *.\n+\t* optabs.c (add_equal_note): Likewise for param \"insns\" and local\n+\t\"last_insn\".\n+\t(expand_binop_directly): Add checked casts to rtx_insn * within\n+\tNEXT_INSN (pat) uses.\n+\t(expand_unop_direct): Likewise.\n+\t(maybe_emit_unop_insn): Likewise.\n+\t* recog.c (peep2_attempt): Strengthen locals \"last\",\n+\t\"before_try\", \"x\" from rtx to rtx_insn *.\n+\t* reorg.c (optimize_skip): Strengthen return type and local\n+\t\"delay_list\" from rtx to rtx_insn_list *.  Strengthen param \"insn\"\n+\tand locals \"trial\", \"next_trial\" from rtx to rtx_insn *.\n+\t* resource.c (next_insn_no_annul): Strengthen return type and\n+\tparam \"insn\" from rtx to rtx_insn *.  Use a cast to and method of\n+\trtx_sequence to clarify the code.\n+\t(mark_referenced_resources): Add a checked cast to rtx_insn *\n+\twithin PREV_INSN (x).\n+\t(find_dead_or_set_registers): Strengthen return type, param\n+\t\"target\", locals \"insn\", \"next\", \"jump_insn\", \"this_jump_insn\"\n+\tfrom rtx to rtx_insn *.  Strengthen param \"jump_target\" from rtx *\n+\tto rtx_insn **.\n+\t(mark_target_live_regs): Strengthen params \"insns\" and \"target\",\n+\tlocals \"insn\", \"jump_target\", \"start_insn\", \"stop_insn\" from rtx\n+\tto rtx_insn *.  Use cast to and method of rtx_sequence to clarify\n+\tthe code.\n+\t* resource.h (mark_target_live_regs): Strengthen params 1 and 2\n+\tfrom rtx to rtx_insn *.\n+\t* rtl.h (copy_reg_eh_region_note_forward): Strengthen second param\n+\tfrom rtx to rtx_insn *.\n+\t(copy_reg_eh_region_note_backward): Likewise.\n+\t(unshare_all_rtl_in_chain): Likewise for sole param.\n+\t(dump_rtl_slim): Strengthen second and third params from const_rtx\n+\tto const rtx_insn *.\n+\t* sched-deps.c (sched_free_deps): Strengthen params \"head\" and\n+\t\"tail\" and locals \"insn\", \"next_tail\" from rtx to rtx_insn *.\n+\t* sched-ebb.c (init_ready_list): Strengthen locals \"prev_head\",\n+\t\"next_tail\" from rtx to rtx_insn *.\n+\t(begin_move_insn): Likewise for local \"next\".\n+\t* sched-int.h (sched_free_deps): Likewise for first and second\n+\tparams.\n+\t(no_real_insns_p): Strengthen both params from const_rtx to\n+\tconst rtx_insn *.\n+\t(sched_setup_bb_reg_pressure_info): Strengthen second params from\n+\trtx to rtx_insn *.\n+\t* sched-rgn.c (init_ready_list): Likewise for locals \"prev_head\",\n+\t\"next_tail\".\n+\t* sched-vis.c (dump_rtl_slim): Strengthen params \"first\", \"last\"\n+\tand locals \"insn\", \"tail\" from const_rtx to const rtx_insn *.\n+\t(rtl_dump_bb_for_graph): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(debug_rtl_slim): Strengthen params \"first\" and \"last\" from\n+\tconst_rtx to const rtx_insn *.\n+\t* shrink-wrap.c (try_shrink_wrapping): Strengthen param\n+\t\"prologue_seq\" and locals \"seq\", \"p_insn\" from rtx to rtx_insn *.\n+\t(convert_to_simple_return): Likewise for param \"returnjump\".\n+\t* shrink-wrap.h (try_shrink_wrapping): Likewise for param\n+\t\"prologue_seq\".\n+\t(convert_to_simple_return): Likewise for param \"returnjump\".\n+\t* valtrack.c (propagate_for_debug): Likewise for params\n+\t\"insn\", \"last\".\n+\t* valtrack.h (propagate_for_debug): Likewise for second param.\n+\n 2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n \n \t* output.h (insn_current_reference_address): Strengthen param"}, {"sha": "0a1b4bf64c227fddbbd9addfe34d5688097b62ed", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -5847,7 +5847,7 @@ pass_expand::execute (function *fun)\n \n   if (var_ret_seq)\n     {\n-      rtx after = return_label;\n+      rtx_insn *after = return_label;\n       rtx_insn *next = NEXT_INSN (after);\n       if (next && NOTE_INSN_BASIC_BLOCK_P (next))\n \tafter = next;"}, {"sha": "bc6c9651ee2467024481f0225d89f401255988b5", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -1603,6 +1603,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \n   if (EDGE_COUNT (e->src->succs) >= 2 || abnormal_edge_flags || asm_goto_edge)\n     {\n+      rtx_insn *new_head;\n       gcov_type count = e->count;\n       int probability = e->probability;\n       /* Create the new structures.  */\n@@ -1612,12 +1613,12 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t forward from the last instruction of the old block.  */\n       rtx_jump_table_data *table;\n       if (tablejump_p (BB_END (e->src), NULL, &table))\n-\tnote = table;\n+\tnew_head = table;\n       else\n-\tnote = BB_END (e->src);\n-      note = NEXT_INSN (note);\n+\tnew_head = BB_END (e->src);\n+      new_head = NEXT_INSN (new_head);\n \n-      jump_block = create_basic_block (note, NULL, e->src);\n+      jump_block = create_basic_block (new_head, NULL, e->src);\n       jump_block->count = count;\n       jump_block->frequency = EDGE_FREQUENCY (e);\n "}, {"sha": "60524b5f2010c6a07942ef73ec22919c27e11678", "filename": "gcc/combine.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -514,13 +514,13 @@ target_canonicalize_comparison (enum rtx_code *code, rtx *op0, rtx *op1,\n    reg_stat vector is made larger if the splitter creates a new\n    register.  */\n \n-static rtx\n+static rtx_insn *\n combine_split_insns (rtx pattern, rtx insn)\n {\n-  rtx ret;\n+  rtx_insn *ret;\n   unsigned int nregs;\n \n-  ret = split_insns (pattern, insn);\n+  ret = safe_as_a <rtx_insn *> (split_insns (pattern, insn));\n   nregs = max_reg_num ();\n   if (nregs > reg_stat.length ())\n     reg_stat.safe_grow_cleared (nregs);\n@@ -2294,8 +2294,9 @@ likely_spilled_retval_1 (rtx x, const_rtx set, void *data)\n static int\n likely_spilled_retval_p (rtx_insn *insn)\n {\n-  rtx use = BB_END (this_basic_block);\n-  rtx reg, p;\n+  rtx_insn *use = BB_END (this_basic_block);\n+  rtx reg;\n+  rtx_insn *p;\n   unsigned regno, nregs;\n   /* We assume here that no machine mode needs more than\n      32 hard registers when the value overlaps with a register\n@@ -3333,13 +3334,14 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n   if (i1 && insn_code_number < 0 && GET_CODE (newpat) == SET\n       && asm_noperands (newpat) < 0)\n     {\n-      rtx parallel, m_split, *split;\n+      rtx parallel, *split;\n+      rtx_insn *m_split_insn;\n \n       /* See if the MD file can split NEWPAT.  If it can't, see if letting it\n \t use I2DEST as a scratch register will help.  In the latter case,\n \t convert I2DEST to the mode of the source of NEWPAT if we can.  */\n \n-      m_split = combine_split_insns (newpat, i3);\n+      m_split_insn = combine_split_insns (newpat, i3);\n \n       /* We can only use I2DEST as a scratch reg if it doesn't overlap any\n \t inputs of NEWPAT.  */\n@@ -3348,7 +3350,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t possible to try that as a scratch reg.  This would require adding\n \t more code to make it work though.  */\n \n-      if (m_split == 0 && ! reg_overlap_mentioned_p (i2dest, newpat))\n+      if (m_split_insn == 0 && ! reg_overlap_mentioned_p (i2dest, newpat))\n \t{\n \t  enum machine_mode new_mode = GET_MODE (SET_DEST (newpat));\n \n@@ -3358,11 +3360,11 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t\t\t\t       gen_rtvec (2, newpat,\n \t\t\t\t\t\t  gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t\t\t\t   i2dest)));\n-\t  m_split = combine_split_insns (parallel, i3);\n+\t  m_split_insn = combine_split_insns (parallel, i3);\n \n \t  /* If that didn't work, try changing the mode of I2DEST if\n \t     we can.  */\n-\t  if (m_split == 0\n+\t  if (m_split_insn == 0\n \t      && new_mode != GET_MODE (i2dest)\n \t      && new_mode != VOIDmode\n \t      && can_change_dest_mode (i2dest, added_sets_2, new_mode))\n@@ -3383,9 +3385,9 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t\t\t   gen_rtvec (2, newpat,\n \t\t\t\t      gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t\t       ni2dest))));\n-\t      m_split = combine_split_insns (parallel, i3);\n+\t      m_split_insn = combine_split_insns (parallel, i3);\n \n-\t      if (m_split == 0\n+\t      if (m_split_insn == 0\n \t\t  && REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  struct undo *buf;\n@@ -3398,34 +3400,34 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t\t}\n \t    }\n \n-\t  i2scratch = m_split != 0;\n+\t  i2scratch = m_split_insn != 0;\n \t}\n \n       /* If recog_for_combine has discarded clobbers, try to use them\n \t again for the split.  */\n-      if (m_split == 0 && newpat_vec_with_clobbers)\n+      if (m_split_insn == 0 && newpat_vec_with_clobbers)\n \t{\n \t  parallel = gen_rtx_PARALLEL (VOIDmode, newpat_vec_with_clobbers);\n-\t  m_split = combine_split_insns (parallel, i3);\n+\t  m_split_insn = combine_split_insns (parallel, i3);\n \t}\n \n-      if (m_split && NEXT_INSN (m_split) == NULL_RTX)\n+      if (m_split_insn && NEXT_INSN (m_split_insn) == NULL_RTX)\n \t{\n-\t  m_split = PATTERN (m_split);\n-\t  insn_code_number = recog_for_combine (&m_split, i3, &new_i3_notes);\n+\t  rtx m_split_pat = PATTERN (m_split_insn);\n+\t  insn_code_number = recog_for_combine (&m_split_pat, i3, &new_i3_notes);\n \t  if (insn_code_number >= 0)\n-\t    newpat = m_split;\n+\t    newpat = m_split_pat;\n \t}\n-      else if (m_split && NEXT_INSN (NEXT_INSN (m_split)) == NULL_RTX\n+      else if (m_split_insn && NEXT_INSN (NEXT_INSN (m_split_insn)) == NULL_RTX\n \t       && (next_nonnote_nondebug_insn (i2) == i3\n-\t\t   || ! use_crosses_set_p (PATTERN (m_split), DF_INSN_LUID (i2))))\n+\t\t   || ! use_crosses_set_p (PATTERN (m_split_insn), DF_INSN_LUID (i2))))\n \t{\n \t  rtx i2set, i3set;\n-\t  rtx newi3pat = PATTERN (NEXT_INSN (m_split));\n-\t  newi2pat = PATTERN (m_split);\n+\t  rtx newi3pat = PATTERN (NEXT_INSN (m_split_insn));\n+\t  newi2pat = PATTERN (m_split_insn);\n \n-\t  i3set = single_set (NEXT_INSN (m_split));\n-\t  i2set = single_set (m_split);\n+\t  i3set = single_set (NEXT_INSN (m_split_insn));\n+\t  i2set = single_set (m_split_insn);\n \n \t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n@@ -4534,9 +4536,9 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t\t\t\t\t    MEM_ADDR_SPACE (x)))\n \t{\n \t  rtx reg = regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n-\t  rtx seq = combine_split_insns (gen_rtx_SET (VOIDmode, reg,\n-\t\t\t\t\t\t      XEXP (x, 0)),\n-\t\t\t\t\t subst_insn);\n+\t  rtx_insn *seq = combine_split_insns (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t\t\t\t\t    XEXP (x, 0)),\n+\t\t\t\t\t       subst_insn);\n \n \t  /* This should have produced two insns, each of which sets our\n \t     placeholder.  If the source of the second is a valid address,"}, {"sha": "028b61f65e2063723dd085936f89b356aeed5908", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -2664,8 +2664,8 @@ spu_machine_dependent_reorg (void)\n \t   label because GCC expects it at the beginning of the block. */\n \trtx unspec = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n \trtx label_ref = XVECEXP (unspec, 0, 0);\n-\trtx label = XEXP (label_ref, 0);\n-\trtx branch;\n+\trtx_insn *label = as_a <rtx_insn *> (XEXP (label_ref, 0));\n+\trtx_insn *branch;\n \tint offset = 0;\n \tfor (branch = NEXT_INSN (label);\n \t     !JUMP_P (branch) && !CALL_P (branch);"}, {"sha": "e9554785011708da405a8331dca76fcdf435ba35", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -1733,7 +1733,7 @@\n     rtx t0_hi = gen_rtx_SUBREG (HImode, t0, 2);\n     rtx t1_hi = gen_rtx_SUBREG (HImode, t1, 2);\n \n-    rtx insn = emit_insn (gen_lshrsi3 (t0, operands[1], GEN_INT (16)));\n+    rtx_insn *insn = emit_insn (gen_lshrsi3 (t0, operands[1], GEN_INT (16)));\n     emit_insn (gen_lshrsi3 (t1, operands[2], GEN_INT (16)));\n     emit_insn (gen_umulhisi3 (t2, op1_hi, op2_hi));\n     emit_insn (gen_mpyh_si (t3, operands[1], operands[2]));\n@@ -1794,7 +1794,7 @@\n     rtx op2_hi = gen_rtx_SUBREG (HImode, operands[2], 2);\n     rtx t0_hi = gen_rtx_SUBREG (HImode, t0, 2);\n \n-    rtx insn = emit_insn (gen_rotlsi3 (t0, operands[2], GEN_INT (16)));\n+    rtx_insn *insn = emit_insn (gen_rotlsi3 (t0, operands[2], GEN_INT (16)));\n     emit_insn (gen_umulhisi3 (t1, op1_hi, op2_hi));\n     emit_insn (gen_umulhisi3 (t2, op1_hi, t0_hi));\n     emit_insn (gen_mpyhhu_si (t3, operands[1], t0));"}, {"sha": "2dcbd9cf9f3943801d5ce9790f4bb6e5bb60c03d", "filename": "gcc/dse.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -812,7 +812,7 @@ free_store_info (insn_info_t insn_info)\n \n typedef struct\n {\n-  rtx first, current;\n+  rtx_insn *first, *current;\n   regset fixed_regs_live;\n   bool failure;\n } note_add_store_info;\n@@ -823,7 +823,7 @@ typedef struct\n static void\n note_add_store (rtx loc, const_rtx expr ATTRIBUTE_UNUSED, void *data)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   note_add_store_info *info = (note_add_store_info *) data;\n   int r, n;\n \n@@ -864,7 +864,7 @@ emit_inc_dec_insn_before (rtx mem ATTRIBUTE_UNUSED,\n \t\t\t  rtx dest, rtx src, rtx srcoff, void *arg)\n {\n   insn_info_t insn_info = (insn_info_t) arg;\n-  rtx insn = insn_info->insn, new_insn, cur;\n+  rtx_insn *insn = insn_info->insn, *new_insn, *cur;\n   note_add_store_info info;\n \n   /* We can reuse all operands without copying, because we are about\n@@ -877,7 +877,7 @@ emit_inc_dec_insn_before (rtx mem ATTRIBUTE_UNUSED,\n       end_sequence ();\n     }\n   else\n-    new_insn = gen_move_insn (dest, src);\n+    new_insn = as_a <rtx_insn *> (gen_move_insn (dest, src));\n   info.first = new_insn;\n   info.fixed_regs_live = insn_info->fixed_regs_live;\n   info.failure = false;\n@@ -1742,7 +1742,8 @@ find_shift_sequence (int access_size,\n        GET_MODE_BITSIZE (new_mode) <= BITS_PER_WORD;\n        new_mode = GET_MODE_WIDER_MODE (new_mode))\n     {\n-      rtx target, new_reg, shift_seq, insn, new_lhs;\n+      rtx target, new_reg, new_lhs;\n+      rtx_insn *shift_seq, *insn;\n       int cost;\n \n       /* If a constant was stored into memory, try to simplify it here,\n@@ -1962,7 +1963,8 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n {\n   enum machine_mode store_mode = GET_MODE (store_info->mem);\n   enum machine_mode read_mode = GET_MODE (read_info->mem);\n-  rtx insns, this_insn, read_reg;\n+  rtx_insn *insns, *this_insn;\n+  rtx read_reg;\n   basic_block bb;\n \n   if (!dbg_cnt (dse))"}, {"sha": "f30274e1471b0b4e3044a609f5e15852c95a30ae", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -113,7 +113,7 @@ typedef struct\n   HOST_WIDE_INT beg_delay_args_size, end_delay_args_size;\n \n   /* The first EH insn in the trace, where beg_delay_args_size must be set.  */\n-  rtx eh_head;\n+  rtx_insn *eh_head;\n \n   /* The following variables contain data used in interpreting frame related\n      expressions.  These are not part of the \"real\" row state as defined by\n@@ -876,7 +876,7 @@ notice_args_size (rtx insn)\n    data within the trace related to EH insns and args_size.  */\n \n static void\n-notice_eh_throw (rtx insn)\n+notice_eh_throw (rtx_insn *insn)\n {\n   HOST_WIDE_INT args_size;\n \n@@ -2577,10 +2577,10 @@ create_cfi_notes (void)\n \n /* Return the insn before the first NOTE_INSN_CFI after START.  */\n \n-static rtx\n-before_next_cfi_note (rtx start)\n+static rtx_insn *\n+before_next_cfi_note (rtx_insn *start)\n {\n-  rtx prev = start;\n+  rtx_insn *prev = start;\n   while (start)\n     {\n       if (NOTE_P (start) && NOTE_KIND (start) == NOTE_INSN_CFI)\n@@ -2675,7 +2675,7 @@ connect_traces (void)\n \n       if (dump_file && add_cfi_insn != ti->head)\n \t{\n-\t  rtx note;\n+\t  rtx_insn *note;\n \n \t  fprintf (dump_file, \"Fixup between trace %u and %u:\\n\",\n \t\t   prev_ti->id, ti->id);"}, {"sha": "330c5215a2e0362efd2b0453b0afc88855642316", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 104, "deletions": 68, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -2747,7 +2747,7 @@ reset_insn_used_flags (rtx insn)\n static void\n reset_all_used_flags (void)\n {\n-  rtx p;\n+  rtx_insn *p;\n \n   for (p = get_insns (); p; p = NEXT_INSN (p))\n     if (INSN_P (p))\n@@ -2786,7 +2786,7 @@ verify_insn_sharing (rtx insn)\n DEBUG_FUNCTION void\n verify_rtl_sharing (void)\n {\n-  rtx p;\n+  rtx_insn *p;\n \n   timevar_push (TV_VERIFY_RTL_SHARING);\n \n@@ -2816,7 +2816,7 @@ verify_rtl_sharing (void)\n    Assumes the mark bits are cleared at entry.  */\n \n void\n-unshare_all_rtl_in_chain (rtx insn)\n+unshare_all_rtl_in_chain (rtx_insn *insn)\n {\n   for (; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n@@ -3144,7 +3144,7 @@ get_last_insn_anywhere (void)\n rtx\n get_first_nonnote_insn (void)\n {\n-  rtx insn = get_insns ();\n+  rtx_insn *insn = get_insns ();\n \n   if (insn)\n     {\n@@ -3157,7 +3157,7 @@ get_first_nonnote_insn (void)\n \t{\n \t  if (NONJUMP_INSN_P (insn)\n \t      && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\t    insn = XVECEXP (PATTERN (insn), 0, 0);\n+\t    insn = as_a <rtx_sequence *> (PATTERN (insn))->insn (0);\n \t}\n     }\n \n@@ -3170,7 +3170,7 @@ get_first_nonnote_insn (void)\n rtx\n get_last_nonnote_insn (void)\n {\n-  rtx insn = get_last_insn ();\n+  rtx_insn *insn = get_last_insn ();\n \n   if (insn)\n     {\n@@ -3181,10 +3181,9 @@ get_last_nonnote_insn (void)\n \t  continue;\n       else\n \t{\n-\t  if (NONJUMP_INSN_P (insn)\n-\t      && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\t    insn = XVECEXP (PATTERN (insn), 0,\n-\t\t\t    XVECLEN (PATTERN (insn), 0) - 1);\n+\t  if (NONJUMP_INSN_P (insn))\n+\t    if (rtx_sequence *seq = dyn_cast <rtx_sequence *> (PATTERN (insn)))\n+\t      insn = seq->insn (seq->len () - 1);\n \t}\n     }\n \n@@ -3216,59 +3215,64 @@ get_max_insn_count (void)\n    of the sequence.  */\n \n rtx_insn *\n-next_insn (rtx insn)\n+next_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n   if (insn)\n     {\n       insn = NEXT_INSN (insn);\n       if (insn && NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, 0);\n+\tinsn = as_a <rtx_sequence *> (PATTERN (insn))->insn (0);\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the previous insn.  If it is a SEQUENCE, return the last insn\n    of the sequence.  */\n \n rtx_insn *\n-previous_insn (rtx insn)\n+previous_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n   if (insn)\n     {\n       insn = PREV_INSN (insn);\n-      if (insn && NONJUMP_INSN_P (insn)\n-\t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, XVECLEN (PATTERN (insn), 0) - 1);\n+      if (insn && NONJUMP_INSN_P (insn))\n+\tif (rtx_sequence *seq = dyn_cast <rtx_sequence *> (PATTERN (insn)))\n+\t  insn = seq->insn (seq->len () - 1);\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the next insn after INSN that is not a NOTE.  This routine does not\n    look inside SEQUENCEs.  */\n \n rtx_insn *\n-next_nonnote_insn (rtx insn)\n+next_nonnote_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n       if (insn == 0 || !NOTE_P (insn))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the next insn after INSN that is not a NOTE, but stop the\n    search before we enter another basic block.  This routine does not\n    look inside SEQUENCEs.  */\n \n rtx_insn *\n-next_nonnote_insn_bb (rtx insn)\n+next_nonnote_insn_bb (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n@@ -3278,32 +3282,36 @@ next_nonnote_insn_bb (rtx insn)\n \treturn NULL;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the previous insn before INSN that is not a NOTE.  This routine does\n    not look inside SEQUENCEs.  */\n \n rtx_insn *\n-prev_nonnote_insn (rtx insn)\n+prev_nonnote_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n       if (insn == 0 || !NOTE_P (insn))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the previous insn before INSN that is not a NOTE, but stop\n    the search before we enter another basic block.  This routine does\n    not look inside SEQUENCEs.  */\n \n rtx_insn *\n-prev_nonnote_insn_bb (rtx insn)\n+prev_nonnote_insn_bb (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n@@ -3313,105 +3321,117 @@ prev_nonnote_insn_bb (rtx insn)\n \treturn NULL;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the next insn after INSN that is not a DEBUG_INSN.  This\n    routine does not look inside SEQUENCEs.  */\n \n rtx_insn *\n-next_nondebug_insn (rtx insn)\n+next_nondebug_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n       if (insn == 0 || !DEBUG_INSN_P (insn))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the previous insn before INSN that is not a DEBUG_INSN.\n    This routine does not look inside SEQUENCEs.  */\n \n rtx_insn *\n-prev_nondebug_insn (rtx insn)\n+prev_nondebug_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n       if (insn == 0 || !DEBUG_INSN_P (insn))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the next insn after INSN that is not a NOTE nor DEBUG_INSN.\n    This routine does not look inside SEQUENCEs.  */\n \n rtx_insn *\n-next_nonnote_nondebug_insn (rtx insn)\n+next_nonnote_nondebug_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n       if (insn == 0 || (!NOTE_P (insn) && !DEBUG_INSN_P (insn)))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the previous insn before INSN that is not a NOTE nor DEBUG_INSN.\n    This routine does not look inside SEQUENCEs.  */\n \n rtx_insn *\n-prev_nonnote_nondebug_insn (rtx insn)\n+prev_nonnote_nondebug_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n       if (insn == 0 || (!NOTE_P (insn) && !DEBUG_INSN_P (insn)))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;\n    or 0, if there is none.  This routine does not look inside\n    SEQUENCEs.  */\n \n rtx_insn *\n-next_real_insn (rtx insn)\n+next_real_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n       if (insn == 0 || INSN_P (insn))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the last INSN, CALL_INSN or JUMP_INSN before INSN;\n    or 0, if there is none.  This routine does not look inside\n    SEQUENCEs.  */\n \n rtx_insn *\n-prev_real_insn (rtx insn)\n+prev_real_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n       if (insn == 0 || INSN_P (insn))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Return the last CALL_INSN in the current list, or 0 if there is none.\n@@ -3446,33 +3466,37 @@ active_insn_p (const_rtx insn)\n }\n \n rtx_insn *\n-next_active_insn (rtx insn)\n+next_active_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n       if (insn == 0 || active_insn_p (insn))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \n /* Find the last insn before INSN that really does something.  This routine\n    does not look inside SEQUENCEs.  After reload this also skips over\n    standalone USE and CLOBBER insn.  */\n \n rtx_insn *\n-prev_active_insn (rtx insn)\n+prev_active_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n       if (insn == 0 || active_insn_p (insn))\n \tbreak;\n     }\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n \f\n #ifdef HAVE_cc0\n@@ -3486,19 +3510,21 @@ prev_active_insn (rtx insn)\n    Return 0 if we can't find the insn.  */\n \n rtx_insn *\n-next_cc0_user (rtx insn)\n+next_cc0_user (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   rtx note = find_reg_note (insn, REG_CC_USER, NULL_RTX);\n \n   if (note)\n     return safe_as_a <rtx_insn *> (XEXP (note, 0));\n \n   insn = next_nonnote_insn (insn);\n   if (insn && NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-    insn = XVECEXP (PATTERN (insn), 0, 0);\n+    insn = as_a <rtx_sequence *> (PATTERN (insn))->insn (0);\n \n   if (insn && INSN_P (insn) && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n-    return safe_as_a <rtx_insn *> (insn);\n+    return insn;\n \n   return 0;\n }\n@@ -3507,8 +3533,10 @@ next_cc0_user (rtx insn)\n    note, it is the previous insn.  */\n \n rtx_insn *\n-prev_cc0_setter (rtx insn)\n+prev_cc0_setter (rtx uncast_insn)\n {\n+  rtx_insn *insn = safe_as_a <rtx_insn *> (uncast_insn);\n+\n   rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n \n   if (note)\n@@ -3517,7 +3545,7 @@ prev_cc0_setter (rtx insn)\n   insn = prev_nonnote_insn (insn);\n   gcc_assert (sets_cc0_p (PATTERN (insn)));\n \n-  return safe_as_a <rtx_insn *> (insn);\n+  return insn;\n }\n #endif\n \n@@ -3574,27 +3602,29 @@ mark_label_nuses (rtx x)\n    returns TRIAL.  If the insn to be returned can be split, it will be.  */\n \n rtx_insn *\n-try_split (rtx pat, rtx trial, int last)\n+try_split (rtx pat, rtx uncast_trial, int last)\n {\n+  rtx_insn *trial = as_a <rtx_insn *> (uncast_trial);\n   rtx_insn *before = PREV_INSN (trial);\n   rtx_insn *after = NEXT_INSN (trial);\n   int has_barrier = 0;\n-  rtx note, seq, tem;\n+  rtx note;\n+  rtx_insn *seq, *tem;\n   int probability;\n-  rtx insn_last, insn;\n+  rtx_insn *insn_last, *insn;\n   int njumps = 0;\n   rtx call_insn = NULL_RTX;\n \n   /* We're not good at redistributing frame information.  */\n   if (RTX_FRAME_RELATED_P (trial))\n-    return as_a <rtx_insn *> (trial);\n+    return trial;\n \n   if (any_condjump_p (trial)\n       && (note = find_reg_note (trial, REG_BR_PROB, 0)))\n     split_branch_probability = XINT (note, 0);\n   probability = split_branch_probability;\n \n-  seq = split_insns (pat, trial);\n+  seq = safe_as_a <rtx_insn *> (split_insns (pat, trial));\n \n   split_branch_probability = -1;\n \n@@ -3607,7 +3637,7 @@ try_split (rtx pat, rtx trial, int last)\n     }\n \n   if (!seq)\n-    return as_a <rtx_insn *> (trial);\n+    return trial;\n \n   /* Avoid infinite loop if any insn of the result matches\n      the original pattern.  */\n@@ -3616,7 +3646,7 @@ try_split (rtx pat, rtx trial, int last)\n     {\n       if (INSN_P (insn_last)\n \t  && rtx_equal_p (PATTERN (insn_last), pat))\n-\treturn as_a <rtx_insn *> (trial);\n+\treturn trial;\n       if (!NEXT_INSN (insn_last))\n \tbreak;\n       insn_last = NEXT_INSN (insn_last);\n@@ -3656,7 +3686,8 @@ try_split (rtx pat, rtx trial, int last)\n       for (insn = insn_last; insn ; insn = PREV_INSN (insn))\n \tif (CALL_P (insn))\n \t  {\n-\t    rtx next, *p;\n+\t    rtx_insn *next;\n+\t    rtx *p;\n \n \t    gcc_assert (call_insn == NULL_RTX);\n \t    call_insn = insn;\n@@ -4090,8 +4121,9 @@ set_insn_deleted (rtx insn)\n    To really delete an insn and related DF information, use delete_insn.  */\n \n void\n-remove_insn (rtx insn)\n+remove_insn (rtx uncast_insn)\n {\n+  rtx_insn *insn = as_a <rtx_insn *> (uncast_insn);\n   rtx_insn *next = NEXT_INSN (insn);\n   rtx_insn *prev = PREV_INSN (insn);\n   basic_block bb;\n@@ -4627,9 +4659,10 @@ emit_note_before (enum insn_note subtype, rtx uncast_before)\n    MAKE_RAW indicates how to turn PATTERN into a real insn.  */\n \n static rtx_insn *\n-emit_pattern_after_setloc (rtx pattern, rtx after, int loc,\n+emit_pattern_after_setloc (rtx pattern, rtx uncast_after, int loc,\n \t\t\t   rtx_insn *(*make_raw) (rtx))\n {\n+  rtx_insn *after = safe_as_a <rtx_insn *> (uncast_after);\n   rtx last = emit_pattern_after_noloc (pattern, after, NULL, make_raw);\n \n   if (pattern == NULL_RTX || !loc)\n@@ -4652,10 +4685,11 @@ emit_pattern_after_setloc (rtx pattern, rtx after, int loc,\n    any DEBUG_INSNs.  */\n \n static rtx_insn *\n-emit_pattern_after (rtx pattern, rtx after, bool skip_debug_insns,\n+emit_pattern_after (rtx pattern, rtx uncast_after, bool skip_debug_insns,\n \t\t    rtx_insn *(*make_raw) (rtx))\n {\n-  rtx prev = after;\n+  rtx_insn *after = safe_as_a <rtx_insn *> (uncast_after);\n+  rtx_insn *prev = after;\n \n   if (skip_debug_insns)\n     while (DEBUG_INSN_P (prev))\n@@ -4730,16 +4764,17 @@ emit_debug_insn_after (rtx pattern, rtx after)\n    CALL_INSN, etc.  */\n \n static rtx_insn *\n-emit_pattern_before_setloc (rtx pattern, rtx before, int loc, bool insnp,\n+emit_pattern_before_setloc (rtx pattern, rtx uncast_before, int loc, bool insnp,\n \t\t\t    rtx_insn *(*make_raw) (rtx))\n {\n-  rtx first = PREV_INSN (before);\n-  rtx last = emit_pattern_before_noloc (pattern, before,\n-                                        insnp ? before : NULL_RTX,\n-                                        NULL, make_raw);\n+  rtx_insn *before = as_a <rtx_insn *> (uncast_before);\n+  rtx_insn *first = PREV_INSN (before);\n+  rtx_insn *last = emit_pattern_before_noloc (pattern, before,\n+\t\t\t\t\t      insnp ? before : NULL_RTX,\n+\t\t\t\t\t      NULL, make_raw);\n \n   if (pattern == NULL_RTX || !loc)\n-    return safe_as_a <rtx_insn *> (last);\n+    return last;\n \n   if (!first)\n     first = get_insns ();\n@@ -4753,7 +4788,7 @@ emit_pattern_before_setloc (rtx pattern, rtx before, int loc, bool insnp,\n \tbreak;\n       first = NEXT_INSN (first);\n     }\n-  return safe_as_a <rtx_insn *> (last);\n+  return last;\n }\n \n /* Insert PATTERN before BEFORE.  MAKE_RAW indicates how to turn PATTERN\n@@ -4762,10 +4797,11 @@ emit_pattern_before_setloc (rtx pattern, rtx before, int loc, bool insnp,\n    INSN as opposed to a JUMP_INSN, CALL_INSN, etc.  */\n \n static rtx_insn *\n-emit_pattern_before (rtx pattern, rtx before, bool skip_debug_insns,\n+emit_pattern_before (rtx pattern, rtx uncast_before, bool skip_debug_insns,\n \t\t     bool insnp, rtx_insn *(*make_raw) (rtx))\n {\n-  rtx next = before;\n+  rtx_insn *before = safe_as_a <rtx_insn *> (uncast_before);\n+  rtx_insn *next = before;\n \n   if (skip_debug_insns)\n     while (DEBUG_INSN_P (next))"}, {"sha": "5cdfb680bbf01878d0fa3914c1c05e9bd520b9c0", "filename": "gcc/except.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -1741,9 +1741,10 @@ insn_could_throw_p (const_rtx insn)\n    to look for a note, or the note itself.  */\n \n void\n-copy_reg_eh_region_note_forward (rtx note_or_insn, rtx first, rtx last)\n+copy_reg_eh_region_note_forward (rtx note_or_insn, rtx_insn *first, rtx last)\n {\n-  rtx insn, note = note_or_insn;\n+  rtx_insn *insn;\n+  rtx note = note_or_insn;\n \n   if (INSN_P (note_or_insn))\n     {\n@@ -1762,9 +1763,10 @@ copy_reg_eh_region_note_forward (rtx note_or_insn, rtx first, rtx last)\n /* Likewise, but iterate backward.  */\n \n void\n-copy_reg_eh_region_note_backward (rtx note_or_insn, rtx last, rtx first)\n+copy_reg_eh_region_note_backward (rtx note_or_insn, rtx_insn *last, rtx first)\n {\n-  rtx insn, note = note_or_insn;\n+  rtx_insn *insn;\n+  rtx note = note_or_insn;\n \n   if (INSN_P (note_or_insn))\n     {"}, {"sha": "49c22c5ec4e0543f6d9879469b1934f2e25e3f9b", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -3933,11 +3933,12 @@ find_args_size_adjust (rtx insn)\n }\n \n int\n-fixup_args_size_notes (rtx prev, rtx last, int end_args_size)\n+fixup_args_size_notes (rtx prev, rtx uncast_last, int end_args_size)\n {\n+  rtx_insn *last = safe_as_a <rtx_insn *> (uncast_last);\n   int args_size = end_args_size;\n   bool saw_unknown = false;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = last; insn != prev; insn = PREV_INSN (insn))\n     {"}, {"sha": "28e0dce4eed735c63713b5884298ba72d49d3d63", "filename": "gcc/function.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -122,7 +122,7 @@ static tree *get_block_vector (tree, int *);\n extern tree debug_find_var_in_block_tree (tree, tree);\n /* We always define `record_insns' even if it's not used so that we\n    can always export `prologue_epilogue_contains'.  */\n-static void record_insns (rtx, rtx, htab_t *) ATTRIBUTE_UNUSED;\n+static void record_insns (rtx_insn *, rtx, htab_t *) ATTRIBUTE_UNUSED;\n static bool contains (const_rtx, htab_t);\n static void prepare_function_start (void);\n static void do_clobber_return_reg (rtx, void *);\n@@ -4982,9 +4982,9 @@ do_warn_unused_parameter (tree fn)\n /* Set the location of the insn chain starting at INSN to LOC.  */\n \n static void\n-set_insn_locations (rtx insn, int loc)\n+set_insn_locations (rtx_insn *insn, int loc)\n {\n-  while (insn != NULL_RTX)\n+  while (insn != NULL)\n     {\n       if (INSN_P (insn))\n \tINSN_LOCATION (insn) = loc;\n@@ -5284,9 +5284,9 @@ get_arg_pointer_save_area (void)\n    for the first time.  */\n \n static void\n-record_insns (rtx insns, rtx end, htab_t *hashp)\n+record_insns (rtx_insn *insns, rtx end, htab_t *hashp)\n {\n-  rtx tmp;\n+  rtx_insn *tmp;\n   htab_t hash = *hashp;\n \n   if (hash == NULL)\n@@ -5424,8 +5424,9 @@ set_return_jump_label (rtx returnjump)\n #if defined (HAVE_return) || defined (HAVE_simple_return)\n /* Return true if there are any active insns between HEAD and TAIL.  */\n bool\n-active_insn_between (rtx head, rtx tail)\n+active_insn_between (rtx head, rtx uncast_tail)\n {\n+  rtx_insn *tail = safe_as_a <rtx_insn *> (uncast_tail);\n   while (tail)\n     {\n       if (active_insn_p (tail))\n@@ -5615,9 +5616,8 @@ thread_prologue_and_epilogue_insns (void)\n   bitmap_head bb_flags;\n #endif\n   rtx_insn *returnjump;\n-  rtx seq ATTRIBUTE_UNUSED;\n   rtx_insn *epilogue_end ATTRIBUTE_UNUSED;\n-  rtx prologue_seq ATTRIBUTE_UNUSED, split_prologue_seq ATTRIBUTE_UNUSED;\n+  rtx_insn *prologue_seq ATTRIBUTE_UNUSED, *split_prologue_seq ATTRIBUTE_UNUSED;\n   edge e, entry_edge, orig_entry_edge, exit_fallthru_edge;\n   edge_iterator ei;\n \n@@ -5626,7 +5626,6 @@ thread_prologue_and_epilogue_insns (void)\n   rtl_profile_for_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   inserted = false;\n-  seq = NULL_RTX;\n   epilogue_end = NULL;\n   returnjump = NULL;\n \n@@ -5637,7 +5636,7 @@ thread_prologue_and_epilogue_insns (void)\n   entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   orig_entry_edge = entry_edge;\n \n-  split_prologue_seq = NULL_RTX;\n+  split_prologue_seq = NULL;\n   if (flag_split_stack\n       && (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl))\n \t  == NULL))\n@@ -5657,12 +5656,12 @@ thread_prologue_and_epilogue_insns (void)\n #endif\n     }\n \n-  prologue_seq = NULL_RTX;\n+  prologue_seq = NULL;\n #ifdef HAVE_prologue\n   if (HAVE_prologue)\n     {\n       start_sequence ();\n-      seq = gen_prologue ();\n+      rtx_insn *seq = safe_as_a <rtx_insn *> (gen_prologue ());\n       emit_insn (seq);\n \n       /* Insert an explicit USE for the frame pointer\n@@ -5799,7 +5798,7 @@ thread_prologue_and_epilogue_insns (void)\n     {\n       start_sequence ();\n       epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n-      seq = gen_epilogue ();\n+      rtx_insn *seq = as_a <rtx_insn *> (gen_epilogue ());\n       if (seq)\n \temit_jump_insn (seq);\n \n@@ -5900,7 +5899,7 @@ thread_prologue_and_epilogue_insns (void)\n \t  start_sequence ();\n \t  emit_note (NOTE_INSN_EPILOGUE_BEG);\n \t  emit_insn (ep_seq);\n-\t  seq = get_insns ();\n+\t  rtx_insn *seq = get_insns ();\n \t  end_sequence ();\n \n \t  /* Retain a map of the epilogue insns.  Used in life analysis to"}, {"sha": "4a8fe50e0da37c5e3a7a138477a78792f86f3b22", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -2161,7 +2161,7 @@ process_insert_insn (struct expr *expr)\n static void\n insert_insn_end_basic_block (struct expr *expr, basic_block bb)\n {\n-  rtx insn = BB_END (bb);\n+  rtx_insn *insn = BB_END (bb);\n   rtx_insn *new_insn;\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n@@ -2188,7 +2188,7 @@ insert_insn_end_basic_block (struct expr *expr, basic_block bb)\n \t if cc0 isn't set.  */\n       rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n       if (note)\n-\tinsn = XEXP (note, 0);\n+\tinsn = safe_as_a <rtx_insn *> (XEXP (note, 0));\n       else\n \t{\n \t  rtx_insn *maybe_cc0_setter = prev_nonnote_insn (insn);"}, {"sha": "1ebfcdb3c8ac03de7aab0b13239273c5ea7a4d2c", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -1037,7 +1037,7 @@ static void\n initiate_bb_reg_pressure_info (basic_block bb)\n {\n   unsigned int i ATTRIBUTE_UNUSED;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (current_nr_blocks > 1)\n     FOR_BB_INSNS (bb, insn)\n@@ -1604,7 +1604,7 @@ priority (rtx_insn *insn)\n \tthis_priority = insn_cost (insn);\n       else\n \t{\n-\t  rtx prev_first, twin;\n+\t  rtx_insn *prev_first, *twin;\n \t  basic_block rec;\n \n \t  /* For recovery check instructions we calculate priority slightly\n@@ -3049,7 +3049,7 @@ update_register_pressure (rtx_insn *insn)\n    meaning in sched-int.h::_haifa_insn_data) for all current BB insns\n    after insn AFTER.  */\n static void\n-setup_insn_max_reg_pressure (rtx after, bool update_p)\n+setup_insn_max_reg_pressure (rtx_insn *after, bool update_p)\n {\n   int i, p;\n   bool eq_p;\n@@ -3112,7 +3112,7 @@ update_reg_and_insn_max_reg_pressure (rtx_insn *insn)\n    insns starting after insn AFTER.  Set up also max register pressure\n    for all insns of the basic block.  */\n void\n-sched_setup_bb_reg_pressure_info (basic_block bb, rtx after)\n+sched_setup_bb_reg_pressure_info (basic_block bb, rtx_insn *after)\n {\n   gcc_assert (sched_pressure == SCHED_PRESSURE_WEIGHTED);\n   initiate_bb_reg_pressure_info (bb);\n@@ -4832,7 +4832,7 @@ get_ebb_head_tail (basic_block beg, basic_block end,\n /* Return nonzero if there are no real insns in the range [ HEAD, TAIL ].  */\n \n int\n-no_real_insns_p (const_rtx head, const_rtx tail)\n+no_real_insns_p (const rtx_insn *head, const rtx_insn *tail)\n {\n   while (head != NEXT_INSN (tail))\n     {\n@@ -5975,7 +5975,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \n   /* Head/tail info for this block.  */\n   rtx_insn *prev_head = current_sched_info->prev_head;\n-  rtx next_tail = current_sched_info->next_tail;\n+  rtx_insn *next_tail = current_sched_info->next_tail;\n   rtx_insn *head = NEXT_INSN (prev_head);\n   rtx_insn *tail = PREV_INSN (next_tail);\n "}, {"sha": "91162041043124c8a12a0a3d0af60a9b3908e82d", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -87,10 +87,11 @@ static int count_bb_insns (const_basic_block);\n static bool cheap_bb_rtx_cost_p (const_basic_block, int, int);\n static rtx_insn *first_active_insn (basic_block);\n static rtx_insn *last_active_insn (basic_block, int);\n-static rtx find_active_insn_before (basic_block, rtx);\n-static rtx find_active_insn_after (basic_block, rtx);\n+static rtx_insn *find_active_insn_before (basic_block, rtx_insn *);\n+static rtx_insn *find_active_insn_after (basic_block, rtx_insn *);\n static basic_block block_fallthru (basic_block);\n-static int cond_exec_process_insns (ce_if_block *, rtx, rtx, rtx, int, int);\n+static int cond_exec_process_insns (ce_if_block *, rtx_insn *, rtx, rtx, int,\n+\t\t\t\t    int);\n static rtx cond_exec_get_condition (rtx);\n static rtx noce_get_condition (rtx_insn *, rtx_insn **, bool);\n static int noce_operand_ok (const_rtx);\n@@ -256,11 +257,11 @@ last_active_insn (basic_block bb, int skip_use_p)\n \n /* Return the active insn before INSN inside basic block CURR_BB. */\n \n-static rtx\n-find_active_insn_before (basic_block curr_bb, rtx insn)\n+static rtx_insn *\n+find_active_insn_before (basic_block curr_bb, rtx_insn *insn)\n {\n   if (!insn || insn == BB_HEAD (curr_bb))\n-    return NULL_RTX;\n+    return NULL;\n \n   while ((insn = PREV_INSN (insn)) != NULL_RTX)\n     {\n@@ -269,19 +270,19 @@ find_active_insn_before (basic_block curr_bb, rtx insn)\n \n       /* No other active insn all the way to the start of the basic block. */\n       if (insn == BB_HEAD (curr_bb))\n-        return NULL_RTX;\n+        return NULL;\n     }\n \n   return insn;\n }\n \n /* Return the active insn after INSN inside basic block CURR_BB. */\n \n-static rtx\n-find_active_insn_after (basic_block curr_bb, rtx insn)\n+static rtx_insn *\n+find_active_insn_after (basic_block curr_bb, rtx_insn *insn)\n {\n   if (!insn || insn == BB_END (curr_bb))\n-    return NULL_RTX;\n+    return NULL;\n \n   while ((insn = NEXT_INSN (insn)) != NULL_RTX)\n     {\n@@ -290,7 +291,7 @@ find_active_insn_after (basic_block curr_bb, rtx insn)\n \n       /* No other active insn all the way to the end of the basic block. */\n       if (insn == BB_END (curr_bb))\n-        return NULL_RTX;\n+        return NULL;\n     }\n \n   return insn;\n@@ -334,14 +335,14 @@ rtx_interchangeable_p (const_rtx a, const_rtx b)\n \n static int\n cond_exec_process_insns (ce_if_block *ce_info ATTRIBUTE_UNUSED,\n-\t\t\t /* if block information */rtx start,\n+\t\t\t /* if block information */rtx_insn *start,\n \t\t\t /* first insn to look at */rtx end,\n \t\t\t /* last insn to look at */rtx test,\n \t\t\t /* conditional execution test */int prob_val,\n \t\t\t /* probability of branch taken. */int mod_ok)\n {\n   int must_be_last = FALSE;\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx xtest;\n   rtx pattern;\n \n@@ -466,10 +467,10 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n   basic_block then_bb = ce_info->then_bb;\t/* THEN */\n   basic_block else_bb = ce_info->else_bb;\t/* ELSE or NULL */\n   rtx test_expr;\t\t/* expression in IF_THEN_ELSE that is tested */\n-  rtx then_start;\t\t/* first insn in THEN block */\n-  rtx then_end;\t\t\t/* last insn + 1 in THEN block */\n-  rtx else_start = NULL_RTX;\t/* first insn in ELSE block or NULL */\n-  rtx else_end = NULL_RTX;\t/* last insn + 1 in ELSE block */\n+  rtx_insn *then_start;\t\t/* first insn in THEN block */\n+  rtx_insn *then_end;\t\t/* last insn + 1 in THEN block */\n+  rtx_insn *else_start = NULL;\t/* first insn in ELSE block or NULL */\n+  rtx_insn *else_end = NULL;\t/* last insn + 1 in ELSE block */\n   int max;\t\t\t/* max # of insns to convert.  */\n   int then_mod_ok;\t\t/* whether conditional mods are ok in THEN */\n   rtx true_expr;\t\t/* test for else block insns */\n@@ -534,9 +535,9 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n \t\t\t\t\t &then_first_tail, &else_first_tail,\n \t\t\t\t\t NULL);\n       if (then_first_tail == BB_HEAD (then_bb))\n-\tthen_start = then_end = NULL_RTX;\n+\tthen_start = then_end = NULL;\n       if (else_first_tail == BB_HEAD (else_bb))\n-\telse_start = else_end = NULL_RTX;\n+\telse_start = else_end = NULL;\n \n       if (n_matching > 0)\n \t{\n@@ -562,7 +563,7 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n \n \t  if (n_matching > 0)\n \t    {\n-\t      rtx insn;\n+\t      rtx_insn *insn;\n \n \t      /* We won't pass the insns in the head sequence to\n \t\t cond_exec_process_insns, so we need to test them here\n@@ -577,9 +578,9 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n \t    }\n \n \t  if (then_last_head == then_end)\n-\t    then_start = then_end = NULL_RTX;\n+\t    then_start = then_end = NULL;\n \t  if (else_last_head == else_end)\n-\t    else_start = else_end = NULL_RTX;\n+\t    else_start = else_end = NULL;\n \n \t  if (n_matching > 0)\n \t    {\n@@ -641,7 +642,7 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n \n       do\n \t{\n-\t  rtx start, end;\n+\t  rtx_insn *start, *end;\n \t  rtx t, f;\n \t  enum rtx_code f_code;\n \n@@ -743,7 +744,7 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n      that the remaining one is executed first for both branches.  */\n   if (then_first_tail)\n     {\n-      rtx from = then_first_tail;\n+      rtx_insn *from = then_first_tail;\n       if (!INSN_P (from))\n \tfrom = find_active_insn_after (then_bb, from);\n       delete_insn_chain (from, BB_END (then_bb), false);\n@@ -2499,7 +2500,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n   basic_block then_bb = if_info->then_bb;\t/* THEN */\n   basic_block else_bb = if_info->else_bb;\t/* ELSE or NULL */\n   basic_block join_bb = if_info->join_bb;\t/* JOIN */\n-  rtx jump = if_info->jump;\n+  rtx_insn *jump = if_info->jump;\n   rtx cond = if_info->cond;\n   rtx_insn *insn_a, *insn_b;\n   rtx set_a, set_b;\n@@ -3201,7 +3202,7 @@ merge_if_block (struct ce_if_block * ce_info)\n       if (EDGE_COUNT (then_bb->succs) == 0\n \t  && EDGE_COUNT (combo_bb->succs) > 1)\n \t{\n-\t  rtx end = NEXT_INSN (BB_END (then_bb));\n+\t  rtx_insn *end = NEXT_INSN (BB_END (then_bb));\n \t  while (end && NOTE_P (end) && !NOTE_INSN_BASIC_BLOCK_P (end))\n \t    end = NEXT_INSN (end);\n \n@@ -3224,7 +3225,7 @@ merge_if_block (struct ce_if_block * ce_info)\n       if (EDGE_COUNT (else_bb->succs) == 0\n \t  && EDGE_COUNT (combo_bb->succs) > 1)\n \t{\n-\t  rtx end = NEXT_INSN (BB_END (else_bb));\n+\t  rtx_insn *end = NEXT_INSN (BB_END (else_bb));\n \t  while (end && NOTE_P (end) && !NOTE_INSN_BASIC_BLOCK_P (end))\n \t    end = NEXT_INSN (end);\n \n@@ -3568,7 +3569,7 @@ cond_exec_find_if_block (struct ce_if_block * ce_info)\n     {\n       if (single_pred_p (else_bb) && else_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n-\t  rtx last_insn = BB_END (then_bb);\n+\t  rtx_insn *last_insn = BB_END (then_bb);\n \n \t  while (last_insn\n \t\t && NOTE_P (last_insn)"}, {"sha": "3cb7ef29eaee612b1061e6479ecd9c14f715d50d", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -1247,8 +1247,9 @@ mark_jump_label_asm (rtx asmop, rtx insn)\n    subsequent cfg_cleanup pass to delete unreachable code if needed.  */\n \n rtx_insn *\n-delete_related_insns (rtx insn)\n+delete_related_insns (rtx uncast_insn)\n {\n+  rtx_insn *insn = as_a <rtx_insn *> (uncast_insn);\n   int was_code_label = (LABEL_P (insn));\n   rtx note;\n   rtx_insn *next = NEXT_INSN (insn), *prev = PREV_INSN (insn);\n@@ -1276,7 +1277,7 @@ delete_related_insns (rtx insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE\n \t  && CALL_P (XVECEXP (PATTERN (insn), 0, 0))))\n     {\n-      rtx p;\n+      rtx_insn *p;\n \n       for (p = next && INSN_DELETED_P (next) ? NEXT_INSN (next) : next;\n \t   p && NOTE_P (p);"}, {"sha": "b0385274f07ee820fd6bff37a4b173cad24d1b95", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -4544,7 +4544,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t\t   \"    Rejecting inheritance %d->%d \"\n \t\t   \"as it results in 2 or more insns:\\n\",\n \t\t   original_regno, REGNO (new_reg));\n-\t  dump_rtl_slim (lra_dump_file, new_insns, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, new_insns, NULL, -1, 0);\n \t  fprintf (lra_dump_file,\n \t\t   \"\t>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n \t}\n@@ -4809,7 +4809,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n \t    (lra_dump_file,\n \t     \"\t  Rejecting split %d->%d resulting in > 2 %s save insns:\\n\",\n \t     original_regno, REGNO (new_reg), call_save_p ? \"call\" : \"\");\n-\t  dump_rtl_slim (lra_dump_file, save, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, save, NULL, -1, 0);\n \t  fprintf (lra_dump_file,\n \t\t   \"\t))))))))))))))))))))))))))))))))))))))))))))))))\\n\");\n \t}\n@@ -4825,7 +4825,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n \t\t   \"\tRejecting split %d->%d \"\n \t\t   \"resulting in > 2 %s restore insns:\\n\",\n \t\t   original_regno, REGNO (new_reg), call_save_p ? \"call\" : \"\");\n-\t  dump_rtl_slim (lra_dump_file, restore, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, restore, NULL, -1, 0);\n \t  fprintf (lra_dump_file,\n \t\t   \"\t))))))))))))))))))))))))))))))))))))))))))))))))\\n\");\n \t}"}, {"sha": "911bcb046cea037a2a794bb83dc8fefdf68b04ec", "filename": "gcc/lra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -1737,12 +1737,12 @@ lra_process_new_insns (rtx_insn *insn, rtx_insn *before, rtx_insn *after,\n       if (before != NULL_RTX)\n \t{\n \t  fprintf (lra_dump_file,\"    %s before:\\n\", title);\n-\t  dump_rtl_slim (lra_dump_file, before, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, before, NULL, -1, 0);\n \t}\n       if (after != NULL_RTX)\n \t{\n \t  fprintf (lra_dump_file, \"    %s after:\\n\", title);\n-\t  dump_rtl_slim (lra_dump_file, after, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, after, NULL, -1, 0);\n \t}\n       fprintf (lra_dump_file, \"\\n\");\n     }"}, {"sha": "5ad484dfe6c69cbc7de1e8712f3f2629e390803e", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -212,7 +212,7 @@ static int compute_split_row (sbitmap, int, int, int, ddg_node_ptr);\n static int sms_order_nodes (ddg_ptr, int, int *, int *);\n static void set_node_sched_params (ddg_ptr);\n static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int, int *);\n-static void permute_partial_schedule (partial_schedule_ptr, rtx);\n+static void permute_partial_schedule (partial_schedule_ptr, rtx_insn *);\n static void generate_prolog_epilog (partial_schedule_ptr, struct loop *,\n                                     rtx, rtx);\n static int calculate_stage_count (partial_schedule_ptr, int);\n@@ -876,7 +876,7 @@ reset_sched_times (partial_schedule_ptr ps, int amount)\n    row ii-1, and position them right before LAST.  This schedules\n    the insns of the loop kernel.  */\n static void\n-permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n+permute_partial_schedule (partial_schedule_ptr ps, rtx_insn *last)\n {\n   int ii = ps->ii;\n   int row;"}, {"sha": "ddc20d7dc1e7d90f5b1f79001bb72442d7eeb2fb", "filename": "gcc/optabs.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -177,9 +177,10 @@ optab_libfunc (optab optab, enum machine_mode mode)\n    try again, ensuring that TARGET is not one of the operands.  */\n \n static int\n-add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n+add_equal_note (rtx_insn *insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n {\n-  rtx last_insn, set;\n+  rtx_insn *last_insn;\n+  rtx set;\n   rtx note;\n \n   gcc_assert (insns && INSN_P (insns) && NEXT_INSN (insns));\n@@ -1505,8 +1506,9 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n       /* If PAT is composed of more than one insn, try to add an appropriate\n \t REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n \t operand, call expand_binop again, this time without a target.  */\n-      if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t  && ! add_equal_note (pat, ops[0].value, optab_to_code (binoptab),\n+      if (INSN_P (pat) && NEXT_INSN (as_a <rtx_insn *> (pat)) != NULL_RTX\n+\t  && ! add_equal_note (as_a <rtx_insn *> (pat), ops[0].value,\n+\t\t\t       optab_to_code (binoptab),\n \t\t\t       ops[1].value, ops[2].value))\n \t{\n \t  delete_insns_since (last);\n@@ -3028,8 +3030,9 @@ expand_unop_direct (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       pat = maybe_gen_insn (icode, 2, ops);\n       if (pat)\n \t{\n-\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t      && ! add_equal_note (pat, ops[0].value, optab_to_code (unoptab),\n+\t  if (INSN_P (pat) && NEXT_INSN (as_a <rtx_insn *> (pat)) != NULL_RTX\n+\t      && ! add_equal_note (as_a <rtx_insn *> (pat), ops[0].value,\n+\t\t\t\t   optab_to_code (unoptab),\n \t\t\t\t   ops[1].value, NULL_RTX))\n \t    {\n \t      delete_insns_since (last);\n@@ -3829,8 +3832,10 @@ maybe_emit_unop_insn (enum insn_code icode, rtx target, rtx op0,\n   if (!pat)\n     return false;\n \n-  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX && code != UNKNOWN)\n-    add_equal_note (pat, ops[0].value, code, ops[1].value, NULL_RTX);\n+  if (INSN_P (pat) && NEXT_INSN (as_a <rtx_insn *> (pat)) != NULL_RTX\n+      && code != UNKNOWN)\n+    add_equal_note (as_a <rtx_insn *> (pat), ops[0].value, code, ops[1].value,\n+\t\t    NULL_RTX);\n \n   emit_insn (pat);\n "}, {"sha": "4dcb14ed75909c848e007d047cc26722b5777640", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -3164,7 +3164,8 @@ static rtx\n peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n {\n   int i;\n-  rtx last, eh_note, as_note, before_try, x;\n+  rtx_insn *last, *before_try, *x;\n+  rtx eh_note, as_note;\n   rtx old_insn, new_insn;\n   bool was_call = false;\n "}, {"sha": "5298a1fc614c1d00d9ee68e177ee4968c9a5f56b", "filename": "gcc/reorg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -213,7 +213,7 @@ static rtx_insn *delete_from_delay_slot (rtx_insn *);\n static void delete_scheduled_jump (rtx);\n static void note_delay_statistics (int, int);\n #if defined(ANNUL_IFFALSE_SLOTS) || defined(ANNUL_IFTRUE_SLOTS)\n-static rtx_insn_list *optimize_skip (rtx);\n+static rtx_insn_list *optimize_skip (rtx_insn *);\n #endif\n static int get_jump_flags (rtx, rtx);\n static int mostly_true_jump (rtx);\n@@ -766,10 +766,10 @@ note_delay_statistics (int slots_filled, int index)\n    of delay slots required.  */\n \n static rtx_insn_list *\n-optimize_skip (rtx insn)\n+optimize_skip (rtx_insn *insn)\n {\n   rtx_insn *trial = next_nonnote_insn (insn);\n-  rtx next_trial = next_active_insn (trial);\n+  rtx_insn *next_trial = next_active_insn (trial);\n   rtx_insn_list *delay_list = 0;\n   int flags;\n "}, {"sha": "eb5374e50b430c9688147f72c61be2fd16f2734f", "filename": "gcc/resource.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -79,10 +79,10 @@ static HARD_REG_SET pending_dead_regs;\n \f\n static void update_live_status (rtx, const_rtx, void *);\n static int find_basic_block (rtx, int);\n-static rtx next_insn_no_annul (rtx);\n-static rtx find_dead_or_set_registers (rtx, struct resources*,\n-\t\t\t\t       rtx*, int, struct resources,\n-\t\t\t\t       struct resources);\n+static rtx_insn *next_insn_no_annul (rtx_insn *);\n+static rtx_insn *find_dead_or_set_registers (rtx_insn *, struct resources*,\n+\t\t\t\t\t     rtx_insn **, int, struct resources,\n+\t\t\t\t\t     struct resources);\n \f\n /* Utility function called from mark_target_live_regs via note_stores.\n    It deadens any CLOBBERed registers and livens any SET registers.  */\n@@ -163,8 +163,8 @@ find_basic_block (rtx insn, int search_limit)\n /* Similar to next_insn, but ignores insns in the delay slots of\n    an annulled branch.  */\n \n-static rtx\n-next_insn_no_annul (rtx insn)\n+static rtx_insn *\n+next_insn_no_annul (rtx_insn *insn)\n {\n   if (insn)\n     {\n@@ -187,7 +187,7 @@ next_insn_no_annul (rtx insn)\n       insn = NEXT_INSN (insn);\n       if (insn && NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, 0);\n+\tinsn = as_a <rtx_sequence *> (PATTERN (insn))->insn (0);\n     }\n \n   return insn;\n@@ -308,7 +308,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t     However, we may have moved some of the parameter loading insns\n \t     into the delay slot of this CALL.  If so, the USE's for them\n \t     don't count and should be skipped.  */\n-\t  rtx_insn *insn = PREV_INSN (x);\n+\t  rtx_insn *insn = PREV_INSN (as_a <rtx_insn *> (x));\n \t  rtx_sequence *sequence = 0;\n \t  int seq_size = 0;\n \t  int i;\n@@ -420,19 +420,19 @@ mark_referenced_resources (rtx x, struct resources *res,\n    Stop after passing a few conditional jumps, and/or a small\n    number of unconditional branches.  */\n \n-static rtx\n-find_dead_or_set_registers (rtx target, struct resources *res,\n-\t\t\t    rtx *jump_target, int jump_count,\n+static rtx_insn *\n+find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n+\t\t\t    rtx_insn **jump_target, int jump_count,\n \t\t\t    struct resources set, struct resources needed)\n {\n   HARD_REG_SET scratch;\n-  rtx insn, next;\n-  rtx jump_insn = 0;\n+  rtx_insn *insn, *next;\n+  rtx_insn *jump_insn = 0;\n   int i;\n \n   for (insn = target; insn; insn = next)\n     {\n-      rtx this_jump_insn = insn;\n+      rtx_insn *this_jump_insn = insn;\n \n       next = NEXT_INSN (insn);\n \n@@ -480,7 +480,7 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t\t of a call, so search for a JUMP_INSN in any position.  */\n \t      for (i = 0; i < seq->len (); i++)\n \t\t{\n-\t\t  this_jump_insn = seq->element (i);\n+\t\t  this_jump_insn = seq->insn (i);\n \t\t  if (JUMP_P (this_jump_insn))\n \t\t    break;\n \t\t}\n@@ -497,14 +497,14 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t      if (any_uncondjump_p (this_jump_insn)\n \t\t  || ANY_RETURN_P (PATTERN (this_jump_insn)))\n \t\t{\n-\t\t  next = JUMP_LABEL (this_jump_insn);\n+\t\t  next = JUMP_LABEL_AS_INSN (this_jump_insn);\n \t\t  if (ANY_RETURN_P (next))\n-\t\t    next = NULL_RTX;\n+\t\t    next = NULL;\n \t\t  if (jump_insn == 0)\n \t\t    {\n \t\t      jump_insn = insn;\n \t\t      if (jump_target)\n-\t\t\t*jump_target = JUMP_LABEL (this_jump_insn);\n+\t\t\t*jump_target = JUMP_LABEL_AS_INSN (this_jump_insn);\n \t\t    }\n \t\t}\n \t      else if (any_condjump_p (this_jump_insn))\n@@ -569,7 +569,7 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t\t  AND_COMPL_HARD_REG_SET (fallthrough_res.regs, scratch);\n \n \t\t  if (!ANY_RETURN_P (JUMP_LABEL (this_jump_insn)))\n-\t\t    find_dead_or_set_registers (JUMP_LABEL (this_jump_insn),\n+\t\t    find_dead_or_set_registers (JUMP_LABEL_AS_INSN (this_jump_insn),\n \t\t\t\t\t\t&target_res, 0, jump_count,\n \t\t\t\t\t\ttarget_set, needed);\n \t\t  find_dead_or_set_registers (next,\n@@ -880,14 +880,14 @@ return_insn_p (const_rtx insn)\n    init_resource_info () was invoked before we are called.  */\n \n void\n-mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n+mark_target_live_regs (rtx_insn *insns, rtx_insn *target, struct resources *res)\n {\n   int b = -1;\n   unsigned int i;\n   struct target_info *tinfo = NULL;\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx jump_insn = 0;\n-  rtx jump_target;\n+  rtx_insn *jump_target;\n   HARD_REG_SET scratch;\n   struct resources set, needed;\n \n@@ -965,7 +965,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n   if (b != -1)\n     {\n       regset regs_live = DF_LR_IN (BASIC_BLOCK_FOR_FN (cfun, b));\n-      rtx start_insn, stop_insn;\n+      rtx_insn *start_insn, *stop_insn;\n \n       /* Compute hard regs live at start of block.  */\n       REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);\n@@ -978,7 +978,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \n       if (NONJUMP_INSN_P (start_insn)\n \t  && GET_CODE (PATTERN (start_insn)) == SEQUENCE)\n-\tstart_insn = XVECEXP (PATTERN (start_insn), 0, 0);\n+\tstart_insn = as_a <rtx_sequence *> (PATTERN (start_insn))->insn (0);\n \n       if (NONJUMP_INSN_P (stop_insn)\n \t  && GET_CODE (PATTERN (stop_insn)) == SEQUENCE)\n@@ -1122,7 +1122,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n   if (jump_insn)\n     {\n       struct resources new_resources;\n-      rtx stop_insn = next_active_insn (jump_insn);\n+      rtx_insn *stop_insn = next_active_insn (jump_insn);\n \n       if (!ANY_RETURN_P (jump_target))\n \tjump_target = next_active_insn (jump_target);"}, {"sha": "633d1ab7f7443951586b6bd494b6f34b11f83b04", "filename": "gcc/resource.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fresource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fresource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.h?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -44,7 +44,7 @@ enum mark_resource_type\n   MARK_SRC_DEST_CALL = 1\n };\n \n-extern void mark_target_live_regs (rtx, rtx, struct resources *);\n+extern void mark_target_live_regs (rtx_insn *, rtx_insn *, struct resources *);\n extern void mark_set_resources (rtx, struct resources *, int,\n \t\t\t\tenum mark_resource_type);\n extern void mark_referenced_resources (rtx, struct resources *, bool);"}, {"sha": "ab2a4de859a3a33179eb4eb92c6f520b5eb8f65e", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -2789,8 +2789,8 @@ extern bool can_throw_external (const_rtx);\n extern bool insn_could_throw_p (const_rtx);\n extern bool insn_nothrow_p (const_rtx);\n extern bool can_nonlocal_goto (const_rtx);\n-extern void copy_reg_eh_region_note_forward (rtx, rtx, rtx);\n-extern void copy_reg_eh_region_note_backward (rtx, rtx, rtx);\n+extern void copy_reg_eh_region_note_forward (rtx, rtx_insn *, rtx);\n+extern void copy_reg_eh_region_note_backward (rtx, rtx_insn *, rtx);\n extern int inequality_comparisons_p (const_rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);\n extern void replace_label (rtx *, rtx, rtx, bool);\n@@ -3280,7 +3280,7 @@ extern void pop_topmost_sequence (void);\n extern void set_new_first_and_last_insn (rtx_insn *, rtx_insn *);\n extern unsigned int unshare_all_rtl (void);\n extern void unshare_all_rtl_again (rtx_insn *);\n-extern void unshare_all_rtl_in_chain (rtx);\n+extern void unshare_all_rtl_in_chain (rtx_insn *);\n extern void verify_rtl_sharing (void);\n extern void add_insn (rtx_insn *);\n extern void add_insn_before (rtx, rtx, basic_block);\n@@ -3339,7 +3339,8 @@ extern void print_inline_rtx (FILE *, const_rtx, int);\n    by the scheduler anymore but for all \"slim\" RTL dumping.  */\n extern void dump_value_slim (FILE *, const_rtx, int);\n extern void dump_insn_slim (FILE *, const_rtx);\n-extern void dump_rtl_slim (FILE *, const_rtx, const_rtx, int, int);\n+extern void dump_rtl_slim (FILE *, const rtx_insn *, const rtx_insn *,\n+\t\t\t   int, int);\n extern void print_value (pretty_printer *, const_rtx, int);\n extern void print_pattern (pretty_printer *, const_rtx, int);\n extern void print_insn (pretty_printer *, const_rtx, int);"}, {"sha": "e922a96b7b816f8fa76dd7f347f73cb6e3f395a8", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -3848,10 +3848,10 @@ delete_dep_nodes_in_back_deps (rtx insn, bool resolved_p)\n /* Delete (RESOLVED_P) dependencies between HEAD and TAIL together with\n    deps_lists.  */\n void\n-sched_free_deps (rtx head, rtx tail, bool resolved_p)\n+sched_free_deps (rtx_insn *head, rtx_insn *tail, bool resolved_p)\n {\n-  rtx insn;\n-  rtx next_tail = NEXT_INSN (tail);\n+  rtx_insn *insn;\n+  rtx_insn *next_tail = NEXT_INSN (tail);\n \n   /* We make two passes since some insns may be scheduled before their\n      dependencies are resolved.  */"}, {"sha": "c3be721c89da17a4a5d9a3881bf2350a0be7955b", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -116,8 +116,8 @@ static void\n init_ready_list (void)\n {\n   int n = 0;\n-  rtx prev_head = current_sched_info->prev_head;\n-  rtx next_tail = current_sched_info->next_tail;\n+  rtx_insn *prev_head = current_sched_info->prev_head;\n+  rtx_insn *next_tail = current_sched_info->next_tail;\n   rtx_insn *insn;\n \n   sched_rgn_n_insns = 0;\n@@ -189,7 +189,7 @@ begin_move_insn (rtx_insn *insn, rtx_insn *last)\n       else\n \t{\n \t  /* Create an empty unreachable block after the INSN.  */\n-\t  rtx next = NEXT_INSN (insn);\n+\t  rtx_insn *next = NEXT_INSN (insn);\n \t  if (next && BARRIER_P (next))\n \t    next = NEXT_INSN (next);\n \t  bb = create_basic_block (next, NULL_RTX, last_bb);"}, {"sha": "bbf332a2576f8e4b2d6b9cfb5307e4b36b13adea", "filename": "gcc/sched-int.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -1328,7 +1328,7 @@ extern void deps_start_bb (struct deps_desc *, rtx);\n extern enum reg_note ds_to_dt (ds_t);\n \n extern bool deps_pools_are_empty_p (void);\n-extern void sched_free_deps (rtx, rtx, bool);\n+extern void sched_free_deps (rtx_insn *, rtx_insn *, bool);\n extern void extend_dependency_caches (int, bool);\n \n extern void debug_ds (ds_t);\n@@ -1342,14 +1342,14 @@ extern void free_global_sched_pressure_data (void);\n extern int haifa_classify_insn (const_rtx);\n extern void get_ebb_head_tail (basic_block, basic_block,\n \t\t\t       rtx_insn **, rtx_insn **);\n-extern int no_real_insns_p (const_rtx, const_rtx);\n+extern int no_real_insns_p (const rtx_insn *, const rtx_insn *);\n \n extern int insn_cost (rtx_insn *);\n extern int dep_cost_1 (dep_t, dw_t);\n extern int dep_cost (dep_t);\n extern int set_priorities (rtx_insn *, rtx_insn *);\n \n-extern void sched_setup_bb_reg_pressure_info (basic_block, rtx);\n+extern void sched_setup_bb_reg_pressure_info (basic_block, rtx_insn *);\n extern bool schedule_block (basic_block *, state_t);\n \n extern int cycle_issued_insns;"}, {"sha": "509a2243b846cb741442dbef4ecfb7ed50b110a7", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -2107,8 +2107,8 @@ schedule_more_p (void)\n static void\n init_ready_list (void)\n {\n-  rtx prev_head = current_sched_info->prev_head;\n-  rtx next_tail = current_sched_info->next_tail;\n+  rtx_insn *prev_head = current_sched_info->prev_head;\n+  rtx_insn *next_tail = current_sched_info->next_tail;\n   int bb_src;\n   rtx_insn *insn;\n "}, {"sha": "1dca799d41f2d2e600d6df81b0923a8613d11044", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -816,14 +816,14 @@ dump_insn_slim (FILE *f, const_rtx x)\n    If COUNT < 0 it will stop only at LAST or NULL rtx.  */\n \n void\n-dump_rtl_slim (FILE *f, const_rtx first, const_rtx last,\n+dump_rtl_slim (FILE *f, const rtx_insn *first, const rtx_insn *last,\n \t       int count, int flags ATTRIBUTE_UNUSED)\n {\n-  const_rtx insn, tail;\n+  const rtx_insn *insn, *tail;\n   pretty_printer rtl_slim_pp;\n   rtl_slim_pp.buffer->stream = f;\n \n-  tail = last ? NEXT_INSN (last) : NULL_RTX;\n+  tail = last ? NEXT_INSN (last) : NULL;\n   for (insn = first;\n        (insn != NULL) && (insn != tail) && (count != 0);\n        insn = NEXT_INSN (insn))\n@@ -842,7 +842,7 @@ dump_rtl_slim (FILE *f, const_rtx first, const_rtx last,\n void\n rtl_dump_bb_for_graph (pretty_printer *pp, basic_block bb)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   bool first = true;\n \n   /* TODO: inter-bb stuff.  */\n@@ -882,9 +882,11 @@ debug_insn_slim (const_rtx x)\n }\n \n /* Same as above, but using dump_rtl_slim.  */\n-extern void debug_rtl_slim (FILE *, const_rtx, const_rtx, int, int);\n+extern void debug_rtl_slim (FILE *, const rtx_insn *, const rtx_insn *,\n+\t\t\t    int, int);\n DEBUG_FUNCTION void\n-debug_rtl_slim (const_rtx first, const_rtx last, int count, int flags)\n+debug_rtl_slim (const rtx_insn *first, const rtx_insn *last, int count,\n+\t\tint flags)\n {\n   dump_rtl_slim (stderr, first, last, count, flags);\n }"}, {"sha": "fd24135e06a7e9bf323f362f956e568511f9b301", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -428,13 +428,13 @@ dup_block_and_redirect (basic_block bb, basic_block copy_bb, rtx_insn *before,\n \n void\n try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n-\t\t     bitmap_head *bb_flags, rtx prologue_seq)\n+\t\t     bitmap_head *bb_flags, rtx_insn *prologue_seq)\n {\n   edge e;\n   edge_iterator ei;\n   bool nonempty_prologue = false;\n   unsigned max_grow_size;\n-  rtx seq;\n+  rtx_insn *seq;\n \n   for (seq = prologue_seq; seq; seq = NEXT_INSN (seq))\n     if (!NOTE_P (seq) || NOTE_KIND (seq) != NOTE_INSN_PROLOGUE_END)\n@@ -449,7 +449,7 @@ try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n     {\n       HARD_REG_SET prologue_clobbered, prologue_used, live_on_edge;\n       struct hard_reg_set_container set_up_by_prologue;\n-      rtx p_insn;\n+      rtx_insn *p_insn;\n       vec<basic_block> vec;\n       basic_block bb;\n       bitmap_head bb_antic_flags;\n@@ -831,7 +831,7 @@ get_unconverted_simple_return (edge exit_fallthru_edge, bitmap_head bb_flags,\n \n void\n convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n-\t\t\t  bitmap_head bb_flags, rtx returnjump,\n+\t\t\t  bitmap_head bb_flags, rtx_insn *returnjump,\n \t\t\t  vec<edge> unconverted_simple_returns)\n {\n   edge e;"}, {"sha": "647c0769fc9e05dd0053b42d7a3ceb7d5d16cf71", "filename": "gcc/shrink-wrap.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fshrink-wrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fshrink-wrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.h?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -40,11 +40,12 @@ extern void dup_block_and_redirect (basic_block bb, basic_block copy_bb,\n \t\t\t\t    rtx_insn *before,\n \t\t\t\t    bitmap_head *need_prologue);\n extern void try_shrink_wrapping (edge *entry_edge, edge orig_entry_edge,\n-\t\t\t\t bitmap_head *bb_flags, rtx prologue_seq);\n+\t\t\t\t bitmap_head *bb_flags, rtx_insn *prologue_seq);\n extern edge get_unconverted_simple_return (edge, bitmap_head,\n \t\t\t\t\t   vec<edge> *, rtx_insn **);\n extern void convert_to_simple_return (edge entry_edge, edge orig_entry_edge,\n-\t\t\t\t      bitmap_head bb_flags, rtx returnjump,\n+\t\t\t\t      bitmap_head bb_flags,\n+\t\t\t\t      rtx_insn *returnjump,\n \t\t\t\t      vec<edge> unconverted_simple_returns);\n #endif\n "}, {"sha": "66d0d8a612761d8f8c91f8877d1250b58da57afd", "filename": "gcc/valtrack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -177,7 +177,7 @@ propagate_for_debug_subst (rtx from, const_rtx old_rtx, void *data)\n    of THIS_BASIC_BLOCK.  */\n \n void\n-propagate_for_debug (rtx_insn *insn, rtx last, rtx dest, rtx src,\n+propagate_for_debug (rtx_insn *insn, rtx_insn *last, rtx dest, rtx src,\n \t\t     basic_block this_basic_block)\n {\n   rtx_insn *next, *end = NEXT_INSN (BB_END (this_basic_block));"}, {"sha": "d8b8bb80450e128192b1fd3d9b5d5a0a278fda58", "filename": "gcc/valtrack.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fvaltrack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc01c3d194afdf0ef85c46a97459badf1b149225/gcc%2Fvaltrack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.h?ref=dc01c3d194afdf0ef85c46a97459badf1b149225", "patch": "@@ -149,7 +149,7 @@ extern int dead_debug_insert_temp (struct dead_debug_local *,\n \t\t\t\t   unsigned int uregno, rtx insn,\n \t\t\t\t   enum debug_temp_where);\n \n-extern void propagate_for_debug (rtx_insn *, rtx, rtx, rtx, basic_block);\n+extern void propagate_for_debug (rtx_insn *, rtx_insn *, rtx, rtx, basic_block);\n \n \n #endif /* GCC_VALTRACK_H */"}]}