{"sha": "efee38a99ac1639e29a1f08235756becdbeca01c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZlZTM4YTk5YWMxNjM5ZTI5YTFmMDgyMzU3NTZiZWNkYmVjYTAxYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-25T18:10:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-25T18:10:04Z"}, "message": "cp-tree.h (check_return_expr): New function.\n\n\t* cp-tree.h (check_return_expr): New function.\n\t* decl.c (finish_constructor_body): New function.\n\t(pushdecl): Put global friend functions in namespace binding\n\tlevel, not the class binding level.\n\t(finish_destructor_body): Make sure the dtor_label is always\n\tdefined.  Fix typo in comment.\n\t(finish_function): Move generation of constructor-termination code\n\tto semantic-analysis time.  Move generation of implicit `main'\n\treturn value to semantic-analysis time.\n\t* semantics.c (finish_return_stmt): Generate goto's to\n\tctor_label/dtor_label here.  Use check_return_expr to do semantic\n\tanalysis on the returned expression.\n\t* typeck.c (maybe_warn_about_returning_address_of_local): New\n\tfunction split out from c_expand_return.\n\t(check_return_expr): Likewise.\n\t(c_expand_return): Just generate the RTL for the return.\n\nFrom-SVN: r29663", "tree": {"sha": "29d37f53a0796acd0b38eaf7a9a35991a1aa4bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29d37f53a0796acd0b38eaf7a9a35991a1aa4bf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efee38a99ac1639e29a1f08235756becdbeca01c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efee38a99ac1639e29a1f08235756becdbeca01c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efee38a99ac1639e29a1f08235756becdbeca01c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efee38a99ac1639e29a1f08235756becdbeca01c/comments", "author": null, "committer": null, "parents": [{"sha": "5a657fc371aefb7648ad42cc9db9187032a80809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a657fc371aefb7648ad42cc9db9187032a80809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a657fc371aefb7648ad42cc9db9187032a80809"}], "stats": {"total": 450, "additions": 266, "deletions": 184}, "files": [{"sha": "0efaa14b3287d7fbea5c3e21887a3f8f3c32dce7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=efee38a99ac1639e29a1f08235756becdbeca01c", "patch": "@@ -1,3 +1,22 @@\n+1999-09-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (check_return_expr): New function.\n+\t* decl.c (finish_constructor_body): New function.\n+\t(pushdecl): Put global friend functions in namespace binding\n+\tlevel, not the class binding level.\n+\t(finish_destructor_body): Make sure the dtor_label is always\n+\tdefined.  Fix typo in comment.\n+\t(finish_function): Move generation of constructor-termination code\n+\tto semantic-analysis time.  Move generation of implicit `main'\n+\treturn value to semantic-analysis time.\n+\t* semantics.c (finish_return_stmt): Generate goto's to\n+\tctor_label/dtor_label here.  Use check_return_expr to do semantic\n+\tanalysis on the returned expression.\n+\t* typeck.c (maybe_warn_about_returning_address_of_local): New\n+\tfunction split out from c_expand_return.\n+\t(check_return_expr): Likewise.\n+\t(c_expand_return): Just generate the RTL for the return.\n+\t\n 1999-09-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (CPTI_CLEANUP_TYPE): New macro."}, {"sha": "15c5099beab705bb6b10a30b75b9c0ceed5fc931", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=efee38a99ac1639e29a1f08235756becdbeca01c", "patch": "@@ -3949,6 +3949,7 @@ extern tree pfn_from_ptrmemfunc                 PROTO((tree));\n extern tree type_after_usual_arithmetic_conversions PROTO((tree, tree));\n extern tree composite_pointer_type              PROTO((tree, tree, tree, tree,\n \t\t\t\t\t\t       const char*));\n+extern tree check_return_expr                   PROTO((tree));\n \n /* in typeck2.c */\n extern tree error_not_base_type\t\t\tPROTO((tree, tree));"}, {"sha": "d5da38f4f28c2343e07eb378541591d22c9132cc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=efee38a99ac1639e29a1f08235756becdbeca01c", "patch": "@@ -180,6 +180,7 @@ static void save_function_data PROTO((tree));\n static void check_function_type PROTO((tree));\n static void destroy_local_static PROTO((tree));\n static void destroy_local_var PROTO((tree));\n+static void finish_constructor_body PROTO((void));\n static void finish_destructor_body PROTO((void));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n@@ -4064,7 +4065,10 @@ pushdecl (x)\n     }\n \n   if (need_new_binding)\n-    add_decl_to_level (x, current_binding_level);\n+    add_decl_to_level (x, \n+\t\t       DECL_NAMESPACE_SCOPE_P (x)\n+\t\t       ? NAMESPACE_LEVEL (CP_DECL_CONTEXT (x))\n+\t\t       : current_binding_level);\n \n   return x;\n }\n@@ -13329,9 +13333,26 @@ save_function_data (decl)\n   f->cannot_inline = current_function_cannot_inline;\n }\n \n+/* At the end of every constructor we generate to code to return\n+   `this'.  Do that now.  */\n+\n+static void\n+finish_constructor_body ()\n+{\n+  /* Any return from a constructor will end up here.  */\n+  add_tree (build_min_nt (LABEL_STMT, ctor_label));\n+\n+  /* Clear CTOR_LABEL so that finish_return_stmt knows to really\n+     generate the return, rather than a goto to CTOR_LABEL.  */\n+  ctor_label = NULL_TREE;\n+  /* In check_return_expr we translate an empty return from a\n+     constructor to a return of `this'.  */\n+  finish_return_stmt (NULL_TREE);\n+}\n+\n /* At the end of every destructor we generate code to restore virtual\n    function tables to the values desired by base classes and to call\n-   to base class destructors.  Do that now, for DECL.  */\n+   to base class destructors.  Do that now.  */\n \n static void\n finish_destructor_body ()\n@@ -13344,6 +13365,9 @@ finish_destructor_body ()\n   /* Create a block to contain all the extra code.  */\n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n \n+  /* Any return from a destructor will end up here.  */\n+  add_tree (build_min_nt (LABEL_STMT, dtor_label));\n+\n   /* Generate the code to call destructor on base class.  If this\n      destructor belongs to a class with virtual functions, then set\n      the virtual function table pointer to represent the type of our\n@@ -13372,13 +13396,12 @@ finish_destructor_body ()\n \t  || TREE_OPERAND (exprstmt, 0) != integer_zero_node\n \t  || TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)))\n     {\n-      add_tree (build_min_nt (LABEL_STMT, dtor_label));\n       if (exprstmt != void_zero_node)\n \t/* Don't call `expand_expr_stmt' if we're not going to do\n \t   anything, since -Wall will give a diagnostic.  */\n \tfinish_expr_stmt (exprstmt);\n \n-      /* Run destructor on all virtual baseclasses.  */\n+      /* Run destructors for all virtual baseclasses.  */\n       if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n \t{\n \t  tree vbases = nreverse (copy_list (CLASSTYPE_VBASECLASSES (current_class_type)));\n@@ -13496,10 +13519,23 @@ finish_function (lineno, flags)\n \n   if (building_stmt_tree ())\n     {\n-      if (DECL_CONSTRUCTOR_P (fndecl) && call_poplevel)\n-\tdo_poplevel ();\n+      if (DECL_CONSTRUCTOR_P (fndecl))\n+\t{\n+\t  finish_constructor_body ();\n+\t  if (call_poplevel)\n+\t    do_poplevel ();\n+\t}\n       else if (DECL_DESTRUCTOR_P (fndecl) && !processing_template_decl)\n \tfinish_destructor_body ();\n+      else if (DECL_MAIN_P (fndecl))\n+\t{\n+\t  /* Make it so that `main' always returns 0 by default.  */\n+#ifdef VMS\n+\t  finish_return_stmt (integer_one_node);\n+#else\n+\t  finish_return_stmt (integer_zero_node);\n+#endif\n+\t}\n \n       /* Finish dealing with exception specifiers.  */\n       if (flag_exceptions && !processing_template_decl\n@@ -13535,28 +13571,11 @@ finish_function (lineno, flags)\n \t;\n       else if (DECL_CONSTRUCTOR_P (fndecl))\n \t{\n-\t  /* This is where the body of the constructor begins.  All\n-\t     subobjects have been fully constructed at this point.  */\n+\t  /* All subobjects have been fully constructed at this point.  */\n \t  end_protect_partials ();\n \n-\t  /* This is where the body of the constructor ends.  */\n-\t  expand_label (ctor_label);\n-\t  ctor_label = NULL_TREE;\n-\n \t  if (call_poplevel)\n \t    do_poplevel ();\n-\n-\t  /* c_expand_return knows to return 'this' from a constructor.  */\n-\t  c_expand_return (NULL_TREE);\n-\t}\n-      else if (DECL_MAIN_P (fndecl))\n-\t{\n-\t  /* Make it so that `main' always returns 0 by default.  */\n-#ifdef VMS\n-\t  c_expand_return (integer_one_node);\n-#else\n-\t  c_expand_return (integer_zero_node);\n-#endif\n \t}\n       else if (return_label != NULL_RTX\n \t       && flag_this_is_variable <= 0"}, {"sha": "ac7856bce58bc7560a804a083fa2ffebe5c7fed3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=efee38a99ac1639e29a1f08235756becdbeca01c", "patch": "@@ -371,6 +371,33 @@ void\n finish_return_stmt (expr)\n      tree expr;\n {\n+  if (doing_semantic_analysis_p () && !processing_template_decl)\n+    expr = check_return_expr (expr);\n+\n+  if (doing_semantic_analysis_p () && !processing_template_decl)\n+    {\n+      if (DECL_CONSTRUCTOR_P (current_function_decl) && ctor_label)\n+\t{\n+\t  /* Even returns without a value in a constructor must return\n+\t     `this'.  We accomplish this by sending all returns in a\n+\t     constructor to the CTOR_LABEL; finish_function emits code to\n+\t     return a value there.  When we finally generate the real\n+\t     return statement, CTOR_LABEL is no longer set, and we fall\n+\t     through into the normal return-processing code below.  */\n+\t  finish_goto_stmt (ctor_label);\n+\t  return;\n+\t}\n+      else if (DECL_DESTRUCTOR_P (current_function_decl))\n+\t{\n+\t  /* Similarly, all destructors must run destructors for\n+\t     base-classes before returning.  So, all returns in a\n+\t     destructor get sent to the DTOR_LABEL; finsh_function emits\n+\t     code to return a value there.  */\n+\t  finish_goto_stmt (dtor_label);\n+\t  return;\n+\t}\n+    }\n+\n   if (building_stmt_tree ())\n     add_tree (build_min_nt (RETURN_STMT, expr));\n   else"}, {"sha": "6a18b11cdb5d9609a12fc6dd35ccd384976917b1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 176, "deletions": 160, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efee38a99ac1639e29a1f08235756becdbeca01c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=efee38a99ac1639e29a1f08235756becdbeca01c", "patch": "@@ -64,6 +64,7 @@ static tree get_delta_difference PROTO((tree, tree, int));\n static int comp_cv_target_types PROTO((tree, tree, int));\n static void casts_away_constness_r PROTO((tree *, tree *));\n static int casts_away_constness PROTO ((tree, tree));\n+static void maybe_warn_about_returning_address_of_local PROTO ((tree));\n \n /* Return the target type of TYPE, which means return T for:\n    T*, T&, T[], T (...), and otherwise, just T.  */\n@@ -6639,230 +6640,245 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   emit_queue ();\n }\n \f\n-/* Expand a C `return' statement.\n-   RETVAL is the expression for what to return,\n-   or a null pointer for `return;' with no value.\n+/* If RETVAL is the address of, or a reference to, a local variable or\n+   temporary give an appropraite warning.  */\n \n-   C++: upon seeing a `return', we must call destructors on all\n-   variables in scope which had constructors called on them.\n-   This means that if in a destructor, the base class destructors\n-   must be called before returning.\n+static void\n+maybe_warn_about_returning_address_of_local (retval)\n+     tree retval;\n+{\n+  tree valtype = TREE_TYPE (DECL_RESULT (current_function_decl));\n \n-   The RETURN statement in C++ has initialization semantics.  */\n+  if (TREE_CODE (valtype) == REFERENCE_TYPE)\n+    {\n+      tree whats_returned;\n \n-void\n-c_expand_return (retval)\n+      /* Sort through common things to see what it is\n+\t we are returning.  */\n+      whats_returned = retval;\n+      if (TREE_CODE (whats_returned) == COMPOUND_EXPR)\n+\t{\n+\t  whats_returned = TREE_OPERAND (whats_returned, 1);\n+\t  if (TREE_CODE (whats_returned) == ADDR_EXPR)\n+\t    whats_returned = TREE_OPERAND (whats_returned, 0);\n+\t}\n+      while (TREE_CODE (whats_returned) == CONVERT_EXPR\n+\t     || TREE_CODE (whats_returned) == NOP_EXPR)\n+\twhats_returned = TREE_OPERAND (whats_returned, 0);\n+      if (TREE_CODE (whats_returned) == ADDR_EXPR)\n+\t{\n+\t  whats_returned = TREE_OPERAND (whats_returned, 0);\n+\t  while (TREE_CODE (whats_returned) == AGGR_INIT_EXPR\n+\t\t || TREE_CODE (whats_returned) == TARGET_EXPR)\n+\t    {\n+\t      /* Get the target.  */\n+\t      whats_returned = TREE_OPERAND (whats_returned, 0);\n+\t      warning (\"returning reference to temporary\");\n+\t    }\n+\t}\n+\n+      if (TREE_CODE (whats_returned) == VAR_DECL \n+\t  && DECL_NAME (whats_returned))\n+\t{\n+\t  if (TEMP_NAME_P (DECL_NAME (whats_returned)))\n+\t    warning (\"reference to non-lvalue returned\");\n+\t  else if (TREE_CODE (TREE_TYPE (whats_returned)) != REFERENCE_TYPE\n+\t\t   && DECL_FUNCTION_SCOPE_P (whats_returned)\n+\t\t   && !(TREE_STATIC (whats_returned)\n+\t\t\t|| TREE_PUBLIC (whats_returned)))\n+\t    cp_warning_at (\"reference to local variable `%D' returned\", \n+\t\t\t   whats_returned);\n+\t}\n+    }\n+  else if (TREE_CODE (retval) == ADDR_EXPR)\n+    {\n+      tree whats_returned = TREE_OPERAND (retval, 0);\n+\n+      if (TREE_CODE (whats_returned) == VAR_DECL\n+\t  && DECL_NAME (whats_returned)\n+\t  && DECL_FUNCTION_SCOPE_P (whats_returned)\n+\t  && !(TREE_STATIC (whats_returned)\n+\t       || TREE_PUBLIC (whats_returned)))\n+\tcp_warning_at (\"address of local variable `%D' returned\", \n+\t\t       whats_returned);\n+    }\n+}\n+\n+/* Check that returning RETVAL from the current function is legal.\n+   Return an expression explicitly showing all conversions required to\n+   change RETVAL into the function return type, and to assign it to\n+   the DECL_RESULT for the function.  */\n+\n+tree\n+check_return_expr (retval)\n      tree retval;\n {\n-  tree result = DECL_RESULT (current_function_decl);\n-  tree valtype = TREE_TYPE (result);\n-\n+  tree result;\n+  /* The type actually returned by the function, after any\n+     promotions.  */\n+  tree valtype;\n+  int fn_returns_value_p;\n+\n+  /* A `volatile' function is one that isn't supposed to return, ever.\n+     (This is a G++ extension, used to get better code for functions\n+     that call the `volatile' function.)  */\n   if (TREE_THIS_VOLATILE (current_function_decl))\n     warning (\"function declared `noreturn' has a `return' statement\");\n \n+  /* Check for various simple errors.  */\n   if (retval == error_mark_node)\n     {\n+      /* If an error occurred, there's nothing to do.  */\n       current_function_returns_null = 1;\n-      return;\n+      return error_mark_node;\n     }\n-\n-  if (dtor_label)\n+  else if (dtor_label)\n     {\n       if (retval)\n \terror (\"returning a value from a destructor\");\n-\n-      /* Can't just return from a destructor.  */\n-      expand_goto (dtor_label);\n-      return;\n+      return NULL_TREE;\n     }\n   else if (in_function_try_handler\n \t   && DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n       /* If a return statement appears in a handler of the\n          function-try-block of a constructor, the program is ill-formed. */\n       error (\"cannot return from a handler of a function-try-block of a constructor\");\n-      return;\n+      return error_mark_node;\n+    }\n+  else if (retval && DECL_CONSTRUCTOR_P (current_function_decl))\n+    /* You can't return a value from a constructor.  */\n+    error (\"returning a value from a constructor\");\n+\n+  /* Constructors actually always return `this', even though in C++\n+     you can't return a value from a constructor.  */\n+  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+    retval = current_class_ptr;\n+\n+  /* When no explicit return-value is given in a function with a named\n+     return value, the named return value is used.  */\n+  result = DECL_RESULT (current_function_decl);\n+  valtype = TREE_TYPE (result);\n+  my_friendly_assert (valtype != NULL_TREE, 19990924);\n+  fn_returns_value_p = !same_type_p (valtype, void_type_node);\n+  if (!retval && DECL_NAME (result) && fn_returns_value_p)\n+    retval = result;\n+\n+  /* Check for a return statement with no return value in a function\n+     that's supposed to return a value.  */\n+  if (!retval && fn_returns_value_p)\n+    {\n+      pedwarn (\"`return' with no value, in function returning non-void\");\n+      /* Clear this, so finish_function won't say that we reach the\n+\t end of a non-void function (which we don't, we gave a\n+\t return!).  */\n+      current_function_returns_null = 0;\n+    }\n+  /* Check for a return statement with a value in a function that\n+     isn't supposed to return a value.  */\n+  else if (retval && !fn_returns_value_p)\n+    {     \n+      if (same_type_p (TREE_TYPE (retval), void_type_node))\n+\t/* You can return a `void' value from a function of `void'\n+\t   type.  In that case, we have to evaluate the expression for\n+\t   its side-effects.  */\n+\t  finish_expr_stmt (retval);\n+      else\n+\tpedwarn (\"`return' with a value, in function returning void\");\n+\n+      current_function_returns_null = 1;\n+\n+      /* There's really no value to return, after all.  */\n+      return NULL_TREE;\n     }\n+  else if (!retval)\n+    /* Remember that this function can sometimes return without a\n+       value.  */\n+    current_function_returns_null = 1;\n \n   /* Only operator new(...) throw(), can return NULL [expr.new/13].  */\n   if ((DECL_NAME (current_function_decl) == ansi_opname[(int) NEW_EXPR]\n        || DECL_NAME (current_function_decl) == ansi_opname[(int) VEC_NEW_EXPR])\n       && !TYPE_NOTHROW_P (TREE_TYPE (current_function_decl))\n       && null_ptr_cst_p (retval))\n     cp_warning (\"operator new should throw an exception, not return NULL\");\n-  \n-  if (retval == NULL_TREE)\n-    {\n-      /* A non-named return value does not count.  */\n-\n-      if (DECL_CONSTRUCTOR_P (current_function_decl))\n-\tretval = current_class_ptr;\n-      else if (DECL_NAME (result) != NULL_TREE\n-\t       && TREE_CODE (valtype) != VOID_TYPE)\n-\tretval = result;\n-      else\n-\t{\n-\t  current_function_returns_null = 1;\n-\n-\t  if (valtype != NULL_TREE && TREE_CODE (valtype) != VOID_TYPE)\n-\t    {\n-\t      if (DECL_NAME (DECL_RESULT (current_function_decl)) == NULL_TREE)\n-\t\t{\n-\t\t  pedwarn (\"`return' with no value, in function returning non-void\");\n-\t\t  /* Clear this, so finish_function won't say that we\n-\t\t     reach the end of a non-void function (which we don't,\n-\t\t     we gave a return!).  */\n-\t\t  current_function_returns_null = 0;\n-\t\t}\n-\t    }\n-\n-\t  expand_null_return ();\n-\t  return;\n-\t}\n-    }\n-  else if (DECL_CONSTRUCTOR_P (current_function_decl))\n-    {\n-      error (\"returning a value from a constructor\");\n-      retval = current_class_ptr;\n-    }\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp\n       && DECL_NAME (current_function_decl) == ansi_opname[(int) MODIFY_EXPR]\n       && retval != current_class_ref)\n     cp_warning (\"`operator=' should return a reference to `*this'\");\n \n-  if (valtype == NULL_TREE || TREE_CODE (valtype) == VOID_TYPE)\n-    {\n-      current_function_returns_null = 1;\n-      if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n-\tpedwarn (\"`return' with a value, in function returning void\");\n-      expand_return (retval);\n-      return;\n-    }\n-  \n-  /* Now deal with possible C++ hair:\n-     (1) Compute the return value.\n-     (2) If there are aggregate values with destructors which\n-     must be cleaned up, clean them (taking care\n-     not to clobber the return value).\n-     (3) If an X(X&) constructor is defined, the return\n-     value must be returned via that.  */\n-\n-  if (retval == result\n-      || DECL_CONSTRUCTOR_P (current_function_decl))\n-    /* It's already done for us.  */;\n-  else if (TREE_CODE (TREE_TYPE (retval)) == VOID_TYPE)\n-    {\n-      pedwarn (\"return of void value in function returning non-void\");\n-      expand_expr_stmt (retval);\n-      retval = 0;\n-    }\n+  /* We don't need to do any conversions when there's nothing being\n+     returned.  */\n+  if (!retval)\n+    return NULL_TREE;\n+\n+  /* Do any required conversions.  */\n+  if (retval == result || DECL_CONSTRUCTOR_P (current_function_decl))\n+    /* No conversions are required.  */\n+    ;\n   else\n     {\n+      /* The type the function is declared to return.  */\n       tree functype = TREE_TYPE (TREE_TYPE (current_function_decl));\n \n       /* First convert the value to the function's return type, then\n \t to the type of return value's location to handle the\n          case that functype is thiner than the valtype. */\n-\n       retval = convert_for_initialization\n \t(NULL_TREE, functype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n \t \"return\", NULL_TREE, 0);\n-\n       retval = convert (valtype, retval);\n \n+      /* If the conversion failed, treat this just like `return;'.  */\n       if (retval == error_mark_node)\n-\t{\n-\t  /* Avoid warning about control reaching end of function.  */\n-\t  expand_null_return ();\n-\t  return;\n-\t}\n-\n+\treturn NULL_TREE;\n       /* We can't initialize a register from a AGGR_INIT_EXPR.  */\n       else if (! current_function_returns_struct\n \t       && TREE_CODE (retval) == TARGET_EXPR\n \t       && TREE_CODE (TREE_OPERAND (retval, 1)) == AGGR_INIT_EXPR)\n \tretval = build (COMPOUND_EXPR, TREE_TYPE (retval), retval,\n \t\t\tTREE_OPERAND (retval, 0));\n-\n-      /* Add some useful error checking for C++.  */\n-      else if (TREE_CODE (valtype) == REFERENCE_TYPE)\n-\t{\n-\t  tree whats_returned;\n-\n-\t  /* Sort through common things to see what it is\n-\t     we are returning.  */\n-\t  whats_returned = retval;\n-\t  if (TREE_CODE (whats_returned) == COMPOUND_EXPR)\n-\t    {\n-\t      whats_returned = TREE_OPERAND (whats_returned, 1);\n-\t      if (TREE_CODE (whats_returned) == ADDR_EXPR)\n-\t\twhats_returned = TREE_OPERAND (whats_returned, 0);\n-\t    }\n-\t  while (TREE_CODE (whats_returned) == CONVERT_EXPR\n-\t\t || TREE_CODE (whats_returned) == NOP_EXPR)\n-\t    whats_returned = TREE_OPERAND (whats_returned, 0);\n-\t  if (TREE_CODE (whats_returned) == ADDR_EXPR)\n-\t    {\n-\t      whats_returned = TREE_OPERAND (whats_returned, 0);\n-\t      while (TREE_CODE (whats_returned) == AGGR_INIT_EXPR\n-\t\t     || TREE_CODE (whats_returned) == TARGET_EXPR)\n-\t\t{\n-\t\t  /* Get the target.  */\n-\t\t  whats_returned = TREE_OPERAND (whats_returned, 0);\n-\t\t  warning (\"returning reference to temporary\");\n-\t\t}\n-\t    }\n-\n-\t  if (TREE_CODE (whats_returned) == VAR_DECL && DECL_NAME (whats_returned))\n-\t    {\n-\t      if (TEMP_NAME_P (DECL_NAME (whats_returned)))\n-\t\twarning (\"reference to non-lvalue returned\");\n-\t      else if (TREE_CODE (TREE_TYPE (whats_returned)) != REFERENCE_TYPE\n-\t\t       && DECL_FUNCTION_SCOPE_P (whats_returned)\n-\t\t       && !(TREE_STATIC (whats_returned)\n-\t\t\t    || TREE_PUBLIC (whats_returned)))\n-\t\tcp_warning_at (\"reference to local variable `%D' returned\", whats_returned);\n-\t    }\n-\t}\n-      else if (TREE_CODE (retval) == ADDR_EXPR)\n-\t{\n-\t  tree whats_returned = TREE_OPERAND (retval, 0);\n-\n-\t  if (TREE_CODE (whats_returned) == VAR_DECL\n-\t      && DECL_NAME (whats_returned)\n-\t      && DECL_FUNCTION_SCOPE_P (whats_returned)\n-\t      && !(TREE_STATIC (whats_returned)\n-\t\t   || TREE_PUBLIC (whats_returned)))\n-\t    cp_warning_at (\"address of local variable `%D' returned\", whats_returned);\n-\t}\n-    }\n-\n-  if (retval != NULL_TREE\n-      && TREE_CODE_CLASS (TREE_CODE (retval)) == 'd'\n-      && ! in_control_zone_p ())\n-    current_function_return_value = retval;\n-\n-  if (ctor_label && TREE_CODE (ctor_label) != ERROR_MARK)\n-    {\n-      /* Here RETVAL is CURRENT_CLASS_PTR, so there's nothing to do.  */\n-      expand_goto (ctor_label);\n+      else\n+\tmaybe_warn_about_returning_address_of_local (retval);\n     }\n-\n+  \n+  /* Actually copy the value returned into the appropriate location.  */\n   if (retval && retval != result)\n     {\n-      result = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n-      TREE_SIDE_EFFECTS (result) = 1;\n+      retval = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n+      TREE_SIDE_EFFECTS (retval) = 1;\n     }\n \n-  expand_start_target_temps ();\n+  /* All done.  Remember that this function did return a value.  */\n+  current_function_returns_value = 1;\n+  return retval;\n+}\n+\n+/* Expand a C `return' statement.\n+   RETVAL is the expression for what to return,\n+   or a null pointer for `return;' with no value.\n \n-  expand_return (result);\n+   C++: upon seeing a `return', we must call destructors on all\n+   variables in scope which had constructors called on them.\n+   This means that if in a destructor, the base class destructors\n+   must be called before returning.\n \n-  expand_end_target_temps ();\n+   The RETURN statement in C++ has initialization semantics.  */\n \n-  current_function_returns_value = 1;\n+void\n+c_expand_return (retval)\n+     tree retval;\n+{\n+  if (!retval)\n+    expand_null_return ();\n+  else\n+    {\n+      expand_start_target_temps ();\n+      expand_return (retval);\n+      expand_end_target_temps ();\n+    }\n }\n \f\n /* Start a C switch statement, testing expression EXP."}]}