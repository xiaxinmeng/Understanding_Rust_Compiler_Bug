{"sha": "ac677cc88956d8b2022022610eb79112136267f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2NzdjYzg4OTU2ZDhiMjAyMjAyMjYxMGViNzkxMTIxMzYyNjdmMw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2006-10-13T12:20:28Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2006-10-13T12:20:28Z"}, "message": "re PR fortran/29391 ([4.2/4.1 only] LBOUND and UBOUND are broken)\n\n\tPR fortran/29391\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Generate correct\n\tcode for LBOUND and UBOUND intrinsics.\n\n\t* gfortran.dg/bound_2.f90: New test.\n\nFrom-SVN: r117691", "tree": {"sha": "a00b370f5f0d08990592249b4a50b8741a935c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a00b370f5f0d08990592249b4a50b8741a935c76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac677cc88956d8b2022022610eb79112136267f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac677cc88956d8b2022022610eb79112136267f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac677cc88956d8b2022022610eb79112136267f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac677cc88956d8b2022022610eb79112136267f3/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec2061a9bfaf34fa44584beb2c440b2a15e6df10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2061a9bfaf34fa44584beb2c440b2a15e6df10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec2061a9bfaf34fa44584beb2c440b2a15e6df10"}], "stats": {"total": 196, "additions": 192, "deletions": 4}, "files": [{"sha": "9bf791b79fe11bbb27985cc82b434d8ace42acf3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac677cc88956d8b2022022610eb79112136267f3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac677cc88956d8b2022022610eb79112136267f3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ac677cc88956d8b2022022610eb79112136267f3", "patch": "@@ -1,3 +1,9 @@\n+2006-10-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/29391\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Generate correct\n+\tcode for LBOUND and UBOUND intrinsics.\n+\n 2006-10-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/21435"}, {"sha": "53c61c696d910db4b7470718d6b82bd866e40e09", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac677cc88956d8b2022022610eb79112136267f3/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac677cc88956d8b2022022610eb79112136267f3/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=ac677cc88956d8b2022022610eb79112136267f3", "patch": "@@ -710,9 +710,13 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   tree type;\n   tree bound;\n   tree tmp;\n-  tree cond;\n+  tree cond, cond1, cond2, cond3, size;\n+  tree ubound;\n+  tree lbound;\n   gfc_se argse;\n   gfc_ss *ss;\n+  gfc_array_spec * as;\n+  gfc_ref *ref;\n   int i;\n \n   arg = expr->value.function.actual;\n@@ -773,10 +777,111 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n         }\n     }\n \n-  if (upper)\n-    se->expr = gfc_conv_descriptor_ubound(desc, bound);\n+  ubound = gfc_conv_descriptor_ubound (desc, bound);\n+  lbound = gfc_conv_descriptor_lbound (desc, bound);\n+  \n+  /* Follow any component references.  */\n+  if (arg->expr->expr_type == EXPR_VARIABLE\n+      || arg->expr->expr_type == EXPR_CONSTANT)\n+    {\n+      as = arg->expr->symtree->n.sym->as;\n+      for (ref = arg->expr->ref; ref; ref = ref->next)\n+\t{\n+\t  switch (ref->type)\n+\t    {\n+\t    case REF_COMPONENT:\n+\t      as = ref->u.c.component->as;\n+\t      continue;\n+\n+\t    case REF_SUBSTRING:\n+\t      continue;\n+\n+\t    case REF_ARRAY:\n+\t      {\n+\t\tswitch (ref->u.ar.type)\n+\t\t  {\n+\t\t  case AR_ELEMENT:\n+\t\t  case AR_SECTION:\n+\t\t  case AR_UNKNOWN:\n+\t\t    as = NULL;\n+\t\t    continue;\n+\n+\t\t  case AR_FULL:\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    }\n+\t}\n+    }\n+  else\n+    as = NULL;\n+\n+  /* 13.14.53: Result value for LBOUND\n+\n+     Case (i): For an array section or for an array expression other than a\n+               whole array or array structure component, LBOUND(ARRAY, DIM)\n+               has the value 1.  For a whole array or array structure\n+               component, LBOUND(ARRAY, DIM) has the value:\n+                 (a) equal to the lower bound for subscript DIM of ARRAY if\n+                     dimension DIM of ARRAY does not have extent zero\n+                     or if ARRAY is an assumed-size array of rank DIM,\n+              or (b) 1 otherwise.\n+\n+     13.14.113: Result value for UBOUND\n+\n+     Case (i): For an array section or for an array expression other than a\n+               whole array or array structure component, UBOUND(ARRAY, DIM)\n+               has the value equal to the number of elements in the given\n+               dimension; otherwise, it has a value equal to the upper bound\n+               for subscript DIM of ARRAY if dimension DIM of ARRAY does\n+               not have size zero and has value zero if dimension DIM has\n+               size zero.  */\n+\n+  if (as)\n+    {\n+      tree stride = gfc_conv_descriptor_stride (desc, bound);\n+      cond1 = fold_build2 (GE_EXPR, boolean_type_node, ubound, lbound);\n+      cond2 = fold_build2 (LE_EXPR, boolean_type_node, ubound, lbound);\n+      cond3 = fold_build2 (GT_EXPR, boolean_type_node, stride,\n+\t\t\t   gfc_index_zero_node);\n+\n+      if (upper)\n+\t{\n+\t  cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond3, cond1);\n+\t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, cond2);\n+\n+\t  se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n+\t\t\t\t  ubound, gfc_index_zero_node);\n+\t}\n+      else\n+\t{\n+\t  if (as->type == AS_ASSUMED_SIZE)\n+\t    cond = fold_build2 (EQ_EXPR, boolean_type_node, bound,\n+\t\t\t\tbuild_int_cst (TREE_TYPE (bound),\n+\t\t\t\t\t       arg->expr->rank));\n+\t  else\n+\t    cond = boolean_false_node;\n+\n+\t  cond1 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond3, cond1);\n+\t  cond1 = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond1, cond2);\n+\n+\t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, cond1);\n+\n+\t  se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n+\t\t\t\t  lbound, gfc_index_one_node);\n+\t}\n+    }\n   else\n-    se->expr = gfc_conv_descriptor_lbound(desc, bound);\n+    {\n+      if (upper)\n+        {\n+\t  size = fold_build2 (MINUS_EXPR, gfc_array_index_type, ubound, lbound);\n+\t  se->expr = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n+\t\t\t\t  gfc_index_one_node);\n+\t}\n+      else\n+\tse->expr = gfc_index_one_node;\n+    }\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = convert (type, se->expr);"}, {"sha": "79424c2583c574626872e9c07710589e618fa7ae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac677cc88956d8b2022022610eb79112136267f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac677cc88956d8b2022022610eb79112136267f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac677cc88956d8b2022022610eb79112136267f3", "patch": "@@ -1,3 +1,8 @@\n+2006-10-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/29391\n+\t* gfortran.dg/bound_2.f90: New test.\n+\n 2006-10-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* gfortran.dg/defined_operators_1.f90: Add cleanup-modules dg"}, {"sha": "bd8cb4e87a445325399a16bafd40809ab288cb1f", "filename": "gcc/testsuite/gfortran.dg/bound_2.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac677cc88956d8b2022022610eb79112136267f3/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac677cc88956d8b2022022610eb79112136267f3/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_2.f90?ref=ac677cc88956d8b2022022610eb79112136267f3", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do run }\n+! PR fortran/29391\n+! This file is here to check that LBOUND and UBOUND return correct values\n+!\n+! Contributed by Francois-Xavier Coudert (coudert@clipper.ens.fr)\n+  implicit none\n+  integer :: i(-1:1,-1:1) = 0\n+  integer :: j(-1:2) = 0\n+\n+  if (any(lbound(i(-1:1,-1:1)) /= 1)) call abort\n+  if (any(ubound(i(-1:1,-1:1)) /= 3)) call abort\n+  if (any(lbound(i(:,:)) /= 1)) call abort\n+  if (any(ubound(i(:,:)) /= 3)) call abort\n+  if (any(lbound(i(0:,-1:)) /= 1)) call abort\n+  if (any(ubound(i(0:,-1:)) /= [2,3])) call abort\n+  if (any(lbound(i(:0,:0)) /= 1)) call abort\n+  if (any(ubound(i(:0,:0)) /= 2)) call abort\n+\n+  if (any(lbound(transpose(i)) /= 1)) call abort\n+  if (any(ubound(transpose(i)) /= 3)) call abort\n+  if (any(lbound(reshape(i,[2,2])) /= 1)) call abort\n+  if (any(ubound(reshape(i,[2,2])) /= 2)) call abort\n+  if (any(lbound(cshift(i,-1)) /= 1)) call abort\n+  if (any(ubound(cshift(i,-1)) /= 3)) call abort\n+  if (any(lbound(eoshift(i,-1)) /= 1)) call abort\n+  if (any(ubound(eoshift(i,-1)) /= 3)) call abort\n+  if (any(lbound(spread(i,1,2)) /= 1)) call abort\n+  if (any(ubound(spread(i,1,2)) /= [2,3,3])) call abort\n+  if (any(lbound(maxloc(i)) /= 1)) call abort\n+  if (any(ubound(maxloc(i)) /= 2)) call abort\n+  if (any(lbound(minloc(i)) /= 1)) call abort\n+  if (any(ubound(minloc(i)) /= 2)) call abort\n+  if (any(lbound(maxval(i,2)) /= 1)) call abort\n+  if (any(ubound(maxval(i,2)) /= 3)) call abort\n+  if (any(lbound(minval(i,2)) /= 1)) call abort\n+  if (any(ubound(minval(i,2)) /= 3)) call abort\n+  if (any(lbound(any(i==1,2)) /= 1)) call abort\n+  if (any(ubound(any(i==1,2)) /= 3)) call abort\n+  if (any(lbound(count(i==1,2)) /= 1)) call abort\n+  if (any(ubound(count(i==1,2)) /= 3)) call abort\n+  if (any(lbound(merge(i,i,.true.)) /= 1)) call abort\n+  if (any(ubound(merge(i,i,.true.)) /= 3)) call abort\n+  if (any(lbound(lbound(i)) /= 1)) call abort\n+  if (any(ubound(lbound(i)) /= 2)) call abort\n+  if (any(lbound(ubound(i)) /= 1)) call abort\n+  if (any(ubound(ubound(i)) /= 2)) call abort\n+  if (any(lbound(shape(i)) /= 1)) call abort\n+  if (any(ubound(shape(i)) /= 2)) call abort\n+\n+  if (any(lbound(product(i,2)) /= 1)) call abort\n+  if (any(ubound(product(i,2)) /= 3)) call abort\n+  if (any(lbound(sum(i,2)) /= 1)) call abort\n+  if (any(ubound(sum(i,2)) /= 3)) call abort\n+  if (any(lbound(matmul(i,i)) /= 1)) call abort\n+  if (any(ubound(matmul(i,i)) /= 3)) call abort\n+  if (any(lbound(pack(i,.true.)) /= 1)) call abort\n+  if (any(ubound(pack(i,.true.)) /= 9)) call abort\n+  if (any(lbound(unpack(j,[.true.],[2])) /= 1)) call abort\n+  if (any(ubound(unpack(j,[.true.],[2])) /= 1)) call abort\n+\n+  call sub1(i,3)\n+  call sub1(reshape([7,9,4,6,7,9],[3,2]),3)\n+\n+contains\n+\n+  subroutine sub1(a,n)\n+    integer :: a(2:n+1,4:*), n\n+    if (any([lbound(a,1), lbound(a,2)] /= [2, 4])) call abort\n+    if (any(lbound(a) /= [2, 4])) call abort\n+  end subroutine sub1\n+\n+end"}]}