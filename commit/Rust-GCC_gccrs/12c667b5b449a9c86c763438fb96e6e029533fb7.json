{"sha": "12c667b5b449a9c86c763438fb96e6e029533fb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjNjY3YjViNDQ5YTljODZjNzYzNDM4ZmI5NmU2ZTAyOTUzM2ZiNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-12-12T08:55:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-12-12T08:55:02Z"}, "message": "re PR tree-optimization/80631 (Compiling with -O3 -mavx2 gives wrong code)\n\n\tPR tree-optimization/80631\n\t* tree-vect-loop.c (get_initial_def_for_reduction): Fix comment typo.\n\t(vect_create_epilog_for_reduction): Add INDUC_VAL and INDUC_CODE\n\targuments, for INTEGER_INDUC_COND_REDUCTION use INDUC_VAL instead of\n\thardcoding zero as the value if COND_EXPR is never true.  For\n\tINTEGER_INDUC_COND_REDUCTION don't emit the final COND_EXPR if\n\tINDUC_VAL is equal to INITIAL_DEF, and use INDUC_CODE instead of\n\thardcoding MAX_EXPR as the reduction operation.\n\t(is_nonwrapping_integer_induction): Allow negative step.\n\t(vectorizable_reduction): Compute INDUC_VAL and INDUC_CODE for\n\tvect_create_epilog_for_reduction, if no value is suitable, don't\n\tuse INTEGER_INDUC_COND_REDUCTION for now.  Formatting fixes.\n\n\t* gcc.dg/vect/pr80631-1.c: New test.\n\t* gcc.dg/vect/pr80631-2.c: New test.\n\t* gcc.dg/vect/pr65947-13.c: Expect integer induc cond reduction\n\tvectorization.\n\nFrom-SVN: r255574", "tree": {"sha": "8fc6551cd16156c3e02209066ef1b2eaf1da2365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fc6551cd16156c3e02209066ef1b2eaf1da2365"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12c667b5b449a9c86c763438fb96e6e029533fb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c667b5b449a9c86c763438fb96e6e029533fb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c667b5b449a9c86c763438fb96e6e029533fb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c667b5b449a9c86c763438fb96e6e029533fb7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b0c69ae65b713ab68202af20dae9dca533d39cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0c69ae65b713ab68202af20dae9dca533d39cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0c69ae65b713ab68202af20dae9dca533d39cf"}], "stats": {"total": 319, "additions": 280, "deletions": 39}, "files": [{"sha": "1e26d7b9747d80d5eee91e9a4ec3b5874c0aad71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12c667b5b449a9c86c763438fb96e6e029533fb7", "patch": "@@ -1,3 +1,18 @@\n+2017-12-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/80631\n+\t* tree-vect-loop.c (get_initial_def_for_reduction): Fix comment typo.\n+\t(vect_create_epilog_for_reduction): Add INDUC_VAL and INDUC_CODE\n+\targuments, for INTEGER_INDUC_COND_REDUCTION use INDUC_VAL instead of\n+\thardcoding zero as the value if COND_EXPR is never true.  For\n+\tINTEGER_INDUC_COND_REDUCTION don't emit the final COND_EXPR if\n+\tINDUC_VAL is equal to INITIAL_DEF, and use INDUC_CODE instead of\n+\thardcoding MAX_EXPR as the reduction operation.\n+\t(is_nonwrapping_integer_induction): Allow negative step.\n+\t(vectorizable_reduction): Compute INDUC_VAL and INDUC_CODE for\n+\tvect_create_epilog_for_reduction, if no value is suitable, don't\n+\tuse INTEGER_INDUC_COND_REDUCTION for now.  Formatting fixes.\n+\n 2017-12-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/81889"}, {"sha": "fcb4c6d8323491a2aae42965610f631f1674e292", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=12c667b5b449a9c86c763438fb96e6e029533fb7", "patch": "@@ -1,3 +1,11 @@\n+2017-12-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/80631\n+\t* gcc.dg/vect/pr80631-1.c: New test.\n+\t* gcc.dg/vect/pr80631-2.c: New test.\n+\t* gcc.dg/vect/pr65947-13.c: Expect integer induc cond reduction\n+\tvectorization.\n+\n 2017-12-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/81889"}, {"sha": "ce290459c50943b1a62a1de8eaf0b2b44d6fe7fd", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-13.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c?ref=12c667b5b449a9c86c763438fb96e6e029533fb7", "patch": "@@ -6,8 +6,7 @@ extern void abort (void) __attribute__ ((noreturn));\n \n #define N 32\n \n-/* Simple condition reduction with a reversed loop.\n-   Will fail to vectorize to a simple case.  */\n+/* Simple condition reduction with a reversed loop.  */\n \n int\n condition_reduction (int *a, int min_v)\n@@ -42,4 +41,4 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" } } */"}, {"sha": "4af741d53075332d7fc37c50443c2923120c661b", "filename": "gcc/testsuite/gcc.dg/vect/pr80631-1.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-1.c?ref=12c667b5b449a9c86c763438fb96e6e029533fb7", "patch": "@@ -0,0 +1,76 @@\n+/* PR tree-optimization/80631 */\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+int v[8] = { 77, 1, 79, 3, 4, 3, 6, 7 };\n+\n+__attribute__((noipa)) void\n+f1 (void)\n+{\n+  int k, r = -1;\n+  for (k = 0; k < 8; k++)\n+    if (v[k] == 77)\n+      r = k;\n+  if (r != 0)\n+    abort ();\n+}\n+\n+__attribute__((noipa)) void\n+f2 (void)\n+{\n+  int k, r = 4;\n+  for (k = 0; k < 8; k++)\n+    if (v[k] == 79)\n+      r = k;\n+  if (r != 2)\n+    abort ();\n+}\n+\n+__attribute__((noipa)) void\n+f3 (void)\n+{\n+  int k, r = -17;\n+  for (k = 0; k < 8; k++)\n+    if (v[k] == 78)\n+      r = k;\n+  if (r != -17)\n+    abort ();\n+}\n+\n+__attribute__((noipa)) void\n+f4 (void)\n+{\n+  int k, r = 7;\n+  for (k = 0; k < 8; k++)\n+    if (v[k] == 78)\n+      r = k;\n+  if (r != 7)\n+    abort ();\n+}\n+\n+__attribute__((noipa)) void\n+f5 (void)\n+{\n+  int k, r = -1;\n+  for (k = 0; k < 8; k++)\n+    if (v[k] == 3)\n+      r = k;\n+  if (r != 5)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  f4 ();\n+  f5 ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 5 \"vect\" { target vect_condition } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 10 \"vect\" { target vect_condition } } } */"}, {"sha": "777738ad763cf4e3a5a6dee1ab240e61d96d4ca1", "filename": "gcc/testsuite/gcc.dg/vect/pr80631-2.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80631-2.c?ref=12c667b5b449a9c86c763438fb96e6e029533fb7", "patch": "@@ -0,0 +1,76 @@\n+/* PR tree-optimization/80631 */\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+int v[8] = { 77, 1, 79, 3, 4, 3, 6, 7 };\n+\n+__attribute__((noipa)) void\n+f1 (void)\n+{\n+  int k, r = -1;\n+  for (k = 7; k >= 0; k--)\n+    if (v[k] == 77)\n+      r = k;\n+  if (r != 0)\n+    abort ();\n+}\n+\n+__attribute__((noipa)) void\n+f2 (void)\n+{\n+  int k, r = 4;\n+  for (k = 7; k >= 0; k--)\n+    if (v[k] == 79)\n+      r = k;\n+  if (r != 2)\n+    abort ();\n+}\n+\n+__attribute__((noipa)) void\n+f3 (void)\n+{\n+  int k, r = -17;\n+  for (k = 7; k >= 0; k--)\n+    if (v[k] == 78)\n+      r = k;\n+  if (r != -17)\n+    abort ();\n+}\n+\n+__attribute__((noipa)) void\n+f4 (void)\n+{\n+  int k, r = 7;\n+  for (k = 7; k >= 0; k--)\n+    if (v[k] == 78)\n+      r = k;\n+  if (r != 7)\n+    abort ();\n+}\n+\n+__attribute__((noipa)) void\n+f5 (void)\n+{\n+  int k, r = -1;\n+  for (k = 7; k >= 0; k--)\n+    if (v[k] == 3)\n+      r = k;\n+  if (r != 3)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  f4 ();\n+  f5 ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 5 \"vect\" { target vect_condition } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 10 \"vect\" { target vect_condition } } } */"}, {"sha": "a66c8cfccad3c010aaa9be804a0ce4b7fb62ec8d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 103, "deletions": 36, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12c667b5b449a9c86c763438fb96e6e029533fb7/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=12c667b5b449a9c86c763438fb96e6e029533fb7", "patch": "@@ -4034,7 +4034,7 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n     case MULT_EXPR:\n     case BIT_AND_EXPR:\n       {\n-        /* ADJUSMENT_DEF is NULL when called from\n+        /* ADJUSTMENT_DEF is NULL when called from\n            vect_create_epilog_for_reduction to vectorize double reduction.  */\n         if (adjustment_def)\n \t  *adjustment_def = init_val;\n@@ -4283,6 +4283,11 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n    DOUBLE_REDUC is TRUE if double reduction phi nodes should be handled.\n    SLP_NODE is an SLP node containing a group of reduction statements. The \n      first one in this group is STMT.\n+   INDUC_VAL is for INTEGER_INDUC_COND_REDUCTION the value to use for the case\n+     when the COND_EXPR is never true in the loop.  For MAX_EXPR, it needs to\n+     be smaller than any value of the IV in the loop, for MIN_EXPR larger than\n+     any value of the IV in the loop.\n+   INDUC_CODE is the code for epilog reduction if INTEGER_INDUC_COND_REDUCTION.\n \n    This function:\n    1. Creates the reduction def-use cycles: sets the arguments for \n@@ -4330,7 +4335,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t\t\t\t  vec<gimple *> reduction_phis,\n                                   bool double_reduc, \n \t\t\t\t  slp_tree slp_node,\n-\t\t\t\t  slp_instance slp_node_instance)\n+\t\t\t\t  slp_instance slp_node_instance,\n+\t\t\t\t  tree induc_val, enum tree_code induc_code)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_phi_info;\n@@ -4419,6 +4425,18 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       gimple *def_stmt;\n       initial_def = PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n \t\t\t\t\t   loop_preheader_edge (loop));\n+      /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n+\t and we can't use zero for induc_val, use initial_def.  Similarly\n+\t for REDUC_MIN and initial_def larger than the base.  */\n+      if (TREE_CODE (initial_def) == INTEGER_CST\n+\t  && (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t      == INTEGER_INDUC_COND_REDUCTION)\n+\t  && !integer_zerop (induc_val)\n+\t  && ((reduc_fn == IFN_REDUC_MAX\n+\t       && tree_int_cst_lt (initial_def, induc_val))\n+\t      || (reduc_fn == IFN_REDUC_MIN\n+\t\t  && tree_int_cst_lt (induc_val, initial_def))))\n+\tinduc_val = initial_def;\n       vect_is_simple_use (initial_def, loop_vinfo, &def_stmt, &initial_def_dt);\n       vec_initial_def = get_initial_def_for_reduction (stmt, initial_def,\n \t\t\t\t\t\t       &adjustment_def);\n@@ -4453,9 +4471,10 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t      gcc_assert (i == 0);\n \n \t      tree vec_init_def_type = TREE_TYPE (vec_init_def);\n-\t      tree zero_vec = build_zero_cst (vec_init_def_type);\n+\t      tree induc_val_vec\n+\t\t= build_vector_from_val (vec_init_def_type, induc_val);\n \n-\t      add_phi_arg (as_a <gphi *> (phi), zero_vec,\n+\t      add_phi_arg (as_a <gphi *> (phi), induc_val_vec,\n \t\t\t   loop_preheader_edge (loop), UNKNOWN_LOCATION);\n \t    }\n \t  else\n@@ -4983,14 +5002,16 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       gimple_set_lhs (epilog_stmt, new_temp);\n       gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n \n-      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t  == INTEGER_INDUC_COND_REDUCTION)\n+      if ((STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t   == INTEGER_INDUC_COND_REDUCTION)\n+\t  && !operand_equal_p (initial_def, induc_val, 0))\n \t{\n-\t  /* Earlier we set the initial value to be zero.  Check the result\n-\t     and if it is zero then replace with the original initial\n-\t     value.  */\n-\t  tree zero = build_zero_cst (scalar_type);\n-\t  tree zcompare = build2 (EQ_EXPR, boolean_type_node, new_temp, zero);\n+\t  /* Earlier we set the initial value to be a vector if induc_val\n+\t     values.  Check the result and if it is induc_val then replace\n+\t     with the original initial value, unless induc_val is\n+\t     the same as initial_def already.  */\n+\t  tree zcompare = build2 (EQ_EXPR, boolean_type_node, new_temp,\n+\t\t\t\t  induc_val);\n \n \t  tmp = make_ssa_name (new_scalar_dest);\n \t  epilog_stmt = gimple_build_assign (tmp, COND_EXPR, zcompare,\n@@ -5008,9 +5029,16 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n       tree vec_temp;\n \n-      /* COND reductions all do the final reduction with MAX_EXPR.  */\n+      /* COND reductions all do the final reduction with MAX_EXPR\n+\t or MIN_EXPR.  */\n       if (code == COND_EXPR)\n-\tcode = MAX_EXPR;\n+\t{\n+\t  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t      == INTEGER_INDUC_COND_REDUCTION)\n+\t    code = induc_code;\n+\t  else\n+\t    code = MAX_EXPR;\n+\t}\n \n       /* Regardless of whether we have a whole vector shift, if we're\n          emulating the operation via tree-vect-generic, we don't want\n@@ -5110,7 +5138,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n               else\n                 vec_temp = gimple_assign_lhs (new_phi);\n               tree rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n-                            bitsize_zero_node);\n+\t\t\t\t bitsize_zero_node);\n               epilog_stmt = gimple_build_assign (new_scalar_dest, rhs);\n               new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n               gimple_assign_set_lhs (epilog_stmt, new_temp);\n@@ -5179,14 +5207,16 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n             scalar_results.safe_push (new_temp);\n         }\n \n-      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t  == INTEGER_INDUC_COND_REDUCTION)\n+      if ((STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t   == INTEGER_INDUC_COND_REDUCTION)\n+\t  && !operand_equal_p (initial_def, induc_val, 0))\n \t{\n-\t  /* Earlier we set the initial value to be zero.  Check the result\n-\t     and if it is zero then replace with the original initial\n-\t     value.  */\n-\t  tree zero = build_zero_cst (scalar_type);\n-\t  tree zcompare = build2 (EQ_EXPR, boolean_type_node, new_temp, zero);\n+\t  /* Earlier we set the initial value to be a vector if induc_val\n+\t     values.  Check the result and if it is induc_val then replace\n+\t     with the original initial value, unless induc_val is\n+\t     the same as initial_def already.  */\n+\t  tree zcompare = build2 (EQ_EXPR, boolean_type_node, new_temp,\n+\t\t\t\t  induc_val);\n \n \t  tree tmp = make_ssa_name (new_scalar_dest);\n \t  epilog_stmt = gimple_build_assign (tmp, COND_EXPR, zcompare,\n@@ -5513,10 +5543,6 @@ is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n       || TREE_CODE (step) != INTEGER_CST)\n     return false;\n \n-  /* Check that the induction increments.  */\n-  if (tree_int_cst_sgn (step) == -1)\n-    return false;\n-\n   /* Check that the max size of the loop will not wrap.  */\n \n   if (TYPE_OVERFLOW_UNDEFINED (lhs_type))\n@@ -5608,6 +5634,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree new_temp = NULL_TREE;\n   gimple *def_stmt;\n   enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n+  gimple *cond_reduc_def_stmt = NULL;\n+  enum tree_code cond_reduc_op_code = ERROR_MARK;\n   tree scalar_type;\n   bool is_simple_use;\n   gimple *orig_stmt;\n@@ -5879,9 +5907,13 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      cond_reduc_dt = dt;\n \t      cond_reduc_val = ops[i];\n \t    }\n-\t  if (dt == vect_induction_def && def_stmt != NULL\n+\t  if (dt == vect_induction_def\n+\t      && def_stmt != NULL\n \t      && is_nonwrapping_integer_induction (def_stmt, loop))\n-\t    cond_reduc_dt = dt;\n+\t    {\n+\t      cond_reduc_dt = dt;\n+\t      cond_reduc_def_stmt = def_stmt;\n+\t    }\n \t}\n     }\n \n@@ -5928,12 +5960,46 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       if (cond_reduc_dt == vect_induction_def)\n \t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"condition expression based on \"\n-\t\t\t     \"integer induction.\\n\");\n-\t  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t    = INTEGER_INDUC_COND_REDUCTION;\n+\t  stmt_vec_info cond_stmt_vinfo = vinfo_for_stmt (cond_reduc_def_stmt);\n+\t  tree base\n+\t    = STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED (cond_stmt_vinfo);\n+\t  tree step = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (cond_stmt_vinfo);\n+\n+\t  gcc_assert (TREE_CODE (base) == INTEGER_CST\n+\t\t      && TREE_CODE (step) == INTEGER_CST);\n+\t  cond_reduc_val = NULL_TREE;\n+\t  /* Find a suitable value, for MAX_EXPR below base, for MIN_EXPR\n+\t     above base; punt if base is the minimum value of the type for\n+\t     MAX_EXPR or maximum value of the type for MIN_EXPR for now.  */\n+\t  if (tree_int_cst_sgn (step) == -1)\n+\t    {\n+\t      cond_reduc_op_code = MIN_EXPR;\n+\t      if (tree_int_cst_sgn (base) == -1)\n+\t\tcond_reduc_val = build_int_cst (TREE_TYPE (base), 0);\n+\t      else if (tree_int_cst_lt (base,\n+\t\t\t\t\tTYPE_MAX_VALUE (TREE_TYPE (base))))\n+\t\tcond_reduc_val\n+\t\t  = int_const_binop (PLUS_EXPR, base, integer_one_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      cond_reduc_op_code = MAX_EXPR;\n+\t      if (tree_int_cst_sgn (base) == 1)\n+\t\tcond_reduc_val = build_int_cst (TREE_TYPE (base), 0);\n+\t      else if (tree_int_cst_lt (TYPE_MIN_VALUE (TREE_TYPE (base)),\n+\t\t\t\t\tbase))\n+\t\tcond_reduc_val\n+\t\t  = int_const_binop (MINUS_EXPR, base, integer_one_node);\n+\t    }\n+\t  if (cond_reduc_val)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"condition expression based on \"\n+\t\t\t\t \"integer induction.\\n\");\n+\t      STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t\t= INTEGER_INDUC_COND_REDUCTION;\n+\t    }\n \t}\n \n       /* Loop peeling modifies initial value of reduction PHI, which\n@@ -6127,8 +6193,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  gcc_assert (orig_code == MAX_EXPR || orig_code == MIN_EXPR);\n \t}\n       else if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t\t == INTEGER_INDUC_COND_REDUCTION)\n-\torig_code = MAX_EXPR;\n+\t       == INTEGER_INDUC_COND_REDUCTION)\n+\torig_code = cond_reduc_op_code;\n     }\n \n   if (nested_cycle)\n@@ -6464,7 +6530,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   vect_create_epilog_for_reduction (vect_defs, stmt, reduc_def_stmt,\n \t\t\t\t    epilog_copies, reduc_fn, phis,\n-\t\t\t\t    double_reduc, slp_node, slp_node_instance);\n+\t\t\t\t    double_reduc, slp_node, slp_node_instance,\n+\t\t\t\t    cond_reduc_val, cond_reduc_op_code);\n \n   return true;\n }"}]}