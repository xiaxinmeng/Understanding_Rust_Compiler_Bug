{"sha": "e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkyZmI1MDExNDcwNmRkNjBmYzQzY2NlYzQ4OGE3YWM5OWI1ZmE5Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-05-25T20:18:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-05-25T20:18:26Z"}, "message": "re PR c++/20103 (ICE in create_tmp_var with C99 style struct initializer)\n\n\tPR c++/20103\n\t* gimplify.c (gimplify_decl_expr): Do not call gimple_add_tmp_var\n\tfor anonymous variables explicitly declared by front ends. \n\n\tPR c++/20103\n\t* decl.c (cp_make_fname_decl): Don't set DECL_INITIAL to\n\terror_mark_node to indicate an initialization is OK.\n\t(start_decl): Likewise.  Adjust call to start_decl_1.\n\t(start_decl_1): Add initialized parameter.  Simplify.\n\t* except.c (initialize_handler_parm): Adjust call to\n\tsetart_decl_1.\n\t(expand_start_catch_block): Let cp_finish_decl initialize catch\n\tparameters.\n\t* cp-tree.h (start_decl_1): Adjust prototype.\n\t* pt.c (tsubst_expr): Don't set DECL_INITIAL to error_mark_node.\n\t(instantiate_decl): Let cp_finish_decl handle initialization.\n\t* semantics.c (finish_compound_literal): Create a temporary\n\tvariable for the literal.\n\t* typeck.c (build_unary_op): Remove COMPOUND_LITERAL_P special\n\tcases.\n\t* decl2.c (finish_static_data_member_decl): Don't set\n\tDECL_INITIAL.\n\t(grokfield): Do not try to initialize functions.\n\n\tPR c++/20103\n\t* g++.dg/ext/complit6.C: New test.\n\t* g++.dg/ext/complit3.C: Adjust error markers.\n\t* g++.dg/init/const3.C: New test.\n\nFrom-SVN: r114119", "tree": {"sha": "622ad082d8859f1f7dcb1eac879fee90193bb6e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/622ad082d8859f1f7dcb1eac879fee90193bb6e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/comments", "author": null, "committer": null, "parents": [{"sha": "05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05a58ad48d4bad7dff39cc2c2b5263bbb89cab38"}], "stats": {"total": 242, "additions": 137, "deletions": 105}, "files": [{"sha": "4e271ed8073659653aa05f4e9e70f07711b886df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -1,3 +1,9 @@\n+2006-05-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/20103\n+\t* gimplify.c (gimplify_decl_expr): Do not call gimple_add_tmp_var\n+\tfor anonymous variables explicitly declared by front ends. \n+\n 2006-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-ssa-structalias.h (PTR_IS_REF_ALL): New macro."}, {"sha": "45d25bb1f73ad3b94ccfc8b9c21506245e59b637", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -1,3 +1,25 @@\n+2006-05-24  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/20103\n+\t* decl.c (cp_make_fname_decl): Don't set DECL_INITIAL to\n+\terror_mark_node to indicate an initialization is OK.\n+\t(start_decl): Likewise.  Adjust call to start_decl_1.\n+\t(start_decl_1): Add initialized parameter.  Simplify.\n+\t* except.c (initialize_handler_parm): Adjust call to\n+\tsetart_decl_1.\n+\t(expand_start_catch_block): Let cp_finish_decl initialize catch\n+\tparameters.\n+\t* cp-tree.h (start_decl_1): Adjust prototype.\n+\t* pt.c (tsubst_expr): Don't set DECL_INITIAL to error_mark_node.\n+\t(instantiate_decl): Let cp_finish_decl handle initialization.\n+\t* semantics.c (finish_compound_literal): Create a temporary\n+\tvariable for the literal.\n+\t* typeck.c (build_unary_op): Remove COMPOUND_LITERAL_P special\n+\tcases.\n+\t* decl2.c (finish_static_data_member_decl): Don't set\n+\tDECL_INITIAL.\n+\t(grokfield): Do not try to initialize functions.\n+\n 2006-05-23  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/20173"}, {"sha": "486a90da1eb8803e8301e3605d30393b3be15615", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -3835,7 +3835,7 @@ extern tree check_tag_decl\t\t\t(cp_decl_specifier_seq *);\n extern tree shadow_tag\t\t\t\t(cp_decl_specifier_seq *);\n extern tree groktypename\t\t\t(cp_decl_specifier_seq *, const cp_declarator *);\n extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree, tree *);\n-extern void start_decl_1\t\t\t(tree);\n+extern void start_decl_1\t\t\t(tree, bool);\n extern void cp_finish_decl\t\t\t(tree, tree, bool, tree, int);\n extern void finish_decl\t\t\t\t(tree, tree, tree);\n extern int cp_complete_array_type\t\t(tree *, tree, bool);"}, {"sha": "fef09edb6945e0addac8d950cadb273d22c2dc45", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -3311,7 +3311,6 @@ cp_make_fname_decl (tree id, int type_dep)\n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n-  DECL_INITIAL (decl) = init;\n \n   TREE_USED (decl) = 1;\n \n@@ -3848,11 +3847,6 @@ start_decl (const cp_declarator *declarator,\n       DECL_EXTERNAL (decl) = 0;\n       if (toplevel_bindings_p ())\n \tTREE_STATIC (decl) = 1;\n-\n-      /* Tell `pushdecl' this is an initialized decl\n-\t even though we don't yet have the initializer expression.\n-\t Also tell `cp_finish_decl' it may store the real initializer.  */\n-      DECL_INITIAL (decl) = error_mark_node;\n     }\n \n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n@@ -3895,8 +3889,7 @@ start_decl (const cp_declarator *declarator,\n \t\t declaration will have DECL_EXTERNAL set, but will have an\n \t\t initialization.  Thus, duplicate_decls won't warn\n \t\t about this situation, and so we check here.  */\n-\t      if (DECL_INITIAL (decl) \n-\t\t  && DECL_INITIALIZED_IN_CLASS_P (field))\n+\t      if (initialized && DECL_INITIALIZED_IN_CLASS_P (field))\n \t\terror (\"duplicate initialization of %qD\", decl);\n \t      if (duplicate_decls (decl, field, /*newdecl_is_friend=*/false))\n \t\tdecl = field;\n@@ -3930,8 +3923,7 @@ start_decl (const cp_declarator *declarator,\n \n \t     We check for processing_specialization so this only applies\n \t     to the new specialization syntax.  */\n-\t  if (!DECL_INITIAL (decl)\n-\t      && processing_specialization)\n+\t  if (!initialized && processing_specialization)\n \t    DECL_EXTERNAL (decl) = 1;\n \t}\n \n@@ -3960,21 +3952,25 @@ start_decl (const cp_declarator *declarator,\n       && !have_global_bss_p ())\n     DECL_COMMON (tem) = 1;\n \n-  if (! processing_template_decl)\n-    start_decl_1 (tem);\n+  if (!processing_template_decl && TREE_CODE (tem) == VAR_DECL)\n+    start_decl_1 (tem, initialized);\n \n   return tem;\n }\n \n void\n-start_decl_1 (tree decl)\n+start_decl_1 (tree decl, bool initialized)\n {\n-  tree type = TREE_TYPE (decl);\n-  int initialized = (DECL_INITIAL (decl) != NULL_TREE);\n+  tree type;\n \n-  if (type == error_mark_node)\n+  gcc_assert (!processing_template_decl);\n+\n+  if (error_operand_p (decl))\n     return;\n \n+  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  type = TREE_TYPE (decl);\n+\n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n        If not, set INITIALIZED to zero, which will indirectly\n@@ -3998,16 +3994,10 @@ start_decl_1 (tree decl)\n \t  initialized = 0;\n \t}\n     }\n-\n-  if (!initialized\n-      && TREE_CODE (decl) != TYPE_DECL\n-      && TREE_CODE (decl) != TEMPLATE_DECL\n-      && type != error_mark_node\n-      && IS_AGGR_TYPE (type)\n-      && ! DECL_EXTERNAL (decl))\n+  else if (IS_AGGR_TYPE (type)\n+\t   && ! DECL_EXTERNAL (decl))\n     {\n-      if ((! processing_template_decl || ! uses_template_parms (type))\n-\t  && !COMPLETE_TYPE_P (complete_type (type)))\n+      if (!COMPLETE_TYPE_P (complete_type (type)))\n \t{\n \t  error (\"aggregate %q#D has incomplete type and cannot be defined\",\n \t\t decl);\n@@ -4027,9 +4017,6 @@ start_decl_1 (tree decl)\n \t}\n     }\n \n-  if (! initialized)\n-    DECL_INITIAL (decl) = NULL_TREE;\n-\n   /* Create a new scope to hold this declaration if necessary.\n      Whether or not a new scope is necessary cannot be determined\n      until after the type has been completed; if the type is a\n@@ -4665,16 +4652,6 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n   tree type = TREE_TYPE (decl);\n   tree init_code = NULL;\n \n-  /* If `start_decl' didn't like having an initialization, ignore it now.  */\n-  if (init != NULL_TREE && DECL_INITIAL (decl) == NULL_TREE)\n-    init = NULL_TREE;\n-\n-  /* If an initializer is present, DECL_INITIAL has been\n-     error_mark_node, to indicate that an as-of-yet unevaluated\n-     initialization will occur.  From now on, DECL_INITIAL reflects\n-     the static initialization -- if any -- of DECL.  */\n-  DECL_INITIAL (decl) = NULL_TREE;\n-\n   /* Things that are going to be initialized need to have complete\n      type.  */\n   TREE_TYPE (decl) = type = complete_type (TREE_TYPE (decl));\n@@ -5040,7 +5017,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n       if (at_function_scope_p ())\n \tadd_decl_expr (decl);\n \n-      if (init && DECL_INITIAL (decl))\n+      if (init)\n \t{\n \t  DECL_INITIAL (decl) = init;\n \t  if (init_const_expr_p)\n@@ -5227,10 +5204,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t    {\n \t      /* Initialize the local variable.  */\n \t      if (processing_template_decl)\n-\t\t{\n-\t\t  if (init || DECL_INITIAL (decl) == error_mark_node)\n-\t\t    DECL_INITIAL (decl) = init;\n-\t\t}\n+\t\tDECL_INITIAL (decl) = init;\n \t      else if (!TREE_STATIC (decl))\n \t\tinitialize_local_var (decl, init);\n \t    }"}, {"sha": "c0bea8c3dad3bd2bdeb57960b6a49dd6d62f6ba5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -720,9 +720,6 @@ finish_static_data_member_decl (tree decl,\n   /* We cannot call pushdecl here, because that would fill in the\n      TREE_CHAIN of our decl.  Instead, we modify cp_finish_decl to do\n      the right thing, namely, to put this decl out straight away.  */\n-  /* current_class_type can be NULL_TREE in case of error.  */\n-  if (!asmspec_tree && current_class_type)\n-    DECL_INITIAL (decl) = error_mark_node;\n \n   if (! processing_template_decl)\n     note_vague_linkage_var (decl);\n@@ -920,7 +917,9 @@ grokfield (const cp_declarator *declarator,\n       if (asmspec)\n \tset_user_assembler_name (value, asmspec);\n \n-      cp_finish_decl (value, init, /*init_const_expr_p=*/false, \n+      cp_finish_decl (value, \n+\t\t      /*init=*/NULL_TREE, \n+\t\t      /*init_const_expr_p=*/false, \n \t\t      asmspec_tree, flags);\n \n       /* Pass friends back this way.  */"}, {"sha": "427591044002edf054972f632d2248af3c2ea1e1", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -392,11 +392,9 @@ initialize_handler_parm (tree decl, tree exp)\n       init = build1 (MUST_NOT_THROW_EXPR, TREE_TYPE (init), init);\n     }\n \n-  /* Let `cp_finish_decl' know that this initializer is ok.  */\n-  DECL_INITIAL (decl) = error_mark_node;\n   decl = pushdecl (decl);\n \n-  start_decl_1 (decl);\n+  start_decl_1 (decl, true);\n   cp_finish_decl (decl, init, /*init_const_expr_p=*/false, NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n }\n@@ -464,7 +462,6 @@ expand_start_catch_block (tree decl)\n       DECL_REGISTER (exp) = 1;\n       cp_finish_decl (exp, init, /*init_const_expr=*/false, \n \t\t      NULL_TREE, LOOKUP_ONLYCONVERTING);\n-      finish_expr_stmt (build_modify_expr (exp, INIT_EXPR, init));\n       initialize_handler_parm (decl, exp);\n     }\n "}, {"sha": "4b8232e9a9b61b4bcae21dccad27173f2b550515", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -8266,8 +8266,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    decl = tsubst (decl, args, complain, in_decl);\n \t    if (decl != error_mark_node)\n \t      {\n-\t\tif (init)\n-\t\t  DECL_INITIAL (decl) = error_mark_node;\n \t\t/* By marking the declaration as instantiated, we avoid\n \t\t   trying to instantiate it.  Since instantiate_decl can't\n \t\t   handle local variables, and since we've already done\n@@ -11850,7 +11848,6 @@ instantiate_decl (tree d, int defer_ok,\n \t  init = tsubst_expr (DECL_INITIAL (code_pattern), \n \t\t\t      args,\n \t\t\t      tf_warning_or_error, NULL_TREE);\n-\t  DECL_INITIAL (d) = init;\n \t  cp_finish_decl (d, init, /*init_const_expr_p=*/false,\n \t\t\t  /*asmspec_tree=*/NULL_TREE,\n \t\t\t  LOOKUP_ONLYCONVERTING);\n@@ -11917,19 +11914,28 @@ instantiate_decl (tree d, int defer_ok,\n \n   if (TREE_CODE (d) == VAR_DECL)\n     {\n+      tree init;\n+\n       /* Clear out DECL_RTL; whatever was there before may not be right\n \t since we've reset the type of the declaration.  */\n       SET_DECL_RTL (d, NULL_RTX);\n       DECL_IN_AGGR_P (d) = 0;\n \n+      /* The initializer is placed in DECL_INITIAL by\n+\t regenerate_decl_from_template.  Pull it out so that\n+\t finish_decl can process it.  */\n+      init = DECL_INITIAL (d);\n+      DECL_INITIAL (d) = NULL_TREE;\n+      DECL_INITIALIZED_P (d) = 0;\n+\n       /* Clear DECL_EXTERNAL so that cp_finish_decl will process the\n \t initializer.  That function will defer actual emission until\n \t we have a chance to determine linkage.  */\n       DECL_EXTERNAL (d) = 0;\n \n       /* Enter the scope of D so that access-checking works correctly.  */\n       push_nested_class (DECL_CONTEXT (d));\n-      finish_decl (d, DECL_INITIAL (d), NULL_TREE);\n+      finish_decl (d, init, NULL_TREE);\n       pop_nested_class ();\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)"}, {"sha": "976005c7b9e0f4b048f66c84658f2a2dd9cac2ca", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -1089,7 +1089,6 @@ finish_handler_parms (tree decl, tree handler)\n     }\n   else\n     type = expand_start_catch_block (decl);\n-\n   HANDLER_TYPE (handler) = type;\n   if (!processing_template_decl && type)\n     mark_used (eh_type_info (type));\n@@ -2019,33 +2018,43 @@ finish_unary_op_expr (enum tree_code code, tree expr)\n tree\n finish_compound_literal (tree type, VEC(constructor_elt,gc) *initializer_list)\n {\n+  tree var;\n   tree compound_literal;\n \n   /* Build a CONSTRUCTOR for the INITIALIZER_LIST.  */\n   compound_literal = build_constructor (NULL_TREE, initializer_list);\n   if (processing_template_decl)\n-    TREE_TYPE (compound_literal) = type;\n-  else\n     {\n-      /* Check the initialization.  */\n-      compound_literal = reshape_init (type, compound_literal);\n-      compound_literal = digest_init (type, compound_literal);\n-      /* If the TYPE was an array type with an unknown bound, then we can\n-\t figure out the dimension now.  For example, something like:\n-\n-\t   `(int []) { 2, 3 }'\n-\n-\t implies that the array has two elements.  */\n-      if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n-\tcp_complete_array_type (&TREE_TYPE (compound_literal),\n-\t\t\t\tcompound_literal, 1);\n-    }\n-\n-  /* Mark it as a compound-literal.  */\n-  if (TREE_CODE (compound_literal) == CONSTRUCTOR)\n-    TREE_HAS_CONSTRUCTOR (compound_literal) = 1;\n-\n-  return compound_literal;\n+      TREE_TYPE (compound_literal) = type;\n+      /* Mark the expression as a compound literal.  */\n+      TREE_HAS_CONSTRUCTOR (compound_literal) = 1;\n+      return compound_literal;\n+    }\n+\n+  /* Create a temporary variable to represent the compound literal.  */\n+  var = create_temporary_var (type);\n+  if (!current_function_decl)\n+    {\n+      /* If this compound-literal appears outside of a function, then\n+\t the corresponding variable has static storage duration, just\n+\t like the variable in whose initializer it appears.  */  \n+      TREE_STATIC (var) = 1;\n+      /* The variable has internal linkage, since there is no need to\n+\t reference it from another translation unit.  */\n+      TREE_PUBLIC (var) = 0;\n+      /* It must have a name, so that the name mangler can mangle it.  */\n+      DECL_NAME (var) = make_anon_name ();\n+    }\n+  /* We must call pushdecl, since the gimplifier complains if the\n+     variable hase been declared via a BIND_EXPR.  */\n+  pushdecl (var);\n+  /* Initialize the variable as we would any other variable with a\n+     brace-enclosed initializer.  */\n+  cp_finish_decl (var, compound_literal, \n+\t\t  /*init_const_expr_p=*/false,\n+\t\t  /*asmspec_tree=*/NULL_TREE,\n+\t\t  LOOKUP_ONLYCONVERTING);\n+  return var;\n }\n \n /* Return the declaration for the function-name variable indicated by"}, {"sha": "975bfd3e0555e32cee51404f5516f003e484a1f3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -4324,9 +4324,6 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n       if (TREE_CODE (argtype) != FUNCTION_TYPE\n \t  && TREE_CODE (argtype) != METHOD_TYPE\n \t  && TREE_CODE (arg) != OFFSET_REF\n-\t  /* Permit users to take the address of a compound-literal\n-\t     with sufficient simple elements.  */\n-\t  && !(COMPOUND_LITERAL_P (arg) && TREE_STATIC (arg))\n \t  && !lvalue_or_else (arg, lv_addressof))\n \treturn error_mark_node;\n \n@@ -4343,24 +4340,6 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  return val;\n \t}\n \n-      /* If the user has taken the address of the compound literal,\n-\t create a variable to contain the value of the literal and\n-\t then return the address of that variable.  */\n-      if (COMPOUND_LITERAL_P (arg))\n-\t{\n-\t  tree var;\n-\t  gcc_assert (TREE_STATIC (arg));\n-\t  var = create_temporary_var (TREE_TYPE (arg));\n-\t  TREE_STATIC (var) = 1;\n-\t  set_compound_literal_name (var); \n-\t  initialize_artificial_var (var, arg);\n-\t  arg = pushdecl (var);\n-\t  /* Since each compound literal is unique, pushdecl should\n-\t     never find a pre-existing variable with the same\n-\t     name.  */\n-\t  gcc_assert (arg == var);\n-\t}\n-      \n       if (TREE_CODE (arg) != COMPONENT_REF)\n \t{\n \t  val = build_address (arg);"}, {"sha": "fe18bc19234073b86e72987804326018237c2f13", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -1216,10 +1216,12 @@ gimplify_decl_expr (tree *stmt_p)\n \t    walk_tree (&init, force_labels_r, NULL, NULL);\n \t}\n \n-      /* This decl isn't mentioned in the enclosing block, so add it to the\n-\t list of temps.  FIXME it seems a bit of a kludge to say that\n-\t anonymous artificial vars aren't pushed, but everything else is.  */\n-      if (DECL_ARTIFICIAL (decl) && DECL_NAME (decl) == NULL_TREE)\n+      /* Some front ends do not explicitly declare all anonymous\n+\t artificial variables.  We compensate here by declaring the\n+\t variables, though it would be better if the front ends would\n+\t explicitly declare them.  */\n+      if (!DECL_SEEN_IN_BIND_EXPR_P (decl)\n+\t  && DECL_ARTIFICIAL (decl) && DECL_NAME (decl) == NULL_TREE)\n \tgimple_add_tmp_var (decl);\n     }\n "}, {"sha": "78fa87aba49d1e4f7038793ec666d4dd443f25fd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -1,3 +1,10 @@\n+2006-05-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/20103\n+\t* g++.dg/ext/complit6.C: New test.\n+\t* g++.dg/ext/complit3.C: Adjust error markers.\n+\t* g++.dg/init/const3.C: New test. \t\n+\n 2006-05-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/27743"}, {"sha": "a54a8bce1f9ee65cb9d21786f06a4dc9fbbed16a", "filename": "gcc/testsuite/g++.dg/ext/complit3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit3.C?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -2,7 +2,7 @@\n \n int Compound_Literals_0()\n {\n-  static int y[] = (int []) {1, 2, 3}; // { dg-error \"compound literal\" }\n-  static int z[] = (int [3]) {1}; // { dg-error \"compound literal\" }\n+  static int y[] = (int []) {1, 2, 3}; // { dg-error \"init\" }\n+  static int z[] = (int [3]) {1}; // { dg-error \"init\" }\n   return y[0]+z[0]; \n }"}, {"sha": "d3187a65b2dd0d2ed2fb36f37c8dd80703a4ef39", "filename": "gcc/testsuite/g++.dg/ext/complit6.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit6.C?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/20103\n+// { dg-options \"\" }\n+\n+struct A\n+{\n+  A(const A&);\n+};\n+\n+struct B\n+{\n+  A a;\n+};\n+\n+void foo(B);\n+\n+void bar(A &x)\n+{\n+  foo((B){x});\n+}"}, {"sha": "96cb6f9094f3de397a1ccb9ea48f95a1d7ec7d5f", "filename": "gcc/testsuite/g++.dg/init/const3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92fb50114706dd60fc43ccec488a7ac99b5fa9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst3.C?ref=e92fb50114706dd60fc43ccec488a7ac99b5fa9b", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do run }\n+\n+struct S {\n+  static const int i = 3;\n+};\n+\n+const int S::i;\n+\n+int main () {\n+  if (!S::i)\n+    return 1;\n+}"}]}