{"sha": "d2694766dcfff0278fa93d581340a10b150c0f44", "node_id": "C_kwDOANBUbNoAKGQyNjk0NzY2ZGNmZmYwMjc4ZmE5M2Q1ODEzNDBhMTBiMTUwYzBmNDQ", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-01T18:22:13Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-01T18:22:13Z"}, "message": "vect: Try to remove single-vector permutes from SLP graph\n\nThis patch extends the SLP layout optimisation pass so that it\ntries to remove layout changes that are brought about by permutes\nof existing vectors.  This fixes the bb-slp-pr54400.c regression on\nx86_64 and also means that we can remove the permutes in cases like:\n\ntypedef float v4sf __attribute__((vector_size(sizeof(float)*4)));\n\nfloat __attribute__((noipa))\nf(v4sf v0, v4sf v1)\n{\n  return v0[0]*v1[0]+v0[1]*v1[1]+v0[2]*v1[2]+v0[3]*v1[3];\n}\n\nThe new test is a simple adaption of bb-slp-pr54400.c, with the\nsame style of markup.\n\ngcc/\n\t* tree-vect-slp.cc (vect_build_slp_tree_2): When building a\n\tVEC_PERM_EXPR of an existing vector, set the SLP_TREE_LANES\n\tto the number of vector elements, if that's a known constant.\n\t(vect_optimize_slp_pass::is_compatible_layout): Remove associated\n\tcomment about zero SLP_TREE_LANES.\n\t(vect_optimize_slp_pass::start_choosing_layouts): Iterate over\n\tall partition members when looking for potential layouts.\n\tHandle existing permutes of fixed-length vectors.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-pr54400.c: Extend to aarch64.\n\t* gcc.dg/vect/bb-slp-layout-18.c: New test.", "tree": {"sha": "7f35881aaa65986887c387161b393bab673de954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f35881aaa65986887c387161b393bab673de954"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2694766dcfff0278fa93d581340a10b150c0f44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2694766dcfff0278fa93d581340a10b150c0f44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2694766dcfff0278fa93d581340a10b150c0f44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2694766dcfff0278fa93d581340a10b150c0f44/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5205f5b54ad769969ffd89978ba1bcee41380bf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5205f5b54ad769969ffd89978ba1bcee41380bf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5205f5b54ad769969ffd89978ba1bcee41380bf8"}], "stats": {"total": 86, "additions": 61, "deletions": 25}, "files": [{"sha": "ff46272250749f925d56f88b88160541205c5702", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-18.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2694766dcfff0278fa93d581340a10b150c0f44/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2694766dcfff0278fa93d581340a10b150c0f44/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-18.c?ref=d2694766dcfff0278fa93d581340a10b150c0f44", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_float} */\n+/* { dg-additional-options \"-w -Wno-psabi -ffast-math\" } */\n+\n+typedef float v4sf __attribute__((vector_size(sizeof(float)*4)));\n+\n+float __attribute__((noipa))\n+f(v4sf v0, v4sf v1)\n+{\n+  return v0[0]*v1[0]+v0[1]*v1[1]+v0[2]*v1[2]+v0[3]*v1[3];\n+}\n+\n+/* We are lacking an effective target for .REDUC_PLUS support.  */\n+/* { dg-final { scan-tree-dump-times \"basic block part vectorized\" 1 \"slp2\" { target x86_64-*-* aarch64*-*-* } } } */\n+/* { dg-final { scan-tree-dump-not \" = VEC_PERM_EXPR\" \"slp2\" { target x86_64-*-* aarch64*-*-* } } } */"}, {"sha": "8aec2092f4dddb4a89014fd35395ab7dccf0f22b", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr54400.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2694766dcfff0278fa93d581340a10b150c0f44/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr54400.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2694766dcfff0278fa93d581340a10b150c0f44/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr54400.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr54400.c?ref=d2694766dcfff0278fa93d581340a10b150c0f44", "patch": "@@ -39,5 +39,5 @@ main ()\n }\n \n /* We are lacking an effective target for .REDUC_PLUS support.  */\n-/* { dg-final { scan-tree-dump-times \"basic block part vectorized\" 3 \"slp2\" { target x86_64-*-* } } } */\n-/* { dg-final { scan-tree-dump-not \" = VEC_PERM_EXPR\" \"slp2\" { target x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"basic block part vectorized\" 3 \"slp2\" { target x86_64-*-* aarch64*-*-* } } } */\n+/* { dg-final { scan-tree-dump-not \" = VEC_PERM_EXPR\" \"slp2\" { target x86_64-*-* aarch64*-*-* } } } */"}, {"sha": "1cf79eee4a6c520415f75ed5bb4b3aa227141615", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2694766dcfff0278fa93d581340a10b150c0f44/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2694766dcfff0278fa93d581340a10b150c0f44/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=d2694766dcfff0278fa93d581340a10b150c0f44", "patch": "@@ -1842,6 +1842,10 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t\t\t\t\t     TREE_TYPE (TREE_TYPE (vec))));\n \t  SLP_TREE_VECTYPE (vnode) = TREE_TYPE (vec);\n \t}\n+      auto nunits = TYPE_VECTOR_SUBPARTS (SLP_TREE_VECTYPE (vnode));\n+      unsigned HOST_WIDE_INT const_nunits;\n+      if (nunits.is_constant (&const_nunits))\n+\tSLP_TREE_LANES (vnode) = const_nunits;\n       SLP_TREE_VEC_DEFS (vnode).safe_push (vec);\n       /* We are always building a permutation node even if it is an identity\n \t permute to shield the rest of the vectorizer from the odd node\n@@ -4331,8 +4335,6 @@ vect_optimize_slp_pass::is_compatible_layout (slp_tree node,\n   if (layout_i == 0)\n     return true;\n \n-  /* SLP_TREE_LANES is zero for existing vectors, but those only support\n-     layout 0 anyway.  */\n   if (SLP_TREE_LANES (node) != m_perms[layout_i].length ())\n     return false;\n \n@@ -4527,46 +4529,65 @@ vect_optimize_slp_pass::start_choosing_layouts ()\n   m_perms.safe_push (vNULL);\n \n   /* Create layouts from existing permutations.  */\n-  for (unsigned int node_i : m_leafs)\n+  auto_load_permutation_t tmp_perm;\n+  for (unsigned int node_i : m_partitioned_nodes)\n     {\n-      auto &vertex = m_vertices[node_i];\n-      if (vertex.partition < 0)\n-\tcontinue;\n-\n       /* Leafs also double as entries to the reverse graph.  Allow the\n \t layout of those to be changed.  */\n+      auto &vertex = m_vertices[node_i];\n       auto &partition = m_partitions[vertex.partition];\n       if (!m_slpg->vertices[node_i].succ)\n \tpartition.layout = 0;\n \n-      /* Loads are the only thing generating permutes.  */\n+      /* Loads and VEC_PERM_EXPRs are the only things generating permutes.  */\n       slp_tree node = vertex.node;\n-      if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-\tcontinue;\n-\n-      /* If splitting out a SLP_TREE_LANE_PERMUTATION can make the node\n-\t unpermuted, record a layout that reverses this permutation.  */\n-      gcc_assert (partition.layout == 0);\n       stmt_vec_info dr_stmt = SLP_TREE_REPRESENTATIVE (node);\n-      if (!STMT_VINFO_GROUPED_ACCESS (dr_stmt))\n-\tcontinue;\n-      dr_stmt = DR_GROUP_FIRST_ELEMENT (dr_stmt);\n-      unsigned imin = DR_GROUP_SIZE (dr_stmt) + 1, imax = 0;\n+      slp_tree child;\n+      unsigned HOST_WIDE_INT imin, imax = 0;\n       bool any_permute = false;\n+      tmp_perm.truncate (0);\n+      if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n+\t{\n+\t  /* If splitting out a SLP_TREE_LANE_PERMUTATION can make the node\n+\t     unpermuted, record a layout that reverses this permutation.  */\n+\t  gcc_assert (partition.layout == 0);\n+\t  if (!STMT_VINFO_GROUPED_ACCESS (dr_stmt))\n+\t    continue;\n+\t  dr_stmt = DR_GROUP_FIRST_ELEMENT (dr_stmt);\n+\t  imin = DR_GROUP_SIZE (dr_stmt) + 1;\n+\t  tmp_perm.safe_splice (SLP_TREE_LOAD_PERMUTATION (node));\n+\t}\n+      else if (SLP_TREE_CODE (node) == VEC_PERM_EXPR\n+\t       && SLP_TREE_CHILDREN (node).length () == 1\n+\t       && (child = SLP_TREE_CHILDREN (node)[0])\n+\t       && (TYPE_VECTOR_SUBPARTS (SLP_TREE_VECTYPE (child))\n+\t\t   .is_constant (&imin)))\n+\t{\n+\t  /* If the child has the same vector size as this node,\n+\t     reversing the permutation can make the permutation a no-op.\n+\t     In other cases it can change a true permutation into a\n+\t     full-vector extract.  */\n+\t  tmp_perm.reserve (SLP_TREE_LANES (node));\n+\t  for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n+\t    tmp_perm.quick_push (SLP_TREE_LANE_PERMUTATION (node)[j].second);\n+\t}\n+      else\n+\tcontinue;\n+\n       for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n \t{\n-\t  unsigned idx = SLP_TREE_LOAD_PERMUTATION (node)[j];\n+\t  unsigned idx = tmp_perm[j];\n \t  imin = MIN (imin, idx);\n \t  imax = MAX (imax, idx);\n-\t  if (idx - SLP_TREE_LOAD_PERMUTATION (node)[0] != j)\n+\t  if (idx - tmp_perm[0] != j)\n \t    any_permute = true;\n \t}\n       /* If the span doesn't match we'd disrupt VF computation, avoid\n \t that for now.  */\n       if (imax - imin + 1 != SLP_TREE_LANES (node))\n \tcontinue;\n       /* If there's no permute no need to split one out.  In this case\n-\t we can consider turning the load into a permuted load, if that\n+\t we can consider turning a load into a permuted load, if that\n \t turns out to be cheaper than alternatives.  */\n       if (!any_permute)\n \t{\n@@ -4581,7 +4602,7 @@ vect_optimize_slp_pass::start_choosing_layouts ()\n       auto_sbitmap load_index (SLP_TREE_LANES (node));\n       bitmap_clear (load_index);\n       for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n-\tbitmap_set_bit (load_index, SLP_TREE_LOAD_PERMUTATION (node)[j] - imin);\n+\tbitmap_set_bit (load_index, tmp_perm[j] - imin);\n       unsigned j;\n       for (j = 0; j < SLP_TREE_LANES (node); ++j)\n \tif (!bitmap_bit_p (load_index, j))\n@@ -4592,7 +4613,7 @@ vect_optimize_slp_pass::start_choosing_layouts ()\n       vec<unsigned> perm = vNULL;\n       perm.safe_grow (SLP_TREE_LANES (node), true);\n       for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n-\tperm[j] = SLP_TREE_LOAD_PERMUTATION (node)[j] - imin;\n+\tperm[j] = tmp_perm[j] - imin;\n \n       if (int (m_perms.length ()) >= param_vect_max_layout_candidates)\n \t{"}]}