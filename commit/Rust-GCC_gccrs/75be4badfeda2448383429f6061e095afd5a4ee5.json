{"sha": "75be4badfeda2448383429f6061e095afd5a4ee5", "node_id": "C_kwDOANBUbNoAKDc1YmU0YmFkZmVkYTI0NDgzODM0MjlmNjA2MWUwOTVhZmQ1YTRlZTU", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2023-03-28T01:20:05Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2023-03-28T01:20:05Z"}, "message": "CRIS: Improve bailing for eliminable compares for \"addi\" vs. \"add\"\n\nThis patch affects a post-reload define_split for CRIS that transforms\na condition-code-clobbering addition into a non-clobbering addition.\n(A \"two-operand\" addition between registers is the only insn that has\nboth a condition-code-clobbering and a non-clobbering variant for\nCRIS.)  Many more \"add.d\":s are replaced by non-condition-code-\nclobbering \"addi\":s after this patch, but most of the transformations\ndon't matter.\n\nCRIS with LRA generated code that exposed a flaw with the original\npatch: it bailed too easily, on *any* insn using the result of the\naddition.  To wit, more effort than simply applying reg_mentioned_p is\nneeded to inspect the user, in the code to avoid munging an insn\nsequence that cmpelim is supposed to handle.\n\nWith this patch coremark score for CRIS (*with reload*) improves by\nless than 0.01% (a single \"nop\" is eliminated in\ncore_state_transition, in an execution path that affects ~1/20 of all\nof the 10240 calls).  However, the original cause for this patch is to\nnot regress gcc.target/cris/pr93372-44.c for LRA, where otherwise a\nneedless \"cmpq\" is emitted.  For CRIS with LRA, the performance effect\non coremark isn't even measurable, except by reducing the size of the\nexecutable due to affecting non-called library code.\n\n\t* config/cris/cris.md (\"*add<mode>3_addi\"): Improve to bail only\n\tfor possible eliminable compares.", "tree": {"sha": "39d64d4e527d24cea969ecf2ef82a3b21242de3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39d64d4e527d24cea969ecf2ef82a3b21242de3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75be4badfeda2448383429f6061e095afd5a4ee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75be4badfeda2448383429f6061e095afd5a4ee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75be4badfeda2448383429f6061e095afd5a4ee5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75be4badfeda2448383429f6061e095afd5a4ee5/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bab2fb9d63ef1e3d51b88dcdf1d7d533fb6e6844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab2fb9d63ef1e3d51b88dcdf1d7d533fb6e6844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bab2fb9d63ef1e3d51b88dcdf1d7d533fb6e6844"}], "stats": {"total": 53, "additions": 52, "deletions": 1}, "files": [{"sha": "30ff7e75c1bf61743454a7e6dd42e6d9b56c6ea7", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75be4badfeda2448383429f6061e095afd5a4ee5/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75be4badfeda2448383429f6061e095afd5a4ee5/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=75be4badfeda2448383429f6061e095afd5a4ee5", "patch": "@@ -1362,12 +1362,63 @@\n {\n   rtx reg = operands[0];\n   rtx_insn *i = next_nonnote_nondebug_insn_bb (curr_insn);\n+  rtx x, src, dest;\n \n   while (i != NULL_RTX && (!INSN_P (i) || DEBUG_INSN_P (i)))\n     i = next_nonnote_nondebug_insn_bb (i);\n \n-  if (i == NULL_RTX || reg_mentioned_p (reg, i) || BARRIER_P (i))\n+  /* We don't want to strip the clobber if the next insn possibly uses the\n+     zeroness of the result.  Preferably fail only if we see a compare insn\n+     that looks eliminable and with the register \"reg\" compared.  With some\n+     effort we could also check for an equality test (EQ, NE) in the post-split\n+     user, just not for now.  */\n+  if (i == NULL_RTX)\n     FAIL;\n+\n+  x = single_set (i);\n+\n+  /* We explicitly need to bail on a BARRIER, but that's implied by a failing\n+     single_set test.  */\n+  if (x == NULL_RTX)\n+    FAIL;\n+\n+  src = SET_SRC (x);\n+  dest = SET_DEST (x);\n+\n+  /* Bail on (post-split) eliminable compares.  */\n+  if (REG_P (dest) && REGNO (dest) == CRIS_CC0_REGNUM\n+      && GET_CODE (src) == COMPARE)\n+    {\n+      rtx cop0 = XEXP (src, 0);\n+\n+      if (REG_P (cop0) && REGNO (cop0) == REGNO (reg)\n+\t  && XEXP (src, 1) == const0_rtx)\n+\tFAIL;\n+    }\n+\n+  /* Bail out if we see a (pre-split) cbranch or cstore where the comparison\n+     looks eliminable and uses the destination register in this addition.  We\n+     don't need to look very deep: a single_set which is a parallel clobbers\n+     something, and (one of) that something, is always CRIS_CC0_REGNUM here.\n+     Also, the entities we're looking for are two-element parallels.  A\n+     split-up cbranch or cstore doesn't clobber CRIS_CC0_REGNUM.  A cbranch has\n+     if_then_else as its source with a comparison operator as the condition,\n+     and a cstore has a source with the comparison operator directly.  That\n+     also matches dstep, so look for pc as destination for the if_then_else.\n+     We error on the safe side if we happen to catch other conditional entities\n+     and FAIL, that just means the split won't happen.  */\n+  if (GET_CODE (PATTERN (i)) == PARALLEL && XVECLEN (PATTERN (i), 0) == 2)\n+    {\n+      rtx cmp\n+\t= (GET_CODE (src) == IF_THEN_ELSE && dest == pc_rtx\n+\t   ? XEXP (src, 0)\n+\t   : (COMPARISON_P (src) ? src : NULL_RTX));\n+      gcc_assert (cmp == NULL_RTX || COMPARISON_P (cmp));\n+\n+      if (cmp && REG_P (XEXP (cmp, 0)) && XEXP (cmp, 1) == const0_rtx\n+\t  && REGNO (XEXP (cmp, 0)) == REGNO (reg))\n+\tFAIL;\n+    }\n })\n \n (define_insn \"<u>mul<s><mode>3\""}]}