{"sha": "1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJhYTM3NWZlYWEyMmUzZGJmNmRmN2EwNjZiYTBkNGEyYjNhMDJkOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "1999-11-27T13:50:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1999-11-27T13:50:13Z"}, "message": "fold-const.c (negate_expr, [...]): New.\n\n\t* fold-const.c (negate_expr, associate_trees, extract_muldiv): New.\n\t(split_tree): Completely rework to make more general.\n\t(make_range, fold): Call negate_expr.\n\t(fold, case NEGATE_EXPR): Simplify -(a-b) is -ffast-math.\n\t(fold, associate): Call new split_tree and associate_trees.\n\t(fold, case MULT_EXPR, case *_{DIV,MOD}_EXPR): Call extract_muldiv.\n\nFrom-SVN: r30673", "tree": {"sha": "368881c3a9ecac0c1c9c28d7d35bd0a9485737fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/368881c3a9ecac0c1c9c28d7d35bd0a9485737fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8/comments", "author": null, "committer": null, "parents": [{"sha": "a8b64d6cf40a262116836ced24027faf5c39e5c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b64d6cf40a262116836ced24027faf5c39e5c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b64d6cf40a262116836ced24027faf5c39e5c6"}], "stats": {"total": 824, "additions": 452, "deletions": 372}, "files": [{"sha": "ec399ecbb7653181515a89e8040be62bfeab22a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8", "patch": "@@ -1,3 +1,12 @@\n+Sat Nov 27 08:38:26 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* fold-const.c (negate_expr, associate_trees, extract_muldiv): New.\n+\t(split_tree): Completely rework to make more general.\n+\t(make_range, fold): Call negate_expr.\n+\t(fold, case NEGATE_EXPR): Simplify -(a-b) is -ffast-math.\n+\t(fold, associate): Call new split_tree and associate_trees.\n+\t(fold, case MULT_EXPR, case *_{DIV,MOD}_EXPR): Call extract_muldiv.\n+\n 1999-11-26  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* loop.c (try_copy_prop): Avoid GNU C extension."}, {"sha": "e48f0e243b70b0c0cbb5188e669bd72479500392", "filename": "gcc/fold-const.c", "status": "modified", "additions": 443, "deletions": 372, "changes": 815, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1baa375feaa22e3dbf6df7a066ba0d4a2b3a02d8", "patch": "@@ -61,8 +61,10 @@ int div_and_round_double\tPROTO((enum tree_code, int, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT *));\n-static int split_tree\t\tPROTO((tree, enum tree_code, tree *,\n-\t\t\t\t       tree *, int *));\n+static tree negate_expr\t\tPROTO((tree));\n+static tree split_tree\t\tPROTO((tree, enum tree_code, tree *, tree *,\n+\t\t\t\t       int));\n+static tree associate_trees\tPROTO((tree, tree, enum tree_code, tree));\n static tree int_const_binop\tPROTO((enum tree_code, tree, tree, int, int));\n static tree const_binop\t\tPROTO((enum tree_code, tree, tree, int));\n static tree fold_convert\tPROTO((tree, tree));\n@@ -93,6 +95,7 @@ static tree fold_range_test\tPROTO((tree));\n static tree unextend\t\tPROTO((tree, int, int, tree));\n static tree fold_truthop\tPROTO((enum tree_code, tree, tree, tree));\n static tree optimize_minmax_comparison PROTO((tree));\n+static tree extract_muldiv\tPROTO((tree, tree, enum tree_code, tree));\n static tree strip_compound_expr PROTO((tree, tree));\n static int multiple_of_p\tPROTO((tree, tree, tree));\n static tree constant_boolean_node PROTO((int, tree));\n@@ -1199,93 +1202,181 @@ real_hex_to_f (s, mode)\n \n #endif /* no REAL_ARITHMETIC */\n \f\n-/* Split a tree IN into a constant and a variable part\n-   that could be combined with CODE to make IN.\n-   CODE must be a commutative arithmetic operation.\n-   Store the constant part into *CONP and the variable in &VARP.\n-   Return 1 if this was done; zero means the tree IN did not decompose\n-   this way.\n-\n-   If CODE is PLUS_EXPR we also split trees that use MINUS_EXPR.\n-   Therefore, we must tell the caller whether the variable part\n-   was subtracted.  We do this by storing 1 or -1 into *VARSIGNP.\n-   The value stored is the coefficient for the variable term.\n-   The constant term we return should always be added;\n-   we negate it if necessary.  */\n+/* Given T, an expression, return the negation of T.  Allow for T to be\n+   null, in which case return null.  */\n \n-static int\n-split_tree (in, code, varp, conp, varsignp)\n+static tree\n+negate_expr (t)\n+     tree t;\n+{\n+  tree type;\n+  tree tem;\n+\n+  if (t == 0)\n+    return 0;\n+\n+  type = TREE_TYPE (t);\n+  STRIP_SIGN_NOPS (t);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case INTEGER_CST:\n+    case REAL_CST:\n+      if (! TREE_UNSIGNED (type)\n+\t  && 0 != (tem = fold (build1 (NEGATE_EXPR, type, t)))\n+\t  && ! TREE_OVERFLOW (tem))\n+\treturn tem;\n+      break;\n+\n+    case NEGATE_EXPR:\n+      return convert (type, TREE_OPERAND (t, 0));\n+\n+    case MINUS_EXPR:\n+      /* - (A - B) -> B - A  */\n+      if (! FLOAT_TYPE_P (type) || flag_fast_math)\n+\treturn convert (type,\n+\t\t\tfold (build (MINUS_EXPR, TREE_TYPE (t),\n+\t\t\t\t     TREE_OPERAND (t, 1),\n+\t\t\t\t     TREE_OPERAND (t, 0))));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return convert (type, build1 (NEGATE_EXPR, TREE_TYPE (t), t));\n+}\n+\f\n+/* Split a tree IN into a constant, literal and variable parts that could be\n+   combined with CODE to make IN.  \"constant\" means an expression with\n+   TREE_CONSTANT but that isn't an actual constant.  CODE must be a\n+   commutative arithmetic operation.  Store the constant part into *CONP,\n+   the literal in &LITP and return the variable part.  If a part isn't\n+   present, set it to null.  If the tree does not decompose in this way,\n+   return the entire tree as the variable part and the other parts as null.\n+\n+   If CODE is PLUS_EXPR we also split trees that use MINUS_EXPR.  In that\n+   case, we negate an operand that was subtracted.  If NEGATE_P is true, we\n+   are negating all of IN.\n+\n+   If IN is itself a literal or constant, return it as appropriate.\n+\n+   Note that we do not guarantee that any of the three values will be the\n+   same type as IN, but they will have the same signedness and mode.  */\n+\n+static tree\n+split_tree (in, code, conp, litp, negate_p)\n      tree in;\n      enum tree_code code;\n-     tree *varp, *conp;\n-     int *varsignp;\n+     tree *conp, *litp;\n+     int negate_p;\n {\n-  register tree outtype = TREE_TYPE (in);\n-  *varp = 0;\n+  tree orig_in = in;\n+  tree type = TREE_TYPE (in);\n+  tree var = 0;\n+\n   *conp = 0;\n+  *litp = 0;\n+\n+  /* Strip any conversions that don't change the machine mode or signedness. */\n+  STRIP_SIGN_NOPS (in);\n+\n+  if (TREE_CODE (in) == INTEGER_CST || TREE_CODE (in) == REAL_CST)\n+    *litp = in;\n+  else if (TREE_CONSTANT (in))\n+    *conp = in;\n+\n+  else if (TREE_CODE (in) == code\n+\t   || (! FLOAT_TYPE_P (TREE_TYPE (in))\n+\t       /* We can associate addition and subtraction together (even\n+\t\t  though the C standard doesn't say so) for integers because\n+\t\t  the value is not affected.  For reals, the value might be\n+\t\t  affected, so we can't.  */\n+\t       && ((code == PLUS_EXPR && TREE_CODE (in) == MINUS_EXPR)\n+\t\t   || (code == MINUS_EXPR && TREE_CODE (in) == PLUS_EXPR))))\n+    {\n+      tree op0 = TREE_OPERAND (in, 0);\n+      tree op1 = TREE_OPERAND (in, 1);\n+      int neg1_p = TREE_CODE (in) == MINUS_EXPR;\n+      int neg_litp_p = 0, neg_conp_p = 0, neg_var_p = 0;\n+\n+      /* First see if either of the operands is a literal, then a constant.  */\n+      if (TREE_CODE (op0) == INTEGER_CST || TREE_CODE (op0) == REAL_CST)\n+\t*litp = op0, op0 = 0;\n+      else if (TREE_CODE (op1) == INTEGER_CST || TREE_CODE (op1) == REAL_CST)\n+\t*litp = op1, neg_litp_p = neg1_p, op1 = 0;\n+\n+      if (op0 != 0 && TREE_CONSTANT (op0))\n+\t*conp = op0, op0 = 0;\n+      else if (op1 != 0 && TREE_CONSTANT (op1))\n+\t*conp = op1, neg_conp_p = neg1_p, op1 = 0;\n+\n+      /* If we haven't dealt with either operand, this is not a case we can\n+\t decompose.  Otherwise, VAR is either of the ones remaining, if any. */\n+      if (op0 != 0 && op1 != 0)\n+\tvar = in;\n+      else if (op0 != 0)\n+\tvar = op0;\n+      else\n+\tvar = op1, neg_var_p = neg1_p;\n \n-  /* Strip any conversions that don't change the machine mode.  */\n-  while ((TREE_CODE (in) == NOP_EXPR\n-\t  || TREE_CODE (in) == CONVERT_EXPR)\n-\t && (TYPE_MODE (TREE_TYPE (in))\n-\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (in, 0)))))\n-    in = TREE_OPERAND (in, 0);\n-\n-  if (TREE_CODE (in) == code\n-      || (! FLOAT_TYPE_P (TREE_TYPE (in))\n-\t  /* We can associate addition and subtraction together\n-\t     (even though the C standard doesn't say so)\n-\t     for integers because the value is not affected.\n-\t     For reals, the value might be affected, so we can't.  */\n-\t  && ((code == PLUS_EXPR && TREE_CODE (in) == MINUS_EXPR)\n-\t      || (code == MINUS_EXPR && TREE_CODE (in) == PLUS_EXPR))))\n+      /* Now do any needed negations.  */\n+      if (neg_litp_p) *litp = negate_expr (*litp);\n+      if (neg_conp_p) *conp = negate_expr (*conp);\n+      if (neg_var_p) var = negate_expr (var);\n+    }\n+  else\n+    var = in;\n+\n+  if (negate_p)\n     {\n-      enum tree_code code = TREE_CODE (TREE_OPERAND (in, 0));\n-      if (code == INTEGER_CST)\n-\t{\n-\t  *conp = TREE_OPERAND (in, 0);\n-\t  *varp = TREE_OPERAND (in, 1);\n-\t  if (TYPE_MODE (TREE_TYPE (*varp)) != TYPE_MODE (outtype)\n-\t      && TREE_TYPE (*varp) != outtype)\n-\t    *varp = convert (outtype, *varp);\n-\t  *varsignp = (TREE_CODE (in) == MINUS_EXPR) ? -1 : 1;\n-\t  return 1;\n-\t}\n-      if (TREE_CONSTANT (TREE_OPERAND (in, 1)))\n-\t{\n-\t  *conp = TREE_OPERAND (in, 1);\n-\t  *varp = TREE_OPERAND (in, 0);\n-\t  *varsignp = 1;\n-\t  if (TYPE_MODE (TREE_TYPE (*varp)) != TYPE_MODE (outtype)\n-\t      && TREE_TYPE (*varp) != outtype)\n-\t    *varp = convert (outtype, *varp);\n-\t  if (TREE_CODE (in) == MINUS_EXPR)\n-\t    {\n-\t      /* If operation is subtraction and constant is second,\n-\t\t must negate it to get an additive constant.\n-\t\t And this cannot be done unless it is a manifest constant.\n-\t\t It could also be the address of a static variable.\n-\t\t We cannot negate that, so give up.  */\n-\t      if (TREE_CODE (*conp) == INTEGER_CST)\n-\t\t/* Subtracting from integer_zero_node loses for long long.  */\n-\t\t*conp = fold (build1 (NEGATE_EXPR, TREE_TYPE (*conp), *conp));\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t  return 1;\n-\t}\n-      if (TREE_CONSTANT (TREE_OPERAND (in, 0)))\n-\t{\n-\t  *conp = TREE_OPERAND (in, 0);\n-\t  *varp = TREE_OPERAND (in, 1);\n-\t  if (TYPE_MODE (TREE_TYPE (*varp)) != TYPE_MODE (outtype)\n-\t      && TREE_TYPE (*varp) != outtype)\n-\t    *varp = convert (outtype, *varp);\n-\t  *varsignp = (TREE_CODE (in) == MINUS_EXPR) ? -1 : 1;\n-\t  return 1;\n-\t}\n+      var = negate_expr (var);\n+      *conp = negate_expr (*conp);\n+      *litp = negate_expr (*litp);\n     }\n-  return 0;\n+\n+  return var;\n+}\n+\n+/* Re-associate trees split by the above function.  T1 and T2 are either\n+   expressions to associate or null.  Return the new expression, if any.  If\n+   we build an operation, do it in TYPE and with CODE, except if CODE is a\n+   MINUS_EXPR, in which case we use PLUS_EXPR since split_tree will already\n+   have taken care of the negations.  */\n+\n+static tree\n+associate_trees (t1, t2, code, type)\n+     tree t1, t2;\n+     enum tree_code code;\n+     tree type;\n+{\n+  tree tem;\n+\n+  if (t1 == 0)\n+    return t2;\n+  else if (t2 == 0)\n+    return t1;\n+\n+  if (code == MINUS_EXPR)\n+    code = PLUS_EXPR;\n+\n+  /* If either input is CODE, a PLUS_EXPR, or a MINUS_EXPR, don't\n+     try to fold this since we will have infinite recursion.  But do\n+     deal with any NEGATE_EXPRs.  */\n+  if (TREE_CODE (t1) == code || TREE_CODE (t2) == code\n+      || TREE_CODE (t1) == MINUS_EXPR || TREE_CODE (t2) == MINUS_EXPR)\n+    {\n+      if (TREE_CODE (t1) == NEGATE_EXPR)\n+\treturn build (MINUS_EXPR, type, convert (type, t2),\n+\t\t      convert (type, TREE_OPERAND (t1, 0)));\n+      else if (TREE_CODE (t2) == NEGATE_EXPR)\n+\treturn build (MINUS_EXPR, type, convert (type, t1),\n+\t\t      convert (type, TREE_OPERAND (t2, 0)));\n+      else\n+\treturn build (code, type, convert (type, t1), convert (type, t2));\n+    }\n+\n+  return fold (build (code, type, convert (type, t1), convert (type, t2)));\n }\n \f\n /* Combine two integer constants ARG1 and ARG2 under operation CODE\n@@ -3249,7 +3340,7 @@ make_range (exp, pin_p, plow, phigh)\n \n \tcase BIT_NOT_EXPR:\n \t  /* ~ X -> -X - 1  */\n-\t  exp = build (MINUS_EXPR, type, build1 (NEGATE_EXPR, type, arg0),\n+\t  exp = build (MINUS_EXPR, type, negate_expr (arg0),\n \t\t       convert (type, integer_one_node));\n \t  continue;\n \n@@ -4154,6 +4245,213 @@ optimize_minmax_comparison (t)\n     }\n }\n \f\n+/* T is an integer expression that is being multiplied, divided, or taken a\n+   modulus (CODE says which and what kind of divide or modulus) by a\n+   constant C.  See if we can eliminate that operation by folding it with\n+   other operations already in T.  WIDE_TYPE, if non-null, is a type that\n+   should be used for the computation if wider than our type.\n+\n+   For example, if we are dividing (X * 8) + (Y + 16) by 4, we can return\n+   (X * 2) + (Y + 4).  We also canonicalize (X + 7) * 4 into X * 4 + 28\n+   in the hope that either the machine has a multiply-accumulate insn\n+   or that this is part of an addressing calculation.\n+\n+   If we return a non-null expression, it is an equivalent form of the\n+   original computation, but need not be in the original type.  */\n+\n+static tree\n+extract_muldiv (t, c, code, wide_type)\n+     tree t;\n+     tree c;\n+     enum tree_code code;\n+     tree wide_type;\n+{\n+  tree type = TREE_TYPE (t);\n+  enum tree_code tcode = TREE_CODE (t);\n+  tree ctype = (wide_type != 0 && (GET_MODE_SIZE (TYPE_MODE (wide_type)) \n+\t\t\t\t   > GET_MODE_SIZE (TYPE_MODE (type)))\n+\t\t? wide_type : type);\n+  tree t1, t2;\n+  int same_p = tcode == code;\n+  int cancel_p\n+    = (code == MULT_EXPR && tcode == EXACT_DIV_EXPR)  || tcode == MULT_EXPR;\n+  tree op0, op1;\n+\n+  /* Don't deal with constants of zero here; they confuse the code below.  */\n+  if (integer_zerop (c))\n+    return 0;\n+\n+  if (TREE_CODE_CLASS (tcode) == '1')\n+    op0 = TREE_OPERAND (t, 0);\n+\n+  if (TREE_CODE_CLASS (tcode) == '2')\n+    op0 = TREE_OPERAND (t, 0), op1 = TREE_OPERAND (t, 1);\n+\n+  /* Note that we need not handle conditional operations here since fold\n+     already handles those cases.  So just do arithmetic here.  */\n+  switch (tcode)\n+    {\n+    case INTEGER_CST:\n+      /* For a constant, we can always simplify if we are a multiply\n+\t or (for divide and modulus) if it is a multiple of our constant.  */\n+      if (code == MULT_EXPR\n+\t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, t, c, 0)))\n+\treturn const_binop (code, convert (ctype, t), convert (ctype, c), 0);\n+      break;\n+\n+    case CONVERT_EXPR:  case NON_LVALUE_EXPR:  case NOP_EXPR:\n+\n+      /* Pass the constant down and see if we can make a simplification.  If\n+\t we can, replace this expression with a conversion of that result to\n+\t our type.  */\n+      if (0 != (t1 = extract_muldiv (op0, convert (TREE_TYPE (op0), c), code,\n+\t\t\t\t     code == MULT_EXPR ? ctype : NULL_TREE)))\n+\treturn t1;\n+      break;\n+\n+    case NEGATE_EXPR:  case ABS_EXPR:\n+      if ((t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n+\treturn fold (build1 (tcode, ctype, convert (ctype, t1)));\n+      break;\n+\n+    case MIN_EXPR:  case MAX_EXPR:\n+      /* MIN (a, b) / 5 -> MIN (a / 5, b / 5)  */\n+      if ((t1 = extract_muldiv (op0, c, code, wide_type)) != 0\n+\t  && (t2 = extract_muldiv (op1, c, code, wide_type)) != 0)\n+\treturn fold (build (tcode, ctype, convert (ctype, t1),\n+\t\t\t    convert (ctype, t2)));\n+      break;\n+\n+    case WITH_RECORD_EXPR:\n+      if ((t1 = extract_muldiv (TREE_OPERAND (t, 0), c, code, wide_type)) != 0)\n+\treturn build (WITH_RECORD_EXPR, TREE_TYPE (t1), t1,\n+\t\t      TREE_OPERAND (t, 1));\n+      break;\n+\n+    case SAVE_EXPR:\n+      /* If this has not been evaluated, we can see if we can do\n+\t something inside it and make a new one.  */\n+      if (SAVE_EXPR_RTL (t) == 0\n+\t  && 0 != (t1 = extract_muldiv (TREE_OPERAND (t, 0), c, code,\n+\t\t\t\t\twide_type)))\n+\treturn save_expr (t1);\n+      break;\n+\n+    case LSHIFT_EXPR:  case RSHIFT_EXPR:\n+      /* If the second operand is constant, this is a multiplication\n+\t or floor division, by a power of two, so we can treat it that\n+\t way unless the multiplier or divisor overflows.  */\n+      if (TREE_CODE (op1) == INTEGER_CST\n+\t  && 0 != (t1 = convert (ctype,\n+\t\t\t\t const_binop (LSHIFT_EXPR, size_one_node,\n+\t\t\t\t\t      op1, 0)))\n+\t  && ! TREE_OVERFLOW (t1))\n+\treturn extract_muldiv (build (tcode == LSHIFT_EXPR\n+\t\t\t\t      ? MULT_EXPR : FLOOR_DIV_EXPR,\n+\t\t\t\t      ctype, convert (ctype, op0), t1),\n+\t\t\t       c, code, wide_type);\n+      break;\n+\n+    case PLUS_EXPR:  case MINUS_EXPR:\n+      /* See if we can eliminate the operation on both sides.  If we can, we\n+\t can return a new PLUS or MINUS.  If we can't, the only remaining\n+\t cases where we can do anything are if the second operand is a\n+\t constant.  */\n+      t1 = extract_muldiv (op0, c, code, wide_type);\n+      t2 = extract_muldiv (op1, c, code, wide_type);\n+      if (t1 != 0 && t2 != 0)\n+\treturn fold (build (tcode, ctype, convert (ctype, t1),\n+\t\t\t    convert (ctype, t2)));\n+      else if (TREE_CODE (op1) != INTEGER_CST)\n+\tbreak;\n+\n+      /* If we were able to eliminate our operation from the first side,\n+\t apply our operation to the second side and reform the PLUS or\n+\t MINUS.  */\n+      if (t1 != 0 && (TREE_CODE (t1) != code || code == MULT_EXPR)\n+\t  && 0 != (t2 = const_binop (code, convert (ctype, op1),\n+\t\t\t\t     convert (ctype, c), 0))\n+\t  && ! TREE_OVERFLOW (t2))\n+\treturn fold (build (tcode, ctype, convert (ctype, t1), t2));\n+\n+      /* The last case is if we are a multiply.  In that case, we can\n+\t apply the distributive law to commute the multiply and addition\n+\t if the multiplication of the constants doesn't overflow. */\n+      if (code == MULT_EXPR\n+\t  && 0 != (t1 = const_binop (code, convert (ctype, op1),\n+\t\t\t\t     convert (ctype, c), 0))\n+\t  && ! TREE_OVERFLOW (t1))\n+\treturn fold (build (tcode, ctype, fold (build (code, ctype,\n+\t\t\t\t\t\t       convert (ctype, op0),\n+\t\t\t\t\t\t       convert (ctype, c))),\n+\t\t\t    t1));\n+\n+      break;\n+\n+    case MULT_EXPR:\n+      /* We have a special case here if we are doing something like\n+\t (C * 8) % 4 since we know that's zero.  */\n+      if ((code == TRUNC_MOD_EXPR || code == CEIL_MOD_EXPR\n+\t   || code == FLOOR_MOD_EXPR || code == ROUND_MOD_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST\n+\t  && integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n+\treturn omit_one_operand (type, integer_zero_node, op0);\n+\n+      /* ... fall through ... */\n+\n+    case TRUNC_DIV_EXPR:  case CEIL_DIV_EXPR:  case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:  case EXACT_DIV_EXPR:\n+      /* If we can extract our operation from the LHS, do so and return a\n+\t new operation.  Likewise for the RHS from a MULT_EXPR.  Otherwise,\n+\t do something only if the second operand is a constant.  */\n+      if (same_p\n+\t  && (t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n+\treturn fold (build (tcode, ctype, convert (ctype, t1),\n+\t\t\t    convert (ctype, op1)));\n+      else if (tcode == MULT_EXPR && code == MULT_EXPR\n+\t       && (t1 = extract_muldiv (op1, c, code, wide_type)) != 0)\n+\treturn fold (build (tcode, ctype, convert (ctype, op0),\n+\t\t\t    convert (ctype, t1)));\n+      else if (TREE_CODE (op1) != INTEGER_CST)\n+\treturn 0;\n+\n+      /* If these are the same operation types, we can associate them\n+\t assuming no overflow.  */\n+      if (tcode == code\n+\t  && 0 != (t1 = const_binop (MULT_EXPR, convert (ctype, op1),\n+\t\t\t\t     convert (ctype, c), 0))\n+\t  && ! TREE_OVERFLOW (t1))\n+\treturn fold (build (tcode, ctype, convert (ctype, op0), t1));\n+\n+      /* If these operations \"cancel\" each other, we have the main\n+\t optimizations of this pass, which occur when either constant is a\n+\t multiple of the other, in which case we replace this with either an\n+\t operation or CODE or TCODE.  */\n+      if ((code == MULT_EXPR && tcode == EXACT_DIV_EXPR)\n+\t  || (tcode == MULT_EXPR\n+\t      && code != TRUNC_MOD_EXPR && code != CEIL_MOD_EXPR\n+\t      && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR))\n+\t{\n+\t  if (integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n+\t    return fold (build (tcode, ctype, convert (ctype, op0),\n+\t\t\t\tconvert (ctype,\n+\t\t\t\t\t const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t      op1, c, 0))));\n+\t  else if (integer_zerop (const_binop (TRUNC_MOD_EXPR, c, op1, 0)))\n+\t    return fold (build (code, ctype, convert (ctype, op0),\n+\t\t\t\tconvert (ctype,\n+\t\t\t\t\t const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t      c, op1, 0))));\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\f\n /* If T contains a COMPOUND_EXPR which was inserted merely to evaluate\n    S, a SAVE_EXPR, return the expression actually being evaluated.   Note\n    that we may sometimes modify the tree.  */\n@@ -4772,7 +5070,8 @@ fold (expr)\n \treturn TREE_OPERAND (arg0, 0);\n \n       /* Convert - (a - b) to (b - a) for non-floating-point.  */\n-      else if (TREE_CODE (arg0) == MINUS_EXPR && ! FLOAT_TYPE_P (type))\n+      else if (TREE_CODE (arg0) == MINUS_EXPR\n+\t       && (! FLOAT_TYPE_P (type) || flag_fast_math))\n \treturn build (MINUS_EXPR, type, TREE_OPERAND (arg0, 1),\n \t\t      TREE_OPERAND (arg0, 0));\n \n@@ -4816,14 +5115,10 @@ fold (expr)\n       else if (TREE_CODE (arg0) == COMPLEX_EXPR)\n \treturn build (COMPLEX_EXPR, TREE_TYPE (arg0),\n \t\t      TREE_OPERAND (arg0, 0),\n-\t\t      fold (build1 (NEGATE_EXPR,\n-\t\t\t\t    TREE_TYPE (TREE_TYPE (arg0)),\n-\t\t\t\t    TREE_OPERAND (arg0, 1))));\n+\t\t      negate_expr (TREE_OPERAND (arg0, 1)));\n       else if (TREE_CODE (arg0) == COMPLEX_CST)\n \treturn build_complex (type, TREE_OPERAND (arg0, 0),\n-\t\t\t      fold (build1 (NEGATE_EXPR,\n-\t\t\t\t\t    TREE_TYPE (TREE_TYPE (arg0)),\n-\t\t\t\t\t    TREE_OPERAND (arg0, 1))));\n+\t\t\t      negate_expr (TREE_OPERAND (arg0, 1)));\n       else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n \treturn fold (build (TREE_CODE (arg0), type,\n \t\t\t    fold (build1 (CONJ_EXPR, type,\n@@ -5047,109 +5342,41 @@ fold (expr)\n \t  }\n       }\n \n+\n     associate:\n-      /* In most languages, can't associate operations on floats\n-\t through parentheses.  Rather than remember where the parentheses\n-\t were, we don't associate floats at all.  It shouldn't matter much.\n-\t However, associating multiplications is only very slightly\n-\t inaccurate, so do that if -ffast-math is specified.  */\n-      if (FLOAT_TYPE_P (type)\n-\t  && ! (flag_fast_math && code == MULT_EXPR))\n-\tgoto binary;\n-\n-      /* The varsign == -1 cases happen only for addition and subtraction.\n-\t It says that the arg that was split was really CON minus VAR.\n-\t The rest of the code applies to all associative operations.  */\n-      if (!wins)\n+      /* In most languages, can't associate operations on floats through\n+\t parentheses.  Rather than remember where the parentheses were, we\n+\t don't associate floats at all.  It shouldn't matter much.  However,\n+\t associating multiplications is only very slightly inaccurate, so do\n+\t that if -ffast-math is specified.  */\n+\n+      if (! wins\n+\t  && (! FLOAT_TYPE_P (type)\n+\t      || (flag_fast_math && code != MULT_EXPR)))\n \t{\n-\t  tree var, con;\n-\t  int varsign;\n-\n-\t  if (split_tree (arg0, code, &var, &con, &varsign))\n-\t    {\n-\t      if (varsign == -1)\n-\t\t{\n-\t\t  /* EXPR is (CON-VAR) +- ARG1.  */\n-\t\t  /* If it is + and VAR==ARG1, return just CONST.  */\n-\t\t  if (code == PLUS_EXPR && operand_equal_p (var, arg1, 0))\n-\t\t    return convert (TREE_TYPE (t), con);\n-\t\t    \n-\t\t  /* If ARG0 is a constant, don't change things around;\n-\t\t     instead keep all the constant computations together.  */\n-\n-\t\t  if (TREE_CONSTANT (arg0))\n-\t\t    return t;\n-\n-\t\t  /* Otherwise return (CON +- ARG1) - VAR.  */\n-\t\t  t = build (MINUS_EXPR, type,\n-\t\t\t     fold (build (code, type, con, arg1)), var);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* EXPR is (VAR+CON) +- ARG1.  */\n-\t\t  /* If it is - and VAR==ARG1, return just CONST.  */\n-\t\t  if (code == MINUS_EXPR && operand_equal_p (var, arg1, 0))\n-\t\t    return convert (TREE_TYPE (t), con);\n-\t\t    \n-\t\t  /* If ARG0 is a constant, don't change things around;\n-\t\t     instead keep all the constant computations together.  */\n-\n-\t\t  if (TREE_CONSTANT (arg0))\n-\t\t    return t;\n-\n-\t\t  /* Otherwise return VAR +- (ARG1 +- CON).  */\n-\t\t  tem = fold (build (code, type, arg1, con));\n-\t\t  t = build (code, type, var, tem);\n-\n-\t\t  if (integer_zerop (tem)\n-\t\t      && (code == PLUS_EXPR || code == MINUS_EXPR))\n-\t\t    return convert (type, var);\n-\t\t  /* If we have x +/- (c - d) [c an explicit integer]\n-\t\t     change it to x -/+ (d - c) since if d is relocatable\n-\t\t     then the latter can be a single immediate insn\n-\t\t     and the former cannot.  */\n-\t\t  if (TREE_CODE (tem) == MINUS_EXPR\n-\t\t      && TREE_CODE (TREE_OPERAND (tem, 0)) == INTEGER_CST)\n-\t\t    {\n-\t\t      tree tem1 = TREE_OPERAND (tem, 1);\n-\t\t      TREE_OPERAND (tem, 1) = TREE_OPERAND (tem, 0);\n-\t\t      TREE_OPERAND (tem, 0) = tem1;\n-\t\t      TREE_SET_CODE (t,\n-\t\t\t\t     (code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR));\n-\t\t    }\n-\t\t}\n-\t      return t;\n-\t    }\n-\n-\t  if (split_tree (arg1, code, &var, &con, &varsign))\n+\t  tree var0, con0, lit0, var1, con1, lit1;\n+\n+\t  /* Split both trees into variables, constants, and literals.  Then\n+\t     associate each group together, the constants with literals,\n+\t     then the result with variables.  This increases the chances of\n+\t     literals being recombined later and of generating relocatable\n+\t     expressions for the sum of a constant and literal. */\n+\t  var0 = split_tree (arg0, code, &con0, &lit0, 0);\n+\t  var1 = split_tree (arg1, code, &con1, &lit1, code == MINUS_EXPR);\n+\n+\t  /* Only do something if we found more than two objects.  Otherwise,\n+\t     nothing has changed and we risk infinite recursion.  */\n+\t  if (2 < ((var0 != 0) + (var1 != 0) + (con0 != 0) + (con1 != 0)\n+\t\t   + (lit0 != 0) + (lit1 != 0)))\n \t    {\n-\t      if (TREE_CONSTANT (arg1))\n-\t\treturn t;\n-\n-\t      if (varsign == -1)\n-\t\tTREE_SET_CODE (t,\n-\t\t\t       (code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR));\n-\n-\t      /* EXPR is ARG0 +- (CON +- VAR).  */\n-\t      if (TREE_CODE (t) == MINUS_EXPR\n-\t\t  && operand_equal_p (var, arg0, 0))\n-\t\t{\n-\t\t  /* If VAR and ARG0 cancel, return just CON or -CON.  */\n-\t\t  if (code == PLUS_EXPR)\n-\t\t    return convert (TREE_TYPE (t), con);\n-\t\t  return fold (build1 (NEGATE_EXPR, TREE_TYPE (t),\n-\t\t\t\t       convert (TREE_TYPE (t), con)));\n-\t\t}\n-\n-\t      t = build (TREE_CODE (t), type,\n-\t\t\t fold (build (code, TREE_TYPE (t), arg0, con)), var);\n-\n-\t      if (integer_zerop (TREE_OPERAND (t, 0))\n-\t\t  && TREE_CODE (t) == PLUS_EXPR)\n-\t\treturn convert (TREE_TYPE (t), var);\n-\t      return t;\n+\t      var0 = associate_trees (var0, var1, code, type);\n+\t      con0 = associate_trees (con0, con1, code, type);\n+\t      lit0 = associate_trees (lit0, lit1, code, type);\n+\t      con0 = associate_trees (con0, lit0, code, type);\n+\t      return convert (type, associate_trees (var0, con0, code, type));\n \t    }\n \t}\n+\n     binary:\n #if defined (REAL_IS_NOT_DOUBLE) && ! defined (REAL_ARITHMETIC)\n       if (TREE_CODE (arg1) == REAL_CST)\n@@ -5183,7 +5410,7 @@ fold (expr)\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (! wins && integer_zerop (arg0))\n-\t    return build1 (NEGATE_EXPR, type, arg1);\n+\t    return negate_expr (arg1);\n \t  if (integer_zerop (arg1))\n \t    return non_lvalue (convert (type, arg0));\n \n@@ -5206,7 +5433,7 @@ fold (expr)\n \t{\n \t  /* Except with IEEE floating point, 0-x equals -x.  */\n \t  if (! wins && real_zerop (arg0))\n-\t    return build1 (NEGATE_EXPR, type, arg1);\n+\t    return negate_expr (arg1);\n \t  /* Except with IEEE floating point, x-0 equals x.  */\n \t  if (real_zerop (arg1))\n \t    return non_lvalue (convert (type, arg0));\n@@ -5237,14 +5464,6 @@ fold (expr)\n \t  if (integer_onep (arg1))\n \t    return non_lvalue (convert (type, arg0));\n \n-\t  /* ((A / C) * C) is A if the division is an\n-\t     EXACT_DIV_EXPR.   Since C is normally a constant,\n-\t     just check for one of the four possibilities.  */\n-\n-\t  if (TREE_CODE (arg0) == EXACT_DIV_EXPR\n-\t      && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\t    return TREE_OPERAND (arg0, 0);\n-\n \t  /* (a * (1 << b)) is (a << b)  */\n \t  if (TREE_CODE (arg1) == LSHIFT_EXPR\n \t      && integer_onep (TREE_OPERAND (arg1, 0)))\n@@ -5254,6 +5473,12 @@ fold (expr)\n \t      && integer_onep (TREE_OPERAND (arg0, 0)))\n \t    return fold (build (LSHIFT_EXPR, type, arg1,\n \t\t\t\tTREE_OPERAND (arg0, 1)));\n+\n+\t  if (TREE_CODE (arg1) == INTEGER_CST\n+\t      && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n+\t\t\t\t\t     code, NULL_TREE)))\n+\t    return convert (type, tem);\n+\n \t}\n       else\n \t{\n@@ -5455,129 +5680,10 @@ fold (expr)\n \t  && multiple_of_p (type, arg0, arg1))\n \treturn fold (build (EXACT_DIV_EXPR, type, arg0, arg1));\n \n-      /* If we have ((a / C1) / C2) where both division are the same type, try\n-\t to simplify.  First see if C1 * C2 overflows or not.  */\n-      if (TREE_CODE (arg0) == code && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\t{\n-\t  tree new_divisor;\n-\n-\t  new_divisor = const_binop (MULT_EXPR, TREE_OPERAND (arg0, 1), arg1, 0);\n-\t  tem = const_binop (FLOOR_DIV_EXPR, new_divisor, arg1, 0);\n-\n-\t  if (TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)) == TREE_INT_CST_LOW (tem)\n-\t      && TREE_INT_CST_HIGH (TREE_OPERAND (arg0, 1)) == TREE_INT_CST_HIGH (tem))\n-\t    {\n-\t      /* If no overflow, divide by C1*C2.  */\n-\t      return fold (build (code, type, TREE_OPERAND (arg0, 0), new_divisor));\n-\t    }\n-\t}\n-\n-      /* Look for ((a * C1) / C3) or (((a * C1) + C2) / C3),\n-\t where C1 % C3 == 0 or C3 % C1 == 0.  We can simplify these\n-\t expressions, which often appear in the offsets or sizes of\n-\t objects with a varying size.  Only deal with positive divisors\n-\t and multiplicands.   If C2 is negative, we must have C2 % C3 == 0.\n-\n-\t Look for NOPs and SAVE_EXPRs inside.  */\n-\n-      if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && tree_int_cst_sgn (arg1) >= 0)\n-\t{\n-\t  int have_save_expr = 0;\n-\t  tree c2 = integer_zero_node;\n-\t  tree xarg0 = arg0;\n-\n-\t  if (TREE_CODE (xarg0) == SAVE_EXPR && SAVE_EXPR_RTL (xarg0) == 0)\n-\t    have_save_expr = 1, xarg0 = TREE_OPERAND (xarg0, 0);\n-\n-\t  STRIP_NOPS (xarg0);\n-\n-\t  /* Look inside the dividend and simplify using EXACT_DIV_EXPR\n-\t     if possible.  */\n-\t  if (TREE_CODE (xarg0) == MULT_EXPR\n-\t      && multiple_of_p (type, TREE_OPERAND (xarg0, 0), arg1))\n-\t    {\n-\t      tree t;\n-\n-\t      t = fold (build (MULT_EXPR, type,\n-\t\t\t       fold (build (EXACT_DIV_EXPR, type,\n-\t\t\t\t\t    TREE_OPERAND (xarg0, 0), arg1)),\n-\t\t\t       TREE_OPERAND (xarg0, 1)));\n-\t      if (have_save_expr)\n-\t\tt = save_expr (t);\n-\t      return t;\n-\n-\t    }\n-\n-\t  if (TREE_CODE (xarg0) == MULT_EXPR\n-\t      && multiple_of_p (type, TREE_OPERAND (xarg0, 1), arg1))\n-\t    {\n-\t      tree t;\n-\n-\t      t = fold (build (MULT_EXPR, type,\n-\t\t\t       fold (build (EXACT_DIV_EXPR, type,\n-\t\t\t\t\t    TREE_OPERAND (xarg0, 1), arg1)),\n-\t\t\t       TREE_OPERAND (xarg0, 0)));\n-\t      if (have_save_expr)\n-\t\tt = save_expr (t);\n-\t      return t;\n-\t    }\n-\n-\t  if (TREE_CODE (xarg0) == PLUS_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n-\t    c2 = TREE_OPERAND (xarg0, 1), xarg0 = TREE_OPERAND (xarg0, 0);\n-\t  else if (TREE_CODE (xarg0) == MINUS_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n-\t\t   /* If we are doing this computation unsigned, the negate\n-\t\t      is incorrect.  */\n-\t\t   && ! TREE_UNSIGNED (type))\n-\t    {\n-\t      c2 = fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (xarg0, 1)));\n-\t      xarg0 = TREE_OPERAND (xarg0, 0);\n-\t    }\n-\n-\t  if (TREE_CODE (xarg0) == SAVE_EXPR && SAVE_EXPR_RTL (xarg0) == 0)\n-\t    have_save_expr = 1, xarg0 = TREE_OPERAND (xarg0, 0);\n-\n-\t  STRIP_NOPS (xarg0);\n-\n-\t  if (TREE_CODE (xarg0) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n-\t      && tree_int_cst_sgn (TREE_OPERAND (xarg0, 1)) >= 0\n-\t      && (integer_zerop (const_binop (TRUNC_MOD_EXPR,\n-\t\t\t\t\t      TREE_OPERAND (xarg0, 1), arg1, 1))\n-\t\t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, arg1,\n-\t\t\t\t\t\t TREE_OPERAND (xarg0, 1), 1)))\n-\t      && (tree_int_cst_sgn (c2) >= 0\n-\t\t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, c2,\n-\t\t\t\t\t\t arg1, 1))))\n-\t    {\n-\t      tree outer_div = integer_one_node;\n-\t      tree c1 = TREE_OPERAND (xarg0, 1);\n-\t      tree c3 = arg1;\n-\n-\t      /* If C3 > C1, set them equal and do a divide by\n-\t\t C3/C1 at the end of the operation.  */\n-\t      if (tree_int_cst_lt (c1, c3))\n-\t\touter_div = const_binop (code, c3, c1, 0), c3 = c1;\n-\t\t\n-\t      /* The result is A * (C1/C3) + (C2/C3).  */\n-\t      t = fold (build (PLUS_EXPR, type,\n-\t\t\t       fold (build (MULT_EXPR, type,\n-\t\t\t\t\t    TREE_OPERAND (xarg0, 0),\n-\t\t\t\t\t    const_binop (code, c1, c3, 1))),\n-\t\t\t       const_binop (code, c2, c3, 1)));\n-\n-\t      if (! integer_onep (outer_div))\n-\t\tt = fold (build (code, type, t, convert (type, outer_div)));\n-\n-\t      if (have_save_expr)\n-\t\tt = save_expr (t);\n-\n-\t      return t;\n-\t    }\n-\t}\n+        if (TREE_CODE (arg1) == INTEGER_CST\n+\t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n+\t\t\t\t\t code, NULL_TREE)))\n+\treturn convert (type, tem);\n \n       goto binary;\n \n@@ -5590,39 +5696,10 @@ fold (expr)\n       if (integer_zerop (arg1))\n \treturn t;\n \n-      /* Look for ((a * C1) % C3) or (((a * C1) + C2) % C3),\n-\t where C1 % C3 == 0.  Handle similarly to the division case,\n-\t but don't bother with SAVE_EXPRs.  */\n-\n       if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && ! integer_zerop (arg1))\n-\t{\n-\t  tree c2 = integer_zero_node;\n-\t  tree xarg0 = arg0;\n-\n-\t  if (TREE_CODE (xarg0) == PLUS_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n-\t    c2 = TREE_OPERAND (xarg0, 1), xarg0 = TREE_OPERAND (xarg0, 0);\n-\t  else if (TREE_CODE (xarg0) == MINUS_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n-\t\t   && ! TREE_UNSIGNED (type))\n-\t    {\n-\t      c2 = fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (xarg0, 1)));\n-\t      xarg0 = TREE_OPERAND (xarg0, 0);\n-\t    }\n-\n-\t  STRIP_NOPS (xarg0);\n-\n-\t  if (TREE_CODE (xarg0) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n-\t      && integer_zerop (const_binop (TRUNC_MOD_EXPR,\n-\t\t\t\t\t     TREE_OPERAND (xarg0, 1),\n-\t\t\t\t\t     arg1, 1))\n-\t      && tree_int_cst_sgn (c2) >= 0)\n-\t    /* The result is (C2%C3).  */\n-\t    return omit_one_operand (type, const_binop (code, c2, arg1, 1),\n-\t\t\t\t     TREE_OPERAND (xarg0, 0));\n-\t}\n+\t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n+\t\t\t\t\t code, NULL_TREE)))\n+\treturn convert (type, tem);\n \n       goto binary;\n \n@@ -6046,8 +6123,7 @@ fold (expr)\n       else if ((code == EQ_EXPR || code == NE_EXPR)\n \t       && TREE_CODE (arg0) == NEGATE_EXPR\n \t       && TREE_CODE (arg1) == INTEGER_CST\n-\t       && 0 != (tem = fold (build1 (NEGATE_EXPR, TREE_TYPE (arg1),\n-\t\t\t\t\t    arg1)))\n+\t       && 0 != (tem = negate_expr (arg1))\n \t       && TREE_CODE (tem) == INTEGER_CST\n \t       && ! TREE_CONSTANT_OVERFLOW (tem))\n \treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n@@ -6086,17 +6162,14 @@ fold (expr)\n \t and a comparison, and is probably faster.  */\n       else if (code == LE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n \t       && TREE_CODE (arg0) == ABS_EXPR\n-\t       && ! TREE_SIDE_EFFECTS (arg0))\n-\t{\n-\t  tree inner = TREE_OPERAND (arg0, 0);\n-\n-\t  tem = fold (build1 (NEGATE_EXPR, TREE_TYPE (arg1), arg1));\n-\t  if (TREE_CODE (tem) == INTEGER_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold (build (TRUTH_ANDIF_EXPR, type,\n-\t\t\t\tbuild (GE_EXPR, type, inner, tem),\n-\t\t\t\tbuild (LE_EXPR, type, inner, arg1)));\n-\t}\n+\t       && ! TREE_SIDE_EFFECTS (arg0)\n+\t       && (0 != (tem = negate_expr (arg1)))\n+\t       && TREE_CODE (tem) == INTEGER_CST\n+\t       && ! TREE_CONSTANT_OVERFLOW (tem))\n+\treturn fold (build (TRUTH_ANDIF_EXPR, type,\n+\t\t\t    build (GE_EXPR, type, TREE_OPERAND (arg0, 0), tem),\n+\t\t\t    build (LE_EXPR, type,\n+\t\t\t\t   TREE_OPERAND (arg0, 0), arg1)));\n \t  \n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n@@ -6635,8 +6708,7 @@ fold (expr)\n \t    switch (comp_code)\n \t      {\n \t      case EQ_EXPR:\n-\t\treturn pedantic_non_lvalue\n-\t\t  (fold (build1 (NEGATE_EXPR, type, arg1)));\n+\t\treturn pedantic_non_lvalue (negate_expr (arg1));\n \t      case NE_EXPR:\n \t\treturn pedantic_non_lvalue (convert (type, arg1));\n \t      case GE_EXPR:\n@@ -6651,11 +6723,10 @@ fold (expr)\n \t\tif (TREE_UNSIGNED (TREE_TYPE (arg1)))\n \t\t  arg1 = convert (signed_type (TREE_TYPE (arg1)), arg1);\n \t\treturn pedantic_non_lvalue\n-\t\t  (fold (build1 (NEGATE_EXPR, type,\n-\t\t\t\t convert (type,\n-\t\t\t\t\t  fold (build1 (ABS_EXPR,\n-\t\t\t\t\t\t\tTREE_TYPE (arg1),\n-\t\t\t\t\t\t\targ1))))));\n+\t\t  (negate_expr (convert (type,\n+\t\t\t\t\t fold (build1 (ABS_EXPR,\n+\t\t\t\t\t\t       TREE_TYPE (arg1),\n+\t\t\t\t\t\t       arg1)))));\n \t      default:\n \t\tabort ();\n \t      }"}]}