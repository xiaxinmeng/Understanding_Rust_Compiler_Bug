{"sha": "58b82d2b1a414470ea15282f5642bcfc0029e184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThiODJkMmIxYTQxNDQ3MGVhMTUyODJmNTY0MmJjZmMwMDI5ZTE4NA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-06-12T03:19:26Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-06-12T03:19:26Z"}, "message": "Fix PR tree-optimization/22005 Fix PR tree-optimization/22025\n\n2005-06-11  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/22005\n\tFix PR tree-optimization/22025\n\n\t* tree-ssa-structalias.c (struct variable_info): Add has_union\n\tmember.\n\t(create_variable_info_for):  Mark variables containing unions.\n\tDon't sort the field stack if notokay is true.\n\t(find_what_p_points_to): Convert variables containing unions back\n\tto their SFT's if necessary.\n\nFrom-SVN: r100851", "tree": {"sha": "a66413c660b58f251a921eee4eb35efd2c4bbf7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a66413c660b58f251a921eee4eb35efd2c4bbf7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58b82d2b1a414470ea15282f5642bcfc0029e184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b82d2b1a414470ea15282f5642bcfc0029e184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b82d2b1a414470ea15282f5642bcfc0029e184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b82d2b1a414470ea15282f5642bcfc0029e184/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e71b548ac9752d8d47baab10b418d2991607c4f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e71b548ac9752d8d47baab10b418d2991607c4f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e71b548ac9752d8d47baab10b418d2991607c4f5"}], "stats": {"total": 72, "additions": 61, "deletions": 11}, "files": [{"sha": "9fa225532b3690e32128a6bb9feb4528a8e64323", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b82d2b1a414470ea15282f5642bcfc0029e184/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b82d2b1a414470ea15282f5642bcfc0029e184/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58b82d2b1a414470ea15282f5642bcfc0029e184", "patch": "@@ -19,6 +19,18 @@\n \n \t* config/rs6000/rs6000.md (eq<mode>_compare): Restrict to Pmode.\n \n+2005-06-11  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/22005\n+\tFix PR tree-optimization/22025\n+\t\n+\t* tree-ssa-structalias.c (struct variable_info): Add has_union\n+\tmember.\n+\t(create_variable_info_for):  Mark variables containing unions.\n+\tDon't sort the field stack if notokay is true.\n+\t(find_what_p_points_to): Convert variables containing unions back\n+\tto their SFT's if necessary.\n+\t\n 2005-06-11  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* lambda-code.c (replace_uses_equiv_to_x_with_y): Verify the step"}, {"sha": "cdaac2b889b1e578303eb8bae70717826302d0b9", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr22005.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b82d2b1a414470ea15282f5642bcfc0029e184/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22005.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b82d2b1a414470ea15282f5642bcfc0029e184/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22005.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr22005.C?ref=58b82d2b1a414470ea15282f5642bcfc0029e184", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+struct cl_string \n+{\n+  union{ int i; };\n+  cl_string ();\n+};\n+struct cl_print_univpoly_flags { cl_string univpoly_varname; };\n+struct cl_print_flags: cl_print_univpoly_flags {int i;};\n+cl_print_flags default_print_flags;"}, {"sha": "00ecb7f691861989b16a28052fc39c2c1bc42c1a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b82d2b1a414470ea15282f5642bcfc0029e184/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b82d2b1a414470ea15282f5642bcfc0029e184/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=58b82d2b1a414470ea15282f5642bcfc0029e184", "patch": "@@ -221,6 +221,9 @@ struct variable_info\n   /* True for variables whose size is not known or variable.  */\n   unsigned int is_unknown_size_var:1;  \n \n+  /* True for variables that have unions somewhere in them.  */\n+  unsigned int has_union:1;\n+\n   /* Points-to set for this variable.  */\n   bitmap solution;\n \n@@ -2638,16 +2641,21 @@ create_variable_info_for (tree decl, const char *name)\n   varinfo_t vi;\n   tree decltype = TREE_TYPE (decl);\n   bool notokay = false;\n+  bool hasunion;\n   subvar_t svars;\n   bool is_global = DECL_P (decl) ? is_global_var (decl) : false;\n-\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n   \n-  if (var_can_have_subvars (decl) && use_field_sensitive)\n+\n+  hasunion = TREE_CODE (decltype) == UNION_TYPE || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n+  if (var_can_have_subvars (decl) && use_field_sensitive && !hasunion)\n     {\n-      push_fields_onto_fieldstack (decltype, &fieldstack, 0, &notokay);\n-      if (notokay)\n-\tVEC_free (fieldoff_s, heap, fieldstack);\n+      push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion);\n+      if (hasunion)\n+\t{\n+\t  VEC_free (fieldoff_s, heap, fieldstack);\n+\t  notokay = true;\n+\t}\t \n     }\n \n   /* If this variable already has subvars, just create the variables for the\n@@ -2713,6 +2721,7 @@ create_variable_info_for (tree decl, const char *name)\n   vi = new_var_info (decl, index, name, index);\n   vi->decl = decl;\n   vi->offset = 0;\n+  vi->has_union = hasunion;\n   if (!TYPE_SIZE (decltype) \n       || TREE_CODE (TYPE_SIZE  (decltype)) != INTEGER_CST\n       || TREE_CODE (decltype) == ARRAY_TYPE\n@@ -2756,7 +2765,13 @@ create_variable_info_for (tree decl, const char *name)\n \t      break;\n \t    }\n \t}\n-      sort_fieldstack (fieldstack);\n+\n+      /* We can't sort them if we have a field with a variable sized type,\n+\t which will make notokay = true.  In that case, we are going to return\n+\t without creating varinfos for the fields anyway, so sorting them is a\n+\t waste to boot.  */\n+      if (!notokay)\t\n+\tsort_fieldstack (fieldstack);\n       \n       if (VEC_length (fieldoff_s, fieldstack) != 0)\n \tfo = VEC_index (fieldoff_s, fieldstack, 0);\n@@ -2872,12 +2887,23 @@ set_uids_in_ptset (bitmap into, bitmap from)\n   EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n       varinfo_t vi = get_varinfo (i);\n-\n+      \n+      /* Variables containing unions may need to be converted to their \n+\t SFT's, because SFT's can have unions and we cannot.  */\n+      if (vi->has_union && get_subvars_for_var (vi->decl) != NULL)\n+\t{\n+\t  subvar_t svars = get_subvars_for_var (vi->decl);\n+\t  subvar_t sv;\n+\t  for (sv = svars; sv; sv = sv->next)\n+\t    bitmap_set_bit (into, var_ann (sv->var)->uid);    \n+\t}\n       /* We may end up with labels in the points-to set because people\n \t take their address, and they are _DECL's.  */\n-      if (TREE_CODE (vi->decl) == VAR_DECL \n+      else if (TREE_CODE (vi->decl) == VAR_DECL \n \t  || TREE_CODE (vi->decl) == PARM_DECL)\n \tbitmap_set_bit (into, var_ann (vi->decl)->uid);\n+\n+\t  \n     }\n }\n static int have_alias_info = false;\n@@ -2904,6 +2930,8 @@ find_what_p_points_to (tree p)\n \t  if (!var_can_have_subvars (vi->decl)\n \t      || get_subvars_for_var (vi->decl) == NULL)\n \t    return false;\n+\t  /* Nothing currently asks about structure fields directly, but when\n+\t     they do, we need code here to hand back the points-to set.  */\n \t} \n       else\n \t{\n@@ -2915,9 +2943,9 @@ find_what_p_points_to (tree p)\n \t     variable.  */\n \t  vi = get_varinfo (vi->node);\n \t  \n-\t  /* Make sure there aren't any artificial vars in the points\n-             to set.  XXX: Note that we need to translate our heap\n-             variables to something.  */ \n+\t  /* Make sure there aren't any artificial vars in the points to set.\n+             XXX: Note that we need to translate our heap variables to\n+             something.  */\n \t  EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n \t    {\n \t      if (get_varinfo (i)->is_artificial_var)"}]}