{"sha": "e6267549228960d1a5422dc073a0026081e39130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYyNjc1NDkyMjg5NjBkMWE1NDIyZGMwNzNhMDAyNjA4MWUzOTEzMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-11-23T23:57:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-11-23T23:57:32Z"}, "message": "typeck2.c (process_init_constructor): If there are elements that don't have initializers and they need to have...\n\n\t* typeck2.c (process_init_constructor): If there are elements\n\tthat don't have initializers and they need to have constructors\n\trun, supply them with initializers.\nFixes Sec12/6_1/P12176.C.\n\t* class.c (finish_struct_1): A class with a 0-width bitfield is\n\tstill empty.\nFixes Sec9/6/R09387.r0.  Really this time.\n\nFrom-SVN: r23819", "tree": {"sha": "8a5a846dae3a69d58c913a71a6e6fa421ef3ea09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a5a846dae3a69d58c913a71a6e6fa421ef3ea09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6267549228960d1a5422dc073a0026081e39130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6267549228960d1a5422dc073a0026081e39130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6267549228960d1a5422dc073a0026081e39130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6267549228960d1a5422dc073a0026081e39130/comments", "author": null, "committer": null, "parents": [{"sha": "d0b9a143e7552eef02291ab94d986867acb828ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b9a143e7552eef02291ab94d986867acb828ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b9a143e7552eef02291ab94d986867acb828ee"}], "stats": {"total": 204, "additions": 123, "deletions": 81}, "files": [{"sha": "6e403361efe285bc0c94a61f57bab1cfd5fcfd5a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6267549228960d1a5422dc073a0026081e39130/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6267549228960d1a5422dc073a0026081e39130/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6267549228960d1a5422dc073a0026081e39130", "patch": "@@ -1,3 +1,12 @@\n+1998-11-23  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck2.c (process_init_constructor): If there are elements\n+\tthat don't have initializers and they need to have constructors\n+\trun, supply them with initializers.\n+\n+\t* class.c (finish_struct_1): A class with a 0-width bitfield is\n+\tstill empty.\n+\n 1998-11-23  Mark Mitchell  <mark@markmitchell.com>\n \n \t* pt.c (instantiate_class_template): Don't try to figure out what"}, {"sha": "de283eae2ddea8c5b6b35cbc6983e796f07a75e5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6267549228960d1a5422dc073a0026081e39130/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6267549228960d1a5422dc073a0026081e39130/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e6267549228960d1a5422dc073a0026081e39130", "patch": "@@ -1235,7 +1235,9 @@ add_method (type, fields, method)\n \t\t}\n \t    }\n \n-\t  if (DECL_CONV_FN_P (method))\n+\t  if (TREE_VEC_ELT (method_vec, i))\n+\t    /* We found a match.  */;\n+\t  else if (DECL_CONV_FN_P (method))\n \t    {\n \t      /* Type conversion operators have to come before\n \t\t ordinary methods; add_conversions depends on this to\n@@ -3453,7 +3455,11 @@ finish_struct_1 (t, warn_anon)\n       if (TREE_CODE (x) == FIELD_DECL)\n \t{\n \t  DECL_PACKED (x) |= TYPE_PACKED (t);\n-\t  empty = 0;\n+\n+\t  if (DECL_C_BIT_FIELD (x) && integer_zerop (DECL_INITIAL (x)))\n+\t    /* A zero-width bitfield doesn't do the trick.  */;\n+\t  else\n+\t    empty = 0;\n \t}\n \n       if (TREE_CODE (x) == USING_DECL)"}, {"sha": "e11bde2d3b291fa172ec850f12430ba59bb742eb", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 106, "deletions": 79, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6267549228960d1a5422dc073a0026081e39130/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6267549228960d1a5422dc073a0026081e39130/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e6267549228960d1a5422dc073a0026081e39130", "patch": "@@ -703,6 +703,9 @@ digest_init (type, init, tail)\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     init = TREE_OPERAND (init, 0);\n \n+  if (TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == type)\n+    return init;\n+\n   raw_constructor = TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == 0;\n \n   if (raw_constructor\n@@ -873,6 +876,7 @@ process_init_constructor (type, init, elts)\n   /* List of the elements of the result constructor,\n      in reverse order.  */\n   register tree members = NULL;\n+  register tree next1;\n   tree result;\n   int allconstant = 1;\n   int allsimple = 1;\n@@ -907,42 +911,59 @@ process_init_constructor (type, init, elts)\n       else\n \tlen = -1;  /* Take as many as there are */\n \n-      for (i = 0; (len < 0 || i < len) && tail != 0; i++)\n+      for (i = 0; len < 0 || i < len; i++)\n \t{\n-\t  register tree next1;\n-\n-\t  if (TREE_PURPOSE (tail)\n-\t      && (TREE_CODE (TREE_PURPOSE (tail)) != INTEGER_CST\n-\t\t  || TREE_INT_CST_LOW (TREE_PURPOSE (tail)) != i))\n-\t    sorry (\"non-trivial labeled initializers\");\n-\n-\t  if (TREE_VALUE (tail) != 0)\n+\t  if (tail)\n \t    {\n-\t      tree tail1 = tail;\n-\t      next1 = digest_init (TREE_TYPE (type),\n-\t\t\t\t   TREE_VALUE (tail), &tail1);\n-\t      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (type))\n-\t\t  && TYPE_MAIN_VARIANT (TREE_TYPE (type)) != TYPE_MAIN_VARIANT (TREE_TYPE (next1)))\n+\t      if (TREE_PURPOSE (tail)\n+\t\t  && (TREE_CODE (TREE_PURPOSE (tail)) != INTEGER_CST\n+\t\t      || TREE_INT_CST_LOW (TREE_PURPOSE (tail)) != i))\n+\t\tsorry (\"non-trivial labeled initializers\");\n+\n+\t      if (TREE_VALUE (tail) != 0)\n \t\t{\n-\t\t  /* The fact this needs to be done suggests this code needs\n-\t\t     to be totally rewritten.  */\n-\t\t  next1 = convert_for_initialization (NULL_TREE, TREE_TYPE (type), next1, LOOKUP_NORMAL, \"initialization\", NULL_TREE, 0);\n+\t\t  tree tail1 = tail;\n+\t\t  next1 = digest_init (TREE_TYPE (type),\n+\t\t\t\t       TREE_VALUE (tail), &tail1);\n+\t\t  my_friendly_assert (TYPE_MAIN_VARIANT (TREE_TYPE (type))\n+\t\t\t\t      == TYPE_MAIN_VARIANT (TREE_TYPE (next1)),\n+\t\t\t\t      981123);\n+\t\t  my_friendly_assert (tail1 == 0\n+\t\t\t\t      || TREE_CODE (tail1) == TREE_LIST, 319);\n+\t\t  if (tail == tail1 && len < 0)\n+\t\t    {\n+\t\t      error (\"non-empty initializer for array of empty elements\");\n+\t\t      /* Just ignore what we were supposed to use.  */\n+\t\t      tail1 = NULL_TREE;\n+\t\t    }\n+\t\t  tail = tail1;\n \t\t}\n-\t      my_friendly_assert (tail1 == 0\n-\t\t\t\t  || TREE_CODE (tail1) == TREE_LIST, 319);\n-\t      if (tail == tail1 && len < 0)\n+\t      else\n \t\t{\n-\t\t  error (\"non-empty initializer for array of empty elements\");\n-\t\t  /* Just ignore what we were supposed to use.  */\n-\t\t  tail1 = NULL_TREE;\n+\t\t  next1 = error_mark_node;\n+\t\t  tail = TREE_CHAIN (tail);\n \t\t}\n-\t      tail = tail1;\n \t    }\n-\t  else\n+\t  else if (len < 0)\n+\t    /* We're done.  */\n+\t    break;\n+\t  else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (type)))\n \t    {\n-\t      next1 = error_mark_node;\n-\t      tail = TREE_CHAIN (tail);\n+\t      /* If this type needs constructors run for\n+\t\t default-initialization, we can't rely on the backend to do it\n+\t\t for us, so build up TARGET_EXPRs.  If the type in question is\n+\t\t a class, just build one up; if it's an array, recurse.  */\n+\n+\t      if (IS_AGGR_TYPE (TREE_TYPE (type)))\n+\t\tnext1 = build_functional_cast (TREE_TYPE (type), NULL_TREE);\n+\t      else\n+\t\tnext1 = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, NULL_TREE);\n+\t      next1 = digest_init (TREE_TYPE (type), next1, 0);\n \t    }\n+\t  else\n+\t    /* The default zero-initialization is fine for us; don't\n+\t       add anything to the CONSTRUCTOR.  */\n+\t    break;\n \n \t  if (next1 == error_mark_node)\n \t    erroneous = 1;\n@@ -978,11 +999,9 @@ process_init_constructor (type, init, elts)\n \t    }\n \t}\n \n-      for (field = TYPE_FIELDS (type); field && tail;\n+      for (field = TYPE_FIELDS (type); field;\n \t   field = TREE_CHAIN (field))\n \t{\n-\t  register tree next1;\n-\n \t  if (! DECL_NAME (field) && DECL_C_BIT_FIELD (field))\n \t    {\n \t      members = expr_tree_cons (field, integer_zero_node, members);\n@@ -992,25 +1011,67 @@ process_init_constructor (type, init, elts)\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n \n-\t  if (TREE_PURPOSE (tail)\n-\t      && TREE_PURPOSE (tail) != field\n-\t      && TREE_PURPOSE (tail) != DECL_NAME (field))\n-\t    sorry (\"non-trivial labeled initializers\");\n+\t  if (tail)\n+\t    {\n+\t      if (TREE_PURPOSE (tail)\n+\t\t  && TREE_PURPOSE (tail) != field\n+\t\t  && TREE_PURPOSE (tail) != DECL_NAME (field))\n+\t\tsorry (\"non-trivial labeled initializers\");\n+\n+\t      if (TREE_VALUE (tail) != 0)\n+\t\t{\n+\t\t  tree tail1 = tail;\n \n-\t  if (TREE_VALUE (tail) != 0)\n+\t\t  next1 = digest_init (TREE_TYPE (field),\n+\t\t\t\t       TREE_VALUE (tail), &tail1);\n+\t\t  my_friendly_assert (tail1 == 0\n+\t\t\t\t      || TREE_CODE (tail1) == TREE_LIST, 320);\n+\t\t  tail = tail1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  next1 = error_mark_node;\n+\t\t  tail = TREE_CHAIN (tail);\n+\t\t}\n+\t    }\n+\t  else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n \t    {\n-\t      tree tail1 = tail;\n+\t      /* If this type needs constructors run for\n+\t\t default-initialization, we can't rely on the backend to do it\n+\t\t for us, so build up TARGET_EXPRs.  If the type in question is\n+\t\t a class, just build one up; if it's an array, recurse.  */\n+\n+\t      if (IS_AGGR_TYPE (TREE_TYPE (field)))\n+\t\tnext1 = build_functional_cast (TREE_TYPE (field),\n+\t\t\t\t\t       NULL_TREE);\n+\t      else\n+\t\tnext1 = build (CONSTRUCTOR, NULL_TREE, NULL_TREE,\n+\t\t\t       NULL_TREE);\n+\t      next1 = digest_init (TREE_TYPE (field), next1, 0);\n \n-\t      next1 = digest_init (TREE_TYPE (field),\n-\t\t\t\t   TREE_VALUE (tail), &tail1);\n-\t      my_friendly_assert (tail1 == 0\n-\t\t\t\t  || TREE_CODE (tail1) == TREE_LIST, 320);\n-\t      tail = tail1;\n+\t      /* Warn when some struct elements are implicitly initialized.  */\n+\t      if (extra_warnings)\n+\t\tcp_warning (\"missing initializer for member `%D'\", field);\n \t    }\n \t  else\n \t    {\n-\t      next1 = error_mark_node;\n-\t      tail = TREE_CHAIN (tail);\n+\t      if (TREE_READONLY (field))\n+\t\tcp_error (\"uninitialized const member `%D'\", field);\n+\t      else if (TYPE_LANG_SPECIFIC (TREE_TYPE (field))\n+\t\t       && CLASSTYPE_READONLY_FIELDS_NEED_INIT (TREE_TYPE (field)))\n+\t\tcp_error (\"member `%D' with uninitialized const fields\",\n+\t\t\t  field);\n+\t      else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n+\t\tcp_error (\"member `%D' is uninitialized reference\", field);\n+\n+\t      /* Warn when some struct elements are implicitly initialized\n+\t\t to zero.  */\n+\t      if (extra_warnings)\n+\t\tcp_warning (\"missing initializer for member `%D'\", field);\n+\n+\t      /* The default zero-initialization is fine for us; don't\n+\t\t add anything to the CONSTRUCTOR.  */\n+\t      continue;\n \t    }\n \n \t  if (next1 == error_mark_node)\n@@ -1021,44 +1082,10 @@ process_init_constructor (type, init, elts)\n \t    allsimple = 0;\n \t  members = expr_tree_cons (field, next1, members);\n \t}\n-      for (; field; field = TREE_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n-\n-\t  /* Does this field have a default initialization?  */\n-\t  if (DECL_INITIAL (field))\n-\t    {\n-\t      register tree next1 = DECL_INITIAL (field);\n-\t      if (TREE_CODE (next1) == ERROR_MARK)\n-\t\terroneous = 1;\n-\t      else if (!TREE_CONSTANT (next1))\n-\t\tallconstant = 0;\n-\t      else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n-\t\tallsimple = 0;\n-\t      members = expr_tree_cons (field, next1, members);\n-\t    }\n-\t  else if (TREE_READONLY (field))\n-\t    error (\"uninitialized const member `%s'\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t  else if (TYPE_LANG_SPECIFIC (TREE_TYPE (field))\n-\t\t   && CLASSTYPE_READONLY_FIELDS_NEED_INIT (TREE_TYPE (field)))\n-\t    error (\"member `%s' with uninitialized const fields\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n-\t    error (\"member `%s' is uninitialized reference\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t  /* Warn when some struct elements are implicitly initialized\n-\t      to zero.  */\n-\t  else if (extra_warnings)\n-\t    warning (\"missing initializer for member `%s'\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t}\n     }\n   else if (TREE_CODE (type) == UNION_TYPE)\n     {\n       register tree field = TYPE_FIELDS (type);\n-      register tree next1;\n \n       /* Find the first named field.  ANSI decided in September 1990\n \t that only named fields count here.  */\n@@ -1087,8 +1114,8 @@ process_init_constructor (type, init, elts)\n \t      if (temp)\n \t\tfield = temp, win = 1;\n \t      else\n-\t\terror (\"no field `%s' in union being initialized\",\n-\t\t       IDENTIFIER_POINTER (TREE_PURPOSE (tail)));\n+\t\tcp_error (\"no field `%D' in union being initialized\",\n+\t\t\t  TREE_PURPOSE (tail));\n \t    }\n \t  if (!win)\n \t    TREE_VALUE (tail) = error_mark_node;"}]}