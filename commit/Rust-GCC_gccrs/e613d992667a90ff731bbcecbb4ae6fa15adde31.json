{"sha": "e613d992667a90ff731bbcecbb4ae6fa15adde31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYxM2Q5OTI2NjdhOTBmZjczMWJiY2VjYmI0YWU2ZmExNWFkZGUzMQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2019-02-10T21:01:24Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-02-10T21:01:24Z"}, "message": "libphobos: Apply core.internal.hash updates from druntime\n\nBackported from upstream druntime 2.084\n\nReviewed-on: https://github.com/dlang/druntime/pull/2469\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Remove rt/util/hash.d\n\t* libdruntime/Makefile.in: Rebuild.\n\t* testsuite/libphobos.aa/aa.exp: New file.\n\t* testsuite/libphobos.aa/test_aa.d: New test.\n\t* testsuite/libphobos.hash/hash.exp: New file.\n\t* testsuite/libphobos.hash/test_hash.d: New test.\n\nFrom-SVN: r268754", "tree": {"sha": "ab84eeb1414db276d7d507c01749431e7e3dcf6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab84eeb1414db276d7d507c01749431e7e3dcf6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e613d992667a90ff731bbcecbb4ae6fa15adde31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e613d992667a90ff731bbcecbb4ae6fa15adde31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e613d992667a90ff731bbcecbb4ae6fa15adde31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e613d992667a90ff731bbcecbb4ae6fa15adde31/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1b7b50affd1e9eea1f1e3be8a0804fd94fb6b39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1b7b50affd1e9eea1f1e3be8a0804fd94fb6b39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1b7b50affd1e9eea1f1e3be8a0804fd94fb6b39"}], "stats": {"total": 3998, "additions": 2630, "deletions": 1368}, "files": [{"sha": "2aa99a426f85924089a40d196f25cac7eb5a1572", "filename": "libphobos/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2FChangeLog?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -1,3 +1,12 @@\n+2019-02-10  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Remove rt/util/hash.d\n+\t* libdruntime/Makefile.in: Rebuild.\n+\t* testsuite/libphobos.aa/aa.exp: New file.\n+\t* testsuite/libphobos.aa/test_aa.d: New test.\n+\t* testsuite/libphobos.hash/hash.exp: New file.\n+\t* testsuite/libphobos.hash/test_hash.d: New test.\n+\n 2019-01-12  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* README.gcc: New file."}, {"sha": "2c8c70c83f2781adb99a54047a76e51e8db47cec", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -1,4 +1,4 @@\n-f2db21937e650553066c30f1a9d5a7d08a1b3573\n+cc215408bbdbc3324a95080aeef31287f663e57c\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "4894435510e1fa8243d1c44802fdb4ba45b86a9a", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -197,8 +197,8 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \trt/typeinfo/ti_ucent.d rt/typeinfo/ti_uint.d rt/typeinfo/ti_ulong.d \\\n \trt/typeinfo/ti_ushort.d rt/typeinfo/ti_void.d rt/typeinfo/ti_wchar.d \\\n \trt/util/array.d rt/util/container/array.d rt/util/container/common.d \\\n-\trt/util/container/hashtab.d rt/util/container/treap.d rt/util/hash.d \\\n-\trt/util/random.d rt/util/typeinfo.d rt/util/utf.d\n+\trt/util/container/hashtab.d rt/util/container/treap.d rt/util/random.d \\\n+\trt/util/typeinfo.d rt/util/utf.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/exception.d \\\n \tcore/stdcpp/typeinfo.d"}, {"sha": "0842862091f7ab3888d62b2e312800d787405377", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -229,8 +229,7 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \trt/typeinfo/ti_wchar.lo rt/util/array.lo \\\n \trt/util/container/array.lo rt/util/container/common.lo \\\n \trt/util/container/hashtab.lo rt/util/container/treap.lo \\\n-\trt/util/hash.lo rt/util/random.lo rt/util/typeinfo.lo \\\n-\trt/util/utf.lo\n+\trt/util/random.lo rt/util/typeinfo.lo rt/util/utf.lo\n am__objects_2 = gc/bits.lo gc/config.lo gc/gcinterface.lo \\\n \tgc/impl/conservative/gc.lo gc/impl/manual/gc.lo gc/os.lo \\\n \tgc/pooltable.lo gc/proxy.lo\n@@ -831,8 +830,8 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \trt/typeinfo/ti_ucent.d rt/typeinfo/ti_uint.d rt/typeinfo/ti_ulong.d \\\n \trt/typeinfo/ti_ushort.d rt/typeinfo/ti_void.d rt/typeinfo/ti_wchar.d \\\n \trt/util/array.d rt/util/container/array.d rt/util/container/common.d \\\n-\trt/util/container/hashtab.d rt/util/container/treap.d rt/util/hash.d \\\n-\trt/util/random.d rt/util/typeinfo.d rt/util/utf.d\n+\trt/util/container/hashtab.d rt/util/container/treap.d rt/util/random.d \\\n+\trt/util/typeinfo.d rt/util/utf.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/exception.d \\\n \tcore/stdcpp/typeinfo.d\n@@ -1256,7 +1255,6 @@ rt/util/container/array.lo: rt/util/container/$(am__dirstamp)\n rt/util/container/common.lo: rt/util/container/$(am__dirstamp)\n rt/util/container/hashtab.lo: rt/util/container/$(am__dirstamp)\n rt/util/container/treap.lo: rt/util/container/$(am__dirstamp)\n-rt/util/hash.lo: rt/util/$(am__dirstamp)\n rt/util/random.lo: rt/util/$(am__dirstamp)\n rt/util/typeinfo.lo: rt/util/$(am__dirstamp)\n rt/util/utf.lo: rt/util/$(am__dirstamp)"}, {"sha": "2b4fc31e3b5963840ef33d4331f86e6f94b80659", "filename": "libphobos/libdruntime/core/internal/convert.d", "status": "modified", "additions": 112, "deletions": 81, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -33,7 +33,7 @@ private ubyte[] ctfe_alloc()(size_t n)\n     }\n }\n \n-@trusted pure nothrow\n+@trusted pure nothrow @nogc\n const(ubyte)[] toUbyte(T)(const ref T val) if (is(Unqual!T == float) || is(Unqual!T == double) || is(Unqual!T == real) ||\n                                         is(Unqual!T == ifloat) || is(Unqual!T == idouble) || is(Unqual!T == ireal))\n {\n@@ -72,7 +72,7 @@ const(ubyte)[] toUbyte(T)(const ref T val) if (is(Unqual!T == float) || is(Unqua\n             ulong mantissa2 = parsed.mantissa2;\n             off_bytes--; // go back one, since mantissa only stored data in 56\n                          // bits, ie 7 bytes\n-            for(; off_bytes < FloatTraits!T.MANTISSA/8; ++off_bytes)\n+            for (; off_bytes < FloatTraits!T.MANTISSA/8; ++off_bytes)\n             {\n                 buff[off_bytes] = cast(ubyte)mantissa2;\n                 mantissa2 >>= 8;\n@@ -114,13 +114,13 @@ const(ubyte)[] toUbyte(T)(const ref T val) if (is(Unqual!T == float) || is(Unqua\n     }\n }\n \n-@safe pure nothrow\n+@safe pure nothrow @nogc\n private Float parse(bool is_denormalized = false, T)(T x) if (is(Unqual!T == ifloat) || is(Unqual!T == idouble) || is(Unqual!T == ireal))\n {\n     return parse(x.im);\n }\n \n-@safe pure nothrow\n+@safe pure nothrow @nogc\n private Float parse(bool is_denormalized = false, T:real)(T x_) if (floatFormat!T != FloatFormat.Real80)\n {\n     Unqual!T x = x_;\n@@ -178,7 +178,7 @@ private Float parse(bool is_denormalized = false, T:real)(T x_) if (floatFormat!\n     }\n }\n \n-@safe pure nothrow\n+@safe pure nothrow @nogc\n private Float parse(bool _ = false, T:real)(T x_) if (floatFormat!T == FloatFormat.Real80)\n {\n     Unqual!T x = x_;\n@@ -291,10 +291,10 @@ private template FloatTraits(T) if (floatFormat!T == FloatFormat.Quadruple)\n }\n \n \n-@safe pure nothrow\n+@safe pure nothrow @nogc\n private real binPow2(int pow)\n {\n-    static real binPosPow2(int pow) @safe pure nothrow\n+    static real binPosPow2(int pow) @safe pure nothrow @nogc\n     {\n         assert(pow > 0);\n \n@@ -319,14 +319,14 @@ private real binPow2(int pow)\n \n \n //Need in CTFE, because CTFE float and double expressions computed more precisely that run-time expressions.\n-@safe pure nothrow\n+@safe pure nothrow @nogc\n private ulong shiftrRound(ulong x)\n {\n     return (x >> 1) + (x & 1);\n }\n \n-@safe pure nothrow\n-private uint binLog2(T)(T x)\n+@safe pure nothrow @nogc\n+private uint binLog2(T)(const T x)\n {\n     assert(x > 0);\n     int max = 2 ^^ (FloatTraits!T.EXPONENT-1)-1;\n@@ -353,7 +353,7 @@ private uint binLog2(T)(T x)\n     return max;\n }\n \n-@safe pure nothrow\n+@safe pure nothrow @nogc\n private Float denormalizedMantissa(T)(T x, uint sign) if (floatFormat!T == FloatFormat.Real80)\n {\n     x *= 2.0L^^FloatTraits!T.MANTISSA;\n@@ -362,7 +362,7 @@ private Float denormalizedMantissa(T)(T x, uint sign) if (floatFormat!T == Float\n     return Float(fl.mantissa >> pow, 0, sign);\n }\n \n-@safe pure nothrow\n+@safe pure nothrow @nogc\n private Float denormalizedMantissa(T)(T x, uint sign)\n     if (floatFormat!T == FloatFormat.Float || floatFormat!T == FloatFormat.Double)\n {\n@@ -372,7 +372,7 @@ private Float denormalizedMantissa(T)(T x, uint sign)\n     return Float(shiftrRound(mant), 0, sign);\n }\n \n-@safe pure nothrow\n+@safe pure nothrow @nogc\n private Float denormalizedMantissa(T)(T x, uint sign) if (floatFormat!T == FloatFormat.Quadruple)\n {\n     x *= 2.0L^^FloatTraits!T.MANTISSA;\n@@ -568,21 +568,35 @@ template floatFormat(T) if (is(T:real) || is(T:ireal))\n }\n \n //  all toUbyte functions must be evaluable at compile time\n-@trusted pure nothrow\n-const(ubyte)[] toUbyte(T)(T[] arr) if (T.sizeof == 1)\n+@trusted pure nothrow @nogc\n+const(ubyte)[] toUbyte(T)(const T[] arr) if (T.sizeof == 1)\n {\n     return cast(const(ubyte)[])arr;\n }\n \n-@trusted pure nothrow\n-const(ubyte)[] toUbyte(T)(T[] arr) if ((is(typeof(toUbyte(arr[0])) == const(ubyte)[])) && (T.sizeof > 1))\n+@trusted pure nothrow @nogc\n+const(ubyte)[] toUbyte(T)(const T[] arr) if (T.sizeof > 1)\n {\n     if (__ctfe)\n     {\n-        const(ubyte)[] ret;\n-        foreach (cur; arr)\n+        ubyte[] ret = ctfe_alloc(T.sizeof * arr.length);\n+        static if (is(T EType == enum)) // Odd style is to avoid template instantiation in most cases.\n+            alias E = OriginalType!EType;\n+        else\n+            alias E = T;\n+        static if (is(E == struct) || is(E == union) || __traits(isStaticArray, E) || !is(typeof(arr[0] is null)))\n+        {\n+            size_t offset = 0;\n+            foreach (ref cur; arr)\n+            {\n+                ret[offset .. offset + T.sizeof] = toUbyte(cur)[0 .. T.sizeof];\n+                offset += T.sizeof;\n+            }\n+        }\n+        else\n         {\n-            ret ~= toUbyte(cur);\n+            foreach (cur; arr)\n+                assert(cur is null, \"Unable to compute byte representation of non-null pointer at compile time\");\n         }\n         return ret;\n     }\n@@ -592,14 +606,16 @@ const(ubyte)[] toUbyte(T)(T[] arr) if ((is(typeof(toUbyte(arr[0])) == const(ubyt\n     }\n }\n \n-@trusted pure nothrow\n-const(ubyte)[] toUbyte(T)(ref T val) if (__traits(isIntegral, T) && !is(T == enum))\n+@trusted pure nothrow @nogc\n+const(ubyte)[] toUbyte(T)(const ref T val) if (__traits(isIntegral, T) && !is(T == enum) && !is(T == __vector))\n {\n     static if (T.sizeof == 1)\n     {\n         if (__ctfe)\n         {\n-            return cast(const(ubyte)[])[val];\n+            ubyte[] result = ctfe_alloc(1);\n+            result[0] = cast(ubyte) val;\n+            return result;\n         }\n         else\n         {\n@@ -608,7 +624,7 @@ const(ubyte)[] toUbyte(T)(ref T val) if (__traits(isIntegral, T) && !is(T == enu\n     }\n     else if (__ctfe)\n     {\n-        ubyte[T.sizeof] tmp;\n+        ubyte[] tmp = ctfe_alloc(T.sizeof);\n         Unqual!T val_ = val;\n         for (size_t i = 0; i < T.sizeof; ++i)\n         {\n@@ -618,114 +634,129 @@ const(ubyte)[] toUbyte(T)(ref T val) if (__traits(isIntegral, T) && !is(T == enu\n             tmp[idx] = cast(ubyte)(val_&0xff);\n             val_ >>= 8;\n         }\n-        return tmp[].dup;\n+        return tmp;\n     }\n     else\n     {\n         return (cast(const(ubyte)*)(&val))[0 .. T.sizeof];\n     }\n }\n \n-@trusted pure nothrow\n-const(ubyte)[] toUbyte(T)(ref T val) if (is(Unqual!T == cfloat) || is(Unqual!T == cdouble) ||is(Unqual!T == creal))\n+@trusted pure nothrow @nogc\n+const(ubyte)[] toUbyte(T)(const ref T val) if (is(T == __vector))\n+{\n+    if (!__ctfe)\n+        return (cast(const ubyte*) &val)[0 .. T.sizeof];\n+    else static if (is(typeof(val[0]) : void))\n+        assert(0, \"Unable to compute byte representation of \" ~ T.stringof ~ \" at compile time.\");\n+    else\n+    {\n+        // This code looks like it should work in CTFE but it segfaults:\n+        //    auto a = val.array;\n+        //    return toUbyte(a);\n+        alias E = typeof(val[0]);\n+        ubyte[] result = ctfe_alloc(T.sizeof);\n+        for (size_t i = 0, j = 0; i < T.sizeof; i += E.sizeof, ++j)\n+        {\n+            result[i .. i + E.sizeof] = toUbyte(val[j]);\n+        }\n+        return result;\n+    }\n+}\n+\n+@trusted pure nothrow @nogc\n+const(ubyte)[] toUbyte(T)(const ref T val) if (is(Unqual!T == cfloat) || is(Unqual!T == cdouble) ||is(Unqual!T == creal))\n {\n     if (__ctfe)\n     {\n         auto re = val.re;\n         auto im = val.im;\n-        return (re.toUbyte() ~ im.toUbyte());\n+        auto a = re.toUbyte();\n+        auto b = im.toUbyte();\n+        ubyte[] result = ctfe_alloc(a.length + b.length);\n+        result[0 .. a.length] = a[0 .. a.length];\n+        result[a.length .. $] = b[0 .. b.length];\n+        return result;\n     }\n     else\n     {\n         return (cast(const(ubyte)*)&val)[0 .. T.sizeof];\n     }\n }\n \n-@trusted pure nothrow\n-const(ubyte)[] toUbyte(T)(ref T val) if (is(T == enum) && is(typeof(toUbyte(cast(V)val)) == const(ubyte)[]))\n+@trusted pure nothrow @nogc\n+const(ubyte)[] toUbyte(T)(const ref T val) if (is(T == enum))\n {\n     if (__ctfe)\n     {\n         static if (is(T V == enum)){}\n-        V e_val = val;\n-        return toUbyte(e_val);\n+        return toUbyte(cast(const V) val);\n     }\n     else\n     {\n         return (cast(const(ubyte)*)&val)[0 .. T.sizeof];\n     }\n }\n \n-private bool isNonReference(T)()\n+nothrow pure @safe unittest\n {\n-    static if (is(T == struct) || is(T == union))\n-    {\n-        return isNonReferenceStruct!T();\n-    }\n-    else static if (__traits(isStaticArray, T))\n-    {\n-      return isNonReference!(typeof(T.init[0]))();\n-    }\n-    else static if (is(T E == enum))\n-    {\n-      return isNonReference!(E)();\n-    }\n-    else static if (!__traits(isScalar, T))\n-    {\n-        return false;\n-    }\n-    else static if (is(T V : V*))\n-    {\n-        return false;\n-    }\n-    else static if (is(T == function))\n-    {\n-        return false;\n-    }\n-    else\n-    {\n-        return true;\n-    }\n+    // Issue 19008 - check toUbyte works on enums.\n+    enum Month : uint { jan = 1}\n+    Month m = Month.jan;\n+    const bytes = toUbyte(m);\n+    enum ctfe_works = (() => { Month x = Month.jan; return toUbyte(x).length > 0; })();\n }\n \n-private bool isNonReferenceStruct(T)() if (is(T == struct) || is(T == union))\n+@trusted pure nothrow @nogc\n+const(ubyte)[] toUbyte(T)(const ref T val) if (is(T == delegate) || is(T : V*, V) && __traits(getAliasThis, T).length == 0)\n {\n-    foreach (cur; T.init.tupleof)\n+    if (__ctfe)\n     {\n-        static if (!isNonReference!(typeof(cur))()) return false;\n+        if (val !is null) assert(0, \"Unable to compute byte representation of non-null pointer at compile time\");\n+        return ctfe_alloc(T.sizeof);\n+    }\n+    else\n+    {\n+        return (cast(const(ubyte)*)&val)[0 .. T.sizeof];\n     }\n-\n-    return true;\n }\n \n-@trusted pure nothrow\n-const(ubyte)[] toUbyte(T)(ref T val) if (is(T == struct) || is(T == union))\n+@trusted pure nothrow @nogc\n+const(ubyte)[] toUbyte(T)(const ref T val) if (is(T == struct) || is(T == union))\n {\n     if (__ctfe)\n     {\n-        ubyte[T.sizeof] bytes;\n-        foreach (key, cur; val.tupleof)\n+        ubyte[] bytes = ctfe_alloc(T.sizeof);\n+        foreach (key, ref cur; val.tupleof)\n         {\n-            alias CUR_TYPE = typeof(cur);\n-            static if (isNonReference!(CUR_TYPE)())\n-            {\n-                bytes[val.tupleof[key].offsetof .. val.tupleof[key].offsetof + cur.sizeof] = toUbyte(cur)[];\n-            }\n-            else static if (is(typeof(val.tupleof[key] is null)))\n+            static if (is(typeof(cur) EType == enum)) // Odd style is to avoid template instantiation in most cases.\n+                alias CurType = OriginalType!EType;\n+            else\n+                alias CurType = typeof(cur);\n+            static if (is(CurType == struct) || is(CurType == union) || __traits(isStaticArray, CurType) || !is(typeof(cur is null)))\n             {\n-                assert(val.tupleof[key] is null, \"Unable to compute byte representation of non-null reference field at compile time\");\n-                //skip, because val bytes are zeros\n+                bytes[val.tupleof[key].offsetof .. val.tupleof[key].offsetof + CurType.sizeof] = toUbyte(cur)[];\n             }\n             else\n             {\n-                //pragma(msg, \"is null: \", typeof(CUR_TYPE).stringof);\n-                assert(0, \"Unable to compute byte representation of \"~typeof(CUR_TYPE).stringof~\" field at compile time\");\n+                assert(cur is null, \"Unable to compute byte representation of non-null reference field at compile time\");\n+                //skip, because val bytes are zeros\n             }\n         }\n-        return bytes[].dup;\n+        return bytes;\n     }\n     else\n     {\n         return (cast(const(ubyte)*)&val)[0 .. T.sizeof];\n     }\n }\n+\n+// Strips off all `enum`s from type `T`.\n+// Perhaps move to core.internal.types.\n+private template OriginalType(T)\n+{\n+    static if (is(T EType == enum))\n+        alias OriginalType = .OriginalType!EType;\n+    else\n+        alias OriginalType = T;\n+}"}, {"sha": "5de559cf8b126ab3cd0604659e20169824426ab9", "filename": "libphobos/libdruntime/core/internal/hash.d", "status": "modified", "additions": 629, "deletions": 345, "changes": 974, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fhash.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fhash.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fhash.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -10,9 +10,198 @@\n module core.internal.hash;\n \n import core.internal.convert;\n+import core.internal.traits : allSatisfy;\n+\n+// If true ensure that positive zero and negative zero have the same hash.\n+// Historically typeid(float).getHash did this but hashOf(float) did not.\n+private enum floatCoalesceZeroes = true;\n+// If true ensure that all NaNs of the same floating point type have the same hash.\n+// Historically typeid(float).getHash didn't do this but hashOf(float) did.\n+private enum floatCoalesceNaNs = true;\n+\n+// If either of the above are true then no struct or array that contains the\n+// representation of a floating point number may be hashed with `bytesHash`.\n+\n+@nogc nothrow pure @safe unittest\n+{\n+    static if (floatCoalesceZeroes)\n+        assert(hashOf(+0.0) == hashOf(-0.0)); // Same hash for +0.0 and -0.0.\n+    static if (floatCoalesceNaNs)\n+        assert(hashOf(double.nan) == hashOf(-double.nan)); // Same hash for different NaN.\n+}\n+\n+private enum hasCallableToHash(T) = __traits(compiles,\n+    {\n+        size_t hash = ((T* x) => (*x).toHash())(null);\n+    });\n+\n+@nogc nothrow pure @safe unittest\n+{\n+    static struct S { size_t toHash() { return 4; } }\n+    assert(hasCallableToHash!S);\n+    assert(!hasCallableToHash!(shared const S));\n+}\n+\n+private enum isFinalClassWithAddressBasedHash(T) = __traits(isFinalClass, T)\n+    // Use __traits(compiles, ...) in case there are multiple overloads of `toHash`.\n+    && __traits(compiles, {static assert(&Object.toHash is &T.toHash);});\n+\n+@nogc nothrow pure @safe unittest\n+{\n+    static class C1 {}\n+    final static class C2 : C1 {}\n+    final static class C3 : C1 { override size_t toHash() const nothrow { return 1; }}\n+    static assert(!isFinalClassWithAddressBasedHash!Object);\n+    static assert(!isFinalClassWithAddressBasedHash!C1);\n+    static assert(isFinalClassWithAddressBasedHash!C2);\n+    static assert(!isFinalClassWithAddressBasedHash!C3);\n+}\n+\n+/+\n+Is it valid to calculate a hash code for T based on the bits of its\n+representation? Always false for interfaces, dynamic arrays, and\n+associative arrays. False for all classes except final classes that do\n+not override `toHash`.\n+\n+Note: according to the spec as of\n+https://github.com/dlang/dlang.org/commit/d66eff16491b0664c0fc00ba80a7aa291703f1f2\n+the contents of unnamed paddings between fields is undefined. Currently\n+this hashing implementation assumes that the padding contents (if any)\n+for all instances of `T` are the same. The correctness of this\n+assumption is yet to be verified.\n++/\n+private template canBitwiseHash(T)\n+{\n+    static if (is(T EType == enum))\n+        enum canBitwiseHash = .canBitwiseHash!EType;\n+    else static if (__traits(isFloating, T))\n+        enum canBitwiseHash = !(floatCoalesceZeroes || floatCoalesceNaNs);\n+    else static if (__traits(isScalar, T))\n+        enum canBitwiseHash = true;\n+    else static if (is(T == class))\n+    {\n+        enum canBitwiseHash = isFinalClassWithAddressBasedHash!T;\n+    }\n+    else static if (is(T == interface))\n+    {\n+        enum canBitwiseHash = false;\n+    }\n+    else static if (is(T == struct))\n+    {\n+        static if (hasCallableToHash!T || __traits(isNested, T))\n+            enum canBitwiseHash = false;\n+        else\n+            enum canBitwiseHash = allSatisfy!(.canBitwiseHash, typeof(T.tupleof));\n+    }\n+    else static if (is(T == union))\n+    {\n+        // Right now we always bytewise hash unions that lack callable `toHash`.\n+        enum canBitwiseHash = !hasCallableToHash!T;\n+    }\n+    else static if (is(T E : E[]))\n+    {\n+        static if (__traits(isStaticArray, T))\n+            enum canBitwiseHash = (T.length == 0) || .canBitwiseHash!E;\n+        else\n+            enum canBitwiseHash = false;\n+    }\n+    else static if (__traits(isAssociativeArray, T))\n+    {\n+        enum canBitwiseHash = false;\n+    }\n+    else\n+    {\n+        static assert(is(T == delegate) || is(T : void) || is(T : typeof(null)),\n+            \"Internal error: unanticipated type \"~T.stringof);\n+        enum canBitwiseHash = true;\n+    }\n+}\n+\n+// Overly restrictive for simplicity: has false negatives but no false positives.\n+private template useScopeConstPassByValue(T)\n+{\n+    static if (__traits(isScalar, T))\n+        enum useScopeConstPassByValue = true;\n+    else static if (is(T == class) || is(T == interface))\n+        // Overly restrictive for simplicity.\n+        enum useScopeConstPassByValue = isFinalClassWithAddressBasedHash!T;\n+    else static if (is(T == struct) || is(T == union))\n+    {\n+        // Overly restrictive for simplicity.\n+        enum useScopeConstPassByValue = T.sizeof <= (int[]).sizeof &&\n+            __traits(isPOD, T) && // \"isPOD\" just to check there's no dtor or postblit.\n+            canBitwiseHash!T; // We can't verify toHash doesn't leak.\n+    }\n+    else static if (is(T : E[], E))\n+    {\n+        static if (!__traits(isStaticArray, T))\n+            // Overly restrictive for simplicity.\n+            enum useScopeConstPassByValue = .useScopeConstPassByValue!E;\n+        else static if (T.length == 0)\n+            enum useScopeConstPassByValue = true;\n+        else\n+            enum useScopeConstPassByValue = T.sizeof <= (uint[]).sizeof\n+                && .useScopeConstPassByValue!(typeof(T.init[0]));\n+    }\n+    else static if (is(T : V[K], K, V))\n+    {\n+        // Overly restrictive for simplicity.\n+        enum useScopeConstPassByValue = .useScopeConstPassByValue!K\n+            && .useScopeConstPassByValue!V;\n+    }\n+    else\n+    {\n+        static assert(is(T == delegate) || is(T : void) || is(T : typeof(null)),\n+            \"Internal error: unanticipated type \"~T.stringof);\n+        enum useScopeConstPassByValue = true;\n+    }\n+}\n+\n+@safe unittest\n+{\n+    static assert(useScopeConstPassByValue!int);\n+    static assert(useScopeConstPassByValue!string);\n+\n+    static int ctr;\n+    static struct S1 { ~this() { ctr++; } }\n+    static struct S2 { this(this) { ctr++; } }\n+    static assert(!useScopeConstPassByValue!S1,\n+        \"Don't default pass by value a struct with a non-vacuous destructor.\");\n+    static assert(!useScopeConstPassByValue!S2,\n+        \"Don't default pass by value a struct with a non-vacuous postblit.\");\n+}\n+\n+//enum hash. CTFE depends on base type\n+size_t hashOf(T)(scope const T val)\n+if (is(T EType == enum) && useScopeConstPassByValue!EType)\n+{\n+    static if (is(T EType == enum)) //for EType\n+    {\n+        return hashOf(cast(const EType) val);\n+    }\n+    else\n+    {\n+        static assert(0);\n+    }\n+}\n \n //enum hash. CTFE depends on base type\n-size_t hashOf(T)(auto ref T val, size_t seed = 0) if (is(T == enum))\n+size_t hashOf(T)(scope const T val, size_t seed)\n+if (is(T EType == enum) && useScopeConstPassByValue!EType)\n+{\n+    static if (is(T EType == enum)) //for EType\n+    {\n+        return hashOf(cast(const EType) val, seed);\n+    }\n+    else\n+    {\n+        static assert(0);\n+    }\n+}\n+\n+//enum hash. CTFE depends on base type\n+size_t hashOf(T)(auto ref T val, size_t seed = 0)\n+if (is(T EType == enum) && !useScopeConstPassByValue!EType)\n {\n     static if (is(T EType == enum)) //for EType\n     {\n@@ -25,99 +214,273 @@ size_t hashOf(T)(auto ref T val, size_t seed = 0) if (is(T == enum))\n     }\n }\n \n-//CTFE ready (depends on base type). Can be merged with dynamic array hash\n-size_t hashOf(T)(auto ref T val, size_t seed = 0) if (!is(T == enum) && __traits(isStaticArray, T))\n+//CTFE ready (depends on base type).\n+size_t hashOf(T)(scope const auto ref T val, size_t seed = 0)\n+if (!is(T == enum) && __traits(isStaticArray, T) && canBitwiseHash!T)\n {\n-    size_t cur_hash = seed;\n-    foreach (ref cur; val)\n+    // FIXME:\n+    // We would like to to do this:\n+    //\n+    //static if (T.length == 0)\n+    //    return seed;\n+    //else static if (T.length == 1)\n+    //    return hashOf(val[0], seed);\n+    //else\n+    //    return bytesHashWithExactSizeAndAlignment!T(toUbyte(val), seed);\n+    //\n+    // ... but that's inefficient when using a runtime TypeInfo (introduces a branch)\n+    // and PR #2243 wants typeid(T).getHash(&val) to produce the same result as\n+    // hashOf(val).\n+    static if (T.length == 0)\n+    {\n+        return bytesHashAlignedBy!size_t((ubyte[]).init, seed);\n+    }\n+    static if (is(typeof(toUbyte(val)) == const(ubyte)[]))\n     {\n-        cur_hash = hashOf(cur, cur_hash);\n+        return bytesHashAlignedBy!T(toUbyte(val), seed);\n+    }\n+    else //Other types. CTFE unsupported\n+    {\n+        assert(!__ctfe, \"unable to compute hash of \"~T.stringof~\" at compile time\");\n+        return bytesHashAlignedBy!T((cast(const(ubyte)*) &val)[0 .. T.sizeof], seed);\n     }\n-    return cur_hash;\n }\n \n-//dynamic array hash\n+//CTFE ready (depends on base type).\n size_t hashOf(T)(auto ref T val, size_t seed = 0)\n+if (!is(T == enum) && __traits(isStaticArray, T) && !canBitwiseHash!T)\n+{\n+    // FIXME:\n+    // We would like to to do this:\n+    //\n+    //static if (T.length == 0)\n+    //    return seed;\n+    //else static if (T.length == 1)\n+    //    return hashOf(val[0], seed);\n+    //else\n+    //    /+ hash like a dynamic array +/\n+    //\n+    // ... but that's inefficient when using a runtime TypeInfo (introduces a branch)\n+    // and PR #2243 wants typeid(T).getHash(&val) to produce the same result as\n+    // hashOf(val).\n+    return hashOf(val[], seed);\n+}\n+\n+//dynamic array hash\n+size_t hashOf(T)(scope const T val, size_t seed = 0)\n if (!is(T == enum) && !is(T : typeof(null)) && is(T S: S[]) && !__traits(isStaticArray, T)\n-    && !is(T == struct) && !is(T == class) && !is(T == union))\n+    && !is(T == struct) && !is(T == class) && !is(T == union)\n+    && (__traits(isScalar, S) || canBitwiseHash!S))\n {\n     alias ElementType = typeof(val[0]);\n-    static if (is(ElementType == interface) || is(ElementType == class) ||\n-                   ((is(ElementType == struct) || is(ElementType == union))\n-                       && is(typeof(val[0].toHash()) == size_t)))\n-    //class or interface array or struct array with toHash(); CTFE depend on toHash() method\n+    static if (!canBitwiseHash!ElementType)\n     {\n         size_t hash = seed;\n-        foreach (o; val)\n+        foreach (ref o; val)\n         {\n-            hash = hashOf(o, hash);\n+            hash = hashOf(hashOf(o), hash); // double hashing to match TypeInfo.getHash\n         }\n         return hash;\n     }\n     else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))\n     //ubyteble array (arithmetic types and structs without toHash) CTFE ready for arithmetic types and structs without reference fields\n     {\n-        auto bytes = toUbyte(val);\n-        return bytesHash(bytes.ptr, bytes.length, seed);\n+        return bytesHashAlignedBy!ElementType(toUbyte(val), seed);\n     }\n     else //Other types. CTFE unsupported\n     {\n-        assert(!__ctfe, \"unable to compute hash of \"~T.stringof);\n-        return bytesHash(val.ptr, ElementType.sizeof*val.length, seed);\n+        assert(!__ctfe, \"unable to compute hash of \"~T.stringof~\" at compile time\");\n+        return bytesHashAlignedBy!ElementType((cast(const(ubyte)*) val.ptr)[0 .. ElementType.sizeof*val.length], seed);\n+    }\n+}\n+\n+//dynamic array hash\n+size_t hashOf(T)(T val, size_t seed = 0)\n+if (!is(T == enum) && !is(T : typeof(null)) && is(T S: S[]) && !__traits(isStaticArray, T)\n+    && !is(T == struct) && !is(T == class) && !is(T == union)\n+    && !(__traits(isScalar, S) || canBitwiseHash!S))\n+{\n+    size_t hash = seed;\n+    foreach (ref o; val)\n+    {\n+        hash = hashOf(hashOf(o), hash); // double hashing because TypeInfo.getHash doesn't allow to pass seed value\n     }\n+    return hash;\n+}\n+\n+//arithmetic type hash\n+@trusted @nogc nothrow pure\n+size_t hashOf(T)(scope const T val) if (!is(T == enum) && __traits(isArithmetic, T)\n+    && __traits(isIntegral, T) && T.sizeof <= size_t.sizeof && !is(T == __vector))\n+{\n+    return val;\n }\n \n //arithmetic type hash\n-@trusted nothrow pure\n-size_t hashOf(T)(auto ref T val, size_t seed = 0) if (!is(T == enum) && __traits(isArithmetic, T))\n+@trusted @nogc nothrow pure\n+size_t hashOf(T)(scope const T val, size_t seed) if (!is(T == enum) && __traits(isArithmetic, T)\n+    && __traits(isIntegral, T) && T.sizeof <= size_t.sizeof && !is(T == __vector))\n+{\n+    static if (size_t.sizeof < ulong.sizeof)\n+    {\n+        //MurmurHash3 32-bit single round\n+        enum uint c1 = 0xcc9e2d51;\n+        enum uint c2 = 0x1b873593;\n+        enum uint c3 = 0xe6546b64;\n+        enum uint r1 = 15;\n+        enum uint r2 = 13;\n+    }\n+    else\n+    {\n+        //Half of MurmurHash3 64-bit single round\n+        //(omits second interleaved update)\n+        enum ulong c1 = 0x87c37b91114253d5;\n+        enum ulong c2 = 0x4cf5ad432745937f;\n+        enum ulong c3 = 0x52dce729;\n+        enum uint r1 = 31;\n+        enum uint r2 = 27;\n+    }\n+    size_t h = c1 * val;\n+    h = (h << r1) | (h >>> (size_t.sizeof * 8 - r1));\n+    h = (h * c2) ^ seed;\n+    h = (h << r2) | (h >>> (size_t.sizeof * 8 - r2));\n+    return h * 5 + c3;\n+}\n+\n+//arithmetic type hash\n+@trusted @nogc nothrow pure\n+size_t hashOf(T)(scope const T val, size_t seed = 0) if (!is(T == enum) && __traits(isArithmetic, T)\n+    && (!__traits(isIntegral, T) || T.sizeof > size_t.sizeof) && !is(T == __vector))\n {\n     static if (__traits(isFloating, val))\n     {\n-        T data = (val != val) ? T.nan : val;\n-        auto bytes = toUbyte(data);\n-        return bytesHash(bytes.ptr, bytes.length, seed);\n+        static if (floatCoalesceZeroes || floatCoalesceNaNs)\n+        {\n+            import core.internal.traits : Unqual;\n+            Unqual!T data = val;\n+            // +0.0 and -0.0 become the same.\n+            static if (floatCoalesceZeroes && is(typeof(data = 0)))\n+                if (data == 0) data = 0;\n+            static if (floatCoalesceZeroes && is(typeof(data = 0.0i)))\n+                if (data == 0.0i) data = 0.0i;\n+            static if (floatCoalesceZeroes && is(typeof(data = 0.0 + 0.0i)))\n+            {\n+                if (data.re == 0.0) data = 0.0 + (data.im * 1.0i);\n+                if (data.im == 0.0i) data = data.re + 0.0i;\n+            }\n+            static if (floatCoalesceNaNs)\n+                if (data != data) data = T.nan; // All NaN patterns become the same.\n+        }\n+        else\n+        {\n+            alias data = val;\n+        }\n+\n+        static if (T.mant_dig == float.mant_dig && T.sizeof == uint.sizeof)\n+            return hashOf(*cast(const uint*) &data, seed);\n+        else static if (T.mant_dig == double.mant_dig && T.sizeof == ulong.sizeof)\n+            return hashOf(*cast(const ulong*) &data, seed);\n+        else\n+            return bytesHashWithExactSizeAndAlignment!T(toUbyte(data), seed);\n     }\n     else\n     {\n-        auto bytes = toUbyte(val);\n-        return bytesHash(bytes.ptr, bytes.length, seed);\n+        static assert(T.sizeof > size_t.sizeof && __traits(isIntegral, T));\n+        foreach (i; 0 .. T.sizeof / size_t.sizeof)\n+            seed = hashOf(cast(size_t) (val >>> (size_t.sizeof * 8 * i)), seed);\n+        return seed;\n     }\n }\n \n+size_t hashOf(T)(scope const auto ref T val, size_t seed = 0) @safe @nogc nothrow pure\n+if (is(T == __vector) && !is(T == enum))\n+{\n+    static if (__traits(isFloating, T) && (floatCoalesceZeroes || floatCoalesceNaNs))\n+    {\n+        if (__ctfe)\n+        {\n+            // Workaround for CTFE bug.\n+            alias E = Unqual!(typeof(val[0]));\n+            E[T.sizeof / E.sizeof] array;\n+            foreach (i; 0 .. T.sizeof / E.sizeof)\n+                array[i] = val[i];\n+            return hashOf(array, seed);\n+        }\n+        return hashOf(val.array, seed);\n+    }\n+    else\n+    {\n+        return bytesHashAlignedBy!T(toUbyte(val), seed);\n+    }\n+}\n+\n+//typeof(null) hash. CTFE supported\n+@trusted @nogc nothrow pure\n+size_t hashOf(T)(scope const T val) if (!is(T == enum) && is(T : typeof(null)))\n+{\n+    return 0;\n+}\n+\n //typeof(null) hash. CTFE supported\n-@trusted nothrow pure\n-size_t hashOf(T)(auto ref T val, size_t seed = 0) if (!is(T == enum) && is(T : typeof(null)))\n+@trusted @nogc nothrow pure\n+size_t hashOf(T)(scope const T val, size_t seed) if (!is(T == enum) && is(T : typeof(null)))\n {\n-    return hashOf(cast(void*)null);\n+    return hashOf(size_t(0), seed);\n }\n \n //Pointers hash. CTFE unsupported if not null\n-@trusted nothrow pure\n-size_t hashOf(T)(auto ref T val, size_t seed = 0)\n+@trusted @nogc nothrow pure\n+size_t hashOf(T)(scope const T val)\n if (!is(T == enum) && is(T V : V*) && !is(T : typeof(null))\n     && !is(T == struct) && !is(T == class) && !is(T == union))\n {\n     if (__ctfe)\n     {\n         if (val is null)\n         {\n-            return hashOf(cast(size_t)0);\n+            return 0;\n         }\n         else\n         {\n             assert(0, \"Unable to calculate hash of non-null pointer at compile time\");\n         }\n \n     }\n-    return hashOf(cast(size_t)val);\n+    auto addr = cast(size_t) val;\n+    return addr ^ (addr >>> 4);\n }\n \n-//struct or union hash\n-size_t hashOf(T)(auto ref T val, size_t seed = 0) if (!is(T == enum) && (is(T == struct) || is(T == union)))\n+//Pointers hash. CTFE unsupported if not null\n+@trusted @nogc nothrow pure\n+size_t hashOf(T)(scope const T val, size_t seed)\n+if (!is(T == enum) && is(T V : V*) && !is(T : typeof(null))\n+    && !is(T == struct) && !is(T == class) && !is(T == union))\n {\n-    static if (is(typeof(val.toHash()) == size_t)) //CTFE depends on toHash()\n+    if (__ctfe)\n+    {\n+        if (val is null)\n+        {\n+            return hashOf(cast(size_t)0, seed);\n+        }\n+        else\n+        {\n+            assert(0, \"Unable to calculate hash of non-null pointer at compile time\");\n+        }\n+\n+    }\n+    return hashOf(cast(size_t)val, seed);\n+}\n+\n+private enum _hashOfStruct =\n+q{\n+    enum bool isChained = is(typeof(seed) : size_t);\n+    static if (!isChained) enum size_t seed = 0;\n+    static if (hasCallableToHash!T) //CTFE depends on toHash()\n     {\n-        return hashOf(val.toHash(), seed);\n+        static if (isChained)\n+            return hashOf(cast(size_t) val.toHash(), seed);\n+        else\n+            return val.toHash();\n     }\n     else\n     {\n@@ -126,39 +489,171 @@ size_t hashOf(T)(auto ref T val, size_t seed = 0) if (!is(T == enum) && (is(T ==\n             pragma(msg, \"Warning: struct \"~__traits(identifier, T)~\" has method toHash, however it cannot be called with \"~T.stringof~\" this.\");\n         }\n \n-        static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields\n+        static if (T.tupleof.length == 0)\n+        {\n+            return seed;\n+        }\n+        else static if ((is(T == struct) && !canBitwiseHash!T) || T.tupleof.length == 1)\n         {\n-            auto bytes = toUbyte(val);\n-            return bytesHash(bytes.ptr, bytes.length, seed);\n+            size_t h = void;\n+            static if (isChained) h = seed;\n+            foreach (i, F; typeof(val.tupleof))\n+            {\n+                static if (__traits(isStaticArray, F))\n+                {\n+                    static if (i == 0 && !isChained) h = 0;\n+                    static if (F.sizeof > 0 && canBitwiseHash!F)\n+                        // May use smallBytesHash instead of bytesHash.\n+                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);\n+                    else\n+                        // We can avoid the \"double hashing\" the top-level version uses\n+                        // for consistency with TypeInfo.getHash.\n+                        foreach (ref e; val.tupleof[i])\n+                            h = hashOf(e, h);\n+                }\n+                else static if (is(F == struct) || is(F == union))\n+                {\n+                    static if (hasCallableToHash!F)\n+                    {\n+                        static if (i == 0 && !isChained)\n+                            h = val.tupleof[i].toHash();\n+                        else\n+                            h = hashOf(cast(size_t) val.tupleof[i].toHash(), h);\n+                    }\n+                    else static if (F.tupleof.length == 1)\n+                    {\n+                        // Handle the single member case separately to avoid unnecessarily using bytesHash.\n+                        static if (i == 0 && !isChained)\n+                            h = hashOf(val.tupleof[i].tupleof[0]);\n+                        else\n+                            h = hashOf(val.tupleof[i].tupleof[0], h);\n+                    }\n+                    else static if (canBitwiseHash!F)\n+                    {\n+                        // May use smallBytesHash instead of bytesHash.\n+                        static if (i == 0 && !isChained) h = 0;\n+                        h = bytesHashWithExactSizeAndAlignment!F(toUbyte(val.tupleof[i]), h);\n+                    }\n+                    else\n+                    {\n+                        // Nothing special happening.\n+                        static if (i == 0 && !isChained)\n+                            h = hashOf(val.tupleof[i]);\n+                        else\n+                            h = hashOf(val.tupleof[i], h);\n+                    }\n+                }\n+                else\n+                {\n+                    // Nothing special happening.\n+                    static if (i == 0 && !isChained)\n+                        h = hashOf(val.tupleof[i]);\n+                    else\n+                        h = hashOf(val.tupleof[i], h);\n+                }\n+            }\n+            return h;\n         }\n-        else // CTFE unsupproreted for structs with reference fields\n+        else static if (is(typeof(toUbyte(val)) == const(ubyte)[]))//CTFE ready for structs without reference fields\n         {\n-            assert(!__ctfe, \"unable to compute hash of \"~T.stringof);\n-            const(ubyte)[] bytes = (cast(const(ubyte)*)&val)[0 .. T.sizeof];\n-            return bytesHash(bytes.ptr, bytes.length, seed);\n+            // Not using bytesHashWithExactSizeAndAlignment here because\n+            // the result may differ from typeid(T).hashOf(&val).\n+            return bytesHashAlignedBy!T(toUbyte(val), seed);\n+        }\n+        else // CTFE unsupported\n+        {\n+            assert(!__ctfe, \"unable to compute hash of \"~T.stringof~\" at compile time\");\n+            const(ubyte)[] bytes = (() @trusted => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();\n+            // Not using bytesHashWithExactSizeAndAlignment here because\n+            // the result may differ from typeid(T).hashOf(&val).\n+            return bytesHashAlignedBy!T(bytes, seed);\n         }\n     }\n+};\n+\n+//struct or union hash\n+size_t hashOf(T)(scope const auto ref T val, size_t seed = 0)\n+if (!is(T == enum) && (is(T == struct) || is(T == union))\n+    && canBitwiseHash!T)\n+{\n+    mixin(_hashOfStruct);\n+}\n+\n+//struct or union hash\n+size_t hashOf(T)(auto ref T val)\n+if (!is(T == enum) && (is(T == struct) || is(T == union))\n+    && !canBitwiseHash!T)\n+{\n+    mixin(_hashOfStruct);\n+}\n+\n+//struct or union hash\n+size_t hashOf(T)(auto ref T val, size_t seed)\n+if (!is(T == enum) && (is(T == struct) || is(T == union))\n+    && !canBitwiseHash!T)\n+{\n+    mixin(_hashOfStruct);\n }\n \n //delegate hash. CTFE unsupported\n-@trusted nothrow pure\n-size_t hashOf(T)(auto ref T val, size_t seed = 0) if (!is(T == enum) && is(T == delegate))\n+@trusted @nogc nothrow pure\n+size_t hashOf(T)(scope const T val, size_t seed = 0) if (!is(T == enum) && is(T == delegate))\n {\n-    assert(!__ctfe, \"unable to compute hash of \"~T.stringof);\n+    assert(!__ctfe, \"unable to compute hash of \"~T.stringof~\" at compile time\");\n     const(ubyte)[] bytes = (cast(const(ubyte)*)&val)[0 .. T.sizeof];\n-    return bytesHash(bytes.ptr, bytes.length, seed);\n+    return bytesHashWithExactSizeAndAlignment!T(bytes, seed);\n+}\n+\n+//address-based class hash. CTFE only if null.\n+@nogc nothrow pure @trusted\n+size_t hashOf(T)(scope const T val)\n+if (!is(T == enum) && (is(T == interface) || is(T == class))\n+    && canBitwiseHash!T)\n+{\n+    if (__ctfe) if (val is null) return 0;\n+    return hashOf(cast(const void*) val);\n+}\n+\n+//address-based class hash. CTFE only if null.\n+@nogc nothrow pure @trusted\n+size_t hashOf(T)(scope const T val, size_t seed)\n+if (!is(T == enum) && (is(T == interface) || is(T == class))\n+    && canBitwiseHash!T)\n+{\n+    if (__ctfe) if (val is null) return hashOf(size_t(0), seed);\n+    return hashOf(cast(const void*) val, seed);\n }\n \n //class or interface hash. CTFE depends on toHash\n-size_t hashOf(T)(auto ref T val, size_t seed = 0) if (!is(T == enum) && is(T == interface) || is(T == class))\n+size_t hashOf(T)(T val)\n+if (!is(T == enum) && (is(T == interface) || is(T == class))\n+    && !canBitwiseHash!T)\n {\n-    return hashOf(val ? (cast(Object)val).toHash() : 0, seed);\n+    static if (__traits(compiles, {size_t h = val.toHash();}))\n+        return val ? val.toHash() : 0;\n+    else\n+        return val ? (cast(Object)val).toHash() : 0;\n+}\n+\n+//class or interface hash. CTFE depends on toHash\n+size_t hashOf(T)(T val, size_t seed)\n+if (!is(T == enum) && (is(T == interface) || is(T == class))\n+    && !canBitwiseHash!T)\n+{\n+    static if (__traits(compiles, {size_t h = val.toHash();}))\n+        return hashOf(val ? cast(size_t) val.toHash() : size_t(0), seed);\n+    else\n+        return hashOf(val ? (cast(Object)val).toHash() : 0, seed);\n }\n \n //associative array hash. CTFE depends on base types\n-size_t hashOf(T)(auto ref T aa, size_t seed = 0) if (!is(T == enum) && __traits(isAssociativeArray, T))\n+size_t hashOf(T)(T aa) if (!is(T == enum) && __traits(isAssociativeArray, T))\n {\n-    if (!aa.length) return hashOf(0, seed);\n+    static if (is(typeof(aa) : V[K], K, V)) {} // Put K & V in scope.\n+    static if (__traits(compiles, (ref K k, ref V v) nothrow => .hashOf(k) + .hashOf(v)))\n+        scope (failure) assert(0); // Allow compiler to infer nothrow.\n+\n+    if (!aa.length) return 0;\n     size_t h = 0;\n \n     // The computed hash is independent of the foreach traversal order.\n@@ -167,315 +662,81 @@ size_t hashOf(T)(auto ref T aa, size_t seed = 0) if (!is(T == enum) && __traits(\n         size_t[2] hpair;\n         hpair[0] = key.hashOf();\n         hpair[1] = val.hashOf();\n-        h ^= hpair.hashOf();\n+        h += hpair.hashOf();\n     }\n-    return h.hashOf(seed);\n+    return h;\n }\n \n-unittest\n+//associative array hash. CTFE depends on base types\n+size_t hashOf(T)(T aa, size_t seed) if (!is(T == enum) && __traits(isAssociativeArray, T))\n {\n-    static struct Foo\n-    {\n-        int a = 99;\n-        float b = 4.0;\n-        size_t toHash() const pure @safe nothrow\n-        {\n-            return a;\n-        }\n-    }\n-\n-    static struct Bar\n-    {\n-        char c = 'x';\n-        int a = 99;\n-        float b = 4.0;\n-        void* d = null;\n-    }\n-\n-    static struct Boom\n-    {\n-        char c = 'M';\n-        int* a = null;\n-    }\n-\n-    interface IBoo\n-    {\n-        void boo();\n-    }\n-\n-    static class Boo: IBoo\n-    {\n-        override void boo()\n-        {\n-        }\n-\n-        override size_t toHash()\n-        {\n-            return 1;\n-        }\n-    }\n-\n-    static struct Goo\n-    {\n-        size_t toHash() pure @safe nothrow\n-        {\n-            return 1;\n-        }\n-    }\n-\n-    enum Gun: long\n-    {\n-        A = 99,\n-        B = 17\n-    }\n-\n-    enum double dexpr = 3.14;\n-    enum float fexpr = 2.71;\n-    enum wstring wsexpr = \"abcdef\"w;\n-    enum string csexpr = \"abcdef\";\n-    enum int iexpr = 7;\n-    enum long lexpr = 42;\n-    enum int[2][3] saexpr = [[1, 2], [3, 4], [5, 6]];\n-    enum int[] daexpr = [7,8,9];\n-    enum Foo thsexpr = Foo();\n-    enum Bar vsexpr = Bar();\n-    enum int[int] aaexpr = [99:2, 12:6, 45:4];\n-    enum Gun eexpr = Gun.A;\n-    enum cdouble cexpr = 7+4i;\n-    enum Foo[] staexpr = [Foo(), Foo(), Foo()];\n-    enum Bar[] vsaexpr = [Bar(), Bar(), Bar()];\n-    enum realexpr = 7.88;\n-    enum raexpr = [8.99L+86i, 3.12L+99i, 5.66L+12i];\n-    enum nullexpr = null;\n-\n-    //No CTFE:\n-    Boom rstructexpr = Boom();\n-    Boom[] rstrarrexpr = [Boom(), Boom(), Boom()];\n-    int delegate() dgexpr  = (){return 78;};\n-    void* ptrexpr = &dgexpr;\n-\n-\n-    //CTFE hashes\n-    enum h1 = dexpr.hashOf();\n-    enum h2 = fexpr.hashOf();\n-    enum h3 = wsexpr.hashOf();\n-    enum h4 = csexpr.hashOf();\n-    enum h5 = iexpr.hashOf();\n-    enum h6 = lexpr.hashOf();\n-    enum h7 = saexpr.hashOf();\n-    enum h8 = daexpr.hashOf();\n-    enum h9 = thsexpr.hashOf();\n-    enum h10 = vsexpr.hashOf();\n-    enum h11 = aaexpr.hashOf();\n-    enum h12 = eexpr.hashOf();\n-    enum h13 = cexpr.hashOf();\n-    enum h14 = hashOf(new Boo);\n-    enum h15 = staexpr.hashOf();\n-    enum h16 = hashOf([new Boo, new Boo, new Boo]);\n-    enum h17 = hashOf([cast(IBoo)new Boo, cast(IBoo)new Boo, cast(IBoo)new Boo]);\n-    enum h18 = hashOf(cast(IBoo)new Boo);\n-    enum h19 = vsaexpr.hashOf();\n-    enum h20 = hashOf(cast(Foo[3])staexpr);\n-\n-    //BUG: cannot cast [Boo(), Boo(), Boo()][0] to object.Object at compile time\n-    auto h21 = hashOf(cast(Boo[3])[new Boo, new Boo, new Boo]);\n-    auto h22 = hashOf(cast(IBoo[3])[cast(IBoo)new Boo, cast(IBoo)new Boo, cast(IBoo)new Boo]);\n-    enum h23 = hashOf(cast(Bar[3])vsaexpr);\n-\n-    //NO CTFE (Compute, but don't check correctness):\n-    auto h24 = rstructexpr.hashOf();\n-    auto h25 = rstrarrexpr.hashOf();\n-    auto h26 = dgexpr.hashOf();\n-    auto h27 = ptrexpr.hashOf();\n-\n-    enum h28 = realexpr.hashOf();\n-    enum h29 = raexpr.hashOf();\n-    enum h30 = nullexpr.hashOf();\n-\n-    auto v1 = dexpr;\n-    auto v2 = fexpr;\n-    auto v3 = wsexpr;\n-    auto v4 = csexpr;\n-    auto v5 = iexpr;\n-    auto v6 = lexpr;\n-    auto v7 = saexpr;\n-    auto v8 = daexpr;\n-    auto v9 = thsexpr;\n-    auto v10 = vsexpr;\n-    auto v11 = aaexpr;\n-    auto v12 = eexpr;\n-    auto v13 = cexpr;\n-    auto v14 = new Boo;\n-    auto v15 = staexpr;\n-    auto v16 = [new Boo, new Boo, new Boo];\n-    auto v17 = [cast(IBoo)new Boo, cast(IBoo)new Boo, cast(IBoo)new Boo];\n-    auto v18 = cast(IBoo)new Boo;\n-    auto v19 = vsaexpr;\n-    auto v20 = cast(Foo[3])staexpr;\n-    auto v21 = cast(Boo[3])[new Boo, new Boo, new Boo];\n-    auto v22 = cast(IBoo[3])[cast(IBoo)new Boo, cast(IBoo)new Boo, cast(IBoo)new Boo];\n-    auto v23 = cast(Bar[3])vsaexpr;\n-    auto v30 = null;\n-\n-    //NO CTFE:\n-    /*auto v24 = rstructexpr;\n-    auto v25 = rstrarrexpr;\n-    auto v26 = dgexpr;\n-    auto v27 = ptrexpr;\n-    auto v28 = realexpr;\n-    auto v29 = raexpr;*/\n-\n-    //runtime hashes\n-    auto rth1 = hashOf(v1);\n-    auto rth2 = hashOf(v2);\n-    auto rth3 = hashOf(v3);\n-    auto rth4 = hashOf(v4);\n-    auto rth5 = hashOf(v5);\n-    auto rth6 = hashOf(v6);\n-    auto rth7 = hashOf(v7);\n-    auto rth8 = hashOf(v8);\n-    auto rth9 = hashOf(v9);\n-    auto rth10 = hashOf(v10);\n-    auto rth11 = hashOf(v11);\n-    auto rth12 = hashOf(v12);\n-    auto rth13 = hashOf(v13);\n-    auto rth14 = hashOf(v14);\n-    auto rth15 = hashOf(v15);\n-    auto rth16 = hashOf(v16);\n-    auto rth17 = hashOf(v17);\n-    auto rth18 = hashOf(v18);\n-    auto rth19 = hashOf(v19);\n-    auto rth20 = hashOf(v20);\n-    auto rth21 = hashOf(v21);\n-    auto rth22 = hashOf(v22);\n-    auto rth23 = hashOf(v23);\n-    auto rth30 = hashOf(v30);\n-    /*//NO CTFE:\n-    auto rth24 = hashOf(v24);\n-    auto rth25 = hashOf(v25);\n-    auto rth26 = hashOf(v26);\n-    auto rth27 = hashOf(v27);\n-    auto rth28 = hashOf(v28);\n-    auto rth29 = hashOf(v29);*/\n-\n-    assert(h1 == rth1);\n-    assert(h2 == rth2);\n-    assert(h3 == rth3);\n-    assert(h4 == rth4);\n-    assert(h5 == rth5);\n-    assert(h6 == rth6);\n-    assert(h7 == rth7);\n-    assert(h8 == rth8);\n-    assert(h9 == rth9);\n-    assert(h10 == rth10);\n-    assert(h11 == rth11);\n-    assert(h12 == rth12);\n-    assert(h13 == rth13);\n-    assert(h14 == rth14);\n-    assert(h15 == rth15);\n-    assert(h16 == rth16);\n-    assert(h17 == rth17);\n-    assert(h18 == rth18);\n-    assert(h19 == rth19);\n-    assert(h20 == rth20);\n-    assert(h21 == rth21);\n-    assert(h22 == rth22);\n-    assert(h23 == rth23);\n-    /*assert(h24 == rth24);\n-    assert(h25 == rth25);\n-    assert(h26 == rth26);\n-    assert(h27 == rth27);\n-    assert(h28 == rth28);\n-    assert(h29 == rth29);*/\n-    assert(h30 == rth30);\n-}\n-\n-\n-unittest // issue 15111\n-{\n-    void testAlias(T)()\n-    {\n-        static struct Foo\n-        {\n-            T t;\n-            alias t this;\n-        }\n-        Foo foo;\n-        static assert(is(typeof(hashOf(foo))));\n-    }\n-    // was fixed\n-    testAlias!(int[]);\n-    testAlias!(int*);\n-    // was not affected\n-    testAlias!int;\n-    testAlias!(void delegate());\n-    testAlias!(string[string]);\n-    testAlias!(int[8]);\n+    return hashOf(hashOf(aa), seed);\n }\n \n // MurmurHash3 was written by Austin Appleby, and is placed in the public\n // domain. The author hereby disclaims copyright to this source code.\n \n-version (X86)\n-    version = AnyX86;\n-version (X86_64)\n-    version = AnyX86;\n+// This overload is for backwards compatibility.\n+@system pure nothrow @nogc\n+size_t bytesHash()(scope const(void)* buf, size_t len, size_t seed)\n+{\n+    return bytesHashAlignedBy!ubyte((cast(const(ubyte)*) buf)[0 .. len], seed);\n+}\n \n-version (AnyX86)\n+private template bytesHashAlignedBy(AlignType)\n {\n-    version (DigitalMars)\n-    {\n-    }\n-    else\n-    {\n-        version = HasUnalignedOps;\n-    }\n+    alias bytesHashAlignedBy = bytesHash!(AlignType.alignof >= uint.alignof);\n }\n \n+private template bytesHashWithExactSizeAndAlignment(SizeAndAlignType)\n+{\n+    static if (SizeAndAlignType.alignof < uint.alignof\n+            ? SizeAndAlignType.sizeof <= 12\n+            : SizeAndAlignType.sizeof <= 10)\n+        alias bytesHashWithExactSizeAndAlignment = smallBytesHash;\n+    else\n+        alias bytesHashWithExactSizeAndAlignment = bytesHashAlignedBy!SizeAndAlignType;\n+}\n \n-@system pure nothrow @nogc\n-size_t bytesHash(const(void)* buf, size_t len, size_t seed)\n+// Fowler/Noll/Vo hash. http://www.isthe.com/chongo/tech/comp/fnv/\n+private size_t fnv()(scope const(ubyte)[] bytes, size_t seed) @nogc nothrow pure @safe\n {\n-    static uint rotl32(uint n)(in uint x) pure nothrow @safe @nogc\n-    {\n-        return (x << n) | (x >> (32 - n));\n-    }\n+    static if (size_t.max <= uint.max)\n+        enum prime = (1U << 24) + (1U << 8) + 0x93U;\n+    else static if (size_t.max <= ulong.max)\n+        enum prime = (1UL << 40) + (1UL << 8) + 0xb3UL;\n+    else\n+        enum prime = (size_t(1) << 88) + (size_t(1) << 8) + size_t(0x3b);\n+    foreach (b; bytes)\n+        seed = (seed ^ b) * prime;\n+    return seed;\n+}\n+private alias smallBytesHash = fnv;\n \n-    //-----------------------------------------------------------------------------\n-    // Block read - if your platform needs to do endian-swapping or can only\n-    // handle aligned reads, do the conversion here\n-    static uint get32bits(const (ubyte)* x) pure nothrow @nogc\n+//-----------------------------------------------------------------------------\n+// Block read - if your platform needs to do endian-swapping or can only\n+// handle aligned reads, do the conversion here\n+private uint get32bits()(scope const(ubyte)* x) @nogc nothrow pure @system\n+{\n+    version (BigEndian)\n     {\n-        //Compiler can optimize this code to simple *cast(uint*)x if it possible.\n-        version (HasUnalignedOps)\n-        {\n-            if (!__ctfe)\n-                return *cast(uint*)x; //BUG: Can't be inlined by DMD\n-        }\n-        version (BigEndian)\n-        {\n-            return ((cast(uint) x[0]) << 24) | ((cast(uint) x[1]) << 16) | ((cast(uint) x[2]) << 8) | (cast(uint) x[3]);\n-        }\n-        else\n-        {\n-            return ((cast(uint) x[3]) << 24) | ((cast(uint) x[2]) << 16) | ((cast(uint) x[1]) << 8) | (cast(uint) x[0]);\n-        }\n+        return ((cast(uint) x[0]) << 24) | ((cast(uint) x[1]) << 16) | ((cast(uint) x[2]) << 8) | (cast(uint) x[3]);\n     }\n-\n-    //-----------------------------------------------------------------------------\n-    // Finalization mix - force all bits of a hash block to avalanche\n-    static uint fmix32(uint h) pure nothrow @safe @nogc\n+    else\n     {\n-        h ^= h >> 16;\n-        h *= 0x85ebca6b;\n-        h ^= h >> 13;\n-        h *= 0xc2b2ae35;\n-        h ^= h >> 16;\n-\n-        return h;\n+        return ((cast(uint) x[3]) << 24) | ((cast(uint) x[2]) << 16) | ((cast(uint) x[1]) << 8) | (cast(uint) x[0]);\n     }\n+}\n \n-    auto data = cast(const(ubyte)*)buf;\n+/+\n+Params:\n+    dataKnownToBeAligned = whether the data is known at compile time to be uint-aligned.\n++/\n+@nogc nothrow pure @trusted\n+private size_t bytesHash(bool dataKnownToBeAligned)(scope const(ubyte)[] bytes, size_t seed)\n+{\n+    auto len = bytes.length;\n+    auto data = bytes.ptr;\n     auto nblocks = len / 4;\n \n     uint h1 = cast(uint)seed;\n@@ -489,13 +750,16 @@ size_t bytesHash(const(void)* buf, size_t len, size_t seed)\n     auto end_data = data+nblocks*uint.sizeof;\n     for (; data!=end_data; data += uint.sizeof)\n     {\n-        uint k1 = get32bits(data);\n+        static if (dataKnownToBeAligned)\n+            uint k1 = __ctfe ? get32bits(data) : *(cast(const uint*) data);\n+        else\n+            uint k1 = get32bits(data);\n         k1 *= c1;\n-        k1 = rotl32!15(k1);\n+        k1 = (k1 << 15) | (k1 >> (32 - 15));\n         k1 *= c2;\n \n         h1 ^= k1;\n-        h1 = rotl32!13(h1);\n+        h1 = (h1 << 13) | (h1 >> (32 - 13));\n         h1 = h1*5+c3;\n     }\n \n@@ -508,15 +772,18 @@ size_t bytesHash(const(void)* buf, size_t len, size_t seed)\n         case 3: k1 ^= data[2] << 16; goto case;\n         case 2: k1 ^= data[1] << 8;  goto case;\n         case 1: k1 ^= data[0];\n-                k1 *= c1; k1 = rotl32!15(k1); k1 *= c2; h1 ^= k1;\n+                k1 *= c1; k1 = (k1 << 15) | (k1 >> (32 - 15)); k1 *= c2; h1 ^= k1;\n                 goto default;\n         default:\n     }\n \n     //----------\n     // finalization\n     h1 ^= len;\n-    h1 = fmix32(h1);\n+    // Force all bits of the hash block to avalanche.\n+    h1 = (h1 ^ (h1 >> 16)) * 0x85ebca6b;\n+    h1 = (h1 ^ (h1 >> 13)) * 0xc2b2ae35;\n+    h1 ^= h1 >> 16;\n     return h1;\n }\n \n@@ -531,4 +798,21 @@ pure nothrow @system @nogc unittest\n     enum test_str = \"Sample string\";\n     enum size_t hashVal = ctfeHash(test_str);\n     assert(hashVal == bytesHash(&test_str[0], test_str.length, 0));\n+\n+    // Detect unintended changes to bytesHash on unaligned and aligned inputs.\n+    version (BigEndian)\n+    {\n+        const ubyte[7] a = [99, 4, 3, 2, 1, 5, 88];\n+        const uint[2] b = [0x04_03_02_01, 0x05_ff_ff_ff];\n+    }\n+    else\n+    {\n+        const ubyte[7] a = [99, 1, 2, 3, 4, 5, 88];\n+        const uint[2] b = [0x04_03_02_01, 0xff_ff_ff_05];\n+    }\n+    // It is okay to change the below values if you make a change\n+    // that you expect to change the result of bytesHash.\n+    assert(bytesHash(&a[1], a.length - 2, 0) == 2727459272);\n+    assert(bytesHash(&b, 5, 0) == 2727459272);\n+    assert(bytesHashAlignedBy!uint((cast(const ubyte*) &b)[0 .. 5], 0) == 2727459272);\n }"}, {"sha": "d57868080541dae2289fac810bd7d87910e8edad", "filename": "libphobos/libdruntime/core/internal/traits.d", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -128,6 +128,30 @@ template dtorIsNothrow(T)\n     enum dtorIsNothrow = is(typeof(function{T t=void;}) : void function() nothrow);\n }\n \n+/*\n+Tests whether all given items satisfy a template predicate, i.e. evaluates to\n+$(D F!(T[0]) && F!(T[1]) && ... && F!(T[$ - 1])).\n+*/\n+package(core.internal)\n+template allSatisfy(alias F, T...)\n+{\n+    static if (T.length == 0)\n+    {\n+        enum allSatisfy = true;\n+    }\n+    else static if (T.length == 1)\n+    {\n+        enum allSatisfy = F!(T[0]);\n+    }\n+    else\n+    {\n+        static if (allSatisfy!(F, T[0  .. $/2]))\n+            enum allSatisfy = allSatisfy!(F, T[$/2 .. $]);\n+        else\n+            enum allSatisfy = false;\n+    }\n+}\n+\n template anySatisfy(alias F, T...)\n {\n     static if (T.length == 0)"}, {"sha": "38bd0ae1f6b7ae7bff8686c006faf3488ab68b66", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 268, "deletions": 425, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -63,7 +63,15 @@ class Object\n     size_t toHash() @trusted nothrow\n     {\n         // BUG: this prevents a compacting GC from working, needs to be fixed\n-        return cast(size_t)cast(void*)this;\n+        size_t addr = cast(size_t) cast(void*) this;\n+        // The bottom log2((void*).alignof) bits of the address will always\n+        // be 0. Moreover it is likely that each Object is allocated with a\n+        // separate call to malloc. The alignment of malloc differs from\n+        // platform to platform, but rather than having special cases for\n+        // each platform it is safe to use a shift of 4. To minimize\n+        // collisions in the low bits it is more important for the shift to\n+        // not be too small than for the shift to not be too big.\n+        return addr ^ (addr >>> 4);\n     }\n \n     /**\n@@ -209,10 +217,7 @@ class TypeInfo\n \n     override size_t toHash() @trusted const nothrow\n     {\n-        import core.internal.traits : externDFunc;\n-        alias hashOf = externDFunc!(\"rt.util.hash.hashOf\",\n-                                    size_t function(const(void)[], size_t) @trusted pure nothrow @nogc);\n-        return hashOf(this.toString(), 0);\n+        return hashOf(this.toString());\n     }\n \n     override int opCmp(Object o)\n@@ -250,7 +255,10 @@ class TypeInfo\n      * Bugs:\n      *    fix https://issues.dlang.org/show_bug.cgi?id=12516 e.g. by changing this to a truly safe interface.\n      */\n-    size_t getHash(in void* p) @trusted nothrow const { return cast(size_t)p; }\n+    size_t getHash(scope const void* p) @trusted nothrow const\n+    {\n+        return hashOf(p);\n+    }\n \n     /// Compares two instances for equality.\n     bool equals(in void* p1, in void* p2) const { return p1 == p2; }\n@@ -327,7 +335,7 @@ class TypeInfo_Enum : TypeInfo\n                     this.base == c.base;\n     }\n \n-    override size_t getHash(in void* p) const { return base.getHash(p); }\n+    override size_t getHash(scope const void* p) const { return base.getHash(p); }\n     override bool equals(in void* p1, in void* p2) const { return base.equals(p1, p2); }\n     override int compare(in void* p1, in void* p2) const { return base.compare(p1, p2); }\n     override @property size_t tsize() nothrow pure const { return base.tsize; }\n@@ -375,9 +383,10 @@ class TypeInfo_Pointer : TypeInfo\n         return c && this.m_next == c.m_next;\n     }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n-        return cast(size_t)*cast(void**)p;\n+        size_t addr = cast(size_t) *cast(const void**)p;\n+        return addr ^ (addr >> 4);\n     }\n \n     override bool equals(in void* p1, in void* p2) const\n@@ -430,7 +439,7 @@ class TypeInfo_Array : TypeInfo\n         return c && this.value == c.value;\n     }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         void[] a = *cast(void[]*)p;\n         return getArrayHash(value, a.ptr, a.length);\n@@ -529,7 +538,7 @@ class TypeInfo_StaticArray : TypeInfo\n                     this.value == c.value;\n     }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         return getArrayHash(value, p, len);\n     }\n@@ -655,7 +664,7 @@ class TypeInfo_AssociativeArray : TypeInfo\n         return !!_aaEqual(this, *cast(const void**) p1, *cast(const void**) p2);\n     }\n \n-    override hash_t getHash(in void* p) nothrow @trusted const\n+    override hash_t getHash(scope const void* p) nothrow @trusted const\n     {\n         return _aaGetHash(cast(void*)p, this);\n     }\n@@ -702,7 +711,7 @@ class TypeInfo_Vector : TypeInfo\n         return c && this.base == c.base;\n     }\n \n-    override size_t getHash(in void* p) const { return base.getHash(p); }\n+    override size_t getHash(scope const void* p) const { return base.getHash(p); }\n     override bool equals(in void* p1, in void* p2) const { return base.equals(p1, p2); }\n     override int compare(in void* p1, in void* p2) const { return base.compare(p1, p2); }\n     override @property size_t tsize() nothrow pure const { return base.tsize; }\n@@ -796,7 +805,7 @@ class TypeInfo_Delegate : TypeInfo\n         return c && this.deco == c.deco;\n     }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         return hashOf(*cast(void delegate()*)p);\n     }\n@@ -851,34 +860,6 @@ class TypeInfo_Delegate : TypeInfo\n     }\n }\n \n-unittest\n-{\n-    // Bugzilla 15367\n-    void f1() {}\n-    void f2() {}\n-\n-    // TypeInfo_Delegate.getHash\n-    int[void delegate()] aa;\n-    assert(aa.length == 0);\n-    aa[&f1] = 1;\n-    assert(aa.length == 1);\n-    aa[&f1] = 1;\n-    assert(aa.length == 1);\n-\n-    auto a1 = [&f2, &f1];\n-    auto a2 = [&f2, &f1];\n-\n-    // TypeInfo_Delegate.equals\n-    for (auto i = 0; i < 2; i++)\n-        assert(a1[i] == a2[i]);\n-    assert(a1 == a2);\n-\n-    // TypeInfo_Delegate.compare\n-    for (auto i = 0; i < 2; i++)\n-        assert(a1[i] <= a2[i]);\n-    assert(a1 <= a2);\n-}\n-\n /**\n  * Runtime type information about a class.\n  * Can be retrieved from an object instance by using the\n@@ -896,7 +877,7 @@ class TypeInfo_Class : TypeInfo\n         return c && this.info.name == c.info.name;\n     }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         auto o = *cast(Object*)p;\n         return o ? o.toHash() : 0;\n@@ -1051,8 +1032,12 @@ class TypeInfo_Interface : TypeInfo\n         return c && this.info.name == typeid(c).name;\n     }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n+        if (!*cast(void**)p)\n+        {\n+            return 0;\n+        }\n         Interface* pi = **cast(Interface ***)*cast(void**)p;\n         Object o = cast(Object)(*cast(void**)p - pi.offset);\n         assert(o);\n@@ -1121,7 +1106,7 @@ class TypeInfo_Struct : TypeInfo\n                     this.initializer().length == s.initializer().length;\n     }\n \n-    override size_t getHash(in void* p) @trusted pure nothrow const\n+    override size_t getHash(scope const void* p) @trusted pure nothrow const\n     {\n         assert(p);\n         if (xtoHash)\n@@ -1130,10 +1115,7 @@ class TypeInfo_Struct : TypeInfo\n         }\n         else\n         {\n-            import core.internal.traits : externDFunc;\n-            alias hashOf = externDFunc!(\"rt.util.hash.hashOf\",\n-                                        size_t function(const(void)[], size_t) @trusted pure nothrow @nogc);\n-            return hashOf(p[0 .. initializer().length], 0);\n+            return hashOf(p[0 .. initializer().length]);\n         }\n     }\n \n@@ -1310,7 +1292,7 @@ class TypeInfo_Tuple : TypeInfo\n         return false;\n     }\n \n-    override size_t getHash(in void* p) const\n+    override size_t getHash(scope const void* p) const\n     {\n         assert(0);\n     }\n@@ -1381,7 +1363,7 @@ class TypeInfo_Const : TypeInfo\n         return base.opEquals(t.base);\n     }\n \n-    override size_t getHash(in void *p) const { return base.getHash(p); }\n+    override size_t getHash(scope const void *p) const { return base.getHash(p); }\n     override bool equals(in void *p1, in void *p2) const { return base.equals(p1, p2); }\n     override int compare(in void *p1, in void *p2) const { return base.compare(p1, p2); }\n     override @property size_t tsize() nothrow pure const { return base.tsize; }\n@@ -1882,6 +1864,7 @@ extern (C)\n \n     // size_t _aaLen(in void* p) pure nothrow @nogc;\n     private void* _aaGetY(void** paa, const TypeInfo_AssociativeArray ti, in size_t valuesize, in void* pkey) pure nothrow;\n+    private void* _aaGetX(void** paa, const TypeInfo_AssociativeArray ti, in size_t valuesize, in void* pkey, out bool found) pure nothrow;\n     // inout(void)* _aaGetRvalueX(inout void* p, in TypeInfo keyti, in size_t valuesize, in void* pkey);\n     inout(void)[] _aaValues(inout void* p, in size_t keysize, in size_t valuesize, const TypeInfo tiValArray) pure nothrow;\n     inout(void)[] _aaKeys(inout void* p, in size_t keysize, const TypeInfo tiKeyArray) pure nothrow;\n@@ -1895,11 +1878,11 @@ extern (C)\n     // int _aaApply2(void* aa, size_t keysize, _dg2_t dg);\n \n     private struct AARange { void* impl; size_t idx; }\n-    AARange _aaRange(void* aa) pure nothrow @nogc;\n-    bool _aaRangeEmpty(AARange r) pure nothrow @nogc;\n-    void* _aaRangeFrontKey(AARange r) pure nothrow @nogc;\n-    void* _aaRangeFrontValue(AARange r) pure nothrow @nogc;\n-    void _aaRangePopFront(ref AARange r) pure nothrow @nogc;\n+    AARange _aaRange(void* aa) pure nothrow @nogc @safe;\n+    bool _aaRangeEmpty(AARange r) pure nothrow @nogc @safe;\n+    void* _aaRangeFrontKey(AARange r) pure nothrow @nogc @safe;\n+    void* _aaRangeFrontValue(AARange r) pure nothrow @nogc @safe;\n+    void _aaRangePopFront(ref AARange r) pure nothrow @nogc @safe;\n \n     int _aaEqual(in TypeInfo tiRaw, in void* e1, in void* e2);\n     hash_t _aaGetHash(in void* aa, in TypeInfo tiRaw) nothrow;\n@@ -1920,40 +1903,63 @@ void* aaLiteral(Key, Value)(Key[] keys, Value[] values) @trusted pure\n \n alias AssociativeArray(Key, Value) = Value[Key];\n \n+/***********************************\n+ * Removes all remaining keys and values from an associative array.\n+ * Params:\n+ *      aa =     The associative array.\n+ */\n void clear(T : Value[Key], Value, Key)(T aa)\n {\n     _aaClear(*cast(void **) &aa);\n }\n \n+/* ditto */\n void clear(T : Value[Key], Value, Key)(T* aa)\n {\n     _aaClear(*cast(void **) aa);\n }\n \n+/***********************************\n+ * Reorganizes the associative array in place so that lookups are more\n+ * efficient.\n+ * Params:\n+ *      aa =     The associative array.\n+ * Returns:\n+ *      The rehashed associative array.\n+ */\n T rehash(T : Value[Key], Value, Key)(T aa)\n {\n     _aaRehash(cast(void**)&aa, typeid(Value[Key]));\n     return aa;\n }\n \n+/* ditto */\n T rehash(T : Value[Key], Value, Key)(T* aa)\n {\n     _aaRehash(cast(void**)aa, typeid(Value[Key]));\n     return *aa;\n }\n \n+/* ditto */\n T rehash(T : shared Value[Key], Value, Key)(T aa)\n {\n     _aaRehash(cast(void**)&aa, typeid(Value[Key]));\n     return aa;\n }\n \n+/* ditto */\n T rehash(T : shared Value[Key], Value, Key)(T* aa)\n {\n     _aaRehash(cast(void**)aa, typeid(Value[Key]));\n     return *aa;\n }\n \n+/***********************************\n+ * Create a new associative array of the same size and copy the contents of the\n+ * associative array into it.\n+ * Params:\n+ *      aa =     The associative array.\n+ */\n V[K] dup(T : V[K], K, V)(T aa)\n {\n     //pragma(msg, \"K = \", K, \", V = \", V);\n@@ -1990,12 +1996,31 @@ V[K] dup(T : V[K], K, V)(T aa)\n     return result;\n }\n \n+/* ditto */\n V[K] dup(T : V[K], K, V)(T* aa)\n {\n     return (*aa).dup;\n }\n \n-auto byKey(T : V[K], K, V)(T aa) pure nothrow @nogc\n+// this should never be made public.\n+private AARange _aaToRange(T: V[K], K, V)(ref T aa) pure nothrow @nogc @safe\n+{\n+    // ensure we are dealing with a genuine AA.\n+    static if (is(const(V[K]) == const(T)))\n+        alias realAA = aa;\n+    else\n+        const(V[K]) realAA = aa;\n+    return _aaRange(() @trusted { return cast(void*)realAA; } ());\n+}\n+\n+/***********************************\n+ * Returns a forward range over the keys of the associative array.\n+ * Params:\n+ *      aa =     The associative array.\n+ * Returns:\n+ *      A forward range.\n+ */\n+auto byKey(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n {\n     import core.internal.traits : substInout;\n \n@@ -2004,21 +2029,33 @@ auto byKey(T : V[K], K, V)(T aa) pure nothrow @nogc\n         AARange r;\n \n     pure nothrow @nogc:\n-        @property bool empty() { return _aaRangeEmpty(r); }\n-        @property ref front() { return *cast(substInout!K*)_aaRangeFrontKey(r); }\n-        void popFront() { _aaRangePopFront(r); }\n+        @property bool empty()  @safe { return _aaRangeEmpty(r); }\n+        @property ref front()\n+        {\n+            auto p = (() @trusted => cast(substInout!K*) _aaRangeFrontKey(r)) ();\n+            return *p;\n+        }\n+        void popFront() @safe { _aaRangePopFront(r); }\n         @property Result save() { return this; }\n     }\n \n-    return Result(_aaRange(cast(void*)aa));\n+    return Result(_aaToRange(aa));\n }\n \n+/* ditto */\n auto byKey(T : V[K], K, V)(T* aa) pure nothrow @nogc\n {\n     return (*aa).byKey();\n }\n \n-auto byValue(T : V[K], K, V)(T aa) pure nothrow @nogc\n+/***********************************\n+ * Returns a forward range over the values of the associative array.\n+ * Params:\n+ *      aa =     The associative array.\n+ * Returns:\n+ *      A forward range.\n+ */\n+auto byValue(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n {\n     import core.internal.traits : substInout;\n \n@@ -2027,21 +2064,33 @@ auto byValue(T : V[K], K, V)(T aa) pure nothrow @nogc\n         AARange r;\n \n     pure nothrow @nogc:\n-        @property bool empty() { return _aaRangeEmpty(r); }\n-        @property ref front() { return *cast(substInout!V*)_aaRangeFrontValue(r); }\n-        void popFront() { _aaRangePopFront(r); }\n+        @property bool empty() @safe { return _aaRangeEmpty(r); }\n+        @property ref front()\n+        {\n+            auto p = (() @trusted => cast(substInout!V*) _aaRangeFrontValue(r)) ();\n+            return *p;\n+        }\n+        void popFront() @safe { _aaRangePopFront(r); }\n         @property Result save() { return this; }\n     }\n \n-    return Result(_aaRange(cast(void*)aa));\n+    return Result(_aaToRange(aa));\n }\n \n+/* ditto */\n auto byValue(T : V[K], K, V)(T* aa) pure nothrow @nogc\n {\n     return (*aa).byValue();\n }\n \n-auto byKeyValue(T : V[K], K, V)(T aa) pure nothrow @nogc\n+/***********************************\n+ * Returns a forward range over the key value pairs of the associative array.\n+ * Params:\n+ *      aa =     The associative array.\n+ * Returns:\n+ *      A forward range.\n+ */\n+auto byKeyValue(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n {\n     import core.internal.traits : substInout;\n \n@@ -2050,8 +2099,8 @@ auto byKeyValue(T : V[K], K, V)(T aa) pure nothrow @nogc\n         AARange r;\n \n     pure nothrow @nogc:\n-        @property bool empty() { return _aaRangeEmpty(r); }\n-        @property auto front() @trusted\n+        @property bool empty() @safe { return _aaRangeEmpty(r); }\n+        @property auto front()\n         {\n             static struct Pair\n             {\n@@ -2060,24 +2109,41 @@ auto byKeyValue(T : V[K], K, V)(T aa) pure nothrow @nogc\n                 private void* keyp;\n                 private void* valp;\n \n-                @property ref key() inout { return *cast(substInout!K*)keyp; }\n-                @property ref value() inout { return *cast(substInout!V*)valp; }\n+                @property ref key() inout\n+                {\n+                    auto p = (() @trusted => cast(substInout!K*) keyp) ();\n+                    return *p;\n+                }\n+                @property ref value() inout\n+                {\n+                    auto p = (() @trusted => cast(substInout!V*) valp) ();\n+                    return *p;\n+                }\n             }\n             return Pair(_aaRangeFrontKey(r),\n                         _aaRangeFrontValue(r));\n         }\n-        void popFront() { _aaRangePopFront(r); }\n+        void popFront() @safe { return _aaRangePopFront(r); }\n         @property Result save() { return this; }\n     }\n \n-    return Result(_aaRange(cast(void*)aa));\n+    return Result(_aaToRange(aa));\n }\n \n+/* ditto */\n auto byKeyValue(T : V[K], K, V)(T* aa) pure nothrow @nogc\n {\n     return (*aa).byKeyValue();\n }\n \n+/***********************************\n+ * Returns a dynamic array, the elements of which are the keys in the\n+ * associative array.\n+ * Params:\n+ *      aa =     The associative array.\n+ * Returns:\n+ *      A dynamic array.\n+ */\n Key[] keys(T : Value[Key], Value, Key)(T aa) @property\n {\n     auto a = cast(void[])_aaKeys(cast(inout(void)*)aa, Key.sizeof, typeid(Key[]));\n@@ -2086,11 +2152,20 @@ Key[] keys(T : Value[Key], Value, Key)(T aa) @property\n     return res;\n }\n \n+/* ditto */\n Key[] keys(T : Value[Key], Value, Key)(T *aa) @property\n {\n     return (*aa).keys;\n }\n \n+/***********************************\n+ * Returns a dynamic array, the elements of which are the values in the\n+ * associative array.\n+ * Params:\n+ *      aa =     The associative array.\n+ * Returns:\n+ *      A dynamic array.\n+ */\n Value[] values(T : Value[Key], Value, Key)(T aa) @property\n {\n     auto a = cast(void[])_aaValues(cast(inout(void)*)aa, Key.sizeof, Value.sizeof, typeid(Value[]));\n@@ -2099,341 +2174,149 @@ Value[] values(T : Value[Key], Value, Key)(T aa) @property\n     return res;\n }\n \n+/* ditto */\n Value[] values(T : Value[Key], Value, Key)(T *aa) @property\n {\n     return (*aa).values;\n }\n \n-unittest\n-{\n-    static struct T\n-    {\n-        static size_t count;\n-        this(this) { ++count; }\n-    }\n-    T[int] aa;\n-    T t;\n-    aa[0] = t;\n-    aa[1] = t;\n-    assert(T.count == 2);\n-    auto vals = aa.values;\n-    assert(vals.length == 2);\n-    assert(T.count == 4);\n-\n-    T.count = 0;\n-    int[T] aa2;\n-    aa2[t] = 0;\n-    assert(T.count == 1);\n-    aa2[t] = 1;\n-    assert(T.count == 1);\n-    auto keys = aa2.keys;\n-    assert(keys.length == 1);\n-    assert(T.count == 2);\n-}\n-\n+/***********************************\n+ * Looks up key; if it exists returns corresponding value else evaluates and\n+ * returns defaultValue.\n+ * Params:\n+ *      aa =     The associative array.\n+ *      key =    The key.\n+ *      defaultValue = The default value.\n+ * Returns:\n+ *      The value.\n+ */\n inout(V) get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)\n {\n     auto p = key in aa;\n     return p ? *p : defaultValue;\n }\n \n+/* ditto */\n inout(V) get(K, V)(inout(V[K])* aa, K key, lazy inout(V) defaultValue)\n {\n     return (*aa).get(key, defaultValue);\n }\n \n-pure nothrow unittest\n+/***********************************\n+ * Looks up key; if it exists returns corresponding value else evaluates\n+ * value, adds it to the associative array and returns it.\n+ * Params:\n+ *      aa =     The associative array.\n+ *      key =    The key.\n+ *      value =  The required value.\n+ * Returns:\n+ *      The value.\n+ */\n+ref V require(K, V)(ref V[K] aa, K key, lazy V value = V.init)\n {\n-    int[int] a;\n-    foreach (i; a.byKey)\n+    bool found;\n+    // if key is @safe-ly copyable, `require` can infer @safe\n+    static if (isSafeCopyable!K)\n     {\n-        assert(false);\n+        auto p = () @trusted\n+        {\n+            return cast(V*) _aaGetX(cast(void**) &aa, typeid(V[K]), V.sizeof, &key, found);\n+        } ();\n     }\n-    foreach (i; a.byValue)\n+    else\n     {\n-        assert(false);\n+        auto p = cast(V*) _aaGetX(cast(void**) &aa, typeid(V[K]), V.sizeof, &key, found);\n     }\n+    return found ? *p : (*p = value);\n }\n \n-pure /*nothrow */ unittest\n+// Constraints for aa update. Delegates, Functions or Functors (classes that\n+// provide opCall) are allowed. See unittest for an example.\n+private\n {\n-    auto a = [ 1:\"one\", 2:\"two\", 3:\"three\" ];\n-    auto b = a.dup;\n-    assert(b == [ 1:\"one\", 2:\"two\", 3:\"three\" ]);\n-\n-    int[] c;\n-    foreach (k; a.byKey)\n+    template isCreateOperation(C, V)\n     {\n-        c ~= k;\n-    }\n-\n-    assert(c.length == 3);\n-    assert(c[0] == 1 || c[1] == 1 || c[2] == 1);\n-    assert(c[0] == 2 || c[1] == 2 || c[2] == 2);\n-    assert(c[0] == 3 || c[1] == 3 || c[2] == 3);\n-}\n-\n-pure nothrow unittest\n-{\n-    // test for bug 5925\n-    const a = [4:0];\n-    const b = [4:0];\n-    assert(a == b);\n-}\n-\n-pure nothrow unittest\n-{\n-    // test for bug 9052\n-    static struct Json {\n-        Json[string] aa;\n-        void opAssign(Json) {}\n-        size_t length() const { return aa.length; }\n-        // This length() instantiates AssociativeArray!(string, const(Json)) to call AA.length(), and\n-        // inside ref Slot opAssign(Slot p); (which is automatically generated by compiler in Slot),\n-        // this.value = p.value would actually fail, because both side types of the assignment\n-        // are const(Json).\n+        static if (is(C : V delegate()) || is(C : V function()))\n+            enum bool isCreateOperation = true;\n+        else static if (isCreateOperation!(typeof(&C.opCall), V))\n+            enum bool isCreateOperation = true;\n+        else\n+            enum bool isCreateOperation = false;\n     }\n-}\n-\n-pure nothrow unittest\n-{\n-    // test for bug 8583: ensure Slot and aaA are on the same page wrt value alignment\n-    string[byte]    aa0 = [0: \"zero\"];\n-    string[uint[3]] aa1 = [[1,2,3]: \"onetwothree\"];\n-    ushort[uint[3]] aa2 = [[9,8,7]: 987];\n-    ushort[uint[4]] aa3 = [[1,2,3,4]: 1234];\n-    string[uint[5]] aa4 = [[1,2,3,4,5]: \"onetwothreefourfive\"];\n-\n-    assert(aa0.byValue.front == \"zero\");\n-    assert(aa1.byValue.front == \"onetwothree\");\n-    assert(aa2.byValue.front == 987);\n-    assert(aa3.byValue.front == 1234);\n-    assert(aa4.byValue.front == \"onetwothreefourfive\");\n-}\n \n-pure nothrow unittest\n-{\n-    // test for bug 10720\n-    static struct NC\n+    template isUpdateOperation(U, V)\n     {\n-        @disable this(this) { }\n+        static if (is(U : V delegate(ref V)) || is(U : V function(ref V)))\n+            enum bool isUpdateOperation = true;\n+        else static if (isUpdateOperation!(typeof(&U.opCall), V))\n+            enum bool isUpdateOperation = true;\n+        else\n+            enum bool isUpdateOperation = false;\n     }\n-\n-    NC[string] aa;\n-    static assert(!is(aa.nonExistingField));\n }\n \n-pure nothrow unittest\n-{\n-    // bug 5842\n-    string[string] test = null;\n-    test[\"test1\"] = \"test1\";\n-    test.remove(\"test1\");\n-    test.rehash;\n-    test[\"test3\"] = \"test3\"; // causes divide by zero if rehash broke the AA\n-}\n+// Tests whether T can be @safe-ly copied. Use a union to exclude destructor from the test.\n+private enum bool isSafeCopyable(T) = is(typeof(() @safe { union U { T x; } T *x; auto u = U(*x); }));\n \n-pure nothrow unittest\n+/***********************************\n+ * Looks up key; if it exists applies the update delegate else evaluates the\n+ * create delegate and adds it to the associative array\n+ * Params:\n+ *      aa =     The associative array.\n+ *      key =    The key.\n+ *      create = The delegate to apply on create.\n+ *      update = The delegate to apply on update.\n+ */\n+void update(K, V, C, U)(ref V[K] aa, K key, scope C create, scope U update)\n+if (isCreateOperation!(C, V) && isUpdateOperation!(U, V))\n {\n-    string[] keys = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n-\n-    // Test forward range capabilities of byKey\n+    bool found;\n+    // if key is @safe-ly copyable, `update` may infer @safe\n+    static if (isSafeCopyable!K)\n     {\n-        int[string] aa;\n-        foreach (key; keys)\n-            aa[key] = 0;\n-\n-        auto keyRange = aa.byKey();\n-        auto savedKeyRange = keyRange.save;\n-\n-        // Consume key range once\n-        size_t keyCount = 0;\n-        while (!keyRange.empty)\n-        {\n-            aa[keyRange.front]++;\n-            keyCount++;\n-            keyRange.popFront();\n-        }\n-\n-        foreach (key; keys)\n+        auto p = () @trusted\n         {\n-            assert(aa[key] == 1);\n-        }\n-        assert(keyCount == keys.length);\n-\n-        // Verify it's possible to iterate the range the second time\n-        keyCount = 0;\n-        while (!savedKeyRange.empty)\n-        {\n-            aa[savedKeyRange.front]++;\n-            keyCount++;\n-            savedKeyRange.popFront();\n-        }\n-\n-        foreach (key; keys)\n-        {\n-            assert(aa[key] == 2);\n-        }\n-        assert(keyCount == keys.length);\n+            return cast(V*) _aaGetX(cast(void**) &aa, typeid(V[K]), V.sizeof, &key, found);\n+        } ();\n     }\n-\n-    // Test forward range capabilities of byValue\n-    {\n-        size_t[string] aa;\n-        foreach (i; 0 .. keys.length)\n-        {\n-            aa[keys[i]] = i;\n-        }\n-\n-        auto valRange = aa.byValue();\n-        auto savedValRange = valRange.save;\n-\n-        // Consume value range once\n-        int[] hasSeen;\n-        hasSeen.length = keys.length;\n-        while (!valRange.empty)\n-        {\n-            assert(hasSeen[valRange.front] == 0);\n-            hasSeen[valRange.front]++;\n-            valRange.popFront();\n-        }\n-\n-        foreach (sawValue; hasSeen) { assert(sawValue == 1); }\n-\n-        // Verify it's possible to iterate the range the second time\n-        hasSeen = null;\n-        hasSeen.length = keys.length;\n-        while (!savedValRange.empty)\n-        {\n-            assert(!hasSeen[savedValRange.front]);\n-            hasSeen[savedValRange.front] = true;\n-            savedValRange.popFront();\n-        }\n-\n-        foreach (sawValue; hasSeen) { assert(sawValue); }\n-    }\n-}\n-\n-pure nothrow unittest\n-{\n-    // expanded test for 5842: increase AA size past the point where the AA\n-    // stops using binit, in order to test another code path in rehash.\n-    int[int] aa;\n-    foreach (int i; 0 .. 32)\n-        aa[i] = i;\n-    foreach (int i; 0 .. 32)\n-        aa.remove(i);\n-    aa.rehash;\n-    aa[1] = 1;\n-}\n-\n-pure nothrow unittest\n-{\n-    // bug 13078\n-    shared string[][string] map;\n-    map.rehash;\n-}\n-\n-pure nothrow unittest\n-{\n-    // bug 11761: test forward range functionality\n-    auto aa = [\"a\": 1];\n-\n-    void testFwdRange(R, T)(R fwdRange, T testValue)\n-    {\n-        assert(!fwdRange.empty);\n-        assert(fwdRange.front == testValue);\n-        static assert(is(typeof(fwdRange.save) == typeof(fwdRange)));\n-\n-        auto saved = fwdRange.save;\n-        fwdRange.popFront();\n-        assert(fwdRange.empty);\n-\n-        assert(!saved.empty);\n-        assert(saved.front == testValue);\n-        saved.popFront();\n-        assert(saved.empty);\n-    }\n-\n-    testFwdRange(aa.byKey, \"a\");\n-    testFwdRange(aa.byValue, 1);\n-    //testFwdRange(aa.byPair, tuple(\"a\", 1));\n-}\n-\n-unittest\n-{\n-    // Issue 9119\n-    int[string] aa;\n-    assert(aa.byKeyValue.empty);\n-\n-    aa[\"a\"] = 1;\n-    aa[\"b\"] = 2;\n-    aa[\"c\"] = 3;\n-\n-    auto pairs = aa.byKeyValue;\n-\n-    auto savedPairs = pairs.save;\n-    size_t count = 0;\n-    while (!pairs.empty)\n-    {\n-        assert(pairs.front.key in aa);\n-        assert(pairs.front.value == aa[pairs.front.key]);\n-        count++;\n-        pairs.popFront();\n-    }\n-    assert(count == aa.length);\n-\n-    // Verify that saved range can iterate over the AA again\n-    count = 0;\n-    while (!savedPairs.empty)\n-    {\n-        assert(savedPairs.front.key in aa);\n-        assert(savedPairs.front.value == aa[savedPairs.front.key]);\n-        count++;\n-        savedPairs.popFront();\n-    }\n-    assert(count == aa.length);\n-}\n-\n-unittest\n-{\n-    // Verify iteration with const.\n-    auto aa = [1:2, 3:4];\n-    foreach (const t; aa.byKeyValue)\n+    else\n     {\n-        auto k = t.key;\n-        auto v = t.value;\n+        auto p = cast(V*) _aaGetX(cast(void**) &aa, typeid(V[K]), V.sizeof, &key, found);\n     }\n+    if (!found)\n+        *p = create();\n+    else\n+        *p = update(*p);\n }\n \n unittest\n {\n-    // test for bug 14626\n     static struct S\n     {\n-        string[string] aa;\n-        inout(string) key() inout { return aa.byKey().front; }\n-        inout(string) val() inout { return aa.byValue().front; }\n-        auto keyval() inout { return aa.byKeyValue().front; }\n+        int x;\n+    @nogc nothrow pure:\n+        this(this) @system {}\n+\n+    @safe const:\n+        // stubs\n+        bool opEquals(S rhs) { assert(0); }\n+        size_t toHash() { assert(0); }\n     }\n \n-    S s = S([\"a\":\"b\"]);\n-    assert(s.key() == \"a\");\n-    assert(s.val() == \"b\");\n-    assert(s.keyval().key == \"a\");\n-    assert(s.keyval().value == \"b\");\n+    int[string] aai;\n+    static assert(is(typeof(() @safe { aai.require(\"a\", 1234); })));\n+    static assert(is(typeof(() @safe { aai.update(\"a\", { return 1234; }, (ref int x) { x++; return x; }); })));\n \n-    void testInoutKeyVal(inout(string) key)\n-    {\n-        inout(string)[typeof(key)] aa;\n+    S[string] aas;\n+    static assert(is(typeof(() { aas.require(\"a\", S(1234)); })));\n+    static assert(is(typeof(() { aas.update(\"a\", { return S(1234); }, (ref S s) { s.x++; return s; }); })));\n+    static assert(!is(typeof(() @safe { aas.update(\"a\", { return S(1234); }, (ref S s) { s.x++; return s; }); })));\n \n-        foreach (i; aa.byKey()) {}\n-        foreach (i; aa.byValue()) {}\n-        foreach (i; aa.byKeyValue()) {}\n-    }\n-\n-    const int[int] caa;\n-    static assert(is(typeof(caa.byValue().front) == const int));\n+    int[S] aais;\n+    static assert(is(typeof(() { aais.require(S(1234), 1234); })));\n+    static assert(is(typeof(() { aais.update(S(1234), { return 1234; }, (ref int x) { x++; return x; }); })));\n+    static assert(!is(typeof(() @safe { aais.require(S(1234), 1234); })));\n+    static assert(!is(typeof(() @safe { aais.update(S(1234), { return 1234; }, (ref int x) { x++; return x; }); })));\n }\n \n private void _destructRecurse(S)(ref S s)\n@@ -3190,32 +3073,35 @@ bool _ArrayEq(T1, T2)(T1[] a1, T2[] a2)\n     return true;\n }\n \n-/**\n-Calculates the hash value of $(D arg) with $(D seed) initial value.\n-The result may not be equal to `typeid(T).getHash(&arg)`.\n-The $(D seed) value may be used for hash chaining:\n-----\n-struct Test\n+version (D_Ddoc)\n {\n-    int a;\n-    string b;\n-    MyObject c;\n+    // This lets DDoc produce better documentation.\n+\n+    /**\n+    Calculates the hash value of `arg` with an optional `seed` initial value.\n+    The result might not be equal to `typeid(T).getHash(&arg)`.\n \n-    size_t toHash() const @safe pure nothrow\n+    Params:\n+        arg = argument to calculate the hash value of\n+        seed = optional `seed` value (may be used for hash chaining)\n+\n+    Return: calculated hash value of `arg`\n+    */\n+    size_t hashOf(T)(auto ref T arg, size_t seed)\n+    {\n+        static import core.internal.hash;\n+        return core.internal.hash.hashOf(arg, seed);\n+    }\n+    /// ditto\n+    size_t hashOf(T)(auto ref T arg)\n     {\n-        size_t hash = a.hashOf();\n-        hash = b.hashOf(hash);\n-        size_t h1 = c.myMegaHash();\n-        hash = h1.hashOf(hash); //Mix two hash values\n-        return hash;\n+        static import core.internal.hash;\n+        return core.internal.hash.hashOf(arg);\n     }\n }\n-----\n-*/\n-size_t hashOf(T)(auto ref T arg, size_t seed = 0)\n+else\n {\n-    import core.internal.hash;\n-    return core.internal.hash.hashOf(arg, seed);\n+    public import core.internal.hash : hashOf;\n }\n \n unittest\n@@ -3722,58 +3608,15 @@ private size_t getArrayHash(in TypeInfo element, in void* ptr, in size_t count)\n     }\n \n     import core.internal.traits : externDFunc;\n-    alias hashOf = externDFunc!(\"rt.util.hash.hashOf\",\n-                                size_t function(const(void)[], size_t) @trusted pure nothrow @nogc);\n     if (!hasCustomToHash(element))\n-        return hashOf(ptr[0 .. elementSize * count], 0);\n+        return hashOf(ptr[0 .. elementSize * count]);\n \n     size_t hash = 0;\n     foreach (size_t i; 0 .. count)\n-        hash += element.getHash(ptr + i * elementSize);\n+        hash = hashOf(element.getHash(ptr + i * elementSize), hash);\n     return hash;\n }\n \n-\n-// Tests ensure TypeInfo_Array.getHash  uses element hash functions instead of hashing array data\n-\n-unittest\n-{\n-    class C\n-    {\n-        int i;\n-        this(in int i) { this.i = i; }\n-        override hash_t toHash() { return 0; }\n-    }\n-    C[] a1 = [new C(11)], a2 = [new C(12)];\n-    assert(typeid(C[]).getHash(&a1) == typeid(C[]).getHash(&a2));\n-}\n-\n-unittest\n-{\n-    struct S\n-    {\n-        int i;\n-        hash_t toHash() const @safe nothrow { return 0; }\n-    }\n-    S[] a1 = [S(11)], a2 = [S(12)];\n-    assert(typeid(S[]).getHash(&a1) == typeid(S[]).getHash(&a2));\n-}\n-\n-@safe unittest\n-{\n-    struct S\n-    {\n-        int i;\n-    const @safe nothrow:\n-        hash_t toHash() { return 0; }\n-        bool opEquals(const S) { return true; }\n-        int opCmp(const S) { return 0; }\n-    }\n-\n-    int[S[]] aa = [[S(11)] : 13];\n-    assert(aa[[S(12)]] == 13);\n-}\n-\n /// Provide the .dup array property.\n @property auto dup(T)(T[] a)\n     if (!is(const(T) : T))"}, {"sha": "631847e4c2ba20107df6d392f331f00fff8b9d7a", "filename": "libphobos/libdruntime/rt/aaA.d", "status": "modified", "additions": 51, "deletions": 257, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2FaaA.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2FaaA.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2FaaA.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -88,7 +88,7 @@ private:\n         return used - deleted;\n     }\n \n-    @property size_t dim() const pure nothrow @nogc\n+    @property size_t dim() const pure nothrow @nogc @safe\n     {\n         return buckets.length;\n     }\n@@ -183,7 +183,7 @@ private pure nothrow @nogc:\n         return hash == HASH_DELETED;\n     }\n \n-    @property bool filled() const\n+    @property bool filled() const @safe\n     {\n         return cast(ptrdiff_t) hash < 0;\n     }\n@@ -365,8 +365,29 @@ extern (C) size_t _aaLen(in AA aa) pure nothrow @nogc\n  *      If key was not in the aa, a mutable pointer to newly inserted value which\n  *      is set to all zeros\n  */\n-extern (C) void* _aaGetY(AA* aa, const TypeInfo_AssociativeArray ti, in size_t valsz,\n-    in void* pkey)\n+extern (C) void* _aaGetY(AA* aa, const TypeInfo_AssociativeArray ti,\n+    in size_t valsz, in void* pkey)\n+{\n+    bool found;\n+    return _aaGetX(aa, ti, valsz, pkey, found);\n+}\n+\n+/******************************\n+ * Lookup *pkey in aa.\n+ * Called only from implementation of require\n+ * Params:\n+ *      aa = associative array opaque pointer\n+ *      ti = TypeInfo for the associative array\n+ *      valsz = ignored\n+ *      pkey = pointer to the key value\n+ *      found = true if the value was found\n+ * Returns:\n+ *      if key was in the aa, a mutable pointer to the existing value.\n+ *      If key was not in the aa, a mutable pointer to newly inserted value which\n+ *      is set to all zeros\n+ */\n+extern (C) void* _aaGetX(AA* aa, const TypeInfo_AssociativeArray ti,\n+    in size_t valsz, in void* pkey, out bool found)\n {\n     // lazily alloc implementation\n     if (aa.impl is null)\n@@ -377,7 +398,10 @@ extern (C) void* _aaGetY(AA* aa, const TypeInfo_AssociativeArray ti, in size_t v\n \n     // found a value => return it\n     if (auto p = aa.findSlotLookup(hash, pkey, ti.key))\n+    {\n+        found = true;\n         return p.entry + aa.valoff;\n+    }\n \n     auto p = aa.findSlotInsert(hash);\n     if (p.deleted)\n@@ -584,6 +608,7 @@ extern (C) Impl* _d_assocarrayliteralTX(const TypeInfo_AssociativeArray ti, void\n     void* pkey = keys.ptr;\n     void* pval = vals.ptr;\n     immutable off = aa.valoff;\n+    uint actualLength = 0;\n     foreach (_; 0 .. length)\n     {\n         immutable hash = calcHash(pkey, ti.key);\n@@ -595,6 +620,7 @@ extern (C) Impl* _d_assocarrayliteralTX(const TypeInfo_AssociativeArray ti, void\n             p.hash = hash;\n             p.entry = allocEntry(aa, pkey); // move key, no postblit\n             aa.firstUsed = min(aa.firstUsed, cast(uint)(p - aa.buckets.ptr));\n+            actualLength++;\n         }\n         else if (aa.entryTI && hasDtor(ti.value))\n         {\n@@ -608,7 +634,7 @@ extern (C) Impl* _d_assocarrayliteralTX(const TypeInfo_AssociativeArray ti, void\n         pkey += keysz;\n         pval += valsz;\n     }\n-    aa.used = cast(uint) length;\n+    aa.used = actualLength;\n     return aa;\n }\n \n@@ -653,17 +679,19 @@ extern (C) hash_t _aaGetHash(in AA* aa, in TypeInfo tiRaw) nothrow\n     auto uti = unqualify(tiRaw);\n     auto ti = *cast(TypeInfo_AssociativeArray*)&uti;\n     immutable off = aa.valoff;\n+    auto keyHash = &ti.key.getHash;\n     auto valHash = &ti.value.getHash;\n \n     size_t h;\n     foreach (b; aa.buckets)\n     {\n         if (!b.filled)\n             continue;\n-        size_t[2] h2 = [b.hash, valHash(b.entry + off)];\n-        // use XOR here, so that hash is independent of element order\n-        h ^= hashOf(h2);\n+        size_t[2] h2 = [keyHash(b.entry), valHash(b.entry + off)];\n+        // use addition here, so that hash is independent of element order\n+        h += hashOf(h2);\n     }\n+\n     return h;\n }\n \n@@ -677,7 +705,7 @@ struct Range\n     alias impl this;\n }\n \n-extern (C) pure nothrow @nogc\n+extern (C) pure nothrow @nogc @safe\n {\n     Range _aaRange(AA aa)\n     {\n@@ -694,21 +722,32 @@ extern (C) pure nothrow @nogc\n \n     bool _aaRangeEmpty(Range r)\n     {\n-        return r.impl is null || r.idx == r.dim;\n+        return r.impl is null || r.idx >= r.dim;\n     }\n \n     void* _aaRangeFrontKey(Range r)\n     {\n+        assert(!_aaRangeEmpty(r));\n+        if (r.idx >= r.dim)\n+            return null;\n         return r.buckets[r.idx].entry;\n     }\n \n     void* _aaRangeFrontValue(Range r)\n     {\n-        return r.buckets[r.idx].entry + r.valoff;\n+        assert(!_aaRangeEmpty(r));\n+        if (r.idx >= r.dim)\n+            return null;\n+\n+        auto entry = r.buckets[r.idx].entry;\n+        return entry is null ?\n+            null :\n+            (() @trusted { return entry + r.valoff; } ());\n     }\n \n     void _aaRangePopFront(ref Range r)\n     {\n+        if (r.idx >= r.dim) return;\n         for (++r.idx; r.idx < r.dim; ++r.idx)\n         {\n             if (r.buckets[r.idx].filled)\n@@ -717,221 +756,7 @@ extern (C) pure nothrow @nogc\n     }\n }\n \n-//==============================================================================\n-// Unittests\n-//------------------------------------------------------------------------------\n-\n-pure nothrow unittest\n-{\n-    int[string] aa;\n-\n-    assert(aa.keys.length == 0);\n-    assert(aa.values.length == 0);\n-\n-    aa[\"hello\"] = 3;\n-    assert(aa[\"hello\"] == 3);\n-    aa[\"hello\"]++;\n-    assert(aa[\"hello\"] == 4);\n-\n-    assert(aa.length == 1);\n-\n-    string[] keys = aa.keys;\n-    assert(keys.length == 1);\n-    assert(keys[0] == \"hello\");\n-\n-    int[] values = aa.values;\n-    assert(values.length == 1);\n-    assert(values[0] == 4);\n-\n-    aa.rehash;\n-    assert(aa.length == 1);\n-    assert(aa[\"hello\"] == 4);\n-\n-    aa[\"foo\"] = 1;\n-    aa[\"bar\"] = 2;\n-    aa[\"batz\"] = 3;\n-\n-    assert(aa.keys.length == 4);\n-    assert(aa.values.length == 4);\n-\n-    foreach (a; aa.keys)\n-    {\n-        assert(a.length != 0);\n-        assert(a.ptr != null);\n-    }\n-\n-    foreach (v; aa.values)\n-    {\n-        assert(v != 0);\n-    }\n-}\n-\n-unittest  // Test for Issue 10381\n-{\n-    alias II = int[int];\n-    II aa1 = [0 : 1];\n-    II aa2 = [0 : 1];\n-    II aa3 = [0 : 2];\n-    assert(aa1 == aa2); // Passes\n-    assert(typeid(II).equals(&aa1, &aa2));\n-    assert(!typeid(II).equals(&aa1, &aa3));\n-}\n-\n-pure nothrow unittest\n-{\n-    string[int] key1 = [1 : \"true\", 2 : \"false\"];\n-    string[int] key2 = [1 : \"false\", 2 : \"true\"];\n-    string[int] key3;\n-\n-    // AA lits create a larger hashtable\n-    int[string[int]] aa1 = [key1 : 100, key2 : 200, key3 : 300];\n-\n-    // Ensure consistent hash values are computed for key1\n-    assert((key1 in aa1) !is null);\n-\n-    // Manually assigning to an empty AA creates a smaller hashtable\n-    int[string[int]] aa2;\n-    aa2[key1] = 100;\n-    aa2[key2] = 200;\n-    aa2[key3] = 300;\n-\n-    assert(aa1 == aa2);\n-\n-    // Ensure binary-independence of equal hash keys\n-    string[int] key2a;\n-    key2a[1] = \"false\";\n-    key2a[2] = \"true\";\n-\n-    assert(aa1[key2a] == 200);\n-}\n-\n-// Issue 9852\n-pure nothrow unittest\n-{\n-    // Original test case (revised, original assert was wrong)\n-    int[string] a;\n-    a[\"foo\"] = 0;\n-    a.remove(\"foo\");\n-    assert(a == null); // should not crash\n-\n-    int[string] b;\n-    assert(b is null);\n-    assert(a == b); // should not deref null\n-    assert(b == a); // ditto\n-\n-    int[string] c;\n-    c[\"a\"] = 1;\n-    assert(a != c); // comparison with empty non-null AA\n-    assert(c != a);\n-    assert(b != c); // comparison with null AA\n-    assert(c != b);\n-}\n-\n-// Bugzilla 14104\n-unittest\n-{\n-    import core.stdc.stdio;\n-\n-    alias K = const(ubyte)*;\n-    size_t[K] aa;\n-    immutable key = cast(K)(cast(size_t) uint.max + 1);\n-    aa[key] = 12;\n-    assert(key in aa);\n-}\n-\n-unittest\n-{\n-    int[int] aa;\n-    foreach (k, v; aa)\n-        assert(false);\n-    foreach (v; aa)\n-        assert(false);\n-    assert(aa.byKey.empty);\n-    assert(aa.byValue.empty);\n-    assert(aa.byKeyValue.empty);\n-\n-    size_t n;\n-    aa = [0 : 3, 1 : 4, 2 : 5];\n-    foreach (k, v; aa)\n-    {\n-        n += k;\n-        assert(k >= 0 && k < 3);\n-        assert(v >= 3 && v < 6);\n-    }\n-    assert(n == 3);\n-    n = 0;\n-\n-    foreach (v; aa)\n-    {\n-        n += v;\n-        assert(v >= 3 && v < 6);\n-    }\n-    assert(n == 12);\n-\n-    n = 0;\n-    foreach (k, v; aa)\n-    {\n-        ++n;\n-        break;\n-    }\n-    assert(n == 1);\n-\n-    n = 0;\n-    foreach (v; aa)\n-    {\n-        ++n;\n-        break;\n-    }\n-    assert(n == 1);\n-}\n-\n-unittest\n-{\n-    int[int] aa;\n-    assert(!aa.remove(0));\n-    aa = [0 : 1];\n-    assert(aa.remove(0));\n-    assert(!aa.remove(0));\n-    aa[1] = 2;\n-    assert(!aa.remove(0));\n-    assert(aa.remove(1));\n-\n-    assert(aa.length == 0);\n-    assert(aa.byKey.empty);\n-}\n-\n-// test zero sized value (hashset)\n-unittest\n-{\n-    alias V = void[0];\n-    auto aa = [0 : V.init];\n-    assert(aa.length == 1);\n-    assert(aa.byKey.front == 0);\n-    assert(aa.byValue.front == V.init);\n-    aa[1] = V.init;\n-    assert(aa.length == 2);\n-    aa[0] = V.init;\n-    assert(aa.length == 2);\n-    assert(aa.remove(0));\n-    aa[0] = V.init;\n-    assert(aa.length == 2);\n-    assert(aa == [0 : V.init, 1 : V.init]);\n-}\n-\n-// test tombstone purging\n-unittest\n-{\n-    int[int] aa;\n-    foreach (i; 0 .. 6)\n-        aa[i] = i;\n-    foreach (i; 0 .. 6)\n-        assert(aa.remove(i));\n-    foreach (i; 6 .. 10)\n-        aa[i] = i;\n-    assert(aa.length == 4);\n-    foreach (i; 6 .. 10)\n-        assert(i in aa);\n-}\n+// Most tests are now in in test_aa.d\n \n // test postblit for AA literals\n unittest\n@@ -982,34 +807,3 @@ unittest\n     GC.runFinalizers((cast(char*)(&entryDtor))[0 .. 1]);\n     assert(T.dtor == 6 && T.postblit == 2);\n }\n-\n-// for aa.clear\n-pure nothrow unittest\n-{\n-    int[int] aa;\n-    assert(aa.length == 0);\n-    foreach (i; 0 .. 100)\n-        aa[i] = i * 2;\n-    assert(aa.length == 100);\n-    auto aa2 = aa;\n-    assert(aa2.length == 100);\n-    aa.clear();\n-    assert(aa.length == 0);\n-    assert(aa2.length == 0);\n-\n-    aa2[5] = 6;\n-    assert(aa.length == 1);\n-    assert(aa[5] == 6);\n-}\n-\n-// test AA as key (Issue 16974)\n-unittest\n-{\n-    int[int] a = [1 : 2], a2 = [1 : 2];\n-\n-    assert([a : 3] == [a : 3]);\n-    assert([a : 3] == [a2 : 3]);\n-\n-    assert(typeid(a).getHash(&a) == typeid(a).getHash(&a));\n-    assert(typeid(a).getHash(&a) == typeid(a).getHash(&a2));\n-}"}, {"sha": "4eea4ad09366b24ef8d6d6d62d0d35c03ffb847c", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Acdouble.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acdouble.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acdouble.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acdouble.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -25,7 +25,7 @@ class TypeInfo_Ar : TypeInfo_Array\n \n     override string toString() const { return (F[]).stringof; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         return Array!F.hashOf(*cast(F[]*)p);\n     }"}, {"sha": "126bfd80c8d7ae0e7ab4cfa4ce3aa923b2009657", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Acfloat.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acfloat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acfloat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acfloat.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -25,7 +25,7 @@ class TypeInfo_Aq : TypeInfo_Array\n \n     override string toString() const { return (F[]).stringof; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         return Array!F.hashOf(*cast(F[]*)p);\n     }"}, {"sha": "1d1421fa3e712bb999850ec540715d8e4387bc02", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Acreal.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acreal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acreal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Acreal.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -25,7 +25,7 @@ class TypeInfo_Ac : TypeInfo_Array\n \n     override string toString() const { return (F[]).stringof; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         return Array!F.hashOf(*cast(F[]*)p);\n     }"}, {"sha": "779049204190a0d92783b4efec0ccb40bc080c9d", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Adouble.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Adouble.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Adouble.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Adouble.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -25,7 +25,7 @@ class TypeInfo_Ad : TypeInfo_Array\n \n     override string toString() const { return (F[]).stringof; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         return Array!F.hashOf(*cast(F[]*)p);\n     }"}, {"sha": "f6ae827196817401e6b810a79b1e42b1cc5a1ff4", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Afloat.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Afloat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Afloat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Afloat.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -25,7 +25,7 @@ class TypeInfo_Af : TypeInfo_Array\n \n     override string toString() const { return (F[]).stringof; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         return Array!F.hashOf(*cast(F[]*)p);\n     }"}, {"sha": "f61bd34bbb53b2d6e8eb69503125a0c7c1f3f037", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Ag.d", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Ag.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Ag.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Ag.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -14,7 +14,6 @@\n module rt.typeinfo.ti_Ag;\n \n private import core.stdc.string;\n-private import rt.util.hash;\n private import core.internal.string;\n \n // byte[]\n@@ -25,10 +24,10 @@ class TypeInfo_Ag : TypeInfo_Array\n \n     override string toString() const { return \"byte[]\"; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         const s = *cast(const void[]*)p;\n-        return rt.util.hash.hashOf(s, 0);\n+        return hashOf(s);\n     }\n \n     override bool equals(in void* p1, in void* p2) const\n@@ -118,54 +117,10 @@ class TypeInfo_Aa : TypeInfo_Ah\n {\n     override string toString() const { return \"char[]\"; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         char[] s = *cast(char[]*)p;\n-        size_t hash = 0;\n-\n-version (all)\n-{\n-        foreach (char c; s)\n-            hash = hash * 11 + c;\n-}\n-else\n-{\n-        size_t len = s.length;\n-        char *str = s;\n-\n-        while (1)\n-        {\n-            switch (len)\n-            {\n-                case 0:\n-                    return hash;\n-\n-                case 1:\n-                    hash *= 9;\n-                    hash += *cast(ubyte *)str;\n-                    return hash;\n-\n-                case 2:\n-                    hash *= 9;\n-                    hash += *cast(ushort *)str;\n-                    return hash;\n-\n-                case 3:\n-                    hash *= 9;\n-                    hash += (*cast(ushort *)str << 8) +\n-                            (cast(ubyte *)str)[2];\n-                    return hash;\n-\n-                default:\n-                    hash *= 9;\n-                    hash += *cast(uint *)str;\n-                    str += 4;\n-                    len -= 4;\n-                    break;\n-            }\n-        }\n-}\n-        return hash;\n+        return hashOf(s);\n     }\n \n     override @property inout(TypeInfo) next() inout"}, {"sha": "828fbc08ad9372b9baa4802532dc7404de4c8222", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Aint.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Aint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Aint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Aint.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -14,7 +14,6 @@\n module rt.typeinfo.ti_Aint;\n \n private import core.stdc.string;\n-private import rt.util.hash;\n \n extern (C) void[] _adSort(void[] a, TypeInfo ti);\n \n@@ -26,10 +25,11 @@ class TypeInfo_Ai : TypeInfo_Array\n \n     override string toString() const { return \"int[]\"; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n-        const s = *cast(const int[]*)p;\n-        return rt.util.hash.hashOf(s, 0);\n+        // Hash as if unsigned.\n+        const s = *cast(const uint[]*)p;\n+        return hashOf(s);\n     }\n \n     override bool equals(in void* p1, in void* p2) const"}, {"sha": "51c741a3da26fd1cd5db1a03f6064bf02e0e8180", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Along.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Along.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Along.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Along.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -14,7 +14,6 @@\n module rt.typeinfo.ti_Along;\n \n private import core.stdc.string;\n-private import rt.util.hash;\n \n // long[]\n \n@@ -24,10 +23,11 @@ class TypeInfo_Al : TypeInfo_Array\n \n     override string toString() const { return \"long[]\"; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n-        const s = *cast(const long[]*)p;\n-        return rt.util.hash.hashOf(s, 0);\n+        // Hash as if unsigned.\n+        const s = *cast(const ulong[]*)p;\n+        return hashOf(s);\n     }\n \n     override bool equals(in void* p1, in void* p2) const"}, {"sha": "f1dd458e2e6238236e0376fade57d7afda7d3d57", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Areal.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Areal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Areal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Areal.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -25,7 +25,7 @@ class TypeInfo_Ae : TypeInfo_Array\n \n     override string toString() const { return (F[]).stringof; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n         return Array!F.hashOf(*cast(F[]*)p);\n     }"}, {"sha": "e4b47e247b721d90cf4811928f92c582e5c23630", "filename": "libphobos/libdruntime/rt/typeinfo/ti_Ashort.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Ashort.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Ashort.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_Ashort.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -14,7 +14,6 @@\n module rt.typeinfo.ti_Ashort;\n \n private import core.stdc.string;\n-private import rt.util.hash;\n \n // short[]\n \n@@ -24,10 +23,11 @@ class TypeInfo_As : TypeInfo_Array\n \n     override string toString() const { return \"short[]\"; }\n \n-    override size_t getHash(in void* p) @trusted const\n+    override size_t getHash(scope const void* p) @trusted const\n     {\n-        const s = *cast(const short[]*)p;\n-        return rt.util.hash.hashOf(s, 0);\n+        // Hash as if unsigned.\n+        const s = *cast(const ushort[]*)p;\n+        return hashOf(s);\n     }\n \n     override bool equals(in void* p1, in void* p2) const"}, {"sha": "df4987312a1851bbc9616a95172b36110f0f6d04", "filename": "libphobos/libdruntime/rt/typeinfo/ti_C.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_C.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_C.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_C.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -22,7 +22,7 @@ class TypeInfo_C : TypeInfo\n     //pure:\n     //nothrow:\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n         Object o = *cast(Object*)p;\n         return o ? o.toHash() : 0;"}, {"sha": "6a3efb144bfe8e84ce3ce3a60757f379dd4bee6c", "filename": "libphobos/libdruntime/rt/typeinfo/ti_byte.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_byte.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_byte.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_byte.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_g : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"byte\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(byte *)p;\n+        return *cast(const byte *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "c396a17ce2ce3c1fe4ffda84811ada288b2a4295", "filename": "libphobos/libdruntime/rt/typeinfo/ti_cdouble.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cdouble.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cdouble.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cdouble.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -27,7 +27,7 @@ class TypeInfo_r : TypeInfo\n \n     override string toString() const { return F.stringof; }\n \n-    override size_t getHash(in void* p) const @trusted\n+    override size_t getHash(scope const void* p) const @trusted\n     {\n         return Floating!F.hashOf(*cast(F*)p);\n     }"}, {"sha": "a74f796d1c5d7f2efa56b8a992c22c8ff0f5a406", "filename": "libphobos/libdruntime/rt/typeinfo/ti_cent.d", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cent.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cent.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cent.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -13,8 +13,6 @@\n  */\n module rt.typeinfo.ti_cent;\n \n-private import rt.util.hash;\n-\n static if (is(cent)):\n \n // cent\n@@ -28,9 +26,10 @@ class TypeInfo_zi : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"cent\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return rt.util.hash.hashOf(p[0 .. cent.sizeof], 0);\n+        // cent & ucent hash the same if ucent.sizeof >= size_t.sizeof.\n+        return hashOf(*cast(const ucent*) p);\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "a3ad4ca9dbf77b5813bdec981d7d62c8c8dabf32", "filename": "libphobos/libdruntime/rt/typeinfo/ti_cfloat.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cfloat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cfloat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_cfloat.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -27,7 +27,7 @@ class TypeInfo_q : TypeInfo\n \n     override string toString() const { return F.stringof; }\n \n-    override size_t getHash(in void* p) const @trusted\n+    override size_t getHash(scope const void* p) const @trusted\n     {\n         return Floating!F.hashOf(*cast(F*)p);\n     }"}, {"sha": "fbc5680335ecf921a8130051df22850a65f8e3e7", "filename": "libphobos/libdruntime/rt/typeinfo/ti_char.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_char.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_char.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_char.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_a : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"char\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(char *)p;\n+        return *cast(const char *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "c064b7b872bf02ad380e7c9b40728fab71029f49", "filename": "libphobos/libdruntime/rt/typeinfo/ti_creal.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_creal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_creal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_creal.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -27,7 +27,7 @@ class TypeInfo_c : TypeInfo\n \n     override string toString() const { return F.stringof; }\n \n-    override size_t getHash(in void* p) const @trusted\n+    override size_t getHash(scope const void* p) const @trusted\n     {\n         return Floating!F.hashOf(*cast(F*)p);\n     }"}, {"sha": "5d6fea161d5e770426865cc4ddc228bbb9e913da", "filename": "libphobos/libdruntime/rt/typeinfo/ti_dchar.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_dchar.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_dchar.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_dchar.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_w : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"dchar\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(dchar *)p;\n+        return *cast(const dchar *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "aaddd858159f39ae357a23650cd3fc86343d1587", "filename": "libphobos/libdruntime/rt/typeinfo/ti_delegate.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_delegate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_delegate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_delegate.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -13,7 +13,6 @@\n  */\n module rt.typeinfo.ti_delegate;\n \n-private import rt.util.hash;\n \n // delegate\n \n@@ -26,9 +25,9 @@ class TypeInfo_D : TypeInfo\n     pure:\n     nothrow:\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return rt.util.hash.hashOf(p[0 .. dg.sizeof], 0);\n+        return hashOf(*cast(dg*)p);\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "f5671cd032c578189431498e0111805b0151d511", "filename": "libphobos/libdruntime/rt/typeinfo/ti_double.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_double.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_double.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_double.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -27,7 +27,7 @@ class TypeInfo_d : TypeInfo\n \n     override string toString() const { return F.stringof; }\n \n-    override size_t getHash(in void* p) const @trusted\n+    override size_t getHash(scope const void* p) const @trusted\n     {\n         return Floating!F.hashOf(*cast(F*)p);\n     }"}, {"sha": "4cd68c7cf265b9b9c705c8b6a1ec07f769ec9962", "filename": "libphobos/libdruntime/rt/typeinfo/ti_float.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_float.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_float.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_float.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -27,7 +27,7 @@ class TypeInfo_f : TypeInfo\n \n     override string toString() const { return F.stringof; }\n \n-    override size_t getHash(in void* p) const @trusted\n+    override size_t getHash(scope const void* p) const @trusted\n     {\n         return Floating!F.hashOf(*cast(F*)p);\n     }"}, {"sha": "6e32c43afe93b5f5903de8bbfb6d1cf151db8e91", "filename": "libphobos/libdruntime/rt/typeinfo/ti_int.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_int.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_int.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_int.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_i : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"int\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(uint *)p;\n+        return *cast(const int *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "78fea117634baee5b35f4f2c53c482fc597a222f", "filename": "libphobos/libdruntime/rt/typeinfo/ti_long.d", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_long.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_long.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_long.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -13,8 +13,6 @@\n  */\n module rt.typeinfo.ti_long;\n \n-private import rt.util.hash;\n-\n // long\n \n class TypeInfo_l : TypeInfo\n@@ -26,9 +24,13 @@ class TypeInfo_l : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"long\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return rt.util.hash.hashOf(p[0 .. long.sizeof], 0);\n+        static if (ulong.sizeof <= size_t.sizeof)\n+            return *cast(const long*)p;\n+        else\n+            // long & ulong hash the same if ulong.sizeof > size_t.sizeof.\n+            return hashOf(*cast(const ulong*)p);\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "b6cea03218ca1d30e083e51c8162391db9d70c52", "filename": "libphobos/libdruntime/rt/typeinfo/ti_n.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_n.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_n.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_n.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -19,7 +19,7 @@ class TypeInfo_n : TypeInfo\n {\n     override string toString() const @safe { return \"typeof(null)\"; }\n \n-    override size_t getHash(in void* p) const\n+    override size_t getHash(scope const void* p) const\n     {\n         return 0;\n     }"}, {"sha": "8857ef9071702e2b9cf05a5320572b5a65ab8a39", "filename": "libphobos/libdruntime/rt/typeinfo/ti_ptr.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ptr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ptr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ptr.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -23,9 +23,10 @@ class TypeInfo_P : TypeInfo\n     pure:\n     nothrow:\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return cast(size_t)*cast(void**)p;\n+        size_t addr = cast(size_t) *cast(const void**)p;\n+        return addr ^ (addr >> 4);\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "fb20f1429ac552ea0186e3275b832cdd73664e61", "filename": "libphobos/libdruntime/rt/typeinfo/ti_real.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_real.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_real.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_real.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -27,7 +27,7 @@ class TypeInfo_e : TypeInfo\n \n     override string toString() const { return F.stringof; }\n \n-    override size_t getHash(in void* p) const @trusted\n+    override size_t getHash(scope const void* p) const @trusted\n     {\n         return Floating!F.hashOf(*cast(F*)p);\n     }"}, {"sha": "bccbe63477a89a019ed378968b647d9e91e2d988", "filename": "libphobos/libdruntime/rt/typeinfo/ti_short.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_short.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_short.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_short.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_s : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"short\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(short *)p;\n+        return *cast(const short *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "9643179be6641aaf77344b3ba64f7dee6e421ef3", "filename": "libphobos/libdruntime/rt/typeinfo/ti_ubyte.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ubyte.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ubyte.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ubyte.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_h : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"ubyte\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(ubyte *)p;\n+        return *cast(const ubyte *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "ffa67d8a62452d74bed286530c081fd1ebf29ce4", "filename": "libphobos/libdruntime/rt/typeinfo/ti_ucent.d", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ucent.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ucent.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ucent.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -13,8 +13,6 @@\n  */\n module rt.typeinfo.ti_ucent;\n \n-private import rt.util.hash;\n-\n static if (is(ucent)):\n \n // ucent\n@@ -28,9 +26,9 @@ class TypeInfo_zk : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"ucent\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return rt.util.hash.hashOf(p[0 .. ucent.sizeof], 0);\n+        return hashOf(*cast(const ucent*) p);\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "09bff186b3f09927393f6878a6ef47a48e2c8082", "filename": "libphobos/libdruntime/rt/typeinfo/ti_uint.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_uint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_uint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_uint.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_k : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"uint\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(uint *)p;\n+        return *cast(const uint *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "3fdaacd8ec9fd7c66b901e0cf56e2d7154f20d2c", "filename": "libphobos/libdruntime/rt/typeinfo/ti_ulong.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ulong.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ulong.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ulong.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -13,7 +13,6 @@\n  */\n module rt.typeinfo.ti_ulong;\n \n-private import rt.util.hash;\n \n // ulong\n \n@@ -26,9 +25,12 @@ class TypeInfo_m : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"ulong\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return rt.util.hash.hashOf(p[0 .. ulong.sizeof], 0);\n+        static if (ulong.sizeof <= size_t.sizeof)\n+            return *cast(const ulong*)p;\n+        else\n+            return hashOf(*cast(const ulong*)p);\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "90623f2d14c07b03afb32ee1fc4dccff8cde9a56", "filename": "libphobos/libdruntime/rt/typeinfo/ti_ushort.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ushort.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ushort.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_ushort.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_t : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"ushort\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(ushort *)p;\n+        return *cast(const ushort *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "1facb955597a0771f4f8d535dc0b79ff75e68eb8", "filename": "libphobos/libdruntime/rt/typeinfo/ti_void.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_void.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_void.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_void.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,7 +24,7 @@ class TypeInfo_v : TypeInfo\n \n     override string toString() const pure nothrow @safe { return \"void\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n         assert(0);\n     }"}, {"sha": "dcf8256bf59ab7eef8cfe4e6392c5e937fc9ba99", "filename": "libphobos/libdruntime/rt/typeinfo/ti_wchar.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_wchar.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_wchar.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Ftypeinfo%2Fti_wchar.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -24,9 +24,9 @@ class TypeInfo_u : TypeInfo\n \n     override string toString() { return \"wchar\"; }\n \n-    override size_t getHash(in void* p)\n+    override size_t getHash(scope const void* p)\n     {\n-        return *cast(wchar *)p;\n+        return *cast(const wchar *)p;\n     }\n \n     override bool equals(in void* p1, in void* p2)"}, {"sha": "13b88638296af5672d653b18cbea78acc2832b27", "filename": "libphobos/libdruntime/rt/util/container/hashtab.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Futil%2Fcontainer%2Fhashtab.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Futil%2Fcontainer%2Fhashtab.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Futil%2Fcontainer%2Fhashtab.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -146,11 +146,10 @@ private:\n \n     static hash_t hashOf(in ref Key key) @trusted\n     {\n-        import rt.util.hash : hashOf;\n         static if (is(Key U : U[]))\n-            return hashOf(key, 0);\n+            return .hashOf(key, 0);\n         else\n-            return hashOf((&key)[0 .. 1], 0);\n+            return .hashOf((&key)[0 .. 1], 0);\n     }\n \n     @property hash_t mask() const"}, {"sha": "19943a4d6d24d0b5afd305657e17d17ea8b98c72", "filename": "libphobos/libdruntime/rt/util/hash.d", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1b7b50affd1e9eea1f1e3be8a0804fd94fb6b39/libphobos%2Flibdruntime%2Frt%2Futil%2Fhash.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1b7b50affd1e9eea1f1e3be8a0804fd94fb6b39/libphobos%2Flibdruntime%2Frt%2Futil%2Fhash.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Futil%2Fhash.d?ref=f1b7b50affd1e9eea1f1e3be8a0804fd94fb6b39", "patch": "@@ -1,107 +0,0 @@\n-/**\n- * The default hash implementation.\n- *\n- * Copyright: Copyright Sean Kelly 2009 - 2016.\n- * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n- * Authors:   Sean Kelly\n- * Source: $(DRUNTIMESRC src/rt/util/_hash.d)\n- */\n-module rt.util.hash;\n-\n-\n-version (X86)\n-    version = AnyX86;\n-version (X86_64)\n-    version = AnyX86;\n-version (AnyX86)\n-    version = HasUnalignedOps;\n-\n-\n-@trusted pure nothrow @nogc\n-size_t hashOf( const(void)[] buf, size_t seed )\n-{\n-    /*\n-     * This is Paul Hsieh's SuperFastHash algorithm, described here:\n-     *   http://www.azillionmonkeys.com/qed/hash.html\n-     * It is protected by the following open source license:\n-     *   http://www.azillionmonkeys.com/qed/weblicense.html\n-     */\n-    static uint get16bits( const (ubyte)* x ) pure nothrow @nogc\n-    {\n-        // CTFE doesn't support casting ubyte* -> ushort*, so revert to\n-        // per-byte access when in CTFE.\n-        version (HasUnalignedOps)\n-        {\n-            if (!__ctfe)\n-                return *cast(ushort*) x;\n-        }\n-\n-        return ((cast(uint) x[1]) << 8) + (cast(uint) x[0]);\n-    }\n-\n-    // NOTE: SuperFastHash normally starts with a zero hash value.  The seed\n-    //       value was incorporated to allow chaining.\n-    auto data = cast(const(ubyte)*) buf.ptr;\n-    auto len = buf.length;\n-    auto hash = seed;\n-\n-    if ( len == 0 || data is null )\n-        return 0;\n-\n-    int rem = len & 3;\n-    len >>= 2;\n-\n-    for ( ; len > 0; len-- )\n-    {\n-        hash += get16bits( data );\n-        auto tmp = (get16bits( data + 2 ) << 11) ^ hash;\n-        hash  = (hash << 16) ^ tmp;\n-        data += 2 * ushort.sizeof;\n-        hash += hash >> 11;\n-    }\n-\n-    switch ( rem )\n-    {\n-    case 3: hash += get16bits( data );\n-            hash ^= hash << 16;\n-            hash ^= data[ushort.sizeof] << 18;\n-            hash += hash >> 11;\n-            break;\n-    case 2: hash += get16bits( data );\n-            hash ^= hash << 11;\n-            hash += hash >> 17;\n-            break;\n-    case 1: hash += *data;\n-            hash ^= hash << 10;\n-            hash += hash >> 1;\n-            break;\n-     default:\n-            break;\n-    }\n-\n-    /* Force \"avalanching\" of final 127 bits */\n-    hash ^= hash << 3;\n-    hash += hash >> 5;\n-    hash ^= hash << 4;\n-    hash += hash >> 17;\n-    hash ^= hash << 25;\n-    hash += hash >> 6;\n-\n-    return hash;\n-}\n-\n-unittest\n-{\n-    enum test_str = \"Sample string\";\n-    size_t hashval = hashOf(test_str, 5);\n-\n-    //import core.stdc.stdio;\n-    //printf(\"hashval = %lld\\n\", cast(long)hashval);\n-\n-    if (hashval.sizeof == 4)\n-        assert(hashval == 528740845);\n-    else if (hashval.sizeof == 8)\n-        assert(hashval == 8106800467257150594L);\n-    else\n-        assert(0);\n-}"}, {"sha": "2cc1c236c10c1c01abb24d01cdcea8b4b64cffff", "filename": "libphobos/libdruntime/rt/util/typeinfo.d", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Futil%2Ftypeinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Flibdruntime%2Frt%2Futil%2Ftypeinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Futil%2Ftypeinfo.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -6,6 +6,7 @@\n  * Authors:   Kenji Hara\n  */\n module rt.util.typeinfo;\n+static import core.internal.hash;\n \n template Floating(T)\n if (is(T == float) || is(T == double) || is(T == real))\n@@ -32,19 +33,7 @@ if (is(T == float) || is(T == double) || is(T == real))\n         return (d1 == d2) ? 0 : ((d1 < d2) ? -1 : 1);\n     }\n \n-    size_t hashOf(T value) @trusted\n-    {\n-        if (value == 0) // +0.0 and -0.0\n-            value = 0;\n-\n-        static if (is(T == float))  // special case?\n-            return *cast(uint*)&value;\n-        else\n-        {\n-            import rt.util.hash;\n-            return rt.util.hash.hashOf((&value)[0 .. 1], 0);\n-        }\n-    }\n+    public alias hashOf = core.internal.hash.hashOf;\n }\n template Floating(T)\n if (is(T == cfloat) || is(T == cdouble) || is(T == creal))\n@@ -73,13 +62,7 @@ if (is(T == cfloat) || is(T == cdouble) || is(T == creal))\n         return result;\n     }\n \n-    size_t hashOf(T value) @trusted\n-    {\n-        if (value == 0 + 0i)\n-            value = 0 + 0i;\n-        import rt.util.hash;\n-        return rt.util.hash.hashOf((&value)[0 .. 1], 0);\n-    }\n+    public alias hashOf = core.internal.hash.hashOf;\n }\n \n template Array(T)\n@@ -118,13 +101,7 @@ if (is(T ==  float) || is(T ==  double) || is(T ==  real) ||\n         return 0;\n     }\n \n-    size_t hashOf(T[] value)\n-    {\n-        size_t h = 0;\n-        foreach (e; value)\n-            h += Floating!T.hashOf(e);\n-        return h;\n-    }\n+    public alias hashOf = core.internal.hash.hashOf;\n }\n \n version (unittest)\n@@ -247,7 +224,7 @@ unittest\n         {\n             assert(f1 == 0 + 0i);\n \n-            assert(f1  == f2);\n+            assert(f1 == f2);\n             assert(f1 !is f2);\n             ti = typeid(F);\n             assert(ti.getHash(&f1) == ti.getHash(&f2));"}, {"sha": "2bfb7b28bdbe3be15d26eac7bd480e394734e04e", "filename": "libphobos/testsuite/libphobos.aa/aa.exp", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Ftestsuite%2Flibphobos.aa%2Faa.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Ftestsuite%2Flibphobos.aa%2Faa.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.aa%2Faa.exp?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -0,0 +1,29 @@\n+# Copyright (C) 2018 Free Software Foundation, Inc.\n+#\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+load_lib libphobos-dg.exp\n+\n+# Initialize dg.\n+dg-init\n+\n+# Gather a list of all tests.\n+set tests [lsort [find $srcdir/$subdir *.d]]\n+\n+# Main loop.\n+dg-runtest $tests \"\" $DEFAULT_DFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "d6222b13175a0f5e42a86ddf50534581167bd50c", "filename": "libphobos/testsuite/libphobos.aa/test_aa.d", "status": "added", "additions": 856, "deletions": 0, "changes": 856, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Ftestsuite%2Flibphobos.aa%2Ftest_aa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Ftestsuite%2Flibphobos.aa%2Ftest_aa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.aa%2Ftest_aa.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -0,0 +1,856 @@\n+void main()\n+{\n+    testKeysValues1();\n+    testKeysValues2();\n+    testGet1();\n+    testGet2();\n+    testRequire1();\n+    testRequire2();\n+    testRequire3();\n+    testUpdate1();\n+    testUpdate2();\n+    testByKey1();\n+    testByKey2();\n+    testByKey3();\n+    testByKey4();\n+    issue5842();\n+    issue5842Expanded();\n+    issue5925();\n+    issue8583();\n+    issue9052();\n+    issue9119();\n+    issue9852();\n+    issue10381();\n+    issue10720();\n+    issue11761();\n+    issue13078();\n+    issue14104();\n+    issue14626();\n+    issue15290();\n+    issue15367();\n+    issue16974();\n+    issue18071();\n+    testIterationWithConst();\n+    testStructArrayKey();\n+    miscTests1();\n+    miscTests2();\n+    testRemove();\n+    testZeroSizedValue();\n+    testTombstonePurging();\n+    testClear();\n+}\n+\n+void testKeysValues1()\n+{\n+    static struct T\n+    {\n+        byte b;\n+        static size_t count;\n+        this(this) { ++count; }\n+    }\n+    T[int] aa;\n+    T t;\n+    aa[0] = t;\n+    aa[1] = t;\n+    assert(T.count == 2);\n+    auto vals = aa.values;\n+    assert(vals.length == 2);\n+    assert(T.count == 4);\n+\n+    T.count = 0;\n+    int[T] aa2;\n+    aa2[t] = 0;\n+    assert(T.count == 1);\n+    aa2[t] = 1;\n+    assert(T.count == 1);\n+    auto keys = aa2.keys;\n+    assert(keys.length == 1);\n+    assert(T.count == 2);\n+}\n+\n+void testKeysValues2() nothrow pure\n+{\n+    int[string] aa;\n+\n+    assert(aa.keys.length == 0);\n+    assert(aa.values.length == 0);\n+\n+    aa[\"hello\"] = 3;\n+    assert(aa[\"hello\"] == 3);\n+    aa[\"hello\"]++;\n+    assert(aa[\"hello\"] == 4);\n+\n+    assert(aa.length == 1);\n+\n+    string[] keys = aa.keys;\n+    assert(keys.length == 1);\n+    assert(keys[0] == \"hello\");\n+\n+    int[] values = aa.values;\n+    assert(values.length == 1);\n+    assert(values[0] == 4);\n+\n+    aa.rehash;\n+    assert(aa.length == 1);\n+    assert(aa[\"hello\"] == 4);\n+\n+    aa[\"foo\"] = 1;\n+    aa[\"bar\"] = 2;\n+    aa[\"batz\"] = 3;\n+\n+    assert(aa.keys.length == 4);\n+    assert(aa.values.length == 4);\n+\n+    foreach (a; aa.keys)\n+    {\n+        assert(a.length != 0);\n+        assert(a.ptr != null);\n+    }\n+\n+    foreach (v; aa.values)\n+    {\n+        assert(v != 0);\n+    }\n+}\n+\n+void testGet1() @safe\n+{\n+    int[string] aa;\n+    int a;\n+    foreach (val; aa.byKeyValue)\n+    {\n+        ++aa[val.key];\n+        a = val.value;\n+    }\n+}\n+\n+void testGet2()\n+{\n+    static class T\n+    {\n+        static size_t count;\n+        this() { ++count; }\n+    }\n+\n+    T[string] aa;\n+\n+    auto a = new T;\n+    aa[\"foo\"] = a;\n+    assert(T.count == 1);\n+    auto b = aa.get(\"foo\", new T);\n+    assert(T.count == 1);\n+    assert(b is a);\n+    auto c = aa.get(\"bar\", new T);\n+    assert(T.count == 2);\n+    assert(c !is a);\n+\n+    //Obviously get doesn't add.\n+    assert(\"bar\" !in aa);\n+}\n+\n+void testRequire1()\n+{\n+    static class T\n+    {\n+        static size_t count;\n+        this() { ++count; }\n+    }\n+\n+    T[string] aa;\n+\n+    auto a = new T;\n+    aa[\"foo\"] = a;\n+    assert(T.count == 1);\n+    auto b = aa.require(\"foo\", new T);\n+    assert(T.count == 1);\n+    assert(b is a);\n+    auto c = aa.require(\"bar\", null);\n+    assert(T.count == 1);\n+    assert(c is null);\n+    assert(\"bar\" in aa);\n+    auto d = aa.require(\"bar\", new T);\n+    assert(d is null);\n+    auto e = aa.require(\"baz\", new T);\n+    assert(T.count == 2);\n+    assert(e !is a);\n+\n+    assert(\"baz\" in aa);\n+\n+    bool created = false;\n+    auto f = aa.require(\"qux\", { created = true; return new T; }());\n+    assert(created == true);\n+\n+    T g;\n+    auto h = aa.require(\"qux\", { g = new T; return g; }());\n+    assert(g !is h);\n+}\n+\n+void testRequire2()\n+{\n+    static struct S\n+    {\n+        int value;\n+    }\n+\n+    S[string] aa;\n+\n+    aa.require(\"foo\").value = 1;\n+    assert(aa == [\"foo\" : S(1)]);\n+\n+    aa[\"bar\"] = S(2);\n+    auto a = aa.require(\"bar\", S(3));\n+    assert(a == S(2));\n+\n+    auto b = aa[\"bar\"];\n+    assert(b == S(2));\n+\n+    S* c = &aa.require(\"baz\", S(4));\n+    assert(c is &aa[\"baz\"]);\n+    assert(*c == S(4));\n+\n+    assert(\"baz\" in aa);\n+\n+    auto d = aa[\"baz\"];\n+    assert(d == S(4));\n+}\n+\n+void testRequire3() pure\n+{\n+    string[string] aa;\n+\n+    auto a = aa.require(\"foo\", \"bar\");\n+    assert(\"foo\" in aa);\n+}\n+\n+\n+void testUpdate1()\n+{\n+    static class C {}\n+    C[string] aa;\n+\n+    C orig = new C;\n+    aa[\"foo\"] = orig;\n+\n+    C newer;\n+    C older;\n+\n+    void test(string key)\n+    {\n+        aa.update(key, {\n+            newer = new C;\n+            return newer;\n+        }, (ref C c) {\n+            older = c;\n+            newer = new C;\n+            return newer;\n+        });\n+    }\n+\n+    test(\"foo\");\n+    assert(older is orig);\n+    assert(newer is aa[\"foo\"]);\n+\n+    test(\"bar\");\n+    assert(newer is aa[\"bar\"]);\n+}\n+\n+void testUpdate2()\n+{\n+    static class C {}\n+    C[string] aa;\n+\n+    auto created = false;\n+    auto updated = false;\n+\n+    class Creator\n+    {\n+        C opCall()\n+        {\n+            created = true;\n+            return new C();\n+        }\n+    }\n+\n+    class Updater\n+    {\n+        C opCall(ref C)\n+        {\n+            updated = true;\n+            return new C();\n+        }\n+    }\n+\n+    aa.update(\"foo\", new Creator, new Updater);\n+    assert(created);\n+    aa.update(\"foo\", new Creator, new Updater);\n+    assert(updated);\n+}\n+\n+void testByKey1()\n+{\n+    static assert(!__traits(compiles,\n+        () @safe {\n+            struct BadValue\n+            {\n+                int x;\n+                this(this) @safe { *(cast(ubyte*)(null) + 100000) = 5; } // not @safe\n+                alias x this;\n+            }\n+\n+            BadValue[int] aa;\n+            () @safe { auto x = aa.byKey.front; } ();\n+        }\n+    ));\n+}\n+\n+void testByKey2() nothrow pure\n+{\n+    int[int] a;\n+    foreach (i; a.byKey)\n+    {\n+        assert(false);\n+    }\n+    foreach (i; a.byValue)\n+    {\n+        assert(false);\n+    }\n+}\n+\n+void testByKey3() /*nothrow*/ pure\n+{\n+    auto a = [ 1:\"one\", 2:\"two\", 3:\"three\" ];\n+    auto b = a.dup;\n+    assert(b == [ 1:\"one\", 2:\"two\", 3:\"three\" ]);\n+\n+    int[] c;\n+    foreach (k; a.byKey)\n+    {\n+        c ~= k;\n+    }\n+\n+    assert(c.length == 3);\n+    assert(c[0] == 1 || c[1] == 1 || c[2] == 1);\n+    assert(c[0] == 2 || c[1] == 2 || c[2] == 2);\n+    assert(c[0] == 3 || c[1] == 3 || c[2] == 3);\n+}\n+\n+void testByKey4() nothrow pure\n+{\n+    string[] keys = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n+\n+    // Test forward range capabilities of byKey\n+    {\n+        int[string] aa;\n+        foreach (key; keys)\n+            aa[key] = 0;\n+\n+        auto keyRange = aa.byKey();\n+        auto savedKeyRange = keyRange.save;\n+\n+        // Consume key range once\n+        size_t keyCount = 0;\n+        while (!keyRange.empty)\n+        {\n+            aa[keyRange.front]++;\n+            keyCount++;\n+            keyRange.popFront();\n+        }\n+\n+        foreach (key; keys)\n+        {\n+            assert(aa[key] == 1);\n+        }\n+        assert(keyCount == keys.length);\n+\n+        // Verify it's possible to iterate the range the second time\n+        keyCount = 0;\n+        while (!savedKeyRange.empty)\n+        {\n+            aa[savedKeyRange.front]++;\n+            keyCount++;\n+            savedKeyRange.popFront();\n+        }\n+\n+        foreach (key; keys)\n+        {\n+            assert(aa[key] == 2);\n+        }\n+        assert(keyCount == keys.length);\n+    }\n+\n+    // Test forward range capabilities of byValue\n+    {\n+        size_t[string] aa;\n+        foreach (i; 0 .. keys.length)\n+        {\n+            aa[keys[i]] = i;\n+        }\n+\n+        auto valRange = aa.byValue();\n+        auto savedValRange = valRange.save;\n+\n+        // Consume value range once\n+        int[] hasSeen;\n+        hasSeen.length = keys.length;\n+        while (!valRange.empty)\n+        {\n+            assert(hasSeen[valRange.front] == 0);\n+            hasSeen[valRange.front]++;\n+            valRange.popFront();\n+        }\n+\n+        foreach (sawValue; hasSeen) { assert(sawValue == 1); }\n+\n+        // Verify it's possible to iterate the range the second time\n+        hasSeen = null;\n+        hasSeen.length = keys.length;\n+        while (!savedValRange.empty)\n+        {\n+            assert(!hasSeen[savedValRange.front]);\n+            hasSeen[savedValRange.front] = true;\n+            savedValRange.popFront();\n+        }\n+\n+        foreach (sawValue; hasSeen) { assert(sawValue); }\n+    }\n+}\n+\n+void issue5842() pure nothrow\n+{\n+    string[string] test = null;\n+    test[\"test1\"] = \"test1\";\n+    test.remove(\"test1\");\n+    test.rehash;\n+    test[\"test3\"] = \"test3\"; // causes divide by zero if rehash broke the AA\n+}\n+\n+/// expanded test for 5842: increase AA size past the point where the AA\n+/// stops using binit, in order to test another code path in rehash.\n+void issue5842Expanded() pure nothrow\n+{\n+    int[int] aa;\n+    foreach (int i; 0 .. 32)\n+        aa[i] = i;\n+    foreach (int i; 0 .. 32)\n+        aa.remove(i);\n+    aa.rehash;\n+    aa[1] = 1;\n+}\n+\n+void issue5925() nothrow pure\n+{\n+    const a = [4:0];\n+    const b = [4:0];\n+    assert(a == b);\n+}\n+\n+/// test for bug 8583: ensure Slot and aaA are on the same page wrt value alignment\n+void issue8583() nothrow pure\n+{\n+    string[byte]    aa0 = [0: \"zero\"];\n+    string[uint[3]] aa1 = [[1,2,3]: \"onetwothree\"];\n+    ushort[uint[3]] aa2 = [[9,8,7]: 987];\n+    ushort[uint[4]] aa3 = [[1,2,3,4]: 1234];\n+    string[uint[5]] aa4 = [[1,2,3,4,5]: \"onetwothreefourfive\"];\n+\n+    assert(aa0.byValue.front == \"zero\");\n+    assert(aa1.byValue.front == \"onetwothree\");\n+    assert(aa2.byValue.front == 987);\n+    assert(aa3.byValue.front == 1234);\n+    assert(aa4.byValue.front == \"onetwothreefourfive\");\n+}\n+\n+void issue9052() nothrow pure\n+{\n+    static struct Json {\n+        Json[string] aa;\n+        void opAssign(Json) {}\n+        size_t length() const { return aa.length; }\n+        // This length() instantiates AssociativeArray!(string, const(Json)) to call AA.length(), and\n+        // inside ref Slot opAssign(Slot p); (which is automatically generated by compiler in Slot),\n+        // this.value = p.value would actually fail, because both side types of the assignment\n+        // are const(Json).\n+    }\n+}\n+\n+void issue9119()\n+{\n+    int[string] aa;\n+    assert(aa.byKeyValue.empty);\n+\n+    aa[\"a\"] = 1;\n+    aa[\"b\"] = 2;\n+    aa[\"c\"] = 3;\n+\n+    auto pairs = aa.byKeyValue;\n+\n+    auto savedPairs = pairs.save;\n+    size_t count = 0;\n+    while (!pairs.empty)\n+    {\n+        assert(pairs.front.key in aa);\n+        assert(pairs.front.value == aa[pairs.front.key]);\n+        count++;\n+        pairs.popFront();\n+    }\n+    assert(count == aa.length);\n+\n+    // Verify that saved range can iterate over the AA again\n+    count = 0;\n+    while (!savedPairs.empty)\n+    {\n+        assert(savedPairs.front.key in aa);\n+        assert(savedPairs.front.value == aa[savedPairs.front.key]);\n+        count++;\n+        savedPairs.popFront();\n+    }\n+    assert(count == aa.length);\n+}\n+\n+void issue9852() nothrow pure\n+{\n+    // Original test case (revised, original assert was wrong)\n+    int[string] a;\n+    a[\"foo\"] = 0;\n+    a.remove(\"foo\");\n+    assert(a == null); // should not crash\n+\n+    int[string] b;\n+    assert(b is null);\n+    assert(a == b); // should not deref null\n+    assert(b == a); // ditto\n+\n+    int[string] c;\n+    c[\"a\"] = 1;\n+    assert(a != c); // comparison with empty non-null AA\n+    assert(c != a);\n+    assert(b != c); // comparison with null AA\n+    assert(c != b);\n+}\n+\n+void issue10381()\n+{\n+    alias II = int[int];\n+    II aa1 = [0 : 1];\n+    II aa2 = [0 : 1];\n+    II aa3 = [0 : 2];\n+    assert(aa1 == aa2); // Passes\n+    assert(typeid(II).equals(&aa1, &aa2));\n+    assert(!typeid(II).equals(&aa1, &aa3));\n+}\n+\n+void issue10720() nothrow pure\n+{\n+    static struct NC\n+    {\n+        @disable this(this) { }\n+    }\n+\n+    NC[string] aa;\n+    static assert(!is(aa.nonExistingField));\n+}\n+\n+/// bug 11761: test forward range functionality\n+void issue11761() pure nothrow\n+{\n+    auto aa = [\"a\": 1];\n+\n+    void testFwdRange(R, T)(R fwdRange, T testValue)\n+    {\n+        assert(!fwdRange.empty);\n+        assert(fwdRange.front == testValue);\n+        static assert(is(typeof(fwdRange.save) == typeof(fwdRange)));\n+\n+        auto saved = fwdRange.save;\n+        fwdRange.popFront();\n+        assert(fwdRange.empty);\n+\n+        assert(!saved.empty);\n+        assert(saved.front == testValue);\n+        saved.popFront();\n+        assert(saved.empty);\n+    }\n+\n+    testFwdRange(aa.byKey, \"a\");\n+    testFwdRange(aa.byValue, 1);\n+    //testFwdRange(aa.byPair, tuple(\"a\", 1));\n+}\n+\n+void issue13078() nothrow pure\n+{\n+    shared string[][string] map;\n+    map.rehash;\n+}\n+\n+void issue14104()\n+{\n+    import core.stdc.stdio;\n+\n+    alias K = const(ubyte)*;\n+    size_t[K] aa;\n+    immutable key = cast(K)(cast(size_t) uint.max + 1);\n+    aa[key] = 12;\n+    assert(key in aa);\n+}\n+\n+void issue14626()\n+{\n+    static struct S\n+    {\n+        string[string] aa;\n+        inout(string) key() inout { return aa.byKey().front; }\n+        inout(string) val() inout { return aa.byValue().front; }\n+        auto keyval() inout { return aa.byKeyValue().front; }\n+    }\n+\n+    S s = S([\"a\":\"b\"]);\n+    assert(s.key() == \"a\");\n+    assert(s.val() == \"b\");\n+    assert(s.keyval().key == \"a\");\n+    assert(s.keyval().value == \"b\");\n+\n+    void testInoutKeyVal(inout(string) key)\n+    {\n+        inout(string)[typeof(key)] aa;\n+\n+        foreach (i; aa.byKey()) {}\n+        foreach (i; aa.byValue()) {}\n+        foreach (i; aa.byKeyValue()) {}\n+    }\n+\n+    const int[int] caa;\n+    static assert(is(typeof(caa.byValue().front) == const int));\n+}\n+\n+/// test duplicated keys in AA literal\n+/// https://issues.dlang.org/show_bug.cgi?id=15290\n+void issue15290()\n+{\n+    string[int] aa = [ 0: \"a\", 0: \"b\" ];\n+    assert(aa.length == 1);\n+    assert(aa.keys == [ 0 ]);\n+}\n+\n+void issue15367()\n+{\n+    void f1() {}\n+    void f2() {}\n+\n+    // TypeInfo_Delegate.getHash\n+    int[void delegate()] aa;\n+    assert(aa.length == 0);\n+    aa[&f1] = 1;\n+    assert(aa.length == 1);\n+    aa[&f1] = 1;\n+    assert(aa.length == 1);\n+\n+    auto a1 = [&f2, &f1];\n+    auto a2 = [&f2, &f1];\n+\n+    // TypeInfo_Delegate.equals\n+    for (auto i = 0; i < 2; i++)\n+        assert(a1[i] == a2[i]);\n+    assert(a1 == a2);\n+\n+    // TypeInfo_Delegate.compare\n+    for (auto i = 0; i < 2; i++)\n+        assert(a1[i] <= a2[i]);\n+    assert(a1 <= a2);\n+}\n+\n+/// test AA as key\n+/// https://issues.dlang.org/show_bug.cgi?id=16974\n+void issue16974()\n+{\n+    int[int] a = [1 : 2], a2 = [1 : 2];\n+\n+    assert([a : 3] == [a : 3]);\n+    assert([a : 3] == [a2 : 3]);\n+\n+    assert(typeid(a).getHash(&a) == typeid(a).getHash(&a));\n+    assert(typeid(a).getHash(&a) == typeid(a).getHash(&a2));\n+}\n+\n+/// test safety for alias-this'd AA that have unsafe opCast\n+/// https://issues.dlang.org/show_bug.cgi?id=18071\n+void issue18071()\n+{\n+    static struct Foo\n+    {\n+        int[int] aa;\n+        auto opCast() pure nothrow @nogc\n+        {\n+            *cast(uint*)0xdeadbeef = 0xcafebabe;// unsafe\n+            return null;\n+        }\n+        alias aa this;\n+    }\n+\n+    Foo f;\n+    () @safe { assert(f.byKey.empty); }();\n+}\n+\n+/// Verify iteration with const.\n+void testIterationWithConst()\n+{\n+    auto aa = [1:2, 3:4];\n+    foreach (const t; aa.byKeyValue)\n+    {\n+        auto k = t.key;\n+        auto v = t.value;\n+    }\n+}\n+\n+void testStructArrayKey() @safe\n+{\n+    struct S\n+    {\n+        int i;\n+    const @safe nothrow:\n+        hash_t toHash() { return 0; }\n+        bool opEquals(const S) { return true; }\n+        int opCmp(const S) { return 0; }\n+    }\n+\n+    int[S[]] aa = [[S(11)] : 13];\n+    assert(aa[[S(12)]] == 13);\n+}\n+\n+void miscTests1() pure nothrow\n+{\n+    string[int] key1 = [1 : \"true\", 2 : \"false\"];\n+    string[int] key2 = [1 : \"false\", 2 : \"true\"];\n+    string[int] key3;\n+\n+    // AA lits create a larger hashtable\n+    int[string[int]] aa1 = [key1 : 100, key2 : 200, key3 : 300];\n+\n+    // Ensure consistent hash values are computed for key1\n+    assert((key1 in aa1) !is null);\n+\n+    // Manually assigning to an empty AA creates a smaller hashtable\n+    int[string[int]] aa2;\n+    aa2[key1] = 100;\n+    aa2[key2] = 200;\n+    aa2[key3] = 300;\n+\n+    assert(aa1 == aa2);\n+\n+    // Ensure binary-independence of equal hash keys\n+    string[int] key2a;\n+    key2a[1] = \"false\";\n+    key2a[2] = \"true\";\n+\n+    assert(aa1[key2a] == 200);\n+}\n+\n+void miscTests2()\n+{\n+    int[int] aa;\n+    foreach (k, v; aa)\n+        assert(false);\n+    foreach (v; aa)\n+        assert(false);\n+    assert(aa.byKey.empty);\n+    assert(aa.byValue.empty);\n+    assert(aa.byKeyValue.empty);\n+\n+    size_t n;\n+    aa = [0 : 3, 1 : 4, 2 : 5];\n+    foreach (k, v; aa)\n+    {\n+        n += k;\n+        assert(k >= 0 && k < 3);\n+        assert(v >= 3 && v < 6);\n+    }\n+    assert(n == 3);\n+    n = 0;\n+\n+    foreach (v; aa)\n+    {\n+        n += v;\n+        assert(v >= 3 && v < 6);\n+    }\n+    assert(n == 12);\n+\n+    n = 0;\n+    foreach (k, v; aa)\n+    {\n+        ++n;\n+        break;\n+    }\n+    assert(n == 1);\n+\n+    n = 0;\n+    foreach (v; aa)\n+    {\n+        ++n;\n+        break;\n+    }\n+    assert(n == 1);\n+}\n+\n+void testRemove()\n+{\n+    int[int] aa;\n+    assert(!aa.remove(0));\n+    aa = [0 : 1];\n+    assert(aa.remove(0));\n+    assert(!aa.remove(0));\n+    aa[1] = 2;\n+    assert(!aa.remove(0));\n+    assert(aa.remove(1));\n+\n+    assert(aa.length == 0);\n+    assert(aa.byKey.empty);\n+}\n+\n+/// test zero sized value (hashset)\n+void testZeroSizedValue()\n+{\n+    alias V = void[0];\n+    auto aa = [0 : V.init];\n+    assert(aa.length == 1);\n+    assert(aa.byKey.front == 0);\n+    assert(aa.byValue.front == V.init);\n+    aa[1] = V.init;\n+    assert(aa.length == 2);\n+    aa[0] = V.init;\n+    assert(aa.length == 2);\n+    assert(aa.remove(0));\n+    aa[0] = V.init;\n+    assert(aa.length == 2);\n+    assert(aa == [0 : V.init, 1 : V.init]);\n+}\n+\n+void testTombstonePurging()\n+{\n+    int[int] aa;\n+    foreach (i; 0 .. 6)\n+        aa[i] = i;\n+    foreach (i; 0 .. 6)\n+        assert(aa.remove(i));\n+    foreach (i; 6 .. 10)\n+        aa[i] = i;\n+    assert(aa.length == 4);\n+    foreach (i; 6 .. 10)\n+        assert(i in aa);\n+}\n+\n+void testClear()\n+{\n+    int[int] aa;\n+    assert(aa.length == 0);\n+    foreach (i; 0 .. 100)\n+        aa[i] = i * 2;\n+    assert(aa.length == 100);\n+    auto aa2 = aa;\n+    assert(aa2.length == 100);\n+    aa.clear();\n+    assert(aa.length == 0);\n+    assert(aa2.length == 0);\n+\n+    aa2[5] = 6;\n+    assert(aa.length == 1);\n+    assert(aa[5] == 6);\n+}"}, {"sha": "2bfb7b28bdbe3be15d26eac7bd480e394734e04e", "filename": "libphobos/testsuite/libphobos.hash/hash.exp", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Ftestsuite%2Flibphobos.hash%2Fhash.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Ftestsuite%2Flibphobos.hash%2Fhash.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.hash%2Fhash.exp?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -0,0 +1,29 @@\n+# Copyright (C) 2018 Free Software Foundation, Inc.\n+#\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+load_lib libphobos-dg.exp\n+\n+# Initialize dg.\n+dg-init\n+\n+# Gather a list of all tests.\n+set tests [lsort [find $srcdir/$subdir *.d]]\n+\n+# Main loop.\n+dg-runtest $tests \"\" $DEFAULT_DFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "5229c842cdf100060d63090882e37b0f9128e9ad", "filename": "libphobos/testsuite/libphobos.hash/test_hash.d", "status": "added", "additions": 540, "deletions": 0, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Ftestsuite%2Flibphobos.hash%2Ftest_hash.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e613d992667a90ff731bbcecbb4ae6fa15adde31/libphobos%2Ftestsuite%2Flibphobos.hash%2Ftest_hash.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.hash%2Ftest_hash.d?ref=e613d992667a90ff731bbcecbb4ae6fa15adde31", "patch": "@@ -0,0 +1,540 @@\n+void main()\n+{\n+    issue19562();\n+    issue15111();\n+    issues16654And16764();\n+    issue18918();\n+    issue18925();\n+    issue19005();\n+    issue19204();\n+    issue19262();\n+    issue19568();\n+    issue19582();\n+    testTypeInfoArrayGetHash1();\n+    testTypeInfoArrayGetHash2();\n+    pr2243();\n+}\n+\n+/// Check hashOf an array of void pointers or delegates is @safe.\n+void issue19562() @nogc nothrow pure @safe\n+{\n+    void*[10] val;\n+    size_t h = hashOf(val[]);\n+\n+    alias D = void delegate();\n+    D[10] ds;\n+    h = hashOf(ds[]);\n+}\n+\n+/// hashOf was failing for structs that had an `alias this` to a dynamic array.\n+void issue15111()\n+{\n+    void testAlias(T)()\n+    {\n+        static struct Foo\n+        {\n+            T t;\n+            alias t this;\n+        }\n+        Foo foo;\n+        static assert(is(typeof(hashOf(foo))));\n+    }\n+    // was fixed\n+    testAlias!(int[]);\n+    testAlias!(int*);\n+    // was not affected\n+    testAlias!int;\n+    testAlias!(void delegate());\n+    testAlias!(string[string]);\n+    testAlias!(int[8]);\n+}\n+\n+void issues16654And16764()\n+{\n+    auto a = [1];\n+    auto b = a.dup;\n+    assert(hashOf(a) == hashOf(b));\n+}\n+\n+/// Check hashOf dynamic array of scalars is usable in @safe code.\n+void issue18918() nothrow pure @safe\n+{\n+    const _ = (() @nogc => hashOf(\"abc\"))();\n+\n+    static struct S { string array; }\n+    auto s1 = S(\"abc\");\n+    auto s2 = S(s1.array.idup);\n+    assert(hashOf(s1) == hashOf(s2));\n+    enum e = hashOf(S(\"abc\"));\n+    assert(hashOf(s1) == e);\n+}\n+\n+/// Check hashOf struct of scalar fields is usable in @safe code.\n+void issue18925() @nogc nothrow pure @safe\n+{\n+\n+    static struct S { int a; int b; }\n+    auto h = hashOf(S.init);\n+}\n+\n+void issue19005() @nogc nothrow pure @safe\n+{\n+    enum Month : ubyte\n+    {\n+        jan = 1\n+    }\n+    static struct Date\n+    {\n+        short _year;\n+        Month _month;\n+        ubyte _day;\n+    }\n+    Date date;\n+    auto hash = date.hashOf;\n+}\n+\n+/// Accept SIMD vectors.\n+void issue19204() @nogc nothrow pure @safe\n+{\n+    version (D_SIMD)\n+    {\n+        static import simd = core.simd;\n+        static if (is(simd.int4)) // __traits(isArithmetic)\n+        {{\n+            enum simd.int4 val = [1,2,3,4];\n+            enum ctfeHash = hashOf(val);\n+            simd.int4 rtVal = val;\n+            auto rtHash = hashOf(rtVal);\n+            assert(ctfeHash == rtHash);\n+        }}\n+        static if (is(simd.void16)) // non __traits(isArithmetic)\n+        {{\n+            auto h = hashOf(simd.void16.init);\n+        }}\n+        static if (is(simd.float4)) // __traits(isArithmetic) and __traits(isFloating)\n+        {{\n+            enum simd.float4 val = [1.1f, 2.2f, 3.3f, 4.4f];\n+            enum ctfeHash = hashOf(val);\n+            simd.float4 rtVal = val;\n+            auto rtHash = hashOf(rtVal);\n+            assert(ctfeHash == rtHash);\n+        }}\n+    }\n+}\n+\n+/// hashOf associative array should infer nothrow\n+void issue19262() nothrow\n+{\n+    int[int] aa;\n+    auto h = hashOf(aa);\n+    h = hashOf(aa, h);\n+}\n+\n+/// hashOf should not unnecessarily call a struct's fields' postblits & dtors in CTFE\n+void issue19568()\n+{\n+    static struct S1\n+    {\n+        @disable this(this);\n+\n+        ~this() @nogc nothrow\n+        {\n+            import core.stdc.stdio;\n+            if (mptr) puts(\"impure\");\n+        }\n+\n+        size_t[2] pad;\n+        void* mptr;\n+    }\n+\n+    static struct S2\n+    {\n+        @disable this(this);\n+\n+        ~this() @nogc nothrow\n+        {\n+            import core.stdc.stdio;\n+            if (fd != -1) puts(\"impure\");\n+        }\n+\n+        int fd = -1;\n+        S1 s1;\n+    }\n+\n+    static struct S3\n+    {\n+        private S2 s2;\n+    }\n+\n+    S3 s3;\n+    size_t h = ((ref S3 s3) pure => hashOf(s3))(s3);\n+}\n+\n+/// Check core.internal.convert.toUbyte in CTFE for arrays works with\n+/// reference type elements and doesn't call postblits/dtors.\n+void issue19582()\n+{\n+    import core.internal.convert : toUbyte;\n+    final static class C : Object {}\n+    enum b1 = (() @nogc nothrow pure @safe { C[10] o; return toUbyte(o[])[0]; })();\n+\n+    static struct S\n+    {\n+        int x;\n+        @disable this(this);\n+        ~this() @nogc nothrow\n+        {\n+            import core.stdc.stdio : puts;\n+            if (x) puts(\"impure\");\n+        }\n+    }\n+    enum b2 = () {\n+            S[10] a;\n+            return ((const S[] a) @nogc nothrow pure @safe => toUbyte(a))(a);\n+        }();\n+}\n+\n+/// Tests ensure TypeInfo_Array.getHash uses element hash functions instead\n+/// of hashing array data.\n+void testTypeInfoArrayGetHash1()\n+{\n+    class C\n+    {\n+        int i;\n+        this(in int i) { this.i = i; }\n+        override hash_t toHash() { return 0; }\n+    }\n+    C[] a1 = [new C(11)], a2 = [new C(12)];\n+    assert(typeid(C[]).getHash(&a1) == typeid(C[]).getHash(&a2));\n+}\n+\n+/// ditto\n+void testTypeInfoArrayGetHash2()\n+{\n+    struct S\n+    {\n+        int i;\n+        hash_t toHash() const @safe nothrow { return 0; }\n+    }\n+    S[] a1 = [S(11)], a2 = [S(12)];\n+    assert(typeid(S[]).getHash(&a1) == typeid(S[]).getHash(&a2));\n+}\n+\n+/++\n+Use the new `core.internal.hash.hashOf` in all `TypeInfo.getHash` instead of\n+the `old rt.util.hash.hashOf`. Also make `typeid(T).getHash(&val)` get the\n+same result as `hashOf(val)`.\n++/\n+void pr2243()\n+{\n+    static struct Foo\n+    {\n+        int a = 99;\n+        float b = 4.0;\n+        size_t toHash() const pure @safe nothrow\n+        {\n+            return a;\n+        }\n+    }\n+\n+    static struct Bar\n+    {\n+        char c = 'x';\n+        int a = 99;\n+        float b = 4.0;\n+        void* d = null;\n+    }\n+\n+    static struct Boom\n+    {\n+        char c = 'M';\n+        int* a = null;\n+    }\n+\n+    static struct Plain\n+    {\n+        int a = 1;\n+        int b = 2;\n+    }\n+\n+    interface IBoo\n+    {\n+        void boo();\n+    }\n+\n+    static class Boo: IBoo\n+    {\n+        override void boo()\n+        {\n+        }\n+\n+        override size_t toHash()\n+        {\n+            return 1;\n+        }\n+    }\n+\n+    static struct Goo\n+    {\n+        size_t toHash() pure @safe nothrow\n+        {\n+            return 1;\n+        }\n+    }\n+\n+    enum Gun: long\n+    {\n+        A = 99,\n+        B = 17\n+    }\n+\n+    enum double dexpr = 3.14;\n+    enum float fexpr = 2.71;\n+    enum wstring wsexpr = \"abcdef\"w;\n+    enum string csexpr = \"abcdef\";\n+    enum int iexpr = 7;\n+    enum long lexpr = 42;\n+    enum int[2][3] saexpr = [[1, 2], [3, 4], [5, 6]];\n+    enum int[] daexpr = [7,8,9];\n+    enum Foo thsexpr = Foo();\n+    enum Bar vsexpr = Bar();\n+    enum int[int] aaexpr = [99:2, 12:6, 45:4];\n+    enum Gun eexpr = Gun.A;\n+    enum cdouble cexpr = 7+4i;\n+    enum Foo[] staexpr = [Foo(), Foo(), Foo()];\n+    enum Bar[] vsaexpr = [Bar(), Bar(), Bar()];\n+    enum realexpr = 7.88;\n+    enum raexpr = [8.99L+86i, 3.12L+99i, 5.66L+12i];\n+    enum nullexpr = null;\n+    enum plstr = Plain();\n+    enum plarrstr = [Plain(), Plain(), Plain()];\n+    //No CTFE:\n+    Boom rstructexpr = Boom();\n+    Boom[] rstrarrexpr = [Boom(), Boom(), Boom()];\n+    int delegate() dgexpr  = (){return 78;};\n+    void* ptrexpr = &dgexpr;\n+\n+\n+    //CTFE hashes\n+    enum h1 = dexpr.hashOf();\n+    enum h2 = fexpr.hashOf();\n+    enum h3 = wsexpr.hashOf();\n+    enum h4 = csexpr.hashOf();\n+    enum h5 = iexpr.hashOf();\n+    enum h6 = lexpr.hashOf();\n+    enum h7 = saexpr.hashOf();\n+    enum h8 = daexpr.hashOf();\n+    enum h9 = thsexpr.hashOf();\n+    enum h10 = vsexpr.hashOf();\n+    enum h11 = aaexpr.hashOf();\n+    enum h12 = eexpr.hashOf();\n+    enum h13 = cexpr.hashOf();\n+    enum h14 = hashOf(new Boo);\n+    enum h15 = staexpr.hashOf();\n+    enum h16 = hashOf([new Boo, new Boo, new Boo]);\n+    enum h17 = hashOf([cast(IBoo)new Boo, cast(IBoo)new Boo, cast(IBoo)new Boo]);\n+    enum h18 = hashOf(cast(IBoo)new Boo);\n+    enum h19 = vsaexpr.hashOf();\n+    enum h20 = hashOf(cast(Foo[3])staexpr);\n+\n+    //BUG: cannot cast [Boo(), Boo(), Boo()][0] to object.Object at compile time\n+    auto h21 = hashOf(cast(Boo[3])[new Boo, new Boo, new Boo]);\n+    auto h22 = hashOf(cast(IBoo[3])[cast(IBoo)new Boo, cast(IBoo)new Boo, cast(IBoo)new Boo]);\n+    enum h23 = hashOf(cast(Bar[3])vsaexpr);\n+\n+    //NO CTFE (Compute, but don't check correctness):\n+    auto h24 = rstructexpr.hashOf();\n+    auto h25 = rstrarrexpr.hashOf();\n+    auto h26 = dgexpr.hashOf();\n+    auto h27 = ptrexpr.hashOf();\n+\n+    enum h28 = realexpr.hashOf();\n+    enum h29 = raexpr.hashOf();\n+    enum h30 = nullexpr.hashOf();\n+    enum h31 = plstr.hashOf();\n+    enum h32 = plarrstr.hashOf();\n+    enum h33 = hashOf(cast(Plain[3])plarrstr);\n+\n+    auto v1 = dexpr;\n+    auto v2 = fexpr;\n+    auto v3 = wsexpr;\n+    auto v4 = csexpr;\n+    auto v5 = iexpr;\n+    auto v6 = lexpr;\n+    auto v7 = saexpr;\n+    auto v8 = daexpr;\n+    auto v9 = thsexpr;\n+    auto v10 = vsexpr;\n+    auto v11 = aaexpr;\n+    auto v12 = eexpr;\n+    auto v13 = cexpr;\n+    auto v14 = new Boo;\n+    auto v15 = staexpr;\n+    auto v16 = [new Boo, new Boo, new Boo];\n+    auto v17 = [cast(IBoo)new Boo, cast(IBoo)new Boo, cast(IBoo)new Boo];\n+    auto v18 = cast(IBoo)new Boo;\n+    auto v19 = vsaexpr;\n+    auto v20 = cast(Foo[3])staexpr;\n+    auto v21 = cast(Boo[3])[new Boo, new Boo, new Boo];\n+    auto v22 = cast(IBoo[3])[cast(IBoo)new Boo, cast(IBoo)new Boo, cast(IBoo)new Boo];\n+    auto v23 = cast(Bar[3])vsaexpr;\n+    auto v30 = null;\n+    auto v31 = plstr;\n+    auto v32 = plarrstr;\n+    auto v33 = cast(Plain[3])plarrstr;\n+\n+    //NO CTFE:\n+    auto v24 = rstructexpr;\n+    auto v25 = rstrarrexpr;\n+    auto v26 = dgexpr;\n+    auto v27 = ptrexpr;\n+    auto v28 = realexpr;\n+    auto v29 = raexpr;\n+\n+    //runtime hashes\n+    auto rth1 = hashOf(v1);\n+    auto rth2 = hashOf(v2);\n+    auto rth3 = hashOf(v3);\n+    auto rth4 = hashOf(v4);\n+    auto rth5 = hashOf(v5);\n+    auto rth6 = hashOf(v6);\n+    auto rth7 = hashOf(v7);\n+    auto rth8 = hashOf(v8);\n+    auto rth9 = hashOf(v9);\n+    auto rth10 = hashOf(v10);\n+    auto rth11 = hashOf(v11);\n+    auto rth12 = hashOf(v12);\n+    auto rth13 = hashOf(v13);\n+    auto rth14 = hashOf(v14);\n+    auto rth15 = hashOf(v15);\n+    auto rth16 = hashOf(v16);\n+    auto rth17 = hashOf(v17);\n+    auto rth18 = hashOf(v18);\n+    auto rth19 = hashOf(v19);\n+    auto rth20 = hashOf(v20);\n+    auto rth21 = hashOf(v21);\n+    auto rth22 = hashOf(v22);\n+    auto rth23 = hashOf(v23);\n+    auto rth30 = hashOf(v30);\n+    //NO CTFE:\n+    auto rth24 = hashOf(v24);\n+    auto rth25 = hashOf(v25);\n+    auto rth26 = hashOf(v26);\n+    auto rth27 = hashOf(v27);\n+    auto rth28 = hashOf(v28);\n+    auto rth29 = hashOf(v29);\n+\n+    auto rth31 = hashOf(v31);\n+    auto rth32 = hashOf(v32);\n+    auto rth33 = hashOf(v33);\n+\n+    assert(h1 == rth1);\n+    assert(h2 == rth2);\n+    assert(h3 == rth3);\n+    assert(h4 == rth4);\n+    assert(h5 == rth5);\n+    assert(h6 == rth6);\n+    assert(h7 == rth7);\n+    assert(h8 == rth8);\n+    assert(h9 == rth9);\n+    assert(h10 == rth10);\n+    assert(h11 == rth11);\n+    assert(h12 == rth12);\n+    assert(h13 == rth13);\n+    assert(h14 == rth14);\n+    assert(h15 == rth15);\n+    assert(h16 == rth16);\n+    assert(h17 == rth17);\n+    assert(h18 == rth18);\n+    assert(h19 == rth19);\n+    assert(h20 == rth20);\n+    assert(h21 == rth21);\n+    assert(h22 == rth22);\n+    assert(h23 == rth23);\n+    /*assert(h24 == rth24);\n+    assert(h25 == rth25);\n+    assert(h26 == rth26);\n+    assert(h27 == rth27);\n+    assert(h28 == rth28);\n+    assert(h29 == rth29);*/\n+    assert(h30 == rth30);\n+    assert(h31 == rth31);\n+    assert(h32 == rth32);\n+    assert(h33 == rth33);\n+\n+    // https://issues.dlang.org/show_bug.cgi?id=18932\n+    assert(hashOf(null, 0) != hashOf(null, 123456789));\n+\n+    static size_t tiHashOf(T)(T var)\n+    {\n+        return typeid(T).getHash(&var);\n+    }\n+\n+    auto tih1 = tiHashOf(v1);\n+    auto tih2 = tiHashOf(v2);\n+    auto tih3 = tiHashOf(v3);\n+    auto tih4 = tiHashOf(v4);\n+    auto tih5 = tiHashOf(v5);\n+    auto tih6 = tiHashOf(v6);\n+    auto tih7 = tiHashOf(v7);\n+    auto tih8 = tiHashOf(v8);\n+    auto tih9 = tiHashOf(v9);\n+    auto tih10 = tiHashOf(v10);\n+    auto tih11 = tiHashOf(v11);\n+    auto tih12 = tiHashOf(v12);\n+    auto tih13 = tiHashOf(v13);\n+    auto tih14 = tiHashOf(v14);\n+    auto tih15 = tiHashOf(v15);\n+    auto tih16 = tiHashOf(v16);\n+    auto tih17 = tiHashOf(v17);\n+    auto tih18 = tiHashOf(v18);\n+    auto tih19 = tiHashOf(v19);\n+    auto tih20 = tiHashOf(v20);\n+    auto tih21 = tiHashOf(v21);\n+    auto tih22 = tiHashOf(v22);\n+    auto tih23 = tiHashOf(v23);\n+    auto tih24 = tiHashOf(v24);\n+    auto tih25 = tiHashOf(v25);\n+    auto tih26 = tiHashOf(v26);\n+    auto tih27 = tiHashOf(v27);\n+    auto tih28 = tiHashOf(v28);\n+    auto tih29 = tiHashOf(v29);\n+    auto tih30 = tiHashOf(v30);\n+    auto tih31 = tiHashOf(v31);\n+    auto tih32 = tiHashOf(v32);\n+    auto tih33 = tiHashOf(v33);\n+\n+    assert(tih1 == rth1);\n+    assert(tih2 == rth2);\n+    assert(tih3 == rth3);\n+    assert(tih4 == rth4);\n+    assert(tih5 == rth5);\n+    assert(tih6 == rth6);\n+    assert(tih7 == rth7);\n+    assert(tih8 == rth8);\n+    assert(tih9 == rth9);\n+    //assert(tih10 == rth10); // need compiler-generated __xtoHash changes\n+    assert(tih11 == rth11);\n+    assert(tih12 == rth12);\n+    assert(tih13 == rth13);\n+    assert(tih14 == rth14);\n+    assert(tih15 == rth15);\n+    assert(tih16 == rth16);\n+    assert(tih17 == rth17);\n+    assert(tih18 == rth18);\n+    //assert(tih19 == rth19); // need compiler-generated __xtoHash changes\n+    assert(tih20 == rth20);\n+    assert(tih21 == rth21);\n+    assert(tih22 == rth22);\n+    //assert(tih23 == rth23); // need compiler-generated __xtoHash changes\n+    //assert(tih24 == rth24);\n+    //assert(tih25 == rth25);\n+    assert(tih26 == rth26);\n+    assert(tih27 == rth27);\n+    assert(tih28 == rth28);\n+    //assert(tih29 == rth29); // XGDC: Implementation wrongly hashes padding.\n+    assert(tih30 == rth30);\n+    assert(tih31 == rth31);\n+    assert(tih32 == rth32);\n+    assert(tih33 == rth33);\n+}"}]}