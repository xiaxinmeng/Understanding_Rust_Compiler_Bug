{"sha": "dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwYmZlNmEzNTc3MTRmNzYxYTZiNDMyNmRjN2EzY2IwM2M3OWQ4Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-04T14:39:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-04T14:39:13Z"}, "message": "Makefile.in (cgraph.o, [...]): Add intl.h dependency.\n\n\n\t* Makefile.in (cgraph.o, cgraphunit.o): Add intl.h dependency.\n\t* cgraph.c (create_edge, dump_cgraph): Update to use inline_failed\n\t* cgraph.h (cgraph_edge): Replace inline_call by inline_failed\n\t(cgraph_inline_p): Add extra argument reason.\n\t* cgraphunit.c: Minor formating fixes.\n\tcgraph_first_inlined_callee): New functions.\n\t(record_call_1): Record builtins too.\n\t(cgraph_analyze_function): Update inline_failed messages.\n\t(cgraph_mark_functions_to_output, cgraph_expand_function, cgraph_inlined_into,\n\tcgraph_inlined_callees, cgraph_estimate_growth): Update to use inline_failed.\n\t(cgraph_check_inline_limits): Likewise; Add argument reason.\n\t(cgraph_set_inline_failed): New static function.\n\t(cgraph_decide_inlining_of_small_function, cgraph_decide_inlining): Set\n\treasons.\n\t(cgraph_inline_p): Add new argument reason.\n\t* tree-inline.c (expand_call_inline):  Update warning.\n\nFrom-SVN: r75391", "tree": {"sha": "b64167702ac199d1ec0b2c92b512d1cd185a82b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b64167702ac199d1ec0b2c92b512d1cd185a82b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/comments", "author": null, "committer": null, "parents": [{"sha": "e42870dffe41cff30755a74cbe162be96f742442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42870dffe41cff30755a74cbe162be96f742442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e42870dffe41cff30755a74cbe162be96f742442"}], "stats": {"total": 345, "additions": 281, "deletions": 64}, "files": [{"sha": "a1b09c01db3f593e257e00b52afd5274928f944c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -1,3 +1,22 @@\n+2004-01-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (cgraph.o, cgraphunit.o): Add intl.h dependency.\n+\t* cgraph.c (create_edge, dump_cgraph): Update to use inline_failed\n+\t* cgraph.h (cgraph_edge): Replace inline_call by inline_failed\n+\t(cgraph_inline_p): Add extra argument reason.\n+\t* cgraphunit.c: Minor formating fixes.\n+\tcgraph_first_inlined_callee): New functions.\n+\t(record_call_1): Record builtins too.\n+\t(cgraph_analyze_function): Update inline_failed messages.\n+\t(cgraph_mark_functions_to_output, cgraph_expand_function, cgraph_inlined_into,\n+\tcgraph_inlined_callees, cgraph_estimate_growth): Update to use inline_failed.\n+\t(cgraph_check_inline_limits): Likewise; Add argument reason.\n+\t(cgraph_set_inline_failed): New static function.\n+\t(cgraph_decide_inlining_of_small_function, cgraph_decide_inlining): Set\n+\treasons.\n+\t(cgraph_inline_p): Add new argument reason.\n+\t* tree-inline.c (expand_call_inline):  Update warning.\n+\n 2004-01-03  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* configure.ac: Replace AC_INIT, AC_OUTPUT, AC_CANONICAL_SYSTEM"}, {"sha": "592acd81ef9402ba2fb67e1b22de85a8e92e795d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -1633,9 +1633,10 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RT\n    $(REGS_H) hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H) $(TREE_H) $(TARGET_H)\n cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   langhooks.h toplev.h flags.h $(GGC_H)  $(TARGET_H) cgraph.h gt-cgraph.h output.h\n+   langhooks.h toplev.h flags.h $(GGC_H)  $(TARGET_H) cgraph.h gt-cgraph.h \\\n+   output.h intl.h\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   langhooks.h tree-inline.h toplev.h flags.h $(GGC_H)  $(TARGET_H) cgraph.h\n+   langhooks.h tree-inline.h toplev.h flags.h $(GGC_H)  $(TARGET_H) cgraph.h intl.h\n coverage.o : coverage.c gcov-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \\\n    toplev.h $(GGC_H) $(TARGET_H) langhooks.h $(COVERAGE_H) libfuncs.h \\"}, {"sha": "73a420e6e7c64bc4bb65ddf52281809d32779483", "filename": "gcc/cgraph.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -34,6 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cgraph.h\"\n #include \"varray.h\"\n #include \"output.h\"\n+#include \"intl.h\"\n \n \n /* Hash table used to convert declarations into nodes.  */\n@@ -156,15 +157,21 @@ create_edge (struct cgraph_node *caller, struct cgraph_node *callee)\n   struct cgraph_edge *edge = ggc_alloc (sizeof (struct cgraph_edge));\n   struct cgraph_edge *edge2;\n \n-  edge->inline_call = false;\n+  if (!DECL_SAVED_TREE (callee->decl))\n+    edge->inline_failed = N_(\"function body not available\");\n+  else if (callee->local.inlinable)\n+    edge->inline_failed = N_(\"function not considered for inlining\");\n+  else\n+    edge->inline_failed = N_(\"function not inlinable\");\n+\n   /* At the moment we don't associate calls with specific CALL_EXPRs\n      as we probably ought to, so we must preserve inline_call flags to\n      be the same in all copies of the same edge.  */\n   if (cgraph_global_info_ready)\n     for (edge2 = caller->callees; edge2; edge2 = edge2->next_callee)\n       if (edge2->callee == callee)\n \t{\n-\t  edge->inline_call = edge2->inline_call;\n+\t  edge->inline_failed = edge2->inline_failed;\n \t  break;\n \t}\n \n@@ -381,15 +388,15 @@ dump_cgraph (FILE *f)\n       for (edge = node->callers; edge; edge = edge->next_caller)\n \t{\n \t  fprintf (f, \"%s \", cgraph_node_name (edge->caller));\n-\t  if (edge->inline_call)\n+\t  if (!edge->inline_failed)\n \t    fprintf(f, \"(inlined) \");\n \t}\n \n       fprintf (f, \"\\n  calls: \");\n       for (edge = node->callees; edge; edge = edge->next_callee)\n \t{\n \t  fprintf (f, \"%s \", cgraph_node_name (edge->callee));\n-\t  if (edge->inline_call)\n+\t  if (!edge->inline_failed)\n \t    fprintf(f, \"(inlined) \");\n \t}\n       fprintf (f, \"\\n\");"}, {"sha": "5cf31d7afae67af9930f5f031f447411d7cbcc3a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -119,7 +119,9 @@ struct cgraph_edge GTY(())\n   struct cgraph_node *callee;\n   struct cgraph_edge *next_caller;\n   struct cgraph_edge *next_callee;\n-  bool inline_call;\n+  /* When NULL, inline this call.  When non-NULL, points to the explanation\n+     why function was not inlined.  */\n+  const char *inline_failed;\n };\n \n /* The cgraph_varpool data structure.\n@@ -181,6 +183,6 @@ void cgraph_create_edges (tree, tree);\n void cgraph_optimize (void);\n void cgraph_mark_needed_node (struct cgraph_node *);\n void cgraph_mark_reachable_node (struct cgraph_node *);\n-bool cgraph_inline_p (tree, tree);\n+bool cgraph_inline_p (tree, tree, const char **reason);\n \n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "4b4aef046ed717a29850c20224499b8885dd07c8", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 119, "deletions": 52, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -38,6 +38,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"params.h\"\n #include \"fibheap.h\"\n #include \"c-common.h\"\n+#include \"intl.h\"\n \n #define INSNS_PER_CALL 10\n \n@@ -257,8 +258,6 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n \ttree decl = get_callee_fndecl (*tp);\n \tif (decl && TREE_CODE (decl) == FUNCTION_DECL)\n \t  {\n-\t    if (DECL_BUILT_IN (decl))\n-\t      return NULL;\n \t    cgraph_record_call (data, decl);\n \n \t    /* When we see a function call, we don't want to look at the\n@@ -311,6 +310,7 @@ static void\n cgraph_analyze_function (struct cgraph_node *node)\n {\n   tree decl = node->decl;\n+  struct cgraph_edge *e;\n \n   current_function_decl = decl;\n \n@@ -325,6 +325,10 @@ cgraph_analyze_function (struct cgraph_node *node)\n   if (node->local.inlinable)\n     node->local.disregard_inline_limits\n       = (*lang_hooks.tree_inlining.disregard_inline_limits) (decl);\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (e->inline_failed)\n+      e->inline_failed = (!node->local.inlinable ? N_(\"function not inlinable\")\n+\t\t\t  : N_(\"function not considered for inlining\"));\n   if (flag_really_no_inline && !node->local.disregard_inline_limits)\n     node->local.inlinable = 0;\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n@@ -442,11 +446,12 @@ cgraph_mark_functions_to_output (void)\n     {\n       tree decl = node->decl;\n       struct cgraph_edge *e;\n+\n       if (node->output)\n \tabort ();\n \n       for (e = node->callers; e; e = e->next_caller)\n-\tif (!e->inline_call)\n+\tif (e->inline_failed)\n \t  break;\n \n       /* We need to output all local functions that are used and not\n@@ -476,7 +481,7 @@ cgraph_optimize_function (struct cgraph_node *node)\n       struct cgraph_edge *e;\n \n       for (e = node->callees; e; e = e->next_callee)\n-\tif (e->inline_call || warn_inline)\n+\tif (!e->inline_failed || warn_inline)\n \t  break;\n       if (e)\n         optimize_inline_calls (decl);\n@@ -512,6 +517,7 @@ cgraph_expand_function (struct cgraph_node *node)\n \n /* Fill array order with all nodes with output flag set in the reverse\n    topological order.  */\n+\n static int\n cgraph_postorder (struct cgraph_node **order)\n {\n@@ -594,7 +600,7 @@ cgraph_inlined_into (struct cgraph_node *node, struct cgraph_node **array)\n   /* Fast path: since we traverse in mostly topological order, we will likely\n      find no edges.  */\n   for (e = node->callers; e; e = e->next_caller)\n-    if (e->inline_call)\n+    if (!e->inline_failed)\n       break;\n \n   if (!e)\n@@ -626,16 +632,17 @@ cgraph_inlined_into (struct cgraph_node *node, struct cgraph_node **array)\n       SET_INLINED_TIMES (caller, INLINED_TIMES (caller) + 1);\n \n       for (e1 = caller->callers; e1; e1 = e1->next_caller)\n-\tif (e1->inline_call)\n+\tif (!e1->inline_failed)\n \t  break;\n+\n       if (e1)\n \tstack[sp++] = e1;\n       else\n \t{\n \t  while (true)\n \t    {\n \t      for (e1 = e->next_caller; e1; e1 = e1->next_caller)\n-\t\tif (e1->inline_call)\n+\t\tif (!e1->inline_failed)\n \t\t  break;\n \n \t      if (e1)\n@@ -692,7 +699,7 @@ cgraph_inlined_callees (struct cgraph_node *node, struct cgraph_node **array)\n   /* Fast path: since we traverse in mostly topological order, we will likely\n      find no edges.  */\n   for (e = node->callees; e; e = e->next_callee)\n-    if (e->inline_call)\n+    if (!e->inline_failed)\n       break;\n \n   if (!e)\n@@ -724,7 +731,7 @@ cgraph_inlined_callees (struct cgraph_node *node, struct cgraph_node **array)\n       SET_INLINED_TIMES (callee, INLINED_TIMES (callee) + 1);\n \n       for (e1 = callee->callees; e1; e1 = e1->next_callee)\n-\tif (e1->inline_call)\n+\tif (!e1->inline_failed)\n \t  break;\n       if (e1)\n \tstack[sp++] = e1;\n@@ -733,7 +740,7 @@ cgraph_inlined_callees (struct cgraph_node *node, struct cgraph_node **array)\n \t  while (true)\n \t    {\n \t      for (e1 = e->next_callee; e1; e1 = e1->next_callee)\n-\t\tif (e1->inline_call)\n+\t\tif (!e1->inline_failed)\n \t\t  break;\n \n \t      if (e1)\n@@ -791,7 +798,7 @@ cgraph_estimate_growth (struct cgraph_node *node)\n   struct cgraph_edge *e;\n \n   for (e = node->callers; e; e = e->next_caller)\n-    if (!e->inline_call)\n+    if (e->inline_failed)\n       {\n \tgrowth += ((cgraph_estimate_size_after_inlining (1, e->caller, node)\n \t\t    -\n@@ -833,13 +840,13 @@ cgraph_mark_inline (struct cgraph_node *to, struct cgraph_node *what,\n     {\n       if (e->caller == to)\n \t{\n-\t  if (e->inline_call)\n-\t    abort ();\n-\t  e->inline_call = true;\n+\t  if (!e->inline_failed)\n+\t    continue;\n+\t  e->inline_failed = NULL;\n \t  times++;\n \t  clones += e->caller->global.cloned_times;\n \t}\n-      else if (!e->inline_call)\n+      else if (e->inline_failed)\n \tcalled = true;\n     }\n   if (!times)\n@@ -884,7 +891,8 @@ cgraph_mark_inline (struct cgraph_node *to, struct cgraph_node *what,\n \n static bool\n cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n-\t\t\t    struct cgraph_node **inlined, int ninlined)\n+\t\t\t    struct cgraph_node **inlined, int ninlined,\n+\t\t\t    const char **reason)\n {\n   int i;\n   int times = 0;\n@@ -908,7 +916,10 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n   newsize = cgraph_estimate_size_after_inlining (times, to, what);\n   if (newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n       && newsize > limit)\n-    return false;\n+    {\n+      *reason = N_(\"--param large-function-growth limit reached\");\n+      return false;\n+    }\n   for (i = 0; i < ninlined; i++)\n     {\n       newsize =\n@@ -918,7 +929,10 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n \t  && newsize >\n \t  inlined[i]->local.self_insns *\n \t  (100 + PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH)) / 100)\n-\treturn false;\n+\t{\n+\t  *reason = N_(\"--param large-function-growth limit reached while inlining the caller\");\n+\t  return false;\n+\t}\n     }\n   return true;\n }\n@@ -936,6 +950,20 @@ cgraph_default_inline_p (struct cgraph_node *n)\n     return n->global.insns < MAX_INLINE_INSNS_AUTO;\n }\n \n+/* Set inline_failed for all callers of given function to REASON.  */\n+\n+static void\n+cgraph_set_inline_failed (struct cgraph_node *node, const char *reason)\n+{\n+  struct cgraph_edge *e;\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Inlining failed: %s\\n\", reason);\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (e->inline_failed)\n+      e->inline_failed = reason;\n+}\n+\n /* We use greedy algorithm for inlining of small functions:\n    All inline candidates are put into prioritized heap based on estimated\n    growth of the overall number of instructions and then update the estimates.\n@@ -960,25 +988,23 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      struct cgraph_edge *e;\n-\n       if (!node->local.inlinable || !node->callers\n-\t  || !cgraph_default_inline_p (node))\n+\t  || node->local.disregard_inline_limits)\n \tcontinue;\n \n-      /* Rule out always_inline functions we dealt with earlier.  */\n-      for (e = node->callers; e; e = e->next_caller)\n-\tif (e->inline_call)\n-\t  break;\n-      if (e)\n-\tcontinue;\n+      if (!cgraph_default_inline_p (node))\n+\t{\n+\t  cgraph_set_inline_failed (node,\n+\t    N_(\"--param max-inline-insns-single limit reached\"));\n+\t  continue;\n+\t}\n       heap_node[node->uid] =\n \tfibheap_insert (heap, cgraph_estimate_growth (node), node);\n     }\n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\nDeciding on smaller functions:\\n\");\n-  while ((node = fibheap_extract_min (heap)) && overall_insns <= max_insns)\n+  while (overall_insns <= max_insns && (node = fibheap_extract_min (heap)))\n     {\n       struct cgraph_edge *e;\n       int old_insns = overall_insns;\n@@ -992,18 +1018,27 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t\t cgraph_estimate_growth (node));\n       if (!cgraph_default_inline_p (node))\n \t{\n-\t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \" Function too large.\\n\");\n+\t  cgraph_set_inline_failed (node,\n+\t    N_(\"--param max-inline-insns-single limit reached after inlining into the callee\"));\n \t  continue;\n \t}\n       ninlined_callees = cgraph_inlined_callees (node, inlined_callees);\n       for (e = node->callers; e; e = e->next_caller)\n-\tif (!e->inline_call && e->caller != node)\n+\tif (e->inline_failed)\n \t  {\n+\t    /* Marking recursive function inlinine has sane semantic and\n+\t       thus we should not warn on it.  */\n+ \t    if (e->caller == node)\n+ \t      {\n+ \t        e->inline_failed = \"\";\n+ \t\tcontinue;\n+ \t      }\n \t    ninlined = cgraph_inlined_into (e->caller, inlined);\n+\t    if (e->callee->output)\n+\t      e->inline_failed = \"\";\n \t    if (e->callee->output\n \t\t|| !cgraph_check_inline_limits (e->caller, node, inlined,\n-\t\t\t\t\t\tninlined))\n+\t\t\t\t\t\tninlined, &e->inline_failed))\n \t      {\n \t\tfor (i = 0; i < ninlined; i++)\n \t\t  inlined[i]->output = 0, node->aux = 0;\n@@ -1039,7 +1074,7 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n          are now called more times; update keys.  */\n \n       for (e = node->callees; e; e = e->next_callee)\n-\tif (!e->inline_call && heap_node[e->callee->uid])\n+\tif (e->inline_failed && heap_node[e->callee->uid])\n \t  fibheap_replace_key (heap, heap_node[e->callee->uid],\n \t\t\t       cgraph_estimate_growth (e->callee));\n \n@@ -1048,7 +1083,7 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t  struct cgraph_edge *e;\n \n \t  for (e = inlined_callees[i]->callees; e; e = e->next_callee)\n-\t    if (!e->inline_call && heap_node[e->callee->uid])\n+\t    if (e->inline_failed && heap_node[e->callee->uid])\n \t      fibheap_replace_key (heap, heap_node[e->callee->uid],\n \t\t\t\t   cgraph_estimate_growth (e->callee));\n \n@@ -1059,8 +1094,9 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t\t \" Inlined %i times for a net change of %+i insns.\\n\",\n \t\t node->global.cloned_times, overall_insns - old_insns);\n     }\n-  if (cgraph_dump_file && !fibheap_empty (heap))\n-    fprintf (cgraph_dump_file, \"\\nReached the inline-unit-growth limit.\\n\");\n+  while ((node = fibheap_extract_min (heap)) != NULL)\n+    if (!node->local.disregard_inline_limits)\n+      cgraph_set_inline_failed (node, N_(\"--param inline-unit-growth limit reached\"));\n   fibheap_delete (heap);\n   free (heap_node);\n }\n@@ -1122,10 +1158,14 @@ cgraph_decide_inlining (void)\n       for (; e; e = e->next_callee)\n \t{\n \t  old_insns = overall_insns;\n-\t  if (e->inline_call || !e->callee->local.disregard_inline_limits)\n-\t    continue;\n-\t  if (e->callee->output || e->callee == node)\n-\t    continue;\n+\t  if (!e->inline_failed || !e->callee->local.inlinable\n+\t      || !e->callee->local.disregard_inline_limits)\n+  \t    continue;\n+  \t  if (e->callee->output || e->callee == node)\n+\t    {\n+\t      e->inline_failed = N_(\"recursive inlining\");\n+\t      continue;\n+\t    }\n \t  ninlined_callees =\n \t    cgraph_inlined_callees (e->callee, inlined_callees);\n \t  cgraph_mark_inline (node, e->callee, inlined, ninlined,\n@@ -1160,20 +1200,21 @@ cgraph_decide_inlining (void)\n \t  node = order[i];\n \n \t  if (node->callers && !node->callers->next_caller && !node->needed\n-\t      && node->local.inlinable && !node->callers->inline_call\n+\t      && node->local.inlinable && node->callers->inline_failed\n \t      && !DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n \t    {\n \t      bool ok = true;\n \t      struct cgraph_node *node1;\n \n \t      /* Verify that we won't duplicate the caller.  */\n \t      for (node1 = node->callers->caller;\n-\t\t   node1->callers && node1->callers->inline_call\n+\t\t   node1->callers && node1->callers->inline_failed\n \t\t   && ok; node1 = node1->callers->caller)\n \t\tif (node1->callers->next_caller || node1->needed)\n \t\t  ok = false;\n \t      if (ok)\n \t\t{\n+\t\t  const char *dummy_reason;\n \t\t  if (cgraph_dump_file)\n \t\t    fprintf (cgraph_dump_file,\n \t\t\t     \"\\nConsidering %s %i insns.\\n\"\n@@ -1184,8 +1225,11 @@ cgraph_decide_inlining (void)\n \t\t  ninlined = cgraph_inlined_into (node->callers->caller,\n \t\t      \t\t\t\t  inlined);\n \t\t  old_insns = overall_insns;\n+\n+\t\t  /* Inlining functions once would never cause inlining warnings.  */\n \t\t  if (cgraph_check_inline_limits\n-\t\t      (node->callers->caller, node, inlined, ninlined))\n+\t\t      (node->callers->caller, node, inlined, ninlined,\n+\t\t       &dummy_reason))\n \t\t    {\n \t\t      ninlined_callees =\n \t\t\tcgraph_inlined_callees (node, inlined_callees);\n@@ -1245,9 +1289,16 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n \n   /* First of all look for always inline functions.  */\n   for (e = node->callees; e; e = e->next_callee)\n-    if (e->callee->local.disregard_inline_limits && !e->callee->output\n-\t&& e->callee != node && !e->inline_call)\n+    if (e->callee->local.disregard_inline_limits && e->inline_failed\n+\t/* ??? It is possible that renaming variable removed the function body\n+\t   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n+\t&& DECL_SAVED_TREE (e->callee->decl))\n       {\n+\tif (e->callee->output || e->callee == node)\n+\t  {\n+ \t    e->inline_failed = N_(\"recursive inlining\");\n+\t    continue;\n+\t  }\n \tninlined_callees = cgraph_inlined_callees (e->callee, inlined_callees);\n \tcgraph_mark_inline (node, e->callee, inlined, ninlined,\n \t\t\t    inlined_callees, ninlined_callees);\n@@ -1259,12 +1310,19 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n     {\n       /* Now do the automatic inlining.  */\n       for (e = node->callees; e; e = e->next_callee)\n-\tif (e->callee->local.inlinable && !e->callee->output\n-\t    && e->callee != node && !e->inline_call\n+\tif (e->callee->local.inlinable && e->inline_failed\n \t    && cgraph_default_inline_p (e->callee)\n \t    && cgraph_check_inline_limits (node, e->callee, inlined,\n-\t\t\t\t\t   ninlined))\n+\t\t\t\t\t   ninlined, &e->inline_failed)\n+\t    && DECL_SAVED_TREE (e->callee->decl))\n \t  {\n+\t    /* Marking recursive function inlinine has sane semantic and thus\n+\t       we should not warn on it.  */\n+\t    if (e->callee->output || e->callee == node)\n+\t      {\n+\t\te->inline_failed = \"\";\n+\t\tcontinue;\n+\t      }\n \t    ninlined_callees = cgraph_inlined_callees (e->callee,\n \t\t\t\t\t\t       inlined_callees);\n \t    cgraph_mark_inline (node, e->callee, inlined, ninlined,\n@@ -1283,21 +1341,29 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n }\n \n \n-/* Return true when CALLER_DECL should be inlined into CALLEE_DECL.  */\n+/* Return true when CALLER_DECL should be inlined into CALLEE_DECL.\n+   When returned false and reason is non-NULL, set it to the reason\n+   why the call was not inlined.  */\n \n bool\n-cgraph_inline_p (tree caller_decl, tree callee_decl)\n+cgraph_inline_p (tree caller_decl, tree callee_decl, const char **reason)\n {\n   struct cgraph_node *caller = cgraph_node (caller_decl);\n   struct cgraph_node *callee = cgraph_node (callee_decl);\n   struct cgraph_edge *e;\n \n   for (e = caller->callees; e; e = e->next_callee)\n     if (e->callee == callee)\n-      return e->inline_call;\n+      {\n+\tif (e->inline_failed && reason)\n+\t  *reason = e->inline_failed;\n+        return !e->inline_failed;\n+      }\n   /* We do not record builtins in the callgraph.  Perhaps it would make more\n      sense to do so and then prune out those not overwritten by explicit\n      function body.  */\n+  if (reason)\n+    *reason = \"originally indirect function calls never inlined\";\n   return false;\n }\n /* Expand all functions that must be output.\n@@ -1340,7 +1406,8 @@ cgraph_expand_all_functions (void)\n /* Mark all local functions.\n \n    A local function is one whose calls can occur only in the\n-   current compilation unit, so we change its calling convention.\n+   current compilation unit and all it's calls are explicit,\n+   so we can change its calling convention.\n    We simply mark all static functions whose address is not taken\n    as local.  */\n "}, {"sha": "0b82e5877c89c0ef4d3b4b90fa9f7291c7835367", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -1,3 +1,7 @@\n+2004-01-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/winline[1-7].c: New tests.\n+\n 2004-01-02  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/13520"}, {"sha": "ac2ae82427a9e61d554c6192bf2fde3414a23a55", "filename": "gcc/testsuite/gcc.dg/winline-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-1.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Winline -O2\" } */\n+\n+void q(void);\n+inline int t(void)\n+{\n+\tint ret;\n+\tq();\n+\tret = t();  /* We define sane semantics for inline keyword on recursive\n+\t\t       functions, so do not warn here.  */\n+\tq();\n+\treturn ret;\n+}"}, {"sha": "584c68fddf6b136c27b826cf034f5f923bca1f47", "filename": "gcc/testsuite/gcc.dg/winline-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-2.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Winline -O2\" } */\n+\n+inline int q(void);\t\t /* { dg-warning \"body not available\" \"\" } */\n+inline int t(void)\n+{\n+\treturn q();\t\t /* { dg-warning \"called from here\" \"\" } */\n+}"}, {"sha": "ce9e08012ca09dec7a3321e9a96ff5214e4b2075", "filename": "gcc/testsuite/gcc.dg/winline-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-3.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Winline -O2 --param max-inline-insns-single=1\" } */\n+\n+void big (void);\n+inline int q(void)\t\t\n+{\t\t\t\t/* { dg-warning \"max-inline-insns-single\" \"\" } */\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+}\n+inline int t (void)\n+{\n+\treturn q ();\t\t /* { dg-warning \"called from here\" \"\" } */\n+}"}, {"sha": "5ce0a02202dbcedda3b96e16880c564f9b35e442", "filename": "gcc/testsuite/gcc.dg/winline-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-4.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Winline -O1 -fno-unit-at-a-time\" } */\n+\n+inline int q(void);\t\t /* { dg-warning \"body not available\" } */\n+inline int t(void)\n+{\n+\treturn q();\t\t /* { dg-warning \"called from here\" } */\n+}\n+int q(void)\n+{\n+}"}, {"sha": "20df786a7571e60d94231fe90d51d2b4313846e1", "filename": "gcc/testsuite/gcc.dg/winline-5.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-5.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Winline -O2 --param inline-unit-growth=0\" } */\n+\n+void big (void);\n+inline int q(void)\t\t \n+{\t\t\t\t/* { dg-warning \"inline-unit-growth\" } */\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+}\n+inline int q1(void)\n+{\n+\tbig();\n+\tbig();\n+\tbig();\n+}\n+int t (void)\n+{\n+ /* We allow one inlining over limit.  */\n+\tq1();\n+\treturn q ();\t\t /* { dg-warning \"called from here\" } */\n+}"}, {"sha": "7ce7481a3ef29e009204644b1964ec4e9dd22d49", "filename": "gcc/testsuite/gcc.dg/winline-6.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-6.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Winline -O2 --param large-function-growth=0 --param large-function-insns=1\" } */\n+\n+void big (void);\n+inline int q(void)\n+{\t\t\t\t/* { dg-warning \"large-function-growth\" } */\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+\tbig();\n+}\n+inline int t (void)\n+{\n+\treturn q ();\t\t /* { dg-warning \"called from here\" } */\n+}"}, {"sha": "03b951763dc6d8e6dbb302b91cd3e49503b1548f", "filename": "gcc/testsuite/gcc.dg/winline-7.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-7.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Winline -O2\" } */\n+\n+void big (void);\n+inline int q(void)\n+{\t\t\t\t/* { dg-warning \"(function not inlinable|alloca)\" } */\n+\treturn (int)alloca(10);\n+}\n+inline int t (void)\n+{\n+\treturn q ();\t\t /* { dg-warning \"called from here\" } */\n+}"}, {"sha": "9d73be287ba68f6f51bd35b87c606afcbe78c49a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=dc0bfe6a357714f761a6b4326dc7a3cb03c79d8c", "patch": "@@ -1247,6 +1247,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   splay_tree st;\n   tree args;\n   tree return_slot_addr;\n+  const char *reason;\n \n   /* See what we've got.  */\n   id = (inline_data *) data;\n@@ -1327,12 +1328,13 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n \n   /* Don't try to inline functions that are not well-suited to\n      inlining.  */\n-  if (!DECL_SAVED_TREE (fn) || !cgraph_inline_p (id->current_decl, fn))\n+  if (!cgraph_inline_p (id->current_decl, fn, &reason))\n     {\n-      if (warn_inline && DECL_INLINE (fn) && DECL_DECLARED_INLINE_P (fn)\n-\t  && !DECL_IN_SYSTEM_HEADER (fn))\n+      if (warn_inline && DECL_DECLARED_INLINE_P (fn)\n+\t  && !DECL_IN_SYSTEM_HEADER (fn)\n+\t  && strlen (reason))\n \t{\n-\t  warning (\"%Jinlining failed in call to '%F'\", fn, fn);\n+\t  warning (\"%Jinlining failed in call to '%F': %s\", fn, fn, reason);\n \t  warning (\"called from here\");\n \t}\n       return NULL_TREE;"}]}