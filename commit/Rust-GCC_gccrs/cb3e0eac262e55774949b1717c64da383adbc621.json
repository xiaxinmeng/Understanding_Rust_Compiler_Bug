{"sha": "cb3e0eac262e55774949b1717c64da383adbc621", "node_id": "C_kwDOANBUbNoAKGNiM2UwZWFjMjYyZTU1Nzc0OTQ5YjE3MTdjNjRkYTM4M2FkYmM2MjE", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-16T15:30:20Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-16T15:30:20Z"}, "message": "don't declare header-defined functions both static and inline\n\nMany functions defined in our headers are declared 'static inline' which\nis a C idiom whose use predates our move to C++ as the implementation\nlanguage.  But in C++ the inline keyword is more than just a compiler\nhint, and is sufficient to give the function the intended semantics.\nIn fact declaring a function both static and inline is a pessimization\nsince static effectively disables the desired definition merging\nbehavior enabled by inline, and is also a source of (harmless) ODR\nviolations when a static inline function gets called from a non-static\ninline one (such as tree_operand_check calling tree_operand_length).\n\nThis patch mechanically fixes the vast majority of occurrences of this\nanti-pattern throughout the compiler's headers via the command line\n\n  sed -i 's/^static inline/inline/g' gcc/*.h gcc/*/*.h\n\nThere's also a manual change to remove the redundant declarations\nof is_ivar and lookup_category in gcc/objc/objc-act.cc which would\notherwise conflict with their modified definitions in objc-act.h\n(due to the difference in staticness).\n\nBesides fixing some ODR violations, this speeds up stage1 cc1plus by\nabout 2% and reduces the size of its text segment by 1.5MB.\n\ngcc/ChangeLog:\n\n\t* addresses.h: Mechanically drop 'static' from 'static inline'\n\tfunctions via s/^static inline/inline/g.\n\t* asan.h: Likewise.\n\t* attribs.h: Likewise.\n\t* basic-block.h: Likewise.\n\t* bitmap.h: Likewise.\n\t* cfghooks.h: Likewise.\n\t* cfgloop.h: Likewise.\n\t* cgraph.h: Likewise.\n\t* cselib.h: Likewise.\n\t* data-streamer.h: Likewise.\n\t* debug.h: Likewise.\n\t* df.h: Likewise.\n\t* diagnostic.h: Likewise.\n\t* dominance.h: Likewise.\n\t* dumpfile.h: Likewise.\n\t* emit-rtl.h: Likewise.\n\t* except.h: Likewise.\n\t* expmed.h: Likewise.\n\t* expr.h: Likewise.\n\t* fixed-value.h: Likewise.\n\t* gengtype.h: Likewise.\n\t* gimple-expr.h: Likewise.\n\t* gimple-iterator.h: Likewise.\n\t* gimple-predict.h: Likewise.\n\t* gimple-range-fold.h: Likewise.\n\t* gimple-ssa.h: Likewise.\n\t* gimple.h: Likewise.\n\t* graphite.h: Likewise.\n\t* hard-reg-set.h: Likewise.\n\t* hash-map.h: Likewise.\n\t* hash-set.h: Likewise.\n\t* hash-table.h: Likewise.\n\t* hwint.h: Likewise.\n\t* input.h: Likewise.\n\t* insn-addr.h: Likewise.\n\t* internal-fn.h: Likewise.\n\t* ipa-fnsummary.h: Likewise.\n\t* ipa-icf-gimple.h: Likewise.\n\t* ipa-inline.h: Likewise.\n\t* ipa-modref.h: Likewise.\n\t* ipa-prop.h: Likewise.\n\t* ira-int.h: Likewise.\n\t* ira.h: Likewise.\n\t* lra-int.h: Likewise.\n\t* lra.h: Likewise.\n\t* lto-streamer.h: Likewise.\n\t* memmodel.h: Likewise.\n\t* omp-general.h: Likewise.\n\t* optabs-query.h: Likewise.\n\t* optabs.h: Likewise.\n\t* plugin.h: Likewise.\n\t* pretty-print.h: Likewise.\n\t* range.h: Likewise.\n\t* read-md.h: Likewise.\n\t* recog.h: Likewise.\n\t* regs.h: Likewise.\n\t* rtl-iter.h: Likewise.\n\t* rtl.h: Likewise.\n\t* sbitmap.h: Likewise.\n\t* sched-int.h: Likewise.\n\t* sel-sched-ir.h: Likewise.\n\t* sese.h: Likewise.\n\t* sparseset.h: Likewise.\n\t* ssa-iterators.h: Likewise.\n\t* system.h: Likewise.\n\t* target-globals.h: Likewise.\n\t* target.h: Likewise.\n\t* timevar.h: Likewise.\n\t* tree-chrec.h: Likewise.\n\t* tree-data-ref.h: Likewise.\n\t* tree-iterator.h: Likewise.\n\t* tree-outof-ssa.h: Likewise.\n\t* tree-phinodes.h: Likewise.\n\t* tree-scalar-evolution.h: Likewise.\n\t* tree-sra.h: Likewise.\n\t* tree-ssa-alias.h: Likewise.\n\t* tree-ssa-live.h: Likewise.\n\t* tree-ssa-loop-manip.h: Likewise.\n\t* tree-ssa-loop.h: Likewise.\n\t* tree-ssa-operands.h: Likewise.\n\t* tree-ssa-propagate.h: Likewise.\n\t* tree-ssa-sccvn.h: Likewise.\n\t* tree-ssa.h: Likewise.\n\t* tree-ssanames.h: Likewise.\n\t* tree-streamer.h: Likewise.\n\t* tree-switch-conversion.h: Likewise.\n\t* tree-vectorizer.h: Likewise.\n\t* tree.h: Likewise.\n\t* wide-int.h: Likewise.\n\ngcc/c-family/ChangeLog:\n\n\t* c-common.h: Mechanically drop static from static inline\n\tfunctions via s/^static inline/inline/g.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.h: Mechanically drop static from static inline\n\tfunctions via s/^static inline/inline/g.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h: Mechanically drop static from static inline\n\tfunctions via s/^static inline/inline/g.\n\ngcc/fortran/ChangeLog:\n\n\t* gfortran.h: Mechanically drop static from static inline\n\tfunctions via s/^static inline/inline/g.\n\ngcc/jit/ChangeLog:\n\n\t* jit-dejagnu.h: Mechanically drop static from static inline\n\tfunctions via s/^static inline/inline/g.\n\t* jit-recording.h: Likewise.\n\ngcc/objc/ChangeLog:\n\n\t* objc-act.h: Mechanically drop static from static inline\n\tfunctions via s/^static inline/inline/g.\n\t* objc-map.h: Likewise.\n\t* objc-act.cc: Remove the redundant redeclarations of is_ivar\n\tand lookup_category.", "tree": {"sha": "a86ae96b5585e5f6d6c86bf152bc621ae76d632d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a86ae96b5585e5f6d6c86bf152bc621ae76d632d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb3e0eac262e55774949b1717c64da383adbc621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3e0eac262e55774949b1717c64da383adbc621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb3e0eac262e55774949b1717c64da383adbc621", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3e0eac262e55774949b1717c64da383adbc621/comments", "author": null, "committer": null, "parents": [{"sha": "a5de17d9120dde7e6598a05ea4d1556c2783c69b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5de17d9120dde7e6598a05ea4d1556c2783c69b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5de17d9120dde7e6598a05ea4d1556c2783c69b"}], "stats": {"total": 2558, "additions": 1278, "deletions": 1280}, "files": [{"sha": "3519c241c6d7b1e83f3615ab6ab5b01741ffef59", "filename": "gcc/addresses.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Faddresses.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Faddresses.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faddresses.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ADDRESSES_H\n #define GCC_ADDRESSES_H\n \n-static inline enum reg_class\n+inline enum reg_class\n base_reg_class (machine_mode mode ATTRIBUTE_UNUSED,\n \t\taddr_space_t as ATTRIBUTE_UNUSED,\n \t\tenum rtx_code outer_code ATTRIBUTE_UNUSED,\n@@ -51,7 +51,7 @@ base_reg_class (machine_mode mode ATTRIBUTE_UNUSED,\n    REGNO_OK_FOR_BASE_P.\n    Arguments as for the REGNO_MODE_CODE_OK_FOR_BASE_P macro.  */\n \n-static inline bool\n+inline bool\n ok_for_base_p_1 (unsigned regno ATTRIBUTE_UNUSED,\n \t\t machine_mode mode ATTRIBUTE_UNUSED,\n \t\t addr_space_t as ATTRIBUTE_UNUSED,\n@@ -77,7 +77,7 @@ ok_for_base_p_1 (unsigned regno ATTRIBUTE_UNUSED,\n /* Wrapper around ok_for_base_p_1, for use after register allocation is\n    complete.  Arguments as for the called function.  */\n \n-static inline bool\n+inline bool\n regno_ok_for_base_p (unsigned regno, machine_mode mode, addr_space_t as,\n \t\t     enum rtx_code outer_code, enum rtx_code index_code)\n {"}, {"sha": "7d26b413ac51b6769a356b909902a5d02dfa010b", "filename": "gcc/asan.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -140,7 +140,7 @@ extern bool asan_mark_p (gimple *stmt, enum asan_mark_flags flag);\n /* Return the size of padding needed to insert after a protected\n    decl of SIZE.  */\n \n-static inline unsigned int\n+inline unsigned int\n asan_red_zone_size (unsigned int size)\n {\n   unsigned int c = size & (ASAN_RED_ZONE_SIZE - 1);\n@@ -150,7 +150,7 @@ asan_red_zone_size (unsigned int size)\n /* Return how much a stack variable occupis on a stack\n    including a space for red zone.  */\n \n-static inline unsigned HOST_WIDE_INT\n+inline unsigned HOST_WIDE_INT\n asan_var_and_redzone_size (unsigned HOST_WIDE_INT size)\n {\n   if (size <= 4)\n@@ -182,7 +182,7 @@ extern hash_set<tree> *asan_handled_variables;\n /* Return TRUE if builtin with given FCODE will be intercepted by\n    libasan.  */\n \n-static inline bool\n+inline bool\n asan_intercepted_p (enum built_in_function fcode)\n {\n   if (hwasan_sanitize_p ())\n@@ -213,7 +213,7 @@ asan_intercepted_p (enum built_in_function fcode)\n \n /* Return TRUE if we should instrument for use-after-scope sanity checking.  */\n \n-static inline bool\n+inline bool\n asan_sanitize_use_after_scope (void)\n {\n   return (flag_sanitize_address_use_after_scope\n@@ -222,7 +222,7 @@ asan_sanitize_use_after_scope (void)\n \n /* Return true if DECL should be guarded on the stack.  */\n \n-static inline bool\n+inline bool\n asan_protect_stack_decl (tree decl)\n {\n   return DECL_P (decl)\n@@ -233,7 +233,7 @@ asan_protect_stack_decl (tree decl)\n /* Return true when flag_sanitize & FLAG is non-zero.  If FN is non-null,\n    remove all flags mentioned in \"no_sanitize\" of DECL_ATTRIBUTES.  */\n \n-static inline bool\n+inline bool\n sanitize_flags_p (unsigned int flag, const_tree fn = current_function_decl)\n {\n   unsigned int result_flags = flag_sanitize & flag;\n@@ -252,7 +252,7 @@ sanitize_flags_p (unsigned int flag, const_tree fn = current_function_decl)\n \n /* Return true when coverage sanitization should happend for FN function.  */\n \n-static inline bool\n+inline bool\n sanitize_coverage_p (const_tree fn = current_function_decl)\n {\n   return (flag_sanitize_coverage"}, {"sha": "84a43658a70dab576c212491df234aa1049016fc", "filename": "gcc/attribs.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -148,7 +148,7 @@ canonicalize_attr_name (const char *&s, T &l)\n /* For a given IDENTIFIER_NODE, strip leading and trailing '_' characters\n    so that we have a canonical form of attribute names.  */\n \n-static inline tree\n+inline tree\n canonicalize_attr_name (tree attr_name)\n {\n   size_t l = IDENTIFIER_LENGTH (attr_name);\n@@ -163,7 +163,7 @@ canonicalize_attr_name (tree attr_name)\n /* Compare attribute identifiers ATTR1 and ATTR2 with length ATTR1_LEN and\n    ATTR2_LEN.  */\n \n-static inline bool\n+inline bool\n cmp_attribs (const char *attr1, size_t attr1_len,\n \t     const char *attr2, size_t attr2_len)\n {\n@@ -172,7 +172,7 @@ cmp_attribs (const char *attr1, size_t attr1_len,\n \n /* Compare attribute identifiers ATTR1 and ATTR2.  */\n \n-static inline bool\n+inline bool\n cmp_attribs (const char *attr1, const char *attr2)\n {\n   return cmp_attribs (attr1, strlen (attr1), attr2, strlen (attr2));\n@@ -181,7 +181,7 @@ cmp_attribs (const char *attr1, const char *attr2)\n /* Given an identifier node IDENT and a string ATTR_NAME, return true\n    if the identifier node is a valid attribute name for the string.  */\n \n-static inline bool\n+inline bool\n is_attribute_p (const char *attr_name, const_tree ident)\n {\n   return cmp_attribs (attr_name, strlen (attr_name),\n@@ -193,7 +193,7 @@ is_attribute_p (const char *attr_name, const_tree ident)\n    for standard attribute (NULL get_attribute_namespace) or \"gnu\"\n    namespace.  */\n \n-static inline bool\n+inline bool\n is_attribute_namespace_p (const char *attr_ns, const_tree attr)\n {\n   tree ident = get_attribute_namespace (attr);\n@@ -212,7 +212,7 @@ is_attribute_namespace_p (const char *attr_ns, const_tree attr)\n    occurrences are wanted.  ATTR_NAME must be in the form 'text' (not\n    '__text__').  */\n \n-static inline tree\n+inline tree\n lookup_attribute (const char *attr_name, tree list)\n {\n   if (CHECKING_P && attr_name[0] != '_')\n@@ -236,7 +236,7 @@ lookup_attribute (const char *attr_name, tree list)\n /* Similar to lookup_attribute, but also match the attribute namespace.\n    ATTR_NS \"\" stands for either standard attribute or \"gnu\" namespace.  */\n \n-static inline tree\n+inline tree\n lookup_attribute (const char *attr_ns, const char *attr_name, tree list)\n {\n   if (CHECKING_P && attr_name[0] != '_')\n@@ -269,7 +269,7 @@ lookup_attribute (const char *attr_ns, const char *attr_name, tree list)\n    starts with ATTR_NAME.  ATTR_NAME must be in the form 'text' (not\n    '__text__').  */\n \n-static inline tree\n+inline tree\n lookup_attribute_by_prefix (const char *attr_name, tree list)\n {\n   gcc_checking_assert (attr_name[0] != '_');"}, {"sha": "29191e56720b55b26e061bca1452118446f47e1a", "filename": "gcc/basic-block.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -309,15 +309,15 @@ enum cfg_bb_flags\n \n /* Returns true if BB has precisely one successor.  */\n \n-static inline bool\n+inline bool\n single_succ_p (const_basic_block bb)\n {\n   return EDGE_COUNT (bb->succs) == 1;\n }\n \n /* Returns true if BB has precisely one predecessor.  */\n \n-static inline bool\n+inline bool\n single_pred_p (const_basic_block bb)\n {\n   return EDGE_COUNT (bb->preds) == 1;\n@@ -326,7 +326,7 @@ single_pred_p (const_basic_block bb)\n /* Returns the single successor edge of basic block BB.  Aborts if\n    BB does not have exactly one successor.  */\n \n-static inline edge\n+inline edge\n single_succ_edge (const_basic_block bb)\n {\n   gcc_checking_assert (single_succ_p (bb));\n@@ -336,7 +336,7 @@ single_succ_edge (const_basic_block bb)\n /* Returns the single predecessor edge of basic block BB.  Aborts\n    if BB does not have exactly one predecessor.  */\n \n-static inline edge\n+inline edge\n single_pred_edge (const_basic_block bb)\n {\n   gcc_checking_assert (single_pred_p (bb));\n@@ -346,7 +346,7 @@ single_pred_edge (const_basic_block bb)\n /* Returns the single successor block of basic block BB.  Aborts\n    if BB does not have exactly one successor.  */\n \n-static inline basic_block\n+inline basic_block\n single_succ (const_basic_block bb)\n {\n   return single_succ_edge (bb)->dest;\n@@ -355,7 +355,7 @@ single_succ (const_basic_block bb)\n /* Returns the single predecessor block of basic block BB.  Aborts\n    if BB does not have exactly one predecessor.*/\n \n-static inline basic_block\n+inline basic_block\n single_pred (const_basic_block bb)\n {\n   return single_pred_edge (bb)->src;\n@@ -368,7 +368,7 @@ struct edge_iterator {\n   vec<edge, va_gc> **container;\n };\n \n-static inline vec<edge, va_gc> *\n+inline vec<edge, va_gc> *\n ei_container (edge_iterator i)\n {\n   gcc_checking_assert (i.container);\n@@ -379,7 +379,7 @@ ei_container (edge_iterator i)\n #define ei_last(iter) ei_last_1 (&(iter))\n \n /* Return an iterator pointing to the start of an edge vector.  */\n-static inline edge_iterator\n+inline edge_iterator\n ei_start_1 (vec<edge, va_gc> **ev)\n {\n   edge_iterator i;\n@@ -392,7 +392,7 @@ ei_start_1 (vec<edge, va_gc> **ev)\n \n /* Return an iterator pointing to the last element of an edge\n    vector.  */\n-static inline edge_iterator\n+inline edge_iterator\n ei_last_1 (vec<edge, va_gc> **ev)\n {\n   edge_iterator i;\n@@ -404,38 +404,38 @@ ei_last_1 (vec<edge, va_gc> **ev)\n }\n \n /* Is the iterator `i' at the end of the sequence?  */\n-static inline bool\n+inline bool\n ei_end_p (edge_iterator i)\n {\n   return (i.index == EDGE_COUNT (ei_container (i)));\n }\n \n /* Is the iterator `i' at one position before the end of the\n    sequence?  */\n-static inline bool\n+inline bool\n ei_one_before_end_p (edge_iterator i)\n {\n   return (i.index + 1 == EDGE_COUNT (ei_container (i)));\n }\n \n /* Advance the iterator to the next element.  */\n-static inline void\n+inline void\n ei_next (edge_iterator *i)\n {\n   gcc_checking_assert (i->index < EDGE_COUNT (ei_container (*i)));\n   i->index++;\n }\n \n /* Move the iterator to the previous element.  */\n-static inline void\n+inline void\n ei_prev (edge_iterator *i)\n {\n   gcc_checking_assert (i->index > 0);\n   i->index--;\n }\n \n /* Return the edge pointed to by the iterator `i'.  */\n-static inline edge\n+inline edge\n ei_edge (edge_iterator i)\n {\n   return EDGE_I (ei_container (i), i.index);\n@@ -444,7 +444,7 @@ ei_edge (edge_iterator i)\n /* Return an edge pointed to by the iterator.  Do it safely so that\n    NULL is returned when the iterator is pointing at the end of the\n    sequence.  */\n-static inline edge\n+inline edge\n ei_safe_edge (edge_iterator i)\n {\n   return !ei_end_p (i) ? ei_edge (i) : NULL;\n@@ -454,7 +454,7 @@ ei_safe_edge (edge_iterator i)\n    *Edge P is set to the next edge if we are to continue to iterate\n    and NULL otherwise.  */\n \n-static inline bool\n+inline bool\n ei_cond (edge_iterator ei, edge *p)\n {\n   if (!ei_end_p (ei))\n@@ -505,14 +505,14 @@ ei_cond (edge_iterator ei, edge *p)\n \n /* Return true if BB is in a transaction.  */\n \n-static inline bool\n+inline bool\n bb_in_transaction (basic_block bb)\n {\n   return bb->flags & BB_IN_TRANSACTION;\n }\n \n /* Return true when one of the predecessor edges of BB is marked with EDGE_EH.  */\n-static inline bool\n+inline bool\n bb_has_eh_pred (basic_block bb)\n {\n   edge e;\n@@ -527,7 +527,7 @@ bb_has_eh_pred (basic_block bb)\n }\n \n /* Return true when one of the predecessor edges of BB is marked with EDGE_ABNORMAL.  */\n-static inline bool\n+inline bool\n bb_has_abnormal_pred (basic_block bb)\n {\n   edge e;\n@@ -542,7 +542,7 @@ bb_has_abnormal_pred (basic_block bb)\n }\n \n /* Return the fallthru edge in EDGES if it exists, NULL otherwise.  */\n-static inline edge\n+inline edge\n find_fallthru_edge (vec<edge, va_gc> *edges)\n {\n   edge e;\n@@ -557,7 +557,7 @@ find_fallthru_edge (vec<edge, va_gc> *edges)\n \n /* Check tha probability is sane.  */\n \n-static inline void\n+inline void\n check_probability (int prob)\n {\n   gcc_checking_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n@@ -566,7 +566,7 @@ check_probability (int prob)\n /* Given PROB1 and PROB2, return PROB1*PROB2/REG_BR_PROB_BASE. \n    Used to combine BB probabilities.  */\n \n-static inline int\n+inline int\n combine_probabilities (int prob1, int prob2)\n {\n   check_probability (prob1);\n@@ -578,15 +578,15 @@ combine_probabilities (int prob1, int prob2)\n    interface when potentially scaling up, so that SCALE is not\n    constrained to be < REG_BR_PROB_BASE.  */\n \n-static inline gcov_type\n+inline gcov_type\n apply_scale (gcov_type freq, gcov_type scale)\n {\n   return RDIV (freq * scale, REG_BR_PROB_BASE);\n }\n \n /* Apply probability PROB on frequency or count FREQ.  */\n \n-static inline gcov_type\n+inline gcov_type\n apply_probability (gcov_type freq, int prob)\n {\n   check_probability (prob);\n@@ -595,7 +595,7 @@ apply_probability (gcov_type freq, int prob)\n \n /* Return inverse probability for PROB.  */\n \n-static inline int\n+inline int\n inverse_probability (int prob1)\n {\n   check_probability (prob1);\n@@ -604,7 +604,7 @@ inverse_probability (int prob1)\n \n /* Return true if BB has at least one abnormal outgoing edge.  */\n \n-static inline bool\n+inline bool\n has_abnormal_or_eh_outgoing_edge_p (basic_block bb)\n {\n   edge e;\n@@ -620,7 +620,7 @@ has_abnormal_or_eh_outgoing_edge_p (basic_block bb)\n /* Return true when one of the predecessor edges of BB is marked with\n    EDGE_ABNORMAL_CALL or EDGE_EH.  */\n \n-static inline bool\n+inline bool\n has_abnormal_call_or_eh_pred_edge_p (basic_block bb)\n {\n   edge e;"}, {"sha": "43337d2e9d9ed8c1be2c230221f2c8e7204d9f8f", "filename": "gcc/bitmap.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -461,7 +461,7 @@ extern void dump_bitmap_statistics (void);\n /* Initialize a bitmap header.  OBSTACK indicates the bitmap obstack\n    to allocate from, NULL for GC'd bitmap.  */\n \n-static inline void\n+inline void\n bitmap_initialize (bitmap head, bitmap_obstack *obstack CXX_MEM_STAT_INFO)\n {\n   head->first = head->current = NULL;\n@@ -476,7 +476,7 @@ bitmap_initialize (bitmap head, bitmap_obstack *obstack CXX_MEM_STAT_INFO)\n /* Release a bitmap (but not its head).  This is suitable for pairing with\n    bitmap_initialize.  */\n \n-static inline void\n+inline void\n bitmap_release (bitmap head)\n {\n   bitmap_clear (head);\n@@ -532,7 +532,7 @@ struct bitmap_iterator\n /* Initialize a single bitmap iterator.  START_BIT is the first bit to\n    iterate from.  */\n \n-static inline void\n+inline void\n bmp_iter_set_init (bitmap_iterator *bi, const_bitmap map,\n \t\t   unsigned start_bit, unsigned *bit_no)\n {\n@@ -576,7 +576,7 @@ bmp_iter_set_init (bitmap_iterator *bi, const_bitmap map,\n /* Initialize an iterator to iterate over the intersection of two\n    bitmaps.  START_BIT is the bit to commence from.  */\n \n-static inline void\n+inline void\n bmp_iter_and_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,\n \t\t   unsigned start_bit, unsigned *bit_no)\n {\n@@ -645,7 +645,7 @@ bmp_iter_and_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,\n \n /* Initialize an iterator to iterate over the bits in MAP1 & ~MAP2.  */\n \n-static inline void\n+inline void\n bmp_iter_and_compl_init (bitmap_iterator *bi,\n \t\t\t const_bitmap map1, const_bitmap map2,\n \t\t\t unsigned start_bit, unsigned *bit_no)\n@@ -696,7 +696,7 @@ bmp_iter_and_compl_init (bitmap_iterator *bi,\n /* Advance to the next bit in BI.  We don't advance to the next\n    nonzero bit yet.  */\n \n-static inline void\n+inline void\n bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)\n {\n   bi->bits >>= 1;\n@@ -705,7 +705,7 @@ bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)\n \n /* Advance to first set bit in BI.  */\n \n-static inline void\n+inline void\n bmp_iter_next_bit (bitmap_iterator * bi, unsigned *bit_no)\n {\n #if (GCC_VERSION >= 3004)\n@@ -728,7 +728,7 @@ bmp_iter_next_bit (bitmap_iterator * bi, unsigned *bit_no)\n    already advanced past the just iterated bit.  Return true if there\n    is a bit to iterate.  */\n \n-static inline bool\n+inline bool\n bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n {\n   /* If our current word is nonzero, it contains the bit we want.  */\n@@ -774,7 +774,7 @@ bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n    bitmaps.  We will have already advanced past the just iterated bit.\n    Return true if there is a bit to iterate.  */\n \n-static inline bool\n+inline bool\n bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n {\n   /* If our current word is nonzero, it contains the bit we want.  */\n@@ -843,7 +843,7 @@ bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n    complemented bitmaps.  We will have already advanced past the just\n    iterated bit.  */\n \n-static inline bool\n+inline bool\n bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n {\n   /* If our current word is nonzero, it contains the bit we want.  */"}, {"sha": "3cf7df691d15182dfd4cc4e836fa0cc6719ebe73", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -923,7 +923,7 @@ extern tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwis\n    minimum or op1 is not -1, because e.g. (long long) INT_MIN / -1 is\n    well defined INT_MAX + 1LL if long long is wider than int, but INT_MIN / -1\n    is UB.  */\n-static inline bool\n+inline bool\n may_shorten_divmod (tree op0, tree op1)\n {\n   tree type0 = TREE_TYPE (op0);\n@@ -1327,7 +1327,7 @@ extern const struct c_omp_directive *c_omp_categorize_directive (const char *,\n \t\t\t\t\t\t\t\t const char *);\n \n /* Return next tree in the chain for chain_next walking of tree nodes.  */\n-static inline tree\n+inline tree\n c_tree_chain_next (tree t)\n {\n   /* TREE_CHAIN of a type is TYPE_STUB_DECL, which is different"}, {"sha": "545f0f4d9ebcbc70fc819f1ac6cd6ceb58bd94af", "filename": "gcc/c/c-parser.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fc%2Fc-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fc%2Fc-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -161,7 +161,7 @@ extern bool old_style_parameter_scope (void);\n /* Return true if the next token from PARSER has the indicated\n    TYPE.  */\n \n-static inline bool\n+inline bool\n c_parser_next_token_is (c_parser *parser, enum cpp_ttype type)\n {\n   return c_parser_peek_token (parser)->type == type;\n@@ -170,7 +170,7 @@ c_parser_next_token_is (c_parser *parser, enum cpp_ttype type)\n /* Return true if the next token from PARSER does not have the\n    indicated TYPE.  */\n \n-static inline bool\n+inline bool\n c_parser_next_token_is_not (c_parser *parser, enum cpp_ttype type)\n {\n   return !c_parser_next_token_is (parser, type);\n@@ -179,7 +179,7 @@ c_parser_next_token_is_not (c_parser *parser, enum cpp_ttype type)\n /* Return true if the next token from PARSER is the indicated\n    KEYWORD.  */\n \n-static inline bool\n+inline bool\n c_parser_next_token_is_keyword (c_parser *parser, enum rid keyword)\n {\n   return c_parser_peek_token (parser)->keyword == keyword;"}, {"sha": "7c87712c8d7290b1c6c64b9df03306845866b92f", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -206,7 +206,7 @@ extern void verify_flow_info (void);\n /* Check control flow invariants, if internal consistency checks are\n    enabled.  */\n \n-static inline void\n+inline void\n checking_verify_flow_info (void)\n {\n   /* TODO: Add a separate option for -fchecking=cfg.  */"}, {"sha": "e7ac2b5f3db55de3dbbab7bd2bfe08388f4ec533", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -280,21 +280,21 @@ class GTY ((chain_next (\"%h.next\"))) loop {\n #define LOOP_C_FINITE\t\t(1 << 1)\n \n /* Set C to the LOOP constraint.  */\n-static inline void\n+inline void\n loop_constraint_set (class loop *loop, unsigned c)\n {\n   loop->constraints |= c;\n }\n \n /* Clear C from the LOOP constraint.  */\n-static inline void\n+inline void\n loop_constraint_clear (class loop *loop, unsigned c)\n {\n   loop->constraints &= ~c;\n }\n \n /* Check if C is set in the LOOP constraint.  */\n-static inline bool\n+inline bool\n loop_constraint_set_p (class loop *loop, unsigned c)\n {\n   return (loop->constraints & c) == c;\n@@ -508,7 +508,7 @@ extern void iv_analysis_done (void);\n extern class niter_desc *get_simple_loop_desc (class loop *loop);\n extern void free_simple_loop_desc (class loop *loop);\n \n-static inline class niter_desc *\n+inline class niter_desc *\n simple_loop_desc (class loop *loop)\n {\n   return loop->simple_loop_desc;\n@@ -518,15 +518,15 @@ simple_loop_desc (class loop *loop)\n \n /* Returns the loop with index NUM from FNs loop tree.  */\n \n-static inline class loop *\n+inline class loop *\n get_loop (struct function *fn, unsigned num)\n {\n   return (*loops_for_fn (fn)->larray)[num];\n }\n \n /* Returns the number of superloops of LOOP.  */\n \n-static inline unsigned\n+inline unsigned\n loop_depth (const class loop *loop)\n {\n   return vec_safe_length (loop->superloops);\n@@ -535,7 +535,7 @@ loop_depth (const class loop *loop)\n /* Returns the immediate superloop of LOOP, or NULL if LOOP is the outermost\n    loop.  */\n \n-static inline class loop *\n+inline class loop *\n loop_outer (const class loop *loop)\n {\n   unsigned n = vec_safe_length (loop->superloops);\n@@ -548,7 +548,7 @@ loop_outer (const class loop *loop)\n \n /* Returns true if LOOP has at least one exit edge.  */\n \n-static inline bool\n+inline bool\n loop_has_exit_edges (const class loop *loop)\n {\n   return loop->exits->next->e != NULL;\n@@ -569,7 +569,7 @@ get_loops (struct function *fn)\n /* Returns the number of loops in FN (including the removed\n    ones and the fake loop that forms the root of the loop tree).  */\n \n-static inline unsigned\n+inline unsigned\n number_of_loops (struct function *fn)\n {\n   struct loops *loops = loops_for_fn (fn);\n@@ -582,41 +582,41 @@ number_of_loops (struct function *fn)\n /* Returns true if state of the loops satisfies all properties\n    described by FLAGS.  */\n \n-static inline bool\n+inline bool\n loops_state_satisfies_p (function *fn, unsigned flags)\n {\n   return (loops_for_fn (fn)->state & flags) == flags;\n }\n \n-static inline bool\n+inline bool\n loops_state_satisfies_p (unsigned flags)\n {\n   return loops_state_satisfies_p (cfun, flags);\n }\n \n /* Sets FLAGS to the loops state.  */\n \n-static inline void\n+inline void\n loops_state_set (function *fn, unsigned flags)\n {\n   loops_for_fn (fn)->state |= flags;\n }\n \n-static inline void\n+inline void\n loops_state_set (unsigned flags)\n {\n   loops_state_set (cfun, flags);\n }\n \n /* Clears FLAGS from the loops state.  */\n \n-static inline void\n+inline void\n loops_state_clear (function *fn, unsigned flags)\n {\n   loops_for_fn (fn)->state &= ~flags;\n }\n \n-static inline void\n+inline void\n loops_state_clear (unsigned flags)\n {\n   if (!current_loops)\n@@ -627,7 +627,7 @@ loops_state_clear (unsigned flags)\n /* Check loop structure invariants, if internal consistency checks are\n    enabled.  */\n \n-static inline void\n+inline void\n checking_verify_loop_structure (void)\n {\n   /* VERIFY_LOOP_STRUCTURE essentially asserts that no loops need fixups.\n@@ -897,7 +897,7 @@ extern void move_loop_invariants (void);\n extern auto_vec<basic_block> get_loop_hot_path (const class loop *loop);\n \n /* Returns the outermost loop of the loop nest that contains LOOP.*/\n-static inline class loop *\n+inline class loop *\n loop_outermost (class loop *loop)\n {\n   unsigned n = vec_safe_length (loop->superloops);\n@@ -919,7 +919,7 @@ extern int bb_loop_depth (const_basic_block);\n \n /* Converts VAL to widest_int.  */\n \n-static inline widest_int\n+inline widest_int\n gcov_type_to_wide_int (gcov_type val)\n {\n   HOST_WIDE_INT a[2];"}, {"sha": "b5fc739f1b0602a871040292a5bb1d69a9ef305f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -2650,7 +2650,7 @@ symtab_node::real_symbol_p (void)\n /* Return true if DECL should have entry in symbol table if used.\n    Those are functions and static & external variables.  */\n \n-static inline bool\n+inline bool\n decl_in_symtab_p (const_tree decl)\n {\n   return (TREE_CODE (decl) == FUNCTION_DECL\n@@ -3323,7 +3323,7 @@ cgraph_edge::frequency ()\n \n \n /* Return true if the TM_CLONE bit is set for a given FNDECL.  */\n-static inline bool\n+inline bool\n decl_is_tm_clone (const_tree fndecl)\n {\n   cgraph_node *n = cgraph_node::get (fndecl);\n@@ -3539,7 +3539,7 @@ ipa_polymorphic_call_context::useless_p () const\n    the name documents the intent.  We require that no GC can occur\n    within the fprintf call.  */\n \n-static inline const char *\n+inline const char *\n xstrdup_for_dump (const char *transient_str)\n {\n   return ggc_strdup (transient_str);"}, {"sha": "be8775ed0f8c2d9e931b50685f57da1c3af30208", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -4238,7 +4238,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n /* We have an expression tree T that represents a call, either CALL_EXPR\n    or AGGR_INIT_EXPR.  Return a reference to the Nth argument.  */\n \n-static inline tree&\n+inline tree&\n get_nth_callarg (tree t, int n)\n {\n   switch (TREE_CODE (t))"}, {"sha": "e2fa8e8c2c1d5e4686d23a0546fa0c8275f03206", "filename": "gcc/cselib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -113,7 +113,7 @@ extern void dump_cselib_table (FILE *);\n /* Return the canonical value for VAL, following the equivalence chain\n    towards the earliest (== lowest uid) equivalent value.  */\n \n-static inline cselib_val *\n+inline cselib_val *\n canonical_cselib_val (cselib_val *val)\n {\n   cselib_val *canon;\n@@ -131,7 +131,7 @@ canonical_cselib_val (cselib_val *val)\n /* Return nonzero if we can prove that X and Y contain the same value, taking\n    our gathered information into account.  */\n \n-static inline int\n+inline int\n rtx_equal_for_cselib_p (rtx x, rtx y)\n {\n   if (x == y)"}, {"sha": "d8c7e21dad9b32814695c6ee09a19a8bc23b4d05", "filename": "gcc/data-streamer.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdata-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdata-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -91,7 +91,7 @@ wide_int streamer_read_wide_int (class lto_input_block *);\n widest_int streamer_read_widest_int (class lto_input_block *);\n \n /* Returns a new bit-packing context for bit-packing into S.  */\n-static inline struct bitpack_d\n+inline struct bitpack_d\n bitpack_create (struct lto_output_stream *s)\n {\n   struct bitpack_d bp;\n@@ -102,7 +102,7 @@ bitpack_create (struct lto_output_stream *s)\n }\n \n /* Pack the NBITS bit sized value VAL into the bit-packing context BP.  */\n-static inline void\n+inline void\n bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n {\n   bitpack_word_t word = bp->word;\n@@ -132,7 +132,7 @@ bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n \n /* Pack VAL into the bit-packing context BP, using NBITS for each\n    coefficient.  */\n-static inline void\n+inline void\n bp_pack_poly_value (struct bitpack_d *bp,\n \t\t    const poly_int<NUM_POLY_INT_COEFFS, bitpack_word_t> &val,\n \t\t    unsigned nbits)\n@@ -142,7 +142,7 @@ bp_pack_poly_value (struct bitpack_d *bp,\n }\n \n /* Finishes bit-packing of BP.  */\n-static inline void\n+inline void\n streamer_write_bitpack (struct bitpack_d *bp)\n {\n   streamer_write_uhwi_stream ((struct lto_output_stream *) bp->stream,\n@@ -152,7 +152,7 @@ streamer_write_bitpack (struct bitpack_d *bp)\n }\n \n /* Returns a new bit-packing context for bit-unpacking from IB.  */\n-static inline struct bitpack_d\n+inline struct bitpack_d\n streamer_read_bitpack (class lto_input_block *ib)\n {\n   struct bitpack_d bp;\n@@ -163,7 +163,7 @@ streamer_read_bitpack (class lto_input_block *ib)\n }\n \n /* Unpacks NBITS bits from the bit-packing context BP and returns them.  */\n-static inline bitpack_word_t\n+inline bitpack_word_t\n bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n {\n   bitpack_word_t mask, val;\n@@ -191,7 +191,7 @@ bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n \n /* Unpacks a polynomial value from the bit-packing context BP in which each\n    coefficient has NBITS bits.  */\n-static inline poly_int<NUM_POLY_INT_COEFFS, bitpack_word_t>\n+inline poly_int<NUM_POLY_INT_COEFFS, bitpack_word_t>\n bp_unpack_poly_value (struct bitpack_d *bp, unsigned nbits)\n {\n   poly_int_pod<NUM_POLY_INT_COEFFS, bitpack_word_t> x;\n@@ -203,7 +203,7 @@ bp_unpack_poly_value (struct bitpack_d *bp, unsigned nbits)\n \n /* Write a character to the output block.  */\n \n-static inline void\n+inline void\n streamer_write_char_stream (struct lto_output_stream *obs, char c)\n {\n   /* No space left.  */\n@@ -221,7 +221,7 @@ streamer_write_char_stream (struct lto_output_stream *obs, char c)\n \n /* Read byte from the input block.  */\n \n-static inline unsigned char\n+inline unsigned char\n streamer_read_uchar (class lto_input_block *ib)\n {\n   if (ib->p >= ib->len)\n@@ -233,7 +233,7 @@ streamer_read_uchar (class lto_input_block *ib)\n    to be compile time constant.\n    Be host independent, limit range to 31bits.  */\n \n-static inline void\n+inline void\n streamer_write_hwi_in_range (struct lto_output_stream *obs,\n \t\t\t\t  HOST_WIDE_INT min,\n \t\t\t\t  HOST_WIDE_INT max,\n@@ -251,7 +251,7 @@ streamer_write_hwi_in_range (struct lto_output_stream *obs,\n /* Input VAL into OBS and verify it is in range MIN...MAX that is supposed\n    to be compile time constant.  PURPOSE is used for error reporting.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n streamer_read_hwi_in_range (class lto_input_block *ib,\n \t\t\t\t const char *purpose,\n \t\t\t\t HOST_WIDE_INT min,\n@@ -272,7 +272,7 @@ streamer_read_hwi_in_range (class lto_input_block *ib,\n    to be compile time constant.\n    Be host independent, limit range to 31bits.  */\n \n-static inline void\n+inline void\n bp_pack_int_in_range (struct bitpack_d *bp,\n \t\t      HOST_WIDE_INT min,\n \t\t      HOST_WIDE_INT max,\n@@ -291,7 +291,7 @@ bp_pack_int_in_range (struct bitpack_d *bp,\n /* Input VAL into BP and verify it is in range MIN...MAX that is supposed\n    to be compile time constant.  PURPOSE is used for error reporting.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n bp_unpack_int_in_range (struct bitpack_d *bp,\n \t\t        const char *purpose,\n \t\t        HOST_WIDE_INT min,\n@@ -332,15 +332,15 @@ bp_unpack_int_in_range (struct bitpack_d *bp,\n \n /* Output the start of a record with TAG to output block OB.  */\n \n-static inline void\n+inline void\n streamer_write_record_start (struct output_block *ob, enum LTO_tags tag)\n {\n   streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS, tag);\n }\n \n /* Return the next tag in the input block IB.  */\n \n-static inline enum LTO_tags\n+inline enum LTO_tags\n streamer_read_record_start (class lto_input_block *ib)\n {\n   return streamer_read_enum (ib, LTO_tags, LTO_NUM_TAGS);"}, {"sha": "05512bce48c1bb934df3bb87f3665f44f04fa8bf", "filename": "gcc/debug.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -270,7 +270,7 @@ extern decl_to_instance_map_t *decl_to_instance_map;\n /* Allocate decl_to_instance_map with COUNT slots to begin wtih, if it\n  * hasn't been allocated yet.  */\n \n-static inline decl_to_instance_map_t *\n+inline decl_to_instance_map_t *\n maybe_create_decl_to_instance_map (int count = 13)\n {\n   if (!decl_to_instance_map)"}, {"sha": "aec2223591a280c0df8cf27e6e6b44c3cd339540", "filename": "gcc/df.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -1097,7 +1097,7 @@ extern void df_scan_verify (void);\n    Public functions access functions for the dataflow problems.\n ----------------------------------------------------------------------------*/\n \n-static inline struct df_scan_bb_info *\n+inline struct df_scan_bb_info *\n df_scan_get_bb_info (unsigned int index)\n {\n   if (index < df_scan->block_info_size)\n@@ -1106,7 +1106,7 @@ df_scan_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_rd_bb_info *\n+inline class df_rd_bb_info *\n df_rd_get_bb_info (unsigned int index)\n {\n   if (index < df_rd->block_info_size)\n@@ -1115,7 +1115,7 @@ df_rd_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_lr_bb_info *\n+inline class df_lr_bb_info *\n df_lr_get_bb_info (unsigned int index)\n {\n   if (index < df_lr->block_info_size)\n@@ -1124,7 +1124,7 @@ df_lr_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_md_bb_info *\n+inline class df_md_bb_info *\n df_md_get_bb_info (unsigned int index)\n {\n   if (index < df_md->block_info_size)\n@@ -1133,7 +1133,7 @@ df_md_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_live_bb_info *\n+inline class df_live_bb_info *\n df_live_get_bb_info (unsigned int index)\n {\n   if (index < df_live->block_info_size)\n@@ -1142,7 +1142,7 @@ df_live_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_word_lr_bb_info *\n+inline class df_word_lr_bb_info *\n df_word_lr_get_bb_info (unsigned int index)\n {\n   if (index < df_word_lr->block_info_size)\n@@ -1151,7 +1151,7 @@ df_word_lr_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline class df_mir_bb_info *\n+inline class df_mir_bb_info *\n df_mir_get_bb_info (unsigned int index)\n {\n   if (index < df_mir->block_info_size)\n@@ -1165,7 +1165,7 @@ df_mir_get_bb_info (unsigned int index)\n    choose different dataflow problems depending on the optimization\n    level.  */\n \n-static inline bitmap\n+inline bitmap\n df_get_live_out (basic_block bb)\n {\n   gcc_checking_assert (df_lr);\n@@ -1181,7 +1181,7 @@ df_get_live_out (basic_block bb)\n    choose different dataflow problems depending on the optimization\n    level.  */\n \n-static inline bitmap\n+inline bitmap\n df_get_live_in (basic_block bb)\n {\n   gcc_checking_assert (df_lr);\n@@ -1195,7 +1195,7 @@ df_get_live_in (basic_block bb)\n /* Get basic block info.  */\n /* Get the artificial defs for a basic block.  */\n \n-static inline df_ref\n+inline df_ref\n df_get_artificial_defs (unsigned int bb_index)\n {\n   return df_scan_get_bb_info (bb_index)->artificial_defs;\n@@ -1204,7 +1204,7 @@ df_get_artificial_defs (unsigned int bb_index)\n \n /* Get the artificial uses for a basic block.  */\n \n-static inline df_ref\n+inline df_ref\n df_get_artificial_uses (unsigned int bb_index)\n {\n   return df_scan_get_bb_info (bb_index)->artificial_uses;\n@@ -1213,7 +1213,7 @@ df_get_artificial_uses (unsigned int bb_index)\n /* If INSN defines exactly one register, return the associated reference,\n    otherwise return null.  */\n \n-static inline df_ref\n+inline df_ref\n df_single_def (const df_insn_info *info)\n {\n   df_ref defs = DF_INSN_INFO_DEFS (info);\n@@ -1223,7 +1223,7 @@ df_single_def (const df_insn_info *info)\n /* If INSN uses exactly one register, return the associated reference,\n    otherwise return null.  */\n \n-static inline df_ref\n+inline df_ref\n df_single_use (const df_insn_info *info)\n {\n   df_ref uses = DF_INSN_INFO_USES (info);"}, {"sha": "e7390e495546f7bec93f18688ef1f4092a25cfa9", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -416,7 +416,7 @@ struct diagnostic_context\n   diagnostic_client_data_hooks *m_client_data_hooks;\n };\n \n-static inline void\n+inline void\n diagnostic_inhibit_notes (diagnostic_context * context)\n {\n   context->inhibit_notes_p = true;\n@@ -474,7 +474,7 @@ extern diagnostic_context *global_dc;\n /* Override the option index to be used for reporting a\n    diagnostic.  */\n \n-static inline void\n+inline void\n diagnostic_override_option_index (diagnostic_info *info, int optidx)\n {\n   info->option_index = optidx;\n@@ -546,15 +546,15 @@ int get_terminal_width (void);\n /* Return the location associated to this diagnostic. Parameter WHICH\n    specifies which location. By default, expand the first one.  */\n \n-static inline location_t\n+inline location_t\n diagnostic_location (const diagnostic_info * diagnostic, int which = 0)\n {\n   return diagnostic->message.get_location (which);\n }\n \n /* Return the number of locations to be printed in DIAGNOSTIC.  */\n \n-static inline unsigned int\n+inline unsigned int\n diagnostic_num_locations (const diagnostic_info * diagnostic)\n {\n   return diagnostic->message.m_richloc->get_num_locations ();\n@@ -564,7 +564,7 @@ diagnostic_num_locations (const diagnostic_info * diagnostic)\n    consistency.  Parameter WHICH specifies which location. By default,\n    expand the first one.  */\n \n-static inline expanded_location\n+inline expanded_location\n diagnostic_expand_location (const diagnostic_info * diagnostic, int which = 0)\n {\n   return diagnostic->richloc->get_expanded_location (which);\n@@ -579,7 +579,7 @@ const int CARET_LINE_MARGIN = 10;\n    caret line.  This is used to build a prefix and also to determine\n    whether to print one or two caret lines.  */\n \n-static inline bool\n+inline bool\n diagnostic_same_line (const diagnostic_context *context,\n \t\t       expanded_location s1, expanded_location s2)\n {"}, {"sha": "ddac0f58050d34130ebbd6aa3b1adfa39c4c216c", "filename": "gcc/dominance.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdominance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdominance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -69,7 +69,7 @@ extern void verify_dominators (enum cdi_direction);\n /* Verify invariants of computed dominance information, if internal consistency\n    checks are enabled.  */\n \n-static inline void\n+inline void\n checking_verify_dominators (cdi_direction dir)\n {\n   if (flag_checking)"}, {"sha": "7d5eca899dcc98676a9ce7a7efff8e439854ff89", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -208,35 +208,35 @@ enum dump_flag : uint32_t\n \n typedef enum dump_flag dump_flags_t;\n \n-static inline dump_flags_t\n+inline dump_flags_t\n operator| (dump_flags_t lhs, dump_flags_t rhs)\n {\n   return (dump_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n \t\t\t| (std::underlying_type<dump_flags_t>::type)rhs);\n }\n \n-static inline dump_flags_t\n+inline dump_flags_t\n operator& (dump_flags_t lhs, dump_flags_t rhs)\n {\n   return (dump_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n \t\t\t& (std::underlying_type<dump_flags_t>::type)rhs);\n }\n \n-static inline dump_flags_t\n+inline dump_flags_t\n operator~ (dump_flags_t flags)\n {\n   return (dump_flags_t)~((std::underlying_type<dump_flags_t>::type)flags);\n }\n \n-static inline dump_flags_t &\n+inline dump_flags_t &\n operator|= (dump_flags_t &lhs, dump_flags_t rhs)\n {\n   lhs = (dump_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n \t\t       | (std::underlying_type<dump_flags_t>::type)rhs);\n   return lhs;\n }\n \n-static inline dump_flags_t &\n+inline dump_flags_t &\n operator&= (dump_flags_t &lhs, dump_flags_t rhs)\n {\n   lhs = (dump_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n@@ -276,14 +276,14 @@ enum optgroup_flag\n \n typedef enum optgroup_flag optgroup_flags_t;\n \n-static inline optgroup_flags_t\n+inline optgroup_flags_t\n operator| (optgroup_flags_t lhs, optgroup_flags_t rhs)\n {\n   return (optgroup_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n \t\t\t    | (std::underlying_type<dump_flags_t>::type)rhs);\n }\n \n-static inline optgroup_flags_t &\n+inline optgroup_flags_t &\n operator|= (optgroup_flags_t &lhs, optgroup_flags_t rhs)\n {\n   lhs = (optgroup_flags_t)((std::underlying_type<dump_flags_t>::type)lhs\n@@ -528,7 +528,7 @@ extern bool dumps_are_enabled;\n extern void set_dump_file (FILE *new_dump_file);\n \n /* Return true if any of the dumps is enabled, false otherwise. */\n-static inline bool\n+inline bool\n dump_enabled_p (void)\n {\n   return dumps_are_enabled;"}, {"sha": "c472c736cb66acf821d54ab899ed6e425faa0658", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -400,15 +400,15 @@ extern bool need_atomic_barrier_p (enum memmodel, bool);\n \n /* Return the current sequence.  */\n \n-static inline struct sequence_stack *\n+inline struct sequence_stack *\n get_current_sequence (void)\n {\n   return &crtl->emit.seq;\n }\n \n /* Return the outermost sequence.  */\n \n-static inline struct sequence_stack *\n+inline struct sequence_stack *\n get_topmost_sequence (void)\n {\n   struct sequence_stack *seq, *top;\n@@ -424,15 +424,15 @@ get_topmost_sequence (void)\n \n /* Return the first insn of the current sequence or current function.  */\n \n-static inline rtx_insn *\n+inline rtx_insn *\n get_insns (void)\n {\n   return get_current_sequence ()->first;\n }\n \n /* Specify a new insn as the first in the chain.  */\n \n-static inline void\n+inline void\n set_first_insn (rtx_insn *insn)\n {\n   gcc_checking_assert (!insn || !PREV_INSN (insn));\n@@ -441,15 +441,15 @@ set_first_insn (rtx_insn *insn)\n \n /* Return the last insn emitted in current sequence or current function.  */\n \n-static inline rtx_insn *\n+inline rtx_insn *\n get_last_insn (void)\n {\n   return get_current_sequence ()->last;\n }\n \n /* Specify a new insn as the last in the chain.  */\n \n-static inline void\n+inline void\n set_last_insn (rtx_insn *insn)\n {\n   gcc_checking_assert (!insn || !NEXT_INSN (insn));\n@@ -458,7 +458,7 @@ set_last_insn (rtx_insn *insn)\n \n /* Return a number larger than any instruction's uid in this function.  */\n \n-static inline int\n+inline int\n get_max_uid (void)\n {\n   return crtl->emit.x_cur_insn_uid;"}, {"sha": "5ecdbc0d1dc2959810db8d943ae298acfb55c56a", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -302,7 +302,7 @@ function_needs_eh_personality (struct function *);\n \n /* Pre-order iteration within the eh_region tree.  */\n \n-static inline eh_region\n+inline eh_region\n ehr_next (eh_region r, eh_region start)\n {\n   if (r->inner)"}, {"sha": "c1aee00c616b5a10b341c20bda895440066d8124", "filename": "gcc/expmed.h", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -191,31 +191,31 @@ extern struct target_expmed *this_target_expmed;\n \n /* Return a pointer to the alg_hash_entry at IDX.  */\n \n-static inline struct alg_hash_entry *\n+inline struct alg_hash_entry *\n alg_hash_entry_ptr (int idx)\n {\n   return &this_target_expmed->x_alg_hash[idx];\n }\n \n /* Return true if the x_alg_hash field might have been used.  */\n \n-static inline bool\n+inline bool\n alg_hash_used_p (void)\n {\n   return this_target_expmed->x_alg_hash_used_p;\n }\n \n /* Set whether the x_alg_hash field might have been used.  */\n \n-static inline void\n+inline void\n set_alg_hash_used_p (bool usedp)\n {\n   this_target_expmed->x_alg_hash_used_p = usedp;\n }\n \n /* Compute an index into the cost arrays by mode class.  */\n \n-static inline int\n+inline int\n expmed_mode_index (machine_mode mode)\n {\n   switch (GET_MODE_CLASS (mode))\n@@ -244,7 +244,7 @@ expmed_mode_index (machine_mode mode)\n    a particular operation performed in MODE is cheap when optimizing\n    for SPEED.  */\n \n-static inline bool *\n+inline bool *\n expmed_op_cheap_ptr (struct expmed_op_cheap *eoc, bool speed,\n \t\t     machine_mode mode)\n {\n@@ -255,7 +255,7 @@ expmed_op_cheap_ptr (struct expmed_op_cheap *eoc, bool speed,\n /* Return a pointer to a cost contained in COSTS when a particular\n    operation is performed in MODE when optimizing for SPEED.  */\n \n-static inline int *\n+inline int *\n expmed_op_cost_ptr (struct expmed_op_costs *costs, bool speed,\n \t\t    machine_mode mode)\n {\n@@ -265,7 +265,7 @@ expmed_op_cost_ptr (struct expmed_op_costs *costs, bool speed,\n \n /* Subroutine of {set_,}sdiv_pow2_cheap.  Not to be used otherwise.  */\n \n-static inline bool *\n+inline bool *\n sdiv_pow2_cheap_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cheap_ptr (&this_target_expmed->x_sdiv_pow2_cheap,\n@@ -275,7 +275,7 @@ sdiv_pow2_cheap_ptr (bool speed, machine_mode mode)\n /* Set whether a signed division by a power of 2 is cheap in MODE\n    when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_sdiv_pow2_cheap (bool speed, machine_mode mode, bool cheap_p)\n {\n   *sdiv_pow2_cheap_ptr (speed, mode) = cheap_p;\n@@ -284,15 +284,15 @@ set_sdiv_pow2_cheap (bool speed, machine_mode mode, bool cheap_p)\n /* Return whether a signed division by a power of 2 is cheap in MODE\n    when optimizing for SPEED.  */\n \n-static inline bool\n+inline bool\n sdiv_pow2_cheap (bool speed, machine_mode mode)\n {\n   return *sdiv_pow2_cheap_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}smod_pow2_cheap.  Not to be used otherwise.  */\n \n-static inline bool *\n+inline bool *\n smod_pow2_cheap_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cheap_ptr (&this_target_expmed->x_smod_pow2_cheap,\n@@ -302,7 +302,7 @@ smod_pow2_cheap_ptr (bool speed, machine_mode mode)\n /* Set whether a signed modulo by a power of 2 is CHEAP in MODE when\n    optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_smod_pow2_cheap (bool speed, machine_mode mode, bool cheap)\n {\n   *smod_pow2_cheap_ptr (speed, mode) = cheap;\n@@ -311,71 +311,71 @@ set_smod_pow2_cheap (bool speed, machine_mode mode, bool cheap)\n /* Return whether a signed modulo by a power of 2 is cheap in MODE\n    when optimizing for SPEED.  */\n \n-static inline bool\n+inline bool\n smod_pow2_cheap (bool speed, machine_mode mode)\n {\n   return *smod_pow2_cheap_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}zero_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n zero_cost_ptr (bool speed)\n {\n   return &this_target_expmed->x_zero_cost[speed];\n }\n \n /* Set the COST of loading zero when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_zero_cost (bool speed, int cost)\n {\n   *zero_cost_ptr (speed) = cost;\n }\n \n /* Return the COST of loading zero when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n zero_cost (bool speed)\n {\n   return *zero_cost_ptr (speed);\n }\n \n /* Subroutine of {set_,}add_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n add_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_add_cost, speed, mode);\n }\n \n /* Set the COST of computing an add in MODE when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_add_cost (bool speed, machine_mode mode, int cost)\n {\n   *add_cost_ptr (speed, mode) = cost;\n }\n \n /* Return the cost of computing an add in MODE when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n add_cost (bool speed, machine_mode mode)\n {\n   return *add_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}neg_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n neg_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_neg_cost, speed, mode);\n }\n \n /* Set the COST of computing a negation in MODE when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_neg_cost (bool speed, machine_mode mode, int cost)\n {\n   *neg_cost_ptr (speed, mode) = cost;\n@@ -384,15 +384,15 @@ set_neg_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost of computing a negation in MODE when optimizing for\n    SPEED.  */\n \n-static inline int\n+inline int\n neg_cost (bool speed, machine_mode mode)\n {\n   return *neg_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}shift_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n shift_cost_ptr (bool speed, machine_mode mode, int bits)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_shift_cost[bits],\n@@ -401,7 +401,7 @@ shift_cost_ptr (bool speed, machine_mode mode, int bits)\n \n /* Set the COST of doing a shift in MODE by BITS when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_shift_cost (bool speed, machine_mode mode, int bits, int cost)\n {\n   *shift_cost_ptr (speed, mode, bits) = cost;\n@@ -410,15 +410,15 @@ set_shift_cost (bool speed, machine_mode mode, int bits, int cost)\n /* Return the cost of doing a shift in MODE by BITS when optimizing for\n    SPEED.  */\n \n-static inline int\n+inline int\n shift_cost (bool speed, machine_mode mode, int bits)\n {\n   return *shift_cost_ptr (speed, mode, bits);\n }\n \n /* Subroutine of {set_,}shiftadd_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n shiftadd_cost_ptr (bool speed, machine_mode mode, int bits)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_shiftadd_cost[bits],\n@@ -428,7 +428,7 @@ shiftadd_cost_ptr (bool speed, machine_mode mode, int bits)\n /* Set the COST of doing a shift in MODE by BITS followed by an add when\n    optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_shiftadd_cost (bool speed, machine_mode mode, int bits, int cost)\n {\n   *shiftadd_cost_ptr (speed, mode, bits) = cost;\n@@ -437,15 +437,15 @@ set_shiftadd_cost (bool speed, machine_mode mode, int bits, int cost)\n /* Return the cost of doing a shift in MODE by BITS followed by an add\n    when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n shiftadd_cost (bool speed, machine_mode mode, int bits)\n {\n   return *shiftadd_cost_ptr (speed, mode, bits);\n }\n \n /* Subroutine of {set_,}shiftsub0_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n shiftsub0_cost_ptr (bool speed, machine_mode mode, int bits)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_shiftsub0_cost[bits],\n@@ -455,7 +455,7 @@ shiftsub0_cost_ptr (bool speed, machine_mode mode, int bits)\n /* Set the COST of doing a shift in MODE by BITS and then subtracting a\n    value when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_shiftsub0_cost (bool speed, machine_mode mode, int bits, int cost)\n {\n   *shiftsub0_cost_ptr (speed, mode, bits) = cost;\n@@ -464,15 +464,15 @@ set_shiftsub0_cost (bool speed, machine_mode mode, int bits, int cost)\n /* Return the cost of doing a shift in MODE by BITS and then subtracting\n    a value when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n shiftsub0_cost (bool speed, machine_mode mode, int bits)\n {\n   return *shiftsub0_cost_ptr (speed, mode, bits);\n }\n \n /* Subroutine of {set_,}shiftsub1_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n shiftsub1_cost_ptr (bool speed, machine_mode mode, int bits)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_shiftsub1_cost[bits],\n@@ -482,7 +482,7 @@ shiftsub1_cost_ptr (bool speed, machine_mode mode, int bits)\n /* Set the COST of subtracting a shift in MODE by BITS from a value when\n    optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_shiftsub1_cost (bool speed, machine_mode mode, int bits, int cost)\n {\n   *shiftsub1_cost_ptr (speed, mode, bits) = cost;\n@@ -491,15 +491,15 @@ set_shiftsub1_cost (bool speed, machine_mode mode, int bits, int cost)\n /* Return the cost of subtracting a shift in MODE by BITS from a value\n    when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n shiftsub1_cost (bool speed, machine_mode mode, int bits)\n {\n   return *shiftsub1_cost_ptr (speed, mode, bits);\n }\n \n /* Subroutine of {set_,}mul_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n mul_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_mul_cost, speed, mode);\n@@ -508,7 +508,7 @@ mul_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST of doing a multiplication in MODE when optimizing for\n    SPEED.  */\n \n-static inline void\n+inline void\n set_mul_cost (bool speed, machine_mode mode, int cost)\n {\n   *mul_cost_ptr (speed, mode) = cost;\n@@ -517,15 +517,15 @@ set_mul_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost of doing a multiplication in MODE when optimizing\n    for SPEED.  */\n \n-static inline int\n+inline int\n mul_cost (bool speed, machine_mode mode)\n {\n   return *mul_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}sdiv_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n sdiv_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_sdiv_cost, speed, mode);\n@@ -534,7 +534,7 @@ sdiv_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST of doing a signed division in MODE when optimizing\n    for SPEED.  */\n \n-static inline void\n+inline void\n set_sdiv_cost (bool speed, machine_mode mode, int cost)\n {\n   *sdiv_cost_ptr (speed, mode) = cost;\n@@ -543,15 +543,15 @@ set_sdiv_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost of doing a signed division in MODE when optimizing\n    for SPEED.  */\n \n-static inline int\n+inline int\n sdiv_cost (bool speed, machine_mode mode)\n {\n   return *sdiv_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}udiv_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n udiv_cost_ptr (bool speed, machine_mode mode)\n {\n   return expmed_op_cost_ptr (&this_target_expmed->x_udiv_cost, speed, mode);\n@@ -560,7 +560,7 @@ udiv_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST of doing an unsigned division in MODE when optimizing\n    for SPEED.  */\n \n-static inline void\n+inline void\n set_udiv_cost (bool speed, machine_mode mode, int cost)\n {\n   *udiv_cost_ptr (speed, mode) = cost;\n@@ -569,15 +569,15 @@ set_udiv_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost of doing an unsigned division in MODE when\n    optimizing for SPEED.  */\n \n-static inline int\n+inline int\n udiv_cost (bool speed, machine_mode mode)\n {\n   return *udiv_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}mul_widen_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n mul_widen_cost_ptr (bool speed, machine_mode mode)\n {\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n@@ -588,7 +588,7 @@ mul_widen_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST for computing a widening multiplication in MODE when\n    optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_mul_widen_cost (bool speed, machine_mode mode, int cost)\n {\n   *mul_widen_cost_ptr (speed, mode) = cost;\n@@ -597,15 +597,15 @@ set_mul_widen_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost for computing a widening multiplication in MODE when\n    optimizing for SPEED.  */\n \n-static inline int\n+inline int\n mul_widen_cost (bool speed, machine_mode mode)\n {\n   return *mul_widen_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}mul_highpart_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n mul_highpart_cost_ptr (bool speed, machine_mode mode)\n {\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n@@ -618,7 +618,7 @@ mul_highpart_cost_ptr (bool speed, machine_mode mode)\n /* Set the COST for computing the high part of a multiplication in MODE\n    when optimizing for SPEED.  */\n \n-static inline void\n+inline void\n set_mul_highpart_cost (bool speed, machine_mode mode, int cost)\n {\n   *mul_highpart_cost_ptr (speed, mode) = cost;\n@@ -627,15 +627,15 @@ set_mul_highpart_cost (bool speed, machine_mode mode, int cost)\n /* Return the cost for computing the high part of a multiplication in MODE\n    when optimizing for SPEED.  */\n \n-static inline int\n+inline int\n mul_highpart_cost (bool speed, machine_mode mode)\n {\n   return *mul_highpart_cost_ptr (speed, mode);\n }\n \n /* Subroutine of {set_,}convert_cost.  Not to be used otherwise.  */\n \n-static inline int *\n+inline int *\n convert_cost_ptr (machine_mode to_mode, machine_mode from_mode,\n \t\t  bool speed)\n {\n@@ -651,7 +651,7 @@ convert_cost_ptr (machine_mode to_mode, machine_mode from_mode,\n /* Set the COST for converting from FROM_MODE to TO_MODE when optimizing\n    for SPEED.  */\n \n-static inline void\n+inline void\n set_convert_cost (machine_mode to_mode, machine_mode from_mode,\n \t\t  bool speed, int cost)\n {\n@@ -661,7 +661,7 @@ set_convert_cost (machine_mode to_mode, machine_mode from_mode,\n /* Return the cost for converting from FROM_MODE to TO_MODE when optimizing\n    for SPEED.  */\n \n-static inline int\n+inline int\n convert_cost (machine_mode to_mode, machine_mode from_mode,\n \t      bool speed)\n {"}, {"sha": "0c059ed9023bc5bdce467594fb35918dbeb1b25d", "filename": "gcc/expr.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -84,19 +84,19 @@ extern rtx convert_wider_int_to_float (machine_mode mode, machine_mode imode,\n extern rtx emit_block_op_via_libcall (enum built_in_function, rtx, rtx, rtx,\n \t\t\t\t      bool);\n \n-static inline rtx\n+inline rtx\n emit_block_copy_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n {\n   return emit_block_op_via_libcall (BUILT_IN_MEMCPY, dst, src, size, tailcall);\n }\n \n-static inline rtx\n+inline rtx\n emit_block_move_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n {\n   return emit_block_op_via_libcall (BUILT_IN_MEMMOVE, dst, src, size, tailcall);\n }\n \n-static inline rtx\n+inline rtx\n emit_block_comp_via_libcall (rtx dst, rtx src, rtx size, bool tailcall = false)\n {\n   return emit_block_op_via_libcall (BUILT_IN_MEMCMP, dst, src, size, tailcall);\n@@ -178,14 +178,14 @@ extern void clobber_reg_mode (rtx *, rtx, machine_mode);\n extern rtx copy_blkmode_to_reg (machine_mode, tree);\n \n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n-static inline void\n+inline void\n use_reg (rtx *fusage, rtx reg)\n {\n   use_reg_mode (fusage, reg, VOIDmode);\n }\n \n /* Mark REG as clobbered by the call with FUSAGE as CALL_INSN_FUNCTION_USAGE.  */\n-static inline void\n+inline void\n clobber_reg (rtx *fusage, rtx reg)\n {\n   clobber_reg_mode (fusage, reg, VOIDmode);\n@@ -303,14 +303,14 @@ extern rtx expand_expr_real_2 (sepops, rtx, machine_mode,\n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.  */\n-static inline rtx\n+inline rtx\n expand_expr (tree exp, rtx target, machine_mode mode,\n \t     enum expand_modifier modifier)\n {\n   return expand_expr_real (exp, target, mode, modifier, NULL, false);\n }\n \n-static inline rtx\n+inline rtx\n expand_normal (tree exp)\n {\n   return expand_expr_real (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL, NULL, false);"}, {"sha": "8d1002ac6f089b170f8c249049b28a051391e57f", "filename": "gcc/fixed-value.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ffixed-value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ffixed-value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -51,7 +51,7 @@ extern FIXED_VALUE_TYPE fixed_from_double_int (double_int, scalar_mode);\n \n /* Return a CONST_FIXED from a bit payload and machine mode MODE.\n    The bits in PAYLOAD are sign-extended/zero-extended according to MODE.  */\n-static inline rtx\n+inline rtx\n const_fixed_from_double_int (double_int payload,\n \t\t\t     scalar_mode mode)\n {"}, {"sha": "fea25312cf433c829e8291fe359932c54bea2904", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -3276,7 +3276,7 @@ void gfc_done_2 (void);\n int get_c_kind (const char *, CInteropKind_t *);\n \n const char *gfc_closest_fuzzy_match (const char *, char **);\n-static inline void\n+inline void\n vec_push (char **&optr, size_t &osz, const char *elt)\n {\n   /* {auto,}vec.safe_push () replacement.  Don't ask..  */\n@@ -3552,7 +3552,7 @@ void gfc_intrinsic_done_1 (void);\n \n char gfc_type_letter (bt, bool logical_equals_int = false);\n int gfc_type_abi_kind (bt, int);\n-static inline int\n+inline int\n gfc_type_abi_kind (gfc_typespec *ts)\n {\n   return gfc_type_abi_kind (ts->type, ts->kind);"}, {"sha": "4e5df544fbfc5170bc439d9395a14f5ed13511d9", "filename": "gcc/gengtype.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -77,7 +77,7 @@ input_file* input_file_by_name (const char* name);\n const char *get_file_srcdir_relative_path (const input_file *inpf);\n \n /* Get the name of an input file.  */\n-static inline const char*\n+inline const char*\n get_input_file_name (const input_file *inpf)\n {\n   if (inpf)\n@@ -94,7 +94,7 @@ get_input_file_name (const input_file *inpf)\n    some GC roots may be missed, which is a much harder-to-debug problem.\n   */\n \n-static inline lang_bitmap\n+inline lang_bitmap\n get_lang_bitmap (const input_file* inpf)\n {\n   if (inpf == NULL)\n@@ -104,7 +104,7 @@ get_lang_bitmap (const input_file* inpf)\n \n /* Set the bitmap returned by get_lang_bitmap.  The only legitimate\n    callers of this function are read_input_list & read_state_*.  */\n-static inline void\n+inline void\n set_lang_bitmap (input_file* inpf, lang_bitmap n)\n {\n   gcc_assert (inpf);\n@@ -346,7 +346,7 @@ extern struct type callback_type;\n \n /* Test if a type is a union or a structure, perhaps a language\n    specific one.  */\n-static inline bool\n+inline bool\n union_or_struct_p (enum typekind kind)\n {\n   return (kind == TYPE_UNION\n@@ -355,14 +355,14 @@ union_or_struct_p (enum typekind kind)\n \t  || kind == TYPE_USER_STRUCT);\n }\n \n-static inline bool\n+inline bool\n union_or_struct_p (const_type_p x)\n {\n   return union_or_struct_p (x->kind);\n }\n \n /* Give the file location of a type, if any. */\n-static inline struct fileloc* \n+inline struct fileloc* \n type_fileloc (type_p t)\n {\n   if (!t) "}, {"sha": "e89f7e20fc8196b77fd92fce6b62d52ebac50588", "filename": "gcc/gimple-expr.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -60,7 +60,7 @@ extern tree canonicalize_cond_expr_cond (tree);\n /* Return true if a conversion from either type of TYPE1 and TYPE2\n    to the other is not required.  Otherwise return false.  */\n \n-static inline bool\n+inline bool\n types_compatible_p (tree type1, tree type2)\n {\n   return (type1 == type2\n@@ -70,15 +70,15 @@ types_compatible_p (tree type1, tree type2)\n \n /* Return true if TYPE is a suitable type for a scalar register variable.  */\n \n-static inline bool\n+inline bool\n is_gimple_reg_type (tree type)\n {\n   return !AGGREGATE_TYPE_P (type);\n }\n \n /* Return true if T is a variable.  */\n \n-static inline bool\n+inline bool\n is_gimple_variable (tree t)\n {\n   return (TREE_CODE (t) == VAR_DECL\n@@ -89,7 +89,7 @@ is_gimple_variable (tree t)\n \n /*  Return true if T is a GIMPLE identifier (something with an address).  */\n \n-static inline bool\n+inline bool\n is_gimple_id (tree t)\n {\n   return (is_gimple_variable (t)\n@@ -102,7 +102,7 @@ is_gimple_id (tree t)\n \n /* Return true if OP, an SSA name or a DECL is a virtual operand.  */\n \n-static inline bool\n+inline bool\n virtual_operand_p (tree op)\n {\n   if (TREE_CODE (op) == SSA_NAME)\n@@ -116,7 +116,7 @@ virtual_operand_p (tree op)\n \n /*  Return true if T is something whose address can be taken.  */\n \n-static inline bool\n+inline bool\n is_gimple_addressable (tree t)\n {\n   return (is_gimple_id (t) || handled_component_p (t)\n@@ -126,7 +126,7 @@ is_gimple_addressable (tree t)\n \n /* Return true if T is a valid gimple constant.  */\n \n-static inline bool\n+inline bool\n is_gimple_constant (const_tree t)\n {\n   switch (TREE_CODE (t))\n@@ -148,7 +148,7 @@ is_gimple_constant (const_tree t)\n /* A wrapper around extract_ops_from_tree with 3 ops, for callers which\n    expect to see only a maximum of two operands.  */\n \n-static inline void\n+inline void\n extract_ops_from_tree (tree expr, enum tree_code *code, tree *op0,\n \t\t       tree *op1)\n {\n@@ -160,7 +160,7 @@ extract_ops_from_tree (tree expr, enum tree_code *code, tree *op0,\n /* Given a valid GIMPLE_CALL function address return the FUNCTION_DECL\n    associated with the callee if known.  Otherwise return NULL_TREE.  */\n \n-static inline tree\n+inline tree\n gimple_call_addr_fndecl (const_tree fn)\n {\n   if (fn && TREE_CODE (fn) == ADDR_EXPR)"}, {"sha": "38352aa95af62dc68b312477c113a91579b8cd9b", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -95,7 +95,7 @@ extern void update_modified_stmts (gimple_seq);\n \n /* Return a new iterator pointing to GIMPLE_SEQ's first statement.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start (gimple_seq &seq)\n {\n   gimple_stmt_iterator i;\n@@ -107,7 +107,7 @@ gsi_start (gimple_seq &seq)\n   return i;\n }\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_none (void)\n {\n   gimple_stmt_iterator i;\n@@ -119,7 +119,7 @@ gsi_none (void)\n \n /* Return a new iterator pointing to the first statement in basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start_bb (basic_block bb)\n {\n   gimple_stmt_iterator i;\n@@ -137,7 +137,7 @@ gimple_stmt_iterator gsi_start_edge (edge e);\n \n /* Return a new iterator initially pointing to GIMPLE_SEQ's last statement.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_last (gimple_seq &seq)\n {\n   gimple_stmt_iterator i;\n@@ -151,7 +151,7 @@ gsi_last (gimple_seq &seq)\n \n /* Return a new iterator pointing to the last statement in basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_last_bb (basic_block bb)\n {\n   gimple_stmt_iterator i;\n@@ -167,31 +167,31 @@ gsi_last_bb (basic_block bb)\n \n /* Return true if I is at the end of its sequence.  */\n \n-static inline bool\n+inline bool\n gsi_end_p (gimple_stmt_iterator i)\n {\n   return i.ptr == NULL;\n }\n \n /* Return true if I is one statement before the end of its sequence.  */\n \n-static inline bool\n+inline bool\n gsi_one_before_end_p (gimple_stmt_iterator i)\n {\n   return i.ptr != NULL && i.ptr->next == NULL;\n }\n \n /* Advance the iterator to the next gimple statement.  */\n \n-static inline void\n+inline void\n gsi_next (gimple_stmt_iterator *i)\n {\n   i->ptr = i->ptr->next;\n }\n \n /* Advance the iterator to the previous gimple statement.  */\n \n-static inline void\n+inline void\n gsi_prev (gimple_stmt_iterator *i)\n {\n   gimple *prev = i->ptr->prev;\n@@ -203,7 +203,7 @@ gsi_prev (gimple_stmt_iterator *i)\n \n /* Return the current stmt.  */\n \n-static inline gimple *\n+inline gimple *\n gsi_stmt (gimple_stmt_iterator i)\n {\n   return i.ptr;\n@@ -212,7 +212,7 @@ gsi_stmt (gimple_stmt_iterator i)\n /* Return a block statement iterator that points to the first\n    non-label statement in block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_after_labels (basic_block bb)\n {\n   gimple_stmt_iterator gsi = gsi_start_bb (bb);\n@@ -231,7 +231,7 @@ gsi_after_labels (basic_block bb)\n /* Return a statement iterator that points to the first\n    non-label statement in sequence SEQ.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_after_labels (gimple_seq &seq)\n {\n   gimple_stmt_iterator gsi = gsi_start (seq);\n@@ -249,7 +249,7 @@ gsi_after_labels (gimple_seq &seq)\n \n /* Advance the iterator to the next non-debug gimple statement.  */\n \n-static inline void\n+inline void\n gsi_next_nondebug (gimple_stmt_iterator *i)\n {\n   do\n@@ -261,7 +261,7 @@ gsi_next_nondebug (gimple_stmt_iterator *i)\n \n /* Advance the iterator to the previous non-debug gimple statement.  */\n \n-static inline void\n+inline void\n gsi_prev_nondebug (gimple_stmt_iterator *i)\n {\n   do\n@@ -274,7 +274,7 @@ gsi_prev_nondebug (gimple_stmt_iterator *i)\n /* Return a new iterator pointing to the first non-debug statement in\n    SEQ.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start_nondebug (gimple_seq seq)\n {\n   gimple_stmt_iterator gsi = gsi_start (seq);\n@@ -287,7 +287,7 @@ gsi_start_nondebug (gimple_seq seq)\n /* Return a new iterator pointing to the first non-debug statement in\n    basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start_nondebug_bb (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_start_bb (bb);\n@@ -301,7 +301,7 @@ gsi_start_nondebug_bb (basic_block bb)\n /* Return a new iterator pointing to the first non-debug non-label statement in\n    basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_start_nondebug_after_labels_bb (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_after_labels (bb);\n@@ -315,7 +315,7 @@ gsi_start_nondebug_after_labels_bb (basic_block bb)\n /* Return a new iterator pointing to the last non-debug statement in\n    basic block BB.  */\n \n-static inline gimple_stmt_iterator\n+inline gimple_stmt_iterator\n gsi_last_nondebug_bb (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_last_bb (bb);\n@@ -329,7 +329,7 @@ gsi_last_nondebug_bb (basic_block bb)\n /* Return true if I is followed only by debug statements in its\n    sequence.  */\n \n-static inline bool\n+inline bool\n gsi_one_nondebug_before_end_p (gimple_stmt_iterator i)\n {\n   if (gsi_one_before_end_p (i))\n@@ -343,7 +343,7 @@ gsi_one_nondebug_before_end_p (gimple_stmt_iterator i)\n /* Advance I statement iterator to the next non-virtual GIMPLE_PHI\n    statement.  */\n \n-static inline void\n+inline void\n gsi_next_nonvirtual_phi (gphi_iterator *i)\n {\n   do\n@@ -356,7 +356,7 @@ gsi_next_nonvirtual_phi (gphi_iterator *i)\n /* Return a new iterator pointing to the first non-virtual phi statement in\n    basic block BB.  */\n \n-static inline gphi_iterator\n+inline gphi_iterator\n gsi_start_nonvirtual_phis (basic_block bb)\n {\n   gphi_iterator i = gsi_start_phis (bb);\n@@ -369,23 +369,23 @@ gsi_start_nonvirtual_phis (basic_block bb)\n \n /* Return the basic block associated with this iterator.  */\n \n-static inline basic_block\n+inline basic_block\n gsi_bb (gimple_stmt_iterator i)\n {\n   return i.bb;\n }\n \n /* Return the sequence associated with this iterator.  */\n \n-static inline gimple_seq\n+inline gimple_seq\n gsi_seq (gimple_stmt_iterator i)\n {\n   return *i.seq;\n }\n \n /* Determine whether SEQ is a nondebug singleton.  */\n \n-static inline bool\n+inline bool\n gimple_seq_nondebug_singleton_p (gimple_seq seq)\n {\n   gimple_stmt_iterator gsi;"}, {"sha": "6c085a93ea7f823ba36f7acf23b5065fc165694e", "filename": "gcc/gimple-predict.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-predict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-predict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predict.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Return the predictor of GIMPLE_PREDICT statement GS.  */\n \n-static inline enum br_predictor\n+inline enum br_predictor\n gimple_predict_predictor (const gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n@@ -35,7 +35,7 @@ gimple_predict_predictor (const gimple *gs)\n \n /* Set the predictor of GIMPLE_PREDICT statement GS to PREDICT.  */\n \n-static inline void\n+inline void\n gimple_predict_set_predictor (gimple *gs, enum br_predictor predictor)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n@@ -46,7 +46,7 @@ gimple_predict_set_predictor (gimple *gs, enum br_predictor predictor)\n \n /* Return the outcome of GIMPLE_PREDICT statement GS.  */\n \n-static inline enum prediction\n+inline enum prediction\n gimple_predict_outcome (const gimple *gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n@@ -56,7 +56,7 @@ gimple_predict_outcome (const gimple *gs)\n \n /* Set the outcome of GIMPLE_PREDICT statement GS to OUTCOME.  */\n \n-static inline void\n+inline void\n gimple_predict_set_outcome (gimple *gs, enum prediction outcome)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PREDICT);\n@@ -82,7 +82,7 @@ gimple_build_predict (enum br_predictor predictor, enum prediction outcome)\n \n /* Return true if GS is a GIMPLE_PREDICT statement.  */\n \n-static inline bool\n+inline bool\n is_gimple_predict (const gimple *gs)\n {\n   return gimple_code (gs) == GIMPLE_PREDICT;"}, {"sha": "10b5c18b858c232b241d03707c742fb048407468", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -44,7 +44,7 @@ bool fold_range (vrange &r, gimple *s, unsigned num_elements, vrange **vector);\n // Return the type of range which statement S calculates.  If the type is\n // unsupported or no type can be determined, return NULL_TREE.\n \n-static inline tree\n+inline tree\n gimple_range_type (const gimple *s)\n {\n   tree lhs = gimple_get_lhs (s);\n@@ -73,7 +73,7 @@ gimple_range_type (const gimple *s)\n \n // Return EXP if it is an SSA_NAME with a type supported by gimple ranges.\n \n-static inline tree\n+inline tree\n gimple_range_ssa_p (tree exp)\n {\n   if (exp && TREE_CODE (exp) == SSA_NAME &&\n@@ -86,7 +86,7 @@ gimple_range_ssa_p (tree exp)\n \n // Return true if TYPE1 and TYPE2 are compatible range types.\n \n-static inline bool\n+inline bool\n range_compatible_p (tree type1, tree type2)\n {\n   // types_compatible_p requires conversion in both directions to be useless."}, {"sha": "604af8b96b7b9e3791ff438f0f1fa612d4e723af", "filename": "gcc/gimple-ssa.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -119,14 +119,14 @@ struct GTY(()) gimple_df {\n    gimple_in_ssa_p is queried by gimplifier in various early stages before SSA\n    infrastructure is initialized.  Check for presence of the datastructures\n    at first place.  */\n-static inline bool\n+inline bool\n gimple_in_ssa_p (const struct function *fun)\n {\n   return fun && fun->gimple_df && fun->gimple_df->in_ssa_p;\n }\n \n /* Artificial variable used for the virtual operand FUD chain.  */\n-static inline tree\n+inline tree\n gimple_vop (const struct function *fun)\n {\n   gcc_checking_assert (fun && fun->gimple_df);\n@@ -135,7 +135,7 @@ gimple_vop (const struct function *fun)\n \n /* Return the set of VUSE operand for statement G.  */\n \n-static inline use_operand_p\n+inline use_operand_p\n gimple_vuse_op (const gimple *g)\n {\n   struct use_optype_d *ops;\n@@ -152,7 +152,7 @@ gimple_vuse_op (const gimple *g)\n \n /* Return the set of VDEF operand for statement G.  */\n \n-static inline def_operand_p\n+inline def_operand_p\n gimple_vdef_op (gimple *g)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n@@ -166,7 +166,7 @@ gimple_vdef_op (gimple *g)\n \n /* Mark statement S as modified, and update it.  */\n \n-static inline void\n+inline void\n update_stmt (gimple *s)\n {\n   if (gimple_has_ops (s))\n@@ -178,7 +178,7 @@ update_stmt (gimple *s)\n \n /* Update statement S if it has been optimized.  */\n \n-static inline void\n+inline void\n update_stmt_if_modified (gimple *s)\n {\n   if (gimple_modified_p (s))\n@@ -187,7 +187,7 @@ update_stmt_if_modified (gimple *s)\n \n /* Mark statement S as modified, and update it.  */\n \n-static inline void\n+inline void\n update_stmt_fn (struct function *fn, gimple *s)\n {\n   if (gimple_has_ops (s))"}, {"sha": "081d18e425aabd123ac8258a9900e3725f12185d", "filename": "gcc/gimple.h", "status": "modified", "additions": 513, "deletions": 513, "changes": 1026, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=cb3e0eac262e55774949b1717c64da383adbc621"}, {"sha": "dc6e482fce31b31c804e8180108b02a15dadfa56", "filename": "gcc/graphite.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -32,7 +32,7 @@ typedef struct scop *scop_p;\n \n typedef unsigned graphite_dim_t;\n \n-static inline graphite_dim_t scop_nb_params (scop_p);\n+inline graphite_dim_t scop_nb_params (scop_p);\n \n /* A data reference can write or read some memory or we\n    just know it may write some memory.  */\n@@ -189,23 +189,23 @@ void new_poly_dr (poly_bb_p, gimple *, enum poly_dr_type,\n void debug_pdr (poly_dr_p);\n void print_pdr (FILE *, poly_dr_p);\n \n-static inline bool\n+inline bool\n pdr_read_p (poly_dr_p pdr)\n {\n   return PDR_TYPE (pdr) == PDR_READ;\n }\n \n /* Returns true when PDR is a \"write\".  */\n \n-static inline bool\n+inline bool\n pdr_write_p (poly_dr_p pdr)\n {\n   return PDR_TYPE (pdr) == PDR_WRITE;\n }\n \n /* Returns true when PDR is a \"may write\".  */\n \n-static inline bool\n+inline bool\n pdr_may_write_p (poly_dr_p pdr)\n {\n   return PDR_TYPE (pdr) == PDR_MAY_WRITE;\n@@ -295,37 +295,37 @@ extern void debug_schedule_ast (__isl_keep isl_schedule *, scop_p);\n \n /* The basic block of the PBB.  */\n \n-static inline basic_block\n+inline basic_block\n pbb_bb (poly_bb_p pbb)\n {\n   return GBB_BB (PBB_BLACK_BOX (pbb));\n }\n \n-static inline int\n+inline int\n pbb_index (poly_bb_p pbb)\n {\n   return pbb_bb (pbb)->index;\n }\n \n /* The loop of the PBB.  */\n \n-static inline loop_p\n+inline loop_p\n pbb_loop (poly_bb_p pbb)\n {\n   return gbb_loop (PBB_BLACK_BOX (pbb));\n }\n \n /* The scop that contains the PDR.  */\n \n-static inline scop_p\n+inline scop_p\n pdr_scop (poly_dr_p pdr)\n {\n   return PBB_SCOP (PDR_PBB (pdr));\n }\n \n /* Set black box of PBB to BLACKBOX.  */\n \n-static inline void\n+inline void\n pbb_set_black_box (poly_bb_p pbb, gimple_poly_bb_p black_box)\n {\n   pbb->black_box = black_box;\n@@ -412,23 +412,23 @@ extern bool apply_poly_transforms (scop_p);\n \n /* Set the region of SCOP to REGION.  */\n \n-static inline void\n+inline void\n scop_set_region (scop_p scop, sese_info_p region)\n {\n   scop->scop_info = region;\n }\n \n /* Returns the number of parameters for SCOP.  */\n \n-static inline graphite_dim_t\n+inline graphite_dim_t\n scop_nb_params (scop_p scop)\n {\n   return scop->nb_params;\n }\n \n /* Set the number of params of SCOP to NB_PARAMS.  */\n \n-static inline void\n+inline void\n scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)\n {\n   scop->nb_params = nb_params;"}, {"sha": "b0bb9bce074229eb7845f54c8bb93cb6aee797c2", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -173,19 +173,19 @@ struct hard_reg_set_container\n #define CLEAR_HARD_REG_SET(TO) ((TO) = HARD_CONST (0))\n #define SET_HARD_REG_SET(TO) ((TO) = ~ HARD_CONST (0))\n \n-static inline bool\n+inline bool\n hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   return (x & ~y) == HARD_CONST (0);\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   return (x & y) != HARD_CONST (0);\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_empty_p (const_hard_reg_set x)\n {\n   return x == HARD_CONST (0);\n@@ -228,7 +228,7 @@ SET_HARD_REG_SET (HARD_REG_SET &set)\n     set.elts[i] = -1;\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   HARD_REG_ELT_TYPE bad = 0;\n@@ -237,7 +237,7 @@ hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n   return bad == 0;\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   HARD_REG_ELT_TYPE good = 0;\n@@ -246,7 +246,7 @@ hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n   return good != 0;\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_empty_p (const_hard_reg_set x)\n {\n   HARD_REG_ELT_TYPE bad = 0;\n@@ -279,7 +279,7 @@ struct hard_reg_set_iterator\n \n /* The implementation of the iterator functions is fully analogous to\n    the bitmap iterators.  */\n-static inline void\n+inline void\n hard_reg_set_iter_init (hard_reg_set_iterator *iter, const_hard_reg_set set,\n                         unsigned min, unsigned *regno)\n {\n@@ -302,7 +302,7 @@ hard_reg_set_iter_init (hard_reg_set_iterator *iter, const_hard_reg_set set,\n   *regno = min;\n }\n \n-static inline bool\n+inline bool\n hard_reg_set_iter_set (hard_reg_set_iterator *iter, unsigned *regno)\n {\n   while (1)\n@@ -337,7 +337,7 @@ hard_reg_set_iter_set (hard_reg_set_iterator *iter, unsigned *regno)\n     }\n }\n \n-static inline void\n+inline void\n hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)\n {\n   iter->bits >>= 1;"}, {"sha": "1c5189b04d5195b8e1496bf71df5e7cce0e83569", "filename": "gcc/hash-map.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -315,29 +315,29 @@ class GTY((user)) hash_map\n /* ggc marking routines.  */\n \n template<typename K, typename V, typename H>\n-static inline void\n+inline void\n gt_ggc_mx (hash_map<K, V, H> *h)\n {\n   gt_ggc_mx (&h->m_table);\n }\n \n template<typename K, typename V, typename H>\n-static inline void\n+inline void\n gt_pch_nx (hash_map<K, V, H> *h)\n {\n   gt_pch_nx (&h->m_table);\n }\n \n template<typename K, typename V, typename H>\n-static inline void\n+inline void\n gt_cleare_cache (hash_map<K, V, H> *h)\n {\n   if (h)\n     gt_cleare_cache (&h->m_table);\n }\n \n template<typename K, typename V, typename H>\n-static inline void\n+inline void\n gt_pch_nx (hash_map<K, V, H> *h, gt_pointer_operator op, void *cookie)\n {\n   op (&h->m_table.m_entries, NULL, cookie);"}, {"sha": "f6125eb6a3a0b3af41eeb98bbd0f0039cb06600b", "filename": "gcc/hash-set.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -194,21 +194,21 @@ debug_helper (hash_set<T> &ref)\n /* ggc marking routines.  */\n \n template<typename K, typename H>\n-static inline void\n+inline void\n gt_ggc_mx (hash_set<K, false, H> *h)\n {\n   gt_ggc_mx (&h->m_table);\n }\n \n template<typename K, typename H>\n-static inline void\n+inline void\n gt_pch_nx (hash_set<K, false, H> *h)\n {\n   gt_pch_nx (&h->m_table);\n }\n \n template<typename K, typename H>\n-static inline void\n+inline void\n gt_pch_nx (hash_set<K, false, H> *h, gt_pointer_operator op, void *cookie)\n {\n   op (&h->m_table.m_entries, NULL, cookie);"}, {"sha": "3f87ec06f37a7264e2d46730586c484b2c3b3160", "filename": "gcc/hash-table.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -1236,7 +1236,7 @@ hash_table<Descriptor, Lazy, Allocator>::iterator::operator ++ ()\n /* ggc walking routines.  */\n \n template<typename E>\n-static inline void\n+inline void\n gt_ggc_mx (hash_table<E> *h)\n {\n   typedef hash_table<E> table;\n@@ -1257,7 +1257,7 @@ gt_ggc_mx (hash_table<E> *h)\n }\n \n template<typename D>\n-static inline void\n+inline void\n hashtab_entry_note_pointers (void *obj, void *h, gt_pointer_operator op,\n \t\t\t     void *cookie)\n {\n@@ -1293,7 +1293,7 @@ gt_pch_nx (hash_table<D> *h)\n }\n \n template<typename D>\n-static inline void\n+inline void\n gt_pch_nx (hash_table<D> *h, gt_pointer_operator op, void *cookie)\n {\n   op (&h->m_entries, NULL, cookie);"}, {"sha": "427e9b9e9fda7fe93431c3427f6c04aac4af02af", "filename": "gcc/hwint.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -138,23 +138,23 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n \n /* Return X with all but the lowest bit masked off.  */\n \n-static inline unsigned HOST_WIDE_INT\n+inline unsigned HOST_WIDE_INT\n least_bit_hwi (unsigned HOST_WIDE_INT x)\n {\n   return (x & -x);\n }\n \n /* True if X is zero or a power of two.  */\n \n-static inline bool\n+inline bool\n pow2_or_zerop (unsigned HOST_WIDE_INT x)\n {\n   return least_bit_hwi (x) == x;\n }\n \n /* True if X is a power of two.  */\n \n-static inline bool\n+inline bool\n pow2p_hwi (unsigned HOST_WIDE_INT x)\n {\n   return x && pow2_or_zerop (x);\n@@ -181,7 +181,7 @@ extern int ceil_log2\t\t\t(unsigned HOST_WIDE_INT);\n #else /* GCC_VERSION >= 3004 */\n \n /* For convenience, define 0 -> word_size.  */\n-static inline int\n+inline int\n clz_hwi (unsigned HOST_WIDE_INT x)\n {\n   if (x == 0)\n@@ -195,7 +195,7 @@ clz_hwi (unsigned HOST_WIDE_INT x)\n # endif\n }\n \n-static inline int\n+inline int\n ctz_hwi (unsigned HOST_WIDE_INT x)\n {\n   if (x == 0)\n@@ -209,7 +209,7 @@ ctz_hwi (unsigned HOST_WIDE_INT x)\n # endif\n }\n \n-static inline int\n+inline int\n ffs_hwi (unsigned HOST_WIDE_INT x)\n {\n # if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n@@ -221,7 +221,7 @@ ffs_hwi (unsigned HOST_WIDE_INT x)\n # endif\n }\n \n-static inline int\n+inline int\n popcount_hwi (unsigned HOST_WIDE_INT x)\n {\n # if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n@@ -233,19 +233,19 @@ popcount_hwi (unsigned HOST_WIDE_INT x)\n # endif\n }\n \n-static inline int\n+inline int\n floor_log2 (unsigned HOST_WIDE_INT x)\n {\n   return HOST_BITS_PER_WIDE_INT - 1 - clz_hwi (x);\n }\n \n-static inline int\n+inline int\n ceil_log2 (unsigned HOST_WIDE_INT x)\n {\n   return x == 0 ? 0 : floor_log2 (x - 1) + 1;\n }\n \n-static inline int\n+inline int\n exact_log2 (unsigned HOST_WIDE_INT x)\n {\n   return pow2p_hwi (x) ? ctz_hwi (x) : -1;\n@@ -266,15 +266,15 @@ extern HOST_WIDE_INT least_common_multiple (HOST_WIDE_INT, HOST_WIDE_INT);\n \n /* Like ctz_hwi, except 0 when x == 0.  */\n \n-static inline int\n+inline int\n ctz_or_zero (unsigned HOST_WIDE_INT x)\n {\n   return ffs_hwi (x) - 1;\n }\n \n /* Sign extend SRC starting from PREC.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n sext_hwi (HOST_WIDE_INT src, unsigned int prec)\n {\n   if (prec == HOST_BITS_PER_WIDE_INT)\n@@ -304,7 +304,7 @@ sext_hwi (HOST_WIDE_INT src, unsigned int prec)\n }\n \n /* Zero extend SRC starting from PREC.  */\n-static inline unsigned HOST_WIDE_INT\n+inline unsigned HOST_WIDE_INT\n zext_hwi (unsigned HOST_WIDE_INT src, unsigned int prec)\n {\n   if (prec == HOST_BITS_PER_WIDE_INT)"}, {"sha": "9d68648bb3c54df6ca5d91afa231351ad5780e4e", "filename": "gcc/input.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -195,7 +195,7 @@ extern int get_discriminator_from_loc (location_t);\n    that is part of a macro replacement-list defined in a system\n    header, but expanded in a non-system file.  */\n \n-static inline int\n+inline int\n in_system_header_at (location_t loc)\n {\n   return linemap_location_in_system_header_p (line_table, loc);\n@@ -204,7 +204,7 @@ in_system_header_at (location_t loc)\n /* Return true if LOCATION is the locus of a token that\n    comes from a macro expansion, false otherwise.  */\n \n-static inline bool\n+inline bool\n from_macro_expansion_at (location_t loc)\n {\n   return linemap_location_from_macro_expansion_p (line_table, loc);\n@@ -214,29 +214,29 @@ from_macro_expansion_at (location_t loc)\n    a macro definition, false otherwise.  This differs from from_macro_expansion_at\n    in its treatment of macro arguments, for which this returns false.  */\n \n-static inline bool\n+inline bool\n from_macro_definition_at (location_t loc)\n {\n   return linemap_location_from_macro_definition_p (line_table, loc);\n }\n \n-static inline location_t\n+inline location_t\n get_pure_location (location_t loc)\n {\n   return get_pure_location (line_table, loc);\n }\n \n /* Get the start of any range encoded within location LOC.  */\n \n-static inline location_t\n+inline location_t\n get_start (location_t loc)\n {\n   return get_range_from_loc (line_table, loc).m_start;\n }\n \n /* Get the endpoint of any range encoded within location LOC.  */\n \n-static inline location_t\n+inline location_t\n get_finish (location_t loc)\n {\n   return get_range_from_loc (line_table, loc).m_finish;"}, {"sha": "baf4d995e224f0a20ea1dfb2ed5a42ec498e6b36", "filename": "gcc/insn-addr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Finsn-addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Finsn-addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-addr.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -37,7 +37,7 @@ extern int insn_current_address;\n #define INSN_ADDRESSES_SET_P() (insn_addresses_.exists ())\n #define INSN_ADDRESSES_SIZE() (insn_addresses_.length ())\n \n-static inline void\n+inline void\n insn_addresses_new (rtx_insn *insn, int insn_addr)\n {\n   unsigned insn_uid = INSN_UID ((insn));"}, {"sha": "2fd82a19d158854b64ec872c63b2dc11c82010b2", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -105,7 +105,7 @@ extern void init_internal_fns ();\n \n extern const char *const internal_fn_name_array[];\n \n-static inline const char *\n+inline const char *\n internal_fn_name (enum internal_fn fn)\n {\n   return internal_fn_name_array[(int) fn];\n@@ -117,7 +117,7 @@ extern internal_fn lookup_internal_fn (const char *);\n \n extern const int internal_fn_flags_array[];\n \n-static inline int\n+inline int\n internal_fn_flags (enum internal_fn fn)\n {\n   return internal_fn_flags_array[(int) fn];\n@@ -127,7 +127,7 @@ internal_fn_flags (enum internal_fn fn)\n \n extern GTY(()) const_tree internal_fn_fnspec_array[IFN_LAST + 1];\n \n-static inline const_tree\n+inline const_tree\n internal_fn_fnspec (enum internal_fn fn)\n {\n   return internal_fn_fnspec_array[(int) fn];"}, {"sha": "fcc01167d0d2889b945e8644d86c582f1cac3fce", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -435,7 +435,7 @@ void ipa_remove_from_growth_caches (struct cgraph_edge *edge);\n \n /* Return true if EDGE is a cross module call.  */\n \n-static inline bool\n+inline bool\n cross_module_call_p (struct cgraph_edge *edge)\n {\n   /* Here we do not want to walk to alias target becuase ICF may create"}, {"sha": "1ad6421a5baa151aeb1b060585efdce361a0fe1e", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Logs a MESSAGE to dump_file if exists and returns false. FUNC is name\n    of function and LINE is location in the source file.  */\n \n-static inline bool\n+inline bool\n return_false_with_message_1 (const char *message, const char *filename,\n \t\t\t     const char *func, unsigned int line)\n {\n@@ -59,7 +59,7 @@ return_false_with_message_1 (const char *message, const char *filename,\n /* Logs return value if RESULT is false. FUNC is name of function and LINE\n    is location in the source file.  */\n \n-static inline bool\n+inline bool\n return_with_result (bool result, const char *filename,\n \t\t    const char *func, unsigned int line)\n {\n@@ -77,7 +77,7 @@ return_with_result (bool result, const char *filename,\n /* Verbose logging function logging statements S1 and S2 of a CODE.\n    FUNC is name of function and LINE is location in the source file.  */\n \n-static inline bool\n+inline bool\n return_different_stmts_1 (gimple *s1, gimple *s2, const char *code,\n \t\t\t  const char *func, unsigned int line)\n {"}, {"sha": "70de89a8b5a18813c44246789300709293ab25ae", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -69,7 +69,7 @@ extern function_summary <tree *> *ipa_saved_clone_sources;\n \n /* Return estimated size of the inline sequence of EDGE.  */\n \n-static inline int\n+inline int\n estimate_edge_size (struct cgraph_edge *edge)\n {\n   edge_growth_cache_entry *entry;\n@@ -82,7 +82,7 @@ estimate_edge_size (struct cgraph_edge *edge)\n \n /* Return lower bound on estimated callee growth after inlining EDGE.  */\n \n-static inline int\n+inline int\n estimate_min_edge_growth (struct cgraph_edge *edge)\n {\n   ipa_call_summary *s = ipa_call_summaries->get (edge);\n@@ -92,7 +92,7 @@ estimate_min_edge_growth (struct cgraph_edge *edge)\n \n /* Return estimated callee growth after inlining EDGE.  */\n \n-static inline int\n+inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n   ipa_call_summary *s = ipa_call_summaries->get (edge);\n@@ -103,7 +103,7 @@ estimate_edge_growth (struct cgraph_edge *edge)\n /* Return estimated callee runtime increase after inlining\n    EDGE.  */\n \n-static inline sreal\n+inline sreal\n estimate_edge_time (struct cgraph_edge *edge, sreal *nonspec_time = NULL)\n {\n   edge_growth_cache_entry *entry;\n@@ -120,7 +120,7 @@ estimate_edge_time (struct cgraph_edge *edge, sreal *nonspec_time = NULL)\n /* Return estimated callee runtime increase after inlining\n    EDGE.  */\n \n-static inline ipa_hints\n+inline ipa_hints\n estimate_edge_hints (struct cgraph_edge *edge)\n {\n   edge_growth_cache_entry *entry;"}, {"sha": "2a2d31e86dbeb87934ef0f9b3cd81620a2ea26fa", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -108,7 +108,7 @@ static const int implicit_retslot_eaf_flags\n    MODREF_FLAGS are flags determined by analysis of function body while\n    FLAGS are flags known otherwise (i.e. by fnspec, pure/const attributes\n    etc.)  */\n-static inline int\n+inline int\n interposable_eaf_flags (int modref_flags, int flags)\n {\n   /* If parameter was previously unused, we know it is only read"}, {"sha": "a40ccc0ebbe84bb6d1603acbc84c7bbc34e1b91f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -348,14 +348,14 @@ struct GTY (()) ipa_jump_func\n \n /* Return the constant stored in a constant jump functin JFUNC.  */\n \n-static inline tree\n+inline tree\n ipa_get_jf_constant (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n   return jfunc->value.constant.value;\n }\n \n-static inline struct ipa_cst_ref_desc *\n+inline struct ipa_cst_ref_desc *\n ipa_get_jf_constant_rdesc (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n@@ -364,7 +364,7 @@ ipa_get_jf_constant_rdesc (struct ipa_jump_func *jfunc)\n \n /* Return the operand of a pass through jmp function JFUNC.  */\n \n-static inline tree\n+inline tree\n ipa_get_jf_pass_through_operand (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -374,7 +374,7 @@ ipa_get_jf_pass_through_operand (struct ipa_jump_func *jfunc)\n /* Return the number of the caller's formal parameter that a pass through jump\n    function JFUNC refers to.  */\n \n-static inline int\n+inline int\n ipa_get_jf_pass_through_formal_id (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -383,7 +383,7 @@ ipa_get_jf_pass_through_formal_id (struct ipa_jump_func *jfunc)\n \n /* Return operation of a pass through jump function JFUNC.  */\n \n-static inline enum tree_code\n+inline enum tree_code\n ipa_get_jf_pass_through_operation (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -392,7 +392,7 @@ ipa_get_jf_pass_through_operation (struct ipa_jump_func *jfunc)\n \n /* Return the agg_preserved flag of a pass through jump function JFUNC.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -402,7 +402,7 @@ ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n /* Return true if pass through jump function JFUNC preserves type\n    information.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_pass_through_type_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n@@ -411,7 +411,7 @@ ipa_get_jf_pass_through_type_preserved (struct ipa_jump_func *jfunc)\n \n /* Return the offset of an ancestor jump function JFUNC.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n ipa_get_jf_ancestor_offset (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -421,7 +421,7 @@ ipa_get_jf_ancestor_offset (struct ipa_jump_func *jfunc)\n /* Return the number of the caller's formal parameter that an ancestor jump\n    function JFUNC refers to.  */\n \n-static inline int\n+inline int\n ipa_get_jf_ancestor_formal_id (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -430,7 +430,7 @@ ipa_get_jf_ancestor_formal_id (struct ipa_jump_func *jfunc)\n \n /* Return the agg_preserved flag of an ancestor jump function JFUNC.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -439,7 +439,7 @@ ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)\n \n /* Return true if ancestor jump function JFUNC presrves type information.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -450,7 +450,7 @@ ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n    parameter for non-NULLness unless it does not matter because the offset is\n    zero anyway.  */\n \n-static inline bool\n+inline bool\n ipa_get_jf_ancestor_keep_null (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n@@ -701,7 +701,7 @@ struct ipa_func_body_info\n \n /* Return the number of formal parameters. */\n \n-static inline int\n+inline int\n ipa_get_param_count (class ipa_node_params *info)\n {\n   return vec_safe_length (info->descriptors);\n@@ -710,7 +710,7 @@ ipa_get_param_count (class ipa_node_params *info)\n /* Return the parameter declaration in DESCRIPTORS at index I and assert it is\n    indeed a PARM_DECL.  */\n \n-static inline tree\n+inline tree\n ipa_get_param (const vec<ipa_param_descriptor, va_gc> &descriptors, int i)\n {\n   tree t = descriptors[i].decl_or_type;\n@@ -723,7 +723,7 @@ ipa_get_param (const vec<ipa_param_descriptor, va_gc> &descriptors, int i)\n    using ipa_initialize_node_params.  This function should not be called in\n    WPA.  */\n \n-static inline tree\n+inline tree\n ipa_get_param (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -733,7 +733,7 @@ ipa_get_param (class ipa_node_params *info, int i)\n /* Return the type of Ith formal parameter of the function corresponding\n    to INFO if it is known or NULL if not.  */\n \n-static inline tree\n+inline tree\n ipa_get_type (class ipa_node_params *info, int i)\n {\n   if (vec_safe_length (info->descriptors) <= (unsigned) i)\n@@ -750,7 +750,7 @@ ipa_get_type (class ipa_node_params *info, int i)\n /* Return the move cost of Ith formal parameter of the function corresponding\n    to INFO.  */\n \n-static inline int\n+inline int\n ipa_get_param_move_cost (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -760,7 +760,7 @@ ipa_get_param_move_cost (class ipa_node_params *info, int i)\n /* Set the used flag corresponding to the Ith formal parameter of the function\n    associated with INFO to VAL.  */\n \n-static inline void\n+inline void\n ipa_set_param_used (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -770,7 +770,7 @@ ipa_set_param_used (class ipa_node_params *info, int i, bool val)\n /* Set the used_by_ipa_predicates flag corresponding to the Ith formal\n    parameter of the function associated with INFO to VAL.  */\n \n-static inline void\n+inline void\n ipa_set_param_used_by_ipa_predicates (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -780,7 +780,7 @@ ipa_set_param_used_by_ipa_predicates (class ipa_node_params *info, int i, bool v\n /* Set the used_by_indirect_call flag corresponding to the Ith formal\n    parameter of the function associated with INFO to VAL.  */\n \n-static inline void\n+inline void\n ipa_set_param_used_by_indirect_call (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -790,7 +790,7 @@ ipa_set_param_used_by_indirect_call (class ipa_node_params *info, int i, bool va\n /* Set the .used_by_polymorphic_call flag corresponding to the Ith formal\n    parameter of the function associated with INFO to VAL.  */\n \n-static inline void\n+inline void\n ipa_set_param_used_by_polymorphic_call (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -800,7 +800,7 @@ ipa_set_param_used_by_polymorphic_call (class ipa_node_params *info, int i, bool\n /* Return how many uses described by ipa-prop a parameter has or\n    IPA_UNDESCRIBED_USE if there is a use that is not described by these\n    structures.  */\n-static inline int\n+inline int\n ipa_get_controlled_uses (class ipa_node_params *info, int i)\n {\n   /* FIXME: introducing speculation causes out of bounds access here.  */\n@@ -811,7 +811,7 @@ ipa_get_controlled_uses (class ipa_node_params *info, int i)\n \n /* Set the controlled counter of a given parameter.  */\n \n-static inline void\n+inline void\n ipa_set_controlled_uses (class ipa_node_params *info, int i, int val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -820,7 +820,7 @@ ipa_set_controlled_uses (class ipa_node_params *info, int i, int val)\n \n /* Assuming a parameter does not have IPA_UNDESCRIBED_USE controlled uses,\n    return flag which indicates it has been dereferenced but only in a load.  */\n-static inline int\n+inline int\n ipa_get_param_load_dereferenced (class ipa_node_params *info, int i)\n {\n   gcc_assert (ipa_get_controlled_uses (info, i) != IPA_UNDESCRIBED_USE);\n@@ -829,7 +829,7 @@ ipa_get_param_load_dereferenced (class ipa_node_params *info, int i)\n \n /* Set the load_dereferenced flag of a given parameter.  */\n \n-static inline void\n+inline void\n ipa_set_param_load_dereferenced (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -839,7 +839,7 @@ ipa_set_param_load_dereferenced (class ipa_node_params *info, int i, bool val)\n /* Return the used flag corresponding to the Ith formal parameter of the\n    function associated with INFO.  */\n \n-static inline bool\n+inline bool\n ipa_is_param_used (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -849,7 +849,7 @@ ipa_is_param_used (class ipa_node_params *info, int i)\n /* Return the used_by_ipa_predicates flag corresponding to the Ith formal\n    parameter of the function associated with INFO.  */\n \n-static inline bool\n+inline bool\n ipa_is_param_used_by_ipa_predicates (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -859,7 +859,7 @@ ipa_is_param_used_by_ipa_predicates (class ipa_node_params *info, int i)\n /* Return the used_by_indirect_call flag corresponding to the Ith formal\n    parameter of the function associated with INFO.  */\n \n-static inline bool\n+inline bool\n ipa_is_param_used_by_indirect_call (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -869,7 +869,7 @@ ipa_is_param_used_by_indirect_call (class ipa_node_params *info, int i)\n /* Return the used_by_polymorphic_call flag corresponding to the Ith formal\n    parameter of the function associated with INFO.  */\n \n-static inline bool\n+inline bool\n ipa_is_param_used_by_polymorphic_call (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n@@ -944,7 +944,7 @@ class GTY((for_user)) ipa_edge_args\n \n /* Return the number of actual arguments. */\n \n-static inline int\n+inline int\n ipa_get_cs_argument_count (class ipa_edge_args *args)\n {\n   return vec_safe_length (args->jump_functions);\n@@ -954,15 +954,15 @@ ipa_get_cs_argument_count (class ipa_edge_args *args)\n    there is no setter function as jump functions are all set up in\n    ipa_compute_jump_functions. */\n \n-static inline struct ipa_jump_func *\n+inline struct ipa_jump_func *\n ipa_get_ith_jump_func (class ipa_edge_args *args, int i)\n {\n   return &(*args->jump_functions)[i];\n }\n \n /* Returns a pointer to the polymorphic call context for the ith argument.\n    NULL if contexts are not computed.  */\n-static inline class ipa_polymorphic_call_context *\n+inline class ipa_polymorphic_call_context *\n ipa_get_ith_polymorhic_call_context (class ipa_edge_args *args, int i)\n {\n   if (!args->polymorphic_call_contexts)\n@@ -1056,7 +1056,7 @@ int count_formal_params (tree fndecl);\n /* This function ensures the array of node param infos is big enough to\n    accommodate a structure for all nodes and reallocates it if not.  */\n \n-static inline void\n+inline void\n ipa_check_create_node_params (void)\n {\n   if (!ipa_node_params_sum)\n@@ -1069,13 +1069,13 @@ ipa_check_create_node_params (void)\n    of this function is that debug dumping function can check info availability\n    without causing allocations.  */\n \n-static inline bool\n+inline bool\n ipa_edge_args_info_available_for_edge_p (struct cgraph_edge *edge)\n {\n   return ipa_edge_args_sum->exists (edge);\n }\n \n-static inline ipcp_transformation *\n+inline ipcp_transformation *\n ipcp_get_transformation_summary (cgraph_node *node)\n {\n   if (ipcp_transformation_sum == NULL)"}, {"sha": "e2de47213b490e90a56f139dcea078341a8a8fae", "filename": "gcc/ira-int.h", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -504,7 +504,7 @@ struct ira_emit_data\n extern ira_emit_data_t ira_allocno_emit_data;\n \n /* Abbreviation for frequent emit data access.  */\n-static inline rtx\n+inline rtx\n allocno_emit_reg (ira_allocno_t a)\n {\n   return ALLOCNO_EMIT_DATA (a)->reg;\n@@ -734,7 +734,7 @@ struct minmax_set_iterator {\n \n /* Initialize the iterator I for bit vector VEC containing minimal and\n    maximal values MIN and MAX.  */\n-static inline void\n+inline void\n minmax_set_iter_init (minmax_set_iterator *i, IRA_INT_TYPE *vec, int min,\n \t\t      int max)\n {\n@@ -749,7 +749,7 @@ minmax_set_iter_init (minmax_set_iterator *i, IRA_INT_TYPE *vec, int min,\n /* Return TRUE if we have more allocnos to visit, in which case *N is\n    set to the number of the element to be visited.  Otherwise, return\n    FALSE.  */\n-static inline bool\n+inline bool\n minmax_set_iter_cond (minmax_set_iterator *i, int *n)\n {\n   /* Skip words that are zeros.  */\n@@ -774,7 +774,7 @@ minmax_set_iter_cond (minmax_set_iterator *i, int *n)\n }\n \n /* Advance to the next element in the set.  */\n-static inline void\n+inline void\n minmax_set_iter_next (minmax_set_iterator *i)\n {\n   i->word >>= 1;\n@@ -1084,7 +1084,7 @@ extern void ira_emit (bool);\n \f\n \n /* Return true if equivalence of pseudo REGNO is not a lvalue.  */\n-static inline bool\n+inline bool\n ira_equiv_no_lvalue_p (int regno)\n {\n   if (regno >= ira_reg_equiv_len)\n@@ -1098,7 +1098,7 @@ ira_equiv_no_lvalue_p (int regno)\n \f\n \n /* Initialize register costs for MODE if necessary.  */\n-static inline void\n+inline void\n ira_init_register_move_cost_if_necessary (machine_mode mode)\n {\n   if (ira_register_move_cost[mode] == NULL)\n@@ -1114,15 +1114,15 @@ struct ira_allocno_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_allocno_iter_init (ira_allocno_iterator *i)\n {\n   i->n = 0;\n }\n \n /* Return TRUE if we have more allocnos to visit, in which case *A is\n    set to the allocno to be visited.  Otherwise, return FALSE.  */\n-static inline bool\n+inline bool\n ira_allocno_iter_cond (ira_allocno_iterator *i, ira_allocno_t *a)\n {\n   int n;\n@@ -1151,15 +1151,15 @@ struct ira_object_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_object_iter_init (ira_object_iterator *i)\n {\n   i->n = 0;\n }\n \n /* Return TRUE if we have more objects to visit, in which case *OBJ is\n    set to the object to be visited.  Otherwise, return FALSE.  */\n-static inline bool\n+inline bool\n ira_object_iter_cond (ira_object_iterator *i, ira_object_t *obj)\n {\n   int n;\n@@ -1188,7 +1188,7 @@ struct ira_allocno_object_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_allocno_object_iter_init (ira_allocno_object_iterator *i)\n {\n   i->n = 0;\n@@ -1197,7 +1197,7 @@ ira_allocno_object_iter_init (ira_allocno_object_iterator *i)\n /* Return TRUE if we have more objects to visit in allocno A, in which\n    case *O is set to the object to be visited.  Otherwise, return\n    FALSE.  */\n-static inline bool\n+inline bool\n ira_allocno_object_iter_cond (ira_allocno_object_iterator *i, ira_allocno_t a,\n \t\t\t      ira_object_t *o)\n {\n@@ -1225,15 +1225,15 @@ struct ira_pref_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_pref_iter_init (ira_pref_iterator *i)\n {\n   i->n = 0;\n }\n \n /* Return TRUE if we have more prefs to visit, in which case *PREF is\n    set to the pref to be visited.  Otherwise, return FALSE.  */\n-static inline bool\n+inline bool\n ira_pref_iter_cond (ira_pref_iterator *i, ira_pref_t *pref)\n {\n   int n;\n@@ -1263,15 +1263,15 @@ struct ira_copy_iterator {\n };\n \n /* Initialize the iterator I.  */\n-static inline void\n+inline void\n ira_copy_iter_init (ira_copy_iterator *i)\n {\n   i->n = 0;\n }\n \n /* Return TRUE if we have more copies to visit, in which case *CP is\n    set to the copy to be visited.  Otherwise, return FALSE.  */\n-static inline bool\n+inline bool\n ira_copy_iter_cond (ira_copy_iterator *i, ira_copy_t *cp)\n {\n   int n;\n@@ -1324,7 +1324,7 @@ struct ira_object_conflict_iterator {\n };\n \n /* Initialize the iterator I with ALLOCNO conflicts.  */\n-static inline void\n+inline void\n ira_object_conflict_iter_init (ira_object_conflict_iterator *i,\n \t\t\t       ira_object_t obj)\n {\n@@ -1350,7 +1350,7 @@ ira_object_conflict_iter_init (ira_object_conflict_iterator *i,\n /* Return TRUE if we have more conflicting allocnos to visit, in which\n    case *A is set to the allocno to be visited.  Otherwise, return\n    FALSE.  */\n-static inline bool\n+inline bool\n ira_object_conflict_iter_cond (ira_object_conflict_iterator *i,\n \t\t\t       ira_object_t *pobj)\n {\n@@ -1405,7 +1405,7 @@ ira_object_conflict_iter_cond (ira_object_conflict_iterator *i,\n /* The function returns TRUE if at least one hard register from ones\n    starting with HARD_REGNO and containing value of MODE are in set\n    HARD_REGSET.  */\n-static inline bool\n+inline bool\n ira_hard_reg_set_intersection_p (int hard_regno, machine_mode mode,\n \t\t\t\t HARD_REG_SET hard_regset)\n {\n@@ -1419,7 +1419,7 @@ ira_hard_reg_set_intersection_p (int hard_regno, machine_mode mode,\n }\n \n /* Return number of hard registers in hard register SET.  */\n-static inline int\n+inline int\n hard_reg_set_size (HARD_REG_SET set)\n {\n   int i, size;\n@@ -1433,7 +1433,7 @@ hard_reg_set_size (HARD_REG_SET set)\n /* The function returns TRUE if hard registers starting with\n    HARD_REGNO and containing value of MODE are fully in set\n    HARD_REGSET.  */\n-static inline bool\n+inline bool\n ira_hard_reg_in_set_p (int hard_regno, machine_mode mode,\n \t\t       HARD_REG_SET hard_regset)\n {\n@@ -1454,7 +1454,7 @@ ira_hard_reg_in_set_p (int hard_regno, machine_mode mode,\n \n /* Allocate cost vector *VEC for hard registers of ACLASS and\n    initialize the elements by VAL if it is necessary */\n-static inline void\n+inline void\n ira_allocate_and_set_costs (int **vec, reg_class_t aclass, int val)\n {\n   int i, *reg_costs;\n@@ -1470,7 +1470,7 @@ ira_allocate_and_set_costs (int **vec, reg_class_t aclass, int val)\n \n /* Allocate cost vector *VEC for hard registers of ACLASS and copy\n    values of vector SRC into the vector if it is necessary */\n-static inline void\n+inline void\n ira_allocate_and_copy_costs (int **vec, enum reg_class aclass, int *src)\n {\n   int len;\n@@ -1484,7 +1484,7 @@ ira_allocate_and_copy_costs (int **vec, enum reg_class aclass, int *src)\n \n /* Allocate cost vector *VEC for hard registers of ACLASS and add\n    values of vector SRC into the vector if it is necessary */\n-static inline void\n+inline void\n ira_allocate_and_accumulate_costs (int **vec, enum reg_class aclass, int *src)\n {\n   int i, len;\n@@ -1504,7 +1504,7 @@ ira_allocate_and_accumulate_costs (int **vec, enum reg_class aclass, int *src)\n /* Allocate cost vector *VEC for hard registers of ACLASS and copy\n    values of vector SRC into the vector or initialize it by VAL (if\n    SRC is null).  */\n-static inline void\n+inline void\n ira_allocate_and_set_or_copy_costs (int **vec, enum reg_class aclass,\n \t\t\t\t    int val, int *src)\n {"}, {"sha": "9c48f94cec92d646bfa3b3db703167df31689e45", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -235,7 +235,7 @@ extern rtx non_conflicting_reg_copy_p (rtx_insn *);\n    non-local goto code using frame-pointer to address saved stack\n    pointer value after restoring old frame pointer value.  The\n    function returns TRUE if REGNO is such a static chain pseudo.  */\n-static inline bool\n+inline bool\n non_spilled_static_chain_regno_p (int regno)\n {\n   return (cfun->static_chain_decl && crtl->has_nonlocal_goto"}, {"sha": "bdf5785753701c7df9f8ca307c7ea6d225df883f", "filename": "gcc/jit/jit-dejagnu.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fjit%2Fjit-dejagnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fjit%2Fjit-dejagnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-dejagnu.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -66,7 +66,7 @@ dg_wait (void)\n }\n #endif\n \n-static inline void\n+inline void\n pass (const char* fmt, ...)\n {\n   va_list ap;\n@@ -81,7 +81,7 @@ pass (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n xpass (const char* fmt, ...)\n {\n   va_list ap;\n@@ -96,7 +96,7 @@ xpass (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n fail (const char* fmt, ...)\n {\n   va_list ap;\n@@ -111,7 +111,7 @@ fail (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n xfail (const char* fmt, ...)\n {\n   va_list ap;\n@@ -126,7 +126,7 @@ xfail (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n untested (const char* fmt, ...)\n {\n   va_list ap;\n@@ -141,7 +141,7 @@ untested (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n unresolved (const char* fmt, ...)\n {\n   va_list ap;\n@@ -156,7 +156,7 @@ unresolved (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n note (const char* fmt, ...)\n {\n   va_list ap;\n@@ -170,7 +170,7 @@ note (const char* fmt, ...)\n #endif\n }\n \n-static inline void\n+inline void\n totals (void)\n {\n   printf (\"\\nTotals:\\n\");"}, {"sha": "400cf34560035e74038428c9af7d5c3e0bd0d0cd", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -2556,7 +2556,7 @@ types_kinda_same_internal (recording::type *a,\n \n    For array and vector types the number of element also\n    has to match, aswell as the element types themself.  */\n-static inline bool\n+inline bool\n types_kinda_same (recording::type *a, recording::type *b)\n {\n   /* Handle trivial case here, to allow for inlining.  */"}, {"sha": "73f8eb004b02d1532b25fbbc1bcd99b2dbb6d437", "filename": "gcc/lra-int.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -419,7 +419,7 @@ extern void lra_eliminate_reg_if_possible (rtx *);\n /* Return the hard register which given pseudo REGNO assigned to.\n    Negative value means that the register got memory or we don't know\n    allocation yet.  */\n-static inline int\n+inline int\n lra_get_regno_hard_regno (int regno)\n {\n   resize_reg_info ();\n@@ -443,7 +443,7 @@ lra_change_class (int regno, enum reg_class new_class,\n \n /* Update insn operands which are duplication of NOP operand.  The\n    insn is represented by its LRA internal representation ID.  */\n-static inline void\n+inline void\n lra_update_dup (lra_insn_recog_data_t id, int nop)\n {\n   int i;\n@@ -458,7 +458,7 @@ lra_update_dup (lra_insn_recog_data_t id, int nop)\n    operands processing.\t Generally speaking, we could do this probably\n    simultaneously with operands processing because a common practice\n    is to enumerate the operators after their operands.\t*/\n-static inline void\n+inline void\n lra_update_operator_dups (lra_insn_recog_data_t id)\n {\n   int i;\n@@ -474,7 +474,7 @@ lra_update_operator_dups (lra_insn_recog_data_t id)\n }\n \n /* Return info about INSN.  Set up the info if it is not done yet.  */\n-static inline lra_insn_recog_data_t\n+inline lra_insn_recog_data_t\n lra_get_insn_recog_data (rtx_insn *insn)\n {\n   lra_insn_recog_data_t data;\n@@ -494,7 +494,7 @@ lra_get_insn_recog_data (rtx_insn *insn)\n }\n \n /* Update offset from pseudos with VAL by INCR.  */\n-static inline void\n+inline void\n lra_update_reg_val_offset (int val, poly_int64 incr)\n {\n   int i;\n@@ -507,7 +507,7 @@ lra_update_reg_val_offset (int val, poly_int64 incr)\n }\n \n /* Return true if register content is equal to VAL with OFFSET.  */\n-static inline bool\n+inline bool\n lra_reg_val_equal_p (int regno, int val, poly_int64 offset)\n {\n   if (lra_reg_info[regno].val == val\n@@ -518,7 +518,7 @@ lra_reg_val_equal_p (int regno, int val, poly_int64 offset)\n }\n \n /* Assign value of register FROM to TO.  */\n-static inline void\n+inline void\n lra_assign_reg_val (int from, int to)\n {\n   lra_reg_info[to].val = lra_reg_info[from].val;"}, {"sha": "85dbf92741494ae6fa861984b09e2470b33c9f5b", "filename": "gcc/lra.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Flra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Flra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -27,7 +27,7 @@ extern bool lra_simple_p;\n /* Return the allocno reg class of REGNO.  If it is a reload pseudo,\n    the pseudo should finally get hard register of the allocno\n    class.  */\n-static inline enum reg_class\n+inline enum reg_class\n lra_get_allocno_class (int regno)\n {\n   resize_reg_info ();"}, {"sha": "fc7133d07ba162e44efe0c0f259529319ba8b6f9", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -969,15 +969,15 @@ extern const char *lto_section_name[];\n extern vec<lto_out_decl_state_ptr> lto_function_decl_states;\n \n /* Return true if LTO tag TAG corresponds to a tree code.  */\n-static inline bool\n+inline bool\n lto_tag_is_tree_code_p (enum LTO_tags tag)\n {\n   return tag > LTO_first_tree_tag && (unsigned) tag <= MAX_TREE_CODES;\n }\n \n \n /* Return true if LTO tag TAG corresponds to a gimple code.  */\n-static inline bool\n+inline bool\n lto_tag_is_gimple_code_p (enum LTO_tags tag)\n {\n   return (unsigned) tag >= LTO_first_gimple_tag\n@@ -988,7 +988,7 @@ lto_tag_is_gimple_code_p (enum LTO_tags tag)\n \n /* Return the LTO tag corresponding to gimple code CODE.  See enum\n    LTO_tags for details on the conversion.  */\n-static inline enum LTO_tags\n+inline enum LTO_tags\n lto_gimple_code_to_tag (enum gimple_code code)\n {\n   return (enum LTO_tags) ((unsigned) code + LTO_first_gimple_tag);\n@@ -997,7 +997,7 @@ lto_gimple_code_to_tag (enum gimple_code code)\n \n /* Return the GIMPLE code corresponding to TAG.  See enum LTO_tags for\n    details on the conversion.  */\n-static inline enum gimple_code\n+inline enum gimple_code\n lto_tag_to_gimple_code (enum LTO_tags tag)\n {\n   gcc_assert (lto_tag_is_gimple_code_p (tag));\n@@ -1007,7 +1007,7 @@ lto_tag_to_gimple_code (enum LTO_tags tag)\n \n /* Return the LTO tag corresponding to tree code CODE.  See enum\n    LTO_tags for details on the conversion.  */\n-static inline enum LTO_tags\n+inline enum LTO_tags\n lto_tree_code_to_tag (enum tree_code code)\n {\n   return (enum LTO_tags) ((unsigned) code + LTO_first_tree_tag);\n@@ -1016,15 +1016,15 @@ lto_tree_code_to_tag (enum tree_code code)\n \n /* Return the tree code corresponding to TAG.  See enum LTO_tags for\n    details on the conversion.  */\n-static inline enum tree_code\n+inline enum tree_code\n lto_tag_to_tree_code (enum LTO_tags tag)\n {\n   gcc_assert (lto_tag_is_tree_code_p (tag));\n   return (enum tree_code) ((unsigned) tag - LTO_first_tree_tag);\n }\n \n /* Check that tag ACTUAL == EXPECTED.  */\n-static inline void\n+inline void\n lto_tag_check (enum LTO_tags actual, enum LTO_tags expected)\n {\n   if (actual != expected)\n@@ -1033,7 +1033,7 @@ lto_tag_check (enum LTO_tags actual, enum LTO_tags expected)\n }\n \n /* Check that tag ACTUAL is in the range [TAG1, TAG2].  */\n-static inline void\n+inline void\n lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n \t\t     enum LTO_tags tag2)\n {\n@@ -1046,7 +1046,7 @@ lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n }\n \n /* Initialize an lto_out_decl_buffer ENCODER.  */\n-static inline void\n+inline void\n lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n   encoder->tree_hash_table = new hash_map<tree, unsigned> (251);\n@@ -1056,7 +1056,7 @@ lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n \n /* Destroy an lto_tree_ref_encoder ENCODER by freeing its contents.  The\n    memory used by ENCODER is not freed by this function.  */\n-static inline void\n+inline void\n lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n   /* Hash table may be delete already.  */\n@@ -1066,22 +1066,22 @@ lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n }\n \n /* Return the number of trees encoded in ENCODER. */\n-static inline unsigned int\n+inline unsigned int\n lto_tree_ref_encoder_size (struct lto_tree_ref_encoder *encoder)\n {\n   return encoder->trees.length ();\n }\n \n /* Return the IDX-th tree in ENCODER. */\n-static inline tree\n+inline tree\n lto_tree_ref_encoder_get_tree (struct lto_tree_ref_encoder *encoder,\n \t\t\t       unsigned int idx)\n {\n   return encoder->trees[idx];\n }\n \n /* Return number of encoded nodes in ENCODER.  */\n-static inline int\n+inline int\n lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n {\n   return encoder->nodes.length ();\n@@ -1093,7 +1093,7 @@ lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n /* Look up NODE in encoder.  Return NODE's reference if it has been encoded\n    or LCC_NOT_FOUND if it is not there.  */\n \n-static inline int\n+inline int\n lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n \t\t\t   symtab_node *node)\n {\n@@ -1102,43 +1102,43 @@ lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n }\n \n /* Return true if iterator LSE points to nothing.  */\n-static inline bool\n+inline bool\n lsei_end_p (lto_symtab_encoder_iterator lsei)\n {\n   return lsei.index >= (unsigned)lto_symtab_encoder_size (lsei.encoder);\n }\n \n /* Advance iterator LSE.  */\n-static inline void\n+inline void\n lsei_next (lto_symtab_encoder_iterator *lsei)\n {\n   lsei->index++;\n }\n \n /* Return the node pointed to by LSI.  */\n-static inline symtab_node *\n+inline symtab_node *\n lsei_node (lto_symtab_encoder_iterator lsei)\n {\n   return lsei.encoder->nodes[lsei.index].node;\n }\n \n /* Return the node pointed to by LSI.  */\n-static inline struct cgraph_node *\n+inline struct cgraph_node *\n lsei_cgraph_node (lto_symtab_encoder_iterator lsei)\n {\n   return dyn_cast<cgraph_node *> (lsei.encoder->nodes[lsei.index].node);\n }\n \n /* Return the node pointed to by LSI.  */\n-static inline varpool_node *\n+inline varpool_node *\n lsei_varpool_node (lto_symtab_encoder_iterator lsei)\n {\n   return dyn_cast<varpool_node *> (lsei.encoder->nodes[lsei.index].node);\n }\n \n /* Return the cgraph node corresponding to REF using ENCODER.  */\n \n-static inline symtab_node *\n+inline symtab_node *\n lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n {\n   if (ref == LCC_NOT_FOUND)\n@@ -1148,7 +1148,7 @@ lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n }\n \n /* Return an iterator to the first node in LSI.  */\n-static inline lto_symtab_encoder_iterator\n+inline lto_symtab_encoder_iterator\n lsei_start (lto_symtab_encoder_t encoder)\n {\n   lto_symtab_encoder_iterator lsei;\n@@ -1159,7 +1159,7 @@ lsei_start (lto_symtab_encoder_t encoder)\n }\n \n /* Advance iterator LSE.  */\n-static inline void\n+inline void\n lsei_next_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n@@ -1169,7 +1169,7 @@ lsei_next_in_partition (lto_symtab_encoder_iterator *lsei)\n }\n \n /* Return an iterator to the first node in LSI.  */\n-static inline lto_symtab_encoder_iterator\n+inline lto_symtab_encoder_iterator\n lsei_start_in_partition (lto_symtab_encoder_t encoder)\n {\n   lto_symtab_encoder_iterator lsei = lsei_start (encoder);\n@@ -1183,7 +1183,7 @@ lsei_start_in_partition (lto_symtab_encoder_t encoder)\n }\n \n /* Advance iterator LSE.  */\n-static inline void\n+inline void\n lsei_next_function_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n@@ -1194,7 +1194,7 @@ lsei_next_function_in_partition (lto_symtab_encoder_iterator *lsei)\n }\n \n /* Return an iterator to the first node in LSI.  */\n-static inline lto_symtab_encoder_iterator\n+inline lto_symtab_encoder_iterator\n lsei_start_function_in_partition (lto_symtab_encoder_t encoder)\n {\n   lto_symtab_encoder_iterator lsei = lsei_start (encoder);\n@@ -1209,7 +1209,7 @@ lsei_start_function_in_partition (lto_symtab_encoder_t encoder)\n }\n \n /* Advance iterator LSE.  */\n-static inline void\n+inline void\n lsei_next_variable_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n@@ -1220,7 +1220,7 @@ lsei_next_variable_in_partition (lto_symtab_encoder_iterator *lsei)\n }\n \n /* Return an iterator to the first node in LSI.  */\n-static inline lto_symtab_encoder_iterator\n+inline lto_symtab_encoder_iterator\n lsei_start_variable_in_partition (lto_symtab_encoder_t encoder)\n {\n   lto_symtab_encoder_iterator lsei = lsei_start (encoder);"}, {"sha": "7dfad2fb6b1ab27f456d30ed7f3238b338c9318e", "filename": "gcc/memmodel.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fmemmodel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fmemmodel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmemmodel.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -51,63 +51,63 @@ enum memmodel\n };\n \n /* Return the memory model from a host integer.  */\n-static inline enum memmodel\n+inline enum memmodel\n memmodel_from_int (unsigned HOST_WIDE_INT val)\n {\n   return (enum memmodel) (val & MEMMODEL_MASK);\n }\n \n /* Return the base memory model from a host integer.  */\n-static inline enum memmodel\n+inline enum memmodel\n memmodel_base (unsigned HOST_WIDE_INT val)\n {\n   return (enum memmodel) (val & MEMMODEL_BASE_MASK);\n }\n \n /* Return TRUE if the memory model is RELAXED.  */\n-static inline bool\n+inline bool\n is_mm_relaxed (enum memmodel model)\n {\n   return (model & MEMMODEL_BASE_MASK) == MEMMODEL_RELAXED;\n }\n \n /* Return TRUE if the memory model is CONSUME.  */\n-static inline bool\n+inline bool\n is_mm_consume (enum memmodel model)\n {\n   return (model & MEMMODEL_BASE_MASK) == MEMMODEL_CONSUME;\n }\n \n /* Return TRUE if the memory model is ACQUIRE.  */\n-static inline bool\n+inline bool\n is_mm_acquire (enum memmodel model)\n {\n   return (model & MEMMODEL_BASE_MASK) == MEMMODEL_ACQUIRE;\n }\n \n /* Return TRUE if the memory model is RELEASE.  */\n-static inline bool\n+inline bool\n is_mm_release (enum memmodel model)\n {\n   return (model & MEMMODEL_BASE_MASK) == MEMMODEL_RELEASE;\n }\n \n /* Return TRUE if the memory model is ACQ_REL.  */\n-static inline bool\n+inline bool\n is_mm_acq_rel (enum memmodel model)\n {\n   return (model & MEMMODEL_BASE_MASK) == MEMMODEL_ACQ_REL;\n }\n \n /* Return TRUE if the memory model is SEQ_CST.  */\n-static inline bool\n+inline bool\n is_mm_seq_cst (enum memmodel model)\n {\n   return (model & MEMMODEL_BASE_MASK) == MEMMODEL_SEQ_CST;\n }\n \n /* Return TRUE if the memory model is a SYNC variant.  */\n-static inline bool\n+inline bool\n is_mm_sync (enum memmodel model)\n {\n   return (model & MEMMODEL_SYNC);"}, {"sha": "08201749207951eb22ad6ec1fa670949f3227806", "filename": "gcc/objc/objc-act.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fobjc%2Fobjc-act.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fobjc%2Fobjc-act.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.cc?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -117,7 +117,6 @@ static tree build_method_decl (enum tree_code, tree, tree, tree, bool);\n static tree objc_add_method (tree, tree, int, bool);\n static tree add_instance_variable (tree, objc_ivar_visibility_kind, tree);\n static tree build_ivar_reference (tree);\n-static tree is_ivar (tree, tree);\n \n /* We only need the following for ObjC; ObjC++ will use C++'s definition\n    of DERIVED_FROM_P.  */\n@@ -169,7 +168,6 @@ static tree lookup_method_static (tree, tree, int);\n static void interface_hash_init (void);\n static tree add_interface (tree, tree);\n static void add_category (tree, tree);\n-static inline tree lookup_category (tree, tree);\n \n /* Protocols.  */\n "}, {"sha": "e21ab52d8ca6d92748bcbbf7e0e200d896d89c0a", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -745,7 +745,7 @@ size_t objc_common_tree_size (enum tree_code code);\n #define objc_is_class_id(TYPE) (OBJC_TYPE_NAME (TYPE) == objc_class_id)\n \n /* Retrieve category interface CAT_NAME (if any) associated with CLASS.  */\n-static inline tree\n+inline tree\n lookup_category (tree klass, tree cat_name)\n {\n   tree category = CLASS_CATEGORY_LIST (klass);\n@@ -756,7 +756,7 @@ lookup_category (tree klass, tree cat_name)\n }\n \n /* Count only the fields occurring in T.  */\n-static inline int\n+inline int\n ivar_list_length (tree t)\n {\n   int count = 0;\n@@ -768,7 +768,7 @@ ivar_list_length (tree t)\n   return count;\n }\n \n-static inline tree\n+inline tree\n is_ivar (tree decl_chain, tree ident)\n {\n   for ( ; decl_chain; decl_chain = DECL_CHAIN (decl_chain))"}, {"sha": "1e1b5fd419bd34962fe0cb721e3f0858a9c2040e", "filename": "gcc/objc/objc-map.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fobjc%2Fobjc-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fobjc%2Fobjc-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-map.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -133,7 +133,7 @@ int objc_map_maximum_load_factor (objc_map_t map);\n    value NULL, and objc_map_get() will return NULL in that case.\n    So a result of NULL means that they key *was* found, and the value\n    associated with it was NULL.  */\n-static inline tree\n+inline tree\n objc_map_get (objc_map_t map, /* struct tree_identifier * */tree key)\n {\n   /* The inline implementation is private and may change without notice.  */\n@@ -169,7 +169,7 @@ objc_map_get (objc_map_t map, /* struct tree_identifier * */tree key)\n    You can use any identifier as key, with the exception of NULL.\n \n    You can use any tree as value, including NULL.  */\n-static inline\n+inline\n void objc_map_put (objc_map_t map, /*struct tree_identifier * */tree key, tree value)\n {\n   /* The inline implementation is private and may change without notice.  */\n@@ -243,7 +243,7 @@ typedef size_t objc_map_iterator_t;\n /* Initialize an iterator to iterate over the specified objc_map.  You\n    must use this before starting the iteration, to get a working\n    iterator.  */\n-static inline\n+inline\n void\n objc_map_iterator_initialize (objc_map_t map ATTRIBUTE_UNUSED, objc_map_iterator_t *i)\n {\n@@ -262,7 +262,7 @@ objc_map_iterator_initialize (objc_map_t map ATTRIBUTE_UNUSED, objc_map_iterator\n    been initialized using objc_map_iterator_initialize().  Note that\n    because this function is modifying the iterator, you need to pass a\n    pointer to it.  */\n-static inline\n+inline\n int\n objc_map_iterator_move_to_next (objc_map_t map, objc_map_iterator_t *i)\n {\n@@ -285,7 +285,7 @@ objc_map_iterator_move_to_next (objc_map_t map, objc_map_iterator_t *i)\n    first element), and only if the last call returned\n    OBJC_MAP_SUCCESS.  The behavior is otherwise undefined, probably a\n    segmentation fault.  */\n-static inline\n+inline\n tree\n objc_map_iterator_current_key (objc_map_t map, objc_map_iterator_t i)\n {\n@@ -298,7 +298,7 @@ objc_map_iterator_current_key (objc_map_t map, objc_map_iterator_t i)\n    the first element), and only if the last call returned\n    OBJC_MAP_SUCCESS.  The behavior is otherwise undefined, probably a\n    segmentation fault.  */\n-static inline\n+inline\n tree\n objc_map_iterator_current_value (objc_map_t map, objc_map_iterator_t i)\n {"}, {"sha": "92717db16280d8ca61cc355913019e28c0764bc1", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -137,7 +137,7 @@ enum omp_requires {\n \n extern GTY(()) enum omp_requires omp_requires_mask;\n \n-static inline dump_flags_t\n+inline dump_flags_t\n get_openacc_privatization_dump_flags ()\n {\n   dump_flags_t l_dump_flags = MSG_NOTE;"}, {"sha": "b266d2fe99024d40e3c3dc2c6c94fcf40cf7dae9", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -92,7 +92,7 @@ trapv_binoptab_p (optab binoptab)\n /* Return insn code for a comparison operator with VMODE\n    resultin MASK_MODE, unsigned if UNS is true.  */\n \n-static inline enum insn_code\n+inline enum insn_code\n get_vec_cmp_icode (machine_mode vmode, machine_mode mask_mode, bool uns)\n {\n   optab tab = uns ? vec_cmpu_optab : vec_cmp_optab;\n@@ -102,7 +102,7 @@ get_vec_cmp_icode (machine_mode vmode, machine_mode mask_mode, bool uns)\n /* Return insn code for a comparison operator with VMODE\n    resultin MASK_MODE (only for EQ/NE).  */\n \n-static inline enum insn_code\n+inline enum insn_code\n get_vec_cmp_eq_icode (machine_mode vmode, machine_mode mask_mode)\n {\n   return convert_optab_handler (vec_cmpeq_optab, vmode, mask_mode);\n@@ -125,7 +125,7 @@ get_vcond_icode (machine_mode vmode, machine_mode cmode, bool uns)\n /* Return insn code for a conditional operator with a mask mode\n    MMODE resulting in a value of mode VMODE.  */\n \n-static inline enum insn_code\n+inline enum insn_code\n get_vcond_mask_icode (machine_mode vmode, machine_mode mmode)\n {\n   return convert_optab_handler (vcond_mask_optab, vmode, mmode);\n@@ -134,7 +134,7 @@ get_vcond_mask_icode (machine_mode vmode, machine_mode mmode)\n /* Return insn code for a conditional operator with a comparison in\n    mode CMODE (only EQ/NE), resulting in a value of mode VMODE.  */\n \n-static inline enum insn_code\n+inline enum insn_code\n get_vcond_eq_icode (machine_mode vmode, machine_mode cmode)\n {\n   return convert_optab_handler (vcondeq_optab, vmode, cmode);"}, {"sha": "29ccbe9235eeba418bd1b201e91677fe400749c5", "filename": "gcc/optabs.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -70,7 +70,7 @@ class expand_operand {\n /* Initialize OP with the given fields.  Initialise the other fields\n    to their default values.  */\n \n-static inline void\n+inline void\n create_expand_operand (class expand_operand *op,\n \t\t       enum expand_operand_type type,\n \t\t       rtx value, machine_mode mode,\n@@ -87,7 +87,7 @@ create_expand_operand (class expand_operand *op,\n \n /* Make OP describe an operand that must use rtx X, even if X is volatile.  */\n \n-static inline void\n+inline void\n create_fixed_operand (class expand_operand *op, rtx x)\n {\n   create_expand_operand (op, EXPAND_FIXED, x, VOIDmode, false);\n@@ -98,7 +98,7 @@ create_fixed_operand (class expand_operand *op, rtx x)\n    It is OK for VALUE to be inconsistent with MODE, although it will just\n    be ignored in that case.  */\n \n-static inline void\n+inline void\n create_output_operand (class expand_operand *op, rtx x,\n \t\t       machine_mode mode)\n {\n@@ -110,7 +110,7 @@ create_output_operand (class expand_operand *op, rtx x,\n    VALUE be copied into a different kind of rtx before being passed\n    as an operand.  */\n \n-static inline void\n+inline void\n create_input_operand (class expand_operand *op, rtx value,\n \t\t      machine_mode mode)\n {\n@@ -120,7 +120,7 @@ create_input_operand (class expand_operand *op, rtx value,\n /* Like create_input_operand, except that VALUE must first be converted\n    to mode MODE.  UNSIGNED_P says whether VALUE is unsigned.  */\n \n-static inline void\n+inline void\n create_convert_operand_to (class expand_operand *op, rtx value,\n \t\t\t   machine_mode mode, bool unsigned_p)\n {\n@@ -136,7 +136,7 @@ create_convert_operand_to (class expand_operand *op, rtx value,\n    conversion (as for convert_modes) and duplicating a scalar to fill\n    a vector (if VALUE is a scalar but the operand is a vector).  */\n \n-static inline void\n+inline void\n create_convert_operand_from (class expand_operand *op, rtx value,\n \t\t\t     machine_mode mode, bool unsigned_p)\n {\n@@ -147,7 +147,7 @@ create_convert_operand_from (class expand_operand *op, rtx value,\n /* Make OP describe an input Pmode address operand.  VALUE is the value\n    of the address, but it may need to be converted to Pmode first.  */\n \n-static inline void\n+inline void\n create_address_operand (class expand_operand *op, rtx value)\n {\n   create_expand_operand (op, EXPAND_ADDRESS, value, Pmode, false);"}, {"sha": "ee0a53ec4c95c0a4c4f6b8427d3e0abde6bd9c55", "filename": "gcc/plugin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fplugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fplugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -184,7 +184,7 @@ extern bool flag_plugin_added;\n    EVENT    - the event identifier\n    GCC_DATA - event-specific data provided by the compiler  */\n \n-static inline int\n+inline int\n invoke_plugin_callbacks (int event ATTRIBUTE_UNUSED,\n \t\t\t void *gcc_data ATTRIBUTE_UNUSED)\n {"}, {"sha": "0230a289df536590360a0c623c345519d5e95d11", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -113,7 +113,7 @@ class output_buffer\n \n /* Finishes constructing a NULL-terminated character string representing\n    the buffered text.  */\n-static inline const char *\n+inline const char *\n output_buffer_formatted_text (output_buffer *buff)\n {\n   obstack_1grow (buff->obstack, '\\0');\n@@ -122,7 +122,7 @@ output_buffer_formatted_text (output_buffer *buff)\n \n /* Append to the output buffer a string specified by its\n    STARTing character and LENGTH.  */\n-static inline void\n+inline void\n output_buffer_append_r (output_buffer *buff, const char *start, int length)\n {\n   gcc_checking_assert (start);\n@@ -136,7 +136,7 @@ output_buffer_append_r (output_buffer *buff, const char *start, int length)\n \n /*  Return a pointer to the last character emitted in the\n     output_buffer.  A NULL pointer means no character available.  */\n-static inline const char *\n+inline const char *\n output_buffer_last_position_in_text (const output_buffer *buff)\n {\n   const char *p = NULL;\n@@ -283,7 +283,7 @@ class pretty_printer\n   diagnostic_url_format url_format;\n };\n \n-static inline const char *\n+inline const char *\n pp_get_prefix (const pretty_printer *pp) { return pp->prefix; }\n \n #define pp_space(PP)            pp_character (PP, ' ')\n@@ -415,7 +415,7 @@ extern void pp_begin_url (pretty_printer *pp, const char *url);\n extern void pp_end_url (pretty_printer *pp);\n \n /* Switch into verbatim mode and return the old mode.  */\n-static inline pp_wrapping_mode_t\n+inline pp_wrapping_mode_t\n pp_set_verbatim_wrapping_ (pretty_printer *pp)\n {\n   pp_wrapping_mode_t oldmode = pp_wrapping_mode (pp);"}, {"sha": "3b0e9efffbf8bcf1c2572213b5f96ec26f12a183", "filename": "gcc/range.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Frange.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Frange.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -28,7 +28,7 @@ value_range range_negatives (tree type);\n \n // Return an irange instance that is a boolean TRUE.\n \n-static inline int_range<1>\n+inline int_range<1>\n range_true (tree type)\n {\n   unsigned prec = TYPE_PRECISION (type);\n@@ -37,7 +37,7 @@ range_true (tree type)\n \n // Return an irange instance that is a boolean FALSE.\n \n-static inline int_range<1>\n+inline int_range<1>\n range_false (tree type)\n {\n   unsigned prec = TYPE_PRECISION (type);\n@@ -46,7 +46,7 @@ range_false (tree type)\n \n // Return an irange that covers both true and false.\n \n-static inline int_range<1>\n+inline int_range<1>\n range_true_and_false (tree type)\n {\n   unsigned prec = TYPE_PRECISION (type);"}, {"sha": "b309c9c3deb62b4c3d821b8c980f517687dba08b", "filename": "gcc/read-md.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -375,15 +375,15 @@ extern void (*include_callback) (const char *);\n \n /* Read the next character from the MD file.  */\n \n-static inline int\n+inline int\n read_char (void)\n {\n   return md_reader_ptr->read_char ();\n }\n \n /* Put back CH, which was the last character read from the MD file.  */\n \n-static inline void\n+inline void\n unread_char (int ch)\n {\n   md_reader_ptr->unread_char (ch);"}, {"sha": "764fa90afde2e7eed688b7fe4a85cac98d9e01ea", "filename": "gcc/recog.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -76,7 +76,7 @@ struct operand_alternative\n /* Return the class for operand I of alternative ALT, taking matching\n    constraints into account.  */\n \n-static inline enum reg_class\n+inline enum reg_class\n alternative_class (const operand_alternative *alt, int i)\n {\n   return alt[i].matches >= 0 ? alt[alt[i].matches].cl : alt[i].cl;\n@@ -229,7 +229,7 @@ extern bool mode_dependent_address_p (rtx, addr_space_t);\n \n extern int recog (rtx, rtx_insn *, int *);\n #ifndef GENERATOR_FILE\n-static inline int recog_memoized (rtx_insn *insn);\n+inline int recog_memoized (rtx_insn *insn);\n #endif\n extern void add_clobbers (rtx, int);\n extern int added_clobbers_hard_reg_p (int);\n@@ -266,7 +266,7 @@ extern void copy_frame_info_to_split_insn (rtx_insn *, rtx_insn *);\n    The automatically-generated function `recog' is normally called\n    through this one.  */\n \n-static inline int\n+inline int\n recog_memoized (rtx_insn *insn)\n {\n   if (INSN_CODE (insn) < 0)\n@@ -277,7 +277,7 @@ recog_memoized (rtx_insn *insn)\n \n /* Skip chars until the next ',' or the end of the string.  This is\n    useful to skip alternatives in a constraint string.  */\n-static inline const char *\n+inline const char *\n skip_alternative (const char *p)\n {\n   const char *r = p;"}, {"sha": "aea093ed795b1d3d1be09fbb89ad4703146b5f7b", "filename": "gcc/regs.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -64,7 +64,7 @@ struct regstat_n_sets_and_refs_t\n extern struct regstat_n_sets_and_refs_t *regstat_n_sets_and_refs;\n \n /* Indexed by n, gives number of times (REG n) is used or set.  */\n-static inline int\n+inline int\n REG_N_REFS (int regno)\n {\n   return regstat_n_sets_and_refs[regno].refs;\n@@ -75,7 +75,7 @@ REG_N_REFS (int regno)\n #define INC_REG_N_REFS(N,V) (regstat_n_sets_and_refs[N].refs += V)\n \n /* Indexed by n, gives number of times (REG n) is set.  */\n-static inline int\n+inline int\n REG_N_SETS (int regno)\n {\n   return regstat_n_sets_and_refs[regno].sets;\n@@ -266,7 +266,7 @@ hard_regno_nregs (unsigned int regno, machine_mode mode)\n /* Return an exclusive upper bound on the registers occupied by hard\n    register (reg:MODE REGNO).  */\n \n-static inline unsigned int\n+inline unsigned int\n end_hard_regno (machine_mode mode, unsigned int regno)\n {\n   return regno + hard_regno_nregs (regno, mode);\n@@ -275,7 +275,7 @@ end_hard_regno (machine_mode mode, unsigned int regno)\n /* Add to REGS all the registers required to store a value of mode MODE\n    in register REGNO.  */\n \n-static inline void\n+inline void\n add_to_hard_reg_set (HARD_REG_SET *regs, machine_mode mode,\n \t\t     unsigned int regno)\n {\n@@ -289,7 +289,7 @@ add_to_hard_reg_set (HARD_REG_SET *regs, machine_mode mode,\n \n /* Likewise, but remove the registers.  */\n \n-static inline void\n+inline void\n remove_from_hard_reg_set (HARD_REG_SET *regs, machine_mode mode,\n \t\t\t  unsigned int regno)\n {\n@@ -303,7 +303,7 @@ remove_from_hard_reg_set (HARD_REG_SET *regs, machine_mode mode,\n \n /* Return true if REGS contains the whole of (reg:MODE REGNO).  */\n \n-static inline bool\n+inline bool\n in_hard_reg_set_p (const_hard_reg_set regs, machine_mode mode,\n \t\t   unsigned int regno)\n {\n@@ -328,7 +328,7 @@ in_hard_reg_set_p (const_hard_reg_set regs, machine_mode mode,\n \n /* Return true if (reg:MODE REGNO) includes an element of REGS.  */\n \n-static inline bool\n+inline bool\n overlaps_hard_reg_set_p (const_hard_reg_set regs, machine_mode mode,\n \t\t\t unsigned int regno)\n {\n@@ -348,7 +348,7 @@ overlaps_hard_reg_set_p (const_hard_reg_set regs, machine_mode mode,\n /* Like add_to_hard_reg_set, but use a REGNO/NREGS range instead of\n    REGNO and MODE.  */\n \n-static inline void\n+inline void\n add_range_to_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,\n \t\t\t   int nregs)\n {\n@@ -358,7 +358,7 @@ add_range_to_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,\n \n /* Likewise, but remove the registers.  */\n \n-static inline void\n+inline void\n remove_range_from_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,\n \t\t\t\tint nregs)\n {\n@@ -368,7 +368,7 @@ remove_range_from_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,\n \n /* Like overlaps_hard_reg_set_p, but use a REGNO/NREGS range instead of\n    REGNO and MODE.  */\n-static inline bool\n+inline bool\n range_overlaps_hard_reg_set_p (const_hard_reg_set set, unsigned regno,\n \t\t\t       int nregs)\n {\n@@ -380,7 +380,7 @@ range_overlaps_hard_reg_set_p (const_hard_reg_set set, unsigned regno,\n \n /* Like in_hard_reg_set_p, but use a REGNO/NREGS range instead of\n    REGNO and MODE.  */\n-static inline bool\n+inline bool\n range_in_hard_reg_set_p (const_hard_reg_set set, unsigned regno, int nregs)\n {\n   while (nregs-- > 0)"}, {"sha": "00ce4f12cac008efc8e51e1ddcb7219f3c6322d6", "filename": "gcc/rtl-iter.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Frtl-iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Frtl-iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-iter.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -39,7 +39,7 @@ extern rtx_subrtx_bound_info rtx_nonconst_subrtx_bounds[];\n \n /* Return true if CODE has no subrtxes.  */\n \n-static inline bool\n+inline bool\n leaf_code_p (enum rtx_code code)\n {\n   return rtx_all_subrtx_bounds[code].count == 0;"}, {"sha": "52f0419af29f904b06c34b049b1019d3e468a3b6", "filename": "gcc/rtl.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -1895,15 +1895,15 @@ inline void rtx_jump_insn::set_jump_target (rtx_code_label *target)\n #define LABEL_REFS(LABEL) XCEXP (LABEL, 3, CODE_LABEL)\n \n /* Get the label that a LABEL_REF references.  */\n-static inline rtx_insn *\n+inline rtx_insn *\n label_ref_label (const_rtx ref)\n {\n   return as_a<rtx_insn *> (XCEXP (ref, 0, LABEL_REF));\n }\n \n /* Set the label that LABEL_REF ref refers to.  */\n \n-static inline void\n+inline void\n set_label_ref_label (rtx ref, rtx_insn *label)\n {\n   XCEXP (ref, 0, LABEL_REF) = label;\n@@ -1926,22 +1926,22 @@ set_label_ref_label (rtx ref, rtx_insn *label)\n   (RTL_FLAG_CHECK1 (\"ORIGINAL_REGNO\", (RTX), REG)->u2.original_regno)\n \n /* Force the REGNO macro to only be used on the lhs.  */\n-static inline unsigned int\n+inline unsigned int\n rhs_regno (const_rtx x)\n {\n   return REG_CHECK (x)->regno;\n }\n \n /* Return the final register in REG X plus one.  */\n-static inline unsigned int\n+inline unsigned int\n END_REGNO (const_rtx x)\n {\n   return REGNO (x) + REG_NREGS (x);\n }\n \n /* Change the REGNO and REG_NREGS of REG X to the specified values,\n    bypassing the df machinery.  */\n-static inline void\n+inline void\n set_regno_raw (rtx x, unsigned int regno, unsigned int nregs)\n {\n   reg_info *reg = REG_CHECK (x);\n@@ -2058,7 +2058,7 @@ const_vector_encoded_nelts (const_rtx x)\n \n /* Return true if CODE always has VOIDmode.  */\n \n-static inline bool\n+inline bool\n always_void_p (enum rtx_code code)\n {\n   return code == SET;\n@@ -2073,15 +2073,15 @@ struct full_rtx_costs\n };\n \n /* Initialize a full_rtx_costs structure C to the maximum cost.  */\n-static inline void\n+inline void\n init_costs_to_max (struct full_rtx_costs *c)\n {\n   c->speed = MAX_COST;\n   c->size = MAX_COST;\n }\n \n /* Initialize a full_rtx_costs structure C to zero cost.  */\n-static inline void\n+inline void\n init_costs_to_zero (struct full_rtx_costs *c)\n {\n   c->speed = 0;\n@@ -2090,7 +2090,7 @@ init_costs_to_zero (struct full_rtx_costs *c)\n \n /* Compare two full_rtx_costs structures A and B, returning true\n    if A < B when optimizing for speed.  */\n-static inline bool\n+inline bool\n costs_lt_p (struct full_rtx_costs *a, struct full_rtx_costs *b,\n \t    bool speed)\n {\n@@ -2104,7 +2104,7 @@ costs_lt_p (struct full_rtx_costs *a, struct full_rtx_costs *b,\n \n /* Increase both members of the full_rtx_costs structure C by the\n    cost of N insns.  */\n-static inline void\n+inline void\n costs_add_n_insns (struct full_rtx_costs *c, int n)\n {\n   c->speed += COSTS_N_INSNS (n);\n@@ -2168,7 +2168,7 @@ subreg_shape::unique_id () const\n \n /* Return the shape of a SUBREG rtx.  */\n \n-static inline subreg_shape\n+inline subreg_shape\n shape_of_subreg (const_rtx x)\n {\n   return subreg_shape (GET_MODE (SUBREG_REG (x)),\n@@ -2919,15 +2919,15 @@ extern int currently_expanding_to_rtl;\n /* Return the cost of SET X.  SPEED_P is true if optimizing for speed\n    rather than size.  */\n \n-static inline int\n+inline int\n set_rtx_cost (rtx x, bool speed_p)\n {\n   return rtx_cost (x, VOIDmode, INSN, 4, speed_p);\n }\n \n /* Like set_rtx_cost, but return both the speed and size costs in C.  */\n \n-static inline void\n+inline void\n get_full_set_rtx_cost (rtx x, struct full_rtx_costs *c)\n {\n   get_full_rtx_cost (x, VOIDmode, INSN, 4, c);\n@@ -2937,15 +2937,15 @@ get_full_set_rtx_cost (rtx x, struct full_rtx_costs *c)\n    of a register move.  SPEED_P is true if optimizing for speed rather\n    than size.  */\n \n-static inline int\n+inline int\n set_src_cost (rtx x, machine_mode mode, bool speed_p)\n {\n   return rtx_cost (x, mode, SET, 1, speed_p);\n }\n \n /* Like set_src_cost, but return both the speed and size costs in C.  */\n \n-static inline void\n+inline void\n get_full_set_src_cost (rtx x, machine_mode mode, struct full_rtx_costs *c)\n {\n   get_full_rtx_cost (x, mode, SET, 1, c);\n@@ -3947,7 +3947,7 @@ extern struct target_rtl *this_target_rtl;\n \n #ifndef GENERATOR_FILE\n /* Return the attributes of a MEM rtx.  */\n-static inline const class mem_attrs *\n+inline const class mem_attrs *\n get_mem_attrs (const_rtx x)\n {\n   class mem_attrs *attrs;\n@@ -3996,7 +3996,7 @@ extern rtx gen_rtx_VAR_LOCATION (machine_mode, tree, rtx,\n #ifdef GENERATOR_FILE\n #define PUT_MODE(RTX, MODE) PUT_MODE_RAW (RTX, MODE)\n #else\n-static inline void\n+inline void\n PUT_MODE (rtx x, machine_mode mode)\n {\n   if (REG_P (x))"}, {"sha": "61172db9d7b66634f2b72aad34a8603da0862eb9", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -98,7 +98,7 @@ struct simple_bitmap_def\n \n /* Verify that access at INDEX in bitmap MAP is valid.  */ \n \n-static inline void\n+inline void\n bitmap_check_index (const_sbitmap map, int index)\n {\n   gcc_checking_assert (index >= 0);\n@@ -107,14 +107,14 @@ bitmap_check_index (const_sbitmap map, int index)\n \n /* Verify that bitmaps A and B have same size.  */ \n \n-static inline void\n+inline void\n bitmap_check_sizes (const_sbitmap a, const_sbitmap b)\n {\n   gcc_checking_assert (a->n_bits == b->n_bits);\n }\n \n /* Test if bit number bitno in the bitmap is set.  */\n-static inline bool\n+inline bool\n bitmap_bit_p (const_sbitmap map, int bitno)\n {\n   bitmap_check_index (map, bitno);\n@@ -127,7 +127,7 @@ bitmap_bit_p (const_sbitmap map, int bitno)\n /* Set bit number BITNO in the sbitmap MAP.\n    Return true if the bit changed.  */\n \n-static inline bool\n+inline bool\n bitmap_set_bit (sbitmap map, int bitno)\n {\n   bitmap_check_index (map, bitno);\n@@ -143,7 +143,7 @@ bitmap_set_bit (sbitmap map, int bitno)\n /* Reset bit number BITNO in the sbitmap MAP.\n    Return true if the bit changed.  */\n \n-static inline bool\n+inline bool\n bitmap_clear_bit (sbitmap map, int bitno)\n {\n   bitmap_check_index (map, bitno);\n@@ -177,7 +177,7 @@ struct sbitmap_iterator {\n /* Initialize the iterator I with sbitmap BMP and the initial index\n    MIN.  */\n \n-static inline void\n+inline void\n bmp_iter_set_init (sbitmap_iterator *i, const_sbitmap bmp,\n \t\t   unsigned int min, unsigned *bit_no ATTRIBUTE_UNUSED)\n {\n@@ -197,7 +197,7 @@ bmp_iter_set_init (sbitmap_iterator *i, const_sbitmap bmp,\n    to the index of the bit to be visited.  Otherwise, return\n    false.  */\n \n-static inline bool\n+inline bool\n bmp_iter_set (sbitmap_iterator *i, unsigned int *n)\n {\n   /* Skip words that are zeros.  */\n@@ -223,7 +223,7 @@ bmp_iter_set (sbitmap_iterator *i, unsigned int *n)\n \n /* Advance to the next bit.  */\n \n-static inline void\n+inline void\n bmp_iter_next (sbitmap_iterator *i, unsigned *bit_no ATTRIBUTE_UNUSED)\n {\n   i->word >>= 1;"}, {"sha": "97b7d2d319bc5b60d0f48f2cc085d367cfb79f5a", "filename": "gcc/sched-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -87,7 +87,7 @@ extern struct common_sched_info_def *common_sched_info;\n extern const struct common_sched_info_def haifa_common_sched_info;\n \n /* Return true if selective scheduling pass is working.  */\n-static inline bool\n+inline bool\n sel_sched_p (void)\n {\n   return common_sched_info->sched_pass_id == SCHED_SEL_PASS;\n@@ -1588,7 +1588,7 @@ typedef struct _sd_iterator sd_iterator_def;\n    struct _deps_link.  */\n \n /* Return initialized iterator.  */\n-static inline sd_iterator_def\n+inline sd_iterator_def\n sd_iterator_start (rtx insn, sd_list_types_def types)\n {\n   /* Some dep_link a pointer to which will return NULL.  */\n@@ -1607,7 +1607,7 @@ sd_iterator_start (rtx insn, sd_list_types_def types)\n }\n \n /* Return the current element.  */\n-static inline bool\n+inline bool\n sd_iterator_cond (sd_iterator_def *it_ptr, dep_t *dep_ptr)\n {\n   while (true)\n@@ -1645,7 +1645,7 @@ sd_iterator_cond (sd_iterator_def *it_ptr, dep_t *dep_ptr)\n }\n \n /* Advance iterator.  */\n-static inline void\n+inline void\n sd_iterator_next (sd_iterator_def *it_ptr)\n {\n   it_ptr->linkp = &DEP_LINK_NEXT (*it_ptr->linkp);"}, {"sha": "7034a1ab06c1f295a12b2f3121e0450924898783", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -359,13 +359,13 @@ struct _list_node\n    we can't move them in sel-sched-ir.cc.  */\n extern object_allocator<_list_node> sched_lists_pool;\n \n-static inline _list_t\n+inline _list_t\n _list_alloc (void)\n {\n   return sched_lists_pool.allocate ();\n }\n \n-static inline void\n+inline void\n _list_add (_list_t *lp)\n {\n   _list_t l = _list_alloc ();\n@@ -374,15 +374,15 @@ _list_add (_list_t *lp)\n   *lp = l;\n }\n \n-static inline void\n+inline void\n _list_remove_nofree (_list_t *lp)\n {\n   _list_t n = *lp;\n \n   *lp = _LIST_NEXT (n);\n }\n \n-static inline void\n+inline void\n _list_remove (_list_t *lp)\n {\n   _list_t n = *lp;\n@@ -391,7 +391,7 @@ _list_remove (_list_t *lp)\n   sched_lists_pool.remove (n);\n }\n \n-static inline void\n+inline void\n _list_clear (_list_t *l)\n {\n   while (*l)\n@@ -412,15 +412,15 @@ struct _list_iterator\n   bool removed_p;\n };\n \n-static inline void\n+inline void\n _list_iter_start (_list_iterator *ip, _list_t *lp, bool can_remove_p)\n {\n   ip->lp = lp;\n   ip->can_remove_p = can_remove_p;\n   ip->removed_p = false;\n }\n \n-static inline void\n+inline void\n _list_iter_next (_list_iterator *ip)\n {\n   if (!ip->removed_p)\n@@ -429,15 +429,15 @@ _list_iter_next (_list_iterator *ip)\n     ip->removed_p = false;\n }\n \n-static inline void\n+inline void\n _list_iter_remove (_list_iterator *ip)\n {\n   gcc_assert (!ip->removed_p && ip->can_remove_p);\n   _list_remove (ip->lp);\n   ip->removed_p = true;\n }\n \n-static inline void\n+inline void\n _list_iter_remove_nofree (_list_iterator *ip)\n {\n   gcc_assert (!ip->removed_p && ip->can_remove_p);\n@@ -460,7 +460,7 @@ _list_iter_remove_nofree (_list_iterator *ip)\n \n /* _xlist_t functions.  */\n \n-static inline void\n+inline void\n _xlist_add (_xlist_t *lp, rtx x)\n {\n   _list_add (lp);\n@@ -470,7 +470,7 @@ _xlist_add (_xlist_t *lp, rtx x)\n #define _xlist_remove(LP) (_list_remove (LP))\n #define _xlist_clear(LP) (_list_clear (LP))\n \n-static inline bool\n+inline bool\n _xlist_is_in_p (_xlist_t l, rtx x)\n {\n   while (l)\n@@ -484,7 +484,7 @@ _xlist_is_in_p (_xlist_t l, rtx x)\n }\n \n /* Used through _FOR_EACH.  */\n-static inline bool\n+inline bool\n _list_iter_cond_x (_xlist_t l, rtx *xp)\n {\n   if (l)\n@@ -505,7 +505,7 @@ typedef _list_iterator _xlist_iterator;\n \n /* ilist_t functions.  */\n \n-static inline void\n+inline void\n ilist_add (ilist_t *lp, insn_t insn)\n {\n   _list_add (lp);\n@@ -514,7 +514,7 @@ ilist_add (ilist_t *lp, insn_t insn)\n #define ilist_remove(LP) (_list_remove (LP))\n #define ilist_clear(LP) (_list_clear (LP))\n \n-static inline bool\n+inline bool\n ilist_is_in_p (ilist_t l, insn_t insn)\n {\n   while (l)\n@@ -528,7 +528,7 @@ ilist_is_in_p (ilist_t l, insn_t insn)\n }\n \n /* Used through _FOR_EACH.  */\n-static inline bool\n+inline bool\n _list_iter_cond_insn (ilist_t l, insn_t *ip)\n {\n   if (l)\n@@ -574,7 +574,7 @@ typedef _list_iterator def_list_iterator;\n \n #define FOR_EACH_DEF(DEF, I, DEF_LIST) _FOR_EACH (def, (DEF), (I), (DEF_LIST))\n \n-static inline bool\n+inline bool\n _list_iter_cond_def (def_list_t def_list, def_t *def)\n {\n   if (def_list)\n@@ -1040,7 +1040,7 @@ extern bool sel_bb_empty_p (basic_block);\n extern bool in_current_region_p (basic_block);\n \n /* True when BB is a header of the inner loop.  */\n-static inline bool\n+inline bool\n inner_loop_header_p (basic_block bb)\n {\n   class loop *inner_loop;\n@@ -1068,7 +1068,7 @@ inner_loop_header_p (basic_block bb)\n }\n \n /* Return exit edges of LOOP, filtering out edges with the same dest bb.  */\n-static inline vec<edge> \n+inline vec<edge> \n get_loop_exit_edges_unique_dests (const class loop *loop)\n {\n   vec<edge> edges = vNULL;\n@@ -1122,7 +1122,7 @@ sel_bb_empty_or_nop_p (basic_block bb)\n    traverse all of them and if any of them turns out to be another loop header\n    (after skipping empty BBs), add its loop exits to the resulting vector\n    as well.  */\n-static inline vec<edge> \n+inline vec<edge> \n get_all_loop_exits (basic_block bb)\n {\n   vec<edge> exits = vNULL;\n@@ -1212,7 +1212,7 @@ get_all_loop_exits (basic_block bb)\n \n /* We need to return a succ_iterator to avoid 'unitialized' warning\n    during bootstrap.  */\n-static inline succ_iterator\n+inline succ_iterator\n _succ_iter_start (insn_t *succp, insn_t insn, int flags)\n {\n   succ_iterator i;\n@@ -1249,7 +1249,7 @@ _succ_iter_start (insn_t *succp, insn_t insn, int flags)\n   return i;\n }\n \n-static inline bool\n+inline bool\n _succ_iter_cond (succ_iterator *ip, insn_t *succp, insn_t insn,\n                  bool check (edge, succ_iterator *))\n {\n@@ -1354,7 +1354,7 @@ _succ_iter_cond (succ_iterator *ip, insn_t *succp, insn_t insn,\n     }\n }\n \n-static inline void\n+inline void\n _succ_iter_next (succ_iterator *ip)\n {\n   gcc_assert (!ip->e2 || ip->e1);\n@@ -1367,7 +1367,7 @@ _succ_iter_next (succ_iterator *ip)\n    empty blocks.  When E2P is not null, the resulting edge is written there.\n    FLAGS are used to specify whether back edges and out-of-region edges\n    should be considered.  */\n-static inline bool\n+inline bool\n _eligible_successor_edge_p (edge e1, succ_iterator *ip)\n {\n   edge e2 = e1;\n@@ -1476,7 +1476,7 @@ _eligible_successor_edge_p (edge e1, succ_iterator *ip)\n #define SUCC_ITER_EDGE(ITER) ((ITER)->e1)\n \n /* Return the next block of BB not running into inconsistencies.  */\n-static inline basic_block\n+inline basic_block\n bb_next_bb (basic_block bb)\n {\n   switch (EDGE_COUNT (bb->succs))"}, {"sha": "252318bcc1c17c5d114e2f94432ed4465c0b3d8b", "filename": "gcc/sese.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -44,15 +44,15 @@ void dump_sese (const sese_l &);\n \n /* Get the entry of an sese S.  */\n \n-static inline basic_block\n+inline basic_block\n get_entry_bb (const sese_l &s)\n {\n   return s.entry->dest;\n }\n \n /* Get the exit of an sese S.  */\n \n-static inline basic_block\n+inline basic_block\n get_exit_bb (const sese_l &s)\n {\n   return s.exit->src;\n@@ -110,7 +110,7 @@ extern bool sese_trivially_empty_bb_p (basic_block);\n \n /* The number of parameters in REGION. */\n \n-static inline unsigned\n+inline unsigned\n sese_nb_params (sese_info_p region)\n {\n   return region->params.length ();\n@@ -119,7 +119,7 @@ sese_nb_params (sese_info_p region)\n /* Checks whether BB is contained in the region delimited by ENTRY and\n    EXIT blocks.  */\n \n-static inline bool\n+inline bool\n bb_in_region (const_basic_block bb, const_basic_block entry, const_basic_block exit)\n {\n   return dominated_by_p (CDI_DOMINATORS, bb, entry)\n@@ -130,15 +130,15 @@ bb_in_region (const_basic_block bb, const_basic_block entry, const_basic_block e\n /* Checks whether BB is contained in the region delimited by ENTRY and\n    EXIT blocks.  */\n \n-static inline bool\n+inline bool\n bb_in_sese_p (basic_block bb, const sese_l &r)\n {\n   return bb_in_region (bb, r.entry->dest, r.exit->dest);\n }\n \n /* Returns true when STMT is defined in REGION.  */\n \n-static inline bool\n+inline bool\n stmt_in_sese_p (gimple *stmt, const sese_l &r)\n {\n   basic_block bb = gimple_bb (stmt);\n@@ -147,15 +147,15 @@ stmt_in_sese_p (gimple *stmt, const sese_l &r)\n \n /* Returns true when NAME is defined in REGION.  */\n \n-static inline bool\n+inline bool\n defined_in_sese_p (tree name, const sese_l &r)\n {\n   return stmt_in_sese_p (SSA_NAME_DEF_STMT (name), r);\n }\n \n /* Returns true when LOOP is in REGION.  */\n \n-static inline bool\n+inline bool\n loop_in_sese_p (class loop *loop, const sese_l &region)\n {\n   return (bb_in_sese_p (loop->header, region)\n@@ -185,7 +185,7 @@ loop_in_sese_p (class loop *loop, const sese_l &region)\n     loop_1 exists, but is not completely contained in the region -> depth 0\n     loop_2 is completely contained -> depth 1  */\n \n-static inline unsigned int\n+inline unsigned int\n sese_loop_depth (const sese_l &region, loop_p loop)\n {\n   unsigned int depth = 0;\n@@ -212,19 +212,19 @@ extern void set_ifsese_condition (ifsese, tree);\n extern edge get_true_edge_from_guard_bb (basic_block);\n extern edge get_false_edge_from_guard_bb (basic_block);\n \n-static inline edge\n+inline edge\n if_region_entry (ifsese if_region)\n {\n   return if_region->region->region.entry;\n }\n \n-static inline edge\n+inline edge\n if_region_exit (ifsese if_region)\n {\n   return if_region->region->region.exit;\n }\n \n-static inline basic_block\n+inline basic_block\n if_region_get_condition_block (ifsese if_region)\n {\n   return if_region_entry (if_region)->dest;\n@@ -272,7 +272,7 @@ typedef struct gimple_poly_bb\n \n /* Return the innermost loop that contains the basic block GBB.  */\n \n-static inline class loop *\n+inline class loop *\n gbb_loop (gimple_poly_bb_p gbb)\n {\n   return GBB_BB (gbb)->loop_father;\n@@ -281,7 +281,7 @@ gbb_loop (gimple_poly_bb_p gbb)\n /* Returns the gimple loop, that corresponds to the loop_iterator_INDEX.\n    If there is no corresponding gimple loop, we return NULL.  */\n \n-static inline loop_p\n+inline loop_p\n gbb_loop_at_index (gimple_poly_bb_p gbb, sese_l &region, int index)\n {\n   loop_p loop = gbb_loop (gbb);\n@@ -297,7 +297,7 @@ gbb_loop_at_index (gimple_poly_bb_p gbb, sese_l &region, int index)\n \n /* The number of common loops in REGION for GBB1 and GBB2.  */\n \n-static inline int\n+inline int\n nb_common_loops (sese_l &region, gimple_poly_bb_p gbb1, gimple_poly_bb_p gbb2)\n {\n   loop_p l1 = gbb_loop (gbb1);"}, {"sha": "694ff117f0e83963d12b1b87f777bd4f6598c98b", "filename": "gcc/sparseset.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsparseset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsparseset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsparseset.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -109,7 +109,7 @@ extern bool sparseset_equal_p (sparseset, sparseset);\n /* Operation: S = {}\n    Clear the set of all elements.  */\n \n-static inline void\n+inline void\n sparseset_clear (sparseset s)\n {\n   s->members = 0;\n@@ -118,23 +118,23 @@ sparseset_clear (sparseset s)\n \n /* Return the number of elements currently in the set.  */\n \n-static inline SPARSESET_ELT_TYPE\n+inline SPARSESET_ELT_TYPE\n sparseset_cardinality (sparseset s)\n {\n   return s->members;\n }\n \n /* Return the maximum number of elements this set can hold.  */\n \n-static inline SPARSESET_ELT_TYPE\n+inline SPARSESET_ELT_TYPE\n sparseset_size (sparseset s)\n {\n   return s->size;\n }\n \n /* Return true if e is a member of the set S, otherwise return false.  */\n \n-static inline bool\n+inline bool\n sparseset_bit_p (sparseset s, SPARSESET_ELT_TYPE e)\n {\n   SPARSESET_ELT_TYPE idx;\n@@ -149,7 +149,7 @@ sparseset_bit_p (sparseset s, SPARSESET_ELT_TYPE e)\n /* Low level insertion routine not meant for use outside of sparseset.[ch].\n    Assumes E is valid and not already a member of the set S.  */\n \n-static inline void\n+inline void\n sparseset_insert_bit (sparseset s, SPARSESET_ELT_TYPE e, SPARSESET_ELT_TYPE idx)\n {\n   s->sparse[e] = idx;\n@@ -159,7 +159,7 @@ sparseset_insert_bit (sparseset s, SPARSESET_ELT_TYPE e, SPARSESET_ELT_TYPE idx)\n /* Operation: S = S + {e}\n    Insert E into the set S, if it isn't already a member.  */\n \n-static inline void\n+inline void\n sparseset_set_bit (sparseset s, SPARSESET_ELT_TYPE e)\n {\n   if (!sparseset_bit_p (s, e))\n@@ -168,7 +168,7 @@ sparseset_set_bit (sparseset s, SPARSESET_ELT_TYPE e)\n \n /* Return and remove the last member added to the set S.  */\n \n-static inline SPARSESET_ELT_TYPE\n+inline SPARSESET_ELT_TYPE\n sparseset_pop (sparseset s)\n {\n   SPARSESET_ELT_TYPE mem = s->members;\n@@ -179,15 +179,15 @@ sparseset_pop (sparseset s)\n   return s->dense[s->members];\n }\n \n-static inline void\n+inline void\n sparseset_iter_init (sparseset s)\n {\n   s->iter = 0;\n   s->iter_inc = 1;\n   s->iterating = true;\n }\n \n-static inline bool\n+inline bool\n sparseset_iter_p (sparseset s)\n {\n   if (s->iterating && s->iter < s->members)\n@@ -196,13 +196,13 @@ sparseset_iter_p (sparseset s)\n     return s->iterating = false;\n }\n \n-static inline SPARSESET_ELT_TYPE\n+inline SPARSESET_ELT_TYPE\n sparseset_iter_elm (sparseset s)\n {\n   return s->dense[s->iter];\n }\n \n-static inline void\n+inline void\n sparseset_iter_next (sparseset s)\n {\n   s->iter += s->iter_inc;"}, {"sha": "3aeb89bb60e87682db80b48ce8045edd893e1b52", "filename": "gcc/ssa-iterators.h", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fssa-iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fssa-iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-iterators.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -78,7 +78,7 @@ struct imm_use_iterator\n        (void) ((DEST) = next_readonly_imm_use (&(ITER))))\n \n /* Forward declare for use in the class below.  */\n-static inline void end_imm_use_stmt_traverse (imm_use_iterator *);\n+inline void end_imm_use_stmt_traverse (imm_use_iterator *);\n \n /* arrange to automatically call, upon descruction, end_imm_use_stmt_traverse\n    with a given pointer to imm_use_iterator.  */\n@@ -246,7 +246,7 @@ struct ssa_op_iter\n \n \n /* Delink an immediate_uses node from its chain.  */\n-static inline void\n+inline void\n delink_imm_use (ssa_use_operand_t *linknode)\n {\n   /* Return if this node is not in a list.  */\n@@ -260,7 +260,7 @@ delink_imm_use (ssa_use_operand_t *linknode)\n }\n \n /* Link ssa_imm_use node LINKNODE into the chain for LIST.  */\n-static inline void\n+inline void\n link_imm_use_to_list (ssa_use_operand_t *linknode, ssa_use_operand_t *list)\n {\n   /* Link the new node at the head of the list.  If we are in the process of\n@@ -272,7 +272,7 @@ link_imm_use_to_list (ssa_use_operand_t *linknode, ssa_use_operand_t *list)\n }\n \n /* Link ssa_imm_use node LINKNODE into the chain for DEF.  */\n-static inline void\n+inline void\n link_imm_use (ssa_use_operand_t *linknode, tree def)\n {\n   ssa_use_operand_t *root;\n@@ -289,7 +289,7 @@ link_imm_use (ssa_use_operand_t *linknode, tree def)\n }\n \n /* Set the value of a use pointed to by USE to VAL.  */\n-static inline void\n+inline void\n set_ssa_use_from_ptr (use_operand_p use, tree val)\n {\n   delink_imm_use (use);\n@@ -299,7 +299,7 @@ set_ssa_use_from_ptr (use_operand_p use, tree val)\n \n /* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occurring\n    in STMT.  */\n-static inline void\n+inline void\n link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, gimple *stmt)\n {\n   if (stmt)\n@@ -310,7 +310,7 @@ link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, gimple *stmt)\n }\n \n /* Relink a new node in place of an old node in the list.  */\n-static inline void\n+inline void\n relink_imm_use (ssa_use_operand_t *node, ssa_use_operand_t *old)\n {\n   /* The node one had better be in the same list.  */\n@@ -328,7 +328,7 @@ relink_imm_use (ssa_use_operand_t *node, ssa_use_operand_t *old)\n \n /* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occurring\n    in STMT.  */\n-static inline void\n+inline void\n relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old,\n \t\t     gimple *stmt)\n {\n@@ -341,14 +341,14 @@ relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old,\n \n \n /* Return true is IMM has reached the end of the immediate use list.  */\n-static inline bool\n+inline bool\n end_readonly_imm_use_p (const imm_use_iterator *imm)\n {\n   return (imm->imm_use == imm->end_p);\n }\n \n /* Initialize iterator IMM to process the list for VAR.  */\n-static inline use_operand_p\n+inline use_operand_p\n first_readonly_imm_use (imm_use_iterator *imm, tree var)\n {\n   imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n@@ -360,7 +360,7 @@ first_readonly_imm_use (imm_use_iterator *imm, tree var)\n }\n \n /* Bump IMM to the next use in the list.  */\n-static inline use_operand_p\n+inline use_operand_p\n next_readonly_imm_use (imm_use_iterator *imm)\n {\n   use_operand_p old = imm->imm_use;\n@@ -383,7 +383,7 @@ next_readonly_imm_use (imm_use_iterator *imm)\n \n \n /* Return true if VAR has no nondebug uses.  */\n-static inline bool\n+inline bool\n has_zero_uses (const_tree var)\n {\n   const ssa_use_operand_t *const head = &(SSA_NAME_IMM_USE_NODE (var));\n@@ -397,7 +397,7 @@ has_zero_uses (const_tree var)\n }\n \n /* Return true if VAR has a single nondebug use.  */\n-static inline bool\n+inline bool\n has_single_use (const_tree var)\n {\n   const ssa_use_operand_t *const head = &(SSA_NAME_IMM_USE_NODE (var));\n@@ -418,7 +418,7 @@ has_single_use (const_tree var)\n     \n /* If VAR has only a single immediate nondebug use, return true, and\n    set USE_P and STMT to the use pointer and stmt of occurrence.  */\n-static inline bool\n+inline bool\n single_imm_use (const_tree var, use_operand_p *use_p, gimple **stmt)\n {\n   const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n@@ -449,7 +449,7 @@ single_imm_use (const_tree var, use_operand_p *use_p, gimple **stmt)\n }\n \n /* Return the number of nondebug immediate uses of VAR.  */\n-static inline unsigned int\n+inline unsigned int\n num_imm_uses (const_tree var)\n {\n   const ssa_use_operand_t *const start = &(SSA_NAME_IMM_USE_NODE (var));\n@@ -476,14 +476,14 @@ num_imm_uses (const_tree var)\n    SSA operands.  */\n \n /* Return true if PTR is finished iterating.  */\n-static inline bool\n+inline bool\n op_iter_done (const ssa_op_iter *ptr)\n {\n   return ptr->done;\n }\n \n /* Get the next iterator use value for PTR.  */\n-static inline use_operand_p\n+inline use_operand_p\n op_iter_next_use (ssa_op_iter *ptr)\n {\n   use_operand_p use_p;\n@@ -503,7 +503,7 @@ op_iter_next_use (ssa_op_iter *ptr)\n }\n \n /* Get the next iterator def value for PTR.  */\n-static inline def_operand_p\n+inline def_operand_p\n op_iter_next_def (ssa_op_iter *ptr)\n {\n   gcc_checking_assert (ptr->iter_type == ssa_op_iter_def);\n@@ -538,7 +538,7 @@ op_iter_next_def (ssa_op_iter *ptr)\n }\n \n /* Get the next iterator tree value for PTR.  */\n-static inline tree\n+inline tree\n op_iter_next_tree (ssa_op_iter *ptr)\n {\n   tree val;\n@@ -582,7 +582,7 @@ op_iter_next_tree (ssa_op_iter *ptr)\n    used to prevent warnings in the compile about might be uninitialized\n    components.  */\n \n-static inline void\n+inline void\n clear_and_done_ssa_iter (ssa_op_iter *ptr)\n {\n   ptr->i = 0;\n@@ -595,7 +595,7 @@ clear_and_done_ssa_iter (ssa_op_iter *ptr)\n }\n \n /* Initialize the iterator PTR to the virtual defs in STMT.  */\n-static inline void\n+inline void\n op_iter_init (ssa_op_iter *ptr, gimple *stmt, int flags)\n {\n   /* PHI nodes require a different iterator initialization path.  We\n@@ -640,7 +640,7 @@ op_iter_init (ssa_op_iter *ptr, gimple *stmt, int flags)\n \n /* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return\n    the first use.  */\n-static inline use_operand_p\n+inline use_operand_p\n op_iter_init_use (ssa_op_iter *ptr, gimple *stmt, int flags)\n {\n   gcc_checking_assert ((flags & SSA_OP_ALL_DEFS) == 0\n@@ -652,7 +652,7 @@ op_iter_init_use (ssa_op_iter *ptr, gimple *stmt, int flags)\n \n /* Initialize iterator PTR to the def operands in STMT based on FLAGS. Return\n    the first def.  */\n-static inline def_operand_p\n+inline def_operand_p\n op_iter_init_def (ssa_op_iter *ptr, gimple *stmt, int flags)\n {\n   gcc_checking_assert ((flags & SSA_OP_ALL_USES) == 0\n@@ -664,7 +664,7 @@ op_iter_init_def (ssa_op_iter *ptr, gimple *stmt, int flags)\n \n /* Initialize iterator PTR to the operands in STMT based on FLAGS. Return\n    the first operand as a tree.  */\n-static inline tree\n+inline tree\n op_iter_init_tree (ssa_op_iter *ptr, gimple *stmt, int flags)\n {\n   op_iter_init (ptr, stmt, flags);\n@@ -675,7 +675,7 @@ op_iter_init_tree (ssa_op_iter *ptr, gimple *stmt, int flags)\n \n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n    return NULL.  */\n-static inline tree\n+inline tree\n single_ssa_tree_operand (gimple *stmt, int flags)\n {\n   tree var;\n@@ -693,7 +693,7 @@ single_ssa_tree_operand (gimple *stmt, int flags)\n \n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n    return NULL.  */\n-static inline use_operand_p\n+inline use_operand_p\n single_ssa_use_operand (gimple *stmt, int flags)\n {\n   use_operand_p var;\n@@ -710,7 +710,7 @@ single_ssa_use_operand (gimple *stmt, int flags)\n \n /* Return the single virtual use operand in STMT if present.  Otherwise\n    return NULL.  */\n-static inline use_operand_p\n+inline use_operand_p\n ssa_vuse_operand (gimple *stmt)\n {\n   if (! gimple_vuse (stmt))\n@@ -721,7 +721,7 @@ ssa_vuse_operand (gimple *stmt)\n \n /* If there is a single operand in STMT matching FLAGS, return it.  Otherwise\n    return NULL.  */\n-static inline def_operand_p\n+inline def_operand_p\n single_ssa_def_operand (gimple *stmt, int flags)\n {\n   def_operand_p var;\n@@ -739,7 +739,7 @@ single_ssa_def_operand (gimple *stmt, int flags)\n \n /* Return true if there are zero operands in STMT matching the type\n    given in FLAGS.  */\n-static inline bool\n+inline bool\n zero_ssa_operands (gimple *stmt, int flags)\n {\n   ssa_op_iter iter;\n@@ -750,7 +750,7 @@ zero_ssa_operands (gimple *stmt, int flags)\n \n \n /* Return the number of operands matching FLAGS in STMT.  */\n-static inline int\n+inline int\n num_ssa_operands (gimple *stmt, int flags)\n {\n   ssa_op_iter iter;\n@@ -765,7 +765,7 @@ num_ssa_operands (gimple *stmt, int flags)\n \n /* If there is a single DEF in the PHI node which matches FLAG, return it.\n    Otherwise return NULL_DEF_OPERAND_P.  */\n-static inline tree\n+inline tree\n single_phi_def (gphi *stmt, int flags)\n {\n   tree def = PHI_RESULT (stmt);\n@@ -778,7 +778,7 @@ single_phi_def (gphi *stmt, int flags)\n \n /* Initialize the iterator PTR for uses matching FLAGS in PHI.  FLAGS should\n    be either SSA_OP_USES or SSA_OP_VIRTUAL_USES.  */\n-static inline use_operand_p\n+inline use_operand_p\n op_iter_init_phiuse (ssa_op_iter *ptr, gphi *phi, int flags)\n {\n   tree phi_def = gimple_phi_result (phi);\n@@ -808,7 +808,7 @@ op_iter_init_phiuse (ssa_op_iter *ptr, gphi *phi, int flags)\n \n /* Start an iterator for a PHI definition.  */\n \n-static inline def_operand_p\n+inline def_operand_p\n op_iter_init_phidef (ssa_op_iter *ptr, gphi *phi, int flags)\n {\n   tree phi_def = PHI_RESULT (phi);\n@@ -838,7 +838,7 @@ op_iter_init_phidef (ssa_op_iter *ptr, gphi *phi, int flags)\n \n /* Return true is IMM has reached the end of the immediate use stmt list.  */\n \n-static inline bool\n+inline bool\n end_imm_use_stmt_p (const imm_use_iterator *imm)\n {\n   return (imm->imm_use == imm->end_p);\n@@ -847,7 +847,7 @@ end_imm_use_stmt_p (const imm_use_iterator *imm)\n /* Finished the traverse of an immediate use stmt list IMM by removing the\n    placeholder node from the list.  */\n \n-static inline void\n+inline void\n end_imm_use_stmt_traverse (imm_use_iterator *imm)\n {\n   delink_imm_use (&(imm->iter_node));\n@@ -859,7 +859,7 @@ end_imm_use_stmt_traverse (imm_use_iterator *imm)\n    currently delimited by HEAD and LAST_P.  The new LAST_P value is\n    returned.  */\n \n-static inline use_operand_p\n+inline use_operand_p\n move_use_after_head (use_operand_p use_p, use_operand_p head,\n \t\t      use_operand_p last_p)\n {\n@@ -885,7 +885,7 @@ move_use_after_head (use_operand_p use_p, use_operand_p head,\n /* This routine will relink all uses with the same stmt as HEAD into the list\n    immediately following HEAD for iterator IMM.  */\n \n-static inline void\n+inline void\n link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n {\n   use_operand_p use_p;\n@@ -925,7 +925,7 @@ link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n }\n \n /* Initialize IMM to traverse over uses of VAR.  Return the first statement.  */\n-static inline gimple *\n+inline gimple *\n first_imm_use_stmt (imm_use_iterator *imm, tree var)\n {\n   imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n@@ -950,7 +950,7 @@ first_imm_use_stmt (imm_use_iterator *imm, tree var)\n \n /* Bump IMM to the next stmt which has a use of var.  */\n \n-static inline gimple *\n+inline gimple *\n next_imm_use_stmt (imm_use_iterator *imm)\n {\n   imm->imm_use = imm->iter_node.next;\n@@ -968,7 +968,7 @@ next_imm_use_stmt (imm_use_iterator *imm)\n /* This routine will return the first use on the stmt IMM currently refers\n    to.  */\n \n-static inline use_operand_p\n+inline use_operand_p\n first_imm_use_on_stmt (imm_use_iterator *imm)\n {\n   imm->next_imm_name = imm->imm_use->next;\n@@ -977,15 +977,15 @@ first_imm_use_on_stmt (imm_use_iterator *imm)\n \n /*  Return TRUE if the last use on the stmt IMM refers to has been visited.  */\n \n-static inline bool\n+inline bool\n end_imm_use_on_stmt_p (const imm_use_iterator *imm)\n {\n   return (imm->imm_use == &(imm->iter_node));\n }\n \n /* Bump to the next use on the stmt IMM refers to, return NULL if done.  */\n \n-static inline use_operand_p\n+inline use_operand_p\n next_imm_use_on_stmt (imm_use_iterator *imm)\n {\n   imm->imm_use = imm->next_imm_name;\n@@ -999,7 +999,7 @@ next_imm_use_on_stmt (imm_use_iterator *imm)\n }\n \n /* Delink all immediate_use information for STMT.  */\n-static inline void\n+inline void\n delink_stmt_imm_use (gimple *stmt)\n {\n    ssa_op_iter iter;"}, {"sha": "64cd5a492580e32b8533fa0afd1a4a302a2cc358", "filename": "gcc/system.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -1166,7 +1166,7 @@ extern void fancy_abort (const char *, int, const char *)\n    so does GCC 3.4.x (PR17436).  */\n #define CONST_CAST2(TOTYPE,FROMTYPE,X) ((__extension__(union {FROMTYPE _q; TOTYPE _nq;})(X))._nq)\n #elif defined(__GNUC__)\n-static inline char *\n+inline char *\n helper_const_non_const_cast (const char *p)\n {\n   union {\n@@ -1308,15 +1308,15 @@ void gcc_stablesort_r (void *, size_t, size_t, sort_r_cmp_fn *, void *data);\n \n /* Return true if STR string starts with PREFIX.  */\n \n-static inline bool\n+inline bool\n startswith (const char *str, const char *prefix)\n {\n   return strncmp (str, prefix, strlen (prefix)) == 0;\n }\n \n /* Return true if STR string ends with SUFFIX.  */\n \n-static inline bool\n+inline bool\n endswith (const char *str, const char *suffix)\n {\n   size_t str_len = strlen (str);"}, {"sha": "daedf66017f6b0b807d8f9e46127f8f2a2442abb", "filename": "gcc/target-globals.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -69,7 +69,7 @@ extern class target_globals default_target_globals;\n extern class target_globals *save_target_globals (void);\n extern class target_globals *save_target_globals_default_opts (void);\n \n-static inline void\n+inline void\n restore_target_globals (class target_globals *g)\n {\n   this_target_flag_state = g->flag_state;"}, {"sha": "fdb364ca4512cc6a2aa9688f3a07024b65fe8fe9", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -279,7 +279,7 @@ extern struct gcc_target targetm;\n    runtime value is needed for correctness, since the function only\n    provides a rough guess.  */\n \n-static inline HOST_WIDE_INT\n+inline HOST_WIDE_INT\n estimated_poly_value (poly_int64 x,\n \t\t      poly_value_estimate_kind kind = POLY_VALUE_LIKELY)\n {\n@@ -295,7 +295,7 @@ estimated_poly_value (poly_int64 x,\n #define CUMULATIVE_ARGS_MAGIC ((void *) &targetm.calls)\n #endif\n \n-static inline CUMULATIVE_ARGS *\n+inline CUMULATIVE_ARGS *\n get_cumulative_args (cumulative_args_t arg)\n {\n #if CHECKING_P\n@@ -304,7 +304,7 @@ get_cumulative_args (cumulative_args_t arg)\n   return (CUMULATIVE_ARGS *) arg.p;\n }\n \n-static inline cumulative_args_t\n+inline cumulative_args_t\n pack_cumulative_args (CUMULATIVE_ARGS *arg)\n {\n   cumulative_args_t ret;"}, {"sha": "ad46573160957c6461190204c5181ec9e904e204", "filename": "gcc/timevar.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -206,14 +206,14 @@ class timer\n };\n \n /* Provided for backward compatibility.  */\n-static inline void\n+inline void\n timevar_push (timevar_id_t tv)\n {\n   if (g_timer)\n     g_timer->push (tv);\n }\n \n-static inline void\n+inline void\n timevar_pop (timevar_id_t tv)\n {\n   if (g_timer)"}, {"sha": "9c412dc879a00a8f65b5ae7603d8537303193448", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n /* After having added an automatically generated element, please\n    include it in the following function.  */\n \n-static inline bool\n+inline bool\n automatically_generated_chrec_p (const_tree chrec)\n {\n   return (chrec == chrec_dont_know\n@@ -44,7 +44,7 @@ automatically_generated_chrec_p (const_tree chrec)\n \n /* The tree nodes aka. CHRECs.  */\n \n-static inline bool\n+inline bool\n tree_is_chrec (const_tree expr)\n {\n   if (TREE_CODE (expr) == POLYNOMIAL_CHREC\n@@ -96,7 +96,7 @@ extern bool evolution_function_right_is_integer_cst (const_tree);\n \n /* Determines whether CHREC is equal to zero.  */\n \n-static inline bool\n+inline bool\n chrec_zerop (const_tree chrec)\n {\n   if (chrec == NULL_TREE)\n@@ -111,7 +111,7 @@ chrec_zerop (const_tree chrec)\n /* Determines whether CHREC is a loop invariant with respect to LOOP_NUM.\n    Set the result in RES and return true when the property can be computed.  */\n \n-static inline bool\n+inline bool\n no_evolution_in_loop_p (tree chrec, unsigned loop_num, bool *res)\n {\n   tree scev;\n@@ -129,7 +129,7 @@ no_evolution_in_loop_p (tree chrec, unsigned loop_num, bool *res)\n \n /* Build a polynomial chain of recurrence.  */\n \n-static inline tree\n+inline tree\n build_polynomial_chrec (unsigned loop_num,\n \t\t\ttree left,\n \t\t\ttree right)\n@@ -167,7 +167,7 @@ build_polynomial_chrec (unsigned loop_num,\n \n /* Determines whether the expression CHREC is a constant.  */\n \n-static inline bool\n+inline bool\n evolution_function_is_constant_p (const_tree chrec)\n {\n   if (chrec == NULL_TREE)\n@@ -178,7 +178,7 @@ evolution_function_is_constant_p (const_tree chrec)\n \n /* Determine whether CHREC is an affine evolution function in LOOPNUM.  */\n \n-static inline bool\n+inline bool\n evolution_function_is_affine_in_loop (const_tree chrec, int loopnum)\n {\n   if (chrec == NULL_TREE)\n@@ -200,7 +200,7 @@ evolution_function_is_affine_in_loop (const_tree chrec, int loopnum)\n \n /* Determine whether CHREC is an affine evolution function or not.  */\n \n-static inline bool\n+inline bool\n evolution_function_is_affine_p (const_tree chrec)\n {\n   return chrec\n@@ -213,15 +213,15 @@ evolution_function_is_affine_p (const_tree chrec)\n \n /* Determines whether EXPR does not contains chrec expressions.  */\n \n-static inline bool\n+inline bool\n tree_does_not_contain_chrecs (const_tree expr)\n {\n   return !tree_contains_chrecs (expr, NULL);\n }\n \n /* Returns the type of the chrec.  */\n \n-static inline tree\n+inline tree\n chrec_type (const_tree chrec)\n {\n   if (automatically_generated_chrec_p (chrec))\n@@ -230,7 +230,7 @@ chrec_type (const_tree chrec)\n   return TREE_TYPE (chrec);\n }\n \n-static inline tree\n+inline tree\n chrec_fold_op (enum tree_code code, tree type, tree op0, tree op1)\n {\n   switch (code)"}, {"sha": "4d1a5c4a45e4ae428d0ca5ff1fab06b310c755d2", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -592,7 +592,7 @@ extern bool dr_known_forward_stride_p (struct data_reference *);\n /* Return true when the base objects of data references A and B are\n    the same memory object.  */\n \n-static inline bool\n+inline bool\n same_data_refs_base_objects (data_reference_p a, data_reference_p b)\n {\n   return DR_NUM_DIMENSIONS (a) == DR_NUM_DIMENSIONS (b)\n@@ -603,7 +603,7 @@ same_data_refs_base_objects (data_reference_p a, data_reference_p b)\n    memory object with the same access functions.  Optionally skip the\n    last OFFSET dimensions in the data reference.  */\n \n-static inline bool\n+inline bool\n same_data_refs (data_reference_p a, data_reference_p b, int offset = 0)\n {\n   unsigned int i;\n@@ -641,7 +641,7 @@ known_dependences_p (vec<ddr_p> dependence_relations)\n    LEVEL = 0 means a lexicographic dependence, i.e. a dependence due\n    to the sequence of statements, not carried by any loop.  */\n \n-static inline unsigned\n+inline unsigned\n dependence_level (lambda_vector dist_vect, int length)\n {\n   int i;\n@@ -655,7 +655,7 @@ dependence_level (lambda_vector dist_vect, int length)\n \n /* Return the dependence level for the DDR relation.  */\n \n-static inline unsigned\n+inline unsigned\n ddr_dependence_level (ddr_p ddr)\n {\n   unsigned vector;\n@@ -672,7 +672,7 @@ ddr_dependence_level (ddr_p ddr)\n \n /* Return the index of the variable VAR in the LOOP_NEST array.  */\n \n-static inline int\n+inline int\n index_in_loop_nest (int var, const vec<loop_p> &loop_nest)\n {\n   class loop *loopi;\n@@ -688,7 +688,7 @@ index_in_loop_nest (int var, const vec<loop_p> &loop_nest)\n /* Returns true when the data reference DR the form \"A[i] = ...\"\n    with a stride equal to its unit type size.  */\n \n-static inline bool\n+inline bool\n adjacent_dr_p (struct data_reference *dr)\n {\n   /* If this is a bitfield store bail out.  */\n@@ -709,7 +709,7 @@ void split_constant_offset (tree , tree *, tree *);\n \n /* Compute the greatest common divisor of a VECTOR of SIZE numbers.  */\n \n-static inline lambda_int\n+inline lambda_int\n lambda_vector_gcd (lambda_vector vector, int size)\n {\n   int i;\n@@ -726,7 +726,7 @@ lambda_vector_gcd (lambda_vector vector, int size)\n \n /* Allocate a new vector of given SIZE.  */\n \n-static inline lambda_vector\n+inline lambda_vector\n lambda_vector_new (int size)\n {\n   /* ???  We shouldn't abuse the GC allocator here.  */\n@@ -735,7 +735,7 @@ lambda_vector_new (int size)\n \n /* Clear out vector VEC1 of length SIZE.  */\n \n-static inline void\n+inline void\n lambda_vector_clear (lambda_vector vec1, int size)\n {\n   memset (vec1, 0, size * sizeof (*vec1));\n@@ -744,7 +744,7 @@ lambda_vector_clear (lambda_vector vec1, int size)\n /* Returns true when the vector V is lexicographically positive, in\n    other words, when the first nonzero element is positive.  */\n \n-static inline bool\n+inline bool\n lambda_vector_lexico_pos (lambda_vector v,\n \t\t\t  unsigned n)\n {\n@@ -763,7 +763,7 @@ lambda_vector_lexico_pos (lambda_vector v,\n \n /* Return true if vector VEC1 of length SIZE is the zero vector.  */\n \n-static inline bool\n+inline bool\n lambda_vector_zerop (lambda_vector vec1, int size)\n {\n   int i;\n@@ -775,7 +775,7 @@ lambda_vector_zerop (lambda_vector vec1, int size)\n \n /* Allocate a matrix of M rows x  N cols.  */\n \n-static inline lambda_matrix\n+inline lambda_matrix\n lambda_matrix_new (int m, int n, struct obstack *lambda_obstack)\n {\n   lambda_matrix mat;"}, {"sha": "800dd2e9c0ec96eea1039448f70b026816885203", "filename": "gcc/tree-iterator.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -49,7 +49,7 @@ struct tree_stmt_iterator {\n   tree operator* () const { return ptr->stmt; }\n };\n \n-static inline tree_stmt_iterator\n+inline tree_stmt_iterator\n tsi_start (tree t)\n {\n   tree_stmt_iterator i;\n@@ -60,7 +60,7 @@ tsi_start (tree t)\n   return i;\n }\n \n-static inline tree_stmt_iterator\n+inline tree_stmt_iterator\n tsi_last (tree t)\n {\n   tree_stmt_iterator i;\n@@ -71,37 +71,37 @@ tsi_last (tree t)\n   return i;\n }\n \n-static inline bool\n+inline bool\n tsi_end_p (tree_stmt_iterator i)\n {\n   return i.ptr == NULL;\n }\n \n-static inline bool\n+inline bool\n tsi_one_before_end_p (tree_stmt_iterator i)\n {\n   return i.ptr != NULL && i.ptr->next == NULL;\n }\n \n-static inline void\n+inline void\n tsi_next (tree_stmt_iterator *i)\n {\n   ++(*i);\n }\n \n-static inline void\n+inline void\n tsi_prev (tree_stmt_iterator *i)\n {\n   --(*i);\n }\n \n-static inline tree *\n+inline tree *\n tsi_stmt_ptr (tree_stmt_iterator i)\n {\n   return &(*i);\n }\n \n-static inline tree\n+inline tree\n tsi_stmt (tree_stmt_iterator i)\n {\n   return *i;"}, {"sha": "d69c5a7e68d1c6011744f216b032690a1678c499", "filename": "gcc/tree-outof-ssa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-outof-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-outof-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -53,7 +53,7 @@ extern struct ssaexpand SA;\n \n /* Returns the RTX expression representing the storage of the outof-SSA\n    partition that the SSA name EXP is a member of.  */\n-static inline rtx\n+inline rtx\n get_rtx_for_ssa_name (tree exp)\n {\n   int p = partition_find (SA.map->var_partition, SSA_NAME_VERSION (exp));\n@@ -65,7 +65,7 @@ get_rtx_for_ssa_name (tree exp)\n \n /* If TER decided to forward the definition of SSA name EXP this function\n    returns the defining statement, otherwise NULL.  */\n-static inline gimple *\n+inline gimple *\n get_gimple_for_ssa_name (tree exp)\n {\n   int v = SSA_NAME_VERSION (exp);"}, {"sha": "932a461e987d4196be74bb4d5164fe9a03f09010", "filename": "gcc/tree-phinodes.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-phinodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-phinodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -31,15 +31,15 @@ extern void remove_phi_nodes (basic_block);\n extern tree degenerate_phi_result (gphi *);\n extern void set_phi_nodes (basic_block, gimple_seq);\n \n-static inline use_operand_p\n+inline use_operand_p\n gimple_phi_arg_imm_use_ptr (gimple *gs, int i)\n {\n   return &gimple_phi_arg (gs, i)->imm_use;\n }\n \n /* Return the phi argument which contains the specified use.  */\n \n-static inline int\n+inline int\n phi_arg_index_from_use (use_operand_p use)\n {\n   struct phi_arg_d *element, *root;"}, {"sha": "c58a8a16e81573aada38e912b7c58b3e1b23b66d", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -46,7 +46,7 @@ extern tree compute_overall_effect_of_inner_loop (class loop *, tree);\n /* Returns the basic block preceding LOOP, or the CFG entry block when\n    the loop is function's body.  */\n \n-static inline basic_block\n+inline basic_block\n block_before_loop (loop_p loop)\n {\n   edge preheader = loop_preheader_edge (loop);\n@@ -57,15 +57,15 @@ block_before_loop (loop_p loop)\n    symbolic form.  LOOP is the loop in which symbolic names have to\n    be analyzed and instantiated.  */\n \n-static inline tree\n+inline tree\n instantiate_parameters (class loop *loop, tree chrec)\n {\n   return instantiate_scev (loop_preheader_edge (loop), loop, chrec);\n }\n \n /* Returns the loop of the polynomial chrec CHREC.  */\n \n-static inline class loop *\n+inline class loop *\n get_chrec_loop (const_tree chrec)\n {\n   return get_loop (cfun, CHREC_VARIABLE (chrec));"}, {"sha": "f20266c46226f7840299a768cb575f6f92b54207", "filename": "gcc/tree-sra.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-sra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-sra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -24,7 +24,7 @@ bool type_internals_preclude_sra_p (tree type, const char **msg);\n /* Return true iff TYPE is stdarg va_list type (which early SRA and IPA-SRA\n    should leave alone).  */\n \n-static inline bool\n+inline bool\n is_va_list_type (tree type)\n {\n   return TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (va_list_type_node);"}, {"sha": "dce27323247ead414d6a03727da4d88b5badd112", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -186,7 +186,7 @@ extern GTY(()) struct pt_solution ipa_escaped_pt;\n    overlap.  SIZE1 and/or SIZE2 can be (unsigned)-1 in which case the\n    range is open-ended.  Otherwise return false.  */\n \n-static inline bool\n+inline bool\n ranges_overlap_p (HOST_WIDE_INT pos1,\n \t\t  unsigned HOST_WIDE_INT size1,\n \t\t  HOST_WIDE_INT pos2,"}, {"sha": "de665d6bad0f4ff34db387e1dd1282059c0e95d5", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -109,7 +109,7 @@ region_contains_p (var_map map, basic_block bb)\n \n /* Return number of partitions in MAP.  */\n \n-static inline unsigned\n+inline unsigned\n num_var_partitions (var_map map)\n {\n   return map->num_partitions;\n@@ -119,7 +119,7 @@ num_var_partitions (var_map map)\n /* Given partition index I from MAP, return the variable which represents that\n    partition.  */\n \n-static inline tree\n+inline tree\n partition_to_var (var_map map, int i)\n {\n   tree name;\n@@ -134,7 +134,7 @@ partition_to_var (var_map map, int i)\n /* Given ssa_name VERSION, if it has a partition in MAP,  return the var it\n    is associated with.  Otherwise return NULL.  */\n \n-static inline tree\n+inline tree\n version_to_var (var_map map, int version)\n {\n   int part;\n@@ -151,7 +151,7 @@ version_to_var (var_map map, int version)\n /* Given VAR, return the partition number in MAP which contains it.\n    NO_PARTITION is returned if it's not in any partition.  */\n \n-static inline int\n+inline int\n var_to_partition (var_map map, tree var)\n {\n   int part;\n@@ -166,7 +166,7 @@ var_to_partition (var_map map, tree var)\n /* Given VAR, return the variable which represents the entire partition\n    it is a member of in MAP.  NULL is returned if it is not in a partition.  */\n \n-static inline tree\n+inline tree\n var_to_partition_to_var (var_map map, tree var)\n {\n   int part;\n@@ -180,7 +180,7 @@ var_to_partition_to_var (var_map map, tree var)\n \n /* Return the index into the basevar table for PARTITION's base in MAP.  */\n \n-static inline int\n+inline int\n basevar_index (var_map map, int partition)\n {\n   gcc_checking_assert (partition >= 0\n@@ -191,7 +191,7 @@ basevar_index (var_map map, int partition)\n \n /* Return the number of different base variables in MAP.  */\n \n-static inline int\n+inline int\n num_basevars (var_map map)\n {\n   return map->num_basevars;\n@@ -274,7 +274,7 @@ extern void destroy_live_vars (vec<bitmap_head> &);\n \n /*  Return TRUE if P is marked as a global in LIVE.  */\n \n-static inline int\n+inline int\n partition_is_global (tree_live_info_p live, int p)\n {\n   gcc_checking_assert (live->global);\n@@ -285,7 +285,7 @@ partition_is_global (tree_live_info_p live, int p)\n /* Return the bitmap from LIVE representing the live on entry blocks for\n    partition P.  */\n \n-static inline bitmap\n+inline bitmap\n live_on_entry (tree_live_info_p live, basic_block bb)\n {\n   gcc_checking_assert (live->livein\n@@ -299,7 +299,7 @@ live_on_entry (tree_live_info_p live, basic_block bb)\n /* Return the bitmap from LIVE representing the live on exit partitions from\n    block BB.  */\n \n-static inline bitmap\n+inline bitmap\n live_on_exit (tree_live_info_p live, basic_block bb)\n {\n   gcc_checking_assert (live->liveout\n@@ -312,7 +312,7 @@ live_on_exit (tree_live_info_p live, basic_block bb)\n \n /* Return the partition map which the information in LIVE utilizes.  */\n \n-static inline var_map\n+inline var_map\n live_var_map (tree_live_info_p live)\n {\n   return live->map;\n@@ -321,7 +321,7 @@ live_var_map (tree_live_info_p live)\n \n /* Mark partition P as live on entry to basic block BB in LIVE.  */\n \n-static inline void\n+inline void\n make_live_on_entry (tree_live_info_p live, basic_block bb , int p)\n {\n   bitmap_set_bit (&live->livein[bb->index], p);"}, {"sha": "d49273a39874762b4e80a004f022a197df5e2e63", "filename": "gcc/tree-ssa-loop-manip.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-loop-manip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-loop-manip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -27,7 +27,7 @@ extern void create_iv (tree, tree, tree, class loop *, gimple_stmt_iterator *,\n extern void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n extern void verify_loop_closed_ssa (bool, class loop * = NULL);\n \n-static inline void\n+inline void\n checking_verify_loop_closed_ssa (bool verify_ssa_p, class loop *loop = NULL)\n {\n   if (flag_checking)"}, {"sha": "3fd4cd4546629dbfd88fa038e59ca44dd728cc6f", "filename": "gcc/tree-ssa-loop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -71,7 +71,7 @@ extern unsigned tree_num_loop_insns (class loop *, struct eni_weights *);\n \n /* Returns the loop of the statement STMT.  */\n \n-static inline class loop *\n+inline class loop *\n loop_containing_stmt (gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);"}, {"sha": "ae36bcdb893e3a4c80f594f9e6776838769378c1", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -106,14 +106,14 @@ extern void debug_immediate_uses_for (tree var);\n extern void unlink_stmt_vdef (gimple *);\n \n /* Return the tree pointed-to by USE.  */\n-static inline tree\n+inline tree\n get_use_from_ptr (use_operand_p use)\n {\n   return *(use->use);\n }\n \n /* Return the tree pointed-to by DEF.  */\n-static inline tree\n+inline tree\n get_def_from_ptr (def_operand_p def)\n {\n   return *def;"}, {"sha": "be4cb4578735421b2451e0a1146880c4988dc012", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -26,15 +26,15 @@ along with GCC; see the file COPYING3.  If not see\n \n /* If SIM_P is true, statement S will be simulated again.  */\n \n-static inline void\n+inline void\n prop_set_simulate_again (gimple *s, bool visit_p)\n {\n   gimple_set_visited (s, visit_p);\n }\n \n /* Return true if statement T should be simulated again.  */\n \n-static inline bool\n+inline bool\n prop_simulate_again_p (gimple *s)\n {\n   return gimple_visited_p (s);"}, {"sha": "675240ebb9d369eeaed33108119c0e1c90bb8d53", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -68,7 +68,7 @@ typedef const struct vn_nary_op_s *const_vn_nary_op_t;\n \n /* Return the size of a vn_nary_op_t with LENGTH operands.  */\n \n-static inline size_t\n+inline size_t\n sizeof_vn_nary_op (unsigned int length)\n {\n   return sizeof (struct vn_nary_op_s) + sizeof (tree) * length - sizeof (tree);\n@@ -166,7 +166,7 @@ enum vn_kind vn_get_stmt_kind (gimple *);\n /* Hash the type TYPE using bits that distinguishes it in the\n    types_compatible_p sense.  */\n \n-static inline hashval_t\n+inline hashval_t\n vn_hash_type (tree type)\n {\n   return (INTEGRAL_TYPE_P (type)\n@@ -177,7 +177,7 @@ vn_hash_type (tree type)\n /* Hash the constant CONSTANT with distinguishing type incompatible\n    constants in the types_compatible_p sense.  */\n \n-static inline hashval_t\n+inline hashval_t\n vn_hash_constant_with_type (tree constant)\n {\n   inchash::hash hstate;\n@@ -189,7 +189,7 @@ vn_hash_constant_with_type (tree constant)\n /* Compare the constants C1 and C2 with distinguishing type incompatible\n    constants in the types_compatible_p sense.  */\n \n-static inline bool\n+inline bool\n vn_constant_eq_with_type (tree c1, tree c2)\n {\n   return (expressions_equal_p (c1, c2)\n@@ -286,7 +286,7 @@ unsigned int get_constant_value_id (tree);\n unsigned int get_or_alloc_constant_value_id (tree);\n \n /* Return true if V is a value id for a constant.  */\n-static inline bool\n+inline bool\n value_id_constant_p (unsigned int v)\n {\n   return (int)v < 0;"}, {"sha": "fa8c8082311df1893bdb406d1eb8f8cdba8ea09f", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -63,7 +63,7 @@ extern void mark_ssa_maybe_undefs (void);\n /* Return TRUE iff VAR is marked as maybe-undefined.  See\n    mark_ssa_maybe_undefs.  */\n \n-static inline bool\n+inline bool\n ssa_name_maybe_undef_p (tree var)\n {\n   gcc_checking_assert (TREE_CODE (var) == SSA_NAME);\n@@ -72,7 +72,7 @@ ssa_name_maybe_undef_p (tree var)\n \n /* Set (or clear, depending on VALUE) VAR's maybe-undefined mark.  */\n \n-static inline void\n+inline void\n ssa_name_set_maybe_undef (tree var, bool value = true)\n {\n   gcc_checking_assert (TREE_CODE (var) == SSA_NAME);\n@@ -84,31 +84,31 @@ extern void execute_update_addresses_taken (void);\n \n /* Given an edge_var_map V, return the PHI arg definition.  */\n \n-static inline tree\n+inline tree\n redirect_edge_var_map_def (edge_var_map *v)\n {\n   return v->def;\n }\n \n /* Given an edge_var_map V, return the PHI result.  */\n \n-static inline tree\n+inline tree\n redirect_edge_var_map_result (edge_var_map *v)\n {\n   return v->result;\n }\n \n /* Given an edge_var_map V, return the PHI arg location.  */\n \n-static inline location_t\n+inline location_t\n redirect_edge_var_map_location (edge_var_map *v)\n {\n   return v->locus;\n }\n \n /* Verify SSA invariants, if internal consistency checks are enabled.  */\n \n-static inline void\n+inline void\n checking_verify_ssa (bool check_modified_stmt, bool check_ssa_operands)\n {\n   if (flag_checking)"}, {"sha": "b09e71bf7793c0117de703627348f45b8921fbad", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -91,7 +91,7 @@ extern void flush_ssaname_freelist (void);\n /* Return an SSA_NAME node for variable VAR defined in statement STMT\n    in function cfun.  */\n \n-static inline tree\n+inline tree\n make_ssa_name (tree var, gimple *stmt = NULL)\n {\n   return make_ssa_name_fn (cfun, var, stmt);\n@@ -100,7 +100,7 @@ make_ssa_name (tree var, gimple *stmt = NULL)\n /* Return an SSA_NAME node using the template SSA name NAME defined in\n    statement STMT in function cfun.  */\n \n-static inline tree\n+inline tree\n copy_ssa_name (tree var, gimple *stmt = NULL)\n {\n   return copy_ssa_name_fn (cfun, var, stmt);\n@@ -109,15 +109,15 @@ copy_ssa_name (tree var, gimple *stmt = NULL)\n /*  Creates a duplicate of a SSA name NAME tobe defined by statement STMT\n     in function cfun.  */\n \n-static inline tree\n+inline tree\n duplicate_ssa_name (tree var, gimple *stmt)\n {\n   return duplicate_ssa_name_fn (cfun, var, stmt);\n }\n \n /* Release the SSA name NAME used in function cfun.  */\n \n-static inline void\n+inline void\n release_ssa_name (tree name)\n {\n   release_ssa_name_fn (cfun, name);\n@@ -126,7 +126,7 @@ release_ssa_name (tree name)\n /* Return an anonymous SSA_NAME node for type TYPE defined in statement STMT\n    in function cfun.  Arrange so that it uses NAME in dumps.  */\n \n-static inline tree\n+inline tree\n make_temp_ssa_name (tree type, gimple *stmt, const char *name)\n {\n   tree ssa_name;"}, {"sha": "170d61cf20b28822788b41ad4fe5081c1a3363e7", "filename": "gcc/tree-streamer.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -90,28 +90,28 @@ void streamer_tree_cache_delete (struct streamer_tree_cache_d *);\n \n /* Return the tree node at slot IX in CACHE.  */\n \n-static inline tree\n+inline tree\n streamer_tree_cache_get_tree (struct streamer_tree_cache_d *cache, unsigned ix)\n {\n   return cache->nodes[ix];\n }\n \n /* Return the tree hash value at slot IX in CACHE.  */\n \n-static inline hashval_t\n+inline hashval_t\n streamer_tree_cache_get_hash (struct streamer_tree_cache_d *cache, unsigned ix)\n {\n   return cache->hashes[ix];\n }\n \n-static inline void\n+inline void\n bp_pack_machine_mode (struct bitpack_d *bp, machine_mode mode)\n {\n   streamer_mode_table[mode] = 1;\n   bp_pack_enum (bp, machine_mode, 1 << 8, mode);\n }\n \n-static inline machine_mode\n+inline machine_mode\n bp_unpack_machine_mode (struct bitpack_d *bp)\n {\n   return (machine_mode)"}, {"sha": "4e97164e0ef13c5c208be1af9883d0e40ed00efc", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -914,7 +914,7 @@ switch_decision_tree::reset_out_edges_aux (gswitch *swtch)\n \n /* Release CLUSTERS vector and destruct all dynamically allocated items.  */\n \n-static inline void\n+inline void\n release_clusters (vec<cluster *> &clusters)\n {\n   for (unsigned i = 0; i < clusters.length (); i++)"}, {"sha": "9cf2fb23fe397b467d89aa7cc5ebeaa293ed4cce", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -969,7 +969,7 @@ typedef class _loop_vec_info : public vec_info {\n    stack.  */\n typedef opt_pointer_wrapper <loop_vec_info> opt_loop_vec_info;\n \n-static inline loop_vec_info\n+inline loop_vec_info\n loop_vec_info_for_loop (class loop *loop)\n {\n   return (loop_vec_info) loop->aux;\n@@ -1641,7 +1641,7 @@ vector_costs::suggested_unroll_factor () const\n        && TYPE_PRECISION (TYPE) == 1\t\t\\\n        && TYPE_UNSIGNED (TYPE)))\n \n-static inline bool\n+inline bool\n nested_in_vect_loop_p (class loop *loop, stmt_vec_info stmt_info)\n {\n   return (loop->inner\n@@ -1652,7 +1652,7 @@ nested_in_vect_loop_p (class loop *loop, stmt_vec_info stmt_info)\n    Return the initial value of the variable on entry to the containing\n    loop.  */\n \n-static inline tree\n+inline tree\n vect_phi_initial_value (gphi *phi)\n {\n   basic_block bb = gimple_bb (phi);\n@@ -1664,7 +1664,7 @@ vect_phi_initial_value (gphi *phi)\n /* Return true if STMT_INFO should produce a vector mask type rather than\n    a normal nonmask type.  */\n \n-static inline bool\n+inline bool\n vect_use_mask_type_p (stmt_vec_info stmt_info)\n {\n   return stmt_info->mask_precision && stmt_info->mask_precision != ~0U;\n@@ -1673,7 +1673,7 @@ vect_use_mask_type_p (stmt_vec_info stmt_info)\n /* Return TRUE if a statement represented by STMT_INFO is a part of a\n    pattern.  */\n \n-static inline bool\n+inline bool\n is_pattern_stmt_p (stmt_vec_info stmt_info)\n {\n   return stmt_info->pattern_stmt_p;\n@@ -1692,7 +1692,7 @@ vect_orig_stmt (stmt_vec_info stmt_info)\n \n /* Return the later statement between STMT1_INFO and STMT2_INFO.  */\n \n-static inline stmt_vec_info\n+inline stmt_vec_info\n get_later_stmt (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info)\n {\n   if (gimple_uid (vect_orig_stmt (stmt1_info)->stmt)\n@@ -1715,7 +1715,7 @@ vect_stmt_to_vectorize (stmt_vec_info stmt_info)\n \n /* Return true if BB is a loop header.  */\n \n-static inline bool\n+inline bool\n is_loop_header_bb_p (basic_block bb)\n {\n   if (bb == (bb->loop_father)->header)\n@@ -1726,7 +1726,7 @@ is_loop_header_bb_p (basic_block bb)\n \n /* Return pow2 (X).  */\n \n-static inline int\n+inline int\n vect_pow2 (int x)\n {\n   int i, res = 1;\n@@ -1739,7 +1739,7 @@ vect_pow2 (int x)\n \n /* Alias targetm.vectorize.builtin_vectorization_cost.  */\n \n-static inline int\n+inline int\n builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \t\t\t    tree vectype, int misalign)\n {\n@@ -1749,15 +1749,15 @@ builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \n /* Get cost by calling cost target builtin.  */\n \n-static inline\n+inline\n int vect_get_stmt_cost (enum vect_cost_for_stmt type_of_cost)\n {\n   return builtin_vectorization_cost (type_of_cost, NULL, 0);\n }\n \n /* Alias targetm.vectorize.init_cost.  */\n \n-static inline vector_costs *\n+inline vector_costs *\n init_cost (vec_info *vinfo, bool costing_for_scalar)\n {\n   return targetm.vectorize.create_costs (vinfo, costing_for_scalar);\n@@ -1769,7 +1769,7 @@ extern void dump_stmt_cost (FILE *, int, enum vect_cost_for_stmt,\n \n /* Alias targetm.vectorize.add_stmt_cost.  */\n \n-static inline unsigned\n+inline unsigned\n add_stmt_cost (vector_costs *costs, int count,\n \t       enum vect_cost_for_stmt kind,\n \t       stmt_vec_info stmt_info, slp_tree node,\n@@ -1784,7 +1784,7 @@ add_stmt_cost (vector_costs *costs, int count,\n   return cost;\n }\n \n-static inline unsigned\n+inline unsigned\n add_stmt_cost (vector_costs *costs, int count, enum vect_cost_for_stmt kind,\n \t       enum vect_cost_model_location where)\n {\n@@ -1795,7 +1795,7 @@ add_stmt_cost (vector_costs *costs, int count, enum vect_cost_for_stmt kind,\n \n /* Alias targetm.vectorize.add_stmt_cost.  */\n \n-static inline unsigned\n+inline unsigned\n add_stmt_cost (vector_costs *costs, stmt_info_for_cost *i)\n {\n   return add_stmt_cost (costs, i->count, i->kind, i->stmt_info, i->node,\n@@ -1804,7 +1804,7 @@ add_stmt_cost (vector_costs *costs, stmt_info_for_cost *i)\n \n /* Alias targetm.vectorize.finish_cost.  */\n \n-static inline void\n+inline void\n finish_cost (vector_costs *costs, const vector_costs *scalar_costs,\n \t     unsigned *prologue_cost, unsigned *body_cost,\n \t     unsigned *epilogue_cost, unsigned *suggested_unroll_factor = NULL)\n@@ -1845,7 +1845,7 @@ extern int dr_misalignment (dr_vec_info *dr_info, tree vectype,\n #define SET_DR_MISALIGNMENT(DR, VAL) set_dr_misalignment (DR, VAL)\n \n /* Only defined once DR_MISALIGNMENT is defined.  */\n-static inline const poly_uint64\n+inline const poly_uint64\n dr_target_alignment (dr_vec_info *dr_info)\n {\n   if (STMT_VINFO_GROUPED_ACCESS (dr_info->stmt))\n@@ -1854,7 +1854,7 @@ dr_target_alignment (dr_vec_info *dr_info)\n }\n #define DR_TARGET_ALIGNMENT(DR) dr_target_alignment (DR)\n \n-static inline void\n+inline void\n set_dr_target_alignment (dr_vec_info *dr_info, poly_uint64 val)\n {\n   dr_info->target_alignment = val;\n@@ -1864,7 +1864,7 @@ set_dr_target_alignment (dr_vec_info *dr_info, poly_uint64 val)\n /* Return true if data access DR_INFO is aligned to the targets\n    preferred alignment for VECTYPE (which may be less than a full vector).  */\n \n-static inline bool\n+inline bool\n aligned_access_p (dr_vec_info *dr_info, tree vectype)\n {\n   return (dr_misalignment (dr_info, vectype) == 0);\n@@ -1874,7 +1874,7 @@ aligned_access_p (dr_vec_info *dr_info, tree vectype)\n    respect to the targets preferred alignment for VECTYPE, and FALSE\n    otherwise.  */\n \n-static inline bool\n+inline bool\n known_alignment_for_access_p (dr_vec_info *dr_info, tree vectype)\n {\n   return (dr_misalignment (dr_info, vectype) != DR_MISALIGNMENT_UNKNOWN);\n@@ -1883,7 +1883,7 @@ known_alignment_for_access_p (dr_vec_info *dr_info, tree vectype)\n /* Return the minimum alignment in bytes that the vectorized version\n    of DR_INFO is guaranteed to have.  */\n \n-static inline unsigned int\n+inline unsigned int\n vect_known_alignment_in_bytes (dr_vec_info *dr_info, tree vectype)\n {\n   int misalignment = dr_misalignment (dr_info, vectype);\n@@ -1898,7 +1898,7 @@ vect_known_alignment_in_bytes (dr_vec_info *dr_info, tree vectype)\n    (which for outer loop vectorization might not be the behavior recorded\n    in DR_INFO itself).  */\n \n-static inline innermost_loop_behavior *\n+inline innermost_loop_behavior *\n vect_dr_behavior (vec_info *vinfo, dr_vec_info *dr_info)\n {\n   stmt_vec_info stmt_info = dr_info->stmt;\n@@ -1936,7 +1936,7 @@ get_dr_vinfo_offset (vec_info *vinfo,\n \n \n /* Return the vect cost model for LOOP.  */\n-static inline enum vect_cost_model\n+inline enum vect_cost_model\n loop_cost_model (loop_p loop)\n {\n   if (loop != NULL\n@@ -1947,7 +1947,7 @@ loop_cost_model (loop_p loop)\n }\n \n /* Return true if the vect cost model is unlimited.  */\n-static inline bool\n+inline bool\n unlimited_cost_model (loop_p loop)\n {\n   return loop_cost_model (loop) == VECT_COST_MODEL_UNLIMITED;\n@@ -1957,7 +1957,7 @@ unlimited_cost_model (loop_p loop)\n    if the first iteration should use a partial mask in order to achieve\n    alignment.  */\n \n-static inline bool\n+inline bool\n vect_use_loop_mask_for_alignment_p (loop_vec_info loop_vinfo)\n {\n   return (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n@@ -1968,7 +1968,7 @@ vect_use_loop_mask_for_alignment_p (loop_vec_info loop_vinfo)\n    NUNITS elements.  NUNITS should be based on the vectorization factor,\n    so it is always a known multiple of the number of elements in VECTYPE.  */\n \n-static inline unsigned int\n+inline unsigned int\n vect_get_num_vectors (poly_uint64 nunits, tree vectype)\n {\n   return exact_div (nunits, TYPE_VECTOR_SUBPARTS (vectype)).to_constant ();\n@@ -1979,7 +1979,7 @@ vect_get_num_vectors (poly_uint64 nunits, tree vectype)\n    vectorization factor divided by the number of elements in\n    VECTYPE and is always known at compile time.  */\n \n-static inline unsigned int\n+inline unsigned int\n vect_get_num_copies (loop_vec_info loop_vinfo, tree vectype)\n {\n   return vect_get_num_vectors (LOOP_VINFO_VECT_FACTOR (loop_vinfo), vectype);\n@@ -1988,7 +1988,7 @@ vect_get_num_copies (loop_vec_info loop_vinfo, tree vectype)\n /* Update maximum unit count *MAX_NUNITS so that it accounts for\n    NUNITS.  *MAX_NUNITS can be 1 if we haven't yet recorded anything.  */\n \n-static inline void\n+inline void\n vect_update_max_nunits (poly_uint64 *max_nunits, poly_uint64 nunits)\n {\n   /* All unit counts have the form vec_info::vector_size * X for some\n@@ -2001,7 +2001,7 @@ vect_update_max_nunits (poly_uint64 *max_nunits, poly_uint64 nunits)\n    the number of units in vector type VECTYPE.  *MAX_NUNITS can be 1\n    if we haven't yet recorded any vector types.  */\n \n-static inline void\n+inline void\n vect_update_max_nunits (poly_uint64 *max_nunits, tree vectype)\n {\n   vect_update_max_nunits (max_nunits, TYPE_VECTOR_SUBPARTS (vectype));\n@@ -2012,7 +2012,7 @@ vect_update_max_nunits (poly_uint64 *max_nunits, tree vectype)\n    Pick a reasonable estimate if the vectorization factor isn't\n    known at compile time.  */\n \n-static inline unsigned int\n+inline unsigned int\n vect_vf_for_cost (loop_vec_info loop_vinfo)\n {\n   return estimated_poly_value (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n@@ -2022,15 +2022,15 @@ vect_vf_for_cost (loop_vec_info loop_vinfo)\n    Pick a reasonable estimate if the exact number isn't known at\n    compile time.  */\n \n-static inline unsigned int\n+inline unsigned int\n vect_nunits_for_cost (tree vec_type)\n {\n   return estimated_poly_value (TYPE_VECTOR_SUBPARTS (vec_type));\n }\n \n /* Return the maximum possible vectorization factor for LOOP_VINFO.  */\n \n-static inline unsigned HOST_WIDE_INT\n+inline unsigned HOST_WIDE_INT\n vect_max_vf (loop_vec_info loop_vinfo)\n {\n   unsigned HOST_WIDE_INT vf;\n@@ -2160,7 +2160,7 @@ extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n \n /* Overload of record_stmt_cost with VECTYPE derived from STMT_INFO.  */\n \n-static inline unsigned\n+inline unsigned\n record_stmt_cost (stmt_vector_for_cost *body_cost_vec, int count,\n \t\t  enum vect_cost_for_stmt kind, stmt_vec_info stmt_info,\n \t\t  int misalign, enum vect_cost_model_location where)"}, {"sha": "92ac0e6a2143c85259d842395fa16da458254f47", "filename": "gcc/tree.h", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -1280,7 +1280,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    location.  */\n #define CAN_HAVE_LOCATION_P(NODE) ((NODE) && EXPR_P (NODE))\n \n-static inline source_range\n+inline source_range\n get_expr_source_range (tree expr)\n {\n   location_t loc = EXPR_LOCATION (expr);\n@@ -3263,7 +3263,7 @@ extern void decl_fini_priority_insert (tree, priority_type);\n /* Set decl_type of a DECL.  Set it to T when SET is true, or reset\n    it to NONE.  */\n \n-static inline void\n+inline void\n set_function_decl_type (tree decl, function_decl_type t, bool set)\n {\n   if (set)\n@@ -4009,7 +4009,7 @@ any_integral_type_check (const_tree __t, const char *__f, int __l,\n /* Compute the number of operands in an expression node NODE.  For\n    tcc_vl_exp nodes like CALL_EXPRs, this is stored in the node itself,\n    otherwise it is looked up from the node's code.  */\n-static inline int\n+inline int\n tree_operand_length (const_tree node)\n {\n   if (VL_EXP_CLASS_P (node))\n@@ -4139,7 +4139,7 @@ SET_TYPE_VECTOR_SUBPARTS (tree node, poly_uint64 subparts)\n /* Return true if we can construct vector types with the given number\n    of subparts.  */\n \n-static inline bool\n+inline bool\n valid_vector_subparts_p (poly_uint64 subparts)\n {\n   unsigned HOST_WIDE_INT coeff0 = subparts.coeffs[0];\n@@ -4587,7 +4587,7 @@ extern tree build5 (enum tree_code, tree, tree, tree, tree, tree,\n \n /* _loc versions of build[1-5].  */\n \n-static inline tree\n+inline tree\n build1_loc (location_t loc, enum tree_code code, tree type,\n \t    tree arg1 CXX_MEM_STAT_INFO)\n {\n@@ -4597,7 +4597,7 @@ build1_loc (location_t loc, enum tree_code code, tree type,\n   return t;\n }\n \n-static inline tree\n+inline tree\n build2_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n \t    tree arg1 CXX_MEM_STAT_INFO)\n {\n@@ -4607,7 +4607,7 @@ build2_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n   return t;\n }\n \n-static inline tree\n+inline tree\n build3_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n \t    tree arg1, tree arg2 CXX_MEM_STAT_INFO)\n {\n@@ -4617,7 +4617,7 @@ build3_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n   return t;\n }\n \n-static inline tree\n+inline tree\n build4_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n \t    tree arg1, tree arg2, tree arg3 CXX_MEM_STAT_INFO)\n {\n@@ -4627,7 +4627,7 @@ build4_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n   return t;\n }\n \n-static inline tree\n+inline tree\n build5_loc (location_t loc, enum tree_code code, tree type, tree arg0,\n \t    tree arg1, tree arg2, tree arg3, tree arg4 CXX_MEM_STAT_INFO)\n {\n@@ -5174,7 +5174,7 @@ extern tree get_narrower (tree, int *);\n \n /* Return true if T is an expression that get_inner_reference handles.  */\n \n-static inline bool\n+inline bool\n handled_component_p (const_tree t)\n {\n   switch (TREE_CODE (t))\n@@ -5195,7 +5195,7 @@ handled_component_p (const_tree t)\n \n /* Return true T is a component with reverse storage order.  */\n \n-static inline bool\n+inline bool\n reverse_storage_order_for_component_p (tree t)\n {\n   /* The storage order only applies to scalar components.  */\n@@ -5233,7 +5233,7 @@ reverse_storage_order_for_component_p (tree t)\n    outer type, a VIEW_CONVERT_EXPR can modify the storage order because\n    it can change the partition of the aggregate object into scalars.  */\n \n-static inline bool\n+inline bool\n storage_order_barrier_p (const_tree t)\n {\n   if (TREE_CODE (t) != VIEW_CONVERT_EXPR)\n@@ -5274,7 +5274,7 @@ extern bool real_zerop (const_tree);\n \n /* Initialize the iterator I with arguments from function FNDECL  */\n \n-static inline void\n+inline void\n function_args_iter_init (function_args_iterator *i, const_tree fntype)\n {\n   i->next = TYPE_ARG_TYPES (fntype);\n@@ -5283,7 +5283,7 @@ function_args_iter_init (function_args_iterator *i, const_tree fntype)\n /* Return a pointer that holds the next argument if there are more arguments to\n    handle, otherwise return NULL.  */\n \n-static inline tree *\n+inline tree *\n function_args_iter_cond_ptr (function_args_iterator *i)\n {\n   return (i->next) ? &TREE_VALUE (i->next) : NULL;\n@@ -5292,14 +5292,14 @@ function_args_iter_cond_ptr (function_args_iterator *i)\n /* Return the next argument if there are more arguments to handle, otherwise\n    return NULL.  */\n \n-static inline tree\n+inline tree\n function_args_iter_cond (function_args_iterator *i)\n {\n   return (i->next) ? TREE_VALUE (i->next) : NULL_TREE;\n }\n \n /* Advance to the next argument.  */\n-static inline void\n+inline void\n function_args_iter_next (function_args_iterator *i)\n {\n   gcc_assert (i->next != NULL_TREE);\n@@ -5311,7 +5311,7 @@ function_args_iter_next (function_args_iterator *i)\n    so the function returns true for all but the innermost and outermost\n    blocks into which an expression has been inlined.  */\n \n-static inline bool\n+inline bool\n inlined_function_outer_scope_p (const_tree block)\n {\n  return LOCATION_LOCUS (BLOCK_SOURCE_LOCATION (block)) != UNKNOWN_LOCATION;\n@@ -5385,23 +5385,23 @@ extern const char *combined_fn_name (combined_fn);\n    pointer.  Assumes all pointers are interchangeable, which is sort\n    of already assumed by gcc elsewhere IIRC.  */\n \n-static inline int\n+inline int\n struct_ptr_eq (const void *a, const void *b)\n {\n   const void * const * x = (const void * const *) a;\n   const void * const * y = (const void * const *) b;\n   return *x == *y;\n }\n \n-static inline hashval_t\n+inline hashval_t\n struct_ptr_hash (const void *a)\n {\n   const void * const * x = (const void * const *) a;\n   return (intptr_t)*x >> 4;\n }\n \n /* Return nonzero if CODE is a tree code that represents a truth value.  */\n-static inline bool\n+inline bool\n truth_value_p (enum tree_code code)\n {\n   return (TREE_CODE_CLASS (code) == tcc_comparison\n@@ -5412,7 +5412,7 @@ truth_value_p (enum tree_code code)\n \n /* Return whether TYPE is a type suitable for an offset for\n    a POINTER_PLUS_EXPR.  */\n-static inline bool\n+inline bool\n ptrofftype_p (tree type)\n {\n   return (INTEGRAL_TYPE_P (type)\n@@ -5423,7 +5423,7 @@ ptrofftype_p (tree type)\n /* Return true if the argument is a complete type or an array\n    of unknown bound (whose type is incomplete but) whose elements\n    have complete type.  */\n-static inline bool\n+inline bool\n complete_or_array_type_p (const_tree type)\n {\n   return COMPLETE_TYPE_P (type)\n@@ -5482,7 +5482,7 @@ extern void add_expr (const_tree, hash &, unsigned int = 0);\n \n /* Compat version until all callers are converted. Return hash for\n    TREE with SEED.  */\n-static inline hashval_t iterative_hash_expr(const_tree tree, hashval_t seed)\n+inline hashval_t iterative_hash_expr(const_tree tree, hashval_t seed)\n {\n   inchash::hash hstate (seed);\n   inchash::add_expr (tree, hstate);\n@@ -5776,15 +5776,15 @@ typedef hash_map<tree,tree,decl_tree_traits> decl_tree_map;\n \n /* Initialize the abstract argument list iterator object ITER with the\n    arguments from CALL_EXPR node EXP.  */\n-static inline void\n+inline void\n init_call_expr_arg_iterator (tree exp, call_expr_arg_iterator *iter)\n {\n   iter->t = exp;\n   iter->n = call_expr_nargs (exp);\n   iter->i = 0;\n }\n \n-static inline void\n+inline void\n init_const_call_expr_arg_iterator (const_tree exp, const_call_expr_arg_iterator *iter)\n {\n   iter->t = exp;\n@@ -5794,7 +5794,7 @@ init_const_call_expr_arg_iterator (const_tree exp, const_call_expr_arg_iterator\n \n /* Return the next argument from abstract argument list iterator object ITER,\n    and advance its state.  Return NULL_TREE if there are no more arguments.  */\n-static inline tree\n+inline tree\n next_call_expr_arg (call_expr_arg_iterator *iter)\n {\n   tree result;\n@@ -5805,7 +5805,7 @@ next_call_expr_arg (call_expr_arg_iterator *iter)\n   return result;\n }\n \n-static inline const_tree\n+inline const_tree\n next_const_call_expr_arg (const_call_expr_arg_iterator *iter)\n {\n   const_tree result;\n@@ -5820,14 +5820,14 @@ next_const_call_expr_arg (const_call_expr_arg_iterator *iter)\n    past and return the first argument.  Useful in for expressions, e.g.\n      for (arg = first_call_expr_arg (exp, &iter); arg;\n           arg = next_call_expr_arg (&iter))   */\n-static inline tree\n+inline tree\n first_call_expr_arg (tree exp, call_expr_arg_iterator *iter)\n {\n   init_call_expr_arg_iterator (exp, iter);\n   return next_call_expr_arg (iter);\n }\n \n-static inline const_tree\n+inline const_tree\n first_const_call_expr_arg (const_tree exp, const_call_expr_arg_iterator *iter)\n {\n   init_const_call_expr_arg_iterator (exp, iter);\n@@ -5836,7 +5836,7 @@ first_const_call_expr_arg (const_tree exp, const_call_expr_arg_iterator *iter)\n \n /* Test whether there are more arguments in abstract argument list iterator\n    ITER, without changing its state.  */\n-static inline bool\n+inline bool\n more_call_expr_args_p (const call_expr_arg_iterator *iter)\n {\n   return (iter->i < iter->n);\n@@ -5853,7 +5853,7 @@ more_call_expr_args_p (const call_expr_arg_iterator *iter)\n        (arg) = next_const_call_expr_arg (&(iter)))\n \n /* Return true if tree node T is a language-specific node.  */\n-static inline bool\n+inline bool\n is_lang_specific (const_tree t)\n {\n   return TREE_CODE (t) == LANG_TYPE || TREE_CODE (t) >= NUM_TREE_CODES;\n@@ -5871,7 +5871,7 @@ is_lang_specific (const_tree t)\n   (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (builtin_decl_explicit (BUILTIN))))\n \n /* Return the tree node for an explicit standard builtin function or NULL.  */\n-static inline tree\n+inline tree\n builtin_decl_explicit (enum built_in_function fncode)\n {\n   gcc_checking_assert (BUILTIN_VALID_P (fncode));\n@@ -5880,7 +5880,7 @@ builtin_decl_explicit (enum built_in_function fncode)\n }\n \n /* Return the tree node for an implicit builtin function or NULL.  */\n-static inline tree\n+inline tree\n builtin_decl_implicit (enum built_in_function fncode)\n {\n   size_t uns_fncode = (size_t)fncode;\n@@ -5900,7 +5900,7 @@ extern tree build_builtin_unreachable (location_t);\n /* Set explicit builtin function nodes and whether it is an implicit\n    function.  */\n \n-static inline void\n+inline void\n set_builtin_decl (enum built_in_function fncode, tree decl, bool implicit_p)\n {\n   size_t ufncode = (size_t)fncode;\n@@ -5915,7 +5915,7 @@ set_builtin_decl (enum built_in_function fncode, tree decl, bool implicit_p)\n \n /* Set the implicit flag for a builtin function.  */\n \n-static inline void\n+inline void\n set_builtin_decl_implicit_p (enum built_in_function fncode, bool implicit_p)\n {\n   size_t uns_fncode = (size_t)fncode;\n@@ -5928,7 +5928,7 @@ set_builtin_decl_implicit_p (enum built_in_function fncode, bool implicit_p)\n \n /* Set the declared flag for a builtin function.  */\n \n-static inline void\n+inline void\n set_builtin_decl_declared_p (enum built_in_function fncode, bool declared_p)\n {\n   size_t uns_fncode = (size_t)fncode;\n@@ -5942,7 +5942,7 @@ set_builtin_decl_declared_p (enum built_in_function fncode, bool declared_p)\n /* Return whether the standard builtin function can be used as an explicit\n    function.  */\n \n-static inline bool\n+inline bool\n builtin_decl_explicit_p (enum built_in_function fncode)\n {\n   gcc_checking_assert (BUILTIN_VALID_P (fncode));\n@@ -5951,7 +5951,7 @@ builtin_decl_explicit_p (enum built_in_function fncode)\n \n /* Return whether the standard builtin function can be used implicitly.  */\n \n-static inline bool\n+inline bool\n builtin_decl_implicit_p (enum built_in_function fncode)\n {\n   size_t uns_fncode = (size_t)fncode;\n@@ -5963,7 +5963,7 @@ builtin_decl_implicit_p (enum built_in_function fncode)\n \n /* Return whether the standard builtin function was declared.  */\n \n-static inline bool\n+inline bool\n builtin_decl_declared_p (enum built_in_function fncode)\n {\n   size_t uns_fncode = (size_t)fncode;\n@@ -5983,7 +5983,7 @@ builtin_decl_declared_p (enum built_in_function fncode)\n    Avoid using this, as it's generally better to use attributes rather\n    than to check for functions by name.  */\n \n-static inline bool\n+inline bool\n maybe_special_function_p (const_tree fndecl)\n {\n   tree name_decl = DECL_NAME (fndecl);\n@@ -6001,7 +6001,7 @@ maybe_special_function_p (const_tree fndecl)\n /* Return true if T (assumed to be a DECL) is a global variable.\n    A variable is considered global if its storage is not automatic.  */\n \n-static inline bool\n+inline bool\n is_global_var (const_tree t)\n {\n   return (TREE_STATIC (t) || DECL_EXTERNAL (t));\n@@ -6011,7 +6011,7 @@ is_global_var (const_tree t)\n    maybe aliased if it has its address taken by the local TU\n    or possibly by another TU and might be modified through a pointer.  */\n \n-static inline bool\n+inline bool\n may_be_aliased (const_tree var)\n {\n   return (TREE_CODE (var) != CONST_DECL\n@@ -6025,7 +6025,7 @@ may_be_aliased (const_tree var)\n }\n \n /* Return pointer to optimization flags of FNDECL.  */\n-static inline struct cl_optimization *\n+inline struct cl_optimization *\n opts_for_fn (const_tree fndecl)\n {\n   tree fn_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n@@ -6035,7 +6035,7 @@ opts_for_fn (const_tree fndecl)\n }\n \n /* Return pointer to target flags of FNDECL.  */\n-static inline cl_target_option *\n+inline cl_target_option *\n target_opts_for_fn (const_tree fndecl)\n {\n   tree fn_opts = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);"}, {"sha": "a450a744c9f27b1807a26a1b5e84067f193b9c67", "filename": "gcc/wide-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3e0eac262e55774949b1717c64da383adbc621/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=cb3e0eac262e55774949b1717c64da383adbc621", "patch": "@@ -3495,7 +3495,7 @@ wi::set_bit_in_zero (unsigned int bit)\n \n /* Accumulate a set of overflows into OVERFLOW.  */\n \n-static inline void\n+inline void\n wi::accumulate_overflow (wi::overflow_type &overflow,\n \t\t\t wi::overflow_type suboverflow)\n {"}]}