{"sha": "4ca827d08d50dbe8e8b8ec6c594c50e8c6d89236", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNhODI3ZDA4ZDUwZGJlOGU4YjhlYzZjNTk0YzUwZThjNmQ4OTIzNg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-06T19:34:19Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-06T19:34:19Z"}, "message": "(yylex): For integers, rename shorts to parts.\n\nLet the number of them be variable.  Simplify overflow testing.\nDon't use long long types unless ll was specified.\nDon't warn twice.\n\nFrom-SVN: r1463", "tree": {"sha": "837551de4da81bccfff53c903392d1180197a4ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/837551de4da81bccfff53c903392d1180197a4ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ca827d08d50dbe8e8b8ec6c594c50e8c6d89236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca827d08d50dbe8e8b8ec6c594c50e8c6d89236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca827d08d50dbe8e8b8ec6c594c50e8c6d89236", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca827d08d50dbe8e8b8ec6c594c50e8c6d89236/comments", "author": null, "committer": null, "parents": [{"sha": "a57bd38144cb1af3bf3e4a6238cc9e572bb10f3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a57bd38144cb1af3bf3e4a6238cc9e572bb10f3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a57bd38144cb1af3bf3e4a6238cc9e572bb10f3b"}], "stats": {"total": 151, "additions": 37, "deletions": 114}, "files": [{"sha": "0ee33cd709af73e38258dbf577d5237c9e352bdb", "filename": "gcc/c-lex.c", "status": "modified", "additions": 37, "deletions": 114, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca827d08d50dbe8e8b8ec6c594c50e8c6d89236/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca827d08d50dbe8e8b8ec6c594c50e8c6d89236/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=4ca827d08d50dbe8e8b8ec6c594c50e8c6d89236", "patch": "@@ -65,6 +65,10 @@ extern int yydebug;\n /* File used for outputting assembler code.  */\n extern FILE *asm_out_file;\n \n+#ifndef LONG_LONG_TYPE_SIZE\n+#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n #ifndef WCHAR_TYPE_SIZE\n #ifdef INT_TYPE_SIZE\n #define WCHAR_TYPE_SIZE INT_TYPE_SIZE\n@@ -1151,16 +1155,18 @@ yylex ()\n \tint largest_digit = 0;\n \tint numdigits = 0;\n \t/* for multi-precision arithmetic,\n-\t   we store only 8 live bits in each short,\n-\t   giving us 64 bits of reliable precision */\n-\tshort shorts[8];\n+\t   we actually store only HOST_BITS_PER_CHAR bits in each part.\n+\t   The number of parts is chosen so as to be sufficient to hold\n+\t   at least as many bits as are in a target `long long' value.  */\n+#define TOTAL_PARTS (LONG_LONG_TYPE_SIZE / HOST_BITS_PER_CHAR) + 2\n+\tint parts[TOTAL_PARTS];\n \tint overflow = 0;\n \n \tenum anon1 { NOT_FLOAT, AFTER_POINT, TOO_MANY_POINTS} floatflag\n \t  = NOT_FLOAT;\n \n-\tfor (count = 0; count < 8; count++)\n-\t  shorts[count] = 0;\n+\tfor (count = 0; count < TOTAL_PARTS; count++)\n+\t  parts[count] = 0;\n \n \tp = token_buffer;\n \t*p++ = c;\n@@ -1259,20 +1265,24 @@ yylex ()\n \t\t  largest_digit = c;\n \t\tnumdigits++;\n \n-\t\tfor (count = 0; count < 8; count++)\n+\t\tfor (count = 0; count < TOTAL_PARTS; count++)\n \t\t  {\n-\t\t    shorts[count] *= base;\n+\t\t    parts[count] *= base;\n \t\t    if (count)\n \t\t      {\n-\t\t\tshorts[count] += (shorts[count-1] >> 8);\n-\t\t\tshorts[count-1] &= (1<<8)-1;\n+\t\t\tparts[count]\n+\t\t\t  += (parts[count-1] >> HOST_BITS_PER_CHAR);\n+\t\t\tparts[count-1]\n+\t\t\t  &= (1 << HOST_BITS_PER_CHAR) - 1;\n \t\t      }\n-\t\t    else shorts[0] += c;\n+\t\t    else\n+\t\t      parts[0] += c;\n \t\t  }\n \n-\t\tif (shorts[7] >= 1<<8\n-\t\t    || shorts[7] < - (1 << 8))\n-\t\t  overflow = TRUE;\n+\t\t/* If the extra highest-order part ever gets anything in it,\n+\t\t   the number is certainly too big.  */\n+\t\tif (parts[TOTAL_PARTS - 1] != 0)\n+\t\t  overflow = 1;\n \n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n@@ -1477,107 +1487,24 @@ yylex ()\n \t    else\n \t      bytes = TYPE_PRECISION (long_integer_type_node) / 8;\n \n-\t    if (bytes <= 8)\n-\t      {\n-\t\twarn = overflow;\n-\t\tfor (i = bytes; i < 8; i++)\n-\t\t  if (shorts[i])\n-\t\t    {\n-\t\t      /* If LL was not used, then clear any excess precision.\n-\t\t\t This is equivalent to the original code, but it is\n-\t\t\t not clear why this is being done.  Perhaps to prevent\n-\t\t\t ANSI programs from creating long long constants\n-\t\t\t by accident?  */\n-\t\t      if (! spec_long_long)\n-\t\t\tshorts[i] = 0;\n-\t\t      warn = 1;\n-\t\t    }\n-\t\tif (warn)\n-\t\t  pedwarn (\"integer constant out of range\");\n-\t      }\n-\t    else if (overflow)\n-\t      pedwarn (\"integer constant larger than compiler can handle\");\n-\n-\t    /* If it overflowed our internal buffer, then make it unsigned.\n-\t       We can't distinguish based on the tree node because\n-\t       any integer constant fits any long long type.  */\n-\t    if (overflow)\n-\t      spec_unsigned = 1;\n+\t    warn = overflow;\n+\t    for (i = bytes; i < TOTAL_PARTS; i++)\n+\t      if (parts[i])\n+\t\twarn = 1;\n+\t    if (warn)\n+\t      pedwarn (\"integer constant out of range\");\n \n \t    /* This is simplified by the fact that our constant\n \t       is always positive.  */\n \t    /* The casts in the following statement should not be\n \t       needed, but they get around bugs in some C compilers.  */\n \t    yylval.ttype\n \t      = (build_int_2\n-\t\t ((((long)shorts[3]<<24) + ((long)shorts[2]<<16)\n-\t\t   + ((long)shorts[1]<<8) + (long)shorts[0]),\n-\t\t  (((long)shorts[7]<<24) + ((long)shorts[6]<<16)\n-\t\t   + ((long)shorts[5]<<8) + (long)shorts[4])));\n+\t\t ((((long)parts[3]<<24) + ((long)parts[2]<<16)\n+\t\t   + ((long)parts[1]<<8) + (long)parts[0]),\n+\t\t  (((long)parts[7]<<24) + ((long)parts[6]<<16)\n+\t\t   + ((long)parts[5]<<8) + (long)parts[4])));\n \n-#if 0\n-\t    /* Find the first allowable type that the value fits in.  */\n-\t    type = 0;\n-\t    for (i = 0; i < sizeof (type_sequence) / sizeof (type_sequence[0]);\n-\t\t i++)\n-\t      if (!(spec_long && !type_sequence[i].long_flag)\n-\t\t  && !(spec_long_long && !type_sequence[i].long_long_flag)\n-\t\t  && !(spec_unsigned && !type_sequence[i].unsigned_flag)\n-\t\t  /* A decimal constant can't be unsigned int\n-\t\t     unless explicitly specified.  */\n-\t\t  && !(base == 10 && !spec_unsigned\n-\t\t       && *type_sequence[i].node_var == unsigned_type_node))\n-\t\tif (int_fits_type_p (yylval.ttype, *type_sequence[i].node_var))\n-\t\t  {\n-\t\t    type = *type_sequence[i].node_var;\n-\t\t    break;\n-\t\t  }\n-\t    if (flag_traditional && type == long_unsigned_type_node\n-\t\t&& !spec_unsigned)\n-\t      type = long_integer_type_node;\n-\t      \n-\t    if (type == 0)\n-\t      {\n-\t\ttype = long_long_integer_type_node;\n-\t\twarning (\"integer constant out of range\");\n-\t      }\n-\n-\t    /* Warn about some cases where the type of a given constant\n-\t       changes from traditional C to ANSI C.  */\n-\t    if (warn_traditional)\n-\t      {\n-\t\ttree other_type = 0;\n-\n-\t\t/* This computation is the same as the previous one\n-\t\t   except that flag_traditional is used backwards.  */\n-\t\tfor (i = 0; i < sizeof (type_sequence) / sizeof (type_sequence[0]);\n-\t\t     i++)\n-\t\t  if (!(spec_long && !type_sequence[i].long_flag)\n-\t\t      && !(spec_long_long && !type_sequence[i].long_long_flag)\n-\t\t      && !(spec_unsigned && !type_sequence[i].unsigned_flag)\n-\t\t      /* A decimal constant can't be unsigned int\n-\t\t\t unless explicitly specified.  */\n-\t\t      && !(base == 10 && !spec_unsigned\n-\t\t\t   && *type_sequence[i].node_var == unsigned_type_node))\n-\t\t    if (int_fits_type_p (yylval.ttype, *type_sequence[i].node_var))\n-\t\t      {\n-\t\t\tother_type = *type_sequence[i].node_var;\n-\t\t\tbreak;\n-\t\t      }\n-\t\tif (!flag_traditional && type == long_unsigned_type_node\n-\t\t    && !spec_unsigned)\n-\t\t  type = long_integer_type_node;\n-\t      \n-\t\tif (other_type != 0 && other_type != type)\n-\t\t  {\n-\t\t    if (flag_traditional)\n-\t\t      warning (\"type of integer constant would be different without -traditional\");\n-\t\t    else\n-\t\t      warning (\"type of integer constant would be different with -traditional\");\n-\t\t  }\n-\t      }\n-\n-#else /* 1 */\n \t    /* If warn_traditional, calculate both the ANSI type and the\n \t       traditional type, then see if they disagree.\n \t       Otherwise, calculate only the type for the dialect in use.  */\n@@ -1600,9 +1527,7 @@ yylex ()\n \t\t\t && int_fits_type_p (yylval.ttype, integer_type_node))\n \t\t  traditional_type = (spec_unsigned ? unsigned_type_node\n \t\t\t\t      : integer_type_node);\n-\t\telse if (! spec_long_long\n-\t\t\t && int_fits_type_p (yylval.ttype,\n-\t\t\t\t\t     long_unsigned_type_node))\n+\t\telse if (! spec_long_long)\n \t\t  traditional_type = (spec_unsigned ? long_unsigned_type_node\n \t\t\t\t      : long_integer_type_node);\n \t\telse\n@@ -1622,9 +1547,7 @@ yylex ()\n \t\telse if (! spec_unsigned && !spec_long_long\n \t\t\t && int_fits_type_p (yylval.ttype, long_integer_type_node))\n \t\t  ansi_type = long_integer_type_node;\n-\t\telse if (! spec_long_long\n-\t\t\t && int_fits_type_p (yylval.ttype,\n-\t\t\t\t\t     long_unsigned_type_node))\n+\t\telse if (! spec_long_long)\n \t\t  ansi_type = long_unsigned_type_node;\n \t\telse if (! spec_unsigned\n \t\t\t && int_fits_type_p (yylval.ttype,\n@@ -1647,9 +1570,9 @@ yylex ()\n \t\telse\n \t\t  warning (\"width of integer constant may change on other systems with -traditional\");\n \t      }\n-#endif\n \n-\t    if (!flag_traditional && !int_fits_type_p (yylval.ttype, type))\n+\t    if (!flag_traditional && !int_fits_type_p (yylval.ttype, type)\n+\t\t&& !warn)\n \t      pedwarn (\"integer constant out of range\");\n \n \t    TREE_TYPE (yylval.ttype) = type;"}]}