{"sha": "ff7e7ee099988c5dea7973553983bb23db7c2924", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY3ZTdlZTA5OTk4OGM1ZGVhNzk3MzU1Mzk4M2JiMjNkYjdjMjkyNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-10-11T08:54:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-10-11T08:54:56Z"}, "message": "sparc.opt (msubxc): New option.\n\n\t* config/sparc/sparc.opt (msubxc): New option.\n\t* doc/invoke.texi (SPARC options): Document it and tidy up.\n\t* doc/tm.texi.in (Condition Codes): Adjust SPARC example.\n\t* doc/tm.texi: Regenerate.\n\t* config/sparc/sparc-modes.def (CC_NOOV): Rename into...\n\t(CCNZ): ...this.\n\t(CCX_NOOV): Rename into...\n\t(CCXNZ): ...this.\n\t(CCC): New.\n\t(CCXC): Likewise.\n\t* config/sparc/predicates.m (fcc_register_operand): Simplify.\n\t(fcc0_register_operand): Likewise.\n\t(icc_register_operand): New.\n\t(icc_or_fcc_register_operand): Simplify.\n\t(nz_comparison_operator): New.\n\t(c_comparison_operator): Likewise.\n\t(noov_compare_operator): Rename into...\n\t(icc_comparison_operator): ...this.  Use above predicates.\n\t(noov_compare64_operator): Rename into...\n\t(v9_comparison_operator): ...this and tidy up.\n\t(fcc_comparison_operator): New.\n\t(icc_or_fcc_comparison_operator): Likewise.\n\t(v9_register_compare_operator): Rename info...\n\t(v9_register_comparison_operator): ...this.\n\t* config/sparc/sparc.c (TARGET_FIXED_CONDITION_CODE_REGS): Define.\n\t(sparc_option_override): Remove redundant VIS masks and add MASK_SUBXC\n\tfor Niagara-7.\n\t(sparc_fixed_condition_code_regs): New function.\n\t(select_cc_mode): Remove ATTRIBUTE_UNUSED.  Adjust for CCNZ/CCXNZ\n\trenaming and add support for CCC/CCXC.\n\t(output_cbranch): Likewise.\n\t(sparc_print_operand): Likewise.\n\t(gen_v9_scc): Remove obsolete assertion.\n\t(emit_scc_insn): Emit RTL directly for EQ and NE.  Add direct support\n\tfor EQ in DImode if TARGET_SUBXC.  Remove test on TARGET_VIS3 for GEU.\n\t(output_cbcond): Remove bogus handling of CC modes.\n\t(sparc_register_move_cost): Return 100 for NO_REGS.\n\t* config/sparc/sparc.md (W): New mode iterator.\n\t(length): Adjust for noov_compare64_operator renaming.\n\t(cmpsi_sne): New instruction.\n\t(cmpdi_sne): Likewise.\n\t(seqdi_special): Delete.\n\t(seqdi_special): Likewise.\n\t(snesi<P:mode>_special): Likewise.\n\t(snedi_special): Likewise.\n\t(snedi_special_vis3): Likewise.\n\t(snesi patterns): Use W iterator.\n\t(snedi patterns): Likewise.  Add TARGET_SUBXC patterns.\n\t(sltu patterns): Likewise.\n\t(sgeu patterns): Likewise.\n\t(scc splitter): Do not split GEU in DImode if TARGET_SUBXC.\n\t(normal_branch): Use icc_comparison_operator predicate.\n\t(inverted_branch): Likewise.\n\t(cbcond_sp32): Use comparison_operator predicate.\n\t(cbcond_sp64): Likewise.\n\t(normal_int_branch_sp64): Adjust for renaming\n\t(inverted_int_branch_sp64): Likewise.\n\t(mov<I:mode>_cc_reg_sp64): Likewise.\n\t(movsf_cc_reg_sp6): Likewise.\n\t(movdf_cc_reg_sp64): Likewise.\n\t(movtf_cc_reg_hq_sp64): Likewise.\n\t(movtf_cc_reg_sp64): Likewise.\n\t(mov<I:mode>_cc_v9): Use icc_or_fcc_comparison_operator predicate.\n\t(movsf_cc_v9): Likewise.\n\t(movdf_cc_v9): Likewise.\n\t(movtf_cc_hq_v9): Likewise.\n\t(movtf_cc_v9): Likewise.\n\t(adddi3): Call gen_adddi3_sp32.\n\t(adddi3_insn_sp32): Rename to...\n\t(adddi3_sp32): ...this.  Accept only register_operand as operand #1\n\tand use CCCmode for the carry.\n\t(addx_extend_sp32): Use CCCmode for the carry.\n\t(addx_extend_sp64): Delete.\n\t(adddi3_extend_sp32): Use CCCmode for the carry.\n\t(cmp_plus patterns): Use CCNZ/CCXNZ mode and add C variants.\n\t(subdi3): Call gen_subdi3_sp32.\n\t(subdi3_insn_sp32): Rename to...\n\t(subdi3_sp32): ...this and use CCmode for the carry.\n\t(subx_extend_sp32): Use CCCmode for the carry.\n\t(subx_extend_sp64): Delete.\n\t(subdi3_extend_sp32): Use CCmode for the carry.\n\t(cmp_minus patterns): Use CCNZ/CCXNZ mode and add C variants.\n\t(negdi3): Call gen_negdi3_sp32.\n\t(negdi3_sp32): Use CCCmode for the carry.\n\t(cmp_neg patterns): Use CCNZ/CCXNZ mode and add C variants.\n\t(cmp_nz_ashift_1): Use CCNZ mode.\n\t(cmp_nz_set_ashift_1): Likewise.\n\t(ctrapsi4): Use comparison_operator predicate.\n\t(ctrapdi4): Likewise.\n\t(trapsi_insn): Use icc_comparison_operator predicate.\n\t(trapdi_insn): Likewise.\n\t(edge8 patterns): Use CCNZmode.\n\t(edge16 patterns): Likewise.\n\t(edge32 patterns): Likewise.\n\nFrom-SVN: r240971", "tree": {"sha": "8f2ee158c10cb98bbff16c437a13a7b71f8e52ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f2ee158c10cb98bbff16c437a13a7b71f8e52ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff7e7ee099988c5dea7973553983bb23db7c2924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7e7ee099988c5dea7973553983bb23db7c2924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7e7ee099988c5dea7973553983bb23db7c2924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7e7ee099988c5dea7973553983bb23db7c2924/comments", "author": null, "committer": null, "parents": [{"sha": "8d946ecc4695b2075da22d77fff79de6a36401b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d946ecc4695b2075da22d77fff79de6a36401b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d946ecc4695b2075da22d77fff79de6a36401b9"}], "stats": {"total": 2398, "additions": 1530, "deletions": 868}, "files": [{"sha": "b00cb2c54fc0fb91c2481a32eb21789050892040", "filename": "gcc/ChangeLog", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -1,3 +1,100 @@\n+2016-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc.opt (msubxc): New option.\n+\t* doc/invoke.texi (SPARC options): Document it and tidy up.\n+\t* doc/tm.texi.in (Condition Codes): Adjust SPARC example.\n+\t* doc/tm.texi: Regenerate.\n+\t* config/sparc/sparc-modes.def (CC_NOOV): Rename into...\n+\t(CCNZ): ...this.\n+\t(CCX_NOOV): Rename into...\n+\t(CCXNZ): ...this.\n+\t(CCC): New.\n+\t(CCXC): Likewise.\n+\t* config/sparc/predicates.m (fcc_register_operand): Simplify.\n+\t(fcc0_register_operand): Likewise.\n+\t(icc_register_operand): New.\n+\t(icc_or_fcc_register_operand): Simplify.\n+\t(nz_comparison_operator): New.\n+\t(c_comparison_operator): Likewise.\n+\t(noov_compare_operator): Rename into...\n+\t(icc_comparison_operator): ...this.  Use above predicates.\n+\t(noov_compare64_operator): Rename into...\n+\t(v9_comparison_operator): ...this and tidy up.\n+\t(fcc_comparison_operator): New.\n+\t(icc_or_fcc_comparison_operator): Likewise.\n+\t(v9_register_compare_operator): Rename info...\n+\t(v9_register_comparison_operator): ...this.\n+\t* config/sparc/sparc.c (TARGET_FIXED_CONDITION_CODE_REGS): Define.\n+\t(sparc_option_override): Remove redundant VIS masks and add MASK_SUBXC\n+\tfor Niagara-7.\n+\t(sparc_fixed_condition_code_regs): New function.\n+\t(select_cc_mode): Remove ATTRIBUTE_UNUSED.  Adjust for CCNZ/CCXNZ\n+\trenaming and add support for CCC/CCXC.\n+\t(output_cbranch): Likewise.\n+\t(sparc_print_operand): Likewise.\n+\t(gen_v9_scc): Remove obsolete assertion.\n+\t(emit_scc_insn): Emit RTL directly for EQ and NE.  Add direct support\n+\tfor EQ in DImode if TARGET_SUBXC.  Remove test on TARGET_VIS3 for GEU.\n+\t(output_cbcond): Remove bogus handling of CC modes.\n+\t(sparc_register_move_cost): Return 100 for NO_REGS.\n+\t* config/sparc/sparc.md (W): New mode iterator.\n+\t(length): Adjust for noov_compare64_operator renaming.\n+\t(cmpsi_sne): New instruction.\n+\t(cmpdi_sne): Likewise.\n+\t(seqdi_special): Delete.\n+\t(seqdi_special): Likewise.\n+\t(snesi<P:mode>_special): Likewise.\n+\t(snedi_special): Likewise.\n+\t(snedi_special_vis3): Likewise.\n+\t(snesi patterns): Use W iterator.\n+\t(snedi patterns): Likewise.  Add TARGET_SUBXC patterns.\n+\t(sltu patterns): Likewise.\n+\t(sgeu patterns): Likewise.\n+\t(scc splitter): Do not split GEU in DImode if TARGET_SUBXC.\n+\t(normal_branch): Use icc_comparison_operator predicate.\n+\t(inverted_branch): Likewise.\n+\t(cbcond_sp32): Use comparison_operator predicate.\n+\t(cbcond_sp64): Likewise.\n+\t(normal_int_branch_sp64): Adjust for renaming\n+\t(inverted_int_branch_sp64): Likewise.\n+\t(mov<I:mode>_cc_reg_sp64): Likewise.\n+\t(movsf_cc_reg_sp6): Likewise.\n+\t(movdf_cc_reg_sp64): Likewise.\n+\t(movtf_cc_reg_hq_sp64): Likewise.\n+\t(movtf_cc_reg_sp64): Likewise.\n+\t(mov<I:mode>_cc_v9): Use icc_or_fcc_comparison_operator predicate.\n+\t(movsf_cc_v9): Likewise.\n+\t(movdf_cc_v9): Likewise.\n+\t(movtf_cc_hq_v9): Likewise.\n+\t(movtf_cc_v9): Likewise.\n+\t(adddi3): Call gen_adddi3_sp32.\n+\t(adddi3_insn_sp32): Rename to...\n+\t(adddi3_sp32): ...this.  Accept only register_operand as operand #1\n+\tand use CCCmode for the carry.\n+\t(addx_extend_sp32): Use CCCmode for the carry.\n+\t(addx_extend_sp64): Delete.\n+\t(adddi3_extend_sp32): Use CCCmode for the carry.\n+\t(cmp_plus patterns): Use CCNZ/CCXNZ mode and add C variants.\n+\t(subdi3): Call gen_subdi3_sp32.\n+\t(subdi3_insn_sp32): Rename to...\n+\t(subdi3_sp32): ...this and use CCmode for the carry.\n+\t(subx_extend_sp32): Use CCCmode for the carry.\n+\t(subx_extend_sp64): Delete.\n+\t(subdi3_extend_sp32): Use CCmode for the carry.\n+\t(cmp_minus patterns): Use CCNZ/CCXNZ mode and add C variants.\n+\t(negdi3): Call gen_negdi3_sp32.\n+\t(negdi3_sp32): Use CCCmode for the carry.\n+\t(cmp_neg patterns): Use CCNZ/CCXNZ mode and add C variants.\n+\t(cmp_nz_ashift_1): Use CCNZ mode.\n+\t(cmp_nz_set_ashift_1): Likewise.\n+\t(ctrapsi4): Use comparison_operator predicate.\n+\t(ctrapdi4): Likewise.\n+\t(trapsi_insn): Use icc_comparison_operator predicate.\n+\t(trapdi_insn): Likewise.\n+\t(edge8 patterns): Use CCNZmode.\n+\t(edge16 patterns): Likewise.\n+\t(edge32 patterns): Likewise.\n+\n 2016-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/visium/visium-modes.def (CC_NOOV): Rename into..."}, {"sha": "dd57bf5e52fbb872dc5694aebaaf8fa46fca4ad8", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -234,53 +234,23 @@\n \n ;; Return true if OP is a floating point condition code register.\n (define_predicate \"fcc_register_operand\"\n-  (match_code \"reg\")\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return false;\n-  if (mode == VOIDmode\n-      && (GET_MODE (op) != CCFPmode && GET_MODE (op) != CCFPEmode))\n-    return false;\n-\n-#if 0 /* ??? 1 when %fcc0-3 are pseudos first.  See gen_compare_reg().  */\n-  if (reg_renumber == 0)\n-    return REGNO (op) >= FIRST_PSEUDO_REGISTER;\n-  return REGNO_OK_FOR_CCFP_P (REGNO (op));\n-#else\n-  return ((unsigned) REGNO (op) - SPARC_FIRST_V9_FCC_REG) < 4;\n-#endif\n-})\n+  (and (match_code \"reg\")\n+       (match_test \"((unsigned) REGNO (op) - SPARC_FIRST_V9_FCC_REG) < 4\")))\n \n ;; Return true if OP is the floating point condition code register fcc0.\n (define_predicate \"fcc0_register_operand\"\n-  (match_code \"reg\")\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return false;\n-  if (mode == VOIDmode\n-      && (GET_MODE (op) != CCFPmode && GET_MODE (op) != CCFPEmode))\n-    return false;\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == SPARC_FCC_REG\")))\n \n-  return REGNO (op) == SPARC_FCC_REG;\n-})\n+;; Return true if OP is an integer condition code register.\n+(define_predicate \"icc_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == SPARC_ICC_REG\")))\n \n ;; Return true if OP is an integer or floating point condition code register.\n (define_predicate \"icc_or_fcc_register_operand\"\n-  (match_code \"reg\")\n-{\n-  if (REGNO (op) == SPARC_ICC_REG)\n-    {\n-      if (mode != VOIDmode && mode != GET_MODE (op))\n-\treturn false;\n-      if (mode == VOIDmode\n-\t  && GET_MODE (op) != CCmode && GET_MODE (op) != CCXmode)\n-\treturn false;\n-\n-      return true;\n-    }\n-\n-  return fcc_register_operand (op, mode);\n-})\n+  (ior (match_operand 0 \"icc_register_operand\")\n+       (match_operand 0 \"fcc_register_operand\")))\n \n \n ;; Predicates for arithmetic instructions.\n@@ -442,46 +412,74 @@\n \n ;; Predicates for operators.\n \n-;; Return true if OP is a comparison operator.  This allows the use of\n-;; MATCH_OPERATOR to recognize all the branch insns.\n-(define_predicate \"noov_compare_operator\"\n-  (match_code \"ne,eq,ge,gt,le,lt,geu,gtu,leu,ltu\")\n+;; Return true if OP is a valid comparison operator for CCNZmode.\n+(define_predicate \"nz_comparison_operator\"\n+  (match_code \"eq,ne,lt,ge\"))\n+\n+;; Return true if OP is a valid comparison operator for CCCmode.\n+(define_predicate \"c_comparison_operator\"\n+  (match_code \"ltu,geu\"))\n+\n+;; Return true if OP is an integer comparison operator.  This allows\n+;; the use of MATCH_OPERATOR to recognize all the branch insns.\n+(define_predicate \"icc_comparison_operator\"\n+  (match_operand 0 \"ordered_comparison_operator\")\n {\n-  enum rtx_code code = GET_CODE (op);\n-  if (GET_MODE (XEXP (op, 0)) == CC_NOOVmode\n-      || GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n-    /* These are the only branches which work with CC_NOOVmode.  */\n-    return (code == EQ || code == NE || code == GE || code == LT);\n-  return true;\n+  switch (GET_MODE (XEXP (op, 0)))\n+    {\n+    case CCmode:\n+    case CCXmode:\n+      return true;\n+    case CCNZmode:\n+    case CCXNZmode:\n+      return nz_comparison_operator (op, mode);\n+    case CCCmode:\n+    case CCXCmode:\n+      return c_comparison_operator (op, mode);\n+    default:\n+      return false;\n+    }\n })\n \n-;; Return true if OP is a 64-bit comparison operator.  This allows the use of\n-;; MATCH_OPERATOR to recognize all the branch insns.\n-(define_predicate \"noov_compare64_operator\"\n-  (and (match_code \"ne,eq,ge,gt,le,lt,geu,gtu,leu,ltu\")\n-       (match_test \"TARGET_V9\"))\n+;; Return true if OP is a FP comparison operator.\n+(define_predicate \"fcc_comparison_operator\"\n+  (match_operand 0 \"comparison_operator\")\n {\n-  enum rtx_code code = GET_CODE (op);\n-  if (GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n-    /* These are the only branches which work with CCX_NOOVmode.  */\n-    return (code == EQ || code == NE || code == GE || code == LT);\n-  return (GET_MODE (XEXP (op, 0)) == CCXmode);\n+  switch (GET_MODE (XEXP (op, 0)))\n+    {\n+    case CCFPmode:\n+    case CCFPEmode:\n+      return true;\n+    default:\n+      return false;\n+    }\n })\n \n+;; Return true if OP is an integer or FP comparison operator.  This allows\n+;; the use of MATCH_OPERATOR to recognize all the conditional move insns.\n+(define_predicate \"icc_or_fcc_comparison_operator\"\n+  (ior (match_operand 0 \"icc_comparison_operator\")\n+       (match_operand 0 \"fcc_comparison_operator\")))\n+\n+;; Return true if OP is an integer comparison operator for V9.\n+(define_predicate \"v9_comparison_operator\"\n+  (and (match_operand 0 \"ordered_comparison_operator\")\n+       (match_test \"TARGET_V9\")))\n+\n ;; Return true if OP is a comparison operator suitable for use in V9\n ;; conditional move or branch on register contents instructions.\n-(define_predicate \"v9_register_compare_operator\"\n+(define_predicate \"v9_register_comparison_operator\"\n   (match_code \"eq,ne,ge,lt,le,gt\"))\n \n ;; Return true if OP is an operator which can set the condition codes\n-;; explicitly.  We do not include PLUS and MINUS because these\n-;; require CC_NOOVmode, which we handle explicitly.\n+;; explicitly.  We do not include PLUS/MINUS/NEG/ASHIFT because these\n+;; require CCNZmode, which we handle explicitly.\n (define_predicate \"cc_arith_operator\"\n   (match_code \"and,ior,xor\"))\n \n ;; Return true if OP is an operator which can bitwise complement its\n ;; second operand and set the condition codes explicitly.\n ;; XOR is not here because combine canonicalizes (xor (not ...) ...)\n-;; and (xor ... (not ...)) to (not (xor ...)).  */\n+;; and (xor ... (not ...)) to (not (xor ...)).\n (define_predicate \"cc_arith_not_operator\"\n   (match_code \"and,ior\"))"}, {"sha": "9c6fe0391643ac127a23754b4ac4e5efc2f497bb", "filename": "gcc/config/sparc/sparc-modes.def", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GCC, for Sun SPARC.\n    Copyright (C) 2002-2016 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n-   64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n+   64-bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n    at Cygnus Support.\n \n This file is part of GCC.\n@@ -25,20 +25,27 @@ FLOAT_MODE (TF, 16, ieee_quad_format);\n \n /* Add any extra modes needed to represent the condition code.\n \n-   On the SPARC, we have a \"no-overflow\" mode which is used when an add or\n-   subtract insn is used to set the condition code.  Different branches are\n-   used in this case for some operations.\n+   We have a CCNZ mode which is used for implicit comparisons with zero when\n+   arithmetic instructions set the condition code.  Only the N and Z flags\n+   are valid in this mode, which means that only the =,!= and <,>= operators\n+   can be used in conjunction with it.\n+\n+   We also have a CCCmode which is used by the arithmetic instructions when\n+   they explicitly set the C flag (unsigned overflow).  Only the unsigned\n+   <,>= operators can be used in conjunction with it.\n \n    We also have two modes to indicate that the relevant condition code is\n    in the floating-point condition code register.  One for comparisons which\n    will generate an exception if the result is unordered (CCFPEmode) and\n    one for comparisons which will never trap (CCFPmode).\n \n-   CCXmode and CCX_NOOVmode are only used by v9.  */\n+   CC modes are used for the 32-bit ICC, CCX modes for the 64-bit XCC.  */\n \n CC_MODE (CCX);\n-CC_MODE (CC_NOOV);\n-CC_MODE (CCX_NOOV);\n+CC_MODE (CCNZ);\n+CC_MODE (CCXNZ);\n+CC_MODE (CCC);\n+CC_MODE (CCXC);\n CC_MODE (CCFP);\n CC_MODE (CCFPE);\n "}, {"sha": "d8ceff9ffed3281fc1aa94f995e0ff77748da358", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 234, "deletions": 138, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -647,6 +647,7 @@ static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t   secondary_reload_info *);\n static machine_mode sparc_cstore_mode (enum insn_code icode);\n static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n+static bool sparc_fixed_condition_code_regs (unsigned int *, unsigned int *);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -857,6 +858,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n #define TARGET_ATOMIC_ASSIGN_EXPAND_FENV sparc_atomic_assign_expand_fenv\n \n+#undef TARGET_FIXED_CONDITION_CODE_REGS\n+#define TARGET_FIXED_CONDITION_CODE_REGS sparc_fixed_condition_code_regs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Return the memory reference contained in X if any, zero otherwise.  */\n@@ -1314,13 +1318,13 @@ sparc_option_override (void)\n       MASK_V9|MASK_POPC|MASK_VIS2 },\n     /* UltraSPARC T3 */\n     { \"niagara3\",\tMASK_ISA,\n-      MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_FMAF },\n+      MASK_V9|MASK_POPC|MASK_VIS3|MASK_FMAF },\n     /* UltraSPARC T4 */\n     { \"niagara4\",\tMASK_ISA,\n-      MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_FMAF|MASK_CBCOND },\n+      MASK_V9|MASK_POPC|MASK_VIS3|MASK_FMAF|MASK_CBCOND },\n     /* UltraSPARC M7 */\n     { \"niagara7\",\tMASK_ISA,\n-      MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_VIS4|MASK_FMAF|MASK_CBCOND },\n+      MASK_V9|MASK_POPC|MASK_VIS4|MASK_FMAF|MASK_CBCOND|MASK_SUBXC }\n   };\n   const struct cpu_table *cpu;\n   unsigned int i;\n@@ -1451,7 +1455,7 @@ sparc_option_override (void)\n \t\t   & ~MASK_CBCOND\n #endif\n #ifndef HAVE_AS_SPARC5_VIS4\n-\t\t   & ~MASK_VIS4\n+\t\t   & ~(MASK_VIS4 | MASK_SUBXC)\n #endif\n #ifndef HAVE_AS_LEON\n \t\t   & ~(MASK_LEON | MASK_LEON3)\n@@ -2742,14 +2746,24 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n   sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits);\n }\n \n+/* Implement TARGET_FIXED_CONDITION_CODE_REGS.  */\n+\n+static bool\n+sparc_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n+{\n+  *p1 = SPARC_ICC_REG;\n+  *p2 = SPARC_FCC_REG;\n+  return true;\n+}\n+\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,\n-   CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand\n+   CCFP[E]mode is used.  CCNZmode should be used when the first operand\n    is a PLUS, MINUS, NEG, or ASHIFT.  CCmode should be used when no special\n    processing is needed.  */\n \n machine_mode\n-select_cc_mode (enum rtx_code op, rtx x, rtx y ATTRIBUTE_UNUSED)\n+select_cc_mode (enum rtx_code op, rtx x, rtx y)\n {\n   if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n     {\n@@ -2781,12 +2795,21 @@ select_cc_mode (enum rtx_code op, rtx x, rtx y ATTRIBUTE_UNUSED)\n \t   || GET_CODE (x) == NEG || GET_CODE (x) == ASHIFT)\n     {\n       if (TARGET_ARCH64 && GET_MODE (x) == DImode)\n-\treturn CCX_NOOVmode;\n+\treturn CCXNZmode;\n       else\n-\treturn CC_NOOVmode;\n+\treturn CCNZmode;\n     }\n   else\n     {\n+      /* This is for the cmp<mode>_sne pattern.  */\n+      if (GET_CODE (x) == NOT && y == constm1_rtx)\n+\t{\n+\t  if (TARGET_ARCH64 && GET_MODE (x) == DImode)\n+\t    return CCXCmode;\n+\t  else\n+\t    return CCCmode;\n+\t}\n+\n       if (TARGET_ARCH64 && GET_MODE (x) == DImode)\n \treturn CCXmode;\n       else\n@@ -2951,9 +2974,6 @@ gen_v9_scc (rtx dest, enum rtx_code compare_code, rtx x, rtx y)\n       x = gen_compare_reg_1 (compare_code, x, y);\n       y = const0_rtx;\n \n-      gcc_assert (GET_MODE (x) != CC_NOOVmode\n-\t\t  && GET_MODE (x) != CCX_NOOVmode);\n-\n       emit_insn (gen_rtx_SET (dest, const0_rtx));\n       emit_insn (gen_rtx_SET (dest,\n \t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (dest),\n@@ -2971,10 +2991,9 @@ gen_v9_scc (rtx dest, enum rtx_code compare_code, rtx x, rtx y)\n bool\n emit_scc_insn (rtx operands[])\n {\n-  rtx tem;\n-  rtx x;\n-  rtx y;\n+  rtx tem, x, y;\n   enum rtx_code code;\n+  machine_mode mode;\n \n   /* The quad-word fp compare library routines all return nonzero to indicate\n      true, which is different from the equivalent libgcc routines, so we must\n@@ -2990,59 +3009,42 @@ emit_scc_insn (rtx operands[])\n   code = GET_CODE (operands[1]);\n   x = operands[2];\n   y = operands[3];\n+  mode = GET_MODE (x);\n \n   /* For seq/sne on v9 we use the same code as v8 (the addx/subx method has\n      more applications).  The exception to this is \"reg != 0\" which can\n      be done in one instruction on v9 (so we do it).  */\n-  if (code == EQ)\n+  if ((code == EQ || code == NE) && (mode == SImode || mode == DImode))\n     {\n-      if (GET_MODE (x) == SImode)\n-        {\n-\t  rtx pat;\n-\t  if (TARGET_ARCH64)\n-\t    pat = gen_seqsidi_special (operands[0], x, y);\n-\t  else\n-\t    pat = gen_seqsisi_special (operands[0], x, y);\n-          emit_insn (pat);\n-          return true;\n-        }\n-      else if (GET_MODE (x) == DImode)\n-        {\n-\t  rtx pat = gen_seqdi_special (operands[0], x, y);\n-          emit_insn (pat);\n-          return true;\n-        }\n-    }\n+      if (y != const0_rtx)\n+\tx = force_reg (mode, gen_rtx_XOR (mode, x, y));\n \n-  if (code == NE)\n-    {\n-      if (GET_MODE (x) == SImode)\n-        {\n-          rtx pat;\n-\t  if (TARGET_ARCH64)\n-\t    pat = gen_snesidi_special (operands[0], x, y);\n-\t  else\n-\t    pat = gen_snesisi_special (operands[0], x, y);\n-          emit_insn (pat);\n-          return true;\n-        }\n-      else if (GET_MODE (x) == DImode)\n-        {\n-\t  rtx pat;\n-\t  if (TARGET_VIS3)\n-\t    pat = gen_snedi_special_vis3 (operands[0], x, y);\n-\t  else\n-\t    pat = gen_snedi_special (operands[0], x, y);\n-          emit_insn (pat);\n-          return true;\n-        }\n+      rtx pat = gen_rtx_SET (operands[0],\n+\t\t\t     gen_rtx_fmt_ee (code, GET_MODE (operands[0]),\n+\t\t\t\t\t     x, const0_rtx));\n+\n+      /* If we can use addx/subx or addxc/subxc, add a clobber for CC.  */\n+      if (mode == SImode\n+\t  || (code == NE && TARGET_VIS3)\n+\t  || (code == EQ && TARGET_SUBXC))\n+\t{\n+\t  rtx clobber\n+\t    = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t       gen_rtx_REG (mode == SImode ? CCmode : CCXmode,\n+\t\t\t\t\t    SPARC_ICC_REG));\n+\t  pat = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, pat, clobber));\n+\t}\n+\n+      emit_insn (pat);\n+      return true;\n     }\n \n-  if (TARGET_V9\n-      && TARGET_ARCH64\n-      && GET_MODE (x) == DImode\n-      && !(TARGET_VIS3\n-\t   && (code == GTU || code == LTU))\n+  /* We can do LTU in DImode using the addxc instruction with VIS3\n+     and GEU in DImode using the subxc instruction with SUBXC.  */\n+  if (TARGET_ARCH64\n+      && mode == DImode\n+      && !((code == LTU || code == GTU) && TARGET_VIS3)\n+      && !((code == GEU || code == LEU) && TARGET_SUBXC)\n       && gen_v9_scc (operands[0], code, x, y))\n     return true;\n \n@@ -3061,8 +3063,7 @@ emit_scc_insn (rtx operands[])\n         }\n     }\n \n-  if (code == LTU\n-      || (!TARGET_VIS3 && code == GEU))\n+  if (code == LTU || code == GEU)\n     {\n       emit_insn (gen_rtx_SET (operands[0],\n \t\t\t      gen_rtx_fmt_ee (code, GET_MODE (operands[0]),\n@@ -7715,7 +7716,6 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \tcase LTGT:\n \t  branch = \"fblg\";\n \t  break;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -7741,7 +7741,7 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \t  branch = \"be\";\n \t  break;\n \tcase GE:\n-\t  if (mode == CC_NOOVmode || mode == CCX_NOOVmode)\n+\t  if (mode == CCNZmode || mode == CCXNZmode)\n \t    branch = \"bpos\";\n \t  else\n \t    branch = \"bge\";\n@@ -7753,7 +7753,7 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \t  branch = \"ble\";\n \t  break;\n \tcase LT:\n-\t  if (mode == CC_NOOVmode || mode == CCX_NOOVmode)\n+\t  if (mode == CCNZmode || mode == CCXNZmode)\n \t    branch = \"bneg\";\n \t  else\n \t    branch = \"bl\";\n@@ -7770,7 +7770,6 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \tcase LTU:\n \t  branch = \"blu\";\n \t  break;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -7801,28 +7800,37 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \t    v8 = 1;\n \t}\n \n-      if (mode == CCFPmode || mode == CCFPEmode)\n-\t{\n-\t  static char v9_fcc_labelno[] = \"%%fccX, \";\n-\t  /* Set the char indicating the number of the fcc reg to use.  */\n-\t  v9_fcc_labelno[5] = REGNO (cc_reg) - SPARC_FIRST_V9_FCC_REG + '0';\n-\t  labelno = v9_fcc_labelno;\n-\t  if (v8)\n-\t    {\n-\t      gcc_assert (REGNO (cc_reg) == SPARC_FCC_REG);\n-\t      labelno = \"\";\n-\t    }\n-\t}\n-      else if (mode == CCXmode || mode == CCX_NOOVmode)\n-\t{\n-\t  labelno = \"%%xcc, \";\n-\t  gcc_assert (! v8);\n-\t}\n-      else\n+      switch (mode)\n \t{\n+\tcase CCmode:\n+\tcase CCNZmode:\n+\tcase CCCmode:\n \t  labelno = \"%%icc, \";\n \t  if (v8)\n \t    labelno = \"\";\n+\t  break;\n+\tcase CCXmode:\n+\tcase CCXNZmode:\n+\tcase CCXCmode:\n+\t  labelno = \"%%xcc, \";\n+\t  gcc_assert (!v8);\n+\t  break;\n+\tcase CCFPmode:\n+\tcase CCFPEmode:\n+\t  {\n+\t    static char v9_fcc_labelno[] = \"%%fccX, \";\n+\t    /* Set the char indicating the number of the fcc reg to use.  */\n+\t    v9_fcc_labelno[5] = REGNO (cc_reg) - SPARC_FIRST_V9_FCC_REG + '0';\n+\t    labelno = v9_fcc_labelno;\n+\t    if (v8)\n+\t      {\n+\t\tgcc_assert (REGNO (cc_reg) == SPARC_FCC_REG);\n+\t\tlabelno = \"\";\n+\t      }\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n \n       if (*labelno && insn && (note = find_reg_note (insn, REG_BR_PROB, NULL_RTX)))\n@@ -8129,10 +8137,7 @@ output_cbcond (rtx op, rtx dest, rtx_insn *insn)\n       break;\n \n     case GE:\n-      if (mode == CC_NOOVmode || mode == CCX_NOOVmode)\n-\tcond_str = \"pos\";\n-      else\n-\tcond_str = \"ge\";\n+      cond_str = \"ge\";\n       break;\n \n     case GT:\n@@ -8144,10 +8149,7 @@ output_cbcond (rtx op, rtx dest, rtx_insn *insn)\n       break;\n \n     case LT:\n-      if (mode == CC_NOOVmode || mode == CCX_NOOVmode)\n-\tcond_str = \"neg\";\n-      else\n-\tcond_str = \"l\";\n+      cond_str = \"l\";\n       break;\n \n     case GEU:\n@@ -8699,6 +8701,8 @@ sparc_print_operand_punct_valid_p (unsigned char code)\n static void\n sparc_print_operand (FILE *file, rtx x, int code)\n {\n+  const char *s;\n+\n   switch (code)\n     {\n     case '#':\n@@ -8806,14 +8810,22 @@ sparc_print_operand (FILE *file, rtx x, int code)\n       /* Print a condition code register.  */\n       if (REGNO (x) == SPARC_ICC_REG)\n \t{\n-\t  /* We don't handle CC[X]_NOOVmode because they're not supposed\n-\t     to occur here.  */\n-\t  if (GET_MODE (x) == CCmode)\n-\t    fputs (\"%icc\", file);\n-\t  else if (GET_MODE (x) == CCXmode)\n-\t    fputs (\"%xcc\", file);\n-\t  else\n-\t    gcc_unreachable ();\n+\t  switch (GET_MODE (x))\n+\t    {\n+\t    case CCmode:\n+\t    case CCNZmode:\n+\t    case CCCmode:\n+\t      s = \"%icc\";\n+\t      break;\n+\t    case CCXmode:\n+\t    case CCXNZmode:\n+\t    case CCXCmode:\n+\t      s = \"%xcc\";\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  fputs (s, file);\n \t}\n       else\n \t/* %fccN register */\n@@ -8838,67 +8850,147 @@ sparc_print_operand (FILE *file, rtx x, int code)\n     case 'A':\n       switch (GET_CODE (x))\n \t{\n-\tcase IOR: fputs (\"or\", file); break;\n-\tcase AND: fputs (\"and\", file); break;\n-\tcase XOR: fputs (\"xor\", file); break;\n-\tdefault: output_operand_lossage (\"invalid %%A operand\");\n+\tcase IOR:\n+\t  s = \"or\";\n+\t  break;\n+\tcase AND:\n+\t  s = \"and\";\n+\t  break;\n+\tcase XOR:\n+\t  s = \"xor\";\n+\t  break;\n+\tdefault:\n+\t  output_operand_lossage (\"invalid %%A operand\");\n+\t  s = \"\";\n+\t  break;\n \t}\n+      fputs (s, file);\n       return;\n \n     case 'B':\n       switch (GET_CODE (x))\n \t{\n-\tcase IOR: fputs (\"orn\", file); break;\n-\tcase AND: fputs (\"andn\", file); break;\n-\tcase XOR: fputs (\"xnor\", file); break;\n-\tdefault: output_operand_lossage (\"invalid %%B operand\");\n+\tcase IOR:\n+\t  s = \"orn\";\n+\t  break;\n+\tcase AND:\n+\t  s = \"andn\";\n+\t  break;\n+\tcase XOR:\n+\t  s = \"xnor\";\n+\t  break;\n+\tdefault:\n+\t  output_operand_lossage (\"invalid %%B operand\");\n+\t  s = \"\";\n+\t  break;\n \t}\n+      fputs (s, file);\n       return;\n \n       /* This is used by the conditional move instructions.  */\n     case 'C':\n       {\n-\tenum rtx_code rc = GET_CODE (x);\n-\t\n-\tswitch (rc)\n+\tmachine_mode mode = GET_MODE (XEXP (x, 0));\n+\tswitch (GET_CODE (x))\n \t  {\n-\t  case NE: fputs (\"ne\", file); break;\n-\t  case EQ: fputs (\"e\", file); break;\n-\t  case GE: fputs (\"ge\", file); break;\n-\t  case GT: fputs (\"g\", file); break;\n-\t  case LE: fputs (\"le\", file); break;\n-\t  case LT: fputs (\"l\", file); break;\n-\t  case GEU: fputs (\"geu\", file); break;\n-\t  case GTU: fputs (\"gu\", file); break;\n-\t  case LEU: fputs (\"leu\", file); break;\n-\t  case LTU: fputs (\"lu\", file); break;\n-\t  case LTGT: fputs (\"lg\", file); break;\n-\t  case UNORDERED: fputs (\"u\", file); break;\n-\t  case ORDERED: fputs (\"o\", file); break;\n-\t  case UNLT: fputs (\"ul\", file); break;\n-\t  case UNLE: fputs (\"ule\", file); break;\n-\t  case UNGT: fputs (\"ug\", file); break;\n-\t  case UNGE: fputs (\"uge\", file); break;\n-\t  case UNEQ: fputs (\"ue\", file); break;\n-\t  default: output_operand_lossage (\"invalid %%C operand\");\n+\t  case NE:\n+\t    s = \"ne\";\n+\t    break;\n+\t  case EQ:\n+\t    s = \"e\";\n+\t    break;\n+\t  case GE:\n+\t    if (mode == CCNZmode || mode == CCXNZmode)\n+\t      s = \"pos\";\n+\t    else\n+\t      s = \"ge\";\n+\t    break;\n+\t  case GT:\n+\t    s = \"g\";\n+\t    break;\n+\t  case LE:\n+\t    s = \"le\";\n+\t    break;\n+\t  case LT:\n+\t    if (mode == CCNZmode || mode == CCXNZmode)\n+\t      s = \"neg\";\n+\t    else\n+\t      s = \"l\";\n+\t    break;\n+\t  case GEU:\n+\t    s = \"geu\";\n+\t    break;\n+\t  case GTU:\n+\t    s = \"gu\";\n+\t    break;\n+\t  case LEU:\n+\t    s = \"leu\";\n+\t    break;\n+\t  case LTU:\n+\t    s = \"lu\";\n+\t    break;\n+\t  case LTGT:\n+\t    s = \"lg\";\n+\t    break;\n+\t  case UNORDERED:\n+\t    s = \"u\";\n+\t    break;\n+\t  case ORDERED:\n+\t    s = \"o\";\n+\t    break;\n+\t  case UNLT:\n+\t    s = \"ul\";\n+\t    break;\n+\t  case UNLE:\n+\t    s = \"ule\";\n+\t    break;\n+\t  case UNGT:\n+\t    s = \"ug\";\n+\t    break;\n+\t  case UNGE:\n+\t    s = \"uge\"\n+\t    ; break;\n+\t  case UNEQ:\n+\t    s = \"ue\";\n+\t    break;\n+\t  default:\n+\t    output_operand_lossage (\"invalid %%C operand\");\n+\t    s = \"\";\n+\t    break;\n \t  }\n+\tfputs (s, file);\n \treturn;\n       }\n \n       /* This are used by the movr instruction pattern.  */\n     case 'D':\n       {\n-\tenum rtx_code rc = GET_CODE (x);\n-\tswitch (rc)\n+\tswitch (GET_CODE (x))\n \t  {\n-\t  case NE: fputs (\"ne\", file); break;\n-\t  case EQ: fputs (\"e\", file); break;\n-\t  case GE: fputs (\"gez\", file); break;\n-\t  case LT: fputs (\"lz\", file); break;\n-\t  case LE: fputs (\"lez\", file); break;\n-\t  case GT: fputs (\"gz\", file); break;\n-\t  default: output_operand_lossage (\"invalid %%D operand\");\n+\t  case NE:\n+\t    s = \"ne\";\n+\t    break;\n+\t  case EQ:\n+\t    s = \"e\";\n+\t    break;\n+\t  case GE:\n+\t    s = \"gez\";\n+\t    break;\n+\t  case LT:\n+\t    s = \"lz\";\n+\t    break;\n+\t  case LE:\n+\t    s = \"lez\";\n+\t    break;\n+\t  case GT:\n+\t    s = \"gz\";\n+\t    break;\n+\t  default:\n+\t    output_operand_lossage (\"invalid %%D operand\");\n+\t    s = \"\";\n+\t    break;\n \t  }\n+\tfputs (s, file);\n \treturn;\n       }\n \n@@ -11238,6 +11330,10 @@ sparc_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n {\n   bool need_memory = false;\n \n+  /* This helps postreload CSE to eliminate redundant comparisons.  */\n+  if (from == NO_REGS || to == NO_REGS)\n+    return 100;\n+\n   if (from == FPCC_REGS || to == FPCC_REGS)\n     need_memory = true;\n   else if ((FP_REG_CLASS_P (from) && general_or_i64_p (to))"}, {"sha": "5389216baa2cc82d938729416ac75ddebecf0109", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -1517,7 +1517,7 @@ do {\t\t\t\t\t\t\t\t\t   \\\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,\n-   CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand\n+   CCFP[E]mode is used.  CCNZmode should be used when the first operand\n    is a PLUS, MINUS, NEG, or ASHIFT.  CCmode should be used when no special\n    processing is needed.  */\n #define SELECT_CC_MODE(OP,X,Y)  select_cc_mode ((OP), (X), (Y))"}, {"sha": "05407451b6a2774def9aff60fa6bedbbfa58822d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 776, "deletions": 598, "changes": 1374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -203,6 +203,7 @@\n \n (define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n (define_mode_iterator I [QI HI SI DI])\n+(define_mode_iterator W [SI (DI \"TARGET_ARCH64\")])\n (define_mode_iterator F [SF DF TF])\n \n ;; The upper 32 fp regs on the v9 can't hold SFmode values.  To deal with this\n@@ -338,7 +339,7 @@\n \t       (const_int 2)\n \t       (const_int 1)))\n \t (eq_attr \"branch_type\" \"icc\")\n-\t   (if_then_else (match_operand 0 \"noov_compare64_operator\" \"\")\n+\t   (if_then_else (match_operand 0 \"v9_comparison_operator\" \"\")\n \t     (if_then_else (lt (pc) (match_dup 1))\n \t       (if_then_else (lt (minus (match_dup 1) (pc)) (const_int 260000))\n \t\t (if_then_else (eq_attr \"empty_delay_slot\" \"true\")\n@@ -525,8 +526,6 @@\n ;; DEFINE_SPLITs for some of the scc insns that actually require\n ;; more than one machine instruction.  DEFINE_EXPANDs are further down.\n \n-;; The compare DEFINE_INSNs.\n-\n (define_insn \"*cmpsi_insn\"\n   [(set (reg:CC CC_REG)\n \t(compare:CC (match_operand:SI 0 \"register_operand\" \"r\")\n@@ -543,6 +542,22 @@\n   \"cmp\\t%0, %1\"\n   [(set_attr \"type\" \"compare\")])\n \n+(define_insn \"*cmpsi_sne\"\n+  [(set (reg:CCC CC_REG)\n+\t(compare:CCC (not:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n+\t\t     (const_int -1)))]\n+  \"\"\n+  \"cmp\\t%%g0, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmpdi_sne\"\n+  [(set (reg:CCXC CC_REG)\n+\t(compare:CCXC (not:DI (match_operand:DI 0 \"arith_operand\" \"rI\"))\n+\t\t      (const_int -1)))]\n+  \"TARGET_ARCH64\"\n+  \"cmp\\t%%g0, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n (define_insn \"*cmpsf_fpe\"\n   [(set (match_operand:CCFPE 0 \"fcc_register_operand\" \"=c\")\n \t(compare:CCFPE (match_operand:SF 1 \"register_operand\" \"f\")\n@@ -652,497 +667,671 @@\n           (match_operand:F 3 \"register_operand\" \"\")]))\n    (clobber (match_operand:SI 0 \"cstore_result_operand\"))]\n   \"TARGET_FPU\"\n-  { if (emit_scc_insn (operands)) DONE; else FAIL; })\n-\n-;; Seq_special[_xxx] and sne_special[_xxx] clobber the CC reg, because they\n-;; generate addcc/subcc instructions.\n-\n-(define_expand \"seqsi<P:mode>_special\"\n-  [(set (match_dup 3)\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"\")))\n-   (parallel [(set (match_operand:P 0 \"register_operand\" \"\")\n-\t\t   (eq:P (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CC CC_REG))])]\n-  \"\"\n-  { operands[3] = gen_reg_rtx (SImode); })\n-\n-(define_expand \"seqdi_special\"\n-  [(set (match_dup 3)\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(eq:DI (match_dup 3) (const_int 0)))]\n-  \"TARGET_ARCH64\"\n-  { operands[3] = gen_reg_rtx (DImode); })\n-\n-(define_expand \"snesi<P:mode>_special\"\n-  [(set (match_dup 3)\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"\")))\n-   (parallel [(set (match_operand:P 0 \"register_operand\" \"\")\n-\t\t   (ne:P (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CC CC_REG))])]\n-  \"\"\n-  { operands[3] = gen_reg_rtx (SImode); })\n-\n-(define_expand \"snedi_special\"\n-  [(set (match_dup 3)\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ne:DI (match_dup 3) (const_int 0)))]\n-  \"TARGET_ARCH64 && ! TARGET_VIS3\"\n-  { operands[3] = gen_reg_rtx (DImode); })\n-\n-(define_expand \"snedi_special_vis3\"\n-  [(set (match_dup 3)\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (ne:DI (match_dup 3) (const_int 0)))\n-\t      (clobber (reg:CCX CC_REG))])]\n-  \"TARGET_ARCH64 && TARGET_VIS3\"\n-  { operands[3] = gen_reg_rtx (DImode); })\n-\n-\n-;; Now the DEFINE_INSNs for the scc cases.\n+{\n+  if (emit_scc_insn (operands)) DONE; else FAIL;\n+})\n \n-;; The SEQ and SNE patterns are special because they can be done\n-;; without any branching and do not involve a COMPARE.  We want\n-;; them to always use the splits below so the results can be\n-;; scheduled.\n+;; The SNE and SEQ patterns are special because they can be done\n+;; without any branching and do not involve a COMPARE.\n \n-(define_insn_and_split \"*snesi<P:mode>_zero\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-\t(ne:P (match_operand:SI 1 \"register_operand\" \"r\")\n-\t       (const_int 0)))\n+(define_insn_and_split \"*snesi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(ne:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t      (const_int 0)))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (ltu:P (reg:CC CC_REG) (const_int 0)))]\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (ltu:W (reg:CCC CC_REG) (const_int 0)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*neg_snesisi_zero\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t       (const_int 0))))\n+(define_insn_and_split \"*neg_snesi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (ne:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (const_int 0))))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (neg:SI (ltu:SI (reg:CC CC_REG) (const_int 0))))]\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (neg:W (ltu:W (reg:CCC CC_REG) (const_int 0))))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*neg_snesidi_zero\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(neg:DI (ne:DI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t       (const_int 0))))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_ARCH64\"\n+(define_insn_and_split \"*snedi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=&r\")\n+        (ne:W (match_operand:DI 1 \"register_operand\" \"r\")\n+              (const_int 0)))]\n+  \"TARGET_ARCH64 && !TARGET_VIS3\"\n   \"#\"\n+  \"&& ! reg_overlap_mentioned_p (operands[1], operands[0])\"\n+  [(set (match_dup 0) (const_int 0))\n+   (set (match_dup 0) (if_then_else:W (ne:DI (match_dup 1) (const_int 0))\n+                                      (const_int 1)\n+                                      (match_dup 0)))]\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (sign_extend:DI (neg:SI (ltu:SI (reg:CC CC_REG)\n-                                                      (const_int 0)))))]\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn_and_split \"*snedi<W:mode>_zero_vis3\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(ne:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t      (const_int 0)))\n+   (clobber (reg:CCX CC_REG))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (ltu:W (reg:CCXC CC_REG) (const_int 0)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*snedi_zero\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-        (ne:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-               (const_int 0)))]\n-  \"TARGET_ARCH64 && ! TARGET_VIS3\"\n+(define_insn_and_split \"*neg_snedi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=&r\")\n+        (neg:W (ne:W (match_operand:DI 1 \"register_operand\" \"r\")\n+                     (const_int 0))))]\n+  \"TARGET_ARCH64 && !TARGET_SUBXC\"\n   \"#\"\n   \"&& ! reg_overlap_mentioned_p (operands[1], operands[0])\"\n   [(set (match_dup 0) (const_int 0))\n-   (set (match_dup 0) (if_then_else:DI (ne:DI (match_dup 1)\n-                                              (const_int 0))\n-                                       (const_int 1)\n-                                       (match_dup 0)))]\n+   (set (match_dup 0) (if_then_else:W (ne:DI (match_dup 1) (const_int 0))\n+                                      (const_int -1)\n+                                      (match_dup 0)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*snedi_zero_vis3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ne:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t       (const_int 0)))\n+(define_insn_and_split \"*neg_snedi<W:mode>_zero_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=&r\")\n+        (neg:W (ne:W (match_operand:DI 1 \"register_operand\" \"r\")\n+                     (const_int 0))))\n    (clobber (reg:CCX CC_REG))]\n-  \"TARGET_ARCH64 && TARGET_VIS3\"\n+  \"TARGET_ARCH64 && TARGET_SUBXC\"\n   \"#\"\n   \"\"\n-  [(set (reg:CCX_NOOV CC_REG) (compare:CCX_NOOV (neg:DI (match_dup 1))\n-\t\t\t\t\t        (const_int 0)))\n-   (set (match_dup 0) (ltu:DI (reg:CCX CC_REG) (const_int 0)))]\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (neg:W (ltu:W (reg:CCXC CC_REG) (const_int 0))))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*neg_snedi_zero\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-        (neg:DI (ne:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                       (const_int 0))))]\n-  \"TARGET_ARCH64\"\n+(define_insn_and_split \"*seqsi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(eq:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t      (const_int 0)))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n   \"#\"\n-  \"&& ! reg_overlap_mentioned_p (operands[1], operands[0])\"\n-  [(set (match_dup 0) (const_int 0))\n-   (set (match_dup 0) (if_then_else:DI (ne:DI (match_dup 1)\n-                                              (const_int 0))\n-                                       (const_int -1)\n-                                       (match_dup 0)))]\n+  \"\"\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (geu:W (reg:CCC CC_REG) (const_int 0)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*snedi_zero_trunc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-        (ne:SI (match_operand:DI 1 \"register_operand\" \"r\")\n-               (const_int 0)))]\n-  \"TARGET_ARCH64 && ! TARGET_VIS3\"\n+(define_insn_and_split \"*neg_seqsi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (eq:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (const_int 0))))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (neg:W (geu:W (reg:CCC CC_REG) (const_int 0))))]\n+  \"\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn_and_split \"*seqdi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=&r\")\n+        (eq:W (match_operand:DI 1 \"register_operand\" \"r\")\n+              (const_int 0)))]\n+  \"TARGET_ARCH64 && !TARGET_SUBXC\"\n   \"#\"\n   \"&& ! reg_overlap_mentioned_p (operands[1], operands[0])\"\n   [(set (match_dup 0) (const_int 0))\n-   (set (match_dup 0) (if_then_else:SI (ne:DI (match_dup 1)\n-                                              (const_int 0))\n-                                       (const_int 1)\n-                                       (match_dup 0)))]\n+   (set (match_dup 0) (if_then_else:W (eq:DI (match_dup 1) (const_int 0))\n+                                      (const_int 1)\n+                                      (match_dup 0)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*snedi_zero_trunc_vis3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ne:SI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t       (const_int 0)))\n+(define_insn_and_split \"*seqdi<W:mode>_zero_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(eq:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t      (const_int 0)))\n    (clobber (reg:CCX CC_REG))]\n-  \"TARGET_ARCH64 && TARGET_VIS3\"\n+  \"TARGET_ARCH64 && TARGET_SUBXC\"\n   \"#\"\n   \"\"\n-  [(set (reg:CCX_NOOV CC_REG) (compare:CCX_NOOV (neg:DI (match_dup 1))\n-\t\t\t\t\t        (const_int 0)))\n-   (set (match_dup 0) (ltu:SI (reg:CCX CC_REG) (const_int 0)))]\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (geu:W (reg:CCXC CC_REG) (const_int 0)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*seqsi<P:mode>_zero\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-\t(eq:P (match_operand:SI 1 \"register_operand\" \"r\")\n-\t       (const_int 0)))\n-   (clobber (reg:CC CC_REG))]\n+(define_insn_and_split \"*neg_seqdi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=&r\")\n+        (neg:W (eq:W (match_operand:DI 1 \"register_operand\" \"r\")\n+                     (const_int 0))))]\n+  \"TARGET_ARCH64 && !TARGET_VIS3\"\n+  \"#\"\n+  \"&& ! reg_overlap_mentioned_p (operands[1], operands[0])\"\n+  [(set (match_dup 0) (const_int 0))\n+   (set (match_dup 0) (if_then_else:W (eq:DI (match_dup 1) (const_int 0))\n+                                      (const_int -1)\n+                                      (match_dup 0)))]\n   \"\"\n+  [(set_attr \"length\" \"2\")]) \n+\n+(define_insn_and_split \"*neg_seqdi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (eq:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t     (const_int 0))))\n+   (clobber (reg:CCX CC_REG))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\"\n   \"#\"\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (geu:P (reg:CC CC_REG) (const_int 0)))]\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (neg:W (geu:W (reg:CCXC CC_REG) (const_int 0))))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*neg_seqsisi_zero\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t       (const_int 0))))\n+;; We can also do (x + (i == 0)) and related, so put them in.\n+\n+(define_insn_and_split \"*plus_snesi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (ne:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t      (const_int 0))\n+\t\t(match_operand:W 2 \"register_operand\" \"r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (neg:SI (geu:SI (reg:CC CC_REG) (const_int 0))))]\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (plus:W (ltu:W (reg:CCC CC_REG) (const_int 0))\n+\t\t\t      (match_dup 2)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*neg_seqsidi_zero\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(neg:DI (eq:DI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t       (const_int 0))))\n+(define_insn_and_split \"*plus_plus_snesi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (plus:W (ne:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t      (const_int 0))\n+\t\t\t(match_operand:W 2 \"register_operand\" \"r\"))\n+                 (match_operand:W 3 \"register_operand\" \"r\")))\n    (clobber (reg:CC CC_REG))]\n-  \"TARGET_ARCH64\"\n+  \"\"\n   \"#\"\n-  \"&& 1\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (sign_extend:DI (neg:SI (geu:SI (reg:CC CC_REG)\n-                                                      (const_int 0)))))]\n+  \"\"\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (plus:W (plus:W (ltu:W (reg:CCC CC_REG) (const_int 0))\n+\t\t\t\t      (match_dup 2))\n+\t\t      (match_dup 3)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*seqdi_zero\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-        (eq:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-               (const_int 0)))]\n-  \"TARGET_ARCH64\"\n+(define_insn_and_split \"*plus_snedi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (ne:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t      (const_int 0))\n+\t\t(match_operand:W 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CCX CC_REG))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\"\n   \"#\"\n-  \"&& ! reg_overlap_mentioned_p (operands[1], operands[0])\"\n-  [(set (match_dup 0) (const_int 0))\n-   (set (match_dup 0) (if_then_else:DI (eq:DI (match_dup 1)\n-                                              (const_int 0))\n-                                       (const_int 1)\n-                                       (match_dup 0)))]\n+  \"\"\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (plus:W (ltu:W (reg:CCXC CC_REG) (const_int 0))\n+\t\t\t      (match_dup 2)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*neg_seqdi_zero\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-        (neg:DI (eq:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                       (const_int 0))))]\n-  \"TARGET_ARCH64\"\n+(define_insn_and_split \"*plus_plus_snedi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (plus:W (ne:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t      (const_int 0))\n+\t\t\t(match_operand:W 2 \"register_operand\" \"r\"))\n+                 (match_operand:W 3 \"register_operand\" \"r\")))\n+   (clobber (reg:CCX CC_REG))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\"\n   \"#\"\n-  \"&& ! reg_overlap_mentioned_p (operands[1], operands[0])\"\n-  [(set (match_dup 0) (const_int 0))\n-   (set (match_dup 0) (if_then_else:DI (eq:DI (match_dup 1)\n-                                              (const_int 0))\n-                                       (const_int -1)\n-                                       (match_dup 0)))]\n   \"\"\n-  [(set_attr \"length\" \"2\")]) \n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (plus:W (plus:W (ltu:W (reg:CCXC CC_REG) (const_int 0))\n+\t\t\t\t      (match_dup 2))\n+\t\t      (match_dup 3)))]\n+  \"\"\n+  [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*seqdi_zero_trunc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-        (eq:SI (match_operand:DI 1 \"register_operand\" \"r\")\n-               (const_int 0)))]\n-  \"TARGET_ARCH64\"\n+(define_insn_and_split \"*minus_snesi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (match_operand:W 2 \"register_operand\" \"r\")\n+\t\t  (ne:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t(const_int 0))))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n   \"#\"\n-  \"&& ! reg_overlap_mentioned_p (operands[1], operands[0])\"\n-  [(set (match_dup 0) (const_int 0))\n-   (set (match_dup 0) (if_then_else:SI (eq:DI (match_dup 1)\n-                                              (const_int 0))\n-                                       (const_int 1)\n-                                       (match_dup 0)))]\n+  \"\"\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (minus:W (match_dup 2)\n+\t\t\t       (ltu:W (reg:CCC CC_REG) (const_int 0))))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-;; We can also do (x + (i == 0)) and related, so put them in.\n-;; ??? The addx/subx insns use the 32 bit carry flag so there are no DImode\n-;; versions for v9.\n-\n-(define_insn_and_split \"*x_plus_i_ne_0\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t(const_int 0))\n-\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+(define_insn_and_split \"*minus_minus_snesi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (minus:W (match_operand:W 2 \"register_operand\" \"r\")\n+\t\t\t  (ne:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 0)))\n+\t\t (match_operand:W 3 \"register_operand\" \"r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (plus:SI (ltu:SI (reg:CC CC_REG) (const_int 0))\n-\t\t\t       (match_dup 2)))]\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (minus:W (minus:W (match_dup 2)\n+\t\t\t\t        (ltu:W (reg:CCC CC_REG) (const_int 0)))\n+\t\t\t       (match_dup 3)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*x_minus_i_ne_0\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t  (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (const_int 0))))\n-   (clobber (reg:CC CC_REG))]\n+(define_insn_and_split \"*minus_snedi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (match_operand:W 2 \"register_operand\" \"r\")\n+\t\t  (ne:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t(const_int 0))))\n+   (clobber (reg:CCX CC_REG))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (minus:W (match_dup 2)\n+\t\t\t       (ltu:W (reg:CCXC CC_REG) (const_int 0))))]\n   \"\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn_and_split \"*minus_minus_snedi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (minus:W (match_operand:W 2 \"register_operand\" \"r\")\n+\t\t\t  (ne:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t\t(const_int 0)))\n+\t\t (match_operand:W 3 \"register_operand\" \"r\")))\n+   (clobber (reg:CCX CC_REG))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\"\n   \"#\"\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (minus:SI (match_dup 2)\n-\t\t\t\t(ltu:SI (reg:CC CC_REG) (const_int 0))))]\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (minus:W (minus:W (match_dup 2)\n+\t\t\t\t        (ltu:W (reg:CCXC CC_REG) (const_int 0)))\n+\t\t\t       (match_dup 3)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*x_plus_i_eq_0\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t(const_int 0))\n-\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+(define_insn_and_split \"*plus_seqsi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (eq:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t      (const_int 0))\n+\t\t(match_operand:W 2 \"register_operand\" \"r\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (plus:SI (geu:SI (reg:CC CC_REG) (const_int 0))\n-\t\t\t       (match_dup 2)))]\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (plus:W (geu:W (reg:CCC CC_REG) (const_int 0))\n+\t\t\t      (match_dup 2)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*x_minus_i_eq_0\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t  (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (const_int 0))))\n+(define_insn_and_split \"*plus_seqdi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (eq:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t      (const_int 0))\n+\t\t(match_operand:W 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CCX CC_REG))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (plus:W (geu:W (reg:CCXC CC_REG) (const_int 0))\n+\t\t\t      (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn_and_split \"*minus_seqsi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (match_operand:W 2 \"register_operand\" \"r\")\n+\t\t (eq:W (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t       (const_int 0))))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n-\t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (minus:SI (match_dup 2)\n-\t\t\t\t(geu:SI (reg:CC CC_REG) (const_int 0))))]\n+  [(set (reg:CCC CC_REG) (compare:CCC (not:SI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (minus:W (match_dup 2)\n+\t\t\t       (geu:W (reg:CCC CC_REG) (const_int 0))))]\n+  \"\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn_and_split \"*minus_seqdi<W:mode>_zero\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (match_operand:W 2 \"register_operand\" \"r\")\n+\t\t (eq:W (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t       (const_int 0))))\n+   (clobber (reg:CCX CC_REG))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:CCXC CC_REG) (compare:CCXC (not:DI (match_dup 1)) (const_int -1)))\n+   (set (match_dup 0) (minus:W (match_dup 2)\n+\t\t\t       (geu:W (reg:CCXC CC_REG) (const_int 0))))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n ;; We can also do GEU and LTU directly, but these operate after a compare.\n-;; ??? The addx/subx insns use the 32 bit carry flag so there are no DImode\n-;; versions for v9.\n \n-(define_insn \"*sltu<P:mode>_insn\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-\t(ltu:P (reg:CC CC_REG) (const_int 0)))]\n-  \"\"\n+(define_insn \"*sltu<W:mode>_insn\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(ltu:W (match_operand 1 \"icc_register_operand\" \"X\") (const_int 0)))]\n+  \"GET_MODE (operands[1]) == CCmode || GET_MODE (operands[1]) == CCCmode\"\n   \"addx\\t%%g0, 0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sltu_insn_vis3\"\n+(define_insn \"*plus_sltu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (ltu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t       (const_int 0))\n+\t\t(match_operand:W 1 \"arith_operand\" \"rI\")))]\n+  \"GET_MODE (operands[2]) == CCmode || GET_MODE (operands[2]) == CCCmode\"\n+  \"addx\\t%%g0, %1, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*plus_plus_sltu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (plus:W (ltu:W (match_operand 3 \"icc_register_operand\" \"X\")\n+\t\t\t       (const_int 0))\n+\t\t\t(match_operand:W 1 \"arith_operand\" \"%r\"))\n+\t\t(match_operand:W 2 \"arith_operand\" \"rI\")))]\n+  \"GET_MODE (operands[3]) == CCmode || GET_MODE (operands[3]) == CCCmode\"\n+  \"addx\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*neg_sgeu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (geu:W (match_operand 1 \"icc_register_operand\" \"X\")\n+\t\t      (const_int 0))))]\n+  \"GET_MODE (operands[1]) == CCmode || GET_MODE (operands[1]) == CCCmode\"\n+  \"addx\\t%%g0, -1, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*neg_sgeusidi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ltu:DI (reg:CCX CC_REG) (const_int 0)))]\n-  \"TARGET_ARCH64 && TARGET_VIS3\"\n-  \"addxc\\t%%g0, %%g0, %0\"\n+\t(sign_extend:DI (neg:SI (geu:SI (match_operand 1 \"icc_register_operand\" \"X\")\n+\t\t\t\t\t(const_int 0)))))]\n+  \"TARGET_ARCH64\n+   && (GET_MODE (operands[1]) == CCmode || GET_MODE (operands[1]) == CCCmode)\"\n+  \"addx\\t%%g0, -1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sltu_insn_vis3_trunc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ltu:SI (reg:CCX CC_REG) (const_int 0)))]\n-  \"TARGET_ARCH64 && TARGET_VIS3\"\n+(define_insn \"*minus_sgeu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (match_operand:W 1 \"register_operand\" \"r\")\n+\t\t (geu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t\t(const_int 0))))]\n+  \"GET_MODE (operands[2]) == CCmode || GET_MODE (operands[2]) == CCCmode\"\n+  \"addx\\t%1, -1, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*addx<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (plus:W (match_operand:W 1 \"arith_operand\" \"%r\")\n+\t\t\t(match_operand:W 2 \"arith_operand\" \"rI\"))\n+\t\t(ltu:W (match_operand 3 \"icc_register_operand\" \"X\")\n+\t\t       (const_int 0))))]\n+  \"GET_MODE (operands[3]) == CCmode || GET_MODE (operands[3]) == CCCmode\"\n+  \"addx\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*sltu<W:mode>_insn_vis3\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(ltu:W (match_operand 1 \"icc_register_operand\" \"X\") (const_int 0)))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\n+   && (GET_MODE (operands[1]) == CCXmode || GET_MODE (operands[1]) == CCXCmode)\"\n   \"addxc\\t%%g0, %%g0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*neg_sltusi_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (ltu:SI (reg:CC CC_REG) (const_int 0))))]\n-  \"\"\n+(define_insn \"*plus_sltu<W:mode>_vis3\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (ltu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t       (const_int 0))\n+\t\t(match_operand:W 1 \"arith_operand\" \"rI\")))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\n+   && (GET_MODE (operands[2]) == CCXmode || GET_MODE (operands[2]) == CCXCmode)\"\n+  \"addxc\\t%%g0, %1, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*plus_plus_sltu<W:mode>_vis3\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (plus:W (ltu:W (match_operand 3 \"icc_register_operand\" \"X\")\n+\t\t\t       (const_int 0))\n+\t\t\t(match_operand:W 1 \"arith_operand\" \"%r\"))\n+\t\t(match_operand:W 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\n+   && (GET_MODE (operands[3]) == CCXmode || GET_MODE (operands[3]) == CCXCmode)\"\n+  \"addxc\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*neg_sgeu<W:mode>_vis3\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (geu:W (match_operand 1 \"icc_register_operand\" \"X\")\n+\t\t      (const_int 0))))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\n+   && (GET_MODE (operands[1]) == CCXmode || GET_MODE (operands[1]) == CCXCmode)\"\n+  \"addxc\\t%%g0, -1, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*minus_sgeu<W:mode>_vis3\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (match_operand:W 1 \"register_operand\" \"r\")\n+\t\t (geu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t        (const_int 0))))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\n+   && (GET_MODE (operands[2]) == CCXmode || GET_MODE (operands[2]) == CCXCmode)\"\n+  \"addxc\\t%1, -1, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*addxc<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (plus:W (match_operand:W 1 \"register_or_zero_operand\" \"%rJ\")\n+\t\t\t(match_operand:W 2 \"register_or_zero_operand\" \"rJ\"))\n+\t\t(ltu:W (match_operand 3 \"icc_register_operand\" \"X\")\n+\t\t       (const_int 0))))]\n+  \"TARGET_ARCH64 && TARGET_VIS3\n+   && (GET_MODE (operands[3]) == CCXmode || GET_MODE (operands[3]) == CCXCmode)\"\n+  \"addxc\\t%r1, %r2, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*neg_sltu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (ltu:W (match_operand 1 \"icc_register_operand\" \"X\")\n+\t\t      (const_int 0))))]\n+  \"GET_MODE (operands[1]) == CCmode || GET_MODE (operands[1]) == CCCmode\"\n   \"subx\\t%%g0, 0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*neg_sltudi_insn\"\n+(define_insn \"*neg_sltusidi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:DI (neg:SI (ltu:SI (reg:CC CC_REG) (const_int 0)))))]\n-  \"TARGET_ARCH64\"\n+\t(sign_extend:DI (neg:SI (ltu:SI (match_operand 1 \"icc_register_operand\" \"X\")\n+\t\t\t\t\t(const_int 0)))))]\n+  \"TARGET_ARCH64\n+   && (GET_MODE (operands[1]) == CCmode || GET_MODE (operands[1]) == CCCmode)\"\n   \"subx\\t%%g0, 0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*neg_sltu_minus_x\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (neg:SI (ltu:SI (reg:CC CC_REG) (const_int 0)))\n-\t\t  (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n-  \"\"\n+(define_insn \"*minus_neg_sltu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (neg:W (ltu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t\t       (const_int 0)))\n+\t\t (match_operand:W 1 \"arith_operand\" \"rI\")))]\n+  \"GET_MODE (operands[2]) == CCmode || GET_MODE (operands[2]) == CCCmode\"\n   \"subx\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*neg_sltu_plus_x\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (plus:SI (ltu:SI (reg:CC CC_REG) (const_int 0))\n-\t\t\t (match_operand:SI 1 \"arith_operand\" \"rI\"))))]\n-  \"\"\n+(define_insn \"*neg_plus_sltu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (plus:W (ltu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t\t      (const_int 0))\n+\t\t       (match_operand:W 1 \"arith_operand\" \"rI\"))))]\n+  \"GET_MODE (operands[2]) == CCmode || GET_MODE (operands[2]) == CCCmode\"\n   \"subx\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sgeu<P:mode>_insn\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n-\t(geu:P (reg:CC CC_REG) (const_int 0)))]\n-  \"\"\n+(define_insn \"*minus_sltu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (match_operand:W 1 \"register_operand\" \"r\")\n+\t\t (ltu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t\t(const_int 0))))]\n+  \"GET_MODE (operands[2]) == CCmode || GET_MODE (operands[2]) == CCCmode\"\n+  \"subx\\t%1, 0, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*minus_minus_sltu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (minus:W (match_operand:W 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t  (ltu:W (match_operand 3 \"icc_register_operand\" \"X\")\n+\t\t\t\t (const_int 0)))\n+\t\t (match_operand:W 2 \"arith_operand\" \"rI\")))]\n+  \"GET_MODE (operands[3]) == CCmode || GET_MODE (operands[3]) == CCCmode\"\n+  \"subx\\t%r1, %2, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n+\n+(define_insn \"*sgeu<W:mode>_insn\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(geu:W (match_operand 1 \"icc_register_operand\" \"X\") (const_int 0)))]\n+  \"GET_MODE (operands[1]) == CCmode || GET_MODE (operands[1]) == CCCmode\"\n   \"subx\\t%%g0, -1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*neg_sgeusi_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (geu:SI (reg:CC CC_REG) (const_int 0))))]\n-  \"\"\n-  \"addx\\t%%g0, -1, %0\"\n+(define_insn \"*plus_sgeu<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (geu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t       (const_int 0))\n+\t\t(match_operand:W 1 \"register_operand\" \"r\")))]\n+  \"GET_MODE (operands[2]) == CCmode || GET_MODE (operands[2]) == CCCmode\"\n+  \"subx\\t%1, -1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*neg_sgeudi_insn\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:DI (neg:SI (geu:SI (reg:CC CC_REG) (const_int 0)))))]\n-  \"TARGET_ARCH64\"\n-  \"addx\\t%%g0, -1, %0\"\n+(define_insn \"*subx<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (minus:W (match_operand:W 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t  (match_operand:W 2 \"arith_operand\" \"rI\"))\n+\t\t (ltu:W (match_operand 3 \"icc_register_operand\" \"X\")\n+\t\t        (const_int 0))))]\n+  \"GET_MODE (operands[3]) == CCmode || GET_MODE (operands[3]) == CCCmode\"\n+  \"subx\\t%r1, %2, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-;; We can also do (x + ((unsigned) i >= 0)) and related, so put them in.\n-;; ??? The addx/subx insns use the 32 bit carry flag so there are no DImode\n-;; versions for v9.\n+(define_insn \"*neg_sltu<W:mode>_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (ltu:W (match_operand 1 \"icc_register_operand\" \"X\")\n+\t\t      (const_int 0))))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\n+   && (GET_MODE (operands[1]) == CCXmode || GET_MODE (operands[1]) == CCXCmode)\"\n+  \"subxc\\t%%g0, 0, %0\"\n+  [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sltu_plus_x\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (ltu:SI (reg:CC CC_REG) (const_int 0))\n-\t\t (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n-  \"\"\n-  \"addx\\t%%g0, %1, %0\"\n+(define_insn \"*minus_neg_sltu<W:mode>_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (neg:W (ltu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t\t       (const_int 0)))\n+\t\t (match_operand:W 1 \"arith_operand\" \"rI\")))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\n+   && (GET_MODE (operands[2]) == CCXmode || GET_MODE (operands[2]) == CCXCmode)\"\n+  \"subxc\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sltu_plus_x_plus_y\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (ltu:SI (reg:CC CC_REG) (const_int 0))\n-\t\t (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n-\t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n-  \"\"\n-  \"addx\\t%1, %2, %0\"\n+(define_insn \"*neg_plus_sltu<W:mode>_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(neg:W (plus:W (ltu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t\t      (const_int 0))\n+\t\t       (match_operand:W 1 \"arith_operand\" \"rI\"))))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\n+   && (GET_MODE (operands[2]) == CCXmode || GET_MODE (operands[2]) == CCXCmode)\"\n+  \"subxc\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*x_minus_sltu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (ltu:SI (reg:CC CC_REG) (const_int 0))))]\n-  \"\"\n-  \"subx\\t%1, 0, %0\"\n+(define_insn \"*minus_sltu<W:mode>_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (match_operand:W 1 \"register_operand\" \"r\")\n+\t\t (ltu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t\t(const_int 0))))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\n+   && (GET_MODE (operands[2]) == CCXmode || GET_MODE (operands[2]) == CCXCmode)\"\n+  \"subxc\\t%1, 0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-;; ??? Combine should canonicalize these next two to the same pattern.\n-(define_insn \"*x_minus_y_minus_sltu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-\t\t  (ltu:SI (reg:CC CC_REG) (const_int 0))))]\n-  \"\"\n-  \"subx\\t%r1, %2, %0\"\n+(define_insn \"*minus_minus_sltu<W:mode>_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (minus:W (match_operand:W 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t  (ltu:W (match_operand 3 \"icc_register_operand\" \"X\")\n+\t\t\t\t (const_int 0)))\n+\t\t (match_operand:W 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\n+   && (GET_MODE (operands[3]) == CCXmode || GET_MODE (operands[3]) == CCXCmode)\"\n+  \"subxc\\t%r1, %2, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*x_minus_sltu_plus_y\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t  (plus:SI (ltu:SI (reg:CC CC_REG) (const_int 0))\n-\t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n-  \"\"\n-  \"subx\\t%r1, %2, %0\"\n+(define_insn \"*sgeu<W:mode>_insn_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(geu:W (match_operand 1 \"icc_register_operand\" \"X\") (const_int 0)))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\n+   && (GET_MODE (operands[1]) == CCXmode || GET_MODE (operands[1]) == CCXCmode)\"\n+  \"subxc\\t%%g0, -1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sgeu_plus_x\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (geu:SI (reg:CC CC_REG) (const_int 0))\n-\t\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"subx\\t%1, -1, %0\"\n+(define_insn \"*plus_sgeu<W:mode>_subxc\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(plus:W (geu:W (match_operand 2 \"icc_register_operand\" \"X\")\n+\t\t       (const_int 0))\n+\t\t(match_operand:W 1 \"register_operand\" \"r\")))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\n+   && (GET_MODE (operands[2]) == CCXmode || GET_MODE (operands[2]) == CCXCmode)\"\n+  \"subxc\\t%1, -1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*x_minus_sgeu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (geu:SI (reg:CC CC_REG) (const_int 0))))]\n-  \"\"\n-  \"addx\\t%1, -1, %0\"\n+(define_insn \"*subxc<W:mode>\"\n+  [(set (match_operand:W 0 \"register_operand\" \"=r\")\n+\t(minus:W (minus:W (match_operand:W 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t  (match_operand:W 2 \"arith_operand\" \"rI\"))\n+\t\t (ltu:W (match_operand 3 \"icc_register_operand\" \"X\")\n+\t\t\t(const_int 0))))]\n+  \"TARGET_ARCH64 && TARGET_SUBXC\n+   && (GET_MODE (operands[3]) == CCXmode || GET_MODE (operands[3]) == CCXCmode)\"\n+  \"subxc\\t%r1, %2, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operator:SI 2 \"noov_compare_operator\"\n-\t\t\t   [(match_operand 1 \"icc_or_fcc_register_operand\" \"\")\n-\t\t\t    (const_int 0)]))]\n+  [(set (match_operand:W 0 \"register_operand\" \"\")\n+\t(match_operator:W 1 \"icc_comparison_operator\"\n+\t  [(match_operand 2 \"icc_register_operand\" \"\") (const_int 0)]))]\n   \"TARGET_V9\n-   && REGNO (operands[1]) == SPARC_ICC_REG\n-   && (GET_MODE (operands[1]) == CCXmode\n-       /* 32-bit LTU/GEU are better implemented using addx/subx.  */\n-       || (GET_CODE (operands[2]) != LTU && GET_CODE (operands[2]) != GEU))\"\n+   /* 64-bit LTU is better implemented using addxc with VIS3.  */\n+   && !(GET_CODE (operands[1]) == LTU\n+\t&& (GET_MODE (operands[2]) == CCXmode\n+\t    || GET_MODE (operands[2]) == CCXCmode)\n+\t&& TARGET_VIS3)\n+   /* 64-bit GEU is better implemented using subxc with SUBXC.  */\n+   && !(GET_CODE (operands[1]) == GEU\n+\t&& (GET_MODE (operands[2]) == CCXmode\n+\t    || GET_MODE (operands[2]) == CCXCmode)\n+\t&& TARGET_SUBXC)\n+   /* 32-bit LTU/GEU are better implemented using addx/subx.  */\n+   && !((GET_CODE (operands[1]) == LTU || GET_CODE (operands[1]) == GEU)\n+\t&& (GET_MODE (operands[2]) == CCmode\n+\t    || GET_MODE (operands[2]) == CCCmode))\"\n   [(set (match_dup 0) (const_int 0))\n    (set (match_dup 0)\n-\t(if_then_else:SI (match_op_dup:SI 2 [(match_dup 1) (const_int 0)])\n+\t(if_then_else:SI (match_op_dup:W 1 [(match_dup 2) (const_int 0)])\n \t\t\t (const_int 1)\n \t\t\t (match_dup 0)))]\n   \"\")\n \n-\n ;; These control RTL generation for conditional jump insns\n \n (define_expand \"cbranchcc4\"\n@@ -1195,7 +1384,7 @@\n ;; XXX fpcmp nop braindamage\n (define_insn \"*normal_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"noov_compare_operator\"\n+\t(if_then_else (match_operator 0 \"icc_comparison_operator\"\n \t\t\t\t      [(reg CC_REG) (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n@@ -1211,7 +1400,7 @@\n ;; XXX fpcmp nop braindamage\n (define_insn \"*inverted_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"noov_compare_operator\"\n+\t(if_then_else (match_operator 0 \"icc_comparison_operator\"\n \t\t\t\t      [(reg CC_REG) (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n@@ -1297,7 +1486,7 @@\n \n (define_insn \"*cbcond_sp32\"\n   [(set (pc)\n-        (if_then_else (match_operator 0 \"noov_compare_operator\"\n+        (if_then_else (match_operator 0 \"comparison_operator\"\n                        [(match_operand:SI 1 \"register_operand\" \"r\")\n                         (match_operand:SI 2 \"arith5_operand\" \"rA\")])\n                       (label_ref (match_operand 3 \"\" \"\"))\n@@ -1310,7 +1499,7 @@\n \n (define_insn \"*cbcond_sp64\"\n   [(set (pc)\n-        (if_then_else (match_operator 0 \"noov_compare_operator\"\n+        (if_then_else (match_operator 0 \"comparison_operator\"\n                        [(match_operand:DI 1 \"register_operand\" \"r\")\n                         (match_operand:DI 2 \"arith5_operand\" \"rA\")])\n                       (label_ref (match_operand 3 \"\" \"\"))\n@@ -1321,11 +1510,11 @@\n }\n   [(set_attr \"type\" \"cbcond\")])\n \n-;; There are no 32 bit brreg insns.\n+;; There are no 32-bit brreg insns.\n \n (define_insn \"*normal_int_branch_sp64\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"v9_register_compare_operator\"\n+\t(if_then_else (match_operator 0 \"v9_register_comparison_operator\"\n \t\t\t\t      [(match_operand:DI 1 \"register_operand\" \"r\")\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n@@ -1341,7 +1530,7 @@\n \n (define_insn \"*inverted_int_branch_sp64\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"v9_register_compare_operator\"\n+\t(if_then_else (match_operator 0 \"v9_register_comparison_operator\"\n \t\t\t\t      [(match_operand:DI 1 \"register_operand\" \"r\")\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n@@ -2696,7 +2885,7 @@\n \n (define_insn \"*mov<I:mode>_cc_v9\"\n   [(set (match_operand:I 0 \"register_operand\" \"=r\")\n-\t(if_then_else:I (match_operator 1 \"comparison_operator\"\n+\t(if_then_else:I (match_operator 1 \"icc_or_fcc_comparison_operator\"\n \t\t\t       [(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t\t(const_int 0)])\n \t\t\t(match_operand:I 3 \"arith11_operand\" \"rL\")\n@@ -2707,7 +2896,7 @@\n \n (define_insn \"*mov<I:mode>_cc_reg_sp64\"\n   [(set (match_operand:I 0 \"register_operand\" \"=r\")\n-\t(if_then_else:I (match_operator 1 \"v9_register_compare_operator\"\n+\t(if_then_else:I (match_operator 1 \"v9_register_comparison_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n \t\t\t(match_operand:I 3 \"arith10_operand\" \"rM\")\n@@ -2718,7 +2907,7 @@\n \n (define_insn \"*movsf_cc_v9\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(if_then_else:SF (match_operator 1 \"comparison_operator\"\n+\t(if_then_else:SF (match_operator 1 \"icc_or_fcc_comparison_operator\"\n \t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t\t (const_int 0)])\n \t\t\t (match_operand:SF 3 \"register_operand\" \"f\")\n@@ -2729,7 +2918,7 @@\n \n (define_insn \"*movsf_cc_reg_sp64\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(if_then_else:SF (match_operator 1 \"v9_register_compare_operator\"\n+\t(if_then_else:SF (match_operator 1 \"v9_register_comparison_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n \t\t\t (match_operand:SF 3 \"register_operand\" \"f\")\n@@ -2741,7 +2930,7 @@\n ;; Named because invoked by movtf_cc_v9\n (define_insn \"movdf_cc_v9\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n-\t(if_then_else:DF (match_operator 1 \"comparison_operator\"\n+\t(if_then_else:DF (match_operator 1 \"icc_or_fcc_comparison_operator\"\n \t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t\t (const_int 0)])\n \t\t\t (match_operand:DF 3 \"register_operand\" \"e\")\n@@ -2754,7 +2943,7 @@\n ;; Named because invoked by movtf_cc_reg_sp64\n (define_insn \"movdf_cc_reg_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n-\t(if_then_else:DF (match_operator 1 \"v9_register_compare_operator\"\n+\t(if_then_else:DF (match_operator 1 \"v9_register_comparison_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n \t\t\t (match_operand:DF 3 \"register_operand\" \"e\")\n@@ -2766,7 +2955,7 @@\n \n (define_insn \"*movtf_cc_hq_v9\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n+\t(if_then_else:TF (match_operator 1 \"icc_or_fcc_comparison_operator\"\n \t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t\t (const_int 0)])\n \t\t\t (match_operand:TF 3 \"register_operand\" \"e\")\n@@ -2777,7 +2966,7 @@\n \n (define_insn \"*movtf_cc_reg_hq_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n+\t(if_then_else:TF (match_operator 1 \"v9_register_comparison_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n \t\t\t (match_operand:TF 3 \"register_operand\" \"e\")\n@@ -2788,7 +2977,7 @@\n \n (define_insn_and_split \"*movtf_cc_v9\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n+\t(if_then_else:TF (match_operator 1 \"icc_or_fcc_comparison_operator\"\n \t\t\t    [(match_operand 2 \"icc_or_fcc_register_operand\" \"X\")\n \t\t\t     (const_int 0)])\n \t\t\t (match_operand:TF 3 \"register_operand\" \"e\")\n@@ -2824,7 +3013,7 @@\n \n (define_insn_and_split \"*movtf_cc_reg_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n+\t(if_then_else:TF (match_operator 1 \"v9_register_comparison_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r\")\n \t\t\t\t (const_int 0)])\n \t\t\t (match_operand:TF 3 \"register_operand\" \"e\")\n@@ -3616,36 +3805,29 @@\n \t\t (match_operand:DI 2 \"arith_double_add_operand\" \"\")))]\n   \"\"\n {\n-  if (! TARGET_ARCH64)\n+  if (!TARGET_ARCH64)\n     {\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n-\t\t\t  gen_rtx_SET (operands[0],\n-\t\t\t\t   gen_rtx_PLUS (DImode, operands[1],\n-\t\t\t\t\t\t operands[2])),\n-\t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_REG (CCmode, SPARC_ICC_REG)))));\n+      emit_insn (gen_adddi3_sp32 (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n })\n \n-(define_insn_and_split \"*adddi3_insn_sp32\"\n+(define_insn_and_split \"adddi3_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-\t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n \t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n    (clobber (reg:CC CC_REG))]\n-  \"! TARGET_ARCH64\"\n+  \"!TARGET_ARCH64\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (reg:CC_NOOV CC_REG)\n-\t\t   (compare:CC_NOOV (plus:SI (match_dup 4)\n-\t\t\t\t\t     (match_dup 5))\n-\t\t\t\t    (const_int 0)))\n+  [(parallel [(set (reg:CCC CC_REG)\n+\t\t   (compare:CCC (plus:SI (match_dup 4) (match_dup 5))\n+\t\t\t\t(match_dup 4)))\n \t      (set (match_dup 3)\n \t\t   (plus:SI (match_dup 4) (match_dup 5)))])\n    (set (match_dup 6)\n-\t(plus:SI (plus:SI (match_dup 7)\n-\t\t\t  (match_dup 8))\n-\t\t (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0))))]\n+\t(plus:SI (plus:SI (match_dup 7) (match_dup 8))\n+\t\t (ltu:SI (reg:CCC CC_REG) (const_int 0))))]\n {\n   operands[3] = gen_lowpart (SImode, operands[0]);\n   operands[4] = gen_lowpart (SImode, operands[1]);\n@@ -3656,59 +3838,22 @@\n }\n   [(set_attr \"length\" \"2\")])\n \n-;; LTU here means \"carry set\"\n-(define_insn \"addx\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n-\t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-\t\t (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0))))]\n-  \"\"\n-  \"addx\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n-(define_insn \"addxc\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (plus:DI (match_operand:DI 1 \"register_or_zero_operand\" \"%rJ\")\n-\t\t\t  (match_operand:DI 2 \"register_or_zero_operand\" \"rJ\"))\n-\t\t (ltu:DI (reg:CCX_NOOV CC_REG) (const_int 0))))]\n-  \"TARGET_ARCH64 && TARGET_VIS3\"\n-  \"addxc\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n (define_insn_and_split \"*addx_extend_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (plus:SI (plus:SI\n-                                  (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ\")\n-                                  (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-                                 (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0)))))]\n+                                   (match_operand:SI 1 \"register_operand\" \"%r\")\n+                                   (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+                                 (ltu:SI (reg:CCC CC_REG) (const_int 0)))))]\n   \"! TARGET_ARCH64\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3) (plus:SI (plus:SI (match_dup 1) (match_dup 2))\n-                               (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0))))\n+                               (ltu:SI (reg:CCC CC_REG) (const_int 0))))\n    (set (match_dup 4) (const_int 0))]\n   \"operands[3] = gen_lowpart (SImode, operands[0]);\n    operands[4] = gen_highpart (SImode, operands[0]);\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn \"*addx_extend_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (plus:SI (plus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ\")\n-                                          (match_operand:SI 2 \"register_or_zero_operand\" \"rJ\"))\n-                                 (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0)))))]\n-  \"TARGET_ARCH64\"\n-  \"addx\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n-(define_insn \"*addxc_trunc_sp64_vis3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (plus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"%rJ\")\n-                          (match_operand:SI 2 \"register_or_zero_operand\" \"rJ\"))\n-                 (ltu:SI (reg:CCX_NOOV CC_REG) (const_int 0))))]\n-  \"TARGET_ARCH64 && TARGET_VIS3\"\n-  \"addxc\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n (define_insn_and_split \"*adddi3_extend_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n         (plus:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n@@ -3717,13 +3862,13 @@\n   \"! TARGET_ARCH64\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (reg:CC_NOOV CC_REG)\n-                   (compare:CC_NOOV (plus:SI (match_dup 3) (match_dup 1))\n-                                    (const_int 0)))\n+  [(parallel [(set (reg:CCC CC_REG)\n+                   (compare:CCC (plus:SI (match_dup 3) (match_dup 1))\n+                                (match_dup 3)))\n               (set (match_dup 5) (plus:SI (match_dup 3) (match_dup 1)))])\n    (set (match_dup 6)\n         (plus:SI (plus:SI (match_dup 4) (const_int 0))\n-                 (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0))))]\n+                 (ltu:SI (reg:CCC CC_REG) (const_int 0))))]\n   \"operands[3] = gen_lowpart (SImode, operands[2]);\n    operands[4] = gen_highpart (SImode, operands[2]);\n    operands[5] = gen_lowpart (SImode, operands[0]);\n@@ -3750,40 +3895,80 @@\n   [(set_attr \"type\" \"*,*\")\n    (set_attr \"fptype\" \"*,*\")])\n \n-(define_insn \"*cmp_cc_plus\"\n-  [(set (reg:CC_NOOV CC_REG)\n-\t(compare:CC_NOOV (plus:SI (match_operand:SI 0 \"arith_operand\" \"%r\")\n-\t\t\t\t  (match_operand:SI 1 \"arith_operand\" \"rI\"))\n-\t\t\t (const_int 0)))]\n+(define_insn \"*cmp_ccnz_plus\"\n+  [(set (reg:CCNZ CC_REG)\n+\t(compare:CCNZ (plus:SI (match_operand:SI 0 \"register_operand\" \"%r\")\n+\t\t\t       (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t      (const_int 0)))]\n+  \"\"\n+  \"addcc\\t%0, %1, %%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmp_ccxnz_plus\"\n+  [(set (reg:CCXNZ CC_REG)\n+\t(compare:CCXNZ (plus:DI (match_operand:DI 0 \"register_operand\" \"%r\")\n+\t\t\t        (match_operand:DI 1 \"arith_operand\" \"rI\"))\n+\t\t       (const_int 0)))]\n+  \"TARGET_ARCH64\"\n+  \"addcc\\t%0, %1, %%g0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmp_ccnz_plus_set\"\n+  [(set (reg:CCNZ CC_REG)\n+\t(compare:CCNZ (plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t       (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t      (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"addcc\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmp_ccxnz_plus_set\"\n+  [(set (reg:CCXNZ CC_REG)\n+\t(compare:CCXNZ (plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t\t        (match_operand:DI 2 \"arith_operand\" \"rI\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_ARCH64\"\n+  \"addcc\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmp_ccc_plus\"\n+  [(set (reg:CCC CC_REG)\n+\t(compare:CCC (plus:SI (match_operand:SI 0 \"register_operand\" \"%r\")\n+\t\t\t      (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t     (match_dup 0)))]\n   \"\"\n   \"addcc\\t%0, %1, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_ccx_plus\"\n-  [(set (reg:CCX_NOOV CC_REG)\n-\t(compare:CCX_NOOV (plus:DI (match_operand:DI 0 \"arith_operand\" \"%r\")\n-\t\t\t\t   (match_operand:DI 1 \"arith_operand\" \"rI\"))\n-\t\t\t  (const_int 0)))]\n+(define_insn \"*cmp_ccxc_plus\"\n+  [(set (reg:CCXC CC_REG)\n+\t(compare:CCXC (plus:DI (match_operand:DI 0 \"register_operand\" \"%r\")\n+\t\t\t       (match_operand:DI 1 \"arith_operand\" \"rI\"))\n+\t\t      (match_dup 0)))]\n   \"TARGET_ARCH64\"\n   \"addcc\\t%0, %1, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_cc_plus_set\"\n-  [(set (reg:CC_NOOV CC_REG)\n-\t(compare:CC_NOOV (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n-\t\t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-\t\t\t (const_int 0)))\n+(define_insn \"*cmp_ccc_plus_set\"\n+  [(set (reg:CCC CC_REG)\n+\t(compare:CCC (plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t      (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t     (match_dup 1)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"addcc\\t%1, %2, %0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_ccx_plus_set\"\n-  [(set (reg:CCX_NOOV CC_REG)\n-\t(compare:CCX_NOOV (plus:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n-\t\t\t\t   (match_operand:DI 2 \"arith_operand\" \"rI\"))\n-\t\t\t  (const_int 0)))\n+(define_insn \"*cmp_ccxc_plus_set\"\n+  [(set (reg:CCXC CC_REG)\n+\t(compare:CCXC (plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t\t       (match_operand:DI 2 \"arith_operand\" \"rI\"))\n+\t\t      (match_dup 1)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_dup 1) (match_dup 2)))]\n   \"TARGET_ARCH64\"\n@@ -3796,36 +3981,28 @@\n \t\t  (match_operand:DI 2 \"arith_double_add_operand\" \"\")))]\n   \"\"\n {\n-  if (! TARGET_ARCH64)\n+  if (!TARGET_ARCH64)\n     {\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n-\t\t\t  gen_rtx_SET (operands[0],\n-\t\t\t\t   gen_rtx_MINUS (DImode, operands[1],\n-\t\t\t\t\t\t  operands[2])),\n-\t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_REG (CCmode, SPARC_ICC_REG)))));\n+      emit_insn (gen_subdi3_sp32 (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n })\n \n-(define_insn_and_split \"*subdi3_insn_sp32\"\n+(define_insn_and_split \"subdi3_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t  (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n    (clobber (reg:CC CC_REG))]\n   \"! TARGET_ARCH64\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (reg:CC_NOOV CC_REG)\n-\t\t   (compare:CC_NOOV (minus:SI (match_dup 4)\n-\t\t\t\t\t      (match_dup 5))\n-\t\t\t\t    (const_int 0)))\n+  [(parallel [(set (reg:CC CC_REG)\n+\t\t   (compare:CC (match_dup 4) (match_dup 5)))\n \t      (set (match_dup 3)\n \t\t   (minus:SI (match_dup 4) (match_dup 5)))])\n    (set (match_dup 6)\n-\t(minus:SI (minus:SI (match_dup 7)\n-\t\t\t    (match_dup 8))\n-\t\t  (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0))))]\n+\t(minus:SI (minus:SI (match_dup 7) (match_dup 8))\n+\t\t  (ltu:SI (reg:CC CC_REG) (const_int 0))))]\n {\n   operands[3] = gen_lowpart (SImode, operands[0]);\n   operands[4] = gen_lowpart (SImode, operands[1]);\n@@ -3836,35 +4013,17 @@\n }\n   [(set_attr \"length\" \"2\")])\n \n-;; LTU here means \"carry set\"\n-(define_insn \"subx\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-\t\t  (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0))))]\n-  \"\"\n-  \"subx\\t%r1, %2, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n-(define_insn \"*subx_extend_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (minus:SI (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n-                                            (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-                                  (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0)))))]\n-  \"TARGET_ARCH64\"\n-  \"subx\\t%r1, %2, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n (define_insn_and_split \"*subx_extend_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (minus:SI (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n-                                            (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-                                  (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0)))))]\n+\t(zero_extend:DI (minus:SI (minus:SI\n+\t\t\t\t    (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+                                  (ltu:SI (reg:CCC CC_REG) (const_int 0)))))]\n   \"! TARGET_ARCH64\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3) (minus:SI (minus:SI (match_dup 1) (match_dup 2))\n-                                (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0))))\n+                                (ltu:SI (reg:CCC CC_REG) (const_int 0))))\n    (set (match_dup 4) (const_int 0))]\n   \"operands[3] = gen_lowpart (SImode, operands[0]);\n    operands[4] = gen_highpart (SImode, operands[0]);\"\n@@ -3878,13 +4037,12 @@\n   \"! TARGET_ARCH64\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (reg:CC_NOOV CC_REG)\n-                   (compare:CC_NOOV (minus:SI (match_dup 3) (match_dup 2))\n-                                    (const_int 0)))\n+  [(parallel [(set (reg:CC CC_REG)\n+                   (compare:CC (match_dup 3) (match_dup 2)))\n               (set (match_dup 5) (minus:SI (match_dup 3) (match_dup 2)))])\n    (set (match_dup 6)\n         (minus:SI (minus:SI (match_dup 4) (const_int 0))\n-                  (ltu:SI (reg:CC_NOOV CC_REG) (const_int 0))))]\n+                  (ltu:SI (reg:CC CC_REG) (const_int 0))))]\n   \"operands[3] = gen_lowpart (SImode, operands[1]);\n    operands[4] = gen_highpart (SImode, operands[1]);\n    operands[5] = gen_lowpart (SImode, operands[0]);\n@@ -3911,44 +4069,64 @@\n   [(set_attr \"type\" \"*,*\")\n    (set_attr \"fptype\" \"*,*\")])\n \n-(define_insn \"*cmp_minus_cc\"\n-  [(set (reg:CC_NOOV CC_REG)\n-\t(compare:CC_NOOV (minus:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t\t   (match_operand:SI 1 \"arith_operand\" \"rI\"))\n-\t\t\t (const_int 0)))]\n+(define_insn \"*cmp_ccnz_minus\"\n+  [(set (reg:CCNZ CC_REG)\n+\t(compare:CCNZ (minus:SI (match_operand:SI 0 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t\t(match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t      (const_int 0)))]\n   \"\"\n   \"subcc\\t%r0, %1, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_minus_ccx\"\n-  [(set (reg:CCX_NOOV CC_REG)\n-\t(compare:CCX_NOOV (minus:DI (match_operand:DI 0 \"register_operand\" \"r\")\n-\t\t\t\t    (match_operand:DI 1 \"arith_operand\" \"rI\"))\n-\t\t\t  (const_int 0)))]\n+(define_insn \"*cmp_ccxnz_minus\"\n+  [(set (reg:CCXNZ CC_REG)\n+\t(compare:CCXNZ (minus:DI (match_operand:DI 0 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t\t (match_operand:DI 1 \"arith_operand\" \"rI\"))\n+\t\t       (const_int 0)))]\n   \"TARGET_ARCH64\"\n-  \"subcc\\t%0, %1, %%g0\"\n+  \"subcc\\t%r0, %1, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"cmp_minus_cc_set\"\n-  [(set (reg:CC_NOOV CC_REG)\n-\t(compare:CC_NOOV (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))\n-\t\t\t (const_int 0)))\n+(define_insn \"*cmp_ccnz_minus_set\"\n+  [(set (reg:CCNZ CC_REG)\n+\t(compare:CCNZ (minus:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t\t(match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t      (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"subcc\\t%r1, %2, %0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_minus_ccx_set\"\n-  [(set (reg:CCX_NOOV CC_REG)\n-\t(compare:CCX_NOOV (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t\t    (match_operand:DI 2 \"arith_operand\" \"rI\"))\n-\t\t\t  (const_int 0)))\n+(define_insn \"*cmp_ccxnz_minus_set\"\n+  [(set (reg:CCXNZ CC_REG)\n+\t(compare:CCXNZ (minus:DI (match_operand:DI 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t\t (match_operand:DI 2 \"arith_operand\" \"rI\"))\n+\t\t       (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_dup 1) (match_dup 2)))]\n   \"TARGET_ARCH64\"\n-  \"subcc\\t%1, %2, %0\"\n+  \"subcc\\t%r1, %2, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmpsi_set\"\n+  [(set (reg:CC CC_REG)\n+\t(compare:CC (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"subcc\\t%r1, %2, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmpdi_set\"\n+  [(set (reg:CCX CC_REG)\n+\t(compare:CCX (match_operand:DI 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t     (match_operand:DI 2 \"arith_operand\" \"rI\")))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_ARCH64\"\n+  \"subcc\\t%r1, %2, %0\"\n   [(set_attr \"type\" \"compare\")])\n \n \n@@ -5040,33 +5218,25 @@\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n   \"\"\n {\n-  if (! TARGET_ARCH64)\n+  if (!TARGET_ARCH64)\n     {\n-      emit_insn (gen_rtx_PARALLEL\n-\t\t (VOIDmode,\n-\t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx_SET (operand0,\n-\t\t\t\t\t  gen_rtx_NEG (DImode, operand1)),\n-\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t      gen_rtx_REG (CCmode,\n-\t\t\t\t\t\t\t   SPARC_ICC_REG)))));\n+      emit_insn (gen_negdi2_sp32 (operands[0], operands[1]));\n       DONE;\n     }\n })\n \n-(define_insn_and_split \"*negdi2_sp32\"\n+(define_insn_and_split \"negdi2_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n    (clobber (reg:CC CC_REG))]\n   \"! TARGET_ARCH64\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(parallel [(set (reg:CC_NOOV CC_REG)\n-                   (compare:CC_NOOV (minus:SI (const_int 0) (match_dup 5))\n-                                    (const_int 0)))\n-              (set (match_dup 4) (minus:SI (const_int 0) (match_dup 5)))])\n+  [(parallel [(set (reg:CCC CC_REG)\n+                   (compare:CCC (not:SI (match_dup 5)) (const_int -1)))\n+              (set (match_dup 4) (neg:SI (match_dup 5)))])\n    (set (match_dup 2) (minus:SI (minus:SI (const_int 0) (match_dup 3))\n-                                (ltu:SI (reg:CC CC_REG) (const_int 0))))]\n+                                (ltu:SI (reg:CCC CC_REG) (const_int 0))))]\n   \"operands[2] = gen_highpart (SImode, operands[0]);\n    operands[3] = gen_highpart (SImode, operands[1]);\n    operands[4] = gen_lowpart (SImode, operands[0]);\n@@ -5085,42 +5255,63 @@\n   \"\"\n   \"sub\\t%%g0, %1, %0\")\n \n-(define_insn \"*cmp_cc_neg\"\n-  [(set (reg:CC_NOOV CC_REG)\n-\t(compare:CC_NOOV (neg:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n-\t\t\t (const_int 0)))]\n+(define_insn \"*cmp_ccnz_neg\"\n+  [(set (reg:CCNZ CC_REG)\n+\t(compare:CCNZ (neg:SI (match_operand:SI 0 \"arith_operand\" \"rI\"))\n+\t\t      (const_int 0)))]\n   \"\"\n   \"subcc\\t%%g0, %0, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_ccx_neg\"\n-  [(set (reg:CCX_NOOV CC_REG)\n-\t(compare:CCX_NOOV (neg:DI (match_operand:DI 0 \"arith_operand\" \"rI\"))\n-\t\t\t  (const_int 0)))]\n+(define_insn \"*cmp_ccxnz_neg\"\n+  [(set (reg:CCXNZ CC_REG)\n+\t(compare:CCXNZ (neg:DI (match_operand:DI 0 \"arith_operand\" \"rI\"))\n+\t\t       (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"subcc\\t%%g0, %0, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_cc_set_neg\"\n-  [(set (reg:CC_NOOV CC_REG)\n-\t(compare:CC_NOOV (neg:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n-\t\t\t (const_int 0)))\n+(define_insn \"*cmp_ccnz_neg_set\"\n+  [(set (reg:CCNZ CC_REG)\n+\t(compare:CCNZ (neg:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t      (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_dup 1)))]\n   \"\"\n   \"subcc\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_ccx_set_neg\"\n-  [(set (reg:CCX_NOOV CC_REG)\n-\t(compare:CCX_NOOV (neg:DI (match_operand:DI 1 \"arith_operand\" \"rI\"))\n-\t\t\t  (const_int 0)))\n+(define_insn \"*cmp_ccxnz_neg_set\"\n+  [(set (reg:CCXNZ CC_REG)\n+\t(compare:CCXNZ (neg:DI (match_operand:DI 1 \"arith_operand\" \"rI\"))\n+\t\t       (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(neg:DI (match_dup 1)))]\n   \"TARGET_ARCH64\"\n   \"subcc\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"compare\")])\n \n+(define_insn \"*cmp_ccc_neg_set\"\n+  [(set (reg:CCC CC_REG)\n+\t(compare:CCC (not:SI (match_operand:SI 1 \"arith_operand\" \"rI\"))\n+\t\t     (const_int -1)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_dup 1)))]\n+  \"\"\n+  \"subcc\\t%%g0, %1, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmp_ccxc_neg_set\"\n+  [(set (reg:CCXC CC_REG)\n+\t(compare:CCXC (not:DI (match_operand:DI 1 \"arith_operand\" \"rI\"))\n+\t\t      (const_int -1)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(neg:DI (match_dup 1)))]\n+  \"TARGET_ARCH64\"\n+  \"subcc\\t%%g0, %1, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+\n (define_insn \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (match_operand:DI 1 \"arith_operand\" \"rI\")))]\n@@ -5173,8 +5364,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(match_operand:SI 1 \"register_operand\" \"r\"))\n    (set (reg:CC CC_REG)\n-\t(compare:CC (match_dup 1)\n-\t\t    (const_int 0)))]\n+\t(compare:CC (match_dup 1) (const_int 0)))]\n   \"\"\n   \"orcc\\t%1, 0, %0\"\n   [(set_attr \"type\" \"compare\")])\n@@ -5183,8 +5373,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(match_operand:DI 1 \"register_operand\" \"r\"))\n    (set (reg:CCX CC_REG)\n-\t(compare:CCX (match_dup 1)\n-\t\t     (const_int 0)))]\n+\t(compare:CCX (match_dup 1) (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"orcc\\t%1, 0, %0\"\n    [(set_attr \"type\" \"compare\")])\n@@ -5730,37 +5919,20 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5,5,6\")])\n \n-;; Optimize (1LL<<x)-1\n-;; XXX this also needs to be fixed to handle equal subregs\n-;; XXX first before we could re-enable it.\n-;(define_insn \"\"\n-;  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n-;\t(plus:DI (ashift:DI (const_int 1)\n-;\t\t\t    (match_operand:SI 1 \"arith_operand\" \"rI\"))\n-;\t\t (const_int -1)))]\n-;  \"0 && TARGET_V8PLUS\"\n-;{\n-;  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == REGNO (operands[0]))\n-;    return \"mov\\t1, %L0\\;sllx\\t%L0, %1, %L0\\;sub\\t%L0, 1, %L0\\;srlx\\t%L0, 32, %H0\";\n-;  return \"mov\\t1, %H0\\;sllx\\t%H0, %1, %L0\\;sub\\t%L0, 1, %L0\\;srlx\\t%L0, 32, %H0\";\n-;}\n-;  [(set_attr \"type\" \"multi\")\n-;   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"*cmp_cc_ashift_1\"\n-  [(set (reg:CC_NOOV CC_REG)\n-\t(compare:CC_NOOV (ashift:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t\t    (const_int 1))\n-\t\t\t (const_int 0)))]\n+(define_insn \"*cmp_ccnz_ashift_1\"\n+  [(set (reg:CCNZ CC_REG)\n+\t(compare:CCNZ (ashift:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t (const_int 1))\n+\t\t      (const_int 0)))]\n   \"\"\n   \"addcc\\t%0, %0, %%g0\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"*cmp_cc_set_ashift_1\"\n-  [(set (reg:CC_NOOV CC_REG)\n-\t(compare:CC_NOOV (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t    (const_int 1))\n-\t\t\t (const_int 0)))\n+(define_insn \"*cmp_ccnz_set_ashift_1\"\n+  [(set (reg:CCNZ CC_REG)\n+\t(compare:CCNZ (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t (const_int 1))\n+\t\t      (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ashift:SI (match_dup 1) (const_int 1)))]\n   \"\"\n@@ -7092,29 +7264,34 @@\n   [(set_attr \"type\" \"trap\")])\n \n (define_expand \"ctrapsi4\"\n-  [(trap_if (match_operator 0 \"noov_compare_operator\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n \t     [(match_operand:SI 1 \"compare_operand\" \"\")\n \t      (match_operand:SI 2 \"arith_operand\" \"\")])\n \t   (match_operand 3 \"arith_operand\"))]\n   \"\"\n-  \"operands[1] = gen_compare_reg (operands[0]);\n-   if (GET_MODE (operands[1]) != CCmode && GET_MODE (operands[1]) != CCXmode)\n-     FAIL;\n-   operands[2] = const0_rtx;\")\n+{\n+  operands[1] = gen_compare_reg (operands[0]);\n+  if (GET_MODE (operands[1]) != CCmode && GET_MODE (operands[1]) != CCXmode)\n+    FAIL;\n+  operands[2] = const0_rtx;\n+})\n \n (define_expand \"ctrapdi4\"\n-  [(trap_if (match_operator 0 \"noov_compare_operator\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n \t     [(match_operand:DI 1 \"compare_operand\" \"\")\n \t      (match_operand:DI 2 \"arith_operand\" \"\")])\n \t   (match_operand 3 \"arith_operand\"))]\n   \"TARGET_ARCH64\"\n-  \"operands[1] = gen_compare_reg (operands[0]);\n-   if (GET_MODE (operands[1]) != CCmode && GET_MODE (operands[1]) != CCXmode)\n-     FAIL;\n-   operands[2] = const0_rtx;\")\n+{\n+  operands[1] = gen_compare_reg (operands[0]);\n+  if (GET_MODE (operands[1]) != CCmode && GET_MODE (operands[1]) != CCXmode)\n+    FAIL;\n+  operands[2] = const0_rtx;\n+})\n \n-(define_insn \"\"\n-  [(trap_if (match_operator 0 \"noov_compare_operator\" [(reg:CC CC_REG) (const_int 0)])\n+(define_insn \"*trapsi_insn\"\n+  [(trap_if (match_operator 0 \"icc_comparison_operator\"\n+\t      [(reg:CC CC_REG) (const_int 0)])\n \t    (match_operand:SI 1 \"arith_operand\" \"rM\"))]\n   \"\"\n {\n@@ -7125,8 +7302,9 @@\n }\n   [(set_attr \"type\" \"trap\")])\n \n-(define_insn \"\"\n-  [(trap_if (match_operator 0 \"noov_compare_operator\" [(reg:CCX CC_REG) (const_int 0)])\n+(define_insn \"*trapdi_insn\"\n+  [(trap_if (match_operator 0 \"icc_comparison_operator\"\n+\t      [(reg:CCX CC_REG) (const_int 0)])\n \t    (match_operand:SI 1 \"arith_operand\" \"rM\"))]\n   \"TARGET_V9\"\n   \"t%C0\\t%%xcc, %1\"\n@@ -8315,65 +8493,65 @@\n ;; Edge instructions produce condition codes equivalent to a 'subcc'\n ;; with the same operands.\n (define_insn \"edge8<P:mode>_vis\"\n-  [(set (reg:CC_NOOV CC_REG)\n-        (compare:CC_NOOV (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t  \t  (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n-\t\t\t (const_int 0)))\n+  [(set (reg:CCNZ CC_REG)\n+        (compare:CCNZ (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t       (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n+\t\t      (const_int 0)))\n    (set (match_operand:P 0 \"register_operand\" \"=r\")\n         (unspec:P [(match_dup 1) (match_dup 2)] UNSPEC_EDGE8))]\n   \"TARGET_VIS\"\n   \"edge8\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"edge\")])\n \n (define_insn \"edge8l<P:mode>_vis\"\n-  [(set (reg:CC_NOOV CC_REG)\n-        (compare:CC_NOOV (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t  \t  (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n-\t\t\t (const_int 0)))\n+  [(set (reg:CCNZ CC_REG)\n+        (compare:CCNZ (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t       (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n+\t\t      (const_int 0)))\n    (set (match_operand:P 0 \"register_operand\" \"=r\")\n         (unspec:P [(match_dup 1) (match_dup 2)] UNSPEC_EDGE8L))]\n   \"TARGET_VIS\"\n   \"edge8l\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"edge\")])\n \n (define_insn \"edge16<P:mode>_vis\"\n-  [(set (reg:CC_NOOV CC_REG)\n-        (compare:CC_NOOV (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t  \t  (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n-\t\t\t (const_int 0)))\n+  [(set (reg:CCNZ CC_REG)\n+        (compare:CCNZ (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t       (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n+\t\t      (const_int 0)))\n    (set (match_operand:P 0 \"register_operand\" \"=r\")\n         (unspec:P [(match_dup 1) (match_dup 2)] UNSPEC_EDGE16))]\n   \"TARGET_VIS\"\n   \"edge16\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"edge\")])\n \n (define_insn \"edge16l<P:mode>_vis\"\n-  [(set (reg:CC_NOOV CC_REG)\n-        (compare:CC_NOOV (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t  \t  (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n-\t\t\t (const_int 0)))\n+  [(set (reg:CCNZ CC_REG)\n+        (compare:CCNZ (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t       (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n+\t\t      (const_int 0)))\n    (set (match_operand:P 0 \"register_operand\" \"=r\")\n         (unspec:P [(match_dup 1) (match_dup 2)] UNSPEC_EDGE16L))]\n   \"TARGET_VIS\"\n   \"edge16l\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"edge\")])\n \n (define_insn \"edge32<P:mode>_vis\"\n-  [(set (reg:CC_NOOV CC_REG)\n-        (compare:CC_NOOV (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t  \t  (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n-\t\t\t (const_int 0)))\n+  [(set (reg:CCNZ CC_REG)\n+        (compare:CCNZ (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t       (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n+\t\t      (const_int 0)))\n    (set (match_operand:P 0 \"register_operand\" \"=r\")\n         (unspec:P [(match_dup 1) (match_dup 2)] UNSPEC_EDGE32))]\n   \"TARGET_VIS\"\n   \"edge32\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"edge\")])\n \n (define_insn \"edge32l<P:mode>_vis\"\n-  [(set (reg:CC_NOOV CC_REG)\n-        (compare:CC_NOOV (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n-\t\t\t  \t  (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n-\t\t\t (const_int 0)))\n+  [(set (reg:CCNZ CC_REG)\n+        (compare:CCNZ (minus:P (match_operand:P 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t       (match_operand:P 2 \"register_or_zero_operand\" \"rJ\"))\n+\t\t      (const_int 0)))\n    (set (match_operand:P 0 \"register_operand\" \"=r\")\n         (unspec:P [(match_dup 1) (match_dup 2)] UNSPEC_EDGE32L))]\n   \"TARGET_VIS\""}, {"sha": "1be78009c6265c96537765207fda3b0ab2a9ca3b", "filename": "gcc/config/sparc/sparc.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.opt?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -89,6 +89,10 @@ mpopc\n Target Report Mask(POPC)\n Use UltraSPARC Population-Count instruction.\n \n+msubxc\n+Target Report Mask(SUBXC)\n+Use UltraSPARC Subtract-Extended-with-Carry instruction.\n+\n mptr64\n Target Report RejectNegative Mask(PTR64)\n Pointers are 64-bit."}, {"sha": "fa693bae4f7d3677659f7f60a8eba8adf841e90d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -1092,8 +1092,8 @@ See RS/6000 and PowerPC Options.\n -muser-mode  -mno-user-mode @gol\n -mv8plus  -mno-v8plus  -mvis  -mno-vis @gol\n -mvis2  -mno-vis2  -mvis3  -mno-vis3 @gol\n--mcbcond -mno-cbcond @gol\n--mfmaf  -mno-fmaf  -mpopc  -mno-popc @gol\n+-mcbcond -mno-cbcond  -mfmaf  -mno-fmaf  @gol\n+-mpopc  -mno-popc  -msubxc  -mno-subxc@gol\n -mfix-at697f -mfix-ut699}\n \n @emph{SPU Options}\n@@ -22941,27 +22941,36 @@ also sets @option{-mvis3}, @option{-mvis2} and @option{-mvis}.\n @itemx -mno-cbcond\n @opindex mcbcond\n @opindex mno-cbcond\n-With @option{-mcbcond}, GCC generates code that takes advantage of\n-compare-and-branch instructions, as defined in the Sparc Architecture 2011.\n-The default is @option{-mcbcond} when targeting a cpu that supports such\n-instructions, such as niagara-4 and later.\n+With @option{-mcbcond}, GCC generates code that takes advantage of the UltraSPARC\n+Compare-and-Branch-on-Condition instructions.  The default is @option{-mcbcond}\n+when targeting a CPU that supports such instructions, such as Niagara-4 and\n+later.\n+\n+@item -mfmaf\n+@itemx -mno-fmaf\n+@opindex mfmaf\n+@opindex mno-fmaf\n+With @option{-mfmaf}, GCC generates code that takes advantage of the UltraSPARC\n+Fused Multiply-Add Floating-point instructions.  The default is @option{-mfmaf}\n+when targeting a CPU that supports such instructions, such as Niagara-3 and\n+later.\n \n @item -mpopc\n @itemx -mno-popc\n @opindex mpopc\n @opindex mno-popc\n With @option{-mpopc}, GCC generates code that takes advantage of the UltraSPARC\n-population count instruction.  The default is @option{-mpopc}\n-when targeting a cpu that supports such instructions, such as Niagara-2 and\n+Population Count instruction.  The default is @option{-mpopc}\n+when targeting a CPU that supports such an instruction, such as Niagara-2 and\n later.\n \n-@item -mfmaf\n-@itemx -mno-fmaf\n-@opindex mfmaf\n-@opindex mno-fmaf\n-With @option{-mfmaf}, GCC generates code that takes advantage of the UltraSPARC\n-Fused Multiply-Add Floating-point extensions.  The default is @option{-mfmaf}\n-when targeting a cpu that supports such instructions, such as Niagara-3 and\n+@item -msubxc\n+@itemx -mno-subxc\n+@opindex msubxc\n+@opindex mno-subxc\n+With @option{-msubxc}, GCC generates code that takes advantage of the UltraSPARC\n+Subtract-Extended-with-Carry instruction.  The default is @option{-msubxc}\n+when targeting a CPU that supports such an instruction, such as Niagara-7 and\n later.\n \n @item -mfix-at697f"}, {"sha": "d54f96c25dee94aa9330116d7d7f0d9854cfdb2e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -6021,8 +6021,8 @@ the case of the add on the SPARC discussed above, we have the pattern\n \n @smallexample\n (define_insn \"\"\n-  [(set (reg:CC_NOOV 0)\n-        (compare:CC_NOOV\n+  [(set (reg:CCNZ 0)\n+        (compare:CCNZ\n           (plus:SI (match_operand:SI 0 \"register_operand\" \"%r\")\n                    (match_operand:SI 1 \"arith_operand\" \"rI\"))\n           (const_int 0)))]\n@@ -6031,7 +6031,7 @@ the case of the add on the SPARC discussed above, we have the pattern\n @end smallexample\n \n @noindent\n-together with a @code{SELECT_CC_MODE} that returns @code{CC_NOOVmode}\n+together with a @code{SELECT_CC_MODE} that returns @code{CCNZmode}\n for comparisons whose argument is a @code{plus}:\n \n @smallexample\n@@ -6041,7 +6041,7 @@ for comparisons whose argument is a @code{plus}:\n       ? CCFPEmode : CCFPmode)                            \\\n    : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS     \\\n        || GET_CODE (X) == NEG || GET_CODE (x) == ASHIFT) \\\n-      ? CC_NOOVmode : CCmode))\n+      ? CCNZmode : CCmode))\n @end smallexample\n \n Another reason to use modes is to retain information on which operands"}, {"sha": "00699e36070f54f7945d69a0f3281d61a5b196bf", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -4443,8 +4443,8 @@ the case of the add on the SPARC discussed above, we have the pattern\n \n @smallexample\n (define_insn \"\"\n-  [(set (reg:CC_NOOV 0)\n-        (compare:CC_NOOV\n+  [(set (reg:CCNZ 0)\n+        (compare:CCNZ\n           (plus:SI (match_operand:SI 0 \"register_operand\" \"%r\")\n                    (match_operand:SI 1 \"arith_operand\" \"rI\"))\n           (const_int 0)))]\n@@ -4453,7 +4453,7 @@ the case of the add on the SPARC discussed above, we have the pattern\n @end smallexample\n \n @noindent\n-together with a @code{SELECT_CC_MODE} that returns @code{CC_NOOVmode}\n+together with a @code{SELECT_CC_MODE} that returns @code{CCNZmode}\n for comparisons whose argument is a @code{plus}:\n \n @smallexample\n@@ -4463,7 +4463,7 @@ for comparisons whose argument is a @code{plus}:\n       ? CCFPEmode : CCFPmode)                            \\\n    : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS     \\\n        || GET_CODE (X) == NEG || GET_CODE (x) == ASHIFT) \\\n-      ? CC_NOOVmode : CCmode))\n+      ? CCNZmode : CCmode))\n @end smallexample\n \n Another reason to use modes is to retain information on which operands"}, {"sha": "126342d63c886de5c6dfb3ccf96f9a4d07429021", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -1,3 +1,20 @@\n+2016-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/sparc/cbcond-1.c: New test.\n+\t* gcc.target/sparc/cbcond-2.c: Likewise.\n+\t* gcc.target/sparc/movcc-1.c: Likewise.\n+\t* gcc.target/sparc/movcc-2.c: Likewise.\n+\t* gcc.target/sparc/setcc-1.c: Adjust.\n+\t* gcc.target/sparc/setcc-2.c: Likewise.\n+\t* gcc.target/sparc/setcc-3.c: Likewise.\n+\t* gcc.target/sparc/setcc-4.c: Likewise.\n+\t* gcc.target/sparc/setcc-5.c: Likewise.\n+\t* gcc.target/sparc/setcc-6.c: New test.\n+\t* gcc.target/sparc/setcc-7.c: Likewise.\n+\t* gcc.target/sparc/setcc-8.c: Likewise.\n+\t* gcc.target/sparc/setcc-9.c: Likewise.\n+\t* gcc.target/sparc/setcc-10.c: Likewise.\n+\n 2016-10-10  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/71947"}, {"sha": "74fe475a6c541c44bf01efd1953d58b5cbd38b8d", "filename": "gcc/testsuite/gcc.target/sparc/cbcond-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcbcond-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcbcond-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcbcond-1.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcbcond\" } */\n+\n+extern void foo (void);\n+extern void bar (void);\n+\n+void cbcondne (int a)\n+{\n+  if (a != 0)\n+    foo ();\n+  bar ();\n+}\n+\n+void cbconde (int a)\n+{\n+  if (a == 0)\n+    foo ();\n+  bar ();\n+}\n+\n+void cbcondl (int a)\n+{\n+  if (a < 0)\n+    foo ();\n+  bar ();\n+}\n+\n+void cbcondle (int a)\n+{\n+  if (a <= 0)\n+    foo ();\n+  bar ();\n+}\n+\n+/* { dg-final { scan-assembler \"cwbe\\t%\"  { target ilp32 } } } */\n+/* { dg-final { scan-assembler \"cwbne\\t%\" { target ilp32 } } } */\n+/* { dg-final { scan-assembler \"cwbl\\t%\"  } } */\n+/* { dg-final { scan-assembler \"cwble\\t%\" } } */"}, {"sha": "3c03d444e72d6b921ef7f43d3c5c110b429fac74", "filename": "gcc/testsuite/gcc.target/sparc/cbcond-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcbcond-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcbcond-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcbcond-2.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcbcond\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+extern void foo (void);\n+extern void bar (void);\n+\n+void cbcondne (long a)\n+{\n+  if (a != 0)\n+    foo ();\n+  bar ();\n+}\n+\n+void cbconde (long a)\n+{\n+  if (a == 0)\n+    foo ();\n+  bar ();\n+}\n+\n+void cbcondl (long a)\n+{\n+  if (a < 0)\n+    foo ();\n+  bar ();\n+}\n+\n+void cbcondle (long a)\n+{\n+  if (a <= 0)\n+    foo ();\n+  bar ();\n+}\n+\n+/* { dg-final { scan-assembler \"cxbe\\t%\"  } } */\n+/* { dg-final { scan-assembler \"cxbne\\t%\" } } */\n+/* { dg-final { scan-assembler \"cxbl\\t%\"  } } */\n+/* { dg-final { scan-assembler \"cxble\\t%\" } } */"}, {"sha": "57ba0f919f44381406966588fc0c3a321ec69489", "filename": "gcc/testsuite/gcc.target/sparc/movcc-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fmovcc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fmovcc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fmovcc-1.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+int foo1 (int a)\n+{\n+  int b = a + 1;\n+  if (b != 0)\n+    return b;\n+  return 1;\n+}\n+\n+int foo2 (int a)\n+{\n+  int b = a + 1;\n+  if (b < 0)\n+    return b;\n+  return 1;\n+}\n+\n+int foo3 (int a)\n+{\n+  int b = a + 1;\n+  if (b >= 0)\n+    return b;\n+  return 1;\n+}\n+\n+/* { dg-final { scan-assembler \"move\\t%\"  } } */\n+/* { dg-final { scan-assembler \"movpos\\t%\"  } } */\n+/* { dg-final { scan-assembler \"movneg\\t%\" } } */"}, {"sha": "3af78768798a7b0a4c65e22e3237cbfcd01c0c11", "filename": "gcc/testsuite/gcc.target/sparc/movcc-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fmovcc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fmovcc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fmovcc-2.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+long foo1 (long a)\n+{\n+  long b = a + 1;\n+  if (b != 0)\n+    return b;\n+  return 1;\n+}\n+\n+long foo2 (long a)\n+{\n+  long b = a + 1;\n+  if (b < 0)\n+    return b;\n+  return 1;\n+}\n+\n+long foo3 (long a)\n+{\n+  long b = a + 1;\n+  if (b >= 0)\n+    return b;\n+  return 1;\n+}\n+\n+/* { dg-final { scan-assembler \"movre\\t%\"  } } */\n+/* { dg-final { scan-assembler \"movrgez\\t%\"  } } */\n+/* { dg-final { scan-assembler \"movrlz\\t%\" } } */"}, {"sha": "a4ff6ae5066779ec7984b695173b531b2ca5ab27", "filename": "gcc/testsuite/gcc.target/sparc/setcc-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-1.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -32,8 +32,7 @@ int gt (unsigned int a, unsigned int b)\n }\n \n /* { dg-final { scan-assembler-times \"xor\\t%\" 2 } } */\n-/* { dg-final { scan-assembler-times \"subcc\\t%\" 2 } } */\n /* { dg-final { scan-assembler-times \"addx\\t%\" 3 } } */\n /* { dg-final { scan-assembler-times \"subx\\t%\" 3 } } */\n-/* { dg-final { scan-assembler-times \"cmp\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 6 } } */\n /* { dg-final { scan-assembler-not \"sra\\t%\" { target lp64 } } } */"}, {"sha": "6d19a0ab2437a633fa5d3942d9760064627f9c48", "filename": "gcc/testsuite/gcc.target/sparc/setcc-2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-2.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -32,8 +32,7 @@ int gt (unsigned int a, unsigned int b)\n }\n \n /* { dg-final { scan-assembler-times \"xor\\t%\" 2 } } */\n-/* { dg-final { scan-assembler-times \"subcc\\t%\" 2 } } */\n /* { dg-final { scan-assembler-times \"addx\\t%\" 3 } } */\n /* { dg-final { scan-assembler-times \"subx\\t%\" 3 } } */\n-/* { dg-final { scan-assembler-times \"cmp\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 6 } } */\n /* { dg-final { scan-assembler-not \"sra\\t%\" { target lp64 } } } */"}, {"sha": "58542c15c4eff7c881e8394a2fb523336cb9ecfe", "filename": "gcc/testsuite/gcc.target/sparc/setcc-3.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-3.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -18,7 +18,6 @@ int gt (unsigned long a, unsigned long b)\n }\n \n /* { dg-final { scan-assembler \"xor\\t%\" } } */\n-/* { dg-final { scan-assembler \"subcc\\t%\" } } */\n /* { dg-final { scan-assembler-times \"addxc\\t%\" 3 } } */\n-/* { dg-final { scan-assembler-times \"cmp\\t%\" 2 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 3 } } */\n /* { dg-final { scan-assembler-not \"sra\\t%\" } } */"}, {"sha": "a51955763c4f6a0e3a344ae90db255322f7a0ddc", "filename": "gcc/testsuite/gcc.target/sparc/setcc-4.c", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-4.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -1,44 +1,23 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target lp64 } */\n-/* { dg-options \"-O1 -mno-vis3\" } */\n+/* { dg-options \"-O1 -msubxc\" } */\n \n-long neq (long a, long b)\n-{\n-  return a != b;\n-}\n-\n-long eq (long a, long b)\n+int eq (long a, long b)\n {\n   return a == b;\n }\n \n-long lt (unsigned long a, unsigned long b)\n-{\n-  return a < b;\n-}\n-\n-long leq (unsigned long a, unsigned long b)\n-{\n-  return a <= b;\n-}\n-\n-long geq (unsigned long a, unsigned long b)\n+int ge (unsigned long a, unsigned long b)\n {\n   return a >= b;\n }\n \n-long gt (unsigned long a, unsigned long b)\n+int le (unsigned long a, unsigned long b)\n {\n-  return a > b;\n+  return a <= b;\n }\n \n-/* { dg-final { scan-assembler-times \"xor\\t%\" 2 } } */\n-/* { dg-final { scan-assembler-times \"cmp\\t%\" 4 } } */\n-/* { dg-final { scan-assembler-times \"movrne\\t%\" 1 } } */\n-/* { dg-final { scan-assembler-times \"movre\\t%\" 1 } } */\n-/* { dg-final { scan-assembler-times \"movlu\\t%\" 1 } } */\n-/* { dg-final { scan-assembler-times \"movleu\\t%\" 1 } } */\n-/* { dg-final { scan-assembler-times \"movgeu\\t%\" 1 } } */\n-/* { dg-final { scan-assembler-times \"movgu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler \"xor\\t%\" } } */\n+/* { dg-final { scan-assembler-times \"subxc\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 3 } } */\n /* { dg-final { scan-assembler-not \"sra\\t%\" } } */\n-/* { dg-final { scan-assembler-not \"and\\t%\" } } */"}, {"sha": "1c32d41781af8d0d622bb49cd7941a907936b7d9", "filename": "gcc/testsuite/gcc.target/sparc/setcc-5.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-5.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target lp64 } */\n-/* { dg-options \"-O1 -mvis3\" } */\n+/* { dg-options \"-O1 -mno-vis3 -mno-subxc\" } */\n \n long neq (long a, long b)\n {\n@@ -34,9 +34,11 @@ long gt (unsigned long a, unsigned long b)\n \n /* { dg-final { scan-assembler-times \"xor\\t%\" 2 } } */\n /* { dg-final { scan-assembler-times \"cmp\\t%\" 4 } } */\n-/* { dg-final { scan-assembler-times \"addxc\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"movrne\\t%\" 1 } } */\n /* { dg-final { scan-assembler-times \"movre\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movlu\\t%\" 1 } } */\n /* { dg-final { scan-assembler-times \"movleu\\t%\" 1 } } */\n /* { dg-final { scan-assembler-times \"movgeu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movgu\\t%\" 1 } } */\n /* { dg-final { scan-assembler-not \"sra\\t%\" } } */\n /* { dg-final { scan-assembler-not \"and\\t%\" } } */"}, {"sha": "7cd58947d549d3fce6717662b283054df513ed92", "filename": "gcc/testsuite/gcc.target/sparc/setcc-6.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-6.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O1 -mvis3 -msubxc\" } */\n+\n+long neq (long a, long b)\n+{\n+  return a != b;\n+}\n+\n+long eq (long a, long b)\n+{\n+  return a == b;\n+}\n+\n+long lt (unsigned long a, unsigned long b)\n+{\n+  return a < b;\n+}\n+\n+long leq (unsigned long a, unsigned long b)\n+{\n+  return a <= b;\n+}\n+\n+long geq (unsigned long a, unsigned long b)\n+{\n+  return a >= b;\n+}\n+\n+long gt (unsigned long a, unsigned long b)\n+{\n+  return a > b;\n+}\n+\n+/* { dg-final { scan-assembler-times \"xor\\t%\" 2 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 6 } } */\n+/* { dg-final { scan-assembler-times \"addxc\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"subxc\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-not \"sra\\t%\" } } */\n+/* { dg-final { scan-assembler-not \"and\\t%\" } } */"}, {"sha": "fa6587639f33babfe31d4d9f331437833e6008df", "filename": "gcc/testsuite/gcc.target/sparc/setcc-7.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-7.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+int foo1 (int a, int i)\n+{\n+  return a + (i != 0);\n+}\n+\n+int foo2 (int a, int i)\n+{\n+  return a - (i != 0);\n+}\n+\n+int foo3 (int a, int b, int i)\n+{\n+  return a + b + (i != 0);\n+}\n+\n+int foo4 (int a, int b, int i)\n+{\n+  return a - b - (i != 0);\n+}\n+\n+int foo5 (int a, int i)\n+{\n+  return a + (i == 0);\n+}\n+\n+int foo6 (int a, int i)\n+{\n+  return a - (i == 0);\n+}\n+\n+/* { dg-final { scan-assembler-times \"addx\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"subx\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 6 } } */\n+/* { dg-final { scan-assembler-not \"add\\t%\" } } */\n+/* { dg-final { scan-assembler-not \"sub\\t%\" } } */"}, {"sha": "3eb9c3dfd796587f1e7331b04f0ad369c92a4c63", "filename": "gcc/testsuite/gcc.target/sparc/setcc-8.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-8.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O1 -mno-vis3 -mno-subxc\" } */\n+\n+long foo1 (long a, int i)\n+{\n+  return a + (i != 0);\n+}\n+\n+long foo2 (long a, int i)\n+{\n+  return a - (i != 0);\n+}\n+\n+long foo3 (long a, long b, int i)\n+{\n+  return a + b + (i != 0);\n+}\n+\n+long foo4 (long a, long b, int i)\n+{\n+  return a - b - (i != 0);\n+}\n+\n+long foo5 (long a, int i)\n+{\n+  return a + (i == 0);\n+}\n+\n+long foo6 (long a, int i)\n+{\n+  return a - (i == 0);\n+}\n+\n+/* { dg-final { scan-assembler-times \"addx\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"subx\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 6 } } */\n+/* { dg-final { scan-assembler-not \"add\\t%\" } } */\n+/* { dg-final { scan-assembler-not \"sub\\t%\" } } */"}, {"sha": "9da7c23caf6500ee1df33aed678ed2cf3029edec", "filename": "gcc/testsuite/gcc.target/sparc/setcc-9.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7e7ee099988c5dea7973553983bb23db7c2924/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-9.c?ref=ff7e7ee099988c5dea7973553983bb23db7c2924", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O1 -mvis3\" } */\n+\n+long foo1 (long a, long i)\n+{\n+  return a + (i != 0);\n+}\n+\n+long foo3 (long a, long b, long i)\n+{\n+  return a + b + (i != 0);\n+}\n+\n+long foo6 (long a, long i)\n+{\n+  return a - (i == 0);\n+}\n+\n+/* { dg-final { scan-assembler-times \"addxc\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-not \"add\\t%\" } } */\n+/* { dg-final { scan-assembler-not \"sub\\t%\" } } */"}]}