{"sha": "8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ1MWYyNmY4ZWMyZTc4YTYzNjljMWNkOGJmNzJlMzlkNjEyNjFlMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-01-28T13:53:19Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-01-28T13:53:19Z"}, "message": "re PR fortran/45170 ([F2003] allocatable character lengths)\n\n2011-01-28  Paul Thomas  <pault@gcc.gnu.org>\n\t    Tobias Burnus  <burnus@gcc.gnu.org>\n\n\tPR fortran/45170\n\tPR fortran/35810\n\tPR fortran/47350\n\t* interface.c (compare_actual_formal): An allocatable or pointer\n\tdeferred length actual is only allowed if the formal argument\n\tis also deferred length. Clean up whitespace.\n\t* trans-expr.c (gfc_conv_procedure_call): Pass string length for\n\tdeferred character length formal arguments by reference. Do the\n\tsame for function results.\n\t(gfc_trans_pointer_assignment): Do not do runtime check of lhs\n\tand rhs character lengths, if deferred length lhs.  In this case\n\tset the lhs character length to that of the rhs.\n\t(gfc_conv_string_parameter): Remove assert that string length is\n\tan integer type.\n\t(is_scalar_reallocatable_lhs): New function.\n\t(alloc_scalar_allocatable_for_assignment): New function.\n\t(gfc_trans_assignment_1): Call above new function. If the rhs is\n\ta deferred character length itself, makes ure that the function\n\tis called before reallocation, so that the length is available.\n\t(gfc_trans_asssignment): Remove error about assignment to\n\tdeferred length character variables.\n\t* gfortran.texi : Update entry about (re)allocation on\n\tassignment.\n\t* trans-stmt.c (gfc_trans_allocate): Add code to handle deferred\n\tlength character variables.\n\t* module.c (mio_typespec): Transfer deferred characteristic.\n\t* trans-types.c (gfc_get_function_type): New code to generate\n\thidden typelist, so that those character lengths that are\n\tpassed by reference get the right type.\n\t* resolve.c (resolve_contained_fntype): Supress error for\n\tdeferred character length functions.\n\t(resolve_function, resolve_fl_procedure) The same.\n\t(check_symbols): Remove the error that support for\n\tentity with deferred type parameter is not yet implemented.\n\t(resolve_fl_derived): The same.\n\tmatch.c (alloc_opt_list): Allow MOLD for deferred length object.\n\t* trans-decl.c (gfc_get_symbol_decl): For deferred character\n\tlength dummies, generate a local variable for string length.\n\t(create_function_arglist): Hidden length can be a pointer.\n\t(gfc_trans_deferred_vars): For deferred character length\n\tresults and dummies, assign the string length to the local\n\tvariable from the hidden argument on entry and the other way\n\tround on exit, as appropriate.\n\n2011-01-28  Paul Thomas  <pault@gcc.gnu.org>\n\t    Tobias Burnus  <burnus@gcc.gnu.org>\n\n\tPR fortran/45170\n\tPR fortran/35810\n\tPR fortran/47350\n\t* gfortran.dg/realloc_on_assign_3.f03: New test.\n\t* gfortran.dg/realloc_on_assign_4.f03: New test.\n\t* gfortran.dg/realloc_on_assign_5.f90: New test.\n\t* gfortran.dg/allocatable_function_5.f90: New test.\n\t* gfortran.dg/allocate_deferred_char_scalar_1.f90: New test.\n\t* gfortran.dg/deferred_type_param_2.f90: Remove two \"not yet\n\timplemented\" dg-errors.\n\n\nCo-Authored-By: Tobias Burnus <burnus@gcc.gnu.org>\n\nFrom-SVN: r169356", "tree": {"sha": "8feacbc10294f914c2ff1de86d10b842892c1692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8feacbc10294f914c2ff1de86d10b842892c1692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/comments", "author": null, "committer": null, "parents": [{"sha": "c9f58b9addbff701efacd96907ea7bf59e3f9361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f58b9addbff701efacd96907ea7bf59e3f9361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f58b9addbff701efacd96907ea7bf59e3f9361"}], "stats": {"total": 995, "additions": 932, "deletions": 63}, "files": [{"sha": "ae0b36cc9eaffe3e4d6d6e259ec41b97a6498318", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -1,3 +1,50 @@\n+2011-01-28  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Tobias Burnus  <burnus@gcc.gnu.org>\n+\n+\tPR fortran/45170\n+\tPR fortran/35810\n+\tPR fortran/47350\n+\t* interface.c (compare_actual_formal): An allocatable or pointer\n+\tdeferred length actual is only allowed if the formal argument\n+\tis also deferred length. Clean up whitespace.\n+\t* trans-expr.c (gfc_conv_procedure_call): Pass string length for\n+\tdeferred character length formal arguments by reference. Do the\n+\tsame for function results.\n+\t(gfc_trans_pointer_assignment): Do not do runtime check of lhs\n+\tand rhs character lengths, if deferred length lhs.  In this case\n+\tset the lhs character length to that of the rhs.\n+\t(gfc_conv_string_parameter): Remove assert that string length is\n+\tan integer type.\n+\t(is_scalar_reallocatable_lhs): New function.\n+\t(alloc_scalar_allocatable_for_assignment): New function.\n+\t(gfc_trans_assignment_1): Call above new function. If the rhs is\n+\ta deferred character length itself, makes ure that the function\n+\tis called before reallocation, so that the length is available.\n+\t(gfc_trans_asssignment): Remove error about assignment to\n+\tdeferred length character variables.\n+\t* gfortran.texi : Update entry about (re)allocation on\n+\tassignment.\n+\t* trans-stmt.c (gfc_trans_allocate): Add code to handle deferred\n+\tlength character variables.\n+\t* module.c (mio_typespec): Transfer deferred characteristic.\n+\t* trans-types.c (gfc_get_function_type): New code to generate\n+\thidden typelist, so that those character lengths that are\n+\tpassed by reference get the right type.\n+\t* resolve.c (resolve_contained_fntype): Supress error for\n+\tdeferred character length functions.\n+\t(resolve_function, resolve_fl_procedure) The same.\n+\t(check_symbols): Remove the error that support for\n+\tentity with deferred type parameter is not yet implemented.\n+\t(resolve_fl_derived): The same.\n+\tmatch.c (alloc_opt_list): Allow MOLD for deferred length object.\n+\t* trans-decl.c (gfc_get_symbol_decl): For deferred character\n+\tlength dummies, generate a local variable for string length.\n+\t(create_function_arglist): Hidden length can be a pointer.\n+\t(gfc_trans_deferred_vars): For deferred character length\n+\tresults and dummies, assign the string length to the local\n+\tvariable from the hidden argument on entry and the other way\n+\tround on exit, as appropriate.\n+\n 2011-01-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/47474"}, {"sha": "4f5875d8c2a379b0e74f5bc64d08fa3d62cec10a", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -830,10 +830,11 @@ type-specification with type parameter and for allocation and initialization\n from a @code{SOURCE=} expression; @code{ALLOCATE} and @code{DEALLOCATE}\n optionally return an error message string via @code{ERRMSG=}.\n \n-@item Reallocation on assignment for arrays: If an intrinsic assignment is\n+@item Reallocation on assignment: If an intrinsic assignment is\n used, an allocatable variable on the left-hand side is automatically allocated\n-(if unallocated) or reallocated (if the shape is different). Currently, the\n-reallocation for scalars is not implemented.\n+(if unallocated) or reallocated (if the shape is different). Currently, scalar\n+deferred character length left-hand sides are correctly handled but arrays\n+are not yet fully implemented.\n \n @item Transferring of allocations via @code{MOVE_ALLOC}.\n "}, {"sha": "1cbba2483544fd3a453861ef0f94b5302c421e25", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -2093,6 +2093,18 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t   return 0;\n \t }\n \n+      if ((f->sym->attr.pointer || f->sym->attr.allocatable)\n+\t    && f->sym->ts.deferred != a->expr->ts.deferred\n+\t    && a->expr->ts.type == BT_CHARACTER)\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument argument at %L to allocatable or \"\n+\t\t       \"pointer dummy argument '%s' must have a deferred \"\n+\t\t       \"length type parameter if and only if the dummy has one\",\n+\t\t       &a->expr->where, f->sym->name);\n+\t  return 0;\n+\t}\n+\n       actual_size = get_expr_storage_size (a->expr);\n       formal_size = get_sym_storage_size (f->sym);\n       if (actual_size != 0\n@@ -2101,14 +2113,14 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t{\n \t  if (a->expr->ts.type == BT_CHARACTER && !f->sym->as && where)\n \t    gfc_warning (\"Character length of actual argument shorter \"\n-\t\t\t\"than of dummy argument '%s' (%lu/%lu) at %L\",\n-\t\t\tf->sym->name, actual_size, formal_size,\n-\t\t\t&a->expr->where);\n+\t\t\t \"than of dummy argument '%s' (%lu/%lu) at %L\",\n+\t\t\t f->sym->name, actual_size, formal_size,\n+\t\t\t &a->expr->where);\n           else if (where)\n \t    gfc_warning (\"Actual argument contains too few \"\n-\t\t\t\"elements for dummy argument '%s' (%lu/%lu) at %L\",\n-\t\t\tf->sym->name, actual_size, formal_size,\n-\t\t\t&a->expr->where);\n+\t\t\t \"elements for dummy argument '%s' (%lu/%lu) at %L\",\n+\t\t\t f->sym->name, actual_size, formal_size,\n+\t\t\t &a->expr->where);\n \t  return  0;\n \t}\n "}, {"sha": "01b88ffd46e563e0fa98d1201eed4b0de51f1f4d", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -3134,10 +3134,11 @@ gfc_match_allocate (void)\n     }\n \n   /* Check F03:C623,  */\n-  if (saw_deferred && ts.type == BT_UNKNOWN && !source)\n+  if (saw_deferred && ts.type == BT_UNKNOWN && !source && !mold)\n     {\n       gfc_error (\"Allocate-object at %L with a deferred type parameter \"\n-\t\t \"requires either a type-spec or SOURCE tag\", &deferred_locus);\n+\t\t \"requires either a type-spec or SOURCE tag or a MOLD tag\",\n+\t\t &deferred_locus);\n       goto cleanup;\n     }\n   "}, {"sha": "6c3455b22c8ab3a518e7f3af78603b9c334c660a", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -2138,6 +2138,20 @@ mio_typespec (gfc_typespec *ts)\n   else\n     mio_charlen (&ts->u.cl);\n \n+  /* So as not to disturb the existing API, use an ATOM_NAME to\n+     transmit deferred characteristic for characters (F2003).  */\n+  if (iomode == IO_OUTPUT)\n+    {\n+      if (ts->type == BT_CHARACTER && ts->deferred)\n+\twrite_atom (ATOM_NAME, \"DEFERRED_CL\");\n+    }\n+  else if (peek_atom () != ATOM_RPAREN)\n+    {\n+      if (parse_atom () != ATOM_NAME)\n+\tbad_module (\"Expected string\");\n+      ts->deferred = 1;\n+    }\n+\n   mio_rparen ();\n }\n "}, {"sha": "243628397aa1a8260520725a2e16896f8264d5cc", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -500,7 +500,7 @@ resolve_contained_fntype (gfc_symbol *sym, gfc_namespace *ns)\n   if (sym->result->ts.type == BT_CHARACTER)\n     {\n       gfc_charlen *cl = sym->result->ts.u.cl;\n-      if (!cl || !cl->length)\n+      if ((!cl || !cl->length) && !sym->result->ts.deferred)\n \t{\n \t  /* See if this is a module-procedure and adapt error message\n \t     accordingly.  */\n@@ -2990,6 +2990,7 @@ resolve_function (gfc_expr *expr)\n       && sym->ts.u.cl\n       && sym->ts.u.cl->length == NULL\n       && !sym->attr.dummy\n+      && !sym->ts.deferred\n       && expr->value.function.esym == NULL\n       && !sym->attr.contained)\n     {\n@@ -6916,12 +6917,6 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n     }\n \n success:\n-  if (e->ts.deferred)\n-    {\n-      gfc_error (\"Support for entity at %L with deferred type parameter \"\n-\t\t \"not yet implemented\", &e->where);\n-      return FAILURE;\n-    }\n   return SUCCESS;\n \n failure:\n@@ -10267,8 +10262,11 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t}\n \n       /* Appendix B.2 of the standard.  Contained functions give an\n-\t error anyway.  Fixed-form is likely to be F77/legacy.  */\n-      if (!sym->attr.contained && gfc_current_form != FORM_FIXED)\n+\t error anyway.  Fixed-form is likely to be F77/legacy. Deferred\n+\t character length is an F2003 feature.  */\n+      if (!sym->attr.contained\n+\t    && gfc_current_form != FORM_FIXED\n+\t    && !sym->ts.deferred)\n \tgfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: \"\n \t\t\t\"CHARACTER(*) function '%s' at %L\",\n \t\t\tsym->name, &sym->declared_at);\n@@ -11605,7 +11603,8 @@ resolve_fl_derived (gfc_symbol *sym)\n \t  return FAILURE;\n \t}\n \n-      if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer)\n+      if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer\n+\t    && !c->ts.deferred)\n \t{\n \t if (c->ts.u.cl->length == NULL\n \t     || (resolve_charlen (c->ts.u.cl) == FAILURE)\n@@ -11619,6 +11618,15 @@ resolve_fl_derived (gfc_symbol *sym)\n \t   }\n \t}\n \n+      if (c->ts.type == BT_CHARACTER && c->ts.deferred\n+\t  && !c->attr.pointer && !c->attr.allocatable)\n+\t{\n+\t  gfc_error (\"Character component '%s' of '%s' at %L with deferred \"\n+\t\t     \"length must be a POINTER or ALLOCATABLE\",\n+\t\t     c->name, sym->name, &c->loc);\n+\t  return FAILURE;\n+\t}\n+\n       if (c->ts.type == BT_DERIVED\n \t  && sym->component_access != ACCESS_PRIVATE\n \t  && gfc_check_access (sym->attr.access, sym->ns->default_access)"}, {"sha": "fb2f9a85d544229f3e7d94b78993fcf505aa3480", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 129, "deletions": 15, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -1,5 +1,6 @@\n /* Backend function setup\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -1067,6 +1068,21 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \tgfc_find_derived_vtab (c->ts.u.derived);\n     }\n \n+  /* All deferred character length procedures need to retain the backend\n+     decl, which is a pointer to the character length in the caller's\n+     namespace and to declare a local character length.  */\n+  if (!byref && sym->attr.function\n+\t&& sym->ts.type == BT_CHARACTER\n+\t&& sym->ts.deferred\n+\t&& sym->ts.u.cl->passed_length == NULL\n+\t&& sym->ts.u.cl->backend_decl\n+\t&& TREE_CODE (sym->ts.u.cl->backend_decl) == PARM_DECL)\n+    {\n+      sym->ts.u.cl->passed_length = sym->ts.u.cl->backend_decl;\n+      sym->ts.u.cl->backend_decl = NULL_TREE;\n+      length = gfc_create_string_length (sym);\n+    }\n+\n   if ((sym->attr.dummy && ! sym->attr.function) || (sym->attr.result && byref))\n     {\n       /* Return via extra parameter.  */\n@@ -1087,6 +1103,20 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       /* Create a character length variable.  */\n       if (sym->ts.type == BT_CHARACTER)\n \t{\n+\t  /* For a deferred dummy, make a new string length variable.  */\n+\t  if (sym->ts.deferred\n+\t\t&&\n+\t     (sym->ts.u.cl->passed_length == sym->ts.u.cl->backend_decl))\n+\t    sym->ts.u.cl->backend_decl = NULL_TREE;\n+\n+\t  if (sym->ts.deferred && sym->attr.result\n+\t\t&& sym->ts.u.cl->passed_length == NULL\n+\t\t&& sym->ts.u.cl->backend_decl)\n+\t    {\n+\t      sym->ts.u.cl->passed_length = sym->ts.u.cl->backend_decl;\n+\t      sym->ts.u.cl->backend_decl = NULL_TREE;\n+\t    }\n+\n \t  if (sym->ts.u.cl->backend_decl == NULL_TREE)\n \t    length = gfc_create_string_length (sym);\n \t  else\n@@ -1793,7 +1823,6 @@ create_function_arglist (gfc_symbol * sym)\n \t{\n \t  /* Length of character result.  */\n \t  tree len_type = TREE_VALUE (TREE_CHAIN (typelist));\n-\t  gcc_assert (len_type == gfc_charlen_type_node);\n \n \t  length = build_decl (input_location,\n \t\t\t       PARM_DECL,\n@@ -1879,7 +1908,10 @@ create_function_arglist (gfc_symbol * sym)\n \t{\n \t  tree len_type = TREE_VALUE (hidden_typelist);\n \t  tree length = NULL_TREE;\n-\t  gcc_assert (len_type == gfc_charlen_type_node);\n+\t  if (!f->sym->ts.deferred)\n+\t    gcc_assert (len_type == gfc_charlen_type_node);\n+\t  else\n+\t    gcc_assert (POINTER_TYPE_P (len_type));\n \n \t  strcpy (&name[1], f->sym->name);\n \t  name[0] = '_';\n@@ -3182,6 +3214,10 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n   gfc_formal_arglist *f;\n   stmtblock_t tmpblock;\n   bool seen_trans_deferred_array = false;\n+  tree tmp = NULL;\n+  gfc_expr *e;\n+  gfc_se se;\n+  stmtblock_t init;\n \n   /* Deal with implicit return variables.  Explicit return variables will\n      already have been added.  */\n@@ -3213,7 +3249,34 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t}\n       else if (proc_sym->ts.type == BT_CHARACTER)\n \t{\n-\t  if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n+\t  if (proc_sym->ts.deferred)\n+\t    {\n+\t      tmp = NULL;\n+\t      gfc_start_block (&init);\n+\t      /* Zero the string length on entry.  */\n+\t      gfc_add_modify (&init, proc_sym->ts.u.cl->backend_decl,\n+\t\t\t      build_int_cst (gfc_charlen_type_node, 0));\n+\t      /* Null the pointer.  */\n+\t      e = gfc_lval_expr_from_sym (proc_sym);\n+\t      gfc_init_se (&se, NULL);\n+\t      se.want_pointer = 1;\n+\t      gfc_conv_expr (&se, e);\n+\t      gfc_free_expr (e);\n+\t      tmp = se.expr;\n+\t      gfc_add_modify (&init, tmp,\n+\t\t\t      fold_convert (TREE_TYPE (se.expr),\n+\t\t\t\t\t    null_pointer_node));\n+\n+\t      /* Pass back the string length on exit.  */\n+\t      tmp = proc_sym->ts.u.cl->passed_length;\n+\t      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\t      tmp = fold_convert (gfc_charlen_type_node, tmp);\n+\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t     gfc_charlen_type_node, tmp,\n+\t\t\t\t     proc_sym->ts.u.cl->backend_decl);\n+\t      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n+\t    }\n+\t  else if (TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n \t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, block);\n \t}\n       else\n@@ -3304,7 +3367,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t  if (sym_has_alloc_comp && !seen_trans_deferred_array)\n \t    gfc_trans_deferred_array (sym, block);\n \t}\n-      else if (!sym->attr.dummy\n+      else if ((!sym->attr.dummy || sym->ts.deferred)\n \t\t&& (sym->attr.allocatable\n \t\t    || (sym->ts.type == BT_CLASS\n \t\t\t&& CLASS_DATA (sym)->attr.allocatable)))\n@@ -3313,11 +3376,6 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t    {\n \t      /* Nullify and automatic deallocation of allocatable\n \t\t scalars.  */\n-\t      tree tmp = NULL;\n-\t      gfc_expr *e;\n-\t      gfc_se se;\n-\t      stmtblock_t init;\n-\n \t      e = gfc_lval_expr_from_sym (sym);\n \t      if (sym->ts.type == BT_CLASS)\n \t\tgfc_add_data_component (e);\n@@ -3327,15 +3385,44 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t      gfc_conv_expr (&se, e);\n \t      gfc_free_expr (e);\n \n-\t      /* Nullify when entering the scope.  */\n \t      gfc_start_block (&init);\n-\t      gfc_add_modify (&init, se.expr,\n-\t\t\t      fold_convert (TREE_TYPE (se.expr),\n-\t\t\t\t\t    null_pointer_node));\n+\n+\t      if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)\n+\t\t{\n+\t\t  /* Nullify when entering the scope.  */\n+\t\t  gfc_add_modify (&init, se.expr,\n+\t\t\t\t  fold_convert (TREE_TYPE (se.expr),\n+\t\t\t\t\t        null_pointer_node));\n+\t\t}\n+\n+\t      if ((sym->attr.dummy ||sym->attr.result)\n+\t\t    && sym->ts.type == BT_CHARACTER\n+\t\t    && sym->ts.deferred)\n+\t\t{\n+\t\t  /* Character length passed by reference.  */\n+\t\t  tmp = sym->ts.u.cl->passed_length;\n+\t\t  tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\t\t  tmp = fold_convert (gfc_charlen_type_node, tmp);\n+\n+\t\t  if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)\n+\t\t    /* Zero the string length when entering the scope.  */\n+\t\t    gfc_add_modify (&init, sym->ts.u.cl->backend_decl,\n+\t\t\t\tbuild_int_cst (gfc_charlen_type_node, 0));\n+\t\t  else\n+\t\t    gfc_add_modify (&init, sym->ts.u.cl->backend_decl, tmp);\n+\n+\t\t  /* Pass the final character length back.  */\n+\t\t  if (sym->attr.intent != INTENT_IN)\n+\t\t    tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t\t   gfc_charlen_type_node, tmp,\n+\t\t\t\t\t   sym->ts.u.cl->backend_decl);\n+\t\t  else\n+\t\t    tmp = NULL_TREE;\n+\t\t}\n \n \t      /* Deallocate when leaving the scope. Nullifying is not\n \t\t needed.  */\n-\t      if (!sym->attr.result)\n+\t      if (!sym->attr.result && !sym->attr.dummy)\n \t\ttmp = gfc_deallocate_scalar_with_status (se.expr, NULL, true,\n \t\t\t\t\t\t\t NULL, sym->ts);\n \n@@ -3358,6 +3445,33 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n \t    }\n \t}\n+      else if (sym->ts.type == BT_CHARACTER && sym->ts.deferred)\n+\t{\n+\t  tree tmp = NULL;\n+\t  stmtblock_t init;\n+\n+\t  /* If we get to here, all that should be left are pointers.  */\n+\t  gcc_assert (sym->attr.pointer);\n+\n+\t  if (sym->attr.dummy)\n+\t    {\n+\t      gfc_start_block (&init);\n+\n+\t      /* Character length passed by reference.  */\n+\t      tmp = sym->ts.u.cl->passed_length;\n+\t      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\t      tmp = fold_convert (gfc_charlen_type_node, tmp);\n+\t      gfc_add_modify (&init, sym->ts.u.cl->backend_decl, tmp);\n+\t      /* Pass the final character length back.  */\n+\t      if (sym->attr.intent != INTENT_IN)\n+\t\ttmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t       gfc_charlen_type_node, tmp,\n+\t\t\t\t       sym->ts.u.cl->backend_decl);\n+\t      else\n+\t\ttmp = NULL_TREE;\n+\t      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n+\t    }\n+\t}\n       else if (sym->ts.deferred)\n \tgfc_fatal_error (\"Deferred type parameter not yet supported\");\n       else if (sym_has_alloc_comp)"}, {"sha": "9bbe791d88bfdc1926602e6701662d53fa2b90fd", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 186, "deletions": 13, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -3322,6 +3322,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n         }\n       end_pointer_check:\n \n+      /* Deferred length dummies pass the character length by reference\n+\t so that the value can be returned.  */\n+      if (parmse.string_length && fsym && fsym->ts.deferred)\n+\t{\n+\t  tmp = parmse.string_length;\n+\t  if (TREE_CODE (tmp) != VAR_DECL)\n+\t    tmp = gfc_evaluate_now (parmse.string_length, &se->pre);\n+\t  parmse.string_length = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t}\n \n       /* Character strings are passed as two parameters, a length and a\n          pointer - except for Bind(c) which only passes the pointer.  */\n@@ -3349,7 +3358,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t     we take the character length of the first argument for the result.\n \t     For dummies, we have to look through the formal argument list for\n \t     this function and use the character length found there.*/\n-\t  if (!sym->attr.dummy)\n+\t  if (ts.deferred && (sym->attr.allocatable || sym->attr.pointer))\n+\t    cl.backend_decl = gfc_create_var (gfc_charlen_type_node, \"slen\");\n+\t  else if (!sym->attr.dummy)\n \t    cl.backend_decl = VEC_index (tree, stringargs, 0);\n \t  else\n \t    {\n@@ -3534,6 +3545,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  VEC_safe_push (tree, gc, retargs, var);\n \t}\n \n+      if (ts.type == BT_CHARACTER && ts.deferred\n+\t    && (sym->attr.allocatable || sym->attr.pointer))\n+\t{\n+\t  tmp = len;\n+\t  if (TREE_CODE (tmp) != VAR_DECL)\n+\t    tmp = gfc_evaluate_now (len, &se->pre);\n+\t  len = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t}\n+\n       /* Add the string length to the argument list.  */\n       if (ts.type == BT_CHARACTER)\n \tVEC_safe_push (tree, gc, retargs, len);\n@@ -3642,7 +3662,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      else\n \t        se->expr = var;\n \n-\t      se->string_length = len;\n+\t      if (!ts.deferred)\n+\t\tse->string_length = len;\n+\t      else if (sym->attr.allocatable || sym->attr.pointer)\n+\t\tse->string_length = cl.backend_decl;\n \t    }\n \t  else\n \t    {\n@@ -4919,8 +4942,11 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_add_block_to_block (&block, &rse.pre);\n \n       /* Check character lengths if character expression.  The test is only\n-\t really added if -fbounds-check is enabled.  */\n+\t really added if -fbounds-check is enabled.  Exclude deferred\n+\t character length lefthand sides.  */\n       if (expr1->ts.type == BT_CHARACTER && expr2->expr_type != EXPR_NULL\n+\t  && !(expr1->ts.deferred\n+\t\t\t&& (TREE_CODE (lse.string_length) == VAR_DECL))\n \t  && !expr1->symtree->n.sym->attr.proc_pointer\n \t  && !gfc_is_proc_ptr_comp (expr1, NULL))\n \t{\n@@ -4931,6 +4957,17 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\t\t\t       &block);\n \t}\n \n+      /* The assignment to an deferred character length sets the string\n+\t length to that of the rhs.  */\n+      if (expr1->ts.deferred && (TREE_CODE (lse.string_length) == VAR_DECL))\n+\t{\n+\t  if (expr2->expr_type != EXPR_NULL)\n+\t    gfc_add_modify (&block, lse.string_length, rse.string_length);\n+\t  else\n+\t    gfc_add_modify (&block, lse.string_length,\n+\t\t\t    build_int_cst (gfc_charlen_type_node, 0));\n+\t}\n+\n       gfc_add_modify (&block, lse.expr,\n \t\t\t   fold_convert (TREE_TYPE (lse.expr), rse.expr));\n \n@@ -5206,8 +5243,6 @@ gfc_conv_string_parameter (gfc_se * se)\n     }\n \n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (se->expr)));\n-  gcc_assert (se->string_length\n-\t  && TREE_CODE (TREE_TYPE (se->string_length)) == INTEGER_TYPE);\n }\n \n \n@@ -5792,6 +5827,136 @@ expr_is_variable (gfc_expr *expr)\n }\n \n \n+/* Is the lhs OK for automatic reallocation?  */\n+\n+static bool\n+is_scalar_reallocatable_lhs (gfc_expr *expr)\n+{\n+  gfc_ref * ref;\n+\n+  /* An allocatable variable with no reference.  */\n+  if (expr->symtree->n.sym->attr.allocatable\n+\t&& !expr->ref)\n+    return true;\n+\n+  /* All that can be left are allocatable components.  */\n+  if ((expr->symtree->n.sym->ts.type != BT_DERIVED\n+\t&& expr->symtree->n.sym->ts.type != BT_CLASS)\n+\t|| !expr->symtree->n.sym->ts.u.derived->attr.alloc_comp)\n+    return false;\n+\n+  /* Find an allocatable component ref last.  */\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    if (ref->type == REF_COMPONENT\n+\t  && !ref->next\n+\t  && ref->u.c.component->attr.allocatable)\n+      return true;\n+\n+  return false;\n+}\n+\n+\n+/* Allocate or reallocate scalar lhs, as necessary.  */\n+\n+static void\n+alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n+\t\t\t\t\t tree string_length,\n+\t\t\t\t\t gfc_expr *expr1,\n+\t\t\t\t\t gfc_expr *expr2)\n+\n+{\n+  tree cond;\n+  tree tmp;\n+  tree size;\n+  tree size_in_bytes;\n+  tree jump_label1;\n+  tree jump_label2;\n+  gfc_se lse;\n+\n+  if (!expr1 || expr1->rank)\n+    return;\n+\n+  if (!expr2 || expr2->rank)\n+    return;\n+\n+  /* Since this is a scalar lhs, we can afford to do this.  That is,\n+     there is no risk of side effects being repeated.  */\n+  gfc_init_se (&lse, NULL);\n+  lse.want_pointer = 1;\n+  gfc_conv_expr (&lse, expr1);\n+  \n+  jump_label1 = gfc_build_label_decl (NULL_TREE);\n+  jump_label2 = gfc_build_label_decl (NULL_TREE);\n+\n+  /* Do the allocation if the lhs is NULL. Otherwise go to label 1.  */\n+  tmp = build_int_cst (TREE_TYPE (lse.expr), 0);\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t  lse.expr, tmp);\n+  tmp = build3_v (COND_EXPR, cond,\n+\t\t  build1_v (GOTO_EXPR, jump_label1),\n+\t\t  build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+    {\n+      /* Use the rhs string length and the lhs element size.  */\n+      size = string_length;\n+      tmp = TREE_TYPE (gfc_typenode_for_spec (&expr1->ts));\n+      tmp = TYPE_SIZE_UNIT (tmp);\n+      size_in_bytes = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t       TREE_TYPE (tmp), tmp,\n+\t\t\t\t       fold_convert (TREE_TYPE (tmp), size));\n+    }\n+  else\n+    {\n+      /* Otherwise use the length in bytes of the rhs.  */\n+      size = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));\n+      size_in_bytes = size;\n+    }\n+\n+  tmp = build_call_expr_loc (input_location,\n+\t\t\t     built_in_decls[BUILT_IN_MALLOC], 1,\n+\t\t\t     size_in_bytes);\n+  tmp = fold_convert (TREE_TYPE (lse.expr), tmp);\n+  gfc_add_modify (block, lse.expr, tmp);\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+    {\n+      /* Deferred characters need checking for lhs and rhs string\n+\t length.  Other deferred parameter variables will have to\n+\t come here too.  */\n+      tmp = build1_v (GOTO_EXPR, jump_label2);\n+      gfc_add_expr_to_block (block, tmp);\n+    }\n+  tmp = build1_v (LABEL_EXPR, jump_label1);\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  /* For a deferred length character, reallocate if lengths of lhs and\n+     rhs are different.  */\n+  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+    {\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t      expr1->ts.u.cl->backend_decl, size);\n+      /* Jump past the realloc if the lengths are the same.  */\n+      tmp = build3_v (COND_EXPR, cond,\n+\t\t      build1_v (GOTO_EXPR, jump_label2),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (block, tmp);\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t built_in_decls[BUILT_IN_REALLOC], 2,\n+\t\t\t\t fold_convert (pvoid_type_node, lse.expr),\n+\t\t\t\t size_in_bytes);\n+      tmp = fold_convert (TREE_TYPE (lse.expr), tmp);\n+      gfc_add_modify (block, lse.expr, tmp);\n+      tmp = build1_v (LABEL_EXPR, jump_label2);\n+      gfc_add_expr_to_block (block, tmp);\n+\n+      /* Update the lhs character length.  */\n+      size = string_length;\n+      gfc_add_modify (block, expr1->ts.u.cl->backend_decl, size);\n+    }\n+}\n+\n+\n /* Subroutine of gfc_trans_assignment that actually scalarizes the\n    assignment.  EXPR1 is the destination/LHS and EXPR2 is the source/RHS.\n    init_flag indicates initialization expressions and dealloc that no\n@@ -5929,6 +6094,15 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n       gfc_add_expr_to_block (&loop.post, tmp);\n     }\n \n+  /* For a deferred character length function, the function call must\n+     happen before the (re)allocation of the lhs, otherwise the character\n+     length of the result is not known.  */\n+  if (gfc_option.flag_realloc_lhs\n+\t&& expr2->expr_type == EXPR_FUNCTION\n+\t&& expr2->ts.type == BT_CHARACTER\n+\t&& expr2->ts.deferred)\n+    gfc_add_block_to_block (&block, &rse.pre);\n+\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n \t\t\t\t l_is_temp || init_flag,\n \t\t\t\t expr_is_variable (expr2) || scalar_to_array,\n@@ -5937,6 +6111,12 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \n   if (lss == gfc_ss_terminator)\n     {\n+      /* F2003: Add the code for reallocation on assignment.  */\n+      if (gfc_option.flag_realloc_lhs\n+\t    && is_scalar_reallocatable_lhs (expr1))\n+\talloc_scalar_allocatable_for_assignment (&block, rse.string_length,\n+\t\t\t\t\t\t expr1, expr2);\n+\n       /* Use the scalar assignment as is.  */\n       gfc_add_block_to_block (&block, &body);\n     }\n@@ -5972,7 +6152,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t  gfc_add_expr_to_block (&body, tmp);\n \t}\n \n-      /* Allocate or reallocate lhs of allocatable array.  */\n+      /* F2003: Allocate or reallocate lhs of allocatable array.  */\n       if (gfc_option.flag_realloc_lhs\n \t    && gfc_is_reallocatable_lhs (expr1)\n \t    && !gfc_expr_attr (expr1).codimension\n@@ -6042,13 +6222,6 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n {\n   tree tmp;\n \n-  if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n-    {\n-      gfc_error (\"Assignment to deferred-length character variable at %L \"\n-\t\t \"not implemented\", &expr1->where);\n-      return NULL_TREE;\n-    }\n-\n   /* Special case a single function returning an array.  */\n   if (expr2->expr_type == EXPR_FUNCTION && expr2->rank > 0)\n     {"}, {"sha": "161b309e00fd546b956de3c770853f503ae4b5e0", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -1,5 +1,6 @@\n /* Statement translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -4507,14 +4508,73 @@ gfc_trans_allocate (gfc_code * code)\n \t      else\n \t\tmemsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr3->ts));\n \t    }\n+\t  else if (al->expr->ts.type == BT_CHARACTER\n+\t\t     && al->expr->ts.deferred && code->expr3)\n+\t    {\n+\t      if (!code->expr3->ts.u.cl->backend_decl)\n+\t\t{\n+\t\t  /* Convert and use the length expression.  */\n+\t\t  gfc_se se_sz;\n+\t\t  gfc_init_se (&se_sz, NULL);\n+\t\t  if (code->expr3->expr_type == EXPR_VARIABLE\n+\t\t\t|| code->expr3->expr_type == EXPR_CONSTANT)\n+\t\t    {\n+\t\t      gfc_conv_expr (&se_sz, code->expr3);\n+\t\t      memsz = se_sz.string_length;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);\n+\t\t      memsz = se_sz.expr;\n+\t\t    }\n+\t\t  if (TREE_CODE (se.string_length) == VAR_DECL)\n+                    gfc_add_modify (&block, se.string_length,\n+\t\t\t\t    fold_convert (TREE_TYPE (se.string_length),\n+\t\t\t\t\t\t  memsz));\n+\t\t}\n+\t      else\n+\t\t/* Otherwise use the stored string length.  */\n+\t\tmemsz = code->expr3->ts.u.cl->backend_decl;\n+\t      tmp = al->expr->ts.u.cl->backend_decl;\n+\n+\t      /* Store the string length.  */\n+\t      if (tmp && TREE_CODE (tmp) == VAR_DECL)\n+\t\tgfc_add_modify (&block, tmp, fold_convert (TREE_TYPE (tmp),\n+\t\t\t\tmemsz));\n+\n+\t      /* Convert to size in bytes, using the character KIND.  */\n+\t      tmp = TREE_TYPE (gfc_typenode_for_spec (&al->expr->ts));\n+\t      tmp = TYPE_SIZE_UNIT (tmp);\n+\t      memsz = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t       TREE_TYPE (tmp), tmp,\n+\t\t\t\t       fold_convert (TREE_TYPE (tmp), memsz));\n+\t    }\n \t  else if (code->ext.alloc.ts.type != BT_UNKNOWN)\n \t    memsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n \t  else\n \t    memsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n \n \t  if (expr->ts.type == BT_CHARACTER && memsz == NULL_TREE)\n-\t    memsz = se.string_length;\n-\n+\t    {\n+\t      if (expr->ts.deferred)\n+\t\t{\n+\t\t  gfc_se se_sz;\n+\t\t  gfc_init_se (&se_sz, NULL);\n+\t\t  gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);\n+\t\t  memsz = se_sz.expr;\n+                  gfc_add_modify (&block, se.string_length,\n+\t\t\t\t  fold_convert (TREE_TYPE (se.string_length),\n+\t\t\t\t\t\tmemsz));\n+\t\t}\n+\t      else\n+\t\tmemsz = se.string_length;\n+\t      /* Convert to size in bytes, using the character KIND.  */\n+\t      tmp = TREE_TYPE (gfc_typenode_for_spec (&code->ext.alloc.ts));\n+\t      tmp = TYPE_SIZE_UNIT (tmp);\n+\t      memsz = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t       TREE_TYPE (tmp), tmp,\n+\t\t\t\t       fold_convert (TREE_TYPE (tmp), memsz));\n+\t    }\n \t  /* Allocate - for non-pointers with re-alloc checking.  */\n \t  {\n \t    gfc_ref *ref;"}, {"sha": "7c299741aec51f0e7b3e87f8bb07c50c161d45ef", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -1,6 +1,6 @@\n /* Backend support for Fortran 95 basic types and derived types.\n    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n-   2010\n+   2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -2352,7 +2352,6 @@ gfc_get_function_type (gfc_symbol * sym)\n   tree typelist;\n   gfc_formal_arglist *f;\n   gfc_symbol *arg;\n-  int nstr;\n   int alternate_return;\n \n   /* Make sure this symbol is a function, a subroutine or the main\n@@ -2363,7 +2362,6 @@ gfc_get_function_type (gfc_symbol * sym)\n   if (sym->backend_decl)\n     return TREE_TYPE (sym->backend_decl);\n \n-  nstr = 0;\n   alternate_return = 0;\n   typelist = NULL_TREE;\n \n@@ -2392,7 +2390,16 @@ gfc_get_function_type (gfc_symbol * sym)\n \n       typelist = gfc_chainon_list (typelist, type);\n       if (arg->ts.type == BT_CHARACTER)\n-\ttypelist = gfc_chainon_list (typelist, gfc_charlen_type_node);\n+\t{\n+\t  if (!arg->ts.deferred)\n+\t    /* Transfer by value.  */\n+\t    typelist = gfc_chainon_list (typelist, gfc_charlen_type_node);\n+\t  else\n+\t    /* Deferred character lengths are transferred by reference\n+\t       so that the value can be returned.  */\n+\t    typelist = gfc_chainon_list (typelist,\n+\t\t\t\tbuild_pointer_type (gfc_charlen_type_node));\n+\t}\n     }\n \n   /* Build the argument types for the function.  */\n@@ -2428,8 +2435,7 @@ gfc_get_function_type (gfc_symbol * sym)\n \t     Contained procedures could pass by value as these are never\n \t     used without an explicit interface, and cannot be passed as\n \t     actual parameters for a dummy procedure.  */\n-\t  if (arg->ts.type == BT_CHARACTER && !sym->attr.is_bind_c)\n-            nstr++;\n+\n \t  typelist = gfc_chainon_list (typelist, type);\n \t}\n       else\n@@ -2440,8 +2446,22 @@ gfc_get_function_type (gfc_symbol * sym)\n     }\n \n   /* Add hidden string length parameters.  */\n-  while (nstr--)\n-    typelist = gfc_chainon_list (typelist, gfc_charlen_type_node);\n+  for (f = sym->formal; f; f = f->next)\n+    {\n+      arg = f->sym;\n+      if (arg && arg->ts.type == BT_CHARACTER && !sym->attr.is_bind_c)\n+\t{\n+\t  if (!arg->ts.deferred)\n+\t    /* Transfer by value.  */\n+\t    type = gfc_charlen_type_node;\n+\t  else\n+\t    /* Deferred character lengths are transferred by reference\n+\t       so that the value can be returned.  */\n+\t    type = build_pointer_type (gfc_charlen_type_node);\n+\n+\t  typelist = gfc_chainon_list (typelist, type);\n+\t}\n+    }\n \n   if (typelist)\n     typelist = chainon (typelist, void_list_node);"}, {"sha": "cd0a2099b4c32d55385eaedac1e6ade9d28aef95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -1,3 +1,17 @@\n+2011-01-28  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Tobias Burnus  <burnus@gcc.gnu.org>\n+\n+\tPR fortran/45170\n+\tPR fortran/35810\n+\tPR fortran/47350\n+\t* gfortran.dg/realloc_on_assign_3.f03: New test.\n+\t* gfortran.dg/realloc_on_assign_4.f03: New test.\n+\t* gfortran.dg/realloc_on_assign_5.f90: New test.\n+\t* gfortran.dg/allocatable_function_5.f90: New test.\n+\t* gfortran.dg/allocate_deferred_char_scalar_1.f90: New test.\n+\t* gfortran.dg/deferred_type_param_2.f90: Remove two \"not yet\n+\timplemented\" dg-errors.\n+\n 2011-01-27  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/46949"}, {"sha": "a14318a64f516706a20a7fabb4358f198eb8112b", "filename": "gcc/testsuite/gfortran.dg/allocate_deferred_char_scalar_1.f03", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_deferred_char_scalar_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_deferred_char_scalar_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_deferred_char_scalar_1.f03?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -0,0 +1,267 @@\n+! { dg-do run}\n+!\n+! Automatic reallocate on assignment, deferred length parameter for char\n+!\n+! PR fortran/45170\n+! PR fortran/35810\n+! PR fortran/47350\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+program test\n+  implicit none\n+  call mold_check()\n+  call mold_check4()\n+  call source_check()\n+  call source_check4()\n+  call ftn_test()\n+  call ftn_test4()\n+  call source3()\n+contains\n+  subroutine source_check()\n+    character(len=:), allocatable :: str, str2\n+    target :: str\n+    character(len=8) :: str3\n+    character(len=:), pointer :: str4, str5\n+    nullify(str4)\n+    str3 = 'AbCdEfGhIj'\n+    if(allocated(str)) call abort()\n+    allocate(str, source=str3)\n+    if(.not.allocated(str)) call abort()\n+    if(len(str) /= 8) call abort()\n+    if(str /= 'AbCdEfGh') call abort()\n+    if(associated(str4)) call abort()\n+    str4 => str\n+    if(str4 /= str .or. len(str4)/=8) call abort()\n+    if(.not.associated(str4, str)) call abort()\n+    str4 => null()\n+    str = '12a56b78'\n+    if(str4 == '12a56b78') call abort()\n+    str4 = 'ABCDEFGH'\n+    if(str == 'ABCDEFGH') call abort()\n+    allocate(str5, source=str)\n+    if(associated(str5, str)) call abort()\n+    if(str5 /= '12a56b78' .or. len(str5)/=8) call abort()\n+    str = 'abcdef'\n+    if(str5 == 'abcdef') call abort()\n+    str5 = 'ABCDEF'\n+    if(str == 'ABCDEF') call abort()\n+  end subroutine source_check\n+  subroutine source_check4()\n+    character(kind=4,len=:), allocatable :: str, str2\n+    target :: str\n+    character(kind=4,len=8) :: str3\n+    character(kind=4,len=:), pointer :: str4, str5\n+    nullify(str4)\n+    str3 = 4_'AbCdEfGhIj'\n+    if(allocated(str)) call abort()\n+    allocate(str, source=str3)\n+    if(.not.allocated(str)) call abort()\n+    if(len(str) /= 8) call abort()\n+    if(str /= 4_'AbCdEfGh') call abort()\n+    if(associated(str4)) call abort()\n+    str4 => str\n+    if(str4 /= str .or. len(str4)/=8) call abort()\n+    if(.not.associated(str4, str)) call abort()\n+    str4 => null()\n+    str = 4_'12a56b78'\n+    if(str4 == 4_'12a56b78') call abort()\n+    str4 = 4_'ABCDEFGH'\n+    if(str == 4_'ABCDEFGH') call abort()\n+    allocate(str5, source=str)\n+    if(associated(str5, str)) call abort()\n+    if(str5 /= 4_'12a56b78' .or. len(str5)/=8) call abort()\n+    str = 4_'abcdef'\n+    if(str5 == 4_'abcdef') call abort()\n+    str5 = 4_'ABCDEF'\n+    if(str == 4_'ABCDEF') call abort()\n+  end subroutine source_check4\n+  subroutine mold_check()\n+    character(len=:), allocatable :: str, str2\n+    character(len=8) :: str3\n+    character(len=:), pointer :: str4, str5\n+    nullify(str4)\n+    str2 = \"ABCE\"\n+    ALLOCATE( str, MOLD=str3)\n+    if (len(str) /= 8) call abort()\n+    DEALLOCATE(str)\n+    ALLOCATE( str, MOLD=str2)\n+    if (len(str) /= 4) call abort()\n+\n+    IF (associated(str4)) call abort()\n+    ALLOCATE( str4, MOLD=str3)\n+    IF (.not.associated(str4)) call abort()\n+    str4 = '12345678'\n+    if (len(str4) /= 8) call abort()\n+    if(str4 /= '12345678') call abort()\n+    DEALLOCATE(str4)\n+    ALLOCATE( str4, MOLD=str2)\n+    str4 = 'ABCD'\n+    if (len(str4) /= 4) call abort()\n+    if (str4 /= 'ABCD') call abort()\n+    str5 => str4\n+    if(.not.associated(str4,str5)) call abort()\n+    if(len(str5) /= 4 .or. len(str4) /= len(str5)) call abort()\n+    if(str5 /= str4) call abort()\n+    deallocate(str4) \n+  end subroutine mold_check\n+  subroutine mold_check4()\n+    character(len=:,kind=4), allocatable :: str, str2\n+    character(len=8,kind=4) :: str3\n+    character(len=:,kind=4), pointer :: str4, str5\n+    nullify(str4)\n+    str2 = 4_\"ABCE\"\n+    ALLOCATE( str, MOLD=str3)\n+    if (len(str) /= 8) call abort()\n+    DEALLOCATE(str)\n+    ALLOCATE( str, MOLD=str2)\n+    if (len(str) /= 4) call abort()\n+\n+    IF (associated(str4)) call abort()\n+    ALLOCATE( str4, MOLD=str3)\n+    IF (.not.associated(str4)) call abort()\n+    str4 = 4_'12345678'\n+    if (len(str4) /= 8) call abort()\n+    if(str4 /= 4_'12345678') call abort()\n+    DEALLOCATE(str4)\n+    ALLOCATE( str4, MOLD=str2)\n+    str4 = 4_'ABCD'\n+    if (len(str4) /= 4) call abort()\n+    if (str4 /= 4_'ABCD') call abort()\n+    str5 => str4\n+    if(.not.associated(str4,str5)) call abort()\n+    if(len(str5) /= 4 .or. len(str4) /= len(str5)) call abort()\n+    if(str5 /= str4) call abort()\n+    deallocate(str4) \n+  end subroutine mold_check4\n+  subroutine ftn_test()\n+    character(len=:), allocatable :: str_a\n+    character(len=:), pointer     :: str_p\n+    nullify(str_p) \n+    call proc_test(str_a, str_p, .false.)\n+    if (str_p /= '123457890abcdef') call abort()\n+    if (len(str_p) /= 50) call abort()\n+    if (str_a(1:5) /= 'ABCDE ') call abort()\n+    if (len(str_a) /= 50) call abort()\n+    deallocate(str_p)\n+    str_a = '1245'\n+    if(len(str_a) /= 4) call abort()\n+    if(str_a /= '1245') call abort()\n+    allocate(character(len=6) :: str_p)\n+    if(len(str_p) /= 6) call abort()\n+    str_p = 'AbCdEf'\n+    call proc_test(str_a, str_p, .true.)\n+    if (str_p /= '123457890abcdef') call abort()\n+    if (len(str_p) /= 50) call abort()\n+    if (str_a(1:5) /= 'ABCDE ') call abort()\n+    if (len(str_a) /= 50) call abort()\n+    deallocate(str_p)\n+  end subroutine ftn_test\n+  subroutine proc_test(a, p, alloc)\n+    character(len=:), allocatable :: a\n+    character(len=:), pointer     :: p\n+    character(len=5), target :: loc\n+    logical :: alloc\n+    if (.not.  alloc) then\n+      if(associated(p)) call abort()\n+      if(allocated(a)) call abort()\n+    else\n+      if(len(a) /= 4) call abort()\n+      if(a /= '1245') call abort()\n+      if(len(p) /= 6) call abort()\n+      if(p /= 'AbCdEf') call abort()\n+      deallocate(a)\n+      nullify(p)\n+    end if\n+    allocate(character(len=50) :: a)\n+    a(1:5) = 'ABCDE'\n+    if(len(a) /= 50) call abort()\n+    if(a(1:5) /= \"ABCDE\") call abort()\n+    loc = '12345'\n+    p => loc\n+    if (len(p) /= 5) call abort()\n+    if (p /= '12345') call abort()\n+    p = '12345679'\n+    if (len(p) /= 5) call abort()\n+    if (p /= '12345') call abort()\n+    p = 'ABC'\n+    if (loc /= 'ABC  ') call abort()\n+    allocate(p, mold=a)\n+    if (.not.associated(p)) call abort()\n+    p = '123457890abcdef'\n+    if (p /= '123457890abcdef') call abort()\n+    if (len(p) /= 50) call abort()\n+  end subroutine proc_test\n+  subroutine ftn_test4()\n+    character(len=:,kind=4), allocatable :: str_a\n+    character(len=:,kind=4), pointer     :: str_p\n+    nullify(str_p) \n+    call proc_test4(str_a, str_p, .false.)\n+    if (str_p /= 4_'123457890abcdef') call abort()\n+    if (len(str_p) /= 50) call abort()\n+    if (str_a(1:5) /= 4_'ABCDE ') call abort()\n+    if (len(str_a) /= 50) call abort()\n+    deallocate(str_p)\n+    str_a = 4_'1245'\n+    if(len(str_a) /= 4) call abort()\n+    if(str_a /= 4_'1245') call abort()\n+    allocate(character(len=6, kind = 4) :: str_p)\n+    if(len(str_p) /= 6) call abort()\n+    str_p = 4_'AbCdEf'\n+    call proc_test4(str_a, str_p, .true.)\n+    if (str_p /= 4_'123457890abcdef') call abort()\n+    if (len(str_p) /= 50) call abort()\n+    if (str_a(1:5) /= 4_'ABCDE ') call abort()\n+    if (len(str_a) /= 50) call abort()\n+    deallocate(str_p)\n+  end subroutine ftn_test4\n+  subroutine proc_test4(a, p, alloc)\n+    character(len=:,kind=4), allocatable :: a\n+    character(len=:,kind=4), pointer     :: p\n+    character(len=5,kind=4), target :: loc\n+    logical :: alloc\n+    if (.not.  alloc) then\n+      if(associated(p)) call abort()\n+      if(allocated(a)) call abort()\n+    else\n+      if(len(a) /= 4) call abort()\n+      if(a /= 4_'1245') call abort()\n+      if(len(p) /= 6) call abort()\n+      if(p /= 4_'AbCdEf') call abort()\n+      deallocate(a)\n+      nullify(p)\n+    end if\n+    allocate(character(len=50,kind=4) :: a)\n+    a(1:5) = 4_'ABCDE'\n+    if(len(a) /= 50) call abort()\n+    if(a(1:5) /= 4_\"ABCDE\") call abort()\n+    loc = '12345'\n+    p => loc\n+    if (len(p) /= 5) call abort()\n+    if (p /= 4_'12345') call abort()\n+    p = 4_'12345679'\n+    if (len(p) /= 5) call abort()\n+    if (p /= 4_'12345') call abort()\n+    p = 4_'ABC'\n+    if (loc /= 4_'ABC  ') call abort()\n+    allocate(p, mold=a)\n+    if (.not.associated(p)) call abort()\n+    p = 4_'123457890abcdef'\n+    if (p /= 4_'123457890abcdef') call abort()\n+    if (len(p) /= 50) call abort()\n+  end subroutine proc_test4\n+  subroutine source3()\n+     character(len=:, kind=1), allocatable :: a1\n+     character(len=:, kind=4), allocatable :: a4\n+     character(len=:, kind=1), pointer     :: p1\n+     character(len=:, kind=4), pointer     :: p4\n+     allocate(a1, source='ABC') ! << ICE\n+     if(len(a1) /= 3 .or. a1 /= 'ABC') call abort()\n+     allocate(a4, source=4_'12345') ! << ICE\n+     if(len(a4) /= 5 .or. a4 /= 4_'12345') call abort()\n+     allocate(p1, mold='AB') ! << ICE\n+     if(len(p1) /= 2) call abort()\n+     allocate(p4, mold=4_'145') ! << ICE\n+     if(len(p4) /= 3) call abort()\n+  end subroutine source3\n+end program test"}, {"sha": "8ac48c3f1532a6919cafabc3f934924c792fd11b", "filename": "gcc/testsuite/gfortran.dg/deferred_type_param_2.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_type_param_2.f90?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -34,9 +34,9 @@ subroutine three()\n   str1 = [\"abc\"]\n   pstr2 => str1\n \n-  allocate (character(len=77) :: str1(1)) ! OK ! { dg-error \"not yet implemented\" }\n-  allocate (pstr, source=str2)  ! OK  ! { dg-error \"not yet implemented\" }\n-  allocate (pstr, mold=str2) ! { dg-error \"requires either a type-spec or SOURCE tag\" }\n+  allocate (character(len=77) :: str1(1))\n+  allocate (pstr, source=str2)\n+  allocate (pstr, mold=str2)\n   allocate (pstr) ! { dg-error \"requires either a type-spec or SOURCE tag\" }\n   allocate (character(len=:) :: str1(1)) ! { dg-error \"cannot contain a deferred type parameter\" }\n "}, {"sha": "d975f47270588f9a3c1212b7b4640d4f400d5e15", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_3.f03", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_3.f03?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do run }\n+! Test (re)allocation on assignment of scalars\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  call test_real\n+  call test_derived\n+  call test_char1\n+  call test_char4\n+  call test_deferred_char1\n+  call test_deferred_char4\n+contains\n+  subroutine test_real\n+    real, allocatable :: x\n+    real :: y = 42\n+    x = 42.0\n+    if (x .ne. y) call abort\n+    deallocate (x)\n+    x = y\n+    if (x .ne. y) call abort\n+  end subroutine   \n+  subroutine test_derived\n+    type :: mytype\n+      real :: x\n+      character(4) :: c\n+    end type\n+    type (mytype), allocatable :: t\n+    t = mytype (99.0, \"abcd\")\n+    if (t%c .ne. \"abcd\") call abort\n+  end subroutine   \n+  subroutine test_char1\n+    character(len = 8), allocatable :: c1\n+    character(len = 8) :: c2 = \"abcd1234\"\n+    c1 = \"abcd1234\"\n+    if (c1 .ne. c2) call abort\n+    deallocate (c1)\n+    c1 = c2\n+    if (c1 .ne. c2) call abort\n+  end subroutine    \n+  subroutine test_char4\n+    character(len = 8, kind = 4), allocatable :: c1\n+    character(len = 8, kind = 4) :: c2 = 4_\"abcd1234\"\n+    c1 = 4_\"abcd1234\"\n+    if (c1 .ne. c2) call abort\n+    deallocate (c1)\n+    c1 = c2\n+    if (c1 .ne. c2) call abort\n+  end subroutine\n+  subroutine test_deferred_char1  \n+    character(:), allocatable :: c\n+    c = \"Hello\"\n+    if (c .ne. \"Hello\") call abort\n+    if (len(c) .ne. 5) call abort\n+    c = \"Goodbye\"\n+    if (c .ne. \"Goodbye\") call abort\n+    if (len(c) .ne. 7) call abort\n+! Check that the hidden LEN dummy is passed by reference\n+    call test_pass_c1 (c)\n+    if (c .ne. \"Made in test!\") print *, c\n+    if (len(c) .ne. 13) call abort\n+  end subroutine\n+  subroutine test_pass_c1 (carg)\n+    character(:), allocatable :: carg\n+    if (carg .ne. \"Goodbye\") call abort\n+    if (len(carg) .ne. 7) call abort\n+    carg = \"Made in test!\"\n+  end subroutine\n+  subroutine test_deferred_char4\n+    character(:, kind = 4), allocatable :: c\n+    c = 4_\"Hello\"\n+    if (c .ne. 4_\"Hello\") call abort\n+    if (len(c) .ne. 5) call abort\n+    c = 4_\"Goodbye\"\n+    if (c .ne. 4_\"Goodbye\") call abort\n+    if (len(c) .ne. 7) call abort\n+! Check that the hidden LEN dummy is passed by reference\n+    call test_pass_c4 (c)\n+    if (c .ne. 4_\"Made in test!\") print *, c\n+    if (len(c) .ne. 13) call abort\n+  end subroutine\n+  subroutine test_pass_c4 (carg)\n+    character(:, kind = 4), allocatable :: carg\n+    if (carg .ne. 4_\"Goodbye\") call abort\n+    if (len(carg) .ne. 7) call abort\n+    carg = 4_\"Made in test!\"\n+  end subroutine\n+end\n+"}, {"sha": "a71f5d59bd1b3c2649c2b386930be23b09c20a05", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_4.f03", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_4.f03?ref=8d51f26f8ec2e78a6369c1cd8bf72e39d61261e2", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do run }\n+! Tests function return of deferred length scalars.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module m\n+contains\n+  function mfoo (carg) result(res)\n+    character (:), allocatable :: res\n+    character (*) :: carg\n+    res = carg(2:4)\n+  end function\n+  function mbar (carg)\n+    character (:), allocatable :: mbar\n+    character (*) :: carg\n+    mbar = carg(2:13)\n+  end function\n+end module\n+\n+  use m\n+  character (:), allocatable :: lhs\n+  lhs = foo (\"foo calling \")\n+  if (lhs .ne. \"foo\") call abort\n+  if (len (lhs) .ne. 3) call abort\n+  deallocate (lhs)\n+  lhs = bar (\"bar calling - baaaa!\")\n+  if (lhs .ne. \"bar calling\") call abort\n+  if (len (lhs) .ne. 12) call abort\n+  deallocate (lhs)\n+  lhs = mfoo (\"mfoo calling \")\n+  if (lhs .ne. \"foo\") call abort\n+  if (len (lhs) .ne. 3) call abort\n+  deallocate (lhs)\n+  lhs = mbar (\"mbar calling - baaaa!\")\n+  if (lhs .ne. \"bar calling\") call abort\n+  if (len (lhs) .ne. 12) call abort\n+contains\n+  function foo (carg) result(res)\n+    character (:), allocatable :: res\n+    character (*) :: carg\n+    res = carg(1:3)\n+  end function\n+  function bar (carg)\n+    character (:), allocatable :: bar\n+    character (*) :: carg\n+    bar = carg(1:12)\n+  end function\n+end\n+\n+"}]}