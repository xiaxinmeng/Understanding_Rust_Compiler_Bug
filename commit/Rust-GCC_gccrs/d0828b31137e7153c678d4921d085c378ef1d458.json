{"sha": "d0828b31137e7153c678d4921d085c378ef1d458", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4MjhiMzExMzdlNzE1M2M2NzhkNDkyMWQwODVjMzc4ZWYxZDQ1OA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2005-04-27T17:38:17Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2005-04-27T17:38:17Z"}, "message": "explow.c (allocate_dynamic_stack_space SETJMP_VIA_SAVE_AREA): Kill setjmpless_size.\n\n\t* explow.c (allocate_dynamic_stack_space SETJMP_VIA_SAVE_AREA):\n\tKill setjmpless_size.  current_function_calls_setjmp is completely\n\tcomputed when we are called, so just use the optimized size value\n\tinstead of using REG_SAVE_AREA notes.\n\t(optimize_save_area_alloca): Delete....\n\t* rtl.h (optimize_save_area_alloca): Likewise...\n\t* passes.c (rest_of_compilation): and don't call it any more.\n\t* reg-notes.def (SAVE_AREA): Delete.\n\nFrom-SVN: r98861", "tree": {"sha": "5d84007dcd11c49594a8241212785c5184d6b5ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d84007dcd11c49594a8241212785c5184d6b5ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0828b31137e7153c678d4921d085c378ef1d458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0828b31137e7153c678d4921d085c378ef1d458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0828b31137e7153c678d4921d085c378ef1d458", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0828b31137e7153c678d4921d085c378ef1d458/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25b9575bc2665d873a16ddc30e7829bcdadf4dec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25b9575bc2665d873a16ddc30e7829bcdadf4dec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25b9575bc2665d873a16ddc30e7829bcdadf4dec"}], "stats": {"total": 198, "additions": 50, "deletions": 148}, "files": [{"sha": "54870c628d189dd91418583d29e708a8c7340b58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0828b31137e7153c678d4921d085c378ef1d458", "patch": "@@ -1,3 +1,14 @@\n+2005-04-27  David S. Miller  <davem@davemloft.net>\n+\n+\t* explow.c (allocate_dynamic_stack_space SETJMP_VIA_SAVE_AREA):\n+\tKill setjmpless_size.  current_function_calls_setjmp is completely\n+\tcomputed when we are called, so just use the optimized size value\n+\tinstead of using REG_SAVE_AREA notes.\n+\t(optimize_save_area_alloca): Delete....\n+\t* rtl.h (optimize_save_area_alloca): Likewise...\n+\t* passes.c (rest_of_compilation): and don't call it any more.\n+\t* reg-notes.def (SAVE_AREA): Delete.\n+\t\n 2005-04-27  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/fp-bit.c (abort): Add noreturn attribute."}, {"sha": "6a406901e34b552e3a11a3adb08073d9dc431b5f", "filename": "gcc/explow.c", "status": "modified", "additions": 39, "deletions": 134, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d0828b31137e7153c678d4921d085c378ef1d458", "patch": "@@ -1017,83 +1017,6 @@ update_nonlocal_goto_save_area (void)\n   emit_stack_save (SAVE_NONLOCAL, &r_save, NULL_RTX);\n }\n \f\n-#ifdef SETJMP_VIA_SAVE_AREA\n-/* Optimize RTL generated by allocate_dynamic_stack_space for targets\n-   where SETJMP_VIA_SAVE_AREA is true.  The problem is that on these\n-   platforms, the dynamic stack space used can corrupt the original\n-   frame, thus causing a crash if a longjmp unwinds to it.  */\n-\n-void\n-optimize_save_area_alloca (void)\n-{\n-  rtx insn;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN(insn))\n-    {\n-      rtx note;\n-\n-      if (!NONJUMP_INSN_P (insn))\n-\tcontinue;\n-\n-      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t{\n-\t  if (REG_NOTE_KIND (note) != REG_SAVE_AREA)\n-\t    continue;\n-\n-\t  if (!current_function_calls_setjmp)\n-\t    {\n-\t      rtx pat = PATTERN (insn);\n-\n-\t      /* If we do not see the note in a pattern matching\n-\t\t these precise characteristics, we did something\n-\t\t entirely wrong in allocate_dynamic_stack_space.\n-\n-\t\t Note, one way this could happen is if SETJMP_VIA_SAVE_AREA\n-\t\t was defined on a machine where stacks grow towards higher\n-\t\t addresses.\n-\n-\t\t Right now only supported port with stack that grow upward\n-\t\t is the HPPA and it does not define SETJMP_VIA_SAVE_AREA.  */\n-\t      gcc_assert (GET_CODE (pat) == SET\n-\t\t\t  && SET_DEST (pat) == stack_pointer_rtx\n-\t\t\t  && GET_CODE (SET_SRC (pat)) == MINUS\n-\t\t\t  && XEXP (SET_SRC (pat), 0) == stack_pointer_rtx);\n-\n-\t      /* This will now be transformed into a (set REG REG)\n-\t\t so we can just blow away all the other notes.  */\n-\t      XEXP (SET_SRC (pat), 1) = XEXP (note, 0);\n-\t      REG_NOTES (insn) = NULL_RTX;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* setjmp was called, we must remove the REG_SAVE_AREA\n-\t\t note so that later passes do not get confused by its\n-\t\t presence.  */\n-\t      if (note == REG_NOTES (insn))\n-\t\t{\n-\t\t  REG_NOTES (insn) = XEXP (note, 1);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rtx srch;\n-\n-\t\t  for (srch = REG_NOTES (insn); srch; srch = XEXP (srch, 1))\n-\t\t    if (XEXP (srch, 1) == note)\n-\t\t      break;\n-\n-\t\t  gcc_assert (srch);\n-\n-\t\t  XEXP (srch, 1) = XEXP (note, 1);\n-\t\t}\n-\t    }\n-\t  /* Once we've seen the note of interest, we need not look at\n-\t     the rest of them.  */\n-\t  break;\n-\t}\n-    }\n-}\n-#endif /* SETJMP_VIA_SAVE_AREA */\n-\n /* Return an rtx representing the address of an area of memory dynamically\n    pushed on the stack.  This region of memory is always aligned to\n    a multiple of BIGGEST_ALIGNMENT.\n@@ -1108,10 +1031,6 @@ optimize_save_area_alloca (void)\n rtx\n allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n {\n-#ifdef SETJMP_VIA_SAVE_AREA\n-  rtx setjmpless_size = NULL_RTX;\n-#endif\n-\n   /* If we're asking for zero bytes, it doesn't matter what we point\n      to since we can't dereference it.  But return a reasonable\n      address anyway.  */\n@@ -1160,51 +1079,47 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n      avoid clobbering the reg save area.  Note that the offset of\n      virtual_incoming_args_rtx includes the preallocated stack args space.\n      It would be no problem to clobber that, but it's on the wrong side\n-     of the old save area.  */\n-  {\n-    rtx dynamic_offset\n-      = expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,\n-\t\t      stack_pointer_rtx, NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+     of the old save area.\n+\n+     What used to happen is that, since we did not know for sure\n+     whether setjmp() was invoked until after RTL generation, we\n+     would use reg notes to store the \"optimized\" size and fix things\n+     up later.  These days we know this information before we ever\n+     start building RTL so the reg notes are unnecessary.  */\n+  if (!current_function_calls_setjmp)\n+    {\n+      int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n \n-    if (!current_function_calls_setjmp)\n-      {\n-\tint align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n-\n-\t/* See optimize_save_area_alloca to understand what is being\n-\t   set up here.  */\n-\n-\t/* ??? Code below assumes that the save area needs maximal\n-\t   alignment.  This constraint may be too strong.  */\n-\tgcc_assert (PREFERRED_STACK_BOUNDARY == BIGGEST_ALIGNMENT);\n-\n-\tif (GET_CODE (size) == CONST_INT)\n-\t  {\n-\t    HOST_WIDE_INT new = INTVAL (size) / align * align;\n-\n-\t    if (INTVAL (size) != new)\n-\t      setjmpless_size = GEN_INT (new);\n-\t    else\n-\t      setjmpless_size = size;\n-\t  }\n-\telse\n-\t  {\n-\t    /* Since we know overflow is not possible, we avoid using\n-\t       CEIL_DIV_EXPR and use TRUNC_DIV_EXPR instead.  */\n-\t    setjmpless_size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size,\n-\t\t\t\t\t     GEN_INT (align), NULL_RTX, 1);\n-\t    setjmpless_size = expand_mult (Pmode, setjmpless_size,\n-\t\t\t\t\t   GEN_INT (align), NULL_RTX, 1);\n-\t  }\n-\t/* Our optimization works based upon being able to perform a simple\n-\t   transformation of this RTL into a (set REG REG) so make sure things\n-\t   did in fact end up in a REG.  */\n-\tif (!register_operand (setjmpless_size, Pmode))\n-\t  setjmpless_size = force_reg (Pmode, setjmpless_size);\n-      }\n+      /* ??? Code below assumes that the save area needs maximal\n+\t alignment.  This constraint may be too strong.  */\n+      gcc_assert (PREFERRED_STACK_BOUNDARY == BIGGEST_ALIGNMENT);\n \n-    size = expand_binop (Pmode, add_optab, size, dynamic_offset,\n-\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-  }\n+      if (GET_CODE (size) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT new = INTVAL (size) / align * align;\n+\n+\t  if (INTVAL (size) != new)\n+\t    size = GEN_INT (new);\n+\t}\n+      else\n+\t{\n+\t  /* Since we know overflow is not possible, we avoid using\n+\t     CEIL_DIV_EXPR and use TRUNC_DIV_EXPR instead.  */\n+\t  size = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, size,\n+\t\t\t\tGEN_INT (align), NULL_RTX, 1);\n+\t  size = expand_mult (Pmode, size,\n+\t\t\t      GEN_INT (align), NULL_RTX, 1);\n+\t}\n+    }\n+  else\n+    {\n+      rtx dynamic_offset\n+\t= expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,\n+\t\t\tstack_pointer_rtx, NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+      size = expand_binop (Pmode, add_optab, size, dynamic_offset,\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+    }\n #endif /* SETJMP_VIA_SAVE_AREA */\n \n   /* Round the size to a multiple of the required stack alignment.\n@@ -1304,16 +1219,6 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n \t}\n \n       anti_adjust_stack (size);\n-#ifdef SETJMP_VIA_SAVE_AREA\n-      if (setjmpless_size != NULL_RTX)\n-\t{\n-\t  rtx note_target = get_last_insn ();\n-\n-\t  REG_NOTES (note_target)\n-\t    = gen_rtx_EXPR_LIST (REG_SAVE_AREA, setjmpless_size,\n-\t\t\t\t REG_NOTES (note_target));\n-\t}\n-#endif /* SETJMP_VIA_SAVE_AREA */\n \n #ifdef STACK_GROWS_DOWNWARD\n       emit_move_insn (target, virtual_stack_dynamic_rtx);"}, {"sha": "7f1a9b36c861a1033a33f425267357d3c291edd5", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d0828b31137e7153c678d4921d085c378ef1d458", "patch": "@@ -1558,15 +1558,6 @@ rest_of_compilation (void)\n   /* Copy any shared structure that should not be shared.  */\n   unshare_all_rtl ();\n \n-#ifdef SETJMP_VIA_SAVE_AREA\n-  /* This must be performed before virtual register instantiation.\n-     Please be aware that everything in the compiler that can look\n-     at the RTL up to this point must understand that REG_SAVE_AREA\n-     is just like a use of the REG contained inside.  */\n-  if (current_function_calls_alloca)\n-    optimize_save_area_alloca ();\n-#endif\n-\n   /* Instantiate all virtual registers.  */\n   instantiate_virtual_regs ();\n "}, {"sha": "a7df27bcb1463eb365d610ff644588ee1112c61b", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=d0828b31137e7153c678d4921d085c378ef1d458", "patch": "@@ -117,10 +117,6 @@ REG_NOTE (VALUE_PROFILE)\n    that the pointer returned cannot alias anything else.  */\n REG_NOTE (NOALIAS)\n \n-/* Used to optimize rtl generated by dynamic stack allocations for\n-   targets where SETJMP_VIA_SAVE_AREA is true.  */\n-REG_NOTE (SAVE_AREA)\n-\n /* REG_BR_PRED is attached to JUMP_INSNs and CALL_INSNSs.  It contains\n    CONCAT of two integer value.  First specifies the branch predictor\n    that added the note, second specifies the predicted hitrate of"}, {"sha": "c162393a74e9db12711423807a5409544720c52e", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0828b31137e7153c678d4921d085c378ef1d458/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d0828b31137e7153c678d4921d085c378ef1d458", "patch": "@@ -1320,7 +1320,6 @@ extern rtx expand_builtin_expect_jump (tree, rtx, rtx);\n extern void set_stack_check_libfunc (rtx);\n extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, enum machine_mode);\n extern rtx plus_constant (rtx, HOST_WIDE_INT);\n-extern void optimize_save_area_alloca (void);\n \n /* In emit-rtl.c */\n extern rtvec gen_rtvec (int, ...);"}]}