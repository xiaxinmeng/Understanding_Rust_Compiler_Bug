{"sha": "7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FkYTY2MjVjZDNhN2U2OTQwMjQ4Y2JiNGU2MGE3ZTY4YjNiN2YxMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-27T14:43:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-27T14:43:46Z"}, "message": "* i386.md (mins*, maxs*): New patterns, expanders and splitters.\n\nFrom-SVN: r40092", "tree": {"sha": "d0975066595550b68864a11479ef0fff02e3eafc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0975066595550b68864a11479ef0fff02e3eafc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12/comments", "author": null, "committer": null, "parents": [{"sha": "73ea87d76df215c101cf1a6b17bc7739c341f1dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ea87d76df215c101cf1a6b17bc7739c341f1dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ea87d76df215c101cf1a6b17bc7739c341f1dc"}], "stats": {"total": 294, "additions": 294, "deletions": 0}, "files": [{"sha": "c8eeca62760c849d96d885ae62a8d17904fb07ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12", "patch": "@@ -1,3 +1,7 @@\n+Tue Feb 27 15:36:48 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (mins*, maxs*): New patterns, expanders and splitters.\n+\n 2001-02-26  Jeffrey Oldham  <oldham@codesourcery.com>\n \n \t* mips.c (mips_make_temp_file): Fix thinko in last change."}, {"sha": "de369128d777832349b8cf07ff8613e9d1c37296", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7ada6625cd3a7e6940248cbb4e60a7e68b3b7f12", "patch": "@@ -12110,6 +12110,296 @@\n    fcmov%f1\\\\t{%3, %0|%0, %3}\"\n   [(set_attr \"type\" \"fcmov\")\n    (set_attr \"mode\" \"XF\")])\n+\n+(define_expand \"minsf3\"\n+  [(parallel [\n+     (set (match_operand:SF 0 \"register_operand\" \"\")\n+\t  (if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t\t       (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n+\t\t\t   (match_dup 1)\n+\t\t\t   (match_dup 2)))\n+     (clobber (reg:CC 17))])]\n+  \"TARGET_SSE\"\n+  \"\")\n+\n+(define_insn \"*minsf\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x,f#x\")\n+\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"0,0,f#x\")\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,f#x,0\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE && TARGET_IEEE_FP\"\n+  \"#\")\n+\n+(define_insn \"*minsf_nonieee\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x\")\n+\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"%0,0\")\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,fm#x\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE && !TARGET_IEEE_FP\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  [(set (match_dup 0)\n+\t(if_then_else:SF (lt (match_dup 1)\n+\t\t\t     (match_dup 2))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+;; We can't represent the LT test directly.  Do this by swapping the operands.\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:SF 2 \"register_operand\" \"\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"FP_REG_P (operands[0]) && reload_completed\"\n+  [(set (reg:CCFP 17)\n+\t(compare:CCFP (match_dup 2)\n+\t\t      (match_dup 1)))\n+   (set (match_dup 0)\n+\t(if_then_else:SF (ge (reg:CCFP 17) (const_int 0))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+(define_insn \"*minsf_sse\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))]\n+  \"TARGET_SSE && reload_completed\"\n+  \"minss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_expand \"mindf3\"\n+  [(parallel [\n+     (set (match_operand:DF 0 \"register_operand\" \"\")\n+\t  (if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"\")\n+\t\t\t       (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n+\t\t\t   (match_dup 1)\n+\t\t\t   (match_dup 2)))\n+     (clobber (reg:CC 17))])]\n+  \"TARGET_SSE2\"\n+  \"#\")\n+\n+(define_insn \"*mindf\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y,f#Y\")\n+\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"0,0,f#Y\")\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,f#Y,0\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE2 && TARGET_IEEE_FP\"\n+  \"#\")\n+\n+(define_insn \"*mindf_nonieee\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y\")\n+\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"%0,0\")\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,fm#Y\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE2 && !TARGET_IEEE_FP\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  [(set (match_dup 0)\n+\t(if_then_else:DF (lt (match_dup 1)\n+\t\t\t     (match_dup 2))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+;; We can't represent the LT test directly.  Do this by swapping the operands.\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:DF 2 \"register_operand\" \"\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"FP_REG_P (operands[0]) && reload_completed\"\n+  [(set (reg:CCFP 17)\n+\t(compare:CCFP (match_dup 2)\n+\t\t      (match_dup 2)))\n+   (set (match_dup 0)\n+\t(if_then_else:DF (ge (reg:CCFP 17) (const_int 0))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+(define_insn \"*mindf_sse\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=Y\")\n+\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))]\n+  \"TARGET_SSE2 && reload_completed\"\n+  \"minsd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_expand \"maxsf3\"\n+  [(parallel [\n+     (set (match_operand:SF 0 \"register_operand\" \"\")\n+\t  (if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t\t       (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n+\t\t\t   (match_dup 1)\n+\t\t\t   (match_dup 2)))\n+     (clobber (reg:CC 17))])]\n+  \"TARGET_SSE\"\n+  \"#\")\n+\n+(define_insn \"*maxsf\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x,f#x\")\n+\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"0,0,f#x\")\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,fm#x,0\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE && TARGET_IEEE_FP\"\n+  \"#\")\n+\n+(define_insn \"*maxsf_nonieee\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x\")\n+\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"%0,0\")\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,fm#x\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE && !TARGET_IEEE_FP\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  [(set (match_dup 0)\n+\t(if_then_else:SF (gt (match_dup 1)\n+\t\t\t     (match_dup 2))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:SF 2 \"register_operand\" \"\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"FP_REG_P (operands[0]) && reload_completed\"\n+  [(set (reg:CCFP 17)\n+\t(compare:CCFP (match_dup 1)\n+\t\t      (match_dup 2)))\n+   (set (match_dup 0)\n+\t(if_then_else:SF (gt (reg:CCFP 17) (const_int 0))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+(define_insn \"*maxsf_sse\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))]\n+  \"TARGET_SSE && reload_completed\"\n+  \"maxss\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_expand \"maxdf3\"\n+  [(parallel [\n+     (set (match_operand:DF 0 \"register_operand\" \"\")\n+\t  (if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"\")\n+\t\t\t       (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n+\t\t\t   (match_dup 1)\n+\t\t\t   (match_dup 2)))\n+     (clobber (reg:CC 17))])]\n+  \"TARGET_SSE2\"\n+  \"#\")\n+\n+(define_insn \"*maxdf\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y,f#Y\")\n+\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"0,0,f#Y\")\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,fm#Y,0\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE2 && TARGET_IEEE_FP\"\n+  \"#\")\n+\n+(define_insn \"*maxdf_nonieee\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y\")\n+\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"%0,0\")\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,fm#Y\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SSE2 && !TARGET_IEEE_FP\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  [(set (match_dup 0)\n+\t(if_then_else:DF (gt (match_dup 1)\n+\t\t\t     (match_dup 2))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:DF 2 \"register_operand\" \"\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))\n+   (clobber (reg:CC 17))]\n+  \"FP_REG_P (operands[0]) && reload_completed\"\n+  [(set (reg:CCFP 17)\n+\t(compare:CCFP (match_dup 1)\n+\t\t      (match_dup 2)))\n+   (set (match_dup 0)\n+\t(if_then_else:DF (gt (reg:CCFP 17) (const_int 0))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))])\n+\n+(define_insn \"*maxdf_sse\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=Y\")\n+\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\"))\n+\t\t\t (match_dup 1)\n+\t\t\t (match_dup 2)))]\n+  \"TARGET_SSE2 && reload_completed\"\n+  \"maxsd\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"mode\" \"DF\")])\n \f\n ;; Misc patterns (?)\n "}]}