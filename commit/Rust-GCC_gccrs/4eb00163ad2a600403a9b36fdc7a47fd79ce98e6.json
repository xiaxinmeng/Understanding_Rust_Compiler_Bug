{"sha": "4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGViMDAxNjNhZDJhNjAwNDAzYTliMzZmZGM3YTQ3ZmQ3OWNlOThlNg==", "commit": {"author": {"name": "Jeffrey Oldham", "email": "oldham@codesourcery.com", "date": "2000-07-22T23:29:14Z"}, "committer": {"name": "Jeffrey D. Oldham", "email": "oldham@gcc.gnu.org", "date": "2000-07-22T23:29:14Z"}, "message": "collect2.c (main): Typo fixed.\n\n2000-07-22  Jeffrey Oldham  <oldham@codesourcery.com>\n\n\t* collect2.c (main): Typo fixed.\n\t* diagnostic.c: Typo fixed.\n\t* dwarf2out.c (dwarf2out_frame_debug_expr): Typo fixed.\n\t* eh-common.h: Typo fixed.\n\t* emit-rtl.c (start_sequence): Typo fixed.\n\t* flow.c (find_label_refs): Typo fixed.\n\t(calculate_global_regs_live): Typo fixed.\n\t(mark_regno_cond_dead): Typo fixed.\n\t(create_edge_list): Typos fixed.\n\t(verify_edge_list): Typo fixed.\n\t* ggc-common.c (ggc_mark_rtx_children): Typo fixed.\n\t* loop.c (strength_reduce): Typo in function name fixed.\n\t* rtl.h: Added comments.  Typo in function name fixed.\n\t* rtlanal.c: Typo in function name fixed.\n\t(insn_dependant_p): Rename to ...\n\t(insn_dependent_p): ... this.\n\t(computed_jumo_p): Typo fixed.\n\nFrom-SVN: r35194", "tree": {"sha": "905decf88d64625f2e335c550face23d4df5671f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/905decf88d64625f2e335c550face23d4df5671f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/comments", "author": null, "committer": null, "parents": [{"sha": "11489a95954d9b77b40c4a1621521564dd5b2e07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11489a95954d9b77b40c4a1621521564dd5b2e07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11489a95954d9b77b40c4a1621521564dd5b2e07"}], "stats": {"total": 129, "additions": 102, "deletions": 27}, "files": [{"sha": "0b5c01232d4088ba91d4a0bec999f5cbf034f14e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -1,3 +1,23 @@\n+2000-07-22  Jeffrey Oldham  <oldham@codesourcery.com>\n+\n+\t* collect2.c (main): Typo fixed.\n+\t* diagnostic.c: Typo fixed.\n+\t* dwarf2out.c (dwarf2out_frame_debug_expr): Typo fixed.\n+\t* eh-common.h: Typo fixed.\n+\t* emit-rtl.c (start_sequence): Typo fixed.\n+\t* flow.c (find_label_refs): Typo fixed.\n+\t(calculate_global_regs_live): Typo fixed.\n+\t(mark_regno_cond_dead): Typo fixed.\n+\t(create_edge_list): Typos fixed.\n+\t(verify_edge_list): Typo fixed.\n+\t* ggc-common.c (ggc_mark_rtx_children): Typo fixed.\n+\t* loop.c (strength_reduce): Typo in function name fixed.\n+\t* rtl.h: Added comments.  Typo in function name fixed.\n+\t* rtlanal.c: Typo in function name fixed.\n+\t(insn_dependant_p): Rename to ...\n+\t(insn_dependent_p): ... this.\n+\t(computed_jumo_p): Typo fixed.\n+\n 2000-07-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* system.h (__FUNCTION__): Wrap definition in #ifndef."}, {"sha": "13372792481735489b401150329b4f2274b167ce", "filename": "gcc/collect2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -876,7 +876,7 @@ main (argc, argv)\n   int num_c_args\t= argc+9;\n \n #if defined (COLLECT2_HOST_INITIALIZATION)\n-  /* Perform system dependant initialization, if neccessary.  */\n+  /* Perform system dependent initialization, if neccessary.  */\n   COLLECT2_HOST_INITIALIZATION;\n #endif\n "}, {"sha": "1afe54515249198960a85ac65b10ad427db504f4", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -20,7 +20,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* This file implements the language independant aspect of diagnostic\n+/* This file implements the language independent aspect of diagnostic\n    message module.  */\n \n #include \"config.h\""}, {"sha": "48aa33683e7a188b97dff09d0a3dd53021d60868", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -1226,7 +1226,7 @@ dwarf2out_frame_debug_expr (expr, label)\n   long offset;\n     \n   /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of \n-     the PARALLEL independantly. The first element is always processed if \n+     the PARALLEL independently. The first element is always processed if \n      it is a SET. This is for backward compatability.   Other elements \n      are processed only if they are SETs and the RTX_FRAME_RELATED_P \n      flag is set in them. */"}, {"sha": "dffe682a05b11593f3bc32ee1e63b416b061c35b", "filename": "gcc/eh-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Feh-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Feh-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Feh-common.h?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -19,7 +19,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n \n /* This file contains the structures required for the language\n-   independant exception handling model. Both the static compiler and\n+   independent exception handling model. Both the static compiler and\n    the runtime library share this file. */\n \n /* The runtime flag flag_new_exceptions is used to determine whether the "}, {"sha": "6d55a155372d7baeeefad417c47399aebc0d4550", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -3494,7 +3494,7 @@ emit (x)\n    pops have previously been deferred; see INHIBIT_DEFER_POP for more\n    details), use do_pending_stack_adjust before calling this function.\n    That will ensure that the deferred pops are not accidentally\n-   emitted in the middel of this sequence.  */\n+   emitted in the middle of this sequence.  */\n \n void\n start_sequence ()"}, {"sha": "7bebfa803400904b00f9635618340fe254a80935", "filename": "gcc/flow.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -535,9 +535,10 @@ count_basic_blocks (f)\n   return count;\n }\n \n-/* Scan a list of insns for labels referrred to other than by jumps.\n+/* Scan a list of insns for labels referred to other than by jumps.\n    This is used to scan the alternatives of a call placeholder.  */\n-static rtx find_label_refs (f, lvl)\n+static rtx\n+find_label_refs (f, lvl)\n      rtx f;\n      rtx lvl;\n {\n@@ -3188,7 +3189,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \t  /* If any bits were removed from live_at_end, we'll have to\n \t     rescan the block.  This wouldn't be necessary if we had\n \t     precalculated local_live, however with PROP_SCAN_DEAD_CODE\n-\t     local_live is really dependant on live_at_end.  */\n+\t     local_live is really dependent on live_at_end.  */\n \t  CLEAR_REG_SET (tmp);\n \t  rescan = bitmap_operation (tmp, bb->global_live_at_end,\n \t\t\t\t     new_live_at_end, BITMAP_AND_COMPL);\n@@ -4554,7 +4555,7 @@ mark_regno_cond_dead (pbi, regno, cond)\n {\n   /* If this is a store to a predicate register, the value of the\n      predicate is changing, we don't know that the predicate as seen\n-     before is the same as that seen after.  Flush all dependant\n+     before is the same as that seen after.  Flush all dependent\n      conditions from reg_cond_dead.  This will make all such\n      conditionally live registers unconditionally live.  */\n   if (REGNO_REG_SET_P (pbi->reg_cond_reg, regno))\n@@ -6575,16 +6576,16 @@ verify_flow_info ()\n \f\n /* Functions to access an edge list with a vector representation.\n    Enough data is kept such that given an index number, the \n-   pred and succ that edge reprsents can be determined, or\n-   given a pred and a succ, it's index number can be returned.\n-   This allows algorithms which comsume a lot of memory to \n+   pred and succ that edge represents can be determined, or\n+   given a pred and a succ, its index number can be returned.\n+   This allows algorithms which consume a lot of memory to \n    represent the normally full matrix of edge (pred,succ) with a\n    single indexed vector,  edge (EDGE_INDEX (pred, succ)), with no\n    wasted space in the client code due to sparse flow graphs.  */\n \n /* This functions initializes the edge list. Basically the entire \n    flowgraph is processed, and all edges are assigned a number,\n-   and the data structure is filed in.  */\n+   and the data structure is filled in.  */\n struct edge_list *\n create_edge_list ()\n {\n@@ -6676,7 +6677,7 @@ print_edge_list (f, elist)\n     }\n }\n \n-/* This function provides an internal consistancy check of an edge list,\n+/* This function provides an internal consistency check of an edge list,\n    verifying that all edges are present, and that there are no \n    extra edges.  */\n void\n@@ -6904,7 +6905,7 @@ remove_fake_edges ()\n   remove_fake_successors (ENTRY_BLOCK_PTR);\n }\n \n-/* This functions will add a fake edge between any block which has no\n+/* This function will add a fake edge between any block which has no\n    successors, and the exit block. Some data flow equations require these\n    edges to exist.  */\n void"}, {"sha": "2fa3d101493a13d5fd2ec15c617218685e365f3b", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -220,7 +220,7 @@ ggc_mark_rtx_children (r)\n \t  ggc_stats->size_rtxs[(int) code] += ggc_get_size (r);\n \t}\n \n-      /* ??? If (some of) these are really pass-dependant info, do we\n+      /* ??? If (some of) these are really pass-dependent info, do we\n \t have any right poking our noses in?  */\n       switch (code)\n \t{"}, {"sha": "bee844dc9518b8aef44826c98d96a99484441713", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -4104,7 +4104,7 @@ strength_reduce (loop, insn_count, flags)\n \t\t    {\n \t\t      if (GET_CODE (next) == JUMP_INSN\n \t\t\t  || (INSN_P (next)\n-\t\t\t      && insn_dependant_p (giv_insn, next)))\n+\t\t\t      && insn_dependent_p (giv_insn, next)))\n \t\t\tbreak;\n #ifdef HAVE_cc0\n \t\t      if (! INSN_P (next)"}, {"sha": "ccf60c02cdf73ca3df3e652a31c9646f471fa488", "filename": "gcc/rtl.h", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -754,7 +754,7 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n \n /* For a MEM rtx, 1 if it refers to an aggregate, either to the\n    aggregate itself of to a field of the aggregate.  If zero, RTX may\n-   or may not be such a refrence.  */\n+   or may not be such a reference.  */\n #define MEM_IN_STRUCT_P(RTX) ((RTX)->in_struct)\n \n /* For a MEM rtx, 1 if it refers to a scalar.  If zero, RTX may or may\n@@ -1059,32 +1059,48 @@ extern rtx plus_constant_wide\t\t PARAMS ((rtx, HOST_WIDE_INT));\n extern rtx plus_constant_for_output_wide PARAMS ((rtx, HOST_WIDE_INT));\n extern void optimize_save_area_alloca\tPARAMS ((rtx));\n \n+/* In emit-rtl.c */\n extern rtx gen_rtx\t\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, ...));\n extern rtvec gen_rtvec\t\t\tPARAMS ((int, ...));\n \n+/* In other files */\n extern char *oballoc\t\t\tPARAMS ((int));\n extern char *permalloc\t\t\tPARAMS ((int));\n extern rtx rtx_alloc\t\t\tPARAMS ((RTX_CODE));\n extern rtvec rtvec_alloc\t\tPARAMS ((int));\n extern rtx copy_insn_1\t\t\tPARAMS ((rtx));\n extern rtx copy_insn\t\t\tPARAMS ((rtx));\n+\n+/* In rtl.c */\n extern rtx copy_rtx\t\t\tPARAMS ((rtx));\n+\n+/* In emit-rtl.c */\n extern rtx copy_rtx_if_shared\t\tPARAMS ((rtx));\n+\n+/* In rtl.c */\n extern rtx copy_most_rtx\t\tPARAMS ((rtx, rtx));\n extern rtx shallow_copy_rtx\t\tPARAMS ((rtx));\n extern int rtx_equal_p                  PARAMS ((rtx, rtx));\n+\n+/* In emit-rtl.c */\n extern rtvec gen_rtvec_v\t\tPARAMS ((int, rtx *));\n extern rtx gen_reg_rtx\t\t\tPARAMS ((enum machine_mode));\n extern rtx gen_label_rtx\t\tPARAMS ((void));\n extern rtx gen_lowpart_common\t\tPARAMS ((enum machine_mode, rtx));\n extern rtx gen_lowpart\t\t\tPARAMS ((enum machine_mode, rtx));\n+\n+/* In cse.c */\n extern rtx gen_lowpart_if_possible\tPARAMS ((enum machine_mode, rtx));\n+\n+/* In emit-rtl.c */\n extern rtx gen_highpart\t\t\tPARAMS ((enum machine_mode, rtx));\n extern rtx gen_realpart\t\t\tPARAMS ((enum machine_mode, rtx));\n extern rtx gen_imagpart\t\t\tPARAMS ((enum machine_mode, rtx));\n extern rtx operand_subword\t\tPARAMS ((rtx, unsigned int, int,\n \t\t\t\t\t\t enum machine_mode));\n+\n+/* In emit-rtl.c */\n extern rtx operand_subword_force\tPARAMS ((rtx, unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n extern int subreg_lowpart_p\t\tPARAMS ((rtx));\n@@ -1101,24 +1117,35 @@ extern void end_sequence\t\tPARAMS ((void));\n extern void push_to_full_sequence\tPARAMS ((rtx, rtx));\n extern void end_full_sequence\t\tPARAMS ((rtx*, rtx*));\n extern rtx gen_sequence\t\t\tPARAMS ((void));\n+\n+/* In varasm.c  */\n extern rtx immed_double_const\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode));\n extern rtx force_const_mem\t\tPARAMS ((enum machine_mode, rtx));\n+\n+/* In explow.c  */\n extern rtx force_reg\t\t\tPARAMS ((enum machine_mode, rtx));\n+\n+/* In varasm.c  */\n extern rtx get_pool_constant\t\tPARAMS ((rtx));\n extern enum machine_mode get_pool_mode\tPARAMS ((rtx));\n extern rtx get_pool_constant_for_function\tPARAMS ((struct function *, rtx));\n extern enum machine_mode get_pool_mode_for_function\tPARAMS ((struct function *, rtx));\n extern int get_pool_offset\t\tPARAMS ((rtx));\n extern rtx simplify_subtraction\t\tPARAMS ((rtx));\n+\n+/* In function.c  */\n extern rtx assign_stack_local\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t       HOST_WIDE_INT, int));\n extern rtx assign_stack_temp\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t       HOST_WIDE_INT, int));\n extern rtx assign_temp\t\t\tPARAMS ((union tree_node *,\n \t\t\t\t\t       int, int, int));\n+/* In expr.c  */\n extern rtx protect_from_queue\t\tPARAMS ((rtx, int));\n extern void emit_queue\t\t\tPARAMS ((void));\n extern rtx emit_move_insn\t\tPARAMS ((rtx, rtx));\n+\n+/* In emit-rtl.c */\n extern rtx emit_insn_before\t\tPARAMS ((rtx, rtx));\n extern rtx emit_jump_insn_before\tPARAMS ((rtx, rtx));\n extern rtx emit_call_insn_before\tPARAMS ((rtx, rtx));\n@@ -1156,41 +1183,68 @@ extern rtx prev_label\t\t\tPARAMS ((rtx));\n extern rtx next_label\t\t\tPARAMS ((rtx));\n extern rtx next_cc0_user\t\tPARAMS ((rtx));\n extern rtx prev_cc0_setter\t\tPARAMS ((rtx));\n+\n+/* In jump.c */\n extern rtx next_nondeleted_insn\t\tPARAMS ((rtx));\n extern enum rtx_code reverse_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code reverse_condition_maybe_unordered PARAMS ((enum rtx_code));\n extern enum rtx_code swap_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code unsigned_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code signed_condition\tPARAMS ((enum rtx_code));\n+\n+/* In reload.c */\n extern rtx find_equiv_reg\t\tPARAMS ((rtx, rtx, enum reg_class, int, short *, int, enum machine_mode));\n+\n+/* In jump.c */\n extern rtx squeeze_notes\t\tPARAMS ((rtx, rtx));\n extern rtx delete_insn\t\t\tPARAMS ((rtx));\n extern void delete_jump\t\t\tPARAMS ((rtx));\n extern void delete_barrier\t\tPARAMS ((rtx));\n extern rtx get_label_before\t\tPARAMS ((rtx));\n extern rtx get_label_after\t\tPARAMS ((rtx));\n extern rtx follow_jumps\t\t\tPARAMS ((rtx));\n+\n+/* In recog.c  */\n extern rtx adj_offsettable_operand\tPARAMS ((rtx, int));\n+\n+/* In emit-rtl.c  */\n extern rtx try_split\t\t\tPARAMS ((rtx, rtx, int));\n+\n+/* In unknown file  */\n extern rtx split_insns\t\t\tPARAMS ((rtx, rtx));\n+\n+/* In simplify-rtx.c  */\n extern rtx simplify_unary_operation\tPARAMS ((enum rtx_code, enum machine_mode, rtx, enum machine_mode));\n extern rtx simplify_binary_operation\tPARAMS ((enum rtx_code, enum machine_mode, rtx, rtx));\n extern rtx simplify_ternary_operation\tPARAMS ((enum rtx_code, enum machine_mode, enum machine_mode, rtx, rtx, rtx));\n extern rtx simplify_relational_operation PARAMS ((enum rtx_code, enum machine_mode, rtx, rtx));\n extern rtx simplify_gen_binary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t\t       rtx, rtx));\n extern rtx simplify_rtx\t\t\tPARAMS ((rtx));\n+\n+/* In optabs.c  */\n extern rtx gen_move_insn\t\tPARAMS ((rtx, rtx));\n+\n extern rtx gen_jump\t\t\tPARAMS ((rtx));\n extern rtx gen_beq\t\t\tPARAMS ((rtx));\n extern rtx gen_bge\t\t\tPARAMS ((rtx));\n extern rtx gen_ble\t\t\tPARAMS ((rtx));\n+\n+/* In function.c  */\n extern rtx gen_mem_addressof\t\tPARAMS ((rtx, union tree_node *));\n+\n+/* In explow.c  */\n extern rtx eliminate_constant_term\tPARAMS ((rtx, rtx *));\n+\n+/* In optabs.c */\n extern rtx expand_complex_abs\t\tPARAMS ((enum machine_mode, rtx, rtx,\n \t\t\t\t\t\t int));\n+\n+/* In regclass.c  */\n extern enum machine_mode choose_hard_reg_mode PARAMS ((unsigned int,\n \t\t\t\t\t\t       unsigned int));\n+\n+/* In emit-rtl.c  */\n extern void set_unique_reg_note         PARAMS ((rtx, enum reg_note, rtx));\n \n /* Functions in rtlanal.c */\n@@ -1210,7 +1264,7 @@ extern int modified_between_p\t\tPARAMS ((rtx, rtx, rtx));\n extern int no_labels_between_p\t\tPARAMS ((rtx, rtx));\n extern int no_jumps_between_p\t\tPARAMS ((rtx, rtx));\n extern int modified_in_p\t\tPARAMS ((rtx, rtx));\n-extern int insn_dependant_p\t\tPARAMS ((rtx, rtx));\n+extern int insn_dependent_p\t\tPARAMS ((rtx, rtx));\n extern int reg_set_p\t\t\tPARAMS ((rtx, rtx));\n extern rtx single_set\t\t\tPARAMS ((rtx));\n extern int multiple_sets\t\tPARAMS ((rtx));"}, {"sha": "e7cc12f2806d021c5313c5652245b2be7417f4f4", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb00163ad2a600403a9b36fdc7a47fd79ce98e6/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4eb00163ad2a600403a9b36fdc7a47fd79ce98e6", "patch": "@@ -26,7 +26,7 @@ Boston, MA 02111-1307, USA.  */\n \n static int rtx_addr_can_trap_p\tPARAMS ((rtx));\n static void reg_set_p_1\t\tPARAMS ((rtx, rtx, void *));\n-static void insn_dependant_p_1\tPARAMS ((rtx, rtx, void *));\n+static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n static void reg_set_last_1\tPARAMS ((rtx, rtx, void *));\n \n \n@@ -689,11 +689,11 @@ modified_in_p (x, insn)\n   return 0;\n }\n \n-/* Return true if anything in insn X is (anti,output,true) dependant on\n+/* Return true if anything in insn X is (anti,output,true) dependent on\n    anything in insn Y.  */\n \n int\n-insn_dependant_p (x, y)\n+insn_dependent_p (x, y)\n      rtx x, y;\n {\n   rtx tmp;\n@@ -702,22 +702,22 @@ insn_dependant_p (x, y)\n     abort ();\n \n   tmp = PATTERN (y);\n-  note_stores (PATTERN (x), insn_dependant_p_1, &tmp);\n+  note_stores (PATTERN (x), insn_dependent_p_1, &tmp);\n   if (tmp == NULL_RTX)\n     return 1;\n \n   tmp = PATTERN (x);\n-  note_stores (PATTERN (y), insn_dependant_p_1, &tmp);\n+  note_stores (PATTERN (y), insn_dependent_p_1, &tmp);\n   if (tmp == NULL_RTX)\n     return 1;\n \n   return 0;\n }\n \n-/* A helper routine for insn_dependant_p called through note_stores.  */\n+/* A helper routine for insn_dependent_p called through note_stores.  */\n \n static void\n-insn_dependant_p_1 (x, pat, data)\n+insn_dependent_p_1 (x, pat, data)\n      rtx x;\n      rtx pat ATTRIBUTE_UNUSED;\n      void *data;\n@@ -2113,7 +2113,7 @@ jmp_uses_reg_or_mem (x)\n /* Return nonzero if INSN is an indirect jump (aka computed jump).\n \n    Tablejumps and casesi insns are not considered indirect jumps;\n-   we can recognize them by a (use (lael_ref)).  */\n+   we can recognize them by a (use (label_ref)).  */\n \n int\n computed_jump_p (insn)"}]}