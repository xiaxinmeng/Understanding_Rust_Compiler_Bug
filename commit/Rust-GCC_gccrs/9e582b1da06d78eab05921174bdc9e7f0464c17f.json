{"sha": "9e582b1da06d78eab05921174bdc9e7f0464c17f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU1ODJiMWRhMDZkNzhlYWIwNTkyMTE3NGJkYzllN2YwNDY0YzE3Zg==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2011-11-06T22:58:54Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2011-11-06T22:58:54Z"}, "message": "regset.h (fixed_reg_set_regset): Declare.\n\n        * regset.h (fixed_reg_set_regset): Declare.\n        * dse.c: Include regset.h .\n        (struct insn_info): Add member fixed_regs_live.\n        (note_add_store_info): New typedef.\n        (note_add_store): New function.\n        (emit_inc_dec_insn_before): Expect arg to be of type insn_info_t .\n        Use gen_add3_insn / gen_move_insn.\n        Check new insn for unwanted clobbers before emitting it.\n        (check_for_inc_dec): Rename to...\n        (check_for_inc_dec_1:) ... this.  Return bool.  Take insn_info\n        parameter.  Changed all callers in file.\n        (check_for_inc_dec, copy_fixed_regs): New functions.\n        (scan_insn): Set fixed_regs_live field of insn_info.\n        * rtl.h (check_for_inc_dec): Update prototype.\n        * postreload.c (reload_cse_simplify): Take new signature of\n        check_ind_dec into account.\n        * reginfo.c (fixed_reg_set_regset): New variable.\n        (init_reg_sets_1): Initialize it.\n\nCo-Authored-By: Eric Botcazou <ebotcazou@adacore.com>\n\nFrom-SVN: r181046", "tree": {"sha": "292c99c70f3521110cea26b4cb276bbfa0bbdc77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/292c99c70f3521110cea26b4cb276bbfa0bbdc77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e582b1da06d78eab05921174bdc9e7f0464c17f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e582b1da06d78eab05921174bdc9e7f0464c17f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e582b1da06d78eab05921174bdc9e7f0464c17f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e582b1da06d78eab05921174bdc9e7f0464c17f/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57899d2fc591789a7ef0839d6e38e954a5f494e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57899d2fc591789a7ef0839d6e38e954a5f494e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57899d2fc591789a7ef0839d6e38e954a5f494e0"}], "stats": {"total": 192, "additions": 166, "deletions": 26}, "files": [{"sha": "0a6059a3d0fd8d96f678884d23687086f7089240", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e582b1da06d78eab05921174bdc9e7f0464c17f", "patch": "@@ -1,3 +1,25 @@\n+2011-11-06  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* regset.h (fixed_reg_set_regset): Declare.\n+\t* dse.c: Include regset.h .\n+\t(struct insn_info): Add member fixed_regs_live.\n+\t(note_add_store_info): New typedef.\n+\t(note_add_store): New function.\n+\t(emit_inc_dec_insn_before): Expect arg to be of type insn_info_t .\n+\tUse gen_add3_insn / gen_move_insn.\n+\tCheck new insn for unwanted clobbers before emitting it.\n+\t(check_for_inc_dec): Rename to...\n+\t(check_for_inc_dec_1:) ... this.  Return bool.  Take insn_info\n+\tparameter.  Changed all callers in file.\n+\t(check_for_inc_dec, copy_fixed_regs): New functions.\n+\t(scan_insn): Set fixed_regs_live field of insn_info.\n+\t* rtl.h (check_for_inc_dec): Update prototype.\n+\t* postreload.c (reload_cse_simplify): Take new signature of\n+\tcheck_ind_dec into account.\n+\t* reginfo.c (fixed_reg_set_regset): New variable.\n+\t(init_reg_sets_1): Initialize it.\n+\n 2011-11-06  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-cfg.c (gimple_can_merge_blocks_p): For -O0 don't remove"}, {"sha": "ddabd3de0c6a86dd9536595df8268184542696e4", "filename": "gcc/dse.c", "status": "modified", "additions": 123, "deletions": 18, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=9e582b1da06d78eab05921174bdc9e7f0464c17f", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n+#include \"regset.h\"\n #include \"flags.h\"\n #include \"df.h\"\n #include \"cselib.h\"\n@@ -377,6 +378,13 @@ struct insn_info\n      created.  */\n   read_info_t read_rec;\n \n+  /* The live fixed registers.  We assume only fixed registers can\n+     cause trouble by being clobbered from an expanded pattern;\n+     storing only the live fixed registers (rather than all registers)\n+     means less memory needs to be allocated / copied for the individual\n+     stores.  */\n+  regset fixed_regs_live;\n+\n   /* The prev insn in the basic block.  */\n   struct insn_info * prev_insn;\n \n@@ -448,9 +456,9 @@ struct bb_info\n   /* The following bitvector is indexed by the reg number.  It\n      contains the set of regs that are live at the current instruction\n      being processed.  While it contains info for all of the\n-     registers, only the pseudos are actually examined.  It is used to\n-     assure that shift sequences that are inserted do not accidently\n-     clobber live hard regs.  */\n+     registers, only the hard registers are actually examined.  It is used\n+     to assure that shift and/or add sequences that are inserted do not\n+     accidently clobber live hard regs.  */\n   bitmap regs_live;\n };\n \n@@ -827,6 +835,51 @@ free_store_info (insn_info_t insn_info)\n   insn_info->store_rec = NULL;\n }\n \n+typedef struct\n+{\n+  rtx first, current;\n+  regset fixed_regs_live;\n+  bool failure;\n+} note_add_store_info;\n+\n+/* Callback for emit_inc_dec_insn_before via note_stores.\n+   Check if a register is clobbered which is live afterwards.  */\n+\n+static void\n+note_add_store (rtx loc, const_rtx expr ATTRIBUTE_UNUSED, void *data)\n+{\n+  rtx insn;\n+  note_add_store_info *info = (note_add_store_info *) data;\n+  int r, n;\n+\n+  if (!REG_P (loc))\n+    return;\n+\n+  /* If this register is referenced by the current or an earlier insn,\n+     that's OK.  E.g. this applies to the register that is being incremented\n+     with this addition.  */\n+  for (insn = info->first;\n+       insn != NEXT_INSN (info->current);\n+       insn = NEXT_INSN (insn))\n+    if (reg_referenced_p (loc, PATTERN (insn)))\n+      return;\n+\n+  /* If we come here, we have a clobber of a register that's only OK\n+     if that register is not live.  If we don't have liveness information\n+     available, fail now.  */\n+  if (!info->fixed_regs_live)\n+    {\n+      info->failure =  true;\n+      return;\n+    }\n+  /* Now check if this is a live fixed register.  */\n+  r = REGNO (loc);\n+  n = hard_regno_nregs[r][GET_MODE (loc)];\n+  while (--n >=  0)\n+    if (REGNO_REG_SET_P (info->fixed_regs_live, r+n))\n+      info->failure =  true;\n+}\n+\n /* Callback for for_each_inc_dec that emits an INSN that sets DEST to\n    SRC + SRCOFF before insn ARG.  */\n \n@@ -835,31 +888,68 @@ emit_inc_dec_insn_before (rtx mem ATTRIBUTE_UNUSED,\n \t\t\t  rtx op ATTRIBUTE_UNUSED,\n \t\t\t  rtx dest, rtx src, rtx srcoff, void *arg)\n {\n-  rtx insn = (rtx)arg;\n-\n-  if (srcoff)\n-    src = gen_rtx_PLUS (GET_MODE (src), src, srcoff);\n+  insn_info_t insn_info = (insn_info_t) arg;\n+  rtx insn = insn_info->insn, new_insn, cur;\n+  note_add_store_info info;\n \n   /* We can reuse all operands without copying, because we are about\n      to delete the insn that contained it.  */\n+  if (srcoff)\n+    new_insn = gen_add3_insn (dest, src, srcoff);\n+  else\n+    new_insn = gen_move_insn (dest, src);\n+  info.first = new_insn;\n+  info.fixed_regs_live = insn_info->fixed_regs_live;\n+  info.failure = false;\n+  for (cur = new_insn; cur; cur = NEXT_INSN (cur))\n+    {\n+      info.current = cur;\n+      note_stores (PATTERN (cur), note_add_store, &info);\n+    }\n \n-  emit_insn_before (gen_rtx_SET (VOIDmode, dest, src), insn);\n+  /* If a failure was flagged above, return 1 so that for_each_inc_dec will\n+     return it immediately, communicating the failure to its caller.  */\n+  if (info.failure)\n+    return 1;\n+\n+  emit_insn_before (new_insn, insn);\n \n   return -1;\n }\n \n-/* Before we delete INSN, make sure that the auto inc/dec, if it is\n-   there, is split into a separate insn.  */\n+/* Before we delete INSN_INFO->INSN, make sure that the auto inc/dec, if it\n+   is there, is split into a separate insn.\n+   Return true on success (or if there was nothing to do), false on failure.  */\n \n-void\n-check_for_inc_dec (rtx insn)\n+static bool\n+check_for_inc_dec_1 (insn_info_t insn_info)\n {\n+  rtx insn = insn_info->insn;\n   rtx note = find_reg_note (insn, REG_INC, NULL_RTX);\n   if (note)\n-    for_each_inc_dec (&insn, emit_inc_dec_insn_before, insn);\n+    return for_each_inc_dec (&insn, emit_inc_dec_insn_before, insn_info) == 0;\n+  return true;\n }\n \n \n+/* Entry point for postreload.  If you work on reload_cse, or you need this\n+   anywhere else, consider if you can provide register liveness information\n+   and add a parameter to this function so that it can be passed down in\n+   insn_info.fixed_regs_live.  */\n+bool\n+check_for_inc_dec (rtx insn)\n+{\n+  struct insn_info insn_info;\n+  rtx note;\n+\n+  insn_info.insn = insn;\n+  insn_info.fixed_regs_live = NULL;\n+  note = find_reg_note (insn, REG_INC, NULL_RTX);\n+  if (note)\n+    return for_each_inc_dec (&insn, emit_inc_dec_insn_before, &insn_info) == 0;\n+  return true;\n+}\n+\n /* Delete the insn and free all of the fields inside INSN_INFO.  */\n \n static void\n@@ -870,7 +960,8 @@ delete_dead_store_insn (insn_info_t insn_info)\n   if (!dbg_cnt (dse))\n     return;\n \n-  check_for_inc_dec (insn_info->insn);\n+  if (!check_for_inc_dec_1 (insn_info))\n+    return;\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Locally deleting insn %d \",\n@@ -2375,6 +2466,17 @@ get_call_args (rtx call_insn, tree fn, rtx *args, int nargs)\n   return true;\n }\n \n+/* Return a bitmap of the fixed registers contained in IN.  */\n+\n+static bitmap\n+copy_fixed_regs (const_bitmap in)\n+{\n+  bitmap ret;\n+\n+  ret = ALLOC_REG_SET (NULL);\n+  bitmap_and (ret, in, fixed_reg_set_regset);\n+  return ret;\n+}\n \n /* Apply record_store to all candidate stores in INSN.  Mark INSN\n    if some part of it is not a candidate store and assigns to a\n@@ -2529,6 +2631,8 @@ scan_insn (bb_info_t bb_info, rtx insn)\n \t\t\t  active_local_stores_len = 1;\n \t\t\t  active_local_stores = NULL;\n \t\t\t}\n+\t\t      insn_info->fixed_regs_live\n+\t\t\t= copy_fixed_regs (bb_info->regs_live);\n \t\t      insn_info->next_local_store = active_local_stores;\n \t\t      active_local_stores = insn_info;\n \t\t    }\n@@ -2579,6 +2683,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n \t  active_local_stores_len = 1;\n \t  active_local_stores = NULL;\n \t}\n+      insn_info->fixed_regs_live = copy_fixed_regs (bb_info->regs_live);\n       insn_info->next_local_store = active_local_stores;\n       active_local_stores = insn_info;\n     }\n@@ -3622,9 +3727,9 @@ dse_step5_nospill (void)\n \t\t}\n \t      if (deleted)\n \t\t{\n-\t\t  if (dbg_cnt (dse))\n+\t\t  if (dbg_cnt (dse)\n+\t\t      && check_for_inc_dec_1 (insn_info))\n \t\t    {\n-\t\t      check_for_inc_dec (insn_info->insn);\n \t\t      delete_insn (insn_info->insn);\n \t\t      insn_info->insn = NULL;\n \t\t      globally_deleted++;\n@@ -3702,12 +3807,12 @@ dse_step5_spill (void)\n \t\t    deleted = false;\n \t\t  store_info = store_info->next;\n \t\t}\n-\t      if (deleted && dbg_cnt (dse))\n+\t      if (deleted && dbg_cnt (dse)\n+\t\t  && check_for_inc_dec_1 (insn_info))\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Spill deleting insn %d\\n\",\n \t\t\t     INSN_UID (insn_info->insn));\n-\t\t  check_for_inc_dec (insn_info->insn);\n \t\t  delete_insn (insn_info->insn);\n \t\t  spill_deleted++;\n \t\t  insn_info->insn = NULL;"}, {"sha": "886d024926cd582fc69377293b3e86a37f4a2f0c", "filename": "gcc/postreload.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=9e582b1da06d78eab05921174bdc9e7f0464c17f", "patch": "@@ -112,8 +112,8 @@ reload_cse_simplify (rtx insn, rtx testreg)\n \t  if (REG_P (value)\n \t      && ! REG_FUNCTION_VALUE_P (value))\n \t    value = 0;\n-\t  check_for_inc_dec (insn);\n-\t  delete_insn_and_edges (insn);\n+\t  if (check_for_inc_dec (insn))\n+\t    delete_insn_and_edges (insn);\n \t  return;\n \t}\n \n@@ -164,8 +164,8 @@ reload_cse_simplify (rtx insn, rtx testreg)\n \n       if (i < 0)\n \t{\n-\t  check_for_inc_dec (insn);\n-\t  delete_insn_and_edges (insn);\n+\t  if (check_for_inc_dec (insn))\n+\t    delete_insn_and_edges (insn);\n \t  /* We're done with this insn.  */\n \t  return;\n \t}"}, {"sha": "e9bf65f300342cb16c4db2b20dc1324c7ef3bd79", "filename": "gcc/reginfo.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=9e582b1da06d78eab05921174bdc9e7f0464c17f", "patch": "@@ -1,7 +1,7 @@\n /* Compute different info about registers.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996\n    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010  Free Software Foundation, Inc.\n+   2009, 2010, 2011  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -94,6 +94,9 @@ static tree GTY(()) global_regs_decl[FIRST_PSEUDO_REGISTER];\n    in dataflow more conveniently.  */\n regset regs_invalidated_by_call_regset;\n \n+/* Same information as FIXED_REG_SET but in regset form.  */\n+regset fixed_reg_set_regset;\n+\n /* The bitmap_obstack is used to hold some static variables that\n    should not be reset after each function is compiled.  */\n static bitmap_obstack persistent_obstack;\n@@ -451,6 +454,10 @@ init_reg_sets_1 (void)\n     }\n   else\n     CLEAR_REG_SET (regs_invalidated_by_call_regset);\n+  if (!fixed_reg_set_regset)\n+    fixed_reg_set_regset = ALLOC_REG_SET (&persistent_obstack);\n+  else\n+    CLEAR_REG_SET (fixed_reg_set_regset);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -462,7 +469,10 @@ init_reg_sets_1 (void)\n #endif\n \n       if (fixed_regs[i])\n-\tSET_HARD_REG_BIT (fixed_reg_set, i);\n+\t{\n+\t  SET_HARD_REG_BIT (fixed_reg_set, i);\n+\t  SET_REGNO_REG_SET (fixed_reg_set_regset, i);\n+\t}\n \n       if (call_used_regs[i])\n \tSET_HARD_REG_BIT (call_used_reg_set, i);"}, {"sha": "af807b03597382fac3fd955ede348e6222f66bca", "filename": "gcc/regset.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Fregset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Fregset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregset.h?ref=9e582b1da06d78eab05921174bdc9e7f0464c17f", "patch": "@@ -1,6 +1,6 @@\n /* Define regsets.\n    Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -115,6 +115,9 @@ typedef bitmap_iterator reg_set_iterator;\n \n extern regset regs_invalidated_by_call_regset;\n \n+/* Same information as FIXED_REG_SET but in regset form.  */\n+extern regset fixed_reg_set_regset;\n+\n /* An obstack for regsets.  */\n extern bitmap_obstack reg_obstack;\n "}, {"sha": "fd3e3ef641e59cfed21fd764d49f43969b17e178", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e582b1da06d78eab05921174bdc9e7f0464c17f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9e582b1da06d78eab05921174bdc9e7f0464c17f", "patch": "@@ -2396,7 +2396,7 @@ extern int exp_equiv_p (const_rtx, const_rtx, int, bool);\n extern unsigned hash_rtx (const_rtx x, enum machine_mode, int *, int *, bool);\n \n /* In dse.c */\n-extern void check_for_inc_dec (rtx insn);\n+extern bool check_for_inc_dec (rtx insn);\n \n /* In jump.c */\n extern int comparison_dominates_p (enum rtx_code, enum rtx_code);"}]}