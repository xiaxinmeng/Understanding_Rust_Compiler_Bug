{"sha": "932198a8e1b6ab26201a265ced3a8c4802304146", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMyMTk4YThlMWI2YWIyNjIwMWEyNjVjZWQzYThjNDgwMjMwNDE0Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-21T08:45:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-21T08:45:21Z"}, "message": "Always translate Is_Pure flag into pure in C sense\n\nGigi has historically translated the Is_Pure flag of the front-end into\nthe \"const\" attribute of GNU C.  That's correct for subprograms of pure\nAda units, but not fully exact according to the semantics of the flag.\n\ngcc/ada/\n\t* gcc-interface/decl.c (gnat_to_gnu_subprog_type): Always translate\n\tthe Is_Pure flag into the \"pure\" attribute of GNU C.", "tree": {"sha": "5616d6238ac30801ccfdcf53ad58ed699ffde584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5616d6238ac30801ccfdcf53ad58ed699ffde584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/932198a8e1b6ab26201a265ced3a8c4802304146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932198a8e1b6ab26201a265ced3a8c4802304146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/932198a8e1b6ab26201a265ced3a8c4802304146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932198a8e1b6ab26201a265ced3a8c4802304146/comments", "author": null, "committer": null, "parents": [{"sha": "1e66a9170071aded59dda09ac437757de4223346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e66a9170071aded59dda09ac437757de4223346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e66a9170071aded59dda09ac437757de4223346"}], "stats": {"total": 44, "additions": 19, "deletions": 25}, "files": [{"sha": "19e851ff712acd9d00e8de29e54a1ff73f8f9615", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932198a8e1b6ab26201a265ced3a8c4802304146/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932198a8e1b6ab26201a265ced3a8c4802304146/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=932198a8e1b6ab26201a265ced3a8c4802304146", "patch": "@@ -5737,16 +5737,16 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n   tree gnu_cico_return_type = NULL_TREE;\n   tree gnu_cico_field_list = NULL_TREE;\n   bool gnu_cico_only_integral_type = true;\n-  /* The semantics of \"pure\" in Ada essentially matches that of \"const\"\n-     or \"pure\" in GCC.  In particular, both properties are orthogonal\n-     to the \"nothrow\" property if the EH circuitry is explicit in the\n-     internal representation of the middle-end.  If we are to completely\n-     hide the EH circuitry from it, we need to declare that calls to pure\n-     Ada subprograms that can throw have side effects since they can\n-     trigger an \"abnormal\" transfer of control flow; therefore, they can\n-     be neither \"const\" nor \"pure\" in the GCC sense.  */\n-  bool const_flag = (Back_End_Exceptions () && Is_Pure (gnat_subprog));\n-  bool pure_flag = false;\n+  /* Although the semantics of \"pure\" units in Ada essentially match those of\n+     \"const\" in GNU C, the semantics of the Is_Pure flag in GNAT do not say\n+     anything about access to global memory, that's why it needs to be mapped\n+     to \"pure\" instead of \"const\" in GNU C.  The property is orthogonal to the\n+     \"nothrow\" property only if the EH circuitry is explicit in the internal\n+     representation of the middle-end: if we are to completely hide the EH\n+     circuitry from it, we need to declare that calls to pure Ada subprograms\n+     that can throw have side effects, since they can trigger an \"abnormal\"\n+     transfer of control; therefore they cannot be \"pure\" in the GCC sense.  */\n+  bool pure_flag = Is_Pure (gnat_subprog) && Back_End_Exceptions ();\n   bool return_by_direct_ref_p = false;\n   bool return_by_invisi_ref_p = false;\n   bool return_unconstrained_p = false;\n@@ -5899,14 +5899,14 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n     }\n \n   /* A procedure (something that doesn't return anything) shouldn't be\n-     considered const since there would be no reason for calling such a\n+     considered pure since there would be no reason for calling such a\n      subprogram.  Note that procedures with Out (or In Out) parameters\n      have already been converted into a function with a return type.\n      Similarly, if the function returns an unconstrained type, then the\n      function will allocate the return value on the secondary stack and\n      thus calls to it cannot be CSE'ed, lest the stack be reclaimed.  */\n   if (VOID_TYPE_P (gnu_return_type) || return_unconstrained_p)\n-    const_flag = false;\n+    pure_flag = false;\n \n   /* Loop over the parameters and get their associated GCC tree.  While doing\n      this, build a copy-in copy-out structure if we need one.  */\n@@ -6034,19 +6034,16 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t  save_gnu_tree (gnat_param, gnu_param, false);\n \n \t  /* A pure function in the Ada sense which takes an access parameter\n-\t     may modify memory through it and thus need be considered neither\n-\t     const nor pure in the GCC sense, unless it's access-to-function.\n-\t     Likewise it if takes a by-ref In Out or Out parameter.  But if it\n-\t     takes a by-ref In parameter, then it may only read memory through\n-\t     it and can be considered pure in the GCC sense.  */\n-\t  if ((const_flag || pure_flag)\n+\t     may modify memory through it and thus cannot be considered pure\n+\t     in the GCC sense, unless it's access-to-function.  Likewise it if\n+\t     takes a by-ref In Out or Out parameter.  But if it takes a by-ref\n+\t     In parameter, then it may only read memory through it and can be\n+\t     considered pure in the GCC sense.  */\n+\t  if (pure_flag\n \t      && ((POINTER_TYPE_P (gnu_param_type)\n \t\t   && TREE_CODE (TREE_TYPE (gnu_param_type)) != FUNCTION_TYPE)\n \t\t  || TYPE_IS_FAT_POINTER_P (gnu_param_type)))\n-\t    {\n-\t      const_flag = false;\n-\t      pure_flag = DECL_POINTS_TO_READONLY_P (gnu_param);\n-\t    }\n+\t    pure_flag = DECL_POINTS_TO_READONLY_P (gnu_param);\n \t}\n \n       /* If the parameter uses the copy-in copy-out mechanism, allocate a field\n@@ -6246,9 +6243,6 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t    }\n \t}\n \n-      if (const_flag)\n-\tgnu_type = change_qualified_type (gnu_type, TYPE_QUAL_CONST);\n-\n       if (pure_flag)\n \tgnu_type = change_qualified_type (gnu_type, TYPE_QUAL_RESTRICT);\n "}]}