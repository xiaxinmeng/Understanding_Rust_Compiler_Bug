{"sha": "2b0bd71482ce011ac9c399534feb9c62a7d75a80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIwYmQ3MTQ4MmNlMDExYWM5YzM5OTUzNGZlYjljNjJhN2Q3NWE4MA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael.morin@tele2.fr", "date": "2008-11-16T22:45:10Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2008-11-16T22:45:10Z"}, "message": "re PR fortran/35681 (wrong result for vector subscripted array expression in MVBITS)\n\n2008-11-16  Mikael Morin <mikael.morin@tele2.fr>\n\n\tPR fortran/35681\n\t* dependency.c (gfc_check_argument_var_dependency): Add\n\telemental check flag. Issue a warning if we find a dependency\n\tbut don't generate a temporary. Add the case of an elemental\n\tfunction call as actual argument to an elemental procedure.\n\tAdd the case of an operator expression as actual argument\n\tto an elemental procedure.\n\t(gfc_check_argument_dependency): Add elemental check flag.\n\tUpdate calls to gfc_check_argument_var_dependency.\n\t(gfc_check_fncall_dependency): Add elemental check flag.\n\tUpdate call to gfc_check_argument_dependency.\n\t* trans-stmt.c (gfc_trans_call): Make call to\n\tgfc_conv_elemental_dependency unconditional, but with a flag\n\twhether we should check dependencies between variables.\n\t(gfc_conv_elemental_dependency): Add elemental check flag.\n\tUpdate call to gfc_check_fncall_dependency.\n\t* trans-expr.c (gfc_trans_arrayfunc_assign): Update call to\n\tgfc_check_fncall_dependency.\n\t* resolve.c (find_noncopying_intrinsics): Update call to\n\tgfc_check_fncall_dependency.\n\t* dependency.h (enum gfc_dep_check): New enum.\n\t(gfc_check_fncall_dependency): Update prototype.\n\n2008-11-16  Mikael Morin <mikael.morin@tele2.fr>\n\n\tPR fortran/35681\n\t* gfortran.dg/elemental_dependency_1.f90: New test.\n\nFrom-SVN: r141931", "tree": {"sha": "232858a8b76bd4730269441ec98967c72d4e5605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/232858a8b76bd4730269441ec98967c72d4e5605"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b0bd71482ce011ac9c399534feb9c62a7d75a80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0bd71482ce011ac9c399534feb9c62a7d75a80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b0bd71482ce011ac9c399534feb9c62a7d75a80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0bd71482ce011ac9c399534feb9c62a7d75a80/comments", "author": null, "committer": null, "parents": [{"sha": "d3ea650c44d79a7ba10ec2964cf2bfd707c7b396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ea650c44d79a7ba10ec2964cf2bfd707c7b396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ea650c44d79a7ba10ec2964cf2bfd707c7b396"}], "stats": {"total": 150, "additions": 128, "deletions": 22}, "files": [{"sha": "69d8df28def9312eea8cee82e883a393dadf5c33", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2b0bd71482ce011ac9c399534feb9c62a7d75a80", "patch": "@@ -1,3 +1,28 @@\n+2008-11-16  Mikael Morin <mikael.morin@tele2.fr>\n+\n+\tPR fortran/35681\n+\t* dependency.c (gfc_check_argument_var_dependency): Add\n+\telemental check flag. Issue a warning if we find a dependency\n+\tbut don't generate a temporary. Add the case of an elemental\n+\tfunction call as actual argument to an elemental procedure.\n+\tAdd the case of an operator expression as actual argument\n+\tto an elemental procedure.\n+\t(gfc_check_argument_dependency): Add elemental check flag.\n+\tUpdate calls to gfc_check_argument_var_dependency.\n+\t(gfc_check_fncall_dependency): Add elemental check flag.\n+\tUpdate call to gfc_check_argument_dependency.\n+\t* trans-stmt.c (gfc_trans_call): Make call to\n+\tgfc_conv_elemental_dependency unconditional, but with a flag\n+\twhether we should check dependencies between variables.\n+\t(gfc_conv_elemental_dependency): Add elemental check flag.\n+\tUpdate call to gfc_check_fncall_dependency.\n+\t* trans-expr.c (gfc_trans_arrayfunc_assign): Update call to\n+\tgfc_check_fncall_dependency.\n+\t* resolve.c (find_noncopying_intrinsics): Update call to\n+\tgfc_check_fncall_dependency.\n+\t* dependency.h (enum gfc_dep_check): New enum.\n+\t(gfc_check_fncall_dependency): Update prototype.\n+\n 2008-11-16  Mikael Morin  <mikael.morin@tele2.fr>\n \n \tPR fortran/37992"}, {"sha": "cd768becb8aa47d3ec1dc0201366750409842509", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 69, "deletions": 11, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=2b0bd71482ce011ac9c399534feb9c62a7d75a80", "patch": "@@ -432,25 +432,81 @@ gfc_ref_needs_temporary_p (gfc_ref *ref)\n \n static int\n gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n-\t\t\t\t   gfc_expr *expr)\n+\t\t\t\t   gfc_expr *expr, gfc_dep_check elemental)\n {\n+  gfc_expr *arg;\n+\n   gcc_assert (var->expr_type == EXPR_VARIABLE);\n   gcc_assert (var->rank > 0);\n \n   switch (expr->expr_type)\n     {\n     case EXPR_VARIABLE:\n-      return (gfc_ref_needs_temporary_p (expr->ref)\n-\t      || gfc_check_dependency (var, expr, 1));\n+      /* In case of elemental subroutines, there is no dependency \n+         between two same-range array references.  */\n+      if (gfc_ref_needs_temporary_p (expr->ref)\n+\t  || gfc_check_dependency (var, expr, !elemental))\n+\t{\n+\t  if (elemental == ELEM_DONT_CHECK_VARIABLE)\n+\t    {\n+\t      /* Elemental procedures forbid unspecified intents, \n+\t\t and we don't check dependencies for INTENT_IN args.  */\n+\t      gcc_assert (intent == INTENT_OUT || intent == INTENT_INOUT);\n+\n+\t      /* We are told not to check dependencies. \n+\t\t We do it, however, and issue a warning in case we find one. \n+\t\t If a dependency is found in the case \n+\t\t elemental == ELEM_CHECK_VARIABLE, we will generate\n+\t\t a temporary, so we don't need to bother the user.  */\n+\t      gfc_warning (\"INTENT(%s) actual argument at %L might interfere \"\n+\t\t\t   \"with actual argument at %L.\", \n+\t\t\t   intent == INTENT_OUT ? \"OUT\" : \"INOUT\", \n+\t\t\t   &var->where, &expr->where);\n+\t      return 0;\n+\t    }\n+\t  else\n+\t    return 1; \n+\t}\n+      return 0;\n \n     case EXPR_ARRAY:\n       return gfc_check_dependency (var, expr, 1);\n \n     case EXPR_FUNCTION:\n-      if (intent != INTENT_IN && expr->inline_noncopying_intrinsic)\n+      if (intent != INTENT_IN && expr->inline_noncopying_intrinsic\n+\t  && (arg = gfc_get_noncopying_intrinsic_argument (expr))\n+\t  && gfc_check_argument_var_dependency (var, intent, arg, elemental))\n+\treturn 1;\n+      if (elemental)\n \t{\n-\t  expr = gfc_get_noncopying_intrinsic_argument (expr);\n-\t  return gfc_check_argument_var_dependency (var, intent, expr);\n+\t  if ((expr->value.function.esym\n+\t       && expr->value.function.esym->attr.elemental)\n+\t      || (expr->value.function.isym\n+\t\t  && expr->value.function.isym->elemental))\n+\t    return gfc_check_fncall_dependency (var, intent, NULL,\n+\t\t\t\t\t\texpr->value.function.actual,\n+\t\t\t\t\t\tELEM_CHECK_VARIABLE);\n+\t}\n+      return 0;\n+\n+    case EXPR_OP:\n+      /* In case of non-elemental procedures, there is no need to catch\n+\t dependencies, as we will make a temporary anyway.  */\n+      if (elemental)\n+\t{\n+\t  /* If the actual arg EXPR is an expression, we need to catch \n+\t     a dependency between variables in EXPR and VAR, \n+\t     an intent((IN)OUT) variable.  */\n+\t  if (expr->value.op.op1\n+\t      && gfc_check_argument_var_dependency (var, intent, \n+\t\t\t\t\t\t    expr->value.op.op1, \n+\t\t\t\t\t\t    ELEM_CHECK_VARIABLE))\n+\t    return 1;\n+\t  else if (expr->value.op.op2\n+\t\t   && gfc_check_argument_var_dependency (var, intent, \n+\t\t\t\t\t\t\t expr->value.op.op2, \n+\t\t\t\t\t\t\t ELEM_CHECK_VARIABLE))\n+\t    return 1;\n \t}\n       return 0;\n \n@@ -465,18 +521,19 @@ gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n \n static int\n gfc_check_argument_dependency (gfc_expr *other, sym_intent intent,\n-\t\t\t       gfc_expr *expr)\n+\t\t\t       gfc_expr *expr, gfc_dep_check elemental)\n {\n   switch (other->expr_type)\n     {\n     case EXPR_VARIABLE:\n-      return gfc_check_argument_var_dependency (other, intent, expr);\n+      return gfc_check_argument_var_dependency (other, intent, expr, elemental);\n \n     case EXPR_FUNCTION:\n       if (other->inline_noncopying_intrinsic)\n \t{\n \t  other = gfc_get_noncopying_intrinsic_argument (other);\n-\t  return gfc_check_argument_dependency (other, INTENT_IN, expr);\n+\t  return gfc_check_argument_dependency (other, INTENT_IN, expr, \n+\t\t\t\t\t\telemental);\n \t}\n       return 0;\n \n@@ -491,7 +548,8 @@ gfc_check_argument_dependency (gfc_expr *other, sym_intent intent,\n \n int\n gfc_check_fncall_dependency (gfc_expr *other, sym_intent intent,\n-\t\t\t     gfc_symbol *fnsym, gfc_actual_arglist *actual)\n+\t\t\t     gfc_symbol *fnsym, gfc_actual_arglist *actual,\n+\t\t\t     gfc_dep_check elemental)\n {\n   gfc_formal_arglist *formal;\n   gfc_expr *expr;\n@@ -514,7 +572,7 @@ gfc_check_fncall_dependency (gfc_expr *other, sym_intent intent,\n \t  && formal->sym->attr.intent == INTENT_IN)\n \tcontinue;\n \n-      if (gfc_check_argument_dependency (other, intent, expr))\n+      if (gfc_check_argument_dependency (other, intent, expr, elemental))\n \treturn 1;\n     }\n "}, {"sha": "1920c558c983164b2f9c8d841469cb9c9351a40e", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=2b0bd71482ce011ac9c399534feb9c62a7d75a80", "patch": "@@ -19,13 +19,24 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/****************************** Enums *********************************/\n+typedef enum\n+{\n+  NOT_ELEMENTAL,        /* Not elemental case: normal dependency check.  */\n+  ELEM_CHECK_VARIABLE,  /* Test whether variables overlap.  */\n+  ELEM_DONT_CHECK_VARIABLE  /* Test whether variables overlap only if used \n+\t\t\t       in an expression.  */\n+}\n+gfc_dep_check;\n \n \n+/*********************** Functions prototypes **************************/\n+\n bool gfc_ref_needs_temporary_p (gfc_ref *);\n bool gfc_full_array_ref_p (gfc_ref *);\n gfc_expr *gfc_get_noncopying_intrinsic_argument (gfc_expr *);\n int gfc_check_fncall_dependency (gfc_expr *, sym_intent, gfc_symbol *,\n-\t\t\t\t gfc_actual_arglist *);\n+\t\t\t\t gfc_actual_arglist *, gfc_dep_check);\n int gfc_check_dependency (gfc_expr *, gfc_expr *, bool);\n int gfc_is_same_range (gfc_array_ref *, gfc_array_ref *, int, int);\n int gfc_expr_is_one (gfc_expr *, int);"}, {"sha": "e4766d6de563239f9b2d8cdbbb8a4aafdde06c18", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=2b0bd71482ce011ac9c399534feb9c62a7d75a80", "patch": "@@ -1491,7 +1491,8 @@ find_noncopying_intrinsics (gfc_symbol *fnsym, gfc_actual_arglist *actual)\n   for (ap = actual; ap; ap = ap->next)\n     if (ap->expr\n \t&& (expr = gfc_get_noncopying_intrinsic_argument (ap->expr))\n-\t&& !gfc_check_fncall_dependency (expr, INTENT_IN, fnsym, actual))\n+\t&& !gfc_check_fncall_dependency (expr, INTENT_IN, fnsym, actual,\n+\t\t\t\t\t NOT_ELEMENTAL))\n       ap->expr->inline_noncopying_intrinsic = 1;\n }\n "}, {"sha": "e096021259b55d129349b7605c119383eece7006", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=2b0bd71482ce011ac9c399534feb9c62a7d75a80", "patch": "@@ -4288,7 +4288,8 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   /* Check for a dependency.  */\n   if (gfc_check_fncall_dependency (expr1, INTENT_OUT,\n \t\t\t\t   expr2->value.function.esym,\n-\t\t\t\t   expr2->value.function.actual))\n+\t\t\t\t   expr2->value.function.actual,\n+\t\t\t\t   NOT_ELEMENTAL))\n     return NULL;\n \n   /* The frontend doesn't seem to bother filling in expr->symtree for intrinsic"}, {"sha": "9505dfb67ebbd9f585c59623b072ecb4ef6167c1", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=2b0bd71482ce011ac9c399534feb9c62a7d75a80", "patch": "@@ -201,7 +201,8 @@ gfc_trans_entry (gfc_code * code)\n    can be used, as is, to copy the result back to the variable.  */\n static void\n gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n-\t\t\t\t gfc_symbol * sym, gfc_actual_arglist * arg)\n+\t\t\t\t gfc_symbol * sym, gfc_actual_arglist * arg,\n+\t\t\t\t gfc_dep_check check_variable)\n {\n   gfc_actual_arglist *arg0;\n   gfc_expr *e;\n@@ -249,7 +250,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t    && e->rank && fsym\n \t    && fsym->attr.intent != INTENT_IN\n \t    && gfc_check_fncall_dependency (e, fsym->attr.intent,\n-\t\t\t\t\t    sym, arg0))\n+\t\t\t\t\t    sym, arg0, check_variable))\n \t{\n \t  tree initial;\n \t  stmtblock_t temp_post;\n@@ -333,6 +334,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n   gfc_se se;\n   gfc_ss * ss;\n   int has_alternate_specifier;\n+  gfc_dep_check check_variable;\n \n   /* A CALL starts a new block because the actual arguments may have to\n      be evaluated first.  */\n@@ -395,6 +397,10 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n       gfc_add_ss_to_loop (&loop, ss);\n \n       gfc_conv_ss_startstride (&loop);\n+      /* TODO: gfc_conv_loop_setup generates a temporary for vector \n+\t subscripts.  This could be prevented in the elemental case  \n+\t as temporaries are handled separatedly \n+\t (below in gfc_conv_elemental_dependencies).  */\n       gfc_conv_loop_setup (&loop, &code->expr->where);\n       gfc_mark_ss_chain_used (ss, 1);\n \n@@ -404,12 +410,11 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n \n       /* For operator assignment, do dependency checking.  */\n       if (dependency_check)\n-\t{\n-\t  gfc_symbol *sym;\n-\t  sym = code->resolved_sym;\n-\t  gfc_conv_elemental_dependencies (&se, &loopse, sym,\n-\t\t\t\t\t   code->ext.actual);\n-\t}\n+\tcheck_variable = ELEM_CHECK_VARIABLE;\n+      else\n+\tcheck_variable = ELEM_DONT_CHECK_VARIABLE;\n+      gfc_conv_elemental_dependencies (&se, &loopse, code->resolved_sym,\n+\t\t\t\t       code->ext.actual, check_variable);\n \n       /* Generate the loop body.  */\n       gfc_start_scalarized_body (&loop, &body);"}, {"sha": "ae6939f3341119cb09c9a62ab63df5aeff009fb4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0bd71482ce011ac9c399534feb9c62a7d75a80/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b0bd71482ce011ac9c399534feb9c62a7d75a80", "patch": "@@ -1,3 +1,8 @@\n+2008-11-16  Mikael Morin <mikael.morin@tele2.fr>\n+\n+\tPR fortran/35681\n+\t* gfortran.dg/elemental_dependency_1.f90: New test.\n+\n 2008-11-16  Mikael Morin  <mikael.morin@tele2.fr>\n \n \tPR fortran/37992"}]}