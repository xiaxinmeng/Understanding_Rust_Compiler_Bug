{"sha": "121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIxZGUzOWZjMGViYWRmYmY5ZWY5ZjE3MjFhYTNjYWM0MmFjOTJlMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-03-30T21:12:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-03-30T21:12:53Z"}, "message": "directives.c (lex_macro_node_from_str): New.\n\nlibcpp/\n        * directives.c (lex_macro_node_from_str): New.\n        (cpp_push_definition, cpp_pop_definition): New.\n        * include/cpplib.h (cpp_push_definition, cpp_pop_definition): Declare.\ngcc/\n        * c-pragma.c (struct def_pragma_macro_value): New.\n        (struct def_pragma_macro): New.\n        (pushed_macro_table): New.\n        (dpm_hash, dpm_eq): New.\n        (handle_pragma_push_macro, handle_pragma_pop_macro): New.\n        (init_pragma): Install them.\n        * doc/tm.texi (HANDLE_PRAGMA_PUSH_POP_MACRO): New.\n\nCo-Authored-By: Kai Tietz <kai.tietz@onevision.com>\n\nFrom-SVN: r123370", "tree": {"sha": "f8ad58ad599c110a4cb386319a9c1e0f7f184b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8ad58ad599c110a4cb386319a9c1e0f7f184b64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/comments", "author": null, "committer": null, "parents": [{"sha": "6c7ac15dc63e3435b7cec32baa37e48d86c381e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7ac15dc63e3435b7cec32baa37e48d86c381e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7ac15dc63e3435b7cec32baa37e48d86c381e3"}], "stats": {"total": 259, "additions": 259, "deletions": 0}, "files": [{"sha": "1f01dac48ea6d9226e68376a29d47a409da99c74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "patch": "@@ -1,3 +1,14 @@\n+2007-03-30  Richard Henderson  <rth@redhat.com>\n+\t    Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* c-pragma.c (struct def_pragma_macro_value): New.\n+\t(struct def_pragma_macro): New.\n+\t(pushed_macro_table): New.\n+\t(dpm_hash, dpm_eq): New.\n+\t(handle_pragma_push_macro, handle_pragma_pop_macro): New.\n+\t(init_pragma): Install them.\n+\t* doc/tm.texi (HANDLE_PRAGMA_PUSH_POP_MACRO): New.\n+\n 2007-03-30  Anatoly Sokolov <aesok@post.ru>\n \n \t* config/avr/avr.c (avr_override_options): Clear "}, {"sha": "65da61838f726c638364cdb4c00f1be94fc106e8", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "patch": "@@ -245,6 +245,144 @@ handle_pragma_pack (cpp_reader * ARG_UNUSED (dummy))\n }\n #endif  /* HANDLE_PRAGMA_PACK */\n \n+struct def_pragma_macro_value GTY(())\n+{\n+  struct def_pragma_macro_value *prev;\n+  cpp_macro *value;\n+};\n+\n+struct def_pragma_macro GTY(())\n+{\n+  hashval_t hash;\n+  const char *name;\n+  struct def_pragma_macro_value value;\n+};\n+\n+static GTY((param_is (struct def_pragma_macro))) htab_t pushed_macro_table;\n+\n+#ifdef HANDLE_PRAGMA_PUSH_POP_MACRO\n+/* Hash table control functions for pushed_macro_table.  */\n+static hashval_t\n+dpm_hash (const void *p)\n+{\n+  return ((const struct def_pragma_macro *)p)->hash;\n+}\n+\n+static int\n+dpm_eq (const void *pa, const void *pb)\n+{\n+  const struct def_pragma_macro *a = pa, *b = pb;\n+  return a->hash == b->hash && strcmp (a->name, b->name) == 0;\n+}\n+\n+/* #pragma push_macro(\"MACRO_NAME\")\n+   #pragma pop_macro(\"MACRO_NAME\") */\n+\n+static void\n+handle_pragma_push_macro (cpp_reader *reader)\n+{\n+  tree x, id = 0;\n+  enum cpp_ttype token;\n+  struct def_pragma_macro dummy, *c;\n+  const char *macroname;\n+  void **slot;\n+\n+  if (pragma_lex (&x) != CPP_OPEN_PAREN)\n+    GCC_BAD (\"missing %<(%> after %<#pragma push_macro%> - ignored\");\n+\n+  token = pragma_lex (&id);\n+\n+  /* Silently ignore */\n+  if (token == CPP_CLOSE_PAREN)\n+    return;\n+  if (token != CPP_STRING)\n+    GCC_BAD (\"invalid constant in %<#pragma push_macro%> - ignored\");\n+\n+  if (pragma_lex (&x) != CPP_CLOSE_PAREN)\n+    GCC_BAD (\"missing %<)%> after %<#pragma push_macro%> - ignored\");\n+\n+  if (pragma_lex (&x) != CPP_EOF)\n+    warning (OPT_Wpragmas, \"junk at end of %<#pragma push_macro%>\");\n+\n+  /* Check for empty string, and silently ignore.  */\n+  if (TREE_STRING_LENGTH (id) < 1)\n+    return;\n+  macroname = TREE_STRING_POINTER (id);\n+\n+  if (pushed_macro_table == NULL)\n+    pushed_macro_table = htab_create_ggc (15, dpm_hash, dpm_eq, 0);\n+\n+  dummy.hash = htab_hash_string (macroname);\n+  dummy.name = macroname;\n+  slot = htab_find_slot_with_hash (pushed_macro_table, &dummy,\n+\t\t\t\t   dummy.hash, INSERT);\n+  c = *slot;\n+  if (c == NULL)\n+    {\n+      *slot = c = ggc_alloc (sizeof (struct def_pragma_macro));\n+      c->hash = dummy.hash;\n+      c->name = ggc_alloc_string (macroname, TREE_STRING_LENGTH (id) - 1);\n+      c->value.prev = NULL;\n+    }\n+  else\n+    {\n+      struct def_pragma_macro_value *v;\n+      v = ggc_alloc (sizeof (struct def_pragma_macro_value));\n+      *v = c->value;\n+      c->value.prev = v;\n+    }\n+\n+  c->value.value = cpp_push_definition (reader, macroname);\n+}\n+\n+static void\n+handle_pragma_pop_macro (cpp_reader *reader)\n+{\n+  tree x, id = 0;\n+  enum cpp_ttype token;\n+  struct def_pragma_macro dummy, *c;\n+  const char *macroname;\n+  void **slot;\n+\n+  if (pragma_lex (&x) != CPP_OPEN_PAREN)\n+    GCC_BAD (\"missing %<(%> after %<#pragma pop_macro%> - ignored\");\n+\n+  token = pragma_lex (&id);\n+\n+  /* Silently ignore */\n+  if (token == CPP_CLOSE_PAREN)\n+    return;\n+  if (token != CPP_STRING)\n+    GCC_BAD (\"invalid constant in %<#pragma pop_macro%> - ignored\");\n+\n+  if (pragma_lex (&x) != CPP_CLOSE_PAREN)\n+    GCC_BAD (\"missing %<)%> after %<#pragma pop_macro%> - ignored\");\n+\n+  if (pragma_lex (&x) != CPP_EOF)\n+    warning (OPT_Wpragmas, \"junk at end of %<#pragma pop_macro%>\");\n+\n+  /* Check for empty string, and silently ignore.  */\n+  if (TREE_STRING_LENGTH (id) < 1)\n+    return;\n+  macroname = TREE_STRING_POINTER (id);\n+\n+  dummy.hash = htab_hash_string (macroname);\n+  dummy.name = macroname;\n+  slot = htab_find_slot_with_hash (pushed_macro_table, &dummy,\n+\t\t\t\t   dummy.hash, NO_INSERT);\n+  if (slot == NULL)\n+    return;\n+  c = *slot;\n+\n+  cpp_pop_definition (reader, c->name, c->value.value);\n+\n+  if (c->value.prev)\n+    c->value = *c->value.prev;\n+  else\n+    htab_clear_slot (pushed_macro_table, slot);\n+}\n+#endif /* HANDLE_PRAGMA_PUSH_POP_MACRO */\n+\n static GTY(()) tree pending_weaks;\n \n #ifdef HANDLE_PRAGMA_WEAK\n@@ -819,6 +957,10 @@ init_pragma (void)\n   c_register_pragma (0, \"pack\", handle_pragma_pack);\n #endif\n #endif\n+#ifdef HANDLE_PRAGMA_PUSH_POP_MACRO\n+  c_register_pragma (0 ,\"push_macro\", handle_pragma_push_macro);\n+  c_register_pragma (0 ,\"pop_macro\", handle_pragma_pop_macro);\n+#endif\n #ifdef HANDLE_PRAGMA_WEAK\n   c_register_pragma (0, \"weak\", handle_pragma_weak);\n #endif"}, {"sha": "0d4185de05c535729fffd391f5bb90725fbbb2f9", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "patch": "@@ -9719,6 +9719,18 @@ This must be a value that would also be valid to use with\n @samp{#pragma pack()} (that is, a small power of two).\n @end defmac\n \n+@findex #pragma\n+@findex pragma\n+@defmac HANDLE_PRAGMA_PUSH_POP_MACRO\n+Define this macro if you want to support the Win32 style pragmas\n+@samp{#pragma push_macro(macro-name-as-string)} and @samp{#pragma\n+pop_macro(macro-name-as-string)}.  The @samp{#pragma push_macro(\n+macro-name-as-string)} pragma saves the named macro and via\n+@samp{#pragma pop_macro(macro-name-as-string)} it will return to the\n+previous value.\n+@end defmac\n+\n+\n @defmac DOLLARS_IN_IDENTIFIERS\n Define this macro to control use of the character @samp{$} in\n identifier names for the C family of languages.  0 means @samp{$} is"}, {"sha": "ac5d059b5ea1c79c97d036311eedb55ac883395f", "filename": "gcc/testsuite/gcc.dg/pragma-push_macro-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-push_macro-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-push_macro-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-push_macro-1.c?ref=121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "patch": "@@ -0,0 +1,26 @@\n+/* Prove that HANDLE_PRAGMA_PUSH_POP_MACRO handling works somewhat. */\n+\n+/* { dg-do link { target *-*-mingw* } } */\n+\n+#define TEXT1  \"ABC\"\n+#define TEXT2  \"DEF\"\n+\n+int main()\n+{\n+  if (__builtin_strcmp (TEXT1 TEXT2, \"ABCDEF\") != 0)\n+    link_error ();\n+\n+#pragma push_macro(\"TEXT1\")\n+#undef TEXT1\n+#define TEXT1  \"XYZ\"\n+\n+  if (__builtin_strcmp (TEXT1 TEXT2, \"XYZDEF\") != 0)\n+    link_error ();\n+\n+#pragma pop_macro(\"TEXT1\")\n+\n+  if (__builtin_strcmp (TEXT1 TEXT2, \"ABCDEF\") != 0)\n+    link_error ();\n+\n+  return 0;\n+}"}, {"sha": "a8be346bc56ab3d268618a61d0d16132abbcd764", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "patch": "@@ -1,3 +1,9 @@\n+2007-03-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* directives.c (lex_macro_node_from_str): New.\n+\t(cpp_push_definition, cpp_pop_definition): New.\n+\t* include/cpplib.h (cpp_push_definition, cpp_pop_definition): Declare.\n+\n 2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* Makefile.in: Add dummy install-pdf target."}, {"sha": "d9cf9d27204384ebba3fe1020e6f4caa9cb512cb", "filename": "libcpp/directives.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "patch": "@@ -2078,6 +2078,65 @@ cpp_undef (cpp_reader *pfile, const char *macro)\n   run_directive (pfile, T_UNDEF, buf, len);\n }\n \n+/* Like lex_macro_node, but read the input from STR.  */\n+static cpp_hashnode *\n+lex_macro_node_from_str (cpp_reader *pfile, const char *str)\n+{\n+  size_t len = strlen (str);\n+  uchar *buf = (char *) alloca (len + 1);\n+  cpp_hashnode *node;\n+\n+  memcpy (buf, str, len);\n+  buf[len] = '\\n';\n+  cpp_push_buffer (pfile, buf, len, true);\n+  node = lex_macro_node (pfile, true);\n+  _cpp_pop_buffer (pfile);\n+\n+  return node;\n+}\n+\n+/* If STR is a defined macro, return its definition node, else return NULL.  */\n+cpp_macro *\n+cpp_push_definition (cpp_reader *pfile, const char *str)\n+{\n+  cpp_hashnode *node = lex_macro_node_from_str (pfile, str);\n+  if (node && node->type == NT_MACRO)\n+    return node->value.macro;\n+  else\n+    return NULL;\n+}\n+\n+/* Replace a previous definition DFN of the macro STR.  If DFN is NULL,\n+   then the macro should be undefined.  */\n+void\n+cpp_pop_definition (cpp_reader *pfile, const char *str, cpp_macro *dfn)\n+{\n+  cpp_hashnode *node = lex_macro_node_from_str (pfile, str);\n+  if (node == NULL)\n+    return;\n+\n+  if (node->type == NT_MACRO)\n+    {\n+      if (pfile->cb.undef)\n+\tpfile->cb.undef (pfile, pfile->directive_line, node);\n+      if (CPP_OPTION (pfile, warn_unused_macros))\n+\t_cpp_warn_if_unused_macro (pfile, node, NULL);\n+    }\n+  if (node->type != NT_VOID)\n+    _cpp_free_definition (node);\n+\n+  if (dfn)\n+    {\n+      node->type = NT_MACRO;\n+      node->value.macro = dfn;\n+      if (! ustrncmp (NODE_NAME (node), DSC (\"__STDC_\")))\n+\tnode->flags |= NODE_WARN;\n+\n+      if (pfile->cb.define)\n+\tpfile->cb.define (pfile, pfile->directive_line, node);\n+    }\n+}\n+\n /* Process the string STR as if it appeared as the body of a #assert.  */\n void\n cpp_assert (cpp_reader *pfile, const char *str)"}, {"sha": "b2939984f80a4fa18e4c2531ee71fe3ad684440e", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=121de39fc0ebadfbf9ef9f1721aa3cac42ac92e1", "patch": "@@ -704,6 +704,9 @@ extern void cpp_assert (cpp_reader *, const char *);\n extern void cpp_undef (cpp_reader *, const char *);\n extern void cpp_unassert (cpp_reader *, const char *);\n \n+extern cpp_macro *cpp_push_definition (cpp_reader *, const char *);\n+extern void cpp_pop_definition (cpp_reader *, const char *, cpp_macro *);\n+\n /* Undefine all macros and assertions.  */\n extern void cpp_undef_all (cpp_reader *);\n "}]}