{"sha": "23d5ed5dcf5305653fc67dddf0a2ea53ca81add6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNkNWVkNWRjZjUzMDU2NTNmYzY3ZGRkZjBhMmVhNTNjYTgxYWRkNg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2011-01-19T22:07:14Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2011-01-19T22:07:14Z"}, "message": "re PR debug/46240 (ice in maybe_register_def)\n\ngcc/ChangeLog:\nPR debug/46240\n* tree-into-ssa.c (maybe_register_def): Do not attempt to add\ndebug bind stmt on merge edges.\ngcc/testsuite/ChangeLog:\nPR debug/46240\n* g++.dg/debug/pr46240.cc: New.\n\nFrom-SVN: r169035", "tree": {"sha": "cc4d61e9e6bc2658197fbb19d9f459bca47f0f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc4d61e9e6bc2658197fbb19d9f459bca47f0f94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/comments", "author": null, "committer": null, "parents": [{"sha": "37d6a488a470eb9447ac51f434621ad979e5b4f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d6a488a470eb9447ac51f434621ad979e5b4f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37d6a488a470eb9447ac51f434621ad979e5b4f3"}], "stats": {"total": 209, "additions": 204, "deletions": 5}, "files": [{"sha": "fc8e90ca95a1ceff4aadca3c81dd0280fe4a0804", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23d5ed5dcf5305653fc67dddf0a2ea53ca81add6", "patch": "@@ -1,3 +1,9 @@\n+2011-01-19  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/46240\n+\t* tree-into-ssa.c (maybe_register_def): Do not attempt to add\n+\tdebug bind stmt on merge edges.\n+\n 2011-01-19  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/47079"}, {"sha": "332b1eb1f22d7126ffde5b2b54d0e4e29179dd16", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=23d5ed5dcf5305653fc67dddf0a2ea53ca81add6", "patch": "@@ -1,3 +1,8 @@\n+2011-01-19  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/46240\n+\t* g++.dg/debug/pr46240.cc: New.\n+\n 2011-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/47303"}, {"sha": "c12a6988af8f66bf41ce763786618f1d70ff6492", "filename": "gcc/testsuite/g++.dg/debug/pr46240.cc", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr46240.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr46240.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fpr46240.cc?ref=23d5ed5dcf5305653fc67dddf0a2ea53ca81add6", "patch": "@@ -0,0 +1,172 @@\n+// { dg-do compile }\n+// { dg-options \"-O3 -g\" }\n+\n+template <typename T>\n+T &max (T &a, T &b)\n+{\n+  if (a < b) return b; else return a;\n+}\n+int foo (double);\n+struct S\n+{\n+  struct T\n+  {\n+    int dims, count;\n+    T (int, int) : dims (), count () {}\n+  };\n+  T *rep;\n+  S () {}\n+  S (int r, int c) : rep (new T (r, c)) {}\n+  ~S () { delete rep; }\n+};\n+template <typename T>\n+struct U\n+{\n+  static T epsilon () throw ();\n+};\n+template <class T>\n+struct V\n+{\n+  struct W\n+  {\n+    T * data;\n+    int count;\n+    W (int n) : data (new T[n]), count () {}\n+  };\n+  V::W *rep;\n+  S dimensions;\n+  int slice_len;\n+  V (S s) : rep (new V <T>::W (get_size (s))) {}\n+  int capacity () { return slice_len; }\n+  int get_size (S);\n+};\n+template <class T>\n+struct Z : public V <T>\n+{\n+  Z () : V <T> (S (0, 0)) {}\n+  Z (int r, int c) : V <T> (S (r, c)) {}\n+};\n+template <class T>\n+struct A : public Z <T>\n+{\n+  A () : Z <T> () {}\n+  A (int n, int m) : Z <T> (n, m) {}\n+};\n+template <class T>\n+struct B : public V <T>\n+{\n+};\n+struct C : public A <double>\n+{\n+  C () : A <double> () {}\n+  C (int r, int c) : A <double> (r, c) {}\n+};\n+struct D : public B <double>\n+{\n+};\n+template <class T>\n+struct E\n+{\n+};\n+template <class T>\n+struct G : public E <T>\n+{\n+};\n+struct H : public G <double>\n+{\n+};\n+template <class R>\n+struct I\n+{\n+  R scl, sum;\n+  void accum (R val)\n+  {\n+    R t = __builtin_fabs (val);\n+    if (scl == t)\n+      sum += 1;\n+  }\n+  operator R () { __builtin_sqrt (sum); return R (); }\n+};\n+template <class R>\n+struct J\n+{\n+  template < class U > void accum (U val) {}\n+  operator R () { return R (); }\n+};\n+template <class R>\n+struct K\n+{\n+  R max;\n+  template <class U> void accum (U val)\n+  {\n+    double z = __builtin_fabs (val);\n+    max = ::max (max, z);\n+  }\n+  operator R () { return max; }\n+};\n+template <class R>\n+struct L\n+{\n+  unsigned num;\n+  template <class U> void accum (U) {}\n+  operator R () { return num; }\n+};\n+template <class T, class R, class S>\n+void bar (V <T> &v, R &res, S acc)\n+{\n+  for (int i = 0; i < v.capacity (); i++)\n+    acc.accum ((i));\n+  res = acc;\n+}\n+template <class T, class R>\n+void bar (B <T> &v, R)\n+{\n+  R res;\n+  bar (v, res, I <R> ());\n+}\n+template <class T, class R>\n+R bar (A <T> &v, R p)\n+{\n+  R res;\n+  if (p == 2)\n+    bar (v, res, I <R> ());\n+  else if (p == 1)\n+    bar (v, res, J <R> ());\n+  else if (p == sizeof (float) ? (p) : foo (p))\n+    {\n+      if (p > 0)\n+\tbar (v, res, K <R> ());\n+    }\n+  else if (p == 0)\n+    bar (v, res, L <R> ());\n+  return res;\n+}\n+template <class CT, class VectorT, class R>\n+void\n+baz (CT m, R p, R tol, int maxiter, VectorT)\n+{\n+  VectorT y (0, 0), z (0, 1);\n+  R q = 0;\n+  R gamma = 0, gamma1 = 0;\n+  gamma = bar (y, p);\n+  (void) (bar (z, q) <= (gamma1 <= gamma));\n+}\n+int a = 100;\n+template <class CT, class VectorT, class R>\n+void\n+test (CT m, R p, VectorT)\n+{\n+  VectorT x;\n+  R sqrteps (U <R>::epsilon ());\n+  baz (m, p, sqrteps, a, x);\n+}\n+void\n+fn (D x, double p)\n+{\n+  bar (x, p);\n+}\n+void\n+fn (H x, double p)\n+{\n+  test (x, p, C ());\n+}"}, {"sha": "c425586a15657fb3957be243cc4314243b8ca785", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d5ed5dcf5305653fc67dddf0a2ea53ca81add6/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=23d5ed5dcf5305653fc67dddf0a2ea53ca81add6", "patch": "@@ -1869,11 +1869,27 @@ maybe_register_def (def_operand_p def_p, gimple stmt,\n \t\t\tgcc_assert (!ef);\n \t\t\tef = e;\n \t\t      }\n-\t\t  gcc_assert (ef\n-\t\t\t      && single_pred_p (ef->dest)\n-\t\t\t      && !phi_nodes (ef->dest)\n-\t\t\t      && ef->dest != EXIT_BLOCK_PTR);\n-\t\t  gsi_insert_on_edge_immediate (ef, note);\n+\t\t  /* If there are other predecessors to ef->dest, then\n+\t\t     there must be PHI nodes for the modified\n+\t\t     variable, and therefore there will be debug bind\n+\t\t     stmts after the PHI nodes.  The debug bind notes\n+\t\t     we'd insert would force the creation of a new\n+\t\t     block (diverging codegen) and be redundant with\n+\t\t     the post-PHI bind stmts, so don't add them.\n+\n+\t\t     As for the exit edge, there wouldn't be redundant\n+\t\t     bind stmts, but there wouldn't be a PC to bind\n+\t\t     them to either, so avoid diverging the CFG.  */\n+\t\t  if (ef && single_pred_p (ef->dest)\n+\t\t      && ef->dest != EXIT_BLOCK_PTR)\n+\t\t    {\n+\t\t      /* If there were PHI nodes in the node, we'd\n+\t\t\t have to make sure the value we're binding\n+\t\t\t doesn't need rewriting.  But there shouldn't\n+\t\t\t be PHI nodes in a single-predecessor block,\n+\t\t\t so we just add the note.  */\n+\t\t      gsi_insert_on_edge_immediate (ef, note);\n+\t\t    }\n \t\t}\n \t      else\n \t\tgsi_insert_after (&gsi, note, GSI_SAME_STMT);"}]}