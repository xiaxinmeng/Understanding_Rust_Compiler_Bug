{"sha": "517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE3ZDc2ZmFlZmY5YWUyNGM1YzBkYzZiODdmZmUzODY4YzAzOGQyOQ==", "commit": {"author": {"name": "Vladimir Yanovsky", "email": "yanov@il.ibm.com", "date": "2007-08-05T09:43:07Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-08-05T09:43:07Z"}, "message": "New flag to control reg-moves generation\n\nCo-Authored-By: Revital Eres <eres@il.ibm.com>\n\nFrom-SVN: r127223", "tree": {"sha": "500d4059ebb7fcc4538315c58a87786450624b31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/500d4059ebb7fcc4538315c58a87786450624b31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/comments", "author": null, "committer": null, "parents": [{"sha": "152b97088e45ce9f59ae86bc16181eb020fb152a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152b97088e45ce9f59ae86bc16181eb020fb152a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152b97088e45ce9f59ae86bc16181eb020fb152a"}], "stats": {"total": 148, "additions": 110, "deletions": 38}, "files": [{"sha": "3e7dab0c34618d000436697784ad7cf26fac20b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "patch": "@@ -1,3 +1,18 @@\n+2007-08-05  Vladimir Yanovsky  <yanov@il.ibm.com>\n+            Revital Eres <eres@il.ibm.com>\n+\n+\t* doc/invoke.texi (-fmodulo-sched-allow-regmoves): Document new\n+\tflag.\n+\t* ddg.c (create_ddg_dependence): Rename to...\n+\t(create_ddg_dep_from_intra_loop_link): This.  Do not check\n+\tfor interloop edges.  Do not create anti dependence edge when\n+\ta true dependence edge exists in the opposite direction and\n+\t-fmodulo-sched-allow-regmoves is set.\n+\t(build_intra_loop_deps): Call create_ddg_dep_from_intra_loop_link.\n+\t(add_cross_iteration_register_deps): Create anti dependence edge\n+\twhen -fno-modulo-sched-allow-regmoves is set.\n+\t* common.opt (-fmodulo-sched-allow-regmoves): New flag.\n+\n 2007-08-04  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/arm/arm.md (movsi): Add braces."}, {"sha": "4e59e17fe0eef47274cda86eefcdf9ce17d9e770", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "patch": "@@ -651,6 +651,10 @@ fmodulo-sched\n Common Report Var(flag_modulo_sched) Optimization\n Perform SMS based modulo scheduling before the first scheduling pass\n \n+fmodulo-sched-allow-regmoves\n+Common Report Var(flag_modulo_sched_allow_regmoves)\n+Perform SMS based modulo scheduling with register moves allowed\n+\n fmove-loop-invariants\n Common Report Var(flag_move_loop_invariants) Init(1) Optimization\n Move loop invariant computations out of loops"}, {"sha": "def8e0ee6d9e3da6c91ae5e3d937841a3293b1ca", "filename": "gcc/ddg.c", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "patch": "@@ -51,7 +51,8 @@ enum edge_flag {NOT_IN_SCC = 0, IN_SCC};\n static void add_backarc_to_ddg (ddg_ptr, ddg_edge_ptr);\n static void add_backarc_to_scc (ddg_scc_ptr, ddg_edge_ptr);\n static void add_scc_to_ddg (ddg_all_sccs_ptr, ddg_scc_ptr);\n-static void create_ddg_dependence (ddg_ptr, ddg_node_ptr, ddg_node_ptr, dep_t);\n+static void create_ddg_dep_from_intra_loop_link (ddg_ptr, ddg_node_ptr,\n+                                                 ddg_node_ptr, dep_t);\n static void create_ddg_dep_no_link (ddg_ptr, ddg_node_ptr, ddg_node_ptr,\n  \t\t\t\t    dep_type, dep_data_type, int);\n static ddg_edge_ptr create_ddg_edge (ddg_node_ptr, ddg_node_ptr, dep_type,\n@@ -145,50 +146,51 @@ mem_access_insn_p (rtx insn)\n /* Computes the dependence parameters (latency, distance etc.), creates\n    a ddg_edge and adds it to the given DDG.  */\n static void\n-create_ddg_dependence (ddg_ptr g, ddg_node_ptr src_node,\n-\t\t       ddg_node_ptr dest_node, dep_t link)\n+create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n+                                     ddg_node_ptr dest_node, dep_t link)\n {\n   ddg_edge_ptr e;\n   int latency, distance = 0;\n-  int interloop = (src_node->cuid >= dest_node->cuid);\n   dep_type t = TRUE_DEP;\n   dep_data_type dt = (mem_access_insn_p (src_node->insn)\n \t\t      && mem_access_insn_p (dest_node->insn) ? MEM_DEP\n \t\t\t\t\t\t\t     : REG_DEP);\n-\n-  /* For now we don't have an exact calculation of the distance,\n-     so assume 1 conservatively.  */\n-  if (interloop)\n-     distance = 1;\n-\n+  gcc_assert (src_node->cuid < dest_node->cuid);\n   gcc_assert (link);\n \n   /* Note: REG_DEP_ANTI applies to MEM ANTI_DEP as well!!  */\n   if (DEP_KIND (link) == REG_DEP_ANTI)\n     t = ANTI_DEP;\n   else if (DEP_KIND (link) == REG_DEP_OUTPUT)\n     t = OUTPUT_DEP;\n-  latency = dep_cost (link);\n \n-  e = create_ddg_edge (src_node, dest_node, t, dt, latency, distance);\n-\n-  if (interloop)\n+  /* We currently choose not to create certain anti-deps edges and\n+     compensate for that by generating reg-moves based on the life-range\n+     analysis.  The anti-deps that will be deleted are the ones which\n+     have true-deps edges in the opposite direction (in other words\n+     the kernel has only one def of the relevant register).  TODO:\n+     support the removal of all anti-deps edges, i.e. including those\n+     whose register has multiple defs in the loop.  */\n+  if (flag_modulo_sched_allow_regmoves && (t == ANTI_DEP && dt == REG_DEP))\n     {\n-      /* Some interloop dependencies are relaxed:\n-\t 1. Every insn is output dependent on itself; ignore such deps.\n-\t 2. Every true/flow dependence is an anti dependence in the\n-\t opposite direction with distance 1; such register deps\n-\t will be removed by renaming if broken --- ignore them.  */\n-      if (!(t == OUTPUT_DEP && src_node == dest_node)\n-\t  && !(t == ANTI_DEP && dt == REG_DEP))\n-\tadd_backarc_to_ddg (g, e);\n-      else\n-\tfree (e);\n+      rtx set;\n+\n+      set = single_set (dest_node->insn);\n+      if (set)\n+        {\n+          int regno = REGNO (SET_DEST (set));\n+          struct df_ref *first_def =\n+            df_bb_regno_first_def_find (g->bb, regno);\n+          struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n+\n+          if (bitmap_bit_p (bb_info->gen, first_def->id))\n+            return;\n+        }\n     }\n-  else if (t == ANTI_DEP && dt == REG_DEP)\n-    free (e);  /* We can fix broken anti register deps using reg-moves.  */\n-  else\n-    add_edge_to_ddg (g, e);\n+\n+   latency = dep_cost (link);\n+   e = create_ddg_edge (src_node, dest_node, t, dt, latency, distance);\n+   add_edge_to_ddg (g, e);\n }\n \n /* The same as the above function, but it doesn't require a link parameter.  */\n@@ -247,6 +249,11 @@ add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n   gcc_assert (last_def_node);\n   gcc_assert (first_def);\n \n+#ifdef ENABLE_CHECKING\n+  if (last_def->id != first_def->id)\n+    gcc_assert (!bitmap_bit_p (bb_info->gen, first_def->id));\n+#endif\n+\n   /* Create inter-loop true dependences and anti dependences.  */\n   for (r_use = DF_REF_CHAIN (last_def); r_use != NULL; r_use = r_use->next)\n     {\n@@ -280,14 +287,11 @@ add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n \n \t  gcc_assert (first_def_node);\n \n-          if (last_def->id != first_def->id)\n-            {\n-#ifdef ENABLE_CHECKING\n-              gcc_assert (!bitmap_bit_p (bb_info->gen, first_def->id));\n-#endif\n-              create_ddg_dep_no_link (g, use_node, first_def_node, ANTI_DEP,\n-                                      REG_DEP, 1);\n-            }\n+          if (last_def->id != first_def->id\n+              || !flag_modulo_sched_allow_regmoves)\n+            create_ddg_dep_no_link (g, use_node, first_def_node, ANTI_DEP,\n+                                    REG_DEP, 1);\n+\n \t}\n     }\n   /* Create an inter-loop output dependence between LAST_DEF (which is the\n@@ -392,7 +396,7 @@ build_intra_loop_deps (ddg_ptr g)\n \t    continue;\n \n       \t  add_forw_dep (link);\n-\t  create_ddg_dependence (g, src_node, dest_node, dep);\n+\t  create_ddg_dep_from_intra_loop_link (g, src_node, dest_node, dep);\n \t}\n \n       /* If this insn modifies memory, add an edge to all insns that access"}, {"sha": "5a13c42501b29f09edecc047823c55f748aeacdf", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "patch": "@@ -328,7 +328,7 @@ Objective-C and Objective-C++ Dialects}.\n -finline-functions  -finline-functions-called-once @gol\n -finline-limit=@var{n}  -fkeep-inline-functions @gol\n -fkeep-static-consts  -fmerge-constants  -fmerge-all-constants @gol\n--fmodulo-sched -fno-branch-count-reg @gol\n+-fmodulo-sched -fmodulo-sched-allow-regmoves -fno-branch-count-reg @gol\n -fno-default-inline  -fno-defer-pop -fmove-loop-invariants @gol\n -fno-function-cse  -fno-guess-branch-probability @gol\n -fno-inline  -fno-math-errno  -fno-peephole  -fno-peephole2 @gol\n@@ -5265,6 +5265,13 @@ Perform swing modulo scheduling immediately before the first scheduling\n pass.  This pass looks at innermost loops and reorders their\n instructions by overlapping different iterations.\n \n+@item -fmodulo-sched-allow-regmoves\n+@opindex fmodulo-sched-allow-regmoves\n+Perform more aggressive SMS based modulo scheduling with register moves\n+allowed.  By setting this flag certain anti-dependences edges will be\n+deleted which will trigger the generation of reg-moves based on the\n+life-range analysis.\n+\n @item -fno-branch-count-reg\n @opindex fno-branch-count-reg\n Do not use ``decrement and branch'' instructions on a count register,"}, {"sha": "b5f183e68c70c5d8c24e028aa62c769c3e3fe3c1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "patch": "@@ -1,3 +1,8 @@\n+2007-08-05  Vladimir Yanovsky  <yanov@il.ibm.com>\n+            Revital Eres <eres@il.ibm.com>\n+\n+\t* gcc.dg/sms-antideps.c: New test.\n+\n 2007-08-04  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/31214"}, {"sha": "e973261999ae3c54641bee406d059a5600167378", "filename": "gcc/testsuite/gcc.dg/sms-antideps.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-antideps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517d76faeff9ae24c5c0dc6b87ffe3868c038d29/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-antideps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-antideps.c?ref=517d76faeff9ae24c5c0dc6b87ffe3868c038d29", "patch": "@@ -0,0 +1,37 @@\n+/*  This test is a reduced test case for a bug that caused\n+    bootstrapping with -fmodulo-sched.  Related to a broken anti-dep\n+    that was not fixed by reg-moves.  */\n+\n+ /* { dg-do run } */\n+ /* { dg-options \"-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves\" } */\n+\n+#include <stdlib.h>\n+\n+unsigned long long\n+foo (long long ixi, unsigned ctr)\n+{\n+  unsigned long long irslt = 1;\n+  long long ix = ixi;\n+\n+  for (; ctr; ctr--)\n+    {\n+      irslt *= ix;\n+      ix *= ix;\n+    }\n+\n+  if (irslt != 14348907)\n+    abort ();\n+  return irslt;\n+}\n+\n+\n+int\n+main ()\n+{\n+  unsigned long long res;\n+\n+  res = foo (3, 4);\n+}\n+\n+\n+"}]}