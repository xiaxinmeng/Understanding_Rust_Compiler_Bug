{"sha": "2d5b3f6e54c8439baf3123ab9cb24946e59e7032", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ1YjNmNmU1NGM4NDM5YmFmMzEyM2FiOWNiMjQ5NDZlNTllNzAzMg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-09-13T16:54:15Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-09-13T16:54:15Z"}, "message": "bt-load.c: remove typedefs that hide pointerness\n\ngcc/ChangeLog:\n\n2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* bt-load.c (struct btr_def_group): Rename from btr_def_group_s.\n\t(struct btr_user): Rename from btr_user_s.\n\t(struct btr_def): Rename from btr_def_s.\n\t(find_btr_def_group): Adjust.\n\t(add_btr_def): Likewise.\n\t(new_btr_user): Likewise.\n\t(note_other_use_this_block): Likewise.\n\t(compute_defs_uses_and_gen): Likewise.\n\t(link_btr_uses): Likewise.\n\t(build_btr_def_use_webs): Likewise.\n\t(block_at_edge_of_live_range_p): Likewise.\n\t(btr_def_live_range): Likewise.\n\t(combine_btr_defs): Likewise.\n\t(move_btr_def): Likewise.\n\t(migrate_btr_def): Likewise.\n\t(migrate_btr_defs): Likewise.\n\nFrom-SVN: r227722", "tree": {"sha": "5648a916edbd75d0a6569a1fc1602f2cdf10fad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5648a916edbd75d0a6569a1fc1602f2cdf10fad6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d5b3f6e54c8439baf3123ab9cb24946e59e7032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5b3f6e54c8439baf3123ab9cb24946e59e7032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d5b3f6e54c8439baf3123ab9cb24946e59e7032", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5b3f6e54c8439baf3123ab9cb24946e59e7032/comments", "author": null, "committer": null, "parents": [{"sha": "db646889a3e98a5a84b682b0e4cb4265f25b18a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db646889a3e98a5a84b682b0e4cb4265f25b18a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db646889a3e98a5a84b682b0e4cb4265f25b18a9"}], "stats": {"total": 159, "additions": 90, "deletions": 69}, "files": [{"sha": "dec1c70abf41f64be2ff0289fd0c1d6936577c11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5b3f6e54c8439baf3123ab9cb24946e59e7032/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5b3f6e54c8439baf3123ab9cb24946e59e7032/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d5b3f6e54c8439baf3123ab9cb24946e59e7032", "patch": "@@ -1,3 +1,22 @@\n+2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* bt-load.c (struct btr_def_group): Rename from btr_def_group_s.\n+\t(struct btr_user): Rename from btr_user_s.\n+\t(struct btr_def): Rename from btr_def_s.\n+\t(find_btr_def_group): Adjust.\n+\t(add_btr_def): Likewise.\n+\t(new_btr_user): Likewise.\n+\t(note_other_use_this_block): Likewise.\n+\t(compute_defs_uses_and_gen): Likewise.\n+\t(link_btr_uses): Likewise.\n+\t(build_btr_def_use_webs): Likewise.\n+\t(block_at_edge_of_live_range_p): Likewise.\n+\t(btr_def_live_range): Likewise.\n+\t(combine_btr_defs): Likewise.\n+\t(move_btr_def): Likewise.\n+\t(migrate_btr_def): Likewise.\n+\t(migrate_btr_defs): Likewise.\n+\n 2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* var-tracking.c (shared_hash_def): Rename to shared_hash."}, {"sha": "9b1d366bf00d31150cb0f47dc56b97caba91394b", "filename": "gcc/bt-load.c", "status": "modified", "additions": 71, "deletions": 69, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5b3f6e54c8439baf3123ab9cb24946e59e7032/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5b3f6e54c8439baf3123ab9cb24946e59e7032/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=2d5b3f6e54c8439baf3123ab9cb24946e59e7032", "patch": "@@ -51,18 +51,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-iter.h\"\n #include \"fibonacci_heap.h\"\n \n+struct btr_def;\n+\n /* Target register optimizations - these are performed after reload.  */\n \n-typedef struct btr_def_group_s\n+struct btr_def_group\n {\n-  struct btr_def_group_s *next;\n+  btr_def_group *next;\n   rtx src;\n-  struct btr_def_s *members;\n-} *btr_def_group;\n+  btr_def *members;\n+};\n \n-typedef struct btr_user_s\n+struct btr_user\n {\n-  struct btr_user_s *next;\n+  btr_user *next;\n   basic_block bb;\n   int luid;\n   rtx_insn *insn;\n@@ -74,7 +76,7 @@ typedef struct btr_user_s\n   int n_reaching_defs;\n   int first_reaching_def;\n   char other_use_this_block;\n-} *btr_user;\n+};\n \n /* btr_def structs appear on three lists:\n      1. A list of all btr_def structures (head is\n@@ -85,10 +87,10 @@ typedef struct btr_user_s\n \tgroup (head is in a BTR_DEF_GROUP struct, linked by\n \tNEXT_THIS_GROUP field).  */\n \n-typedef struct btr_def_s\n+struct btr_def\n {\n-  struct btr_def_s *next_this_bb;\n-  struct btr_def_s *next_this_group;\n+  btr_def *next_this_bb;\n+  btr_def *next_this_group;\n   basic_block bb;\n   int luid;\n   rtx_insn *insn;\n@@ -98,8 +100,8 @@ typedef struct btr_def_s\n      source (i.e. a label), group links together all the\n      insns with the same source.  For other branch register\n      setting insns, group is NULL.  */\n-  btr_def_group group;\n-  btr_user uses;\n+  btr_def_group *group;\n+  btr_user *uses;\n   /* If this def has a reaching use which is not a simple use\n      in a branch instruction, then has_ambiguous_use will be true,\n      and we will not attempt to migrate this definition.  */\n@@ -119,38 +121,38 @@ typedef struct btr_def_s\n      to clear out trs_live_at_end again.  */\n   char own_end;\n   bitmap live_range;\n-} *btr_def;\n+};\n \n-typedef fibonacci_heap <long, btr_def_s> btr_heap_t;\n-typedef fibonacci_node <long, btr_def_s> btr_heap_node_t;\n+typedef fibonacci_heap <long, btr_def> btr_heap_t;\n+typedef fibonacci_node <long, btr_def> btr_heap_node_t;\n \n static int issue_rate;\n \n static int basic_block_freq (const_basic_block);\n static int insn_sets_btr_p (const rtx_insn *, int, int *);\n-static void find_btr_def_group (btr_def_group *, btr_def);\n-static btr_def add_btr_def (btr_heap_t *, basic_block, int, rtx_insn *,\n-\t\t\t    unsigned int, int, btr_def_group *);\n-static btr_user new_btr_user (basic_block, int, rtx_insn *);\n+static void find_btr_def_group (btr_def_group **, btr_def *);\n+static btr_def *add_btr_def (btr_heap_t *, basic_block, int, rtx_insn *,\n+\t\t\t    unsigned int, int, btr_def_group **);\n+static btr_user *new_btr_user (basic_block, int, rtx_insn *);\n static void dump_hard_reg_set (HARD_REG_SET);\n static void dump_btrs_live (int);\n-static void note_other_use_this_block (unsigned int, btr_user);\n-static void compute_defs_uses_and_gen (btr_heap_t *, btr_def *,btr_user *,\n+static void note_other_use_this_block (unsigned int, btr_user *);\n+static void compute_defs_uses_and_gen (btr_heap_t *, btr_def **, btr_user **,\n \t\t\t\t       sbitmap *, sbitmap *, HARD_REG_SET *);\n static void compute_kill (sbitmap *, sbitmap *, HARD_REG_SET *);\n static void compute_out (sbitmap *bb_out, sbitmap *, sbitmap *, int);\n-static void link_btr_uses (btr_def *, btr_user *, sbitmap *, sbitmap *, int);\n+static void link_btr_uses (btr_def **, btr_user **, sbitmap *, sbitmap *, int);\n static void build_btr_def_use_webs (btr_heap_t *);\n-static int block_at_edge_of_live_range_p (int, btr_def);\n-static void clear_btr_from_live_range (btr_def def);\n-static void add_btr_to_live_range (btr_def, int);\n+static int block_at_edge_of_live_range_p (int, btr_def *);\n+static void clear_btr_from_live_range (btr_def *def);\n+static void add_btr_to_live_range (btr_def *, int);\n static void augment_live_range (bitmap, HARD_REG_SET *, basic_block,\n \t\t\t\tbasic_block, int);\n static int choose_btr (HARD_REG_SET);\n-static void combine_btr_defs (btr_def, HARD_REG_SET *);\n-static void btr_def_live_range (btr_def, HARD_REG_SET *);\n-static void move_btr_def (basic_block, int, btr_def, bitmap, HARD_REG_SET *);\n-static int migrate_btr_def (btr_def, int);\n+static void combine_btr_defs (btr_def *, HARD_REG_SET *);\n+static void btr_def_live_range (btr_def *, HARD_REG_SET *);\n+static void move_btr_def (basic_block, int, btr_def *, bitmap, HARD_REG_SET *);\n+static int migrate_btr_def (btr_def *, int);\n static void migrate_btr_defs (enum reg_class, int);\n static int can_move_up (const_basic_block, const rtx_insn *, int);\n static void note_btr_set (rtx, const_rtx, void *);\n@@ -257,11 +259,11 @@ insn_sets_btr_p (const rtx_insn *insn, int check_const, int *regno)\n    to in the list starting with *ALL_BTR_DEF_GROUPS.  If no such\n    group exists, create one.  Add def to the group.  */\n static void\n-find_btr_def_group (btr_def_group *all_btr_def_groups, btr_def def)\n+find_btr_def_group (btr_def_group **all_btr_def_groups, btr_def *def)\n {\n   if (insn_sets_btr_p (def->insn, 1, NULL))\n     {\n-      btr_def_group this_group;\n+      btr_def_group *this_group;\n       rtx def_src = SET_SRC (single_set (def->insn));\n \n       /* ?? This linear search is an efficiency concern, particularly\n@@ -274,7 +276,7 @@ find_btr_def_group (btr_def_group *all_btr_def_groups, btr_def def)\n \n       if (!this_group)\n \t{\n-\t  this_group = XOBNEW (&migrate_btrl_obstack, struct btr_def_group_s);\n+\t  this_group = XOBNEW (&migrate_btrl_obstack, btr_def_group);\n \t  this_group->src = def_src;\n \t  this_group->members = NULL;\n \t  this_group->next = *all_btr_def_groups;\n@@ -291,13 +293,13 @@ find_btr_def_group (btr_def_group *all_btr_def_groups, btr_def def)\n /* Create a new target register definition structure, for a definition in\n    block BB, instruction INSN, and insert it into ALL_BTR_DEFS.  Return\n    the new definition.  */\n-static btr_def\n+static btr_def *\n add_btr_def (btr_heap_t *all_btr_defs, basic_block bb, int insn_luid,\n \t     rtx_insn *insn,\n \t     unsigned int dest_reg, int other_btr_uses_before_def,\n-\t     btr_def_group *all_btr_def_groups)\n+\t     btr_def_group **all_btr_def_groups)\n {\n-  btr_def this_def = XOBNEW (&migrate_btrl_obstack, struct btr_def_s);\n+  btr_def *this_def = XOBNEW (&migrate_btrl_obstack, btr_def);\n   this_def->bb = bb;\n   this_def->luid = insn_luid;\n   this_def->insn = insn;\n@@ -325,7 +327,7 @@ add_btr_def (btr_heap_t *all_btr_defs, basic_block bb, int insn_luid,\n \n /* Create a new target register user structure, for a use in block BB,\n    instruction INSN.  Return the new user.  */\n-static btr_user\n+static btr_user *\n new_btr_user (basic_block bb, int insn_luid, rtx_insn *insn)\n {\n   /* This instruction reads target registers.  We need\n@@ -334,7 +336,7 @@ new_btr_user (basic_block bb, int insn_luid, rtx_insn *insn)\n    */\n   rtx *usep = find_btr_use (PATTERN (insn));\n   rtx use;\n-  btr_user user = NULL;\n+  btr_user *user = NULL;\n \n   if (usep)\n     {\n@@ -348,7 +350,7 @@ new_btr_user (basic_block bb, int insn_luid, rtx_insn *insn)\n \tusep = NULL;\n     }\n   use = usep ? *usep : NULL_RTX;\n-  user = XOBNEW (&migrate_btrl_obstack, struct btr_user_s);\n+  user = XOBNEW (&migrate_btrl_obstack, btr_user);\n   user->bb = bb;\n   user->luid = insn_luid;\n   user->insn = insn;\n@@ -395,17 +397,17 @@ dump_btrs_live (int bb)\n    If any of them use the same register, set their other_use_this_block\n    flag.  */\n static void\n-note_other_use_this_block (unsigned int regno, btr_user users_this_bb)\n+note_other_use_this_block (unsigned int regno, btr_user *users_this_bb)\n {\n-  btr_user user;\n+  btr_user *user;\n \n   for (user = users_this_bb; user != NULL; user = user->next)\n     if (user->use && REGNO (user->use) == regno)\n       user->other_use_this_block = 1;\n }\n \n struct defs_uses_info {\n-  btr_user users_this_bb;\n+  btr_user *users_this_bb;\n   HARD_REG_SET btrs_written_in_block;\n   HARD_REG_SET btrs_live_in_block;\n   sbitmap bb_gen;\n@@ -438,8 +440,8 @@ note_btr_set (rtx dest, const_rtx set ATTRIBUTE_UNUSED, void *data)\n }\n \n static void\n-compute_defs_uses_and_gen (btr_heap_t *all_btr_defs, btr_def *def_array,\n-\t\t\t   btr_user *use_array, sbitmap *btr_defset,\n+compute_defs_uses_and_gen (btr_heap_t *all_btr_defs, btr_def **def_array,\n+\t\t\t   btr_user **use_array, sbitmap *btr_defset,\n \t\t\t   sbitmap *bb_gen, HARD_REG_SET *btrs_written)\n {\n   /* Scan the code building up the set of all defs and all uses.\n@@ -450,15 +452,15 @@ compute_defs_uses_and_gen (btr_heap_t *all_btr_defs, btr_def *def_array,\n   */\n   int i;\n   int insn_luid = 0;\n-  btr_def_group all_btr_def_groups = NULL;\n+  btr_def_group *all_btr_def_groups = NULL;\n   defs_uses_info info;\n \n   bitmap_vector_clear (bb_gen, last_basic_block_for_fn (cfun));\n   for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n       int reg;\n-      btr_def defs_this_bb = NULL;\n+      btr_def *defs_this_bb = NULL;\n       rtx_insn *insn;\n       rtx_insn *last;\n       int can_throw = 0;\n@@ -485,7 +487,7 @@ compute_defs_uses_and_gen (btr_heap_t *all_btr_defs, btr_def *def_array,\n \n \t      if (insn_sets_btr_p (insn, 0, &regno))\n \t\t{\n-\t\t  btr_def def = add_btr_def (\n+\t\t  btr_def *def = add_btr_def (\n \t\t      all_btr_defs, bb, insn_luid, insn, regno,\n \t\t      TEST_HARD_REG_BIT (info.btrs_live_in_block, regno),\n \t\t      &all_btr_def_groups);\n@@ -505,7 +507,7 @@ compute_defs_uses_and_gen (btr_heap_t *all_btr_defs, btr_def *def_array,\n \t      else if (cfun->has_nonlocal_label\n \t\t       && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE)\n \t\t{\n-\t\t  btr_user user;\n+\t\t  btr_user *user;\n \n \t\t  /* Do the equivalent of calling note_other_use_this_block\n \t\t     for every target register.  */\n@@ -521,7 +523,7 @@ compute_defs_uses_and_gen (btr_heap_t *all_btr_defs, btr_def *def_array,\n \t\t{\n \t\t  if (find_btr_use (PATTERN (insn)))\n \t\t    {\n-\t\t      btr_user user = new_btr_user (bb, insn_luid, insn);\n+\t\t      btr_user *user = new_btr_user (bb, insn_luid, insn);\n \n \t\t      use_array[insn_uid] = user;\n \t\t      if (user->use)\n@@ -655,7 +657,7 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n }\n \n static void\n-link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n+link_btr_uses (btr_def **def_array, btr_user **use_array, sbitmap *bb_out,\n \t       sbitmap *btr_defset, int max_uid)\n {\n   int i;\n@@ -678,8 +680,8 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t    {\n \t      int insn_uid = INSN_UID (insn);\n \n-\t      btr_def def   = def_array[insn_uid];\n-\t      btr_user user = use_array[insn_uid];\n+\t      btr_def *def   = def_array[insn_uid];\n+\t      btr_user *user = use_array[insn_uid];\n \t      if (def != NULL)\n \t\t{\n \t\t  /* Remove all reaching defs of regno except\n@@ -716,7 +718,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t    }\n \t\t  EXECUTE_IF_SET_IN_BITMAP (reaching_defs_of_reg, 0, uid, sbi)\n \t\t    {\n-\t\t      btr_def def = def_array[uid];\n+\t\t      btr_def *def = def_array[uid];\n \n \t\t      /* We now know that def reaches user.  */\n \n@@ -770,8 +772,8 @@ static void\n build_btr_def_use_webs (btr_heap_t *all_btr_defs)\n {\n   const int max_uid = get_max_uid ();\n-  btr_def  *def_array   = XCNEWVEC (btr_def, max_uid);\n-  btr_user *use_array   = XCNEWVEC (btr_user, max_uid);\n+  btr_def  **def_array   = XCNEWVEC (btr_def *, max_uid);\n+  btr_user **use_array   = XCNEWVEC (btr_user *, max_uid);\n   sbitmap *btr_defset   = sbitmap_vector_alloc (\n \t\t\t   (last_btr - first_btr) + 1, max_uid);\n   sbitmap *bb_gen = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n@@ -808,14 +810,14 @@ build_btr_def_use_webs (btr_heap_t *all_btr_defs)\n    live range of the definition DEF, AND there are other live\n    ranges of the same target register that include BB.  */\n static int\n-block_at_edge_of_live_range_p (int bb, btr_def def)\n+block_at_edge_of_live_range_p (int bb, btr_def *def)\n {\n   if (def->other_btr_uses_before_def\n       && BASIC_BLOCK_FOR_FN (cfun, bb) == def->bb)\n     return 1;\n   else if (def->other_btr_uses_after_use)\n     {\n-      btr_user user;\n+      btr_user *user;\n       for (user = def->uses; user != NULL; user = user->next)\n \tif (BASIC_BLOCK_FOR_FN (cfun, bb) == user->bb)\n \t  return 1;\n@@ -832,7 +834,7 @@ block_at_edge_of_live_range_p (int bb, btr_def def)\n    to remove the target register from the live set of these blocks\n    only if they do not contain other live ranges for the same register.  */\n static void\n-clear_btr_from_live_range (btr_def def)\n+clear_btr_from_live_range (btr_def *def)\n {\n   unsigned bb;\n   bitmap_iterator bi;\n@@ -860,7 +862,7 @@ clear_btr_from_live_range (btr_def def)\n    If OWN_END is set, also show that the register is live from our\n    definitions at the end of the basic block where it is defined.  */\n static void\n-add_btr_to_live_range (btr_def def, int own_end)\n+add_btr_to_live_range (btr_def *def, int own_end)\n {\n   unsigned bb;\n   bitmap_iterator bi;\n@@ -1003,11 +1005,11 @@ choose_btr (HARD_REG_SET used_btrs)\n    in this live range, but ignore the live range represented by DEF\n    when calculating this set.  */\n static void\n-btr_def_live_range (btr_def def, HARD_REG_SET *btrs_live_in_range)\n+btr_def_live_range (btr_def *def, HARD_REG_SET *btrs_live_in_range)\n {\n   if (!def->live_range)\n     {\n-      btr_user user;\n+      btr_user *user;\n \n       def->live_range = BITMAP_ALLOC (NULL);\n \n@@ -1050,9 +1052,9 @@ btr_def_live_range (btr_def def, HARD_REG_SET *btrs_live_in_range)\n    group that are dominated by DEF, provided that there is a target\n    register available to allocate to the merged web.  */\n static void\n-combine_btr_defs (btr_def def, HARD_REG_SET *btrs_live_in_range)\n+combine_btr_defs (btr_def *def, HARD_REG_SET *btrs_live_in_range)\n {\n-  btr_def other_def;\n+  btr_def *other_def;\n \n   for (other_def = def->group->members;\n        other_def != NULL;\n@@ -1070,7 +1072,7 @@ combine_btr_defs (btr_def def, HARD_REG_SET *btrs_live_in_range)\n \t  int btr;\n \t  HARD_REG_SET combined_btrs_live;\n \t  bitmap combined_live_range = BITMAP_ALLOC (NULL);\n-\t  btr_user user;\n+\t  btr_user *user;\n \n \t  if (other_def->live_range == NULL)\n \t    {\n@@ -1100,7 +1102,7 @@ combine_btr_defs (btr_def def, HARD_REG_SET *btrs_live_in_range)\n \t      user = other_def->uses;\n \t      while (user != NULL)\n \t\t{\n-\t\t  btr_user next = user->next;\n+\t\t  btr_user *next = user->next;\n \n \t\t  user->next = def->uses;\n \t\t  def->uses = user;\n@@ -1139,7 +1141,7 @@ combine_btr_defs (btr_def def, HARD_REG_SET *btrs_live_in_range)\n    If this new position means that other defs in the\n    same group can be combined with DEF then combine them.  */\n static void\n-move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n+move_btr_def (basic_block new_def_bb, int btr, btr_def *def, bitmap live_range,\n \t     HARD_REG_SET *btrs_live_in_range)\n {\n   /* We can move the instruction.\n@@ -1154,7 +1156,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n   rtx btr_rtx;\n   rtx_insn *new_insn;\n   machine_mode btr_mode;\n-  btr_user user;\n+  btr_user *user;\n   rtx set;\n \n   if (dump_file)\n@@ -1264,7 +1266,7 @@ can_move_up (const_basic_block bb, const rtx_insn *insn, int n_insns)\n    MIN_COST, but we may be able to reduce it further).\n    Return zero if no further migration is possible.  */\n static int\n-migrate_btr_def (btr_def def, int min_cost)\n+migrate_btr_def (btr_def *def, int min_cost)\n {\n   bitmap live_range;\n   HARD_REG_SET btrs_live_in_range;\n@@ -1273,7 +1275,7 @@ migrate_btr_def (btr_def def, int min_cost)\n   basic_block attempt;\n   int give_up = 0;\n   int def_moved = 0;\n-  btr_user user;\n+  btr_user *user;\n   int def_latency;\n \n   if (dump_file)\n@@ -1432,7 +1434,7 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n   while (!all_btr_defs.empty ())\n     {\n       int min_cost = -all_btr_defs.min_key ();\n-      btr_def def = all_btr_defs.extract_min ();\n+      btr_def *def = all_btr_defs.extract_min ();\n       if (migrate_btr_def (def, min_cost))\n \t{\n \t  all_btr_defs.insert (-def->cost, def);"}]}