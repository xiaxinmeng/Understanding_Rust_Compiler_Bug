{"sha": "d092494cf3665e8c1d7725fa51c48ecd6023d585", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA5MjQ5NGNmMzY2NWU4YzFkNzcyNWZhNTFjNDhlY2Q2MDIzZDU4NQ==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-11-03T08:44:35Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-11-03T08:44:35Z"}, "message": "re PR tree-optimization/50912 (gimple assertion failure at gimple.h:1940 with -msse2)\n\n\n\tPR tree-optimization/50912\n\t* tree-vectorizer.h (slp_void_p): New.\n\t(struct _slp_tree): Replace left and right with children.  Update\n\tdocumentation.\n\t(struct _slp_oprnd_info): New.\n\t(vect_get_vec_defs): Declare.\n\t(vect_get_slp_defs): Update arguments.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Call\n\tvect_get_vec_defs instead of vect_get_slp_defs.\n\t(vectorizable_reduction): Likewise.\n\t* tree-vect-stmts.c (vect_get_vec_defs): Remove static, add argument.\n\tUpdate call to vect_get_slp_defs.\n\t(vectorizable_conversion): Update call to vect_get_vec_defs.\n\t(vectorizable_assignment, vectorizable_shift,\n\tvectorizable_operation): Likewise.\n\t(vectorizable_type_demotion): Call vect_get_vec_defs instead of\n\tvect_get_slp_defs.\n\t(vectorizable_type_promotion, vectorizable_store): Likewise.\n\t(vect_analyze_stmt): Fix typo.\n\t* tree-vect-slp.c (vect_free_slp_tree): Update SLP tree traversal.\n\t(vect_print_slp_tree, vect_mark_slp_stmts,\n\tvect_mark_slp_stmts_relevant, vect_slp_rearrange_stmts,\n\tvect_detect_hybrid_slp_stmts, vect_slp_analyze_node_operations,\n\tvect_schedule_slp_instance): Likewise.\n\t(vect_create_new_slp_node): New.\n\t(vect_create_oprnd_info, vect_free_oprnd_info): Likewise.\n\t(vect_get_and_check_slp_defs): Pass information about defs using\n\toprnds_info, allow any number of operands.\n\t(vect_build_slp_tree): Likewise.  Update calls to\n\tvect_get_and_check_slp_defs.  Fix comments.\n\t(vect_analyze_slp_instance): Move node creation to\n\tvect_create_new_slp_node.\n\t(vect_get_slp_defs): Allow any number of operands.\n\nFrom-SVN: r180819", "tree": {"sha": "4a3e5280c77376f6cbc8b2adb845491b1fb646f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a3e5280c77376f6cbc8b2adb845491b1fb646f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d092494cf3665e8c1d7725fa51c48ecd6023d585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d092494cf3665e8c1d7725fa51c48ecd6023d585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d092494cf3665e8c1d7725fa51c48ecd6023d585", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d092494cf3665e8c1d7725fa51c48ecd6023d585/comments", "author": null, "committer": null, "parents": [{"sha": "d2a7d041b640b8a28d82de1155a5b166d1682d48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a7d041b640b8a28d82de1155a5b166d1682d48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a7d041b640b8a28d82de1155a5b166d1682d48"}], "stats": {"total": 909, "additions": 534, "deletions": 375}, "files": [{"sha": "27118895782171e28f285c3afc7aa696cdd70321", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -1,3 +1,39 @@\n+2011-11-03  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\tPR tree-optimization/50912\n+\t* tree-vectorizer.h (slp_void_p): New.\n+\t(struct _slp_tree): Replace left and right with children.  Update\n+\tdocumentation.\n+\t(struct _slp_oprnd_info): New.\n+\t(vect_get_vec_defs): Declare.\n+\t(vect_get_slp_defs): Update arguments.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Call\n+\tvect_get_vec_defs instead of vect_get_slp_defs.\n+\t(vectorizable_reduction): Likewise.\n+\t* tree-vect-stmts.c (vect_get_vec_defs): Remove static, add argument.\n+\tUpdate call to vect_get_slp_defs.\n+\t(vectorizable_conversion): Update call to vect_get_vec_defs.\n+\t(vectorizable_assignment, vectorizable_shift,\n+\tvectorizable_operation): Likewise.\n+\t(vectorizable_type_demotion): Call vect_get_vec_defs instead of\n+\tvect_get_slp_defs.\n+\t(vectorizable_type_promotion, vectorizable_store): Likewise.\n+\t(vect_analyze_stmt): Fix typo.\n+\t* tree-vect-slp.c (vect_free_slp_tree): Update SLP tree traversal.\n+\t(vect_print_slp_tree, vect_mark_slp_stmts,\n+\tvect_mark_slp_stmts_relevant, vect_slp_rearrange_stmts,\n+\tvect_detect_hybrid_slp_stmts, vect_slp_analyze_node_operations,\n+\tvect_schedule_slp_instance): Likewise.\n+\t(vect_create_new_slp_node): New.\n+\t(vect_create_oprnd_info, vect_free_oprnd_info): Likewise.\n+\t(vect_get_and_check_slp_defs): Pass information about defs using\n+\toprnds_info, allow any number of operands.\n+\t(vect_build_slp_tree): Likewise.  Update calls to\n+\tvect_get_and_check_slp_defs.  Fix comments.\n+\t(vect_analyze_slp_instance): Move node creation to\n+\tvect_create_new_slp_node.\n+\t(vect_get_slp_defs): Allow any number of operands.\n+\n 2011-11-02  Peter Bergner  <bergner@vnet.ibm.com>\n \t    Iain Sandoe  <iains@gcc.gnu.org>\n "}, {"sha": "305ba6a64553136cc3fdbda9bd3ebdddba7c4a63", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -1,3 +1,9 @@\n+2011-11-03  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\tPR tree-optimization/50912\n+\t* gnat.dg/loop_optimization10.ad[sb]: New test.\n+\t* gnat.dg/loop_optimization10_pkg.ads: New helper.\n+\n 2011-11-02  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/50930"}, {"sha": "3b8e8949e1a2631d80e7720a21d6bdadfc4370d3", "filename": "gcc/testsuite/gnat.dg/loop_optimization10.adb", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10.adb?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -0,0 +1,18 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O3\" }\n+-- { dg-options \"-O3 -msse2\" { target i?86-*-* x86_64-*-* } }\n+\n+package body Loop_Optimization10 is\n+\n+   function F (Low, High : in Array_Real_Type) return Array_Limit_Type is\n+      Result : Array_Limit_Type;\n+   begin\n+      for I in Result'Range\n+      loop\n+         Result (I) := F (Low (I), High (I));\n+      end loop;\n+      return Result;\n+   end;\n+\n+end Loop_Optimization10;\n+"}, {"sha": "2f4872d1b5a7bad77a3246ec7038df6f3ac00aa8", "filename": "gcc/testsuite/gnat.dg/loop_optimization10.ads", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10.ads?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -0,0 +1,11 @@\n+with Loop_Optimization10_Pkg; use Loop_Optimization10_Pkg;\n+package Loop_Optimization10 is\n+\n+   type Dual_Axis_Type is (One, Two);\n+\n+   type Array_Real_Type    is array (Dual_Axis_Type) of Float;\n+   type Array_Limit_Type   is array (Dual_Axis_Type) of Limit_Type;\n+\n+   function F (Low, High : in Array_Real_Type) return Array_Limit_Type;\n+\n+end Loop_Optimization10;"}, {"sha": "6fce4df8a3e751731c016659b82a5c8b5c791b3d", "filename": "gcc/testsuite/gnat.dg/loop_optimization10_pkg.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_optimization10_pkg.ads?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -0,0 +1,12 @@\n+package Loop_Optimization10_Pkg is\n+\n+   pragma Pure (Loop_Optimization10_Pkg);\n+\n+   type Limit_Type is record\n+      Low  : Float;\n+      High : Float;\n+   end record;\n+\n+   function F (Low, High : in Float) return Limit_Type;\n+\n+end Loop_Optimization10_Pkg;"}, {"sha": "6dfc7629a60e495b32ba21253b2918ed94741a84", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -2524,7 +2524,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n   VEC (data_reference_p, heap) *datarefs;\n   struct data_reference *dr;\n   tree scalar_type;\n-  bool res, stop_bb_analysis = false;\n+  bool res;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs ===\\n\");\n@@ -2586,12 +2586,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n \n-      if (stop_bb_analysis)\n-        {\n-          STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-          continue;\n-        }\n-\n       /* Check that analysis of the data-ref succeeded.  */\n       if (!DR_BASE_ADDRESS (dr) || !DR_OFFSET (dr) || !DR_INIT (dr)\n           || !DR_STEP (dr))\n@@ -2602,13 +2596,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n \n-          if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n-\n           return false;\n         }\n \n@@ -2617,15 +2604,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n             fprintf (vect_dump, \"not vectorized: base addr of dr is a \"\n                      \"constant\");\n-\n-          if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n-\n-           return false;\n+          return false;\n         }\n \n       if (TREE_THIS_VOLATILE (DR_REF (dr)))\n@@ -2635,14 +2614,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               fprintf (vect_dump, \"not vectorized: volatile type \");\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n-\n-          if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n-\n           return false;\n         }\n \n@@ -2658,14 +2629,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                        \"exception \");\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n-\n-          if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n-\n           return false;\n         }\n \n@@ -2783,14 +2746,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                        \"not vectorized: more than one data ref in stmt: \");\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n-\n-          if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n-\n           return false;\n         }\n \n@@ -2815,7 +2770,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n             {\n               /* Mark the statement as not vectorizable.  */\n               STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n               continue;\n             }\n           else"}, {"sha": "1598899868772ce16c131e71d58f5645209034b1", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -3537,8 +3537,8 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n   /* Get the loop-entry arguments.  */\n   if (slp_node)\n-    vect_get_slp_defs (reduction_op, NULL_TREE, slp_node, &vec_initial_defs,\n-                       NULL, reduc_index);\n+    vect_get_vec_defs (reduction_op, NULL_TREE, stmt, &vec_initial_defs,\n+                       NULL, slp_node, reduc_index);\n   else\n     {\n       vec_initial_defs = VEC_alloc (tree, heap, 1);\n@@ -4792,8 +4792,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n             }\n \n           if (slp_node)\n-            vect_get_slp_defs (op0, op1, slp_node, &vec_oprnds0, &vec_oprnds1,\n-                               -1);\n+            vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,\n+                               slp_node, -1);\n           else\n             {\n               loop_vec_def0 = vect_get_vec_def_for_operand (ops[!reduc_index],"}, {"sha": "eab5e4067dcd9b20aa1599a1c17bd462cadb8f42", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 372, "deletions": 293, "changes": 665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -68,14 +68,14 @@ find_bb_location (basic_block bb)\n static void\n vect_free_slp_tree (slp_tree node)\n {\n+  int i;\n+  slp_void_p child;\n+\n   if (!node)\n     return;\n \n-  if (SLP_TREE_LEFT (node))\n-    vect_free_slp_tree (SLP_TREE_LEFT (node));\n-\n-  if (SLP_TREE_RIGHT (node))\n-    vect_free_slp_tree (SLP_TREE_RIGHT (node));\n+  FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n+    vect_free_slp_tree ((slp_tree)child);\n \n   VEC_free (gimple, heap, SLP_TREE_SCALAR_STMTS (node));\n \n@@ -97,48 +97,117 @@ vect_free_slp_instance (slp_instance instance)\n }\n \n \n-/* Get the defs for the rhs of STMT (collect them in DEF_STMTS0/1), check that\n-   they are of a legal type and that they match the defs of the first stmt of\n-   the SLP group (stored in FIRST_STMT_...).  */\n+/* Create an SLP node for SCALAR_STMTS.  */\n+\n+static slp_tree\n+vect_create_new_slp_node (VEC (gimple, heap) *scalar_stmts)\n+{\n+  slp_tree node = XNEW (struct _slp_tree);\n+  gimple stmt = VEC_index (gimple, scalar_stmts, 0);\n+  unsigned int nops;\n+\n+  if (is_gimple_call (stmt))\n+    nops = gimple_call_num_args (stmt);\n+  else if (is_gimple_assign (stmt))\n+    nops = gimple_num_ops (stmt) - 1;\n+  else\n+    return NULL;\n+\n+  SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n+  SLP_TREE_VEC_STMTS (node) = NULL;\n+  SLP_TREE_CHILDREN (node) = VEC_alloc (slp_void_p, heap, nops);\n+  SLP_TREE_OUTSIDE_OF_LOOP_COST (node) = 0;\n+  SLP_TREE_INSIDE_OF_LOOP_COST (node) = 0;\n+\n+  return node;\n+}\n+\n+\n+/* Allocate operands info for NOPS operands, and GROUP_SIZE def-stmts for each\n+   operand.  */\n+static VEC (slp_oprnd_info, heap) *\n+vect_create_oprnd_info (int nops, int group_size)\n+{\n+  int i;\n+  slp_oprnd_info oprnd_info;\n+  VEC (slp_oprnd_info, heap) *oprnds_info;\n+\n+  oprnds_info = VEC_alloc (slp_oprnd_info, heap, nops);\n+  for (i = 0; i < nops; i++)\n+    {\n+      oprnd_info = XNEW (struct _slp_oprnd_info);\n+      oprnd_info->def_stmts = VEC_alloc (gimple, heap, group_size);\n+      oprnd_info->first_dt = vect_uninitialized_def;\n+      oprnd_info->first_def_type = NULL_TREE;\n+      oprnd_info->first_const_oprnd = NULL_TREE;\n+      oprnd_info->first_pattern = false;\n+      VEC_quick_push (slp_oprnd_info, oprnds_info, oprnd_info);\n+    }\n+\n+  return oprnds_info;\n+}\n+\n+\n+/* Free operands info.  Free def-stmts in FREE_DEF_STMTS is true.\n+   (FREE_DEF_STMTS is true when the SLP analysis fails, and false when it\n+   succeds.  In the later case we don't need the operands info that we used to\n+   check isomorphism of the stmts, but we still need the def-stmts - they are\n+   used as scalar stmts in SLP nodes.  */\n+static void\n+vect_free_oprnd_info (VEC (slp_oprnd_info, heap) **oprnds_info,\n+                      bool free_def_stmts)\n+{\n+  int i;\n+  slp_oprnd_info oprnd_info;\n+\n+  if (free_def_stmts)\n+    FOR_EACH_VEC_ELT (slp_oprnd_info, *oprnds_info, i, oprnd_info)\n+      VEC_free (gimple, heap, oprnd_info->def_stmts);\n+\n+  VEC_free (slp_oprnd_info, heap, *oprnds_info);\n+}\n+\n+\n+/* Get the defs for the rhs of STMT (collect them in OPRNDS_INFO), check that\n+   they are of a valid type and that they match the defs of the first stmt of\n+   the SLP group (stored in OPRNDS_INFO).  */\n \n static bool\n vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                              slp_tree slp_node, gimple stmt,\n-\t\t\t     VEC (gimple, heap) **def_stmts0,\n-\t\t\t     VEC (gimple, heap) **def_stmts1,\n-\t\t\t     enum vect_def_type *first_stmt_dt0,\n-\t\t\t     enum vect_def_type *first_stmt_dt1,\n-\t\t\t     tree *first_stmt_def0_type,\n-\t\t\t     tree *first_stmt_def1_type,\n-\t\t\t     tree *first_stmt_const_oprnd,\n-\t\t\t     int ncopies_for_cost,\n-                             bool *pattern0, bool *pattern1)\n+\t\t\t     int ncopies_for_cost, bool first,\n+                             VEC (slp_oprnd_info, heap) **oprnds_info)\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n-  tree def[2];\n+  tree def, def_op0 = NULL_TREE;\n   gimple def_stmt;\n-  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n-  stmt_vec_info stmt_info =\n-    vinfo_for_stmt (VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0));\n-  enum gimple_rhs_class rhs_class;\n+  enum vect_def_type dt = vect_uninitialized_def;\n+  enum vect_def_type dt_op0 = vect_uninitialized_def;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree lhs = gimple_get_lhs (stmt);\n   struct loop *loop = NULL;\n   enum tree_code rhs_code;\n   bool different_types = false;\n+  bool pattern = false;\n+  slp_oprnd_info oprnd_info, oprnd0_info, oprnd1_info;\n \n   if (loop_vinfo)\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n-  rhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (stmt));\n-  number_of_oprnds = gimple_num_ops (stmt) - 1;\t/* RHS only */\n+  if (is_gimple_call (stmt))\n+    number_of_oprnds = gimple_call_num_args (stmt);\n+  else\n+    number_of_oprnds = gimple_num_ops (stmt) - 1;\n \n   for (i = 0; i < number_of_oprnds; i++)\n     {\n       oprnd = gimple_op (stmt, i + 1);\n+      oprnd_info = VEC_index (slp_oprnd_info, *oprnds_info, i);\n \n-      if (!vect_is_simple_use (oprnd, loop_vinfo, bb_vinfo, &def_stmt, &def[i],\n-                               &dt[i])\n-\t  || (!def_stmt && dt[i] != vect_constant_def))\n+      if (!vect_is_simple_use (oprnd, loop_vinfo, bb_vinfo, &def_stmt, &def,\n+                               &dt)\n+\t  || (!def_stmt && dt != vect_constant_def))\n \t{\n \t  if (vect_print_dump_info (REPORT_SLP))\n \t    {\n@@ -159,29 +228,24 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           && !STMT_VINFO_RELEVANT (vinfo_for_stmt (def_stmt))\n           && !STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt)))\n         {\n-          if (!*first_stmt_dt0)\n-            *pattern0 = true;\n-          else\n-            {\n-              if (i == 1 && !*first_stmt_dt1)\n-                *pattern1 = true;\n-              else if ((i == 0 && !*pattern0) || (i == 1 && !*pattern1))\n-                {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    {\n-                      fprintf (vect_dump, \"Build SLP failed: some of the stmts\"\n-                                     \" are in a pattern, and others are not \");\n-                      print_generic_expr (vect_dump, oprnd, TDF_SLIM);\n-                    }\n+          pattern = true;\n+          if (!first && !oprnd_info->first_pattern)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t{\n+\t\t  fprintf (vect_dump, \"Build SLP failed: some of the stmts\"\n+\t\t\t\t\" are in a pattern, and others are not \");\n+\t\t  print_generic_expr (vect_dump, oprnd, TDF_SLIM);\n+\t\t}\n \n-                  return false;\n-                }\n+\t      return false;\n             }\n \n           def_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt));\n-          dt[i] = STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def_stmt));\n+          dt = STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def_stmt));\n \n-          if (*dt == vect_unknown_def_type)\n+          if (dt == vect_unknown_def_type\n+\t      || STMT_VINFO_PATTERN_DEF_STMT (vinfo_for_stmt (def_stmt)))\n             {\n               if (vect_print_dump_info (REPORT_DETAILS))\n                 fprintf (vect_dump, \"Unsupported pattern.\");\n@@ -191,11 +255,11 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           switch (gimple_code (def_stmt))\n             {\n               case GIMPLE_PHI:\n-                def[i] = gimple_phi_result (def_stmt);\n+                def = gimple_phi_result (def_stmt);\n                 break;\n \n               case GIMPLE_ASSIGN:\n-                def[i] = gimple_assign_lhs (def_stmt);\n+                def = gimple_assign_lhs (def_stmt);\n                 break;\n \n               default:\n@@ -205,133 +269,133 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             }\n         }\n \n-      if (!*first_stmt_dt0)\n+      if (first)\n \t{\n-\t  /* op0 of the first stmt of the group - store its info.  */\n-\t  *first_stmt_dt0 = dt[i];\n-\t  if (def[i])\n-\t    *first_stmt_def0_type = TREE_TYPE (def[i]);\n+\t  oprnd_info->first_dt = dt;\n+\t  oprnd_info->first_pattern = pattern;\n+\t  if (def)\n+\t    {\n+\t      oprnd_info->first_def_type = TREE_TYPE (def);\n+\t      oprnd_info->first_const_oprnd = NULL_TREE;\n+\t    }\n \t  else\n-\t    *first_stmt_const_oprnd = oprnd;\n+            {\n+              oprnd_info->first_def_type = NULL_TREE;\n+              oprnd_info->first_const_oprnd = oprnd;\n+            }\n \n-\t  /* Analyze costs (for the first stmt of the group only).  */\n-\t  if (rhs_class != GIMPLE_SINGLE_RHS)\n-\t    /* Not memory operation (we don't call this functions for loads).  */\n-\t    vect_model_simple_cost (stmt_info, ncopies_for_cost, dt, slp_node);\n-\t  else\n-\t    /* Store.  */\n-\t    vect_model_store_cost (stmt_info, ncopies_for_cost, false,\n-\t\t\t\t   dt[0], slp_node);\n+\t  if (i == 0)\n+\t    {\n+\t      def_op0 = def;\n+\t      dt_op0 = dt;\n+\t      /* Analyze costs (for the first stmt of the group only).  */\n+\t      if (REFERENCE_CLASS_P (lhs))\n+\t\t/* Store.  */\n+                vect_model_store_cost (stmt_info, ncopies_for_cost, false,\n+                                        dt, slp_node);\n+\t      else\n+\t        /* Not memory operation (we don't call this function for\n+\t\t   loads).  */\n+\t\tvect_model_simple_cost (stmt_info, ncopies_for_cost, &dt,\n+\t\t\t\t\tslp_node);\n+\t    }\n \t}\n-\n       else\n \t{\n-\t  if (!*first_stmt_dt1 && i == 1)\n+\t  /* Not first stmt of the group, check that the def-stmt/s match\n+\t     the def-stmt/s of the first stmt.  Allow different definition\n+\t     types for reduction chains: the first stmt must be a\n+\t     vect_reduction_def (a phi node), and the rest\n+\t     vect_internal_def.  */\n+\t  if (((oprnd_info->first_dt != dt\n+                && !(oprnd_info->first_dt == vect_reduction_def\n+                     && dt == vect_internal_def))\n+               || (oprnd_info->first_def_type != NULL_TREE\n+\t\t   && def\n+\t\t   && !types_compatible_p (oprnd_info->first_def_type,\n+\t\t\t\t\t   TREE_TYPE (def))))\n+\t       || (!def\n+\t\t   && !types_compatible_p (TREE_TYPE (oprnd_info->first_const_oprnd),\n+\t\t\t\t\t   TREE_TYPE (oprnd)))\n+\t       || different_types)\n \t    {\n-\t      /* op1 of the first stmt of the group - store its info.  */\n-\t      *first_stmt_dt1 = dt[i];\n-\t      if (def[i])\n-\t\t*first_stmt_def1_type = TREE_TYPE (def[i]);\n-\t      else\n+\t      if (number_of_oprnds != 2)\n \t\t{\n-\t\t  /* We assume that the stmt contains only one constant\n-\t\t     operand. We fail otherwise, to be on the safe side.  */\n-\t\t  if (*first_stmt_const_oprnd)\n-\t\t    {\n-\t\t      if (vect_print_dump_info (REPORT_SLP))\n-\t\t\tfprintf (vect_dump, \"Build SLP failed: two constant \"\n-\t\t\t\t \"oprnds in stmt\");\n-\t\t      return false;\n-\t\t    }\n-\t\t  *first_stmt_const_oprnd = oprnd;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Not first stmt of the group, check that the def-stmt/s match\n-\t\t the def-stmt/s of the first stmt.  Allow different definition\n-\t\t types for reduction chains: the first stmt must be a\n-\t\t vect_reduction_def (a phi node), and the rest\n-\t\t vect_internal_def.  */\n-\t      if ((i == 0\n-\t\t   && ((*first_stmt_dt0 != dt[i]\n-                        && !(*first_stmt_dt0 == vect_reduction_def\n-                             && dt[i] == vect_internal_def))\n-\t\t       || (*first_stmt_def0_type && def[0]\n-\t\t\t   && !types_compatible_p (*first_stmt_def0_type,\n-\t\t\t\t\t\t   TREE_TYPE (def[0])))))\n-\t\t  || (i == 1\n-\t\t      && ((*first_stmt_dt1 != dt[i]\n-                           && !(*first_stmt_dt1 == vect_reduction_def\n-                                && dt[i] == vect_internal_def))\n-\t\t\t  || (*first_stmt_def1_type && def[1]\n-\t\t\t      && !types_compatible_p (*first_stmt_def1_type,\n-\t\t\t\t\t\t      TREE_TYPE (def[1])))))\n-\t\t  || (!def[i]\n-\t\t      && !types_compatible_p (TREE_TYPE (*first_stmt_const_oprnd),\n-\t\t\t\t\t      TREE_TYPE (oprnd)))\n-\t\t  || different_types)\n+\t\t  if (vect_print_dump_info (REPORT_SLP))\n+\t\t    fprintf (vect_dump, \"Build SLP failed: different types \");\n+\n+\t\t  return false;\n+                }\n+\n+\t      /* Try to swap operands in case of binary operation.  */\n+              if (i == 0)\n+                different_types = true;\n+              else\n \t\t{\n-                  if (i != number_of_oprnds - 1)\n-                    different_types = true;\n-                  else\n-\t            {\n-                      if (is_gimple_assign (stmt)\n-                          && (rhs_code = gimple_assign_rhs_code (stmt))\n- \t\t          && TREE_CODE_CLASS (rhs_code) == tcc_binary\n-\t\t\t  && commutative_tree_code (rhs_code)\n-\t\t\t  && *first_stmt_dt0 == dt[1]\n-\t\t\t  && *first_stmt_dt1 == dt[0]\n-\t\t\t  && def[0] && def[1]\n-\t\t\t  && !(*first_stmt_def0_type\n-\t\t\t       && !types_compatible_p (*first_stmt_def0_type,\n-\t\t\t                               TREE_TYPE (def[1])))\n-                          && !(*first_stmt_def1_type\n-                               && !types_compatible_p (*first_stmt_def1_type,\n-                                                       TREE_TYPE (def[0]))))\n-                        {\n-                           if (vect_print_dump_info (REPORT_SLP))\n-\t                     {\n-\t\t\t       fprintf (vect_dump, \"Swapping operands of \");\n- \t\t               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-\t\t\t     }\n-\n- \t\t\t   swap_tree_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n- \t                                      gimple_assign_rhs2_ptr (stmt));\n+\t\t  oprnd0_info = VEC_index (slp_oprnd_info, *oprnds_info, 0);\n+\t\t  if (is_gimple_assign (stmt)\n+\t\t      && (rhs_code = gimple_assign_rhs_code (stmt))\n+ \t\t      && TREE_CODE_CLASS (rhs_code) == tcc_binary\n+\t\t      && commutative_tree_code (rhs_code)\n+\t\t      && oprnd0_info->first_dt == dt\n+\t\t      && oprnd_info->first_dt == dt_op0\n+\t\t      && def_op0 && def\n+\t\t      && !(oprnd0_info->first_def_type\n+\t\t\t   && !types_compatible_p (oprnd0_info->first_def_type,\n+\t\t\t                           TREE_TYPE (def)))\n+                      && !(oprnd_info->first_def_type\n+                           && !types_compatible_p (oprnd_info->first_def_type,\n+                                                   TREE_TYPE (def_op0))))\n+                    {\n+                      if (vect_print_dump_info (REPORT_SLP))\n+\t                {\n+\t\t\t  fprintf (vect_dump, \"Swapping operands of \");\n+ \t\t          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t\t}\n-                      else\n-                        {\n-         \t\t  if (vect_print_dump_info (REPORT_SLP))\n-\t        \t    fprintf (vect_dump, \"Build SLP failed: different types \");\n \n-\t\t          return false;\n-\t\t\t}\n+ \t\t      swap_tree_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n+ \t                                  gimple_assign_rhs2_ptr (stmt));\n+\t\t    }\n+                  else\n+                    {\n+         \t      if (vect_print_dump_info (REPORT_SLP))\n+\t\t\tfprintf (vect_dump, \"Build SLP failed: different types \");\n+\n+\t\t      return false;\n \t\t    }\n \t\t}\n \t    }\n \t}\n \n       /* Check the types of the definitions.  */\n-      switch (dt[i])\n+      switch (dt)\n \t{\n \tcase vect_constant_def:\n \tcase vect_external_def:\n+        case vect_reduction_def:\n \t  break;\n \n \tcase vect_internal_def:\n-        case vect_reduction_def:\n-\t  if ((i == 0 && !different_types) || (i == 1 && different_types))\n-\t    VEC_safe_push (gimple, heap, *def_stmts0, def_stmt);\n+          if (different_types)\n+            {\n+\t      oprnd0_info = VEC_index (slp_oprnd_info, *oprnds_info, 0);\n+\t      oprnd1_info = VEC_index (slp_oprnd_info, *oprnds_info, 0);\n+              if (i == 0)\n+                VEC_quick_push (gimple, oprnd1_info->def_stmts, def_stmt);\n+              else\n+                VEC_quick_push (gimple, oprnd0_info->def_stmts, def_stmt);\n+            }\n \t  else\n- \t    VEC_safe_push (gimple, heap, *def_stmts1, def_stmt);\n+ \t    VEC_quick_push (gimple, oprnd_info->def_stmts, def_stmt);\n+\n \t  break;\n \n \tdefault:\n \t  /* FORNOW: Not supported.  */\n \t  if (vect_print_dump_info (REPORT_SLP))\n \t    {\n \t      fprintf (vect_dump, \"Build SLP failed: illegal type of def \");\n-\t      print_generic_expr (vect_dump, def[i], TDF_SLIM);\n+\t      print_generic_expr (vect_dump, def, TDF_SLIM);\n \t    }\n \n \t  return false;\n@@ -356,15 +420,10 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                      VEC (slp_tree, heap) **loads,\n                      unsigned int vectorization_factor, bool *loads_permuted)\n {\n-  VEC (gimple, heap) *def_stmts0 = VEC_alloc (gimple, heap, group_size);\n-  VEC (gimple, heap) *def_stmts1 =  VEC_alloc (gimple, heap, group_size);\n   unsigned int i;\n   VEC (gimple, heap) *stmts = SLP_TREE_SCALAR_STMTS (*node);\n   gimple stmt = VEC_index (gimple, stmts, 0);\n-  enum vect_def_type first_stmt_dt0 = vect_uninitialized_def;\n-  enum vect_def_type first_stmt_dt1 = vect_uninitialized_def;\n   enum tree_code first_stmt_code = ERROR_MARK, rhs_code = ERROR_MARK;\n-  tree first_stmt_def1_type = NULL_TREE, first_stmt_def0_type = NULL_TREE;\n   tree lhs;\n   bool stop_recursion = false, need_same_oprnds = false;\n   tree vectype, scalar_type, first_op1 = NULL_TREE;\n@@ -373,13 +432,21 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   int icode;\n   enum machine_mode optab_op2_mode;\n   enum machine_mode vec_mode;\n-  tree first_stmt_const_oprnd = NULL_TREE;\n   struct data_reference *first_dr;\n-  bool pattern0 = false, pattern1 = false;\n   HOST_WIDE_INT dummy;\n   bool permutation = false;\n   unsigned int load_place;\n   gimple first_load, prev_first_load = NULL;\n+  VEC (slp_oprnd_info, heap) *oprnds_info;\n+  unsigned int nops;\n+  slp_oprnd_info oprnd_info;\n+\n+  if (is_gimple_call (stmt))\n+    nops = gimple_call_num_args (stmt);\n+  else\n+    nops = gimple_num_ops (stmt) - 1;\n+\n+  oprnds_info = vect_create_oprnd_info (nops, group_size);\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   FOR_EACH_VEC_ELT (gimple, stmts, i, stmt)\n@@ -400,6 +467,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n \n+\t  vect_free_oprnd_info (&oprnds_info, true);\n           return false;\n         }\n \n@@ -409,10 +477,11 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  if (vect_print_dump_info (REPORT_SLP))\n \t    {\n \t      fprintf (vect_dump,\n-\t\t       \"Build SLP failed: not GIMPLE_ASSIGN nor GIMPLE_CALL\");\n+\t\t       \"Build SLP failed: not GIMPLE_ASSIGN nor GIMPLE_CALL \");\n \t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t    }\n \n+\t  vect_free_oprnd_info (&oprnds_info, true);\n \t  return false;\n \t}\n \n@@ -425,6 +494,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               fprintf (vect_dump, \"Build SLP failed: unsupported data-type \");\n               print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n             }\n+\n+\t  vect_free_oprnd_info (&oprnds_info, true);\n           return false;\n         }\n \n@@ -471,6 +542,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t    {\n \t\t      if (vect_print_dump_info (REPORT_SLP))\n \t\t\tfprintf (vect_dump, \"Build SLP failed: no optab.\");\n+\t  \t      vect_free_oprnd_info (&oprnds_info, true);\n \t\t      return false;\n \t\t    }\n \t\t  icode = (int) optab_handler (optab, vec_mode);\n@@ -479,6 +551,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t      if (vect_print_dump_info (REPORT_SLP))\n \t\t\tfprintf (vect_dump, \"Build SLP failed: \"\n \t\t\t\t            \"op not supported by target.\");\n+\t  \t      vect_free_oprnd_info (&oprnds_info, true);\n \t\t      return false;\n \t\t    }\n \t\t  optab_op2_mode = insn_data[icode].operand[2].mode;\n@@ -515,6 +588,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \n+\t      vect_free_oprnd_info (&oprnds_info, true);\n \t      return false;\n \t    }\n \n@@ -528,6 +602,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \n+\t      vect_free_oprnd_info (&oprnds_info, true);\n \t      return false;\n \t    }\n \t}\n@@ -539,15 +614,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t    {\n \t      /* Store.  */\n \t      if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node,\n-\t\t\t\t\t\tstmt, &def_stmts0, &def_stmts1,\n-\t\t\t\t\t\t&first_stmt_dt0,\n-\t\t\t\t\t\t&first_stmt_dt1,\n-\t\t\t\t\t\t&first_stmt_def0_type,\n-\t\t\t\t\t\t&first_stmt_def1_type,\n-\t\t\t\t\t\t&first_stmt_const_oprnd,\n-\t\t\t\t\t\tncopies_for_cost,\n-                                                &pattern0, &pattern1))\n-\t\treturn false;\n+\t\t\t\t\t\tstmt, ncopies_for_cost,\n+\t\t\t\t\t\t(i == 0), &oprnds_info))\n+\t\t{\n+\t  \t  vect_free_oprnd_info (&oprnds_info, true);\n+ \t\t  return false;\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -565,6 +637,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                     }\n \n+\t  \t  vect_free_oprnd_info (&oprnds_info, true);\n                   return false;\n                 }\n \n@@ -581,6 +654,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                     }\n \n+\t  \t  vect_free_oprnd_info (&oprnds_info, true);\n                   return false;\n                 }\n \n@@ -601,6 +675,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                           print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                         }\n  \n+\t  \t      vect_free_oprnd_info (&oprnds_info, true);\n                       return false;\n                     }\n                 }\n@@ -620,6 +695,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                           print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n                         }\n \n+\t  \t      vect_free_oprnd_info (&oprnds_info, true);\n                       return false;\n                     }\n \n@@ -647,14 +723,15 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t{\n \t  if (TREE_CODE_CLASS (rhs_code) == tcc_reference)\n \t    {\n-\t      /* Not strided load. */\n+\t      /* Not strided load.  */\n \t      if (vect_print_dump_info (REPORT_SLP))\n \t\t{\n \t\t  fprintf (vect_dump, \"Build SLP failed: not strided load \");\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \n \t      /* FORNOW: Not strided loads are not supported.  */\n+\t      vect_free_oprnd_info (&oprnds_info, true);\n \t      return false;\n \t    }\n \n@@ -669,19 +746,18 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \n+\t      vect_free_oprnd_info (&oprnds_info, true);\n \t      return false;\n \t    }\n \n \t  /* Find the def-stmts.  */\n \t  if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node, stmt,\n-\t\t\t\t\t    &def_stmts0, &def_stmts1,\n-\t\t\t\t\t    &first_stmt_dt0, &first_stmt_dt1,\n-\t\t\t\t\t    &first_stmt_def0_type,\n-\t\t\t\t\t    &first_stmt_def1_type,\n-\t\t\t\t\t    &first_stmt_const_oprnd,\n-\t\t\t\t\t    ncopies_for_cost,\n-                                            &pattern0, &pattern1))\n-\t    return false;\n+\t\t\t\t\t    ncopies_for_cost, (i == 0),\n+\t\t\t\t\t    &oprnds_info))\n+\t    {\n+\t      vect_free_oprnd_info (&oprnds_info, true);\n+\t      return false;\n+\t    }\n \t}\n     }\n \n@@ -714,42 +790,29 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     }\n \n   /* Create SLP_TREE nodes for the definition node/s.  */\n-  if (first_stmt_dt0 == vect_internal_def)\n-    {\n-      slp_tree left_node = XNEW (struct _slp_tree);\n-      SLP_TREE_SCALAR_STMTS (left_node) = def_stmts0;\n-      SLP_TREE_VEC_STMTS (left_node) = NULL;\n-      SLP_TREE_LEFT (left_node) = NULL;\n-      SLP_TREE_RIGHT (left_node) = NULL;\n-      SLP_TREE_OUTSIDE_OF_LOOP_COST (left_node) = 0;\n-      SLP_TREE_INSIDE_OF_LOOP_COST (left_node) = 0;\n-      if (!vect_build_slp_tree (loop_vinfo, bb_vinfo, &left_node, group_size,\n-\t\t\t\tinside_cost, outside_cost, ncopies_for_cost,\n-\t\t\t\tmax_nunits, load_permutation, loads,\n-\t\t\t\tvectorization_factor, loads_permuted))\n-\treturn false;\n+  FOR_EACH_VEC_ELT (slp_oprnd_info, oprnds_info, i, oprnd_info)\n+    {\n+      slp_tree child;\n \n-      SLP_TREE_LEFT (*node) = left_node;\n-    }\n+      if (oprnd_info->first_dt != vect_internal_def)\n+        continue;\n \n-  if (first_stmt_dt1 == vect_internal_def)\n-    {\n-      slp_tree right_node = XNEW (struct _slp_tree);\n-      SLP_TREE_SCALAR_STMTS (right_node) = def_stmts1;\n-      SLP_TREE_VEC_STMTS (right_node) = NULL;\n-      SLP_TREE_LEFT (right_node) = NULL;\n-      SLP_TREE_RIGHT (right_node) = NULL;\n-      SLP_TREE_OUTSIDE_OF_LOOP_COST (right_node) = 0;\n-      SLP_TREE_INSIDE_OF_LOOP_COST (right_node) = 0;\n-      if (!vect_build_slp_tree (loop_vinfo, bb_vinfo, &right_node, group_size,\n+      child = vect_create_new_slp_node (oprnd_info->def_stmts);\n+      if (!child\n+          || !vect_build_slp_tree (loop_vinfo, bb_vinfo, &child, group_size,\n \t\t\t\tinside_cost, outside_cost, ncopies_for_cost,\n \t\t\t\tmax_nunits, load_permutation, loads,\n \t\t\t\tvectorization_factor, loads_permuted))\n-\treturn false;\n+        {\n+          free (child);\n+          vect_free_oprnd_info (&oprnds_info, true);\n+   \t  return false;\n+\t}\n \n-      SLP_TREE_RIGHT (*node) = right_node;\n+      VEC_quick_push (slp_void_p, SLP_TREE_CHILDREN (*node), child);\n     }\n \n+  vect_free_oprnd_info (&oprnds_info, false);\n   return true;\n }\n \n@@ -759,6 +822,7 @@ vect_print_slp_tree (slp_tree node)\n {\n   int i;\n   gimple stmt;\n+  slp_void_p child;\n \n   if (!node)\n     return;\n@@ -771,8 +835,8 @@ vect_print_slp_tree (slp_tree node)\n     }\n   fprintf (vect_dump, \"\\n\");\n \n-  vect_print_slp_tree (SLP_TREE_LEFT (node));\n-  vect_print_slp_tree (SLP_TREE_RIGHT (node));\n+  FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n+    vect_print_slp_tree ((slp_tree) child);\n }\n \n \n@@ -786,6 +850,7 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n {\n   int i;\n   gimple stmt;\n+  slp_void_p child;\n \n   if (!node)\n     return;\n@@ -794,8 +859,8 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n     if (j < 0 || i == j)\n       STMT_SLP_TYPE (vinfo_for_stmt (stmt)) = mark;\n \n-  vect_mark_slp_stmts (SLP_TREE_LEFT (node), mark, j);\n-  vect_mark_slp_stmts (SLP_TREE_RIGHT (node), mark, j);\n+  FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n+    vect_mark_slp_stmts ((slp_tree) child, mark, j);\n }\n \n \n@@ -807,6 +872,7 @@ vect_mark_slp_stmts_relevant (slp_tree node)\n   int i;\n   gimple stmt;\n   stmt_vec_info stmt_info;\n+  slp_void_p child;\n \n   if (!node)\n     return;\n@@ -819,8 +885,8 @@ vect_mark_slp_stmts_relevant (slp_tree node)\n       STMT_VINFO_RELEVANT (stmt_info) = vect_used_in_scope;\n     }\n \n-  vect_mark_slp_stmts_relevant (SLP_TREE_LEFT (node));\n-  vect_mark_slp_stmts_relevant (SLP_TREE_RIGHT (node));\n+  FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n+    vect_mark_slp_stmts_relevant ((slp_tree) child);\n }\n \n \n@@ -893,12 +959,13 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n   gimple stmt;\n   VEC (gimple, heap) *tmp_stmts;\n   unsigned int index, i;\n+  slp_void_p child;\n \n   if (!node)\n     return;\n \n-  vect_slp_rearrange_stmts (SLP_TREE_LEFT (node), group_size, permutation);\n-  vect_slp_rearrange_stmts (SLP_TREE_RIGHT (node), group_size, permutation);\n+  FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n+    vect_slp_rearrange_stmts ((slp_tree) child, group_size, permutation);\n \n   gcc_assert (group_size == VEC_length (gimple, SLP_TREE_SCALAR_STMTS (node)));\n   tmp_stmts = VEC_alloc (gimple, heap, group_size);\n@@ -1263,7 +1330,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                            gimple stmt)\n {\n   slp_instance new_instance;\n-  slp_tree node = XNEW (struct _slp_tree);\n+  slp_tree node;\n   unsigned int group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n   unsigned int unrolling_factor = 1, nunits;\n   tree vectype, scalar_type = NULL_TREE;\n@@ -1275,6 +1342,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   VEC (slp_tree, heap) *loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n   bool loads_permuted = false;\n+  VEC (gimple, heap) *scalar_stmts;\n \n   if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n@@ -1327,32 +1395,26 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     }\n \n   /* Create a node (a root of the SLP tree) for the packed strided stores.  */\n-  SLP_TREE_SCALAR_STMTS (node) = VEC_alloc (gimple, heap, group_size);\n+  scalar_stmts = VEC_alloc (gimple, heap, group_size);\n   next = stmt;\n   if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n       /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n       while (next)\n         {\n-          VEC_safe_push (gimple, heap, SLP_TREE_SCALAR_STMTS (node), next);\n+          VEC_safe_push (gimple, heap, scalar_stmts, next);\n           next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n         }\n     }\n   else\n     {\n       /* Collect reduction statements.  */\n-      for (i = 0; VEC_iterate (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i, \n-                               next); \n-           i++)\n-        VEC_safe_push (gimple, heap, SLP_TREE_SCALAR_STMTS (node), next);\n+      VEC (gimple, heap) *reductions = LOOP_VINFO_REDUCTIONS (loop_vinfo);\n+      for (i = 0; VEC_iterate (gimple, reductions, i, next); i++)\n+        VEC_safe_push (gimple, heap, scalar_stmts, next);\n     }\n \n-  SLP_TREE_VEC_STMTS (node) = NULL;\n-  SLP_TREE_NUMBER_OF_VEC_STMTS (node) = 0;\n-  SLP_TREE_LEFT (node) = NULL;\n-  SLP_TREE_RIGHT (node) = NULL;\n-  SLP_TREE_OUTSIDE_OF_LOOP_COST (node) = 0;\n-  SLP_TREE_INSIDE_OF_LOOP_COST (node) = 0;\n+  node = vect_create_new_slp_node (scalar_stmts);\n \n   /* Calculate the number of vector stmts to create based on the unrolling\n      factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n@@ -1548,6 +1610,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node)\n   imm_use_iterator imm_iter;\n   gimple use_stmt;\n   stmt_vec_info stmt_vinfo; \n+  slp_void_p child;\n \n   if (!node)\n     return;\n@@ -1565,8 +1628,8 @@ vect_detect_hybrid_slp_stmts (slp_tree node)\n                      == vect_reduction_def))\n \t  vect_mark_slp_stmts (node, hybrid, i);\n \n-  vect_detect_hybrid_slp_stmts (SLP_TREE_LEFT (node));\n-  vect_detect_hybrid_slp_stmts (SLP_TREE_RIGHT (node));\n+  FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n+    vect_detect_hybrid_slp_stmts ((slp_tree) child);\n }\n \n \n@@ -1656,13 +1719,14 @@ vect_slp_analyze_node_operations (bb_vec_info bb_vinfo, slp_tree node)\n   bool dummy;\n   int i;\n   gimple stmt;\n+  slp_void_p child;\n \n   if (!node)\n     return true;\n \n-  if (!vect_slp_analyze_node_operations (bb_vinfo, SLP_TREE_LEFT (node))\n-      || !vect_slp_analyze_node_operations (bb_vinfo, SLP_TREE_RIGHT (node)))\n-    return false;\n+  FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n+    if (!vect_slp_analyze_node_operations (bb_vinfo, (slp_tree) child))\n+      return false;\n \n   FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n@@ -2208,85 +2272,100 @@ vect_get_slp_vect_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds)\n    If the scalar definitions are loop invariants or constants, collect them and\n    call vect_get_constant_vectors() to create vector stmts.\n    Otherwise, the def-stmts must be already vectorized and the vectorized stmts\n-   must be stored in the LEFT/RIGHT node of SLP_NODE, and we call\n-   vect_get_slp_vect_defs() to retrieve them.\n-   If VEC_OPRNDS1 is NULL, don't get vector defs for the second operand (from\n-   the right node. This is used when the second operand must remain scalar.  */\n+   must be stored in the corresponding child of SLP_NODE, and we call\n+   vect_get_slp_vect_defs () to retrieve them.  */\n \n void\n-vect_get_slp_defs (tree op0, tree op1, slp_tree slp_node,\n-                   VEC (tree,heap) **vec_oprnds0,\n-                   VEC (tree,heap) **vec_oprnds1, int reduc_index)\n+vect_get_slp_defs (VEC (tree, heap) *ops, slp_tree slp_node,\n+                   VEC (slp_void_p, heap) **vec_oprnds, int reduc_index)\n {\n-  gimple first_stmt;\n-  enum tree_code code;\n-  int number_of_vects;\n+  gimple first_stmt, first_def;\n+  int number_of_vects = 0, i;\n+  unsigned int child_index = 0;\n   HOST_WIDE_INT lhs_size_unit, rhs_size_unit;\n+  slp_tree child = NULL;\n+  VEC (tree, heap) *vec_defs;\n+  tree oprnd, def_lhs;\n+  bool vectorized_defs;\n \n   first_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0);\n-  /* The number of vector defs is determined by the number of vector statements\n-     in the node from which we get those statements.  */\n-  if (SLP_TREE_LEFT (slp_node))\n-    number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_LEFT (slp_node));\n-  else\n-    {\n-      number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-      /* Number of vector stmts was calculated according to LHS in\n-         vect_schedule_slp_instance(), fix it by replacing LHS with RHS, if\n-         necessary.  See vect_get_smallest_scalar_type () for details.  */\n-      vect_get_smallest_scalar_type (first_stmt, &lhs_size_unit,\n-                                     &rhs_size_unit);\n-      if (rhs_size_unit != lhs_size_unit)\n+  FOR_EACH_VEC_ELT (tree, ops, i, oprnd)\n+    {\n+      /* For each operand we check if it has vectorized definitions in a child\n+\t node or we need to create them (for invariants and constants).  We\n+\t check if the LHS of the first stmt of the next child matches OPRND.\n+\t If it does, we found the correct child.  Otherwise, we call\n+\t vect_get_constant_vectors (), and not advance CHILD_INDEX in order\n+\t to check this child node for the next operand.  */\n+      vectorized_defs = false;\n+      if (VEC_length (slp_void_p, SLP_TREE_CHILDREN (slp_node)) > child_index)\n         {\n-          number_of_vects *= rhs_size_unit;\n-          number_of_vects /= lhs_size_unit;\n-        }\n-    }\n-\n-  /* Allocate memory for vectorized defs.  */\n-  *vec_oprnds0 = VEC_alloc (tree, heap, number_of_vects);\n-\n-  /* SLP_NODE corresponds either to a group of stores or to a group of\n-     unary/binary operations.  We don't call this function for loads.\n-     For reduction defs we call vect_get_constant_vectors(), since we are\n-     looking for initial loop invariant values.  */\n-  if (SLP_TREE_LEFT (slp_node) && reduc_index == -1)\n-    /* The defs are already vectorized.  */\n-    vect_get_slp_vect_defs (SLP_TREE_LEFT (slp_node), vec_oprnds0);\n-  else\n-    /* Build vectors from scalar defs.  */\n-    vect_get_constant_vectors (op0, slp_node, vec_oprnds0, 0, number_of_vects,\n-                               reduc_index);\n+          child = (slp_tree) VEC_index (slp_void_p,\n+\t\t\t\t\tSLP_TREE_CHILDREN (slp_node),\n+\t\t\t\t\tchild_index);\n+          first_def = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (child), 0);\n+\n+\t  /* In the end of a pattern sequence we have a use of the original stmt,\n+\t     so we need to compare OPRND with the original def.  */\n+          if (is_pattern_stmt_p (vinfo_for_stmt (first_def))\n+\t      && !STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (first_stmt))\n+              && !is_pattern_stmt_p (vinfo_for_stmt (first_stmt)))\n+            first_def = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (first_def));\n+\n+          if (is_gimple_call (first_def))\n+            def_lhs = gimple_call_lhs (first_def);\n+          else\n+            def_lhs = gimple_assign_lhs (first_def);\n \n-  if (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt)))\n-    /* Since we don't call this function with loads, this is a group of\n-       stores.  */\n-    return;\n+          if (operand_equal_p (oprnd, def_lhs, 0))\n+            {\n+              /* The number of vector defs is determined by the number of\n+                 vector statements in the node from which we get those\n+\t\t statements.  */\n+                 number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (child);\n+                 vectorized_defs = true;\n+\t      child_index++;\n+            }\n+        }\n \n-  /* For reductions, we only need initial values.  */\n-  if (reduc_index != -1)\n-    return;\n+      if (!vectorized_defs)\n+        {\n+          if (i == 0)\n+            {\n+              number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+              /* Number of vector stmts was calculated according to LHS in\n+                 vect_schedule_slp_instance (), fix it by replacing LHS with\n+                 RHS, if necessary.  See vect_get_smallest_scalar_type () for\n+                 details.  */\n+              vect_get_smallest_scalar_type (first_stmt, &lhs_size_unit,\n+                                             &rhs_size_unit);\n+              if (rhs_size_unit != lhs_size_unit)\n+                {\n+                  number_of_vects *= rhs_size_unit;\n+                  number_of_vects /= lhs_size_unit;\n+                }\n+            }\n+        }\n \n-  code = gimple_assign_rhs_code (first_stmt);\n-  if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS || !vec_oprnds1 || !op1)\n-    return;\n+      /* Allocate memory for vectorized defs.  */\n+      vec_defs = VEC_alloc (tree, heap, number_of_vects);\n \n-  /* The number of vector defs is determined by the number of vector statements\n-     in the node from which we get those statements.  */\n-  if (SLP_TREE_RIGHT (slp_node))\n-    number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_RIGHT (slp_node));\n-  else\n-    number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+      /* For reduction defs we call vect_get_constant_vectors (), since we are\n+         looking for initial loop invariant values.  */\n+      if (vectorized_defs && reduc_index == -1)\n+        /* The defs are already vectorized.  */\n+        vect_get_slp_vect_defs (child, &vec_defs);\n+      else\n+        /* Build vectors from scalar defs.  */\n+        vect_get_constant_vectors (oprnd, slp_node, &vec_defs, i,\n+                                   number_of_vects, reduc_index);\n \n-  *vec_oprnds1 = VEC_alloc (tree, heap, number_of_vects);\n+      VEC_quick_push (slp_void_p, *vec_oprnds, (slp_void_p) vec_defs);\n \n-  if (SLP_TREE_RIGHT (slp_node))\n-    /* The defs are already vectorized.  */\n-    vect_get_slp_vect_defs (SLP_TREE_RIGHT (slp_node), vec_oprnds1);\n-  else\n-    /* Build vectors from scalar defs.  */\n-    vect_get_constant_vectors (op1, slp_node, vec_oprnds1, 1, number_of_vects,\n-                               -1);\n+      /* For reductions, we only need initial values.  */\n+      if (reduc_index != -1)\n+        return;\n+    }\n }\n \n \n@@ -2593,14 +2672,14 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   tree vectype;\n   int i;\n   slp_tree loads_node;\n+  slp_void_p child;\n \n   if (!node)\n     return false;\n \n-  vect_schedule_slp_instance (SLP_TREE_LEFT (node), instance,\n-                              vectorization_factor);\n-  vect_schedule_slp_instance (SLP_TREE_RIGHT (node), instance,\n-                              vectorization_factor);\n+  FOR_EACH_VEC_ELT (slp_void_p, SLP_TREE_CHILDREN (node), i, child)\n+    vect_schedule_slp_instance ((slp_tree) child, instance,\n+                                vectorization_factor);\n \n   stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n   stmt_info = vinfo_for_stmt (stmt);"}, {"sha": "8f3e4eca64b3cb09d0b5604d9d932f85c02f0d7c", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -1399,16 +1399,35 @@ vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt,\n }\n \n \n-/* Get vectorized definitions for OP0 and OP1, or SLP_NODE if it is not\n-   NULL.  */\n+/* Get vectorized definitions for OP0 and OP1.\n+   REDUC_INDEX is the index of reduction operand in case of reduction,\n+   and -1 otherwise.  */\n \n-static void\n+void\n vect_get_vec_defs (tree op0, tree op1, gimple stmt,\n-\t\t   VEC(tree,heap) **vec_oprnds0, VEC(tree,heap) **vec_oprnds1,\n-\t\t   slp_tree slp_node)\n+\t\t   VEC (tree, heap) **vec_oprnds0,\n+\t\t   VEC (tree, heap) **vec_oprnds1,\n+\t\t   slp_tree slp_node, int reduc_index)\n {\n   if (slp_node)\n-    vect_get_slp_defs (op0, op1, slp_node, vec_oprnds0, vec_oprnds1, -1);\n+    {\n+      int nops = (op1 == NULL_TREE) ? 1 : 2;\n+      VEC (tree, heap) *ops = VEC_alloc (tree, heap, nops);\n+      VEC (slp_void_p, heap) *vec_defs = VEC_alloc (slp_void_p, heap, nops);\n+\n+      VEC_quick_push (tree, ops, op0);\n+      if (op1)\n+        VEC_quick_push (tree, ops, op1);\n+\n+      vect_get_slp_defs (ops, slp_node, &vec_defs, reduc_index);\n+\n+      *vec_oprnds0 = (VEC (tree, heap) *) VEC_index (slp_void_p, vec_defs, 0);\n+      if (op1)\n+        *vec_oprnds1 = (VEC (tree, heap) *) VEC_index (slp_void_p, vec_defs, 1);\n+\n+      VEC_free (tree, heap, ops);\n+      VEC_free (slp_void_p, heap, vec_defs);\n+    }\n   else\n     {\n       tree vec_oprnd;\n@@ -1986,7 +2005,8 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n       for (j = 0; j < ncopies; j++)\n \t{\n \t  if (j == 0)\n-\t    vect_get_vec_defs (op0, NULL, stmt, &vec_oprnds0, NULL, slp_node);\n+\t    vect_get_vec_defs (op0, NULL, stmt, &vec_oprnds0, NULL, slp_node,\n+\t\t\t       -1);\n \t  else\n \t    vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, NULL);\n \n@@ -2223,7 +2243,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       /* Handle uses.  */\n       if (j == 0)\n-        vect_get_vec_defs (op, NULL, stmt, &vec_oprnds, NULL, slp_node);\n+        vect_get_vec_defs (op, NULL, stmt, &vec_oprnds, NULL, slp_node, -1);\n       else\n         vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds, NULL);\n \n@@ -2617,10 +2637,10 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n              operand 1 should be of a vector type (the usual case).  */\n           if (vec_oprnd1)\n             vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n-                               slp_node);\n+                               slp_node, -1);\n           else\n             vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,\n-                               slp_node);\n+                               slp_node, -1);\n         }\n       else\n         vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n@@ -2942,10 +2962,10 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  if (op_type == binary_op || op_type == ternary_op)\n \t    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,\n-\t\t\t       slp_node);\n+\t\t\t       slp_node, -1);\n \t  else\n \t    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n-\t\t\t       slp_node);\n+\t\t\t       slp_node, -1);\n \t  if (op_type == ternary_op)\n \t    {\n \t      vec_oprnds2 = VEC_alloc (tree, heap, 1);\n@@ -3268,7 +3288,8 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       /* Handle uses.  */\n       if (slp_node)\n-        vect_get_slp_defs (op0, NULL_TREE, slp_node, &vec_oprnds0, NULL, -1);\n+        vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n+\t\t\t   slp_node, -1);\n       else\n         {\n           VEC_free (tree, heap, vec_oprnds0);\n@@ -3627,12 +3648,12 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n                   for (k = 0; k < slp_node->vec_stmts_size - 1; k++)\n                     VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n \n-    \t\t  vect_get_slp_defs (op0, NULL_TREE, slp_node, &vec_oprnds0, NULL,\n- \t                             -1);\n+    \t\t  vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n+ \t                             slp_node, -1);\n                 }\n               else\n-                vect_get_slp_defs (op0, op1, slp_node, &vec_oprnds0,\n-                                   &vec_oprnds1, -1);\n+                vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0,\n+                                   &vec_oprnds1, slp_node, -1);\n \t    }\n \t  else\n             {\n@@ -3870,6 +3891,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n           vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n           first_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0); \n           first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+\t  op = gimple_assign_rhs1 (first_stmt);\n         } \n       else\n         /* VEC_NUM is the number of vect stmts to be created for this \n@@ -3952,8 +3974,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n           if (slp)\n             {\n \t      /* Get vectorized arguments for SLP_NODE.  */\n-              vect_get_slp_defs (NULL_TREE, NULL_TREE, slp_node, &vec_oprnds,\n-                                 NULL, -1);\n+              vect_get_vec_defs (op, NULL_TREE, stmt, &vec_oprnds,\n+                                 NULL, slp_node, -1);\n \n               vec_oprnd = VEC_index (tree, vec_oprnds, 0);\n             }\n@@ -5069,7 +5091,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n      In basic blocks we only analyze statements that are a part of some SLP\n      instance, therefore, all the statements are relevant.\n \n-     Pattern statement need to be analyzed instead of the original statement\n+     Pattern statement needs to be analyzed instead of the original statement\n      if the original statement is not relevant.  Otherwise, we analyze both\n      statements.  */\n "}, {"sha": "bcbc32cbd95e47b3eac109a0d3db30b598caf731", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d092494cf3665e8c1d7725fa51c48ecd6023d585/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d092494cf3665e8c1d7725fa51c48ecd6023d585", "patch": "@@ -73,15 +73,15 @@ enum vect_def_type {\n /************************************************************************\n   SLP\n  ************************************************************************/\n+typedef void *slp_void_p;\n+DEF_VEC_P (slp_void_p);\n+DEF_VEC_ALLOC_P (slp_void_p, heap);\n \n-/* A computation tree of an SLP instance. Each node corresponds to a group of\n+/* A computation tree of an SLP instance.  Each node corresponds to a group of\n    stmts to be packed in a SIMD stmt.  */\n typedef struct _slp_tree {\n-  /* Only binary and unary operations are supported. LEFT child corresponds to\n-     the first operand and RIGHT child to the second if the operation is\n-     binary.  */\n-  struct _slp_tree *left;\n-  struct _slp_tree *right;\n+  /* Nodes that contain def-stmts of this node statements operands.  */\n+  VEC (slp_void_p, heap) *children;\n   /* A group of scalar stmts to be vectorized together.  */\n   VEC (gimple, heap) *stmts;\n   /* Vectorized stmt/s.  */\n@@ -146,14 +146,32 @@ DEF_VEC_ALLOC_P(slp_instance, heap);\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n #define SLP_INSTANCE_FIRST_LOAD_STMT(S)          (S)->first_load\n \n-#define SLP_TREE_LEFT(S)                         (S)->left\n-#define SLP_TREE_RIGHT(S)                        (S)->right\n+#define SLP_TREE_CHILDREN(S)                     (S)->children\n #define SLP_TREE_SCALAR_STMTS(S)                 (S)->stmts\n #define SLP_TREE_VEC_STMTS(S)                    (S)->vec_stmts\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n #define SLP_TREE_OUTSIDE_OF_LOOP_COST(S)         (S)->cost.outside_of_loop\n #define SLP_TREE_INSIDE_OF_LOOP_COST(S)          (S)->cost.inside_of_loop\n \n+/* This structure is used in creation of an SLP tree.  Each instance\n+   corresponds to the same operand in a group of scalar stmts in an SLP\n+   node.  */\n+typedef struct _slp_oprnd_info\n+{\n+  /* Def-stmts for the operands.  */\n+  VEC (gimple, heap) *def_stmts;\n+  /* Information about the first statement, its vector def-type, type, the\n+     operand itself in case it's constant, and an indication if it's a pattern\n+     stmt.  */\n+  enum vect_def_type first_dt;\n+  tree first_def_type;\n+  tree first_const_oprnd;\n+  bool first_pattern;\n+} *slp_oprnd_info;\n+\n+DEF_VEC_P(slp_oprnd_info);\n+DEF_VEC_ALLOC_P(slp_oprnd_info, heap);\n+\n \n typedef struct _vect_peel_info\n {\n@@ -824,6 +842,8 @@ extern void vect_get_load_cost (struct data_reference *, int, bool,\n                                 unsigned int *, unsigned int *);\n extern void vect_get_store_cost (struct data_reference *, int, unsigned int *);\n extern bool vect_supportable_shift (enum tree_code, tree);\n+extern void vect_get_vec_defs (tree, tree, gimple, VEC (tree, heap) **,\n+\t\t\t       VEC (tree, heap) **, slp_tree, int);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n@@ -891,8 +911,9 @@ extern void vect_update_slp_costs_according_to_vf (loop_vec_info);\n extern bool vect_analyze_slp (loop_vec_info, bb_vec_info);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n-extern void vect_get_slp_defs (tree, tree, slp_tree, VEC (tree,heap) **,\n-                               VEC (tree,heap) **, int);\n+extern void vect_get_slp_defs (VEC (tree, heap) *, slp_tree,\n+\t\t\t       VEC (slp_void_p, heap) **, int);\n+\n extern LOC find_bb_location (basic_block);\n extern bb_vec_info vect_slp_analyze_bb (basic_block);\n extern void vect_slp_transform_bb (basic_block);"}]}