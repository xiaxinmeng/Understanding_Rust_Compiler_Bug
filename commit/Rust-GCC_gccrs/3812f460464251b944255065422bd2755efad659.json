{"sha": "3812f460464251b944255065422bd2755efad659", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgxMmY0NjA0NjQyNTFiOTQ0MjU1MDY1NDIyYmQyNzU1ZWZhZDY1OQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-04-11T16:35:34Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-04-11T16:35:34Z"}, "message": "PR middle-end/80364 - sanitizer detects signed integer overflow in gimple-ssa-sprintf.c\n\ngcc/ChangeLog:\n\tPR middle-end/80364\n\t* gimple-ssa-sprintf.c (get_int_range): Remove second argument and\n\talways use the int type.  Use INTEGRAL_TYPE_P() rather than testing\n\tfor INTEGER_TYPE.\n\t(directive::set_width, directive::set_precision, format_character):\n\tAdjust.\n\t(parse_directive): Use INTEGRAL_TYPE_P() rather than testing for\n\tINTEGER_TYPE.\n\ngcc/testsuite/ChangeLog:\n\tPR middle-end/80364\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-16.c: New test.\n\nFrom-SVN: r246846", "tree": {"sha": "17927665a105191963a2ff79345d192d5106c03e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17927665a105191963a2ff79345d192d5106c03e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3812f460464251b944255065422bd2755efad659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3812f460464251b944255065422bd2755efad659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3812f460464251b944255065422bd2755efad659", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3812f460464251b944255065422bd2755efad659/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b1c0468f72b1f155419a5cb648609a03f2c37d2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c0468f72b1f155419a5cb648609a03f2c37d2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1c0468f72b1f155419a5cb648609a03f2c37d2d"}], "stats": {"total": 342, "additions": 315, "deletions": 27}, "files": [{"sha": "fa7471e707ad814888e560ad4a1341c48b747427", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3812f460464251b944255065422bd2755efad659/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3812f460464251b944255065422bd2755efad659/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3812f460464251b944255065422bd2755efad659", "patch": "@@ -1,3 +1,14 @@\n+2017-04-11  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/80364\n+\t* gimple-ssa-sprintf.c (get_int_range): Remove second argument and\n+\talways use the int type.  Use INTEGRAL_TYPE_P() rather than testing\n+\tfor INTEGER_TYPE.\n+\t(directive::set_width, directive::set_precision, format_character):\n+\tAdjust.\n+\t(parse_directive): Use INTEGRAL_TYPE_P() rather than testing for\n+\tINTEGER_TYPE.\n+\n 2017-04-11  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/80389"}, {"sha": "2e62086e2d13e2c6e565953dec028f47df74ee20", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3812f460464251b944255065422bd2755efad659/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3812f460464251b944255065422bd2755efad659/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=3812f460464251b944255065422bd2755efad659", "patch": "@@ -599,8 +599,7 @@ fmtresult::type_max_digits (tree type, int base)\n }\n \n static bool\n-get_int_range (tree, tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t       bool, HOST_WIDE_INT);\n+get_int_range (tree, HOST_WIDE_INT *, HOST_WIDE_INT *, bool, HOST_WIDE_INT);\n \n /* Description of a format directive.  A directive is either a plain\n    string or a conversion specification that starts with '%'.  */\n@@ -674,7 +673,7 @@ struct directive\n      For an indeterminate ARG set width to [0, INT_MAX].  */\n   void set_width (tree arg)\n   {\n-    get_int_range (arg, integer_type_node, width, width + 1, true, 0);\n+    get_int_range (arg, width, width + 1, true, 0);\n   }\n \n   /* Set both bounds of the precision range to VAL.  */\n@@ -690,7 +689,7 @@ struct directive\n      For an indeterminate ARG set precision to [-1, INT_MAX].  */\n   void set_precision (tree arg)\n   {\n-    get_int_range (arg, integer_type_node, prec, prec + 1, false, -1);\n+    get_int_range (arg, prec, prec + 1, false, -1);\n   }\n \n   /* Return true if both width and precision are known to be\n@@ -927,25 +926,27 @@ build_intmax_type_nodes (tree *pintmax, tree *puintmax)\n     }\n }\n \n-/* Determine the range [*PMIN, *PMAX] that the expression ARG of TYPE\n-   is in.  Return true when the range is a subrange of that of TYPE.\n-   Whn ARG is null it is as if it had the full range of TYPE.\n+/* Determine the range [*PMIN, *PMAX] that the expression ARG is\n+   in and that is representable in type int.\n+   Return true when the range is a subrange of that of int.\n+   When ARG is null it is as if it had the full range of int.\n    When ABSOLUTE is true the range reflects the absolute value of\n    the argument.  When ABSOLUTE is false, negative bounds of\n    the determined range are replaced with NEGBOUND.  */\n \n static bool\n-get_int_range (tree arg, tree type, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n+get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t       bool absolute, HOST_WIDE_INT negbound)\n {\n+  /* The type of the result.  */\n+  const_tree type = integer_type_node;\n+\n   bool knownrange = false;\n \n   if (!arg)\n     {\n-      *pmin = (TYPE_UNSIGNED (type)\n-\t       ? tree_to_uhwi (TYPE_MIN_VALUE (type))\n-\t       : tree_to_shwi (TYPE_MIN_VALUE (type)));\n-      *pmax = tree_to_uhwi (TYPE_MAX_VALUE (type));\n+      *pmin = tree_to_shwi (TYPE_MIN_VALUE (type));\n+      *pmax = tree_to_shwi (TYPE_MAX_VALUE (type));\n     }\n   else if (TREE_CODE (arg) == INTEGER_CST)\n     {\n@@ -961,38 +962,51 @@ get_int_range (tree arg, tree type, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n       /* True if the argument's range cannot be determined.  */\n       bool unknown = true;\n \n-      type = TREE_TYPE (arg);\n+      tree argtype = TREE_TYPE (arg);\n \n+      /* Ignore invalid arguments with greater precision that that\n+\t of the expected type (e.g., in sprintf(\"%*i\", 12LL, i)).\n+\t They will have been detected and diagnosed by -Wformat and\n+\t so it's not important to complicate this code to try to deal\n+\t with them again.  */\n       if (TREE_CODE (arg) == SSA_NAME\n-\t  && TREE_CODE (type) == INTEGER_TYPE)\n+\t  && INTEGRAL_TYPE_P (argtype)\n+\t  && TYPE_PRECISION (argtype) <= TYPE_PRECISION (type))\n \t{\n \t  /* Try to determine the range of values of the integer argument.  */\n \t  wide_int min, max;\n \t  enum value_range_type range_type = get_range_info (arg, &min, &max);\n \t  if (range_type == VR_RANGE)\n \t    {\n \t      HOST_WIDE_INT type_min\n-\t\t= (TYPE_UNSIGNED (type)\n-\t\t   ? tree_to_uhwi (TYPE_MIN_VALUE (type))\n-\t\t   : tree_to_shwi (TYPE_MIN_VALUE (type)));\n+\t\t= (TYPE_UNSIGNED (argtype)\n+\t\t   ? tree_to_uhwi (TYPE_MIN_VALUE (argtype))\n+\t\t   : tree_to_shwi (TYPE_MIN_VALUE (argtype)));\n \n-\t      HOST_WIDE_INT type_max = tree_to_uhwi (TYPE_MAX_VALUE (type));\n+\t      HOST_WIDE_INT type_max = tree_to_uhwi (TYPE_MAX_VALUE (argtype));\n \n \t      *pmin = min.to_shwi ();\n \t      *pmax = max.to_shwi ();\n \n-\t      /* Return true if the adjusted range is a subrange of\n-\t\t the full range of the argument's type.  */\n-\t      knownrange = type_min < *pmin || *pmax < type_max;\n-\n-\t      unknown = false;\n+\t      if (*pmin < *pmax)\n+\t\t{\n+\t\t  /* Return true if the adjusted range is a subrange of\n+\t\t     the full range of the argument's type.  *PMAX may\n+\t\t     be less than *PMIN when the argument is unsigned\n+\t\t     and its upper bound is in excess of TYPE_MAX.  In\n+\t\t     that (invalid) case disregard the range and use that\n+\t\t     of the expected type instead.  */\n+\t\t  knownrange = type_min < *pmin || *pmax < type_max;\n+\n+\t\t  unknown = false;\n+\t\t}\n \t    }\n \t}\n \n       /* Handle an argument with an unknown range as if none had been\n \t provided.  */\n       if (unknown)\n-\treturn get_int_range (NULL_TREE, type, pmin, pmax, absolute, negbound);\n+\treturn get_int_range (NULL_TREE, pmin, pmax, absolute, negbound);\n     }\n \n   /* Adjust each bound as specified by ABSOLUTE and NEGBOUND.  */\n@@ -1004,6 +1018,9 @@ get_int_range (tree arg, tree type, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t    *pmin = *pmax = -*pmin;\n \t  else\n \t    {\n+\t      /* Make sure signed overlow is avoided.  */\n+\t      gcc_assert (*pmin != HOST_WIDE_INT_MIN);\n+\n \t      HOST_WIDE_INT tmp = -*pmin;\n \t      *pmin = 0;\n \t      if (*pmax < tmp)\n@@ -1948,7 +1965,7 @@ format_character (const directive &dir, tree arg)\n       res.range.min = 0;\n \n       HOST_WIDE_INT min, max;\n-      if (get_int_range (arg, integer_type_node, &min, &max, false, 0))\n+      if (get_int_range (arg, &min, &max, false, 0))\n \t{\n \t  if (min == 0 && max == 0)\n \t    {\n@@ -3125,7 +3142,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n \n   if (star_width)\n     {\n-      if (TREE_CODE (TREE_TYPE (star_width)) == INTEGER_TYPE)\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (star_width)))\n \tdir.set_width (star_width);\n       else\n \t{\n@@ -3140,7 +3157,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n \n   if (star_precision)\n     {\n-      if (TREE_CODE (TREE_TYPE (star_precision)) == INTEGER_TYPE)\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (star_precision)))\n \tdir.set_precision (star_precision);\n       else\n \t{"}, {"sha": "89196e60cf43250aa5dfba388a8ccc5507ec6447", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3812f460464251b944255065422bd2755efad659/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3812f460464251b944255065422bd2755efad659/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3812f460464251b944255065422bd2755efad659", "patch": "@@ -1,3 +1,8 @@\n+2017-04-11  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/80364\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-16.c: New test.\n+\n 2017-04-11  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/70878"}, {"sha": "d6cbfe3e191c41e6c6825762a88e70f9221065d0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-16.c", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3812f460464251b944255065422bd2755efad659/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3812f460464251b944255065422bd2755efad659/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-16.c?ref=3812f460464251b944255065422bd2755efad659", "patch": "@@ -0,0 +1,255 @@\n+/* PR middle-end/80364 - sanitizer detects signed integer overflow\n+   in gimple-ssa-sprintf.c\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wformat-overflow=1 -ftrack-macro-expansion=0\" }\n+   { dg-require-effective-target int32plus } */\n+\n+typedef __SIZE_TYPE__  size_t;\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+void sink (void*);\n+void* get_value (void);\n+\n+/* Return a random width as type T.  */\n+#define W(T) *(T*)get_value ()\n+\n+/* Return a random precision as type T.  */\n+#define P(T) *(T*)get_value ()\n+\n+/* Return a random value as type T.  */\n+#define V(T) *(T*)get_value ()\n+\n+extern char buf[1];\n+\n+/* Test convenience macro.  */\n+#define T(fmt, ...)\t\t\t\t\t\\\n+  __builtin_sprintf (buf + 1, fmt, __VA_ARGS__);\t\\\n+  sink (buf)\n+\n+typedef signed char         schar_t;\n+typedef unsigned char       uchar_t;\n+typedef signed short        sshort_t;\n+typedef unsigned short      ushort_t;\n+typedef signed int          sint_t;\n+typedef unsigned int        uint_t;\n+typedef signed long         slong_t;\n+typedef unsigned long       ulong_t;\n+typedef signed long long    sllong_t;\n+typedef unsigned long long  ullong_t;\n+\n+#if __SIZEOF_INT128__\n+typedef __int128_t          sint128_t;\n+typedef __uint128_t         uint128_t;\n+#else\n+/* When __int128_t is not available, repeat the same tests with long long.\n+   This is to avoid having to guard the tests below and to avoid making\n+   the dg-warning directives conditional.  */\n+typedef signed long long    sint128_t;\n+typedef unsigned long long  uint128_t;\n+#endif\n+\n+const sint128_t sint128_max\n+  = (sint128_t)1 << (sizeof sint128_max * __CHAR_BIT__ - 2);\n+const sint128_t uint128_max = (uint128_t)-1;\n+\n+void test_width_cst (void)\n+{\n+  T (\"%*i\", W (schar_t), 1);     /* { dg-warning \"between 1 and 128 \" } */\n+  T (\"%*i\", W (uchar_t), 12);    /* { dg-warning \"between 2 and 255 \" } */\n+\n+  T (\"%*i\", W (sshort_t), 123);  /* { dg-warning \"between 3 and 32768 \" } */\n+  T (\"%*i\", W (ushort_t), 1234); /* { dg-warning \"between 4 and 65535 \" } */\n+\n+  T (\"%*i\", W (sint_t), 12345);  /* { dg-warning \"between 5 and 2147483648 \" } */\n+  T (\"%*i\", W (uint_t), 123456); /* { dg-warning \"between 6 and 2147483648 \" } */\n+\n+  /* Exercise calls with invalid arguments (to verify there is no ICE).  */\n+  T (\"%*li\", W (slong_t), 1234567L);  /* { dg-warning \"between 7 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%*li\", W (ulong_t), 12345678L); /* { dg-warning \"between 8 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  T (\"%*lli\", W (sllong_t), 123456789LL);  /* { dg-warning \"between 9 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%*lli\", W (ullong_t), 1234567890LL); /* { dg-warning \"between 10 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  T (\"%*i\", W (sint128_t), 0);  /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%*i\", W (uint128_t), 1); /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  {\n+    extern sint128_t si128;\n+    if (si128 < sint128_max / 2 || sint128_max - 8 < si128)\n+      si128 = sint128_max / 2;\n+\n+    T (\"%*i\", si128, 0);  /* { dg-warning \"between 1 and 2147483648 \" } */\n+    /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+    extern uint128_t ui128;\n+    if (ui128 < uint128_max / 2 || uint128_max - 8 < ui128)\n+      ui128 = uint128_max / 2;\n+\n+    T (\"%*i\", ui128, 0);  /* { dg-warning \"between 1 and 2147483648 \" } */\n+    /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  }\n+\n+  T (\"%*i\", W (float), 2);  /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%*i\", W (double), 3); /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+}\n+\n+void test_width_var (void)\n+{\n+  T (\"%*i\", W (schar_t), V (schar_t));     /* { dg-warning \"between 1 and 128 \" } */\n+  T (\"%*i\", W (uchar_t), V (uchar_t));    /* { dg-warning \"between 1 and 255 \" } */\n+\n+  T (\"%*i\", W (sshort_t), V (sshort_t));  /* { dg-warning \"between 1 and 32768 \" } */\n+  T (\"%*i\", W (ushort_t), V (ushort_t)); /* { dg-warning \"between 1 and 65535 \" } */\n+\n+  T (\"%*i\", W (sint_t), V (sint_t));  /* { dg-warning \"between 1 and 2147483648 \" } */\n+  T (\"%*i\", W (uint_t), V (uint_t)); /* { dg-warning \"between 1 and 2147483648 \" } */\n+\n+  /* Exercise calls with invalid arguments (to verify there is no ICE).  */\n+  T (\"%*li\", W (slong_t), V (slong_t));  /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%*li\", W (ulong_t), V (ulong_t)); /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  T (\"%*lli\", W (sllong_t), V (sllong_t));  /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%*lli\", W (ullong_t), V (ullong_t)); /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  T (\"%*i\", W (float), V (int));  /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%*i\", W (double), V (int)); /* { dg-warning \"between 1 and 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  {\n+    /* Create an unsigned range with a lower bound greater than 1 and\n+       an upper bound in excess of INT_MAX and verify that the lower\n+       bound isn't used as the minimum output (since the excessive\n+       upper bound wraps around zero).  It's possible to constrain\n+       the upper bound on the output more, based on the upper bound\n+       of the width here, but not worth the trouble.  */\n+    extern unsigned w;\n+    if (w < 5 || (unsigned)-1 - 7 < w)\n+      w = 5;\n+\n+    T (\"%*u\", w, V (int));   /* { dg-warning \"between 1 and 2147483648 \" } */\n+  }\n+\n+  {\n+    /* Verify that enums are correctly handled (i.e., that the warning\n+       doesn't just test for TREE_CODE(type) == INTEGER_TYPE but instead\n+       uses INTEGRAL_TYPE_P() or some equivalent.  */\n+    enum WidthEnum { e7 = 7, e9 = 9 };\n+    enum WidthEnum w = V (enum WidthEnum);\n+    if (w < e7 || e9 < w)\n+      w = e7;\n+\n+    T (\"%*hu\", w, V (int));   /* { dg-warning \"between 7 and 9 \" } */\n+  }\n+}\n+\n+void test_precision_cst (void)\n+{\n+  T (\"%.*i\", P (schar_t), 1);     /* { dg-warning \"between 1 and 127 \" } */\n+  T (\"%.*i\", P (uchar_t), 12);    /* { dg-warning \"between 2 and 255 \" } */\n+\n+  T (\"%.*i\", P (sshort_t), 123);  /* { dg-warning \"between 3 and 32767 \" } */\n+  T (\"%.*i\", P (ushort_t), 1234); /* { dg-warning \"between 4 and 65535 \" } */\n+\n+  T (\"%.*i\", P (sint_t), 12345);  /* { dg-warning \"between 5 and 2147483647 \" } */\n+  T (\"%.*i\", P (uint_t), 123456); /* { dg-warning \"between 6 and 2147483647 \" } */\n+\n+  /* Exercise calls with invalid arguments (to verify there is no ICE).  */\n+  T (\"%.*li\", P (slong_t), 1234567L);  /* { dg-warning \"between 7 and 2147483647 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%.*li\", P (ulong_t), 12345678L); /* { dg-warning \"between 8 and 2147483647 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  T (\"%.*lli\", P (sllong_t), 123456789LL);  /* { dg-warning \"between 9 and 2147483647 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%.*lli\", P (ullong_t), 1234567890LL); /* { dg-warning \"between 10 and 2147483647 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  T (\"%.*i\", P (sint128_t), 0);  /* { dg-warning \"up to 2147483647 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%.*i\", P (uint128_t), 1); /* { dg-warning \"between 1 and 2147483647 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  {\n+    extern sint128_t si128;\n+    if (si128 < sint128_max / 2 || sint128_max - 8 < si128)\n+      si128 = sint128_max / 2;\n+\n+    T (\"%.*i\", si128, 0);  /* { dg-warning \"up to 2147483647 \" } */\n+    /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+    extern uint128_t ui128;\n+    if (ui128 < uint128_max / 2 || uint128_max - 8 < ui128)\n+      ui128 = uint128_max / 2;\n+\n+    T (\"%.*i\", ui128, 0);  /* { dg-warning \"up to 2147483647 \" } */\n+    /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  }\n+\n+  T (\"%.*i\", P (float), 0);  /* { dg-warning \"up to 2147483647 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%.*i\", P (double), 1); /* { dg-warning \"between 1 and 2147483647 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+}\n+\n+void test_precision_var (void)\n+{\n+  T (\"%.*i\", P (schar_t), V (schar_t));     /* { dg-warning \"up to 128 \" } */\n+  T (\"%.*i\", P (uchar_t), V (uchar_t));    /* { dg-warning \"up to 255 \" } */\n+\n+  T (\"%.*i\", P (sshort_t), V (sshort_t));  /* { dg-warning \"up to 32768 \" } */\n+  T (\"%.*i\", P (ushort_t), V (ushort_t)); /* { dg-warning \"up to 65535 \" } */\n+\n+  T (\"%.*i\", P (sint_t), V (sint_t));  /* { dg-warning \"up to 2147483648 \" } */\n+  T (\"%.*i\", P (uint_t), V (uint_t)); /* { dg-warning \"up to 2147483648 \" } */\n+\n+  /* Exercise calls with invalid arguments (to verify there is no ICE).  */\n+  T (\"%.*li\", P (slong_t), V (slong_t));  /* { dg-warning \"up to 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%.*li\", P (ulong_t), V (ulong_t)); /* { dg-warning \"up to 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  T (\"%.*lli\", P (sllong_t), V (sllong_t));  /* { dg-warning \"up to 2147483648\" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%.*lli\", P (ullong_t), V (ullong_t)); /* { dg-warning \"up to 2147483648\" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  T (\"%.*i\", P (float), V (int));  /* { dg-warning \"up to 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+  T (\"%.*i\", P (double), V (int)); /* { dg-warning \"up to 2147483648 \" } */\n+  /* { dg-warning \"expects argument of type .int.\" \"\" { target *-*-* } .-1 } */\n+\n+  {\n+    /* Similar to the corresponding width case, create an unsigned range\n+       with a lower bound greater than 1 and an upper bound in excess of\n+       INT_MAX and verify that the lower bound isn't used as the minimum\n+       output (since the excessive upper bound wraps around zero).  */\n+    extern unsigned p;\n+    if (p < 7 || (unsigned)-1 - 9 < p)\n+      p = 7;\n+\n+    T (\"%.*u\", p, V (int));   /* { dg-warning \"up to 2147483647 \" } */\n+  }\n+\n+  {\n+    /* Verify that enums are correctly handled.  */\n+    enum PrecEnum { e9 = 9, e17 = 17 };\n+    enum PrecEnum p = V (enum PrecEnum);\n+    if (p < e9 || e17 < p)\n+      p = e9;\n+\n+    T (\"%.*u\", p, V (int));   /* { dg-warning \"between 9 and 17 \" } */\n+  }\n+}"}]}