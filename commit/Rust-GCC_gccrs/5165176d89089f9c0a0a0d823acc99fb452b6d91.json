{"sha": "5165176d89089f9c0a0a0d823acc99fb452b6d91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE2NTE3NmQ4OTA4OWY5YzBhMGEwZDgyM2FjYzk5ZmI0NTJiNmQ5MQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-02-19T17:50:20Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-02-19T17:50:20Z"}, "message": "(offsettable_memory_operand): New function.\n\n(alignable_memory_operand): New function.\n(gen_rotated_half_load): New function.\n(get_arm_condition_code): Extract the mode of the comparison and\nuse it to generate the correct return value.\n\nFrom-SVN: r11304", "tree": {"sha": "0e18f6dc10a7de868f2c19941df60c18996fafe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e18f6dc10a7de868f2c19941df60c18996fafe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5165176d89089f9c0a0a0d823acc99fb452b6d91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5165176d89089f9c0a0a0d823acc99fb452b6d91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5165176d89089f9c0a0a0d823acc99fb452b6d91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5165176d89089f9c0a0a0d823acc99fb452b6d91/comments", "author": null, "committer": null, "parents": [{"sha": "d944f453bba09441261a72397b9f7e97f7c7afdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d944f453bba09441261a72397b9f7e97f7c7afdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d944f453bba09441261a72397b9f7e97f7c7afdb"}], "stats": {"total": 127, "additions": 116, "deletions": 11}, "files": [{"sha": "37bc901f9d9ce554796aa8f66f19b89c562cdbf9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 116, "deletions": 11, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5165176d89089f9c0a0a0d823acc99fb452b6d91/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5165176d89089f9c0a0a0d823acc99fb452b6d91/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5165176d89089f9c0a0a0d823acc99fb452b6d91", "patch": "@@ -1404,6 +1404,50 @@ arm_not_operand (op, mode)\n \t\t  || const_ok_for_arm (~INTVAL (op)))));\n }\n \n+/* Return TRUE if the operand is a memory reference which contains an\n+   offsettable address.  */\n+int\n+offsettable_memory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  return (mode == GET_MODE (op)\n+\t  && GET_CODE (op) == MEM\n+\t  && offsettable_address_p (reload_completed | reload_in_progress,\n+\t\t\t\t    mode, XEXP (op, 0)));\n+}\n+\n+/* Return TRUE if the operand is a memory reference which is, or can be\n+   made word aligned by adjusting the offset.  */\n+int\n+alignable_memory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx reg;\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  if (mode != GET_MODE (op) || GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  return ((GET_CODE (reg = op) == REG\n+\t   || (GET_CODE (op) == SUBREG\n+\t       && GET_CODE (reg = SUBREG_REG (op)) == REG)\n+\t   || (GET_CODE (op) == PLUS\n+\t       && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && (GET_CODE (reg = XEXP (op, 0)) == REG\n+\t\t   || (GET_CODE (XEXP (op, 0)) == SUBREG\n+\t\t       && GET_CODE (reg = SUBREG_REG (XEXP (op, 0))) == REG))))\n+\t  && REGNO_POINTER_ALIGN (REGNO (reg)) >= 4);\n+}\n+\n /* Return TRUE for valid operands for the rhs of an FPU instruction.  */\n \n int\n@@ -2110,6 +2154,35 @@ arm_gen_movstrqi (operands)\n   return 1;\n }\n \n+/* Generate a memory reference for a half word, such that it will be loaded\n+   into the top 16 bits of the word.  We can assume that the address is\n+   known to be alignable and of the form reg, or plus (reg, const).  */\n+rtx\n+gen_rotated_half_load (memref)\n+     rtx memref;\n+{\n+  HOST_WIDE_INT offset = 0;\n+  rtx base = XEXP (memref, 0);\n+\n+  if (GET_CODE (base) == PLUS)\n+    {\n+      offset = INTVAL (XEXP (base, 1));\n+      base = XEXP (base, 0);\n+    }\n+\n+  /* If we aren't allowed to generate unalligned addresses, then fail.  */\n+  if (TARGET_SHORT_BY_BYTES\n+      && ((BYTES_BIG_ENDIAN ? 1 : 0) ^ ((offset & 2) == 0)))\n+    return NULL;\n+\n+  base = gen_rtx (MEM, SImode, plus_constant (base, offset & ~2));\n+\n+  if ((BYTES_BIG_ENDIAN ? 1 : 0) ^ ((offset & 2) == 2))\n+    return base;\n+\n+  return gen_rtx (ROTATE, SImode, base, GEN_INT (16));\n+}\n+\n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n    return the rtx for register 0 in the proper mode.  FP means this is a\n    floating point compare: I don't think that it is needed on the arm.  */\n@@ -4208,18 +4281,50 @@ int\n get_arm_condition_code (comparison)\n      rtx comparison;\n {\n-  switch (GET_CODE (comparison))\n+  enum machine_mode mode = GET_MODE (XEXP (comparison, 0));\n+\n+  if (GET_MODE_CLASS (mode) != MODE_CC)\n+    mode = SELECT_CC_MODE (GET_CODE (comparison), XEXP (comparison, 0),\n+\t\t\t   XEXP (comparison, 1));\n+\n+  switch (mode)\n     {\n-    case NE: return (1);\n-    case EQ: return (0);\n-    case GE: return (10);\n-    case GT: return (12);\n-    case LE: return (13);\n-    case LT: return (11);\n-    case GEU: return (2);\n-    case GTU: return (8);\n-    case LEU: return (9);\n-    case LTU: return (3);\n+    case CC_NOOVmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase NE: return 1;\n+\tcase EQ: return 0;\n+\tcase GE: return 5;\n+\tcase LT: return 4;\n+\tdefault: abort ();\n+\t}\n+\n+    case CC_Zmode:\n+    case CCFPmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase NE: return 1;\n+\tcase EQ: return 0;\n+\tdefault: abort ();\n+\t}\n+\n+    case CCFPEmode:\n+    case CCmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase NE: return 1;\n+\tcase EQ: return 0;\n+\tcase GE: return 10;\n+\tcase GT: return 12;\n+\tcase LE: return 13;\n+\tcase LT: return 11;\n+\tcase GEU: return 2;\n+\tcase GTU: return 8;\n+\tcase LEU: return 9;\n+\tcase LTU: return 3;\n+\tdefault: abort ();\n+\t}\n+\n     default: abort ();\n     }\n   /*NOTREACHED*/"}]}