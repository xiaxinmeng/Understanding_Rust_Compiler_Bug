{"sha": "7009b073c56b40b280408c0ab69957651372c42e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAwOWIwNzNjNTZiNDBiMjgwNDA4YzBhYjY5OTU3NjUxMzcyYzQyZQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-09-28T17:30:09Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-09-28T17:30:09Z"}, "message": "Redesign Graphite scop detection\n\nRedesign Graphite scop detection for faster compiler time and detecting more SCoPs.\n\nExisting algorithm for SCoP detection in graphite was based on dominator tree\nwhere a tree (CFG) traversal was required for analyzing an SESE. The tree\ntraversal is linear in the number of basic blocks and SCoP detection is\n(probably) linear in number of instructions. That algorithm utilized a generic\ninfrastructure of SESE which does not directly represent loops.  With regards to\ngraphite framework, we are only interested in subtrees with loops. The new\nalgorithm is geared towards tree traversal on loop structure. The algorithm is\nlinear in number of loops which is faster than the previous algorithm.\n\nBriefly, we start the traversal at a loop-nest and analyze it recursively for\nvalidity. Once a valid loop is found we find a valid adjacent loop. If an\nadjacent loop is found and is valid, we merge both loop nests otherwise we form\na SCoP from the previous loop nest, and resume the algorithm from the adjacent\nloop nest. The data structure to represent an SESE is an ordered pair of edges\n(entry, exit). The new algoritm can extend a SCoP in both the directions. With\nthis approach, the number of instructions to be analyzed for validity reduces to\na minimal set.  We start by analyzing those statements which are inside a loop,\nbecause validity of those statements is necessary for the validity of loop. The\nstatements outside the loop nest can be just excluded from the SESE if they are\nnot valid.\n\nThis patch depends on: https://gcc.gnu.org/ml/gcc-patches/2015-09/msg02024.html\n\nPasses (c,c++,fortran) regtest and bootstrap.\n\ngcc/ChangeLog:\n\n2015-09-27  Aditya Kumar  <hiraditya@msn.com>\n            Sebastian Pop  <s.pop@samsung.com>\n        * graphite-optimize-isl.c (optimize_isl):\n        * graphite-scop-detection.c (struct sese_l): New type.\n        (get_entry_bb): API for getting entry bb of SESE.\n        (get_exit_bb): API for getting exit bb of SESE.\n        (class debug_printer): New type. Simple printer in debug mode.\n        (trivially_empty_bb_p): New. Return true when BB is empty or\n\tcontains only debug instructions.\n        (graphite_can_represent_expr): Call scalar_evoution_in_region\n\tinstead of analyze_scalar_evolution. Pass in scop instead of only\n\tthe scop entry.\n        (stmt_has_simple_data_refs_p): Pass in scop instead of only the\n\tscop entry.\n        (stmt_simple_for_scop_p): Same.\n        (harmful_stmt_in_bb): Same.\n        (graphite_can_represent_loop): Deleted.\n        (struct scopdet_info): Deleted.\n        (scopdet_basic_block_info): Deleted.\n        (build_scops_1): Deleted.\n        (bb_in_sd_region): Deleted.\n        (find_single_entry_edge): Deleted.\n        (find_single_exit_edge): Deleted.\n        (create_single_entry_edge): Deleted.\n        (sd_region_without_exit): Deleted.\n        (create_single_exit_edge): Deleted.\n        (unmark_exit_edges): Deleted.\n        (mark_exit_edges): Deleted.\n        (create_sese_edges): Deleted.\n        (build_graphite_scops): Deleted.\n        (canonicalize_loop_closed_ssa): Recompute all dominators at the\n\tend.\n        (build_scops): Use the new scop_builder to build scops.\n        (dot_all_scops_1): Use the new pretty printer. Print loop father\n\tas well.\n        (loop_body_is_valid_scop): New. Return true if loop body is a\n\tvalid scop.\n        (class scop_builder): New. Builds SCoPs for polyhedral\n\toptimizatios.\n        (scop_builder): New. Constructor.\n        (static sese_l invalid_sese): sese_l with invalid edges.\n        (get_sese): Get an sese (from a loop) if possible, invalid_sese\n\totherwise.\n        (get_nearest_dom_with_single_entry): Get nearest dominator of a\n\tbasic_block with single entry. Return NULL if we get to the\n\tbeginning of a function.\n        (get_nearest_pdom_with_single_exit): Get nearest post-dominator of\n\ta basic_block with single exit. Return NULL if we get to the\n\tbeginning of a function.\n        (print_sese): Pretty-print SESE.\n        (merge_sese): Merge two SESEs if possible and return the new SESE.\n        (build_scop_depth): Start building the SCoP within a loop nest.\n        (build_scop_breadth): Start building the SCoP at a single loop\n\tdepth. Merge adjacent SESEs if valid.\n        (can_represent_loop_1): Returns true if Graphite can represent\n\tloop inside SCoP. Helper for can_represent_loop.\n        (can_represent_loop): Returns true if Graphite can represent LOOP\n\tand all its nested loops in SCoP.\n        (loop_is_valid_scop): Returns true if LOOP and all its nests\n\tconstitute a valid SCoP.\n        (region_has_one_loop): Returns true of a region has only one loop.\n        (add_scop): Add SCoP to the list of valid scops. Removes an\n\talready existing scop if it intersects with or subsumed by this\n\tone.\n        (harmful_stmt_in_region): Returns true if SCoP has any statment\n\twhich cannot be represented by Graphite.\n        (subsumes): Returns true of SCoP S1 subsumes SCoP S2.\n        (remove_subscops): Remove any SCoP from the list of already found\n\tSCoPs, if subsumed by S1.\n        (intersects): Return true if region bounded by SCoPs S1 and S2\n\tintersect.\n        (remove_intersecting_scops): Remove any SCoP which intersects with\n\tS1.\n        * graphite.c (print_graphite_scop_statistics):\n        (print_graphite_statistics): Print SCoP info while debugging.\n        (graphite_initialize): Early exit in case number of loops in a\n\tfunction is less than PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION or\n\tbasic blocks are more than PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION.\n        (graphite_finalize):\n        * params.def: Add PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION.\n        * sese.h (sese_loop_depth): Remove unnecessary gcc_assert.\n        (recompute_all_dominators): Recalculate POST_DOMINATORS.\n        * tree-cfg.c (print_loops): Print the function name while printing\n\tloops.\n\ngcc/testsuite/ChangeLog:\n\n2015-09-27  Aditya Kumar  <hiraditya@msn.com>\n            Sebastian Pop  <s.pop@samsung.com>\n        * gcc.dg/graphite/block-1.c: Modified to match the pattern.\n        * gcc.dg/graphite/block-3.c: Same.\n        * gcc.dg/graphite/block-4.c: Same.\n        * gcc.dg/graphite/block-5.c: Same.\n        * gcc.dg/graphite/block-6.c: Same.\n        * gcc.dg/graphite/block-7.c: Same.\n        * gcc.dg/graphite/block-8.c: Same.\n        * gcc.dg/graphite/block-pr47654.c: Same.\n        * gcc.dg/graphite/interchange-0.c: Same.\n        * gcc.dg/graphite/interchange-1.c: Same.\n        * gcc.dg/graphite/interchange-10.c: Same.\n        * gcc.dg/graphite/interchange-11.c: Same.\n        * gcc.dg/graphite/interchange-12.c: Same.\n        * gcc.dg/graphite/interchange-13.c: Same.\n        * gcc.dg/graphite/interchange-14.c: Same.\n        * gcc.dg/graphite/interchange-15.c: Same.\n        * gcc.dg/graphite/interchange-3.c: Same.\n        * gcc.dg/graphite/interchange-4.c: Same.\n        * gcc.dg/graphite/interchange-5.c: Same.\n        * gcc.dg/graphite/interchange-6.c: Same.\n        * gcc.dg/graphite/interchange-7.c: Same.\n        * gcc.dg/graphite/interchange-8.c: Same.\n        * gcc.dg/graphite/interchange-9.c: Same.\n        * gcc.dg/graphite/interchange-mvt.c: Same.\n        * gcc.dg/graphite/pr35356-1.c (foo): Same.\n        * gcc.dg/graphite/pr35356-3.c: Same.\n        * gcc.dg/graphite/pr37485.c: Same.\n        * gcc/testsuite/gcc.dg/graphite/run-id-pr67700-1.c: New test case.\n        * gcc.dg/graphite/scop-1.c (int toto): Modified to match the pattern.\n        * gcc.dg/graphite/scop-11.c: Same.\n        * gcc.dg/graphite/scop-5.c: Same.\n        * gcc.dg/graphite/uns-block-1.c: Same.\n        * gcc.dg/graphite/uns-interchange-9.c: Same.\n        * gfortran.dg/graphite/block-1.f90: Same.\n        * gfortran.dg/graphite/interchange-3.f90: Same.\n        * gfortran.dg/graphite/pr14741.f90: Same.\n\nFrom-SVN: r228215", "tree": {"sha": "62c283455b6a2c87b52450b5abaaebd969cf52a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62c283455b6a2c87b52450b5abaaebd969cf52a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7009b073c56b40b280408c0ab69957651372c42e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7009b073c56b40b280408c0ab69957651372c42e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7009b073c56b40b280408c0ab69957651372c42e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7009b073c56b40b280408c0ab69957651372c42e/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5b5a232d4555659943c2776d1df753e5c0387f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b5a232d4555659943c2776d1df753e5c0387f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5b5a232d4555659943c2776d1df753e5c0387f3"}], "stats": {"total": 1884, "additions": 905, "deletions": 979}, "files": [{"sha": "ccfd4a8252fb021067987f491aa4e789e3500fa4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -1,3 +1,89 @@\n+2015-09-28  Aditya Kumar  <aditya.k7@samsung.com>\n+            Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-optimize-isl.c (optimize_isl): Use ISL_SCHEDULE_FUSE_MAX.\n+\t* graphite-scop-detection.c (struct sese_l): New type.\n+\t(get_entry_bb): API for getting entry bb of SESE.\n+\t(get_exit_bb): API for getting exit bb of SESE.\n+\t(class debug_printer): New type.  Simple printer in debug mode.\n+\t(trivially_empty_bb_p): New.  Return true when BB is empty or\n+\tcontains only debug instructions.\n+\t(graphite_can_represent_expr): Call scalar_evoution_in_region\n+\tinstead of analyze_scalar_evolution.  Pass in scop instead of only\n+\tthe scop entry.\n+\t(stmt_has_simple_data_refs_p): Pass in scop instead of only the\n+\tscop entry.\n+\t(stmt_simple_for_scop_p): Same.\n+\t(harmful_stmt_in_bb): Same.\n+\t(graphite_can_represent_loop): Deleted.\n+\t(struct scopdet_info): Deleted.\n+\t(scopdet_basic_block_info): Deleted.\n+\t(build_scops_1): Deleted.\n+\t(bb_in_sd_region): Deleted.\n+\t(find_single_entry_edge): Deleted.\n+\t(find_single_exit_edge): Deleted.\n+\t(create_single_entry_edge): Deleted.\n+\t(sd_region_without_exit): Deleted.\n+\t(create_single_exit_edge): Deleted.\n+\t(unmark_exit_edges): Deleted.\n+\t(mark_exit_edges): Deleted.\n+\t(create_sese_edges): Deleted.\n+\t(build_graphite_scops): Deleted.\n+\t(canonicalize_loop_closed_ssa): Recompute all dominators at the\n+\tend.\n+\t(build_scops): Use the new scop_builder to build scops.\n+\t(dot_all_scops_1): Use the new pretty printer.  Print loop father\n+\tas well.\n+\t(loop_body_is_valid_scop): New.  Return true if loop body is a\n+\tvalid scop.\n+\t(class scop_builder): New.  Builds SCoPs for polyhedral\n+\toptimizations.\n+\t(scop_builder): New constructor.\n+\t(static sese_l invalid_sese): sese_l with invalid edges.\n+\t(get_sese): Get an sese (from a loop) if possible, invalid_sese\n+\totherwise.\n+\t(get_nearest_dom_with_single_entry): Get nearest dominator of a\n+\tbasic_block with single entry.  Return NULL if we get to the\n+\tbeginning of a function.\n+\t(get_nearest_pdom_with_single_exit): Get nearest post-dominator of\n+\ta basic_block with single exit.  Return NULL if we get to the\n+\tbeginning of a function.\n+\t(print_sese): Pretty-print SESE.\n+\t(merge_sese): Merge two SESEs if possible and return the new SESE.\n+\t(build_scop_depth): Start building the SCoP within a loop nest.\n+\t(build_scop_breadth): Start building the SCoP at a single loop\n+\tdepth.  Merge adjacent SESEs if valid.\n+\t(can_represent_loop_1): Returns true if Graphite can represent\n+\tloop inside SCoP.  Helper for can_represent_loop.\n+\t(can_represent_loop): Returns true if Graphite can represent LOOP\n+\tand all its nested loops in SCoP.\n+\t(loop_is_valid_scop): Returns true if LOOP and all its nests\n+\tconstitute a valid SCoP.\n+\t(region_has_one_loop): Returns true of a region has only one loop.\n+\t(add_scop): Add SCoP to the list of valid scops.  Removes an\n+\talready existing scop if it intersects with or subsumed by this\n+\tone.\n+\t(harmful_stmt_in_region): Returns true if SCoP has any statment\n+\twhich cannot be represented by Graphite.\n+\t(subsumes): Returns true of SCoP S1 subsumes SCoP S2.\n+\t(remove_subscops): Remove any SCoP from the list of already found\n+\tSCoPs, if subsumed by S1.\n+\t(intersects): Return true if region bounded by SCoPs S1 and S2\n+\tintersect.\n+\t(remove_intersecting_scops): Remove any SCoP which intersects with\n+\tS1.\n+\t* graphite.c (print_graphite_scop_statistics):\n+\t(print_graphite_statistics): Print SCoP info while debugging.\n+\t(graphite_initialize): Early exit in case number of loops in a\n+\tfunction is less than PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION or\n+\tbasic blocks are more than PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION.\n+\t(graphite_finalize):\n+\t* params.def: Add PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION.\n+\t* sese.h (sese_loop_depth): Remove unnecessary gcc_assert.\n+\t(recompute_all_dominators): Recalculate POST_DOMINATORS.\n+\t* tree-cfg.c (print_loops): Print the function name while printing\n+\tloops.\n+\n 2015-09-28  Aditya Kumar  <aditya.k7@samsung.com>\n             Sebastian Pop  <s.pop@samsung.com>\n \n@@ -11,8 +97,8 @@\n \n 2015-09-28  David Wohlferd  <dw@LimeGreenSocks.com>\n \n-         * doc/extend.texi (Asm Labels): Break out text for data vs\n-\t functions.\n+        * doc/extend.texi (Asm Labels): Break out text for data vs\n+\tfunctions.\n \n 2015-09-28  Jiong Wang  <jiong.wang@arm.com>\n "}, {"sha": "4b821741afb85c2459a9b2774bace840874801cb", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -329,7 +329,7 @@ optimize_isl (scop_p scop)\n #ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   isl_options_set_schedule_serialize_sccs (scop->ctx, 1);\n #else\n-  isl_options_set_schedule_fuse (scop->ctx, ISL_SCHEDULE_FUSE_MIN);\n+  isl_options_set_schedule_fuse (scop->ctx, ISL_SCHEDULE_FUSE_MAX);\n #endif\n \n #ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE"}, {"sha": "a498ddcdbfc1dfb7b0ececb1386712ed6299ff95", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 621, "deletions": 906, "changes": 1527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"backend.h\"\n #include \"cfghooks.h\"\n+#include \"params.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"ssa.h\"\n@@ -53,108 +54,83 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite-scop-detection.h\"\n #include \"gimple-pretty-print.h\"\n \n-/* Forward declarations.  */\n-static void make_close_phi_nodes_unique (basic_block);\n+/* Lightweight representation of sese for scop detection.\n+   TODO: Make all this as a constant_edge.  */\n+struct sese_l\n+{\n+  sese_l (edge e, edge x)\n+  : entry (e), exit (x)\n+  { }\n \n-/* The type of the analyzed basic block.  */\n+  operator bool () const\n+  {\n+    return entry && exit;\n+  }\n \n-enum gbb_type {\n-  GBB_UNKNOWN,\n-  GBB_LOOP_SING_EXIT_HEADER,\n-  GBB_LOOP_MULT_EXIT_HEADER,\n-  GBB_LOOP_EXIT,\n-  GBB_COND_HEADER,\n-  GBB_SIMPLE,\n-  GBB_LAST\n+  edge entry;\n+  edge exit;\n };\n \n-/* Detect the type of BB.  Loop headers are only marked, if they are\n-   new.  This means their loop_father is different to LAST_LOOP.\n-   Otherwise they are treated like any other bb and their type can be\n-   any other type.  */\n-\n-static gbb_type\n-get_bb_type (basic_block bb, struct loop *last_loop)\n+/* APIs for getting entry/exit of an sese.  */\n+static basic_block\n+get_entry_bb (edge e)\n {\n-  vec<basic_block> dom;\n-  int nb_dom;\n-  struct loop *loop = bb->loop_father;\n-\n-  /* Check, if we entry into a new loop. */\n-  if (loop != last_loop)\n-    {\n-      if (single_exit (loop) != NULL)\n-        return GBB_LOOP_SING_EXIT_HEADER;\n-      else if (loop->num != 0)\n-        return GBB_LOOP_MULT_EXIT_HEADER;\n-      else\n-\treturn GBB_COND_HEADER;\n-    }\n-\n-  dom = get_dominated_by (CDI_DOMINATORS, bb);\n-  nb_dom = dom.length ();\n-  dom.release ();\n-\n-  if (nb_dom == 0)\n-    return GBB_LAST;\n-\n-  if (nb_dom == 1 && single_succ_p (bb))\n-    return GBB_SIMPLE;\n-\n-  return GBB_COND_HEADER;\n+  return e->dest;\n }\n \n-/* A SCoP detection region, defined using bbs as borders.\n-\n-   All control flow touching this region, comes in passing basic_block\n-   ENTRY and leaves passing basic_block EXIT.  By using bbs instead of\n-   edges for the borders we are able to represent also regions that do\n-   not have a single entry or exit edge.\n-\n-   But as they have a single entry basic_block and a single exit\n-   basic_block, we are able to generate for every sd_region a single\n-   entry and exit edge.\n-\n-   1   2\n-    \\ /\n-     3\t<- entry\n-     |\n-     4\n-    / \\\t\t\tThis region contains: {3, 4, 5, 6, 7, 8}\n-   5   6\n-   |   |\n-   7   8\n-    \\ /\n-     9\t<- exit  */\n-\n+static basic_block\n+get_exit_bb (edge e)\n+{\n+  return e->src;\n+}\n \n-struct sd_region\n+class debug_printer\n {\n-  /* The entry bb dominates all bbs in the sd_region.  It is part of\n-     the region.  */\n-  basic_block entry;\n+private:\n+  FILE *dump_file;\n+public:\n+  void set_dump_file (FILE *f)\n+  {\n+    gcc_assert (f);\n+    dump_file = f;\n+  }\n \n-  /* The exit bb postdominates all bbs in the sd_region, but is not\n-     part of the region.  */\n-  basic_block exit;\n-};\n+  friend debug_printer &operator<<(debug_printer &output, int i)\n+  {\n+    fprintf (output.dump_file, \"%d\", i);\n+    return output;\n+  }\n+  friend debug_printer &operator<<(debug_printer &output, const char *s)\n+  {\n+    fprintf (output.dump_file, \"%s\", s);\n+    return output;\n+  }\n+} dp;\n \n+#define DEBUG_PRINT(args) do \\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (dump_file && (dump_flags & TDF_DETAILS)) { args; }\t\\\n+    } while (0);\n \n \n-/* Moves the scops from SOURCE to TARGET and clean up SOURCE.  */\n+/* Return true if BB is empty, contains only DEBUG_INSNs.  */\n \n-static void\n-move_sd_regions (vec<sd_region> *source, vec<sd_region> *target)\n+static bool\n+trivially_empty_bb_p (basic_block bb)\n {\n-  sd_region *s;\n-  int i;\n+  gimple_stmt_iterator gsi;\n \n-  FOR_EACH_VEC_ELT (*source, i, s)\n-    target->safe_push (*s);\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (gimple_code (gsi_stmt (gsi)) != GIMPLE_DEBUG)\n+      return false;\n \n-  source->release ();\n+  return true;\n }\n \n+\n+/* Forward declarations.  */\n+static void make_close_phi_nodes_unique (basic_block);\n+\n /* Something like \"n * m\" is not allowed.  */\n \n static bool\n@@ -267,36 +243,34 @@ graphite_can_represent_scev (tree scev)\n \n /* Return true when EXPR can be represented in the polyhedral model.\n \n-   This means an expression can be represented, if it is linear with\n-   respect to the loops and the strides are non parametric.\n-   LOOP is the place where the expr will be evaluated.  SCOP_ENTRY defines the\n-   entry of the region we analyse.  */\n+   This means an expression can be represented, if it is linear with respect to\n+   the loops and the strides are non parametric.  LOOP is the place where the\n+   expr will be evaluated.  SCOP defines the region we analyse.  */\n \n static bool\n-graphite_can_represent_expr (basic_block scop_entry, loop_p loop,\n-\t\t\t     tree expr)\n+graphite_can_represent_expr (sese_l scop, loop_p loop, tree expr)\n {\n-  tree scev = analyze_scalar_evolution (loop, expr);\n-\n-  scev = instantiate_scev (scop_entry, loop, scev);\n-\n+  sese region = new_sese (scop.entry, scop.exit);\n+  tree scev = scalar_evolution_in_region (region, loop, expr);\n+  free_sese (region);\n   return graphite_can_represent_scev (scev);\n }\n \n-/* Return true if the data references of STMT can be represented by\n-   Graphite.  */\n+/* Return true if the data references of STMT can be represented by Graphite.\n+   We try to analyze the data references in a loop contained in the SCOP.  */\n \n static bool\n-stmt_has_simple_data_refs_p (loop_p outermost_loop ATTRIBUTE_UNUSED,\n-\t\t\t     gimple *stmt)\n+stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n {\n   data_reference_p dr;\n   int j;\n   bool res = true;\n   vec<data_reference_p> drs = vNULL;\n   loop_p outer;\n+  loop_p loop_around_scop = get_entry_bb (scop.entry)->loop_father;\n \n-  for (outer = loop_containing_stmt (stmt); outer; outer = loop_outer (outer))\n+  for (outer = loop_containing_stmt (stmt); outer && outer != loop_around_scop;\n+       outer = loop_outer (outer))\n     {\n       graphite_find_data_references_in_stmt (outer,\n \t\t\t\t\t     loop_containing_stmt (stmt),\n@@ -330,19 +304,18 @@ stmt_has_simple_data_refs_p (loop_p outermost_loop ATTRIBUTE_UNUSED,\n   return res;\n }\n \n-/* Return true only when STMT is simple enough for being handled by\n-   Graphite.  This depends on SCOP_ENTRY, as the parameters are\n-   initialized relatively to this basic block, the linear functions\n-   are initialized to OUTERMOST_LOOP and BB is the place where we try\n-   to evaluate the STMT.  */\n+/* Return true only when STMT is simple enough for being handled by Graphite.\n+   This depends on SCOP, as the parameters are initialized relatively to\n+   this basic block, the linear functions are initialized based on the outermost\n+   loop containing STMT inside the SCOP.  BB is the place where we try to\n+   evaluate the STMT.  */\n \n static bool\n-stmt_simple_for_scop_p (basic_block scop_entry, loop_p outermost_loop,\n-\t\t\tgimple *stmt, basic_block bb)\n+stmt_simple_for_scop_p (sese_l scop, gimple *stmt, basic_block bb)\n {\n   loop_p loop = bb->loop_father;\n \n-  gcc_assert (scop_entry);\n+  gcc_assert (scop);\n \n   /* GIMPLE_ASM and GIMPLE_CALL may embed arbitrary side effects.\n      Calls have side-effects, except those to const or pure\n@@ -352,28 +325,20 @@ stmt_simple_for_scop_p (basic_block scop_entry, loop_p outermost_loop,\n \t  && !(gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE)))\n       || (gimple_code (stmt) == GIMPLE_ASM))\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"[scop-detection-fail] \");\n-\t  fprintf (dump_file, \"Graphite cannot handle this stmt:\\n\");\n-\t  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS);\n-\t}\n-\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] \"\n+\t\t      << \"Graphite cannot handle this stmt:\\n\";\n+\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS));\n       return false;\n     }\n \n   if (is_gimple_debug (stmt))\n     return true;\n \n-  if (!stmt_has_simple_data_refs_p (outermost_loop, stmt))\n+  if (!stmt_has_simple_data_refs_p (scop, stmt))\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"[scop-detection-fail] \");\n-\t  fprintf (dump_file, \"Graphite cannot handle data-refs in stmt:\\n\");\n-\t  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS);\n-\t}\n-\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] \"\n+\t\t      << \"Graphite cannot handle data-refs in stmt:\\n\";\n+\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS););\n       return false;\n     }\n \n@@ -395,30 +360,22 @@ stmt_simple_for_scop_p (basic_block scop_entry, loop_p outermost_loop,\n \t      || code == EQ_EXPR\n \t      || code == NE_EXPR))\n           {\n-\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t      {\n-\t\tfprintf (dump_file, \"[scop-detection-fail] \");\n-\t\tfprintf (dump_file, \"Graphite cannot handle cond stmt:\\n\");\n-\t\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS);\n-\t      }\n-\n+\t    DEBUG_PRINT (dp <<  \"[scop-detection-fail] \"\n+\t\t\t    << \"Graphite cannot handle cond stmt:\\n\";\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS));\n \t    return false;\n \t  }\n \n \tfor (unsigned i = 0; i < 2; ++i)\n \t  {\n \t    tree op = gimple_op (stmt, i);\n-\t    if (!graphite_can_represent_expr (scop_entry, loop, op)\n+\t    if (!graphite_can_represent_expr (scop, loop, op)\n \t\t/* We can only constrain on integer type.  */\n \t\t|| (TREE_CODE (TREE_TYPE (op)) != INTEGER_TYPE))\n \t      {\n-\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t  {\n-\t\t    fprintf (dump_file, \"[scop-detection-fail] \");\n-\t\t    fprintf (dump_file, \"Graphite cannot represent stmt:\\n\");\n-\t\t    print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS);\n-\t\t  }\n-\n+\t\tDEBUG_PRINT (dp <<  \"[scop-detection-fail] \"\n+\t\t\t        << \"Graphite cannot represent stmt:\\n\";\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS));\n \t\treturn false;\n \t      }\n \t  }\n@@ -432,764 +389,30 @@ stmt_simple_for_scop_p (basic_block scop_entry, loop_p outermost_loop,\n \n     default:\n       /* These nodes cut a new scope.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"[scop-detection-fail] \");\n-\t  fprintf (dump_file, \"Gimple stmt not handled in Graphite:\\n\");\n-\t  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS);\n-\t}\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] \"\n+\t\t      << \"Gimple stmt not handled in Graphite:\\n\";\n+\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS));\n       return false;\n     }\n \n   return false;\n }\n \n-/* Returns the statement of BB that contains a harmful operation: that\n+/* Return true when BB contains a harmful operation for a scop: that\n    can be a function call with side effects, the induction variables\n-   are not linear with respect to SCOP_ENTRY, etc.  The current open\n-   scop should end before this statement.  The evaluation is limited using\n-   OUTERMOST_LOOP as outermost loop that may change.  */\n+   are not linear with respect to SCOP, etc.  The current open\n+   scop should end before this statement.  */\n \n-static gimple *\n-harmful_stmt_in_bb (basic_block scop_entry, loop_p outer_loop, basic_block bb)\n+static bool\n+harmful_stmt_in_bb (sese_l scop, basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (!stmt_simple_for_scop_p (scop_entry, outer_loop, gsi_stmt (gsi), bb))\n-      return gsi_stmt (gsi);\n-\n-  return NULL;\n-}\n-\n-/* Return true if LOOP can be represented in the polyhedral\n-   representation.  This is evaluated taking SCOP_ENTRY and\n-   OUTERMOST_LOOP in mind.  */\n-\n-static bool\n-graphite_can_represent_loop (basic_block scop_entry, loop_p loop)\n-{\n-  tree niter;\n-  struct tree_niter_desc niter_desc;\n-\n-  if (!loop_nest_has_data_refs (loop))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"[scop-detection-fail] \");\n-\t  fprintf (dump_file, \"Loop %d does not have any data reference.\\n\",\n-\t\t   loop->num);\n-\t}\n-      return false;\n-    }\n-\n-  /* FIXME: For the moment, graphite cannot be used on loops that\n-     iterate using induction variables that wrap.  */\n-\n-  return number_of_iterations_exit (loop, single_exit (loop), &niter_desc, false)\n-    && niter_desc.control.no_overflow\n-    && (niter = number_of_latch_executions (loop))\n-    && !chrec_contains_undetermined (niter)\n-    && graphite_can_represent_expr (scop_entry, loop, niter);\n-}\n-\n-/* Store information needed by scopdet_* functions.  */\n-\n-struct scopdet_info\n-{\n-  /* Exit of the open scop would stop if the current BB is harmful.  */\n-  basic_block exit;\n-\n-  /* Where the next scop would start if the current BB is harmful.  */\n-  basic_block next;\n-\n-  /* The bb or one of its children contains open loop exits.  That means\n-     loop exit nodes that are not surrounded by a loop dominated by bb.  */\n-  bool exits;\n-\n-  /* The bb or one of its children contains only structures we can handle.  */\n-  bool difficult;\n-};\n-\n-static struct scopdet_info build_scops_1 (basic_block, loop_p,\n-\t\t\t\t\t  vec<sd_region> *, loop_p);\n-\n-/* Calculates BB infos. If bb is difficult we add valid SCoPs dominated by BB\n-   to SCOPS.  TYPE is the gbb_type of BB.  */\n-\n-static struct scopdet_info\n-scopdet_basic_block_info (basic_block bb, loop_p outermost_loop,\n-\t\t\t  vec<sd_region> *scops, gbb_type type)\n-{\n-  loop_p loop = bb->loop_father;\n-  struct scopdet_info result;\n-  gimple *stmt;\n-\n-  /* XXX: ENTRY_BLOCK_PTR could be optimized in later steps.  */\n-  basic_block entry_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-  stmt = harmful_stmt_in_bb (entry_block, outermost_loop, bb);\n-  result.difficult = (stmt != NULL);\n-  result.exit = NULL;\n-\n-  switch (type)\n-    {\n-    case GBB_LAST:\n-      result.next = NULL;\n-      result.exits = false;\n-\n-      /* Mark bbs terminating a SESE region difficult, if they start\n-\t a condition or if the block it exits to cannot be split\n-\t with make_forwarder_block.  */\n-      if (!single_succ_p (bb)\n-\t  || bb_has_abnormal_pred (single_succ (bb)))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"[scop-detection-fail] \");\n-\t      fprintf (dump_file, \"BB %d cannot be part of a scop.\\n\",\n-\t\t       bb->index);\n-\t    }\n-\n-\t  result.difficult = true;\n-\t}\n-      else\n-\tresult.exit = single_succ (bb);\n-\n-      break;\n-\n-    case GBB_SIMPLE:\n-      result.next = single_succ (bb);\n-      result.exits = false;\n-      result.exit = single_succ (bb);\n-      break;\n-\n-    case GBB_LOOP_SING_EXIT_HEADER:\n-      {\n-\tauto_vec<sd_region, 3> regions;\n-\tstruct scopdet_info sinfo;\n-\tedge exit_e = single_exit (loop);\n-\n-\tsinfo = build_scops_1 (bb, outermost_loop, &regions, loop);\n-\n-\tif (!graphite_can_represent_loop (entry_block, loop))\n-\t  {\n-\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t      {\n-\t\tfprintf (dump_file, \"[scop-detection-fail] \");\n-\t\tfprintf (dump_file, \"Graphite cannot represent loop %d.\\n\",\n-\t\t\t loop->num);\n-\t      }\n-\t    result.difficult = true;\n-\t  }\n-\n-\tresult.difficult |= sinfo.difficult;\n-\n-\t/* Try again with another loop level.  */\n-\tif (result.difficult\n-\t    && loop_depth (outermost_loop) + 1 == loop_depth (loop))\n-\t  {\n-\t    outermost_loop = loop;\n-\n-\t    regions.release ();\n-\t    regions.create (3);\n-\n-\t    sinfo = scopdet_basic_block_info (bb, outermost_loop, scops, type);\n-\n-\t    result = sinfo;\n-\t    result.difficult = true;\n-\n-\t    if (sinfo.difficult)\n-\t      move_sd_regions (&regions, scops);\n-\t    else\n-\t      {\n-\t\tsd_region open_scop;\n-\t\topen_scop.entry = bb;\n-\t\topen_scop.exit = exit_e->dest;\n-\t\tscops->safe_push (open_scop);\n-\t\tregions.release ();\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    result.exit = exit_e->dest;\n-\t    result.next = exit_e->dest;\n-\n-\t    /* If we do not dominate result.next, remove it.  It's either\n-\t       the exit block, or another bb dominates it and will\n-\t       call the scop detection for this bb.  */\n-\t    if (!dominated_by_p (CDI_DOMINATORS, result.next, bb))\n-\t      result.next = NULL;\n-\n-\t    if (exit_e->src->loop_father != loop)\n-\t      result.next = NULL;\n-\n-\t    result.exits = false;\n-\n-\t    if (result.difficult)\n-\t      move_sd_regions (&regions, scops);\n-\t    else\n-\t      regions.release ();\n-\t  }\n-\n-\tbreak;\n-      }\n-\n-    case GBB_LOOP_MULT_EXIT_HEADER:\n-      {\n-        /* XXX: For now we just do not join loops with multiple exits.  If the\n-           exits lead to the same bb it may be possible to join the loop.  */\n-        auto_vec<sd_region, 3> regions;\n-        vec<edge> exits = get_loop_exit_edges (loop);\n-        edge e;\n-        int i;\n-\tbuild_scops_1 (bb, loop, &regions, loop);\n-\n-\t/* Scan the code dominated by this loop.  This means all bbs, that are\n-\t   are dominated by a bb in this loop, but are not part of this loop.\n-\n-\t   The easiest case:\n-\t     - The loop exit destination is dominated by the exit sources.\n-\n-\t   TODO: We miss here the more complex cases:\n-\t\t  - The exit destinations are dominated by another bb inside\n-\t\t    the loop.\n-\t\t  - The loop dominates bbs, that are not exit destinations.  */\n-        FOR_EACH_VEC_ELT (exits, i, e)\n-          if (e->src->loop_father == loop\n-\t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src))\n-\t    {\n-\t      if (loop_outer (outermost_loop))\n-\t\toutermost_loop = loop_outer (outermost_loop);\n-\n-\t      /* Pass loop_outer to recognize e->dest as loop header in\n-\t\t build_scops_1.  */\n-\t      if (e->dest->loop_father->header == e->dest)\n-\t\tbuild_scops_1 (e->dest, outermost_loop, &regions,\n-\t\t\t       loop_outer (e->dest->loop_father));\n-\t      else\n-\t\tbuild_scops_1 (e->dest, outermost_loop, &regions,\n-\t\t\t       e->dest->loop_father);\n-\t    }\n-\n-        result.next = NULL;\n-        result.exit = NULL;\n-        result.difficult = true;\n-        result.exits = false;\n-        move_sd_regions (&regions, scops);\n-        exits.release ();\n-        break;\n-      }\n-    case GBB_COND_HEADER:\n-      {\n-\tauto_vec<sd_region, 3> regions;\n-\tstruct scopdet_info sinfo;\n-\tvec<basic_block> dominated;\n-\tint i;\n-\tbasic_block dom_bb;\n-\tbasic_block last_exit = NULL;\n-\tedge e;\n-\tresult.exits = false;\n-\n-\t/* First check the successors of BB, and check if it is\n-\t   possible to join the different branches.  */\n-\tFOR_EACH_VEC_SAFE_ELT (bb->succs, i, e)\n-\t  {\n-\t    /* Ignore loop exits.  They will be handled after the loop\n-\t       body.  */\n-\t    if (loop_exits_to_bb_p (loop, e->dest))\n-\t      {\n-\t\tresult.exits = true;\n-\t\tcontinue;\n-\t      }\n-\n-\t    /* Do not follow edges that lead to the end of the\n-\t       conditions block.  For example, in\n-\n-               |   0\n-\t       |  /|\\\n-\t       | 1 2 |\n-\t       | | | |\n-\t       | 3 4 |\n-\t       |  \\|/\n-               |   6\n-\n-\t       the edge from 0 => 6.  Only check if all paths lead to\n-\t       the same node 6.  */\n-\n-\t    if (!single_pred_p (e->dest))\n-\t      {\n-\t\t/* Check, if edge leads directly to the end of this\n-\t\t   condition.  */\n-\t\tif (!last_exit)\n-\t\t  last_exit = e->dest;\n-\n-\t\tif (e->dest != last_exit)\n-\t\t  result.difficult = true;\n-\n-\t\tcontinue;\n-\t      }\n-\n-\t    if (!dominated_by_p (CDI_DOMINATORS, e->dest, bb))\n-\t      {\n-\t\tresult.difficult = true;\n-\t\tcontinue;\n-\t      }\n-\n-\t    sinfo = build_scops_1 (e->dest, outermost_loop, &regions, loop);\n-\n-\t    result.exits |= sinfo.exits;\n-\t    result.difficult |= sinfo.difficult;\n-\n-\t    /* Checks, if all branches end at the same point.\n-\t       If that is true, the condition stays joinable.\n-\t       Have a look at the example above.  */\n-\t    if (sinfo.exit)\n-\t      {\n-\t\tif (!last_exit)\n-\t\t  last_exit = sinfo.exit;\n-\n-\t\tif (sinfo.exit != last_exit)\n-\t\t  result.difficult = true;\n-\t      }\n-\t    else\n-\t      result.difficult = true;\n-\t  }\n-\n-\tif (!last_exit)\n-\t  result.difficult = true;\n-\n-\t/* Join the branches of the condition if possible.  */\n-\tif (!result.exits && !result.difficult)\n-\t  {\n-\t    /* Only return a next pointer if we dominate this pointer.\n-\t       Otherwise it will be handled by the bb dominating it.  */\n-\t    if (dominated_by_p (CDI_DOMINATORS, last_exit, bb)\n-\t\t&& last_exit != bb)\n-\t      result.next = last_exit;\n-\t    else\n-\t      result.next = NULL;\n-\n-\t    result.exit = last_exit;\n-\n-\t    regions.release ();\n-\t    break;\n-\t  }\n-\n-\t/* Scan remaining bbs dominated by BB.  */\n-\tdominated = get_dominated_by (CDI_DOMINATORS, bb);\n-\n-\tFOR_EACH_VEC_ELT (dominated, i, dom_bb)\n-\t  {\n-\t    /* Ignore loop exits: they will be handled after the loop body.  */\n-\t    if (loop_depth (find_common_loop (loop, dom_bb->loop_father))\n-\t\t< loop_depth (loop))\n-\t      {\n-\t\tresult.exits = true;\n-\t\tcontinue;\n-\t      }\n-\n-\t    /* Ignore the bbs processed above.  */\n-\t    if (single_pred_p (dom_bb) && single_pred (dom_bb) == bb)\n-\t      continue;\n-\n-\t    if (loop_depth (loop) > loop_depth (dom_bb->loop_father))\n-\t      sinfo = build_scops_1 (dom_bb, outermost_loop, &regions,\n-\t\t\t\t     loop_outer (loop));\n-\t    else\n-\t      sinfo = build_scops_1 (dom_bb, outermost_loop, &regions, loop);\n-\n-\t    result.exits |= sinfo.exits;\n-\t    result.difficult = true;\n-\t    result.exit = NULL;\n-\t  }\n-\n-\tdominated.release ();\n-\n-\tresult.next = NULL;\n-\tmove_sd_regions (&regions, scops);\n-\n-\tbreak;\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return result;\n-}\n-\n-/* Starting from CURRENT we walk the dominance tree and add new sd_regions to\n-   SCOPS. The analyse if a sd_region can be handled is based on the value\n-   of OUTERMOST_LOOP. Only loops inside OUTERMOST loops may change.  LOOP\n-   is the loop in which CURRENT is handled.\n-\n-   TODO: These functions got a little bit big. They definitely should be cleaned\n-\t up.  */\n-\n-static struct scopdet_info\n-build_scops_1 (basic_block current, loop_p outermost_loop,\n-\t       vec<sd_region> *scops, loop_p loop)\n-{\n-  bool in_scop = false;\n-  sd_region open_scop;\n-  struct scopdet_info sinfo;\n-\n-  /* Initialize result.  */\n-  struct scopdet_info result;\n-  result.exits = false;\n-  result.difficult = false;\n-  result.next = NULL;\n-  result.exit = NULL;\n-  open_scop.entry = NULL;\n-  open_scop.exit = NULL;\n-  sinfo.exit = NULL;\n-\n-  /* Loop over the dominance tree.  If we meet a difficult bb, close\n-     the current SCoP.  Loop and condition header start a new layer,\n-     and can only be added if all bbs in deeper layers are simple.  */\n-  while (current != NULL)\n-    {\n-      sinfo = scopdet_basic_block_info (current, outermost_loop, scops,\n-\t\t\t\t\tget_bb_type (current, loop));\n-\n-      if (!in_scop && !(sinfo.exits || sinfo.difficult))\n-        {\n-\t  open_scop.entry = current;\n-\t  open_scop.exit = NULL;\n-          in_scop = true;\n-        }\n-      else if (in_scop && (sinfo.exits || sinfo.difficult))\n-        {\n-\t  open_scop.exit = current;\n-          scops->safe_push (open_scop);\n-          in_scop = false;\n-        }\n-\n-      result.difficult |= sinfo.difficult;\n-      result.exits |= sinfo.exits;\n-\n-      current = sinfo.next;\n-    }\n-\n-  /* Try to close open_scop, if we are still in an open SCoP.  */\n-  if (in_scop)\n-    {\n-      open_scop.exit = sinfo.exit;\n-      gcc_assert (open_scop.exit);\n-      if (open_scop.entry != open_scop.exit)\n-\tscops->safe_push (open_scop);\n-      else\n-\t{\n-\t  sinfo.difficult = true;\n-\t  sinfo.exits = false;\n-\t  sinfo.exit = NULL;\n-\t}\n-    }\n-\n-  result.exit = sinfo.exit;\n-  return result;\n-}\n-\n-/* Checks if a bb is contained in REGION.  */\n-\n-static bool\n-bb_in_sd_region (basic_block bb, sd_region *region)\n-{\n-  return bb_in_region (bb, region->entry, region->exit);\n-}\n-\n-/* Returns the single entry edge of REGION, if it does not exits NULL.  */\n-\n-static edge\n-find_single_entry_edge (sd_region *region)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  edge entry = NULL;\n-\n-  FOR_EACH_EDGE (e, ei, region->entry->preds)\n-    if (!bb_in_sd_region (e->src, region))\n-      {\n-\tif (entry)\n-\t  {\n-\t    entry = NULL;\n-\t    break;\n-\t  }\n-\n-\telse\n-\t  entry = e;\n-      }\n-\n-  return entry;\n-}\n-\n-/* Returns the single exit edge of REGION, if it does not exits NULL.  */\n-\n-static edge\n-find_single_exit_edge (sd_region *region)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  edge exit = NULL;\n-\n-  FOR_EACH_EDGE (e, ei, region->exit->preds)\n-    if (bb_in_sd_region (e->src, region))\n-      {\n-\tif (exit)\n-\t  {\n-\t    exit = NULL;\n-\t    break;\n-\t  }\n-\n-\telse\n-\t  exit = e;\n-      }\n-\n-  return exit;\n-}\n-\n-/* Create a single entry edge for REGION.  */\n-\n-static void\n-create_single_entry_edge (sd_region *region)\n-{\n-  if (find_single_entry_edge (region))\n-    return;\n-\n-  /* There are multiple predecessors for bb_3\n-\n-  |  1  2\n-  |  | /\n-  |  |/\n-  |  3\t<- entry\n-  |  |\\\n-  |  | |\n-  |  4 ^\n-  |  | |\n-  |  |/\n-  |  5\n-\n-  There are two edges (1->3, 2->3), that point from outside into the region,\n-  and another one (5->3), a loop latch, lead to bb_3.\n-\n-  We split bb_3.\n-\n-  |  1  2\n-  |  | /\n-  |  |/\n-  |3.0\n-  |  |\\     (3.0 -> 3.1) = single entry edge\n-  |3.1 |  \t<- entry\n-  |  | |\n-  |  | |\n-  |  4 ^\n-  |  | |\n-  |  |/\n-  |  5\n-\n-  If the loop is part of the SCoP, we have to redirect the loop latches.\n-\n-  |  1  2\n-  |  | /\n-  |  |/\n-  |3.0\n-  |  |      (3.0 -> 3.1) = entry edge\n-  |3.1  \t<- entry\n-  |  |\\\n-  |  | |\n-  |  4 ^\n-  |  | |\n-  |  |/\n-  |  5  */\n-\n-  if (region->entry->loop_father->header != region->entry\n-      || dominated_by_p (CDI_DOMINATORS,\n-\t\t\t loop_latch_edge (region->entry->loop_father)->src,\n-\t\t\t region->exit))\n-    {\n-      edge forwarder = split_block_after_labels (region->entry);\n-      region->entry = forwarder->dest;\n-    }\n-  else\n-    /* This case is never executed, as the loop headers seem always to have a\n-       single edge pointing from outside into the loop.  */\n-    gcc_unreachable ();\n-\n-  gcc_checking_assert (find_single_entry_edge (region));\n-}\n-\n-/* Check if the sd_region, mentioned in EDGE, has no exit bb.  */\n-\n-static bool\n-sd_region_without_exit (edge e)\n-{\n-  sd_region *r = (sd_region *) e->aux;\n-\n-  if (r)\n-    return r->exit == NULL;\n-  else\n-    return false;\n-}\n-\n-/* Create a single exit edge for REGION.  */\n-\n-static void\n-create_single_exit_edge (sd_region *region)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  edge forwarder = NULL;\n-  basic_block exit;\n-\n-  /* We create a forwarder bb (5) for all edges leaving this region\n-     (3->5, 4->5).  All other edges leading to the same bb, are moved\n-     to a new bb (6).  If these edges where part of another region (2->5)\n-     we update the region->exit pointer, of this region.\n-\n-     To identify which edge belongs to which region we depend on the e->aux\n-     pointer in every edge.  It points to the region of the edge or to NULL,\n-     if the edge is not part of any region.\n-\n-     1 2 3 4   \t1->5 no region, \t\t2->5 region->exit = 5,\n-      \\| |/    \t3->5 region->exit = NULL, \t4->5 region->exit = NULL\n-        5\t<- exit\n-\n-     changes to\n-\n-     1 2 3 4   \t1->6 no region, \t\t\t2->6 region->exit = 6,\n-     | | \\/\t3->5 no region,\t\t\t\t4->5 no region,\n-     | |  5\n-      \\| /\t5->6 region->exit = 6\n-\t6\n-\n-     Now there is only a single exit edge (5->6).  */\n-  exit = region->exit;\n-  region->exit = NULL;\n-  forwarder = make_forwarder_block (exit, &sd_region_without_exit, NULL);\n-\n-  /* Unmark the edges, that are no longer exit edges.  */\n-  FOR_EACH_EDGE (e, ei, forwarder->src->preds)\n-    if (e->aux)\n-      e->aux = NULL;\n-\n-  /* Mark the new exit edge.  */\n-  single_succ_edge (forwarder->src)->aux = region;\n-\n-  /* Update the exit bb of all regions, where exit edges lead to\n-     forwarder->dest.  */\n-  FOR_EACH_EDGE (e, ei, forwarder->dest->preds)\n-    if (e->aux)\n-      ((sd_region *) e->aux)->exit = forwarder->dest;\n-\n-  gcc_checking_assert (find_single_exit_edge (region));\n-}\n-\n-/* Unmark the exit edges of all REGIONS.\n-   See comment in \"create_single_exit_edge\". */\n-\n-static void\n-unmark_exit_edges (vec<sd_region> regions)\n-{\n-  int i;\n-  sd_region *s;\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_VEC_ELT (regions, i, s)\n-    FOR_EACH_EDGE (e, ei, s->exit->preds)\n-      e->aux = NULL;\n-}\n-\n-\n-/* Mark the exit edges of all REGIONS.\n-   See comment in \"create_single_exit_edge\". */\n-\n-static void\n-mark_exit_edges (vec<sd_region> regions)\n-{\n-  int i;\n-  sd_region *s;\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_VEC_ELT (regions, i, s)\n-    FOR_EACH_EDGE (e, ei, s->exit->preds)\n-      if (bb_in_sd_region (e->src, s))\n-\te->aux = s;\n-}\n-\n-/* Create for all scop regions a single entry and a single exit edge.  */\n-\n-static void\n-create_sese_edges (vec<sd_region> regions)\n-{\n-  int i;\n-  sd_region *s;\n-\n-  FOR_EACH_VEC_ELT (regions, i, s)\n-    create_single_entry_edge (s);\n-\n-  mark_exit_edges (regions);\n-\n-  FOR_EACH_VEC_ELT (regions, i, s)\n-    /* Don't handle multiple edges exiting the function.  */\n-    if (!find_single_exit_edge (s)\n-\t&& s->exit != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-      create_single_exit_edge (s);\n-\n-  unmark_exit_edges (regions);\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  fix_loop_structure (NULL);\n-\n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-  verify_ssa (false, true);\n-#endif\n-}\n-\n-/* Create graphite SCoPs from an array of scop detection REGIONS.  */\n-\n-static void\n-build_graphite_scops (vec<sd_region> regions,\n-\t\t      vec<scop_p> *scops)\n-{\n-  int i;\n-  sd_region *s;\n-\n-  FOR_EACH_VEC_ELT (regions, i, s)\n-    {\n-      edge entry = find_single_entry_edge (s);\n-      edge exit = find_single_exit_edge (s);\n-      scop_p scop;\n-\n-      if (!exit)\n-\tcontinue;\n-\n-      sese sese_reg = new_sese (entry, exit);\n-      scop = new_scop (sese_reg);\n-\n-      build_sese_loop_nests (sese_reg);\n-\n-      /* Scops with one or no loops are not interesting.  */\n-      if (SESE_LOOP_NEST (sese_reg).length () > 1)\n-\tscops->safe_push (scop);\n-      else if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Discarded scop: %d loops\\n\",\n-\t\t SESE_LOOP_NEST (sese_reg).length ());\n-\n-      /* Are there overlapping SCoPs?  */\n-#ifdef ENABLE_CHECKING\n-\t{\n-\t  int j;\n-\t  sd_region *s2;\n+    if (!stmt_simple_for_scop_p (scop, gsi_stmt (gsi), bb))\n+      return true;\n \n-\t  FOR_EACH_VEC_ELT (regions, j, s2)\n-\t    if (s != s2)\n-\t      gcc_assert (!bb_in_sd_region (s->entry, s2));\n-\t}\n-#endif\n-    }\n+  return false;\n }\n \n /* Returns true when P1 and P2 are close phis with the same\n@@ -1275,6 +498,7 @@ canonicalize_loop_closed_ssa (loop_p loop)\n   if (single_pred_p (bb))\n     {\n       e = split_block_after_labels (bb);\n+      DEBUG_PRINT (dp << \"\\nSplitting bb_\" << bb->index);\n       make_close_phi_nodes_unique (e->src);\n     }\n   else\n@@ -1283,6 +507,9 @@ canonicalize_loop_closed_ssa (loop_p loop)\n       basic_block close = split_edge (e);\n \n       e = single_succ_edge (close);\n+      DEBUG_PRINT (dp << \"\\nSplitting edge (\"\n+\t\t      << e->src->index << \",\" << e->dest->index\n+\t\t      << \")\\n\");\n \n       for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n \t{\n@@ -1316,7 +543,7 @@ canonicalize_loop_closed_ssa (loop_p loop)\n \n   /* The code above does not properly handle changes in the post dominance\n      information (yet).  */\n-  free_dominance_info (CDI_POST_DOMINATORS);\n+  recompute_all_dominators ();\n }\n \n /* Converts the current loop closed SSA form to a canonical form\n@@ -1360,29 +587,6 @@ canonicalize_loop_closed_ssa_form (void)\n #endif\n }\n \n-/* Find Static Control Parts (SCoP) in the current function and pushes\n-   them to SCOPS.  */\n-\n-void\n-build_scops (vec<scop_p> *scops)\n-{\n-  struct loop *loop = current_loops->tree_root;\n-  auto_vec<sd_region, 3> regions;\n-\n-  canonicalize_loop_closed_ssa_form ();\n-  build_scops_1 (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n-\t\t ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father,\n-\t\t &regions, loop);\n-  create_sese_edges (regions);\n-  build_graphite_scops (regions, scops);\n-\n-  regions.release ();\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nnumber of SCoPs: %d\\n\",\n-\t     scops ? scops->length () : 0);\n-}\n-\n /* Pretty print to FILE all the SCoPs in DOT format and mark them with\n    different colors.  If there are not enough colors, paint the\n    remaining SCoPs in gray.\n@@ -1500,6 +704,8 @@ dot_all_scops_1 (FILE *file, vec<scop_p> scops)\n \t      else\n \t\tfprintf (file, \" %d \", bb->index);\n \n+\t      fprintf (file, \"{lp_%d}\", bb->loop_father->num);\n+\n \t      if (!bb_in_sese_p (bb,region))\n \t\tfprintf (file, \")\");\n \n@@ -1511,7 +717,8 @@ dot_all_scops_1 (FILE *file, vec<scop_p> scops)\n       if (!part_of_scop)\n \t{\n \t  fprintf (file, \"    <TR><TD WIDTH=\\\"50\\\" BGCOLOR=\\\"#ffffff\\\">\");\n-\t  fprintf (file, \" %d </TD></TR>\\n\", bb->index);\n+\t  fprintf (file, \" %d {lp_%d} </TD></TR>\\n\",\n+\t\t   bb->index, bb->loop_father->num);\n \t}\n       fprintf (file, \"  </TABLE>>, shape=box, style=\\\"setlinewidth(0)\\\"]\\n\");\n     }\n@@ -1576,4 +783,512 @@ dot_scop (scop_p scop)\n #endif\n }\n \n+/* Return true when the body of LOOP has statements that can be represented as a\n+   valid scop.  */\n+\n+static bool\n+loop_body_is_valid_scop (loop_p loop, sese_l scop)\n+{\n+  if (!loop_nest_has_data_refs (loop))\n+    {\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\"\n+\t\t      << loop->num << \"does not have any data reference.\\n\");\n+      return false;\n+    }\n+\n+  basic_block *bbs = get_loop_body (loop);\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+\n+      if (harmful_stmt_in_bb (scop, bb))\n+\treturn false;\n+    }\n+  free (bbs);\n+  return true;\n+}\n+\n+/* Build the maximal scop containing LOOP(s) and add it to SCOPS.  */\n+\n+class scop_builder\n+{\n+ public:\n+  scop_builder (vec<scop_p> *s)\n+    : scops (s)\n+  { }\n+\n+  static sese_l invalid_sese;\n+\n+  sese_l get_sese (loop_p loop)\n+  {\n+    if (!loop)\n+      return invalid_sese;\n+\n+    if (!loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS))\n+      return invalid_sese;\n+    edge scop_end = single_exit (loop);\n+    if (!scop_end)\n+      return invalid_sese;\n+    edge scop_begin = loop_preheader_edge (loop);\n+    sese_l s (scop_begin, scop_end);\n+    return s;\n+  }\n+\n+  static edge\n+    get_nearest_dom_with_single_entry (basic_block dom)\n+  {\n+    if (!dom->preds)\n+      return NULL;\n+    /* If e1->src dominates e2->src then e1->src will also dominate dom.  */\n+    if (dom->preds->length () == 2)\n+      {\n+\tedge e1 = (*dom->preds)[0];\n+\tedge e2 = (*dom->preds)[1];\n+\tif (dominated_by_p (CDI_DOMINATORS, e2->src, e1->src))\n+\t  return e1;\n+\tif (dominated_by_p (CDI_DOMINATORS, e1->src, e2->src))\n+\t  return e2;\n+      }\n+\n+    while (dom->preds->length () != 1)\n+      {\n+\tif (dom->preds->length () < 1)\n+\t  return NULL;\n+\tdom = get_immediate_dominator (CDI_DOMINATORS, dom);\n+\tif (!dom->preds)\n+\t  return NULL;\n+      }\n+    return (*dom->preds)[0];\n+  }\n+\n+  static edge\n+    get_nearest_pdom_with_single_exit (basic_block dom)\n+  {\n+    if (!dom->succs)\n+      return NULL;\n+    if (dom->succs->length () == 2)\n+      {\n+\tedge e1 = (*dom->succs)[0];\n+\tedge e2 = (*dom->succs)[1];\n+\tif (dominated_by_p (CDI_POST_DOMINATORS, e2->dest, e1->dest))\n+\t  return e1;\n+\tif (dominated_by_p (CDI_POST_DOMINATORS, e1->dest, e2->dest))\n+\t  return e2;\n+      }\n+\n+    while (dom->succs->length () != 1)\n+      {\n+\tif (dom->succs->length () < 1)\n+\t  return NULL;\n+\tdom = get_immediate_dominator (CDI_POST_DOMINATORS, dom);\n+\tif (!dom->succs)\n+\t  return NULL;\n+      }\n+    return (*dom->succs)[0];\n+  }\n+\n+  /* Print S to FILE.  */\n+\n+  static void\n+    print_sese (FILE *file, sese_l s)\n+  {\n+    fprintf (file, \"(entry_edge (bb_%d, bb_%d), exit_edge (bb_%d, bb_%d))\\n\",\n+\t     s.entry->src->index, s.entry->dest->index,\n+\t     s.exit->src->index, s.exit->dest->index);\n+  }\n+\n+  /* Merge scops at same loop depth and returns the new sese.\n+     TODO: Free the already allocated sese's first and second, or reuse.\n+     Returns SECOND when first is NULL.  SECOND cannot be NULL.\n+     Frees up SECOND and returns a new SESE when merge was successful.\n+  */\n+\n+  static sese_l\n+    merge_sese (sese_l first, sese_l second)\n+  {\n+    /* In the trivial case first/second may be NULL.  */\n+    if (!first)\n+      return second;\n+    if (!second)\n+      return first;\n+\n+    DEBUG_PRINT (dp << \"[try-merging-sese] s1: \";\n+\t\t print_sese (dump_file, first);\n+\t\t dp << \"[try-merging-sese] s2: \";\n+\t\t print_sese (dump_file, second));\n+\n+    /* Assumption: Both the sese's should be at the same loop depth or one scop\n+       should subsume the other like in case of nested loops.  */\n+\n+    /* Find the common dominators for entry,\n+       and common post-dominators for the exit.  */\n+    basic_block dom = nearest_common_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\tget_entry_bb (first.entry),\n+\t\t\t\t\t\tget_entry_bb (second.entry));\n+\n+\n+    edge entry = get_nearest_dom_with_single_entry (dom);\n+    if (!entry)\n+      return invalid_sese;\n+\n+    basic_block pdom = nearest_common_dominator (CDI_POST_DOMINATORS,\n+\t\t\t\t\t\t get_exit_bb (first.exit),\n+\t\t\t\t\t\t get_exit_bb (second.exit));\n+    pdom = nearest_common_dominator (CDI_POST_DOMINATORS, dom, pdom);\n+\n+    edge exit = get_nearest_pdom_with_single_exit (pdom);\n+    if (!exit)\n+      return invalid_sese;\n+\n+    sese_l combined (entry, exit);\n+\n+    /* FIXME: We could iterate to find the dom which dominates pdom, and pdom\n+       which post-dominates dom, until it stabilizes.  Also, ENTRY->SRC and\n+       EXIT->DEST should be in the same loop nest.  */\n+    if (!dominated_by_p (CDI_DOMINATORS, pdom, dom)\n+\t|| loop_depth (entry->src->loop_father)\n+\t   != loop_depth (exit->dest->loop_father))\n+      return invalid_sese;\n+\n+    /* For now we just want to bail out when exit does not post-dominate entry.\n+       TODO: We might just add a basic_block at the exit to make exit\n+       post-dominate entry (the entrire region).  */\n+    if (!dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (entry),\n+                         get_exit_bb (exit))\n+\t|| !dominated_by_p (CDI_DOMINATORS, get_exit_bb (exit),\n+\t\t\t    get_entry_bb (entry)))\n+      {\n+\tDEBUG_PRINT (dp <<  \"[scop-detection-fail] cannot merge seses.\\n\");\n+\treturn invalid_sese;\n+      }\n+\n+    /* FIXME: We should remove this piece of code once\n+       canonicalize_loop_closed_ssa has been removed, because that function\n+       adds a BB with single exit.  */\n+    if (!trivially_empty_bb_p (get_exit_bb (combined.exit)))\n+      {\n+\t/* Find the first empty succ (with single exit) of combined.exit.  */\n+\tbasic_block imm_succ = combined.exit->dest;\n+\tif (single_succ_p (imm_succ) && trivially_empty_bb_p (imm_succ))\n+\t  combined.exit = single_succ_edge (imm_succ);\n+\telse\n+\t  {\n+\t    DEBUG_PRINT (dp << \"\\n[scop-detection-fail] Discarding SCoP because \"\n+\t\t\t    << \"no single exit (empty succ) for sese exit\";\n+\t\t\t print_sese (dump_file, combined));\n+\t    return invalid_sese;\n+\t  }\n+      }\n+\n+    /* Analyze all the BBs in new sese.  */\n+    if (harmful_stmt_in_region (combined))\n+      return invalid_sese;\n+\n+    DEBUG_PRINT (dp <<  \"[merged-sese] s1: \";\n+\t\t print_sese (dump_file, combined));\n+\n+    return combined;\n+  }\n+\n+  /* Build scop outer->inner if possible.  */\n+  sese_l\n+    build_scop_depth (sese_l s, loop_p loop)\n+  {\n+    if (!loop)\n+      return s;\n+\n+    DEBUG_PRINT (dp << \"\\n[Depth loop_\" << loop->num << \"]\");\n+    s = build_scop_depth (s, loop->inner);\n+\n+    sese_l s2 = merge_sese (s, get_sese (loop));\n+    if (!s2)\n+      {\n+\t/* s might be a valid scop, so return it and start analyzing from the\n+\t   adjacent loop.  */\n+\tbuild_scop_depth (invalid_sese, loop->next);\n+\treturn s;\n+      }\n+\n+    if (!loop_is_valid_scop (loop, s2))\n+      return build_scop_depth (invalid_sese, loop->next);\n+\n+    return build_scop_breadth (s2, loop);\n+  }\n+\n+  /* If loop and loop->next are valid scops, try to merge them.  */\n+\n+  sese_l\n+    build_scop_breadth (sese_l s1, loop_p loop)\n+  {\n+    if (!loop)\n+      return s1;\n+    DEBUG_PRINT (dp << \"\\n[Breadth loop_\" << loop->num << \"]\");\n+    gcc_assert (s1);\n+\n+    loop_p l = loop;\n+    sese_l s2 = build_scop_depth (invalid_sese, l->next);\n+    if (!s2)\n+      {\n+\tif (s1)\n+\t  add_scop (s1);\n+\treturn s1;\n+      }\n+\n+    sese_l combined = merge_sese (s1, s2);\n+\n+    if (combined)\n+      s1 = combined;\n+    else\n+      add_scop (s2);\n+\n+    if (s1)\n+      add_scop (s1);\n+    return s1;\n+  }\n+\n+  /* Returns true when Graphite can represent LOOP in SCOP.\n+     FIXME: For the moment, graphite cannot be used on loops that iterate using\n+     induction variables that wrap.  */\n+  static bool\n+    can_represent_loop_1 (loop_p loop, sese_l scop)\n+  {\n+    tree niter;\n+    struct tree_niter_desc niter_desc;\n+\n+    return single_exit (loop)\n+      && number_of_iterations_exit (loop, single_exit (loop), &niter_desc, false)\n+      && niter_desc.control.no_overflow\n+      && (niter = number_of_latch_executions (loop))\n+      && !chrec_contains_undetermined (niter)\n+      && graphite_can_represent_expr (scop, loop, niter);\n+  }\n+\n+  /* Return true when all the loops within LOOP can be represented by\n+     Graphite.  */\n+\n+  static bool\n+    can_represent_loop (loop_p loop, sese_l scop)\n+  {\n+    if (!can_represent_loop_1 (loop, scop))\n+      return false;\n+    if (loop->inner && !can_represent_loop (loop->inner, scop))\n+      return false;\n+    if (loop->next && !can_represent_loop (loop->next, scop))\n+      return false;\n+\n+    return true;\n+  }\n+\n+  /* Return true when LOOP is a valid scop, that is a Static Control Part, a\n+     region of code that can be represented in the polyhedral model.  SCOP\n+     defines the region we analyse.  */\n+\n+  static bool\n+    loop_is_valid_scop (loop_p loop, sese_l scop)\n+  {\n+    if (!scop)\n+      return false;\n+\n+    if (!can_represent_loop (loop, scop))\n+      {\n+\tDEBUG_PRINT (dp << \"[scop-detection-fail] cannot represent loop_\"\n+\t\t        << loop->num << \"\\n\");\n+\treturn false;\n+      }\n+\n+    if (loop_body_is_valid_scop (loop, scop))\n+      {\n+\tDEBUG_PRINT (dp << \"[valid-scop] loop_\"\n+\t\t        << loop->num << \"is a valid scop.\\n\");\n+\treturn true;\n+      }\n+    return false;\n+  }\n+\n+  /* Return true when BEGIN is the preheader edge of a loop with a single exit\n+     END.  */\n+\n+  static bool\n+    region_has_one_loop (sese_l s)\n+  {\n+    edge begin = s.entry;\n+    edge end = s.exit;\n+    /* Check for a single perfectly nested loop.  */\n+    if (begin->dest->loop_father->inner)\n+      return false;\n+\n+    /* Otherwise, check whether we have adjacent loops.  */\n+    return begin->dest->loop_father == end->src->loop_father;\n+  }\n+\n+  /* Add to SCOPS a scop starting at SCOP_BEGIN and ending at SCOP_END.  */\n+\n+  void\n+    add_scop (sese_l s)\n+  {\n+    gcc_assert (s);\n+    edge scop_begin = s.entry;\n+    edge scop_end = s.exit;\n+\n+    /* Do not add scops with only one loop.  */\n+    if (region_has_one_loop (s))\n+      {\n+\tDEBUG_PRINT (dp << \"\\n[scop-detection-fail] Discarding one loop SCoP\";\n+\t\t     print_sese (dump_file, s));\n+\treturn;\n+      }\n+\n+    if (get_exit_bb (scop_end) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+      {\n+\tDEBUG_PRINT (dp << \"\\n[scop-detection-fail] \"\n+\t\t        << \"Discarding SCoP exiting to return\";\n+\t\t     print_sese (dump_file, s));\n+\treturn;\n+      }\n+\n+    sese sese_reg = new_sese (scop_begin, scop_end);\n+    scop_p newscop = new_scop (sese_reg);\n+\n+    /* Remove all the scops which are subsumed by s.  */\n+    remove_subscops (newscop);\n+\n+    /* Replace this with split-intersecting scops.  */\n+    remove_intersecting_scops (newscop);\n+\n+    scops->safe_push (newscop);\n+    DEBUG_PRINT (dp << \"\\nAdding SCoP \"; print_sese (dump_file, s));\n+  }\n+\n+  /* Return true when a statement in SCOP cannot be represented by Graphite.\n+     The assumptions are that L1 dominates L2, and SCOP->entry dominates L1.\n+     Limit the number of bbs between adjacent loops to\n+     PARAM_SCOP_MAX_NUM_BBS_BETWEEN_LOOPS.  */\n+\n+  static bool\n+    harmful_stmt_in_region (sese_l scop)\n+  {\n+    basic_block exit_bb = get_exit_bb (scop.exit);\n+    basic_block entry_bb = get_entry_bb (scop.entry);\n+\n+    DEBUG_PRINT (dp << \"\\n[checking-harmful-bbs] \";\n+\t\t print_sese (dump_file, scop));\n+    gcc_assert (dominated_by_p (CDI_DOMINATORS, exit_bb, entry_bb));\n+\n+    int depth = bb_dom_dfs_in (CDI_DOMINATORS, exit_bb)\n+      - bb_dom_dfs_in (CDI_DOMINATORS, entry_bb);\n+\n+    gcc_assert (depth >0);\n+\n+    vec<basic_block> dom = get_dominated_to_depth (CDI_DOMINATORS,\n+\t\t\t\t\t\t   entry_bb, depth);\n+    int i;\n+    basic_block bb;\n+    FOR_EACH_VEC_ELT (dom, i, bb)\n+      {\n+\tDEBUG_PRINT (dp << \"\\nVisiting bb_\" << bb->index);\n+\n+\t/* We don't want to analyze any bb outside sese.  */\n+\tif (!dominated_by_p (CDI_POST_DOMINATORS, bb, exit_bb))\n+\t  continue;\n+\n+\tif (harmful_stmt_in_bb (scop, bb))\n+\t  return true;\n+      }\n+\n+    return false;\n+  }\n+\n+  /* Returns true if S1 subsumes/surrounds S2.  */\n+  static bool\n+    subsumes (scop_p s1, scop_p s2)\n+  {\n+    if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2->region->entry),\n+\t\t\tget_entry_bb (s1->region->entry))\n+\t&& dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (s2->region->exit),\n+\t\t\t   get_entry_bb (s1->region->exit)))\n+      return true;\n+    return false;\n+  }\n+\n+  /* TODO: Maybe vec<scops_p> can be made as vec<sese_l> so that it consumes\n+   less memory and later push only the relevant scops to vec <scops_p>.  */\n+  void\n+    remove_subscops (scop_p s1)\n+  {\n+    int j;\n+    scop_p s2;\n+    FOR_EACH_VEC_ELT_REVERSE (*scops, j, s2)\n+      {\n+\tif (subsumes (s1, s2))\n+\t  {\n+\t    DEBUG_PRINT (dp << \"\\nRemoving sub-SCoP\";\n+\t\t print_sese (dump_file,\n+\t\t\t     sese_l (s2->region->entry, s2->region->exit)));\n+\t    scops->unordered_remove (j);\n+\t  }\n+      }\n+  }\n+\n+  /* Returns true if S1 intersects with S2.  Since we already know that S1 does\n+     not subsume S2 or vice-versa, we only check for entry bbs.  */\n+\n+  static bool\n+    intersects (scop_p s1, scop_p s2)\n+  {\n+    if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2->region->entry),\n+\t\t\tget_entry_bb (s1->region->entry))\n+\t&& !dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2->region->entry),\n+\t\t\t    get_exit_bb (s1->region->exit)))\n+      return true;\n+    if ((s1->region->exit == s2->region->entry)\n+\t|| (s2->region->exit == s1->region->entry))\n+      return true;\n+\n+    return false;\n+  }\n+\n+  /* Remove one of the scops when it intersects with any other.  */\n+\n+  void\n+    remove_intersecting_scops (scop_p s1)\n+  {\n+    int j;\n+    scop_p s2;\n+    FOR_EACH_VEC_ELT_REVERSE (*scops, j, s2)\n+      {\n+\tif (intersects (s1, s2))\n+\t  {\n+\t    DEBUG_PRINT (dp << \"\\nRemoving intersecting SCoP\";\n+\t\tprint_sese (dump_file, sese_l (s2->region->entry,\n+\t\t\t\t\t       s2->region->exit));\n+\t\tdp << \"Intersects with:\";\n+\t\tprint_sese (dump_file, sese_l (s1->region->entry,\n+\t\t\t\t\t       s1->region->exit)));\n+\t    scops->unordered_remove (j);\n+\t  }\n+      }\n+  }\n+\n+ private:\n+  vec<scop_p> *scops;\n+};\n+\n+sese_l scop_builder::invalid_sese (NULL, NULL);\n+\n+/* Find Static Control Parts (SCoP) in the current function and pushes\n+   them to SCOPS.  */\n+\n+void\n+build_scops (vec<scop_p> *scops)\n+{\n+  if (dump_file)\n+    dp.set_dump_file (dump_file);\n+\n+  canonicalize_loop_closed_ssa_form ();\n+\n+  scop_builder s (scops);\n+  s.build_scop_depth (scop_builder::invalid_sese, current_loops->tree_root);\n+  DEBUG_PRINT (dp << \"number of SCoPs: \" << (scops ? scops->length () : 0););\n+}\n+\n #endif  /* HAVE_isl */"}, {"sha": "a957d93a3ec9ca38c8dedb36d03f53e89646c749", "filename": "gcc/graphite.c", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-pass.h\"\n #include \"params.h\"\n+#include \"pretty-print.h\"\n \n #ifdef HAVE_isl\n #include \"cfghooks.h\"\n@@ -168,6 +169,16 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n \t}\n     }\n \n+  fprintf (file, \"\\nFunction Name: %s\\n\", current_function_name ());\n+\n+  edge scop_begin = scop->region->entry;\n+  edge scop_end = scop->region->exit;\n+\n+  fprintf (file, \"\\nSCoP (entry_edge (bb_%d, bb_%d), \",\n+\t   scop_begin->src->index, scop_begin->dest->index);\n+  fprintf (file, \"exit_edge (bb_%d, bb_%d))\",\n+\t   scop_end->src->index, scop_end->dest->index);\n+\n   fprintf (file, \"\\nSCoP statistics (\");\n   fprintf (file, \"BBS:%ld, \", n_bbs);\n   fprintf (file, \"LOOPS:%ld, \", n_loops);\n@@ -191,21 +202,41 @@ print_graphite_statistics (FILE* file, vec<scop_p> scops)\n \n   FOR_EACH_VEC_ELT (scops, i, scop)\n     print_graphite_scop_statistics (file, scop);\n+\n+  /* Print the loop structure.  */\n+  print_loops (file, 2);\n+  print_loops (file, 3);\n }\n \n /* Initialize graphite: when there are no loops returns false.  */\n \n static bool\n graphite_initialize (isl_ctx *ctx)\n {\n-  if (number_of_loops (cfun) <= 1\n+  int min_loops = PARAM_VALUE (PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION);\n+  int max_bbs = PARAM_VALUE (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION);\n+  int nbbs = n_basic_blocks_for_fn (cfun);\n+  int nloops = number_of_loops (cfun);\n+\n+  if (nloops <= min_loops\n       /* FIXME: This limit on the number of basic blocks of a function\n \t should be removed when the SCOP detection is faster.  */\n-      || (n_basic_blocks_for_fn (cfun) >\n-\t  PARAM_VALUE (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION)))\n+      || (nbbs > max_bbs))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tprint_global_statistics (dump_file);\n+\t{\n+\t  if (nloops <= min_loops)\n+\t    fprintf (dump_file, \"\\nFunction does not have enough loops: \"\n+\t\t     \"PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION = %d.\\n\",\n+\t\t     min_loops);\n+\n+\t  else if (nbbs > max_bbs)\n+\t    fprintf (dump_file, \"\\nFunction has too many basic blocks: \"\n+\t\t     \"PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION = %d.\\n\", max_bbs);\n+\n+\t  fprintf (dump_file, \"\\nnumber of SCoPs: 0\\n\");\n+\t  print_global_statistics (dump_file);\n+\t}\n \n       isl_ctx_free (ctx);\n       return false;\n@@ -216,7 +247,10 @@ graphite_initialize (isl_ctx *ctx)\n   initialize_original_copy_tables ();\n \n   if (dump_file && dump_flags)\n-    dump_function_to_file (current_function_decl, dump_file, dump_flags);\n+    {\n+      dump_function_to_file (current_function_decl, dump_file, dump_flags);\n+      print_loops (dump_file, 3);\n+    }\n \n   return true;\n }\n@@ -227,8 +261,10 @@ graphite_initialize (isl_ctx *ctx)\n static void\n graphite_finalize (bool need_cfg_cleanup_p)\n {\n+  free_dominance_info (CDI_POST_DOMINATORS);\n   if (need_cfg_cleanup_p)\n     {\n+      free_dominance_info (CDI_DOMINATORS);\n       scev_reset ();\n       cleanup_tree_cfg ();\n       profile_status_for_fn (cfun) = PROFILE_ABSENT;"}, {"sha": "3f91992815622e897739796731609a84dc48a15b", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -844,6 +844,13 @@ DEFPARAM (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION,\n \t  \"maximum number of basic blocks per function to be analyzed by Graphite\",\n \t  100, 0, 0)\n \n+/* Maximal number of basic blocks in the functions analyzed by Graphite.  */\n+\n+DEFPARAM (PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION,\n+\t  \"graphite-min-loops-per-function\",\n+\t  \"minimal number of loops per function to be analyzed by Graphite\",\n+\t  2, 0, 0)\n+\n DEFPARAM (PARAM_MAX_ISL_OPERATIONS,\n \t  \"max-isl-operations\",\n \t  \"maximum number of ISL operations, 0 means unlimited\","}, {"sha": "1a26fa836e731a50b9a086000cb655a7568b1ff7", "filename": "gcc/sese.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -172,11 +172,6 @@ sese_loop_depth (sese region, loop_p loop)\n {\n   unsigned int depth = 0;\n \n-  gcc_assert ((!loop_in_sese_p (loop, region)\n-\t       && (SESE_ENTRY_BB (region)->loop_father == loop\n-\t           || SESE_EXIT (region)->src->loop_father == loop))\n-              || loop_in_sese_p (loop, region));\n-\n   while (loop_in_sese_p (loop, region))\n     {\n       depth++;\n@@ -263,6 +258,9 @@ recompute_all_dominators (void)\n   mark_irreducible_loops ();\n   free_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_DOMINATORS);\n+\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n }\n \n typedef struct gimple_bb"}, {"sha": "da9954dd703f320a0fbd5410549983fcaa963e31", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -1,3 +1,44 @@\n+2015-09-28  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* gcc/testsuite/gcc.dg/graphite/run-id-pr67700-1.c: New test case.\n+\t* gcc.dg/graphite/block-1.c: Modified to match the pattern.\n+\t* gcc.dg/graphite/block-3.c: Same.\n+\t* gcc.dg/graphite/block-4.c: Same.\n+\t* gcc.dg/graphite/block-5.c: Same.\n+\t* gcc.dg/graphite/block-6.c: Same.\n+\t* gcc.dg/graphite/block-7.c: Same.\n+\t* gcc.dg/graphite/block-8.c: Same.\n+\t* gcc.dg/graphite/block-pr47654.c: Same.\n+\t* gcc.dg/graphite/interchange-0.c: Same.\n+\t* gcc.dg/graphite/interchange-1.c: Same.\n+\t* gcc.dg/graphite/interchange-10.c: Same.\n+\t* gcc.dg/graphite/interchange-11.c: Same.\n+\t* gcc.dg/graphite/interchange-12.c: Same.\n+\t* gcc.dg/graphite/interchange-13.c: Same.\n+\t* gcc.dg/graphite/interchange-14.c: Same.\n+\t* gcc.dg/graphite/interchange-15.c: Same.\n+\t* gcc.dg/graphite/interchange-3.c: Same.\n+\t* gcc.dg/graphite/interchange-4.c: Same.\n+\t* gcc.dg/graphite/interchange-5.c: Same.\n+\t* gcc.dg/graphite/interchange-6.c: Same.\n+\t* gcc.dg/graphite/interchange-7.c: Same.\n+\t* gcc.dg/graphite/interchange-8.c: Same.\n+\t* gcc.dg/graphite/interchange-9.c: Same.\n+\t* gcc.dg/graphite/interchange-mvt.c: Same.\n+\t* gcc.dg/graphite/pr35356-1.c: Same.\n+\t* gcc.dg/graphite/pr35356-3.c: Same.\n+\t* gcc.dg/graphite/pr37485.c: Same.\n+\t* gcc.dg/graphite/scop-1.c: Same.\n+\t* gcc.dg/graphite/scop-11.c: Same.\n+\t* gcc.dg/graphite/scop-5.c: Same.\n+\t* gcc.dg/graphite/uns-block-1.c: Same.\n+\t* gcc.dg/graphite/uns-interchange-9.c: Same.\n+\t* gfortran.dg/graphite/block-1.f90: Same.\n+\t* gfortran.dg/graphite/interchange-3.f90: Same.\n+\t* gfortran.dg/graphite/pr14741.f90: Same.\n+\t* gfortran.dg/graphite/block-2.f: Same.\n+\n 2015-09-28  Aditya Kumar  <aditya.k7@samsung.com>\n             Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "b8ac3acf9ac9a7ba0eedfc7db75ad1a50ab8e31b", "filename": "gcc/testsuite/gcc.dg/graphite/block-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -45,4 +45,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 6 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "08bdb23e9e9e54fd8977217b4f24b67165e28437", "filename": "gcc/testsuite/gcc.dg/graphite/block-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -58,4 +58,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "0deaec14e7a6c746792a2088d4632d916b029966", "filename": "gcc/testsuite/gcc.dg/graphite/block-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -57,4 +57,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 7 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "97bf410dcf6fb018bfb43b51bd88371c1a5c6dfc", "filename": "gcc/testsuite/gcc.dg/graphite/block-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -53,4 +53,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "a6a5ba7d7de8c367da3df360a9e9d8ac7499332c", "filename": "gcc/testsuite/gcc.dg/graphite/block-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -48,4 +48,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "4e5c5760fadd54bcf049d4edd5033509e951fa24", "filename": "gcc/testsuite/gcc.dg/graphite/block-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -54,4 +54,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 6 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "298db85460d88dac0177084f7e28dd56669c6099", "filename": "gcc/testsuite/gcc.dg/graphite/block-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-8.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -55,4 +55,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 7 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "6d53ef42cb404a50271c4086693ccc0aec8cabfb", "filename": "gcc/testsuite/gcc.dg/graphite/block-pr47654.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-pr47654.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-pr47654.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-pr47654.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -21,4 +21,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "d56be46d4841605bda117df73c6354b8e4cc6ffc", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-0.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "97110079efe15692018c189a046a94a70ab8ad5d", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -49,4 +49,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "e2ad29843422c2913f65b5d2c2a96955cd1a7061", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-10.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 6 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "77106180a0044a28654c3699f0fb939dce5d125e", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-11.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "482bea46c03455f16f2f75674abba5b11d127187", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -53,4 +53,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 5 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "37422a7c75b402695d5fab017d1ac35a061d5ba4", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-13.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -50,4 +50,4 @@ main (void)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "ca4dedc2760f61ddf8ecfedbbeaa2cbf9192bd3f", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-14.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-14.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -54,4 +54,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 6 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "7410f29da5080cd16c58a6658bfbbc9b7d8fb0ec", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-15.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-15.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -48,4 +48,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "1d63ea84bf9bd54b8d422281b40c81b345e179e0", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-3.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -47,4 +47,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "e2887d5cbe322639ea5b75770dc31bc999e84669", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-4.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "e5aaa642d8ebafae5e84b0ba5c12f6a23434e9cc", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-5.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "7257c29dba808261a57fb1619e1bf4e74dcadb81", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -47,4 +47,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "f231b878ba21d238da47bfa126efe425ba3aee33", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-7.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "d7059107038a4af43c50157e89475a593561d909", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-8.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -82,4 +82,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 6 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "690fa1e48d678de6a8ab098147fb17ae7394fd3a", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-9.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -44,4 +44,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "c6543ec457c6dc7f3ac69ddf1b3a99f4813d2ad0", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-mvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-mvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-mvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-mvt.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -58,4 +58,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 7 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "6d82579d4e1b7c82b7e1b9bf1e8cab5cbab24c06", "filename": "gcc/testsuite/gcc.dg/graphite/pr35356-1.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-1.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -24,6 +24,14 @@ foo (int bar, int n, int k)\n    | if (k >= 0 && k < n)\n    |   a[k] = bar;\n \n+   Check that this text is produced:\n+\n+ISL AST generated by ISL:\n+if (n >= k + 1 && k >= 0) {\n+  S_6(k);\n+  S_11(k);\n+}\n+\n */\n \n-/* { dg-final { scan-tree-dump-times \"loop_1\" 0 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"if \\\\\\(n >= k \\\\\\+ 1 && k >= 0\\\\\\) \\\\\\{\" 1 \"graphite\" } } */"}, {"sha": "f2827a2bb6d63498bbb486e0c39ce9047699f0cd", "filename": "gcc/testsuite/gcc.dg/graphite/pr35356-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-3.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -36,4 +36,4 @@ match (void)\n    \"Y[winner].y > 0\".  This could be fixed when we will use predicates\n    for such cases.  */\n \n-/* { dg-final { scan-tree-dump-times \"loop_1\" 0 \"graphite\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"loop_1\" 0 \"graphite\" } } */"}, {"sha": "c6d4f924113a2d5f611e9fc4e52cc1b280fa05ec", "filename": "gcc/testsuite/gcc.dg/graphite/pr37485.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -floop-block -ffast-math -fdump-tree-graphite-all\" } */\n+/* { dg-options \"-O2 -floop-block -ffast-math\" } */\n \n typedef unsigned char   UChar;\n typedef int             Int32;\n@@ -30,5 +30,3 @@ void fallbackSort ( UInt32* fmap,\n    }\n    AssertH ( j < 256, 1005 );\n }\n-\n-/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */"}, {"sha": "e0db2561e7dd645908bd14bd416c29c101414cf9", "filename": "gcc/testsuite/gcc.dg/graphite/run-id-pr67700-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr67700-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr67700-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr67700-1.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -0,0 +1,48 @@\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+struct type *obj;\n+struct type {\n+  int elem1[81];\n+};\n+\n+enum fpmath_unit\n+{\n+  FPMATH_387 = 1,\n+  FPMATH_SSE = 2\n+};\n+\n+struct gcc_options\n+{\n+  enum fpmath_unit x_ix86_fpmath;\n+};\n+\n+struct gcc_options global_options;\n+\n+void foo(void)\n+{\n+   int pos = 0;\n+   int i;\n+   if (!((global_options.x_ix86_fpmath & FPMATH_SSE) != 0))\n+     for (i = 8; i <= 15; i++)\n+       (obj->elem1) [pos++] = i;\n+   for (i = 45; i <= 52; i++)\n+     (obj->elem1) [pos++] = i;\n+   if (((global_options.x_ix86_fpmath & FPMATH_SSE) != 0))\n+     for (i = 8; i <= 15; i++)\n+       (obj->elem1) [pos++] = i;\n+   for (i = 29; i <= 36; i++)\n+     (obj->elem1) [pos++] = i;\n+}\n+\n+int main()\n+{\n+  int i;\n+  obj = (struct type*) malloc (sizeof (struct type));\n+  for (i = 0; i <= 80; i++)\n+    obj->elem1[i] = 0;\n+  foo();\n+  assert (obj->elem1[8] == 45);\n+  return 0;\n+}\n+"}, {"sha": "f8f1bf908f1548f90d992497e2449c8d7b894e07", "filename": "gcc/testsuite/gcc.dg/graphite/scop-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-1.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -1,6 +1,6 @@\n void bar (void);\n \n-int toto()\n+int toto ()\n {\n   int i, j, k;\n   int a[101][100];\n@@ -16,12 +16,12 @@ int toto()\n       bar ();\n \n       for (j = 1; j < 100; j++)\n-\ta[j][i] = a[j+1][i-1] + 2;\n+\ta[j][i] = a[j+1][i-1] + 3;\n \n       b[i] = a[i-1][i] + 2;\n \n       for (j = 1; j < 100; j++)\n-\ta[j][i] = a[j+1][i-1] + 2;\n+\ta[j][i] = a[j+1][i-1] + 4;\n     }\n \n   return a[3][5] + b[1];"}, {"sha": "801e54f996151fb52667e4668a0f102debc0c8fb", "filename": "gcc/testsuite/gcc.dg/graphite/scop-11.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-11.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -1,25 +1,17 @@\n void bar ();\n \n-int toto()\n+int toto (int i, int b)\n {\n-  int i,j, b;\n+  int j;\n   int a[100];\n \n-  if (i == 20)\n-    {\n-      for (j = 0; j <= 20; j++)\n-        a[j] = b + i;\n-      b = 3;\n-    }\n-  else \n-    {\n-      if (i == 30)\n-\t{\n-          for (j = 0; j <= 20; j++)\n-            a[j] = b + i;\n-\t  b = 5;\n-\t}\n-    }\n+  for (j = 0; j <= 20; j++)\n+    a[j] = b + i;\n+\n+  if (a[12] == 23)\n+    b = 3;\n+  else\n+    b = 1;\n \n   for (j = 0; j <= 20; j++)\n     a[j] = b + i;"}, {"sha": "5ecaaeed383cd5d42565f2226d0c225941135959", "filename": "gcc/testsuite/gcc.dg/graphite/scop-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-5.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -33,4 +33,4 @@ int toto()\n   return a[b];\n }\n \n-/* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 1\" 1 \"graphite\"} } */"}, {"sha": "3bc7c127d762821926c131a41031582502725fcb", "filename": "gcc/testsuite/gcc.dg/graphite/uns-block-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-block-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-block-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-block-1.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -45,4 +45,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 5 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "ff7121403504e59531efdad0ec77e78b4f95a48c", "filename": "gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-9.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -45,4 +45,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } } */"}, {"sha": "237bd1ed6f8b8410157f7644a91ab2ff086d8579", "filename": "gcc/testsuite/gfortran.dg/graphite/block-1.f90", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-1.f90?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -7,6 +7,4 @@ subroutine matrix_multiply(a,b,c,n)\n \n end subroutine matrix_multiply\n \n-! { dg-final { scan-tree-dump-times \"number of SCoPs: 1\" 1 \"graphite\" { xfail *-*-* } } }\n-! { dg-final { scan-tree-dump-times \"will be loop blocked\" 1 \"graphite\" { xfail *-*-* } } }\n-\n+! { dg-final { scan-tree-dump-times \"number of SCoPs: 1\" 1 \"graphite\"} }"}, {"sha": "d7ca40f704f3ed9209c6ab0fc44fd201b6cbe64e", "filename": "gcc/testsuite/gfortran.dg/graphite/block-2.f", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fblock-2.f?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -16,5 +16,4 @@ SUBROUTINE MATRIX_MUL_UNROLLED (A, B, C, L, M, N)\n       RETURN\n       END\n \n-! { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\" { xfail *-*-* } } }\n-! { dg-final { scan-tree-dump-times \"will be loop blocked\" 2 \"graphite\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\" } }"}, {"sha": "9c373324ec0563266feb0bc92287b62341898c33", "filename": "gcc/testsuite/gfortran.dg/graphite/interchange-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -24,4 +24,4 @@ Program FOO\n \n end Program FOO\n \n-! { dg-final { scan-tree-dump-times \"tiled by\" 5 \"graphite\" } }\n+! { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } }"}, {"sha": "e40262f128859c0b43858f95071ae45481ad2a89", "filename": "gcc/testsuite/gfortran.dg/graphite/pr14741.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr14741.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr14741.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr14741.f90?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -24,5 +24,4 @@ SUBROUTINE mult(A,B,C,N)\n   ENDDO\n END SUBROUTINE mult\n \n-! { dg-final { scan-tree-dump-times \"number of SCoPs: 1\" 1 \"graphite\" { xfail *-*-* } } }\n-! { dg-final { scan-tree-dump-times \"will be loop blocked\" 1 \"graphite\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump \"tiled by\" \"graphite\" } }"}, {"sha": "712d8cc96332069537bfac1e8e56c2e863037314", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7009b073c56b40b280408c0ab69957651372c42e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=7009b073c56b40b280408c0ab69957651372c42e", "patch": "@@ -7646,6 +7646,7 @@ print_loops (FILE *file, int verbosity)\n   basic_block bb;\n \n   bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  fprintf (file, \"\\nLoops in function: %s\\n\", current_function_name ());\n   if (bb && bb->loop_father)\n     print_loop_and_siblings (file, bb->loop_father, 0, verbosity);\n }"}]}