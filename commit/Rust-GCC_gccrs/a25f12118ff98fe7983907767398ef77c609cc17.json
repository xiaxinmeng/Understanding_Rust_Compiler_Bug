{"sha": "a25f12118ff98fe7983907767398ef77c609cc17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1ZjEyMTE4ZmY5OGZlNzk4MzkwNzc2NzM5OGVmNzdjNjA5Y2MxNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-19T23:40:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-19T23:40:37Z"}, "message": "c-decl.c (grokdeclarator): Support flexible array members.\n\n        * c-decl.c (grokdeclarator): Support flexible array members.\n        Use open-ended ranges for these and zero-length arrays.\n        * c-typeck.c (push_init_level): Validate the context of\n        initialization of a zero-length array.\n        * tree.c (int_fits_type_p): Be prepared for missing bounds.\n        * varasm.c (array_size_for_constructor): New.\n        (output_constructor): Use it for arrays of unspecified length.\n        * extend.texi (Zero Length): Mention C99 flexible array members.\n        Document initialization in a top-level struct as valid.\n\nFrom-SVN: r37576", "tree": {"sha": "b0963851524845509cecfbe1ac8dbb68d8f147ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0963851524845509cecfbe1ac8dbb68d8f147ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a25f12118ff98fe7983907767398ef77c609cc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25f12118ff98fe7983907767398ef77c609cc17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25f12118ff98fe7983907767398ef77c609cc17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25f12118ff98fe7983907767398ef77c609cc17/comments", "author": null, "committer": null, "parents": [{"sha": "2650255a57477be0a966f3d3af0c0b71a0e52f0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2650255a57477be0a966f3d3af0c0b71a0e52f0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2650255a57477be0a966f3d3af0c0b71a0e52f0f"}], "stats": {"total": 131, "additions": 118, "deletions": 13}, "files": [{"sha": "1e9c1c0afc42fa9bf96bdcab2e6e949b53b56d7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a25f12118ff98fe7983907767398ef77c609cc17", "patch": "@@ -1,3 +1,15 @@\n+2000-11-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-decl.c (grokdeclarator): Support flexible array members.\n+\tUse open-ended ranges for these and zero-length arrays.\n+\t* c-typeck.c (push_init_level): Validate the context of\n+\tinitialization of a zero-length array.\n+\t* tree.c (int_fits_type_p): Be prepared for missing bounds.\n+\t* varasm.c (array_size_for_constructor): New.\n+\t(output_constructor): Use it for arrays of unspecified length.\n+\t* extend.texi (Zero Length): Mention C99 flexible array members.\n+\tDocument initialization in a top-level struct as valid.\n+\n 2000-11-19  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* config.gcc, invoke.texi: Fix errors in spelling of \"deprecated\".\n@@ -116,8 +128,7 @@\n \n 2000-11-17  Neil Booth  <neilb@earthling.net>\n \n-        * cpperror.c (print_file_and_line): Don't display line number\n-        if 0.\n+\t* cpperror.c (print_file_and_line): Don't display line number if 0.\n \n 2000-11-17  Zack Weinberg  <zack@wolery.stanford.edu>\n "}, {"sha": "9da1923adee928587d80a7fd04b4dd647fb91d11", "filename": "gcc/c-decl.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=a25f12118ff98fe7983907767398ef77c609cc17", "patch": "@@ -4498,9 +4498,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t{\n \t\t  /* A zero-length array cannot be represented with an\n \t\t     unsigned index type, which is what we'll get with\n-\t\t     build_index_type.  Create a signed range instead.  */\n-\t\t  itype = build_range_type (index_type, size,\n-\t\t\t\t\t    build_int_2 (-1, -1));\n+\t\t     build_index_type.  Create an open-ended range instead.  */\n+\t\t  itype = build_range_type (sizetype, size, NULL_TREE);\n \t\t}\n \t      else\n \t\t{\n@@ -4530,6 +4529,19 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t  itype = build_index_type (itype);\n \t\t}\n \t    }\n+\t  else if (decl_context == FIELD)\n+\t    {\n+\t      /* ??? Need to check somewhere that this is a structure\n+\t\t and not a union, that this field is last, and that \n+\t\t this structure has at least one other named member.  */\n+\n+\t      if (pedantic && !flag_isoc99 && !in_system_header)\n+\t\tpedwarn (\"ISO C89 does not support flexible array members\");\n+\n+\t      /* ISO C99 Flexible array members are effectively identical\n+\t\t to GCC's zero-length array extension.  */\n+\t      itype = build_range_type (sizetype, size_zero_node, NULL_TREE);\n+\t    }\n \n #if 0\n \t  /* This had bad results for pointers to arrays, as in"}, {"sha": "ada69a8e39546f6fac36c2135fd570d056f2771e", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=a25f12118ff98fe7983907767398ef77c609cc17", "patch": "@@ -5295,6 +5295,16 @@ push_init_level (implicit)\n \t{\n \t  constructor_max_index\n \t    = TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type));\n+\n+\t  if (constructor_max_index == NULL_TREE)\n+\t    {\n+\t      /* This is a zero-length array or flexible array member.  */\n+\t      if (pedantic)\n+\t\tpedwarn_init (\"ISO C does not support initialization of flexible array members\");\n+\t      if (constructor_depth != 2)\n+\t\terror_init (\"initialization of zero-length array inside a nested structure\");\n+\t    }\n+\n \t  constructor_index\n \t    = convert (bitsizetype, \n \t\t\t\t  TYPE_MIN_VALUE"}, {"sha": "0d88bdf175e8207bbc22c74065797a598a2ae843", "filename": "gcc/extend.texi", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=a25f12118ff98fe7983907767398ef77c609cc17", "patch": "@@ -886,12 +886,25 @@ struct line @{\n @}\n @end example\n \n-In standard C, you would have to give @code{contents} a length of 1, which\n+In ISO C89, you would have to give @code{contents} a length of 1, which\n means either you waste space or complicate the argument to @code{malloc}.\n \n-Static initialization of the zero-length array is not allowed.  A\n-warning will be generated for each initializer attempting to initialize\n-the zero-length array.\n+In ISO C99, you would use a @dfn{flexible array member}, which uses a\n+slightly different syntax: leave out the @code{0} and write\n+@code{contents[]}.\n+\n+GCC allows static initialization of the zero-length array if\n+the structure is not nested inside another structure.  I.e.\n+\n+@example\n+/* Legal.  */\n+struct line x = @{ 4, @{ 'g', 'o', 'o', 'd' @} @};\n+\n+/* Illegal.  */\n+struct bar @{\n+  struct line a;\n+@} y = @{ @{ 3, @{ 'b', 'a', 'd' @} @} @};\n+@end example\n \n @node Variable Length\n @section Arrays of Variable Length"}, {"sha": "7910449bd34c30ff61678c2a3668ad41626a82ce", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a25f12118ff98fe7983907767398ef77c609cc17", "patch": "@@ -4186,7 +4186,9 @@ int_fits_type_p (c, type)\n {\n   /* If the bounds of the type are integers, we can check ourselves.\n      Otherwise,. use force_fit_type, which checks against the precision.  */\n-  if (TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n+  if (TYPE_MAX_VALUE (type) != NULL_TREE\n+      && TYPE_MIN_VALUE (type) != NULL_TREE\n+      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n       && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST)\n     {\n       if (TREE_UNSIGNED (type))"}, {"sha": "799beeb14ee16341f5864c36ddc9c4777d2f5d19", "filename": "gcc/varasm.c", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25f12118ff98fe7983907767398ef77c609cc17/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a25f12118ff98fe7983907767398ef77c609cc17", "patch": "@@ -171,6 +171,7 @@ static void mark_constant_pool\t\tPARAMS ((void));\n static void mark_constants\t\tPARAMS ((rtx));\n static int output_addressed_constants\tPARAMS ((tree));\n static void output_after_function_constants PARAMS ((void));\n+static int array_size_for_constructor\tPARAMS ((tree));\n static void output_constructor\t\tPARAMS ((tree, int));\n #ifdef ASM_WEAKEN_LABEL\n static void remove_from_pending_weak_list\tPARAMS ((const char *));\n@@ -4413,8 +4414,53 @@ output_constant (exp, size)\n }\n \n \f\n-/* Subroutine of output_constant, used for CONSTRUCTORs\n-   (aggregate constants).\n+/* Subroutine of output_constructor, used for computing the size of\n+   arrays of unspecified length.  VAL must be a CONSTRUCTOR of an array\n+   type with an unspecified upper bound.  */\n+\n+static int\n+array_size_for_constructor (val)\n+     tree val;\n+{\n+  tree max_index, i;\n+\n+  if (!val || TREE_CODE (val) != CONSTRUCTOR\n+      || TREE_CODE (TREE_TYPE (val)) != ARRAY_TYPE\n+      || TYPE_DOMAIN (TREE_TYPE (val)) == NULL_TREE\n+      || TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (val))) != NULL_TREE\n+      || TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (val))) == NULL_TREE)\n+    abort ();\n+\n+  max_index = NULL_TREE;\n+  for (i = CONSTRUCTOR_ELTS (val); i ; i = TREE_CHAIN (i))\n+    {\n+      tree index = TREE_PURPOSE (i);\n+\n+      if (TREE_CODE (index) == RANGE_EXPR)\n+\tindex = TREE_OPERAND (index, 1);\n+      if (max_index == NULL_TREE || tree_int_cst_lt (max_index, index))\n+\tmax_index = index;\n+    }\n+\n+  /* ??? I'm fairly certain if there were no elements, we shouldn't have\n+     created the constructor in the first place.  */\n+  if (max_index == NULL_TREE)\n+    abort ();\n+\n+  /* Compute the total number of array elements.  */\n+  i = fold (build (MINUS_EXPR, TREE_TYPE (max_index), max_index, \n+\t\t   TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (val)))));\n+  i = fold (build (PLUS_EXPR, TREE_TYPE (i), i,\n+\t\t   convert (TREE_TYPE (i), integer_one_node)));\n+\n+  /* Multiply by the array element unit size to find number of bytes.  */\n+  i = fold (build (MULT_EXPR, TREE_TYPE (max_index), i,\n+\t\t   TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (val)))));\n+\n+  return tree_low_cst (i, 1);\n+}\n+\n+/* Subroutine of output_constant, used for CONSTRUCTORs (aggregate constants).\n    Generate at least SIZE bytes, padding if necessary.  */\n \n static void\n@@ -4532,7 +4578,18 @@ output_constructor (exp, size)\n \n \t  /* Determine size this element should occupy.  */\n \t  if (field)\n-\t    fieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 1);\n+\t    {\n+\t      if (DECL_SIZE_UNIT (field))\n+\t\tfieldsize = tree_low_cst (DECL_SIZE_UNIT (field), 1);\n+\t      else\n+\t\t{\n+\t\t  /* If DECL_SIZE is not set, then this must be an array\n+\t\t     of unspecified length.  The initialized value must\n+\t\t     be a CONSTRUCTOR, and we take the length from the\n+\t\t     last initialized element.  */\n+\t\t  fieldsize = array_size_for_constructor (val);\n+\t\t}\n+\t    }\n \t  else\n \t    fieldsize = int_size_in_bytes (TREE_TYPE (type));\n "}]}