{"sha": "a8e65aa5f2a310aa949081a9423acb55affc210d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlNjVhYTVmMmEzMTBhYTk0OTA4MWE5NDIzYWNiNTVhZmZjMjEwZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-16T10:20:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-16T10:20:04Z"}, "message": "[multiple changes]\n\n2009-04-16  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Document effect of Assume_No_Invalid_Values and -gnatVa\n\tused together.\n\n2009-04-16  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Find_Equality_Types): Filter out types that are not\n\tusable before calling Add_One_Interp, to resolve spurious ambiguities.\n\nFrom-SVN: r146163", "tree": {"sha": "40871dae07483d2ff0c8618dff8c64185c33f089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40871dae07483d2ff0c8618dff8c64185c33f089"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8e65aa5f2a310aa949081a9423acb55affc210d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e65aa5f2a310aa949081a9423acb55affc210d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8e65aa5f2a310aa949081a9423acb55affc210d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e65aa5f2a310aa949081a9423acb55affc210d/comments", "author": null, "committer": null, "parents": [{"sha": "fa702fbdb573639fa7b5011e2d1e20e94d25aa7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa702fbdb573639fa7b5011e2d1e20e94d25aa7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa702fbdb573639fa7b5011e2d1e20e94d25aa7a"}], "stats": {"total": 60, "additions": 53, "deletions": 7}, "files": [{"sha": "465aea16106019fae5aa28b1a4daa75a1264e94f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e65aa5f2a310aa949081a9423acb55affc210d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e65aa5f2a310aa949081a9423acb55affc210d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a8e65aa5f2a310aa949081a9423acb55affc210d", "patch": "@@ -1,3 +1,13 @@\n+2009-04-16  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Document effect of Assume_No_Invalid_Values and -gnatVa\n+\tused together.\n+\n+2009-04-16  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Find_Equality_Types): Filter out types that are not\n+\tusable before calling Add_One_Interp, to resolve spurious ambiguities.\n+\n 2009-04-16  Robert Dewar  <dewar@adacore.com>\n \n \t* Makefile.rtl: Add entries for s-conca?"}, {"sha": "3c45af2dd0254ddf0cd8e5f4c5bc3e588978ac6a", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e65aa5f2a310aa949081a9423acb55affc210d/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e65aa5f2a310aa949081a9423acb55affc210d/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=a8e65aa5f2a310aa949081a9423acb55affc210d", "patch": "@@ -1041,7 +1041,15 @@ value, and the loop above will be optimized away.\n The use of @code{Assume_No_Invalid_Values (On)} is appropriate if\n you know your code is free of uninitialized variables and other\n possible sources of invalid representations, and may result in\n-more efficient code.\n+more efficient code. A program that accesses an invalid representation\n+with this pragma in effect is erroneous, so no guarantees can be made\n+about its behavior.\n+\n+It is peculiar though permissible to use this pragma in conjunction\n+with validity checking (-gnatVa). In such cases, accessing invalid\n+values will generally give an exception, though formally the program\n+is erroneous so there are no guarantees that this will always be the\n+case, and it is recommended that these two options not be used together.\n \n @node Pragma Ast_Entry\n @unnumberedsec Pragma Ast_Entry"}, {"sha": "2f0ce9ac763b7afe4eea1ff162daf13af53c0034", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e65aa5f2a310aa949081a9423acb55affc210d/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e65aa5f2a310aa949081a9423acb55affc210d/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=a8e65aa5f2a310aa949081a9423acb55affc210d", "patch": "@@ -4697,17 +4697,19 @@ package body Sem_Ch4 is\n       Scop  : Entity_Id := Empty;\n \n       procedure Try_One_Interp (T1 : Entity_Id);\n-      --  The context of the operator plays no role in resolving the\n-      --  arguments,  so that if there is more than one interpretation\n-      --  of the operands that is compatible with equality, the construct\n-      --  is ambiguous and an error can be emitted now, after trying to\n-      --  disambiguate, i.e. applying preference rules.\n+      --  The context of the equality operator plays no role in resolving the\n+      --  arguments, so that if there is more than one interpretation of the\n+      --  operands that is compatible with equality, the construct is ambiguous\n+      --  and an error can be emitted now, after trying to disambiguate, i.e.\n+      --  applying preference rules.\n \n       --------------------\n       -- Try_One_Interp --\n       --------------------\n \n       procedure Try_One_Interp (T1 : Entity_Id) is\n+         Bas : constant Entity_Id := Base_Type (T1);\n+\n       begin\n          --  If the operator is an expanded name, then the type of the operand\n          --  must be defined in the corresponding scope. If the type is\n@@ -4725,7 +4727,7 @@ package body Sem_Ch4 is\n               or else T1 = Any_String\n               or else T1 = Any_Composite\n               or else (Ekind (T1) = E_Access_Subprogram_Type\n-                          and then not Comes_From_Source (T1))\n+                        and then not Comes_From_Source (T1))\n             then\n                null;\n \n@@ -4739,6 +4741,32 @@ package body Sem_Ch4 is\n \n                return;\n             end if;\n+\n+         --  If we have infix notation, the operator must be usable.\n+         --  Within an instance, if the type is already established we\n+         --  know it is correct.\n+         --  In Ada 2005, the equality on anonymous access types is declared\n+         --  in Standard, and is always visible.\n+\n+         elsif In_Open_Scopes (Scope (Bas))\n+           or else Is_Potentially_Use_Visible (Bas)\n+           or else In_Use (Bas)\n+           or else (In_Use (Scope (Bas))\n+                     and then not Is_Hidden (Bas))\n+           or else (In_Instance\n+                     and then First_Subtype (T1) = First_Subtype (Etype (R)))\n+           or else Ekind (T1) = E_Anonymous_Access_Type\n+         then\n+            null;\n+\n+         else\n+            --  Save candidate type for subsquent error message, if any.\n+\n+            if not Is_Limited_Type (T1) then\n+               Candidate_Type := T1;\n+            end if;\n+\n+            return;\n          end if;\n \n          --  Ada 2005 (AI-230): Keep restriction imposed by Ada 83 and 95:"}]}