{"sha": "60284a5928b20fe9380a361c3d61aa9c890ae7b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAyODRhNTkyOGIyMGZlOTM4MGEzNjFjM2Q2MWFhOWM4OTBhZTdiMA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-04-28T23:14:56Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-04-28T23:14:56Z"}, "message": "cppexp.c (lex): Move some code to _cpp_parse_expr, but keep most cases as function eval_token.\n\n\t* cppexp.c (lex): Move some code to _cpp_parse_expr, but\n\tkeep most cases as function eval_token.\n\t(eval_token): New function.\n\t(_cpp_parse_expr): Read token here for improved diagnostics.\n\tDon't use op_as_text.  Detect bad ':' here.\n\t(reduce): Don't detect bad ':' here.\n\t(op_as_text): Remove.\n\t* cpphash.h (_cpp_test_assertion): Change prototype.\n\t* cpplib.c (_cpp_test_assertion): Change prototype.\ntestsuite:\n\t* gcc.dg/cpp/if-cexp.c: Add a test.\n\nFrom-SVN: r52866", "tree": {"sha": "8b81b7298d53e223bfdc65067d374f41d92e9076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b81b7298d53e223bfdc65067d374f41d92e9076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60284a5928b20fe9380a361c3d61aa9c890ae7b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60284a5928b20fe9380a361c3d61aa9c890ae7b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60284a5928b20fe9380a361c3d61aa9c890ae7b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60284a5928b20fe9380a361c3d61aa9c890ae7b0/comments", "author": null, "committer": null, "parents": [{"sha": "349a4b40eb462ffe806c9aafa8792e5ef5ab00a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/349a4b40eb462ffe806c9aafa8792e5ef5ab00a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/349a4b40eb462ffe806c9aafa8792e5ef5ab00a2"}], "stats": {"total": 176, "additions": 74, "deletions": 102}, "files": [{"sha": "f4fcc8d06e37c9047eb29f38160f84de7b12a0de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60284a5928b20fe9380a361c3d61aa9c890ae7b0", "patch": "@@ -1,3 +1,15 @@\n+2002-04-29  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppexp.c (lex): Move some code to _cpp_parse_expr, but\n+\tkeep most cases as function eval_token.\n+\t(eval_token): New function.\n+\t(_cpp_parse_expr): Read token here for improved diagnostics.\n+\tDon't use op_as_text.  Detect bad ':' here.\n+\t(reduce): Don't detect bad ':' here.\n+\t(op_as_text): Remove.\n+\t* cpphash.h (_cpp_test_assertion): Change prototype.\n+\t* cpplib.c (_cpp_test_assertion): Change prototype.\n+\n 2002-04-28  Richard Henderson  <rth@redhat.com>\n \n \tPR c/5154"}, {"sha": "914a2070ac4ad69eb1f20cdfcd71af9df5a47c41", "filename": "gcc/cppexp.c", "status": "modified", "additions": 54, "deletions": 99, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=60284a5928b20fe9380a361c3d61aa9c890ae7b0", "patch": "@@ -36,8 +36,7 @@ static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n \t\t\t\t\t    unsigned HOST_WIDEST_INT));\n static struct op parse_number PARAMS ((cpp_reader *, const cpp_token *));\n static struct op parse_defined PARAMS ((cpp_reader *));\n-static struct op lex PARAMS ((cpp_reader *));\n-static const unsigned char *op_as_text PARAMS ((cpp_reader *, enum cpp_ttype));\n+static struct op eval_token PARAMS ((cpp_reader *, const cpp_token *));\n static struct op *reduce PARAMS ((cpp_reader *, struct op *, enum cpp_ttype));\n \n struct op\n@@ -275,45 +274,30 @@ parse_defined (pfile)\n   return op;\n }\n \n-/* Read a token.  The returned type is CPP_NUMBER for a valid number\n-   (an interpreted preprocessing number or character constant, or the\n-   result of the \"defined\" or \"#\" operators), CPP_ERROR on error,\n-   CPP_EOF, or the type of an operator token.  */\n+/* Convert a token into a CPP_NUMBER (an interpreted preprocessing\n+   number or character constant, or the result of the \"defined\" or \"#\"\n+   operators), or CPP_ERROR on error.  */\n static struct op\n-lex (pfile)\n+eval_token (pfile, token)\n      cpp_reader *pfile;\n+     const cpp_token *token;\n {\n+  unsigned int temp;\n   struct op op;\n-  const cpp_token *token = cpp_get_token (pfile);\n+\n+  op.op = CPP_NUMBER;\n+  op.unsignedp = 0;\n \n   switch (token->type)\n     {\n     case CPP_NUMBER:\n       return parse_number (pfile, token);\n \n-    case CPP_CHAR:\n     case CPP_WCHAR:\n-      {\n-\tunsigned int chars_seen;\n-\n-\tif (token->type == CPP_CHAR)\n-\t  op.unsignedp = 0;\n-\telse\n-\t  op.unsignedp = WCHAR_UNSIGNED;\n-\top.op = CPP_NUMBER;\n-\top.value = cpp_interpret_charconst (pfile, token, 1, &chars_seen);\n-\treturn op;\n-      }\n-\n-    case CPP_STRING:\n-    case CPP_WSTRING:\n-      SYNTAX_ERROR (\"string constants are not valid in #if\");\n-\n-    case CPP_OTHER:\n-      if (ISGRAPH (token->val.c))\n-\tSYNTAX_ERROR2 (\"invalid character '%c' in #if\", token->val.c);\n-      else\n-\tSYNTAX_ERROR2 (\"invalid character '\\\\%03o' in #if\", token->val.c);\n+      op.unsignedp = WCHAR_UNSIGNED;\n+    case CPP_CHAR:\t\t/* Always unsigned.  */\n+      op.value = cpp_interpret_charconst (pfile, token, 1, &temp);\n+      break;\n \n     case CPP_NAME:\n       if (token->val.node == pfile->spec_nodes.n_defined)\n@@ -322,8 +306,6 @@ lex (pfile)\n \t       && (token->val.node == pfile->spec_nodes.n_true\n \t\t   || token->val.node == pfile->spec_nodes.n_false))\n \t{\n-\t  op.op = CPP_NUMBER;\n-\t  op.unsignedp = 0;\n \t  op.value = (token->val.node == pfile->spec_nodes.n_true);\n \n \t  /* Warn about use of true or false in #if when pedantic\n@@ -333,46 +315,22 @@ lex (pfile)\n \t    cpp_error (pfile, DL_PEDWARN,\n \t\t       \"ISO C++ does not permit \\\"%s\\\" in #if\",\n \t\t       NODE_NAME (token->val.node));\n-\t  return op;\n \t}\n       else\n \t{\n-\t  op.op = CPP_NUMBER;\n-\t  op.unsignedp = 0;\n \t  op.value = 0;\n-\n \t  if (CPP_OPTION (pfile, warn_undef) && !pfile->state.skip_eval)\n \t    cpp_error (pfile, DL_WARNING, \"\\\"%s\\\" is not defined\",\n \t\t       NODE_NAME (token->val.node));\n-\t  return op;\n-\t}\n-\n-    case CPP_HASH:\n-      {\n-\tint temp;\n-\n-\top.op = CPP_NUMBER;\n-\tif (_cpp_test_assertion (pfile, &temp))\n-\t  op.op = CPP_ERROR;\n-\top.unsignedp = 0;\n-\top.value = temp;\n-\treturn op;\n-      }\n-\n-    default:\n-      if (((int) token->type > (int) CPP_EQ\n-\t   && (int) token->type < (int) CPP_PLUS_EQ))\n-\t{\n-\t  op.op = token->type;\n-\t  return op;\n \t}\n+      break;\n \n-      SYNTAX_ERROR2 (\"\\\"%s\\\" is not valid in #if expressions\",\n-\t\t     cpp_token_as_text (pfile, token));\n+    default: /* CPP_HASH */\n+      if (_cpp_test_assertion (pfile, &temp))\n+\top.op = CPP_ERROR;\n+      op.value = temp;\n     }\n \n- syntax_error:\n-  op.op = CPP_ERROR;\n   return op;\n }\n \n@@ -459,7 +417,7 @@ extra semantics need to be handled with operator-specific code.  */\n    N entries of enum cpp_ttype.  */\n static const struct operator\n {\n-  uchar prio;\t\t\t/* Priorities are even.  */\n+  uchar prio;\n   uchar flags;\n } optab[] =\n {\n@@ -539,6 +497,7 @@ _cpp_parse_expr (pfile)\n      cpp_reader *pfile;\n {\n   struct op *top = pfile->op_stack;\n+  const cpp_token *token = NULL, *prev_token;\n   unsigned int lex_count;\n   bool saw_leading_not, want_value = true;\n \n@@ -556,19 +515,26 @@ _cpp_parse_expr (pfile)\n     {\n       struct op op;\n \n-      /* Read a token */\n-      op = lex (pfile);\n+      prev_token = token;\n+      token = cpp_get_token (pfile);\n       lex_count++;\n+      op.op = token->type;\n \n       switch (op.op)\n \t{\n-\tcase CPP_ERROR:\n-\t  goto syntax_error;\n+\t  /* These tokens convert into values.  */\n \tcase CPP_NUMBER:\n-\t  /* Push a value onto the stack.  */\n+\tcase CPP_CHAR:\n+\tcase CPP_WCHAR:\n+\tcase CPP_NAME:\n+\tcase CPP_HASH:\n \t  if (!want_value)\n-\t    SYNTAX_ERROR (\"missing binary operator\");\n+\t    SYNTAX_ERROR2 (\"missing binary operator before token \\\"%s\\\"\",\n+\t\t\t   cpp_token_as_text (pfile, token));\n \t  want_value = false;\n+\t  op = eval_token (pfile, token);\n+\t  if (op.op == CPP_ERROR)\n+\t    goto syntax_error;\n \t  top->value = op.value;\n \t  top->unsignedp = op.unsignedp;\n \t  continue;\n@@ -584,19 +550,30 @@ _cpp_parse_expr (pfile)\n \t  if (want_value)\n \t    op.op = CPP_UMINUS;\n \t  break;\n+\tcase CPP_OTHER:\n+\t  if (ISGRAPH (token->val.c))\n+\t    SYNTAX_ERROR2 (\"invalid character '%c' in #if\", token->val.c);\n+\t  else\n+\t    SYNTAX_ERROR2 (\"invalid character '\\\\%03o' in #if\", token->val.c);\n+\n \tdefault:\n+\t  if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ)\n+\t    SYNTAX_ERROR2 (\"token \\\"%s\\\" is not valid in #if expressions\",\n+\t\t\t   cpp_token_as_text (pfile, token));\n \t  break;\n \t}\n \n       /* Check we have a value or operator as appropriate.  */\n       if (optab[op.op].flags & NO_L_OPERAND)\n \t{\n \t  if (!want_value)\n-\t    SYNTAX_ERROR2 (\"missing binary operator before '%s'\",\n-\t\t\t   op_as_text (pfile, op.op));\n+\t    SYNTAX_ERROR2 (\"missing binary operator before token \\\"%s\\\"\",\n+\t\t\t   cpp_token_as_text (pfile, token));\n \t}\n       else if (want_value)\n \t{\n+\t  /* Ordering here is subtle and intended to favour the\n+\t     missing parenthesis diagnostics over alternatives.  */\n \t  if (op.op == CPP_CLOSE_PAREN)\n \t    {\n \t      if (top->op == CPP_OPEN_PAREN)\n@@ -606,19 +583,20 @@ _cpp_parse_expr (pfile)\n \t    SYNTAX_ERROR (\"#if with no expression\");\n \t  if (top->op != CPP_EOF && top->op != CPP_OPEN_PAREN)\n \t    SYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n-\t\t\t   op_as_text (pfile, top->op));\n+\t\t\t   cpp_token_as_text (pfile, prev_token));\n \t}\n \n       top = reduce (pfile, top, op.op);\n       if (!top)\n \tgoto syntax_error;\n \n+      if (op.op == CPP_EOF)\n+\tbreak;\n+\n       switch (op.op)\n \t{\n \tcase CPP_CLOSE_PAREN:\n \t  continue;\n-\tcase CPP_EOF:\n-\t  goto done;\n \tcase CPP_OR_OR:\n \t  if (top->value)\n \t    pfile->state.skip_eval++;\n@@ -629,6 +607,8 @@ _cpp_parse_expr (pfile)\n \t    pfile->state.skip_eval++;\n \t  break;\n \tcase CPP_COLON:\n+\t  if (top->op != CPP_QUERY)\n+\t    SYNTAX_ERROR (\" ':' without preceding '?'\");\n \t  if (top[-1].value) /* Was '?' condition true?  */\n \t    pfile->state.skip_eval++;\n \t  else\n@@ -646,7 +626,6 @@ _cpp_parse_expr (pfile)\n       top->op = op.op;\n     }\n \n-done:\n   /* The controlling macro expression is only valid if we called lex 3\n      times: <!> <defined expression> and <EOF>.  push_conditional ()\n      checks that we are at top-of-file.  */\n@@ -693,8 +672,7 @@ reduce (pfile, top, op)\n       switch (top[1].op)\n \t{\n \tdefault:\n-\t  cpp_error (pfile, DL_ICE, \"impossible operator '%s'\",\n-\t\t     op_as_text (pfile, top[1].op));\n+\t  cpp_error (pfile, DL_ICE, \"impossible operator '%u'\", top[1].op);\n \t  return 0;\n \n \tcase CPP_NOT:\t UNARY(!);\tbreak;\n@@ -806,11 +784,6 @@ reduce (pfile, top, op)\n \t  cpp_error (pfile, DL_ERROR, \"'?' without following ':'\");\n \t  return 0;\n \tcase CPP_COLON:\n-\t  if (top->op != CPP_QUERY)\n-\t    {\n-\t      cpp_error (pfile, DL_ERROR, \" ':' without preceding '?'\");\n-\t      return 0;\n-\t    }\n \t  top--;\n \t  if (top->value) pfile->state.skip_eval--;\n \t  top->value = top->value ? v1 : v2;\n@@ -849,21 +822,3 @@ _cpp_expand_op_stack (pfile)\n \n   return pfile->op_stack + n;\n }\n-\n-/* Output OP as text for diagnostics.  */\n-static const unsigned char *\n-op_as_text (pfile, op)\n-     cpp_reader *pfile;\n-     enum cpp_ttype op;\n-{\n-  cpp_token token;\n-\n-  if (op == CPP_UPLUS)\n-    op = CPP_PLUS;\n-  else if (op == CPP_UMINUS)\n-    op = CPP_MINUS;\n-\n-  token.type = op;\n-  token.flags = 0;\n-  return cpp_token_as_text (pfile, &token);\n-}"}, {"sha": "5ad0c6e1a31e78cb439807a422fb5757ec20d462", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=60284a5928b20fe9380a361c3d61aa9c890ae7b0", "patch": "@@ -413,7 +413,7 @@ extern void _cpp_init_tokenrun\t\tPARAMS ((tokenrun *, unsigned int));\n extern void _cpp_maybe_push_include_file PARAMS ((cpp_reader *));\n \n /* In cpplib.c */\n-extern int _cpp_test_assertion PARAMS ((cpp_reader *, int *));\n+extern int _cpp_test_assertion PARAMS ((cpp_reader *, unsigned int *));\n extern int _cpp_handle_directive PARAMS ((cpp_reader *, int));\n extern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));"}, {"sha": "b210209b2e7c9a4b5099a88e5d59f3984e09273b", "filename": "gcc/cpplib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=60284a5928b20fe9380a361c3d61aa9c890ae7b0", "patch": "@@ -1652,7 +1652,7 @@ find_answer (node, candidate)\n int\n _cpp_test_assertion (pfile, value)\n      cpp_reader *pfile;\n-     int *value;\n+     unsigned int *value;\n {\n   struct answer *answer;\n   cpp_hashnode *node;"}, {"sha": "f806315491b088989080e571b63745e62a8d0522", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60284a5928b20fe9380a361c3d61aa9c890ae7b0", "patch": "@@ -1,3 +1,7 @@\n+2002-04-29  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/if-cexp.c: Add a test.\n+\n 2002-04-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/20020426-2.c: New test."}, {"sha": "1ebd11929fda0b122306148648ef550b5a3cc759", "filename": "gcc/testsuite/gcc.dg/cpp/if-cexp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-cexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60284a5928b20fe9380a361c3d61aa9c890ae7b0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-cexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-cexp.c?ref=60284a5928b20fe9380a361c3d61aa9c890ae7b0", "patch": "@@ -10,4 +10,5 @@\n #error OK\t/* { dg-error \"OK\" \"nested ? : with parens\" } */\n #endif\n \n-\n+#if 2:\t\t/* { dg-error \"':' without\" \"immediate :\" } */\n+#endif"}]}