{"sha": "ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU5MjgxZmM2NGFlYmQ0MGZiZTBjZTE3MDVjNmNhMGFhZmZkYjBjNA==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2016-08-04T13:35:30Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2016-08-04T13:35:30Z"}, "message": "Rework C/C++ OpenACC routine parsing\n\n\tgcc/c/\n\t* c-parser.c (struct oacc_routine_data): Add error_seen and\n\tfndecl_seen members.\n\t(c_finish_oacc_routine): Use these.\n\t(c_parser_declaration_or_fndef): Adjust.\n\t(c_parser_oacc_routine): Likewise.  Support more C language\n\tconstructs, and improve diagnostics.  Move pragma context\n\tchecking...\n\t(c_parser_pragma): ... here.\n\tgcc/cp/\n\t* parser.c (cp_ensure_no_oacc_routine): Improve diagnostics.\n\t(cp_parser_late_parsing_cilk_simd_fn_info): Fix diagnostics.\n\t(cp_parser_late_parsing_oacc_routine, cp_finalize_oacc_routine):\n\tSimplify code, and improve diagnostics.\n\t(cp_parser_oacc_routine): Likewise.  Move pragma context\n\tchecking...\n\t(cp_parser_pragma): ... here.\n\tgcc/testsuite/\n\t* c-c++-common/goacc/routine-5.c: Update.\n\nFrom-SVN: r239128", "tree": {"sha": "9256ee4be3149ae56764735e8e4cd0392a65d11b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9256ee4be3149ae56764735e8e4cd0392a65d11b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682"}], "stats": {"total": 565, "additions": 391, "deletions": 174}, "files": [{"sha": "ecae4f158bbf6499dc3c9c0427d3de25a44c7d74", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "patch": "@@ -1,5 +1,14 @@\n 2016-08-04  Thomas Schwinge  <thomas@codesourcery.com>\n \n+\t* c-parser.c (struct oacc_routine_data): Add error_seen and\n+\tfndecl_seen members.\n+\t(c_finish_oacc_routine): Use these.\n+\t(c_parser_declaration_or_fndef): Adjust.\n+\t(c_parser_oacc_routine): Likewise.  Support more C language\n+\tconstructs, and improve diagnostics.  Move pragma context\n+\tchecking...\n+\t(c_parser_pragma): ... here.\n+\n \t* c-parser.c (struct oacc_routine_data): New.\n \t(c_parser_declaration_or_fndef, c_parser_oacc_routine): Use it.\n \tSimplify code."}, {"sha": "ec74e0b3ead786b66ecc61e5e8c357e6ff584690", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 115, "deletions": 50, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "patch": "@@ -1276,6 +1276,8 @@ enum c_parser_prec {\n \n /* Helper data structure for parsing #pragma acc routine.  */\n struct oacc_routine_data {\n+  bool error_seen; /* Set if error has been reported.  */\n+  bool fndecl_seen; /* Set if one fn decl/definition has been seen already.  */\n   tree clauses;\n   location_t loc;\n };\n@@ -1568,8 +1570,7 @@ c_parser_external_declaration (c_parser *parser)\n }\n \n static void c_finish_omp_declare_simd (c_parser *, tree, tree, vec<c_token>);\n-static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool,\n-\t\t\t\t   bool, bool);\n+static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool);\n \n /* Parse a declaration or function definition (C90 6.5, 6.7.1, C99\n    6.7, 6.9.1).  If FNDEF_OK is true, a function definition is\n@@ -1754,8 +1755,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t}\n       c_parser_consume_token (parser);\n       if (oacc_routine_data)\n-\tc_finish_oacc_routine (oacc_routine_data, NULL_TREE, false, true,\n-\t\t\t       false);\n+\tc_finish_oacc_routine (oacc_routine_data, NULL_TREE, false);\n       return;\n     }\n \n@@ -1853,7 +1853,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n   prefix_attrs = specs->attrs;\n   all_prefix_attrs = prefix_attrs;\n   specs->attrs = NULL_TREE;\n-  for (bool first = true;; first = false)\n+  while (true)\n     {\n       struct c_declarator *declarator;\n       bool dummy = false;\n@@ -1873,8 +1873,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    c_finish_omp_declare_simd (parser, NULL_TREE, NULL_TREE,\n \t\t\t\t       omp_declare_simd_clauses);\n \t  if (oacc_routine_data)\n-\t    c_finish_oacc_routine (oacc_routine_data, NULL_TREE,\n-\t\t\t\t   false, first, false);\n+\t    c_finish_oacc_routine (oacc_routine_data, NULL_TREE, false);\n \t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t  return;\n \t}\n@@ -1990,8 +1989,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  finish_init ();\n \t\t}\n \t      if (oacc_routine_data)\n-\t\tc_finish_oacc_routine (oacc_routine_data, d,\n-\t\t\t\t       false, first, false);\n+\t\tc_finish_oacc_routine (oacc_routine_data, d, false);\n \t      if (d != error_mark_node)\n \t\t{\n \t\t  maybe_warn_string_init (init_loc, TREE_TYPE (d), init);\n@@ -2036,8 +2034,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t    temp_pop_parm_decls ();\n \t\t}\n \t      if (oacc_routine_data)\n-\t\tc_finish_oacc_routine (oacc_routine_data, d,\n-\t\t\t\t       false, first, false);\n+\t\tc_finish_oacc_routine (oacc_routine_data, d, false);\n \t      if (d)\n \t\tfinish_decl (d, UNKNOWN_LOCATION, NULL_TREE,\n \t\t\t     NULL_TREE, asm_name);\n@@ -2149,8 +2146,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \tc_finish_omp_declare_simd (parser, current_function_decl, NULL_TREE,\n \t\t\t\t   omp_declare_simd_clauses);\n       if (oacc_routine_data)\n-\tc_finish_oacc_routine (oacc_routine_data, current_function_decl,\n-\t\t\t       false, first, true);\n+\tc_finish_oacc_routine (oacc_routine_data, current_function_decl, true);\n       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus\n \t= c_parser_peek_token (parser)->location;\n       fnbody = c_parser_compound_statement (parser);\n@@ -10123,6 +10119,13 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       return false;\n \n     case PRAGMA_OACC_ROUTINE:\n+      if (context != pragma_external)\n+\t{\n+\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t    \"%<#pragma acc routine%> must be at file scope\");\n+\t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+\t  return false;\n+\t}\n       c_parser_oacc_routine (parser, context);\n       return false;\n \n@@ -14030,29 +14033,32 @@ c_parser_oacc_kernels_parallel (location_t loc, c_parser *parser,\n static void\n c_parser_oacc_routine (c_parser *parser, enum pragma_context context)\n {\n-  tree decl = NULL_TREE;\n+  gcc_checking_assert (context == pragma_external);\n+\n   oacc_routine_data data;\n+  data.error_seen = false;\n+  data.fndecl_seen = false;\n   data.clauses = NULL_TREE;\n   data.loc = c_parser_peek_token (parser)->location;\n-  \n-  if (context != pragma_external)\n-    c_parser_error (parser, \"%<#pragma acc routine%> not at file scope\");\n \n   c_parser_consume_pragma (parser);\n \n-  /* Scan for optional '( name )'.  */\n-  if (c_parser_peek_token (parser)->type == CPP_OPEN_PAREN)\n+  /* Look for optional '( name )'.  */\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n-      c_parser_consume_token (parser);\n+      c_parser_consume_token (parser); /* '(' */\n \n-      c_token *token = c_parser_peek_token (parser);\n-      if (token->type == CPP_NAME && (token->id_kind == C_ID_ID\n-\t\t\t\t      || token->id_kind == C_ID_TYPENAME))\n+      tree decl = NULL_TREE;\n+      c_token *name_token = c_parser_peek_token (parser);\n+      location_t name_loc = name_token->location;\n+      if (name_token->type == CPP_NAME\n+\t  && (name_token->id_kind == C_ID_ID\n+\t      || name_token->id_kind == C_ID_TYPENAME))\n \t{\n-\t  decl = lookup_name (token->value);\n+\t  decl = lookup_name (name_token->value);\n \t  if (!decl)\n-\t    error_at (token->location, \"%qE has not been declared\",\n-\t\t      token->value);\n+\t    error_at (name_loc,\n+\t\t      \"%qE has not been declared\", name_token->value);\n \t  c_parser_consume_token (parser);\n \t}\n       else\n@@ -14064,47 +14070,103 @@ c_parser_oacc_routine (c_parser *parser, enum pragma_context context)\n \t  c_parser_skip_to_pragma_eol (parser, false);\n \t  return;\n \t}\n+\n+      data.clauses\n+\t= c_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n+\t\t\t\t     \"#pragma acc routine\");\n+\n+      if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t{\n+\t  error_at (name_loc, \"%qD does not refer to a function\", decl);\n+\t  return;\n+\t}\n+\n+      c_finish_oacc_routine (&data, decl, false);\n     }\n+  else /* No optional '( name )'.  */\n+    {\n+      data.clauses\n+\t= c_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n+\t\t\t\t     \"#pragma acc routine\");\n \n-  /* Build a chain of clauses.  */\n-  parser->in_pragma = true;\n-  data.clauses\n-    = c_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n-\t\t\t\t \"#pragma acc routine\");\n-\n-  if (decl)\n-    c_finish_oacc_routine (&data, decl, true, true, false);\n-  else if (c_parser_peek_token (parser)->type == CPP_PRAGMA)\n-    /* This will emit an error.  */\n-    c_finish_oacc_routine (&data, NULL_TREE, false, true, false);\n-  else\n-    c_parser_declaration_or_fndef (parser, true, false, false, false,\n-\t\t\t\t   true, NULL, vNULL, &data);\n+      /* Emit a helpful diagnostic if there's another pragma following this\n+\t one.  Also don't allow a static assertion declaration, as in the\n+\t following we'll just parse a *single* \"declaration or function\n+\t definition\", and the static assertion counts an one.  */\n+      if (c_parser_next_token_is (parser, CPP_PRAGMA)\n+\t  || c_parser_next_token_is_keyword (parser, RID_STATIC_ASSERT))\n+\t{\n+\t  error_at (data.loc,\n+\t\t    \"%<#pragma acc routine%> not immediately followed by\"\n+\t\t    \" function declaration or definition\");\n+\t  /* ..., and then just keep going.  */\n+\t  return;\n+\t}\n+\n+      /* We only have to consider the pragma_external case here.  */\n+      if (c_parser_next_token_is (parser, CPP_KEYWORD)\n+\t  && c_parser_peek_token (parser)->keyword == RID_EXTENSION)\n+\t{\n+\t  int ext = disable_extension_diagnostics ();\n+\t  do\n+\t    c_parser_consume_token (parser);\n+\t  while (c_parser_next_token_is (parser, CPP_KEYWORD)\n+\t\t && c_parser_peek_token (parser)->keyword == RID_EXTENSION);\n+\t  c_parser_declaration_or_fndef (parser, true, true, true, false, true,\n+\t\t\t\t\t NULL, vNULL, &data);\n+\t  restore_extension_diagnostics (ext);\n+\t}\n+      else\n+\tc_parser_declaration_or_fndef (parser, true, true, true, false, true,\n+\t\t\t\t       NULL, vNULL, &data);\n+    }\n }\n \n /* Finalize an OpenACC routine pragma, applying it to FNDECL.\n    IS_DEFN is true if we're applying it to the definition.  */\n \n static void\n c_finish_oacc_routine (struct oacc_routine_data *data, tree fndecl,\n-\t\t       bool named, bool first, bool is_defn)\n+\t\t       bool is_defn)\n {\n-  if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL || !first)\n+  /* Keep going if we're in error reporting mode.  */\n+  if (data->error_seen\n+      || fndecl == error_mark_node)\n+    return;\n+\n+  if (data->fndecl_seen)\n     {\n-      if (fndecl != error_mark_node)\n-\terror_at (data->loc, \"%<#pragma acc routine%> %s\",\n-\t\t  named ? \"does not refer to a function\"\n-\t\t  : \"not followed by single function\");\n+      error_at (data->loc,\n+\t\t\"%<#pragma acc routine%> not immediately followed by\"\n+\t\t\" a single function declaration or definition\");\n+      data->error_seen = true;\n+      return;\n+    }\n+  if (fndecl == NULL_TREE || TREE_CODE (fndecl) != FUNCTION_DECL)\n+    {\n+      error_at (data->loc,\n+\t\t\"%<#pragma acc routine%> not immediately followed by\"\n+\t\t\" function declaration or definition\");\n+      data->error_seen = true;\n       return;\n     }\n \n   if (get_oacc_fn_attrib (fndecl))\n-    error_at (data->loc,\n-\t      \"%<#pragma acc routine%> already applied to %D\", fndecl);\n+    {\n+      error_at (data->loc,\n+\t\t\"%<#pragma acc routine%> already applied to %qD\", fndecl);\n+      data->error_seen = true;\n+      return;\n+    }\n \n   if (TREE_USED (fndecl) || (!is_defn && DECL_SAVED_TREE (fndecl)))\n-    error_at (data->loc, \"%<#pragma acc routine%> must be applied before %s\",\n-\t      TREE_USED (fndecl) ? \"use\" : \"definition\");\n+    {\n+      error_at (data->loc,\n+\t\t\"%<#pragma acc routine%> must be applied before %s\",\n+\t\tTREE_USED (fndecl) ? \"use\" : \"definition\");\n+      data->error_seen = true;\n+      return;\n+    }\n \n   /* Process the routine's dimension clauses.  */\n   tree dims = build_oacc_routine_dims (data->clauses);\n@@ -14114,6 +14176,9 @@ c_finish_oacc_routine (struct oacc_routine_data *data, tree fndecl,\n   DECL_ATTRIBUTES (fndecl)\n     = tree_cons (get_identifier (\"omp declare target\"),\n \t\t NULL_TREE, DECL_ATTRIBUTES (fndecl));\n+\n+  /* Remember that we've used this \"#pragma acc routine\".  */\n+  data->fndecl_seen = true;\n }\n \n /* OpenACC 2.0:"}, {"sha": "4c2b1157dfdba5ac08f6743dc5dfbb0a10a75c94", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "patch": "@@ -1,5 +1,13 @@\n 2016-08-04  Thomas Schwinge  <thomas@codesourcery.com>\n \n+\t* parser.c (cp_ensure_no_oacc_routine): Improve diagnostics.\n+\t(cp_parser_late_parsing_cilk_simd_fn_info): Fix diagnostics.\n+\t(cp_parser_late_parsing_oacc_routine, cp_finalize_oacc_routine):\n+\tSimplify code, and improve diagnostics.\n+\t(cp_parser_oacc_routine): Likewise.  Move pragma context\n+\tchecking...\n+\t(cp_parser_pragma): ... here.\n+\n \t* parser.h (struct cp_omp_declare_simd_data): New.\n \t(struct cp_parser): Use it for oacc_routine member.\n \t* parser.c (cp_ensure_no_oacc_routine, cp_parser_oacc_routine)"}, {"sha": "fdb0ab0b035f4482464c45710ab0e3972f1c5514", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 81, "deletions": 99, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "patch": "@@ -1392,8 +1392,8 @@ cp_ensure_no_oacc_routine (cp_parser *parser)\n   if (parser->oacc_routine && !parser->oacc_routine->error_seen)\n     {\n       error_at (parser->oacc_routine->loc,\n-\t\t\"%<#pragma acc routine%> not followed by a function \"\n-\t\t\"declaration or definition\");\n+\t\t\"%<#pragma acc routine%> not immediately followed by \"\n+\t\t\"function declaration or definition\");\n       parser->oacc_routine = NULL;\n     }\n }\n@@ -35736,6 +35736,8 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n \t used while this scope is live.  */\n       parser->omp_declare_simd = &data;\n     }\n+\n+  /* Store away all pragma tokens.  */\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n \t && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n     cp_lexer_consume_token (parser->lexer);\n@@ -35745,6 +35747,7 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n   struct cp_token_cache *cp\n     = cp_token_cache_new (pragma_tok, cp_lexer_peek_token (parser->lexer));\n   parser->omp_declare_simd->tokens.safe_push (cp);\n+\n   if (first_p)\n     {\n       while (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA))\n@@ -35789,9 +35792,9 @@ cp_parser_late_parsing_cilk_simd_fn_info (cp_parser *parser, tree attrs)\n   if (parser->omp_declare_simd != NULL\n       || lookup_attribute (\"simd\", attrs))\n     {\n-      error (\"%<#pragma omp declare simd%> of %<simd%> attribute cannot be \"\n+      error (\"%<#pragma omp declare simd%> or %<simd%> attribute cannot be \"\n \t     \"used in the same function marked as a Cilk Plus SIMD-enabled \"\n-\t     \" function\");\n+\t     \"function\");\n       parser->cilk_simd_fn_info->tokens.release ();\n       XDELETE (parser->cilk_simd_fn_info);\n       parser->cilk_simd_fn_info = NULL;\n@@ -36563,64 +36566,39 @@ static void\n cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t\t\tenum pragma_context context)\n {\n-  bool first_p = parser->oacc_routine == NULL;\n-  cp_oacc_routine_data data;\n-  if (first_p)\n-    {\n-      data.error_seen = false;\n-      data.fndecl_seen = false;\n-      data.tokens = vNULL;\n-      data.clauses = NULL_TREE;\n-      data.loc = pragma_tok->location;\n-      /* It is safe to take the address of a local variable; it will only be\n-\t used while this scope is live.  */\n-      parser->oacc_routine = &data;\n-    }\n+  gcc_checking_assert (context == pragma_external);\n+  /* The checking for \"another pragma following this one\" in the \"no optional\n+     '( name )'\" case makes sure that we dont re-enter.  */\n+  gcc_checking_assert (parser->oacc_routine == NULL);\n \n-  if (context != pragma_external)\n-    {\n-      cp_parser_error (parser, \"%<#pragma acc routine%> not at file scope\");\n-      parser->oacc_routine->error_seen = true;\n-      parser->oacc_routine = NULL;\n-      return;\n-    }\n+  cp_oacc_routine_data data;\n+  data.error_seen = false;\n+  data.fndecl_seen = false;\n+  data.tokens = vNULL;\n+  data.clauses = NULL_TREE;\n+  data.loc = pragma_tok->location;\n+  /* It is safe to take the address of a local variable; it will only be\n+     used while this scope is live.  */\n+  parser->oacc_routine = &data;\n \n   /* Look for optional '( name )'.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n-      if (!first_p)\n-\t{\n-\t  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n-\t\t && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n-\t    parser->oacc_routine->error_seen = true;\n-\t  cp_parser_require_pragma_eol (parser, pragma_tok);\n-\n-\t  error_at (parser->oacc_routine->loc,\n-\t\t    \"%<#pragma acc routine%> not followed by a \"\n-\t\t    \"function declaration or definition\");\n-\n-\t  parser->oacc_routine->error_seen = true;\n-\t  return;\n-\t}\n-\n-      cp_lexer_consume_token (parser->lexer);\n-      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      cp_lexer_consume_token (parser->lexer); /* '(' */\n \n       /* We parse the name as an id-expression.  If it resolves to\n \t anything other than a non-overloaded function at namespace\n \t scope, it's an error.  */\n-      tree id = cp_parser_id_expression (parser,\n-\t\t\t\t\t /*template_keyword_p=*/false,\n-\t\t\t\t\t /*check_dependency_p=*/false,\n-\t\t\t\t\t /*template_p=*/NULL,\n-\t\t\t\t\t /*declarator_p=*/false,\n-\t\t\t\t\t /*optional_p=*/false);\n-      tree decl = cp_parser_lookup_name_simple (parser, id, token->location);\n-      if (id != error_mark_node && decl == error_mark_node)\n-\tcp_parser_name_lookup_error (parser, id, decl, NLE_NULL,\n-\t\t\t\t     token->location);\n+      location_t name_loc = cp_lexer_peek_token (parser->lexer)->location;\n+      tree name = cp_parser_id_expression (parser,\n+\t\t\t\t\t   /*template_keyword_p=*/false,\n+\t\t\t\t\t   /*check_dependency_p=*/false,\n+\t\t\t\t\t   /*template_p=*/NULL,\n+\t\t\t\t\t   /*declarator_p=*/false,\n+\t\t\t\t\t   /*optional_p=*/false);\n+      tree decl = cp_parser_lookup_name_simple (parser, name, name_loc);\n+      if (name != error_mark_node && decl == error_mark_node)\n+\tcp_parser_name_lookup_error (parser, name, decl, NLE_NULL, name_loc);\n \n       if (decl == error_mark_node\n \t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n@@ -36630,8 +36608,6 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t  return;\n \t}\n \n-      /* Build a chain of clauses.  */\n-      parser->lexer->in_pragma = true;\n       data.clauses\n \t= cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n \t\t\t\t      \"#pragma acc routine\",\n@@ -36641,7 +36617,7 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t  && (TREE_CODE (decl) != FUNCTION_DECL\n \t      || DECL_FUNCTION_TEMPLATE_P  (decl)))\n \t{\n-\t  error_at (data.loc,\n+\t  error_at (name_loc,\n \t\t    \"%<#pragma acc routine%> names a set of overloads\");\n \t  parser->oacc_routine = NULL;\n \t  return;\n@@ -36651,91 +36627,91 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t namespaces?  */\n       if (!DECL_NAMESPACE_SCOPE_P (decl))\n \t{\n-\t  error_at (data.loc,\n-\t\t    \"%<#pragma acc routine%> does not refer to a \"\n-\t\t    \"namespace scope function\");\n+\t  error_at (name_loc,\n+\t\t    \"%qD does not refer to a namespace scope function\", decl);\n \t  parser->oacc_routine = NULL;\n \t  return;\n \t}\n \n-      if (!decl || TREE_CODE (decl) != FUNCTION_DECL)\n+      if (TREE_CODE (decl) != FUNCTION_DECL)\n \t{\n-\t  error_at (data.loc,\n-\t\t    \"%<#pragma acc routine%> does not refer to a function\");\n+\t  error_at (name_loc, \"%qD does not refer to a function\", decl);\n \t  parser->oacc_routine = NULL;\n \t  return;\n \t}\n \n       cp_finalize_oacc_routine (parser, decl, false);\n-      data.tokens.release ();\n       parser->oacc_routine = NULL;\n     }\n-  else\n+  else /* No optional '( name )'.  */\n     {\n+      /* Store away all pragma tokens.  */\n       while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n \t     && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n \tcp_lexer_consume_token (parser->lexer);\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n \tparser->oacc_routine->error_seen = true;\n       cp_parser_require_pragma_eol (parser, pragma_tok);\n-\n       struct cp_token_cache *cp\n \t= cp_token_cache_new (pragma_tok, cp_lexer_peek_token (parser->lexer));\n       parser->oacc_routine->tokens.safe_push (cp);\n \n-      while (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA))\n-\tcp_parser_pragma (parser, context, NULL);\n-\n-      if (first_p)\n+      /* Emit a helpful diagnostic if there's another pragma following this\n+\t one.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA))\n \t{\n-\t  cp_parser_declaration (parser);\n-\n-\t  if (parser->oacc_routine\n-\t      && !parser->oacc_routine->error_seen\n-\t      && !parser->oacc_routine->fndecl_seen)\n-\t    error_at (data.loc,\n-\t\t      \"%<#pragma acc routine%> not followed by a \"\n-\t\t      \"function declaration or definition\");\n-\n+\t  cp_ensure_no_oacc_routine (parser);\n \t  data.tokens.release ();\n-\t  parser->oacc_routine = NULL;\n+\t  /* ..., and then just keep going.  */\n+\t  return;\n \t}\n+\n+      /* We only have to consider the pragma_external case here.  */\n+      cp_parser_declaration (parser);\n+      if (parser->oacc_routine\n+\t  && !parser->oacc_routine->fndecl_seen)\n+\tcp_ensure_no_oacc_routine (parser);\n+      else\n+\tparser->oacc_routine = NULL;\n+      data.tokens.release ();\n     }\n }\n \n /* Finalize #pragma acc routine clauses after direct declarator has\n-   been parsed, and put that into \"oacc function\" attribute.  */\n+   been parsed.  */\n \n static tree\n cp_parser_late_parsing_oacc_routine (cp_parser *parser, tree attrs)\n {\n   struct cp_token_cache *ce;\n   cp_oacc_routine_data *data = parser->oacc_routine;\n \n-  if ((!data->error_seen && data->fndecl_seen)\n-      || data->tokens.length () != 1)\n+  if (!data->error_seen && data->fndecl_seen)\n     {\n       error_at (data->loc,\n-\t\t\"%<#pragma acc routine%> not followed by a \"\n-\t\t\"function declaration or definition\");\n+\t\t\"%<#pragma acc routine%> not immediately followed by \"\n+\t\t\"a single function declaration or definition\");\n       data->error_seen = true;\n     }\n   if (data->error_seen)\n     return attrs;\n \n+  gcc_checking_assert (data->tokens.length () == 1);\n   ce = data->tokens[0];\n \n   cp_parser_push_lexer_for_tokens (parser, ce);\n   parser->lexer->in_pragma = true;\n   gcc_assert (cp_lexer_peek_token (parser->lexer)->type == CPP_PRAGMA);\n \n   cp_token *pragma_tok = cp_lexer_consume_token (parser->lexer);\n+  gcc_checking_assert (parser->oacc_routine->clauses == NULL_TREE);\n   parser->oacc_routine->clauses\n     = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n \t\t\t\t  \"#pragma acc routine\", pragma_tok);\n   cp_parser_pop_lexer (parser);\n+  /* Later, cp_finalize_oacc_routine will process the clauses, and then set\n+     fndecl_seen.  */\n \n-  data->fndecl_seen = true;\n   return attrs;\n }\n \n@@ -36747,34 +36723,29 @@ cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)\n {\n   if (__builtin_expect (parser->oacc_routine != NULL, 0))\n     {\n-      if (parser->oacc_routine->error_seen)\n+      /* Keep going if we're in error reporting mode.  */\n+      if (parser->oacc_routine->error_seen\n+\t  || fndecl == error_mark_node)\n \treturn;\n-      \n-      if (fndecl == error_mark_node)\n+\n+      if (parser->oacc_routine->fndecl_seen)\n \t{\n+\t  error_at (parser->oacc_routine->loc,\n+\t\t    \"%<#pragma acc routine%> not immediately followed by\"\n+\t\t    \" a single function declaration or definition\");\n \t  parser->oacc_routine = NULL;\n \t  return;\n \t}\n-\n       if (TREE_CODE (fndecl) != FUNCTION_DECL)\n \t{\n \t  cp_ensure_no_oacc_routine (parser);\n \t  return;\n \t}\n \n-      if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL)\n-\t{\n-\t  error_at (parser->oacc_routine->loc,\n-\t\t    \"%<#pragma acc routine%> not followed by a function \"\n-\t\t    \"declaration or definition\");\n-\t  parser->oacc_routine = NULL;\n-\t  return;\n-\t}\n-\t  \n       if (get_oacc_fn_attrib (fndecl))\n \t{\n \t  error_at (parser->oacc_routine->loc,\n-\t\t    \"%<#pragma acc routine%> already applied to %D\", fndecl);\n+\t\t    \"%<#pragma acc routine%> already applied to %qD\", fndecl);\n \t  parser->oacc_routine = NULL;\n \t  return;\n \t}\n@@ -36796,6 +36767,11 @@ cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)\n       DECL_ATTRIBUTES (fndecl)\n \t= tree_cons (get_identifier (\"omp declare target\"),\n \t\t     NULL_TREE, DECL_ATTRIBUTES (fndecl));\n+\n+      /* Don't unset parser->oacc_routine here: we may still need it to\n+\t diagnose wrong usage.  But, remember that we've used this \"#pragma acc\n+\t routine\".  */\n+      parser->oacc_routine->fndecl_seen = true;\n     }\n }\n \n@@ -37395,6 +37371,12 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n       return false;\n \n     case PRAGMA_OACC_ROUTINE:\n+      if (context != pragma_external)\n+\t{\n+\t  error_at (pragma_tok->location,\n+\t\t    \"%<#pragma acc routine%> must be at file scope\");\n+\t  break;\n+\t}\n       cp_parser_oacc_routine (parser, pragma_tok, context);\n       return false;\n "}, {"sha": "0d6a8d2007bdef5c013850343ab085349ad16425", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "patch": "@@ -1,3 +1,7 @@\n+2016-08-04  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* c-c++-common/goacc/routine-5.c: Update.\n+\n 2016-08-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR rtl-optimization/70903"}, {"sha": "17fe67cd298f2d9019035fd088c51e3e4e947005", "filename": "gcc/testsuite/c-c++-common/goacc/routine-5.c", "status": "modified", "additions": 174, "deletions": 25, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c?ref=ae9281fc64aebd40fbe0ce1705c6ca0aaffdb0c4", "patch": "@@ -1,64 +1,211 @@\n-/* { dg-do compile } */\n+/* Miscellaneous OpenACC routine front end checking.  */\n \n-#pragma acc routine /* { dg-error \"not followed by\" } */\n+/* Pragma context.  */\n+\n+struct PC\n+{\n+#pragma acc routine /* { dg-error \".#pragma acc routine. must be at file scope\" } */\n+};\n+\n+void PC1( /* { dg-bogus \"variable or field .PC1. declared void\" \"TODO\" { xfail c++ } } */\n+#pragma acc routine\n+\t /* { dg-error \".#pragma acc routine. must be at file scope\" \"\" { target c } 11 }\n+\t    { dg-error \".#pragma. is not allowed here\" \"\" { target c++ } 11 } */\n+) /* { dg-bogus \"expected declaration specifiers or .\\\\.\\\\.\\\\.. before .\\\\). token\" \"TODO\" { xfail c } } */\n+{\n+}\n+\n+void PC2()\n+{\n+  if (0)\n+#pragma acc routine /* { dg-error \".#pragma acc routine. must be at file scope\" } */\n+    ;\n+}\n+\n+void PC3()\n+{\n+#pragma acc routine /* { dg-error \".#pragma acc routine. must be at file scope\" } */\n+}\n+\n+\n+/* \"( name )\" syntax.  */\n+\n+#pragma acc routine ( /* { dg-error \"expected (function name|unqualified-id) before end of line\" } */\n+#pragma acc routine () /* { dg-error \"expected (function name|unqualified-id) before .\\\\). token\" } */\n+#pragma acc routine (+) /* { dg-error \"expected (function name|unqualified-id) before .\\\\+. token\" } */\n+#pragma acc routine (?) /* { dg-error \"expected (function name|unqualified-id) before .\\\\?. token\" } */\n+#pragma acc routine (:) /* { dg-error \"expected (function name|unqualified-id) before .:. token\" } */\n+#pragma acc routine (4) /* { dg-error \"expected (function name|unqualified-id) before numeric constant\" } */\n+#pragma acc routine ('4') /* { dg-error \"expected (function name|unqualified-id) before .4.\" } */\n+#pragma acc routine (\"4\") /* { dg-error \"expected (function name|unqualified-id) before string constant\" } */\n+extern void R1(void);\n+extern void R2(void);\n+#pragma acc routine (R1, R2, R3) worker /* { dg-error \"expected .\\\\). before .,. token\" } */\n+#pragma acc routine (R1 R2 R3) worker /* { dg-error \"expected .\\\\). before .R2.\" } */\n+#pragma acc routine (R1) worker\n+#pragma acc routine (R2) worker\n+\n+\n+/* \"#pragma acc routine\" not immediately followed by (a single) function\n+   declaration or definition.  */\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n int a;\n \n-#pragma acc routine /* { dg-error \"not followed by\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by a single function declaration or definition\" } */\n void fn1 (void), fn1b (void);\n \n-#pragma acc routine /* { dg-error \"not followed by\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n int b, fn2 (void);\n \n-#pragma acc routine /* { dg-error \"not followed by\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+int b_, fn2_ (void), B_;\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by a single function declaration or definition\" } */\n int fn3 (void), b2;\n \n-#pragma acc routine /* { dg-error \"not followed by\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n typedef struct c c;\n \n-#pragma acc routine /* { dg-error \"not followed by\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n struct d {} d;\n \n-#pragma acc routine /* { dg-error \"not followed by\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by a single function declaration or definition\" } */\n+void fn1_2 (void), fn1b_2 (void);\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+int b_2, fn2_2 (void);\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+int b_2_, fn2_2_ (void), B_2_;\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by a single function declaration or definition\" } */\n+int fn3_2 (void), b2_2;\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+typedef struct c_2 c_2;\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+struct d_2 {} d_2;\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n #pragma acc routine\n int fn4 (void);\n \n int fn5a (void);\n-\n-#pragma acc routine /* { dg-error \"not followed by\" } */\n+int fn5b (void);\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n #pragma acc routine (fn5a)\n+#pragma acc routine (fn5b)\n int fn5 (void);\n \n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+#pragma acc routine (fn6a) /* { dg-error \".fn6a. has not been declared\" } */\n+#pragma acc routine (fn6b) /* { dg-error \".fn6b. has not been declared\" } */\n+int fn6 (void);\n+\n #ifdef __cplusplus\n \n-#pragma acc routine /* { dg-error \"not followed by\" \"\" { target c++ } } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" \"\" { target c++ } } */\n namespace f {}\n \n namespace g {}\n \n-#pragma acc routine /* { dg-error \"not followed by\" \"\" { target c++ } } */\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" \"\" { target c++ } } */\n using namespace g;\n \n-#pragma acc routine (g) /* { dg-error \"does not refer to a function\" \"\" { target c++ } } */\n+#pragma acc routine (g) /* { dg-error \".g. does not refer to a function\" \"\" { target c++ } } */\n \n #endif /* __cplusplus */\n \n-#pragma acc routine (a) /* { dg-error \"does not refer to a function\" } */\n+#pragma acc routine (a) /* { dg-error \".a. does not refer to a function\" } */\n   \n-#pragma acc routine (c) /* { dg-error \"does not refer to a function\" } */\n+#pragma acc routine (c) /* { dg-error \".c. does not refer to a function\" } */\n \n \n-#pragma acc routine () vector /* { dg-error \"expected (function name|unqualified-id) before .\\\\). token\" } */\n+/* Static assert.  */\n \n-#pragma acc routine (+) /* { dg-error \"expected (function name|unqualified-id) before .\\\\+. token\" } */\n+#pragma acc routine /* { dg-bogus \".#pragma acc routine. not immediately followed by function declaration or definition\" \"TODO\" { xfail *-*-* } } */\n+#ifndef __cplusplus /* C */\n+_Static_assert(0, \"\"); /* { dg-error \"static assertion failed\" \"\" { target c } } */\n+#elif __cplusplus < 201103L /* C++98 */\n+/* C++98 doesn't support static_assert, so fake an error in combination, and as\n+   expected with the \"#pragma acc routine\" above.  */\n+int dummy_instead_of_static_assert;\n+#else /* C++ */\n+static_assert(0, \"\"); /* { dg-error \"static assertion failed\" \"\" { target c++11 } } */\n+#endif\n+void f_static_assert();\n+/* Check that we already recognized \"f_static_assert\" as an OpenACC routine.  */\n+#pragma acc routine (f_static_assert) /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*f_static_assert\" \"TODO\" { xfail *-*-* } } */\n \n \n-extern void R1(void);\n-extern void R2(void);\n-#pragma acc routine (R1, R2, R3) worker /* { dg-error \"expected .\\\\). before .,. token\" } */\n-#pragma acc routine (R1 R2 R3) worker /* { dg-error \"expected .\\\\). before .R2.\" } */\n-#pragma acc routine (R1) worker\n-#pragma acc routine (R2) worker\n+/* __extension__ usage.  */\n+\n+#pragma acc routine\n+__extension__ extern void ex1();\n+#pragma acc routine (ex1) /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*ex1\" } */\n+\n+#pragma acc routine\n+__extension__ __extension__ __extension__ __extension__ __extension__ void ex2()\n+{\n+}\n+#pragma acc routine (ex2) /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*ex2\" } */\n+\n+#pragma acc routine /* { dg-error \".#pragma acc routine. not immediately followed by function declaration or definition\" } */\n+__extension__ int ex3;\n+#pragma acc routine (ex3) /* { dg-error \".ex3. does not refer to a function\" } */\n+\n+\n+/* \"#pragma acc routine\" already applied.  */\n \n+extern void fungsi_1();\n+#pragma acc routine(fungsi_1) gang\n+#pragma acc routine(fungsi_1) gang /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_1\" } */\n+#pragma acc routine(fungsi_1) worker /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_1\" } */\n+#pragma acc routine(fungsi_1) vector /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_1\" } */\n+\n+#pragma acc routine seq\n+extern void fungsi_2();\n+#pragma acc routine(fungsi_2) seq /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_2.\" } */\n+#pragma acc routine(fungsi_2) worker /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_2.\" } */\n+#pragma acc routine(fungsi_2) /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_2.\" } */\n+\n+#pragma acc routine vector\n+extern void fungsi_3();\n+#pragma acc routine vector /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_3.\" } */\n+void fungsi_3()\n+{\n+}\n+\n+extern void fungsi_4();\n+#pragma acc routine (fungsi_4) worker\n+#pragma acc routine gang /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_4.\" } */\n+void fungsi_4()\n+{\n+}\n+\n+#pragma acc routine gang\n+void fungsi_5()\n+{\n+}\n+#pragma acc routine (fungsi_5) worker /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_5.\" } */\n+\n+#pragma acc routine seq\n+void fungsi_6()\n+{\n+}\n+#pragma acc routine seq /* { dg-error \".#pragma acc routine. already applied to .\\[void \\]*fungsi_6.\" } */\n+extern void fungsi_6();\n+\n+\n+/* \"#pragma acc routine\" must be applied before.  */\n \n void Bar ();\n \n@@ -67,13 +214,15 @@ void Foo ()\n   Bar ();\n }\n \n-#pragma acc routine (Bar) // { dg-error \"must be applied before use\" }\n+#pragma acc routine (Bar) // { dg-error \".#pragma acc routine. must be applied before use\" }\n \n-#pragma acc routine (Foo) gang // { dg-error \"must be applied before definition\" }\n+#pragma acc routine (Foo) gang // { dg-error \".#pragma acc routine. must be applied before definition\" }\n \n #pragma acc routine (Baz) // { dg-error \"not been declared\" }\n \n \n+/* OpenACC declare.  */\n+\n int vb1;\t\t/* { dg-error \"directive for use\" } */\n extern int vb2;\t\t/* { dg-error \"directive for use\" } */\n static int vb3;\t\t/* { dg-error \"directive for use\" } */"}]}