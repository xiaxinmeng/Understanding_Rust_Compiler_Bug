{"sha": "f31c0a32f5285f585d3dd53901f304b864ebfe29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxYzBhMzJmNTI4NWY1ODVkM2RkNTM5MDFmMzA0Yjg2NGViZmUyOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-28T05:10:05Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-28T05:10:05Z"}, "message": "cp-tree.h (make_temp_vec): Remove.\n\n\t* cp-tree.h (make_temp_vec): Remove.\n\t(make_scratch_vec): Likewise.\n\t* call.c (add_function_candidate): Use make_tree_vec.\n\t(add_conv_candidate): Likewise.\n\t(build_builtin_candidate): Likewise.\n\t(add_template_candidate_real): Likewise.\n\t* class.c (resolve_address_of_overloaded_function): Likewise.\n\t* decl.c (start_function): Don't fool with the momentary obstack.\n\t(finish_function): Likewise.\n\t* init.c (expand_direct_vtbls_init): Likewise.\n\t(begin_init_stmts): Likewise.\n\t(finish_init_stmts): Likewise.\n\t* pt.c (add_to_template_args): Use make_tree_vec.\n\t(check_explicit_specialization): Likewise.\n\t(coerce_template_parms): Likewise.\n\t(lookup_template_class): Don't fool with the momentary obstack.\n\t(instantiate_class_template): Likewise.\n\t(tsubst_template_arg_vector): Use make_tree_vec.\n\t(tsubst_aggr_type): Don't fool with the momentary obstack.\n\t(tsubst_decl): Likewise.  Use make_tree_vec.\n\t(try_one_overload): Likewise.\n\t(try_class_unification):  Don't fool with the momentary obstack.\n\t(get_bindings_real): Use make_tree_vec.\n\t(set_mangled_name_for_template_decl): Likewise.\n\t* rtti.c (synthesize_tinfo_fn): Don't fool with the momentary obstack.\n\t* semantics.c (finish_expr_stmt): Likewise.\n\t(finish_do_stmt): Likewise.\n\t(finish_for_expr): Likewise.\n\t(finish_switch_cond): Likewise.\n\t(do_pushlevel): Likewise.\n\t(do_poplevel): Likewise.\n\t* tree.c (make_temp_vec): Remove.\n\nFrom-SVN: r30225", "tree": {"sha": "5584b920b11041a4ee4bf0f7dcb9eff30ec02345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5584b920b11041a4ee4bf0f7dcb9eff30ec02345"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f31c0a32f5285f585d3dd53901f304b864ebfe29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31c0a32f5285f585d3dd53901f304b864ebfe29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f31c0a32f5285f585d3dd53901f304b864ebfe29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31c0a32f5285f585d3dd53901f304b864ebfe29/comments", "author": null, "committer": null, "parents": [{"sha": "62961522f7b2e524e9266302aff321ef8579fb16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62961522f7b2e524e9266302aff321ef8579fb16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62961522f7b2e524e9266302aff321ef8579fb16"}], "stats": {"total": 166, "additions": 58, "deletions": 108}, "files": [{"sha": "6fb431945ee775a4873d397821e126dc357fc38c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -1,5 +1,38 @@\n 1999-10-27  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (make_temp_vec): Remove.\n+\t(make_scratch_vec): Likewise.\n+\t* call.c (add_function_candidate): Use make_tree_vec.\n+\t(add_conv_candidate): Likewise.\n+\t(build_builtin_candidate): Likewise.\n+\t(add_template_candidate_real): Likewise.\n+\t* class.c (resolve_address_of_overloaded_function): Likewise.\n+\t* decl.c (start_function): Don't fool with the momentary obstack.\n+\t(finish_function): Likewise.\n+\t* init.c (expand_direct_vtbls_init): Likewise.\n+\t(begin_init_stmts): Likewise.\n+\t(finish_init_stmts): Likewise.\n+\t* pt.c (add_to_template_args): Use make_tree_vec.\n+\t(check_explicit_specialization): Likewise.\n+\t(coerce_template_parms): Likewise.\n+\t(lookup_template_class): Don't fool with the momentary obstack.\n+\t(instantiate_class_template): Likewise.\n+\t(tsubst_template_arg_vector): Use make_tree_vec.\n+\t(tsubst_aggr_type): Don't fool with the momentary obstack.\n+\t(tsubst_decl): Likewise.  Use make_tree_vec.\n+\t(try_one_overload): Likewise.\n+\t(try_class_unification):  Don't fool with the momentary obstack.\n+\t(get_bindings_real): Use make_tree_vec.\n+\t(set_mangled_name_for_template_decl): Likewise.\n+\t* rtti.c (synthesize_tinfo_fn): Don't fool with the momentary obstack.\n+\t* semantics.c (finish_expr_stmt): Likewise.\n+\t(finish_do_stmt): Likewise.\n+\t(finish_for_expr): Likewise.\n+\t(finish_switch_cond): Likewise.\n+\t(do_pushlevel): Likewise.\n+\t(do_poplevel): Likewise.\n+\t* tree.c (make_temp_vec): Remove.\n+\t\n \t* dump.c (dequeue_and_dump): Dump HANDLERs and SAVE_EXPRs.  Dump\n \tCLEANUP_P for a TRY_BLOCK.\n \t* ir.texi: Document SAVE_EXPR."}, {"sha": "38ce371d93a59a5d3d9ef864b850f8058de4fbe3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -1255,7 +1255,7 @@ add_function_candidate (candidates, fn, arglist, flags)\n     }\n \n   len = list_length (arglist);\n-  convs = make_scratch_vec (len);\n+  convs = make_tree_vec (len);\n \n   /* 13.3.2 - Viable functions [over.match.viable]\n      First, to be a viable function, a candidate function shall have enough\n@@ -1372,7 +1372,7 @@ add_conv_candidate (candidates, fn, obj, arglist)\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (totype));\n   int i, len = list_length (arglist) + 1;\n-  tree convs = make_scratch_vec (len);\n+  tree convs = make_tree_vec (len);\n   tree parmnode = parmlist;\n   tree argnode = arglist;\n   int viable = 1;\n@@ -1444,7 +1444,7 @@ build_builtin_candidate (candidates, fnname, type1, type2,\n   types[0] = type1;\n   types[1] = type2;\n \n-  convs = make_scratch_vec (args[2] ? 3 : (args[1] ? 2 : 1));\n+  convs = make_tree_vec (args[2] ? 3 : (args[1] ? 2 : 1));\n \n   for (i = 0; i < 2; ++i)\n     {\n@@ -2097,7 +2097,7 @@ add_template_candidate_real (candidates, tmpl, explicit_targs,\n      unification_kind_t strict;\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n-  tree targs = make_scratch_vec (ntparms);\n+  tree targs = make_tree_vec (ntparms);\n   struct z_candidate *cand;\n   int i;\n   tree fn;"}, {"sha": "612e0acdef82971d7ed3eb1727ed6be831838c88", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -4850,7 +4850,7 @@ resolve_address_of_overloaded_function (target_type,\n \t    continue;\n \n \t  /* Try to do argument deduction.  */\n-\t  targs = make_scratch_vec (DECL_NTPARMS (fn));\n+\t  targs = make_tree_vec (DECL_NTPARMS (fn));\n \t  if (fn_type_unification (fn, explicit_targs, targs,\n \t\t\t\t   target_arg_types, NULL_TREE,\n \t\t\t\t   DEDUCE_EXACT) != 0)"}, {"sha": "7d712dcbf889048e6230144807171886e2665adb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -3969,7 +3969,6 @@ extern tree hack_decl_function_context \t\tPROTO((tree));\n extern tree decl_namespace_context \t\tPROTO((tree));\n extern tree lvalue_type\t\t\t\tPROTO((tree));\n extern tree error_type\t\t\t\tPROTO((tree));\n-extern tree make_temp_vec\t\t\tPROTO((int));\n extern tree build_ptr_wrapper\t\t\tPROTO((void *));\n extern tree build_expr_ptr_wrapper\t\tPROTO((void *));\n extern tree build_int_wrapper\t\t\tPROTO((int));\n@@ -3995,7 +3994,6 @@ extern tree cp_build_qualified_type_real        PROTO((tree, int, int));\n \n #define scratchalloc expralloc\n #define build_scratch_list build_expr_list\n-#define make_scratch_vec make_temp_vec\n #define push_scratch_obstack push_expression_obstack\n \n /* in typeck.c */"}, {"sha": "72818cb69a23943a59579dc5926ae3154637ea78", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -13093,10 +13093,6 @@ start_function (declspecs, declarator, attrs, flags)\n   if (! hack_decl_function_context (decl1))\n     temporary_allocation ();\n   \n-  /* Make sure that we always have a momntary obstack while we're in a\n-     function body.  */\n-  push_momentary ();\n-\n   ++function_depth;\n \n   if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl1))\n@@ -13676,9 +13672,6 @@ finish_function (lineno, flags)\n      to the FUNCTION_DECL node itself.  */\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n-  /* Undo the call to push_momentary in start_function.  */\n-  pop_momentary ();\n-\n   /* Save away current state, if appropriate.  */\n   if (!expanding_p && !processing_template_decl)\n     save_function_data (fndecl);"}, {"sha": "d1af4d786559d4bf3d0a05e5f6e6fb2edcbf9eed", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -105,7 +105,6 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = real_binfos ? TREE_VEC_LENGTH (real_binfos) : 0;\n \n-  push_momentary ();\n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree real_base_binfo = TREE_VEC_ELT (real_binfos, i);\n@@ -127,7 +126,6 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n       tree base_ptr = convert_pointer_to_real (binfo, addr);\n       expand_virtual_init (real_binfo, base_ptr);\n     }\n-  pop_momentary ();\n }\n \f\n /* 348 - 351 */\n@@ -975,7 +973,6 @@ begin_init_stmts (stmt_expr_p, compound_stmt_p)\n      tree *stmt_expr_p;\n      tree *compound_stmt_p;\n {\n-  push_momentary ();\n   *stmt_expr_p = begin_stmt_expr ();\n   *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/1);\n }\n@@ -988,7 +985,6 @@ finish_init_stmts (stmt_expr, compound_stmt)\n      tree stmt_expr;\n      tree compound_stmt;\n {\n-  pop_momentary ();\n   finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n   stmt_expr = finish_stmt_expr (stmt_expr);\n "}, {"sha": "9427314ffa1e478d3084e46237ac08866bbbe3d8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 52, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -481,7 +481,7 @@ add_to_template_args (args, extra_args)\n   int j;\n \n   extra_depth = TMPL_ARGS_DEPTH (extra_args);\n-  new_args = make_temp_vec (TMPL_ARGS_DEPTH (args) + extra_depth);\n+  new_args = make_tree_vec (TMPL_ARGS_DEPTH (args) + extra_depth);\n \n   for (i = 1; i <= TMPL_ARGS_DEPTH (args); ++i)\n     SET_TMPL_ARGS_LEVEL (new_args, i, TMPL_ARGS_LEVEL (args, i));\n@@ -1463,7 +1463,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t  int i;\n \t\t  tree new_targs;\n \n-\t\t  new_targs = make_temp_vec (parm_depth);\n+\t\t  new_targs = make_tree_vec (parm_depth);\n \t\t  for (i = arg_depth - parm_depth; i < arg_depth; ++i)\n \t\t    TREE_VEC_ELT (new_targs, i - (arg_depth - parm_depth))\n \t\t      = TREE_VEC_ELT (targs, i);\n@@ -3328,7 +3328,7 @@ coerce_template_parms (parms, args, in_decl,\n       return error_mark_node;\n     }\n \n-  new_inner_args = make_temp_vec (nparms);\n+  new_inner_args = make_tree_vec (nparms);\n   new_args = add_outermost_template_args (args, new_inner_args);\n   for (i = 0; i < nparms; i++)\n     {\n@@ -3753,10 +3753,6 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       parm_depth = TMPL_PARMS_DEPTH (parmlist);\n       arg_depth = TMPL_ARGS_DEPTH (arglist);\n \n-      /* We build up the coerced arguments and such on the\n-\t momentary_obstack.  */\n-      push_momentary ();\n-\n       if (arg_depth == 1 && parm_depth > 1)\n \t{\n \t  /* We've been given an incomplete set of template arguments.\n@@ -3793,7 +3789,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t  int i;\n \t  int saved_depth = TMPL_ARGS_DEPTH (arglist);\n \n-\t  tree bound_args = make_temp_vec (parm_depth);\n+\t  tree bound_args = make_tree_vec (parm_depth);\n \t  \n \t  for (i = saved_depth,\n \t\t t = DECL_TEMPLATE_PARMS (template); \n@@ -3874,10 +3870,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t}\n \n       if (found)\n-\t{\n-\t  pop_momentary ();\n-\t  return found;\n-\t}\n+\treturn found;\n \n       /* This type is a \"partial instantiation\" if any of the template\n \t arguments still inolve template parameters.  Note that we set\n@@ -3889,7 +3882,6 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t  && !PRIMARY_TEMPLATE_P (template)\n \t  && TREE_CODE (CP_DECL_CONTEXT (template)) == NAMESPACE_DECL)\n \t{\n-\t  pop_momentary ();\n \t  found = xref_tag_from_type (TREE_TYPE (template),\n \t\t\t\t      DECL_NAME (template),\n \t\t\t\t      /*globalize=*/1);\n@@ -4009,9 +4001,6 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \n       /* We're done with the permanent obstack, now.  */\n       pop_obstacks ();\n-      /* We're also done with the momentary allocation we started\n-\t above.  */\n-      pop_momentary ();\n \n       /* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO\n \t is set up.  */\n@@ -4754,12 +4743,6 @@ instantiate_class_template (type)\n   if (TYPE_BEING_DEFINED (type) || TYPE_SIZE (type))\n     return type;\n \n-  /* We want to allocate temporary vectors of template arguments and\n-     template argument expressions on the momentary obstack, not on\n-     the expression obstack.  Otherwise, all the space allocated in\n-     argument coercion and such is simply lost.  */\n-  push_momentary ();\n-\n   /* Figure out which template is being instantiated.  */\n   template = most_general_template (CLASSTYPE_TI_TEMPLATE (type));\n   my_friendly_assert (TREE_CODE (template) == TEMPLATE_DECL, 279);\n@@ -4787,7 +4770,7 @@ instantiate_class_template (type)\n \n        Now, the `S<U>' in `f<int>' is the specialization, not an\n        instantiation of the original template.  */\n-    goto end;\n+    return type;\n \n   /* Determine what specialization of the original template to\n      instantiate.  */\n@@ -4822,8 +4805,7 @@ instantiate_class_template (type)\n \t\t}\n \t    }\n \t  TYPE_BEING_DEFINED (type) = 1;\n-\t  type = error_mark_node;\n-\t  goto end;\n+\t  return error_mark_node;\n \t}\n     }\n \n@@ -4835,7 +4817,7 @@ instantiate_class_template (type)\n   /* If the template we're instantiating is incomplete, then clearly\n      there's nothing we can do.  */\n   if (TYPE_SIZE (pattern) == NULL_TREE)\n-    goto end;\n+    return type;\n \n   /* If this is a partial instantiation, don't tsubst anything.  We will\n      only use this type for implicit typename, so the actual contents don't\n@@ -4851,12 +4833,12 @@ instantiate_class_template (type)\n       /* Pretend that the type is complete, so that we will look\n \t inside it during name lookup and such.  */\n       TYPE_SIZE (type) = integer_zero_node;\n-      goto end;\n+      return type;\n     }\n \n   /* If we've recursively instantiated too many templates, stop.  */\n   if (! push_tinst_level (type))\n-    goto end;\n+    return type;\n \n   /* Now we're really doing the instantiation.  Mark the type as in\n      the process of being defined.  */\n@@ -5194,9 +5176,6 @@ instantiate_class_template (type)\n   pop_from_top_level ();\n   pop_tinst_level ();\n \n- end:\n-  pop_momentary ();\n-\n   return type;\n }\n \n@@ -5284,7 +5263,7 @@ tsubst_template_arg_vector (t, args, complain)\n   if (!need_new)\n     return t;\n   \n-  t = make_temp_vec (len);\n+  t = make_tree_vec (len);\n   for (i = 0; i < len; i++)\n     TREE_VEC_ELT (t, i) = elts[i];\n   \n@@ -5394,13 +5373,11 @@ tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n \t     and supposing that we are instantiating f<int, double>,\n \t     then our ARGS will be {int, double}, but, when looking up\n \t     S we only want {double}.  */\n-\t  push_momentary ();\n \t  argvec = tsubst_template_arg_vector (TYPE_TI_ARGS (t), args,\n \t\t\t\t\t       complain);\n \n   \t  r = lookup_template_class (t, argvec, in_decl, context,\n \t\t\t\t     entering_scope);\n-\t  pop_momentary ();\n \n \t  return cp_build_qualified_type_real (r, TYPE_QUALS (t),\n \t\t\t\t\t       complain);\n@@ -5517,7 +5494,6 @@ tsubst_decl (t, args, type, in_decl)\n \t      : DECL_TI_ARGS (DECL_RESULT (t));\n \t    tree full_args;\n \t    \n-\t    push_momentary ();\n \t    full_args = tsubst_template_arg_vector (tmpl_args, args,\n \t\t\t\t\t\t    /*complain=*/1);\n \n@@ -5527,7 +5503,6 @@ tsubst_decl (t, args, type, in_decl)\n \t    my_friendly_assert (full_args != tmpl_args, 0);\n \n \t    spec = retrieve_specialization (t, full_args);\n-\t    pop_momentary ();\n \t    if (spec != NULL_TREE)\n \t      {\n \t\tr = spec;\n@@ -5676,10 +5651,6 @@ tsubst_decl (t, args, type, in_decl)\n \t  {\n \t    tree spec;\n \n-\t    /* Allocate template arguments on the momentary obstack,\n-\t       in case we don't need to keep them.  */\n-\t    push_momentary ();\n-\n \t    /* Calculate the most general template of which R is a\n \t       specialization, and the complete set of arguments used to\n \t       specialize R.  */\n@@ -5695,12 +5666,9 @@ tsubst_decl (t, args, type, in_decl)\n \t    if (spec)\n \t      {\n \t\tr = spec;\n-\t\tpop_momentary ();\n \t\tbreak;\n \t      }\n \n-\t    pop_momentary ();\n-\n \t    /* Here, we deal with the peculiar case:\n \n \t\t template <class T> struct S { \n@@ -5733,7 +5701,7 @@ tsubst_decl (t, args, type, in_decl)\n \t\t  {\n \t\t    int i;\n \n-\t\t    args = make_temp_vec (parms_depth);\n+\t\t    args = make_tree_vec (parms_depth);\n \t\t    for (i = 0; i < parms_depth; ++i)\n \t\t      TREE_VEC_ELT (args, i) = \n \t\t\tTREE_VEC_ELT (args, i + (args_depth - parms_depth));\n@@ -8020,7 +7988,7 @@ try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n      try to deduce a template parameter for the same argument, even though\n      there isn't really a conflict.  */\n   nargs = TREE_VEC_LENGTH (targs);\n-  tempargs = make_scratch_vec (nargs);\n+  tempargs = make_tree_vec (nargs);\n \n   if (unify (tparms, tempargs, parm, arg, sub_strict) != 0)\n     return 0;\n@@ -8106,11 +8074,9 @@ try_class_unification (tparms, targs, parm, arg)\n      because there are two ways to unify base classes of S<0, 1, 2>\n      with S<I, I, I>.  If we kept the already deduced knowledge, we\n      would reject the possibility I=1.  */\n-  push_momentary ();\n-  copy_of_targs = make_temp_vec (TREE_VEC_LENGTH (targs));\n+  copy_of_targs = make_tree_vec (TREE_VEC_LENGTH (targs));\n   i = unify (tparms, copy_of_targs, CLASSTYPE_TI_ARGS (parm),\n \t     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE);\n-  pop_momentary ();\n   \n   /* If unification failed, we're done.  */\n   if (i != 0)\n@@ -8834,7 +8800,7 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n      int check_rettype;\n {\n   int ntparms = DECL_NTPARMS (fn);\n-  tree targs = make_scratch_vec (ntparms);\n+  tree targs = make_tree_vec (ntparms);\n   tree decl_type;\n   tree decl_arg_types;\n   int i;\n@@ -8934,7 +8900,7 @@ get_class_bindings (tparms, parms, args)\n      tree tparms, parms, args;\n {\n   int i, ntparms = TREE_VEC_LENGTH (tparms);\n-  tree vec = make_temp_vec (ntparms);\n+  tree vec = make_tree_vec (ntparms);\n \n   args = innermost_args (args);\n \n@@ -9969,13 +9935,13 @@ set_mangled_name_for_template_decl (decl)\n \n       /* Replace the innermost level of the TARGS with NULL_TREEs to\n \t let tsubst know not to subsitute for those parameters.  */\n-      partial_args = make_temp_vec (TREE_VEC_LENGTH (targs));\n+      partial_args = make_tree_vec (TREE_VEC_LENGTH (targs));\n       for (i = 1; i < TMPL_ARGS_DEPTH (targs); ++i)\n \tSET_TMPL_ARGS_LEVEL (partial_args, i,\n \t\t\t     TMPL_ARGS_LEVEL (targs, i));\n       SET_TMPL_ARGS_LEVEL (partial_args,\n \t\t\t   TMPL_ARGS_DEPTH (targs),\n-\t\t\t   make_temp_vec (DECL_NTPARMS (tmpl)));\n+\t\t\t   make_tree_vec (DECL_NTPARMS (tmpl)));\n \n       /* Now, do the (partial) substitution to figure out the\n \t appropriate function type.  */"}, {"sha": "2580eaa63a6b36dd45211e2e15b6704f85c2f19f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -1137,11 +1137,8 @@ synthesize_tinfo_fn (fndecl)\n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n \n   /* For convenience, we save away the address of the static\n-     variable.  Since we will process expression-statements between\n-     here and the end of the function, we must call push_momentary to\n-     keep ADDR from being overwritten.  */\n+     variable.  */\n   addr = decay_conversion (tdecl);\n-  push_momentary ();\n \n   /* If the first word of the array (the vtable) is non-zero, we've already\n      initialized the object, so don't do it again.  */\n@@ -1193,8 +1190,6 @@ synthesize_tinfo_fn (fndecl)\n   tmp = cp_convert (build_pointer_type (type_info_type_node), addr);\n   tmp = build_indirect_ref (tmp, 0);\n   finish_return_stmt (tmp);\n-  /* Undo the call to push_momentary above.  */\n-  pop_momentary ();\n   /* Finish the function body.  */\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n   expand_body (finish_function (lineno, 0));"}, {"sha": "de6cd08015c904edc46442e91d2219dc679f5bdf", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -144,10 +144,7 @@ finish_expr_stmt (expr)\n \t  cplus_expand_expr_stmt (expr);\n \n \t  if (stmts_are_full_exprs_p)\n-\t    {\n-\t      expand_end_target_temps ();\n-\t      clear_momentary ();\n-\t    }\n+\t    expand_end_target_temps ();\n \t}\n     }\n \n@@ -368,7 +365,6 @@ finish_do_stmt (cond, do_stmt)\n       expand_end_loop ();\n     }\n \n-  clear_momentary ();\n   finish_stmt ();\n }\n \n@@ -503,10 +499,6 @@ finish_for_expr (expr, for_stmt)\n {\n   if (building_stmt_tree ())\n     FOR_EXPR (for_stmt) = expr;\n-\n-  /* Don't let the tree nodes for EXPR be discarded\n-     by clear_momentary during the parsing of the next stmt.  */\n-  push_momentary ();\n }\n \n /* Finish the body of a for-statement, which may be given by\n@@ -532,8 +524,6 @@ finish_for_stmt (expr, for_stmt)\n       expand_end_loop ();\n     }\n \n-  pop_momentary ();\n-\n   if (flag_new_for_scope > 0)\n     do_poplevel ();\n \n@@ -605,10 +595,6 @@ finish_switch_cond (cond, switch_stmt)\n     c_expand_start_case (boolean_false_node);\n \n   push_switch ();\n-\n-  /* Don't let the tree nodes for COND be discarded by\n-     clear_momentary during the parsing of the next stmt.  */\n-  push_momentary ();\n }\n \n /* Finish the body of a switch-statement, which may be given by\n@@ -623,7 +609,6 @@ finish_switch_stmt (cond, switch_stmt)\n     RECHAIN_STMTS (switch_stmt, SWITCH_BODY (switch_stmt));\n   else\n     expand_end_case (cond);\n-  pop_momentary ();\n   pop_switch (); \n   do_poplevel ();\n   finish_stmt ();\n@@ -1295,7 +1280,6 @@ do_pushlevel ()\n       emit_line_note (input_filename, lineno);\n       clear_last_expr ();\n     }\n-  push_momentary ();\n   if (stmts_are_full_exprs_p)\n     {\n       pushlevel (0);\n@@ -1333,7 +1317,6 @@ do_poplevel ()\n \n       t = poplevel (kept_level_p (), 1, 0);\n     }\n-  pop_momentary ();\n   return t;\n }\n "}, {"sha": "0dbc539021adef09a10a716a310048de0942de5b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31c0a32f5285f585d3dd53901f304b864ebfe29/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f31c0a32f5285f585d3dd53901f304b864ebfe29", "patch": "@@ -2517,20 +2517,6 @@ cp_tree_equal (t1, t2)\n   return -1;\n }\n \n-/* Similar to make_tree_vec, but build on the momentary_obstack.\n-   Thus, these vectors are really and truly temporary.  */\n-\n-tree\n-make_temp_vec (len)\n-     int len;\n-{\n-  register tree node;\n-  push_expression_obstack ();\n-  node = make_tree_vec (len);\n-  pop_obstacks ();\n-  return node;\n-}\n-\n /* Build a wrapper around some pointer PTR so we can use it as a tree.  */\n \n tree"}]}