{"sha": "a9895094b3e88b913cee8a9115ffae8fd89e8c55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk4OTUwOTRiM2U4OGI5MTNjZWU4YTkxMTVmZmFlOGZkODllOGM1NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T14:06:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T14:06:56Z"}, "message": "[multiple changes]\n\n2013-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb (Record_Possible_Body_Reference): Fix test for\n\tbeing in body.\n\t(Add_Constituent): Merged into Check_Refined_Global_Item.\n\t(Check_Matching_Constituent): A constituent that has the proper Part_Of\n\toption and comes from a private child or a sibling is now collected.\n\t(Check_Matching_Modes): Merged into Check_Refined_Global_Item.\n\t(Check_Refined_Global_Item): Code cleanup.\n\t(Collect_Constituent): New routine.\n\t(Inconsistent_Mode_Error): Moved out from Check_Matching_Modes.\n\n2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Check_Current_Instance, Process): Add RM reference\n\tand mention immutably limited types, when the current instance\n\tis illegal in Ada 2012.\n\n2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_warn.adb (Check_Unused_Withs): If the main unit is a\n\tsubunit, apply the check to the units mentioned in its context\n\tonly. This provides additional warnings on with_clauses that\n\tare superfluous.\n\n2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Declarations): Emit an\n\terror message concerning state refinement when the spec defines at\n\tleast one non-null abstract state and the body's SPARK mode is On.\n\t(Requires_State_Refinement): New routine.\n\n2013-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch7.ads: Comment fixes.\n\n2013-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch7.adb (Analyze_Package_Specification): Remove circuit\n\tfor ensuring that a package spec requires a body for some other\n\treason than that it contains the declaration of an abstract state.\n\n2013-10-17  Tristan Gingold  <gingold@adacore.com>\n\n\t* exp_ch11.adb (Expand_N_Raise_Expression): Fix call of\n\tPossible_Local_Raise.\n\n2013-10-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_pakd.adb (Expand_Bit_Packed_Element_Set): Unchecked\n\tconversion of Or_Rhs to Etype of New_Rhs is required only when\n\tthe latter is the result of a byte swap operation.\n\n2013-10-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.adb (Build_To_Any_Function): For a type with opaque\n\trepresentation that is not transmitted as an unconstrained value,\n\tuse 'Write, not 'Output, to generate the opaque representation.\n\n2013-10-17  Yannick Moy  <moy@adacore.com>\n\n\t* sem_res.adb (Resolve_Short_Circuit): Only\n\tgenerate expression-with-action when full expansion is set.\n\n2013-10-17  Yannick Moy  <moy@adacore.com>\n\n\t* debug.adb Remove obsolete comment.\n\n2013-10-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb (Process_Transient_Object.Find_Enclosing_Contexts):\n\tAvoid late insertion when expanding an expression with action\n\tnested within a transient block; Do not inconditionally generate\n\ta finalization call if the generated object is from a specific\n\tbranch of a conditional expression.\n\n2013-10-17  Pascal Obry  <obry@adacore.com>\n\n\t* g-arrspl.adb: Ensure Finalize call is idempotent.\n\t* g-arrspl.adb (Finalize): Makes the call idempotent.\n\nFrom-SVN: r203767", "tree": {"sha": "7087351f544680ff168ffcf19f42858a2963c735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7087351f544680ff168ffcf19f42858a2963c735"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9895094b3e88b913cee8a9115ffae8fd89e8c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9895094b3e88b913cee8a9115ffae8fd89e8c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9895094b3e88b913cee8a9115ffae8fd89e8c55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9895094b3e88b913cee8a9115ffae8fd89e8c55/comments", "author": null, "committer": null, "parents": [{"sha": "72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d1b27a2ae4676e5604c6200b07bcbfb6b5ad31"}], "stats": {"total": 460, "additions": 300, "deletions": 160}, "files": [{"sha": "0bcbc7ca1d8344db380fdc332d4b7a25f6c1417c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -1,3 +1,84 @@\n+2013-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb (Record_Possible_Body_Reference): Fix test for\n+\tbeing in body.\n+\t(Add_Constituent): Merged into Check_Refined_Global_Item.\n+\t(Check_Matching_Constituent): A constituent that has the proper Part_Of\n+\toption and comes from a private child or a sibling is now collected.\n+\t(Check_Matching_Modes): Merged into Check_Refined_Global_Item.\n+\t(Check_Refined_Global_Item): Code cleanup.\n+\t(Collect_Constituent): New routine.\n+\t(Inconsistent_Mode_Error): Moved out from Check_Matching_Modes.\n+\n+2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Check_Current_Instance, Process): Add RM reference\n+\tand mention immutably limited types, when the current instance\n+\tis illegal in Ada 2012.\n+\n+2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_warn.adb (Check_Unused_Withs): If the main unit is a\n+\tsubunit, apply the check to the units mentioned in its context\n+\tonly. This provides additional warnings on with_clauses that\n+\tare superfluous.\n+\n+2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Declarations): Emit an\n+\terror message concerning state refinement when the spec defines at\n+\tleast one non-null abstract state and the body's SPARK mode is On.\n+\t(Requires_State_Refinement): New routine.\n+\n+2013-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch7.ads: Comment fixes.\n+\n+2013-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch7.adb (Analyze_Package_Specification): Remove circuit\n+\tfor ensuring that a package spec requires a body for some other\n+\treason than that it contains the declaration of an abstract state.\n+\n+2013-10-17  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* exp_ch11.adb (Expand_N_Raise_Expression): Fix call of\n+\tPossible_Local_Raise.\n+\n+2013-10-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_pakd.adb (Expand_Bit_Packed_Element_Set): Unchecked\n+\tconversion of Or_Rhs to Etype of New_Rhs is required only when\n+\tthe latter is the result of a byte swap operation.\n+\n+2013-10-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_dist.adb (Build_To_Any_Function): For a type with opaque\n+\trepresentation that is not transmitted as an unconstrained value,\n+\tuse 'Write, not 'Output, to generate the opaque representation.\n+\n+2013-10-17  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Short_Circuit): Only\n+\tgenerate expression-with-action when full expansion is set.\n+\n+2013-10-17  Yannick Moy  <moy@adacore.com>\n+\n+\t* debug.adb Remove obsolete comment.\n+\n+2013-10-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb (Process_Transient_Object.Find_Enclosing_Contexts):\n+\tAvoid late insertion when expanding an expression with action\n+\tnested within a transient block; Do not inconditionally generate\n+\ta finalization call if the generated object is from a specific\n+\tbranch of a conditional expression.\n+\n+2013-10-17  Pascal Obry  <obry@adacore.com>\n+\n+\t* g-arrspl.adb: Ensure Finalize call is idempotent.\n+\t* g-arrspl.adb (Finalize): Makes the call idempotent.\n+\n 2013-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Is_Matching_Input): Account"}, {"sha": "8be585c7725b0cc905e576e7e765b78691f365ec", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -1450,7 +1450,7 @@ package body Exp_Ch11 is\n       RCE : Node_Id;\n \n    begin\n-      Possible_Local_Raise (N, Name (N));\n+      Possible_Local_Raise (N, Entity (Name (N)));\n \n       --  Later we must teach the back end/gigi how to deal with this, but\n       --  for now we will assume the type is Standard_Boolean and transform"}, {"sha": "068a950ba116ab71f896779106b424a5c440a7b0", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -9838,7 +9838,8 @@ package body Exp_Dist is\n                --  Constrained and unconstrained array types\n \n                declare\n-                  Constrained : constant Boolean := Is_Constrained (Typ);\n+                  Constrained : constant Boolean :=\n+                    not Transmit_As_Unconstrained (Typ);\n \n                   procedure TA_Ary_Add_Process_Element\n                     (Stmts   : List_Id;\n@@ -9957,16 +9958,29 @@ package body Exp_Dist is\n \n                   --  Generate:\n                   --    T'Output (Strm'Access, E);\n+                  --  or\n+                  --    T'Write (Strm'Access, E);\n+                  --  depending on whether to transmit as unconstrained\n \n-                  Append_To (Stms,\n-                      Make_Attribute_Reference (Loc,\n-                        Prefix         => New_Occurrence_Of (Typ, Loc),\n-                        Attribute_Name => Name_Output,\n-                        Expressions    => New_List (\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix         => New_Occurrence_Of (Strm, Loc),\n-                            Attribute_Name => Name_Access),\n-                          New_Occurrence_Of (Expr_Parameter, Loc))));\n+                  declare\n+                     Attr_Name : Name_Id;\n+                  begin\n+                     if Transmit_As_Unconstrained (Typ) then\n+                        Attr_Name := Name_Output;\n+                     else\n+                        Attr_Name := Name_Write;\n+                     end if;\n+\n+                     Append_To (Stms,\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix         => New_Occurrence_Of (Typ, Loc),\n+                           Attribute_Name => Attr_Name,\n+                           Expressions    => New_List (\n+                             Make_Attribute_Reference (Loc,\n+                               Prefix         => New_Occurrence_Of (Strm, Loc),\n+                               Attribute_Name => Name_Access),\n+                             New_Occurrence_Of (Expr_Parameter, Loc))));\n+                  end;\n \n                   --  Generate:\n                   --    BS_To_Any (Strm, A);"}, {"sha": "0baab98d9cd0df2d9d676750cac1c7d77c6fa2ca", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -1703,11 +1703,17 @@ package body Exp_Pakd is\n                   Set_Etype (New_Rhs, Etype (Left_Opnd (New_Rhs)));\n                end if;\n \n+               --  If New_Rhs has been byte swapped, need to convert Or_Rhs\n+               --  to the return type of the byte swapping function now.\n+\n+               if Require_Byte_Swapping then\n+                  Or_Rhs := Unchecked_Convert_To (Etype (New_Rhs), Or_Rhs);\n+               end if;\n+\n                New_Rhs :=\n                  Make_Op_Or (Loc,\n                    Left_Opnd  => New_Rhs,\n-                   Right_Opnd => Unchecked_Convert_To\n-                                   (Etype (New_Rhs), Or_Rhs));\n+                   Right_Opnd => Or_Rhs);\n             end;\n          end if;\n "}, {"sha": "f6c60678143c85dcfcd91ea1ee3aacfb55a61d8d", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -1872,8 +1872,16 @@ package body Freeze is\n                     and then Is_Type (Entity (Prefix (N)))\n                     and then Entity (Prefix (N)) = E\n                   then\n-                     Error_Msg_N\n-                       (\"current instance must be a limited type\", Prefix (N));\n+                     if Ada_Version < Ada_2012 then\n+                        Error_Msg_N\n+                          (\"current instance must be a limited type\",\n+                             Prefix (N));\n+                     else\n+                        Error_Msg_N\n+                          (\"current instance must be an immutably limited \" &\n+                            \"type (RM-2012, 7.5 (8.1/3))\",\n+                             Prefix (N));\n+                     end if;\n                      return Abandon;\n                   else\n                      return OK;"}, {"sha": "01d6dddd1024c76b41c954b1867be718b3f9cbf7", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 83, "deletions": 3, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -2071,6 +2071,12 @@ package body Sem_Ch3 is\n       --  If the states have visible refinement, remove the visibility of each\n       --  constituent at the end of the package body declarations.\n \n+      function Requires_State_Refinement\n+        (Spec_Id : Entity_Id;\n+         Body_Id : Entity_Id) return Boolean;\n+      --  Determine whether a package denoted by its spec and body entities\n+      --  requires refinement of abstract states.\n+\n       -----------------\n       -- Adjust_Decl --\n       -----------------\n@@ -2100,6 +2106,82 @@ package body Sem_Ch3 is\n          end if;\n       end Remove_Visible_Refinements;\n \n+      -------------------------------\n+      -- Requires_State_Refinement --\n+      -------------------------------\n+\n+      function Requires_State_Refinement\n+        (Spec_Id : Entity_Id;\n+         Body_Id : Entity_Id) return Boolean\n+      is\n+         function Mode_Is_Off (Prag : Node_Id) return Boolean;\n+         --  Given pragma SPARK_Mode, determine whether the mode is Off\n+\n+         -----------------\n+         -- Mode_Is_Off --\n+         -----------------\n+\n+         function Mode_Is_Off (Prag : Node_Id) return Boolean is\n+            Mode : Node_Id;\n+\n+         begin\n+            --  The default SPARK mode is On\n+\n+            if No (Prag) then\n+               return False;\n+            end if;\n+\n+            Mode :=\n+              Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n+\n+            --  Then the pragma lacks an argument, the default mode is On\n+\n+            if No (Mode) then\n+               return False;\n+            else\n+               return Chars (Mode) = Name_Off;\n+            end if;\n+         end Mode_Is_Off;\n+\n+      --  Start of processing for Requires_State_Refinement\n+\n+      begin\n+         --  A package that does not define at least one abstract state cannot\n+         --  possibly require refinement.\n+\n+         if No (Abstract_States (Spec_Id)) then\n+            return False;\n+\n+         --  The package instroduces a single null state which does not merit\n+         --  refinement.\n+\n+         elsif Has_Null_Abstract_State (Spec_Id) then\n+            return False;\n+\n+         --  Check whether the package body is subject to pragma SPARK_Mode. If\n+         --  it is and the mode is Off, the package body is considered to be in\n+         --  regular Ada and does not require refinement.\n+\n+         elsif Mode_Is_Off (SPARK_Mode_Pragmas (Body_Id)) then\n+            return False;\n+\n+         --  The body's SPARK_Mode may be inherited from a similar pragma that\n+         --  appears in the private declarations of the spec. The pragma we are\n+         --  interested appears as the second entry in SPARK_Mode_Pragmas.\n+\n+         elsif Present (SPARK_Mode_Pragmas (Spec_Id))\n+           and then Mode_Is_Off (Next_Pragma (SPARK_Mode_Pragmas (Spec_Id)))\n+         then\n+            return False;\n+\n+         --  The spec defines at least one abstract state and the body has no\n+         --  way of circumventing the refinement.\n+\n+         else\n+            return True;\n+         end if;\n+      end Requires_State_Refinement;\n+\n       --  Local variables\n \n       Body_Id     : Entity_Id;\n@@ -2264,9 +2346,7 @@ package body Sem_Ch3 is\n             --  State refinement is required when the package declaration has\n             --  abstract states. Null states are not considered.\n \n-            elsif Present (Abstract_States (Spec_Id))\n-              and then not Has_Null_Abstract_State (Spec_Id)\n-            then\n+            elsif Requires_State_Refinement (Spec_Id, Body_Id) then\n                Error_Msg_NE\n                  (\"package & requires state refinement\", Context, Spec_Id);\n             end if;"}, {"sha": "76875b27afce0033d4250670a7f70907a53104e9", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -1493,34 +1493,6 @@ package body Sem_Ch7 is\n \n       Check_One_Tagged_Type_Or_Extension_At_Most;\n \n-      --  Issue an error if a package that is a library unit does not require a\n-      --  body, and we have a non-null abstract state (SPARK LRM 7.1.5(4)).\n-\n-      if not Unit_Requires_Body (Id, Ignore_Abstract_State => True)\n-        and then Present (Abstract_States (Id))\n-\n-        --  We use Scope_Depth of 1 to identify library units, which seems a\n-        --  bit ugly, but there doesn't seem to be an easier way.\n-\n-        and then Scope_Depth (Id) = 1\n-\n-        --  A null abstract state always appears as the sole element of the\n-        --  state list.\n-\n-        and then not Is_Null_State (Node (First_Elmt (Abstract_States (Id))))\n-      then\n-         declare\n-            P : constant Node_Id := Get_Pragma (Id, Pragma_Abstract_State);\n-         begin\n-            Error_Msg_NE\n-              (\"package & specifies a non-null abstract state\", P, Id);\n-            Error_Msg_N\n-              (\"\\but package does not otherwise require a body\", P);\n-            Error_Msg_N\n-              (\"\\pragma Elaborate_Body is required in this case\", P);\n-         end;\n-      end if;\n-\n       --  If switch set, output information on why body required\n \n       if List_Body_Required_Info"}, {"sha": "783fc57efa0ac429cc79997f08116b0b27245cf8", "filename": "gcc/ada/sem_ch7.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -60,7 +60,10 @@ package Sem_Ch7 is\n    --  Ignore_Abstract_State is set True, then the test for a non-null abstract\n    --  state (which normally requires a body) is not carried out. This allows\n    --  the use of this routine to tell if there is some other reason that a\n-   --  body is required (as is required for analyzing Abstract_State).\n+   --  body is required (as is required for analyzing Abstract_State). This\n+   --  is not currently used, but may be useful in future if we implement a\n+   --  compatibility mode which warns about possible incompatibilities if a\n+   --  SPARK 2014 program is compiled with a SPARK-unaware compiler.\n \n    procedure May_Need_Implicit_Body (E : Entity_Id);\n    --  If a package declaration contains tasks or RACWs and does not require"}, {"sha": "738ab266805ffd2f7a674778c955f6475b52a71d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 81, "deletions": 108, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -9452,7 +9452,8 @@ package body Sem_Prag is\n \n                      Analyze (Par_State);\n \n-                     --  Part_Of specified a legal state\n+                     --  Part_Of specified a legal state, this automatically\n+                     --  makes the state a constituent.\n \n                      if Is_Entity_Name (Par_State)\n                        and then Present (Entity (Par_State))\n@@ -21013,20 +21014,35 @@ package body Sem_Prag is\n            (Item        : Node_Id;\n             Global_Mode : Name_Id)\n          is\n-            procedure Add_Constituent (Item_Id : Entity_Id);\n-            --  Add a single constituent to one of the three constituent lists\n-            --  depending on Global_Mode.\n+            Item_Id : constant Entity_Id := Entity_Of (Item);\n \n-            procedure Check_Matching_Modes (Item_Id : Entity_Id);\n-            --  Verify that the global modes of item Item_Id are the same in\n-            --  both pragmas Global and Refined_Global.\n+            procedure Inconsistent_Mode_Error (Expect : Name_Id);\n+            --  Issue a common error message for all mode mismatches. Expect\n+            --  denotes the expected mode.\n \n-            ---------------------\n-            -- Add_Constituent --\n-            ---------------------\n+            -----------------------------\n+            -- Inconsistent_Mode_Error --\n+            -----------------------------\n \n-            procedure Add_Constituent (Item_Id : Entity_Id) is\n+            procedure Inconsistent_Mode_Error (Expect : Name_Id) is\n             begin\n+               Error_Msg_NE\n+                 (\"global item & has inconsistent modes\", Item, Item_Id);\n+\n+               Error_Msg_Name_1 := Global_Mode;\n+               Error_Msg_N (\"\\  expected mode %\", Item);\n+\n+               Error_Msg_Name_1 := Expect;\n+               Error_Msg_N (\"\\  found mode %\", Item);\n+            end Inconsistent_Mode_Error;\n+\n+         --  Start of processing for Check_Refined_Global_Item\n+\n+         begin\n+            --  The state or variable acts as a constituent of a state, collect\n+            --  it for the state completeness checks performed later on.\n+\n+            if Present (Refined_State (Item_Id)) then\n                if Global_Mode = Name_Input then\n                   Add_Item (Item_Id, In_Constits);\n \n@@ -21036,92 +21052,30 @@ package body Sem_Prag is\n                elsif Global_Mode = Name_Output then\n                   Add_Item (Item_Id, Out_Constits);\n                end if;\n-            end Add_Constituent;\n-\n-            --------------------------\n-            -- Check_Matching_Modes --\n-            --------------------------\n-\n-            procedure Check_Matching_Modes (Item_Id : Entity_Id) is\n-               procedure Inconsistent_Mode_Error (Expect : Name_Id);\n-               --  Issue a common error message for all mode mismatche. Expect\n-               --  denotes the expected mode.\n \n-               -----------------------------\n-               -- Inconsistent_Mode_Error --\n-               -----------------------------\n+            --  When not a constituent, ensure that both occurrences of the\n+            --  item in pragmas Global and Refined_Global match.\n \n-               procedure Inconsistent_Mode_Error (Expect : Name_Id) is\n-               begin\n-                  Error_Msg_NE\n-                    (\"global item & has inconsistent modes\", Item, Item_Id);\n-\n-                  Error_Msg_Name_1 := Global_Mode;\n-                  Error_Msg_N (\"\\  expected mode %\", Item);\n-\n-                  Error_Msg_Name_1 := Expect;\n-                  Error_Msg_N (\"\\  found mode %\", Item);\n-               end Inconsistent_Mode_Error;\n-\n-            --  Start processing for Check_Matching_Modes\n-\n-            begin\n-               if Contains (In_Items, Item_Id) then\n-                  if Global_Mode /= Name_Input then\n-                     Inconsistent_Mode_Error (Name_Input);\n-                  end if;\n-\n-               elsif Contains (In_Out_Items, Item_Id) then\n-                  if Global_Mode /= Name_In_Out then\n-                     Inconsistent_Mode_Error (Name_In_Out);\n-                  end if;\n-\n-               elsif Contains (Out_Items, Item_Id) then\n-                  if Global_Mode /= Name_Output then\n-                     Inconsistent_Mode_Error (Name_Output);\n-                  end if;\n-\n-               --  The item does not appear in the corresponding Global aspect,\n-               --  it must be an extra.\n-\n-               else\n-                  Error_Msg_NE (\"extra global item &\", Item, Item_Id);\n+            elsif Contains (In_Items, Item_Id) then\n+               if Global_Mode /= Name_Input then\n+                  Inconsistent_Mode_Error (Name_Input);\n                end if;\n-            end Check_Matching_Modes;\n-\n-            --  Local variables\n \n-            Item_Id : constant Entity_Id := Entity_Of (Item);\n-\n-         --  Start of processing for Check_Refined_Global_Item\n-\n-         begin\n-            if Ekind (Item_Id) = E_Abstract_State then\n-\n-               --  The state is neither a constituent of an ancestor state nor\n-               --  has a visible refinement. Ensure that the modes of both its\n-               --  occurrences in Global and Refined_Global match.\n-\n-               if No (Refined_State (Item_Id))\n-                 and then not Has_Visible_Refinement (Item_Id)\n-               then\n-                  Check_Matching_Modes (Item_Id);\n+            elsif Contains (In_Out_Items, Item_Id) then\n+               if Global_Mode /= Name_In_Out then\n+                  Inconsistent_Mode_Error (Name_In_Out);\n                end if;\n \n-            else pragma Assert (Ekind (Item_Id) = E_Variable);\n-\n-               --  The variable acts as a constituent of a state, collect it\n-               --  for the state completeness checks performed later on.\n-\n-               if Present (Refined_State (Item_Id)) then\n-                  Add_Constituent (Item_Id);\n+            elsif Contains (Out_Items, Item_Id) then\n+               if Global_Mode /= Name_Output then\n+                  Inconsistent_Mode_Error (Name_Output);\n+               end if;\n \n-               --  The variable is not a constituent. Ensure that the modes of\n-               --  both its occurrences in Global and Refined_Global match.\n+            --  The item does not appear in the corresponding Global pragma, it\n+            --  must be an extra.\n \n-               else\n-                  Check_Matching_Modes (Item_Id);\n-               end if;\n+            else\n+               Error_Msg_NE (\"extra global item &\", Item, Item_Id);\n             end if;\n          end Check_Refined_Global_Item;\n \n@@ -21433,8 +21387,40 @@ package body Sem_Prag is\n             --------------------------------\n \n             procedure Check_Matching_Constituent (Constit_Id : Entity_Id) is\n+               procedure Collect_Constituent;\n+               --  Add constituent Constit_Id to the refinements of State_Id\n+\n+               -------------------------\n+               -- Collect_Constituent --\n+               -------------------------\n+\n+               procedure Collect_Constituent is\n+               begin\n+                  --  Add the constituent to the lis of processed items to aid\n+                  --  with the detection of duplicates.\n+\n+                  Add_Item (Constit_Id, Constituents_Seen);\n+\n+                  --  Collect the constituent in the list of refinement items.\n+                  --  Establish a relation between the refined state and its\n+                  --  constituent.\n+\n+                  Append_Elmt (Constit_Id, Refinement_Constituents (State_Id));\n+                  Set_Refined_State (Constit_Id, State_Id);\n+\n+                  --  The state has at least one legal constituent, mark the\n+                  --  start of the refinement region. The region ends when the\n+                  --  body declarations end (see routine Analyze_Declarations).\n+\n+                  Set_Has_Visible_Refinement (State_Id);\n+               end Collect_Constituent;\n+\n+               --  Local variables\n+\n                State_Elmt : Elmt_Id;\n \n+            --  Start of processing for Check_Matching_Constituent\n+\n             begin\n                --  Detect a duplicate use of a constituent\n \n@@ -21457,15 +21443,16 @@ package body Sem_Prag is\n \n                   --  The constituent has the proper Part_Of option, but may\n                   --  not appear in the immediate hidden state of the related\n-                  --  package. This case arises when the constituent comes from\n-                  --  a private child or a private sibling. Recognize these\n-                  --  scenarios to avoid generating a bogus error message.\n+                  --  package. This case arises when the constituent appears\n+                  --  in a private child or a private sibling. Recognize these\n+                  --  scenarios and collect the constituent.\n \n                   elsif Is_Child_Or_Sibling\n                           (Pack_1        => Scope (State_Id),\n                            Pack_2        => Scope (Constit_Id),\n                            Private_Child => True)\n                   then\n+                     Collect_Constituent;\n                      return;\n                   end if;\n                end if;\n@@ -21489,21 +21476,7 @@ package body Sem_Prag is\n                         Add_Item (Constit_Id, Constituents_Seen);\n                         Remove_Elmt (Hidden_States, State_Elmt);\n \n-                        --  Collect the constituent in the list of refinement\n-                        --  items. Establish a relation between the refined\n-                        --  state and its constituent.\n-\n-                        Append_Elmt\n-                          (Constit_Id, Refinement_Constituents (State_Id));\n-                        Set_Refined_State (Constit_Id, State_Id);\n-\n-                        --  The state has at least one legal constituent, mark\n-                        --  the start of the refinement region. The region ends\n-                        --  when the body declarations end (see routine\n-                        --  Analyze_Declarations).\n-\n-                        Set_Has_Visible_Refinement (State_Id);\n-\n+                        Collect_Constituent;\n                         return;\n                      end if;\n \n@@ -23356,7 +23329,7 @@ package body Sem_Prag is\n       Item_Id : Entity_Id)\n    is\n    begin\n-      if In_Package_Body\n+      if Is_Body_Name (Unit_Name (Get_Source_Unit (Item)))\n         and then Ekind (Item_Id) = E_Abstract_State\n       then\n          if not Has_Body_References (Item_Id) then"}, {"sha": "5603464f15e4c75ab22185e8909322d320d87f1b", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9895094b3e88b913cee8a9115ffae8fd89e8c55/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=a9895094b3e88b913cee8a9115ffae8fd89e8c55", "patch": "@@ -2545,13 +2545,16 @@ package body Sem_Warn is\n          return;\n       end if;\n \n-      --  Flag any unused with clauses, but skip this step if we are compiling\n-      --  a subunit on its own, since we do not have enough information to\n-      --  determine whether with's are used. We will get the relevant warnings\n-      --  when we compile the parent. This is the normal style of GNAT\n-      --  compilation in any case.\n+      --  Flag any unused with clauses. For a subunit, check only the units\n+      --  in its context, not those of the parent, which may be needed by other\n+      --  subunits.  We will get the full warnings when we compile the parent,\n+      --  but the following is helpful when compiling a subunit by itself.\n \n       if Nkind (Unit (Cunit (Main_Unit))) = N_Subunit then\n+         if Current_Sem_Unit = Main_Unit then\n+            Check_One_Unit (Main_Unit);\n+         end if;\n+\n          return;\n       end if;\n "}]}