{"sha": "2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFkNGRjZjk4NWJmN2I4N2I1NmUzMWE0ZDdkMWY4NzhlOGRjZWE3OA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2004-07-09T09:30:46Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2004-07-09T09:30:46Z"}, "message": "arm.c (arm_cpp_interwork): New variable.\n\n* arm.c (arm_cpp_interwork): New variable.\n(arm_override_options): Set it if TARGET_INTERWORK was on the command\nline.\n* arm.h (arm_cpp_interwork): Declare it.\n(TARGET_CPU_CPP_BUILTINS): Use it to control definition of\n__THUMB_INTERWORK__ in the preprocessor.\n\nFrom-SVN: r84351", "tree": {"sha": "3fdda4aba160a45835b2302040249ad8c3955a6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fdda4aba160a45835b2302040249ad8c3955a6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78/comments", "author": null, "committer": null, "parents": [{"sha": "55d816e7c16bcb97973913b47a8303d140ab465c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d816e7c16bcb97973913b47a8303d140ab465c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d816e7c16bcb97973913b47a8303d140ab465c"}], "stats": {"total": 31, "additions": 30, "deletions": 1}, "files": [{"sha": "6de0aaf785cfdf942e6578e7ebbe73d10104089f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78", "patch": "@@ -1,3 +1,12 @@\n+2004-07-09  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_cpp_interwork): New variable.\n+\t(arm_override_options): Set it if TARGET_INTERWORK was on the command\n+\tline.\n+\t* arm.h (arm_cpp_interwork): Declare it.\n+\t(TARGET_CPU_CPP_BUILTINS): Use it to control definition of\n+\t__THUMB_INTERWORK__ in the preprocessor.\n+\n 2004-07-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* vec.h (VEC_T_alloc): Fix MEM_STAT_DECL pasto."}, {"sha": "9c373cffc316c23824653696df6916b4a841ffad", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78", "patch": "@@ -418,6 +418,13 @@ int arm_is_6_or_7 = 0;\n /* Nonzero if generating Thumb instructions.  */\n int thumb_code = 0;\n \n+/* Nonzero if we should define __THUMB_INTERWORK__ in the\n+   preprocessor.  \n+   XXX This is a bit of a hack, it's intended to help work around\n+   problems in GLD which doesn't understand that armv5t code is\n+   interworking clean.  */\n+int arm_cpp_interwork = 0;\n+\n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n    must report the mode of the memory reference from PRINT_OPERAND to\n    PRINT_OPERAND_ADDRESS.  */\n@@ -838,6 +845,12 @@ arm_override_options (void)\n \n   /* V5 code we generate is completely interworking capable, so we turn off\n      TARGET_INTERWORK here to avoid many tests later on.  */\n+\n+  /* XXX However, we must pass the right pre-processor defines to CPP\n+     or GLD can get confused.  This is a hack.  */\n+  if (TARGET_INTERWORK)\n+    arm_cpp_interwork = 1;\n+\n   if (arm_arch5)\n     target_flags &= ~ARM_FLAG_INTERWORK;\n "}, {"sha": "a66ec4d62890beb87d8b0be121c35688b8478d37", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=2ad4dcf985bf7b87b56e31a4d7d1f878e8dcea78", "patch": "@@ -63,7 +63,7 @@ extern char arm_arch_name[];\n \t\t\t\t\t\t\t\\\n \t/* Add a define for interworking.\t\t\\\n \t   Needed when building libgcc.a.  */\t\t\\\n-\tif (TARGET_INTERWORK)\t\t\t\t\\\n+\tif (arm_cpp_interwork)\t\t\t\t\\\n \t  builtin_define (\"__THUMB_INTERWORK__\");\t\\\n \t\t\t\t\t\t\t\\\n \tbuiltin_assert (\"cpu=arm\");\t\t\t\\\n@@ -528,6 +528,13 @@ extern int arm_tune_xscale;\n /* Nonzero if this chip is an ARM6 or an ARM7.  */\n extern int arm_is_6_or_7;\n \n+/* Nonzero if we should define __THUMB_INTERWORK__ in the\n+   preprocessor.  \n+   XXX This is a bit of a hack, it's intended to help work around\n+   problems in GLD which doesn't understand that armv5t code is\n+   interworking clean.  */\n+extern int arm_cpp_interwork;\n+\n #ifndef TARGET_DEFAULT\n #define TARGET_DEFAULT  (ARM_FLAG_APCS_FRAME)\n #endif"}]}