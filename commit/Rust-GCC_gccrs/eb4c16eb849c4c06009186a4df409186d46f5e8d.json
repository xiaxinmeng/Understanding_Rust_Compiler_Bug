{"sha": "eb4c16eb849c4c06009186a4df409186d46f5e8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI0YzE2ZWI4NDljNGMwNjAwOTE4NmE0ZGY0MDkxODZkNDZmNWU4ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-01-08T19:41:07Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-01-08T19:41:07Z"}, "message": "New jit API entrypoint: gcc_jit_context_set_logfile\n\ngcc/jit/ChangeLog:\n\t* Make-lang.in (jit_OBJS): Add jit/jit-logging.o.\n\t* docs/internals/index.rst (Overview of code structure): Mention\n\tgcc_jit_context_set_logfile, and embed the example logfile.\n\t* docs/internals/test-hello-world.exe.log.txt: New file: example\n\tof a logfile.\n\t* docs/topics/contexts.rst (Debugging): Add documentation\n\tfor gcc_jit_context_set_logfile.\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\t* dummy-frontend.c: Include \"jit-logging.h\".\n\t(jit_langhook_init): Assert that there is an active playback\n\tcontext.  If it has a logger, log entry/exit to this function.\n\t(jit_langhook_write_globals): Likewise.\n\t* jit-common.h (gcc::jit::logger): New forward declaration.\n\t* jit-logging.c: New file.\n\t* jit-logging.h: New file.\n\t* jit-playback.c: Include \"jit-logging.h\".\n\t(gcc::jit::playback::context::context): Initialize the log_user\n\tbase class from the recording context's logger (if any).  Use\n\tJIT_LOG_SCOPE to log entry/exit from the function body.\n\t(gcc::jit::playback::context::~context): Use JIT_LOG_SCOPE to\n\tlog entry/exit from the function body.\n\t(gcc::jit::playback::build_stmt_list): Likewise.\n\t(gcc::jit::playback::function::postprocess): Likewise.\n\t(gcc::jit::playback::context::compile): Likewise.  Log the\n\tentry/exit to toplev::main and toplev::finalize.  Log the\n\tfake argv passed to toplev::main.\n\t(gcc::jit::playback::context::acquire_mutex): Use JIT_LOG_SCOPE to\n\tlog entry/exit from the function body.\n\t(gcc::jit::playback::context::release_mutex): Likewise.\n\t(gcc::jit::playback::context::make_fake_args): Likewise.\n\t(gcc::jit::playback::context::extract_any_requested_dumps):\n\tLikewise.\n\t(gcc::jit::playback::context::convert_to_dso): Likewise. Also,\n\tlog the arguments that the driver is invoked with.\n\t(gcc::jit::playback::context::dlopen_built_dso): Likewise.  Pass\n\tthe logger to the result object.\n\t(gcc::jit::playback::context::replay): Use JIT_LOG_SCOPE to\n\tlog entry/exit from the function body.\n\t(gcc::jit::playback::context::dump_generated_code): Likewise.\n\t(gcc::jit::playback::context::handle_locations): Likewise.\n\t* jit-playback.h (gcc::jit::playback::context): Make this be\n\ta subclass of gcc::jit::log_user.\n\t* jit-recording.c: Include \"jit-logging.h\".\n\t(gcc::jit::recording::context::context: Initialize the logger to\n\tNULL for root contexts, or to the parent's logger for child\n\tcontexts.\n\t(gcc::jit::recording::context::~context): Use JIT_LOG_SCOPE to\n\tlog entry/exit from the function body.\n\t(gcc::jit::recording::context::replay_into): Likewise.\n\t(gcc::jit::recording::context::disassociate_from_playback):\n\tLikewise.\n\t(gcc::jit::recording::context::compile): Likewise.\n\t(recording::context::add_error_va): Likewise.  Also, log the\n\terror.\n\t(gcc::jit::recording::context::validate): Use JIT_LOG_SCOPE to\n\tlog entry/exit from the function body.\n\t* jit-recording.h: Include \"jit-logging.h\".\n\t(gcc::jit::recording::context): Make this be a subclass of\n\tgcc::jit::log_user.\n\t* jit-result.c: Include \"jit-common.h\" and \"jit-logging.h\".\n\t(gcc::jit::result::result): Add logger param, recording it.\n\tUse JIT_LOG_SCOPE to log entry/exit from the function body.\n\t(gcc::jit::result::~result(): Use JIT_LOG_SCOPE to\n\tlog entry/exit from the function body.\n\t(gcc::jit::result::get_code): Likewise.\n\t* jit-result.h (gcc::jit::result): Make this be a subclass of\n\tgcc::jit::log_user.\n\t(gcc::jit::result::result): Add logger parameter.\n\t* libgccjit++.h (gccjit::context::set_logfile): New function.\n\t* libgccjit.c: Include \"jit-logging.h\".\n\t(gcc_jit_context_acquire): Log the context.\n\t(gcc_jit_context_release): Use JIT_LOG_FUNC to\n\tlog entry/exit from the function body, and log the context.\n\t(gcc_jit_context_new_child_context): Likewise, logging both\n\tcontexts.\n\t(gcc_jit_context_new_location): Use JIT_LOG_FUNC to\n\tlog entry/exit from the function body.\n\t(gcc_jit_context_get_type): Likewise.\n\t(gcc_jit_context_get_int_type): Likewise.\n\t(gcc_jit_context_new_array_type): Likewise.\n\t(gcc_jit_context_new_field): Likewise.\n\t(gcc_jit_context_new_struct_type): Likewise.\n\t(gcc_jit_context_new_opaque_struct): Likewise.\n\t(gcc_jit_struct_set_fields): Likewise.\n\t(gcc_jit_context_new_union_type): Likewise.\n\t(gcc_jit_context_new_function_ptr_type): Likewise.\n\t(gcc_jit_context_new_param): Likewise.\n\t(gcc_jit_context_new_function): Likewise.\n\t(gcc_jit_context_get_builtin_function): Likewise.\n\t(gcc_jit_function_get_param): Likewise.\n\t(gcc_jit_function_dump_to_dot): Likewise.\n\t(gcc_jit_function_new_block): Likewise.\n\t(gcc_jit_context_new_global): Likewise.\n\t(gcc_jit_context_new_rvalue_from_int): Likewise.\n\t(gcc_jit_context_zero): Likewise.\n\t(gcc_jit_context_one): Likewise.\n\t(gcc_jit_context_new_rvalue_from_double): Likewise.\n\t(gcc_jit_context_new_rvalue_from_ptr): Likewise.\n\t(gcc_jit_context_null): Likewise.\n\t(gcc_jit_context_new_string_literal): Likewise.\n\t(gcc_jit_context_new_unary_op): Likewise.\n\t(gcc_jit_context_new_binary_op): Likewise.\n\t(gcc_jit_context_new_comparison): Likewise.\n\t(gcc_jit_context_new_call): Likewise.\n\t(gcc_jit_context_new_call_through_ptr): Likewise.\n\t(gcc_jit_context_new_cast): Likewise.\n\t(gcc_jit_context_new_array_access): Likewise.\n\t(gcc_jit_lvalue_access_field): Likewise.\n\t(gcc_jit_rvalue_access_field): Likewise.\n\t(gcc_jit_rvalue_dereference_field): Likewise.\n\t(gcc_jit_rvalue_dereference): Likewise.\n\t(gcc_jit_lvalue_get_address): Likewise.\n\t(gcc_jit_function_new_local): Likewise.\n\t(gcc_jit_block_add_eval): Likewise.\n\t(gcc_jit_block_add_assignment): Likewise.\n\t(gcc_jit_block_add_assignment_op): Likewise.\n\t(gcc_jit_block_end_with_conditional): Likewise.\n\t(gcc_jit_block_add_comment): Likewise.\n\t(gcc_jit_block_end_with_jump): Likewise.\n\t(gcc_jit_block_end_with_return): Likewise.\n\t(gcc_jit_block_end_with_void_return): Likewise.\n\t(gcc_jit_context_set_str_option): Likewise.\n\t(gcc_jit_context_set_int_option): Likewise.\n\t(gcc_jit_context_set_bool_option): Likewise.\n\t(gcc_jit_context_enable_dump): Likewise.\n\t(gcc_jit_context_compile): Likewise.  Also log the context,\n\tand the result.\n\t(gcc_jit_context_dump_to_file): Likewise.\n\t(gcc_jit_context_set_logfile): New function.\n\t(gcc_jit_context_get_first_error): Use JIT_LOG_FUNC to\n\tlog entry/exit from the function body.\n\t(gcc_jit_result_get_code): Likewise.  Also log the fnname)\n\tand the ptr to be returned.\n\t(gcc_jit_result_release): Likewise.  Also log the result.\n\t* libgccjit.h: Include <stdio.h>, since we need FILE *.\n\t(gcc_jit_context_set_logfile): New declaration.\n\t* libgccjit.map (gcc_jit_context_set_logfile): New.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/harness.h (set_up_logging): New function.\n\t(test_jit): Fail if gcc_jit_context_acquire fails.  Call\n\tset_up_logging on the context, so that every testcase is\n\tlogged to a particular file.\n\t* jit.dg/test-nested-contexts.c (main): Open a logfile,\n\tand call gcc_jit_context_set_logfile on the top-level context.\n\nFrom-SVN: r219357", "tree": {"sha": "fb0c1dc7bb71ee82c586ff5bfaf5f70fad96ddb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb0c1dc7bb71ee82c586ff5bfaf5f70fad96ddb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb4c16eb849c4c06009186a4df409186d46f5e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4c16eb849c4c06009186a4df409186d46f5e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb4c16eb849c4c06009186a4df409186d46f5e8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4c16eb849c4c06009186a4df409186d46f5e8d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "efa7df3c625146460d7ec345d32a4efb42be871b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa7df3c625146460d7ec345d32a4efb42be871b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efa7df3c625146460d7ec345d32a4efb42be871b"}], "stats": {"total": 1945, "additions": 1544, "deletions": 401}, "files": [{"sha": "670f6a2c3fb31696fba1753ebcdb58a72420f533", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -1,3 +1,143 @@\n+2015-01-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Make-lang.in (jit_OBJS): Add jit/jit-logging.o.\n+\t* docs/internals/index.rst (Overview of code structure): Mention\n+\tgcc_jit_context_set_logfile, and embed the example logfile.\n+\t* docs/internals/test-hello-world.exe.log.txt: New file: example\n+\tof a logfile.\n+\t* docs/topics/contexts.rst (Debugging): Add documentation\n+\tfor gcc_jit_context_set_logfile.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\t* dummy-frontend.c: Include \"jit-logging.h\".\n+\t(jit_langhook_init): Assert that there is an active playback\n+\tcontext.  If it has a logger, log entry/exit to this function.\n+\t(jit_langhook_write_globals): Likewise.\n+\t* jit-common.h (gcc::jit::logger): New forward declaration.\n+\t* jit-logging.c: New file.\n+\t* jit-logging.h: New file.\n+\t* jit-playback.c: Include \"jit-logging.h\".\n+\t(gcc::jit::playback::context::context): Initialize the log_user\n+\tbase class from the recording context's logger (if any).  Use\n+\tJIT_LOG_SCOPE to log entry/exit from the function body.\n+\t(gcc::jit::playback::context::~context): Use JIT_LOG_SCOPE to\n+\tlog entry/exit from the function body.\n+\t(gcc::jit::playback::build_stmt_list): Likewise.\n+\t(gcc::jit::playback::function::postprocess): Likewise.\n+\t(gcc::jit::playback::context::compile): Likewise.  Log the\n+\tentry/exit to toplev::main and toplev::finalize.  Log the\n+\tfake argv passed to toplev::main.\n+\t(gcc::jit::playback::context::acquire_mutex): Use JIT_LOG_SCOPE to\n+\tlog entry/exit from the function body.\n+\t(gcc::jit::playback::context::release_mutex): Likewise.\n+\t(gcc::jit::playback::context::make_fake_args): Likewise.\n+\t(gcc::jit::playback::context::extract_any_requested_dumps):\n+\tLikewise.\n+\t(gcc::jit::playback::context::convert_to_dso): Likewise. Also,\n+\tlog the arguments that the driver is invoked with.\n+\t(gcc::jit::playback::context::dlopen_built_dso): Likewise.  Pass\n+\tthe logger to the result object.\n+\t(gcc::jit::playback::context::replay): Use JIT_LOG_SCOPE to\n+\tlog entry/exit from the function body.\n+\t(gcc::jit::playback::context::dump_generated_code): Likewise.\n+\t(gcc::jit::playback::context::handle_locations): Likewise.\n+\t* jit-playback.h (gcc::jit::playback::context): Make this be\n+\ta subclass of gcc::jit::log_user.\n+\t* jit-recording.c: Include \"jit-logging.h\".\n+\t(gcc::jit::recording::context::context: Initialize the logger to\n+\tNULL for root contexts, or to the parent's logger for child\n+\tcontexts.\n+\t(gcc::jit::recording::context::~context): Use JIT_LOG_SCOPE to\n+\tlog entry/exit from the function body.\n+\t(gcc::jit::recording::context::replay_into): Likewise.\n+\t(gcc::jit::recording::context::disassociate_from_playback):\n+\tLikewise.\n+\t(gcc::jit::recording::context::compile): Likewise.\n+\t(recording::context::add_error_va): Likewise.  Also, log the\n+\terror.\n+\t(gcc::jit::recording::context::validate): Use JIT_LOG_SCOPE to\n+\tlog entry/exit from the function body.\n+\t* jit-recording.h: Include \"jit-logging.h\".\n+\t(gcc::jit::recording::context): Make this be a subclass of\n+\tgcc::jit::log_user.\n+\t* jit-result.c: Include \"jit-common.h\" and \"jit-logging.h\".\n+\t(gcc::jit::result::result): Add logger param, recording it.\n+\tUse JIT_LOG_SCOPE to log entry/exit from the function body.\n+\t(gcc::jit::result::~result(): Use JIT_LOG_SCOPE to\n+\tlog entry/exit from the function body.\n+\t(gcc::jit::result::get_code): Likewise.\n+\t* jit-result.h (gcc::jit::result): Make this be a subclass of\n+\tgcc::jit::log_user.\n+\t(gcc::jit::result::result): Add logger parameter.\n+\t* libgccjit++.h (gccjit::context::set_logfile): New function.\n+\t* libgccjit.c: Include \"jit-logging.h\".\n+\t(gcc_jit_context_acquire): Log the context.\n+\t(gcc_jit_context_release): Use JIT_LOG_FUNC to\n+\tlog entry/exit from the function body, and log the context.\n+\t(gcc_jit_context_new_child_context): Likewise, logging both\n+\tcontexts.\n+\t(gcc_jit_context_new_location): Use JIT_LOG_FUNC to\n+\tlog entry/exit from the function body.\n+\t(gcc_jit_context_get_type): Likewise.\n+\t(gcc_jit_context_get_int_type): Likewise.\n+\t(gcc_jit_context_new_array_type): Likewise.\n+\t(gcc_jit_context_new_field): Likewise.\n+\t(gcc_jit_context_new_struct_type): Likewise.\n+\t(gcc_jit_context_new_opaque_struct): Likewise.\n+\t(gcc_jit_struct_set_fields): Likewise.\n+\t(gcc_jit_context_new_union_type): Likewise.\n+\t(gcc_jit_context_new_function_ptr_type): Likewise.\n+\t(gcc_jit_context_new_param): Likewise.\n+\t(gcc_jit_context_new_function): Likewise.\n+\t(gcc_jit_context_get_builtin_function): Likewise.\n+\t(gcc_jit_function_get_param): Likewise.\n+\t(gcc_jit_function_dump_to_dot): Likewise.\n+\t(gcc_jit_function_new_block): Likewise.\n+\t(gcc_jit_context_new_global): Likewise.\n+\t(gcc_jit_context_new_rvalue_from_int): Likewise.\n+\t(gcc_jit_context_zero): Likewise.\n+\t(gcc_jit_context_one): Likewise.\n+\t(gcc_jit_context_new_rvalue_from_double): Likewise.\n+\t(gcc_jit_context_new_rvalue_from_ptr): Likewise.\n+\t(gcc_jit_context_null): Likewise.\n+\t(gcc_jit_context_new_string_literal): Likewise.\n+\t(gcc_jit_context_new_unary_op): Likewise.\n+\t(gcc_jit_context_new_binary_op): Likewise.\n+\t(gcc_jit_context_new_comparison): Likewise.\n+\t(gcc_jit_context_new_call): Likewise.\n+\t(gcc_jit_context_new_call_through_ptr): Likewise.\n+\t(gcc_jit_context_new_cast): Likewise.\n+\t(gcc_jit_context_new_array_access): Likewise.\n+\t(gcc_jit_lvalue_access_field): Likewise.\n+\t(gcc_jit_rvalue_access_field): Likewise.\n+\t(gcc_jit_rvalue_dereference_field): Likewise.\n+\t(gcc_jit_rvalue_dereference): Likewise.\n+\t(gcc_jit_lvalue_get_address): Likewise.\n+\t(gcc_jit_function_new_local): Likewise.\n+\t(gcc_jit_block_add_eval): Likewise.\n+\t(gcc_jit_block_add_assignment): Likewise.\n+\t(gcc_jit_block_add_assignment_op): Likewise.\n+\t(gcc_jit_block_end_with_conditional): Likewise.\n+\t(gcc_jit_block_add_comment): Likewise.\n+\t(gcc_jit_block_end_with_jump): Likewise.\n+\t(gcc_jit_block_end_with_return): Likewise.\n+\t(gcc_jit_block_end_with_void_return): Likewise.\n+\t(gcc_jit_context_set_str_option): Likewise.\n+\t(gcc_jit_context_set_int_option): Likewise.\n+\t(gcc_jit_context_set_bool_option): Likewise.\n+\t(gcc_jit_context_enable_dump): Likewise.\n+\t(gcc_jit_context_compile): Likewise.  Also log the context,\n+\tand the result.\n+\t(gcc_jit_context_dump_to_file): Likewise.\n+\t(gcc_jit_context_set_logfile): New function.\n+\t(gcc_jit_context_get_first_error): Use JIT_LOG_FUNC to\n+\tlog entry/exit from the function body.\n+\t(gcc_jit_result_get_code): Likewise.  Also log the fnname)\n+\tand the ptr to be returned.\n+\t(gcc_jit_result_release): Likewise.  Also log the result.\n+\t* libgccjit.h: Include <stdio.h>, since we need FILE *.\n+\t(gcc_jit_context_set_logfile): New declaration.\n+\t* libgccjit.map (gcc_jit_context_set_logfile): New.\n+\n 2015-01-07  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit-recording.h (gcc::jit::recording::type::is_void): New"}, {"sha": "551b115d6bec1e4e681524f416d9807c109ffafd", "filename": "gcc/jit/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FMake-lang.in?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -62,6 +62,7 @@ jit: $(LIBGCCJIT_FILENAME) \\\n jit_OBJS = attribs.o \\\n \tjit/dummy-frontend.o \\\n \tjit/libgccjit.o \\\n+\tjit/jit-logging.o \\\n \tjit/jit-recording.o \\\n \tjit/jit-playback.o \\\n \tjit/jit-result.o \\"}, {"sha": "cc40fd7dc4362c58f0071c893b300cf690a497c8", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 568, "deletions": 373, "changes": 941, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d"}, {"sha": "20ac337784adaf30121dade973a495009f0af875", "filename": "gcc/jit/docs/internals/index.rst", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -268,3 +268,12 @@ Here is a high-level summary from ``jit-common.h``:\n .. include:: ../../jit-common.h\n   :start-after: This comment is included by the docs.\n   :end-before: End of comment for inclusion in the docs.  */\n+\n+.. _example-of-log-file:\n+\n+Another way to understand the structure of the code is to enable logging,\n+via :c:func:`gcc_jit_context_set_logfile`.  Here is an example of a log\n+generated via this call:\n+\n+.. literalinclude:: test-hello-world.exe.log.txt\n+    :lines: 1-"}, {"sha": "a96d80fc45e70076c94a714d1f671ea0cc9efa43", "filename": "gcc/jit/docs/internals/test-hello-world.exe.log.txt", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Finternals%2Ftest-hello-world.exe.log.txt?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -0,0 +1,126 @@\n+JIT: entering: gcc_jit_context_set_str_option\n+JIT: exiting: gcc_jit_context_set_str_option\n+JIT: entering: gcc_jit_context_set_int_option\n+JIT: exiting: gcc_jit_context_set_int_option\n+JIT: entering: gcc_jit_context_set_bool_option\n+JIT: exiting: gcc_jit_context_set_bool_option\n+JIT: entering: gcc_jit_context_set_bool_option\n+JIT: exiting: gcc_jit_context_set_bool_option\n+JIT: entering: gcc_jit_context_set_bool_option\n+JIT: exiting: gcc_jit_context_set_bool_option\n+JIT: entering: gcc_jit_context_set_bool_option\n+JIT: exiting: gcc_jit_context_set_bool_option\n+JIT: entering: gcc_jit_context_set_bool_option\n+JIT: exiting: gcc_jit_context_set_bool_option\n+JIT: entering: gcc_jit_context_get_type\n+JIT: exiting: gcc_jit_context_get_type\n+JIT: entering: gcc_jit_context_get_type\n+JIT: exiting: gcc_jit_context_get_type\n+JIT: entering: gcc_jit_context_new_param\n+JIT: exiting: gcc_jit_context_new_param\n+JIT: entering: gcc_jit_context_new_function\n+JIT: exiting: gcc_jit_context_new_function\n+JIT: entering: gcc_jit_context_new_param\n+JIT: exiting: gcc_jit_context_new_param\n+JIT: entering: gcc_jit_context_get_type\n+JIT: exiting: gcc_jit_context_get_type\n+JIT: entering: gcc_jit_context_new_function\n+JIT: exiting: gcc_jit_context_new_function\n+JIT: entering: gcc_jit_context_new_string_literal\n+JIT: exiting: gcc_jit_context_new_string_literal\n+JIT: entering: gcc_jit_function_new_block\n+JIT: exiting: gcc_jit_function_new_block\n+JIT: entering: gcc_jit_block_add_comment\n+JIT: exiting: gcc_jit_block_add_comment\n+JIT: entering: gcc_jit_context_new_call\n+JIT: exiting: gcc_jit_context_new_call\n+JIT: entering: gcc_jit_block_add_eval\n+JIT: exiting: gcc_jit_block_add_eval\n+JIT: entering: gcc_jit_block_end_with_void_return\n+JIT: exiting: gcc_jit_block_end_with_void_return\n+JIT: entering: gcc_jit_context_compile\n+JIT:  compiling ctxt: 0x1283e20\n+JIT:  entering: gcc::jit::result* gcc::jit::recording::context::compile()\n+JIT:   entering: void gcc::jit::recording::context::validate()\n+JIT:   exiting: void gcc::jit::recording::context::validate()\n+JIT:   entering: gcc::jit::playback::context::context(gcc::jit::recording::context*)\n+JIT:   exiting: gcc::jit::playback::context::context(gcc::jit::recording::context*)\n+JIT:   entering: gcc::jit::result* gcc::jit::playback::context::compile()\n+JIT:    entering: void gcc::jit::playback::context::make_fake_args(vec<char*>*, const char*, vec<gcc::jit::recording::requested_dump>*)\n+JIT:    exiting: void gcc::jit::playback::context::make_fake_args(vec<char*>*, const char*, vec<gcc::jit::recording::requested_dump>*)\n+JIT:    entering: void gcc::jit::playback::context::acquire_mutex()\n+JIT:    exiting: void gcc::jit::playback::context::acquire_mutex()\n+JIT:    entering: toplev::main\n+JIT:     argv[0]: ./test-hello-world.c.exe\n+JIT:     argv[1]: /tmp/libgccjit-CKq1M9/fake.c\n+JIT:     argv[2]: -fPIC\n+JIT:     argv[3]: -O3\n+JIT:     argv[4]: -g\n+JIT:     argv[5]: -quiet\n+JIT:     argv[6]: --param\n+JIT:     argv[7]: ggc-min-expand=0\n+JIT:     argv[8]: --param\n+JIT:     argv[9]: ggc-min-heapsize=0\n+JIT:     entering: bool jit_langhook_init()\n+JIT:     exiting: bool jit_langhook_init()\n+JIT:     entering: void gcc::jit::playback::context::replay()\n+JIT:      entering: void gcc::jit::recording::context::replay_into(gcc::jit::replayer*)\n+JIT:      exiting: void gcc::jit::recording::context::replay_into(gcc::jit::replayer*)\n+JIT:      entering: void gcc::jit::recording::context::disassociate_from_playback()\n+JIT:      exiting: void gcc::jit::recording::context::disassociate_from_playback()\n+JIT:      entering: void gcc::jit::playback::context::handle_locations()\n+JIT:      exiting: void gcc::jit::playback::context::handle_locations()\n+JIT:      entering: void gcc::jit::playback::function::build_stmt_list()\n+JIT:      exiting: void gcc::jit::playback::function::build_stmt_list()\n+JIT:      entering: void gcc::jit::playback::function::build_stmt_list()\n+JIT:      exiting: void gcc::jit::playback::function::build_stmt_list()\n+JIT:      entering: void gcc::jit::playback::function::postprocess()\n+JIT:      exiting: void gcc::jit::playback::function::postprocess()\n+JIT:      entering: void gcc::jit::playback::function::postprocess()\n+JIT:      exiting: void gcc::jit::playback::function::postprocess()\n+JIT:     exiting: void gcc::jit::playback::context::replay()\n+JIT:     entering: void jit_langhook_write_globals()\n+JIT:     exiting: void jit_langhook_write_globals()\n+JIT:    exiting: toplev::main\n+JIT:    entering: void gcc::jit::playback::context::extract_any_requested_dumps(vec<gcc::jit::recording::requested_dump>*)\n+JIT:    exiting: void gcc::jit::playback::context::extract_any_requested_dumps(vec<gcc::jit::recording::requested_dump>*)\n+JIT:    entering: toplev::finalize\n+JIT:    exiting: toplev::finalize\n+JIT:    entering: void gcc::jit::playback::context::convert_to_dso(const char*)\n+JIT:     argv[0]: x86_64-unknown-linux-gnu-gcc-5.0.0\n+JIT:     argv[1]: -shared\n+JIT:     argv[2]: /tmp/libgccjit-CKq1M9/fake.s\n+JIT:     argv[3]: -o\n+JIT:     argv[4]: /tmp/libgccjit-CKq1M9/fake.so\n+JIT:     argv[5]: -fno-use-linker-plugin\n+JIT:     argv[6]: (null)\n+JIT:    exiting: void gcc::jit::playback::context::convert_to_dso(const char*)\n+JIT:    entering: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()\n+JIT:     entering: gcc::jit::result::result(gcc::jit::logger*, void*)\n+JIT:     exiting: gcc::jit::result::result(gcc::jit::logger*, void*)\n+JIT:    exiting: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()\n+JIT:    entering: void gcc::jit::playback::context::release_mutex()\n+JIT:    exiting: void gcc::jit::playback::context::release_mutex()\n+JIT:   exiting: gcc::jit::result* gcc::jit::playback::context::compile()\n+JIT:   entering: gcc::jit::playback::context::~context()\n+JIT:   exiting: gcc::jit::playback::context::~context()\n+JIT:  exiting: gcc::jit::result* gcc::jit::recording::context::compile()\n+JIT:  gcc_jit_context_compile: returning (gcc_jit_result *)0x12f75d0\n+JIT: exiting: gcc_jit_context_compile\n+JIT: entering: gcc_jit_result_get_code\n+JIT:  locating fnname: hello_world\n+JIT:  entering: void* gcc::jit::result::get_code(const char*)\n+JIT:  exiting: void* gcc::jit::result::get_code(const char*)\n+JIT:  gcc_jit_result_get_code: returning (void *)0x7ff6b8cd87f0\n+JIT: exiting: gcc_jit_result_get_code\n+JIT: entering: gcc_jit_context_release\n+JIT:  deleting ctxt: 0x1283e20\n+JIT:  entering: gcc::jit::recording::context::~context()\n+JIT:  exiting: gcc::jit::recording::context::~context()\n+JIT: exiting: gcc_jit_context_release\n+JIT: entering: gcc_jit_result_release\n+JIT:  deleting result: 0x12f75d0\n+JIT:  entering: virtual gcc::jit::result::~result()\n+JIT:  exiting: virtual gcc::jit::result::~result()\n+JIT: exiting: gcc_jit_result_release\n+JIT: gcc::jit::logger::~logger()"}, {"sha": "6099c69c96520c3305d912d5b8172665f03abc19", "filename": "gcc/jit/docs/topics/contexts.rst", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -152,6 +152,56 @@ Debugging\n    :macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO` to allow stepping through the\n    code in a debugger.\n \n+.. function:: void\\\n+              gcc_jit_context_set_logfile (gcc_jit_context *ctxt,\\\n+                                           FILE *logfile,\\\n+                                           int flags,\\\n+                                           int verbosity)\n+\n+   To help with debugging; enable ongoing logging of the context's\n+   activity to the given file.\n+\n+   For example, the following will enable logging to stderr.\n+\n+   .. code-block:: c\n+\n+      gcc_jit_context_set_logfile (ctxt, stderr, 0, 0);\n+\n+   Examples of information logged include:\n+\n+   * API calls\n+\n+   * the various steps involved within compilation\n+\n+   * activity on any :c:type:`gcc_jit_result` instances created by\n+     the context\n+\n+   * activity within any child contexts\n+\n+   An example of a log can be seen :ref:`here <example-of-log-file>`,\n+   though the precise format and kinds of information logged is subject\n+   to change.\n+\n+   The caller remains responsible for closing `logfile`, and it must not\n+   be closed until all users are released.  In particular, note that\n+   child contexts and :c:type:`gcc_jit_result` instances created by\n+   the context will use the logfile.\n+\n+   There may a performance cost for logging.\n+\n+   You can turn off logging on `ctxt` by passing `NULL` for `logfile`.\n+   Doing so only affects the context; it does not affect child contexts\n+   or :c:type:`gcc_jit_result` instances already created by\n+   the context.\n+\n+   The parameters \"flags\" and \"verbosity\" are reserved for future\n+   expansion, and must be zero for now.\n+\n+To contrast the above: :c:func:`gcc_jit_context_dump_to_file` dumps the\n+current state of a context to the given path, whereas\n+:c:func:`gcc_jit_context_set_logfile` enables on-going logging of\n+future activies on a context to the given `FILE *`.\n+\n .. function:: void\\\n               gcc_jit_context_enable_dump (gcc_jit_context *ctxt,\\\n                                            const char *dumpname, \\"}, {"sha": "23883ad230c7fe8b8e6eed30e3f2cc4f2e12bcde", "filename": "gcc/jit/dummy-frontend.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdummy-frontend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fdummy-frontend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdummy-frontend.c?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n \n #include \"jit-common.h\"\n+#include \"jit-logging.h\"\n #include \"jit-playback.h\"\n \n #include <mpfr.h>\n@@ -113,6 +114,9 @@ struct ggc_root_tab jit_root_tab[] =\n static bool\n jit_langhook_init (void)\n {\n+  gcc_assert (gcc::jit::active_playback_ctxt);\n+  JIT_LOG_SCOPE (gcc::jit::active_playback_ctxt->get_logger ());\n+\n   static bool registered_root_tab = false;\n   if (!registered_root_tab)\n     {\n@@ -212,6 +216,9 @@ jit_langhook_getdecls (void)\n static void\n jit_langhook_write_globals (void)\n {\n+  gcc_assert (gcc::jit::active_playback_ctxt);\n+  JIT_LOG_SCOPE (gcc::jit::active_playback_ctxt->get_logger ());\n+\n   /* This is the hook that runs the middle and backends: */\n   symtab->finalize_compilation_unit ();\n }"}, {"sha": "80e1cbef1f5a41bd8c4168798821802bee294a11", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -97,6 +97,7 @@ namespace jit {\n \n class result;\n class dump;\n+class logger;\n class builtins_manager; // declared within jit-builtins.h\n class tempdir;\n "}, {"sha": "61b898b00bd1af379efe2beb6b9a4eca25e9241f", "filename": "gcc/jit/jit-logging.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-logging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-logging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-logging.c?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -0,0 +1,168 @@\n+/* Internals of libgccjit: logging\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"jit-logging.h\"\n+\n+namespace gcc {\n+\n+namespace jit {\n+\n+/* Implementation of class gcc::jit::logger.  */\n+\n+/* The constructor for gcc::jit::logger, used by\n+   gcc_jit_context_set_logfile.  */\n+\n+logger::logger (FILE *f_out,\n+\t\tint, /* flags */\n+\t\tint /* verbosity */) :\n+  m_refcount (0),\n+  m_f_out (f_out),\n+  m_indent_level (0),\n+  m_log_refcount_changes (false)\n+{\n+}\n+\n+/* The destructor for gcc::jit::logger, invoked via\n+   the decref method when the refcount hits zero.\n+   Note that we do not close the underlying FILE * (m_f_out).  */\n+\n+logger::~logger ()\n+{\n+  /* This should be the last message emitted.  */\n+  log (\"%s\", __PRETTY_FUNCTION__);\n+  gcc_assert (m_refcount == 0);\n+}\n+\n+/* Increment the reference count of the gcc::jit::logger.  */\n+\n+void\n+logger::incref (const char *reason)\n+{\n+  m_refcount++;\n+  if (m_log_refcount_changes)\n+    log (\"%s: reason: %s refcount now %i \",\n+\t __PRETTY_FUNCTION__, reason, m_refcount);\n+}\n+\n+/* Decrement the reference count of the gcc::jit::logger,\n+   deleting it if nothing is referring to it.  */\n+\n+void\n+logger::decref (const char *reason)\n+{\n+  gcc_assert (m_refcount > 0);\n+  --m_refcount;\n+  if (m_log_refcount_changes)\n+    log (\"%s: reason: %s refcount now %i\",\n+\t __PRETTY_FUNCTION__, reason, m_refcount);\n+  if (0 == m_refcount)\n+    delete this;\n+}\n+\n+/* Write a formatted message to the log, by calling the log_va method.  */\n+\n+void\n+logger::log (const char *fmt, ...)\n+{\n+  va_list ap;\n+  va_start (ap, fmt);\n+  log_va (fmt, ap);\n+  va_end (ap);\n+}\n+\n+/* Write an indented line to the log file.\n+\n+   We explicitly flush after each line: if something crashes the process,\n+   we want the logfile/stream to contain the most up-to-date hint about the\n+   last thing that was happening, without it being hidden in an in-process\n+   buffer.  */\n+\n+void\n+logger::log_va (const char *fmt, va_list ap)\n+{\n+  fprintf (m_f_out, \"JIT: \");\n+  for (int i = 0; i < m_indent_level; i++)\n+    fputc (' ', m_f_out);\n+  vfprintf (m_f_out, fmt, ap);\n+  fprintf (m_f_out, \"\\n\");\n+  fflush (m_f_out);\n+}\n+\n+/* Record the entry within a particular scope, indenting subsequent\n+   log lines accordingly.  */\n+\n+void\n+logger::enter_scope (const char *scope_name)\n+{\n+  log (\"entering: %s\", scope_name);\n+  m_indent_level += 1;\n+}\n+\n+/* Record the exit from a particular scope, restoring the indent level to\n+   before the scope was entered.  */\n+\n+void\n+logger::exit_scope (const char *scope_name)\n+{\n+  if (m_indent_level)\n+    m_indent_level -= 1;\n+  else\n+    log (\"(mismatching indentation)\");\n+  log (\"exiting: %s\", scope_name);\n+}\n+\n+/* Implementation of class gcc::jit::log_user.  */\n+\n+/* The constructor for gcc::jit::log_user.  */\n+\n+log_user::log_user (logger *logger) : m_logger (logger)\n+{\n+  if (m_logger)\n+    m_logger->incref(\"log_user ctor\");\n+}\n+\n+/* The destructor for gcc::jit::log_user.  */\n+\n+log_user::~log_user ()\n+{\n+  if (m_logger)\n+    m_logger->decref(\"log_user dtor\");\n+}\n+\n+/* Set the logger for a gcc::jit::log_user, managing the reference counts\n+   of the old and new logger (either of which might be NULL).  */\n+\n+void\n+log_user::set_logger (logger *logger)\n+{\n+  if (logger)\n+    logger->incref (\"log_user::set_logger\");\n+  if (m_logger)\n+    m_logger->decref (\"log_user::set_logger\");\n+  m_logger = logger;\n+}\n+\n+} // namespace gcc::jit\n+\n+} // namespace gcc"}, {"sha": "581090c738ad680c9a2808c53348d995c7bec944", "filename": "gcc/jit/jit-logging.h", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-logging.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-logging.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-logging.h?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -0,0 +1,191 @@\n+/* Internals of libgccjit: logging\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef JIT_LOGGING_H\n+#define JIT_LOGGING_H\n+\n+#include \"jit-common.h\"\n+\n+namespace gcc {\n+\n+namespace jit {\n+\n+/* A gcc::jit::logger encapsulates a logging stream: a way to send\n+   lines of pertinent information to a FILE *.  */\n+\n+class logger\n+{\n+ public:\n+  logger (FILE *f_out, int flags, int verbosity);\n+  ~logger ();\n+\n+  void incref (const char *reason);\n+  void decref (const char *reason);\n+\n+  void log (const char *fmt, ...)\n+    GNU_PRINTF(2, 3);\n+  void log_va (const char *fmt, va_list ap)\n+    GNU_PRINTF(2, 0);\n+\n+  void enter_scope (const char *scope_name);\n+  void exit_scope (const char *scope_name);\n+\n+private:\n+  int m_refcount;\n+  FILE *m_f_out;\n+  int m_indent_level;\n+  bool m_log_refcount_changes;\n+};\n+\n+/* The class gcc::jit::log_scope is an RAII-style class intended to make\n+   it easy to notify a logger about entering and exiting the body of a\n+   given function.  */\n+\n+class log_scope\n+{\n+public:\n+  log_scope (logger *logger, const char *name);\n+  ~log_scope ();\n+\n+ private:\n+  logger *m_logger;\n+  const char *m_name;\n+};\n+\n+/* The constructor for gcc::jit::log_scope.\n+\n+   The normal case is that the logger is NULL, in which case this should\n+   be largely a no-op.\n+\n+   If we do have a logger, notify it that we're entering the given scope.\n+   We also need to hold a reference on it, to avoid a use-after-free\n+   when logging the cleanup of the owner of the logger.  */\n+\n+inline\n+log_scope::log_scope (logger *logger, const char *name) :\n+ m_logger (logger),\n+ m_name (name)\n+{\n+  if (m_logger)\n+    {\n+      m_logger->incref (\"log_scope ctor\");\n+      m_logger->enter_scope (m_name);\n+    }\n+}\n+\n+/* The destructor for gcc::jit::log_scope; essentially the opposite of\n+   the constructor.  */\n+\n+inline\n+log_scope::~log_scope ()\n+{\n+  if (m_logger)\n+    {\n+      m_logger->exit_scope (m_name);\n+      m_logger->decref (\"log_scope dtor\");\n+    }\n+}\n+\n+/* A gcc::jit::log_user is something that potentially uses a\n+   gcc::jit::logger (which could be NULL).\n+\n+   It is the base class for each of:\n+\n+      - class gcc::jit::recording::context\n+\n+      - class gcc::jit::playback::context\n+\n+      - class gcc::jit::result\n+\n+   The log_user class keeps the reference-count of a logger up-to-date.  */\n+\n+class log_user\n+{\n+ public:\n+  log_user (logger *logger);\n+  ~log_user ();\n+\n+  logger * get_logger () const { return m_logger; }\n+  void set_logger (logger * logger);\n+\n+  void log (const char *fmt, ...)\n+    GNU_PRINTF(2, 3);\n+\n+  void enter_scope (const char *scope_name);\n+  void exit_scope (const char *scope_name);\n+\n+ private:\n+  logger *m_logger;\n+};\n+\n+/* A shortcut for calling log from a context/result, handling the common\n+   case where the underlying logger is NULL via a no-op.  */\n+\n+inline void\n+log_user::log (const char *fmt, ...)\n+{\n+  if (m_logger)\n+    {\n+      va_list ap;\n+      va_start (ap, fmt);\n+      m_logger->log_va (fmt, ap);\n+      va_end (ap);\n+    }\n+}\n+\n+/* A shortcut for recording entry into a scope from a context/result,\n+   handling the common case where the underlying logger is NULL via\n+   a no-op.  */\n+\n+inline void\n+log_user::enter_scope (const char *scope_name)\n+{\n+  if (m_logger)\n+    m_logger->enter_scope (scope_name);\n+}\n+\n+/* A shortcut for recording exit from a scope from a context/result,\n+   handling the common case where the underlying logger is NULL via\n+   a no-op.  */\n+\n+inline void\n+log_user::exit_scope (const char *scope_name)\n+{\n+  if (m_logger)\n+    m_logger->exit_scope (scope_name);\n+}\n+\n+} // namespace gcc::jit\n+\n+} // namespace gcc\n+\n+/* If the given logger is non-NULL, log entry/exit of this scope to\n+   it, identifying it using __PRETTY_FUNCTION__.  */\n+\n+#define JIT_LOG_SCOPE(LOGGER) \\\n+  gcc::jit::log_scope s (LOGGER, __PRETTY_FUNCTION__)\n+\n+/* If the given logger is non-NULL, log entry/exit of this scope to\n+   it, identifying it using __func__.  */\n+\n+#define JIT_LOG_FUNC(LOGGER) \\\n+  gcc::jit::log_scope s (LOGGER, __func__)\n+\n+#endif /* JIT_LOGGING_H */"}, {"sha": "a8a281a66843fb27bd562805d739744e056658ab", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"context.h\"\n \n #include \"jit-common.h\"\n+#include \"jit-logging.h\"\n #include \"jit-playback.h\"\n #include \"jit-result.h\"\n #include \"jit-builtins.h\"\n@@ -86,11 +87,13 @@ namespace jit {\n /* The constructor for gcc::jit::playback::context.  */\n \n playback::context::context (recording::context *ctxt)\n-  : m_recording_ctxt (ctxt),\n+  : log_user (ctxt->get_logger ()),\n+    m_recording_ctxt (ctxt),\n     m_tempdir (NULL),\n     m_char_array_type_node (NULL),\n     m_const_char_ptr (NULL)\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   m_functions.create (0);\n   m_source_files.create (0);\n   m_cached_locations.create (0);\n@@ -100,6 +103,7 @@ playback::context::context (recording::context *ctxt)\n \n playback::context::~context ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   if (m_tempdir)\n     delete m_tempdir;\n   m_functions.release ();\n@@ -1219,6 +1223,8 @@ build_stmt_list ()\n   int i;\n   block *b;\n \n+  JIT_LOG_SCOPE (m_ctxt->get_logger ());\n+\n   FOR_EACH_VEC_ELT (m_blocks, i, b)\n     {\n       int j;\n@@ -1244,6 +1250,8 @@ void\n playback::function::\n postprocess ()\n {\n+  JIT_LOG_SCOPE (m_ctxt->get_logger ());\n+\n   if (m_ctxt->get_bool_option (GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE))\n     debug_tree (m_stmt_list);\n \n@@ -1538,6 +1546,8 @@ result *\n playback::context::\n compile ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n+\n   const char *ctxt_progname;\n   result *result_obj = NULL;\n \n@@ -1572,16 +1582,23 @@ compile ()\n \n   /* This runs the compiler.  */\n   toplev toplev (false);\n+  enter_scope (\"toplev::main\");\n+  if (get_logger ())\n+    for (unsigned i = 0; i < fake_args.length (); i++)\n+      get_logger ()->log (\"argv[%i]: %s\", i, fake_args[i]);\n   toplev.main (fake_args.length (),\n \t       const_cast <char **> (fake_args.address ()));\n+  exit_scope (\"toplev::main\");\n \n   /* Extracting dumps makes use of the gcc::dump_manager, hence we\n      need to do it between toplev::main (which creates the dump manager)\n      and toplev::finalize (which deletes it).  */\n   extract_any_requested_dumps (&requested_dumps);\n \n   /* Clean up the compiler.  */\n+  enter_scope (\"toplev::finalize\");\n   toplev.finalize ();\n+  exit_scope (\"toplev::finalize\");\n \n   /* Ideally we would release the jit mutex here, but we can't yet since\n      followup activities use timevars, which are global state.  */\n@@ -1622,6 +1639,7 @@ void\n playback::context::acquire_mutex ()\n {\n   /* Acquire the big GCC mutex. */\n+  JIT_LOG_SCOPE (get_logger ());\n   pthread_mutex_lock (&jit_mutex);\n   gcc_assert (NULL == active_playback_ctxt);\n   active_playback_ctxt = this;\n@@ -1633,6 +1651,7 @@ void\n playback::context::release_mutex ()\n {\n   /* Release the big GCC mutex. */\n+  JIT_LOG_SCOPE (get_logger ());\n   gcc_assert (active_playback_ctxt == this);\n   active_playback_ctxt = NULL;\n   pthread_mutex_unlock (&jit_mutex);\n@@ -1647,6 +1666,8 @@ make_fake_args (vec <char *> *argvec,\n \t\tconst char *ctxt_progname,\n \t\tvec <recording::requested_dump> *requested_dumps)\n {\n+  JIT_LOG_SCOPE (get_logger ());\n+\n #define ADD_ARG(arg) argvec->safe_push (xstrdup (arg))\n #define ADD_ARG_TAKE_OWNERSHIP(arg) argvec->safe_push (arg)\n \n@@ -1734,6 +1755,8 @@ void\n playback::context::\n extract_any_requested_dumps (vec <recording::requested_dump> *requested_dumps)\n {\n+  JIT_LOG_SCOPE (get_logger ());\n+\n   int i;\n   recording::requested_dump *d;\n   FOR_EACH_VEC_ELT (*requested_dumps, i, d)\n@@ -1819,6 +1842,7 @@ void\n playback::context::\n convert_to_dso (const char *ctxt_progname)\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   /* Currently this lumps together both assembling and linking into\n      TV_ASSEMBLE.  */\n   auto_timevar assemble_timevar (TV_ASSEMBLE);\n@@ -1852,6 +1876,10 @@ convert_to_dso (const char *ctxt_progname)\n   /* pex_one's error-handling requires pname to be non-NULL.  */\n   gcc_assert (ctxt_progname);\n \n+  if (get_logger ())\n+    for (unsigned i = 0; i < argvec.length (); i++)\n+      get_logger ()->log (\"argv[%i]: %s\", i, argvec[i]);\n+\n   errmsg = pex_one (PEX_SEARCH, /* int flags, */\n \t\t    gcc_driver_name,\n \t\t    const_cast <char *const *> (argvec.address ()),\n@@ -1892,6 +1920,7 @@ result *\n playback::context::\n dlopen_built_dso ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   auto_timevar load_timevar (TV_LOAD);\n   void *handle = NULL;\n   const char *error = NULL;\n@@ -1906,7 +1935,7 @@ dlopen_built_dso ()\n     add_error (NULL, \"%s\", error);\n   }\n   if (handle)\n-    result_obj = new result (handle);\n+    result_obj = new result (get_logger (), handle);\n   else\n     result_obj = NULL;\n \n@@ -1923,6 +1952,7 @@ void\n playback::context::\n replay ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   /* Adapted from c-common.c:c_common_nodes_and_builtins.  */\n   tree array_domain_type = build_index_type (size_int (200));\n   m_char_array_type_node\n@@ -1984,6 +2014,7 @@ void\n playback::context::\n dump_generated_code ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   char buf[4096];\n   size_t sz;\n   FILE *f_in = fopen (get_path_s_file (), \"r\");\n@@ -2069,6 +2100,7 @@ handle_locations ()\n      imposed by the linemap API.\n \n      line_table is a global.  */\n+  JIT_LOG_SCOPE (get_logger ());\n   int i;\n   source_file *file;\n "}, {"sha": "3a03b3a99876806915654241a188e97a58ccfb1f", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -35,7 +35,7 @@ namespace jit {\n \n namespace playback {\n \n-class context\n+class context : public log_user\n {\n public:\n   context (::gcc::jit::recording::context *ctxt);"}, {"sha": "a872063630acb1632607b141baab8109274b7cb3", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"jit-common.h\"\n #include \"jit-builtins.h\"\n+#include \"jit-logging.h\"\n #include \"jit-recording.h\"\n #include \"jit-playback.h\"\n \n@@ -169,7 +170,8 @@ recording::playback_block (recording::block *b)\n    gcc_jit_context_acquire and gcc_jit_context_new_child_context.  */\n \n recording::context::context (context *parent_ctxt)\n-  : m_parent_ctxt (parent_ctxt),\n+  : log_user (NULL),\n+    m_parent_ctxt (parent_ctxt),\n     m_error_count (0),\n     m_first_error_str (NULL),\n     m_owns_first_error_str (false),\n@@ -195,6 +197,7 @@ recording::context::context (context *parent_ctxt)\n       memcpy (m_bool_options,\n \t      parent_ctxt->m_bool_options,\n \t      sizeof (m_bool_options));\n+      set_logger (parent_ctxt->get_logger ());\n     }\n   else\n     {\n@@ -211,6 +214,7 @@ recording::context::context (context *parent_ctxt)\n \n recording::context::~context ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   int i;\n   memento *m;\n   FOR_EACH_VEC_ELT (m_mementos, i, m)\n@@ -245,6 +249,7 @@ recording::context::record (memento *m)\n void\n recording::context::replay_into (replayer *r)\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   int i;\n   memento *m;\n \n@@ -302,6 +307,7 @@ recording::context::replay_into (replayer *r)\n void\n recording::context::disassociate_from_playback ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n   int i;\n   memento *m;\n \n@@ -904,6 +910,8 @@ recording::context::enable_dump (const char *dumpname,\n result *\n recording::context::compile ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n+\n   validate ();\n \n   if (errors_occurred ())\n@@ -940,6 +948,8 @@ recording::context::add_error_va (location *loc, const char *fmt, va_list ap)\n   const char *errmsg;\n   bool has_ownership;\n \n+  JIT_LOG_SCOPE (get_logger ());\n+\n   vasprintf (&malloced_msg, fmt, ap);\n   if (malloced_msg)\n     {\n@@ -951,6 +961,8 @@ recording::context::add_error_va (location *loc, const char *fmt, va_list ap)\n       errmsg = \"out of memory generating error message\";\n       has_ownership = false;\n     }\n+  if (get_logger ())\n+    get_logger ()->log (\"error %i: %s\", m_error_count, errmsg);\n \n   const char *ctxt_progname =\n     get_str_option (GCC_JIT_STR_OPTION_PROGNAME);\n@@ -1060,6 +1072,8 @@ recording::context::get_all_requested_dumps (vec <recording::requested_dump> *ou\n void\n recording::context::validate ()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n+\n   if (m_parent_ctxt)\n     m_parent_ctxt->validate ();\n "}, {"sha": "dddf0db23da30ffd36f54288f4a4cece9e5398f5", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define JIT_RECORDING_H\n \n #include \"jit-common.h\"\n+#include \"jit-logging.h\"\n \n namespace gcc {\n \n@@ -53,7 +54,7 @@ struct requested_dump\n };\n \n /* A JIT-compilation context.  */\n-class context\n+class context : public log_user\n {\n public:\n   context (context *parent_ctxt);"}, {"sha": "67699e0b19809e829ab5d1ce3b2b6126469ec02a", "filename": "gcc/jit/jit-result.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-result.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-result.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-result.c?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -21,6 +21,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+\n+#include \"jit-common.h\"\n+#include \"jit-logging.h\"\n #include \"jit-result.h\"\n \n namespace gcc {\n@@ -29,9 +32,11 @@ namespace jit {\n /* Constructor for gcc::jit::result.  */\n \n result::\n-result(void *dso_handle)\n-  : m_dso_handle(dso_handle)\n+result(logger *logger, void *dso_handle) :\n+  log_user (logger),\n+  m_dso_handle (dso_handle)\n {\n+  JIT_LOG_SCOPE (get_logger ());\n }\n \n /* gcc::jit::result's destructor.\n@@ -40,6 +45,8 @@ result(void *dso_handle)\n \n result::~result()\n {\n+  JIT_LOG_SCOPE (get_logger ());\n+\n   dlclose (m_dso_handle);\n }\n \n@@ -53,6 +60,8 @@ void *\n result::\n get_code (const char *funcname)\n {\n+  JIT_LOG_SCOPE (get_logger ());\n+\n   void *code;\n   const char *error;\n "}, {"sha": "59d28a1a364474c9ddce958263783e4ededecfa3", "filename": "gcc/jit/jit-result.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-result.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Fjit-result.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-result.h?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -26,10 +26,10 @@ namespace gcc {\n namespace jit {\n \n /* The result of JIT-compilation.  */\n-class result\n+class result : public log_user\n {\n public:\n-  result(void *dso_handle);\n+  result(logger *logger, void *dso_handle);\n \n   virtual ~result();\n "}, {"sha": "600219ce853d3f71bb04897403ae3aa243bcba18", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -102,6 +102,10 @@ namespace gccjit\n     void dump_to_file (const std::string &path,\n \t\t       bool update_locations);\n \n+    void set_logfile (FILE *logfile,\n+\t\t      int flags,\n+\t\t      int verbosity);\n+\n     void set_str_option (enum gcc_jit_str_option opt,\n \t\t\t const char *value);\n \n@@ -540,6 +544,17 @@ context::dump_to_file (const std::string &path,\n \t\t\t\tupdate_locations);\n }\n \n+inline void\n+context::set_logfile (FILE *logfile,\n+\t\t      int flags,\n+\t\t      int verbosity)\n+{\n+  gcc_jit_context_set_logfile (m_inner_ctxt,\n+\t\t\t       logfile,\n+\t\t\t       flags,\n+\t\t\t       verbosity);\n+}\n+\n inline void\n context::set_str_option (enum gcc_jit_str_option opt,\n \t\t\t const char *value)"}, {"sha": "c043961701431ebb48ce57bfa696326f7c619700", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 115, "deletions": 18, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"libgccjit.h\"\n #include \"jit-common.h\"\n+#include \"jit-logging.h\"\n #include \"jit-recording.h\"\n #include \"jit-result.h\"\n \n@@ -323,7 +324,9 @@ compatible_types (gcc::jit::recording::type *ltype,\n gcc_jit_context *\n gcc_jit_context_acquire (void)\n {\n-  return new gcc_jit_context (NULL);\n+  gcc_jit_context *ctxt = new gcc_jit_context (NULL);\n+  ctxt->log (\"new top-level ctxt: %p\", (void *)ctxt);\n+  return ctxt;\n }\n \n /* Public entrypoint for releasing a gcc_jit_context.\n@@ -333,6 +336,9 @@ gcc_jit_context_acquire (void)\n void\n gcc_jit_context_release (gcc_jit_context *ctxt)\n {\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL ctxt\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  ctxt->log (\"deleting ctxt: %p\", (void *)ctxt);\n   delete ctxt;\n }\n \n@@ -345,7 +351,12 @@ gcc_jit_context_release (gcc_jit_context *ctxt)\n gcc_jit_context *\n gcc_jit_context_new_child_context (gcc_jit_context *parent_ctxt)\n {\n-  return new gcc_jit_context (parent_ctxt);\n+  RETURN_NULL_IF_FAIL (parent_ctxt, NULL, NULL, \"NULL parent ctxt\");\n+  JIT_LOG_FUNC (parent_ctxt->get_logger ());\n+  parent_ctxt->log (\"parent_ctxt: %p\", (void *)parent_ctxt);\n+  gcc_jit_context *child_ctxt = new gcc_jit_context (parent_ctxt);\n+  child_ctxt->log (\"new child_ctxt: %p\", (void *)child_ctxt);\n+  return child_ctxt;\n }\n \n /* Public entrypoint.  See description in libgccjit.h.\n@@ -361,7 +372,7 @@ gcc_jit_context_new_location (gcc_jit_context *ctxt,\n \t\t\t      int column)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n-\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   return (gcc_jit_location *)ctxt->new_location (filename, line, column);\n }\n \n@@ -404,6 +415,7 @@ gcc_jit_context_get_type (gcc_jit_context *ctxt,\n \t\t\t  enum gcc_jit_types type)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL_PRINTF1 (\n     (type >= GCC_JIT_TYPE_VOID\n      && type <= GCC_JIT_TYPE_FILE_PTR),\n@@ -425,6 +437,7 @@ gcc_jit_context_get_int_type (gcc_jit_context *ctxt,\n \t\t\t      int num_bytes, int is_signed)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL (num_bytes >= 0, ctxt, NULL, \"negative size\");\n \n   return (gcc_jit_type *)ctxt->get_int_type (num_bytes, is_signed);\n@@ -485,6 +498,7 @@ gcc_jit_context_new_array_type (gcc_jit_context *ctxt,\n \t\t\t\tint num_elements)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (element_type, ctxt, loc, \"NULL type\");\n   RETURN_NULL_IF_FAIL (num_elements >= 0, ctxt, NULL, \"negative size\");\n@@ -507,6 +521,7 @@ gcc_jit_context_new_field (gcc_jit_context *ctxt,\n \t\t\t   const char *name)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n   RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n@@ -543,6 +558,7 @@ gcc_jit_context_new_struct_type (gcc_jit_context *ctxt,\n \t\t\t\t gcc_jit_field **fields)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n   if (num_fields)\n@@ -578,6 +594,7 @@ gcc_jit_context_new_opaque_struct (gcc_jit_context *ctxt,\n \t\t\t\t   const char *name)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n \n@@ -611,8 +628,9 @@ gcc_jit_struct_set_fields (gcc_jit_struct *struct_type,\n \t\t\t   gcc_jit_field **fields)\n {\n   RETURN_IF_FAIL (struct_type, NULL, loc, \"NULL struct_type\");\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = struct_type->m_ctxt;\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_IF_FAIL_PRINTF1 (\n     NULL == struct_type->get_fields (), ctxt, loc,\n     \"%s already has had fields set\",\n@@ -649,6 +667,7 @@ gcc_jit_context_new_union_type (gcc_jit_context *ctxt,\n \t\t\t\tgcc_jit_field **fields)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n   if (num_fields)\n@@ -687,6 +706,7 @@ gcc_jit_context_new_function_ptr_type (gcc_jit_context *ctxt,\n \t\t\t\t       int is_variadic)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (return_type, ctxt, loc, \"NULL return_type\");\n   RETURN_NULL_IF_FAIL (\n@@ -720,6 +740,7 @@ gcc_jit_context_new_param (gcc_jit_context *ctxt,\n \t\t\t   const char *name)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n   RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n@@ -785,6 +806,7 @@ gcc_jit_context_new_function (gcc_jit_context *ctxt,\n \t\t\t      int is_variadic)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL_PRINTF1 (\n     ((kind >= GCC_JIT_FUNCTION_EXPORTED)\n@@ -846,6 +868,7 @@ gcc_jit_context_get_builtin_function (gcc_jit_context *ctxt,\n \t\t\t\t      const char *name)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL (name, ctxt, NULL, \"NULL name\");\n \n   return static_cast <gcc_jit_function *> (ctxt->get_builtin_function (name));\n@@ -876,6 +899,7 @@ gcc_jit_function_get_param (gcc_jit_function *func, int index)\n {\n   RETURN_NULL_IF_FAIL (func, NULL, NULL, \"NULL function\");\n   gcc::jit::recording::context *ctxt = func->m_ctxt;\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL (index >= 0, ctxt, NULL, \"negative index\");\n   int num_params = func->get_params ().length ();\n   RETURN_NULL_IF_FAIL_PRINTF3 (index < num_params,\n@@ -900,6 +924,7 @@ gcc_jit_function_dump_to_dot (gcc_jit_function *func,\n {\n   RETURN_IF_FAIL (func, NULL, NULL, \"NULL function\");\n   gcc::jit::recording::context *ctxt = func->m_ctxt;\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_IF_FAIL (path, ctxt, NULL, \"NULL path\");\n \n   func->dump_to_dot (path);\n@@ -916,6 +941,7 @@ gcc_jit_function_new_block (gcc_jit_function *func,\n \t\t\t    const char *name)\n {\n   RETURN_NULL_IF_FAIL (func, NULL, NULL, \"NULL function\");\n+  JIT_LOG_FUNC (func->get_context ()->get_logger ());\n   RETURN_NULL_IF_FAIL (func->get_kind () != GCC_JIT_FUNCTION_IMPORTED,\n \t\t       func->get_context (), NULL,\n \t\t       \"cannot add block to an imported function\");\n@@ -965,6 +991,7 @@ gcc_jit_context_new_global (gcc_jit_context *ctxt,\n \t\t\t    const char *name)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n   RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n@@ -1050,6 +1077,7 @@ gcc_jit_context_new_rvalue_from_int (gcc_jit_context *ctxt,\n \t\t\t\t     int value)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE (ctxt, numeric_type);\n \n   return (gcc_jit_rvalue *)ctxt->new_rvalue_from_int (numeric_type, value);\n@@ -1066,6 +1094,7 @@ gcc_jit_context_zero (gcc_jit_context *ctxt,\n \t\t      gcc_jit_type *numeric_type)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE (ctxt, numeric_type);\n \n   return gcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 0);\n@@ -1082,6 +1111,7 @@ gcc_jit_context_one (gcc_jit_context *ctxt,\n \t\t     gcc_jit_type *numeric_type)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE (ctxt, numeric_type);\n \n   return gcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 1);\n@@ -1099,6 +1129,7 @@ gcc_jit_context_new_rvalue_from_double (gcc_jit_context *ctxt,\n \t\t\t\t\tdouble value)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL_NONNULL_NUMERIC_TYPE (ctxt, numeric_type);\n \n   return (gcc_jit_rvalue *)ctxt->new_rvalue_from_double (numeric_type, value);\n@@ -1116,6 +1147,7 @@ gcc_jit_context_new_rvalue_from_ptr (gcc_jit_context *ctxt,\n \t\t\t\t     void *value)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL (pointer_type, ctxt, NULL, \"NULL type\");\n   RETURN_NULL_IF_FAIL_PRINTF1 (\n     pointer_type->is_pointer (),\n@@ -1137,6 +1169,7 @@ gcc_jit_context_null (gcc_jit_context *ctxt,\n \t\t      gcc_jit_type *pointer_type)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL (pointer_type, ctxt, NULL, \"NULL type\");\n   RETURN_NULL_IF_FAIL_PRINTF1 (\n     pointer_type->is_pointer (),\n@@ -1158,6 +1191,7 @@ gcc_jit_context_new_string_literal (gcc_jit_context *ctxt,\n \t\t\t\t    const char *value)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_NULL_IF_FAIL (value, ctxt, NULL, \"NULL value\");\n \n   return (gcc_jit_rvalue *)ctxt->new_string_literal (value);\n@@ -1177,6 +1211,7 @@ gcc_jit_context_new_unary_op (gcc_jit_context *ctxt,\n \t\t\t      gcc_jit_rvalue *rvalue)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL_PRINTF1 (\n     (op >= GCC_JIT_UNARY_OP_MINUS\n@@ -1215,6 +1250,7 @@ gcc_jit_context_new_binary_op (gcc_jit_context *ctxt,\n \t\t\t       gcc_jit_rvalue *a, gcc_jit_rvalue *b)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL_PRINTF1 (\n     valid_binary_op_p (op),\n@@ -1250,6 +1286,7 @@ gcc_jit_context_new_comparison (gcc_jit_context *ctxt,\n \t\t\t\tgcc_jit_rvalue *a, gcc_jit_rvalue *b)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL_PRINTF1 (\n     (op >= GCC_JIT_COMPARISON_EQ\n@@ -1285,6 +1322,7 @@ gcc_jit_context_new_call (gcc_jit_context *ctxt,\n \t\t\t  int numargs , gcc_jit_rvalue **args)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (func, ctxt, loc, \"NULL function\");\n   if (numargs)\n@@ -1357,6 +1395,7 @@ gcc_jit_context_new_call_through_ptr (gcc_jit_context *ctxt,\n \t\t\t\t      int numargs, gcc_jit_rvalue **args)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (fn_ptr, ctxt, loc, \"NULL fn_ptr\");\n   if (numargs)\n@@ -1486,6 +1525,7 @@ gcc_jit_context_new_cast (gcc_jit_context *ctxt,\n \t\t\t  gcc_jit_type *type)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n   RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n@@ -1513,6 +1553,7 @@ gcc_jit_context_new_array_access (gcc_jit_context *ctxt,\n \t\t\t\t  gcc_jit_rvalue *index)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (ptr, ctxt, loc, \"NULL ptr\");\n   RETURN_NULL_IF_FAIL (index, ctxt, loc, \"NULL index\");\n@@ -1572,8 +1613,9 @@ gcc_jit_lvalue_access_field (gcc_jit_lvalue *struct_,\n \t\t\t     gcc_jit_field *field)\n {\n   RETURN_NULL_IF_FAIL (struct_, NULL, loc, \"NULL struct\");\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = struct_->m_ctxt;\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (field, ctxt, loc, \"NULL field\");\n   RETURN_NULL_IF_FAIL_PRINTF1 (field->get_container (), field->m_ctxt, loc,\n \t\t\t       \"field %s has not been placed in a struct\",\n@@ -1594,8 +1636,9 @@ gcc_jit_rvalue_access_field (gcc_jit_rvalue *struct_,\n \t\t\t     gcc_jit_field *field)\n {\n   RETURN_NULL_IF_FAIL (struct_, NULL, loc, \"NULL struct\");\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = struct_->m_ctxt;\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (field, ctxt, loc, \"NULL field\");\n   RETURN_NULL_IF_FAIL_PRINTF1 (field->get_container (), field->m_ctxt, loc,\n \t\t\t       \"field %s has not been placed in a struct\",\n@@ -1616,6 +1659,7 @@ gcc_jit_rvalue_dereference_field (gcc_jit_rvalue *ptr,\n \t\t\t\t  gcc_jit_field *field)\n {\n   RETURN_NULL_IF_FAIL (ptr, NULL, loc, \"NULL ptr\");\n+  JIT_LOG_FUNC (ptr->get_context ()->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (field, NULL, loc, \"NULL field\");\n   gcc::jit::recording::type *underlying_type =\n@@ -1652,6 +1696,7 @@ gcc_jit_rvalue_dereference (gcc_jit_rvalue *rvalue,\n \t\t\t    gcc_jit_location *loc)\n {\n   RETURN_NULL_IF_FAIL (rvalue, NULL, loc, \"NULL rvalue\");\n+  JIT_LOG_FUNC (rvalue->get_context ()->get_logger ());\n   /* LOC can be NULL.  */\n \n   gcc::jit::recording::type *underlying_type =\n@@ -1684,6 +1729,7 @@ gcc_jit_lvalue_get_address (gcc_jit_lvalue *lvalue,\n \t\t\t    gcc_jit_location *loc)\n {\n   RETURN_NULL_IF_FAIL (lvalue, NULL, loc, \"NULL lvalue\");\n+  JIT_LOG_FUNC (lvalue->get_context ()->get_logger ());\n   /* LOC can be NULL.  */\n \n   return (gcc_jit_rvalue *)lvalue->get_address (loc);\n@@ -1701,8 +1747,9 @@ gcc_jit_function_new_local (gcc_jit_function *func,\n \t\t\t    const char *name)\n {\n   RETURN_NULL_IF_FAIL (func, NULL, loc, \"NULL function\");\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = func->m_ctxt;\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_NULL_IF_FAIL (func->get_kind () != GCC_JIT_FUNCTION_IMPORTED,\n \t\t       ctxt, loc,\n \t\t       \"Cannot add locals to an imported function\");\n@@ -1723,8 +1770,9 @@ gcc_jit_block_add_eval (gcc_jit_block *block,\n \t\t\tgcc_jit_rvalue *rvalue)\n {\n   RETURN_IF_NOT_VALID_BLOCK (block, loc);\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n \n   return block->add_eval (loc, rvalue);\n@@ -1743,8 +1791,9 @@ gcc_jit_block_add_assignment (gcc_jit_block *block,\n \t\t\t      gcc_jit_rvalue *rvalue)\n {\n   RETURN_IF_NOT_VALID_BLOCK (block, loc);\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_IF_FAIL (lvalue, ctxt, loc, \"NULL lvalue\");\n   RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n   RETURN_IF_FAIL_PRINTF4 (\n@@ -1775,8 +1824,9 @@ gcc_jit_block_add_assignment_op (gcc_jit_block *block,\n \t\t\t\t gcc_jit_rvalue *rvalue)\n {\n   RETURN_IF_NOT_VALID_BLOCK (block, loc);\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_IF_FAIL (lvalue, ctxt, loc, \"NULL lvalue\");\n   RETURN_IF_FAIL_PRINTF1 (\n     valid_binary_op_p (op),\n@@ -1814,8 +1864,9 @@ gcc_jit_block_end_with_conditional (gcc_jit_block *block,\n \t\t\t\t    gcc_jit_block *on_false)\n {\n   RETURN_IF_NOT_VALID_BLOCK (block, loc);\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_IF_FAIL (boolval, ctxt, loc, \"NULL boolval\");\n   RETURN_IF_FAIL_PRINTF2 (\n    is_bool (boolval), ctxt, loc,\n@@ -1860,8 +1911,9 @@ gcc_jit_block_add_comment (gcc_jit_block *block,\n \t\t\t   const char *text)\n {\n   RETURN_IF_NOT_VALID_BLOCK (block, loc);\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_IF_FAIL (text, ctxt, loc, \"NULL text\");\n \n   block->add_comment (loc, text);\n@@ -1879,8 +1931,9 @@ gcc_jit_block_end_with_jump (gcc_jit_block *block,\n \t\t\t     gcc_jit_block *target)\n {\n   RETURN_IF_NOT_VALID_BLOCK (block, loc);\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   RETURN_IF_FAIL (target, ctxt, loc, \"NULL target\");\n   RETURN_IF_FAIL_PRINTF4 (\n     block->get_function () == target->get_function (),\n@@ -1908,8 +1961,9 @@ gcc_jit_block_end_with_return (gcc_jit_block *block,\n \t\t\t       gcc_jit_rvalue *rvalue)\n {\n   RETURN_IF_NOT_VALID_BLOCK (block, loc);\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   gcc::jit::recording::function *func = block->get_function ();\n   RETURN_IF_FAIL (rvalue, ctxt, loc, \"NULL rvalue\");\n   RETURN_IF_FAIL_PRINTF4 (\n@@ -1938,8 +1992,9 @@ gcc_jit_block_end_with_void_return (gcc_jit_block *block,\n \t\t\t\t    gcc_jit_location *loc)\n {\n   RETURN_IF_NOT_VALID_BLOCK (block, loc);\n-  /* LOC can be NULL.  */\n   gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n   gcc::jit::recording::function *func = block->get_function ();\n   RETURN_IF_FAIL_PRINTF2 (\n     func->get_return_type () == ctxt->get_type (GCC_JIT_TYPE_VOID),\n@@ -1968,6 +2023,7 @@ gcc_jit_context_set_str_option (gcc_jit_context *ctxt,\n \t\t\t\tconst char *value)\n {\n   RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* opt is checked by the inner function.\n      value can be NULL.  */\n \n@@ -1986,6 +2042,7 @@ gcc_jit_context_set_int_option (gcc_jit_context *ctxt,\n \t\t\t\tint value)\n {\n   RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* opt is checked by the inner function.  */\n \n   ctxt->set_int_option (opt, value);\n@@ -2003,6 +2060,7 @@ gcc_jit_context_set_bool_option (gcc_jit_context *ctxt,\n \t\t\t\t int value)\n {\n   RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   /* opt is checked by the inner function.  */\n \n   ctxt->set_bool_option (opt, value);\n@@ -2020,6 +2078,7 @@ gcc_jit_context_enable_dump (gcc_jit_context *ctxt,\n \t\t\t     char **out_ptr)\n {\n   RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_IF_FAIL (dumpname, ctxt, NULL, \"NULL dumpname\");\n   RETURN_IF_FAIL (out_ptr, ctxt, NULL, \"NULL out_ptr\");\n \n@@ -2037,7 +2096,16 @@ gcc_jit_context_compile (gcc_jit_context *ctxt)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n \n-  return (gcc_jit_result *)ctxt->compile ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+\n+  ctxt->log (\"compiling ctxt: %p\", (void *)ctxt);\n+\n+  gcc_jit_result *result = (gcc_jit_result *)ctxt->compile ();\n+\n+  ctxt->log (\"%s: returning (gcc_jit_result *)%p\",\n+\t     __func__, (void *)result);\n+\n+  return result;\n }\n \n /* Public entrypoint.  See description in libgccjit.h.\n@@ -2052,10 +2120,32 @@ gcc_jit_context_dump_to_file (gcc_jit_context *ctxt,\n \t\t\t      int update_locations)\n {\n   RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n   RETURN_IF_FAIL (path, ctxt, NULL, \"NULL path\");\n   ctxt->dump_to_file (path, update_locations);\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.  */\n+\n+void\n+gcc_jit_context_set_logfile (gcc_jit_context *ctxt,\n+\t\t\t     FILE *logfile,\n+\t\t\t     int flags,\n+\t\t\t     int verbosity)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  RETURN_IF_FAIL ((flags == 0), ctxt, NULL, \"flags must be 0 for now\");\n+  RETURN_IF_FAIL ((verbosity == 0), ctxt, NULL, \"verbosity must be 0 for now\");\n+\n+  gcc::jit::logger *logger;\n+  if (logfile)\n+    logger = new gcc::jit::logger (logfile, flags, verbosity);\n+  else\n+    logger = NULL;\n+  ctxt->set_logger (logger);\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the\n@@ -2066,6 +2156,7 @@ const char *\n gcc_jit_context_get_first_error (gcc_jit_context *ctxt)\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n \n   return ctxt->get_first_error ();\n }\n@@ -2080,9 +2171,14 @@ gcc_jit_result_get_code (gcc_jit_result *result,\n \t\t\t const char *fnname)\n {\n   RETURN_NULL_IF_FAIL (result, NULL, NULL, \"NULL result\");\n+  JIT_LOG_FUNC (result->get_logger ());\n   RETURN_NULL_IF_FAIL (fnname, NULL, NULL, \"NULL fnname\");\n \n-  return result->get_code (fnname);\n+  result->log (\"locating fnname: %s\", fnname);\n+  void *code = result->get_code (fnname);\n+  result->log (\"%s: returning (void *)%p\", __func__, code);\n+\n+  return code;\n }\n \n /* Public entrypoint.  See description in libgccjit.h.\n@@ -2094,6 +2190,7 @@ void\n gcc_jit_result_release (gcc_jit_result *result)\n {\n   RETURN_IF_FAIL (result, NULL, NULL, \"NULL result\");\n-\n+  JIT_LOG_FUNC (result->get_logger ());\n+  result->log (\"deleting result: %p\", (void *)result);\n   delete result;\n }"}, {"sha": "91ca409d91d797642541d2f4a518598b59af43e8", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef LIBGCCJIT_H\n #define LIBGCCJIT_H\n \n+#include <stdio.h>\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif /* __cplusplus */\n@@ -254,6 +256,19 @@ gcc_jit_context_dump_to_file (gcc_jit_context *ctxt,\n \t\t\t      const char *path,\n \t\t\t      int update_locations);\n \n+/* To help with debugging; enable ongoing logging of the context's\n+   activity to the given FILE *.\n+\n+   The caller remains responsible for closing \"logfile\".\n+\n+   Params \"flags\" and \"verbosity\" are reserved for future use, and\n+   must both be 0 for now.  */\n+extern void\n+gcc_jit_context_set_logfile (gcc_jit_context *ctxt,\n+\t\t\t     FILE *logfile,\n+\t\t\t     int flags,\n+\t\t\t     int verbosity);\n+\n /* To be called after a compile, this gives the first error message\n    that occurred on the context.\n "}, {"sha": "267898c1dafae56fde4b40d5eceb6233db879fa8", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -65,6 +65,7 @@\n     gcc_jit_context_release;\n     gcc_jit_context_set_bool_option;\n     gcc_jit_context_set_int_option;\n+    gcc_jit_context_set_logfile;\n     gcc_jit_context_set_str_option;\n     gcc_jit_context_zero;\n     gcc_jit_field_as_object;"}, {"sha": "6ec4ba2ba32a05f9264c3df66acdce384370f5c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -1,3 +1,12 @@\n+2015-01-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (set_up_logging): New function.\n+\t(test_jit): Fail if gcc_jit_context_acquire fails.  Call\n+\tset_up_logging on the context, so that every testcase is\n+\tlogged to a particular file.\n+\t* jit.dg/test-nested-contexts.c (main): Open a logfile,\n+\tand call gcc_jit_context_set_logfile on the top-level context.\n+\n 2015-01-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/64338"}, {"sha": "1252af5e4c79412bd5ed14348a829edbbf4c5ea8", "filename": "gcc/testsuite/jit.dg/harness.h", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -251,15 +251,64 @@ static void set_options (gcc_jit_context *ctxt, const char *argv0)\n }\n \n #ifndef TEST_ESCHEWS_TEST_JIT\n+/* Set up logging to a logfile of the form \"test-FOO.exe.log.txt\".\n+\n+   For example,\n+     SRCDIR/gcc/testsuite/jit.dg/test-hello-world.c\n+   is built as:\n+     BUILDDIR/gcc/testsuite/jit/test-hello-world.c.exe\n+   and is logged to\n+     BUILDDIR/gcc/testsuite/jit/test-hello-world.c.exe.log.txt\n+\n+   The logfile must be closed by the caller.\n+\n+   Note that not every testcase enables logging.  */\n+static FILE *\n+set_up_logging (gcc_jit_context *ctxt, const char *argv0)\n+{\n+  const char *logfile_name_suffix = \".log.txt\";\n+  char *logfile_name = NULL;\n+  FILE *logfile = NULL;\n+\n+  /* Build a logfile name of the form \"test-FOO.exe.log.txt\".  */\n+  logfile_name = (char *)malloc (strlen (argv0)\n+\t\t\t\t + strlen (logfile_name_suffix)\n+\t\t\t\t + 1);\n+  if (!logfile_name)\n+    {\n+      fail (\"malloc failure\");\n+      return NULL;\n+    }\n+  strcpy (logfile_name, argv0);\n+  strcpy (logfile_name + strlen (argv0), logfile_name_suffix);\n+  logfile_name[strlen (argv0) + strlen (logfile_name_suffix)] = '\\0';\n+\n+  logfile = fopen (logfile_name, \"w\");\n+  CHECK_NON_NULL (logfile);\n+  free (logfile_name);\n+\n+  if (logfile)\n+    gcc_jit_context_set_logfile (ctxt, logfile, 0, 0);\n+\n+  return logfile;\n+}\n+\n /* Run one iteration of the test.  */\n static void\n test_jit (const char *argv0, void *user_data)\n {\n   gcc_jit_context *ctxt;\n+  FILE *logfile;\n   gcc_jit_result *result;\n \n   ctxt = gcc_jit_context_acquire ();\n-     /* FIXME: error-handling */\n+  if (!ctxt)\n+    {\n+      fail (\"gcc_jit_context_acquire failed\");\n+      return;\n+    }\n+\n+  logfile = set_up_logging (ctxt, argv0);\n \n   set_options (ctxt, argv0);\n \n@@ -275,6 +324,9 @@ test_jit (const char *argv0, void *user_data)\n \n   /* Once we're done with the code, this unloads the built .so file: */\n   gcc_jit_result_release (result);\n+\n+  if (logfile)\n+    fclose (logfile);\n }\n #endif /* #ifndef TEST_ESCHEWS_TEST_JIT */\n "}, {"sha": "81b1bb2cb7fc7b8d5f75e91e2b3b3f1d2567bab2", "filename": "gcc/testsuite/jit.dg/test-nested-contexts.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4c16eb849c4c06009186a4df409186d46f5e8d/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c?ref=eb4c16eb849c4c06009186a4df409186d46f5e8d", "patch": "@@ -532,6 +532,10 @@ main (int argc, char **argv)\n   /* We do the whole thing multiple times to shake out state-management\n      issues in the underlying code.  */\n \n+  FILE *logfile = fopen (\"test-nested-contexts.c.exe.log.txt\", \"w\");\n+  if (!logfile)\n+    fail (\"error opening logfile\");\n+\n   for (i = 1; i <= NUM_TOP_ITERATIONS; i++)\n     {\n       /* Create the top-level context.  */\n@@ -544,6 +548,9 @@ main (int argc, char **argv)\n       memset (&top_level, 0, sizeof (top_level));\n \n       top_level.ctxt = gcc_jit_context_acquire ();\n+      gcc_jit_context_set_logfile (top_level.ctxt,\n+\t\t\t\t   logfile,\n+\t\t\t\t   0, 0);\n       set_options (top_level.ctxt, argv[0]);\n \n       make_types (&top_level);\n@@ -635,6 +642,9 @@ main (int argc, char **argv)\n       gcc_jit_context_release (top_level.ctxt);\n    }\n \n+  if (logfile)\n+    fclose (logfile);\n+\n   totals ();\n \n   return 0;"}]}