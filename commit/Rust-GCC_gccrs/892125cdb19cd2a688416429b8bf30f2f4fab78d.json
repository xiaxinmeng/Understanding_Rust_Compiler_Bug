{"sha": "892125cdb19cd2a688416429b8bf30f2f4fab78d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkyMTI1Y2RiMTljZDJhNjg4NDE2NDI5YjhiZjMwZjJmNGZhYjc4ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-15T10:39:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-15T10:39:11Z"}, "message": "[multiple changes]\n\n2009-07-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_warn.adb (Warn_On_Constant_Condition): Handle properly constant\n\tconditions of a derived boolean type.\n\tMinor reformatting\n\n2009-07-15  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat1drv.adb: Initialize SCO tables\n\n\t* par-load.adb: Call SCO_Record for main unit spec\n\n\t* par.adb: Make call to SCO_Record for main unit\n\n\t* par_sco.adb (Unit_Table): Change format to facilitate sort\n\t(Process_Decisions): New procedure with list argument\n\t(Traverse_Generic_Package_Declaration): New procedure\n\t(Initialize): New procedure, replaces Init\n\t(SCO_Output): Sort unit table before output\n\t(SCO_Record): Avoid duplications\n\t(SCO_Record): Handle remaining cases of units\n\t(Traverse_Declarations_Or_Statements): Handle generics\n\n\t* par_sco.ads (Initialize): New peocedure (replaces Init)\n\n\t* sem_ch10.adb (Analyze_Proper_Body): Make call to SCO_Record for\n\tsubunit.\n\n2009-07-15  Arnaud Charlet  <charlet@adacore.com>\n\n\t* debug.adb: Add -gnatd.J switch for now to support scil generation in\n\tparallel. Add missing doc for -gnatd.I and -gnatd.O\n\nFrom-SVN: r149679", "tree": {"sha": "a0ab72ef2e31cf8c6f6fc5c246bde0729f1611a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0ab72ef2e31cf8c6f6fc5c246bde0729f1611a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/892125cdb19cd2a688416429b8bf30f2f4fab78d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/892125cdb19cd2a688416429b8bf30f2f4fab78d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/892125cdb19cd2a688416429b8bf30f2f4fab78d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/892125cdb19cd2a688416429b8bf30f2f4fab78d/comments", "author": null, "committer": null, "parents": [{"sha": "671eb58697ed6f7069e657f880e03874d1b9c6b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671eb58697ed6f7069e657f880e03874d1b9c6b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/671eb58697ed6f7069e657f880e03874d1b9c6b4"}], "stats": {"total": 391, "additions": 304, "deletions": 87}, "files": [{"sha": "6edf424d77acee7715dd5287c1afc76b871b94bd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -1,3 +1,36 @@\n+2009-07-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_warn.adb (Warn_On_Constant_Condition): Handle properly constant\n+\tconditions of a derived boolean type.\n+\tMinor reformatting\n+\n+2009-07-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat1drv.adb: Initialize SCO tables\n+\n+\t* par-load.adb: Call SCO_Record for main unit spec\n+\n+\t* par.adb: Make call to SCO_Record for main unit\n+\n+\t* par_sco.adb (Unit_Table): Change format to facilitate sort\n+\t(Process_Decisions): New procedure with list argument\n+\t(Traverse_Generic_Package_Declaration): New procedure\n+\t(Initialize): New procedure, replaces Init\n+\t(SCO_Output): Sort unit table before output\n+\t(SCO_Record): Avoid duplications\n+\t(SCO_Record): Handle remaining cases of units\n+\t(Traverse_Declarations_Or_Statements): Handle generics\n+\n+\t* par_sco.ads (Initialize): New peocedure (replaces Init)\n+\n+\t* sem_ch10.adb (Analyze_Proper_Body): Make call to SCO_Record for\n+\tsubunit.\n+\n+2009-07-15  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* debug.adb: Add -gnatd.J switch for now to support scil generation in\n+\tparallel. Add missing doc for -gnatd.I and -gnatd.O\n+\n 2009-07-15  Robert Dewar  <dewar@adacore.com>\n \n \t* lib-load.adb: Minor reformatting"}, {"sha": "baa04293cd189c09e00b9d8fb4fd54ffc7a6ee7c", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -127,12 +127,12 @@ package body Debug is\n    --  d.G\n    --  d.H\n    --  d.I  SCIL generation mode\n-   --  d.J\n+   --  d.J  Parallel SCIL generation mode\n    --  d.K\n    --  d.L\n    --  d.M\n    --  d.N\n-   --  d.O\n+   --  d.O  Dump internal SCO tables\n    --  d.P\n    --  d.Q\n    --  d.R\n@@ -555,9 +555,17 @@ package body Debug is\n    --  d.C  Generate call to System.Concat_n.Str_Concat_n routines in cases\n    --       where we would normally generate inline concatenation code.\n \n-   --  d.I  Inspector mode. Relevant for VM_Target /= None. Try to generate\n-   --       byte code, even in case of unsupported construct, for the sake\n-   --       of static analysis tools.\n+   --  d.I  Generate SCIL mode. Generate intermediate code for the sake of\n+   --       of static analysis tools, and ensure additional tree consistency\n+   --       between different compilations of specs.\n+\n+   --  d.J  Ensure the SCIL generated is compatible with parallel builds.\n+   --       This means in particular not writing the same files under the\n+   --       same directory.\n+\n+   --  d.O  Dump internal SCO tables. Before outputting the SCO information to\n+   --       the ALI file, the internal SCO tables (SCO_Table/SCO_Unit_Table)\n+   --       are dumped for debugging purposes.\n \n    --  d.S  Force Optimize_Alignment (Space) mode as the default\n "}, {"sha": "79065e26addca0315a556ce9d2be38b19da8fff8", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -45,6 +45,7 @@ with Nlists;\n with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n+with Par_SCO;\n with Prepcomp;\n with Repinfo;  use Repinfo;\n with Restrict;\n@@ -506,6 +507,9 @@ begin\n    --  nested blocks, so that the outer one handles unrecoverable error.\n \n    begin\n+      --  Initialize all packages. For the most part, these initialization\n+      --  calls can be made in any order. Exceptions are as follows:\n+\n       --  Lib.Initialize need to be called before Scan_Compiler_Arguments,\n       --  because it initializes a table filled by Scan_Compiler_Arguments.\n \n@@ -527,6 +531,7 @@ begin\n       Snames.Initialize;\n       Stringt.Initialize;\n       Inline.Initialize;\n+      Par_SCO.Initialize;\n       Sem_Ch8.Initialize;\n       Sem_Ch12.Initialize;\n       Sem_Ch13.Initialize;"}, {"sha": "9aa084238054cacad1fa77fac9fd0412ada380f3", "filename": "gcc/ada/par-load.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fpar-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fpar-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-load.adb?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -278,9 +278,14 @@ begin\n \n          --  If this is a separate spec for the main unit, then we reset\n          --  Main_Unit_Entity to point to the entity for this separate spec\n+         --  and this is also where we generate the SCO's for this spec.\n \n          if Cur_Unum = Main_Unit then\n             Main_Unit_Entity := Cunit_Entity (Unum);\n+\n+            if Generate_SCO then\n+               SCO_Record (Unum);\n+            end if;\n          end if;\n \n       --  If we don't find the spec, then if we have a subprogram body, we"}, {"sha": "78ffd604ebd1b251cd2ee844b99fadc8ebef05fe", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -1328,10 +1328,9 @@ begin\n \n          if Ucount < Multiple_Unit_Index then\n \n-            --  We skip in syntax check only mode, since we don't want\n-            --  to do anything more than skip past the unit and ignore it.\n-            --  This causes processing like setting up a unit table entry\n-            --  to be skipped.\n+            --  We skip in syntax check only mode, since we don't want to do\n+            --  anything more than skip past the unit and ignore it. This means\n+            --  we skip processing like setting up a unit table entry.\n \n             declare\n                Save_Operating_Mode : constant Operating_Mode_Type :=\n@@ -1456,12 +1455,10 @@ begin\n \n       pragma Assert (Scope.Last = 0);\n \n-      --  This is where we generate SCO output if required\n+      --  Here we make the SCO table entries for the main unit\n \n-      if Generate_SCO\n-        and then Operating_Mode = Generate_Code\n-      then\n-         SCO_Record (Current_Source_Unit);\n+      if Generate_SCO then\n+         SCO_Record (Main_Unit);\n       end if;\n \n       --  Remaining steps are to create implicit label declarations and to load"}, {"sha": "897b35981ca51868c3ba6d30823c1bf6dacd78c1", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 183, "deletions": 63, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -28,12 +28,14 @@ with Debug;    use Debug;\n with Lib;      use Lib;\n with Lib.Util; use Lib.Util;\n with Nlists;   use Nlists;\n+with Opt;      use Opt;\n with Output;   use Output;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Table;\n \n-with GNAT.HTable; use GNAT.HTable;\n+with GNAT.HTable;      use GNAT.HTable;\n+with GNAT.Heap_Sort_G;\n \n package body Par_SCO is\n \n@@ -120,20 +122,20 @@ package body Par_SCO is\n    -- Unit Table --\n    ----------------\n \n-   --  This table keeps track of the units and the corresponding starting index\n-   --  in the SCO table. The ending index is either one less than the starting\n-   --  index of the next table entry, or, for the last table entry, it is\n-   --  SCO_Table.Last.\n+   --  This table keeps track of the units and the corresponding starting and\n+   --  ending indexes (From, To) in the SCO table. Note that entry zero is\n+   --  unused, it is for convenience in calling the sort routine.\n \n    type SCO_Unit_Table_Entry is record\n-      Unit  : Unit_Number_Type;\n-      Index : Int;\n+      Unit : Unit_Number_Type;\n+      From : Nat;\n+      To   : Nat;\n    end record;\n \n    package SCO_Unit_Table is new Table.Table (\n      Table_Component_Type => SCO_Unit_Table_Entry,\n      Table_Index_Type     => Int,\n-     Table_Low_Bound      => 1,\n+     Table_Low_Bound      => 0,\n      Table_Initial        => 20,\n      Table_Increment      => 200,\n      Table_Name           => \"SCO_Unit_Table_Entry\");\n@@ -181,6 +183,9 @@ package body Par_SCO is\n    --  the node is always a decision a decision is always present (at the very\n    --  least a simple decision is present at the top level).\n \n+   procedure Process_Decisions (L : List_Id; T : Character);\n+   --  Calls above procedure for each element of the list L\n+\n    procedure Set_Table_Entry\n      (C1   : Character;\n       C2   : Character;\n@@ -189,11 +194,12 @@ package body Par_SCO is\n       Last : Boolean);\n    --  Append an entry to SCO_Table with fields set as per arguments\n \n-   procedure Traverse_Declarations_Or_Statements (L : List_Id);\n-   procedure Traverse_Handled_Statement_Sequence (N : Node_Id);\n-   procedure Traverse_Package_Body               (N : Node_Id);\n-   procedure Traverse_Package_Declaration        (N : Node_Id);\n-   procedure Traverse_Subprogram_Body            (N : Node_Id);\n+   procedure Traverse_Declarations_Or_Statements  (L : List_Id);\n+   procedure Traverse_Generic_Package_Declaration (N : Node_Id);\n+   procedure Traverse_Handled_Statement_Sequence  (N : Node_Id);\n+   procedure Traverse_Package_Body                (N : Node_Id);\n+   procedure Traverse_Package_Declaration         (N : Node_Id);\n+   procedure Traverse_Subprogram_Body             (N : Node_Id);\n    --  Traverse the corresponding construct, generating SCO table entries\n \n    procedure dsco;\n@@ -213,8 +219,10 @@ package body Par_SCO is\n          Write_Int (Index);\n          Write_Str (\".  Unit = \");\n          Write_Int (Int (SCO_Unit_Table.Table (Index).Unit));\n-         Write_Str (\"  Index = \");\n-         Write_Int (Int (SCO_Unit_Table.Table (Index).Index));\n+         Write_Str (\"  From = \");\n+         Write_Int (Int (SCO_Unit_Table.Table (Index).From));\n+         Write_Str (\"  To = \");\n+         Write_Int (Int (SCO_Unit_Table.Table (Index).To));\n          Write_Eol;\n       end loop;\n \n@@ -297,14 +305,16 @@ package body Par_SCO is\n       return Header_Num (Nat (F) mod 997);\n    end Hash;\n \n-   ----------\n-   -- Init --\n-   ----------\n+   ----------------\n+   -- Initialize --\n+   ----------------\n \n-   procedure Init is\n+   procedure Initialize is\n    begin\n-      null;\n-   end Init;\n+      SCO_Unit_Table.Init;\n+      SCO_Unit_Table.Increment_Last;\n+      SCO_Table.Init;\n+   end Initialize;\n \n    -------------------------\n    -- Is_Logical_Operator --\n@@ -324,10 +334,24 @@ package body Par_SCO is\n    -- Process_Decisions --\n    -----------------------\n \n-   procedure Process_Decisions\n-     (N : Node_Id;\n-      T : Character)\n-   is\n+   --  Version taking a list\n+\n+   procedure Process_Decisions (L : List_Id; T : Character) is\n+      N : Node_Id;\n+   begin\n+      if L /= No_List then\n+         N := First (L);\n+         while Present (N) loop\n+            Process_Decisions (N, T);\n+            Next (N);\n+         end loop;\n+      end if;\n+   end Process_Decisions;\n+\n+   --  Version taking a node\n+\n+   procedure Process_Decisions (N : Node_Id; T : Character) is\n+\n       function Process_Node (N : Node_Id) return Traverse_Result;\n       --  Processes one node in the traversal, looking for logical operators,\n       --  and if one is found, outputs the appropriate table entries.\n@@ -567,40 +591,75 @@ package body Par_SCO is\n          dsco;\n       end if;\n \n+      --  Sort the unit table\n+\n+      Unit_Table_Sort : declare\n+\n+         function Lt (Op1, Op2 : Natural) return Boolean;\n+         --  Comparison routine for sort call\n+\n+         procedure Move (From : Natural; To : Natural);\n+         --  Move routine for sort call\n+\n+         --------\n+         -- Lt --\n+         --------\n+\n+         function Lt (Op1, Op2 : Natural) return Boolean is\n+         begin\n+            return Dependency_Num (SCO_Unit_Table.Table (Nat (Op1)).Unit) <\n+                   Dependency_Num (SCO_Unit_Table.Table (Nat (Op2)).Unit);\n+         end Lt;\n+\n+         ----------\n+         -- Move --\n+         ----------\n+\n+         procedure Move (From : Natural; To : Natural) is\n+         begin\n+            SCO_Unit_Table.Table (Nat (To)) :=\n+              SCO_Unit_Table.Table (Nat (From));\n+         end Move;\n+\n+         package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n+\n+      --  Start of processing for Unit_Table_Sort\n+\n+      begin\n+         Sorting.Sort (Integer (SCO_Unit_Table.Last));\n+      end Unit_Table_Sort;\n+\n       --  Loop through entries in the unit table\n \n-      for J in SCO_Unit_Table.First .. SCO_Unit_Table.Last loop\n+      for J in 1 .. SCO_Unit_Table.Last loop\n          U := SCO_Unit_Table.Table (J).Unit;\n \n-         if In_Extended_Main_Source_Unit (Cunit_Entity (U)) then\n-            Write_Info_Initiate ('C');\n-            Write_Info_Char (' ');\n-            Write_Info_Nat (Dependency_Num (U));\n-            Write_Info_Char (' ');\n-            Write_Info_Name (Reference_Name (Source_Index (U)));\n-            Write_Info_Terminate;\n+         --  Output header line preceded by blank line\n \n-            Start := SCO_Unit_Table.Table (J).Index;\n+         Write_Info_Terminate;\n+         Write_Info_Initiate ('C');\n+         Write_Info_Char (' ');\n+         Write_Info_Nat (Dependency_Num (U));\n+         Write_Info_Char (' ');\n+         Write_Info_Name (Reference_Name (Source_Index (U)));\n+         Write_Info_Terminate;\n \n-            if J = SCO_Unit_Table.Last then\n-               Stop := SCO_Table.Last;\n-            else\n-               Stop := SCO_Unit_Table.Table (J + 1).Index - 1;\n-            end if;\n+         Start := SCO_Unit_Table.Table (J).From;\n+         Stop  := SCO_Unit_Table.Table (J).To;\n \n-            --  Loop through relevant entries in SCO table, outputting C lines\n+         --  Loop through relevant entries in SCO table, outputting C lines\n \n-            while Start <= Stop loop\n-               declare\n-                  T : SCO_Table_Entry renames SCO_Table.Table (Start);\n+         while Start <= Stop loop\n+            declare\n+               T : SCO_Table_Entry renames SCO_Table.Table (Start);\n \n-               begin\n-                  Write_Info_Initiate ('C');\n-                  Write_Info_Char (T.C1);\n+            begin\n+               Write_Info_Initiate ('C');\n+               Write_Info_Char (T.C1);\n \n-                  case T.C1 is\n+               case T.C1 is\n \n-                     --  Statements, entry, exit\n+                  --  Statements, entry, exit\n \n                   when 'S' | 'Y' | 'T' =>\n                      Write_Info_Char (' ');\n@@ -641,17 +700,16 @@ package body Par_SCO is\n \n                   when others =>\n                      raise Program_Error;\n-                  end case;\n+               end case;\n \n-                  Write_Info_Terminate;\n-               end;\n+               Write_Info_Terminate;\n+            end;\n \n-               exit when Start = Stop;\n-               Start := Start + 1;\n+            exit when Start = Stop;\n+            Start := Start + 1;\n \n-               pragma Assert (Start <= Stop);\n-            end loop;\n-         end if;\n+            pragma Assert (Start <= Stop);\n+         end loop;\n       end loop;\n    end SCO_Output;\n \n@@ -660,11 +718,35 @@ package body Par_SCO is\n    ----------------\n \n    procedure SCO_Record (U : Unit_Number_Type) is\n-      Cu : constant Node_Id := Cunit (U);\n-      Lu : constant Node_Id := Unit (Cu);\n+      Lu   : Node_Id;\n+      From : Nat;\n \n    begin\n-      SCO_Unit_Table.Append ((Unit => U, Index => SCO_Table.Last + 1));\n+      --  Ignore call if not generating code and generating SCO's\n+\n+      if not (Generate_SCO and then Operating_Mode = Generate_Code) then\n+         return;\n+      end if;\n+\n+      --  Ignore call if this unit already recorded\n+\n+      for J in 1 .. SCO_Unit_Table.Last loop\n+         if SCO_Unit_Table.Table (J).Unit = U then\n+            return;\n+         end if;\n+      end loop;\n+\n+      --  Otherwise record starting entry\n+\n+      From := SCO_Table.Last + 1;\n+\n+      --  Get Unit (checking case of subunit)\n+\n+      Lu := Unit (Cunit (U));\n+\n+      if Nkind (Lu) = N_Subunit then\n+         Lu := Proper_Body (Lu);\n+      end if;\n \n       --  Traverse the unit\n \n@@ -677,13 +759,20 @@ package body Par_SCO is\n       elsif Nkind (Lu) = N_Package_Body then\n          Traverse_Package_Body (Lu);\n \n-         --  Ignore subprogram specifications, since nothing to cover.\n-         --  Also ignore instantiations, since again, nothing to cover.\n-         --  Also for now, ignore generic declarations ???\n+      elsif Nkind (Lu) = N_Generic_Package_Declaration then\n+         Traverse_Generic_Package_Declaration (Lu);\n+\n+      --  For anything else, the only issue is default expressions for\n+      --  parameters, where we have to worry about possible embedded decisions\n+      --  but nothing else.\n \n       else\n-         null;\n+         Process_Decisions (Lu, 'X');\n       end if;\n+\n+      --  Make entry for new unit in unit table\n+\n+      SCO_Unit_Table.Append ((Unit => U, From => From, To => SCO_Table.Last));\n    end SCO_Record;\n \n    -----------------------\n@@ -774,12 +863,33 @@ package body Par_SCO is\n                   Set_Statement_Entry;\n                   Traverse_Package_Declaration (N);\n \n+               --  Generic package declaration\n+\n+               when N_Generic_Package_Declaration =>\n+                  Set_Statement_Entry;\n+                  Traverse_Generic_Package_Declaration (N);\n+\n                --  Package body\n \n                when N_Package_Body =>\n                   Set_Statement_Entry;\n                   Traverse_Package_Body (N);\n \n+               --  Subprogram declaration\n+\n+               when N_Subprogram_Declaration =>\n+                  Set_Statement_Entry;\n+                  Process_Decisions\n+                    (Parameter_Specifications (Specification (N)), 'X');\n+\n+               --  Generic subprogram declaration\n+\n+               when N_Generic_Subprogram_Declaration =>\n+                  Set_Statement_Entry;\n+                  Process_Decisions (Generic_Formal_Declarations (N), 'X');\n+                  Process_Decisions\n+                    (Parameter_Specifications (Specification (N)), 'X');\n+\n                --  Subprogram_Body\n \n                when N_Subprogram_Body =>\n@@ -906,6 +1016,16 @@ package body Par_SCO is\n       end if;\n    end Traverse_Declarations_Or_Statements;\n \n+   ------------------------------------------\n+   -- Traverse_Generic_Package_Declaration --\n+   ------------------------------------------\n+\n+   procedure Traverse_Generic_Package_Declaration (N : Node_Id) is\n+   begin\n+      Process_Decisions (Generic_Formal_Declarations (N), 'X');\n+      Traverse_Package_Declaration (N);\n+   end Traverse_Generic_Package_Declaration;\n+\n    -----------------------------------------\n    -- Traverse_Handled_Statement_Sequence --\n    -----------------------------------------"}, {"sha": "5adee95af156d17606505d53a4f1de5c5dbeca6d", "filename": "gcc/ada/par_sco.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fpar_sco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fpar_sco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.ads?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -201,7 +201,7 @@ package Par_SCO is\n    -- Subprograms --\n    -----------------\n \n-   procedure Init;\n+   procedure Initialize;\n    --  Initialize internal tables for a new compilation\n \n    procedure SCO_Record (U : Unit_Number_Type);"}, {"sha": "a443e4100529bd0f677bae1d5f1e8911ef682e0b", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -42,6 +42,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n+with Par_SCO;  use Par_SCO;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n@@ -1695,6 +1696,8 @@ package body Sem_Ch10 is\n                  Subunit    => True,\n                  Error_Node => N);\n \n+            --  Give message if we did not get the unit\n+\n             if Original_Operating_Mode = Generate_Code\n               and then Unum = No_Unit\n             then\n@@ -1736,6 +1739,17 @@ package body Sem_Ch10 is\n \n                      Set_Corresponding_Stub (Unit (Comp_Unit), N);\n \n+                     --  Collect SCO information for loaded subunit if we are\n+                     --  in the main unit).\n+\n+                     if Generate_SCO\n+                       and then\n+                         In_Extended_Main_Source_Unit\n+                           (Cunit_Entity (Current_Sem_Unit))\n+                     then\n+                        SCO_Record (Unum);\n+                     end if;\n+\n                      --  Analyze the unit if semantics active\n \n                      if not Fatal_Error (Unum) or else Try_Semantics then"}, {"sha": "1551acf092af8a39c992cdb0c48e815ee29694c1", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/892125cdb19cd2a688416429b8bf30f2f4fab78d/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=892125cdb19cd2a688416429b8bf30f2f4fab78d", "patch": "@@ -3308,15 +3308,53 @@ package body Sem_Warn is\n    -----------------------------\n \n    procedure Warn_On_Known_Condition (C : Node_Id) is\n-      P    : Node_Id;\n-      Orig : constant Node_Id := Original_Node (C);\n+      P           : Node_Id;\n+      Orig        : constant Node_Id := Original_Node (C);\n+      Test_Result : Boolean;\n+\n+      function Is_Known_Branch return Boolean;\n+      --  If the type of the condition is Boolean, the constant value of the\n+      --  condition is a boolean literal. If the type is a derived boolean\n+      --  type, the constant is wrapped in a type conversion of the derived\n+      --  literal. If the value of the condition is not a literal, no warnings\n+      --  can be produced. This function returns True if the result can be\n+      --  determined, and Test_Result is set True/False accordingly. Otherwise\n+      --  False is returned, and Test_Result is unchanged.\n \n       procedure Track (N : Node_Id; Loc : Node_Id);\n       --  Adds continuation warning(s) pointing to reason (assignment or test)\n       --  for the operand of the conditional having a known value (or at least\n       --  enough is known about the value to issue the warning). N is the node\n       --  which is judged to have a known value. Loc is the warning location.\n \n+      ---------------------\n+      -- Is_Known_Branch --\n+      ---------------------\n+\n+      function Is_Known_Branch return Boolean is\n+      begin\n+         if Etype (C) = Standard_Boolean\n+           and then Is_Entity_Name (C)\n+           and then\n+             (Entity (C) = Standard_False or else Entity (C) = Standard_True)\n+         then\n+            Test_Result := Entity (C) = Standard_True;\n+            return True;\n+\n+         elsif Is_Boolean_Type (Etype (C))\n+           and then Nkind (C) = N_Unchecked_Type_Conversion\n+           and then Is_Entity_Name (Expression (C))\n+           and then Ekind (Entity (Expression (C))) = E_Enumeration_Literal\n+         then\n+            Test_Result :=\n+              Chars (Entity (Expression (C))) = Chars (Standard_True);\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Known_Branch;\n+\n       -----------\n       -- Track --\n       -----------\n@@ -3362,7 +3400,7 @@ package body Sem_Warn is\n \n       if Generate_SCO\n         and then Comes_From_Source (Orig)\n-        and then Is_Entity_Name (C)\n+        and then Is_Known_Branch\n       then\n          declare\n             Start : Source_Ptr;\n@@ -3372,8 +3410,7 @@ package body Sem_Warn is\n \n          begin\n             Sloc_Range (Orig, Start, Dummy);\n-\n-            Atrue := Entity (C) = Standard_True;\n+            Atrue := Test_Result;\n \n             if Present (Parent (C))\n               and then Nkind (Parent (C)) = N_Op_Not\n@@ -3399,9 +3436,7 @@ package body Sem_Warn is\n       end if;\n \n       if Constant_Condition_Warnings\n-        and then Nkind (C) = N_Identifier\n-        and then\n-          (Entity (C) = Standard_False or else Entity (C) = Standard_True)\n+        and then Is_Known_Branch\n         and then Comes_From_Source (Original_Node (C))\n         and then not In_Instance\n       then\n@@ -3456,7 +3491,7 @@ package body Sem_Warn is\n \n          if not Operand_Has_Warnings_Suppressed (C) then\n             declare\n-               True_Branch : Boolean := Entity (C) = Standard_True;\n+               True_Branch : Boolean := Test_Result;\n                Cond        : Node_Id := C;\n \n             begin"}]}