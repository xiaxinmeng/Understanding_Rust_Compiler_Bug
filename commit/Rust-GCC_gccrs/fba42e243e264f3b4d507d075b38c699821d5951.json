{"sha": "fba42e243e264f3b4d507d075b38c699821d5951", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJhNDJlMjQzZTI2NGYzYjRkNTA3ZDA3NWIzOGM2OTk4MjFkNTk1MQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-10-11T17:41:24Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-10-11T17:41:24Z"}, "message": "target.def (preferred_reload_class): New hook.\n\n\t* target.def (preferred_reload_class): New hook.\n\t* doc/tm.texi.in (TARGET_PREFERRED_RELOAD_CLASS): Document.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_preferred_reload_class): New function.\n\t* targhooks.h (default_preferred_reload_class): Declare.\n\t* reload.c (find_dummy_reload): Change preferred_class variable type\n\tfrom enum reg_class to reg_class_t. Use TARGET_PREFERRED_RELOAD_CLASS\n\ttarget hook.\n\t(find_reloads): Change goal_alternative array type from int to\n\treg_class_t. Use TARGET_PREFERRED_RELOAD_CLASS target hook.\n\t(push_reload, find_reloads_address_part): Use\n\tTARGET_PREFERRED_RELOAD_CLASS target hook.\n\t* reload1.c (emit_input_reload_insns): Ditto.\n\t* ira-costs.c (copy_cost): Use TARGET_PREFERRED_RELOAD_CLASS target\n\thook. Change rclass argument and secondary_class variable types from\n\t'enum reg_class' to reg_class_t.\n\n\t* config/i386/i386.h (PREFERRED_RELOAD_CLASS): Remove.\n\t* config/i386/i386-protos (ix86_preferred_reload_class): Remove.\n\t* config/i386/i386.c (ix86_preferred_reload_class): Make static.\n\tChange regclass argument and result types from enum reg_class to\n\treg_class_t.\n\t(TARGET_PREFERRED_RELOAD_CLASS): Define.\n\nFrom-SVN: r165321", "tree": {"sha": "4b63d698c47af01f476f8ddd1376746e9309a913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b63d698c47af01f476f8ddd1376746e9309a913"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fba42e243e264f3b4d507d075b38c699821d5951", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba42e243e264f3b4d507d075b38c699821d5951", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba42e243e264f3b4d507d075b38c699821d5951", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba42e243e264f3b4d507d075b38c699821d5951/comments", "author": null, "committer": null, "parents": [{"sha": "43c36287976d2cb4d134aff2952eca031c78eb59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c36287976d2cb4d134aff2952eca031c78eb59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43c36287976d2cb4d134aff2952eca031c78eb59"}], "stats": {"total": 197, "additions": 152, "deletions": 45}, "files": [{"sha": "c9501f4a14eab48e91b3d5a9770cde3d88fe3dc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -1,3 +1,29 @@\n+2010-10-11  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* target.def (preferred_reload_class): New hook.\n+\t* doc/tm.texi.in (TARGET_PREFERRED_RELOAD_CLASS): Document.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_preferred_reload_class): New function.\n+\t* targhooks.h (default_preferred_reload_class): Declare.\n+\t* reload.c (find_dummy_reload): Change preferred_class variable type\n+\tfrom enum reg_class to reg_class_t. Use TARGET_PREFERRED_RELOAD_CLASS\n+\ttarget hook.\n+\t(find_reloads): Change goal_alternative array type from int to\n+\treg_class_t. Use TARGET_PREFERRED_RELOAD_CLASS target hook.\n+\t(push_reload, find_reloads_address_part): Use\n+\tTARGET_PREFERRED_RELOAD_CLASS target hook.\n+\t* reload1.c (emit_input_reload_insns): Ditto.\n+\t* ira-costs.c (copy_cost): Use TARGET_PREFERRED_RELOAD_CLASS target\n+\thook. Change rclass argument and secondary_class variable types from\n+\t'enum reg_class' to reg_class_t.\n+\n+\t* config/i386/i386.h (PREFERRED_RELOAD_CLASS): Remove.\n+\t* config/i386/i386-protos (ix86_preferred_reload_class): Remove.\n+\t* config/i386/i386.c (ix86_preferred_reload_class): Make static.\n+\tChange regclass argument and result types from enum reg_class to\n+\treg_class_t.\n+\t(TARGET_PREFERRED_RELOAD_CLASS): Define.\n+\n 2010-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* simplify-rtx.c (simplify_unary_operation_1): Use unsigned arithmetics"}, {"sha": "f23ea933ec01409d65660ca21c1eea68211acf84", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -153,7 +153,6 @@ extern bool ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n \t\t\t\t\t  enum machine_mode, int);\n extern bool ix86_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n-extern enum reg_class ix86_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class ix86_preferred_output_reload_class (rtx, enum reg_class);\n extern int ix86_mode_needed (int, rtx);\n extern void emit_i387_cw_initialization (int);"}, {"sha": "ff2be626ef06adbb325e34f1d0ab9bf483d2d07d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -26650,12 +26650,15 @@ i386_ira_cover_classes (void)\n  return TARGET_SSE_MATH ? sse_fpmath_classes : no_sse_fpmath_classes;\n }\n \n-/* Put float CONST_DOUBLE in the constant pool instead of fp regs.\n+/* Implement TARGET_PREFERRED_RELOAD_CLASS.\n+\n+   Put float CONST_DOUBLE in the constant pool instead of fp regs.\n    QImode must go into class Q_REGS.\n    Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and\n    movdf to do mem-to-mem moves through integer regs.  */\n-enum reg_class\n-ix86_preferred_reload_class (rtx x, enum reg_class regclass)\n+\n+static reg_class_t\n+ix86_preferred_reload_class (rtx x, reg_class_t regclass)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n@@ -33295,6 +33298,8 @@ ix86_autovectorize_vector_sizes (void)\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD ix86_secondary_reload\n \n+#undef TARGET_PREFERRED_RELOAD_CLASS\n+#define TARGET_PREFERRED_RELOAD_CLASS ix86_preferred_reload_class\n #undef TARGET_CLASS_LIKELY_SPILLED_P\n #define TARGET_CLASS_LIKELY_SPILLED_P ix86_class_likely_spilled_p\n "}, {"sha": "719761d2438c5281d9a728026b46941a4aba0617", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -1373,22 +1373,6 @@ enum reg_class\n        || (CLASS) == LEGACY_REGS || (CLASS) == INDEX_REGS)\t\\\n    ? Q_REGS : (CLASS))\n \n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-   On the 80386 series, we prevent floating constants from being\n-   reloaded into floating registers (since no move-insn can do that)\n-   and we ensure that QImodes aren't reloaded into the esi or edi reg.  */\n-\n-/* Put float CONST_DOUBLE in the constant pool instead of fp regs.\n-   QImode must go into class Q_REGS.\n-   Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and\n-   movdf to do mem-to-mem moves through integer regs.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n-   ix86_preferred_reload_class ((X), (CLASS))\n-\n /* Discourage putting floating-point values in SSE registers unless\n    SSE math is being used, and likewise for the 387 registers.  */\n "}, {"sha": "55a98972bc8a7732537c03db859c6a0fc1b0cb70", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -2585,6 +2585,40 @@ only if neither labeling works.\n This macro also has strict and non-strict variants.\n @end defmac\n \n+@deftypefn {Target Hook} reg_class_t TARGET_PREFERRED_RELOAD_CLASS (rtx @var{x}, reg_class_t @var{rclass})\n+A target hook that places additional restrictions on the register class\n+to use when it is necessary to copy value @var{x} into a register in class\n+@var{rclass}.  The value is a register class; perhaps @var{rclass}, or perhaps\n+another, smaller class.\n+\n+The default version of this hook always returns value of @code{rclass} argument.\n+\n+Sometimes returning a more restrictive class makes better code.  For\n+example, on the 68000, when @var{x} is an integer constant that is in range\n+for a @samp{moveq} instruction, the value of this macro is always\n+@code{DATA_REGS} as long as @var{rclass} includes the data registers.\n+Requiring a data register guarantees that a @samp{moveq} will be used.\n+\n+One case where @code{TARGET_PREFERRED_RELOAD_CLASS} must not return\n+@var{rclass} is if @var{x} is a legitimate constant which cannot be\n+loaded into some register class.  By returning @code{NO_REGS} you can\n+force @var{x} into a memory location.  For example, rs6000 can load\n+immediate values into general-purpose registers, but does not have an\n+instruction for loading an immediate value into a floating-point\n+register, so @code{TARGET_PREFERRED_RELOAD_CLASS} returns @code{NO_REGS} when\n+@var{x} is a floating-point constant.  If the constant can't be loaded\n+into any kind of register, code generation will be better if\n+@code{LEGITIMATE_CONSTANT_P} makes the constant illegitimate instead\n+of using @code{TARGET_PREFERRED_RELOAD_CLASS}.\n+\n+If an insn has pseudos in it after register allocation, reload will go\n+through the alternatives and call repeatedly @code{TARGET_PREFERRED_RELOAD_CLASS}\n+to find the best one.  Returning @code{NO_REGS}, in this case, makes\n+reload add a @code{!} in front of the constraint: the x86 back-end uses\n+this feature to discourage usage of 387 registers when math is done in\n+the SSE registers (and vice versa).\n+@end deftypefn\n+\n @defmac PREFERRED_RELOAD_CLASS (@var{x}, @var{class})\n A C expression that places additional restrictions on the register class\n to use when it is necessary to copy value @var{x} into a register in class"}, {"sha": "84a071b6242ad16a4ca5af0c9a9681bff7b9df82", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -2583,6 +2583,40 @@ only if neither labeling works.\n This macro also has strict and non-strict variants.\n @end defmac\n \n+@hook TARGET_PREFERRED_RELOAD_CLASS\n+A target hook that places additional restrictions on the register class\n+to use when it is necessary to copy value @var{x} into a register in class\n+@var{rclass}.  The value is a register class; perhaps @var{rclass}, or perhaps\n+another, smaller class.\n+\n+The default version of this hook always returns value of @code{rclass} argument.\n+\n+Sometimes returning a more restrictive class makes better code.  For\n+example, on the 68000, when @var{x} is an integer constant that is in range\n+for a @samp{moveq} instruction, the value of this macro is always\n+@code{DATA_REGS} as long as @var{rclass} includes the data registers.\n+Requiring a data register guarantees that a @samp{moveq} will be used.\n+\n+One case where @code{TARGET_PREFERRED_RELOAD_CLASS} must not return\n+@var{rclass} is if @var{x} is a legitimate constant which cannot be\n+loaded into some register class.  By returning @code{NO_REGS} you can\n+force @var{x} into a memory location.  For example, rs6000 can load\n+immediate values into general-purpose registers, but does not have an\n+instruction for loading an immediate value into a floating-point\n+register, so @code{TARGET_PREFERRED_RELOAD_CLASS} returns @code{NO_REGS} when\n+@var{x} is a floating-point constant.  If the constant can't be loaded\n+into any kind of register, code generation will be better if\n+@code{LEGITIMATE_CONSTANT_P} makes the constant illegitimate instead\n+of using @code{TARGET_PREFERRED_RELOAD_CLASS}.\n+\n+If an insn has pseudos in it after register allocation, reload will go\n+through the alternatives and call repeatedly @code{TARGET_PREFERRED_RELOAD_CLASS}\n+to find the best one.  Returning @code{NO_REGS}, in this case, makes\n+reload add a @code{!} in front of the constraint: the x86 back-end uses\n+this feature to discourage usage of 387 registers when math is done in\n+the SSE registers (and vice versa).\n+@end deftypefn\n+\n @defmac PREFERRED_RELOAD_CLASS (@var{x}, @var{class})\n A C expression that places additional restrictions on the register class\n to use when it is necessary to copy value @var{x} into a register in class"}, {"sha": "3d8298d94a060e83cfdcb8a3025f48bc907b4e1b", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -131,46 +131,48 @@ static int frequency;\n    TO_P is FALSE) a register of class RCLASS in mode MODE.  X must not\n    be a pseudo register.  */\n static int\n-copy_cost (rtx x, enum machine_mode mode, enum reg_class rclass, bool to_p,\n+copy_cost (rtx x, enum machine_mode mode, reg_class_t rclass, bool to_p,\n \t   secondary_reload_info *prev_sri)\n {\n   secondary_reload_info sri;\n-  enum reg_class secondary_class = NO_REGS;\n+  reg_class_t secondary_class = NO_REGS;\n \n   /* If X is a SCRATCH, there is actually nothing to move since we are\n      assuming optimal allocation.  */\n   if (GET_CODE (x) == SCRATCH)\n     return 0;\n \n   /* Get the class we will actually use for a reload.  */\n-  rclass = PREFERRED_RELOAD_CLASS (x, rclass);\n+  rclass = targetm.preferred_reload_class (x, rclass);\n \n   /* If we need a secondary reload for an intermediate, the cost is\n      that to load the input into the intermediate register, then to\n      copy it.  */\n   sri.prev_sri = prev_sri;\n   sri.extra_cost = 0;\n-  secondary_class\n-    = (enum reg_class) targetm.secondary_reload (to_p, x, rclass, mode, &sri);\n+  secondary_class = targetm.secondary_reload (to_p, x, rclass, mode, &sri);\n \n   if (secondary_class != NO_REGS)\n     {\n       if (!move_cost[mode])\n         init_move_cost (mode);\n-      return (move_cost[mode][secondary_class][rclass] + sri.extra_cost\n+      return (move_cost[mode][(int) secondary_class][(int) rclass]\n+\t      + sri.extra_cost\n \t      + copy_cost (x, mode, secondary_class, to_p, &sri));\n     }\n \n   /* For memory, use the memory move cost, for (hard) registers, use\n      the cost to move between the register classes, and use 2 for\n      everything else (constants).  */\n   if (MEM_P (x) || rclass == NO_REGS)\n-    return sri.extra_cost + ira_memory_move_cost[mode][rclass][to_p != 0];\n+    return sri.extra_cost\n+\t   + ira_memory_move_cost[mode][(int) rclass][to_p != 0];\n   else if (REG_P (x))\n     {\n       if (!move_cost[mode])\n         init_move_cost (mode);\n-      return (sri.extra_cost + move_cost[mode][REGNO_REG_CLASS (REGNO (x))][rclass]);\n+      return (sri.extra_cost\n+\t      + move_cost[mode][REGNO_REG_CLASS (REGNO (x))][(int) rclass]);\n     }\n   else\n     /* If this is a constant, we may eventually want to call rtx_cost"}, {"sha": "17d4f2838b0252903bb76496ab8ccc71940fb0a9", "filename": "gcc/reload.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -1227,7 +1227,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n     enum reg_class preferred_class = rclass;\n \n     if (in != 0)\n-      preferred_class = PREFERRED_RELOAD_CLASS (in, rclass);\n+      preferred_class = (enum reg_class) targetm.preferred_reload_class (in, rclass);\n \n   /* Output reloads may need analogous treatment, different in detail.  */\n #ifdef PREFERRED_OUTPUT_RELOAD_CLASS\n@@ -1963,9 +1963,9 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n   /* Narrow down the reg class, the same way push_reload will;\n      otherwise we might find a dummy now, but push_reload won't.  */\n   {\n-    enum reg_class preferred_class = PREFERRED_RELOAD_CLASS (in, rclass);\n+    reg_class_t preferred_class = targetm.preferred_reload_class (in, rclass);\n     if (preferred_class != NO_REGS)\n-      rclass = preferred_class;\n+      rclass = (enum reg_class) preferred_class;\n   }\n \n   /* See if OUT will do.  */\n@@ -2595,7 +2595,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   char this_alternative_earlyclobber[MAX_RECOG_OPERANDS];\n   int this_alternative_matches[MAX_RECOG_OPERANDS];\n   int swapped;\n-  int goal_alternative[MAX_RECOG_OPERANDS];\n+  reg_class_t goal_alternative[MAX_RECOG_OPERANDS];\n   int this_alternative_number;\n   int goal_alternative_number = 0;\n   int operand_reloadnum[MAX_RECOG_OPERANDS];\n@@ -3506,7 +3506,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t precisely the same as in the code below that calls\n \t\t force_const_mem.  */\n \t      if (CONST_POOL_OK_P (operand)\n-\t\t  && ((PREFERRED_RELOAD_CLASS (operand, this_alternative[i])\n+\t\t  && ((targetm.preferred_reload_class (operand,\n+\t\t\t\t\t\t       this_alternative[i])\n \t\t       == NO_REGS)\n \t\t      || no_input_reloads)\n \t\t  && operand_mode[i] != VOIDmode)\n@@ -3534,7 +3535,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t      if (! CONSTANT_P (operand) && this_alternative[i] != NO_REGS)\n \t\t{\n-\t\t  if (PREFERRED_RELOAD_CLASS (operand, this_alternative[i])\n+\t\t  if (targetm.preferred_reload_class (operand, this_alternative[i])\n \t\t      == NO_REGS)\n \t\t    reject = 600;\n \n@@ -3695,7 +3696,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    {\n \t      goal_alternative_win[i] = this_alternative_win[i];\n \t      goal_alternative_match_win[i] = this_alternative_match_win[i];\n-\t      goal_alternative[i] = this_alternative[i];\n+\t      goal_alternative[i] = (reg_class_t) this_alternative[i];\n \t      goal_alternative_offmemok[i] = this_alternative_offmemok[i];\n \t      goal_alternative_matches[i] = this_alternative_matches[i];\n \t      goal_alternative_earlyclobber[i]\n@@ -3722,7 +3723,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    {\n \t      for (i = 0; i < noperands; i++)\n \t\t{\n-\t\t  goal_alternative[i] = this_alternative[i];\n+\t\t  goal_alternative[i] = (reg_class_t) this_alternative[i];\n \t\t  goal_alternative_win[i] = this_alternative_win[i];\n \t\t  goal_alternative_match_win[i]\n \t\t    = this_alternative_match_win[i];\n@@ -3915,8 +3916,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t  }\n \n \tif (CONST_POOL_OK_P (op)\n-\t    && ((PREFERRED_RELOAD_CLASS (op,\n-\t\t\t\t\t (enum reg_class) goal_alternative[i])\n+\t    && ((targetm.preferred_reload_class (op, goal_alternative[i])\n \t\t == NO_REGS)\n \t\t|| no_input_reloads)\n \t    && mode != VOIDmode)\n@@ -4094,7 +4094,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    /* If this is only for an output, the optional reload would not\n \t       actually cause us to use a register now, just note that\n \t       something is stored here.  */\n-\t    && ((enum reg_class) goal_alternative[i] != NO_REGS\n+\t    && (goal_alternative[i] != NO_REGS\n \t\t|| modified[i] == RELOAD_WRITE)\n \t    && ! no_input_reloads\n \t    /* An optional output reload might allow to delete INSN later.\n@@ -4168,8 +4168,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \tif ((MEM_P (operand)\n \t     || (REG_P (operand)\n \t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n-\t    && ((enum reg_class) goal_alternative[goal_alternative_matches[i]]\n-\t\t!= NO_REGS))\n+\t    && (goal_alternative[goal_alternative_matches[i]] != NO_REGS))\n \t  operand_reloadnum[i] = operand_reloadnum[goal_alternative_matches[i]]\n \t    = push_reload (recog_data.operand[goal_alternative_matches[i]],\n \t\t\t   recog_data.operand[i],\n@@ -6048,7 +6047,7 @@ find_reloads_address_part (rtx x, rtx *loc, enum reg_class rclass,\n {\n   if (CONSTANT_P (x)\n       && (! LEGITIMATE_CONSTANT_P (x)\n-\t  || PREFERRED_RELOAD_CLASS (x, rclass) == NO_REGS))\n+\t  || targetm.preferred_reload_class (x, rclass) == NO_REGS))\n     {\n       x = force_const_mem (mode, x);\n       find_reloads_address (mode, &x, XEXP (x, 0), &XEXP (x, 0),\n@@ -6058,7 +6057,8 @@ find_reloads_address_part (rtx x, rtx *loc, enum reg_class rclass,\n   else if (GET_CODE (x) == PLUS\n \t   && CONSTANT_P (XEXP (x, 1))\n \t   && (! LEGITIMATE_CONSTANT_P (XEXP (x, 1))\n-\t       || PREFERRED_RELOAD_CLASS (XEXP (x, 1), rclass) == NO_REGS))\n+\t       || targetm.preferred_reload_class (XEXP (x, 1), rclass)\n+\t\t   == NO_REGS))\n     {\n       rtx tem;\n "}, {"sha": "00c16719e136a447ff4ec38704dc4b86cb581d9b", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -7500,8 +7500,8 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t  || (reg_equiv_constant\n \t\t      [REGNO (SUBREG_REG (oldequiv))] != 0)))\n \t  || (CONSTANT_P (oldequiv)\n-\t      && (PREFERRED_RELOAD_CLASS (oldequiv,\n-\t\t\t\t\t  REGNO_REG_CLASS (REGNO (reloadreg)))\n+\t      && (targetm.preferred_reload_class (oldequiv,\n+\t\t\t\t\t\t  REGNO_REG_CLASS (REGNO (reloadreg)))\n \t\t  == NO_REGS)))\n \treal_oldequiv = rl->in;\n       gen_reload (reloadreg, real_oldequiv, rl->opnum,"}, {"sha": "f7ad80b7b8ab207e1df869534def45957cf147d5", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -2033,6 +2033,15 @@ DEFHOOK\n   secondary_reload_info *sri),\n  default_secondary_reload)\n \n+/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n+   return the class of reg to actually use.  */\n+DEFHOOK\n+(preferred_reload_class,\n+ \"\",\n+ reg_class_t,\n+ (rtx x, reg_class_t rclass),\n+ default_preferred_reload_class)\n+\n DEFHOOK\n (class_likely_spilled_p,\n  \"\","}, {"sha": "7a3dda3241be2b77f65404c2955f6fe6feb21b49", "filename": "gcc/targhooks.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -1230,6 +1230,19 @@ default_profile_before_prologue (void)\n #endif\n }\n \n+/* The default implementation of TARGET_PREFERRED_RELOAD_CLASS.  */\n+\n+reg_class_t\n+default_preferred_reload_class (rtx x ATTRIBUTE_UNUSED,\n+\t\t\t        reg_class_t rclass)\n+{\n+#ifdef PREFERRED_RELOAD_CLASS \n+  return (reg_class_t) PREFERRED_RELOAD_CLASS (x, (enum reg_class) rclass);\n+#else\n+  return rclass;\n+#endif\n+}\n+\n /* The default implementation of TARGET_CLASS_LIKELY_SPILLED_P.  */\n \n bool"}, {"sha": "925e1f51aefa740b008b0fe4c15e2f6ef2951656", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba42e243e264f3b4d507d075b38c699821d5951/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=fba42e243e264f3b4d507d075b38c699821d5951", "patch": "@@ -154,6 +154,7 @@ extern int default_register_move_cost (enum machine_mode, reg_class_t,\n \t\t\t\t       reg_class_t);\n \n extern bool default_profile_before_prologue (void);\n+extern reg_class_t default_preferred_reload_class (rtx, reg_class_t);\n extern bool default_class_likely_spilled_p (reg_class_t);\n \n extern enum unwind_info_type default_debug_unwind_info (void);"}]}