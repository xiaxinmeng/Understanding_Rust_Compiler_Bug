{"sha": "8de1f441bb72de63213667ce2af8152e3d2ce801", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRlMWY0NDFiYjcyZGU2MzIxMzY2N2NlMmFmODE1MmUzZDJjZTgwMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-05-17T06:31:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-05-17T06:31:51Z"}, "message": "re PR fortran/15080 (Forall bounds not calculated correctly (forall_3.f90))\n\n\tPR fortran/15080\n\t* trans-stmt.c (generate_loop_for_temp_to_lhs): Remove SIZE and COUNT2\n\targuments.  If LSS is gfc_ss_terminator, increment COUNT1 by 1, instead\n\tof incrementing COUNT2 and using COUNT1+COUNT2 increment COUNT1 and use\n\tjust that as index.\n\t(generate_loop_for_rhs_to_temp): Likewise.\n\t(compute_overall_iter_number): Add INNER_SIZE_BODY argument.\n\tIt non-NULL, add it to body.\n\t(allocate_temp_for_forall_nest_1): New function, split from\n\tallocate_temp_for_forall_nest.\n\t(allocate_temp_for_forall_nest): Add INNER_SIZE_BODY argument,\n\tpropagate it down to compute_overall_iter_number.  Use\n\tallocate_temp_for_forall_nest_1.\n\t(gfc_trans_assign_need_temp): Remove COUNT2.  Call\n\tcompute_inner_temp_size into a new stmtblock_t.  Adjust calls to\n\tallocate_temp_for_forall_nest, generate_loop_for_rhs_to_temp\n\tand generate_loop_for_temp_to_lhs.\n\t(gfc_trans_pointer_assign_need_temp): Adjust calls to\n\tallocate_temp_for_forall_nest.\n\t(gfc_evaluate_where_mask): Call compute_inner_temp_size into a new\n\tstmtblock_t.  Call compute_overall_iter_number just once, then\n\tallocate_temp_for_forall_nest_1 twice with the same size.\n\tInitialize mask indexes if nested_forall_info != NULL.\n\t(gfc_trans_where_2): Initialize mask indexes before calling\n\tgfc_trans_nested_forall_loop.\n\n\t* gfortran.fortran-torture/execute/forall_3.f90: Remove comment\n\tabout the test failing.\n\t* gfortran.fortran-torture/execute/where_7.f90: New test.\n\t* gfortran.fortran-torture/execute/where_8.f90: New test.\n\nFrom-SVN: r99812", "tree": {"sha": "c579da660c53114a5f26494b5bf7b0ce3668ce55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c579da660c53114a5f26494b5bf7b0ce3668ce55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8de1f441bb72de63213667ce2af8152e3d2ce801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de1f441bb72de63213667ce2af8152e3d2ce801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de1f441bb72de63213667ce2af8152e3d2ce801", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de1f441bb72de63213667ce2af8152e3d2ce801/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b5bf0e27e0b77a48f0f8a046cb6a56280137054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5bf0e27e0b77a48f0f8a046cb6a56280137054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b5bf0e27e0b77a48f0f8a046cb6a56280137054"}], "stats": {"total": 370, "additions": 278, "deletions": 92}, "files": [{"sha": "c83763a505f1cbf6d966744afc15e592ea47a681", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8de1f441bb72de63213667ce2af8152e3d2ce801", "patch": "@@ -1,3 +1,31 @@\n+2005-05-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/15080\n+\t* trans-stmt.c (generate_loop_for_temp_to_lhs): Remove SIZE and COUNT2\n+\targuments.  If LSS is gfc_ss_terminator, increment COUNT1 by 1, instead\n+\tof incrementing COUNT2 and using COUNT1+COUNT2 increment COUNT1 and use\n+\tjust that as index.\n+\t(generate_loop_for_rhs_to_temp): Likewise.\n+\t(compute_overall_iter_number): Add INNER_SIZE_BODY argument.\n+\tIt non-NULL, add it to body.\n+\t(allocate_temp_for_forall_nest_1): New function, split from\n+\tallocate_temp_for_forall_nest.\n+\t(allocate_temp_for_forall_nest): Add INNER_SIZE_BODY argument,\n+\tpropagate it down to compute_overall_iter_number.  Use\n+\tallocate_temp_for_forall_nest_1.\n+\t(gfc_trans_assign_need_temp): Remove COUNT2.  Call\n+\tcompute_inner_temp_size into a new stmtblock_t.  Adjust calls to\n+\tallocate_temp_for_forall_nest, generate_loop_for_rhs_to_temp\n+\tand generate_loop_for_temp_to_lhs.\n+\t(gfc_trans_pointer_assign_need_temp): Adjust calls to\n+\tallocate_temp_for_forall_nest.\n+\t(gfc_evaluate_where_mask): Call compute_inner_temp_size into a new\n+\tstmtblock_t.  Call compute_overall_iter_number just once, then\n+\tallocate_temp_for_forall_nest_1 twice with the same size.\n+\tInitialize mask indexes if nested_forall_info != NULL.\n+\t(gfc_trans_where_2): Initialize mask indexes before calling\n+\tgfc_trans_nested_forall_loop.\n+\n 2005-05-15  Feng Wang <fengwang@nudt.edu.cn>\n \tJerry DeLisle <jvdelisle@verizon.net>\n "}, {"sha": "d3e86dd9d9dcbea4f93f16985cf8cf20cffa5ea9", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 160, "deletions": 90, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=8de1f441bb72de63213667ce2af8152e3d2ce801", "patch": "@@ -1516,15 +1516,14 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n /* Generate codes to copy the temporary to the actual lhs.  */\n \n static tree\n-generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n-                          tree count3, tree count1, tree count2, tree wheremask)\n+generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n+\t\t\t       tree count1, tree wheremask)\n {\n   gfc_ss *lss;\n   gfc_se lse, rse;\n   stmtblock_t block, body;\n   gfc_loopinfo loop1;\n   tree tmp, tmp2;\n-  tree index;\n   tree wheremaskexpr;\n \n   /* Walk the lhs.  */\n@@ -1548,8 +1547,10 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       gfc_add_block_to_block (&block, &lse.post);\n \n       /* Increment the count1.  */\n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size);\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1,\n+\t\t\t gfc_index_one_node);\n       gfc_add_modify_expr (&block, count1, tmp);\n+\n       tmp = gfc_finish_block (&block);\n     }\n   else\n@@ -1569,8 +1570,6 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       gfc_conv_loop_setup (&loop1);\n \n       gfc_mark_ss_chain_used (lss, 1);\n-      /* Initialize count2.  */\n-      gfc_add_modify_expr (&block, count2, gfc_index_zero_node);\n \n       /* Start the scalarized loop body.  */\n       gfc_start_scalarized_body (&loop1, &body);\n@@ -1581,11 +1580,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n \n       /* Form the expression of the temporary.  */\n       if (lss != gfc_ss_terminator)\n-        {\n-          index = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t       count1, count2);\n-          rse.expr = gfc_build_array_ref (tmp1, index);\n-        }\n+\trse.expr = gfc_build_array_ref (tmp1, count1);\n       /* Translate expr.  */\n       gfc_conv_expr (&lse, expr);\n \n@@ -1596,41 +1591,38 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n      if (wheremask)\n        {\n \t wheremaskexpr = gfc_build_array_ref (wheremask, count3);\n-         tmp2 = TREE_CHAIN (wheremask);\n-         while (tmp2)\n-           {\n-             tmp1 = gfc_build_array_ref (tmp2, count3);\n-             wheremaskexpr = build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n+\t tmp2 = TREE_CHAIN (wheremask);\n+\t while (tmp2)\n+\t   {\n+\t     tmp1 = gfc_build_array_ref (tmp2, count3);\n+\t     wheremaskexpr = build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n \t\t\t\t     wheremaskexpr, tmp1);\n-             tmp2 = TREE_CHAIN (tmp2);\n-           }\n-         tmp = build3_v (COND_EXPR, wheremaskexpr, tmp, build_empty_stmt ());\n+\t     tmp2 = TREE_CHAIN (tmp2);\n+\t   }\n+\t tmp = build3_v (COND_EXPR, wheremaskexpr, tmp, build_empty_stmt ());\n        }\n \n       gfc_add_expr_to_block (&body, tmp);\n \n-      /* Increment count2.  */\n+      /* Increment count1.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count2, gfc_index_one_node);\n-      gfc_add_modify_expr (&body, count2, tmp);\n+\t\t\t count1, gfc_index_one_node);\n+      gfc_add_modify_expr (&body, count1, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n-        {\n-          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t{\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     count3, gfc_index_one_node);\n-          gfc_add_modify_expr (&body, count3, tmp);\n-        }\n+\t  gfc_add_modify_expr (&body, count3, tmp);\n+\t}\n \n       /* Generate the copying loops.  */\n       gfc_trans_scalarizing_loops (&loop1, &body);\n       gfc_add_block_to_block (&block, &loop1.pre);\n       gfc_add_block_to_block (&block, &loop1.post);\n       gfc_cleanup_loop (&loop1);\n \n-      /* Increment count1.  */\n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size);\n-      gfc_add_modify_expr (&block, count1, tmp);\n       tmp = gfc_finish_block (&block);\n     }\n   return tmp;\n@@ -1642,15 +1634,15 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n    not be freed.  */\n \n static tree\n-generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n-\t\t\t       tree count3, tree count1, tree count2,\n-\t\t\t    gfc_ss *lss, gfc_ss *rss, tree wheremask)\n+generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n+\t\t\t       tree count1, gfc_ss *lss, gfc_ss *rss,\n+\t\t\t       tree wheremask)\n {\n   stmtblock_t block, body1;\n   gfc_loopinfo loop;\n   gfc_se lse;\n   gfc_se rse;\n-  tree tmp, tmp2, index;\n+  tree tmp, tmp2;\n   tree wheremaskexpr;\n \n   gfc_start_block (&block);\n@@ -1666,9 +1658,6 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n     }\n   else\n     {\n-      /* Initialize count2.  */\n-      gfc_add_modify_expr (&block, count2, gfc_index_zero_node);\n-\n       /* Initialize the loop.  */\n       gfc_init_loopinfo (&loop);\n \n@@ -1689,8 +1678,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n       gfc_conv_expr (&rse, expr2);\n \n       /* Form the expression of the temporary.  */\n-      index = fold_build2 (PLUS_EXPR, gfc_array_index_type, count1, count2);\n-      lse.expr = gfc_build_array_ref (tmp1, index);\n+      lse.expr = gfc_build_array_ref (tmp1, count1);\n     }\n \n   /* Use the scalar assignment.  */\n@@ -1702,12 +1690,12 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n       wheremaskexpr = gfc_build_array_ref (wheremask, count3);\n       tmp2 = TREE_CHAIN (wheremask);\n       while (tmp2)\n-        {\n-          tmp1 = gfc_build_array_ref (tmp2, count3);\n-          wheremaskexpr = build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n+\t{\n+\t  tmp1 = gfc_build_array_ref (tmp2, count3);\n+\t  wheremaskexpr = build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n \t\t\t\t  wheremaskexpr, tmp1);\n-          tmp2 = TREE_CHAIN (tmp2);\n-        }\n+\t  tmp2 = TREE_CHAIN (tmp2);\n+\t}\n       tmp = build3_v (COND_EXPR, wheremaskexpr, tmp, build_empty_stmt ());\n     }\n \n@@ -1716,21 +1704,26 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n   if (lss == gfc_ss_terminator)\n     {\n       gfc_add_block_to_block (&block, &body1);\n+\n+      /* Increment count1.  */\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1,\n+\t\t\t gfc_index_one_node);\n+      gfc_add_modify_expr (&block, count1, tmp);\n     }\n   else\n     {\n-      /* Increment count2.  */\n+      /* Increment count1.  */\n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count2, gfc_index_one_node);\n-      gfc_add_modify_expr (&body1, count2, tmp);\n+\t\t\t count1, gfc_index_one_node);\n+      gfc_add_modify_expr (&body1, count1, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n-        {\n-          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t{\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     count3, gfc_index_one_node);\n-          gfc_add_modify_expr (&body1, count3, tmp);\n-        }\n+\t  gfc_add_modify_expr (&body1, count3, tmp);\n+\t}\n \n       /* Generate the copying loops.  */\n       gfc_trans_scalarizing_loops (&loop, &body1);\n@@ -1740,11 +1733,8 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n \n       gfc_cleanup_loop (&loop);\n       /* TODO: Reuse lss and rss when copying temp->lhs.  Need to be careful\n-         as tree nodes in SS may not be valid in different scope.  */\n+\t as tree nodes in SS may not be valid in different scope.  */\n     }\n-  /* Increment count1.  */\n-  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size);\n-  gfc_add_modify_expr (&block, count1, tmp);\n \n   tmp = gfc_finish_block (&block);\n   return tmp;\n@@ -1822,7 +1812,7 @@ compute_inner_temp_size (gfc_expr *expr1, gfc_expr *expr2,\n \n static tree\n compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n-                             stmtblock_t *block)\n+\t\t\t     stmtblock_t *inner_size_body, stmtblock_t *block)\n {\n   tree tmp, number;\n   stmtblock_t body;\n@@ -1832,6 +1822,8 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n   gfc_add_modify_expr (block, number, gfc_index_zero_node);\n \n   gfc_start_block (&body);\n+  if (inner_size_body)\n+    gfc_add_block_to_block (&body, inner_size_body);\n   if (nested_forall_info)\n     tmp = build2 (PLUS_EXPR, gfc_array_index_type, number,\n \t\t  inner_size);\n@@ -1850,22 +1842,17 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n }\n \n \n-/* Allocate temporary for forall construct according to the information in\n-   nested_forall_info.  INNER_SIZE is the size of temporary needed in the\n-   assignment inside forall.  PTEMP1 is returned for space free.  */\n+/* Allocate temporary for forall construct.  SIZE is the size of temporary\n+   needed.  PTEMP1 is returned for space free.  */\n \n static tree\n-allocate_temp_for_forall_nest (forall_info * nested_forall_info, tree type,\n-                               tree inner_size, stmtblock_t * block,\n-                               tree * ptemp1)\n+allocate_temp_for_forall_nest_1 (tree type, tree size, stmtblock_t * block,\n+\t\t\t\t tree * ptemp1)\n {\n   tree unit;\n   tree temp1;\n   tree tmp;\n-  tree bytesize, size;\n-\n-  /* Calculate the total size of temporary needed in forall construct.  */\n-  size = compute_overall_iter_number (nested_forall_info, inner_size, block);\n+  tree bytesize;\n \n   unit = TYPE_SIZE_UNIT (type);\n   bytesize = fold_build2 (MULT_EXPR, gfc_array_index_type, size, unit);\n@@ -1882,7 +1869,56 @@ allocate_temp_for_forall_nest (forall_info * nested_forall_info, tree type,\n }\n \n \n-/* Handle assignments inside forall which need temporary.  */\n+/* Allocate temporary for forall construct according to the information in\n+   nested_forall_info.  INNER_SIZE is the size of temporary needed in the\n+   assignment inside forall.  PTEMP1 is returned for space free.  */\n+\n+static tree\n+allocate_temp_for_forall_nest (forall_info * nested_forall_info, tree type,\n+\t\t\t       tree inner_size, stmtblock_t * inner_size_body,\n+\t\t\t       stmtblock_t * block, tree * ptemp1)\n+{\n+  tree size;\n+\n+  /* Calculate the total size of temporary needed in forall construct.  */\n+  size = compute_overall_iter_number (nested_forall_info, inner_size,\n+\t\t\t\t      inner_size_body, block);\n+\n+  return allocate_temp_for_forall_nest_1 (type, size, block, ptemp1);\n+}\n+\n+\n+/* Handle assignments inside forall which need temporary.\n+\n+    forall (i=start:end:stride; maskexpr)\n+      e<i> = f<i>\n+    end forall\n+   (where e,f<i> are arbitrary expressions possibly involving i\n+    and there is a dependency between e<i> and f<i>)\n+   Translates to:\n+    masktmp(:) = maskexpr(:)\n+\n+    maskindex = 0;\n+    count1 = 0;\n+    num = 0;\n+    for (i = start; i <= end; i += stride)\n+      num += SIZE (f<i>)\n+    count1 = 0;\n+    ALLOCATE (tmp(num))\n+    for (i = start; i <= end; i += stride)\n+      {\n+\tif (masktmp[maskindex++])\n+\t  tmp[count1++] = f<i>\n+      }\n+    maskindex = 0;\n+    count1 = 0;\n+    for (i = start; i <= end; i += stride)\n+      {\n+\tif (masktmp[maskindex++])\n+\t  e<i> = tmp[count1++]\n+      }\n+    DEALLOCATE (tmp)\n+  */\n static void\n gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n                             forall_info * nested_forall_info,\n@@ -1891,17 +1927,16 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   tree type;\n   tree inner_size;\n   gfc_ss *lss, *rss;\n-  tree count, count1, count2;\n+  tree count, count1;\n   tree tmp, tmp1;\n   tree ptemp1;\n   tree mask, maskindex;\n   forall_info *forall_tmp;\n+  stmtblock_t inner_size_body;\n \n-  /* Create vars. count1 is the current iterator number of the nested forall.\n-     count2 is the current iterator number of the inner loops needed in the\n-     assignment.  */\n+  /* Create vars. count1 is the current iterator number of the nested\n+     forall.  */\n   count1 = gfc_create_var (gfc_array_index_type, \"count1\");\n-  count2 = gfc_create_var (gfc_array_index_type, \"count2\");\n \n   /* Count is the wheremask index.  */\n   if (wheremask)\n@@ -1917,15 +1952,17 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n \n   /* Calculate the size of temporary needed in the assignment. Return loop, lss\n      and rss which are used in function generate_loop_for_rhs_to_temp().  */\n-  inner_size = compute_inner_temp_size (expr1, expr2, block, &lss, &rss);\n+  gfc_init_block (&inner_size_body);\n+  inner_size = compute_inner_temp_size (expr1, expr2, &inner_size_body,\n+\t\t\t\t\t&lss, &rss);\n \n   /* The type of LHS. Used in function allocate_temp_for_forall_nest */\n   type = gfc_typenode_for_spec (&expr1->ts);\n \n   /* Allocate temporary for nested forall construct according to the\n      information in nested_forall_info and inner_size.  */\n-  tmp1 = allocate_temp_for_forall_nest (nested_forall_info, type,\n-                                inner_size, block, &ptemp1);\n+  tmp1 = allocate_temp_for_forall_nest (nested_forall_info, type, inner_size,\n+\t\t\t\t\t&inner_size_body, block, &ptemp1);\n \n   /* Initialize the maskindexes.  */\n   forall_tmp = nested_forall_info;\n@@ -1939,8 +1976,8 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n     }\n \n   /* Generate codes to copy rhs to the temporary .  */\n-  tmp = generate_loop_for_rhs_to_temp (expr2, tmp1, inner_size, count,\n-                                       count1, count2, lss, rss, wheremask);\n+  tmp = generate_loop_for_rhs_to_temp (expr2, tmp1, count, count1, lss, rss,\n+\t\t\t\t       wheremask);\n \n   /* Generate body and loops according to the information in\n      nested_forall_info.  */\n@@ -1966,8 +2003,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n     gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n   /* Generate codes to copy the temporary to lhs.  */\n-  tmp = generate_loop_for_temp_to_lhs (expr1, tmp1, inner_size, count,\n-                                       count1, count2, wheremask);\n+  tmp = generate_loop_for_temp_to_lhs (expr1, tmp1, count, count1, wheremask);\n \n   /* Generate body and loops according to the information in\n      nested_forall_info.  */\n@@ -2020,8 +2056,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       /* Allocate temporary for nested forall construct according to the\n          information in nested_forall_info and inner_size.  */\n-      tmp1 = allocate_temp_for_forall_nest (nested_forall_info,\n-                                            type, inner_size, block, &ptemp1);\n+      tmp1 = allocate_temp_for_forall_nest (nested_forall_info, type,\n+\t\t\t\t\t    inner_size, NULL, block, &ptemp1);\n       gfc_start_block (&body);\n       gfc_init_se (&lse, NULL);\n       lse.expr = gfc_build_array_ref (tmp1, count);\n@@ -2110,7 +2146,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       /* Allocate temporary for nested forall construct.  */\n       tmp1 = allocate_temp_for_forall_nest (nested_forall_info, parmtype,\n-                                            inner_size, block, &ptemp1);\n+\t\t\t\t\t    inner_size, NULL, block, &ptemp1);\n       gfc_start_block (&body);\n       gfc_init_se (&lse, NULL);\n       lse.expr = gfc_build_array_ref (tmp1, count);\n@@ -2201,7 +2237,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n     end forall\n    (where e,f,g,h<i> are arbitrary expressions possibly involving i)\n    Translates to:\n-    count = ((end + 1 - start) / staride)\n+    count = ((end + 1 - start) / stride)\n     masktmp(:) = maskexpr(:)\n \n     maskindex = 0;\n@@ -2567,20 +2603,25 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   gfc_ss *lss, *rss;\n   gfc_loopinfo loop;\n   tree ptemp1, ntmp, ptemp2;\n-  tree inner_size;\n-  stmtblock_t body, body1;\n+  tree inner_size, size;\n+  stmtblock_t body, body1, inner_size_body;\n   gfc_se lse, rse;\n   tree count;\n   tree tmpexpr;\n \n   gfc_init_loopinfo (&loop);\n \n   /* Calculate the size of temporary needed by the mask-expr.  */\n-  inner_size = compute_inner_temp_size (me, me, block, &lss, &rss);\n+  gfc_init_block (&inner_size_body);\n+  inner_size = compute_inner_temp_size (me, me, &inner_size_body, &lss, &rss);\n+\n+  /* Calculate the total size of temporary needed.  */\n+  size = compute_overall_iter_number (nested_forall_info, inner_size,\n+\t\t\t\t      &inner_size_body, block);\n \n   /* Allocate temporary for where mask.  */\n-  tmp = allocate_temp_for_forall_nest (nested_forall_info, boolean_type_node,\n-                                       inner_size, block, &ptemp1);\n+  tmp = allocate_temp_for_forall_nest_1 (boolean_type_node, size, block,\n+\t\t\t\t\t &ptemp1);\n   /* Record the temporary address in order to free it later.  */\n   if (ptemp1)\n     {\n@@ -2592,8 +2633,8 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n     }\n \n   /* Allocate temporary for !mask.  */\n-  ntmp = allocate_temp_for_forall_nest (nested_forall_info, boolean_type_node,\n-                                        inner_size, block, &ptemp2);\n+  ntmp = allocate_temp_for_forall_nest_1 (boolean_type_node, size, block,\n+\t\t\t\t\t  &ptemp2);\n   /* Record the temporary  in order to free it later.  */\n   if (ptemp2)\n     {\n@@ -2676,8 +2717,22 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   tmp1 = gfc_finish_block (&body);\n   /* If the WHERE construct is inside FORALL, fill the full temporary.  */\n   if (nested_forall_info != NULL)\n-    tmp1 = gfc_trans_nested_forall_loop (nested_forall_info, tmp1, 1, 1);\n+    {\n+      forall_info *forall_tmp;\n+      tree maskindex;\n \n+      /* Initialize the maskindexes.  */\n+      forall_tmp = nested_forall_info;\n+      while (forall_tmp != NULL)\n+\t{\n+\t  maskindex = forall_tmp->maskindex;\n+\t  if (forall_tmp->mask)\n+\t    gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n+\t  forall_tmp = forall_tmp->next_nest;\n+\t}\n+\n+      tmp1 = gfc_trans_nested_forall_loop (nested_forall_info, tmp1, 1, 1);\n+    }\n \n   gfc_add_expr_to_block (block, tmp1);\n \n@@ -2998,6 +3053,9 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n                                                 nested_forall_info, block);\n                   else\n                     {\n+\t\t      forall_info *forall_tmp;\n+\t\t      tree maskindex;\n+\n                       /* Variables to control maskexpr.  */\n                       count1 = gfc_create_var (gfc_array_index_type, \"count1\");\n                       count2 = gfc_create_var (gfc_array_index_type, \"count2\");\n@@ -3006,6 +3064,18 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n \n                       tmp = gfc_trans_where_assign (expr1, expr2, mask, count1,\n                                                     count2);\n+\n+\t\t      /* Initialize the maskindexes.  */\n+\t\t      forall_tmp = nested_forall_info;\n+\t\t      while (forall_tmp != NULL)\n+\t\t\t{\n+\t\t\t  maskindex = forall_tmp->maskindex;\n+\t\t\t  if (forall_tmp->mask)\n+\t\t\t    gfc_add_modify_expr (block, maskindex,\n+\t\t\t\t\t\t gfc_index_zero_node);\n+\t\t\t  forall_tmp = forall_tmp->next_nest;\n+\t\t\t}\n+\n                       tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n                                                           tmp, 1, 1);\n                       gfc_add_expr_to_block (block, tmp);"}, {"sha": "2e99a3620b4697a7077c6b94cc3eec89db57fe5f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8de1f441bb72de63213667ce2af8152e3d2ce801", "patch": "@@ -1,3 +1,11 @@\n+2005-05-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/15080\n+\t* gfortran.fortran-torture/execute/forall_3.f90: Remove comment\n+\tabout the test failing.\n+\t* gfortran.fortran-torture/execute/where_7.f90: New test.\n+\t* gfortran.fortran-torture/execute/where_8.f90: New test.\n+\n 2005-05-16  Richard Henderson  <rth@redhat.com>\n \n \t* lib/target-supports.exp (check_effective_target_vect_int_mul): Add"}, {"sha": "cab07579539b93aa7b6c68d346d4cd6c6828e933", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/forall_3.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fforall_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fforall_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fforall_3.f90?ref=8de1f441bb72de63213667ce2af8152e3d2ce801", "patch": "@@ -1,6 +1,5 @@\n+! PR fortran/15080\n ! Really test forall with temporary\n-! This test fails (2004-06-28).  See PR15080.  I'd XFAIL it,\n-! but there doesn't seem to be an easy way to do this for torture tests.\n program evil_forall\n   implicit none\n   type t"}, {"sha": "49dc5952a9fbb2b5ae75c0b6b45d5fc458d83538", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/where_7.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere_7.f90?ref=8de1f441bb72de63213667ce2af8152e3d2ce801", "patch": "@@ -0,0 +1,53 @@\n+! Really test where inside forall with temporary\n+program evil_where\n+  implicit none\n+  type t\n+    logical valid\n+    integer :: s\n+    integer, dimension(:), pointer :: p\n+  end type\n+  type (t), dimension (5) :: v\n+  integer i\n+\n+  allocate (v(1)%p(2))\n+  allocate (v(2)%p(8))\n+  v(3)%p => NULL()\n+  allocate (v(4)%p(8))\n+  allocate (v(5)%p(2))\n+\n+  v(:)%valid = (/.true., .true., .false., .true., .true./)\n+  v(:)%s = (/1, 8, 999, 6, 2/)\n+  v(1)%p(:) = (/9, 10/)\n+  v(2)%p(:) = (/1, 2, 3, 4, 5, 6, 7, 8/)\n+  v(4)%p(:) = (/13, 14, 15, 16, 17, 18, 19, 20/)\n+  v(5)%p(:) = (/11, 12/)\n+\n+  forall (i=1:5,v(i)%valid)\n+    where (v(i)%p(1:v(i)%s).gt.4)\n+      v(i)%p(1:v(i)%s) = v(6-i)%p(1:v(i)%s)\n+    end where\n+  end forall\n+\n+  if (any(v(1)%p(:) .ne. (/11, 10/))) call abort\n+  if (any(v(2)%p(:) .ne. (/1, 2, 3, 4, 17, 18, 19, 20/))) call abort\n+  if (any(v(4)%p(:) .ne. (/1, 2, 3, 4, 5, 6, 19, 20/))) call abort\n+  if (any(v(5)%p(:) .ne. (/9, 10/))) call abort\n+\n+  v(1)%p(:) = (/9, 10/)\n+  v(2)%p(:) = (/1, 2, 3, 4, 5, 6, 7, 8/)\n+  v(4)%p(:) = (/13, 14, 15, 16, 17, 18, 19, 20/)\n+  v(5)%p(:) = (/11, 12/)\n+\n+  forall (i=1:5,v(i)%valid)\n+    where (v(i)%p(1:v(i)%s).le.4)\n+      v(i)%p(1:v(i)%s) = v(6-i)%p(1:v(i)%s)\n+    end where\n+  end forall\n+\n+  if (any(v(1)%p(:) .ne. (/9, 10/))) call abort\n+  if (any(v(2)%p(:) .ne. (/13, 14, 15, 16, 5, 6, 7, 8/))) call abort\n+  if (any(v(4)%p(:) .ne. (/13, 14, 15, 16, 17, 18, 19, 20/))) call abort\n+  if (any(v(5)%p(:) .ne. (/11, 12/))) call abort\n+\n+  ! I should really free the memory I've allocated.\n+end program"}, {"sha": "58a26bd348387913711b52bb7300400a7a79e9a2", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/where_8.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de1f441bb72de63213667ce2af8152e3d2ce801/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere_8.f90?ref=8de1f441bb72de63213667ce2af8152e3d2ce801", "patch": "@@ -0,0 +1,28 @@\n+program where_8\n+  implicit none\n+  type t\n+    logical valid\n+    integer :: s\n+    integer, dimension(8) :: p\n+  end type\n+  type (t), dimension (5) :: v\n+  integer i\n+\n+  v(:)%valid = (/.true., .true., .false., .true., .true./)\n+  v(:)%s = (/1, 8, 999, 6, 2/)\n+  v(1)%p(:) = (/9, 10, 0, 0, 0, 0, 0, 0/)\n+  v(2)%p(:) = (/1, 2, 3, 4, 5, 6, 7, 8/)\n+  v(4)%p(:) = (/13, 14, 15, 16, 17, 18, 19, 20/)\n+  v(5)%p(:) = (/11, 12, 0, 0, 0, 0, 0, 0/)\n+\n+  forall (i=1:5,v(i)%valid)\n+    where (v(i)%p(1:v(i)%s).gt.4)\n+      v(i)%p(1:v(i)%s) = 21\n+    end where\n+  end forall\n+\n+  if (any(v(1)%p(:) .ne. (/21, 10, 0, 0, 0, 0, 0, 0/))) call abort\n+  if (any(v(2)%p(:) .ne. (/1, 2, 3, 4, 21, 21, 21, 21/))) call abort\n+  if (any(v(4)%p(:) .ne. (/21, 21, 21, 21, 21, 21, 19, 20/))) call abort\n+  if (any(v(5)%p(:) .ne. (/21, 21, 0, 0, 0, 0, 0, 0/))) call abort\n+end program"}]}