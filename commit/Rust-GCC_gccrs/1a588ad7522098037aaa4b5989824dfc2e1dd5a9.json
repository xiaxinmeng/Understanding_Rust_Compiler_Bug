{"sha": "1a588ad7522098037aaa4b5989824dfc2e1dd5a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE1ODhhZDc1MjIwOTgwMzdhYWE0YjU5ODk4MjRkZmMyZTFkZDVhOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-25T23:26:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-25T23:26:21Z"}, "message": "cp-tree.h (vcall_offset_in_vtable_p): New macro.\n\n\t* cp-tree.h (vcall_offset_in_vtable_p): New macro.\n\t* class.c (build_vbase_offset_vtbl_entries): Fix typo in commment.\n\t(struct vcall_offset_data_s): New type.\n\t(dfs_vcall_offset_queue_p): New function.\n\t(dfs_build_vcall_offset_vtbl_entries): Likewise.\n\t(build_vcall_offset_vtbl_entries): Likewise.\n\t(layout_vtable_decl): Likewise.\n\t(num_vfun_entries): Likewise.\n\t(num_extra_vtbl_entries): Add the entries for vcall offsets.\n\t(build_vtbl_initializer): Likewise.\n\t(dfs_finish_vtabls): Use layout_vtable_decl.\n\t(modify_one_vtables): Always duplicate vtables under the new ABI.\n\t(finish_struct_1): Use layout_vtable_decl.\n\nFrom-SVN: r31619", "tree": {"sha": "ac98c635afddd4791e9c8c208dfa2a653df0b4a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac98c635afddd4791e9c8c208dfa2a653df0b4a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a588ad7522098037aaa4b5989824dfc2e1dd5a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a588ad7522098037aaa4b5989824dfc2e1dd5a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a588ad7522098037aaa4b5989824dfc2e1dd5a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a588ad7522098037aaa4b5989824dfc2e1dd5a9/comments", "author": null, "committer": null, "parents": [{"sha": "0534b8047e8a12c4748f70a7bbb3267319c21216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0534b8047e8a12c4748f70a7bbb3267319c21216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0534b8047e8a12c4748f70a7bbb3267319c21216"}], "stats": {"total": 290, "additions": 254, "deletions": 36}, "files": [{"sha": "97231fb77af6719704609f6ce098acb188ff4fe1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a588ad7522098037aaa4b5989824dfc2e1dd5a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a588ad7522098037aaa4b5989824dfc2e1dd5a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a588ad7522098037aaa4b5989824dfc2e1dd5a9", "patch": "@@ -1,3 +1,19 @@\n+2000-01-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (vcall_offset_in_vtable_p): New macro.\n+\t* class.c (build_vbase_offset_vtbl_entries): Fix typo in commment.\n+\t(struct vcall_offset_data_s): New type.\n+\t(dfs_vcall_offset_queue_p): New function.\n+\t(dfs_build_vcall_offset_vtbl_entries): Likewise.\n+\t(build_vcall_offset_vtbl_entries): Likewise.\n+\t(layout_vtable_decl): Likewise.\n+\t(num_vfun_entries): Likewise.\n+\t(num_extra_vtbl_entries): Add the entries for vcall offsets.\n+\t(build_vtbl_initializer): Likewise.\n+\t(dfs_finish_vtabls): Use layout_vtable_decl.\n+\t(modify_one_vtables): Always duplicate vtables under the new ABI.\n+\t(finish_struct_1): Use layout_vtable_decl.\n+\t\n 2000-01-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl.c (member_function_or_else): Change third arg from a format"}, {"sha": "0085052d3027a56de7b466963beca6436bdade17", "filename": "gcc/cp/class.c", "status": "modified", "additions": 233, "deletions": 36, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a588ad7522098037aaa4b5989824dfc2e1dd5a9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a588ad7522098037aaa4b5989824dfc2e1dd5a9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1a588ad7522098037aaa4b5989824dfc2e1dd5a9", "patch": "@@ -146,7 +146,13 @@ static tree dfs_set_offset_for_shared_vbases PROTO((tree, void *));\n static tree dfs_set_offset_for_unshared_vbases PROTO((tree, void *));\n static tree dfs_build_vbase_offset_vtbl_entries PROTO((tree, void *));\n static tree build_vbase_offset_vtbl_entries PROTO((tree, tree));\n+static tree dfs_vcall_offset_queue_p PROTO((tree, void *));\n+static tree dfs_build_vcall_offset_vtbl_entries PROTO((tree, void *));\n+static tree build_vcall_offset_vtbl_entries PROTO((tree, tree));\n+static tree dfs_count_virtuals PROTO((tree, void *));\n static void start_vtable PROTO((tree, int *));\n+static void layout_vtable_decl PROTO((tree, int));\n+static int num_vfun_entries PROTO((tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -324,7 +330,7 @@ build_vbase_offset_vtbl_entries (binfo, t)\n \t    list);\n   inits = nreverse (TREE_VALUE (list));\n \n-  /* We've now got offsets in the right oder.  However, the offsets\n+  /* We've now got offsets in the right order.  However, the offsets\n      we've stored are offsets from the beginning of the complete\n      object, and we need offsets from this BINFO.  */\n   for (init = inits; init; init = TREE_CHAIN (init))\n@@ -345,6 +351,140 @@ build_vbase_offset_vtbl_entries (binfo, t)\n   return inits;\n }\n \n+typedef struct vcall_offset_data_s\n+{\n+  /* The binfo for the most-derived type.  */\n+  tree derived;\n+  /* The binfo for the virtual base for which we're building\n+     initializers.  */\n+  tree vbase;\n+  /* The vcall offset initializers built up so far.  */\n+  tree inits;\n+  /* The number of vcall offsets accumulated.  */\n+  int offsets;\n+} vcall_offset_data;\n+\n+/* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n+\n+static tree\n+dfs_vcall_offset_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  vcall_offset_data* vod = (vcall_offset_data *) data;\n+\n+  return (binfo == vod->vbase) ? binfo : dfs_skip_vbases (binfo, NULL);\n+}\n+\n+/* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n+\n+static tree\n+dfs_build_vcall_offset_vtbl_entries (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  vcall_offset_data* vod;\n+  tree virtuals;\n+  tree binfo_inits;\n+\n+  /* Primary bases are not interesting; all of the virtual\n+     function table entries have been overridden.  */\n+  if (BINFO_PRIMARY_MARKED_P (binfo))\n+     return NULL_TREE;\n+\n+  vod = (vcall_offset_data *) data;\n+  binfo_inits = NULL_TREE;\n+\n+  /* We chain the offsets on in reverse order.  That's correct --\n+     build_vtbl_initializer will straighten them out.  */\n+  for (virtuals = skip_rtti_stuff (binfo,\n+\t\t\t\t   BINFO_TYPE (binfo),\n+\t\t\t\t   NULL);\n+       virtuals;\n+       virtuals = TREE_CHAIN (virtuals))\n+    {\n+      tree fn;\n+      tree base;\n+      tree base_binfo;\n+      tree offset;\n+\n+      /* Figure out what function we're looking at.  */\n+      fn = TREE_VALUE (virtuals);\n+      base = DECL_CLASS_CONTEXT (fn);\n+\n+      /* The FN is comes from BASE.  So, we must caculate the\n+\t adjustment from the virtual base that derived from BINFO to\n+\t BASE.  */\n+      base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n+      offset = ssize_binop (MINUS_EXPR,\n+\t\t\t    BINFO_OFFSET (base_binfo),\n+\t\t\t    BINFO_OFFSET (vod->vbase));\n+      offset = build1 (NOP_EXPR, vtable_entry_type, offset);\n+      offset = fold (offset);\n+      TREE_CONSTANT (offset) = 1;\n+      binfo_inits = tree_cons (NULL_TREE, offset, binfo_inits);\n+    }\n+\n+  /* Now add the initializers we've just created to the list that will\n+     be returned to our caller.  */\n+  vod->inits = chainon (vod->inits, binfo_inits);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns the initializers for the vcall offset entries in the vtable\n+   for BINFO (which is part of the class hierarchy dominated by T), in\n+   reverse order.  */\n+\n+static tree\n+build_vcall_offset_vtbl_entries (binfo, t)\n+     tree binfo;\n+     tree t;\n+{\n+  vcall_offset_data vod;\n+\n+  /* Under the old ABI, the adjustments to the `this' pointer were made\n+     elsewhere.  */\n+  if (!vcall_offsets_in_vtable_p ())\n+    return NULL_TREE;\n+\n+  /* We only need these entries if this base is a virtual base.  */\n+  if (!TREE_VIA_VIRTUAL (binfo))\n+    return NULL_TREE;\n+\n+  /* We need a vcall offset for each of the virtual functions in this\n+     vtable.  For example:\n+\n+       class A { virtual void f (); };\n+       class B : virtual public A { };\n+       class C: virtual public A, public B {};\n+      \n+     Now imagine:\n+\n+       B* b = new C;\n+       b->f();\n+\n+     The location of `A' is not at a fixed offset relative to `B'; the\n+     offset depends on the complete object derived from `B'.  So, \n+     `B' vtable contains an entry for `f' that indicates by what\n+     amount the `this' pointer for `B' needs to be adjusted to arrive\n+     at `A'.  \n+\n+     We need entries for all the functions in our primary vtable and\n+     in our non-virtual bases vtables.  For each base, the entries\n+     appear in the same order as in the base; but the bases themselves\n+     appear in reverse depth-first, left-to-right order.  */\n+  vod.derived = t;\n+  vod.vbase = binfo;\n+  vod.inits = NULL_TREE;\n+  dfs_walk (binfo,\n+\t    dfs_build_vcall_offset_vtbl_entries,\n+\t    dfs_vcall_offset_queue_p,\n+\t    &vod);\n+\n+  return vod.inits;\n+}\n+\n /* Returns a pointer to the virtual base class of EXP that has the\n    indicated TYPE.  EXP is of class type, not a pointer type.  */\n \n@@ -2321,6 +2461,68 @@ duplicate_tag_error (t)\n   TYPE_NONCOPIED_PARTS (t) = NULL_TREE;\n }\n \n+/* Make the BINFO's vtablehave N entries, including RTTI entries, but\n+   not including vbase and vcall offsets.  Set its type and call the\n+   backend to lay it out.  */\n+\n+static void\n+layout_vtable_decl (binfo, n)\n+     tree binfo;\n+     int n;\n+{\n+  tree itype;\n+  tree atype;\n+\n+  itype = size_int (n);\n+  itype = size_binop (PLUS_EXPR, \n+\t\t      itype,\n+\t\t      num_extra_vtbl_entries (binfo));\n+  atype = build_cplus_array_type (vtable_entry_type, \n+\t\t\t\t  build_index_type (itype));\n+  layout_type (atype);\n+\n+  /* We may have to grow the vtable.  */\n+  if (!same_type_p (TREE_TYPE (BINFO_VTABLE (binfo)), atype))\n+    {\n+      TREE_TYPE (BINFO_VTABLE (binfo)) = atype;\n+      DECL_SIZE (BINFO_VTABLE (binfo)) = 0;\n+      layout_decl (BINFO_VTABLE (binfo), 0);\n+      /* At one time the vtable info was grabbed 2 words at a time.  This\n+\t fails on sparc unless you have 8-byte alignment.  (tiemann) */\n+      DECL_ALIGN (BINFO_VTABLE (binfo))\n+\t= MAX (TYPE_ALIGN (double_type_node),\n+\t       DECL_ALIGN (BINFO_VTABLE (binfo)));\n+    }\n+}\n+\n+/* Returns the number of virtual function table entries (excluding\n+   RTTI information, vbase and vcall offests, etc.) in the vtable for\n+   BINFO.  */\n+\n+static int\n+num_vfun_entries (binfo)\n+     tree binfo;\n+{\n+  return list_length (skip_rtti_stuff (binfo,\n+\t\t\t\t       BINFO_TYPE (binfo),\n+\t\t\t\t       NULL));\n+}\n+\n+/* Called from num_extra_vtbl_entries via dfs_walk.  */\n+\n+static tree\n+dfs_count_virtuals (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  /* Non-primary bases are not interesting; all of the virtual\n+     function table entries have been overridden.  */\n+  if (!BINFO_PRIMARY_MARKED_P (binfo))\n+    ((vcall_offset_data *) data)->offsets += num_vfun_entries (binfo);\n+  \n+  return NULL_TREE;\n+}\n+\n /* Returns the number of extra entries (at negative indices) required\n    for BINFO's vtable.  */\n \n@@ -2331,17 +2533,29 @@ num_extra_vtbl_entries (binfo)\n   tree type;\n   int entries;\n \n-  /* Under the old ABI, there are no entries at negative offsets.  */\n-  if (!vbase_offsets_in_vtable_p ())\n-    return size_zero_node;\n-\n   type = BINFO_TYPE (binfo);\n   entries = 0;\n \n   /* There is an entry for the offset to each virtual base.  */\n-  entries += list_length (CLASSTYPE_VBASECLASSES (type));\n+  if (vbase_offsets_in_vtable_p ())\n+    entries += list_length (CLASSTYPE_VBASECLASSES (type));\n+\n+  /* If this is a virtual base, there are entries for each virtual\n+     function defined in this class or its bases.  */\n+  if (vcall_offsets_in_vtable_p () && TREE_VIA_VIRTUAL (binfo))\n+    {\n+      vcall_offset_data vod;\n \n-  return size_int (entries);\n+      vod.vbase = binfo;\n+      vod.offsets = 0;\n+      dfs_walk (binfo,\n+\t\tdfs_count_virtuals,\n+\t\tdfs_vcall_offset_queue_p,\n+\t\t&vod);\n+      entries += vod.offsets;\n+    }\n+      \n+  return entries ? size_int (entries) : size_zero_node;\n }\n \n /* Returns the offset (in bytes) from the beginning of BINFO's vtable\n@@ -2372,8 +2586,13 @@ build_vtbl_initializer (binfo, t)\n   tree inits = NULL_TREE;\n   tree type = BINFO_TYPE (binfo);\n \n+  /* Add entries to the vtable that indicate how to adjust the this\n+     pointer when calling a virtual function in this class.  */\n+  inits = build_vcall_offset_vtbl_entries (binfo, t);\n+\n   /* Add entries to the vtable for offsets to our virtual bases.  */\n-  inits = build_vbase_offset_vtbl_entries (binfo, t);\n+  inits = chainon (build_vbase_offset_vtbl_entries (binfo, t),\n+\t\t   inits);\n \n   /* Process the RTTI stuff at the head of the list.  If we're not\n      using vtable thunks, then the RTTI entry is just an ordinary\n@@ -2451,6 +2670,7 @@ dfs_finish_vtbls (binfo, data)\n       tree decl;\n       tree context;\n       \n+      layout_vtable_decl (binfo, list_length (BINFO_VIRTUALS (binfo)));\n       decl = BINFO_VTABLE (binfo);\n       context = DECL_CONTEXT (decl);\n       DECL_CONTEXT (decl) = 0;\n@@ -2675,8 +2895,10 @@ modify_one_vtable (binfo, t, fndecl)\n   tree virtuals;\n   unsigned HOST_WIDE_INT n;\n   \n-  /* update rtti entry */\n-  if (flag_rtti)\n+  /* If we're support RTTI then we always need a new vtable to point\n+     to the RTTI information.  Under the new ABI we may need a new\n+     vtable to contain vcall and vbase offsets.  */\n+  if (flag_rtti || flag_new_abi)\n     {\n       if (binfo == TYPE_BINFO (t))\n \tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))), t);\n@@ -5010,32 +5232,7 @@ finish_struct_1 (t)\n \n   /* Now lay out the virtual function table.  */\n   if (has_virtual)\n-    {\n-      /* Use size_int so values are memoized in common cases.  */\n-      tree itype;\n-      tree atype;\n-\n-      itype = size_int (has_virtual);\n-      itype = size_binop (PLUS_EXPR, \n-\t\t\t  itype,\n-\t\t\t  num_extra_vtbl_entries (TYPE_BINFO (t)));\n-      atype = build_cplus_array_type (vtable_entry_type, \n-\t\t\t\t      build_index_type (itype));\n-      layout_type (atype);\n-\n-      /* We may have to grow the vtable.  */\n-      if (TREE_TYPE (TYPE_BINFO_VTABLE (t)) != atype)\n-\t{\n-\t  TREE_TYPE (TYPE_BINFO_VTABLE (t)) = atype;\n-\t  DECL_SIZE (TYPE_BINFO_VTABLE (t)) = 0;\n-\t  layout_decl (TYPE_BINFO_VTABLE (t), 0);\n-\t  /* At one time the vtable info was grabbed 2 words at a time.  This\n-\t     fails on sparc unless you have 8-byte alignment.  (tiemann) */\n-\t  DECL_ALIGN (TYPE_BINFO_VTABLE (t))\n-\t    = MAX (TYPE_ALIGN (double_type_node),\n-\t\t   DECL_ALIGN (TYPE_BINFO_VTABLE (t)));\n-\t}\n-    }\n+    layout_vtable_decl (TYPE_BINFO (t), has_virtual);\n \n   /* If we created a new vtbl pointer for this class, add it to the\n      list.  */"}, {"sha": "0d83576c92233763072abd4d65143cb86b5aadaf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a588ad7522098037aaa4b5989824dfc2e1dd5a9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a588ad7522098037aaa4b5989824dfc2e1dd5a9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1a588ad7522098037aaa4b5989824dfc2e1dd5a9", "patch": "@@ -213,6 +213,11 @@ extern int flag_rtti;\n    stored in the object itself.  */\n #define vbase_offsets_in_vtable_p() (flag_new_abi)\n \n+/* Nonzero if displacements to the `this' pointer to use when calling\n+   virtual functions in a virtual base class are present in the\n+   vtable.  */\n+#define vcall_offsets_in_vtable_p() (flag_new_abi)\n+\n /* Nonzero if a derived class that needs a vptr should always get one,\n    even if a non-primary base class already has one.  For example,\n    given:"}]}