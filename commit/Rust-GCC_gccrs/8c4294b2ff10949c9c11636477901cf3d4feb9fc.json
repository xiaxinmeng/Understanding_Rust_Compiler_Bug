{"sha": "8c4294b2ff10949c9c11636477901cf3d4feb9fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM0Mjk0YjJmZjEwOTQ5YzljMTE2MzY0Nzc5MDFjZjNkNGZlYjlmYw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-06-10T13:41:03Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-06-10T13:41:03Z"}, "message": "Add ggc-tests.c\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add ggc-tests.o.\n\t(GTFILES): Add ggc-tests.c.\n\t* ggc-tests.c: New file.\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tselftest::ggc_tests_c_tests.\n\t* selftest.h (selftest::ggc_tests_c_tests): New prototype.\n\nFrom-SVN: r237309", "tree": {"sha": "eea610dee184736fd13d44b88712599f74c096ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eea610dee184736fd13d44b88712599f74c096ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c4294b2ff10949c9c11636477901cf3d4feb9fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4294b2ff10949c9c11636477901cf3d4feb9fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4294b2ff10949c9c11636477901cf3d4feb9fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4294b2ff10949c9c11636477901cf3d4feb9fc/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18c9b7d42460b6ea55bd506a9f751968d1355770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c9b7d42460b6ea55bd506a9f751968d1355770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c9b7d42460b6ea55bd506a9f751968d1355770"}], "stats": {"total": 536, "additions": 536, "deletions": 0}, "files": [{"sha": "9be025e4c4b083c57da35715671d1b79d9a58953", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c4294b2ff10949c9c11636477901cf3d4feb9fc", "patch": "@@ -1,3 +1,12 @@\n+2016-06-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add ggc-tests.o.\n+\t(GTFILES): Add ggc-tests.c.\n+\t* ggc-tests.c: New file.\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tselftest::ggc_tests_c_tests.\n+\t* selftest.h (selftest::ggc_tests_c_tests): New prototype.\n+\n 2016-06-10  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* match.pd (-1 / B < A): Use :c to avoid pattern duplication."}, {"sha": "776f6d7503b61425edb56901b334eee463bd9f78", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8c4294b2ff10949c9c11636477901cf3d4feb9fc", "patch": "@@ -1270,6 +1270,7 @@ OBJS = \\\n \tgcse.o \\\n \tgcse-common.o \\\n \tggc-common.o \\\n+\tggc-tests.o \\\n \tgimple.o \\\n \tgimple-builder.o \\\n \tgimple-expr.o \\\n@@ -2398,6 +2399,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.h $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/expr.h \\\n   $(srcdir)/function.c $(srcdir)/except.c \\\n+  $(srcdir)/ggc-tests.c \\\n   $(srcdir)/gcse.c $(srcdir)/godump.c \\\n   $(srcdir)/lists.c $(srcdir)/optabs-libfuncs.c \\\n   $(srcdir)/profile.c $(srcdir)/mcf.c \\"}, {"sha": "48eac03103b37ec67ffdaacea8f7cfc6bea1d47c", "filename": "gcc/ggc-tests.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2Fggc-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2Fggc-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-tests.c?ref=8c4294b2ff10949c9c11636477901cf3d4feb9fc", "patch": "@@ -0,0 +1,523 @@\n+/* Unit tests for GCC's garbage collector (and gengtype etc).\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree-core.h\"\n+#include \"tree.h\"\n+#include \"ggc-internal.h\" /* (for ggc_force_collect).  */\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+/* The various GTY markers must be outside of a namespace to be seen by\n+   gengtype, so we don't put this file within the selftest namespace.  */\n+\n+/* A helper function for writing ggc tests.  */\n+\n+static void\n+forcibly_ggc_collect ()\n+{\n+  ggc_force_collect = true;\n+  ggc_collect ();\n+  ggc_force_collect = false;\n+}\n+\n+\f\n+\n+/* Verify that a simple struct works, and that it can\n+   own references to non-roots, and have them be marked.  */\n+\n+struct GTY(()) test_struct\n+{\n+  struct test_struct *other;\n+};\n+\n+static GTY(()) test_struct *root_test_struct;\n+\n+static void\n+test_basic_struct ()\n+{\n+  root_test_struct = ggc_cleared_alloc <test_struct> ();\n+  root_test_struct->other = ggc_cleared_alloc <test_struct> ();\n+\n+  forcibly_ggc_collect ();\n+\n+  ASSERT_TRUE (ggc_marked_p (root_test_struct));\n+  ASSERT_TRUE (ggc_marked_p (root_test_struct->other));\n+}\n+\n+\f\n+\n+/* Selftest for GTY((length)).  */\n+\n+/* A test struct using GTY((length)).  */\n+\n+struct GTY(()) test_of_length\n+{\n+  int num_elem;\n+  struct test_of_length * GTY ((length (\"%h.num_elem\"))) elem[1];\n+};\n+\n+static GTY(()) test_of_length *root_test_of_length;\n+\n+static void\n+test_length ()\n+{\n+  const int count = 5;\n+  size_t sz = sizeof (test_of_length) + (count- 1) * sizeof (test_of_length *);\n+  root_test_of_length = (test_of_length *)ggc_internal_cleared_alloc (sz);\n+  root_test_of_length->num_elem = count;\n+  for (int i = 0; i < count; i++)\n+    root_test_of_length->elem[i] = ggc_cleared_alloc <test_of_length> ();\n+\n+  forcibly_ggc_collect ();\n+\n+  ASSERT_TRUE (ggc_marked_p (root_test_of_length));\n+  for (int i = 0; i < count; i++)\n+    ASSERT_TRUE (ggc_marked_p (root_test_of_length->elem[i]));\n+}\n+\n+\f\n+\n+/* Selftest for unions, GTY((tag)), and GTY((desc)).  */\n+\n+/* A struct with a reference that's an a different offset to test_struct,\n+   to ensure that we're using the correct types.  */\n+\n+struct GTY(()) test_other\n+{\n+  char dummy[256];\n+  test_struct *m_ptr;\n+};\n+\n+enum which_field\n+{\n+  WHICH_FIELD_USE_TEST_STRUCT,\n+  WHICH_FIELD_USE_TEST_OTHER\n+};\n+\n+/* An example function for use by a GTY((desc)) marker.  */\n+\n+static enum which_field\n+calc_desc (int kind)\n+{\n+  switch (kind)\n+    {\n+    case 0: return WHICH_FIELD_USE_TEST_STRUCT;\n+    case 1: return WHICH_FIELD_USE_TEST_OTHER;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* A struct containing an example of a union, showing the \"tag\" and\n+   \"desc\" markers.  */\n+\n+struct GTY(()) test_of_union\n+{\n+  int m_kind;\n+  union u {\n+    test_struct * GTY ((tag (\"WHICH_FIELD_USE_TEST_STRUCT\") )) u_test_struct;\n+    test_other * GTY ((tag (\"WHICH_FIELD_USE_TEST_OTHER\") )) u_test_other;\n+  } GTY ((desc (\"calc_desc (%0.m_kind)\"))) m_u;\n+};\n+\n+/* Example roots.  */\n+\n+static GTY(()) test_of_union *root_test_of_union_1;\n+static GTY(()) test_of_union *root_test_of_union_2;\n+\n+/* Verify that the above work correctly.  */\n+\n+static void\n+test_union ()\n+{\n+  root_test_of_union_1 = ggc_cleared_alloc <test_of_union> ();\n+  root_test_of_union_1->m_kind = 0;\n+  test_struct *ts = ggc_cleared_alloc <test_struct> ();\n+  root_test_of_union_1->m_u.u_test_struct = ts;\n+\n+  root_test_of_union_2 = ggc_cleared_alloc <test_of_union> ();\n+  root_test_of_union_2->m_kind = 1;\n+  test_other *other = ggc_cleared_alloc <test_other> ();\n+  root_test_of_union_2->m_u.u_test_other = other;\n+  test_struct *referenced_by_other = ggc_cleared_alloc <test_struct> ();\n+  other->m_ptr = referenced_by_other;\n+\n+  forcibly_ggc_collect ();\n+\n+  ASSERT_TRUE (ggc_marked_p (root_test_of_union_1));\n+  ASSERT_TRUE (ggc_marked_p (ts));\n+\n+  ASSERT_TRUE (ggc_marked_p (root_test_of_union_2));\n+  ASSERT_TRUE (ggc_marked_p (other));\n+  ASSERT_TRUE (ggc_marked_p (referenced_by_other));\n+}\n+\n+\f\n+\n+/* Verify that destructors get run when instances are collected.  */\n+\n+struct GTY(()) test_struct_with_dtor\n+{\n+  /* This struct has a destructor; it *ought* to be called\n+     by the ggc machinery when instances are collected.  */\n+  ~test_struct_with_dtor () { dtor_call_count++; }\n+\n+  static int dtor_call_count;\n+};\n+\n+int test_struct_with_dtor::dtor_call_count;\n+\n+static void\n+test_finalization ()\n+{\n+  ASSERT_FALSE (need_finalization_p <test_struct> ());\n+  ASSERT_TRUE (need_finalization_p <test_struct_with_dtor> ());\n+\n+  /* Create some garbage.  */\n+  const int count = 10;\n+  for (int i = 0; i < count; i++)\n+    ggc_cleared_alloc <test_struct_with_dtor> ();\n+\n+  test_struct_with_dtor::dtor_call_count = 0;\n+\n+  forcibly_ggc_collect ();\n+\n+  /* Verify that the destructor was run for each instance.  */\n+  ASSERT_EQ (count, test_struct_with_dtor::dtor_call_count);\n+}\n+\n+\f\n+\n+/* Verify that a global can be marked as \"deletable\".  */\n+\n+static GTY((deletable)) test_struct *test_of_deletable;\n+\n+static void\n+test_deletable_global ()\n+{\n+  test_of_deletable = ggc_cleared_alloc <test_struct> ();\n+  ASSERT_TRUE (test_of_deletable != NULL);\n+\n+  forcibly_ggc_collect ();\n+\n+  ASSERT_EQ (NULL, test_of_deletable);\n+}\n+\n+\f\n+\n+/* Verify that gengtype etc can cope with inheritance.  */\n+\n+class GTY((desc(\"%h.m_kind\"), tag(\"0\"))) example_base\n+{\n+ public:\n+  example_base ()\n+    : m_kind (0),\n+      m_a (ggc_cleared_alloc <test_struct> ())\n+  {}\n+\n+  void *\n+  operator new (size_t sz)\n+  {\n+    return ggc_internal_cleared_alloc (sz);\n+  }\n+\n+ protected:\n+  example_base (int kind)\n+    : m_kind (kind),\n+      m_a (ggc_cleared_alloc <test_struct> ())\n+  {}\n+\n+ public:\n+  int m_kind;\n+  test_struct *m_a;\n+};\n+\n+class GTY((tag(\"1\"))) some_subclass : public example_base\n+{\n+ public:\n+  some_subclass ()\n+    : example_base (1),\n+      m_b (ggc_cleared_alloc <test_struct> ())\n+  {}\n+\n+  test_struct *m_b;\n+};\n+\n+class GTY((tag(\"2\"))) some_other_subclass : public example_base\n+{\n+ public:\n+  some_other_subclass ()\n+    : example_base (2),\n+      m_c (ggc_cleared_alloc <test_struct> ())\n+  {}\n+\n+  test_struct *m_c;\n+};\n+\n+/* Various test roots, both expressed as a ptr to the actual class, and\n+   as a ptr to the base class.  */\n+static GTY(()) example_base *test_example_base;\n+static GTY(()) some_subclass *test_some_subclass;\n+static GTY(()) some_other_subclass *test_some_other_subclass;\n+static GTY(()) example_base *test_some_subclass_as_base_ptr;\n+static GTY(()) example_base *test_some_other_subclass_as_base_ptr;\n+\n+static void\n+test_inheritance ()\n+{\n+  test_example_base = new example_base ();\n+  test_some_subclass = new some_subclass ();\n+  test_some_other_subclass = new some_other_subclass ();\n+  test_some_subclass_as_base_ptr = new some_subclass ();\n+  test_some_other_subclass_as_base_ptr = new some_other_subclass ();\n+\n+  forcibly_ggc_collect ();\n+\n+  /* Verify that the roots and everything referenced by them got marked\n+     (both for fields in the base class and those in subclasses).  */\n+  ASSERT_TRUE (ggc_marked_p (test_example_base));\n+  ASSERT_TRUE (ggc_marked_p (test_example_base->m_a));\n+\n+  ASSERT_TRUE (ggc_marked_p (test_some_subclass));\n+  ASSERT_TRUE (ggc_marked_p (test_some_subclass->m_a));\n+  ASSERT_TRUE (ggc_marked_p (test_some_subclass->m_b));\n+\n+  ASSERT_TRUE (ggc_marked_p (test_some_other_subclass));\n+  ASSERT_TRUE (ggc_marked_p (test_some_other_subclass->m_a));\n+  ASSERT_TRUE (ggc_marked_p (test_some_other_subclass->m_c));\n+\n+  ASSERT_TRUE (ggc_marked_p (test_some_subclass_as_base_ptr));\n+  ASSERT_TRUE (ggc_marked_p (test_some_subclass_as_base_ptr->m_a));\n+  ASSERT_TRUE (ggc_marked_p (((some_subclass *)\n+\t\t\t      test_some_subclass_as_base_ptr)->m_b));\n+\n+  ASSERT_TRUE (ggc_marked_p (test_some_other_subclass_as_base_ptr));\n+  ASSERT_TRUE (ggc_marked_p (test_some_other_subclass_as_base_ptr->m_a));\n+  ASSERT_TRUE (ggc_marked_p (((some_other_subclass *)\n+\t\t\t      test_some_other_subclass_as_base_ptr)->m_c));\n+}\n+\n+\f\n+\n+/* Test of chain_next/chain_prev\n+\n+   Construct a very long linked list, so that without\n+   the chain_next/chain_prev optimization we'd have\n+   a stack overflow when gt_ggc_mx_test_node recurses.  */\n+\n+struct GTY(( chain_next (\"%h.m_next\"),\n+\t     chain_prev (\"%h.m_prev\") )) test_node\n+{\n+  test_node *m_prev;\n+  test_node *m_next;\n+  int m_idx;\n+};\n+\n+static GTY(()) test_node *root_test_node;\n+\n+static void\n+test_chain_next ()\n+{\n+  /* Ideally we would construct a long list so that the number of\n+     stack frames would be deep enough to crash if gengtype has created\n+     something that recurses.\n+\n+     However, as the list is lengthened to increase the chance of\n+     overflowing the stack, the test will require more time and memory\n+     to run.  On a Fedora 20 x86_64 box with 128GB of RAM, count=2000000\n+     without the chain_next optimization reliably overflowed the stack,\n+     but the test took 0.5s to run.\n+\n+     For now this test runs with a low value for \"count\", which defeats\n+     the main purpose of the test - though it at least gives us coverage\n+     for walking a GTY((chain_next)) list.\n+\n+     We could potentially increase this value once we have a better sense\n+     of the time and space requirements of the test on different hosts,\n+     or perhaps find a way to reduce the stack size when running this\n+     testcase.  */\n+  const int count = 10;\n+\n+  /* Build the linked list.  */\n+  root_test_node = ggc_cleared_alloc <test_node> ();\n+  test_node *tail_node = root_test_node;\n+  for (int i = 0; i < count; i++)\n+    {\n+      test_node *new_node = ggc_cleared_alloc <test_node> ();\n+      tail_node->m_next = new_node;\n+      new_node->m_prev = tail_node;\n+      new_node->m_idx = i;\n+      tail_node = new_node;\n+    }\n+\n+  forcibly_ggc_collect ();\n+\n+  /* If we got here, we survived.  */\n+\n+  /* Verify that all nodes in the list were marked.  */\n+  ASSERT_TRUE (ggc_marked_p (root_test_node));\n+  test_node *iter_node = root_test_node->m_next;\n+  for (int i = 0; i < count; i++)\n+    {\n+      ASSERT_TRUE (ggc_marked_p (iter_node));\n+      ASSERT_EQ (i, iter_node->m_idx);\n+      iter_node = iter_node->m_next;\n+    }\n+}\n+\n+\f\n+\n+/* Test for GTY((user)).  */\n+\n+struct GTY((user)) user_struct\n+{\n+  char dummy[16];\n+  test_struct *m_ptr;\n+};\n+\n+static GTY(()) user_struct *root_user_struct_ptr;\n+\n+/* A global for verifying that the user-provided gt_ggc_mx gets\n+   called.  */\n+static int num_calls_to_user_gt_ggc_mx;\n+\n+/* User-provided implementation of gt_ggc_mx.  */\n+\n+static void\n+gt_ggc_mx (user_struct *p)\n+{\n+  num_calls_to_user_gt_ggc_mx++;\n+  gt_ggc_mx_test_struct (p->m_ptr);\n+}\n+\n+/* User-provided implementation of gt_pch_nx.  */\n+\n+static void\n+gt_pch_nx (user_struct *p)\n+{\n+  gt_pch_nx_test_struct (p->m_ptr);\n+}\n+\n+/* User-provided implementation of gt_pch_nx.  */\n+\n+static void\n+gt_pch_nx (user_struct *p, gt_pointer_operator op, void *cookie)\n+{\n+  op (&(p->m_ptr), cookie);\n+}\n+\n+/* Verify that GTY((user)) works.  */\n+\n+static void\n+test_user_struct ()\n+{\n+  root_user_struct_ptr = ggc_cleared_alloc <user_struct> ();\n+  test_struct *referenced = ggc_cleared_alloc <test_struct> ();\n+  root_user_struct_ptr->m_ptr = referenced;\n+\n+  num_calls_to_user_gt_ggc_mx = 0;\n+\n+  forcibly_ggc_collect ();\n+\n+  ASSERT_TRUE (ggc_marked_p (root_user_struct_ptr));\n+  ASSERT_TRUE (ggc_marked_p (referenced));\n+  ASSERT_TRUE (num_calls_to_user_gt_ggc_mx > 0);\n+}\n+\n+\f\n+\n+/* Smoketest to ensure that the tree type is marked.  */\n+\n+static GTY(()) tree dummy_unittesting_tree;\n+\n+static void\n+test_tree_marking ()\n+{\n+  dummy_unittesting_tree = build_int_cst (integer_type_node, 1066);\n+\n+  forcibly_ggc_collect ();\n+\n+  ASSERT_TRUE (ggc_marked_p (dummy_unittesting_tree));\n+}\n+\n+\f\n+\n+/* Ideas for other tests:\n+   - pch-handling  */\n+\n+namespace selftest {\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+ggc_tests_c_tests ()\n+{\n+  test_basic_struct ();\n+  test_length ();\n+  test_union ();\n+  test_finalization ();\n+  test_deletable_global ();\n+  test_inheritance ();\n+  test_chain_next ();\n+  test_user_struct ();\n+  test_tree_marking ();\n+}\n+\n+} // namespace selftest\n+\n+#include \"gt-ggc-tests.h\"\n+\n+#else /* #if CHECKING_P */\n+\n+/* The #if CHECKING_P code above has various GTY-marked roots.\n+   gengtype has no knowledge of the preprocessor, and so detects\n+   these roots and writes them out to gt-ggc-tests.h.\n+   In a !CHECKING_P build we can ignore gt-ggc-tests.h, but the\n+   root tables are referenced in the various generated gtype-*.c\n+   files like this:\n+\n+      ...snip...\n+      extern const struct ggc_root_tab gt_ggc_r_gt_ggc_tests_h[];\n+      ...snip...\n+\n+      EXPORTED_CONST struct ggc_root_tab * const gt_ggc_rtab[] = {\n+        ...snip...\n+        gt_ggc_r_gt_ggc_tests_h,\n+        ...snip...\n+      };\n+\n+    Hence to avoid a link failure, we provide dummy implementations\n+    of these root tables in an unchecked build.\n+\n+    Note that these conditional roots imply that PCH files are\n+    incompatible between checked and unchecked builds.  */\n+\n+EXPORTED_CONST struct ggc_root_tab gt_ggc_r_gt_ggc_tests_h[] = {\n+  LAST_GGC_ROOT_TAB\n+};\n+\n+EXPORTED_CONST struct ggc_root_tab gt_ggc_rd_gt_ggc_tests_h[] = {\n+  LAST_GGC_ROOT_TAB\n+};\n+\n+#endif /* #else clause of #if CHECKING_P */"}, {"sha": "934e700b2e1385b06a58d03412da2be9203d6633", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=8c4294b2ff10949c9c11636477901cf3d4feb9fc", "patch": "@@ -48,6 +48,7 @@ selftest::run_tests ()\n   vec_c_tests ();\n   pretty_print_c_tests ();\n   wide_int_cc_tests ();\n+  ggc_tests_c_tests ();\n \n   /* Mid-level data structures.  */\n   input_c_tests ();"}, {"sha": "d1f8accfe126144ec80e4f7a2d047404157711a5", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4294b2ff10949c9c11636477901cf3d4feb9fc/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=8c4294b2ff10949c9c11636477901cf3d4feb9fc", "patch": "@@ -47,6 +47,7 @@ extern void et_forest_c_tests ();\n extern void fold_const_c_tests ();\n extern void function_tests_c_tests ();\n extern void gimple_c_tests ();\n+extern void ggc_tests_c_tests ();\n extern void hash_map_tests_c_tests ();\n extern void hash_set_tests_c_tests ();\n extern void input_c_tests ();"}]}