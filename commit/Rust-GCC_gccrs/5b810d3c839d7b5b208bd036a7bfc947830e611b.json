{"sha": "5b810d3c839d7b5b208bd036a7bfc947830e611b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI4MTBkM2M4MzlkN2I1YjIwOGJkMDM2YTdiZmM5NDc4MzBlNjExYg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-06T11:29:51Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-06T11:29:51Z"}, "message": "* doc/cppinternals.texi: Update.\n\nFrom-SVN: r46050", "tree": {"sha": "75faf39e4eedd33b096e8fbef9e57ab4111e9e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75faf39e4eedd33b096e8fbef9e57ab4111e9e87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b810d3c839d7b5b208bd036a7bfc947830e611b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b810d3c839d7b5b208bd036a7bfc947830e611b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b810d3c839d7b5b208bd036a7bfc947830e611b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b810d3c839d7b5b208bd036a7bfc947830e611b/comments", "author": null, "committer": null, "parents": [{"sha": "d644be7b4c9aba239a4ce9b29375cbff27705746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d644be7b4c9aba239a4ce9b29375cbff27705746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d644be7b4c9aba239a4ce9b29375cbff27705746"}], "stats": {"total": 116, "additions": 67, "deletions": 49}, "files": [{"sha": "45fb7e255ea88aec9efc211716b50c00f31e702e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b810d3c839d7b5b208bd036a7bfc947830e611b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b810d3c839d7b5b208bd036a7bfc947830e611b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b810d3c839d7b5b208bd036a7bfc947830e611b", "patch": "@@ -1,3 +1,7 @@\n+2001-10-06  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* doc/cppinternals.texi: Update.\n+\n 2001-10-06  Zack Weinberg  <zack@codesourcery.com>\n \n \t* gcc.c (main): Set this_file_error if the appropriate"}, {"sha": "95c4ceba9fafbf18e7fa6a679d91cddbd87b9aca", "filename": "gcc/doc/cppinternals.texi", "status": "modified", "additions": 63, "deletions": 49, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b810d3c839d7b5b208bd036a7bfc947830e611b/gcc%2Fdoc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b810d3c839d7b5b208bd036a7bfc947830e611b/gcc%2Fdoc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppinternals.texi?ref=5b810d3c839d7b5b208bd036a7bfc947830e611b", "patch": "@@ -41,7 +41,7 @@ into another language, under the above conditions for modified versions.\n @titlepage\n @c @finalout\n @title Cpplib Internals\n-@subtitle Last revised September 2001\n+@subtitle Last revised October 2001\n @subtitle for GCC version 3.1\n @author Neil Booth\n @page\n@@ -71,7 +71,7 @@ into another language, under the above conditions for modified versions.\n @chapter Cpplib---the core of the GNU C Preprocessor\n \n The GNU C preprocessor in GCC 3.x has been completely rewritten.  It is\n-now implemented as a library, cpplib, so it can be easily shared between\n+now implemented as a library, @dfn{cpplib}, so it can be easily shared between\n a stand-alone preprocessor, and a preprocessor integrated with the C,\n C++ and Objective-C front ends.  It is also available for use by other\n programs, though this is not recommended as its exposed interface has\n@@ -498,12 +498,13 @@ both for aesthetic reasons and because it causes problems for people who\n still try to abuse the preprocessor for things like Fortran source and\n Makefiles.\n \n-For now, just notice that the only places we need to be careful about\n-@dfn{paste avoidance} are when tokens are added (or removed) from the\n-original token stream.  This only occurs because of macro expansion, but\n-care is needed in many places: before @strong{and} after each macro\n-replacement, each argument replacement, and additionally each token\n-created by the @samp{#} and @samp{##} operators.\n+For now, just notice that when tokens are added (or removed, as shown by\n+the @code{EMPTY} example) from the original lexed token stream, we need\n+to check for accidental token pasting.  We call this @dfn{paste\n+avoidance}.  Token addition and removal can only occur because of macro\n+expansion, but accidental pasting can occur in many places: both before\n+and after each macro replacement, each argument replacement, and\n+additionally each token created by the @samp{#} and @samp{##} operators.\n \n Let's look at how the preprocessor gets whitespace output correct\n normally.  The @code{cpp_token} structure contains a flags byte, and one\n@@ -512,7 +513,7 @@ indicates that the token was preceded by whitespace of some form other\n than a new line.  The stand-alone preprocessor can use this flag to\n decide whether to insert a space between tokens in the output.\n \n-Now consider the following:\n+Now consider the result of the following macro expansion:\n \n @smallexample\n #define add(x, y, z) x + y +z;\n@@ -524,20 +525,21 @@ The interesting thing here is that the tokens @samp{1} and @samp{2} are\n output with a preceding space, and @samp{3} is output without a\n preceding space, but when lexed none of these tokens had that property.\n Careful consideration reveals that @samp{1} gets its preceding\n-whitespace from the space preceding @samp{add} in the macro\n-@emph{invocation}, @samp{2} gets its whitespace from the space preceding\n-the parameter @samp{y} in the macro @emph{replacement list}, and\n-@samp{3} has no preceding space because parameter @samp{z} has none in\n-the replacement list.\n+whitespace from the space preceding @samp{add} in the macro invocation,\n+@emph{not} replacement list.  @samp{2} gets its whitespace from the\n+space preceding the parameter @samp{y} in the macro replacement list,\n+and @samp{3} has no preceding space because parameter @samp{z} has none\n+in the replacement list.\n \n Once lexed, tokens are effectively fixed and cannot be altered, since\n pointers to them might be held in many places, in particular by\n in-progress macro expansions.  So instead of modifying the two tokens\n above, the preprocessor inserts a special token, which I call a\n-@dfn{padding token}, into the token stream in front of every macro\n-expansion and expanded macro argument, to indicate that the subsequent\n-token should assume its @code{PREV_WHITE} flag from a different\n-@dfn{source token}.  In the above example, the source tokens are\n+@dfn{padding token}, into the token stream to indicate that spacing of\n+the subsequent token is special.  The preprocessor inserts padding\n+tokens in front of every macro expansion and expanded macro argument.\n+These point to a @dfn{source token} from which the subsequent real token\n+should inherit its spacing.  In the above example, the source tokens are\n @samp{add} in the macro invocation, and @samp{y} and @samp{z} in the\n macro replacement list, respectively.\n \n@@ -551,10 +553,14 @@ a macro's first replacement token expands straight into another macro.\n         @expansion{} [baz]\n @end smallexample\n \n-Here, two padding tokens with sources @samp{foo} between the brackets,\n-and @samp{bar} from foo's replacement list, are generated.  Clearly the\n-first padding token is the one that matters.  But what if we happen to\n-leave a macro expansion?  Adjusting the above example slightly:\n+Here, two padding tokens are generated with sources the @samp{foo} token\n+between the brackets, and the @samp{bar} token from foo's replacement\n+list, respectively.  Clearly the first padding token is the one we\n+should use, so our output code should contain a rule that the first\n+padding token in a sequence is the one that matters.\n+\n+But what if we happen to leave a macro expansion?  Adjusting the above\n+example slightly:\n \n @smallexample\n #define foo bar\n@@ -564,33 +570,41 @@ leave a macro expansion?  Adjusting the above example slightly:\n         @expansion{} [ baz] ;\n @end smallexample\n \n-As shown, now there should be a space before baz and the semicolon.  Our\n-initial algorithm fails for the former, because we would see three\n-padding tokens, one per macro invocation, followed by @samp{baz}, which\n-would have inherit its spacing from the original source, @samp{foo},\n-which has no leading space.  Note that it is vital that cpplib get\n-spacing correct in these examples, since any of these macro expansions\n-could be stringified, where spacing matters.\n-\n-So, I have demonstrated that not just entering macro and argument\n-expansions, but leaving them requires special handling too.  So cpplib\n-inserts a padding token with a @code{NULL} source token when leaving\n-macro expansions and after each replaced argument in a macro's\n-replacement list.  It also inserts appropriate padding tokens on either\n-side of tokens created by the @samp{#} and @samp{##} operators.\n-\n-Now we can see the relationship with paste avoidance: we have to be\n-careful about paste avoidance in exactly the same locations we take care\n-to get white space correct.  This makes implementation of paste\n-avoidance easy: wherever the stand-alone preprocessor is fixing up\n-spacing because of padding tokens, and it turns out that no space is\n-needed, it has to take the extra step to check that a space is not\n-needed after all to avoid an accidental paste.  The function\n-@code{cpp_avoid_paste} advises whether a space is required between two\n-consecutive tokens.  To avoid excessive spacing, it tries hard to only\n-require a space if one is likely to be necessary, but for reasons of\n-efficiency it is slightly conservative and might recommend a space where\n-one is not strictly needed.\n+As shown, now there should be a space before @samp{baz} and the\n+semicolon in the output.\n+\n+The rules we decided above fail for @samp{baz}: we generate three\n+padding tokens, one per macro invocation, before the token @samp{baz}.\n+We would then have it take its spacing from the first of these, which\n+carries source token @samp{foo} with no leading space.\n+\n+It is vital that cpplib get spacing correct in these examples since any\n+of these macro expansions could be stringified, where spacing matters.\n+\n+So, this demonstrates that not just entering macro and argument\n+expansions, but leaving them requires special handling too.  I made\n+cpplib insert a padding token with a @code{NULL} source token when\n+leaving macro expansions, as well as after each replaced argument in a\n+macro's replacement list.  It also inserts appropriate padding tokens on\n+either side of tokens created by the @samp{#} and @samp{##} operators.\n+I expanded the rule so that, if we see a padding token with a\n+@code{NULL} source token, @emph{and} that source token has no leading\n+space, then we behave as if we have seen no padding tokens at all.  A\n+quick check shows this rule will then get the above example correct as\n+well.\n+\n+Now a relationship with paste avoidance is apparent: we have to be\n+careful about paste avoidance in exactly the same locations we have\n+padding tokens in order to get white space correct.  This makes\n+implementation of paste avoidance easy: wherever the stand-alone\n+preprocessor is fixing up spacing because of padding tokens, and it\n+turns out that no space is needed, it has to take the extra step to\n+check that a space is not needed after all to avoid an accidental paste.\n+The function @code{cpp_avoid_paste} advises whether a space is required\n+between two consecutive tokens.  To avoid excessive spacing, it tries\n+hard to only require a space if one is likely to be necessary, but for\n+reasons of efficiency it is slightly conservative and might recommend a\n+space where one is not strictly needed.\n \n @node Line Numbering\n @unnumbered Line numbering"}]}