{"sha": "7f426c93a7460029a565712e1665de1b9042ddca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y0MjZjOTNhNzQ2MDAyOWE1NjU3MTJlMTY2NWRlMWI5MDQyZGRjYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2012-07-04T22:17:18Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2012-07-04T22:17:18Z"}, "message": "re PR libstdc++/53830 (condition_variable_any - deadlock issue)\n\n\tPR libstdc++/53830\n\t* include/std/condition_variable (condition_variable_any::wait):\n\tMove _Unlock type to class scope.\n\t(condition_variable_any::wait_until): Reuse it.\n\t* testsuite/30_threads/condition_variable_any/53830.cc: New.\n\nFrom-SVN: r189268", "tree": {"sha": "541374b93f366c25bfb253728a273c31c64d412b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/541374b93f366c25bfb253728a273c31c64d412b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f426c93a7460029a565712e1665de1b9042ddca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f426c93a7460029a565712e1665de1b9042ddca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f426c93a7460029a565712e1665de1b9042ddca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f426c93a7460029a565712e1665de1b9042ddca/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fece06368cf6ebfc99558ae612c0cf53d2e2e5aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fece06368cf6ebfc99558ae612c0cf53d2e2e5aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fece06368cf6ebfc99558ae612c0cf53d2e2e5aa"}], "stats": {"total": 122, "additions": 103, "deletions": 19}, "files": [{"sha": "b22d9071fae27615af63fd8b0f9eb7fe21971356", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f426c93a7460029a565712e1665de1b9042ddca/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f426c93a7460029a565712e1665de1b9042ddca/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7f426c93a7460029a565712e1665de1b9042ddca", "patch": "@@ -1,3 +1,11 @@\n+2012-07-04  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/53830\n+\t* include/std/condition_variable (condition_variable_any::wait):\n+\tMove _Unlock type to class scope.\n+\t(condition_variable_any::wait_until): Reuse it.\n+\t* testsuite/30_threads/condition_variable_any/53830.cc: New.\n+\n 2012-07-04  Matthias Klose  <doko@ubuntu.com>\n \n \t* testsuite/28_regex/headers/04_header: Remove empty directory."}, {"sha": "85b50a7eaaf102049ab7a737b2b2d4600a5c4785", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f426c93a7460029a565712e1665de1b9042ddca/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f426c93a7460029a565712e1665de1b9042ddca/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=7f426c93a7460029a565712e1665de1b9042ddca", "patch": "@@ -176,6 +176,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     condition_variable\t\t\t_M_cond;\n     mutex\t\t\t\t_M_mutex;\n \n+    // scoped unlock - unlocks in ctor, re-locks in dtor\n+    template<typename _Lock>\n+      struct _Unlock\n+      {\n+\texplicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }\n+\n+\t~_Unlock() noexcept(false)\n+\t{\n+\t  if (uncaught_exception())\n+\t    __try { _M_lock.lock(); } __catch(...) { }\n+\t  else\n+\t    _M_lock.lock();\n+\t}\n+\n+\t_Unlock(const _Unlock&) = delete;\n+\t_Unlock& operator=(const _Unlock&) = delete;\n+\n+\t_Lock& _M_lock;\n+      };\n+\n   public:\n \n     condition_variable_any() noexcept;\n@@ -202,21 +222,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       wait(_Lock& __lock)\n       {\n-\t// scoped unlock - unlocks in ctor, re-locks in dtor\n-\tstruct _Unlock {\n-\t  explicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }\n-\t  ~_Unlock() noexcept(false)\n-\t  {\n-\t    if (uncaught_exception())\n-\t      __try { _M_lock.lock(); } __catch(...) { }\n-\t    else\n-\t      _M_lock.lock();\n-\t  }\n-\t  _Lock& _M_lock;\n-\t};\n-\n \tunique_lock<mutex> __my_lock(_M_mutex);\n-\t_Unlock __unlock(__lock);\n+\t_Unlock<_Lock> __unlock(__lock);\n \t// _M_mutex must be unlocked before re-locking __lock so move\n \t// ownership of _M_mutex lock to an object with shorter lifetime.\n \tunique_lock<mutex> __my_lock2(std::move(__my_lock));\n@@ -237,11 +244,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       wait_until(_Lock& __lock,\n \t\t const chrono::time_point<_Clock, _Duration>& __atime)\n       {\n-        unique_lock<mutex> __my_lock(_M_mutex);\n-        __lock.unlock();\n-        cv_status __status = _M_cond.wait_until(__my_lock, __atime);\n-        __lock.lock();\n-        return __status;\n+\tunique_lock<mutex> __my_lock(_M_mutex);\n+\t_Unlock<_Lock> __unlock(__lock);\n+\t// _M_mutex must be unlocked before re-locking __lock so move\n+\t// ownership of _M_mutex lock to an object with shorter lifetime.\n+\tunique_lock<mutex> __my_lock2(std::move(__my_lock));\n+\treturn _M_cond.wait_until(__my_lock2, __atime);\n       }\n \n     template<typename _Lock, typename _Clock,"}, {"sha": "91aa348f90c828203c4217834a1353ffb92a68bc", "filename": "libstdc++-v3/testsuite/30_threads/condition_variable_any/53830.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f426c93a7460029a565712e1665de1b9042ddca/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2F53830.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f426c93a7460029a565712e1665de1b9042ddca/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2F53830.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2F53830.cc?ref=7f426c93a7460029a565712e1665de1b9042ddca", "patch": "@@ -0,0 +1,68 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-sched-yield \"\" }\n+// { dg-require-nanosleep \"\" }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// PR libstdc++/53830\n+// Test for deadlock in condition_variable_any::wait_for\n+\n+#include <thread>\n+#include <mutex>\n+#include <condition_variable>\n+#include <chrono>\n+#include <atomic>\n+\n+std::mutex mutex;\n+std::condition_variable_any cv;\n+\n+std::atomic<int> barrier(0);\n+\n+// waits for data from another thread\n+void wait_for_data()\n+{\n+  std::unique_lock<std::mutex> lock(mutex);\n+  barrier = 1;\n+  cv.wait_for(lock, std::chrono::milliseconds(100), []{ return false; });\n+  // read data\n+}\n+\n+// passes data to waiting thread\n+void provide_data()\n+{\n+  while (barrier == 0)\n+    std::this_thread::yield();\n+  std::unique_lock<std::mutex> lock(mutex);\n+  // pass data\n+  std::this_thread::sleep_for(std::chrono::seconds(1));\n+  cv.notify_one();\n+}\n+\n+int main()\n+{\n+  std::thread thread1(wait_for_data);\n+  provide_data();\n+  thread1.join();\n+  return 0;\n+}\n+"}]}