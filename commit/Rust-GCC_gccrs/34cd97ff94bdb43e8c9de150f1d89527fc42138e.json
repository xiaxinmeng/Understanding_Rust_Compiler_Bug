{"sha": "34cd97ff94bdb43e8c9de150f1d89527fc42138e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRjZDk3ZmY5NGJkYjQzZThjOWRlMTUwZjFkODk1MjdmYzQyMTM4ZQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-08-05T06:01:47Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-08-12T18:27:56Z"}, "message": "Remove legacy back threader.\n\nAt this point I don't see any use for the legacy mode, which I had\noriginally left in place during the transition.\n\nThis patch removes the legacy back threader, and cleans up the code a\nbit.  There are no functional changes to the non-legacy code.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* doc/invoke.texi: Remove docs for threader-mode param.\n\t* flag-types.h (enum threader_mode): Remove.\n\t* params.opt: Remove threader-mode param.\n\t* tree-ssa-threadbackward.c (class back_threader): Remove\n\tpath_is_unreachable_p.\n\tMake find_paths private.\n\tAdd maybe_thread and thread_through_all_blocks.\n\tRemove reference marker for m_registry.\n\tRemove reference marker for m_profit.\n\t(back_threader::back_threader): Adjust for registry and profit not\n\tbeing references.\n\t(dump_path): Move down.\n\t(debug): Move down.\n\t(class thread_jumps): Remove.\n\t(class back_threader_registry): Remove m_all_paths.\n\tRemove destructor.\n\t(thread_jumps::thread_through_all_blocks): Move to back_threader\n\tclass.\n\t(fsm_find_thread_path): Remove\n\t(back_threader::maybe_thread): New.\n\t(back_threader::thread_through_all_blocks): Move from\n\tthread_jumps.\n\t(back_threader_registry::back_threader_registry): Remove\n\tm_all_paths.\n\t(back_threader_registry::~back_threader_registry): Remove.\n\t(thread_jumps::find_taken_edge): Remove.\n\t(thread_jumps::check_subpath_and_update_thread_path): Remove.\n\t(thread_jumps::maybe_register_path): Remove.\n\t(thread_jumps::handle_phi): Remove.\n\t(handle_assignment_p): Remove.\n\t(thread_jumps::handle_assignment): Remove.\n\t(thread_jumps::fsm_find_control_statement_thread_paths): Remove.\n\t(thread_jumps::find_jump_threads_backwards): Remove.\n\t(thread_jumps::find_jump_threads_backwards_with_ranger): Remove.\n\t(try_thread_blocks): Rename find_jump_threads_backwards to\n\tmaybe_thread.\n\t(pass_early_thread_jumps::execute): Same.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Remove call into the legacy\n\tcode and adjust for ranger threader.", "tree": {"sha": "6927f760e70f7c1f8dc1fb5fccb706bdd88da16e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6927f760e70f7c1f8dc1fb5fccb706bdd88da16e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34cd97ff94bdb43e8c9de150f1d89527fc42138e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34cd97ff94bdb43e8c9de150f1d89527fc42138e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34cd97ff94bdb43e8c9de150f1d89527fc42138e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34cd97ff94bdb43e8c9de150f1d89527fc42138e/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3a7fbcb7c7a1016ceac2ceaf79b28c17ce9fcd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a7fbcb7c7a1016ceac2ceaf79b28c17ce9fcd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a7fbcb7c7a1016ceac2ceaf79b28c17ce9fcd7"}], "stats": {"total": 569, "additions": 61, "deletions": 508}, "files": [{"sha": "57b97a0838cec8bd43b2782fcd66c22122be5c68", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=34cd97ff94bdb43e8c9de150f1d89527fc42138e", "patch": "@@ -13421,9 +13421,6 @@ Setting to 0 disables the analysis completely.\n @item modref-max-escape-points\n Specifies the maximum number of escape points tracked by modref per SSA-name.\n \n-@item threader-mode\n-Specifies the mode the backwards threader should run in.\n-\n @item profile-func-internal-id\n A parameter to control whether to use function internal id in profile\n database lookup. If the value is 0, the compiler uses an id that"}, {"sha": "e43d1de490df7a2142dbbdb16fd348a4841a5dbb", "filename": "gcc/flag-types.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=34cd97ff94bdb43e8c9de150f1d89527fc42138e", "patch": "@@ -454,13 +454,6 @@ enum evrp_mode\n   EVRP_MODE_RVRP_DEBUG = EVRP_MODE_RVRP_ONLY | EVRP_MODE_DEBUG\n };\n \n-/* Backwards threader mode.  */\n-enum threader_mode\n-{\n-  THREADER_MODE_LEGACY = 0,\n-  THREADER_MODE_RANGER = 1\n-};\n-\n /* Modes of OpenACC 'kernels' constructs handling.  */\n enum openacc_kernels\n {"}, {"sha": "92b003e38cbb18ec6d3570c7c7f717fe42a3d9c5", "filename": "gcc/params.opt", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=34cd97ff94bdb43e8c9de150f1d89527fc42138e", "patch": "@@ -1010,19 +1010,6 @@ Maximum depth of DFS walk used by modref escape analysis.\n Common Joined UInteger Var(param_modref_max_escape_points) Init(256) Param Optimization\n Maximum number of escape points tracked by modref per SSA-name.\n \n--param=threader-mode=\n-Common Joined Var(param_threader_mode) Enum(threader_mode) Init(THREADER_MODE_RANGER) Param Optimization\n---param=threader-mode=[legacy|ranger] Specifies the mode the backwards threader should run in.\n-\n-Enum\n-Name(threader_mode) Type(enum threader_mode) UnknownError(unknown threader mode %qs)\n-\n-EnumValue\n-Enum(threader_mode) String(legacy) Value(THREADER_MODE_LEGACY)\n-\n-EnumValue\n-Enum(threader_mode) String(ranger) Value(THREADER_MODE_RANGER)\n-\n -param=tm-max-aggregate-size=\n Common Joined UInteger Var(param_tm_max_aggregate_size) Init(9) Param Optimization\n Size in bytes after which thread-local aggregates should be instrumented with the logging functions instead of save/restore pairs."}, {"sha": "5fc2145a4322ed328ef55aba54eca3662f489f82", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c?ref=34cd97ff94bdb43e8c9de150f1d89527fc42138e", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-thread1-stats -fdump-tree-thread2-stats -fdump-tree-dom2-stats -fdump-tree-thread3-stats -fdump-tree-dom3-stats -fdump-tree-vrp2-stats -fno-guess-branch-probability\" } */\n-/* { dg-additional-options \"--param=threader-mode=legacy\" } */\n \n /* Here we have the same issue as was commented in ssa-dom-thread-6.c.\n    The PHI coming into the threader has a lot more constants, so the\n@@ -17,7 +16,7 @@\n   basically tracking the switch index better through multiple\n   paths.  */\n \n-/* { dg-final { scan-tree-dump \"Jumps threaded: 19\"  \"thread1\" } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 18\"  \"thread1\" } } */\n /* { dg-final { scan-tree-dump \"Jumps threaded: 8\" \"thread2\" } } */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\"  \"dom2\" } } */\n "}, {"sha": "3aad1493c4da0463a139e5e72d5a17bf49dafa7d", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 60, "deletions": 483, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd97ff94bdb43e8c9de150f1d89527fc42138e/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=34cd97ff94bdb43e8c9de150f1d89527fc42138e", "patch": "@@ -51,12 +51,9 @@ class back_threader_registry\n {\n public:\n   back_threader_registry (int max_allowable_paths);\n-  ~back_threader_registry ();\n   bool register_path (const vec<basic_block> &, edge taken);\n   bool thread_through_all_blocks ();\n-\n private:\n-  vec<vec<basic_block>> m_all_paths;\n   jump_thread_path_registry m_lowlevel_registry;\n   const int m_max_allowable_paths;\n   int m_threaded_paths;\n@@ -72,24 +69,19 @@ class back_threader_profitability\n   { }\n   bool profitable_path_p (const vec<basic_block> &, tree name, edge taken,\n \t\t\t  bool *irreducible_loop = NULL);\n-\n private:\n   const bool m_speed_p;\n };\n \n-// Ranger based backwards threader.\n-\n class back_threader\n {\n-  // Temporary until we remove old code.\n-  friend bool path_is_unreachable_p (const vec<jump_thread_edge *> &);\n-\n public:\n-  back_threader (back_threader_profitability &, back_threader_registry &);\n+  back_threader (bool speed_p);\n   ~back_threader ();\n-  void find_paths (basic_block bb, tree name);\n-\n+  void maybe_thread_block (basic_block bb);\n+  bool thread_through_all_blocks ();\n private:\n+  void find_paths (basic_block bb, tree name);\n   void maybe_register_path (edge taken_edge);\n   bool find_paths_to_names (basic_block bb, bitmap imports);\n   bool resolve_def (tree name, bitmap interesting, vec<tree> &worklist);\n@@ -98,8 +90,8 @@ class back_threader\n   edge find_taken_edge_cond (const vec<basic_block> &path, gcond *);\n   edge find_taken_edge_switch (const vec<basic_block> &path, gswitch *);\n \n-  back_threader_registry &m_registry;\n-  back_threader_profitability &m_profit;\n+  back_threader_registry m_registry;\n+  back_threader_profitability m_profit;\n   gimple_ranger m_ranger;\n   path_range_query m_solver;\n \n@@ -123,10 +115,9 @@ class back_threader\n // in a the given direction.\n const edge back_threader::UNREACHABLE_EDGE = (edge) -1;\n \n-back_threader::back_threader (back_threader_profitability &profit,\n-\t\t\t      back_threader_registry &registry)\n-  : m_registry (registry),\n-    m_profit (profit),\n+back_threader::back_threader (bool speed_p)\n+  : m_registry (param_max_fsm_thread_paths),\n+    m_profit (speed_p),\n     m_solver (m_ranger)\n {\n   m_last_stmt = NULL;\n@@ -456,74 +447,9 @@ back_threader::find_paths (basic_block bb, tree name)\n     }\n }\n \n-// Dump a sequence of BBs through the CFG.\n-\n-DEBUG_FUNCTION void\n-dump_path (FILE *dump_file, const vec<basic_block> &path)\n-{\n-  for (size_t i = 0; i < path.length (); ++i)\n-    {\n-      fprintf (dump_file, \"BB%d\", path[i]->index);\n-      if (i + 1 < path.length ())\n-\tfprintf (dump_file, \" <- \");\n-    }\n-  fprintf (dump_file, \"\\n\");\n-}\n-\n-DEBUG_FUNCTION void\n-debug (const vec <basic_block> &path)\n-{\n-  dump_path (stderr, path);\n-}\n-\n-class thread_jumps\n-{\n-public:\n-  thread_jumps (bool speed_p = true)\n-    : m_profit (speed_p),\n-      m_registry (param_max_fsm_thread_paths),\n-      m_back_threader (m_profit, m_registry)\n-  { }\n-  void find_jump_threads_backwards (basic_block bb);\n-  void find_jump_threads_backwards_with_ranger (basic_block bb);\n-  bool thread_through_all_blocks ();\n-\n-private:\n-  void maybe_register_path (const vec<basic_block> &m_path,\n-\t\t\t    tree name,\n-\t\t\t    edge taken_edge);\n-  edge find_taken_edge (const vec<basic_block> &path, tree arg);\n-  void handle_assignment (gimple *stmt, basic_block def_bb);\n-  void handle_phi (gphi *phi, basic_block def_bb);\n-  void fsm_find_control_statement_thread_paths (tree name);\n-  bool check_subpath_and_update_thread_path (basic_block last_bb,\n-\t\t\t\t\t     basic_block new_bb,\n-\t\t\t\t\t     int *next_path_length);\n-\n-  /* Hash to keep track of seen bbs.  */\n-  hash_set<basic_block> m_visited_bbs;\n-  /* Current path we're analyzing.  */\n-  auto_vec<basic_block> m_path;\n-  /* Tracks if we have recursed through a loop PHI node.  */\n-  bool m_seen_loop_phi;\n-\n-  tree m_name;\n-  back_threader_profitability m_profit;\n-  back_threader_registry m_registry;\n-  back_threader m_back_threader;\n-};\n-\n-// Perform the actual jump threading for the all queued paths.\n-\n-bool\n-thread_jumps::thread_through_all_blocks ()\n-{\n-  return m_registry.thread_through_all_blocks ();\n-}\n-\n-/* Simple helper to get the last statement from BB, which is assumed\n-   to be a control statement.   Return NULL if the last statement is\n-   not a control statement.  */\n+// Simple helper to get the last statement from BB, which is assumed\n+// to be a control statement.  Return NULL if the last statement is\n+// not a control statement.\n \n static gimple *\n get_gimple_control_stmt (basic_block bb)\n@@ -540,55 +466,65 @@ get_gimple_control_stmt (basic_block bb)\n   return NULL;\n }\n \n-/* Return true if the CFG contains at least one path from START_BB to\n-   END_BB.  When a path is found, record in PATH the blocks from\n-   END_BB to START_BB.  LOCAL_VISITED_BBS is used to make sure we\n-   don't fall into an infinite loop.  Bound the recursion to basic\n-   blocks belonging to LOOP.  */\n+// Search backwards from BB looking for paths where the final\n+// conditional maybe threaded to a successor block.  Record such paths\n+// for jump threading.\n \n-static bool\n-fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n-\t\t      vec<basic_block> &path,\n-\t\t      hash_set<basic_block> &local_visited_bbs,\n-\t\t      loop_p loop)\n+void\n+back_threader::maybe_thread_block (basic_block bb)\n {\n-  if (loop != start_bb->loop_father)\n-    return false;\n+  gimple *stmt = get_gimple_control_stmt (bb);\n+  if (!stmt)\n+    return;\n \n-  if (start_bb == end_bb)\n-    {\n-      path.safe_push (start_bb);\n-      return true;\n-    }\n+  enum gimple_code code = gimple_code (stmt);\n+  tree name;\n+  if (code == GIMPLE_SWITCH)\n+    name = gimple_switch_index (as_a <gswitch *> (stmt));\n+  else if (code == GIMPLE_COND)\n+    name = gimple_cond_lhs (stmt);\n+  else if (code == GIMPLE_GOTO)\n+    name = gimple_goto_dest (stmt);\n+  else\n+    name = NULL;\n+\n+  find_paths (bb, name);\n+}\n+\n+// Perform the actual jump threading for the all queued paths.\n+\n+bool\n+back_threader::thread_through_all_blocks ()\n+{\n+  return m_registry.thread_through_all_blocks ();\n+}\n+\n+// Dump a sequence of BBs through the CFG.\n \n-  if (!local_visited_bbs.add (start_bb))\n+DEBUG_FUNCTION void\n+dump_path (FILE *dump_file, const vec<basic_block> &path)\n+{\n+  for (size_t i = 0; i < path.length (); ++i)\n     {\n-      edge e;\n-      edge_iterator ei;\n-      FOR_EACH_EDGE (e, ei, start_bb->succs)\n-\tif (fsm_find_thread_path (e->dest, end_bb, path, local_visited_bbs,\n-\t\t\t\t  loop))\n-\t  {\n-\t    path.safe_push (start_bb);\n-\t    return true;\n-\t  }\n+      fprintf (dump_file, \"BB%d\", path[i]->index);\n+      if (i + 1 < path.length ())\n+\tfprintf (dump_file, \" <- \");\n     }\n+  fprintf (dump_file, \"\\n\");\n+}\n \n-  return false;\n+DEBUG_FUNCTION void\n+debug (const vec <basic_block> &path)\n+{\n+  dump_path (stderr, path);\n }\n \n back_threader_registry::back_threader_registry (int max_allowable_paths)\n   : m_max_allowable_paths (max_allowable_paths)\n {\n-  m_all_paths.create (5);\n   m_threaded_paths = 0;\n }\n \n-back_threader_registry::~back_threader_registry ()\n-{\n-  m_all_paths.release ();\n-}\n-\n bool\n back_threader_registry::thread_through_all_blocks ()\n {\n@@ -881,39 +817,6 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n   return true;\n }\n \n-/* Return the taken edge out of a path, assuming that the underlying assignment\n-   or PHI SSA resolves to ARG.  */\n-\n-edge\n-thread_jumps::find_taken_edge (const vec<basic_block> &path, tree arg)\n-{\n-  if (TREE_CODE_CLASS (TREE_CODE (arg)) != tcc_constant)\n-    return NULL;\n-\n-  gcc_checking_assert (!path.is_empty ());\n-  gimple *stmt = get_gimple_control_stmt (m_path[0]);\n-\n-  /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n-     and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n-     we need to substitute, fold and simplify so we can determine\n-     the edge taken out of the last block.  */\n-  if (gimple_code (stmt) == GIMPLE_COND)\n-    {\n-      enum tree_code cond_code = gimple_cond_code (stmt);\n-\n-      /* We know the underyling format of the condition.  */\n-      arg = fold_binary (cond_code, boolean_type_node,\n-\t\t\t arg, gimple_cond_rhs (stmt));\n-    }\n-\n-  /* If this path threaded through the loop latch back into the\n-     same loop and the destination does not dominate the loop\n-     latch, then this thread would create an irreducible loop.\n-\n-     We have to know the outgoing edge to figure this out.  */\n-  return ::find_taken_edge (m_path[0], arg);\n-}\n-\n /* The current path PATH is a vector of blocks forming a jump threading\n    path in reverse order.  TAKEN_EDGE is the edge taken from path[0].\n \n@@ -962,331 +865,6 @@ back_threader_registry::register_path (const vec<basic_block> &m_path,\n   return true;\n }\n \n-/* While following a chain of SSA_NAME definitions, we jumped from a\n-   definition in LAST_BB to a definition in NEW_BB (walking\n-   backwards).\n-\n-   Verify there is a single path between the blocks and none of the\n-   blocks in the path is already in VISITED_BBS.  If so, then update\n-   VISISTED_BBS, add the new blocks to PATH and return TRUE.\n-   Otherwise return FALSE.\n-\n-   Store the length of the subpath in NEXT_PATH_LENGTH.  */\n-\n-bool\n-thread_jumps::check_subpath_and_update_thread_path (basic_block last_bb,\n-\t\t\t\t\t\t    basic_block new_bb,\n-\t\t\t\t\t\t    int *next_path_length)\n-{\n-  edge e;\n-  int e_count = 0;\n-  edge_iterator ei;\n-  auto_vec<basic_block> next_path;\n-\n-  FOR_EACH_EDGE (e, ei, last_bb->preds)\n-    {\n-      hash_set<basic_block> local_visited_bbs;\n-\n-      if (fsm_find_thread_path (new_bb, e->src, next_path,\n-\t\t\t\tlocal_visited_bbs, e->src->loop_father))\n-\t++e_count;\n-\n-      /* If there is more than one path, stop.  */\n-      if (e_count > 1)\n-\treturn false;\n-    }\n-\n-  /* Stop if we have not found a path: this could occur when the recursion\n-     is stopped by one of the bounds.  */\n-  if (e_count == 0)\n-    return false;\n-\n-  /* Make sure we haven't already visited any of the nodes in\n-     NEXT_PATH.  Don't add them here to avoid pollution.  */\n-  for (unsigned int i = 0; i + 1 < next_path.length (); i++)\n-    {\n-      if (m_visited_bbs.contains (next_path[i]))\n-\treturn false;\n-    }\n-\n-  /* Now add the nodes to VISISTED_BBS.  */\n-  for (unsigned int i = 0; i + 1 < next_path.length (); i++)\n-    m_visited_bbs.add (next_path[i]);\n-\n-  /* Append all the nodes from NEXT_PATH to PATH.  */\n-  m_path.safe_splice (next_path);\n-  *next_path_length = next_path.length ();\n-\n-  return true;\n-}\n-\n-/* If this is a profitable jump thread path, register it.\n-\n-   NAME is an SSA NAME with a possible constant value of ARG on PATH.\n-\n-   DEF_BB is the basic block that ultimately defines the constant.  */\n-\n-void\n-thread_jumps::maybe_register_path (const vec<basic_block> &m_path,\n-\t\t\t\t   tree name,\n-\t\t\t\t   edge taken_edge)\n-{\n-  bool irreducible = false;\n-  bool profitable = m_profit.profitable_path_p (m_path, name, taken_edge,\n-\t\t\t\t\t\t&irreducible);\n-  if (profitable)\n-    {\n-      if (!m_registry.register_path (m_path, taken_edge))\n-\treturn;\n-\n-      if (irreducible)\n-\tvect_free_loop_info_assumptions (m_path[0]->loop_father);\n-    }\n-}\n-\n-/* Given PHI which defines NAME in block DEF_BB, recurse through the\n-   PHI's arguments searching for paths where NAME will ultimately have\n-   a constant value.\n-\n-   PATH contains the series of blocks to traverse that will result in\n-   NAME having a constant value.  */\n-\n-void\n-thread_jumps::handle_phi (gphi *phi, basic_block def_bb)\n-{\n-  /* Iterate over the arguments of PHI.  */\n-  for (unsigned int i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      tree arg = gimple_phi_arg_def (phi, i);\n-      basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n-\n-      /* Skip edges pointing outside the current loop.  */\n-      if (!arg || def_bb->loop_father != bbi->loop_father)\n-\tcontinue;\n-\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\t{\n-\t  m_path.safe_push (bbi);\n-\t  /* Recursively follow SSA_NAMEs looking for a constant\n-\t     definition.  */\n-\t  fsm_find_control_statement_thread_paths (arg);\n-\n-\t  m_path.pop ();\n-\t  continue;\n-\t}\n-\n-      m_path.safe_push (bbi);\n-      edge taken_edge = find_taken_edge (m_path, arg);\n-      if (taken_edge)\n-\tmaybe_register_path (m_path, m_name, taken_edge);\n-      m_path.pop ();\n-    }\n-}\n-\n-/* Return TRUE if STMT is a gimple assignment we want to either directly\n-   handle or recurse through.  Return FALSE otherwise.\n-\n-   Note that adding more cases here requires adding cases to handle_assignment\n-   below.  */\n-\n-static bool\n-handle_assignment_p (gimple *stmt)\n-{\n-  if (is_gimple_assign (stmt))\n-    {\n-      enum tree_code def_code = gimple_assign_rhs_code (stmt);\n-\n-      /* If the RHS is an SSA_NAME, then we will recurse through it.\n-\t Go ahead and filter out cases where the SSA_NAME is a default\n-\t definition.  There's little to be gained by trying to handle that.  */\n-      if (def_code == SSA_NAME\n-\t  && !SSA_NAME_IS_DEFAULT_DEF (gimple_assign_rhs1 (stmt)))\n-\treturn true;\n-\n-      /* If the RHS is a constant, then it's a terminal that we'll want\n-\t to handle as well.  */\n-      if (TREE_CODE_CLASS (def_code) == tcc_constant)\n-\treturn true;\n-    }\n-\n-  /* Anything not explicitly allowed is not handled.  */\n-  return false;\n-}\n-\n-/* Given STMT which defines NAME in block DEF_BB, recurse through the\n-   PHI's arguments searching for paths where NAME will ultimately have\n-   a constant value.\n-\n-   PATH contains the series of blocks to traverse that will result in\n-   NAME having a constant value.  */\n-\n-void\n-thread_jumps::handle_assignment (gimple *stmt, basic_block def_bb)\n-{\n-  tree arg = gimple_assign_rhs1 (stmt);\n-\n-  if (TREE_CODE (arg) == SSA_NAME)\n-    fsm_find_control_statement_thread_paths (arg);\n-  else\n-    {\n-      if (CHECKING_P)\n-\t{\n-\t  gcc_assert (!m_path.is_empty ());\n-\t  basic_block top = m_path[m_path.length () - 1];\n-\t  gcc_assert (top == def_bb);\n-\t}\n-      edge taken_edge = find_taken_edge (m_path, arg);\n-      if (taken_edge)\n-\tmaybe_register_path (m_path, m_name, taken_edge);\n-    }\n-}\n-\n-/* We trace the value of the SSA_NAME NAME back through any phi nodes\n-   looking for places where it gets a constant value and save the\n-   path.  */\n-\n-void\n-thread_jumps::fsm_find_control_statement_thread_paths (tree name)\n-{\n-  /* If NAME appears in an abnormal PHI, then don't try to trace its\n-     value back through PHI nodes.  */\n-  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n-    return;\n-\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n-  basic_block def_bb = gimple_bb (def_stmt);\n-\n-  if (def_bb == NULL)\n-    return;\n-\n-  /* We allow the SSA chain to contains PHIs and simple copies and constant\n-     initializations.  */\n-  if (gimple_code (def_stmt) != GIMPLE_PHI\n-      && gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-    return;\n-\n-  if (gimple_code (def_stmt) == GIMPLE_PHI\n-      && (gimple_phi_num_args (def_stmt)\n-\t  >= (unsigned) param_fsm_maximum_phi_arguments))\n-    return;\n-\n-  if (is_gimple_assign (def_stmt)\n-      && ! handle_assignment_p (def_stmt))\n-    return;\n-\n-  /* Avoid infinite recursion.  */\n-  if (m_visited_bbs.add (def_bb))\n-    return;\n-\n-  int next_path_length = 0;\n-  basic_block last_bb_in_path = m_path.last ();\n-\n-  if (loop_containing_stmt (def_stmt)->header == gimple_bb (def_stmt))\n-    {\n-      /* Do not walk through more than one loop PHI node.  */\n-      if (m_seen_loop_phi)\n-\treturn;\n-      m_seen_loop_phi = true;\n-    }\n-\n-  /* Following the chain of SSA_NAME definitions, we jumped from a definition in\n-     LAST_BB_IN_PATH to a definition in DEF_BB.  When these basic blocks are\n-     different, append to PATH the blocks from LAST_BB_IN_PATH to DEF_BB.  */\n-  if (def_bb != last_bb_in_path)\n-    {\n-      /* When DEF_BB == LAST_BB_IN_PATH, then the first block in the path\n-\t will already be in VISITED_BBS.  When they are not equal, then we\n-\t must ensure that first block is accounted for to ensure we do not\n-\t create bogus jump threading paths.  */\n-      m_visited_bbs.add (m_path[0]);\n-      if (!check_subpath_and_update_thread_path (last_bb_in_path, def_bb,\n-\t\t\t\t\t\t &next_path_length))\n-\treturn;\n-    }\n-\n-  gcc_assert (m_path.last () == def_bb);\n-\n-  if (gimple_code (def_stmt) == GIMPLE_PHI)\n-    handle_phi (as_a <gphi *> (def_stmt), def_bb);\n-  else if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n-    handle_assignment (def_stmt, def_bb);\n-\n-  /* Remove all the nodes that we added from NEXT_PATH.  */\n-  if (next_path_length)\n-    m_path.truncate (m_path.length () - next_path_length);\n-}\n-\n-/* Search backwards from BB looking for paths where NAME (an SSA_NAME)\n-   is a constant.  Record such paths for jump threading.\n-\n-   It is assumed that BB ends with a control statement and that by\n-   finding a path where NAME is a constant, we can thread the path.\n-   SPEED_P indicates that we could increase code size to improve the\n-   code path.  */\n-\n-void\n-thread_jumps::find_jump_threads_backwards (basic_block bb)\n-{\n-  if (param_threader_mode & THREADER_MODE_RANGER)\n-    {\n-      find_jump_threads_backwards_with_ranger (bb);\n-      return;\n-    }\n-\n-  gimple *stmt = get_gimple_control_stmt (bb);\n-  if (!stmt)\n-    return;\n-\n-  enum gimple_code code = gimple_code (stmt);\n-  tree name = NULL;\n-  if (code == GIMPLE_SWITCH)\n-    name = gimple_switch_index (as_a <gswitch *> (stmt));\n-  else if (code == GIMPLE_GOTO)\n-    name = gimple_goto_dest (stmt);\n-  else if (code == GIMPLE_COND)\n-    {\n-      if (TREE_CODE (gimple_cond_lhs (stmt)) == SSA_NAME\n-\t  && TREE_CODE_CLASS (TREE_CODE (gimple_cond_rhs (stmt))) == tcc_constant\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))\n-\t      || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))\n-\tname = gimple_cond_lhs (stmt);\n-    }\n-\n-  if (!name || TREE_CODE (name) != SSA_NAME)\n-    return;\n-\n-  /* Initialize pass local data that's different for each BB.  */\n-  m_path.truncate (0);\n-  m_path.safe_push (bb);\n-  m_visited_bbs.empty ();\n-  m_seen_loop_phi = false;\n-  m_name = name;\n-\n-  fsm_find_control_statement_thread_paths (name);\n-}\n-\n-// Like find_jump_threads_backwards(), but using ranger.\n-\n-void\n-thread_jumps::find_jump_threads_backwards_with_ranger (basic_block bb)\n-{\n-  gimple *stmt = get_gimple_control_stmt (bb);\n-  if (!stmt)\n-    return;\n-\n-  enum gimple_code code = gimple_code (stmt);\n-  tree name = NULL;\n-  if (code == GIMPLE_SWITCH)\n-    name = gimple_switch_index (as_a <gswitch *> (stmt));\n-  else if (code == GIMPLE_GOTO)\n-    name = gimple_goto_dest (stmt);\n-  else if (code == GIMPLE_COND)\n-    name = gimple_cond_lhs (stmt);\n-\n-  m_name = name;\n-  m_back_threader.find_paths (bb, name);\n-}\n-\n namespace {\n \n const pass_data pass_data_thread_jumps =\n@@ -1327,12 +905,12 @@ static bool\n try_thread_blocks (function *fun)\n {\n   /* Try to thread each block with more than one successor.  */\n-  thread_jumps threader;\n+  back_threader threader (/*speed_p=*/true);\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       if (EDGE_COUNT (bb->succs) > 1)\n-\tthreader.find_jump_threads_backwards (bb);\n+\tthreader.maybe_thread_block (bb);\n     }\n   return threader.thread_through_all_blocks ();\n }\n@@ -1390,19 +968,18 @@ pass_early_thread_jumps::gate (function *fun ATTRIBUTE_UNUSED)\n   return true;\n }\n \n-\n unsigned int\n pass_early_thread_jumps::execute (function *fun)\n {\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n \n   /* Try to thread each block with more than one successor.  */\n-  thread_jumps threader (/*speed_p=*/false);\n+  back_threader threader (/*speed_p=*/false);\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       if (EDGE_COUNT (bb->succs) > 1)\n-\tthreader.find_jump_threads_backwards (bb);\n+\tthreader.maybe_thread_block (bb);\n     }\n   threader.thread_through_all_blocks ();\n "}]}