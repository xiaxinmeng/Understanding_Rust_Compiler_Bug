{"sha": "b1403b691a24fae2a96fa7ce5b93c3395e7bfd05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE0MDNiNjkxYTI0ZmFlMmE5NmZhN2NlNWI5M2MzMzk1ZTdiZmQwNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-15T04:34:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-03-15T04:34:43Z"}, "message": "compiler: eliminate bound checks in append expression\n    \n    The compiler generates two array index expressions when lowering\n    an append expression. Currently they generate bound checks.\n    Bound checks are not necessary in this case, as we know the slice\n    has, or will grow to, enough length and capacity. Eliminate them.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/166817\n\nFrom-SVN: r269699", "tree": {"sha": "9000ae815c21bbe19c77f3316301fd75964c6e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9000ae815c21bbe19c77f3316301fd75964c6e93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05/comments", "author": null, "committer": null, "parents": [{"sha": "928499cfeee9cba7cc63e4c8547f88306d8d45fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928499cfeee9cba7cc63e4c8547f88306d8d45fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928499cfeee9cba7cc63e4c8547f88306d8d45fb"}], "stats": {"total": 176, "additions": 99, "deletions": 77}, "files": [{"sha": "61bcab29e67cf46afadaa7ab59131219be2f4bf2", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=b1403b691a24fae2a96fa7ce5b93c3395e7bfd05", "patch": "@@ -1,4 +1,4 @@\n-946aa5ab2e82d045a2a3b2f18ba2c5b00e957c4b\n+80a7f6dae0861a06407a44c501b6346a4abd119c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "f41647aa4e4c9ee5216b4007539083e4d821d1d3", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 80, "deletions": 66, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=b1403b691a24fae2a96fa7ce5b93c3395e7bfd05", "patch": "@@ -8008,8 +8008,8 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n   ref = Expression::make_temporary_reference(s1tmp, loc);\n   Expression* zero = Expression::make_integer_ul(0, int_type, loc);\n   Expression* ref2 = Expression::make_temporary_reference(ntmp, loc);\n-  // FIXME: Mark this index as not requiring bounds checks.\n-  ref = Expression::make_index(ref, zero, ref2, NULL, loc);\n+  ref = Expression::make_array_index(ref, zero, ref2, NULL, loc);\n+  ref->array_index_expression()->set_needs_bounds_check(false);\n \n   if (assign_lhs == NULL)\n     {\n@@ -8058,8 +8058,8 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n       a1 = Expression::make_temporary_reference(s1tmp, loc);\n       ref = Expression::make_temporary_reference(l1tmp, loc);\n       Expression* nil = Expression::make_nil(loc);\n-      // FIXME: Mark this index as not requiring bounds checks.\n-      a1 = Expression::make_index(a1, ref, nil, NULL, loc);\n+      a1 = Expression::make_array_index(a1, ref, nil, NULL, loc);\n+      a1->array_index_expression()->set_needs_bounds_check(false);\n \n       a2 = Expression::make_temporary_reference(s2tmp, loc);\n \n@@ -8086,9 +8086,9 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n \t  ref2 = Expression::make_temporary_reference(l1tmp, loc);\n \t  Expression* off = Expression::make_integer_ul(i, int_type, loc);\n \t  ref2 = Expression::make_binary(OPERATOR_PLUS, ref2, off, loc);\n-\t  // FIXME: Mark this index as not requiring bounds checks.\n-\t  Expression* lhs = Expression::make_index(ref, ref2, NULL, NULL,\n-\t\t\t\t\t\t   loc);\n+\t  Expression* lhs = Expression::make_array_index(ref, ref2, NULL,\n+                                                         NULL, loc);\n+          lhs->array_index_expression()->set_needs_bounds_check(false);\n \t  gogo->lower_expression(function, inserter, &lhs);\n \t  gogo->flatten_expression(function, inserter, &lhs);\n \t  // The flatten pass runs after the write barrier pass, so we\n@@ -11328,47 +11328,53 @@ Array_index_expression::do_get_backend(Translate_context* context)\n   if (length == NULL)\n     length = cap_arg;\n \n-  int code = (array_type->length() != NULL\n-\t      ? (this->end_ == NULL\n-\t\t ? RUNTIME_ERROR_ARRAY_INDEX_OUT_OF_BOUNDS\n-\t\t : RUNTIME_ERROR_ARRAY_SLICE_OUT_OF_BOUNDS)\n-\t      : (this->end_ == NULL\n-\t\t ? RUNTIME_ERROR_SLICE_INDEX_OUT_OF_BOUNDS\n-\t\t : RUNTIME_ERROR_SLICE_SLICE_OUT_OF_BOUNDS));\n-  Bexpression* crash = gogo->runtime_error(code, loc)->get_backend(context);\n-\n   if (this->start_->type()->integer_type() == NULL\n       && !Type::are_convertible(int_type, this->start_->type(), NULL))\n     {\n       go_assert(saw_errors());\n       return context->backend()->error_expression();\n     }\n \n-  Bexpression* bad_index =\n-    Expression::check_bounds(this->start_, loc)->get_backend(context);\n-\n   Bexpression* start = this->start_->get_backend(context);\n   start = gogo->backend()->convert_expression(int_btype, start, loc);\n-  Bexpression* start_too_large =\n-    gogo->backend()->binary_expression((this->end_ == NULL\n-\t\t\t\t\t? OPERATOR_GE\n-\t\t\t\t\t: OPERATOR_GT),\n-                                       start,\n-\t\t\t\t       (this->end_ == NULL\n-\t\t\t\t\t? length\n-\t\t\t\t\t: capacity),\n-                                       loc);\n-  bad_index = gogo->backend()->binary_expression(OPERATOR_OROR, start_too_large,\n-\t\t\t\t\t\t bad_index, loc);\n+\n+  Bexpression* crash = NULL;\n+  Bexpression* bad_index = NULL;\n+  if (this->needs_bounds_check_)\n+    {\n+      int code = (array_type->length() != NULL\n+                  ? (this->end_ == NULL\n+                     ? RUNTIME_ERROR_ARRAY_INDEX_OUT_OF_BOUNDS\n+                     : RUNTIME_ERROR_ARRAY_SLICE_OUT_OF_BOUNDS)\n+                  : (this->end_ == NULL\n+                     ? RUNTIME_ERROR_SLICE_INDEX_OUT_OF_BOUNDS\n+                     : RUNTIME_ERROR_SLICE_SLICE_OUT_OF_BOUNDS));\n+      crash = gogo->runtime_error(code, loc)->get_backend(context);\n+      bad_index = Expression::check_bounds(this->start_, loc)->get_backend(context);\n+      Bexpression* start_too_large =\n+        gogo->backend()->binary_expression((this->end_ == NULL\n+                                            ? OPERATOR_GE\n+                                            : OPERATOR_GT),\n+                                           start,\n+                                           (this->end_ == NULL\n+                                            ? length\n+                                            : capacity),\n+                                           loc);\n+      bad_index = gogo->backend()->binary_expression(OPERATOR_OROR,\n+                                                     start_too_large,\n+                                                     bad_index, loc);\n+    }\n+\n \n   Bfunction* bfn = context->function()->func_value()->get_decl();\n   if (this->end_ == NULL)\n     {\n       // Simple array indexing.  This has to return an l-value, so\n       // wrap the index check into START.\n-      start =\n-        gogo->backend()->conditional_expression(bfn, int_btype, bad_index,\n-\t\t\t\t\t\tcrash, start, loc);\n+      if (this->needs_bounds_check_)\n+        start =\n+          gogo->backend()->conditional_expression(bfn, int_btype, bad_index,\n+                                                  crash, start, loc);\n \n       Bexpression* ret;\n       if (array_type->length() != NULL)\n@@ -11396,47 +11402,53 @@ Array_index_expression::do_get_backend(Translate_context* context)\n \n   if (this->cap_ != NULL)\n     {\n-      Bexpression* bounds_bcheck =\n-\tExpression::check_bounds(this->cap_, loc)->get_backend(context);\n-      bad_index =\n-\tgogo->backend()->binary_expression(OPERATOR_OROR, bounds_bcheck,\n-\t\t\t\t\t   bad_index, loc);\n       cap_arg = gogo->backend()->convert_expression(int_btype, cap_arg, loc);\n \n-      Bexpression* cap_too_small =\n-\tgogo->backend()->binary_expression(OPERATOR_LT, cap_arg, start, loc);\n-      Bexpression* cap_too_large =\n-\tgogo->backend()->binary_expression(OPERATOR_GT, cap_arg, capacity, loc);\n-      Bexpression* bad_cap =\n-\tgogo->backend()->binary_expression(OPERATOR_OROR, cap_too_small,\n-\t\t\t\t\t   cap_too_large, loc);\n-      bad_index = gogo->backend()->binary_expression(OPERATOR_OROR, bad_cap,\n-\t\t\t\t\t\t     bad_index, loc);\n+      if (this->needs_bounds_check_)\n+        {\n+          Bexpression* bounds_bcheck =\n+            Expression::check_bounds(this->cap_, loc)->get_backend(context);\n+          bad_index =\n+            gogo->backend()->binary_expression(OPERATOR_OROR, bounds_bcheck,\n+                                               bad_index, loc);\n+\n+          Bexpression* cap_too_small =\n+            gogo->backend()->binary_expression(OPERATOR_LT, cap_arg, start, loc);\n+          Bexpression* cap_too_large =\n+            gogo->backend()->binary_expression(OPERATOR_GT, cap_arg, capacity, loc);\n+          Bexpression* bad_cap =\n+            gogo->backend()->binary_expression(OPERATOR_OROR, cap_too_small,\n+                                               cap_too_large, loc);\n+          bad_index = gogo->backend()->binary_expression(OPERATOR_OROR, bad_cap,\n+                                                         bad_index, loc);\n+        }\n     }\n \n   Bexpression* end;\n   if (this->end_->is_nil_expression())\n     end = length;\n   else\n     {\n-      Bexpression* bounds_bcheck =\n-\tExpression::check_bounds(this->end_, loc)->get_backend(context);\n-\n-      bad_index =\n-\tgogo->backend()->binary_expression(OPERATOR_OROR, bounds_bcheck,\n-\t\t\t\t\t   bad_index, loc);\n-\n       end = this->end_->get_backend(context);\n       end = gogo->backend()->convert_expression(int_btype, end, loc);\n-      Bexpression* end_too_small =\n-\tgogo->backend()->binary_expression(OPERATOR_LT, end, start, loc);\n-      Bexpression* end_too_large =\n-\tgogo->backend()->binary_expression(OPERATOR_GT, end, cap_arg, loc);\n-      Bexpression* bad_end =\n-\tgogo->backend()->binary_expression(OPERATOR_OROR, end_too_small,\n-\t\t\t\t\t   end_too_large, loc);\n-      bad_index = gogo->backend()->binary_expression(OPERATOR_OROR, bad_end,\n-\t\t\t\t\t\t     bad_index, loc);\n+      if (this->needs_bounds_check_)\n+        {\n+          Bexpression* bounds_bcheck =\n+            Expression::check_bounds(this->end_, loc)->get_backend(context);\n+          bad_index =\n+            gogo->backend()->binary_expression(OPERATOR_OROR, bounds_bcheck,\n+                                               bad_index, loc);\n+\n+          Bexpression* end_too_small =\n+            gogo->backend()->binary_expression(OPERATOR_LT, end, start, loc);\n+          Bexpression* end_too_large =\n+            gogo->backend()->binary_expression(OPERATOR_GT, end, cap_arg, loc);\n+          Bexpression* bad_end =\n+            gogo->backend()->binary_expression(OPERATOR_OROR, end_too_small,\n+                                               end_too_large, loc);\n+          bad_index = gogo->backend()->binary_expression(OPERATOR_OROR, bad_end,\n+                                                         bad_index, loc);\n+        }\n     }\n \n   Bexpression* result_length =\n@@ -11468,10 +11480,12 @@ Array_index_expression::do_get_backend(Translate_context* context)\n   init.push_back(result_length);\n   init.push_back(result_capacity);\n \n-  Bexpression* ctor =\n+  Bexpression* ret =\n     gogo->backend()->constructor_expression(struct_btype, init, loc);\n-  return gogo->backend()->conditional_expression(bfn, struct_btype, bad_index,\n-\t\t\t\t\t\t crash, ctor, loc);\n+  if (this->needs_bounds_check_)\n+    ret = gogo->backend()->conditional_expression(bfn, struct_btype, bad_index,\n+                                                  crash, ret, loc);\n+  return ret;\n }\n \n // Dump ast representation for an array index expression."}, {"sha": "c521d9bf775cfb5a552209258dd99895f3893034", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1403b691a24fae2a96fa7ce5b93c3395e7bfd05/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=b1403b691a24fae2a96fa7ce5b93c3395e7bfd05", "patch": "@@ -2854,7 +2854,7 @@ class Array_index_expression : public Expression\n \t\t\t Expression* end, Expression* cap, Location location)\n     : Expression(EXPRESSION_ARRAY_INDEX, location),\n       array_(array), start_(start), end_(end), cap_(cap), type_(NULL),\n-      is_lvalue_(false)\n+      is_lvalue_(false), needs_bounds_check_(true)\n   { }\n \n   // Return the array.\n@@ -2898,6 +2898,10 @@ class Array_index_expression : public Expression\n   set_is_lvalue()\n   { this->is_lvalue_ = true; }\n \n+  void\n+  set_needs_bounds_check(bool b)\n+  { this->needs_bounds_check_ = b; }\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -2917,15 +2921,17 @@ class Array_index_expression : public Expression\n   Expression*\n   do_copy()\n   {\n-    return Expression::make_array_index(this->array_->copy(),\n-\t\t\t\t\tthis->start_->copy(),\n-\t\t\t\t\t(this->end_ == NULL\n-\t\t\t\t\t ? NULL\n-\t\t\t\t\t : this->end_->copy()),\n-\t\t\t\t\t(this->cap_ == NULL\n-\t\t\t\t\t ? NULL\n-\t\t\t\t\t : this->cap_->copy()),\n-\t\t\t\t\tthis->location());\n+    Expression* ret = Expression::make_array_index(this->array_->copy(),\n+                                                   this->start_->copy(),\n+                                                   (this->end_ == NULL\n+                                                    ? NULL\n+                                                    : this->end_->copy()),\n+                                                   (this->cap_ == NULL\n+                                                    ? NULL\n+                                                    : this->cap_->copy()),\n+                                                   this->location());\n+    ret->array_index_expression()->set_needs_bounds_check(this->needs_bounds_check_);\n+    return ret;\n   }\n \n   bool\n@@ -2962,6 +2968,8 @@ class Array_index_expression : public Expression\n   Type* type_;\n   // Whether expr appears in an lvalue context.\n   bool is_lvalue_;\n+  // Whether bounds check is needed.\n+  bool needs_bounds_check_;\n };\n \n // A string index.  This is used for both indexing and slicing."}]}