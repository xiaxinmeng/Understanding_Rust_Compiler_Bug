{"sha": "4df3629eb775ef9a4578c0bed3194565ca30e690", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmMzYyOWViNzc1ZWY5YTQ1NzhjMGJlZDMxOTQ1NjVjYTMwZTY5MA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-07-19T20:49:25Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-07-19T20:49:25Z"}, "message": "Add \"optinfo\" framework\n\nThis patch implements a way to consolidate dump_* calls into\noptinfo objects, as enabling work towards being able to write out\noptimization records to a file.\n\nThe patch adds the support for building optinfo instances from dump_*\ncalls, but leaves implementing any *users* of them to followup patches.\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add optinfo.o.\n\t* coretypes.h (class symtab_node): New forward decl.\n\t(struct cgraph_node): New forward decl.\n\t(class varpool_node): New forward decl.\n\t* dump-context.h: New file.\n\t* dumpfile.c: Include \"optinfo.h\", \"dump-context.h\", \"cgraph.h\",\n\t\"tree-pass.h\".\n\t(refresh_dumps_are_enabled): Use optinfo_enabled_p.\n\t(set_dump_file): Call dumpfile_ensure_any_optinfo_are_flushed.\n\t(set_alt_dump_file): Likewise.\n\t(dump_context::~dump_context): New dtor.\n\t(dump_gimple_stmt): Move implementation to...\n\t(dump_context::dump_gimple_stmt): ...this new member function.\n\tAdd the stmt to any pending optinfo, creating one if need be.\n\t(dump_gimple_stmt_loc): Move implementation to...\n\t(dump_context::dump_gimple_stmt_loc): ...this new member function.\n\tStart a new optinfo and add the stmt to it.\n\t(dump_gimple_expr): Move implementation to...\n\t(dump_context::dump_gimple_expr): ...this new member function.\n\tAdd the stmt to any pending optinfo, creating one if need be.\n\t(dump_gimple_expr_loc): Move implementation to...\n\t(dump_context::dump_gimple_expr_loc): ...this new member function.\n\tStart a new optinfo and add the stmt to it.\n\t(dump_generic_expr): Move implementation to...\n\t(dump_context::dump_generic_expr): ...this new member function.\n\tAdd the tree to any pending optinfo, creating one if need be.\n\t(dump_generic_expr_loc): Move implementation to...\n\t(dump_context::dump_generic_expr_loc): ...this new member\n\tfunction.  Add the tree to any pending optinfo, creating one if\n\tneed be.\n\t(dump_printf): Move implementation to...\n\t(dump_context::dump_printf_va): ...this new member function.  Add\n\tthe text to any pending optinfo, creating one if need be.\n\t(dump_printf_loc): Move implementation to...\n\t(dump_context::dump_printf_loc_va): ...this new member function.\n\tStart a new optinfo and add the stmt to it.\n\t(dump_dec): Move implementation to...\n\t(dump_context::dump_dec): ...this new member function.  Add the\n\tvalue to any pending optinfo, creating one if need be.\n\t(dump_context::dump_symtab_node): New member function.\n\t(dump_context::get_scope_depth): New member function.\n\t(dump_context::begin_scope): New member function.\n\t(dump_context::end_scope): New member function.\n\t(dump_context::ensure_pending_optinfo): New member function.\n\t(dump_context::begin_next_optinfo): New member function.\n\t(dump_context::end_any_optinfo): New member function.\n\t(dump_context::s_current): New global.\n\t(dump_context::s_default): New global.\n\t(dump_scope_depth): Delete global.\n\t(dumpfile_ensure_any_optinfo_are_flushed): New function.\n\t(dump_symtab_node): New function.\n\t(get_dump_scope_depth): Reimplement in terms of dump_context.\n\t(dump_begin_scope): Likewise.\n\t(dump_end_scope): Likewise.\n\t(selftest::temp_dump_context::temp_dump_context): New ctor.\n\t(selftest::temp_dump_context::~temp_dump_context): New dtor.\n\t(selftest::verify_item): New function.\n\t(ASSERT_IS_TEXT): New macro.\n\t(ASSERT_IS_TREE): New macro.\n\t(ASSERT_IS_GIMPLE): New macro.\n\t(selftest::test_capture_of_dump_calls): New test.\n\t(selftest::dumpfile_c_tests): Call it.\n\t* dumpfile.h (dump_printf, dump_printf_loc, dump_basic_block)\n\t(dump_generic_expr_loc, dump_generic_expr, dump_gimple_stmt_loc)\n\t(dump_gimple_stmt, dump_dec): Gather these related decls and add a\n\tdescriptive comment.\n\t(dump_function, print_combine_total_stats, enable_rtl_dump_file)\n\t(dump_node, dump_bb): Move these unrelated decls.\n\t(class dump_manager): Add leading comment.\n\t* optinfo.cc: New file.\n\t* optinfo.h: New file.\n\nFrom-SVN: r262891", "tree": {"sha": "6a3d9241b9f22c4142966a40b77cd934a1fc00e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a3d9241b9f22c4142966a40b77cd934a1fc00e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4df3629eb775ef9a4578c0bed3194565ca30e690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df3629eb775ef9a4578c0bed3194565ca30e690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4df3629eb775ef9a4578c0bed3194565ca30e690", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df3629eb775ef9a4578c0bed3194565ca30e690/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30c460535576882863fe4e0db740b4ac4bcfaba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c460535576882863fe4e0db740b4ac4bcfaba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c460535576882863fe4e0db740b4ac4bcfaba9"}], "stats": {"total": 1340, "additions": 1274, "deletions": 66}, "files": [{"sha": "a498df47abaa6f957fc8a59a50307e9727685558", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4df3629eb775ef9a4578c0bed3194565ca30e690", "patch": "@@ -1,3 +1,77 @@\n+2018-07-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add optinfo.o.\n+\t* coretypes.h (class symtab_node): New forward decl.\n+\t(struct cgraph_node): New forward decl.\n+\t(class varpool_node): New forward decl.\n+\t* dump-context.h: New file.\n+\t* dumpfile.c: Include \"optinfo.h\", \"dump-context.h\", \"cgraph.h\",\n+\t\"tree-pass.h\".\n+\t(refresh_dumps_are_enabled): Use optinfo_enabled_p.\n+\t(set_dump_file): Call dumpfile_ensure_any_optinfo_are_flushed.\n+\t(set_alt_dump_file): Likewise.\n+\t(dump_context::~dump_context): New dtor.\n+\t(dump_gimple_stmt): Move implementation to...\n+\t(dump_context::dump_gimple_stmt): ...this new member function.\n+\tAdd the stmt to any pending optinfo, creating one if need be.\n+\t(dump_gimple_stmt_loc): Move implementation to...\n+\t(dump_context::dump_gimple_stmt_loc): ...this new member function.\n+\tStart a new optinfo and add the stmt to it.\n+\t(dump_gimple_expr): Move implementation to...\n+\t(dump_context::dump_gimple_expr): ...this new member function.\n+\tAdd the stmt to any pending optinfo, creating one if need be.\n+\t(dump_gimple_expr_loc): Move implementation to...\n+\t(dump_context::dump_gimple_expr_loc): ...this new member function.\n+\tStart a new optinfo and add the stmt to it.\n+\t(dump_generic_expr): Move implementation to...\n+\t(dump_context::dump_generic_expr): ...this new member function.\n+\tAdd the tree to any pending optinfo, creating one if need be.\n+\t(dump_generic_expr_loc): Move implementation to...\n+\t(dump_context::dump_generic_expr_loc): ...this new member\n+\tfunction.  Add the tree to any pending optinfo, creating one if\n+\tneed be.\n+\t(dump_printf): Move implementation to...\n+\t(dump_context::dump_printf_va): ...this new member function.  Add\n+\tthe text to any pending optinfo, creating one if need be.\n+\t(dump_printf_loc): Move implementation to...\n+\t(dump_context::dump_printf_loc_va): ...this new member function.\n+\tStart a new optinfo and add the stmt to it.\n+\t(dump_dec): Move implementation to...\n+\t(dump_context::dump_dec): ...this new member function.  Add the\n+\tvalue to any pending optinfo, creating one if need be.\n+\t(dump_context::dump_symtab_node): New member function.\n+\t(dump_context::get_scope_depth): New member function.\n+\t(dump_context::begin_scope): New member function.\n+\t(dump_context::end_scope): New member function.\n+\t(dump_context::ensure_pending_optinfo): New member function.\n+\t(dump_context::begin_next_optinfo): New member function.\n+\t(dump_context::end_any_optinfo): New member function.\n+\t(dump_context::s_current): New global.\n+\t(dump_context::s_default): New global.\n+\t(dump_scope_depth): Delete global.\n+\t(dumpfile_ensure_any_optinfo_are_flushed): New function.\n+\t(dump_symtab_node): New function.\n+\t(get_dump_scope_depth): Reimplement in terms of dump_context.\n+\t(dump_begin_scope): Likewise.\n+\t(dump_end_scope): Likewise.\n+\t(selftest::temp_dump_context::temp_dump_context): New ctor.\n+\t(selftest::temp_dump_context::~temp_dump_context): New dtor.\n+\t(selftest::verify_item): New function.\n+\t(ASSERT_IS_TEXT): New macro.\n+\t(ASSERT_IS_TREE): New macro.\n+\t(ASSERT_IS_GIMPLE): New macro.\n+\t(selftest::test_capture_of_dump_calls): New test.\n+\t(selftest::dumpfile_c_tests): Call it.\n+\t* dumpfile.h (dump_printf, dump_printf_loc, dump_basic_block)\n+\t(dump_generic_expr_loc, dump_generic_expr, dump_gimple_stmt_loc)\n+\t(dump_gimple_stmt, dump_dec): Gather these related decls and add a\n+\tdescriptive comment.\n+\t(dump_function, print_combine_total_stats, enable_rtl_dump_file)\n+\t(dump_node, dump_bb): Move these unrelated decls.\n+\t(class dump_manager): Add leading comment.\n+\t* optinfo.cc: New file.\n+\t* optinfo.h: New file.\n+\n 2018-07-19  Michael Collison  <michael.collison@arm.com>\n \t    Richard Henderson <rth@redhat.com>\n "}, {"sha": "dd1dfc1e87cfd6c7394430aa24fbdf40f2bb26c5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4df3629eb775ef9a4578c0bed3194565ca30e690", "patch": "@@ -1427,6 +1427,7 @@ OBJS = \\\n \toptabs-libfuncs.o \\\n \toptabs-query.o \\\n \toptabs-tree.o \\\n+\toptinfo.o \\\n \toptions-save.o \\\n \topts-global.o \\\n \tpasses.o \\"}, {"sha": "917fdc9aba1dadf072e4646cbc793850d239b1c4", "filename": "gcc/coretypes.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=4df3629eb775ef9a4578c0bed3194565ca30e690", "patch": "@@ -134,6 +134,13 @@ struct gomp_single;\n struct gomp_target;\n struct gomp_teams;\n \n+/* Subclasses of symtab_node, using indentation to show the class\n+   hierarchy.  */\n+\n+class symtab_node;\n+  struct cgraph_node;\n+  class varpool_node;\n+\n union section;\n typedef union section section;\n struct gcc_options;"}, {"sha": "a191e3a7133ab11735478984f8fc7ee5744da943", "filename": "gcc/dump-context.h", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Fdump-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Fdump-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdump-context.h?ref=4df3629eb775ef9a4578c0bed3194565ca30e690", "patch": "@@ -0,0 +1,138 @@\n+/* Support code for handling the various dump_* calls in dumpfile.h\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef GCC_DUMP_CONTEXT_H\n+#define GCC_DUMP_CONTEXT_H 1\n+\n+/* A class for handling the various dump_* calls.\n+\n+   In particular, this class has responsibility for consolidating\n+   the \"dump_*\" calls into optinfo instances (delimited by \"dump_*_loc\"\n+   calls), and emitting them.\n+\n+   Putting this in a class (rather than as global state) allows\n+   for selftesting of this code.  */\n+\n+class dump_context\n+{\n+  friend class temp_dump_context;\n+ public:\n+  static dump_context &get () { return *s_current; }\n+\n+  ~dump_context ();\n+\n+  void dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n+\t\t\t gimple *gs, int spc);\n+\n+  void dump_gimple_stmt_loc (dump_flags_t dump_kind,\n+\t\t\t     const dump_location_t &loc,\n+\t\t\t     dump_flags_t extra_dump_flags,\n+\t\t\t     gimple *gs, int spc);\n+\n+  void dump_gimple_expr (dump_flags_t dump_kind,\n+\t\t\t dump_flags_t extra_dump_flags,\n+\t\t\t gimple *gs, int spc);\n+\n+  void dump_gimple_expr_loc (dump_flags_t dump_kind,\n+\t\t\t    const dump_location_t &loc,\n+\t\t\t    dump_flags_t extra_dump_flags,\n+\t\t\t    gimple *gs,\n+\t\t\t    int spc);\n+\n+  void dump_generic_expr (dump_flags_t dump_kind,\n+\t\t\t  dump_flags_t extra_dump_flags,\n+\t\t\t  tree t);\n+\n+  void dump_generic_expr_loc (dump_flags_t dump_kind,\n+\t\t\t      const dump_location_t &loc,\n+\t\t\t      dump_flags_t extra_dump_flags,\n+\t\t\t      tree t);\n+\n+  void dump_printf_va (dump_flags_t dump_kind, const char *format,\n+\t\t       va_list ap) ATTRIBUTE_PRINTF (3, 0);\n+\n+  void dump_printf_loc_va (dump_flags_t dump_kind, const dump_location_t &loc,\n+\t\t\t   const char *format, va_list ap)\n+    ATTRIBUTE_PRINTF (4, 0);\n+\n+  template<unsigned int N, typename C>\n+  void dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value);\n+\n+  void dump_symtab_node (dump_flags_t dump_kind, symtab_node *node);\n+\n+  /* Managing nested scopes.  */\n+  unsigned int get_scope_depth () const;\n+  void begin_scope (const char *name, const dump_location_t &loc);\n+  void end_scope ();\n+\n+  /* For use in selftests; if true then optinfo_enabled_p is true.  */\n+  bool forcibly_enable_optinfo_p () const\n+  {\n+    return m_forcibly_enable_optinfo;\n+  }\n+\n+  void end_any_optinfo ();\n+\n+ private:\n+  optinfo &ensure_pending_optinfo ();\n+  optinfo &begin_next_optinfo (const dump_location_t &loc);\n+\n+  /* For use in selftests; if true then optinfo_enabled_p is true.  */\n+  bool m_forcibly_enable_optinfo;\n+\n+  /* The current nesting depth of dump scopes, for showing nesting\n+     via indentation).  */\n+  unsigned int m_scope_depth;\n+\n+  /* The optinfo currently being accumulated since the last dump_*_loc call,\n+     if any.  */\n+  optinfo *m_pending;\n+\n+  /* The currently active dump_context, for use by the dump_* API calls.  */\n+  static dump_context *s_current;\n+\n+  /* The default active context.  */\n+  static dump_context s_default;\n+};\n+\n+#if CHECKING_P\n+\n+/* An RAII-style class for use in selftests for temporarily using a different\n+   dump_context.  */\n+\n+class temp_dump_context\n+{\n+ public:\n+  temp_dump_context (bool forcibly_enable_optinfo);\n+  ~temp_dump_context ();\n+\n+  /* Support for selftests.  */\n+  optinfo *get_pending_optinfo () const { return m_context.m_pending; }\n+\n+ private:\n+  dump_context m_context;\n+  dump_context *m_saved;\n+  bool m_saved_flag_remarks;\n+};\n+\n+#endif /* CHECKING_P */\n+\n+#endif /* GCC_DUMP_CONTEXT_H */"}, {"sha": "74b585594df9cb84c236447fae9e10db954bba6c", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 556, "deletions": 41, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=4df3629eb775ef9a4578c0bed3194565ca30e690", "patch": "@@ -33,6 +33,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\" /* for dump_user_location_t ctor.  */\n #include \"rtl.h\" /* for dump_user_location_t ctor.  */\n #include \"selftest.h\"\n+#include \"optinfo.h\"\n+#include \"dump-context.h\"\n+#include \"cgraph.h\"\n+#include \"tree-pass.h\" /* for \"current_pass\".  */\n \n /* If non-NULL, return one past-the-end of the matching SUBPART of\n    the WHOLE string.  */\n@@ -64,7 +68,7 @@ bool dumps_are_enabled = false;\n static void\n refresh_dumps_are_enabled ()\n {\n-  dumps_are_enabled = (dump_file || alt_dump_file);\n+  dumps_are_enabled = (dump_file || alt_dump_file || optinfo_enabled_p ());\n }\n \n /* Set global \"dump_file\" to NEW_DUMP_FILE, refreshing the \"dumps_are_enabled\"\n@@ -73,6 +77,7 @@ refresh_dumps_are_enabled ()\n void\n set_dump_file (FILE *new_dump_file)\n {\n+  dumpfile_ensure_any_optinfo_are_flushed ();\n   dump_file = new_dump_file;\n   refresh_dumps_are_enabled ();\n }\n@@ -83,6 +88,7 @@ set_dump_file (FILE *new_dump_file)\n static void\n set_alt_dump_file (FILE *new_alt_dump_file)\n {\n+  dumpfile_ensure_any_optinfo_are_flushed ();\n   alt_dump_file = new_alt_dump_file;\n   refresh_dumps_are_enabled ();\n }\n@@ -465,25 +471,44 @@ dump_loc (dump_flags_t dump_kind, FILE *dfile, source_location loc)\n     }\n }\n \n+/* Implementation of dump_context member functions.  */\n+\n+/* dump_context's dtor.  */\n+\n+dump_context::~dump_context ()\n+{\n+  delete m_pending;\n+}\n+\n /* Dump gimple statement GS with SPC indentation spaces and\n    EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.  */\n \n void\n-dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n-\t\t  gimple *gs, int spc)\n+dump_context::dump_gimple_stmt (dump_flags_t dump_kind,\n+\t\t\t\tdump_flags_t extra_dump_flags,\n+\t\t\t\tgimple *gs, int spc)\n {\n   if (dump_file && (dump_kind & pflags))\n     print_gimple_stmt (dump_file, gs, spc, dump_flags | extra_dump_flags);\n \n   if (alt_dump_file && (dump_kind & alt_flags))\n     print_gimple_stmt (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = ensure_pending_optinfo ();\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_gimple_stmt (gs, spc, dump_flags | extra_dump_flags);\n+    }\n }\n \n /* Similar to dump_gimple_stmt, except additionally print source location.  */\n \n void\n-dump_gimple_stmt_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n-\t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n+dump_context::dump_gimple_stmt_loc (dump_flags_t dump_kind,\n+\t\t\t\t    const dump_location_t &loc,\n+\t\t\t\t    dump_flags_t extra_dump_flags,\n+\t\t\t\t    gimple *gs, int spc)\n {\n   location_t srcloc = loc.get_location_t ();\n   if (dump_file && (dump_kind & pflags))\n@@ -497,28 +522,46 @@ dump_gimple_stmt_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n       dump_loc (dump_kind, alt_dump_file, srcloc);\n       print_gimple_stmt (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n     }\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = begin_next_optinfo (loc);\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_gimple_stmt (gs, spc, dump_flags | extra_dump_flags);\n+    }\n }\n \n /* Dump gimple statement GS with SPC indentation spaces and\n    EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.\n    Do not terminate with a newline or semicolon.  */\n \n void\n-dump_gimple_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n-\t\t  gimple *gs, int spc)\n+dump_context::dump_gimple_expr (dump_flags_t dump_kind,\n+\t\t\t\tdump_flags_t extra_dump_flags,\n+\t\t\t\tgimple *gs, int spc)\n {\n   if (dump_file && (dump_kind & pflags))\n     print_gimple_expr (dump_file, gs, spc, dump_flags | extra_dump_flags);\n \n   if (alt_dump_file && (dump_kind & alt_flags))\n     print_gimple_expr (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = ensure_pending_optinfo ();\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_gimple_expr (gs, spc, dump_flags | extra_dump_flags);\n+    }\n }\n \n /* Similar to dump_gimple_expr, except additionally print source location.  */\n \n void\n-dump_gimple_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n-\t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n+dump_context::dump_gimple_expr_loc (dump_flags_t dump_kind,\n+\t\t\t\t    const dump_location_t &loc,\n+\t\t\t\t    dump_flags_t extra_dump_flags,\n+\t\t\t\t    gimple *gs,\n+\t\t\t\t    int spc)\n {\n   location_t srcloc = loc.get_location_t ();\n   if (dump_file && (dump_kind & pflags))\n@@ -532,30 +575,47 @@ dump_gimple_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n       dump_loc (dump_kind, alt_dump_file, srcloc);\n       print_gimple_expr (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n     }\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = begin_next_optinfo (loc);\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_gimple_expr (gs, spc, dump_flags | extra_dump_flags);\n+    }\n }\n \n \n /* Dump expression tree T using EXTRA_DUMP_FLAGS on dump streams if\n    DUMP_KIND is enabled.  */\n \n void\n-dump_generic_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n-\t\t   tree t)\n+dump_context::dump_generic_expr (dump_flags_t dump_kind,\n+\t\t\t\t dump_flags_t extra_dump_flags,\n+\t\t\t\t tree t)\n {\n   if (dump_file && (dump_kind & pflags))\n       print_generic_expr (dump_file, t, dump_flags | extra_dump_flags);\n \n   if (alt_dump_file && (dump_kind & alt_flags))\n       print_generic_expr (alt_dump_file, t, dump_flags | extra_dump_flags);\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = ensure_pending_optinfo ();\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_tree (t, dump_flags | extra_dump_flags);\n+    }\n }\n \n \n /* Similar to dump_generic_expr, except additionally print the source\n    location.  */\n \n void\n-dump_generic_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n-\t\t       dump_flags_t extra_dump_flags, tree t)\n+dump_context::dump_generic_expr_loc (dump_flags_t dump_kind,\n+\t\t\t\t     const dump_location_t &loc,\n+\t\t\t\t     dump_flags_t extra_dump_flags,\n+\t\t\t\t     tree t)\n {\n   location_t srcloc = loc.get_location_t ();\n   if (dump_file && (dump_kind & pflags))\n@@ -569,61 +629,91 @@ dump_generic_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n       dump_loc (dump_kind, alt_dump_file, srcloc);\n       print_generic_expr (alt_dump_file, t, dump_flags | extra_dump_flags);\n     }\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = begin_next_optinfo (loc);\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_tree (t, dump_flags | extra_dump_flags);\n+    }\n }\n \n /* Output a formatted message using FORMAT on appropriate dump streams.  */\n \n void\n-dump_printf (dump_flags_t dump_kind, const char *format, ...)\n+dump_context::dump_printf_va (dump_flags_t dump_kind, const char *format,\n+\t\t\t      va_list ap)\n {\n   if (dump_file && (dump_kind & pflags))\n     {\n-      va_list ap;\n-      va_start (ap, format);\n-      vfprintf (dump_file, format, ap);\n-      va_end (ap);\n+      va_list aq;\n+      va_copy (aq, ap);\n+      vfprintf (dump_file, format, aq);\n+      va_end (aq);\n     }\n \n   if (alt_dump_file && (dump_kind & alt_flags))\n     {\n-      va_list ap;\n-      va_start (ap, format);\n-      vfprintf (alt_dump_file, format, ap);\n-      va_end (ap);\n+      va_list aq;\n+      va_copy (aq, ap);\n+      vfprintf (alt_dump_file, format, aq);\n+      va_end (aq);\n+    }\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = ensure_pending_optinfo ();\n+      va_list aq;\n+      va_copy (aq, ap);\n+      info.add_printf_va (format, aq);\n+      va_end (aq);\n     }\n }\n \n-/* Similar to dump_printf, except source location is also printed.  */\n+/* Similar to dump_printf, except source location is also printed, and\n+   dump location captured.  */\n \n void\n-dump_printf_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n-\t\t const char *format, ...)\n+dump_context::dump_printf_loc_va (dump_flags_t dump_kind,\n+\t\t\t\t  const dump_location_t &loc,\n+\t\t\t\t  const char *format, va_list ap)\n {\n   location_t srcloc = loc.get_location_t ();\n+\n   if (dump_file && (dump_kind & pflags))\n     {\n-      va_list ap;\n       dump_loc (dump_kind, dump_file, srcloc);\n-      va_start (ap, format);\n-      vfprintf (dump_file, format, ap);\n-      va_end (ap);\n+      va_list aq;\n+      va_copy (aq, ap);\n+      vfprintf (dump_file, format, aq);\n+      va_end (aq);\n     }\n \n   if (alt_dump_file && (dump_kind & alt_flags))\n     {\n-      va_list ap;\n       dump_loc (dump_kind, alt_dump_file, srcloc);\n-      va_start (ap, format);\n-      vfprintf (alt_dump_file, format, ap);\n-      va_end (ap);\n+      va_list aq;\n+      va_copy (aq, ap);\n+      vfprintf (alt_dump_file, format, aq);\n+      va_end (aq);\n+    }\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = begin_next_optinfo (loc);\n+      info.handle_dump_file_kind (dump_kind);\n+      va_list aq;\n+      va_copy (aq, ap);\n+      info.add_printf_va (format, aq);\n+      va_end (aq);\n     }\n }\n \n /* Output VALUE in decimal to appropriate dump streams.  */\n \n template<unsigned int N, typename C>\n void\n-dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n+dump_context::dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n {\n   STATIC_ASSERT (poly_coeff_traits<C>::signedness >= 0);\n   signop sgn = poly_coeff_traits<C>::signedness ? SIGNED : UNSIGNED;\n@@ -632,6 +722,224 @@ dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n \n   if (alt_dump_file && (dump_kind & alt_flags))\n     print_dec (value, alt_dump_file, sgn);\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = ensure_pending_optinfo ();\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_poly_int<N,C> (value);\n+    }\n+}\n+\n+/* Output the name of NODE on appropriate dump streams.  */\n+\n+void\n+dump_context::dump_symtab_node (dump_flags_t dump_kind, symtab_node *node)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    fprintf (dump_file, \"%s\", node->dump_name ());\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    fprintf (alt_dump_file, \"%s\", node->dump_name ());\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      optinfo &info = ensure_pending_optinfo ();\n+      info.handle_dump_file_kind (dump_kind);\n+      info.add_symtab_node (node);\n+    }\n+}\n+\n+/* Get the current dump scope-nesting depth.\n+   For use by -fopt-info (for showing nesting via indentation).  */\n+\n+unsigned int\n+dump_context::get_scope_depth () const\n+{\n+  return m_scope_depth;\n+}\n+\n+/* Push a nested dump scope.\n+   Print \"=== NAME ===\\n\" to the dumpfile, if any, and to the -fopt-info\n+   destination, if any.\n+   Emit a \"scope\" optinfo if optinfos are enabled.\n+   Increment the scope depth.  */\n+\n+void\n+dump_context::begin_scope (const char *name, const dump_location_t &loc)\n+{\n+  /* Specialcase, to avoid going through dump_printf_loc,\n+     so that we can create a optinfo of kind OPTINFO_KIND_SCOPE.  */\n+\n+  if (dump_file)\n+    {\n+      dump_loc (MSG_NOTE, dump_file, loc.get_location_t ());\n+      fprintf (dump_file, \"=== %s ===\\n\", name);\n+    }\n+\n+  if (alt_dump_file)\n+    {\n+      dump_loc (MSG_NOTE, alt_dump_file, loc.get_location_t ());\n+      fprintf (alt_dump_file, \"=== %s ===\\n\", name);\n+    }\n+\n+  if (optinfo_enabled_p ())\n+    {\n+      end_any_optinfo ();\n+      optinfo info (loc, OPTINFO_KIND_SCOPE, current_pass);\n+      info.add_printf (\"=== %s ===\", name);\n+      info.emit ();\n+    }\n+\n+  m_scope_depth++;\n+}\n+\n+/* Pop a nested dump scope.  */\n+\n+void\n+dump_context::end_scope ()\n+{\n+  end_any_optinfo ();\n+  m_scope_depth--;\n+}\n+\n+/* Return the optinfo currently being accumulated, creating one if\n+   necessary.  */\n+\n+optinfo &\n+dump_context::ensure_pending_optinfo ()\n+{\n+  if (!m_pending)\n+    return begin_next_optinfo (dump_location_t (dump_user_location_t ()));\n+  return *m_pending;\n+}\n+\n+/* Start a new optinfo and return it, ending any optinfo that was already\n+   accumulated.  */\n+\n+optinfo &\n+dump_context::begin_next_optinfo (const dump_location_t &loc)\n+{\n+  end_any_optinfo ();\n+  gcc_assert (m_pending == NULL);\n+  m_pending = new optinfo (loc, OPTINFO_KIND_NOTE, current_pass);\n+  return *m_pending;\n+}\n+\n+/* End any optinfo that has been accumulated within this context; emitting\n+   it to any destinations as appropriate - though none have currently been\n+   implemented.  */\n+\n+void\n+dump_context::end_any_optinfo ()\n+{\n+  if (m_pending)\n+    m_pending->emit ();\n+  delete m_pending;\n+  m_pending = NULL;\n+}\n+\n+/* The current singleton dump_context, and its default.  */\n+\n+dump_context *dump_context::s_current = &dump_context::s_default;\n+dump_context dump_context::s_default;\n+\n+/* Implementation of dump_* API calls, calling into dump_context\n+   member functions.  */\n+\n+/* Dump gimple statement GS with SPC indentation spaces and\n+   EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.  */\n+\n+void\n+dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n+\t\t  gimple *gs, int spc)\n+{\n+  dump_context::get ().dump_gimple_stmt (dump_kind, extra_dump_flags, gs, spc);\n+}\n+\n+/* Similar to dump_gimple_stmt, except additionally print source location.  */\n+\n+void\n+dump_gimple_stmt_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n+\t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n+{\n+  dump_context::get ().dump_gimple_stmt_loc (dump_kind, loc, extra_dump_flags,\n+\t\t\t\t\t     gs, spc);\n+}\n+\n+/* Dump gimple statement GS with SPC indentation spaces and\n+   EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.\n+   Do not terminate with a newline or semicolon.  */\n+\n+void\n+dump_gimple_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n+\t\t  gimple *gs, int spc)\n+{\n+  dump_context::get ().dump_gimple_expr (dump_kind, extra_dump_flags, gs, spc);\n+}\n+\n+/* Similar to dump_gimple_expr, except additionally print source location.  */\n+\n+void\n+dump_gimple_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n+\t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n+{\n+  dump_context::get ().dump_gimple_expr_loc (dump_kind, loc, extra_dump_flags,\n+\t\t\t\t\t     gs, spc);\n+}\n+\n+/* Dump expression tree T using EXTRA_DUMP_FLAGS on dump streams if\n+   DUMP_KIND is enabled.  */\n+\n+void\n+dump_generic_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n+\t\t   tree t)\n+{\n+  dump_context::get ().dump_generic_expr (dump_kind, extra_dump_flags, t);\n+}\n+\n+/* Similar to dump_generic_expr, except additionally print the source\n+   location.  */\n+\n+void\n+dump_generic_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n+\t\t       dump_flags_t extra_dump_flags, tree t)\n+{\n+  dump_context::get ().dump_generic_expr_loc (dump_kind, loc, extra_dump_flags,\n+\t\t\t\t\t      t);\n+}\n+\n+/* Output a formatted message using FORMAT on appropriate dump streams.  */\n+\n+void\n+dump_printf (dump_flags_t dump_kind, const char *format, ...)\n+{\n+  va_list ap;\n+  va_start (ap, format);\n+  dump_context::get ().dump_printf_va (dump_kind, format, ap);\n+  va_end (ap);\n+}\n+\n+/* Similar to dump_printf, except source location is also printed, and\n+   dump location captured.  */\n+\n+void\n+dump_printf_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n+\t\t const char *format, ...)\n+{\n+  va_list ap;\n+  va_start (ap, format);\n+  dump_context::get ().dump_printf_loc_va (dump_kind, loc, format, ap);\n+  va_end (ap);\n+}\n+\n+/* Output VALUE in decimal to appropriate dump streams.  */\n+\n+template<unsigned int N, typename C>\n+void\n+dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n+{\n+  dump_context::get ().dump_dec (dump_kind, value);\n }\n \n template void dump_dec (dump_flags_t, const poly_uint16 &);\n@@ -662,37 +970,50 @@ dump_hex (dump_flags_t dump_kind, const poly_wide_int &value)\n     print_hex (value, alt_dump_file);\n }\n \n-/* The current dump scope-nesting depth.  */\n+/* Emit and delete the currently pending optinfo, if there is one,\n+   without the caller needing to know about class dump_context.  */\n+\n+void\n+dumpfile_ensure_any_optinfo_are_flushed ()\n+{\n+  dump_context::get().end_any_optinfo ();\n+}\n+\n+/* Output the name of NODE on appropriate dump streams.  */\n \n-static int dump_scope_depth;\n+void\n+dump_symtab_node (dump_flags_t dump_kind, symtab_node *node)\n+{\n+  dump_context::get ().dump_symtab_node (dump_kind, node);\n+}\n \n /* Get the current dump scope-nesting depth.\n-   For use by dump_*_loc (for showing nesting via indentation).  */\n+   For use by -fopt-info (for showing nesting via indentation).  */\n \n unsigned int\n get_dump_scope_depth ()\n {\n-  return dump_scope_depth;\n+  return dump_context::get ().get_scope_depth ();\n }\n \n /* Push a nested dump scope.\n    Print \"=== NAME ===\\n\" to the dumpfile, if any, and to the -fopt-info\n    destination, if any.\n+   Emit a \"scope\" opinfo if optinfos are enabled.\n    Increment the scope depth.  */\n \n void\n dump_begin_scope (const char *name, const dump_location_t &loc)\n {\n-  dump_printf_loc (MSG_NOTE, loc, \"=== %s ===\\n\", name);\n-  dump_scope_depth++;\n+  dump_context::get ().begin_scope (name, loc);\n }\n \n /* Pop a nested dump scope.  */\n \n void\n dump_end_scope ()\n {\n-  dump_scope_depth--;\n+  dump_context::get ().end_scope ();\n }\n \n /* Start a dump for PHASE. Store user-supplied dump flags in\n@@ -1249,6 +1570,24 @@ enable_rtl_dump_file (void)\n \n #if CHECKING_P\n \n+/* temp_dump_context's ctor.  Temporarily override the dump_context\n+   (to forcibly enable optinfo-generation).  */\n+\n+temp_dump_context::temp_dump_context (bool forcibly_enable_optinfo)\n+: m_context (),\n+  m_saved (&dump_context ().get ())\n+{\n+  dump_context::s_current = &m_context;\n+  m_context.m_forcibly_enable_optinfo = forcibly_enable_optinfo;\n+}\n+\n+/* temp_dump_context's dtor.  Restore the saved dump_context.  */\n+\n+temp_dump_context::~temp_dump_context ()\n+{\n+  dump_context::s_current = m_saved;\n+}\n+\n namespace selftest {\n \n /* Verify that the dump_location_t constructors capture the source location\n@@ -1285,12 +1624,188 @@ test_impl_location ()\n #endif\n }\n \n+/* Verify that ITEM has the expected values.  */\n+\n+static void\n+verify_item (const location &loc,\n+\t     const optinfo_item *item,\n+\t     enum optinfo_item_kind expected_kind,\n+\t     location_t expected_location,\n+\t     const char *expected_text)\n+{\n+  ASSERT_EQ_AT (loc, item->get_kind (), expected_kind);\n+  ASSERT_EQ_AT (loc, item->get_location (), expected_location);\n+  ASSERT_STREQ_AT (loc, item->get_text (), expected_text);\n+}\n+\n+/* Verify that ITEM is a text item, with EXPECTED_TEXT.  */\n+\n+#define ASSERT_IS_TEXT(ITEM, EXPECTED_TEXT) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n+    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_TEXT, \\\n+\t\t UNKNOWN_LOCATION, (EXPECTED_TEXT));\t\t    \\\n+  SELFTEST_END_STMT\n+\n+/* Verify that ITEM is a tree item, with the expected values.  */\n+\n+#define ASSERT_IS_TREE(ITEM, EXPECTED_LOCATION, EXPECTED_TEXT) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n+    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_TREE, \\\n+\t\t (EXPECTED_LOCATION), (EXPECTED_TEXT));\t    \\\n+  SELFTEST_END_STMT\n+\n+/* Verify that ITEM is a gimple item, with the expected values.  */\n+\n+#define ASSERT_IS_GIMPLE(ITEM, EXPECTED_LOCATION, EXPECTED_TEXT) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n+    verify_item (SELFTEST_LOCATION, (ITEM), OPTINFO_ITEM_KIND_GIMPLE, \\\n+\t\t (EXPECTED_LOCATION), (EXPECTED_TEXT));\t    \\\n+  SELFTEST_END_STMT\n+\n+/* Verify that calls to the dump_* API are captured and consolidated into\n+   optimization records. */\n+\n+static void\n+test_capture_of_dump_calls (const line_table_case &case_)\n+{\n+  /* Generate a location_t for testing.  */\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, \"test.txt\", 0);\n+  linemap_line_start (line_table, 5, 100);\n+  linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n+  location_t where = linemap_position_for_column (line_table, 10);\n+\n+  dump_location_t loc = dump_location_t::from_location_t (where);\n+\n+  /* Test of dump_printf.  */\n+  {\n+    temp_dump_context tmp (true);\n+    dump_printf (MSG_NOTE, \"int: %i str: %s\", 42, \"foo\");\n+\n+    optinfo *info = tmp.get_pending_optinfo ();\n+    ASSERT_TRUE (info != NULL);\n+    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+    ASSERT_EQ (info->num_items (), 1);\n+    ASSERT_IS_TEXT (info->get_item (0), \"int: 42 str: foo\");\n+  }\n+\n+  /* Tree, via dump_generic_expr.  */\n+  {\n+    temp_dump_context tmp (true);\n+    dump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n+    dump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);\n+\n+    optinfo *info = tmp.get_pending_optinfo ();\n+    ASSERT_TRUE (info != NULL);\n+    ASSERT_EQ (info->get_location_t (), where);\n+    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+    ASSERT_EQ (info->num_items (), 2);\n+    ASSERT_IS_TEXT (info->get_item (0), \"test of tree: \");\n+    ASSERT_IS_TREE (info->get_item (1), UNKNOWN_LOCATION, \"0\");\n+  }\n+\n+  /* Tree, via dump_generic_expr_loc.  */\n+  {\n+    temp_dump_context tmp (true);\n+    dump_generic_expr_loc (MSG_NOTE, loc, TDF_SLIM, integer_one_node);\n+\n+    optinfo *info = tmp.get_pending_optinfo ();\n+    ASSERT_TRUE (info != NULL);\n+    ASSERT_EQ (info->get_location_t (), where);\n+    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+    ASSERT_EQ (info->num_items (), 1);\n+    ASSERT_IS_TREE (info->get_item (0), UNKNOWN_LOCATION, \"1\");\n+  }\n+\n+  /* Gimple.  */\n+  {\n+    greturn *stmt = gimple_build_return (NULL);\n+    gimple_set_location (stmt, where);\n+\n+    /* dump_gimple_stmt_loc.  */\n+    {\n+      temp_dump_context tmp (true);\n+      dump_gimple_stmt_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n+\n+      optinfo *info = tmp.get_pending_optinfo ();\n+      ASSERT_TRUE (info != NULL);\n+      ASSERT_EQ (info->num_items (), 1);\n+      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\\n\");\n+    }\n+\n+    /* dump_gimple_stmt.  */\n+    {\n+      temp_dump_context tmp (true);\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 2);\n+\n+      optinfo *info = tmp.get_pending_optinfo ();\n+      ASSERT_TRUE (info != NULL);\n+      ASSERT_EQ (info->num_items (), 1);\n+      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\\n\");\n+    }\n+\n+    /* dump_gimple_expr_loc.  */\n+    {\n+      temp_dump_context tmp (true);\n+      dump_gimple_expr_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n+\n+      optinfo *info = tmp.get_pending_optinfo ();\n+      ASSERT_TRUE (info != NULL);\n+      ASSERT_EQ (info->num_items (), 1);\n+      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\");\n+    }\n+\n+    /* dump_gimple_expr.  */\n+    {\n+      temp_dump_context tmp (true);\n+      dump_gimple_expr (MSG_NOTE, TDF_SLIM, stmt, 2);\n+\n+      optinfo *info = tmp.get_pending_optinfo ();\n+      ASSERT_TRUE (info != NULL);\n+      ASSERT_EQ (info->num_items (), 1);\n+      ASSERT_IS_GIMPLE (info->get_item (0), where, \"return;\");\n+    }\n+  }\n+\n+  /* poly_int.  */\n+  {\n+    temp_dump_context tmp (true);\n+    dump_dec (MSG_NOTE, poly_int64 (42));\n+\n+    optinfo *info = tmp.get_pending_optinfo ();\n+    ASSERT_TRUE (info != NULL);\n+    ASSERT_EQ (info->num_items (), 1);\n+    ASSERT_IS_TEXT (info->get_item (0), \"42\");\n+  }\n+\n+  /* Verify that MSG_* affects optinfo->get_kind (); we tested MSG_NOTE\n+     above.  */\n+  {\n+    /* MSG_OPTIMIZED_LOCATIONS.  */\n+    {\n+      temp_dump_context tmp (true);\n+      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc, \"test\");\n+      ASSERT_EQ (tmp.get_pending_optinfo ()->get_kind (),\n+\t\t OPTINFO_KIND_SUCCESS);\n+    }\n+\n+    /* MSG_MISSED_OPTIMIZATION.  */\n+    {\n+      temp_dump_context tmp (true);\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc, \"test\");\n+      ASSERT_EQ (tmp.get_pending_optinfo ()->get_kind (),\n+\t\t OPTINFO_KIND_FAILURE);\n+    }\n+  }\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n dumpfile_c_tests ()\n {\n   test_impl_location ();\n+  for_each_line_table_case (test_capture_of_dump_calls);\n }\n \n } // namespace selftest"}, {"sha": "558351d5122a1c0f13276f2ebedab12e4e00452c", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 59, "deletions": 25, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=4df3629eb775ef9a4578c0bed3194565ca30e690", "patch": "@@ -420,6 +420,48 @@ extern FILE *dump_begin (int, dump_flags_t *, int part=-1);\n extern void dump_end (int, FILE *);\n extern int opt_info_switch_p (const char *);\n extern const char *dump_flag_name (int);\n+\n+/* Global variables used to communicate with passes.  */\n+extern FILE *dump_file;\n+extern dump_flags_t dump_flags;\n+extern const char *dump_file_name;\n+\n+extern bool dumps_are_enabled;\n+\n+extern void set_dump_file (FILE *new_dump_file);\n+\n+/* Return true if any of the dumps is enabled, false otherwise. */\n+static inline bool\n+dump_enabled_p (void)\n+{\n+  return dumps_are_enabled;\n+}\n+\n+/* The following API calls (which *don't* take a \"FILE *\")\n+   write the output to zero or more locations:\n+   (a) the active dump_file, if any\n+   (b) the -fopt-info destination, if any\n+   (c) to the \"optinfo\" destinations, if any:\n+\n+   dump_* (MSG_*) --> dumpfile.c --+--> (a) dump_file\n+                                   |\n+                                   +--> (b) alt_dump_file\n+                                   |\n+                                   `--> (c) optinfo\n+                                            `---> optinfo destinations\n+\n+   For optinfos, the dump_*_loc mark the beginning of an optinfo\n+   instance: all subsequent dump_* calls are consolidated into\n+   that optinfo, until the next dump_*_loc call (or a change in\n+   dump scope, or a call to dumpfile_ensure_any_optinfo_are_flushed).\n+\n+   A group of dump_* calls should be guarded by:\n+\n+     if (dump_enabled_p ())\n+\n+   to minimize the work done for the common case where dumps\n+   are disabled.  */\n+\n extern void dump_printf (dump_flags_t, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void dump_printf_loc (dump_flags_t, const dump_location_t &,\n \t\t\t     const char *, ...) ATTRIBUTE_PRINTF_3;\n@@ -434,37 +476,14 @@ extern void dump_gimple_stmt (dump_flags_t, dump_flags_t, gimple *, int);\n extern void dump_gimple_expr_loc (dump_flags_t, const dump_location_t &,\n \t\t\t\t  dump_flags_t, gimple *, int);\n extern void dump_gimple_expr (dump_flags_t, dump_flags_t, gimple *, int);\n-extern void print_combine_total_stats (void);\n-extern bool enable_rtl_dump_file (void);\n+extern void dump_symtab_node (dump_flags_t, symtab_node *);\n \n template<unsigned int N, typename C>\n void dump_dec (dump_flags_t, const poly_int<N, C> &);\n extern void dump_dec (dump_flags_t, const poly_wide_int &, signop);\n extern void dump_hex (dump_flags_t, const poly_wide_int &);\n \n-/* In tree-dump.c  */\n-extern void dump_node (const_tree, dump_flags_t, FILE *);\n-\n-/* In combine.c  */\n-extern void dump_combine_total_stats (FILE *);\n-/* In cfghooks.c  */\n-extern void dump_bb (FILE *, basic_block, int, dump_flags_t);\n-\n-/* Global variables used to communicate with passes.  */\n-extern FILE *dump_file;\n-extern dump_flags_t dump_flags;\n-extern const char *dump_file_name;\n-\n-extern bool dumps_are_enabled;\n-\n-extern void set_dump_file (FILE *new_dump_file);\n-\n-/* Return true if any of the dumps is enabled, false otherwise. */\n-static inline bool\n-dump_enabled_p (void)\n-{\n-  return dumps_are_enabled;\n-}\n+extern void dumpfile_ensure_any_optinfo_are_flushed ();\n \n /* Managing nested scopes, so that dumps can express the call chain\n    leading to a dump message.  */\n@@ -505,8 +524,23 @@ class auto_dump_scope\n #define AUTO_DUMP_SCOPE(NAME, LOC) \\\n   auto_dump_scope scope (NAME, LOC)\n \n+extern void dump_function (int phase, tree fn);\n+extern void print_combine_total_stats (void);\n+extern bool enable_rtl_dump_file (void);\n+\n+/* In tree-dump.c  */\n+extern void dump_node (const_tree, dump_flags_t, FILE *);\n+\n+/* In combine.c  */\n+extern void dump_combine_total_stats (FILE *);\n+/* In cfghooks.c  */\n+extern void dump_bb (FILE *, basic_block, int, dump_flags_t);\n+\n namespace gcc {\n \n+/* A class for managing all of the various dump files used by the\n+   optimization passes.  */\n+\n class dump_manager\n {\n public:"}, {"sha": "6f224bc84ad955d26499889ed7e89f431988eb37", "filename": "gcc/optinfo.cc", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Foptinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Foptinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.cc?ref=4df3629eb775ef9a4578c0bed3194565ca30e690", "patch": "@@ -0,0 +1,236 @@\n+/* Optimization information.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+\n+#include \"optinfo.h\"\n+#include \"dump-context.h\"\n+#include \"pretty-print.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cgraph.h\"\n+#include \"selftest.h\"\n+\n+/* optinfo_item's ctor.  */\n+\n+optinfo_item::optinfo_item (enum optinfo_item_kind kind, location_t location,\n+\t\t\t    char *text, bool owned)\n+: m_kind (kind), m_location (location), m_text (text), m_owned (owned)\n+{\n+}\n+\n+/* optinfo_item's dtor.  */\n+\n+optinfo_item::~optinfo_item ()\n+{\n+  if (m_owned)\n+    free (m_text);\n+}\n+\n+/* Get a string from KIND.  */\n+\n+const char *\n+optinfo_kind_to_string (enum optinfo_kind kind)\n+{\n+  switch (kind)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case OPTINFO_KIND_SUCCESS:\n+      return \"success\";\n+    case OPTINFO_KIND_FAILURE:\n+      return \"failure\";\n+    case OPTINFO_KIND_NOTE:\n+      return \"note\";\n+    case OPTINFO_KIND_SCOPE:\n+      return \"scope\";\n+    }\n+}\n+\n+/* optinfo's dtor.  */\n+\n+optinfo::~optinfo ()\n+{\n+  /* Cleanup.  */\n+  unsigned i;\n+  optinfo_item *item;\n+  FOR_EACH_VEC_ELT (m_items, i, item)\n+    delete item;\n+}\n+\n+/* Emit the optinfo to all of the active destinations.  */\n+\n+void\n+optinfo::emit ()\n+{\n+  /* currently this is a no-op.  */\n+}\n+\n+/* Update the optinfo's kind based on DUMP_KIND.  */\n+\n+void\n+optinfo::handle_dump_file_kind (dump_flags_t dump_kind)\n+{\n+  if (dump_kind & MSG_OPTIMIZED_LOCATIONS)\n+    m_kind = OPTINFO_KIND_SUCCESS;\n+  else if (dump_kind & MSG_MISSED_OPTIMIZATION)\n+    m_kind = OPTINFO_KIND_FAILURE;\n+  else if (dump_kind & MSG_NOTE)\n+    m_kind = OPTINFO_KIND_NOTE;\n+}\n+\n+/* Append a string literal to this optinfo.  */\n+\n+void\n+optinfo::add_string (const char *str)\n+{\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n+\t\t\tconst_cast <char *> (str), false);\n+  m_items.safe_push (item);\n+}\n+\n+/* Append printf-formatted text to this optinfo.  */\n+\n+void\n+optinfo::add_printf (const char *format, ...)\n+{\n+  va_list ap;\n+  va_start (ap, format);\n+  add_printf_va (format, ap);\n+  va_end (ap);\n+}\n+\n+/* Append printf-formatted text to this optinfo.  */\n+\n+void\n+optinfo::add_printf_va (const char *format, va_list ap)\n+{\n+  char *formatted_text = xvasprintf (format, ap);\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n+\t\t\tformatted_text, true);\n+  m_items.safe_push (item);\n+}\n+\n+/* Append a gimple statement to this optinfo, equivalent to\n+   print_gimple_stmt.  */\n+\n+void\n+optinfo::add_gimple_stmt (gimple *stmt, int spc, dump_flags_t dump_flags)\n+{\n+  pretty_printer pp;\n+  pp_needs_newline (&pp) = true;\n+  pp_gimple_stmt_1 (&pp, stmt, spc, dump_flags);\n+  pp_newline (&pp);\n+\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_GIMPLE, gimple_location (stmt),\n+\t\t\txstrdup (pp_formatted_text (&pp)), true);\n+  m_items.safe_push (item);\n+}\n+\n+/* Append a gimple statement to this optinfo, equivalent to\n+   print_gimple_expr.  */\n+\n+void\n+optinfo::add_gimple_expr (gimple *stmt, int spc, dump_flags_t dump_flags)\n+{\n+  dump_flags |= TDF_RHS_ONLY;\n+  pretty_printer pp;\n+  pp_needs_newline (&pp) = true;\n+  pp_gimple_stmt_1 (&pp, stmt, spc, dump_flags);\n+\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_GIMPLE, gimple_location (stmt),\n+\t\t\txstrdup (pp_formatted_text (&pp)), true);\n+  m_items.safe_push (item);\n+}\n+\n+/* Append a tree node to this optinfo, equivalent to print_generic_expr.  */\n+\n+void\n+optinfo::add_tree (tree node, dump_flags_t dump_flags)\n+{\n+  pretty_printer pp;\n+  pp_needs_newline (&pp) = true;\n+  pp_translate_identifiers (&pp) = false;\n+  dump_generic_node (&pp, node, 0, dump_flags, false);\n+\n+  location_t loc = UNKNOWN_LOCATION;\n+  if (EXPR_HAS_LOCATION (node))\n+    loc = EXPR_LOCATION (node);\n+\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_TREE, loc,\n+\t\t\txstrdup (pp_formatted_text (&pp)), true);\n+  m_items.safe_push (item);\n+}\n+\n+/* Append a symbol table node to this optinfo.  */\n+\n+void\n+optinfo::add_symtab_node (symtab_node *node)\n+{\n+  location_t loc = DECL_SOURCE_LOCATION (node->decl);\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_SYMTAB_NODE, loc,\n+\t\t\txstrdup (node->dump_name ()), true);\n+  m_items.safe_push (item);\n+}\n+\n+/* Append the decimal represenation of a wide_int_ref to this\n+   optinfo.  */\n+\n+void\n+optinfo::add_dec (const wide_int_ref &wi, signop sgn)\n+{\n+  char buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+  print_dec (wi, buf, sgn);\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n+\t\t\txstrdup (buf), true);\n+  m_items.safe_push (item);\n+}\n+\n+/* Should optinfo instances be created?\n+   All creation of optinfos should be guarded by this predicate.\n+   Return true if any optinfo destinations are active.  */\n+\n+bool optinfo_enabled_p ()\n+{\n+  /* Currently no destinations are implemented, just a hook for\n+     selftests.  */\n+  return dump_context::get ().forcibly_enable_optinfo_p ();\n+}\n+\n+/* Return true if any of the active optinfo destinations make use\n+   of inlining information.\n+   (if true, then the information is preserved).  */\n+\n+bool optinfo_wants_inlining_info_p ()\n+{\n+  return false;\n+}"}, {"sha": "8fd5202b94de465e4efba0ae99f0f6404278ec85", "filename": "gcc/optinfo.h", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Foptinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df3629eb775ef9a4578c0bed3194565ca30e690/gcc%2Foptinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.h?ref=4df3629eb775ef9a4578c0bed3194565ca30e690", "patch": "@@ -0,0 +1,203 @@\n+/* Optimization information.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OPTINFO_H\n+#define GCC_OPTINFO_H\n+\n+/* An \"optinfo\" is a bundle of information describing part of an\n+   optimization, which can be emitted to zero or more of several\n+   destinations, such as:\n+\n+   * as a \"remark\" through the diagnostics subsystem\n+\n+   * saved to a file as an \"optimization record\"\n+\n+   Currently no such destinations are implemented.\n+\n+   They are generated in response to calls to the \"dump_*\" API in\n+   dumpfile.h; repeated calls to the \"dump_*\" API are consolidated\n+   into a pending optinfo instance, with a \"dump_*_loc\" starting a new\n+   optinfo instance.\n+\n+   The data sent to the dump calls are captured within the pending optinfo\n+   instance as a sequence of optinfo_items.  For example, given:\n+\n+      if (dump_enabled_p ())\n+        {\n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                           \"not vectorized: live stmt not supported: \");\n+          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+        }\n+\n+   the \"dump_printf_loc\" call begins a new optinfo containing two items:\n+   (1) a text item containing \"not vectorized: live stmt not supported: \"\n+   (2) a gimple item for \"stmt\"\n+\n+   Dump destinations are thus able to access rich metadata about the\n+   items when the optinfo is emitted to them, rather than just having plain\n+   text.  For example, when saving the above optinfo to a file as an\n+   \"optimization record\", the record could capture the source location of\n+   \"stmt\" above, rather than just its textual form.\n+\n+   The currently pending optinfo is emitted and deleted:\n+   * each time a \"dump_*_loc\" call occurs (which starts the next optinfo), or\n+   * when the dump files are changed (at the end of a pass)\n+\n+   Dumping to an optinfo instance is non-trivial (due to building optinfo_item\n+   instances), so all usage should be guarded by\n+\n+     if (optinfo_enabled_p ())\n+\n+   which is off by default.  */\n+\n+\n+/* Forward decls.  */\n+struct opt_pass;\n+class optinfo_item;\n+\n+/* Should optinfo instances be created?\n+   All creation of optinfos should be guarded by this predicate.\n+   Return true if any optinfo destinations are active.  */\n+\n+extern bool optinfo_enabled_p ();\n+\n+/* Return true if any of the active optinfo destinations make use\n+   of inlining information.\n+   (if true, then the information is preserved).  */\n+\n+extern bool optinfo_wants_inlining_info_p ();\n+\n+/* The various kinds of optinfo.  */\n+\n+enum optinfo_kind\n+{\n+  OPTINFO_KIND_SUCCESS,\n+  OPTINFO_KIND_FAILURE,\n+  OPTINFO_KIND_NOTE,\n+  OPTINFO_KIND_SCOPE\n+};\n+\n+extern const char *optinfo_kind_to_string (enum optinfo_kind kind);\n+\n+/* A bundle of information describing part of an optimization.  */\n+\n+class optinfo\n+{\n+  friend class dump_context;\n+\n+ public:\n+  optinfo (const dump_location_t &loc,\n+\t   enum optinfo_kind kind,\n+\t   opt_pass *pass)\n+  : m_loc (loc), m_kind (kind), m_pass (pass), m_items ()\n+  {}\n+  ~optinfo ();\n+\n+  const dump_user_location_t &\n+  get_user_location () const { return m_loc.get_user_location (); }\n+\n+  const dump_impl_location_t &\n+  get_impl_location () const { return m_loc.get_impl_location (); }\n+\n+  enum optinfo_kind get_kind () const { return m_kind; }\n+  opt_pass *get_pass () const { return m_pass; }\n+  unsigned int num_items () const { return m_items.length (); }\n+  const optinfo_item *get_item (unsigned int i) const { return m_items[i]; }\n+\n+  location_t get_location_t () const { return m_loc.get_location_t (); }\n+  profile_count get_count () const { return m_loc.get_count (); }\n+\n+ private:\n+  void emit ();\n+\n+  /* Pre-canned ways of manipulating the optinfo, for use by friend class\n+     dump_context.  */\n+  void handle_dump_file_kind (dump_flags_t);\n+  void add_string (const char *str);\n+  void add_printf (const char *format, ...) ATTRIBUTE_PRINTF_2;\n+  void add_printf_va (const char *format, va_list ap) ATTRIBUTE_PRINTF (2, 0);\n+  void add_gimple_stmt (gimple *stmt, int spc, dump_flags_t dump_flags);\n+  void add_gimple_expr (gimple *stmt, int spc, dump_flags_t dump_flags);\n+  void add_tree (tree node, dump_flags_t dump_flags);\n+  void add_symtab_node (symtab_node *node);\n+  void add_dec (const wide_int_ref &wi, signop sgn);\n+\n+  template<unsigned int N, typename C>\n+  void add_poly_int (const poly_int<N, C> &value)\n+  {\n+    /* Compare with dump_dec (MSG_NOTE, ).  */\n+\n+    STATIC_ASSERT (poly_coeff_traits<C>::signedness >= 0);\n+    signop sgn = poly_coeff_traits<C>::signedness ? SIGNED : UNSIGNED;\n+\n+    if (value.is_constant ())\n+      add_dec (value.coeffs[0], sgn);\n+    else\n+      {\n+\tadd_string (\"[\");\n+\tfor (unsigned int i = 0; i < N; ++i)\n+\t  {\n+\t    add_dec (value.coeffs[i], sgn);\n+\t    add_string (i == N - 1 ? \"]\" : \",\");\n+\t  }\n+      }\n+  }\n+\n+ private:\n+  dump_location_t m_loc;\n+  enum optinfo_kind m_kind;\n+  opt_pass *m_pass;\n+  auto_vec <optinfo_item *> m_items;\n+};\n+\n+/* An enum for discriminating between different kinds of optinfo_item.  */\n+\n+enum optinfo_item_kind\n+{\n+  OPTINFO_ITEM_KIND_TEXT,\n+  OPTINFO_ITEM_KIND_TREE,\n+  OPTINFO_ITEM_KIND_GIMPLE,\n+  OPTINFO_ITEM_KIND_SYMTAB_NODE\n+};\n+\n+/* An item within an optinfo.  */\n+\n+class optinfo_item\n+{\n+ public:\n+  optinfo_item (enum optinfo_item_kind kind, location_t location,\n+\t\tchar *text, bool owned);\n+  ~optinfo_item ();\n+\n+  enum optinfo_item_kind get_kind () const { return m_kind; }\n+  location_t get_location () const { return m_location; }\n+  const char *get_text () const { return m_text; }\n+\n+ private:\n+  /* Metadata (e.g. for optimization records).  */\n+  enum optinfo_item_kind m_kind;\n+  location_t m_location;\n+\n+  /* The textual form of the item.  */\n+  char *m_text;\n+  bool m_owned;\n+};\n+\n+#endif /* #ifndef GCC_OPTINFO_H */"}]}