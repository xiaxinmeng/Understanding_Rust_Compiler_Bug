{"sha": "f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhkOWZhOWU4MGI1N2Y4OWU3ODc3Y2U2Y2FkOGEzNDY0ODc5MDA5Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2015-01-15T00:27:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-01-15T00:27:56Z"}, "message": "libgo, compiler: Upgrade libgo to Go 1.4, except for runtime.\n\nThis upgrades all of libgo other than the runtime package to\nthe Go 1.4 release.  In Go 1.4 much of the runtime was\nrewritten into Go.  Merging that code will take more time and\nwill not change the API, so I'm putting it off for now.\n\nThere are a few runtime changes anyhow, to accomodate other\npackages that rely on minor modifications to the runtime\nsupport.\n\nThe compiler changes slightly to add a one-bit flag to each\ntype descriptor kind that is stored directly in an interface,\nwhich for gccgo is currently only pointer types.  Another\none-bit flag (gcprog) is reserved because it is used by the gc\ncompiler, but gccgo does not currently use it.\n\nThere is another error check in the compiler since I ran\nacross it during testing.\n\ngotools/:\n\t* Makefile.am (go_cmd_go_files): Sort entries.  Add generate.go.\n\t* Makefile.in: Rebuild.\n\nFrom-SVN: r219627", "tree": {"sha": "58a1724fee16d2b03c65678c4dd9b50bb97137a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58a1724fee16d2b03c65678c4dd9b50bb97137a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/comments", "author": null, "committer": null, "parents": [{"sha": "6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2"}], "stats": {"total": 36790, "additions": 29890, "deletions": 6900}, "files": [{"sha": "564c5b72ad7abb5365dd4fe0ed2b97408dede766", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -15559,7 +15559,7 @@ bool\n Numeric_constant::set_type(Type* type, bool issue_error, Location loc)\n {\n   bool ret;\n-  if (type == NULL)\n+  if (type == NULL || type->is_error())\n     ret = true;\n   else if (type->integer_type() != NULL)\n     ret = this->check_int_type(type->integer_type(), issue_error, loc);"}, {"sha": "d3047575750b16788469c773163a177b8b08eaf3", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1966,6 +1966,8 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n \n   if (!this->has_pointer())\n     runtime_type_kind |= RUNTIME_TYPE_KIND_NO_POINTERS;\n+  if (this->points_to() != NULL)\n+    runtime_type_kind |= RUNTIME_TYPE_KIND_DIRECT_IFACE;\n   Struct_field_list::const_iterator p = fields->begin();\n   go_assert(p->is_field_name(\"kind\"));\n   vals->push_back(Expression::make_integer_ul(runtime_type_kind, p->type(),"}, {"sha": "acc8af5df0344ff78b3e89e3b250fdc0ce003ccc", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -81,6 +81,8 @@ static const int RUNTIME_TYPE_KIND_STRING = 24;\n static const int RUNTIME_TYPE_KIND_STRUCT = 25;\n static const int RUNTIME_TYPE_KIND_UNSAFE_POINTER = 26;\n \n+static const int RUNTIME_TYPE_KIND_DIRECT_IFACE = (1 << 5);\n+static const int RUNTIME_TYPE_KIND_GC_PROG = (1 << 6);\n static const int RUNTIME_TYPE_KIND_NO_POINTERS = (1 << 7);\n \n // GC instruction opcodes.  These must match the values in libgo/runtime/mgc0.h."}, {"sha": "cc3af21243d205f88bea4090583151d67f7c211d", "filename": "gotools/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,8 @@\n+2015-01-14  Ian Lance Taylor  <iant@google.com>\n+\n+\t* Makefile.am (go_cmd_go_files): Sort entries.  Add generate.go.\n+\t* Makefile.in: Rebuild.\n+\n 2015-01-09  Ian Lance Taylor  <iant@google.com>\n \n \t* Makefile.am (GOCOMPILER): Set to GOC or GOC_FOR_TARGET depending"}, {"sha": "5f129f89df958bc5c4ebefe8331feab9841d42e4", "filename": "gotools/Makefile.am", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -46,27 +46,28 @@ cmdsrcdir = $(srcdir)/../libgo/go/cmd\n go_cmd_go_files = \\\n \t$(cmdsrcdir)/go/build.go \\\n \t$(cmdsrcdir)/go/clean.go \\\n-\t$(cmdsrcdir)/go/main.go \\\n-\t$(cmdsrcdir)/go/signal.go \\\n-\t$(cmdsrcdir)/go/version.go \\\n-\t$(cmdsrcdir)/go/env.go \\\n-\t$(cmdsrcdir)/go/help.go \\\n-\t$(cmdsrcdir)/go/run.go \\\n-\t$(cmdsrcdir)/go/tool.go \\\n-\t$(cmdsrcdir)/go/vet.go \\\n \t$(cmdsrcdir)/go/context.go \\\n-\t$(cmdsrcdir)/go/fix.go \\\n-\t$(cmdsrcdir)/go/get.go \\\n-\t$(cmdsrcdir)/go/http.go \\\n-\t$(cmdsrcdir)/go/signal_unix.go \\\n-\t$(cmdsrcdir)/go/vcs.go \\\n \t$(cmdsrcdir)/go/discovery.go \\\n+\t$(cmdsrcdir)/go/env.go \\\n+\t$(cmdsrcdir)/go/fix.go \\\n \t$(cmdsrcdir)/go/fmt.go \\\n+\t$(cmdsrcdir)/go/generate.go \\\n+\t$(cmdsrcdir)/go/get.go \\\n \t$(cmdsrcdir)/go/go11.go \\\n+\t$(cmdsrcdir)/go/help.go \\\n+\t$(cmdsrcdir)/go/http.go \\\n \t$(cmdsrcdir)/go/list.go \\\n+\t$(cmdsrcdir)/go/main.go \\\n \t$(cmdsrcdir)/go/pkg.go \\\n+\t$(cmdsrcdir)/go/run.go \\\n+\t$(cmdsrcdir)/go/signal.go \\\n+\t$(cmdsrcdir)/go/signal_unix.go \\\n \t$(cmdsrcdir)/go/test.go \\\n-\t$(cmdsrcdir)/go/testflag.go\n+\t$(cmdsrcdir)/go/testflag.go \\\n+\t$(cmdsrcdir)/go/tool.go \\\n+\t$(cmdsrcdir)/go/vcs.go \\\n+\t$(cmdsrcdir)/go/version.go \\\n+\t$(cmdsrcdir)/go/vet.go\n \n go_cmd_gofmt_files = \\\n \t$(cmdsrcdir)/gofmt/doc.go \\"}, {"sha": "20458bdf9b01b9f6b6f1946edaa3418c439e1851", "filename": "gotools/Makefile.in", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -211,27 +211,28 @@ cmdsrcdir = $(srcdir)/../libgo/go/cmd\n go_cmd_go_files = \\\n \t$(cmdsrcdir)/go/build.go \\\n \t$(cmdsrcdir)/go/clean.go \\\n-\t$(cmdsrcdir)/go/main.go \\\n-\t$(cmdsrcdir)/go/signal.go \\\n-\t$(cmdsrcdir)/go/version.go \\\n-\t$(cmdsrcdir)/go/env.go \\\n-\t$(cmdsrcdir)/go/help.go \\\n-\t$(cmdsrcdir)/go/run.go \\\n-\t$(cmdsrcdir)/go/tool.go \\\n-\t$(cmdsrcdir)/go/vet.go \\\n \t$(cmdsrcdir)/go/context.go \\\n-\t$(cmdsrcdir)/go/fix.go \\\n-\t$(cmdsrcdir)/go/get.go \\\n-\t$(cmdsrcdir)/go/http.go \\\n-\t$(cmdsrcdir)/go/signal_unix.go \\\n-\t$(cmdsrcdir)/go/vcs.go \\\n \t$(cmdsrcdir)/go/discovery.go \\\n+\t$(cmdsrcdir)/go/env.go \\\n+\t$(cmdsrcdir)/go/fix.go \\\n \t$(cmdsrcdir)/go/fmt.go \\\n+\t$(cmdsrcdir)/go/generate.go \\\n+\t$(cmdsrcdir)/go/get.go \\\n \t$(cmdsrcdir)/go/go11.go \\\n+\t$(cmdsrcdir)/go/help.go \\\n+\t$(cmdsrcdir)/go/http.go \\\n \t$(cmdsrcdir)/go/list.go \\\n+\t$(cmdsrcdir)/go/main.go \\\n \t$(cmdsrcdir)/go/pkg.go \\\n+\t$(cmdsrcdir)/go/run.go \\\n+\t$(cmdsrcdir)/go/signal.go \\\n+\t$(cmdsrcdir)/go/signal_unix.go \\\n \t$(cmdsrcdir)/go/test.go \\\n-\t$(cmdsrcdir)/go/testflag.go\n+\t$(cmdsrcdir)/go/testflag.go \\\n+\t$(cmdsrcdir)/go/tool.go \\\n+\t$(cmdsrcdir)/go/vcs.go \\\n+\t$(cmdsrcdir)/go/version.go \\\n+\t$(cmdsrcdir)/go/vet.go\n \n go_cmd_gofmt_files = \\\n \t$(cmdsrcdir)/gofmt/doc.go \\"}, {"sha": "0e12671be4e7e5b9bbe58a3624567039ade09f7b", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,4 +1,4 @@\n-f44017549ff9\n+14854533dcc7\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "0ce357690a836068cb6345ffd0e16ee3746f15e0", "filename": "libgo/Makefile.am", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -495,6 +495,7 @@ runtime_files = \\\n \truntime/go-unsafe-new.c \\\n \truntime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c \\\n+\truntime/go-unsetenv.c \\\n \truntime/go-unwind.c \\\n \truntime/go-varargs.c \\\n \truntime/env_posix.c \\\n@@ -695,7 +696,7 @@ go_net_sockoptip_file = go/net/sockoptip_linux.go go/net/sockoptip_posix.go\n else\n if LIBGO_IS_SOLARIS\n go_net_cgo_file = go/net/cgo_linux.go\n-go_net_sock_file = go/net/sock_solaris.go\n+go_net_sock_file = go/net/sock_stub.go\n go_net_sockopt_file = go/net/sockopt_solaris.go\n go_net_sockoptip_file = go/net/sockoptip_stub.go\n else\n@@ -761,17 +762,13 @@ else\n if LIBGO_IS_DARWIN\n go_net_tcpsockopt_file = go/net/tcpsockopt_darwin.go\n else\n-if LIBGO_IS_SOLARIS\n-go_net_tcpsockopt_file = go/net/tcpsockopt_solaris.go\n-else\n if LIBGO_IS_DRAGONFLY\n go_net_tcpsockopt_file = go/net/tcpsockopt_dragonfly.go\n else\n go_net_tcpsockopt_file = go/net/tcpsockopt_unix.go\n endif\n endif\n endif\n-endif\n \n go_net_files = \\\n \tgo/net/cgo_unix.go \\\n@@ -997,7 +994,6 @@ go_runtime_files = \\\n \tgo/runtime/extern.go \\\n \tgo/runtime/mem.go \\\n \tgo/runtime/softfloat64.go \\\n-\tgo/runtime/type.go \\\n \tversion.go\n \n version.go: s-version; @true\n@@ -1187,10 +1183,19 @@ go_crypto_md5_files = \\\n \tgo/crypto/md5/md5.go \\\n \tgo/crypto/md5/md5block.go \\\n \tgo/crypto/md5/md5block_generic.go\n+\n+if LIBGO_IS_LINUX\n+crypto_rand_file = go/crypto/rand/rand_linux.go\n+else\n+crypto_rand_file =\n+endif\n+\n go_crypto_rand_files = \\\n \tgo/crypto/rand/rand.go \\\n \tgo/crypto/rand/rand_unix.go \\\n+\t$(crypto_rand_file) \\\n \tgo/crypto/rand/util.go\n+\n go_crypto_rc4_files = \\\n \tgo/crypto/rc4/rc4.go \\\n \tgo/crypto/rc4/rc4_ref.go\n@@ -1289,9 +1294,11 @@ go_encoding_csv_files = \\\n go_encoding_gob_files = \\\n \tgo/encoding/gob/decode.go \\\n \tgo/encoding/gob/decoder.go \\\n+\tgo/encoding/gob/dec_helpers.go \\\n \tgo/encoding/gob/doc.go \\\n \tgo/encoding/gob/encode.go \\\n \tgo/encoding/gob/encoder.go \\\n+\tgo/encoding/gob/enc_helpers.go \\\n \tgo/encoding/gob/error.go \\\n \tgo/encoding/gob/type.go\n go_encoding_hex_files = \\\n@@ -1452,7 +1459,6 @@ go_mime_multipart_files = \\\n \tgo/mime/multipart/writer.go\n \n go_net_http_files = \\\n-\tgo/net/http/chunked.go \\\n \tgo/net/http/client.go \\\n \tgo/net/http/cookie.go \\\n \tgo/net/http/filetransport.go \\\n@@ -1496,12 +1502,12 @@ go_net_http_httptest_files = \\\n go_net_http_pprof_files = \\\n \tgo/net/http/pprof/pprof.go\n go_net_http_httputil_files = \\\n-\tgo/net/http/httputil/chunked.go \\\n \tgo/net/http/httputil/dump.go \\\n \tgo/net/http/httputil/httputil.go \\\n \tgo/net/http/httputil/persist.go \\\n \tgo/net/http/httputil/reverseproxy.go\n-\n+go_net_http_internal_files = \\\n+\tgo/net/http/internal/chunked.go\n \n go_old_regexp_files = \\\n \tgo/old/regexp/regexp.go\n@@ -1535,7 +1541,8 @@ go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n \tgo/path/filepath/path.go \\\n \tgo/path/filepath/path_unix.go \\\n-\tgo/path/filepath/symlink.go\n+\tgo/path/filepath/symlink.go \\\n+\tgo/path/filepath/symlink_unix.go\n \n go_regexp_syntax_files = \\\n \tgo/regexp/syntax/compile.go \\\n@@ -1570,7 +1577,8 @@ go_text_template_parse_files = \\\n \tgo/text/template/parse/parse.go\n \n go_sync_atomic_files = \\\n-\tgo/sync/atomic/doc.go\n+\tgo/sync/atomic/doc.go \\\n+\tgo/sync/atomic/value.go\n go_sync_atomic_c_files = \\\n \tgo/sync/atomic/atomic.c\n \n@@ -1784,10 +1792,21 @@ go_syscall_c_files = \\\n \n go_syscall_test_files = \\\n \t$(syscall_creds_test_file) \\\n+\tgo/syscall/export_test.go \\\n \tgo/syscall/mmap_unix_test.go \\\n \tgo/syscall/syscall_test.go \\\n \tgo/syscall/syscall_unix_test.go\n \n+if LIBGO_IS_LINUX\n+internal_syscall_getrandom_file = go/internal/syscall/getrandom_linux.go\n+else\n+internal_syscall_getrandom_file =\n+endif\n+\n+go_internal_syscall_files = \\\n+\tgo/internal/syscall/dummy.go \\\n+\t$(internal_syscall_getrandom_file)\n+\n libcalls.go: s-libcalls; @true\n s-libcalls: libcalls-list go/syscall/mksyscall.awk $(go_base_syscall_files)\n \trm -f libcalls.go.tmp\n@@ -1957,6 +1976,7 @@ libgo_go_objs = \\\n \tnet/http/fcgi.lo \\\n \tnet/http/httptest.lo \\\n \tnet/http/httputil.lo \\\n+\tnet/http/internal.lo \\\n \tnet/http/pprof.lo \\\n \timage/color.lo \\\n \timage/color/palette.lo \\\n@@ -1965,6 +1985,7 @@ libgo_go_objs = \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n \tindex/suffixarray.lo \\\n+\tinternal/syscall.lo \\\n \tio/ioutil.lo \\\n \tlog/syslog.lo \\\n \tlog/syslog/syslog_c.lo \\\n@@ -3160,6 +3181,15 @@ net/http/httputil/check: $(check_deps)\n \t@$(CHECK)\n .PHONY: net/http/httputil/check\n \n+@go_include@ net/http/internal.lo.dep\n+net/http/internal.lo.dep: $(go_net_http_internal_files)\n+\t$(BUILDDEPS)\n+net/http/internal.lo: $(go_net_http_internal_files)\n+\t$(BUILDPACKAGE)\n+net/http/internal/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: net/http/internal/check\n+\n @go_include@ net/http/pprof.lo.dep\n net/http/pprof.lo.dep: $(go_net_http_pprof_files)\n \t$(BUILDDEPS)\n@@ -3260,7 +3290,8 @@ runtime/pprof/check: $(CHECK_DEPS)\n .PHONY: runtime/pprof/check\n # At least for now, we need -static-libgo for this test, because\n # otherwise we can't get the line numbers.\n-runtime_pprof_check_GOCFLAGS = -static-libgo\n+# Also use -fno-inline to get better results from the memory profiler.\n+runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n \n @go_include@ sync/atomic.lo.dep\n sync/atomic.lo.dep: $(go_sync_atomic_files)\n@@ -3363,6 +3394,15 @@ syscall/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: syscall/check\n \n+@go_include@ internal/syscall.lo.dep\n+internal/syscall.lo.dep: $(go_internal_syscall_files)\n+\t$(BUILDDEPS)\n+internal/syscall.lo: $(go_internal_syscall_files)\n+\t$(BUILDPACKAGE)\n+internal/syscall/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/syscall/check\n+\n # How to build a .gox file from a .lo file.\n BUILDGOX = \\\n \tf=`echo $< | sed -e 's/.lo$$/.o/'`; \\\n@@ -3623,6 +3663,9 @@ net/http/httputil.gox: net/http/httputil.lo\n net/http/pprof.gox: net/http/pprof.lo\n \t$(BUILDGOX)\n \n+net/http/internal.gox: net/http/internal.lo\n+\t$(BUILDGOX)\n+\n net/rpc/jsonrpc.gox: net/rpc/jsonrpc.lo\n \t$(BUILDGOX)\n \n@@ -3652,6 +3695,9 @@ runtime/pprof.gox: runtime/pprof.lo\n sync/atomic.gox: sync/atomic.lo\n \t$(BUILDGOX)\n \n+internal/syscall.gox: internal/syscall.lo\n+\t$(BUILDGOX)\n+\n text/scanner.gox: text/scanner.lo\n \t$(BUILDGOX)\n text/tabwriter.gox: text/tabwriter.lo\n@@ -3774,6 +3820,7 @@ TEST_PACKAGES = \\\n \tnet/http/fcgi/check \\\n \tnet/http/httptest/check \\\n \tnet/http/httputil/check \\\n+\tnet/http/internal/check \\\n \tnet/mail/check \\\n \tnet/rpc/check \\\n \tnet/smtp/check \\"}, {"sha": "495dc350b700e1fe11bcd977236dd3eb627ff949", "filename": "libgo/Makefile.in", "status": "modified", "additions": 78, "deletions": 27, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -164,14 +164,15 @@ am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n \thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n \tnet/http/cookiejar.lo net/http/fcgi.lo net/http/httptest.lo \\\n-\tnet/http/httputil.lo net/http/pprof.lo image/color.lo \\\n-\timage/color/palette.lo image/draw.lo image/gif.lo \\\n-\timage/jpeg.lo image/png.lo index/suffixarray.lo io/ioutil.lo \\\n-\tlog/syslog.lo log/syslog/syslog_c.lo math/big.lo math/cmplx.lo \\\n-\tmath/rand.lo mime/multipart.lo net/http.lo net/mail.lo \\\n-\tnet/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n-\told/regexp.lo old/template.lo os/exec.lo $(am__DEPENDENCIES_1) \\\n-\tos/signal.lo os/user.lo path/filepath.lo regexp/syntax.lo \\\n+\tnet/http/httputil.lo net/http/internal.lo net/http/pprof.lo \\\n+\timage/color.lo image/color/palette.lo image/draw.lo \\\n+\timage/gif.lo image/jpeg.lo image/png.lo index/suffixarray.lo \\\n+\tinternal/syscall.lo io/ioutil.lo log/syslog.lo \\\n+\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n+\tmime/multipart.lo net/http.lo net/mail.lo net/rpc.lo \\\n+\tnet/smtp.lo net/textproto.lo net/url.lo old/regexp.lo \\\n+\told/template.lo os/exec.lo $(am__DEPENDENCIES_1) os/signal.lo \\\n+\tos/user.lo path/filepath.lo regexp/syntax.lo \\\n \tnet/rpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n \tsync/atomic.lo sync/atomic_c.lo text/scanner.lo \\\n \ttext/tabwriter.lo text/template.lo text/template/parse.lo \\\n@@ -218,15 +219,15 @@ am__objects_6 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-type-complex.lo go-type-eface.lo go-type-error.lo \\\n \tgo-type-float.lo go-type-identity.lo go-type-interface.lo \\\n \tgo-type-string.lo go-typedesc-equal.lo go-unsafe-new.lo \\\n-\tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unwind.lo \\\n-\tgo-varargs.lo env_posix.lo heapdump.lo $(am__objects_1) \\\n-\tmcache.lo mcentral.lo $(am__objects_2) mfixalloc.lo mgc0.lo \\\n-\tmheap.lo msize.lo $(am__objects_3) panic.lo parfor.lo print.lo \\\n-\tproc.lo runtime.lo signal_unix.lo thread.lo yield.lo \\\n-\t$(am__objects_4) chan.lo cpuprof.lo go-iface.lo lfstack.lo \\\n-\tmalloc.lo map.lo mprof.lo netpoll.lo rdebug.lo reflect.lo \\\n-\truntime1.lo sema.lo sigqueue.lo string.lo time.lo \\\n-\t$(am__objects_5)\n+\tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unsetenv.lo \\\n+\tgo-unwind.lo go-varargs.lo env_posix.lo heapdump.lo \\\n+\t$(am__objects_1) mcache.lo mcentral.lo $(am__objects_2) \\\n+\tmfixalloc.lo mgc0.lo mheap.lo msize.lo $(am__objects_3) \\\n+\tpanic.lo parfor.lo print.lo proc.lo runtime.lo signal_unix.lo \\\n+\tthread.lo yield.lo $(am__objects_4) chan.lo cpuprof.lo \\\n+\tgo-iface.lo lfstack.lo malloc.lo map.lo mprof.lo netpoll.lo \\\n+\trdebug.lo reflect.lo runtime1.lo sema.lo sigqueue.lo string.lo \\\n+\ttime.lo $(am__objects_5)\n am_libgo_llgo_la_OBJECTS = $(am__objects_6)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -838,6 +839,7 @@ runtime_files = \\\n \truntime/go-unsafe-new.c \\\n \truntime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c \\\n+\truntime/go-unsetenv.c \\\n \truntime/go-unwind.c \\\n \truntime/go-varargs.c \\\n \truntime/env_posix.c \\\n@@ -992,7 +994,7 @@ go_mime_files = \\\n @LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n @LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n @LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n-@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sock_file = go/net/sock_solaris.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sock_file = go/net/sock_stub.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n@@ -1017,9 +1019,8 @@ go_mime_files = \\\n @LIBGO_IS_LINUX_TRUE@go_net_interface_file = go/net/interface_linux.go\n @LIBGO_IS_LINUX_FALSE@go_net_cloexec_file = go/net/sys_cloexec.go\n @LIBGO_IS_LINUX_TRUE@go_net_cloexec_file = go/net/sock_cloexec.go\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_tcpsockopt_file = go/net/tcpsockopt_unix.go\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_tcpsockopt_file = go/net/tcpsockopt_dragonfly.go\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_tcpsockopt_file = go/net/tcpsockopt_solaris.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_OPENBSD_FALSE@go_net_tcpsockopt_file = go/net/tcpsockopt_unix.go\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_OPENBSD_FALSE@go_net_tcpsockopt_file = go/net/tcpsockopt_dragonfly.go\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_OPENBSD_FALSE@go_net_tcpsockopt_file = go/net/tcpsockopt_darwin.go\n @LIBGO_IS_OPENBSD_TRUE@go_net_tcpsockopt_file = go/net/tcpsockopt_openbsd.go\n go_net_files = \\\n@@ -1180,7 +1181,6 @@ go_runtime_files = \\\n \tgo/runtime/extern.go \\\n \tgo/runtime/mem.go \\\n \tgo/runtime/softfloat64.go \\\n-\tgo/runtime/type.go \\\n \tversion.go\n \n go_sort_files = \\\n@@ -1348,9 +1348,12 @@ go_crypto_md5_files = \\\n \tgo/crypto/md5/md5block.go \\\n \tgo/crypto/md5/md5block_generic.go\n \n+@LIBGO_IS_LINUX_FALSE@crypto_rand_file = \n+@LIBGO_IS_LINUX_TRUE@crypto_rand_file = go/crypto/rand/rand_linux.go\n go_crypto_rand_files = \\\n \tgo/crypto/rand/rand.go \\\n \tgo/crypto/rand/rand_unix.go \\\n+\t$(crypto_rand_file) \\\n \tgo/crypto/rand/util.go\n \n go_crypto_rc4_files = \\\n@@ -1469,9 +1472,11 @@ go_encoding_csv_files = \\\n go_encoding_gob_files = \\\n \tgo/encoding/gob/decode.go \\\n \tgo/encoding/gob/decoder.go \\\n+\tgo/encoding/gob/dec_helpers.go \\\n \tgo/encoding/gob/doc.go \\\n \tgo/encoding/gob/encode.go \\\n \tgo/encoding/gob/encoder.go \\\n+\tgo/encoding/gob/enc_helpers.go \\\n \tgo/encoding/gob/error.go \\\n \tgo/encoding/gob/type.go\n \n@@ -1649,7 +1654,6 @@ go_mime_multipart_files = \\\n \tgo/mime/multipart/writer.go\n \n go_net_http_files = \\\n-\tgo/net/http/chunked.go \\\n \tgo/net/http/client.go \\\n \tgo/net/http/cookie.go \\\n \tgo/net/http/filetransport.go \\\n@@ -1702,12 +1706,14 @@ go_net_http_pprof_files = \\\n \tgo/net/http/pprof/pprof.go\n \n go_net_http_httputil_files = \\\n-\tgo/net/http/httputil/chunked.go \\\n \tgo/net/http/httputil/dump.go \\\n \tgo/net/http/httputil/httputil.go \\\n \tgo/net/http/httputil/persist.go \\\n \tgo/net/http/httputil/reverseproxy.go\n \n+go_net_http_internal_files = \\\n+\tgo/net/http/internal/chunked.go\n+\n go_old_regexp_files = \\\n \tgo/old/regexp/regexp.go\n \n@@ -1737,7 +1743,8 @@ go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n \tgo/path/filepath/path.go \\\n \tgo/path/filepath/path_unix.go \\\n-\tgo/path/filepath/symlink.go\n+\tgo/path/filepath/symlink.go \\\n+\tgo/path/filepath/symlink_unix.go\n \n go_regexp_syntax_files = \\\n \tgo/regexp/syntax/compile.go \\\n@@ -1775,7 +1782,8 @@ go_text_template_parse_files = \\\n \tgo/text/template/parse/parse.go\n \n go_sync_atomic_files = \\\n-\tgo/sync/atomic/doc.go\n+\tgo/sync/atomic/doc.go \\\n+\tgo/sync/atomic/value.go\n \n go_sync_atomic_c_files = \\\n \tgo/sync/atomic/atomic.c\n@@ -1918,10 +1926,17 @@ go_syscall_c_files = \\\n \n go_syscall_test_files = \\\n \t$(syscall_creds_test_file) \\\n+\tgo/syscall/export_test.go \\\n \tgo/syscall/mmap_unix_test.go \\\n \tgo/syscall/syscall_test.go \\\n \tgo/syscall/syscall_unix_test.go\n \n+@LIBGO_IS_LINUX_FALSE@internal_syscall_getrandom_file = \n+@LIBGO_IS_LINUX_TRUE@internal_syscall_getrandom_file = go/internal/syscall/getrandom_linux.go\n+go_internal_syscall_files = \\\n+\tgo/internal/syscall/dummy.go \\\n+\t$(internal_syscall_getrandom_file)\n+\n @LIBGO_IS_LINUX_FALSE@os_lib_inotify_lo = \n \n # os_lib_inotify_lo = os/inotify.lo\n@@ -2030,6 +2045,7 @@ libgo_go_objs = \\\n \tnet/http/fcgi.lo \\\n \tnet/http/httptest.lo \\\n \tnet/http/httputil.lo \\\n+\tnet/http/internal.lo \\\n \tnet/http/pprof.lo \\\n \timage/color.lo \\\n \timage/color/palette.lo \\\n@@ -2038,6 +2054,7 @@ libgo_go_objs = \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n \tindex/suffixarray.lo \\\n+\tinternal/syscall.lo \\\n \tio/ioutil.lo \\\n \tlog/syslog.lo \\\n \tlog/syslog/syslog_c.lo \\\n@@ -2169,7 +2186,8 @@ CHECK_DEPS = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgounicode_DATA) $(am__append_1) $(am__append_2)\n # At least for now, we need -static-libgo for this test, because\n # otherwise we can't get the line numbers.\n-runtime_pprof_check_GOCFLAGS = -static-libgo\n+# Also use -fno-inline to get better results from the memory profiler.\n+runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n \n # How to build a .gox file from a .lo file.\n BUILDGOX = \\\n@@ -2279,6 +2297,7 @@ TEST_PACKAGES = \\\n \tnet/http/fcgi/check \\\n \tnet/http/httptest/check \\\n \tnet/http/httputil/check \\\n+\tnet/http/internal/check \\\n \tnet/mail/check \\\n \tnet/rpc/check \\\n \tnet/smtp/check \\\n@@ -2515,6 +2534,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-new.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-newarray.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-pointer.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsetenv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unwind.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-varargs.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/heapdump.Plo@am__quote@\n@@ -3031,6 +3051,13 @@ go-unsafe-pointer.lo: runtime/go-unsafe-pointer.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-unsafe-pointer.lo `test -f 'runtime/go-unsafe-pointer.c' || echo '$(srcdir)/'`runtime/go-unsafe-pointer.c\n \n+go-unsetenv.lo: runtime/go-unsetenv.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-unsetenv.lo -MD -MP -MF $(DEPDIR)/go-unsetenv.Tpo -c -o go-unsetenv.lo `test -f 'runtime/go-unsetenv.c' || echo '$(srcdir)/'`runtime/go-unsetenv.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-unsetenv.Tpo $(DEPDIR)/go-unsetenv.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-unsetenv.c' object='go-unsetenv.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-unsetenv.lo `test -f 'runtime/go-unsetenv.c' || echo '$(srcdir)/'`runtime/go-unsetenv.c\n+\n go-unwind.lo: runtime/go-unwind.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-unwind.lo -MD -MP -MF $(DEPDIR)/go-unwind.Tpo -c -o go-unwind.lo `test -f 'runtime/go-unwind.c' || echo '$(srcdir)/'`runtime/go-unwind.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-unwind.Tpo $(DEPDIR)/go-unwind.Plo\n@@ -5498,6 +5525,15 @@ net/http/httputil/check: $(check_deps)\n \t@$(CHECK)\n .PHONY: net/http/httputil/check\n \n+@go_include@ net/http/internal.lo.dep\n+net/http/internal.lo.dep: $(go_net_http_internal_files)\n+\t$(BUILDDEPS)\n+net/http/internal.lo: $(go_net_http_internal_files)\n+\t$(BUILDPACKAGE)\n+net/http/internal/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: net/http/internal/check\n+\n @go_include@ net/http/pprof.lo.dep\n net/http/pprof.lo.dep: $(go_net_http_pprof_files)\n \t$(BUILDDEPS)\n@@ -5698,6 +5734,15 @@ syscall/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: syscall/check\n \n+@go_include@ internal/syscall.lo.dep\n+internal/syscall.lo.dep: $(go_internal_syscall_files)\n+\t$(BUILDDEPS)\n+internal/syscall.lo: $(go_internal_syscall_files)\n+\t$(BUILDPACKAGE)\n+internal/syscall/check: $(CHECK_DEPS)\n+\t@$(CHECK)\n+.PHONY: internal/syscall/check\n+\n bufio.gox: bufio.lo\n \t$(BUILDGOX)\n bytes.gox: bytes.lo\n@@ -5953,6 +5998,9 @@ net/http/httputil.gox: net/http/httputil.lo\n net/http/pprof.gox: net/http/pprof.lo\n \t$(BUILDGOX)\n \n+net/http/internal.gox: net/http/internal.lo\n+\t$(BUILDGOX)\n+\n net/rpc/jsonrpc.gox: net/rpc/jsonrpc.lo\n \t$(BUILDGOX)\n \n@@ -5982,6 +6030,9 @@ runtime/pprof.gox: runtime/pprof.lo\n sync/atomic.gox: sync/atomic.lo\n \t$(BUILDGOX)\n \n+internal/syscall.gox: internal/syscall.lo\n+\t$(BUILDGOX)\n+\n text/scanner.gox: text/scanner.lo\n \t$(BUILDGOX)\n text/tabwriter.gox: text/tabwriter.lo"}, {"sha": "629c603e380f5200b0fbcce7be57a50c3b374aaa", "filename": "libgo/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -319,6 +319,9 @@\n /* Define to 1 if you have the `unlinkat' function. */\n #undef HAVE_UNLINKAT\n \n+/* Define to 1 if you have the `unsetenv' function. */\n+#undef HAVE_UNSETENV\n+\n /* Define to 1 if you have the `unshare' function. */\n #undef HAVE_UNSHARE\n "}, {"sha": "b8e776f13eba490707a81c510d2f9252b162ec6a", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -14805,7 +14805,7 @@ else\n fi\n \n \n-for ac_func in strerror_r strsignal wait4 mincore setenv dl_iterate_phdr\n+for ac_func in strerror_r strsignal wait4 mincore setenv unsetenv dl_iterate_phdr\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\""}, {"sha": "4482dd07f68fc34c6158d05412beac7fab284e40", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -551,7 +551,7 @@ fi\n \n AM_CONDITIONAL(HAVE_SYS_MMAN_H, test \"$ac_cv_header_sys_mman_h\" = yes)\n \n-AC_CHECK_FUNCS(strerror_r strsignal wait4 mincore setenv dl_iterate_phdr)\n+AC_CHECK_FUNCS(strerror_r strsignal wait4 mincore setenv unsetenv dl_iterate_phdr)\n AM_CONDITIONAL(HAVE_STRERROR_R, test \"$ac_cv_func_strerror_r\" = yes)\n AM_CONDITIONAL(HAVE_WAIT4, test \"$ac_cv_func_wait4\" = yes)\n "}, {"sha": "a27559d0f042c152ca4ef8b20cbe21412fc14fa7", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -29,10 +29,11 @@ const maxNanoSecondIntSize = 9\n // The Next method advances to the next file in the archive (including the first),\n // and then it can be treated as an io.Reader to access the file's data.\n type Reader struct {\n-\tr    io.Reader\n-\terr  error\n-\tpad  int64          // amount of padding (ignored) after current file entry\n-\tcurr numBytesReader // reader for current file entry\n+\tr       io.Reader\n+\terr     error\n+\tpad     int64           // amount of padding (ignored) after current file entry\n+\tcurr    numBytesReader  // reader for current file entry\n+\thdrBuff [blockSize]byte // buffer to use in readHeader\n }\n \n // A numBytesReader is an io.Reader with a numBytes method, returning the number\n@@ -426,7 +427,9 @@ func (tr *Reader) verifyChecksum(header []byte) bool {\n }\n \n func (tr *Reader) readHeader() *Header {\n-\theader := make([]byte, blockSize)\n+\theader := tr.hdrBuff[:]\n+\tcopy(header, zeroBlock)\n+\n \tif _, tr.err = io.ReadFull(tr.r, header); tr.err != nil {\n \t\treturn nil\n \t}"}, {"sha": "dafb2cabf37a8c4194b49ac37f0b65df860ae3c0", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -37,8 +37,10 @@ type Writer struct {\n \tnb         int64 // number of unwritten bytes for current file entry\n \tpad        int64 // amount of padding to write after current file entry\n \tclosed     bool\n-\tusedBinary bool // whether the binary numeric field extension was used\n-\tpreferPax  bool // use pax header instead of binary numeric header\n+\tusedBinary bool            // whether the binary numeric field extension was used\n+\tpreferPax  bool            // use pax header instead of binary numeric header\n+\thdrBuff    [blockSize]byte // buffer to use in writeHeader when writing a regular header\n+\tpaxHdrBuff [blockSize]byte // buffer to use in writeHeader when writing a pax header\n }\n \n // NewWriter creates a new Writer writing to w.\n@@ -160,7 +162,18 @@ func (tw *Writer) writeHeader(hdr *Header, allowPax bool) error {\n \t// subsecond time resolution, but for now let's just capture\n \t// too long fields or non ascii characters\n \n-\theader := make([]byte, blockSize)\n+\tvar header []byte\n+\n+\t// We need to select which scratch buffer to use carefully,\n+\t// since this method is called recursively to write PAX headers.\n+\t// If allowPax is true, this is the non-recursive call, and we will use hdrBuff.\n+\t// If allowPax is false, we are being called by writePAXHeader, and hdrBuff is\n+\t// already being used by the non-recursive call, so we must use paxHdrBuff.\n+\theader = tw.hdrBuff[:]\n+\tif !allowPax {\n+\t\theader = tw.paxHdrBuff[:]\n+\t}\n+\tcopy(header, zeroBlock)\n \ts := slicer(header)\n \n \t// keep a reference to the filename to allow to overwrite it later if we detect that we can use ustar longnames instead of pax"}, {"sha": "5e42e322f9c722f66d730793cfdab18895a25c30", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -454,3 +454,38 @@ func TestUSTARLongName(t *testing.T) {\n \t\tt.Fatal(\"Couldn't recover long name\")\n \t}\n }\n+\n+func TestValidTypeflagWithPAXHeader(t *testing.T) {\n+\tvar buffer bytes.Buffer\n+\ttw := NewWriter(&buffer)\n+\n+\tfileName := strings.Repeat(\"ab\", 100)\n+\n+\thdr := &Header{\n+\t\tName:     fileName,\n+\t\tSize:     4,\n+\t\tTypeflag: 0,\n+\t}\n+\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\tt.Fatalf(\"Failed to write header: %s\", err)\n+\t}\n+\tif _, err := tw.Write([]byte(\"fooo\")); err != nil {\n+\t\tt.Fatalf(\"Failed to write the file's data: %s\", err)\n+\t}\n+\ttw.Close()\n+\n+\ttr := NewReader(&buffer)\n+\n+\tfor {\n+\t\theader, err := tr.Next()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Failed to read header: %s\", err)\n+\t\t}\n+\t\tif header.Typeflag != 0 {\n+\t\t\tt.Fatalf(\"Typeflag should've been 0, found %d\", header.Typeflag)\n+\t\t}\n+\t}\n+}"}, {"sha": "8136b840d455f4bcf0911d1c0b7020822a49faba", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -267,8 +267,13 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n \t\t\tb = b[size:]\n \t\t}\n \t\t// Should have consumed the whole header.\n-\t\tif len(b) != 0 {\n-\t\t\treturn ErrFormat\n+\t\t// But popular zip & JAR creation tools are broken and\n+\t\t// may pad extra zeros at the end, so accept those\n+\t\t// too. See golang.org/issue/8186.\n+\t\tfor _, v := range b {\n+\t\t\tif v != 0 {\n+\t\t\t\treturn ErrFormat\n+\t\t\t}\n \t\t}\n \t}\n \treturn nil"}, {"sha": "29d0652dcc16ed795841f9449aecb4d1a0f0caa3", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"regexp\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -508,3 +509,25 @@ func returnRecursiveZip() (r io.ReaderAt, size int64) {\n \tb := rZipBytes()\n \treturn bytes.NewReader(b), int64(len(b))\n }\n+\n+func TestIssue8186(t *testing.T) {\n+\t// Directory headers & data found in the TOC of a JAR file.\n+\tdirEnts := []string{\n+\t\t\"PK\\x01\\x02\\n\\x00\\n\\x00\\x00\\b\\x00\\x004\\x9d3?\\xaa\\x1b\\x06\\xf0\\x81\\x02\\x00\\x00\\x81\\x02\\x00\\x00-\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00res/drawable-xhdpi-v4/ic_actionbar_accept.png\\xfe\\xca\\x00\\x00\\x00\",\n+\t\t\"PK\\x01\\x02\\n\\x00\\n\\x00\\x00\\b\\x00\\x004\\x9d3?\\x90K\\x89\\xc7t\\n\\x00\\x00t\\n\\x00\\x00\\x0e\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd1\\x02\\x00\\x00resources.arsc\\x00\\x00\\x00\",\n+\t\t\"PK\\x01\\x02\\x14\\x00\\x14\\x00\\b\\b\\b\\x004\\x9d3?\\xff$\\x18\\xed3\\x03\\x00\\x00\\xb4\\b\\x00\\x00\\x13\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00t\\r\\x00\\x00AndroidManifest.xml\",\n+\t\t\"PK\\x01\\x02\\x14\\x00\\x14\\x00\\b\\b\\b\\x004\\x9d3?\\x14\\xc5K\\xab\\x192\\x02\\x00\\xc8\\xcd\\x04\\x00\\v\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe8\\x10\\x00\\x00classes.dex\",\n+\t\t\"PK\\x01\\x02\\x14\\x00\\x14\\x00\\b\\b\\b\\x004\\x9d3?E\\x96\\nD\\xac\\x01\\x00\\x00P\\x03\\x00\\x00&\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00:C\\x02\\x00res/layout/actionbar_set_wallpaper.xml\",\n+\t\t\"PK\\x01\\x02\\x14\\x00\\x14\\x00\\b\\b\\b\\x004\\x9d3?\u013b\\x14\\xe3\\xd8\\x01\\x00\\x00\\xd8\\x03\\x00\\x00 \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00:E\\x02\\x00res/layout/wallpaper_cropper.xml\",\n+\t\t\"PK\\x01\\x02\\x14\\x00\\x14\\x00\\b\\b\\b\\x004\\x9d3?}\\xc1\\x15\\x9eZ\\x01\\x00\\x00!\\x02\\x00\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00`G\\x02\\x00META-INF/MANIFEST.MF\",\n+\t\t\"PK\\x01\\x02\\x14\\x00\\x14\\x00\\b\\b\\b\\x004\\x9d3?\\xe6\\x98\u042co\\x01\\x00\\x00\\x84\\x02\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfcH\\x02\\x00META-INF/CERT.SF\",\n+\t\t\"PK\\x01\\x02\\x14\\x00\\x14\\x00\\b\\b\\b\\x004\\x9d3?\\xbfP\\x96b\\x86\\x04\\x00\\x00\\xb2\\x06\\x00\\x00\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa9J\\x02\\x00META-INF/CERT.RSA\",\n+\t}\n+\tfor i, s := range dirEnts {\n+\t\tvar f File\n+\t\terr := readDirectoryHeader(&f, strings.NewReader(s))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error reading #%d: %v\", i, err)\n+\t\t}\n+\t}\n+}"}, {"sha": "170beec0eec3fe8a76c96f8f8752afd7d3c6ee8e", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -34,6 +34,12 @@ func NewWriter(w io.Writer) *Writer {\n \treturn &Writer{cw: &countWriter{w: bufio.NewWriter(w)}}\n }\n \n+// Flush flushes any buffered data to the underlying writer.\n+// Calling Flush is not normally necessary; calling Close is sufficient.\n+func (w *Writer) Flush() error {\n+\treturn w.cw.w.(*bufio.Writer).Flush()\n+}\n+\n // Close finishes writing the zip file by writing the central directory.\n // It does not (and can not) close the underlying writer.\n func (w *Writer) Close() error {"}, {"sha": "184a7d96a7f2bb331d35a77932de8e4189dd38a5", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,6 +6,7 @@ package zip\n \n import (\n \t\"bytes\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"math/rand\"\n \t\"os\"\n@@ -86,6 +87,24 @@ func TestWriter(t *testing.T) {\n \t}\n }\n \n+func TestWriterFlush(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tw := NewWriter(struct{ io.Writer }{&buf})\n+\t_, err := w.Create(\"foo\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif buf.Len() > 0 {\n+\t\tt.Fatalf(\"Unexpected %d bytes already in buffer\", buf.Len())\n+\t}\n+\tif err := w.Flush(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif buf.Len() == 0 {\n+\t\tt.Fatal(\"No bytes written after Flush\")\n+\t}\n+}\n+\n func testCreate(t *testing.T, w *Writer, wt *WriteTest) {\n \theader := &FileHeader{\n \t\tName:   wt.Name,"}, {"sha": "d3c68fe6fe539e975f668c6d7e6af66c7348af79", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -30,8 +30,8 @@ var (\n // Reader implements buffering for an io.Reader object.\n type Reader struct {\n \tbuf          []byte\n-\trd           io.Reader\n-\tr, w         int\n+\trd           io.Reader // reader provided by the client\n+\tr, w         int       // buf read and write positions\n \terr          error\n \tlastByte     int\n \tlastRuneSize int\n@@ -131,18 +131,17 @@ func (b *Reader) Peek(n int) ([]byte, error) {\n \tfor b.w-b.r < n && b.err == nil {\n \t\tb.fill() // b.w-b.r < len(b.buf) => buffer is not full\n \t}\n-\tm := b.w - b.r\n-\tif m > n {\n-\t\tm = n\n-\t}\n+\n \tvar err error\n-\tif m < n {\n+\tif avail := b.w - b.r; avail < n {\n+\t\t// not enough data in buffer\n+\t\tn = avail\n \t\terr = b.readErr()\n \t\tif err == nil {\n \t\t\terr = ErrBufferFull\n \t\t}\n \t}\n-\treturn b.buf[b.r : b.r+m], err\n+\treturn b.buf[b.r : b.r+n], err\n }\n \n // Read reads data into p.\n@@ -173,15 +172,13 @@ func (b *Reader) Read(p []byte) (n int, err error) {\n \t\t\treturn n, b.readErr()\n \t\t}\n \t\tb.fill() // buffer is empty\n-\t\tif b.w == b.r {\n+\t\tif b.r == b.w {\n \t\t\treturn 0, b.readErr()\n \t\t}\n \t}\n \n-\tif n > b.w-b.r {\n-\t\tn = b.w - b.r\n-\t}\n-\tcopy(p[0:n], b.buf[b.r:])\n+\t// copy as much as we can\n+\tn = copy(p, b.buf[b.r:b.w])\n \tb.r += n\n \tb.lastByte = int(b.buf[b.r-1])\n \tb.lastRuneSize = -1\n@@ -288,7 +285,7 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {\n \t\t}\n \n \t\t// Buffer full?\n-\t\tif n := b.Buffered(); n >= len(b.buf) {\n+\t\tif b.Buffered() >= len(b.buf) {\n \t\t\tb.r = b.w\n \t\t\tline = b.buf\n \t\t\terr = ErrBufferFull\n@@ -301,6 +298,7 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {\n \t// Handle last byte, if any.\n \tif i := len(line) - 1; i >= 0 {\n \t\tb.lastByte = int(line[i])\n+\t\tb.lastRuneSize = -1\n \t}\n \n \treturn\n@@ -458,11 +456,13 @@ func (b *Reader) WriteTo(w io.Writer) (n int64, err error) {\n \treturn n, b.readErr()\n }\n \n+var errNegativeWrite = errors.New(\"bufio: writer returned negative count from Write\")\n+\n // writeBuf writes the Reader's buffer to the writer.\n func (b *Reader) writeBuf(w io.Writer) (int64, error) {\n \tn, err := w.Write(b.buf[b.r:b.w])\n-\tif n < b.r-b.w {\n-\t\tpanic(errors.New(\"bufio: writer did not write all data\"))\n+\tif n < 0 {\n+\t\tpanic(errNegativeWrite)\n \t}\n \tb.r += n\n \treturn int64(n), err"}, {"sha": "550dac9173f0083828974c47d8fe3d1acd61eace", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -31,9 +31,6 @@ func newRot13Reader(r io.Reader) *rot13Reader {\n \n func (r13 *rot13Reader) Read(p []byte) (int, error) {\n \tn, err := r13.r.Read(p)\n-\tif err != nil {\n-\t\treturn n, err\n-\t}\n \tfor i := 0; i < n; i++ {\n \t\tc := p[i] | 0x20 // lowercase byte\n \t\tif 'a' <= c && c <= 'm' {\n@@ -42,7 +39,7 @@ func (r13 *rot13Reader) Read(p []byte) (int, error) {\n \t\t\tp[i] -= 13\n \t\t}\n \t}\n-\treturn n, nil\n+\treturn n, err\n }\n \n // Call ReadByte to accumulate the text of a file\n@@ -438,7 +435,7 @@ func TestUnreadRuneError(t *testing.T) {\n \tif err != nil {\n \t\tt.Error(\"unexpected error on ReadRune (2):\", err)\n \t}\n-\tfor _ = range buf {\n+\tfor range buf {\n \t\t_, err = r.ReadByte()\n \t\tif err != nil {\n \t\t\tt.Error(\"unexpected error on ReadByte (2):\", err)\n@@ -463,6 +460,18 @@ func TestUnreadRuneError(t *testing.T) {\n \tif r.UnreadRune() == nil {\n \t\tt.Error(\"expected error after UnreadByte (3)\")\n \t}\n+\t// Test error after ReadSlice.\n+\t_, _, err = r.ReadRune() // reset state\n+\tif err != nil {\n+\t\tt.Error(\"unexpected error on ReadRune (4):\", err)\n+\t}\n+\t_, err = r.ReadSlice(0)\n+\tif err != io.EOF {\n+\t\tt.Error(\"unexpected error on ReadSlice (4):\", err)\n+\t}\n+\tif r.UnreadRune() == nil {\n+\t\tt.Error(\"expected error after ReadSlice (4)\")\n+\t}\n }\n \n func TestUnreadRuneAtEOF(t *testing.T) {"}, {"sha": "364d15961399b6a07e56f7bf4e0ae7e06b3ec33d", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -36,6 +36,7 @@ type Scanner struct {\n \tstart        int       // First non-processed byte in buf.\n \tend          int       // End of data in buf.\n \terr          error     // Sticky error.\n+\tempties      int       // Count of successive empty tokens.\n }\n \n // SplitFunc is the signature of the split function used to tokenize the\n@@ -64,8 +65,9 @@ var (\n )\n \n const (\n-\t// Maximum size used to buffer a token. The actual maximum token size\n-\t// may be smaller as the buffer may need to include, for instance, a newline.\n+\t// MaxScanTokenSize is the maximum size used to buffer a token.\n+\t// The actual maximum token size may be smaller as the buffer\n+\t// may need to include, for instance, a newline.\n \tMaxScanTokenSize = 64 * 1024\n )\n \n@@ -107,11 +109,15 @@ func (s *Scanner) Text() string {\n // After Scan returns false, the Err method will return any error that\n // occurred during scanning, except that if it was io.EOF, Err\n // will return nil.\n+// Split panics if the split function returns 100 empty tokens without\n+// advancing the input. This is a common error mode for scanners.\n func (s *Scanner) Scan() bool {\n \t// Loop until we have a token.\n \tfor {\n \t\t// See if we can get a token with what we already have.\n-\t\tif s.end > s.start {\n+\t\t// If we've run out of data but have an error, give the split function\n+\t\t// a chance to recover any remaining, possibly empty token.\n+\t\tif s.end > s.start || s.err != nil {\n \t\t\tadvance, token, err := s.split(s.buf[s.start:s.end], s.err != nil)\n \t\t\tif err != nil {\n \t\t\t\ts.setErr(err)\n@@ -122,6 +128,15 @@ func (s *Scanner) Scan() bool {\n \t\t\t}\n \t\t\ts.token = token\n \t\t\tif token != nil {\n+\t\t\t\tif s.err == nil || advance > 0 {\n+\t\t\t\t\ts.empties = 0\n+\t\t\t\t} else {\n+\t\t\t\t\t// Returning tokens not advancing input at EOF.\n+\t\t\t\t\ts.empties++\n+\t\t\t\t\tif s.empties > 100 {\n+\t\t\t\t\t\tpanic(\"bufio.Scan: 100 empty tokens without progressing\")\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\treturn true\n \t\t\t}\n \t\t}\n@@ -169,6 +184,7 @@ func (s *Scanner) Scan() bool {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif n > 0 {\n+\t\t\t\ts.empties = 0\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tloop++\n@@ -326,9 +342,6 @@ func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error) {\n \t\t\tbreak\n \t\t}\n \t}\n-\tif atEOF && len(data) == 0 {\n-\t\treturn 0, nil, nil\n-\t}\n \t// Scan until space, marking end of word.\n \tfor width, i := 0, start; i < len(data); i += width {\n \t\tvar r rune\n@@ -342,5 +355,5 @@ func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error) {\n \t\treturn len(data), data[start:], nil\n \t}\n \t// Request more data.\n-\treturn 0, nil, nil\n+\treturn start, nil, nil\n }"}, {"sha": "eea87cbf7b39de26059bb7f1dd673b37820d868e", "filename": "libgo/go/bufio/scan_test.go", "status": "modified", "additions": 119, "deletions": 1, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbufio%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbufio%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -15,6 +15,8 @@ import (\n \t\"unicode/utf8\"\n )\n \n+const smallMaxTokenSize = 256 // Much smaller for more efficient testing.\n+\n // Test white space table matches the Unicode definition.\n func TestSpace(t *testing.T) {\n \tfor r := rune(0); r <= utf8.MaxRune; r++ {\n@@ -172,7 +174,6 @@ func genLine(buf *bytes.Buffer, lineNum, n int, addNewline bool) {\n \n // Test the line splitter, including some carriage returns but no long lines.\n func TestScanLongLines(t *testing.T) {\n-\tconst smallMaxTokenSize = 256 // Much smaller for more efficient testing.\n \t// Build a buffer of lots of line lengths up to but not exceeding smallMaxTokenSize.\n \ttmp := new(bytes.Buffer)\n \tbuf := new(bytes.Buffer)\n@@ -404,3 +405,120 @@ func TestBadReader(t *testing.T) {\n \t\tt.Errorf(\"unexpected error: %v\", err)\n \t}\n }\n+\n+func TestScanWordsExcessiveWhiteSpace(t *testing.T) {\n+\tconst word = \"ipsum\"\n+\ts := strings.Repeat(\" \", 4*smallMaxTokenSize) + word\n+\tscanner := NewScanner(strings.NewReader(s))\n+\tscanner.MaxTokenSize(smallMaxTokenSize)\n+\tscanner.Split(ScanWords)\n+\tif !scanner.Scan() {\n+\t\tt.Fatalf(\"scan failed: %v\", scanner.Err())\n+\t}\n+\tif token := scanner.Text(); token != word {\n+\t\tt.Fatalf(\"unexpected token: %v\", token)\n+\t}\n+}\n+\n+// Test that empty tokens, including at end of line or end of file, are found by the scanner.\n+// Issue 8672: Could miss final empty token.\n+\n+func commaSplit(data []byte, atEOF bool) (advance int, token []byte, err error) {\n+\tfor i := 0; i < len(data); i++ {\n+\t\tif data[i] == ',' {\n+\t\t\treturn i + 1, data[:i], nil\n+\t\t}\n+\t}\n+\tif !atEOF {\n+\t\treturn 0, nil, nil\n+\t}\n+\treturn 0, data, nil\n+}\n+\n+func TestEmptyTokens(t *testing.T) {\n+\ts := NewScanner(strings.NewReader(\"1,2,3,\"))\n+\tvalues := []string{\"1\", \"2\", \"3\", \"\"}\n+\ts.Split(commaSplit)\n+\tvar i int\n+\tfor i = 0; i < len(values); i++ {\n+\t\tif !s.Scan() {\n+\t\t\tbreak\n+\t\t}\n+\t\tif s.Text() != values[i] {\n+\t\t\tt.Errorf(\"%d: expected %q got %q\", i, values[i], s.Text())\n+\t\t}\n+\t}\n+\tif i != len(values) {\n+\t\tt.Errorf(\"got %d fields, expected %d\", i, len(values))\n+\t}\n+\tif err := s.Err(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func loopAtEOFSplit(data []byte, atEOF bool) (advance int, token []byte, err error) {\n+\tif len(data) > 0 {\n+\t\treturn 1, data[:1], nil\n+\t}\n+\treturn 0, data, nil\n+}\n+\n+func TestDontLoopForever(t *testing.T) {\n+\ts := NewScanner(strings.NewReader(\"abc\"))\n+\ts.Split(loopAtEOFSplit)\n+\t// Expect a panic\n+\tdefer func() {\n+\t\terr := recover()\n+\t\tif err == nil {\n+\t\t\tt.Fatal(\"should have panicked\")\n+\t\t}\n+\t\tif msg, ok := err.(string); !ok || !strings.Contains(msg, \"empty tokens\") {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}()\n+\tfor count := 0; s.Scan(); count++ {\n+\t\tif count > 1000 {\n+\t\t\tt.Fatal(\"looping\")\n+\t\t}\n+\t}\n+\tif s.Err() != nil {\n+\t\tt.Fatal(\"after scan:\", s.Err())\n+\t}\n+}\n+\n+func TestBlankLines(t *testing.T) {\n+\ts := NewScanner(strings.NewReader(strings.Repeat(\"\\n\", 1000)))\n+\tfor count := 0; s.Scan(); count++ {\n+\t\tif count > 2000 {\n+\t\t\tt.Fatal(\"looping\")\n+\t\t}\n+\t}\n+\tif s.Err() != nil {\n+\t\tt.Fatal(\"after scan:\", s.Err())\n+\t}\n+}\n+\n+type countdown int\n+\n+func (c *countdown) split(data []byte, atEOF bool) (advance int, token []byte, err error) {\n+\tif *c > 0 {\n+\t\t*c--\n+\t\treturn 1, data[:1], nil\n+\t}\n+\treturn 0, nil, nil\n+}\n+\n+// Check that the looping-at-EOF check doesn't trigger for merely empty tokens.\n+func TestEmptyLinesOK(t *testing.T) {\n+\tc := countdown(10000)\n+\ts := NewScanner(strings.NewReader(strings.Repeat(\"\\n\", 10000)))\n+\ts.Split(c.split)\n+\tfor s.Scan() {\n+\t}\n+\tif s.Err() != nil {\n+\t\tt.Fatal(\"after scan:\", s.Err())\n+\t}\n+\tif c != 0 {\n+\t\tt.Fatalf(\"stopped with %d left to process\", c)\n+\t}\n+}"}, {"sha": "7634707b3cb6e65e4d66cd7a5f295c0d476683c0", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -267,6 +267,8 @@ func Fields(s []byte) [][]byte {\n // It splits the slice s at each run of code points c satisfying f(c) and\n // returns a slice of subslices of s.  If all code points in s satisfy f(c), or\n // len(s) == 0, an empty slice is returned.\n+// FieldsFunc makes no guarantees about the order in which it calls f(c).\n+// If f does not return consistent results for a given c, FieldsFunc may crash.\n func FieldsFunc(s []byte, f func(rune) bool) [][]byte {\n \tn := 0\n \tinField := false\n@@ -377,9 +379,10 @@ func Map(mapping func(r rune) rune, s []byte) []byte {\n // Repeat returns a new byte slice consisting of count copies of b.\n func Repeat(b []byte, count int) []byte {\n \tnb := make([]byte, len(b)*count)\n-\tbp := 0\n-\tfor i := 0; i < count; i++ {\n-\t\tbp += copy(nb[bp:], b)\n+\tbp := copy(nb, b)\n+\tfor bp < len(nb) {\n+\t\tcopy(nb[bp:], nb[:bp])\n+\t\tbp *= 2\n \t}\n \treturn nb\n }\n@@ -604,6 +607,9 @@ func Runes(s []byte) []rune {\n \n // Replace returns a copy of the slice s with the first n\n // non-overlapping instances of old replaced by new.\n+// If old is empty, it matches at the beginning of the slice\n+// and after each UTF-8 sequence, yielding up to k+1 replacements\n+// for a k-rune slice.\n // If n < 0, there is no limit on the number of replacements.\n func Replace(s, old, new []byte, n int) []byte {\n \tm := 0"}, {"sha": "980c41d754ddfbcbb135daa0adf98bb940848bc1", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1232,3 +1232,9 @@ func BenchmarkTrimSpace(b *testing.B) {\n \t\tTrimSpace(s)\n \t}\n }\n+\n+func BenchmarkRepeat(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tRepeat([]byte(\"-\"), 80)\n+\t}\n+}"}, {"sha": "10e2278a1d61e2f8f2b16e97e1756ca981c84724", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -272,7 +272,7 @@ func (f *File) walk(x interface{}, context string, visit func(*File, interface{}\n \n \tcase nil:\n \n-\t// These are ordered and grouped to match ../../pkg/go/ast/ast.go\n+\t// These are ordered and grouped to match ../../go/ast/ast.go\n \tcase *ast.Field:\n \t\tif len(n.Names) == 0 && context == \"field\" {\n \t\t\tf.walk(&n.Type, \"embed-type\", visit)\n@@ -308,6 +308,9 @@ func (f *File) walk(x interface{}, context string, visit func(*File, interface{}\n \t\tif n.High != nil {\n \t\t\tf.walk(&n.High, \"expr\", visit)\n \t\t}\n+\t\tif n.Max != nil {\n+\t\t\tf.walk(&n.Max, \"expr\", visit)\n+\t\t}\n \tcase *ast.TypeAssertExpr:\n \t\tf.walk(&n.X, \"expr\", visit)\n \t\tf.walk(&n.Type, \"type\", visit)"}, {"sha": "6179c7afd19eb1d587c5bedce46d5b375c64834b", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -152,7 +152,7 @@ In C, a function argument written as a fixed size array\n actually requires a pointer to the first element of the array.\n C compilers are aware of this calling convention and adjust\n the call accordingly, but Go cannot.  In Go, you must pass\n-the pointer to the first element explicitly: C.f(&x[0]).\n+the pointer to the first element explicitly: C.f(&C.x[0]).\n \n A few special functions convert between Go and C types\n by making copies of the data.  In pseudo-Go definitions:"}, {"sha": "abdd369d7139c1e522e3631505e64076bb80038d", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 106, "deletions": 81, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -229,7 +229,8 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t// Determine kinds for names we already know about,\n \t// like #defines or 'struct foo', before bothering with gcc.\n \tvar names, needType []*Name\n-\tfor _, n := range f.Name {\n+\tfor _, key := range nameKeys(f.Name) {\n+\t\tn := f.Name[key]\n \t\t// If we've already found this name as a #define\n \t\t// and we can translate it as a constant value, do so.\n \t\tif n.Define != \"\" {\n@@ -331,6 +332,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \tconst (\n \t\tnotType = 1 << iota\n \t\tnotConst\n+\t\tnotDeclared\n \t)\n \tfor _, line := range strings.Split(stderr, \"\\n\") {\n \t\tif !strings.Contains(line, \": error:\") {\n@@ -365,7 +367,7 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\tcompleted = true\n \n \t\tcase \"not-declared\":\n-\t\t\terror_(token.NoPos, \"%s\", strings.TrimSpace(line[c2+1:]))\n+\t\t\tsniff[i] |= notDeclared\n \t\tcase \"not-type\":\n \t\t\tsniff[i] |= notType\n \t\tcase \"not-const\":\n@@ -374,12 +376,12 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t}\n \n \tif !completed {\n-\t\tfatalf(\"%s did not produce error at completed:1\\non input:\\n%s\", p.gccBaseCmd()[0], b.Bytes())\n+\t\tfatalf(\"%s did not produce error at completed:1\\non input:\\n%s\\nfull error output:\\n%s\", p.gccBaseCmd()[0], b.Bytes(), stderr)\n \t}\n \n \tfor i, n := range names {\n \t\tswitch sniff[i] {\n-\t\tcase 0:\n+\t\tdefault:\n \t\t\terror_(token.NoPos, \"could not determine kind of name for C.%s\", fixGo(n.Go))\n \t\tcase notType:\n \t\t\tn.Kind = \"const\"\n@@ -390,6 +392,14 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t}\n \t}\n \tif nerrors > 0 {\n+\t\t// Check if compiling the preamble by itself causes any errors,\n+\t\t// because the messages we've printed out so far aren't helpful\n+\t\t// to users debugging preamble mistakes.  See issue 8442.\n+\t\tpreambleErrors := p.gccErrors([]byte(f.Preamble))\n+\t\tif len(preambleErrors) > 0 {\n+\t\t\terror_(token.NoPos, \"\\n%s errors for preamble:\\n%s\", p.gccBaseCmd()[0], preambleErrors)\n+\t\t}\n+\n \t\tfatalf(\"unresolved names\")\n \t}\n \n@@ -649,7 +659,13 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t\t\tf.Name[fpName] = name\n \t\t\t\t}\n \t\t\t\tr.Name = name\n-\t\t\t\texpr = ast.NewIdent(name.Mangle)\n+\t\t\t\t// Rewrite into call to _Cgo_ptr to prevent assignments.  The _Cgo_ptr\n+\t\t\t\t// function is defined in out.go and simply returns its argument. See\n+\t\t\t\t// issue 7757.\n+\t\t\t\texpr = &ast.CallExpr{\n+\t\t\t\t\tFun:  &ast.Ident{NamePos: (*r.Expr).Pos(), Name: \"_Cgo_ptr\"},\n+\t\t\t\t\tArgs: []ast.Expr{ast.NewIdent(name.Mangle)},\n+\t\t\t\t}\n \t\t\t} else if r.Name.Kind == \"type\" {\n \t\t\t\t// Okay - might be new(T)\n \t\t\t\texpr = r.Name.Type.Go\n@@ -928,9 +944,8 @@ type typeConv struct {\n \n \t// Map from types to incomplete pointers to those types.\n \tptrs map[dwarf.Type][]*Type\n-\n-\t// Fields to be processed by godefsField after completing pointers.\n-\ttodoFlds [][]*ast.Field\n+\t// Keys of ptrs in insertion order (deterministic worklist)\n+\tptrKeys []dwarf.Type\n \n \t// Predeclared types.\n \tbool                                   ast.Expr\n@@ -940,9 +955,9 @@ type typeConv struct {\n \tfloat32, float64                       ast.Expr\n \tcomplex64, complex128                  ast.Expr\n \tvoid                                   ast.Expr\n-\tunsafePointer                          ast.Expr\n \tstring                                 ast.Expr\n \tgoVoid                                 ast.Expr // _Ctype_void, denotes C's void\n+\tgoVoidPtr                              ast.Expr // unsafe.Pointer or *byte\n \n \tptrSize int64\n \tintSize int64\n@@ -972,10 +987,17 @@ func (c *typeConv) Init(ptrSize, intSize int64) {\n \tc.float64 = c.Ident(\"float64\")\n \tc.complex64 = c.Ident(\"complex64\")\n \tc.complex128 = c.Ident(\"complex128\")\n-\tc.unsafePointer = c.Ident(\"unsafe.Pointer\")\n \tc.void = c.Ident(\"void\")\n \tc.string = c.Ident(\"string\")\n \tc.goVoid = c.Ident(\"_Ctype_void\")\n+\n+\t// Normally cgo translates void* to unsafe.Pointer,\n+\t// but for historical reasons -cdefs and -godefs use *byte instead.\n+\tif *cdefs || *godefs {\n+\t\tc.goVoidPtr = &ast.StarExpr{X: c.byte}\n+\t} else {\n+\t\tc.goVoidPtr = c.Ident(\"unsafe.Pointer\")\n+\t}\n }\n \n // base strips away qualifiers and typedefs to get the underlying type\n@@ -1037,29 +1059,22 @@ func (tr *TypeRepr) Set(repr string, fargs ...interface{}) {\n }\n \n // FinishType completes any outstanding type mapping work.\n-// In particular, it resolves incomplete pointer types and also runs\n-// godefsFields on any new struct types.\n+// In particular, it resolves incomplete pointer types.\n func (c *typeConv) FinishType(pos token.Pos) {\n \t// Completing one pointer type might produce more to complete.\n \t// Keep looping until they're all done.\n-\tfor len(c.ptrs) > 0 {\n-\t\tfor dtype := range c.ptrs {\n-\t\t\t// Note Type might invalidate c.ptrs[dtype].\n-\t\t\tt := c.Type(dtype, pos)\n-\t\t\tfor _, ptr := range c.ptrs[dtype] {\n-\t\t\t\tptr.Go.(*ast.StarExpr).X = t.Go\n-\t\t\t\tptr.C.Set(\"%s*\", t.C)\n-\t\t\t}\n-\t\t\tdelete(c.ptrs, dtype)\n-\t\t}\n-\t}\n+\tfor len(c.ptrKeys) > 0 {\n+\t\tdtype := c.ptrKeys[0]\n+\t\tc.ptrKeys = c.ptrKeys[1:]\n \n-\t// Now that pointer types are completed, we can invoke godefsFields\n-\t// to rewrite struct definitions.\n-\tfor _, fld := range c.todoFlds {\n-\t\tgodefsFields(fld)\n+\t\t// Note Type might invalidate c.ptrs[dtype].\n+\t\tt := c.Type(dtype, pos)\n+\t\tfor _, ptr := range c.ptrs[dtype] {\n+\t\t\tptr.Go.(*ast.StarExpr).X = t.Go\n+\t\t\tptr.C.Set(\"%s*\", t.C)\n+\t\t}\n+\t\tc.ptrs[dtype] = nil // retain the map key\n \t}\n-\tc.todoFlds = nil\n }\n \n // Type returns a *Type with the same memory layout as\n@@ -1072,12 +1087,6 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\treturn t\n \t}\n \n-\t// clang won't generate DW_AT_byte_size for pointer types,\n-\t// so we have to fix it here.\n-\tif dt, ok := base(dtype).(*dwarf.PtrType); ok && dt.ByteSize == -1 {\n-\t\tdt.ByteSize = c.ptrSize\n-\t}\n-\n \tt := new(Type)\n \tt.Size = dtype.Size() // note: wrong for array of pointers, corrected below\n \tt.Align = -1\n@@ -1101,12 +1110,20 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\tt.Go = c.Opaque(t.Size)\n \t\t\tbreak\n \t\t}\n+\t\tcount := dt.Count\n+\t\tif count == -1 {\n+\t\t\t// Indicates flexible array member, which Go doesn't support.\n+\t\t\t// Translate to zero-length array instead.\n+\t\t\tcount = 0\n+\t\t}\n \t\tsub := c.Type(dt.Type, pos)\n \t\tt.Align = sub.Align\n \t\tt.Go = &ast.ArrayType{\n-\t\t\tLen: c.intExpr(dt.Count),\n+\t\t\tLen: c.intExpr(count),\n \t\t\tElt: sub.Go,\n \t\t}\n+\t\t// Recalculate t.Size now that we know sub.Size.\n+\t\tt.Size = count * sub.Size\n \t\tt.C.Set(\"__typeof__(%s[%d])\", sub.C, dt.Count)\n \n \tcase *dwarf.BoolType:\n@@ -1207,18 +1224,25 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t}\n \n \tcase *dwarf.PtrType:\n+\t\t// Clang doesn't emit DW_AT_byte_size for pointer types.\n+\t\tif t.Size != c.ptrSize && t.Size != -1 {\n+\t\t\tfatalf(\"%s: unexpected: %d-byte pointer type - %s\", lineno(pos), t.Size, dtype)\n+\t\t}\n+\t\tt.Size = c.ptrSize\n \t\tt.Align = c.ptrSize\n \n-\t\t// Translate void* as unsafe.Pointer\n \t\tif _, ok := base(dt.Type).(*dwarf.VoidType); ok {\n-\t\t\tt.Go = c.unsafePointer\n+\t\t\tt.Go = c.goVoidPtr\n \t\t\tt.C.Set(\"void*\")\n \t\t\tbreak\n \t\t}\n \n \t\t// Placeholder initialization; completed in FinishType.\n \t\tt.Go = &ast.StarExpr{}\n \t\tt.C.Set(\"<incomplete>*\")\n+\t\tif _, ok := c.ptrs[dt.Type]; !ok {\n+\t\t\tc.ptrKeys = append(c.ptrKeys, dt.Type)\n+\t\t}\n \t\tc.ptrs[dt.Type] = append(c.ptrs[dt.Type], t)\n \n \tcase *dwarf.QualType:\n@@ -1379,34 +1403,24 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t}\n \t}\n \n-\tif t.Size <= 0 {\n-\t\t// Clang does not record the size of a pointer in its DWARF entry,\n-\t\t// so if dtype is an array, the call to dtype.Size at the top of the function\n-\t\t// computed the size as the array length * 0 = 0.\n-\t\t// The type switch called Type (this function) recursively on the pointer\n-\t\t// entry, and the code near the top of the function updated the size to\n-\t\t// be correct, so calling dtype.Size again will produce the correct value.\n-\t\tt.Size = dtype.Size()\n-\t\tif t.Size < 0 {\n-\t\t\t// Unsized types are [0]byte, unless they're typedefs of other types\n-\t\t\t// or structs with tags.\n-\t\t\t// if so, use the name we've already defined.\n-\t\t\tt.Size = 0\n-\t\t\tswitch dt := dtype.(type) {\n-\t\t\tcase *dwarf.TypedefType:\n-\t\t\t\t// ok\n-\t\t\tcase *dwarf.StructType:\n-\t\t\t\tif dt.StructName != \"\" {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tt.Go = c.Opaque(0)\n-\t\t\tdefault:\n-\t\t\t\tt.Go = c.Opaque(0)\n-\t\t\t}\n-\t\t\tif t.C.Empty() {\n-\t\t\t\tt.C.Set(\"void\")\n+\tif t.Size < 0 {\n+\t\t// Unsized types are [0]byte, unless they're typedefs of other types\n+\t\t// or structs with tags.\n+\t\t// if so, use the name we've already defined.\n+\t\tt.Size = 0\n+\t\tswitch dt := dtype.(type) {\n+\t\tcase *dwarf.TypedefType:\n+\t\t\t// ok\n+\t\tcase *dwarf.StructType:\n+\t\t\tif dt.StructName != \"\" {\n+\t\t\t\tbreak\n \t\t\t}\n-\t\t\treturn t\n+\t\t\tt.Go = c.Opaque(0)\n+\t\tdefault:\n+\t\t\tt.Go = c.Opaque(0)\n+\t\t}\n+\t\tif t.C.Empty() {\n+\t\t\tt.C.Set(\"void\")\n \t\t}\n \t}\n \n@@ -1538,6 +1552,9 @@ func (c *typeConv) pad(fld []*ast.Field, size int64) []*ast.Field {\n \n // Struct conversion: return Go and (6g) C syntax for type.\n func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.StructType, csyntax string, align int64) {\n+\t// Minimum alignment for a struct is 1 byte.\n+\talign = 1\n+\n \tvar buf bytes.Buffer\n \tbuf.WriteString(\"struct {\")\n \tfld := make([]*ast.Field, 0, 2*len(dt.Field)+1) // enough for padding around every field\n@@ -1579,7 +1596,27 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\t\tfld = c.pad(fld, f.ByteOffset-off)\n \t\t\toff = f.ByteOffset\n \t\t}\n-\t\tt := c.Type(f.Type, pos)\n+\n+\t\tname := f.Name\n+\t\tft := f.Type\n+\n+\t\t// In godefs or cdefs mode, if this field is a C11\n+\t\t// anonymous union then treat the first field in the\n+\t\t// union as the field in the struct.  This handles\n+\t\t// cases like the glibc <sys/resource.h> file; see\n+\t\t// issue 6677.\n+\t\tif *godefs || *cdefs {\n+\t\t\tif st, ok := f.Type.(*dwarf.StructType); ok && name == \"\" && st.Kind == \"union\" && len(st.Field) > 0 && !used[st.Field[0].Name] {\n+\t\t\t\tname = st.Field[0].Name\n+\t\t\t\tident[name] = name\n+\t\t\t\tft = st.Field[0].Type\n+\t\t\t}\n+\t\t}\n+\n+\t\t// TODO: Handle fields that are anonymous structs by\n+\t\t// promoting the fields of the inner struct.\n+\n+\t\tt := c.Type(ft, pos)\n \t\ttgo := t.Go\n \t\tsize := t.Size\n \t\ttalign := t.Align\n@@ -1598,17 +1635,18 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\t\ttalign = size\n \t\t}\n \n-\t\tif talign > 0 && f.ByteOffset%talign != 0 {\n+\t\tif talign > 0 && f.ByteOffset%talign != 0 && !*cdefs {\n \t\t\t// Drop misaligned fields, the same way we drop integer bit fields.\n \t\t\t// The goal is to make available what can be made available.\n \t\t\t// Otherwise one bad and unneeded field in an otherwise okay struct\n \t\t\t// makes the whole program not compile. Much of the time these\n \t\t\t// structs are in system headers that cannot be corrected.\n+\t\t\t// Exception: In -cdefs mode, we use #pragma pack, so misaligned\n+\t\t\t// fields should still work.\n \t\t\tcontinue\n \t\t}\n \t\tn := len(fld)\n \t\tfld = fld[0 : n+1]\n-\t\tname := f.Name\n \t\tif name == \"\" {\n \t\t\tname = fmt.Sprintf(\"anon%d\", anon)\n \t\t\tanon++\n@@ -1635,7 +1673,7 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \tcsyntax = buf.String()\n \n \tif *godefs || *cdefs {\n-\t\tc.todoFlds = append(c.todoFlds, fld)\n+\t\tgodefsFields(fld)\n \t}\n \texpr = &ast.StructType{Fields: &ast.FieldList{List: fld}}\n \treturn\n@@ -1673,19 +1711,6 @@ func godefsFields(fld []*ast.Field) {\n \t\t\t\tn.Name = upper(n.Name)\n \t\t\t}\n \t\t}\n-\t\tp := &f.Type\n-\t\tt := *p\n-\t\tif star, ok := t.(*ast.StarExpr); ok {\n-\t\t\tstar = &ast.StarExpr{X: star.X}\n-\t\t\t*p = star\n-\t\t\tp = &star.X\n-\t\t\tt = *p\n-\t\t}\n-\t\tif id, ok := t.(*ast.Ident); ok {\n-\t\t\tif id.Name == \"unsafe.Pointer\" {\n-\t\t\t\t*p = ast.NewIdent(\"*byte\")\n-\t\t\t}\n-\t\t}\n \t}\n }\n "}, {"sha": "d92bed9bf014ca9268eb8d970a08c193bd911031", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 139, "deletions": 104, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -44,6 +44,7 @@ func (p *Package) writeDefs() {\n \tfmt.Fprintf(fm, \"int main() { return 0; }\\n\")\n \tif *importRuntimeCgo {\n \t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int), void *a, int c) { }\\n\")\n+\t\tfmt.Fprintf(fm, \"char* _cgo_topofstack(void) { return (char*)0; }\\n\")\n \t} else {\n \t\t// If we're not importing runtime/cgo, we *are* runtime/cgo,\n \t\t// which provides crosscall2.  We just need a prototype.\n@@ -58,16 +59,14 @@ func (p *Package) writeDefs() {\n \tfmt.Fprintf(fgo2, \"// Created by cgo - DO NOT EDIT\\n\\n\")\n \tfmt.Fprintf(fgo2, \"package %s\\n\\n\", p.PackageName)\n \tfmt.Fprintf(fgo2, \"import \\\"unsafe\\\"\\n\\n\")\n-\tif *importSyscall {\n-\t\tfmt.Fprintf(fgo2, \"import \\\"syscall\\\"\\n\\n\")\n-\t}\n \tif !*gccgo && *importRuntimeCgo {\n \t\tfmt.Fprintf(fgo2, \"import _ \\\"runtime/cgo\\\"\\n\\n\")\n \t}\n-\tfmt.Fprintf(fgo2, \"type _ unsafe.Pointer\\n\\n\")\n \tif *importSyscall {\n-\t\tfmt.Fprintf(fgo2, \"func _Cerrno(dst *error, x int32) { *dst = syscall.Errno(x) }\\n\")\n+\t\tfmt.Fprintf(fgo2, \"import \\\"syscall\\\"\\n\\n\")\n+\t\tfmt.Fprintf(fgo2, \"var _ syscall.Errno\\n\")\n \t}\n+\tfmt.Fprintf(fgo2, \"func _Cgo_ptr(ptr unsafe.Pointer) unsafe.Pointer { return ptr }\\n\\n\")\n \n \ttypedefNames := make([]string, 0, len(typedef))\n \tfor name := range typedef {\n@@ -87,9 +86,10 @@ func (p *Package) writeDefs() {\n \t}\n \n \tif *gccgo {\n-\t\tfmt.Fprintf(fc, p.cPrologGccgo())\n+\t\tfmt.Fprint(fc, p.cPrologGccgo())\n \t} else {\n-\t\tfmt.Fprintf(fc, cProlog)\n+\t\tfmt.Fprint(fc, cProlog)\n+\t\tfmt.Fprint(fgo2, goProlog)\n \t}\n \n \tgccgoSymbolPrefix := p.gccgoSymbolPrefix()\n@@ -130,6 +130,7 @@ func (p *Package) writeDefs() {\n \t\t\tfmt.Fprintf(fc, `extern void *%s __asm__(\"%s.%s\");`, n.Mangle, gccgoSymbolPrefix, n.Mangle)\n \t\t\tfmt.Fprintf(&gccgoInit, \"\\t%s = %s%s;\\n\", n.Mangle, amp, n.C)\n \t\t} else {\n+\t\t\tfmt.Fprintf(fc, \"#pragma dataflag NOPTR /* C pointer, not heap pointer */ \\n\")\n \t\t\tfmt.Fprintf(fc, \"void *\u00b7%s = %s%s;\\n\", n.Mangle, amp, n.C)\n \t\t}\n \t\tfmt.Fprintf(fc, \"\\n\")\n@@ -296,10 +297,6 @@ func (p *Package) structType(n *Name) (string, int64) {\n \t\tfmt.Fprintf(&buf, \"\\t\\tchar __pad%d[%d];\\n\", off, pad)\n \t\toff += pad\n \t}\n-\tif n.AddError {\n-\t\tfmt.Fprint(&buf, \"\\t\\tint e[2*sizeof(void *)/sizeof(int)]; /* error */\\n\")\n-\t\toff += 2 * p.PtrSize\n-\t}\n \tif off == 0 {\n \t\tfmt.Fprintf(&buf, \"\\t\\tchar unused;\\n\") // avoid empty struct\n \t}\n@@ -334,19 +331,18 @@ func (p *Package) writeDefsFunc(fc, fgo2 *os.File, n *Name) {\n \t}\n \n \t// Builtins defined in the C prolog.\n-\tinProlog := name == \"CString\" || name == \"GoString\" || name == \"GoStringN\" || name == \"GoBytes\" || name == \"_CMalloc\"\n+\tinProlog := builtinDefs[name] != \"\"\n+\tcname := fmt.Sprintf(\"_cgo%s%s\", cPrefix, n.Mangle)\n+\tparamnames := []string(nil)\n+\tfor i, param := range d.Type.Params.List {\n+\t\tparamName := fmt.Sprintf(\"p%d\", i)\n+\t\tparam.Names = []*ast.Ident{ast.NewIdent(paramName)}\n+\t\tparamnames = append(paramnames, paramName)\n+\t}\n \n \tif *gccgo {\n \t\t// Gccgo style hooks.\n \t\tfmt.Fprint(fgo2, \"\\n\")\n-\t\tcname := fmt.Sprintf(\"_cgo%s%s\", cPrefix, n.Mangle)\n-\t\tparamnames := []string(nil)\n-\t\tfor i, param := range d.Type.Params.List {\n-\t\t\tparamName := fmt.Sprintf(\"p%d\", i)\n-\t\t\tparam.Names = []*ast.Ident{ast.NewIdent(paramName)}\n-\t\t\tparamnames = append(paramnames, paramName)\n-\t\t}\n-\n \t\tconf.Fprint(fgo2, fset, d)\n \t\tfmt.Fprint(fgo2, \" {\\n\")\n \t\tif !inProlog {\n@@ -383,7 +379,7 @@ func (p *Package) writeDefsFunc(fc, fgo2 *os.File, n *Name) {\n \t\tfmt.Fprint(fgo2, \"}\\n\")\n \n \t\t// declare the C function.\n-\t\tfmt.Fprintf(fgo2, \"//extern _cgo%s%s\\n\", cPrefix, n.Mangle)\n+\t\tfmt.Fprintf(fgo2, \"//extern %s\\n\", cname)\n \t\td.Name = ast.NewIdent(cname)\n \t\tif n.AddError {\n \t\t\tl := d.Type.Results.List\n@@ -394,61 +390,50 @@ func (p *Package) writeDefsFunc(fc, fgo2 *os.File, n *Name) {\n \n \t\treturn\n \t}\n-\tconf.Fprint(fgo2, fset, d)\n-\tfmt.Fprint(fgo2, \"\\n\")\n \n \tif inProlog {\n+\t\tfmt.Fprint(fgo2, builtinDefs[name])\n \t\treturn\n \t}\n \n-\tvar argSize int64\n-\t_, argSize = p.structType(n)\n-\n \t// C wrapper calls into gcc, passing a pointer to the argument frame.\n-\tfmt.Fprintf(fc, \"#pragma cgo_import_static _cgo%s%s\\n\", cPrefix, n.Mangle)\n-\tfmt.Fprintf(fc, \"void _cgo%s%s(void*);\\n\", cPrefix, n.Mangle)\n-\tfmt.Fprintf(fc, \"\\n\")\n-\tfmt.Fprintf(fc, \"void\\n\")\n-\tif argSize == 0 {\n-\t\targSize++\n+\tfmt.Fprintf(fc, \"#pragma cgo_import_static %s\\n\", cname)\n+\tfmt.Fprintf(fc, \"void %s(void*);\\n\", cname)\n+\tfmt.Fprintf(fc, \"#pragma dataflag NOPTR\\n\")\n+\tfmt.Fprintf(fc, \"void *\u00b7%s = %s;\\n\", cname, cname)\n+\n+\tnret := 0\n+\tif !void {\n+\t\td.Type.Results.List[0].Names = []*ast.Ident{ast.NewIdent(\"r1\")}\n+\t\tnret = 1\n \t}\n-\t// TODO(rsc): The struct here should declare pointers only where\n-\t// there are pointers in the actual argument frame.\n-\t// This is a workaround for golang.org/issue/6397.\n-\tfmt.Fprintf(fc, \"\u00b7%s(struct{\", n.Mangle)\n-\tif n := argSize / p.PtrSize; n > 0 {\n-\t\tfmt.Fprintf(fc, \"void *y[%d];\", n)\n+\tif n.AddError {\n+\t\td.Type.Results.List[nret].Names = []*ast.Ident{ast.NewIdent(\"r2\")}\n \t}\n-\tif n := argSize % p.PtrSize; n > 0 {\n-\t\tfmt.Fprintf(fc, \"uint8 x[%d];\", n)\n+\n+\tfmt.Fprint(fgo2, \"\\n\")\n+\tfmt.Fprintf(fgo2, \"var %s unsafe.Pointer\\n\", cname)\n+\tconf.Fprint(fgo2, fset, d)\n+\tfmt.Fprint(fgo2, \" {\\n\")\n+\n+\t// NOTE: Using uintptr to hide from escape analysis.\n+\targ := \"0\"\n+\tif len(paramnames) > 0 {\n+\t\targ = \"uintptr(unsafe.Pointer(&p0))\"\n+\t} else if !void {\n+\t\targ = \"uintptr(unsafe.Pointer(&r1))\"\n \t}\n-\tfmt.Fprintf(fc, \"}p)\\n\")\n-\tfmt.Fprintf(fc, \"{\\n\")\n-\tfmt.Fprintf(fc, \"\\truntime\u00b7cgocall(_cgo%s%s, &p);\\n\", cPrefix, n.Mangle)\n+\n+\tprefix := \"\"\n \tif n.AddError {\n-\t\t// gcc leaves errno in first word of interface at end of p.\n-\t\t// check whether it is zero; if so, turn interface into nil.\n-\t\t// if not, turn interface into errno.\n-\t\t// Go init function initializes \u00b7_Cerrno with an os.Errno\n-\t\t// for us to copy.\n-\t\tfmt.Fprintln(fc, `\t{\n-\t\t\tint32 e;\n-\t\t\tvoid **v;\n-\t\t\tv = (void**)(&p+1) - 2;\t/* v = final two void* of p */\n-\t\t\te = *(int32*)v;\n-\t\t\tv[0] = (void*)0xdeadbeef;\n-\t\t\tv[1] = (void*)0xdeadbeef;\n-\t\t\tif(e == 0) {\n-\t\t\t\t/* nil interface */\n-\t\t\t\tv[0] = 0;\n-\t\t\t\tv[1] = 0;\n-\t\t\t} else {\n-\t\t\t\t\u00b7_Cerrno(v, e);\t/* fill in v as error for errno e */\n-\t\t\t}\n-\t\t}`)\n+\t\tprefix = \"errno := \"\n \t}\n-\tfmt.Fprintf(fc, \"}\\n\")\n-\tfmt.Fprintf(fc, \"\\n\")\n+\tfmt.Fprintf(fgo2, \"\\t%s_cgo_runtime_cgocall_errno(%s, %s)\\n\", prefix, cname, arg)\n+\tif n.AddError {\n+\t\tfmt.Fprintf(fgo2, \"\\tif errno != 0 { r2 = syscall.Errno(errno) }\\n\")\n+\t}\n+\tfmt.Fprintf(fgo2, \"\\treturn\\n\")\n+\tfmt.Fprintf(fgo2, \"}\\n\")\n }\n \n // writeOutput creates stubs for a specific source file to be compiled by 6g\n@@ -521,7 +506,11 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \n \t// Gcc wrapper unpacks the C argument struct\n \t// and calls the actual C function.\n-\tfmt.Fprintf(fgcc, \"void\\n\")\n+\tif n.AddError {\n+\t\tfmt.Fprintf(fgcc, \"int\\n\")\n+\t} else {\n+\t\tfmt.Fprintf(fgcc, \"void\\n\")\n+\t}\n \tfmt.Fprintf(fgcc, \"_cgo%s%s(void *v)\\n\", cPrefix, n.Mangle)\n \tfmt.Fprintf(fgcc, \"{\\n\")\n \tif n.AddError {\n@@ -531,9 +520,13 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t// Use packed attribute to force no padding in this struct in case\n \t// gcc has different packing requirements.\n \tfmt.Fprintf(fgcc, \"\\t%s %v *a = v;\\n\", ctype, p.packedAttribute())\n+\tif n.FuncType.Result != nil {\n+\t\t// Save the stack top for use below.\n+\t\tfmt.Fprintf(fgcc, \"\\tchar *stktop = _cgo_topofstack();\\n\")\n+\t}\n \tfmt.Fprintf(fgcc, \"\\t\")\n \tif t := n.FuncType.Result; t != nil {\n-\t\tfmt.Fprintf(fgcc, \"a->r = \")\n+\t\tfmt.Fprintf(fgcc, \"__typeof__(a->r) r = \")\n \t\tif c := t.C.String(); c[len(c)-1] == '*' {\n \t\t\tfmt.Fprint(fgcc, \"(__typeof__(a->r)) \")\n \t\t}\n@@ -556,8 +549,15 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t\tfmt.Fprintf(fgcc, \"a->p%d\", i)\n \t}\n \tfmt.Fprintf(fgcc, \");\\n\")\n+\tif n.FuncType.Result != nil {\n+\t\t// The cgo call may have caused a stack copy (via a callback).\n+\t\t// Adjust the return value pointer appropriately.\n+\t\tfmt.Fprintf(fgcc, \"\\ta = (void*)((char*)a + (_cgo_topofstack() - stktop));\\n\")\n+\t\t// Save the return value.\n+\t\tfmt.Fprintf(fgcc, \"\\ta->r = r;\\n\")\n+\t}\n \tif n.AddError {\n-\t\tfmt.Fprintf(fgcc, \"\\t*(int*)(a->e) = errno;\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\treturn errno;\\n\")\n \t}\n \tfmt.Fprintf(fgcc, \"}\\n\")\n \tfmt.Fprintf(fgcc, \"\\n\")\n@@ -1016,7 +1016,7 @@ func forFieldList(fl *ast.FieldList, fn func(int, ast.Expr)) {\n \t\t\tfn(i, r.Type)\n \t\t\ti++\n \t\t} else {\n-\t\t\tfor _ = range r.Names {\n+\t\t\tfor range r.Names {\n \t\t\t\tfn(i, r.Type)\n \t\t\t\ti++\n \t\t\t}\n@@ -1143,21 +1143,17 @@ __cgo_size_assert(__cgo_long_long, 8)\n __cgo_size_assert(float, 4)\n __cgo_size_assert(double, 8)\n \n+extern char* _cgo_topofstack(void);\n+\n #include <errno.h>\n #include <string.h>\n `\n \n const builtinProlog = `\n-#include <sys/types.h> /* for size_t below */\n+#include <stddef.h> /* for ptrdiff_t and size_t below */\n \n /* Define intgo when compiling with GCC.  */\n-#ifdef __PTRDIFF_TYPE__\n-typedef __PTRDIFF_TYPE__ intgo;\n-#elif defined(_LP64)\n-typedef long long intgo;\n-#else\n-typedef int intgo;\n-#endif\n+typedef ptrdiff_t intgo;\n \n typedef struct { char *p; intgo n; } _GoString_;\n typedef struct { char *p; intgo n; intgo c; } _GoBytes_;\n@@ -1171,47 +1167,86 @@ void *_CMalloc(size_t);\n const cProlog = `\n #include \"runtime.h\"\n #include \"cgocall.h\"\n+#include \"textflag.h\"\n+\n+#pragma dataflag NOPTR\n+static void *cgocall_errno = runtime\u00b7cgocall_errno;\n+#pragma dataflag NOPTR\n+void *\u00b7_cgo_runtime_cgocall_errno = &cgocall_errno;\n+\n+#pragma dataflag NOPTR\n+static void *runtime_gostring = runtime\u00b7gostring;\n+#pragma dataflag NOPTR\n+void *\u00b7_cgo_runtime_gostring = &runtime_gostring;\n+\n+#pragma dataflag NOPTR\n+static void *runtime_gostringn = runtime\u00b7gostringn;\n+#pragma dataflag NOPTR\n+void *\u00b7_cgo_runtime_gostringn = &runtime_gostringn;\n+\n+#pragma dataflag NOPTR\n+static void *runtime_gobytes = runtime\u00b7gobytes;\n+#pragma dataflag NOPTR\n+void *\u00b7_cgo_runtime_gobytes = &runtime_gobytes;\n+\n+#pragma dataflag NOPTR\n+static void *runtime_cmalloc = runtime\u00b7cmalloc;\n+#pragma dataflag NOPTR\n+void *\u00b7_cgo_runtime_cmalloc = &runtime_cmalloc;\n \n void \u00b7_Cerrno(void*, int32);\n+`\n \n-void\n-\u00b7_Cfunc_GoString(int8 *p, String s)\n-{\n-\ts = runtime\u00b7gostring((byte*)p);\n-\tFLUSH(&s);\n+const goProlog = `\n+var _cgo_runtime_cgocall_errno func(unsafe.Pointer, uintptr) int32\n+var _cgo_runtime_cmalloc func(uintptr) unsafe.Pointer\n+`\n+\n+const goStringDef = `\n+var _cgo_runtime_gostring func(*_Ctype_char) string\n+func _Cfunc_GoString(p *_Ctype_char) string {\n+\treturn _cgo_runtime_gostring(p)\n }\n+`\n \n-void\n-\u00b7_Cfunc_GoStringN(int8 *p, int32 l, String s)\n-{\n-\ts = runtime\u00b7gostringn((byte*)p, l);\n-\tFLUSH(&s);\n+const goStringNDef = `\n+var _cgo_runtime_gostringn func(*_Ctype_char, int) string\n+func _Cfunc_GoStringN(p *_Ctype_char, l _Ctype_int) string {\n+\treturn _cgo_runtime_gostringn(p, int(l))\n }\n+`\n \n-void\n-\u00b7_Cfunc_GoBytes(int8 *p, int32 l, Slice s)\n-{\n-\ts = runtime\u00b7gobytes((byte*)p, l);\n-\tFLUSH(&s);\n+const goBytesDef = `\n+var _cgo_runtime_gobytes func(unsafe.Pointer, int) []byte\n+func _Cfunc_GoBytes(p unsafe.Pointer, l _Ctype_int) []byte {\n+\treturn _cgo_runtime_gobytes(p, int(l))\n }\n+`\n \n-void\n-\u00b7_Cfunc_CString(String s, int8 *p)\n-{\n-\tp = runtime\u00b7cmalloc(s.len+1);\n-\truntime\u00b7memmove((byte*)p, s.str, s.len);\n-\tp[s.len] = 0;\n-\tFLUSH(&p);\n+const cStringDef = `\n+func _Cfunc_CString(s string) *_Ctype_char {\n+\tp := _cgo_runtime_cmalloc(uintptr(len(s)+1))\n+\tpp := (*[1<<30]byte)(p)\n+\tcopy(pp[:], s)\n+\tpp[len(s)] = 0\n+\treturn (*_Ctype_char)(p)\n }\n+`\n \n-void\n-\u00b7_Cfunc__CMalloc(uintptr n, int8 *p)\n-{\n-\tp = runtime\u00b7cmalloc(n);\n-\tFLUSH(&p);\n+const cMallocDef = `\n+func _Cfunc__CMalloc(n _Ctype_size_t) unsafe.Pointer {\n+\treturn _cgo_runtime_cmalloc(uintptr(n))\n }\n `\n \n+var builtinDefs = map[string]string{\n+\t\"GoString\":  goStringDef,\n+\t\"GoStringN\": goStringNDef,\n+\t\"GoBytes\":   goBytesDef,\n+\t\"CString\":   cStringDef,\n+\t\"_CMalloc\":  cMallocDef,\n+}\n+\n func (p *Package) cPrologGccgo() string {\n \treturn strings.Replace(cPrologGccgo, \"PREFIX\", cPrefix, -1)\n }"}, {"sha": "95b9804d3de3d1dbffbf5006cfc38a5f12409f2d", "filename": "libgo/go/cmd/go/build.go", "status": "modified", "additions": 145, "deletions": 65, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -57,14 +57,15 @@ and test commands:\n \n \t-a\n \t\tforce rebuilding of packages that are already up-to-date.\n+\t\tIn Go releases, does not apply to the standard library.\n \t-n\n \t\tprint the commands but do not run them.\n \t-p n\n \t\tthe number of builds that can be run in parallel.\n \t\tThe default is the number of CPUs available.\n \t-race\n \t\tenable data race detection.\n-\t\tSupported only on linux/amd64, darwin/amd64 and windows/amd64.\n+\t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n \t-v\n \t\tprint the names of packages as they are compiled.\n \t-work\n@@ -291,23 +292,26 @@ func runBuild(cmd *Command, args []string) {\n \t\t}\n \t}\n \n+\tdepMode := modeBuild\n+\tif buildI {\n+\t\tdepMode = modeInstall\n+\t}\n+\n \tif *buildO != \"\" {\n \t\tif len(pkgs) > 1 {\n \t\t\tfatalf(\"go build: cannot use -o with multiple packages\")\n+\t\t} else if len(pkgs) == 0 {\n+\t\t\tfatalf(\"no packages to build\")\n \t\t}\n \t\tp := pkgs[0]\n \t\tp.target = \"\" // must build - not up to date\n-\t\ta := b.action(modeInstall, modeBuild, p)\n+\t\ta := b.action(modeInstall, depMode, p)\n \t\ta.target = *buildO\n \t\tb.do(a)\n \t\treturn\n \t}\n \n \ta := &action{}\n-\tdepMode := modeBuild\n-\tif buildI {\n-\t\tdepMode = modeInstall\n-\t}\n \tfor _, p := range packages(args) {\n \t\ta.deps = append(a.deps, b.action(modeBuild, depMode, p))\n \t}\n@@ -438,12 +442,11 @@ const (\n )\n \n var (\n-\tgoroot       = filepath.Clean(runtime.GOROOT())\n-\tgobin        = os.Getenv(\"GOBIN\")\n-\tgorootBin    = filepath.Join(goroot, \"bin\")\n-\tgorootSrcPkg = filepath.Join(goroot, \"src/pkg\")\n-\tgorootPkg    = filepath.Join(goroot, \"pkg\")\n-\tgorootSrc    = filepath.Join(goroot, \"src\")\n+\tgoroot    = filepath.Clean(runtime.GOROOT())\n+\tgobin     = os.Getenv(\"GOBIN\")\n+\tgorootBin = filepath.Join(goroot, \"bin\")\n+\tgorootPkg = filepath.Join(goroot, \"pkg\")\n+\tgorootSrc = filepath.Join(goroot, \"src\")\n )\n \n func (b *builder) init() {\n@@ -510,8 +513,13 @@ func goFilesPackage(gofiles []string) *Package {\n \t}\n \tctxt.ReadDir = func(string) ([]os.FileInfo, error) { return dirent, nil }\n \n-\tif !filepath.IsAbs(dir) {\n-\t\tdir = filepath.Join(cwd, dir)\n+\tvar err error\n+\tif dir == \"\" {\n+\t\tdir = cwd\n+\t}\n+\tdir, err = filepath.Abs(dir)\n+\tif err != nil {\n+\t\tfatalf(\"%s\", err)\n \t}\n \n \tbp, err := ctxt.ImportDir(dir, 0)\n@@ -833,12 +841,17 @@ func (b *builder) build(a *action) (err error) {\n \t\t}\n \t}\n \n-\tvar gofiles, cfiles, sfiles, objects, cgoObjects []string\n+\tvar gofiles, cfiles, sfiles, objects, cgoObjects, pcCFLAGS, pcLDFLAGS []string\n \n \tgofiles = append(gofiles, a.p.GoFiles...)\n \tcfiles = append(cfiles, a.p.CFiles...)\n \tsfiles = append(sfiles, a.p.SFiles...)\n \n+\tif a.p.usesCgo() || a.p.usesSwig() {\n+\t\tif pcCFLAGS, pcLDFLAGS, err = b.getPkgConfigFlags(a.p); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n \t// Run cgo.\n \tif a.p.usesCgo() {\n \t\t// In a package using cgo, cgo compiles the C, C++ and assembly files with gcc.\n@@ -869,7 +882,7 @@ func (b *builder) build(a *action) (err error) {\n \t\tif a.cgo != nil && a.cgo.target != \"\" {\n \t\t\tcgoExe = a.cgo.target\n \t\t}\n-\t\toutGo, outObj, err := b.cgo(a.p, cgoExe, obj, gccfiles, a.p.CXXFiles, a.p.MFiles)\n+\t\toutGo, outObj, err := b.cgo(a.p, cgoExe, obj, pcCFLAGS, pcLDFLAGS, gccfiles, a.p.CXXFiles, a.p.MFiles)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -882,9 +895,18 @@ func (b *builder) build(a *action) (err error) {\n \t\t// In a package using SWIG, any .c or .s files are\n \t\t// compiled with gcc.\n \t\tgccfiles := append(cfiles, sfiles...)\n+\t\tcxxfiles, mfiles := a.p.CXXFiles, a.p.MFiles\n \t\tcfiles = nil\n \t\tsfiles = nil\n-\t\toutGo, outObj, err := b.swig(a.p, obj, gccfiles, a.p.CXXFiles, a.p.MFiles)\n+\n+\t\t// Don't build c/c++ files twice if cgo is enabled (mainly for pkg-config).\n+\t\tif a.p.usesCgo() {\n+\t\t\tcxxfiles = nil\n+\t\t\tgccfiles = nil\n+\t\t\tmfiles = nil\n+\t\t}\n+\n+\t\toutGo, outObj, err := b.swig(a.p, obj, pcCFLAGS, gccfiles, cxxfiles, mfiles)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -893,7 +915,7 @@ func (b *builder) build(a *action) (err error) {\n \t}\n \n \tif len(gofiles) == 0 {\n-\t\treturn &build.NoGoError{a.p.Dir}\n+\t\treturn &build.NoGoError{Dir: a.p.Dir}\n \t}\n \n \t// If we're doing coverage, preprocess the .go files and put them in the work directory\n@@ -1028,6 +1050,34 @@ func (b *builder) build(a *action) (err error) {\n \treturn nil\n }\n \n+// Calls pkg-config if needed and returns the cflags/ldflags needed to build the package.\n+func (b *builder) getPkgConfigFlags(p *Package) (cflags, ldflags []string, err error) {\n+\tif pkgs := p.CgoPkgConfig; len(pkgs) > 0 {\n+\t\tvar out []byte\n+\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, \"pkg-config\", \"--cflags\", pkgs)\n+\t\tif err != nil {\n+\t\t\tb.showOutput(p.Dir, \"pkg-config --cflags \"+strings.Join(pkgs, \" \"), string(out))\n+\t\t\tb.print(err.Error() + \"\\n\")\n+\t\t\terr = errPrintedOutput\n+\t\t\treturn\n+\t\t}\n+\t\tif len(out) > 0 {\n+\t\t\tcflags = strings.Fields(string(out))\n+\t\t}\n+\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, \"pkg-config\", \"--libs\", pkgs)\n+\t\tif err != nil {\n+\t\t\tb.showOutput(p.Dir, \"pkg-config --libs \"+strings.Join(pkgs, \" \"), string(out))\n+\t\t\tb.print(err.Error() + \"\\n\")\n+\t\t\terr = errPrintedOutput\n+\t\t\treturn\n+\t\t}\n+\t\tif len(out) > 0 {\n+\t\t\tldflags = strings.Fields(string(out))\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n // install is the action for installing a single package or executable.\n func (b *builder) install(a *action) (err error) {\n \tdefer func() {\n@@ -1263,7 +1313,7 @@ func (b *builder) showcmd(dir string, format string, args ...interface{}) {\n // the source directory for the package that has failed to build.\n // showOutput rewrites mentions of dir with a relative path to dir\n // when the relative path is shorter.  This is usually more pleasant.\n-// For example, if fmt doesn't compile and we are in src/pkg/html,\n+// For example, if fmt doesn't compile and we are in src/html,\n // the output is\n //\n //\t$ go build\n@@ -1275,7 +1325,7 @@ func (b *builder) showcmd(dir string, format string, args ...interface{}) {\n //\n //\t$ go build\n //\t# fmt\n-//\t/usr/gopher/go/src/pkg/fmt/print.go:1090: undefined: asdf\n+//\t/usr/gopher/go/src/fmt/print.go:1090: undefined: asdf\n //\t$\n //\n // showOutput also replaces references to the work directory with $WORK.\n@@ -1435,6 +1485,14 @@ func (b *builder) runOut(dir string, desc string, env []string, cmdargs ...inter\n \t\t\tcontinue\n \t\t}\n \n+\t\t// err can be something like 'exit status 1'.\n+\t\t// Add information about what program was running.\n+\t\t// Note that if buf.Bytes() is non-empty, the caller usually\n+\t\t// shows buf.Bytes() and does not print err at all, so the\n+\t\t// prefix here does not make most output any more verbose.\n+\t\tif err != nil {\n+\t\t\terr = errors.New(cmdline[0] + \": \" + err.Error())\n+\t\t}\n \t\treturn buf.Bytes(), err\n \t}\n }\n@@ -1597,7 +1655,7 @@ func (gcToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []\n \textFiles := len(p.CgoFiles) + len(p.CFiles) + len(p.CXXFiles) + len(p.MFiles) + len(p.SFiles) + len(p.SysoFiles) + len(p.SwigFiles) + len(p.SwigCXXFiles)\n \tif p.Standard {\n \t\tswitch p.ImportPath {\n-\t\tcase \"os\", \"runtime/pprof\", \"sync\", \"time\":\n+\t\tcase \"bytes\", \"net\", \"os\", \"runtime/pprof\", \"sync\", \"time\":\n \t\t\textFiles++\n \t\t}\n \t}\n@@ -1621,8 +1679,10 @@ func (gcToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []\n }\n \n func (gcToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n+\t// Add -I pkg/GOOS_GOARCH so #include \"textflag.h\" works in .s files.\n+\tinc := filepath.Join(goroot, \"pkg\", fmt.Sprintf(\"%s_%s\", goos, goarch))\n \tsfile = mkAbs(p.Dir, sfile)\n-\treturn b.run(p.Dir, p.ImportPath, nil, tool(archChar+\"a\"), \"-trimpath\", b.work, \"-I\", obj, \"-o\", ofile, \"-D\", \"GOOS_\"+goos, \"-D\", \"GOARCH_\"+goarch, sfile)\n+\treturn b.run(p.Dir, p.ImportPath, nil, tool(archChar+\"a\"), \"-trimpath\", b.work, \"-I\", obj, \"-I\", inc, \"-o\", ofile, \"-D\", \"GOOS_\"+goos, \"-D\", \"GOARCH_\"+goarch, sfile)\n }\n \n func (gcToolchain) pkgpath(basedir string, p *Package) string {\n@@ -1716,7 +1776,7 @@ func packInternal(b *builder, afile string, ofiles []string) error {\n \n func (gcToolchain) ld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error {\n \timportArgs := b.includeArgs(\"-L\", allactions)\n-\tcxx := false\n+\tcxx := len(p.CXXFiles) > 0\n \tfor _, a := range allactions {\n \t\tif a.p != nil && len(a.p.CXXFiles) > 0 {\n \t\t\tcxx = true\n@@ -1776,7 +1836,15 @@ func (gcToolchain) ld(b *builder, p *Package, out string, allactions []*action,\n func (gcToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error {\n \tinc := filepath.Join(goroot, \"pkg\", fmt.Sprintf(\"%s_%s\", goos, goarch))\n \tcfile = mkAbs(p.Dir, cfile)\n-\targs := stringList(tool(archChar+\"c\"), \"-F\", \"-V\", \"-w\", \"-trimpath\", b.work, \"-I\", objdir, \"-I\", inc, \"-o\", ofile, buildCcflags, \"-D\", \"GOOS_\"+goos, \"-D\", \"GOARCH_\"+goarch, cfile)\n+\twarn := []string{\"-w\"}\n+\tif p.usesSwig() {\n+\t\t// When using SWIG, this compiler is only used to\n+\t\t// compile the C files generated by SWIG.\n+\t\t// We don't want warnings.\n+\t\t// See issue 9065 for details.\n+\t\twarn = nil\n+\t}\n+\targs := stringList(tool(archChar+\"c\"), \"-F\", \"-V\", warn, \"-trimpath\", b.work, \"-I\", objdir, \"-I\", inc, \"-o\", ofile, buildCcflags, \"-D\", \"GOOS_\"+goos, \"-D\", \"GOARCH_\"+goarch, cfile)\n \treturn b.run(p.Dir, p.ImportPath, nil, args)\n }\n \n@@ -1802,7 +1870,7 @@ func (gccgoToolchain) linker() string {\n }\n \n func (tools gccgoToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {\n-\tout := p.Name + \".o\"\n+\tout := \"_go_.o\"\n \tofile = obj + out\n \tgcargs := []string{\"-g\"}\n \tgcargs = append(gcargs, b.gccArchArgs()...)\n@@ -1828,6 +1896,7 @@ func (tools gccgoToolchain) asm(b *builder, p *Package, obj, ofile, sfile string\n \t\tdefs = append(defs, `-D`, `GOPKGPATH=\"`+pkgpath+`\"`)\n \t}\n \tdefs = append(defs, b.gccArchArgs()...)\n+\n \treturn b.run(p.Dir, p.ImportPath, nil, tools.compiler(), \"-c\", \"-I\", obj, \"-o\", ofile, defs, sfile)\n }\n \n@@ -1854,8 +1923,8 @@ func (tools gccgoToolchain) ld(b *builder, p *Package, out string, allactions []\n \tldflags := b.gccArchArgs()\n \tcgoldflags := []string{}\n \tusesCgo := false\n-\tcxx := false\n-\tobjc := false\n+\tcxx := len(p.CXXFiles) > 0\n+\tobjc := len(p.MFiles) > 0\n \n \t// Prefer the output of an install action to the output of a build action,\n \t// because the install action will delete the output of the build action.\n@@ -1917,8 +1986,7 @@ func (gccgoToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) er\n \tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n \t\tdefs = append(defs, `-D`, `GOPKGPATH=\"`+pkgpath+`\"`)\n \t}\n-\t// TODO: Support using clang here (during gccgo build)?\n-\treturn b.run(p.Dir, p.ImportPath, nil, \"gcc\", \"-Wall\", \"-g\",\n+\treturn b.run(p.Dir, p.ImportPath, nil, envList(\"CC\", defaultCC), \"-Wall\", \"-g\",\n \t\t\"-I\", objdir, \"-I\", inc, \"-o\", ofile, defs, \"-c\", cfile)\n }\n \n@@ -1969,9 +2037,9 @@ func (b *builder) libgcc(p *Package) (string, error) {\n \t\treturn \"$LIBGCC\", nil\n \t}\n \n-\t// clang might not be able to find libgcc, and in that case,\n+\t// The compiler might not be able to find libgcc, and in that case,\n \t// it will simply return \"libgcc.a\", which is of no use to us.\n-\tif strings.Contains(gccCmd[0], \"clang\") && !filepath.IsAbs(string(f)) {\n+\tif !filepath.IsAbs(string(f)) {\n \t\treturn \"\", nil\n \t}\n \n@@ -2109,36 +2177,16 @@ var (\n \tcgoLibGccFileOnce sync.Once\n )\n \n-func (b *builder) cgo(p *Package, cgoExe, obj string, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n+func (b *builder) cgo(p *Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n \tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoLDFLAGS := b.cflags(p, true)\n \t_, cgoexeCFLAGS, _, _ := b.cflags(p, false)\n-\n+\tcgoCPPFLAGS = append(cgoCPPFLAGS, pcCFLAGS...)\n+\tcgoLDFLAGS = append(cgoLDFLAGS, pcLDFLAGS...)\n \t// If we are compiling Objective-C code, then we need to link against libobjc\n \tif len(mfiles) > 0 {\n \t\tcgoLDFLAGS = append(cgoLDFLAGS, \"-lobjc\")\n \t}\n \n-\tif pkgs := p.CgoPkgConfig; len(pkgs) > 0 {\n-\t\tout, err := b.runOut(p.Dir, p.ImportPath, nil, \"pkg-config\", \"--cflags\", pkgs)\n-\t\tif err != nil {\n-\t\t\tb.showOutput(p.Dir, \"pkg-config --cflags \"+strings.Join(pkgs, \" \"), string(out))\n-\t\t\tb.print(err.Error() + \"\\n\")\n-\t\t\treturn nil, nil, errPrintedOutput\n-\t\t}\n-\t\tif len(out) > 0 {\n-\t\t\tcgoCPPFLAGS = append(cgoCPPFLAGS, strings.Fields(string(out))...)\n-\t\t}\n-\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, \"pkg-config\", \"--libs\", pkgs)\n-\t\tif err != nil {\n-\t\t\tb.showOutput(p.Dir, \"pkg-config --libs \"+strings.Join(pkgs, \" \"), string(out))\n-\t\t\tb.print(err.Error() + \"\\n\")\n-\t\t\treturn nil, nil, errPrintedOutput\n-\t\t}\n-\t\tif len(out) > 0 {\n-\t\t\tcgoLDFLAGS = append(cgoLDFLAGS, strings.Fields(string(out))...)\n-\t\t}\n-\t}\n-\n \t// Allows including _cgo_export.h from .[ch] files in the package.\n \tcgoCPPFLAGS = append(cgoCPPFLAGS, \"-I\", obj)\n \n@@ -2215,6 +2263,14 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, gccfiles, gxxfiles, mfiles\n \t\t\tstrings.HasSuffix(f, \".so\"),\n \t\t\tstrings.HasSuffix(f, \".dll\"):\n \t\t\tcontinue\n+\t\t// Remove any -fsanitize=foo flags.\n+\t\t// Otherwise the compiler driver thinks that we are doing final link\n+\t\t// and links sanitizer runtime into the object file. But we are not doing\n+\t\t// the final link, we will link the resulting object file again. And\n+\t\t// so the program ends up with two copies of sanitizer runtime.\n+\t\t// See issue 8788 for details.\n+\t\tcase strings.HasPrefix(f, \"-fsanitize=\"):\n+\t\t\tcontinue\n \t\tdefault:\n \t\t\tbareLDFLAGS = append(bareLDFLAGS, f)\n \t\t}\n@@ -2281,13 +2337,14 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, gccfiles, gxxfiles, mfiles\n \n \tlinkobj = append(linkobj, p.SysoFiles...)\n \tdynobj := obj + \"_cgo_.o\"\n-\tif goarch == \"arm\" && goos == \"linux\" { // we need to use -pie for Linux/ARM to get accurate imported sym\n+\tpie := goarch == \"arm\" && (goos == \"linux\" || goos == \"android\")\n+\tif pie { // we need to use -pie for Linux/ARM to get accurate imported sym\n \t\tcgoLDFLAGS = append(cgoLDFLAGS, \"-pie\")\n \t}\n \tif err := b.gccld(p, dynobj, cgoLDFLAGS, linkobj); err != nil {\n \t\treturn nil, nil, err\n \t}\n-\tif goarch == \"arm\" && goos == \"linux\" { // but we don't need -pie for normal cgo programs\n+\tif pie { // but we don't need -pie for normal cgo programs\n \t\tcgoLDFLAGS = cgoLDFLAGS[0 : len(cgoLDFLAGS)-1]\n \t}\n \n@@ -2321,7 +2378,23 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, gccfiles, gxxfiles, mfiles\n \t\t\tnonGccObjs = append(nonGccObjs, f)\n \t\t}\n \t}\n-\tif err := b.gccld(p, ofile, stringList(bareLDFLAGS, \"-Wl,-r\", \"-nostdlib\", staticLibs), gccObjs); err != nil {\n+\tldflags := stringList(bareLDFLAGS, \"-Wl,-r\", \"-nostdlib\", staticLibs)\n+\n+\t// Some systems, such as Ubuntu, always add --build-id to\n+\t// every link, but we don't want a build ID since we are\n+\t// producing an object file.  On some of those system a plain\n+\t// -r (not -Wl,-r) will turn off --build-id, but clang 3.0\n+\t// doesn't support a plain -r.  I don't know how to turn off\n+\t// --build-id when using clang other than passing a trailing\n+\t// --build-id=none.  So that is what we do, but only on\n+\t// systems likely to support it, which is to say, systems that\n+\t// normally use gold or the GNU linker.\n+\tswitch goos {\n+\tcase \"android\", \"dragonfly\", \"linux\", \"netbsd\":\n+\t\tldflags = append(ldflags, \"-Wl,--build-id=none\")\n+\t}\n+\n+\tif err := b.gccld(p, ofile, ldflags, gccObjs); err != nil {\n \t\treturn nil, nil, err\n \t}\n \n@@ -2336,7 +2409,7 @@ func (b *builder) cgo(p *Package, cgoExe, obj string, gccfiles, gxxfiles, mfiles\n // Run SWIG on all SWIG input files.\n // TODO: Don't build a shared library, once SWIG emits the necessary\n // pragmas for external linking.\n-func (b *builder) swig(p *Package, obj string, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n+func (b *builder) swig(p *Package, obj string, pcCFLAGS, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n \tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _ := b.cflags(p, true)\n \tcflags := stringList(cgoCPPFLAGS, cgoCFLAGS)\n \tcxxflags := stringList(cgoCPPFLAGS, cgoCXXFLAGS)\n@@ -2377,7 +2450,7 @@ func (b *builder) swig(p *Package, obj string, gccfiles, gxxfiles, mfiles []stri\n \t}\n \n \tfor _, f := range p.SwigFiles {\n-\t\tgoFile, objFile, gccObjFile, err := b.swigOne(p, f, obj, false, intgosize)\n+\t\tgoFile, objFile, gccObjFile, err := b.swigOne(p, f, obj, pcCFLAGS, false, intgosize)\n \t\tif err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n@@ -2392,7 +2465,7 @@ func (b *builder) swig(p *Package, obj string, gccfiles, gxxfiles, mfiles []stri\n \t\t}\n \t}\n \tfor _, f := range p.SwigCXXFiles {\n-\t\tgoFile, objFile, gccObjFile, err := b.swigOne(p, f, obj, true, intgosize)\n+\t\tgoFile, objFile, gccObjFile, err := b.swigOne(p, f, obj, pcCFLAGS, true, intgosize)\n \t\tif err != nil {\n \t\t\treturn nil, nil, err\n \t\t}\n@@ -2471,13 +2544,13 @@ func (b *builder) swigIntSize(obj string) (intsize string, err error) {\n }\n \n // Run SWIG on one SWIG input file.\n-func (b *builder) swigOne(p *Package, file, obj string, cxx bool, intgosize string) (outGo, outObj, objGccObj string, err error) {\n+func (b *builder) swigOne(p *Package, file, obj string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outObj, objGccObj string, err error) {\n \tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _ := b.cflags(p, true)\n \tvar cflags []string\n \tif cxx {\n-\t\tcflags = stringList(cgoCPPFLAGS, cgoCXXFLAGS)\n+\t\tcflags = stringList(cgoCPPFLAGS, pcCFLAGS, cgoCXXFLAGS)\n \t} else {\n-\t\tcflags = stringList(cgoCPPFLAGS, cgoCFLAGS)\n+\t\tcflags = stringList(cgoCPPFLAGS, pcCFLAGS, cgoCFLAGS)\n \t}\n \n \tn := 5 // length of \".swig\"\n@@ -2503,6 +2576,13 @@ func (b *builder) swigOne(p *Package, file, obj string, cxx bool, intgosize stri\n \t\t\"-o\", obj + gccBase + gccExt,\n \t\t\"-outdir\", obj,\n \t}\n+\n+\tfor _, f := range cflags {\n+\t\tif len(f) > 3 && f[:2] == \"-I\" {\n+\t\t\targs = append(args, f)\n+\t\t}\n+\t}\n+\n \tif gccgo {\n \t\targs = append(args, \"-gccgo\")\n \t\tif pkgpath := gccgoPkgpath(p); pkgpath != \"\" {\n@@ -2575,8 +2655,8 @@ func raceInit() {\n \tif !buildRace {\n \t\treturn\n \t}\n-\tif goarch != \"amd64\" || goos != \"linux\" && goos != \"darwin\" && goos != \"windows\" {\n-\t\tfmt.Fprintf(os.Stderr, \"go %s: -race is only supported on linux/amd64, darwin/amd64 and windows/amd64\\n\", flag.Args()[0])\n+\tif goarch != \"amd64\" || goos != \"linux\" && goos != \"freebsd\" && goos != \"darwin\" && goos != \"windows\" {\n+\t\tfmt.Fprintf(os.Stderr, \"go %s: -race is only supported on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64\\n\", flag.Args()[0])\n \t\tos.Exit(2)\n \t}\n \tbuildGcflags = append(buildGcflags, \"-race\")"}, {"sha": "d0d8a8a5b2e8d298b544e295360ebf7923ab1658", "filename": "libgo/go/cmd/go/doc.go", "status": "modified", "additions": 173, "deletions": 33, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -19,6 +19,7 @@ The commands are:\n     env         print Go environment information\n     fix         run go tool fix on packages\n     fmt         run gofmt on package sources\n+    generate    generate Go files by processing source\n     get         download and install packages and dependencies\n     install     compile and install packages and dependencies\n     list        list packages\n@@ -75,14 +76,15 @@ and test commands:\n \n \t-a\n \t\tforce rebuilding of packages that are already up-to-date.\n+\t\tIn Go releases, does not apply to the standard library.\n \t-n\n \t\tprint the commands but do not run them.\n \t-p n\n \t\tthe number of builds that can be run in parallel.\n \t\tThe default is the number of CPUs available.\n \t-race\n \t\tenable data race detection.\n-\t\tSupported only on linux/amd64, darwin/amd64 and windows/amd64.\n+\t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n \t-v\n \t\tprint the names of packages as they are compiled.\n \t-work\n@@ -219,18 +221,122 @@ To run gofmt with specific options, run gofmt itself.\n See also: go fix, go vet.\n \n \n+Generate Go files by processing source\n+\n+Usage:\n+\n+\tgo generate [-run regexp] [file.go... | packages]\n+\n+Generate runs commands described by directives within existing\n+files. Those commands can run any process but the intent is to\n+create or update Go source files, for instance by running yacc.\n+\n+Go generate is never run automatically by go build, go get, go test,\n+and so on. It must be run explicitly.\n+\n+Go generate scans the file for directives, which are lines of\n+the form,\n+\n+\t//go:generate command argument...\n+\n+(note: no leading spaces and no space in \"//go\") where command\n+is the generator to be run, corresponding to an executable file\n+that can be run locally. It must either be in the shell path\n+(gofmt), a fully qualified path (/usr/you/bin/mytool), or a\n+command alias, described below.\n+\n+Note that go generate does not parse the file, so lines that look\n+like directives in comments or multiline strings will be treated\n+as directives.\n+\n+The arguments to the directive are space-separated tokens or\n+double-quoted strings passed to the generator as individual\n+arguments when it is run.\n+\n+Quoted strings use Go syntax and are evaluated before execution; a\n+quoted string appears as a single argument to the generator.\n+\n+Go generate sets several variables when it runs the generator:\n+\n+\t$GOARCH\n+\t\tThe execution architecture (arm, amd64, etc.)\n+\t$GOOS\n+\t\tThe execution operating system (linux, windows, etc.)\n+\t$GOFILE\n+\t\tThe base name of the file.\n+\t$GOPACKAGE\n+\t\tThe name of the package of the file containing the directive.\n+\n+Other than variable substitution and quoted-string evaluation, no\n+special processing such as \"globbing\" is performed on the command\n+line.\n+\n+As a last step before running the command, any invocations of any\n+environment variables with alphanumeric names, such as $GOFILE or\n+$HOME, are expanded throughout the command line. The syntax for\n+variable expansion is $NAME on all operating systems.  Due to the\n+order of evaluation, variables are expanded even inside quoted\n+strings. If the variable NAME is not set, $NAME expands to the\n+empty string.\n+\n+A directive of the form,\n+\n+\t//go:generate -command xxx args...\n+\n+specifies, for the remainder of this source file only, that the\n+string xxx represents the command identified by the arguments. This\n+can be used to create aliases or to handle multiword generators.\n+For example,\n+\n+\t//go:generate -command yacc go tool yacc\n+\n+specifies that the command \"yacc\" represents the generator\n+\"go tool yacc\".\n+\n+Generate processes packages in the order given on the command line,\n+one at a time. If the command line lists .go files, they are treated\n+as a single package. Within a package, generate processes the\n+source files in a package in file name order, one at a time. Within\n+a source file, generate runs generators in the order they appear\n+in the file, one at a time.\n+\n+If any generator returns an error exit status, \"go generate\" skips\n+all further processing for that package.\n+\n+The generator is run in the package's source directory.\n+\n+Go generate accepts one specific flag:\n+\n+\t-run=\"\"\n+\t\tif non-empty, specifies a regular expression to\n+\t\tselect directives whose command matches the expression.\n+\n+It also accepts the standard build flags -v, -n, and -x.\n+The -v flag prints the names of packages and files as they are\n+processed.\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+\n Download and install packages and dependencies\n \n Usage:\n \n-\tgo get [-d] [-fix] [-t] [-u] [build flags] [packages]\n+\tgo get [-d] [-f] [-fix] [-t] [-u] [build flags] [packages]\n \n Get downloads and installs the packages named by the import paths,\n along with their dependencies.\n \n The -d flag instructs get to stop after downloading the packages; that is,\n it instructs get not to install the packages.\n \n+The -f flag, valid only when -u is set, forces get -u not to verify that\n+each package has been checked out from the source control repository\n+implied by its import path. This can be useful if the source is a local fork\n+of the original.\n+\n The -fix flag instructs get to run the fix tool on the downloaded packages\n before resolving dependencies or building the code.\n \n@@ -291,28 +397,29 @@ syntax of package template.  The default output is equivalent to -f\n '{{.ImportPath}}'. The struct being passed to the template is:\n \n     type Package struct {\n-        Dir        string // directory containing package sources\n-        ImportPath string // import path of package in dir\n-        Name       string // package name\n-        Doc        string // package documentation string\n-        Target     string // install path\n-        Goroot     bool   // is this package in the Go root?\n-        Standard   bool   // is this package part of the standard Go library?\n-        Stale      bool   // would 'go install' do anything for this package?\n-        Root       string // Go root or Go path dir containing this package\n+        Dir           string // directory containing package sources\n+        ImportPath    string // import path of package in dir\n+        ImportComment string // path in import comment on package statement\n+        Name          string // package name\n+        Doc           string // package documentation string\n+        Target        string // install path\n+        Goroot        bool   // is this package in the Go root?\n+        Standard      bool   // is this package part of the standard Go library?\n+        Stale         bool   // would 'go install' do anything for this package?\n+        Root          string // Go root or Go path dir containing this package\n \n         // Source files\n-        GoFiles  []string       // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-        CgoFiles []string       // .go sources files that import \"C\"\n+        GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+        CgoFiles       []string // .go sources files that import \"C\"\n         IgnoredGoFiles []string // .go sources ignored due to build constraints\n-        CFiles   []string       // .c source files\n-        CXXFiles []string       // .cc, .cxx and .cpp source files\n-        MFiles   []string       // .m source files\n-        HFiles   []string       // .h, .hh, .hpp and .hxx source files\n-        SFiles   []string       // .s source files\n-        SwigFiles []string      // .swig files\n-        SwigCXXFiles []string   // .swigcxx files\n-        SysoFiles []string      // .syso object files to add to archive\n+        CFiles         []string // .c source files\n+        CXXFiles       []string // .cc, .cxx and .cpp source files\n+        MFiles         []string // .m source files\n+        HFiles         []string // .h, .hh, .hpp and .hxx source files\n+        SFiles         []string // .s source files\n+        SwigFiles      []string // .swig files\n+        SwigCXXFiles   []string // .swigcxx files\n+        SysoFiles      []string // .syso object files to add to archive\n \n         // Cgo directives\n         CgoCFLAGS    []string // cgo: flags for C compiler\n@@ -431,16 +538,23 @@ non-test installation.\n \n In addition to the build flags, the flags handled by 'go test' itself are:\n \n-\t-c  Compile the test binary to pkg.test but do not run it.\n-\t    (Where pkg is the last element of the package's import path.)\n+\t-c\n+\t\tCompile the test binary to pkg.test but do not run it\n+\t\t(where pkg is the last element of the package's import path).\n+\t\tThe file name can be changed with the -o flag.\n+\n+\t-exec xprog\n+\t    Run the test binary using xprog. The behavior is the same as\n+\t    in 'go run'. See 'go help run' for details.\n \n \t-i\n \t    Install packages that are dependencies of the test.\n \t    Do not run the test.\n \n-\t-exec xprog\n-\t    Run the test binary using xprog. The behavior is the same as\n-\t    in 'go run'. See 'go help run' for details.\n+\t-o file\n+\t\tCompile the test binary to the named file.\n+\t\tThe test still runs (unless -c or -i is specified).\n+\n \n The test binary also accepts flags that control execution of the test; these\n flags are also accessible by 'go test'.  See 'go help testflag' for details.\n@@ -488,7 +602,7 @@ Usage:\n \n Vet runs the Go vet command on the packages named by the import paths.\n \n-For more about vet, see 'godoc code.google.com/p/go.tools/cmd/vet'.\n+For more about vet, see 'godoc golang.org/x/tools/cmd/vet'.\n For more about specifying packages, see 'go help packages'.\n \n To run the vet tool with specific options, run 'go tool vet'.\n@@ -681,6 +795,11 @@ A few common code hosting sites have special syntax:\n \t\timport \"launchpad.net/~user/project/branch\"\n \t\timport \"launchpad.net/~user/project/branch/sub/directory\"\n \n+\tIBM DevOps Services (Git)\n+\n+\t\timport \"hub.jazz.net/git/user/project\"\n+\t\timport \"hub.jazz.net/git/user/project/sub/directory\"\n+\n For code hosted on other servers, import paths may either be qualified\n with the version control type, or the go tool can dynamically fetch\n the import path over https/http and discover where the code resides\n@@ -756,7 +875,26 @@ listed in the GOPATH environment variable (see 'go help gopath').\n \n The go command attempts to download the version of the\n package appropriate for the Go release being used.\n-Run 'go help install' for more.\n+Run 'go help get' for more.\n+\n+Import path checking\n+\n+When the custom import path feature described above redirects to a\n+known code hosting site, each of the resulting packages has two possible\n+import paths, using the custom domain or the known hosting site.\n+\n+A package statement is said to have an \"import comment\" if it is immediately\n+followed (before the next newline) by a comment of one of these two forms:\n+\n+\tpackage math // import \"path\"\n+\tpackage math /* import \"path\" * /\n+\n+The go command will refuse to install a package with an import comment\n+unless it is being referred to by that import path. In this way, import comments\n+let package authors make sure the custom import path is used and not a\n+direct path to the underlying code hosting site.\n+\n+See https://golang.org/s/go14customimport for details.\n \n \n Description of package lists\n@@ -812,7 +950,8 @@ single directory, the command is applied to a single synthesized\n package made up of exactly those files, ignoring any build constraints\n in those files and ignoring any other files in the directory.\n \n-File names that begin with \".\" or \"_\" are ignored by the go tool.\n+Directory and file names that begin with \".\" or \"_\" are ignored\n+by the go tool, as are directories named \"testdata\".\n \n \n Description of testing flags\n@@ -844,6 +983,7 @@ control the execution of any test:\n \t-blockprofile block.out\n \t    Write a goroutine blocking profile to the specified file\n \t    when all tests are complete.\n+\t    Writes test binary as -c would.\n \n \t-blockprofilerate n\n \t    Control the detail provided in goroutine blocking profiles by\n@@ -875,8 +1015,7 @@ control the execution of any test:\n \t    Sets -cover.\n \n \t-coverprofile cover.out\n-\t    Write a coverage profile to the specified file after all tests\n-\t    have passed.\n+\t    Write a coverage profile to the file after all tests have passed.\n \t    Sets -cover.\n \n \t-cpu 1,2,4\n@@ -886,10 +1025,11 @@ control the execution of any test:\n \n \t-cpuprofile cpu.out\n \t    Write a CPU profile to the specified file before exiting.\n+\t    Writes test binary as -c would.\n \n \t-memprofile mem.out\n-\t    Write a memory profile to the specified file after all tests\n-\t    have passed.\n+\t    Write a memory profile to the file after all tests have passed.\n+\t    Writes test binary as -c would.\n \n \t-memprofilerate n\n \t    Enable more precise (and expensive) memory profiles by setting"}, {"sha": "baf4d2b55c1f8792c1794fc46ff8d895bfdf31e9", "filename": "libgo/go/cmd/go/generate.go", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,398 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+var cmdGenerate = &Command{\n+\tRun:       runGenerate,\n+\tUsageLine: \"generate [-run regexp] [file.go... | packages]\",\n+\tShort:     \"generate Go files by processing source\",\n+\tLong: `\n+Generate runs commands described by directives within existing\n+files. Those commands can run any process but the intent is to\n+create or update Go source files, for instance by running yacc.\n+\n+Go generate is never run automatically by go build, go get, go test,\n+and so on. It must be run explicitly.\n+\n+Go generate scans the file for directives, which are lines of\n+the form,\n+\n+\t//go:generate command argument...\n+\n+(note: no leading spaces and no space in \"//go\") where command\n+is the generator to be run, corresponding to an executable file\n+that can be run locally. It must either be in the shell path\n+(gofmt), a fully qualified path (/usr/you/bin/mytool), or a\n+command alias, described below.\n+\n+Note that go generate does not parse the file, so lines that look\n+like directives in comments or multiline strings will be treated\n+as directives.\n+\n+The arguments to the directive are space-separated tokens or\n+double-quoted strings passed to the generator as individual\n+arguments when it is run.\n+\n+Quoted strings use Go syntax and are evaluated before execution; a\n+quoted string appears as a single argument to the generator.\n+\n+Go generate sets several variables when it runs the generator:\n+\n+\t$GOARCH\n+\t\tThe execution architecture (arm, amd64, etc.)\n+\t$GOOS\n+\t\tThe execution operating system (linux, windows, etc.)\n+\t$GOFILE\n+\t\tThe base name of the file.\n+\t$GOPACKAGE\n+\t\tThe name of the package of the file containing the directive.\n+\n+Other than variable substitution and quoted-string evaluation, no\n+special processing such as \"globbing\" is performed on the command\n+line.\n+\n+As a last step before running the command, any invocations of any\n+environment variables with alphanumeric names, such as $GOFILE or\n+$HOME, are expanded throughout the command line. The syntax for\n+variable expansion is $NAME on all operating systems.  Due to the\n+order of evaluation, variables are expanded even inside quoted\n+strings. If the variable NAME is not set, $NAME expands to the\n+empty string.\n+\n+A directive of the form,\n+\n+\t//go:generate -command xxx args...\n+\n+specifies, for the remainder of this source file only, that the\n+string xxx represents the command identified by the arguments. This\n+can be used to create aliases or to handle multiword generators.\n+For example,\n+\n+\t//go:generate -command yacc go tool yacc\n+\n+specifies that the command \"yacc\" represents the generator\n+\"go tool yacc\".\n+\n+Generate processes packages in the order given on the command line,\n+one at a time. If the command line lists .go files, they are treated\n+as a single package. Within a package, generate processes the\n+source files in a package in file name order, one at a time. Within\n+a source file, generate runs generators in the order they appear\n+in the file, one at a time.\n+\n+If any generator returns an error exit status, \"go generate\" skips\n+all further processing for that package.\n+\n+The generator is run in the package's source directory.\n+\n+Go generate accepts one specific flag:\n+\n+\t-run=\"\"\n+\t\tif non-empty, specifies a regular expression to\n+\t\tselect directives whose command matches the expression.\n+\n+It also accepts the standard build flags -v, -n, and -x.\n+The -v flag prints the names of packages and files as they are\n+processed.\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+For more about specifying packages, see 'go help packages'.\n+\t`,\n+}\n+\n+var generateRunFlag string // generate -run flag\n+\n+func init() {\n+\taddBuildFlags(cmdGenerate)\n+\tcmdGenerate.Flag.StringVar(&generateRunFlag, \"run\", \"\", \"\")\n+}\n+\n+func runGenerate(cmd *Command, args []string) {\n+\t// Even if the arguments are .go files, this loop suffices.\n+\tfor _, pkg := range packages(args) {\n+\t\tfor _, file := range pkg.gofiles {\n+\t\t\tif !generate(pkg.Name, file) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// generate runs the generation directives for a single file.\n+func generate(pkg, absFile string) bool {\n+\tfd, err := os.Open(absFile)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"generate: %s\", err)\n+\t}\n+\tdefer fd.Close()\n+\tg := &Generator{\n+\t\tr:        fd,\n+\t\tpath:     absFile,\n+\t\tpkg:      pkg,\n+\t\tcommands: make(map[string][]string),\n+\t}\n+\treturn g.run()\n+}\n+\n+// A Generator represents the state of a single Go source file\n+// being scanned for generator commands.\n+type Generator struct {\n+\tr        io.Reader\n+\tpath     string // full rooted path name.\n+\tdir      string // full rooted directory of file.\n+\tfile     string // base name of file.\n+\tpkg      string\n+\tcommands map[string][]string\n+\tlineNum  int\n+}\n+\n+// run runs the generators in the current file.\n+func (g *Generator) run() (ok bool) {\n+\t// Processing below here calls g.errorf on failure, which does panic(stop).\n+\t// If we encounter an error, we abort the package.\n+\tdefer func() {\n+\t\te := recover()\n+\t\tif e != nil {\n+\t\t\tok = false\n+\t\t\tif e != stop {\n+\t\t\t\tpanic(e)\n+\t\t\t}\n+\t\t\tsetExitStatus(1)\n+\t\t}\n+\t}()\n+\tg.dir, g.file = filepath.Split(g.path)\n+\tg.dir = filepath.Clean(g.dir) // No final separator please.\n+\tif buildV {\n+\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", shortPath(g.path))\n+\t}\n+\n+\t// Scan for lines that start \"//go:generate\".\n+\t// Can't use bufio.Scanner because it can't handle long lines,\n+\t// which are likely to appear when using generate.\n+\tinput := bufio.NewReader(g.r)\n+\tvar err error\n+\t// One line per loop.\n+\tfor {\n+\t\tg.lineNum++ // 1-indexed.\n+\t\tvar buf []byte\n+\t\tbuf, err = input.ReadSlice('\\n')\n+\t\tif err == bufio.ErrBufferFull {\n+\t\t\t// Line too long - consume and ignore.\n+\t\t\tif isGoGenerate(buf) {\n+\t\t\t\tg.errorf(\"directive too long\")\n+\t\t\t}\n+\t\t\tfor err == bufio.ErrBufferFull {\n+\t\t\t\t_, err = input.ReadSlice('\\n')\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif err != nil {\n+\t\t\t// Check for marker at EOF without final \\n.\n+\t\t\tif err == io.EOF && isGoGenerate(buf) {\n+\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tif !isGoGenerate(buf) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\twords := g.split(string(buf))\n+\t\tif len(words) == 0 {\n+\t\t\tg.errorf(\"no arguments to directive\")\n+\t\t}\n+\t\tif words[0] == \"-command\" {\n+\t\t\tg.setShorthand(words)\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Run the command line.\n+\t\tif buildN || buildX {\n+\t\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", strings.Join(words, \" \"))\n+\t\t}\n+\t\tif buildN {\n+\t\t\tcontinue\n+\t\t}\n+\t\tg.exec(words)\n+\t}\n+\tif err != nil && err != io.EOF {\n+\t\tg.errorf(\"error reading %s: %s\", shortPath(g.path), err)\n+\t}\n+\treturn true\n+}\n+\n+func isGoGenerate(buf []byte) bool {\n+\treturn bytes.HasPrefix(buf, []byte(\"//go:generate \")) || bytes.HasPrefix(buf, []byte(\"//go:generate\\t\"))\n+}\n+\n+// split breaks the line into words, evaluating quoted\n+// strings and evaluating environment variables.\n+// The initial //go:generate element is present in line.\n+func (g *Generator) split(line string) []string {\n+\t// Parse line, obeying quoted strings.\n+\tvar words []string\n+\tline = line[len(\"//go:generate \") : len(line)-1] // Drop preamble and final newline.\n+\t// One (possibly quoted) word per iteration.\n+Words:\n+\tfor {\n+\t\tline = strings.TrimLeft(line, \" \\t\")\n+\t\tif len(line) == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif line[0] == '\"' {\n+\t\t\tfor i := 1; i < len(line); i++ {\n+\t\t\t\tc := line[i] // Only looking for ASCII so this is OK.\n+\t\t\t\tswitch c {\n+\t\t\t\tcase '\\\\':\n+\t\t\t\t\tif i+1 == len(line) {\n+\t\t\t\t\t\tg.errorf(\"bad backslash\")\n+\t\t\t\t\t}\n+\t\t\t\t\ti++ // Absorb next byte (If it's a multibyte we'll get an error in Unquote).\n+\t\t\t\tcase '\"':\n+\t\t\t\t\tword, err := strconv.Unquote(line[0 : i+1])\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tg.errorf(\"bad quoted string\")\n+\t\t\t\t\t}\n+\t\t\t\t\twords = append(words, word)\n+\t\t\t\t\tline = line[i+1:]\n+\t\t\t\t\t// Check the next character is space or end of line.\n+\t\t\t\t\tif len(line) > 0 && line[0] != ' ' && line[0] != '\\t' {\n+\t\t\t\t\t\tg.errorf(\"expect space after quoted argument\")\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue Words\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tg.errorf(\"mismatched quoted string\")\n+\t\t}\n+\t\ti := strings.IndexAny(line, \" \\t\")\n+\t\tif i < 0 {\n+\t\t\ti = len(line)\n+\t\t}\n+\t\twords = append(words, line[0:i])\n+\t\tline = line[i:]\n+\t}\n+\t// Substitute command if required.\n+\tif len(words) > 0 && g.commands[words[0]] != nil {\n+\t\t// Replace 0th word by command substitution.\n+\t\twords = append(g.commands[words[0]], words[1:]...)\n+\t}\n+\t// Substitute environment variables.\n+\tfor i, word := range words {\n+\t\twords[i] = g.expandEnv(word)\n+\t}\n+\treturn words\n+}\n+\n+var stop = fmt.Errorf(\"error in generation\")\n+\n+// errorf logs an error message prefixed with the file and line number.\n+// It then exits the program (with exit status 1) because generation stops\n+// at the first error.\n+func (g *Generator) errorf(format string, args ...interface{}) {\n+\tfmt.Fprintf(os.Stderr, \"%s:%d: %s\\n\", shortPath(g.path), g.lineNum,\n+\t\tfmt.Sprintf(format, args...))\n+\tpanic(stop)\n+}\n+\n+// expandEnv expands any $XXX invocations in word.\n+func (g *Generator) expandEnv(word string) string {\n+\tif !strings.ContainsRune(word, '$') {\n+\t\treturn word\n+\t}\n+\tvar buf bytes.Buffer\n+\tvar w int\n+\tvar r rune\n+\tfor i := 0; i < len(word); i += w {\n+\t\tr, w = utf8.DecodeRuneInString(word[i:])\n+\t\tif r != '$' {\n+\t\t\tbuf.WriteRune(r)\n+\t\t\tcontinue\n+\t\t}\n+\t\tw += g.identLength(word[i+w:])\n+\t\tenvVar := word[i+1 : i+w]\n+\t\tvar sub string\n+\t\tswitch envVar {\n+\t\tcase \"GOARCH\":\n+\t\t\tsub = runtime.GOARCH\n+\t\tcase \"GOOS\":\n+\t\t\tsub = runtime.GOOS\n+\t\tcase \"GOFILE\":\n+\t\t\tsub = g.file\n+\t\tcase \"GOPACKAGE\":\n+\t\t\tsub = g.pkg\n+\t\tdefault:\n+\t\t\tsub = os.Getenv(envVar)\n+\t\t}\n+\t\tbuf.WriteString(sub)\n+\t}\n+\treturn buf.String()\n+}\n+\n+// identLength returns the length of the identifier beginning the string.\n+func (g *Generator) identLength(word string) int {\n+\tfor i, r := range word {\n+\t\tif r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r) {\n+\t\t\tcontinue\n+\t\t}\n+\t\treturn i\n+\t}\n+\treturn len(word)\n+}\n+\n+// setShorthand installs a new shorthand as defined by a -command directive.\n+func (g *Generator) setShorthand(words []string) {\n+\t// Create command shorthand.\n+\tif len(words) == 1 {\n+\t\tg.errorf(\"no command specified for -command\")\n+\t}\n+\tcommand := words[1]\n+\tif g.commands[command] != nil {\n+\t\tg.errorf(\"command %q defined multiply defined\", command)\n+\t}\n+\tg.commands[command] = words[2:len(words):len(words)] // force later append to make copy\n+}\n+\n+// exec runs the command specified by the argument. The first word is\n+// the command name itself.\n+func (g *Generator) exec(words []string) {\n+\tcmd := exec.Command(words[0], words[1:]...)\n+\t// Standard in and out of generator should be the usual.\n+\tcmd.Stdout = os.Stdout\n+\tcmd.Stderr = os.Stderr\n+\t// Run the command in the package directory.\n+\tcmd.Dir = g.dir\n+\tenv := []string{\n+\t\t\"GOARCH=\" + runtime.GOARCH,\n+\t\t\"GOOS=\" + runtime.GOOS,\n+\t\t\"GOFILE=\" + g.file,\n+\t\t\"GOPACKAGE=\" + g.pkg,\n+\t}\n+\tcmd.Env = mergeEnvLists(env, os.Environ())\n+\terr := cmd.Run()\n+\tif err != nil {\n+\t\tg.errorf(\"running %q: %s\", words[0], err)\n+\t}\n+}"}, {"sha": "660ebabbe84d8b2d5593bca35fec4b137c9fd421", "filename": "libgo/go/cmd/go/generate_test.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+type splitTest struct {\n+\tin  string\n+\tout []string\n+}\n+\n+var splitTests = []splitTest{\n+\t{\"\", nil},\n+\t{\"x\", []string{\"x\"}},\n+\t{\" a b\\tc \", []string{\"a\", \"b\", \"c\"}},\n+\t{` \" a \" `, []string{\" a \"}},\n+\t{\"$GOARCH\", []string{runtime.GOARCH}},\n+\t{\"$GOOS\", []string{runtime.GOOS}},\n+\t{\"$GOFILE\", []string{\"proc.go\"}},\n+\t{\"$GOPACKAGE\", []string{\"sys\"}},\n+\t{\"a $XXNOTDEFINEDXX b\", []string{\"a\", \"\", \"b\"}},\n+\t{\"/$XXNOTDEFINED/\", []string{\"//\"}},\n+\t{\"yacc -o $GOARCH/yacc_$GOFILE\", []string{\"go\", \"tool\", \"yacc\", \"-o\", runtime.GOARCH + \"/yacc_proc.go\"}},\n+}\n+\n+func TestGenerateCommandParse(t *testing.T) {\n+\tg := &Generator{\n+\t\tr:        nil, // Unused here.\n+\t\tpath:     \"/usr/ken/sys/proc.go\",\n+\t\tdir:      \"/usr/ken/sys\",\n+\t\tfile:     \"proc.go\",\n+\t\tpkg:      \"sys\",\n+\t\tcommands: make(map[string][]string),\n+\t}\n+\tg.setShorthand([]string{\"-command\", \"yacc\", \"go\", \"tool\", \"yacc\"})\n+\tfor _, test := range splitTests {\n+\t\tgot := g.split(\"//go:generate \" + test.in + \"\\n\")\n+\t\tif !reflect.DeepEqual(got, test.out) {\n+\t\t\tt.Errorf(\"split(%q): got %q expected %q\", test.in, got, test.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "86e1697618ab4d6e21f8e5d78ef1d5b547abc2ac", "filename": "libgo/go/cmd/go/get.go", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -16,7 +16,7 @@ import (\n )\n \n var cmdGet = &Command{\n-\tUsageLine: \"get [-d] [-fix] [-t] [-u] [build flags] [packages]\",\n+\tUsageLine: \"get [-d] [-f] [-fix] [-t] [-u] [build flags] [packages]\",\n \tShort:     \"download and install packages and dependencies\",\n \tLong: `\n Get downloads and installs the packages named by the import paths,\n@@ -25,6 +25,11 @@ along with their dependencies.\n The -d flag instructs get to stop after downloading the packages; that is,\n it instructs get not to install the packages.\n \n+The -f flag, valid only when -u is set, forces get -u not to verify that\n+each package has been checked out from the source control repository\n+implied by its import path. This can be useful if the source is a local fork\n+of the original.\n+\n The -fix flag instructs get to run the fix tool on the downloaded packages\n before resolving dependencies or building the code.\n \n@@ -53,6 +58,7 @@ See also: go build, go install, go clean.\n }\n \n var getD = cmdGet.Flag.Bool(\"d\", false, \"\")\n+var getF = cmdGet.Flag.Bool(\"f\", false, \"\")\n var getT = cmdGet.Flag.Bool(\"t\", false, \"\")\n var getU = cmdGet.Flag.Bool(\"u\", false, \"\")\n var getFix = cmdGet.Flag.Bool(\"fix\", false, \"\")\n@@ -63,6 +69,10 @@ func init() {\n }\n \n func runGet(cmd *Command, args []string) {\n+\tif *getF && !*getU {\n+\t\tfatalf(\"go get: cannot use -f flag without -u\")\n+\t}\n+\n \t// Phase 1.  Download/update.\n \tvar stk importStack\n \tfor _, arg := range downloadPaths(args) {\n@@ -151,7 +161,9 @@ func download(arg string, stk *importStack, getTestDeps bool) {\n \t}\n \n \t// Only process each package once.\n-\tif downloadCache[arg] {\n+\t// (Unless we're fetching test dependencies for this package,\n+\t// in which case we want to process it again.)\n+\tif downloadCache[arg] && !getTestDeps {\n \t\treturn\n \t}\n \tdownloadCache[arg] = true\n@@ -264,6 +276,25 @@ func downloadPackage(p *Package) error {\n \t\t\treturn err\n \t\t}\n \t\trepo = \"<local>\" // should be unused; make distinctive\n+\n+\t\t// Double-check where it came from.\n+\t\tif *getU && vcs.remoteRepo != nil && !*getF {\n+\t\t\tdir := filepath.Join(p.build.SrcRoot, rootPath)\n+\t\t\tif remote, err := vcs.remoteRepo(vcs, dir); err == nil {\n+\t\t\t\tif rr, err := repoRootForImportPath(p.ImportPath); err == nil {\n+\t\t\t\t\trepo := rr.repo\n+\t\t\t\t\tif rr.vcs.resolveRepo != nil {\n+\t\t\t\t\t\tresolved, err := rr.vcs.resolveRepo(rr.vcs, dir, repo)\n+\t\t\t\t\t\tif err == nil {\n+\t\t\t\t\t\t\trepo = resolved\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif remote != repo {\n+\t\t\t\t\t\treturn fmt.Errorf(\"%s is from %s, should be from %s\", dir, remote, repo)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t} else {\n \t\t// Analyze the import path to determine the version control system,\n \t\t// repository, and the import path for the root of the repository."}, {"sha": "53d695cccc8a72c6285ce5b7bcfa87bccef22e26", "filename": "libgo/go/cmd/go/go_windows_test.go", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestAbsolutePath(t *testing.T) {\n+\ttmp, err := ioutil.TempDir(\"\", \"TestAbsolutePath\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(tmp)\n+\n+\tfile := filepath.Join(tmp, \"a.go\")\n+\terr = ioutil.WriteFile(file, []byte{}, 0644)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdir := filepath.Join(tmp, \"dir\")\n+\terr = os.Mkdir(dir, 0777)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.Chdir(wd)\n+\n+\t// Chdir so current directory and a.go reside on the same drive.\n+\terr = os.Chdir(dir)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tnoVolume := file[len(filepath.VolumeName(file)):]\n+\twrongPath := filepath.Join(dir, noVolume)\n+\toutput, err := exec.Command(\"go\", \"build\", noVolume).CombinedOutput()\n+\tif err == nil {\n+\t\tt.Fatal(\"build should fail\")\n+\t}\n+\tif strings.Contains(string(output), wrongPath) {\n+\t\tt.Fatalf(\"wrong output found: %v %v\", err, string(output))\n+\t}\n+}"}, {"sha": "c590fdb37fe80665050428af053040b8fd56a62c", "filename": "libgo/go/cmd/go/help.go", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -81,7 +81,8 @@ single directory, the command is applied to a single synthesized\n package made up of exactly those files, ignoring any build constraints\n in those files and ignoring any other files in the directory.\n \n-File names that begin with \".\" or \"_\" are ignored by the go tool.\n+Directory and file names that begin with \".\" or \"_\" are ignored\n+by the go tool, as are directories named \"testdata\".\n \t`,\n }\n \n@@ -154,6 +155,11 @@ A few common code hosting sites have special syntax:\n \t\timport \"launchpad.net/~user/project/branch\"\n \t\timport \"launchpad.net/~user/project/branch/sub/directory\"\n \n+\tIBM DevOps Services (Git)\n+\n+\t\timport \"hub.jazz.net/git/user/project\"\n+\t\timport \"hub.jazz.net/git/user/project/sub/directory\"\n+\n For code hosted on other servers, import paths may either be qualified\n with the version control type, or the go tool can dynamically fetch\n the import path over https/http and discover where the code resides\n@@ -229,7 +235,26 @@ listed in the GOPATH environment variable (see 'go help gopath').\n \n The go command attempts to download the version of the\n package appropriate for the Go release being used.\n-Run 'go help install' for more.\n+Run 'go help get' for more.\n+\n+Import path checking\n+\n+When the custom import path feature described above redirects to a\n+known code hosting site, each of the resulting packages has two possible\n+import paths, using the custom domain or the known hosting site.\n+\n+A package statement is said to have an \"import comment\" if it is immediately\n+followed (before the next newline) by a comment of one of these two forms:\n+\n+\tpackage math // import \"path\"\n+\tpackage math /* import \"path\" */\n+\n+The go command will refuse to install a package with an import comment\n+unless it is being referred to by that import path. In this way, import comments\n+let package authors make sure the custom import path is used and not a\n+direct path to the underlying code hosting site.\n+\n+See https://golang.org/s/go14customimport for details.\n \t`,\n }\n "}, {"sha": "fbf96167febd47f0c9b226010efe444189429921", "filename": "libgo/go/cmd/go/list.go", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -30,28 +30,29 @@ syntax of package template.  The default output is equivalent to -f\n '{{.ImportPath}}'. The struct being passed to the template is:\n \n     type Package struct {\n-        Dir        string // directory containing package sources\n-        ImportPath string // import path of package in dir\n-        Name       string // package name\n-        Doc        string // package documentation string\n-        Target     string // install path\n-        Goroot     bool   // is this package in the Go root?\n-        Standard   bool   // is this package part of the standard Go library?\n-        Stale      bool   // would 'go install' do anything for this package?\n-        Root       string // Go root or Go path dir containing this package\n+        Dir           string // directory containing package sources\n+        ImportPath    string // import path of package in dir\n+        ImportComment string // path in import comment on package statement\n+        Name          string // package name\n+        Doc           string // package documentation string\n+        Target        string // install path\n+        Goroot        bool   // is this package in the Go root?\n+        Standard      bool   // is this package part of the standard Go library?\n+        Stale         bool   // would 'go install' do anything for this package?\n+        Root          string // Go root or Go path dir containing this package\n \n         // Source files\n-        GoFiles  []string       // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-        CgoFiles []string       // .go sources files that import \"C\"\n+        GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+        CgoFiles       []string // .go sources files that import \"C\"\n         IgnoredGoFiles []string // .go sources ignored due to build constraints\n-        CFiles   []string       // .c source files\n-        CXXFiles []string       // .cc, .cxx and .cpp source files\n-        MFiles   []string       // .m source files\n-        HFiles   []string       // .h, .hh, .hpp and .hxx source files\n-        SFiles   []string       // .s source files\n-        SwigFiles []string      // .swig files\n-        SwigCXXFiles []string   // .swigcxx files\n-        SysoFiles []string      // .syso object files to add to archive\n+        CFiles         []string // .c source files\n+        CXXFiles       []string // .cc, .cxx and .cpp source files\n+        MFiles         []string // .m source files\n+        HFiles         []string // .h, .hh, .hpp and .hxx source files\n+        SFiles         []string // .s source files\n+        SwigFiles      []string // .swig files\n+        SwigCXXFiles   []string // .swigcxx files\n+        SysoFiles      []string // .syso object files to add to archive\n \n         // Cgo directives\n         CgoCFLAGS    []string // cgo: flags for C compiler"}, {"sha": "9691f39c763ffbde59d213cb67a0f8f50deb1420", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -79,6 +79,7 @@ var commands = []*Command{\n \tcmdEnv,\n \tcmdFix,\n \tcmdFmt,\n+\tcmdGenerate,\n \tcmdGet,\n \tcmdInstall,\n \tcmdList,\n@@ -536,7 +537,7 @@ func matchPackages(pattern string) []string {\n \t})\n \n \tfor _, src := range buildContext.SrcDirs() {\n-\t\tif pattern == \"std\" && src != gorootSrcPkg {\n+\t\tif pattern == \"std\" && src != gorootSrc {\n \t\t\tcontinue\n \t\t}\n \t\tsrc = filepath.Clean(src) + string(filepath.Separator)\n@@ -618,7 +619,7 @@ func matchPackagesInFS(pattern string) []string {\n \t\t\t// The initial case is not Cleaned, though, so we do this explicitly.\n \t\t\t//\n \t\t\t// This converts a path like \"./io/\" to \"io\". Without this step, running\n-\t\t\t// \"cd $GOROOT/src/pkg; go list ./io/...\" would incorrectly skip the io\n+\t\t\t// \"cd $GOROOT/src; go list ./io/...\" would incorrectly skip the io\n \t\t\t// package, because prepending the prefix \"./\" to the unclean path would\n \t\t\t// result in \"././io\", and match(\"././io\") returns false.\n \t\t\tpath = filepath.Clean(path)"}, {"sha": "621cb4b6083cd76e57a92cf211c318d43be3eb9c", "filename": "libgo/go/cmd/go/pkg.go", "status": "modified", "additions": 144, "deletions": 36, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"os\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"time\"\n@@ -25,16 +26,17 @@ type Package struct {\n \t// Note: These fields are part of the go command's public API.\n \t// See list.go.  It is okay to add fields, but not to change or\n \t// remove existing ones.  Keep in sync with list.go\n-\tDir         string `json:\",omitempty\"` // directory containing package sources\n-\tImportPath  string `json:\",omitempty\"` // import path of package in dir\n-\tName        string `json:\",omitempty\"` // package name\n-\tDoc         string `json:\",omitempty\"` // package documentation string\n-\tTarget      string `json:\",omitempty\"` // install path\n-\tGoroot      bool   `json:\",omitempty\"` // is this package found in the Go root?\n-\tStandard    bool   `json:\",omitempty\"` // is this package part of the standard Go library?\n-\tStale       bool   `json:\",omitempty\"` // would 'go install' do anything for this package?\n-\tRoot        string `json:\",omitempty\"` // Go root or Go path dir containing this package\n-\tConflictDir string `json:\",omitempty\"` // Dir is hidden by this other directory\n+\tDir           string `json:\",omitempty\"` // directory containing package sources\n+\tImportPath    string `json:\",omitempty\"` // import path of package in dir\n+\tImportComment string `json:\",omitempty\"` // path in import comment on package statement\n+\tName          string `json:\",omitempty\"` // package name\n+\tDoc           string `json:\",omitempty\"` // package documentation string\n+\tTarget        string `json:\",omitempty\"` // install path\n+\tGoroot        bool   `json:\",omitempty\"` // is this package found in the Go root?\n+\tStandard      bool   `json:\",omitempty\"` // is this package part of the standard Go library?\n+\tStale         bool   `json:\",omitempty\"` // would 'go install' do anything for this package?\n+\tRoot          string `json:\",omitempty\"` // Go root or Go path dir containing this package\n+\tConflictDir   string `json:\",omitempty\"` // Dir is hidden by this other directory\n \n \t// Source files\n \tGoFiles        []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n@@ -103,6 +105,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \n \tp.Dir = pp.Dir\n \tp.ImportPath = pp.ImportPath\n+\tp.ImportComment = pp.ImportComment\n \tp.Name = pp.Name\n \tp.Doc = pp.Doc\n \tp.Root = pp.Root\n@@ -218,7 +221,7 @@ func dirToImportPath(dir string) string {\n }\n \n func makeImportValid(r rune) rune {\n-\t// Should match Go spec, compilers, and ../../pkg/go/parser/parser.go:/isValidImport.\n+\t// Should match Go spec, compilers, and ../../go/parser/parser.go:/isValidImport.\n \tconst illegalChars = `!\"#$%&'()*,:;<=>?[\\]^{|}` + \"`\\uFFFD\"\n \tif !unicode.IsGraphic(r) || unicode.IsSpace(r) || strings.ContainsRune(illegalChars, r) {\n \t\treturn '_'\n@@ -244,6 +247,9 @@ func loadImport(path string, srcDir string, stk *importStack, importPos []token.\n \t\timportPath = dirToImportPath(filepath.Join(srcDir, path))\n \t}\n \tif p := packageCache[importPath]; p != nil {\n+\t\tif perr := disallowInternal(srcDir, p, stk); perr != p {\n+\t\t\treturn perr\n+\t\t}\n \t\treturn reusePackage(p, stk)\n \t}\n \n@@ -258,18 +264,25 @@ func loadImport(path string, srcDir string, stk *importStack, importPos []token.\n \t//\n \t// TODO: After Go 1, decide when to pass build.AllowBinary here.\n \t// See issue 3268 for mistakes to avoid.\n-\tbp, err := buildContext.Import(path, srcDir, 0)\n+\tbp, err := buildContext.Import(path, srcDir, build.ImportComment)\n \tbp.ImportPath = importPath\n \tif gobin != \"\" {\n \t\tbp.BinDir = gobin\n \t}\n+\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path {\n+\t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n+\t}\n \tp.load(stk, bp, err)\n \tif p.Error != nil && len(importPos) > 0 {\n \t\tpos := importPos[0]\n \t\tpos.Filename = shortPath(pos.Filename)\n \t\tp.Error.Pos = pos.String()\n \t}\n \n+\tif perr := disallowInternal(srcDir, p, stk); perr != p {\n+\t\treturn perr\n+\t}\n+\n \treturn p\n }\n \n@@ -298,12 +311,82 @@ func reusePackage(p *Package, stk *importStack) *Package {\n \treturn p\n }\n \n+// disallowInternal checks that srcDir is allowed to import p.\n+// If the import is allowed, disallowInternal returns the original package p.\n+// If not, it returns a new package containing just an appropriate error.\n+func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n+\t// golang.org/s/go14internal:\n+\t// An import of a path containing the element \u201cinternal\u201d\n+\t// is disallowed if the importing code is outside the tree\n+\t// rooted at the parent of the \u201cinternal\u201d directory.\n+\t//\n+\t// ... For Go 1.4, we will implement the rule first for $GOROOT, but not $GOPATH.\n+\n+\t// Only applies to $GOROOT.\n+\tif !p.Standard {\n+\t\treturn p\n+\t}\n+\n+\t// The stack includes p.ImportPath.\n+\t// If that's the only thing on the stack, we started\n+\t// with a name given on the command line, not an\n+\t// import. Anything listed on the command line is fine.\n+\tif len(*stk) == 1 {\n+\t\treturn p\n+\t}\n+\n+\t// Check for \"internal\" element: four cases depending on begin of string and/or end of string.\n+\ti, ok := findInternal(p.ImportPath)\n+\tif !ok {\n+\t\treturn p\n+\t}\n+\n+\t// Internal is present.\n+\t// Map import path back to directory corresponding to parent of internal.\n+\tif i > 0 {\n+\t\ti-- // rewind over slash in \".../internal\"\n+\t}\n+\tparent := p.Dir[:i+len(p.Dir)-len(p.ImportPath)]\n+\tif hasPathPrefix(filepath.ToSlash(srcDir), filepath.ToSlash(parent)) {\n+\t\treturn p\n+\t}\n+\n+\t// Internal is present, and srcDir is outside parent's tree. Not allowed.\n+\tperr := *p\n+\tperr.Error = &PackageError{\n+\t\tImportStack: stk.copy(),\n+\t\tErr:         \"use of internal package not allowed\",\n+\t}\n+\tperr.Incomplete = true\n+\treturn &perr\n+}\n+\n+// findInternal looks for the final \"internal\" path element in the given import path.\n+// If there isn't one, findInternal returns ok=false.\n+// Otherwise, findInternal returns ok=true and the index of the \"internal\".\n+func findInternal(path string) (index int, ok bool) {\n+\t// Four cases, depending on internal at start/end of string or not.\n+\t// The order matters: we must return the index of the final element,\n+\t// because the final one produces the most restrictive requirement\n+\t// on the importer.\n+\tswitch {\n+\tcase strings.HasSuffix(path, \"/internal\"):\n+\t\treturn len(path) - len(\"internal\"), true\n+\tcase strings.Contains(path, \"/internal/\"):\n+\t\treturn strings.LastIndex(path, \"/internal/\") + 1, true\n+\tcase path == \"internal\", strings.HasPrefix(path, \"internal/\"):\n+\t\treturn 0, true\n+\t}\n+\treturn 0, false\n+}\n+\n type targetDir int\n \n const (\n-\ttoRoot targetDir = iota // to bin dir inside package root (default)\n-\ttoTool                  // GOROOT/pkg/tool\n-\ttoBin                   // GOROOT/bin\n+\ttoRoot    targetDir = iota // to bin dir inside package root (default)\n+\ttoTool                     // GOROOT/pkg/tool\n+\ttoBin                      // GOROOT/bin\n+\tstalePath                  // the old import path; fail to build\n )\n \n // goTools is a map of Go program import path to install target directory.\n@@ -316,10 +399,14 @@ var goTools = map[string]targetDir{\n \t\"cmd/nm\":                               toTool,\n \t\"cmd/objdump\":                          toTool,\n \t\"cmd/pack\":                             toTool,\n+\t\"cmd/pprof\":                            toTool,\n \t\"cmd/yacc\":                             toTool,\n-\t\"code.google.com/p/go.tools/cmd/cover\": toTool,\n-\t\"code.google.com/p/go.tools/cmd/godoc\": toBin,\n-\t\"code.google.com/p/go.tools/cmd/vet\":   toTool,\n+\t\"golang.org/x/tools/cmd/cover\":         toTool,\n+\t\"golang.org/x/tools/cmd/godoc\":         toBin,\n+\t\"golang.org/x/tools/cmd/vet\":           toTool,\n+\t\"code.google.com/p/go.tools/cmd/cover\": stalePath,\n+\t\"code.google.com/p/go.tools/cmd/godoc\": stalePath,\n+\t\"code.google.com/p/go.tools/cmd/vet\":   stalePath,\n }\n \n // expandScanner expands a scanner.List error into all the errors in the list.\n@@ -380,6 +467,13 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t}\n \n \tif p.Name == \"main\" {\n+\t\t// Report an error when the old code.google.com/p/go.tools paths are used.\n+\t\tif goTools[p.ImportPath] == stalePath {\n+\t\t\tnewPath := strings.Replace(p.ImportPath, \"code.google.com/p/go.\", \"golang.org/x/\", 1)\n+\t\t\te := fmt.Sprintf(\"the %v command has moved; use %v instead.\", p.ImportPath, newPath)\n+\t\t\tp.Error = &PackageError{Err: e}\n+\t\t\treturn p\n+\t\t}\n \t\t_, elem := filepath.Split(p.Dir)\n \t\tfull := buildContext.GOOS + \"_\" + buildContext.GOARCH + \"/\" + elem\n \t\tif buildContext.GOOS != toolGOOS || buildContext.GOARCH != toolGOARCH {\n@@ -482,7 +576,7 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \n \t// Build list of imported packages and full dependency list.\n \timports := make([]*Package, 0, len(p.Imports))\n-\tdeps := make(map[string]bool)\n+\tdeps := make(map[string]*Package)\n \tfor i, path := range importPaths {\n \t\tif path == \"C\" {\n \t\t\tcontinue\n@@ -505,10 +599,10 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\t\tpath = p1.ImportPath\n \t\t\timportPaths[i] = path\n \t\t}\n-\t\tdeps[path] = true\n+\t\tdeps[path] = p1\n \t\timports = append(imports, p1)\n-\t\tfor _, dep := range p1.Deps {\n-\t\t\tdeps[dep] = true\n+\t\tfor _, dep := range p1.deps {\n+\t\t\tdeps[dep.ImportPath] = dep\n \t\t}\n \t\tif p1.Incomplete {\n \t\t\tp.Incomplete = true\n@@ -522,7 +616,7 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t}\n \tsort.Strings(p.Deps)\n \tfor _, dep := range p.Deps {\n-\t\tp1 := packageCache[dep]\n+\t\tp1 := deps[dep]\n \t\tif p1 == nil {\n \t\t\tpanic(\"impossible: missing entry in package cache for \" + dep + \" imported by \" + p.ImportPath)\n \t\t}\n@@ -538,6 +632,16 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t}\n \tp.Target = p.target\n \n+\t// Check for C code compiled with Plan 9 C compiler.\n+\t// No longer allowed except in runtime and runtime/cgo, for now.\n+\tif len(p.CFiles) > 0 && !p.usesCgo() && (!p.Standard || p.ImportPath != \"runtime\") {\n+\t\tp.Error = &PackageError{\n+\t\t\tImportStack: stk.copy(),\n+\t\t\tErr:         fmt.Sprintf(\"C source files not allowed when not using cgo: %s\", strings.Join(p.CFiles, \" \")),\n+\t\t}\n+\t\treturn p\n+\t}\n+\n \t// In the absence of errors lower in the dependency tree,\n \t// check for case-insensitive collisions of import paths.\n \tif len(p.DepsErrors) == 0 {\n@@ -599,6 +703,12 @@ func computeStale(pkgs ...*Package) {\n \t}\n }\n \n+// The runtime version string takes one of two forms:\n+// \"go1.X[.Y]\" for Go releases, and \"devel +hash\" at tip.\n+// Determine whether we are in a released copy by\n+// inspecting the version.\n+var isGoRelease = strings.HasPrefix(runtime.Version(), \"go1\")\n+\n // isStale reports whether package p needs to be rebuilt.\n func isStale(p *Package, topRoot map[string]bool) bool {\n \tif p.Standard && (p.ImportPath == \"unsafe\" || buildContext.Compiler == \"gccgo\") {\n@@ -619,7 +729,16 @@ func isStale(p *Package, topRoot map[string]bool) bool {\n \t\treturn false\n \t}\n \n-\tif buildA || p.target == \"\" || p.Stale {\n+\t// If we are running a release copy of Go, do not rebuild the standard packages.\n+\t// They may not be writable anyway, but they are certainly not changing.\n+\t// This makes 'go build -a' skip the standard packages when using an official release.\n+\t// See issue 4106 and issue 8290.\n+\tpkgBuildA := buildA\n+\tif p.Standard && isGoRelease {\n+\t\tpkgBuildA = false\n+\t}\n+\n+\tif pkgBuildA || p.target == \"\" || p.Stale {\n \t\treturn true\n \t}\n \n@@ -707,24 +826,13 @@ func loadPackage(arg string, stk *importStack) *Package {\n \t\t\targ = sub\n \t\t}\n \t}\n-\tif strings.HasPrefix(arg, \"cmd/\") {\n+\tif strings.HasPrefix(arg, \"cmd/\") && !strings.Contains(arg[4:], \"/\") {\n \t\tif p := cmdCache[arg]; p != nil {\n \t\t\treturn p\n \t\t}\n \t\tstk.push(arg)\n \t\tdefer stk.pop()\n \n-\t\tif strings.Contains(arg[4:], \"/\") {\n-\t\t\tp := &Package{\n-\t\t\t\tError: &PackageError{\n-\t\t\t\t\tImportStack: stk.copy(),\n-\t\t\t\t\tErr:         fmt.Sprintf(\"invalid import path: cmd/... is reserved for Go commands\"),\n-\t\t\t\t\thard:        true,\n-\t\t\t\t},\n-\t\t\t}\n-\t\t\treturn p\n-\t\t}\n-\n \t\tbp, err := buildContext.ImportDir(filepath.Join(gorootSrc, arg), 0)\n \t\tbp.ImportPath = arg\n \t\tbp.Goroot = true"}, {"sha": "28b46ff52bffd34959dfcba05f96968e8b2dbde0", "filename": "libgo/go/cmd/go/test.go", "status": "modified", "additions": 140, "deletions": 38, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,6 +6,7 @@ package main\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/build\"\n@@ -48,7 +49,7 @@ It prints a summary of the test results in the format:\n followed by detailed output for each failed package.\n \n 'Go test' recompiles each package along with any files with names matching\n-the file pattern \"*_test.go\". \n+the file pattern \"*_test.go\".\n Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n These additional files can contain test functions, benchmark functions, and\n example functions.  See 'go help testfunc' for more.\n@@ -65,16 +66,23 @@ non-test installation.\n \n In addition to the build flags, the flags handled by 'go test' itself are:\n \n-\t-c  Compile the test binary to pkg.test but do not run it.\n-\t    (Where pkg is the last element of the package's import path.)\n+\t-c\n+\t\tCompile the test binary to pkg.test but do not run it\n+\t\t(where pkg is the last element of the package's import path).\n+\t\tThe file name can be changed with the -o flag.\n+\n+\t-exec xprog\n+\t    Run the test binary using xprog. The behavior is the same as\n+\t    in 'go run'. See 'go help run' for details.\n \n \t-i\n \t    Install packages that are dependencies of the test.\n \t    Do not run the test.\n \n-\t-exec xprog\n-\t    Run the test binary using xprog. The behavior is the same as\n-\t    in 'go run'. See 'go help run' for details.\n+\t-o file\n+\t\tCompile the test binary to the named file.\n+\t\tThe test still runs (unless -c or -i is specified).\n+\n \n The test binary also accepts flags that control execution of the test; these\n flags are also accessible by 'go test'.  See 'go help testflag' for details.\n@@ -122,6 +130,7 @@ control the execution of any test:\n \t-blockprofile block.out\n \t    Write a goroutine blocking profile to the specified file\n \t    when all tests are complete.\n+\t    Writes test binary as -c would.\n \n \t-blockprofilerate n\n \t    Control the detail provided in goroutine blocking profiles by\n@@ -153,8 +162,7 @@ control the execution of any test:\n \t    Sets -cover.\n \n \t-coverprofile cover.out\n-\t    Write a coverage profile to the specified file after all tests\n-\t    have passed.\n+\t    Write a coverage profile to the file after all tests have passed.\n \t    Sets -cover.\n \n \t-cpu 1,2,4\n@@ -164,10 +172,11 @@ control the execution of any test:\n \n \t-cpuprofile cpu.out\n \t    Write a CPU profile to the specified file before exiting.\n+\t    Writes test binary as -c would.\n \n \t-memprofile mem.out\n-\t    Write a memory profile to the specified file after all tests\n-\t    have passed.\n+\t    Write a memory profile to the file after all tests have passed.\n+\t    Writes test binary as -c would.\n \n \t-memprofilerate n\n \t    Enable more precise (and expensive) memory profiles by setting\n@@ -274,10 +283,10 @@ var (\n \ttestCoverMode    string     // -covermode flag\n \ttestCoverPaths   []string   // -coverpkg flag\n \ttestCoverPkgs    []*Package // -coverpkg flag\n+\ttestO            string     // -o flag\n \ttestProfile      bool       // some profiling flag\n \ttestNeedBinary   bool       // profile needs to keep binary around\n \ttestV            bool       // -v flag\n-\ttestFiles        []string   // -file flag(s)  TODO: not respected\n \ttestTimeout      string     // -timeout flag\n \ttestArgs         []string\n \ttestBench        bool\n@@ -291,6 +300,7 @@ var testMainDeps = map[string]bool{\n \t// Dependencies for testmain.\n \t\"testing\": true,\n \t\"regexp\":  true,\n+\t\"os\":      true,\n }\n \n func runTest(cmd *Command, args []string) {\n@@ -308,6 +318,9 @@ func runTest(cmd *Command, args []string) {\n \tif testC && len(pkgs) != 1 {\n \t\tfatalf(\"cannot use -c flag with multiple packages\")\n \t}\n+\tif testO != \"\" && len(pkgs) != 1 {\n+\t\tfatalf(\"cannot use -o flag with multiple packages\")\n+\t}\n \tif testProfile && len(pkgs) != 1 {\n \t\tfatalf(\"cannot use test profile flag with multiple packages\")\n \t}\n@@ -524,6 +537,13 @@ func contains(x []string, s string) bool {\n \treturn false\n }\n \n+var windowsBadWords = []string{\n+\t\"install\",\n+\t\"patch\",\n+\t\"setup\",\n+\t\"update\",\n+}\n+\n func (b *builder) test(p *Package) (buildAction, runAction, printAction *action, err error) {\n \tif len(p.TestGoFiles)+len(p.XTestGoFiles) == 0 {\n \t\tbuild := b.action(modeBuild, modeBuild, p)\n@@ -695,7 +715,7 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\tomitDWARF:  !testC && !testNeedBinary,\n \t}\n \n-\t// The generated main also imports testing and regexp.\n+\t// The generated main also imports testing, regexp, and os.\n \tstk.push(\"testmain\")\n \tfor dep := range testMainDeps {\n \t\tif dep == ptest.ImportPath {\n@@ -734,11 +754,13 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \tif err != nil {\n \t\treturn nil, nil, nil, err\n \t}\n-\tif t.NeedTest || ptest.coverMode != \"\" {\n+\tif len(ptest.GoFiles) > 0 {\n \t\tpmain.imports = append(pmain.imports, ptest)\n+\t\tt.ImportTest = true\n \t}\n-\tif t.NeedXtest {\n+\tif pxtest != nil {\n \t\tpmain.imports = append(pmain.imports, pxtest)\n+\t\tt.ImportXtest = true\n \t}\n \n \tif ptest != p && localCover {\n@@ -790,25 +812,62 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \ta.objdir = testDir + string(filepath.Separator)\n \ta.objpkg = filepath.Join(testDir, \"main.a\")\n \ta.target = filepath.Join(testDir, testBinary) + exeSuffix\n-\tpmainAction := a\n+\tif goos == \"windows\" {\n+\t\t// There are many reserved words on Windows that,\n+\t\t// if used in the name of an executable, cause Windows\n+\t\t// to try to ask for extra permissions.\n+\t\t// The word list includes setup, install, update, and patch,\n+\t\t// but it does not appear to be defined anywhere.\n+\t\t// We have run into this trying to run the\n+\t\t// go.codereview/patch tests.\n+\t\t// For package names containing those words, use test.test.exe\n+\t\t// instead of pkgname.test.exe.\n+\t\t// Note that this file name is only used in the Go command's\n+\t\t// temporary directory. If the -c or other flags are\n+\t\t// given, the code below will still use pkgname.test.exe.\n+\t\t// There are two user-visible effects of this change.\n+\t\t// First, you can actually run 'go test' in directories that\n+\t\t// have names that Windows thinks are installer-like,\n+\t\t// without getting a dialog box asking for more permissions.\n+\t\t// Second, in the Windows process listing during go test,\n+\t\t// the test shows up as test.test.exe, not pkgname.test.exe.\n+\t\t// That second one is a drawback, but it seems a small\n+\t\t// price to pay for the test running at all.\n+\t\t// If maintaining the list of bad words is too onerous,\n+\t\t// we could just do this always on Windows.\n+\t\tfor _, bad := range windowsBadWords {\n+\t\t\tif strings.Contains(testBinary, bad) {\n+\t\t\t\ta.target = filepath.Join(testDir, \"test.test\") + exeSuffix\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\tbuildAction = a\n \n \tif testC || testNeedBinary {\n \t\t// -c or profiling flag: create action to copy binary to ./test.out.\n-\t\trunAction = &action{\n+\t\ttarget := filepath.Join(cwd, testBinary+exeSuffix)\n+\t\tif testO != \"\" {\n+\t\t\ttarget = testO\n+\t\t\tif !filepath.IsAbs(target) {\n+\t\t\t\ttarget = filepath.Join(cwd, target)\n+\t\t\t}\n+\t\t}\n+\t\tbuildAction = &action{\n \t\t\tf:      (*builder).install,\n-\t\t\tdeps:   []*action{pmainAction},\n+\t\t\tdeps:   []*action{buildAction},\n \t\t\tp:      pmain,\n-\t\t\ttarget: filepath.Join(cwd, testBinary+exeSuffix),\n+\t\t\ttarget: target,\n \t\t}\n-\t\tpmainAction = runAction // in case we are running the test\n+\t\trunAction = buildAction // make sure runAction != nil even if not running test\n \t}\n \tif testC {\n \t\tprintAction = &action{p: p, deps: []*action{runAction}} // nop\n \t} else {\n \t\t// run test\n \t\trunAction = &action{\n \t\t\tf:          (*builder).runTest,\n-\t\t\tdeps:       []*action{pmainAction},\n+\t\t\tdeps:       []*action{buildAction},\n \t\t\tp:          p,\n \t\t\tignoreFail: true,\n \t\t}\n@@ -824,7 +883,7 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\t}\n \t}\n \n-\treturn pmainAction, runAction, printAction, nil\n+\treturn buildAction, runAction, printAction, nil\n }\n \n func testImportStack(top string, p *Package, target string) []string {\n@@ -1068,6 +1127,31 @@ func (b *builder) notest(a *action) error {\n \treturn nil\n }\n \n+// isTestMain tells whether fn is a TestMain(m *testing.M) function.\n+func isTestMain(fn *ast.FuncDecl) bool {\n+\tif fn.Name.String() != \"TestMain\" ||\n+\t\tfn.Type.Results != nil && len(fn.Type.Results.List) > 0 ||\n+\t\tfn.Type.Params == nil ||\n+\t\tlen(fn.Type.Params.List) != 1 ||\n+\t\tlen(fn.Type.Params.List[0].Names) > 1 {\n+\t\treturn false\n+\t}\n+\tptr, ok := fn.Type.Params.List[0].Type.(*ast.StarExpr)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\t// We can't easily check that the type is *testing.M\n+\t// because we don't know how testing has been imported,\n+\t// but at least check that it's *M or *something.M.\n+\tif name, ok := ptr.X.(*ast.Ident); ok && name.Name == \"M\" {\n+\t\treturn true\n+\t}\n+\tif sel, ok := ptr.X.(*ast.SelectorExpr); ok && sel.Sel.Name == \"M\" {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // isTest tells whether name looks like a test (or benchmark, according to prefix).\n // It is a Test (say) if there is a character after Test that is not a lower-case letter.\n // We don't want TesticularCancer.\n@@ -1093,12 +1177,12 @@ func loadTestFuncs(ptest *Package) (*testFuncs, error) {\n \t\tPackage: ptest,\n \t}\n \tfor _, file := range ptest.TestGoFiles {\n-\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_test\", &t.NeedTest); err != nil {\n+\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_test\", &t.ImportTest, &t.NeedTest); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}\n \tfor _, file := range ptest.XTestGoFiles {\n-\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_xtest\", &t.NeedXtest); err != nil {\n+\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_xtest\", &t.ImportXtest, &t.NeedXtest); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}\n@@ -1121,13 +1205,16 @@ func writeTestmain(out string, t *testFuncs) error {\n }\n \n type testFuncs struct {\n-\tTests      []testFunc\n-\tBenchmarks []testFunc\n-\tExamples   []testFunc\n-\tPackage    *Package\n-\tNeedTest   bool\n-\tNeedXtest  bool\n-\tCover      []coverInfo\n+\tTests       []testFunc\n+\tBenchmarks  []testFunc\n+\tExamples    []testFunc\n+\tTestMain    *testFunc\n+\tPackage     *Package\n+\tImportTest  bool\n+\tNeedTest    bool\n+\tImportXtest bool\n+\tNeedXtest   bool\n+\tCover       []coverInfo\n }\n \n func (t *testFuncs) CoverMode() string {\n@@ -1162,7 +1249,7 @@ type testFunc struct {\n \n var testFileSet = token.NewFileSet()\n \n-func (t *testFuncs) load(filename, pkg string, seen *bool) error {\n+func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n \tf, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)\n \tif err != nil {\n \t\treturn expandScanner(err)\n@@ -1177,17 +1264,24 @@ func (t *testFuncs) load(filename, pkg string, seen *bool) error {\n \t\t}\n \t\tname := n.Name.String()\n \t\tswitch {\n+\t\tcase isTestMain(n):\n+\t\t\tif t.TestMain != nil {\n+\t\t\t\treturn errors.New(\"multiple definitions of TestMain\")\n+\t\t\t}\n+\t\t\tt.TestMain = &testFunc{pkg, name, \"\"}\n+\t\t\t*doImport, *seen = true, true\n \t\tcase isTest(name, \"Test\"):\n \t\t\tt.Tests = append(t.Tests, testFunc{pkg, name, \"\"})\n-\t\t\t*seen = true\n+\t\t\t*doImport, *seen = true, true\n \t\tcase isTest(name, \"Benchmark\"):\n \t\t\tt.Benchmarks = append(t.Benchmarks, testFunc{pkg, name, \"\"})\n-\t\t\t*seen = true\n+\t\t\t*doImport, *seen = true, true\n \t\t}\n \t}\n \tex := doc.Examples(f)\n \tsort.Sort(byOrder(ex))\n \tfor _, e := range ex {\n+\t\t*doImport = true // import test file whether executed or not\n \t\tif e.Output == \"\" && !e.EmptyOutput {\n \t\t\t// Don't run examples with no output.\n \t\t\tcontinue\n@@ -1208,14 +1302,17 @@ var testmainTmpl = template.Must(template.New(\"main\").Parse(`\n package main\n \n import (\n+{{if not .TestMain}}\n+\t\"os\"\n+{{end}}\n \t\"regexp\"\n \t\"testing\"\n \n-{{if .NeedTest}}\n-\t_test {{.Package.ImportPath | printf \"%q\"}}\n+{{if .ImportTest}}\n+\t{{if .NeedTest}}_test{{else}}_{{end}} {{.Package.ImportPath | printf \"%q\"}}\n {{end}}\n-{{if .NeedXtest}}\n-\t_xtest {{.Package.ImportPath | printf \"%s_test\" | printf \"%q\"}}\n+{{if .ImportXtest}}\n+\t{{if .NeedXtest}}_xtest{{else}}_{{end}} {{.Package.ImportPath | printf \"%s_test\" | printf \"%q\"}}\n {{end}}\n {{range $i, $p := .Cover}}\n \t_cover{{$i}} {{$p.Package.ImportPath | printf \"%q\"}}\n@@ -1302,7 +1399,12 @@ func main() {\n \t\tCoveredPackages: {{printf \"%q\" .Covered}},\n \t})\n {{end}}\n-\ttesting.Main(matchString, tests, benchmarks, examples)\n+\tm := testing.MainStart(matchString, tests, benchmarks, examples)\n+{{with .TestMain}}\n+\t{{.Package}}.{{.Name}}(m)\n+{{else}}\n+\tos.Exit(m.Run())\n+{{end}}\n }\n \n `))"}, {"sha": "1f05734f04f5bcbcf573e9a43168150ff265c1ab", "filename": "libgo/go/cmd/go/testdata/generate/test1.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest1.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Simple test for go generate.\n+\n+// We include a build tag that go generate should ignore.\n+\n+// +build ignore\n+\n+//go:generate echo Success\n+\n+package p"}, {"sha": "ef1a3d9515903d7481b60bf1631e3560b3195cda", "filename": "libgo/go/cmd/go/testdata/generate/test2.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest2.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that go generate handles command aliases.\n+\n+//go:generate -command run echo Now is the time\n+//go:generate run for all good men\n+\n+package p"}, {"sha": "41ffb7ea87f3c214e8c69d6ac01005ad06289b35", "filename": "libgo/go/cmd/go/testdata/generate/test3.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fgenerate%2Ftest3.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test go generate variable substitution.\n+\n+//go:generate echo $GOARCH $GOFILE $GOPACKAGE xyz$GOPACKAGE/$GOFILE/123\n+\n+package p"}, {"sha": "e104c2e992b35026a3cece0a4e41ca42b6a26abd", "filename": "libgo/go/cmd/go/testdata/importcom/bad.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fbad.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+import \"bad\""}, {"sha": "995556c51148eec79bf7d4332159fe5cab15238d", "filename": "libgo/go/cmd/go/testdata/importcom/conflict.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fconflict.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fconflict.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fconflict.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+import \"conflict\""}, {"sha": "bc51fd3fdeeb120877a927a0548dcd0f94e3aadb", "filename": "libgo/go/cmd/go/testdata/importcom/src/bad/bad.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fbad%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fbad%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fbad%2Fbad.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package bad // import"}, {"sha": "2d677035119bab23b86a306ef0d0f9a0a0e8d25c", "filename": "libgo/go/cmd/go/testdata/importcom/src/conflict/a.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fa.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package conflict // import \"a\""}, {"sha": "8fcfb3c8bd3c7f39844814b434a3aa92b34d62a2", "filename": "libgo/go/cmd/go/testdata/importcom/src/conflict/b.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fb.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package conflict /* import \"b\" */"}, {"sha": "044c6eca803b62bca73e737d2c06fb037400014f", "filename": "libgo/go/cmd/go/testdata/importcom/src/works/x/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package x // import \"works/x\""}, {"sha": "2449b29df51ef066e551ef72d9f7d17ce68a571f", "filename": "libgo/go/cmd/go/testdata/importcom/src/works/x/x1.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx1.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package x // important! not an import comment"}, {"sha": "b89849da78598b01ec6bfdca94fc4355f5174c8d", "filename": "libgo/go/cmd/go/testdata/importcom/src/wrongplace/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fwrongplace%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fwrongplace%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fwrongplace%2Fx.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package x // import \"my/x\""}, {"sha": "31b55d08a37f08e425e06c082bc2dd476b7d2c26", "filename": "libgo/go/cmd/go/testdata/importcom/works.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fworks.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fworks.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fworks.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+import _ \"works/x\""}, {"sha": "e2535e01ae0efbb973995828a5a5cbd2b107d8bd", "filename": "libgo/go/cmd/go/testdata/importcom/wrongplace.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fwrongplace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fwrongplace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fwrongplace.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+import \"wrongplace\""}, {"sha": "e158305a6c8cd93adf036b2f6234d3b88f98021d", "filename": "libgo/go/cmd/go/testdata/norunexample/example_test.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Fexample_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,11 @@\n+package pkg_test\n+\n+import \"os\"\n+\n+func init() {\n+\tos.Stdout.Write([]byte(\"File with non-runnable example was built.\\n\"))\n+}\n+\n+func Example_test() {\n+\t// This test will not be run, it has no \"Output:\" comment.\n+}"}, {"sha": "d2e919838fb571404999ae2c71ddeb5e6766bd6a", "filename": "libgo/go/cmd/go/testdata/norunexample/test_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fnorunexample%2Ftest_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,10 @@\n+package pkg\n+\n+import (\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestBuilt(t *testing.T) {\n+\tos.Stdout.Write([]byte(\"A normal test was executed.\\n\"))\n+}"}, {"sha": "bfa1de28bde5178ac93b88b3153efaa6cc56b9cc", "filename": "libgo/go/cmd/go/testdata/src/badc/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package badc"}, {"sha": "12f50517125a3d91b4977bab24f4d67834bb9a7c", "filename": "libgo/go/cmd/go/testdata/src/badtest/badexec/x_test.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadexec%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadexec%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadexec%2Fx_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,5 @@\n+package badexec\n+\n+func init() {\n+\tpanic(\"badexec\")\n+}"}, {"sha": "c8a5407a5ace027072b0678d611f63e5b3449b85", "filename": "libgo/go/cmd/go/testdata/src/badtest/badsyntax/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadsyntax%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadsyntax%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadsyntax%2Fx.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package badsyntax"}, {"sha": "5be10745d9b874c15f72e86e7b90eca66c9738e4", "filename": "libgo/go/cmd/go/testdata/src/badtest/badsyntax/x_test.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadsyntax%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadsyntax%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadsyntax%2Fx_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,3 @@\n+package badsyntax\n+\n+func func func func func!"}, {"sha": "fdd46c4c721cb6e4356f4dea562a851b718a9d50", "filename": "libgo/go/cmd/go/testdata/src/badtest/badvar/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadvar%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadvar%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadvar%2Fx.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package badvar"}, {"sha": "c67df01c5cac251e47f7a2ac957ca129cd9b67aa", "filename": "libgo/go/cmd/go/testdata/src/badtest/badvar/x_test.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadvar%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadvar%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadtest%2Fbadvar%2Fx_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,5 @@\n+package badvar_test\n+\n+func f() {\n+\t_ = notdefined\n+}"}, {"sha": "9b64e8e1a26912848f4e8069783f060c94be47c6", "filename": "libgo/go/cmd/go/testdata/src/vetpkg/a_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fa_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package p_test"}, {"sha": "99e18f63dc65aaf4bad40464f0c89cc3f8dc75bb", "filename": "libgo/go/cmd/go/testdata/src/vetpkg/b.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetpkg%2Fb.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,7 @@\n+package p\n+\n+import \"fmt\"\n+\n+func f() {\n+\tfmt.Printf(\"%d\")\n+}"}, {"sha": "e3558a53b244276b9ba1bf0867a04e5ad2057743", "filename": "libgo/go/cmd/go/testdata/testinternal/p.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal%2Fp.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+import _ \"net/http/internal\""}, {"sha": "c594f5c5e9effc9e9ea56692b4c71c84d76f2c1b", "filename": "libgo/go/cmd/go/testdata/testinternal2/p.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fp.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+import _ \"./x/y/z/internal/w\""}, {"sha": "a796c0b5f4b14f82d3cc4417a0d14c9a96fa1019", "filename": "libgo/go/cmd/go/testdata/testinternal2/x/y/z/internal/w/w.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fx%2Fy%2Fz%2Finternal%2Fw%2Fw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fx%2Fy%2Fz%2Finternal%2Fw%2Fw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestinternal2%2Fx%2Fy%2Fz%2Finternal%2Fw%2Fw.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1 @@\n+package w"}, {"sha": "6da74b99677f92be2f09f15809d13130d47d8a06", "filename": "libgo/go/cmd/go/testflag.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -65,9 +65,9 @@ type testFlagSpec struct {\n var testFlagDefn = []*testFlagSpec{\n \t// local.\n \t{name: \"c\", boolVar: &testC},\n-\t{name: \"file\", multiOK: true},\n \t{name: \"cover\", boolVar: &testCover},\n \t{name: \"coverpkg\"},\n+\t{name: \"o\"},\n \n \t// build flags.\n \t{name: \"a\", boolVar: &buildA},\n@@ -153,6 +153,9 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\t// bool flags.\n \t\tcase \"a\", \"c\", \"i\", \"n\", \"x\", \"v\", \"race\", \"cover\", \"work\":\n \t\t\tsetBoolFlag(f.boolVar, value)\n+\t\tcase \"o\":\n+\t\t\ttestO = value\n+\t\t\ttestNeedBinary = true\n \t\tcase \"p\":\n \t\t\tsetIntFlag(&buildP, value)\n \t\tcase \"exec\":\n@@ -184,8 +187,6 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\t\tbuildContext.BuildTags = strings.Fields(value)\n \t\tcase \"compiler\":\n \t\t\tbuildCompiler{}.Set(value)\n-\t\tcase \"file\":\n-\t\t\ttestFiles = append(testFiles, value)\n \t\tcase \"bench\":\n \t\t\t// record that we saw the flag; don't care about the value\n \t\t\ttestBench = true"}, {"sha": "01923f74bdff7653e4de02d9b8f3ffad0b588695", "filename": "libgo/go/cmd/go/testgo.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestgo.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file contains extra hooks for testing the go command.\n+// It is compiled into the Go binary only when building the\n+// test copy; it does not get compiled into the standard go\n+// command, so these testing hooks are not present in the\n+// go command that everyone uses.\n+\n+// +build testgo\n+\n+package main\n+\n+import \"os\"\n+\n+func init() {\n+\tif v := os.Getenv(\"TESTGO_IS_GO_RELEASE\"); v != \"\" {\n+\t\tisGoRelease = v == \"1\"\n+\t}\n+}"}, {"sha": "3f11c3e3d44a4c9cb70d56749f72570c7c4a3324", "filename": "libgo/go/cmd/go/tool.go", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -47,13 +47,13 @@ const toolWindowsExtension = \".exe\"\n \n func tool(toolName string) string {\n \ttoolPath := filepath.Join(toolDir, toolName)\n-\tif toolIsWindows && toolName != \"pprof\" {\n+\tif toolIsWindows {\n \t\ttoolPath += toolWindowsExtension\n \t}\n \t// Give a nice message if there is no tool with that name.\n \tif _, err := os.Stat(toolPath); err != nil {\n \t\tif isInGoToolsRepo(toolName) {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q; to install:\\n\\tgo get code.google.com/p/go.tools/cmd/%s\\n\", toolName, toolName)\n+\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q; to install:\\n\\tgo get golang.org/x/tools/cmd/%s\\n\", toolName, toolName)\n \t\t} else {\n \t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q\\n\", toolName)\n \t\t}\n@@ -91,16 +91,6 @@ func runTool(cmd *Command, args []string) {\n \tif toolPath == \"\" {\n \t\treturn\n \t}\n-\tif toolIsWindows && toolName == \"pprof\" {\n-\t\targs = append([]string{\"perl\", toolPath}, args[1:]...)\n-\t\tvar err error\n-\t\ttoolPath, err = exec.LookPath(\"perl\")\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go tool: perl not found\\n\")\n-\t\t\tsetExitStatus(3)\n-\t\t\treturn\n-\t\t}\n-\t}\n \tif toolN {\n \t\tfmt.Printf(\"%s %s\\n\", toolPath, strings.Join(args[1:], \" \"))\n \t\treturn"}, {"sha": "1cac6133889be6e4724cb3899e9f2306066dbf8c", "filename": "libgo/go/cmd/go/vcs.go", "status": "modified", "additions": 138, "deletions": 11, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -33,6 +33,9 @@ type vcsCmd struct {\n \n \tscheme  []string\n \tpingCmd string\n+\n+\tremoteRepo  func(v *vcsCmd, rootDir string) (remoteRepo string, err error)\n+\tresolveRepo func(v *vcsCmd, rootDir, remoteRepo string) (realRepo string, err error)\n }\n \n // A tagCmd describes a command to list available tags\n@@ -81,8 +84,17 @@ var vcsHg = &vcsCmd{\n \ttagSyncCmd:     \"update -r {tag}\",\n \ttagSyncDefault: \"update default\",\n \n-\tscheme:  []string{\"https\", \"http\", \"ssh\"},\n-\tpingCmd: \"identify {scheme}://{repo}\",\n+\tscheme:     []string{\"https\", \"http\", \"ssh\"},\n+\tpingCmd:    \"identify {scheme}://{repo}\",\n+\tremoteRepo: hgRemoteRepo,\n+}\n+\n+func hgRemoteRepo(vcsHg *vcsCmd, rootDir string) (remoteRepo string, err error) {\n+\tout, err := vcsHg.runOutput(rootDir, \"paths default\")\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn strings.TrimSpace(string(out)), nil\n }\n \n // vcsGit describes how to use Git.\n@@ -104,8 +116,38 @@ var vcsGit = &vcsCmd{\n \ttagSyncCmd:     \"checkout {tag}\",\n \ttagSyncDefault: \"checkout master\",\n \n-\tscheme:  []string{\"git\", \"https\", \"http\", \"git+ssh\"},\n-\tpingCmd: \"ls-remote {scheme}://{repo}\",\n+\tscheme:     []string{\"git\", \"https\", \"http\", \"git+ssh\"},\n+\tpingCmd:    \"ls-remote {scheme}://{repo}\",\n+\tremoteRepo: gitRemoteRepo,\n+}\n+\n+func gitRemoteRepo(vcsGit *vcsCmd, rootDir string) (remoteRepo string, err error) {\n+\toutb, err := vcsGit.runOutput(rootDir, \"remote -v\")\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tout := string(outb)\n+\n+\t// Expect:\n+\t// origin\thttps://github.com/rsc/pdf (fetch)\n+\t// origin\thttps://github.com/rsc/pdf (push)\n+\t// use first line only.\n+\n+\tif !strings.HasPrefix(out, \"origin\\t\") {\n+\t\treturn \"\", fmt.Errorf(\"unable to parse output of git remote -v\")\n+\t}\n+\tout = strings.TrimPrefix(out, \"origin\\t\")\n+\ti := strings.Index(out, \"\\n\")\n+\tif i < 0 {\n+\t\treturn \"\", fmt.Errorf(\"unable to parse output of git remote -v\")\n+\t}\n+\tout = out[:i]\n+\ti = strings.LastIndex(out, \" \")\n+\tif i < 0 {\n+\t\treturn \"\", fmt.Errorf(\"unable to parse output of git remote -v\")\n+\t}\n+\tout = out[:i]\n+\treturn strings.TrimSpace(string(out)), nil\n }\n \n // vcsBzr describes how to use Bazaar.\n@@ -123,8 +165,51 @@ var vcsBzr = &vcsCmd{\n \ttagSyncCmd:     \"update -r {tag}\",\n \ttagSyncDefault: \"update -r revno:-1\",\n \n-\tscheme:  []string{\"https\", \"http\", \"bzr\", \"bzr+ssh\"},\n-\tpingCmd: \"info {scheme}://{repo}\",\n+\tscheme:      []string{\"https\", \"http\", \"bzr\", \"bzr+ssh\"},\n+\tpingCmd:     \"info {scheme}://{repo}\",\n+\tremoteRepo:  bzrRemoteRepo,\n+\tresolveRepo: bzrResolveRepo,\n+}\n+\n+func bzrRemoteRepo(vcsBzr *vcsCmd, rootDir string) (remoteRepo string, err error) {\n+\toutb, err := vcsBzr.runOutput(rootDir, \"config parent_location\")\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn strings.TrimSpace(string(outb)), nil\n+}\n+\n+func bzrResolveRepo(vcsBzr *vcsCmd, rootDir, remoteRepo string) (realRepo string, err error) {\n+\toutb, err := vcsBzr.runOutput(rootDir, \"info \"+remoteRepo)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tout := string(outb)\n+\n+\t// Expect:\n+\t// ...\n+\t//   (branch root|repository branch): <URL>\n+\t// ...\n+\n+\tfound := false\n+\tfor _, prefix := range []string{\"\\n  branch root: \", \"\\n  repository branch: \"} {\n+\t\ti := strings.Index(out, prefix)\n+\t\tif i >= 0 {\n+\t\t\tout = out[i+len(prefix):]\n+\t\t\tfound = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif !found {\n+\t\treturn \"\", fmt.Errorf(\"unable to parse output of bzr info\")\n+\t}\n+\n+\ti := strings.Index(out, \"\\n\")\n+\tif i < 0 {\n+\t\treturn \"\", fmt.Errorf(\"unable to parse output of bzr info\")\n+\t}\n+\tout = out[:i]\n+\treturn strings.TrimSpace(string(out)), nil\n }\n \n // vcsSvn describes how to use Subversion.\n@@ -138,8 +223,34 @@ var vcsSvn = &vcsCmd{\n \t// There is no tag command in subversion.\n \t// The branch information is all in the path names.\n \n-\tscheme:  []string{\"https\", \"http\", \"svn\", \"svn+ssh\"},\n-\tpingCmd: \"info {scheme}://{repo}\",\n+\tscheme:     []string{\"https\", \"http\", \"svn\", \"svn+ssh\"},\n+\tpingCmd:    \"info {scheme}://{repo}\",\n+\tremoteRepo: svnRemoteRepo,\n+}\n+\n+func svnRemoteRepo(vcsSvn *vcsCmd, rootDir string) (remoteRepo string, err error) {\n+\toutb, err := vcsSvn.runOutput(rootDir, \"info\")\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tout := string(outb)\n+\n+\t// Expect:\n+\t// ...\n+\t// Repository Root: <URL>\n+\t// ...\n+\n+\ti := strings.Index(out, \"\\nRepository Root: \")\n+\tif i < 0 {\n+\t\treturn \"\", fmt.Errorf(\"unable to parse output of svn info\")\n+\t}\n+\tout = out[i+len(\"\\nRepository Root: \"):]\n+\ti = strings.Index(out, \"\\n\")\n+\tif i < 0 {\n+\t\treturn \"\", fmt.Errorf(\"unable to parse output of svn info\")\n+\t}\n+\tout = out[:i]\n+\treturn strings.TrimSpace(string(out)), nil\n }\n \n func (v *vcsCmd) String() string {\n@@ -361,7 +472,14 @@ var httpPrefixRE = regexp.MustCompile(`^https?:`)\n func repoRootForImportPath(importPath string) (*repoRoot, error) {\n \trr, err := repoRootForImportPathStatic(importPath, \"\")\n \tif err == errUnknownSite {\n-\t\trr, err = repoRootForImportDynamic(importPath)\n+\t\t// If there are wildcards, look up the thing before the wildcard,\n+\t\t// hoping it applies to the wildcarded parts too.\n+\t\t// This makes 'go get rsc.io/pdf/...' work in a fresh GOPATH.\n+\t\tlookup := strings.TrimSuffix(importPath, \"/...\")\n+\t\tif i := strings.Index(lookup, \"/.../\"); i >= 0 {\n+\t\t\tlookup = lookup[:i]\n+\t\t}\n+\t\trr, err = repoRootForImportDynamic(lookup)\n \n \t\t// repoRootForImportDynamic returns error detail\n \t\t// that is irrelevant if the user didn't intend to use a\n@@ -465,11 +583,11 @@ func repoRootForImportPathStatic(importPath, scheme string) (*repoRoot, error) {\n func repoRootForImportDynamic(importPath string) (*repoRoot, error) {\n \tslash := strings.Index(importPath, \"/\")\n \tif slash < 0 {\n-\t\treturn nil, errors.New(\"import path doesn't contain a slash\")\n+\t\treturn nil, errors.New(\"import path does not contain a slash\")\n \t}\n \thost := importPath[:slash]\n \tif !strings.Contains(host, \".\") {\n-\t\treturn nil, errors.New(\"import path doesn't contain a hostname\")\n+\t\treturn nil, errors.New(\"import path does not begin with hostname\")\n \t}\n \turlStr, body, err := httpsOrHTTP(importPath)\n \tif err != nil {\n@@ -613,6 +731,15 @@ var vcsPaths = []*vcsPath{\n \t\tcheck:  launchpadVCS,\n \t},\n \n+\t// IBM DevOps Services (JazzHub)\n+\t{\n+\t\tprefix: \"hub.jazz.net/git\",\n+\t\tre:     `^(?P<root>hub.jazz.net/git/[a-z0-9]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tvcs:    \"git\",\n+\t\trepo:   \"https://{root}\",\n+\t\tcheck:  noVCSSuffix,\n+\t},\n+\n \t// General syntax for any server.\n \t{\n \t\tre:   `^(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?/[A-Za-z0-9_.\\-/]*?)\\.(?P<vcs>bzr|git|hg|svn))(/[A-Za-z0-9_.\\-]+)*$`,"}, {"sha": "14d681ba6afc5e1f88f566a27322874c53e77ed1", "filename": "libgo/go/cmd/go/vcs_test.go", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+// Test that RepoRootForImportPath creates the correct RepoRoot for a given importPath.\n+// TODO(cmang): Add tests for SVN and BZR.\n+func TestRepoRootForImportPath(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping test to avoid external network\")\n+\t}\n+\tswitch runtime.GOOS {\n+\tcase \"nacl\", \"android\":\n+\t\tt.Skipf(\"no networking available on %s\", runtime.GOOS)\n+\t}\n+\ttests := []struct {\n+\t\tpath string\n+\t\twant *repoRoot\n+\t}{\n+\t\t{\n+\t\t\t\"code.google.com/p/go\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsHg,\n+\t\t\t\trepo: \"https://code.google.com/p/go\",\n+\t\t\t},\n+\t\t},\n+\t\t/*{\n+\t\t        \"code.google.com/r/go\",\n+\t\t        &repoRoot{\n+\t\t                vcs:  vcsHg,\n+\t\t                repo: \"https://code.google.com/r/go\",\n+\t\t        },\n+\t\t},*/\n+\t\t{\n+\t\t\t\"github.com/golang/groupcache\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://github.com/golang/groupcache\",\n+\t\t\t},\n+\t\t},\n+\t\t// IBM DevOps Services tests\n+\t\t{\n+\t\t\t\"hub.jazz.net/git/user1/pkgname\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://hub.jazz.net/git/user1/pkgname\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"hub.jazz.net/git/user1/pkgname/submodule/submodule/submodule\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://hub.jazz.net/git/user1/pkgname\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"hub.jazz.net\",\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"hub2.jazz.net\",\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"hub.jazz.net/someotherprefix\",\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"hub.jazz.net/someotherprefix/user1/pkgname\",\n+\t\t\tnil,\n+\t\t},\n+\t\t// Spaces are not valid in user names or package names\n+\t\t{\n+\t\t\t\"hub.jazz.net/git/User 1/pkgname\",\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"hub.jazz.net/git/user1/pkg name\",\n+\t\t\tnil,\n+\t\t},\n+\t\t// Dots are not valid in user names\n+\t\t{\n+\t\t\t\"hub.jazz.net/git/user.1/pkgname\",\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"hub.jazz.net/git/user/pkg.name\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://hub.jazz.net/git/user/pkg.name\",\n+\t\t\t},\n+\t\t},\n+\t\t// User names cannot have uppercase letters\n+\t\t{\n+\t\t\t\"hub.jazz.net/git/USER/pkgname\",\n+\t\t\tnil,\n+\t\t},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\tgot, err := repoRootForImportPath(test.path)\n+\t\twant := test.want\n+\n+\t\tif want == nil {\n+\t\t\tif err == nil {\n+\t\t\t\tt.Errorf(\"RepoRootForImport(%q): Error expected but not received\", test.path)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"RepoRootForImport(%q): %v\", test.path, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif got.vcs.name != want.vcs.name || got.repo != want.repo {\n+\t\t\tt.Errorf(\"RepoRootForImport(%q) = VCS(%s) Repo(%s), want VCS(%s) Repo(%s)\", test.path, got.vcs, got.repo, want.vcs, want.repo)\n+\t\t}\n+\t}\n+}"}, {"sha": "02ff54b2ac89ce93c42f57ce6b8ca739a848c05b", "filename": "libgo/go/cmd/go/vet.go", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -4,6 +4,8 @@\n \n package main\n \n+import \"path/filepath\"\n+\n func init() {\n \taddBuildFlagsNX(cmdVet)\n }\n@@ -15,7 +17,7 @@ var cmdVet = &Command{\n \tLong: `\n Vet runs the Go vet command on the packages named by the import paths.\n \n-For more about vet, see 'godoc code.google.com/p/go.tools/cmd/vet'.\n+For more about vet, see 'godoc golang.org/x/tools/cmd/vet'.\n For more about specifying packages, see 'go help packages'.\n \n To run the vet tool with specific options, run 'go tool vet'.\n@@ -28,10 +30,21 @@ See also: go fmt, go fix.\n }\n \n func runVet(cmd *Command, args []string) {\n-\tfor _, pkg := range packages(args) {\n-\t\t// Use pkg.gofiles instead of pkg.Dir so that\n-\t\t// the command only applies to this package,\n-\t\t// not to packages in subdirectories.\n-\t\trun(tool(\"vet\"), relPaths(stringList(pkg.gofiles, pkg.sfiles)))\n+\tfor _, p := range packages(args) {\n+\t\t// Vet expects to be given a set of files all from the same package.\n+\t\t// Run once for package p and once for package p_test.\n+\t\tif len(p.GoFiles)+len(p.CgoFiles)+len(p.TestGoFiles) > 0 {\n+\t\t\trunVetFiles(p, stringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.SFiles))\n+\t\t}\n+\t\tif len(p.XTestGoFiles) > 0 {\n+\t\t\trunVetFiles(p, stringList(p.XTestGoFiles))\n+\t\t}\n+\t}\n+}\n+\n+func runVetFiles(p *Package, files []string) {\n+\tfor i := range files {\n+\t\tfiles[i] = filepath.Join(p.Dir, files[i])\n \t}\n+\trun(tool(\"vet\"), relPaths(files))\n }"}, {"sha": "3fc0439548f675692ff0f6db9d66012e91f4117a", "filename": "libgo/go/cmd/gofmt/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -67,7 +67,7 @@ To remove the parentheses:\n \n To convert the package tree from explicit slice upper bounds to implicit ones:\n \n-\tgofmt -r '\u03b1[\u03b2:len(\u03b1)] -> \u03b1[\u03b2:]' -w $GOROOT/src/pkg\n+\tgofmt -r '\u03b1[\u03b2:len(\u03b1)] -> \u03b1[\u03b2:]' -w $GOROOT/src\n \n The simplify command\n "}, {"sha": "81da21ff109ac862045f92678437d57351546d57", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 118, "deletions": 75, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -87,13 +87,13 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error\n \t\treturn err\n \t}\n \n-\tfile, adjust, err := parse(fileSet, filename, src, stdin)\n+\tfile, sourceAdj, indentAdj, err := parse(fileSet, filename, src, stdin)\n \tif err != nil {\n \t\treturn err\n \t}\n \n \tif rewrite != nil {\n-\t\tif adjust == nil {\n+\t\tif sourceAdj == nil {\n \t\t\tfile = rewrite(file)\n \t\t} else {\n \t\t\tfmt.Fprintf(os.Stderr, \"warning: rewrite ignored for incomplete programs\\n\")\n@@ -106,23 +106,18 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error\n \t\tsimplify(file)\n \t}\n \n-\tvar buf bytes.Buffer\n-\terr = (&printer.Config{Mode: printerMode, Tabwidth: tabWidth}).Fprint(&buf, fileSet, file)\n+\tres, err := format(fileSet, file, sourceAdj, indentAdj, src, printer.Config{Mode: printerMode, Tabwidth: tabWidth})\n \tif err != nil {\n \t\treturn err\n \t}\n-\tres := buf.Bytes()\n-\tif adjust != nil {\n-\t\tres = adjust(src, res)\n-\t}\n \n \tif !bytes.Equal(src, res) {\n \t\t// formatting has changed\n \t\tif *list {\n \t\t\tfmt.Fprintln(out, filename)\n \t\t}\n \t\tif *write {\n-\t\t\terr = ioutil.WriteFile(filename, res, 0)\n+\t\t\terr = ioutil.WriteFile(filename, res, 0644)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n@@ -186,6 +181,11 @@ func gofmtMain() {\n \tinitRewrite()\n \n \tif flag.NArg() == 0 {\n+\t\tif *write {\n+\t\t\tfmt.Fprintln(os.Stderr, \"error: cannot use -w with standard input\")\n+\t\t\texitCode = 2\n+\t\t\treturn\n+\t\t}\n \t\tif err := processFile(\"<standard input>\", os.Stdin, os.Stdout, true); err != nil {\n \t\t\treport(err)\n \t\t}\n@@ -235,19 +235,29 @@ func diff(b1, b2 []byte) (data []byte, err error) {\n \n }\n \n-// parse parses src, which was read from filename,\n-// as a Go source file or statement list.\n-func parse(fset *token.FileSet, filename string, src []byte, stdin bool) (*ast.File, func(orig, src []byte) []byte, error) {\n+// ----------------------------------------------------------------------------\n+// Support functions\n+//\n+// The functions parse, format, and isSpace below are identical to the\n+// respective functions in src/go/format/format.go - keep them in sync!\n+//\n+// TODO(gri) Factor out this functionality, eventually.\n+\n+// parse parses src, which was read from the named file,\n+// as a Go source file, declaration, or statement list.\n+func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n+\tfile *ast.File,\n+\tsourceAdj func(src []byte, indent int) []byte,\n+\tindentAdj int,\n+\terr error,\n+) {\n \t// Try as whole source file.\n-\tfile, err := parser.ParseFile(fset, filename, src, parserMode)\n-\tif err == nil {\n-\t\treturn file, nil, nil\n-\t}\n-\t// If the error is that the source file didn't begin with a\n-\t// package line and this is standard input, fall through to\n+\tfile, err = parser.ParseFile(fset, filename, src, parserMode)\n+\t// If there's no error, return.  If the error is that the source file didn't begin with a\n+\t// package line and source fragments are ok, fall through to\n \t// try as a source fragment.  Stop and return on any other error.\n-\tif !stdin || !strings.Contains(err.Error(), \"expected 'package'\") {\n-\t\treturn nil, nil, err\n+\tif err == nil || !fragmentOk || !strings.Contains(err.Error(), \"expected 'package'\") {\n+\t\treturn\n \t}\n \n \t// If this is a declaration list, make it a source file\n@@ -257,88 +267,121 @@ func parse(fset *token.FileSet, filename string, src []byte, stdin bool) (*ast.F\n \tpsrc := append([]byte(\"package p;\"), src...)\n \tfile, err = parser.ParseFile(fset, filename, psrc, parserMode)\n \tif err == nil {\n-\t\tadjust := func(orig, src []byte) []byte {\n+\t\tsourceAdj = func(src []byte, indent int) []byte {\n \t\t\t// Remove the package clause.\n \t\t\t// Gofmt has turned the ; into a \\n.\n-\t\t\tsrc = src[len(\"package p\\n\"):]\n-\t\t\treturn matchSpace(orig, src)\n+\t\t\tsrc = src[indent+len(\"package p\\n\"):]\n+\t\t\treturn bytes.TrimSpace(src)\n \t\t}\n-\t\treturn file, adjust, nil\n+\t\treturn\n \t}\n \t// If the error is that the source file didn't begin with a\n \t// declaration, fall through to try as a statement list.\n \t// Stop and return on any other error.\n \tif !strings.Contains(err.Error(), \"expected declaration\") {\n-\t\treturn nil, nil, err\n+\t\treturn\n \t}\n \n \t// If this is a statement list, make it a source file\n \t// by inserting a package clause and turning the list\n \t// into a function body.  This handles expressions too.\n \t// Insert using a ;, not a newline, so that the line numbers\n \t// in fsrc match the ones in src.\n-\tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '}')\n+\tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '\\n', '}')\n \tfile, err = parser.ParseFile(fset, filename, fsrc, parserMode)\n \tif err == nil {\n-\t\tadjust := func(orig, src []byte) []byte {\n+\t\tsourceAdj = func(src []byte, indent int) []byte {\n+\t\t\t// Cap adjusted indent to zero.\n+\t\t\tif indent < 0 {\n+\t\t\t\tindent = 0\n+\t\t\t}\n \t\t\t// Remove the wrapping.\n \t\t\t// Gofmt has turned the ; into a \\n\\n.\n-\t\t\tsrc = src[len(\"package p\\n\\nfunc _() {\"):]\n-\t\t\tsrc = src[:len(src)-len(\"}\\n\")]\n-\t\t\t// Gofmt has also indented the function body one level.\n-\t\t\t// Remove that indent.\n-\t\t\tsrc = bytes.Replace(src, []byte(\"\\n\\t\"), []byte(\"\\n\"), -1)\n-\t\t\treturn matchSpace(orig, src)\n+\t\t\t// There will be two non-blank lines with indent, hence 2*indent.\n+\t\t\tsrc = src[2*indent+len(\"package p\\n\\nfunc _() {\"):]\n+\t\t\tsrc = src[:len(src)-(indent+len(\"\\n}\\n\"))]\n+\t\t\treturn bytes.TrimSpace(src)\n \t\t}\n-\t\treturn file, adjust, nil\n+\t\t// Gofmt has also indented the function body one level.\n+\t\t// Adjust that with indentAdj.\n+\t\tindentAdj = -1\n \t}\n \n-\t// Failed, and out of options.\n-\treturn nil, nil, err\n+\t// Succeeded, or out of options.\n+\treturn\n }\n \n-func cutSpace(b []byte) (before, middle, after []byte) {\n-\ti := 0\n-\tfor i < len(b) && (b[i] == ' ' || b[i] == '\\t' || b[i] == '\\n') {\n-\t\ti++\n-\t}\n-\tj := len(b)\n-\tfor j > 0 && (b[j-1] == ' ' || b[j-1] == '\\t' || b[j-1] == '\\n') {\n-\t\tj--\n-\t}\n-\tif i <= j {\n-\t\treturn b[:i], b[i:j], b[j:]\n+// format formats the given package file originally obtained from src\n+// and adjusts the result based on the original source via sourceAdj\n+// and indentAdj.\n+func format(\n+\tfset *token.FileSet,\n+\tfile *ast.File,\n+\tsourceAdj func(src []byte, indent int) []byte,\n+\tindentAdj int,\n+\tsrc []byte,\n+\tcfg printer.Config,\n+) ([]byte, error) {\n+\tif sourceAdj == nil {\n+\t\t// Complete source file.\n+\t\tvar buf bytes.Buffer\n+\t\terr := cfg.Fprint(&buf, fset, file)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn buf.Bytes(), nil\n \t}\n-\treturn nil, nil, b[j:]\n-}\n \n-// matchSpace reformats src to use the same space context as orig.\n-// 1) If orig begins with blank lines, matchSpace inserts them at the beginning of src.\n-// 2) matchSpace copies the indentation of the first non-blank line in orig\n-//    to every non-blank line in src.\n-// 3) matchSpace copies the trailing space from orig and uses it in place\n-//   of src's trailing space.\n-func matchSpace(orig []byte, src []byte) []byte {\n-\tbefore, _, after := cutSpace(orig)\n-\ti := bytes.LastIndex(before, []byte{'\\n'})\n-\tbefore, indent := before[:i+1], before[i+1:]\n-\n-\t_, src, _ = cutSpace(src)\n-\n-\tvar b bytes.Buffer\n-\tb.Write(before)\n-\tfor len(src) > 0 {\n-\t\tline := src\n-\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n-\t\t\tline, src = line[:i+1], line[i+1:]\n-\t\t} else {\n-\t\t\tsrc = nil\n+\t// Partial source file.\n+\t// Determine and prepend leading space.\n+\ti, j := 0, 0\n+\tfor j < len(src) && isSpace(src[j]) {\n+\t\tif src[j] == '\\n' {\n+\t\t\ti = j + 1 // byte offset of last line in leading space\n \t\t}\n-\t\tif len(line) > 0 && line[0] != '\\n' { // not blank\n-\t\t\tb.Write(indent)\n+\t\tj++\n+\t}\n+\tvar res []byte\n+\tres = append(res, src[:i]...)\n+\n+\t// Determine and prepend indentation of first code line.\n+\t// Spaces are ignored unless there are no tabs,\n+\t// in which case spaces count as one tab.\n+\tindent := 0\n+\thasSpace := false\n+\tfor _, b := range src[i:j] {\n+\t\tswitch b {\n+\t\tcase ' ':\n+\t\t\thasSpace = true\n+\t\tcase '\\t':\n+\t\t\tindent++\n \t\t}\n-\t\tb.Write(line)\n \t}\n-\tb.Write(after)\n-\treturn b.Bytes()\n+\tif indent == 0 && hasSpace {\n+\t\tindent = 1\n+\t}\n+\tfor i := 0; i < indent; i++ {\n+\t\tres = append(res, '\\t')\n+\t}\n+\n+\t// Format the source.\n+\t// Write it without any leading and trailing space.\n+\tcfg.Indent = indent + indentAdj\n+\tvar buf bytes.Buffer\n+\terr := cfg.Fprint(&buf, fset, file)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tres = append(res, sourceAdj(buf.Bytes(), cfg.Indent)...)\n+\n+\t// Determine and append trailing space.\n+\ti = len(src)\n+\tfor i > 0 && isSpace(src[i-1]) {\n+\t\ti--\n+\t}\n+\treturn append(res, src[i:]...), nil\n+}\n+\n+func isSpace(b byte) bool {\n+\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n }"}, {"sha": "d1edb7bcc16c25fba5cdaa68b287838bd451cfac", "filename": "libgo/go/cmd/gofmt/gofmt_test.go", "status": "modified", "additions": 80, "deletions": 41, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,18 +6,60 @@ package main\n \n import (\n \t\"bytes\"\n+\t\"flag\"\n \t\"io/ioutil\"\n+\t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"testing\"\n+\t\"text/scanner\"\n )\n \n-func runTest(t *testing.T, in, out, flags string) {\n+var update = flag.Bool(\"update\", false, \"update .golden files\")\n+\n+// gofmtFlags looks for a comment of the form\n+//\n+//\t//gofmt flags\n+//\n+// within the first maxLines lines of the given file,\n+// and returns the flags string, if any. Otherwise it\n+// returns the empty string.\n+func gofmtFlags(filename string, maxLines int) string {\n+\tf, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn \"\" // ignore errors - they will be found later\n+\t}\n+\tdefer f.Close()\n+\n+\t// initialize scanner\n+\tvar s scanner.Scanner\n+\ts.Init(f)\n+\ts.Error = func(*scanner.Scanner, string) {}       // ignore errors\n+\ts.Mode = scanner.GoTokens &^ scanner.SkipComments // want comments\n+\n+\t// look for //gofmt comment\n+\tfor s.Line <= maxLines {\n+\t\tswitch s.Scan() {\n+\t\tcase scanner.Comment:\n+\t\t\tconst prefix = \"//gofmt \"\n+\t\t\tif t := s.TokenText(); strings.HasPrefix(t, prefix) {\n+\t\t\t\treturn strings.TrimSpace(t[len(prefix):])\n+\t\t\t}\n+\t\tcase scanner.EOF:\n+\t\t\treturn \"\"\n+\t\t}\n+\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+func runTest(t *testing.T, in, out string) {\n \t// process flags\n \t*simplifyAST = false\n \t*rewriteRule = \"\"\n \tstdin := false\n-\tfor _, flag := range strings.Split(flags, \" \") {\n+\tfor _, flag := range strings.Split(gofmtFlags(in, 20), \" \") {\n \t\telts := strings.SplitN(flag, \"=\", 2)\n \t\tname := elts[0]\n \t\tvalue := \"\"\n@@ -56,6 +98,17 @@ func runTest(t *testing.T, in, out, flags string) {\n \t}\n \n \tif got := buf.Bytes(); !bytes.Equal(got, expected) {\n+\t\tif *update {\n+\t\t\tif in != out {\n+\t\t\t\tif err := ioutil.WriteFile(out, got, 0666); err != nil {\n+\t\t\t\t\tt.Error(err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// in == out: don't accidentally destroy input\n+\t\t\tt.Errorf(\"WARNING: -update did not rewrite input file %s\", in)\n+\t\t}\n+\n \t\tt.Errorf(\"(gofmt %s) != %s (see %s.gofmt)\", in, out, in)\n \t\td, err := diff(expected, got)\n \t\tif err == nil {\n@@ -67,51 +120,37 @@ func runTest(t *testing.T, in, out, flags string) {\n \t}\n }\n \n-var tests = []struct {\n-\tin, flags string\n-}{\n-\t{\"gofmt.go\", \"\"},\n-\t{\"gofmt_test.go\", \"\"},\n-\t{\"testdata/composites.input\", \"-s\"},\n-\t{\"testdata/slices1.input\", \"-s\"},\n-\t{\"testdata/slices2.input\", \"-s\"},\n-\t{\"testdata/old.input\", \"\"},\n-\t{\"testdata/rewrite1.input\", \"-r=Foo->Bar\"},\n-\t{\"testdata/rewrite2.input\", \"-r=int->bool\"},\n-\t{\"testdata/rewrite3.input\", \"-r=x->x\"},\n-\t{\"testdata/rewrite4.input\", \"-r=(x)->x\"},\n-\t{\"testdata/rewrite5.input\", \"-r=x+x->2*x\"},\n-\t{\"testdata/rewrite6.input\", \"-r=fun(x)->Fun(x)\"},\n-\t{\"testdata/rewrite7.input\", \"-r=fun(x...)->Fun(x)\"},\n-\t{\"testdata/rewrite8.input\", \"-r=interface{}->int\"},\n-\t{\"testdata/stdin*.input\", \"-stdin\"},\n-\t{\"testdata/comments.input\", \"\"},\n-\t{\"testdata/import.input\", \"\"},\n-\t{\"testdata/crlf.input\", \"\"},       // test case for issue 3961; see also TestCRLF\n-\t{\"testdata/typeswitch.input\", \"\"}, // test case for issue 4470\n-}\n-\n+// TestRewrite processes testdata/*.input files and compares them to the\n+// corresponding testdata/*.golden files. The gofmt flags used to process\n+// a file must be provided via a comment of the form\n+//\n+//\t//gofmt flags\n+//\n+// in the processed file within the first 20 lines, if any.\n func TestRewrite(t *testing.T) {\n-\tfor _, test := range tests {\n-\t\tmatch, err := filepath.Glob(test.in)\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t\tcontinue\n+\t// determine input files\n+\tmatch, err := filepath.Glob(\"testdata/*.input\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// add larger examples\n+\tmatch = append(match, \"gofmt.go\", \"gofmt_test.go\")\n+\n+\tfor _, in := range match {\n+\t\tout := in // for files where input and output are identical\n+\t\tif strings.HasSuffix(in, \".input\") {\n+\t\t\tout = in[:len(in)-len(\".input\")] + \".golden\"\n \t\t}\n-\t\tfor _, in := range match {\n-\t\t\tout := in\n-\t\t\tif strings.HasSuffix(in, \".input\") {\n-\t\t\t\tout = in[:len(in)-len(\".input\")] + \".golden\"\n-\t\t\t}\n-\t\t\trunTest(t, in, out, test.flags)\n-\t\t\tif in != out {\n-\t\t\t\t// Check idempotence.\n-\t\t\t\trunTest(t, out, out, test.flags)\n-\t\t\t}\n+\t\trunTest(t, in, out)\n+\t\tif in != out {\n+\t\t\t// Check idempotence.\n+\t\t\trunTest(t, out, out)\n \t\t}\n \t}\n }\n \n+// Test case for issue 3961.\n func TestCRLF(t *testing.T) {\n \tconst input = \"testdata/crlf.input\"   // must contain CR/LF's\n \tconst golden = \"testdata/crlf.golden\" // must not contain any CR's"}, {"sha": "237b86021bf356d357077d9f61dacb980f7a39e8", "filename": "libgo/go/cmd/gofmt/long_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -32,7 +32,7 @@ var (\n )\n \n func gofmt(fset *token.FileSet, filename string, src *bytes.Buffer) error {\n-\tf, _, err := parse(fset, filename, src.Bytes(), false)\n+\tf, _, _, err := parse(fset, filename, src.Bytes(), false)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -60,7 +60,7 @@ func testFile(t *testing.T, b1, b2 *bytes.Buffer, filename string) {\n \n \t// exclude files w/ syntax errors (typically test cases)\n \tfset := token.NewFileSet()\n-\tif _, _, err = parse(fset, filename, b1.Bytes(), false); err != nil {\n+\tif _, _, _, err = parse(fset, filename, b1.Bytes(), false); err != nil {\n \t\tif *verbose {\n \t\t\tfmt.Fprintf(os.Stderr, \"ignoring %s\\n\", err)\n \t\t}"}, {"sha": "d267cfcc1dc69de69c51bb82e790e9a3ce4c786d", "filename": "libgo/go/cmd/gofmt/rewrite.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -226,9 +226,6 @@ func match(m map[string]reflect.Value, pattern, val reflect.Value) bool {\n \t\treturn true\n \n \tcase reflect.Struct:\n-\t\tif p.NumField() != v.NumField() {\n-\t\t\treturn false\n-\t\t}\n \t\tfor i := 0; i < p.NumField(); i++ {\n \t\t\tif !match(m, p.Field(i), v.Field(i)) {\n \t\t\t\treturn false"}, {"sha": "69f7bf23c0b2de7b3e7f909ea65fd0fc9bd39b36", "filename": "libgo/go/cmd/gofmt/simplify.go", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -68,9 +68,10 @@ func (s *simplifier) Visit(node ast.Node) ast.Visitor {\n \t\t// a slice expression of the form: s[a:len(s)]\n \t\t// can be simplified to: s[a:]\n \t\t// if s is \"simple enough\" (for now we only accept identifiers)\n-\t\tif s.hasDotImport {\n-\t\t\t// if dot imports are present, we cannot be certain that an\n-\t\t\t// unresolved \"len\" identifier refers to the predefined len()\n+\t\tif n.Max != nil || s.hasDotImport {\n+\t\t\t// - 3-index slices always require the 2nd and 3rd index\n+\t\t\t// - if dot imports are present, we cannot be certain that an\n+\t\t\t//   unresolved \"len\" identifier refers to the predefined len()\n \t\t\tbreak\n \t\t}\n \t\tif s, _ := n.X.(*ast.Ident); s != nil && s.Obj != nil {\n@@ -96,16 +97,26 @@ func (s *simplifier) Visit(node ast.Node) ast.Visitor {\n \t\t//       x, y := b[:n], b[n:]\n \n \tcase *ast.RangeStmt:\n-\t\t// a range of the form: for x, _ = range v {...}\n+\t\t// - a range of the form: for x, _ = range v {...}\n \t\t// can be simplified to: for x = range v {...}\n-\t\tif ident, _ := n.Value.(*ast.Ident); ident != nil && ident.Name == \"_\" {\n+\t\t// - a range of the form: for _ = range v {...}\n+\t\t// can be simplified to: for range v {...}\n+\t\tif isBlank(n.Value) {\n \t\t\tn.Value = nil\n \t\t}\n+\t\tif isBlank(n.Key) && n.Value == nil {\n+\t\t\tn.Key = nil\n+\t\t}\n \t}\n \n \treturn s\n }\n \n+func isBlank(x ast.Expr) bool {\n+\tident, ok := x.(*ast.Ident)\n+\treturn ok && ident.Name == \"_\"\n+}\n+\n func simplify(f *ast.File) {\n \tvar s simplifier\n \n@@ -117,5 +128,34 @@ func simplify(f *ast.File) {\n \t\t}\n \t}\n \n+\t// remove empty declarations such as \"const ()\", etc\n+\tremoveEmptyDeclGroups(f)\n+\n \tast.Walk(&s, f)\n }\n+\n+func removeEmptyDeclGroups(f *ast.File) {\n+\ti := 0\n+\tfor _, d := range f.Decls {\n+\t\tif g, ok := d.(*ast.GenDecl); !ok || !isEmpty(f, g) {\n+\t\t\tf.Decls[i] = d\n+\t\t\ti++\n+\t\t}\n+\t}\n+\tf.Decls = f.Decls[:i]\n+}\n+\n+func isEmpty(f *ast.File, g *ast.GenDecl) bool {\n+\tif g.Doc != nil || g.Specs != nil {\n+\t\treturn false\n+\t}\n+\n+\tfor _, c := range f.Comments {\n+\t\t// if there is a comment in the declaration, it is not considered empty\n+\t\tif g.Pos() <= c.Pos() && c.End() <= g.End() {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}"}, {"sha": "fc9c98e625b4b869250a464fc5fd6b08fc42b613", "filename": "libgo/go/cmd/gofmt/testdata/composites.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -s\n+\n package P\n \n type T struct {"}, {"sha": "fc7598af99edf1fc729f0e51f459ceda11ca73c0", "filename": "libgo/go/cmd/gofmt/testdata/composites.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -s\n+\n package P\n \n type T struct {"}, {"sha": "193dbacc727dd786f3ac6604c8d1f0f55ab26376", "filename": "libgo/go/cmd/gofmt/testdata/crlf.golden", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -2,6 +2,7 @@\n \tSource containing CR/LF line endings.\n \tThe gofmt'ed output must only have LF\n \tline endings.\n+\tTest case for issue 3961.\n */\n package main\n "}, {"sha": "ae7e14dbf1386c7133cc0863acf425ad85f51f63", "filename": "libgo/go/cmd/gofmt/testdata/crlf.input", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -2,6 +2,7 @@\n \tSource containing CR/LF line endings.\r\n \tThe gofmt'ed output must only have LF\r\n \tline endings.\r\n+\tTest case for issue 3961.\r\n */\r\n package main\r\n \r"}, {"sha": "3ee5373a79094a6b05328b2114d75946cb4c4575", "filename": "libgo/go/cmd/gofmt/testdata/rewrite1.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=Foo->Bar\n+\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "a84c8f781659ba5ebd9ae62ac351d680167551cd", "filename": "libgo/go/cmd/gofmt/testdata/rewrite1.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=Foo->Bar\n+\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "f980e035309e1a6958b6bb02458ee055dac98431", "filename": "libgo/go/cmd/gofmt/testdata/rewrite2.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=int->bool\n+\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "489be4e07dc80facb5a7ee72a6b8f5c7ba2cf18e", "filename": "libgo/go/cmd/gofmt/testdata/rewrite2.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=int->bool\n+\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "261a220c65d7f1988a2ae55fa31af59b32bb6dec", "filename": "libgo/go/cmd/gofmt/testdata/rewrite3.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=x->x\n+\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "261a220c65d7f1988a2ae55fa31af59b32bb6dec", "filename": "libgo/go/cmd/gofmt/testdata/rewrite3.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=x->x\n+\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "b05547b4bf08216357c7f7bfc2622916aa976165", "filename": "libgo/go/cmd/gofmt/testdata/rewrite4.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=(x)->x\n+\n // Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "0817099209c0e87ce5c422bd7750c0d01a38b839", "filename": "libgo/go/cmd/gofmt/testdata/rewrite4.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=(x)->x\n+\n // Copyright 2012 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "9beb34aee76d13da7fafce9f32006f4c16b9092a", "filename": "libgo/go/cmd/gofmt/testdata/rewrite5.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=x+x->2*x\n+\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "d7a6122d07a7a99c20e3ce7e0f57d27b054d2bcc", "filename": "libgo/go/cmd/gofmt/testdata/rewrite5.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=x+x->2*x\n+\n // Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "48ec9aa0df7780e1dea1567071240fee46d1b2f9", "filename": "libgo/go/cmd/gofmt/testdata/rewrite6.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=fun(x)->Fun(x)\n+\n // Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "b085a84fef4a878b41bdd90716dce23acb90ecb9", "filename": "libgo/go/cmd/gofmt/testdata/rewrite6.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=fun(x)->Fun(x)\n+\n // Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "8386a0b2a3eb791bd1bb5a68d4277ea75b660441", "filename": "libgo/go/cmd/gofmt/testdata/rewrite7.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=fun(x...)->Fun(x)\n+\n // Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "c1984708e71b34b96a1e78292ba8cca8ce1280f5", "filename": "libgo/go/cmd/gofmt/testdata/rewrite7.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=fun(x...)->Fun(x)\n+\n // Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "62f0419dfb460297d64aef8850d228c507f411f9", "filename": "libgo/go/cmd/gofmt/testdata/rewrite8.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=interface{}->int\n+\n // Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "7964c5c75c78fb0551487b8ae637353081990851", "filename": "libgo/go/cmd/gofmt/testdata/rewrite8.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -r=interface{}->int\n+\n // Copyright 2013 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file."}, {"sha": "04bc16f2160b62e330346aa424afc395b4be200a", "filename": "libgo/go/cmd/gofmt/testdata/slices1.golden", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -s\n+\n // Test cases for slice expression simplification.\n package p\n \n@@ -15,41 +17,47 @@ var (\n \t_ = a[3:(len(a))]\n \t_ = a[len(a) : len(a)-1]\n \t_ = a[0:len(b)]\n+\t_ = a[2:len(a):len(a)]\n \n \t_ = a[:]\n \t_ = a[:10]\n \t_ = a[:]\n \t_ = a[:(len(a))]\n \t_ = a[:len(a)-1]\n \t_ = a[:len(b)]\n+\t_ = a[:len(a):len(a)]\n \n \t_ = s[0:]\n \t_ = s[1:10]\n \t_ = s[2:]\n \t_ = s[3:(len(s))]\n \t_ = s[len(a) : len(s)-1]\n \t_ = s[0:len(b)]\n+\t_ = s[2:len(s):len(s)]\n \n \t_ = s[:]\n \t_ = s[:10]\n \t_ = s[:]\n \t_ = s[:(len(s))]\n \t_ = s[:len(s)-1]\n \t_ = s[:len(b)]\n+\t_ = s[:len(s):len(s)]\n \n \t_ = t.s[0:]\n \t_ = t.s[1:10]\n \t_ = t.s[2:len(t.s)]\n \t_ = t.s[3:(len(t.s))]\n \t_ = t.s[len(a) : len(t.s)-1]\n \t_ = t.s[0:len(b)]\n+\t_ = t.s[2:len(t.s):len(t.s)]\n \n \t_ = t.s[:]\n \t_ = t.s[:10]\n \t_ = t.s[:len(t.s)]\n \t_ = t.s[:(len(t.s))]\n \t_ = t.s[:len(t.s)-1]\n \t_ = t.s[:len(b)]\n+\t_ = t.s[:len(t.s):len(t.s)]\n )\n \n func _() {"}, {"sha": "1f25c43ccbc825ba1a89cee7e0362c43c4eba257", "filename": "libgo/go/cmd/gofmt/testdata/slices1.input", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -s\n+\n // Test cases for slice expression simplification.\n package p\n \n@@ -15,41 +17,47 @@ var (\n \t_ = a[3:(len(a))]\n \t_ = a[len(a) : len(a)-1]\n \t_ = a[0:len(b)]\n+\t_ = a[2:len(a):len(a)]\n \n \t_ = a[:]\n \t_ = a[:10]\n \t_ = a[:len(a)]\n \t_ = a[:(len(a))]\n \t_ = a[:len(a)-1]\n \t_ = a[:len(b)]\n+\t_ = a[:len(a):len(a)]\n \n \t_ = s[0:]\n \t_ = s[1:10]\n \t_ = s[2:len(s)]\n \t_ = s[3:(len(s))]\n \t_ = s[len(a) : len(s)-1]\n \t_ = s[0:len(b)]\n+\t_ = s[2:len(s):len(s)]\n \n \t_ = s[:]\n \t_ = s[:10]\n \t_ = s[:len(s)]\n \t_ = s[:(len(s))]\n \t_ = s[:len(s)-1]\n \t_ = s[:len(b)]\n+\t_ = s[:len(s):len(s)]\n \n \t_ = t.s[0:]\n \t_ = t.s[1:10]\n \t_ = t.s[2:len(t.s)]\n \t_ = t.s[3:(len(t.s))]\n \t_ = t.s[len(a) : len(t.s)-1]\n \t_ = t.s[0:len(b)]\n+\t_ = t.s[2:len(t.s):len(t.s)]\n \n \t_ = t.s[:]\n \t_ = t.s[:10]\n \t_ = t.s[:len(t.s)]\n \t_ = t.s[:(len(t.s))]\n \t_ = t.s[:len(t.s)-1]\n \t_ = t.s[:len(b)]\n+\t_ = t.s[:len(t.s):len(t.s)]\n )\n \n func _() {"}, {"sha": "ab657004e64accaae1c2b1258e3b795fef78bcf0", "filename": "libgo/go/cmd/gofmt/testdata/slices2.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -s\n+\n // Test cases for slice expression simplification.\n // Because of a dot import, these slices must remain untouched.\n package p"}, {"sha": "ab657004e64accaae1c2b1258e3b795fef78bcf0", "filename": "libgo/go/cmd/gofmt/testdata/slices2.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+//gofmt -s\n+\n // Test cases for slice expression simplification.\n // Because of a dot import, these slices must remain untouched.\n package p"}, {"sha": "9e4dcd20fe0d563ed51b2bac27567fbc7f5ee63c", "filename": "libgo/go/cmd/gofmt/testdata/stdin1.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+\t//gofmt -stdin\n+\n \tif x {\n \t\ty\n \t}"}, {"sha": "1f888877d010ec034726048c6a0b1a72dfdac91f", "filename": "libgo/go/cmd/gofmt/testdata/stdin1.golden.gofmt", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden.gofmt?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,3 +0,0 @@\n-\tif x {\n-\ty\n-}"}, {"sha": "9e4dcd20fe0d563ed51b2bac27567fbc7f5ee63c", "filename": "libgo/go/cmd/gofmt/testdata/stdin1.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+\t//gofmt -stdin\n+\n \tif x {\n \t\ty\n \t}"}, {"sha": "1f888877d010ec034726048c6a0b1a72dfdac91f", "filename": "libgo/go/cmd/gofmt/testdata/stdin1.input.gofmt", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input.gofmt?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,3 +0,0 @@\n-\tif x {\n-\ty\n-}"}, {"sha": "57df35540358c1c15f8cb3dfbdc292ae7d59c225", "filename": "libgo/go/cmd/gofmt/testdata/stdin2.golden", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,4 +1,4 @@\n-\n+//gofmt -stdin\n \n var x int\n "}, {"sha": "85e80030081c3ed9724b918e437e773e2e0772b8", "filename": "libgo/go/cmd/gofmt/testdata/stdin2.golden.gofmt", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden.gofmt?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,10 +0,0 @@\n-\n-\n-\n-var x int\n-\n-func f() {\n-\ty := z\n-}\n-\n-"}, {"sha": "69d6bdd682efe8f90e157ef1f93f549c7cc7b4a4", "filename": "libgo/go/cmd/gofmt/testdata/stdin2.input", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,4 +1,4 @@\n-\n+//gofmt -stdin\n \n var x int\n "}, {"sha": "7eb1b54fec058ebbc4f248f05a63fddb63112380", "filename": "libgo/go/cmd/gofmt/testdata/stdin2.input.gofmt", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input.gofmt?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,11 +0,0 @@\n-\n-\n-var x int\n-\n-func f() {\n-\ty := z\n-\t/* this is a comment */\n-\t// this is a comment too\n-}\n-\n-"}, {"sha": "d6da0e417a06ce11d31cab2bea97606987ee3288", "filename": "libgo/go/cmd/gofmt/testdata/stdin3.golden", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,4 @@\n+\t\t//gofmt -stdin\n \n \t\t/* note: no newline at end of file */\n \t\tfor i := 0; i < 10; i++ {"}, {"sha": "b4d1d4663ed0694d32504732a78bbf20061c0447", "filename": "libgo/go/cmd/gofmt/testdata/stdin3.golden.gofmt", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden.gofmt?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,7 +0,0 @@\n-\n-\n-\t\t/* note: no newline at end of file */\n-\t\tfor i := 0; i < 10; i++ {\n-\t\t\ts += i\n-\t\t}\n-\t\n\\ No newline at end of file"}, {"sha": "ab46c1063beba078cd8a18c4fd2beb64186e9d0a", "filename": "libgo/go/cmd/gofmt/testdata/stdin3.input", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,4 @@\n+\t\t//gofmt -stdin\n \n \t\t/* note: no newline at end of file */\n \t\tfor i := 0; i < 10; i++ { s += i }"}, {"sha": "b4d1d4663ed0694d32504732a78bbf20061c0447", "filename": "libgo/go/cmd/gofmt/testdata/stdin3.input.gofmt", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input.gofmt?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,7 +0,0 @@\n-\n-\n-\t\t/* note: no newline at end of file */\n-\t\tfor i := 0; i < 10; i++ {\n-\t\t\ts += i\n-\t\t}\n-\t\n\\ No newline at end of file"}, {"sha": "0c7acace5d0fa8c557e988699f92311ad74aa659", "filename": "libgo/go/cmd/gofmt/testdata/stdin4.golden", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+\t//gofmt -stdin\n+\n \t// comment\n \n \ti := 0"}, {"sha": "5f73435517f4376404e5915844df18113b8fb338", "filename": "libgo/go/cmd/gofmt/testdata/stdin4.golden.gofmt", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden.gofmt?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,3 +0,0 @@\n-\t// comment\n-\n-\ti := 0"}, {"sha": "1fc73f31e5e68aadf77ed9a334655e98754812bf", "filename": "libgo/go/cmd/gofmt/testdata/stdin4.input", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -1,3 +1,5 @@\n+\t//gofmt -stdin\n+\n \t// comment\n \t\n \ti := 0"}, {"sha": "5f73435517f4376404e5915844df18113b8fb338", "filename": "libgo/go/cmd/gofmt/testdata/stdin4.input.gofmt", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input.gofmt?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,3 +0,0 @@\n-\t// comment\n-\n-\ti := 0"}, {"sha": "15575d22023e431aa65e392c6a9d8c5412434982", "filename": "libgo/go/compress/bzip2/bzip2.go", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -42,6 +42,8 @@ type reader struct {\n }\n \n // NewReader returns an io.Reader which decompresses bzip2 data from r.\n+// If r does not also implement io.ByteReader,\n+// the decompressor may read more data than necessary from r.\n func NewReader(r io.Reader) io.Reader {\n \tbz2 := new(reader)\n \tbz2.br = newBitReader(r)\n@@ -261,6 +263,11 @@ func (bz2 *reader) readBlock() (err error) {\n \t\t}\n \t}\n \n+\tif numSymbols == 0 {\n+\t\t// There must be an EOF symbol.\n+\t\treturn StructuralError(\"no symbols in input\")\n+\t}\n+\n \t// A block uses between two and six different Huffman trees.\n \tnumHuffmanTrees := br.ReadBits(3)\n \tif numHuffmanTrees < 2 || numHuffmanTrees > 6 {\n@@ -307,10 +314,10 @@ func (bz2 *reader) readBlock() (err error) {\n \n \t// Now we decode the arrays of code-lengths for each tree.\n \tlengths := make([]uint8, numSymbols)\n-\tfor i := 0; i < numHuffmanTrees; i++ {\n+\tfor i := range huffmanTrees {\n \t\t// The code lengths are delta encoded from a 5-bit base value.\n \t\tlength := br.ReadBits(5)\n-\t\tfor j := 0; j < numSymbols; j++ {\n+\t\tfor j := range lengths {\n \t\t\tfor {\n \t\t\t\tif !br.ReadBit() {\n \t\t\t\t\tbreak\n@@ -333,6 +340,12 @@ func (bz2 *reader) readBlock() (err error) {\n \t}\n \n \tselectorIndex := 1 // the next tree index to use\n+\tif len(treeIndexes) == 0 {\n+\t\treturn StructuralError(\"no tree selectors given\")\n+\t}\n+\tif int(treeIndexes[0]) >= len(huffmanTrees) {\n+\t\treturn StructuralError(\"tree selector out of range\")\n+\t}\n \tcurrentHuffmanTree := huffmanTrees[treeIndexes[0]]\n \tbufIndex := 0 // indexes bz2.buf, the output buffer.\n \t// The output of the move-to-front transform is run-length encoded and\n@@ -350,6 +363,12 @@ func (bz2 *reader) readBlock() (err error) {\n \tdecoded := 0 // counts the number of symbols decoded by the current tree.\n \tfor {\n \t\tif decoded == 50 {\n+\t\t\tif selectorIndex >= numSelectors {\n+\t\t\t\treturn StructuralError(\"insufficient selector indices for number of symbols\")\n+\t\t\t}\n+\t\t\tif int(treeIndexes[selectorIndex]) >= len(huffmanTrees) {\n+\t\t\t\treturn StructuralError(\"tree selector out of range\")\n+\t\t\t}\n \t\t\tcurrentHuffmanTree = huffmanTrees[treeIndexes[selectorIndex]]\n \t\t\tselectorIndex++\n \t\t\tdecoded = 0"}, {"sha": "fb79d089eb3b0dbf3bdc5ea08620b15f48e8c3d0", "filename": "libgo/go/compress/bzip2/bzip2_test.go", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -208,6 +208,52 @@ func TestBufferOverrun(t *testing.T) {\n \tioutil.ReadAll(decompressor)\n }\n \n+func TestOutOfRangeSelector(t *testing.T) {\n+\t// Tests https://code.google.com/p/go/issues/detail?id=8363.\n+\tbuffer := bytes.NewReader(outOfRangeSelector)\n+\tdecompressor := NewReader(buffer)\n+\t// This shouldn't panic.\n+\tioutil.ReadAll(decompressor)\n+}\n+\n+func TestMTF(t *testing.T) {\n+\tmtf := newMTFDecoderWithRange(5)\n+\n+\t// 0 1 2 3 4\n+\texpect := byte(1)\n+\tx := mtf.Decode(1)\n+\tif x != expect {\n+\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n+\t}\n+\n+\t// 1 0 2 3 4\n+\tx = mtf.Decode(0)\n+\tif x != expect {\n+\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n+\t}\n+\n+\t// 1 0 2 3 4\n+\texpect = byte(0)\n+\tx = mtf.Decode(1)\n+\tif x != expect {\n+\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n+\t}\n+\n+\t// 0 1 2 3 4\n+\texpect = byte(4)\n+\tx = mtf.Decode(4)\n+\tif x != expect {\n+\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n+\t}\n+\n+\t// 4 0 1 2 3\n+\texpect = byte(0)\n+\tx = mtf.Decode(1)\n+\tif x != expect {\n+\t\tt.Errorf(\"expected %v, got %v\", expect, x)\n+\t}\n+}\n+\n var bufferOverrunBase64 string = `\n QlpoNTFBWSZTWTzyiGcACMP/////////////////////////////////3/7f3///\n ////4N/fCZODak2Xo44GIHZgkGzDRbFAuwAAKoFV7T6AO6qwA6APb6s2rOoAkAAD\n@@ -361,3 +407,13 @@ O0A8s/iua5oFdNZTWvbVI4FUH9sKcLiB3/fIAF+sB4n8q6L+UCfmbPcAo/crQ6b3\n HqhDBMY9J0q/jdz9GNYZ/1fbXdkUqAQKFePhtzJDRBZba27+LPQNMCcrHMq06F1T\n 4QmLmkHt7LxB2pAczUO+T2O9bHEw/HWw+dYf2MoRDUw=\n `\n+\n+var outOfRangeSelector = []byte{\n+\t0x42, 0x5a, 0x68, 0x39, 0x31, 0x41, 0x59, 0x26,\n+\t0x53, 0x59, 0x4e, 0xec, 0xe8, 0x36, 0x00, 0x00,\n+\t0x02, 0x51, 0x80, 0x00, 0x10, 0x40, 0x00, 0x06,\n+\t0x44, 0x90, 0x80, 0x20, 0x00, 0x31, 0x06, 0x4c,\n+\t0x41, 0x01, 0xa7, 0xa9, 0xa5, 0x80, 0xbb, 0x94,\n+\t0x31, 0x17, 0x72, 0x45, 0x38, 0x50, 0x90, 0x00,\n+\t0x00, 0x00, 0x00,\n+}"}, {"sha": "526dfb34cc06db6dcc2a61cc35e82b3e3b9bf0af", "filename": "libgo/go/compress/bzip2/move_to_front.go", "status": "modified", "additions": 17, "deletions": 62, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -11,88 +11,43 @@ package bzip2\n // index into that list. When a symbol is referenced, it's moved to the front\n // of the list. Thus, a repeated symbol ends up being encoded with many zeros,\n // as the symbol will be at the front of the list after the first access.\n-type moveToFrontDecoder struct {\n-\t// Rather than actually keep the list in memory, the symbols are stored\n-\t// as a circular, double linked list with the symbol indexed by head\n-\t// at the front of the list.\n-\tsymbols [256]byte\n-\tnext    [256]uint8\n-\tprev    [256]uint8\n-\thead    uint8\n-\tlen     int\n-}\n+type moveToFrontDecoder []byte\n \n // newMTFDecoder creates a move-to-front decoder with an explicit initial list\n // of symbols.\n-func newMTFDecoder(symbols []byte) *moveToFrontDecoder {\n+func newMTFDecoder(symbols []byte) moveToFrontDecoder {\n \tif len(symbols) > 256 {\n \t\tpanic(\"too many symbols\")\n \t}\n-\n-\tm := new(moveToFrontDecoder)\n-\tcopy(m.symbols[:], symbols)\n-\tm.len = len(symbols)\n-\tm.threadLinkedList()\n-\treturn m\n+\treturn moveToFrontDecoder(symbols)\n }\n \n // newMTFDecoderWithRange creates a move-to-front decoder with an initial\n // symbol list of 0...n-1.\n-func newMTFDecoderWithRange(n int) *moveToFrontDecoder {\n+func newMTFDecoderWithRange(n int) moveToFrontDecoder {\n \tif n > 256 {\n \t\tpanic(\"newMTFDecoderWithRange: cannot have > 256 symbols\")\n \t}\n \n-\tm := new(moveToFrontDecoder)\n+\tm := make([]byte, n)\n \tfor i := 0; i < n; i++ {\n-\t\tm.symbols[byte(i)] = byte(i)\n-\t}\n-\tm.len = n\n-\tm.threadLinkedList()\n-\treturn m\n-}\n-\n-// threadLinkedList creates the initial linked-list pointers.\n-func (m *moveToFrontDecoder) threadLinkedList() {\n-\tif m.len == 0 {\n-\t\treturn\n-\t}\n-\n-\tm.prev[0] = uint8(m.len - 1)\n-\n-\tfor i := byte(0); int(i) < m.len-1; i++ {\n-\t\tm.next[i] = uint8(i + 1)\n-\t\tm.prev[i+1] = uint8(i)\n+\t\tm[i] = byte(i)\n \t}\n-\n-\tm.next[m.len-1] = 0\n+\treturn moveToFrontDecoder(m)\n }\n \n-func (m *moveToFrontDecoder) Decode(n int) (b byte) {\n-\t// Most of the time, n will be zero so it's worth dealing with this\n-\t// simple case.\n-\tif n == 0 {\n-\t\treturn m.symbols[m.head]\n-\t}\n-\n-\ti := m.head\n-\tfor j := 0; j < n; j++ {\n-\t\ti = m.next[i]\n-\t}\n-\tb = m.symbols[i]\n-\n-\tm.next[m.prev[i]] = m.next[i]\n-\tm.prev[m.next[i]] = m.prev[i]\n-\tm.next[i] = m.head\n-\tm.prev[i] = m.prev[m.head]\n-\tm.next[m.prev[m.head]] = i\n-\tm.prev[m.head] = i\n-\tm.head = i\n-\n+func (m moveToFrontDecoder) Decode(n int) (b byte) {\n+\t// Implement move-to-front with a simple copy. This approach\n+\t// beats more sophisticated approaches in benchmarking, probably\n+\t// because it has high locality of reference inside of a\n+\t// single cache line (most move-to-front operations have n < 64).\n+\tb = m[n]\n+\tcopy(m[1:], m[:n])\n+\tm[0] = b\n \treturn\n }\n \n // First returns the symbol at the front of the list.\n-func (m *moveToFrontDecoder) First() byte {\n-\treturn m.symbols[m.head]\n+func (m moveToFrontDecoder) First() byte {\n+\treturn m[0]\n }"}, {"sha": "7df8b9a293f796637caa09df0678ea43bb2be702", "filename": "libgo/go/compress/flate/fixedhuff.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fflate%2Ffixedhuff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fflate%2Ffixedhuff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Ffixedhuff.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -4,7 +4,7 @@\n \n package flate\n \n-// autogenerated by gen.go, DO NOT EDIT\n+// autogenerated by go run gen.go -output fixedhuff.go, DO NOT EDIT\n \n var fixedHuffmanDecoder = huffmanDecoder{\n \t7,"}, {"sha": "6288ecddd0e601948b2f9ea6f8622c7a04ee7351", "filename": "libgo/go/compress/flate/gen.go", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fgen.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -7,14 +7,21 @@\n // This program generates fixedhuff.go\n // Invoke as\n //\n-//      go run gen.go |gofmt >fixedhuff.go\n+//\tgo run gen.go -output fixedhuff.go\n \n package main\n \n import (\n+\t\"bytes\"\n+\t\"flag\"\n \t\"fmt\"\n+\t\"go/format\"\n+\t\"io/ioutil\"\n+\t\"log\"\n )\n \n+var filename = flag.String(\"output\", \"fixedhuff.go\", \"output file name\")\n+\n const maxCodeLen = 16\n \n // Note: the definition of the huffmanDecoder struct is copied from\n@@ -113,6 +120,8 @@ func (h *huffmanDecoder) init(bits []int) bool {\n }\n \n func main() {\n+\tflag.Parse()\n+\n \tvar h huffmanDecoder\n \tvar bits [288]int\n \tinitReverseByte()\n@@ -129,27 +138,43 @@ func main() {\n \t\tbits[i] = 8\n \t}\n \th.init(bits[:])\n-\tfmt.Println(\"package flate\")\n-\tfmt.Println()\n-\tfmt.Println(\"// autogenerated by gen.go, DO NOT EDIT\")\n-\tfmt.Println()\n-\tfmt.Println(\"var fixedHuffmanDecoder = huffmanDecoder{\")\n-\tfmt.Printf(\"\\t%d,\\n\", h.min)\n-\tfmt.Println(\"\\t[huffmanNumChunks]uint32{\")\n+\n+\tvar buf bytes.Buffer\n+\n+\tfmt.Fprintf(&buf, `// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.`+\"\\n\\n\")\n+\n+\tfmt.Fprintln(&buf, \"package flate\")\n+\tfmt.Fprintln(&buf)\n+\tfmt.Fprintln(&buf, \"// autogenerated by go run gen.go -output fixedhuff.go, DO NOT EDIT\")\n+\tfmt.Fprintln(&buf)\n+\tfmt.Fprintln(&buf, \"var fixedHuffmanDecoder = huffmanDecoder{\")\n+\tfmt.Fprintf(&buf, \"\\t%d,\\n\", h.min)\n+\tfmt.Fprintln(&buf, \"\\t[huffmanNumChunks]uint32{\")\n \tfor i := 0; i < huffmanNumChunks; i++ {\n \t\tif i&7 == 0 {\n-\t\t\tfmt.Printf(\"\\t\\t\")\n+\t\t\tfmt.Fprintf(&buf, \"\\t\\t\")\n \t\t} else {\n-\t\t\tfmt.Printf(\" \")\n+\t\t\tfmt.Fprintf(&buf, \" \")\n \t\t}\n-\t\tfmt.Printf(\"0x%04x,\", h.chunks[i])\n+\t\tfmt.Fprintf(&buf, \"0x%04x,\", h.chunks[i])\n \t\tif i&7 == 7 {\n-\t\t\tfmt.Println()\n+\t\t\tfmt.Fprintln(&buf)\n \t\t}\n \t}\n-\tfmt.Println(\"\\t},\")\n-\tfmt.Println(\"\\tnil, 0,\")\n-\tfmt.Println(\"}\")\n+\tfmt.Fprintln(&buf, \"\\t},\")\n+\tfmt.Fprintln(&buf, \"\\tnil, 0,\")\n+\tfmt.Fprintln(&buf, \"}\")\n+\n+\tdata, err := format.Source(buf.Bytes())\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\terr = ioutil.WriteFile(*filename, data, 0644)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n }\n \n var reverseByte [256]byte"}, {"sha": "76519bbf4274f89a95372f07d48c4ff869866f12", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:generate go run gen.go -output fixedhuff.go\n+\n // Package flate implements the DEFLATE compressed data format, described in\n // RFC 1951.  The gzip and zlib packages implement access to DEFLATE-based file\n // formats.\n@@ -54,6 +56,15 @@ func (e *WriteError) Error() string {\n \treturn \"flate: write error at offset \" + strconv.FormatInt(e.Offset, 10) + \": \" + e.Err.Error()\n }\n \n+// Resetter resets a ReadCloser returned by NewReader or NewReaderDict to\n+// to switch to a new underlying Reader. This permits reusing a ReadCloser\n+// instead of allocating a new one.\n+type Resetter interface {\n+\t// Reset discards any buffered data and resets the Resetter as if it was\n+\t// newly initialized with the given reader.\n+\tReset(r io.Reader, dict []byte) error\n+}\n+\n // Note that much of the implementation of huffmanDecoder is also copied\n // into gen.go (in package main) for the purpose of precomputing the\n // fixed huffman tables so they can be included statically.\n@@ -677,10 +688,28 @@ func makeReader(r io.Reader) Reader {\n \treturn bufio.NewReader(r)\n }\n \n+func (f *decompressor) Reset(r io.Reader, dict []byte) error {\n+\t*f = decompressor{\n+\t\tr:        makeReader(r),\n+\t\tbits:     f.bits,\n+\t\tcodebits: f.codebits,\n+\t\thist:     f.hist,\n+\t\tstep:     (*decompressor).nextBlock,\n+\t}\n+\tif dict != nil {\n+\t\tf.setDict(dict)\n+\t}\n+\treturn nil\n+}\n+\n // NewReader returns a new ReadCloser that can be used\n-// to read the uncompressed version of r.  It is the caller's\n-// responsibility to call Close on the ReadCloser when\n-// finished reading.\n+// to read the uncompressed version of r.\n+// If r does not also implement io.ByteReader,\n+// the decompressor may read more data than necessary from r.\n+// It is the caller's responsibility to call Close on the ReadCloser\n+// when finished reading.\n+//\n+// The ReadCloser returned by NewReader also implements Resetter.\n func NewReader(r io.Reader) io.ReadCloser {\n \tvar f decompressor\n \tf.bits = new([maxLit + maxDist]int)\n@@ -696,6 +725,8 @@ func NewReader(r io.Reader) io.ReadCloser {\n // the uncompressed data stream started with the given dictionary,\n // which has already been read.  NewReaderDict is typically used\n // to read data compressed by NewWriterDict.\n+//\n+// The ReadCloser returned by NewReader also implements Resetter.\n func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser {\n \tvar f decompressor\n \tf.r = makeReader(r)"}, {"sha": "9f25d30b35cd0684608371e9044a3ff1fd198263", "filename": "libgo/go/compress/flate/inflate_test.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"testing\"\n+)\n+\n+func TestReset(t *testing.T) {\n+\tss := []string{\n+\t\t\"lorem ipsum izzle fo rizzle\",\n+\t\t\"the quick brown fox jumped over\",\n+\t}\n+\n+\tdeflated := make([]bytes.Buffer, 2)\n+\tfor i, s := range ss {\n+\t\tw, _ := NewWriter(&deflated[i], 1)\n+\t\tw.Write([]byte(s))\n+\t\tw.Close()\n+\t}\n+\n+\tinflated := make([]bytes.Buffer, 2)\n+\n+\tf := NewReader(&deflated[0])\n+\tio.Copy(&inflated[0], f)\n+\tf.(Resetter).Reset(&deflated[1], nil)\n+\tio.Copy(&inflated[1], f)\n+\tf.Close()\n+\n+\tfor i, s := range ss {\n+\t\tif s != inflated[i].String() {\n+\t\t\tt.Errorf(\"inflated[%d]:\\ngot  %q\\nwant %q\", i, inflated[i], s)\n+\t\t}\n+\t}\n+}"}, {"sha": "72ee55c4fabdf5a310688bd7fda031c389510e1c", "filename": "libgo/go/compress/gzip/gunzip.go", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -74,14 +74,17 @@ type Reader struct {\n \tflg          byte\n \tbuf          [512]byte\n \terr          error\n+\tmultistream  bool\n }\n \n // NewReader creates a new Reader reading the given reader.\n-// The implementation buffers input and may read more data than necessary from r.\n+// If r does not also implement io.ByteReader,\n+// the decompressor may read more data than necessary from r.\n // It is the caller's responsibility to call Close on the Reader when done.\n func NewReader(r io.Reader) (*Reader, error) {\n \tz := new(Reader)\n \tz.r = makeReader(r)\n+\tz.multistream = true\n \tz.digest = crc32.NewIEEE()\n \tif err := z.readHeader(true); err != nil {\n \t\treturn nil, err\n@@ -101,9 +104,30 @@ func (z *Reader) Reset(r io.Reader) error {\n \t}\n \tz.size = 0\n \tz.err = nil\n+\tz.multistream = true\n \treturn z.readHeader(true)\n }\n \n+// Multistream controls whether the reader supports multistream files.\n+//\n+// If enabled (the default), the Reader expects the input to be a sequence\n+// of individually gzipped data streams, each with its own header and\n+// trailer, ending at EOF. The effect is that the concatenation of a sequence\n+// of gzipped files is treated as equivalent to the gzip of the concatenation\n+// of the sequence. This is standard behavior for gzip readers.\n+//\n+// Calling Multistream(false) disables this behavior; disabling the behavior\n+// can be useful when reading file formats that distinguish individual gzip\n+// data streams or mix gzip data streams with other data streams.\n+// In this mode, when the Reader reaches the end of the data stream,\n+// Read returns io.EOF. If the underlying reader implements io.ByteReader,\n+// it will be left positioned just after the gzip stream.\n+// To start the next stream, call z.Reset(r) followed by z.Multistream(false).\n+// If there is no next stream, z.Reset(r) will return io.EOF.\n+func (z *Reader) Multistream(ok bool) {\n+\tz.multistream = ok\n+}\n+\n // GZIP (RFC 1952) is little-endian, unlike ZLIB (RFC 1950).\n func get4(p []byte) uint32 {\n \treturn uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24\n@@ -207,7 +231,11 @@ func (z *Reader) readHeader(save bool) error {\n \t}\n \n \tz.digest.Reset()\n-\tz.decompressor = flate.NewReader(z.r)\n+\tif z.decompressor == nil {\n+\t\tz.decompressor = flate.NewReader(z.r)\n+\t} else {\n+\t\tz.decompressor.(flate.Resetter).Reset(z.r, nil)\n+\t}\n \treturn nil\n }\n \n@@ -240,6 +268,10 @@ func (z *Reader) Read(p []byte) (n int, err error) {\n \t}\n \n \t// File is ok; is there another?\n+\tif !z.multistream {\n+\t\treturn 0, io.EOF\n+\t}\n+\n \tif err = z.readHeader(false); err != nil {\n \t\tz.err = err\n \t\treturn"}, {"sha": "0636dec9ab01d208857673d7f8e566444eda9627", "filename": "libgo/go/compress/gzip/gunzip_test.go", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgunzip_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -367,3 +368,43 @@ func TestInitialReset(t *testing.T) {\n \t\tt.Errorf(\"got %q want %q\", s, gunzipTests[1].raw)\n \t}\n }\n+\n+func TestMultistreamFalse(t *testing.T) {\n+\t// Find concatenation test.\n+\tvar tt gunzipTest\n+\tfor _, tt = range gunzipTests {\n+\t\tif strings.HasSuffix(tt.desc, \" x2\") {\n+\t\t\tgoto Found\n+\t\t}\n+\t}\n+\tt.Fatal(\"cannot find hello.txt x2 in gunzip tests\")\n+\n+Found:\n+\tbr := bytes.NewReader(tt.gzip)\n+\tvar r Reader\n+\tif err := r.Reset(br); err != nil {\n+\t\tt.Fatalf(\"first reset: %v\", err)\n+\t}\n+\n+\t// Expect two streams with \"hello world\\n\", then real EOF.\n+\tconst hello = \"hello world\\n\"\n+\n+\tr.Multistream(false)\n+\tdata, err := ioutil.ReadAll(&r)\n+\tif string(data) != hello || err != nil {\n+\t\tt.Fatalf(\"first stream = %q, %v, want %q, %v\", string(data), err, hello, nil)\n+\t}\n+\n+\tif err := r.Reset(br); err != nil {\n+\t\tt.Fatalf(\"second reset: %v\", err)\n+\t}\n+\tr.Multistream(false)\n+\tdata, err = ioutil.ReadAll(&r)\n+\tif string(data) != hello || err != nil {\n+\t\tt.Fatalf(\"second stream = %q, %v, want %q, %v\", string(data), err, hello, nil)\n+\t}\n+\n+\tif err := r.Reset(br); err != io.EOF {\n+\t\tt.Fatalf(\"third reset: err=%v, want io.EOF\", err)\n+\t}\n+}"}, {"sha": "526620c82717e929eceef18816d243d8ebdab26d", "filename": "libgo/go/compress/lzw/reader.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,12 +6,16 @@\n // described in T. A. Welch, ``A Technique for High-Performance Data\n // Compression'', Computer, 17(6) (June 1984), pp 8-19.\n //\n-// In particular, it implements LZW as used by the GIF, TIFF and PDF file\n+// In particular, it implements LZW as used by the GIF and PDF file\n // formats, which means variable-width codes up to 12 bits and the first\n // two non-literal codes are a clear code and an EOF code.\n+//\n+// The TIFF file format uses a similar but incompatible version of the LZW\n+// algorithm. See the golang.org/x/image/tiff/lzw package for an\n+// implementation.\n package lzw\n \n-// TODO(nigeltao): check that TIFF and PDF use LZW in the same way as GIF,\n+// TODO(nigeltao): check that PDF uses LZW in the same way as GIF,\n // modulo LSB/MSB packing order.\n \n import (\n@@ -218,6 +222,8 @@ func (d *decoder) Close() error {\n \n // NewReader creates a new io.ReadCloser.\n // Reads from the returned io.ReadCloser read and decompress data from r.\n+// If r does not also implement io.ByteReader,\n+// the decompressor may read more data than necessary from r.\n // It is the caller's responsibility to call Close on the ReadCloser when\n // finished reading.\n // The number of bits to use for literal codes, litWidth, must be in the"}, {"sha": "816f1bf6bd06e73dd24b781a2af8839fb08e25b9", "filename": "libgo/go/compress/zlib/reader.go", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Freader.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -51,45 +51,36 @@ type reader struct {\n \tscratch      [4]byte\n }\n \n-// NewReader creates a new io.ReadCloser.\n-// Reads from the returned io.ReadCloser read and decompress data from r.\n+// Resetter resets a ReadCloser returned by NewReader or NewReaderDict to\n+// to switch to a new underlying Reader. This permits reusing a ReadCloser\n+// instead of allocating a new one.\n+type Resetter interface {\n+\t// Reset discards any buffered data and resets the Resetter as if it was\n+\t// newly initialized with the given reader.\n+\tReset(r io.Reader, dict []byte) error\n+}\n+\n+// NewReader creates a new ReadCloser.\n+// Reads from the returned ReadCloser read and decompress data from r.\n // The implementation buffers input and may read more data than necessary from r.\n // It is the caller's responsibility to call Close on the ReadCloser when done.\n+//\n+// The ReadCloser returned by NewReader also implements Resetter.\n func NewReader(r io.Reader) (io.ReadCloser, error) {\n \treturn NewReaderDict(r, nil)\n }\n \n // NewReaderDict is like NewReader but uses a preset dictionary.\n // NewReaderDict ignores the dictionary if the compressed data does not refer to it.\n+// If the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n+//\n+// The ReadCloser returned by NewReaderDict also implements Resetter.\n func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error) {\n \tz := new(reader)\n-\tif fr, ok := r.(flate.Reader); ok {\n-\t\tz.r = fr\n-\t} else {\n-\t\tz.r = bufio.NewReader(r)\n-\t}\n-\t_, err := io.ReadFull(z.r, z.scratch[0:2])\n+\terr := z.Reset(r, dict)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\th := uint(z.scratch[0])<<8 | uint(z.scratch[1])\n-\tif (z.scratch[0]&0x0f != zlibDeflate) || (h%31 != 0) {\n-\t\treturn nil, ErrHeader\n-\t}\n-\tif z.scratch[1]&0x20 != 0 {\n-\t\t_, err = io.ReadFull(z.r, z.scratch[0:4])\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tchecksum := uint32(z.scratch[0])<<24 | uint32(z.scratch[1])<<16 | uint32(z.scratch[2])<<8 | uint32(z.scratch[3])\n-\t\tif checksum != adler32.Checksum(dict) {\n-\t\t\treturn nil, ErrDictionary\n-\t\t}\n-\t\tz.decompressor = flate.NewReaderDict(z.r, dict)\n-\t} else {\n-\t\tz.decompressor = flate.NewReader(z.r)\n-\t}\n-\tz.digest = adler32.New()\n \treturn z, nil\n }\n \n@@ -130,3 +121,41 @@ func (z *reader) Close() error {\n \tz.err = z.decompressor.Close()\n \treturn z.err\n }\n+\n+func (z *reader) Reset(r io.Reader, dict []byte) error {\n+\tif fr, ok := r.(flate.Reader); ok {\n+\t\tz.r = fr\n+\t} else {\n+\t\tz.r = bufio.NewReader(r)\n+\t}\n+\t_, err := io.ReadFull(z.r, z.scratch[0:2])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\th := uint(z.scratch[0])<<8 | uint(z.scratch[1])\n+\tif (z.scratch[0]&0x0f != zlibDeflate) || (h%31 != 0) {\n+\t\treturn ErrHeader\n+\t}\n+\thaveDict := z.scratch[1]&0x20 != 0\n+\tif haveDict {\n+\t\t_, err = io.ReadFull(z.r, z.scratch[0:4])\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tchecksum := uint32(z.scratch[0])<<24 | uint32(z.scratch[1])<<16 | uint32(z.scratch[2])<<8 | uint32(z.scratch[3])\n+\t\tif checksum != adler32.Checksum(dict) {\n+\t\t\treturn ErrDictionary\n+\t\t}\n+\t}\n+\tif z.decompressor == nil {\n+\t\tif haveDict {\n+\t\t\tz.decompressor = flate.NewReaderDict(z.r, dict)\n+\t\t} else {\n+\t\t\tz.decompressor = flate.NewReader(z.r)\n+\t\t}\n+\t} else {\n+\t\tz.decompressor.(flate.Resetter).Reset(z.r, dict)\n+\t}\n+\tz.digest = adler32.New()\n+\treturn nil\n+}"}, {"sha": "9b544bb2118b70226c1e6d143f8d5aea971ec989", "filename": "libgo/go/crypto/cipher/cfb_test.go", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcfb_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -9,10 +9,85 @@ import (\n \t\"crypto/aes\"\n \t\"crypto/cipher\"\n \t\"crypto/rand\"\n+\t\"encoding/hex\"\n \t\"testing\"\n )\n \n-func TestCFB(t *testing.T) {\n+// cfbTests contains the test vectors from\n+// http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf, section\n+// F.3.13.\n+var cfbTests = []struct {\n+\tkey, iv, plaintext, ciphertext string\n+}{\n+\t{\n+\t\t\"2b7e151628aed2a6abf7158809cf4f3c\",\n+\t\t\"000102030405060708090a0b0c0d0e0f\",\n+\t\t\"6bc1bee22e409f96e93d7e117393172a\",\n+\t\t\"3b3fd92eb72dad20333449f8e83cfb4a\",\n+\t},\n+\t{\n+\t\t\"2b7e151628aed2a6abf7158809cf4f3c\",\n+\t\t\"3B3FD92EB72DAD20333449F8E83CFB4A\",\n+\t\t\"ae2d8a571e03ac9c9eb76fac45af8e51\",\n+\t\t\"c8a64537a0b3a93fcde3cdad9f1ce58b\",\n+\t},\n+\t{\n+\t\t\"2b7e151628aed2a6abf7158809cf4f3c\",\n+\t\t\"C8A64537A0B3A93FCDE3CDAD9F1CE58B\",\n+\t\t\"30c81c46a35ce411e5fbc1191a0a52ef\",\n+\t\t\"26751f67a3cbb140b1808cf187a4f4df\",\n+\t},\n+\t{\n+\t\t\"2b7e151628aed2a6abf7158809cf4f3c\",\n+\t\t\"26751F67A3CBB140B1808CF187A4F4DF\",\n+\t\t\"f69f2445df4f9b17ad2b417be66c3710\",\n+\t\t\"c04b05357c5d1c0eeac4c66f9ff7f2e6\",\n+\t},\n+}\n+\n+func TestCFBVectors(t *testing.T) {\n+\tfor i, test := range cfbTests {\n+\t\tkey, err := hex.DecodeString(test.key)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tiv, err := hex.DecodeString(test.iv)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tplaintext, err := hex.DecodeString(test.plaintext)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\texpected, err := hex.DecodeString(test.ciphertext)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tblock, err := aes.NewCipher(key)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tciphertext := make([]byte, len(plaintext))\n+\t\tcfb := cipher.NewCFBEncrypter(block, iv)\n+\t\tcfb.XORKeyStream(ciphertext, plaintext)\n+\n+\t\tif !bytes.Equal(ciphertext, expected) {\n+\t\t\tt.Errorf(\"#%d: wrong output: got %x, expected %x\", i, ciphertext, expected)\n+\t\t}\n+\n+\t\tcfbdec := cipher.NewCFBDecrypter(block, iv)\n+\t\tplaintextCopy := make([]byte, len(ciphertext))\n+\t\tcfbdec.XORKeyStream(plaintextCopy, ciphertext)\n+\n+\t\tif !bytes.Equal(plaintextCopy, plaintextCopy) {\n+\t\t\tt.Errorf(\"#%d: wrong plaintext: got %x, expected %x\", i, plaintextCopy, plaintext)\n+\t\t}\n+\t}\n+}\n+\n+func TestCFBInverse(t *testing.T) {\n \tblock, err := aes.NewCipher(commonKey128)\n \tif err != nil {\n \t\tt.Error(err)"}, {"sha": "1cfa982df4ba4d7de1fa2db172078002ed64a6dc", "filename": "libgo/go/crypto/cipher/example_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -240,7 +240,7 @@ func ExampleStreamReader() {\n \t}\n \n \t// Note that this example is simplistic in that it omits any\n-\t// authentication of the encrypted data. It you were actually to use\n+\t// authentication of the encrypted data. If you were actually to use\n \t// StreamReader in this manner, an attacker could flip arbitrary bits in\n \t// the output.\n }\n@@ -277,7 +277,7 @@ func ExampleStreamWriter() {\n \t}\n \n \t// Note that this example is simplistic in that it omits any\n-\t// authentication of the encrypted data. It you were actually to use\n+\t// authentication of the encrypted data. If you were actually to use\n \t// StreamReader in this manner, an attacker could flip arbitrary bits in\n \t// the decrypted result.\n }"}, {"sha": "59b23e93f5cd9ff637f8cd0d9dd8aa8256b89cae", "filename": "libgo/go/crypto/crypto.go", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -7,23 +7,33 @@ package crypto\n \n import (\n \t\"hash\"\n+\t\"io\"\n \t\"strconv\"\n )\n \n // Hash identifies a cryptographic hash function that is implemented in another\n // package.\n type Hash uint\n \n+// HashFunc simply returns the value of h so that Hash implements SignerOpts.\n+func (h Hash) HashFunc() Hash {\n+\treturn h\n+}\n+\n const (\n-\tMD4       Hash = 1 + iota // import code.google.com/p/go.crypto/md4\n+\tMD4       Hash = 1 + iota // import golang.org/x/crypto/md4\n \tMD5                       // import crypto/md5\n \tSHA1                      // import crypto/sha1\n \tSHA224                    // import crypto/sha256\n \tSHA256                    // import crypto/sha256\n \tSHA384                    // import crypto/sha512\n \tSHA512                    // import crypto/sha512\n \tMD5SHA1                   // no implementation; MD5+SHA1 used for TLS RSA\n-\tRIPEMD160                 // import code.google.com/p/go.crypto/ripemd160\n+\tRIPEMD160                 // import golang.org/x/crypto/ripemd160\n+\tSHA3_224                  // import golang.org/x/crypto/sha3\n+\tSHA3_256                  // import golang.org/x/crypto/sha3\n+\tSHA3_384                  // import golang.org/x/crypto/sha3\n+\tSHA3_512                  // import golang.org/x/crypto/sha3\n \tmaxHash\n )\n \n@@ -35,6 +45,10 @@ var digestSizes = []uint8{\n \tSHA256:    32,\n \tSHA384:    48,\n \tSHA512:    64,\n+\tSHA3_224:  28,\n+\tSHA3_256:  32,\n+\tSHA3_384:  48,\n+\tSHA3_512:  64,\n \tMD5SHA1:   36,\n \tRIPEMD160: 20,\n }\n@@ -83,3 +97,30 @@ type PublicKey interface{}\n \n // PrivateKey represents a private key using an unspecified algorithm.\n type PrivateKey interface{}\n+\n+// Signer is an interface for an opaque private key that can be used for\n+// signing operations. For example, an RSA key kept in a hardware module.\n+type Signer interface {\n+\t// Public returns the public key corresponding to the opaque,\n+\t// private key.\n+\tPublic() PublicKey\n+\n+\t// Sign signs msg with the private key, possibly using entropy from\n+\t// rand. For an RSA key, the resulting signature should be either a\n+\t// PKCS#1 v1.5 or PSS signature (as indicated by opts). For an (EC)DSA\n+\t// key, it should be a DER-serialised, ASN.1 signature structure.\n+\t//\n+\t// Hash implements the SignerOpts interface and, in most cases, one can\n+\t// simply pass in the hash function used as opts. Sign may also attempt\n+\t// to type assert opts to other types in order to obtain algorithm\n+\t// specific values. See the documentation in each package for details.\n+\tSign(rand io.Reader, msg []byte, opts SignerOpts) (signature []byte, err error)\n+}\n+\n+// SignerOpts contains options for signing with a Signer.\n+type SignerOpts interface {\n+\t// HashFunc returns an identifier for the hash function used to produce\n+\t// the message passed to Signer.Sign, or else zero to indicate that no\n+\t// hashing was done.\n+\tHashFunc() Hash\n+}"}, {"sha": "d6135531bff762ec43edfbb928bc0a6df9234961", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -13,7 +13,9 @@ package ecdsa\n //     http://www.secg.org/download/aid-780/sec1-v2.pdf\n \n import (\n+\t\"crypto\"\n \t\"crypto/elliptic\"\n+\t\"encoding/asn1\"\n \t\"io\"\n \t\"math/big\"\n )\n@@ -30,6 +32,28 @@ type PrivateKey struct {\n \tD *big.Int\n }\n \n+type ecdsaSignature struct {\n+\tR, S *big.Int\n+}\n+\n+// Public returns the public key corresponding to priv.\n+func (priv *PrivateKey) Public() crypto.PublicKey {\n+\treturn &priv.PublicKey\n+}\n+\n+// Sign signs msg with priv, reading randomness from rand. This method is\n+// intended to support keys where the private part is kept in, for example, a\n+// hardware module. Common uses should use the Sign function in this package\n+// directly.\n+func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) ([]byte, error) {\n+\tr, s, err := Sign(rand, priv, msg)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn asn1.Marshal(ecdsaSignature{r, s})\n+}\n+\n var one = new(big.Int).SetInt64(1)\n \n // randFieldElement returns a random element of the field underlying the given"}, {"sha": "8cd0a6358e170f057930d33b9fe5a572d28ab73e", "filename": "libgo/go/crypto/md5/gen.go", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fgen.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -7,26 +7,41 @@\n // This program generates md5block.go\n // Invoke as\n //\n-//\tgo run gen.go [-full] |gofmt >md5block.go\n+//\tgo run gen.go [-full] -output md5block.go\n //\n // The -full flag causes the generated code to do a full\n // (16x) unrolling instead of a 4x unrolling.\n \n package main\n \n import (\n+\t\"bytes\"\n \t\"flag\"\n+\t\"go/format\"\n+\t\"io/ioutil\"\n \t\"log\"\n-\t\"os\"\n \t\"strings\"\n \t\"text/template\"\n )\n \n+var filename = flag.String(\"output\", \"md5block.go\", \"output file name\")\n+\n func main() {\n \tflag.Parse()\n \n+\tvar buf bytes.Buffer\n+\n \tt := template.Must(template.New(\"main\").Funcs(funcs).Parse(program))\n-\tif err := t.Execute(os.Stdout, data); err != nil {\n+\tif err := t.Execute(&buf, data); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tdata, err := format.Source(buf.Bytes())\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\terr = ioutil.WriteFile(*filename, data, 0644)\n+\tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n }\n@@ -165,7 +180,7 @@ var program = `// Copyright 2013 The Go Authors. All rights reserved.\n // license that can be found in the LICENSE file.\n \n // DO NOT EDIT.\n-// Generate with: go run gen.go{{if .Full}} -full{{end}} | gofmt >md5block.go\n+// Generate with: go run gen.go{{if .Full}} -full{{end}} -output md5block.go\n \n package md5\n "}, {"sha": "8c50c6d0bfaa7db920a48988ae5af5ecff7dd411", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:generate go run gen.go -full -output md5block.go\n+\n // Package md5 implements the MD5 hash algorithm as defined in RFC 1321.\n package md5\n "}, {"sha": "64e1e7c1efdb15e8c06dce73f87f1cedaccea99e", "filename": "libgo/go/crypto/md5/md5block.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5block.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // DO NOT EDIT.\n-// Generate with: go run gen.go -full | gofmt >md5block.go\n+// Generate with: go run gen.go -full -output md5block.go\n \n package md5\n "}, {"sha": "8cb59c75dfffa953fb767996e44e18bc5d8a32eb", "filename": "libgo/go/crypto/rand/rand_linux.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package rand\n+\n+import (\n+\t\"internal/syscall\"\n+\t\"sync\"\n+)\n+\n+func init() {\n+\taltGetRandom = getRandomLinux\n+}\n+\n+var (\n+\tonce       sync.Once\n+\tuseSyscall bool\n+)\n+\n+func pickStrategy() {\n+\t// Test whether we should use the system call or /dev/urandom.\n+\t// We'll fall back to urandom if:\n+\t// - the kernel is too old (before 3.17)\n+\t// - the machine has no entropy available (early boot + no hardware\n+\t//   entropy source?) and we want to avoid blocking later.\n+\tvar buf [1]byte\n+\tn, err := syscall.GetRandom(buf[:], syscall.GRND_NONBLOCK)\n+\tuseSyscall = n == 1 && err == nil\n+}\n+\n+func getRandomLinux(p []byte) (ok bool) {\n+\tonce.Do(pickStrategy)\n+\tif !useSyscall {\n+\t\treturn false\n+\t}\n+\tn, err := syscall.GetRandom(p, 0)\n+\treturn n == len(p) && err == nil\n+}"}, {"sha": "62d0fbdb350c4d7013186893b3d065e1ce5b8a02", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -20,14 +20,16 @@ import (\n \t\"time\"\n )\n \n+const urandomDevice = \"/dev/urandom\"\n+\n // Easy implementation: read from /dev/urandom.\n // This is sufficient on Linux, OS X, and FreeBSD.\n \n func init() {\n \tif runtime.GOOS == \"plan9\" {\n \t\tReader = newReader(nil)\n \t} else {\n-\t\tReader = &devReader{name: \"/dev/urandom\"}\n+\t\tReader = &devReader{name: urandomDevice}\n \t}\n }\n \n@@ -38,7 +40,14 @@ type devReader struct {\n \tmu   sync.Mutex\n }\n \n+// altGetRandom if non-nil specifies an OS-specific function to get\n+// urandom-style randomness.\n+var altGetRandom func([]byte) (ok bool)\n+\n func (r *devReader) Read(b []byte) (n int, err error) {\n+\tif altGetRandom != nil && r.name == urandomDevice && altGetRandom(b) {\n+\t\treturn len(b), nil\n+\t}\n \tr.mu.Lock()\n \tdefer r.mu.Unlock()\n \tif r.f == nil {"}, {"sha": "02e5b67d55385f604a26711d206ed1e105a818ae", "filename": "libgo/go/crypto/rc4/rc4_asm.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_asm.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 amd64p32 arm 386\n+// +build amd64 amd64p32 arm,!nacl 386\n \n package rc4\n "}, {"sha": "e34bd34cf1df90d7719b20ded5ab87da1a92d3bc", "filename": "libgo/go/crypto/rc4/rc4_ref.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4_ref.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !amd64,!amd64p32,!arm,!386\n+// +build !amd64,!amd64p32,!arm,!386 arm,nacl\n \n package rc4\n "}, {"sha": "e9f2908250cc3a2a9d3f2fc1c1a6cc875ccf6805", "filename": "libgo/go/crypto/rsa/pss.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpss.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -222,6 +222,17 @@ type PSSOptions struct {\n \t// signature. It can either be a number of bytes, or one of the special\n \t// PSSSaltLength constants.\n \tSaltLength int\n+\n+\t// Hash, if not zero, overrides the hash function passed to SignPSS.\n+\t// This is the only way to specify the hash function when using the\n+\t// crypto.Signer interface.\n+\tHash crypto.Hash\n+}\n+\n+// HashFunc returns pssOpts.Hash so that PSSOptions implements\n+// crypto.SignerOpts.\n+func (pssOpts *PSSOptions) HashFunc() crypto.Hash {\n+\treturn pssOpts.Hash\n }\n \n func (opts *PSSOptions) saltLength() int {\n@@ -244,6 +255,10 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte,\n \t\tsaltLength = hash.Size()\n \t}\n \n+\tif opts.Hash != 0 {\n+\t\thash = opts.Hash\n+\t}\n+\n \tsalt := make([]byte, saltLength)\n \tif _, err = io.ReadFull(rand, salt); err != nil {\n \t\treturn"}, {"sha": "2702311281ce07a64c71ff56223d4a75c0041bf0", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,6 +6,7 @@\n package rsa\n \n import (\n+\t\"crypto\"\n \t\"crypto/rand\"\n \t\"crypto/subtle\"\n \t\"errors\"\n@@ -58,6 +59,24 @@ type PrivateKey struct {\n \tPrecomputed PrecomputedValues\n }\n \n+// Public returns the public key corresponding to priv.\n+func (priv *PrivateKey) Public() crypto.PublicKey {\n+\treturn &priv.PublicKey\n+}\n+\n+// Sign signs msg with priv, reading randomness from rand. If opts is a\n+// *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will\n+// be used. This method is intended to support keys where the private part is\n+// kept in, for example, a hardware module. Common uses should use the Sign*\n+// functions in this package.\n+func (priv *PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) ([]byte, error) {\n+\tif pssOpts, ok := opts.(*PSSOptions); ok {\n+\t\treturn SignPSS(rand, priv, pssOpts.Hash, msg, pssOpts)\n+\t}\n+\n+\treturn SignPKCS1v15(rand, priv, opts.HashFunc(), msg)\n+}\n+\n type PrecomputedValues struct {\n \tDp, Dq *big.Int // D mod (P-1) (or mod Q-1)\n \tQinv   *big.Int // Q^-1 mod P"}, {"sha": "6f80e7c58dc3c8d551b05c8a171b3da9fed6b006", "filename": "libgo/go/crypto/subtle/constant_time.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,12 +6,12 @@\n // code but require careful thought to use correctly.\n package subtle\n \n-// ConstantTimeCompare returns 1 iff the two equal length slices, x\n+// ConstantTimeCompare returns 1 iff the two slices, x\n // and y, have equal contents. The time taken is a function of the length of\n // the slices and is independent of the contents.\n func ConstantTimeCompare(x, y []byte) int {\n \tif len(x) != len(y) {\n-\t\tpanic(\"subtle: slices have different lengths\")\n+\t\treturn 0\n \t}\n \n \tvar v byte\n@@ -62,7 +62,6 @@ func ConstantTimeCopy(v int, x, y []byte) {\n \tfor i := 0; i < len(x); i++ {\n \t\tx[i] = x[i]&xmask | y[i]&ymask\n \t}\n-\treturn\n }\n \n // ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise."}, {"sha": "619a454441d9570d3e10a1a930dbbdb95c657676", "filename": "libgo/go/crypto/subtle/constant_time_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsubtle%2Fconstant_time_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -18,6 +18,8 @@ var testConstantTimeCompareData = []TestConstantTimeCompareStruct{\n \t{[]byte{}, []byte{}, 1},\n \t{[]byte{0x11}, []byte{0x11}, 1},\n \t{[]byte{0x12}, []byte{0x11}, 0},\n+\t{[]byte{0x11}, []byte{0x11, 0x12}, 0},\n+\t{[]byte{0x11, 0x12}, []byte{0x11}, 0},\n }\n \n func TestConstantTimeCompare(t *testing.T) {"}, {"sha": "3de4834d3f5b83ec3165396788345bd6fe612c0b", "filename": "libgo/go/crypto/tls/alert.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -35,6 +35,7 @@ const (\n \talertProtocolVersion        alert = 70\n \talertInsufficientSecurity   alert = 71\n \talertInternalError          alert = 80\n+\talertInappropriateFallback  alert = 86\n \talertUserCanceled           alert = 90\n \talertNoRenegotiation        alert = 100\n )\n@@ -60,6 +61,7 @@ var alertText = map[alert]string{\n \talertProtocolVersion:        \"protocol version not supported\",\n \talertInsufficientSecurity:   \"insufficient security level\",\n \talertInternalError:          \"internal error\",\n+\talertInappropriateFallback:  \"inappropriate fallback\",\n \talertUserCanceled:           \"user canceled\",\n \talertNoRenegotiation:        \"no renegotiation\",\n }"}, {"sha": "226e06d68d63acb4b314b38210e747565a85f65c", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -267,4 +267,9 @@ const (\n \tTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0xc014\n \tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   uint16 = 0xc02f\n \tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b\n+\n+\t// TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator\n+\t// that the client is doing version fallback. See\n+\t// https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00.\n+\tTLS_FALLBACK_SCSV uint16 = 0x5600\n )"}, {"sha": "776b70c93c8fc632b6b82be296220b14dec3d0a5", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 63, "deletions": 10, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -72,6 +72,7 @@ const (\n \textensionSupportedCurves     uint16 = 10\n \textensionSupportedPoints     uint16 = 11\n \textensionSignatureAlgorithms uint16 = 13\n+\textensionALPN                uint16 = 16\n \textensionSessionTicket       uint16 = 35\n \textensionNextProtoNeg        uint16 = 13172 // not IANA assigned\n \textensionRenegotiationInfo   uint16 = 0xff01\n@@ -164,6 +165,14 @@ type ConnectionState struct {\n \tServerName                 string                // server name requested by client, if any (server side only)\n \tPeerCertificates           []*x509.Certificate   // certificate chain presented by remote peer\n \tVerifiedChains             [][]*x509.Certificate // verified chains built from PeerCertificates\n+\n+\t// TLSUnique contains the \"tls-unique\" channel binding value (see RFC\n+\t// 5929, section 3). For resumed sessions this value will be nil\n+\t// because resumption does not include enough context (see\n+\t// https://secure-resumption.com/#channelbindings). This will change in\n+\t// future versions of Go once the TLS master-secret fix has been\n+\t// standardized and implemented.\n+\tTLSUnique []byte\n }\n \n // ClientAuthType declares the policy the server will follow for\n@@ -201,6 +210,32 @@ type ClientSessionCache interface {\n \tPut(sessionKey string, cs *ClientSessionState)\n }\n \n+// ClientHelloInfo contains information from a ClientHello message in order to\n+// guide certificate selection in the GetCertificate callback.\n+type ClientHelloInfo struct {\n+\t// CipherSuites lists the CipherSuites supported by the client (e.g.\n+\t// TLS_RSA_WITH_RC4_128_SHA).\n+\tCipherSuites []uint16\n+\n+\t// ServerName indicates the name of the server requested by the client\n+\t// in order to support virtual hosting. ServerName is only set if the\n+\t// client is using SNI (see\n+\t// http://tools.ietf.org/html/rfc4366#section-3.1).\n+\tServerName string\n+\n+\t// SupportedCurves lists the elliptic curves supported by the client.\n+\t// SupportedCurves is set only if the Supported Elliptic Curves\n+\t// Extension is being used (see\n+\t// http://tools.ietf.org/html/rfc4492#section-5.1.1).\n+\tSupportedCurves []CurveID\n+\n+\t// SupportedPoints lists the point formats supported by the client.\n+\t// SupportedPoints is set only if the Supported Point Formats Extension\n+\t// is being used (see\n+\t// http://tools.ietf.org/html/rfc4492#section-5.1.2).\n+\tSupportedPoints []uint8\n+}\n+\n // A Config structure is used to configure a TLS client or server.\n // After one has been passed to a TLS function it must not be\n // modified. A Config may be reused; the tls package will also not\n@@ -229,6 +264,13 @@ type Config struct {\n \t// for all connections.\n \tNameToCertificate map[string]*Certificate\n \n+\t// GetCertificate returns a Certificate based on the given\n+\t// ClientHelloInfo. If GetCertificate is nil or returns nil, then the\n+\t// certificate is retrieved from NameToCertificate. If\n+\t// NameToCertificate is nil, the first element of Certificates will be\n+\t// used.\n+\tGetCertificate func(clientHello *ClientHelloInfo) (*Certificate, error)\n+\n \t// RootCAs defines the set of root certificate authorities\n \t// that clients use when verifying server certificates.\n \t// If RootCAs is nil, TLS uses the host's root CA set.\n@@ -383,22 +425,28 @@ func (c *Config) mutualVersion(vers uint16) (uint16, bool) {\n \treturn vers, true\n }\n \n-// getCertificateForName returns the best certificate for the given name,\n-// defaulting to the first element of c.Certificates if there are no good\n-// options.\n-func (c *Config) getCertificateForName(name string) *Certificate {\n+// getCertificate returns the best certificate for the given ClientHelloInfo,\n+// defaulting to the first element of c.Certificates.\n+func (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, error) {\n+\tif c.GetCertificate != nil {\n+\t\tcert, err := c.GetCertificate(clientHello)\n+\t\tif cert != nil || err != nil {\n+\t\t\treturn cert, err\n+\t\t}\n+\t}\n+\n \tif len(c.Certificates) == 1 || c.NameToCertificate == nil {\n \t\t// There's only one choice, so no point doing any work.\n-\t\treturn &c.Certificates[0]\n+\t\treturn &c.Certificates[0], nil\n \t}\n \n-\tname = strings.ToLower(name)\n+\tname := strings.ToLower(clientHello.ServerName)\n \tfor len(name) > 0 && name[len(name)-1] == '.' {\n \t\tname = name[:len(name)-1]\n \t}\n \n \tif cert, ok := c.NameToCertificate[name]; ok {\n-\t\treturn cert\n+\t\treturn cert, nil\n \t}\n \n \t// try replacing labels in the name with wildcards until we get a\n@@ -408,12 +456,12 @@ func (c *Config) getCertificateForName(name string) *Certificate {\n \t\tlabels[i] = \"*\"\n \t\tcandidate := strings.Join(labels, \".\")\n \t\tif cert, ok := c.NameToCertificate[candidate]; ok {\n-\t\t\treturn cert\n+\t\t\treturn cert, nil\n \t\t}\n \t}\n \n \t// If nothing matches, return the first certificate.\n-\treturn &c.Certificates[0]\n+\treturn &c.Certificates[0], nil\n }\n \n // BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate\n@@ -439,7 +487,12 @@ func (c *Config) BuildNameToCertificate() {\n // A Certificate is a chain of one or more certificates, leaf first.\n type Certificate struct {\n \tCertificate [][]byte\n-\tPrivateKey  crypto.PrivateKey // supported types: *rsa.PrivateKey, *ecdsa.PrivateKey\n+\t// PrivateKey contains the private key corresponding to the public key\n+\t// in Leaf. For a server, this must be a *rsa.PrivateKey or\n+\t// *ecdsa.PrivateKey. For a client doing client authentication, this\n+\t// can be any type that implements crypto.Signer (which includes RSA\n+\t// and ECDSA private keys).\n+\tPrivateKey crypto.PrivateKey\n \t// OCSPStaple contains an optional OCSP response which will be served\n \t// to clients that request it.\n \tOCSPStaple []byte"}, {"sha": "ba8e4c22b70656314f0c26a0e9c4e243c71189ab", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -42,6 +42,9 @@ type Conn struct {\n \tverifiedChains [][]*x509.Certificate\n \t// serverName contains the server name indicated by the client, if any.\n \tserverName string\n+\t// firstFinished contains the first Finished hash sent during the\n+\t// handshake. This is the \"tls-unique\" channel binding value.\n+\tfirstFinished [12]byte\n \n \tclientProtocol         string\n \tclientProtocolFallback bool\n@@ -994,6 +997,9 @@ func (c *Conn) ConnectionState() ConnectionState {\n \t\tstate.PeerCertificates = c.peerCertificates\n \t\tstate.VerifiedChains = c.verifiedChains\n \t\tstate.ServerName = c.serverName\n+\t\tif !c.didResume {\n+\t\t\tstate.TLSUnique = c.firstFinished[:]\n+\t\t}\n \t}\n \n \treturn state"}, {"sha": "ec802cad70fc74d599dbe0ad48a7eb8dbaaf116a", "filename": "libgo/go/crypto/tls/conn_test.go", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -88,19 +88,31 @@ func TestCertificateSelection(t *testing.T) {\n \t\treturn -1\n \t}\n \n-\tif n := pointerToIndex(config.getCertificateForName(\"example.com\")); n != 0 {\n+\tcertificateForName := func(name string) *Certificate {\n+\t\tclientHello := &ClientHelloInfo{\n+\t\t\tServerName: name,\n+\t\t}\n+\t\tif cert, err := config.getCertificate(clientHello); err != nil {\n+\t\t\tt.Errorf(\"unable to get certificate for name '%s': %s\", name, err)\n+\t\t\treturn nil\n+\t\t} else {\n+\t\t\treturn cert\n+\t\t}\n+\t}\n+\n+\tif n := pointerToIndex(certificateForName(\"example.com\")); n != 0 {\n \t\tt.Errorf(\"example.com returned certificate %d, not 0\", n)\n \t}\n-\tif n := pointerToIndex(config.getCertificateForName(\"bar.example.com\")); n != 1 {\n+\tif n := pointerToIndex(certificateForName(\"bar.example.com\")); n != 1 {\n \t\tt.Errorf(\"bar.example.com returned certificate %d, not 1\", n)\n \t}\n-\tif n := pointerToIndex(config.getCertificateForName(\"foo.example.com\")); n != 2 {\n+\tif n := pointerToIndex(certificateForName(\"foo.example.com\")); n != 2 {\n \t\tt.Errorf(\"foo.example.com returned certificate %d, not 2\", n)\n \t}\n-\tif n := pointerToIndex(config.getCertificateForName(\"foo.bar.example.com\")); n != 3 {\n+\tif n := pointerToIndex(certificateForName(\"foo.bar.example.com\")); n != 3 {\n \t\tt.Errorf(\"foo.bar.example.com returned certificate %d, not 3\", n)\n \t}\n-\tif n := pointerToIndex(config.getCertificateForName(\"foo.bar.baz.example.com\")); n != 0 {\n+\tif n := pointerToIndex(certificateForName(\"foo.bar.baz.example.com\")); n != 0 {\n \t\tt.Errorf(\"foo.bar.baz.example.com returned certificate %d, not 0\", n)\n \t}\n }"}, {"sha": "83f9916ff9d937e1eefcd30e0de6d95a3d5a8c42", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -10,6 +10,8 @@\n package main\n \n import (\n+\t\"crypto/ecdsa\"\n+\t\"crypto/elliptic\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n \t\"crypto/x509\"\n@@ -26,21 +28,65 @@ import (\n )\n \n var (\n-\thost      = flag.String(\"host\", \"\", \"Comma-separated hostnames and IPs to generate a certificate for\")\n-\tvalidFrom = flag.String(\"start-date\", \"\", \"Creation date formatted as Jan 1 15:04:05 2011\")\n-\tvalidFor  = flag.Duration(\"duration\", 365*24*time.Hour, \"Duration that certificate is valid for\")\n-\tisCA      = flag.Bool(\"ca\", false, \"whether this cert should be its own Certificate Authority\")\n-\trsaBits   = flag.Int(\"rsa-bits\", 2048, \"Size of RSA key to generate\")\n+\thost       = flag.String(\"host\", \"\", \"Comma-separated hostnames and IPs to generate a certificate for\")\n+\tvalidFrom  = flag.String(\"start-date\", \"\", \"Creation date formatted as Jan 1 15:04:05 2011\")\n+\tvalidFor   = flag.Duration(\"duration\", 365*24*time.Hour, \"Duration that certificate is valid for\")\n+\tisCA       = flag.Bool(\"ca\", false, \"whether this cert should be its own Certificate Authority\")\n+\trsaBits    = flag.Int(\"rsa-bits\", 2048, \"Size of RSA key to generate. Ignored if --ecdsa-curve is set\")\n+\tecdsaCurve = flag.String(\"ecdsa-curve\", \"\", \"ECDSA curve to use to generate a key. Valid values are P224, P256, P384, P521\")\n )\n \n+func publicKey(priv interface{}) interface{} {\n+\tswitch k := priv.(type) {\n+\tcase *rsa.PrivateKey:\n+\t\treturn &k.PublicKey\n+\tcase *ecdsa.PrivateKey:\n+\t\treturn &k.PublicKey\n+\tdefault:\n+\t\treturn nil\n+\t}\n+}\n+\n+func pemBlockForKey(priv interface{}) *pem.Block {\n+\tswitch k := priv.(type) {\n+\tcase *rsa.PrivateKey:\n+\t\treturn &pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(k)}\n+\tcase *ecdsa.PrivateKey:\n+\t\tb, err := x509.MarshalECPrivateKey(k)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"Unable to marshal ECDSA private key: %v\", err)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\treturn &pem.Block{Type: \"EC PRIVATE KEY\", Bytes: b}\n+\tdefault:\n+\t\treturn nil\n+\t}\n+}\n+\n func main() {\n \tflag.Parse()\n \n \tif len(*host) == 0 {\n \t\tlog.Fatalf(\"Missing required --host parameter\")\n \t}\n \n-\tpriv, err := rsa.GenerateKey(rand.Reader, *rsaBits)\n+\tvar priv interface{}\n+\tvar err error\n+\tswitch *ecdsaCurve {\n+\tcase \"\":\n+\t\tpriv, err = rsa.GenerateKey(rand.Reader, *rsaBits)\n+\tcase \"P224\":\n+\t\tpriv, err = ecdsa.GenerateKey(elliptic.P224(), rand.Reader)\n+\tcase \"P256\":\n+\t\tpriv, err = ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n+\tcase \"P384\":\n+\t\tpriv, err = ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\n+\tcase \"P521\":\n+\t\tpriv, err = ecdsa.GenerateKey(elliptic.P521(), rand.Reader)\n+\tdefault:\n+\t\tfmt.Fprintf(os.Stderr, \"Unrecognized elliptic curve: %q\", *ecdsaCurve)\n+\t\tos.Exit(1)\n+\t}\n \tif err != nil {\n \t\tlog.Fatalf(\"failed to generate private key: %s\", err)\n \t}\n@@ -91,7 +137,7 @@ func main() {\n \t\ttemplate.KeyUsage |= x509.KeyUsageCertSign\n \t}\n \n-\tderBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)\n+\tderBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, publicKey(priv), priv)\n \tif err != nil {\n \t\tlog.Fatalf(\"Failed to create certificate: %s\", err)\n \t}\n@@ -109,7 +155,7 @@ func main() {\n \t\tlog.Print(\"failed to open key.pem for writing:\", err)\n \t\treturn\n \t}\n-\tpem.Encode(keyOut, &pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(priv)})\n+\tpem.Encode(keyOut, pemBlockForKey(priv))\n \tkeyOut.Close()\n \tlog.Print(\"written key.pem\\n\")\n }"}, {"sha": "7f662e9c9f3501f5ded4b276dda1edaea958d926", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,11 +6,11 @@ package tls\n \n import (\n \t\"bytes\"\n+\t\"crypto\"\n \t\"crypto/ecdsa\"\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n-\t\"encoding/asn1\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n@@ -37,6 +37,18 @@ func (c *Conn) clientHandshake() error {\n \t\treturn errors.New(\"tls: either ServerName or InsecureSkipVerify must be specified in the tls.Config\")\n \t}\n \n+\tnextProtosLength := 0\n+\tfor _, proto := range c.config.NextProtos {\n+\t\tif l := len(proto); l == 0 || l > 255 {\n+\t\t\treturn errors.New(\"tls: invalid NextProtos value\")\n+\t\t} else {\n+\t\t\tnextProtosLength += 1 + l\n+\t\t}\n+\t}\n+\tif nextProtosLength > 0xffff {\n+\t\treturn errors.New(\"tls: NextProtos values too large\")\n+\t}\n+\n \thello := &clientHelloMsg{\n \t\tvers:                c.config.maxVersion(),\n \t\tcompressionMethods:  []uint8{compressionNone},\n@@ -47,6 +59,7 @@ func (c *Conn) clientHandshake() error {\n \t\tsupportedPoints:     []uint8{pointFormatUncompressed},\n \t\tnextProtoNeg:        len(c.config.NextProtos) > 0,\n \t\tsecureRenegotiation: true,\n+\t\talpnProtocols:       c.config.NextProtos,\n \t}\n \n \tpossibleCipherSuites := c.config.cipherSuites()\n@@ -174,10 +187,10 @@ NextCipherSuite:\n \t\tif err := hs.readSessionTicket(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.readFinished(); err != nil {\n+\t\tif err := hs.readFinished(c.firstFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.sendFinished(); err != nil {\n+\t\tif err := hs.sendFinished(nil); err != nil {\n \t\t\treturn err\n \t\t}\n \t} else {\n@@ -187,13 +200,13 @@ NextCipherSuite:\n \t\tif err := hs.establishKeys(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.sendFinished(); err != nil {\n+\t\tif err := hs.sendFinished(c.firstFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n \t\tif err := hs.readSessionTicket(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.readFinished(); err != nil {\n+\t\tif err := hs.readFinished(nil); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -332,8 +345,8 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\t}\n \n \t\t// We need to search our list of client certs for one\n-\t\t// where SignatureAlgorithm is RSA and the Issuer is in\n-\t\t// certReq.certificateAuthorities\n+\t\t// where SignatureAlgorithm is acceptable to the server and the\n+\t\t// Issuer is in certReq.certificateAuthorities\n \tfindCert:\n \t\tfor i, chain := range c.config.Certificates {\n \t\t\tif !rsaAvail && !ecdsaAvail {\n@@ -360,7 +373,7 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \n \t\t\t\tif len(certReq.certificateAuthorities) == 0 {\n \t\t\t\t\t// they gave us an empty list, so just take the\n-\t\t\t\t\t// first RSA cert from c.config.Certificates\n+\t\t\t\t\t// first cert from c.config.Certificates\n \t\t\t\t\tchainToSend = &chain\n \t\t\t\t\tbreak findCert\n \t\t\t\t}\n@@ -415,22 +428,24 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\t\thasSignatureAndHash: c.vers >= VersionTLS12,\n \t\t}\n \n-\t\tswitch key := c.config.Certificates[0].PrivateKey.(type) {\n-\t\tcase *ecdsa.PrivateKey:\n-\t\t\tdigest, _, hashId := hs.finishedHash.hashForClientCertificate(signatureECDSA)\n-\t\t\tr, s, err := ecdsa.Sign(c.config.rand(), key, digest)\n-\t\t\tif err == nil {\n-\t\t\t\tsigned, err = asn1.Marshal(ecdsaSignature{r, s})\n-\t\t\t}\n+\t\tkey, ok := chainToSend.PrivateKey.(crypto.Signer)\n+\t\tif !ok {\n+\t\t\tc.sendAlert(alertInternalError)\n+\t\t\treturn fmt.Errorf(\"tls: client certificate private key of type %T does not implement crypto.Signer\", chainToSend.PrivateKey)\n+\t\t}\n+\t\tswitch key.Public().(type) {\n+\t\tcase *ecdsa.PublicKey:\n+\t\t\tdigest, hashFunc, hashId := hs.finishedHash.hashForClientCertificate(signatureECDSA)\n+\t\t\tsigned, err = key.Sign(c.config.rand(), digest, hashFunc)\n \t\t\tcertVerify.signatureAndHash.signature = signatureECDSA\n \t\t\tcertVerify.signatureAndHash.hash = hashId\n-\t\tcase *rsa.PrivateKey:\n+\t\tcase *rsa.PublicKey:\n \t\t\tdigest, hashFunc, hashId := hs.finishedHash.hashForClientCertificate(signatureRSA)\n-\t\t\tsigned, err = rsa.SignPKCS1v15(c.config.rand(), key, hashFunc, digest)\n+\t\t\tsigned, err = key.Sign(c.config.rand(), digest, hashFunc)\n \t\t\tcertVerify.signatureAndHash.signature = signatureRSA\n \t\t\tcertVerify.signatureAndHash.hash = hashId\n \t\tdefault:\n-\t\t\terr = errors.New(\"unknown private key type\")\n+\t\t\terr = fmt.Errorf(\"tls: unknown client certificate key type: %T\", key)\n \t\t}\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertInternalError)\n@@ -483,11 +498,31 @@ func (hs *clientHandshakeState) processServerHello() (bool, error) {\n \t\treturn false, errors.New(\"tls: server selected unsupported compression format\")\n \t}\n \n-\tif !hs.hello.nextProtoNeg && hs.serverHello.nextProtoNeg {\n+\tclientDidNPN := hs.hello.nextProtoNeg\n+\tclientDidALPN := len(hs.hello.alpnProtocols) > 0\n+\tserverHasNPN := hs.serverHello.nextProtoNeg\n+\tserverHasALPN := len(hs.serverHello.alpnProtocol) > 0\n+\n+\tif !clientDidNPN && serverHasNPN {\n \t\tc.sendAlert(alertHandshakeFailure)\n \t\treturn false, errors.New(\"server advertised unrequested NPN extension\")\n \t}\n \n+\tif !clientDidALPN && serverHasALPN {\n+\t\tc.sendAlert(alertHandshakeFailure)\n+\t\treturn false, errors.New(\"server advertised unrequested ALPN extension\")\n+\t}\n+\n+\tif serverHasNPN && serverHasALPN {\n+\t\tc.sendAlert(alertHandshakeFailure)\n+\t\treturn false, errors.New(\"server advertised both NPN and ALPN extensions\")\n+\t}\n+\n+\tif serverHasALPN {\n+\t\tc.clientProtocol = hs.serverHello.alpnProtocol\n+\t\tc.clientProtocolFallback = false\n+\t}\n+\n \tif hs.serverResumedSession() {\n \t\t// Restore masterSecret and peerCerts from previous state\n \t\ths.masterSecret = hs.session.masterSecret\n@@ -497,7 +532,7 @@ func (hs *clientHandshakeState) processServerHello() (bool, error) {\n \treturn false, nil\n }\n \n-func (hs *clientHandshakeState) readFinished() error {\n+func (hs *clientHandshakeState) readFinished(out []byte) error {\n \tc := hs.c\n \n \tc.readRecord(recordTypeChangeCipherSpec)\n@@ -522,6 +557,7 @@ func (hs *clientHandshakeState) readFinished() error {\n \t\treturn errors.New(\"tls: server's Finished message was incorrect\")\n \t}\n \ths.finishedHash.Write(serverFinished.marshal())\n+\tcopy(out, verify)\n \treturn nil\n }\n \n@@ -553,7 +589,7 @@ func (hs *clientHandshakeState) readSessionTicket() error {\n \treturn nil\n }\n \n-func (hs *clientHandshakeState) sendFinished() error {\n+func (hs *clientHandshakeState) sendFinished(out []byte) error {\n \tc := hs.c\n \n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n@@ -572,6 +608,7 @@ func (hs *clientHandshakeState) sendFinished() error {\n \tfinished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)\n \ths.finishedHash.Write(finished.marshal())\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n+\tcopy(out, finished.verifyData)\n \treturn nil\n }\n \n@@ -584,18 +621,18 @@ func clientSessionCacheKey(serverAddr net.Addr, config *Config) string {\n \treturn serverAddr.String()\n }\n \n-// mutualProtocol finds the mutual Next Protocol Negotiation protocol given the\n-// set of client and server supported protocols. The set of client supported\n-// protocols must not be empty. It returns the resulting protocol and flag\n+// mutualProtocol finds the mutual Next Protocol Negotiation or ALPN protocol\n+// given list of possible protocols and a list of the preference order. The\n+// first list must not be empty. It returns the resulting protocol and flag\n // indicating if the fallback case was reached.\n-func mutualProtocol(clientProtos, serverProtos []string) (string, bool) {\n-\tfor _, s := range serverProtos {\n-\t\tfor _, c := range clientProtos {\n+func mutualProtocol(protos, preferenceProtos []string) (string, bool) {\n+\tfor _, s := range preferenceProtos {\n+\t\tfor _, c := range protos {\n \t\t\tif s == c {\n \t\t\t\treturn s, false\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn clientProtos[0], true\n+\treturn protos[0], true\n }"}, {"sha": "e5eaa7de20830b91f48dc6a05fbf7108208c8c89", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -49,6 +49,10 @@ type clientTest struct {\n \t// key, if not nil, contains either a *rsa.PrivateKey or\n \t// *ecdsa.PrivateKey which is the private key for the reference server.\n \tkey interface{}\n+\t// validate, if not nil, is a function that will be called with the\n+\t// ConnectionState of the resulting connection. It returns a non-nil\n+\t// error if the ConnectionState is unacceptable.\n+\tvalidate func(ConnectionState) error\n }\n \n var defaultServerCommand = []string{\"openssl\", \"s_server\"}\n@@ -188,6 +192,11 @@ func (test *clientTest) run(t *testing.T, write bool) {\n \t\tif _, err := client.Write([]byte(\"hello\\n\")); err != nil {\n \t\t\tt.Logf(\"Client.Write failed: %s\", err)\n \t\t}\n+\t\tif test.validate != nil {\n+\t\t\tif err := test.validate(client.ConnectionState()); err != nil {\n+\t\t\t\tt.Logf(\"validate callback returned error: %s\", err)\n+\t\t\t}\n+\t\t}\n \t\tclient.Close()\n \t\tclientConn.Close()\n \t\tdoneChan <- true\n@@ -196,7 +205,7 @@ func (test *clientTest) run(t *testing.T, write bool) {\n \tif !write {\n \t\tflows, err := test.loadData()\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"%s: failed to load data from %s\", test.name, test.dataPath())\n+\t\t\tt.Fatalf(\"%s: failed to load data from %s: %v\", test.name, test.dataPath(), err)\n \t\t}\n \t\tfor i, b := range flows {\n \t\t\tif i%2 == 1 {\n@@ -437,3 +446,45 @@ func TestLRUClientSessionCache(t *testing.T) {\n \t\tt.Fatalf(\"failed to add nil entry to cache\")\n \t}\n }\n+\n+func TestHandshakeClientALPNMatch(t *testing.T) {\n+\tconfig := *testConfig\n+\tconfig.NextProtos = []string{\"proto2\", \"proto1\"}\n+\n+\ttest := &clientTest{\n+\t\tname: \"ALPN\",\n+\t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n+\t\t// version that supports the -alpn flag.\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-alpn\", \"proto1,proto2\"},\n+\t\tconfig:  &config,\n+\t\tvalidate: func(state ConnectionState) error {\n+\t\t\t// The server's preferences should override the client.\n+\t\t\tif state.NegotiatedProtocol != \"proto1\" {\n+\t\t\t\treturn fmt.Errorf(\"Got protocol %q, wanted proto1\", state.NegotiatedProtocol)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\trunClientTestTLS12(t, test)\n+}\n+\n+func TestHandshakeClientALPNNoMatch(t *testing.T) {\n+\tconfig := *testConfig\n+\tconfig.NextProtos = []string{\"proto3\"}\n+\n+\ttest := &clientTest{\n+\t\tname: \"ALPN-NoMatch\",\n+\t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n+\t\t// version that supports the -alpn flag.\n+\t\tcommand: []string{\"openssl\", \"s_server\", \"-alpn\", \"proto1,proto2\"},\n+\t\tconfig:  &config,\n+\t\tvalidate: func(state ConnectionState) error {\n+\t\t\t// There's no overlap so OpenSSL will not select a protocol.\n+\t\t\tif state.NegotiatedProtocol != \"\" {\n+\t\t\t\treturn fmt.Errorf(\"Got protocol %q, wanted ''\", state.NegotiatedProtocol)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\trunClientTestTLS12(t, test)\n+}"}, {"sha": "5d14871a348e6ece28a1bea5296e6766d3474527", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 96, "deletions": 2, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -22,6 +22,7 @@ type clientHelloMsg struct {\n \tsessionTicket       []uint8\n \tsignatureAndHashes  []signatureAndHash\n \tsecureRenegotiation bool\n+\talpnProtocols       []string\n }\n \n func (m *clientHelloMsg) equal(i interface{}) bool {\n@@ -44,7 +45,8 @@ func (m *clientHelloMsg) equal(i interface{}) bool {\n \t\tm.ticketSupported == m1.ticketSupported &&\n \t\tbytes.Equal(m.sessionTicket, m1.sessionTicket) &&\n \t\teqSignatureAndHashes(m.signatureAndHashes, m1.signatureAndHashes) &&\n-\t\tm.secureRenegotiation == m1.secureRenegotiation\n+\t\tm.secureRenegotiation == m1.secureRenegotiation &&\n+\t\teqStrings(m.alpnProtocols, m1.alpnProtocols)\n }\n \n func (m *clientHelloMsg) marshal() []byte {\n@@ -86,6 +88,17 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\textensionsLength += 1\n \t\tnumExtensions++\n \t}\n+\tif len(m.alpnProtocols) > 0 {\n+\t\textensionsLength += 2\n+\t\tfor _, s := range m.alpnProtocols {\n+\t\t\tif l := len(s); l == 0 || l > 255 {\n+\t\t\t\tpanic(\"invalid ALPN protocol\")\n+\t\t\t}\n+\t\t\textensionsLength++\n+\t\t\textensionsLength += len(s)\n+\t\t}\n+\t\tnumExtensions++\n+\t}\n \tif numExtensions > 0 {\n \t\textensionsLength += 4 * numExtensions\n \t\tlength += 2 + extensionsLength\n@@ -237,6 +250,27 @@ func (m *clientHelloMsg) marshal() []byte {\n \t\tz[3] = 1\n \t\tz = z[5:]\n \t}\n+\tif len(m.alpnProtocols) > 0 {\n+\t\tz[0] = byte(extensionALPN >> 8)\n+\t\tz[1] = byte(extensionALPN & 0xff)\n+\t\tlengths := z[2:]\n+\t\tz = z[6:]\n+\n+\t\tstringsLength := 0\n+\t\tfor _, s := range m.alpnProtocols {\n+\t\t\tl := len(s)\n+\t\t\tz[0] = byte(l)\n+\t\t\tcopy(z[1:], s)\n+\t\t\tz = z[1+l:]\n+\t\t\tstringsLength += 1 + l\n+\t\t}\n+\n+\t\tlengths[2] = byte(stringsLength >> 8)\n+\t\tlengths[3] = byte(stringsLength)\n+\t\tstringsLength += 2\n+\t\tlengths[0] = byte(stringsLength >> 8)\n+\t\tlengths[1] = byte(stringsLength)\n+\t}\n \n \tm.raw = x\n \n@@ -291,6 +325,7 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \tm.ticketSupported = false\n \tm.sessionTicket = nil\n \tm.signatureAndHashes = nil\n+\tm.alpnProtocols = nil\n \n \tif len(data) == 0 {\n \t\t// ClientHello is optionally followed by extension data\n@@ -400,6 +435,24 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \t\t\t\treturn false\n \t\t\t}\n \t\t\tm.secureRenegotiation = true\n+\t\tcase extensionALPN:\n+\t\t\tif length < 2 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tl := int(data[0])<<8 | int(data[1])\n+\t\t\tif l != length-2 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\td := data[2:length]\n+\t\t\tfor len(d) != 0 {\n+\t\t\t\tstringLen := int(d[0])\n+\t\t\t\td = d[1:]\n+\t\t\t\tif stringLen == 0 || stringLen > len(d) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\tm.alpnProtocols = append(m.alpnProtocols, string(d[:stringLen]))\n+\t\t\t\td = d[stringLen:]\n+\t\t\t}\n \t\t}\n \t\tdata = data[length:]\n \t}\n@@ -419,6 +472,7 @@ type serverHelloMsg struct {\n \tocspStapling        bool\n \tticketSupported     bool\n \tsecureRenegotiation bool\n+\talpnProtocol        string\n }\n \n func (m *serverHelloMsg) equal(i interface{}) bool {\n@@ -437,7 +491,8 @@ func (m *serverHelloMsg) equal(i interface{}) bool {\n \t\teqStrings(m.nextProtos, m1.nextProtos) &&\n \t\tm.ocspStapling == m1.ocspStapling &&\n \t\tm.ticketSupported == m1.ticketSupported &&\n-\t\tm.secureRenegotiation == m1.secureRenegotiation\n+\t\tm.secureRenegotiation == m1.secureRenegotiation &&\n+\t\tm.alpnProtocol == m1.alpnProtocol\n }\n \n func (m *serverHelloMsg) marshal() []byte {\n@@ -468,6 +523,14 @@ func (m *serverHelloMsg) marshal() []byte {\n \t\textensionsLength += 1\n \t\tnumExtensions++\n \t}\n+\tif alpnLen := len(m.alpnProtocol); alpnLen > 0 {\n+\t\tif alpnLen >= 256 {\n+\t\t\tpanic(\"invalid ALPN protocol\")\n+\t\t}\n+\t\textensionsLength += 2 + 1 + alpnLen\n+\t\tnumExtensions++\n+\t}\n+\n \tif numExtensions > 0 {\n \t\textensionsLength += 4 * numExtensions\n \t\tlength += 2 + extensionsLength\n@@ -528,6 +591,20 @@ func (m *serverHelloMsg) marshal() []byte {\n \t\tz[3] = 1\n \t\tz = z[5:]\n \t}\n+\tif alpnLen := len(m.alpnProtocol); alpnLen > 0 {\n+\t\tz[0] = byte(extensionALPN >> 8)\n+\t\tz[1] = byte(extensionALPN & 0xff)\n+\t\tl := 2 + 1 + alpnLen\n+\t\tz[2] = byte(l >> 8)\n+\t\tz[3] = byte(l)\n+\t\tl -= 2\n+\t\tz[4] = byte(l >> 8)\n+\t\tz[5] = byte(l)\n+\t\tl -= 1\n+\t\tz[6] = byte(l)\n+\t\tcopy(z[7:], []byte(m.alpnProtocol))\n+\t\tz = z[7+alpnLen:]\n+\t}\n \n \tm.raw = x\n \n@@ -558,6 +635,7 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \tm.nextProtos = nil\n \tm.ocspStapling = false\n \tm.ticketSupported = false\n+\tm.alpnProtocol = \"\"\n \n \tif len(data) == 0 {\n \t\t// ServerHello is optionally followed by extension data\n@@ -612,6 +690,22 @@ func (m *serverHelloMsg) unmarshal(data []byte) bool {\n \t\t\t\treturn false\n \t\t\t}\n \t\t\tm.secureRenegotiation = true\n+\t\tcase extensionALPN:\n+\t\t\td := data[:length]\n+\t\t\tif len(d) < 3 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tl := int(d[0])<<8 | int(d[1])\n+\t\t\tif l != len(d)-2 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\td = d[2:]\n+\t\t\tl = int(d[0])\n+\t\t\tif l != len(d)-1 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\td = d[1:]\n+\t\t\tm.alpnProtocol = string(d)\n \t\t}\n \t\tdata = data[length:]\n \t}"}, {"sha": "a96e95c3f03262d0549150a44467f1b7efcbdc24", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -138,6 +138,10 @@ func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tif rand.Intn(10) > 5 {\n \t\tm.signatureAndHashes = supportedSKXSignatureAlgorithms\n \t}\n+\tm.alpnProtocols = make([]string, rand.Intn(5))\n+\tfor i := range m.alpnProtocols {\n+\t\tm.alpnProtocols[i] = randomString(rand.Intn(20)+1, rand)\n+\t}\n \n \treturn reflect.ValueOf(m)\n }\n@@ -166,6 +170,7 @@ func (*serverHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \tif rand.Intn(10) > 5 {\n \t\tm.ticketSupported = true\n \t}\n+\tm.alpnProtocol = randomString(rand.Intn(32)+1, rand)\n \n \treturn reflect.ValueOf(m)\n }"}, {"sha": "0d907656c6c20cc0698baaaaa2db1ad2cede83b6", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -57,10 +57,10 @@ func (c *Conn) serverHandshake() error {\n \t\tif err := hs.establishKeys(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.sendFinished(); err != nil {\n+\t\tif err := hs.sendFinished(c.firstFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.readFinished(); err != nil {\n+\t\tif err := hs.readFinished(nil); err != nil {\n \t\t\treturn err\n \t\t}\n \t\tc.didResume = true\n@@ -73,13 +73,13 @@ func (c *Conn) serverHandshake() error {\n \t\tif err := hs.establishKeys(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.readFinished(); err != nil {\n+\t\tif err := hs.readFinished(c.firstFinished[:]); err != nil {\n \t\t\treturn err\n \t\t}\n \t\tif err := hs.sendSessionTicket(); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif err := hs.sendFinished(); err != nil {\n+\t\tif err := hs.sendFinished(nil); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -163,13 +163,21 @@ Curves:\n \tif len(hs.clientHello.serverName) > 0 {\n \t\tc.serverName = hs.clientHello.serverName\n \t}\n-\t// Although sending an empty NPN extension is reasonable, Firefox has\n-\t// had a bug around this. Best to send nothing at all if\n-\t// config.NextProtos is empty. See\n-\t// https://code.google.com/p/go/issues/detail?id=5445.\n-\tif hs.clientHello.nextProtoNeg && len(config.NextProtos) > 0 {\n-\t\ths.hello.nextProtoNeg = true\n-\t\ths.hello.nextProtos = config.NextProtos\n+\n+\tif len(hs.clientHello.alpnProtocols) > 0 {\n+\t\tif selectedProto, fallback := mutualProtocol(hs.clientHello.alpnProtocols, c.config.NextProtos); !fallback {\n+\t\t\ths.hello.alpnProtocol = selectedProto\n+\t\t\tc.clientProtocol = selectedProto\n+\t\t}\n+\t} else {\n+\t\t// Although sending an empty NPN extension is reasonable, Firefox has\n+\t\t// had a bug around this. Best to send nothing at all if\n+\t\t// config.NextProtos is empty. See\n+\t\t// https://code.google.com/p/go/issues/detail?id=5445.\n+\t\tif hs.clientHello.nextProtoNeg && len(config.NextProtos) > 0 {\n+\t\t\ths.hello.nextProtoNeg = true\n+\t\t\ths.hello.nextProtos = config.NextProtos\n+\t\t}\n \t}\n \n \tif len(config.Certificates) == 0 {\n@@ -178,7 +186,16 @@ Curves:\n \t}\n \ths.cert = &config.Certificates[0]\n \tif len(hs.clientHello.serverName) > 0 {\n-\t\ths.cert = config.getCertificateForName(hs.clientHello.serverName)\n+\t\tchi := &ClientHelloInfo{\n+\t\t\tCipherSuites:    hs.clientHello.cipherSuites,\n+\t\t\tServerName:      hs.clientHello.serverName,\n+\t\t\tSupportedCurves: hs.clientHello.supportedCurves,\n+\t\t\tSupportedPoints: hs.clientHello.supportedPoints,\n+\t\t}\n+\t\tif hs.cert, err = config.getCertificate(chi); err != nil {\n+\t\t\tc.sendAlert(alertInternalError)\n+\t\t\treturn false, err\n+\t\t}\n \t}\n \n \t_, hs.ecdsaOk = hs.cert.PrivateKey.(*ecdsa.PrivateKey)\n@@ -207,6 +224,18 @@ Curves:\n \t\treturn false, errors.New(\"tls: no cipher suite supported by both client and server\")\n \t}\n \n+\t// See https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00.\n+\tfor _, id := range hs.clientHello.cipherSuites {\n+\t\tif id == TLS_FALLBACK_SCSV {\n+\t\t\t// The client is doing a fallback connection.\n+\t\t\tif hs.clientHello.vers < c.config.MaxVersion {\n+\t\t\t\tc.sendAlert(alertInappropriateFallback)\n+\t\t\t\treturn false, errors.New(\"tls: client using inppropriate protocol fallback\")\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n \treturn false, nil\n }\n \n@@ -470,7 +499,7 @@ func (hs *serverHandshakeState) establishKeys() error {\n \treturn nil\n }\n \n-func (hs *serverHandshakeState) readFinished() error {\n+func (hs *serverHandshakeState) readFinished(out []byte) error {\n \tc := hs.c\n \n \tc.readRecord(recordTypeChangeCipherSpec)\n@@ -510,6 +539,7 @@ func (hs *serverHandshakeState) readFinished() error {\n \t}\n \n \ths.finishedHash.Write(clientFinished.marshal())\n+\tcopy(out, verify)\n \treturn nil\n }\n \n@@ -539,7 +569,7 @@ func (hs *serverHandshakeState) sendSessionTicket() error {\n \treturn nil\n }\n \n-func (hs *serverHandshakeState) sendFinished() error {\n+func (hs *serverHandshakeState) sendFinished(out []byte) error {\n \tc := hs.c\n \n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n@@ -550,6 +580,7 @@ func (hs *serverHandshakeState) sendFinished() error {\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n \n \tc.cipherSuite = hs.suite.id\n+\tcopy(out, finished.verifyData)\n \n \treturn nil\n }"}, {"sha": "0338af457ee5f8bedccc9b24c646499fe32857be", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 155, "deletions": 13, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"crypto/ecdsa\"\n \t\"crypto/elliptic\"\n \t\"crypto/rsa\"\n-\t\"crypto/x509\"\n \t\"encoding/hex\"\n \t\"encoding/pem\"\n \t\"errors\"\n@@ -258,6 +257,16 @@ type serverTest struct {\n \texpectedPeerCerts []string\n \t// config, if not nil, contains a custom Config to use for this test.\n \tconfig *Config\n+\t// expectAlert, if true, indicates that a fatal alert should be returned\n+\t// when handshaking with the server.\n+\texpectAlert bool\n+\t// expectHandshakeErrorIncluding, when not empty, contains a string\n+\t// that must be a substring of the error resulting from the handshake.\n+\texpectHandshakeErrorIncluding string\n+\t// validate, if not nil, is a function that will be called with the\n+\t// ConnectionState of the resulting connection. It returns false if the\n+\t// ConnectionState is unacceptable.\n+\tvalidate func(ConnectionState) error\n }\n \n var defaultClientCommand = []string{\"openssl\", \"s_client\", \"-no_ticket\"}\n@@ -354,20 +363,30 @@ func (test *serverTest) run(t *testing.T, write bool) {\n \t\tconfig = testConfig\n \t}\n \tserver := Server(serverConn, config)\n-\tpeerCertsChan := make(chan []*x509.Certificate, 1)\n+\tconnStateChan := make(chan ConnectionState, 1)\n \tgo func() {\n-\t\tif _, err := server.Write([]byte(\"hello, world\\n\")); err != nil {\n+\t\tvar err error\n+\t\tif _, err = server.Write([]byte(\"hello, world\\n\")); err != nil {\n \t\t\tt.Logf(\"Error from Server.Write: %s\", err)\n \t\t}\n+\t\tif len(test.expectHandshakeErrorIncluding) > 0 {\n+\t\t\tif err == nil {\n+\t\t\t\tt.Errorf(\"Error expected, but no error returned\")\n+\t\t\t} else if s := err.Error(); !strings.Contains(s, test.expectHandshakeErrorIncluding) {\n+\t\t\t\tt.Errorf(\"Error expected containing '%s' but got '%s'\", test.expectHandshakeErrorIncluding, s)\n+\t\t\t}\n+\t\t}\n \t\tserver.Close()\n \t\tserverConn.Close()\n-\t\tpeerCertsChan <- server.ConnectionState().PeerCertificates\n+\t\tconnStateChan <- server.ConnectionState()\n \t}()\n \n \tif !write {\n \t\tflows, err := test.loadData()\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"%s: failed to load data from %s\", test.name, test.dataPath())\n+\t\t\tif !test.expectAlert {\n+\t\t\t\tt.Fatalf(\"%s: failed to load data from %s\", test.name, test.dataPath())\n+\t\t\t}\n \t\t}\n \t\tfor i, b := range flows {\n \t\t\tif i%2 == 0 {\n@@ -376,17 +395,24 @@ func (test *serverTest) run(t *testing.T, write bool) {\n \t\t\t}\n \t\t\tbb := make([]byte, len(b))\n \t\t\tn, err := io.ReadFull(clientConn, bb)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"%s #%d: %s\\nRead %d, wanted %d, got %x, wanted %x\\n\", test.name, i+1, err, n, len(bb), bb[:n], b)\n-\t\t\t}\n-\t\t\tif !bytes.Equal(b, bb) {\n-\t\t\t\tt.Fatalf(\"%s #%d: mismatch on read: got:%x want:%x\", test.name, i+1, bb, b)\n+\t\t\tif test.expectAlert {\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tt.Fatal(\"Expected read failure but read succeeded\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"%s #%d: %s\\nRead %d, wanted %d, got %x, wanted %x\\n\", test.name, i+1, err, n, len(bb), bb[:n], b)\n+\t\t\t\t}\n+\t\t\t\tif !bytes.Equal(b, bb) {\n+\t\t\t\t\tt.Fatalf(\"%s #%d: mismatch on read: got:%x want:%x\", test.name, i+1, bb, b)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tclientConn.Close()\n \t}\n \n-\tpeerCerts := <-peerCertsChan\n+\tconnState := <-connStateChan\n+\tpeerCerts := connState.PeerCertificates\n \tif len(peerCerts) == len(test.expectedPeerCerts) {\n \t\tfor i, peerCert := range peerCerts {\n \t\t\tblock, _ := pem.Decode([]byte(test.expectedPeerCerts[i]))\n@@ -398,6 +424,12 @@ func (test *serverTest) run(t *testing.T, write bool) {\n \t\tt.Fatalf(\"%s: mismatch on peer list length: %d (wanted) != %d (got)\", test.name, len(test.expectedPeerCerts), len(peerCerts))\n \t}\n \n+\tif test.validate != nil {\n+\t\tif err := test.validate(connState); err != nil {\n+\t\t\tt.Fatalf(\"validate callback returned error: %s\", err)\n+\t\t}\n+\t}\n+\n \tif write {\n \t\tpath := test.dataPath()\n \t\tout, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)\n@@ -408,7 +440,9 @@ func (test *serverTest) run(t *testing.T, write bool) {\n \t\trecordingConn.Close()\n \t\tif len(recordingConn.flows) < 3 {\n \t\t\tchildProcess.Stdout.(*bytes.Buffer).WriteTo(os.Stdout)\n-\t\t\tt.Fatalf(\"Handshake failed\")\n+\t\t\tif len(test.expectHandshakeErrorIncluding) == 0 {\n+\t\t\t\tt.Fatalf(\"Handshake failed\")\n+\t\t\t}\n \t\t}\n \t\trecordingConn.WriteTo(out)\n \t\tfmt.Printf(\"Wrote %s\\n\", path)\n@@ -498,6 +532,49 @@ func TestHandshakeServerECDHEECDSAAES(t *testing.T) {\n \trunServerTestTLS12(t, test)\n }\n \n+func TestHandshakeServerALPN(t *testing.T) {\n+\tconfig := *testConfig\n+\tconfig.NextProtos = []string{\"proto1\", \"proto2\"}\n+\n+\ttest := &serverTest{\n+\t\tname: \"ALPN\",\n+\t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n+\t\t// version that supports the -alpn flag.\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-alpn\", \"proto2,proto1\"},\n+\t\tconfig:  &config,\n+\t\tvalidate: func(state ConnectionState) error {\n+\t\t\t// The server's preferences should override the client.\n+\t\t\tif state.NegotiatedProtocol != \"proto1\" {\n+\t\t\t\treturn fmt.Errorf(\"Got protocol %q, wanted proto1\", state.NegotiatedProtocol)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\trunServerTestTLS12(t, test)\n+}\n+\n+func TestHandshakeServerALPNNoMatch(t *testing.T) {\n+\tconfig := *testConfig\n+\tconfig.NextProtos = []string{\"proto3\"}\n+\n+\ttest := &serverTest{\n+\t\tname: \"ALPN-NoMatch\",\n+\t\t// Note that this needs OpenSSL 1.0.2 because that is the first\n+\t\t// version that supports the -alpn flag.\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-alpn\", \"proto2,proto1\"},\n+\t\tconfig:  &config,\n+\t\tvalidate: func(state ConnectionState) error {\n+\t\t\t// Rather than reject the connection, Go doesn't select\n+\t\t\t// a protocol when there is no overlap.\n+\t\t\tif state.NegotiatedProtocol != \"\" {\n+\t\t\t\treturn fmt.Errorf(\"Got protocol %q, wanted ''\", state.NegotiatedProtocol)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t},\n+\t}\n+\trunServerTestTLS12(t, test)\n+}\n+\n // TestHandshakeServerSNI involves a client sending an SNI extension of\n // \"snitest.com\", which happens to match the CN of testSNICertificate. The test\n // verifies that the server correctly selects that certificate.\n@@ -509,6 +586,61 @@ func TestHandshakeServerSNI(t *testing.T) {\n \trunServerTestTLS12(t, test)\n }\n \n+// TestHandshakeServerSNICertForName is similar to TestHandshakeServerSNI, but\n+// tests the dynamic GetCertificate method\n+func TestHandshakeServerSNIGetCertificate(t *testing.T) {\n+\tconfig := *testConfig\n+\n+\t// Replace the NameToCertificate map with a GetCertificate function\n+\tnameToCert := config.NameToCertificate\n+\tconfig.NameToCertificate = nil\n+\tconfig.GetCertificate = func(clientHello *ClientHelloInfo) (*Certificate, error) {\n+\t\tcert, _ := nameToCert[clientHello.ServerName]\n+\t\treturn cert, nil\n+\t}\n+\ttest := &serverTest{\n+\t\tname:    \"SNI\",\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"AES128-SHA\", \"-servername\", \"snitest.com\"},\n+\t\tconfig:  &config,\n+\t}\n+\trunServerTestTLS12(t, test)\n+}\n+\n+// TestHandshakeServerSNICertForNameNotFound is similar to\n+// TestHandshakeServerSNICertForName, but tests to make sure that when the\n+// GetCertificate method doesn't return a cert, we fall back to what's in\n+// the NameToCertificate map.\n+func TestHandshakeServerSNIGetCertificateNotFound(t *testing.T) {\n+\tconfig := *testConfig\n+\n+\tconfig.GetCertificate = func(clientHello *ClientHelloInfo) (*Certificate, error) {\n+\t\treturn nil, nil\n+\t}\n+\ttest := &serverTest{\n+\t\tname:    \"SNI\",\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"AES128-SHA\", \"-servername\", \"snitest.com\"},\n+\t\tconfig:  &config,\n+\t}\n+\trunServerTestTLS12(t, test)\n+}\n+\n+// TestHandshakeServerSNICertForNameError tests to make sure that errors in\n+// GetCertificate result in a tls alert.\n+func TestHandshakeServerSNIGetCertificateError(t *testing.T) {\n+\tconfig := *testConfig\n+\n+\tconfig.GetCertificate = func(clientHello *ClientHelloInfo) (*Certificate, error) {\n+\t\treturn nil, fmt.Errorf(\"Test error in GetCertificate\")\n+\t}\n+\ttest := &serverTest{\n+\t\tname:        \"SNI\",\n+\t\tcommand:     []string{\"openssl\", \"s_client\", \"-no_ticket\", \"-cipher\", \"AES128-SHA\", \"-servername\", \"snitest.com\"},\n+\t\tconfig:      &config,\n+\t\texpectAlert: true,\n+\t}\n+\trunServerTestTLS12(t, test)\n+}\n+\n // TestCipherSuiteCertPreferance ensures that we select an RSA ciphersuite with\n // an RSA certificate and an ECDSA ciphersuite with an ECDSA certificate.\n func TestCipherSuiteCertPreferenceECDSA(t *testing.T) {\n@@ -525,7 +657,7 @@ func TestCipherSuiteCertPreferenceECDSA(t *testing.T) {\n \tconfig = *testConfig\n \tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA}\n \tconfig.Certificates = []Certificate{\n-\t\tCertificate{\n+\t\t{\n \t\t\tCertificate: [][]byte{testECDSACertificate},\n \t\t\tPrivateKey:  testECDSAPrivateKey,\n \t\t},\n@@ -583,6 +715,16 @@ func TestResumptionDisabled(t *testing.T) {\n \t// file for ResumeDisabled does not include a resumption handshake.\n }\n \n+func TestFallbackSCSV(t *testing.T) {\n+\ttest := &serverTest{\n+\t\tname: \"FallbackSCSV\",\n+\t\t// OpenSSL 1.0.1j is needed for the -fallback_scsv option.\n+\t\tcommand: []string{\"openssl\", \"s_client\", \"-fallback_scsv\"},\n+\t\texpectHandshakeErrorIncluding: \"inppropriate protocol fallback\",\n+\t}\n+\trunServerTestTLS11(t, test)\n+}\n+\n // cert.pem and key.pem were generated with generate_cert.go\n // Thus, they have no ExtKeyUsage fields and trigger an error\n // when verification is turned on."}, {"sha": "0974fc6e0f4add7a51627ea2bb1675d569a582c4", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -292,6 +292,9 @@ func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Cert\n \tif x == nil {\n \t\treturn nil, errClientKeyExchange\n \t}\n+\tif !ka.curve.IsOnCurve(x, y) {\n+\t\treturn nil, errClientKeyExchange\n+\t}\n \tx, _ = ka.curve.ScalarMult(x, y, ka.privateKey)\n \tpreMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)>>3)\n \txBytes := x.Bytes()\n@@ -322,6 +325,9 @@ func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHell\n \tif ka.x == nil {\n \t\treturn errServerKeyExchange\n \t}\n+\tif !ka.curve.IsOnCurve(ka.x, ka.y) {\n+\t\treturn errServerKeyExchange\n+\t}\n \tserverECDHParams := skx.key[:4+publicLen]\n \n \tsig := skx.key[4+publicLen:]"}, {"sha": "f09a4f106c147bb44b275fac669f57bfefe8574a", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ALPN", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,97 @@\n+>>> Flow 1 (client to server)\n+00000000  16 03 01 00 8d 01 00 00  89 03 03 00 00 00 00 00  |................|\n+00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 1a c0 2f  |.............../|\n+00000030  c0 2b c0 11 c0 07 c0 13  c0 09 c0 14 c0 0a 00 05  |.+..............|\n+00000040  00 2f 00 35 c0 12 00 0a  01 00 00 46 33 74 00 00  |./.5.......F3t..|\n+00000050  00 05 00 05 01 00 00 00  00 00 0a 00 08 00 06 00  |................|\n+00000060  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0a 00  |................|\n+00000070  08 04 01 04 03 02 01 02  03 ff 01 00 01 00 00 10  |................|\n+00000080  00 10 00 0e 06 70 72 6f  74 6f 32 06 70 72 6f 74  |.....proto2.prot|\n+00000090  6f 31                                             |o1|\n+>>> Flow 2 (server to client)\n+00000000  16 03 03 00 66 02 00 00  62 03 03 77 a9 7d 9c 4b  |....f...b..w.}.K|\n+00000010  69 65 aa dc 95 cb 78 08  3d d2 1a 0a 45 69 23 73  |ie....x.=...Ei#s|\n+00000020  4f 41 4f 24 12 2e 57 47  b7 53 64 20 82 9a f8 e7  |OAO$..WG.Sd ....|\n+00000030  79 f8 13 2c 9d cd b5 cb  cb 9a 95 56 0e e9 cb a8  |y..,.......V....|\n+00000040  e4 a2 8a d6 bc dc fa 25  b3 57 cc cf c0 2f 00 00  |.......%.W.../..|\n+00000050  1a ff 01 00 01 00 00 0b  00 04 03 00 01 02 00 10  |................|\n+00000060  00 09 00 07 06 70 72 6f  74 6f 31 16 03 03 02 be  |.....proto1.....|\n+00000070  0b 00 02 ba 00 02 b7 00  02 b4 30 82 02 b0 30 82  |..........0...0.|\n+00000080  02 19 a0 03 02 01 02 02  09 00 85 b0 bb a4 8a 7f  |................|\n+00000090  b8 ca 30 0d 06 09 2a 86  48 86 f7 0d 01 01 05 05  |..0...*.H.......|\n+000000a0  00 30 45 31 0b 30 09 06  03 55 04 06 13 02 41 55  |.0E1.0...U....AU|\n+000000b0  31 13 30 11 06 03 55 04  08 13 0a 53 6f 6d 65 2d  |1.0...U....Some-|\n+000000c0  53 74 61 74 65 31 21 30  1f 06 03 55 04 0a 13 18  |State1!0...U....|\n+000000d0  49 6e 74 65 72 6e 65 74  20 57 69 64 67 69 74 73  |Internet Widgits|\n+000000e0  20 50 74 79 20 4c 74 64  30 1e 17 0d 31 30 30 34  | Pty Ltd0...1004|\n+000000f0  32 34 30 39 30 39 33 38  5a 17 0d 31 31 30 34 32  |24090938Z..11042|\n+00000100  34 30 39 30 39 33 38 5a  30 45 31 0b 30 09 06 03  |4090938Z0E1.0...|\n+00000110  55 04 06 13 02 41 55 31  13 30 11 06 03 55 04 08  |U....AU1.0...U..|\n+00000120  13 0a 53 6f 6d 65 2d 53  74 61 74 65 31 21 30 1f  |..Some-State1!0.|\n+00000130  06 03 55 04 0a 13 18 49  6e 74 65 72 6e 65 74 20  |..U....Internet |\n+00000140  57 69 64 67 69 74 73 20  50 74 79 20 4c 74 64 30  |Widgits Pty Ltd0|\n+00000150  81 9f 30 0d 06 09 2a 86  48 86 f7 0d 01 01 01 05  |..0...*.H.......|\n+00000160  00 03 81 8d 00 30 81 89  02 81 81 00 bb 79 d6 f5  |.....0.......y..|\n+00000170  17 b5 e5 bf 46 10 d0 dc  69 be e6 2b 07 43 5a d0  |....F...i..+.CZ.|\n+00000180  03 2d 8a 7a 43 85 b7 14  52 e7 a5 65 4c 2c 78 b8  |.-.zC...R..eL,x.|\n+00000190  23 8c b5 b4 82 e5 de 1f  95 3b 7e 62 a5 2c a5 33  |#........;~b.,.3|\n+000001a0  d6 fe 12 5c 7a 56 fc f5  06 bf fa 58 7b 26 3f b5  |...\\zV.....X{&?.|\n+000001b0  cd 04 d3 d0 c9 21 96 4a  c7 f4 54 9f 5a bf ef 42  |.....!.J..T.Z..B|\n+000001c0  71 00 fe 18 99 07 7f 7e  88 7d 7d f1 04 39 c4 a2  |q......~.}}..9..|\n+000001d0  2e db 51 c9 7c e3 c0 4c  3b 32 66 01 cf af b1 1d  |..Q.|..L;2f.....|\n+000001e0  b8 71 9a 1d db db 89 6b  ae da 2d 79 02 03 01 00  |.q.....k..-y....|\n+000001f0  01 a3 81 a7 30 81 a4 30  1d 06 03 55 1d 0e 04 16  |....0..0...U....|\n+00000200  04 14 b1 ad e2 85 5a cf  cb 28 db 69 ce 23 69 de  |......Z..(.i.#i.|\n+00000210  d3 26 8e 18 88 39 30 75  06 03 55 1d 23 04 6e 30  |.&...90u..U.#.n0|\n+00000220  6c 80 14 b1 ad e2 85 5a  cf cb 28 db 69 ce 23 69  |l......Z..(.i.#i|\n+00000230  de d3 26 8e 18 88 39 a1  49 a4 47 30 45 31 0b 30  |..&...9.I.G0E1.0|\n+00000240  09 06 03 55 04 06 13 02  41 55 31 13 30 11 06 03  |...U....AU1.0...|\n+00000250  55 04 08 13 0a 53 6f 6d  65 2d 53 74 61 74 65 31  |U....Some-State1|\n+00000260  21 30 1f 06 03 55 04 0a  13 18 49 6e 74 65 72 6e  |!0...U....Intern|\n+00000270  65 74 20 57 69 64 67 69  74 73 20 50 74 79 20 4c  |et Widgits Pty L|\n+00000280  74 64 82 09 00 85 b0 bb  a4 8a 7f b8 ca 30 0c 06  |td...........0..|\n+00000290  03 55 1d 13 04 05 30 03  01 01 ff 30 0d 06 09 2a  |.U....0....0...*|\n+000002a0  86 48 86 f7 0d 01 01 05  05 00 03 81 81 00 08 6c  |.H.............l|\n+000002b0  45 24 c7 6b b1 59 ab 0c  52 cc f2 b0 14 d7 87 9d  |E$.k.Y..R.......|\n+000002c0  7a 64 75 b5 5a 95 66 e4  c5 2b 8e ae 12 66 1f eb  |zdu.Z.f..+...f..|\n+000002d0  4f 38 b3 6e 60 d3 92 fd  f7 41 08 b5 25 13 b1 18  |O8.n`....A..%...|\n+000002e0  7a 24 fb 30 1d ba ed 98  b9 17 ec e7 d7 31 59 db  |z$.0.........1Y.|\n+000002f0  95 d3 1d 78 ea 50 56 5c  d5 82 5a 2d 5a 5f 33 c4  |...x.PV\\..Z-Z_3.|\n+00000300  b6 d8 c9 75 90 96 8c 0f  52 98 b5 cd 98 1f 89 20  |...u....R...... |\n+00000310  5f f2 a0 1c a3 1b 96 94  dd a9 fd 57 e9 70 e8 26  |_..........W.p.&|\n+00000320  6d 71 99 9b 26 6e 38 50  29 6c 90 a7 bd d9 16 03  |mq..&n8P)l......|\n+00000330  03 00 cd 0c 00 00 c9 03  00 17 41 04 1b 42 c3 ae  |..........A..B..|\n+00000340  44 19 d3 84 7c 6c 98 cb  b9 22 a2 67 63 95 aa cc  |D...|l...\".gc...|\n+00000350  bd e4 1e f8 08 e6 60 f3  bc 83 9f 81 da 9c 1c 8c  |......`.........|\n+00000360  ff 6f f4 3e 1e e5 3b f6  49 61 f9 70 43 7f c1 69  |.o.>..;.Ia.pC..i|\n+00000370  de 73 98 4b bd 5c c3 78  24 18 a8 ec 04 01 00 80  |.s.K.\\.x$.......|\n+00000380  70 d2 5b e1 39 cf 4d 54  de d2 74 4e 5e a8 b3 ca  |p.[.9.MT..tN^...|\n+00000390  e1 f2 4e 76 3c 77 8b ef  f7 d1 df b9 ad c1 70 39  |..Nv<w........p9|\n+000003a0  c7 a3 1e 0f 7b 6c 78 2e  c1 86 d2 67 36 d8 25 e0  |....{lx....g6.%.|\n+000003b0  e8 e5 cc 35 a2 96 a1 b4  b7 06 68 1e aa c7 06 97  |...5......h.....|\n+000003c0  b7 c2 83 ce c0 17 dd 4f  9e 6f 7a bd cd c7 6e 7f  |.......O.oz...n.|\n+000003d0  cb 80 d1 7d 06 2d f9 f1  fb 5f cc bb d8 62 5b f0  |...}.-..._...b[.|\n+000003e0  27 12 57 d5 9b 55 aa 55  4b 9a 5a f6 a5 aa c1 82  |'.W..U.UK.Z.....|\n+000003f0  39 11 6b dc 83 7f a8 47  28 5a 0f 3d 3f 0f c2 22  |9.k....G(Z.=?..\"|\n+00000400  16 03 03 00 04 0e 00 00  00                       |.........|\n+>>> Flow 3 (client to server)\n+00000000  16 03 03 00 46 10 00 00  42 41 04 1e 18 37 ef 0d  |....F...BA...7..|\n+00000010  19 51 88 35 75 71 b5 e5  54 5b 12 2e 8f 09 67 fd  |.Q.5uq..T[....g.|\n+00000020  a7 24 20 3e b2 56 1c ce  97 28 5e f8 2b 2d 4f 9e  |.$ >.V...(^.+-O.|\n+00000030  f1 07 9f 6c 4b 5b 83 56  e2 32 42 e9 58 b6 d7 49  |...lK[.V.2B.X..I|\n+00000040  a6 b5 68 1a 41 03 56 6b  dc 5a 89 14 03 03 00 01  |..h.A.Vk.Z......|\n+00000050  01 16 03 03 00 28 00 00  00 00 00 00 00 00 35 9d  |.....(........5.|\n+00000060  92 e8 bf df 7f a7 77 1b  cf 03 2a bf e2 6c 62 2b  |......w...*..lb+|\n+00000070  26 f0 fb 93 d3 df fd 55  84 d3 ed 88 31 cb        |&......U....1.|\n+>>> Flow 4 (server to client)\n+00000000  14 03 03 00 01 01 16 03  03 00 28 c8 c0 78 09 73  |..........(..x.s|\n+00000010  58 41 73 66 88 cf db f3  fe c6 57 ab 45 be 2e d8  |XAsf......W.E...|\n+00000020  4e e5 ff 42 57 13 74 d2  cc c2 62 07 39 8b 06 46  |N..BW.t...b.9..F|\n+00000030  1d 8f 88                                          |...|\n+>>> Flow 5 (client to server)\n+00000000  17 03 03 00 1e 00 00 00  00 00 00 00 01 10 c3 5f  |..............._|\n+00000010  3f c8 92 6c 7a a7 23 05  f3 d8 31 20 01 52 f1 99  |?..lz.#...1 .R..|\n+00000020  33 c1 2a 15 03 03 00 1a  00 00 00 00 00 00 00 02  |3.*.............|\n+00000030  cc ef eb 78 e4 e1 9d 90  05 6d 95 ac f2 49 ba 8e  |...x.....m...I..|\n+00000040  6b 8d                                             |k.|"}, {"sha": "f24a70cc8281d6046fdd03dae6e1121f744501d2", "filename": "libgo/go/crypto/tls/testdata/Client-TLSv12-ALPN-NoMatch", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FClient-TLSv12-ALPN-NoMatch?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,95 @@\n+>>> Flow 1 (client to server)\n+00000000  16 03 01 00 86 01 00 00  82 03 03 00 00 00 00 00  |................|\n+00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 1a c0 2f  |.............../|\n+00000030  c0 2b c0 11 c0 07 c0 13  c0 09 c0 14 c0 0a 00 05  |.+..............|\n+00000040  00 2f 00 35 c0 12 00 0a  01 00 00 3f 33 74 00 00  |./.5.......?3t..|\n+00000050  00 05 00 05 01 00 00 00  00 00 0a 00 08 00 06 00  |................|\n+00000060  17 00 18 00 19 00 0b 00  02 01 00 00 0d 00 0a 00  |................|\n+00000070  08 04 01 04 03 02 01 02  03 ff 01 00 01 00 00 10  |................|\n+00000080  00 09 00 07 06 70 72 6f  74 6f 33                 |.....proto3|\n+>>> Flow 2 (server to client)\n+00000000  16 03 03 00 59 02 00 00  55 03 03 69 84 d1 d3 44  |....Y...U..i...D|\n+00000010  e9 66 08 48 bc 70 d8 ae  40 0b 17 69 e7 27 f6 7a  |.f.H.p..@..i.'.z|\n+00000020  d5 ee 86 74 54 9e a8 bb  79 76 89 20 57 53 1b 02  |...tT...yv. WS..|\n+00000030  5b 70 81 a6 f1 53 bc 9d  b7 42 5e ac 92 93 b5 20  |[p...S...B^.... |\n+00000040  8a bb 36 cc 8f cb 7e a0  61 a2 e8 ef c0 2f 00 00  |..6...~.a..../..|\n+00000050  0d ff 01 00 01 00 00 0b  00 04 03 00 01 02 16 03  |................|\n+00000060  03 02 be 0b 00 02 ba 00  02 b7 00 02 b4 30 82 02  |.............0..|\n+00000070  b0 30 82 02 19 a0 03 02  01 02 02 09 00 85 b0 bb  |.0..............|\n+00000080  a4 8a 7f b8 ca 30 0d 06  09 2a 86 48 86 f7 0d 01  |.....0...*.H....|\n+00000090  01 05 05 00 30 45 31 0b  30 09 06 03 55 04 06 13  |....0E1.0...U...|\n+000000a0  02 41 55 31 13 30 11 06  03 55 04 08 13 0a 53 6f  |.AU1.0...U....So|\n+000000b0  6d 65 2d 53 74 61 74 65  31 21 30 1f 06 03 55 04  |me-State1!0...U.|\n+000000c0  0a 13 18 49 6e 74 65 72  6e 65 74 20 57 69 64 67  |...Internet Widg|\n+000000d0  69 74 73 20 50 74 79 20  4c 74 64 30 1e 17 0d 31  |its Pty Ltd0...1|\n+000000e0  30 30 34 32 34 30 39 30  39 33 38 5a 17 0d 31 31  |00424090938Z..11|\n+000000f0  30 34 32 34 30 39 30 39  33 38 5a 30 45 31 0b 30  |0424090938Z0E1.0|\n+00000100  09 06 03 55 04 06 13 02  41 55 31 13 30 11 06 03  |...U....AU1.0...|\n+00000110  55 04 08 13 0a 53 6f 6d  65 2d 53 74 61 74 65 31  |U....Some-State1|\n+00000120  21 30 1f 06 03 55 04 0a  13 18 49 6e 74 65 72 6e  |!0...U....Intern|\n+00000130  65 74 20 57 69 64 67 69  74 73 20 50 74 79 20 4c  |et Widgits Pty L|\n+00000140  74 64 30 81 9f 30 0d 06  09 2a 86 48 86 f7 0d 01  |td0..0...*.H....|\n+00000150  01 01 05 00 03 81 8d 00  30 81 89 02 81 81 00 bb  |........0.......|\n+00000160  79 d6 f5 17 b5 e5 bf 46  10 d0 dc 69 be e6 2b 07  |y......F...i..+.|\n+00000170  43 5a d0 03 2d 8a 7a 43  85 b7 14 52 e7 a5 65 4c  |CZ..-.zC...R..eL|\n+00000180  2c 78 b8 23 8c b5 b4 82  e5 de 1f 95 3b 7e 62 a5  |,x.#........;~b.|\n+00000190  2c a5 33 d6 fe 12 5c 7a  56 fc f5 06 bf fa 58 7b  |,.3...\\zV.....X{|\n+000001a0  26 3f b5 cd 04 d3 d0 c9  21 96 4a c7 f4 54 9f 5a  |&?......!.J..T.Z|\n+000001b0  bf ef 42 71 00 fe 18 99  07 7f 7e 88 7d 7d f1 04  |..Bq......~.}}..|\n+000001c0  39 c4 a2 2e db 51 c9 7c  e3 c0 4c 3b 32 66 01 cf  |9....Q.|..L;2f..|\n+000001d0  af b1 1d b8 71 9a 1d db  db 89 6b ae da 2d 79 02  |....q.....k..-y.|\n+000001e0  03 01 00 01 a3 81 a7 30  81 a4 30 1d 06 03 55 1d  |.......0..0...U.|\n+000001f0  0e 04 16 04 14 b1 ad e2  85 5a cf cb 28 db 69 ce  |.........Z..(.i.|\n+00000200  23 69 de d3 26 8e 18 88  39 30 75 06 03 55 1d 23  |#i..&...90u..U.#|\n+00000210  04 6e 30 6c 80 14 b1 ad  e2 85 5a cf cb 28 db 69  |.n0l......Z..(.i|\n+00000220  ce 23 69 de d3 26 8e 18  88 39 a1 49 a4 47 30 45  |.#i..&...9.I.G0E|\n+00000230  31 0b 30 09 06 03 55 04  06 13 02 41 55 31 13 30  |1.0...U....AU1.0|\n+00000240  11 06 03 55 04 08 13 0a  53 6f 6d 65 2d 53 74 61  |...U....Some-Sta|\n+00000250  74 65 31 21 30 1f 06 03  55 04 0a 13 18 49 6e 74  |te1!0...U....Int|\n+00000260  65 72 6e 65 74 20 57 69  64 67 69 74 73 20 50 74  |ernet Widgits Pt|\n+00000270  79 20 4c 74 64 82 09 00  85 b0 bb a4 8a 7f b8 ca  |y Ltd...........|\n+00000280  30 0c 06 03 55 1d 13 04  05 30 03 01 01 ff 30 0d  |0...U....0....0.|\n+00000290  06 09 2a 86 48 86 f7 0d  01 01 05 05 00 03 81 81  |..*.H...........|\n+000002a0  00 08 6c 45 24 c7 6b b1  59 ab 0c 52 cc f2 b0 14  |..lE$.k.Y..R....|\n+000002b0  d7 87 9d 7a 64 75 b5 5a  95 66 e4 c5 2b 8e ae 12  |...zdu.Z.f..+...|\n+000002c0  66 1f eb 4f 38 b3 6e 60  d3 92 fd f7 41 08 b5 25  |f..O8.n`....A..%|\n+000002d0  13 b1 18 7a 24 fb 30 1d  ba ed 98 b9 17 ec e7 d7  |...z$.0.........|\n+000002e0  31 59 db 95 d3 1d 78 ea  50 56 5c d5 82 5a 2d 5a  |1Y....x.PV\\..Z-Z|\n+000002f0  5f 33 c4 b6 d8 c9 75 90  96 8c 0f 52 98 b5 cd 98  |_3....u....R....|\n+00000300  1f 89 20 5f f2 a0 1c a3  1b 96 94 dd a9 fd 57 e9  |.. _..........W.|\n+00000310  70 e8 26 6d 71 99 9b 26  6e 38 50 29 6c 90 a7 bd  |p.&mq..&n8P)l...|\n+00000320  d9 16 03 03 00 cd 0c 00  00 c9 03 00 17 41 04 04  |.............A..|\n+00000330  be 27 08 6f 12 83 1b 04  76 fa 5f 16 d6 e3 64 76  |.'.o....v._...dv|\n+00000340  ad 0a 77 37 71 64 44 4c  3f 1a be dc 85 ce 46 c8  |..w7qdDL?.....F.|\n+00000350  29 a1 e2 24 78 66 1f 35  90 05 46 c0 91 d1 fd dd  |)..$xf.5..F.....|\n+00000360  b5 5b 87 d7 6d 9d 77 a7  f7 b3 df 68 27 fd 6d 04  |.[..m.w....h'.m.|\n+00000370  01 00 80 7b 9b fd 0d 62  57 07 ef 97 f5 ff a9 00  |...{...bW.......|\n+00000380  a0 89 35 5a 8a e6 e7 ae  7b 55 c5 dc 21 64 87 6e  |..5Z....{U..!d.n|\n+00000390  0f ab 85 6d 82 e8 83 fd  7d 3b 49 a7 ae 92 5f 6d  |...m....};I..._m|\n+000003a0  a3 42 ce ff ef a6 00 6a  33 32 1f 7b eb b7 c2 5c  |.B.....j32.{...\\|\n+000003b0  2d 38 cf 10 4b 59 69 4d  15 e0 68 49 39 ba cb 2a  |-8..KYiM..hI9..*|\n+000003c0  d9 b9 f3 fe 33 01 4f 7e  ac 69 02 35 a5 e0 33 8d  |....3.O~.i.5..3.|\n+000003d0  b3 74 34 14 45 9c 89 ad  41 2d d0 27 22 90 58 c6  |.t4.E...A-.'\".X.|\n+000003e0  e0 2c b4 6e 19 04 e4 46  26 ec 13 35 48 a6 3f 64  |.,.n...F&..5H.?d|\n+000003f0  dc 85 2b 16 03 03 00 04  0e 00 00 00              |..+.........|\n+>>> Flow 3 (client to server)\n+00000000  16 03 03 00 46 10 00 00  42 41 04 1e 18 37 ef 0d  |....F...BA...7..|\n+00000010  19 51 88 35 75 71 b5 e5  54 5b 12 2e 8f 09 67 fd  |.Q.5uq..T[....g.|\n+00000020  a7 24 20 3e b2 56 1c ce  97 28 5e f8 2b 2d 4f 9e  |.$ >.V...(^.+-O.|\n+00000030  f1 07 9f 6c 4b 5b 83 56  e2 32 42 e9 58 b6 d7 49  |...lK[.V.2B.X..I|\n+00000040  a6 b5 68 1a 41 03 56 6b  dc 5a 89 14 03 03 00 01  |..h.A.Vk.Z......|\n+00000050  01 16 03 03 00 28 00 00  00 00 00 00 00 00 88 0d  |.....(..........|\n+00000060  04 8b 8e 93 55 58 d6 75  ca 16 26 42 a3 60 20 67  |....UX.u..&B.` g|\n+00000070  84 cf d7 b3 10 fe 63 6c  2f 40 64 0c d6 78        |......cl/@d..x|\n+>>> Flow 4 (server to client)\n+00000000  14 03 03 00 01 01 16 03  03 00 28 bd 6c 2f 70 b9  |..........(.l/p.|\n+00000010  2f 9c 29 70 af 34 49 4c  5b 25 c3 14 b6 6d 28 81  |/.)p.4IL[%...m(.|\n+00000020  ff 54 d9 71 8d 2c c7 38  dd 44 27 6b 54 1e 53 7b  |.T.q.,.8.D'kT.S{|\n+00000030  22 cb 65                                          |\".e|\n+>>> Flow 5 (client to server)\n+00000000  17 03 03 00 1e 00 00 00  00 00 00 00 01 7f 0d d7  |................|\n+00000010  d9 4b 87 7b 36 fb 24 92  69 22 43 50 1e 46 fb c4  |.K.{6.$.i\"CP.F..|\n+00000020  86 64 6f 15 03 03 00 1a  00 00 00 00 00 00 00 02  |.do.............|\n+00000030  37 d5 2d 0a be c5 a8 ae  d4 bd 2b 09 34 18 a0 87  |7.-.......+.4...|\n+00000040  08 a6                                             |..|"}, {"sha": "2d8dfbc3b491e1bdbfd4f1c5ec332679dfa7a010", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv11-FallbackSCSV", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-FallbackSCSV", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-FallbackSCSV", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv11-FallbackSCSV?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,17 @@\n+>>> Flow 1 (client to server)\n+00000000  16 03 01 00 d4 01 00 00  d0 03 02 74 2d da 6d 98  |...........t-.m.|\n+00000010  ad 3e a5 ec 90 ea d1 5b  f0 e0 a7 45 33 d9 5e 8d  |.>.....[...E3.^.|\n+00000020  0f 1d 01 16 6d 00 31 65  ed 50 88 00 00 5e c0 14  |....m.1e.P...^..|\n+00000030  c0 0a 00 39 00 38 00 88  00 87 c0 0f c0 05 00 35  |...9.8.........5|\n+00000040  00 84 c0 13 c0 09 00 33  00 32 00 9a 00 99 00 45  |.......3.2.....E|\n+00000050  00 44 c0 0e c0 04 00 2f  00 96 00 41 00 07 c0 11  |.D...../...A....|\n+00000060  c0 07 c0 0c c0 02 00 05  00 04 c0 12 c0 08 00 16  |................|\n+00000070  00 13 c0 0d c0 03 00 0a  00 15 00 12 00 09 00 14  |................|\n+00000080  00 11 00 08 00 06 00 03  00 ff 56 00 01 00 00 49  |..........V....I|\n+00000090  00 0b 00 04 03 00 01 02  00 0a 00 34 00 32 00 0e  |...........4.2..|\n+000000a0  00 0d 00 19 00 0b 00 0c  00 18 00 09 00 0a 00 16  |................|\n+000000b0  00 17 00 08 00 06 00 07  00 14 00 15 00 04 00 05  |................|\n+000000c0  00 12 00 13 00 01 00 02  00 03 00 0f 00 10 00 11  |................|\n+000000d0  00 23 00 00 00 0f 00 01  01                       |.#.......|\n+>>> Flow 2 (server to client)\n+00000000  15 03 02 00 02 02 56                              |......V|"}, {"sha": "106244d5a22e62eac5ad1387e854c3d6bdca6d0e", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ALPN", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,122 @@\n+>>> Flow 1 (client to server)\n+00000000  16 03 01 01 8a 01 00 01  86 03 03 34 54 69 f3 d7  |...........4Ti..|\n+00000010  20 9d 1d 74 db 72 e9 2f  51 7c c2 82 0a 9b cb 6d  | ..t.r./Q|.....m|\n+00000020  90 b4 8e a2 1f 2f c7 66  74 8f 33 00 00 d6 c0 30  |...../.ft.3....0|\n+00000030  c0 2c c0 28 c0 24 c0 14  c0 0a c0 22 c0 21 c0 20  |.,.(.$.....\".!. |\n+00000040  00 a5 00 a3 00 a1 00 9f  00 6b 00 6a 00 69 00 68  |.........k.j.i.h|\n+00000050  00 39 00 38 00 37 00 36  00 88 00 87 00 86 00 85  |.9.8.7.6........|\n+00000060  c0 32 c0 2e c0 2a c0 26  c0 0f c0 05 00 9d 00 3d  |.2...*.&.......=|\n+00000070  00 35 00 84 c0 2f c0 2b  c0 27 c0 23 c0 13 c0 09  |.5.../.+.'.#....|\n+00000080  c0 1f c0 1e c0 1d 00 a4  00 a2 00 a0 00 9e 00 67  |...............g|\n+00000090  00 40 00 3f 00 3e 00 33  00 32 00 31 00 30 00 9a  |.@.?.>.3.2.1.0..|\n+000000a0  00 99 00 98 00 97 00 45  00 44 00 43 00 42 c0 31  |.......E.D.C.B.1|\n+000000b0  c0 2d c0 29 c0 25 c0 0e  c0 04 00 9c 00 3c 00 2f  |.-.).%.......<./|\n+000000c0  00 96 00 41 00 07 c0 11  c0 07 c0 0c c0 02 00 05  |...A............|\n+000000d0  00 04 c0 12 c0 08 c0 1c  c0 1b c0 1a 00 16 00 13  |................|\n+000000e0  00 10 00 0d c0 0d c0 03  00 0a 00 15 00 12 00 0f  |................|\n+000000f0  00 0c 00 09 00 14 00 11  00 0e 00 0b 00 08 00 06  |................|\n+00000100  00 03 00 ff 01 00 00 87  00 0b 00 04 03 00 01 02  |................|\n+00000110  00 0a 00 3a 00 38 00 0e  00 0d 00 19 00 1c 00 0b  |...:.8..........|\n+00000120  00 0c 00 1b 00 18 00 09  00 0a 00 1a 00 16 00 17  |................|\n+00000130  00 08 00 06 00 07 00 14  00 15 00 04 00 05 00 12  |................|\n+00000140  00 13 00 01 00 02 00 03  00 0f 00 10 00 11 00 23  |...............#|\n+00000150  00 00 00 0d 00 20 00 1e  06 01 06 02 06 03 05 01  |..... ..........|\n+00000160  05 02 05 03 04 01 04 02  04 03 03 01 03 02 03 03  |................|\n+00000170  02 01 02 02 02 03 00 0f  00 01 01 00 10 00 10 00  |................|\n+00000180  0e 06 70 72 6f 74 6f 32  06 70 72 6f 74 6f 31     |..proto2.proto1|\n+>>> Flow 2 (server to client)\n+00000000  16 03 03 00 42 02 00 00  3e 03 03 00 00 00 00 00  |....B...>.......|\n+00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 c0 14 00 00  |................|\n+00000030  16 00 23 00 00 ff 01 00  01 00 00 10 00 09 00 07  |..#.............|\n+00000040  06 70 72 6f 74 6f 31 16  03 03 02 be 0b 00 02 ba  |.proto1.........|\n+00000050  00 02 b7 00 02 b4 30 82  02 b0 30 82 02 19 a0 03  |......0...0.....|\n+00000060  02 01 02 02 09 00 85 b0  bb a4 8a 7f b8 ca 30 0d  |..............0.|\n+00000070  06 09 2a 86 48 86 f7 0d  01 01 05 05 00 30 45 31  |..*.H........0E1|\n+00000080  0b 30 09 06 03 55 04 06  13 02 41 55 31 13 30 11  |.0...U....AU1.0.|\n+00000090  06 03 55 04 08 13 0a 53  6f 6d 65 2d 53 74 61 74  |..U....Some-Stat|\n+000000a0  65 31 21 30 1f 06 03 55  04 0a 13 18 49 6e 74 65  |e1!0...U....Inte|\n+000000b0  72 6e 65 74 20 57 69 64  67 69 74 73 20 50 74 79  |rnet Widgits Pty|\n+000000c0  20 4c 74 64 30 1e 17 0d  31 30 30 34 32 34 30 39  | Ltd0...10042409|\n+000000d0  30 39 33 38 5a 17 0d 31  31 30 34 32 34 30 39 30  |0938Z..110424090|\n+000000e0  39 33 38 5a 30 45 31 0b  30 09 06 03 55 04 06 13  |938Z0E1.0...U...|\n+000000f0  02 41 55 31 13 30 11 06  03 55 04 08 13 0a 53 6f  |.AU1.0...U....So|\n+00000100  6d 65 2d 53 74 61 74 65  31 21 30 1f 06 03 55 04  |me-State1!0...U.|\n+00000110  0a 13 18 49 6e 74 65 72  6e 65 74 20 57 69 64 67  |...Internet Widg|\n+00000120  69 74 73 20 50 74 79 20  4c 74 64 30 81 9f 30 0d  |its Pty Ltd0..0.|\n+00000130  06 09 2a 86 48 86 f7 0d  01 01 01 05 00 03 81 8d  |..*.H...........|\n+00000140  00 30 81 89 02 81 81 00  bb 79 d6 f5 17 b5 e5 bf  |.0.......y......|\n+00000150  46 10 d0 dc 69 be e6 2b  07 43 5a d0 03 2d 8a 7a  |F...i..+.CZ..-.z|\n+00000160  43 85 b7 14 52 e7 a5 65  4c 2c 78 b8 23 8c b5 b4  |C...R..eL,x.#...|\n+00000170  82 e5 de 1f 95 3b 7e 62  a5 2c a5 33 d6 fe 12 5c  |.....;~b.,.3...\\|\n+00000180  7a 56 fc f5 06 bf fa 58  7b 26 3f b5 cd 04 d3 d0  |zV.....X{&?.....|\n+00000190  c9 21 96 4a c7 f4 54 9f  5a bf ef 42 71 00 fe 18  |.!.J..T.Z..Bq...|\n+000001a0  99 07 7f 7e 88 7d 7d f1  04 39 c4 a2 2e db 51 c9  |...~.}}..9....Q.|\n+000001b0  7c e3 c0 4c 3b 32 66 01  cf af b1 1d b8 71 9a 1d  ||..L;2f......q..|\n+000001c0  db db 89 6b ae da 2d 79  02 03 01 00 01 a3 81 a7  |...k..-y........|\n+000001d0  30 81 a4 30 1d 06 03 55  1d 0e 04 16 04 14 b1 ad  |0..0...U........|\n+000001e0  e2 85 5a cf cb 28 db 69  ce 23 69 de d3 26 8e 18  |..Z..(.i.#i..&..|\n+000001f0  88 39 30 75 06 03 55 1d  23 04 6e 30 6c 80 14 b1  |.90u..U.#.n0l...|\n+00000200  ad e2 85 5a cf cb 28 db  69 ce 23 69 de d3 26 8e  |...Z..(.i.#i..&.|\n+00000210  18 88 39 a1 49 a4 47 30  45 31 0b 30 09 06 03 55  |..9.I.G0E1.0...U|\n+00000220  04 06 13 02 41 55 31 13  30 11 06 03 55 04 08 13  |....AU1.0...U...|\n+00000230  0a 53 6f 6d 65 2d 53 74  61 74 65 31 21 30 1f 06  |.Some-State1!0..|\n+00000240  03 55 04 0a 13 18 49 6e  74 65 72 6e 65 74 20 57  |.U....Internet W|\n+00000250  69 64 67 69 74 73 20 50  74 79 20 4c 74 64 82 09  |idgits Pty Ltd..|\n+00000260  00 85 b0 bb a4 8a 7f b8  ca 30 0c 06 03 55 1d 13  |.........0...U..|\n+00000270  04 05 30 03 01 01 ff 30  0d 06 09 2a 86 48 86 f7  |..0....0...*.H..|\n+00000280  0d 01 01 05 05 00 03 81  81 00 08 6c 45 24 c7 6b  |...........lE$.k|\n+00000290  b1 59 ab 0c 52 cc f2 b0  14 d7 87 9d 7a 64 75 b5  |.Y..R.......zdu.|\n+000002a0  5a 95 66 e4 c5 2b 8e ae  12 66 1f eb 4f 38 b3 6e  |Z.f..+...f..O8.n|\n+000002b0  60 d3 92 fd f7 41 08 b5  25 13 b1 18 7a 24 fb 30  |`....A..%...z$.0|\n+000002c0  1d ba ed 98 b9 17 ec e7  d7 31 59 db 95 d3 1d 78  |.........1Y....x|\n+000002d0  ea 50 56 5c d5 82 5a 2d  5a 5f 33 c4 b6 d8 c9 75  |.PV\\..Z-Z_3....u|\n+000002e0  90 96 8c 0f 52 98 b5 cd  98 1f 89 20 5f f2 a0 1c  |....R...... _...|\n+000002f0  a3 1b 96 94 dd a9 fd 57  e9 70 e8 26 6d 71 99 9b  |.......W.p.&mq..|\n+00000300  26 6e 38 50 29 6c 90 a7  bd d9 16 03 03 00 cd 0c  |&n8P)l..........|\n+00000310  00 00 c9 03 00 17 41 04  1e 18 37 ef 0d 19 51 88  |......A...7...Q.|\n+00000320  35 75 71 b5 e5 54 5b 12  2e 8f 09 67 fd a7 24 20  |5uq..T[....g..$ |\n+00000330  3e b2 56 1c ce 97 28 5e  f8 2b 2d 4f 9e f1 07 9f  |>.V...(^.+-O....|\n+00000340  6c 4b 5b 83 56 e2 32 42  e9 58 b6 d7 49 a6 b5 68  |lK[.V.2B.X..I..h|\n+00000350  1a 41 03 56 6b dc 5a 89  04 01 00 80 2d a0 6e 47  |.A.Vk.Z.....-.nG|\n+00000360  93 a2 19 17 32 f5 42 58  93 f6 4f d4 e9 4d a4 0f  |....2.BX..O..M..|\n+00000370  fe 4e d7 2c 62 b6 fb 83  37 a3 09 60 4b 69 e2 4c  |.N.,b...7..`Ki.L|\n+00000380  fc b8 4c d1 a6 9a 89 a0  c5 76 f5 62 b7 e8 eb c2  |..L......v.b....|\n+00000390  fa 0f 0e 61 86 bc 70 da  13 72 8d 87 94 16 9a 8d  |...a..p..r......|\n+000003a0  5f 80 82 92 77 37 4f 9e  55 5d dc 35 42 a3 75 5c  |_...w7O.U].5B.u\\|\n+000003b0  ec a4 58 78 66 97 97 da  49 67 2e b6 7e 11 de fb  |..Xxf...Ig..~...|\n+000003c0  e3 8f e8 bf 1d 91 1e 91  20 1b 2a df c6 58 e4 82  |........ .*..X..|\n+000003d0  ce 37 dd 6f a5 ac 51 3d  65 db 3f f5 16 03 03 00  |.7.o..Q=e.?.....|\n+000003e0  04 0e 00 00 00                                    |.....|\n+>>> Flow 3 (client to server)\n+00000000  16 03 03 00 46 10 00 00  42 41 04 f3 fc ea d8 50  |....F...BA.....P|\n+00000010  e6 15 b0 e7 11 c7 6d ee  09 ad 80 d5 54 eb 4f 62  |......m.....T.Ob|\n+00000020  7d bb a7 2d 28 0c 66 33  42 09 cf 2b 58 f8 58 41  |}..-(.f3B..+X.XA|\n+00000030  bd 46 51 0a f0 7d 8c 0c  98 9e 26 77 20 fd 5e c1  |.FQ..}....&w .^.|\n+00000040  a9 b3 e5 c3 6c 05 97 e3  81 fd db 14 03 03 00 01  |....l...........|\n+00000050  01 16 03 03 00 40 02 2a  28 41 e3 9c 5d 45 d4 45  |.....@.*(A..]E.E|\n+00000060  51 8c 7a c0 ba b1 8e a4  84 2c f3 83 cd c4 55 5c  |Q.z......,....U\\|\n+00000070  d6 5c 6f 72 ab 89 7a c6  d7 9c 2a 54 f0 c4 20 ee  |.\\or..z...*T.. .|\n+00000080  37 74 9b b6 8c f7 e4 37  2c eb d4 9f 5c 5e 55 a0  |7t.....7,...\\^U.|\n+00000090  e2 5a fe 1e c8 67                                 |.Z...g|\n+>>> Flow 4 (server to client)\n+00000000  16 03 03 00 72 04 00 00  6e 00 00 00 00 00 68 00  |....r...n.....h.|\n+00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 65  |...............e|\n+00000020  ea 8b c0 ef ba 59 31 75  33 96 f1 f8 c9 e1 ef 30  |.....Y1u3......0|\n+00000030  00 a3 a9 1d ab c8 4b 29  94 f2 c8 c8 8d 03 57 ab  |......K)......W.|\n+00000040  56 df 0f 4e 0d 30 13 09  c9 e4 fa 51 4e b3 26 ad  |V..N.0.....QN.&.|\n+00000050  43 9f ae 62 d5 59 23 05  9b 69 8f 5b a8 ba 39 f1  |C..b.Y#..i.[..9.|\n+00000060  90 84 35 bf 8f 8d d5 39  93 98 ee b9 75 03 3f 91  |..5....9....u.?.|\n+00000070  e8 56 0b cb 44 a6 7a 14  03 03 00 01 01 16 03 03  |.V..D.z.........|\n+00000080  00 40 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |.@..............|\n+00000090  00 00 f9 a0 8e 23 34 f1  61 15 a8 4e ae c4 f3 2a  |.....#4.a..N...*|\n+000000a0  a6 f8 ee 1b 65 c4 c0 ff  93 14 74 ed 82 ae 48 a8  |....e.....t...H.|\n+000000b0  42 fb a9 24 5d dd fd 98  b8 65 73 03 88 99 e1 ed  |B..$]....es.....|\n+000000c0  02 95 17 03 03 00 40 00  00 00 00 00 00 00 00 00  |......@.........|\n+000000d0  00 00 00 00 00 00 00 b9  b3 f5 41 84 3b 2a a9 c3  |..........A.;*..|\n+000000e0  9c e3 d4 38 90 76 c1 8c  f0 4f 10 1b 04 b5 07 fe  |...8.v...O......|\n+000000f0  79 3d 7b 77 a4 17 0f 4e  df 64 70 70 9e 34 8e b6  |y={w...N.dpp.4..|\n+00000100  db b2 b6 fd 41 fe b3 15  03 03 00 30 00 00 00 00  |....A......0....|\n+00000110  00 00 00 00 00 00 00 00  00 00 00 00 02 73 de fe  |.............s..|\n+00000120  fa 4b 69 6d 30 69 79 96  7e 4f 2f 04 67 36 96 27  |.Kim0iy.~O/.g6.'|\n+00000130  67 23 2b dc 7a c4 6c 34  ea fc 79 fd              |g#+.z.l4..y.|"}, {"sha": "db5881b768524aafd6e6c230ae0cc55d3ff5a04b", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ALPN-NoMatch", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ALPN-NoMatch?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,121 @@\n+>>> Flow 1 (client to server)\n+00000000  16 03 01 01 8a 01 00 01  86 03 03 0a a8 82 53 61  |..............Sa|\n+00000010  68 e0 83 91 71 36 f9 c1  19 ff e8 09 fc 21 9f 03  |h...q6.......!..|\n+00000020  31 f3 87 4a 04 8c 3d c2  6e 00 32 00 00 d6 c0 30  |1..J..=.n.2....0|\n+00000030  c0 2c c0 28 c0 24 c0 14  c0 0a c0 22 c0 21 c0 20  |.,.(.$.....\".!. |\n+00000040  00 a5 00 a3 00 a1 00 9f  00 6b 00 6a 00 69 00 68  |.........k.j.i.h|\n+00000050  00 39 00 38 00 37 00 36  00 88 00 87 00 86 00 85  |.9.8.7.6........|\n+00000060  c0 32 c0 2e c0 2a c0 26  c0 0f c0 05 00 9d 00 3d  |.2...*.&.......=|\n+00000070  00 35 00 84 c0 2f c0 2b  c0 27 c0 23 c0 13 c0 09  |.5.../.+.'.#....|\n+00000080  c0 1f c0 1e c0 1d 00 a4  00 a2 00 a0 00 9e 00 67  |...............g|\n+00000090  00 40 00 3f 00 3e 00 33  00 32 00 31 00 30 00 9a  |.@.?.>.3.2.1.0..|\n+000000a0  00 99 00 98 00 97 00 45  00 44 00 43 00 42 c0 31  |.......E.D.C.B.1|\n+000000b0  c0 2d c0 29 c0 25 c0 0e  c0 04 00 9c 00 3c 00 2f  |.-.).%.......<./|\n+000000c0  00 96 00 41 00 07 c0 11  c0 07 c0 0c c0 02 00 05  |...A............|\n+000000d0  00 04 c0 12 c0 08 c0 1c  c0 1b c0 1a 00 16 00 13  |................|\n+000000e0  00 10 00 0d c0 0d c0 03  00 0a 00 15 00 12 00 0f  |................|\n+000000f0  00 0c 00 09 00 14 00 11  00 0e 00 0b 00 08 00 06  |................|\n+00000100  00 03 00 ff 01 00 00 87  00 0b 00 04 03 00 01 02  |................|\n+00000110  00 0a 00 3a 00 38 00 0e  00 0d 00 19 00 1c 00 0b  |...:.8..........|\n+00000120  00 0c 00 1b 00 18 00 09  00 0a 00 1a 00 16 00 17  |................|\n+00000130  00 08 00 06 00 07 00 14  00 15 00 04 00 05 00 12  |................|\n+00000140  00 13 00 01 00 02 00 03  00 0f 00 10 00 11 00 23  |...............#|\n+00000150  00 00 00 0d 00 20 00 1e  06 01 06 02 06 03 05 01  |..... ..........|\n+00000160  05 02 05 03 04 01 04 02  04 03 03 01 03 02 03 03  |................|\n+00000170  02 01 02 02 02 03 00 0f  00 01 01 00 10 00 10 00  |................|\n+00000180  0e 06 70 72 6f 74 6f 32  06 70 72 6f 74 6f 31     |..proto2.proto1|\n+>>> Flow 2 (server to client)\n+00000000  16 03 03 00 35 02 00 00  31 03 03 00 00 00 00 00  |....5...1.......|\n+00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n+00000020  00 00 00 00 00 00 00 00  00 00 00 00 c0 14 00 00  |................|\n+00000030  09 00 23 00 00 ff 01 00  01 00 16 03 03 02 be 0b  |..#.............|\n+00000040  00 02 ba 00 02 b7 00 02  b4 30 82 02 b0 30 82 02  |.........0...0..|\n+00000050  19 a0 03 02 01 02 02 09  00 85 b0 bb a4 8a 7f b8  |................|\n+00000060  ca 30 0d 06 09 2a 86 48  86 f7 0d 01 01 05 05 00  |.0...*.H........|\n+00000070  30 45 31 0b 30 09 06 03  55 04 06 13 02 41 55 31  |0E1.0...U....AU1|\n+00000080  13 30 11 06 03 55 04 08  13 0a 53 6f 6d 65 2d 53  |.0...U....Some-S|\n+00000090  74 61 74 65 31 21 30 1f  06 03 55 04 0a 13 18 49  |tate1!0...U....I|\n+000000a0  6e 74 65 72 6e 65 74 20  57 69 64 67 69 74 73 20  |nternet Widgits |\n+000000b0  50 74 79 20 4c 74 64 30  1e 17 0d 31 30 30 34 32  |Pty Ltd0...10042|\n+000000c0  34 30 39 30 39 33 38 5a  17 0d 31 31 30 34 32 34  |4090938Z..110424|\n+000000d0  30 39 30 39 33 38 5a 30  45 31 0b 30 09 06 03 55  |090938Z0E1.0...U|\n+000000e0  04 06 13 02 41 55 31 13  30 11 06 03 55 04 08 13  |....AU1.0...U...|\n+000000f0  0a 53 6f 6d 65 2d 53 74  61 74 65 31 21 30 1f 06  |.Some-State1!0..|\n+00000100  03 55 04 0a 13 18 49 6e  74 65 72 6e 65 74 20 57  |.U....Internet W|\n+00000110  69 64 67 69 74 73 20 50  74 79 20 4c 74 64 30 81  |idgits Pty Ltd0.|\n+00000120  9f 30 0d 06 09 2a 86 48  86 f7 0d 01 01 01 05 00  |.0...*.H........|\n+00000130  03 81 8d 00 30 81 89 02  81 81 00 bb 79 d6 f5 17  |....0.......y...|\n+00000140  b5 e5 bf 46 10 d0 dc 69  be e6 2b 07 43 5a d0 03  |...F...i..+.CZ..|\n+00000150  2d 8a 7a 43 85 b7 14 52  e7 a5 65 4c 2c 78 b8 23  |-.zC...R..eL,x.#|\n+00000160  8c b5 b4 82 e5 de 1f 95  3b 7e 62 a5 2c a5 33 d6  |........;~b.,.3.|\n+00000170  fe 12 5c 7a 56 fc f5 06  bf fa 58 7b 26 3f b5 cd  |..\\zV.....X{&?..|\n+00000180  04 d3 d0 c9 21 96 4a c7  f4 54 9f 5a bf ef 42 71  |....!.J..T.Z..Bq|\n+00000190  00 fe 18 99 07 7f 7e 88  7d 7d f1 04 39 c4 a2 2e  |......~.}}..9...|\n+000001a0  db 51 c9 7c e3 c0 4c 3b  32 66 01 cf af b1 1d b8  |.Q.|..L;2f......|\n+000001b0  71 9a 1d db db 89 6b ae  da 2d 79 02 03 01 00 01  |q.....k..-y.....|\n+000001c0  a3 81 a7 30 81 a4 30 1d  06 03 55 1d 0e 04 16 04  |...0..0...U.....|\n+000001d0  14 b1 ad e2 85 5a cf cb  28 db 69 ce 23 69 de d3  |.....Z..(.i.#i..|\n+000001e0  26 8e 18 88 39 30 75 06  03 55 1d 23 04 6e 30 6c  |&...90u..U.#.n0l|\n+000001f0  80 14 b1 ad e2 85 5a cf  cb 28 db 69 ce 23 69 de  |......Z..(.i.#i.|\n+00000200  d3 26 8e 18 88 39 a1 49  a4 47 30 45 31 0b 30 09  |.&...9.I.G0E1.0.|\n+00000210  06 03 55 04 06 13 02 41  55 31 13 30 11 06 03 55  |..U....AU1.0...U|\n+00000220  04 08 13 0a 53 6f 6d 65  2d 53 74 61 74 65 31 21  |....Some-State1!|\n+00000230  30 1f 06 03 55 04 0a 13  18 49 6e 74 65 72 6e 65  |0...U....Interne|\n+00000240  74 20 57 69 64 67 69 74  73 20 50 74 79 20 4c 74  |t Widgits Pty Lt|\n+00000250  64 82 09 00 85 b0 bb a4  8a 7f b8 ca 30 0c 06 03  |d...........0...|\n+00000260  55 1d 13 04 05 30 03 01  01 ff 30 0d 06 09 2a 86  |U....0....0...*.|\n+00000270  48 86 f7 0d 01 01 05 05  00 03 81 81 00 08 6c 45  |H.............lE|\n+00000280  24 c7 6b b1 59 ab 0c 52  cc f2 b0 14 d7 87 9d 7a  |$.k.Y..R.......z|\n+00000290  64 75 b5 5a 95 66 e4 c5  2b 8e ae 12 66 1f eb 4f  |du.Z.f..+...f..O|\n+000002a0  38 b3 6e 60 d3 92 fd f7  41 08 b5 25 13 b1 18 7a  |8.n`....A..%...z|\n+000002b0  24 fb 30 1d ba ed 98 b9  17 ec e7 d7 31 59 db 95  |$.0.........1Y..|\n+000002c0  d3 1d 78 ea 50 56 5c d5  82 5a 2d 5a 5f 33 c4 b6  |..x.PV\\..Z-Z_3..|\n+000002d0  d8 c9 75 90 96 8c 0f 52  98 b5 cd 98 1f 89 20 5f  |..u....R...... _|\n+000002e0  f2 a0 1c a3 1b 96 94 dd  a9 fd 57 e9 70 e8 26 6d  |..........W.p.&m|\n+000002f0  71 99 9b 26 6e 38 50 29  6c 90 a7 bd d9 16 03 03  |q..&n8P)l.......|\n+00000300  00 cd 0c 00 00 c9 03 00  17 41 04 1e 18 37 ef 0d  |.........A...7..|\n+00000310  19 51 88 35 75 71 b5 e5  54 5b 12 2e 8f 09 67 fd  |.Q.5uq..T[....g.|\n+00000320  a7 24 20 3e b2 56 1c ce  97 28 5e f8 2b 2d 4f 9e  |.$ >.V...(^.+-O.|\n+00000330  f1 07 9f 6c 4b 5b 83 56  e2 32 42 e9 58 b6 d7 49  |...lK[.V.2B.X..I|\n+00000340  a6 b5 68 1a 41 03 56 6b  dc 5a 89 04 01 00 80 b9  |..h.A.Vk.Z......|\n+00000350  0f 79 8a 16 f4 da 8f 27  b4 16 fc c0 51 db ae d1  |.y.....'....Q...|\n+00000360  af 79 77 d5 d5 a2 13 05  45 20 cc eb ac ed cb 30  |.yw.....E .....0|\n+00000370  32 2e 2c bd fa 1c 4d b5  32 a6 37 43 c8 5c 2d f8  |2.,...M.2.7C.\\-.|\n+00000380  6e 85 f5 cd 54 92 29 ad  13 7d d5 9e 8c 1d b7 d0  |n...T.)..}......|\n+00000390  c1 c7 3d e8 ba 4a 0f 9a  a6 3e 25 5f 27 62 b1 00  |..=..J...>%_'b..|\n+000003a0  91 d9 23 48 3f 10 fe c5  e3 07 9a 58 57 6d cc 10  |..#H?......XWm..|\n+000003b0  3b f8 1a d5 6e 8b 1f 03  6f 82 84 98 b5 f7 71 5d  |;...n...o.....q]|\n+000003c0  c2 ad 60 14 c1 88 07 5a  3d 99 fd a8 c9 9a 03 16  |..`....Z=.......|\n+000003d0  03 03 00 04 0e 00 00 00                           |........|\n+>>> Flow 3 (client to server)\n+00000000  16 03 03 00 46 10 00 00  42 41 04 76 aa 4e b9 f9  |....F...BA.v.N..|\n+00000010  68 85 81 74 7c d9 f9 64  7f bd 09 83 08 5b 4f 76  |h..t|..d.....[Ov|\n+00000020  6e be 79 b6 4e 97 17 63  e4 b5 1c 77 e5 85 76 8a  |n.y.N..c...w..v.|\n+00000030  5d 9f f1 21 88 ec f9 a7  7c 41 af f9 c5 fe 11 81  |]..!....|A......|\n+00000040  11 51 8e a7 20 33 5f cf  e7 90 90 14 03 03 00 01  |.Q.. 3_.........|\n+00000050  01 16 03 03 00 40 44 3e  32 01 71 ac 5a b5 1f 2c  |.....@D>2.q.Z..,|\n+00000060  37 d9 4b 70 72 91 89 d4  d7 c2 c3 e7 ff dc 72 2a  |7.Kpr.........r*|\n+00000070  ba f5 30 b0 e9 dd 48 10  3d cd 98 48 a3 e3 ca de  |..0...H.=..H....|\n+00000080  15 0e 90 8e e5 04 14 74  42 b8 b0 12 cc 68 7b 7d  |.......tB....h{}|\n+00000090  6c 43 72 60 05 0d                                 |lCr`..|\n+>>> Flow 4 (server to client)\n+00000000  16 03 03 00 72 04 00 00  6e 00 00 00 00 00 68 00  |....r...n.....h.|\n+00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 65  |...............e|\n+00000020  ea 8b c0 ef ba 12 45 17  61 24 cd d2 4c 22 bb 3b  |......E.a$..L\".;|\n+00000030  e3 0e d0 ff 83 e9 7c b7  8f 10 3c 16 1c fc c2 44  |......|...<....D|\n+00000040  ef 45 f8 27 30 56 db ea  eb ae f5 b6 17 b2 ef f9  |.E.'0V..........|\n+00000050  96 0d 2d db e4 59 23 0a  fc fa e3 13 48 57 e5 b3  |..-..Y#.....HW..|\n+00000060  3a d1 f5 5e ca ef d7 3f  7b b5 f4 69 85 c3 bd da  |:..^...?{..i....|\n+00000070  fd 9c 50 05 2f 86 ce 14  03 03 00 01 01 16 03 03  |..P./...........|\n+00000080  00 40 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |.@..............|\n+00000090  00 00 60 25 1c ed 6f c6  a5 bd b2 29 39 4e 09 d1  |..`%..o....)9N..|\n+000000a0  64 cc 75 cd df 91 a8 90  9d 03 aa 92 07 f2 d0 8a  |d.u.............|\n+000000b0  60 bb 3e 85 21 22 fe f8  dc 52 3c 4e 82 77 14 14  |`.>.!\"...R<N.w..|\n+000000c0  0f 1f 17 03 03 00 40 00  00 00 00 00 00 00 00 00  |......@.........|\n+000000d0  00 00 00 00 00 00 00 0b  87 12 62 3e e5 3e 7d 74  |..........b>.>}t|\n+000000e0  0d ac c4 a9 df 67 1c 5a  ad 3e 01 34 03 88 2f 39  |.....g.Z.>.4../9|\n+000000f0  f7 3c 06 e4 f6 81 43 66  b1 1b ed a5 e5 b6 a8 43  |.<....Cf.......C|\n+00000100  7f 36 2f b2 da 45 9a 15  03 03 00 30 00 00 00 00  |.6/..E.....0....|\n+00000110  00 00 00 00 00 00 00 00  00 00 00 00 fa 63 4e c5  |.............cN.|\n+00000120  77 89 71 56 e3 0a cf 98  da 2f 89 8f 74 8e 76 24  |w.qV...../..t.v$|\n+00000130  e2 40 a5 9f 29 1b b2 11  ef 7a 55 7f              |.@..)....zU.|"}, {"sha": "30f0026815538511a3b44e50d269981048df71af", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-IssueTicketPreDisable", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-IssueTicketPreDisable?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,87 +0,0 @@\n->>> Flow 1 (client to server)\n-00000000  16 03 01 00 60 01 00 00  5c 03 03 54 23 54 02 17  |....`...\\..T#T..|\n-00000010  f3 53 13 3d 48 88 c3 19  b9 d1 3d 33 7f f5 99 56  |.S.=H.....=3...V|\n-00000020  04 71 1b d9 d5 64 8a 0d  4a 54 00 00 00 04 00 05  |.q...d..JT......|\n-00000030  00 ff 01 00 00 2f 00 23  00 00 00 0d 00 22 00 20  |...../.#.....\". |\n-00000040  06 01 06 02 06 03 05 01  05 02 05 03 04 01 04 02  |................|\n-00000050  04 03 03 01 03 02 03 03  02 01 02 02 02 03 01 01  |................|\n-00000060  00 0f 00 01 01                                    |.....|\n->>> Flow 2 (server to client)\n-00000000  16 03 03 00 35 02 00 00  31 03 03 00 00 00 00 00  |....5...1.......|\n-00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 05 00 00  |................|\n-00000030  09 00 23 00 00 ff 01 00  01 00 16 03 03 02 be 0b  |..#.............|\n-00000040  00 02 ba 00 02 b7 00 02  b4 30 82 02 b0 30 82 02  |.........0...0..|\n-00000050  19 a0 03 02 01 02 02 09  00 85 b0 bb a4 8a 7f b8  |................|\n-00000060  ca 30 0d 06 09 2a 86 48  86 f7 0d 01 01 05 05 00  |.0...*.H........|\n-00000070  30 45 31 0b 30 09 06 03  55 04 06 13 02 41 55 31  |0E1.0...U....AU1|\n-00000080  13 30 11 06 03 55 04 08  13 0a 53 6f 6d 65 2d 53  |.0...U....Some-S|\n-00000090  74 61 74 65 31 21 30 1f  06 03 55 04 0a 13 18 49  |tate1!0...U....I|\n-000000a0  6e 74 65 72 6e 65 74 20  57 69 64 67 69 74 73 20  |nternet Widgits |\n-000000b0  50 74 79 20 4c 74 64 30  1e 17 0d 31 30 30 34 32  |Pty Ltd0...10042|\n-000000c0  34 30 39 30 39 33 38 5a  17 0d 31 31 30 34 32 34  |4090938Z..110424|\n-000000d0  30 39 30 39 33 38 5a 30  45 31 0b 30 09 06 03 55  |090938Z0E1.0...U|\n-000000e0  04 06 13 02 41 55 31 13  30 11 06 03 55 04 08 13  |....AU1.0...U...|\n-000000f0  0a 53 6f 6d 65 2d 53 74  61 74 65 31 21 30 1f 06  |.Some-State1!0..|\n-00000100  03 55 04 0a 13 18 49 6e  74 65 72 6e 65 74 20 57  |.U....Internet W|\n-00000110  69 64 67 69 74 73 20 50  74 79 20 4c 74 64 30 81  |idgits Pty Ltd0.|\n-00000120  9f 30 0d 06 09 2a 86 48  86 f7 0d 01 01 01 05 00  |.0...*.H........|\n-00000130  03 81 8d 00 30 81 89 02  81 81 00 bb 79 d6 f5 17  |....0.......y...|\n-00000140  b5 e5 bf 46 10 d0 dc 69  be e6 2b 07 43 5a d0 03  |...F...i..+.CZ..|\n-00000150  2d 8a 7a 43 85 b7 14 52  e7 a5 65 4c 2c 78 b8 23  |-.zC...R..eL,x.#|\n-00000160  8c b5 b4 82 e5 de 1f 95  3b 7e 62 a5 2c a5 33 d6  |........;~b.,.3.|\n-00000170  fe 12 5c 7a 56 fc f5 06  bf fa 58 7b 26 3f b5 cd  |..\\zV.....X{&?..|\n-00000180  04 d3 d0 c9 21 96 4a c7  f4 54 9f 5a bf ef 42 71  |....!.J..T.Z..Bq|\n-00000190  00 fe 18 99 07 7f 7e 88  7d 7d f1 04 39 c4 a2 2e  |......~.}}..9...|\n-000001a0  db 51 c9 7c e3 c0 4c 3b  32 66 01 cf af b1 1d b8  |.Q.|..L;2f......|\n-000001b0  71 9a 1d db db 89 6b ae  da 2d 79 02 03 01 00 01  |q.....k..-y.....|\n-000001c0  a3 81 a7 30 81 a4 30 1d  06 03 55 1d 0e 04 16 04  |...0..0...U.....|\n-000001d0  14 b1 ad e2 85 5a cf cb  28 db 69 ce 23 69 de d3  |.....Z..(.i.#i..|\n-000001e0  26 8e 18 88 39 30 75 06  03 55 1d 23 04 6e 30 6c  |&...90u..U.#.n0l|\n-000001f0  80 14 b1 ad e2 85 5a cf  cb 28 db 69 ce 23 69 de  |......Z..(.i.#i.|\n-00000200  d3 26 8e 18 88 39 a1 49  a4 47 30 45 31 0b 30 09  |.&...9.I.G0E1.0.|\n-00000210  06 03 55 04 06 13 02 41  55 31 13 30 11 06 03 55  |..U....AU1.0...U|\n-00000220  04 08 13 0a 53 6f 6d 65  2d 53 74 61 74 65 31 21  |....Some-State1!|\n-00000230  30 1f 06 03 55 04 0a 13  18 49 6e 74 65 72 6e 65  |0...U....Interne|\n-00000240  74 20 57 69 64 67 69 74  73 20 50 74 79 20 4c 74  |t Widgits Pty Lt|\n-00000250  64 82 09 00 85 b0 bb a4  8a 7f b8 ca 30 0c 06 03  |d...........0...|\n-00000260  55 1d 13 04 05 30 03 01  01 ff 30 0d 06 09 2a 86  |U....0....0...*.|\n-00000270  48 86 f7 0d 01 01 05 05  00 03 81 81 00 08 6c 45  |H.............lE|\n-00000280  24 c7 6b b1 59 ab 0c 52  cc f2 b0 14 d7 87 9d 7a  |$.k.Y..R.......z|\n-00000290  64 75 b5 5a 95 66 e4 c5  2b 8e ae 12 66 1f eb 4f  |du.Z.f..+...f..O|\n-000002a0  38 b3 6e 60 d3 92 fd f7  41 08 b5 25 13 b1 18 7a  |8.n`....A..%...z|\n-000002b0  24 fb 30 1d ba ed 98 b9  17 ec e7 d7 31 59 db 95  |$.0.........1Y..|\n-000002c0  d3 1d 78 ea 50 56 5c d5  82 5a 2d 5a 5f 33 c4 b6  |..x.PV\\..Z-Z_3..|\n-000002d0  d8 c9 75 90 96 8c 0f 52  98 b5 cd 98 1f 89 20 5f  |..u....R...... _|\n-000002e0  f2 a0 1c a3 1b 96 94 dd  a9 fd 57 e9 70 e8 26 6d  |..........W.p.&m|\n-000002f0  71 99 9b 26 6e 38 50 29  6c 90 a7 bd d9 16 03 03  |q..&n8P)l.......|\n-00000300  00 04 0e 00 00 00                                 |......|\n->>> Flow 3 (client to server)\n-00000000  16 03 03 00 86 10 00 00  82 00 80 27 e9 a4 f7 e7  |...........'....|\n-00000010  df 25 de 84 8c 1f d6 e6  c3 11 28 55 9a c1 91 37  |.%........(U...7|\n-00000020  84 f5 ba f8 80 0d ca 50  cb 1e 72 f7 97 6f c2 b2  |.......P..r..o..|\n-00000030  04 4d 13 7c e0 6e a0 1f  91 e1 38 1b a2 c0 55 16  |.M.|.n....8...U.|\n-00000040  7f 29 fc ed 1c 1a cf 72  14 c3 00 c1 dd 36 36 af  |.).....r.....66.|\n-00000050  a6 e4 a8 be ba ec 13 d0  1e d0 1d fd e1 5b 27 fd  |.............['.|\n-00000060  9a da 2e 12 c8 b0 b9 c2  b9 76 ec 7f 3c 98 b6 63  |.........v..<..c|\n-00000070  bc da f0 07 7a 3d e7 61  f4 2f 12 80 3b f9 3b cc  |....z=.a./..;.;.|\n-00000080  05 c8 2f 7e 28 b2 73 bf  97 61 29 14 03 03 00 01  |../~(.s..a).....|\n-00000090  01 16 03 03 00 24 17 59  a9 45 53 46 33 96 50 dd  |.....$.Y.ESF3.P.|\n-000000a0  3e 23 aa 91 38 f8 56 4a  2f 1a f2 b1 44 9b ce 17  |>#..8.VJ/...D...|\n-000000b0  6b 8a 89 76 bc 67 b8 8b  ba 90                    |k..v.g....|\n->>> Flow 4 (server to client)\n-00000000  16 03 03 00 72 04 00 00  6e 00 00 00 00 00 68 00  |....r...n.....h.|\n-00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 65  |...............e|\n-00000020  ea 4b d1 ef ba 2d db 0c  ba 9a d4 20 76 57 c8 ec  |.K...-..... vW..|\n-00000030  dc 2d 77 fb fb 3b 93 5f  53 e0 14 4f 90 fb d6 55  |.-w..;._S..O...U|\n-00000040  57 8c 8d 0d 25 ea 5d 0d  f2 91 e5 12 22 12 ec 7b  |W...%.].....\"..{|\n-00000050  5f b6 6e fd 07 59 23 24  fc b1 97 ca ea 56 a5 c2  |_.n..Y#$.....V..|\n-00000060  a0 e4 9e 99 64 f2 64 d0  75 7a 46 63 e3 dc 21 ed  |....d.d.uzFc..!.|\n-00000070  78 56 e9 e1 ab 66 80 14  03 03 00 01 01 16 03 03  |xV...f..........|\n-00000080  00 24 fc 14 68 07 17 1f  df b7 84 cb fd c1 e0 e4  |.$..h...........|\n-00000090  f2 1a ea 34 b5 00 7f 70  be c8 1c 0a d6 55 e3 57  |...4...p.....U.W|\n-000000a0  50 4e 6d 7d 8a 5d 17 03  03 00 21 24 27 50 40 c1  |PNm}.]....!$'P@.|\n-000000b0  c5 bd c7 9f 95 d9 ba 2e  7b 0e db ea a7 31 81 05  |........{....1..|\n-000000c0  75 43 b1 63 cf b8 55 92  ef 76 98 a9 15 03 03 00  |uC.c..U..v......|\n-000000d0  16 d7 ea 3c 79 e7 a6 2f  61 39 ec 4e 95 86 48 5e  |...<y../a9.N..H^|\n-000000e0  75 a0 9e 41 42 89 67                              |u..AB.g|"}, {"sha": "db833f65559af36771ab35aad82b58c476a0e74c", "filename": "libgo/go/crypto/tls/testdata/Server-TLSv12-ResumeDisabled", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftestdata%2FServer-TLSv12-ResumeDisabled?ref=6bd3f109d8d8fa58eeccd6b3504721b4f20c00c2", "patch": "@@ -1,87 +0,0 @@\n->>> Flow 1 (client to server)\n-00000000  16 03 01 00 e8 01 00 00  e4 03 03 54 23 54 02 a5  |...........T#T..|\n-00000010  10 11 0f 6d e5 2d 2f e8  bb 52 b1 38 3f 65 01 43  |...m.-/..R.8?e.C|\n-00000020  36 cc 48 f6 09 22 a1 85  20 28 3c 20 35 8b fe 7a  |6.H..\".. (< 5..z|\n-00000030  41 3b 59 3a 5d b9 b3 21  f0 62 e9 0d 7b af f5 5d  |A;Y:]..!.b..{..]|\n-00000040  fa 65 1a 40 c8 ca cd 74  8c ef d2 fb 00 04 00 05  |.e.@...t........|\n-00000050  00 ff 01 00 00 97 00 23  00 68 00 00 00 00 00 00  |.......#.h......|\n-00000060  00 00 00 00 00 00 00 00  00 00 65 ea 4b d1 ef ba  |..........e.K...|\n-00000070  2d db 0c ba 9a d4 20 76  57 c8 ec dc 2d 77 fb fb  |-..... vW...-w..|\n-00000080  3b 93 5f 53 e0 14 4f 90  fb d6 55 57 8c 8d 0d 25  |;._S..O...UW...%|\n-00000090  ea 5d 0d f2 91 e5 12 22  12 ec 7b 5f b6 6e fd 07  |.].....\"..{_.n..|\n-000000a0  59 23 24 fc b1 97 ca ea  56 a5 c2 a0 e4 9e 99 64  |Y#$.....V......d|\n-000000b0  f2 64 d0 75 7a 46 63 e3  dc 21 ed 78 56 e9 e1 ab  |.d.uzFc..!.xV...|\n-000000c0  66 80 00 0d 00 22 00 20  06 01 06 02 06 03 05 01  |f....\". ........|\n-000000d0  05 02 05 03 04 01 04 02  04 03 03 01 03 02 03 03  |................|\n-000000e0  02 01 02 02 02 03 01 01  00 0f 00 01 01           |.............|\n->>> Flow 2 (server to client)\n-00000000  16 03 03 00 31 02 00 00  2d 03 03 00 00 00 00 00  |....1...-.......|\n-00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n-00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 05 00 00  |................|\n-00000030  05 ff 01 00 01 00 16 03  03 02 be 0b 00 02 ba 00  |................|\n-00000040  02 b7 00 02 b4 30 82 02  b0 30 82 02 19 a0 03 02  |.....0...0......|\n-00000050  01 02 02 09 00 85 b0 bb  a4 8a 7f b8 ca 30 0d 06  |.............0..|\n-00000060  09 2a 86 48 86 f7 0d 01  01 05 05 00 30 45 31 0b  |.*.H........0E1.|\n-00000070  30 09 06 03 55 04 06 13  02 41 55 31 13 30 11 06  |0...U....AU1.0..|\n-00000080  03 55 04 08 13 0a 53 6f  6d 65 2d 53 74 61 74 65  |.U....Some-State|\n-00000090  31 21 30 1f 06 03 55 04  0a 13 18 49 6e 74 65 72  |1!0...U....Inter|\n-000000a0  6e 65 74 20 57 69 64 67  69 74 73 20 50 74 79 20  |net Widgits Pty |\n-000000b0  4c 74 64 30 1e 17 0d 31  30 30 34 32 34 30 39 30  |Ltd0...100424090|\n-000000c0  39 33 38 5a 17 0d 31 31  30 34 32 34 30 39 30 39  |938Z..1104240909|\n-000000d0  33 38 5a 30 45 31 0b 30  09 06 03 55 04 06 13 02  |38Z0E1.0...U....|\n-000000e0  41 55 31 13 30 11 06 03  55 04 08 13 0a 53 6f 6d  |AU1.0...U....Som|\n-000000f0  65 2d 53 74 61 74 65 31  21 30 1f 06 03 55 04 0a  |e-State1!0...U..|\n-00000100  13 18 49 6e 74 65 72 6e  65 74 20 57 69 64 67 69  |..Internet Widgi|\n-00000110  74 73 20 50 74 79 20 4c  74 64 30 81 9f 30 0d 06  |ts Pty Ltd0..0..|\n-00000120  09 2a 86 48 86 f7 0d 01  01 01 05 00 03 81 8d 00  |.*.H............|\n-00000130  30 81 89 02 81 81 00 bb  79 d6 f5 17 b5 e5 bf 46  |0.......y......F|\n-00000140  10 d0 dc 69 be e6 2b 07  43 5a d0 03 2d 8a 7a 43  |...i..+.CZ..-.zC|\n-00000150  85 b7 14 52 e7 a5 65 4c  2c 78 b8 23 8c b5 b4 82  |...R..eL,x.#....|\n-00000160  e5 de 1f 95 3b 7e 62 a5  2c a5 33 d6 fe 12 5c 7a  |....;~b.,.3...\\z|\n-00000170  56 fc f5 06 bf fa 58 7b  26 3f b5 cd 04 d3 d0 c9  |V.....X{&?......|\n-00000180  21 96 4a c7 f4 54 9f 5a  bf ef 42 71 00 fe 18 99  |!.J..T.Z..Bq....|\n-00000190  07 7f 7e 88 7d 7d f1 04  39 c4 a2 2e db 51 c9 7c  |..~.}}..9....Q.||\n-000001a0  e3 c0 4c 3b 32 66 01 cf  af b1 1d b8 71 9a 1d db  |..L;2f......q...|\n-000001b0  db 89 6b ae da 2d 79 02  03 01 00 01 a3 81 a7 30  |..k..-y........0|\n-000001c0  81 a4 30 1d 06 03 55 1d  0e 04 16 04 14 b1 ad e2  |..0...U.........|\n-000001d0  85 5a cf cb 28 db 69 ce  23 69 de d3 26 8e 18 88  |.Z..(.i.#i..&...|\n-000001e0  39 30 75 06 03 55 1d 23  04 6e 30 6c 80 14 b1 ad  |90u..U.#.n0l....|\n-000001f0  e2 85 5a cf cb 28 db 69  ce 23 69 de d3 26 8e 18  |..Z..(.i.#i..&..|\n-00000200  88 39 a1 49 a4 47 30 45  31 0b 30 09 06 03 55 04  |.9.I.G0E1.0...U.|\n-00000210  06 13 02 41 55 31 13 30  11 06 03 55 04 08 13 0a  |...AU1.0...U....|\n-00000220  53 6f 6d 65 2d 53 74 61  74 65 31 21 30 1f 06 03  |Some-State1!0...|\n-00000230  55 04 0a 13 18 49 6e 74  65 72 6e 65 74 20 57 69  |U....Internet Wi|\n-00000240  64 67 69 74 73 20 50 74  79 20 4c 74 64 82 09 00  |dgits Pty Ltd...|\n-00000250  85 b0 bb a4 8a 7f b8 ca  30 0c 06 03 55 1d 13 04  |........0...U...|\n-00000260  05 30 03 01 01 ff 30 0d  06 09 2a 86 48 86 f7 0d  |.0....0...*.H...|\n-00000270  01 01 05 05 00 03 81 81  00 08 6c 45 24 c7 6b b1  |..........lE$.k.|\n-00000280  59 ab 0c 52 cc f2 b0 14  d7 87 9d 7a 64 75 b5 5a  |Y..R.......zdu.Z|\n-00000290  95 66 e4 c5 2b 8e ae 12  66 1f eb 4f 38 b3 6e 60  |.f..+...f..O8.n`|\n-000002a0  d3 92 fd f7 41 08 b5 25  13 b1 18 7a 24 fb 30 1d  |....A..%...z$.0.|\n-000002b0  ba ed 98 b9 17 ec e7 d7  31 59 db 95 d3 1d 78 ea  |........1Y....x.|\n-000002c0  50 56 5c d5 82 5a 2d 5a  5f 33 c4 b6 d8 c9 75 90  |PV\\..Z-Z_3....u.|\n-000002d0  96 8c 0f 52 98 b5 cd 98  1f 89 20 5f f2 a0 1c a3  |...R...... _....|\n-000002e0  1b 96 94 dd a9 fd 57 e9  70 e8 26 6d 71 99 9b 26  |......W.p.&mq..&|\n-000002f0  6e 38 50 29 6c 90 a7 bd  d9 16 03 03 00 04 0e 00  |n8P)l...........|\n-00000300  00 00                                             |..|\n->>> Flow 3 (client to server)\n-00000000  16 03 03 00 86 10 00 00  82 00 80 ae 02 dd 1f 1a  |................|\n-00000010  86 83 f5 2f 82 46 4b 29  58 aa a1 b3 56 8b 4e 40  |.../.FK)X...V.N@|\n-00000020  ef 23 65 67 ad 48 e5 e1  fd ae dd bf 68 fd bd a6  |.#eg.H......h...|\n-00000030  13 a0 7e 05 ab f7 20 e1  6a 4e d1 37 93 08 1d c9  |..~... .jN.7....|\n-00000040  37 e0 b5 34 28 bf 20 45  45 da 0f 7e 51 a7 c6 ae  |7..4(. EE..~Q...|\n-00000050  61 6c 07 1b 73 ef da 6e  25 c4 ed be e3 3f da ae  |al..s..n%....?..|\n-00000060  cd 3c 17 9c 2e ee fb 47  9d b3 a1 b2 c3 5d e0 83  |.<.....G.....]..|\n-00000070  74 20 37 2d 72 d6 d0 4d  58 0e 26 1c 50 22 95 08  |t 7-r..MX.&.P\"..|\n-00000080  7d e0 5f 86 99 9e 2c 2e  a7 a0 7f 14 03 03 00 01  |}._...,.........|\n-00000090  01 16 03 03 00 24 a2 ab  41 25 a5 cf 04 18 1d 98  |.....$..A%......|\n-000000a0  88 6c 59 21 86 33 54 f4  35 b4 21 6e a5 29 d5 6e  |.lY!.3T.5.!n.).n|\n-000000b0  3d 08 72 b0 af 46 b5 8f  6b 86                    |=.r..F..k.|\n->>> Flow 4 (server to client)\n-00000000  14 03 03 00 01 01 16 03  03 00 24 59 20 4d c2 17  |..........$Y M..|\n-00000010  8b 3c 9b 33 d9 f9 ef fb  80 18 1f 67 a7 58 12 89  |.<.3.......g.X..|\n-00000020  4e 73 0f 2d 7b e6 c4 a6  79 73 01 da 22 e8 54 17  |Ns.-{...ys..\".T.|\n-00000030  03 03 00 21 36 ca 64 0f  4a 12 a5 50 3d 97 bb 39  |...!6.d.J..P=..9|\n-00000040  02 fc ed d1 82 6a 9a 2e  21 79 f6 e1 b3 cc 32 db  |.....j..!y....2.|\n-00000050  0f 5d b3 fb a5 15 03 03  00 16 51 f4 be 57 7a df  |.]........Q..Wz.|\n-00000060  f1 f2 bd b5 51 5e 45 80  be 0b 9a 0c d1 19 3c 79  |....Q^E.......<y|"}, {"sha": "e82579eee9f638ca9bee8aabdef818996b89d0b3", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -5,6 +5,7 @@\n package tls\n \n import (\n+\t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n \t\"net\"\n@@ -235,3 +236,47 @@ func testConnReadNonzeroAndEOF(t *testing.T, delay time.Duration) error {\n \t}\n \treturn nil\n }\n+\n+func TestTLSUniqueMatches(t *testing.T) {\n+\tln := newLocalListener(t)\n+\tdefer ln.Close()\n+\n+\tserverTLSUniques := make(chan []byte)\n+\tgo func() {\n+\t\tfor i := 0; i < 2; i++ {\n+\t\t\tsconn, err := ln.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tserverConfig := *testConfig\n+\t\t\tsrv := Server(sconn, &serverConfig)\n+\t\t\tif err := srv.Handshake(); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tserverTLSUniques <- srv.ConnectionState().TLSUnique\n+\t\t}\n+\t}()\n+\n+\tclientConfig := *testConfig\n+\tclientConfig.ClientSessionCache = NewLRUClientSessionCache(1)\n+\tconn, err := Dial(\"tcp\", ln.Addr().String(), &clientConfig)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !bytes.Equal(conn.ConnectionState().TLSUnique, <-serverTLSUniques) {\n+\t\tt.Error(\"client and server channel bindings differ\")\n+\t}\n+\tconn.Close()\n+\n+\tconn, err = Dial(\"tcp\", ln.Addr().String(), &clientConfig)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer conn.Close()\n+\tif !conn.ConnectionState().DidResume {\n+\t\tt.Error(\"second session did not use resumption\")\n+\t}\n+\tif !bytes.Equal(conn.ConnectionState().TLSUnique, <-serverTLSUniques) {\n+\t\tt.Error(\"client and server channel bindings differ when session resumption is used\")\n+\t}\n+}"}, {"sha": "13e4700bddade6007081b4ac0d20e8aa1d064178", "filename": "libgo/go/crypto/x509/pem_decrypt_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpem_decrypt_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -14,7 +14,7 @@ import (\n \n func TestDecrypt(t *testing.T) {\n \tfor i, data := range testData {\n-\t\tt.Logf(\"test %d. %s\", i, data.kind)\n+\t\tt.Logf(\"test %v. %v\", i, data.kind)\n \t\tblock, rest := pem.Decode(data.pemData)\n \t\tif len(rest) > 0 {\n \t\t\tt.Error(\"extra data\")\n@@ -39,7 +39,7 @@ func TestDecrypt(t *testing.T) {\n \n func TestEncrypt(t *testing.T) {\n \tfor i, data := range testData {\n-\t\tt.Logf(\"test %d. %s\", i, data.kind)\n+\t\tt.Logf(\"test %v. %v\", i, data.kind)\n \t\tplainDER, err := base64.StdEncoding.DecodeString(data.plainDER)\n \t\tif err != nil {\n \t\t\tt.Fatal(\"cannot decode test DER data: \", err)"}, {"sha": "8768b785908a0a4f93c1a5f0b79b6ff53a2dd616", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -164,7 +164,7 @@ type TBSCertificateList struct {\n \tSignature           AlgorithmIdentifier\n \tIssuer              RDNSequence\n \tThisUpdate          time.Time\n-\tNextUpdate          time.Time\n+\tNextUpdate          time.Time            `asn1:\"optional\"`\n \tRevokedCertificates []RevokedCertificate `asn1:\"optional\"`\n \tExtensions          []Extension          `asn1:\"tag:0,optional,explicit\"`\n }"}, {"sha": "f77d6c0c57f79e386349801cb57ed2baa88e3c3c", "filename": "libgo/go/crypto/x509/root_unix.go", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -15,6 +15,15 @@ var certFiles = []string{\n \t\"/etc/ssl/ca-bundle.pem\",                 // OpenSUSE\n \t\"/etc/ssl/cert.pem\",                      // OpenBSD\n \t\"/usr/local/share/certs/ca-root-nss.crt\", // FreeBSD/DragonFly\n+\t\"/etc/pki/tls/cacert.pem\",                // OpenELEC\n+\t\"/etc/certs/ca-certificates.crt\",         // Solaris 11.2+\n+}\n+\n+// Possible directories with certificate files; stop after successfully\n+// reading at least one file from a directory.\n+var certDirectories = []string{\n+\t\"/system/etc/security/cacerts\", // Android\n+\n }\n \n func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {\n@@ -32,6 +41,24 @@ func initSystemRoots() {\n \t\t}\n \t}\n \n+\tfor _, directory := range certDirectories {\n+\t\tfis, err := ioutil.ReadDir(directory)\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\trootsAdded := false\n+\t\tfor _, fi := range fis {\n+\t\t\tdata, err := ioutil.ReadFile(directory + \"/\" + fi.Name())\n+\t\t\tif err == nil && roots.AppendCertsFromPEM(data) {\n+\t\t\t\trootsAdded = true\n+\t\t\t}\n+\t\t}\n+\t\tif rootsAdded {\n+\t\t\tsystemRoots = roots\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n \t// All of the files failed to load. systemRoots will be nil which will\n \t// trigger a specific error at verification time.\n }"}, {"sha": "ec1981423dba5af2c535bfd6199010bc7c8c63a8", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -116,10 +116,9 @@ func (e UnknownAuthorityError) Error() string {\n }\n \n // SystemRootsError results when we fail to load the system root certificates.\n-type SystemRootsError struct {\n-}\n+type SystemRootsError struct{}\n \n-func (e SystemRootsError) Error() string {\n+func (SystemRootsError) Error() string {\n \treturn \"x509: failed to load system roots and no roots provided\"\n }\n \n@@ -206,6 +205,9 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n // needed. If successful, it returns one or more chains where the first\n // element of the chain is c and the last element is from opts.Roots.\n //\n+// If opts.Roots is nil and system roots are unavailable the returned error\n+// will be of type SystemRootsError.\n+//\n // WARNING: this doesn't do any revocation checking.\n func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {\n \t// Use Windows's own verification and chain building."}, {"sha": "7a37b98e3179fc65119b0811bde6414f9cb7f332", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -494,6 +494,11 @@ type Certificate struct {\n \tBasicConstraintsValid bool // if true then the next two fields are valid.\n \tIsCA                  bool\n \tMaxPathLen            int\n+\t// MaxPathLenZero indicates that BasicConstraintsValid==true and\n+\t// MaxPathLen==0 should be interpreted as an actual maximum path length\n+\t// of zero. Otherwise, that combination is interpreted as MaxPathLen\n+\t// not being set.\n+\tMaxPathLenZero bool\n \n \tSubjectKeyId   []byte\n \tAuthorityKeyId []byte\n@@ -913,6 +918,7 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t\t\t\t\tout.BasicConstraintsValid = true\n \t\t\t\t\tout.IsCA = constraints.IsCA\n \t\t\t\t\tout.MaxPathLen = constraints.MaxPathLen\n+\t\t\t\t\tout.MaxPathLenZero = out.MaxPathLen == 0\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\tcase 17:\n@@ -1227,8 +1233,15 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t}\n \n \tif template.BasicConstraintsValid && !oidInExtensions(oidExtensionBasicConstraints, template.ExtraExtensions) {\n+\t\t// Leaving MaxPathLen as zero indicates that no maximum path\n+\t\t// length is desired, unless MaxPathLenZero is set. A value of\n+\t\t// -1 causes encoding/asn1 to omit the value as desired.\n+\t\tmaxPathLen := template.MaxPathLen\n+\t\tif maxPathLen == 0 && !template.MaxPathLenZero {\n+\t\t\tmaxPathLen = -1\n+\t\t}\n \t\tret[n].Id = oidExtensionBasicConstraints\n-\t\tret[n].Value, err = asn1.Marshal(basicConstraints{template.IsCA, template.MaxPathLen})\n+\t\tret[n].Value, err = asn1.Marshal(basicConstraints{template.IsCA, maxPathLen})\n \t\tret[n].Critical = true\n \t\tif err != nil {\n \t\t\treturn\n@@ -1328,7 +1341,7 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \n \t\t\tdp := distributionPoint{\n \t\t\t\tDistributionPoint: distributionPointName{\n-\t\t\t\t\tFullName: asn1.RawValue{Tag: 0, Class: 2, Bytes: rawFullName},\n+\t\t\t\t\tFullName: asn1.RawValue{Tag: 0, Class: 2, IsCompound: true, Bytes: rawFullName},\n \t\t\t\t},\n \t\t\t}\n \t\t\tcrlDp = append(crlDp, dp)\n@@ -1657,7 +1670,7 @@ var oidExtensionRequest = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 9, 14}\n \n // CreateCertificateRequest creates a new certificate based on a template. The\n // following members of template are used: Subject, Attributes,\n-// SignatureAlgorithm, Extension, DNSNames, EmailAddresses, and IPAddresses.\n+// SignatureAlgorithm, Extensions, DNSNames, EmailAddresses, and IPAddresses.\n // The private key is the private key of the signer.\n //\n // The returned slice is the certificate request in DER encoding."}, {"sha": "4f1f0c2cc698459f7d6e4d327b96dd39774575a8", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -707,6 +707,17 @@ func TestParseDERCRL(t *testing.T) {\n \t// Can't check the signature here without a package cycle.\n }\n \n+func TestCRLWithoutExpiry(t *testing.T) {\n+\tderBytes := fromBase64(\"MIHYMIGZMAkGByqGSM44BAMwEjEQMA4GA1UEAxMHQ2FybERTUxcNOTkwODI3MDcwMDAwWjBpMBMCAgDIFw05OTA4MjIwNzAwMDBaMBMCAgDJFw05OTA4MjIwNzAwMDBaMBMCAgDTFw05OTA4MjIwNzAwMDBaMBMCAgDSFw05OTA4MjIwNzAwMDBaMBMCAgDUFw05OTA4MjQwNzAwMDBaMAkGByqGSM44BAMDLwAwLAIUfmVSdjP+NHMX0feW+aDU2G1cfT0CFAJ6W7fVWxjBz4fvftok8yqDnDWh\")\n+\tcertList, err := ParseDERCRL(derBytes)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !certList.TBSCertList.NextUpdate.IsZero() {\n+\t\tt.Errorf(\"NextUpdate is not the zero value\")\n+\t}\n+}\n+\n func TestParsePEMCRL(t *testing.T) {\n \tpemBytes := fromBase64(pemCRLBase64)\n \tcertList, err := ParseCRL(pemBytes)\n@@ -729,8 +740,9 @@ func TestParsePEMCRL(t *testing.T) {\n \n func TestImports(t *testing.T) {\n \tt.Skip(\"gccgo does not have a go command\")\n-\tif runtime.GOOS == \"nacl\" {\n-\t\tt.Skip(\"skipping on nacl\")\n+\tswitch runtime.GOOS {\n+\tcase \"android\", \"nacl\":\n+\t\tt.Skipf(\"skipping on %s\", runtime.GOOS)\n \t}\n \n \tif err := exec.Command(\"go\", \"run\", \"x509_test_import.go\").Run(); err != nil {\n@@ -851,7 +863,7 @@ func TestCertificateRequestOverrides(t *testing.T) {\n \t\t// An explicit extension should override the DNSNames from the\n \t\t// template.\n \t\tExtraExtensions: []pkix.Extension{\n-\t\t\tpkix.Extension{\n+\t\t\t{\n \t\t\t\tId:    oidExtensionSubjectAltName,\n \t\t\t\tValue: sanContents,\n \t\t\t},\n@@ -869,11 +881,11 @@ func TestCertificateRequestOverrides(t *testing.T) {\n \t// with two extension attributes.\n \n \ttemplate.Attributes = []pkix.AttributeTypeAndValueSET{\n-\t\tpkix.AttributeTypeAndValueSET{\n+\t\t{\n \t\t\tType: oidExtensionRequest,\n \t\t\tValue: [][]pkix.AttributeTypeAndValue{\n-\t\t\t\t[]pkix.AttributeTypeAndValue{\n-\t\t\t\t\tpkix.AttributeTypeAndValue{\n+\t\t\t\t{\n+\t\t\t\t\t{\n \t\t\t\t\t\tType:  oidExtensionAuthorityInfoAccess,\n \t\t\t\t\t\tValue: []byte(\"foo\"),\n \t\t\t\t\t},\n@@ -942,6 +954,69 @@ func TestParseCertificateRequest(t *testing.T) {\n \t}\n }\n \n+func TestMaxPathLen(t *testing.T) {\n+\tblock, _ := pem.Decode([]byte(pemPrivateKey))\n+\trsaPriv, err := ParsePKCS1PrivateKey(block.Bytes)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to parse private key: %s\", err)\n+\t}\n+\n+\ttemplate := &Certificate{\n+\t\tSerialNumber: big.NewInt(1),\n+\t\tSubject: pkix.Name{\n+\t\t\tCommonName: \"\u03a3 Acme Co\",\n+\t\t},\n+\t\tNotBefore: time.Unix(1000, 0),\n+\t\tNotAfter:  time.Unix(100000, 0),\n+\n+\t\tBasicConstraintsValid: true,\n+\t\tIsCA: true,\n+\t}\n+\n+\tserialiseAndParse := func(template *Certificate) *Certificate {\n+\t\tderBytes, err := CreateCertificate(rand.Reader, template, template, &rsaPriv.PublicKey, rsaPriv)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to create certificate: %s\", err)\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tcert, err := ParseCertificate(derBytes)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to parse certificate: %s\", err)\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn cert\n+\t}\n+\n+\tcert1 := serialiseAndParse(template)\n+\tif m := cert1.MaxPathLen; m != -1 {\n+\t\tt.Errorf(\"Omitting MaxPathLen didn't turn into -1, got %d\", m)\n+\t}\n+\tif cert1.MaxPathLenZero {\n+\t\tt.Errorf(\"Omitting MaxPathLen resulted in MaxPathLenZero\")\n+\t}\n+\n+\ttemplate.MaxPathLen = 1\n+\tcert2 := serialiseAndParse(template)\n+\tif m := cert2.MaxPathLen; m != 1 {\n+\t\tt.Errorf(\"Setting MaxPathLen didn't work. Got %d but set 1\", m)\n+\t}\n+\tif cert2.MaxPathLenZero {\n+\t\tt.Errorf(\"Setting MaxPathLen resulted in MaxPathLenZero\")\n+\t}\n+\n+\ttemplate.MaxPathLen = 0\n+\ttemplate.MaxPathLenZero = true\n+\tcert3 := serialiseAndParse(template)\n+\tif m := cert3.MaxPathLen; m != 0 {\n+\t\tt.Errorf(\"Setting MaxPathLenZero didn't work, got %d\", m)\n+\t}\n+\tif !cert3.MaxPathLenZero {\n+\t\tt.Errorf(\"Setting MaxPathLen to zero didn't result in MaxPathLenZero\")\n+\t}\n+}\n+\n // This CSR was generated with OpenSSL:\n //  openssl req -out CSR.csr -new -newkey rsa:2048 -nodes -keyout privateKey.key -config openssl.cnf\n //"}, {"sha": "98af9fb64c58ba39dcadfe9ae2b1e7e6eeb37ea1", "filename": "libgo/go/database/sql/convert_test.go", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -283,6 +283,26 @@ func TestValueConverters(t *testing.T) {\n \n // Tests that assigning to RawBytes doesn't allocate (and also works).\n func TestRawBytesAllocs(t *testing.T) {\n+\tvar tests = []struct {\n+\t\tname string\n+\t\tin   interface{}\n+\t\twant string\n+\t}{\n+\t\t{\"uint64\", uint64(12345678), \"12345678\"},\n+\t\t{\"uint32\", uint32(1234), \"1234\"},\n+\t\t{\"uint16\", uint16(12), \"12\"},\n+\t\t{\"uint8\", uint8(1), \"1\"},\n+\t\t{\"uint\", uint(123), \"123\"},\n+\t\t{\"int\", int(123), \"123\"},\n+\t\t{\"int8\", int8(1), \"1\"},\n+\t\t{\"int16\", int16(12), \"12\"},\n+\t\t{\"int32\", int32(1234), \"1234\"},\n+\t\t{\"int64\", int64(12345678), \"12345678\"},\n+\t\t{\"float32\", float32(1.5), \"1.5\"},\n+\t\t{\"float64\", float64(64), \"64\"},\n+\t\t{\"bool\", false, \"false\"},\n+\t}\n+\n \tbuf := make(RawBytes, 10)\n \ttest := func(name string, in interface{}, want string) {\n \t\tif err := convertAssign(&buf, in); err != nil {\n@@ -301,20 +321,11 @@ func TestRawBytesAllocs(t *testing.T) {\n \t\t\tt.Fatalf(\"%s: got %q (len %d); want %q (len %d)\", name, buf, len(buf), want, len(want))\n \t\t}\n \t}\n+\n \tn := testing.AllocsPerRun(100, func() {\n-\t\ttest(\"uint64\", uint64(12345678), \"12345678\")\n-\t\ttest(\"uint32\", uint32(1234), \"1234\")\n-\t\ttest(\"uint16\", uint16(12), \"12\")\n-\t\ttest(\"uint8\", uint8(1), \"1\")\n-\t\ttest(\"uint\", uint(123), \"123\")\n-\t\ttest(\"int\", int(123), \"123\")\n-\t\ttest(\"int8\", int8(1), \"1\")\n-\t\ttest(\"int16\", int16(12), \"12\")\n-\t\ttest(\"int32\", int32(1234), \"1234\")\n-\t\ttest(\"int64\", int64(12345678), \"12345678\")\n-\t\ttest(\"float32\", float32(1.5), \"1.5\")\n-\t\ttest(\"float64\", float64(64), \"64\")\n-\t\ttest(\"bool\", false, \"false\")\n+\t\tfor _, tt := range tests {\n+\t\t\ttest(tt.name, tt.in, tt.want)\n+\t\t}\n \t})\n \n \t// The numbers below are only valid for 64-bit interface word sizes,"}, {"sha": "a993fd46ede488938419a84ea6c112b6e321a6cb", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"log\"\n+\t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n@@ -126,6 +127,29 @@ func init() {\n \tRegister(\"test\", fdriver)\n }\n \n+func contains(list []string, y string) bool {\n+\tfor _, x := range list {\n+\t\tif x == y {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+type Dummy struct {\n+\tdriver.Driver\n+}\n+\n+func TestDrivers(t *testing.T) {\n+\tunregisterAllDrivers()\n+\tRegister(\"test\", fdriver)\n+\tRegister(\"invalid\", Dummy{})\n+\tall := Drivers()\n+\tif len(all) < 2 || !sort.StringsAreSorted(all) || !contains(all, \"test\") || !contains(all, \"invalid\") {\n+\t\tt.Fatalf(\"Drivers = %v, want sorted list with at least [invalid, test]\", all)\n+\t}\n+}\n+\n // Supports dsn forms:\n //    <dbname>\n //    <dbname>;<opts>  (only currently supported option is `badConn`,"}, {"sha": "6e6f246aeecb745d6f7c567dfac6323073949dcf", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 135, "deletions": 85, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -13,12 +13,12 @@\n package sql\n \n import (\n-\t\"container/list\"\n \t\"database/sql/driver\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"runtime\"\n+\t\"sort\"\n \t\"sync\"\n )\n \n@@ -37,6 +37,21 @@ func Register(name string, driver driver.Driver) {\n \tdrivers[name] = driver\n }\n \n+func unregisterAllDrivers() {\n+\t// For tests.\n+\tdrivers = make(map[string]driver.Driver)\n+}\n+\n+// Drivers returns a sorted list of the names of the registered drivers.\n+func Drivers() []string {\n+\tvar list []string\n+\tfor name := range drivers {\n+\t\tlist = append(list, name)\n+\t}\n+\tsort.Strings(list)\n+\treturn list\n+}\n+\n // RawBytes is a byte slice that holds a reference to memory owned by\n // the database itself. After a Scan into a RawBytes, the slice is only\n // valid until the next call to Next, Scan, or Close.\n@@ -198,8 +213,8 @@ type DB struct {\n \tdsn    string\n \n \tmu           sync.Mutex // protects following fields\n-\tfreeConn     *list.List // of *driverConn\n-\tconnRequests *list.List // of connRequest\n+\tfreeConn     []*driverConn\n+\tconnRequests []chan connRequest\n \tnumOpen      int\n \tpendingOpens int\n \t// Used to signal the need for new connections\n@@ -232,9 +247,6 @@ type driverConn struct {\n \tinUse      bool\n \tonPut      []func() // code (with db.mu held) run when conn is next returned\n \tdbmuClosed bool     // same as closed, but guarded by db.mu, for connIfFree\n-\t// This is the Element returned by db.freeConn.PushFront(conn).\n-\t// It's used by connIfFree to remove the conn from the freeConn list.\n-\tlistElem *list.Element\n }\n \n func (dc *driverConn) releaseConn(err error) {\n@@ -437,8 +449,6 @@ func Open(driverName, dataSourceName string) (*DB, error) {\n \t\topenerCh: make(chan struct{}, connectionRequestQueueSize),\n \t\tlastPut:  make(map[*driverConn]string),\n \t}\n-\tdb.freeConn = list.New()\n-\tdb.connRequests = list.New()\n \tgo db.connectionOpener()\n \treturn db, nil\n }\n@@ -469,17 +479,13 @@ func (db *DB) Close() error {\n \t}\n \tclose(db.openerCh)\n \tvar err error\n-\tfns := make([]func() error, 0, db.freeConn.Len())\n-\tfor db.freeConn.Front() != nil {\n-\t\tdc := db.freeConn.Front().Value.(*driverConn)\n-\t\tdc.listElem = nil\n+\tfns := make([]func() error, 0, len(db.freeConn))\n+\tfor _, dc := range db.freeConn {\n \t\tfns = append(fns, dc.closeDBLocked())\n-\t\tdb.freeConn.Remove(db.freeConn.Front())\n \t}\n+\tdb.freeConn = nil\n \tdb.closed = true\n-\tfor db.connRequests.Front() != nil {\n-\t\treq := db.connRequests.Front().Value.(connRequest)\n-\t\tdb.connRequests.Remove(db.connRequests.Front())\n+\tfor _, req := range db.connRequests {\n \t\tclose(req)\n \t}\n \tdb.mu.Unlock()\n@@ -527,11 +533,11 @@ func (db *DB) SetMaxIdleConns(n int) {\n \t\tdb.maxIdle = db.maxOpen\n \t}\n \tvar closing []*driverConn\n-\tfor db.freeConn.Len() > db.maxIdleConnsLocked() {\n-\t\tdc := db.freeConn.Back().Value.(*driverConn)\n-\t\tdc.listElem = nil\n-\t\tdb.freeConn.Remove(db.freeConn.Back())\n-\t\tclosing = append(closing, dc)\n+\tidleCount := len(db.freeConn)\n+\tmaxIdle := db.maxIdleConnsLocked()\n+\tif idleCount > maxIdle {\n+\t\tclosing = db.freeConn[maxIdle:]\n+\t\tdb.freeConn = db.freeConn[:maxIdle]\n \t}\n \tdb.mu.Unlock()\n \tfor _, c := range closing {\n@@ -564,7 +570,7 @@ func (db *DB) SetMaxOpenConns(n int) {\n // If there are connRequests and the connection limit hasn't been reached,\n // then tell the connectionOpener to open new connections.\n func (db *DB) maybeOpenNewConnections() {\n-\tnumRequests := db.connRequests.Len() - db.pendingOpens\n+\tnumRequests := len(db.connRequests) - db.pendingOpens\n \tif db.maxOpen > 0 {\n \t\tnumCanOpen := db.maxOpen - (db.numOpen + db.pendingOpens)\n \t\tif numRequests > numCanOpen {\n@@ -580,7 +586,7 @@ func (db *DB) maybeOpenNewConnections() {\n \n // Runs in a separate goroutine, opens new connections when requested.\n func (db *DB) connectionOpener() {\n-\tfor _ = range db.openerCh {\n+\tfor range db.openerCh {\n \t\tdb.openNewConnection()\n \t}\n }\n@@ -616,7 +622,10 @@ func (db *DB) openNewConnection() {\n // connRequest represents one request for a new connection\n // When there are no idle connections available, DB.conn will create\n // a new connRequest and put it on the db.connRequests list.\n-type connRequest chan<- interface{} // takes either a *driverConn or an error\n+type connRequest struct {\n+\tconn *driverConn\n+\terr  error\n+}\n \n var errDBClosed = errors.New(\"sql: database is closed\")\n \n@@ -630,32 +639,21 @@ func (db *DB) conn() (*driverConn, error) {\n \n \t// If db.maxOpen > 0 and the number of open connections is over the limit\n \t// and there are no free connection, make a request and wait.\n-\tif db.maxOpen > 0 && db.numOpen >= db.maxOpen && db.freeConn.Len() == 0 {\n+\tif db.maxOpen > 0 && db.numOpen >= db.maxOpen && len(db.freeConn) == 0 {\n \t\t// Make the connRequest channel. It's buffered so that the\n \t\t// connectionOpener doesn't block while waiting for the req to be read.\n-\t\tch := make(chan interface{}, 1)\n-\t\treq := connRequest(ch)\n-\t\tdb.connRequests.PushBack(req)\n+\t\treq := make(chan connRequest, 1)\n+\t\tdb.connRequests = append(db.connRequests, req)\n \t\tdb.maybeOpenNewConnections()\n \t\tdb.mu.Unlock()\n-\t\tret, ok := <-ch\n-\t\tif !ok {\n-\t\t\treturn nil, errDBClosed\n-\t\t}\n-\t\tswitch ret.(type) {\n-\t\tcase *driverConn:\n-\t\t\treturn ret.(*driverConn), nil\n-\t\tcase error:\n-\t\t\treturn nil, ret.(error)\n-\t\tdefault:\n-\t\t\tpanic(\"sql: Unexpected type passed through connRequest.ch\")\n-\t\t}\n+\t\tret := <-req\n+\t\treturn ret.conn, ret.err\n \t}\n \n-\tif f := db.freeConn.Front(); f != nil {\n-\t\tconn := f.Value.(*driverConn)\n-\t\tconn.listElem = nil\n-\t\tdb.freeConn.Remove(f)\n+\tif c := len(db.freeConn); c > 0 {\n+\t\tconn := db.freeConn[0]\n+\t\tcopy(db.freeConn, db.freeConn[1:])\n+\t\tdb.freeConn = db.freeConn[:c-1]\n \t\tconn.inUse = true\n \t\tdb.mu.Unlock()\n \t\treturn conn, nil\n@@ -702,9 +700,15 @@ func (db *DB) connIfFree(wanted *driverConn) (*driverConn, error) {\n \tif wanted.inUse {\n \t\treturn nil, errConnBusy\n \t}\n-\tif wanted.listElem != nil {\n-\t\tdb.freeConn.Remove(wanted.listElem)\n-\t\twanted.listElem = nil\n+\tidx := -1\n+\tfor ii, v := range db.freeConn {\n+\t\tif v == wanted {\n+\t\t\tidx = ii\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif idx >= 0 {\n+\t\tdb.freeConn = append(db.freeConn[:idx], db.freeConn[idx+1:]...)\n \t\twanted.inUse = true\n \t\treturn wanted, nil\n \t}\n@@ -793,18 +797,23 @@ func (db *DB) putConn(dc *driverConn, err error) {\n // If a connRequest was fulfilled or the *driverConn was placed in the\n // freeConn list, then true is returned, otherwise false is returned.\n func (db *DB) putConnDBLocked(dc *driverConn, err error) bool {\n-\tif db.connRequests.Len() > 0 {\n-\t\treq := db.connRequests.Front().Value.(connRequest)\n-\t\tdb.connRequests.Remove(db.connRequests.Front())\n-\t\tif err != nil {\n-\t\t\treq <- err\n-\t\t} else {\n+\tif c := len(db.connRequests); c > 0 {\n+\t\treq := db.connRequests[0]\n+\t\t// This copy is O(n) but in practice faster than a linked list.\n+\t\t// TODO: consider compacting it down less often and\n+\t\t// moving the base instead?\n+\t\tcopy(db.connRequests, db.connRequests[1:])\n+\t\tdb.connRequests = db.connRequests[:c-1]\n+\t\tif err == nil {\n \t\t\tdc.inUse = true\n-\t\t\treq <- dc\n+\t\t}\n+\t\treq <- connRequest{\n+\t\t\tconn: dc,\n+\t\t\terr:  err,\n \t\t}\n \t\treturn true\n-\t} else if err == nil && !db.closed && db.maxIdleConnsLocked() > db.freeConn.Len() {\n-\t\tdc.listElem = db.freeConn.PushFront(dc)\n+\t} else if err == nil && !db.closed && db.maxIdleConnsLocked() > len(db.freeConn) {\n+\t\tdb.freeConn = append(db.freeConn, dc)\n \t\treturn true\n \t}\n \treturn false\n@@ -1050,6 +1059,13 @@ type Tx struct {\n \t// or Rollback. once done, all operations fail with\n \t// ErrTxDone.\n \tdone bool\n+\n+\t// All Stmts prepared for this transaction.  These will be closed after the\n+\t// transaction has been committed or rolled back.\n+\tstmts struct {\n+\t\tsync.Mutex\n+\t\tv []*Stmt\n+\t}\n }\n \n var ErrTxDone = errors.New(\"sql: Transaction has already been committed or rolled back\")\n@@ -1071,15 +1087,28 @@ func (tx *Tx) grabConn() (*driverConn, error) {\n \treturn tx.dc, nil\n }\n \n+// Closes all Stmts prepared for this transaction.\n+func (tx *Tx) closePrepared() {\n+\ttx.stmts.Lock()\n+\tfor _, stmt := range tx.stmts.v {\n+\t\tstmt.Close()\n+\t}\n+\ttx.stmts.Unlock()\n+}\n+\n // Commit commits the transaction.\n func (tx *Tx) Commit() error {\n \tif tx.done {\n \t\treturn ErrTxDone\n \t}\n \tdefer tx.close()\n \ttx.dc.Lock()\n-\tdefer tx.dc.Unlock()\n-\treturn tx.txi.Commit()\n+\terr := tx.txi.Commit()\n+\ttx.dc.Unlock()\n+\tif err != driver.ErrBadConn {\n+\t\ttx.closePrepared()\n+\t}\n+\treturn err\n }\n \n // Rollback aborts the transaction.\n@@ -1089,8 +1118,12 @@ func (tx *Tx) Rollback() error {\n \t}\n \tdefer tx.close()\n \ttx.dc.Lock()\n-\tdefer tx.dc.Unlock()\n-\treturn tx.txi.Rollback()\n+\terr := tx.txi.Rollback()\n+\ttx.dc.Unlock()\n+\tif err != driver.ErrBadConn {\n+\t\ttx.closePrepared()\n+\t}\n+\treturn err\n }\n \n // Prepare creates a prepared statement for use within a transaction.\n@@ -1134,6 +1167,9 @@ func (tx *Tx) Prepare(query string) (*Stmt, error) {\n \t\t},\n \t\tquery: query,\n \t}\n+\ttx.stmts.Lock()\n+\ttx.stmts.v = append(tx.stmts.v, stmt)\n+\ttx.stmts.Unlock()\n \treturn stmt, nil\n }\n \n@@ -1162,7 +1198,7 @@ func (tx *Tx) Stmt(stmt *Stmt) *Stmt {\n \tdc.Lock()\n \tsi, err := dc.ci.Prepare(stmt.query)\n \tdc.Unlock()\n-\treturn &Stmt{\n+\ttxs := &Stmt{\n \t\tdb: tx.db,\n \t\ttx: tx,\n \t\ttxsi: &driverStmt{\n@@ -1172,6 +1208,10 @@ func (tx *Tx) Stmt(stmt *Stmt) *Stmt {\n \t\tquery:     stmt.query,\n \t\tstickyErr: err,\n \t}\n+\ttx.stmts.Lock()\n+\ttx.stmts.v = append(tx.stmts.v, txs)\n+\ttx.stmts.Unlock()\n+\treturn txs\n }\n \n // Exec executes a query that doesn't return rows.\n@@ -1333,15 +1373,12 @@ func (s *Stmt) connStmt() (ci *driverConn, releaseConn func(error), si driver.St\n \t\treturn ci, releaseConn, s.txsi.si, nil\n \t}\n \n-\tvar cs connStmt\n-\tmatch := false\n \tfor i := 0; i < len(s.css); i++ {\n \t\tv := s.css[i]\n \t\t_, err := s.db.connIfFree(v.dc)\n \t\tif err == nil {\n-\t\t\tmatch = true\n-\t\t\tcs = v\n-\t\t\tbreak\n+\t\t\ts.mu.Unlock()\n+\t\t\treturn v.dc, v.dc.releaseConn, v.si, nil\n \t\t}\n \t\tif err == errConnClosed {\n \t\t\t// Lazily remove dead conn from our freelist.\n@@ -1353,28 +1390,41 @@ func (s *Stmt) connStmt() (ci *driverConn, releaseConn func(error), si driver.St\n \t}\n \ts.mu.Unlock()\n \n-\t// Make a new conn if all are busy.\n-\t// TODO(bradfitz): or wait for one? make configurable later?\n-\tif !match {\n-\t\tdc, err := s.db.conn()\n-\t\tif err != nil {\n-\t\t\treturn nil, nil, nil, err\n-\t\t}\n-\t\tdc.Lock()\n-\t\tsi, err := dc.prepareLocked(s.query)\n-\t\tdc.Unlock()\n-\t\tif err != nil {\n-\t\t\ts.db.putConn(dc, err)\n-\t\t\treturn nil, nil, nil, err\n+\t// If all connections are busy, either wait for one to become available (if\n+\t// we've already hit the maximum number of open connections) or create a\n+\t// new one.\n+\t//\n+\t// TODO(bradfitz): or always wait for one? make configurable later?\n+\tdc, err := s.db.conn()\n+\tif err != nil {\n+\t\treturn nil, nil, nil, err\n+\t}\n+\n+\t// Do another pass over the list to see whether this statement has\n+\t// already been prepared on the connection assigned to us.\n+\ts.mu.Lock()\n+\tfor _, v := range s.css {\n+\t\tif v.dc == dc {\n+\t\t\ts.mu.Unlock()\n+\t\t\treturn dc, dc.releaseConn, v.si, nil\n \t\t}\n-\t\ts.mu.Lock()\n-\t\tcs = connStmt{dc, si}\n-\t\ts.css = append(s.css, cs)\n-\t\ts.mu.Unlock()\n \t}\n+\ts.mu.Unlock()\n+\n+\t// No luck; we need to prepare the statement on this connection\n+\tdc.Lock()\n+\tsi, err = dc.prepareLocked(s.query)\n+\tdc.Unlock()\n+\tif err != nil {\n+\t\ts.db.putConn(dc, err)\n+\t\treturn nil, nil, nil, err\n+\t}\n+\ts.mu.Lock()\n+\tcs := connStmt{dc, si}\n+\ts.css = append(s.css, cs)\n+\ts.mu.Unlock()\n \n-\tconn := cs.dc\n-\treturn conn, conn.releaseConn, cs.si, nil\n+\treturn dc, dc.releaseConn, si, nil\n }\n \n // Query executes a prepared query statement with the given arguments"}, {"sha": "34efdf254c65309f9ea0c48a6921ff2a9add9f97", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -24,7 +24,14 @@ func init() {\n \t}\n \tfreedFrom := make(map[dbConn]string)\n \tputConnHook = func(db *DB, c *driverConn) {\n-\t\tif c.listElem != nil {\n+\t\tidx := -1\n+\t\tfor i, v := range db.freeConn {\n+\t\t\tif v == c {\n+\t\t\t\tidx = i\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif idx >= 0 {\n \t\t\t// print before panic, as panic may get lost due to conflicting panic\n \t\t\t// (all goroutines asleep) elsewhere, since we might not unlock\n \t\t\t// the mutex in freeConn here.\n@@ -79,15 +86,14 @@ func closeDB(t testing.TB, db *DB) {\n \t\t\tt.Errorf(\"Error closing fakeConn: %v\", err)\n \t\t}\n \t})\n-\tfor node, i := db.freeConn.Front(), 0; node != nil; node, i = node.Next(), i+1 {\n-\t\tdc := node.Value.(*driverConn)\n+\tfor i, dc := range db.freeConn {\n \t\tif n := len(dc.openStmt); n > 0 {\n \t\t\t// Just a sanity check. This is legal in\n \t\t\t// general, but if we make the tests clean up\n \t\t\t// their statements first, then we can safely\n \t\t\t// verify this is always zero here, and any\n \t\t\t// other value is a leak.\n-\t\t\tt.Errorf(\"while closing db, freeConn %d/%d had %d open stmts; want 0\", i, db.freeConn.Len(), n)\n+\t\t\tt.Errorf(\"while closing db, freeConn %d/%d had %d open stmts; want 0\", i, len(db.freeConn), n)\n \t\t}\n \t}\n \terr := db.Close()\n@@ -105,10 +111,10 @@ func closeDB(t testing.TB, db *DB) {\n // numPrepares assumes that db has exactly 1 idle conn and returns\n // its count of calls to Prepare\n func numPrepares(t *testing.T, db *DB) int {\n-\tif n := db.freeConn.Len(); n != 1 {\n+\tif n := len(db.freeConn); n != 1 {\n \t\tt.Fatalf(\"free conns = %d; want 1\", n)\n \t}\n-\treturn (db.freeConn.Front().Value.(*driverConn)).ci.(*fakeConn).numPrepare\n+\treturn db.freeConn[0].ci.(*fakeConn).numPrepare\n }\n \n func (db *DB) numDeps() int {\n@@ -133,7 +139,7 @@ func (db *DB) numDepsPollUntil(want int, d time.Duration) int {\n func (db *DB) numFreeConns() int {\n \tdb.mu.Lock()\n \tdefer db.mu.Unlock()\n-\treturn db.freeConn.Len()\n+\treturn len(db.freeConn)\n }\n \n func (db *DB) dumpDeps(t *testing.T) {\n@@ -435,6 +441,33 @@ func TestExec(t *testing.T) {\n \t}\n }\n \n+func TestTxPrepare(t *testing.T) {\n+\tdb := newTestDB(t, \"\")\n+\tdefer closeDB(t, db)\n+\texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n+\ttx, err := db.Begin()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Begin = %v\", err)\n+\t}\n+\tstmt, err := tx.Prepare(\"INSERT|t1|name=?,age=?\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stmt, err = %v, %v\", stmt, err)\n+\t}\n+\tdefer stmt.Close()\n+\t_, err = stmt.Exec(\"Bobby\", 7)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Exec = %v\", err)\n+\t}\n+\terr = tx.Commit()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Commit = %v\", err)\n+\t}\n+\t// Commit() should have closed the statement\n+\tif !stmt.closed {\n+\t\tt.Fatal(\"Stmt not closed after Commit\")\n+\t}\n+}\n+\n func TestTxStmt(t *testing.T) {\n \tdb := newTestDB(t, \"\")\n \tdefer closeDB(t, db)\n@@ -458,6 +491,10 @@ func TestTxStmt(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"Commit = %v\", err)\n \t}\n+\t// Commit() should have closed the statement\n+\tif !txs.closed {\n+\t\tt.Fatal(\"Stmt not closed after Commit\")\n+\t}\n }\n \n // Issue: http://golang.org/issue/2784\n@@ -650,10 +687,10 @@ func TestQueryRowClosingStmt(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tif db.freeConn.Len() != 1 {\n+\tif len(db.freeConn) != 1 {\n \t\tt.Fatalf(\"expected 1 free conn\")\n \t}\n-\tfakeConn := (db.freeConn.Front().Value.(*driverConn)).ci.(*fakeConn)\n+\tfakeConn := db.freeConn[0].ci.(*fakeConn)\n \tif made, closed := fakeConn.stmtsMade, fakeConn.stmtsClosed; made != closed {\n \t\tt.Errorf(\"statement close mismatch: made %d, closed %d\", made, closed)\n \t}\n@@ -878,13 +915,13 @@ func TestMaxIdleConns(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \ttx.Commit()\n-\tif got := db.freeConn.Len(); got != 1 {\n+\tif got := len(db.freeConn); got != 1 {\n \t\tt.Errorf(\"freeConns = %d; want 1\", got)\n \t}\n \n \tdb.SetMaxIdleConns(0)\n \n-\tif got := db.freeConn.Len(); got != 0 {\n+\tif got := len(db.freeConn); got != 0 {\n \t\tt.Errorf(\"freeConns after set to zero = %d; want 0\", got)\n \t}\n \n@@ -893,7 +930,7 @@ func TestMaxIdleConns(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \ttx.Commit()\n-\tif got := db.freeConn.Len(); got != 0 {\n+\tif got := len(db.freeConn); got != 0 {\n \t\tt.Errorf(\"freeConns = %d; want 0\", got)\n \t}\n }\n@@ -1180,10 +1217,10 @@ func TestCloseConnBeforeStmts(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \n-\tif db.freeConn.Len() != 1 {\n-\t\tt.Fatalf(\"expected 1 freeConn; got %d\", db.freeConn.Len())\n+\tif len(db.freeConn) != 1 {\n+\t\tt.Fatalf(\"expected 1 freeConn; got %d\", len(db.freeConn))\n \t}\n-\tdc := db.freeConn.Front().Value.(*driverConn)\n+\tdc := db.freeConn[0]\n \tif dc.closed {\n \t\tt.Errorf(\"conn shouldn't be closed\")\n \t}\n@@ -1342,16 +1379,19 @@ func TestErrBadConnReconnect(t *testing.T) {\n \t\treturn nil\n \t})\n \n+\t// Provide a way to force a re-prepare of a statement on next execution\n+\tforcePrepare := func(stmt *Stmt) {\n+\t\tstmt.css = nil\n+\t}\n+\n \t// stmt.Exec\n \tstmt1, err := db.Prepare(\"INSERT|t1|name=?,age=?,dead=?\")\n \tif err != nil {\n \t\tt.Fatalf(\"prepare: %v\", err)\n \t}\n \tdefer stmt1.Close()\n \t// make sure we must prepare the stmt first\n-\tfor _, cs := range stmt1.css {\n-\t\tcs.dc.inUse = true\n-\t}\n+\tforcePrepare(stmt1)\n \n \tstmtExec := func() error {\n \t\t_, err := stmt1.Exec(\"Gopher\", 3, false)\n@@ -1367,9 +1407,7 @@ func TestErrBadConnReconnect(t *testing.T) {\n \t}\n \tdefer stmt2.Close()\n \t// make sure we must prepare the stmt first\n-\tfor _, cs := range stmt2.css {\n-\t\tcs.dc.inUse = true\n-\t}\n+\tforcePrepare(stmt2)\n \n \tstmtQuery := func() error {\n \t\trows, err := stmt2.Query()\n@@ -1708,7 +1746,7 @@ func doConcurrentTest(t testing.TB, ct concurrentTest) {\n \n \tfor i := 0; i < maxProcs*2; i++ {\n \t\tgo func() {\n-\t\t\tfor _ = range reqs {\n+\t\t\tfor range reqs {\n \t\t\t\terr := ct.test(t)\n \t\t\t\tif err != nil {\n \t\t\t\t\twg.Done()\n@@ -1750,7 +1788,7 @@ func manyConcurrentQueries(t testing.TB) {\n \n \tfor i := 0; i < maxProcs*2; i++ {\n \t\tgo func() {\n-\t\t\tfor _ = range reqs {\n+\t\t\tfor range reqs {\n \t\t\t\trows, err := stmt.Query()\n \t\t\t\tif err != nil {\n \t\t\t\t\tt.Errorf(\"error on query:  %v\", err)"}, {"sha": "6986b19e7221bb4043e2ea7cc819b81f00f0011b", "filename": "libgo/go/debug/dwarf/type.go", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -88,6 +88,11 @@ type AddrType struct {\n \tBasicType\n }\n \n+// An UnspecifiedType represents an implicit, unknown, ambiguous or nonexistent type.\n+type UnspecifiedType struct {\n+\tBasicType\n+}\n+\n // qualifiers\n \n // A QualType represents a type that has the C/C++ \"const\", \"restrict\", or \"volatile\" qualifier.\n@@ -113,7 +118,12 @@ func (t *ArrayType) String() string {\n \treturn \"[\" + strconv.FormatInt(t.Count, 10) + \"]\" + t.Type.String()\n }\n \n-func (t *ArrayType) Size() int64 { return t.Count * t.Type.Size() }\n+func (t *ArrayType) Size() int64 {\n+\tif t.Count == -1 {\n+\t\treturn 0\n+\t}\n+\treturn t.Count * t.Type.Size()\n+}\n \n // A VoidType represents the C void type.\n type VoidType struct {\n@@ -364,32 +374,36 @@ func (d *Data) readType(name string, r typeReader, off Offset, typeCache map[Off\n \t\tt.StrideBitSize, _ = e.Val(AttrStrideSize).(int64)\n \n \t\t// Accumulate dimensions,\n-\t\tndim := 0\n+\t\tvar dims []int64\n \t\tfor kid := next(); kid != nil; kid = next() {\n \t\t\t// TODO(rsc): Can also be TagEnumerationType\n \t\t\t// but haven't seen that in the wild yet.\n \t\t\tswitch kid.Tag {\n \t\t\tcase TagSubrangeType:\n-\t\t\t\tmax, ok := kid.Val(AttrUpperBound).(int64)\n+\t\t\t\tcount, ok := kid.Val(AttrCount).(int64)\n \t\t\t\tif !ok {\n-\t\t\t\t\tmax = -2 // Count == -1, as in x[].\n-\t\t\t\t}\n-\t\t\t\tif ndim == 0 {\n-\t\t\t\t\tt.Count = max + 1\n-\t\t\t\t} else {\n-\t\t\t\t\t// Multidimensional array.\n-\t\t\t\t\t// Create new array type underneath this one.\n-\t\t\t\t\tt.Type = &ArrayType{Type: t.Type, Count: max + 1}\n+\t\t\t\t\t// Old binaries may have an upper bound instead.\n+\t\t\t\t\tcount, ok = kid.Val(AttrUpperBound).(int64)\n+\t\t\t\t\tif ok {\n+\t\t\t\t\t\tcount++ // Length is one more than upper bound.\n+\t\t\t\t\t} else if len(dims) == 0 {\n+\t\t\t\t\t\tcount = -1 // As in x[].\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tndim++\n+\t\t\t\tdims = append(dims, count)\n \t\t\tcase TagEnumerationType:\n \t\t\t\terr = DecodeError{name, kid.Offset, \"cannot handle enumeration type as array bound\"}\n \t\t\t\tgoto Error\n \t\t\t}\n \t\t}\n-\t\tif ndim == 0 {\n+\t\tif len(dims) == 0 {\n \t\t\t// LLVM generates this for x[].\n-\t\t\tt.Count = -1\n+\t\t\tdims = []int64{-1}\n+\t\t}\n+\n+\t\tt.Count = dims[0]\n+\t\tfor i := len(dims) - 1; i >= 1; i-- {\n+\t\t\tt.Type = &ArrayType{Type: t.Type, Count: dims[i]}\n \t\t}\n \n \tcase TagBaseType:\n@@ -417,6 +431,17 @@ func (d *Data) readType(name string, r typeReader, off Offset, typeCache map[Off\n \t\t\ttyp = new(BoolType)\n \t\tcase encComplexFloat:\n \t\t\ttyp = new(ComplexType)\n+\t\t\tif name == \"complex\" {\n+\t\t\t\t// clang writes out 'complex' instead of 'complex float' or 'complex double'.\n+\t\t\t\t// clang also writes out a byte size that we can use to distinguish.\n+\t\t\t\t// See issue 8694.\n+\t\t\t\tswitch byteSize, _ := e.Val(AttrByteSize).(int64); byteSize {\n+\t\t\t\tcase 8:\n+\t\t\t\t\tname = \"complex float\"\n+\t\t\t\tcase 16:\n+\t\t\t\t\tname = \"complex double\"\n+\t\t\t\t}\n+\t\t\t}\n \t\tcase encFloat:\n \t\t\ttyp = new(FloatType)\n \t\tcase encSigned:\n@@ -465,7 +490,7 @@ func (d *Data) readType(name string, r typeReader, off Offset, typeCache map[Off\n \t\tt.StructName, _ = e.Val(AttrName).(string)\n \t\tt.Incomplete = e.Val(AttrDeclaration) != nil\n \t\tt.Field = make([]*StructField, 0, 8)\n-\t\tvar lastFieldType Type\n+\t\tvar lastFieldType *Type\n \t\tvar lastFieldBitOffset int64\n \t\tfor kid := next(); kid != nil; kid = next() {\n \t\t\tif kid.Tag == TagMember {\n@@ -507,7 +532,7 @@ func (d *Data) readType(name string, r typeReader, off Offset, typeCache map[Off\n \t\t\t\t\t// (DWARF writes out 0-length arrays as if they were 1-length arrays.)\n \t\t\t\t\tzeroArray(lastFieldType)\n \t\t\t\t}\n-\t\t\t\tlastFieldType = f.Type\n+\t\t\t\tlastFieldType = &f.Type\n \t\t\t\tlastFieldBitOffset = bito\n \t\t\t}\n \t\t}\n@@ -624,6 +649,15 @@ func (d *Data) readType(name string, r typeReader, off Offset, typeCache map[Off\n \t\ttypeCache[off] = t\n \t\tt.Name, _ = e.Val(AttrName).(string)\n \t\tt.Type = typeOf(e)\n+\n+\tcase TagUnspecifiedType:\n+\t\t// Unspecified type (DWARF v3 \u00a75.2)\n+\t\t// Attributes:\n+\t\t//\tAttrName: name\n+\t\tt := new(UnspecifiedType)\n+\t\ttyp = t\n+\t\ttypeCache[off] = t\n+\t\tt.Name, _ = e.Val(AttrName).(string)\n \t}\n \n \tif err != nil {\n@@ -647,13 +681,16 @@ Error:\n \treturn nil, err\n }\n \n-func zeroArray(t Type) {\n-\tfor {\n-\t\tat, ok := t.(*ArrayType)\n-\t\tif !ok {\n-\t\t\tbreak\n-\t\t}\n-\t\tat.Count = 0\n-\t\tt = at.Type\n+func zeroArray(t *Type) {\n+\tif t == nil {\n+\t\treturn\n+\t}\n+\tat, ok := (*t).(*ArrayType)\n+\tif !ok || at.Type.Size() == 0 {\n+\t\treturn\n \t}\n+\t// Make a copy to avoid invalidating typeCache.\n+\ttt := *at\n+\ttt.Count = 0\n+\t*t = &tt\n }"}, {"sha": "a9466bbdcd603f53af9fc230070605e6101617de", "filename": "libgo/go/debug/elf/elf.go", "status": "modified", "additions": 295, "deletions": 43, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -11,6 +11,7 @@\n  * $FreeBSD: src/sys/i386/include/elf.h,v 1.16 2004/08/02 19:12:17 dfr Exp $\n  * $FreeBSD: src/sys/powerpc/include/elf.h,v 1.7 2004/11/02 09:47:01 ssouhlal Exp $\n  * $FreeBSD: src/sys/sparc64/include/elf.h,v 1.12 2003/09/25 01:10:26 peter Exp $\n+ * \"ELF for the ARM\u00ae 64-bit Architecture (AArch64)\" (ARM IHI 0056B)\n  *\n  * Copyright (c) 1996-1998 John D. Polstra.  All rights reserved.\n  * Copyright (c) 2001 David E. O'Brien\n@@ -192,49 +193,50 @@ func (i Type) GoString() string { return stringName(uint32(i), typeStrings, true\n type Machine uint16\n \n const (\n-\tEM_NONE        Machine = 0  /* Unknown machine. */\n-\tEM_M32         Machine = 1  /* AT&T WE32100. */\n-\tEM_SPARC       Machine = 2  /* Sun SPARC. */\n-\tEM_386         Machine = 3  /* Intel i386. */\n-\tEM_68K         Machine = 4  /* Motorola 68000. */\n-\tEM_88K         Machine = 5  /* Motorola 88000. */\n-\tEM_860         Machine = 7  /* Intel i860. */\n-\tEM_MIPS        Machine = 8  /* MIPS R3000 Big-Endian only. */\n-\tEM_S370        Machine = 9  /* IBM System/370. */\n-\tEM_MIPS_RS3_LE Machine = 10 /* MIPS R3000 Little-Endian. */\n-\tEM_PARISC      Machine = 15 /* HP PA-RISC. */\n-\tEM_VPP500      Machine = 17 /* Fujitsu VPP500. */\n-\tEM_SPARC32PLUS Machine = 18 /* SPARC v8plus. */\n-\tEM_960         Machine = 19 /* Intel 80960. */\n-\tEM_PPC         Machine = 20 /* PowerPC 32-bit. */\n-\tEM_PPC64       Machine = 21 /* PowerPC 64-bit. */\n-\tEM_S390        Machine = 22 /* IBM System/390. */\n-\tEM_V800        Machine = 36 /* NEC V800. */\n-\tEM_FR20        Machine = 37 /* Fujitsu FR20. */\n-\tEM_RH32        Machine = 38 /* TRW RH-32. */\n-\tEM_RCE         Machine = 39 /* Motorola RCE. */\n-\tEM_ARM         Machine = 40 /* ARM. */\n-\tEM_SH          Machine = 42 /* Hitachi SH. */\n-\tEM_SPARCV9     Machine = 43 /* SPARC v9 64-bit. */\n-\tEM_TRICORE     Machine = 44 /* Siemens TriCore embedded processor. */\n-\tEM_ARC         Machine = 45 /* Argonaut RISC Core. */\n-\tEM_H8_300      Machine = 46 /* Hitachi H8/300. */\n-\tEM_H8_300H     Machine = 47 /* Hitachi H8/300H. */\n-\tEM_H8S         Machine = 48 /* Hitachi H8S. */\n-\tEM_H8_500      Machine = 49 /* Hitachi H8/500. */\n-\tEM_IA_64       Machine = 50 /* Intel IA-64 Processor. */\n-\tEM_MIPS_X      Machine = 51 /* Stanford MIPS-X. */\n-\tEM_COLDFIRE    Machine = 52 /* Motorola ColdFire. */\n-\tEM_68HC12      Machine = 53 /* Motorola M68HC12. */\n-\tEM_MMA         Machine = 54 /* Fujitsu MMA. */\n-\tEM_PCP         Machine = 55 /* Siemens PCP. */\n-\tEM_NCPU        Machine = 56 /* Sony nCPU. */\n-\tEM_NDR1        Machine = 57 /* Denso NDR1 microprocessor. */\n-\tEM_STARCORE    Machine = 58 /* Motorola Star*Core processor. */\n-\tEM_ME16        Machine = 59 /* Toyota ME16 processor. */\n-\tEM_ST100       Machine = 60 /* STMicroelectronics ST100 processor. */\n-\tEM_TINYJ       Machine = 61 /* Advanced Logic Corp. TinyJ processor. */\n-\tEM_X86_64      Machine = 62 /* Advanced Micro Devices x86-64 */\n+\tEM_NONE        Machine = 0   /* Unknown machine. */\n+\tEM_M32         Machine = 1   /* AT&T WE32100. */\n+\tEM_SPARC       Machine = 2   /* Sun SPARC. */\n+\tEM_386         Machine = 3   /* Intel i386. */\n+\tEM_68K         Machine = 4   /* Motorola 68000. */\n+\tEM_88K         Machine = 5   /* Motorola 88000. */\n+\tEM_860         Machine = 7   /* Intel i860. */\n+\tEM_MIPS        Machine = 8   /* MIPS R3000 Big-Endian only. */\n+\tEM_S370        Machine = 9   /* IBM System/370. */\n+\tEM_MIPS_RS3_LE Machine = 10  /* MIPS R3000 Little-Endian. */\n+\tEM_PARISC      Machine = 15  /* HP PA-RISC. */\n+\tEM_VPP500      Machine = 17  /* Fujitsu VPP500. */\n+\tEM_SPARC32PLUS Machine = 18  /* SPARC v8plus. */\n+\tEM_960         Machine = 19  /* Intel 80960. */\n+\tEM_PPC         Machine = 20  /* PowerPC 32-bit. */\n+\tEM_PPC64       Machine = 21  /* PowerPC 64-bit. */\n+\tEM_S390        Machine = 22  /* IBM System/390. */\n+\tEM_V800        Machine = 36  /* NEC V800. */\n+\tEM_FR20        Machine = 37  /* Fujitsu FR20. */\n+\tEM_RH32        Machine = 38  /* TRW RH-32. */\n+\tEM_RCE         Machine = 39  /* Motorola RCE. */\n+\tEM_ARM         Machine = 40  /* ARM. */\n+\tEM_SH          Machine = 42  /* Hitachi SH. */\n+\tEM_SPARCV9     Machine = 43  /* SPARC v9 64-bit. */\n+\tEM_TRICORE     Machine = 44  /* Siemens TriCore embedded processor. */\n+\tEM_ARC         Machine = 45  /* Argonaut RISC Core. */\n+\tEM_H8_300      Machine = 46  /* Hitachi H8/300. */\n+\tEM_H8_300H     Machine = 47  /* Hitachi H8/300H. */\n+\tEM_H8S         Machine = 48  /* Hitachi H8S. */\n+\tEM_H8_500      Machine = 49  /* Hitachi H8/500. */\n+\tEM_IA_64       Machine = 50  /* Intel IA-64 Processor. */\n+\tEM_MIPS_X      Machine = 51  /* Stanford MIPS-X. */\n+\tEM_COLDFIRE    Machine = 52  /* Motorola ColdFire. */\n+\tEM_68HC12      Machine = 53  /* Motorola M68HC12. */\n+\tEM_MMA         Machine = 54  /* Fujitsu MMA. */\n+\tEM_PCP         Machine = 55  /* Siemens PCP. */\n+\tEM_NCPU        Machine = 56  /* Sony nCPU. */\n+\tEM_NDR1        Machine = 57  /* Denso NDR1 microprocessor. */\n+\tEM_STARCORE    Machine = 58  /* Motorola Star*Core processor. */\n+\tEM_ME16        Machine = 59  /* Toyota ME16 processor. */\n+\tEM_ST100       Machine = 60  /* STMicroelectronics ST100 processor. */\n+\tEM_TINYJ       Machine = 61  /* Advanced Logic Corp. TinyJ processor. */\n+\tEM_X86_64      Machine = 62  /* Advanced Micro Devices x86-64 */\n+\tEM_AARCH64     Machine = 183 /* ARM 64-bit Architecture (AArch64) */\n \n \t/* Non-standard or deprecated. */\n \tEM_486         Machine = 6      /* Intel i486. */\n@@ -774,6 +776,256 @@ var rx86_64Strings = []intName{\n func (i R_X86_64) String() string   { return stringName(uint32(i), rx86_64Strings, false) }\n func (i R_X86_64) GoString() string { return stringName(uint32(i), rx86_64Strings, true) }\n \n+// Relocation types for AArch64 (aka arm64)\n+type R_AARCH64 int\n+\n+const (\n+\tR_AARCH64_NONE                            R_AARCH64 = 0\n+\tR_AARCH64_P32_ABS32                       R_AARCH64 = 1\n+\tR_AARCH64_P32_ABS16                       R_AARCH64 = 2\n+\tR_AARCH64_P32_PREL32                      R_AARCH64 = 3\n+\tR_AARCH64_P32_PREL16                      R_AARCH64 = 4\n+\tR_AARCH64_P32_MOVW_UABS_G0                R_AARCH64 = 5\n+\tR_AARCH64_P32_MOVW_UABS_G0_NC             R_AARCH64 = 6\n+\tR_AARCH64_P32_MOVW_UABS_G1                R_AARCH64 = 7\n+\tR_AARCH64_P32_MOVW_SABS_G0                R_AARCH64 = 8\n+\tR_AARCH64_P32_LD_PREL_LO19                R_AARCH64 = 9\n+\tR_AARCH64_P32_ADR_PREL_LO21               R_AARCH64 = 10\n+\tR_AARCH64_P32_ADR_PREL_PG_HI21            R_AARCH64 = 11\n+\tR_AARCH64_P32_ADD_ABS_LO12_NC             R_AARCH64 = 12\n+\tR_AARCH64_P32_LDST8_ABS_LO12_NC           R_AARCH64 = 13\n+\tR_AARCH64_P32_LDST16_ABS_LO12_NC          R_AARCH64 = 14\n+\tR_AARCH64_P32_LDST32_ABS_LO12_NC          R_AARCH64 = 15\n+\tR_AARCH64_P32_LDST64_ABS_LO12_NC          R_AARCH64 = 16\n+\tR_AARCH64_P32_LDST128_ABS_LO12_NC         R_AARCH64 = 17\n+\tR_AARCH64_P32_TSTBR14                     R_AARCH64 = 18\n+\tR_AARCH64_P32_CONDBR19                    R_AARCH64 = 19\n+\tR_AARCH64_P32_JUMP26                      R_AARCH64 = 20\n+\tR_AARCH64_P32_CALL26                      R_AARCH64 = 21\n+\tR_AARCH64_P32_GOT_LD_PREL19               R_AARCH64 = 25\n+\tR_AARCH64_P32_ADR_GOT_PAGE                R_AARCH64 = 26\n+\tR_AARCH64_P32_LD32_GOT_LO12_NC            R_AARCH64 = 27\n+\tR_AARCH64_P32_TLSGD_ADR_PAGE21            R_AARCH64 = 81\n+\tR_AARCH64_P32_TLSGD_ADD_LO12_NC           R_AARCH64 = 82\n+\tR_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21   R_AARCH64 = 103\n+\tR_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC R_AARCH64 = 104\n+\tR_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19    R_AARCH64 = 105\n+\tR_AARCH64_P32_TLSLE_MOVW_TPREL_G1         R_AARCH64 = 106\n+\tR_AARCH64_P32_TLSLE_MOVW_TPREL_G0         R_AARCH64 = 107\n+\tR_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC      R_AARCH64 = 108\n+\tR_AARCH64_P32_TLSLE_ADD_TPREL_HI12        R_AARCH64 = 109\n+\tR_AARCH64_P32_TLSLE_ADD_TPREL_LO12        R_AARCH64 = 110\n+\tR_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC     R_AARCH64 = 111\n+\tR_AARCH64_P32_TLSDESC_LD_PREL19           R_AARCH64 = 122\n+\tR_AARCH64_P32_TLSDESC_ADR_PREL21          R_AARCH64 = 123\n+\tR_AARCH64_P32_TLSDESC_ADR_PAGE21          R_AARCH64 = 124\n+\tR_AARCH64_P32_TLSDESC_LD32_LO12_NC        R_AARCH64 = 125\n+\tR_AARCH64_P32_TLSDESC_ADD_LO12_NC         R_AARCH64 = 126\n+\tR_AARCH64_P32_TLSDESC_CALL                R_AARCH64 = 127\n+\tR_AARCH64_P32_COPY                        R_AARCH64 = 180\n+\tR_AARCH64_P32_GLOB_DAT                    R_AARCH64 = 181\n+\tR_AARCH64_P32_JUMP_SLOT                   R_AARCH64 = 182\n+\tR_AARCH64_P32_RELATIVE                    R_AARCH64 = 183\n+\tR_AARCH64_P32_TLS_DTPMOD                  R_AARCH64 = 184\n+\tR_AARCH64_P32_TLS_DTPREL                  R_AARCH64 = 185\n+\tR_AARCH64_P32_TLS_TPREL                   R_AARCH64 = 186\n+\tR_AARCH64_P32_TLSDESC                     R_AARCH64 = 187\n+\tR_AARCH64_P32_IRELATIVE                   R_AARCH64 = 188\n+\tR_AARCH64_NULL                            R_AARCH64 = 256\n+\tR_AARCH64_ABS64                           R_AARCH64 = 257\n+\tR_AARCH64_ABS32                           R_AARCH64 = 258\n+\tR_AARCH64_ABS16                           R_AARCH64 = 259\n+\tR_AARCH64_PREL64                          R_AARCH64 = 260\n+\tR_AARCH64_PREL32                          R_AARCH64 = 261\n+\tR_AARCH64_PREL16                          R_AARCH64 = 262\n+\tR_AARCH64_MOVW_UABS_G0                    R_AARCH64 = 263\n+\tR_AARCH64_MOVW_UABS_G0_NC                 R_AARCH64 = 264\n+\tR_AARCH64_MOVW_UABS_G1                    R_AARCH64 = 265\n+\tR_AARCH64_MOVW_UABS_G1_NC                 R_AARCH64 = 266\n+\tR_AARCH64_MOVW_UABS_G2                    R_AARCH64 = 267\n+\tR_AARCH64_MOVW_UABS_G2_NC                 R_AARCH64 = 268\n+\tR_AARCH64_MOVW_UABS_G3                    R_AARCH64 = 269\n+\tR_AARCH64_MOVW_SABS_G0                    R_AARCH64 = 270\n+\tR_AARCH64_MOVW_SABS_G1                    R_AARCH64 = 271\n+\tR_AARCH64_MOVW_SABS_G2                    R_AARCH64 = 272\n+\tR_AARCH64_LD_PREL_LO19                    R_AARCH64 = 273\n+\tR_AARCH64_ADR_PREL_LO21                   R_AARCH64 = 274\n+\tR_AARCH64_ADR_PREL_PG_HI21                R_AARCH64 = 275\n+\tR_AARCH64_ADR_PREL_PG_HI21_NC             R_AARCH64 = 276\n+\tR_AARCH64_ADD_ABS_LO12_NC                 R_AARCH64 = 277\n+\tR_AARCH64_LDST8_ABS_LO12_NC               R_AARCH64 = 278\n+\tR_AARCH64_TSTBR14                         R_AARCH64 = 279\n+\tR_AARCH64_CONDBR19                        R_AARCH64 = 280\n+\tR_AARCH64_JUMP26                          R_AARCH64 = 282\n+\tR_AARCH64_CALL26                          R_AARCH64 = 283\n+\tR_AARCH64_LDST16_ABS_LO12_NC              R_AARCH64 = 284\n+\tR_AARCH64_LDST32_ABS_LO12_NC              R_AARCH64 = 285\n+\tR_AARCH64_LDST64_ABS_LO12_NC              R_AARCH64 = 286\n+\tR_AARCH64_LDST128_ABS_LO12_NC             R_AARCH64 = 299\n+\tR_AARCH64_GOT_LD_PREL19                   R_AARCH64 = 309\n+\tR_AARCH64_ADR_GOT_PAGE                    R_AARCH64 = 311\n+\tR_AARCH64_LD64_GOT_LO12_NC                R_AARCH64 = 312\n+\tR_AARCH64_TLSGD_ADR_PAGE21                R_AARCH64 = 513\n+\tR_AARCH64_TLSGD_ADD_LO12_NC               R_AARCH64 = 514\n+\tR_AARCH64_TLSIE_MOVW_GOTTPREL_G1          R_AARCH64 = 539\n+\tR_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC       R_AARCH64 = 540\n+\tR_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21       R_AARCH64 = 541\n+\tR_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC     R_AARCH64 = 542\n+\tR_AARCH64_TLSIE_LD_GOTTPREL_PREL19        R_AARCH64 = 543\n+\tR_AARCH64_TLSLE_MOVW_TPREL_G2             R_AARCH64 = 544\n+\tR_AARCH64_TLSLE_MOVW_TPREL_G1             R_AARCH64 = 545\n+\tR_AARCH64_TLSLE_MOVW_TPREL_G1_NC          R_AARCH64 = 546\n+\tR_AARCH64_TLSLE_MOVW_TPREL_G0             R_AARCH64 = 547\n+\tR_AARCH64_TLSLE_MOVW_TPREL_G0_NC          R_AARCH64 = 548\n+\tR_AARCH64_TLSLE_ADD_TPREL_HI12            R_AARCH64 = 549\n+\tR_AARCH64_TLSLE_ADD_TPREL_LO12            R_AARCH64 = 550\n+\tR_AARCH64_TLSLE_ADD_TPREL_LO12_NC         R_AARCH64 = 551\n+\tR_AARCH64_TLSDESC_LD_PREL19               R_AARCH64 = 560\n+\tR_AARCH64_TLSDESC_ADR_PREL21              R_AARCH64 = 561\n+\tR_AARCH64_TLSDESC_ADR_PAGE21              R_AARCH64 = 562\n+\tR_AARCH64_TLSDESC_LD64_LO12_NC            R_AARCH64 = 563\n+\tR_AARCH64_TLSDESC_ADD_LO12_NC             R_AARCH64 = 564\n+\tR_AARCH64_TLSDESC_OFF_G1                  R_AARCH64 = 565\n+\tR_AARCH64_TLSDESC_OFF_G0_NC               R_AARCH64 = 566\n+\tR_AARCH64_TLSDESC_LDR                     R_AARCH64 = 567\n+\tR_AARCH64_TLSDESC_ADD                     R_AARCH64 = 568\n+\tR_AARCH64_TLSDESC_CALL                    R_AARCH64 = 569\n+\tR_AARCH64_COPY                            R_AARCH64 = 1024\n+\tR_AARCH64_GLOB_DAT                        R_AARCH64 = 1025\n+\tR_AARCH64_JUMP_SLOT                       R_AARCH64 = 1026\n+\tR_AARCH64_RELATIVE                        R_AARCH64 = 1027\n+\tR_AARCH64_TLS_DTPMOD64                    R_AARCH64 = 1028\n+\tR_AARCH64_TLS_DTPREL64                    R_AARCH64 = 1029\n+\tR_AARCH64_TLS_TPREL64                     R_AARCH64 = 1030\n+\tR_AARCH64_TLSDESC                         R_AARCH64 = 1031\n+\tR_AARCH64_IRELATIVE                       R_AARCH64 = 1032\n+)\n+\n+var raarch64Strings = []intName{\n+\t{0, \"R_AARCH64_NONE\"},\n+\t{1, \"R_AARCH64_P32_ABS32\"},\n+\t{2, \"R_AARCH64_P32_ABS16\"},\n+\t{3, \"R_AARCH64_P32_PREL32\"},\n+\t{4, \"R_AARCH64_P32_PREL16\"},\n+\t{5, \"R_AARCH64_P32_MOVW_UABS_G0\"},\n+\t{6, \"R_AARCH64_P32_MOVW_UABS_G0_NC\"},\n+\t{7, \"R_AARCH64_P32_MOVW_UABS_G1\"},\n+\t{8, \"R_AARCH64_P32_MOVW_SABS_G0\"},\n+\t{9, \"R_AARCH64_P32_LD_PREL_LO19\"},\n+\t{10, \"R_AARCH64_P32_ADR_PREL_LO21\"},\n+\t{11, \"R_AARCH64_P32_ADR_PREL_PG_HI21\"},\n+\t{12, \"R_AARCH64_P32_ADD_ABS_LO12_NC\"},\n+\t{13, \"R_AARCH64_P32_LDST8_ABS_LO12_NC\"},\n+\t{14, \"R_AARCH64_P32_LDST16_ABS_LO12_NC\"},\n+\t{15, \"R_AARCH64_P32_LDST32_ABS_LO12_NC\"},\n+\t{16, \"R_AARCH64_P32_LDST64_ABS_LO12_NC\"},\n+\t{17, \"R_AARCH64_P32_LDST128_ABS_LO12_NC\"},\n+\t{18, \"R_AARCH64_P32_TSTBR14\"},\n+\t{19, \"R_AARCH64_P32_CONDBR19\"},\n+\t{20, \"R_AARCH64_P32_JUMP26\"},\n+\t{21, \"R_AARCH64_P32_CALL26\"},\n+\t{25, \"R_AARCH64_P32_GOT_LD_PREL19\"},\n+\t{26, \"R_AARCH64_P32_ADR_GOT_PAGE\"},\n+\t{27, \"R_AARCH64_P32_LD32_GOT_LO12_NC\"},\n+\t{81, \"R_AARCH64_P32_TLSGD_ADR_PAGE21\"},\n+\t{82, \"R_AARCH64_P32_TLSGD_ADD_LO12_NC\"},\n+\t{103, \"R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21\"},\n+\t{104, \"R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC\"},\n+\t{105, \"R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19\"},\n+\t{106, \"R_AARCH64_P32_TLSLE_MOVW_TPREL_G1\"},\n+\t{107, \"R_AARCH64_P32_TLSLE_MOVW_TPREL_G0\"},\n+\t{108, \"R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC\"},\n+\t{109, \"R_AARCH64_P32_TLSLE_ADD_TPREL_HI12\"},\n+\t{110, \"R_AARCH64_P32_TLSLE_ADD_TPREL_LO12\"},\n+\t{111, \"R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC\"},\n+\t{122, \"R_AARCH64_P32_TLSDESC_LD_PREL19\"},\n+\t{123, \"R_AARCH64_P32_TLSDESC_ADR_PREL21\"},\n+\t{124, \"R_AARCH64_P32_TLSDESC_ADR_PAGE21\"},\n+\t{125, \"R_AARCH64_P32_TLSDESC_LD32_LO12_NC\"},\n+\t{126, \"R_AARCH64_P32_TLSDESC_ADD_LO12_NC\"},\n+\t{127, \"R_AARCH64_P32_TLSDESC_CALL\"},\n+\t{180, \"R_AARCH64_P32_COPY\"},\n+\t{181, \"R_AARCH64_P32_GLOB_DAT\"},\n+\t{182, \"R_AARCH64_P32_JUMP_SLOT\"},\n+\t{183, \"R_AARCH64_P32_RELATIVE\"},\n+\t{184, \"R_AARCH64_P32_TLS_DTPMOD\"},\n+\t{185, \"R_AARCH64_P32_TLS_DTPREL\"},\n+\t{186, \"R_AARCH64_P32_TLS_TPREL\"},\n+\t{187, \"R_AARCH64_P32_TLSDESC\"},\n+\t{188, \"R_AARCH64_P32_IRELATIVE\"},\n+\t{256, \"R_AARCH64_NULL\"},\n+\t{257, \"R_AARCH64_ABS64\"},\n+\t{258, \"R_AARCH64_ABS32\"},\n+\t{259, \"R_AARCH64_ABS16\"},\n+\t{260, \"R_AARCH64_PREL64\"},\n+\t{261, \"R_AARCH64_PREL32\"},\n+\t{262, \"R_AARCH64_PREL16\"},\n+\t{263, \"R_AARCH64_MOVW_UABS_G0\"},\n+\t{264, \"R_AARCH64_MOVW_UABS_G0_NC\"},\n+\t{265, \"R_AARCH64_MOVW_UABS_G1\"},\n+\t{266, \"R_AARCH64_MOVW_UABS_G1_NC\"},\n+\t{267, \"R_AARCH64_MOVW_UABS_G2\"},\n+\t{268, \"R_AARCH64_MOVW_UABS_G2_NC\"},\n+\t{269, \"R_AARCH64_MOVW_UABS_G3\"},\n+\t{270, \"R_AARCH64_MOVW_SABS_G0\"},\n+\t{271, \"R_AARCH64_MOVW_SABS_G1\"},\n+\t{272, \"R_AARCH64_MOVW_SABS_G2\"},\n+\t{273, \"R_AARCH64_LD_PREL_LO19\"},\n+\t{274, \"R_AARCH64_ADR_PREL_LO21\"},\n+\t{275, \"R_AARCH64_ADR_PREL_PG_HI21\"},\n+\t{276, \"R_AARCH64_ADR_PREL_PG_HI21_NC\"},\n+\t{277, \"R_AARCH64_ADD_ABS_LO12_NC\"},\n+\t{278, \"R_AARCH64_LDST8_ABS_LO12_NC\"},\n+\t{279, \"R_AARCH64_TSTBR14\"},\n+\t{280, \"R_AARCH64_CONDBR19\"},\n+\t{282, \"R_AARCH64_JUMP26\"},\n+\t{283, \"R_AARCH64_CALL26\"},\n+\t{284, \"R_AARCH64_LDST16_ABS_LO12_NC\"},\n+\t{285, \"R_AARCH64_LDST32_ABS_LO12_NC\"},\n+\t{286, \"R_AARCH64_LDST64_ABS_LO12_NC\"},\n+\t{299, \"R_AARCH64_LDST128_ABS_LO12_NC\"},\n+\t{309, \"R_AARCH64_GOT_LD_PREL19\"},\n+\t{311, \"R_AARCH64_ADR_GOT_PAGE\"},\n+\t{312, \"R_AARCH64_LD64_GOT_LO12_NC\"},\n+\t{513, \"R_AARCH64_TLSGD_ADR_PAGE21\"},\n+\t{514, \"R_AARCH64_TLSGD_ADD_LO12_NC\"},\n+\t{539, \"R_AARCH64_TLSIE_MOVW_GOTTPREL_G1\"},\n+\t{540, \"R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC\"},\n+\t{541, \"R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21\"},\n+\t{542, \"R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC\"},\n+\t{543, \"R_AARCH64_TLSIE_LD_GOTTPREL_PREL19\"},\n+\t{544, \"R_AARCH64_TLSLE_MOVW_TPREL_G2\"},\n+\t{545, \"R_AARCH64_TLSLE_MOVW_TPREL_G1\"},\n+\t{546, \"R_AARCH64_TLSLE_MOVW_TPREL_G1_NC\"},\n+\t{547, \"R_AARCH64_TLSLE_MOVW_TPREL_G0\"},\n+\t{548, \"R_AARCH64_TLSLE_MOVW_TPREL_G0_NC\"},\n+\t{549, \"R_AARCH64_TLSLE_ADD_TPREL_HI12\"},\n+\t{550, \"R_AARCH64_TLSLE_ADD_TPREL_LO12\"},\n+\t{551, \"R_AARCH64_TLSLE_ADD_TPREL_LO12_NC\"},\n+\t{560, \"R_AARCH64_TLSDESC_LD_PREL19\"},\n+\t{561, \"R_AARCH64_TLSDESC_ADR_PREL21\"},\n+\t{562, \"R_AARCH64_TLSDESC_ADR_PAGE21\"},\n+\t{563, \"R_AARCH64_TLSDESC_LD64_LO12_NC\"},\n+\t{564, \"R_AARCH64_TLSDESC_ADD_LO12_NC\"},\n+\t{565, \"R_AARCH64_TLSDESC_OFF_G1\"},\n+\t{566, \"R_AARCH64_TLSDESC_OFF_G0_NC\"},\n+\t{567, \"R_AARCH64_TLSDESC_LDR\"},\n+\t{568, \"R_AARCH64_TLSDESC_ADD\"},\n+\t{569, \"R_AARCH64_TLSDESC_CALL\"},\n+\t{1024, \"R_AARCH64_COPY\"},\n+\t{1025, \"R_AARCH64_GLOB_DAT\"},\n+\t{1026, \"R_AARCH64_JUMP_SLOT\"},\n+\t{1027, \"R_AARCH64_RELATIVE\"},\n+\t{1028, \"R_AARCH64_TLS_DTPMOD64\"},\n+\t{1029, \"R_AARCH64_TLS_DTPREL64\"},\n+\t{1030, \"R_AARCH64_TLS_TPREL64\"},\n+\t{1031, \"R_AARCH64_TLSDESC\"},\n+\t{1032, \"R_AARCH64_IRELATIVE\"},\n+}\n+\n+func (i R_AARCH64) String() string   { return stringName(uint32(i), raarch64Strings, false) }\n+func (i R_AARCH64) GoString() string { return stringName(uint32(i), raarch64Strings, true) }\n+\n // Relocation types for Alpha.\n type R_ALPHA int\n "}, {"sha": "5a418d8102163c2711c161fc2fb3e5d538eb0cf6", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -405,10 +405,14 @@ func (f *File) getSymbols(typ SectionType) ([]Symbol, []byte, error) {\n \treturn nil, nil, errors.New(\"not implemented\")\n }\n \n+// ErrNoSymbols is returned by File.Symbols and File.DynamicSymbols\n+// if there is no such section in the File.\n+var ErrNoSymbols = errors.New(\"no symbol section\")\n+\n func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, error) {\n \tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n-\t\treturn nil, nil, errors.New(\"no symbol section\")\n+\t\treturn nil, nil, ErrNoSymbols\n \t}\n \n \tdata, err := symtabSection.Data()\n@@ -451,7 +455,7 @@ func (f *File) getSymbols32(typ SectionType) ([]Symbol, []byte, error) {\n func (f *File) getSymbols64(typ SectionType) ([]Symbol, []byte, error) {\n \tsymtabSection := f.SectionByType(typ)\n \tif symtabSection == nil {\n-\t\treturn nil, nil, errors.New(\"no symbol section\")\n+\t\treturn nil, nil, ErrNoSymbols\n \t}\n \n \tdata, err := symtabSection.Data()\n@@ -525,6 +529,9 @@ func (f *File) applyRelocations(dst []byte, rels []byte) error {\n \tif f.Class == ELFCLASS32 && f.Machine == EM_386 {\n \t\treturn f.applyRelocations386(dst, rels)\n \t}\n+\tif f.Class == ELFCLASS64 && f.Machine == EM_AARCH64 {\n+\t\treturn f.applyRelocationsARM64(dst, rels)\n+\t}\n \tif f.Class == ELFCLASS64 && f.Machine == EM_PPC64 {\n \t\treturn f.applyRelocationsPPC64(dst, rels)\n \t}\n@@ -563,6 +570,10 @@ func (f *File) applyRelocationsAMD64(dst []byte, rels []byte) error {\n \t\t\tcontinue\n \t\t}\n \n+\t\t// There are relocations, so this must be a normal\n+\t\t// object file, and we only look at section symbols,\n+\t\t// so we assume that the symbol value is 0.\n+\n \t\tswitch t {\n \t\tcase R_X86_64_64:\n \t\t\tif rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {\n@@ -617,6 +628,55 @@ func (f *File) applyRelocations386(dst []byte, rels []byte) error {\n \treturn nil\n }\n \n+func (f *File) applyRelocationsARM64(dst []byte, rels []byte) error {\n+\t// 24 is the size of Rela64.\n+\tif len(rels)%24 != 0 {\n+\t\treturn errors.New(\"length of relocation section is not a multiple of 24\")\n+\t}\n+\n+\tsymbols, _, err := f.getSymbols(SHT_SYMTAB)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tb := bytes.NewReader(rels)\n+\tvar rela Rela64\n+\n+\tfor b.Len() > 0 {\n+\t\tbinary.Read(b, f.ByteOrder, &rela)\n+\t\tsymNo := rela.Info >> 32\n+\t\tt := R_AARCH64(rela.Info & 0xffff)\n+\n+\t\tif symNo == 0 || symNo > uint64(len(symbols)) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsym := &symbols[symNo-1]\n+\t\tif SymType(sym.Info&0xf) != STT_SECTION {\n+\t\t\t// We don't handle non-section relocations for now.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// There are relocations, so this must be a normal\n+\t\t// object file, and we only look at section symbols,\n+\t\t// so we assume that the symbol value is 0.\n+\n+\t\tswitch t {\n+\t\tcase R_AARCH64_ABS64:\n+\t\t\tif rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tf.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], uint64(rela.Addend))\n+\t\tcase R_AARCH64_ABS32:\n+\t\t\tif rela.Off+4 >= uint64(len(dst)) || rela.Addend < 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tf.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], uint32(rela.Addend))\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n func (f *File) applyRelocationsPPC64(dst []byte, rels []byte) error {\n \t// 24 is the size of Rela64.\n \tif len(rels)%24 != 0 {\n@@ -725,7 +785,7 @@ func (f *File) DWARF() (*dwarf.Data, error) {\n \t// If there's a relocation table for .debug_info, we have to process it\n \t// now otherwise the data in .debug_info is invalid for x86-64 objects.\n \trela := f.Section(\".rela.debug_info\")\n-\tif rela != nil && rela.Type == SHT_RELA && (f.Machine == EM_X86_64 || f.Machine == EM_PPC64 || f.Machine == EM_S390) {\n+\tif rela != nil && rela.Type == SHT_RELA && (f.Machine == EM_X86_64 || f.Machine == EM_AARCH64 || f.Machine == EM_PPC64 || f.Machine == EM_S390) {\n \t\tdata, err := rela.Data()\n \t\tif err != nil {\n \t\t\treturn nil, err\n@@ -790,7 +850,8 @@ func (f *File) DWARF() (*dwarf.Data, error) {\n \treturn d, nil\n }\n \n-// Symbols returns the symbol table for f.\n+// Symbols returns the symbol table for f. The symbols will be listed in the order\n+// they appear in f.\n //\n // For compatibility with Go 1.0, Symbols omits the null symbol at index 0.\n // After retrieving the symbols as symtab, an externally supplied index x\n@@ -800,6 +861,17 @@ func (f *File) Symbols() ([]Symbol, error) {\n \treturn sym, err\n }\n \n+// DynamicSymbols returns the dynamic symbol table for f. The symbols\n+// will be listed in the order they appear in f.\n+//\n+// For compatibility with Symbols, DynamicSymbols omits the null symbol at index 0.\n+// After retrieving the symbols as symtab, an externally supplied index x\n+// corresponds to symtab[x-1], not symtab[x].\n+func (f *File) DynamicSymbols() ([]Symbol, error) {\n+\tsym, _, err := f.getSymbols(SHT_DYNSYM)\n+\treturn sym, err\n+}\n+\n type ImportedSymbol struct {\n \tName    string\n \tVersion string"}, {"sha": "ce10da71d2b23c8959ea510b582fe27153fe535d", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -166,11 +166,11 @@ func TestOpen(t *testing.T) {\n \t\t} else {\n \t\t\tf, err = Open(tt.file)\n \t\t}\n-\t\tdefer f.Close()\n \t\tif err != nil {\n \t\t\tt.Errorf(\"cannot open file %s: %v\", tt.file, err)\n \t\t\tcontinue\n \t\t}\n+\t\tdefer f.Close()\n \t\tif !reflect.DeepEqual(f.FileHeader, tt.hdr) {\n \t\t\tt.Errorf(\"open %s:\\n\\thave %#v\\n\\twant %#v\\n\", tt.file, f.FileHeader, tt.hdr)\n \t\t\tcontinue\n@@ -266,6 +266,12 @@ var relocationTests = []relocationTest{\n \t\t\t{0, &dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{dwarf.Field{Attr: dwarf.AttrProducer, Val: \"GNU C 4.8.2 -Asystem=linux -Asystem=unix -Asystem=posix -msecure-plt -mtune=power8 -mcpu=power7 -gdwarf-2 -fstack-protector\"}, dwarf.Field{Attr: dwarf.AttrLanguage, Val: int64(1)}, dwarf.Field{Attr: dwarf.AttrName, Val: \"go-relocation-test-gcc482-ppc64le.c\"}, dwarf.Field{Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, dwarf.Field{Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, dwarf.Field{Attr: dwarf.AttrHighpc, Val: uint64(0x24)}, dwarf.Field{Attr: dwarf.AttrStmtList, Val: int64(0)}}}},\n \t\t},\n \t},\n+\t{\n+\t\t\"testdata/go-relocation-test-gcc482-aarch64.obj\",\n+\t\t[]relocationTestEntry{\n+\t\t\t{0, &dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{{Attr: dwarf.AttrProducer, Val: \"GNU C 4.8.2 -g -fstack-protector\"}, {Attr: dwarf.AttrLanguage, Val: int64(1)}, {Attr: dwarf.AttrName, Val: \"go-relocation-test-gcc482.c\"}, {Attr: dwarf.AttrCompDir, Val: \"/tmp\"}, {Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, {Attr: dwarf.AttrHighpc, Val: int64(0x24)}, {Attr: dwarf.AttrStmtList, Val: int64(0)}}}},\n+\t\t},\n+\t},\n \t{\n \t\t\"testdata/go-relocation-test-clang-x86.obj\",\n \t\t[]relocationTestEntry{"}, {"sha": "1b79520e3ccb56c39bc61ebb3b8a575293a0498d", "filename": "libgo/go/debug/elf/symbols_test.go", "status": "added", "additions": 834, "deletions": 0, "changes": 834, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Fsymbols_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Fsymbols_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Fsymbols_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,834 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package elf\n+\n+import (\n+\t\"io\"\n+\t\"path\"\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+// TODO: remove duplicate code\n+func TestSymbols(t *testing.T) {\n+\tdo := func(file string, ts []Symbol, getfunc func(*File) ([]Symbol, error)) {\n+\t\tvar f *File\n+\t\tvar err error\n+\t\tif path.Ext(file) == \".gz\" {\n+\t\t\tvar r io.ReaderAt\n+\t\t\tif r, err = decompress(file); err == nil {\n+\t\t\t\tf, err = NewFile(r)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tf, err = Open(file)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"TestSymbols: cannot open file %s: %v\", file, err)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tfs, err := getfunc(f)\n+\t\tif err != nil && err != ErrNoSymbols {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t} else if err == ErrNoSymbols {\n+\t\t\tfs = []Symbol{}\n+\t\t}\n+\t\tif !reflect.DeepEqual(ts, fs) {\n+\t\t\tt.Errorf(\"%s: Symbols = %v, want %v\", file, ts, fs)\n+\t\t}\n+\t}\n+\tfor file, ts := range symbolsGolden {\n+\t\tdo(file, ts, (*File).Symbols)\n+\t}\n+\tfor file, ts := range dynamicSymbolsGolden {\n+\t\tdo(file, ts, (*File).DynamicSymbols)\n+\t}\n+}\n+\n+// golden symbol table data generated by testdata/getgoldsym.c\n+\n+var symbolsGolden = map[string][]Symbol{\n+\t\"testdata/gcc-amd64-linux-exec\": {\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x1,\n+\t\t\tValue:   0x400200,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x2,\n+\t\t\tValue:   0x40021C,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x3,\n+\t\t\tValue:   0x400240,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x4,\n+\t\t\tValue:   0x400268,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x5,\n+\t\t\tValue:   0x400288,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x6,\n+\t\t\tValue:   0x4002E8,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x7,\n+\t\t\tValue:   0x400326,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x8,\n+\t\t\tValue:   0x400330,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x9,\n+\t\t\tValue:   0x400350,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xA,\n+\t\t\tValue:   0x400368,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xB,\n+\t\t\tValue:   0x400398,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xC,\n+\t\t\tValue:   0x4003B0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x4003E0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xE,\n+\t\t\tValue:   0x400594,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xF,\n+\t\t\tValue:   0x4005A4,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x10,\n+\t\t\tValue:   0x4005B8,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x11,\n+\t\t\tValue:   0x4005E0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x12,\n+\t\t\tValue:   0x600688,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x13,\n+\t\t\tValue:   0x600698,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x14,\n+\t\t\tValue:   0x6006A8,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x15,\n+\t\t\tValue:   0x6006B0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x16,\n+\t\t\tValue:   0x600850,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x17,\n+\t\t\tValue:   0x600858,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x18,\n+\t\t\tValue:   0x600880,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x19,\n+\t\t\tValue:   0x600898,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x1A,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x1B,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x1C,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x1D,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x1E,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x1F,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x20,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x21,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"init.c\",\n+\t\t\tInfo:    0x4,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"initfini.c\",\n+\t\t\tInfo:    0x4,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"call_gmon_start\",\n+\t\t\tInfo:    0x2,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x40040C,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"crtstuff.c\",\n+\t\t\tInfo:    0x4,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__CTOR_LIST__\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x12,\n+\t\t\tValue:   0x600688,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__DTOR_LIST__\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x13,\n+\t\t\tValue:   0x600698,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__JCR_LIST__\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x14,\n+\t\t\tValue:   0x6006A8,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__do_global_dtors_aux\",\n+\t\t\tInfo:    0x2,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x400430,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"completed.6183\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x19,\n+\t\t\tValue:   0x600898,\n+\t\t\tSize:    0x1,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"p.6181\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x18,\n+\t\t\tValue:   0x600890,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"frame_dummy\",\n+\t\t\tInfo:    0x2,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x400470,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"crtstuff.c\",\n+\t\t\tInfo:    0x4,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__CTOR_END__\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x12,\n+\t\t\tValue:   0x600690,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__DTOR_END__\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x13,\n+\t\t\tValue:   0x6006A0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__FRAME_END__\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x11,\n+\t\t\tValue:   0x400680,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__JCR_END__\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x14,\n+\t\t\tValue:   0x6006A8,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__do_global_ctors_aux\",\n+\t\t\tInfo:    0x2,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x400560,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"initfini.c\",\n+\t\t\tInfo:    0x4,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"hello.c\",\n+\t\t\tInfo:    0x4,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_GLOBAL_OFFSET_TABLE_\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x2,\n+\t\t\tSection: 0x17,\n+\t\t\tValue:   0x600858,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__init_array_end\",\n+\t\t\tInfo:    0x0,\n+\t\t\tOther:   0x2,\n+\t\t\tSection: 0x12,\n+\t\t\tValue:   0x600684,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__init_array_start\",\n+\t\t\tInfo:    0x0,\n+\t\t\tOther:   0x2,\n+\t\t\tSection: 0x12,\n+\t\t\tValue:   0x600684,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_DYNAMIC\",\n+\t\t\tInfo:    0x1,\n+\t\t\tOther:   0x2,\n+\t\t\tSection: 0x15,\n+\t\t\tValue:   0x6006B0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"data_start\",\n+\t\t\tInfo:    0x20,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x18,\n+\t\t\tValue:   0x600880,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__libc_csu_fini\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x4004C0,\n+\t\t\tSize:    0x2,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_start\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x4003E0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__gmon_start__\",\n+\t\t\tInfo:    0x20,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x0,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_Jv_RegisterClasses\",\n+\t\t\tInfo:    0x20,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x0,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"puts@@GLIBC_2.2.5\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x0,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x18C,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_fini\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xE,\n+\t\t\tValue:   0x400594,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__libc_start_main@@GLIBC_2.2.5\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x0,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x1C2,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_IO_stdin_used\",\n+\t\t\tInfo:    0x11,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xF,\n+\t\t\tValue:   0x4005A4,\n+\t\t\tSize:    0x4,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__data_start\",\n+\t\t\tInfo:    0x10,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x18,\n+\t\t\tValue:   0x600880,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__dso_handle\",\n+\t\t\tInfo:    0x11,\n+\t\t\tOther:   0x2,\n+\t\t\tSection: 0x18,\n+\t\t\tValue:   0x600888,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__libc_csu_init\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x4004D0,\n+\t\t\tSize:    0x89,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__bss_start\",\n+\t\t\tInfo:    0x10,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x600898,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_end\",\n+\t\t\tInfo:    0x10,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x6008A0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_edata\",\n+\t\t\tInfo:    0x10,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x600898,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"main\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x400498,\n+\t\t\tSize:    0x1B,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"_init\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xB,\n+\t\t\tValue:   0x400398,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t},\n+\t\"testdata/go-relocation-test-clang-x86.obj\": {\n+\t\tSymbol{\n+\t\t\tName:    \"go-relocation-test-clang.c\",\n+\t\t\tInfo:    0x4,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF1,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \".Linfo_string0\",\n+\t\t\tInfo:    0x0,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xC,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \".Linfo_string1\",\n+\t\t\tInfo:    0x0,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xC,\n+\t\t\tValue:   0x2C,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \".Linfo_string2\",\n+\t\t\tInfo:    0x0,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xC,\n+\t\t\tValue:   0x47,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \".Linfo_string3\",\n+\t\t\tInfo:    0x0,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xC,\n+\t\t\tValue:   0x4C,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \".Linfo_string4\",\n+\t\t\tInfo:    0x0,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xC,\n+\t\t\tValue:   0x4E,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x1,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x2,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x3,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x4,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x6,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x7,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x8,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xA,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xC,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xD,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xE,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xF,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"\",\n+\t\t\tInfo:    0x3,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x10,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"v\",\n+\t\t\tInfo:    0x11,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0xFFF2,\n+\t\t\tValue:   0x4,\n+\t\t\tSize:    0x4,\n+\t\t},\n+\t},\n+\t\"testdata/hello-world-core.gz\": {},\n+}\n+\n+var dynamicSymbolsGolden = map[string][]Symbol{\n+\t\"testdata/gcc-amd64-linux-exec\": {\n+\t\tSymbol{\n+\t\t\tName:    \"__gmon_start__\",\n+\t\t\tInfo:    0x20,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x0,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x0,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"puts\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x0,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x18C,\n+\t\t},\n+\t\tSymbol{\n+\t\t\tName:    \"__libc_start_main\",\n+\t\t\tInfo:    0x12,\n+\t\t\tOther:   0x0,\n+\t\t\tSection: 0x0,\n+\t\t\tValue:   0x0,\n+\t\t\tSize:    0x1C2,\n+\t\t},\n+\t},\n+\t\"testdata/go-relocation-test-clang-x86.obj\": {},\n+\t\"testdata/hello-world-core.gz\":              {},\n+}"}, {"sha": "849e2644ec79263a958fcabda5b9e731e3cb1842", "filename": "libgo/go/debug/elf/testdata/go-relocation-test-gcc482-aarch64.obj", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc482-aarch64.obj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc482-aarch64.obj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fgo-relocation-test-gcc482-aarch64.obj?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "ee18499d111a8ef359c1a2b8c67a3d67a2f4be35", "filename": "libgo/go/debug/gosym/symtab.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fsymtab.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -402,7 +402,7 @@ func NewTable(symtab []byte, pcln *LineTable) (*Table, error) {\n \t\t\tif n := len(t.Funcs); n > 0 {\n \t\t\t\tt.Funcs[n-1].End = sym.Value\n \t\t\t}\n-\t\t\tif sym.Name == \"etext\" {\n+\t\t\tif sym.Name == \"runtime.etext\" || sym.Name == \"etext\" {\n \t\t\t\tcontinue\n \t\t\t}\n "}, {"sha": "759e5674fd623de32fcf6e8d8c523179d86492f4", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"strconv\"\n-\t\"unsafe\"\n )\n \n // A File represents an open PE file.\n@@ -125,6 +124,11 @@ func (f *File) Close() error {\n \treturn err\n }\n \n+var (\n+\tsizeofOptionalHeader32 = uint16(binary.Size(OptionalHeader32{}))\n+\tsizeofOptionalHeader64 = uint16(binary.Size(OptionalHeader64{}))\n+)\n+\n // NewFile creates a new File for accessing a PE binary in an underlying reader.\n func NewFile(r io.ReaderAt) (*File, error) {\n \tf := new(File)\n@@ -205,16 +209,16 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \t}\n \tvar oh32 OptionalHeader32\n \tvar oh64 OptionalHeader64\n-\tswitch uintptr(f.FileHeader.SizeOfOptionalHeader) {\n-\tcase unsafe.Sizeof(oh32):\n+\tswitch f.FileHeader.SizeOfOptionalHeader {\n+\tcase sizeofOptionalHeader32:\n \t\tif err := binary.Read(sr, binary.LittleEndian, &oh32); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\tif oh32.Magic != 0x10b { // PE32\n \t\t\treturn nil, fmt.Errorf(\"pe32 optional header has unexpected Magic of 0x%x\", oh32.Magic)\n \t\t}\n \t\tf.OptionalHeader = &oh32\n-\tcase unsafe.Sizeof(oh64):\n+\tcase sizeofOptionalHeader64:\n \t\tif err := binary.Read(sr, binary.LittleEndian, &oh64); err != nil {\n \t\t\treturn nil, err\n \t\t}"}, {"sha": "0d73969bca9c8aa68af97701e38f137a3dc297e4", "filename": "libgo/go/debug/pe/file_test.go", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -125,9 +125,9 @@ var fileTests = []fileTest{\n \t},\n \t{\n \t\t\"testdata/gcc-amd64-mingw-exec\",\n-\t\tFileHeader{0x8664, 0x9, 0x53472993, 0x0, 0x0, 0xf0, 0x22f},\n+\t\tFileHeader{0x8664, 0x11, 0x53e4364f, 0x39600, 0x6fc, 0xf0, 0x27},\n \t\t&OptionalHeader64{\n-\t\t\t0x20b, 0x2, 0x16, 0x6a00, 0x2400, 0x1600, 0x14e0, 0x1000, 0x400000, 0x1000, 0x200, 0x4, 0x0, 0x0, 0x0, 0x5, 0x2, 0x0, 0x11000, 0x400, 0x1841e, 0x3, 0x0, 0x200000, 0x1000, 0x100000, 0x1000, 0x0, 0x10,\n+\t\t\t0x20b, 0x2, 0x16, 0x6a00, 0x2400, 0x1600, 0x14e0, 0x1000, 0x400000, 0x1000, 0x200, 0x4, 0x0, 0x0, 0x0, 0x5, 0x2, 0x0, 0x45000, 0x600, 0x46f19, 0x3, 0x0, 0x200000, 0x1000, 0x100000, 0x1000, 0x0, 0x10,\n \t\t\t[16]DataDirectory{\n \t\t\t\t{0x0, 0x0},\n \t\t\t\t{0xe000, 0x990},\n@@ -145,18 +145,25 @@ var fileTests = []fileTest{\n \t\t\t\t{0x0, 0x0},\n \t\t\t\t{0x0, 0x0},\n \t\t\t\t{0x0, 0x0},\n-\t\t\t},\n-\t\t},\n+\t\t\t}},\n \t\t[]*SectionHeader{\n-\t\t\t{\".text\", 0x6860, 0x1000, 0x6a00, 0x400, 0x0, 0x0, 0x0, 0x0, 0x60500020},\n-\t\t\t{\".data\", 0xe0, 0x8000, 0x200, 0x6e00, 0x0, 0x0, 0x0, 0x0, 0xc0500040},\n-\t\t\t{\".rdata\", 0x6b0, 0x9000, 0x800, 0x7000, 0x0, 0x0, 0x0, 0x0, 0x40600040},\n-\t\t\t{\".pdata\", 0x498, 0xa000, 0x600, 0x7800, 0x0, 0x0, 0x0, 0x0, 0x40300040},\n-\t\t\t{\".xdata\", 0x488, 0xb000, 0x600, 0x7e00, 0x0, 0x0, 0x0, 0x0, 0x40300040},\n+\t\t\t{\".text\", 0x6860, 0x1000, 0x6a00, 0x600, 0x0, 0x0, 0x0, 0x0, 0x60500020},\n+\t\t\t{\".data\", 0xe0, 0x8000, 0x200, 0x7000, 0x0, 0x0, 0x0, 0x0, 0xc0500040},\n+\t\t\t{\".rdata\", 0x6b0, 0x9000, 0x800, 0x7200, 0x0, 0x0, 0x0, 0x0, 0x40600040},\n+\t\t\t{\".pdata\", 0x498, 0xa000, 0x600, 0x7a00, 0x0, 0x0, 0x0, 0x0, 0x40300040},\n+\t\t\t{\".xdata\", 0x488, 0xb000, 0x600, 0x8000, 0x0, 0x0, 0x0, 0x0, 0x40300040},\n \t\t\t{\".bss\", 0x1410, 0xc000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0600080},\n-\t\t\t{\".idata\", 0x990, 0xe000, 0xa00, 0x8400, 0x0, 0x0, 0x0, 0x0, 0xc0300040},\n-\t\t\t{\".CRT\", 0x68, 0xf000, 0x200, 0x8e00, 0x0, 0x0, 0x0, 0x0, 0xc0400040},\n-\t\t\t{\".tls\", 0x48, 0x10000, 0x200, 0x9000, 0x0, 0x0, 0x0, 0x0, 0xc0600040},\n+\t\t\t{\".idata\", 0x990, 0xe000, 0xa00, 0x8600, 0x0, 0x0, 0x0, 0x0, 0xc0300040},\n+\t\t\t{\".CRT\", 0x68, 0xf000, 0x200, 0x9000, 0x0, 0x0, 0x0, 0x0, 0xc0400040},\n+\t\t\t{\".tls\", 0x48, 0x10000, 0x200, 0x9200, 0x0, 0x0, 0x0, 0x0, 0xc0600040},\n+\t\t\t{\".debug_aranges\", 0x600, 0x11000, 0x600, 0x9400, 0x0, 0x0, 0x0, 0x0, 0x42500040},\n+\t\t\t{\".debug_info\", 0x1316e, 0x12000, 0x13200, 0x9a00, 0x0, 0x0, 0x0, 0x0, 0x42100040},\n+\t\t\t{\".debug_abbrev\", 0x2ccb, 0x26000, 0x2e00, 0x1cc00, 0x0, 0x0, 0x0, 0x0, 0x42100040},\n+\t\t\t{\".debug_line\", 0x3c4d, 0x29000, 0x3e00, 0x1fa00, 0x0, 0x0, 0x0, 0x0, 0x42100040},\n+\t\t\t{\".debug_frame\", 0x18b8, 0x2d000, 0x1a00, 0x23800, 0x0, 0x0, 0x0, 0x0, 0x42400040},\n+\t\t\t{\".debug_str\", 0x396, 0x2f000, 0x400, 0x25200, 0x0, 0x0, 0x0, 0x0, 0x42100040},\n+\t\t\t{\".debug_loc\", 0x13240, 0x30000, 0x13400, 0x25600, 0x0, 0x0, 0x0, 0x0, 0x42100040},\n+\t\t\t{\".debug_ranges\", 0xa70, 0x44000, 0xc00, 0x38a00, 0x0, 0x0, 0x0, 0x0, 0x42100040},\n \t\t},\n \t\t[]*Symbol{},\n \t},"}, {"sha": "ce6feb6b7b6a4ca1fc5da067254d8acfd49f3377", "filename": "libgo/go/debug/pe/testdata/gcc-amd64-mingw-exec", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fpe%2Ftestdata%2Fgcc-amd64-mingw-exec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fpe%2Ftestdata%2Fgcc-amd64-mingw-exec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ftestdata%2Fgcc-amd64-mingw-exec?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "b11ed86f185dedffe46f24bf572da838e8d2cf72", "filename": "libgo/go/debug/plan9obj/file.go", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fplan9obj%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fplan9obj%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fplan9obj%2Ffile.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -15,10 +15,12 @@ import (\n \n // A FileHeader represents a Plan 9 a.out file header.\n type FileHeader struct {\n-\tMagic   uint32\n-\tBss     uint32\n-\tEntry   uint64\n-\tPtrSize int\n+\tMagic       uint32\n+\tBss         uint32\n+\tEntry       uint64\n+\tPtrSize     int\n+\tLoadAddress uint64\n+\tHdrSize     uint64\n }\n \n // A File represents an open Plan 9 a.out file.\n@@ -148,20 +150,21 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \t}\n \n \tf := &File{FileHeader: FileHeader{\n-\t\tMagic:   ph.Magic,\n-\t\tBss:     ph.Bss,\n-\t\tEntry:   uint64(ph.Entry),\n-\t\tPtrSize: 4,\n+\t\tMagic:       ph.Magic,\n+\t\tBss:         ph.Bss,\n+\t\tEntry:       uint64(ph.Entry),\n+\t\tPtrSize:     4,\n+\t\tLoadAddress: 0x1000,\n+\t\tHdrSize:     4 * 8,\n \t}}\n \n-\thdrSize := 4 * 8\n-\n \tif ph.Magic&Magic64 != 0 {\n \t\tif err := binary.Read(sr, binary.BigEndian, &f.Entry); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\tf.PtrSize = 8\n-\t\thdrSize += 8\n+\t\tf.LoadAddress = 0x200000\n+\t\tf.HdrSize += 8\n \t}\n \n \tvar sects = []struct {\n@@ -177,7 +180,7 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \n \tf.Sections = make([]*Section, 5)\n \n-\toff := uint32(hdrSize)\n+\toff := uint32(f.HdrSize)\n \n \tfor i, sect := range sects {\n \t\ts := new(Section)"}, {"sha": "cfd7a61d1cdff79d8752665ebc84af0c55be4530", "filename": "libgo/go/debug/plan9obj/file_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fplan9obj%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fdebug%2Fplan9obj%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fplan9obj%2Ffile_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -18,7 +18,7 @@ type fileTest struct {\n var fileTests = []fileTest{\n \t{\n \t\t\"testdata/386-plan9-exec\",\n-\t\tFileHeader{Magic386, 0x324, 0x14, 4},\n+\t\tFileHeader{Magic386, 0x324, 0x14, 4, 0x1000, 32},\n \t\t[]*SectionHeader{\n \t\t\t{\"text\", 0x4c5f, 0x20},\n \t\t\t{\"data\", 0x94c, 0x4c7f},\n@@ -29,7 +29,7 @@ var fileTests = []fileTest{\n \t},\n \t{\n \t\t\"testdata/amd64-plan9-exec\",\n-\t\tFileHeader{MagicAMD64, 0x618, 0x13, 8},\n+\t\tFileHeader{MagicAMD64, 0x618, 0x13, 8, 0x200000, 40},\n \t\t[]*SectionHeader{\n \t\t\t{\"text\", 0x4213, 0x28},\n \t\t\t{\"data\", 0xa80, 0x423b},"}, {"sha": "4d7193873a2410fc67f9163ed6ea5e9e3e39f7b2", "filename": "libgo/go/encoding/ascii85/ascii85.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -249,7 +249,6 @@ type decoder struct {\n \terr     error\n \treadErr error\n \tr       io.Reader\n-\tend     bool       // saw end of message\n \tbuf     [1024]byte // leftover input\n \tnbuf    int\n \tout     []byte // leftover decoded output"}, {"sha": "8b3d1b34121c6cc78019806b2bbb76999a6912f5", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -640,15 +640,19 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t// when it sees a string, so if we see a different string type on the\n \t// wire, we change the universal type to match.\n \tif universalTag == tagPrintableString {\n-\t\tswitch t.tag {\n-\t\tcase tagIA5String, tagGeneralString, tagT61String, tagUTF8String:\n-\t\t\tuniversalTag = t.tag\n+\t\tif t.class == classUniversal {\n+\t\t\tswitch t.tag {\n+\t\t\tcase tagIA5String, tagGeneralString, tagT61String, tagUTF8String:\n+\t\t\t\tuniversalTag = t.tag\n+\t\t\t}\n+\t\t} else if params.stringType != 0 {\n+\t\t\tuniversalTag = params.stringType\n \t\t}\n \t}\n \n \t// Special case for time: UTCTime and GeneralizedTime both map to the\n \t// Go type time.Time.\n-\tif universalTag == tagUTCTime && t.tag == tagGeneralizedTime {\n+\tif universalTag == tagUTCTime && t.tag == tagGeneralizedTime && t.class == classUniversal {\n \t\tuniversalTag = tagGeneralizedTime\n \t}\n \n@@ -822,8 +826,19 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \treturn\n }\n \n+// canHaveDefaultValue reports whether k is a Kind that we will set a default\n+// value for. (A signed integer, essentially.)\n+func canHaveDefaultValue(k reflect.Kind) bool {\n+\tswitch k {\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn true\n+\t}\n+\n+\treturn false\n+}\n+\n // setDefaultValue is used to install a default value, from a tag string, into\n-// a Value. It is successful is the field was optional, even if a default value\n+// a Value. It is successful if the field was optional, even if a default value\n // wasn't provided or it failed to install it into the Value.\n func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n \tif !params.optional {\n@@ -833,9 +848,8 @@ func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n \tif params.defaultValue == nil {\n \t\treturn\n \t}\n-\tswitch val := v; val.Kind() {\n-\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\tval.SetInt(*params.defaultValue)\n+\tif canHaveDefaultValue(v.Kind()) {\n+\t\tv.SetInt(*params.defaultValue)\n \t}\n \treturn\n }"}, {"sha": "4e864d08ac0a96ba42dd45ce5c94efb4f48d1914", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -392,6 +392,10 @@ type TestContextSpecificTags2 struct {\n \tB int\n }\n \n+type TestContextSpecificTags3 struct {\n+\tS string `asn1:\"tag:1,utf8\"`\n+}\n+\n type TestElementsAfterString struct {\n \tS    string\n \tA, B int\n@@ -420,6 +424,7 @@ var unmarshalTestData = []struct {\n \t{[]byte{0x04, 0x04, 1, 2, 3, 4}, &RawValue{0, 4, false, []byte{1, 2, 3, 4}, []byte{4, 4, 1, 2, 3, 4}}},\n \t{[]byte{0x30, 0x03, 0x81, 0x01, 0x01}, &TestContextSpecificTags{1}},\n \t{[]byte{0x30, 0x08, 0xa1, 0x03, 0x02, 0x01, 0x01, 0x02, 0x01, 0x02}, &TestContextSpecificTags2{1, 2}},\n+\t{[]byte{0x30, 0x03, 0x81, 0x01, '@'}, &TestContextSpecificTags3{\"@\"}},\n \t{[]byte{0x01, 0x01, 0x00}, newBool(false)},\n \t{[]byte{0x01, 0x01, 0xff}, newBool(true)},\n \t{[]byte{0x30, 0x0b, 0x13, 0x03, 0x66, 0x6f, 0x6f, 0x02, 0x01, 0x22, 0x02, 0x01, 0x33}, &TestElementsAfterString{\"foo\", 0x22, 0x33}},\n@@ -812,3 +817,51 @@ func TestStringSlice(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+type explicitTaggedTimeTest struct {\n+\tTime time.Time `asn1:\"explicit,tag:0\"`\n+}\n+\n+var explicitTaggedTimeTestData = []struct {\n+\tin  []byte\n+\tout explicitTaggedTimeTest\n+}{\n+\t{[]byte{0x30, 0x11, 0xa0, 0xf, 0x17, 0xd, '9', '1', '0', '5', '0', '6', '1', '6', '4', '5', '4', '0', 'Z'},\n+\t\texplicitTaggedTimeTest{time.Date(1991, 05, 06, 16, 45, 40, 0, time.UTC)}},\n+\t{[]byte{0x30, 0x17, 0xa0, 0xf, 0x18, 0x13, '2', '0', '1', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '+', '0', '6', '0', '7'},\n+\t\texplicitTaggedTimeTest{time.Date(2010, 01, 02, 03, 04, 05, 0, time.FixedZone(\"\", 6*60*60+7*60))}},\n+}\n+\n+func TestExplicitTaggedTime(t *testing.T) {\n+\t// Test that a time.Time will match either tagUTCTime or\n+\t// tagGeneralizedTime.\n+\tfor i, test := range explicitTaggedTimeTestData {\n+\t\tvar got explicitTaggedTimeTest\n+\t\t_, err := Unmarshal(test.in, &got)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Unmarshal failed at index %d %v\", i, err)\n+\t\t}\n+\t\tif !got.Time.Equal(test.out.Time) {\n+\t\t\tt.Errorf(\"#%d: got %v, want %v\", i, got.Time, test.out.Time)\n+\t\t}\n+\t}\n+}\n+\n+type implicitTaggedTimeTest struct {\n+\tTime time.Time `asn1:\"tag:24\"`\n+}\n+\n+func TestImplicitTaggedTime(t *testing.T) {\n+\t// An implicitly tagged time value, that happens to have an implicit\n+\t// tag equal to a GENERALIZEDTIME, should still be parsed as a UTCTime.\n+\t// (There's no \"timeType\" in fieldParameters to determine what type of\n+\t// time should be expected when implicitly tagged.)\n+\tder := []byte{0x30, 0x0f, 0x80 | 24, 0xd, '9', '1', '0', '5', '0', '6', '1', '6', '4', '5', '4', '0', 'Z'}\n+\tvar result implicitTaggedTimeTest\n+\tif _, err := Unmarshal(der, &result); err != nil {\n+\t\tt.Fatalf(\"Error while parsing: %s\", err)\n+\t}\n+\tif expected := time.Date(1991, 05, 06, 16, 45, 40, 0, time.UTC); !result.Time.Equal(expected) {\n+\t\tt.Errorf(\"Wrong result. Got %v, want %v\", result.Time, expected)\n+\t}\n+}"}, {"sha": "b2f104b4cbe56817a5342038b13d31e3b5a80969", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -513,8 +513,22 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \t\treturn\n \t}\n \n-\tif params.optional && reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface()) {\n-\t\treturn\n+\tif params.optional && params.defaultValue != nil && canHaveDefaultValue(v.Kind()) {\n+\t\tdefaultValue := reflect.New(v.Type()).Elem()\n+\t\tdefaultValue.SetInt(*params.defaultValue)\n+\n+\t\tif reflect.DeepEqual(v.Interface(), defaultValue.Interface()) {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// If no default value is given then the zero value for the type is\n+\t// assumed to be the default value. This isn't obviously the correct\n+\t// behaviour, but it's what Go has traditionally done.\n+\tif params.optional && params.defaultValue == nil {\n+\t\tif reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface()) {\n+\t\t\treturn\n+\t\t}\n \t}\n \n \tif v.Type() == rawValueType {"}, {"sha": "5b0115f28c58f5f99c938503a519fbe44065428d", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -58,6 +58,10 @@ type omitEmptyTest struct {\n \tA []string `asn1:\"omitempty\"`\n }\n \n+type defaultTest struct {\n+\tA int `asn1:\"optional,default:1\"`\n+}\n+\n type testSET []int\n \n var PST = time.FixedZone(\"PST\", -8*60*60)\n@@ -133,6 +137,9 @@ var marshalTests = []marshalTest{\n \t{omitEmptyTest{[]string{}}, \"3000\"},\n \t{omitEmptyTest{[]string{\"1\"}}, \"30053003130131\"},\n \t{\"\u03a3\", \"0c02cea3\"},\n+\t{defaultTest{0}, \"3003020100\"},\n+\t{defaultTest{1}, \"3000\"},\n+\t{defaultTest{2}, \"3003020102\"},\n }\n \n func TestMarshal(t *testing.T) {"}, {"sha": "5a9e86919d80035a69febd7cc94eeabbf98db037", "filename": "libgo/go/encoding/base32/base32.go", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -73,45 +73,43 @@ func (enc *Encoding) Encode(dst, src []byte) {\n \t}\n \n \tfor len(src) > 0 {\n-\t\tdst[0] = 0\n-\t\tdst[1] = 0\n-\t\tdst[2] = 0\n-\t\tdst[3] = 0\n-\t\tdst[4] = 0\n-\t\tdst[5] = 0\n-\t\tdst[6] = 0\n-\t\tdst[7] = 0\n+\t\tvar b0, b1, b2, b3, b4, b5, b6, b7 byte\n \n \t\t// Unpack 8x 5-bit source blocks into a 5 byte\n \t\t// destination quantum\n \t\tswitch len(src) {\n \t\tdefault:\n-\t\t\tdst[7] |= src[4] & 0x1F\n-\t\t\tdst[6] |= src[4] >> 5\n+\t\t\tb7 = src[4] & 0x1F\n+\t\t\tb6 = src[4] >> 5\n \t\t\tfallthrough\n \t\tcase 4:\n-\t\t\tdst[6] |= (src[3] << 3) & 0x1F\n-\t\t\tdst[5] |= (src[3] >> 2) & 0x1F\n-\t\t\tdst[4] |= src[3] >> 7\n+\t\t\tb6 |= (src[3] << 3) & 0x1F\n+\t\t\tb5 = (src[3] >> 2) & 0x1F\n+\t\t\tb4 = src[3] >> 7\n \t\t\tfallthrough\n \t\tcase 3:\n-\t\t\tdst[4] |= (src[2] << 1) & 0x1F\n-\t\t\tdst[3] |= (src[2] >> 4) & 0x1F\n+\t\t\tb4 |= (src[2] << 1) & 0x1F\n+\t\t\tb3 = (src[2] >> 4) & 0x1F\n \t\t\tfallthrough\n \t\tcase 2:\n-\t\t\tdst[3] |= (src[1] << 4) & 0x1F\n-\t\t\tdst[2] |= (src[1] >> 1) & 0x1F\n-\t\t\tdst[1] |= (src[1] >> 6) & 0x1F\n+\t\t\tb3 |= (src[1] << 4) & 0x1F\n+\t\t\tb2 = (src[1] >> 1) & 0x1F\n+\t\t\tb1 = (src[1] >> 6) & 0x1F\n \t\t\tfallthrough\n \t\tcase 1:\n-\t\t\tdst[1] |= (src[0] << 2) & 0x1F\n-\t\t\tdst[0] |= src[0] >> 3\n+\t\t\tb1 |= (src[0] << 2) & 0x1F\n+\t\t\tb0 = src[0] >> 3\n \t\t}\n \n \t\t// Encode 5-bit blocks using the base32 alphabet\n-\t\tfor j := 0; j < 8; j++ {\n-\t\t\tdst[j] = enc.encode[dst[j]]\n-\t\t}\n+\t\tdst[0] = enc.encode[b0]\n+\t\tdst[1] = enc.encode[b1]\n+\t\tdst[2] = enc.encode[b2]\n+\t\tdst[3] = enc.encode[b3]\n+\t\tdst[4] = enc.encode[b4]\n+\t\tdst[5] = enc.encode[b5]\n+\t\tdst[6] = enc.encode[b6]\n+\t\tdst[7] = enc.encode[b7]\n \n \t\t// Pad the final quantum\n \t\tif len(src) < 5 {\n@@ -330,7 +328,7 @@ func (enc *Encoding) Decode(dst, src []byte) (n int, err error) {\n func (enc *Encoding) DecodeString(s string) ([]byte, error) {\n \ts = strings.Map(removeNewlinesMapper, s)\n \tdbuf := make([]byte, enc.DecodedLen(len(s)))\n-\tn, err := enc.Decode(dbuf, []byte(s))\n+\tn, _, err := enc.decode(dbuf, []byte(s))\n \treturn dbuf[:n], err\n }\n "}, {"sha": "5a68f06e1c94bc12e86fb2f91035fe3c1b3d4435", "filename": "libgo/go/encoding/base32/base32_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -284,3 +284,19 @@ LNEBUWIIDFON2CA3DBMJXXE5LNFY==\n \t\tt.Error(\"Decoded results not equal\")\n \t}\n }\n+\n+func BenchmarkEncodeToString(b *testing.B) {\n+\tdata := make([]byte, 8192)\n+\tb.SetBytes(int64(len(data)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tStdEncoding.EncodeToString(data)\n+\t}\n+}\n+\n+func BenchmarkDecodeString(b *testing.B) {\n+\tdata := StdEncoding.EncodeToString(make([]byte, 8192))\n+\tb.SetBytes(int64(len(data)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tStdEncoding.DecodeString(data)\n+\t}\n+}"}, {"sha": "ad3abe66239f8425f6d50747d824b7e8a49627e9", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -74,31 +74,29 @@ func (enc *Encoding) Encode(dst, src []byte) {\n \t}\n \n \tfor len(src) > 0 {\n-\t\tdst[0] = 0\n-\t\tdst[1] = 0\n-\t\tdst[2] = 0\n-\t\tdst[3] = 0\n+\t\tvar b0, b1, b2, b3 byte\n \n \t\t// Unpack 4x 6-bit source blocks into a 4 byte\n \t\t// destination quantum\n \t\tswitch len(src) {\n \t\tdefault:\n-\t\t\tdst[3] |= src[2] & 0x3F\n-\t\t\tdst[2] |= src[2] >> 6\n+\t\t\tb3 = src[2] & 0x3F\n+\t\t\tb2 = src[2] >> 6\n \t\t\tfallthrough\n \t\tcase 2:\n-\t\t\tdst[2] |= (src[1] << 2) & 0x3F\n-\t\t\tdst[1] |= src[1] >> 4\n+\t\t\tb2 |= (src[1] << 2) & 0x3F\n+\t\t\tb1 = src[1] >> 4\n \t\t\tfallthrough\n \t\tcase 1:\n-\t\t\tdst[1] |= (src[0] << 4) & 0x3F\n-\t\t\tdst[0] |= src[0] >> 2\n+\t\t\tb1 |= (src[0] << 4) & 0x3F\n+\t\t\tb0 = src[0] >> 2\n \t\t}\n \n \t\t// Encode 6-bit blocks using the base64 alphabet\n-\t\tfor j := 0; j < 4; j++ {\n-\t\t\tdst[j] = enc.encode[dst[j]]\n-\t\t}\n+\t\tdst[0] = enc.encode[b0]\n+\t\tdst[1] = enc.encode[b1]\n+\t\tdst[2] = enc.encode[b2]\n+\t\tdst[3] = enc.encode[b3]\n \n \t\t// Pad the final quantum\n \t\tif len(src) < 3 {\n@@ -295,7 +293,7 @@ func (enc *Encoding) Decode(dst, src []byte) (n int, err error) {\n func (enc *Encoding) DecodeString(s string) ([]byte, error) {\n \ts = strings.Map(removeNewlinesMapper, s)\n \tdbuf := make([]byte, enc.DecodedLen(len(s)))\n-\tn, err := enc.Decode(dbuf, []byte(s))\n+\tn, _, err := enc.decode(dbuf, []byte(s))\n \treturn dbuf[:n], err\n }\n "}, {"sha": "7d199bfa0893150d377b1059fde987512d1c07a4", "filename": "libgo/go/encoding/base64/base64_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -342,3 +342,19 @@ func TestDecoderIssue7733(t *testing.T) {\n \t\tt.Errorf(\"DecodeString = %q; want abcd\", s)\n \t}\n }\n+\n+func BenchmarkEncodeToString(b *testing.B) {\n+\tdata := make([]byte, 8192)\n+\tb.SetBytes(int64(len(data)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tStdEncoding.EncodeToString(data)\n+\t}\n+}\n+\n+func BenchmarkDecodeString(b *testing.B) {\n+\tdata := StdEncoding.EncodeToString(make([]byte, 8192))\n+\tb.SetBytes(int64(len(data)))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tStdEncoding.DecodeString(data)\n+\t}\n+}"}, {"sha": "466bf97c973b573ed00301b671c06d9ca5b2c579", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -10,9 +10,10 @@\n // type (int8, uint8, int16, float32, complex64, ...)\n // or an array or struct containing only fixed-size values.\n //\n-// Varints are a method of encoding integers using one or more bytes;\n-// numbers with smaller absolute value take a smaller number of bytes.\n-// For a specification, see http://code.google.com/apis/protocolbuffers/docs/encoding.html.\n+// The varint functions encode and decode single integer values using\n+// a variable-length encoding; smaller values require fewer bytes.\n+// For a specification, see\n+// http://code.google.com/apis/protocolbuffers/docs/encoding.html.\n //\n // This package favors simplicity over efficiency. Clients that require\n // high-performance serialization, especially for large data structures,\n@@ -199,18 +200,17 @@ func Read(r io.Reader, order ByteOrder, data interface{}) error {\n \t}\n \n \t// Fallback to reflect-based decoding.\n-\tvar v reflect.Value\n-\tswitch d := reflect.ValueOf(data); d.Kind() {\n+\tv := reflect.ValueOf(data)\n+\tsize := -1\n+\tswitch v.Kind() {\n \tcase reflect.Ptr:\n-\t\tv = d.Elem()\n+\t\tv = v.Elem()\n+\t\tsize = dataSize(v)\n \tcase reflect.Slice:\n-\t\tv = d\n-\tdefault:\n-\t\treturn errors.New(\"binary.Read: invalid type \" + d.Type().String())\n+\t\tsize = dataSize(v)\n \t}\n-\tsize, err := dataSize(v)\n-\tif err != nil {\n-\t\treturn errors.New(\"binary.Read: \" + err.Error())\n+\tif size < 0 {\n+\t\treturn errors.New(\"binary.Read: invalid type \" + reflect.TypeOf(data).String())\n \t}\n \td := &decoder{order: order, buf: make([]byte, size)}\n \tif _, err := io.ReadFull(r, d.buf); err != nil {\n@@ -323,68 +323,64 @@ func Write(w io.Writer, order ByteOrder, data interface{}) error {\n \n \t// Fallback to reflect-based encoding.\n \tv := reflect.Indirect(reflect.ValueOf(data))\n-\tsize, err := dataSize(v)\n-\tif err != nil {\n-\t\treturn errors.New(\"binary.Write: \" + err.Error())\n+\tsize := dataSize(v)\n+\tif size < 0 {\n+\t\treturn errors.New(\"binary.Write: invalid type \" + reflect.TypeOf(data).String())\n \t}\n \tbuf := make([]byte, size)\n \te := &encoder{order: order, buf: buf}\n \te.value(v)\n-\t_, err = w.Write(buf)\n+\t_, err := w.Write(buf)\n \treturn err\n }\n \n // Size returns how many bytes Write would generate to encode the value v, which\n // must be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\n+// If v is neither of these, Size returns -1.\n func Size(v interface{}) int {\n-\tn, err := dataSize(reflect.Indirect(reflect.ValueOf(v)))\n-\tif err != nil {\n-\t\treturn -1\n-\t}\n-\treturn n\n+\treturn dataSize(reflect.Indirect(reflect.ValueOf(v)))\n }\n \n // dataSize returns the number of bytes the actual data represented by v occupies in memory.\n // For compound structures, it sums the sizes of the elements. Thus, for instance, for a slice\n // it returns the length of the slice times the element size and does not count the memory\n-// occupied by the header.\n-func dataSize(v reflect.Value) (int, error) {\n+// occupied by the header. If the type of v is not acceptable, dataSize returns -1.\n+func dataSize(v reflect.Value) int {\n \tif v.Kind() == reflect.Slice {\n-\t\telem, err := sizeof(v.Type().Elem())\n-\t\tif err != nil {\n-\t\t\treturn 0, err\n+\t\tif s := sizeof(v.Type().Elem()); s >= 0 {\n+\t\t\treturn s * v.Len()\n \t\t}\n-\t\treturn v.Len() * elem, nil\n+\t\treturn -1\n \t}\n \treturn sizeof(v.Type())\n }\n \n-func sizeof(t reflect.Type) (int, error) {\n+// sizeof returns the size >= 0 of variables for the given type or -1 if the type is not acceptable.\n+func sizeof(t reflect.Type) int {\n \tswitch t.Kind() {\n \tcase reflect.Array:\n-\t\tn, err := sizeof(t.Elem())\n-\t\tif err != nil {\n-\t\t\treturn 0, err\n+\t\tif s := sizeof(t.Elem()); s >= 0 {\n+\t\t\treturn s * t.Len()\n \t\t}\n-\t\treturn t.Len() * n, nil\n \n \tcase reflect.Struct:\n \t\tsum := 0\n \t\tfor i, n := 0, t.NumField(); i < n; i++ {\n-\t\t\ts, err := sizeof(t.Field(i).Type)\n-\t\t\tif err != nil {\n-\t\t\t\treturn 0, err\n+\t\t\ts := sizeof(t.Field(i).Type)\n+\t\t\tif s < 0 {\n+\t\t\t\treturn -1\n \t\t\t}\n \t\t\tsum += s\n \t\t}\n-\t\treturn sum, nil\n+\t\treturn sum\n \n \tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n \t\treflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n \t\treflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128:\n-\t\treturn int(t.Size()), nil\n+\t\treturn int(t.Size())\n \t}\n-\treturn 0, errors.New(\"invalid type \" + t.String())\n+\n+\treturn -1\n }\n \n type coder struct {\n@@ -594,12 +590,11 @@ func (e *encoder) value(v reflect.Value) {\n }\n \n func (d *decoder) skip(v reflect.Value) {\n-\tn, _ := dataSize(v)\n-\td.buf = d.buf[n:]\n+\td.buf = d.buf[dataSize(v):]\n }\n \n func (e *encoder) skip(v reflect.Value) {\n-\tn, _ := dataSize(v)\n+\tn := dataSize(v)\n \tfor i := range e.buf[0:n] {\n \t\te.buf[i] = 0\n \t}"}, {"sha": "8ee595fa476aabb677c87b08a065aec30b90af8c", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -289,6 +289,26 @@ func TestUnexportedRead(t *testing.T) {\n \tRead(&buf, LittleEndian, &u2)\n }\n \n+func TestReadErrorMsg(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tread := func(data interface{}) {\n+\t\terr := Read(&buf, LittleEndian, data)\n+\t\twant := \"binary.Read: invalid type \" + reflect.TypeOf(data).String()\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"%T: got no error; want %q\", data, want)\n+\t\t\treturn\n+\t\t}\n+\t\tif got := err.Error(); got != want {\n+\t\t\tt.Errorf(\"%T: got %q; want %q\", data, got, want)\n+\t\t}\n+\t}\n+\tread(0)\n+\ts := new(struct{})\n+\tread(&s)\n+\tp := &s\n+\tread(&p)\n+}\n+\n type byteSliceReader struct {\n \tremain []byte\n }\n@@ -315,8 +335,7 @@ func BenchmarkReadStruct(b *testing.B) {\n \tbsr := &byteSliceReader{}\n \tvar buf bytes.Buffer\n \tWrite(&buf, BigEndian, &s)\n-\tn, _ := dataSize(reflect.ValueOf(s))\n-\tb.SetBytes(int64(n))\n+\tb.SetBytes(int64(dataSize(reflect.ValueOf(s))))\n \tt := s\n \tb.ResetTimer()\n \tfor i := 0; i < b.N; i++ {"}, {"sha": "17e7bb7f5c79bf53f5693a36538d3f6efc1c695f", "filename": "libgo/go/encoding/csv/writer.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -115,10 +115,22 @@ func (w *Writer) WriteAll(records [][]string) (err error) {\n }\n \n // fieldNeedsQuotes returns true if our field must be enclosed in quotes.\n-// Empty fields, files with a Comma, fields with a quote or newline, and\n+// Fields with a Comma, fields with a quote or newline, and\n // fields which start with a space must be enclosed in quotes.\n+// We used to quote empty strings, but we do not anymore (as of Go 1.4).\n+// The two representations should be equivalent, but Postgres distinguishes\n+// quoted vs non-quoted empty string during database imports, and it has\n+// an option to force the quoted behavior for non-quoted CSV but it has\n+// no option to force the non-quoted behavior for quoted CSV, making\n+// CSV with quoted empty strings strictly less useful.\n+// Not quoting the empty string also makes this package match the behavior\n+// of Microsoft Excel and Google Drive.\n+// For Postgres, quote the data termating string `\\.`.\n func (w *Writer) fieldNeedsQuotes(field string) bool {\n-\tif len(field) == 0 || strings.IndexRune(field, w.Comma) >= 0 || strings.IndexAny(field, \"\\\"\\r\\n\") >= 0 {\n+\tif field == \"\" {\n+\t\treturn false\n+\t}\n+\tif field == `\\.` || strings.IndexRune(field, w.Comma) >= 0 || strings.IndexAny(field, \"\\\"\\r\\n\") >= 0 {\n \t\treturn true\n \t}\n "}, {"sha": "8ddca0abe0c13f09e13bc4a30718d09d17829541", "filename": "libgo/go/encoding/csv/writer_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -28,6 +28,17 @@ var writeTests = []struct {\n \t{Input: [][]string{{\"abc\\ndef\"}}, Output: \"\\\"abc\\r\\ndef\\\"\\r\\n\", UseCRLF: true},\n \t{Input: [][]string{{\"abc\\rdef\"}}, Output: \"\\\"abcdef\\\"\\r\\n\", UseCRLF: true},\n \t{Input: [][]string{{\"abc\\rdef\"}}, Output: \"\\\"abc\\rdef\\\"\\n\", UseCRLF: false},\n+\t{Input: [][]string{{\"\"}}, Output: \"\\n\"},\n+\t{Input: [][]string{{\"\", \"\"}}, Output: \",\\n\"},\n+\t{Input: [][]string{{\"\", \"\", \"\"}}, Output: \",,\\n\"},\n+\t{Input: [][]string{{\"\", \"\", \"a\"}}, Output: \",,a\\n\"},\n+\t{Input: [][]string{{\"\", \"a\", \"\"}}, Output: \",a,\\n\"},\n+\t{Input: [][]string{{\"\", \"a\", \"a\"}}, Output: \",a,a\\n\"},\n+\t{Input: [][]string{{\"a\", \"\", \"\"}}, Output: \"a,,\\n\"},\n+\t{Input: [][]string{{\"a\", \"\", \"a\"}}, Output: \"a,,a\\n\"},\n+\t{Input: [][]string{{\"a\", \"a\", \"\"}}, Output: \"a,a,\\n\"},\n+\t{Input: [][]string{{\"a\", \"a\", \"a\"}}, Output: \"a,a,a\\n\"},\n+\t{Input: [][]string{{`\\.`}}, Output: \"\\\"\\\\.\\\"\\n\"},\n }\n \n func TestWrite(t *testing.T) {"}, {"sha": "56a7298fa5583603fa22c68423850830c714eba0", "filename": "libgo/go/encoding/gob/codec_test.go", "status": "modified", "additions": 151, "deletions": 182, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -14,7 +14,6 @@ import (\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n-\t\"unsafe\"\n )\n \n var doFuzzTests = flag.Bool(\"gob.fuzz\", false, \"run the fuzz tests, which are large and very slow\")\n@@ -51,10 +50,16 @@ func testError(t *testing.T) {\n \treturn\n }\n \n+func newDecBuffer(data []byte) *decBuffer {\n+\treturn &decBuffer{\n+\t\tdata: data,\n+\t}\n+}\n+\n // Test basic encode/decode routines for unsigned integers\n func TestUintCodec(t *testing.T) {\n \tdefer testError(t)\n-\tb := new(bytes.Buffer)\n+\tb := new(encBuffer)\n \tencState := newEncoderState(b)\n \tfor _, tt := range encodeT {\n \t\tb.Reset()\n@@ -63,10 +68,10 @@ func TestUintCodec(t *testing.T) {\n \t\t\tt.Errorf(\"encodeUint: %#x encode: expected % x got % x\", tt.x, tt.b, b.Bytes())\n \t\t}\n \t}\n-\tdecState := newDecodeState(b)\n \tfor u := uint64(0); ; u = (u + 1) * 7 {\n \t\tb.Reset()\n \t\tencState.encodeUint(u)\n+\t\tdecState := newDecodeState(newDecBuffer(b.Bytes()))\n \t\tv := decState.decodeUint()\n \t\tif u != v {\n \t\t\tt.Errorf(\"Encode/Decode: sent %#x received %#x\", u, v)\n@@ -79,10 +84,10 @@ func TestUintCodec(t *testing.T) {\n \n func verifyInt(i int64, t *testing.T) {\n \tdefer testError(t)\n-\tvar b = new(bytes.Buffer)\n+\tvar b = new(encBuffer)\n \tencState := newEncoderState(b)\n \tencState.encodeInt(i)\n-\tdecState := newDecodeState(b)\n+\tdecState := newDecodeState(newDecBuffer(b.Bytes()))\n \tdecState.buf = make([]byte, 8)\n \tj := decState.decodeInt()\n \tif i != j {\n@@ -119,14 +124,14 @@ var complexResult = []byte{0x07, 0xFE, 0x31, 0x40, 0xFE, 0x33, 0x40}\n // The result of encoding \"hello\" with field number 7\n var bytesResult = []byte{0x07, 0x05, 'h', 'e', 'l', 'l', 'o'}\n \n-func newDecodeState(buf *bytes.Buffer) *decoderState {\n+func newDecodeState(buf *decBuffer) *decoderState {\n \td := new(decoderState)\n \td.b = buf\n \td.buf = make([]byte, uint64Size)\n \treturn d\n }\n \n-func newEncoderState(b *bytes.Buffer) *encoderState {\n+func newEncoderState(b *encBuffer) *encoderState {\n \tb.Reset()\n \tstate := &encoderState{enc: nil, b: b}\n \tstate.fieldnum = -1\n@@ -136,14 +141,14 @@ func newEncoderState(b *bytes.Buffer) *encoderState {\n // Test instruction execution for encoding.\n // Do not run the machine yet; instead do individual instructions crafted by hand.\n func TestScalarEncInstructions(t *testing.T) {\n-\tvar b = new(bytes.Buffer)\n+\tvar b = new(encBuffer)\n \n \t// bool\n \t{\n-\t\tdata := struct{ a bool }{true}\n-\t\tinstr := &encInstr{encBool, 6, 0, 0}\n+\t\tvar data bool = true\n+\t\tinstr := &encInstr{encBool, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(boolResult, b.Bytes()) {\n \t\t\tt.Errorf(\"bool enc instructions: expected % x got % x\", boolResult, b.Bytes())\n \t\t}\n@@ -152,10 +157,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// int\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a int }{17}\n-\t\tinstr := &encInstr{encInt, 6, 0, 0}\n+\t\tvar data int = 17\n+\t\tinstr := &encInstr{encInt, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int enc instructions: expected % x got % x\", signedResult, b.Bytes())\n \t\t}\n@@ -164,10 +169,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// uint\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a uint }{17}\n-\t\tinstr := &encInstr{encUint, 6, 0, 0}\n+\t\tvar data uint = 17\n+\t\tinstr := &encInstr{encUint, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n \t\t}\n@@ -176,10 +181,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// int8\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a int8 }{17}\n-\t\tinstr := &encInstr{encInt8, 6, 0, 0}\n+\t\tvar data int8 = 17\n+\t\tinstr := &encInstr{encInt, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int8 enc instructions: expected % x got % x\", signedResult, b.Bytes())\n \t\t}\n@@ -188,10 +193,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// uint8\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a uint8 }{17}\n-\t\tinstr := &encInstr{encUint8, 6, 0, 0}\n+\t\tvar data uint8 = 17\n+\t\tinstr := &encInstr{encUint, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint8 enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n \t\t}\n@@ -200,10 +205,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// int16\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a int16 }{17}\n-\t\tinstr := &encInstr{encInt16, 6, 0, 0}\n+\t\tvar data int16 = 17\n+\t\tinstr := &encInstr{encInt, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int16 enc instructions: expected % x got % x\", signedResult, b.Bytes())\n \t\t}\n@@ -212,10 +217,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// uint16\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a uint16 }{17}\n-\t\tinstr := &encInstr{encUint16, 6, 0, 0}\n+\t\tvar data uint16 = 17\n+\t\tinstr := &encInstr{encUint, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint16 enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n \t\t}\n@@ -224,10 +229,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// int32\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a int32 }{17}\n-\t\tinstr := &encInstr{encInt32, 6, 0, 0}\n+\t\tvar data int32 = 17\n+\t\tinstr := &encInstr{encInt, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int32 enc instructions: expected % x got % x\", signedResult, b.Bytes())\n \t\t}\n@@ -236,10 +241,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// uint32\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a uint32 }{17}\n-\t\tinstr := &encInstr{encUint32, 6, 0, 0}\n+\t\tvar data uint32 = 17\n+\t\tinstr := &encInstr{encUint, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint32 enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n \t\t}\n@@ -248,10 +253,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// int64\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a int64 }{17}\n-\t\tinstr := &encInstr{encInt64, 6, 0, 0}\n+\t\tvar data int64 = 17\n+\t\tinstr := &encInstr{encInt, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int64 enc instructions: expected % x got % x\", signedResult, b.Bytes())\n \t\t}\n@@ -260,10 +265,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// uint64\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a uint64 }{17}\n-\t\tinstr := &encInstr{encUint64, 6, 0, 0}\n+\t\tvar data uint64 = 17\n+\t\tinstr := &encInstr{encUint, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint64 enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n \t\t}\n@@ -272,10 +277,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// float32\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a float32 }{17}\n-\t\tinstr := &encInstr{encFloat32, 6, 0, 0}\n+\t\tvar data float32 = 17\n+\t\tinstr := &encInstr{encFloat, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(floatResult, b.Bytes()) {\n \t\t\tt.Errorf(\"float32 enc instructions: expected % x got % x\", floatResult, b.Bytes())\n \t\t}\n@@ -284,10 +289,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// float64\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a float64 }{17}\n-\t\tinstr := &encInstr{encFloat64, 6, 0, 0}\n+\t\tvar data float64 = 17\n+\t\tinstr := &encInstr{encFloat, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(floatResult, b.Bytes()) {\n \t\t\tt.Errorf(\"float64 enc instructions: expected % x got % x\", floatResult, b.Bytes())\n \t\t}\n@@ -296,10 +301,10 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// bytes == []uint8\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a []byte }{[]byte(\"hello\")}\n-\t\tinstr := &encInstr{encUint8Array, 6, 0, 0}\n+\t\tdata := []byte(\"hello\")\n+\t\tinstr := &encInstr{encUint8Array, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(bytesResult, b.Bytes()) {\n \t\t\tt.Errorf(\"bytes enc instructions: expected % x got % x\", bytesResult, b.Bytes())\n \t\t}\n@@ -308,28 +313,28 @@ func TestScalarEncInstructions(t *testing.T) {\n \t// string\n \t{\n \t\tb.Reset()\n-\t\tdata := struct{ a string }{\"hello\"}\n-\t\tinstr := &encInstr{encString, 6, 0, 0}\n+\t\tvar data string = \"hello\"\n+\t\tinstr := &encInstr{encString, 6, nil, 0}\n \t\tstate := newEncoderState(b)\n-\t\tinstr.op(instr, state, unsafe.Pointer(&data))\n+\t\tinstr.op(instr, state, reflect.ValueOf(data))\n \t\tif !bytes.Equal(bytesResult, b.Bytes()) {\n \t\t\tt.Errorf(\"string enc instructions: expected % x got % x\", bytesResult, b.Bytes())\n \t\t}\n \t}\n }\n \n-func execDec(typ string, instr *decInstr, state *decoderState, t *testing.T, p unsafe.Pointer) {\n+func execDec(typ string, instr *decInstr, state *decoderState, t *testing.T, value reflect.Value) {\n \tdefer testError(t)\n \tv := int(state.decodeUint())\n \tif v+state.fieldnum != 6 {\n \t\tt.Fatalf(\"decoding field number %d, got %d\", 6, v+state.fieldnum)\n \t}\n-\tinstr.op(instr, state, decIndirect(p, instr.indir))\n+\tinstr.op(instr, state, value.Elem())\n \tstate.fieldnum = 6\n }\n \n func newDecodeStateFromData(data []byte) *decoderState {\n-\tb := bytes.NewBuffer(data)\n+\tb := newDecBuffer(data)\n \tstate := newDecodeState(b)\n \tstate.fieldnum = -1\n \treturn state\n@@ -342,234 +347,198 @@ func TestScalarDecInstructions(t *testing.T) {\n \n \t// bool\n \t{\n-\t\tvar data struct {\n-\t\t\ta bool\n-\t\t}\n-\t\tinstr := &decInstr{decBool, 6, 0, 0, ovfl}\n+\t\tvar data bool\n+\t\tinstr := &decInstr{decBool, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(boolResult)\n-\t\texecDec(\"bool\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != true {\n-\t\t\tt.Errorf(\"bool a = %v not true\", data.a)\n+\t\texecDec(\"bool\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != true {\n+\t\t\tt.Errorf(\"bool a = %v not true\", data)\n \t\t}\n \t}\n \t// int\n \t{\n-\t\tvar data struct {\n-\t\t\ta int\n-\t\t}\n-\t\tinstr := &decInstr{decOpTable[reflect.Int], 6, 0, 0, ovfl}\n+\t\tvar data int\n+\t\tinstr := &decInstr{decOpTable[reflect.Int], 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(signedResult)\n-\t\texecDec(\"int\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"int a = %v not 17\", data.a)\n+\t\texecDec(\"int\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"int a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// uint\n \t{\n-\t\tvar data struct {\n-\t\t\ta uint\n-\t\t}\n-\t\tinstr := &decInstr{decOpTable[reflect.Uint], 6, 0, 0, ovfl}\n+\t\tvar data uint\n+\t\tinstr := &decInstr{decOpTable[reflect.Uint], 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(unsignedResult)\n-\t\texecDec(\"uint\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"uint a = %v not 17\", data.a)\n+\t\texecDec(\"uint\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"uint a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// int8\n \t{\n-\t\tvar data struct {\n-\t\t\ta int8\n-\t\t}\n-\t\tinstr := &decInstr{decInt8, 6, 0, 0, ovfl}\n+\t\tvar data int8\n+\t\tinstr := &decInstr{decInt8, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(signedResult)\n-\t\texecDec(\"int8\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"int8 a = %v not 17\", data.a)\n+\t\texecDec(\"int8\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"int8 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// uint8\n \t{\n-\t\tvar data struct {\n-\t\t\ta uint8\n-\t\t}\n-\t\tinstr := &decInstr{decUint8, 6, 0, 0, ovfl}\n+\t\tvar data uint8\n+\t\tinstr := &decInstr{decUint8, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(unsignedResult)\n-\t\texecDec(\"uint8\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"uint8 a = %v not 17\", data.a)\n+\t\texecDec(\"uint8\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"uint8 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// int16\n \t{\n-\t\tvar data struct {\n-\t\t\ta int16\n-\t\t}\n-\t\tinstr := &decInstr{decInt16, 6, 0, 0, ovfl}\n+\t\tvar data int16\n+\t\tinstr := &decInstr{decInt16, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(signedResult)\n-\t\texecDec(\"int16\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"int16 a = %v not 17\", data.a)\n+\t\texecDec(\"int16\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"int16 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// uint16\n \t{\n-\t\tvar data struct {\n-\t\t\ta uint16\n-\t\t}\n-\t\tinstr := &decInstr{decUint16, 6, 0, 0, ovfl}\n+\t\tvar data uint16\n+\t\tinstr := &decInstr{decUint16, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(unsignedResult)\n-\t\texecDec(\"uint16\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"uint16 a = %v not 17\", data.a)\n+\t\texecDec(\"uint16\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"uint16 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// int32\n \t{\n-\t\tvar data struct {\n-\t\t\ta int32\n-\t\t}\n-\t\tinstr := &decInstr{decInt32, 6, 0, 0, ovfl}\n+\t\tvar data int32\n+\t\tinstr := &decInstr{decInt32, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(signedResult)\n-\t\texecDec(\"int32\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"int32 a = %v not 17\", data.a)\n+\t\texecDec(\"int32\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"int32 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// uint32\n \t{\n-\t\tvar data struct {\n-\t\t\ta uint32\n-\t\t}\n-\t\tinstr := &decInstr{decUint32, 6, 0, 0, ovfl}\n+\t\tvar data uint32\n+\t\tinstr := &decInstr{decUint32, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(unsignedResult)\n-\t\texecDec(\"uint32\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"uint32 a = %v not 17\", data.a)\n+\t\texecDec(\"uint32\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"uint32 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// uintptr\n \t{\n-\t\tvar data struct {\n-\t\t\ta uintptr\n-\t\t}\n-\t\tinstr := &decInstr{decOpTable[reflect.Uintptr], 6, 0, 0, ovfl}\n+\t\tvar data uintptr\n+\t\tinstr := &decInstr{decOpTable[reflect.Uintptr], 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(unsignedResult)\n-\t\texecDec(\"uintptr\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"uintptr a = %v not 17\", data.a)\n+\t\texecDec(\"uintptr\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"uintptr a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// int64\n \t{\n-\t\tvar data struct {\n-\t\t\ta int64\n-\t\t}\n-\t\tinstr := &decInstr{decInt64, 6, 0, 0, ovfl}\n+\t\tvar data int64\n+\t\tinstr := &decInstr{decInt64, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(signedResult)\n-\t\texecDec(\"int64\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"int64 a = %v not 17\", data.a)\n+\t\texecDec(\"int64\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"int64 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// uint64\n \t{\n-\t\tvar data struct {\n-\t\t\ta uint64\n-\t\t}\n-\t\tinstr := &decInstr{decUint64, 6, 0, 0, ovfl}\n+\t\tvar data uint64\n+\t\tinstr := &decInstr{decUint64, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(unsignedResult)\n-\t\texecDec(\"uint64\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"uint64 a = %v not 17\", data.a)\n+\t\texecDec(\"uint64\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"uint64 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// float32\n \t{\n-\t\tvar data struct {\n-\t\t\ta float32\n-\t\t}\n-\t\tinstr := &decInstr{decFloat32, 6, 0, 0, ovfl}\n+\t\tvar data float32\n+\t\tinstr := &decInstr{decFloat32, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(floatResult)\n-\t\texecDec(\"float32\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"float32 a = %v not 17\", data.a)\n+\t\texecDec(\"float32\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"float32 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// float64\n \t{\n-\t\tvar data struct {\n-\t\t\ta float64\n-\t\t}\n-\t\tinstr := &decInstr{decFloat64, 6, 0, 0, ovfl}\n+\t\tvar data float64\n+\t\tinstr := &decInstr{decFloat64, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(floatResult)\n-\t\texecDec(\"float64\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17 {\n-\t\t\tt.Errorf(\"float64 a = %v not 17\", data.a)\n+\t\texecDec(\"float64\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17 {\n+\t\t\tt.Errorf(\"float64 a = %v not 17\", data)\n \t\t}\n \t}\n \n \t// complex64\n \t{\n-\t\tvar data struct {\n-\t\t\ta complex64\n-\t\t}\n-\t\tinstr := &decInstr{decOpTable[reflect.Complex64], 6, 0, 0, ovfl}\n+\t\tvar data complex64\n+\t\tinstr := &decInstr{decOpTable[reflect.Complex64], 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(complexResult)\n-\t\texecDec(\"complex\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17+19i {\n-\t\t\tt.Errorf(\"complex a = %v not 17+19i\", data.a)\n+\t\texecDec(\"complex\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17+19i {\n+\t\t\tt.Errorf(\"complex a = %v not 17+19i\", data)\n \t\t}\n \t}\n \n \t// complex128\n \t{\n-\t\tvar data struct {\n-\t\t\ta complex128\n-\t\t}\n-\t\tinstr := &decInstr{decOpTable[reflect.Complex128], 6, 0, 0, ovfl}\n+\t\tvar data complex128\n+\t\tinstr := &decInstr{decOpTable[reflect.Complex128], 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(complexResult)\n-\t\texecDec(\"complex\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != 17+19i {\n-\t\t\tt.Errorf(\"complex a = %v not 17+19i\", data.a)\n+\t\texecDec(\"complex\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != 17+19i {\n+\t\t\tt.Errorf(\"complex a = %v not 17+19i\", data)\n \t\t}\n \t}\n \n \t// bytes == []uint8\n \t{\n-\t\tvar data struct {\n-\t\t\ta []byte\n-\t\t}\n-\t\tinstr := &decInstr{decUint8Slice, 6, 0, 0, ovfl}\n+\t\tvar data []byte\n+\t\tinstr := &decInstr{decUint8Slice, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(bytesResult)\n-\t\texecDec(\"bytes\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif string(data.a) != \"hello\" {\n-\t\t\tt.Errorf(`bytes a = %q not \"hello\"`, string(data.a))\n+\t\texecDec(\"bytes\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif string(data) != \"hello\" {\n+\t\t\tt.Errorf(`bytes a = %q not \"hello\"`, string(data))\n \t\t}\n \t}\n \n \t// string\n \t{\n-\t\tvar data struct {\n-\t\t\ta string\n-\t\t}\n-\t\tinstr := &decInstr{decString, 6, 0, 0, ovfl}\n+\t\tvar data string\n+\t\tinstr := &decInstr{decString, 6, nil, ovfl}\n \t\tstate := newDecodeStateFromData(bytesResult)\n-\t\texecDec(\"bytes\", instr, state, t, unsafe.Pointer(&data))\n-\t\tif data.a != \"hello\" {\n-\t\t\tt.Errorf(`bytes a = %q not \"hello\"`, data.a)\n+\t\texecDec(\"bytes\", instr, state, t, reflect.ValueOf(&data))\n+\t\tif data != \"hello\" {\n+\t\t\tt.Errorf(`bytes a = %q not \"hello\"`, data)\n \t\t}\n \t}\n }"}, {"sha": "536bbdb5ac6a5397330a21d3c5e5743e826e3ad4", "filename": "libgo/go/encoding/gob/debug.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -306,7 +306,7 @@ func (deb *debugger) common() CommonType {\n \t\t\t// Id typeId\n \t\t\tid = deb.typeId()\n \t\tdefault:\n-\t\t\terrorf(\"corrupted CommonType\")\n+\t\t\terrorf(\"corrupted CommonType, delta is %d fieldNum is %d\", delta, fieldNum)\n \t\t}\n \t}\n \treturn CommonType{name, id}\n@@ -598,11 +598,11 @@ func (deb *debugger) printBuiltin(indent tab, id typeId) {\n \t\tfmt.Fprintf(os.Stderr, \"%s%d\\n\", indent, x)\n \tcase tFloat:\n \t\tx := deb.uint64()\n-\t\tfmt.Fprintf(os.Stderr, \"%s%g\\n\", indent, floatFromBits(x))\n+\t\tfmt.Fprintf(os.Stderr, \"%s%g\\n\", indent, float64FromBits(x))\n \tcase tComplex:\n \t\tr := deb.uint64()\n \t\ti := deb.uint64()\n-\t\tfmt.Fprintf(os.Stderr, \"%s%g+%gi\\n\", indent, floatFromBits(r), floatFromBits(i))\n+\t\tfmt.Fprintf(os.Stderr, \"%s%g+%gi\\n\", indent, float64FromBits(r), float64FromBits(i))\n \tcase tBytes:\n \t\tx := int(deb.uint64())\n \t\tb := make([]byte, x)"}, {"sha": "a1b67661d8f5f1f959ee358a8192d0c0ef712301", "filename": "libgo/go/encoding/gob/dec_helpers.go", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdec_helpers.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdec_helpers.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdec_helpers.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,468 @@\n+// Created by decgen --output dec_helpers.go; DO NOT EDIT\n+\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package gob\n+\n+import (\n+\t\"math\"\n+\t\"reflect\"\n+)\n+\n+var decArrayHelper = map[reflect.Kind]decHelper{\n+\treflect.Bool:       decBoolArray,\n+\treflect.Complex64:  decComplex64Array,\n+\treflect.Complex128: decComplex128Array,\n+\treflect.Float32:    decFloat32Array,\n+\treflect.Float64:    decFloat64Array,\n+\treflect.Int:        decIntArray,\n+\treflect.Int16:      decInt16Array,\n+\treflect.Int32:      decInt32Array,\n+\treflect.Int64:      decInt64Array,\n+\treflect.Int8:       decInt8Array,\n+\treflect.String:     decStringArray,\n+\treflect.Uint:       decUintArray,\n+\treflect.Uint16:     decUint16Array,\n+\treflect.Uint32:     decUint32Array,\n+\treflect.Uint64:     decUint64Array,\n+\treflect.Uintptr:    decUintptrArray,\n+}\n+\n+var decSliceHelper = map[reflect.Kind]decHelper{\n+\treflect.Bool:       decBoolSlice,\n+\treflect.Complex64:  decComplex64Slice,\n+\treflect.Complex128: decComplex128Slice,\n+\treflect.Float32:    decFloat32Slice,\n+\treflect.Float64:    decFloat64Slice,\n+\treflect.Int:        decIntSlice,\n+\treflect.Int16:      decInt16Slice,\n+\treflect.Int32:      decInt32Slice,\n+\treflect.Int64:      decInt64Slice,\n+\treflect.Int8:       decInt8Slice,\n+\treflect.String:     decStringSlice,\n+\treflect.Uint:       decUintSlice,\n+\treflect.Uint16:     decUint16Slice,\n+\treflect.Uint32:     decUint32Slice,\n+\treflect.Uint64:     decUint64Slice,\n+\treflect.Uintptr:    decUintptrSlice,\n+}\n+\n+func decBoolArray(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decBoolSlice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decBoolSlice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]bool)\n+\tif !ok {\n+\t\t// It is kind bool but not type bool. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding bool array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tslice[i] = state.decodeUint() != 0\n+\t}\n+\treturn true\n+}\n+\n+func decComplex64Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decComplex64Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decComplex64Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]complex64)\n+\tif !ok {\n+\t\t// It is kind complex64 but not type complex64. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding complex64 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\treal := float32FromBits(state.decodeUint(), ovfl)\n+\t\timag := float32FromBits(state.decodeUint(), ovfl)\n+\t\tslice[i] = complex(float32(real), float32(imag))\n+\t}\n+\treturn true\n+}\n+\n+func decComplex128Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decComplex128Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decComplex128Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]complex128)\n+\tif !ok {\n+\t\t// It is kind complex128 but not type complex128. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding complex128 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\treal := float64FromBits(state.decodeUint())\n+\t\timag := float64FromBits(state.decodeUint())\n+\t\tslice[i] = complex(real, imag)\n+\t}\n+\treturn true\n+}\n+\n+func decFloat32Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decFloat32Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decFloat32Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]float32)\n+\tif !ok {\n+\t\t// It is kind float32 but not type float32. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding float32 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tslice[i] = float32(float32FromBits(state.decodeUint(), ovfl))\n+\t}\n+\treturn true\n+}\n+\n+func decFloat64Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decFloat64Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decFloat64Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]float64)\n+\tif !ok {\n+\t\t// It is kind float64 but not type float64. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding float64 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tslice[i] = float64FromBits(state.decodeUint())\n+\t}\n+\treturn true\n+}\n+\n+func decIntArray(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decIntSlice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decIntSlice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]int)\n+\tif !ok {\n+\t\t// It is kind int but not type int. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding int array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tx := state.decodeInt()\n+\t\t// MinInt and MaxInt\n+\t\tif x < ^int64(^uint(0)>>1) || int64(^uint(0)>>1) < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = int(x)\n+\t}\n+\treturn true\n+}\n+\n+func decInt16Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decInt16Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decInt16Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]int16)\n+\tif !ok {\n+\t\t// It is kind int16 but not type int16. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding int16 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tx := state.decodeInt()\n+\t\tif x < math.MinInt16 || math.MaxInt16 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = int16(x)\n+\t}\n+\treturn true\n+}\n+\n+func decInt32Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decInt32Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decInt32Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]int32)\n+\tif !ok {\n+\t\t// It is kind int32 but not type int32. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding int32 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tx := state.decodeInt()\n+\t\tif x < math.MinInt32 || math.MaxInt32 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = int32(x)\n+\t}\n+\treturn true\n+}\n+\n+func decInt64Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decInt64Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decInt64Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]int64)\n+\tif !ok {\n+\t\t// It is kind int64 but not type int64. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding int64 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tslice[i] = state.decodeInt()\n+\t}\n+\treturn true\n+}\n+\n+func decInt8Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decInt8Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decInt8Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]int8)\n+\tif !ok {\n+\t\t// It is kind int8 but not type int8. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding int8 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tx := state.decodeInt()\n+\t\tif x < math.MinInt8 || math.MaxInt8 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = int8(x)\n+\t}\n+\treturn true\n+}\n+\n+func decStringArray(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decStringSlice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decStringSlice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]string)\n+\tif !ok {\n+\t\t// It is kind string but not type string. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding string array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tu := state.decodeUint()\n+\t\tn := int(u)\n+\t\tif n < 0 || uint64(n) != u || n > state.b.Len() {\n+\t\t\terrorf(\"length of string exceeds input size (%d bytes)\", u)\n+\t\t}\n+\t\tif n > state.b.Len() {\n+\t\t\terrorf(\"string data too long for buffer: %d\", n)\n+\t\t}\n+\t\t// Read the data.\n+\t\tdata := make([]byte, n)\n+\t\tif _, err := state.b.Read(data); err != nil {\n+\t\t\terrorf(\"error decoding string: %s\", err)\n+\t\t}\n+\t\tslice[i] = string(data)\n+\t}\n+\treturn true\n+}\n+\n+func decUintArray(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decUintSlice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decUintSlice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]uint)\n+\tif !ok {\n+\t\t// It is kind uint but not type uint. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding uint array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tx := state.decodeUint()\n+\t\t/*TODO if math.MaxUint32 < x {\n+\t\t\terror_(ovfl)\n+\t\t}*/\n+\t\tslice[i] = uint(x)\n+\t}\n+\treturn true\n+}\n+\n+func decUint16Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decUint16Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decUint16Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]uint16)\n+\tif !ok {\n+\t\t// It is kind uint16 but not type uint16. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding uint16 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tx := state.decodeUint()\n+\t\tif math.MaxUint16 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = uint16(x)\n+\t}\n+\treturn true\n+}\n+\n+func decUint32Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decUint32Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decUint32Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]uint32)\n+\tif !ok {\n+\t\t// It is kind uint32 but not type uint32. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding uint32 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tx := state.decodeUint()\n+\t\tif math.MaxUint32 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = uint32(x)\n+\t}\n+\treturn true\n+}\n+\n+func decUint64Array(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decUint64Slice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decUint64Slice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]uint64)\n+\tif !ok {\n+\t\t// It is kind uint64 but not type uint64. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding uint64 array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tslice[i] = state.decodeUint()\n+\t}\n+\treturn true\n+}\n+\n+func decUintptrArray(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn decUintptrSlice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+\n+func decUintptrSlice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]uintptr)\n+\tif !ok {\n+\t\t// It is kind uintptr but not type uintptr. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding uintptr array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n+\t\tx := state.decodeUint()\n+\t\tif uint64(^uintptr(0)) < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = uintptr(x)\n+\t}\n+\treturn true\n+}"}, {"sha": "da41a899ed01ca8d57f7827648b0ae376719f20b", "filename": "libgo/go/encoding/gob/decgen.go", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdecgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdecgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecgen.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,240 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+// encgen writes the helper functions for encoding. Intended to be\n+// used with go generate; see the invocation in encode.go.\n+\n+// TODO: We could do more by being unsafe. Add a -unsafe flag?\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/format\"\n+\t\"log\"\n+\t\"os\"\n+)\n+\n+var output = flag.String(\"output\", \"dec_helpers.go\", \"file name to write\")\n+\n+type Type struct {\n+\tlower   string\n+\tupper   string\n+\tdecoder string\n+}\n+\n+var types = []Type{\n+\t{\n+\t\t\"bool\",\n+\t\t\"Bool\",\n+\t\t`slice[i] = state.decodeUint() != 0`,\n+\t},\n+\t{\n+\t\t\"complex64\",\n+\t\t\"Complex64\",\n+\t\t`real := float32FromBits(state.decodeUint(), ovfl)\n+\t\timag := float32FromBits(state.decodeUint(), ovfl)\n+\t\tslice[i] = complex(float32(real), float32(imag))`,\n+\t},\n+\t{\n+\t\t\"complex128\",\n+\t\t\"Complex128\",\n+\t\t`real := float64FromBits(state.decodeUint())\n+\t\timag := float64FromBits(state.decodeUint())\n+\t\tslice[i] = complex(real, imag)`,\n+\t},\n+\t{\n+\t\t\"float32\",\n+\t\t\"Float32\",\n+\t\t`slice[i] = float32(float32FromBits(state.decodeUint(), ovfl))`,\n+\t},\n+\t{\n+\t\t\"float64\",\n+\t\t\"Float64\",\n+\t\t`slice[i] = float64FromBits(state.decodeUint())`,\n+\t},\n+\t{\n+\t\t\"int\",\n+\t\t\"Int\",\n+\t\t`x := state.decodeInt()\n+\t\t// MinInt and MaxInt\n+\t\tif x < ^int64(^uint(0)>>1) || int64(^uint(0)>>1) < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = int(x)`,\n+\t},\n+\t{\n+\t\t\"int16\",\n+\t\t\"Int16\",\n+\t\t`x := state.decodeInt()\n+\t\tif x < math.MinInt16 || math.MaxInt16 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = int16(x)`,\n+\t},\n+\t{\n+\t\t\"int32\",\n+\t\t\"Int32\",\n+\t\t`x := state.decodeInt()\n+\t\tif x < math.MinInt32 || math.MaxInt32 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = int32(x)`,\n+\t},\n+\t{\n+\t\t\"int64\",\n+\t\t\"Int64\",\n+\t\t`slice[i] = state.decodeInt()`,\n+\t},\n+\t{\n+\t\t\"int8\",\n+\t\t\"Int8\",\n+\t\t`x := state.decodeInt()\n+\t\tif x < math.MinInt8 || math.MaxInt8 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = int8(x)`,\n+\t},\n+\t{\n+\t\t\"string\",\n+\t\t\"String\",\n+\t\t`u := state.decodeUint()\n+\t\tn := int(u)\n+\t\tif n < 0 || uint64(n) != u || n > state.b.Len() {\n+\t\t\terrorf(\"length of string exceeds input size (%d bytes)\", u)\n+\t\t}\n+\t\tif n > state.b.Len() {\n+\t\t\terrorf(\"string data too long for buffer: %d\", n)\n+\t\t}\n+\t\t// Read the data.\n+\t\tdata := make([]byte, n)\n+\t\tif _, err := state.b.Read(data); err != nil {\n+\t\t\terrorf(\"error decoding string: %s\", err)\n+\t\t}\n+\t\tslice[i] = string(data)`,\n+\t},\n+\t{\n+\t\t\"uint\",\n+\t\t\"Uint\",\n+\t\t`x := state.decodeUint()\n+\t\t/*TODO if math.MaxUint32 < x {\n+\t\t\terror_(ovfl)\n+\t\t}*/\n+\t\tslice[i] = uint(x)`,\n+\t},\n+\t{\n+\t\t\"uint16\",\n+\t\t\"Uint16\",\n+\t\t`x := state.decodeUint()\n+\t\tif math.MaxUint16 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = uint16(x)`,\n+\t},\n+\t{\n+\t\t\"uint32\",\n+\t\t\"Uint32\",\n+\t\t`x := state.decodeUint()\n+\t\tif math.MaxUint32 < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = uint32(x)`,\n+\t},\n+\t{\n+\t\t\"uint64\",\n+\t\t\"Uint64\",\n+\t\t`slice[i] = state.decodeUint()`,\n+\t},\n+\t{\n+\t\t\"uintptr\",\n+\t\t\"Uintptr\",\n+\t\t`x := state.decodeUint()\n+\t\tif uint64(^uintptr(0)) < x {\n+\t\t\terror_(ovfl)\n+\t\t}\n+\t\tslice[i] = uintptr(x)`,\n+\t},\n+\t// uint8 Handled separately.\n+}\n+\n+func main() {\n+\tlog.SetFlags(0)\n+\tlog.SetPrefix(\"decgen: \")\n+\tflag.Parse()\n+\tif flag.NArg() != 0 {\n+\t\tlog.Fatal(\"usage: decgen [--output filename]\")\n+\t}\n+\tvar b bytes.Buffer\n+\tfmt.Fprintf(&b, \"// Created by decgen --output %s; DO NOT EDIT\\n\", *output)\n+\tfmt.Fprint(&b, header)\n+\tprintMaps(&b, \"Array\")\n+\tfmt.Fprint(&b, \"\\n\")\n+\tprintMaps(&b, \"Slice\")\n+\tfor _, t := range types {\n+\t\tfmt.Fprintf(&b, arrayHelper, t.lower, t.upper)\n+\t\tfmt.Fprintf(&b, sliceHelper, t.lower, t.upper, t.decoder)\n+\t}\n+\tsource, err := format.Source(b.Bytes())\n+\tif err != nil {\n+\t\tlog.Fatal(\"source format error:\", err)\n+\t}\n+\tfd, err := os.Create(*output)\n+\t_, err = fd.Write(source)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}\n+\n+func printMaps(b *bytes.Buffer, upperClass string) {\n+\tfmt.Fprintf(b, \"var dec%sHelper = map[reflect.Kind]decHelper{\\n\", upperClass)\n+\tfor _, t := range types {\n+\t\tfmt.Fprintf(b, \"reflect.%s: dec%s%s,\\n\", t.upper, t.upper, upperClass)\n+\t}\n+\tfmt.Fprintf(b, \"}\\n\")\n+}\n+\n+const header = `\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package gob\n+\n+import (\n+\t\"math\"\n+\t\"reflect\"\n+)\n+\n+`\n+\n+const arrayHelper = `\n+func dec%[2]sArray(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn dec%[2]sSlice(state, v.Slice(0, v.Len()), length, ovfl)\n+}\n+`\n+\n+const sliceHelper = `\n+func dec%[2]sSlice(state *decoderState, v reflect.Value, length int, ovfl error) bool {\n+\tslice, ok := v.Interface().([]%[1]s)\n+\tif !ok {\n+\t\t// It is kind %[1]s but not type %[1]s. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding %[1]s array or slice: length exceeds input size (%%d elements)\", length)\n+\t\t}\n+\t\t%[3]s\n+\t}\n+\treturn true\n+}\n+`"}, {"sha": "a5bef93141b7adf29796a2276f1c83a45e40ece0", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 312, "deletions": 412, "changes": 724, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -2,19 +2,16 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package gob\n+//go:generate go run decgen.go -output dec_helpers.go\n \n-// TODO(rsc): When garbage collector changes, revisit\n-// the allocations in this file that use unsafe.Pointer.\n+package gob\n \n import (\n-\t\"bytes\"\n \t\"encoding\"\n \t\"errors\"\n \t\"io\"\n \t\"math\"\n \t\"reflect\"\n-\t\"unsafe\"\n )\n \n var (\n@@ -23,21 +20,79 @@ var (\n \terrRange   = errors.New(\"gob: bad data: field numbers out of bounds\")\n )\n \n+type decHelper func(state *decoderState, v reflect.Value, length int, ovfl error) bool\n+\n // decoderState is the execution state of an instance of the decoder. A new state\n // is created for nested objects.\n type decoderState struct {\n \tdec *Decoder\n \t// The buffer is stored with an extra indirection because it may be replaced\n \t// if we load a type during decode (when reading an interface value).\n-\tb        *bytes.Buffer\n+\tb        *decBuffer\n \tfieldnum int // the last field number read.\n \tbuf      []byte\n \tnext     *decoderState // for free list\n }\n \n+// decBuffer is an extremely simple, fast implementation of a read-only byte buffer.\n+// It is initialized by calling Size and then copying the data into the slice returned by Bytes().\n+type decBuffer struct {\n+\tdata   []byte\n+\toffset int // Read offset.\n+}\n+\n+func (d *decBuffer) Read(p []byte) (int, error) {\n+\tn := copy(p, d.data[d.offset:])\n+\tif n == 0 && len(p) != 0 {\n+\t\treturn 0, io.EOF\n+\t}\n+\td.offset += n\n+\treturn n, nil\n+}\n+\n+func (d *decBuffer) Drop(n int) {\n+\tif n > d.Len() {\n+\t\tpanic(\"drop\")\n+\t}\n+\td.offset += n\n+}\n+\n+// Size grows the buffer to exactly n bytes, so d.Bytes() will\n+// return a slice of length n. Existing data is first discarded.\n+func (d *decBuffer) Size(n int) {\n+\td.Reset()\n+\tif cap(d.data) < n {\n+\t\td.data = make([]byte, n)\n+\t} else {\n+\t\td.data = d.data[0:n]\n+\t}\n+}\n+\n+func (d *decBuffer) ReadByte() (byte, error) {\n+\tif d.offset >= len(d.data) {\n+\t\treturn 0, io.EOF\n+\t}\n+\tc := d.data[d.offset]\n+\td.offset++\n+\treturn c, nil\n+}\n+\n+func (d *decBuffer) Len() int {\n+\treturn len(d.data) - d.offset\n+}\n+\n+func (d *decBuffer) Bytes() []byte {\n+\treturn d.data[d.offset:]\n+}\n+\n+func (d *decBuffer) Reset() {\n+\td.data = d.data[0:0]\n+\td.offset = 0\n+}\n+\n // We pass the bytes.Buffer separately for easier testing of the infrastructure\n // without requiring a full Decoder.\n-func (dec *Decoder) newDecoderState(buf *bytes.Buffer) *decoderState {\n+func (dec *Decoder) newDecoderState(buf *decBuffer) *decoderState {\n \td := dec.freeList\n \tif d == nil {\n \t\td = new(decoderState)\n@@ -128,183 +183,126 @@ func (state *decoderState) decodeInt() int64 {\n }\n \n // decOp is the signature of a decoding operator for a given type.\n-type decOp func(i *decInstr, state *decoderState, p unsafe.Pointer)\n+type decOp func(i *decInstr, state *decoderState, v reflect.Value)\n \n // The 'instructions' of the decoding machine\n type decInstr struct {\n-\top     decOp\n-\tfield  int     // field number of the wire type\n-\tindir  int     // how many pointer indirections to reach the value in the struct\n-\toffset uintptr // offset in the structure of the field to encode\n-\tovfl   error   // error message for overflow/underflow (for arrays, of the elements)\n-}\n-\n-// Since the encoder writes no zeros, if we arrive at a decoder we have\n-// a value to extract and store.  The field number has already been read\n-// (it's how we knew to call this decoder).\n-// Each decoder is responsible for handling any indirections associated\n-// with the data structure.  If any pointer so reached is nil, allocation must\n-// be done.\n-\n-// Walk the pointer hierarchy, allocating if we find a nil.  Stop one before the end.\n-func decIndirect(p unsafe.Pointer, indir int) unsafe.Pointer {\n-\tfor ; indir > 1; indir-- {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t// Allocation required\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(unsafe.Pointer))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n-\treturn p\n+\top    decOp\n+\tfield int   // field number of the wire type\n+\tindex []int // field access indices for destination type\n+\tovfl  error // error message for overflow/underflow (for arrays, of the elements)\n }\n \n // ignoreUint discards a uint value with no destination.\n-func ignoreUint(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+func ignoreUint(i *decInstr, state *decoderState, v reflect.Value) {\n \tstate.decodeUint()\n }\n \n // ignoreTwoUints discards a uint value with no destination. It's used to skip\n // complex values.\n-func ignoreTwoUints(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+func ignoreTwoUints(i *decInstr, state *decoderState, v reflect.Value) {\n \tstate.decodeUint()\n \tstate.decodeUint()\n }\n \n-// decBool decodes a uint and stores it as a boolean through p.\n-func decBool(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(bool))\n+// Since the encoder writes no zeros, if we arrive at a decoder we have\n+// a value to extract and store.  The field number has already been read\n+// (it's how we knew to call this decoder).\n+// Each decoder is responsible for handling any indirections associated\n+// with the data structure.  If any pointer so reached is nil, allocation must\n+// be done.\n+\n+// decAlloc takes a value and returns a settable value that can\n+// be assigned to. If the value is a pointer, decAlloc guarantees it points to storage.\n+// The callers to the individual decoders are expected to have used decAlloc.\n+// The individual decoders don't need to it.\n+func decAlloc(v reflect.Value) reflect.Value {\n+\tfor v.Kind() == reflect.Ptr {\n+\t\tif v.IsNil() {\n+\t\t\tv.Set(reflect.New(v.Type().Elem()))\n \t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n+\t\tv = v.Elem()\n \t}\n-\t*(*bool)(p) = state.decodeUint() != 0\n+\treturn v\n }\n \n-// decInt8 decodes an integer and stores it as an int8 through p.\n-func decInt8(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int8))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n+// decBool decodes a uint and stores it as a boolean in value.\n+func decBool(i *decInstr, state *decoderState, value reflect.Value) {\n+\tvalue.SetBool(state.decodeUint() != 0)\n+}\n+\n+// decInt8 decodes an integer and stores it as an int8 in value.\n+func decInt8(i *decInstr, state *decoderState, value reflect.Value) {\n \tv := state.decodeInt()\n \tif v < math.MinInt8 || math.MaxInt8 < v {\n \t\terror_(i.ovfl)\n-\t} else {\n-\t\t*(*int8)(p) = int8(v)\n \t}\n+\tvalue.SetInt(v)\n }\n \n-// decUint8 decodes an unsigned integer and stores it as a uint8 through p.\n-func decUint8(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint8))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n+// decUint8 decodes an unsigned integer and stores it as a uint8 in value.\n+func decUint8(i *decInstr, state *decoderState, value reflect.Value) {\n \tv := state.decodeUint()\n \tif math.MaxUint8 < v {\n \t\terror_(i.ovfl)\n-\t} else {\n-\t\t*(*uint8)(p) = uint8(v)\n \t}\n+\tvalue.SetUint(v)\n }\n \n-// decInt16 decodes an integer and stores it as an int16 through p.\n-func decInt16(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int16))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n+// decInt16 decodes an integer and stores it as an int16 in value.\n+func decInt16(i *decInstr, state *decoderState, value reflect.Value) {\n \tv := state.decodeInt()\n \tif v < math.MinInt16 || math.MaxInt16 < v {\n \t\terror_(i.ovfl)\n-\t} else {\n-\t\t*(*int16)(p) = int16(v)\n \t}\n+\tvalue.SetInt(v)\n }\n \n-// decUint16 decodes an unsigned integer and stores it as a uint16 through p.\n-func decUint16(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint16))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n+// decUint16 decodes an unsigned integer and stores it as a uint16 in value.\n+func decUint16(i *decInstr, state *decoderState, value reflect.Value) {\n \tv := state.decodeUint()\n \tif math.MaxUint16 < v {\n \t\terror_(i.ovfl)\n-\t} else {\n-\t\t*(*uint16)(p) = uint16(v)\n \t}\n+\tvalue.SetUint(v)\n }\n \n-// decInt32 decodes an integer and stores it as an int32 through p.\n-func decInt32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int32))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n+// decInt32 decodes an integer and stores it as an int32 in value.\n+func decInt32(i *decInstr, state *decoderState, value reflect.Value) {\n \tv := state.decodeInt()\n \tif v < math.MinInt32 || math.MaxInt32 < v {\n \t\terror_(i.ovfl)\n-\t} else {\n-\t\t*(*int32)(p) = int32(v)\n \t}\n+\tvalue.SetInt(v)\n }\n \n-// decUint32 decodes an unsigned integer and stores it as a uint32 through p.\n-func decUint32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint32))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n+// decUint32 decodes an unsigned integer and stores it as a uint32 in value.\n+func decUint32(i *decInstr, state *decoderState, value reflect.Value) {\n \tv := state.decodeUint()\n \tif math.MaxUint32 < v {\n \t\terror_(i.ovfl)\n-\t} else {\n-\t\t*(*uint32)(p) = uint32(v)\n \t}\n+\tvalue.SetUint(v)\n }\n \n-// decInt64 decodes an integer and stores it as an int64 through p.\n-func decInt64(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int64))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n-\t*(*int64)(p) = int64(state.decodeInt())\n+// decInt64 decodes an integer and stores it as an int64 in value.\n+func decInt64(i *decInstr, state *decoderState, value reflect.Value) {\n+\tv := state.decodeInt()\n+\tvalue.SetInt(v)\n }\n \n-// decUint64 decodes an unsigned integer and stores it as a uint64 through p.\n-func decUint64(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint64))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n-\t*(*uint64)(p) = uint64(state.decodeUint())\n+// decUint64 decodes an unsigned integer and stores it as a uint64 in value.\n+func decUint64(i *decInstr, state *decoderState, value reflect.Value) {\n+\tv := state.decodeUint()\n+\tvalue.SetUint(v)\n }\n \n // Floating-point numbers are transmitted as uint64s holding the bits\n // of the underlying representation.  They are sent byte-reversed, with\n // the exponent end coming out first, so integer floating point numbers\n // (for example) transmit more compactly.  This routine does the\n // unswizzling.\n-func floatFromBits(u uint64) float64 {\n+func float64FromBits(u uint64) float64 {\n \tvar v uint64\n \tfor i := 0; i < 8; i++ {\n \t\tv <<= 8\n@@ -314,128 +312,100 @@ func floatFromBits(u uint64) float64 {\n \treturn math.Float64frombits(v)\n }\n \n-// storeFloat32 decodes an unsigned integer, treats it as a 32-bit floating-point\n-// number, and stores it through p. It's a helper function for float32 and complex64.\n-func storeFloat32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tv := floatFromBits(state.decodeUint())\n+// float32FromBits decodes an unsigned integer, treats it as a 32-bit floating-point\n+// number, and returns it. It's a helper function for float32 and complex64.\n+// It returns a float64 because that's what reflection needs, but its return\n+// value is known to be accurately representable in a float32.\n+func float32FromBits(u uint64, ovfl error) float64 {\n+\tv := float64FromBits(u)\n \tav := v\n \tif av < 0 {\n \t\tav = -av\n \t}\n \t// +Inf is OK in both 32- and 64-bit floats.  Underflow is always OK.\n \tif math.MaxFloat32 < av && av <= math.MaxFloat64 {\n-\t\terror_(i.ovfl)\n-\t} else {\n-\t\t*(*float32)(p) = float32(v)\n+\t\terror_(ovfl)\n \t}\n+\treturn v\n }\n \n // decFloat32 decodes an unsigned integer, treats it as a 32-bit floating-point\n-// number, and stores it through p.\n-func decFloat32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(float32))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n-\tstoreFloat32(i, state, p)\n+// number, and stores it in value.\n+func decFloat32(i *decInstr, state *decoderState, value reflect.Value) {\n+\tvalue.SetFloat(float32FromBits(state.decodeUint(), i.ovfl))\n }\n \n // decFloat64 decodes an unsigned integer, treats it as a 64-bit floating-point\n-// number, and stores it through p.\n-func decFloat64(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(float64))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n-\t*(*float64)(p) = floatFromBits(uint64(state.decodeUint()))\n+// number, and stores it in value.\n+func decFloat64(i *decInstr, state *decoderState, value reflect.Value) {\n+\tvalue.SetFloat(float64FromBits(state.decodeUint()))\n }\n \n // decComplex64 decodes a pair of unsigned integers, treats them as a\n-// pair of floating point numbers, and stores them as a complex64 through p.\n+// pair of floating point numbers, and stores them as a complex64 in value.\n // The real part comes first.\n-func decComplex64(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(complex64))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n-\tstoreFloat32(i, state, p)\n-\tstoreFloat32(i, state, unsafe.Pointer(uintptr(p)+unsafe.Sizeof(float32(0))))\n+func decComplex64(i *decInstr, state *decoderState, value reflect.Value) {\n+\treal := float32FromBits(state.decodeUint(), i.ovfl)\n+\timag := float32FromBits(state.decodeUint(), i.ovfl)\n+\tvalue.SetComplex(complex(real, imag))\n }\n \n // decComplex128 decodes a pair of unsigned integers, treats them as a\n-// pair of floating point numbers, and stores them as a complex128 through p.\n+// pair of floating point numbers, and stores them as a complex128 in value.\n // The real part comes first.\n-func decComplex128(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(complex128))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n-\treal := floatFromBits(uint64(state.decodeUint()))\n-\timag := floatFromBits(uint64(state.decodeUint()))\n-\t*(*complex128)(p) = complex(real, imag)\n+func decComplex128(i *decInstr, state *decoderState, value reflect.Value) {\n+\treal := float64FromBits(state.decodeUint())\n+\timag := float64FromBits(state.decodeUint())\n+\tvalue.SetComplex(complex(real, imag))\n }\n \n-// decUint8Slice decodes a byte slice and stores through p a slice header\n+// decUint8Slice decodes a byte slice and stores in value a slice header\n // describing the data.\n // uint8 slices are encoded as an unsigned count followed by the raw bytes.\n-func decUint8Slice(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]uint8))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n+func decUint8Slice(i *decInstr, state *decoderState, value reflect.Value) {\n+\tu := state.decodeUint()\n+\tn := int(u)\n+\tif n < 0 || uint64(n) != u {\n+\t\terrorf(\"length of %s exceeds input size (%d bytes)\", value.Type(), u)\n+\t}\n+\tif n > state.b.Len() {\n+\t\terrorf(\"%s data too long for buffer: %d\", value.Type(), n)\n \t}\n-\tn := state.decodeUint()\n-\tif n > uint64(state.b.Len()) {\n-\t\terrorf(\"length of []byte exceeds input size (%d bytes)\", n)\n+\tif n > tooBig {\n+\t\terrorf(\"byte slice too big: %d\", n)\n \t}\n-\tslice := (*[]uint8)(p)\n-\tif uint64(cap(*slice)) < n {\n-\t\t*slice = make([]uint8, n)\n+\tif value.Cap() < n {\n+\t\tvalue.Set(reflect.MakeSlice(value.Type(), n, n))\n \t} else {\n-\t\t*slice = (*slice)[0:n]\n+\t\tvalue.Set(value.Slice(0, n))\n \t}\n-\tif _, err := state.b.Read(*slice); err != nil {\n+\tif _, err := state.b.Read(value.Bytes()); err != nil {\n \t\terrorf(\"error decoding []byte: %s\", err)\n \t}\n }\n \n-// decString decodes byte array and stores through p a string header\n+// decString decodes byte array and stores in value a string header\n // describing the data.\n // Strings are encoded as an unsigned count followed by the raw bytes.\n-func decString(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\tif i.indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(string))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n+func decString(i *decInstr, state *decoderState, value reflect.Value) {\n+\tu := state.decodeUint()\n+\tn := int(u)\n+\tif n < 0 || uint64(n) != u || n > state.b.Len() {\n+\t\terrorf(\"length of %s exceeds input size (%d bytes)\", value.Type(), u)\n \t}\n-\tn := state.decodeUint()\n-\tif n > uint64(state.b.Len()) {\n-\t\terrorf(\"string length exceeds input size (%d bytes)\", n)\n+\tif n > state.b.Len() {\n+\t\terrorf(\"%s data too long for buffer: %d\", value.Type(), n)\n \t}\n-\tb := make([]byte, n)\n-\tstate.b.Read(b)\n-\t// It would be a shame to do the obvious thing here,\n-\t//\t*(*string)(p) = string(b)\n-\t// because we've already allocated the storage and this would\n-\t// allocate again and copy.  So we do this ugly hack, which is even\n-\t// even more unsafe than it looks as it depends the memory\n-\t// representation of a string matching the beginning of the memory\n-\t// representation of a byte slice (a byte slice is longer).\n-\t*(*string)(p) = *(*string)(unsafe.Pointer(&b))\n+\t// Read the data.\n+\tdata := make([]byte, n)\n+\tif _, err := state.b.Read(data); err != nil {\n+\t\terrorf(\"error decoding string: %s\", err)\n+\t}\n+\tvalue.SetString(string(data))\n }\n \n // ignoreUint8Array skips over the data for a byte slice value with no destination.\n-func ignoreUint8Array(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+func ignoreUint8Array(i *decInstr, state *decoderState, value reflect.Value) {\n \tb := make([]byte, state.decodeUint())\n \tstate.b.Read(b)\n }\n@@ -449,55 +419,29 @@ type decEngine struct {\n \tnumInstr int // the number of active instructions\n }\n \n-// allocate makes sure storage is available for an object of underlying type rtyp\n-// that is indir levels of indirection through p.\n-func allocate(rtyp reflect.Type, p unsafe.Pointer, indir int) unsafe.Pointer {\n-\tif indir == 0 {\n-\t\treturn p\n-\t}\n-\tup := p\n-\tif indir > 1 {\n-\t\tup = decIndirect(up, indir)\n-\t}\n-\tif *(*unsafe.Pointer)(up) == nil {\n-\t\t// Allocate object.\n-\t\t*(*unsafe.Pointer)(up) = unsafe.Pointer(reflect.New(rtyp).Pointer())\n-\t}\n-\treturn *(*unsafe.Pointer)(up)\n-}\n-\n-// decodeSingle decodes a top-level value that is not a struct and stores it through p.\n+// decodeSingle decodes a top-level value that is not a struct and stores it in value.\n // Such values are preceded by a zero, making them have the memory layout of a\n // struct field (although with an illegal field number).\n-func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, basep unsafe.Pointer) {\n+func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, value reflect.Value) {\n \tstate := dec.newDecoderState(&dec.buf)\n+\tdefer dec.freeDecoderState(state)\n \tstate.fieldnum = singletonField\n-\tdelta := int(state.decodeUint())\n-\tif delta != 0 {\n+\tif state.decodeUint() != 0 {\n \t\terrorf(\"decode: corrupted data: non-zero delta for singleton\")\n \t}\n \tinstr := &engine.instr[singletonField]\n-\tif instr.indir != ut.indir {\n-\t\terrorf(\"internal error: inconsistent indirection instr %d ut %d\", instr.indir, ut.indir)\n-\t}\n-\tptr := basep // offset will be zero\n-\tif instr.indir > 1 {\n-\t\tptr = decIndirect(ptr, instr.indir)\n-\t}\n-\tinstr.op(instr, state, ptr)\n-\tdec.freeDecoderState(state)\n+\tinstr.op(instr, state, value)\n }\n \n-// decodeStruct decodes a top-level struct and stores it through p.\n+// decodeStruct decodes a top-level struct and stores it in value.\n // Indir is for the value, not the type.  At the time of the call it may\n // differ from ut.indir, which was computed when the engine was built.\n // This state cannot arise for decodeSingle, which is called directly\n // from the user's value, not from the innards of an engine.\n-func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p unsafe.Pointer, indir int) {\n-\tp = allocate(ut.base, p, indir)\n+func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, value reflect.Value) {\n \tstate := dec.newDecoderState(&dec.buf)\n+\tdefer dec.freeDecoderState(state)\n \tstate.fieldnum = -1\n-\tbasep := p\n \tfor state.b.Len() > 0 {\n \t\tdelta := int(state.decodeUint())\n \t\tif delta < 0 {\n@@ -512,19 +456,25 @@ func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p unsafe.P\n \t\t\tbreak\n \t\t}\n \t\tinstr := &engine.instr[fieldnum]\n-\t\tp := unsafe.Pointer(uintptr(basep) + instr.offset)\n-\t\tif instr.indir > 1 {\n-\t\t\tp = decIndirect(p, instr.indir)\n+\t\tvar field reflect.Value\n+\t\tif instr.index != nil {\n+\t\t\t// Otherwise the field is unknown to us and instr.op is an ignore op.\n+\t\t\tfield = value.FieldByIndex(instr.index)\n+\t\t\tif field.Kind() == reflect.Ptr {\n+\t\t\t\tfield = decAlloc(field)\n+\t\t\t}\n \t\t}\n-\t\tinstr.op(instr, state, p)\n+\t\tinstr.op(instr, state, field)\n \t\tstate.fieldnum = fieldnum\n \t}\n-\tdec.freeDecoderState(state)\n }\n \n+var noValue reflect.Value\n+\n // ignoreStruct discards the data for a struct with no destination.\n func (dec *Decoder) ignoreStruct(engine *decEngine) {\n \tstate := dec.newDecoderState(&dec.buf)\n+\tdefer dec.freeDecoderState(state)\n \tstate.fieldnum = -1\n \tfor state.b.Len() > 0 {\n \t\tdelta := int(state.decodeUint())\n@@ -539,97 +489,89 @@ func (dec *Decoder) ignoreStruct(engine *decEngine) {\n \t\t\terror_(errRange)\n \t\t}\n \t\tinstr := &engine.instr[fieldnum]\n-\t\tinstr.op(instr, state, unsafe.Pointer(nil))\n+\t\tinstr.op(instr, state, noValue)\n \t\tstate.fieldnum = fieldnum\n \t}\n-\tdec.freeDecoderState(state)\n }\n \n // ignoreSingle discards the data for a top-level non-struct value with no\n // destination. It's used when calling Decode with a nil value.\n func (dec *Decoder) ignoreSingle(engine *decEngine) {\n \tstate := dec.newDecoderState(&dec.buf)\n+\tdefer dec.freeDecoderState(state)\n \tstate.fieldnum = singletonField\n \tdelta := int(state.decodeUint())\n \tif delta != 0 {\n \t\terrorf(\"decode: corrupted data: non-zero delta for singleton\")\n \t}\n \tinstr := &engine.instr[singletonField]\n-\tinstr.op(instr, state, unsafe.Pointer(nil))\n-\tdec.freeDecoderState(state)\n+\tinstr.op(instr, state, noValue)\n }\n \n // decodeArrayHelper does the work for decoding arrays and slices.\n-func (dec *Decoder) decodeArrayHelper(state *decoderState, p unsafe.Pointer, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl error) {\n-\tinstr := &decInstr{elemOp, 0, elemIndir, 0, ovfl}\n+func (dec *Decoder) decodeArrayHelper(state *decoderState, value reflect.Value, elemOp decOp, length int, ovfl error, helper decHelper) {\n+\tif helper != nil && helper(state, value, length, ovfl) {\n+\t\treturn\n+\t}\n+\tinstr := &decInstr{elemOp, 0, nil, ovfl}\n+\tisPtr := value.Type().Elem().Kind() == reflect.Ptr\n \tfor i := 0; i < length; i++ {\n \t\tif state.b.Len() == 0 {\n \t\t\terrorf(\"decoding array or slice: length exceeds input size (%d elements)\", length)\n \t\t}\n-\t\tup := p\n-\t\tif elemIndir > 1 {\n-\t\t\tup = decIndirect(up, elemIndir)\n+\t\tv := value.Index(i)\n+\t\tif isPtr {\n+\t\t\tv = decAlloc(v)\n \t\t}\n-\t\telemOp(instr, state, up)\n-\t\tp = unsafe.Pointer(uintptr(p) + elemWid)\n+\t\telemOp(instr, state, v)\n \t}\n }\n \n-// decodeArray decodes an array and stores it through p, that is, p points to the zeroth element.\n+// decodeArray decodes an array and stores it in value.\n // The length is an unsigned integer preceding the elements.  Even though the length is redundant\n // (it's part of the type), it's a useful check and is included in the encoding.\n-func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, p unsafe.Pointer, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl error) {\n-\tif indir > 0 {\n-\t\tp = allocate(atyp, p, 1) // All but the last level has been allocated by dec.Indirect\n-\t}\n+func (dec *Decoder) decodeArray(atyp reflect.Type, state *decoderState, value reflect.Value, elemOp decOp, length int, ovfl error, helper decHelper) {\n \tif n := state.decodeUint(); n != uint64(length) {\n \t\terrorf(\"length mismatch in decodeArray\")\n \t}\n-\tdec.decodeArrayHelper(state, p, elemOp, elemWid, length, elemIndir, ovfl)\n+\tdec.decodeArrayHelper(state, value, elemOp, length, ovfl, helper)\n }\n \n-// decodeIntoValue is a helper for map decoding.  Since maps are decoded using reflection,\n-// unlike the other items we can't use a pointer directly.\n-func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value, ovfl error) reflect.Value {\n-\tinstr := &decInstr{op, 0, indir, 0, ovfl}\n-\tup := unsafeAddr(v)\n-\tif indir > 1 {\n-\t\tup = decIndirect(up, indir)\n+// decodeIntoValue is a helper for map decoding.\n+func decodeIntoValue(state *decoderState, op decOp, isPtr bool, value reflect.Value, ovfl error) reflect.Value {\n+\tinstr := &decInstr{op, 0, nil, ovfl}\n+\tv := value\n+\tif isPtr {\n+\t\tv = decAlloc(value)\n \t}\n-\top(instr, state, up)\n-\treturn v\n+\top(instr, state, v)\n+\treturn value\n }\n \n-// decodeMap decodes a map and stores its header through p.\n+// decodeMap decodes a map and stores it in value.\n // Maps are encoded as a length followed by key:value pairs.\n // Because the internals of maps are not visible to us, we must\n // use reflection rather than pointer magic.\n-func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, p unsafe.Pointer, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl error) {\n-\tif indir > 0 {\n-\t\tp = allocate(mtyp, p, 1) // All but the last level has been allocated by dec.Indirect\n-\t}\n-\tup := unsafe.Pointer(p)\n-\tif *(*unsafe.Pointer)(up) == nil { // maps are represented as a pointer in the runtime\n+func (dec *Decoder) decodeMap(mtyp reflect.Type, state *decoderState, value reflect.Value, keyOp, elemOp decOp, ovfl error) {\n+\tif value.IsNil() {\n \t\t// Allocate map.\n-\t\t*(*unsafe.Pointer)(up) = unsafe.Pointer(reflect.MakeMap(mtyp).Pointer())\n+\t\tvalue.Set(reflect.MakeMap(mtyp))\n \t}\n-\t// Maps cannot be accessed by moving addresses around the way\n-\t// that slices etc. can.  We must recover a full reflection value for\n-\t// the iteration.\n-\tv := reflect.NewAt(mtyp, unsafe.Pointer(p)).Elem()\n \tn := int(state.decodeUint())\n+\tkeyIsPtr := mtyp.Key().Kind() == reflect.Ptr\n+\telemIsPtr := mtyp.Elem().Kind() == reflect.Ptr\n \tfor i := 0; i < n; i++ {\n-\t\tkey := decodeIntoValue(state, keyOp, keyIndir, allocValue(mtyp.Key()), ovfl)\n-\t\telem := decodeIntoValue(state, elemOp, elemIndir, allocValue(mtyp.Elem()), ovfl)\n-\t\tv.SetMapIndex(key, elem)\n+\t\tkey := decodeIntoValue(state, keyOp, keyIsPtr, allocValue(mtyp.Key()), ovfl)\n+\t\telem := decodeIntoValue(state, elemOp, elemIsPtr, allocValue(mtyp.Elem()), ovfl)\n+\t\tvalue.SetMapIndex(key, elem)\n \t}\n }\n \n // ignoreArrayHelper does the work for discarding arrays and slices.\n func (dec *Decoder) ignoreArrayHelper(state *decoderState, elemOp decOp, length int) {\n-\tinstr := &decInstr{elemOp, 0, 0, 0, errors.New(\"no error\")}\n+\tinstr := &decInstr{elemOp, 0, nil, errors.New(\"no error\")}\n \tfor i := 0; i < length; i++ {\n-\t\telemOp(instr, state, nil)\n+\t\telemOp(instr, state, noValue)\n \t}\n }\n \n@@ -644,58 +586,45 @@ func (dec *Decoder) ignoreArray(state *decoderState, elemOp decOp, length int) {\n // ignoreMap discards the data for a map value with no destination.\n func (dec *Decoder) ignoreMap(state *decoderState, keyOp, elemOp decOp) {\n \tn := int(state.decodeUint())\n-\tkeyInstr := &decInstr{keyOp, 0, 0, 0, errors.New(\"no error\")}\n-\telemInstr := &decInstr{elemOp, 0, 0, 0, errors.New(\"no error\")}\n+\tkeyInstr := &decInstr{keyOp, 0, nil, errors.New(\"no error\")}\n+\telemInstr := &decInstr{elemOp, 0, nil, errors.New(\"no error\")}\n \tfor i := 0; i < n; i++ {\n-\t\tkeyOp(keyInstr, state, nil)\n-\t\telemOp(elemInstr, state, nil)\n+\t\tkeyOp(keyInstr, state, noValue)\n+\t\telemOp(elemInstr, state, noValue)\n \t}\n }\n \n-// decodeSlice decodes a slice and stores the slice header through p.\n+// decodeSlice decodes a slice and stores it in value.\n // Slices are encoded as an unsigned length followed by the elements.\n-func (dec *Decoder) decodeSlice(atyp reflect.Type, state *decoderState, p unsafe.Pointer, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl error) {\n-\tnr := state.decodeUint()\n-\tn := int(nr)\n-\tif indir > 0 {\n-\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t// Allocate the slice header.\n-\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]unsafe.Pointer))\n-\t\t}\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t}\n-\t// Allocate storage for the slice elements, that is, the underlying array,\n-\t// if the existing slice does not have the capacity.\n-\t// Always write a header at p.\n-\thdrp := (*reflect.SliceHeader)(p)\n-\tif hdrp.Cap < n {\n-\t\thdrp.Data = reflect.MakeSlice(atyp, n, n).Pointer()\n-\t\thdrp.Cap = n\n+func (dec *Decoder) decodeSlice(state *decoderState, value reflect.Value, elemOp decOp, ovfl error, helper decHelper) {\n+\tu := state.decodeUint()\n+\ttyp := value.Type()\n+\tsize := uint64(typ.Elem().Size())\n+\tnBytes := u * size\n+\tn := int(u)\n+\t// Take care with overflow in this calculation.\n+\tif n < 0 || uint64(n) != u || nBytes > tooBig || (size > 0 && nBytes/size != u) {\n+\t\t// We don't check n against buffer length here because if it's a slice\n+\t\t// of interfaces, there will be buffer reloads.\n+\t\terrorf(\"%s slice too big: %d elements of %d bytes\", typ.Elem(), u, size)\n+\t}\n+\tif value.Cap() < n {\n+\t\tvalue.Set(reflect.MakeSlice(typ, n, n))\n+\t} else {\n+\t\tvalue.Set(value.Slice(0, n))\n \t}\n-\thdrp.Len = n\n-\tdec.decodeArrayHelper(state, unsafe.Pointer(hdrp.Data), elemOp, elemWid, n, elemIndir, ovfl)\n+\tdec.decodeArrayHelper(state, value, elemOp, n, ovfl, helper)\n }\n \n // ignoreSlice skips over the data for a slice value with no destination.\n func (dec *Decoder) ignoreSlice(state *decoderState, elemOp decOp) {\n \tdec.ignoreArrayHelper(state, elemOp, int(state.decodeUint()))\n }\n \n-// setInterfaceValue sets an interface value to a concrete value,\n-// but first it checks that the assignment will succeed.\n-func setInterfaceValue(ivalue reflect.Value, value reflect.Value) {\n-\tif !value.Type().AssignableTo(ivalue.Type()) {\n-\t\terrorf(\"%s is not assignable to type %s\", value.Type(), ivalue.Type())\n-\t}\n-\tivalue.Set(value)\n-}\n-\n-// decodeInterface decodes an interface value and stores it through p.\n+// decodeInterface decodes an interface value and stores it in value.\n // Interfaces are encoded as the name of a concrete type followed by a value.\n // If the name is empty, the value is nil and no value is sent.\n-func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p unsafe.Pointer, indir int) {\n-\t// Create a writable interface reflect.Value.  We need one even for the nil case.\n-\tivalue := allocValue(ityp)\n+func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, value reflect.Value) {\n \t// Read the name of the concrete type.\n \tnr := state.decodeUint()\n \tif nr < 0 || nr > 1<<31 { // zero is permissible for anonymous types\n@@ -707,13 +636,10 @@ func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p un\n \tb := make([]byte, nr)\n \tstate.b.Read(b)\n \tname := string(b)\n+\t// Allocate the destination interface value.\n \tif name == \"\" {\n-\t\t// Copy the representation of the nil interface value to the target.\n-\t\t// This is horribly unsafe and special.\n-\t\tif indir > 0 {\n-\t\t\tp = allocate(ityp, p, 1) // All but the last level has been allocated by dec.Indirect\n-\t\t}\n-\t\t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.InterfaceData()\n+\t\t// Copy the nil interface value to the target.\n+\t\tvalue.Set(reflect.Zero(value.Type()))\n \t\treturn\n \t}\n \tif len(name) > 1024 {\n@@ -735,21 +661,18 @@ func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p un\n \t// in case we want to ignore the value by skipping it completely).\n \tstate.decodeUint()\n \t// Read the concrete value.\n-\tvalue := allocValue(typ)\n-\tdec.decodeValue(concreteId, value)\n+\tv := allocValue(typ)\n+\tdec.decodeValue(concreteId, v)\n \tif dec.err != nil {\n \t\terror_(dec.err)\n \t}\n-\t// Allocate the destination interface value.\n-\tif indir > 0 {\n-\t\tp = allocate(ityp, p, 1) // All but the last level has been allocated by dec.Indirect\n-\t}\n \t// Assign the concrete value to the interface.\n \t// Tread carefully; it might not satisfy the interface.\n-\tsetInterfaceValue(ivalue, value)\n-\t// Copy the representation of the interface value to the target.\n-\t// This is horribly unsafe and special.\n-\t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.InterfaceData()\n+\tif !typ.AssignableTo(ityp) {\n+\t\terrorf(\"%s is not assignable to type %s\", typ, ityp)\n+\t}\n+\t// Copy the interface value to the target.\n+\tvalue.Set(v)\n }\n \n // ignoreInterface discards the data for an interface value with no destination.\n@@ -765,12 +688,12 @@ func (dec *Decoder) ignoreInterface(state *decoderState) {\n \t\terror_(dec.err)\n \t}\n \t// At this point, the decoder buffer contains a delimited value. Just toss it.\n-\tstate.b.Next(int(state.decodeUint()))\n+\tstate.b.Drop(int(state.decodeUint()))\n }\n \n // decodeGobDecoder decodes something implementing the GobDecoder interface.\n // The data is encoded as a byte slice.\n-func (dec *Decoder) decodeGobDecoder(ut *userTypeInfo, state *decoderState, v reflect.Value) {\n+func (dec *Decoder) decodeGobDecoder(ut *userTypeInfo, state *decoderState, value reflect.Value) {\n \t// Read the bytes for the value.\n \tb := make([]byte, state.decodeUint())\n \t_, err := state.b.Read(b)\n@@ -780,11 +703,11 @@ func (dec *Decoder) decodeGobDecoder(ut *userTypeInfo, state *decoderState, v re\n \t// We know it's one of these.\n \tswitch ut.externalDec {\n \tcase xGob:\n-\t\terr = v.Interface().(GobDecoder).GobDecode(b)\n+\t\terr = value.Interface().(GobDecoder).GobDecode(b)\n \tcase xBinary:\n-\t\terr = v.Interface().(encoding.BinaryUnmarshaler).UnmarshalBinary(b)\n+\t\terr = value.Interface().(encoding.BinaryUnmarshaler).UnmarshalBinary(b)\n \tcase xText:\n-\t\terr = v.Interface().(encoding.TextUnmarshaler).UnmarshalText(b)\n+\t\terr = value.Interface().(encoding.TextUnmarshaler).UnmarshalText(b)\n \t}\n \tif err != nil {\n \t\terror_(err)\n@@ -832,7 +755,7 @@ var decIgnoreOpMap = map[typeId]decOp{\n \n // decOpFor returns the decoding op for the base type under rt and\n // the indirection count to reach it.\n-func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProgress map[reflect.Type]*decOp) (*decOp, int) {\n+func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProgress map[reflect.Type]*decOp) *decOp {\n \tut := userType(rt)\n \t// If the type implements GobEncoder, we handle it without further processing.\n \tif ut.externalDec != 0 {\n@@ -842,10 +765,9 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t// If this type is already in progress, it's a recursive type (e.g. map[string]*T).\n \t// Return the pointer to the op we're already building.\n \tif opPtr := inProgress[rt]; opPtr != nil {\n-\t\treturn opPtr, ut.indir\n+\t\treturn opPtr\n \t}\n \ttyp := ut.base\n-\tindir := ut.indir\n \tvar op decOp\n \tk := typ.Kind()\n \tif int(k) < len(decOpTable) {\n@@ -858,20 +780,21 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\tcase reflect.Array:\n \t\t\tname = \"element of \" + name\n \t\t\telemId := dec.wireType[wireId].ArrayT.Elem\n-\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n+\t\t\telemOp := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t\t\tstate.dec.decodeArray(t, state, p, *elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl)\n+\t\t\thelper := decArrayHelper[t.Elem().Kind()]\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n+\t\t\t\tstate.dec.decodeArray(t, state, value, *elemOp, t.Len(), ovfl, helper)\n \t\t\t}\n \n \t\tcase reflect.Map:\n \t\t\tkeyId := dec.wireType[wireId].MapT.Key\n \t\t\telemId := dec.wireType[wireId].MapT.Elem\n-\t\t\tkeyOp, keyIndir := dec.decOpFor(keyId, t.Key(), \"key of \"+name, inProgress)\n-\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), \"element of \"+name, inProgress)\n+\t\t\tkeyOp := dec.decOpFor(keyId, t.Key(), \"key of \"+name, inProgress)\n+\t\t\telemOp := dec.decOpFor(elemId, t.Elem(), \"element of \"+name, inProgress)\n \t\t\tovfl := overflow(name)\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t\t\tstate.dec.decodeMap(t, state, p, *keyOp, *elemOp, i.indir, keyIndir, elemIndir, ovfl)\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n+\t\t\t\tstate.dec.decodeMap(t, state, value, *keyOp, *elemOp, ovfl)\n \t\t\t}\n \n \t\tcase reflect.Slice:\n@@ -886,32 +809,34 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t} else {\n \t\t\t\telemId = dec.wireType[wireId].SliceT.Elem\n \t\t\t}\n-\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n+\t\t\telemOp := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t\t\tstate.dec.decodeSlice(t, state, p, *elemOp, t.Elem().Size(), i.indir, elemIndir, ovfl)\n+\t\t\thelper := decSliceHelper[t.Elem().Kind()]\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n+\t\t\t\tstate.dec.decodeSlice(state, value, *elemOp, ovfl, helper)\n \t\t\t}\n \n \t\tcase reflect.Struct:\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n-\t\t\tenginePtr, err := dec.getDecEnginePtr(wireId, userType(typ))\n+\t\t\tut := userType(typ)\n+\t\t\tenginePtr, err := dec.getDecEnginePtr(wireId, ut)\n \t\t\tif err != nil {\n \t\t\t\terror_(err)\n \t\t\t}\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs.\n-\t\t\t\tdec.decodeStruct(*enginePtr, userType(typ), p, i.indir)\n+\t\t\t\tdec.decodeStruct(*enginePtr, ut, value)\n \t\t\t}\n \t\tcase reflect.Interface:\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t\t\tstate.dec.decodeInterface(t, state, p, i.indir)\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n+\t\t\t\tstate.dec.decodeInterface(t, state, value)\n \t\t\t}\n \t\t}\n \t}\n \tif op == nil {\n \t\terrorf(\"decode can't handle type %s\", rt)\n \t}\n-\treturn &op, indir\n+\treturn &op\n }\n \n // decIgnoreOpFor returns the decoding op for a field that has no destination.\n@@ -921,7 +846,7 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\tif wireId == tInterface {\n \t\t\t// Special case because it's a method: the ignored item might\n \t\t\t// define types and we need to record their state in the decoder.\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n \t\t\t\tstate.dec.ignoreInterface(state)\n \t\t\t}\n \t\t\treturn op\n@@ -934,7 +859,7 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\tcase wire.ArrayT != nil:\n \t\t\telemId := wire.ArrayT.Elem\n \t\t\telemOp := dec.decIgnoreOpFor(elemId)\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n \t\t\t\tstate.dec.ignoreArray(state, elemOp, wire.ArrayT.Len)\n \t\t\t}\n \n@@ -943,14 +868,14 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\t\telemId := dec.wireType[wireId].MapT.Elem\n \t\t\tkeyOp := dec.decIgnoreOpFor(keyId)\n \t\t\telemOp := dec.decIgnoreOpFor(elemId)\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n \t\t\t\tstate.dec.ignoreMap(state, keyOp, elemOp)\n \t\t\t}\n \n \t\tcase wire.SliceT != nil:\n \t\t\telemId := wire.SliceT.Elem\n \t\t\telemOp := dec.decIgnoreOpFor(elemId)\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n \t\t\t\tstate.dec.ignoreSlice(state, elemOp)\n \t\t\t}\n \n@@ -960,13 +885,13 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\t\tif err != nil {\n \t\t\t\terror_(err)\n \t\t\t}\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs\n \t\t\t\tstate.dec.ignoreStruct(*enginePtr)\n \t\t\t}\n \n \t\tcase wire.GobEncoderT != nil, wire.BinaryMarshalerT != nil, wire.TextMarshalerT != nil:\n-\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n \t\t\t\tstate.dec.ignoreGobDecoder(state)\n \t\t\t}\n \t\t}\n@@ -979,7 +904,7 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \n // gobDecodeOpFor returns the op for a type that is known to implement\n // GobDecoder.\n-func (dec *Decoder) gobDecodeOpFor(ut *userTypeInfo) (*decOp, int) {\n+func (dec *Decoder) gobDecodeOpFor(ut *userTypeInfo) *decOp {\n \trcvrType := ut.user\n \tif ut.decIndir == -1 {\n \t\trcvrType = reflect.PtrTo(rcvrType)\n@@ -989,25 +914,14 @@ func (dec *Decoder) gobDecodeOpFor(ut *userTypeInfo) (*decOp, int) {\n \t\t}\n \t}\n \tvar op decOp\n-\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n-\t\t// Caller has gotten us to within one indirection of our value.\n-\t\tif i.indir > 0 {\n-\t\t\tif *(*unsafe.Pointer)(p) == nil {\n-\t\t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(reflect.New(ut.base).Pointer())\n-\t\t\t}\n+\top = func(i *decInstr, state *decoderState, value reflect.Value) {\n+\t\t// We now have the base type. We need its address if the receiver is a pointer.\n+\t\tif value.Kind() != reflect.Ptr && rcvrType.Kind() == reflect.Ptr {\n+\t\t\tvalue = value.Addr()\n \t\t}\n-\t\t// Now p is a pointer to the base type.  Do we need to climb out to\n-\t\t// get to the receiver type?\n-\t\tvar v reflect.Value\n-\t\tif ut.decIndir == -1 {\n-\t\t\tv = reflect.NewAt(rcvrType, unsafe.Pointer(&p)).Elem()\n-\t\t} else {\n-\t\t\tv = reflect.NewAt(rcvrType, p).Elem()\n-\t\t}\n-\t\tstate.dec.decodeGobDecoder(ut, state, v)\n+\t\tstate.dec.decodeGobDecoder(ut, state, value)\n \t}\n-\treturn &op, int(ut.indir)\n-\n+\treturn &op\n }\n \n // compatibleType asks: Are these two gob Types compatible?\n@@ -1108,9 +1022,9 @@ func (dec *Decoder) compileSingle(remoteId typeId, ut *userTypeInfo) (engine *de\n \t\t}\n \t\treturn nil, errors.New(\"gob: decoding into local type \" + name + \", received remote type \" + remoteType)\n \t}\n-\top, indir := dec.decOpFor(remoteId, rt, name, make(map[reflect.Type]*decOp))\n+\top := dec.decOpFor(remoteId, rt, name, make(map[reflect.Type]*decOp))\n \tovfl := errors.New(`value for \"` + name + `\" out of range`)\n-\tengine.instr[singletonField] = decInstr{*op, singletonField, indir, 0, ovfl}\n+\tengine.instr[singletonField] = decInstr{*op, singletonField, nil, ovfl}\n \tengine.numInstr = 1\n \treturn\n }\n@@ -1121,7 +1035,7 @@ func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err\n \tengine.instr = make([]decInstr, 1) // one item\n \top := dec.decIgnoreOpFor(remoteId)\n \tovfl := overflow(dec.typeString(remoteId))\n-\tengine.instr[0] = decInstr{op, 0, 0, 0, ovfl}\n+\tengine.instr[0] = decInstr{op, 0, nil, ovfl}\n \tengine.numInstr = 1\n \treturn\n }\n@@ -1164,14 +1078,14 @@ func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn\n \t\t// TODO(r): anonymous names\n \t\tif !present || !isExported(wireField.Name) {\n \t\t\top := dec.decIgnoreOpFor(wireField.Id)\n-\t\t\tengine.instr[fieldnum] = decInstr{op, fieldnum, 0, 0, ovfl}\n+\t\t\tengine.instr[fieldnum] = decInstr{op, fieldnum, nil, ovfl}\n \t\t\tcontinue\n \t\t}\n \t\tif !dec.compatibleType(localField.Type, wireField.Id, make(map[reflect.Type]typeId)) {\n \t\t\terrorf(\"wrong type (%s) for received field %s.%s\", localField.Type, wireStruct.Name, wireField.Name)\n \t\t}\n-\t\top, indir := dec.decOpFor(wireField.Id, localField.Type, localField.Name, seen)\n-\t\tengine.instr[fieldnum] = decInstr{*op, fieldnum, indir, uintptr(localField.Offset), ovfl}\n+\t\top := dec.decOpFor(wireField.Id, localField.Type, localField.Name, seen)\n+\t\tengine.instr[fieldnum] = decInstr{*op, fieldnum, localField.Index, ovfl}\n \t\tengine.numInstr++\n \t}\n \treturn\n@@ -1222,32 +1136,33 @@ func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, er\n \treturn\n }\n \n-// decodeValue decodes the data stream representing a value and stores it in val.\n-func (dec *Decoder) decodeValue(wireId typeId, val reflect.Value) {\n+// decodeValue decodes the data stream representing a value and stores it in value.\n+func (dec *Decoder) decodeValue(wireId typeId, value reflect.Value) {\n \tdefer catchError(&dec.err)\n \t// If the value is nil, it means we should just ignore this item.\n-\tif !val.IsValid() {\n+\tif !value.IsValid() {\n \t\tdec.decodeIgnoredValue(wireId)\n \t\treturn\n \t}\n \t// Dereference down to the underlying type.\n-\tut := userType(val.Type())\n+\tut := userType(value.Type())\n \tbase := ut.base\n \tvar enginePtr **decEngine\n \tenginePtr, dec.err = dec.getDecEnginePtr(wireId, ut)\n \tif dec.err != nil {\n \t\treturn\n \t}\n+\tvalue = decAlloc(value)\n \tengine := *enginePtr\n \tif st := base; st.Kind() == reflect.Struct && ut.externalDec == 0 {\n \t\tif engine.numInstr == 0 && st.NumField() > 0 &&\n \t\t\tdec.wireType[wireId] != nil && len(dec.wireType[wireId].StructT.Field) > 0 {\n \t\t\tname := base.Name()\n \t\t\terrorf(\"type mismatch: no fields matched compiling decoder for %s\", name)\n \t\t}\n-\t\tdec.decodeStruct(engine, ut, unsafeAddr(val), ut.indir)\n+\t\tdec.decodeStruct(engine, ut, value)\n \t} else {\n-\t\tdec.decodeSingle(engine, ut, unsafeAddr(val))\n+\t\tdec.decodeSingle(engine, ut, value)\n \t}\n }\n \n@@ -1293,21 +1208,6 @@ func init() {\n \tdecOpTable[reflect.Uintptr] = uop\n }\n \n-// Gob assumes it can call UnsafeAddr on any Value\n-// in order to get a pointer it can copy data from.\n-// Values that have just been created and do not point\n-// into existing structs or slices cannot be addressed,\n-// so simulate it by returning a pointer to a copy.\n-// Each call allocates once.\n-func unsafeAddr(v reflect.Value) unsafe.Pointer {\n-\tif v.CanAddr() {\n-\t\treturn unsafe.Pointer(v.UnsafeAddr())\n-\t}\n-\tx := reflect.New(v.Type()).Elem()\n-\tx.Set(v)\n-\treturn unsafe.Pointer(x.UnsafeAddr())\n-}\n-\n // Gob depends on being able to take the address\n // of zeroed Values it creates, so use this wrapper instead\n // of the standard reflect.Zero."}, {"sha": "c453e9ba397d3c568d05116a5d4398be1d555bcb", "filename": "libgo/go/encoding/gob/decoder.go", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,25 +6,28 @@ package gob\n \n import (\n \t\"bufio\"\n-\t\"bytes\"\n \t\"errors\"\n \t\"io\"\n \t\"reflect\"\n \t\"sync\"\n )\n \n+// tooBig provides a sanity check for sizes; used in several places.\n+// Upper limit of 1GB, allowing room to grow a little without overflow.\n+// TODO: make this adjustable?\n+const tooBig = 1 << 30\n+\n // A Decoder manages the receipt of type and data information read from the\n // remote side of a connection.\n type Decoder struct {\n \tmutex        sync.Mutex                              // each item must be received atomically\n \tr            io.Reader                               // source of the data\n-\tbuf          bytes.Buffer                            // buffer for more efficient i/o from r\n+\tbuf          decBuffer                               // buffer for more efficient i/o from r\n \twireType     map[typeId]*wireType                    // map from remote ID to local description\n \tdecoderCache map[reflect.Type]map[typeId]**decEngine // cache of compiled engines\n \tignorerCache map[typeId]**decEngine                  // ditto for ignored objects\n \tfreeList     *decoderState                           // list of free decoderStates; avoids reallocation\n \tcountBuf     []byte                                  // used for decoding integers while parsing messages\n-\ttmp          []byte                                  // temporary storage for i/o; saves reallocating\n \terr          error\n }\n \n@@ -75,9 +78,7 @@ func (dec *Decoder) recvMessage() bool {\n \t\tdec.err = err\n \t\treturn false\n \t}\n-\t// Upper limit of 1GB, allowing room to grow a little without overflow.\n-\t// TODO: We might want more control over this limit.\n-\tif nbytes >= 1<<30 {\n+\tif nbytes >= tooBig {\n \t\tdec.err = errBadCount\n \t\treturn false\n \t}\n@@ -87,37 +88,17 @@ func (dec *Decoder) recvMessage() bool {\n \n // readMessage reads the next nbytes bytes from the input.\n func (dec *Decoder) readMessage(nbytes int) {\n-\t// Allocate the dec.tmp buffer, up to 10KB.\n-\tconst maxBuf = 10 * 1024\n-\tnTmp := nbytes\n-\tif nTmp > maxBuf {\n-\t\tnTmp = maxBuf\n-\t}\n-\tif cap(dec.tmp) < nTmp {\n-\t\tnAlloc := nTmp + 100 // A little extra for growth.\n-\t\tif nAlloc > maxBuf {\n-\t\t\tnAlloc = maxBuf\n-\t\t}\n-\t\tdec.tmp = make([]byte, nAlloc)\n+\tif dec.buf.Len() != 0 {\n+\t\t// The buffer should always be empty now.\n+\t\tpanic(\"non-empty decoder buffer\")\n \t}\n-\tdec.tmp = dec.tmp[:nTmp]\n-\n \t// Read the data\n-\tdec.buf.Grow(nbytes)\n-\tfor nbytes > 0 {\n-\t\tif nbytes < nTmp {\n-\t\t\tdec.tmp = dec.tmp[:nbytes]\n-\t\t}\n-\t\tvar nRead int\n-\t\tnRead, dec.err = io.ReadFull(dec.r, dec.tmp)\n-\t\tif dec.err != nil {\n-\t\t\tif dec.err == io.EOF {\n-\t\t\t\tdec.err = io.ErrUnexpectedEOF\n-\t\t\t}\n-\t\t\treturn\n+\tdec.buf.Size(nbytes)\n+\t_, dec.err = io.ReadFull(dec.r, dec.buf.Bytes())\n+\tif dec.err != nil {\n+\t\tif dec.err == io.EOF {\n+\t\t\tdec.err = io.ErrUnexpectedEOF\n \t\t}\n-\t\tdec.buf.Write(dec.tmp)\n-\t\tnbytes -= nRead\n \t}\n }\n \n@@ -209,7 +190,7 @@ func (dec *Decoder) Decode(e interface{}) error {\n // Otherwise, it stores the value into v.  In that case, v must represent\n // a non-nil pointer to data or be an assignable reflect.Value (v.CanSet())\n // If the input is at EOF, DecodeValue returns io.EOF and\n-// does not modify e.\n+// does not modify v.\n func (dec *Decoder) DecodeValue(v reflect.Value) error {\n \tif v.IsValid() {\n \t\tif v.Kind() == reflect.Ptr && !v.IsNil() {"}, {"sha": "804e539d84d386f5b7d3854c8c7eee2954977950", "filename": "libgo/go/encoding/gob/enc_helpers.go", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fenc_helpers.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fenc_helpers.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fenc_helpers.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,414 @@\n+// Created by encgen --output enc_helpers.go; DO NOT EDIT\n+\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package gob\n+\n+import (\n+\t\"reflect\"\n+)\n+\n+var encArrayHelper = map[reflect.Kind]encHelper{\n+\treflect.Bool:       encBoolArray,\n+\treflect.Complex64:  encComplex64Array,\n+\treflect.Complex128: encComplex128Array,\n+\treflect.Float32:    encFloat32Array,\n+\treflect.Float64:    encFloat64Array,\n+\treflect.Int:        encIntArray,\n+\treflect.Int16:      encInt16Array,\n+\treflect.Int32:      encInt32Array,\n+\treflect.Int64:      encInt64Array,\n+\treflect.Int8:       encInt8Array,\n+\treflect.String:     encStringArray,\n+\treflect.Uint:       encUintArray,\n+\treflect.Uint16:     encUint16Array,\n+\treflect.Uint32:     encUint32Array,\n+\treflect.Uint64:     encUint64Array,\n+\treflect.Uintptr:    encUintptrArray,\n+}\n+\n+var encSliceHelper = map[reflect.Kind]encHelper{\n+\treflect.Bool:       encBoolSlice,\n+\treflect.Complex64:  encComplex64Slice,\n+\treflect.Complex128: encComplex128Slice,\n+\treflect.Float32:    encFloat32Slice,\n+\treflect.Float64:    encFloat64Slice,\n+\treflect.Int:        encIntSlice,\n+\treflect.Int16:      encInt16Slice,\n+\treflect.Int32:      encInt32Slice,\n+\treflect.Int64:      encInt64Slice,\n+\treflect.Int8:       encInt8Slice,\n+\treflect.String:     encStringSlice,\n+\treflect.Uint:       encUintSlice,\n+\treflect.Uint16:     encUint16Slice,\n+\treflect.Uint32:     encUint32Slice,\n+\treflect.Uint64:     encUint64Slice,\n+\treflect.Uintptr:    encUintptrSlice,\n+}\n+\n+func encBoolArray(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encBoolSlice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encBoolSlice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]bool)\n+\tif !ok {\n+\t\t// It is kind bool but not type bool. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != false || state.sendZero {\n+\t\t\tif x {\n+\t\t\t\tstate.encodeUint(1)\n+\t\t\t} else {\n+\t\t\t\tstate.encodeUint(0)\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encComplex64Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encComplex64Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encComplex64Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]complex64)\n+\tif !ok {\n+\t\t// It is kind complex64 but not type complex64. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0+0i || state.sendZero {\n+\t\t\trpart := floatBits(float64(real(x)))\n+\t\t\tipart := floatBits(float64(imag(x)))\n+\t\t\tstate.encodeUint(rpart)\n+\t\t\tstate.encodeUint(ipart)\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encComplex128Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encComplex128Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encComplex128Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]complex128)\n+\tif !ok {\n+\t\t// It is kind complex128 but not type complex128. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0+0i || state.sendZero {\n+\t\t\trpart := floatBits(real(x))\n+\t\t\tipart := floatBits(imag(x))\n+\t\t\tstate.encodeUint(rpart)\n+\t\t\tstate.encodeUint(ipart)\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encFloat32Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encFloat32Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encFloat32Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]float32)\n+\tif !ok {\n+\t\t// It is kind float32 but not type float32. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tbits := floatBits(float64(x))\n+\t\t\tstate.encodeUint(bits)\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encFloat64Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encFloat64Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encFloat64Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]float64)\n+\tif !ok {\n+\t\t// It is kind float64 but not type float64. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tbits := floatBits(x)\n+\t\t\tstate.encodeUint(bits)\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encIntArray(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encIntSlice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encIntSlice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]int)\n+\tif !ok {\n+\t\t// It is kind int but not type int. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeInt(int64(x))\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encInt16Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encInt16Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encInt16Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]int16)\n+\tif !ok {\n+\t\t// It is kind int16 but not type int16. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeInt(int64(x))\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encInt32Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encInt32Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encInt32Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]int32)\n+\tif !ok {\n+\t\t// It is kind int32 but not type int32. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeInt(int64(x))\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encInt64Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encInt64Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encInt64Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]int64)\n+\tif !ok {\n+\t\t// It is kind int64 but not type int64. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeInt(x)\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encInt8Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encInt8Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encInt8Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]int8)\n+\tif !ok {\n+\t\t// It is kind int8 but not type int8. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeInt(int64(x))\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encStringArray(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encStringSlice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encStringSlice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]string)\n+\tif !ok {\n+\t\t// It is kind string but not type string. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != \"\" || state.sendZero {\n+\t\t\tstate.encodeUint(uint64(len(x)))\n+\t\t\tstate.b.WriteString(x)\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encUintArray(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encUintSlice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encUintSlice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]uint)\n+\tif !ok {\n+\t\t// It is kind uint but not type uint. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeUint(uint64(x))\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encUint16Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encUint16Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encUint16Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]uint16)\n+\tif !ok {\n+\t\t// It is kind uint16 but not type uint16. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeUint(uint64(x))\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encUint32Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encUint32Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encUint32Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]uint32)\n+\tif !ok {\n+\t\t// It is kind uint32 but not type uint32. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeUint(uint64(x))\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encUint64Array(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encUint64Slice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encUint64Slice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]uint64)\n+\tif !ok {\n+\t\t// It is kind uint64 but not type uint64. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeUint(x)\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func encUintptrArray(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn encUintptrSlice(state, v.Slice(0, v.Len()))\n+}\n+\n+func encUintptrSlice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]uintptr)\n+\tif !ok {\n+\t\t// It is kind uintptr but not type uintptr. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != 0 || state.sendZero {\n+\t\t\tstate.encodeUint(uint64(x))\n+\t\t}\n+\t}\n+\treturn true\n+}"}, {"sha": "efdd9282921da612c2d43afc45bb79f0742fcc42", "filename": "libgo/go/encoding/gob/encgen.go", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fencgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fencgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencgen.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+// encgen writes the helper functions for encoding. Intended to be\n+// used with go generate; see the invocation in encode.go.\n+\n+// TODO: We could do more by being unsafe. Add a -unsafe flag?\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/format\"\n+\t\"log\"\n+\t\"os\"\n+)\n+\n+var output = flag.String(\"output\", \"enc_helpers.go\", \"file name to write\")\n+\n+type Type struct {\n+\tlower   string\n+\tupper   string\n+\tzero    string\n+\tencoder string\n+}\n+\n+var types = []Type{\n+\t{\n+\t\t\"bool\",\n+\t\t\"Bool\",\n+\t\t\"false\",\n+\t\t`if x {\n+\t\t\tstate.encodeUint(1)\n+\t\t} else {\n+\t\t\tstate.encodeUint(0)\n+\t\t}`,\n+\t},\n+\t{\n+\t\t\"complex64\",\n+\t\t\"Complex64\",\n+\t\t\"0+0i\",\n+\t\t`rpart := floatBits(float64(real(x)))\n+\t\tipart := floatBits(float64(imag(x)))\n+\t\tstate.encodeUint(rpart)\n+\t\tstate.encodeUint(ipart)`,\n+\t},\n+\t{\n+\t\t\"complex128\",\n+\t\t\"Complex128\",\n+\t\t\"0+0i\",\n+\t\t`rpart := floatBits(real(x))\n+\t\tipart := floatBits(imag(x))\n+\t\tstate.encodeUint(rpart)\n+\t\tstate.encodeUint(ipart)`,\n+\t},\n+\t{\n+\t\t\"float32\",\n+\t\t\"Float32\",\n+\t\t\"0\",\n+\t\t`bits := floatBits(float64(x))\n+\t\tstate.encodeUint(bits)`,\n+\t},\n+\t{\n+\t\t\"float64\",\n+\t\t\"Float64\",\n+\t\t\"0\",\n+\t\t`bits := floatBits(x)\n+\t\tstate.encodeUint(bits)`,\n+\t},\n+\t{\n+\t\t\"int\",\n+\t\t\"Int\",\n+\t\t\"0\",\n+\t\t`state.encodeInt(int64(x))`,\n+\t},\n+\t{\n+\t\t\"int16\",\n+\t\t\"Int16\",\n+\t\t\"0\",\n+\t\t`state.encodeInt(int64(x))`,\n+\t},\n+\t{\n+\t\t\"int32\",\n+\t\t\"Int32\",\n+\t\t\"0\",\n+\t\t`state.encodeInt(int64(x))`,\n+\t},\n+\t{\n+\t\t\"int64\",\n+\t\t\"Int64\",\n+\t\t\"0\",\n+\t\t`state.encodeInt(x)`,\n+\t},\n+\t{\n+\t\t\"int8\",\n+\t\t\"Int8\",\n+\t\t\"0\",\n+\t\t`state.encodeInt(int64(x))`,\n+\t},\n+\t{\n+\t\t\"string\",\n+\t\t\"String\",\n+\t\t`\"\"`,\n+\t\t`state.encodeUint(uint64(len(x)))\n+\t\tstate.b.WriteString(x)`,\n+\t},\n+\t{\n+\t\t\"uint\",\n+\t\t\"Uint\",\n+\t\t\"0\",\n+\t\t`state.encodeUint(uint64(x))`,\n+\t},\n+\t{\n+\t\t\"uint16\",\n+\t\t\"Uint16\",\n+\t\t\"0\",\n+\t\t`state.encodeUint(uint64(x))`,\n+\t},\n+\t{\n+\t\t\"uint32\",\n+\t\t\"Uint32\",\n+\t\t\"0\",\n+\t\t`state.encodeUint(uint64(x))`,\n+\t},\n+\t{\n+\t\t\"uint64\",\n+\t\t\"Uint64\",\n+\t\t\"0\",\n+\t\t`state.encodeUint(x)`,\n+\t},\n+\t{\n+\t\t\"uintptr\",\n+\t\t\"Uintptr\",\n+\t\t\"0\",\n+\t\t`state.encodeUint(uint64(x))`,\n+\t},\n+\t// uint8 Handled separately.\n+}\n+\n+func main() {\n+\tlog.SetFlags(0)\n+\tlog.SetPrefix(\"encgen: \")\n+\tflag.Parse()\n+\tif flag.NArg() != 0 {\n+\t\tlog.Fatal(\"usage: encgen [--output filename]\")\n+\t}\n+\tvar b bytes.Buffer\n+\tfmt.Fprintf(&b, \"// Created by encgen --output %s; DO NOT EDIT\\n\", *output)\n+\tfmt.Fprint(&b, header)\n+\tprintMaps(&b, \"Array\")\n+\tfmt.Fprint(&b, \"\\n\")\n+\tprintMaps(&b, \"Slice\")\n+\tfor _, t := range types {\n+\t\tfmt.Fprintf(&b, arrayHelper, t.lower, t.upper)\n+\t\tfmt.Fprintf(&b, sliceHelper, t.lower, t.upper, t.zero, t.encoder)\n+\t}\n+\tsource, err := format.Source(b.Bytes())\n+\tif err != nil {\n+\t\tlog.Fatal(\"source format error:\", err)\n+\t}\n+\tfd, err := os.Create(*output)\n+\t_, err = fd.Write(source)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}\n+\n+func printMaps(b *bytes.Buffer, upperClass string) {\n+\tfmt.Fprintf(b, \"var enc%sHelper = map[reflect.Kind]encHelper{\\n\", upperClass)\n+\tfor _, t := range types {\n+\t\tfmt.Fprintf(b, \"reflect.%s: enc%s%s,\\n\", t.upper, t.upper, upperClass)\n+\t}\n+\tfmt.Fprintf(b, \"}\\n\")\n+}\n+\n+const header = `\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package gob\n+\n+import (\n+\t\"reflect\"\n+)\n+\n+`\n+\n+const arrayHelper = `\n+func enc%[2]sArray(state *encoderState, v reflect.Value) bool {\n+\t// Can only slice if it is addressable.\n+\tif !v.CanAddr() {\n+\t\treturn false\n+\t}\n+\treturn enc%[2]sSlice(state, v.Slice(0, v.Len()))\n+}\n+`\n+\n+const sliceHelper = `\n+func enc%[2]sSlice(state *encoderState, v reflect.Value) bool {\n+\tslice, ok := v.Interface().([]%[1]s)\n+\tif !ok {\n+\t\t// It is kind %[1]s but not type %[1]s. TODO: We can handle this unsafely.\n+\t\treturn false\n+\t}\n+\tfor _, x := range slice {\n+\t\tif x != %[3]s || state.sendZero {\n+\t\t\t%[4]s\n+\t\t}\n+\t}\n+\treturn true\n+}\n+`"}, {"sha": "f66279f14134b505825c803f15483e89816493e9", "filename": "libgo/go/encoding/gob/encode.go", "status": "modified", "additions": 209, "deletions": 273, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -2,32 +2,66 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:generate go run encgen.go -output enc_helpers.go\n+\n package gob\n \n import (\n-\t\"bytes\"\n \t\"encoding\"\n \t\"math\"\n \t\"reflect\"\n-\t\"unsafe\"\n )\n \n-const uint64Size = int(unsafe.Sizeof(uint64(0)))\n+const uint64Size = 8\n+\n+type encHelper func(state *encoderState, v reflect.Value) bool\n \n // encoderState is the global execution state of an instance of the encoder.\n // Field numbers are delta encoded and always increase. The field\n // number is initialized to -1 so 0 comes out as delta(1). A delta of\n // 0 terminates the structure.\n type encoderState struct {\n \tenc      *Encoder\n-\tb        *bytes.Buffer\n+\tb        *encBuffer\n \tsendZero bool                 // encoding an array element or map key/value pair; send zero values\n \tfieldnum int                  // the last field number written.\n \tbuf      [1 + uint64Size]byte // buffer used by the encoder; here to avoid allocation.\n \tnext     *encoderState        // for free list\n }\n \n-func (enc *Encoder) newEncoderState(b *bytes.Buffer) *encoderState {\n+// encBuffer is an extremely simple, fast implementation of a write-only byte buffer.\n+// It never returns a non-nil error, but Write returns an error value so it matches io.Writer.\n+type encBuffer struct {\n+\tdata    []byte\n+\tscratch [64]byte\n+}\n+\n+func (e *encBuffer) WriteByte(c byte) {\n+\te.data = append(e.data, c)\n+}\n+\n+func (e *encBuffer) Write(p []byte) (int, error) {\n+\te.data = append(e.data, p...)\n+\treturn len(p), nil\n+}\n+\n+func (e *encBuffer) WriteString(s string) {\n+\te.data = append(e.data, s...)\n+}\n+\n+func (e *encBuffer) Len() int {\n+\treturn len(e.data)\n+}\n+\n+func (e *encBuffer) Bytes() []byte {\n+\treturn e.data\n+}\n+\n+func (e *encBuffer) Reset() {\n+\te.data = e.data[0:0]\n+}\n+\n+func (enc *Encoder) newEncoderState(b *encBuffer) *encoderState {\n \te := enc.freeList\n \tif e == nil {\n \t\te = new(encoderState)\n@@ -38,6 +72,9 @@ func (enc *Encoder) newEncoderState(b *bytes.Buffer) *encoderState {\n \te.sendZero = false\n \te.fieldnum = 0\n \te.b = b\n+\tif len(b.data) == 0 {\n+\t\tb.data = b.scratch[0:0]\n+\t}\n \treturn e\n }\n \n@@ -54,10 +91,7 @@ func (enc *Encoder) freeEncoderState(e *encoderState) {\n // encodeUint writes an encoded unsigned integer to state.b.\n func (state *encoderState) encodeUint(x uint64) {\n \tif x <= 0x7F {\n-\t\terr := state.b.WriteByte(uint8(x))\n-\t\tif err != nil {\n-\t\t\terror_(err)\n-\t\t}\n+\t\tstate.b.WriteByte(uint8(x))\n \t\treturn\n \t}\n \ti := uint64Size\n@@ -67,10 +101,7 @@ func (state *encoderState) encodeUint(x uint64) {\n \t\ti--\n \t}\n \tstate.buf[i] = uint8(i - uint64Size) // = loop count, negated\n-\t_, err := state.b.Write(state.buf[i : uint64Size+1])\n-\tif err != nil {\n-\t\terror_(err)\n-\t}\n+\tstate.b.Write(state.buf[i : uint64Size+1])\n }\n \n // encodeInt writes an encoded signed integer to state.w.\n@@ -87,14 +118,14 @@ func (state *encoderState) encodeInt(i int64) {\n }\n \n // encOp is the signature of an encoding operator for a given type.\n-type encOp func(i *encInstr, state *encoderState, p unsafe.Pointer)\n+type encOp func(i *encInstr, state *encoderState, v reflect.Value)\n \n // The 'instructions' of the encoding machine\n type encInstr struct {\n-\top     encOp\n-\tfield  int     // field number\n-\tindir  int     // how many pointer indirections to reach the value in the struct\n-\toffset uintptr // offset in the structure of the field to encode\n+\top    encOp\n+\tfield int   // field number in input\n+\tindex []int // struct index\n+\tindir int   // how many pointer indirections to reach the value in the struct\n }\n \n // update emits a field number and updates the state to record its value for delta encoding.\n@@ -115,20 +146,20 @@ func (state *encoderState) update(instr *encInstr) {\n // encoded integer, followed by the field data in its appropriate\n // format.\n \n-// encIndirect dereferences p indir times and returns the result.\n-func encIndirect(p unsafe.Pointer, indir int) unsafe.Pointer {\n+// encIndirect dereferences pv indir times and returns the result.\n+func encIndirect(pv reflect.Value, indir int) reflect.Value {\n \tfor ; indir > 0; indir-- {\n-\t\tp = *(*unsafe.Pointer)(p)\n-\t\tif p == nil {\n-\t\t\treturn unsafe.Pointer(nil)\n+\t\tif pv.IsNil() {\n+\t\t\tbreak\n \t\t}\n+\t\tpv = pv.Elem()\n \t}\n-\treturn p\n+\treturn pv\n }\n \n-// encBool encodes the bool with address p as an unsigned 0 or 1.\n-func encBool(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tb := *(*bool)(p)\n+// encBool encodes the bool referenced by v as an unsigned 0 or 1.\n+func encBool(i *encInstr, state *encoderState, v reflect.Value) {\n+\tb := v.Bool()\n \tif b || state.sendZero {\n \t\tstate.update(i)\n \t\tif b {\n@@ -139,102 +170,21 @@ func encBool(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n-// encInt encodes the int with address p.\n-func encInt(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := int64(*(*int)(p))\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeInt(v)\n-\t}\n-}\n-\n-// encUint encodes the uint with address p.\n-func encUint(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := uint64(*(*uint)(p))\n-\tif v != 0 || state.sendZero {\n+// encInt encodes the signed integer (int int8 int16 int32 int64) referenced by v.\n+func encInt(i *encInstr, state *encoderState, v reflect.Value) {\n+\tvalue := v.Int()\n+\tif value != 0 || state.sendZero {\n \t\tstate.update(i)\n-\t\tstate.encodeUint(v)\n+\t\tstate.encodeInt(value)\n \t}\n }\n \n-// encInt8 encodes the int8 with address p.\n-func encInt8(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := int64(*(*int8)(p))\n-\tif v != 0 || state.sendZero {\n+// encUint encodes the unsigned integer (uint uint8 uint16 uint32 uint64 uintptr) referenced by v.\n+func encUint(i *encInstr, state *encoderState, v reflect.Value) {\n+\tvalue := v.Uint()\n+\tif value != 0 || state.sendZero {\n \t\tstate.update(i)\n-\t\tstate.encodeInt(v)\n-\t}\n-}\n-\n-// encUint8 encodes the uint8 with address p.\n-func encUint8(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := uint64(*(*uint8)(p))\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeUint(v)\n-\t}\n-}\n-\n-// encInt16 encodes the int16 with address p.\n-func encInt16(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := int64(*(*int16)(p))\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeInt(v)\n-\t}\n-}\n-\n-// encUint16 encodes the uint16 with address p.\n-func encUint16(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := uint64(*(*uint16)(p))\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeUint(v)\n-\t}\n-}\n-\n-// encInt32 encodes the int32 with address p.\n-func encInt32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := int64(*(*int32)(p))\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeInt(v)\n-\t}\n-}\n-\n-// encUint encodes the uint32 with address p.\n-func encUint32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := uint64(*(*uint32)(p))\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeUint(v)\n-\t}\n-}\n-\n-// encInt64 encodes the int64 with address p.\n-func encInt64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := *(*int64)(p)\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeInt(v)\n-\t}\n-}\n-\n-// encInt64 encodes the uint64 with address p.\n-func encUint64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := *(*uint64)(p)\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeUint(v)\n-\t}\n-}\n-\n-// encUintptr encodes the uintptr with address p.\n-func encUintptr(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tv := uint64(*(*uintptr)(p))\n-\tif v != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tstate.encodeUint(v)\n+\t\tstate.encodeUint(value)\n \t}\n }\n \n@@ -255,42 +205,20 @@ func floatBits(f float64) uint64 {\n \treturn v\n }\n \n-// encFloat32 encodes the float32 with address p.\n-func encFloat32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tf := *(*float32)(p)\n+// encFloat encodes the floating point value (float32 float64) referenced by v.\n+func encFloat(i *encInstr, state *encoderState, v reflect.Value) {\n+\tf := v.Float()\n \tif f != 0 || state.sendZero {\n-\t\tv := floatBits(float64(f))\n+\t\tbits := floatBits(f)\n \t\tstate.update(i)\n-\t\tstate.encodeUint(v)\n+\t\tstate.encodeUint(bits)\n \t}\n }\n \n-// encFloat64 encodes the float64 with address p.\n-func encFloat64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tf := *(*float64)(p)\n-\tif f != 0 || state.sendZero {\n-\t\tstate.update(i)\n-\t\tv := floatBits(f)\n-\t\tstate.encodeUint(v)\n-\t}\n-}\n-\n-// encComplex64 encodes the complex64 with address p.\n+// encComplex encodes the complex value (complex64 complex128) referenced by v.\n // Complex numbers are just a pair of floating-point numbers, real part first.\n-func encComplex64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tc := *(*complex64)(p)\n-\tif c != 0+0i || state.sendZero {\n-\t\trpart := floatBits(float64(real(c)))\n-\t\tipart := floatBits(float64(imag(c)))\n-\t\tstate.update(i)\n-\t\tstate.encodeUint(rpart)\n-\t\tstate.encodeUint(ipart)\n-\t}\n-}\n-\n-// encComplex128 encodes the complex128 with address p.\n-func encComplex128(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tc := *(*complex128)(p)\n+func encComplex(i *encInstr, state *encoderState, v reflect.Value) {\n+\tc := v.Complex()\n \tif c != 0+0i || state.sendZero {\n \t\trpart := floatBits(real(c))\n \t\tipart := floatBits(imag(c))\n@@ -300,21 +228,21 @@ func encComplex128(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n-// encUint8Array encodes the byte slice whose header has address p.\n+// encUint8Array encodes the byte array referenced by v.\n // Byte arrays are encoded as an unsigned count followed by the raw bytes.\n-func encUint8Array(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\tb := *(*[]byte)(p)\n+func encUint8Array(i *encInstr, state *encoderState, v reflect.Value) {\n+\tb := v.Bytes()\n \tif len(b) > 0 || state.sendZero {\n \t\tstate.update(i)\n \t\tstate.encodeUint(uint64(len(b)))\n \t\tstate.b.Write(b)\n \t}\n }\n \n-// encString encodes the string whose header has address p.\n+// encString encodes the string referenced by v.\n // Strings are encoded as an unsigned count followed by the raw bytes.\n-func encString(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\ts := *(*string)(p)\n+func encString(i *encInstr, state *encoderState, v reflect.Value) {\n+\ts := v.String()\n \tif len(s) > 0 || state.sendZero {\n \t\tstate.update(i)\n \t\tstate.encodeUint(uint64(len(s)))\n@@ -324,7 +252,7 @@ func encString(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \n // encStructTerminator encodes the end of an encoded struct\n // as delta field number of 0.\n-func encStructTerminator(i *encInstr, state *encoderState, p unsafe.Pointer) {\n+func encStructTerminator(i *encInstr, state *encoderState, v reflect.Value) {\n \tstate.encodeUint(0)\n }\n \n@@ -338,60 +266,83 @@ type encEngine struct {\n \n const singletonField = 0\n \n+// valid reports whether the value is valid and a non-nil pointer.\n+// (Slices, maps, and chans take care of themselves.)\n+func valid(v reflect.Value) bool {\n+\tswitch v.Kind() {\n+\tcase reflect.Invalid:\n+\t\treturn false\n+\tcase reflect.Ptr:\n+\t\treturn !v.IsNil()\n+\t}\n+\treturn true\n+}\n+\n // encodeSingle encodes a single top-level non-struct value.\n-func (enc *Encoder) encodeSingle(b *bytes.Buffer, engine *encEngine, basep unsafe.Pointer) {\n+func (enc *Encoder) encodeSingle(b *encBuffer, engine *encEngine, value reflect.Value) {\n \tstate := enc.newEncoderState(b)\n+\tdefer enc.freeEncoderState(state)\n \tstate.fieldnum = singletonField\n \t// There is no surrounding struct to frame the transmission, so we must\n \t// generate data even if the item is zero.  To do this, set sendZero.\n \tstate.sendZero = true\n \tinstr := &engine.instr[singletonField]\n-\tp := basep // offset will be zero\n \tif instr.indir > 0 {\n-\t\tif p = encIndirect(p, instr.indir); p == nil {\n-\t\t\treturn\n-\t\t}\n+\t\tvalue = encIndirect(value, instr.indir)\n+\t}\n+\tif valid(value) {\n+\t\tinstr.op(instr, state, value)\n \t}\n-\tinstr.op(instr, state, p)\n-\tenc.freeEncoderState(state)\n }\n \n // encodeStruct encodes a single struct value.\n-func (enc *Encoder) encodeStruct(b *bytes.Buffer, engine *encEngine, basep unsafe.Pointer) {\n+func (enc *Encoder) encodeStruct(b *encBuffer, engine *encEngine, value reflect.Value) {\n+\tif !valid(value) {\n+\t\treturn\n+\t}\n \tstate := enc.newEncoderState(b)\n+\tdefer enc.freeEncoderState(state)\n \tstate.fieldnum = -1\n \tfor i := 0; i < len(engine.instr); i++ {\n \t\tinstr := &engine.instr[i]\n-\t\tp := unsafe.Pointer(uintptr(basep) + instr.offset)\n+\t\tif i >= value.NumField() {\n+\t\t\t// encStructTerminator\n+\t\t\tinstr.op(instr, state, reflect.Value{})\n+\t\t\tbreak\n+\t\t}\n+\t\tfield := value.FieldByIndex(instr.index)\n \t\tif instr.indir > 0 {\n-\t\t\tif p = encIndirect(p, instr.indir); p == nil {\n+\t\t\tfield = encIndirect(field, instr.indir)\n+\t\t\t// TODO: Is field guaranteed valid? If so we could avoid this check.\n+\t\t\tif !valid(field) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n-\t\tinstr.op(instr, state, p)\n+\t\tinstr.op(instr, state, field)\n \t}\n-\tenc.freeEncoderState(state)\n }\n \n-// encodeArray encodes the array whose 0th element is at p.\n-func (enc *Encoder) encodeArray(b *bytes.Buffer, p unsafe.Pointer, op encOp, elemWid uintptr, elemIndir int, length int) {\n+// encodeArray encodes an array.\n+func (enc *Encoder) encodeArray(b *encBuffer, value reflect.Value, op encOp, elemIndir int, length int, helper encHelper) {\n \tstate := enc.newEncoderState(b)\n+\tdefer enc.freeEncoderState(state)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n \tstate.encodeUint(uint64(length))\n+\tif helper != nil && helper(state, value) {\n+\t\treturn\n+\t}\n \tfor i := 0; i < length; i++ {\n-\t\telemp := p\n+\t\telem := value.Index(i)\n \t\tif elemIndir > 0 {\n-\t\t\tup := encIndirect(elemp, elemIndir)\n-\t\t\tif up == nil {\n+\t\t\telem = encIndirect(elem, elemIndir)\n+\t\t\t// TODO: Is elem guaranteed valid? If so we could avoid this check.\n+\t\t\tif !valid(elem) {\n \t\t\t\terrorf(\"encodeArray: nil element\")\n \t\t\t}\n-\t\t\telemp = up\n \t\t}\n-\t\top(nil, state, elemp)\n-\t\tp = unsafe.Pointer(uintptr(p) + elemWid)\n+\t\top(nil, state, elem)\n \t}\n-\tenc.freeEncoderState(state)\n }\n \n // encodeReflectValue is a helper for maps. It encodes the value v.\n@@ -402,13 +353,11 @@ func encodeReflectValue(state *encoderState, v reflect.Value, op encOp, indir in\n \tif !v.IsValid() {\n \t\terrorf(\"encodeReflectValue: nil element\")\n \t}\n-\top(nil, state, unsafeAddr(v))\n+\top(nil, state, v)\n }\n \n // encodeMap encodes a map as unsigned count followed by key:value pairs.\n-// Because map internals are not exposed, we must use reflection rather than\n-// addresses.\n-func (enc *Encoder) encodeMap(b *bytes.Buffer, mv reflect.Value, keyOp, elemOp encOp, keyIndir, elemIndir int) {\n+func (enc *Encoder) encodeMap(b *encBuffer, mv reflect.Value, keyOp, elemOp encOp, keyIndir, elemIndir int) {\n \tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n@@ -426,7 +375,7 @@ func (enc *Encoder) encodeMap(b *bytes.Buffer, mv reflect.Value, keyOp, elemOp e\n // by the type identifier (which might require defining that type right now), followed\n // by the concrete value.  A nil value gets sent as the empty string for the name,\n // followed by no value.\n-func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n+func (enc *Encoder) encodeInterface(b *encBuffer, iv reflect.Value) {\n \t// Gobs can encode nil interface values but not typed interface\n \t// values holding nil pointers, since nil pointers point to no value.\n \telem := iv.Elem()\n@@ -450,18 +399,15 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n \t}\n \t// Send the name.\n \tstate.encodeUint(uint64(len(name)))\n-\t_, err := state.b.WriteString(name)\n-\tif err != nil {\n-\t\terror_(err)\n-\t}\n+\tstate.b.WriteString(name)\n \t// Define the type id if necessary.\n \tenc.sendTypeDescriptor(enc.writer(), state, ut)\n \t// Send the type id.\n \tenc.sendTypeId(state, ut)\n \t// Encode the value into a new buffer.  Any nested type definitions\n \t// should be written to b, before the encoded value.\n \tenc.pushWriter(b)\n-\tdata := new(bytes.Buffer)\n+\tdata := new(encBuffer)\n \tdata.Write(spaceForLength)\n \tenc.encode(data, elem, ut)\n \tif enc.err != nil {\n@@ -470,7 +416,7 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv reflect.Value) {\n \tenc.popWriter()\n \tenc.writeMessage(b, data)\n \tif enc.err != nil {\n-\t\terror_(err)\n+\t\terror_(enc.err)\n \t}\n \tenc.freeEncoderState(state)\n }\n@@ -512,7 +458,7 @@ func isZero(val reflect.Value) bool {\n \n // encGobEncoder encodes a value that implements the GobEncoder interface.\n // The data is sent as a byte array.\n-func (enc *Encoder) encodeGobEncoder(b *bytes.Buffer, ut *userTypeInfo, v reflect.Value) {\n+func (enc *Encoder) encodeGobEncoder(b *encBuffer, ut *userTypeInfo, v reflect.Value) {\n \t// TODO: should we catch panics from the called method?\n \n \tvar data []byte\n@@ -539,30 +485,30 @@ func (enc *Encoder) encodeGobEncoder(b *bytes.Buffer, ut *userTypeInfo, v reflec\n var encOpTable = [...]encOp{\n \treflect.Bool:       encBool,\n \treflect.Int:        encInt,\n-\treflect.Int8:       encInt8,\n-\treflect.Int16:      encInt16,\n-\treflect.Int32:      encInt32,\n-\treflect.Int64:      encInt64,\n+\treflect.Int8:       encInt,\n+\treflect.Int16:      encInt,\n+\treflect.Int32:      encInt,\n+\treflect.Int64:      encInt,\n \treflect.Uint:       encUint,\n-\treflect.Uint8:      encUint8,\n-\treflect.Uint16:     encUint16,\n-\treflect.Uint32:     encUint32,\n-\treflect.Uint64:     encUint64,\n-\treflect.Uintptr:    encUintptr,\n-\treflect.Float32:    encFloat32,\n-\treflect.Float64:    encFloat64,\n-\treflect.Complex64:  encComplex64,\n-\treflect.Complex128: encComplex128,\n+\treflect.Uint8:      encUint,\n+\treflect.Uint16:     encUint,\n+\treflect.Uint32:     encUint,\n+\treflect.Uint64:     encUint,\n+\treflect.Uintptr:    encUint,\n+\treflect.Float32:    encFloat,\n+\treflect.Float64:    encFloat,\n+\treflect.Complex64:  encComplex,\n+\treflect.Complex128: encComplex,\n \treflect.String:     encString,\n }\n \n // encOpFor returns (a pointer to) the encoding op for the base type under rt and\n // the indirection count to reach it.\n-func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp) (*encOp, int) {\n+func encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp, building map[*typeInfo]bool) (*encOp, int) {\n \tut := userType(rt)\n \t// If the type implements GobEncoder, we handle it without further processing.\n \tif ut.externalEnc != 0 {\n-\t\treturn enc.gobEncodeOpFor(ut)\n+\t\treturn gobEncodeOpFor(ut)\n \t}\n \t// If this type is already in progress, it's a recursive type (e.g. map[string]*T).\n \t// Return the pointer to the op we're already building.\n@@ -586,31 +532,27 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\t\tbreak\n \t\t\t}\n \t\t\t// Slices have a header; we decode it to find the underlying array.\n-\t\t\telemOp, elemIndir := enc.encOpFor(t.Elem(), inProgress)\n-\t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\t\t\t\tslice := (*reflect.SliceHeader)(p)\n-\t\t\t\tif !state.sendZero && slice.Len == 0 {\n+\t\t\telemOp, elemIndir := encOpFor(t.Elem(), inProgress, building)\n+\t\t\thelper := encSliceHelper[t.Elem().Kind()]\n+\t\t\top = func(i *encInstr, state *encoderState, slice reflect.Value) {\n+\t\t\t\tif !state.sendZero && slice.Len() == 0 {\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tstate.update(i)\n-\t\t\t\tstate.enc.encodeArray(state.b, unsafe.Pointer(slice.Data), *elemOp, t.Elem().Size(), elemIndir, int(slice.Len))\n+\t\t\t\tstate.enc.encodeArray(state.b, slice, *elemOp, elemIndir, slice.Len(), helper)\n \t\t\t}\n \t\tcase reflect.Array:\n \t\t\t// True arrays have size in the type.\n-\t\t\telemOp, elemIndir := enc.encOpFor(t.Elem(), inProgress)\n-\t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n+\t\t\telemOp, elemIndir := encOpFor(t.Elem(), inProgress, building)\n+\t\t\thelper := encArrayHelper[t.Elem().Kind()]\n+\t\t\top = func(i *encInstr, state *encoderState, array reflect.Value) {\n \t\t\t\tstate.update(i)\n-\t\t\t\tstate.enc.encodeArray(state.b, p, *elemOp, t.Elem().Size(), elemIndir, t.Len())\n+\t\t\t\tstate.enc.encodeArray(state.b, array, *elemOp, elemIndir, array.Len(), helper)\n \t\t\t}\n \t\tcase reflect.Map:\n-\t\t\tkeyOp, keyIndir := enc.encOpFor(t.Key(), inProgress)\n-\t\t\telemOp, elemIndir := enc.encOpFor(t.Elem(), inProgress)\n-\t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\t\t\t\t// Maps cannot be accessed by moving addresses around the way\n-\t\t\t\t// that slices etc. can.  We must recover a full reflection value for\n-\t\t\t\t// the iteration.\n-\t\t\t\tv := reflect.NewAt(t, unsafe.Pointer(p)).Elem()\n-\t\t\t\tmv := reflect.Indirect(v)\n+\t\t\tkeyOp, keyIndir := encOpFor(t.Key(), inProgress, building)\n+\t\t\telemOp, elemIndir := encOpFor(t.Elem(), inProgress, building)\n+\t\t\top = func(i *encInstr, state *encoderState, mv reflect.Value) {\n \t\t\t\t// We send zero-length (but non-nil) maps because the\n \t\t\t\t// receiver might want to use the map.  (Maps don't use append.)\n \t\t\t\tif !state.sendZero && mv.IsNil() {\n@@ -621,19 +563,16 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\t}\n \t\tcase reflect.Struct:\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n-\t\t\tenc.getEncEngine(userType(typ))\n+\t\t\tgetEncEngine(userType(typ), building)\n \t\t\tinfo := mustGetTypeInfo(typ)\n-\t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n+\t\t\top = func(i *encInstr, state *encoderState, sv reflect.Value) {\n \t\t\t\tstate.update(i)\n \t\t\t\t// indirect through info to delay evaluation for recursive structs\n-\t\t\t\tstate.enc.encodeStruct(state.b, info.encoder, p)\n+\t\t\t\tenc := info.encoder.Load().(*encEngine)\n+\t\t\t\tstate.enc.encodeStruct(state.b, enc, sv)\n \t\t\t}\n \t\tcase reflect.Interface:\n-\t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\t\t\t\t// Interfaces transmit the name and contents of the concrete\n-\t\t\t\t// value they contain.\n-\t\t\t\tv := reflect.NewAt(t, unsafe.Pointer(p)).Elem()\n-\t\t\t\tiv := reflect.Indirect(v)\n+\t\t\top = func(i *encInstr, state *encoderState, iv reflect.Value) {\n \t\t\t\tif !state.sendZero && (!iv.IsValid() || iv.IsNil()) {\n \t\t\t\t\treturn\n \t\t\t\t}\n@@ -648,9 +587,8 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \treturn &op, indir\n }\n \n-// gobEncodeOpFor returns the op for a type that is known to implement\n-// GobEncoder.\n-func (enc *Encoder) gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n+// gobEncodeOpFor returns the op for a type that is known to implement GobEncoder.\n+func gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n \trt := ut.user\n \tif ut.encIndir == -1 {\n \t\trt = reflect.PtrTo(rt)\n@@ -660,13 +598,13 @@ func (enc *Encoder) gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n \t\t}\n \t}\n \tvar op encOp\n-\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-\t\tvar v reflect.Value\n+\top = func(i *encInstr, state *encoderState, v reflect.Value) {\n \t\tif ut.encIndir == -1 {\n \t\t\t// Need to climb up one level to turn value into pointer.\n-\t\t\tv = reflect.NewAt(rt, unsafe.Pointer(&p)).Elem()\n-\t\t} else {\n-\t\t\tv = reflect.NewAt(rt, p).Elem()\n+\t\t\tif !v.CanAddr() {\n+\t\t\t\terrorf(\"unaddressable value of type %s\", rt)\n+\t\t\t}\n+\t\t\tv = v.Addr()\n \t\t}\n \t\tif !state.sendZero && isZero(v) {\n \t\t\treturn\n@@ -678,7 +616,7 @@ func (enc *Encoder) gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n }\n \n // compileEnc returns the engine to compile the type.\n-func (enc *Encoder) compileEnc(ut *userTypeInfo) *encEngine {\n+func compileEnc(ut *userTypeInfo, building map[*typeInfo]bool) *encEngine {\n \tsrt := ut.base\n \tengine := new(encEngine)\n \tseen := make(map[reflect.Type]*encOp)\n@@ -692,59 +630,57 @@ func (enc *Encoder) compileEnc(ut *userTypeInfo) *encEngine {\n \t\t\tif !isSent(&f) {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\top, indir := enc.encOpFor(f.Type, seen)\n-\t\t\tengine.instr = append(engine.instr, encInstr{*op, wireFieldNum, indir, uintptr(f.Offset)})\n+\t\t\top, indir := encOpFor(f.Type, seen, building)\n+\t\t\tengine.instr = append(engine.instr, encInstr{*op, wireFieldNum, f.Index, indir})\n \t\t\twireFieldNum++\n \t\t}\n \t\tif srt.NumField() > 0 && len(engine.instr) == 0 {\n \t\t\terrorf(\"type %s has no exported fields\", rt)\n \t\t}\n-\t\tengine.instr = append(engine.instr, encInstr{encStructTerminator, 0, 0, 0})\n+\t\tengine.instr = append(engine.instr, encInstr{encStructTerminator, 0, nil, 0})\n \t} else {\n \t\tengine.instr = make([]encInstr, 1)\n-\t\top, indir := enc.encOpFor(rt, seen)\n-\t\tengine.instr[0] = encInstr{*op, singletonField, indir, 0} // offset is zero\n+\t\top, indir := encOpFor(rt, seen, building)\n+\t\tengine.instr[0] = encInstr{*op, singletonField, nil, indir}\n \t}\n \treturn engine\n }\n \n // getEncEngine returns the engine to compile the type.\n-// typeLock must be held (or we're in initialization and guaranteed single-threaded).\n-func (enc *Encoder) getEncEngine(ut *userTypeInfo) *encEngine {\n-\tinfo, err1 := getTypeInfo(ut)\n-\tif err1 != nil {\n-\t\terror_(err1)\n-\t}\n-\tif info.encoder == nil {\n-\t\t// Assign the encEngine now, so recursive types work correctly. But...\n-\t\tinfo.encoder = new(encEngine)\n-\t\t// ... if we fail to complete building the engine, don't cache the half-built machine.\n-\t\t// Doing this here means we won't cache a type that is itself OK but\n-\t\t// that contains a nested type that won't compile. The result is consistent\n-\t\t// error behavior when Encode is called multiple times on the top-level type.\n-\t\tok := false\n-\t\tdefer func() {\n-\t\t\tif !ok {\n-\t\t\t\tinfo.encoder = nil\n-\t\t\t}\n-\t\t}()\n-\t\tinfo.encoder = enc.compileEnc(ut)\n-\t\tok = true\n+func getEncEngine(ut *userTypeInfo, building map[*typeInfo]bool) *encEngine {\n+\tinfo, err := getTypeInfo(ut)\n+\tif err != nil {\n+\t\terror_(err)\n \t}\n-\treturn info.encoder\n+\tenc, ok := info.encoder.Load().(*encEngine)\n+\tif !ok {\n+\t\tenc = buildEncEngine(info, ut, building)\n+\t}\n+\treturn enc\n }\n \n-// lockAndGetEncEngine is a function that locks and compiles.\n-// This lets us hold the lock only while compiling, not when encoding.\n-func (enc *Encoder) lockAndGetEncEngine(ut *userTypeInfo) *encEngine {\n-\ttypeLock.Lock()\n-\tdefer typeLock.Unlock()\n-\treturn enc.getEncEngine(ut)\n+func buildEncEngine(info *typeInfo, ut *userTypeInfo, building map[*typeInfo]bool) *encEngine {\n+\t// Check for recursive types.\n+\tif building != nil && building[info] {\n+\t\treturn nil\n+\t}\n+\tinfo.encInit.Lock()\n+\tdefer info.encInit.Unlock()\n+\tenc, ok := info.encoder.Load().(*encEngine)\n+\tif !ok {\n+\t\tif building == nil {\n+\t\t\tbuilding = make(map[*typeInfo]bool)\n+\t\t}\n+\t\tbuilding[info] = true\n+\t\tenc = compileEnc(ut, building)\n+\t\tinfo.encoder.Store(enc)\n+\t}\n+\treturn enc\n }\n \n-func (enc *Encoder) encode(b *bytes.Buffer, value reflect.Value, ut *userTypeInfo) {\n+func (enc *Encoder) encode(b *encBuffer, value reflect.Value, ut *userTypeInfo) {\n \tdefer catchError(&enc.err)\n-\tengine := enc.lockAndGetEncEngine(ut)\n+\tengine := getEncEngine(ut, nil)\n \tindir := ut.indir\n \tif ut.externalEnc != 0 {\n \t\tindir = int(ut.encIndir)\n@@ -753,8 +689,8 @@ func (enc *Encoder) encode(b *bytes.Buffer, value reflect.Value, ut *userTypeInf\n \t\tvalue = reflect.Indirect(value)\n \t}\n \tif ut.externalEnc == 0 && value.Type().Kind() == reflect.Struct {\n-\t\tenc.encodeStruct(b, engine, unsafeAddr(value))\n+\t\tenc.encodeStruct(b, engine, value)\n \t} else {\n-\t\tenc.encodeSingle(b, engine, unsafeAddr(value))\n+\t\tenc.encodeSingle(b, engine, value)\n \t}\n }"}, {"sha": "a340e47b5ed6a903cc954738421e1e52a2327790", "filename": "libgo/go/encoding/gob/encoder.go", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -5,7 +5,6 @@\n package gob\n \n import (\n-\t\"bytes\"\n \t\"io\"\n \t\"reflect\"\n \t\"sync\"\n@@ -19,7 +18,7 @@ type Encoder struct {\n \tsent       map[reflect.Type]typeId // which types we've already sent\n \tcountState *encoderState           // stage for writing counts\n \tfreeList   *encoderState           // list of free encoderStates; avoids reallocation\n-\tbyteBuf    bytes.Buffer            // buffer for top-level encoderState\n+\tbyteBuf    encBuffer               // buffer for top-level encoderState\n \terr        error\n }\n \n@@ -34,7 +33,7 @@ func NewEncoder(w io.Writer) *Encoder {\n \tenc := new(Encoder)\n \tenc.w = []io.Writer{w}\n \tenc.sent = make(map[reflect.Type]typeId)\n-\tenc.countState = enc.newEncoderState(new(bytes.Buffer))\n+\tenc.countState = enc.newEncoderState(new(encBuffer))\n \treturn enc\n }\n \n@@ -60,7 +59,7 @@ func (enc *Encoder) setError(err error) {\n }\n \n // writeMessage sends the data item preceded by a unsigned count of its length.\n-func (enc *Encoder) writeMessage(w io.Writer, b *bytes.Buffer) {\n+func (enc *Encoder) writeMessage(w io.Writer, b *encBuffer) {\n \t// Space has been reserved for the length at the head of the message.\n \t// This is a little dirty: we grab the slice from the bytes.Buffer and massage\n \t// it by hand.\n@@ -88,9 +87,7 @@ func (enc *Encoder) sendActualType(w io.Writer, state *encoderState, ut *userTyp\n \tif _, alreadySent := enc.sent[actual]; alreadySent {\n \t\treturn false\n \t}\n-\ttypeLock.Lock()\n \tinfo, err := getTypeInfo(ut)\n-\ttypeLock.Unlock()\n \tif err != nil {\n \t\tenc.setError(err)\n \t\treturn\n@@ -191,9 +188,7 @@ func (enc *Encoder) sendTypeDescriptor(w io.Writer, state *encoderState, ut *use\n \t\t// a singleton basic type (int, []byte etc.) at top level.  We don't\n \t\t// need to send the type info but we do need to update enc.sent.\n \t\tif !sent {\n-\t\t\ttypeLock.Lock()\n \t\t\tinfo, err := getTypeInfo(ut)\n-\t\t\ttypeLock.Unlock()\n \t\t\tif err != nil {\n \t\t\t\tenc.setError(err)\n \t\t\t\treturn"}, {"sha": "0ea4c0ec8e5f479c5eff8d973353d03ea08d30ae", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 96, "deletions": 2, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -13,6 +13,52 @@ import (\n \t\"testing\"\n )\n \n+// Test basic operations in a safe manner.\n+func TestBasicEncoderDecoder(t *testing.T) {\n+\tvar values = []interface{}{\n+\t\ttrue,\n+\t\tint(123),\n+\t\tint8(123),\n+\t\tint16(-12345),\n+\t\tint32(123456),\n+\t\tint64(-1234567),\n+\t\tuint(123),\n+\t\tuint8(123),\n+\t\tuint16(12345),\n+\t\tuint32(123456),\n+\t\tuint64(1234567),\n+\t\tuintptr(12345678),\n+\t\tfloat32(1.2345),\n+\t\tfloat64(1.2345678),\n+\t\tcomplex64(1.2345 + 2.3456i),\n+\t\tcomplex128(1.2345678 + 2.3456789i),\n+\t\t[]byte(\"hello\"),\n+\t\tstring(\"hello\"),\n+\t}\n+\tfor _, value := range values {\n+\t\tb := new(bytes.Buffer)\n+\t\tenc := NewEncoder(b)\n+\t\terr := enc.Encode(value)\n+\t\tif err != nil {\n+\t\t\tt.Error(\"encoder fail:\", err)\n+\t\t}\n+\t\tdec := NewDecoder(b)\n+\t\tresult := reflect.New(reflect.TypeOf(value))\n+\t\terr = dec.Decode(result.Interface())\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"error decoding %T: %v:\", reflect.TypeOf(value), err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(value, result.Elem().Interface()) {\n+\t\t\tt.Fatalf(\"%T: expected %v got %v\", value, value, result.Elem().Interface())\n+\t\t}\n+\t}\n+}\n+\n+type ET0 struct {\n+\tA int\n+\tB string\n+}\n+\n type ET2 struct {\n \tX string\n }\n@@ -40,14 +86,40 @@ type ET4 struct {\n func TestEncoderDecoder(t *testing.T) {\n \tb := new(bytes.Buffer)\n \tenc := NewEncoder(b)\n+\tet0 := new(ET0)\n+\tet0.A = 7\n+\tet0.B = \"gobs of fun\"\n+\terr := enc.Encode(et0)\n+\tif err != nil {\n+\t\tt.Error(\"encoder fail:\", err)\n+\t}\n+\t//fmt.Printf(\"% x %q\\n\", b, b)\n+\t//Debug(b)\n+\tdec := NewDecoder(b)\n+\tnewEt0 := new(ET0)\n+\terr = dec.Decode(newEt0)\n+\tif err != nil {\n+\t\tt.Fatal(\"error decoding ET0:\", err)\n+\t}\n+\n+\tif !reflect.DeepEqual(et0, newEt0) {\n+\t\tt.Fatalf(\"invalid data for et0: expected %+v; got %+v\", *et0, *newEt0)\n+\t}\n+\tif b.Len() != 0 {\n+\t\tt.Error(\"not at eof;\", b.Len(), \"bytes left\")\n+\t}\n+\t//\tt.FailNow()\n+\n+\tb = new(bytes.Buffer)\n+\tenc = NewEncoder(b)\n \tet1 := new(ET1)\n \tet1.A = 7\n \tet1.Et2 = new(ET2)\n-\terr := enc.Encode(et1)\n+\terr = enc.Encode(et1)\n \tif err != nil {\n \t\tt.Error(\"encoder fail:\", err)\n \t}\n-\tdec := NewDecoder(b)\n+\tdec = NewDecoder(b)\n \tnewEt1 := new(ET1)\n \terr = dec.Decode(newEt1)\n \tif err != nil {\n@@ -860,3 +932,25 @@ func Test29ElementSlice(t *testing.T) {\n \t\treturn\n \t}\n }\n+\n+// Don't crash, just give error when allocating a huge slice.\n+// Issue 8084.\n+func TestErrorForHugeSlice(t *testing.T) {\n+\t// Encode an int slice.\n+\tbuf := new(bytes.Buffer)\n+\tslice := []int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n+\terr := NewEncoder(buf).Encode(slice)\n+\tif err != nil {\n+\t\tt.Fatal(\"encode:\", err)\n+\t}\n+\t// Reach into the buffer and smash the count to make the encoded slice very long.\n+\tbuf.Bytes()[buf.Len()-len(slice)-1] = 0xfa\n+\t// Decode and see error.\n+\terr = NewDecoder(buf).Decode(&slice)\n+\tif err == nil {\n+\t\tt.Fatal(\"decode: no error\")\n+\t}\n+\tif !strings.Contains(err.Error(), \"slice too big\") {\n+\t\tt.Fatal(\"decode: expected slice too big error, got %s\", err.Error())\n+\t}\n+}"}, {"sha": "eb76b481d198365e1552dd3b76ef76fa5bebacc0", "filename": "libgo/go/encoding/gob/gobencdec_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -279,7 +279,7 @@ func TestGobEncoderValueField(t *testing.T) {\n \tb := new(bytes.Buffer)\n \t// First a field that's a structure.\n \tenc := NewEncoder(b)\n-\terr := enc.Encode(GobTestValueEncDec{17, StringStruct{\"HIJKL\"}})\n+\terr := enc.Encode(&GobTestValueEncDec{17, StringStruct{\"HIJKL\"}})\n \tif err != nil {\n \t\tt.Fatal(\"encode error:\", err)\n \t}\n@@ -326,7 +326,7 @@ func TestGobEncoderArrayField(t *testing.T) {\n \tfor i := range a.A.a {\n \t\ta.A.a[i] = byte(i)\n \t}\n-\terr := enc.Encode(a)\n+\terr := enc.Encode(&a)\n \tif err != nil {\n \t\tt.Fatal(\"encode error:\", err)\n \t}\n@@ -589,7 +589,8 @@ func TestGobEncoderStructSingleton(t *testing.T) {\n func TestGobEncoderNonStructSingleton(t *testing.T) {\n \tb := new(bytes.Buffer)\n \tenc := NewEncoder(b)\n-\terr := enc.Encode(Gobber(1234))\n+\tvar g Gobber = 1234\n+\terr := enc.Encode(&g)\n \tif err != nil {\n \t\tt.Fatal(\"encode error:\", err)\n \t}"}, {"sha": "940e5ad4126a7f025de32624d62eede74759548b", "filename": "libgo/go/encoding/gob/timing_test.go", "status": "modified", "additions": 237, "deletions": 21, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -19,33 +19,57 @@ type Bench struct {\n \tD []byte\n }\n \n-func benchmarkEndToEnd(r io.Reader, w io.Writer, b *testing.B) {\n-\tb.StopTimer()\n-\tenc := NewEncoder(w)\n-\tdec := NewDecoder(r)\n-\tbench := &Bench{7, 3.2, \"now is the time\", []byte(\"for all good men\")}\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tif enc.Encode(bench) != nil {\n-\t\t\tpanic(\"encode error\")\n+func benchmarkEndToEnd(b *testing.B, ctor func() interface{}, pipe func() (r io.Reader, w io.Writer, err error)) {\n+\tb.RunParallel(func(pb *testing.PB) {\n+\t\tr, w, err := pipe()\n+\t\tif err != nil {\n+\t\t\tb.Fatal(\"can't get pipe:\", err)\n \t\t}\n-\t\tif dec.Decode(bench) != nil {\n-\t\t\tpanic(\"decode error\")\n+\t\tv := ctor()\n+\t\tenc := NewEncoder(w)\n+\t\tdec := NewDecoder(r)\n+\t\tfor pb.Next() {\n+\t\t\tif err := enc.Encode(v); err != nil {\n+\t\t\t\tb.Fatal(\"encode error:\", err)\n+\t\t\t}\n+\t\t\tif err := dec.Decode(v); err != nil {\n+\t\t\t\tb.Fatal(\"decode error:\", err)\n+\t\t\t}\n \t\t}\n-\t}\n+\t})\n }\n \n func BenchmarkEndToEndPipe(b *testing.B) {\n-\tr, w, err := os.Pipe()\n-\tif err != nil {\n-\t\tb.Fatal(\"can't get pipe:\", err)\n-\t}\n-\tbenchmarkEndToEnd(r, w, b)\n+\tbenchmarkEndToEnd(b, func() interface{} {\n+\t\treturn &Bench{7, 3.2, \"now is the time\", bytes.Repeat([]byte(\"for all good men\"), 100)}\n+\t}, func() (r io.Reader, w io.Writer, err error) {\n+\t\tr, w, err = os.Pipe()\n+\t\treturn\n+\t})\n }\n \n func BenchmarkEndToEndByteBuffer(b *testing.B) {\n-\tvar buf bytes.Buffer\n-\tbenchmarkEndToEnd(&buf, &buf, b)\n+\tbenchmarkEndToEnd(b, func() interface{} {\n+\t\treturn &Bench{7, 3.2, \"now is the time\", bytes.Repeat([]byte(\"for all good men\"), 100)}\n+\t}, func() (r io.Reader, w io.Writer, err error) {\n+\t\tvar buf bytes.Buffer\n+\t\treturn &buf, &buf, nil\n+\t})\n+}\n+\n+func BenchmarkEndToEndSliceByteBuffer(b *testing.B) {\n+\tbenchmarkEndToEnd(b, func() interface{} {\n+\t\tv := &Bench{7, 3.2, \"now is the time\", nil}\n+\t\tRegister(v)\n+\t\tarr := make([]interface{}, 100)\n+\t\tfor i := range arr {\n+\t\t\tarr[i] = v\n+\t\t}\n+\t\treturn &arr\n+\t}, func() (r io.Reader, w io.Writer, err error) {\n+\t\tvar buf bytes.Buffer\n+\t\treturn &buf, &buf, nil\n+\t})\n }\n \n func TestCountEncodeMallocs(t *testing.T) {\n@@ -103,7 +127,199 @@ func TestCountDecodeMallocs(t *testing.T) {\n \t\t\tt.Fatal(\"decode:\", err)\n \t\t}\n \t})\n-\tif allocs != 3 {\n-\t\tt.Fatalf(\"mallocs per decode of type Bench: %v; wanted 3\\n\", allocs)\n+\tif allocs != 4 {\n+\t\tt.Fatalf(\"mallocs per decode of type Bench: %v; wanted 4\\n\", allocs)\n+\t}\n+}\n+\n+func BenchmarkEncodeComplex128Slice(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\ta := make([]complex128, 1000)\n+\tfor i := range a {\n+\t\ta[i] = 1.2 + 3.4i\n+\t}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\terr := enc.Encode(a)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkEncodeFloat64Slice(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\ta := make([]float64, 1000)\n+\tfor i := range a {\n+\t\ta[i] = 1.23e4\n+\t}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\terr := enc.Encode(a)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkEncodeInt32Slice(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\ta := make([]int32, 1000)\n+\tfor i := range a {\n+\t\ta[i] = 1234\n+\t}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\terr := enc.Encode(a)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkEncodeStringSlice(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\ta := make([]string, 1000)\n+\tfor i := range a {\n+\t\ta[i] = \"now is the time\"\n+\t}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\terr := enc.Encode(a)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t}\n+}\n+\n+// benchmarkBuf is a read buffer we can reset\n+type benchmarkBuf struct {\n+\toffset int\n+\tdata   []byte\n+}\n+\n+func (b *benchmarkBuf) Read(p []byte) (n int, err error) {\n+\tn = copy(p, b.data[b.offset:])\n+\tif n == 0 {\n+\t\treturn 0, io.EOF\n+\t}\n+\tb.offset += n\n+\treturn\n+}\n+\n+func (b *benchmarkBuf) ReadByte() (c byte, err error) {\n+\tif b.offset >= len(b.data) {\n+\t\treturn 0, io.EOF\n+\t}\n+\tc = b.data[b.offset]\n+\tb.offset++\n+\treturn\n+}\n+\n+func (b *benchmarkBuf) reset() {\n+\tb.offset = 0\n+}\n+\n+func BenchmarkDecodeComplex128Slice(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\ta := make([]complex128, 1000)\n+\tfor i := range a {\n+\t\ta[i] = 1.2 + 3.4i\n+\t}\n+\terr := enc.Encode(a)\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tx := make([]complex128, 1000)\n+\tbbuf := benchmarkBuf{data: buf.Bytes()}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbbuf.reset()\n+\t\tdec := NewDecoder(&bbuf)\n+\t\terr := dec.Decode(&x)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(i, err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkDecodeFloat64Slice(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\ta := make([]float64, 1000)\n+\tfor i := range a {\n+\t\ta[i] = 1.23e4\n+\t}\n+\terr := enc.Encode(a)\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tx := make([]float64, 1000)\n+\tbbuf := benchmarkBuf{data: buf.Bytes()}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbbuf.reset()\n+\t\tdec := NewDecoder(&bbuf)\n+\t\terr := dec.Decode(&x)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(i, err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkDecodeInt32Slice(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\ta := make([]int32, 1000)\n+\tfor i := range a {\n+\t\ta[i] = 1234\n+\t}\n+\terr := enc.Encode(a)\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tx := make([]int32, 1000)\n+\tbbuf := benchmarkBuf{data: buf.Bytes()}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbbuf.reset()\n+\t\tdec := NewDecoder(&bbuf)\n+\t\terr := dec.Decode(&x)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(i, err)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkDecodeStringSlice(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\ta := make([]string, 1000)\n+\tfor i := range a {\n+\t\ta[i] = \"now is the time\"\n+\t}\n+\terr := enc.Encode(a)\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tx := make([]string, 1000)\n+\tbbuf := benchmarkBuf{data: buf.Bytes()}\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbbuf.reset()\n+\t\tdec := NewDecoder(&bbuf)\n+\t\terr := dec.Decode(&x)\n+\t\tif err != nil {\n+\t\t\tb.Fatal(i, err)\n+\t\t}\n \t}\n }"}, {"sha": "a49b71a8676786c67aa38dbae07c8ddbdbd86ec6", "filename": "libgo/go/encoding/gob/type.go", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"os\"\n \t\"reflect\"\n \t\"sync\"\n+\t\"sync/atomic\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n )\n@@ -681,29 +682,51 @@ func (w *wireType) string() string {\n \n type typeInfo struct {\n \tid      typeId\n-\tencoder *encEngine\n+\tencInit sync.Mutex   // protects creation of encoder\n+\tencoder atomic.Value // *encEngine\n \twire    *wireType\n }\n \n-var typeInfoMap = make(map[reflect.Type]*typeInfo) // protected by typeLock\n+// typeInfoMap is an atomic pointer to map[reflect.Type]*typeInfo.\n+// It's updated copy-on-write. Readers just do an atomic load\n+// to get the current version of the map. Writers make a full copy of\n+// the map and atomically update the pointer to point to the new map.\n+// Under heavy read contention, this is significantly faster than a map\n+// protected by a mutex.\n+var typeInfoMap atomic.Value\n+\n+func lookupTypeInfo(rt reflect.Type) *typeInfo {\n+\tm, _ := typeInfoMap.Load().(map[reflect.Type]*typeInfo)\n+\treturn m[rt]\n+}\n \n-// typeLock must be held.\n func getTypeInfo(ut *userTypeInfo) (*typeInfo, error) {\n \trt := ut.base\n \tif ut.externalEnc != 0 {\n \t\t// We want the user type, not the base type.\n \t\trt = ut.user\n \t}\n-\tinfo, ok := typeInfoMap[rt]\n-\tif ok {\n+\tif info := lookupTypeInfo(rt); info != nil {\n \t\treturn info, nil\n \t}\n-\tinfo = new(typeInfo)\n+\treturn buildTypeInfo(ut, rt)\n+}\n+\n+// buildTypeInfo constructs the type information for the type\n+// and stores it in the type info map.\n+func buildTypeInfo(ut *userTypeInfo, rt reflect.Type) (*typeInfo, error) {\n+\ttypeLock.Lock()\n+\tdefer typeLock.Unlock()\n+\n+\tif info := lookupTypeInfo(rt); info != nil {\n+\t\treturn info, nil\n+\t}\n+\n \tgt, err := getBaseType(rt.Name(), rt)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tinfo.id = gt.id()\n+\tinfo := &typeInfo{id: gt.id()}\n \n \tif ut.externalEnc != 0 {\n \t\tuserType, err := getType(rt.Name(), ut, rt)\n@@ -719,25 +742,32 @@ func getTypeInfo(ut *userTypeInfo) (*typeInfo, error) {\n \t\tcase xText:\n \t\t\tinfo.wire = &wireType{TextMarshalerT: gt}\n \t\t}\n-\t\ttypeInfoMap[ut.user] = info\n-\t\treturn info, nil\n+\t\trt = ut.user\n+\t} else {\n+\t\tt := info.id.gobType()\n+\t\tswitch typ := rt; typ.Kind() {\n+\t\tcase reflect.Array:\n+\t\t\tinfo.wire = &wireType{ArrayT: t.(*arrayType)}\n+\t\tcase reflect.Map:\n+\t\t\tinfo.wire = &wireType{MapT: t.(*mapType)}\n+\t\tcase reflect.Slice:\n+\t\t\t// []byte == []uint8 is a special case handled separately\n+\t\t\tif typ.Elem().Kind() != reflect.Uint8 {\n+\t\t\t\tinfo.wire = &wireType{SliceT: t.(*sliceType)}\n+\t\t\t}\n+\t\tcase reflect.Struct:\n+\t\t\tinfo.wire = &wireType{StructT: t.(*structType)}\n+\t\t}\n \t}\n \n-\tt := info.id.gobType()\n-\tswitch typ := rt; typ.Kind() {\n-\tcase reflect.Array:\n-\t\tinfo.wire = &wireType{ArrayT: t.(*arrayType)}\n-\tcase reflect.Map:\n-\t\tinfo.wire = &wireType{MapT: t.(*mapType)}\n-\tcase reflect.Slice:\n-\t\t// []byte == []uint8 is a special case handled separately\n-\t\tif typ.Elem().Kind() != reflect.Uint8 {\n-\t\t\tinfo.wire = &wireType{SliceT: t.(*sliceType)}\n-\t\t}\n-\tcase reflect.Struct:\n-\t\tinfo.wire = &wireType{StructT: t.(*structType)}\n+\t// Create new map with old contents plus new entry.\n+\tnewm := make(map[reflect.Type]*typeInfo)\n+\tm, _ := typeInfoMap.Load().(map[reflect.Type]*typeInfo)\n+\tfor k, v := range m {\n+\t\tnewm[k] = v\n \t}\n-\ttypeInfoMap[rt] = info\n+\tnewm[rt] = info\n+\ttypeInfoMap.Store(newm)\n \treturn info, nil\n }\n "}, {"sha": "705bc2e17a7e3455c588fca9a4d2556782830010", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -173,7 +173,6 @@ type decodeState struct {\n \tscan       scanner\n \tnextscan   scanner // for calls to nextValue\n \tsavedError error\n-\ttempstr    string // scratch space to avoid some allocations\n \tuseNumber  bool\n }\n \n@@ -293,6 +292,32 @@ func (d *decodeState) value(v reflect.Value) {\n \t}\n }\n \n+type unquotedValue struct{}\n+\n+// valueQuoted is like value but decodes a\n+// quoted string literal or literal null into an interface value.\n+// If it finds anything other than a quoted string literal or null,\n+// valueQuoted returns unquotedValue{}.\n+func (d *decodeState) valueQuoted() interface{} {\n+\tswitch op := d.scanWhile(scanSkipSpace); op {\n+\tdefault:\n+\t\td.error(errPhase)\n+\n+\tcase scanBeginArray:\n+\t\td.array(reflect.Value{})\n+\n+\tcase scanBeginObject:\n+\t\td.object(reflect.Value{})\n+\n+\tcase scanBeginLiteral:\n+\t\tswitch v := d.literalInterface().(type) {\n+\t\tcase nil, string:\n+\t\t\treturn v\n+\t\t}\n+\t}\n+\treturn unquotedValue{}\n+}\n+\n // indirect walks down v allocating pointers as needed,\n // until it gets to a non-pointer.\n // if it encounters an Unmarshaler, indirect stops and returns that.\n@@ -444,8 +469,10 @@ func (d *decodeState) array(v reflect.Value) {\n \t}\n }\n \n+var nullLiteral = []byte(\"null\")\n+\n // object consumes an object from d.data[d.off-1:], decoding into the value v.\n-// the first byte of the object ('{') has been read already.\n+// the first byte ('{') of the object has been read already.\n func (d *decodeState) object(v reflect.Value) {\n \t// Check for unmarshaler.\n \tu, ut, pv := d.indirect(v, false)\n@@ -478,7 +505,9 @@ func (d *decodeState) object(v reflect.Value) {\n \t\tt := v.Type()\n \t\tif t.Key().Kind() != reflect.String {\n \t\t\td.saveError(&UnmarshalTypeError{\"object\", v.Type()})\n-\t\t\tbreak\n+\t\t\td.off--\n+\t\t\td.next() // skip over { } in input\n+\t\t\treturn\n \t\t}\n \t\tif v.IsNil() {\n \t\t\tv.Set(reflect.MakeMap(t))\n@@ -564,9 +593,14 @@ func (d *decodeState) object(v reflect.Value) {\n \n \t\t// Read value.\n \t\tif destring {\n-\t\t\td.value(reflect.ValueOf(&d.tempstr))\n-\t\t\td.literalStore([]byte(d.tempstr), subv, true)\n-\t\t\td.tempstr = \"\" // Zero scratch space for successive values.\n+\t\t\tswitch qv := d.valueQuoted().(type) {\n+\t\t\tcase nil:\n+\t\t\t\td.literalStore(nullLiteral, subv, false)\n+\t\t\tcase string:\n+\t\t\t\td.literalStore([]byte(qv), subv, true)\n+\t\t\tdefault:\n+\t\t\t\td.saveError(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal unquoted value into %v\", item, v.Type()))\n+\t\t\t}\n \t\t} else {\n \t\t\td.value(subv)\n \t\t}"}, {"sha": "7235969b9fef556964823bfd2ac7550d256daada", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -406,6 +406,13 @@ var unmarshalTests = []unmarshalTest{\n \t\tptr: new(string),\n \t\tout: \"hello\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd\\ufffdworld\",\n \t},\n+\n+\t// issue 8305\n+\t{\n+\t\tin:  `{\"2009-11-10T23:00:00Z\": \"hello world\"}`,\n+\t\tptr: &map[time.Time]string{},\n+\t\terr: &UnmarshalTypeError{\"object\", reflect.TypeOf(map[time.Time]string{})},\n+\t},\n }\n \n func TestMarshal(t *testing.T) {\n@@ -514,14 +521,17 @@ func TestUnmarshal(t *testing.T) {\n \t\tif tt.ptr == nil {\n \t\t\tcontinue\n \t\t}\n+\n \t\t// v = new(right-type)\n \t\tv := reflect.New(reflect.TypeOf(tt.ptr).Elem())\n \t\tdec := NewDecoder(bytes.NewReader(in))\n \t\tif tt.useNumber {\n \t\t\tdec.UseNumber()\n \t\t}\n \t\tif err := dec.Decode(v.Interface()); !reflect.DeepEqual(err, tt.err) {\n-\t\t\tt.Errorf(\"#%d: %v want %v\", i, err, tt.err)\n+\t\t\tt.Errorf(\"#%d: %v, want %v\", i, err, tt.err)\n+\t\t\tcontinue\n+\t\t} else if err != nil {\n \t\t\tcontinue\n \t\t}\n \t\tif !reflect.DeepEqual(v.Elem().Interface(), tt.out) {\n@@ -1060,18 +1070,25 @@ func TestEmptyString(t *testing.T) {\n \t}\n }\n \n-// Test that the returned error is non-nil when trying to unmarshal null string into int, for successive ,string option\n-// Issue 7046\n+// Test that a null for ,string is not replaced with the previous quoted string (issue 7046).\n+// It should also not be an error (issue 2540, issue 8587).\n func TestNullString(t *testing.T) {\n \ttype T struct {\n-\t\tA int `json:\",string\"`\n-\t\tB int `json:\",string\"`\n+\t\tA int  `json:\",string\"`\n+\t\tB int  `json:\",string\"`\n+\t\tC *int `json:\",string\"`\n \t}\n-\tdata := []byte(`{\"A\": \"1\", \"B\": null}`)\n+\tdata := []byte(`{\"A\": \"1\", \"B\": null, \"C\": null}`)\n \tvar s T\n+\ts.B = 1\n+\ts.C = new(int)\n+\t*s.C = 2\n \terr := Unmarshal(data, &s)\n-\tif err == nil {\n-\t\tt.Fatalf(\"expected error; got %v\", s)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unmarshal: %v\")\n+\t}\n+\tif s.B != 1 || s.C != nil {\n+\t\tt.Fatalf(\"after Unmarshal, s.B=%d, s.C=%p, want 1, nil\", s.B, s.C)\n \t}\n }\n "}, {"sha": "fca2a0980b2a36a30e8d80f79e1261088acea4c8", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -40,8 +40,8 @@ import (\n //\n // Floating point, integer, and Number values encode as JSON numbers.\n //\n-// String values encode as JSON strings. InvalidUTF8Error will be returned\n-// if an invalid UTF-8 sequence is encountered.\n+// String values encode as JSON strings coerced to valid UTF-8,\n+// replacing invalid bytes with the Unicode replacement rune.\n // The angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\n // to keep some browsers from misinterpreting JSON output as HTML.\n // Ampersand \"&\" is also escaped to \"\\u0026\" for the same reason.\n@@ -93,6 +93,8 @@ import (\n // as described in the next paragraph.\n // An anonymous struct field with a name given in its JSON tag is treated as\n // having that name, rather than being anonymous.\n+// An anonymous struct field of interface type is treated the same as having\n+// that type as its name, rather than being anonymous.\n //\n // The Go visibility rules for struct fields are amended for JSON when\n // deciding which field to marshal or unmarshal. If there are\n@@ -696,12 +698,12 @@ type ptrEncoder struct {\n \telemEnc encoderFunc\n }\n \n-func (pe *ptrEncoder) encode(e *encodeState, v reflect.Value, _ bool) {\n+func (pe *ptrEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {\n \tif v.IsNil() {\n \t\te.WriteString(\"null\")\n \t\treturn\n \t}\n-\tpe.elemEnc(e, v.Elem(), false)\n+\tpe.elemEnc(e, v.Elem(), quoted)\n }\n \n func newPtrEncoder(t reflect.Type) encoderFunc {\n@@ -803,6 +805,9 @@ func (e *encodeState) string(s string) (int, error) {\n \t\t\tcase '\\r':\n \t\t\t\te.WriteByte('\\\\')\n \t\t\t\te.WriteByte('r')\n+\t\t\tcase '\\t':\n+\t\t\t\te.WriteByte('\\\\')\n+\t\t\t\te.WriteByte('t')\n \t\t\tdefault:\n \t\t\t\t// This encodes bytes < 0x20 except for \\n and \\r,\n \t\t\t\t// as well as <, > and &. The latter are escaped because they\n@@ -876,9 +881,12 @@ func (e *encodeState) stringBytes(s []byte) (int, error) {\n \t\t\tcase '\\r':\n \t\t\t\te.WriteByte('\\\\')\n \t\t\t\te.WriteByte('r')\n+\t\t\tcase '\\t':\n+\t\t\t\te.WriteByte('\\\\')\n+\t\t\t\te.WriteByte('t')\n \t\t\tdefault:\n \t\t\t\t// This encodes bytes < 0x20 except for \\n and \\r,\n-\t\t\t\t// as well as < and >. The latter are escaped because they\n+\t\t\t\t// as well as <, >, and &. The latter are escaped because they\n \t\t\t\t// can lead to security holes when user-controlled strings\n \t\t\t\t// are rendered into JSON and served to some browsers.\n \t\t\t\te.WriteString(`\\u00`)"}, {"sha": "7abfa85db7bc243c6c057a476297dce62cc9c5f7", "filename": "libgo/go/encoding/json/encode_test.go", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -452,3 +452,81 @@ func TestHTMLEscape(t *testing.T) {\n \t\tt.Errorf(\"HTMLEscape(&b, []byte(m)) = %s; want %s\", b.Bytes(), want.Bytes())\n \t}\n }\n+\n+// golang.org/issue/8582\n+func TestEncodePointerString(t *testing.T) {\n+\ttype stringPointer struct {\n+\t\tN *int64 `json:\"n,string\"`\n+\t}\n+\tvar n int64 = 42\n+\tb, err := Marshal(stringPointer{N: &n})\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal: %v\", err)\n+\t}\n+\tif got, want := string(b), `{\"n\":\"42\"}`; got != want {\n+\t\tt.Errorf(\"Marshal = %s, want %s\", got, want)\n+\t}\n+\tvar back stringPointer\n+\terr = Unmarshal(b, &back)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unmarshal: %v\", err)\n+\t}\n+\tif back.N == nil {\n+\t\tt.Fatalf(\"Unmarshalled nil N field\")\n+\t}\n+\tif *back.N != 42 {\n+\t\tt.Fatalf(\"*N = %d; want 42\", *back.N)\n+\t}\n+}\n+\n+var encodeStringTests = []struct {\n+\tin  string\n+\tout string\n+}{\n+\t{\"\\x00\", `\"\\u0000\"`},\n+\t{\"\\x01\", `\"\\u0001\"`},\n+\t{\"\\x02\", `\"\\u0002\"`},\n+\t{\"\\x03\", `\"\\u0003\"`},\n+\t{\"\\x04\", `\"\\u0004\"`},\n+\t{\"\\x05\", `\"\\u0005\"`},\n+\t{\"\\x06\", `\"\\u0006\"`},\n+\t{\"\\x07\", `\"\\u0007\"`},\n+\t{\"\\x08\", `\"\\u0008\"`},\n+\t{\"\\x09\", `\"\\t\"`},\n+\t{\"\\x0a\", `\"\\n\"`},\n+\t{\"\\x0b\", `\"\\u000b\"`},\n+\t{\"\\x0c\", `\"\\u000c\"`},\n+\t{\"\\x0d\", `\"\\r\"`},\n+\t{\"\\x0e\", `\"\\u000e\"`},\n+\t{\"\\x0f\", `\"\\u000f\"`},\n+\t{\"\\x10\", `\"\\u0010\"`},\n+\t{\"\\x11\", `\"\\u0011\"`},\n+\t{\"\\x12\", `\"\\u0012\"`},\n+\t{\"\\x13\", `\"\\u0013\"`},\n+\t{\"\\x14\", `\"\\u0014\"`},\n+\t{\"\\x15\", `\"\\u0015\"`},\n+\t{\"\\x16\", `\"\\u0016\"`},\n+\t{\"\\x17\", `\"\\u0017\"`},\n+\t{\"\\x18\", `\"\\u0018\"`},\n+\t{\"\\x19\", `\"\\u0019\"`},\n+\t{\"\\x1a\", `\"\\u001a\"`},\n+\t{\"\\x1b\", `\"\\u001b\"`},\n+\t{\"\\x1c\", `\"\\u001c\"`},\n+\t{\"\\x1d\", `\"\\u001d\"`},\n+\t{\"\\x1e\", `\"\\u001e\"`},\n+\t{\"\\x1f\", `\"\\u001f\"`},\n+}\n+\n+func TestEncodeString(t *testing.T) {\n+\tfor _, tt := range encodeStringTests {\n+\t\tb, err := Marshal(tt.in)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Marshal(%q): %v\", tt.in, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tout := string(b)\n+\t\tif out != tt.out {\n+\t\t\tt.Errorf(\"Marshal(%q) = %#q, want %#q\", tt.in, out, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "9566ecadcbb12df7b54dd5837c8a1c6469ea7bbb", "filename": "libgo/go/encoding/json/stream.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -139,7 +139,6 @@ func nonSpace(b []byte) bool {\n // An Encoder writes JSON objects to an output stream.\n type Encoder struct {\n \tw   io.Writer\n-\te   encodeState\n \terr error\n }\n "}, {"sha": "8c15b98c3a9efacf82f7e9de32f4770a913c5cc4", "filename": "libgo/go/encoding/xml/xml.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -196,6 +196,7 @@ type Decoder struct {\n \tns             map[string]string\n \terr            error\n \tline           int\n+\toffset         int64\n \tunmarshalDepth int\n }\n \n@@ -859,9 +860,17 @@ func (d *Decoder) getc() (b byte, ok bool) {\n \tif b == '\\n' {\n \t\td.line++\n \t}\n+\td.offset++\n \treturn b, true\n }\n \n+// InputOffset returns the input stream byte offset of the current decoder position.\n+// The offset gives the location of the end of the most recently returned token\n+// and the beginning of the next token.\n+func (d *Decoder) InputOffset() int64 {\n+\treturn d.offset\n+}\n+\n // Return saved offset.\n // If we did ungetc (nextByte >= 0), have to back up one.\n func (d *Decoder) savedOffset() int {\n@@ -891,6 +900,7 @@ func (d *Decoder) ungetc(b byte) {\n \t\td.line--\n \t}\n \td.nextByte = int(b)\n+\td.offset--\n }\n \n var entity = map[string]int{"}, {"sha": "be995c0d52c035fbc8c6f93a7a7a66b8127c79be", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -170,7 +170,7 @@ var xmlInput = []string{\n func TestRawToken(t *testing.T) {\n \td := NewDecoder(strings.NewReader(testInput))\n \td.Entity = testEntity\n-\ttestRawToken(t, d, rawTokens)\n+\ttestRawToken(t, d, testInput, rawTokens)\n }\n \n const nonStrictInput = `\n@@ -225,7 +225,7 @@ var nonStrictTokens = []Token{\n func TestNonStrictRawToken(t *testing.T) {\n \td := NewDecoder(strings.NewReader(nonStrictInput))\n \td.Strict = false\n-\ttestRawToken(t, d, nonStrictTokens)\n+\ttestRawToken(t, d, nonStrictInput, nonStrictTokens)\n }\n \n type downCaser struct {\n@@ -254,7 +254,7 @@ func TestRawTokenAltEncoding(t *testing.T) {\n \t\t}\n \t\treturn &downCaser{t, input.(io.ByteReader)}, nil\n \t}\n-\ttestRawToken(t, d, rawTokensAltEncoding)\n+\ttestRawToken(t, d, testInputAltEncoding, rawTokensAltEncoding)\n }\n \n func TestRawTokenAltEncodingNoConverter(t *testing.T) {\n@@ -280,9 +280,12 @@ func TestRawTokenAltEncodingNoConverter(t *testing.T) {\n \t}\n }\n \n-func testRawToken(t *testing.T, d *Decoder, rawTokens []Token) {\n+func testRawToken(t *testing.T, d *Decoder, raw string, rawTokens []Token) {\n+\tlastEnd := int64(0)\n \tfor i, want := range rawTokens {\n+\t\tstart := d.InputOffset()\n \t\thave, err := d.RawToken()\n+\t\tend := d.InputOffset()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"token %d: unexpected error: %s\", i, err)\n \t\t}\n@@ -300,6 +303,26 @@ func testRawToken(t *testing.T, d *Decoder, rawTokens []Token) {\n \t\t\t}\n \t\t\tt.Errorf(\"token %d = %s, want %s\", i, shave, swant)\n \t\t}\n+\n+\t\t// Check that InputOffset returned actual token.\n+\t\tswitch {\n+\t\tcase start < lastEnd:\n+\t\t\tt.Errorf(\"token %d: position [%d,%d) for %T is before previous token\", i, start, end, have)\n+\t\tcase start >= end:\n+\t\t\t// Special case: EndElement can be synthesized.\n+\t\t\tif start == end && end == lastEnd {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tt.Errorf(\"token %d: position [%d,%d) for %T is empty\", i, start, end, have)\n+\t\tcase end > int64(len(raw)):\n+\t\t\tt.Errorf(\"token %d: position [%d,%d) for %T extends beyond input\", i, start, end, have)\n+\t\tdefault:\n+\t\t\ttext := raw[start:end]\n+\t\t\tif strings.ContainsAny(text, \"<>\") && (!strings.HasPrefix(text, \"<\") || !strings.HasSuffix(text, \">\")) {\n+\t\t\t\tt.Errorf(\"token %d: misaligned raw token %#q for %T\", i, text, have)\n+\t\t\t}\n+\t\t}\n+\t\tlastEnd = end\n \t}\n }\n "}, {"sha": "60aef5d806c748d6d1f22b5d006781f24a859967", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -73,7 +73,8 @@ import (\n \t\"time\"\n )\n \n-// ErrHelp is the error returned if the flag -help is invoked but no such flag is defined.\n+// ErrHelp is the error returned if the -help or -h flag is invoked\n+// but no such flag is defined.\n var ErrHelp = errors.New(\"flag: help requested\")\n \n // -- bool Value\n@@ -405,6 +406,7 @@ func defaultUsage(f *FlagSet) {\n // for how to write your own usage function.\n \n // Usage prints to standard error a usage message documenting all defined command-line flags.\n+// It is called when an error occurs while parsing flags.\n // The function is a variable that may be changed to point to a custom function.\n var Usage = func() {\n \tfmt.Fprintf(os.Stderr, \"Usage of %s:\\n\", os.Args[0])\n@@ -628,18 +630,21 @@ func Float64(name string, value float64, usage string) *float64 {\n \n // DurationVar defines a time.Duration flag with specified name, default value, and usage string.\n // The argument p points to a time.Duration variable in which to store the value of the flag.\n+// The flag accepts a value acceptable to time.ParseDuration.\n func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string) {\n \tf.Var(newDurationValue(value, p), name, usage)\n }\n \n // DurationVar defines a time.Duration flag with specified name, default value, and usage string.\n // The argument p points to a time.Duration variable in which to store the value of the flag.\n+// The flag accepts a value acceptable to time.ParseDuration.\n func DurationVar(p *time.Duration, name string, value time.Duration, usage string) {\n \tCommandLine.Var(newDurationValue(value, p), name, usage)\n }\n \n // Duration defines a time.Duration flag with specified name, default value, and usage string.\n // The return value is the address of a time.Duration variable that stores the value of the flag.\n+// The flag accepts a value acceptable to time.ParseDuration.\n func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration {\n \tp := new(time.Duration)\n \tf.DurationVar(p, name, value, usage)\n@@ -648,6 +653,7 @@ func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time\n \n // Duration defines a time.Duration flag with specified name, default value, and usage string.\n // The return value is the address of a time.Duration variable that stores the value of the flag.\n+// The flag accepts a value acceptable to time.ParseDuration.\n func Duration(name string, value time.Duration, usage string) *time.Duration {\n \treturn CommandLine.Duration(name, value, usage)\n }\n@@ -697,13 +703,15 @@ func (f *FlagSet) failf(format string, a ...interface{}) error {\n \treturn err\n }\n \n-// usage calls the Usage method for the flag set, or the usage function if\n-// the flag set is CommandLine.\n+// usage calls the Usage method for the flag set if one is specified,\n+// or the appropriate default usage function otherwise.\n func (f *FlagSet) usage() {\n-\tif f == CommandLine {\n-\t\tUsage()\n-\t} else if f.Usage == nil {\n-\t\tdefaultUsage(f)\n+\tif f.Usage == nil {\n+\t\tif f == CommandLine {\n+\t\t\tUsage()\n+\t\t} else {\n+\t\t\tdefaultUsage(f)\n+\t\t}\n \t} else {\n \t\tf.Usage()\n \t}\n@@ -752,6 +760,7 @@ func (f *FlagSet) parseOne() (bool, error) {\n \t\t}\n \t\treturn false, f.failf(\"flag provided but not defined: -%s\", name)\n \t}\n+\n \tif fv, ok := flag.Value.(boolFlag); ok && fv.IsBoolFlag() { // special case: doesn't need an arg\n \t\tif has_value {\n \t\t\tif err := fv.Set(value); err != nil {\n@@ -784,7 +793,7 @@ func (f *FlagSet) parseOne() (bool, error) {\n // Parse parses flag definitions from the argument list, which should not\n // include the command name.  Must be called after all flags in the FlagSet\n // are defined and before flags are accessed by the program.\n-// The return value will be ErrHelp if -help was set but not defined.\n+// The return value will be ErrHelp if -help or -h were set but not defined.\n func (f *FlagSet) Parse(arguments []string) error {\n \tf.parsed = true\n \tf.args = arguments\n@@ -826,7 +835,7 @@ func Parsed() bool {\n }\n \n // CommandLine is the default set of command-line flags, parsed from os.Args.\n-// The top-level functions such as BoolVar, Arg, and on are wrappers for the\n+// The top-level functions such as BoolVar, Arg, and so on are wrappers for the\n // methods of CommandLine.\n var CommandLine = NewFlagSet(os.Args[0], ExitOnError)\n "}, {"sha": "8c88c8c2744371ff7e3a4e87f0ee7c7bb5e91010", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -251,6 +251,16 @@ func TestUserDefined(t *testing.T) {\n \t}\n }\n \n+func TestUserDefinedForCommandLine(t *testing.T) {\n+\tconst help = \"HELP\"\n+\tvar result string\n+\tResetForTesting(func() { result = help })\n+\tUsage()\n+\tif result != help {\n+\t\tt.Fatalf(\"got %q; expected %q\", result, help)\n+\t}\n+}\n+\n // Declare a user-defined boolean flag type.\n type boolFlagVar struct {\n \tcount int"}, {"sha": "ee54463e275bd43d6f7542e8455b6f5eed29f2c4", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -13,7 +13,7 @@\n \tThe verbs:\n \n \tGeneral:\n-\t\t%v\tthe value in a default format.\n+\t\t%v\tthe value in a default format\n \t\t\twhen printing structs, the plus flag (%+v) adds field names\n \t\t%#v\ta Go-syntax representation of the value\n \t\t%T\ta Go-syntax representation of the type of the value\n@@ -38,8 +38,8 @@\n \t\t%E\tscientific notation, e.g. -1234.456E+78\n \t\t%f\tdecimal point but no exponent, e.g. 123.456\n \t\t%F\tsynonym for %f\n-\t\t%g\twhichever of %e or %f produces more compact output\n-\t\t%G\twhichever of %E or %f produces more compact output\n+\t\t%g\t%e for large exponents, %f otherwise\n+\t\t%G\t%E for large exponents, %F otherwise\n \tString and slice of bytes:\n \t\t%s\tthe uninterpreted bytes of the string or slice\n \t\t%q\ta double-quoted string safely escaped with Go syntax\n@@ -51,6 +51,21 @@\n \tThere is no 'u' flag.  Integers are printed unsigned if they have unsigned type.\n \tSimilarly, there is no need to specify the size of the operand (int8, int64).\n \n+\tThe default format for %v is:\n+\t\tbool:                    %t\n+\t\tint, int8 etc.:          %d\n+\t\tuint, uint8 etc.:        %d, %x if printed with %#v\n+\t\tfloat32, complex64, etc: %g\n+\t\tstring:                  %s\n+\t\tchan:                    %p\n+\t\tpointer:                 %p\n+\tFor compound objects, the elements are printed using these rules, recursively,\n+\tlaid out like this:\n+\t\tstruct:             {field0 field1 ...}\n+\t\tarray, slice:       [elem0  elem1 ...]\n+\t\tmaps:               map[key1:value1 key2:value2]\n+\t\tpointer to above:   &{}, &[], &map[]\n+\n \tWidth is specified by an optional decimal number immediately following the verb.\n \tIf absent, the width is whatever is necessary to represent the value.\n \tPrecision is specified after the (optional) width by a period followed by a\n@@ -63,16 +78,20 @@\n \t\t%9.2f  width 9, precision 2\n \t\t%9.f   width 9, precision 0\n \n-\tWidth and precision are measured in units of Unicode code points.\n-\t(This differs from C's printf where the units are numbers\n-\tof bytes.) Either or both of the flags may be replaced with the\n-\tcharacter '*', causing their values to be obtained from the next\n-\toperand, which must be of type int.\n+\tWidth and precision are measured in units of Unicode code points,\n+\tthat is, runes. (This differs from C's printf where the\n+\tunits are always measured in bytes.) Either or both of the flags\n+\tmay be replaced with the character '*', causing their values to be\n+\tobtained from the next operand, which must be of type int.\n \n-\tFor most values, width is the minimum number of characters to output,\n+\tFor most values, width is the minimum number of runes to output,\n \tpadding the formatted form with spaces if necessary.\n-\tFor strings, precision is the maximum number of characters to output,\n-\ttruncating if necessary.\n+\n+\tFor strings, byte slices and byte arrays, however, precision\n+\tlimits the length of the input to be formatted (not the size of\n+\tthe output), truncating if necessary. Normally it is measured in\n+\trunes, but for these types when formatted with the %x or %X format\n+\tit is measured in bytes.\n \n \tFor floating-point values, width sets the minimum width of the field and\n \tprecision sets the number of places after the decimal, if appropriate,\n@@ -147,6 +166,10 @@\n \t\tfunc (x X) String() string { return Sprintf(\"<%s>\", x) }\n \tconvert the value before recurring:\n \t\tfunc (x X) String() string { return Sprintf(\"<%s>\", string(x)) }\n+\tInfinite recursion can also be triggered by self-referential data\n+\tstructures, such as a slice that contains itself as an element, if\n+\tthat type has a String method. Such pathologies are rare, however,\n+\tand the package does not protect against them.\n \n \tExplicit argument indexes:\n \n@@ -160,7 +183,7 @@\n \n \tFor example,\n \t\tfmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)\n-\twill yield \"22, 11\", while\n+\twill yield \"22 11\", while\n \t\tfmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6),\n \tequivalent to\n \t\tfmt.Sprintf(\"%6.2f\", 12.0),"}, {"sha": "ccd80904771fe07c71e91ca08d7345b13b90b723", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 180, "deletions": 17, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -108,6 +108,20 @@ func (p *P) String() string {\n var barray = [5]renamedUint8{1, 2, 3, 4, 5}\n var bslice = barray[:]\n \n+type byteStringer byte\n+\n+func (byteStringer) String() string { return \"X\" }\n+\n+var byteStringerSlice = []byteStringer{97, 98, 99, 100}\n+\n+type byteFormatter byte\n+\n+func (byteFormatter) Format(f State, _ rune) {\n+\tFprint(f, \"X\")\n+}\n+\n+var byteFormatterSlice = []byteFormatter{97, 98, 99, 100}\n+\n var b byte\n \n var fmtTests = []struct {\n@@ -125,13 +139,17 @@ var fmtTests = []struct {\n \t{\"%x\", \"xyz\", \"78797a\"},\n \t{\"%X\", \"xyz\", \"78797A\"},\n \t{\"%q\", \"abc\", `\"abc\"`},\n+\t{\"%#x\", []byte(\"abc\\xff\"), \"0x616263ff\"},\n+\t{\"%#X\", []byte(\"abc\\xff\"), \"0X616263FF\"},\n+\t{\"%# x\", []byte(\"abc\\xff\"), \"0x61 0x62 0x63 0xff\"},\n+\t{\"%# X\", []byte(\"abc\\xff\"), \"0X61 0X62 0X63 0XFF\"},\n \n \t// basic bytes\n \t{\"%s\", []byte(\"abc\"), \"abc\"},\n \t{\"%x\", []byte(\"abc\"), \"616263\"},\n \t{\"% x\", []byte(\"abc\\xff\"), \"61 62 63 ff\"},\n-\t{\"%#x\", []byte(\"abc\\xff\"), \"0x610x620x630xff\"},\n-\t{\"%#X\", []byte(\"abc\\xff\"), \"0X610X620X630XFF\"},\n+\t{\"%#x\", []byte(\"abc\\xff\"), \"0x616263ff\"},\n+\t{\"%#X\", []byte(\"abc\\xff\"), \"0X616263FF\"},\n \t{\"%# x\", []byte(\"abc\\xff\"), \"0x61 0x62 0x63 0xff\"},\n \t{\"%# X\", []byte(\"abc\\xff\"), \"0X61 0X62 0X63 0XFF\"},\n \t{\"% X\", []byte(\"abc\\xff\"), \"61 62 63 FF\"},\n@@ -176,9 +194,18 @@ var fmtTests = []struct {\n \t{\"%.5s\", \"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\", \"\u65e5\u672c\u8a9e\u65e5\u672c\"},\n \t{\"%.5s\", []byte(\"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\"), \"\u65e5\u672c\u8a9e\u65e5\u672c\"},\n \t{\"%.5q\", \"abcdefghijklmnopqrstuvwxyz\", `\"abcde\"`},\n+\t{\"%.5x\", \"abcdefghijklmnopqrstuvwxyz\", `6162636465`},\n+\t{\"%.5q\", []byte(\"abcdefghijklmnopqrstuvwxyz\"), `\"abcde\"`},\n+\t{\"%.5x\", []byte(\"abcdefghijklmnopqrstuvwxyz\"), `6162636465`},\n \t{\"%.3q\", \"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\", `\"\u65e5\u672c\u8a9e\"`},\n \t{\"%.3q\", []byte(\"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\"), `\"\u65e5\u672c\u8a9e\"`},\n+\t{\"%.1q\", \"\u65e5\u672c\u8a9e\", `\"\u65e5\"`},\n+\t{\"%.1q\", []byte(\"\u65e5\u672c\u8a9e\"), `\"\u65e5\"`},\n+\t{\"%.1x\", \"\u65e5\u672c\u8a9e\", `e6`},\n+\t{\"%.1X\", []byte(\"\u65e5\u672c\u8a9e\"), `E6`},\n \t{\"%10.1q\", \"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\", `       \"\u65e5\"`},\n+\t{\"%3c\", '\u2318', \"  \u2318\"},\n+\t{\"%5q\", '\\u2026', `  '\u2026'`},\n \t{\"%10v\", nil, \"     <nil>\"},\n \t{\"%-10v\", nil, \"<nil>     \"},\n \n@@ -379,7 +406,7 @@ var fmtTests = []struct {\n \t{\"%s\", I(23), `<23>`},\n \t{\"%q\", I(23), `\"<23>\"`},\n \t{\"%x\", I(23), `3c32333e`},\n-\t{\"%#x\", I(23), `0x3c0x320x330x3e`},\n+\t{\"%#x\", I(23), `0x3c32333e`},\n \t{\"%# x\", I(23), `0x3c 0x32 0x33 0x3e`},\n \t{\"%d\", I(23), `23`}, // Stringer applies only to string formats.\n \n@@ -623,6 +650,21 @@ var fmtTests = []struct {\n \t{\"%+010.2f\", -104.66 + 440.51i, \"(-000104.66+000440.51i)\"},\n \t{\"%+010.2f\", +104.66 - 440.51i, \"(+000104.66-000440.51i)\"},\n \t{\"%+010.2f\", -104.66 - 440.51i, \"(-000104.66-000440.51i)\"},\n+\n+\t// []T where type T is a byte with a Stringer method.\n+\t{\"%v\", byteStringerSlice, \"[X X X X]\"},\n+\t{\"%s\", byteStringerSlice, \"abcd\"},\n+\t{\"%q\", byteStringerSlice, \"\\\"abcd\\\"\"},\n+\t{\"%x\", byteStringerSlice, \"61626364\"},\n+\t{\"%#v\", byteStringerSlice, \"[]fmt_test.byteStringer{0x61, 0x62, 0x63, 0x64}\"},\n+\n+\t// And the same for Formatter.\n+\t{\"%v\", byteFormatterSlice, \"[X X X X]\"},\n+\t{\"%s\", byteFormatterSlice, \"abcd\"},\n+\t{\"%q\", byteFormatterSlice, \"\\\"abcd\\\"\"},\n+\t{\"%x\", byteFormatterSlice, \"61626364\"},\n+\t// This next case seems wrong, but the docs say the Formatter wins here.\n+\t{\"%#v\", byteFormatterSlice, \"[]fmt_test.byteFormatter{X, X, X, X}\"},\n }\n \n // zeroFill generates zero-filled strings of the specified width. The length\n@@ -672,7 +714,7 @@ func TestSprintf(t *testing.T) {\n // thing as if done by hand with two singleton prints.\n func TestComplexFormatting(t *testing.T) {\n \tvar yesNo = []bool{true, false}\n-\tvar signs = []float64{1, 0, -1}\n+\tvar values = []float64{1, 0, -1, math.Inf(1), math.Inf(-1), math.NaN()}\n \tfor _, plus := range yesNo {\n \t\tfor _, zero := range yesNo {\n \t\t\tfor _, space := range yesNo {\n@@ -697,10 +739,10 @@ func TestComplexFormatting(t *testing.T) {\n \t\t\t\t\timagFmt += \"+\"\n \t\t\t\t\timagFmt += \"10.2\"\n \t\t\t\t\timagFmt += string(char)\n-\t\t\t\t\tfor _, realSign := range signs {\n-\t\t\t\t\t\tfor _, imagSign := range signs {\n-\t\t\t\t\t\t\tone := Sprintf(realFmt, complex(realSign, imagSign))\n-\t\t\t\t\t\t\ttwo := Sprintf(\"(\"+realFmt+imagFmt+\"i)\", realSign, imagSign)\n+\t\t\t\t\tfor _, realValue := range values {\n+\t\t\t\t\t\tfor _, imagValue := range values {\n+\t\t\t\t\t\t\tone := Sprintf(realFmt, complex(realValue, imagValue))\n+\t\t\t\t\t\t\ttwo := Sprintf(\"(\"+realFmt+imagFmt+\"i)\", realValue, imagValue)\n \t\t\t\t\t\t\tif one != two {\n \t\t\t\t\t\t\t\tt.Error(f, one, two)\n \t\t\t\t\t\t\t}\n@@ -819,7 +861,25 @@ func BenchmarkManyArgs(b *testing.B) {\n \t})\n }\n \n+func BenchmarkFprintInt(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\tFprint(&buf, 123456)\n+\t}\n+}\n+\n+func BenchmarkFprintIntNoAlloc(b *testing.B) {\n+\tvar x interface{} = 123456\n+\tvar buf bytes.Buffer\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\tFprint(&buf, x)\n+\t}\n+}\n+\n var mallocBuf bytes.Buffer\n+var mallocPointer *int // A pointer so we know the interface value won't allocate.\n \n // gccgo numbers are different because gccgo does not have escape\n // analysis yet.\n@@ -833,11 +893,13 @@ var mallocTest = []struct {\n \t{5, `Sprintf(\"%x\")`, func() { Sprintf(\"%x\", 7) }},\n \t{5, `Sprintf(\"%s\")`, func() { Sprintf(\"%s\", \"hello\") }},\n \t{5, `Sprintf(\"%x %x\")`, func() { Sprintf(\"%x %x\", 7, 112) }},\n-\t// For %g we use a float32, not float64, to guarantee passing the argument\n-\t// does not need to allocate memory to store the result in a pointer-sized word.\n-\t{20, `Sprintf(\"%g\")`, func() { Sprintf(\"%g\", float32(3.14159)) }},\n-\t{5, `Fprintf(buf, \"%x %x %x\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%x %x %x\", 7, 8, 9) }},\n+\t{20, `Sprintf(\"%g\")`, func() { Sprintf(\"%g\", float32(3.14159)) }}, // TODO: Can this be 1?\n \t{5, `Fprintf(buf, \"%s\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%s\", \"hello\") }},\n+\t// If the interface value doesn't need to allocate, amortized allocation overhead should be zero.\n+\t{5, `Fprintf(buf, \"%x %x %x\")`, func() {\n+\t\tmallocBuf.Reset()\n+\t\tFprintf(&mallocBuf, \"%x %x %x\", mallocPointer, mallocPointer, mallocPointer)\n+\t}},\n }\n \n var _ bytes.Buffer\n@@ -859,7 +921,7 @@ func TestCountMallocs(t *testing.T) {\n \n type flagPrinter struct{}\n \n-func (*flagPrinter) Format(f State, c rune) {\n+func (flagPrinter) Format(f State, c rune) {\n \ts := \"%\"\n \tfor i := 0; i < 128; i++ {\n \t\tif f.Flag(i) {\n@@ -905,11 +967,12 @@ func TestFlagParser(t *testing.T) {\n }\n \n func TestStructPrinter(t *testing.T) {\n-\tvar s struct {\n+\ttype T struct {\n \t\ta string\n \t\tb string\n \t\tc int\n \t}\n+\tvar s T\n \ts.a = \"abc\"\n \ts.b = \"def\"\n \ts.c = 123\n@@ -919,15 +982,38 @@ func TestStructPrinter(t *testing.T) {\n \t}{\n \t\t{\"%v\", \"{abc def 123}\"},\n \t\t{\"%+v\", \"{a:abc b:def c:123}\"},\n+\t\t{\"%#v\", `fmt_test.T{a:\"abc\", b:\"def\", c:123}`},\n \t}\n \tfor _, tt := range tests {\n \t\tout := Sprintf(tt.fmt, s)\n \t\tif out != tt.out {\n-\t\t\tt.Errorf(\"Sprintf(%q, &s) = %q, want %q\", tt.fmt, out, tt.out)\n+\t\t\tt.Errorf(\"Sprintf(%q, s) = %#q, want %#q\", tt.fmt, out, tt.out)\n+\t\t}\n+\t\t// The same but with a pointer.\n+\t\tout = Sprintf(tt.fmt, &s)\n+\t\tif out != \"&\"+tt.out {\n+\t\t\tt.Errorf(\"Sprintf(%q, &s) = %#q, want %#q\", tt.fmt, out, \"&\"+tt.out)\n \t\t}\n \t}\n }\n \n+func TestSlicePrinter(t *testing.T) {\n+\tslice := []int{}\n+\ts := Sprint(slice)\n+\tif s != \"[]\" {\n+\t\tt.Errorf(\"empty slice printed as %q not %q\", s, \"[]\")\n+\t}\n+\tslice = []int{1, 2, 3}\n+\ts = Sprint(slice)\n+\tif s != \"[1 2 3]\" {\n+\t\tt.Errorf(\"slice: got %q expected %q\", s, \"[1 2 3]\")\n+\t}\n+\ts = Sprint(&slice)\n+\tif s != \"&[1 2 3]\" {\n+\t\tt.Errorf(\"&slice: got %q expected %q\", s, \"&[1 2 3]\")\n+\t}\n+}\n+\n // presentInMap checks map printing using substrings so we don't depend on the\n // print order.\n func presentInMap(s string, a []string, t *testing.T) {\n@@ -954,6 +1040,12 @@ func TestMapPrinter(t *testing.T) {\n \ta := []string{\"1:one\", \"2:two\", \"3:three\"}\n \tpresentInMap(Sprintf(\"%v\", m1), a, t)\n \tpresentInMap(Sprint(m1), a, t)\n+\t// Pointer to map prints the same but with initial &.\n+\tif !strings.HasPrefix(Sprint(&m1), \"&\") {\n+\t\tt.Errorf(\"no initial & for address of map\")\n+\t}\n+\tpresentInMap(Sprintf(\"%v\", &m1), a, t)\n+\tpresentInMap(Sprint(&m1), a, t)\n }\n \n func TestEmptyMap(t *testing.T) {\n@@ -1084,10 +1176,10 @@ var panictests = []struct {\n }\n \n func TestPanics(t *testing.T) {\n-\tfor _, tt := range panictests {\n+\tfor i, tt := range panictests {\n \t\ts := Sprintf(tt.fmt, tt.in)\n \t\tif s != tt.out {\n-\t\t\tt.Errorf(\"%q: got %q expected %q\", tt.fmt, s, tt.out)\n+\t\t\tt.Errorf(\"%d: %q: got %q expected %q\", i, tt.fmt, s, tt.out)\n \t\t}\n \t}\n }\n@@ -1147,3 +1239,74 @@ func TestNilDoesNotBecomeTyped(t *testing.T) {\n \t\tt.Errorf(\"expected:\\n\\t%q\\ngot:\\n\\t%q\", expect, got)\n \t}\n }\n+\n+var formatterFlagTests = []struct {\n+\tin  string\n+\tval interface{}\n+\tout string\n+}{\n+\t// scalar values with the (unused by fmt) 'a' verb.\n+\t{\"%a\", flagPrinter{}, \"[%a]\"},\n+\t{\"%-a\", flagPrinter{}, \"[%-a]\"},\n+\t{\"%+a\", flagPrinter{}, \"[%+a]\"},\n+\t{\"%#a\", flagPrinter{}, \"[%#a]\"},\n+\t{\"% a\", flagPrinter{}, \"[% a]\"},\n+\t{\"%0a\", flagPrinter{}, \"[%0a]\"},\n+\t{\"%1.2a\", flagPrinter{}, \"[%1.2a]\"},\n+\t{\"%-1.2a\", flagPrinter{}, \"[%-1.2a]\"},\n+\t{\"%+1.2a\", flagPrinter{}, \"[%+1.2a]\"},\n+\t{\"%-+1.2a\", flagPrinter{}, \"[%+-1.2a]\"},\n+\t{\"%-+1.2abc\", flagPrinter{}, \"[%+-1.2a]bc\"},\n+\t{\"%-1.2abc\", flagPrinter{}, \"[%-1.2a]bc\"},\n+\n+\t// composite values with the 'a' verb\n+\t{\"%a\", [1]flagPrinter{}, \"[[%a]]\"},\n+\t{\"%-a\", [1]flagPrinter{}, \"[[%-a]]\"},\n+\t{\"%+a\", [1]flagPrinter{}, \"[[%+a]]\"},\n+\t{\"%#a\", [1]flagPrinter{}, \"[[%#a]]\"},\n+\t{\"% a\", [1]flagPrinter{}, \"[[% a]]\"},\n+\t{\"%0a\", [1]flagPrinter{}, \"[[%0a]]\"},\n+\t{\"%1.2a\", [1]flagPrinter{}, \"[[%1.2a]]\"},\n+\t{\"%-1.2a\", [1]flagPrinter{}, \"[[%-1.2a]]\"},\n+\t{\"%+1.2a\", [1]flagPrinter{}, \"[[%+1.2a]]\"},\n+\t{\"%-+1.2a\", [1]flagPrinter{}, \"[[%+-1.2a]]\"},\n+\t{\"%-+1.2abc\", [1]flagPrinter{}, \"[[%+-1.2a]]bc\"},\n+\t{\"%-1.2abc\", [1]flagPrinter{}, \"[[%-1.2a]]bc\"},\n+\n+\t// simple values with the 'v' verb\n+\t{\"%v\", flagPrinter{}, \"[%v]\"},\n+\t{\"%-v\", flagPrinter{}, \"[%-v]\"},\n+\t{\"%+v\", flagPrinter{}, \"[%+v]\"},\n+\t{\"%#v\", flagPrinter{}, \"[%#v]\"},\n+\t{\"% v\", flagPrinter{}, \"[% v]\"},\n+\t{\"%0v\", flagPrinter{}, \"[%0v]\"},\n+\t{\"%1.2v\", flagPrinter{}, \"[%1.2v]\"},\n+\t{\"%-1.2v\", flagPrinter{}, \"[%-1.2v]\"},\n+\t{\"%+1.2v\", flagPrinter{}, \"[%+1.2v]\"},\n+\t{\"%-+1.2v\", flagPrinter{}, \"[%+-1.2v]\"},\n+\t{\"%-+1.2vbc\", flagPrinter{}, \"[%+-1.2v]bc\"},\n+\t{\"%-1.2vbc\", flagPrinter{}, \"[%-1.2v]bc\"},\n+\n+\t// composite values with the 'v' verb.\n+\t{\"%v\", [1]flagPrinter{}, \"[[%v]]\"},\n+\t{\"%-v\", [1]flagPrinter{}, \"[[%-v]]\"},\n+\t{\"%+v\", [1]flagPrinter{}, \"[[%+v]]\"},\n+\t{\"%#v\", [1]flagPrinter{}, \"[1]fmt_test.flagPrinter{[%#v]}\"},\n+\t{\"% v\", [1]flagPrinter{}, \"[[% v]]\"},\n+\t{\"%0v\", [1]flagPrinter{}, \"[[%0v]]\"},\n+\t{\"%1.2v\", [1]flagPrinter{}, \"[[%1.2v]]\"},\n+\t{\"%-1.2v\", [1]flagPrinter{}, \"[[%-1.2v]]\"},\n+\t{\"%+1.2v\", [1]flagPrinter{}, \"[[%+1.2v]]\"},\n+\t{\"%-+1.2v\", [1]flagPrinter{}, \"[[%+-1.2v]]\"},\n+\t{\"%-+1.2vbc\", [1]flagPrinter{}, \"[[%+-1.2v]]bc\"},\n+\t{\"%-1.2vbc\", [1]flagPrinter{}, \"[[%-1.2v]]bc\"},\n+}\n+\n+func TestFormatterFlags(t *testing.T) {\n+\tfor _, tt := range formatterFlagTests {\n+\t\ts := Sprintf(tt.in, tt.val)\n+\t\tif s != tt.out {\n+\t\t\tt.Errorf(\"Sprintf(%q, %T) = %q, want %q\", tt.in, tt.val, s, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "4d97d1443eda1292c403fd086acf7fc627b1c88a", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -34,15 +34,8 @@ func init() {\n \t}\n }\n \n-// A fmt is the raw formatter used by Printf etc.\n-// It prints into a buffer that must be set up separately.\n-type fmt struct {\n-\tintbuf [nByte]byte\n-\tbuf    *buffer\n-\t// width, precision\n-\twid  int\n-\tprec int\n-\t// flags\n+// flags placed in a separate struct for easy clearing.\n+type fmtFlags struct {\n \twidPresent  bool\n \tprecPresent bool\n \tminus       bool\n@@ -52,20 +45,27 @@ type fmt struct {\n \tunicode     bool\n \tuniQuote    bool // Use 'x'= prefix for %U if printable.\n \tzero        bool\n+\n+\t// For the formats %+v %#v, we set the plusV/sharpV flags\n+\t// and clear the plus/sharp flags since %+v and %#v are in effect\n+\t// different, flagless formats set at the top level.\n+\tplusV  bool\n+\tsharpV bool\n+}\n+\n+// A fmt is the raw formatter used by Printf etc.\n+// It prints into a buffer that must be set up separately.\n+type fmt struct {\n+\tintbuf [nByte]byte\n+\tbuf    *buffer\n+\t// width, precision\n+\twid  int\n+\tprec int\n+\tfmtFlags\n }\n \n func (f *fmt) clearflags() {\n-\tf.wid = 0\n-\tf.widPresent = false\n-\tf.prec = 0\n-\tf.precPresent = false\n-\tf.minus = false\n-\tf.plus = false\n-\tf.sharp = false\n-\tf.space = false\n-\tf.unicode = false\n-\tf.uniQuote = false\n-\tf.zero = false\n+\tf.fmtFlags = fmtFlags{}\n }\n \n func (f *fmt) init(buf *buffer) {\n@@ -114,7 +114,7 @@ func (f *fmt) pad(b []byte) {\n \t\tf.buf.Write(b)\n \t\treturn\n \t}\n-\tpadding, left, right := f.computePadding(len(b))\n+\tpadding, left, right := f.computePadding(utf8.RuneCount(b))\n \tif left > 0 {\n \t\tf.writePadding(left, padding)\n \t}\n@@ -199,10 +199,36 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {\n \t// block but it's not worth the duplication, so ua has 64 bits.\n \ti := len(buf)\n \tua := uint64(a)\n-\tfor ua >= base {\n-\t\ti--\n-\t\tbuf[i] = digits[ua%base]\n-\t\tua /= base\n+\t// use constants for the division and modulo for more efficient code.\n+\t// switch cases ordered by popularity.\n+\tswitch base {\n+\tcase 10:\n+\t\tfor ua >= 10 {\n+\t\t\ti--\n+\t\t\tnext := ua / 10\n+\t\t\tbuf[i] = byte('0' + ua - next*10)\n+\t\t\tua = next\n+\t\t}\n+\tcase 16:\n+\t\tfor ua >= 16 {\n+\t\t\ti--\n+\t\t\tbuf[i] = digits[ua&0xF]\n+\t\t\tua >>= 4\n+\t\t}\n+\tcase 8:\n+\t\tfor ua >= 8 {\n+\t\t\ti--\n+\t\t\tbuf[i] = byte('0' + ua&7)\n+\t\t\tua >>= 3\n+\t\t}\n+\tcase 2:\n+\t\tfor ua >= 2 {\n+\t\t\ti--\n+\t\t\tbuf[i] = byte('0' + ua&1)\n+\t\t\tua >>= 1\n+\t\t}\n+\tdefault:\n+\t\tpanic(\"fmt: unknown base; can't happen\")\n \t}\n \ti--\n \tbuf[i] = digits[ua]\n@@ -298,7 +324,7 @@ func (f *fmt) fmt_sbx(s string, b []byte, digits string) {\n \t\tif i > 0 && f.space {\n \t\t\tbuf = append(buf, ' ')\n \t\t}\n-\t\tif f.sharp {\n+\t\tif f.sharp && (f.space || i == 0) {\n \t\t\tbuf = append(buf, '0', x)\n \t\t}\n \t\tvar c byte\n@@ -314,11 +340,17 @@ func (f *fmt) fmt_sbx(s string, b []byte, digits string) {\n \n // fmt_sx formats a string as a hexadecimal encoding of its bytes.\n func (f *fmt) fmt_sx(s, digits string) {\n+\tif f.precPresent && f.prec < len(s) {\n+\t\ts = s[:f.prec]\n+\t}\n \tf.fmt_sbx(s, nil, digits)\n }\n \n // fmt_bx formats a byte slice as a hexadecimal encoding of its bytes.\n func (f *fmt) fmt_bx(b []byte, digits string) {\n+\tif f.precPresent && f.prec < len(b) {\n+\t\tb = b[:f.prec]\n+\t}\n \tf.fmt_sbx(\"\", b, digits)\n }\n "}, {"sha": "59a30d221e92aa55d0dbce98eba35a5936560ad6", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 125, "deletions": 101, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -128,7 +128,7 @@ var ppFree = sync.Pool{\n \tNew: func() interface{} { return new(pp) },\n }\n \n-// newPrinter allocates a new pp struct or grab a cached one.\n+// newPrinter allocates a new pp struct or grabs a cached one.\n func newPrinter() *pp {\n \tp := ppFree.Get().(*pp)\n \tp.panicking = false\n@@ -297,13 +297,13 @@ func parsenum(s string, start, end int) (num int, isnum bool, newi int) {\n \treturn\n }\n \n-func (p *pp) unknownType(v interface{}) {\n-\tif v == nil {\n+func (p *pp) unknownType(v reflect.Value) {\n+\tif !v.IsValid() {\n \t\tp.buf.Write(nilAngleBytes)\n \t\treturn\n \t}\n \tp.buf.WriteByte('?')\n-\tp.buf.WriteString(reflect.TypeOf(v).String())\n+\tp.buf.WriteString(v.Type().String())\n \tp.buf.WriteByte('?')\n }\n \n@@ -317,11 +317,11 @@ func (p *pp) badVerb(verb rune) {\n \tcase p.arg != nil:\n \t\tp.buf.WriteString(reflect.TypeOf(p.arg).String())\n \t\tp.add('=')\n-\t\tp.printArg(p.arg, 'v', false, false, 0)\n+\t\tp.printArg(p.arg, 'v', 0)\n \tcase p.value.IsValid():\n \t\tp.buf.WriteString(p.value.Type().String())\n \t\tp.add('=')\n-\t\tp.printValue(p.value, 'v', false, false, 0)\n+\t\tp.printValue(p.value, 'v', 0)\n \tdefault:\n \t\tp.buf.Write(nilAngleBytes)\n \t}\n@@ -406,7 +406,7 @@ func (p *pp) fmtUnicode(v int64) {\n \tp.fmt.sharp = sharp\n }\n \n-func (p *pp) fmtUint64(v uint64, verb rune, goSyntax bool) {\n+func (p *pp) fmtUint64(v uint64, verb rune) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.integer(int64(v), 2, unsigned, ldigits)\n@@ -415,7 +415,7 @@ func (p *pp) fmtUint64(v uint64, verb rune, goSyntax bool) {\n \tcase 'd':\n \t\tp.fmt.integer(int64(v), 10, unsigned, ldigits)\n \tcase 'v':\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tp.fmt0x64(v, true)\n \t\t} else {\n \t\t\tp.fmt.integer(int64(v), 10, unsigned, ldigits)\n@@ -499,10 +499,10 @@ func (p *pp) fmtComplex128(v complex128, verb rune) {\n \t}\n }\n \n-func (p *pp) fmtString(v string, verb rune, goSyntax bool) {\n+func (p *pp) fmtString(v string, verb rune) {\n \tswitch verb {\n \tcase 'v':\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tp.fmt.fmt_q(v)\n \t\t} else {\n \t\t\tp.fmt.fmt_s(v)\n@@ -520,9 +520,9 @@ func (p *pp) fmtString(v string, verb rune, goSyntax bool) {\n \t}\n }\n \n-func (p *pp) fmtBytes(v []byte, verb rune, goSyntax bool, typ reflect.Type, depth int) {\n+func (p *pp) fmtBytes(v []byte, verb rune, typ reflect.Type, depth int) {\n \tif verb == 'v' || verb == 'd' {\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tif v == nil {\n \t\t\t\tif typ == nil {\n \t\t\t\t\tp.buf.WriteString(\"[]byte(nil)\")\n@@ -543,15 +543,15 @@ func (p *pp) fmtBytes(v []byte, verb rune, goSyntax bool, typ reflect.Type, dept\n \t\t}\n \t\tfor i, c := range v {\n \t\t\tif i > 0 {\n-\t\t\t\tif goSyntax {\n+\t\t\t\tif p.fmt.sharpV {\n \t\t\t\t\tp.buf.Write(commaSpaceBytes)\n \t\t\t\t} else {\n \t\t\t\t\tp.buf.WriteByte(' ')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printArg(c, 'v', p.fmt.plus, goSyntax, depth+1)\n+\t\t\tp.printArg(c, 'v', depth+1)\n \t\t}\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tp.buf.WriteByte('}')\n \t\t} else {\n \t\t\tp.buf.WriteByte(']')\n@@ -572,7 +572,7 @@ func (p *pp) fmtBytes(v []byte, verb rune, goSyntax bool, typ reflect.Type, dept\n \t}\n }\n \n-func (p *pp) fmtPointer(value reflect.Value, verb rune, goSyntax bool) {\n+func (p *pp) fmtPointer(value reflect.Value, verb rune) {\n \tuse0x64 := true\n \tswitch verb {\n \tcase 'p', 'v':\n@@ -594,7 +594,7 @@ func (p *pp) fmtPointer(value reflect.Value, verb rune, goSyntax bool) {\n \t\treturn\n \t}\n \n-\tif goSyntax {\n+\tif p.fmt.sharpV {\n \t\tp.add('(')\n \t\tp.buf.WriteString(value.Type().String())\n \t\tp.add(')')\n@@ -611,7 +611,7 @@ func (p *pp) fmtPointer(value reflect.Value, verb rune, goSyntax bool) {\n \t\tif use0x64 {\n \t\t\tp.fmt0x64(uint64(u), !p.fmt.sharp)\n \t\t} else {\n-\t\t\tp.fmtUint64(uint64(u), verb, false)\n+\t\t\tp.fmtUint64(uint64(u), verb)\n \t\t}\n \t}\n }\n@@ -636,42 +636,65 @@ func (p *pp) catchPanic(arg interface{}, verb rune) {\n \t\t\t// Nested panics; the recursion in printArg cannot succeed.\n \t\t\tpanic(err)\n \t\t}\n+\t\tp.fmt.clearflags() // We are done, and for this output we want default behavior.\n \t\tp.buf.Write(percentBangBytes)\n \t\tp.add(verb)\n \t\tp.buf.Write(panicBytes)\n \t\tp.panicking = true\n-\t\tp.printArg(err, 'v', false, false, 0)\n+\t\tp.printArg(err, 'v', 0)\n \t\tp.panicking = false\n \t\tp.buf.WriteByte(')')\n \t}\n }\n \n-func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString, handled bool) {\n+// clearSpecialFlags pushes %#v back into the regular flags and returns their old state.\n+func (p *pp) clearSpecialFlags() (plusV, sharpV bool) {\n+\tplusV = p.fmt.plusV\n+\tif plusV {\n+\t\tp.fmt.plus = true\n+\t\tp.fmt.plusV = false\n+\t}\n+\tsharpV = p.fmt.sharpV\n+\tif sharpV {\n+\t\tp.fmt.sharp = true\n+\t\tp.fmt.sharpV = false\n+\t}\n+\treturn\n+}\n+\n+// restoreSpecialFlags, whose argument should be a call to clearSpecialFlags,\n+// restores the setting of the plusV and sharpV flags.\n+func (p *pp) restoreSpecialFlags(plusV, sharpV bool) {\n+\tif plusV {\n+\t\tp.fmt.plus = false\n+\t\tp.fmt.plusV = true\n+\t}\n+\tif sharpV {\n+\t\tp.fmt.sharp = false\n+\t\tp.fmt.sharpV = true\n+\t}\n+}\n+\n+func (p *pp) handleMethods(verb rune, depth int) (handled bool) {\n \tif p.erroring {\n \t\treturn\n \t}\n \t// Is it a Formatter?\n \tif formatter, ok := p.arg.(Formatter); ok {\n \t\thandled = true\n-\t\twasString = false\n+\t\tdefer p.restoreSpecialFlags(p.clearSpecialFlags())\n \t\tdefer p.catchPanic(p.arg, verb)\n \t\tformatter.Format(p, verb)\n \t\treturn\n \t}\n-\t// Must not touch flags before Formatter looks at them.\n-\tif plus {\n-\t\tp.fmt.plus = false\n-\t}\n \n \t// If we're doing Go syntax and the argument knows how to supply it, take care of it now.\n-\tif goSyntax {\n-\t\tp.fmt.sharp = false\n+\tif p.fmt.sharpV {\n \t\tif stringer, ok := p.arg.(GoStringer); ok {\n-\t\t\twasString = false\n \t\t\thandled = true\n \t\t\tdefer p.catchPanic(p.arg, verb)\n \t\t\t// Print the result of GoString unadorned.\n-\t\t\tp.fmtString(stringer.GoString(), 's', false)\n+\t\t\tp.fmt.fmt_s(stringer.GoString())\n \t\t\treturn\n \t\t}\n \t} else {\n@@ -682,30 +705,27 @@ func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString\n \t\tcase 'v', 's', 'x', 'X', 'q':\n \t\t\t// Is it an error or Stringer?\n \t\t\t// The duplication in the bodies is necessary:\n-\t\t\t// setting wasString and handled, and deferring catchPanic,\n+\t\t\t// setting handled and deferring catchPanic\n \t\t\t// must happen before calling the method.\n \t\t\tswitch v := p.arg.(type) {\n \t\t\tcase error:\n-\t\t\t\twasString = false\n \t\t\t\thandled = true\n \t\t\t\tdefer p.catchPanic(p.arg, verb)\n-\t\t\t\tp.printArg(v.Error(), verb, plus, false, depth)\n+\t\t\t\tp.printArg(v.Error(), verb, depth)\n \t\t\t\treturn\n \n \t\t\tcase Stringer:\n-\t\t\t\twasString = false\n \t\t\t\thandled = true\n \t\t\t\tdefer p.catchPanic(p.arg, verb)\n-\t\t\t\tp.printArg(v.String(), verb, plus, false, depth)\n+\t\t\t\tp.printArg(v.String(), verb, depth)\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n \t}\n-\thandled = false\n-\treturn\n+\treturn false\n }\n \n-func (p *pp) printArg(arg interface{}, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n+func (p *pp) printArg(arg interface{}, verb rune, depth int) (wasString bool) {\n \tp.arg = arg\n \tp.value = reflect.Value{}\n \n@@ -722,26 +742,13 @@ func (p *pp) printArg(arg interface{}, verb rune, plus, goSyntax bool, depth int\n \t// %T (the value's type) and %p (its address) are special; we always do them first.\n \tswitch verb {\n \tcase 'T':\n-\t\tp.printArg(reflect.TypeOf(arg).String(), 's', false, false, 0)\n+\t\tp.printArg(reflect.TypeOf(arg).String(), 's', 0)\n \t\treturn false\n \tcase 'p':\n-\t\tp.fmtPointer(reflect.ValueOf(arg), verb, goSyntax)\n+\t\tp.fmtPointer(reflect.ValueOf(arg), verb)\n \t\treturn false\n \t}\n \n-\t// Clear flags for base formatters.\n-\t// handleMethods needs them, so we must restore them later.\n-\t// We could call handleMethods here and avoid this work, but\n-\t// handleMethods is expensive enough to be worth delaying.\n-\toldPlus := p.fmt.plus\n-\toldSharp := p.fmt.sharp\n-\tif plus {\n-\t\tp.fmt.plus = false\n-\t}\n-\tif goSyntax {\n-\t\tp.fmt.sharp = false\n-\t}\n-\n \t// Some types can be done without reflection.\n \tswitch f := arg.(type) {\n \tcase bool:\n@@ -765,40 +772,37 @@ func (p *pp) printArg(arg interface{}, verb rune, plus, goSyntax bool, depth int\n \tcase int64:\n \t\tp.fmtInt64(f, verb)\n \tcase uint:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n+\t\tp.fmtUint64(uint64(f), verb)\n \tcase uint8:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n+\t\tp.fmtUint64(uint64(f), verb)\n \tcase uint16:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n+\t\tp.fmtUint64(uint64(f), verb)\n \tcase uint32:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n+\t\tp.fmtUint64(uint64(f), verb)\n \tcase uint64:\n-\t\tp.fmtUint64(f, verb, goSyntax)\n+\t\tp.fmtUint64(f, verb)\n \tcase uintptr:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax)\n+\t\tp.fmtUint64(uint64(f), verb)\n \tcase string:\n-\t\tp.fmtString(f, verb, goSyntax)\n+\t\tp.fmtString(f, verb)\n \t\twasString = verb == 's' || verb == 'v'\n \tcase []byte:\n-\t\tp.fmtBytes(f, verb, goSyntax, nil, depth)\n+\t\tp.fmtBytes(f, verb, nil, depth)\n \t\twasString = verb == 's'\n \tdefault:\n-\t\t// Restore flags in case handleMethods finds a Formatter.\n-\t\tp.fmt.plus = oldPlus\n-\t\tp.fmt.sharp = oldSharp\n \t\t// If the type is not simple, it might have methods.\n-\t\tif isString, handled := p.handleMethods(verb, plus, goSyntax, depth); handled {\n-\t\t\treturn isString\n+\t\tif handled := p.handleMethods(verb, depth); handled {\n+\t\t\treturn false\n \t\t}\n \t\t// Need to use reflection\n-\t\treturn p.printReflectValue(reflect.ValueOf(arg), verb, plus, goSyntax, depth)\n+\t\treturn p.printReflectValue(reflect.ValueOf(arg), verb, depth)\n \t}\n \tp.arg = nil\n \treturn\n }\n \n // printValue is like printArg but starts with a reflect value, not an interface{} value.\n-func (p *pp) printValue(value reflect.Value, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n+func (p *pp) printValue(value reflect.Value, verb rune, depth int) (wasString bool) {\n \tif !value.IsValid() {\n \t\tif verb == 'T' || verb == 'v' {\n \t\t\tp.buf.Write(nilAngleBytes)\n@@ -812,10 +816,10 @@ func (p *pp) printValue(value reflect.Value, verb rune, plus, goSyntax bool, dep\n \t// %T (the value's type) and %p (its address) are special; we always do them first.\n \tswitch verb {\n \tcase 'T':\n-\t\tp.printArg(value.Type().String(), 's', false, false, 0)\n+\t\tp.printArg(value.Type().String(), 's', 0)\n \t\treturn false\n \tcase 'p':\n-\t\tp.fmtPointer(value, verb, goSyntax)\n+\t\tp.fmtPointer(value, verb)\n \t\treturn false\n \t}\n \n@@ -825,16 +829,18 @@ func (p *pp) printValue(value reflect.Value, verb rune, plus, goSyntax bool, dep\n \tif value.CanInterface() {\n \t\tp.arg = value.Interface()\n \t}\n-\tif isString, handled := p.handleMethods(verb, plus, goSyntax, depth); handled {\n-\t\treturn isString\n+\tif handled := p.handleMethods(verb, depth); handled {\n+\t\treturn false\n \t}\n \n-\treturn p.printReflectValue(value, verb, plus, goSyntax, depth)\n+\treturn p.printReflectValue(value, verb, depth)\n }\n \n+var byteType = reflect.TypeOf(byte(0))\n+\n // printReflectValue is the fallback for both printArg and printValue.\n // It uses reflect to print the value.\n-func (p *pp) printReflectValue(value reflect.Value, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n+func (p *pp) printReflectValue(value reflect.Value, verb rune, depth int) (wasString bool) {\n \toldValue := p.value\n \tp.value = value\n BigSwitch:\n@@ -844,7 +850,7 @@ BigSwitch:\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n \t\tp.fmtInt64(f.Int(), verb)\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\tp.fmtUint64(f.Uint(), verb, goSyntax)\n+\t\tp.fmtUint64(f.Uint(), verb)\n \tcase reflect.Float32, reflect.Float64:\n \t\tif f.Type().Size() == 4 {\n \t\t\tp.fmtFloat32(float32(f.Float()), verb)\n@@ -858,9 +864,9 @@ BigSwitch:\n \t\t\tp.fmtComplex128(f.Complex(), verb)\n \t\t}\n \tcase reflect.String:\n-\t\tp.fmtString(f.String(), verb, goSyntax)\n+\t\tp.fmtString(f.String(), verb)\n \tcase reflect.Map:\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tp.buf.WriteString(f.Type().String())\n \t\t\tif f.IsNil() {\n \t\t\t\tp.buf.WriteString(\"(nil)\")\n@@ -873,60 +879,64 @@ BigSwitch:\n \t\tkeys := f.MapKeys()\n \t\tfor i, key := range keys {\n \t\t\tif i > 0 {\n-\t\t\t\tif goSyntax {\n+\t\t\t\tif p.fmt.sharpV {\n \t\t\t\t\tp.buf.Write(commaSpaceBytes)\n \t\t\t\t} else {\n \t\t\t\t\tp.buf.WriteByte(' ')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printValue(key, verb, plus, goSyntax, depth+1)\n+\t\t\tp.printValue(key, verb, depth+1)\n \t\t\tp.buf.WriteByte(':')\n-\t\t\tp.printValue(f.MapIndex(key), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printValue(f.MapIndex(key), verb, depth+1)\n \t\t}\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tp.buf.WriteByte('}')\n \t\t} else {\n \t\t\tp.buf.WriteByte(']')\n \t\t}\n \tcase reflect.Struct:\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tp.buf.WriteString(value.Type().String())\n \t\t}\n \t\tp.add('{')\n \t\tv := f\n \t\tt := v.Type()\n \t\tfor i := 0; i < v.NumField(); i++ {\n \t\t\tif i > 0 {\n-\t\t\t\tif goSyntax {\n+\t\t\t\tif p.fmt.sharpV {\n \t\t\t\t\tp.buf.Write(commaSpaceBytes)\n \t\t\t\t} else {\n \t\t\t\t\tp.buf.WriteByte(' ')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif plus || goSyntax {\n+\t\t\tif p.fmt.plusV || p.fmt.sharpV {\n \t\t\t\tif f := t.Field(i); f.Name != \"\" {\n \t\t\t\t\tp.buf.WriteString(f.Name)\n \t\t\t\t\tp.buf.WriteByte(':')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printValue(getField(v, i), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printValue(getField(v, i), verb, depth+1)\n \t\t}\n \t\tp.buf.WriteByte('}')\n \tcase reflect.Interface:\n \t\tvalue := f.Elem()\n \t\tif !value.IsValid() {\n-\t\t\tif goSyntax {\n+\t\t\tif p.fmt.sharpV {\n \t\t\t\tp.buf.WriteString(f.Type().String())\n \t\t\t\tp.buf.Write(nilParenBytes)\n \t\t\t} else {\n \t\t\t\tp.buf.Write(nilAngleBytes)\n \t\t\t}\n \t\t} else {\n-\t\t\twasString = p.printValue(value, verb, plus, goSyntax, depth+1)\n+\t\t\twasString = p.printValue(value, verb, depth+1)\n \t\t}\n \tcase reflect.Array, reflect.Slice:\n-\t\t// Byte slices are special.\n-\t\tif typ := f.Type(); typ.Elem().Kind() == reflect.Uint8 {\n+\t\t// Byte slices are special:\n+\t\t// - Handle []byte (== []uint8) with fmtBytes.\n+\t\t// - Handle []T, where T is a named byte type, with fmtBytes only\n+\t\t//   for the s, q, an x verbs. For other verbs, T might be a\n+\t\t//   Stringer, so we use printValue to print each element.\n+\t\tif typ := f.Type(); typ.Elem().Kind() == reflect.Uint8 && (typ.Elem() == byteType || verb == 's' || verb == 'q' || verb == 'x') {\n \t\t\tvar bytes []byte\n \t\t\tif f.Kind() == reflect.Slice {\n \t\t\t\tbytes = f.Bytes()\n@@ -941,11 +951,11 @@ BigSwitch:\n \t\t\t\t\tbytes[i] = byte(f.Index(i).Uint())\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.fmtBytes(bytes, verb, goSyntax, typ, depth)\n+\t\t\tp.fmtBytes(bytes, verb, typ, depth)\n \t\t\twasString = verb == 's'\n \t\t\tbreak\n \t\t}\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tp.buf.WriteString(value.Type().String())\n \t\t\tif f.Kind() == reflect.Slice && f.IsNil() {\n \t\t\t\tp.buf.WriteString(\"(nil)\")\n@@ -957,15 +967,15 @@ BigSwitch:\n \t\t}\n \t\tfor i := 0; i < f.Len(); i++ {\n \t\t\tif i > 0 {\n-\t\t\t\tif goSyntax {\n+\t\t\t\tif p.fmt.sharpV {\n \t\t\t\t\tp.buf.Write(commaSpaceBytes)\n \t\t\t\t} else {\n \t\t\t\t\tp.buf.WriteByte(' ')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printValue(f.Index(i), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printValue(f.Index(i), verb, depth+1)\n \t\t}\n-\t\tif goSyntax {\n+\t\tif p.fmt.sharpV {\n \t\t\tp.buf.WriteByte('}')\n \t\t} else {\n \t\t\tp.buf.WriteByte(']')\n@@ -978,17 +988,21 @@ BigSwitch:\n \t\t\tswitch a := f.Elem(); a.Kind() {\n \t\t\tcase reflect.Array, reflect.Slice:\n \t\t\t\tp.buf.WriteByte('&')\n-\t\t\t\tp.printValue(a, verb, plus, goSyntax, depth+1)\n+\t\t\t\tp.printValue(a, verb, depth+1)\n \t\t\t\tbreak BigSwitch\n \t\t\tcase reflect.Struct:\n \t\t\t\tp.buf.WriteByte('&')\n-\t\t\t\tp.printValue(a, verb, plus, goSyntax, depth+1)\n+\t\t\t\tp.printValue(a, verb, depth+1)\n+\t\t\t\tbreak BigSwitch\n+\t\t\tcase reflect.Map:\n+\t\t\t\tp.buf.WriteByte('&')\n+\t\t\t\tp.printValue(a, verb, depth+1)\n \t\t\t\tbreak BigSwitch\n \t\t\t}\n \t\t}\n \t\tfallthrough\n \tcase reflect.Chan, reflect.Func, reflect.UnsafePointer:\n-\t\tp.fmtPointer(value, verb, goSyntax)\n+\t\tp.fmtPointer(value, verb)\n \tdefault:\n \t\tp.unknownType(f)\n \t}\n@@ -1154,9 +1168,19 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \t\targ := a[argNum]\n \t\targNum++\n \n-\t\tgoSyntax := c == 'v' && p.fmt.sharp\n-\t\tplus := c == 'v' && p.fmt.plus\n-\t\tp.printArg(arg, c, plus, goSyntax, 0)\n+\t\tif c == 'v' {\n+\t\t\tif p.fmt.sharp {\n+\t\t\t\t// Go syntax. Set the flag in the fmt and clear the sharp flag.\n+\t\t\t\tp.fmt.sharp = false\n+\t\t\t\tp.fmt.sharpV = true\n+\t\t\t}\n+\t\t\tif p.fmt.plus {\n+\t\t\t\t// Struct-field syntax. Set the flag in the fmt and clear the plus flag.\n+\t\t\t\tp.fmt.plus = false\n+\t\t\t\tp.fmt.plusV = true\n+\t\t\t}\n+\t\t}\n+\t\tp.printArg(arg, c, 0)\n \t}\n \n \t// Check for extra arguments unless the call accessed the arguments\n@@ -1170,7 +1194,7 @@ func (p *pp) doPrintf(format string, a []interface{}) {\n \t\t\t\tp.buf.WriteString(reflect.TypeOf(arg).String())\n \t\t\t\tp.buf.WriteByte('=')\n \t\t\t}\n-\t\t\tp.printArg(arg, 'v', false, false, 0)\n+\t\t\tp.printArg(arg, 'v', 0)\n \t\t\tif argNum+1 < len(a) {\n \t\t\t\tp.buf.Write(commaSpaceBytes)\n \t\t\t}\n@@ -1191,7 +1215,7 @@ func (p *pp) doPrint(a []interface{}, addspace, addnewline bool) {\n \t\t\t\tp.buf.WriteByte(' ')\n \t\t\t}\n \t\t}\n-\t\tprevString = p.printArg(arg, 'v', false, false, 0)\n+\t\tprevString = p.printArg(arg, 'v', 0)\n \t}\n \tif addnewline {\n \t\tp.buf.WriteByte('\\n')"}, {"sha": "d7befeae43eee88d0543aa89d5b0474e56a95956", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -360,6 +360,7 @@ func (r *readRune) ReadRune() (rr rune, size int, err error) {\n \t}\n \tif r.buf[0] < utf8.RuneSelf { // fast check for common ASCII case\n \t\trr = rune(r.buf[0])\n+\t\tsize = 1 // Known to be 1.\n \t\treturn\n \t}\n \tvar n int"}, {"sha": "541e12df2102fa946ceae6e7f18dbb98a6c4f4d5", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -842,6 +842,38 @@ func TestLineByLineFscanf(t *testing.T) {\n \t}\n }\n \n+// TestScanStateCount verifies the correct byte count is returned. Issue 8512.\n+\n+// runeScanner implements the Scanner interface for TestScanStateCount.\n+type runeScanner struct {\n+\trune rune\n+\tsize int\n+}\n+\n+func (rs *runeScanner) Scan(state ScanState, verb rune) error {\n+\tr, size, err := state.ReadRune()\n+\trs.rune = r\n+\trs.size = size\n+\treturn err\n+}\n+\n+func TestScanStateCount(t *testing.T) {\n+\tvar a, b, c runeScanner\n+\tn, err := Sscanf(\"12\u2782\", \"%c%c%c\", &a, &b, &c)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif n != 3 {\n+\t\tt.Fatalf(\"expected 3 items consumed, got %d\")\n+\t}\n+\tif a.rune != '1' || b.rune != '2' || c.rune != '\u2782' {\n+\t\tt.Errorf(\"bad scan rune: %q %q %q should be '1' '2' '\u2782'\", a.rune, b.rune, c.rune)\n+\t}\n+\tif a.size != 1 || b.size != 1 || c.size != 3 {\n+\t\tt.Errorf(\"bad scan size: %q %q %q should be 1 1 3\", a.size, b.size, c.size)\n+\t}\n+}\n+\n // RecursiveInt accepts a string matching %d.%d.%d....\n // and parses it into a linked list.\n // It allows us to benchmark recursive descent style scanners."}, {"sha": "312e3d1b9890e788c844048bbfc5f0a5568ddeb7", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -699,9 +699,9 @@ type (\n \t// A RangeStmt represents a for statement with a range clause.\n \tRangeStmt struct {\n \t\tFor        token.Pos   // position of \"for\" keyword\n-\t\tKey, Value Expr        // Value may be nil\n-\t\tTokPos     token.Pos   // position of Tok\n-\t\tTok        token.Token // ASSIGN, DEFINE\n+\t\tKey, Value Expr        // Key, Value may be nil\n+\t\tTokPos     token.Pos   // position of Tok; invalid if Key == nil\n+\t\tTok        token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE\n \t\tX          Expr        // value to range over\n \t\tBody       *BlockStmt\n \t}"}, {"sha": "df1529d18198ce7e24122064c6ae53ef33c39ad0", "filename": "libgo/go/go/ast/scope.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fscope.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -80,7 +80,7 @@ type Object struct {\n \tName string      // declared name\n \tDecl interface{} // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil\n \tData interface{} // object-specific data; or nil\n-\tType interface{} // place holder for type information; may be nil\n+\tType interface{} // placeholder for type information; may be nil\n }\n \n // NewObj creates a new object of a given kind and name."}, {"sha": "73ac38647a23f2d6b7417428fb61659b2efe512d", "filename": "libgo/go/go/ast/walk.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -275,7 +275,9 @@ func Walk(v Visitor, node Node) {\n \t\tWalk(v, n.Body)\n \n \tcase *RangeStmt:\n-\t\tWalk(v, n.Key)\n+\t\tif n.Key != nil {\n+\t\t\tWalk(v, n.Key)\n+\t\t}\n \t\tif n.Value != nil {\n \t\t\tWalk(v, n.Value)\n \t\t}"}, {"sha": "2656aa06d684e41fbd2fd866e602f3bf57d54be8", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 202, "deletions": 30, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -23,6 +23,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"unicode\"\n+\t\"unicode/utf8\"\n )\n \n // A Context specifies the supporting context for a build.\n@@ -206,9 +207,7 @@ func (ctxt *Context) gopath() []string {\n \t\tif p == \"\" || p == ctxt.GOROOT {\n \t\t\t// Empty paths are uninteresting.\n \t\t\t// If the path is the GOROOT, ignore it.\n-\t\t\t// People sometimes set GOPATH=$GOROOT, which is useless\n-\t\t\t// but would cause us to find packages with import paths\n-\t\t\t// like \"pkg/math\".\n+\t\t\t// People sometimes set GOPATH=$GOROOT.\n \t\t\t// Do not get confused by this common mistake.\n \t\t\tcontinue\n \t\t}\n@@ -238,7 +237,7 @@ func (ctxt *Context) gopath() []string {\n func (ctxt *Context) SrcDirs() []string {\n \tvar all []string\n \tif ctxt.GOROOT != \"\" {\n-\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\")\n+\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\")\n \t\tif ctxt.isDir(dir) {\n \t\t\tall = append(all, dir)\n \t\t}\n@@ -272,6 +271,9 @@ var cgoEnabled = map[string]bool{\n \t\"linux/ppc64le\":   true,\n \t\"linux/s390\":      true,\n \t\"linux/s390x\":     true,\n+\t\"android/386\":     true,\n+\t\"android/amd64\":   true,\n+\t\"android/arm\":     true,\n \t\"netbsd/386\":      true,\n \t\"netbsd/amd64\":    true,\n \t\"netbsd/arm\":      true,\n@@ -296,10 +298,10 @@ func defaultContext() Context {\n \t// say \"+build go1.x\", and code that should only be built before Go 1.x\n \t// (perhaps it is the stub to use in that case) should say \"+build !go1.x\".\n \t//\n-\t// When we reach Go 1.4 the line will read\n-\t//\tc.ReleaseTags = []string{\"go1.1\", \"go1.2\", \"go1.3\", \"go1.4\"}\n+\t// When we reach Go 1.5 the line will read\n+\t//\tc.ReleaseTags = []string{\"go1.1\", \"go1.2\", \"go1.3\", \"go1.4\", \"go1.5\"}\n \t// and so on.\n-\tc.ReleaseTags = []string{\"go1.1\", \"go1.2\", \"go1.3\"}\n+\tc.ReleaseTags = []string{\"go1.1\", \"go1.2\", \"go1.3\", \"go1.4\"}\n \n \tswitch os.Getenv(\"CGO_ENABLED\") {\n \tcase \"1\":\n@@ -338,22 +340,29 @@ const (\n \t// If AllowBinary is set, Import can be satisfied by a compiled\n \t// package object without corresponding sources.\n \tAllowBinary\n+\n+\t// If ImportComment is set, parse import comments on package statements.\n+\t// Import returns an error if it finds a comment it cannot understand\n+\t// or finds conflicting comments in multiple source files.\n+\t// See golang.org/s/go14customimport for more information.\n+\tImportComment\n )\n \n // A Package describes the Go package found in a directory.\n type Package struct {\n-\tDir         string   // directory containing package sources\n-\tName        string   // package name\n-\tDoc         string   // documentation synopsis\n-\tImportPath  string   // import path of package (\"\" if unknown)\n-\tRoot        string   // root of Go tree where this package lives\n-\tSrcRoot     string   // package source root directory (\"\" if unknown)\n-\tPkgRoot     string   // package install root directory (\"\" if unknown)\n-\tBinDir      string   // command install directory (\"\" if unknown)\n-\tGoroot      bool     // package found in Go root\n-\tPkgObj      string   // installed .a file\n-\tAllTags     []string // tags that can influence file selection in this directory\n-\tConflictDir string   // this directory shadows Dir in $GOPATH\n+\tDir           string   // directory containing package sources\n+\tName          string   // package name\n+\tImportComment string   // path in import comment on package statement\n+\tDoc           string   // documentation synopsis\n+\tImportPath    string   // import path of package (\"\" if unknown)\n+\tRoot          string   // root of Go tree where this package lives\n+\tSrcRoot       string   // package source root directory (\"\" if unknown)\n+\tPkgRoot       string   // package install root directory (\"\" if unknown)\n+\tBinDir        string   // command install directory (\"\" if unknown)\n+\tGoroot        bool     // package found in Go root\n+\tPkgObj        string   // installed .a file\n+\tAllTags       []string // tags that can influence file selection in this directory\n+\tConflictDir   string   // this directory shadows Dir in $GOPATH\n \n \t// Source files\n \tGoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n@@ -412,6 +421,19 @@ func (e *NoGoError) Error() string {\n \treturn \"no buildable Go source files in \" + e.Dir\n }\n \n+// MultiplePackageError describes a directory containing\n+// multiple buildable Go source files for multiple packages.\n+type MultiplePackageError struct {\n+\tDir      string   // directory containing files\n+\tPackages []string // package names found\n+\tFiles    []string // corresponding files: Files[i] declares package Packages[i]\n+}\n+\n+func (e *MultiplePackageError) Error() string {\n+\t// Error string limited to two entries for compatibility.\n+\treturn fmt.Sprintf(\"found packages %s (%s) and %s (%s) in %s\", e.Packages[0], e.Files[0], e.Packages[1], e.Files[1], e.Dir)\n+}\n+\n func nameExt(name string) string {\n \ti := strings.LastIndex(name, \".\")\n \tif i < 0 {\n@@ -472,7 +494,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\t}\n \t\t// Determine canonical import path, if any.\n \t\tif ctxt.GOROOT != \"\" {\n-\t\t\troot := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\")\n+\t\t\troot := ctxt.joinPath(ctxt.GOROOT, \"src\")\n \t\t\tif sub, ok := ctxt.hasSubdir(root, p.Dir); ok {\n \t\t\t\tp.Goroot = true\n \t\t\t\tp.ImportPath = sub\n@@ -488,7 +510,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\t\t\t// but check that using it wouldn't find something\n \t\t\t\t// else first.\n \t\t\t\tif ctxt.GOROOT != \"\" {\n-\t\t\t\t\tif dir := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\", sub); ctxt.isDir(dir) {\n+\t\t\t\t\tif dir := ctxt.joinPath(ctxt.GOROOT, \"src\", sub); ctxt.isDir(dir) {\n \t\t\t\t\t\tp.ConflictDir = dir\n \t\t\t\t\t\tgoto Found\n \t\t\t\t\t}\n@@ -522,7 +544,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \n \t\t// Determine directory from import path.\n \t\tif ctxt.GOROOT != \"\" {\n-\t\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\", path)\n+\t\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\", path)\n \t\t\tisDir := ctxt.isDir(dir)\n \t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && pkga != \"\" && ctxt.isFile(ctxt.joinPath(ctxt.GOROOT, pkga))\n \t\t\tif isDir || binaryOnly {\n@@ -568,11 +590,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \n Found:\n \tif p.Root != \"\" {\n-\t\tif p.Goroot {\n-\t\t\tp.SrcRoot = ctxt.joinPath(p.Root, \"src\", \"pkg\")\n-\t\t} else {\n-\t\t\tp.SrcRoot = ctxt.joinPath(p.Root, \"src\")\n-\t\t}\n+\t\tp.SrcRoot = ctxt.joinPath(p.Root, \"src\")\n \t\tp.PkgRoot = ctxt.joinPath(p.Root, \"pkg\")\n \t\tp.BinDir = ctxt.joinPath(p.Root, \"bin\")\n \t\tif pkga != \"\" {\n@@ -593,7 +611,7 @@ Found:\n \t}\n \n \tvar Sfiles []string // files with \".S\" (capital S)\n-\tvar firstFile string\n+\tvar firstFile, firstCommentFile string\n \timported := make(map[string][]token.Position)\n \ttestImported := make(map[string][]token.Position)\n \txTestImported := make(map[string][]token.Position)\n@@ -674,12 +692,28 @@ Found:\n \t\t\tp.Name = pkg\n \t\t\tfirstFile = name\n \t\t} else if pkg != p.Name {\n-\t\t\treturn p, fmt.Errorf(\"found packages %s (%s) and %s (%s) in %s\", p.Name, firstFile, pkg, name, p.Dir)\n+\t\t\treturn p, &MultiplePackageError{p.Dir, []string{firstFile, name}, []string{p.Name, pkg}}\n \t\t}\n \t\tif pf.Doc != nil && p.Doc == \"\" {\n \t\t\tp.Doc = doc.Synopsis(pf.Doc.Text())\n \t\t}\n \n+\t\tif mode&ImportComment != 0 {\n+\t\t\tqcom, line := findImportComment(data)\n+\t\t\tif line != 0 {\n+\t\t\t\tcom, err := strconv.Unquote(qcom)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn p, fmt.Errorf(\"%s:%d: cannot parse import comment\", filename, line)\n+\t\t\t\t}\n+\t\t\t\tif p.ImportComment == \"\" {\n+\t\t\t\t\tp.ImportComment = com\n+\t\t\t\t\tfirstCommentFile = name\n+\t\t\t\t} else if p.ImportComment != com {\n+\t\t\t\t\treturn p, fmt.Errorf(\"found import comments %q (%s) and %q (%s) in %s\", p.ImportComment, firstCommentFile, com, name, p.Dir)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\t// Record imports and information about cgo.\n \t\tisCgo := false\n \t\tfor _, decl := range pf.Decls {\n@@ -760,6 +794,117 @@ Found:\n \treturn p, pkgerr\n }\n \n+func findImportComment(data []byte) (s string, line int) {\n+\t// expect keyword package\n+\tword, data := parseWord(data)\n+\tif string(word) != \"package\" {\n+\t\treturn \"\", 0\n+\t}\n+\n+\t// expect package name\n+\t_, data = parseWord(data)\n+\n+\t// now ready for import comment, a // or /* */ comment\n+\t// beginning and ending on the current line.\n+\tfor len(data) > 0 && (data[0] == ' ' || data[0] == '\\t' || data[0] == '\\r') {\n+\t\tdata = data[1:]\n+\t}\n+\n+\tvar comment []byte\n+\tswitch {\n+\tcase bytes.HasPrefix(data, slashSlash):\n+\t\ti := bytes.Index(data, newline)\n+\t\tif i < 0 {\n+\t\t\ti = len(data)\n+\t\t}\n+\t\tcomment = data[2:i]\n+\tcase bytes.HasPrefix(data, slashStar):\n+\t\tdata = data[2:]\n+\t\ti := bytes.Index(data, starSlash)\n+\t\tif i < 0 {\n+\t\t\t// malformed comment\n+\t\t\treturn \"\", 0\n+\t\t}\n+\t\tcomment = data[:i]\n+\t\tif bytes.Contains(comment, newline) {\n+\t\t\treturn \"\", 0\n+\t\t}\n+\t}\n+\tcomment = bytes.TrimSpace(comment)\n+\n+\t// split comment into `import`, `\"pkg\"`\n+\tword, arg := parseWord(comment)\n+\tif string(word) != \"import\" {\n+\t\treturn \"\", 0\n+\t}\n+\n+\tline = 1 + bytes.Count(data[:cap(data)-cap(arg)], newline)\n+\treturn strings.TrimSpace(string(arg)), line\n+}\n+\n+var (\n+\tslashSlash = []byte(\"//\")\n+\tslashStar  = []byte(\"/*\")\n+\tstarSlash  = []byte(\"*/\")\n+\tnewline    = []byte(\"\\n\")\n+)\n+\n+// skipSpaceOrComment returns data with any leading spaces or comments removed.\n+func skipSpaceOrComment(data []byte) []byte {\n+\tfor len(data) > 0 {\n+\t\tswitch data[0] {\n+\t\tcase ' ', '\\t', '\\r', '\\n':\n+\t\t\tdata = data[1:]\n+\t\t\tcontinue\n+\t\tcase '/':\n+\t\t\tif bytes.HasPrefix(data, slashSlash) {\n+\t\t\t\ti := bytes.Index(data, newline)\n+\t\t\t\tif i < 0 {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t\tdata = data[i+1:]\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif bytes.HasPrefix(data, slashStar) {\n+\t\t\t\tdata = data[2:]\n+\t\t\t\ti := bytes.Index(data, starSlash)\n+\t\t\t\tif i < 0 {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t\tdata = data[i+2:]\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tbreak\n+\t}\n+\treturn data\n+}\n+\n+// parseWord skips any leading spaces or comments in data\n+// and then parses the beginning of data as an identifier or keyword,\n+// returning that word and what remains after the word.\n+func parseWord(data []byte) (word, rest []byte) {\n+\tdata = skipSpaceOrComment(data)\n+\n+\t// Parse past leading word characters.\n+\trest = data\n+\tfor {\n+\t\tr, size := utf8.DecodeRune(rest)\n+\t\tif unicode.IsLetter(r) || '0' <= r && r <= '9' || r == '_' {\n+\t\t\trest = rest[size:]\n+\t\t\tcontinue\n+\t\t}\n+\t\tbreak\n+\t}\n+\n+\tword = data[:len(data)-len(rest)]\n+\tif len(word) == 0 {\n+\t\treturn nil, nil\n+\t}\n+\n+\treturn word, rest\n+}\n+\n // MatchFile reports whether the file with the given name in the given directory\n // matches the context and would be included in a Package created by ImportDir\n // of that directory.\n@@ -1128,6 +1273,9 @@ func (ctxt *Context) match(name string, allTags map[string]bool) bool {\n \tif name == ctxt.GOOS || name == ctxt.GOARCH || name == ctxt.Compiler {\n \t\treturn true\n \t}\n+\tif ctxt.GOOS == \"android\" && name == \"linux\" {\n+\t\treturn true\n+\t}\n \n \t// other tags\n \tfor _, tag := range ctxt.BuildTags {\n@@ -1155,10 +1303,25 @@ func (ctxt *Context) match(name string, allTags map[string]bool) bool {\n //     name_$(GOARCH)_test.*\n //     name_$(GOOS)_$(GOARCH)_test.*\n //\n+// An exception: if GOOS=android, then files with GOOS=linux are also matched.\n func (ctxt *Context) goodOSArchFile(name string, allTags map[string]bool) bool {\n \tif dot := strings.Index(name, \".\"); dot != -1 {\n \t\tname = name[:dot]\n \t}\n+\n+\t// Before Go 1.4, a file called \"linux.go\" would be equivalent to having a\n+\t// build tag \"linux\" in that file. For Go 1.4 and beyond, we require this\n+\t// auto-tagging to apply only to files with a non-empty prefix, so\n+\t// \"foo_linux.go\" is tagged but \"linux.go\" is not. This allows new operating\n+\t// sytems, such as android, to arrive without breaking existing code with\n+\t// innocuous source code in \"android.go\". The easiest fix: cut everything\n+\t// in the name before the initial _.\n+\ti := strings.Index(name, \"_\")\n+\tif i < 0 {\n+\t\treturn true\n+\t}\n+\tname = name[i:] // ignore everything before first _\n+\n \tl := strings.Split(name, \"_\")\n \tif n := len(l); n > 0 && l[n-1] == \"test\" {\n \t\tl = l[:n-1]\n@@ -1169,12 +1332,21 @@ func (ctxt *Context) goodOSArchFile(name string, allTags map[string]bool) bool {\n \t\t\tallTags[l[n-2]] = true\n \t\t\tallTags[l[n-1]] = true\n \t\t}\n-\t\treturn l[n-2] == ctxt.GOOS && l[n-1] == ctxt.GOARCH\n+\t\tif l[n-1] != ctxt.GOARCH {\n+\t\t\treturn false\n+\t\t}\n+\t\tif ctxt.GOOS == \"android\" && l[n-2] == \"linux\" {\n+\t\t\treturn true\n+\t\t}\n+\t\treturn l[n-2] == ctxt.GOOS\n \t}\n \tif n >= 1 && knownOS[l[n-1]] {\n \t\tif allTags != nil {\n \t\t\tallTags[l[n-1]] = true\n \t\t}\n+\t\tif ctxt.GOOS == \"android\" && l[n-1] == \"linux\" {\n+\t\t\treturn true\n+\t\t}\n \t\treturn l[n-1] == ctxt.GOOS\n \t}\n \tif n >= 1 && knownArch[l[n-1]] {"}, {"sha": "a40def0fa0ec575073a3dd1741e978a82765fdd7", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -85,6 +85,20 @@ func TestEmptyImport(t *testing.T) {\n \t}\n }\n \n+func TestEmptyFolderImport(t *testing.T) {\n+\t_, err := Import(\".\", \"testdata/empty\", 0)\n+\tif _, ok := err.(*NoGoError); !ok {\n+\t\tt.Fatal(`Import(\"testdata/empty\") did not return NoGoError.`)\n+\t}\n+}\n+\n+func TestMultiplePackageImport(t *testing.T) {\n+\t_, err := Import(\".\", \"testdata/multi\", 0)\n+\tif _, ok := err.(*MultiplePackageError); !ok {\n+\t\tt.Fatal(`Import(\"testdata/multi\") did not return MultiplePackageError.`)\n+\t}\n+}\n+\n func TestLocalDirectory(t *testing.T) {\n \tcwd, err := os.Getwd()\n \tif err != nil {\n@@ -153,22 +167,36 @@ func (r readNopCloser) Close() error {\n \treturn nil\n }\n \n+var (\n+\tctxtP9      = Context{GOARCH: \"arm\", GOOS: \"plan9\"}\n+\tctxtAndroid = Context{GOARCH: \"arm\", GOOS: \"android\"}\n+)\n+\n var matchFileTests = []struct {\n+\tctxt  Context\n \tname  string\n \tdata  string\n \tmatch bool\n }{\n-\t{\"foo_arm.go\", \"\", true},\n-\t{\"foo1_arm.go\", \"// +build linux\\n\\npackage main\\n\", false},\n-\t{\"foo_darwin.go\", \"\", false},\n-\t{\"foo.go\", \"\", true},\n-\t{\"foo1.go\", \"// +build linux\\n\\npackage main\\n\", false},\n-\t{\"foo.badsuffix\", \"\", false},\n+\t{ctxtP9, \"foo_arm.go\", \"\", true},\n+\t{ctxtP9, \"foo1_arm.go\", \"// +build linux\\n\\npackage main\\n\", false},\n+\t{ctxtP9, \"foo_darwin.go\", \"\", false},\n+\t{ctxtP9, \"foo.go\", \"\", true},\n+\t{ctxtP9, \"foo1.go\", \"// +build linux\\n\\npackage main\\n\", false},\n+\t{ctxtP9, \"foo.badsuffix\", \"\", false},\n+\t{ctxtAndroid, \"foo_linux.go\", \"\", true},\n+\t{ctxtAndroid, \"foo_android.go\", \"\", true},\n+\t{ctxtAndroid, \"foo_plan9.go\", \"\", false},\n+\t{ctxtAndroid, \"android.go\", \"\", true},\n+\t{ctxtAndroid, \"plan9.go\", \"\", true},\n+\t{ctxtAndroid, \"plan9_test.go\", \"\", true},\n+\t{ctxtAndroid, \"arm.s\", \"\", true},\n+\t{ctxtAndroid, \"amd64.s\", \"\", true},\n }\n \n func TestMatchFile(t *testing.T) {\n \tfor _, tt := range matchFileTests {\n-\t\tctxt := Context{GOARCH: \"arm\", GOOS: \"plan9\"}\n+\t\tctxt := tt.ctxt\n \t\tctxt.OpenFile = func(path string) (r io.ReadCloser, err error) {\n \t\t\tif path != \"x+\"+tt.name {\n \t\t\t\tt.Fatalf(\"OpenFile asked for %q, expected %q\", path, \"x+\"+tt.name)\n@@ -184,3 +212,13 @@ func TestMatchFile(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestImportCmd(t *testing.T) {\n+\tp, err := Import(\"cmd/internal/objfile\", \"\", 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !strings.HasSuffix(filepath.ToSlash(p.Dir), \"src/cmd/internal/objfile\") {\n+\t\tt.Fatalf(\"Import cmd/internal/objfile returned Dir=%q, want %q\", filepath.ToSlash(p.Dir), \".../src/cmd/internal/objfile\")\n+\t}\n+}"}, {"sha": "a335effec3a7e3fc41a40bfb5804edae5a275adc", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -279,12 +279,12 @@ var pkgDeps = map[string][]string{\n \t// Random byte, number generation.\n \t// This would be part of core crypto except that it imports\n \t// math/big, which imports fmt.\n-\t\"crypto/rand\": {\"L4\", \"CRYPTO\", \"OS\", \"math/big\", \"syscall\"},\n+\t\"crypto/rand\": {\"L4\", \"CRYPTO\", \"OS\", \"math/big\", \"syscall\", \"internal/syscall\"},\n \n \t// Mathematical crypto: dependencies on fmt (L4) and math/big.\n \t// We could avoid some of the fmt, but math/big imports fmt anyway.\n \t\"crypto/dsa\":      {\"L4\", \"CRYPTO\", \"math/big\"},\n-\t\"crypto/ecdsa\":    {\"L4\", \"CRYPTO\", \"crypto/elliptic\", \"math/big\"},\n+\t\"crypto/ecdsa\":    {\"L4\", \"CRYPTO\", \"crypto/elliptic\", \"math/big\", \"encoding/asn1\"},\n \t\"crypto/elliptic\": {\"L4\", \"CRYPTO\", \"math/big\"},\n \t\"crypto/rsa\":      {\"L4\", \"CRYPTO\", \"crypto/rand\", \"math/big\"},\n \n@@ -318,16 +318,17 @@ var pkgDeps = map[string][]string{\n \t\"net/http\": {\n \t\t\"L4\", \"NET\", \"OS\",\n \t\t\"compress/gzip\", \"crypto/tls\", \"mime/multipart\", \"runtime/debug\",\n+\t\t\"net/http/internal\",\n \t},\n \n \t// HTTP-using packages.\n \t\"expvar\":            {\"L4\", \"OS\", \"encoding/json\", \"net/http\"},\n \t\"net/http/cgi\":      {\"L4\", \"NET\", \"OS\", \"crypto/tls\", \"net/http\", \"regexp\"},\n \t\"net/http/fcgi\":     {\"L4\", \"NET\", \"OS\", \"net/http\", \"net/http/cgi\"},\n \t\"net/http/httptest\": {\"L4\", \"NET\", \"OS\", \"crypto/tls\", \"flag\", \"net/http\"},\n-\t\"net/http/httputil\": {\"L4\", \"NET\", \"OS\", \"net/http\"},\n+\t\"net/http/httputil\": {\"L4\", \"NET\", \"OS\", \"net/http\", \"net/http/internal\"},\n \t\"net/http/pprof\":    {\"L4\", \"OS\", \"html/template\", \"net/http\", \"runtime/pprof\"},\n-\t\"net/rpc\":           {\"L4\", \"NET\", \"encoding/gob\", \"net/http\", \"text/template\"},\n+\t\"net/rpc\":           {\"L4\", \"NET\", \"encoding/gob\", \"html/template\", \"net/http\"},\n \t\"net/rpc/jsonrpc\":   {\"L4\", \"NET\", \"encoding/json\", \"net/rpc\"},\n }\n \n@@ -360,7 +361,7 @@ func allowed(pkg string) map[string]bool {\n }\n \n var bools = []bool{false, true}\n-var geese = []string{\"darwin\", \"dragonfly\", \"freebsd\", \"linux\", \"nacl\", \"netbsd\", \"openbsd\", \"plan9\", \"solaris\", \"windows\"}\n+var geese = []string{\"android\", \"darwin\", \"dragonfly\", \"freebsd\", \"linux\", \"nacl\", \"netbsd\", \"openbsd\", \"plan9\", \"solaris\", \"windows\"}\n var goarches = []string{\"386\", \"amd64\", \"arm\", \"arm64\"}\n \n type osPkg struct {"}, {"sha": "75a827bb91fecf15fb8c9c148d4c714aa4c618b0", "filename": "libgo/go/go/build/doc.go", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -100,19 +100,18 @@\n //\t- \"go1.1\", from Go version 1.1 onward\n //\t- \"go1.2\", from Go version 1.2 onward\n //\t- \"go1.3\", from Go version 1.3 onward\n+//\t- \"go1.4\", from Go version 1.4 onward\n //\t- any additional words listed in ctxt.BuildTags\n //\n // If a file's name, after stripping the extension and a possible _test suffix,\n // matches any of the following patterns:\n //\t*_GOOS\n // \t*_GOARCH\n // \t*_GOOS_GOARCH\n-// (example: source_windows_amd64.go) or the literals:\n-//\tGOOS\n-// \tGOARCH\n-// (example: windows.go) where GOOS and GOARCH represent any known operating\n-// system and architecture values respectively, then the file is considered to\n-// have an implicit build constraint requiring those terms.\n+// (example: source_windows_amd64.go) where GOOS and GOARCH represent\n+// any known operating system and architecture values respectively, then\n+// the file is considered to have an implicit build constraint requiring\n+// those terms.\n //\n // To keep a file from being considered for the build:\n //\n@@ -134,4 +133,7 @@\n // building the package for Windows; similarly, math_386.s will be included\n // only when building the package for 32-bit x86.\n //\n+// Using GOOS=android matches build tags and files as for GOOS=linux\n+// in addition to android tags and files.\n+//\n package build"}, {"sha": "0bf4b1573c9b7198e0f8844184aa0eb3ceabde09", "filename": "libgo/go/go/build/syslist.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -4,5 +4,5 @@\n \n package build\n \n-const goosList = \"darwin dragonfly freebsd linux nacl netbsd openbsd plan9 solaris windows \"\n+const goosList = \"android darwin dragonfly freebsd linux nacl netbsd openbsd plan9 solaris windows \"\n const goarchList = \"386 amd64 amd64p32 arm arm64 alpha m68k mipso32 mipsn32 mipsn64 mipso64 ppc ppc64 ppc64le s390 s390x sparc sparc64 \""}, {"sha": "ee946eb2a2d74ba136a1dc1abc4f530ebb5e0a1d", "filename": "libgo/go/go/build/testdata/multi/file.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fmulti%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fmulti%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fmulti%2Ffile.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,5 @@\n+// Test data - not compiled.\n+\n+package main\n+\n+func main() {}"}, {"sha": "4ea31e7031ebd051007af48fcbd557f9bb9eb8bc", "filename": "libgo/go/go/build/testdata/multi/file_appengine.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fmulti%2Ffile_appengine.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fmulti%2Ffile_appengine.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fmulti%2Ffile_appengine.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,5 @@\n+// Test data - not compiled.\n+\n+package test_package\n+\n+func init() {}"}, {"sha": "1d3b466d8c7bb6d767913f04ec8843470ab3713b", "filename": "libgo/go/go/doc/exports.go", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -6,15 +6,19 @@\n \n package doc\n \n-import \"go/ast\"\n+import (\n+\t\"go/ast\"\n+\t\"go/token\"\n+)\n \n // filterIdentList removes unexported names from list in place\n-// and returns the resulting list.\n+// and returns the resulting list. If blankOk is set, blank\n+// identifiers are considered exported names.\n //\n-func filterIdentList(list []*ast.Ident) []*ast.Ident {\n+func filterIdentList(list []*ast.Ident, blankOk bool) []*ast.Ident {\n \tj := 0\n \tfor _, x := range list {\n-\t\tif ast.IsExported(x.Name) {\n+\t\tif ast.IsExported(x.Name) || (blankOk && x.Name == \"_\") {\n \t\t\tlist[j] = x\n \t\t\tj++\n \t\t}\n@@ -74,7 +78,7 @@ func (r *reader) filterFieldList(parent *namedType, fields *ast.FieldList, ityp\n \t\t\t\tr.remember(ityp)\n \t\t\t}\n \t\t} else {\n-\t\t\tfield.Names = filterIdentList(field.Names)\n+\t\t\tfield.Names = filterIdentList(field.Names, false)\n \t\t\tif len(field.Names) < n {\n \t\t\t\tremovedFields = true\n \t\t\t}\n@@ -136,13 +140,15 @@ func (r *reader) filterType(parent *namedType, typ ast.Expr) {\n \t}\n }\n \n-func (r *reader) filterSpec(spec ast.Spec) bool {\n+func (r *reader) filterSpec(spec ast.Spec, tok token.Token) bool {\n \tswitch s := spec.(type) {\n \tcase *ast.ImportSpec:\n \t\t// always keep imports so we can collect them\n \t\treturn true\n \tcase *ast.ValueSpec:\n-\t\ts.Names = filterIdentList(s.Names)\n+\t\t// special case: consider blank constants as exported\n+\t\t// (work-around for issue 5397)\n+\t\ts.Names = filterIdentList(s.Names, tok == token.CONST)\n \t\tif len(s.Names) > 0 {\n \t\t\tr.filterType(nil, s.Type)\n \t\t\treturn true\n@@ -159,10 +165,10 @@ func (r *reader) filterSpec(spec ast.Spec) bool {\n \treturn false\n }\n \n-func (r *reader) filterSpecList(list []ast.Spec) []ast.Spec {\n+func (r *reader) filterSpecList(list []ast.Spec, tok token.Token) []ast.Spec {\n \tj := 0\n \tfor _, s := range list {\n-\t\tif r.filterSpec(s) {\n+\t\tif r.filterSpec(s, tok) {\n \t\t\tlist[j] = s\n \t\t\tj++\n \t\t}\n@@ -173,7 +179,7 @@ func (r *reader) filterSpecList(list []ast.Spec) []ast.Spec {\n func (r *reader) filterDecl(decl ast.Decl) bool {\n \tswitch d := decl.(type) {\n \tcase *ast.GenDecl:\n-\t\td.Specs = r.filterSpecList(d.Specs)\n+\t\td.Specs = r.filterSpecList(d.Specs, d.Tok)\n \t\treturn len(d.Specs) > 0\n \tcase *ast.FuncDecl:\n \t\t// ok to filter these methods early because any"}, {"sha": "1ccaa158194534c0fb0078d04d07410805967f97", "filename": "libgo/go/go/doc/headscan.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -24,6 +24,7 @@ import (\n \t\"go/token\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"regexp\"\n \t\"runtime\"\n \t\"strings\"\n )\n@@ -33,10 +34,10 @@ var (\n \tverbose = flag.Bool(\"v\", false, \"verbose mode\")\n )\n \n-const (\n-\thtml_h    = \"<h3>\"\n-\thtml_endh = \"</h3>\\n\"\n-)\n+// ToHTML in comment.go assigns a (possibly blank) ID to each heading\n+var html_h = regexp.MustCompile(`<h3 id=\"[^\"]*\">`)\n+\n+const html_endh = \"</h3>\\n\"\n \n func isGoFile(fi os.FileInfo) bool {\n \treturn strings.HasSuffix(fi.Name(), \".go\") &&\n@@ -47,11 +48,11 @@ func appendHeadings(list []string, comment string) []string {\n \tvar buf bytes.Buffer\n \tdoc.ToHTML(&buf, comment, nil)\n \tfor s := buf.String(); ; {\n-\t\ti := strings.Index(s, html_h)\n-\t\tif i < 0 {\n+\t\tloc := html_h.FindStringIndex(s)\n+\t\tif len(loc) == 0 {\n \t\t\tbreak\n \t\t}\n-\t\ti += len(html_h)\n+\t\ti := loc[1]\n \t\tj := strings.Index(s, html_endh)\n \t\tif j < 0 {\n \t\t\tlist = append(list, s[i:]) // incorrect HTML"}, {"sha": "dae3ab2affa0e99fc628a46d55fae2ce31eba769", "filename": "libgo/go/go/doc/testdata/blank.0.golden", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.0.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,37 @@\n+// Package blank is a go/doc test for the handling of _. See issue ...\n+PACKAGE blank\n+\n+IMPORTPATH\n+\ttestdata/blank\n+\n+FILENAMES\n+\ttestdata/blank.go\n+\n+CONSTANTS\n+\t// Package constants. \n+\tconst (\n+\t\t_\tint\t= iota\n+\t\tI1\n+\t\tI2\n+\t)\n+\n+\n+TYPES\n+\t// S has a padding field. \n+\ttype S struct {\n+\t\tH\tuint32\n+\t\n+\t\tA\tuint8\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// \n+\ttype T int\n+\n+\t// T constants. \n+\tconst (\n+\t\t_\tT\t= iota\n+\t\tT1\n+\t\tT2\n+\t)\n+"}, {"sha": "333d7e5b040baac8bed9c65467c0b6905f19470f", "filename": "libgo/go/go/doc/testdata/blank.1.golden", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.1.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,46 @@\n+// Package blank is a go/doc test for the handling of _. See issue ...\n+PACKAGE blank\n+\n+IMPORTPATH\n+\ttestdata/blank\n+\n+FILENAMES\n+\ttestdata/blank.go\n+\n+CONSTANTS\n+\t// Package constants. \n+\tconst (\n+\t\t_\tint\t= iota\n+\t\tI1\n+\t\tI2\n+\t)\n+\n+\n+VARIABLES\n+\t// \n+\tvar _ = T(55)\n+\n+\n+FUNCTIONS\n+\t// \n+\tfunc _()\n+\n+\n+TYPES\n+\t// S has a padding field. \n+\ttype S struct {\n+\t\tH\tuint32\n+\t\t_\tuint8\n+\t\tA\tuint8\n+\t}\n+\n+\t// \n+\ttype T int\n+\n+\t// T constants. \n+\tconst (\n+\t\t_\tT\t= iota\n+\t\tT1\n+\t\tT2\n+\t)\n+"}, {"sha": "dae3ab2affa0e99fc628a46d55fae2ce31eba769", "filename": "libgo/go/go/doc/testdata/blank.2.golden", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.2.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,37 @@\n+// Package blank is a go/doc test for the handling of _. See issue ...\n+PACKAGE blank\n+\n+IMPORTPATH\n+\ttestdata/blank\n+\n+FILENAMES\n+\ttestdata/blank.go\n+\n+CONSTANTS\n+\t// Package constants. \n+\tconst (\n+\t\t_\tint\t= iota\n+\t\tI1\n+\t\tI2\n+\t)\n+\n+\n+TYPES\n+\t// S has a padding field. \n+\ttype S struct {\n+\t\tH\tuint32\n+\t\n+\t\tA\tuint8\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// \n+\ttype T int\n+\n+\t// T constants. \n+\tconst (\n+\t\t_\tT\t= iota\n+\t\tT1\n+\t\tT2\n+\t)\n+"}, {"sha": "f812c77b777d1714029444d81e2c6d973032e3b3", "filename": "libgo/go/go/doc/testdata/blank.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fblank.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package blank is a go/doc test for the handling of _.\n+// See issue 5397.\n+package blank\n+\n+type T int\n+\n+// T constants.\n+const (\n+\t_ T = iota\n+\tT1\n+\tT2\n+)\n+\n+// Package constants.\n+const (\n+\t_ int = iota\n+\tI1\n+\tI2\n+)\n+\n+// Blanks not in doc output:\n+\n+// S has a padding field.\n+type S struct {\n+\tH uint32\n+\t_ uint8\n+\tA uint8\n+}\n+\n+func _() {}\n+\n+type _ T\n+\n+var _ = T(55)"}, {"sha": "668a42df2df80da0e6c923c2be100e940ea6d2a2", "filename": "libgo/go/go/format/format.go", "status": "modified", "additions": 144, "deletions": 77, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -18,6 +18,8 @@ import (\n \n var config = printer.Config{Mode: printer.UseSpaces | printer.TabIndent, Tabwidth: 8}\n \n+const parserMode = parser.ParseComments\n+\n // Node formats node in canonical gofmt style and writes the result to dst.\n //\n // The node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n@@ -52,7 +54,7 @@ func Node(dst io.Writer, fset *token.FileSet, node interface{}) error {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tfile, err = parser.ParseFile(fset, \"\", buf.Bytes(), parser.ParseComments)\n+\t\tfile, err = parser.ParseFile(fset, \"\", buf.Bytes(), parserMode)\n \t\tif err != nil {\n \t\t\t// We should never get here. If we do, provide good diagnostic.\n \t\t\treturn fmt.Errorf(\"format.Node internal error (%s)\", err)\n@@ -80,66 +82,18 @@ func Node(dst io.Writer, fset *token.FileSet, node interface{}) error {\n //\n func Source(src []byte) ([]byte, error) {\n \tfset := token.NewFileSet()\n-\tnode, err := parse(fset, src)\n+\tfile, sourceAdj, indentAdj, err := parse(fset, \"\", src, true)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar buf bytes.Buffer\n-\tif file, ok := node.(*ast.File); ok {\n+\tif sourceAdj == nil {\n \t\t// Complete source file.\n+\t\t// TODO(gri) consider doing this always.\n \t\tast.SortImports(fset, file)\n-\t\terr := config.Fprint(&buf, fset, file)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t} else {\n-\t\t// Partial source file.\n-\t\t// Determine and prepend leading space.\n-\t\ti, j := 0, 0\n-\t\tfor j < len(src) && isSpace(src[j]) {\n-\t\t\tif src[j] == '\\n' {\n-\t\t\t\ti = j + 1 // index of last line in leading space\n-\t\t\t}\n-\t\t\tj++\n-\t\t}\n-\t\tbuf.Write(src[:i])\n-\n-\t\t// Determine indentation of first code line.\n-\t\t// Spaces are ignored unless there are no tabs,\n-\t\t// in which case spaces count as one tab.\n-\t\tindent := 0\n-\t\thasSpace := false\n-\t\tfor _, b := range src[i:j] {\n-\t\t\tswitch b {\n-\t\t\tcase ' ':\n-\t\t\t\thasSpace = true\n-\t\t\tcase '\\t':\n-\t\t\t\tindent++\n-\t\t\t}\n-\t\t}\n-\t\tif indent == 0 && hasSpace {\n-\t\t\tindent = 1\n-\t\t}\n-\n-\t\t// Format the source.\n-\t\tcfg := config\n-\t\tcfg.Indent = indent\n-\t\terr := cfg.Fprint(&buf, fset, node)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\t// Determine and append trailing space.\n-\t\ti = len(src)\n-\t\tfor i > 0 && isSpace(src[i-1]) {\n-\t\t\ti--\n-\t\t}\n-\t\tbuf.Write(src[i:])\n \t}\n \n-\treturn buf.Bytes(), nil\n+\treturn format(fset, file, sourceAdj, indentAdj, src, config)\n }\n \n func hasUnsortedImports(file *ast.File) bool {\n@@ -160,40 +114,153 @@ func hasUnsortedImports(file *ast.File) bool {\n \treturn false\n }\n \n-func isSpace(b byte) bool {\n-\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n-}\n+// ----------------------------------------------------------------------------\n+// Support functions\n+//\n+// The functions parse, format, and isSpace below are identical to the\n+// respective functions in cmd/gofmt/gofmt.go - keep them in sync!\n+//\n+// TODO(gri) Factor out this functionality, eventually.\n \n-func parse(fset *token.FileSet, src []byte) (interface{}, error) {\n-\t// Try as a complete source file.\n-\tfile, err := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n-\tif err == nil {\n-\t\treturn file, nil\n-\t}\n-\t// If the source is missing a package clause, try as a source fragment; otherwise fail.\n-\tif !strings.Contains(err.Error(), \"expected 'package'\") {\n-\t\treturn nil, err\n+// parse parses src, which was read from the named file,\n+// as a Go source file, declaration, or statement list.\n+func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (\n+\tfile *ast.File,\n+\tsourceAdj func(src []byte, indent int) []byte,\n+\tindentAdj int,\n+\terr error,\n+) {\n+\t// Try as whole source file.\n+\tfile, err = parser.ParseFile(fset, filename, src, parserMode)\n+\t// If there's no error, return.  If the error is that the source file didn't begin with a\n+\t// package line and source fragments are ok, fall through to\n+\t// try as a source fragment.  Stop and return on any other error.\n+\tif err == nil || !fragmentOk || !strings.Contains(err.Error(), \"expected 'package'\") {\n+\t\treturn\n \t}\n \n-\t// Try as a declaration list by prepending a package clause in front of src.\n-\t// Use ';' not '\\n' to keep line numbers intact.\n+\t// If this is a declaration list, make it a source file\n+\t// by inserting a package clause.\n+\t// Insert using a ;, not a newline, so that the line numbers\n+\t// in psrc match the ones in src.\n \tpsrc := append([]byte(\"package p;\"), src...)\n-\tfile, err = parser.ParseFile(fset, \"\", psrc, parser.ParseComments)\n+\tfile, err = parser.ParseFile(fset, filename, psrc, parserMode)\n \tif err == nil {\n-\t\treturn file.Decls, nil\n+\t\tsourceAdj = func(src []byte, indent int) []byte {\n+\t\t\t// Remove the package clause.\n+\t\t\t// Gofmt has turned the ; into a \\n.\n+\t\t\tsrc = src[indent+len(\"package p\\n\"):]\n+\t\t\treturn bytes.TrimSpace(src)\n+\t\t}\n+\t\treturn\n \t}\n-\t// If the source is missing a declaration, try as a statement list; otherwise fail.\n+\t// If the error is that the source file didn't begin with a\n+\t// declaration, fall through to try as a statement list.\n+\t// Stop and return on any other error.\n \tif !strings.Contains(err.Error(), \"expected declaration\") {\n-\t\treturn nil, err\n+\t\treturn\n \t}\n \n-\t// Try as statement list by wrapping a function around src.\n-\tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '}')\n-\tfile, err = parser.ParseFile(fset, \"\", fsrc, parser.ParseComments)\n+\t// If this is a statement list, make it a source file\n+\t// by inserting a package clause and turning the list\n+\t// into a function body.  This handles expressions too.\n+\t// Insert using a ;, not a newline, so that the line numbers\n+\t// in fsrc match the ones in src.\n+\tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '\\n', '}')\n+\tfile, err = parser.ParseFile(fset, filename, fsrc, parserMode)\n \tif err == nil {\n-\t\treturn file.Decls[0].(*ast.FuncDecl).Body.List, nil\n+\t\tsourceAdj = func(src []byte, indent int) []byte {\n+\t\t\t// Cap adjusted indent to zero.\n+\t\t\tif indent < 0 {\n+\t\t\t\tindent = 0\n+\t\t\t}\n+\t\t\t// Remove the wrapping.\n+\t\t\t// Gofmt has turned the ; into a \\n\\n.\n+\t\t\t// There will be two non-blank lines with indent, hence 2*indent.\n+\t\t\tsrc = src[2*indent+len(\"package p\\n\\nfunc _() {\"):]\n+\t\t\tsrc = src[:len(src)-(indent+len(\"\\n}\\n\"))]\n+\t\t\treturn bytes.TrimSpace(src)\n+\t\t}\n+\t\t// Gofmt has also indented the function body one level.\n+\t\t// Adjust that with indentAdj.\n+\t\tindentAdj = -1\n+\t}\n+\n+\t// Succeeded, or out of options.\n+\treturn\n+}\n+\n+// format formats the given package file originally obtained from src\n+// and adjusts the result based on the original source via sourceAdj\n+// and indentAdj.\n+func format(\n+\tfset *token.FileSet,\n+\tfile *ast.File,\n+\tsourceAdj func(src []byte, indent int) []byte,\n+\tindentAdj int,\n+\tsrc []byte,\n+\tcfg printer.Config,\n+) ([]byte, error) {\n+\tif sourceAdj == nil {\n+\t\t// Complete source file.\n+\t\tvar buf bytes.Buffer\n+\t\terr := cfg.Fprint(&buf, fset, file)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn buf.Bytes(), nil\n+\t}\n+\n+\t// Partial source file.\n+\t// Determine and prepend leading space.\n+\ti, j := 0, 0\n+\tfor j < len(src) && isSpace(src[j]) {\n+\t\tif src[j] == '\\n' {\n+\t\t\ti = j + 1 // byte offset of last line in leading space\n+\t\t}\n+\t\tj++\n+\t}\n+\tvar res []byte\n+\tres = append(res, src[:i]...)\n+\n+\t// Determine and prepend indentation of first code line.\n+\t// Spaces are ignored unless there are no tabs,\n+\t// in which case spaces count as one tab.\n+\tindent := 0\n+\thasSpace := false\n+\tfor _, b := range src[i:j] {\n+\t\tswitch b {\n+\t\tcase ' ':\n+\t\t\thasSpace = true\n+\t\tcase '\\t':\n+\t\t\tindent++\n+\t\t}\n+\t}\n+\tif indent == 0 && hasSpace {\n+\t\tindent = 1\n+\t}\n+\tfor i := 0; i < indent; i++ {\n+\t\tres = append(res, '\\t')\n+\t}\n+\n+\t// Format the source.\n+\t// Write it without any leading and trailing space.\n+\tcfg.Indent = indent + indentAdj\n+\tvar buf bytes.Buffer\n+\terr := cfg.Fprint(&buf, fset, file)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n+\tres = append(res, sourceAdj(buf.Bytes(), cfg.Indent)...)\n \n-\t// Failed, and out of options.\n-\treturn nil, err\n+\t// Determine and append trailing space.\n+\ti = len(src)\n+\tfor i > 0 && isSpace(src[i-1]) {\n+\t\ti--\n+\t}\n+\treturn append(res, src[i:]...), nil\n+}\n+\n+func isSpace(b byte) bool {\n+\treturn b == ' ' || b == '\\t' || b == '\\n' || b == '\\r'\n }"}, {"sha": "d7846bec6523269a9b6ec8022dc3271d14bf3b0c", "filename": "libgo/go/go/format/format_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fformat%2Fformat_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -87,7 +87,11 @@ var tests = []string{\n \t\"\\tx := 0\\n\\tgo f()\\n\\n\\n\",\n \t\"\\n\\t\\t\\n\\n\\tx := 0\\n\\tgo f()\\n\\n\\n\",\n \t\"\\n\\t\\t\\n\\n\\t\\t\\tx := 0\\n\\t\\t\\tgo f()\\n\\n\\n\",\n-\t\"\\n\\t\\t\\n\\n\\t\\t\\tx := 0\\n\\t\\t\\tconst s = `\\nfoo\\n`\\n\\n\\n\", // no indentation inside raw strings\n+\t\"\\n\\t\\t\\n\\n\\t\\t\\tx := 0\\n\\t\\t\\tconst s = `\\nfoo\\n`\\n\\n\\n\",     // no indentation added inside raw strings\n+\t\"\\n\\t\\t\\n\\n\\t\\t\\tx := 0\\n\\t\\t\\tconst s = `\\n\\t\\tfoo\\n`\\n\\n\\n\", // no indentation removed inside raw strings\n+\n+\t// comments\n+\t\"i := 5 /* Comment */\", // Issue 5551.\n \n \t// erroneous programs\n \t\"ERROR1 + 2 +\","}, {"sha": "48fb53e5b0d80951f0a431b2e9d81bb93c1a0526", "filename": "libgo/go/go/parser/error_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -34,7 +34,7 @@ import (\n \n const testdata = \"testdata\"\n \n-var fsetErrs *token.FileSet\n+var fsetErrs = token.NewFileSet()\n \n // getFile assumes that each filename occurs at most once\n func getFile(filename string) (file *token.File) {\n@@ -169,7 +169,6 @@ func checkErrors(t *testing.T, filename string, input interface{}) {\n }\n \n func TestErrors(t *testing.T) {\n-\tfsetErrs = token.NewFileSet()\n \tlist, err := ioutil.ReadDir(testdata)\n \tif err != nil {\n \t\tt.Fatal(err)"}, {"sha": "49103058b59785e04872f279cebe5a8dd946fd00", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -184,7 +184,7 @@ func ParseExpr(x string) (ast.Expr, error) {\n \n \t// If a semicolon was inserted, consume it;\n \t// report an error if there's more tokens.\n-\tif p.tok == token.SEMICOLON {\n+\tif p.tok == token.SEMICOLON && p.lit == \"\\n\" {\n \t\tp.next()\n \t}\n \tp.expect(token.EOF)"}, {"sha": "4a005d8ffa3892a88c597ad7de13903d5620a5ba", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 28, "deletions": 44, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -641,6 +641,7 @@ func (p *parser) parseArrayType() ast.Expr {\n \t}\n \n \tlbrack := p.expect(token.LBRACK)\n+\tp.exprLev++\n \tvar len ast.Expr\n \t// always permit ellipsis for more fault-tolerant parsing\n \tif p.tok == token.ELLIPSIS {\n@@ -649,6 +650,7 @@ func (p *parser) parseArrayType() ast.Expr {\n \t} else if p.tok != token.RBRACK {\n \t\tlen = p.parseRhs()\n \t}\n+\tp.exprLev--\n \tp.expect(token.RBRACK)\n \telt := p.parseType()\n \n@@ -823,9 +825,10 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \t\t// parameter or result variable is the function body.\n \t\tp.declare(field, nil, scope, ast.Var, idents...)\n \t\tp.resolve(typ)\n-\t\tif p.tok == token.COMMA {\n-\t\t\tp.next()\n+\t\tif !p.atComma(\"parameter list\") {\n+\t\t\treturn\n \t\t}\n+\t\tp.next()\n \t\tfor p.tok != token.RPAREN && p.tok != token.EOF {\n \t\t\tidents := p.parseIdentList()\n \t\t\ttyp := p.parseVarType(ellipsisOk)\n@@ -840,15 +843,15 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \t\t\t}\n \t\t\tp.next()\n \t\t}\n-\t} else {\n-\t\t// Type { \",\" Type } (anonymous parameters)\n-\t\tparams = make([]*ast.Field, len(list))\n-\t\tfor i, typ := range list {\n-\t\t\tp.resolve(typ)\n-\t\t\tparams[i] = &ast.Field{Type: typ}\n-\t\t}\n+\t\treturn\n \t}\n \n+\t// Type { \",\" Type } (anonymous parameters)\n+\tparams = make([]*ast.Field, len(list))\n+\tfor i, typ := range list {\n+\t\tp.resolve(typ)\n+\t\tparams[i] = &ast.Field{Type: typ}\n+\t}\n \treturn\n }\n \n@@ -2041,7 +2044,16 @@ func (p *parser) parseForStmt() ast.Stmt {\n \t\tprevLev := p.exprLev\n \t\tp.exprLev = -1\n \t\tif p.tok != token.SEMICOLON {\n-\t\t\ts2, isRange = p.parseSimpleStmt(rangeOk)\n+\t\t\tif p.tok == token.RANGE {\n+\t\t\t\t// \"for range x\" (nil lhs in assignment)\n+\t\t\t\tpos := p.pos\n+\t\t\t\tp.next()\n+\t\t\t\ty := []ast.Expr{&ast.UnaryExpr{OpPos: pos, Op: token.RANGE, X: p.parseRhs()}}\n+\t\t\t\ts2 = &ast.AssignStmt{Rhs: y}\n+\t\t\t\tisRange = true\n+\t\t\t} else {\n+\t\t\t\ts2, isRange = p.parseSimpleStmt(rangeOk)\n+\t\t\t}\n \t\t}\n \t\tif !isRange && p.tok == token.SEMICOLON {\n \t\t\tp.next()\n@@ -2066,12 +2078,14 @@ func (p *parser) parseForStmt() ast.Stmt {\n \t\t// check lhs\n \t\tvar key, value ast.Expr\n \t\tswitch len(as.Lhs) {\n-\t\tcase 2:\n-\t\t\tkey, value = as.Lhs[0], as.Lhs[1]\n+\t\tcase 0:\n+\t\t\t// nothing to do\n \t\tcase 1:\n \t\t\tkey = as.Lhs[0]\n+\t\tcase 2:\n+\t\t\tkey, value = as.Lhs[0], as.Lhs[1]\n \t\tdefault:\n-\t\t\tp.errorExpected(as.Lhs[0].Pos(), \"1 or 2 expressions\")\n+\t\t\tp.errorExpected(as.Lhs[len(as.Lhs)-1].Pos(), \"at most 2 expressions\")\n \t\t\treturn &ast.BadStmt{From: pos, To: p.safePos(body.End())}\n \t\t}\n \t\t// parseSimpleStmt returned a right-hand side that\n@@ -2296,36 +2310,6 @@ func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.Gen\n \t}\n }\n \n-func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n-\tif p.trace {\n-\t\tdefer un(trace(p, \"Receiver\"))\n-\t}\n-\n-\tpar := p.parseParameters(scope, false)\n-\n-\t// must have exactly one receiver\n-\tif par.NumFields() != 1 {\n-\t\tp.errorExpected(par.Opening, \"exactly one receiver\")\n-\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{From: par.Opening, To: par.Closing + 1}}}\n-\t\treturn par\n-\t}\n-\n-\t// recv type must be of the form [\"*\"] identifier\n-\trecv := par.List[0]\n-\tbase := deref(recv.Type)\n-\tif _, isIdent := base.(*ast.Ident); !isIdent {\n-\t\tif _, isBad := base.(*ast.BadExpr); !isBad {\n-\t\t\t// only report error if it's a new one\n-\t\t\tp.errorExpected(base.Pos(), \"(unqualified) identifier\")\n-\t\t}\n-\t\tpar.List = []*ast.Field{\n-\t\t\t{Type: &ast.BadExpr{From: recv.Pos(), To: p.safePos(recv.End())}},\n-\t\t}\n-\t}\n-\n-\treturn par\n-}\n-\n func (p *parser) parseFuncDecl() *ast.FuncDecl {\n \tif p.trace {\n \t\tdefer un(trace(p, \"FunctionDecl\"))\n@@ -2337,7 +2321,7 @@ func (p *parser) parseFuncDecl() *ast.FuncDecl {\n \n \tvar recv *ast.FieldList\n \tif p.tok == token.LPAREN {\n-\t\trecv = p.parseReceiver(scope)\n+\t\trecv = p.parseParameters(scope, false)\n \t}\n \n \tident := p.parseIdent()"}, {"sha": "85065fd1829c995be20f647f03d7bb80f86dc070", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -74,36 +74,54 @@ func TestParseExpr(t *testing.T) {\n \tsrc := \"a + b\"\n \tx, err := ParseExpr(src)\n \tif err != nil {\n-\t\tt.Fatalf(\"ParseExpr(%s): %v\", src, err)\n+\t\tt.Errorf(\"ParseExpr(%q): %v\", src, err)\n \t}\n \t// sanity check\n \tif _, ok := x.(*ast.BinaryExpr); !ok {\n-\t\tt.Errorf(\"ParseExpr(%s): got %T, want *ast.BinaryExpr\", src, x)\n+\t\tt.Errorf(\"ParseExpr(%q): got %T, want *ast.BinaryExpr\", src, x)\n \t}\n \n \t// a valid type expression\n \tsrc = \"struct{x *int}\"\n \tx, err = ParseExpr(src)\n \tif err != nil {\n-\t\tt.Fatalf(\"ParseExpr(%s): %v\", src, err)\n+\t\tt.Errorf(\"ParseExpr(%q): %v\", src, err)\n \t}\n \t// sanity check\n \tif _, ok := x.(*ast.StructType); !ok {\n-\t\tt.Errorf(\"ParseExpr(%s): got %T, want *ast.StructType\", src, x)\n+\t\tt.Errorf(\"ParseExpr(%q): got %T, want *ast.StructType\", src, x)\n \t}\n \n \t// an invalid expression\n \tsrc = \"a + *\"\n-\t_, err = ParseExpr(src)\n-\tif err == nil {\n-\t\tt.Fatalf(\"ParseExpr(%s): got no error\", src)\n+\tif _, err := ParseExpr(src); err == nil {\n+\t\tt.Errorf(\"ParseExpr(%q): got no error\", src)\n \t}\n \n \t// a valid expression followed by extra tokens is invalid\n \tsrc = \"a[i] := x\"\n-\t_, err = ParseExpr(src)\n-\tif err == nil {\n-\t\tt.Fatalf(\"ParseExpr(%s): got no error\", src)\n+\tif _, err := ParseExpr(src); err == nil {\n+\t\tt.Errorf(\"ParseExpr(%q): got no error\", src)\n+\t}\n+\n+\t// a semicolon is not permitted unless automatically inserted\n+\tsrc = \"a + b\\n\"\n+\tif _, err := ParseExpr(src); err != nil {\n+\t\tt.Errorf(\"ParseExpr(%q): got error %s\", src, err)\n+\t}\n+\tsrc = \"a + b;\"\n+\tif _, err := ParseExpr(src); err == nil {\n+\t\tt.Errorf(\"ParseExpr(%q): got no error\", src)\n+\t}\n+\n+\t// various other stuff following a valid expression\n+\tconst validExpr = \"a + b\"\n+\tconst anything = \"dh3*#D)#_\"\n+\tfor _, c := range \"!)]};,\" {\n+\t\tsrc := validExpr + string(c) + anything\n+\t\tif _, err := ParseExpr(src); err == nil {\n+\t\t\tt.Errorf(\"ParseExpr(%q): got no error\", src)\n+\t\t}\n \t}\n \n \t// ParseExpr must not crash"}, {"sha": "05e44de28a72dbee1f93dcfe3a730c663ff5df48", "filename": "libgo/go/go/parser/short_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -35,6 +35,11 @@ var valids = []string{\n \t`package p; func f() { for _ = range \"foo\" + \"bar\" {} };`,\n \t`package p; func f() { var s []int; g(s[:], s[i:], s[:j], s[i:j], s[i:j:k], s[:j:k]) };`,\n \t`package p; var ( _ = (struct {*T}).m; _ = (interface {T}).m )`,\n+\t`package p; func ((T),) m() {}`,\n+\t`package p; func ((*T),) m() {}`,\n+\t`package p; func (*(T),) m() {}`,\n+\t`package p; func _(x []int) { for range x {} }`,\n+\t`package p; func _() { if [T{}.n]int{} {} }`,\n }\n \n func TestValid(t *testing.T) {\n@@ -89,6 +94,7 @@ var invalids = []string{\n \t`package p; func f() { go f /* ERROR HERE \"function must be invoked\" */ }`,\n \t`package p; func f() { defer func() {} /* ERROR HERE \"function must be invoked\" */ }`,\n \t`package p; func f() { go func() { func() { f(x func /* ERROR \"expected '\\)'\" */ (){}) } } }`,\n+\t`package p; func f() (a b string /* ERROR \"expected '\\)'\" */ , ok bool) // issue 8656`,\n }\n \n func TestInvalid(t *testing.T) {"}, {"sha": "d5a69349beba8bdcf72ea914e8ed2a74a84ad983", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -163,8 +163,8 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \tsize := 0\n \n \t// print all list elements\n+\tprevLine := prev.Line\n \tfor i, x := range list {\n-\t\tprevLine := line\n \t\tline = p.lineFor(x.Pos())\n \n \t\t// determine if the next linebreak, if any, needs to use formfeed:\n@@ -207,8 +207,8 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\t\t}\n \t\t}\n \n+\t\tneedsLinebreak := 0 < prevLine && prevLine < line\n \t\tif i > 0 {\n-\t\t\tneedsLinebreak := prevLine < line && prevLine > 0 && line > 0\n \t\t\t// use position of expression following the comma as\n \t\t\t// comma position for correct comment placement, but\n \t\t\t// only if the expression is on the same line\n@@ -232,16 +232,20 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\t\t}\n \t\t}\n \n-\t\tif isPair && size > 0 && len(list) > 1 {\n-\t\t\t// we have a key:value expression that fits onto one line and\n-\t\t\t// is in a list with more then one entry: use a column for the\n-\t\t\t// key such that consecutive entries can align if possible\n+\t\tif len(list) > 1 && isPair && size > 0 && needsLinebreak {\n+\t\t\t// we have a key:value expression that fits onto one line\n+\t\t\t// and it's not on the same line as the prior expression:\n+\t\t\t// use a column for the key such that consecutive entries\n+\t\t\t// can align if possible\n+\t\t\t// (needsLinebreak is set if we started a new line before)\n \t\t\tp.expr(pair.Key)\n \t\t\tp.print(pair.Colon, token.COLON, vtab)\n \t\t\tp.expr(pair.Value)\n \t\t} else {\n \t\t\tp.expr0(x, depth)\n \t\t}\n+\n+\t\tprevLine = line\n \t}\n \n \tif mode&commaTerm != 0 && next.IsValid() && p.pos.Line < next.Line {\n@@ -732,7 +736,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int) {\n \t\tif _, hasParens := x.X.(*ast.ParenExpr); hasParens {\n \t\t\t// don't print parentheses around an already parenthesized expression\n \t\t\t// TODO(gri) consider making this more general and incorporate precedence levels\n-\t\t\tp.expr0(x.X, reduceDepth(depth)) // parentheses undo one level of depth\n+\t\t\tp.expr0(x.X, depth)\n \t\t} else {\n \t\t\tp.print(token.LPAREN)\n \t\t\tp.expr0(x.X, reduceDepth(depth)) // parentheses undo one level of depth\n@@ -1216,14 +1220,17 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool) {\n \n \tcase *ast.RangeStmt:\n \t\tp.print(token.FOR, blank)\n-\t\tp.expr(s.Key)\n-\t\tif s.Value != nil {\n-\t\t\t// use position of value following the comma as\n-\t\t\t// comma position for correct comment placement\n-\t\t\tp.print(s.Value.Pos(), token.COMMA, blank)\n-\t\t\tp.expr(s.Value)\n-\t\t}\n-\t\tp.print(blank, s.TokPos, s.Tok, blank, token.RANGE, blank)\n+\t\tif s.Key != nil {\n+\t\t\tp.expr(s.Key)\n+\t\t\tif s.Value != nil {\n+\t\t\t\t// use position of value following the comma as\n+\t\t\t\t// comma position for correct comment placement\n+\t\t\t\tp.print(s.Value.Pos(), token.COMMA, blank)\n+\t\t\t\tp.expr(s.Value)\n+\t\t\t}\n+\t\t\tp.print(blank, s.TokPos, s.Tok, blank)\n+\t\t}\n+\t\tp.print(token.RANGE, blank)\n \t\tp.expr(stripParens(s.X))\n \t\tp.print(blank)\n \t\tp.block(s.Body, 1)"}, {"sha": "3b0570e5b502a76f4301bf0985e5a35ae7cb61c3", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -159,23 +159,16 @@ func runcheck(t *testing.T, source, golden string, mode checkMode) {\n }\n \n func check(t *testing.T, source, golden string, mode checkMode) {\n-\t// start a timer to produce a time-out signal\n-\ttc := make(chan int)\n-\tgo func() {\n-\t\ttime.Sleep(10 * time.Second) // plenty of a safety margin, even for very slow machines\n-\t\ttc <- 0\n-\t}()\n-\n \t// run the test\n \tcc := make(chan int)\n \tgo func() {\n \t\truncheck(t, source, golden, mode)\n \t\tcc <- 0\n \t}()\n \n-\t// wait for the first finisher\n+\t// wait with timeout\n \tselect {\n-\tcase <-tc:\n+\tcase <-time.After(10 * time.Second): // plenty of a safety margin, even for very slow machines\n \t\t// test running past time out\n \t\tt.Errorf(\"%s: running too slowly\", source)\n \tcase <-cc:\n@@ -357,7 +350,7 @@ func idents(f *ast.File) <-chan *ast.Ident {\n // identCount returns the number of identifiers found in f.\n func identCount(f *ast.File) int {\n \tn := 0\n-\tfor _ = range idents(f) {\n+\tfor range idents(f) {\n \t\tn++\n \t}\n \treturn n"}, {"sha": "9acd41b7d288626f124ef7028dea85800ac7a12c", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -593,7 +593,7 @@ var (\n )\n \n func _() {\n-\tvar privateKey2 = &Block{Type:\t\"RSA PRIVATE KEY\",\n+\tvar privateKey2 = &Block{Type: \"RSA PRIVATE KEY\",\n \t\tHeaders:\tmap[string]string{},\n \t\tBytes: []uint8{0x30, 0x82, 0x1, 0x3a, 0x2, 0x1, 0x0, 0x2,\n \t\t\t0x41, 0x0, 0xb2, 0x99, 0xf, 0x49, 0xc4, 0x7d, 0xfa, 0x8c,\n@@ -698,6 +698,29 @@ var _ = T4{\n \tc:\tz,\n }\n \n+// no alignment of map composite entries if they are not the first entry on a line\n+var _ = T{0: 0}\t// not aligned\n+var _ = T{0: 0,\t// not aligned\n+\t1:\t1,\t\t\t\t// aligned\n+\t22:\t22,\t\t\t\t// aligned\n+\t333:\t333, 1234: 12, 12345: 0,\t// first on line aligned\n+}\n+\n+// test cases form issue 8685\n+// not aligned\n+var _ = map[int]string{1: \"spring\", 2: \"summer\",\n+\t3:\t\"autumn\", 4: \"winter\"}\n+\n+// not aligned\n+var _ = map[string]string{\"a\": \"spring\", \"b\": \"summer\",\n+\t\"c\":\t\"autumn\", \"d\": \"winter\"}\n+\n+// aligned\n+var _ = map[string]string{\"a\": \"spring\",\n+\t\"b\":\t\"summer\",\n+\t\"c\":\t\"autumn\",\n+\t\"d\":\t\"winter\"}\n+\n func _() {\n \tvar _ = T{\n \t\ta,\t// must introduce trailing comma"}, {"sha": "45beec25fc7ff4f182d16e6bf9e3ef58497be2c6", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -715,6 +715,31 @@ var _ = T4{\n }\n \n \n+// no alignment of map composite entries if they are not the first entry on a line\n+var _ = T{0: 0} // not aligned\n+var _ = T{0: 0, // not aligned\n+\t1: 1, // aligned\n+\t22: 22, // aligned\n+\t333: 333, 1234: 12, 12345: 0, // first on line aligned\n+}\n+\n+\n+// test cases form issue 8685\n+// not aligned\n+var _ = map[int]string{1: \"spring\", 2: \"summer\",\n+\t\t\t\t\t3:             \"autumn\", 4: \"winter\"}\n+\n+// not aligned\n+var _ = map[string]string{\"a\": \"spring\", \"b\": \"summer\",\n+\t\"c\": \"autumn\", \"d\": \"winter\"}\n+\n+// aligned\n+var _ = map[string]string{\"a\": \"spring\",\n+\"b\": \"summer\",\n+\t\"c\": \"autumn\",\n+\"d\": \"winter\"}\n+\n+\n func _() {\n \tvar _ = T{\n \t\ta,\t// must introduce trailing comma"}, {"sha": "e3d17a4653f4bc20f567ba78d022512ab197dbb4", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -94,6 +94,11 @@ func _() {\n \t_ = Open(dpath+\"/file\", O_WRONLY|O_CREAT, 0666)\n \t_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)\n \n+\t// test case for issue 8021\n+\t// want:\n+\t//  ([]bool{})[([]int{})[((1)+(((1)+((((1)*(((1)+(1))+(1)))+(1))*(1)))+(1)))]]\n+\t_ = ([]bool{})[([]int{})[((1)+(((1)+((((1)*(((1)+(1))+(1)))+(1))*(1)))+(1)))]]\n+\n \t// the parser does not restrict expressions that may appear as statements\n \ttrue\n \t42"}, {"sha": "d20a59350ed6db32f125ef9df9d93eeb6d28993d", "filename": "libgo/go/go/printer/testdata/expressions.input", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -95,6 +95,11 @@ func _() {\n \t_ = Open(dpath + \"/file\", O_WRONLY | O_CREAT, 0666)\n \t_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)\n \n+\t// test case for issue 8021\n+\t// want:\n+\t//  ([]bool{})[([]int{})[((1)+(((1)+((((1)*(((1)+(1))+(1)))+(1))*(1)))+(1)))]]\n+\t_ = ([]bool{})[([]int{})[((1) + (((((1) + (((((((1) * (((((1) + (1))) + (1))))) + (1))) * (1))))) + (1))))]]\n+\n \t// the parser does not restrict expressions that may appear as statements\n \ttrue\n \t42"}, {"sha": "2357336957fe0c04905acdc1285d02b1dc192fbd", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -94,6 +94,11 @@ func _() {\n \t_ = Open(dpath+\"/file\", O_WRONLY|O_CREAT, 0666)\n \t_ = int(c0&_Mask4)<<18 | int(c1&_Maskx)<<12 | int(c2&_Maskx)<<6 | int(c3&_Maskx)\n \n+\t// test case for issue 8021\n+\t// want:\n+\t//  ([]bool{})[([]int{})[((1)+(((1)+((((1)*(((1)+(1))+(1)))+(1))*(1)))+(1)))]]\n+\t_ = ([]bool{})[([]int{})[((1)+(((1)+((((1)*(((1)+(1))+(1)))+(1))*(1)))+(1)))]]\n+\n \t// the parser does not restrict expressions that may appear as statements\n \ttrue\n \t42"}, {"sha": "4b13460473553fb269a568595296d457104427f7", "filename": "libgo/go/go/printer/testdata/statements.golden", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -309,6 +309,9 @@ func _() {\n \tfor x := expr; expr; expr = false {\n \t\tuse(x)\n \t}\n+\tfor range []int{} {\n+\t\tprintln(\"foo\")\n+\t}\n \tfor x := range []int{} {\n \t\tuse(x)\n \t}\n@@ -338,6 +341,12 @@ func _() {\n \t\ta[i] = i\n \t}\t// multiple lines\n \n+\tfor range a {\n+\t}\n+\tfor _ = range a {\n+\t}\n+\tfor _, _ = range a {\n+\t}\n \tfor i := range a {\n \t}\n \tfor i := range a {\n@@ -435,7 +444,7 @@ func _() {\n \t}\n \tif x == a+b*(T{42}[0]) {\n \t}\n-\tif x == a+(b * (T{42}[0])) {\n+\tif x == a+(b*(T{42}[0])) {\n \t}\n \tif x == a+b*(T{42}[0]) {\n \t}"}, {"sha": "cade1576bf7845852c9b8e45eab0203ec6587e3e", "filename": "libgo/go/go/printer/testdata/statements.input", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b", "patch": "@@ -269,6 +269,8 @@ func _() {\n \tfor x := expr;expr;expr = false {\n \tuse(x)\n \t}\n+\tfor range []int{} {\n+\tprintln(\"foo\")}\n \tfor x := range []int{} {\n \tuse(x) }\n \tfor x := range (([]int{})) {\n@@ -289,6 +291,9 @@ func _() {\n \tfor i := 0; i < len(a); 1++ { a[i] = i\n \t} // multiple lines\n \n+\tfor range a{}\n+\tfor _ = range a{}\n+\tfor _, _ = range a{}\n \tfor i := range a {}\n \tfor i := range a { a[i] = i }\n \tfor i := range a { a[i] = i"}, {"sha": "82d90eeb7284fcaf24b3edfb0c28c33e14202bd7", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "d26939ce277e1c61a1e8f3e31a62f9b7acc9a2d0", "filename": "libgo/go/go/token/position_test.go", "status": "modified", "additions": 80, "deletions": 21, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "6a6b9473bea45b9db127a5c03eb0809f061e9147", "filename": "libgo/go/hash/crc32/crc32.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Fcrc32%2Fcrc32.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "8f99e1b96246e3290c6e9cdc4b08cac0ee7a0f23", "filename": "libgo/go/html/template/error.go", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ferror.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "ee01fb12ab83ba9dbbc6e7193235e1d9d37ae024", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "ef7b8774845e3fc5e6ba0103c85ec9af9f176ed5", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "7af7997de9b6c3dbf8c7016238370965d910c42b", "filename": "libgo/go/html/template/js_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "ce6170105cc3d346d2974b522c1d18346e64c2b5", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "b486fcd28544c05952064b3a011e0df18e3a2d32", "filename": "libgo/go/html/template/transition.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftransition.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "2b5fdaaf2b3b2a34da7ad20c39627f98ac3a90fa", "filename": "libgo/go/image/color/palette/gen.go", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgen.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "64c2ec0d9abb23f8dac59dbd2d3ec1c88e3829ee", "filename": "libgo/go/image/color/palette/generate.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fgenerate.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "0bf2c8e1aa565be9e3fb034fa545a7a633a1015d", "filename": "libgo/go/image/color/palette/palette.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fpalette.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fpalette.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fpalette%2Fpalette.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "5a863e204f3066b7fc232023ee2ad0450e1a3654", "filename": "libgo/go/image/gif/reader.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Freader.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "7b6f504367cf8e8983c80e69a0c0acf078bfa8c2", "filename": "libgo/go/image/gif/reader_test.go", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fgif%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fgif%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Freader_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "49abde704c86669af12714da0bc505d3ceae4492", "filename": "libgo/go/image/gif/writer.go", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fgif%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fgif%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Fwriter.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "93306ffdb34e3c3d34edc4fa91d98c5c4e88a2fe", "filename": "libgo/go/image/gif/writer_test.go", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fgif%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fgif%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Fwriter_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "6b8e5c4877e27b5fef3bab8d5bfb1c0da956a5cb", "filename": "libgo/go/image/image.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "d4ff4cfa0cefab9606b0ab23ce489068d8820caf", "filename": "libgo/go/image/jpeg/huffman.go", "status": "modified", "additions": 141, "deletions": 116, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fhuffman.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "6d8b1d1d036c84b57e53e937f780b8663d999fa3", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 180, "deletions": 30, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "4de2e8ee7371585bdd625a7bb03c094845623ff9", "filename": "libgo/go/image/jpeg/reader_test.go", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "2bd1d9d531d825f0cb33f0870e669d6b4f8522c1", "filename": "libgo/go/image/jpeg/scan.go", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fscan.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "91bbde3bf803e9be37056b481b4cda91bb1e8311", "filename": "libgo/go/image/jpeg/writer.go", "status": "modified", "additions": 97, "deletions": 36, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "3df3cfcc5bb8423e965807a068b6eeb8ec8b2d14", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "9ed6300c865470238eb82ed7efebf3ba5953a6ac", "filename": "libgo/go/image/png/paeth.go", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "cfc1896cd7f2478f8fdd1ec90a0b46d282657bf8", "filename": "libgo/go/image/png/paeth_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fpaeth_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "0a40ca161d99acebdaff8568a86bf3157544a1c2", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 170, "deletions": 49, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "ce772eb6f098e17b9b1cc2e71d47cfea713801ad", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "df23270ee975cdcb8b5b38b986a902a02a8b2f40", "filename": "libgo/go/image/png/writer.go", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "d67a815698fd0e75358b92b0257e88a45f0ee574", "filename": "libgo/go/image/png/writer_test.go", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "7c773f2f0a496049b763e60f3bb608c74a197312", "filename": "libgo/go/image/ycbcr.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fycbcr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fimage%2Fycbcr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "644f00c75771c6eb3d21ff9aa5c9b3009a28f845", "filename": "libgo/go/index/suffixarray/suffixarray_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "b00eb273f923e769c5ac6babb11bea04895b9245", "filename": "libgo/go/internal/syscall/dummy.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Finternal%2Fsyscall%2Fdummy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Finternal%2Fsyscall%2Fdummy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Fdummy.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "944bab3f5d44938f5ff718fcc5d86427756347cd", "filename": "libgo/go/internal/syscall/getrandom_linux.go", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Finternal%2Fsyscall%2Fgetrandom_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Finternal%2Fsyscall%2Fgetrandom_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Fgetrandom_linux.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "7507a84929f8ab950b7dba263e089cc5c0236b00", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "6a863fed3126062d4ece93e23888102e8c53486a", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "1cdabec69224f538e6bea78b885d119ccd75fd02", "filename": "libgo/go/log/syslog/syslog_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_unix.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "763efb2e647a4d032fd8052ccc83978320cf7f07", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 67, "deletions": 10, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "d22e39e7c94fa3591b61236eb433e4130bdf0d86", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}, {"sha": "6070cf325d206ed6ec508cf3805ac3dfac9c23c6", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9fa9e80b57f89e7877ce6cad8a3464879009b/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=f8d9fa9e80b57f89e7877ce6cad8a3464879009b"}]}