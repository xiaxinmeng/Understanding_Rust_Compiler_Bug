{"sha": "32a21096039a8a589a9dea3c977f9d18a37a39be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhMjEwOTYwMzlhOGE1ODlhOWRlYTNjOTc3ZjlkMThhMzdhMzliZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-10T14:39:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-10T14:39:14Z"}, "message": "[multiple changes]\n\n2014-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* errout.adb (Adjust_Name_Case): New procedure.\n\t(Set_Msg_Node): Use Adjust_Name_Case.\n\t* errout.ads (Adjust_Name_Case): New procedure.\n\t* exp_intr.adb (Add_Source_Info): Minor code reorganization\n\t(use Ekind_In).\n\t(Write_Entity_Name): Use Errout.Adjust_Name_Case.\n\t* sem_prag.adb (Is_Non_Significant_Pragma_Reference): Review\n\tand fix up entries in Sig_Flags, and correct logical errors in\n\tfunction itself.\n\t* sprint.adb (Sprint_Node_Actual): Properly print string for\n\traise statement.\n\n2014-10-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): For an object of an\n\tanonymous array type with delayed aspects, defer freezing of\n\ttype until object itself is frozen.\n\t* freeze.adb (Freeze_Entity): When freezing an object of an\n\tanonymous array type with delayed aspects, remove freeze node of\n\tobject after freezing type, to prevent out-of-order elaboration\n\tin the back-end. The initialization call for the object has\n\talready been constructed when expanding the object declaration.\n\nFrom-SVN: r216089", "tree": {"sha": "a7a0ba9c28357303479235bbe2ff1134de286392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7a0ba9c28357303479235bbe2ff1134de286392"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32a21096039a8a589a9dea3c977f9d18a37a39be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a21096039a8a589a9dea3c977f9d18a37a39be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32a21096039a8a589a9dea3c977f9d18a37a39be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a21096039a8a589a9dea3c977f9d18a37a39be/comments", "author": null, "committer": null, "parents": [{"sha": "8f8194710d4d0badd94046d26cbe61cee1a01163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f8194710d4d0badd94046d26cbe61cee1a01163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f8194710d4d0badd94046d26cbe61cee1a01163"}], "stats": {"total": 571, "additions": 350, "deletions": 221}, "files": [{"sha": "6de6c99a669289fedb3110b1b05c0af5fb7abac7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=32a21096039a8a589a9dea3c977f9d18a37a39be", "patch": "@@ -1,3 +1,28 @@\n+2014-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* errout.adb (Adjust_Name_Case): New procedure.\n+\t(Set_Msg_Node): Use Adjust_Name_Case.\n+\t* errout.ads (Adjust_Name_Case): New procedure.\n+\t* exp_intr.adb (Add_Source_Info): Minor code reorganization\n+\t(use Ekind_In).\n+\t(Write_Entity_Name): Use Errout.Adjust_Name_Case.\n+\t* sem_prag.adb (Is_Non_Significant_Pragma_Reference): Review\n+\tand fix up entries in Sig_Flags, and correct logical errors in\n+\tfunction itself.\n+\t* sprint.adb (Sprint_Node_Actual): Properly print string for\n+\traise statement.\n+\n+2014-10-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): For an object of an\n+\tanonymous array type with delayed aspects, defer freezing of\n+\ttype until object itself is frozen.\n+\t* freeze.adb (Freeze_Entity): When freezing an object of an\n+\tanonymous array type with delayed aspects, remove freeze node of\n+\tobject after freezing type, to prevent out-of-order elaboration\n+\tin the back-end. The initialization call for the object has\n+\talready been constructed when expanding the object declaration.\n+\n 2014-10-10  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_intr.adb (Write_Entity_Name): Moved to outer level"}, {"sha": "e540b41a3dda2f398396b976ce742fbfa6a29362", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 69, "deletions": 57, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=32a21096039a8a589a9dea3c977f9d18a37a39be", "patch": "@@ -2318,6 +2318,67 @@ package body Errout is\n       end if;\n    end Remove_Warning_Messages;\n \n+   ----------------------\n+   -- Adjust_Name_Case --\n+   ----------------------\n+\n+   procedure Adjust_Name_Case (Loc : Source_Ptr) is\n+   begin\n+      --  We have an all lower case name from Namet, and now we want to set\n+      --  the appropriate case. If possible we copy the actual casing from\n+      --  the source. If not we use standard identifier casing.\n+\n+      declare\n+         Src_Ind : constant Source_File_Index := Get_Source_File_Index (Loc);\n+         Sbuffer : Source_Buffer_Ptr;\n+         Ref_Ptr : Integer;\n+         Src_Ptr : Source_Ptr;\n+\n+      begin\n+         Ref_Ptr := 1;\n+         Src_Ptr := Loc;\n+\n+         --  For standard locations, always use mixed case\n+\n+         if Loc <= No_Location then\n+            Set_Casing (Mixed_Case);\n+\n+         else\n+            --  Determine if the reference we are dealing with corresponds to\n+            --  text at the point of the error reference. This will often be\n+            --  the case for simple identifier references, and is the case\n+            --  where we can copy the casing from the source.\n+\n+            Sbuffer := Source_Text (Src_Ind);\n+\n+            while Ref_Ptr <= Name_Len loop\n+               exit when\n+                 Fold_Lower (Sbuffer (Src_Ptr)) /=\n+                   Fold_Lower (Name_Buffer (Ref_Ptr));\n+               Ref_Ptr := Ref_Ptr + 1;\n+               Src_Ptr := Src_Ptr + 1;\n+            end loop;\n+\n+            --  If we get through the loop without a mismatch, then output the\n+            --  name the way it is cased in the source program\n+\n+            if Ref_Ptr > Name_Len then\n+               Src_Ptr := Loc;\n+\n+               for J in 1 .. Name_Len loop\n+                  Name_Buffer (J) := Sbuffer (Src_Ptr);\n+                  Src_Ptr := Src_Ptr + 1;\n+               end loop;\n+\n+            --  Otherwise set the casing using the default identifier casing\n+\n+            else\n+               Set_Casing (Identifier_Casing (Src_Ind), Mixed_Case);\n+            end if;\n+         end if;\n+      end;\n+   end Adjust_Name_Case;\n+\n    ---------------------------\n    -- Set_Identifier_Casing --\n    ---------------------------\n@@ -2660,6 +2721,7 @@ package body Errout is\n    ------------------\n \n    procedure Set_Msg_Node (Node : Node_Id) is\n+      Loc : Source_Ptr;\n       Ent : Entity_Id;\n       Nam : Name_Id;\n \n@@ -2692,6 +2754,7 @@ package body Errout is\n \n       if Nkind (Node) = N_Pragma then\n          Nam := Pragma_Name (Node);\n+         Loc := Sloc (Node);\n \n       --  The other cases have Chars fields, and we want to test for possible\n       --  internal names, which generally represent something gone wrong. An\n@@ -2712,6 +2775,8 @@ package body Errout is\n             Ent := Node;\n          end if;\n \n+         Loc := Sloc (Ent);\n+\n          --  If the type is the designated type of an access_to_subprogram,\n          --  then there is no name to provide in the call.\n \n@@ -2729,14 +2794,15 @@ package body Errout is\n \n       else\n          Nam := Chars (Node);\n+         Loc := Sloc (Node);\n       end if;\n \n       --  At this stage, the name to output is in Nam\n \n       Get_Unqualified_Decoded_Name_String (Nam);\n \n       --  Remove trailing upper case letters from the name (useful for\n-      --  dealing with some cases of internal names.\n+      --  dealing with some cases of internal names).\n \n       while Name_Len > 1 and then Name_Buffer (Name_Len) in 'A' .. 'Z' loop\n          Name_Len := Name_Len  - 1;\n@@ -2752,63 +2818,9 @@ package body Errout is\n          Kill_Message := True;\n       end if;\n \n-      --  Now we have to set the proper case. If we have a source location\n-      --  then do a check to see if the name in the source is the same name\n-      --  as the name in the Names table, except for possible differences\n-      --  in case, which is the case when we can copy from the source.\n-\n-      declare\n-         Src_Loc : constant Source_Ptr := Sloc (Node);\n-         Sbuffer : Source_Buffer_Ptr;\n-         Ref_Ptr : Integer;\n-         Src_Ptr : Source_Ptr;\n-\n-      begin\n-         Ref_Ptr := 1;\n-         Src_Ptr := Src_Loc;\n-\n-         --  For standard locations, always use mixed case\n-\n-         if Src_Loc <= No_Location\n-           or else Sloc (Node) <= No_Location\n-         then\n-            Set_Casing (Mixed_Case);\n-\n-         else\n-            --  Determine if the reference we are dealing with corresponds to\n-            --  text at the point of the error reference. This will often be\n-            --  the case for simple identifier references, and is the case\n-            --  where we can copy the spelling from the source.\n-\n-            Sbuffer := Source_Text (Get_Source_File_Index (Src_Loc));\n-\n-            while Ref_Ptr <= Name_Len loop\n-               exit when\n-                 Fold_Lower (Sbuffer (Src_Ptr)) /=\n-                 Fold_Lower (Name_Buffer (Ref_Ptr));\n-               Ref_Ptr := Ref_Ptr + 1;\n-               Src_Ptr := Src_Ptr + 1;\n-            end loop;\n-\n-            --  If we get through the loop without a mismatch, then output the\n-            --  name the way it is spelled in the source program\n-\n-            if Ref_Ptr > Name_Len then\n-               Src_Ptr := Src_Loc;\n-\n-               for J in 1 .. Name_Len loop\n-                  Name_Buffer (J) := Sbuffer (Src_Ptr);\n-                  Src_Ptr := Src_Ptr + 1;\n-               end loop;\n-\n-            --  Otherwise set the casing using the default identifier casing\n-\n-            else\n-               Set_Casing (Identifier_Casing (Flag_Source), Mixed_Case);\n-            end if;\n-         end if;\n-      end;\n+      --  Remaining step is to adjust casing and possibly add 'Class\n \n+      Adjust_Name_Case (Loc);\n       Set_Msg_Name_Buffer;\n       Add_Class;\n    end Set_Msg_Node;"}, {"sha": "ef4a9cf682b3a8a9ebc49a68e346cd2f06cb749a", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=32a21096039a8a589a9dea3c977f9d18a37a39be", "patch": "@@ -879,17 +879,23 @@ package Errout is\n    --  Same as Error_Msg_NE, but the error is suppressed if SPARK_Mode is Off.\n    --  The routine is inlined because it acts as a simple wrapper.\n \n-   ------------------------------------\n-   -- Utility Interface for Back End --\n-   ------------------------------------\n+   ------------------------------------------\n+   -- Utility Interface for Casing Control --\n+   ------------------------------------------\n \n-   --  The following subprograms can be used by the back end for the purposes\n-   --  of concocting error messages that are not output via Errout, e.g. the\n-   --  messages generated by the gcc back end.\n+   procedure Adjust_Name_Case (Loc : Source_Ptr);\n+   --  Given a name stored in Name_Buffer (1 .. Name_Len), set proper casing.\n+   --  Loc is an associated source position, if we can find a match between\n+   --  the name in Name_Buffer and the name at that source location, we copy\n+   --  the casing from the source, otherwise we set appropriate default casing.\n \n    procedure Set_Identifier_Casing\n      (Identifier_Name : System.Address;\n       File_Name       : System.Address);\n+   --  This subprogram can be used by the back end for the purposes of\n+   --  concocting error messages that are not output via Errout, e.g.\n+   --  the messages generated by the gcc back end.\n+   --\n    --  The identifier is a null terminated string that represents the name of\n    --  an identifier appearing in the source program. File_Name is a null\n    --  terminated string giving the corresponding file name for the identifier"}, {"sha": "e8efe03348cb45baafddeb5d2a6bc75091269ec0", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 82, "deletions": 42, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=32a21096039a8a589a9dea3c977f9d18a37a39be", "patch": "@@ -27,6 +27,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n+with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Atag; use Exp_Atag;\n with Exp_Ch4;  use Exp_Ch4;\n@@ -156,8 +157,7 @@ package body Exp_Intr is\n \n             Ent := Current_Scope;\n             while Present (Ent) loop\n-               exit when Ekind (Ent) /= E_Block\n-                 and then Ekind (Ent) /= E_Loop;\n+               exit when not Ekind_In (Ent, E_Block, E_Loop);\n                Ent := Scope (Ent);\n             end loop;\n \n@@ -203,6 +203,7 @@ package body Exp_Intr is\n       Name_Buffer (Save_NL + 1 .. Save_NL + Name_Len) :=\n         Name_Buffer (1 .. Name_Len);\n       Name_Buffer (1 .. Save_NL) := Save_NB;\n+      Name_Len := Name_Len + Save_NL;\n    end Add_Source_Info;\n \n    ---------------------------------\n@@ -1401,65 +1402,104 @@ package body Exp_Intr is\n    -----------------------\n \n    procedure Write_Entity_Name (E : Entity_Id) is\n-      SDef : Source_Ptr;\n-      TDef : constant Source_Buffer_Ptr :=\n-               Source_Text (Get_Source_File_Index (Sloc (E)));\n \n-   begin\n-      --  Nothing to do if at outer level\n+      procedure Write_Entity_Name_Inner (E : Entity_Id);\n+      --  Inner recursive routine, keep outer routine non-recursive to ease\n+      --  debugging when we get strange results from this routine.\n \n-      if Scope (E) = Standard_Standard then\n-         null;\n+      -----------------------------\n+      -- Write_Entity_Name_Inner --\n+      -----------------------------\n+\n+      procedure Write_Entity_Name_Inner (E : Entity_Id) is\n+      begin\n+         --  If entity has an internal name, skip by it, and print its scope.\n+         --  Note that Is_Internal_Name destroys Name_Buffer, hence the save\n+         --  and restore since we depend on its current contents. Note that\n+         --  we strip a final R from the name before the test, this is needed\n+         --  for some cases of instantiations.\n+\n+         declare\n+            Save_NB : constant String  := Name_Buffer (1 .. Name_Len);\n+            Save_NL : constant Natural := Name_Len;\n+            Iname   : Boolean;\n+\n+         begin\n+            Get_Name_String (Chars (E));\n+\n+            if Name_Buffer (Name_Len) = 'R' then\n+               Name_Len := Name_Len - 1;\n+            end if;\n+\n+            Iname := Is_Internal_Name;\n+\n+            Name_Buffer (1 .. Save_NL) := Save_NB;\n+            Name_Len := Save_NL;\n+\n+            if Iname then\n+               Write_Entity_Name_Inner (Scope (E));\n+               return;\n+            end if;\n+         end;\n \n-         --  If scope comes from source, write its name\n+         --  Just print entity name if its scope is at the outer level\n+\n+         if Scope (E) = Standard_Standard then\n+            null;\n \n-      elsif Comes_From_Source (Scope (E)) then\n-         Write_Entity_Name (Scope (E));\n-         Add_Char_To_Name_Buffer ('.');\n+         --  If scope comes from source, write scope and entity\n+\n+         elsif Comes_From_Source (Scope (E)) then\n+            Write_Entity_Name (Scope (E));\n+            Add_Char_To_Name_Buffer ('.');\n \n          --  If in wrapper package skip past it\n \n-      elsif Is_Wrapper_Package (Scope (E)) then\n-         Write_Entity_Name (Scope (Scope (E)));\n-         Add_Char_To_Name_Buffer ('.');\n+         elsif Is_Wrapper_Package (Scope (E)) then\n+            Write_Entity_Name (Scope (Scope (E)));\n+            Add_Char_To_Name_Buffer ('.');\n \n          --  Otherwise nothing to output (happens in unnamed block statements)\n \n-      else\n-         null;\n-      end if;\n+         else\n+            null;\n+         end if;\n \n-      --  Output the name\n+         --  Output the name\n \n-      SDef := Sloc (E);\n+         declare\n+            Save_NB : constant String  := Name_Buffer (1 .. Name_Len);\n+            Save_NL : constant Natural := Name_Len;\n \n-      --  Check for operator name in quotes\n+         begin\n+            Get_Unqualified_Decoded_Name_String (Chars (E));\n \n-      if TDef (SDef) = '\"' then\n-         Add_Char_To_Name_Buffer ('\"');\n+            --  Remove trailing upper case letters from the name (useful for\n+            --  dealing with some cases of internal names generated in the case\n+            --  of references from within a generic.\n \n-         --  Loop to output characters of operator name and terminating quote\n+            while Name_Len > 1\n+              and then Name_Buffer (Name_Len) in 'A' .. 'Z'\n+            loop\n+               Name_Len := Name_Len  - 1;\n+            end loop;\n \n-         loop\n-            SDef := SDef + 1;\n-            Add_Char_To_Name_Buffer (TDef (SDef));\n-            exit when TDef (SDef) = '\"';\n-         end loop;\n+            --  Adjust casing appropriately (gets name from source if possible)\n \n-      --  Normal case of identifier\n+            Adjust_Name_Case (Sloc (E));\n \n-      else\n-         --  Loop to output the name\n+            --  Append to original entry value of Name_Buffer\n \n-         --  This is not right wrt wide char encodings ??? ()\n+            Name_Buffer (Save_NL + 1 ..  Save_NL + Name_Len) :=\n+              Name_Buffer (1 .. Name_Len);\n+            Name_Buffer (1 .. Save_NL) := Save_NB;\n+            Name_Len := Save_NL + Name_Len;\n+         end;\n+      end Write_Entity_Name_Inner;\n \n-         while TDef (SDef) in '0' .. '9'\n-           or else TDef (SDef) >= 'A'\n-           or else TDef (SDef) = ASCII.ESC\n-         loop\n-            Add_Char_To_Name_Buffer (TDef (SDef));\n-            SDef := SDef + 1;\n-         end loop;\n-      end if;\n+   --  Start of processing for Write_Entity_Name\n+\n+   begin\n+      Write_Entity_Name_Inner (E);\n    end Write_Entity_Name;\n end Exp_Intr;"}, {"sha": "7fdd2ab5289f030238bdc5ba680c67ed4e1aad75", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=32a21096039a8a589a9dea3c977f9d18a37a39be", "patch": "@@ -4415,6 +4415,23 @@ package body Freeze is\n               and then Ekind (E) /= E_Generic_Function\n             then\n                Freeze_And_Append (Etype (E), N, Result);\n+\n+               --  For an object of an anonymous array type, aspects on the\n+               --  object declaration apply to the type itself. This is the\n+               --  case for Atomic_Components, Volatile_Components, and\n+               --  Independent_Components. In these cases analysis of the\n+               --  generated pragma will mark the anonymous types accordingly,\n+               --  and the object itself does not require a freeze node.\n+\n+               if Ekind (E) = E_Variable\n+                 and then Is_Itype (Etype (E))\n+                 and then Is_Array_Type (Etype (E))\n+                 and then Has_Delayed_Aspects (E)\n+               then\n+                  Set_Has_Delayed_Aspects (E, False);\n+                  Set_Has_Delayed_Freeze (E, False);\n+                  Set_Freeze_Node (E, Empty);\n+               end if;\n             end if;\n \n             --  Special processing for objects created by object declaration"}, {"sha": "d1df888579c29492edf87a921380fce6d537e800", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=32a21096039a8a589a9dea3c977f9d18a37a39be", "patch": "@@ -3407,11 +3407,21 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-      --  If not a deferred constant, then object declaration freezes its type\n+      --  If not a deferred constant, then the object declaration freezes\n+      --  its type, unless the object is of an anonymous type and has delayed\n+      --  aspects. In that case the type is frozen when the object itself is.\n \n       else\n          Check_Fully_Declared (T, N);\n-         Freeze_Before (N, T);\n+\n+         if Has_Delayed_Aspects (Id)\n+           and then Is_Array_Type (T)\n+           and then Is_Itype (T)\n+         then\n+            Set_Has_Delayed_Freeze (T);\n+         else\n+            Freeze_Before (N, T);\n+         end if;\n       end if;\n \n       --  If the object was created by a constrained array definition, then"}, {"sha": "62d9a03e441977c447e8fe16ea95de515e4679c1", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 127, "deletions": 114, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=32a21096039a8a589a9dea3c977f9d18a37a39be", "patch": "@@ -24755,7 +24755,7 @@ package body Sem_Prag is\n    --  0   indicates that appearance in any argument is not significant\n    --  +n  indicates that appearance as argument n is significant, but all\n    --      other arguments are not significant\n-   --  99  special processing required (e.g. for pragma Check)\n+   --  9n  arguments from n on are significant, before n inisignificant\n \n    Sig_Flags : constant array (Pragma_Id) of Int :=\n      (Pragma_Abort_Defer                    => -1,\n@@ -24767,138 +24767,138 @@ package body Sem_Prag is\n       Pragma_Ada_12                         => -1,\n       Pragma_Ada_2012                       => -1,\n       Pragma_All_Calls_Remote               => -1,\n-      Pragma_Allow_Integer_Address          =>  0,\n-      Pragma_Annotate                       => -1,\n+      Pragma_Allow_Integer_Address          => -1,\n+      Pragma_Annotate                       => 93,\n       Pragma_Assert                         => -1,\n       Pragma_Assert_And_Cut                 => -1,\n       Pragma_Assertion_Policy               =>  0,\n       Pragma_Assume                         => -1,\n       Pragma_Assume_No_Invalid_Values       =>  0,\n       Pragma_Async_Readers                  =>  0,\n       Pragma_Async_Writers                  =>  0,\n-      Pragma_Asynchronous                   => -1,\n+      Pragma_Asynchronous                   =>  0,\n       Pragma_Atomic                         =>  0,\n       Pragma_Atomic_Components              =>  0,\n       Pragma_Attach_Handler                 => -1,\n-      Pragma_Attribute_Definition           => +3,\n-      Pragma_Check                          => 99,\n+      Pragma_Attribute_Definition           => 92,\n+      Pragma_Check                          => -1,\n       Pragma_Check_Float_Overflow           =>  0,\n       Pragma_Check_Name                     =>  0,\n       Pragma_Check_Policy                   =>  0,\n-      Pragma_CIL_Constructor                => -1,\n+      Pragma_CIL_Constructor                =>  0,\n       Pragma_CPP_Class                      =>  0,\n       Pragma_CPP_Constructor                =>  0,\n       Pragma_CPP_Virtual                    =>  0,\n       Pragma_CPP_Vtable                     =>  0,\n       Pragma_CPU                            => -1,\n       Pragma_C_Pass_By_Copy                 =>  0,\n-      Pragma_Comment                        =>  0,\n-      Pragma_Common_Object                  => -1,\n+      Pragma_Comment                        => -1,\n+      Pragma_Common_Object                  =>  0,\n       Pragma_Compile_Time_Error             => -1,\n       Pragma_Compile_Time_Warning           => -1,\n-      Pragma_Compiler_Unit                  =>  0,\n-      Pragma_Compiler_Unit_Warning          =>  0,\n+      Pragma_Compiler_Unit                  => -1,\n+      Pragma_Compiler_Unit_Warning          => -1,\n       Pragma_Complete_Representation        =>  0,\n       Pragma_Complex_Representation         =>  0,\n-      Pragma_Component_Alignment            => -1,\n+      Pragma_Component_Alignment            =>  0,\n       Pragma_Contract_Cases                 => -1,\n       Pragma_Controlled                     =>  0,\n       Pragma_Convention                     =>  0,\n       Pragma_Convention_Identifier          =>  0,\n       Pragma_Debug                          => -1,\n       Pragma_Debug_Policy                   =>  0,\n-      Pragma_Detect_Blocking                => -1,\n+      Pragma_Detect_Blocking                =>  0,\n       Pragma_Default_Initial_Condition      => -1,\n       Pragma_Default_Scalar_Storage_Order   =>  0,\n-      Pragma_Default_Storage_Pool           => -1,\n+      Pragma_Default_Storage_Pool           =>  0,\n       Pragma_Depends                        => -1,\n-      Pragma_Disable_Atomic_Synchronization => -1,\n+      Pragma_Disable_Atomic_Synchronization =>  0,\n       Pragma_Discard_Names                  =>  0,\n       Pragma_Dispatching_Domain             => -1,\n       Pragma_Effective_Reads                =>  0,\n       Pragma_Effective_Writes               =>  0,\n-      Pragma_Elaborate                      => -1,\n-      Pragma_Elaborate_All                  => -1,\n-      Pragma_Elaborate_Body                 => -1,\n-      Pragma_Elaboration_Checks             => -1,\n-      Pragma_Eliminate                      => -1,\n-      Pragma_Enable_Atomic_Synchronization  => -1,\n+      Pragma_Elaborate                      =>  0,\n+      Pragma_Elaborate_All                  =>  0,\n+      Pragma_Elaborate_Body                 =>  0,\n+      Pragma_Elaboration_Checks             =>  0,\n+      Pragma_Eliminate                      =>  0,\n+      Pragma_Enable_Atomic_Synchronization  =>  0,\n       Pragma_Export                         => -1,\n       Pragma_Export_Function                => -1,\n       Pragma_Export_Object                  => -1,\n       Pragma_Export_Procedure               => -1,\n       Pragma_Export_Value                   => -1,\n       Pragma_Export_Valued_Procedure        => -1,\n       Pragma_Extend_System                  => -1,\n-      Pragma_Extensions_Allowed             => -1,\n+      Pragma_Extensions_Allowed             =>  0,\n       Pragma_External                       => -1,\n-      Pragma_Favor_Top_Level                => -1,\n-      Pragma_External_Name_Casing           => -1,\n-      Pragma_Fast_Math                      => -1,\n+      Pragma_Favor_Top_Level                =>  0,\n+      Pragma_External_Name_Casing           =>  0,\n+      Pragma_Fast_Math                      =>  0,\n       Pragma_Finalize_Storage_Only          =>  0,\n       Pragma_Global                         => -1,\n       Pragma_Ident                          => -1,\n       Pragma_Implementation_Defined         => -1,\n       Pragma_Implemented                    => -1,\n       Pragma_Implicit_Packing               =>  0,\n-      Pragma_Import                         => +2,\n+      Pragma_Import                         => 93,\n       Pragma_Import_Function                =>  0,\n       Pragma_Import_Object                  =>  0,\n       Pragma_Import_Procedure               =>  0,\n       Pragma_Import_Valued_Procedure        =>  0,\n       Pragma_Independent                    =>  0,\n       Pragma_Independent_Components         =>  0,\n       Pragma_Initial_Condition              => -1,\n-      Pragma_Initialize_Scalars             => -1,\n+      Pragma_Initialize_Scalars             =>  0,\n       Pragma_Initializes                    => -1,\n       Pragma_Inline                         =>  0,\n       Pragma_Inline_Always                  =>  0,\n       Pragma_Inline_Generic                 =>  0,\n       Pragma_Inspection_Point               => -1,\n-      Pragma_Interface                      => +2,\n-      Pragma_Interface_Name                 => +2,\n+      Pragma_Interface                      => 92,\n+      Pragma_Interface_Name                 =>  0,\n       Pragma_Interrupt_Handler              => -1,\n       Pragma_Interrupt_Priority             => -1,\n       Pragma_Interrupt_State                => -1,\n       Pragma_Invariant                      => -1,\n       Pragma_Java_Constructor               => -1,\n       Pragma_Java_Interface                 => -1,\n       Pragma_Keep_Names                     =>  0,\n-      Pragma_License                        => -1,\n+      Pragma_License                        =>  0,\n       Pragma_Link_With                      => -1,\n       Pragma_Linker_Alias                   => -1,\n       Pragma_Linker_Constructor             => -1,\n       Pragma_Linker_Destructor              => -1,\n       Pragma_Linker_Options                 => -1,\n-      Pragma_Linker_Section                 => -1,\n-      Pragma_List                           => -1,\n-      Pragma_Lock_Free                      => -1,\n-      Pragma_Locking_Policy                 => -1,\n+      Pragma_Linker_Section                 =>  0,\n+      Pragma_List                           =>  0,\n+      Pragma_Lock_Free                      =>  0,\n+      Pragma_Locking_Policy                 =>  0,\n       Pragma_Loop_Invariant                 => -1,\n-      Pragma_Loop_Optimize                  => -1,\n+      Pragma_Loop_Optimize                  =>  0,\n       Pragma_Loop_Variant                   => -1,\n       Pragma_Machine_Attribute              => -1,\n       Pragma_Main                           => -1,\n       Pragma_Main_Storage                   => -1,\n-      Pragma_Memory_Size                    => -1,\n+      Pragma_Memory_Size                    =>  0,\n       Pragma_No_Return                      =>  0,\n       Pragma_No_Body                        =>  0,\n-      Pragma_No_Elaboration_Code_All        => -1,\n+      Pragma_No_Elaboration_Code_All        =>  0,\n       Pragma_No_Inline                      =>  0,\n       Pragma_No_Run_Time                    => -1,\n       Pragma_No_Strict_Aliasing             => -1,\n-      Pragma_Normalize_Scalars              => -1,\n+      Pragma_Normalize_Scalars              =>  0,\n       Pragma_Obsolescent                    =>  0,\n-      Pragma_Optimize                       => -1,\n-      Pragma_Optimize_Alignment             => -1,\n+      Pragma_Optimize                       =>  0,\n+      Pragma_Optimize_Alignment             =>  0,\n       Pragma_Overflow_Mode                  =>  0,\n       Pragma_Overriding_Renamings           =>  0,\n-      Pragma_Ordered                        => -1,\n+      Pragma_Ordered                        =>  0,\n       Pragma_Pack                           =>  0,\n-      Pragma_Page                           => -1,\n-      Pragma_Part_Of                        => -1,\n-      Pragma_Partition_Elaboration_Policy   => -1,\n-      Pragma_Passive                        => -1,\n+      Pragma_Page                           =>  0,\n+      Pragma_Part_Of                        =>  0,\n+      Pragma_Partition_Elaboration_Policy   =>  0,\n+      Pragma_Passive                        =>  0,\n       Pragma_Persistent_BSS                 =>  0,\n       Pragma_Polling                        =>  0,\n       Pragma_Prefix_Exception_Messages      =>  0,\n@@ -24909,89 +24909,118 @@ package body Sem_Prag is\n       Pragma_Precondition                   => -1,\n       Pragma_Predicate                      => -1,\n       Pragma_Preelaborable_Initialization   => -1,\n-      Pragma_Preelaborate                   => -1,\n+      Pragma_Preelaborate                   =>  0,\n       Pragma_Pre_Class                      => -1,\n       Pragma_Priority                       => -1,\n-      Pragma_Priority_Specific_Dispatching  => -1,\n+      Pragma_Priority_Specific_Dispatching  =>  0,\n       Pragma_Profile                        =>  0,\n       Pragma_Profile_Warnings               =>  0,\n-      Pragma_Propagate_Exceptions           => -1,\n-      Pragma_Provide_Shift_Operators        => -1,\n-      Pragma_Psect_Object                   => -1,\n-      Pragma_Pure                           => -1,\n-      Pragma_Pure_Function                  => -1,\n-      Pragma_Queuing_Policy                 => -1,\n-      Pragma_Rational                       => -1,\n-      Pragma_Ravenscar                      => -1,\n+      Pragma_Propagate_Exceptions           =>  0,\n+      Pragma_Provide_Shift_Operators        =>  0,\n+      Pragma_Psect_Object                   =>  0,\n+      Pragma_Pure                           =>  0,\n+      Pragma_Pure_Function                  =>  0,\n+      Pragma_Queuing_Policy                 =>  0,\n+      Pragma_Rational                       =>  0,\n+      Pragma_Ravenscar                      =>  0,\n       Pragma_Refined_Depends                => -1,\n       Pragma_Refined_Global                 => -1,\n       Pragma_Refined_Post                   => -1,\n       Pragma_Refined_State                  => -1,\n-      Pragma_Relative_Deadline              => -1,\n+      Pragma_Relative_Deadline              =>  0,\n       Pragma_Remote_Access_Type             => -1,\n       Pragma_Remote_Call_Interface          => -1,\n       Pragma_Remote_Types                   => -1,\n-      Pragma_Restricted_Run_Time            => -1,\n-      Pragma_Restriction_Warnings           => -1,\n-      Pragma_Restrictions                   => -1,\n+      Pragma_Restricted_Run_Time            =>  0,\n+      Pragma_Restriction_Warnings           =>  0,\n+      Pragma_Restrictions                   =>  0,\n       Pragma_Reviewable                     => -1,\n-      Pragma_Short_Circuit_And_Or           => -1,\n-      Pragma_Share_Generic                  => -1,\n-      Pragma_Shared                         => -1,\n-      Pragma_Shared_Passive                 => -1,\n+      Pragma_Short_Circuit_And_Or           =>  0,\n+      Pragma_Share_Generic                  =>  0,\n+      Pragma_Shared                         =>  0,\n+      Pragma_Shared_Passive                 =>  0,\n       Pragma_Short_Descriptors              =>  0,\n       Pragma_Simple_Storage_Pool_Type       =>  0,\n-      Pragma_Source_File_Name               => -1,\n-      Pragma_Source_File_Name_Project       => -1,\n-      Pragma_Source_Reference               => -1,\n+      Pragma_Source_File_Name               =>  0,\n+      Pragma_Source_File_Name_Project       =>  0,\n+      Pragma_Source_Reference               =>  0,\n       Pragma_SPARK_Mode                     =>  0,\n       Pragma_Storage_Size                   => -1,\n-      Pragma_Storage_Unit                   => -1,\n-      Pragma_Static_Elaboration_Desired     => -1,\n-      Pragma_Stream_Convert                 => -1,\n-      Pragma_Style_Checks                   => -1,\n-      Pragma_Subtitle                       => -1,\n+      Pragma_Storage_Unit                   =>  0,\n+      Pragma_Static_Elaboration_Desired     =>  0,\n+      Pragma_Stream_Convert                 =>  0,\n+      Pragma_Style_Checks                   =>  0,\n+      Pragma_Subtitle                       =>  0,\n       Pragma_Suppress                       =>  0,\n       Pragma_Suppress_Exception_Locations   =>  0,\n-      Pragma_Suppress_All                   => -1,\n+      Pragma_Suppress_All                   =>  0,\n       Pragma_Suppress_Debug_Info            =>  0,\n       Pragma_Suppress_Initialization        =>  0,\n-      Pragma_System_Name                    => -1,\n-      Pragma_Task_Dispatching_Policy        => -1,\n+      Pragma_System_Name                    =>  0,\n+      Pragma_Task_Dispatching_Policy        =>  0,\n       Pragma_Task_Info                      => -1,\n       Pragma_Task_Name                      => -1,\n-      Pragma_Task_Storage                   =>  0,\n+      Pragma_Task_Storage                   => -1,\n       Pragma_Test_Case                      => -1,\n-      Pragma_Thread_Local_Storage           =>  0,\n+      Pragma_Thread_Local_Storage           => -1,\n       Pragma_Time_Slice                     => -1,\n-      Pragma_Title                          => -1,\n+      Pragma_Title                          =>  0,\n       Pragma_Type_Invariant                 => -1,\n       Pragma_Type_Invariant_Class           => -1,\n       Pragma_Unchecked_Union                =>  0,\n-      Pragma_Unimplemented_Unit             => -1,\n-      Pragma_Universal_Aliasing             => -1,\n-      Pragma_Universal_Data                 => -1,\n-      Pragma_Unmodified                     => -1,\n-      Pragma_Unreferenced                   => -1,\n-      Pragma_Unreferenced_Objects           => -1,\n-      Pragma_Unreserve_All_Interrupts       => -1,\n+      Pragma_Unimplemented_Unit             =>  0,\n+      Pragma_Universal_Aliasing             =>  0,\n+      Pragma_Universal_Data                 =>  0,\n+      Pragma_Unmodified                     =>  0,\n+      Pragma_Unreferenced                   =>  0,\n+      Pragma_Unreferenced_Objects           =>  0,\n+      Pragma_Unreserve_All_Interrupts       =>  0,\n       Pragma_Unsuppress                     =>  0,\n       Pragma_Unevaluated_Use_Of_Old         =>  0,\n-      Pragma_Use_VADS_Size                  => -1,\n-      Pragma_Validity_Checks                => -1,\n+      Pragma_Use_VADS_Size                  =>  0,\n+      Pragma_Validity_Checks                =>  0,\n       Pragma_Volatile                       =>  0,\n       Pragma_Volatile_Components            =>  0,\n-      Pragma_Warning_As_Error               => -1,\n-      Pragma_Warnings                       => -1,\n-      Pragma_Weak_External                  => -1,\n+      Pragma_Warning_As_Error               =>  0,\n+      Pragma_Warnings                       =>  0,\n+      Pragma_Weak_External                  =>  0,\n       Pragma_Wide_Character_Encoding        =>  0,\n       Unknown_Pragma                        =>  0);\n \n    function Is_Non_Significant_Pragma_Reference (N : Node_Id) return Boolean is\n       Id : Pragma_Id;\n       P  : Node_Id;\n       C  : Int;\n-      A  : Node_Id;\n+      AN : Nat;\n+\n+      function Arg_No return Nat;\n+      --  Returns an integer showing what argument we are in. A value of\n+      --  zero means we are not in any of the arguments.\n+\n+      ------------\n+      -- Arg_No --\n+      ------------\n+\n+      function Arg_No return Nat is\n+         A : Node_Id;\n+         N : Nat;\n+\n+      begin\n+         A := First (Pragma_Argument_Associations (Parent (P)));\n+         N := 1;\n+         loop\n+            if No (A) then\n+               return 0;\n+            elsif A = P then\n+               return N;\n+            end if;\n+\n+            Next (A);\n+            N := N + 1;\n+         end loop;\n+      end Arg_No;\n+\n+   --  Start of processing for Non_Significant_Pragma_Reference\n \n    begin\n       P := Parent (N);\n@@ -25002,6 +25031,11 @@ package body Sem_Prag is\n       else\n          Id := Get_Pragma_Id (Parent (P));\n          C := Sig_Flags (Id);\n+         AN := Arg_No;\n+\n+         if AN = 0 then\n+            return False;\n+         end if;\n \n          case C is\n             when -1 =>\n@@ -25010,32 +25044,11 @@ package body Sem_Prag is\n             when 0 =>\n                return True;\n \n-            when 99 =>\n-               case Id is\n-\n-                  --  For pragma Check, the first argument is not significant,\n-                  --  the second and the third (if present) arguments are\n-                  --  significant.\n-\n-                  when Pragma_Check =>\n-                     return\n-                       P = First (Pragma_Argument_Associations (Parent (P)));\n-\n-                  when others =>\n-                     raise Program_Error;\n-               end case;\n+            when 92 .. 99 =>\n+               return AN < (C - 90);\n \n             when others =>\n-               A := First (Pragma_Argument_Associations (Parent (P)));\n-               for J in 1 .. C - 1 loop\n-                  if No (A) then\n-                     return False;\n-                  end if;\n-\n-                  Next (A);\n-               end loop;\n-\n-               return A = P; -- is this wrong way round ???\n+               return AN /= C;\n          end case;\n       end if;\n    end Is_Non_Significant_Pragma_Reference;"}, {"sha": "8f47053a29904a677686109483c5a0c790456934", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a21096039a8a589a9dea3c977f9d18a37a39be/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=32a21096039a8a589a9dea3c977f9d18a37a39be", "patch": "@@ -3000,6 +3000,12 @@ package body Sprint is\n          when N_Raise_Statement =>\n             Write_Indent_Str_Sloc (\"raise \");\n             Sprint_Node (Name (Node));\n+\n+            if Present (Expression (Node)) then\n+               Write_Str_With_Col_Check_Sloc (\" with \");\n+               Sprint_Node (Expression (Node));\n+            end if;\n+\n             Write_Char (';');\n \n          when N_Range =>"}]}