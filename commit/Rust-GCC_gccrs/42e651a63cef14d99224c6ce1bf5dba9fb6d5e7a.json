{"sha": "42e651a63cef14d99224c6ce1bf5dba9fb6d5e7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJlNjUxYTYzY2VmMTRkOTkyMjRjNmNlMWJmNWRiYTlmYjZkNWU3YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-23T19:19:04Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-23T19:19:04Z"}, "message": "(cast_expr): Use new initializer parsing functions.\n\n(initdcl, notype_initdcl): Likewise.\n(init): Likewise.\n(initlist_maybe_comma, initlist1): These replace initlist.\n(initelt): New nonterminal.\nChange specified index syntax to `[INDEX]='.\nChange specified field syntax to `.NAME='.\n\nFrom-SVN: r4977", "tree": {"sha": "52618ce9a4ba955cb560b867b64d54054ce3d3ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52618ce9a4ba955cb560b867b64d54054ce3d3ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42e651a63cef14d99224c6ce1bf5dba9fb6d5e7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42e651a63cef14d99224c6ce1bf5dba9fb6d5e7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42e651a63cef14d99224c6ce1bf5dba9fb6d5e7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42e651a63cef14d99224c6ce1bf5dba9fb6d5e7a/comments", "author": null, "committer": null, "parents": [{"sha": "3d06b1003fd4b4c7a431455e437288c181a36a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d06b1003fd4b4c7a431455e437288c181a36a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d06b1003fd4b4c7a431455e437288c181a36a5c"}], "stats": {"total": 113, "additions": 69, "deletions": 44}, "files": [{"sha": "bae5736185bb79007b1579fc84383d51ac523ebc", "filename": "gcc/c-parse.in", "status": "modified", "additions": 69, "deletions": 44, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e651a63cef14d99224c6ce1bf5dba9fb6d5e7a/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e651a63cef14d99224c6ce1bf5dba9fb6d5e7a/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=42e651a63cef14d99224c6ce1bf5dba9fb6d5e7a", "patch": "@@ -176,7 +176,7 @@ void yyerror ();\n %type <ttype> declmods typespec typespecqual_reserved\n %type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n %type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n-%type <ttype> init initlist maybeasm\n+%type <ttype> init maybeasm\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attribute_list attrib\n \n@@ -456,9 +456,16 @@ cast_expr:\n \t| '(' typename ')' cast_expr  %prec UNARY\n \t\t{ tree type = groktypename ($2);\n \t\t  $$ = build_c_cast (type, $4); }\n-\t| '(' typename ')' '{' initlist maybecomma '}'  %prec UNARY\n-\t\t{ tree type = groktypename ($2);\n-\t\t  char *name;\n+\t| '(' typename ')' '{' \n+\t\t{ start_init (NULL_TREE, NULL, 0);\n+\t\t  $2 = groktypename ($2);\n+\t\t  really_start_incremental_init ($2); }\n+\t  initlist_maybe_comma '}'  %prec UNARY\n+\t\t{ char *name;\n+\t\t  tree result = pop_init_level (0);\n+\t\t  tree type = $2;\n+\t\t  finish_init ();\n+\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C forbids constructor expressions\");\n \t\t  if (TYPE_NAME (type) != 0)\n@@ -470,8 +477,7 @@ cast_expr:\n \t\t    }\n \t\t  else\n \t\t    name = \"\";\n-\t\t  $$ = digest_init (type, build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($5)),\n-\t\t\t\t    NULL_PTR, 0, 0, name);\n+\t\t  $$ = result;\n \t\t  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_SIZE (type) == 0)\n \t\t    {\n \t\t      int failure = complete_array_type (type, $$, 1);\n@@ -1012,10 +1018,12 @@ maybeasm:\n \n initdcl:\n \t  declarator maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1); }\n+\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1);\n+\t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ decl_attributes ($<ttype>5, $3);\n+\t\t{ finish_init ();\n+\t\t  decl_attributes ($<ttype>5, $3);\n \t\t  finish_decl ($<ttype>5, $6, $2); }\n \t| declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0);\n@@ -1025,10 +1033,12 @@ initdcl:\n \n notype_initdcl:\n \t  notype_declarator maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1); }\n+\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1);\n+\t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ decl_attributes ($<ttype>5, $3);\n+\t\t{ finish_init ();\n+\t\t  decl_attributes ($<ttype>5, $3);\n \t\t  finish_decl ($<ttype>5, $6, $2); }\n \t| notype_declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0);\n@@ -1095,52 +1105,67 @@ attrib\n \t\t\t\t       NULL_TREE),\n \t\t\t    NULL_TREE); }\n     ;\n+\f\n+/* Initializers.  `init' is the entry point.  */\n \n init:\n \texpr_no_commas\n-\t| '{' '}'\n-\t\t{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, NULL_TREE);\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids empty initializer braces\"); }\n-\t| '{' initlist '}'\n-\t\t{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($2)); }\n-\t| '{' initlist ',' '}'\n-\t\t{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($2)); }\n+\t| '{'\n+\t\t{ really_start_incremental_init (NULL_TREE);\n+\t\t  /* Note that the call to clear_momentary\n+\t\t     is in process_init_element.  */\n+\t\t  push_momentary (); }\n+\t  initlist_maybe_comma '}'\n+\t\t{ $$ = pop_init_level (0);\n+\t\t  pop_momentary (); }\n+\n \t| error\n-\t\t{ $$ = NULL_TREE; }\n+\t\t{ $$ = error_mark_node;\n+\t\t  pop_momentary (); }\n \t;\n \n-/* This chain is built in reverse order,\n-   and put in forward order where initlist is used.  */\n-initlist:\n-\t  init\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n-\t| initlist ',' init\n-\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n+/* `initlist_maybe_comma' is the guts of an initializer in braces.  */\n+initlist_maybe_comma:\n+\t  /* empty */\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids empty initializer braces\"); }\n+\t| initlist1 maybecomma\n+\t;\n+\n+initlist1:\n+\t  initelt\n+\t| initlist1 ',' initelt\n+\t;\n+\n+/* `initelt' is a single element of an initializer.\n+   It may use braces.  */\n+initelt:\n+\texpr_no_commas\n+\t\t{ process_init_element ($1); }\n+\t| '{' \n+\t\t{ push_init_level (0); }\n+\t  initlist_maybe_comma '}'\n+\t\t{ process_init_element (pop_init_level (0)); }\n+\t| error\n \t/* These are for labeled elements.  The syntax for an array element\n \t   initializer conflicts with the syntax for an Objective-C message,\n \t   so don't include these productions in the Objective-C grammer.  */\n ifc\n-\t| '[' expr_no_commas ELLIPSIS expr_no_commas ']' init\n-\t\t{ $$ = build_tree_list (tree_cons ($2, NULL_TREE,\n-\t\t\t\t\t\t   build_tree_list ($4, NULL_TREE)),\n-\t\t\t\t\t$6); }\n-\t| initlist ',' '[' expr_no_commas ELLIPSIS expr_no_commas ']' init\n-\t\t{ $$ = tree_cons (tree_cons ($4, NULL_TREE,\n-\t\t\t\t\t     build_tree_list ($6, NULL_TREE)),\n-\t\t\t\t  $8,\n-\t\t\t\t  $1); }\n-\t| '[' expr_no_commas ']' init\n-\t\t{ $$ = build_tree_list ($2, $4); }\n-\t| initlist ',' '[' expr_no_commas ']' init\n-\t\t{ $$ = tree_cons ($4, $6, $1); }\n+\t| '[' expr_no_commas ELLIPSIS expr_no_commas ']' '='\n+\t\t{ set_init_index ($2, $4); }\n+\t  initelt\n+\t| '[' expr_no_commas ']' '='\n+\t\t{ set_init_index ($2, NULL_TREE); }\n+\t  initelt\n end ifc\n-\t| identifier ':' init\n-\t\t{ $$ = build_tree_list ($1, $3); }\n-\t| initlist ',' identifier ':' init\n-\t\t{ $$ = tree_cons ($3, $5, $1); }\n+\t| identifier ':'\n+\t\t{ set_init_label ($1); }\n+\t  initelt\n+\t| '.' identifier '='\n+\t\t{ set_init_label ($2); }\n+\t  initelt\n \t;\n-\n+\f\n nested_function:\n \t  declarator\n \t\t{ push_c_function_context ();"}]}