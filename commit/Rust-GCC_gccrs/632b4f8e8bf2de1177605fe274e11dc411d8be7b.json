{"sha": "632b4f8e8bf2de1177605fe274e11dc411d8be7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMyYjRmOGU4YmYyZGUxMTc3NjA1ZmUyNzRlMTFkYzQxMWQ4YmU3Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-22T20:04:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-22T20:04:42Z"}, "message": "gengtype.c (open_base_files): Add ipa-inline.h include.\n\n\n\t* gengtype.c (open_base_files): Add ipa-inline.h include.\n\t* ipa-cp.c (ipcp_get_lattice, ipcp_lattice_from_jfunc): Move to ipa-prop.c\n\tupdate all uses.\n\t* ipa-prop.c: (ipa_get_lattice, ipa_lattice_from_jfunc): ... here.\n\t* ipa-inline-transform.c (inline_call): Use inline_merge_summary to merge\n\tsummary of inlined function into former caller.\n\t* ipa-inline.c (max_benefit): Remove.\n\t(edge_badness): Compensate for removal of benefits.\n\t(update_caller_keys): Use reset_node_growth_cache/reset_edge_growth_cache.\n\t(update_callee_keys): Likewise.\n\t(update_all_callee_keys): Likewise.\n\t(inline_small_functions): Do not collect max_benefit; do not\n\treset stimated_growth; call free_growth_caches and initialize_growth_caches.\n\t* ipa-inline.h (struct condition, type clause_t, struct predicate, struct\n\tsize_time_entry): New structures.\n\t(INLINE_SIZE_SCALE, INLINE_TIME_SCALE, MAX_CLAUSES): New constants.\n\t(inline_summary): Remove size_inlining_benefit, time_inlining_benefit and\n\testimated_growth.\n\t(edge_growth_cache_entry): New structure.\n\t(node_growth_cache, edge_growth_cache): New global vars.\n\t(estimate_growth): Turn into inline.\n\t(inline_merge_summary, do_estimate_edge_growth, do_estimate_edge_time,\n\tinitialize_growth_caches, free_growth_caches): Declare.\n\t(estimate_edge_growth): Rewrite.\n\t(estimate_edge_time): Implement as inline cache lookup.\n\t(reset_node_growth_cache, reset_edge_growth_cache): New inline functions.\n\t(MAX_TIME): Reduce to allow multiplicatoin by INLINE_SIZE_SCALE.\n\t(NUM_CONDITIONS): New constant.\n\t(predicate_conditions): New enum.\n\t(IS_NOT_CONSTANT): New constant.\n\t(edge_removal_hook_holder): New var.\n\t(node_growth_cache, edge_growth_cache): New global vars.\n\t(true_predicate, single_cond_predicate, false_predicate, not_inlined_predicate,\n\tadd_condition, add_clause, and_predicates, or_predicates, predicates_equal_p,\n\tevaulate_predicate, dump_condition, dump_clause, dump_predicate, account_size_time,\n\tevaulate_conditions_for_edge): New functions.\n\t(inline_summary_alloc): Move to heap.\n\t(inline_node_removal_hook): Clear condition and entry vectors.\n\t(inline_edge_removal_hook): New function.\n\t(initialize_growth_caches, free_growth_caches): New function.\n\t(dump_inline_summary): Update.\n\t(edge_execution_predicate): New function.\n\t(will_be_nonconstant_predicate): New function.\n\t(estimate_function_body_sizes): Compute BB and constantness predicates.\n\t(compute_inline_parameters): Do not clear estimated_growth.\n\t(estimate_edge_size_and_time): New function.\n\t(estimate_calls_size_and_time): New function.\n\t(estimate_callee_size_and_time): New function.\n\t(remap_predicate): New function.\n\t(inline_merge_summary): New function.\n\t(do_estimate_edge_time): New function based on...\n\t(estimate_edge_time): ... this one.\n\t(do_estimate_edge_growth): New function.\n\t(do_estimate_growth): New function based on....\n\t(estimate_growth): ... this one.\n\t(inline_analyze_function): Analyze after deciding on jump functions.\n\t(inline_read_section): New function.\n\t(inline_read_summary): Use it.\n\t(inline_write_summary): Write all the new data.\n\t* ipa-prop.c (ipa_get_param_decl_index): Export.\n\t(ipa_lattice_from_jfunc): Move here from ipa-cp.c\n\t* ipa-prop.h (ipa_get_param_decl_index, ipa_lattice_from_jfunc): Declare.\n\t(ipa_get_lattice): Move hre from ipa-cp.c\n\t* Makefile.in (GTFILES): Add ipa-inline.h and ipa-inline-analysis.c\n\t* params.def (PARAM_EARLY_INLINING_INSNS): Set to 11.\n\t* cgraph.h (cgraph_clone_inlined_nodes, compute_inline_parameters,\n\tcgraph_edge_inlinable_p): Remove.\n\t* cgraphunit.c: Include ipainline.h\n\t(cgraph_process_new_functions): Update call of compute_inline_parameters.\n\n\t* gcc.dg/tree-ssa/pr38699.c: Fix testcase.\n\nFrom-SVN: r172873", "tree": {"sha": "d11d88528b083b9afc72d6f2e3aa0faeea8de7b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d11d88528b083b9afc72d6f2e3aa0faeea8de7b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/632b4f8e8bf2de1177605fe274e11dc411d8be7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/632b4f8e8bf2de1177605fe274e11dc411d8be7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/632b4f8e8bf2de1177605fe274e11dc411d8be7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/632b4f8e8bf2de1177605fe274e11dc411d8be7b/comments", "author": null, "committer": null, "parents": [{"sha": "0cfbd2883812ee062b98ebc217d46e77b316d790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cfbd2883812ee062b98ebc217d46e77b316d790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cfbd2883812ee062b98ebc217d46e77b316d790"}], "stats": {"total": 1723, "additions": 1437, "deletions": 286}, "files": [{"sha": "71e2d3c9a4e27b359279e9c1c69ef8d2eb8cc402", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -1,3 +1,75 @@\n+2011-04-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gengtype.c (open_base_files): Add ipa-inline.h include.\n+\t* ipa-cp.c (ipcp_get_lattice, ipcp_lattice_from_jfunc): Move to ipa-prop.c\n+\tupdate all uses.\n+\t* ipa-prop.c: (ipa_get_lattice, ipa_lattice_from_jfunc): ... here.\n+\t* ipa-inline-transform.c (inline_call): Use inline_merge_summary to merge\n+\tsummary of inlined function into former caller.\n+\t* ipa-inline.c (max_benefit): Remove.\n+\t(edge_badness): Compensate for removal of benefits.\n+\t(update_caller_keys): Use reset_node_growth_cache/reset_edge_growth_cache.\n+\t(update_callee_keys): Likewise.\n+\t(update_all_callee_keys): Likewise.\n+\t(inline_small_functions): Do not collect max_benefit; do not\n+\treset stimated_growth; call free_growth_caches and initialize_growth_caches.\n+\t* ipa-inline.h (struct condition, type clause_t, struct predicate, struct\n+\tsize_time_entry): New structures.\n+\t(INLINE_SIZE_SCALE, INLINE_TIME_SCALE, MAX_CLAUSES): New constants.\n+\t(inline_summary): Remove size_inlining_benefit, time_inlining_benefit and\n+\testimated_growth.\n+\t(edge_growth_cache_entry): New structure.\n+\t(node_growth_cache, edge_growth_cache): New global vars.\n+\t(estimate_growth): Turn into inline.\n+\t(inline_merge_summary, do_estimate_edge_growth, do_estimate_edge_time,\n+\tinitialize_growth_caches, free_growth_caches): Declare.\n+\t(estimate_edge_growth): Rewrite.\n+\t(estimate_edge_time): Implement as inline cache lookup.\n+\t(reset_node_growth_cache, reset_edge_growth_cache): New inline functions.\n+\t(MAX_TIME): Reduce to allow multiplicatoin by INLINE_SIZE_SCALE.\n+\t(NUM_CONDITIONS): New constant.\n+\t(predicate_conditions): New enum.\n+\t(IS_NOT_CONSTANT): New constant.\n+\t(edge_removal_hook_holder): New var.\n+\t(node_growth_cache, edge_growth_cache): New global vars.\n+\t(true_predicate, single_cond_predicate, false_predicate, not_inlined_predicate,\n+\tadd_condition, add_clause, and_predicates, or_predicates, predicates_equal_p,\n+\tevaulate_predicate, dump_condition, dump_clause, dump_predicate, account_size_time,\n+\tevaulate_conditions_for_edge): New functions.\n+\t(inline_summary_alloc): Move to heap.\n+\t(inline_node_removal_hook): Clear condition and entry vectors.\n+\t(inline_edge_removal_hook): New function.\n+\t(initialize_growth_caches, free_growth_caches): New function.\n+\t(dump_inline_summary): Update.\n+\t(edge_execution_predicate): New function.\n+\t(will_be_nonconstant_predicate): New function.\n+\t(estimate_function_body_sizes): Compute BB and constantness predicates.\n+\t(compute_inline_parameters): Do not clear estimated_growth.\n+\t(estimate_edge_size_and_time): New function.\n+\t(estimate_calls_size_and_time): New function.\n+\t(estimate_callee_size_and_time): New function.\n+\t(remap_predicate): New function.\n+\t(inline_merge_summary): New function.\n+\t(do_estimate_edge_time): New function based on...\n+\t(estimate_edge_time): ... this one.\n+\t(do_estimate_edge_growth): New function.\n+\t(do_estimate_growth): New function based on....\n+\t(estimate_growth): ... this one.\n+\t(inline_analyze_function): Analyze after deciding on jump functions.\n+\t(inline_read_section): New function.\n+\t(inline_read_summary): Use it.\n+\t(inline_write_summary): Write all the new data.\n+\t* ipa-prop.c (ipa_get_param_decl_index): Export.\n+\t(ipa_lattice_from_jfunc): Move here from ipa-cp.c\n+\t* ipa-prop.h (ipa_get_param_decl_index, ipa_lattice_from_jfunc): Declare.\n+\t(ipa_get_lattice): Move hre from ipa-cp.c\n+\t* Makefile.in (GTFILES): Add ipa-inline.h and ipa-inline-analysis.c\n+\t* params.def (PARAM_EARLY_INLINING_INSNS): Set to 11.\n+\t* cgraph.h (cgraph_clone_inlined_nodes, compute_inline_parameters,\n+\tcgraph_edge_inlinable_p): Remove.\n+\t* cgraphunit.c: Include ipainline.h\n+\t(cgraph_process_new_functions): Update call of compute_inline_parameters.\n+\n 2011-04-22  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.c (build_int_cst): Properly create canonicalized integer"}, {"sha": "9b85ad0564c21dde0a891a3e63b44887d16a6e0e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -2997,7 +2997,7 @@ cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) debug.h $(DIAGNOSTIC_H) \\\n    $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) $(IPA_PROP_H) \\\n    gt-cgraphunit.h tree-iterator.h $(COVERAGE_H) $(TREE_DUMP_H) \\\n-   tree-pretty-print.h gimple-pretty-print.h\n+   tree-pretty-print.h gimple-pretty-print.h ipa-inline.h\n cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(GIMPLE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(IPA_UTILS_H) $(EXCEPT_H) \\\n@@ -3782,6 +3782,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/ipa-prop.h \\\n   $(srcdir)/lto-streamer.h \\\n   $(srcdir)/target-globals.h \\\n+  $(srcdir)/ipa-inline.h \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "54e75943cf3db9e06dc558ecb1b292953a1413d2", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -721,11 +721,6 @@ varpool_next_static_initializer (struct varpool_node *node)\n    for ((node) = varpool_first_static_initializer (); (node); \\\n         (node) = varpool_next_static_initializer (node))\n \n-/* In ipa-inline.c  */\n-void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool, bool);\n-void compute_inline_parameters (struct cgraph_node *);\n-cgraph_inline_failed_t cgraph_edge_inlinable_p (struct cgraph_edge *);\n-\n /* Create a new static variable of type TYPE.  */\n tree add_new_static_var (tree type);\n "}, {"sha": "8803cf6b8a294926a391e626c8d0c61501afb22f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -138,6 +138,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"coverage.h\"\n #include \"plugin.h\"\n+#include \"ipa-inline.h\"\n \n static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n@@ -252,7 +253,7 @@ cgraph_process_new_functions (void)\n \t      || !optimize)\n \t    execute_pass_list (pass_early_local_passes.pass.sub);\n \t  else\n-\t    compute_inline_parameters (node);\n+\t    compute_inline_parameters (node, true);\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n \t  free_dominance_info (CDI_DOMINATORS);\n \t  pop_cfun ();"}, {"sha": "95e2a92888f90201fd61815efb2beaf935edf3fb", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -1559,7 +1559,8 @@ open_base_files (void)\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n       \"tree-flow.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n       \"cfglayout.h\", \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\",\n-      \"target.h\", \"ipa-prop.h\", \"lto-streamer.h\", \"target-globals.h\", NULL\n+      \"target.h\", \"ipa-prop.h\", \"lto-streamer.h\", \"target-globals.h\",\n+      \"ipa-inline.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "fd88fc73866b5051479f9f87278582f634e511ce", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 12, "deletions": 83, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -278,77 +278,6 @@ ipa_lattice_meet (struct ipcp_lattice *res, struct ipcp_lattice *lat1,\n   res->constant = lat1->constant;\n }\n \n-/* Return the lattice corresponding to the Ith formal parameter of the function\n-   described by INFO.  */\n-static inline struct ipcp_lattice *\n-ipcp_get_lattice (struct ipa_node_params *info, int i)\n-{\n-  return &(info->params[i].ipcp_lattice);\n-}\n-\n-/* Given the jump function JFUNC, compute the lattice LAT that describes the\n-   value coming down the callsite. INFO describes the caller node so that\n-   pass-through jump functions can be evaluated.  */\n-static void\n-ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n-\t\t\t struct ipa_jump_func *jfunc)\n-{\n-  if (jfunc->type == IPA_JF_CONST)\n-    {\n-      lat->type = IPA_CONST_VALUE;\n-      lat->constant = jfunc->value.constant;\n-    }\n-  else if (jfunc->type == IPA_JF_PASS_THROUGH)\n-    {\n-      struct ipcp_lattice *caller_lat;\n-      tree cst;\n-\n-      caller_lat = ipcp_get_lattice (info, jfunc->value.pass_through.formal_id);\n-      lat->type = caller_lat->type;\n-      if (caller_lat->type != IPA_CONST_VALUE)\n-\treturn;\n-      cst = caller_lat->constant;\n-\n-      if (jfunc->value.pass_through.operation != NOP_EXPR)\n-\t{\n-\t  tree restype;\n-\t  if (TREE_CODE_CLASS (jfunc->value.pass_through.operation)\n-\t      == tcc_comparison)\n-\t    restype = boolean_type_node;\n-\t  else\n-\t    restype = TREE_TYPE (cst);\n-\t  cst = fold_binary (jfunc->value.pass_through.operation,\n-\t\t\t     restype, cst, jfunc->value.pass_through.operand);\n-\t}\n-      if (!cst || !is_gimple_ip_invariant (cst))\n-\tlat->type = IPA_BOTTOM;\n-      lat->constant = cst;\n-    }\n-  else if (jfunc->type == IPA_JF_ANCESTOR)\n-    {\n-      struct ipcp_lattice *caller_lat;\n-      tree t;\n-\n-      caller_lat = ipcp_get_lattice (info, jfunc->value.ancestor.formal_id);\n-      lat->type = caller_lat->type;\n-      if (caller_lat->type != IPA_CONST_VALUE)\n-\treturn;\n-      if (TREE_CODE (caller_lat->constant) != ADDR_EXPR)\n-\t{\n-\t  /* This can happen when the constant is a NULL pointer.  */\n-\t  lat->type = IPA_BOTTOM;\n-\t  return;\n-\t}\n-      t = TREE_OPERAND (caller_lat->constant, 0);\n-      t = build_ref_for_offset (EXPR_LOCATION (t), t,\n-\t\t\t\tjfunc->value.ancestor.offset,\n-\t\t\t\tjfunc->value.ancestor.type, NULL, false);\n-      lat->constant = build_fold_addr_expr (t);\n-    }\n-  else\n-    lat->type = IPA_BOTTOM;\n-}\n-\n /* True when OLD_LAT and NEW_LAT values are not the same.  */\n \n static bool\n@@ -384,7 +313,7 @@ ipcp_print_all_lattices (FILE * f)\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\t  struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n \n \t  fprintf (f, \"    param [%d]: \", i);\n \t  if (lat->type == IPA_CONST_VALUE)\n@@ -582,7 +511,7 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n \n   for (i = 0; i < ipa_get_param_count (info) ; i++)\n     {\n-      ipcp_get_lattice (info, i)->type = type;\n+      ipa_get_lattice (info, i)->type = type;\n       if (type == IPA_BOTTOM)\n \tipa_set_param_cannot_devirtualize (info, i);\n     }\n@@ -659,7 +588,7 @@ ipcp_change_tops_to_bottom (void)\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\t  struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n \t  if (lat->type == IPA_TOP)\n \t    {\n \t      prop_again = true;\n@@ -842,8 +771,8 @@ ipcp_propagate_stage (void)\n \t  for (i = 0; i < count; i++)\n \t    {\n \t      jump_func = ipa_get_ith_jump_func (args, i);\n-\t      ipcp_lattice_from_jfunc (info, &inc_lat, jump_func);\n-\t      dest_lat = ipcp_get_lattice (callee_info, i);\n+\t      ipa_lattice_from_jfunc (info, &inc_lat, jump_func);\n+\t      dest_lat = ipa_get_lattice (callee_info, i);\n \t      ipa_lattice_meet (&new_lat, &inc_lat, dest_lat);\n \t      if (ipcp_lattice_changed (&new_lat, dest_lat))\n \t\t{\n@@ -1031,7 +960,7 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n   count = ipa_get_param_count (orig_callee_info);\n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_lattice *lat = ipcp_get_lattice (orig_callee_info, i);\n+      struct ipcp_lattice *lat = ipa_get_lattice (orig_callee_info, i);\n       struct ipa_jump_func *jump_func;\n \n       jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n@@ -1067,7 +996,7 @@ ipcp_update_callgraph (void)\n \t    args_to_skip = BITMAP_ALLOC (NULL);\n \t    for (i = 0; i < count; i++)\n \t      {\n-\t\tstruct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\t\tstruct ipcp_lattice *lat = ipa_get_lattice (info, i);\n \n \t\t/* We can proactively remove obviously unused arguments.  */\n \t\tif (!ipa_is_param_used (info, i))\n@@ -1155,7 +1084,7 @@ ipcp_estimate_growth (struct cgraph_node *node)\n   if (node->local.can_change_signature)\n     for (i = 0; i < count; i++)\n       {\n-\tstruct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\tstruct ipcp_lattice *lat = ipa_get_lattice (info, i);\n \n \t/* We can proactively remove obviously unused arguments.  */\n \tif (!ipa_is_param_used (info, i))\n@@ -1237,7 +1166,7 @@ ipcp_process_devirtualization_opportunities (struct cgraph_node *node)\n       if (param_index == -1)\n \tcontinue;\n \n-      lat = ipcp_get_lattice (info, param_index);\n+      lat = ipa_get_lattice (info, param_index);\n       token = ie->indirect_info->otr_token;\n       anc_offset = ie->indirect_info->anc_offset;\n       otr_type = ie->indirect_info->otr_type;\n@@ -1309,7 +1238,7 @@ ipcp_const_param_count (struct cgraph_node *node)\n \n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+      struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n       if ((ipcp_lat_is_insertable (lat)\n \t  /* Do not count obviously unused arguments.  */\n \t   && ipa_is_param_used (info, i))\n@@ -1436,7 +1365,7 @@ ipcp_insert_stage (void)\n \targs_to_skip = NULL;\n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\t  struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n \t  parm_tree = ipa_get_param (info, i);\n \n \t  /* We can proactively remove obviously unused arguments.  */\n@@ -1504,7 +1433,7 @@ ipcp_insert_stage (void)\n       info = IPA_NODE_REF (node);\n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\t  struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n \t  if (lat->type == IPA_CONST_VALUE)\n \t    ipcp_discover_new_direct_edges (node1, i, lat->constant);\n         }"}, {"sha": "921f5d3a0e4c56deb33075c8c46c0b4c233130ff", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1077, "deletions": 116, "changes": 1193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -36,9 +36,31 @@ along with GCC; see the file COPYING3.  If not see\n    the function created by applying all the inline decisions already\n    present in the callgraph).\n \n-   We also provide accestor to the inline_summary datastructure and\n+   We provide accestor to the inline_summary datastructure and\n    basic logic updating the parameters when inlining is performed. \n \n+   The summaries are context sensitive.  Context means\n+     1) partial assignment of known constant values of operands\n+     2) whether function is inlined into the call or not.\n+   It is easy to add more variants.  To represent function size and time\n+   that depends on context (i.e. it is known to be optimized away when\n+   context is known either by inlining or from IP-CP and clonning),\n+   we use predicates. Predicates are logical formulas in\n+   conjunctive-disjunctive form consisting of clauses. Clauses are bitmaps\n+   specifying what conditions must be true. Conditions are simple test\n+   of the form described above.\n+\n+   In order to make predicate (possibly) true, all of its clauses must\n+   be (possibly) true. To make clause (possibly) true, one of conditions\n+   it mentions must be (possibly) true.  There are fixed bounds on\n+   number of clauses and conditions and all the manipulation functions\n+   are conservative in positive direction. I.e. we may lose precision\n+   by thinking that predicate may be true even when it is not.\n+\n+   estimate_edge_size and estimate_edge_growth can be used to query\n+   function size/time in the given context.  inline_merge_summary merges\n+   properties of caller and callee after inlining.\n+\n    Finally pass_inline_parameters is exported.  This is used to drive\n    computation of function parameters used by the early inliner. IPA\n    inlined performs analysis via its analyze_function method. */\n@@ -64,18 +86,408 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"ipa-inline.h\"\n \n-#define MAX_TIME 1000000000\n+/* Estimate runtime of function can easilly run into huge numbers with many\n+   nested loops.  Be sure we can compute time * INLINE_SIZE_SCALE in integer.\n+   For anything larger we use gcov_type.  */\n+#define MAX_TIME 1000000\n+\n+/* Number of bits in integer, but we really want to be stable across different\n+   hosts.  */\n+#define NUM_CONDITIONS 32\n+\n+enum predicate_conditions\n+{\n+  predicate_false_condition = 0,\n+  predicate_not_inlined_condition = 1,\n+  predicate_first_dynamic_condition = 2\n+};\n+\n+/* Special condition code we use to represent test that operand is compile time\n+   constant.  */\n+#define IS_NOT_CONSTANT ERROR_MARK\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n static struct cgraph_node_hook_list *node_removal_hook_holder;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n+static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n static void inline_node_removal_hook (struct cgraph_node *, void *);\n static void inline_node_duplication_hook (struct cgraph_node *,\n \t\t\t\t\t  struct cgraph_node *, void *);\n \n-/* VECtor holding inline summaries.  */\n-VEC(inline_summary_t,heap) *inline_summary_vec;\n+/* VECtor holding inline summaries.  \n+   In GGC memory because conditions might point to constant trees.  */\n+VEC(inline_summary_t,gc) *inline_summary_vec;\n+\n+/* Cached node/edge growths.  */\n+VEC(int,heap) *node_growth_cache;\n+VEC(edge_growth_cache_entry,heap) *edge_growth_cache;\n+\n+\n+/* Return true predicate (tautology).\n+   We represent it by empty list of clauses.  */\n+\n+static inline struct predicate\n+true_predicate (void)\n+{\n+  struct predicate p;\n+  p.clause[0]=0;\n+  return p;\n+}\n+\n+\n+/* Return predicate testing single condition number COND.  */\n+\n+static inline struct predicate\n+single_cond_predicate (int cond)\n+{\n+  struct predicate p;\n+  p.clause[0]=1 << cond;\n+  p.clause[1]=0;\n+  return p;\n+}\n+\n+\n+/* Return false predicate.  First clause require false condition.  */\n+\n+static inline struct predicate\n+false_predicate (void)\n+{\n+  return single_cond_predicate (predicate_false_condition);\n+}\n+\n+\n+/* Return predicate that is set true when function is not inlined.  */\n+static inline struct predicate\n+not_inlined_predicate (void)\n+{\n+  return single_cond_predicate (predicate_not_inlined_condition);\n+}\n+\n+\n+/* Add condition to condition list CONDS.  */\n+\n+static struct predicate\n+add_condition (struct inline_summary *summary, int operand_num,\n+\t       enum tree_code code, tree val)\n+{\n+  int i;\n+  struct condition *c;\n+  struct condition new_cond;\n+\n+  for (i = 0; VEC_iterate (condition, summary->conds, i, c); i++)\n+    {\n+      if (c->operand_num == operand_num\n+\t  && c->code == code\n+\t  && c->val == val)\n+        return single_cond_predicate (i + predicate_first_dynamic_condition);\n+    }\n+  /* Too many conditions.  Give up and return constant true.  */\n+  if (i == NUM_CONDITIONS - predicate_first_dynamic_condition)\n+    return true_predicate ();\n+\n+  new_cond.operand_num = operand_num;\n+  new_cond.code = code;\n+  new_cond.val = val;\n+  VEC_safe_push (condition, gc, summary->conds, &new_cond);\n+  return single_cond_predicate (i + predicate_first_dynamic_condition);\n+}\n+\n+\n+/* Add clause CLAUSE into the predicate.  */\n+\n+static inline void\n+add_clause (struct predicate *p, clause_t clause)\n+{\n+  int i;\n+  int insert_here = 0;\n+  /* True clause.  */\n+  if (!clause)\n+    return;\n+\n+  /* Flase clause makes the whole predicate false.  Kill the other variants.  */\n+  if (clause & (1 << predicate_false_condition))\n+    {\n+      p->clause[0] = (1 << predicate_false_condition);\n+      p->clause[1] = 0;\n+    }\n+  for (i = 0; i < MAX_CLAUSES; i++)\n+    {\n+      if (p->clause[i] == clause)\n+        return;\n+      if (!p->clause[i])\n+\tbreak;\n+      if (p->clause[i] < clause && !insert_here)\n+\tinsert_here = i;\n+    }\n+  /* We run out of variants.  Be conservative in positive direciton.  */\n+  if (i == MAX_CLAUSES)\n+    return;\n+  /* Keep clauses ordered by index, so equivalence testing is easy.  */\n+  p->clause[i + 1] = 0;\n+  for (;i > insert_here; i--)\n+    p->clause[i] = p->clause[i - 1];\n+  p->clause[insert_here] = clause;\n+}\n+\n+\n+/* Return P & P2.  */\n+\n+static struct predicate\n+and_predicates (struct predicate *p, struct predicate *p2)\n+{\n+  struct predicate out = *p;\n+  int i;\n+  for (i = 0; p2->clause[i]; i++)\n+    add_clause (&out, p2->clause[i]);\n+  return out;\n+}\n+\n+\n+/* Return P | P2.  */\n+\n+static struct predicate\n+or_predicates (struct predicate *p, struct predicate *p2)\n+{\n+  struct predicate out = true_predicate ();\n+  int i,j;\n+  /* If one of conditions is false, return the other.  */\n+  if (p2->clause[0] == 1 << predicate_false_condition)\n+    {\n+      gcc_checking_assert (!p2->clause[1]);\n+      return *p;\n+    }\n+  if (p->clause[0] == 1 << predicate_false_condition)\n+    {\n+      gcc_checking_assert (!p->clause[1]);\n+      return *p2;\n+    }\n+  for (i = 0; p->clause[i]; i++)\n+    for (j = 0; p2->clause[j]; j++)\n+      add_clause (&out, p->clause[i] | p2->clause[j]);\n+  return out;\n+}\n+\n+\n+/* Return true if predicates are obviously equal.  */\n+\n+static inline bool\n+predicates_equal_p (struct predicate *p, struct predicate *p2)\n+{\n+  int i;\n+  for (i = 0; p->clause[i]; i++)\n+    if (p->clause[i] != p2->clause[i])\n+      return false;\n+  return !p2->clause[i];\n+}\n+\n+\n+/* Having partial truth assignment in POSSIBLE_TRUTHS, return false if predicate P\n+   to be false.  */\n+\n+static bool\n+evaulate_predicate (struct predicate *p, clause_t possible_truths)\n+{\n+  int i;\n+\n+  /* True remains true.  */\n+  if (!p->clause[0])\n+    return true;\n+\n+  /* See if we can find clause we can disprove.  */\n+  for (i = 0; p->clause[i]; i++)\n+    if (!(p->clause[i] & possible_truths))\n+      return false;\n+  return true;\n+}\n+\n+\n+/* Dump conditional COND.  */\n+\n+static void\n+dump_condition (FILE *f, conditions conditions, int cond)\n+{\n+  condition *c;\n+  if (cond == predicate_false_condition)\n+    fprintf (f, \"false\");\n+  else if (cond == predicate_not_inlined_condition)\n+    fprintf (f, \"not inlined\");\n+  else\n+    {\n+      c = VEC_index (condition, conditions, cond - predicate_first_dynamic_condition);\n+      fprintf (f, \"op%i\", c->operand_num);\n+      if (c->code == IS_NOT_CONSTANT)\n+\t{\n+\t  fprintf (f, \" not constant\");\n+\t  return;\n+\t}\n+      fprintf (f, \" %s \", op_symbol_code (c->code));\n+      print_generic_expr (f, c->val, 1);\n+    }\n+}\n+\n+\n+/* Dump clause CLAUSE.  */\n+\n+static void\n+dump_clause (FILE *f, conditions conds, clause_t clause)\n+{\n+  int i;\n+  bool found = false;\n+  fprintf (f, \"(\");\n+  if (!clause)\n+    fprintf (f, \"true\");\n+  for (i = 0; i < NUM_CONDITIONS; i++)\n+    if (clause & (1 << i))\n+      {\n+\tif (found)\n+\t  fprintf (f, \" || \");\n+\tfound = true;\n+        dump_condition (f, conds, i);\n+      }\n+  fprintf (f, \")\");\n+}\n+\n+\n+/* Dump predicate PREDICATE.  */\n+\n+static void\n+dump_predicate (FILE *f, conditions conds, struct predicate *pred)\n+{\n+  int i;\n+  if (!pred->clause[0])\n+    dump_clause (f, conds, 0);\n+  else\n+    for (i = 0; pred->clause[i]; i++)\n+      {\n+\tif (i)\n+\t  fprintf (f, \" && \");\n+        dump_clause (f, conds, pred->clause[i]);\n+      }\n+  fprintf (f, \"\\n\");\n+}\n+\n+\n+/* Record SIZE and TIME under condition PRED into the inline summary.  */\n+\n+static void\n+account_size_time (struct inline_summary *summary, int size, int time, struct predicate *pred)\n+{\n+  size_time_entry *e;\n+  bool found = false;\n+  int i;\n+\n+  if (pred->clause[0] == (1 << predicate_false_condition))\n+    return;\n+\n+  /* We need to create initial empty unconitional clause, but otherwie\n+     we don't need to account empty times and sizes.  */\n+  if (!size && !time && summary->conds)\n+    return;\n+\n+  /* Watch overflow that might result from insane profiles.  */\n+  if (time > MAX_TIME * INLINE_TIME_SCALE)\n+    time = MAX_TIME * INLINE_TIME_SCALE;\n+  gcc_assert (time >= 0);\n+\n+  for (i = 0; VEC_iterate (size_time_entry, summary->entry, i, e); i++)\n+    if (predicates_equal_p (&e->predicate, pred))\n+      {\n+\tfound = true;\n+        break;\n+      }\n+  if (i == 32)\n+    {\n+      i = 0;\n+      found = true;\n+      e = VEC_index (size_time_entry, summary->entry, 0);\n+      gcc_assert (!e->predicate.clause[0]);\n+    }\n+  if (dump_file && (dump_flags & TDF_DETAILS) && (time || size))\n+    {\n+      fprintf (dump_file, \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate:\",\n+\t       ((double)size) / INLINE_SIZE_SCALE, ((double)time) / INLINE_TIME_SCALE,\n+\t       found ? \"\" : \"new \");\n+      dump_predicate (dump_file, summary->conds, pred);\n+    }\n+  if (!found)\n+    {\n+      struct size_time_entry new_entry;\n+      new_entry.size = size;\n+      new_entry.time = time;\n+      new_entry.predicate = *pred;\n+      VEC_safe_push (size_time_entry, gc, summary->entry, &new_entry);\n+    }\n+  else\n+    {\n+      e->size += size;\n+      e->time += time;\n+      if (e->time > MAX_TIME * INLINE_TIME_SCALE)\n+\te->time = MAX_TIME * INLINE_TIME_SCALE;\n+    }\n+}\n+\n+\n+/* Work out what conditions might be true at invocation of E.  */\n+\n+static clause_t\n+evaulate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n+{\n+  clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n+  struct inline_summary *info = inline_summary (e->callee);\n+  int i;\n+\n+  if (ipa_node_params_vector && info->conds\n+      /* FIXME: it seems that we forget to get argument count in some cases,\n+\t probaby for previously indirect edges or so.  */\n+      && ipa_get_cs_argument_count (IPA_EDGE_REF (e)))\n+    {\n+      struct ipa_node_params *parms_info;\n+      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+      int i, count = ipa_get_cs_argument_count (args);\n+      struct ipcp_lattice lat;\n+      struct condition *c;\n+      VEC (tree, heap) *known_vals = NULL;\n+\n+      if (e->caller->global.inlined_to)\n+        parms_info = IPA_NODE_REF (e->caller->global.inlined_to);\n+      else\n+        parms_info = IPA_NODE_REF (e->caller);\n+\n+      VEC_safe_grow_cleared (tree, heap, known_vals, count);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  ipa_lattice_from_jfunc (parms_info, &lat, ipa_get_ith_jump_func (args, i));\n+\t  if (lat.type == IPA_CONST_VALUE)\n+\t    VEC_replace (tree, known_vals, i, lat.constant);\n+\t}\n+      for (i = 0; VEC_iterate (condition, info->conds, i, c); i++)\n+\t{\n+\t  tree val = VEC_index (tree, known_vals, c->operand_num);\n+\t  tree res;\n+\n+\t  if (!val)\n+\t    {\n+\t      clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t      continue;\n+\t    }\n+\t  if (c->code == IS_NOT_CONSTANT)\n+\t    continue;\n+\t  res = fold_binary_to_constant (c->code, boolean_type_node, val, c->val);\n+\t  if (res\n+\t      && integer_zerop (res))\n+\t    continue;\n+\t  clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t}\n+      VEC_free (tree, heap, known_vals);\n+    }\n+  else\n+    for (i = 0; i < (int)VEC_length (condition, info->conds); i++)\n+      clause |= 1 << (i + predicate_first_dynamic_condition);\n+\n+  return clause;\n+}\n+\n \n /* Allocate the inline summary vector or resize it to cover all cgraph nodes. */\n \n@@ -91,7 +503,7 @@ inline_summary_alloc (void)\n \n   if (VEC_length (inline_summary_t, inline_summary_vec)\n       <= (unsigned) cgraph_max_uid)\n-    VEC_safe_grow_cleared (inline_summary_t, heap,\n+    VEC_safe_grow_cleared (inline_summary_t, gc,\n \t\t\t   inline_summary_vec, cgraph_max_uid + 1);\n }\n \n@@ -105,7 +517,11 @@ inline_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n       <= (unsigned)node->uid)\n     return;\n   info = inline_summary (node);\n-  info->estimated_growth = INT_MIN;\n+  reset_node_growth_cache (node);\n+  VEC_free (condition, gc, info->conds);\n+  VEC_free (size_time_entry, gc, info->entry);\n+  info->conds = NULL;\n+  info->entry = NULL;\n   memset (info, 0, sizeof (inline_summary_t));\n }\n \n@@ -120,15 +536,58 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n   info = inline_summary (dst);\n   memcpy (info, inline_summary (src),\n \t  sizeof (struct inline_summary));\n-  info->estimated_growth = INT_MIN;\n+  info->conds = VEC_copy (condition, gc, info->conds);\n+  info->entry = VEC_copy (size_time_entry, gc, info->entry);\n+}\n+\n+\n+/* Keep edge cache consistent across edge removal.  */\n+\n+static void\n+inline_edge_removal_hook (struct cgraph_edge *edge, void *data ATTRIBUTE_UNUSED)\n+{\n+  reset_edge_growth_cache (edge);\n+}\n+\n+\n+/* Initialize growth caches.  */\n+\n+void\n+initialize_growth_caches (void)\n+{\n+  if (!edge_removal_hook_holder)\n+    edge_removal_hook_holder =\n+      cgraph_add_edge_removal_hook (&inline_edge_removal_hook, NULL);\n+  if (cgraph_edge_max_uid)\n+    VEC_safe_grow_cleared (edge_growth_cache_entry, heap, edge_growth_cache,\n+\t\t\t   cgraph_edge_max_uid);\n+  if (cgraph_max_uid)\n+    VEC_safe_grow_cleared (int, heap, node_growth_cache, cgraph_max_uid);\n+}\n+\n+\n+/* Free growth caches.  */\n+\n+void\n+free_growth_caches (void)\n+{\n+  if (edge_removal_hook_holder)\n+    cgraph_remove_edge_removal_hook (edge_removal_hook_holder);\n+  VEC_free (edge_growth_cache_entry, heap, edge_growth_cache);\n+  edge_growth_cache = 0;\n+  VEC_free (int, heap, node_growth_cache);\n+  node_growth_cache = 0;\n }\n \n+\n static void\n-dump_inline_summary (FILE *f, struct cgraph_node *node)\n+dump_inline_summary (FILE * f, struct cgraph_node *node)\n {\n   if (node->analyzed)\n     {\n       struct inline_summary *s = inline_summary (node);\n+      size_time_entry *e;\n+      int i;\n       fprintf (f, \"Inline summary for %s/%i\", cgraph_node_name (node),\n \t       node->uid);\n       if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n@@ -137,16 +596,26 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n \tfprintf (f, \" inlinable\");\n       if (s->versionable)\n \tfprintf (f, \" versionable\");\n-      fprintf (f, \"\\n  self time:       %i, benefit: %i\\n\",\n-      \t       s->self_time, s->time_inlining_benefit);\n+      fprintf (f, \"\\n  self time:       %i\\n\",\n+\t       s->self_time);\n       fprintf (f, \"  global time:     %i\\n\", s->time);\n-      fprintf (f, \"  self size:       %i, benefit: %i\\n\",\n-\t       s->self_size, s->size_inlining_benefit);\n+      fprintf (f, \"  self size:       %i\\n\",\n+\t       s->self_size);\n       fprintf (f, \"  global size:     %i\\n\", s->size);\n       fprintf (f, \"  self stack:      %i\\n\",\n-\t       (int)s->estimated_self_stack_size);\n-      fprintf (f, \"  global stack:    %i\\n\\n\",\n-\t       (int)s->estimated_stack_size);\n+\t       (int) s->estimated_self_stack_size);\n+      fprintf (f, \"  global stack:    %i\\n\",\n+\t       (int) s->estimated_stack_size);\n+      for (i = 0;\n+\t   VEC_iterate (size_time_entry, s->entry, i, e);\n+\t   i++)\n+\t{\n+\t  fprintf (f, \"    size:%f, time:%f, predicate:\",\n+\t\t   (double) e->size / INLINE_SIZE_SCALE,\n+\t\t   (double) e->time / INLINE_TIME_SCALE);\n+\t  dump_predicate (f, s->conds, &e->predicate);\n+\t}\n+      fprintf (f, \"\\n\");\n     }\n }\n \n@@ -259,31 +728,164 @@ eliminated_by_inlining_prob (gimple stmt)\n }\n \n \n-/* Compute function body size parameters for NODE.  */\n+/* Return predicate that must be true when is E executable.  */\n+\n+static struct predicate\n+edge_execution_predicate (struct ipa_node_params *info,\n+\t\t\t  struct inline_summary *summary,\n+\t\t\t  edge e)\n+{\n+  struct predicate p = true_predicate ();\n+  gimple last;\n+  tree op;\n+  int index;\n+  enum tree_code code;\n+\n+  if (e->src == ENTRY_BLOCK_PTR)\n+    return p;\n+\n+  last = last_stmt (e->src);\n+  /* TODO: handle switch.  */\n+  if (!last\n+      || gimple_code (last) != GIMPLE_COND)\n+    return p;\n+  if (!is_gimple_ip_invariant (gimple_cond_rhs (last)))\n+    return p;\n+  op = gimple_cond_lhs (last);\n+  /* TODO: handle conditionals like\n+     var = op0 < 4;\n+     if (var != 0)\n+     and __bulitin_constant_p.  */\n+  if (TREE_CODE (op) != SSA_NAME\n+      || !SSA_NAME_IS_DEFAULT_DEF (op))\n+    return p;\n+  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op));\n+  if (index == -1)\n+    return p;\n+  code = gimple_cond_code (last);\n+\n+  if (EDGE_TRUE_VALUE)\n+    code = invert_tree_comparison (code,\n+\t\t\t\t   HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n+\n+  return add_condition (summary,\n+\t\t\tindex,\n+\t\t\tgimple_cond_code (last),\n+\t\t\tgimple_cond_rhs (last));\n+}\n+\n+static struct predicate\n+will_be_nonconstant_predicate (struct ipa_node_params *info,\n+\t\t\t       struct inline_summary *summary,\n+\t\t\t       gimple stmt)\n+{\n+  struct predicate p = true_predicate ();\n+  ssa_op_iter iter;\n+  tree use;\n+  struct predicate op_non_const;\n+\n+  /* What statments might be optimized away\n+     when their arguments are constant\n+     TODO: also trivial builtins, especially builtin_constant_p.  */\n+  if (gimple_code (stmt) != GIMPLE_ASSIGN\n+      && gimple_code (stmt) != GIMPLE_COND\n+      && gimple_code (stmt) != GIMPLE_SWITCH)\n+    return p;\n+\n+  /* Stores and loads will stay anyway.  */\n+  if (gimple_vuse (stmt))\n+    return p;\n+\n+  /* See if we understand all operands before we start\n+     adding conditionals.  */\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+    {\n+      /* TODO: handle nested expressions and constant\n+\t array accesses.  */\n+      if (TREE_CODE (use) != SSA_NAME\n+\t  || !SSA_NAME_IS_DEFAULT_DEF (use)\n+\t  || ipa_get_param_decl_index (info, SSA_NAME_VAR (use)) < 0)\n+\treturn p;\n+    }\n+  op_non_const = false_predicate ();\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+    {\n+      p = add_condition (summary,\n+\t\t\t ipa_get_param_decl_index (info, SSA_NAME_VAR (use)),\n+\t\t\t IS_NOT_CONSTANT, NULL);\n+      op_non_const = or_predicates (&p, &op_non_const);\n+    }\n+  return op_non_const;\n+}\n+\n+\n+/* Compute function body size parameters for NODE.\n+   When EARLY is true, we compute only simple summaries without\n+   non-trivial predicates to drive the early inliner.  */\n \n static void\n-estimate_function_body_sizes (struct cgraph_node *node)\n+estimate_function_body_sizes (struct cgraph_node *node, bool early)\n {\n   gcov_type time = 0;\n-  gcov_type time_inlining_benefit = 0;\n   /* Estimate static overhead for function prologue/epilogue and alignment. */\n   int size = 2;\n   /* Benefits are scaled by probability of elimination that is in range\n      <0,2>.  */\n-  int size_inlining_benefit = 2 * 2;\n   basic_block bb;\n   gimple_stmt_iterator bsi;\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   int freq;\n+  struct inline_summary *info = inline_summary (node);\n+  struct predicate bb_predicate;\n+  struct ipa_node_params *parms_info;\n+\n+  parms_info = ipa_node_params_vector && !early ? IPA_NODE_REF (node) : NULL;\n+\n+  info->conds = 0;\n+  info->entry = 0;\n+\n \n   if (dump_file)\n-    fprintf (dump_file, \"Analyzing function body size: %s\\n\",\n+    fprintf (dump_file, \"\\nAnalyzing function body size: %s\\n\",\n \t     cgraph_node_name (node));\n \n+  /* When we run into maximal number of entries, we assign everything to the\n+     constant truth case.  Be sure to have it in list. */\n+  bb_predicate = true_predicate ();\n+  account_size_time (info, 0, 0, &bb_predicate);\n+\n+  bb_predicate = not_inlined_predicate ();\n+  account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate);\n+\n+\n   gcc_assert (my_function && my_function->cfg);\n   FOR_EACH_BB_FN (bb, my_function)\n     {\n+      edge e;\n+      edge_iterator ei;\n+\n       freq = compute_call_stmt_bb_frequency (node->decl, bb);\n+\n+      /* TODO: Obviously predicates can be propagated down across CFG.  */\n+      if (parms_info)\n+\t{\n+          bb_predicate = false_predicate ();\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      struct predicate ep;\n+\t      ep = edge_execution_predicate (parms_info, info, e);\n+\t      bb_predicate = or_predicates (&ep, &bb_predicate);\n+\t    }\n+\t}\n+      else\n+\tbb_predicate = true_predicate ();\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"\\n BB %i predicate:\", bb->index);\n+\t  dump_predicate (dump_file, info->conds, &bb_predicate);\n+\t}\n+      \n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n \t  gimple stmt = gsi_stmt (bsi);\n@@ -293,9 +895,10 @@ estimate_function_body_sizes (struct cgraph_node *node)\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      fprintf (dump_file, \"  freq:%6i size:%3i time:%3i \",\n-\t\t       freq, this_size, this_time);\n+\t      fprintf (dump_file, \"  \");\n \t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t      fprintf (dump_file, \"\\t\\tfreq:%3.2f size:%3i time:%3i\\n\",\n+\t\t       ((double)freq)/CGRAPH_FREQ_BASE, this_size, this_time);\n \t    }\n \n \t  if (is_gimple_call (stmt))\n@@ -304,8 +907,8 @@ estimate_function_body_sizes (struct cgraph_node *node)\n \t      edge->call_stmt_size = this_size;\n \t      edge->call_stmt_time = this_time;\n \n-\t      /* Do not inline calls where we cannot triviall work around mismatches\n-\t\t in argument or return types.  */\n+\t      /* Do not inline calls where we cannot triviall work around\n+\t\t mismatches in argument or return types.  */\n \t      if (edge->callee\n \t\t  && !gimple_check_call_matching_types (stmt, edge->callee->decl))\n \t\t{\n@@ -316,46 +919,70 @@ estimate_function_body_sizes (struct cgraph_node *node)\n \t\tgcc_assert (!gimple_call_cannot_inline_p (stmt));\n \t    }\n \n-\t  this_time *= freq;\n-\t  time += this_time;\n-\t  size += this_size;\n+\t  if (this_time || this_size)\n+\t    {\n+\t      struct predicate will_be_nonconstant;\n+\t      struct predicate p;\n+\n+\t      this_time *= freq;\n+\t      time += this_time;\n+\t      size += this_size;\n \n-\t  prob = eliminated_by_inlining_prob (stmt);\n-\t  if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"    50%% will be eliminated by inlining\\n\");\n-\t  if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"    will eliminated by inlining\\n\");\n+\t      prob = eliminated_by_inlining_prob (stmt);\n+\t      if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"\\t\\t50%% will be eliminated by inlining\\n\");\n+\t      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"\\t\\twill eliminated by inlining\\n\");\n+\n+\t      if (parms_info)\n+\t\t{\n+\t\t  will_be_nonconstant\n+\t\t     = will_be_nonconstant_predicate (parms_info, info, stmt);\n+\t\t  p = and_predicates (&bb_predicate, &will_be_nonconstant);\n+\t\t}\n+\t      else\n+\t\tp = true_predicate ();\n \n-\t  size_inlining_benefit += this_size * prob;\n-\t  time_inlining_benefit += this_time * prob;\n+\t      /* We account everything but the calls.  Calls have their own\n+\t\t size/time info attached to cgraph edges.  This is neccesary\n+\t\t in order to make the cost disappear after inlining.  */\n+\t      if (!is_gimple_call (stmt))\n+\t\t{\n+\t\t  if (prob)\n+\t\t    {\n+\t\t      struct predicate ip = not_inlined_predicate ();\n+\t\t      ip = and_predicates (&ip, &p);\n+\t\t      account_size_time (info, this_size * prob,\n+\t\t\t\t\t this_time * prob, &ip);\n+\t\t    }\n+\t\t  if (prob != 2)\n+\t\t    account_size_time (info, this_size * (2 - prob),\n+\t\t\t\t       this_time * (2 - prob), &p);\n+\t\t}\n \n-\t  gcc_assert (time >= 0);\n-\t  gcc_assert (size >= 0);\n+\t      gcc_assert (time >= 0);\n+\t      gcc_assert (size >= 0);\n+\t    }\n \t}\n     }\n   time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n-  time_inlining_benefit = ((time_inlining_benefit + CGRAPH_FREQ_BASE)\n-  \t\t\t   / (CGRAPH_FREQ_BASE * 2));\n-  size_inlining_benefit = (size_inlining_benefit + 1) / 2;\n-  if (time_inlining_benefit > MAX_TIME)\n-    time_inlining_benefit = MAX_TIME;\n   if (time > MAX_TIME)\n     time = MAX_TIME;\n-  if (dump_file)\n-    fprintf (dump_file, \"Overall function body time: %i-%i size: %i-%i\\n\",\n-\t     (int)time, (int)time_inlining_benefit,\n-\t     size, size_inlining_benefit);\n   inline_summary (node)->self_time = time;\n   inline_summary (node)->self_size = size;\n-  inline_summary (node)->time_inlining_benefit = time_inlining_benefit;\n-  inline_summary (node)->size_inlining_benefit = size_inlining_benefit;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n\");\n+      dump_inline_summary (dump_file, node);\n+    }\n }\n \n \n-/* Compute parameters of functions used by inliner.  */\n+/* Compute parameters of functions used by inliner.\n+   EARLY is true when we compute parameters for the early inliner  */\n \n void\n-compute_inline_parameters (struct cgraph_node *node)\n+compute_inline_parameters (struct cgraph_node *node, bool early)\n {\n   HOST_WIDE_INT self_stack_size;\n   struct cgraph_edge *e;\n@@ -389,12 +1016,11 @@ compute_inline_parameters (struct cgraph_node *node)\n \t  break;\n       node->local.can_change_signature = !e;\n     }\n-  estimate_function_body_sizes (node);\n+  estimate_function_body_sizes (node, early);\n \n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n   info->time = info->self_time;\n   info->size = info->self_size;\n-  info->estimated_growth = INT_MIN;\n   info->stack_frame_offset = 0;\n   info->estimated_stack_size = info->estimated_self_stack_size;\n }\n@@ -406,7 +1032,7 @@ compute_inline_parameters (struct cgraph_node *node)\n static unsigned int\n compute_inline_parameters_for_current (void)\n {\n-  compute_inline_parameters (cgraph_get_node (current_function_decl));\n+  compute_inline_parameters (cgraph_get_node (current_function_decl), true);\n   return 0;\n }\n \n@@ -430,20 +1056,279 @@ struct gimple_opt_pass pass_inline_parameters =\n };\n \n \n-/* Estimate the time cost for the caller when inlining EDGE.  */\n+/* Increase SIZE and TIME for size and time needed to handle edge E.  */\n+\n+static void\n+estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time)\n+{\n+  *size += e->call_stmt_size * INLINE_SIZE_SCALE;\n+  *time += (e->call_stmt_time\n+\t    * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE));\n+  if (*time > MAX_TIME * INLINE_TIME_SCALE)\n+    *time = MAX_TIME * INLINE_TIME_SCALE;\n+}\n+\n+\n+/* Increase SIZE and TIME for size and time needed to handle all calls in NODE.  */\n+\n+static void\n+estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time)\n+{\n+  struct cgraph_edge *e;\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (e->inline_failed)\n+      estimate_edge_size_and_time (e, size, time);\n+    else\n+      estimate_calls_size_and_time (e->callee, size, time);\n+  /* TODO: look for devirtualizing oppurtunities.  */\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    estimate_edge_size_and_time (e, size, time);\n+}\n+\n+\n+/* Estimate size and time needed to execute callee of EDGE assuming\n+   that parameters known to be constant at caller of EDGE are\n+   propagated.  If INLINE_P is true, it is assumed that call will\n+   be inlined.  */\n \n-static inline int\n-estimate_edge_time (struct cgraph_edge *edge)\n+static void\n+estimate_callee_size_and_time (struct cgraph_edge *edge, bool inline_p,\n+\t\t       \t       int *ret_size, int *ret_time)\n {\n-  int call_stmt_time;\n   struct inline_summary *info = inline_summary (edge->callee);\n+  clause_t clause = evaulate_conditions_for_edge (edge, inline_p);\n+  size_time_entry *e;\n+  int size = 0, time = 0;\n+  int i;\n+\n+  if (dump_file\n+      && (dump_flags & TDF_DETAILS))\n+    {\n+      bool found = false;\n+      fprintf (dump_file, \"   Estimating callee body: %s/%i\\n\"\n+\t\t\t  \"   Known to be false: \",\n+\t       cgraph_node_name (edge->callee),\n+\t       edge->callee->uid);\n+\n+      for (i = predicate_not_inlined_condition;\n+\t   i < (predicate_first_dynamic_condition\n+\t\t+ (int)VEC_length (condition, info->conds)); i++)\n+\tif (!(clause & (1 << i)))\n+\t  {\n+\t    if (found)\n+\t      fprintf (dump_file, \", \");\n+\t    found = true;\n+            dump_condition (dump_file, info->conds, i);\n+\t  }\n+    }\n+\n+  for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n+    if (evaulate_predicate (&e->predicate, clause))\n+      time += e->time, size += e->size;\n \n-  call_stmt_time = edge->call_stmt_time;\n-  gcc_checking_assert (call_stmt_time);\n-  return (((gcov_type)info->time\n-\t   - info->time_inlining_benefit\n-\t   - call_stmt_time) * edge->frequency\n-\t  + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n+  if (time > MAX_TIME * INLINE_TIME_SCALE)\n+    time = MAX_TIME * INLINE_TIME_SCALE;\n+\n+  estimate_calls_size_and_time (edge->callee, &size, &time);\n+  time = (time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n+  size = (size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n+\n+\n+  if (dump_file\n+      && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n   size:%i time:%i\\n\", size, time);\n+  if (ret_time)\n+    *ret_time = time;\n+  if (ret_size)\n+    *ret_size = size;\n+  return;\n+}\n+\n+\n+/* Translate all conditions from callee representation into caller representaiton and\n+   symbolically evaulate predicate P into new predicate.  */\n+\n+static struct predicate\n+remap_predicate (struct inline_summary *info, struct inline_summary *callee_info,\n+\t\t struct predicate *p,\n+\t\t VEC (int, heap) *operand_map,\n+\t\t clause_t possible_truths)\n+{\n+  int i;\n+  struct predicate out = true_predicate ();\n+\n+  /* True predicate is easy.  */\n+  if (p->clause[0] == 0)\n+    return *p;\n+  for (i = 0; p->clause[i]; i++)\n+    {\n+      clause_t clause = p->clause[i];\n+      int cond;\n+      struct predicate clause_predicate = false_predicate ();\n+\n+      for (cond = 0; cond < NUM_CONDITIONS; cond ++)\n+\t/* Do we have condition we can't disprove?   */\n+\tif (clause & possible_truths & (1 << cond))\n+\t  {\n+\t    struct predicate cond_predicate;\n+\t    /* Work out if the condition can translate to predicate in the\n+\t       inlined function.  */\n+\t    if (cond >= predicate_first_dynamic_condition)\n+\t      {\n+\t\t struct condition *c;\n+\n+\t\t c = VEC_index (condition, callee_info->conds,\n+\t\t\t\tcond - predicate_first_dynamic_condition);\n+\t\t /* See if we can remap condition operand to caller's operand.\n+\t\t    Otherwise give up.  */\n+\t\t if (!operand_map\n+\t\t     || VEC_index (int, operand_map, c->operand_num) == -1)\n+\t\t   cond_predicate = true_predicate ();\n+\t\t else\n+\t\t   cond_predicate = add_condition (info,\n+\t\t\t\t\t\t   VEC_index (int, operand_map,\n+\t\t\t\t\t\t\t      c->operand_num),\n+\t\t\t\t\t\t   c->code, c->val);\n+\t      }\n+\t    /* Fixed conditions remains same, construct single\n+\t       condition predicate.  */\n+\t    else\n+\t      {\n+\t\tcond_predicate.clause[0] = 1 << cond;\n+\t\tcond_predicate.clause[1] = 0;\n+\t      }\n+\t    clause_predicate = or_predicates (&clause_predicate, &cond_predicate);\n+\t  }\n+      out = and_predicates (&out, &clause_predicate);\n+    }\n+  return out;\n+}\n+\n+\n+/* We inlined EDGE.  Update summary of the function we inlined into.  */\n+\n+void\n+inline_merge_summary (struct cgraph_edge *edge)\n+{\n+  struct inline_summary *callee_info = inline_summary (edge->callee);\n+  struct cgraph_node *to = (edge->caller->global.inlined_to\n+\t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n+  struct inline_summary *info = inline_summary (to);\n+  clause_t clause = 0;\t\t/* not_inline is known to be false.  */\n+  size_time_entry *e;\n+  VEC (int, heap) *operand_map = NULL;\n+  int i;\n+\n+  if (ipa_node_params_vector && callee_info->conds\n+      /* FIXME: it seems that we forget to get argument count in some cases,\n+\t probaby for previously indirect edges or so.\n+\t Removing the test leads to ICE on tramp3d.  */\n+      && ipa_get_cs_argument_count (IPA_EDGE_REF (edge)))\n+    {\n+      struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n+      int count = ipa_get_cs_argument_count (args);\n+      int i;\n+\n+      clause = evaulate_conditions_for_edge (edge, true);\n+      VEC_safe_grow_cleared (int, heap, operand_map, count);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, i);\n+\t  int map = -1;\n+\t  /* TODO: handle non-NOPs when merging.  */\n+\t  if (jfunc->type == IPA_JF_PASS_THROUGH\n+\t      && jfunc->value.pass_through.operation == NOP_EXPR)\n+\t    map = jfunc->value.pass_through.formal_id;\n+\t  VEC_replace (int, operand_map, i, map);\n+\t}\n+    }\n+  for (i = 0; VEC_iterate (size_time_entry, callee_info->entry, i, e); i++)\n+    {\n+      struct predicate p = remap_predicate (info, callee_info,\n+\t\t\t\t\t    &e->predicate, operand_map, clause);\n+      gcov_type add_time = ((gcov_type)e->time * edge->frequency\n+\t\t\t    + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n+      if (add_time > MAX_TIME)\n+\tadd_time = MAX_TIME;\n+      account_size_time (info, e->size, add_time, &p);\n+    }\n+  info->size = 0;\n+  info->time = 0;\n+  for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n+    info->size += e->size, info->time += e->time;\n+  estimate_calls_size_and_time (to, &info->size, &info->time);\n+  info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n+  info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n+}\n+\n+\n+/* Estimate the time cost for the caller when inlining EDGE.\n+   Only to be called via estimate_edge_time, that handles the\n+   caching mechanism.\n+\n+   When caching, also update the cache entry.  Compute both time and\n+   size, since we always need both metrics eventually.  */\n+\n+int\n+do_estimate_edge_time (struct cgraph_edge *edge)\n+{\n+  int time;\n+  int size;\n+  gcov_type ret;\n+\n+  gcc_checking_assert (edge->inline_failed);\n+  estimate_callee_size_and_time (edge, true, &size, &time);\n+\n+  ret = (((gcov_type)time - edge->call_stmt_time) * edge->frequency\n+\t + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n+  if (ret > MAX_TIME)\n+    ret = MAX_TIME;\n+\n+  /* When caching, update the cache entry.  */\n+  if (edge_growth_cache)\n+    {\n+      int ret_size;\n+      if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache)\n+\t  <= edge->uid)\n+\tVEC_safe_grow_cleared (edge_growth_cache_entry, heap, edge_growth_cache,\n+\t\t\t       cgraph_edge_max_uid);\n+      VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid)->time\n+\t= ret + (ret >= 0);\n+\n+      ret_size = size - edge->call_stmt_size;\n+      gcc_checking_assert (edge->call_stmt_size);\n+      VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid)->size\n+\t= ret_size + (ret_size >= 0);\n+    }\n+  return ret;\n+}\n+\n+\n+/* Estimate the growth of the caller when inlining EDGE.\n+   Only to be called via estimate_edge_size.  */\n+\n+int\n+do_estimate_edge_growth (struct cgraph_edge *edge)\n+{\n+  int size;\n+\n+  /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n+\n+  if (edge_growth_cache)\n+    {\n+      do_estimate_edge_time (edge);\n+      size = VEC_index (edge_growth_cache_entry,\n+\t\t\tedge_growth_cache,\n+\t\t\tedge->uid)->size;\n+      gcc_checking_assert (size);\n+      return size - (size > 0);\n+    }\n+\n+  /* Early inliner runs without caching, go ahead and do the dirty work.  */\n+  gcc_checking_assert (edge->inline_failed);\n+  estimate_callee_size_and_time (edge, true, &size, NULL);\n+  gcc_checking_assert (edge->call_stmt_size);\n+  return size - edge->call_stmt_size;\n }\n \n \n@@ -478,16 +1363,13 @@ estimate_size_after_inlining (struct cgraph_node *node,\n /* Estimate the growth caused by inlining NODE into all callees.  */\n \n int\n-estimate_growth (struct cgraph_node *node)\n+do_estimate_growth (struct cgraph_node *node)\n {\n   int growth = 0;\n   struct cgraph_edge *e;\n   bool self_recursive = false;\n   struct inline_summary *info = inline_summary (node);\n \n-  if (info->estimated_growth != INT_MIN)\n-    return info->estimated_growth;\n-\n   for (e = node->callers; e; e = e->next_caller)\n     {\n       gcc_checking_assert (e->inline_failed);\n@@ -519,7 +1401,12 @@ estimate_growth (struct cgraph_node *node)\n \t\t   * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY)) + 50) / 100;\n     }\n \n-  info->estimated_growth = growth;\n+  if (node_growth_cache)\n+    {\n+      if ((int)VEC_length (int, node_growth_cache) <= node->uid)\n+\tVEC_safe_grow_cleared (int, heap, node_growth_cache, cgraph_max_uid);\n+      VEC_replace (int, node_growth_cache, node->uid, growth + (growth >= 0));\n+    }\n   return growth;\n }\n \n@@ -547,11 +1434,14 @@ inline_analyze_function (struct cgraph_node *node)\n   push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n   current_function_decl = node->decl;\n \n-  compute_inline_parameters (node);\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nAnalyzing function: %s/%u\\n\",\n+\t     cgraph_node_name (node), node->uid);\n   /* FIXME: We should remove the optimize check after we ensure we never run\n      IPA passes when not optimizing.  */\n   if (flag_indirect_inlining && optimize)\n     inline_indirect_intraprocedural_analysis (node);\n+  compute_inline_parameters (node, false);\n \n   current_function_decl = NULL;\n   pop_cfun ();\n@@ -586,6 +1476,87 @@ inline_generate_summary (void)\n }\n \n \n+/* Stream in inline summaries from the section.  */\n+\n+static void\n+inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n+\t\t     size_t len)\n+{\n+  const struct lto_function_header *header =\n+    (const struct lto_function_header *) data;\n+  const int32_t cfg_offset = sizeof (struct lto_function_header);\n+  const int32_t main_offset = cfg_offset + header->cfg_size;\n+  const int32_t string_offset = main_offset + header->main_size;\n+  struct data_in *data_in;\n+  struct lto_input_block ib;\n+  unsigned int i, count2, j;\n+  unsigned int f_count;\n+\n+  LTO_INIT_INPUT_BLOCK (ib, (const char *) data + main_offset, 0,\n+\t\t\theader->main_size);\n+\n+  data_in =\n+    lto_data_in_create (file_data, (const char *) data + string_offset,\n+\t\t\theader->string_size, NULL);\n+  f_count = lto_input_uleb128 (&ib);\n+  for (i = 0; i < f_count; i++)\n+    {\n+      unsigned int index;\n+      struct cgraph_node *node;\n+      struct inline_summary *info;\n+      lto_cgraph_encoder_t encoder;\n+      struct bitpack_d bp;\n+\n+      index = lto_input_uleb128 (&ib);\n+      encoder = file_data->cgraph_node_encoder;\n+      node = lto_cgraph_encoder_deref (encoder, index);\n+      info = inline_summary (node);\n+\n+      info->estimated_stack_size\n+\t= info->estimated_self_stack_size = lto_input_uleb128 (&ib);\n+      info->size = info->self_size = lto_input_uleb128 (&ib);\n+      info->time = info->self_time = lto_input_uleb128 (&ib);\n+\n+      bp = lto_input_bitpack (&ib);\n+      info->inlinable = bp_unpack_value (&bp, 1);\n+      info->versionable = bp_unpack_value (&bp, 1);\n+\n+      count2 = lto_input_uleb128 (&ib);\n+      gcc_assert (!info->conds);\n+      for (j = 0; j < count2; j++)\n+\t{\n+\t  struct condition c;\n+\t  c.operand_num = lto_input_uleb128 (&ib);\n+\t  c.code = (enum tree_code) lto_input_uleb128 (&ib);\n+\t  c.val = lto_input_tree (&ib, data_in);\n+\t  VEC_safe_push (condition, gc, info->conds, &c);\n+\t}\n+      count2 = lto_input_uleb128 (&ib);\n+      gcc_assert (!info->entry);\n+      for (j = 0; j < count2; j++)\n+\t{\n+\t  struct size_time_entry e;\n+\t  clause_t clause;\n+\t  int k = 0;\n+\n+\t  e.size = lto_input_uleb128 (&ib);\n+\t  e.time = lto_input_uleb128 (&ib);\n+\t  do \n+\t    {\n+\t      clause = e.predicate.clause[k++] = lto_input_uleb128 (&ib);\n+\t    }\n+\t  while (clause);\n+\n+\t  VEC_safe_push (size_time_entry, gc, info->entry, &e);\n+\t}\n+    }\n+\n+  lto_free_section_data (file_data, LTO_section_inline_summary, NULL, data,\n+\t\t\t len);\n+  lto_data_in_delete (data_in);\n+}\n+\n+\n /* Read inline summary.  Jump functions are shared among ipa-cp\n    and inliner, so when ipa-cp is active, we don't need to write them\n    twice.  */\n@@ -603,46 +1574,8 @@ inline_read_summary (void)\n     {\n       size_t len;\n       const char *data = lto_get_section_data (file_data, LTO_section_inline_summary, NULL, &len);\n-\n-      struct lto_input_block *ib\n-\t= lto_create_simple_input_block (file_data,\n-\t\t\t\t\t LTO_section_inline_summary,\n-\t\t\t\t\t &data, &len);\n-      if (ib)\n-\t{\n-\t  unsigned int i;\n-\t  unsigned int f_count = lto_input_uleb128 (ib);\n-\n-\t  for (i = 0; i < f_count; i++)\n-\t    {\n-\t      unsigned int index;\n-\t      struct cgraph_node *node;\n-\t      struct inline_summary *info;\n-\t      lto_cgraph_encoder_t encoder;\n-\t      struct bitpack_d bp;\n-\n-\t      index = lto_input_uleb128 (ib);\n-\t      encoder = file_data->cgraph_node_encoder;\n-\t      node = lto_cgraph_encoder_deref (encoder, index);\n-\t      info = inline_summary (node);\n-\n-\t      info->estimated_stack_size\n-\t        = info->estimated_self_stack_size = lto_input_uleb128 (ib);\n-\t      info->size = info->self_size = lto_input_uleb128 (ib);\n-\t      info->size_inlining_benefit = lto_input_uleb128 (ib);\n-\t      info->time = info->self_time = lto_input_uleb128 (ib);\n-\t      info->time_inlining_benefit = lto_input_uleb128 (ib);\n-\t      info->estimated_growth = INT_MIN;\n-\n-\t      bp = lto_input_bitpack (ib);\n-\t      info->inlinable = bp_unpack_value (&bp, 1);\n-\t      info->versionable = bp_unpack_value (&bp, 1);\n-\t    }\n-\n-\t  lto_destroy_simple_input_block (file_data,\n-\t\t\t\t\t  LTO_section_inline_summary,\n-\t\t\t\t\t  ib, data, len);\n-\t}\n+      if (data)\n+        inline_read_section (file_data, data, len);\n       else\n \t/* Fatal error here.  We do not want to support compiling ltrans units with\n \t   different version of compiler or different flags than the WPA unit, so\n@@ -669,8 +1602,7 @@ inline_write_summary (cgraph_node_set set,\n \t\t      varpool_node_set vset ATTRIBUTE_UNUSED)\n {\n   struct cgraph_node *node;\n-  struct lto_simple_output_block *ob\n-    = lto_create_simple_output_block (LTO_section_inline_summary);\n+  struct output_block *ob = create_output_block (LTO_section_inline_summary);\n   lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n   unsigned int count = 0;\n   int i;\n@@ -687,26 +1619,54 @@ inline_write_summary (cgraph_node_set set,\n \t{\n \t  struct inline_summary *info = inline_summary (node);\n \t  struct bitpack_d bp;\n+\t  int i;\n+\t  size_time_entry *e;\n+\t  struct condition *c;\n+\t  \n \n \t  lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t     lto_cgraph_encoder_encode (encoder, node));\n \t  lto_output_sleb128_stream (ob->main_stream,\n \t\t\t\t     info->estimated_self_stack_size);\n \t  lto_output_sleb128_stream (ob->main_stream,\n \t\t\t\t     info->self_size);\n-\t  lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t     info->size_inlining_benefit);\n \t  lto_output_sleb128_stream (ob->main_stream,\n \t\t\t\t     info->self_time);\n-\t  lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t     info->time_inlining_benefit);\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, info->inlinable, 1);\n \t  bp_pack_value (&bp, info->versionable, 1);\n \t  lto_output_bitpack (&bp);\n+\t  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t     VEC_length (condition, info->conds));\n+\t  for (i = 0; VEC_iterate (condition, info->conds, i, c); i++)\n+\t    {\n+\t      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t\t c->operand_num);\n+\t      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t\t c->code);\n+\t      lto_output_tree (ob, c->val, true);\n+\t    }\n+\t  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t     VEC_length (size_time_entry, info->entry));\n+\t  for (i = 0;\n+\t       VEC_iterate (size_time_entry, info->entry, i, e);\n+\t       i++)\n+\t    {\n+\t      int j;\n+\t      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t\t e->time);\n+\t      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t\t e->size);\n+\t      for (j = 0; e->predicate.clause[j]; j++)\n+\t\tlto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t\t   e->predicate.clause[j]);\n+\t      lto_output_uleb128_stream (ob->main_stream, 0);\n+\t    }\n \t}\n     }\n-  lto_destroy_simple_output_block (ob);\n+  lto_output_1_stream (ob->main_stream, 0);\n+  produce_asm (ob, NULL);\n+  destroy_output_block (ob);\n \n   if (flag_indirect_inlining && !flag_ipa_cp)\n     ipa_prop_write_jump_functions (set);\n@@ -727,5 +1687,6 @@ inline_free_summary (void)\n   if (node_duplication_hook_holder)\n     cgraph_remove_node_duplication_hook (node_duplication_hook_holder);\n   node_duplication_hook_holder = NULL;\n-  VEC_free (inline_summary_t, heap, inline_summary_vec);\n+  VEC_free (inline_summary_t, gc, inline_summary_vec);\n+  inline_summary_vec = NULL;\n }"}, {"sha": "1fdb6d01ad7eb146bf5f7a63de1870252c02105c", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -175,7 +175,6 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   int old_size = 0, new_size = 0;\n   struct cgraph_node *to = NULL;\n   struct cgraph_edge *curr = e;\n-  struct inline_summary *info;\n \n   /* Don't inline inlined edges.  */\n   gcc_assert (e->inline_failed);\n@@ -185,18 +184,15 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   e->inline_failed = CIF_OK;\n   DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n \n+  to = e->caller;\n+  if (to->global.inlined_to)\n+    to = to->global.inlined_to;\n+  old_size = inline_summary (to)->size;\n+  inline_merge_summary (e);\n+  new_size = inline_summary (to)->size;\n+\n   clone_inlined_nodes (e, true, update_original, overall_size);\n \n-  /* Now update size of caller and all functions caller is inlined into.  */\n-  for (;e && !e->inline_failed; e = e->caller->callers)\n-    {\n-      to = e->caller;\n-      info = inline_summary (to);\n-      old_size = info->size;\n-      new_size = estimate_size_after_inlining (to, curr);\n-      info->size = new_size;\n-      info->time = estimate_time_after_inlining (to, curr);\n-    }\n   gcc_assert (curr->callee->global.inlined_to == to);\n   if (overall_size && new_size > old_size)\n     *overall_size += new_size - old_size;"}, {"sha": "02cc77389609cff534cefc5c090da23b25ae0033", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -117,7 +117,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Statistics we collect about inlining algorithm.  */\n static int overall_size;\n-static gcov_type max_count, max_benefit;\n+static gcov_type max_count;\n \n /* Return false when inlining edge E would lead to violating\n    limits on function unit growth or stack usage growth.  \n@@ -633,27 +633,23 @@ static int\n edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   gcov_type badness;\n-  int growth;\n+  int growth, time_growth;\n   struct inline_summary *callee_info = inline_summary (edge->callee);\n \n   if (DECL_DISREGARD_INLINE_LIMITS (edge->callee->decl))\n     return INT_MIN;\n \n   growth = estimate_edge_growth (edge);\n+  time_growth = estimate_edge_time (edge);\n \n   if (dump)\n     {\n       fprintf (dump_file, \"    Badness calculation for %s -> %s\\n\",\n \t       cgraph_node_name (edge->caller),\n \t       cgraph_node_name (edge->callee));\n-      fprintf (dump_file, \"      growth %i, time %i-%i, size %i-%i\\n\",\n+      fprintf (dump_file, \"      growth size %i, time %i\\n\",\n \t       growth,\n-\t       callee_info->time,\n-\t       callee_info->time_inlining_benefit\n-\t       + edge->call_stmt_time,\n-\t       callee_info->size,\n-\t       callee_info->size_inlining_benefit\n-\t       + edge->call_stmt_size);\n+\t       time_growth);\n     }\n \n   /* Always prefer inlining saving code size.  */\n@@ -669,11 +665,16 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      So we optimize for overall number of \"executed\" inlined calls.  */\n   else if (max_count)\n     {\n+      int benefitperc;\n+      benefitperc = (((gcov_type)callee_info->time\n+\t\t     * edge->frequency / CGRAPH_FREQ_BASE - time_growth) * 100\n+\t\t     / (callee_info->time + 1) + 1);\n+      benefitperc = MIN (benefitperc, 100);\n+      benefitperc = MAX (benefitperc, 0);\n       badness =\n \t((int)\n-\t ((double) edge->count * INT_MIN / max_count / (max_benefit + 1)) *\n-\t (callee_info->time_inlining_benefit\n-\t  + edge->call_stmt_time + 1)) / growth;\n+\t ((double) edge->count * INT_MIN / max_count / 100) *\n+\t benefitperc) / growth;\n       \n       /* Be sure that insanity of the profile won't lead to increasing counts\n \t in the scalling and thus to overflow in the computation above.  */\n@@ -685,9 +686,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   \" * Relative benefit %f\\n\",\n \t\t   (int) badness, (double) badness / INT_MIN,\n \t\t   (double) edge->count / max_count,\n-\t\t   (double) (inline_summary (edge->callee)->\n-\t\t\t     time_inlining_benefit\n-\t\t\t     + edge->call_stmt_time + 1) / (max_benefit + 1));\n+\t\t   (double) benefitperc);\n \t}\n     }\n \n@@ -706,11 +705,11 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n       int benefitperc;\n       int growth_for_all;\n       badness = growth * 10000;\n-      benefitperc =\n-\t100 * (callee_info->time_inlining_benefit\n-\t       + edge->call_stmt_time)\n-\t    / (callee_info->time + 1) + 1;\n+      benefitperc = (((gcov_type)callee_info->time\n+\t\t     * edge->frequency / CGRAPH_FREQ_BASE - time_growth) * 100\n+\t\t     / (callee_info->time + 1) + 1);\n       benefitperc = MIN (benefitperc, 100);\n+      benefitperc = MAX (benefitperc, 0);\n       div *= benefitperc;\n \n       /* Decrease badness if call is nested.  */\n@@ -822,7 +821,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n-  inline_summary (node)->estimated_growth = INT_MIN;\n+  reset_node_growth_cache (node);\n \n   /* See if there is something to do.  */\n   for (edge = node->callers; edge; edge = edge->next_caller)\n@@ -834,6 +833,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   for (; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       {\n+\treset_edge_growth_cache (edge);\n \tif (can_inline_edge_p (edge, false)\n \t    && want_inline_small_function_p (edge, false))\n           update_edge_key (heap, edge);\n@@ -857,7 +857,7 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n {\n   struct cgraph_edge *e = node->callees;\n \n-  inline_summary (node)->estimated_growth = INT_MIN;\n+  reset_node_growth_cache (node);\n \n   if (!e)\n     return;\n@@ -866,12 +866,13 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n       e = e->callee->callees;\n     else\n       {\n+\treset_edge_growth_cache (e);\n \tif (e->inline_failed\n \t    && inline_summary (e->callee)->inlinable\n \t    && cgraph_function_body_availability (e->callee) >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, e->callee->uid))\n \t  {\n-\t    inline_summary (node)->estimated_growth = INT_MIN;\n+\t    reset_node_growth_cache (node);\n \t    update_edge_key (heap, e);\n \t  }\n \tif (e->next_callee)\n@@ -899,7 +900,7 @@ update_all_callee_keys (fibheap_t heap, struct cgraph_node *node,\n {\n   struct cgraph_edge *e = node->callees;\n \n-  inline_summary (node)->estimated_growth = INT_MIN;\n+  reset_node_growth_cache (node);\n \n   if (!e)\n     return;\n@@ -1131,28 +1132,20 @@ inline_small_functions (void)\n      metrics.  */\n \n   max_count = 0;\n-  max_benefit = 0;\n+  initialize_growth_caches ();\n \n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed\n \t&& !node->global.inlined_to)\n       {\n \tstruct inline_summary *info = inline_summary (node);\n \n-\tinfo->estimated_growth = INT_MIN;\n-\n \tif (!DECL_EXTERNAL (node->decl))\n \t  initial_size += info->size;\n \n \tfor (edge = node->callers; edge; edge = edge->next_caller)\n-\t  {\n-\t    int benefit = (info->time_inlining_benefit\n-\t\t\t   + edge->call_stmt_time);\n-\t    if (max_count < edge->count)\n-\t      max_count = edge->count;\n-\t    if (max_benefit < benefit)\n-\t      max_benefit = benefit;\n-\t   }\n+\t  if (max_count < edge->count)\n+\t    max_count = edge->count;\n       }\n \n   overall_size = initial_size;\n@@ -1354,22 +1347,23 @@ inline_small_functions (void)\n \t}\n     }\n \n+  free_growth_caches ();\n   if (new_indirect_edges)\n     VEC_free (cgraph_edge_p, heap, new_indirect_edges);\n   fibheap_delete (heap);\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"Unit growth for small function inlining: %i->%i (%i%%)\\n\",\n-\t     overall_size, initial_size,\n-\t     overall_size * 100 / (initial_size + 1) - 100);\n+\t     initial_size, overall_size,\n+\t     initial_size ? overall_size * 100 / (initial_size) - 100: 0);\n   BITMAP_FREE (updated_nodes);\n }\n \n /* Flatten NODE.  Performed both during early inlining and\n    at IPA inlining time.  */\n \n static void\n-flatten_function (struct cgraph_node *node)\n+flatten_function (struct cgraph_node *node, bool early)\n {\n   struct cgraph_edge *e;\n \n@@ -1398,14 +1392,14 @@ flatten_function (struct cgraph_node *node)\n \t it in order to fully flatten the leaves.  */\n       if (!e->inline_failed)\n \t{\n-\t  flatten_function (e->callee);\n+\t  flatten_function (e->callee, early);\n \t  continue;\n \t}\n \n       /* Flatten attribute needs to be processed during late inlining. For\n \t extra code quality we however do flattening during early optimization,\n \t too.  */\n-      if (cgraph_state != CGRAPH_STATE_IPA_SSA\n+      if (!early\n \t  ? !can_inline_edge_p (e, true)\n \t  : !can_early_inline_edge_p (e))\n \tcontinue;\n@@ -1435,7 +1429,7 @@ flatten_function (struct cgraph_node *node)\n       inline_call (e, true, NULL, NULL);\n       if (e->callee != orig_callee)\n \torig_callee->aux = (void *) node;\n-      flatten_function (e->callee);\n+      flatten_function (e->callee, early);\n       if (e->callee != orig_callee)\n \torig_callee->aux = NULL;\n     }\n@@ -1488,7 +1482,7 @@ ipa_inline (void)\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Flattening %s\\n\", cgraph_node_name (node));\n-\t  flatten_function (node);\n+\t  flatten_function (node, false);\n \t}\n     }\n \n@@ -1696,7 +1690,7 @@ early_inliner (void)\n       if (dump_file)\n \tfprintf (dump_file,\n \t\t \"Flattening %s\\n\", cgraph_node_name (node));\n-      flatten_function (node);\n+      flatten_function (node, true);\n       inlined = true;\n     }\n   else"}, {"sha": "4fe4489e8cf8a0d70c568d994629df7195cfe8ce", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 139, "deletions": 21, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -19,22 +19,69 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Function inlining information.  */\n+/* Representation of inline parameters that do depend on context function is\n+   inlined into (i.e. known constant values of function parameters.\n+\n+   Conditions that are interesting for function body are collected into CONDS\n+   vector.  They are of simple for  function_param OP VAL, where VAL is\n+   IPA invariant.  The conditions are then refered by predicates.  */\n+\n+typedef struct GTY(()) condition\n+  {\n+    tree val;\n+    int operand_num;\n+    enum tree_code code;\n+  } condition;\n+\n+DEF_VEC_O (condition);\n+DEF_VEC_ALLOC_O (condition, gc);\n+\n+typedef VEC(condition,gc) *conditions;\n+\n+/* Representation of predicates i.e. formulas using conditions defined\n+   above.  Predicates are simple logical formulas in conjunctive-disjunctive\n+   form.\n+\n+   Predicate is array of clauses terminated by 0.  Every clause must be true\n+   in order to make predicate true.\n+   Clauses are represented as bitmaps of conditions. One of conditions\n+   must be true in order for clause to be true.  */\n+\n+#define MAX_CLAUSES 8\n+typedef int clause_t;\n+struct GTY(()) predicate\n+{\n+  clause_t clause[MAX_CLAUSES + 1];\n+};\n+\n+/* Represnetation of function body size and time depending on the inline\n+   context.  We keep simple array of record, every containing of predicate\n+   and time/size to account.\n \n-struct inline_summary\n+   We keep values scaled up, so fractional sizes and times can be\n+   accounted.  */\n+#define INLINE_SIZE_SCALE 2\n+#define INLINE_TIME_SCALE (CGRAPH_FREQ_BASE * 2)\n+typedef struct GTY(()) size_time_entry\n+{\n+  struct predicate predicate;\n+  int size;\n+  int time;\n+} size_time_entry;\n+DEF_VEC_O (size_time_entry);\n+DEF_VEC_ALLOC_O (size_time_entry, gc);\n+\n+/* Function inlining information.  */\n+struct GTY(()) inline_summary\n {\n   /* Information about the function body itself.  */\n \n   /* Estimated stack frame consumption by the function.  */\n   HOST_WIDE_INT estimated_self_stack_size;\n   /* Size of the function body.  */\n   int self_size;\n-  /* How many instructions are likely going to disappear after inlining.  */\n-  int size_inlining_benefit;\n-  /* Estimated time spent executing the function body.  */\n+  /* Time of the function body.  */\n   int self_time;\n-  /* How much time is going to be saved by inlining.  */\n-  int time_inlining_benefit;\n \n   /* False when there something makes inlining impossible (such as va_arg).  */\n   unsigned inlinable : 1;\n@@ -53,15 +100,25 @@ struct inline_summary\n   /* Estimated size of the function after inlining.  */\n   int time;\n   int size;\n-  /* Cached estimated growth after inlining.\n-     INT_MIN if not computed.  */\n-  int estimated_growth;\n+\n+  conditions conds;\n+  VEC(size_time_entry,gc) *entry;\n };\n \n typedef struct inline_summary inline_summary_t;\n DEF_VEC_O(inline_summary_t);\n-DEF_VEC_ALLOC_O(inline_summary_t,heap);\n-extern VEC(inline_summary_t,heap) *inline_summary_vec;\n+DEF_VEC_ALLOC_O(inline_summary_t,gc);\n+extern GTY(()) VEC(inline_summary_t,gc) *inline_summary_vec;\n+\n+typedef struct edge_growth_cache_entry\n+{\n+  int time, size;\n+} edge_growth_cache_entry;\n+DEF_VEC_O(edge_growth_cache_entry);\n+DEF_VEC_ALLOC_O(edge_growth_cache_entry,heap);\n+\n+extern VEC(int,heap) *node_growth_cache;\n+extern VEC(edge_growth_cache_entry,heap) *edge_growth_cache;\n \n /* In ipa-inline-analysis.c  */\n void debug_inline_summary (struct cgraph_node *);\n@@ -73,7 +130,13 @@ void inline_free_summary (void);\n void initialize_inline_failed (struct cgraph_edge *);\n int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n-int estimate_growth (struct cgraph_node *);\n+int do_estimate_growth (struct cgraph_node *);\n+void inline_merge_summary (struct cgraph_edge *edge);\n+int do_estimate_edge_growth (struct cgraph_edge *edge);\n+int do_estimate_edge_time (struct cgraph_edge *edge);\n+void initialize_growth_caches (void);\n+void free_growth_caches (void);\n+void compute_inline_parameters (struct cgraph_node *, bool);\n \n /* In ipa-inline-transform.c  */\n bool inline_call (struct cgraph_edge *, bool, VEC (cgraph_edge_p, heap) **, int *);\n@@ -89,16 +152,71 @@ inline_summary (struct cgraph_node *node)\n   return VEC_index (inline_summary_t, inline_summary_vec, node->uid);\n }\n \n-/* Estimate the growth of the caller when inlining EDGE.  */\n+\n+/* Return estimated unit growth after inlning all calls to NODE.\n+   Quick accesors to the inline growth caches.  \n+   For convenience we keep zero 0 as unknown.  Because growth\n+   can be both positive and negative, we simply increase positive\n+   growths by 1. */\n+static inline int\n+estimate_growth (struct cgraph_node *node)\n+{\n+  int ret;\n+  if ((int)VEC_length (int, node_growth_cache) <= node->uid\n+      || !(ret = VEC_index (int, node_growth_cache, node->uid)))\n+    return do_estimate_growth (node);\n+  return ret - (ret > 0);\n+}\n+\n+\n+/* Return estimated callee growth after inlining EDGE.  */\n \n static inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n-  int call_stmt_size;\n-  struct inline_summary *info = inline_summary (edge->callee);\n-  call_stmt_size = edge->call_stmt_size;\n-  gcc_checking_assert (call_stmt_size);\n-  return (info->size\n-\t  - info->size_inlining_benefit\n-\t  - call_stmt_size);\n+  int ret;\n+  if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache) <= edge->uid\n+      || !(ret = VEC_index (edge_growth_cache_entry,\n+\t\t\t    edge_growth_cache,\n+\t\t\t    edge->uid)->size))\n+    return do_estimate_edge_growth (edge);\n+  return ret - (ret > 0);\n+}\n+\n+\n+/* Return estimated callee runtime increase after inlning\n+   EDGE.  */\n+\n+static inline int\n+estimate_edge_time (struct cgraph_edge *edge)\n+{\n+  int ret;\n+  if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache) <= edge->uid\n+      || !(ret = VEC_index (edge_growth_cache_entry,\n+\t\t\t    edge_growth_cache,\n+\t\t\t    edge->uid)->size))\n+    return do_estimate_edge_time (edge);\n+  return ret - (ret > 0);\n+}\n+\n+\n+/* Reset cached value for NODE.  */\n+\n+static inline void\n+reset_node_growth_cache (struct cgraph_node *node)\n+{\n+  if ((int)VEC_length (int, node_growth_cache) > node->uid)\n+    VEC_replace (int, node_growth_cache, node->uid, 0);\n+}\n+\n+/* Reset cached value for EDGE.  */\n+\n+static inline void\n+reset_edge_growth_cache (struct cgraph_edge *edge)\n+{\n+  if ((int)VEC_length (edge_growth_cache_entry, edge_growth_cache) > edge->uid)\n+    {\n+      struct edge_growth_cache_entry zero = {0, 0};\n+      VEC_replace (edge_growth_cache_entry, edge_growth_cache, edge->uid, &zero);\n+    }\n }"}, {"sha": "afec18848a5ea2132f8c0f9f3072de0b1fb41557", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -126,7 +126,7 @@ ipa_pop_func_from_list (struct ipa_func_list **wl)\n /* Return index of the formal whose tree is PTREE in function which corresponds\n    to INFO.  */\n \n-static int\n+int\n ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n {\n   int i, count;\n@@ -2986,3 +2986,66 @@ ipa_update_after_lto_read (void)\n \t    ipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n \t}\n }\n+\n+/* Given the jump function JFUNC, compute the lattice LAT that describes the\n+   value coming down the callsite. INFO describes the caller node so that\n+   pass-through jump functions can be evaluated.  */\n+void\n+ipa_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n+\t\t\t struct ipa_jump_func *jfunc)\n+{\n+  if (jfunc->type == IPA_JF_CONST)\n+    {\n+      lat->type = IPA_CONST_VALUE;\n+      lat->constant = jfunc->value.constant;\n+    }\n+  else if (jfunc->type == IPA_JF_PASS_THROUGH)\n+    {\n+      struct ipcp_lattice *caller_lat;\n+      tree cst;\n+\n+      caller_lat = ipa_get_lattice (info, jfunc->value.pass_through.formal_id);\n+      lat->type = caller_lat->type;\n+      if (caller_lat->type != IPA_CONST_VALUE)\n+\treturn;\n+      cst = caller_lat->constant;\n+\n+      if (jfunc->value.pass_through.operation != NOP_EXPR)\n+\t{\n+\t  tree restype;\n+\t  if (TREE_CODE_CLASS (jfunc->value.pass_through.operation)\n+\t      == tcc_comparison)\n+\t    restype = boolean_type_node;\n+\t  else\n+\t    restype = TREE_TYPE (cst);\n+\t  cst = fold_binary (jfunc->value.pass_through.operation,\n+\t\t\t     restype, cst, jfunc->value.pass_through.operand);\n+\t}\n+      if (!cst || !is_gimple_ip_invariant (cst))\n+\tlat->type = IPA_BOTTOM;\n+      lat->constant = cst;\n+    }\n+  else if (jfunc->type == IPA_JF_ANCESTOR)\n+    {\n+      struct ipcp_lattice *caller_lat;\n+      tree t;\n+\n+      caller_lat = ipa_get_lattice (info, jfunc->value.ancestor.formal_id);\n+      lat->type = caller_lat->type;\n+      if (caller_lat->type != IPA_CONST_VALUE)\n+\treturn;\n+      if (TREE_CODE (caller_lat->constant) != ADDR_EXPR)\n+\t{\n+\t  /* This can happen when the constant is a NULL pointer.  */\n+\t  lat->type = IPA_BOTTOM;\n+\t  return;\n+\t}\n+      t = TREE_OPERAND (caller_lat->constant, 0);\n+      t = build_ref_for_offset (EXPR_LOCATION (t), t,\n+\t\t\t\tjfunc->value.ancestor.offset,\n+\t\t\t\tjfunc->value.ancestor.type, NULL, false);\n+      lat->constant = build_fold_addr_expr (t);\n+    }\n+  else\n+    lat->type = IPA_BOTTOM;\n+}"}, {"sha": "3ae0d1b2bd735812472e89b9acc8886a016e45ab", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -515,9 +515,20 @@ void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n void ipa_prop_write_jump_functions (cgraph_node_set set);\n void ipa_prop_read_jump_functions (void);\n void ipa_update_after_lto_read (void);\n+int ipa_get_param_decl_index (struct ipa_node_params *, tree);\n+void ipa_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n+\t\t\t     struct ipa_jump_func *jfunc);\n \n /* From tree-sra.c:  */\n tree build_ref_for_offset (location_t, tree, HOST_WIDE_INT, tree,\n \t\t\t   gimple_stmt_iterator *, bool);\n \n+/* Return the lattice corresponding to the Ith formal parameter of the function\n+   described by INFO.  */\n+static inline struct ipcp_lattice *\n+ipa_get_lattice (struct ipa_node_params *info, int i)\n+{\n+  return &(info->params[i].ipcp_lattice);\n+}\n+\n #endif /* IPA_PROP_H */"}, {"sha": "9579d41f18b5541077586cc1afa362f6400b55b1", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -1254,7 +1254,7 @@ split_function (struct split_point *split_point)\n     }\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n-  compute_inline_parameters (node);\n+  compute_inline_parameters (node, true);\n }\n \n /* Execute function splitting pass.  */"}, {"sha": "fa89a5221ec0990e39ffd5b273479bbe76d1acc1", "filename": "gcc/params.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -188,7 +188,7 @@ DEFPARAM(PARAM_IPCP_UNIT_GROWTH,\n DEFPARAM(PARAM_EARLY_INLINING_INSNS,\n \t \"early-inlining-insns\",\n \t \"Maximal estimated growth of function body caused by early inlining of single call\",\n-\t 10, 0, 0)\n+\t 11, 0, 0)\n DEFPARAM(PARAM_LARGE_STACK_FRAME,\n \t \"large-stack-frame\",\n \t \"The size of stack frame to be considered large\","}, {"sha": "40b9e6d590075389883478573f19ced33592d47c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -1,3 +1,7 @@\n+2011-04-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/pr38699.c: Fix testcase.\n+\n 2011-04-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/48717"}, {"sha": "21b3351306169874a9f1c5a458864af31527fcd0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr38699.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr38699.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr38699.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr38699.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -17,6 +17,7 @@\n #define PORTC    _SFR_IO8(0x15)\n #define PORTD    _SFR_IO8(0x12)\n \n+\n static void delay_wait_us( unsigned char timeout ) {\n     __asm__ __volatile__ (\"wdr\");\n \n@@ -27,8 +28,12 @@ static void delay_wait_us( unsigned char timeout ) {\n     while(!(TIFR & (1 << (TOV0))));\n }\n \n+/* The original testcase was multiplying by 1000.  Gcc is now smart enough\n+   to work out that actual parameter is 5000 that is not what testcase was\n+   about.  Obstructate the code somewhat then.  */\n+int a;\n static void delay_wait_us_ms( unsigned char timeout ) {\n-    delay_wait_us( timeout * 1000 );\n+    delay_wait_us( timeout * a );\n }\n \n "}, {"sha": "e13a9f8869b7e9c23252267b5b1e4aebee155772", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/632b4f8e8bf2de1177605fe274e11dc411d8be7b/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=632b4f8e8bf2de1177605fe274e11dc411d8be7b", "patch": "@@ -4366,7 +4366,7 @@ convert_callers (struct cgraph_node *node, tree old_decl,\n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (bitmap_set_bit (recomputed_callers, cs->caller->uid)\n \t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->decl)))\n-      compute_inline_parameters (cs->caller);\n+      compute_inline_parameters (cs->caller, true);\n   BITMAP_FREE (recomputed_callers);\n \n   current_function_decl = old_cur_fndecl;"}]}