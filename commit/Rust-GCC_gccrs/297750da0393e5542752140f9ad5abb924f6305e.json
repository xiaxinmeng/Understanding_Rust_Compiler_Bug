{"sha": "297750da0393e5542752140f9ad5abb924f6305e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk3NzUwZGEwMzkzZTU1NDI3NTIxNDBmOWFkNWFiYjkyNGY2MzA1ZQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2006-06-08T14:00:43Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2006-06-08T14:00:43Z"}, "message": "jvm.h (_Jv_Linker::maybe_adjust_signature): New.\n\n2006-06-07  Andrew Haley  <aph@redhat.com>\n\n        * include/jvm.h (_Jv_Linker::maybe_adjust_signature): New.\n        (_Jv_Linker::uaddr): New.\n        * link.cc (resolve_pool_entry): Call search_method_in_superclasses\n        instead of an open-coded loop around search_method_in_class.\n        (search_method_in_class): Add a new arg, check_perms.\n        (search_method_in_superclasses): New.\n        (link_symbol_table): Call maybe_adjust_signature() to extract the\n        least significnt bit of the signature pointer.  Do this three\n        times, for instace method calls, static methods, and interfaces.\n        Call search_method_in_superclasses() instead of\n        _Jv_LookupDeclaredMethod.\n        (typedef uaddr): Delete.\n\nFrom-SVN: r114486", "tree": {"sha": "83ae3658665a4f6c170a94e91e6c36e86cf6b124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83ae3658665a4f6c170a94e91e6c36e86cf6b124"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/297750da0393e5542752140f9ad5abb924f6305e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297750da0393e5542752140f9ad5abb924f6305e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/297750da0393e5542752140f9ad5abb924f6305e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297750da0393e5542752140f9ad5abb924f6305e/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f70b22c9423c0352d34ed783b92eb98645cb18f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70b22c9423c0352d34ed783b92eb98645cb18f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f70b22c9423c0352d34ed783b92eb98645cb18f1"}], "stats": {"total": 131, "additions": 104, "deletions": 27}, "files": [{"sha": "781d0aeedfeb1303fe12ce12d55c89743867edff", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297750da0393e5542752140f9ad5abb924f6305e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297750da0393e5542752140f9ad5abb924f6305e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=297750da0393e5542752140f9ad5abb924f6305e", "patch": "@@ -1,3 +1,18 @@\n+2006-06-07  Andrew Haley  <aph@redhat.com>\n+\n+\t* include/jvm.h (_Jv_Linker::maybe_adjust_signature): New.\n+\t(_Jv_Linker::uaddr): New.\n+\t* link.cc (resolve_pool_entry): Call search_method_in_superclasses\n+\tinstead of an open-coded loop around search_method_in_class.\n+\t(search_method_in_class): Add a new arg, check_perms.\n+\t(search_method_in_superclasses): New.\n+\t(link_symbol_table): Call maybe_adjust_signature() to extract the\n+\tleast significnt bit of the signature pointer.  Do this three\n+\ttimes, for instace method calls, static methods, and interfaces.\n+\tCall search_method_in_superclasses() instead of\n+\t_Jv_LookupDeclaredMethod.\n+\t(typedef uaddr): Delete.\n+\t\n 2006-06-07  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* scripts/makemake.tcl (emit_bc_rule): Do not skip"}, {"sha": "d99443cf335edba906d4c6f35b57028800ae3124", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297750da0393e5542752140f9ad5abb924f6305e/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297750da0393e5542752140f9ad5abb924f6305e/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=297750da0393e5542752140f9ad5abb924f6305e", "patch": "@@ -239,6 +239,8 @@ namespace gcj\n class _Jv_Linker\n {\n private:\n+  typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n+\n   static _Jv_Field *find_field_helper(jclass, _Jv_Utf8Const *, _Jv_Utf8Const *,\n \t\t\t\t      jclass, jclass *);\n   static _Jv_Field *find_field(jclass, jclass, jclass *, _Jv_Utf8Const *,\n@@ -264,9 +266,32 @@ class _Jv_Linker\n   static jshort append_partial_itable(jclass, jclass, void **, jshort);\n   static _Jv_Method *search_method_in_class (jclass, jclass,\n \t\t\t\t\t     _Jv_Utf8Const *,\n-\t\t\t\t\t     _Jv_Utf8Const *);\n+\t\t\t\t\t     _Jv_Utf8Const *,\n+\t\t\t\t\t     bool check_perms = true);\n+  static _Jv_Method *search_method_in_superclasses (jclass cls, jclass klass, \n+\t\t\t\t\t\t    _Jv_Utf8Const *method_name,\n+ \t\t\t\t\t\t    _Jv_Utf8Const *method_signature,\n+\t\t\t\t\t\t    jclass *found_class,\n+\t\t\t\t\t\t    bool check_perms = true);\n   static void *create_error_method(_Jv_Utf8Const *);\n \n+  /* The least significant bit of the signature pointer in a symbol\n+     table is set to 1 by the compiler if the reference is \"special\",\n+     i.e. if it is an access to a private field or method.  Extract\n+     that bit, clearing it in the address and setting the LSB of\n+     SPECIAL accordingly.  */\n+  static void maybe_adjust_signature (_Jv_Utf8Const *&s, uaddr &special)\n+  {\n+    union {\n+      _Jv_Utf8Const *signature;\n+      uaddr signature_bits;\n+    };\n+    signature = s;\n+    special = signature_bits & 1;\n+    signature_bits -= special;\n+    s = signature;\n+  }  \n+\n public:\n \n   static bool has_field_p (jclass, _Jv_Utf8Const *);"}, {"sha": "5fc82e58b147a6cbc7bd60252e46f8ebceeb2737", "filename": "libjava/link.cc", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297750da0393e5542752140f9ad5abb924f6305e/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297750da0393e5542752140f9ad5abb924f6305e/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=297750da0393e5542752140f9ad5abb924f6305e", "patch": "@@ -55,8 +55,6 @@ details.  */\n \n using namespace gcj;\n \n-typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n-\n template<typename T>\n struct aligner\n {\n@@ -461,19 +459,11 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n \t      goto end_of_method_search;\n \t  }\n \n-\t// Finally, search superclasses. \n-\tfor (jclass cls = owner->getSuperclass (); cls != 0; \n-\t     cls = cls->getSuperclass ())\n-\t  {\n-\t    the_method = search_method_in_class (cls, klass, method_name,\n-\t\t\t\t\t\t method_signature);\n-\t    if (the_method != 0)\n-\t      {\n-\t\tfound_class = cls;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\n+\t// Finally, search superclasses.\n+\tthe_method = (search_method_in_superclasses \n+\t\t      (owner->getSuperclass (), klass, method_name, \n+\t\t       method_signature, &found_class));\n+\t\n       end_of_method_search:\n     \n \t// FIXME: if (cls->loader != klass->loader), then we\n@@ -534,11 +524,12 @@ _Jv_Linker::resolve_class_ref (jclass klass, jclass *classref)\n }\n \n // Find a method declared in the cls that is referenced from klass and\n-// perform access checks.\n+// perform access checks if CHECK_PERMS is true.\n _Jv_Method *\n _Jv_Linker::search_method_in_class (jclass cls, jclass klass, \n \t\t\t\t    _Jv_Utf8Const *method_name, \n-\t\t\t\t    _Jv_Utf8Const *method_signature)\n+\t\t\t\t    _Jv_Utf8Const *method_signature,\n+\t\t\t\t    bool check_perms)\n {\n   using namespace java::lang::reflect;\n \n@@ -551,7 +542,7 @@ _Jv_Linker::search_method_in_class (jclass cls, jclass klass,\n \t\t\t\t    method_signature)))\n \tcontinue;\n \n-      if (_Jv_CheckAccess (klass, cls, method->accflags))\n+      if (!check_perms || _Jv_CheckAccess (klass, cls, method->accflags))\n \treturn method;\n       else\n \t{\n@@ -568,6 +559,30 @@ _Jv_Linker::search_method_in_class (jclass cls, jclass klass,\n   return 0;\n }\n \n+// Like search_method_in_class, but work our way up the superclass\n+// chain.\n+_Jv_Method *\n+_Jv_Linker::search_method_in_superclasses (jclass cls, jclass klass, \n+\t\t\t\t\t   _Jv_Utf8Const *method_name, \n+\t\t\t\t\t   _Jv_Utf8Const *method_signature,\n+\t\t\t\t\t   jclass *found_class, bool check_perms)\n+{\n+  _Jv_Method *the_method = NULL;\n+\n+  for ( ; cls != 0; cls = cls->getSuperclass ())\n+    {\n+      the_method = search_method_in_class (cls, klass, method_name,\n+\t\t\t\t\t   method_signature, check_perms);\n+      if (the_method != 0)\n+\t{\n+\t  if (found_class)\n+\t    *found_class = cls;\n+\t  break;\n+\t}\n+    }\n+  \n+  return the_method;\n+}\n \n #define INITIAL_IOFFSETS_LEN 4\n #define INITIAL_IFACES_LEN 4\n@@ -1076,6 +1091,8 @@ _Jv_Linker::link_symbol_table (jclass klass)\n       _Jv_Method *meth = NULL;            \n \n       _Jv_Utf8Const *signature = sym.signature;\n+      uaddr special;\n+      maybe_adjust_signature (signature, special);\n \n       if (target_class == NULL)\n \tthrow new java::lang::NoClassDefFoundError \n@@ -1101,8 +1118,15 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \t  // it out now.\n \t  wait_for_state(target_class, JV_STATE_PREPARED);\n \n-\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n-\t\t\t\t\t  sym.signature);\n+\t  try\n+\t    {\n+\t      meth = (search_method_in_superclasses \n+\t\t      (target_class, klass, sym.name, signature, \n+\t\t       NULL, special == 0));\n+\t    }\n+\t  catch (::java::lang::IllegalAccessError *e)\n+\t    {\n+\t    }\n \n \t  // Every class has a throwNoSuchMethodErrorIndex method that\n \t  // it inherits from java.lang.Object.  Find its vtable\n@@ -1158,7 +1182,7 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \ttry\n \t  {\n \t    the_field = find_field (klass, target_class, &found_class,\n-\t\t\t\t    sym.name, sym.signature);\n+\t\t\t\t    sym.name, signature);\n \t    if ((the_field->flags & java::lang::reflect::Modifier::STATIC))\n \t      throw new java::lang::IncompatibleClassChangeError;\n \t    else\n@@ -1185,15 +1209,18 @@ _Jv_Linker::link_symbol_table (jclass klass)\n         _Jv_FindClassNoException (sym.class_name, klass->loader);\n \n       _Jv_Method *meth = NULL;            \n+\n       _Jv_Utf8Const *signature = sym.signature;\n+      uaddr special;\n+      maybe_adjust_signature (signature, special);\n \n       // ??? Setting this pointer to null will at least get us a\n       // NullPointerException\n       klass->atable->addresses[index] = NULL;\n \n       // If the target class is missing we prepare a function call\n       // that throws a NoClassDefFoundError and store the address of\n-      // that newly prepare method in the atable. The user can run\n+      // that newly prepared method in the atable. The user can run\n       // code in classes where the missing class is part of the\n       // execution environment as long as it is never referenced.\n       if (target_class == NULL)\n@@ -1219,8 +1246,15 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \t      throw new VerifyError(sb->toString());\n \t    }\n \n-\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n-\t\t\t\t\t  sym.signature);\n+\t  try\n+\t    {\n+\t      meth = (search_method_in_superclasses \n+\t\t      (target_class, klass, sym.name, signature, \n+\t\t       NULL, special == 0));\n+\t    }\n+\t  catch (::java::lang::IllegalAccessError *e)\n+\t    {\n+\t    }\n \n \t  if (meth != NULL)\n \t    {\n@@ -1250,7 +1284,7 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \twait_for_state(target_class, JV_STATE_PREPARED);\n \tjclass found_class;\n \t_Jv_Field *the_field = find_field (klass, target_class, &found_class,\n-\t\t\t\t\t   sym.name, sym.signature);\n+\t\t\t\t\t   sym.name, signature);\n \tif ((the_field->flags & java::lang::reflect::Modifier::STATIC))\n \t  klass->atable->addresses[index] = the_field->u.addr;\n \telse\n@@ -1270,14 +1304,17 @@ _Jv_Linker::link_symbol_table (jclass klass)\n        ++index)\n     {\n       jclass target_class = _Jv_FindClass (sym.class_name, klass->loader);\n+\n       _Jv_Utf8Const *signature = sym.signature;\n+      uaddr special;\n+      maybe_adjust_signature (signature, special);\n \n       jclass cls;\n       int i;\n \n       wait_for_state(target_class, JV_STATE_LOADED);\n       bool found = _Jv_getInterfaceMethod (target_class, cls, i,\n-\t\t\t\t\t   sym.name, sym.signature);\n+\t\t\t\t\t   sym.name, signature);\n \n       if (found)\n \t{"}]}