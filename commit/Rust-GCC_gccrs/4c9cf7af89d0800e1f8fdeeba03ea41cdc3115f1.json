{"sha": "4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5Y2Y3YWY4OWQwODAwZTFmOGZkZWViYTAzZWE0MWNkYzMxMTVmMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2011-08-18T11:30:42Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-08-18T11:30:42Z"}, "message": "re PR tree-optimization/49963 (ICE: in abs_hwi, at hwint.c:108)\n\n2011-08-18  Paolo Carlini  <paolo.carlini@oracle.com>\n\t    Joseph Myers  <joseph@codesourcery.com>\n\n\tPR tree-optimization/49963\n\t* hwint.c (absu_hwi): Define.\n\t* hwint.h (absu_hwi): Declare.\n\t* fold-const.c (fold_plusminus_mult_expr): Use absu_hwi instead\n\tof abs_hwi.\n\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Likewise.\n\t* tree-ssa-loop-prefetch.c (prune_ref_by_group_reuse): Likewise.\n\nCo-Authored-By: Joseph Myers <joseph@codesourcery.com>\n\nFrom-SVN: r177848", "tree": {"sha": "fbdfd26aa897edd883893073cf2f3b2ed9769b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbdfd26aa897edd883893073cf2f3b2ed9769b4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/comments", "author": null, "committer": null, "parents": [{"sha": "97919ae7b65c192b0fdb6dfa6abdebd63a3f4ba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97919ae7b65c192b0fdb6dfa6abdebd63a3f4ba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97919ae7b65c192b0fdb6dfa6abdebd63a3f4ba9"}], "stats": {"total": 36, "additions": 28, "deletions": 8}, "files": [{"sha": "c46e1ee08b31b794dcd57554a3477d4d0276fd62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "patch": "@@ -1,3 +1,14 @@\n+2011-08-18  Paolo Carlini  <paolo.carlini@oracle.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR tree-optimization/49963\n+\t* hwint.c (absu_hwi): Define.\n+\t* hwint.h (absu_hwi): Declare.\n+\t* fold-const.c (fold_plusminus_mult_expr): Use absu_hwi instead\n+\tof abs_hwi.\n+\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Likewise.\n+\t* tree-ssa-loop-prefetch.c (prune_ref_by_group_reuse): Likewise.\n+\n 2011-08-18  Richard Guenther  <rguenther@suse.de>\n \n \t* expr.c (get_inner_reference): Sign-extend the constant"}, {"sha": "dcd6989b285522e50603334e9c6a5fc7eed7ea20", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "patch": "@@ -7036,7 +7036,7 @@ fold_plusminus_mult_expr (location_t loc, enum tree_code code, tree type,\n       int11 = TREE_INT_CST_LOW (arg11);\n \n       /* Move min of absolute values to int11.  */\n-      if (abs_hwi (int01) < abs_hwi (int11))\n+      if (absu_hwi (int01) < absu_hwi (int11))\n         {\n \t  tmp = int01, int01 = int11, int11 = tmp;\n \t  alt0 = arg00, arg00 = arg10, arg10 = alt0;\n@@ -7046,7 +7046,7 @@ fold_plusminus_mult_expr (location_t loc, enum tree_code code, tree type,\n       else\n \tmaybe_same = arg11;\n \n-      if (exact_log2 (abs_hwi (int11)) > 0 && int01 % int11 == 0\n+      if (exact_log2 (absu_hwi (int11)) > 0 && int01 % int11 == 0\n \t  /* The remainder should not be a constant, otherwise we\n \t     end up folding i * 4 + 2 to (i * 2 + 1) * 2 which has\n \t     increased the number of multiplications necessary.  */"}, {"sha": "533133c7b4db10dabf47f60593538a56753716b7", "filename": "gcc/hwint.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Fhwint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Fhwint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.c?ref=4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "patch": "@@ -109,6 +109,14 @@ abs_hwi (HOST_WIDE_INT x)\n   return x >= 0 ? x : -x;\n }\n \n+/* Compute the absolute value of X as an unsigned type.  */\n+\n+unsigned HOST_WIDE_INT\n+absu_hwi (HOST_WIDE_INT x)\n+{\n+  return x >= 0 ? (unsigned HOST_WIDE_INT)x : -(unsigned HOST_WIDE_INT)x;\n+}\n+\n /* Compute the greatest common divisor of two numbers A and B using\n    Euclid's algorithm.  */\n "}, {"sha": "c8b3c31bfb75908bcd7034d54b41919f61e3165a", "filename": "gcc/hwint.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "patch": "@@ -233,6 +233,7 @@ exact_log2 (unsigned HOST_WIDE_INT x)\n #define HOST_WIDE_INT_MAX (~(HOST_WIDE_INT_MIN))\n \n extern HOST_WIDE_INT abs_hwi (HOST_WIDE_INT);\n+extern unsigned HOST_WIDE_INT absu_hwi (HOST_WIDE_INT);\n extern HOST_WIDE_INT gcd (HOST_WIDE_INT, HOST_WIDE_INT);\n extern HOST_WIDE_INT pos_mul_hwi (HOST_WIDE_INT, HOST_WIDE_INT);\n extern HOST_WIDE_INT mul_hwi (HOST_WIDE_INT, HOST_WIDE_INT);"}, {"sha": "c5ad1c4765f73c21f9cdbeeb37d18e1936b08bc3", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "patch": "@@ -795,7 +795,7 @@ prune_ref_by_group_reuse (struct mem_ref *ref, struct mem_ref *by,\n       prefetch_before = (hit_from - delta_r + step - 1) / step;\n \n       /* Do not reduce prefetch_before if we meet beyond cache size.  */\n-      if (prefetch_before > (unsigned) abs_hwi (L2_CACHE_SIZE_BYTES / step))\n+      if (prefetch_before > absu_hwi (L2_CACHE_SIZE_BYTES / step))\n         prefetch_before = PREFETCH_ALL;\n       if (prefetch_before < ref->prefetch_before)\n \tref->prefetch_before = prefetch_before;"}, {"sha": "db4ec44c3316eb823b01a0456e9691fa5205df9d", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=4c9cf7af89d0800e1f8fdeeba03ea41cdc3115f1", "patch": "@@ -1231,7 +1231,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       /* Attempt to fold powi(arg0, abs(n/2)) into multiplies.  If not\n          possible or profitable, give up.  Skip the degenerate case when\n          n is 1 or -1, where the result is always 1.  */\n-      if (abs_hwi (n) != 1)\n+      if (absu_hwi (n) != 1)\n \t{\n \t  powi_x_ndiv2 = gimple_expand_builtin_powi (gsi, loc, arg0,\n \t\t\t\t\t\t     abs_hwi (n / 2));\n@@ -1243,7 +1243,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n \t result of the optimal multiply sequence just calculated.  */\n       sqrt_arg0 = build_and_insert_call (gsi, loc, &target, sqrtfn, arg0);\n \n-      if (abs_hwi (n) == 1)\n+      if (absu_hwi (n) == 1)\n \tresult = sqrt_arg0;\n       else\n \tresult = build_and_insert_binop (gsi, loc, target, MULT_EXPR,\n@@ -1285,7 +1285,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       /* Attempt to fold powi(arg0, abs(n/3)) into multiplies.  If not\n          possible or profitable, give up.  Skip the degenerate case when\n          abs(n) < 3, where the result is always 1.  */\n-      if (abs_hwi (n) >= 3)\n+      if (absu_hwi (n) >= 3)\n \t{\n \t  powi_x_ndiv3 = gimple_expand_builtin_powi (gsi, loc, arg0,\n \t\t\t\t\t\t     abs_hwi (n / 3));\n@@ -1298,14 +1298,14 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n          either cbrt(x) or cbrt(x) * cbrt(x).  */\n       cbrt_x = build_and_insert_call (gsi, loc, &target, cbrtfn, arg0);\n \n-      if (abs_hwi (n) % 3 == 1)\n+      if (absu_hwi (n) % 3 == 1)\n \tpowi_cbrt_x = cbrt_x;\n       else\n \tpowi_cbrt_x = build_and_insert_binop (gsi, loc, target, MULT_EXPR,\n \t\t\t\t\t      cbrt_x, cbrt_x);\n \n       /* Multiply the two subexpressions, unless powi(x,abs(n)/3) = 1.  */\n-      if (abs_hwi (n) < 3)\n+      if (absu_hwi (n) < 3)\n \tresult = powi_cbrt_x;\n       else\n \tresult = build_and_insert_binop (gsi, loc, target, MULT_EXPR,"}]}