{"sha": "bfa2e39d898414995b43b089dc52b323bc487c1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZhMmUzOWQ4OTg0MTQ5OTViNDNiMDg5ZGM1MmIzMjNiYzQ4N2MxZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T14:20:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T14:20:11Z"}, "message": "[multiple changes]\n\n2011-08-30  Yannick Moy  <moy@adacore.com>\n\n\t* exp_aggr.adb, exp_ch11.adb, exp_prag.adb: Remove early exit during\n\texpansion in Alfa mode.\n\t* exp_ch6.adb, exp_ch6.ads (Expand_Actuals): Make subprogram public\n\t* exp_alfa.adb, exp_alfa.ads: New package defining light expansion for\n\tAlfa mode.\n\t* gnat1drv.adb (Adjust_Global_Switches): Update Comment.\n\t* sem_res.adb: Ditto.\n\n2011-08-30  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-socket.ads: Minor documentation adjustment.\n\nFrom-SVN: r178317", "tree": {"sha": "ee697022c3766e0c8817321a8434e832b19cf8e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee697022c3766e0c8817321a8434e832b19cf8e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfa2e39d898414995b43b089dc52b323bc487c1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa2e39d898414995b43b089dc52b323bc487c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfa2e39d898414995b43b089dc52b323bc487c1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa2e39d898414995b43b089dc52b323bc487c1d/comments", "author": null, "committer": null, "parents": [{"sha": "a0347839daf7ab6b9c9ce1c8323bb25d402e6ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0347839daf7ab6b9c9ce1c8323bb25d402e6ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0347839daf7ab6b9c9ce1c8323bb25d402e6ac5"}], "stats": {"total": 444, "additions": 386, "deletions": 58}, "files": [{"sha": "ab5c1b1b85eed22cb454f5ea27fd279ef1aecc46", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -1,3 +1,17 @@\n+2011-08-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_aggr.adb, exp_ch11.adb, exp_prag.adb: Remove early exit during\n+\texpansion in Alfa mode.\n+\t* exp_ch6.adb, exp_ch6.ads (Expand_Actuals): Make subprogram public\n+\t* exp_alfa.adb, exp_alfa.ads: New package defining light expansion for\n+\tAlfa mode.\n+\t* gnat1drv.adb (Adjust_Global_Switches): Update Comment.\n+\t* sem_res.adb: Ditto.\n+\n+2011-08-30  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-socket.ads: Minor documentation adjustment.\n+\n 2011-08-30  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch9.adb, s-tassta.adb, s-secsta.adb: Minor reformatting."}, {"sha": "a54ebe8b297dfce475701bc0b6693256ad0b02ff", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -4664,12 +4664,6 @@ package body Exp_Aggr is\n          Check_Same_Aggr_Bounds (N, 1);\n       end if;\n \n-      --  In formal verification mode, leave the aggregate non-expanded\n-\n-      if ALFA_Mode then\n-         return;\n-      end if;\n-\n       --  STEP 2\n \n       --  Here we test for is packed array aggregate that we can handle at"}, {"sha": "5d2bb66700093a0f86b1c5de3e9fd4d5f366cba6", "filename": "gcc/ada/exp_alfa.adb", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.adb?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -0,0 +1,270 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ A L F A                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Exp_Attr; use Exp_Attr;\n+with Exp_Ch6;  use Exp_Ch6;\n+with Exp_Dbug; use Exp_Dbug;\n+with Rtsfind;  use Rtsfind;\n+with Sem_Aux;  use Sem_Aux;\n+with Sem_Res;  use Sem_Res;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Tbuild;   use Tbuild;\n+\n+package body Exp_Alfa is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Expand_Alfa_Call (N : Node_Id);\n+   --  This procedure contains common processing for function and procedure\n+   --  calls:\n+   --  * expansion of actuals to introduce necessary temporaries\n+   --  * replacement of renaming by subprogram renamed\n+\n+   procedure Expand_Alfa_N_Attribute_Reference (N : Node_Id);\n+   --  Expand attributes 'Old and 'Result only\n+\n+   procedure Expand_Alfa_N_Package_Declaration (N : Node_Id);\n+   --  Fully qualify names of enclosed entities\n+\n+   procedure Expand_Alfa_N_Simple_Return_Statement (N : Node_Id);\n+   --  Insert conversion on function return if necessary\n+\n+   procedure Expand_Alfa_N_Subprogram_Body (N : Node_Id);\n+   --  Fully qualify names of enclosed entities\n+\n+   procedure Expand_Alfa_Simple_Function_Return (N : Node_Id);\n+   --  Expand simple return from function\n+\n+   -----------------\n+   -- Expand_Alfa --\n+   -----------------\n+\n+   procedure Expand_Alfa (N : Node_Id) is\n+   begin\n+      case Nkind (N) is\n+\n+         when N_Package_Declaration =>\n+            Expand_Alfa_N_Package_Declaration (N);\n+\n+         when N_Simple_Return_Statement =>\n+            Expand_Alfa_N_Simple_Return_Statement (N);\n+\n+         when N_Subprogram_Body =>\n+            Expand_Alfa_N_Subprogram_Body (N);\n+\n+         when N_Function_Call            |\n+              N_Procedure_Call_Statement =>\n+            Expand_Alfa_Call (N);\n+\n+         when N_Attribute_Reference =>\n+            Expand_Alfa_N_Attribute_Reference (N);\n+\n+         when others =>\n+            null;\n+\n+      end case;\n+   end Expand_Alfa;\n+\n+   ----------------------\n+   -- Expand_Alfa_Call --\n+   ----------------------\n+\n+   procedure Expand_Alfa_Call (N : Node_Id) is\n+      Call_Node   : constant Node_Id := N;\n+      Parent_Subp : Entity_Id;\n+      Subp        : Entity_Id;\n+\n+   begin\n+      --  Ignore if previous error\n+\n+      if Nkind (Call_Node) in N_Has_Etype\n+        and then Etype (Call_Node) = Any_Type\n+      then\n+         return;\n+      end if;\n+\n+      --  Call using access to subprogram with explicit dereference\n+\n+      if Nkind (Name (Call_Node)) = N_Explicit_Dereference then\n+         Subp        := Etype (Name (Call_Node));\n+         Parent_Subp := Empty;\n+\n+      --  Case of call to simple entry, where the Name is a selected component\n+      --  whose prefix is the task, and whose selector name is the entry name\n+\n+      elsif Nkind (Name (Call_Node)) = N_Selected_Component then\n+         Subp        := Entity (Selector_Name (Name (Call_Node)));\n+         Parent_Subp := Empty;\n+\n+      --  Case of call to member of entry family, where Name is an indexed\n+      --  component, with the prefix being a selected component giving the\n+      --  task and entry family name, and the index being the entry index.\n+\n+      elsif Nkind (Name (Call_Node)) = N_Indexed_Component then\n+         Subp        := Entity (Selector_Name (Prefix (Name (Call_Node))));\n+         Parent_Subp := Empty;\n+\n+      --  Normal case\n+\n+      else\n+         Subp        := Entity (Name (Call_Node));\n+         Parent_Subp := Alias (Subp);\n+      end if;\n+\n+      --  Various expansion activities for actuals are carried out\n+\n+      Expand_Actuals (N, Subp);\n+\n+      --  If the subprogram is a renaming, replace it in the call with the name\n+      --  of the actual subprogram being called.\n+\n+      if Present (Parent_Subp) then\n+         Parent_Subp := Ultimate_Alias (Parent_Subp);\n+\n+         --  The below setting of Entity is suspect, see F109-018 discussion???\n+\n+         Set_Entity (Name (Call_Node), Parent_Subp);\n+      end if;\n+\n+   end Expand_Alfa_Call;\n+\n+   ---------------------------------------\n+   -- Expand_Alfa_N_Attribute_Reference --\n+   ---------------------------------------\n+\n+   procedure Expand_Alfa_N_Attribute_Reference (N : Node_Id) is\n+      Id : constant Attribute_Id := Get_Attribute_Id (Attribute_Name (N));\n+\n+   begin\n+      case Id is\n+         when Attribute_Old    |\n+              Attribute_Result =>\n+            Expand_N_Attribute_Reference (N);\n+\n+         when others =>\n+            null;\n+      end case;\n+   end Expand_Alfa_N_Attribute_Reference;\n+\n+   ---------------------------------------\n+   -- Expand_Alfa_N_Package_Declaration --\n+   ---------------------------------------\n+\n+   procedure Expand_Alfa_N_Package_Declaration (N : Node_Id) is\n+   begin\n+      Qualify_Entity_Names (N);\n+   end Expand_Alfa_N_Package_Declaration;\n+\n+   -------------------------------------------\n+   -- Expand_Alfa_N_Simple_Return_Statement --\n+   -------------------------------------------\n+\n+   procedure Expand_Alfa_N_Simple_Return_Statement (N : Node_Id) is\n+   begin\n+      --  Defend against previous errors (i.e. the return statement calls a\n+      --  function that is not available in configurable runtime).\n+\n+      if Present (Expression (N))\n+        and then Nkind (Expression (N)) = N_Empty\n+      then\n+         return;\n+      end if;\n+\n+      --  Distinguish the function and non-function cases:\n+\n+      case Ekind (Return_Applies_To (Return_Statement_Entity (N))) is\n+\n+         when E_Function          |\n+              E_Generic_Function  =>\n+            Expand_Alfa_Simple_Function_Return (N);\n+\n+         when E_Procedure         |\n+              E_Generic_Procedure |\n+              E_Entry             |\n+              E_Entry_Family      |\n+              E_Return_Statement =>\n+            --  Expand_Non_Function_Return (N);\n+            null;\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+\n+   exception\n+      when RE_Not_Available =>\n+         return;\n+   end Expand_Alfa_N_Simple_Return_Statement;\n+\n+   -----------------------------------\n+   -- Expand_Alfa_N_Subprogram_Body --\n+   -----------------------------------\n+\n+   procedure Expand_Alfa_N_Subprogram_Body (N : Node_Id) is\n+   begin\n+      Qualify_Entity_Names (N);\n+   end Expand_Alfa_N_Subprogram_Body;\n+\n+   ----------------------------------------\n+   -- Expand_Alfa_Simple_Function_Return --\n+   ----------------------------------------\n+\n+   procedure Expand_Alfa_Simple_Function_Return (N : Node_Id) is\n+      Scope_Id : constant Entity_Id :=\n+                   Return_Applies_To (Return_Statement_Entity (N));\n+      --  The function we are returning from\n+\n+      R_Type : constant Entity_Id := Etype (Scope_Id);\n+      --  The result type of the function\n+\n+      Exp : constant Node_Id := Expression (N);\n+      pragma Assert (Present (Exp));\n+\n+      Exptyp : constant Entity_Id := Etype (Exp);\n+      --  The type of the expression (not necessarily the same as R_Type)\n+\n+   begin\n+      --  Check the result expression of a scalar function against the subtype\n+      --  of the function by inserting a conversion. This conversion must\n+      --  eventually be performed for other classes of types, but for now it's\n+      --  only done for scalars.\n+      --  ???\n+\n+      if Is_Scalar_Type (Exptyp) then\n+         Rewrite (Exp, Convert_To (R_Type, Exp));\n+\n+         --  The expression is resolved to ensure that the conversion gets\n+         --  expanded to generate a possible constraint check.\n+\n+         Analyze_And_Resolve (Exp, R_Type);\n+      end if;\n+   end Expand_Alfa_Simple_Function_Return;\n+\n+end Exp_Alfa;"}, {"sha": "a5c07864be1ea34fca30c8b23b13c92500924567", "filename": "gcc/ada/exp_alfa.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_alfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_alfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.ads?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ A L F A                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements a light expansion which is used in formal\n+--  verification mode. Instead of a complete expansion of nodes for code\n+--  generation, this Alfa expansion targets generation of intermediate code\n+--  for formal verification.\n+\n+--  Expand_Alfa is called directly by Expander.Expand.\n+\n+--  Alfa expansion has three main objectives:\n+\n+--    1. Perform limited expansion to explicit some Ada rules and constructs\n+--       (translate 'Old and 'Result, replace renamings by renamed, insert\n+--        conversions, expand actuals in calls to introduce temporaries)\n+\n+--    2. Facilitate treatment for the formal verification back-end (fully\n+--       qualify names)\n+\n+--    3. Avoid the introduction of low-level code that is difficult to analyze\n+--       formally, as typically done in the full expansion for high-level\n+--       constructs (tasking, dispatching)\n+\n+with Types; use Types;\n+\n+package Exp_Alfa is\n+\n+   procedure Expand_Alfa (N : Node_Id);\n+\n+end Exp_Alfa;"}, {"sha": "dca021f92375d1c03b5bf94d09c4afd91298275c", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -1673,7 +1673,6 @@ package body Exp_Ch11 is\n \n          if VM_Target = No_VM\n            and then not CodePeer_Mode\n-           and then not ALFA_Mode\n            and then Exception_Mechanism = Back_End_Exceptions\n          then\n             return;"}, {"sha": "6780f6e8998161d6d650f13e252121b6804e1120", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -156,36 +156,6 @@ package body Exp_Ch6 is\n    --  the values are not changed for the call, we know immediately that\n    --  we have an infinite recursion.\n \n-   procedure Expand_Actuals (N : Node_Id; Subp : Entity_Id);\n-   --  For each actual of an in-out or out parameter which is a numeric\n-   --  (view) conversion of the form T (A), where A denotes a variable,\n-   --  we insert the declaration:\n-   --\n-   --    Temp : T[ := T (A)];\n-   --\n-   --  prior to the call. Then we replace the actual with a reference to Temp,\n-   --  and append the assignment:\n-   --\n-   --    A := TypeA (Temp);\n-   --\n-   --  after the call. Here TypeA is the actual type of variable A. For out\n-   --  parameters, the initial declaration has no expression. If A is not an\n-   --  entity name, we generate instead:\n-   --\n-   --    Var  : TypeA renames A;\n-   --    Temp : T := Var;       --  omitting expression for out parameter.\n-   --    ...\n-   --    Var := TypeA (Temp);\n-   --\n-   --  For other in-out parameters, we emit the required constraint checks\n-   --  before and/or after the call.\n-   --\n-   --  For all parameter modes, actuals that denote components and slices of\n-   --  packed arrays are expanded into suitable temporaries.\n-   --\n-   --  For non-scalar objects that are possibly unaligned, add call by copy\n-   --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n-\n    procedure Expand_Ctrl_Function_Call (N : Node_Id);\n    --  N is a function call which returns a controlled object. Transform the\n    --  call into a temporary which retrieves the returned object from the"}, {"sha": "95a10ec9deddd64102d5a4efa0fb84fbad35ca01", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -37,6 +37,36 @@ package Exp_Ch6 is\n    procedure Expand_N_Subprogram_Body_Stub      (N : Node_Id);\n    procedure Expand_N_Subprogram_Declaration    (N : Node_Id);\n \n+   procedure Expand_Actuals (N : Node_Id; Subp : Entity_Id);\n+   --  For each actual of an in-out or out parameter which is a numeric\n+   --  (view) conversion of the form T (A), where A denotes a variable,\n+   --  we insert the declaration:\n+   --\n+   --    Temp : T[ := T (A)];\n+   --\n+   --  prior to the call. Then we replace the actual with a reference to Temp,\n+   --  and append the assignment:\n+   --\n+   --    A := TypeA (Temp);\n+   --\n+   --  after the call. Here TypeA is the actual type of variable A. For out\n+   --  parameters, the initial declaration has no expression. If A is not an\n+   --  entity name, we generate instead:\n+   --\n+   --    Var  : TypeA renames A;\n+   --    Temp : T := Var;       --  omitting expression for out parameter.\n+   --    ...\n+   --    Var := TypeA (Temp);\n+   --\n+   --  For other in-out parameters, we emit the required constraint checks\n+   --  before and/or after the call.\n+   --\n+   --  For all parameter modes, actuals that denote components and slices of\n+   --  packed arrays are expanded into suitable temporaries.\n+   --\n+   --  For non-scalar objects that are possibly unaligned, add call by copy\n+   --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n+\n    procedure Expand_Call (N : Node_Id);\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call."}, {"sha": "22e9bb04691e6e2b558756e6965e0d5023ed5890", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -321,15 +321,6 @@ package body Exp_Prag is\n       --  be an explicit conditional in the source, not an implicit if, so we\n       --  do not call Make_Implicit_If_Statement.\n \n-      --  In formal verification mode, we keep the pragma check in the code,\n-      --  and its enclosed expression is not expanded. This requires that no\n-      --  transient scope is introduced for pragma check in this mode in\n-      --  Exp_Ch7.Establish_Transient_Scope.\n-\n-      if ALFA_Mode then\n-         return;\n-      end if;\n-\n       --  Case where we generate a direct raise\n \n       if ((Debug_Flag_Dot_G"}, {"sha": "f14fca00c792230c471726b6042ee7ee14c8ce40", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -27,6 +27,7 @@ with Atree;     use Atree;\n with Debug_A;   use Debug_A;\n with Errout;    use Errout;\n with Exp_Aggr;  use Exp_Aggr;\n+with Exp_Alfa;  use Exp_Alfa;\n with Exp_Attr;  use Exp_Attr;\n with Exp_Ch2;   use Exp_Ch2;\n with Exp_Ch3;   use Exp_Ch3;\n@@ -131,7 +132,12 @@ package body Expander is\n          --  routines.\n \n          begin\n-            case Nkind (N) is\n+            if ALFA_Mode then\n+               Expand_Alfa (N);\n+\n+            else\n+\n+               case Nkind (N) is\n \n                when N_Abort_Statement =>\n                   Expand_N_Abort_Statement (N);\n@@ -449,7 +455,9 @@ package body Expander is\n \n                when others => null;\n \n-            end case;\n+               end case;\n+\n+            end if;\n \n          exception\n             when RE_Not_Available =>"}, {"sha": "01983282ac711dcb1438c350ded403e227f85e6a", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -427,17 +427,16 @@ package GNAT.Sockets is\n \n    --  Timeval_Duration is a subtype of Standard.Duration because the full\n    --  range of Standard.Duration cannot be represented in the equivalent C\n-   --  structure. Moreover, negative values are not allowed to avoid system\n-   --  incompatibilities.\n+   --  structure (struct timeval). Moreover, negative values are not allowed\n+   --  to avoid system incompatibilities.\n \n    Immediate : constant Duration := 0.0;\n \n-   Timeval_Forever : constant := 1.0 * SOSC.MAX_tv_sec;\n    Forever         : constant Duration :=\n-                       Duration'Min (Duration'Last, Timeval_Forever);\n+                       Duration'Min (Duration'Last, 1.0 * SOSC.MAX_tv_sec);\n+   --  Largest possible Duration that is also a valid value for struct timeval\n+\n    subtype Timeval_Duration is Duration range Immediate .. Forever;\n-   --  These needs commenting, in particular we should explain what these is\n-   --  used for, and how the Timeval_Forever value is chosen (see r176463) ???\n \n    subtype Selector_Duration is Timeval_Duration;\n    --  Timeout value for selector operations"}, {"sha": "b538f4bc82e4490cf25781cdd642b3baf8b03ff5", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -435,8 +435,9 @@ procedure Gnat1drv is\n \n          Polling_Required := False;\n \n-         --  Set operating mode to Generate_Code to benefit from full front-end\n-         --  expansion (e.g. default arguments).\n+         --  Set operating mode to Generate_Code, but full front-end expansion\n+         --  is not desirable in ALFA mode, so a light expansion is performed\n+         --  instead.\n \n          Operating_Mode := Generate_Code;\n "}, {"sha": "2b0bb029ad23ee6cc4db54a67dff38e978f08072", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa2e39d898414995b43b089dc52b323bc487c1d/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=bfa2e39d898414995b43b089dc52b323bc487c1d", "patch": "@@ -8094,8 +8094,8 @@ package body Sem_Res is\n          Resolve (Condition (N), Typ);\n          Expander_Mode_Restore;\n \n-      --  In ALFA_Mode, no magic needed, we just resolve the underlying nodes\n-      --  But why is this special handling for ALFA_Mode required ???\n+      --  In ALFA mode, we need expansion in order to introduce properly the\n+      --  necessary transient scopes.\n \n       else\n          Resolve (Condition (N), Typ);"}]}