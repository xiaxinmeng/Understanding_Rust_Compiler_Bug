{"sha": "adcf8a11c772e7a0c64d4ae3eb19a520566f32b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRjZjhhMTFjNzcyZTdhMGM2NGQ0YWUzZWIxOWE1MjA1NjZmMzJiOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-29T16:38:34Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-29T16:41:50Z"}, "message": "c++: Name lookup simplifications\n\nHere are a few cleanups, prior to landing the hidden decl changes.\n\n1) Clear cxx_binding flags in the allocator, not at each user of the allocator.\n\n2) Refactor update_binding.  The logic was getting too convoluted.\n\n3) Set friendliness and anticipatedness before pushing a template decl (not after).\n\n\tgcc/cp/\n\t* name-lookup.c (create_local_binding): Do not clear\n\tINHERITED_VALUE_BINDING_P here.\n\t(name_lookup::process_binding): Move done hidden-decl triage to ...\n\t(name_lookup::search_namespace_only): ... here, its only caller.\n\t(cxx_binding_make): Clear flags here.\n\t(push_binding): Not here.\n\t(pop_local_binding): RAII.\n\t(update_binding): Refactor.\n\t(do_pushdecl): Assert we're never revealing a local binding.\n\t(do_pushdecl_with_scope): Directly call do_pushdecl.\n\t(get_class_binding): Do not clear LOCAL_BINDING_P here.\n\t* pt.c (push_template_decl): Set friend & anticipated before\n\tpushing.", "tree": {"sha": "c94405c1757de5e0bc8f56f679b143bfb9f4b4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c94405c1757de5e0bc8f56f679b143bfb9f4b4f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adcf8a11c772e7a0c64d4ae3eb19a520566f32b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adcf8a11c772e7a0c64d4ae3eb19a520566f32b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adcf8a11c772e7a0c64d4ae3eb19a520566f32b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adcf8a11c772e7a0c64d4ae3eb19a520566f32b9/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74b5b8dec467f922f6c40a320859054081c7bb09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b5b8dec467f922f6c40a320859054081c7bb09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b5b8dec467f922f6c40a320859054081c7bb09"}], "stats": {"total": 175, "additions": 98, "deletions": 77}, "files": [{"sha": "89f1a4c5d645205509a6c387f9d9a599fb2896ad", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 94, "deletions": 73, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adcf8a11c772e7a0c64d4ae3eb19a520566f32b9/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adcf8a11c772e7a0c64d4ae3eb19a520566f32b9/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=adcf8a11c772e7a0c64d4ae3eb19a520566f32b9", "patch": "@@ -77,7 +77,6 @@ create_local_binding (cp_binding_level *level, tree name)\n {\n   cxx_binding *binding = cxx_binding_make (NULL, NULL);\n \n-  INHERITED_VALUE_BINDING_P (binding) = false;\n   LOCAL_BINDING_P (binding) = true;\n   binding->scope = level;\n   binding->previous = IDENTIFIER_BINDING (name);\n@@ -480,22 +479,17 @@ name_lookup::add_type (tree new_type)\n }\n \n /* Process a found binding containing NEW_VAL and NEW_TYPE.  Returns\n-   true if we actually found something noteworthy.  */\n+   true if we actually found something noteworthy.  Hiddenness has\n+   already been handled in the caller.  */\n \n bool\n name_lookup::process_binding (tree new_val, tree new_type)\n {\n   /* Did we really see a type? */\n   if (new_type\n-      && ((want & LOOK_want::TYPE_NAMESPACE) == LOOK_want::NAMESPACE\n-\t  || (!bool (want & LOOK_want::HIDDEN_FRIEND)\n-\t      && DECL_LANG_SPECIFIC (new_type)\n-\t      && DECL_ANTICIPATED (new_type))))\n+      && (want & LOOK_want::TYPE_NAMESPACE) == LOOK_want::NAMESPACE)\n     new_type = NULL_TREE;\n \n-  if (new_val && !bool (want & LOOK_want::HIDDEN_FRIEND))\n-    new_val = ovl_skip_hidden (new_val);\n-\n   /* Do we really see a value? */\n   if (new_val)\n     switch (TREE_CODE (new_val))\n@@ -544,8 +538,25 @@ name_lookup::search_namespace_only (tree scope)\n   bool found = false;\n \n   if (tree *binding = find_namespace_slot (scope, name))\n-    found |= process_binding (MAYBE_STAT_DECL (*binding),\n-\t\t\t      MAYBE_STAT_TYPE (*binding));\n+    {\n+      tree value = *binding, type = NULL_TREE;\n+\n+      if (STAT_HACK_P (value))\n+\t{\n+\t  type = STAT_TYPE (value);\n+\t  value = STAT_DECL (value);\n+      \n+\t  if (!bool (want & LOOK_want::HIDDEN_FRIEND)\n+\t      && DECL_LANG_SPECIFIC (type)\n+\t      && DECL_ANTICIPATED (type))\n+\t    type = NULL_TREE;\n+\t}\n+\n+      if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n+\tvalue = ovl_skip_hidden (value);\n+\n+      found |= process_binding (value, type);\n+    }\n \n   return found;\n }\n@@ -1954,15 +1965,17 @@ cxx_binding_init (cxx_binding *binding, tree value, tree type)\n static cxx_binding *\n cxx_binding_make (tree value, tree type)\n {\n-  cxx_binding *binding;\n-  if (free_bindings)\n-    {\n-      binding = free_bindings;\n-      free_bindings = binding->previous;\n-    }\n+  cxx_binding *binding = free_bindings;\n+\n+  if (binding)\n+    free_bindings = binding->previous;\n   else\n     binding = ggc_alloc<cxx_binding> ();\n \n+  /* Clear flags by default.  */\n+  LOCAL_BINDING_P (binding) = false;\n+  INHERITED_VALUE_BINDING_P (binding) = false;\n+\n   cxx_binding_init (binding, value, type);\n \n   return binding;\n@@ -2009,7 +2022,6 @@ push_binding (tree id, tree decl, cp_binding_level* level)\n \n   /* Now, fill in the binding information.  */\n   binding->previous = IDENTIFIER_BINDING (id);\n-  INHERITED_VALUE_BINDING_P (binding) = 0;\n   LOCAL_BINDING_P (binding) = (level != class_binding_level);\n \n   /* And put it on the front of the list of bindings for ID.  */\n@@ -2022,16 +2034,14 @@ push_binding (tree id, tree decl, cp_binding_level* level)\n void\n pop_local_binding (tree id, tree decl)\n {\n-  cxx_binding *binding;\n-\n   if (id == NULL_TREE)\n     /* It's easiest to write the loops that call this function without\n        checking whether or not the entities involved have names.  We\n        get here for such an entity.  */\n     return;\n \n   /* Get the innermost binding for ID.  */\n-  binding = IDENTIFIER_BINDING (id);\n+  cxx_binding *binding = IDENTIFIER_BINDING (id);\n \n   /* The name should be bound.  */\n   gcc_assert (binding != NULL);\n@@ -2356,9 +2366,16 @@ static tree\n update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \t\ttree old, tree decl, bool hiding = false)\n {\n+  tree old_type = NULL_TREE;\n+\n+  if (!slot)\n+    old_type = binding->type;\n+  else if (STAT_HACK_P (*slot))\n+      old_type = STAT_TYPE (*slot);\n+\n   tree to_val = decl;\n-  tree old_type = slot ? MAYBE_STAT_TYPE (*slot) : binding->type;\n   tree to_type = old_type;\n+  bool local_overload = false;\n \n   gcc_assert (level->kind == sk_namespace ? !binding\n \t      : level->kind != sk_class && !slot);\n@@ -2375,16 +2392,20 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \n       if (old)\n \t{\n-\t  /* Slide decl into the type slot, keep old unaltered  */\n+\t  /* Put DECL into the type slot.  */\n+\t  gcc_checking_assert (!to_type);\n \t  to_type = decl;\n \t  to_val = old;\n \t}\n+\n       goto done;\n     }\n \n   if (old && DECL_IMPLICIT_TYPEDEF_P (old))\n     {\n-      /* Slide old into the type slot.  */\n+      /* OLD is an implicit typedef.  Move it to to_type.  */\n+      gcc_checking_assert (!to_type);\n+\n       to_type = old;\n       old = NULL_TREE;\n     }\n@@ -2428,60 +2449,66 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n \twarning (OPT_Wshadow, \"%q#D hides constructor for %q#D\",\n \t\t decl, to_type);\n \n+      local_overload = old && level->kind != sk_namespace;\n       to_val = ovl_insert (decl, old);\n     }\n-  else if (!old)\n-    ;\n-  else if (TREE_CODE (old) != TREE_CODE (decl))\n-    /* Different kinds of decls conflict.  */\n-    goto conflict;\n-  else if (TREE_CODE (old) == TYPE_DECL)\n-    {\n-      if (same_type_p (TREE_TYPE (old), TREE_TYPE (decl)))\n-\t/* Two type decls to the same type.  Do nothing.  */\n-\treturn old;\n-      else\n-\tgoto conflict;\n-    }\n-  else if (TREE_CODE (old) == NAMESPACE_DECL)\n+  else if (old)\n     {\n-      /* Two maybe-aliased namespaces.  If they're to the same target\n-\t namespace, that's ok.  */\n-      if (ORIGINAL_NAMESPACE (old) != ORIGINAL_NAMESPACE (decl))\n+      if (TREE_CODE (old) != TREE_CODE (decl))\n+\t/* Different kinds of decls conflict.  */\n \tgoto conflict;\n-\n-      /* The new one must be an alias at this point.  */\n-      gcc_assert (DECL_NAMESPACE_ALIAS (decl));\n-      return old;\n-    }\n-  else if (TREE_CODE (old) == VAR_DECL)\n-    {\n-      /* There can be two block-scope declarations of the same\n-\t variable, so long as they are `extern' declarations.  */\n-      if (!DECL_EXTERNAL (old) || !DECL_EXTERNAL (decl))\n-\tgoto conflict;\n-      else if (tree match = duplicate_decls (decl, old))\n-\treturn match;\n+      else if (TREE_CODE (old) == TYPE_DECL)\n+\t{\n+\t  if (same_type_p (TREE_TYPE (old), TREE_TYPE (decl)))\n+\t    {\n+\t      /* Two type decls to the same type.  Do nothing.  */\n+\t      gcc_checking_assert (!hiding);\n+\t      return old;\n+\t    }\n+\t  else\n+\t    goto conflict;\n+\t}\n+      else if (TREE_CODE (old) == NAMESPACE_DECL)\n+\t{\n+\t  /* Two maybe-aliased namespaces.  If they're to the same target\n+\t     namespace, that's ok.  */\n+\t  if (ORIGINAL_NAMESPACE (old) != ORIGINAL_NAMESPACE (decl))\n+\t    goto conflict;\n+\n+\t  /* The new one must be an alias at this point.  */\n+\t  gcc_assert (DECL_NAMESPACE_ALIAS (decl) && !hiding);\n+\t  return old;\n+\t}\n+      else if (TREE_CODE (old) == VAR_DECL)\n+\t{\n+\t  /* There can be two block-scope declarations of the same\n+\t     variable, so long as they are `extern' declarations.  */\n+\t  // FIXME: This is DECL_LOCAL_DECL_P type stuff.\n+\t  if (!DECL_EXTERNAL (old) || !DECL_EXTERNAL (decl))\n+\t    goto conflict;\n+\t  else if (tree match = duplicate_decls (decl, old))\n+\t    return match;\n+\t  else\n+\t    goto conflict;\n+\t}\n       else\n-\tgoto conflict;\n-    }\n-  else\n-    {\n-    conflict:\n-      diagnose_name_conflict (decl, old);\n-      to_val = NULL_TREE;\n+\t{\n+\tconflict:\n+\t  diagnose_name_conflict (decl, old);\n+\t  to_val = NULL_TREE;\n+\t}\n     }\n \n  done:\n   if (to_val)\n     {\n-      if (level->kind == sk_namespace || to_type == decl || to_val == decl)\n-\tadd_decl_to_level (level, decl);\n-      else\n+      if (local_overload)\n \t{\n \t  gcc_checking_assert (binding->value && OVL_P (binding->value));\n \t  update_local_overload (binding, to_val);\n \t}\n+      else\n+\tadd_decl_to_level (level, decl);\n \n       if (slot)\n \t{\n@@ -3059,12 +3086,8 @@ do_pushdecl (tree decl, bool hiding)\n \t\ttree head = iter.reveal_node (old);\n \t\tif (head != old)\n \t\t  {\n-\t\t    if (!ns)\n-\t\t      {\n-\t\t\tupdate_local_overload (binding, head);\n-\t\t\tbinding->value = head;\n-\t\t      }\n-\t\t    else if (STAT_HACK_P (*slot))\n+\t\t    gcc_checking_assert (ns);\n+\t\t    if (STAT_HACK_P (*slot))\n \t\t      STAT_DECL (*slot) = head;\n \t\t    else\n \t\t      *slot = head;\n@@ -3859,7 +3882,7 @@ do_pushdecl_with_scope (tree x, cp_binding_level *level, bool hiding = false)\n \tcurrent_function_decl = NULL_TREE;\n       b = current_binding_level;\n       current_binding_level = level;\n-      x = pushdecl (x, hiding);\n+      x = do_pushdecl (x, hiding);\n       current_binding_level = b;\n       current_function_decl = function_decl;\n     }\n@@ -4398,8 +4421,6 @@ get_class_binding (tree name, cp_binding_level *scope)\n \t\t\t\t   value_binding,\n \t\t\t\t   type_binding,\n \t\t\t\t   scope);\n-      /* This is a class-scope binding, not a block-scope binding.  */\n-      LOCAL_BINDING_P (binding) = 0;\n       set_inherited_value_binding_p (binding, value_binding, class_type);\n     }\n   else"}, {"sha": "a09633751ca98f0eaa123e744508d56baf74fcfc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adcf8a11c772e7a0c64d4ae3eb19a520566f32b9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adcf8a11c772e7a0c64d4ae3eb19a520566f32b9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=adcf8a11c772e7a0c64d4ae3eb19a520566f32b9", "patch": "@@ -6018,16 +6018,16 @@ push_template_decl (tree decl, bool is_friend)\n       if (!ctx\n \t  && !(is_friend && template_class_depth (current_class_type) > 0))\n \t{\n-\t  tmpl = pushdecl_namespace_level (tmpl, /*hiding=*/is_friend);\n-\t  if (tmpl == error_mark_node)\n-\t    return error_mark_node;\n-\n \t  /* Hide template friend classes that haven't been declared yet.  */\n \t  if (is_friend && TREE_CODE (decl) == TYPE_DECL)\n \t    {\n \t      DECL_ANTICIPATED (tmpl) = 1;\n \t      DECL_FRIEND_P (tmpl) = 1;\n \t    }\n+\n+\t  tmpl = pushdecl_namespace_level (tmpl, /*hiding=*/is_friend);\n+\t  if (tmpl == error_mark_node)\n+\t    return error_mark_node;\n \t}\n     }\n   else"}]}