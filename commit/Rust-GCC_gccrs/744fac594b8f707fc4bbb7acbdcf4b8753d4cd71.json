{"sha": "744fac594b8f707fc4bbb7acbdcf4b8753d4cd71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ0ZmFjNTk0YjhmNzA3ZmM0YmJiN2FjYmRjZjRiODc1M2Q0Y2Q3MQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@scf-fs.usc.edu", "date": "1998-07-12T03:06:46Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-12T03:06:46Z"}, "message": "typeck.c (comptypes, [...]): Add parameter comparison.\n\n\t* typeck.c (comptypes, case TEMPLATE_TEMPLATE_PARM): Add parameter\n\tcomparison.\n\t* pt.c (for_each_template_parm, case TEMPLATE_DECL): If it is a\n\ttemplate template parameter, record its use.\n\t(for_each_template_parm, case TEMPLATE_TEMPLATE_PARM): Traverse\n\tits template arguments if exists.\n\t* pt.c (coerce_template_template_parms): New function equivalent\n\tto coerce_template_parms when IS_TMPL_PARM is true.\n\t(coerce_template_parms): Use it.  Remove the IS_TMPL_PARM parameter,\n\tall callers changed.\n\t(coerce_template_parms): Access ARGLIST properly when creating a\n\tnew vector.  Only accept implicit TYPE_DECL as valid argument for\n\ta template template parameter when it is a base class of\n\tcurrent_class_type.  Don't display error message when COMPLAIN is\n\tfalse.\n\nFrom-SVN: r21073", "tree": {"sha": "3c114b63cc3899e04a8e8ac4bd43415fb4085f14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c114b63cc3899e04a8e8ac4bd43415fb4085f14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/comments", "author": null, "committer": null, "parents": [{"sha": "eda600e865cff603d9398c48df114693da913458", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eda600e865cff603d9398c48df114693da913458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eda600e865cff603d9398c48df114693da913458"}], "stats": {"total": 219, "additions": 152, "deletions": 67}, "files": [{"sha": "19121c4b7905ff33edfbbbfd09d8c36dff1862b2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=744fac594b8f707fc4bbb7acbdcf4b8753d4cd71", "patch": "@@ -1,6 +1,27 @@\n+1998-07-12  Kriang Lerdsuwanakij <lerdsuwa@scf-fs.usc.edu>\n+\n+\t* typeck.c (comptypes, case TEMPLATE_TEMPLATE_PARM): Add parameter \n+\tcomparison.\n+\n+\t* pt.c (for_each_template_parm, case TEMPLATE_DECL): If it is a \n+\ttemplate template parameter, record its use.\n+\t(for_each_template_parm, case TEMPLATE_TEMPLATE_PARM): Traverse \n+\tits template arguments if exists.\n+\n+\t* pt.c (coerce_template_template_parms): New function equivalent\n+\tto coerce_template_parms when IS_TMPL_PARM is true.\n+\t(coerce_template_parms): Use it.  Remove the IS_TMPL_PARM parameter,\n+\tall callers changed.\n+\n+\t(coerce_template_parms): Access ARGLIST properly when creating a\n+\tnew vector.  Only accept implicit TYPE_DECL as valid argument for\n+\ta template template parameter when it is a base class of\n+\tcurrent_class_type.  Don't display error message when COMPLAIN is\n+\tfalse.\n+\n 1998-07-12  Klaus Kaempf (kkaempf@progis.de)\n \n- \t* repo.c (get_base_filename): Use file_name_nondirectory ().\n+ \t* repo.c (get_base_filename): Use file_name_nondirectory.\n  \t(open_repo_file): Ditto.\n \t* cp-tree.h (file_name_nondirectory): Add prototype.\n "}, {"sha": "ebd67154c19cfa33460615e289fb8198db933e4d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=744fac594b8f707fc4bbb7acbdcf4b8753d4cd71", "patch": "@@ -298,7 +298,7 @@ dicat (lo, hi)\n   OB_PUTC ('0' + ulo);\n }\n \n-__inline void\n+static __inline void\n flush_repeats (nrepeats, type)\n      int nrepeats;\n      tree type;"}, {"sha": "36d0c0d0c87029b88c5de5b7229d7c477f7d23ca", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 126, "deletions": 65, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=744fac594b8f707fc4bbb7acbdcf4b8753d4cd71", "patch": "@@ -84,7 +84,7 @@ static char *mangle_class_name_for_template PROTO((char *, tree, tree, tree));\n static tree tsubst_expr_values PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree, tree));\n-static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n+static tree coerce_template_parms PROTO((tree, tree, tree, int, int));\n static tree tsubst_enum\tPROTO((tree, tree, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n static void maybe_adjust_types_for_deduction PROTO((unification_kind_t, tree*,\n@@ -2347,6 +2347,82 @@ convert_nontype_argument (type, expr)\n   return error_mark_node;\n }\n \n+/* Return 1 if PARM_PARMS and ARG_PARMS matches using rule for \n+   template template parameters.  Both PARM_PARMS and ARG_PARMS are \n+   vectors of TREE_LIST nodes containing TYPE_DECL, TEMPLATE_DECL \n+   or PARM_DECL.\n+   \n+   ARG_PARMS may contain more parameters than PARM_PARMS.  If this is \n+   the case, then extra parameters must have default arguments.\n+\n+   Consider the example:\n+     template <class T, class Allocator = allocator> class vector;\n+     template<template <class U> class TT> class C;\n+\n+   C<vector> is a valid instantiation.  PARM_PARMS for the above code \n+   contains a TYPE_DECL (for U),  ARG_PARMS contains two TYPE_DECLs (for \n+   T and Allocator) and OUTER_ARGS contains the argument that is used to \n+   substitute the TT parameter.  */\n+\n+static int\n+coerce_template_template_parms (parm_parms, arg_parms, in_decl, outer_args)\n+     tree parm_parms, arg_parms, in_decl, outer_args;\n+{\n+  int nparms, nargs, i;\n+  tree parm, arg;\n+\n+  my_friendly_assert (TREE_CODE (parm_parms) == TREE_VEC, 0);\n+  my_friendly_assert (TREE_CODE (arg_parms) == TREE_VEC, 0);\n+\n+  nparms = TREE_VEC_LENGTH (parm_parms);\n+  nargs = TREE_VEC_LENGTH (arg_parms);\n+\n+  /* The rule here is opposite of coerce_template_parms.  */\n+  if (nargs < nparms\n+      || (nargs > nparms\n+\t  && TREE_PURPOSE (TREE_VEC_ELT (arg_parms, nparms)) == NULL_TREE))\n+    return 0;\n+\n+  for (i = 0; i < nparms; ++i)\n+    {\n+      parm = TREE_VALUE (TREE_VEC_ELT (parm_parms, i));\n+      arg = TREE_VALUE (TREE_VEC_ELT (arg_parms, i));\n+\n+      if (arg == NULL_TREE || arg == error_mark_node\n+          || parm == NULL_TREE || parm == error_mark_node)\n+\treturn 0;\n+\n+      if (TREE_CODE (arg) != TREE_CODE (parm))\n+        return 0;\n+\n+      switch (TREE_CODE (parm))\n+\t{\n+\tcase TYPE_DECL:\n+\t  break;\n+\n+\tcase TEMPLATE_DECL:\n+\t  /* We encounter instantiations of templates like\n+\t       template <template <template <class> class> class TT>\n+\t       class C;  */\n+\t  sorry (\"nested template template parameter\");\n+\t  return 0;\n+\n+\tcase PARM_DECL:\n+\t  /* The tsubst call is used to handle cases such as\n+\t       template <class T, template <T> class TT> class D;  \n+\t     i.e. the parameter list of TT depends on earlier parameters.  */\n+\t  if (!comptypes (tsubst (TREE_TYPE (parm), outer_args, in_decl), \n+\t\t\t  TREE_TYPE (arg), 1))\n+\t    return 0;\n+\t  break;\n+\t  \n+\tdefault:\n+\t  my_friendly_abort (0);\n+\t}\n+    }\n+  return 1;\n+}\n+\n /* Convert all template arguments to their appropriate types, and return\n    a vector containing the resulting values.  If any error occurs, return\n    error_mark_node, and, if COMPLAIN is non-zero, issue an error message.\n@@ -2356,22 +2432,16 @@ convert_nontype_argument (type, expr)\n    If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be\n    provided in ARGLIST, or else trailing parameters must have default\n    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument\n-   deduction for any unspecified trailing arguments.\n+   deduction for any unspecified trailing arguments.  */\n    \n-   If IS_TMPL_PARM is non-zero,  we will coercing parameters of template \n-   template arguments.  In this case, ARGLIST is a chain of TREE_LIST\n-   nodes containing TYPE_DECL, TEMPLATE_DECL or PARM_DECL.  */\n-\n static tree\n coerce_template_parms (parms, arglist, in_decl,\n \t\t       complain,\n-\t\t       require_all_arguments,\n-\t\t       is_tmpl_parm)\n+\t\t       require_all_arguments)\n      tree parms, arglist;\n      tree in_decl;\n      int complain;\n      int require_all_arguments;\n-     int is_tmpl_parm;\n {\n   int nparms, nargs, i, lost = 0;\n   tree vec = NULL_TREE;\n@@ -2414,7 +2484,7 @@ coerce_template_parms (parms, arglist, in_decl,\n \t  tree arg;\n \t  tree parm = TREE_VEC_ELT (parms, i);\n \n-\t  if (arglist)\n+\t  if (arglist && TREE_CODE (arglist) == TREE_LIST)\n \t    {\n \t      arg = arglist;\n \t      arglist = TREE_CHAIN (arglist);\n@@ -2424,7 +2494,7 @@ coerce_template_parms (parms, arglist, in_decl,\n \t      else\n \t\targ = TREE_VALUE (arg);\n \t    }\n-\t  else if (is_tmpl_parm && i < nargs)\n+\t  else if (i < nargs)\n \t    {\n \t      arg = TREE_VEC_ELT (arglist, i);\n \t      if (arg == error_mark_node)\n@@ -2450,16 +2520,6 @@ coerce_template_parms (parms, arglist, in_decl,\n       tree val = 0;\n       int is_type, requires_type, is_tmpl_type, requires_tmpl_type;\n \n-      if (is_tmpl_parm && i < nargs)\n-\t{\n-\t  /* In case we are checking arguments inside a template template\n-\t     parameter, ARG that does not come from default argument is \n-\t     also a TREE_LIST node.  Note that ARG can also be a TREE_LIST\n-\t     in other cases such as overloaded functions.  */\n-\t  if (arg != NULL_TREE && arg != error_mark_node)\n-\t    arg = TREE_VALUE (arg);\n-\t}\n-\n       if (arg == NULL_TREE)\n \t/* We're out of arguments.  */\n \t{\n@@ -2492,7 +2552,11 @@ coerce_template_parms (parms, arglist, in_decl,\n \t\t      || requires_tmpl_type;\n \n       /* Check if it is a class template.  If REQUIRES_TMPL_TYPE is true,\n-\t we also accept implicitly created TYPE_DECL as a valid argument.  */\n+\t we also accept implicitly created TYPE_DECL as a valid argument.\n+         This is necessary to handle the case where we pass a template name\n+         to a template template parameter in a scope where we've derived from\n+         in instantiation of that template, so the template name refers to that\n+         instantiation.  We really ought to handle this better.  */\n       is_tmpl_type = (TREE_CODE (arg) == TEMPLATE_DECL\n \t\t      && TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n \t\t     || (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n@@ -2501,16 +2565,16 @@ coerce_template_parms (parms, arglist, in_decl,\n \t\t         && CLASSTYPE_TEMPLATE_INFO (arg)\n \t\t         && TREE_CODE (TYPE_NAME (arg)) == TYPE_DECL\n \t\t\t && DECL_ARTIFICIAL (TYPE_NAME (arg))\n-\t\t\t && requires_tmpl_type);\n+\t\t\t && requires_tmpl_type\n+\t\t\t && current_class_type\n+\t\t\t /* FIXME what about nested types?  */\n+\t\t\t && get_binfo (arg, current_class_type, 0));\n       if (is_tmpl_type && TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n \targ = TYPE_STUB_DECL (arg);\n       else if (is_tmpl_type && TREE_CODE (arg) == RECORD_TYPE)\n \targ = CLASSTYPE_TI_TEMPLATE (arg);\n \n-      if (is_tmpl_parm && i < nargs)\n-\tis_type = TREE_CODE (arg) == TYPE_DECL || is_tmpl_type;\n-      else\n-\tis_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't' || is_tmpl_type;\n+      is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't' || is_tmpl_type;\n \n       if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n \t  && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n@@ -2544,7 +2608,7 @@ coerce_template_parms (parms, arglist, in_decl,\n \t}\n       if (is_tmpl_type ^ requires_tmpl_type)\n \t{\n-\t  if (in_decl)\n+\t  if (in_decl && complain)\n \t    {\n \t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t\ti + 1, in_decl);\n@@ -2557,16 +2621,6 @@ coerce_template_parms (parms, arglist, in_decl,\n \t  TREE_VEC_ELT (vec, i) = error_mark_node;\n \t  continue;\n \t}\n-      if (is_tmpl_parm)\n-\t{\n-\t  if (requires_tmpl_type)\n-\t    {\n-\t      cp_error (\"nested template template parameter not implemented\");\n-\t      lost++;\n-\t      TREE_VEC_ELT (vec, i) = error_mark_node;\n-\t    }\n-\t  continue;\n-\t}\n         \n       if (is_type)\n \t{\n@@ -2575,23 +2629,28 @@ coerce_template_parms (parms, arglist, in_decl,\n \t      tree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n \t      tree argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n \n-\t      /* The parameter and argument roles have to be switched \n-\t\t here in order to handle default arguments properly.  \n-\t\t For example, \n-\t\t   template<template <class> class TT> void f(TT<int>) \n-\t\t should be able to accept vector<int> which comes from \n-\t\t   template <class T, class Allcator = allocator> \n-\t\t   class vector.  */\n+\t      if (coerce_template_template_parms (parmparm, argparm, \n+\t\t\t\t\t\t  in_decl, vec))\n+\t\t{\n+\t\t  val = arg;\n \n-\t      val = coerce_template_parms (argparm, parmparm, in_decl, 1, 1, 1);\n-\t      if (val != error_mark_node)\n-\t\tval = arg;\n-\t\t    \n-\t      /* TEMPLATE_TEMPLATE_PARM node is preferred over \n-\t\t TEMPLATE_DECL.  */\n-\t      if (val != error_mark_node \n-\t\t  && DECL_TEMPLATE_TEMPLATE_PARM_P (val))\n-\t\tval = TREE_TYPE (val);\n+\t\t  /* TEMPLATE_TEMPLATE_PARM node is preferred over \n+\t\t     TEMPLATE_DECL.  */\n+\t\t  if (val != error_mark_node \n+\t\t      && DECL_TEMPLATE_TEMPLATE_PARM_P (val))\n+\t\t    val = TREE_TYPE (val);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (in_decl && complain)\n+\t\t    {\n+\t\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t\t\t\ti + 1, in_decl);\n+\t\t      cp_error (\"  expected a template of type `%D', got `%D'\", parm, arg);\n+\t\t    }\n+\n+\t\t  val = error_mark_node;\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -3013,7 +3072,7 @@ lookup_template_class (d1, arglist, in_decl, context)\n       CLASSTYPE_GOT_SEMICOLON (parm) = 1;\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n-      arglist2 = coerce_template_parms (parmlist, arglist, template, 1, 1, 0);\n+      arglist2 = coerce_template_parms (parmlist, arglist, template, 1, 1);\n       if (arglist2 == error_mark_node)\n \treturn error_mark_node;\n \n@@ -3049,13 +3108,13 @@ lookup_template_class (d1, arglist, in_decl, context)\n \t    TREE_VEC_ELT (new_args, i) =\n \t      coerce_template_parms (TREE_VALUE (t),\n \t\t\t\t     TREE_VEC_ELT (arglist, i),\n-\t\t\t\t     template, 1, 1, 0);\n+\t\t\t\t     template, 1, 1);\n \t  arglist = new_args;\n \t}\n       else\n \targlist = coerce_template_parms (parmlist, \n \t\t\t\t\t innermost_args (arglist, 0),\n-\t\t\t\t\t template, 1, 1, 0);\n+\t\t\t\t\t template, 1, 1);\n      if (arglist == error_mark_node)\n \treturn error_mark_node;\n       if (uses_template_parms (arglist))\n@@ -3268,10 +3327,8 @@ for_each_template_parm (t, fn, data)\n     case TEMPLATE_DECL:\n       /* A template template parameter is encountered */\n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n-        /* We are parsing a template declaration */\n-        return 1;\n-      /* We are instantiating templates with template template\n-         parameter */\n+\treturn for_each_template_parm (TREE_TYPE (t), fn, data);\n+      /* Already substituted template template parameter */\n       return 0;\n       \n     case CONST_DECL:\n@@ -3301,8 +3358,12 @@ for_each_template_parm (t, fn, data)\n       return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n \n       /* template parm nodes */\n-    case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n+      /* Record template parameters such as `T' inside `TT<T>'.  */\n+      if (CLASSTYPE_TEMPLATE_INFO (t)\n+\t  && for_each_template_parm (CLASSTYPE_TI_ARGS (t), fn, data))\n+\treturn 1;\n+    case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_PARM_INDEX:\n       if (fn)\n \treturn (*fn)(t, data);\n@@ -5844,7 +5905,7 @@ type_unification (tparms, targs, parms, args, explicit_targs,\n     {\n       tree arg_vec;\n       arg_vec = coerce_template_parms (tparms, explicit_targs, NULL_TREE, 0,\n-\t\t\t\t       0, 0);\n+\t\t\t\t       0);\n \n       if (arg_vec == error_mark_node)\n \treturn 1;\n@@ -6260,10 +6321,10 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t\t   in order to handle default arguments properly.  For example, \n \t\t   template<template <class> class TT> void f(TT<int>) \n \t\t   should be able to accept vector<int> which comes from \n-\t\t   template <class T, class Allcator = allocator> \n+\t\t   template <class T, class Allocator = allocator> \n \t\t   class vector.  */\n \n-\t\tif (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 1, 1, 0)\n+\t\tif (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 1, 1)\n \t\t    == error_mark_node)\n \t\t  return 1;\n \t  "}, {"sha": "0708692e6750f3c46ff651d464f005f638ce7195", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/744fac594b8f707fc4bbb7acbdcf4b8753d4cd71/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=744fac594b8f707fc4bbb7acbdcf4b8753d4cd71", "patch": "@@ -804,6 +804,9 @@ comptypes (type1, type2, strict)\n       if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n \t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2))\n \treturn 0;\n+      if (! comp_template_parms (DECL_TEMPLATE_PARMS (TYPE_NAME (t1)),\n+\t\t\t\t DECL_TEMPLATE_PARMS (TYPE_NAME (t2))))\n+\treturn 0;\n       if (! CLASSTYPE_TEMPLATE_INFO (t1) && ! CLASSTYPE_TEMPLATE_INFO (t2))\n \treturn 1;\n       /* Don't check inheritance.  */"}]}