{"sha": "893125e0d62046c5ea553564dbafbf66a36ddd27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkzMTI1ZTBkNjIwNDZjNWVhNTUzNTY0ZGJhZmJmNjZhMzZkZGQyNw==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2008-04-02T07:57:02Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2008-04-02T07:57:02Z"}, "message": "cygming.h (ASM_OUTPUT_DWARF_OFFSET): Add 8 byte offsets for 64-bit mingw.\n\n2008-04-02  Kai Tietz  <kai.tietz@onevision.com>\n\n\t* gcc/config/i386/cygming.h (ASM_OUTPUT_DWARF_OFFSET): Add 8 byte\n\toffsets for 64-bit mingw.\n\t* gcc/config/i386/i386.c (ix86_pass_by_reference): Correct calling\n\tabi for x86_64-pc-mingw.\n\nFrom-SVN: r133825", "tree": {"sha": "acccb732cd3b2cf90bd65082c25453b5398cf644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acccb732cd3b2cf90bd65082c25453b5398cf644"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/893125e0d62046c5ea553564dbafbf66a36ddd27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893125e0d62046c5ea553564dbafbf66a36ddd27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/893125e0d62046c5ea553564dbafbf66a36ddd27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893125e0d62046c5ea553564dbafbf66a36ddd27/comments", "author": null, "committer": null, "parents": [{"sha": "e8930cc1e2b31c8b15b9972b7168733b73f13e52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8930cc1e2b31c8b15b9972b7168733b73f13e52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8930cc1e2b31c8b15b9972b7168733b73f13e52"}], "stats": {"total": 83, "additions": 59, "deletions": 24}, "files": [{"sha": "2ef1f959cd516cfe90cef2a49d27201d96a4a533", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893125e0d62046c5ea553564dbafbf66a36ddd27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893125e0d62046c5ea553564dbafbf66a36ddd27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=893125e0d62046c5ea553564dbafbf66a36ddd27", "patch": "@@ -1,6 +1,10 @@\n 2008-04-02  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config.gcc: Add for x86_64-*-mingw* the t-crtfm to tbuild.\n+\t* gcc/config/i386/cygming.h (ASM_OUTPUT_DWARF_OFFSET): Add 8 byte\n+\toffsets for 64-bit mingw.\n+\t* gcc/config/i386/i386.c (ix86_pass_by_reference): Correct calling\n+\tabi for x86_64-pc-mingw.\n \n 2008-04-02  Richard Guenther  <rguenther@suse.de>\n "}, {"sha": "65311da06019001908c1c4709c64a6b9021ca687", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893125e0d62046c5ea553564dbafbf66a36ddd27/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893125e0d62046c5ea553564dbafbf66a36ddd27/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=893125e0d62046c5ea553564dbafbf66a36ddd27", "patch": "@@ -55,7 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n    won't allow it.  */\n #define ASM_OUTPUT_DWARF_OFFSET(FILE, SIZE, LABEL, SECTION)\t\\\n   do {\t\t\t\t\t\t\t\t\\\n-    if (SIZE != 4)\t\t\t\t\t\t\\\n+    if (SIZE != 4 && (!TARGET_64BIT || SIZE != 8))\t\t\\\n       abort ();\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n     fputs (\"\\t.secrel32\\t\", FILE);\t\t\t\t\\"}, {"sha": "0d402db5149ecaa6a3799b78c002caf25e2cc68c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893125e0d62046c5ea553564dbafbf66a36ddd27/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893125e0d62046c5ea553564dbafbf66a36ddd27/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=893125e0d62046c5ea553564dbafbf66a36ddd27", "patch": "@@ -4419,7 +4419,8 @@ function_arg_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n static rtx\n function_arg_ms_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t    enum machine_mode orig_mode, int named)\n+\t\t    enum machine_mode orig_mode, int named,\n+\t\t    HOST_WIDE_INT bytes)\n {\n   unsigned int regno;\n \n@@ -4451,6 +4452,14 @@ function_arg_ms_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  return gen_rtx_PARALLEL (mode, gen_rtvec (2, t1, t2));\n \t}\n     }\n+  /* Handle aggregated types passed in register.  */\n+  if (orig_mode == BLKmode)\n+    {\n+      if (bytes > 0 && bytes <= 8)\n+        mode = (bytes > 4 ? DImode : SImode);\n+      if (mode == BLKmode)\n+        mode = DImode;\n+    }\n \n   return gen_reg_or_parallel (mode, orig_mode, regno);\n }\n@@ -4474,7 +4483,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n     mode = type_natural_mode (type);\n \n   if (TARGET_64BIT_MS_ABI)\n-    return function_arg_ms_64 (cum, mode, omode, named);\n+    return function_arg_ms_64 (cum, mode, omode, named, bytes);\n   else if (TARGET_64BIT)\n     return function_arg_64 (cum, mode, omode, type);\n   else\n@@ -4492,8 +4501,10 @@ ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n+  /* See Windows x64 Software Convention.  */\n   if (TARGET_64BIT_MS_ABI)\n     {\n+      int msize = (int) GET_MODE_SIZE (mode);\n       if (type)\n \t{\n \t  /* Arrays are passed by reference.  */\n@@ -4504,16 +4515,17 @@ ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t    {\n \t      /* Structs/unions of sizes other than 8, 16, 32, or 64 bits\n \t         are passed by reference.  */\n-\t      int el2 = exact_log2 (int_size_in_bytes (type));\n-\t      return !(el2 >= 0 && el2 <= 3);\n+\t      msize = int_size_in_bytes (type);\n \t    }\n \t}\n \n       /* __m128 is passed by reference.  */\n-      /* ??? How to handle complex?  For now treat them as structs,\n-\t and pass them by reference if they're too large.  */\n-      if (GET_MODE_SIZE (mode) > 8)\n-\treturn true;\n+      switch (msize) {\n+      case 1: case 2: case 4: case 8:\n+        break;\n+      default:\n+        return true;\n+      }\n     }\n   else if (TARGET_64BIT && type && int_size_in_bytes (type) == -1)\n     return 1;\n@@ -4728,12 +4740,22 @@ function_value_ms_64 (enum machine_mode orig_mode, enum machine_mode mode)\n \n   if (TARGET_SSE)\n     {\n-      if (mode == SFmode || mode == DFmode)\n-\tregno = FIRST_SSE_REG;\n-      else if (VECTOR_MODE_P (mode) || GET_MODE_SIZE (mode) == 16)\n-\tregno = FIRST_SSE_REG;\n+      switch (GET_MODE_SIZE (mode))\n+        {\n+        case 16:\n+          if((SCALAR_INT_MODE_P (mode) || VECTOR_MODE_P (mode))\n+\t     && !COMPLEX_MODE_P (mode))\n+\t    regno = FIRST_SSE_REG;\n+\t  break;\n+\tcase 8:\n+\tcase 4:\n+\t  if (mode == SFmode || mode == DFmode)\n+\t    regno = FIRST_SSE_REG;\n+\t  break;\n+\tdefault:\n+\t  break;\n+        }\n     }\n-\n   return gen_rtx_REG (orig_mode, regno);\n }\n \n@@ -4827,13 +4849,13 @@ return_in_memory_ms_64 (const_tree type, enum machine_mode mode)\n {\n   HOST_WIDE_INT size = int_size_in_bytes (type);\n \n-  /* __m128 and friends are returned in xmm0.  */\n-  if (!COMPLEX_MODE_P (mode) && size == 16 && VECTOR_MODE_P (mode))\n+  /* __m128 is returned in xmm0.  */\n+  if ((SCALAR_INT_MODE_P (mode) || VECTOR_MODE_P (mode))\n+      && !COMPLEX_MODE_P (mode) && (GET_MODE_SIZE (mode) == 16 || size == 16))\n     return 0;\n \n-  /* Otherwise, the size must be exactly in [1248]. But not for complex. */\n-  return (size != 1 && size != 2 && size != 4 && size != 8)\n-         || COMPLEX_MODE_P (mode);\n+  /* Otherwise, the size must be exactly in [1248]. */\n+  return (size != 1 && size != 2 && size != 4 && size != 8);\n }\n \n int\n@@ -5817,11 +5839,20 @@ ix86_file_end (void)\n \t  switch_to_section (text_section);\n \t  ASM_OUTPUT_LABEL (asm_out_file, name);\n \t}\n-\n-      xops[0] = gen_rtx_REG (SImode, regno);\n-      xops[1] = gen_rtx_MEM (SImode, stack_pointer_rtx);\n-      output_asm_insn (\"mov{l}\\t{%1, %0|%0, %1}\", xops);\n-      output_asm_insn (\"ret\", xops);\n+      if (TARGET_64BIT_MS_ABI)\n+        {\n+\t  xops[0] = gen_rtx_REG (Pmode, regno);\n+\t  xops[1] = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n+\t  output_asm_insn (\"mov{q}\\t{%1, %0|%0, %1}\", xops);\n+\t  output_asm_insn (\"ret\", xops);\n+        }\n+      else\n+        {\n+\t  xops[0] = gen_rtx_REG (SImode, regno);\n+\t  xops[1] = gen_rtx_MEM (SImode, stack_pointer_rtx);\n+\t  output_asm_insn (\"mov{l}\\t{%1, %0|%0, %1}\", xops);\n+\t  output_asm_insn (\"ret\", xops);\n+\t}\n     }\n \n   if (NEED_INDICATE_EXEC_STACK)"}]}