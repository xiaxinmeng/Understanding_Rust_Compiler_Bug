{"sha": "78ab5260a105594362d0fc96c0b455844b6accd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhhYjUyNjBhMTA1NTk0MzYyZDBmYzk2YzBiNDU1ODQ0YjZhY2NkNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-11-15T14:07:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-11-15T14:07:52Z"}, "message": "re PR fortran/50221 (Allocatable string length fails with array assignment)\n\n2015-11-15  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/50221\n\tPR fortran/68216\n\tPR fortran/63932\n\tPR fortran/66408\n\t* trans_array.c (gfc_conv_scalarized_array_ref): Pass the\n\tsymbol decl for deferred character length array references.\n\t* trans-stmt.c (gfc_trans_allocate): Keep the string lengths\n\tto update deferred length character string lengths.\n\t* trans-types.c (gfc_get_dtype_rank_type); Use the string\n\tlength of deferred character types for the dtype size.\n\t* trans.c (gfc_build_array_ref): For references to deferred\n\tcharacter arrays, use the domain max value, if it is a variable\n\tto set the 'span' and use pointer arithmetic for acces to the\n\telement.\n\t(trans_code): Set gfc_current_locus for diagnostic purposes.\n\n\tPR fortran/67674\n\t* trans-expr.c (gfc_conv_procedure_call): Do not fix deferred\n\tstring lengths of components.\n\n\tPR fortran/49954\n\t* resolve.c (deferred_op_assign): New function.\n\t(gfc_resolve_code): Call it.\n\t* trans-array.c (concat_str_length): New function.\n\t(gfc_alloc_allocatable_for_assignment): Jump directly to alloc/\n\trealloc blocks for deferred character length arrays because the\n\tstring length might change, even if the shape is the same. Call\n\tconcat_str_length to obtain the string length for concatenation\n\tsince it is needed to compute the lhs string length.\n\tSet the descriptor dtype appropriately for the new string\n\tlength.\n\t* trans-expr.c (gfc_trans_assignment_1): Use the rse string\n\tlength for all characters, other than deferred types. For\n\tconcatenation operators, push the rse.pre block to the inner\n\tmost loop so that the temporary pointer and the assignments\n\tare properly placed.\n\n2015-11-15  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/50221\n\t* gfortran.dg/deferred_character_1.f90: New test.\n\t* gfortran.dg/deferred_character_4.f90: New test for comment\n\t#4 of the PR.\n\n\tPR fortran/68216\n\t* gfortran.dg/deferred_character_2.f90: New test.\n\n\tPR fortran/67674\n\t* gfortran.dg/deferred_character_3.f90: New test.\n\n\tPR fortran/63932\n\t* gfortran.dg/deferred_character_5.f90: New test.\n\n\tPR fortran/66408\n\t* gfortran.dg/deferred_character_6.f90: New test.\n\n\tPR fortran/49954\n\t* gfortran.dg/deferred_character_7.f90: New test.\n\nFrom-SVN: r230396", "tree": {"sha": "68e0ae5b8618edca499acc51ced992350c7d50fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68e0ae5b8618edca499acc51ced992350c7d50fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78ab5260a105594362d0fc96c0b455844b6accd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ab5260a105594362d0fc96c0b455844b6accd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ab5260a105594362d0fc96c0b455844b6accd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ab5260a105594362d0fc96c0b455844b6accd4/comments", "author": null, "committer": null, "parents": [{"sha": "356510acd94c858b610a9cc4012880f5ba810c44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/356510acd94c858b610a9cc4012880f5ba810c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/356510acd94c858b610a9cc4012880f5ba810c44"}], "stats": {"total": 610, "additions": 598, "deletions": 12}, "files": [{"sha": "1e6f404cb53beb0d0bac247e44c88938e97ca3e5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -1,3 +1,42 @@\n+2015-11-15  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/50221\n+\tPR fortran/68216\n+\tPR fortran/63932\n+\tPR fortran/66408\n+\t* trans_array.c (gfc_conv_scalarized_array_ref): Pass the\n+\tsymbol decl for deferred character length array references.\n+\t* trans-stmt.c (gfc_trans_allocate): Keep the string lengths\n+\tto update deferred length character string lengths.\n+\t* trans-types.c (gfc_get_dtype_rank_type); Use the string\n+\tlength of deferred character types for the dtype size.\n+\t* trans.c (gfc_build_array_ref): For references to deferred\n+\tcharacter arrays, use the domain max value, if it is a variable\n+\tto set the 'span' and use pointer arithmetic for acces to the\n+\telement.\n+\t(trans_code): Set gfc_current_locus for diagnostic purposes.\n+\n+\tPR fortran/67674\n+\t* trans-expr.c (gfc_conv_procedure_call): Do not fix deferred\n+\tstring lengths of components.\n+\n+\tPR fortran/49954\n+\t* resolve.c (deferred_op_assign): New function.\n+\t(gfc_resolve_code): Call it.\n+\t* trans-array.c (concat_str_length): New function.\n+\t(gfc_alloc_allocatable_for_assignment): Jump directly to alloc/\n+\trealloc blocks for deferred character length arrays because the\n+\tstring length might change, even if the shape is the same. Call\n+\tconcat_str_length to obtain the string length for concatenation\n+\tsince it is needed to compute the lhs string length.\n+\tSet the descriptor dtype appropriately for the new string\n+\tlength.\n+\t* trans-expr.c (gfc_trans_assignment_1): Use the rse string\n+\tlength for all characters, other than deferred types. For\n+\tconcatenation operators, push the rse.pre block to the inner\n+\tmost loop so that the temporary pointer and the assignments\n+\tare properly placed.\n+\n 2015-11-14  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/67803"}, {"sha": "90bc6d49b4b089664254a92113aa7b71fa45de9c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -10222,6 +10222,50 @@ resolve_ptr_fcn_assign (gfc_code **code, gfc_namespace *ns)\n }\n \n \n+/* Deferred character length assignments from an operator expression\n+   require a temporary because the character length of the lhs can\n+   change in the course of the assignment.  */\n+\n+static bool\n+deferred_op_assign (gfc_code **code, gfc_namespace *ns)\n+{\n+  gfc_expr *tmp_expr;\n+  gfc_code *this_code;\n+\n+  if (!((*code)->expr1->ts.type == BT_CHARACTER\n+\t && (*code)->expr1->ts.deferred && (*code)->expr1->rank\n+\t && (*code)->expr2->expr_type == EXPR_OP))\n+    return false;\n+\n+  if (!gfc_check_dependency ((*code)->expr1, (*code)->expr2, 1))\n+    return false;\n+\n+  tmp_expr = get_temp_from_expr ((*code)->expr1, ns);\n+  tmp_expr->where = (*code)->loc;\n+\n+  /* A new charlen is required to ensure that the variable string\n+     length is different to that of the original lhs.  */\n+  tmp_expr->ts.u.cl = gfc_get_charlen();\n+  tmp_expr->symtree->n.sym->ts.u.cl = tmp_expr->ts.u.cl;\n+  tmp_expr->ts.u.cl->next = (*code)->expr2->ts.u.cl->next;\n+  (*code)->expr2->ts.u.cl->next = tmp_expr->ts.u.cl;\n+\n+  tmp_expr->symtree->n.sym->ts.deferred = 1;\n+\n+  this_code = build_assignment (EXEC_ASSIGN,\n+\t\t\t\t(*code)->expr1,\n+\t\t\t\tgfc_copy_expr (tmp_expr),\n+\t\t\t\tNULL, NULL, (*code)->loc);\n+\n+  (*code)->expr1 = tmp_expr;\n+\n+  this_code->next = (*code)->next;\n+  (*code)->next = this_code;\n+\n+  return true;\n+}\n+\n+\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -10427,6 +10471,11 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t\tgoto call;\n \t    }\n \n+\t  /* Check for dependencies in deferred character length array\n+\t     assignments and generate a temporary, if necessary.  */\n+\t  if (code->op == EXEC_ASSIGN && deferred_op_assign (&code, ns))\n+\t    break;\n+\n \t  /* F03 7.4.1.3 for non-allocatable, non-pointer components.  */\n \t  if (code->op != EXEC_CALL && code->expr1->ts.type == BT_DERIVED\n \t      && code->expr1->ts.u.derived\n@@ -10801,7 +10850,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n       sym->binding_label = NULL;\n \n     }\n-  else if (sym->attr.flavor == FL_VARIABLE && module \n+  else if (sym->attr.flavor == FL_VARIABLE && module\n \t   && (strcmp (module, gsym->mod_name) != 0\n \t       || strcmp (sym->name, gsym->sym_name) != 0))\n     {"}, {"sha": "69f6e19f92260b1a216a71fe7fd5dc379d497c9c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 116, "deletions": 4, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -3164,7 +3164,8 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n     index = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n \t\t\t     index, info->offset);\n \n-  if (expr && is_subref_array (expr))\n+  if (expr && (is_subref_array (expr)\n+\t       || (expr->ts.deferred && expr->expr_type == EXPR_VARIABLE)))\n     decl = expr->symtree->n.sym->backend_decl;\n \n   tmp = build_fold_indirect_ref_loc (input_location, info->data);\n@@ -8499,6 +8500,75 @@ gfc_is_reallocatable_lhs (gfc_expr *expr)\n }\n \n \n+static tree\n+concat_str_length (gfc_expr* expr)\n+{\n+  tree type;\n+  tree len1;\n+  tree len2;\n+  gfc_se se;\n+\n+  type = gfc_typenode_for_spec (&expr->value.op.op1->ts);\n+  len1 = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+  if (len1 == NULL_TREE)\n+    {\n+      if (expr->value.op.op1->expr_type == EXPR_OP)\n+\tlen1 = concat_str_length (expr->value.op.op1);\n+      else if (expr->value.op.op1->expr_type == EXPR_CONSTANT)\n+\tlen1 = build_int_cst (gfc_charlen_type_node,\n+\t\t\texpr->value.op.op1->value.character.length);\n+      else if (expr->value.op.op1->ts.u.cl->length)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr (&se, expr->value.op.op1->ts.u.cl->length);\n+\t  len1 = se.expr;\n+\t}\n+      else\n+\t{\n+\t  /* Last resort!  */\n+\t  gfc_init_se (&se, NULL);\n+\t  se.want_pointer = 1;\n+\t  se.descriptor_only = 1;\n+\t  gfc_conv_expr (&se, expr->value.op.op1);\n+\t  len1 = se.string_length;\n+\t}\n+    }\n+\n+  type = gfc_typenode_for_spec (&expr->value.op.op2->ts);\n+  len2 = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+  if (len2 == NULL_TREE)\n+    {\n+      if (expr->value.op.op2->expr_type == EXPR_OP)\n+\tlen2 = concat_str_length (expr->value.op.op2);\n+      else if (expr->value.op.op2->expr_type == EXPR_CONSTANT)\n+\tlen2 = build_int_cst (gfc_charlen_type_node,\n+\t\t\texpr->value.op.op2->value.character.length);\n+      else if (expr->value.op.op2->ts.u.cl->length)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr (&se, expr->value.op.op2->ts.u.cl->length);\n+\t  len2 = se.expr;\n+\t}\n+      else\n+\t{\n+\t  /* Last resort!  */\n+\t  gfc_init_se (&se, NULL);\n+\t  se.want_pointer = 1;\n+\t  se.descriptor_only = 1;\n+\t  gfc_conv_expr (&se, expr->value.op.op2);\n+\t  len2 = se.string_length;\n+\t}\n+    }\n+\n+  gcc_assert(len1 && len2);\n+  len1 = fold_convert (gfc_charlen_type_node, len1);\n+  len2 = fold_convert (gfc_charlen_type_node, len2);\n+\n+  return fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t  gfc_charlen_type_node, len1, len2);\n+}\n+\n+\n /* Allocate the lhs of an assignment to an allocatable array, otherwise\n    reallocate it.  */\n \n@@ -8596,6 +8666,12 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   /* Allocate if data is NULL.  */\n   cond_null = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n \t\t\t array1, build_int_cst (TREE_TYPE (array1), 0));\n+\n+  if (expr1->ts.deferred)\n+    cond_null = gfc_evaluate_now (boolean_true_node, &fblock);\n+  else\n+    cond_null= gfc_evaluate_now (cond_null, &fblock);\n+\n   tmp = build3_v (COND_EXPR, cond_null,\n \t\t  build1_v (GOTO_EXPR, jump_label1),\n \t\t  build_empty_stmt (input_location));\n@@ -8684,7 +8760,13 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \n   cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t  size1, size2);\n-  neq_size = gfc_evaluate_now (cond, &fblock);\n+\n+  /* If the lhs is deferred length, assume that the element size\n+     changes and force a reallocation.  */\n+  if (expr1->ts.deferred)\n+    neq_size = gfc_evaluate_now (boolean_true_node, &fblock);\n+  else\n+    neq_size = gfc_evaluate_now (cond, &fblock);\n \n   /* Deallocation of allocatable components will have to occur on\n      reallocation.  Fix the old descriptor now.  */\n@@ -8789,6 +8871,12 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       else\n \t{\n \t  tmp = expr2->ts.u.cl->backend_decl;\n+\t  if (!tmp && expr2->expr_type == EXPR_OP\n+\t      && expr2->value.op.op == INTRINSIC_CONCAT)\n+\t    {\n+\t      tmp = concat_str_length (expr2);\n+\t      expr2->ts.u.cl->backend_decl = gfc_evaluate_now (tmp, &fblock);\n+\t    }\n \t  tmp = fold_convert (TREE_TYPE (expr1->ts.u.cl->backend_decl), tmp);\n \t}\n \n@@ -8816,6 +8904,22 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t\t\t   size2, size_one_node);\n   size2 = gfc_evaluate_now (size2, &fblock);\n \n+  /* For deferred character length, the 'size' field of the dtype might\n+     have changed so set the dtype.  */\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n+      && expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+    {\n+      tree type;\n+      tmp = gfc_conv_descriptor_dtype (desc);\n+      if (expr2->ts.u.cl->backend_decl)\n+\ttype = gfc_typenode_for_spec (&expr2->ts);\n+      else\n+\ttype = gfc_typenode_for_spec (&expr1->ts);\n+\n+      gfc_add_modify (&fblock, tmp,\n+\t\t      gfc_get_dtype_rank_type (expr1->rank,type));\n+    }\n+\n   /* Realloc expression.  Note that the scalarizer uses desc.data\n      in the array reference - (*desc.data)[<element>].  */\n   gfc_init_block (&realloc_block);\n@@ -8858,8 +8962,16 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t\t\t     1, size2);\n   gfc_conv_descriptor_data_set (&alloc_block,\n \t\t\t\tdesc, tmp);\n-  tmp = gfc_conv_descriptor_dtype (desc);\n-  gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+\n+  /* We already set the dtype in the case of deferred character\n+     length arrays.  */\n+  if (!(GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n+        && expr1->ts.type == BT_CHARACTER && expr1->ts.deferred))\n+    {\n+      tmp = gfc_conv_descriptor_dtype (desc);\n+      gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+    }\n+\n   if ((expr1->ts.type == BT_DERIVED)\n \t&& expr1->ts.u.derived->attr.alloc_comp)\n     {"}, {"sha": "6647a4ec40463644be608aeb63b7e3fc56e35634", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -5599,7 +5599,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  else\n \t    {\n \t      tmp = parmse.string_length;\n-\t      if (TREE_CODE (tmp) != VAR_DECL)\n+\t      if (TREE_CODE (tmp) != VAR_DECL\n+\t\t  && TREE_CODE (tmp) != COMPONENT_REF)\n \t\ttmp = gfc_evaluate_now (parmse.string_length, &se->pre);\n \t      parmse.string_length = gfc_build_addr_expr (NULL_TREE, tmp);\n \t    }\n@@ -9250,8 +9251,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n     }\n \n   /* Stabilize a string length for temporaries.  */\n-  if (expr2->ts.type == BT_CHARACTER)\n+  if (expr2->ts.type == BT_CHARACTER && !expr2->ts.deferred)\n     string_length = gfc_evaluate_now (rse.string_length, &rse.pre);\n+  else if (expr2->ts.type == BT_CHARACTER)\n+    string_length = rse.string_length;\n   else\n     string_length = NULL_TREE;\n \n@@ -9285,8 +9288,14 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n      the function call must happen before the (re)allocation of the lhs -\n      otherwise the character length of the result is not known.\n      NOTE: This relies on having the exact dependence of the length type\n-     parameter available to the caller; gfortran saves it in the .mod files.  */\n-  if (flag_realloc_lhs && expr2->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+     parameter available to the caller; gfortran saves it in the .mod files.\n+     NOTE ALSO: The concatenation operation generates a temporary pointer,\n+     whose allocation must go to the innermost loop.  */\n+  if (flag_realloc_lhs\n+      && expr2->ts.type == BT_CHARACTER && expr1->ts.deferred\n+      && !(lss != gfc_ss_terminator\n+\t   && expr2->expr_type == EXPR_OP\n+\t   && expr2->value.op.op == INTRINSIC_CONCAT))\n     gfc_add_block_to_block (&block, &rse.pre);\n \n   /* Nullify the allocatable components corresponding to those of the lhs"}, {"sha": "86548c007315c459c96a071af6f982cbaa652910", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -5086,6 +5086,7 @@ gfc_trans_allocate (gfc_code * code)\n   tree label_finish;\n   tree memsz;\n   tree al_vptr, al_len;\n+  tree def_str_len = NULL_TREE;\n   /* If an expr3 is present, then store the tree for accessing its\n      _vptr, and _len components in the variables, respectively.  The\n      element size, i.e. _vptr%size, is stored in expr3_esize.  Any of\n@@ -5463,6 +5464,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  expr3_esize = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t\t TREE_TYPE (se_sz.expr),\n \t\t\t\t\t tmp, se_sz.expr);\n+\t  def_str_len = gfc_evaluate_now (se_sz.expr, &block);\n \t}\n     }\n \n@@ -5514,6 +5516,17 @@ gfc_trans_allocate (gfc_code * code)\n \n       se.want_pointer = 1;\n       se.descriptor_only = 1;\n+\n+      if (expr->ts.type == BT_CHARACTER\n+\t  && expr->ts.deferred\n+\t  && TREE_CODE (expr->ts.u.cl->backend_decl) == VAR_DECL\n+\t  && def_str_len != NULL_TREE)\n+\t{\n+\t  tmp = expr->ts.u.cl->backend_decl;\n+\t  gfc_add_modify (&block, tmp,\n+\t\t\t  fold_convert (TREE_TYPE (tmp), def_str_len));\n+\t}\n+\n       gfc_conv_expr (&se, expr);\n       if (expr->ts.type == BT_CHARACTER && expr->ts.deferred)\n \t/* se.string_length now stores the .string_length variable of expr"}, {"sha": "9b44b7109f20958194502974fabf47625d39edc1", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -331,6 +331,18 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n \n   type = TREE_TYPE (type);\n \n+  /* Use pointer arithmetic for deferred character length array\n+     references.  */\n+  if (type && TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_MAXVAL (TYPE_DOMAIN (type)) != NULL_TREE\n+      && TREE_CODE (TYPE_MAXVAL (TYPE_DOMAIN (type))) == VAR_DECL\n+      && decl\n+      && DECL_CONTEXT (TYPE_MAXVAL (TYPE_DOMAIN (type)))\n+\t\t\t\t\t== DECL_CONTEXT (decl))\n+    span = TYPE_MAXVAL (TYPE_DOMAIN (type));\n+  else\n+    span = NULL_TREE;\n+\n   if (DECL_P (base))\n     TREE_ADDRESSABLE (base) = 1;\n \n@@ -345,8 +357,9 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n \t\t|| TREE_CODE (decl) == PARM_DECL)\n        && ((GFC_DECL_SUBREF_ARRAY_P (decl)\n \t    && !integer_zerop (GFC_DECL_SPAN (decl)))\n-\t   || GFC_DECL_CLASS (decl)))\n-      || vptr)\n+\t   || GFC_DECL_CLASS (decl)\n+\t   || span != NULL_TREE))\n+      || vptr != NULL_TREE)\n     {\n       if (decl)\n \t{\n@@ -376,6 +389,8 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n \t    }\n \t  else if (GFC_DECL_SUBREF_ARRAY_P (decl))\n \t    span = GFC_DECL_SPAN (decl);\n+\t  else if (span)\n+\t    span = fold_convert (gfc_array_index_type, span);\n \t  else\n \t    gcc_unreachable ();\n \t}\n@@ -1620,6 +1635,7 @@ trans_code (gfc_code * code, tree cond)\n \t  gfc_add_expr_to_block (&block, res);\n \t}\n \n+      gfc_current_locus = code->loc;\n       gfc_set_backend_locus (&code->loc);\n \n       switch (code->op)"}, {"sha": "5a1997e5d68da81016a7bed67f828ca7d3c8edd2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -1,5 +1,27 @@\n+2015-11-15  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/50221\n+\t* gfortran.dg/deferred_character_1.f90: New test.\n+\t* gfortran.dg/deferred_character_4.f90: New test for comment\n+\t#4 of the PR.\n+\n+\tPR fortran/68216\n+\t* gfortran.dg/deferred_character_2.f90: New test.\n+\n+\tPR fortran/67674\n+\t* gfortran.dg/deferred_character_3.f90: New test.\n+\n+\tPR fortran/63932\n+\t* gfortran.dg/deferred_character_5.f90: New test.\n+\n+\tPR fortran/66408\n+\t* gfortran.dg/deferred_character_6.f90: New test.\n+\n+\tPR fortran/49954\n+\t* gfortran.dg/deferred_character_7.f90: New test.\n+\n 2015-11-14  Steven G. Kargl  <kargl@gcc.gnu.org>\n- \n+\n \tPR fortran/67803\n \t* gfortran.dg/pr67803.f90: New test.\n "}, {"sha": "0772c70537fed07ea467836db9af028e2f06ba59", "filename": "gcc/testsuite/gfortran.dg/deferred_character_1.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_1.f90?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR50221\n+!\n+! Contributed by Clive Page  <clivegpage@gmail.com>\n+!            and Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+! This is from comment #2 by Tobias Burnus.\n+!\n+module m\n+  character(len=:), save, allocatable :: str(:)\n+  character(len=2), parameter :: const(3) = [\"a1\", \"b2\", \"c3\"]\n+end\n+\n+  use m\n+  call test()\n+  if(allocated(str)) deallocate(str)\n+  call foo\n+contains\n+  subroutine test()\n+    call doit()\n+!    print *, 'strlen=',len(str),' / array size =',size(str)\n+!    print '(3a)', '>',str(1),'<'\n+!    print '(3a)', '>',str(2),'<'\n+!    print '(3a)', '>',str(3),'<'\n+    if (any (str .ne. const)) call abort\n+  end subroutine test\n+  subroutine doit()\n+    str = const\n+  end subroutine doit\n+  subroutine foo\n+!\n+! This is the original PR from Clive Page\n+!\n+    character(:), allocatable, dimension(:) :: array\n+    array = (/'xx', 'yy', 'zz'/)\n+!    print *, 'array=', array, len(array(1)), size(array)\n+    if (any (array .ne. [\"xx\", \"yy\", \"zz\"])) call abort\n+  end subroutine\n+end"}, {"sha": "3e6535c76248fe624736008577aef67d57391712", "filename": "gcc/testsuite/gfortran.dg/deferred_character_2.f90", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_2.f90?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -0,0 +1,85 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR68216\n+!\n+! Reported on clf: https://groups.google.com/forum/#!topic/comp.lang.fortran/eWQTKfqKLZc\n+!\n+PROGRAM hello\n+!\n+! This is based on the first testcase, from Francisco (Ayyy LMAO). Original\n+! lines are commented out. The second testcase from this thread is acalled\n+! at the end of the program.\n+!\n+    IMPLICIT NONE\n+\n+    CHARACTER(LEN=:),DIMENSION(:),ALLOCATABLE :: array_lineas\n+    CHARACTER(LEN=:),DIMENSION(:),ALLOCATABLE :: array_copia\n+    character (3), dimension (2) :: array_fijo = [\"abc\",\"def\"]\n+    character (100) :: buffer\n+    INTEGER :: largo , cant_lineas , i\n+\n+    write (buffer, \"(2a3)\") array_fijo\n+\n+!    WRITE(*,*) ' Escriba un numero para el largo de cada linea'\n+!    READ(*,*) largo\n+    largo = LEN (array_fijo)\n+\n+!    WRITE(*,*) ' Escriba la cantidad de lineas'\n+!    READ(*,*) cant_lineas\n+    cant_lineas = size (array_fijo, 1)\n+\n+    ALLOCATE(CHARACTER(LEN=largo) :: array_lineas(cant_lineas))\n+\n+!    WRITE(*,*) 'Escriba el array', len(array_lineas), size(array_lineas)\n+    READ(buffer,\"(2a3)\") (array_lineas(i),i=1,cant_lineas)\n+\n+!    WRITE(*,*) 'Array guardado: '\n+!    DO i=1,cant_lineas\n+!    WRITE(*,*) array_lineas(i)\n+!    ENDDO\n+     if (any (array_lineas .ne. array_fijo)) call abort\n+\n+! The following are additional tests beyond that of the original.\n+!\n+! Check that allocation with source = another deferred length is OK\n+     allocate (array_copia, source = array_lineas)\n+     if (any (array_copia .ne. array_fijo)) call abort\n+     deallocate (array_lineas, array_copia)\n+\n+! Check that allocation with source = a non-deferred length is OK\n+     allocate (array_lineas, source = array_fijo)\n+     if (any (array_lineas .ne. array_fijo)) call abort\n+     deallocate (array_lineas)\n+\n+! Check that allocation with MOLD = a non-deferred length is OK\n+     allocate (array_copia, mold = [array_fijo(:)(1:2), array_fijo(:)(1:2)])\n+     if (size (array_copia, 1) .ne. 4) call abort\n+     if (LEN (array_copia, 1) .ne. 2) call abort\n+\n+! Check that allocation with MOLD = another deferred length is OK\n+     allocate (array_lineas, mold = array_copia)\n+     if (size (array_copia, 1) .ne. 4) call abort\n+     if (LEN (array_copia, 1) .ne. 2) call abort\n+     deallocate (array_lineas, array_copia)\n+\n+!    READ(*,*)\n+     call testdefchar\n+contains\n+     subroutine testdefchar\n+!\n+! This is the testcase in the above thread from Blokbuster\n+!\n+          implicit none\n+          character(:), allocatable :: test(:)\n+\n+          allocate(character(3) :: test(2))\n+          test(1) = 'abc'\n+          test(2) = 'def'\n+          if (any (test .ne. ['abc', 'def'])) call abort\n+\n+          test = ['aa','bb','cc']\n+          if (any (test .ne. ['aa', 'bb', 'cc'])) call abort\n+\n+     end subroutine testdefchar\n+\n+END PROGRAM"}, {"sha": "8f2933713c3e7c63dfb6d379344d822dd2914d8a", "filename": "gcc/testsuite/gfortran.dg/deferred_character_3.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_3.f90?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -0,0 +1,46 @@\n+! {dg_do run }\n+!\n+! Tests the fix for PR67674\n+!\n+! Contributed by Kristopher Kuhlman  <kristopher.kuhlman@gmail.com>\n+!\n+program test\n+  implicit none\n+\n+  type string_type\n+    character(len=:), allocatable :: name\n+  end type string_type\n+  type(string_type), allocatable :: my_string_type\n+\n+  allocate(my_string_type)\n+  allocate(character(len=0) :: my_string_type%name)\n+\n+!  print *, 'length main program before',len(my_string_type%name)\n+\n+  call inputreadword1(my_string_type%name)\n+\n+!  print *, 'length main program after',len(my_string_type%name)\n+!  print *, 'final result:',my_string_type%name\n+  if (my_string_type%name .ne. 'here the word is finally set') call abort\n+\n+contains\n+  subroutine inputreadword1(word_intermediate)\n+    character(len=:), allocatable :: word_intermediate\n+\n+!    print *, 'length intermediate before',len(word_intermediate)\n+    call inputreadword2(word_intermediate)\n+!    print *, 'length intermediate after',len(word_intermediate)\n+!    print *, word_intermediate\n+\n+  end subroutine inputreadword1\n+\n+  subroutine inputreadword2(word)\n+    character(len=:), allocatable :: word\n+\n+!    print *, 'length inner before',len(word)\n+    word = 'here the word is finally set' ! want automatic reallocation to happen here\n+!    print *, 'length inner after',len(word)\n+!    print *, word\n+\n+  end subroutine inputreadword2\n+end program test"}, {"sha": "5bb865810c11b67f15a1cf1eba4edfb96e7b9f71", "filename": "gcc/testsuite/gfortran.dg/deferred_character_4.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_4.f90?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+!\n+! Check that PR50221 comment #4 is fixed.\n+!\n+! Contributed by Arjen Makus  <arjen.markus895@gmail.com>\n+!\n+program chk_alloc_string\n+    implicit none\n+\n+    character(len=:), dimension(:), allocatable :: strings\n+    character(20) :: buffer\n+    integer :: i\n+\n+    allocate( character(10):: strings(1:3) )\n+\n+    strings = [ \"A   \", \"C   \", \"ABCD\", \"V   \" ]\n+\n+    if (len(strings) .ne. 4) call abort\n+    if (size(strings, 1) .ne. 4) call abort\n+    if (any (strings .ne. [character(len=4) :: \"A\", \"C\", \"ABCD\", \"V\"])) call abort\n+\n+    strings = [character(len=4) :: \"A\", \"C\", \"ABCDE\", \"V\", \"zzzz\"]\n+\n+    if (len(strings) .ne. 4) call abort\n+    if (size(strings, 1) .ne. 5) call abort\n+    if (any (strings .ne. [character(len=4) :: \"A\", \"C\", \"ABCD\", \"V\", \"zzzz\"])) call abort\n+\n+    write (buffer, \"(5a4)\") strings\n+    if (buffer .ne. \"A   C   ABCDV   zzzz\") call abort\n+end program chk_alloc_string"}, {"sha": "b5d64b43840a790056a5ac01dfc275497887d3a8", "filename": "gcc/testsuite/gfortran.dg/deferred_character_5.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_5.f90?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+!\n+! Tests that PR63932 stays fixed.\n+!\n+! Contributed by Valery Weber  <valeryweber@hotmail.com>\n+!\n+module mod\n+  type :: t\n+     character(:), allocatable :: c\n+     integer :: i\n+   contains\n+     procedure, pass :: get\n+  end type t\n+  type :: u\n+     character(:), allocatable :: c\n+  end type u\n+contains\n+  subroutine get(this, a)\n+    class(t), intent(in) :: this\n+    character(:), allocatable, intent(out), optional :: a\n+    if (present (a)) a = this%c\n+  end subroutine get\n+end module mod\n+\n+program test\n+  use mod\n+  type(t) :: a\n+  type(u) :: b\n+  a%c = 'something'\n+  call a%get (a = b%c)\n+  if (b%c .ne. 'something') call abort\n+end program test"}, {"sha": "94afa0c0f285a0acc5292590b60f15397675f8c9", "filename": "gcc/testsuite/gfortran.dg/deferred_character_6.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_6.f90?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do run }\n+!\n+! Tests that PR66408 stays fixed.\n+!\n+! Contributed by <werner.blokbuster@gmail.com>\n+!\n+module mytest\n+\n+    implicit none\n+\n+    type vary\n+        character(:), allocatable :: string\n+    end type vary\n+\n+    interface assignment(=)\n+        module procedure char_eq_vary\n+    end interface assignment(=)\n+\n+contains\n+\n+    subroutine char_eq_vary(my_char,my_vary)\n+        character(:), allocatable, intent(out) :: my_char\n+        type(vary), intent(in) :: my_vary\n+        my_char = my_vary%string\n+    end subroutine char_eq_vary\n+\n+end module mytest\n+\n+\n+program thistest\n+\n+    use mytest, only: vary, assignment(=)\n+    implicit none\n+\n+    character(:), allocatable :: test_char\n+    character(14), parameter :: str = 'example string'\n+    type(vary) :: test_vary\n+    type(vary) :: my_stuff\n+\n+\n+    test_vary%string = str\n+    if (test_vary%string .ne. str) call abort\n+\n+! This previously gave a blank string.\n+    my_stuff%string = test_vary\n+    if (my_stuff%string .ne. str) call abort\n+\n+    test_char = test_vary\n+    if (test_char .ne. str) call abort\n+\n+    my_stuff = test_vary\n+    if (my_stuff%string .ne. str) call abort\n+\n+end program thistest"}, {"sha": "64b03aba0bd5ed822fefcd25b881751d4d0d42c9", "filename": "gcc/testsuite/gfortran.dg/deferred_character_7.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ab5260a105594362d0fc96c0b455844b6accd4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_7.f90?ref=78ab5260a105594362d0fc96c0b455844b6accd4", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+!\n+! Tests the fix for pr49954, in which concatenation to deferred length character\n+! arrays, at best, did not work correctly.\n+!\n+!\n+!\n+implicit none\n+  character(len=:), allocatable :: a1(:)\n+  character(len=:), allocatable :: a2(:), a3(:)\n+  character(len=:), allocatable :: b1\n+  character(len=:), allocatable :: b2\n+  character(8) :: chr = \"IJKLMNOP\"\n+  character(48) :: buffer\n+\n+  a1 = [\"ABCDEFGH\",\"abcdefgh\"]\n+  a2 = \"_\"//a1//chr//\"_\"\n+  if (any (a2 .ne. [\"_ABCDEFGHIJKLMNOP_\",\"_abcdefghIJKLMNOP_\"])) call abort\n+\n+! Check that the descriptor dtype is OK - the array write needs it.\n+  write (buffer, \"(2a18)\") a2\n+  if (trim (buffer) .ne. \"_ABCDEFGHIJKLMNOP__abcdefghIJKLMNOP_\") call abort\n+\n+! Make sure scalars survived the fix!\n+  b1 = \"ABCDEFGH\"\n+  b2 = \"_\"//b1//chr//\"_\"\n+  if (b2 .ne. \"_ABCDEFGHIJKLMNOP_\") call abort\n+\n+! Check the dependency is detected and dealt with by generation of a temporary.\n+  a1 = \"?\"//a1//\"?\"\n+  if (any (a1 .ne. [\"?ABCDEFGH?\",\"?abcdefgh?\"])) call abort\n+! With an array reference...\n+  a1 = \"?\"//a1(1:2)//\"?\"\n+  if (any (a1 .ne. [\"??ABCDEFGH??\",\"??abcdefgh??\"])) call abort\n+!... together with a substring.\n+  a1 = \"?\"//a1(1:1)(2:4)//\"?\"\n+  if (any (a1 .ne. [\"??AB?\"])) call abort\n+contains\n+end"}]}