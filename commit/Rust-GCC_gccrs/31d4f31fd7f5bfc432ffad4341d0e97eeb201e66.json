{"sha": "31d4f31fd7f5bfc432ffad4341d0e97eeb201e66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFkNGYzMWZkN2Y1YmZjNDMyZmZhZDQzNDFkMGU5N2VlYjIwMWU2Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-28T17:14:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-28T17:14:41Z"}, "message": "pa.c (hppa_legitimize_address): Don't lose for (plus (plus (mult (A) (shadd_const)) (B)) (C)) if...\n\n        * pa.c (hppa_legitimize_address): Don't lose for\n        (plus (plus (mult (A) (shadd_const)) (B)) (C)) if\n        B + C isn't a valid address for indexing.\n        (basereg_operand): Only accept base registers after\n        cse has completed.  Don't accept the frame pointer if\n        it's likely to be eliminated.\n        * pa.md (unscaled indexing patterns): Add variants with\n        basereg and index register reversed.\n        (HImode and QImode loads): Add zero extended variants.\n\nFrom-SVN: r11625", "tree": {"sha": "fa5198e3b4f6d4ddb91d77979cd2e83d10e5bd5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa5198e3b4f6d4ddb91d77979cd2e83d10e5bd5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31d4f31fd7f5bfc432ffad4341d0e97eeb201e66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d4f31fd7f5bfc432ffad4341d0e97eeb201e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31d4f31fd7f5bfc432ffad4341d0e97eeb201e66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d4f31fd7f5bfc432ffad4341d0e97eeb201e66/comments", "author": null, "committer": null, "parents": [{"sha": "fdb5537fe026a4c2ce2874325ca4793c2d2c642c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb5537fe026a4c2ce2874325ca4793c2d2c642c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdb5537fe026a4c2ce2874325ca4793c2d2c642c"}], "stats": {"total": 356, "additions": 349, "deletions": 7}, "files": [{"sha": "c27b2224e13fc027f3f2c5af0859fcea76176f8d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d4f31fd7f5bfc432ffad4341d0e97eeb201e66/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d4f31fd7f5bfc432ffad4341d0e97eeb201e66/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=31d4f31fd7f5bfc432ffad4341d0e97eeb201e66", "patch": "@@ -767,19 +767,19 @@ hppa_legitimize_address (x, oldx, mode)\n     {\n       rtx regx1, regx2;\n \n-      /* Add the two unscaled terms B and C; only force them into registers\n-\t if it's absolutely necessary.  */\n+      /* Add the two unscaled terms B and C; if either B or C isn't\n+\t a register or small constant int, then fail.  */\n       regx1 = XEXP (XEXP (x, 0), 1);\n       if (! (GET_CODE (regx1) == REG\n \t     || (GET_CODE (regx1) == CONST_INT\n \t\t && INT_14_BITS (regx1))))\n-\tregx1 = force_reg (Pmode, force_operand (XEXP (XEXP (x, 0), 1), 0));\n+\treturn orig;\n       \n       regx2 = XEXP (x, 1);\n       if (! (GET_CODE (regx2) == REG\n \t     || (GET_CODE (regx2) == CONST_INT\n \t\t && INT_14_BITS (regx2))))\n-\tregx2 = force_reg (Pmode, force_operand (XEXP (x, 1), 0));\n+\treturn orig;\n       \n       /* Add them, make sure the result is in canonical form.  */\n       if (GET_CODE (regx1) == REG)\n@@ -4941,6 +4941,12 @@ basereg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  /* cse will create some unscaled indexed addresses, however; it\n+     generally isn't a win on the PA, so avoid creating unscaled\n+     indexed addresses until after cse is finished.  */\n+  if (!cse_not_expected)\n+    return 0;\n+\n   /* Once reload has started everything is considered valid.  Reload should\n      only create indexed addresses using the stack/frame pointer, and any\n      others were checked for validity when created by the combine pass. \n@@ -4952,8 +4958,14 @@ basereg_operand (op, mode)\n   if (TARGET_NO_SPACE_REGS || reload_in_progress || reload_completed)\n     return (GET_CODE (op) == REG || GET_CODE (op) == CONST_INT);\n \n-  /* Stack and frame pointers are always OK for indexing.  */\n-  if (op == stack_pointer_rtx || op == frame_pointer_rtx)\n+  /* Stack is always OK for indexing.  */\n+  if (op == stack_pointer_rtx)\n+    return 1;\n+\n+  /* While it's always safe to index off the frame pointer, it's not\n+     always profitable, particularly when the frame pointer is being\n+     eliminated.  */\n+  if (! flag_omit_frame_pointer && op == frame_pointer_rtx)\n     return 1;\n \n   /* The only other valid OPs are pseudo registers with"}, {"sha": "a96cca46789978f46a80f440083cc16581b97d35", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 331, "deletions": 1, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d4f31fd7f5bfc432ffad4341d0e97eeb201e66/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d4f31fd7f5bfc432ffad4341d0e97eeb201e66/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=31d4f31fd7f5bfc432ffad4341d0e97eeb201e66", "patch": "@@ -1527,6 +1527,25 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"ldwx %1(0,%2),%0\\\";\n+  else\n+    return \\\"ldwx %2(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -1851,7 +1870,20 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n-;; This variant of the above insn can occur if the second operand\n+; Same thing with zero extension.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:HI\n+\t\t\t  (plus:SI\n+\t\t\t    (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (const_int 2))\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"ldhx,s %2(0,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; These variants of the above insns can occur if the second operand\n ;; is the frame pointer.  This is a kludge, but there doesn't\n ;; seem to be a way around it.  Only recognize it while reloading.\n ;; Note how operand 3 uses a predicate of \"const_int_operand\", but \n@@ -1877,6 +1909,44 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n+; Now the zero extended variant.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(zero_extend:SI (mem:HI (plus:SI (plus:SI\n+\t\t\t    (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (const_int 2))\n+\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"rI\")))))]\n+  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    return \\\"sh1addl %2,%1,%0\\;ldh %3(0,%0),%0\\\";\n+  else\n+    return \\\"sh1addl %2,%1,%0\\;ldhx %3(0,%0),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"ldhx %1(0,%2),%0\\\";\n+  else\n+    return \\\"ldhx %2(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -1896,6 +1966,49 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+; Now zero extended variants.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:HI\n+\t\t\t  (plus:SI\n+\t\t\t    (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"ldhx %1(0,%2),%0\\\";\n+  else\n+    return \\\"ldhx %2(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:HI\n+\t\t\t  (plus:SI\n+\t\t\t     (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t     (match_operand:SI 2 \"basereg_operand\" \"r\")))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[1] == hard_frame_pointer_rtx\n+      || operands[1] == stack_pointer_rtx)\n+    return \\\"ldhx %2(0,%1),%0\\\";\n+  else\n+    return \\\"ldhx %1(0,%2),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"=r\")\n@@ -1907,6 +2020,20 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+; And a zero extended variant.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:HI\n+\t\t\t  (plus:SI\n+\t\t\t    (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t\t\t    (match_operand:SI 2 \"int5_operand\" \"L\")))))\n+   (set (match_dup 1)\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldhs,mb %2(0,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (mem:HI (plus:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n \t\t\t (match_operand:SI 1 \"int5_operand\" \"L\")))\n@@ -1962,6 +2089,25 @@\n   [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"ldbx %1(0,%2),%0\\\";\n+  else\n+    return \\\"ldbx %2(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -1981,6 +2127,91 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+; Indexed byte load with zero extension to SImode or HImode.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:QI\n+\t\t\t  (plus:SI\n+\t\t\t    (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"ldbx %1(0,%2),%0\\\";\n+  else\n+    return \\\"ldbx %2(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:QI\n+\t\t\t  (plus:SI\n+\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"basereg_operand\" \"r\")))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[1] == hard_frame_pointer_rtx\n+      || operands[1] == stack_pointer_rtx)\n+    return \\\"ldbx %2(0,%1),%0\\\";\n+  else\n+    return \\\"ldbx %1(0,%2),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (mem:QI\n+\t\t\t  (plus:SI\n+\t\t\t    (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\")))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"ldbx %1(0,%2),%0\\\";\n+  else\n+    return \\\"ldbx %2(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (mem:QI\n+\t\t\t  (plus:SI\n+\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"basereg_operand\" \"r\")))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[1] == hard_frame_pointer_rtx\n+      || operands[1] == stack_pointer_rtx)\n+    return \\\"ldbx %2(0,%1),%0\\\";\n+  else\n+    return \\\"ldbx %1(0,%2),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"=r\")\n@@ -1991,6 +2222,29 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+; Now the same thing with zero extensions.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:QI (plus:SI\n+\t\t\t\t  (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t\t\t\t  (match_operand:SI 2 \"int5_operand\" \"L\")))))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldbs,mb %2(0,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (mem:QI (plus:SI\n+\t\t\t\t  (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t\t\t\t  (match_operand:SI 2 \"int5_operand\" \"L\")))))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldbs,mb %2(0,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (mem:QI (plus:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n \t\t\t (match_operand:SI 1 \"int5_operand\" \"L\")))\n@@ -2225,6 +2479,25 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=fx\")\n+\t(mem:DF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"flddx %1(0,%2),%0\\\";\n+  else\n+    return \\\"flddx %2(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=fx\")\n \t(mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -2283,6 +2556,25 @@\n   [(set_attr \"type\" \"fpstore\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (mem:DF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t(match_operand:DF 0 \"register_operand\" \"fx\"))]\n+  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"fstdx %0,%1(0,%2)\\\";\n+  else\n+    return \\\"fstdx %0,%2(0,%1)\\\";\n+}\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\")))\n@@ -2568,6 +2860,25 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fx\")\n+\t(mem:SF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"fldwx %1(0,%2),%0\\\";\n+  else\n+    return \\\"fldwx %2(0,%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=fx\")\n \t(mem:SF (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -2626,6 +2937,25 @@\n   [(set_attr \"type\" \"fpstore\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (mem:SF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+      (match_operand:SF 0 \"register_operand\" \"fx\"))]\n+  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n+  \"*\n+{\n+  /* Reload can create backwards (relative to cse) unscaled index\n+     address modes when eliminating registers and possibly for\n+     pseudos that don't get hard registers.  Deal with it.  */\n+  if (operands[2] == hard_frame_pointer_rtx\n+      || operands[2] == stack_pointer_rtx)\n+    return \\\"fstwx %0,%1(0,%2)\\\";\n+  else\n+    return \\\"fstwx %0,%2(0,%1)\\\";\n+}\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"4\")])\n+\f\n (define_insn \"\"\n   [(set (mem:SF (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"basereg_operand\" \"r\")))"}]}