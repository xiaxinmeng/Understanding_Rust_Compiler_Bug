{"sha": "3abe8cabdcb83ad745fe569f76887cd0920e5998", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FiZThjYWJkY2I4M2FkNzQ1ZmU1NjlmNzY4ODdjZDA5MjBlNTk5OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-11-15T19:55:27Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2010-11-15T19:55:27Z"}, "message": "re PR lto/41528 (LTO needs better internal and user documentation)\n\n2010-11-15  Jan Hubicka  <jh@suse.cz>\n\t    Diego Novillo  <dnovillo@google.com>\n\n\tPR lto/41528\n\t* doc/lto.texi: Add.\n\t* doc/gccint.texi: Add reference to lto.texi.\n\t* doc/invoke.texi: Update user documentation for LTO.\n\tMove internal flags to lto.texi\n\n\n\nCo-Authored-By: Diego Novillo <dnovillo@google.com>\n\nFrom-SVN: r166765", "tree": {"sha": "e00ea66faf2826dfa5cd19eab8b9b609914d931f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e00ea66faf2826dfa5cd19eab8b9b609914d931f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3abe8cabdcb83ad745fe569f76887cd0920e5998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3abe8cabdcb83ad745fe569f76887cd0920e5998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3abe8cabdcb83ad745fe569f76887cd0920e5998", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3abe8cabdcb83ad745fe569f76887cd0920e5998/comments", "author": null, "committer": null, "parents": [{"sha": "925e8657ce3e2d02766697a98fe2b51412979b30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/925e8657ce3e2d02766697a98fe2b51412979b30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/925e8657ce3e2d02766697a98fe2b51412979b30"}], "stats": {"total": 663, "additions": 609, "deletions": 54}, "files": [{"sha": "26dff01113e0d84146e5bfd4c924901966d2aa1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abe8cabdcb83ad745fe569f76887cd0920e5998/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abe8cabdcb83ad745fe569f76887cd0920e5998/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3abe8cabdcb83ad745fe569f76887cd0920e5998", "patch": "@@ -1,3 +1,12 @@\n+2010-11-15  Jan Hubicka  <jh@suse.cz>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\n+\tPR lto/41528\n+\t* doc/lto.texi: Add.\n+\t* doc/gccint.texi: Add reference to lto.texi.\n+\t* doc/invoke.texi: Update user documentation for LTO.\n+\tMove internal flags to lto.texi\n+\n 2010-11-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* c-typeck.c (build_unary_op): Use"}, {"sha": "d4a8a583c3bafacb3abbd7ca83a3aab56d81d854", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abe8cabdcb83ad745fe569f76887cd0920e5998/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abe8cabdcb83ad745fe569f76887cd0920e5998/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=3abe8cabdcb83ad745fe569f76887cd0920e5998", "patch": "@@ -123,6 +123,7 @@ Additional tutorial information is linked to from\n * Header Dirs::     Understanding the standard header file directories.\n * Type Information:: GCC's memory management; generating type information.\n * Plugins::         Extending the compiler with plugins.\n+* LTO::             Using Link-Time Optimization.\n \n * Funding::         How to help assure funding for free software.\n * GNU Project::     The GNU Project and GNU/Linux.\n@@ -158,6 +159,7 @@ Additional tutorial information is linked to from\n @include headerdirs.texi\n @include gty.texi\n @include plugins.texi\n+@include lto.texi\n \n @include funding.texi\n @include gnu.texi"}, {"sha": "2cc28219fa3c9545a9b665960559526c303df06f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 30, "deletions": 54, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abe8cabdcb83ad745fe569f76887cd0920e5998/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abe8cabdcb83ad745fe569f76887cd0920e5998/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3abe8cabdcb83ad745fe569f76887cd0920e5998", "patch": "@@ -356,8 +356,8 @@ Objective-C and Objective-C++ Dialects}.\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n -floop-block -floop-flatten -floop-interchange -floop-strip-mine @gol\n--floop-parallelize-all -flto -flto-compression-level -flto-partition=@var{alg} @gol\n--flto-report -fltrans -fltrans-output-list -fmerge-all-constants @gol\n+-floop-parallelize-all -flto -flto-compression-level\n+-flto-partition=@var{alg} -flto-report -fmerge-all-constants @gol\n -fmerge-constants -fmodulo-sched -fmodulo-sched-allow-regmoves @gol\n -fmove-loop-invariants fmudflap -fmudflapir -fmudflapth -fno-branch-count-reg @gol\n -fno-default-inline @gol\n@@ -399,7 +399,7 @@ Objective-C and Objective-C++ Dialects}.\n -funit-at-a-time -funroll-all-loops -funroll-loops @gol\n -funsafe-loop-optimizations -funsafe-math-optimizations -funswitch-loops @gol\n -fvariable-expansion-in-unroller -fvect-cost-model -fvpt -fweb @gol\n--fwhole-program -fwhopr[=@var{n}] -fwpa -fuse-linker-plugin @gol\n+-fwhole-program -fwpa -fuse-linker-plugin @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os -Ofast}\n \n@@ -7489,6 +7489,16 @@ The only important thing to keep in mind is that to enable link-time\n optimizations the @option{-flto} flag needs to be passed to both the\n compile and the link commands.\n \n+To make whole program optimization effective, it is necesary to make\n+certain whole program assumptions.  The compiler needs to know\n+what functions and variables can be accessed by libraries and runtime\n+outside of the link time optimized unit.  When supported by the linker,\n+the linker plugin (see @option{-fuse-linker-plugin}) passes to the\n+compiler information about used and externally visible symbols.  When\n+the linker plugin is not available, @option{-fwhole-program} should be\n+used to allow the compiler to make these assumptions, which will lead\n+to more aggressive optimization decisions.\n+\n Note that when a file is compiled with @option{-flto}, the generated\n object file will be larger than a regular object file because it will\n contain GIMPLE bytecodes and the usual final code.  This means that\n@@ -7601,16 +7611,18 @@ GCC will not work with an older/newer version of GCC.\n \n Link time optimization does not play well with generating debugging\n information.  Combining @option{-flto} with\n-@option{-g} is experimental.\n+@option{-g} is currently experimental and expected to produce wrong\n+results.\n \n-If you specify the optional @var{n} the link stage is executed in\n-parallel using @var{n} parallel jobs by utilizing an installed\n-@command{make} program.  The environment variable @env{MAKE} may be\n-used to override the program used.\n+If you specify the optional @var{n}, the optimization and code\n+generation done at link time is executed in parallel using @var{n}\n+parallel jobs by utilizing an installed @command{make} program.  The\n+environment variable @env{MAKE} may be used to override the program\n+used.  The default value for @var{n} is 1.\n \n-You can also specify @option{-fwhopr=jobserver} to use GNU make's \n+You can also specify @option{-flto=jobserver} to use GNU make's \n job server mode to determine the number of parallel jobs. This \n-is useful when the Makefile calling GCC is already parallel.\n+is useful when the Makefile calling GCC is already executing in parallel.\n The parent Makefile will need a @samp{+} prepended to the command recipe\n for this to work. This will likely only work if @env{MAKE} is \n GNU make.\n@@ -7619,53 +7631,17 @@ This option is disabled by default.\n \n @item -flto-partition=@var{alg}\n @opindex flto-partition\n-Specify partitioning algorithm used by @option{-fwhopr} mode.  The value is\n-either @code{1to1} to specify partitioning corresponding to source files\n-or @code{balanced} to specify partitioning into, if possible, equally sized\n-chunks.  Specifying @code{none} as an algorithm disables partitioning\n-and streaming completely.\n-The default value is @code{balanced}.\n-\n-@item -fwpa\n-@opindex fwpa\n-This is an internal option used by GCC when compiling with\n-@option{-fwhopr}.  You should never need to use it.\n-\n-This option runs the link-time optimizer in the whole-program-analysis\n-(WPA) mode, which reads in summary information from all inputs and\n-performs a whole-program analysis based on summary information only.\n-It generates object files for subsequent runs of the link-time\n-optimizer where individual object files are optimized using both\n-summary information from the WPA mode and the actual function bodies.\n-It then drives the LTRANS phase.\n-\n-Disabled by default.\n-\n-@item -fltrans\n-@opindex fltrans\n-This is an internal option used by GCC when compiling with\n-@option{-fwhopr}.  You should never need to use it.\n-\n-This option runs the link-time optimizer in the local-transformation (LTRANS)\n-mode, which reads in output from a previous run of the LTO in WPA mode.\n-In the LTRANS mode, LTO optimizes an object and produces the final assembly.\n-\n-Disabled by default.\n-\n-@item -fltrans-output-list=@var{file}\n-@opindex fltrans-output-list\n-This is an internal option used by GCC when compiling with\n-@option{-fwhopr}.  You should never need to use it.\n-\n-This option specifies a file to which the names of LTRANS output files are\n-written.  This option is only meaningful in conjunction with @option{-fwpa}.\n-\n-Disabled by default.\n+Specify the partitioning algorithm used by the link time optimizer.\n+The value is either @code{1to1} to specify a partitioning mirroring\n+the original source files or @code{balanced} to specify partitioning\n+into equally sized chunks (whenever possible).  Specifying @code{none}\n+as an algorithm disables partitioning and streaming completely. The\n+default value is @code{balanced}.\n \n @item -flto-compression-level=@var{n}\n This option specifies the level of compression used for intermediate\n language written to LTO object files, and is only meaningful in\n-conjunction with LTO mode (@option{-fwhopr}, @option{-flto}).  Valid\n+conjunction with LTO mode (@option{-flto}).  Valid\n values are 0 (no compression) to 9 (maximum compression).  Values\n outside this range are clamped to either 0 or 9.  If the option is not\n given, a default balanced compression setting is used.\n@@ -7674,7 +7650,7 @@ given, a default balanced compression setting is used.\n Prints a report with internal details on the workings of the link-time\n optimizer.  The contents of this report vary from version to version,\n it is meant to be useful to GCC developers when processing object\n-files in LTO mode (via @option{-fwhopr} or @option{-flto}).\n+files in LTO mode (via @option{-flto}).\n \n Disabled by default.\n "}, {"sha": "8daa8310aea743144094c2c223617e5c09889622", "filename": "gcc/doc/lto.texi", "status": "added", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3abe8cabdcb83ad745fe569f76887cd0920e5998/gcc%2Fdoc%2Flto.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3abe8cabdcb83ad745fe569f76887cd0920e5998/gcc%2Fdoc%2Flto.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flto.texi?ref=3abe8cabdcb83ad745fe569f76887cd0920e5998", "patch": "@@ -0,0 +1,568 @@\n+@c Copyright (c) 2010 Free Software Foundation, Inc.\n+@c Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+@c Contributed by Jan Hubicka <jh@suse.cz> and\n+@c Diego Novillo <dnovillo@google.com>\n+\n+@node LTO\n+@chapter Link Time Optimization\n+@cindex lto\n+@cindex whopr\n+@cindex wpa\n+@cindex ltrans\n+\n+@section Design Overview\n+\n+Link time optimization is implemented as a GCC front end for a\n+bytecode representation of GIMPLE that is emitted in special sections\n+of @code{.o} files.  Currently, LTO support is enabled in most\n+ELF-based systems, as well as darwin, cygwin and mingw systems.\n+\n+Since GIMPLE bytecode is saved alongside final object code, object\n+files generated with LTO support are larger than regular object files.\n+This ``fat'' object format makes it easy to integrate LTO into\n+existing build systems, as one can, for instance, produce archives of\n+the files.  Additionally, one might be able to ship one set of fat\n+objects which could be used both for development and the production of\n+optimized builds.  A, perhaps surprising, side effect of this feature\n+is that any mistake in the toolchain that leads to LTO information not\n+being used (e.g. an older @code{libtool} calling @code{ld} directly).\n+This is both an advantage, as the system is more robust, and a\n+disadvantage, as the user is not informed that the optimization has\n+been disabled.\n+\n+The current implementation only produces ``fat'' objects, effectively\n+doubling compilation time and increasing file sizes up to 5x the\n+original size.  This hides the problem that some tools, such as\n+@code{ar} and @code{nm}, need to understand symbol tables of LTO\n+sections.  These tools were extended to use the plugin infrastructure,\n+and with these problems solved, GCC will also support ``slim'' objects\n+consisting of the intermediate code alone.\n+\n+At the highest level, LTO splits the compiler in two.  The first half\n+(the ``writer'') produces a streaming representation of all the\n+internal data structures needed to optimize and generate code.  This\n+includes declarations, types, the callgraph and the GIMPLE representation\n+of function bodies.\n+\n+When @option{-flto} is given during compilation of a source file, the\n+pass manager executes all the passes in @code{all_lto_gen_passes}.\n+Currently, this phase is composed of two IPA passes:\n+\n+@itemize @bullet\n+@item @code{pass_ipa_lto_gimple_out}\n+This pass executes the function @code{lto_output} in\n+@file{lto-streamer-out.c}, which traverses the call graph encoding\n+every reachable declaration, type and function. This generates a\n+memory representation of all the file sections described below.\n+\n+@item @code{pass_ipa_lto_finish_out}\n+This pass executes the function @code{produce_asm_for_decls} in\n+@file{lto-streamer-out.c}, which takes the memory image built in the\n+previous pass and encodes it in the corresponding ELF file sections.\n+@end itemize\n+\n+The second half of LTO support is the ``reader''.  This is implemented\n+as the GCC front end @file{lto1} in @file{lto/lto.c}.  When\n+@file{collect2} detects a link set of @code{.o}/@code{.a} files with\n+LTO information and the @option{-flto} is enabled, it invokes\n+@file{lto1} which reads the set of files and aggregates them into a\n+single translation unit for optimization.  The main entry point for\n+the reader is @file{lto/lto.c}:@code{lto_main}.\n+\n+@subsection LTO modes of operation\n+\n+One of the main goals of the GCC link-time infrastructure was to allow\n+effective compilation of large programs.  For this reason GCC implements two\n+link-time compilation modes.\n+\n+@enumerate\n+@item\t@emph{LTO mode}, in which the whole program is read into the\n+compiler at link-time and optimized in a similar way as if it\n+were a single source-level compilation unit.\n+\n+@item\t@emph{WHOPR or partitioned mode}, designed to utilize multiple\n+CPUs and/or a distributed compilation environment to quickly link\n+large applications.  WHOPR stands for WHOle Program optimizeR (not to\n+be confused with the semantics of @option{-fwhole-program}).  It\n+partitions the aggregated callgraph from many different @code{.o}\n+files and distributes the compilation of the sub-graphs to different\n+CPUs.\n+\n+Note that distributed compilation is not implemented yet, but since\n+the parallelism is facilitated via generating a @code{Makefile}, it\n+would be easy to implement.\n+@end enumerate\n+\n+WHOPR splits LTO into three main stages:\n+@enumerate\n+@item Local generation (LGEN)\n+This stage executes in parallel. Every file in the program is compiled\n+into the intermediate language and packaged together with the local\n+call-graph and summary information.  This stage is the same for both\n+the LTO and WHOPR compilation mode.\n+\n+@item Whole Program Analysis (WPA)\n+WPA is performed sequentially. The global call-graph is generated, and\n+a global analysis procedure makes transformation decisions. The global\n+call-graph is partitioned to facilitate parallel optimization during\n+phase 3. The results of the WPA stage are stored into new object files\n+which contain the partitions of program expressed in the intermediate\n+language and the optimization decisions.\n+\n+@item Local transformations (LTRANS)\n+This stage executes in parallel. All the decisions made during phase 2\n+are implemented locally in each partitioned object file, and the final\n+object code is generated. Optimizations which cannot be decided\n+efficiently during the phase 2 may be performed on the local\n+call-graph partitions.\n+@end enumerate\n+\n+WHOPR can be seen as an extension of the usual LTO mode of\n+compilation.  In LTO, WPA and LTRANS and are executed within a single\n+execution of the compiler, after the whole program has been read into\n+memory.\n+\n+When compiling in WHOPR mode the callgraph is partitioned during\n+the WPA stage.  The whole program is split into a given number of\n+partitions of roughly the same size.  The compiler tries to\n+minimize the number of references which cross partition boundaries.\n+The main advantage of WHOPR is to allow the parallel execution of\n+LTRANS stages, which are the most time-consuming part of the\n+compilation process.  Additionally, it avoids the need to load the\n+whole program into memory.\n+\n+\n+@section LTO file sections\n+\n+LTO information is stored in several ELF sections inside object files.\n+Data structures and enum codes for sections are defined in\n+@file{lto-streamer.h}.\n+\n+These sections are emitted from @file{lto-streamer-out.c} and mapped\n+in all at once from @file{lto/lto.c}:@code{lto_file_read}.  The\n+individual functions dealing with the reading/writing of each section\n+are described below.\n+\n+@itemize @bullet\n+@item Command line options (@code{.gnu.lto_.opts})\n+\n+This section contains the command line options used to generate the\n+object files.  This is used at link-time to determine the optimization\n+level and other settings when they are not explicitly specified at the\n+linker command line.\n+\n+Currently, GCC does not support combining LTO object files compiled\n+with different set of the command line options into a single binary.\n+At link-time, the options given on the command line and the options\n+saved on all the files in a link-time set are applied globally.  No\n+attempt is made at validating the combination of flags (other than the\n+usual validation done by option processing).  This is implemented in\n+@file{lto/lto.c}:@code{lto_read_all_file_options}.\n+\n+\n+@item Symbol table (@code{.gnu.lto_.symtab})\n+\n+This table replaces the ELF symbol table for functions and variables\n+represented in the LTO IL. Symbols used and exported by the optimized\n+assembly code of ``fat'' objects might not match the ones used and\n+exported by the intermediate code.  This table is necessary because\n+the intermediate code is less optimized and thus requires a separate\n+symbol table.\n+\n+Additionally, the binary code in the ``fat'' object will lack a call\n+to a function, since the call was optimized out at compilation time\n+after the intermediate language was streamed out.  In some special\n+cases, the same optimization may not happen  during link-time\n+optimization.  This would lead to an undefined symbol if only one\n+symbol table was used.\n+\n+The symbol table is emitted in\n+@file{lto-streamer-out.c}:@code{produce_symtab}.\n+\n+\n+@item Global declarations and types (@code{.gnu.lto_.decls})\n+\n+This section contains an intermediate language dump of all\n+declarations and types required to represent the callgraph, static\n+variables and top-level debug info.\n+\n+The contents of this section are emitted in\n+@file{lto-streamer-out.c}:@code{produce_asm_for_decls}.  Types and\n+symbols are emitted in a topological order that preserves the sharing\n+of pointers when the file is read back in\n+(@file{lto.c}:@code{read_cgraph_and_symbols}).\n+\n+\n+@item The callgraph (@code{.gnu.lto_.cgraph})\n+\n+This section contains the basic data structure used by the GCC\n+inter-procedural optimization infrastructure. This section stores an\n+annotated multi-graph which represents the functions and call sites as\n+well as the variables, aliases and top-level @code{asm} statements.\n+\n+This section is emitted in\n+@file{lto-streamer-out.c}:@code{output_cgraph} and read in\n+@file{lto-cgraph.c}:@code{input_cgraph}.\n+\n+\n+@item IPA references (@code{.gnu.lto_.refs})\n+\n+This section contains references between function and static\n+variables.  It is emitted by @file{lto-cgraph.c}:@code{output_refs}\n+and read by @file{lto-cgraph.c}:@code{input_refs}.\n+\n+\n+@item Function bodies (@code{.gnu.lto_.function_body.<name>})\n+\n+This section contains function bodies in the intermediate language\n+representation. Every function body is in a separate section to allow\n+copying of the section independently to different object files or\n+reading the function on demand.\n+\n+Functions are emitted in\n+@file{lto-streamer-out.c}:@code{output_function} and read in\n+@file{lto-streamer-in.c}:@code{input_function}.\n+\n+\n+@item Static variable initializers (@code{.gnu.lto_.vars})\n+\n+This section contains all the symbols in the global variable pool.  It\n+is emitted by @file{lto-cgraph.c}:@code{output_varpool} and read in\n+@file{lto-cgraph.c}:@code{input_cgraph}.\n+\n+@item Summaries and optimization summaries used by IPA passes\n+(@code{.gnu.lto_.<xxx>}, where @code{<xxx>} is one of @code{jmpfuncs},\n+@code{pureconst} or @code{reference})\n+\n+These sections are used by IPA passes that need to emit summary\n+information during LTO generation to be read and aggregated at\n+link time.  Each pass is responsible for implementing two pass manager\n+hooks: one for writing the summary and another for reading it in.  The\n+format of these sections is entirely up to each individual pass.  The\n+only requirement is that the writer and reader hooks agree on the\n+format.\n+@end itemize\n+\n+\n+@section Using summary information in IPA passes\n+\n+Programs are represented internally as a @emph{callgraph} (a\n+multi-graph where nodes are functions and edges are call sites)\n+and a @emph{varpool} (a list of static and external variables in\n+the program).\n+\n+The inter-procedural optimization is organized as a sequence of\n+individual passes, which operate on the callgraph and the\n+varpool.  To make the implementation of WHOPR possible, every\n+inter-procedural optimization pass is split into several stages\n+that are executed at different times during WHOPR compilation:\n+\n+@itemize @bullet\n+@item LGEN time\n+@enumerate\n+@item @emph{Generate summary} (@code{generate_summary} in\n+@code{struct ipa_opt_pass_d}). This stage analyzes every function\n+body and variable initializer is examined and stores relevant\n+information into a pass-specific data structure.\n+\n+@item @emph{Write summary} (@code{write_summary} in\n+@code{struct ipa_opt_pass_d}. This stage writes all the\n+pass-specific information generated by @code{generate_summary}.\n+Summaries go into their own @code{LTO_section_*} sections that\n+have to be declared in @file{lto-streamer.h}:@code{enum\n+lto_section_type}.  A new section is created by calling\n+@code{create_output_block} and data can be written using the\n+@code{lto_output_*} routines.\n+@end enumerate\n+\n+@item WPA time\n+@enumerate\n+@item @emph{Read summary} (@code{read_summary} in\n+@code{struct ipa_opt_pass_d}). This stage reads all the\n+pass-specific information in exactly the same order that it was\n+written by @code{write_summary}.\n+\n+@item @emph{Execute} (@code{execute} in @code{struct\n+opt_pass}).  This performs inter-procedural propagation.  This\n+must be done without actual access to the individual function\n+bodies or variable initializers.  Typically, this results in a\n+transitive closure operation over the summary information of all\n+the nodes in the callgraph.\n+\n+@item @emph{Write optimization summary}\n+(@code{write_optimization_summary} in @code{struct\n+ipa_opt_pass_d}).  This writes the result of the inter-procedural\n+propagation into the object file.  This can use the same data\n+structures and helper routines used in @code{write_summary}.\n+@end enumerate\n+\n+@item LTRANS time\n+@enumerate\n+@item @emph{Read optimization summary}\n+(@code{read_optimization_summary} in @code{struct\n+ipa_opt_pass_d}).  The counterpart to\n+@code{write_optimization_summary}.  This reads the interprocedural\n+optimization decisions in exactly the same format emitted by\n+@code{write_optimization_summary}.\n+\n+@item @emph{Transform} (@code{function_transform} and\n+@code{variable_transform} in @code{struct ipa_opt_pass_d}).\n+The actual function bodies and variable initializers are updated\n+based on the information passed down from the @emph{Execute} stage.\n+@end enumerate\n+@end itemize\n+\n+The implementation of the inter-procedural passes are shared\n+between LTO, WHOPR and classic non-LTO compilation.\n+\n+@itemize\n+@item During the traditional file-by-file mode every pass executes its\n+own @emph{Generate summary}, @emph{Execute}, and @emph{Transform}\n+stages within the single execution context of the compiler.\n+\n+@item In LTO compilation mode, every pass uses @emph{Generate\n+summary} and @emph{Write summary} stages at compilation time,\n+while the @emph{Read summary}, @emph{Execute}, and\n+@emph{Transform} stages are executed at link time.\n+\n+@item In WHOPR mode all stages are used.\n+@end itemize\n+\n+To simplify development, the GCC pass manager differentiates\n+between normal inter-procedural passes and small inter-procedural\n+passes.  A @emph{small inter-procedural pass}\n+(@code{SIMPLE_IPA_PASS}) is a pass that does\n+everything at once and thus it can not be executed during WPA in\n+WHOPR mode. It defines only the @emph{Execute} stage and during\n+this stage it accesses and modifies the function bodies.  Such\n+passes are useful for optimization at LGEN or LTRANS time and are\n+used, for example, to implement early optimization before writing\n+object files.  The simple inter-procedural passes can also be used\n+for easier prototyping and development of a new inter-procedural\n+pass.\n+\n+\n+@subsection Virtual clones\n+\n+One of the main challenges of introducing the WHOPR compilation\n+mode was addressing the interactions between optimization passes.\n+In LTO compilation mode, the passes are executed in a sequence,\n+each of which consists of analysis (or @emph{Generate summary}),\n+propagation (or @emph{Execute}) and @emph{Transform} stages.\n+Once the work of one pass is finished, the next pass sees the\n+updated program representation and can execute.  This makes the\n+individual passes dependent on each other.\n+\n+In WHOPR mode all passes first execute their @emph{Generate\n+summary} stage.  Then summary writing marks the end of the LGEN\n+stage.  At WPA time,\n+the summaries are read back into memory and all passes run the\n+@emph{Execute} stage.  Optimization summaries are streamed and\n+sent to LTRANS, where all the passes execute the @emph{Transform}\n+stage.\n+\n+Most optimization passes split naturally into analysis,\n+propagation and transformation stages.  But some do not.  The\n+main problem arises when one pass performs changes and the\n+following pass gets confused by seeing different callgraphs\n+betwee the @emph{Transform} stage and the @emph{Generate summary}\n+or @emph{Execute} stage.  This means that the passes are required\n+to communicate their decisions with each other.\n+\n+To facilitate this communication, the GCC callgraph\n+infrastructure implements @emph{virtual clones}, a method of\n+representing the changes performed by the optimization passes in\n+the callgraph without needing to update function bodies.\n+\n+A @emph{virtual clone} in the callgraph is a function that has no\n+associated body, just a description of how to create its body based\n+on a different function (which itself may be a virtual clone).\n+\n+The description of function modifications includes adjustments to\n+the function's signature (which allows, for example, removing or\n+adding function arguments), substitutions to perform on the\n+function body, and, for inlined functions, a pointer to the\n+function that it will be inlined into.\n+\n+It is also possible to redirect any edge of the callgraph from a\n+function to its virtual clone.  This implies updating of the call\n+site to adjust for the new function signature.\n+\n+Most of the transformations performed by inter-procedural\n+optimizations can be represented via virtual clones.  For\n+instance, a constant propagation pass can produce a virtual clone\n+of the function which replaces one of its arguments by a\n+constant.  The inliner can represent its decisions by producing a\n+clone of a function whose body will be later integrated into\n+a given function.\n+\n+Using @emph{virtual clones}, the program can be easily updated\n+during the @emph{Execute} stage, solving most of pass interactions\n+problems that would otherwise occur during @emph{Transform}.\n+\n+Virtual clones are later materialized in the LTRANS stage and\n+turned into real functions.  Passes executed after the virtual\n+clone were introduced also perform their @emph{Transform} stage\n+on new functions, so for a pass there is no significant\n+difference between operating on a real function or a virtual\n+clone introduced before its @emph{Execute} stage.\n+\n+Optimization passes then work on virtual clones introduced before\n+their @emph{Execute} stage as if they were real functions.  The\n+only difference is that clones are not visible during the\n+@emph{Generate Summary} stage.\n+\n+To keep function summaries updated, the callgraph interface\n+allows an optimizer to register a callback that is called every\n+time a new clone is introduced as well as when the actual\n+function or variable is generated or when a function or variable\n+is removed.  These hooks are registered in the @emph{Generate\n+summary} stage and allow the pass to keep its information intact\n+until the @emph{Execute} stage.  The same hooks can also be\n+registered during the @emph{Execute} stage to keep the\n+optimization summaries updated for the @emph{Transform} stage.\n+\n+@subsection IPA references\n+\n+GCC represents IPA references in the callgraph.  For a function\n+or variable @code{A}, the @emph{IPA reference} is a list of all\n+locations where the address of @code{A} is taken and, when\n+@code{A} is a variable, a list of all direct stores and reads\n+to/from @code{A}. References represent an oriented multi-graph on\n+the union of nodes of the callgraph and the varpool.  See\n+@file{ipa-reference.c}:@code{ipa_reference_write_optimization_summary}\n+and\n+@file{ipa-reference.c}:@code{ipa_reference_read_optimization_summary}\n+for details.\n+\n+@subsection Jump functions\n+Suppose that an optimization pass sees a function @code{A} and it\n+knows the values of (some of) its arguments.  The @emph{jump\n+function} describes the value of a parameter of a given function\n+call in function @code{A} based on this knowledge.\n+\n+Jump functions are used by several optimizations, such as the\n+inter-procedural constant propagation pass and the\n+devirtualization pass.  The inliner also uses jump functions to\n+perform inlining of callbacks.\n+\n+@section Whole program assumptions, linker plugin and symbol visibilities\n+\n+Link-time optimization gives relatively minor benefits when used\n+alone.  The problem is that propagation of inter-procedural\n+information does not work well across functions and variables\n+that are called or referenced by other compilation units (such as\n+from a dynamically linked library). We say that such functions\n+are variables are @emph{externally visible}.\n+\n+To make the situation even more difficult, many applications\n+organize themselves as a set of shared libraries, and the default\n+ELF visibility rules allow one to overwrite any externally\n+visible symbol with a different symbol at runtime.  This\n+basically disables any optimizations across such functions and\n+variables, because the compiler cannot be sure that the function\n+body it is seeing is the same function body that will be used at\n+runtime.  Any function or variable not declared @code{static} in\n+the sources degrades the quality of inter-procedural\n+optimization.\n+\n+To avoid this problem the compiler must assume that it sees the\n+whole program when doing link-time optimization.  Strictly\n+speaking, the whole program is rarely visible even at link-time.\n+Standard system libraries are usually linked dynamically or not\n+provided with the link-time information.  In GCC, the whole\n+program option (@option{-fwhole-program}) asserts that every\n+function and variable defined in the current compilation\n+unit is static, except for function @code{main} (note: at\n+link-time, the current unit is the union of all objects compiled\n+with LTO).  Since some functions and variables need to\n+be referenced externally, for example by another DSO or from an\n+assembler file, GCC also provides the function and variable\n+attribute @code{externally_visible} which can be used to disable\n+the effect of @option{-fwhole-program} on a specific symbol.\n+\n+The whole program mode assumptions are slightly more complex in\n+C++, where inline functions in headers are put into @emph{COMDAT}\n+sections. COMDAT function and variables can be defined by\n+multiple object files and their bodies are unified at link-time\n+and dynamic link-time.  COMDAT functions are changed to local only\n+when their address is not taken and thus un-sharing them with a\n+library is not harmful.  COMDAT variables always remain externally\n+visible, however for readonly variables it is assumed that their\n+initializers cannot be overwritten by a different value.\n+\n+GCC provides the function and variable attribute\n+@code{visibility} that can be used to specify the visibility of\n+externally visible symbols (or alternatively an\n+@option{-fdefault-visibility} command line option).  ELF defines\n+the @code{default}, @code{protected}, @code{hidden} and\n+@code{internal} visibilities.\n+\n+The most commonly used is visibility is @code{hidden}. It\n+specifies that the symbol cannot be referenced from outside of\n+the current shared library. Unfortunately, this information\n+cannot be used directly by the link-time optimization in the\n+compiler since the whole shared library also might contain\n+non-LTO objects and those are not visible to the compiler.\n+\n+GCC solves this problem using linker plugins.  A @emph{linker\n+plugin} is an interface to the linker that allows an external\n+program to claim the ownership of a given object file.  The linker\n+then performs the linking procedure by querying the plugin about\n+the symbol table of the claimed objects and once the linking\n+decisions are complete, the plugin is allowed to provide the\n+final object file before the actual linking is made.  The linker\n+plugin obtains the symbol resolution information which specifies\n+which symbols provided by the claimed objects are bound from the\n+rest of a binary being linked.\n+\n+Currently, the linker plugin  works only in combination\n+with the Gold linker,  but a GNU ld implementation is under\n+development.\n+\n+GCC is designed to be independent of the rest of the toolchain\n+and aims to support linkers without plugin support.  For this\n+reason it does not use the linker plugin by default.  Instead,\n+the object files are examined by @command{collect2} before being\n+passed to the linker and objects found to have LTO sections are\n+passed to @command{lto1} first.  This mode does not work for\n+library archives. The decision on what object files from the\n+archive are needed depends on the actual linking and thus GCC\n+would have to implement the linker itself.  The resolution\n+information is missing too and thus GCC needs to make an educated\n+guess based on @option{-fwhole-program}.  Without the linker\n+plugin GCC also assumes that symbols are declared @code{hidden}\n+and not referred by non-LTO code by default.\n+\n+@section Internal flags controlling @code{lto1}\n+\n+The following flags are passed into @command{lto1} and are not\n+meant to be used directly from the command line.\n+\n+@itemize\n+@item -fwpa\n+@opindex fwpa\n+This option runs the serial part of the link-time optimizer\n+performing the inter-procedural propagation (WPA mode).  The\n+compiler reads in summary information from all inputs and\n+performs an analysis based on summary information only.  It\n+generates object files for subsequent runs of the link-time\n+optimizer where individual object files are optimized using both\n+summary information from the WPA mode and the actual function\n+bodies.  It then drives the LTRANS phase.\n+\n+@item -fltrans\n+@opindex fltrans\n+This option runs the link-time optimizer in the\n+local-transformation (LTRANS) mode, which reads in output from a\n+previous run of the LTO in WPA mode. In the LTRANS mode, LTO\n+optimizes an object and produces the final assembly.\n+\n+@item -fltrans-output-list=@var{file}\n+@opindex fltrans-output-list\n+This option specifies a file to which the names of LTRANS output\n+files are written.  This option is only meaningful in conjunction\n+with @option{-fwpa}.\n+@end itemize"}]}