{"sha": "93a3eea4ca7a6cd1640b135a173faab4601547fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNhM2VlYTRjYTdhNmNkMTY0MGIxMzVhMTczZmFhYjQ2MDE1NDdmYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-10-19T00:12:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-10-19T00:12:07Z"}, "message": "ipa.c (cgraph_externally_visible_p): Handle externally visible and preserve flags before trying to guess on visibility.\n\n\t* ipa.c (cgraph_externally_visible_p): Handle externally visible and\n\tpreserve flags before trying to guess on visibility.\n\t(varpool_externally_visible_p): New function.\n\t(function_and_variable_visibility): Use it.\n\nFrom-SVN: r165669", "tree": {"sha": "56903e4a522c2d1d31fe880336511a451174d1d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56903e4a522c2d1d31fe880336511a451174d1d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93a3eea4ca7a6cd1640b135a173faab4601547fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a3eea4ca7a6cd1640b135a173faab4601547fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93a3eea4ca7a6cd1640b135a173faab4601547fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a3eea4ca7a6cd1640b135a173faab4601547fa/comments", "author": null, "committer": null, "parents": [{"sha": "2a613cffb13f4dbb2b2af79645573e526d3224c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a613cffb13f4dbb2b2af79645573e526d3224c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a613cffb13f4dbb2b2af79645573e526d3224c8"}], "stats": {"total": 95, "additions": 71, "deletions": 24}, "files": [{"sha": "9ee830911280a65a5dc2e64e1b0dbe18ad8f18e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a3eea4ca7a6cd1640b135a173faab4601547fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a3eea4ca7a6cd1640b135a173faab4601547fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93a3eea4ca7a6cd1640b135a173faab4601547fa", "patch": "@@ -1,3 +1,10 @@\n+2010-10-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa.c (cgraph_externally_visible_p): Handle externally visible and\n+\tpreserve flags before trying to guess on visibility.\n+\t(varpool_externally_visible_p): New function.\n+\t(function_and_variable_visibility): Use it.\n+\n 2010-10-18  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented parsing @synthesize and @dynamic for Objective-C."}, {"sha": "7db27f3f859d087961d5bda161b8e6891985dd6e", "filename": "gcc/ipa.c", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a3eea4ca7a6cd1640b135a173faab4601547fa/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a3eea4ca7a6cd1640b135a173faab4601547fa/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=93a3eea4ca7a6cd1640b135a173faab4601547fa", "patch": "@@ -607,6 +607,11 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n   /* If linker counts on us, we must preserve the function.  */\n   if (cgraph_used_from_object_file_p (node))\n     return true;\n+  if (DECL_PRESERVE_P (node->decl))\n+    return true;\n+  if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n+    return true;\n+\n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n       && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n@@ -638,11 +643,64 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n \t      return true;\n \t}\n     }\n-  if (DECL_PRESERVE_P (node->decl))\n-    return true;\n+\n   if (MAIN_NAME_P (DECL_NAME (node->decl)))\n     return true;\n-  if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n+\n+  return false;\n+}\n+\n+/* Return true when variable VNODE should be considered externally visible.  */\n+\n+static bool\n+varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n+{\n+  if (!DECL_COMDAT (vnode->decl) && !TREE_PUBLIC (vnode->decl))\n+    return false;\n+\n+  /* Do not even try to be smart about aliased nodes.  Until we properly\n+     represent everything by same body alias, these are just evil.  */\n+  if (aliased)\n+    return true;\n+\n+  /* If linker counts on us, we must preserve the function.  */\n+  if (varpool_used_from_object_file_p (vnode))\n+    return true;\n+\n+  if (DECL_PRESERVE_P (vnode->decl))\n+    return true;\n+  if (lookup_attribute (\"externally_visible\",\n+\t\t\tDECL_ATTRIBUTES (vnode->decl)))\n+    return true;\n+\n+  /* See if we have linker information about symbol not being used or\n+     if we need to make guess based on the declaration.\n+\n+     Even if the linker clams the symbol is unused, never bring internal\n+     symbols that are declared by user as used or externally visible.\n+     This is needed for i.e. references from asm statements.   */\n+  if (varpool_used_from_object_file_p (vnode))\n+    return true;\n+\n+  /* When doing link time optimizations, hidden symbols become local.  */\n+  if (in_lto_p\n+      && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (vnode->decl) == VISIBILITY_INTERNAL)\n+      /* Be sure that node is defined in IR file, not in other object\n+\t file.  In that case we don't set used_from_other_object_file.  */\n+      && vnode->finalized)\n+    ;\n+  else if (!flag_whole_program)\n+    return true;\n+\n+  /* Do not attempt to privatize COMDATS by default.\n+     This would break linking with C++ libraries sharing\n+     inline definitions.\n+\n+     FIXME: We can do so for readonly vars with no address taken and\n+     possibly also for vtables since no direct pointer comparsion is done.\n+     It might be interesting to do so to reduce linking overhead.  */\n+  if (DECL_COMDAT (vnode->decl) || DECL_WEAK (vnode->decl))\n     return true;\n   return false;\n }\n@@ -798,27 +856,9 @@ function_and_variable_visibility (bool whole_program)\n       if (!vnode->finalized)\n         continue;\n       if (vnode->needed\n-\t  && (DECL_COMDAT (vnode->decl) || TREE_PUBLIC (vnode->decl))\n-\t  && (((!whole_program\n-\t        /* We can privatize comdat readonly variables whose address is\n-\t\t   not taken, but doing so is not going to bring us\n-\t\t   optimization oppurtunities until we start reordering\n-\t\t   datastructures.  */\n-\t\t|| DECL_COMDAT (vnode->decl)\n-\t\t|| DECL_WEAK (vnode->decl))\n-\t       /* When doing linktime optimizations, all hidden symbols will\n-\t\t  become local.  */\n-\t       && (!in_lto_p\n-\t\t   || (DECL_VISIBILITY (vnode->decl) != VISIBILITY_HIDDEN\n-\t\t       && DECL_VISIBILITY (vnode->decl) != VISIBILITY_INTERNAL)\n-\t\t   /* We can get prevailing decision in other object file.\n-\t\t      In this case we do not sed used_from_object_file.  */\n-\t\t   || !vnode->finalized))\n-\t      || DECL_PRESERVE_P (vnode->decl)\n-              || varpool_used_from_object_file_p (vnode)\n-\t      || pointer_set_contains (aliased_vnodes, vnode)\n-\t      || lookup_attribute (\"externally_visible\",\n-\t\t\t\t   DECL_ATTRIBUTES (vnode->decl))))\n+\t  && varpool_externally_visible_p\n+\t      (vnode, \n+\t       pointer_set_contains (aliased_vnodes, vnode)))\n \tvnode->externally_visible = true;\n       else\n         vnode->externally_visible = false;"}]}