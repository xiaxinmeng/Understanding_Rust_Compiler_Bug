{"sha": "8c152bad172993de682af91636b5ae70eb83149d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMxNTJiYWQxNzI5OTNkZTY4MmFmOTE2MzZiNWFlNzBlYjgzMTQ5ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-03-20T23:09:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-03-20T23:09:00Z"}, "message": "re PR c++/4361 (bogus ambiguity taking the address of a member template)\n\ncp:\n\tPR c++/4361\n\t* mangle.c (struct globals) Add internal_mangling_p member.\n\t(write_template_param): Do internal mangling, if needed.\n\t(mangle_conv_op_name_for_type): Request internal mangling.\n\nFrom-SVN: r51098", "tree": {"sha": "c52d88a300a436b981cc3d6059ec85d568e3a82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c52d88a300a436b981cc3d6059ec85d568e3a82f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c152bad172993de682af91636b5ae70eb83149d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c152bad172993de682af91636b5ae70eb83149d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c152bad172993de682af91636b5ae70eb83149d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c152bad172993de682af91636b5ae70eb83149d/comments", "author": null, "committer": null, "parents": [{"sha": "852b81bbe00b28c8a472c148c8fc84f6ecee9c3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852b81bbe00b28c8a472c148c8fc84f6ecee9c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852b81bbe00b28c8a472c148c8fc84f6ecee9c3b"}], "stats": {"total": 57, "additions": 49, "deletions": 8}, "files": [{"sha": "96b7f46cbaa6a894dc13a6bc6634f39ae157c8fe", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c152bad172993de682af91636b5ae70eb83149d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c152bad172993de682af91636b5ae70eb83149d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8c152bad172993de682af91636b5ae70eb83149d", "patch": "@@ -1,3 +1,10 @@\n+2002-03-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/4361\n+\t* mangle.c (struct globals) Add internal_mangling_p member.\n+\t(write_template_param): Do internal mangling, if needed.\n+\t(mangle_conv_op_name_for_type): Request internal mangling.\n+\n 2002-03-20  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/2136\n@@ -79,14 +86,11 @@\n \tall end up on slot 2.\n \t* lex.c (do_identifier): A conversion operator token might be\n \tsatisfied by a templated conversion operator.\n-\t* mangle.c (struct globals) Add internal_mangling_p member.\n-\t(write_template_param): Do internal mangling, if needed.\n-\t(mangle_conv_op_name_for_type): Request internal mangling.\n \t* pt.c (check_explicit_specialization): Use\n \tCLASSTYPE_FIRST_CONVERSION_SLOT.\n \t(template_parm_this_level_p): New function.\n \t(push_template_decl_real): Determine DECL_TEMPLATE_CONV_FN_P.\n-\t* search.c (lookup_fn_fields_1): Template conversions will be on\n+\t* search.c (lookup_fnfields_1): Template conversions will be on\n \tthe first slot.\n \t* typeck.c (build_component_ref): Preserve the type of an\n \tconversion operator name on the overload type."}, {"sha": "ac24b6eb8c6247c5c396efa30736cd93bda956bf", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c152bad172993de682af91636b5ae70eb83149d/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c152bad172993de682af91636b5ae70eb83149d/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=8c152bad172993de682af91636b5ae70eb83149d", "patch": "@@ -93,6 +93,11 @@ static struct globals\n   /* An array of the current substitution candidates, in the order\n      we've seen them.  */\n   varray_type substitutions;\n+\n+  /* We are mangling an internal symbol. It is important to keep those\n+     involving template parmeters distinct by distinguishing their level\n+     and, for non-type parms, their type.  */\n+  bool internal_mangling_p;\n } G;\n \n /* Indices into subst_identifiers.  These are identifiers used in\n@@ -2049,13 +2054,22 @@ write_pointer_to_member_type (type)\n    TEMPLATE_TEMPLATE_PARM, BOUND_TEMPLATE_TEMPLATE_PARM or a\n    TEMPLATE_PARM_INDEX.\n \n-     <template-param> ::= T </parameter/ number> _  */\n+     <template-param> ::= T </parameter/ number> _\n+\n+   If we are internally mangling then we distinguish level and, for\n+   non-type parms, type too. The mangling appends\n+   \n+     </level/ number> _ </non-type type/ type> _\n+\n+   This is used by mangle_conv_op_name_for_type.  */\n \n static void\n write_template_param (parm)\n      tree parm;\n {\n   int parm_index;\n+  int parm_level;\n+  tree parm_type = NULL_TREE;\n \n   MANGLE_TRACE_TREE (\"template-parm\", parm);\n \n@@ -2065,10 +2079,13 @@ write_template_param (parm)\n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       parm_index = TEMPLATE_TYPE_IDX (parm);\n+      parm_level = TEMPLATE_TYPE_LEVEL (parm);\n       break;\n \n     case TEMPLATE_PARM_INDEX:\n       parm_index = TEMPLATE_PARM_IDX (parm);\n+      parm_level = TEMPLATE_PARM_LEVEL (parm);\n+      parm_type = TREE_TYPE (TEMPLATE_PARM_DECL (parm));\n       break;\n \n     default:\n@@ -2081,6 +2098,15 @@ write_template_param (parm)\n   if (parm_index > 0)\n     write_unsigned_number (parm_index - 1);\n   write_char ('_');\n+  if (G.internal_mangling_p)\n+    {\n+      if (parm_level > 0)\n+\twrite_unsigned_number (parm_level - 1);\n+      write_char ('_');\n+      if (parm_type)\n+\twrite_type (parm_type);\n+      write_char ('_');\n+    }\n }\n \n /*  <template-template-param>\n@@ -2407,15 +2433,26 @@ mangle_conv_op_name_for_type (type)\n      tree type;\n {\n   tree identifier;\n+  const char *mangled_type;\n+  char *op_name;\n \n-  /* Build the mangling for TYPE.  */\n-  const char *mangled_type = mangle_type_string (type);\n+  /* Build the internal mangling for TYPE.  */\n+  G.internal_mangling_p = true;\n+  mangled_type = mangle_type_string (type);\n+  G.internal_mangling_p = false;\n+  \n   /* Allocate a temporary buffer for the complete name.  */\n-  char *op_name = concat (\"operator \", mangled_type, NULL);\n+  op_name = concat (\"operator \", mangled_type, NULL);\n   /* Find or create an identifier.  */\n   identifier = get_identifier (op_name);\n   /* Done with the temporary buffer.  */\n   free (op_name);\n+\n+  /* It had better be a unique mangling for the type.  */\n+  my_friendly_assert (!IDENTIFIER_TYPENAME_P (identifier)\n+\t\t      || same_type_p (type, TREE_TYPE (identifier)),\n+\t\t      20011230);\n+  \n   /* Set bits on the identifier so we know later it's a conversion.  */\n   IDENTIFIER_OPNAME_P (identifier) = 1;\n   IDENTIFIER_TYPENAME_P (identifier) = 1;"}]}