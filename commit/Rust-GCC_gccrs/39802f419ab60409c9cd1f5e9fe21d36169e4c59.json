{"sha": "39802f419ab60409c9cd1f5e9fe21d36169e4c59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk4MDJmNDE5YWI2MDQwOWM5Y2QxZjVlOWZlMjFkMzYxNjllNGM1OQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-09-05T10:41:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-05T10:41:24Z"}, "message": "Makefile.in (pexecute.o): Use pexecute.c from libiberty.\n\n        * Makefile.in (pexecute.o): Use pexecute.c from libiberty.  Provide\n        explicit rules for building.  Similarly for alloca and vfprintf.\n        * pexecute.c, alloca.c, vfprintf.c: Delete.\n\nFrom-SVN: r22248", "tree": {"sha": "82b5cbc4380abe10c9f4351c42d82535efeba1a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82b5cbc4380abe10c9f4351c42d82535efeba1a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39802f419ab60409c9cd1f5e9fe21d36169e4c59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39802f419ab60409c9cd1f5e9fe21d36169e4c59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39802f419ab60409c9cd1f5e9fe21d36169e4c59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39802f419ab60409c9cd1f5e9fe21d36169e4c59/comments", "author": null, "committer": null, "parents": [{"sha": "fd384dc9c8bed1e4fd22606c77a10bf0aab44483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd384dc9c8bed1e4fd22606c77a10bf0aab44483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd384dc9c8bed1e4fd22606c77a10bf0aab44483"}], "stats": {"total": 547, "additions": 14, "deletions": 533}, "files": [{"sha": "fc6aacab97236ab24435416d24b27a20233df4bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39802f419ab60409c9cd1f5e9fe21d36169e4c59/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39802f419ab60409c9cd1f5e9fe21d36169e4c59/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39802f419ab60409c9cd1f5e9fe21d36169e4c59", "patch": "@@ -1,8 +1,8 @@\n Sat Sep  5 03:23:05 1998  Jeffrey A Law  (law@cygnus.com)\n \n         * Makefile.in (pexecute.o): Use pexecute.c from libiberty.  Provide\n-\texplicit rules for building.\n-        * pexecute.c: Delete.\n+\texplicit rules for building.  Similarly for alloca and vfprintf.\n+        * pexecute.c, alloca.c, vfprintf.c: Delete.\n \n Fri Sep  4 11:57:50 1998  Tom Tromey  <tromey@cygnus.com>\n "}, {"sha": "ab1b04b3847c0af4f4fb50d2f698db03824834be", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39802f419ab60409c9cd1f5e9fe21d36169e4c59/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39802f419ab60409c9cd1f5e9fe21d36169e4c59/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=39802f419ab60409c9cd1f5e9fe21d36169e4c59", "patch": "@@ -1314,6 +1314,11 @@ pexecute.o: $(srcdir)/../libiberty/pexecute.c $(CONFIG_H) system.h gansidecl.h\n \t$(LN_S) $(srcdir)/../libiberty/pexecute.c pexecute.c\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) pexecute.c\n \n+vfprintf.o: $(srcdir)/../libiberty/vfprintf.c $(CONFIG_H) system.h gansidecl.h\n+\trm -f vfprintf.c\n+\t$(LN_S) $(srcdir)/../libiberty/vfprintf.c vfprintf.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) vfprintf.c\n+\n underscore.c: s-under ; @true\n \n s-under: $(GCC_PASSES)\n@@ -1527,9 +1532,11 @@ halfpic.o: halfpic.c $(CONFIG_H) $(RTL_H) $(TREE_H) system.h\n # Normally this target is not used; but it is used if you\n # define ALLOCA=alloca.o.  In that case, you must get a suitable alloca.c\n # from the GNU Emacs distribution.\n-alloca.o:\talloca.c\n+alloca.o:\t$(srcdir)/../libiberty/alloca.c\n+\trm -f alloca.c\n+\t$(LN_S) $(srcdir)/../libiberty/alloca.c alloca.c\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(ALLOCA_FLAGS) \\\n-\t  -c `echo $(srcdir)/alloca.c | sed 's,^\\./,,'`\n+\t  -c `echo alloca.c | sed 's,^\\./,,'`\n \t$(ALLOCA_FINISH)\n #\f\n # Generate header and source files from the machine description, \n@@ -1794,9 +1801,9 @@ $(HOST_PREFIX_1)rtlanal.o: $(srcdir)/rtlanal.c $(CONFIG_H) $(RTL_H)\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/rtlanal.c > $(HOST_PREFIX)rtlanal.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)rtlanal.c\n \n-$(HOST_PREFIX_1)alloca.o: alloca.c\n+$(HOST_PREFIX_1)alloca.o: $(srcdir)/../libiberty/alloca.c\n \trm -f $(HOST_PREFIX)alloca.c\n-\tcp $(srcdir)/alloca.c $(HOST_PREFIX)alloca.c\n+\t$(LN_S) $(srcdir)/../libiberty/alloca.c $(HOST_PREFIX)alloca.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)alloca.c\n \n $(HOST_PREFIX_1)obstack.o: obstack.c\n@@ -1806,7 +1813,7 @@ $(HOST_PREFIX_1)obstack.o: obstack.c\n \n $(HOST_PREFIX_1)vfprintf.o: $(srcdir)/../libiberty/vfprintf.c\n \trm -f $(HOST_PREFIX)vfprintf.c\n-\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)../libiberty/vfprintf.c > $(HOST_PREFIX)vfprintf.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/vfprintf.c > $(HOST_PREFIX)vfprintf.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)vfprintf.c\n \n $(HOST_PREFIX_1)doprint.o: doprint.c"}, {"sha": "0f8a21511db8f5112a4042762f6f8f0c4d5e5658", "filename": "gcc/alloca.c", "status": "removed", "additions": 0, "deletions": 505, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd384dc9c8bed1e4fd22606c77a10bf0aab44483/gcc%2Falloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd384dc9c8bed1e4fd22606c77a10bf0aab44483/gcc%2Falloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloca.c?ref=fd384dc9c8bed1e4fd22606c77a10bf0aab44483", "patch": "@@ -1,505 +0,0 @@\n-/* alloca.c -- allocate automatically reclaimed memory\n-   (Mostly) portable public-domain implementation -- D A Gwyn\n-\n-   This implementation of the PWB library alloca function,\n-   which is used to allocate space off the run-time stack so\n-   that it is automatically reclaimed upon procedure exit,\n-   was inspired by discussions with J. Q. Johnson of Cornell.\n-   J.Otto Tennant <jot@cray.com> contributed the Cray support.\n-\n-   There are some preprocessor constants that can\n-   be defined when compiling for your specific system, for\n-   improved efficiency; however, the defaults should be okay.\n-\n-   The general concept of this implementation is to keep\n-   track of all alloca-allocated blocks, and reclaim any\n-   that are found to be deeper in the stack than the current\n-   invocation.  This heuristic does not reclaim storage as\n-   soon as it becomes invalid, but it will do so eventually.\n-\n-   As a special case, alloca(0) reclaims storage without\n-   allocating any.  It is a good idea to use alloca(0) in\n-   your main control loop, etc. to force garbage collection.  */\n-\n-#ifdef HAVE_CONFIG_H\n-#include <config.h>\n-#endif\n-\n-#ifdef HAVE_STRING_H\n-#include <string.h>\n-#endif\n-#ifdef HAVE_STDLIB_H\n-#include <stdlib.h>\n-#endif\n-\n-#ifdef emacs\n-#include \"blockinput.h\"\n-#endif\n-\n-/* If compiling with GCC 2, this file's not needed.  Except of course if\n-   the C alloca is explicitly requested.  */\n-#if defined (USE_C_ALLOCA) || !defined (__GNUC__) || __GNUC__ < 2\n-\n-/* If someone has defined alloca as a macro,\n-   there must be some other way alloca is supposed to work.  */\n-#ifndef alloca\n-\n-#ifdef emacs\n-#ifdef static\n-/* actually, only want this if static is defined as \"\"\n-   -- this is for usg, in which emacs must undefine static\n-   in order to make unexec workable\n-   */\n-#ifndef STACK_DIRECTION\n-you\n-lose\n--- must know STACK_DIRECTION at compile-time\n-#endif /* STACK_DIRECTION undefined */\n-#endif /* static */\n-#endif /* emacs */\n-\n-/* If your stack is a linked list of frames, you have to\n-   provide an \"address metric\" ADDRESS_FUNCTION macro.  */\n-\n-#if defined (CRAY) && defined (CRAY_STACKSEG_END)\n-long i00afunc ();\n-#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))\n-#else\n-#define ADDRESS_FUNCTION(arg) &(arg)\n-#endif\n-\n-#if __STDC__\n-typedef void *pointer;\n-#else\n-typedef char *pointer;\n-#endif\n-\n-#ifndef NULL\n-#define\tNULL\t0\n-#endif\n-\n-/* Different portions of Emacs need to call different versions of\n-   malloc.  The Emacs executable needs alloca to call xmalloc, because\n-   ordinary malloc isn't protected from input signals.  On the other\n-   hand, the utilities in lib-src need alloca to call malloc; some of\n-   them are very simple, and don't have an xmalloc routine.\n-\n-   Non-Emacs programs expect this to call use xmalloc.\n-\n-   Callers below should use malloc.  */\n-\n-#ifndef emacs\n-#define malloc xmalloc\n-#endif\n-extern pointer malloc ();\n-\n-/* Define STACK_DIRECTION if you know the direction of stack\n-   growth for your system; otherwise it will be automatically\n-   deduced at run-time.\n-\n-   STACK_DIRECTION > 0 => grows toward higher addresses\n-   STACK_DIRECTION < 0 => grows toward lower addresses\n-   STACK_DIRECTION = 0 => direction of growth unknown  */\n-\n-#ifndef STACK_DIRECTION\n-#define\tSTACK_DIRECTION\t0\t/* Direction unknown.  */\n-#endif\n-\n-#if STACK_DIRECTION != 0\n-\n-#define\tSTACK_DIR\tSTACK_DIRECTION\t/* Known at compile-time.  */\n-\n-#else /* STACK_DIRECTION == 0; need run-time code.  */\n-\n-static int stack_dir;\t\t/* 1 or -1 once known.  */\n-#define\tSTACK_DIR\tstack_dir\n-\n-static void\n-find_stack_direction ()\n-{\n-  static char *addr = NULL;\t/* Address of first `dummy', once known.  */\n-  auto char dummy;\t\t/* To get stack address.  */\n-\n-  if (addr == NULL)\n-    {\t\t\t\t/* Initial entry.  */\n-      addr = ADDRESS_FUNCTION (dummy);\n-\n-      find_stack_direction ();\t/* Recurse once.  */\n-    }\n-  else\n-    {\n-      /* Second entry.  */\n-      if (ADDRESS_FUNCTION (dummy) > addr)\n-\tstack_dir = 1;\t\t/* Stack grew upward.  */\n-      else\n-\tstack_dir = -1;\t\t/* Stack grew downward.  */\n-    }\n-}\n-\n-#endif /* STACK_DIRECTION == 0 */\n-\n-/* An \"alloca header\" is used to:\n-   (a) chain together all alloca'ed blocks;\n-   (b) keep track of stack depth.\n-\n-   It is very important that sizeof(header) agree with malloc\n-   alignment chunk size.  The following default should work okay.  */\n-\n-#ifndef\tALIGN_SIZE\n-#define\tALIGN_SIZE\tsizeof(double)\n-#endif\n-\n-typedef union hdr\n-{\n-  char align[ALIGN_SIZE];\t/* To force sizeof(header).  */\n-  struct\n-    {\n-      union hdr *next;\t\t/* For chaining headers.  */\n-      char *deep;\t\t/* For stack depth measure.  */\n-    } h;\n-} header;\n-\n-static header *last_alloca_header = NULL;\t/* -> last alloca header.  */\n-\n-/* Return a pointer to at least SIZE bytes of storage,\n-   which will be automatically reclaimed upon exit from\n-   the procedure that called alloca.  Originally, this space\n-   was supposed to be taken from the current stack frame of the\n-   caller, but that method cannot be made to work for some\n-   implementations of C, for example under Gould's UTX/32.  */\n-\n-pointer\n-alloca (size)\n-     unsigned size;\n-{\n-  auto char probe;\t\t/* Probes stack depth: */\n-  register char *depth = ADDRESS_FUNCTION (probe);\n-\n-#if STACK_DIRECTION == 0\n-  if (STACK_DIR == 0)\t\t/* Unknown growth direction.  */\n-    find_stack_direction ();\n-#endif\n-\n-  /* Reclaim garbage, defined as all alloca'd storage that\n-     was allocated from deeper in the stack than currently.  */\n-\n-  {\n-    register header *hp;\t/* Traverses linked list.  */\n-\n-#ifdef emacs\n-    BLOCK_INPUT;\n-#endif\n-\n-    for (hp = last_alloca_header; hp != NULL;)\n-      if ((STACK_DIR > 0 && hp->h.deep > depth)\n-\t  || (STACK_DIR < 0 && hp->h.deep < depth))\n-\t{\n-\t  register header *np = hp->h.next;\n-\n-\t  free ((pointer) hp);\t/* Collect garbage.  */\n-\n-\t  hp = np;\t\t/* -> next header.  */\n-\t}\n-      else\n-\tbreak;\t\t\t/* Rest are not deeper.  */\n-\n-    last_alloca_header = hp;\t/* -> last valid storage.  */\n-\n-#ifdef emacs\n-    UNBLOCK_INPUT;\n-#endif\n-  }\n-\n-  if (size == 0)\n-    return NULL;\t\t/* No allocation required.  */\n-\n-  /* Allocate combined header + user data storage.  */\n-\n-  {\n-    register pointer new = malloc (sizeof (header) + size);\n-    /* Address of header.  */\n-\n-    if (new == 0)\n-      abort();\n-\n-    ((header *) new)->h.next = last_alloca_header;\n-    ((header *) new)->h.deep = depth;\n-\n-    last_alloca_header = (header *) new;\n-\n-    /* User storage begins just after header.  */\n-\n-    return (pointer) ((char *) new + sizeof (header));\n-  }\n-}\n-\n-#if defined (CRAY) && defined (CRAY_STACKSEG_END)\n-\n-#ifdef DEBUG_I00AFUNC\n-#include <stdio.h>\n-#endif\n-\n-#ifndef CRAY_STACK\n-#define CRAY_STACK\n-#ifndef CRAY2\n-/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */\n-struct stack_control_header\n-  {\n-    long shgrow:32;\t\t/* Number of times stack has grown.  */\n-    long shaseg:32;\t\t/* Size of increments to stack.  */\n-    long shhwm:32;\t\t/* High water mark of stack.  */\n-    long shsize:32;\t\t/* Current size of stack (all segments).  */\n-  };\n-\n-/* The stack segment linkage control information occurs at\n-   the high-address end of a stack segment.  (The stack\n-   grows from low addresses to high addresses.)  The initial\n-   part of the stack segment linkage control information is\n-   0200 (octal) words.  This provides for register storage\n-   for the routine which overflows the stack.  */\n-\n-struct stack_segment_linkage\n-  {\n-    long ss[0200];\t\t/* 0200 overflow words.  */\n-    long sssize:32;\t\t/* Number of words in this segment.  */\n-    long ssbase:32;\t\t/* Offset to stack base.  */\n-    long:32;\n-    long sspseg:32;\t\t/* Offset to linkage control of previous\n-\t\t\t\t   segment of stack.  */\n-    long:32;\n-    long sstcpt:32;\t\t/* Pointer to task common address block.  */\n-    long sscsnm;\t\t/* Private control structure number for\n-\t\t\t\t   microtasking.  */\n-    long ssusr1;\t\t/* Reserved for user.  */\n-    long ssusr2;\t\t/* Reserved for user.  */\n-    long sstpid;\t\t/* Process ID for pid based multi-tasking.  */\n-    long ssgvup;\t\t/* Pointer to multitasking thread giveup.  */\n-    long sscray[7];\t\t/* Reserved for Cray Research.  */\n-    long ssa0;\n-    long ssa1;\n-    long ssa2;\n-    long ssa3;\n-    long ssa4;\n-    long ssa5;\n-    long ssa6;\n-    long ssa7;\n-    long sss0;\n-    long sss1;\n-    long sss2;\n-    long sss3;\n-    long sss4;\n-    long sss5;\n-    long sss6;\n-    long sss7;\n-  };\n-\n-#else /* CRAY2 */\n-/* The following structure defines the vector of words\n-   returned by the STKSTAT library routine.  */\n-struct stk_stat\n-  {\n-    long now;\t\t\t/* Current total stack size.  */\n-    long maxc;\t\t\t/* Amount of contiguous space which would\n-\t\t\t\t   be required to satisfy the maximum\n-\t\t\t\t   stack demand to date.  */\n-    long high_water;\t\t/* Stack high-water mark.  */\n-    long overflows;\t\t/* Number of stack overflow ($STKOFEN) calls.  */\n-    long hits;\t\t\t/* Number of internal buffer hits.  */\n-    long extends;\t\t/* Number of block extensions.  */\n-    long stko_mallocs;\t\t/* Block allocations by $STKOFEN.  */\n-    long underflows;\t\t/* Number of stack underflow calls ($STKRETN).  */\n-    long stko_free;\t\t/* Number of deallocations by $STKRETN.  */\n-    long stkm_free;\t\t/* Number of deallocations by $STKMRET.  */\n-    long segments;\t\t/* Current number of stack segments.  */\n-    long maxs;\t\t\t/* Maximum number of stack segments so far.  */\n-    long pad_size;\t\t/* Stack pad size.  */\n-    long current_address;\t/* Current stack segment address.  */\n-    long current_size;\t\t/* Current stack segment size.  This\n-\t\t\t\t   number is actually corrupted by STKSTAT to\n-\t\t\t\t   include the fifteen word trailer area.  */\n-    long initial_address;\t/* Address of initial segment.  */\n-    long initial_size;\t\t/* Size of initial segment.  */\n-  };\n-\n-/* The following structure describes the data structure which trails\n-   any stack segment.  I think that the description in 'asdef' is\n-   out of date.  I only describe the parts that I am sure about.  */\n-\n-struct stk_trailer\n-  {\n-    long this_address;\t\t/* Address of this block.  */\n-    long this_size;\t\t/* Size of this block (does not include\n-\t\t\t\t   this trailer).  */\n-    long unknown2;\n-    long unknown3;\n-    long link;\t\t\t/* Address of trailer block of previous\n-\t\t\t\t   segment.  */\n-    long unknown5;\n-    long unknown6;\n-    long unknown7;\n-    long unknown8;\n-    long unknown9;\n-    long unknown10;\n-    long unknown11;\n-    long unknown12;\n-    long unknown13;\n-    long unknown14;\n-  };\n-\n-#endif /* CRAY2 */\n-#endif /* not CRAY_STACK */\n-\n-#ifdef CRAY2\n-/* Determine a \"stack measure\" for an arbitrary ADDRESS.\n-   I doubt that \"lint\" will like this much.  */\n-\n-static long\n-i00afunc (long *address)\n-{\n-  struct stk_stat status;\n-  struct stk_trailer *trailer;\n-  long *block, size;\n-  long result = 0;\n-\n-  /* We want to iterate through all of the segments.  The first\n-     step is to get the stack status structure.  We could do this\n-     more quickly and more directly, perhaps, by referencing the\n-     $LM00 common block, but I know that this works.  */\n-\n-  STKSTAT (&status);\n-\n-  /* Set up the iteration.  */\n-\n-  trailer = (struct stk_trailer *) (status.current_address\n-\t\t\t\t    + status.current_size\n-\t\t\t\t    - 15);\n-\n-  /* There must be at least one stack segment.  Therefore it is\n-     a fatal error if \"trailer\" is null.  */\n-\n-  if (trailer == 0)\n-    abort ();\n-\n-  /* Discard segments that do not contain our argument address.  */\n-\n-  while (trailer != 0)\n-    {\n-      block = (long *) trailer->this_address;\n-      size = trailer->this_size;\n-      if (block == 0 || size == 0)\n-\tabort ();\n-      trailer = (struct stk_trailer *) trailer->link;\n-      if ((block <= address) && (address < (block + size)))\n-\tbreak;\n-    }\n-\n-  /* Set the result to the offset in this segment and add the sizes\n-     of all predecessor segments.  */\n-\n-  result = address - block;\n-\n-  if (trailer == 0)\n-    {\n-      return result;\n-    }\n-\n-  do\n-    {\n-      if (trailer->this_size <= 0)\n-\tabort ();\n-      result += trailer->this_size;\n-      trailer = (struct stk_trailer *) trailer->link;\n-    }\n-  while (trailer != 0);\n-\n-  /* We are done.  Note that if you present a bogus address (one\n-     not in any segment), you will get a different number back, formed\n-     from subtracting the address of the first block.  This is probably\n-     not what you want.  */\n-\n-  return (result);\n-}\n-\n-#else /* not CRAY2 */\n-/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.\n-   Determine the number of the cell within the stack,\n-   given the address of the cell.  The purpose of this\n-   routine is to linearize, in some sense, stack addresses\n-   for alloca.  */\n-\n-static long\n-i00afunc (long address)\n-{\n-  long stkl = 0;\n-\n-  long size, pseg, this_segment, stack;\n-  long result = 0;\n-\n-  struct stack_segment_linkage *ssptr;\n-\n-  /* Register B67 contains the address of the end of the\n-     current stack segment.  If you (as a subprogram) store\n-     your registers on the stack and find that you are past\n-     the contents of B67, you have overflowed the segment.\n-\n-     B67 also points to the stack segment linkage control\n-     area, which is what we are really interested in.  */\n-\n-  stkl = CRAY_STACKSEG_END ();\n-  ssptr = (struct stack_segment_linkage *) stkl;\n-\n-  /* If one subtracts 'size' from the end of the segment,\n-     one has the address of the first word of the segment.\n-\n-     If this is not the first segment, 'pseg' will be\n-     nonzero.  */\n-\n-  pseg = ssptr->sspseg;\n-  size = ssptr->sssize;\n-\n-  this_segment = stkl - size;\n-\n-  /* It is possible that calling this routine itself caused\n-     a stack overflow.  Discard stack segments which do not\n-     contain the target address.  */\n-\n-  while (!(this_segment <= address && address <= stkl))\n-    {\n-#ifdef DEBUG_I00AFUNC\n-      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n-#endif\n-      if (pseg == 0)\n-\tbreak;\n-      stkl = stkl - pseg;\n-      ssptr = (struct stack_segment_linkage *) stkl;\n-      size = ssptr->sssize;\n-      pseg = ssptr->sspseg;\n-      this_segment = stkl - size;\n-    }\n-\n-  result = address - this_segment;\n-\n-  /* If you subtract pseg from the current end of the stack,\n-     you get the address of the previous stack segment's end.\n-     This seems a little convoluted to me, but I'll bet you save\n-     a cycle somewhere.  */\n-\n-  while (pseg != 0)\n-    {\n-#ifdef DEBUG_I00AFUNC\n-      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n-#endif\n-      stkl = stkl - pseg;\n-      ssptr = (struct stack_segment_linkage *) stkl;\n-      size = ssptr->sssize;\n-      pseg = ssptr->sspseg;\n-      result += size;\n-    }\n-  return (result);\n-}\n-\n-#endif /* not CRAY2 */\n-#endif /* CRAY */\n-\n-#endif /* no alloca */\n-#endif /* not GCC version 2 */"}, {"sha": "db7b2ff4c19e0f92e7548e11430ec79fbba6465f", "filename": "gcc/vfprintf.c", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd384dc9c8bed1e4fd22606c77a10bf0aab44483/gcc%2Fvfprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd384dc9c8bed1e4fd22606c77a10bf0aab44483/gcc%2Fvfprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvfprintf.c?ref=fd384dc9c8bed1e4fd22606c77a10bf0aab44483", "patch": "@@ -1,21 +0,0 @@\n-/* Provide a version vfprintf in terms of _doprnt.\n-   By Kaveh Ghazi  (ghazi@caip.rutgers.edu)  3/29/98\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n- */\n-\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-#include <stdio.h>\n-#undef vfprintf\n-\n-int\n-vfprintf (stream, format, ap)\n-  FILE * stream;\n-  const char * format;\n-  va_list ap;\n-{\n-  return _doprnt (format, ap, stream);\n-}"}]}