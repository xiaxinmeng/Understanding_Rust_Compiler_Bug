{"sha": "e57ab5507b20632ae70b0ce192cbeca049133a1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU3YWI1NTA3YjIwNjMyYWU3MGIwY2UxOTJjYmVjYTA0OTEzM2ExYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-18T10:18:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-18T10:18:07Z"}, "message": "[multiple changes]\n\n2010-10-18  Vincent Celier  <celier@adacore.com>\n\n\t* prj.ads (Source_Data): New Boolean flag In_The_Queue.\n\n2010-10-18  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-stausa.ads: Add the Top parameter to Initialize_Analyzer.\n\t* s-stausa.adb: Use the top parameter.  In Fill_Stack, use the\n\tstack top if known.\n\t* s-tassta.adb (Task_Wrapper): Call Initialize_Analyzer after Enter_Task\n\tso that Pri_Stack_Info.Limit can be set and used.\n\n2010-10-18  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads: Minor reformatting.\n\t* sem_res.adb (Resolve_Allocator): Add test for violating\n\tNo_Anonymous_Allocators.\n\nFrom-SVN: r165624", "tree": {"sha": "e04e4d582f301e695971081ecc83be8cd8ed59e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e04e4d582f301e695971081ecc83be8cd8ed59e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e57ab5507b20632ae70b0ce192cbeca049133a1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57ab5507b20632ae70b0ce192cbeca049133a1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e57ab5507b20632ae70b0ce192cbeca049133a1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57ab5507b20632ae70b0ce192cbeca049133a1a/comments", "author": null, "committer": null, "parents": [{"sha": "468ee96a95a470c06e0f646f0a7c83b189b7fbe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468ee96a95a470c06e0f646f0a7c83b189b7fbe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468ee96a95a470c06e0f646f0a7c83b189b7fbe6"}], "stats": {"total": 224, "additions": 145, "deletions": 79}, "files": [{"sha": "172416b35e1c22caa8215160b9a5619c90ff9a98", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e57ab5507b20632ae70b0ce192cbeca049133a1a", "patch": "@@ -1,3 +1,21 @@\n+2010-10-18  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj.ads (Source_Data): New Boolean flag In_The_Queue.\n+\n+2010-10-18  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-stausa.ads: Add the Top parameter to Initialize_Analyzer.\n+\t* s-stausa.adb: Use the top parameter.  In Fill_Stack, use the\n+\tstack top if known.\n+\t* s-tassta.adb (Task_Wrapper): Call Initialize_Analyzer after Enter_Task\n+\tso that Pri_Stack_Info.Limit can be set and used.\n+\n+2010-10-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads: Minor reformatting.\n+\t* sem_res.adb (Resolve_Allocator): Add test for violating\n+\tNo_Anonymous_Allocators.\n+\n 2010-10-18  Robert Dewar  <dewar@adacore.com>\n \n \t* prj-nmsc.adb, prj.adb, sem_res.adb: Minor reformatting."}, {"sha": "d78bcca90a21edb286f4153f5193788ab9226ba0", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=e57ab5507b20632ae70b0ce192cbeca049133a1a", "patch": "@@ -3778,15 +3778,14 @@ package Einfo is\n    --  E_Access_Subtype is for an access subtype created by a subtype\n    --  declaration.\n \n-   --  In addition, we define the kind E_Allocator_Type to label\n-   --  allocators. This is because special resolution rules apply to this\n-   --  construct. Eventually the constructs are labeled with the access\n-   --  type imposed by the context. Gigi should never see the type\n-   --  E_Allocator.\n-\n-   --  Similarly, the type E_Access_Attribute_Type is used as the initial\n-   --  kind associated with an access attribute. After resolution a specific\n-   --  access type will be established as determined by the context.\n+   --  In addition, we define the kind E_Allocator_Type to label allocators.\n+   --  This is because special resolution rules apply to this construct.\n+   --  Eventually the constructs are labeled with the access type imposed by\n+   --  the context. Gigi should never see the type E_Allocator.\n+\n+   --  Similarly, the type E_Access_Attribute_Type is used as the initial kind\n+   --  associated with an access attribute. After resolution a specific access\n+   --  type will be established as determined by the context.\n \n    --  Finally, the type Any_Access is used to label -null- during type\n    --  resolution. Any_Access is also replaced by the context type after"}, {"sha": "ccf0853bda521e678b2161f9034a1ef9bf064e8b", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=e57ab5507b20632ae70b0ce192cbeca049133a1a", "patch": "@@ -710,6 +710,9 @@ package Prj is\n       --  Updated at the first call to Is_Compilable. Yes if source file is\n       --  compilable.\n \n+      In_The_Queue : Boolean := False;\n+      --  True if the source has been put in the queue\n+\n       Locally_Removed : Boolean := False;\n       --  True if the source has been \"excluded\"\n \n@@ -793,6 +796,7 @@ package Prj is\n                        Index                  => 0,\n                        Locally_Removed        => False,\n                        Compilable             => Unknown,\n+                       In_The_Queue           => False,\n                        Replaced_By            => No_Source,\n                        File                   => No_File,\n                        Display_File           => No_File,"}, {"sha": "d533e0ceb5aeb7fa210542f05f0da5f587e5aa0e", "filename": "gcc/ada/s-stausa.adb", "status": "modified", "additions": 83, "deletions": 46, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=e57ab5507b20632ae70b0ce192cbeca049133a1a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 2004-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2004-2010, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -232,7 +232,8 @@ package body System.Stack_Usage is\n                \"ENVIRONMENT TASK\",\n                My_Stack_Size,\n                My_Stack_Size,\n-               System.Storage_Elements.To_Integer (Bottom_Of_Stack'Address));\n+               System.Storage_Elements.To_Integer (Bottom_Of_Stack'Address),\n+               0);\n \n             Fill_Stack (Environment_Task_Analyzer);\n \n@@ -259,56 +260,90 @@ package body System.Stack_Usage is\n       Stack_Used_When_Filling : Integer;\n       Current_Stack_Level     : aliased Integer;\n \n+      Guard : constant Integer := 256;\n+      --  Guard space between the Current_Stack_Level'Address and the last\n+      --  allocated byte on the stack.\n    begin\n-      --  Readjust the pattern size. When we arrive in this function, there is\n-      --  already a given amount of stack used, that we won't analyze.\n+      if Analyzer.Top_Pattern_Mark /= 0 then\n+         --  Easiest and most accurate method: the top of the stack is known.\n \n-      Stack_Used_When_Filling :=\n-        Stack_Size\n-         (Analyzer.Bottom_Of_Stack,\n-          To_Stack_Address (Current_Stack_Level'Address))\n-          + Natural (Current_Stack_Level'Size);\n+         Analyzer.Pattern_Size :=\n+           Stack_Size (Analyzer.Top_Pattern_Mark,\n+                       To_Stack_Address (Current_Stack_Level'Address))\n+           - Guard;\n \n-      if Stack_Used_When_Filling > Analyzer.Pattern_Size then\n-         --  In this case, the known size of the stack is too small, we've\n-         --  already taken more than expected, so there's no possible\n-         --  computation\n+         if System.Parameters.Stack_Grows_Down then\n+            Analyzer.Stack_Overlay_Address :=\n+              To_Address (Analyzer.Top_Pattern_Mark);\n+         else\n+            Analyzer.Stack_Overlay_Address :=\n+              To_Address (Analyzer.Top_Pattern_Mark\n+                            - Stack_Address (Analyzer.Pattern_Size));\n+         end if;\n \n-         Analyzer.Pattern_Size := 0;\n-      else\n-         Analyzer.Pattern_Size :=\n-           Analyzer.Pattern_Size - Stack_Used_When_Filling;\n-      end if;\n+         declare\n+            Pattern : aliased Stack_Slots\n+              (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n+            for Pattern'Address use Analyzer.Stack_Overlay_Address;\n+         begin\n+            if System.Parameters.Stack_Grows_Down then\n+               for I in reverse Pattern'Range loop\n+                  Pattern (I) := Analyzer.Pattern;\n+               end loop;\n+               Analyzer.Bottom_Pattern_Mark :=\n+                 To_Stack_Address (Pattern (Pattern'Last)'Address);\n+            else\n+               for I in Pattern'Range loop\n+                  Pattern (I) := Analyzer.Pattern;\n+               end loop;\n+               Analyzer.Bottom_Pattern_Mark :=\n+                 To_Stack_Address (Pattern (Pattern'First)'Address);\n+            end if;\n+         end;\n \n-      declare\n-         Stack : aliased Stack_Slots\n-                           (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n+      else\n+         --  Readjust the pattern size. When we arrive in this function, there\n+         --  is already a given amount of stack used, that we won't analyze.\n \n-      begin\n-         Stack := (others => Analyzer.Pattern);\n+         Stack_Used_When_Filling :=\n+           Stack_Size (Analyzer.Bottom_Of_Stack,\n+                       To_Stack_Address (Current_Stack_Level'Address));\n \n-         Analyzer.Stack_Overlay_Address := Stack'Address;\n+         if Stack_Used_When_Filling > Analyzer.Pattern_Size then\n+            --  In this case, the known size of the stack is too small, we've\n+            --  already taken more than expected, so there's no possible\n+            --  computation\n \n-         if Analyzer.Pattern_Size /= 0 then\n-            Analyzer.Bottom_Pattern_Mark :=\n-              To_Stack_Address (Stack (Bottom_Slot_Index_In (Stack))'Address);\n-            Analyzer.Top_Pattern_Mark :=\n-              To_Stack_Address (Stack (Top_Slot_Index_In (Stack))'Address);\n+            Analyzer.Pattern_Size := 0;\n          else\n-            Analyzer.Bottom_Pattern_Mark := To_Stack_Address (Stack'Address);\n-            Analyzer.Top_Pattern_Mark := To_Stack_Address (Stack'Address);\n+            Analyzer.Pattern_Size :=\n+              Analyzer.Pattern_Size - Stack_Used_When_Filling;\n          end if;\n \n-         --  If Arr has been packed, the following assertion must be true (we\n-         --  add the size of the element whose address is:\n-         --    Min (Analyzer.Inner_Pattern_Mark, Analyzer.Outer_Pattern_Mark)):\n+         declare\n+            Stack : aliased Stack_Slots\n+              (1 .. Analyzer.Pattern_Size / Bytes_Per_Pattern);\n \n-         pragma Assert\n-           (Analyzer.Pattern_Size = 0 or else\n-            Analyzer.Pattern_Size =\n-              Stack_Size\n-                (Analyzer.Top_Pattern_Mark, Analyzer.Bottom_Pattern_Mark));\n-      end;\n+         begin\n+            Stack := (others => Analyzer.Pattern);\n+\n+            Analyzer.Stack_Overlay_Address := Stack'Address;\n+\n+            if Analyzer.Pattern_Size /= 0 then\n+               Analyzer.Bottom_Pattern_Mark :=\n+                 To_Stack_Address\n+                   (Stack (Bottom_Slot_Index_In (Stack))'Address);\n+               Analyzer.Top_Pattern_Mark :=\n+                 To_Stack_Address\n+                   (Stack (Top_Slot_Index_In (Stack))'Address);\n+            else\n+               Analyzer.Bottom_Pattern_Mark :=\n+                 To_Stack_Address (Stack'Address);\n+               Analyzer.Top_Pattern_Mark :=\n+                 To_Stack_Address (Stack'Address);\n+            end if;\n+         end;\n+      end if;\n    end Fill_Stack;\n \n    -------------------------\n@@ -321,17 +356,19 @@ package body System.Stack_Usage is\n       My_Stack_Size    : Natural;\n       Max_Pattern_Size : Natural;\n       Bottom           : Stack_Address;\n+      Top              : Stack_Address;\n       Pattern          : Unsigned_32 := 16#DEAD_BEEF#)\n    is\n    begin\n       --  Initialize the analyzer fields\n \n-      Analyzer.Bottom_Of_Stack := Bottom;\n-      Analyzer.Stack_Size      := My_Stack_Size;\n-      Analyzer.Pattern_Size    := Max_Pattern_Size;\n-      Analyzer.Pattern         := Pattern;\n-      Analyzer.Result_Id       := Next_Id;\n-      Analyzer.Task_Name       := (others => ' ');\n+      Analyzer.Bottom_Of_Stack  := Bottom;\n+      Analyzer.Stack_Size       := My_Stack_Size;\n+      Analyzer.Pattern_Size     := Max_Pattern_Size;\n+      Analyzer.Pattern          := Pattern;\n+      Analyzer.Result_Id        := Next_Id;\n+      Analyzer.Task_Name        := (others => ' ');\n+      Analyzer.Top_Pattern_Mark := Top;\n \n       --  Compute the task name, and truncate if bigger than Task_Name_Length\n "}, {"sha": "1cd78ea0465136a47d43fc94f111e30d12363be7", "filename": "gcc/ada/s-stausa.ads", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fs-stausa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fs-stausa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.ads?ref=e57ab5507b20632ae70b0ce192cbeca049133a1a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---         Copyright (C) 2004-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 2004-2010, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -218,17 +218,19 @@ package System.Stack_Usage is\n    --  |  of Fill_Stack         |                                     |\n    --  |  (deallocated at       |                                     |\n    --  |  the end of the call)  |                                     |\n-   --  ^                        |                                     |\n-   --  Analyzer.Bottom_Of_Stack ^                                     |\n-   --                    Analyzer.Bottom_Pattern_Mark                 ^\n-   --                                            Analyzer.Top_Pattern_Mark\n+   --  ^                        |                                     ^\n+   --  Analyzer.Bottom_Of_Stack |                  Analyzer.Top_Pattern_Mark\n+   --                           ^\n+   --                    Analyzer.Bottom_Pattern_Mark\n+   --\n \n    procedure Initialize_Analyzer\n      (Analyzer         : in out Stack_Analyzer;\n       Task_Name        : String;\n       My_Stack_Size    : Natural;\n       Max_Pattern_Size : Natural;\n       Bottom           : Stack_Address;\n+      Top              : Stack_Address;\n       Pattern          : Interfaces.Unsigned_32 := 16#DEAD_BEEF#);\n    --  Should be called before any use of a Stack_Analyzer, to initialize it.\n    --  Max_Pattern_Size is the size of the pattern zone, might be smaller than"}, {"sha": "c10cdd82d0a8dcb77a61495fd619e34b0aec1cb7", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=e57ab5507b20632ae70b0ce192cbeca049133a1a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2010, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1093,11 +1093,6 @@ package body System.Tasking.Stages is\n \n       --  Assume a size of the stack taken at this stage\n \n-      Overflow_Guard :=\n-        (if Size < Small_Stack_Limit\n-         then Small_Overflow_Guard\n-         else Big_Overflow_Guard);\n-\n       if not Parameters.Sec_Stack_Dynamic then\n          Self_ID.Common.Compiler_Data.Sec_Stack_Addr :=\n            Secondary_Stack'Address;\n@@ -1109,32 +1104,39 @@ package body System.Tasking.Stages is\n          Self_ID.Common.Task_Alternate_Stack := Task_Alternate_Stack'Address;\n       end if;\n \n-      Size := Size - Overflow_Guard;\n+      --  Set the guard page at the bottom of the stack. The call to unprotect\n+      --  the page is done in Terminate_Task\n+\n+      Stack_Guard (Self_ID, True);\n+\n+      --  Initialize low-level TCB components, that cannot be initialized by\n+      --  the creator. Enter_Task sets Self_ID.LL.Thread\n+\n+      Enter_Task (Self_ID);\n+\n+      --  Initialize dynamic stack usage\n \n       if System.Stack_Usage.Is_Enabled then\n+         Overflow_Guard :=\n+           (if Size < Small_Stack_Limit\n+              then Small_Overflow_Guard\n+              else Big_Overflow_Guard);\n+\n          STPO.Lock_RTS;\n          Initialize_Analyzer\n            (Self_ID.Common.Analyzer,\n             Self_ID.Common.Task_Image\n               (1 .. Self_ID.Common.Task_Image_Len),\n             Natural\n               (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size),\n-            Size,\n-            SSE.To_Integer (Bottom_Of_Stack'Address));\n+            Size - Overflow_Guard,\n+            SSE.To_Integer (Bottom_Of_Stack'Address),\n+            SSE.To_Integer\n+              (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Limit));\n          STPO.Unlock_RTS;\n          Fill_Stack (Self_ID.Common.Analyzer);\n       end if;\n \n-      --  Set the guard page at the bottom of the stack. The call to unprotect\n-      --  the page is done in Terminate_Task\n-\n-      Stack_Guard (Self_ID, True);\n-\n-      --  Initialize low-level TCB components, that cannot be initialized by\n-      --  the creator. Enter_Task sets Self_ID.LL.Thread\n-\n-      Enter_Task (Self_ID);\n-\n       --  We setup the SEH (Structured Exception Handling) handler if supported\n       --  on the target.\n "}, {"sha": "0e670475249ecf2e8b9b841b8a71f522e4a14694", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57ab5507b20632ae70b0ce192cbeca049133a1a/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=e57ab5507b20632ae70b0ce192cbeca049133a1a", "patch": "@@ -4324,6 +4324,10 @@ package body Sem_Res is\n            (Typ, Associated_Storage_Pool (Etype (Parent (N))));\n       end if;\n \n+      if Ekind (Etype (N)) = E_Anonymous_Access_Type then\n+         Check_Restriction (No_Anonymous_Allocators, N);\n+      end if;\n+\n       --  An erroneous allocator may be rewritten as a raise Program_Error\n       --  statement.\n "}]}