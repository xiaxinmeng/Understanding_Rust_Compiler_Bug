{"sha": "037f20f16831bf88dfc5c459cd4299f925ee0df9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM3ZjIwZjE2ODMxYmY4OGRmYzVjNDU5Y2Q0Mjk5ZjkyNWVlMGRmOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-04-11T12:10:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-04-11T12:10:22Z"}, "message": "i386.md (floatsisf_sse): Fix output template\n\n\t* i386.md (floatsisf_sse): Fix output template\n\t* i386.c (ix86_expand_fp_movcc)\n\n\t* reg-stack.c (emit_pop_insn): Handle complex modes.\n\t(move_for_stack_reg): Emit proper move mode.\n\t(subst_stack_regs_pat): Handle complex modes.\n\nFrom-SVN: r41250", "tree": {"sha": "661dac474986ac3c9041f90b5c8d52b65f6f5dae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/661dac474986ac3c9041f90b5c8d52b65f6f5dae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/037f20f16831bf88dfc5c459cd4299f925ee0df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037f20f16831bf88dfc5c459cd4299f925ee0df9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/037f20f16831bf88dfc5c459cd4299f925ee0df9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037f20f16831bf88dfc5c459cd4299f925ee0df9/comments", "author": null, "committer": null, "parents": [{"sha": "01ef656387da241b1f72fde4f174c9cb3fae0e27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ef656387da241b1f72fde4f174c9cb3fae0e27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01ef656387da241b1f72fde4f174c9cb3fae0e27"}], "stats": {"total": 49, "additions": 44, "deletions": 5}, "files": [{"sha": "155b0da5af3b09d16a8caba85b080dd12a1c1bc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037f20f16831bf88dfc5c459cd4299f925ee0df9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037f20f16831bf88dfc5c459cd4299f925ee0df9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=037f20f16831bf88dfc5c459cd4299f925ee0df9", "patch": "@@ -1,3 +1,12 @@\n+Wed Apr 11 14:06:10 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (floatsisf_sse): Fix output template\n+\t* i386.c (ix86_expand_fp_movcc)\n+\n+\t* reg-stack.c (emit_pop_insn): Handle complex modes.\n+\t(move_for_stack_reg): Emit proper move mode.\n+\t(subst_stack_regs_pat): Handle complex modes.\n+\n 2001-04-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cpplex.c (_cpp_lex_token): Only warn if -Wcomment."}, {"sha": "e6e76fe279e72251793385b72702f45ab5642612", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037f20f16831bf88dfc5c459cd4299f925ee0df9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037f20f16831bf88dfc5c459cd4299f925ee0df9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=037f20f16831bf88dfc5c459cd4299f925ee0df9", "patch": "@@ -6664,8 +6664,9 @@ ix86_expand_fp_movcc (operands)\n       /* Similary try to manage result to be first operand of conditional\n \t move. We also don't support the NE comparison on SSE, so try to\n \t avoid it.  */\n-      if (rtx_equal_p (operands[0], operands[3])\n-\t  || GET_CODE (operands[1]) == NE)\n+      if ((rtx_equal_p (operands[0], operands[3])\n+\t   && (!TARGET_IEEE_FP || GET_CODE (operands[1]) != EQ))\n+\t  || (GET_CODE (operands[1]) == NE && TARGET_IEEE_FP))\n \t{\n \t  rtx tmp = operands[2];\n \t  operands[2] = operands[3];"}, {"sha": "d3990ca5eed8ee565b86fac9af5e688d0e923373", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037f20f16831bf88dfc5c459cd4299f925ee0df9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037f20f16831bf88dfc5c459cd4299f925ee0df9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=037f20f16831bf88dfc5c459cd4299f925ee0df9", "patch": "@@ -5117,7 +5117,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=Y\")\n \t(float:DF (match_operand:DI 1 \"nonimmediate_operand\" \"mr\")))]\n   \"TARGET_SSE2\"\n-  \"cvtsi2sd\\\\t{%1, %0|%0, %1}\"\n+  \"cvtsi2sd{q}\\\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"mode\" \"DF\")\n    (set_attr \"fp_int_src\" \"true\")])"}, {"sha": "e31338a37d47207b1a39917da52c31974a3c0498", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037f20f16831bf88dfc5c459cd4299f925ee0df9/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037f20f16831bf88dfc5c459cd4299f925ee0df9/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=037f20f16831bf88dfc5c459cd4299f925ee0df9", "patch": "@@ -906,6 +906,23 @@ emit_pop_insn (insn, regstack, reg, where)\n   rtx pop_insn, pop_rtx;\n   int hard_regno;\n \n+  /* For complex types take care to pop both halves.  These may survive in\n+     CLOBBER and USE expressions.  */\n+  if (COMPLEX_MODE_P (GET_MODE (reg)))\n+    {\n+      rtx reg1 = FP_MODE_REG (REGNO (reg), DFmode);\n+      rtx reg2 = FP_MODE_REG (REGNO (reg) + 1, DFmode);\n+\n+      pop_insn = NULL_RTX;\n+      if (get_hard_regnum (regstack, reg1) >= 0)\n+         pop_insn = emit_pop_insn (insn, regstack, reg1, where);\n+      if (get_hard_regnum (regstack, reg2) >= 0)\n+         pop_insn = emit_pop_insn (insn, regstack, reg2, where);\n+      if (!pop_insn)\n+\tabort ();\n+      return pop_insn;\n+    }\n+\n   hard_regno = get_hard_regnum (regstack, reg);\n \n   if (hard_regno < FIRST_STACK_REG)\n@@ -1129,9 +1146,12 @@ move_for_stack_reg (insn, regstack, pat)\n \t     stack is not full, and then write the value to memory via\n \t     a pop.  */\n \t  rtx push_rtx, push_insn;\n-\t  rtx top_stack_reg = FP_MODE_REG (FIRST_STACK_REG, XFmode);\n+\t  rtx top_stack_reg = FP_MODE_REG (FIRST_STACK_REG, GET_MODE (src));\n \n-\t  push_rtx = gen_movxf (top_stack_reg, top_stack_reg);\n+\t  if (GET_MODE (src) == TFmode)\n+\t    push_rtx = gen_movtf (top_stack_reg, top_stack_reg);\n+\t  else\n+\t    push_rtx = gen_movxf (top_stack_reg, top_stack_reg);\n \t  push_insn = emit_insn_before (push_rtx, insn);\n \t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, top_stack_reg,\n \t\t\t\t\t\tREG_NOTES (insn));\n@@ -1447,6 +1467,15 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t\t    PATTERN (insn) = pat;\n \t\t    move_for_stack_reg (insn, regstack, pat);\n \t\t  }\n+\t\tif (! note && COMPLEX_MODE_P (GET_MODE (*dest))\n+\t\t    && get_hard_regnum (regstack, FP_MODE_REG (REGNO (*dest), DFmode)) == -1)\n+\t\t  {\n+\t\t    pat = gen_rtx_SET (VOIDmode,\n+\t\t\t\t       FP_MODE_REG (REGNO (*dest) + 1, SFmode),\n+\t\t\t\t       nan);\n+\t\t    PATTERN (insn) = pat;\n+\t\t    move_for_stack_reg (insn, regstack, pat);\n+\t\t  }\n \t      }\n \t  }\n \tbreak;"}]}