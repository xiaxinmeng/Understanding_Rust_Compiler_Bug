{"sha": "483e400870601f650c80f867ec781cd5f83507d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzZTQwMDg3MDYwMWY2NTBjODBmODY3ZWM3ODFjZDVmODM1MDdkNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-02T08:47:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-02T09:39:27Z"}, "message": "Refine fix for PR78185, improve LIM for code after inner loops\n\nThis refines the fix for PR78185 after understanding that the code\nregarding to the comment 'In a loop that is always entered we may\nproceed anyway.  But record that we entered it and stop once we leave\nit.' was supposed to protect us from leaving possibly infinite inner\nloops.  The simpler fix of moving the misplaced stopping code\ncan then be refined to continue processing when the exited inner\nloop is finite, improving invariant motion for cases like in the\nadded testcase.\n\n2021-09-02  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-loop-im.c (fill_always_executed_in_1): Refine\n\tfix for PR78185 and continue processing when leaving\n\tfinite inner loops.\n\n\t* gcc.dg/tree-ssa/ssa-lim-16.c: New testcase.", "tree": {"sha": "e61ffe6f5d993c5d330dbbb5df667f96caa2e36a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e61ffe6f5d993c5d330dbbb5df667f96caa2e36a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/483e400870601f650c80f867ec781cd5f83507d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483e400870601f650c80f867ec781cd5f83507d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/483e400870601f650c80f867ec781cd5f83507d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483e400870601f650c80f867ec781cd5f83507d6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2af6dd77ea742d4ee911f466878624972929508a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2af6dd77ea742d4ee911f466878624972929508a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2af6dd77ea742d4ee911f466878624972929508a"}], "stats": {"total": 52, "additions": 38, "deletions": 14}, "files": [{"sha": "741582b745f221bcb85de022fd491269d0ca73ce", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483e400870601f650c80f867ec781cd5f83507d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483e400870601f650c80f867ec781cd5f83507d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-16.c?ref=483e400870601f650c80f867ec781cd5f83507d6", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details\" } */\n+\n+volatile int flag, bar;\n+double foo (double *valp)\n+{\n+  double sum = 0;\n+  for (int i = 0; i < 256; ++i)\n+    {\n+      for (int j = 0; j < 256; ++j)\n+        bar = flag;\n+      if (flag)\n+        sum += 1.;\n+      sum += *valp; // we should move the load of *valp out of the loop\n+    }\n+  return sum;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Moving statement\" 1 \"lim2\" } } */"}, {"sha": "01f3fc2f7f03127aebfeec1cb3bc299090781c77", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483e400870601f650c80f867ec781cd5f83507d6/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483e400870601f650c80f867ec781cd5f83507d6/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=483e400870601f650c80f867ec781cd5f83507d6", "patch": "@@ -3044,23 +3044,27 @@ fill_always_executed_in_1 (class loop *loop, sbitmap contains_call)\n \t  edge_iterator ei;\n \t  bb = bbs[i];\n \n+\t  if (!flow_bb_inside_loop_p (inn_loop, bb))\n+\t    {\n+\t      /* When we are leaving a possibly infinite inner loop\n+\t\t we have to stop processing.  */\n+\t      if (!finite_loop_p (inn_loop))\n+\t\tbreak;\n+\t      /* If the loop was finite we can continue with processing\n+\t\t the loop we exited to.  */\n+\t      inn_loop = bb->loop_father;\n+\t    }\n+\n \t  if (dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n \t    last = bb;\n \n \t  if (bitmap_bit_p (contains_call, bb->index))\n \t    break;\n \n+\t  /* If LOOP exits from this BB stop processing.  */\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    {\n-\t      /* If there is an exit from this BB.  */\n-\t      if (!flow_bb_inside_loop_p (loop, e->dest))\n-\t\tbreak;\n-\t      /* Or we enter a possibly non-finite loop.  */\n-\t      if (flow_loop_nested_p (bb->loop_father,\n-\t\t\t\t      e->dest->loop_father)\n-\t\t  && ! finite_loop_p (e->dest->loop_father))\n-\t\tbreak;\n-\t    }\n+\t    if (!flow_bb_inside_loop_p (loop, e->dest))\n+\t      break;\n \t  if (e)\n \t    break;\n \n@@ -3069,22 +3073,23 @@ fill_always_executed_in_1 (class loop *loop, sbitmap contains_call)\n \t  if (bb->flags & BB_IRREDUCIBLE_LOOP)\n \t    break;\n \n-\t  if (!flow_bb_inside_loop_p (inn_loop, bb))\n-\t    break;\n-\n \t  if (bb->loop_father->header == bb)\n \t    {\n \t      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n \t\tbreak;\n \n \t      /* In a loop that is always entered we may proceed anyway.\n-\t\t But record that we entered it and stop once we leave it.  */\n+\t\t But record that we entered it and stop once we leave it\n+\t\t since it might not be finite.  */\n \t      inn_loop = bb->loop_father;\n \t    }\n \t}\n \n       while (1)\n \t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf (MSG_NOTE, \"BB %d is always executed in loop %d\\n\",\n+\t\t\t last->index, loop->num);\n \t  SET_ALWAYS_EXECUTED_IN (last, loop);\n \t  if (last == loop->header)\n \t    break;"}]}