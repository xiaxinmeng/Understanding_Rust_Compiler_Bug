{"sha": "9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFhM2Y1YzU4YzIyOGVlNzRiOGEyZDliMzk3N2ZlZTFjOTdjYzZiZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-13T09:19:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-13T09:19:09Z"}, "message": "cgraph.c (cgraph_for_node_thunks_and_aliases, [...]): Fix thinko in recursive walking.\n\n\t* cgraph.c (cgraph_for_node_thunks_and_aliases,\n\tcgraph_for_node_and_aliases): Fix thinko in recursive walking.\n\t(nonremovable_p): New function.\n\t(cgraph_can_remove_if_no_direct_calls_p): New function.\n\t(used_from_object_file_p): New functoin.\n\t(cgraph_will_be_removed_from_program_if_no_direct_calls): Look for references\n\tfrom aliases.\n\t* cgraph.h (cgraph_can_remove_if_no_direct_calls_p): Bring offline.\n\t* ipa-inline.c (check_caller_edge): New function.\n\t(want_inline_function_called_once_p): Use it; accept aliases called once, too.\n\t* ipa-inline-analysis.c (do_estimate_growth): Remove FIXME.\n\nFrom-SVN: r174985", "tree": {"sha": "7e356df77924fcdd550af73036e37d71e9ab5ddb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e356df77924fcdd550af73036e37d71e9ab5ddb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/comments", "author": null, "committer": null, "parents": [{"sha": "30cecf17a92a1e52374fa04e25c8b921372f676c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30cecf17a92a1e52374fa04e25c8b921372f676c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30cecf17a92a1e52374fa04e25c8b921372f676c"}], "stats": {"total": 100, "additions": 74, "deletions": 26}, "files": [{"sha": "5404f099f210b49e56037d3601a0492d739324f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "patch": "@@ -1,3 +1,17 @@\n+2011-06-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_for_node_thunks_and_aliases,\n+\tcgraph_for_node_and_aliases): Fix thinko in recursive walking.\n+\t(nonremovable_p): New function.\n+\t(cgraph_can_remove_if_no_direct_calls_p): New function.\n+\t(used_from_object_file_p): New functoin.\n+\t(cgraph_will_be_removed_from_program_if_no_direct_calls): Look for references\n+\tfrom aliases.\n+\t* cgraph.h (cgraph_can_remove_if_no_direct_calls_p): Bring offline.\n+\t* ipa-inline.c (check_caller_edge): New function.\n+\t(want_inline_function_called_once_p): Use it; accept aliases called once, too.\n+\t* ipa-inline-analysis.c (do_estimate_growth): Remove FIXME.\n+\n 2011-06-13  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \n \tPR target/48454"}, {"sha": "dfa5439ad9638d011c04aebe9c832b58ddc2b92f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "patch": "@@ -2567,14 +2567,18 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n     if (e->caller->thunk.thunk_p\n \t&& (include_overwritable\n \t    || cgraph_function_body_availability (e->caller)))\n-      cgraph_for_node_thunks_and_aliases (e->caller, callback, data, include_overwritable);\n+      if (cgraph_for_node_thunks_and_aliases (e->caller, callback, data,\n+\t\t\t\t\t      include_overwritable))\n+\treturn true;\n   for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n \tif (include_overwritable\n \t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n-          cgraph_for_node_thunks_and_aliases (alias, callback, data, include_overwritable);\n+\t  if (cgraph_for_node_thunks_and_aliases (alias, callback, data,\n+\t\t\t\t\t\t  include_overwritable))\n+\t    return true;\n       }\n   return false;\n }\n@@ -2600,7 +2604,9 @@ cgraph_for_node_and_aliases (struct cgraph_node *node,\n \tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n \tif (include_overwritable\n \t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n-          cgraph_for_node_and_aliases (alias, callback, data, include_overwritable);\n+          if (cgraph_for_node_and_aliases (alias, callback, data,\n+\t\t\t\t\t   include_overwritable))\n+\t    return true;\n       }\n   return false;\n }\n@@ -2900,6 +2906,36 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n   return true;\n }\n \n+/* Worker for cgraph_can_remove_if_no_direct_calls_p.  */\n+\n+static bool\n+nonremovable_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  return !cgraph_can_remove_if_no_direct_calls_and_refs_p (node);\n+}\n+\n+/* Return true when function NODE and its aliases can be removed from callgraph\n+   if all direct calls are eliminated.  */\n+\n+bool\n+cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n+{\n+  /* Extern inlines can always go, we will use the external definition.  */\n+  if (DECL_EXTERNAL (node->decl))\n+    return true;\n+  if (node->address_taken)\n+    return false;\n+  return !cgraph_for_node_and_aliases (node, nonremovable_p, NULL, true);\n+}\n+\n+/* Worker for cgraph_can_remove_if_no_direct_calls_p.  */\n+\n+static bool\n+used_from_object_file_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  return cgraph_used_from_object_file_p (node);\n+}\n+\n /* Return true when function NODE can be expected to be removed\n    from program when direct calls in this compilation unit are removed.\n \n@@ -2918,7 +2954,7 @@ bool\n cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n-  if (cgraph_used_from_object_file_p (node))\n+  if (cgraph_for_node_and_aliases (node, used_from_object_file_p, NULL, true))\n     return false;\n   if (!in_lto_p && !flag_whole_program)\n     return cgraph_only_called_directly_p (node);"}, {"sha": "feb742d387e16bd07cb08e663e1b0f271604b405", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "patch": "@@ -535,6 +535,7 @@ bool cgraph_will_be_removed_from_program_if_no_direct_calls\n   (struct cgraph_node *node);\n bool cgraph_can_remove_if_no_direct_calls_and_refs_p\n   (struct cgraph_node *node);\n+bool cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node);\n bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution);\n bool cgraph_used_from_object_file_p (struct cgraph_node *);\n bool varpool_used_from_object_file_p (struct varpool_node *);\n@@ -922,20 +923,6 @@ cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n \t  && !node->local.externally_visible);\n }\n \n-/* Return true when function NODE can be removed from callgraph\n-   if all direct calls are eliminated.  */\n-\n-static inline bool\n-cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n-{\n-  /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (node->decl))\n-    return true;\n-  return (!node->address_taken\n-\t  && cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n-\t  && !ipa_ref_has_aliases_p (&node->ref_list));\n-}\n-\n /* Return true when function NODE can be removed from callgraph\n    if all direct calls are eliminated.  */\n "}, {"sha": "43e0f8124d0cff0fe4f9112210b9b7ac930372cc", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "patch": "@@ -2229,8 +2229,7 @@ do_estimate_growth (struct cgraph_node *node)\n \t  && !cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n \td.growth -= info->size;\n       /* COMDAT functions are very often not shared across multiple units since they\n-\t come from various template instantiations.  Take this into account.\n-         FIXME: allow also COMDATs with COMDAT aliases.  */\n+\t come from various template instantiations.  Take this into account.  */\n       else  if (DECL_COMDAT (node->decl)\n \t\t&& cgraph_can_remove_if_no_direct_calls_p (node))\n \td.growth -= (info->size"}, {"sha": "a2e55b981b774497c58c5829cb3170fc44d2b39f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9aa3f5c58c228ee74b8a2d9b3977fee1c97cc6bd", "patch": "@@ -643,31 +643,43 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   return want_inline;\n }\n \n+/* Return true when NODE has caller other than EDGE. \n+   Worker for cgraph_for_node_and_aliases.  */\n+\n+static bool\n+check_caller_edge (struct cgraph_node *node, void *edge)\n+{\n+  return (node->callers\n+          && node->callers != edge);\n+}\n+\n \n /* Decide if NODE is called once inlining it would eliminate need\n    for the offline copy of function.  */\n \n static bool\n want_inline_function_called_once_p (struct cgraph_node *node)\n {\n-   if (node->alias)\n-     return false;\n+   struct cgraph_node *function = cgraph_function_or_thunk_node (node, NULL);\n    /* Already inlined?  */\n-   if (node->global.inlined_to)\n+   if (function->global.inlined_to)\n      return false;\n    /* Zero or more then one callers?  */\n    if (!node->callers\n        || node->callers->next_caller)\n      return false;\n+   /* Maybe other aliases has more direct calls.  */\n+   if (cgraph_for_node_and_aliases (node, check_caller_edge, node->callers, true))\n+     return false;\n    /* Recursive call makes no sense to inline.  */\n-   if (node->callers->caller == node)\n+   if (cgraph_edge_recursive_p (node->callers))\n      return false;\n    /* External functions are not really in the unit, so inlining\n       them when called once would just increase the program size.  */\n-   if (DECL_EXTERNAL (node->decl))\n+   if (DECL_EXTERNAL (function->decl))\n      return false;\n    /* Offline body must be optimized out.  */\n-   if (!cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n+   if (!cgraph_will_be_removed_from_program_if_no_direct_calls (function))\n      return false;\n    if (!can_inline_edge_p (node->callers, true))\n      return false;"}]}