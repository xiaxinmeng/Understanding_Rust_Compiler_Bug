{"sha": "4fb8ba9d357297206678a3e3eacf9292148eafb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiOGJhOWQzNTcyOTcyMDY2NzhhM2UzZWFjZjkyOTIxNDhlYWZiNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-07-06T08:14:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-07-06T08:14:41Z"}, "message": "[5/7] Move the fix for PR65518\n\nThis patch moves the fix for PR65518 to the code that checks whether\nload-and-permute operations are supported.   If the group size is\ngreater than the vectorisation factor, it would still be possible\nto fall back to elementwise loads (as for strided groups) rather\nthan fail vectorisation entirely.\n\nTested on aarch64-linux-gnu and x86_64-linux-gnu.\n\ngcc/\n\t* tree-vectorizer.h (vect_grouped_load_supported): Add a\n\tsingle_element_p parameter.\n\t* tree-vect-data-refs.c (vect_grouped_load_supported): Likewise.\n\tCheck the PR65518 case here rather than in vectorizable_load.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Update call accordignly.\n\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n\nFrom-SVN: r238037", "tree": {"sha": "bec6504ded7b6f968d307ecd48cfc8553e087464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bec6504ded7b6f968d307ecd48cfc8553e087464"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fb8ba9d357297206678a3e3eacf9292148eafb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb8ba9d357297206678a3e3eacf9292148eafb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb8ba9d357297206678a3e3eacf9292148eafb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb8ba9d357297206678a3e3eacf9292148eafb5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "134c85caeba541ff4fb4377fb12729073cbdfe41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134c85caeba541ff4fb4377fb12729073cbdfe41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/134c85caeba541ff4fb4377fb12729073cbdfe41"}], "stats": {"total": 59, "additions": 38, "deletions": 21}, "files": [{"sha": "91f76acb5e4dc17f8964cda0fe3464a8556eb93b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fb8ba9d357297206678a3e3eacf9292148eafb5", "patch": "@@ -1,3 +1,12 @@\n+2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vect_grouped_load_supported): Add a\n+\tsingle_element_p parameter.\n+\t* tree-vect-data-refs.c (vect_grouped_load_supported): Likewise.\n+\tCheck the PR65518 case here rather than in vectorizable_load.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Update call accordignly.\n+\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n+\n 2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (gather_scatter_info): New structure."}, {"sha": "f2f0dc50bbda44b72918b28e63a797e617f1c940", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=4fb8ba9d357297206678a3e3eacf9292148eafb5", "patch": "@@ -5144,14 +5144,31 @@ vect_setup_realignment (gimple *stmt, gimple_stmt_iterator *gsi,\n \n /* Function vect_grouped_load_supported.\n \n-   Returns TRUE if even and odd permutations are supported,\n-   and FALSE otherwise.  */\n+   COUNT is the size of the load group (the number of statements plus the\n+   number of gaps).  SINGLE_ELEMENT_P is true if there is actually\n+   only one statement, with a gap of COUNT - 1.\n+\n+   Returns true if a suitable permute exists.  */\n \n bool\n-vect_grouped_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n+vect_grouped_load_supported (tree vectype, bool single_element_p,\n+\t\t\t     unsigned HOST_WIDE_INT count)\n {\n   machine_mode mode = TYPE_MODE (vectype);\n \n+  /* If this is single-element interleaving with an element distance\n+     that leaves unused vector loads around punt - we at least create\n+     very sub-optimal code in that case (and blow up memory,\n+     see PR65518).  */\n+  if (single_element_p && count > TYPE_VECTOR_SUBPARTS (vectype))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"single-element interleaving not supported \"\n+\t\t\t \"for not adjacent vector loads\\n\");\n+      return false;\n+    }\n+\n   /* vect_permute_load_chain requires the group size to be equal to 3 or\n      be a power of two.  */\n   if (count != 3 && exact_log2 (count) == -1)"}, {"sha": "63c002e737c64df7fb8c1a5ee603b3c88042d61a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4fb8ba9d357297206678a3e3eacf9292148eafb5", "patch": "@@ -2152,10 +2152,12 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t{\n \t  vinfo = vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n \t  vinfo = vinfo_for_stmt (STMT_VINFO_GROUP_FIRST_ELEMENT (vinfo));\n+\t  bool single_element_p = !STMT_VINFO_GROUP_NEXT_ELEMENT (vinfo);\n \t  size = STMT_VINFO_GROUP_SIZE (vinfo);\n \t  vectype = STMT_VINFO_VECTYPE (vinfo);\n \t  if (! vect_load_lanes_supported (vectype, size)\n-\t      && ! vect_grouped_load_supported (vectype, size))\n+\t      && ! vect_grouped_load_supported (vectype, single_element_p,\n+\t\t\t\t\t\tsize))\n \t    return false;\n \t}\n     }"}, {"sha": "ab32481600b951134746b53d2678e5f898f45b84", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4fb8ba9d357297206678a3e3eacf9292148eafb5", "patch": "@@ -6315,31 +6315,20 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      bool single_element_p = (first_stmt == stmt\n+\t\t\t       && !GROUP_NEXT_ELEMENT (stmt_info));\n \n       if (!slp && !STMT_VINFO_STRIDED_P (stmt_info))\n \t{\n \t  if (vect_load_lanes_supported (vectype, group_size))\n \t    load_lanes_p = true;\n-\t  else if (!vect_grouped_load_supported (vectype, group_size))\n+\t  else if (!vect_grouped_load_supported (vectype, single_element_p,\n+\t\t\t\t\t\t group_size))\n \t    return false;\n \t}\n \n-      /* If this is single-element interleaving with an element distance\n-         that leaves unused vector loads around punt - we at least create\n-\t very sub-optimal code in that case (and blow up memory,\n-\t see PR65518).  */\n-      if (first_stmt == stmt\n-\t  && !GROUP_NEXT_ELEMENT (stmt_info))\n+      if (single_element_p)\n \t{\n-\t  if (GROUP_SIZE (stmt_info) > TYPE_VECTOR_SUBPARTS (vectype))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"single-element interleaving not supported \"\n-\t\t\t\t \"for not adjacent vector loads\\n\");\n-\t      return false;\n-\t    }\n-\n \t  /* Single-element interleaving requires peeling for gaps.  */\n \t  gcc_assert (GROUP_GAP (stmt_info));\n \t}"}, {"sha": "08066306dab8a9b19831630387c7e0fc10f72dda", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb8ba9d357297206678a3e3eacf9292148eafb5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4fb8ba9d357297206678a3e3eacf9292148eafb5", "patch": "@@ -1065,7 +1065,7 @@ extern tree bump_vector_ptr (tree, gimple *, gimple_stmt_iterator *, gimple *,\n extern tree vect_create_destination_var (tree, tree);\n extern bool vect_grouped_store_supported (tree, unsigned HOST_WIDE_INT);\n extern bool vect_store_lanes_supported (tree, unsigned HOST_WIDE_INT);\n-extern bool vect_grouped_load_supported (tree, unsigned HOST_WIDE_INT);\n+extern bool vect_grouped_load_supported (tree, bool, unsigned HOST_WIDE_INT);\n extern bool vect_load_lanes_supported (tree, unsigned HOST_WIDE_INT);\n extern void vect_permute_store_chain (vec<tree> ,unsigned int, gimple *,\n                                     gimple_stmt_iterator *, vec<tree> *);"}]}