{"sha": "b80a188beea98da44228d6030932af0769946f83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgwYTE4OGJlZWE5OGRhNDQyMjhkNjAzMDkzMmFmMDc2OTk0NmY4Mw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-06-12T18:28:37Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-06-12T18:28:37Z"}, "message": "spellcheck: support transpositions aka Damerau-Levenshtein (PR other/69968)\n\ngcc/fortran/ChangeLog:\n\tPR other/69968\n\t* misc.c (gfc_closest_fuzzy_match): Update for renaming of\n\tlevenshtein_distance to get_edit_distance.\n\ngcc/ChangeLog:\n\tPR other/69968\n\t* spellcheck-tree.c (levenshtein_distance): Rename to...\n\t(get_edit_distance): ...this, and update for underlying renaming.\n\t* spellcheck-tree.h (levenshtein_distance): Rename to...\n\t(get_edit_distance): ...this.\n\t* spellcheck.c (levenshtein_distance): Rename to...\n\t(get_edit_distance): ...this.  Convert from Levenshtein distance\n\tto Damerau-Levenshtein distance by supporting transpositions of\n\tadjacent characters.  Rename \"v1\" to \"v_next\" and \"v0\" to\n\t\"v_one_ago\".\n\t(selftest::levenshtein_distance_unit_test_oneway): Rename to...\n\t(selftest::test_edit_distance_unit_test_oneway): ...this, and\n\tupdate for underlying renaming.\n\t(selftest::levenshtein_distance_unit_test): Rename to...\n\t(selftest::test_get_edit_distance_unit): ...this, and update for\n\tunderlying renaming.\n\t(selftest::test_find_closest_string): Add example from PR 69968\n\twhere transposition helps\n\t(selftest::test_metric_conditions): Update for renaming.\n\t(selftest::test_metric_conditions): Likewise.\n\t(selftest::spellcheck_c_tests): Likewise.\n\t* spellcheck.h (levenshtein_distance): Rename both overloads to...\n\t(get_edit_distance): ...this.\n\t(best_match::consider): Update for renaming.\n\ngcc/testsuite/ChangeLog:\n\tPR other/69968\n\t* gcc.dg/spellcheck-transposition.c: New test.\n\nFrom-SVN: r261521", "tree": {"sha": "30899a1fa363ab017696f4a64c390302d401ce6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30899a1fa363ab017696f4a64c390302d401ce6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b80a188beea98da44228d6030932af0769946f83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80a188beea98da44228d6030932af0769946f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b80a188beea98da44228d6030932af0769946f83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80a188beea98da44228d6030932af0769946f83/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3329a782fc0e51b9a4ddfc6938a484ec4b03084", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3329a782fc0e51b9a4ddfc6938a484ec4b03084", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3329a782fc0e51b9a4ddfc6938a484ec4b03084"}], "stats": {"total": 233, "additions": 162, "deletions": 71}, "files": [{"sha": "1bba11ccd676b2fb21b350b84be0ddc4d1c7fb25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -1,3 +1,30 @@\n+2018-06-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/69968\n+\t* spellcheck-tree.c (levenshtein_distance): Rename to...\n+\t(get_edit_distance): ...this, and update for underlying renaming.\n+\t* spellcheck-tree.h (levenshtein_distance): Rename to...\n+\t(get_edit_distance): ...this.\n+\t* spellcheck.c (levenshtein_distance): Rename to...\n+\t(get_edit_distance): ...this.  Convert from Levenshtein distance\n+\tto Damerau-Levenshtein distance by supporting transpositions of\n+\tadjacent characters.  Rename \"v1\" to \"v_next\" and \"v0\" to\n+\t\"v_one_ago\".\n+\t(selftest::levenshtein_distance_unit_test_oneway): Rename to...\n+\t(selftest::test_edit_distance_unit_test_oneway): ...this, and\n+\tupdate for underlying renaming.\n+\t(selftest::levenshtein_distance_unit_test): Rename to...\n+\t(selftest::test_get_edit_distance_unit): ...this, and update for\n+\tunderlying renaming.\n+\t(selftest::test_find_closest_string): Add example from PR 69968\n+\twhere transposition helps\n+\t(selftest::test_metric_conditions): Update for renaming.\n+\t(selftest::test_metric_conditions): Likewise.\n+\t(selftest::spellcheck_c_tests): Likewise.\n+\t* spellcheck.h (levenshtein_distance): Rename both overloads to...\n+\t(get_edit_distance): ...this.\n+\t(best_match::consider): Update for renaming.\n+\n 2018-06-12  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/85259"}, {"sha": "9768959374d745bf1b054935f2dca6afa8d43b53", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -1,3 +1,9 @@\n+2018-06-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/69968\n+\t* misc.c (gfc_closest_fuzzy_match): Update for renaming of\n+\tlevenshtein_distance to get_edit_distance.\n+\n 2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/44491"}, {"sha": "fb18c5ceb6f7811112ec9e3ef7c6c56cabfffba0", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -286,7 +286,7 @@ get_c_kind(const char *c_kind_name, CInteropKind_t kinds_table[])\n \n \n /* For a given name TYPO, determine the best candidate from CANDIDATES\n-   perusing Levenshtein distance.  Frees CANDIDATES before returning.  */\n+   using get_edit_distance.  Frees CANDIDATES before returning.  */\n \n const char *\n gfc_closest_fuzzy_match (const char *typo, char **candidates)\n@@ -299,7 +299,7 @@ gfc_closest_fuzzy_match (const char *typo, char **candidates)\n \n   while (cand && *cand)\n     {\n-      edit_distance_t dist = levenshtein_distance (typo, tl, *cand,\n+      edit_distance_t dist = get_edit_distance (typo, tl, *cand,\n \t  strlen (*cand));\n       if (dist < best_distance)\n \t{"}, {"sha": "596293e8d47f75083dbc906e1e4f3875bd273186", "filename": "gcc/spellcheck-tree.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2Fspellcheck-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2Fspellcheck-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck-tree.c?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -27,18 +27,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest.h\"\n #include \"stringpool.h\"\n \n-/* Calculate Levenshtein distance between two identifiers.  */\n+/* Calculate edit distance between two identifiers.  */\n \n edit_distance_t\n-levenshtein_distance (tree ident_s, tree ident_t)\n+get_edit_distance (tree ident_s, tree ident_t)\n {\n   gcc_assert (TREE_CODE (ident_s) == IDENTIFIER_NODE);\n   gcc_assert (TREE_CODE (ident_t) == IDENTIFIER_NODE);\n \n-  return levenshtein_distance (IDENTIFIER_POINTER (ident_s),\n-\t\t\t       IDENTIFIER_LENGTH (ident_s),\n-\t\t\t       IDENTIFIER_POINTER (ident_t),\n-\t\t\t       IDENTIFIER_LENGTH (ident_t));\n+  return get_edit_distance (IDENTIFIER_POINTER (ident_s),\n+\t\t\t    IDENTIFIER_LENGTH (ident_s),\n+\t\t\t    IDENTIFIER_POINTER (ident_t),\n+\t\t\t    IDENTIFIER_LENGTH (ident_t));\n }\n \n /* Given TARGET, an identifier, and CANDIDATES, a vec of identifiers,"}, {"sha": "4324bd2f9390e602ec09545c9f6be6bdf73d90c8", "filename": "gcc/spellcheck-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2Fspellcheck-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2Fspellcheck-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck-tree.h?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n /* spellcheck-tree.c  */\n \n extern edit_distance_t\n-levenshtein_distance (tree ident_s, tree ident_t);\n+get_edit_distance (tree ident_s, tree ident_t);\n \n extern tree\n find_closest_identifier (tree target, const auto_vec<tree> *candidates);"}, {"sha": "e2a8b92fdeceed84ae2cc9360f64cf0904013e44", "filename": "gcc/spellcheck.c", "status": "modified", "additions": 88, "deletions": 55, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2Fspellcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2Fspellcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.c?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -25,15 +25,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"spellcheck.h\"\n #include \"selftest.h\"\n \n-/* The Levenshtein distance is an \"edit-distance\": the minimal\n-   number of one-character insertions, removals or substitutions\n-   that are needed to change one string into another.\n+/* Get the edit distance between the two strings: the minimal\n+   number of edits that are needed to change one string into another,\n+   where edits can be one-character insertions, removals, or substitutions,\n+   or transpositions of two adjacent characters (counting as one \"edit\").\n \n-   This implementation uses the Wagner-Fischer algorithm.  */\n+   This implementation uses the Wagner-Fischer algorithm for the\n+   Damerau-Levenshtein distance; specifically, the \"optimal string alignment\n+   distance\" or \"restricted edit distance\" variant.  */\n \n edit_distance_t\n-levenshtein_distance (const char *s, int len_s,\n-\t\t      const char *t, int len_t)\n+get_edit_distance (const char *s, int len_s,\n+\t\t   const char *t, int len_t)\n {\n   const bool debug = false;\n \n@@ -49,76 +52,86 @@ levenshtein_distance (const char *s, int len_s,\n     return len_s;\n \n   /* We effectively build a matrix where each (i, j) contains the\n-     Levenshtein distance between the prefix strings s[0:j]\n-     and t[0:i].\n+     distance between the prefix strings s[0:j] and t[0:i].\n      Rather than actually build an (len_t + 1) * (len_s + 1) matrix,\n-     we simply keep track of the last row, v0 and a new row, v1,\n-     which avoids an (len_t + 1) * (len_s + 1) allocation and memory accesses\n-     in favor of two (len_s + 1) allocations.  These could potentially be\n+     we simply keep track of the last two rows, v_one_ago and v_two_ago,\n+     and a new row, v_next, which avoids an (len_t + 1) * (len_s + 1)\n+     allocation and memory accesses in favor of three (len_s + 1)\n+     allocations.  These could potentially be\n      statically-allocated if we impose a maximum length on the\n      strings of interest.  */\n-  edit_distance_t *v0 = new edit_distance_t[len_s + 1];\n-  edit_distance_t *v1 = new edit_distance_t[len_s + 1];\n+  edit_distance_t *v_two_ago = new edit_distance_t[len_s + 1];\n+  edit_distance_t *v_one_ago = new edit_distance_t[len_s + 1];\n+  edit_distance_t *v_next = new edit_distance_t[len_s + 1];\n \n   /* The first row is for the case of an empty target string, which\n      we can reach by deleting every character in the source string.  */\n   for (int i = 0; i < len_s + 1; i++)\n-    v0[i] = i;\n+    v_one_ago[i] = i;\n \n   /* Build successive rows.  */\n   for (int i = 0; i < len_t; i++)\n     {\n       if (debug)\n \t{\n-\t  printf (\"i:%i v0 = \", i);\n+\t  printf (\"i:%i v_one_ago = \", i);\n \t  for (int j = 0; j < len_s + 1; j++)\n-\t    printf (\"%i \", v0[j]);\n+\t    printf (\"%i \", v_one_ago[j]);\n \t  printf (\"\\n\");\n \t}\n \n       /* The initial column is for the case of an empty source string; we\n \t can reach prefixes of the target string of length i\n \t by inserting i characters.  */\n-      v1[0] = i + 1;\n+      v_next[0] = i + 1;\n \n       /* Build the rest of the row by considering neighbors to\n \t the north, west and northwest.  */\n       for (int j = 0; j < len_s; j++)\n \t{\n \t  edit_distance_t cost = (s[j] == t[i] ? 0 : 1);\n-\t  edit_distance_t deletion     = v1[j] + 1;\n-\t  edit_distance_t insertion    = v0[j + 1] + 1;\n-\t  edit_distance_t substitution = v0[j] + cost;\n+\t  edit_distance_t deletion     = v_next[j] + 1;\n+\t  edit_distance_t insertion    = v_one_ago[j + 1] + 1;\n+\t  edit_distance_t substitution = v_one_ago[j] + cost;\n \t  edit_distance_t cheapest = MIN (deletion, insertion);\n \t  cheapest = MIN (cheapest, substitution);\n-\t  v1[j + 1] = cheapest;\n+\t  if (i > 0 && j > 0 && s[j] == t[i - 1] && s[j - 1] == t[i])\n+\t    {\n+\t      edit_distance_t transposition = v_two_ago[j - 1] + 1;\n+\t      cheapest = MIN (cheapest, transposition);\n+\t    }\n+\t  v_next[j + 1] = cheapest;\n \t}\n \n       /* Prepare to move on to next row.  */\n       for (int j = 0; j < len_s + 1; j++)\n-\tv0[j] = v1[j];\n+\t{\n+\t  v_two_ago[j] = v_one_ago[j];\n+\t  v_one_ago[j] = v_next[j];\n+\t}\n     }\n \n   if (debug)\n     {\n-      printf (\"final v1 = \");\n+      printf (\"final v_next = \");\n       for (int j = 0; j < len_s + 1; j++)\n-\tprintf (\"%i \", v1[j]);\n+\tprintf (\"%i \", v_next[j]);\n       printf (\"\\n\");\n     }\n \n-  edit_distance_t result = v1[len_s];\n-  delete[] v0;\n-  delete[] v1;\n+  edit_distance_t result = v_next[len_s];\n+  delete[] v_two_ago;\n+  delete[] v_one_ago;\n+  delete[] v_next;\n   return result;\n }\n \n-/* Calculate Levenshtein distance between two nil-terminated strings.  */\n+/* Get the edit distance between two nil-terminated strings.  */\n \n edit_distance_t\n-levenshtein_distance (const char *s, const char *t)\n+get_edit_distance (const char *s, const char *t)\n {\n-  return levenshtein_distance (s, strlen (s), t, strlen (t));\n+  return get_edit_distance (s, strlen (s), t, strlen (t));\n }\n \n /* Given TARGET, a non-NULL string, and CANDIDATES, a non-NULL ptr to\n@@ -155,29 +168,28 @@ namespace selftest {\n \n /* Selftests.  */\n \n-/* Verify that the levenshtein_distance (A, B) equals the expected\n-   value.  */\n+/* Verify that get_edit_distance (A, B) equals the expected value.  */\n \n static void\n-levenshtein_distance_unit_test_oneway (const char *a, const char *b,\n-\t\t\t\t       edit_distance_t expected)\n+test_edit_distance_unit_test_oneway (const char *a, const char *b,\n+\t\t\t\t    edit_distance_t expected)\n {\n-  edit_distance_t actual = levenshtein_distance (a, b);\n+  edit_distance_t actual = get_edit_distance (a, b);\n   ASSERT_EQ (actual, expected);\n }\n \n /* Verify that both\n-     levenshtein_distance (A, B)\n+     get_edit_distance (A, B)\n    and\n-     levenshtein_distance (B, A)\n+     get_edit_distance (B, A)\n    equal the expected value, to ensure that the function is symmetric.  */\n \n static void\n-levenshtein_distance_unit_test (const char *a, const char *b,\n-\t\t\t\tedit_distance_t expected)\n+test_get_edit_distance_unit (const char *a, const char *b,\n+\t\t\t     edit_distance_t expected)\n {\n-  levenshtein_distance_unit_test_oneway (a, b, expected);\n-  levenshtein_distance_unit_test_oneway (b, a, expected);\n+  test_edit_distance_unit_test_oneway (a, b, expected);\n+  test_edit_distance_unit_test_oneway (b, a, expected);\n }\n \n /* Verify that find_closest_string is sane.  */\n@@ -215,6 +227,16 @@ test_find_closest_string ()\n      it as a suggestion will be nonsensical.  Verify that we don't offer such\n      suggestions.  */\n   ASSERT_EQ (NULL, find_closest_string (\"banana\", &candidates));\n+\n+  /* Example from PR 69968 where transposition helps.  */\n+  candidates.truncate (0);\n+  candidates.safe_push(\"coordx\");\n+  candidates.safe_push(\"coordy\");\n+  candidates.safe_push(\"coordz\");\n+  candidates.safe_push(\"coordx1\");\n+  candidates.safe_push(\"coordy1\");\n+  candidates.safe_push(\"coordz1\");\n+  ASSERT_STREQ (\"coordz1\", find_closest_string (\"coorzd1\", &candidates));\n }\n \n /* Test data for test_metric_conditions.  */\n@@ -227,7 +249,7 @@ static const char * const test_data[] = {\n   \"1234567890123456789012345678901234567890123456789012345678901234567890\"\n };\n \n-/* Verify that levenshtein_distance appears to be a sane distance function,\n+/* Verify that get_edit_distance appears to be a sane distance function,\n    i.e. the conditions for being a metric.  This is done directly for a\n    small set of examples, using test_data above.  This is O(N^3) in the size\n    of the array, due to the test for the triangle inequality, so we keep the\n@@ -243,7 +265,7 @@ test_metric_conditions ()\n       for (int j = 0; j < num_test_cases; j++)\n \t{\n \t  edit_distance_t dist_ij\n-\t    = levenshtein_distance (test_data[i], test_data[j]);\n+\t    = get_edit_distance (test_data[i], test_data[j]);\n \n \t  /* Identity of indiscernibles: d(i, j) > 0 iff i == j.  */\n \t  if (i == j)\n@@ -253,43 +275,54 @@ test_metric_conditions ()\n \n \t  /* Symmetry: d(i, j) == d(j, i).  */\n \t  edit_distance_t dist_ji\n-\t    = levenshtein_distance (test_data[j], test_data[i]);\n+\t    = get_edit_distance (test_data[j], test_data[i]);\n \t  ASSERT_EQ (dist_ij, dist_ji);\n \n \t  /* Triangle inequality.  */\n \t  for (int k = 0; k < num_test_cases; k++)\n \t    {\n \t      edit_distance_t dist_ik\n-\t\t= levenshtein_distance (test_data[i], test_data[k]);\n+\t\t= get_edit_distance (test_data[i], test_data[k]);\n \t      edit_distance_t dist_jk\n-\t\t= levenshtein_distance (test_data[j], test_data[k]);\n+\t\t= get_edit_distance (test_data[j], test_data[k]);\n \t      ASSERT_TRUE (dist_ik <= dist_ij + dist_jk);\n \t    }\n \t}\n     }\n }\n \n-/* Verify levenshtein_distance for a variety of pairs of pre-canned\n+/* Verify get_edit_distance for a variety of pairs of pre-canned\n    inputs, comparing against known-good values.  */\n \n void\n spellcheck_c_tests ()\n {\n-  levenshtein_distance_unit_test (\"\", \"nonempty\", strlen (\"nonempty\"));\n-  levenshtein_distance_unit_test (\"saturday\", \"sunday\", 3);\n-  levenshtein_distance_unit_test (\"foo\", \"m_foo\", 2);\n-  levenshtein_distance_unit_test (\"hello_world\", \"HelloWorld\", 3);\n-  levenshtein_distance_unit_test\n+  test_get_edit_distance_unit (\"\", \"nonempty\", strlen (\"nonempty\"));\n+  test_get_edit_distance_unit (\"saturday\", \"sunday\", 3);\n+  test_get_edit_distance_unit (\"foo\", \"m_foo\", 2);\n+  test_get_edit_distance_unit (\"hello_world\", \"HelloWorld\", 3);\n+  test_get_edit_distance_unit\n     (\"the quick brown fox jumps over the lazy dog\", \"dog\", 40);\n-  levenshtein_distance_unit_test\n+  test_get_edit_distance_unit\n     (\"the quick brown fox jumps over the lazy dog\",\n      \"the quick brown dog jumps over the lazy fox\",\n      4);\n-  levenshtein_distance_unit_test\n+  test_get_edit_distance_unit\n     (\"Lorem ipsum dolor sit amet, consectetur adipiscing elit,\",\n      \"All your base are belong to us\",\n      44);\n-  levenshtein_distance_unit_test (\"foo\", \"FOO\", 3);\n+  test_get_edit_distance_unit (\"foo\", \"FOO\", 3);\n+  test_get_edit_distance_unit (\"fee\", \"deed\", 2);\n+  test_get_edit_distance_unit (\"coorzd1\", \"coordx1\", 2);\n+\n+  /* Examples where transposition helps.  */\n+  test_get_edit_distance_unit (\"ab\", \"ba\", 1);\n+  test_get_edit_distance_unit (\"ba\", \"abc\", 2);\n+  test_get_edit_distance_unit (\"coorzd1\", \"coordz1\", 1);\n+  test_get_edit_distance_unit (\"abcdefghijklmnopqrstuvwxyz\",\n+\t\t\t       \"bacdefghijklmnopqrstuvwxzy\", 2);\n+  test_get_edit_distance_unit (\"saturday\", \"sundya\", 4);\n+  test_get_edit_distance_unit (\"signed\", \"singed\", 1);\n \n   test_find_closest_string ();\n   test_metric_conditions ();"}, {"sha": "41ac16f02524752bad8f2971284ab93160b58534", "filename": "gcc/spellcheck.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2Fspellcheck.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2Fspellcheck.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.h?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -25,11 +25,11 @@ const edit_distance_t MAX_EDIT_DISTANCE = UINT_MAX;\n \n /* spellcheck.c  */\n extern edit_distance_t\n-levenshtein_distance (const char *s, int len_s,\n-\t\t      const char *t, int len_t);\n+get_edit_distance (const char *s, int len_s,\n+\t\t   const char *t, int len_t);\n \n extern edit_distance_t\n-levenshtein_distance (const char *s, const char *t);\n+get_edit_distance (const char *s, const char *t);\n \n extern const char *\n find_closest_string (const char *target,\n@@ -73,7 +73,7 @@ struct edit_distance_traits<const char *>\n \n    This type accumulates the best possible match against GOAL_TYPE for\n    a sequence of elements of CANDIDATE_TYPE, whilst minimizing the\n-   number of calls to levenshtein_distance and to\n+   number of calls to get_edit_distance and to\n    edit_distance_traits<T>::get_length.  */\n \n template <typename GOAL_TYPE, typename CANDIDATE_TYPE>\n@@ -126,9 +126,9 @@ class best_match\n     /* Otherwise, compute the distance and see if the candidate\n        has beaten the previous best value.  */\n     edit_distance_t dist\n-      = levenshtein_distance (m_goal, m_goal_len,\n-\t\t\t      candidate_traits::get_string (candidate),\n-\t\t\t      candidate_len);\n+      = get_edit_distance (m_goal, m_goal_len,\n+\t\t\t   candidate_traits::get_string (candidate),\n+\t\t\t   candidate_len);\n     if (dist < m_best_distance)\n       {\n \tm_best_distance = dist;"}, {"sha": "6acc3589141a92d897ad6992967359c60cfd156e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -1,3 +1,8 @@\n+2018-06-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR other/69968\n+\t* gcc.dg/spellcheck-transposition.c: New test.\n+\n 2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/44491"}, {"sha": "b787c83a4e2dacc7fad839b347a7048d08a392ec", "filename": "gcc/testsuite/gcc.dg/spellcheck-transposition.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80a188beea98da44228d6030932af0769946f83/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-transposition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80a188beea98da44228d6030932af0769946f83/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-transposition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-transposition.c?ref=b80a188beea98da44228d6030932af0769946f83", "patch": "@@ -0,0 +1,20 @@\n+/* PR other/69968.  */\n+\n+struct {\n+  int coordx, coordy, coordz;\n+  int coordx1, coordy1, coordz1;\n+} c;\n+\n+/* Consider the misspelling \"coorzd1\".\n+\n+   With Levenshtein distance, the misspelling has an edit distance of 2\n+   to all 6 of the fields (e.g. via a deletion and a substitution for the\n+   first three, and via deletion and insertion for the second three).\n+   \n+   With Damerau-Levenshtein, the misspelling has an edit distance of 1\n+   via transposition to \"coordz1\", and 2 to the other fields.  */\n+\n+void foo (void)\n+{\n+  c.coorzd1 = c.coordy; /* { dg-error \"has no member named 'coorzd1'; did you mean 'coordz1'\" } */\n+}"}]}