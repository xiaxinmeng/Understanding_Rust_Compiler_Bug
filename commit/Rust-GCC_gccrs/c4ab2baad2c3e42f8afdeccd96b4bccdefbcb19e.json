{"sha": "c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRhYjJiYWFkMmMzZTQyZjhhZmRlY2NkOTZiNGJjY2RlZmJjYjE5ZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-08-20T08:28:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-08-20T08:28:17Z"}, "message": "tree-vrp.c (found_in_subgraph): Remove.\n\n2008-08-20  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (found_in_subgraph): Remove.\n\t(live): New global static.\n\t(live_on_edge): New function.\n\t(blocks_visited): Remove.\n\t(register_edge_assert_for_2): Use live_on_edge.\n\t(find_conditional_asserts): Remove code dealing with\n\tfound_in_subgraph.  Do not walk the CFG.\n\t(find_switch_asserts): Likewise.\n\t(find_assert_locations_1): Renamed from find_assert_locations.\n\tMove finding assert locations for conditional and switch\n\tstatements first.  Update live bitmap.  Do not walk the CFG.\n\t(find_assert_locations): New function.\n\t(insert_range_assertions): Remove entry of CFG walk.\n\tAdjust call to find_assert_locations.\n\t* tree-ssa-pre.c (do_regular_insertion): Ignore critical edges\n\tthat only can appear because of fake exit edges but assert we\n\tnever try to insert on those.\n\t(fini_pre): Do not remove fake exit edges here...\n\t(execute_pre): ...but here, before committing edge inserts.\n\n\t* gcc.dg/tree-ssa/pr20701.c: Scan vrp1 dump.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-1.c: Pass -fno-tree-vrp.\n\t* gcc.dg/tree-ssa/ssa-pre-20.c: New testcase.\n\nFrom-SVN: r139263", "tree": {"sha": "5cee07e65003f9de125569866be3eeaa6a05ea79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cee07e65003f9de125569866be3eeaa6a05ea79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c7c31a6a2d638d431c5fa5556896c75c4c80534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7c31a6a2d638d431c5fa5556896c75c4c80534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7c31a6a2d638d431c5fa5556896c75c4c80534"}], "stats": {"total": 366, "additions": 212, "deletions": 154}, "files": [{"sha": "6f207e576a375851c9b87ce678c5e5eac77d7888", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "patch": "@@ -1,3 +1,25 @@\n+2008-08-20  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (found_in_subgraph): Remove.\n+\t(live): New global static.\n+\t(live_on_edge): New function.\n+\t(blocks_visited): Remove.\n+\t(register_edge_assert_for_2): Use live_on_edge.\n+\t(find_conditional_asserts): Remove code dealing with\n+\tfound_in_subgraph.  Do not walk the CFG.\n+\t(find_switch_asserts): Likewise.\n+\t(find_assert_locations_1): Renamed from find_assert_locations.\n+\tMove finding assert locations for conditional and switch\n+\tstatements first.  Update live bitmap.  Do not walk the CFG.\n+\t(find_assert_locations): New function.\n+\t(insert_range_assertions): Remove entry of CFG walk.\n+\tAdjust call to find_assert_locations.\n+\t* tree-ssa-pre.c (do_regular_insertion): Ignore critical edges\n+\tthat only can appear because of fake exit edges but assert we\n+\tnever try to insert on those.\n+\t(fini_pre): Do not remove fake exit edges here...\n+\t(execute_pre): ...but here, before committing edge inserts.\n+\n 2008-08-19  Richard Guenther  <rguenther@suse.de>\n \n \t* passes.c (init_optimization_passes): Exchange store-ccp"}, {"sha": "791d51bc7ee92f26e749d4be54e97d51a43c4882", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "patch": "@@ -1,3 +1,9 @@\n+2008-08-20  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/pr20701.c: Scan vrp1 dump.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-1.c: Pass -fno-tree-vrp.\n+\t* gcc.dg/tree-ssa/ssa-pre-20.c: New testcase.\n+\n 2008-08-19  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* gcc.dg/torture/fp-int-convert-float.c: Reenable test on SPU."}, {"sha": "3ddf48e6f005e42abfdd9f3662b785408330e75f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20701.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c?ref=c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp2 -fno-early-inlining\" } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1 -fno-early-inlining\" } */\n \n typedef struct {\n   int code;\n@@ -36,6 +36,6 @@ can_combine_p (rtx insn, rtx elt)\n }\n \n /* Target with fno-delete-null-pointer-checks should not fold checks */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 0\" 1 \"vrp2\" { target { ! keeps_null_pointer_checks } } } } */\n-/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 0\" 0 \"vrp2\" { target {   keeps_null_pointer_checks } } } } */\n-/* { dg-final { cleanup-tree-dump \"vrp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 0\" 1 \"vrp1\" { target { ! keeps_null_pointer_checks } } } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 0\" 0 \"vrp1\" { target {   keeps_null_pointer_checks } } } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "7671e93ad10a0e06229ec34478829af088155e2a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-1.c?ref=c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-dom1-details\" } */\n+/* { dg-options \"-O2 -fno-tree-vrp -fdump-tree-dom1-details\" } */\n void t(void);\n void q(void);\n void q1(void);"}, {"sha": "6361b679c44b9684a2ead6bf47c487ad2574e552", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-20.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-20.c?ref=c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+\n+double pcheck;\n+\n+void foo(int n, int m, int b)\n+{\n+  int i, j;\n+\n+  goto bb18;\n+\n+start:\n+  i = 1;\n+  do {\n+    j = 1;\n+    do {\n+      double x = pcheck;\n+      x = x + 1;\n+      pcheck = x;\n+      j = j + 1;\n+    } while (j != m);\n+    i = i + 1;\n+  } while (i != n);\n+\n+bb18:\n+  pcheck = 0.0;\n+  goto start;\n+}\n+\n+/* We should have inserted two PHI nodes and the one in the i-loop\n+   should have 0.0 in the argument coming from the bb18 block.  */\n+\n+/* { dg-final { scan-tree-dump \"New PHIs: 2\" \"pre\" } } */\n+/* { dg-final { scan-tree-dump \"PHI <.*0\\\\\\.0\" \"pre\" } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "d2a55ae7ddc6858446efef71d37617b0e1b6bc05", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "patch": "@@ -3160,14 +3160,9 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t    {\n \t      unsigned int vprime;\n \n-\t      /* This can happen in the very weird case\n-\t\t that our fake infinite loop edges have caused a\n-\t\t critical edge to appear.  */\n-\t      if (EDGE_CRITICAL_P (pred))\n-\t\t{\n-\t\t  cant_insert = true;\n-\t\t  break;\n-\t\t}\n+\t      /* We should never run insertion for the exit block\n+\t         and so not come across fake pred edges.  */\n+\t      gcc_assert (!(pred->flags & EDGE_FAKE));\n \t      bprime = pred->src;\n \t      eprime = phi_translate (expr, ANTIC_IN (block), NULL,\n \t\t\t\t      bprime, block);\n@@ -3299,14 +3294,9 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n \t      unsigned int vprime;\n \t      pre_expr edoubleprime;\n \n-\t      /* This can happen in the very weird case\n-\t\t that our fake infinite loop edges have caused a\n-\t\t critical edge to appear.  */\n-\t      if (EDGE_CRITICAL_P (pred))\n-\t\t{\n-\t\t  cant_insert = true;\n-\t\t  break;\n-\t\t}\n+\t      /* We should never run insertion for the exit block\n+\t         and so not come across fake pred edges.  */\n+\t      gcc_assert (!(pred->flags & EDGE_FAKE));\n \t      bprime = pred->src;\n \t      eprime = phi_translate (expr, ANTIC_IN (block),\n \t\t\t\t      PA_IN (block),\n@@ -4117,7 +4107,6 @@ fini_pre (bool do_fre)\n   free_alloc_pool (pre_expr_pool);\n   htab_delete (phi_translate_table);\n   htab_delete (expression_to_id);\n-  remove_fake_exit_edges ();\n \n   FOR_ALL_BB (bb)\n     {\n@@ -4203,6 +4192,11 @@ execute_pre (bool do_fre ATTRIBUTE_UNUSED)\n   statistics_counter_event (cfun, \"New PHIs\", pre_stats.phis);\n   statistics_counter_event (cfun, \"Eliminated\", pre_stats.eliminations);\n   statistics_counter_event (cfun, \"Constified\", pre_stats.constified);\n+\n+  /* Make sure to remove fake edges before committing our inserts.\n+     This makes sure we don't end up with extra critical edges that\n+     we would need to split.  */\n+  remove_fake_exit_edges ();\n   gsi_commit_edge_inserts ();\n \n   clear_expression_ids ();"}, {"sha": "735191257a99061e6740408aec4155f9dee7d4b9", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 133, "deletions": 132, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c4ab2baad2c3e42f8afdeccd96b4bccdefbcb19e", "patch": "@@ -39,9 +39,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chrec.h\"\n \n \n-/* Set of SSA names found during the dominator traversal of a\n-   sub-graph in find_assert_locations.  */\n-static sbitmap found_in_subgraph;\n+/* Set of SSA names found live during the RPO traversal of the function\n+   for still active basic-blocks.  */\n+static sbitmap *live;\n+\n+/* Return true if the SSA name NAME is live on the edge E.  */\n+\n+static bool\n+live_on_edge (edge e, tree name)\n+{\n+  return (live[e->dest->index]\n+\t  && TEST_BIT (live[e->dest->index], SSA_NAME_VERSION (name)));\n+}\n \n /* Local functions.  */\n static int compare_values (tree val1, tree val2);\n@@ -91,10 +100,6 @@ static bitmap need_assert_for;\n    ASSERT_EXPRs for SSA name N_I should be inserted.  */\n static assert_locus_t *asserts_for;\n \n-/* Set of blocks visited in find_assert_locations.  Used to avoid\n-   visiting the same block more than once.  */\n-static sbitmap blocks_visited;\n-\n /* Value range array.  After propagation, VR_VALUE[I] holds the range\n    of values that SSA name N_I may take.  */\n static value_range_t **vr_value;\n@@ -3910,7 +3915,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \n   /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n      reachable from E.  */\n-  if (TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name))\n+  if (live_on_edge (e, name)\n       && !has_single_use (name))\n     {\n       register_new_assert_for (name, name, comp_code, val, NULL, e, bsi);\n@@ -3956,7 +3961,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t  && (cst2 == NULL_TREE\n \t      || TREE_CODE (cst2) == INTEGER_CST)\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (name3))\n-\t  && TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name3))\n+\t  && live_on_edge (e, name3)\n \t  && !has_single_use (name3))\n \t{\n \t  tree tmp;\n@@ -3985,7 +3990,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n       \t  && TREE_CODE (name2) == SSA_NAME\n \t  && TREE_CODE (cst2) == INTEGER_CST\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n-\t  && TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name2))\n+\t  && live_on_edge (e, name2)\n \t  && !has_single_use (name2))\n \t{\n \t  tree tmp;\n@@ -4185,8 +4190,6 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n }\n \n \n-static bool find_assert_locations (basic_block bb);\n-\n /* Determine whether the outgoing edges of BB should receive an\n    ASSERT_EXPR for each of the operands of BB's LAST statement.\n    The last statement of BB must be a COND_EXPR.\n@@ -4217,35 +4220,6 @@ find_conditional_asserts (basic_block bb, gimple last)\n       if (e->dest == bb)\n \tcontinue;\n \n-      /* Remove the COND_EXPR operands from the FOUND_IN_SUBGRAPH bitmap.\n-\t Otherwise, when we finish traversing each of the sub-graphs, we\n-\t won't know whether the variables were found in the sub-graphs or\n-\t if they had been found in a block upstream from BB. \n-\n-\t This is actually a bad idea is some cases, particularly jump\n-\t threading.  Consider a CFG like the following:\n-\n-                    0\n-                   /|\n-                  1 |\n-                   \\|\n-                    2\n-                   / \\\n-                  3   4\n-\n-\t Assume that one or more operands in the conditional at the\n-\t end of block 0 are used in a conditional in block 2, but not\n-\t anywhere in block 1.  In this case we will not insert any\n-\t assert statements in block 1, which may cause us to miss\n-\t opportunities to optimize, particularly for jump threading.  */\n-      FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n-\tRESET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n-\n-      /* Traverse the strictly dominated sub-graph rooted at E->DEST\n-\t to determine if any of the operands in the conditional\n-\t predicate are used.  */\n-      need_assert |= find_assert_locations (e->dest);\n-\n       /* Register the necessary assertions for each operand in the\n \t conditional predicate.  */\n       FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n@@ -4257,11 +4231,6 @@ find_conditional_asserts (basic_block bb, gimple last)\n \t}\n     }\n \n-  /* Finally, indicate that we have found the operands in the\n-     conditional.  */\n-  FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n-    SET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n-\n   return need_assert;\n }\n \n@@ -4358,18 +4327,6 @@ find_switch_asserts (basic_block bb, gimple last)\n       /* Find the edge to register the assert expr on.  */\n       e = find_edge (bb, label_to_block (CASE_LABEL (cl)));\n \n-      /* Remove the SWITCH_EXPR operand from the FOUND_IN_SUBGRAPH bitmap.\n-\t Otherwise, when we finish traversing each of the sub-graphs, we\n-\t won't know whether the variables were found in the sub-graphs or\n-\t if they had been found in a block upstream from BB.  */\n-      RESET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n-\n-      /* Traverse the strictly dominated sub-graph rooted at E->DEST\n-\t to determine if any of the operands in the conditional\n-\t predicate are used.  */\n-      if (e->dest != bb)\n-\tneed_assert |= find_assert_locations (e->dest);\n-\n       /* Register the necessary assertions for the operand in the\n \t SWITCH_EXPR.  */\n       need_assert |= register_edge_assert_for (op, e, bsi,\n@@ -4386,10 +4343,6 @@ find_switch_asserts (basic_block bb, gimple last)\n \t}\n     }\n \n-  /* Finally, indicate that we have found the operand in the\n-     SWITCH_EXPR.  */\n-  SET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n-\n   return need_assert;\n }\n \n@@ -4458,42 +4411,33 @@ find_switch_asserts (basic_block bb, gimple last)\n    inserted by process_assert_insertions.  */\n \n static bool\n-find_assert_locations (basic_block bb)\n+find_assert_locations_1 (basic_block bb, sbitmap live)\n {\n   gimple_stmt_iterator si;\n   gimple last;\n   gimple phi;\n   bool need_assert;\n-  basic_block son;\n-\n-  if (TEST_BIT (blocks_visited, bb->index))\n-    return false;\n-\n-  SET_BIT (blocks_visited, bb->index);\n \n   need_assert = false;\n+  last = last_stmt (bb);\n \n-  /* Traverse all PHI nodes in BB marking used operands.  */\n-  for (si = gsi_start_phis (bb); !gsi_end_p(si); gsi_next (&si))\n-    {\n-      use_operand_p arg_p;\n-      ssa_op_iter i;\n-      phi = gsi_stmt (si);\n+  /* If BB's last statement is a conditional statement involving integer\n+     operands, determine if we need to add ASSERT_EXPRs.  */\n+  if (last\n+      && gimple_code (last) == GIMPLE_COND\n+      && !fp_predicate (last)\n+      && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n+    need_assert |= find_conditional_asserts (bb, last);\n \n-      FOR_EACH_PHI_ARG (arg_p, phi, i, SSA_OP_USE)\n-\t{\n-\t  tree arg = USE_FROM_PTR (arg_p);\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    {\n-\t      gcc_assert (is_gimple_reg (PHI_RESULT (phi)));\n-\t      SET_BIT (found_in_subgraph, SSA_NAME_VERSION (arg));\n-\t    }\n-\t}\n-    }\n+  /* If BB's last statement is a switch statement involving integer\n+     operands, determine if we need to add ASSERT_EXPRs.  */\n+  if (last\n+      && gimple_code (last) == GIMPLE_SWITCH\n+      && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n+    need_assert |= find_switch_asserts (bb, last);\n \n   /* Traverse all the statements in BB marking used names and looking\n      for statements that may infer assertions for their used operands.  */\n-  last = NULL;\n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       gimple stmt;\n@@ -4508,12 +4452,8 @@ find_assert_locations (basic_block bb)\n \t  tree value;\n \t  enum tree_code comp_code;\n \n-\t  /* Mark OP in bitmap FOUND_IN_SUBGRAPH.  If STMT is inside\n-\t     the sub-graph of a conditional block, when we return from\n-\t     this recursive walk, our parent will use the\n-\t     FOUND_IN_SUBGRAPH bitset to determine if one of the\n-\t     operands it was looking for was present in the sub-graph.  */\n-\t  SET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n+\t  /* Mark OP in our live bitmap.  */\n+\t  SET_BIT (live, SSA_NAME_VERSION (op));\n \n \t  /* If OP is used in such a way that we can infer a value\n \t     range for it, and we don't find a previous assertion for\n@@ -4564,34 +4504,113 @@ find_assert_locations (basic_block bb)\n \t\t}\n \t    }\n \t}\n-\n-      /* Remember the last statement of the block.  */\n-      last = stmt;\n     }\n \n-  /* If BB's last statement is a conditional expression\n-     involving integer operands, recurse into each of the sub-graphs\n-     rooted at BB to determine if we need to add ASSERT_EXPRs.  */\n-  if (last\n-      && gimple_code (last) == GIMPLE_COND\n-      && !fp_predicate (last)\n-      && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n-    need_assert |= find_conditional_asserts (bb, last);\n-\n-  if (last\n-      && gimple_code (last) == GIMPLE_SWITCH\n-      && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n-    need_assert |= find_switch_asserts (bb, last);\n+  /* Traverse all PHI nodes in BB marking used operands.  */\n+  for (si = gsi_start_phis (bb); !gsi_end_p(si); gsi_next (&si))\n+    {\n+      use_operand_p arg_p;\n+      ssa_op_iter i;\n+      phi = gsi_stmt (si);\n \n-  /* Recurse into the dominator children of BB.  */\n-  for (son = first_dom_son (CDI_DOMINATORS, bb);\n-       son;\n-       son = next_dom_son (CDI_DOMINATORS, son))\n-    need_assert |= find_assert_locations (son);\n+      FOR_EACH_PHI_ARG (arg_p, phi, i, SSA_OP_USE)\n+\t{\n+\t  tree arg = USE_FROM_PTR (arg_p);\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    SET_BIT (live, SSA_NAME_VERSION (arg));\n+\t}\n+    }\n \n   return need_assert;\n }\n \n+/* Do an RPO walk over the function computing SSA name liveness\n+   on-the-fly and deciding on assert expressions to insert.\n+   Returns true if there are assert expressions to be inserted.  */\n+\n+static bool\n+find_assert_locations (void)\n+{\n+  int *rpo = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n+  int *bb_rpo = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n+  int *last_rpo = XCNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);\n+  int rpo_cnt, i;\n+  bool need_asserts;\n+\n+  live = XCNEWVEC (sbitmap, last_basic_block + NUM_FIXED_BLOCKS);\n+  rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n+  for (i = 0; i < rpo_cnt; ++i)\n+    bb_rpo[rpo[i]] = i;\n+\n+  need_asserts = false;\n+  for (i = rpo_cnt-1; i >= 0; --i)\n+    {\n+      basic_block bb = BASIC_BLOCK (rpo[i]);\n+      edge e;\n+      edge_iterator ei;\n+\n+      if (!live[rpo[i]])\n+\t{\n+\t  live[rpo[i]] = sbitmap_alloc (num_ssa_names);\n+\t  sbitmap_zero (live[rpo[i]]);\n+\t}\n+\n+      /* Process BB and update the live information with uses in\n+         this block.  */\n+      need_asserts |= find_assert_locations_1 (bb, live[rpo[i]]);\n+\n+      /* Merge liveness into the predecessor blocks and free it.  */\n+      if (!sbitmap_empty_p (live[rpo[i]]))\n+\t{\n+\t  int pred_rpo = i;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      int pred = e->src->index;\n+\t      if (e->flags & EDGE_DFS_BACK)\n+\t\tcontinue;\n+\n+\t      if (!live[pred])\n+\t\t{\n+\t\t  live[pred] = sbitmap_alloc (num_ssa_names);\n+\t\t  sbitmap_zero (live[pred]);\n+\t\t}\n+\t      sbitmap_a_or_b (live[pred], live[pred], live[rpo[i]]);\n+\n+\t      if (bb_rpo[pred] < pred_rpo)\n+\t\tpred_rpo = bb_rpo[pred];\n+\t    }\n+\n+\t  /* Record the RPO number of the last visited block that needs\n+\t     live information from this block.  */\n+\t  last_rpo[rpo[i]] = pred_rpo;\n+\t}\n+      else\n+\t{\n+\t  sbitmap_free (live[rpo[i]]);\n+\t  live[rpo[i]] = NULL;\n+\t}\n+\n+      /* We can free all successors live bitmaps if all their\n+         predecessors have been visited already.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (last_rpo[e->dest->index] == i\n+\t    && live[e->dest->index])\n+\t  {\n+\t    sbitmap_free (live[e->dest->index]);\n+\t    live[e->dest->index] = NULL;\n+\t  }\n+    }\n+\n+  XDELETEVEC (rpo);\n+  XDELETEVEC (bb_rpo);\n+  XDELETEVEC (last_rpo);\n+  for (i = 0; i < last_basic_block + NUM_FIXED_BLOCKS; ++i)\n+    if (live[i])\n+      sbitmap_free (live[i]);\n+  XDELETEVEC (live);\n+\n+  return need_asserts;\n+}\n \n /* Create an ASSERT_EXPR for NAME and insert it in the location\n    indicated by LOC.  Return true if we made any edge insertions.  */\n@@ -4718,27 +4737,12 @@ process_assert_insertions (void)\n static void\n insert_range_assertions (void)\n {\n-  edge e;\n-  edge_iterator ei;\n-  bool update_ssa_p;\n-  \n-  found_in_subgraph = sbitmap_alloc (num_ssa_names);\n-  sbitmap_zero (found_in_subgraph);\n-\n-  blocks_visited = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (blocks_visited);\n-\n   need_assert_for = BITMAP_ALLOC (NULL);\n   asserts_for = XCNEWVEC (assert_locus_t, num_ssa_names);\n \n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  update_ssa_p = false;\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    if (find_assert_locations (e->dest))\n-      update_ssa_p = true;\n-\n-  if (update_ssa_p)\n+  if (find_assert_locations ())\n     {\n       process_assert_insertions ();\n       update_ssa (TODO_update_ssa_no_phi);\n@@ -4750,7 +4754,6 @@ insert_range_assertions (void)\n       dump_function_to_file (current_function_decl, dump_file, dump_flags);\n     }\n \n-  sbitmap_free (found_in_subgraph);\n   free (asserts_for);\n   BITMAP_FREE (need_assert_for);\n }\n@@ -5019,8 +5022,6 @@ remove_range_assertions (void)\n \telse\n \t  gsi_next (&si);\n       }\n-\n-  sbitmap_free (blocks_visited);\n }\n \n "}]}