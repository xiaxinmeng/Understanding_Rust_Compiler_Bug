{"sha": "7508a7e958ea06eb311a4a106312634eaf6d40c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUwOGE3ZTk1OGVhMDZlYjMxMWE0YTEwNjMxMjYzNGVhZjZkNDBjMw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-18T15:14:54Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-30T21:44:31Z"}, "message": "d: Fix associative array literals that don't have alignment holes filled\n\nAssociative array literal keys with alignment holes are now filled using\nmemset() prior to usage, with LTR evaluation of side-effects enforced.\n\ngcc/d/ChangeLog:\n\n\tPR d/96152\n\t* d-codegen.cc (build_array_from_exprs): New function.\n\t* d-tree.h (build_array_from_exprs): Declare.\n\t* expr.cc (ExprVisitor::visit (AssocArrayLiteralExp *)): Use\n\tbuild_array_from_exprs to generate key and value arrays.\n\ngcc/testsuite/ChangeLog:\n\n\tPR d/96152\n\t* gdc.dg/pr96152.d: New test.", "tree": {"sha": "c3d3f96bb65452d64418a4f759a902275f7141f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3d3f96bb65452d64418a4f759a902275f7141f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7508a7e958ea06eb311a4a106312634eaf6d40c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7508a7e958ea06eb311a4a106312634eaf6d40c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7508a7e958ea06eb311a4a106312634eaf6d40c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7508a7e958ea06eb311a4a106312634eaf6d40c3/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "873b45d39c14fee6b68032b83ea6bfbc023e3379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/873b45d39c14fee6b68032b83ea6bfbc023e3379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/873b45d39c14fee6b68032b83ea6bfbc023e3379"}], "stats": {"total": 102, "additions": 78, "deletions": 24}, "files": [{"sha": "2dce09d7187dbf8d4b685d5903b8132c0bf95663", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7508a7e958ea06eb311a4a106312634eaf6d40c3/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7508a7e958ea06eb311a4a106312634eaf6d40c3/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=7508a7e958ea06eb311a4a106312634eaf6d40c3", "patch": "@@ -1722,6 +1722,42 @@ build_array_from_val (Type *type, tree val)\n   return build_constructor (build_ctype (type), elms);\n }\n \n+/* Build a static array of type TYPE from an array of EXPS.\n+   If CONST_P is true, then all elements in EXPS are constants.  */\n+\n+tree\n+build_array_from_exprs (Type *type, Expressions *exps, bool const_p)\n+{\n+  /* Build a CONSTRUCTOR from all expressions.  */\n+  vec <constructor_elt, va_gc> *elms = NULL;\n+  vec_safe_reserve (elms, exps->length);\n+\n+  Type *etype = type->nextOf ();\n+  tree satype = make_array_type (etype, exps->length);\n+\n+  for (size_t i = 0; i < exps->length; i++)\n+    {\n+      Expression *expr = (*exps)[i];\n+      tree t = build_expr (expr, const_p);\n+      CONSTRUCTOR_APPEND_ELT (elms, size_int (i),\n+\t\t\t      convert_expr (t, expr->type, etype));\n+    }\n+\n+  /* Create a new temporary to store the array.  */\n+  tree var = build_local_temp (satype);\n+\n+  /* Fill any alignment holes with zeroes.  */\n+  TypeStruct *ts = etype->baseElemOf ()->isTypeStruct ();\n+  tree init = NULL;\n+  if (ts && (!identity_compare_p (ts->sym) || ts->sym->isUnionDeclaration ()))\n+    init = build_memset_call (var);\n+\n+  /* Initialize the temporary.  */\n+  tree assign = modify_expr (var, build_constructor (satype, elms));\n+  return compound_expr (compound_expr (init, assign), var);\n+}\n+\n+\n /* Implicitly converts void* T to byte* as D allows { void[] a; &a[3]; }  */\n \n tree"}, {"sha": "df317d557eb8d50ec837e184fb33f7a58dd42c56", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7508a7e958ea06eb311a4a106312634eaf6d40c3/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7508a7e958ea06eb311a4a106312634eaf6d40c3/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=7508a7e958ea06eb311a4a106312634eaf6d40c3", "patch": "@@ -562,6 +562,7 @@ extern tree build_offset (tree, tree);\n extern tree build_memref (tree, tree, tree);\n extern tree build_array_set (tree, tree, tree);\n extern tree build_array_from_val (Type *, tree);\n+extern tree build_array_from_exprs (Type *, Expressions *, bool);\n extern tree void_okay_p (tree);\n extern tree build_array_bounds_call (const Loc &);\n extern tree build_bounds_condition (const Loc &, tree, tree, bool);"}, {"sha": "20ab49d7b8c1e5e03feb96b70dfe9cb33894697a", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7508a7e958ea06eb311a4a106312634eaf6d40c3/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7508a7e958ea06eb311a4a106312634eaf6d40c3/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=7508a7e958ea06eb311a4a106312634eaf6d40c3", "patch": "@@ -2799,30 +2799,14 @@ class ExprVisitor : public Visitor\n \n     /* Build an expression that assigns all expressions in KEYS\n        to a constructor.  */\n-    vec <constructor_elt, va_gc> *kelts = NULL;\n-    vec_safe_reserve (kelts, e->keys->length);\n-    for (size_t i = 0; i < e->keys->length; i++)\n-      {\n-\tExpression *key = (*e->keys)[i];\n-\ttree t = build_expr (key);\n-\tCONSTRUCTOR_APPEND_ELT (kelts, size_int (i),\n-\t\t\t\tconvert_expr (t, key->type, ta->index));\n-      }\n-    tree tkeys = make_array_type (ta->index, e->keys->length);\n-    tree akeys = build_constructor (tkeys, kelts);\n+    tree akeys = build_array_from_exprs (ta->index->sarrayOf (e->keys->length),\n+\t\t\t\t\t e->keys, this->constp_);\n+    tree init = stabilize_expr (&akeys);\n \n     /* Do the same with all expressions in VALUES.  */\n-    vec <constructor_elt, va_gc> *velts = NULL;\n-    vec_safe_reserve (velts, e->values->length);\n-    for (size_t i = 0; i < e->values->length; i++)\n-      {\n-\tExpression *value = (*e->values)[i];\n-\ttree t = build_expr (value);\n-\tCONSTRUCTOR_APPEND_ELT (velts, size_int (i),\n-\t\t\t\tconvert_expr (t, value->type, ta->next));\n-      }\n-    tree tvals = make_array_type (ta->next, e->values->length);\n-    tree avals = build_constructor (tvals, velts);\n+    tree avals = build_array_from_exprs (ta->next->sarrayOf (e->values->length),\n+\t\t\t\t\t e->values, this->constp_);\n+    init = compound_expr (init, stabilize_expr (&avals));\n \n     /* Generate: _d_assocarrayliteralTX (ti, keys, vals);  */\n     tree keys = d_array_value (build_ctype (ta->index->arrayOf ()),\n@@ -2840,8 +2824,9 @@ class ExprVisitor : public Visitor\n     vec <constructor_elt, va_gc> *ce = NULL;\n     CONSTRUCTOR_APPEND_ELT (ce, TYPE_FIELDS (aatype), mem);\n \n-    this->result_ = build_nop (build_ctype (e->type),\n-\t\t\t       build_constructor (aatype, ce));\n+    tree result = build_nop (build_ctype (e->type),\n+\t\t\t     build_constructor (aatype, ce));\n+    this->result_ = compound_expr (init, result);\n   }\n \n   /* Build a struct literal.  */"}, {"sha": "3551614654b8d3f7c46324b83fc350353ddba840", "filename": "gcc/testsuite/gdc.dg/pr96152.d", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7508a7e958ea06eb311a4a106312634eaf6d40c3/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96152.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7508a7e958ea06eb311a4a106312634eaf6d40c3/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96152.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96152.d?ref=7508a7e958ea06eb311a4a106312634eaf6d40c3", "patch": "@@ -0,0 +1,32 @@\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96152\n+// { dg-additional-options \"-fmain -funittest\" }\n+// { dg-do run { target hw } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+auto assocArray(Keys, Values)(Keys keys, Values values)\n+{\n+    void* aa;\n+    {\n+        if (values.length > keys.length)\n+            values = values[0 .. keys.length];\n+        else if (keys.length > values.length)\n+            keys = keys[0 .. values.length];\n+        aa = aaLiteral(keys, values);\n+    }\n+    alias Key = typeof(keys[0]);\n+    alias Value = typeof(values[0]);\n+    return (() @trusted => cast(Value[Key]) aa)();\n+}\n+\n+@safe unittest\n+{\n+    struct ThrowingElement\n+    {\n+        int i;\n+        static bool b;\n+        ~this(){\n+            if (b)\n+                throw new Exception(\"\");\n+        }\n+    }\n+    assert(assocArray([ThrowingElement()], [0]) == [ThrowingElement(): 0]);\n+}"}]}