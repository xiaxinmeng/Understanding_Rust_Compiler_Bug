{"sha": "b991151b284774c5fba4fc3148728c41a21c5004", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk5MTE1MWIyODQ3NzRjNWZiYTRmYzMxNDg3MjhjNDFhMjFjNTAwNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-06T15:32:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-06T15:32:46Z"}, "message": "name-lookup.h (lookup_field_1): Delete.\n\n\t* name-lookup.h (lookup_field_1): Delete.\n\t(get_class_binding_direct, get_class_binding): Add type_or_fns arg.\n\t* name-lookup.c\t(lookup_field_1): make static\n\t(method_vec_binary_search, method_vec_linear_search): New.  Broken\n\tout of ...\n\t(get_class_binding_direct): ... here.  Add TYPE_OR_FNS argument.\n\tDo complete search of this level.\n\t(get_class_binding): Adjust.\n\t* decl.c (reshape_init_class): Call get_class_binding.\n\t* search.c (lookup_field_r): Move field searching into\n\tget_class_binding_direct.\n\nFrom-SVN: r251808", "tree": {"sha": "9b92eab19e44e973d5308a183a902bfbcd54fae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b92eab19e44e973d5308a183a902bfbcd54fae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b991151b284774c5fba4fc3148728c41a21c5004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b991151b284774c5fba4fc3148728c41a21c5004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b991151b284774c5fba4fc3148728c41a21c5004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b991151b284774c5fba4fc3148728c41a21c5004/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec7f007c776c7112f8134a6a8cd94a3463cd37e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec7f007c776c7112f8134a6a8cd94a3463cd37e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec7f007c776c7112f8134a6a8cd94a3463cd37e3"}], "stats": {"total": 191, "additions": 106, "deletions": 85}, "files": [{"sha": "c1546308f7cc19b21a9622343b64af305c4745f0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b991151b284774c5fba4fc3148728c41a21c5004", "patch": "@@ -1,5 +1,17 @@\n 2017-09-06  Nathan Sidwell  <nathan@acm.org>\n \n+\t* name-lookup.h (lookup_field_1): Delete.\n+\t(get_class_binding_direct, get_class_binding): Add type_or_fns arg.\n+\t* name-lookup.c\t(lookup_field_1): make static\n+\t(method_vec_binary_search, method_vec_linear_search): New.  Broken\n+\tout of ...\n+\t(get_class_binding_direct): ... here.  Add TYPE_OR_FNS argument.\n+\tDo complete search of this level.\n+\t(get_class_binding): Adjust.\n+\t* decl.c (reshape_init_class): Call get_class_binding.\n+\t* search.c (lookup_field_r): Move field searching into\n+\tget_class_binding_direct.\n+\n \t* class.c (warn_hidden): Don't barf on non-functions.\n \t* decl2.c (check_classfn): Likewise.  Check template match earlier.\n "}, {"sha": "6f3a348f9fdf5f3a06909f3ce73d0498b995c4e3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b991151b284774c5fba4fc3148728c41a21c5004", "patch": "@@ -5746,7 +5746,7 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n \t    /* We already reshaped this.  */\n \t    gcc_assert (d->cur->index == field);\n \t  else if (TREE_CODE (d->cur->index) == IDENTIFIER_NODE)\n-\t    field = lookup_field_1 (type, d->cur->index, /*want_type=*/false);\n+\t    field = get_class_binding (type, d->cur->index, false);\n \t  else\n \t    {\n \t      if (complain & tf_error)"}, {"sha": "7549edd1dbac49c32953d1021cf0c79c6caf956d", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 90, "deletions": 64, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b991151b284774c5fba4fc3148728c41a21c5004", "patch": "@@ -1113,79 +1113,54 @@ extract_conversion_operator (tree fns, tree type)\n   return convs;\n }\n \n-/* TYPE is a class type. Return the member functions in the method\n-   vector with name NAME.  Does not lazily declare implicitly-declared\n-   member functions.  */\n+/* Binary search of (ordered) METHOD_VEC for NAME.  */\n \n-tree\n-get_class_binding_direct (tree type, tree name)\n+static tree\n+method_vec_binary_search (vec<tree, va_gc> *method_vec, tree name)\n {\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (type);\n-  if (!method_vec)\n-    return NULL_TREE;\n-\n-  /* Conversion operators can only be found by the marker conversion\n-     operator name.  */\n-  bool conv_op = IDENTIFIER_CONV_OP_P (name);\n-  tree lookup = conv_op ? conv_op_identifier : name;\n-  tree val = NULL_TREE;\n-  tree fns;\n-\n-  /* If the type is complete, use binary search.  */\n-  if (COMPLETE_TYPE_P (type))\n+  for (unsigned lo = 0, hi = method_vec->length (); lo < hi;)\n     {\n-      int lo = 0;\n-      int hi = method_vec->length ();\n-      while (lo < hi)\n-\t{\n-\t  int i = (lo + hi) / 2;\n+      unsigned mid = (lo + hi) / 2;\n+      tree binding = (*method_vec)[mid];\n+      tree binding_name = OVL_NAME (binding);\n \n-\t  fns = (*method_vec)[i];\n-\t  tree fn_name = OVL_NAME (fns);\n-\t  if (fn_name > lookup)\n-\t    hi = i;\n-\t  else if (fn_name < lookup)\n-\t    lo = i + 1;\n-\t  else\n-\t    {\n-\t      val = fns;\n-\t      break;\n-\t    }\n-\t}\n+      if (binding_name > name)\n+\thi = mid;\n+      else if (binding_name < name)\n+\tlo = mid + 1;\n+      else\n+\treturn binding;\n     }\n-  else\n-    for (int i = 0; vec_safe_iterate (method_vec, i, &fns); ++i)\n-      /* We can get a NULL binding during insertion of a new\n-\t method name, because the identifier_binding machinery\n-\t performs a lookup.  If we find such a NULL slot, that's\n-\t the thing we were looking for, so we might as well bail\n-\t out immediately.  */\n-      if (!fns)\n-\tbreak;\n-      else if (OVL_NAME (fns) == lookup)\n-\t{\n-\t  val = fns;\n-\t  break;\n-\t}\n \n-  /* Extract the conversion operators asked for, unless the general\n-     conversion operator was requested.   */\n-  if (val && conv_op)\n-    {\n-      gcc_checking_assert (OVL_FUNCTION (val) == conv_op_marker);\n-      val = OVL_CHAIN (val);\n-      if (tree type = TREE_TYPE (name))\n-\tval = extract_conversion_operator (val, type);\n-    }\n+  return NULL_TREE;\n+}\n \n-  return val;\n+/* Linear search of (unordered) METHOD_VEC for NAME.  */\n+\n+static tree\n+method_vec_linear_search (vec<tree, va_gc> *method_vec, tree name)\n+{\n+  for (int ix = method_vec->length (); ix--;)\n+    /* We can get a NULL binding during insertion of a new method\n+       name, because the identifier_binding machinery performs a\n+       lookup.  If we find such a NULL slot, that's the thing we were\n+       looking for, so we might as well bail out immediately.  */\n+    if (tree binding = (*method_vec)[ix])\n+      {\n+\tif (OVL_NAME (binding) == name)\n+\t  return binding;\n+      }\n+    else\n+      break;\n+\n+  return NULL_TREE;\n }\n \n /* Do a 1-level search for NAME as a member of TYPE.  The caller must\n    figure out whether it can access this field.  (Since it is only one\n    level, this is reasonable.)  */\n \n-tree\n+static tree\n lookup_field_1 (tree type, tree name, bool want_type)\n {\n   tree field;\n@@ -1281,11 +1256,62 @@ lookup_field_1 (tree type, tree name, bool want_type)\n   return NULL_TREE;\n }\n \n-/* TYPE is a class type. Return the overloads in\n-   the method vector with name NAME.  Lazily create ctors etc.  */\n+/* Look for NAME as an immediate member of KLASS (including\n+   anon-members or unscoped enum member).  TYPE_OR_FNS is zero for\n+   regular search.  >0 to get a type binding (if there is one) and <0\n+   if you want (just) the member function binding.\n+\n+   Use this if you do not want lazy member creation.  */\n+\n+tree\n+get_class_binding_direct (tree klass, tree name, int type_or_fns)\n+{\n+  gcc_checking_assert (RECORD_OR_UNION_TYPE_P (klass));\n+\n+  /* Conversion operators can only be found by the marker conversion\n+     operator name.  */\n+  bool conv_op = IDENTIFIER_CONV_OP_P (name);\n+  tree lookup = conv_op ? conv_op_identifier : name;\n+  tree val = NULL_TREE;\n+\n+  if (type_or_fns > 0)\n+    /* User wants type.  Don't look in method_vec.  */;\n+  else if (vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass))\n+    {\n+      if (COMPLETE_TYPE_P (klass))\n+\tval = method_vec_binary_search (method_vec, lookup);\n+      else\n+\tval = method_vec_linear_search (method_vec, lookup);\n+    }\n+\n+  if (type_or_fns < 0)\n+    /* User wants functions.  Don't look for a field. */;\n+  else if (!val || (TREE_CODE (val) == OVERLOAD && OVL_USING_P (val)))\n+    /* Dependent using declarations are a 'field', make sure we\n+       return that even if we saw an overload already.  */\n+    if (tree field_val = lookup_field_1 (klass, lookup, type_or_fns > 0))\n+      if (!val || TREE_CODE (field_val) == USING_DECL)\n+\tval = field_val;\n+\n+  /* Extract the conversion operators asked for, unless the general\n+     conversion operator was requested.   */\n+  if (val && conv_op)\n+    {\n+      gcc_checking_assert (OVL_FUNCTION (val) == conv_op_marker);\n+      val = OVL_CHAIN (val);\n+      if (tree type = TREE_TYPE (name))\n+\tval = extract_conversion_operator (val, type);\n+    }\n+\n+  return val;\n+}\n+\n+/* Look for NAME's binding in exactly KLASS.  See\n+   get_class_binding_direct for argument description.  Does lazy\n+   special function creation as necessary.  */\n \n tree\n-get_class_binding (tree type, tree name)\n+get_class_binding (tree type, tree name, int type_or_fns)\n {\n   type = complete_type (type);\n \n@@ -1314,7 +1340,7 @@ get_class_binding (tree type, tree name)\n \t}\n     }\n \n-  return get_class_binding_direct (type, name);\n+  return get_class_binding_direct (type, name, type_or_fns);\n }\n \n /* Find the slot containing overloads called 'NAME'.  If there is no"}, {"sha": "3bc06d7da9847c40115d46baf501acc2e4fa56ec", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=b991151b284774c5fba4fc3148728c41a21c5004", "patch": "@@ -319,9 +319,8 @@ extern void pop_decl_namespace (void);\n extern void do_namespace_alias (tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n-extern tree lookup_field_1\t\t\t(tree, tree, bool);\n-extern tree get_class_binding_direct (tree, tree);\n-extern tree get_class_binding (tree, tree);\n+extern tree get_class_binding_direct (tree, tree, int type_or_fns = -1);\n+extern tree get_class_binding (tree, tree, int type_or_fns = -1);\n extern tree *get_method_slot (tree klass, tree name);\n extern void resort_type_method_vec (void *, void *,\n \t\t\t\t    gt_pointer_operator, void *);"}, {"sha": "11e721fc056e0c2970618b59e06ea8ccdfac80bd", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b991151b284774c5fba4fc3148728c41a21c5004/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=b991151b284774c5fba4fc3148728c41a21c5004", "patch": "@@ -974,23 +974,7 @@ lookup_field_r (tree binfo, void *data)\n       && !BINFO_VIRTUAL_P (binfo))\n     return dfs_skip_bases;\n \n-  /* First, look for a function.  There can't be a function and a data\n-     member with the same name, and if there's a function and a type\n-     with the same name, the type is hidden by the function.  */\n-  if (!lfi->want_type)\n-    nval = get_class_binding (type, lfi->name);\n-\n-  if (!nval)\n-    /* Look for a data member or type.  */\n-    nval = lookup_field_1 (type, lfi->name, lfi->want_type);\n-  else if (TREE_CODE (nval) == OVERLOAD && OVL_USING_P (nval))\n-    {\n-      /* If we have both dependent and non-dependent using-declarations, return\n-\t the dependent one rather than an incomplete list of functions.  */\n-      tree dep_using = lookup_field_1 (type, lfi->name, lfi->want_type);\n-      if (dep_using && TREE_CODE (dep_using) == USING_DECL)\n-\tnval = dep_using;\n-    }\n+  nval = get_class_binding (type, lfi->name, lfi->want_type);\n \n   /* If we're looking up a type (as with an elaborated type specifier)\n      we ignore all non-types we find.  */"}]}