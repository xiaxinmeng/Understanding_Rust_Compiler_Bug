{"sha": "d246ab4f578b2e3369963386bafd66b26de8e63d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI0NmFiNGY1NzhiMmUzMzY5OTYzMzg2YmFmZDY2YjI2ZGU4ZTYzZA==", "commit": {"author": {"name": "Artjoms Sinkarovs", "email": "artyom.shinkaroff@gmail.com", "date": "2011-09-29T11:29:03Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-09-29T11:29:03Z"}, "message": "expr.c (do_store_flag): Expand vector comparison by building an appropriate VEC_COND_EXPR.\n\n2011-09-29  Artjoms Sinkarovs <artyom.shinkaroff@gmail.com>\n\n\t* expr.c (do_store_flag): Expand vector comparison by\n\tbuilding an appropriate VEC_COND_EXPR.\n\t* c-typeck.c (build_binary_op): Typecheck vector comparisons.\n\t(c_objc_common_truthvalue_conversion): Adjust.\n\t* tree-vect-generic.c (do_compare): Helper function.\n\t(expand_vector_comparison): Check if hardware supports\n\tvector comparison of the given type or expand vector\n\tpiecewise.\n\t(expand_vector_operation): Treat comparison as binary\n\toperation of vector type.\n\t(expand_vector_operations_1): Adjust.\n\n\t* gcc.c-torture/execute/vector-compare-1.c: New testcase.\n\t* gcc.c-torture/execute/vector-compare-2.c: Likewise.\n\t* gcc.dg/vector-compare-1.c: Likewise.\n\t* gcc.dg/vector-compare-2.c: Likewise.\n\nFrom-SVN: r179342", "tree": {"sha": "288524066a797ac20c1839c796218ffa83932145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/288524066a797ac20c1839c796218ffa83932145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d246ab4f578b2e3369963386bafd66b26de8e63d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d246ab4f578b2e3369963386bafd66b26de8e63d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d246ab4f578b2e3369963386bafd66b26de8e63d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d246ab4f578b2e3369963386bafd66b26de8e63d/comments", "author": {"login": "ashinkarov", "id": 892232, "node_id": "MDQ6VXNlcjg5MjIzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/892232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashinkarov", "html_url": "https://github.com/ashinkarov", "followers_url": "https://api.github.com/users/ashinkarov/followers", "following_url": "https://api.github.com/users/ashinkarov/following{/other_user}", "gists_url": "https://api.github.com/users/ashinkarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashinkarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashinkarov/subscriptions", "organizations_url": "https://api.github.com/users/ashinkarov/orgs", "repos_url": "https://api.github.com/users/ashinkarov/repos", "events_url": "https://api.github.com/users/ashinkarov/events{/privacy}", "received_events_url": "https://api.github.com/users/ashinkarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c99ecef0b605466c522f4c170811761339dac16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c99ecef0b605466c522f4c170811761339dac16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c99ecef0b605466c522f4c170811761339dac16"}], "stats": {"total": 384, "additions": 381, "deletions": 3}, "files": [{"sha": "9cadb7106751c5fd6be13d46c7eda304ba5c7440", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -1,3 +1,17 @@\n+2011-09-29  Artjoms Sinkarovs <artyom.shinkaroff@gmail.com>\n+\n+\t* expr.c (do_store_flag): Expand vector comparison by\n+\tbuilding an appropriate VEC_COND_EXPR.\n+\t* c-typeck.c (build_binary_op): Typecheck vector comparisons.\n+\t(c_objc_common_truthvalue_conversion): Adjust.\n+\t* tree-vect-generic.c (do_compare): Helper function.\n+\t(expand_vector_comparison): Check if hardware supports\n+\tvector comparison of the given type or expand vector\n+\tpiecewise.\n+\t(expand_vector_operation): Treat comparison as binary\n+\toperation of vector type.\n+\t(expand_vector_operations_1): Adjust.\n+\n 2011-09-29  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.c (build_opaque_vector_type): Make opaque vectors"}, {"sha": "e1c17a2c2115fe1af0fdf4e90f98fc69ab601817", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -9910,6 +9910,31 @@ build_binary_op (location_t location, enum tree_code code,\n \n     case EQ_EXPR:\n     case NE_EXPR:\n+      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n+        {\n+          tree intt;\n+          if (TREE_TYPE (type0) != TREE_TYPE (type1))\n+            {\n+              error_at (location, \"comparing vectors with different \"\n+                                  \"element types\");\n+              return error_mark_node;\n+            }\n+\n+          if (TYPE_VECTOR_SUBPARTS (type0) != TYPE_VECTOR_SUBPARTS (type1))\n+            {\n+              error_at (location, \"comparing vectors with different \"\n+                                  \"number of elements\");\n+              return error_mark_node;\n+            }\n+\n+          /* Always construct signed integer vector type.  */\n+          intt = c_common_type_for_size (GET_MODE_BITSIZE\n+\t\t\t\t\t   (TYPE_MODE (TREE_TYPE (type0))), 0);\n+          result_type = build_opaque_vector_type (intt,\n+\t\t\t\t\t\t  TYPE_VECTOR_SUBPARTS (type0));\n+          converted = 1;\n+          break;\n+        }\n       if (FLOAT_TYPE_P (type0) || FLOAT_TYPE_P (type1))\n \twarning_at (location,\n \t\t    OPT_Wfloat_equal,\n@@ -10022,6 +10047,31 @@ build_binary_op (location_t location, enum tree_code code,\n     case GE_EXPR:\n     case LT_EXPR:\n     case GT_EXPR:\n+      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n+        {\n+          tree intt;\n+          if (TREE_TYPE (type0) != TREE_TYPE (type1))\n+            {\n+              error_at (location, \"comparing vectors with different \"\n+                                  \"element types\");\n+              return error_mark_node;\n+            }\n+\n+          if (TYPE_VECTOR_SUBPARTS (type0) != TYPE_VECTOR_SUBPARTS (type1))\n+            {\n+              error_at (location, \"comparing vectors with different \"\n+                                  \"number of elements\");\n+              return error_mark_node;\n+            }\n+\n+          /* Always construct signed integer vector type.  */\n+          intt = c_common_type_for_size (GET_MODE_BITSIZE\n+\t\t\t\t\t   (TYPE_MODE (TREE_TYPE (type0))), 0);\n+          result_type = build_opaque_vector_type (intt,\n+\t\t\t\t\t\t  TYPE_VECTOR_SUBPARTS (type0));\n+          converted = 1;\n+          break;\n+        }\n       build_type = integer_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n \t   || code0 == FIXED_POINT_TYPE)\n@@ -10429,6 +10479,10 @@ c_objc_common_truthvalue_conversion (location_t location, tree expr)\n     case FUNCTION_TYPE:\n       gcc_unreachable ();\n \n+    case VECTOR_TYPE:\n+      error_at (location, \"used vector type where scalar is required\");\n+      return error_mark_node;\n+\n     default:\n       break;\n     }"}, {"sha": "7e89dbde7b9911c55b46ee39049b73da40ba7cc4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -18890,7 +18890,12 @@ ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)\n   enum machine_mode mode = GET_MODE (dest);\n   rtx t2, t3, x;\n \n-  if (op_false == CONST0_RTX (mode))\n+  if (vector_all_ones_operand (op_true, GET_MODE (op_true))\n+      && rtx_equal_p (op_false, CONST0_RTX (mode)))\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, cmp));\n+    }\n+  else if (op_false == CONST0_RTX (mode))\n     {\n       op_true = force_reg (mode, op_true);\n       x = gen_rtx_AND (mode, cmp, op_true);"}, {"sha": "e8a777dca07e9db27d3ad7e84c570efc36f666a9", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -6561,6 +6561,29 @@ invoke undefined behavior at runtime.  Warnings for out of bound\n accesses for vector subscription can be enabled with\n @option{-Warray-bounds}.\n \n+In GNU C vector comparison is supported within standard comparison\n+operators: @code{==, !=, <, <=, >, >=}. Comparison operands can be\n+vector expressions of integer-type or real-type. Comparison between\n+integer-type vectors and real-type vectors are not supported.  The\n+result of the comparison is a vector of the same width and number of\n+elements as the comparison operands with a signed integral element\n+type.\n+\n+Vectors are compared element-wise producing 0 when comparison is false\n+and -1 (constant of the appropriate type where all bits are set)\n+otherwise. Consider the following example.\n+\n+@smallexample\n+typedef int v4si __attribute__ ((vector_size (16)));\n+\n+v4si a = @{1,2,3,4@};\n+v4si b = @{3,2,1,4@};\n+v4si c;\n+\n+c = a >  b;     /* The result would be @{0, 0,-1, 0@}  */\n+c = a == b;     /* The result would be @{0,-1, 0,-1@}  */\n+@end smallexample\n+\n You can declare variables and use them in function calls and returns, as\n well as in assignments and some casts.  You can specify a vector type as\n a return type for a function.  Vector types can also be used as function"}, {"sha": "97edd460019a67441d79858f8ed893d7d1716429", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -10309,6 +10309,17 @@ do_store_flag (sepops ops, rtx target, enum machine_mode mode)\n   STRIP_NOPS (arg0);\n   STRIP_NOPS (arg1);\n \n+  /* For vector typed comparisons emit code to generate the desired\n+     all-ones or all-zeros mask.  Conveniently use the VEC_COND_EXPR\n+     expander for this.  */\n+  if (TREE_CODE (ops->type) == VECTOR_TYPE)\n+    {\n+      tree ifexp = build2 (ops->code, ops->type, arg0, arg1);\n+      tree if_true = constant_boolean_node (true, ops->type);\n+      tree if_false = constant_boolean_node (false, ops->type);\n+      return expand_vec_cond_expr (ops->type, ifexp, if_true, if_false, target);\n+    }\n+\n   /* Get the rtx comparison code to use.  We know that EXP is a comparison\n      operation of some type.  Some comparisons against 1 and -1 can be\n      converted to comparisons with zero.  Do so here so that the tests"}, {"sha": "59aefbc933894adc192b74f443396f5bb6c9416b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -1,3 +1,10 @@\n+2011-09-29  Artjoms Sinkarovs <artyom.shinkaroff@gmail.com>\n+\n+\t* gcc.c-torture/execute/vector-compare-1.c: New testcase.\n+\t* gcc.c-torture/execute/vector-compare-2.c: Likewise.\n+\t* gcc.dg/vector-compare-1.c: Likewise.\n+\t* gcc.dg/vector-compare-2.c: Likewise.\n+\n 2011-09-29  David S. Miller  <davem@davemloft.net>\n \n \t* gcc.target/sparc/array.c: New test."}, {"sha": "90eecb68a5dc57a9fbe6d20d95cf3ee5ac95b2b5", "filename": "gcc/testsuite/gcc.c-torture/execute/vector-compare-1.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvector-compare-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvector-compare-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvector-compare-1.c?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -0,0 +1,123 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define check_compare(count, res, i0, i1, op, fmt) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i ++) { \\\n+      if ((res)[__i] != ((i0)[__i] op (i1)[__i] ? -1 : 0)) \\\n+\t{ \\\n+            __builtin_printf (\"%i != ((\" fmt \" \" #op \" \" fmt \" ? -1 : 0) \", \\\n+\t\t\t      (res)[__i], (i0)[__i], (i1)[__i]); \\\n+            __builtin_abort (); \\\n+        } \\\n+    } \\\n+} while (0)\n+\n+#define test(count, v0, v1, res, fmt); \\\n+do { \\\n+    res = (v0 > v1); \\\n+    check_compare (count, res, v0, v1, >, fmt); \\\n+    res = (v0 < v1); \\\n+    check_compare (count, res, v0, v1, <, fmt); \\\n+    res = (v0 >= v1); \\\n+    check_compare (count, res, v0, v1, >=, fmt); \\\n+    res = (v0 <= v1); \\\n+    check_compare (count, res, v0, v1, <=, fmt); \\\n+    res = (v0 == v1); \\\n+    check_compare (count, res, v0, v1, ==, fmt); \\\n+    res = (v0 != v1); \\\n+    check_compare (count, res, v0, v1, !=, fmt); \\\n+} while (0)\n+\n+\n+int main (int argc, char *argv[]) {\n+#define INT  int\n+    vector (4, INT) i0;\n+    vector (4, INT) i1;\n+    vector (4, int) ires;\n+    int i;\n+\n+    i0 = (vector (4, INT)){argc, 1,  2,  10};\n+    i1 = (vector (4, INT)){0, 3, 2, (INT)-23};    \n+    test (4, i0, i1, ires, \"%i\");\n+#undef INT\n+\n+#define INT unsigned int \n+    vector (4, int) ures;\n+    vector (4, INT) u0;\n+    vector (4, INT) u1;\n+\n+    u0 = (vector (4, INT)){argc, 1,  2,  10};\n+    u1 = (vector (4, INT)){0, 3, 2, (INT)-23};    \n+    test (4, u0, u1, ures, \"%u\");\n+#undef INT\n+\n+\n+#define SHORT short\n+    vector (8, SHORT) s0;\n+    vector (8, SHORT) s1;\n+    vector (8, short) sres;\n+\n+    s0 = (vector (8, SHORT)){argc, 1,  2,  10,  6, 87, (SHORT)-5, 2};\n+    s1 = (vector (8, SHORT)){0, 3, 2, (SHORT)-23, 12, 10, (SHORT)-2, 0};    \n+    test (8, s0, s1, sres, \"%i\");\n+#undef SHORT\n+\n+#define SHORT unsigned short\n+    vector (8, SHORT) us0;\n+    vector (8, SHORT) us1;\n+    vector (8, short) usres;\n+\n+    us0 = (vector (8, SHORT)){argc, 1,  2,  10,  6, 87, (SHORT)-5, 2};\n+    us1 = (vector (8, SHORT)){0, 3, 2, (SHORT)-23, 12, 10, (SHORT)-2, 0};    \n+    test (8, us0, us1, usres, \"%u\");\n+#undef SHORT\n+\n+#define CHAR signed char\n+    vector (16, CHAR) c0;\n+    vector (16, CHAR) c1;\n+    vector (16, signed char) cres;\n+\n+    c0 = (vector (16, CHAR)){argc, 1,  2,  10,  6, 87, (CHAR)-5, 2, \\\n+                             argc, 1,  2,  10,  6, 87, (CHAR)-5, 2 };\n+\n+    c1 = (vector (16, CHAR)){0, 3, 2, (CHAR)-23, 12, 10, (CHAR)-2, 0, \\\n+                             0, 3, 2, (CHAR)-23, 12, 10, (CHAR)-2, 0};\n+    test (16, c0, c1, cres, \"%i\");\n+#undef CHAR\n+\n+#define CHAR unsigned char\n+    vector (16, CHAR) uc0;\n+    vector (16, CHAR) uc1;\n+    vector (16, signed char) ucres;\n+\n+    uc0 = (vector (16, CHAR)){argc, 1,  2,  10,  6, 87, (CHAR)-5, 2, \\\n+                             argc, 1,  2,  10,  6, 87, (CHAR)-5, 2 };\n+\n+    uc1 = (vector (16, CHAR)){0, 3, 2, (CHAR)-23, 12, 10, (CHAR)-2, 0, \\\n+                             0, 3, 2, (CHAR)-23, 12, 10, (CHAR)-2, 0};\n+    test (16, uc0, uc1, ucres, \"%u\");\n+#undef CHAR\n+/* Float comparison.  */\n+    vector (4, float) f0;\n+    vector (4, float) f1;\n+    vector (4, int) ifres;\n+\n+    f0 = (vector (4, float)){(float)argc, 1.,  2.,  10.};\n+    f1 = (vector (4, float)){0., 3., 2., (float)-23};    \n+    test (4, f0, f1, ifres, \"%f\");\n+    \n+/* Double comparison.  */\n+    vector (2, double) d0;\n+    vector (2, double) d1;\n+    vector (2, long long) idres;\n+\n+    d0 = (vector (2, double)){(double)argc,  10.};\n+    d1 = (vector (2, double)){0., (double)-23};    \n+    test (2, d0, d1, idres, \"%f\");\n+\n+\n+    return 0;\n+}\n+"}, {"sha": "398c8254a47c061470e7ced1d69f49be05bd55e5", "filename": "gcc/testsuite/gcc.c-torture/execute/vector-compare-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvector-compare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvector-compare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvector-compare-2.c?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -0,0 +1,27 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+/* Check that constant folding in \n+   these simple cases works.  */\n+vector (4, int)\n+foo (vector (4, int) x)\n+{\n+  return   (x == x) + (x != x) + (x >  x) \n+\t + (x <  x) + (x >= x) + (x <= x);\n+}\n+\n+int \n+main (int argc, char *argv[])\n+{\n+  vector (4, int) t = {argc, 2, argc, 42};\n+  vector (4, int) r;\n+  int i;\n+\n+  r = foo (t);\n+\n+  for (i = 0; i < 4; i++)\n+    if (r[i] != -3)\n+      __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "b56823988106f80aa8cfb8257ac2e59493ceb9b9", "filename": "gcc/testsuite/gcc.dg/vector-compare-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-compare-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-compare-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-compare-1.c?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+void\n+foo (vector (4, int) x, vector (4, float) y)\n+{\n+  vector (4, int) p4;\n+  vector (4, int) r4;\n+  vector (4, unsigned int) q4;\n+  vector (8, int) r8;\n+  vector (4, float) f4;\n+  \n+  r4 = x > y;\t    /* { dg-error \"comparing vectors with different element types\" } */\n+  r8 = (x != p4);   /* { dg-error \"incompatible types when assigning to type\" } */\n+  r8 == r4;\t    /* { dg-error \"comparing vectors with different number of elements\" } */\n+}"}, {"sha": "e672dd1d9c41084ee44f5bdf85a6edaf1741e59c", "filename": "gcc/testsuite/gcc.dg/vector-compare-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-compare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-compare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-compare-2.c?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */   \n+\n+/* Test if C_MAYBE_CONST are folded correctly when \n+   creating VEC_COND_EXPR.  */\n+\n+typedef int vec __attribute__((vector_size(16)));\n+\n+vec i,j;\n+extern vec a, b, c;\n+\n+extern int p, q, z;\n+extern vec foo (int);\n+\n+vec \n+foo (int x)\n+{\n+  return  foo (p ? q :z) > a;\n+}\n+\n+vec \n+bar (int x)\n+{\n+  return  b > foo (p ? q :z);\n+}\n+\n+"}, {"sha": "042d703e15f1787b5befbf20a858622df859d8d1", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d246ab4f578b2e3369963386bafd66b26de8e63d/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=d246ab4f578b2e3369963386bafd66b26de8e63d", "patch": "@@ -35,6 +35,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"optabs.h\"\n \n+\n+static void expand_vector_operations_1 (gimple_stmt_iterator *);\n+\n+\n /* Build a constant of type TYPE, made of VALUE's bits replicated\n    every TYPE_SIZE (INNER_TYPE) bits to fit TYPE's precision.  */\n static tree\n@@ -125,6 +129,31 @@ do_binop (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n   return gimplify_build2 (gsi, code, inner_type, a, b);\n }\n \n+\n+/* Construct expression (A[BITPOS] code B[BITPOS]) ? -1 : 0\n+\n+   INNER_TYPE is the type of A and B elements\n+\n+   returned expression is of signed integer type with the\n+   size equal to the size of INNER_TYPE.  */\n+static tree\n+do_compare (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n+\t  tree bitpos, tree bitsize, enum tree_code code)\n+{\n+  tree comp_type;\n+\n+  a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n+  b = tree_vec_extract (gsi, inner_type, b, bitsize, bitpos);\n+\n+  comp_type = build_nonstandard_integer_type\n+\t\t      (GET_MODE_BITSIZE (TYPE_MODE (inner_type)), 0);\n+\n+  return gimplify_build3 (gsi, COND_EXPR, comp_type,\n+\t\t\t  fold_build2 (code, boolean_type_node, a, b),\n+\t\t\t  build_int_cst (comp_type, -1),\n+\t\t\t  build_int_cst (comp_type, 0));\n+}\n+\n /* Expand vector addition to scalars.  This does bit twiddling\n    in order to increase parallelism:\n \n@@ -333,6 +362,24 @@ uniform_vector_p (tree vec)\n   return NULL_TREE;\n }\n \n+/* Try to expand vector comparison expression OP0 CODE OP1 by\n+   querying optab if the following expression:\n+\tVEC_COND_EXPR< OP0 CODE OP1, {-1,...}, {0,...}>\n+   can be expanded.  */\n+static tree\n+expand_vector_comparison (gimple_stmt_iterator *gsi, tree type, tree op0,\n+                          tree op1, enum tree_code code)\n+{\n+  tree t;\n+  if (! expand_vec_cond_expr_p (type, TREE_TYPE (op0)))\n+    t = expand_vector_piecewise (gsi, do_compare, type,\n+\t\t\t\t TREE_TYPE (TREE_TYPE (op0)), op0, op1, code);\n+  else\n+    t = NULL_TREE;\n+\n+  return t;\n+}\n+\n static tree\n expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type,\n \t\t\t gimple assign, enum tree_code code)\n@@ -375,8 +422,27 @@ expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type\n       case BIT_NOT_EXPR:\n         return expand_vector_parallel (gsi, do_unop, type,\n \t\t      \t\t       gimple_assign_rhs1 (assign),\n-\t\t\t\t       NULL_TREE, code);\n+        \t\t\t       NULL_TREE, code);\n+      case EQ_EXPR:\n+      case NE_EXPR:\n+      case GT_EXPR:\n+      case LT_EXPR:\n+      case GE_EXPR:\n+      case LE_EXPR:\n+      case UNEQ_EXPR:\n+      case UNGT_EXPR:\n+      case UNLT_EXPR:\n+      case UNGE_EXPR:\n+      case UNLE_EXPR:\n+      case LTGT_EXPR:\n+      case ORDERED_EXPR:\n+      case UNORDERED_EXPR:\n+\t{\n+\t  tree rhs1 = gimple_assign_rhs1 (assign);\n+\t  tree rhs2 = gimple_assign_rhs2 (assign);\n \n+\t  return expand_vector_comparison (gsi, type, rhs1, rhs2, code);\n+\t}\n       default:\n \tbreak;\n       }\n@@ -450,11 +516,11 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \n   code = gimple_assign_rhs_code (stmt);\n   rhs_class = get_gimple_rhs_class (code);\n+  lhs = gimple_assign_lhs (stmt);\n \n   if (rhs_class != GIMPLE_UNARY_RHS && rhs_class != GIMPLE_BINARY_RHS)\n     return;\n \n-  lhs = gimple_assign_lhs (stmt);\n   rhs1 = gimple_assign_rhs1 (stmt);\n   type = gimple_expr_type (stmt);\n   if (rhs_class == GIMPLE_BINARY_RHS)\n@@ -598,6 +664,11 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \n   gcc_assert (code != VEC_LSHIFT_EXPR && code != VEC_RSHIFT_EXPR);\n   new_rhs = expand_vector_operation (gsi, type, compute_type, stmt, code);\n+\n+  /* Leave expression untouched for later expansion.  */\n+  if (new_rhs == NULL_TREE)\n+    return;\n+\n   if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (new_rhs)))\n     new_rhs = gimplify_build1 (gsi, VIEW_CONVERT_EXPR, TREE_TYPE (lhs),\n                                new_rhs);"}]}