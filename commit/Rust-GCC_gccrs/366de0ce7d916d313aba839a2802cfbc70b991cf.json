{"sha": "366de0ce7d916d313aba839a2802cfbc70b991cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY2ZGUwY2U3ZDkxNmQzMTNhYmE4MzlhMjgwMmNmYmM3MGI5OTFjZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-09-07T10:19:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-07T10:19:00Z"}, "message": "c-aux-info.c (gen_type): Use gcc_assert or gcc_unreachable.\n\n\t* c-aux-info.c (gen_type): Use gcc_assert or gcc_unreachable.\n\t* c-common.c (c_type_hash, c_common_nodes_and_builtins,\n\tc_expand_expr, boolean_increment, nonnull_check_p,\n\tcheck_function_arguments_recurse, fold_offsetof_1): Likewise.\n\t* c-cppbuiltin.c (define__GNUC__, builtin_define_stdint_macros,\n\tbuiltin_define_type_max): Likewise.\n\t* c-decl.c (bind, pop_scope, merge_decls, pushdecl_top_level,\n\timplicit_decl_warning, builtin_function, build_compound_literal,\n\tcomplete_array_type, grokdeclarator, get_parm_info,\n\tstart_function, store_parm_decls_oldstyle,\n\tc_write_global_declarations): Likewise.\n\t* c-format.c (get_constant, decode_format_attr,\n\tmaybe_read_dollar_number, get_flag_spec, check_format_arg,\n\tcheck_format_types, format_type_warning,\n\tfind_char_info_specifier_index, init_dynamic_asm_fprintf_info,\n\tinit_dynamic_diag_info, handle_format_attribute): Likewise.\n\t* c-gimplify.c (push_context, pop_context, finish_bc_block):\n\t* c-lex.c (c_lex_with_flags, lex_string): Likewise.\n\t* c-objc-common.c (c_tree_printer): Likewise.\n\t* c-pch.c (pch_init): Likewise.\n\t* c-pragma.c (maybe_apply_pragma_weak): Likewise.\n\t* c-pretty-print.c (pp_c_tree_decl_identifier): Likewise.\n\t* c-typeck.c (c_incomplete_type_error, composite_type,\n\tcommon_pointer_type, common_type, same_translation_unit_p,\n\ttagged_types_tu_compatible_p, finish_init, pop_init_level,\n\tset_designator, set_nonincremental_init_from_string,\n\tprocess_init_element, c_finish_if_stmt): Likewise.\n\t* caller-save.c (init_caller_save, save_call_clobbered_regs,\n\tinsert_restore, insert_save, insert_one_insn): Likewise.\n\t* calls.c (emit_call_1, compute_argument_block_size,\n\tprecompute_arguments, expand_call, emit_library_call_value_1,\n\tstore_one_arg): Likewise.\n\nFrom-SVN: r87140", "tree": {"sha": "dd4f142a645a4fabe170becf3c587e3d8176358c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd4f142a645a4fabe170becf3c587e3d8176358c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/366de0ce7d916d313aba839a2802cfbc70b991cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366de0ce7d916d313aba839a2802cfbc70b991cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/366de0ce7d916d313aba839a2802cfbc70b991cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366de0ce7d916d313aba839a2802cfbc70b991cf/comments", "author": null, "committer": null, "parents": [{"sha": "e1bbfc5cc2dd0458d1350df2e9055ef9d213d159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1bbfc5cc2dd0458d1350df2e9055ef9d213d159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1bbfc5cc2dd0458d1350df2e9055ef9d213d159"}], "stats": {"total": 1147, "additions": 553, "deletions": 594}, "files": [{"sha": "bc6075e9540b3a1adc8313a79a1c82c35dcb1283", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -1,3 +1,38 @@\n+2004-09-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* c-aux-info.c (gen_type): Use gcc_assert or gcc_unreachable.\n+\t* c-common.c (c_type_hash, c_common_nodes_and_builtins,\n+\tc_expand_expr, boolean_increment, nonnull_check_p,\n+\tcheck_function_arguments_recurse, fold_offsetof_1): Likewise.\n+\t* c-cppbuiltin.c (define__GNUC__, builtin_define_stdint_macros,\n+\tbuiltin_define_type_max): Likewise.\n+\t* c-decl.c (bind, pop_scope, merge_decls, pushdecl_top_level,\n+\timplicit_decl_warning, builtin_function, build_compound_literal,\n+\tcomplete_array_type, grokdeclarator, get_parm_info,\n+\tstart_function, store_parm_decls_oldstyle,\n+\tc_write_global_declarations): Likewise.\n+\t* c-format.c (get_constant, decode_format_attr,\n+\tmaybe_read_dollar_number, get_flag_spec, check_format_arg,\n+\tcheck_format_types, format_type_warning,\n+\tfind_char_info_specifier_index, init_dynamic_asm_fprintf_info,\n+\tinit_dynamic_diag_info, handle_format_attribute): Likewise.\n+\t* c-gimplify.c (push_context, pop_context, finish_bc_block): \n+\t* c-lex.c (c_lex_with_flags, lex_string): Likewise.\n+\t* c-objc-common.c (c_tree_printer): Likewise.\n+\t* c-pch.c (pch_init): Likewise.\n+\t* c-pragma.c (maybe_apply_pragma_weak): Likewise.\n+\t* c-pretty-print.c (pp_c_tree_decl_identifier): Likewise.\n+\t* c-typeck.c (c_incomplete_type_error, composite_type,\n+\tcommon_pointer_type, common_type, same_translation_unit_p,\n+\ttagged_types_tu_compatible_p, finish_init, pop_init_level,\n+\tset_designator, set_nonincremental_init_from_string,\n+\tprocess_init_element, c_finish_if_stmt): Likewise.\n+\t* caller-save.c (init_caller_save, save_call_clobbered_regs,\n+\tinsert_restore, insert_save, insert_one_insn): Likewise.\n+\t* calls.c (emit_call_1, compute_argument_block_size,\n+\tprecompute_arguments, expand_call, emit_library_call_value_1,\n+\tstore_one_arg): Likewise.\n+\n 2004-09-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* configure.ac (enable-checking): Add release option. Reorganize"}, {"sha": "b42adce9a80d9a8ef2b87b55901c78105c6ed052", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -447,7 +447,7 @@ gen_type (const char *ret_val, tree t, formals_style style)\n \t  break;\n \n         default:\n-          abort ();\n+          gcc_unreachable ();\n         }\n     }\n   if (TYPE_READONLY (t))"}, {"sha": "b7aa389cbfa3df91b1d102ed520462f90b0245c3", "filename": "gcc/c-common.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -2578,7 +2578,7 @@ c_type_hash (const void *p)\n       t2 = TYPE_FIELDS (t);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   for (; t2; t2 = TREE_CHAIN (t2))\n     i++;\n@@ -3188,8 +3188,8 @@ c_common_nodes_and_builtins (void)\n     {\t\t\t\t\t\t\t\t\t\\\n       tree decl;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (strncmp (NAME, \"__builtin_\", strlen (\"__builtin_\")) != 0)\t\\\n-\tabort ();\t\t\t\t\t\t\t\\\n+      gcc_assert (!strncmp (NAME, \"__builtin_\",\t\t\t\t\\\n+\t\t\t    strlen (\"__builtin_\")));\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (!BOTH_P)\t\t\t\t\t\t\t\\\n \tdecl = lang_hooks.builtin_function (NAME, builtin_types[TYPE],\t\\\n@@ -3830,7 +3830,7 @@ c_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3878,7 +3878,7 @@ boolean_increment (enum tree_code code, tree arg)\n       val = build2 (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   TREE_SIDE_EFFECTS (val) = 1;\n   return val;\n@@ -5111,8 +5111,9 @@ nonnull_check_p (tree args, unsigned HOST_WIDE_INT param_num)\n \n   for (; args; args = TREE_CHAIN (args))\n     {\n-      if (! get_nonnull_operand (TREE_VALUE (args), &arg_num))\n-\tabort ();\n+      bool found = get_nonnull_operand (TREE_VALUE (args), &arg_num);\n+\n+      gcc_assert (found);\n \n       if (arg_num == param_num)\n \treturn true;\n@@ -5356,9 +5357,8 @@ check_function_arguments_recurse (void (*callback)\n \t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n \t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n \n-\t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n-\t\t|| TREE_INT_CST_HIGH (format_num_expr) != 0)\n-\t      abort ();\n+\t    gcc_assert (TREE_CODE (format_num_expr) == INTEGER_CST\n+\t\t\t&& !TREE_INT_CST_HIGH (format_num_expr));\n \n \t    format_num = TREE_INT_CST_LOW (format_num_expr);\n \n@@ -5619,7 +5619,7 @@ fold_offsetof_1 (tree expr)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return size_binop (code, base, off);"}, {"sha": "c20e987e83ae213571f49437de54e14a525b45d5", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -261,8 +261,7 @@ define__GNUC__ (void)\n \n   while (*v && ! ISDIGIT (*v))\n     v++;\n-  if (!*v || (v > version_string && v[-1] != '-'))\n-    abort ();\n+  gcc_assert (*v && (v <= version_string || v[-1] == '-'));\n \n   q = v;\n   while (ISDIGIT (*v))\n@@ -271,17 +270,16 @@ define__GNUC__ (void)\n   if (c_dialect_cxx ())\n     builtin_define_with_value_n (\"__GNUG__\", q, v - q);\n \n-  if (*v != '.' || !ISDIGIT (v[1]))\n-    abort ();\n+  gcc_assert (*v == '.' || ISDIGIT (v[1]));\n+  \n   q = ++v;\n   while (ISDIGIT (*v))\n     v++;\n   builtin_define_with_value_n (\"__GNUC_MINOR__\", q, v - q);\n \n   if (*v == '.')\n     {\n-      if (!ISDIGIT (v[1]))\n-\tabort ();\n+      gcc_assert (ISDIGIT (v[1]));\n       q = ++v;\n       while (ISDIGIT (*v))\n \tv++;\n@@ -290,8 +288,7 @@ define__GNUC__ (void)\n   else\n     builtin_define_with_value_n (\"__GNUC_PATCHLEVEL__\", \"0\", 1);\n \n-  if (*v && *v != ' ' && *v != '-')\n-    abort ();\n+  gcc_assert (!*v || *v == ' ' || *v == '-');\n }\n \n /* Define macros used by <stdint.h>.  Currently only defines limits\n@@ -307,7 +304,7 @@ builtin_define_stdint_macros (void)\n   else if (intmax_type_node == integer_type_node)\n     intmax_long = 0;\n   else\n-    abort ();\n+    gcc_unreachable ();\n   builtin_define_type_max (\"__INTMAX_MAX__\", intmax_type_node, intmax_long);\n }\n \n@@ -617,7 +614,7 @@ builtin_define_type_max (const char *macro, tree type, int is_long)\n     case 32:\tidx = 4; break;\n     case 64:\tidx = 6; break;\n     case 128:\tidx = 8; break;\n-    default:    abort ();\n+    default:    gcc_unreachable ();\n     }\n \n   value = values[idx + TYPE_UNSIGNED (type)];"}, {"sha": "aad75640ca9a429a7f3261c63ce721e88a44cb66", "filename": "gcc/c-decl.c", "status": "modified", "additions": 337, "deletions": 356, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -477,7 +477,7 @@ bind (tree name, tree decl, struct c_scope *scope, bool invisible, bool nested)\n     case ERROR_MARK:     here = &I_SYMBOL_BINDING (name);  break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Locate the appropriate place in the chain of shadowed decls\n@@ -731,10 +731,7 @@ pop_scope (void)\n \t  /* Labels go in BLOCK_VARS.  */\n \t  TREE_CHAIN (p) = BLOCK_VARS (block);\n \t  BLOCK_VARS (block) = p;\n-\n-#ifdef ENABLE_CHECKING\n-\t  if (I_LABEL_BINDING (b->id) != b) abort ();\n-#endif\n+\t  gcc_assert (I_LABEL_BINDING (b->id) == b);\n  \t  I_LABEL_BINDING (b->id) = b->shadowed;\n  \t  break;\n \n@@ -747,9 +744,7 @@ pop_scope (void)\n \t     appears in the bindings list with b->id NULL.  */\n \t  if (b->id)\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      if (I_TAG_BINDING (b->id) != b) abort ();\n-#endif\n+\t      gcc_assert (I_TAG_BINDING (b->id) == b);\n \t      I_TAG_BINDING (b->id) = b->shadowed;\n \t    }\n   \t  break;\n@@ -819,17 +814,15 @@ pop_scope (void)\n \t     here with b->id NULL in this case.  */\n \t  if (b->id)\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      if (I_SYMBOL_BINDING (b->id) != b) abort ();\n-#endif\n+\t      gcc_assert (I_SYMBOL_BINDING (b->id) == b);\n \t      I_SYMBOL_BINDING (b->id) = b->shadowed;\n \t      if (b->shadowed && b->shadowed->type)\n \t\tTREE_TYPE (b->shadowed->decl) = b->shadowed->type;\n \t    }\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -1527,7 +1520,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n       for (here = &current_scope->bindings; *here; here = &(*here)->prev)\n \tif ((*here)->decl == olddecl)\n \t  goto found;\n-      abort ();\n+      gcc_unreachable ();\n \n     found:\n       b = *here;\n@@ -2124,13 +2117,11 @@ pushdecl_top_level (tree x)\n   tree name;\n   bool nested = false;\n \n-  if (TREE_CODE (x) != VAR_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (x) == VAR_DECL);\n \n   name = DECL_NAME (x);\n \n-  if (I_SYMBOL_BINDING (name))\n-    abort ();\n+  gcc_assert (!I_SYMBOL_BINDING (name));\n \n   if (TREE_PUBLIC (x))\n     {\n@@ -2152,7 +2143,7 @@ implicit_decl_warning (tree id, tree olddecl)\n     case 0: return;\n     case 1: diag = warning; break;\n     case 2: diag = error;   break;\n-    default: abort ();\n+    default: gcc_unreachable ();\n     }\n \n   diag (N_(\"implicit declaration of function '%E'\"), id);\n@@ -2644,8 +2635,7 @@ builtin_function (const char *name, tree type, int function_code,\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n \n   /* Should never be called on a symbol with a preexisting meaning.  */\n-  if (I_SYMBOL_BINDING (id))\n-    abort ();\n+  gcc_assert (!I_SYMBOL_BINDING (id));\n \n   bind (id, decl, external_scope, /*invisible=*/true, /*nested=*/false);\n \n@@ -3439,8 +3429,8 @@ build_compound_literal (tree type, tree init)\n   if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n     {\n       int failure = complete_array_type (type, DECL_INITIAL (decl), 1);\n-      if (failure)\n-\tabort ();\n+      \n+      gcc_assert (!failure);\n     }\n \n   type = TREE_TYPE (decl);\n@@ -3529,8 +3519,8 @@ complete_array_type (tree type, tree initial_value, int do_default)\n   if (maxindex)\n     {\n       TYPE_DOMAIN (type) = build_index_type (maxindex);\n-      if (!TREE_TYPE (maxindex))\n-\tabort ();\n+      \n+      gcc_assert (TREE_TYPE (maxindex));\n     }\n \n   /* Lay out the type now that we can get the real answer.  */\n@@ -3737,7 +3727,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     orig_name = name;\n     if (name == 0)\n@@ -4211,333 +4201,341 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  array_parm_static = 0;\n \t}\n \n-      if (TREE_CODE (declarator) == TREE_LIST)\n-\t{\n-\t  /* We encode a declarator with embedded attributes using\n-\t     a TREE_LIST.  */\n-\t  tree attrs = TREE_PURPOSE (declarator);\n-\t  tree inner_decl;\n-\t  int attr_flags = 0;\n-\t  declarator = TREE_VALUE (declarator);\n-\t  inner_decl = declarator;\n-\t  while (inner_decl != NULL_TREE\n-\t\t && TREE_CODE (inner_decl) == TREE_LIST)\n-\t    inner_decl = TREE_VALUE (inner_decl);\n-\t  if (inner_decl == NULL_TREE\n-\t      || TREE_CODE (inner_decl) == IDENTIFIER_NODE)\n-\t    attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n-\t  else if (TREE_CODE (inner_decl) == CALL_EXPR)\n-\t    attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n-\t  else if (TREE_CODE (inner_decl) == ARRAY_REF)\n-\t    attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n-\t  returned_attrs = decl_attributes (&type,\n-\t\t\t\t\t    chainon (returned_attrs, attrs),\n-\t\t\t\t\t    attr_flags);\n-\t}\n-      else if (TREE_CODE (declarator) == ARRAY_REF)\n+      switch (TREE_CODE (declarator))\n \t{\n-\t  tree itype = NULL_TREE;\n-\t  tree size = TREE_OPERAND (declarator, 1);\n-\t  /* The index is a signed object `sizetype' bits wide.  */\n-\t  tree index_type = c_common_signed_type (sizetype);\n-\n-\t  array_ptr_quals = TREE_TYPE (declarator);\n-\t  array_parm_static = TREE_STATIC (declarator);\n-\n-\t  declarator = TREE_OPERAND (declarator, 0);\n-\n-\t  /* Check for some types that there cannot be arrays of.  */\n-\n-\t  if (VOID_TYPE_P (type))\n-\t    {\n-\t      error (\"declaration of `%s' as array of voids\", name);\n-\t      type = error_mark_node;\n-\t    }\n-\n-\t  if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t    {\n-\t      error (\"declaration of `%s' as array of functions\", name);\n+\tcase TREE_LIST:\n+\t  {\n+\t    /* We encode a declarator with embedded attributes using a\n+\t       TREE_LIST.  */\n+\t    tree attrs = TREE_PURPOSE (declarator);\n+\t    tree inner_decl;\n+\t    int attr_flags = 0;\n+\t    declarator = TREE_VALUE (declarator);\n+\t    inner_decl = declarator;\n+\t    while (inner_decl != NULL_TREE\n+\t\t   && TREE_CODE (inner_decl) == TREE_LIST)\n+\t      inner_decl = TREE_VALUE (inner_decl);\n+\t    if (inner_decl == NULL_TREE\n+\t\t|| TREE_CODE (inner_decl) == IDENTIFIER_NODE)\n+\t      attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n+\t    else if (TREE_CODE (inner_decl) == CALL_EXPR)\n+\t      attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n+\t    else if (TREE_CODE (inner_decl) == ARRAY_REF)\n+\t      attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n+\t    returned_attrs = decl_attributes (&type,\n+\t\t\t\t\t      chainon (returned_attrs, attrs),\n+\t\t\t\t\t      attr_flags);\n+\t    break;\n+\t  }\n+\tcase ARRAY_REF:\n+\t  {\n+\t    tree itype = NULL_TREE;\n+\t    tree size = TREE_OPERAND (declarator, 1);\n+\t    /* The index is a signed object `sizetype' bits wide.  */\n+\t    tree index_type = c_common_signed_type (sizetype);\n+\n+\t    array_ptr_quals = TREE_TYPE (declarator);\n+\t    array_parm_static = TREE_STATIC (declarator);\n+\t    \n+\t    declarator = TREE_OPERAND (declarator, 0);\n+\n+\t    /* Check for some types that there cannot be arrays of.  */\n+\t    \n+\t    if (VOID_TYPE_P (type))\n+\t      {\n+\t\terror (\"declaration of `%s' as array of voids\", name);\n+\t\ttype = error_mark_node;\n+\t      }\n+\t    \n+\t    if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t      {\n+\t\terror (\"declaration of `%s' as array of functions\", name);\n+\t\ttype = error_mark_node;\n+\t      }\n+\t    \n+\t    if (pedantic && !in_system_header && flexible_array_type_p (type))\n+\t      pedwarn (\"invalid use of structure with flexible array member\");\n+\t    \n+\t    if (size == error_mark_node)\n \t      type = error_mark_node;\n-\t    }\n-\n-\t  if (pedantic && !in_system_header && flexible_array_type_p (type))\n-\t    pedwarn (\"invalid use of structure with flexible array member\");\n-\n-\t  if (size == error_mark_node)\n-\t    type = error_mark_node;\n-\n-\t  if (type == error_mark_node)\n-\t    continue;\n-\n-\t  /* If size was specified, set ITYPE to a range-type for that size.\n-\t     Otherwise, ITYPE remains null.  finish_decl may figure it out\n-\t     from an initial value.  */\n-\n-\t  if (size)\n-\t    {\n-\t      /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n-\t      STRIP_TYPE_NOPS (size);\n-\n-\t      if (! INTEGRAL_TYPE_P (TREE_TYPE (size)))\n-\t\t{\n-\t\t  error (\"size of array `%s' has non-integer type\", name);\n-\t\t  size = integer_one_node;\n-\t\t}\n-\n-\t      if (pedantic && integer_zerop (size))\n-\t\tpedwarn (\"ISO C forbids zero-size array `%s'\", name);\n-\n-\t      if (TREE_CODE (size) == INTEGER_CST)\n-\t\t{\n-\t\t  constant_expression_warning (size);\n-\t\t  if (tree_int_cst_sgn (size) < 0)\n-\t\t    {\n-\t\t      error (\"size of array `%s' is negative\", name);\n-\t\t      size = integer_one_node;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Make sure the array size remains visibly nonconstant\n-\t\t     even if it is (eg) a const variable with known value.  */\n-\t\t  size_varies = 1;\n-\n-\t\t  if (!flag_isoc99 && pedantic)\n-\t\t    {\n-\t\t      if (TREE_CONSTANT (size))\n-\t\t\tpedwarn (\"ISO C90 forbids array `%s' whose size can't be evaluated\",\n-\t\t\t\t name);\n-\t\t      else\n-\t\t\tpedwarn (\"ISO C90 forbids variable-size array `%s'\",\n-\t\t\t\t name);\n-\t\t    }\n-\t\t}\n-\n-\t      if (integer_zerop (size))\n-\t\t{\n-\t\t  /* A zero-length array cannot be represented with an\n-\t\t     unsigned index type, which is what we'll get with\n-\t\t     build_index_type.  Create an open-ended range instead.  */\n-\t\t  itype = build_range_type (sizetype, size, NULL_TREE);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Compute the maximum valid index, that is, size - 1.\n-\t\t     Do the calculation in index_type, so that if it is\n-\t\t     a variable the computations will be done in the\n-\t\t     proper mode.  */\n-\t          itype = fold (build2 (MINUS_EXPR, index_type,\n-\t\t\t\t\tconvert (index_type, size),\n-\t\t\t\t\tconvert (index_type, size_one_node)));\n-\n-\t          /* If that overflowed, the array is too big.\n-\t\t     ??? While a size of INT_MAX+1 technically shouldn't\n-\t\t     cause an overflow (because we subtract 1), the overflow\n-\t\t     is recorded during the conversion to index_type, before\n-\t\t     the subtraction.  Handling this case seems like an\n-\t\t     unnecessary complication.  */\n-\t\t  if (TREE_OVERFLOW (itype))\n-\t\t    {\n-\t\t      error (\"size of array `%s' is too large\", name);\n-\t\t      type = error_mark_node;\n-\t\t      continue;\n-\t\t    }\n+\t    \n+\t    if (type == error_mark_node)\n+\t      continue;\n \n-\t\t  if (size_varies)\n-\t\t    itype = variable_size (itype);\n-\t\t  itype = build_index_type (itype);\n-\t\t}\n-\t    }\n-\t  else if (decl_context == FIELD)\n-\t    {\n-\t      if (pedantic && !flag_isoc99 && !in_system_header)\n-\t\tpedwarn (\"ISO C90 does not support flexible array members\");\n+\t    /* If size was specified, set ITYPE to a range-type for\n+\t       that size.  Otherwise, ITYPE remains null.  finish_decl\n+\t       may figure it out from an initial value.  */\n \n-\t      /* ISO C99 Flexible array members are effectively identical\n-\t\t to GCC's zero-length array extension.  */\n-\t      itype = build_range_type (sizetype, size_zero_node, NULL_TREE);\n-\t    }\n+\t    if (size)\n+\t      {\n+\t\t/* Strip NON_LVALUE_EXPRs since we aren't using as an\n+\t\t   lvalue.  */\n+\t\tSTRIP_TYPE_NOPS (size);\n+\t\t\n+\t\tif (! INTEGRAL_TYPE_P (TREE_TYPE (size)))\n+\t\t  {\n+\t\t    error (\"size of array `%s' has non-integer type\", name);\n+\t\t    size = integer_one_node;\n+\t\t  }\n+\t\t\n+\t\tif (pedantic && integer_zerop (size))\n+\t\t  pedwarn (\"ISO C forbids zero-size array `%s'\", name);\n+\t\t\n+\t\tif (TREE_CODE (size) == INTEGER_CST)\n+\t\t  {\n+\t\t    constant_expression_warning (size);\n+\t\t    if (tree_int_cst_sgn (size) < 0)\n+\t\t      {\n+\t\t\terror (\"size of array `%s' is negative\", name);\n+\t\t\tsize = integer_one_node;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Make sure the array size remains visibly\n+\t\t       nonconstant even if it is (eg) a const variable\n+\t\t       with known value.  */\n+\t\t    size_varies = 1;\n+\t\t    \n+\t\t    if (!flag_isoc99 && pedantic)\n+\t\t      {\n+\t\t\tif (TREE_CONSTANT (size))\n+\t\t\t  pedwarn (\"ISO C90 forbids array `%s' whose size can't be evaluated\",\n+\t\t\t\t   name);\n+\t\t\telse\n+\t\t\t  pedwarn (\"ISO C90 forbids variable-size array `%s'\",\n+\t\t\t\t   name);\n+\t\t      }\n+\t\t  }\n \n-\t  /* If pedantic, complain about arrays of incomplete types.  */\n+\t\tif (integer_zerop (size))\n+\t\t  {\n+\t\t    /* \tA zero-length array cannot be represented with\n+\t\t        an unsigned index type, which is what we'll\n+\t\t        get with build_index_type.  Create an\n+\t\t        open-ended range instead.  */\n+\t\t    itype = build_range_type (sizetype, size, NULL_TREE);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Compute the maximum valid index, that is, size\n+\t\t       - 1.  Do the calculation in index_type, so that\n+\t\t       if it is a variable the computations will be\n+\t\t       done in the proper mode.  */\n+\t\t    itype = fold (build2 (MINUS_EXPR, index_type,\n+\t\t\t\t\t  convert (index_type, size),\n+\t\t\t\t\t  convert (index_type,\n+\t\t\t\t\t\t   size_one_node)));\n+\n+\t\t    /* If that overflowed, the array is too big.  ??? \n+\t\t       While a size of INT_MAX+1 technically shouldn't\n+\t\t       cause an overflow (because we subtract 1), the\n+\t\t       overflow is recorded during the conversion to\n+\t\t       index_type, before the subtraction.  Handling\n+\t\t       this case seems like an unnecessary\n+\t\t       complication.  */\n+\t\t    if (TREE_OVERFLOW (itype))\n+\t\t      {\n+\t\t\terror (\"size of array `%s' is too large\", name);\n+\t\t\ttype = error_mark_node;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    \n+\t\t    if (size_varies)\n+\t\t      itype = variable_size (itype);\n+\t\t    itype = build_index_type (itype);\n+\t\t  }\n+\t      }\n+\t    else if (decl_context == FIELD)\n+\t      {\n+\t\tif (pedantic && !flag_isoc99 && !in_system_header)\n+\t\t  pedwarn (\"ISO C90 does not support flexible array members\");\n \n-\t  if (pedantic && !COMPLETE_TYPE_P (type))\n-\t    pedwarn (\"array type has incomplete element type\");\n+\t\t/* ISO C99 Flexible array members are effectively\n+\t\t   identical to GCC's zero-length array extension.  */\n+\t\titype = build_range_type (sizetype, size_zero_node, NULL_TREE);\n+\t      }\n \n-\t  /* Build the array type itself, then merge any constancy or\n-\t     volatility into the target type.  We must do it in this order\n-\t     to ensure that the TYPE_MAIN_VARIANT field of the array type\n-\t     is set correctly.  */\n+\t    /* If pedantic, complain about arrays of incomplete types.  */\n+\t    if (pedantic && !COMPLETE_TYPE_P (type))\n+\t      pedwarn (\"array type has incomplete element type\");\n \n-\t  type = build_array_type (type, itype);\n-\t  if (type_quals)\n-\t    type = c_build_qualified_type (type, type_quals);\n+\t    /* Build the array type itself, then merge any constancy\n+\t       or volatility into the target type.  We must do it in\n+\t       this order to ensure that the TYPE_MAIN_VARIANT field\n+\t       of the array type is set correctly.  */\n+\t    type = build_array_type (type, itype);\n+\t    if (type_quals)\n+\t      type = c_build_qualified_type (type, type_quals);\n \n-\t  if (size_varies)\n-\t    C_TYPE_VARIABLE_SIZE (type) = 1;\n+\t    if (size_varies)\n+\t      C_TYPE_VARIABLE_SIZE (type) = 1;\n \n-\t  /* The GCC extension for zero-length arrays differs from\n-\t     ISO flexible array members in that sizeof yields zero.  */\n-\t  if (size && integer_zerop (size))\n-\t    {\n+\t    /* The GCC extension for zero-length arrays differs from\n+\t       ISO flexible array members in that sizeof yields\n+\t       zero.  */\n+\t    if (size && integer_zerop (size))\n+\t      {\n+\t\tlayout_type (type);\n+\t\tTYPE_SIZE (type) = bitsize_zero_node;\n+\t\tTYPE_SIZE_UNIT (type) = size_zero_node;\n+\t      }\n+\t    else if (declarator && TREE_CODE (declarator) == INDIRECT_REF)\n+\t      /* We can never complete an array type which is the\n+\t         target of a pointer, so go ahead and lay it out.  */\n \t      layout_type (type);\n-\t      TYPE_SIZE (type) = bitsize_zero_node;\n-\t      TYPE_SIZE_UNIT (type) = size_zero_node;\n-\t    }\n-\t  else if (declarator && TREE_CODE (declarator) == INDIRECT_REF)\n-\t    /* We can never complete an array type which is the target of a\n-\t       pointer, so go ahead and lay it out.  */\n-\t    layout_type (type);\n-\n-\t  if (decl_context != PARM\n-\t      && (array_ptr_quals != NULL_TREE || array_parm_static))\n-\t    {\n-\t      error (\"static or type qualifiers in non-parameter array declarator\");\n-\t      array_ptr_quals = NULL_TREE;\n-\t      array_parm_static = 0;\n-\t    }\n-\t}\n-      else if (TREE_CODE (declarator) == CALL_EXPR)\n-\t{\n-\t  /* Say it's a definition only for the declarator closest to\n-\t     the identifier, apart possibly from some attributes.  */\n-\t  bool really_funcdef = false;\n-\t  tree arg_types;\n-\t  if (funcdef_flag)\n-\t    {\n-\t      tree t = TREE_OPERAND (declarator, 0);\n-\t      while (TREE_CODE (t) == TREE_LIST)\n-\t\tt = TREE_VALUE (t);\n-\t      really_funcdef = (TREE_CODE (t) == IDENTIFIER_NODE);\n-\t    }\n \n-\t  /* Declaring a function type.\n-\t     Make sure we have a valid type for the function to return.  */\n-\t  if (type == error_mark_node)\n-\t    continue;\n-\n-\t  size_varies = 0;\n+\t    if (decl_context != PARM\n+\t\t&& (array_ptr_quals != NULL_TREE || array_parm_static))\n+\t      {\n+\t\terror (\"static or type qualifiers in non-parameter array declarator\");\n+\t\tarray_ptr_quals = NULL_TREE;\n+\t\tarray_parm_static = 0;\n+\t      }\n+\t    break;\n+\t  }\n+\tcase CALL_EXPR:\n+\t  {\n+\t    /* Say it's a definition only for the declarator closest\n+\t       to the identifier, apart possibly from some\n+\t       attributes.  */\n+\t    bool really_funcdef = false;\n+\t    tree arg_types;\n+\t    if (funcdef_flag)\n+\t      {\n+\t\ttree t = TREE_OPERAND (declarator, 0);\n+\t\twhile (TREE_CODE (t) == TREE_LIST)\n+\t\t  t = TREE_VALUE (t);\n+\t\treally_funcdef = (TREE_CODE (t) == IDENTIFIER_NODE);\n+\t      }\n \n-\t  /* Warn about some types functions can't return.  */\n+\t    /* Declaring a function type.  Make sure we have a valid\n+\t       type for the function to return.  */\n+\t    if (type == error_mark_node)\n+\t      continue;\n+\t    \n+\t    size_varies = 0;\n \n-\t  if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t    {\n-\t      error (\"`%s' declared as function returning a function\", name);\n-\t      type = integer_type_node;\n-\t    }\n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    {\n-\t      error (\"`%s' declared as function returning an array\", name);\n-\t      type = integer_type_node;\n-\t    }\n+\t    /* Warn about some types functions can't return.  */\n+\t    if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t      {\n+\t\terror (\"`%s' declared as function returning a function\", name);\n+\t\ttype = integer_type_node;\n+\t      }\n+\t    if (TREE_CODE (type) == ARRAY_TYPE)\n+\t      {\n+\t\terror (\"`%s' declared as function returning an array\", name);\n+\t\ttype = integer_type_node;\n+\t      }\n \n-\t  /* Construct the function type and go to the next\n-\t     inner layer of declarator.  */\n-\t  arg_info = TREE_OPERAND (declarator, 1);\n-\t  arg_types = grokparms (arg_info, really_funcdef);\n+\t    /* Construct the function type and go to the next\n+\t       inner layer of declarator.  */\n+\t    arg_info = TREE_OPERAND (declarator, 1);\n+\t    arg_types = grokparms (arg_info, really_funcdef);\n \n-\t  /* Type qualifiers before the return type of the function\n-\t     qualify the return type, not the function type.  */\n-\t  if (type_quals)\n+\t    /* Type qualifiers before the return type of the function\n+\t       qualify the return type, not the function type.  */\n+\t    if (type_quals)\n+\t      {\n+\t        /* Type qualifiers on a function return type are\n+\t\t   normally permitted by the standard but have no\n+\t\t   effect, so give a warning at -Wreturn-type.\n+\t\t   Qualifiers on a void return type are banned on\n+\t\t   function definitions in ISO C; GCC used to used\n+\t\t   them for noreturn functions.  */\n+\t\tif (VOID_TYPE_P (type) && really_funcdef)\n+\t\t  pedwarn (\"function definition has qualified void return type\");\n+\t\telse if (warn_return_type)\n+\t\t  warning (\"type qualifiers ignored on function return type\");\n+\t\t\n+\t\ttype = c_build_qualified_type (type, type_quals);\n+\t      }\n+\t    type_quals = TYPE_UNQUALIFIED;\n+\t    \n+\t    type = build_function_type (type, arg_types);\n+\t    declarator = TREE_OPERAND (declarator, 0);\n+\t    \n+\t    /* Set the TYPE_CONTEXTs for each tagged type which is local to\n+\t       the formal parameter list of this FUNCTION_TYPE to point to\n+\t       the FUNCTION_TYPE node itself.  */\n \t    {\n-\t      /* Type qualifiers on a function return type are\n-\t\t normally permitted by the standard but have no\n-\t\t effect, so give a warning at -Wreturn-type.\n-\t\t Qualifiers on a void return type are banned on\n-\t\t function definitions in ISO C; GCC used to used them\n-\t\t for noreturn functions.  */\n-\t      if (VOID_TYPE_P (type) && really_funcdef)\n-\t\tpedwarn (\"function definition has qualified void return type\");\n-\t      else if (warn_return_type)\n-\t\twarning (\"type qualifiers ignored on function return type\");\n-\n-\t      type = c_build_qualified_type (type, type_quals);\n+\t      tree link;\n+\t      \n+\t      for (link = ARG_INFO_TAGS (arg_info);\n+\t\t   link;\n+\t\t   link = TREE_CHAIN (link))\n+\t\tTYPE_CONTEXT (TREE_VALUE (link)) = type;\n \t    }\n-\t  type_quals = TYPE_UNQUALIFIED;\n-\n-\t  type = build_function_type (type, arg_types);\n-\t  declarator = TREE_OPERAND (declarator, 0);\n-\n-\t  /* Set the TYPE_CONTEXTs for each tagged type which is local to\n-\t     the formal parameter list of this FUNCTION_TYPE to point to\n-\t     the FUNCTION_TYPE node itself.  */\n-\n+\t    break;\n+\t  }\n+\tcase INDIRECT_REF:\n \t  {\n-\t    tree link;\n+\t    /* Merge any constancy or volatility into the target type\n+\t       for the pointer.  */\n \n-\t    for (link = ARG_INFO_TAGS (arg_info);\n-\t\t link;\n-\t\t link = TREE_CHAIN (link))\n-\t      TYPE_CONTEXT (TREE_VALUE (link)) = type;\n+\t    if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n+\t\t&& type_quals)\n+\t      pedwarn (\"ISO C forbids qualified function types\");\n+\t    if (type_quals)\n+\t      type = c_build_qualified_type (type, type_quals);\n+\t    type_quals = TYPE_UNQUALIFIED;\n+\t    size_varies = 0;\n+\t    \n+\t    type = build_pointer_type (type);\n+\t    \n+\t    /* Process a list of type modifier keywords (such as const\n+\t       or volatile) that were given inside the `*'.  */\n+\t    if (TREE_TYPE (declarator))\n+\t      {\n+\t\ttree typemodlist;\n+\t\tint erred = 0;\n+\t\t\n+\t\tconstp = 0;\n+\t\tvolatilep = 0;\n+\t\trestrictp = 0;\n+\t\tfor (typemodlist = TREE_TYPE (declarator); typemodlist;\n+\t\t     typemodlist = TREE_CHAIN (typemodlist))\n+\t\t  {\n+\t\t    tree qualifier = TREE_VALUE (typemodlist);\n+\t\t    \n+\t\t    if (C_IS_RESERVED_WORD (qualifier))\n+\t\t      {\n+\t\t\tif (C_RID_CODE (qualifier) == RID_CONST)\n+\t\t\t  constp++;\n+\t\t\telse if (C_RID_CODE (qualifier) == RID_VOLATILE)\n+\t\t\t  volatilep++;\n+\t\t\telse if (C_RID_CODE (qualifier) == RID_RESTRICT)\n+\t\t\t  restrictp++;\n+\t\t\telse\n+\t\t\t  erred++;\n+\t\t      }\n+\t\t    else\n+\t\t      erred++;\n+\t\t  }\n+\t\t\n+\t\tif (erred)\n+\t\t  error (\"invalid type modifier within pointer declarator\");\n+\t\tif (pedantic && !flag_isoc99)\n+\t\t  {\n+\t\t    if (constp > 1)\n+\t\t      pedwarn (\"duplicate `const'\");\n+\t\t    if (volatilep > 1)\n+\t\t      pedwarn (\"duplicate `volatile'\");\n+\t\t    if (restrictp > 1)\n+\t\t      pedwarn (\"duplicate `restrict'\");\n+\t\t  }\n+\t\t\n+\t\ttype_quals = ((constp ? TYPE_QUAL_CONST : 0)\n+\t\t\t      | (restrictp ? TYPE_QUAL_RESTRICT : 0)\n+\t\t\t      | (volatilep ? TYPE_QUAL_VOLATILE : 0));\n+\t      }\n+\t    \n+\t    declarator = TREE_OPERAND (declarator, 0);\n+\t    break;\n \t  }\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else if (TREE_CODE (declarator) == INDIRECT_REF)\n-\t{\n-\t  /* Merge any constancy or volatility into the target type\n-\t     for the pointer.  */\n-\n-\t  if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n-\t      && type_quals)\n-\t    pedwarn (\"ISO C forbids qualified function types\");\n-\t  if (type_quals)\n-\t    type = c_build_qualified_type (type, type_quals);\n-\t  type_quals = TYPE_UNQUALIFIED;\n-\t  size_varies = 0;\n-\n-\t  type = build_pointer_type (type);\n-\n-\t  /* Process a list of type modifier keywords\n-\t     (such as const or volatile) that were given inside the `*'.  */\n-\n-\t  if (TREE_TYPE (declarator))\n-\t    {\n-\t      tree typemodlist;\n-\t      int erred = 0;\n-\n-\t      constp = 0;\n-\t      volatilep = 0;\n-\t      restrictp = 0;\n-\t      for (typemodlist = TREE_TYPE (declarator); typemodlist;\n-\t\t   typemodlist = TREE_CHAIN (typemodlist))\n-\t\t{\n-\t\t  tree qualifier = TREE_VALUE (typemodlist);\n-\n-\t\t  if (C_IS_RESERVED_WORD (qualifier))\n-\t\t    {\n-\t\t      if (C_RID_CODE (qualifier) == RID_CONST)\n-\t\t\tconstp++;\n-\t\t      else if (C_RID_CODE (qualifier) == RID_VOLATILE)\n-\t\t\tvolatilep++;\n-\t\t      else if (C_RID_CODE (qualifier) == RID_RESTRICT)\n-\t\t\trestrictp++;\n-\t\t      else\n-\t\t\terred++;\n-\t\t    }\n-\t\t  else\n-\t\t    erred++;\n-\t\t}\n-\n-\t      if (erred)\n-\t\terror (\"invalid type modifier within pointer declarator\");\n-\t      if (pedantic && !flag_isoc99)\n-\t\t{\n-\t\t  if (constp > 1)\n-\t\t    pedwarn (\"duplicate `const'\");\n-\t\t  if (volatilep > 1)\n-\t\t    pedwarn (\"duplicate `volatile'\");\n-\t\t  if (restrictp > 1)\n-\t\t    pedwarn (\"duplicate `restrict'\");\n-\t\t}\n-\n-\t      type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n-\t\t\t    | (restrictp ? TYPE_QUAL_RESTRICT : 0)\n-\t\t\t    | (volatilep ? TYPE_QUAL_VOLATILE : 0));\n-\t    }\n-\n-\t  declarator = TREE_OPERAND (declarator, 0);\n-\t}\n-      else\n-\tabort ();\n-\n     }\n \n   /* Now TYPE has the actual type.  */\n@@ -4930,12 +4928,9 @@ grokdeclarator (tree declarator, tree declspecs,\n \tC_DECL_REGISTER (decl) = was_reg;\n       }\n \n-#ifdef ENABLE_CHECKING\n   /* This is the earliest point at which we might know the assembler\n      name of a variable.  Thus, if it's known before this, die horribly.  */\n-  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n-    abort ();\n-#endif\n+    gcc_assert (!DECL_ASSEMBLER_NAME_SET_P (decl));\n \n     decl_attributes (&decl, returned_attrs, 0);\n \n@@ -5059,10 +5054,7 @@ get_parm_info (bool ellipsis)\n \n   /* This function is only called if there was *something* on the\n      parameter list.  */\n-#ifdef ENABLE_CHECKING\n-  if (b == 0)\n-    abort ();\n-#endif\n+  gcc_assert (b);\n \n   /* A parameter list consisting solely of 'void' indicates that the\n      function takes no arguments.  But if the 'void' is qualified\n@@ -5103,9 +5095,7 @@ get_parm_info (bool ellipsis)\n \tcase PARM_DECL:\n \t  if (b->id)\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      if (I_SYMBOL_BINDING (b->id) != b) abort ();\n-#endif\n+\t      gcc_assert (I_SYMBOL_BINDING (b->id) == b);\n \t      I_SYMBOL_BINDING (b->id) = b->shadowed;\n \t    }\n \n@@ -5143,9 +5133,7 @@ get_parm_info (bool ellipsis)\n \t     appears in the bindings list with b->id NULL.  */\n \t  if (b->id)\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      if (I_TAG_BINDING (b->id) != b) abort ();\n-#endif\n+\t      gcc_assert (I_TAG_BINDING (b->id) == b);\n \t      I_TAG_BINDING (b->id) = b->shadowed;\n \t    }\n \n@@ -5192,9 +5180,7 @@ get_parm_info (bool ellipsis)\n \t     variable.  Just throw it away.  */\n \t  if (b->id)\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      if (I_SYMBOL_BINDING (b->id) != b) abort ();\n-#endif\n+\t      gcc_assert (I_SYMBOL_BINDING (b->id) == b);\n \t      I_SYMBOL_BINDING (b->id) = b->shadowed;\n \t    }\n \t  break;\n@@ -5204,7 +5190,7 @@ get_parm_info (bool ellipsis)\n \tcase FUNCTION_DECL:\n \tcase VAR_DECL:\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       b = free_binding_and_advance (b);\n@@ -6054,12 +6040,9 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   if (current_function_decl != 0)\n     TREE_PUBLIC (decl1) = 0;\n \n-#ifdef ENABLE_CHECKING\n   /* This is the earliest point at which we might know the assembler\n      name of the function.  Thus, if it's set before this, die horribly.  */\n-  if (DECL_ASSEMBLER_NAME_SET_P (decl1))\n-    abort ();\n-#endif\n+  gcc_assert (!DECL_ASSEMBLER_NAME_SET_P (decl1));\n \n   /* If #pragma weak was used, mark the decl weak now.  */\n   if (current_scope == file_scope)\n@@ -6229,8 +6212,7 @@ store_parm_decls_oldstyle (tree fndecl, tree arg_info)\n      seen already, since it is not used on PARM_DECL.  */\n #ifdef ENABLE_CHECKING\n   for (b = current_scope->bindings; b; b = b->prev)\n-    if (TREE_CODE (b->decl) == PARM_DECL && DECL_WEAK (b->decl))\n-      abort ();\n+    gcc_assert (TREE_CODE (b->decl) != PARM_DECL || !DECL_WEAK (b->decl));\n #endif\n \n   if (warn_old_style_definition && !in_system_header)\n@@ -6991,8 +6973,7 @@ c_write_global_declarations (void)\n   /* Close the external scope.  */\n   ext_block = pop_scope ();\n   external_scope = 0;\n-  if (current_scope)\n-    abort ();\n+  gcc_assert (!current_scope);\n \n   /* Process all file scopes in this compilation, and the external_scope,\n      through wrapup_global_declarations and check_global_declarations.  */"}, {"sha": "9524746568e25e5a5b7e5a1d57b4a3033a3ca1b1", "filename": "gcc/c-format.c", "status": "modified", "additions": 33, "deletions": 49, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -151,7 +151,7 @@ check_format_string (tree argument, unsigned HOST_WIDE_INT format_num,\n    and store its value. If validated_p is true, abort on errors.\n    Returns true on success, false otherwise.  */\n static bool\n-get_constant(tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n+get_constant (tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n {\n   while (TREE_CODE (expr) == NOP_EXPR\n \t || TREE_CODE (expr) == CONVERT_EXPR\n@@ -160,8 +160,7 @@ get_constant(tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n \n   if (TREE_CODE (expr) != INTEGER_CST || TREE_INT_CST_HIGH (expr) != 0)\n     {\n-      if (validated_p)\n-\tabort ();\n+      gcc_assert (!validated_p);\n       return false;\n     }\n \n@@ -187,8 +186,7 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n \n   if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n     {\n-      if (validated_p)\n-\tabort ();\n+      gcc_assert (!validated_p);\n       error (\"unrecognized format specifier\");\n       return false;\n     }\n@@ -200,8 +198,7 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n \n       if (info->format_type == format_type_error)\n \t{\n-\t  if (validated_p)\n-\t    abort ();\n+\t  gcc_assert (!validated_p);\n \t  warning (\"%qs is an unrecognized format function type\", p);\n \t  return false;\n \t}\n@@ -221,8 +218,7 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n \n   if (info->first_arg_num != 0 && info->first_arg_num <= info->format_num)\n     {\n-      if (validated_p)\n-\tabort ();\n+      gcc_assert (!validated_p);\n       error (\"format string arg follows the args to be formatted\");\n       return false;\n     }\n@@ -1004,11 +1000,8 @@ maybe_read_dollar_number (const char **format,\n       for (i = 1; i < argnum && *param_ptr != 0; i++)\n \t*param_ptr = TREE_CHAIN (*param_ptr);\n \n-      if (*param_ptr == 0)\n-\t{\n-\t  /* This case shouldn't be caught here.  */\n-\t  abort ();\n-\t}\n+      /* This case shouldn't be caught here.  */\n+      gcc_assert (*param_ptr);\n     }\n   else\n     *param_ptr = 0;\n@@ -1096,10 +1089,8 @@ get_flag_spec (const format_flag_spec *spec, int flag, const char *predicates)\n       else if (spec[i].predicate == 0)\n \treturn &spec[i];\n     }\n-  if (predicates == NULL)\n-    abort ();\n-  else\n-    return NULL;\n+  gcc_assert (predicates);\n+  return NULL;\n }\n \n \n@@ -1299,8 +1290,8 @@ check_format_arg (void *ctx, tree format_tree,\n   if (array_size != 0)\n     {\n       /* Variable length arrays can't be initialized.  */\n-      if (TREE_CODE (array_size) != INTEGER_CST)\n-\tabort ();\n+      gcc_assert (TREE_CODE (array_size) == INTEGER_CST);\n+      \n       if (host_integerp (array_size, 0))\n \t{\n \t  HOST_WIDE_INT array_size_value = TREE_INT_CST_LOW (array_size);\n@@ -2053,10 +2044,8 @@ check_format_types (format_wanted_type *types, const char *format_start,\n       arg_num = types->arg_num;\n \n       /* The following should not occur here.  */\n-      if (wanted_type == 0)\n-\tabort ();\n-      if (wanted_type == void_type_node && types->pointer_count == 0)\n-\tabort ();\n+      gcc_assert (wanted_type);\n+      gcc_assert (wanted_type != void_type_node || types->pointer_count);\n \n       if (types->pointer_count == 0)\n \twanted_type = lang_hooks.types.type_promotes_to (wanted_type);\n@@ -2253,17 +2242,14 @@ format_type_warning (const char *descr, const char *format_start,\n static unsigned int\n find_char_info_specifier_index (const format_char_info *fci, int c)\n {\n-  unsigned int i = 0;\n-  \n-  while (fci->format_chars)\n-    {\n-      if (strchr (fci->format_chars, c))\n-\treturn i;\n-      i++; fci++;\n-    }\n+  unsigned i;\n+\n+  for (i = 0; fci->format_chars; i++, fci++)\n+    if (strchr (fci->format_chars, c))\n+      return i;\n   \n   /* We shouldn't be looking for a non-existent specifier.  */\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Given a format_length_info array FLI, and a character C, this\n@@ -2273,17 +2259,14 @@ find_char_info_specifier_index (const format_char_info *fci, int c)\n static unsigned int\n find_length_info_modifier_index (const format_length_info *fli, int c)\n {\n-  unsigned int i = 0;\n-  \n-  while (fli->name)\n-    {\n-      if (strchr (fli->name, c))\n-\treturn i;\n-      i++; fli++;\n-    }\n+  unsigned i;\n+\n+  for (i = 0; fli->name; i++, fli++)\n+    if (strchr (fli->name, c))\n+      return i;\n   \n   /* We shouldn't be looking for a non-existent modifier.  */\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Determine the type of HOST_WIDE_INT in the code being compiled for\n@@ -2293,7 +2276,7 @@ static void\n init_dynamic_asm_fprintf_info (void)\n {\n   static tree hwi;\n-      \n+\n   if (!hwi)\n     {\n       format_length_info *new_asm_fprintf_length_specs;\n@@ -2303,9 +2286,10 @@ init_dynamic_asm_fprintf_info (void)\n \t length modifier to work, one must have issued: \"typedef\n \t HOST_WIDE_INT __gcc_host_wide_int__;\" in one's source code\n \t prior to using that modifier.  */\n-      if (!(hwi = maybe_get_identifier (\"__gcc_host_wide_int__\"))\n-\t  || !(hwi = DECL_ORIGINAL_TYPE (identifier_global_value (hwi))))\n-\tabort ();\n+      hwi = maybe_get_identifier (\"__gcc_host_wide_int__\");\n+      gcc_assert (hwi);\n+      hwi = DECL_ORIGINAL_TYPE (identifier_global_value (hwi));\n+      gcc_assert (hwi);\n \n       /* Create a new (writable) copy of asm_fprintf_length_specs.  */\n       new_asm_fprintf_length_specs = (format_length_info *)\n@@ -2320,7 +2304,7 @@ init_dynamic_asm_fprintf_info (void)\n       else if (hwi == long_long_integer_type_node)\n \tnew_asm_fprintf_length_specs[i].index = FMT_LEN_ll;\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       /* Assign the new data for use.  */\n       dynamic_format_types[asm_fprintf_format_type].length_char_specs =\n@@ -2383,7 +2367,7 @@ init_dynamic_diag_info (void)\n \t  else if (hwi == long_long_integer_type_node)\n \t    diag_ls[i].index = FMT_LEN_ll;\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n \n       /* Handle the __gcc_diag__ format specifics.  */\n@@ -2551,7 +2535,7 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t       || info.format_type == gcc_cxxdiag_format_type)\n \tinit_dynamic_diag_info();\n       else\n-\tabort();\n+\tgcc_unreachable();\n     }\n \n   return NULL_TREE;"}, {"sha": "d77d75c2f77ce23571fccb92197d1b610e4c10aa", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -84,8 +84,7 @@ static struct c_gimplify_ctx\n static void\n push_context (void)\n {\n-  if (ctxp)\n-    abort ();\n+  gcc_assert (!ctxp);\n   ctxp = (struct c_gimplify_ctx *) xcalloc (1, sizeof (struct c_gimplify_ctx));\n   ctxp->bc_id[bc_continue] = get_identifier (\"continue\");\n   ctxp->bc_id[bc_break] = get_identifier (\"break\");\n@@ -94,8 +93,7 @@ push_context (void)\n static void\n pop_context (void)\n {\n-  if (!ctxp || ctxp->current_bc_label)\n-    abort ();\n+  gcc_assert (ctxp && !ctxp->current_bc_label);\n   free (ctxp);\n   ctxp = NULL;\n }\n@@ -275,8 +273,7 @@ begin_bc_block (enum bc_t bc)\n static tree\n finish_bc_block (tree label, tree body)\n {\n-  if (label != ctxp->current_bc_label)\n-    abort ();\n+  gcc_assert (label == ctxp->current_bc_label);\n \n   if (TREE_USED (label))\n     {"}, {"sha": "6334885f0a326943dd0c0f4ed7ce79a614097212", "filename": "gcc/c-lex.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -373,7 +373,7 @@ c_lex_with_flags (tree *value, unsigned char *cpp_flags)\n \t    break;\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n       }\n       break;\n@@ -435,7 +435,7 @@ c_lex_with_flags (tree *value, unsigned char *cpp_flags)\n     case CPP_HEADER_NAME:\n     case CPP_COMMENT:\n     case CPP_MACRO_ARG:\n-      abort ();\n+      gcc_unreachable ();\n \n     default:\n       *value = NULL_TREE;\n@@ -737,12 +737,11 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n \n       if (c_lex_string_translate == -1)\n \t{\n-\t  if (!cpp_interpret_string_notranslate (parse_in, strs, count,\n-\t\t\t\t\t\t &istr, wide))\n-\t    /* Assume that, if we managed to translate the string\n-\t       above, then the untranslated parsing will always\n-\t       succeed.  */\n-\t    abort ();\n+\t  int xlated = cpp_interpret_string_notranslate (parse_in, strs, count,\n+\t\t\t\t\t\t\t &istr, wide);\n+\t  /* Assume that, if we managed to translate the string above,\n+\t     then the untranslated parsing will always succeed.  */\n+\t  gcc_assert (xlated);\n \t  \n \t  if (TREE_STRING_LENGTH (value) != (int)istr.len\n \t      || 0 != strncmp (TREE_STRING_POINTER (value), (char *)istr.text,"}, {"sha": "9d05a6d97bfcd3499516d450fc5af4af2c366f59", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -213,10 +213,9 @@ c_tree_printer (pretty_printer *pp, text_info *text)\n       break;\n \n     case 'T':\n-      if (TYPE_P (t))\n-\tname = TYPE_NAME (t);\n-      else\n-\tabort ();\n+      gcc_assert (TYPE_P (t));\n+      name = TYPE_NAME (t);\n+      \n       if (name && TREE_CODE (name) == TYPE_DECL)\n \t{\n \t  if (DECL_NAME (name))"}, {"sha": "6352d37fb3d995b8720a905ff60a30f84219cf63", "filename": "gcc/c-pch.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -129,10 +129,10 @@ pch_init (void)\n   if (f == NULL)\n     fatal_error (\"can't create precompiled header %s: %m\", pch_file);\n   pch_outfile = f;\n-  \n-  if (strlen (host_machine) > 255 || strlen (target_machine) > 255\n-      || strlen (version_string) > 255)\n-    abort ();\n+\n+  gcc_assert (strlen (host_machine) < 256\n+\t      && strlen (target_machine) < 256\n+\t      && strlen (version_string) < 256);\n   \n   v.host_machine_length = strlen (host_machine);\n   v.target_machine_length = strlen (target_machine);\n@@ -143,8 +143,7 @@ pch_init (void)\n     for (i = 0; i < MATCH_SIZE; i++)\n       {\n \tv.match[i] = *pch_matching[i].flag_var;\n-\tif (v.match[i] != *pch_matching[i].flag_var)\n-\t  abort ();\n+\tgcc_assert (v.match[i] == *pch_matching[i].flag_var);\n       }\n   }\n   v.pch_init = &pch_init;"}, {"sha": "fe9f17ab569f7e6448ec014c64fab7e40e7b6151", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -279,7 +279,7 @@ maybe_apply_pragma_weak (tree decl)\n     return;\n   /* If it's not a function or a variable, it can't be weak.\n      FIXME: what kinds of things are visible outside this file but\n-     aren't functions or variables?   Should this be an abort() instead?  */\n+     aren't functions or variables?   Should this be an assert instead?  */\n   if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)\n     return;\n "}, {"sha": "7b741244bbf0508ab6ed06b92e9a9f1f90105b71", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -2139,8 +2139,7 @@ pp_c_tree_decl_identifier (c_pretty_printer *pp, tree t)\n {\n   const char *name;\n \n-  if (!DECL_P (t))\n-    abort ();\n+  gcc_assert (DECL_P (t));\n \n   if (DECL_NAME (t))\n     name = IDENTIFIER_POINTER (DECL_NAME (t));"}, {"sha": "c776c7874bf826f66aeffd5bfa5e6687dea17c70", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -157,7 +157,7 @@ c_incomplete_type_error (tree value, tree type)\n \t  return;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n@@ -240,8 +240,7 @@ composite_type (tree t1, tree t2)\n   if (code2 == ENUMERAL_TYPE && code1 == INTEGER_TYPE)\n     return t2;\n \n-  if (code1 != code2)\n-    abort ();\n+  gcc_assert (code1 == code2);\n \n   switch (code1)\n     {\n@@ -261,8 +260,7 @@ composite_type (tree t1, tree t2)\n \ttree elt = composite_type (TREE_TYPE (t1), TREE_TYPE (t2));\n \t\n \t/* We should not have any type quals on arrays at all.  */\n-\tif (TYPE_QUALS (t1) || TYPE_QUALS (t2))\n-\t  abort ();\n+\tgcc_assert (!TYPE_QUALS (t1) && !TYPE_QUALS (t2));\n \t\n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1))\n@@ -412,8 +410,8 @@ common_pointer_type (tree t1, tree t2)\n   if (t2 == error_mark_node)\n     return t1;\n \n-  if (TREE_CODE (t1) != POINTER_TYPE || TREE_CODE (t2) != POINTER_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (t1) == POINTER_TYPE\n+ \t      && TREE_CODE (t2) == POINTER_TYPE);\n \n   /* Merge the attributes.  */\n   attributes = targetm.merge_type_attributes (t1, t2);\n@@ -470,13 +468,10 @@ common_type (tree t1, tree t2)\n   code1 = TREE_CODE (t1);\n   code2 = TREE_CODE (t2);\n \n-  if (code1 != VECTOR_TYPE && code1 != COMPLEX_TYPE\n-      && code1 != REAL_TYPE && code1 != INTEGER_TYPE)\n-    abort ();\n-\n-  if (code2 != VECTOR_TYPE && code2 != COMPLEX_TYPE\n-      && code2 != REAL_TYPE && code2 != INTEGER_TYPE)\n-    abort ();\n+  gcc_assert (code1 == VECTOR_TYPE || code1 == COMPLEX_TYPE\n+\t      || code1 == REAL_TYPE || code1 == INTEGER_TYPE);\n+  gcc_assert (code2 == VECTOR_TYPE || code2 == COMPLEX_TYPE\n+\t      || code2 == REAL_TYPE || code2 == INTEGER_TYPE);\n \n   /* If one type is a vector type, return that type.  (How the usual\n      arithmetic conversions apply to the vector types extension is not\n@@ -744,7 +739,7 @@ same_translation_unit_p (tree t1, tree t2)\n       case 'd': t1 = DECL_CONTEXT (t1); break;\n       case 't': t1 = TYPE_CONTEXT (t1); break;\n       case 'x': t1 = BLOCK_SUPERCONTEXT (t1); break;  /* assume block */\n-      default: abort ();\n+      default: gcc_unreachable ();\n       }\n \n   while (t2 && TREE_CODE (t2) != TRANSLATION_UNIT_DECL)\n@@ -753,7 +748,7 @@ same_translation_unit_p (tree t1, tree t2)\n       case 'd': t2 = DECL_CONTEXT (t2); break;\n       case 't': t2 = TYPE_CONTEXT (t2); break;\n       case 'x': t2 = BLOCK_SUPERCONTEXT (t2); break;  /* assume block */\n-      default: abort ();\n+      default: gcc_unreachable ();\n       }\n \n   return t1 == t2;\n@@ -935,7 +930,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -4371,8 +4366,7 @@ finish_init (void)\n       free (q);\n     }\n \n-  if (constructor_range_stack)\n-    abort ();\n+  gcc_assert (!constructor_range_stack);\n \n   /* Pop back to the data of the outer initializer (if any).  */\n   free (spelling_base);\n@@ -4716,8 +4710,7 @@ pop_init_level (int implicit)\n       while (constructor_stack->implicit)\n \tprocess_init_element (pop_init_level (1));\n \n-      if (constructor_range_stack)\n-\tabort ();\n+      gcc_assert (!constructor_range_stack);\n     }\n \n   /* Now output all pending elements.  */\n@@ -4737,8 +4730,10 @@ pop_init_level (int implicit)\n \t already have pedwarned for empty brackets.  */\n       if (integer_zerop (constructor_unfilled_index))\n \tconstructor_type = NULL_TREE;\n-      else if (! TYPE_SIZE (constructor_type))\n+      else\n \t{\n+\t  gcc_assert (!TYPE_SIZE (constructor_type));\n+\t  \n \t  if (constructor_depth > 2)\n \t    error_init (\"initialization of flexible array member in a nested context\");\n \t  else if (pedantic)\n@@ -4750,10 +4745,6 @@ pop_init_level (int implicit)\n \t  if (TREE_CHAIN (constructor_fields) != NULL_TREE)\n \t    constructor_type = NULL_TREE;\n \t}\n-      else\n-\t/* Zero-length arrays are no longer special, so we should no longer\n-\t   get here.  */\n-\tabort ();\n     }\n \n   /* Warn when some struct elements are implicitly initialized to zero.  */\n@@ -4869,14 +4860,14 @@ set_designator (int array)\n   if (constructor_type == 0)\n     return 1;\n \n-  /* If there were errors in this designator list already, bail out silently.  */\n+  /* If there were errors in this designator list already, bail out\n+     silently.  */\n   if (designator_errorneous)\n     return 1;\n \n   if (!designator_depth)\n     {\n-      if (constructor_range_stack)\n-\tabort ();\n+      gcc_assert (!constructor_range_stack);\n \n       /* Designator list starts at the level of closest explicit\n \t braces.  */\n@@ -4892,19 +4883,20 @@ set_designator (int array)\n       return 1;\n     }\n \n-  if (TREE_CODE (constructor_type) == RECORD_TYPE\n-      || TREE_CODE (constructor_type) == UNION_TYPE)\n+  switch (TREE_CODE (constructor_type))\n     {\n+    case  RECORD_TYPE:\n+    case  UNION_TYPE:\n       subtype = TREE_TYPE (constructor_fields);\n       if (subtype != error_mark_node)\n \tsubtype = TYPE_MAIN_VARIANT (subtype);\n-    }\n-  else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-    {\n+      break;\n+    case ARRAY_TYPE:\n       subtype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n \n   subcode = TREE_CODE (subtype);\n   if (array && subcode != ARRAY_TYPE)\n@@ -5324,18 +5316,17 @@ set_nonincremental_init_from_string (tree str)\n   const char *p, *end;\n   int byte, wchar_bytes, charwidth, bitpos;\n \n-  if (TREE_CODE (constructor_type) != ARRAY_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (constructor_type) == ARRAY_TYPE);\n \n   if (TYPE_PRECISION (TREE_TYPE (TREE_TYPE (str)))\n       == TYPE_PRECISION (char_type_node))\n     wchar_bytes = 1;\n-  else if (TYPE_PRECISION (TREE_TYPE (TREE_TYPE (str)))\n-\t   == TYPE_PRECISION (wchar_type_node))\n-    wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n   else\n-    abort ();\n-\n+    {\n+      gcc_assert (TYPE_PRECISION (TREE_TYPE (TREE_TYPE (str)))\n+\t\t  == TYPE_PRECISION (wchar_type_node));\n+      wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n+    }\n   charwidth = TYPE_PRECISION (char_type_node);\n   type = TREE_TYPE (constructor_type);\n   p = TREE_STRING_POINTER (str);\n@@ -6077,16 +6068,14 @@ process_init_element (struct c_expr value)\n \t  constructor_range_stack = 0;\n \t  while (constructor_stack != range_stack->stack)\n \t    {\n-\t      if (!constructor_stack->implicit)\n-\t\tabort ();\n+\t      gcc_assert (constructor_stack->implicit);\n \t      process_init_element (pop_init_level (1));\n \t    }\n \t  for (p = range_stack;\n \t       !p->range_end || tree_int_cst_equal (p->index, p->range_end);\n \t       p = p->prev)\n \t    {\n-\t      if (!constructor_stack->implicit)\n-\t\tabort ();\n+\t      gcc_assert (constructor_stack->implicit);\n \t      process_init_element (pop_init_level (1));\n \t    }\n \n@@ -6471,7 +6460,7 @@ c_finish_if_stmt (location_t if_locus, tree cond, tree then_block,\n \t    inner_if = TREE_OPERAND (inner_if, 0);\n \t    break;\n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n     found:\n "}, {"sha": "53446f38ec3101f47b02c20d2a9141dfb91fa36d", "filename": "gcc/caller-save.c", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -160,8 +160,7 @@ init_caller_save (void)\n \t [(int) MODE_BASE_REG_CLASS (regno_save_mode [i][1])], i))\n       break;\n \n-  if (i == FIRST_PSEUDO_REGISTER)\n-    abort ();\n+  gcc_assert (i < FIRST_PSEUDO_REGISTER);\n \n   addr_reg = gen_rtx_REG (Pmode, i);\n \n@@ -381,8 +380,7 @@ save_call_clobbered_regs (void)\n \n       next = chain->next;\n \n-      if (chain->is_caller_save_insn)\n-\tabort ();\n+      gcc_assert (!chain->is_caller_save_insn);\n \n       if (INSN_P (insn))\n \t{\n@@ -431,22 +429,17 @@ save_call_clobbered_regs (void)\n \t\t {\n \t\t   int r = reg_renumber[regno];\n \t\t   int nregs;\n-\n-\t\t   if (r >= 0)\n-\t\t     {\n-\t\t       enum machine_mode mode;\n-\n-\t\t       nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n-\t\t       mode = HARD_REGNO_CALLER_SAVE_MODE\n-\t\t\t        (r, nregs, PSEUDO_REGNO_MODE (regno));\n-\t\t       if (GET_MODE_BITSIZE (mode)\n-\t\t\t   > GET_MODE_BITSIZE (save_mode[r]))\n-\t\t\t save_mode[r] = mode;\n-\t\t       while (nregs-- > 0)\n-\t\t\t SET_HARD_REG_BIT (hard_regs_to_save, r + nregs);\n-\t\t     }\n-\t\t   else\n-\t\t     abort ();\n+\t\t   enum machine_mode mode;\n+\n+\t\t   gcc_assert (r >= 0);\n+\t\t   nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n+\t\t   mode = HARD_REGNO_CALLER_SAVE_MODE\n+\t\t     (r, nregs, PSEUDO_REGNO_MODE (regno));\n+\t\t   if (GET_MODE_BITSIZE (mode)\n+\t\t       > GET_MODE_BITSIZE (save_mode[r]))\n+\t\t     save_mode[r] = mode;\n+\t\t   while (nregs-- > 0)\n+\t\t     SET_HARD_REG_BIT (hard_regs_to_save, r + nregs);\n \t\t });\n \n \t      /* Record all registers set in this call insn.  These don't need\n@@ -650,9 +643,7 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n      or SET_SRC.  Instead of doing so and causing a crash later, check\n      for this common case and abort here instead.  This will remove one\n      step in debugging such problems.  */\n-\n-  if (regno_save_mem[regno][1] == 0)\n-    abort ();\n+  gcc_assert (regno_save_mem[regno][1]);\n \n   /* Get the pattern to emit and update our status.\n \n@@ -725,9 +716,7 @@ insert_save (struct insn_chain *chain, int before_p, int regno,\n      or SET_SRC.  Instead of doing so and causing a crash later, check\n      for this common case and abort here instead.  This will remove one\n      step in debugging such problems.  */\n-\n-  if (regno_save_mem[regno][1] == 0)\n-    abort ();\n+  gcc_assert (regno_save_mem[regno][1]);\n \n   /* Get the pattern to emit and update our status.\n \n@@ -824,9 +813,7 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n \t      rtx reg = XEXP (link, 0);\n \t      int regno, i;\n \n-\t      if (!REG_P (reg))\n-\t\tabort ();\n-\n+\t      gcc_assert (REG_P (reg));\n \t      regno = REGNO (reg);\n \t      if (regno >= FIRST_PSEUDO_REGISTER)\n \t\tregno = reg_renumber[regno];"}, {"sha": "eea4146e16bdb8a2f2b04aea89538ed0e023d94a", "filename": "gcc/calls.c", "status": "modified", "additions": 56, "deletions": 63, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366de0ce7d916d313aba839a2802cfbc70b991cf/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=366de0ce7d916d313aba839a2802cfbc70b991cf", "patch": "@@ -349,7 +349,7 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n     }\n   else\n #endif\n-    abort ();\n+    gcc_unreachable ();\n \n   /* Find the call we just emitted.  */\n   call_insn = last_call_insn ();\n@@ -1158,8 +1158,7 @@ compute_argument_block_size (int reg_parm_stack_space,\n \t  /* We don't handle this case yet.  To handle it correctly we have\n \t     to add the delta, round and subtract the delta.\n \t     Currently no machine description requires this support.  */\n-\t  if (stack_pointer_delta & (preferred_stack_boundary - 1))\n-\t    abort ();\n+\t  gcc_assert (!(stack_pointer_delta & (preferred_stack_boundary - 1)));\n \t  args_size->var = round_up (args_size->var, preferred_stack_boundary);\n \t}\n \n@@ -1225,8 +1224,7 @@ precompute_arguments (int flags, int num_actuals, struct arg_data *args)\n       enum machine_mode mode;\n \n       /* If this is an addressable type, we cannot pre-evaluate it.  */\n-      if (TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)))\n-\tabort ();\n+      gcc_assert (!TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)));\n \n       args[i].initial_value = args[i].value\n \t= expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n@@ -1999,8 +1997,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n   /* Operand 0 is a pointer-to-function; get the type of the function.  */\n   funtype = TREE_TYPE (addr);\n-  if (! POINTER_TYPE_P (funtype))\n-    abort ();\n+  gcc_assert (POINTER_TYPE_P (funtype));\n   funtype = TREE_TYPE (funtype);\n \n   /* Munge the tree to split complex arguments into their imaginary\n@@ -2641,8 +2638,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t now!  */\n \n       /* Stack must be properly aligned now.  */\n-      if (pass && stack_pointer_delta % preferred_unit_stack_boundary)\n-\tabort ();\n+      gcc_assert (!pass\n+\t\t  || !(stack_pointer_delta % preferred_unit_stack_boundary));\n \n       /* Generate the actual call instruction.  */\n       emit_call_1 (funexp, exp, fndecl, funtype, unadjusted_args_size,\n@@ -2754,8 +2751,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t    {\n \t      last = PREV_INSN (last);\n \t      /* There was no CALL_INSN?  */\n-\t      if (last == before_call)\n-\t\tabort ();\n+\t      gcc_assert (last != before_call);\n \t    }\n \n \t  emit_barrier_after (last);\n@@ -2855,36 +2851,36 @@ expand_call (tree exp, rtx target, int ignore)\n \n       if (targetm.calls.promote_function_return(funtype))\n \t{\n-      /* If we promoted this return value, make the proper SUBREG.  TARGET\n-\t might be const0_rtx here, so be careful.  */\n-      if (REG_P (target)\n-\t  && TYPE_MODE (TREE_TYPE (exp)) != BLKmode\n-\t  && GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n-\t{\n-\t  tree type = TREE_TYPE (exp);\n-\t  int unsignedp = TYPE_UNSIGNED (type);\n-\t  int offset = 0;\n-\n-\t  /* If we don't promote as expected, something is wrong.  */\n-\t  if (GET_MODE (target)\n-\t      != promote_mode (type, TYPE_MODE (type), &unsignedp, 1))\n-\t    abort ();\n-\n-\tif ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n-\t    && GET_MODE_SIZE (GET_MODE (target))\n-\t       > GET_MODE_SIZE (TYPE_MODE (type)))\n-\t  {\n-\t    offset = GET_MODE_SIZE (GET_MODE (target))\n-\t\t     - GET_MODE_SIZE (TYPE_MODE (type));\n-\t    if (! BYTES_BIG_ENDIAN)\n-\t      offset = (offset / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t    else if (! WORDS_BIG_ENDIAN)\n-\t      offset %= UNITS_PER_WORD;\n-\t  }\n-\t  target = gen_rtx_SUBREG (TYPE_MODE (type), target, offset);\n-\t  SUBREG_PROMOTED_VAR_P (target) = 1;\n-\t  SUBREG_PROMOTED_UNSIGNED_SET (target, unsignedp);\n-\t}\n+\t  /* If we promoted this return value, make the proper SUBREG.\n+\t     TARGET might be const0_rtx here, so be careful.  */\n+\t  if (REG_P (target)\n+\t      && TYPE_MODE (TREE_TYPE (exp)) != BLKmode\n+\t      && GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n+\t    {\n+\t      tree type = TREE_TYPE (exp);\n+\t      int unsignedp = TYPE_UNSIGNED (type);\n+\t      int offset = 0;\n+\t      enum machine_mode pmode;\n+\t      \n+\t      pmode = promote_mode (type, TYPE_MODE (type), &unsignedp, 1);\n+\t      /* If we don't promote as expected, something is wrong.  */\n+\t      gcc_assert (GET_MODE (target) == pmode);\n+\t      \n+\t      if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n+\t\t  && (GET_MODE_SIZE (GET_MODE (target))\n+\t\t      > GET_MODE_SIZE (TYPE_MODE (type))))\n+\t\t{\n+\t\t  offset = GET_MODE_SIZE (GET_MODE (target))\n+\t\t    - GET_MODE_SIZE (TYPE_MODE (type));\n+\t\t  if (! BYTES_BIG_ENDIAN)\n+\t\t    offset = (offset / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t\t  else if (! WORDS_BIG_ENDIAN)\n+\t\t    offset %= UNITS_PER_WORD;\n+\t\t}\n+\t      target = gen_rtx_SUBREG (TYPE_MODE (type), target, offset);\n+\t      SUBREG_PROMOTED_VAR_P (target) = 1;\n+\t      SUBREG_PROMOTED_UNSIGNED_SET (target, unsignedp);\n+\t    }\n \t}\n \n       /* If size of args is variable or this was a constructor call for a stack\n@@ -2971,10 +2967,9 @@ expand_call (tree exp, rtx target, int ignore)\n \t  normal_call_insns = insns;\n \n \t  /* Verify that we've deallocated all the stack we used.  */\n-\t  if (! (flags & (ECF_NORETURN | ECF_LONGJMP))\n-\t      && old_stack_allocated != stack_pointer_delta\n-\t\t\t\t\t- pending_stack_adjust)\n-\t    abort ();\n+\t  gcc_assert ((flags & (ECF_NORETURN | ECF_LONGJMP))\n+\t\t      || (old_stack_allocated\n+\t\t\t  == stack_pointer_delta - pending_stack_adjust));\n \t}\n \n       /* If something prevents making this a sibling call,\n@@ -3286,6 +3281,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   if (mem_value && struct_value == 0 && ! pcc_struct_value)\n     {\n       rtx addr = XEXP (mem_value, 0);\n+      int partial;\n+      \n       nargs++;\n \n       /* Make sure it is a reasonable operand for a move or push insn.  */\n@@ -3298,8 +3295,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       argvec[count].partial = 0;\n \n       argvec[count].reg = FUNCTION_ARG (args_so_far, Pmode, NULL_TREE, 1);\n-      if (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, Pmode, NULL_TREE, 1))\n-\tabort ();\n+      partial = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, Pmode, NULL_TREE, 1);\n+      gcc_assert (!partial);\n \n       locate_and_pad_parm (Pmode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n@@ -3325,9 +3322,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n       /* We cannot convert the arg value to the mode the library wants here;\n \t must do it earlier where we know the signedness of the arg.  */\n-      if (mode == BLKmode\n-\t  || (GET_MODE (val) != mode && GET_MODE (val) != VOIDmode))\n-\tabort ();\n+      gcc_assert (mode != BLKmode\n+\t\t  && (GET_MODE (val) == mode || GET_MODE (val) == VOIDmode));\n \n       /* Make sure it is a reasonable operand for a move or push insn.  */\n       if (!REG_P (val) && !MEM_P (val)\n@@ -3397,8 +3393,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t\t   argvec[count].partial,\n \t\t\t   NULL_TREE, &args_size, &argvec[count].locate);\n \n-      if (argvec[count].locate.size.var)\n-\tabort ();\n+      gcc_assert (!argvec[count].locate.size.var);\n \n       if (argvec[count].reg == 0 || argvec[count].partial != 0\n \t  || reg_parm_stack_space > 0)\n@@ -3662,8 +3657,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t    ? hard_libcall_value (outmode) : NULL_RTX);\n \n   /* Stack must be properly aligned now.  */\n-  if (stack_pointer_delta & (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1))\n-    abort ();\n+  gcc_assert (!(stack_pointer_delta\n+\t\t& (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1)));\n \n   before_call = get_last_insn ();\n \n@@ -3698,8 +3693,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t{\n \t  last = PREV_INSN (last);\n \t  /* There was no CALL_INSN?  */\n-\t  if (last == before_call)\n-\t    abort ();\n+\t  gcc_assert (last != before_call);\n \t}\n \n       emit_barrier_after (last);\n@@ -3975,11 +3969,10 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n       partial = arg->partial;\n     }\n \n-  if (reg != 0 && partial == 0)\n-    /* Being passed entirely in a register.  We shouldn't be called in\n-       this case.  */\n-    abort ();\n-\n+  /* Being passed entirely in a register.  We shouldn't be called in\n+     this case.  */\n+  gcc_assert (reg == 0 || partial != 0);\n+  \n   /* If this arg needs special alignment, don't load the registers\n      here.  */\n   if (arg->n_aligned_regs != 0)\n@@ -4151,8 +4144,8 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n \n \t      /* expand_call should ensure this.  */\n-\t      if (arg->locate.offset.var || GET_CODE (size_rtx) != CONST_INT)\n-\t\tabort ();\n+\t      gcc_assert (!arg->locate.offset.var\n+\t\t\t  && GET_CODE (size_rtx) == CONST_INT);\n \n \t      if (arg->locate.offset.constant > i)\n \t\t{"}]}