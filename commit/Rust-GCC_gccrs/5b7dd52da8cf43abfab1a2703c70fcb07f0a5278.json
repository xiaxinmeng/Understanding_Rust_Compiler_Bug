{"sha": "5b7dd52da8cf43abfab1a2703c70fcb07f0a5278", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3ZGQ1MmRhOGNmNDNhYmZhYjFhMjcwM2M3MGZjYjA3ZjBhNTI3OA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2008-05-20T12:46:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-20T12:46:19Z"}, "message": "exp_disp.adb (Make_DT, [...]): Avoid generating dispatch tables of locally defined tagged types statically.\n\n2008-05-20  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_disp.adb (Make_DT, Make_Secondary_DT, Make_Tags): Avoid\n\tgenerating dispatch tables of locally defined tagged types statically.\n\tRemove implicit if-statement that is no longer required.\n\t(Expand_Dispatching_Call): If this is a call to an instance of the\n\tgeneric dispatching constructor, the type of the first argument may be\n\ta subtype of Tag, so always use the base type to recognize this case.\n\nFrom-SVN: r135625", "tree": {"sha": "54ffad32940d88a7d6874750a02ba8b6fca7aeac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54ffad32940d88a7d6874750a02ba8b6fca7aeac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b7dd52da8cf43abfab1a2703c70fcb07f0a5278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b7dd52da8cf43abfab1a2703c70fcb07f0a5278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b7dd52da8cf43abfab1a2703c70fcb07f0a5278", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b7dd52da8cf43abfab1a2703c70fcb07f0a5278/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4817e3fbfe0e0268aeb96a7ce845e5e7fb3a6a6"}], "stats": {"total": 97, "additions": 34, "deletions": 63}, "files": [{"sha": "58bd28b2d720285965cb028e5fc6ecbf2177f61f", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 34, "deletions": 63, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b7dd52da8cf43abfab1a2703c70fcb07f0a5278/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b7dd52da8cf43abfab1a2703c70fcb07f0a5278/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=5b7dd52da8cf43abfab1a2703c70fcb07f0a5278", "patch": "@@ -335,8 +335,9 @@ package body Exp_Disp is\n       Loc      : constant Source_Ptr := Sloc (Call_Node);\n       Call_Typ : constant Entity_Id  := Etype (Call_Node);\n \n-      Ctrl_Arg   : constant Node_Id := Controlling_Argument (Call_Node);\n-      Param_List : constant List_Id := Parameter_Associations (Call_Node);\n+      Ctrl_Arg   : constant Node_Id   := Controlling_Argument (Call_Node);\n+      Ctrl_Typ   : constant Entity_Id := Base_Type (Etype (Ctrl_Arg));\n+      Param_List : constant List_Id   := Parameter_Associations (Call_Node);\n \n       Subp            : Entity_Id;\n       CW_Typ          : Entity_Id;\n@@ -416,9 +417,9 @@ package body Exp_Disp is\n       --  This capability of dispatching directly by tag is also needed by the\n       --  implementation of AI-260 (for the generic dispatching constructors).\n \n-      if Etype (Ctrl_Arg) = RTE (RE_Tag)\n+      if Ctrl_Typ = RTE (RE_Tag)\n         or else (RTE_Available (RE_Interface_Tag)\n-                  and then Etype (Ctrl_Arg) = RTE (RE_Interface_Tag))\n+                  and then Ctrl_Typ = RTE (RE_Interface_Tag))\n       then\n          CW_Typ := Class_Wide_Type (Find_Dispatching_Type (Subp));\n \n@@ -427,11 +428,11 @@ package body Exp_Disp is\n       --  there are cases where the controlling type is resolved to a specific\n       --  type (such as for designated types of arguments such as CW'Access).\n \n-      elsif Is_Access_Type (Etype (Ctrl_Arg)) then\n-         CW_Typ := Class_Wide_Type (Designated_Type (Etype (Ctrl_Arg)));\n+      elsif Is_Access_Type (Ctrl_Typ) then\n+         CW_Typ := Class_Wide_Type (Designated_Type (Ctrl_Typ));\n \n       else\n-         CW_Typ := Class_Wide_Type (Etype (Ctrl_Arg));\n+         CW_Typ := Class_Wide_Type (Ctrl_Typ);\n       end if;\n \n       Typ := Root_Type (CW_Typ);\n@@ -619,9 +620,9 @@ package body Exp_Disp is\n       --  interface class-wide type then use it directly. Otherwise, the tag\n       --  must be extracted from the controlling object.\n \n-      if Etype (Ctrl_Arg) = RTE (RE_Tag)\n+      if Ctrl_Typ = RTE (RE_Tag)\n         or else (RTE_Available (RE_Interface_Tag)\n-                  and then Etype (Ctrl_Arg) = RTE (RE_Interface_Tag))\n+                  and then Ctrl_Typ = RTE (RE_Interface_Tag))\n       then\n          Controlling_Tag := Duplicate_Subexpr (Ctrl_Arg);\n \n@@ -643,8 +644,8 @@ package body Exp_Disp is\n \n       --  Ada 2005 (AI-251): Abstract interface class-wide type\n \n-      elsif Is_Interface (Etype (Ctrl_Arg))\n-         and then Is_Class_Wide_Type (Etype (Ctrl_Arg))\n+      elsif Is_Interface (Ctrl_Typ)\n+        and then Is_Class_Wide_Type (Ctrl_Typ)\n       then\n          Controlling_Tag := Duplicate_Subexpr (Ctrl_Arg);\n \n@@ -3175,10 +3176,7 @@ package body Exp_Disp is\n \n          if not Building_Static_DT (Typ) then\n             Set_Ekind (Predef_Prims, E_Variable);\n-            Set_Is_Statically_Allocated (Predef_Prims);\n-\n             Set_Ekind (Iface_DT, E_Variable);\n-            Set_Is_Statically_Allocated (Iface_DT);\n \n          --  Statically allocated dispatch tables and related entities are\n          --  constants.\n@@ -3676,9 +3674,9 @@ package body Exp_Disp is\n \n       --  Local variables\n \n-      Elab_Code          : constant List_Id   := New_List;\n-      Result             : constant List_Id   := New_List;\n-      Tname              : constant Name_Id   := Chars (Typ);\n+      Elab_Code          : constant List_Id := New_List;\n+      Result             : constant List_Id := New_List;\n+      Tname              : constant Name_Id := Chars (Typ);\n       AI                 : Elmt_Id;\n       AI_Tag_Elmt        : Elmt_Id;\n       AI_Tag_Comp        : Elmt_Id;\n@@ -3689,11 +3687,9 @@ package body Exp_Disp is\n       I_Depth            : Nat := 0;\n       Iface_Table_Node   : Node_Id;\n       Name_ITable        : Name_Id;\n-      Name_No_Reg        : Name_Id;\n       Nb_Predef_Prims    : Nat := 0;\n       Nb_Prim            : Nat := 0;\n       New_Node           : Node_Id;\n-      No_Reg             : Node_Id;\n       Num_Ifaces         : Nat := 0;\n       Parent_Typ         : Entity_Id;\n       Prim               : Entity_Id;\n@@ -3903,26 +3899,11 @@ package body Exp_Disp is\n       DT_Ptr  := Node (First_Elmt (Access_Disp_Table (Typ)));\n       Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n \n-      Set_Is_Statically_Allocated (DT);\n-      Set_Is_Statically_Allocated (SSD);\n-      Set_Is_Statically_Allocated (TSD);\n-      Set_Is_Statically_Allocated (Predef_Prims);\n-\n-      --  Generate code to define the boolean that controls registration, in\n-      --  order to avoid multiple registrations for tagged types defined in\n-      --  multiple-called scopes.\n-\n-      Name_No_Reg := New_External_Name (Tname, 'F', Suffix_Index => -1);\n-      No_Reg      := Make_Defining_Identifier (Loc, Name_No_Reg);\n-\n-      Set_Ekind (No_Reg, E_Variable);\n-      Set_Is_Statically_Allocated (No_Reg);\n-\n-      Append_To (Result,\n-         Make_Object_Declaration (Loc,\n-           Defining_Identifier => No_Reg,\n-           Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n-           Expression          => New_Reference_To (Standard_True, Loc)));\n+      Set_Is_Statically_Allocated (DT,  Is_Library_Level_Tagged_Type (Typ));\n+      Set_Is_Statically_Allocated (SSD, Is_Library_Level_Tagged_Type (Typ));\n+      Set_Is_Statically_Allocated (TSD, Is_Library_Level_Tagged_Type (Typ));\n+      Set_Is_Statically_Allocated (Predef_Prims,\n+        Is_Library_Level_Tagged_Type (Typ));\n \n       --  In case of locally defined tagged type we declare the object\n       --  containing the dispatch table by means of a variable. Its\n@@ -4544,7 +4525,8 @@ package body Exp_Disp is\n \n                Name_ITable := New_External_Name (Tname, 'I');\n                ITable      := Make_Defining_Identifier (Loc, Name_ITable);\n-               Set_Is_Statically_Allocated (ITable);\n+               Set_Is_Statically_Allocated (ITable,\n+                 Is_Library_Level_Tagged_Type (Typ));\n \n                --  The table of interfaces is not constant; its slots are\n                --  filled at run-time by the IP routine using attribute\n@@ -5385,19 +5367,10 @@ package body Exp_Disp is\n       --  Skip this action in the following cases:\n       --    1) if Register_Tag is not available.\n       --    2) in No_Run_Time mode.\n-      --    3) if Typ is an abstract interface type (the secondary tags will\n-      --       be registered later in types implementing this interface type).\n-      --    4) if Typ is not defined at the library level (this is required\n+      --    3) if Typ is not defined at the library level (this is required\n       --       to avoid adding concurrency control to the hash table used\n       --       by the run-time to register the tags).\n \n-      --  Generate:\n-      --     if No_Reg then\n-      --        [ Elab_Code ]\n-      --        [ Register_Tag (Dt_Ptr); ]\n-      --        No_Reg := False;\n-      --     end if;\n-\n       if not No_Run_Time_Mode\n         and then Is_Library_Level_Entity (Typ)\n         and then RTE_Available (RE_Register_Tag)\n@@ -5409,15 +5382,9 @@ package body Exp_Disp is\n                New_List (New_Reference_To (DT_Ptr, Loc))));\n       end if;\n \n-      Append_To (Elab_Code,\n-        Make_Assignment_Statement (Loc,\n-          Name       => New_Reference_To (No_Reg, Loc),\n-          Expression => New_Reference_To (Standard_False, Loc)));\n-\n-      Append_To (Result,\n-        Make_Implicit_If_Statement (Typ,\n-          Condition       => New_Reference_To (No_Reg, Loc),\n-          Then_Statements => Elab_Code));\n+      if not Is_Empty_List (Elab_Code) then\n+         Append_List_To (Result, Elab_Code);\n+      end if;\n \n       --  Populate the two auxiliary tables used for dispatching\n       --  asynchronous, conditional and timed selects for synchronized\n@@ -5838,7 +5805,8 @@ package body Exp_Disp is\n             Set_Ekind (Iface_DT_Ptr, E_Constant);\n             Set_Is_Tag (Iface_DT_Ptr);\n             Set_Has_Thunks (Iface_DT_Ptr);\n-            Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+            Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+              Is_Library_Level_Tagged_Type (Typ));\n             Set_Is_True_Constant (Iface_DT_Ptr);\n             Set_Related_Type\n               (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n@@ -5854,7 +5822,8 @@ package body Exp_Disp is\n             Set_Ekind (Iface_DT_Ptr, E_Constant);\n             Set_Is_Tag (Iface_DT_Ptr);\n             Set_Has_Thunks (Iface_DT_Ptr);\n-            Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+            Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+              Is_Library_Level_Tagged_Type (Typ));\n             Set_Is_True_Constant (Iface_DT_Ptr);\n             Set_Related_Type\n               (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n@@ -5869,7 +5838,8 @@ package body Exp_Disp is\n             Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n             Set_Ekind (Iface_DT_Ptr, E_Constant);\n             Set_Is_Tag (Iface_DT_Ptr);\n-            Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+            Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+              Is_Library_Level_Tagged_Type (Typ));\n             Set_Is_True_Constant (Iface_DT_Ptr);\n             Set_Related_Type\n               (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n@@ -5883,7 +5853,8 @@ package body Exp_Disp is\n             Set_Etype (Iface_DT_Ptr, RTE (RE_Address));\n             Set_Ekind (Iface_DT_Ptr, E_Constant);\n             Set_Is_Tag (Iface_DT_Ptr);\n-            Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+            Set_Is_Statically_Allocated (Iface_DT_Ptr,\n+              Is_Library_Level_Tagged_Type (Typ));\n             Set_Is_True_Constant (Iface_DT_Ptr);\n             Set_Related_Type\n               (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));"}]}