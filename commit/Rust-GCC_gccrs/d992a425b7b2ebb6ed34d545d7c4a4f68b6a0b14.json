{"sha": "d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk5MmE0MjViN2IyZWJiNmVkMzRkNTQ1ZDdjNGE0ZjY4YjZhMGIxNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-22T13:09:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-22T13:09:47Z"}, "message": "[multiple changes]\n\n2015-05-22  Bob Duff  <duff@adacore.com>\n\n\t* a-convec.ads, a-convec.adb (Append): Check for fast path. Split\n\tout slow path into separate procedure. Inline Append. Fast path\n\tnow avoids calling Insert.\n\t(Finalize): Do the busy checking last, so the container gets emptied.\n\t(Insert, Insert_Space): Remove redundancy.\n\n2015-05-22  Robert Dewar  <dewar@adacore.com>\n\n\t* switch-c.adb (Scan_Front_End_Switches): Insist on -gnatc\n\tfor -gnatd.V.\n\nFrom-SVN: r223567", "tree": {"sha": "fc1306500493f77a2f3b51c5218b669874314121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc1306500493f77a2f3b51c5218b669874314121"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/comments", "author": null, "committer": null, "parents": [{"sha": "84238eb02a86bb7b3c458b5914c849df82fa9aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84238eb02a86bb7b3c458b5914c849df82fa9aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84238eb02a86bb7b3c458b5914c849df82fa9aad"}], "stats": {"total": 166, "additions": 118, "deletions": 48}, "files": [{"sha": "15dc2189fe7adef3c89a9303daf3ab83c9c4fd5d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14", "patch": "@@ -1,3 +1,16 @@\n+2015-05-22  Bob Duff  <duff@adacore.com>\n+\n+\t* a-convec.ads, a-convec.adb (Append): Check for fast path. Split\n+\tout slow path into separate procedure. Inline Append. Fast path\n+\tnow avoids calling Insert.\n+\t(Finalize): Do the busy checking last, so the container gets emptied.\n+\t(Insert, Insert_Space): Remove redundancy.\n+\n+2015-05-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* switch-c.adb (Scan_Front_End_Switches): Insist on -gnatc\n+\tfor -gnatd.V.\n+\n 2015-05-22  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnatvsn.ads: Minor code reorg to remember more easily to update"}, {"sha": "bf7c08b23ba4aa07515bf6ddab06034c9682924b", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 87, "deletions": 43, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14", "patch": "@@ -59,6 +59,13 @@ package body Ada.Containers.Vectors is\n      (Object   : Iterator;\n       Position : Cursor) return Cursor;\n \n+   procedure Append_Slow_Path\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type);\n+   --  This is the slow path for Append. This is split out to minimize the size\n+   --  of Append, because we have Inline (Append).\n+\n    ---------\n    -- \"&\" --\n    ---------\n@@ -91,7 +98,7 @@ package body Ada.Containers.Vectors is\n             Elements : constant Elements_Access :=\n                          new Elements_Type'(Right.Last, RE);\n          begin\n-            return (Controlled with Elements, Right.Last, 0, 0);\n+            return (Controlled with Elements, Right.Last, others => <>);\n          end;\n       end if;\n \n@@ -102,7 +109,7 @@ package body Ada.Containers.Vectors is\n             Elements : constant Elements_Access :=\n                          new Elements_Type'(Left.Last, LE);\n          begin\n-            return (Controlled with Elements, Left.Last, 0, 0);\n+            return (Controlled with Elements, Left.Last, others => <>);\n          end;\n \n       end if;\n@@ -129,7 +136,7 @@ package body Ada.Containers.Vectors is\n       --  exceed Index_Type'Last. We use the wider of Index_Type'Base and\n       --  Count_Type'Base as the type for intermediate values.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n@@ -202,7 +209,7 @@ package body Ada.Containers.Vectors is\n          Elements : constant Elements_Access :=\n                       new Elements_Type'(Last, LE & RE);\n       begin\n-         return (Controlled with Elements, Last, 0, 0);\n+         return (Controlled with Elements, Last, others => <>);\n       end;\n    end \"&\";\n \n@@ -223,7 +230,7 @@ package body Ada.Containers.Vectors is\n                  EA   => (others => Right));\n \n          begin\n-            return (Controlled with Elements, Index_Type'First, 0, 0);\n+            return (Controlled with Elements, Index_Type'First, others => <>);\n          end;\n       end if;\n \n@@ -248,7 +255,7 @@ package body Ada.Containers.Vectors is\n          Elements : constant Elements_Access :=\n                       new Elements_Type'(Last => Last, EA => LE & Right);\n       begin\n-         return (Controlled with Elements, Last, 0, 0);\n+         return (Controlled with Elements, Last, others => <>);\n       end;\n    end \"&\";\n \n@@ -268,7 +275,7 @@ package body Ada.Containers.Vectors is\n                 (Last => Index_Type'First,\n                  EA   => (others => Left));\n          begin\n-            return (Controlled with Elements, Index_Type'First, 0, 0);\n+            return (Controlled with Elements, Index_Type'First, others => <>);\n          end;\n       end if;\n \n@@ -298,7 +305,7 @@ package body Ada.Containers.Vectors is\n               EA   => Left & RE);\n \n       begin\n-         return (Controlled with Elements, Last, 0, 0);\n+         return (Controlled with Elements, Last, others => <>);\n       end;\n    end \"&\";\n \n@@ -328,7 +335,7 @@ package body Ada.Containers.Vectors is\n               EA   => (Left, Right));\n \n       begin\n-         return (Controlled with Elements, Last, 0, 0);\n+         return (Controlled with Elements, Last, others => <>);\n       end;\n    end \"&\";\n \n@@ -456,6 +463,45 @@ package body Ada.Containers.Vectors is\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    is\n+   begin\n+      --  In the general case, we pass the buck to Insert, but for efficiency,\n+      --  we check for the usual case where Count = 1 and the vector has enough\n+      --  room for at least one more element.\n+\n+      if Count = 1\n+        and then Container.Elements /= null\n+        and then Container.Last /= Container.Elements.Last\n+      then\n+         if Container.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (vector is busy)\";\n+         end if;\n+\n+         --  Increment Container.Last after assigning the New_Item, so we\n+         --  leave the Container unmodified in case Finalize/Adjust raises\n+         --  an exception.\n+\n+         declare\n+            New_Last : constant Index_Type := Container.Last + 1;\n+         begin\n+            Container.Elements.EA (New_Last) := New_Item;\n+            Container.Last := New_Last;\n+         end;\n+\n+      else\n+         Append_Slow_Path (Container, New_Item, Count);\n+      end if;\n+   end Append;\n+\n+   ----------------------\n+   -- Append_Slow_Path --\n+   ----------------------\n+\n+   procedure Append_Slow_Path\n+     (Container : in out Vector;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n+   is\n    begin\n       if Count = 0 then\n          return;\n@@ -464,7 +510,7 @@ package body Ada.Containers.Vectors is\n       else\n          Insert (Container, Container.Last + 1, New_Item, Count);\n       end if;\n-   end Append;\n+   end Append_Slow_Path;\n \n    ------------\n    -- Assign --\n@@ -705,7 +751,7 @@ package body Ada.Containers.Vectors is\n       --  index value New_Last is the last index value of their new home, and\n       --  index value J is the first index of their old home.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          New_Last := Old_Last - Index_Type'Base (Count);\n          J := Index + Index_Type'Base (Count);\n       else\n@@ -814,7 +860,7 @@ package body Ada.Containers.Vectors is\n       if Count >= Container.Length then\n          Container.Last := No_Index;\n \n-      elsif Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      elsif Index_Type'Base'Last >= Count_Type_Last then\n          Container.Last := Container.Last - Index_Type'Base (Count);\n \n       else\n@@ -858,14 +904,14 @@ package body Ada.Containers.Vectors is\n       X : Elements_Access := Container.Elements;\n \n    begin\n+      Container.Elements := null;\n+      Container.Last := No_Index;\n+\n+      Free (X);\n+\n       if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (vector is busy)\";\n-\n-      else\n-         Container.Elements := null;\n-         Container.Last := No_Index;\n-         Free (X);\n       end if;\n    end Finalize;\n \n@@ -1334,7 +1380,7 @@ package body Ada.Containers.Vectors is\n       --  deeper flaw in the caller's algorithm, so that case is treated as a\n       --  proper error.)\n \n-      if Before > Container.Last and then Before > Container.Last + 1 then\n+      if Before > Container.Last + 1 then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n       end if;\n@@ -1367,7 +1413,7 @@ package body Ada.Containers.Vectors is\n       --  compare the new length to the maximum length. If the new length is\n       --  acceptable, then we compute the new last index from that.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n@@ -1402,9 +1448,8 @@ package body Ada.Containers.Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            if Index_Type'Last - No_Index >=\n-                 Count_Type'Pos (Count_Type'Last)\n-            then\n+            if Index_Type'Last - No_Index >= Count_Type_Last then\n+\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1469,7 +1514,7 @@ package body Ada.Containers.Vectors is\n       --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to\n       --  compute its value from the New_Length.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          New_Last := No_Index + Index_Type'Base (New_Length);\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n@@ -1537,7 +1582,7 @@ package body Ada.Containers.Vectors is\n                --  new home. We use the wider of Index_Type'Base and\n                --  Count_Type'Base as the type for intermediate index values.\n \n-               if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+               if Index_Type'Base'Last >= Count_Type_Last then\n                   Index := Before + Index_Type'Base (Count);\n                else\n                   Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n@@ -1583,7 +1628,7 @@ package body Ada.Containers.Vectors is\n       --  We have computed the length of the new internal array (and this is\n       --  what \"vector capacity\" means), so use that to compute its last index.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n       else\n          Dst_Last :=\n@@ -1616,7 +1661,7 @@ package body Ada.Containers.Vectors is\n             --  The new items are being inserted before some existing elements,\n             --  so we must slide the existing elements up to their new home.\n \n-            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+            if Index_Type'Base'Last >= Count_Type_Last then\n                Index := Before + Index_Type'Base (Count);\n             else\n                Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n@@ -1679,7 +1724,7 @@ package body Ada.Containers.Vectors is\n       --  We calculate the last index value of the destination slice using the\n       --  wider of Index_Type'Base and count_Type'Base.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          J := (Before - 1) + Index_Type'Base (N);\n       else\n          J := Index_Type'Base (Count_Type'Base (Before - 1) + N);\n@@ -1722,7 +1767,7 @@ package body Ada.Containers.Vectors is\n          --  equals Index_Type'First, then this first source slice will be\n          --  empty, which is harmless.)\n \n-         if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         if Index_Type'Base'Last >= Count_Type_Last then\n             K := L + Index_Type'Base (Src'Length);\n          else\n             K := Index_Type'Base (Count_Type'Base (L) + Src'Length);\n@@ -1765,7 +1810,7 @@ package body Ada.Containers.Vectors is\n          --  destination that receives this slice of the source. (For the\n          --  reasons given above, this slice is guaranteed to be non-empty.)\n \n-         if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+         if Index_Type'Base'Last >= Count_Type_Last then\n             K := F - Index_Type'Base (Src'Length);\n          else\n             K := Index_Type'Base (Count_Type'Base (F) - Src'Length);\n@@ -1996,7 +2041,7 @@ package body Ada.Containers.Vectors is\n       --  deeper flaw in the caller's algorithm, so that case is treated as a\n       --  proper error.)\n \n-      if Before > Container.Last and then Before > Container.Last + 1 then\n+      if Before > Container.Last + 1 then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n       end if;\n@@ -2029,7 +2074,7 @@ package body Ada.Containers.Vectors is\n       --  compare the new length to the maximum length. If the new length is\n       --  acceptable, then we compute the new last index from that.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n@@ -2064,9 +2109,8 @@ package body Ada.Containers.Vectors is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            if Index_Type'Last - No_Index >=\n-                 Count_Type'Pos (Count_Type'Last)\n-            then\n+            if Index_Type'Last - No_Index >= Count_Type_Last then\n+\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -2131,7 +2175,7 @@ package body Ada.Containers.Vectors is\n       --  insertion.  Use the wider of Index_Type'Base and Count_Type'Base to\n       --  compute its value from the New_Length.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          New_Last := No_Index + Index_Type'Base (New_Length);\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n@@ -2192,7 +2236,7 @@ package body Ada.Containers.Vectors is\n                --  home. We use the wider of Index_Type'Base and\n                --  Count_Type'Base as the type for intermediate index values.\n \n-               if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+               if Index_Type'Base'Last >= Count_Type_Last then\n                   Index := Before + Index_Type'Base (Count);\n \n                else\n@@ -2238,7 +2282,7 @@ package body Ada.Containers.Vectors is\n       --  We have computed the length of the new internal array (and this is\n       --  what \"vector capacity\" means), so use that to compute its last index.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n          Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n       else\n          Dst_Last :=\n@@ -2269,7 +2313,7 @@ package body Ada.Containers.Vectors is\n             --  The space is being inserted before some existing elements, so\n             --  we must slide the existing elements up to their new home.\n \n-            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+            if Index_Type'Base'Last >= Count_Type_Last then\n                Index := Before + Index_Type'Base (Count);\n             else\n                Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n@@ -3011,7 +3055,7 @@ package body Ada.Containers.Vectors is\n       --  the Last index value of the new internal array, in a way that avoids\n       --  any possibility of overflow.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n@@ -3528,7 +3572,7 @@ package body Ada.Containers.Vectors is\n       --  index).  We must therefore check whether the specified Length would\n       --  create a Last index value greater than Index_Type'Last.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n@@ -3595,7 +3639,7 @@ package body Ada.Containers.Vectors is\n \n       Elements := new Elements_Type (Last);\n \n-      return Vector'(Controlled with Elements, Last, 0, 0);\n+      return Vector'(Controlled with Elements, Last, others => <>);\n    end To_Vector;\n \n    function To_Vector\n@@ -3618,7 +3662,7 @@ package body Ada.Containers.Vectors is\n       --  index). We must therefore check whether the specified Length would\n       --  create a Last index value greater than Index_Type'Last.\n \n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+      if Index_Type'Base'Last >= Count_Type_Last then\n \n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n@@ -3685,7 +3729,7 @@ package body Ada.Containers.Vectors is\n \n       Elements := new Elements_Type'(Last, EA => (others => New_Item));\n \n-      return Vector'(Controlled with Elements, Last, 0, 0);\n+      return Vector'(Controlled with Elements, Last, others => <>);\n    end To_Vector;\n \n    --------------------"}, {"sha": "fb801b8aaaed76ad974f625a2b260dddc22fab8f", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14", "patch": "@@ -352,6 +352,7 @@ package Ada.Containers.Vectors is\n \n private\n \n+   pragma Inline (Append);\n    pragma Inline (First_Index);\n    pragma Inline (Last_Index);\n    pragma Inline (Element);\n@@ -368,24 +369,23 @@ private\n    type Elements_Array is array (Index_Type range <>) of aliased Element_Type;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   type Elements_Type (Last : Index_Type) is limited record\n+   type Elements_Type (Last : Extended_Index) is limited record\n       EA : Elements_Array (Index_Type'First .. Last);\n    end record;\n \n-   type Elements_Access is access Elements_Type;\n+   type Elements_Access is access all Elements_Type;\n \n    use Ada.Finalization;\n    use Ada.Streams;\n \n    type Vector is new Controlled with record\n-      Elements : Elements_Access;\n+      Elements : Elements_Access := null;\n       Last     : Extended_Index := No_Index;\n       Busy     : Natural := 0;\n       Lock     : Natural := 0;\n    end record;\n \n    overriding procedure Adjust (Container : in out Vector);\n-\n    overriding procedure Finalize (Container : in out Vector);\n \n    procedure Write\n@@ -495,6 +495,10 @@ private\n \n    No_Element   : constant Cursor := Cursor'(null, Index_Type'First);\n \n-   Empty_Vector : constant Vector := (Controlled with null, No_Index, 0, 0);\n+   Empty_Vector : constant Vector := (Controlled with others => <>);\n+\n+   Count_Type_Last : constant := Count_Type'Last;\n+   --  Count_Type'Last as a universal_integer, so we can compare Index_Type\n+   --  values against this without type conversions that might overflow.\n \n end Ada.Containers.Vectors;"}, {"sha": "c3ebbaab332884eaf4fdc58faff549ba15333fe9", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=d992a425b7b2ebb6ed34d545d7c4a4f68b6a0b14", "patch": "@@ -387,6 +387,15 @@ package body Switch.C is\n                            Osint.Fail\n                              (\"-gnatd.b must be first if combined \"\n                               & \"with other switches\");\n+\n+                        --  Special check, -gnatd.V must occur after -gnatc\n+\n+                        elsif C = 'V'\n+                          and then Operating_Mode /= Check_Semantics\n+                        then\n+                           Osint.Fail\n+                             (\"gnatd.V requires previous occurrence \"\n+                              & \"of -gnatc\");\n                         end if;\n \n                      --  Not a dotted flag"}]}