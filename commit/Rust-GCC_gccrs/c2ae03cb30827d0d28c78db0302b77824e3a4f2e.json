{"sha": "c2ae03cb30827d0d28c78db0302b77824e3a4f2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJhZTAzY2IzMDgyN2QwZDI4Yzc4ZGIwMzAyYjc3ODI0ZTNhNGYyZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-05T20:13:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-05T20:13:59Z"}, "message": "pa.h (FIXED_REGISTERS): %r2 is no longer fixed.\n\n        * pa.h (FIXED_REGISTERS): %r2 is no longer fixed.\n        (REG_ALLOC_ORDER): Treat %r2 as a caller-saved allocatable\n        register.  %r30 is fixed and therefore a \"special\" register.\n        %fr22-%fr31 are caller-saved, so allocate them before the\n        callee-saved 1.1 fp registers.  Allocate fp registers before\n        general registers.  Fix typo for register 79.\n\n        * pa.h (FIRST_PSEUDO_REGISTER): Update to take into account\n        registers which are no longer known to the compiler.\n        (FIXED_REGISTERS): Likewise.\n        (CALL_USED_REGISTERS): Likewise.\n        (HARD_REGNO_NREGS): Likewise.\n        (HARD_REGNO_MODE_OK): Likewise.\n        (REGNO_REG_CLASS): Likewise.\n        (FUNCTION_VALUE): Likewise.\n        (LIBCALL_VALUE): Likewise.\n        (FUNCTION_VALUE_REGNO_P): Likewise.\n        (FUNCTION_ARG_REGNO_P): Likewise.\n        (FUNCTION_ARG): Likewise.\n        (REGNO_OK_FOR_FP_P): Likewise.\n        (REGISTER_NAMES): Likewise.\n        (REG_CLASS_CONTENTS): Likewise.  Add %r1 to GENERAL_OR_FP_REGS\n        and GENERAL_OR_SNAKE_FP_REGS.\n        (REG_ALLOC_ORDER): Likewise.  Document and make allocation order\n        \"regular\" across 1.0 and 1.1 cpus.\n\nFrom-SVN: r3659", "tree": {"sha": "32260a4604966f70f8da85519b40c30a2f6dde8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32260a4604966f70f8da85519b40c30a2f6dde8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2ae03cb30827d0d28c78db0302b77824e3a4f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ae03cb30827d0d28c78db0302b77824e3a4f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ae03cb30827d0d28c78db0302b77824e3a4f2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ae03cb30827d0d28c78db0302b77824e3a4f2e/comments", "author": null, "committer": null, "parents": [{"sha": "00b4e148ffba89302141d135c4d1493da1fb9432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b4e148ffba89302141d135c4d1493da1fb9432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00b4e148ffba89302141d135c4d1493da1fb9432"}], "stats": {"total": 125, "additions": 64, "deletions": 61}, "files": [{"sha": "08549d5c0d3c8afdb414a396df83cc6dd7c44d92", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ae03cb30827d0d28c78db0302b77824e3a4f2e/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ae03cb30827d0d28c78db0302b77824e3a4f2e/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=c2ae03cb30827d0d28c78db0302b77824e3a4f2e", "patch": "@@ -235,7 +235,7 @@ extern int target_flags;\n    has different fp units: define separate register sets for the 1.0\n    and 1.1 fp units. */\n \n-#define FIRST_PSEUDO_REGISTER 113  /* 32 + 16 1.0 regs + 64 1.1 regs + */\n+#define FIRST_PSEUDO_REGISTER 101  /* 32 + 12 1.0 regs + 56 1.1 regs + */\n \t\t\t\t   /* 1 shift reg */\n \n /* 1 for registers that have pervasive standard uses\n@@ -258,7 +258,7 @@ extern int target_flags;\n    Reg 30\t= stack pointer\n    Reg 31\t= Temporary/Millicode Return Pointer (hp)\n \n-   Freg 0-3\t= Status Registers\n+   Freg 0-3\t= Status Registers\t -- Not known to the compiler.\n    Freg 4-7\t= Arguments/Return Value\n    Freg 8-11\t= Temporary Registers\n    Freg 12-15\t= Preserved Registers\n@@ -267,27 +267,24 @@ extern int target_flags;\n \n    On the Snake, fp regs are\n \n-   Freg 0-3\t= Status Registers\n+   Freg 0-3\t= Status Registers\t-- Not known to the compiler.\n    Freg 4L-7R\t= Arguments/Return Value\n    Freg 8L-11R\t= Temporary Registers\n-   Freg 12L-15R\t= Preserved Registers\n-\n-   Freg 16L-31R\t= ?? Some partition of temporary and preserved; assume\n-   preserved for now.\n+   Freg 12L-21R\t= Preserved Registers\n+   Freg 22L-31R = Temporary Registers\n    \n \n */\n \n #define FIXED_REGISTERS  \\\n- {0, 0, 1, 0, 1, 0, 0, 0, \\\n+ {0, 0, 0, 0, 1, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 1, 0, 0, 1, 0, \\\n   /* 1.0 fp registers */ \\\n-  1, 1, 1, 1, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   /* 1.1 fp registers */ \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n@@ -309,12 +306,11 @@ extern int target_flags;\n   0, 0, 0, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n   /* 1.0 fp registers */ \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, \\\n   1, 1, 1, 1, 0, 0, 0, 0, \\\n   /* 1.1 fp registers */ \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 1, 1, 1, 1, \\\n@@ -362,28 +358,32 @@ extern int target_flags;\n    the number of registers that need to be saved (as call used\n    registers will generally not be allocated across a call).\n \n-   It is possible that it would be wise to allocate the floating point\n-   registers before the regular ones, but I doubt it matters.  Same\n-   comment for parameters versus normal.  */\n+   Experimentation has shown slightly better results by allocating\n+   FP registers first.  */\n \n #define REG_ALLOC_ORDER \\\n- {19, 20, 21, 22, 23, 24, 25, 26,\t\\\n-  27, 28, 29, 30, 31, 40, 41, 42,\t\\\n-  43, 36, 37, 38, 39,\t\t\t\\\n-  56, 57, 58, 59, 60, 61, 62, 63, \t\\\n-  64, 65, 66, 67, 68, 69, 70, 71, \t\\\n-  72, 73, 74, 75, 76, 77, 78, 79, \t\\\n-  80, 81, 82, 83, 84, 85, 86, 87, \t\\\n-  88, 89, 90, 91, 92, 93, 94, 95, \t\\\n-  96, 97, 98, 99, 100, 101, 102, 103, \t\\\n-  104, 105, 106, 107, 108, 109, 110, 111,\\\n-   3, 5,  6,  7,\t\t\t\\\n-   8,  9, 10, 11, 12, 13, 14, 15,\t\\\n-  16, 17, 18, 44, 45, 46, 47,\t\t\\\n-  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n-     1,\t\\\n-   2, 4, 32, 33, 34, 35,  0,\t\t\\\n-   112}\n+  /* 1.0 caller-saved fp regs.  */\t\\\n+ {36, 37, 38, 39, 32, 33, 34, 35,\t\\\n+  /* 1.1 caller-saved fp regs.  */\t\\\n+  52, 53, 54, 55, 56, 57, 58, 59, \t\\\n+  80, 81, 82, 83, 84, 85, 86, 87,\t\\\n+  88, 89, 90, 91, 92, 93, 94, 95,\t\\\n+  96, 97, 98, 99,\t\t\t\\\n+  44, 45, 46, 47, 48, 49, 50, 51, \t\\\n+  /* caller-saved general regs.  */\t\\\n+  19, 20, 21, 22, 23, 24, 25, 26,\t\\\n+  27, 28, 29, 31,  2,\t\t\t\\\n+  /* 1.0 callee-saved fp regs.  */\t\\\n+  40, 41, 42, 43,\t\t\t\\\n+  /* 1.1 callee-saved fp regs.  */\t\\\n+  60, 61, 62, 63, 64, 65, 66, 67, \t\\\n+  68, 69, 70, 71, 72, 73, 74, 75, \t\\\n+  76, 77, 78, 79, \t\t\t\\\n+  /* callee-saved general regs.  */\t\\\n+   3,  5,  6,  7,  8,  9, 10, 11,\t\\\n+  12, 13, 14, 15, 16, 17, 18,\t\t\\\n+  /* special registers.  */\t\t\\\n+   1,  4, 30,  0, 100}\n \n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -395,7 +395,7 @@ extern int target_flags;\n    The floating point registers are 64 bits wide. Snake fp regs are 32\n    bits wide */\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  (((REGNO) < 32 || (REGNO) >= 48)\t\\\n+  (((REGNO) < 32 || (REGNO) >= 44)\t\\\n    ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) : 1)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n@@ -404,7 +404,7 @@ extern int target_flags;\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n    : (REGNO) < 32 ? ((GET_MODE_SIZE (MODE) <= 4) ? 1 : ((REGNO) & 1) == 0)\\\n-   : (REGNO) < 48 ? (GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n+   : (REGNO) < 44 ? (GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n    : (GET_MODE_SIZE (MODE) > 4 ? ((REGNO) & 1) == 0\t\t\t\\\n       : 1))\n \n@@ -508,14 +508,14 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n { {0, 0, 0, 0},\t\t\t/* NO_REGS */\t\t\\\n   {0x2, 0, 0, 0},\t\t/* R1_REGS */\t\t\\\n   {-2, 0, 0, 0},\t\t/* GENERAL_REGS */\t\\\n-  {0, 0xffff, 0, 0},\t\t/* FP_REGS */\t\t\\\n-  {-2, 0xffff, 0, 0},\t\t/* GENERAL_OR_FP_REGS */\\\n-  {0, 0, 0xffff0000, 0xffff},\t/* HI_SNAKE_FP_REGS */\t\\\n-  {0, 0xffff0000, ~0, 0xffff},\t/* SNAKE_FP_REGS */\t\\\n-  {-2, 0xffff0000, ~0, 0xffff},\t/* GENERAL_OR_SNAKE_FP_REGS */\\\n-  {0, ~0, ~0, 0xffff},\t\t/* FP_OR_SNAKE_FP_REGS */\\\n-  {0, 0, 0, 0x10000},\t\t/* SHIFT_REGS */\t\\\n-  {-2, ~0, ~0, 0x1ffff}}\t/* ALL_REGS */\n+  {0, 0xfff, 0, 0},\t\t/* FP_REGS */\t\t\\\n+  {-2, 0xfff, 0, 0},\t\t/* GENERAL_OR_FP_REGS */\\\n+  {0, 0, 0xfffffff0, 0xf},\t/* HI_SNAKE_FP_REGS */\t\\\n+  {0, 0xfffff000, ~0, 0xf},\t/* SNAKE_FP_REGS */\t\\\n+  {-2, 0xfffff000, ~0, 0xf},\t/* GENERAL_OR_SNAKE_FP_REGS */\\\n+  {0, ~0, ~0, 0xf},\t\t/* FP_OR_SNAKE_FP_REGS */\\\n+  {0, 0, 0, 0x10},\t\t/* SHIFT_REGS */\t\\\n+  {-2, ~0, ~0, 0x1f}}\t\t/* ALL_REGS */\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -526,9 +526,9 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n   ((REGNO) == 0 ? NO_REGS \t\t\\\n    : (REGNO) == 1 ? R1_REGS\t\t\\\n    : (REGNO) < 32 ? GENERAL_REGS\t\\\n-   : (REGNO) < 48 ? FP_REGS\t\t\\\n-   : (REGNO) < 80 ? SNAKE_FP_REGS\t\\\n-   : (REGNO) < 112 ? HI_SNAKE_FP_REGS\t\\\n+   : (REGNO) < 44 ? FP_REGS\t\t\\\n+   : (REGNO) < 68 ? SNAKE_FP_REGS\t\\\n+   : (REGNO) < 100 ? HI_SNAKE_FP_REGS\t\\\n    : SHIFT_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n@@ -684,13 +684,13 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    otherwise, FUNC is 0.  */\n \n /* On the HP-PA the value is found in register(s) 28(-29), unless\n-   the mode is SF or DF. Then the value is returned in fr4 (36, ) */\n+   the mode is SF or DF. Then the value is returned in fr4 (32, ) */\n \n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n   gen_rtx (REG, TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\\\n \t\t\t\t       TYPE_MODE (VALTYPE) == DFmode) ? \\\n-\t\t\t\t      (TARGET_SNAKE ? 56 : 36) : 28))\n+\t\t\t\t      (TARGET_SNAKE ? 44 : 32) : 28))\n \n #define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n   FUNCTION_VALUE(VALTYPE, FUNC)\n@@ -700,18 +700,18 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n \n #define LIBCALL_VALUE(MODE) \\\n   gen_rtx (REG, MODE, (MODE == SFmode || MODE == DFmode ?\\\n-\t\t       (TARGET_SNAKE ? 56 : 36) : 28))\n+\t\t       (TARGET_SNAKE ? 44 : 32) : 28))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n \n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 28 || (N) == 36 || (N) == 56)\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 28 || (N) == 32 || (N) == 44)\n \n /* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(N) (((N) >= 23 && (N) <= 26) || \\\n-\t\t\t\t ((N) >= 36 && (N) <= 39) || \\\n-\t\t\t\t ((N) >= 56 && (N) <= 63))\n+\t\t\t\t ((N) >= 32 && (N) <= 35) || \\\n+\t\t\t\t ((N) >= 44 && (N) <= 51))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -772,11 +772,11 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n \t      (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\t\\\n \t       ? ((MODE) == DFmode\t\t\t\t\t\\\n-\t\t  ? ((CUM) ? (TARGET_SNAKE ? 62 : 39)\t\t\t\\\n-\t\t     : (TARGET_SNAKE ? 58 : 37))\t\t\t\\\n+\t\t  ? ((CUM) ? (TARGET_SNAKE ? 50 : 35)\t\t\t\\\n+\t\t     : (TARGET_SNAKE ? 46 : 33))\t\t\t\\\n \t\t  : ((CUM) ? 23 : 25))\t\t\t\t\t\\\n \t       : ((MODE) == SFmode\t\t\t\t\t\\\n-\t\t  ? (TARGET_SNAKE ? 56 + 2 * (CUM) : 36  + (CUM))\t\\\n+\t\t  ? (TARGET_SNAKE ? 44 + 2 * (CUM) : 32  + (CUM))\t\\\n \t\t  : (27 - (CUM) - FUNCTION_ARG_SIZE ((MODE), (TYPE))))))\\\n    : 0)\n \n@@ -997,8 +997,8 @@ extern union tree_node *current_function_decl;\n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n   ((REGNO) && ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32))\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n-  (((REGNO) >= 32 && (REGNO) <= 111)\\\n-   || (reg_renumber[REGNO] >= 32 && reg_renumber[REGNO] <= 111))\n+  (((REGNO) >= 32 && (REGNO) <= 99)\\\n+   || (reg_renumber[REGNO] >= 32 && reg_renumber[REGNO] <= 99))\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.\n@@ -1483,9 +1483,8 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n  \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\",\t\t\\\n  \"%r16\", \"%r17\", \"%r18\", \"%r19\", \"%r20\", \"%r21\", \"%r22\", \"%r23\",\t\\\n  \"%r24\", \"%r25\", \"%r26\", \"%r27\", \"%r28\", \"%r29\", \"%r30\", \"%r31\",\t\\\n- \"%fr0\", \"%fr1\", \"%fr2\", \"%fr3\", \"%fr4\", \"%fr5\", \"%fr6\", \"%fr7\",\t\\\n+ \"%fr4\", \"%fr5\", \"%fr6\", \"%fr7\",\t\\\n  \"%fr8\", \"%fr9\", \"%fr10\", \"%fr11\", \"%fr12\", \"%fr13\", \"%fr14\", \"%fr15\",\t\\\n- \"%fr0\", \"%fr0R\", \"%fr1\", \"%fr1R\", \"%fr2\", \"%fr2R\", \"%fr3\", \"%fr3R\",\t\\\n  \"%fr4\", \"%fr4R\", \"%fr5\", \"%fr5R\", \"%fr6\", \"%fr6R\", \"%fr7\", \"%fr7R\",\t\\\n  \"%fr8\", \"%fr8R\", \"%fr9\", \"%fr9R\", \"%fr10\", \"%fr10R\", \"%fr11\", \"%fr11R\",\\\n  \"%fr12\", \"%fr12R\", \"%fr13\", \"%fr13R\", \"%fr14\", \"%fr14R\", \"%fr15\", \"%fr15R\",\\\n@@ -1594,9 +1593,13 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n /* This is how to output an assembler line defining an `int' constant.  */\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n+{ fprintf (FILE, \"\\t.word \");\t\t\t\\\n+  if (TARGET_SHARED_LIBS\t\t\t\\\n+      && function_label_operand (VALUE, VOIDmode)\\\n+      && in_section != in_text)\t\t\t\\\n+    fprintf (FILE, \"P%%\");\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\\\n+  fprintf (FILE, \"\\n\");}\n \n /* Likewise for `short' and `char' constants.  */\n "}]}