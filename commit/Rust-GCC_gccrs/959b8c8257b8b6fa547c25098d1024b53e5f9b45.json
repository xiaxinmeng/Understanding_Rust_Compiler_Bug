{"sha": "959b8c8257b8b6fa547c25098d1024b53e5f9b45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU5YjhjODI1N2I4YjZmYTU0N2MyNTA5OGQxMDI0YjUzZTVmOWI0NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-12-24T01:37:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-12-24T01:37:44Z"}, "message": "ipa-utils.c (ipa_merge_profiles): Fix updating of fnsummary; also handle rescaling of mismatched profiles.\n\n\n\t* ipa-utils.c (ipa_merge_profiles): Fix updating of fnsummary;\n\talso handle rescaling of mismatched profiles.\n\t* ipa-fnsummary.c (analyze_function): Handle speculative edges.\n\nFrom-SVN: r267392", "tree": {"sha": "76f8d2d85c498bea6a9f9b56ec6885cad957d6e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76f8d2d85c498bea6a9f9b56ec6885cad957d6e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/959b8c8257b8b6fa547c25098d1024b53e5f9b45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/959b8c8257b8b6fa547c25098d1024b53e5f9b45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/959b8c8257b8b6fa547c25098d1024b53e5f9b45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/959b8c8257b8b6fa547c25098d1024b53e5f9b45/comments", "author": null, "committer": null, "parents": [{"sha": "d0a6fcf5895c4d5c2ca8fdb50756959cc8d204b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a6fcf5895c4d5c2ca8fdb50756959cc8d204b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0a6fcf5895c4d5c2ca8fdb50756959cc8d204b8"}], "stats": {"total": 40, "additions": 36, "deletions": 4}, "files": [{"sha": "479083e64830493330dbe2700300bcf9fa32ced9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/959b8c8257b8b6fa547c25098d1024b53e5f9b45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/959b8c8257b8b6fa547c25098d1024b53e5f9b45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=959b8c8257b8b6fa547c25098d1024b53e5f9b45", "patch": "@@ -1,3 +1,9 @@\n+2018-12-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.c (ipa_merge_profiles): Fix updating of fnsummary;\n+\talso handle rescaling of mismatched profiles.\n+\t* ipa-fnsummary.c (analyze_function): Handle speculative edges.\n+\n 2018-12-23  Martin Sebor  <msebor@redhat.com>\n \t    Jeff Law  <law@redhat.com>\n "}, {"sha": "1c43b31104b88eb8338f3573d0cef2269371efaf", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/959b8c8257b8b6fa547c25098d1024b53e5f9b45/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/959b8c8257b8b6fa547c25098d1024b53e5f9b45/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=959b8c8257b8b6fa547c25098d1024b53e5f9b45", "patch": "@@ -2180,6 +2180,17 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t      es->call_stmt_time = this_time;\n \t      es->loop_depth = bb_loop_depth (bb);\n \t      edge_set_predicate (edge, &bb_predicate);\n+\t      if (edge->speculative)\n+\t\t{\n+\t\t  cgraph_edge *direct, *indirect;\n+\t\t  ipa_ref *ref;\n+\t\t  edge->speculative_call_info (direct, indirect, ref);\n+\t\t  gcc_assert (direct == edge);\n+\t          ipa_call_summary *es2\n+\t\t\t = ipa_call_summaries->get_create (indirect);\n+\t\t  ipa_call_summaries->duplicate (edge, indirect,\n+\t\t\t\t\t\t es, es2);\n+\t\t}\n \t    }\n \n \t  /* TODO: When conditional jump or swithc is known to be constant, but\n@@ -2491,7 +2502,8 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n      ipa_update_overall_fn_summary but because computation happens in\n      different order the roundoff errors result in slight changes.  */\n   ipa_update_overall_fn_summary (node);\n-  gcc_assert (info->size == info->self_size);\n+  /* In LTO mode we may have speculative edges set.  */\n+  gcc_assert (in_lto_p || info->size == info->self_size);\n }\n \n "}, {"sha": "f07e3b3eeccca910b338e624024ae288d0a555f4", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/959b8c8257b8b6fa547c25098d1024b53e5f9b45/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/959b8c8257b8b6fa547c25098d1024b53e5f9b45/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=959b8c8257b8b6fa547c25098d1024b53e5f9b45", "patch": "@@ -392,6 +392,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   if (!src->definition\n       || !dst->definition)\n     return;\n+\n   if (src->frequency < dst->frequency)\n     src->frequency = dst->frequency;\n \n@@ -416,6 +417,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n       fprintf (symtab->dump_file, \"Merging profiles of %s to %s\\n\",\n \t       src->dump_name (), dst->dump_name ());\n     }\n+  profile_count orig_count = dst->count;\n+\n   if (dst->count.initialized_p () && dst->count.ipa () == dst->count)\n     dst->count += src->count.ipa ();\n   else \n@@ -644,10 +647,21 @@ ipa_merge_profiles (struct cgraph_node *dst,\n       if (!preserve_body)\n         src->release_body ();\n       /* Update summary.  */\n-      symtab->call_cgraph_removal_hooks (dst);\n-      symtab->call_cgraph_insertion_hooks (dst);\n+      compute_fn_summary (dst, 0);\n+    }\n+  /* We can't update CFG profile, but we can scale IPA profile. CFG\n+     will be scaled according to dst->count after IPA passes.  */\n+  else\n+    {\n+      profile_count to = dst->count;\n+      profile_count::adjust_for_ipa_scaling (&to, &orig_count);\n+      struct cgraph_edge *e;\n+      \n+      for (e = dst->callees; e; e = e->next_callee)\n+\te->count = e->count.apply_scale (to, orig_count);\n+      for (e = dst->indirect_calls; e; e = e->next_callee)\n+\te->count = e->count.apply_scale (to, orig_count);\n     }\n-  /* TODO: if there is no match, we can scale up.  */\n   src->decl = oldsrcdecl;\n }\n "}]}