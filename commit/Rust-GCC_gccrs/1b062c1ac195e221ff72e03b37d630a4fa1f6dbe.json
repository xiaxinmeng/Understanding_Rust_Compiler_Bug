{"sha": "1b062c1ac195e221ff72e03b37d630a4fa1f6dbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIwNjJjMWFjMTk1ZTIyMWZmNzJlMDNiMzdkNjMwYTRmYTFmNmRiZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-05-11T21:51:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-05-11T21:51:07Z"}, "message": "attribs.h (sorted_attr_string): Move machine independent functions for target clone support from the i386 port...\n\n2017-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* attribs.h (sorted_attr_string): Move machine independent\n\tfunctions for target clone support from the i386 port to common\n\tcode.  Rename ix86_function_versions to common_function_versions.\n\tRename make_name to make_unique_name.\n\t(common_function_versions): Likewise.\n\t(make_unique_name): Likewise.\n\t(make_dispatcher_decl): Likewise.\n\t(is_function_default_version): Likewise.\n\t* attribs.c (attr_strcmp): Likewise.\n\t(sorted_attr_string): Likewise.\n\t(common_function_versions): Likewise.\n\t(make_unique_name): Likewise.\n\t(make_dispatcher_decl): Likewise.\n\t(is_function_default_version): Likewise.\n\t* config/i386/i386.c (attr_strcmp): Likewise.\n\t(sorted_attr_string): Likewise.\n\t(ix86_function_versions): Likewise.\n\t(make_name): Likewise.\n\t(make_dispatcher_decl): Likewise.\n\t(is_function_default_version): Likewise.\n\t(TARGET_OPTION_FUNCTION_VERSIONS): Update target function hook.\n\nFrom-SVN: r247932", "tree": {"sha": "fa84a1609b174a307898b89d3439589e106fec7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa84a1609b174a307898b89d3439589e106fec7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/comments", "author": null, "committer": null, "parents": [{"sha": "3619ab8bd4ed2ceaeb202ccaa59341c863679725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3619ab8bd4ed2ceaeb202ccaa59341c863679725", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3619ab8bd4ed2ceaeb202ccaa59341c863679725"}], "stats": {"total": 511, "additions": 271, "deletions": 240}, "files": [{"sha": "da403cd8b49d784f71a40ab6a36137804d9857e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b062c1ac195e221ff72e03b37d630a4fa1f6dbe", "patch": "@@ -1,3 +1,27 @@\n+2017-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* attribs.h (sorted_attr_string): Move machine independent\n+\tfunctions for target clone support from the i386 port to common\n+\tcode.  Rename ix86_function_versions to common_function_versions.\n+\tRename make_name to make_unique_name.\n+\t(common_function_versions): Likewise.\n+\t(make_unique_name): Likewise.\n+\t(make_dispatcher_decl): Likewise.\n+\t(is_function_default_version): Likewise.\n+\t* attribs.c (attr_strcmp): Likewise.\n+\t(sorted_attr_string): Likewise.\n+\t(common_function_versions): Likewise.\n+\t(make_unique_name): Likewise.\n+\t(make_dispatcher_decl): Likewise.\n+\t(is_function_default_version): Likewise.\n+\t* config/i386/i386.c (attr_strcmp): Likewise.\n+\t(sorted_attr_string): Likewise.\n+\t(ix86_function_versions): Likewise.\n+\t(make_name): Likewise.\n+\t(make_dispatcher_decl): Likewise.\n+\t(is_function_default_version): Likewise.\n+\t(TARGET_OPTION_FUNCTION_VERSIONS): Update target function hook.\n+\n 2017-05-11  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR target/80695"}, {"sha": "4ba0eab88993064289ca37206c932a7085a71395", "filename": "gcc/attribs.c", "status": "modified", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=1b062c1ac195e221ff72e03b37d630a4fa1f6dbe", "patch": "@@ -690,3 +690,242 @@ make_attribute (const char *name, const char *arg_name, tree chain)\n   attr = tree_cons (attr_name, attr_args, chain);\n   return attr;\n }\n+\n+\f\n+/* Common functions used for target clone support.  */\n+\n+/* Comparator function to be used in qsort routine to sort attribute\n+   specification strings to \"target\".  */\n+\n+static int\n+attr_strcmp (const void *v1, const void *v2)\n+{\n+  const char *c1 = *(char *const*)v1;\n+  const char *c2 = *(char *const*)v2;\n+  return strcmp (c1, c2);\n+}\n+\n+/* ARGLIST is the argument to target attribute.  This function tokenizes\n+   the comma separated arguments, sorts them and returns a string which\n+   is a unique identifier for the comma separated arguments.   It also\n+   replaces non-identifier characters \"=,-\" with \"_\".  */\n+\n+char *\n+sorted_attr_string (tree arglist)\n+{\n+  tree arg;\n+  size_t str_len_sum = 0;\n+  char **args = NULL;\n+  char *attr_str, *ret_str;\n+  char *attr = NULL;\n+  unsigned int argnum = 1;\n+  unsigned int i;\n+\n+  for (arg = arglist; arg; arg = TREE_CHAIN (arg))\n+    {\n+      const char *str = TREE_STRING_POINTER (TREE_VALUE (arg));\n+      size_t len = strlen (str);\n+      str_len_sum += len + 1;\n+      if (arg != arglist)\n+\targnum++;\n+      for (i = 0; i < strlen (str); i++)\n+\tif (str[i] == ',')\n+\t  argnum++;\n+    }\n+\n+  attr_str = XNEWVEC (char, str_len_sum);\n+  str_len_sum = 0;\n+  for (arg = arglist; arg; arg = TREE_CHAIN (arg))\n+    {\n+      const char *str = TREE_STRING_POINTER (TREE_VALUE (arg));\n+      size_t len = strlen (str);\n+      memcpy (attr_str + str_len_sum, str, len);\n+      attr_str[str_len_sum + len] = TREE_CHAIN (arg) ? ',' : '\\0';\n+      str_len_sum += len + 1;\n+    }\n+\n+  /* Replace \"=,-\" with \"_\".  */\n+  for (i = 0; i < strlen (attr_str); i++)\n+    if (attr_str[i] == '=' || attr_str[i]== '-')\n+      attr_str[i] = '_';\n+\n+  if (argnum == 1)\n+    return attr_str;\n+\n+  args = XNEWVEC (char *, argnum);\n+\n+  i = 0;\n+  attr = strtok (attr_str, \",\");\n+  while (attr != NULL)\n+    {\n+      args[i] = attr;\n+      i++;\n+      attr = strtok (NULL, \",\");\n+    }\n+\n+  qsort (args, argnum, sizeof (char *), attr_strcmp);\n+\n+  ret_str = XNEWVEC (char, str_len_sum);\n+  str_len_sum = 0;\n+  for (i = 0; i < argnum; i++)\n+    {\n+      size_t len = strlen (args[i]);\n+      memcpy (ret_str + str_len_sum, args[i], len);\n+      ret_str[str_len_sum + len] = i < argnum - 1 ? '_' : '\\0';\n+      str_len_sum += len + 1;\n+    }\n+\n+  XDELETEVEC (args);\n+  XDELETEVEC (attr_str);\n+  return ret_str;\n+}\n+\n+\n+/* This function returns true if FN1 and FN2 are versions of the same function,\n+   that is, the target strings of the function decls are different.  This assumes\n+   that FN1 and FN2 have the same signature.  */\n+\n+bool\n+common_function_versions (tree fn1, tree fn2)\n+{\n+  tree attr1, attr2;\n+  char *target1, *target2;\n+  bool result;\n+\n+  if (TREE_CODE (fn1) != FUNCTION_DECL\n+      || TREE_CODE (fn2) != FUNCTION_DECL)\n+    return false;\n+\n+  attr1 = lookup_attribute (\"target\", DECL_ATTRIBUTES (fn1));\n+  attr2 = lookup_attribute (\"target\", DECL_ATTRIBUTES (fn2));\n+\n+  /* At least one function decl should have the target attribute specified.  */\n+  if (attr1 == NULL_TREE && attr2 == NULL_TREE)\n+    return false;\n+\n+  /* Diagnose missing target attribute if one of the decls is already\n+     multi-versioned.  */\n+  if (attr1 == NULL_TREE || attr2 == NULL_TREE)\n+    {\n+      if (DECL_FUNCTION_VERSIONED (fn1) || DECL_FUNCTION_VERSIONED (fn2))\n+\t{\n+\t  if (attr2 != NULL_TREE)\n+\t    {\n+\t      std::swap (fn1, fn2);\n+\t      attr1 = attr2;\n+\t    }\n+\t  error_at (DECL_SOURCE_LOCATION (fn2),\n+\t\t    \"missing %<target%> attribute for multi-versioned %qD\",\n+\t\t    fn2);\n+\t  inform (DECL_SOURCE_LOCATION (fn1),\n+\t\t  \"previous declaration of %qD\", fn1);\n+\t  /* Prevent diagnosing of the same error multiple times.  */\n+\t  DECL_ATTRIBUTES (fn2)\n+\t    = tree_cons (get_identifier (\"target\"),\n+\t\t\t copy_node (TREE_VALUE (attr1)),\n+\t\t\t DECL_ATTRIBUTES (fn2));\n+\t}\n+      return false;\n+    }\n+\n+  target1 = sorted_attr_string (TREE_VALUE (attr1));\n+  target2 = sorted_attr_string (TREE_VALUE (attr2));\n+\n+  /* The sorted target strings must be different for fn1 and fn2\n+     to be versions.  */\n+  if (strcmp (target1, target2) == 0)\n+    result = false;\n+  else\n+    result = true;\n+\n+  XDELETEVEC (target1);\n+  XDELETEVEC (target2);\n+\n+  return result;\n+}\n+\n+/* Return a new name by appending SUFFIX to the DECL name.  If make_unique\n+   is true, append the full path name of the source file.  */\n+\n+char *\n+make_unique_name (tree decl, const char *suffix, bool make_unique)\n+{\n+  char *global_var_name;\n+  int name_len;\n+  const char *name;\n+  const char *unique_name = NULL;\n+\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  /* Get a unique name that can be used globally without any chances\n+     of collision at link time.  */\n+  if (make_unique)\n+    unique_name = IDENTIFIER_POINTER (get_file_function_name (\"\\0\"));\n+\n+  name_len = strlen (name) + strlen (suffix) + 2;\n+\n+  if (make_unique)\n+    name_len += strlen (unique_name) + 1;\n+  global_var_name = XNEWVEC (char, name_len);\n+\n+  /* Use '.' to concatenate names as it is demangler friendly.  */\n+  if (make_unique)\n+    snprintf (global_var_name, name_len, \"%s.%s.%s\", name, unique_name,\n+\t      suffix);\n+  else\n+    snprintf (global_var_name, name_len, \"%s.%s\", name, suffix);\n+\n+  return global_var_name;\n+}\n+\n+/* Make a dispatcher declaration for the multi-versioned function DECL.\n+   Calls to DECL function will be replaced with calls to the dispatcher\n+   by the front-end.  Return the decl created.  */\n+\n+tree\n+make_dispatcher_decl (const tree decl)\n+{\n+  tree func_decl;\n+  char *func_name;\n+  tree fn_type, func_type;\n+  bool is_uniq = false;\n+\n+  if (TREE_PUBLIC (decl) == 0)\n+    is_uniq = true;\n+\n+  func_name = make_unique_name (decl, \"ifunc\", is_uniq);\n+\n+  fn_type = TREE_TYPE (decl);\n+  func_type = build_function_type (TREE_TYPE (fn_type),\n+\t\t\t\t   TYPE_ARG_TYPES (fn_type));\n+  \n+  func_decl = build_fn_decl (func_name, func_type);\n+  XDELETEVEC (func_name);\n+  TREE_USED (func_decl) = 1;\n+  DECL_CONTEXT (func_decl) = NULL_TREE;\n+  DECL_INITIAL (func_decl) = error_mark_node;\n+  DECL_ARTIFICIAL (func_decl) = 1;\n+  /* Mark this func as external, the resolver will flip it again if\n+     it gets generated.  */\n+  DECL_EXTERNAL (func_decl) = 1;\n+  /* This will be of type IFUNCs have to be externally visible.  */\n+  TREE_PUBLIC (func_decl) = 1;\n+\n+  return func_decl;  \n+}\n+\n+/* Returns true if decl is multi-versioned and DECL is the default function,\n+   that is it is not tagged with target specific optimization.  */\n+\n+bool\n+is_function_default_version (const tree decl)\n+{\n+  if (TREE_CODE (decl) != FUNCTION_DECL\n+      || !DECL_FUNCTION_VERSIONED (decl))\n+    return false;\n+  tree attr = lookup_attribute (\"target\", DECL_ATTRIBUTES (decl));\n+  gcc_assert (attr);\n+  attr = TREE_VALUE (TREE_VALUE (attr));\n+  return (TREE_CODE (attr) == STRING_CST\n+\t  && strcmp (TREE_STRING_POINTER (attr), \"default\") == 0);\n+}"}, {"sha": "7f13332700ec123e0db31da16ae6c69f22db47c2", "filename": "gcc/attribs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=1b062c1ac195e221ff72e03b37d630a4fa1f6dbe", "patch": "@@ -41,4 +41,10 @@ extern tree make_attribute (const char *, const char *, tree);\n extern struct scoped_attributes* register_scoped_attributes (const struct attribute_spec *,\n \t\t\t\t\t\t\t     const char *);\n \n+extern char *sorted_attr_string (tree);\n+extern bool common_function_versions (tree, tree);\n+extern char *make_unique_name (tree, const char *, bool);\n+extern tree make_dispatcher_decl (const tree);\n+extern bool is_function_default_version (const tree);\n+\n #endif // GCC_ATTRIBS_H"}, {"sha": "7e8cdb9602ac33e24255501342b1e0db66b1f208", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 240, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b062c1ac195e221ff72e03b37d630a4fa1f6dbe/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1b062c1ac195e221ff72e03b37d630a4fa1f6dbe", "patch": "@@ -32898,92 +32898,6 @@ dispatch_function_versions (tree dispatch_decl,\n   return 0;\n }\n \n-/* Comparator function to be used in qsort routine to sort attribute\n-   specification strings to \"target\".  */\n-\n-static int\n-attr_strcmp (const void *v1, const void *v2)\n-{\n-  const char *c1 = *(char *const*)v1;\n-  const char *c2 = *(char *const*)v2;\n-  return strcmp (c1, c2);\n-}\n-\n-/* ARGLIST is the argument to target attribute.  This function tokenizes\n-   the comma separated arguments, sorts them and returns a string which\n-   is a unique identifier for the comma separated arguments.   It also\n-   replaces non-identifier characters \"=,-\" with \"_\".  */\n-\n-static char *\n-sorted_attr_string (tree arglist)\n-{\n-  tree arg;\n-  size_t str_len_sum = 0;\n-  char **args = NULL;\n-  char *attr_str, *ret_str;\n-  char *attr = NULL;\n-  unsigned int argnum = 1;\n-  unsigned int i;\n-\n-  for (arg = arglist; arg; arg = TREE_CHAIN (arg))\n-    {\n-      const char *str = TREE_STRING_POINTER (TREE_VALUE (arg));\n-      size_t len = strlen (str);\n-      str_len_sum += len + 1;\n-      if (arg != arglist)\n-\targnum++;\n-      for (i = 0; i < strlen (str); i++)\n-\tif (str[i] == ',')\n-\t  argnum++;\n-    }\n-\n-  attr_str = XNEWVEC (char, str_len_sum);\n-  str_len_sum = 0;\n-  for (arg = arglist; arg; arg = TREE_CHAIN (arg))\n-    {\n-      const char *str = TREE_STRING_POINTER (TREE_VALUE (arg));\n-      size_t len = strlen (str);\n-      memcpy (attr_str + str_len_sum, str, len);\n-      attr_str[str_len_sum + len] = TREE_CHAIN (arg) ? ',' : '\\0';\n-      str_len_sum += len + 1;\n-    }\n-\n-  /* Replace \"=,-\" with \"_\".  */\n-  for (i = 0; i < strlen (attr_str); i++)\n-    if (attr_str[i] == '=' || attr_str[i]== '-')\n-      attr_str[i] = '_';\n-\n-  if (argnum == 1)\n-    return attr_str;\n-\n-  args = XNEWVEC (char *, argnum);\n-\n-  i = 0;\n-  attr = strtok (attr_str, \",\");\n-  while (attr != NULL)\n-    {\n-      args[i] = attr;\n-      i++;\n-      attr = strtok (NULL, \",\");\n-    }\n-\n-  qsort (args, argnum, sizeof (char *), attr_strcmp);\n-\n-  ret_str = XNEWVEC (char, str_len_sum);\n-  str_len_sum = 0;\n-  for (i = 0; i < argnum; i++)\n-    {\n-      size_t len = strlen (args[i]);\n-      memcpy (ret_str + str_len_sum, args[i], len);\n-      ret_str[str_len_sum + len] = i < argnum - 1 ? '_' : '\\0';\n-      str_len_sum += len + 1;\n-    }\n-\n-  XDELETEVEC (args);\n-  XDELETEVEC (attr_str);\n-  return ret_str;\n-}\n-\n /* This function changes the assembler name for functions that are\n    versions.  If DECL is a function version and has a \"target\"\n    attribute, it appends the attribute string to its assembler name.  */\n@@ -33033,68 +32947,6 @@ ix86_mangle_function_version_assembler_name (tree decl, tree id)\n   return ret;\n }\n \n-/* This function returns true if FN1 and FN2 are versions of the same function,\n-   that is, the target strings of the function decls are different.  This assumes\n-   that FN1 and FN2 have the same signature.  */\n-\n-static bool\n-ix86_function_versions (tree fn1, tree fn2)\n-{\n-  tree attr1, attr2;\n-  char *target1, *target2;\n-  bool result;\n-\n-  if (TREE_CODE (fn1) != FUNCTION_DECL\n-      || TREE_CODE (fn2) != FUNCTION_DECL)\n-    return false;\n-\n-  attr1 = lookup_attribute (\"target\", DECL_ATTRIBUTES (fn1));\n-  attr2 = lookup_attribute (\"target\", DECL_ATTRIBUTES (fn2));\n-\n-  /* At least one function decl should have the target attribute specified.  */\n-  if (attr1 == NULL_TREE && attr2 == NULL_TREE)\n-    return false;\n-\n-  /* Diagnose missing target attribute if one of the decls is already\n-     multi-versioned.  */\n-  if (attr1 == NULL_TREE || attr2 == NULL_TREE)\n-    {\n-      if (DECL_FUNCTION_VERSIONED (fn1) || DECL_FUNCTION_VERSIONED (fn2))\n-\t{\n-\t  if (attr2 != NULL_TREE)\n-\t    {\n-\t      std::swap (fn1, fn2);\n-\t      attr1 = attr2;\n-\t    }\n-\t  error_at (DECL_SOURCE_LOCATION (fn2),\n-\t\t    \"missing %<target%> attribute for multi-versioned %qD\",\n-\t\t    fn2);\n-\t  inform (DECL_SOURCE_LOCATION (fn1),\n-\t\t  \"previous declaration of %qD\", fn1);\n-\t  /* Prevent diagnosing of the same error multiple times.  */\n-\t  DECL_ATTRIBUTES (fn2)\n-\t    = tree_cons (get_identifier (\"target\"),\n-\t\t\t copy_node (TREE_VALUE (attr1)),\n-\t\t\t DECL_ATTRIBUTES (fn2));\n-\t}\n-      return false;\n-    }\n-\n-  target1 = sorted_attr_string (TREE_VALUE (attr1));\n-  target2 = sorted_attr_string (TREE_VALUE (attr2));\n-\n-  /* The sorted target strings must be different for fn1 and fn2\n-     to be versions.  */\n-  if (strcmp (target1, target2) == 0)\n-    result = false;\n-  else\n-    result = true;\n-\n-  XDELETEVEC (target1);\n-  XDELETEVEC (target2); \n-  \n-  return result;\n-}\n \n static tree \n ix86_mangle_decl_assembler_name (tree decl, tree id)\n@@ -33110,96 +32962,6 @@ ix86_mangle_decl_assembler_name (tree decl, tree id)\n   return id;\n }\n \n-/* Return a new name by appending SUFFIX to the DECL name.  If make_unique\n-   is true, append the full path name of the source file.  */\n-\n-static char *\n-make_name (tree decl, const char *suffix, bool make_unique)\n-{\n-  char *global_var_name;\n-  int name_len;\n-  const char *name;\n-  const char *unique_name = NULL;\n-\n-  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\n-  /* Get a unique name that can be used globally without any chances\n-     of collision at link time.  */\n-  if (make_unique)\n-    unique_name = IDENTIFIER_POINTER (get_file_function_name (\"\\0\"));\n-\n-  name_len = strlen (name) + strlen (suffix) + 2;\n-\n-  if (make_unique)\n-    name_len += strlen (unique_name) + 1;\n-  global_var_name = XNEWVEC (char, name_len);\n-\n-  /* Use '.' to concatenate names as it is demangler friendly.  */\n-  if (make_unique)\n-    snprintf (global_var_name, name_len, \"%s.%s.%s\", name, unique_name,\n-\t      suffix);\n-  else\n-    snprintf (global_var_name, name_len, \"%s.%s\", name, suffix);\n-\n-  return global_var_name;\n-}\n-\n-#if defined (ASM_OUTPUT_TYPE_DIRECTIVE)\n-\n-/* Make a dispatcher declaration for the multi-versioned function DECL.\n-   Calls to DECL function will be replaced with calls to the dispatcher\n-   by the front-end.  Return the decl created.  */\n-\n-static tree\n-make_dispatcher_decl (const tree decl)\n-{\n-  tree func_decl;\n-  char *func_name;\n-  tree fn_type, func_type;\n-  bool is_uniq = false;\n-\n-  if (TREE_PUBLIC (decl) == 0)\n-    is_uniq = true;\n-\n-  func_name = make_name (decl, \"ifunc\", is_uniq);\n-\n-  fn_type = TREE_TYPE (decl);\n-  func_type = build_function_type (TREE_TYPE (fn_type),\n-\t\t\t\t   TYPE_ARG_TYPES (fn_type));\n-  \n-  func_decl = build_fn_decl (func_name, func_type);\n-  XDELETEVEC (func_name);\n-  TREE_USED (func_decl) = 1;\n-  DECL_CONTEXT (func_decl) = NULL_TREE;\n-  DECL_INITIAL (func_decl) = error_mark_node;\n-  DECL_ARTIFICIAL (func_decl) = 1;\n-  /* Mark this func as external, the resolver will flip it again if\n-     it gets generated.  */\n-  DECL_EXTERNAL (func_decl) = 1;\n-  /* This will be of type IFUNCs have to be externally visible.  */\n-  TREE_PUBLIC (func_decl) = 1;\n-\n-  return func_decl;  \n-}\n-\n-#endif\n-\n-/* Returns true if decl is multi-versioned and DECL is the default function,\n-   that is it is not tagged with target specific optimization.  */\n-\n-static bool\n-is_function_default_version (const tree decl)\n-{\n-  if (TREE_CODE (decl) != FUNCTION_DECL\n-      || !DECL_FUNCTION_VERSIONED (decl))\n-    return false;\n-  tree attr = lookup_attribute (\"target\", DECL_ATTRIBUTES (decl));\n-  gcc_assert (attr);\n-  attr = TREE_VALUE (TREE_VALUE (attr));\n-  return (TREE_CODE (attr) == STRING_CST\n-\t  && strcmp (TREE_STRING_POINTER (attr), \"default\") == 0);\n-}\n-\n /* Make a dispatcher declaration for the multi-versioned function DECL.\n    Calls to DECL function will be replaced with calls to the dispatcher\n    by the front-end.  Returns the decl of the dispatcher function.  */\n@@ -33320,7 +33082,7 @@ make_resolver_func (const tree default_decl,\n      to be externally visible for the loader to find it.  So, appending\n      the filename will prevent conflicts with a resolver function from\n      another module which is based on the same version name.  */\n-  resolver_name = make_name (default_decl, \"resolver\", is_uniq);\n+  resolver_name = make_unique_name (default_decl, \"resolver\", is_uniq);\n \n   /* The resolver function should return a (void *). */\n   type = build_function_type_list (ptr_type_node, NULL_TREE);\n@@ -52238,7 +52000,7 @@ ix86_run_selftests (void)\n #define TARGET_OPTION_PRINT ix86_function_specific_print\n \n #undef TARGET_OPTION_FUNCTION_VERSIONS\n-#define TARGET_OPTION_FUNCTION_VERSIONS ix86_function_versions\n+#define TARGET_OPTION_FUNCTION_VERSIONS common_function_versions\n \n #undef TARGET_CAN_INLINE_P\n #define TARGET_CAN_INLINE_P ix86_can_inline_p"}]}