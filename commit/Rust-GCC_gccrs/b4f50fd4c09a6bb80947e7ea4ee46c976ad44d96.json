{"sha": "b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRmNTBmZDRjMDlhNmJiODA5NDdlN2VhNGVlNDZjOTc2YWQ0NGQ5Ng==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2015-09-14T13:16:59Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2015-09-14T13:16:59Z"}, "message": "[AArch64] Handle literal pools for functions > 1 MiB in size.\n\n    \n\nThis patch fixes the issue in PR63304 where we have\nfunctions that are > 1MiB. The idea is to use adrp / ldr or adrp / add\ninstructions to address the literal pools under the use of a command line\noption. I would like to turn this on by default on trunk but keep this\ndisabled by default for the release branches in order to get some\nserious testing for this feature while it bakes on trunk.\n\nAs a follow-up I would like to try and see if estimate_num_insns or\nsomething else can give us a heuristic to turn this on for \"large\" functions.\nAfter all the number of incidences of this are quite low in real life,\nso may be we should look to restrict this use as much as possible on the\ngrounds that this code generation implies an extra integer register for\naddressing for every floating point and vector constant and I don't think\nthat's great in code that already may have high register pressure.\n\nTested on aarch64-none-elf with no regressions. A previous\nversion was bootstrapped and regression tested.\n\nApplied to trunk.\n\nregards\nRamana\n\n2015-09-14  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n    \tPR target/63304\n    \t* config/aarch64/aarch64.c (aarch64_expand_mov_immediate): Handle\n    \tnopcrelative_literal_loads.\n    \t(aarch64_classify_address): Likewise.\n    \t(aarch64_constant_pool_reload_icode): Define.\n    \t(aarch64_secondary_reload): Handle secondary reloads for\n    \tliteral pools.\n    \t(aarch64_override_options): Handle nopcrelative_literal_loads.\n    \t(aarch64_classify_symbol): Handle nopcrelative_literal_loads.\n    \t* config/aarch64/aarch64.md (aarch64_reload_movcp<GPF_TF:mode><P:mode>):\n    \tDefine.\n    \t(aarch64_reload_movcp<VALL:mode><P:mode>): Likewise.\n    \t* config/aarch64/aarch64.opt (mpc-relative-literal-loads): New option.\n    \t* config/aarch64/predicates.md (aarch64_constant_pool_symref): New\n    \tpredicate.\n    \t* doc/invoke.texi (mpc-relative-literal-loads): Document.\n\nFrom-SVN: r227748", "tree": {"sha": "1da7640d452969bb8627ff1d214216b843d57b15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1da7640d452969bb8627ff1d214216b843d57b15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/comments", "author": null, "committer": null, "parents": [{"sha": "641f1ab4ed20677f2c9515bb039d8263a463576f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641f1ab4ed20677f2c9515bb039d8263a463576f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/641f1ab4ed20677f2c9515bb039d8263a463576f"}], "stats": {"total": 173, "additions": 169, "deletions": 4}, "files": [{"sha": "5484f2bf1cc123c089b15a0afbe6766ea6bcb9dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "patch": "@@ -1,3 +1,22 @@\n+2015-09-14  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+    \tPR target/63304\n+    \t* config/aarch64/aarch64.c (aarch64_expand_mov_immediate): Handle\n+    \tnopcrelative_literal_loads.\n+    \t(aarch64_classify_address): Likewise.\n+    \t(aarch64_constant_pool_reload_icode): Define.\n+    \t(aarch64_secondary_reload): Handle secondary reloads for\n+    \tliteral pools.\n+    \t(aarch64_override_options): Handle nopcrelative_literal_loads.\n+    \t(aarch64_classify_symbol): Handle nopcrelative_literal_loads.\n+    \t* config/aarch64/aarch64.md (aarch64_reload_movcp<GPF_TF:mode><P:mode>):\n+    \tDefine.\n+    \t(aarch64_reload_movcp<VALL:mode><P:mode>): Likewise.\n+    \t* config/aarch64/aarch64.opt (mpc-relative-literal-loads): New option.\n+    \t* config/aarch64/predicates.md (aarch64_constant_pool_symref): New\n+    \tpredicate.\n+    \t* doc/invoke.texi (mpc-relative-literal-loads): Document.\n+\n 2015-09-14  John David Anglin  <danglin@gcc.gnu.org>\n \n \tPR middle-end/67401"}, {"sha": "4d2126ba84ae5413bc2c36d2666b2e4277f12cfa", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 105, "deletions": 4, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "patch": "@@ -1734,11 +1734,27 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n \t      aarch64_emit_move (dest, base);\n \t      return;\n \t    }\n+\n \t  mem = force_const_mem (ptr_mode, imm);\n \t  gcc_assert (mem);\n+\n+\t  /* If we aren't generating PC relative literals, then\n+\t     we need to expand the literal pool access carefully.\n+\t     This is something that needs to be done in a number\n+\t     of places, so could well live as a separate function.  */\n+\t  if (nopcrelative_literal_loads)\n+\t    {\n+\t      gcc_assert (can_create_pseudo_p ());\n+\t      base = gen_reg_rtx (ptr_mode);\n+\t      aarch64_expand_mov_immediate (base, XEXP (mem, 0));\n+\t      mem = gen_rtx_MEM (ptr_mode, base);\n+\t    }\n+\n \t  if (mode != ptr_mode)\n \t    mem = gen_rtx_ZERO_EXTEND (mode, mem);\n+\n \t  emit_insn (gen_rtx_SET (dest, mem));\n+\n \t  return;\n \n         case SYMBOL_SMALL_TLSGD:\n@@ -3854,9 +3870,10 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t  rtx sym, addend;\n \n \t  split_const (x, &sym, &addend);\n-\t  return (GET_CODE (sym) == LABEL_REF\n-\t\t  || (GET_CODE (sym) == SYMBOL_REF\n-\t\t      && CONSTANT_POOL_ADDRESS_P (sym)));\n+\t  return ((GET_CODE (sym) == LABEL_REF\n+\t\t   || (GET_CODE (sym) == SYMBOL_REF\n+\t\t       && CONSTANT_POOL_ADDRESS_P (sym)\n+\t\t       && !nopcrelative_literal_loads)));\n \t}\n       return false;\n \n@@ -5039,12 +5056,69 @@ aarch64_legitimize_reload_address (rtx *x_p,\n }\n \n \n+/* Return the reload icode required for a constant pool in mode.  */\n+static enum insn_code\n+aarch64_constant_pool_reload_icode (machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case SFmode:\n+      return CODE_FOR_aarch64_reload_movcpsfdi;\n+\n+    case DFmode:\n+      return CODE_FOR_aarch64_reload_movcpdfdi;\n+\n+    case TFmode:\n+      return CODE_FOR_aarch64_reload_movcptfdi;\n+\n+    case V8QImode:\n+      return CODE_FOR_aarch64_reload_movcpv8qidi;\n+\n+    case V16QImode:\n+      return CODE_FOR_aarch64_reload_movcpv16qidi;\n+\n+    case V4HImode:\n+      return CODE_FOR_aarch64_reload_movcpv4hidi;\n+\n+    case V8HImode:\n+      return CODE_FOR_aarch64_reload_movcpv8hidi;\n+\n+    case V2SImode:\n+      return CODE_FOR_aarch64_reload_movcpv2sidi;\n+\n+    case V4SImode:\n+      return CODE_FOR_aarch64_reload_movcpv4sidi;\n+\n+    case V2DImode:\n+      return CODE_FOR_aarch64_reload_movcpv2didi;\n+\n+    case V2DFmode:\n+      return CODE_FOR_aarch64_reload_movcpv2dfdi;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gcc_unreachable ();\n+}\n static reg_class_t\n aarch64_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x,\n \t\t\t  reg_class_t rclass,\n \t\t\t  machine_mode mode,\n \t\t\t  secondary_reload_info *sri)\n {\n+\n+  /* If we have to disable direct literal pool loads and stores because the\n+     function is too big, then we need a scratch register.  */\n+  if (MEM_P (x) && GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x)\n+      && (SCALAR_FLOAT_MODE_P (GET_MODE (x))\n+\t  || targetm.vector_mode_supported_p (GET_MODE (x)))\n+      && nopcrelative_literal_loads)\n+    {\n+      sri->icode = aarch64_constant_pool_reload_icode (mode);\n+      return NO_REGS;\n+    }\n+\n   /* Without the TARGET_SIMD instructions we cannot move a Q register\n      to a Q register directly.  We need a scratch.  */\n   if (REG_P (x) && (mode == TFmode || mode == TImode) && mode == GET_MODE (x)\n@@ -7693,6 +7767,24 @@ aarch64_override_options_after_change_1 (struct gcc_options *opts)\n       if (opts->x_align_functions <= 0)\n \topts->x_align_functions = aarch64_tune_params.function_align;\n     }\n+\n+  /* If nopcrelative_literal_loads is set on the command line, this\n+     implies that the user asked for PC relative literal loads.  */\n+  if (nopcrelative_literal_loads == 1)\n+    nopcrelative_literal_loads = 0;\n+\n+  /* If it is not set on the command line, we default to no\n+     pc relative literal loads.  */\n+  if (nopcrelative_literal_loads == 2)\n+    nopcrelative_literal_loads = 1;\n+\n+  /* In the tiny memory model it makes no sense\n+     to disallow non PC relative literal pool loads\n+     as many other things will break anyway.  */\n+  if (nopcrelative_literal_loads\n+      && (aarch64_cmodel == AARCH64_CMODEL_TINY\n+\t  || aarch64_cmodel == AARCH64_CMODEL_TINY_PIC))\n+    nopcrelative_literal_loads = 0;\n }\n \n /* 'Unpack' up the internal tuning structs and update the options\n@@ -8884,7 +8976,16 @@ aarch64_classify_symbol (rtx x, rtx offset,\n   if (GET_CODE (x) == SYMBOL_REF)\n     {\n       if (aarch64_cmodel == AARCH64_CMODEL_LARGE)\n-\t  return SYMBOL_FORCE_TO_MEM;\n+\t{\n+\t  /* This is alright even in PIC code as the constant\n+\t     pool reference is always PC relative and within\n+\t     the same translation unit.  */\n+\t  if (nopcrelative_literal_loads\n+\t      && CONSTANT_POOL_ADDRESS_P (x))\n+\t    return SYMBOL_SMALL_ABSOLUTE;\n+\t  else\n+\t    return SYMBOL_FORCE_TO_MEM;\n+\t}\n \n       if (aarch64_tls_symbol_p (x))\n \treturn aarch64_classify_tls_symbol (x);"}, {"sha": "88ba72e3ac7f8724fd068c5ea61da94d7aff9d76", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "patch": "@@ -4415,6 +4415,32 @@\n ;; -------------------------------------------------------------------\n ;; Reload support\n ;; -------------------------------------------------------------------\n+;; Reload Scalar Floating point modes from constant pool.\n+;; The AArch64 port doesn't have __int128 constant move support.\n+(define_expand \"aarch64_reload_movcp<GPF_TF:mode><P:mode>\"\n+ [(set (match_operand:GPF_TF 0 \"register_operand\" \"=w\")\n+       (mem:GPF_TF (match_operand 1 \"aarch64_constant_pool_symref\" \"S\")))\n+  (clobber (match_operand:P 2 \"register_operand\" \"=&r\"))]\n+ \"TARGET_FLOAT && nopcrelative_literal_loads\"\n+ {\n+   aarch64_expand_mov_immediate (operands[2], XEXP (operands[1], 0));\n+   emit_move_insn (operands[0], gen_rtx_MEM (<GPF_TF:MODE>mode, operands[2]));\n+   DONE;\n+ }\n+)\n+\n+;; Reload Vector modes from constant pool.\n+(define_expand \"aarch64_reload_movcp<VALL:mode><P:mode>\"\n+ [(set (match_operand:VALL 0 \"register_operand\" \"=w\")\n+       (mem:VALL (match_operand 1 \"aarch64_constant_pool_symref\" \"S\")))\n+  (clobber (match_operand:P 2 \"register_operand\" \"=&r\"))]\n+ \"TARGET_FLOAT && nopcrelative_literal_loads\"\n+ {\n+   aarch64_expand_mov_immediate (operands[2], XEXP (operands[1], 0));\n+   emit_move_insn (operands[0], gen_rtx_MEM (<VALL:MODE>mode, operands[2]));\n+   DONE;\n+ }\n+)\n \n (define_expand \"aarch64_reload_mov<mode>\"\n   [(set (match_operand:TX 0 \"register_operand\" \"=w\")"}, {"sha": "a1ce58d4ea897db094566ee33d1dc5cdb77a4c11", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "patch": "@@ -144,3 +144,7 @@ Enum(aarch64_abi) String(ilp32) Value(AARCH64_ABI_ILP32)\n \n EnumValue\n Enum(aarch64_abi) String(lp64) Value(AARCH64_ABI_LP64)\n+\n+mpc-relative-literal-loads\n+Target Report Save Var(nopcrelative_literal_loads) Init(2) Save\n+PC relative literal loads."}, {"sha": "42cb97902e25644fa6582babb44f806e173d731e", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "patch": "@@ -44,6 +44,9 @@\n ;; Double vector modes.\n (define_mode_iterator VDF [V2SF V4HF])\n \n+;; Iterator for all scalar floating point modes (SF, DF and TF)\n+(define_mode_iterator GPF_TF [SF DF TF])\n+\n ;; Integer vector modes.\n (define_mode_iterator VDQ_I [V8QI V16QI V4HI V8HI V2SI V4SI V2DI])\n "}, {"sha": "7b852a43ff5f2f9769cba6efb6c2c3ea3521fd5e", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "patch": "@@ -362,3 +362,7 @@\n (define_predicate \"aarch64_simd_shift_imm_bitsize_di\"\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), 0, 64)\")))\n+\n+(define_predicate \"aarch64_constant_pool_symref\"\n+   (and (match_code \"symbol_ref\")\n+\t(match_test \"CONSTANT_POOL_ADDRESS_P (op)\")))"}, {"sha": "99c9685f8ed411237eee71598f45014ecf62a25c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b4f50fd4c09a6bb80947e7ea4ee46c976ad44d96", "patch": "@@ -12449,6 +12449,14 @@ for @var{string} in this option are not guaranteed to be consistent\n across releases.\n \n This option is only intended to be useful when developing GCC.\n+\n+@item -mpc-relative-literal-loads\n+@opindex mpcrelativeliteralloads\n+Enable PC relative literal loads. If this option is used, literal\n+pools are assumed to have a range of up to 1MiB and an appropriate\n+instruction sequence is used. This option has no impact when used\n+with @option{-mcmodel=tiny}.\n+\n @end table\n \n @subsubsection @option{-march} and @option{-mcpu} Feature Modifiers"}]}