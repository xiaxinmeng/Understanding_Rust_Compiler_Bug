{"sha": "8723e2fedf070eeea2d16e68f4baf2295d9a94e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcyM2UyZmVkZjA3MGVlZWEyZDE2ZTY4ZjRiYWYyMjk1ZDlhOTRlOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-02-19T17:09:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-02-19T17:09:42Z"}, "message": "re PR middle-end/28779 (internal compiler error: in cgraph_estimate_size_after_inlining, at ipa-inline.c:106)\n\n\n\tPR middle-end/28779\n\t* tree-inline.c (estimate_num_insns_1): Fix counting of cost of call_expr.\n\nFrom-SVN: r132439", "tree": {"sha": "1fe672986c3dc436f7d252f138457d6ff2315160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fe672986c3dc436f7d252f138457d6ff2315160"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8723e2fedf070eeea2d16e68f4baf2295d9a94e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8723e2fedf070eeea2d16e68f4baf2295d9a94e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8723e2fedf070eeea2d16e68f4baf2295d9a94e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8723e2fedf070eeea2d16e68f4baf2295d9a94e8/comments", "author": null, "committer": null, "parents": [{"sha": "5ba5440f24b648e4d52d4e38b1e73084199c5325", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ba5440f24b648e4d52d4e38b1e73084199c5325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ba5440f24b648e4d52d4e38b1e73084199c5325"}], "stats": {"total": 39, "additions": 31, "deletions": 8}, "files": [{"sha": "158984452e3b134bb8f2f91defb7b15e5d9bf2cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8723e2fedf070eeea2d16e68f4baf2295d9a94e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8723e2fedf070eeea2d16e68f4baf2295d9a94e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8723e2fedf070eeea2d16e68f4baf2295d9a94e8", "patch": "@@ -1,3 +1,8 @@\n+2008-02-19  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/28779\n+\t* tree-inline.c (estimate_num_insns_1): Fix counting of cost of call_expr.\n+\n 2008-02-19  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR Ada/35186"}, {"sha": "201f2cfc793885b70f30a2f59c648b325ea783c0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8723e2fedf070eeea2d16e68f4baf2295d9a94e8/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8723e2fedf070eeea2d16e68f4baf2295d9a94e8/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8723e2fedf070eeea2d16e68f4baf2295d9a94e8", "patch": "@@ -2434,6 +2434,11 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case CALL_EXPR:\n       {\n \ttree decl = get_callee_fndecl (x);\n+\ttree addr = CALL_EXPR_FN (x);\n+\ttree funtype = TREE_TYPE (addr);\n+\n+\tgcc_assert (POINTER_TYPE_P (funtype));\n+\tfuntype = TREE_TYPE (funtype);\n \n \tif (decl && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_MD)\n \t  cost = d->weights->target_builtin_call_cost;\n@@ -2456,21 +2461,34 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n \t      break;\n \t    }\n \n+\tif (decl)\n+\t  funtype = TREE_TYPE (decl);\n+\n \t/* Our cost must be kept in sync with cgraph_estimate_size_after_inlining\n-\t   that does use function declaration to figure out the arguments.  */\n-\tif (!decl)\n+\t   that does use function declaration to figure out the arguments. \n+\n+\t   When we deal with function with no body nor prototype, base estimates on\n+\t   actual parameters of the call expression.  Otherwise use either the actual\n+\t   arguments types or function declaration for more precise answer.  */\n+\tif (decl && DECL_ARGUMENTS (decl))\n+\t  {\n+\t    tree arg;\n+\t    for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n+\t      d->count += estimate_move_cost (TREE_TYPE (arg));\n+\t  }\n+\telse if (funtype && prototype_p (funtype))\n+\t  {\n+\t    tree t;\n+\t    for (t = TYPE_ARG_TYPES (funtype); t; t = TREE_CHAIN (t))\n+\t      d->count += estimate_move_cost (TREE_VALUE (t));\n+\t  }\n+\telse\n \t  {\n \t    tree a;\n \t    call_expr_arg_iterator iter;\n \t    FOR_EACH_CALL_EXPR_ARG (a, iter, x)\n \t      d->count += estimate_move_cost (TREE_TYPE (a));\n \t  }\n-\telse\n-\t  {\n-\t    tree arg;\n-\t    for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n-\t      d->count += estimate_move_cost (TREE_TYPE (arg));\n-\t  }\n \n \td->count += cost;\n \tbreak;"}]}