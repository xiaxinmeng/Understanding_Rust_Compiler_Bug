{"sha": "f4fde1b378ad68fb2dec6719ed26c1b901488e03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRmZGUxYjM3OGFkNjhmYjJkZWM2NzE5ZWQyNmMxYjkwMTQ4OGUwMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-05-31T16:27:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-05-31T16:27:49Z"}, "message": "New .md construct: define_insn_and_rewrite\n\nSeveral SVE patterns need define_insn_and_splits that generate the\nsame insn_code, but with different operands.  That's probably a\nniche requirement, but it's cropping up often enough on the ACLE\nbranch that I think it would be good to have a syntactic sugar for it.\n\nThis patch therefore adds a new construct called define_insn_and_rewrite.\nIt's basically a define_insn_and_split with an implicit split pattern,\nobtained by copying the insn pattern and replacing match_operands with\nmatch_dups and match_operators with match_op_dups.\n\n2019-05-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* doc/md.texi: Document define_insn_and_rewrite.\n\t* rtl.def (DEFINE_INSN_AND_REWRITE): New rtx code.\n\t* gensupport.c (queue_elem): Update comment.\n\t(replace_operands_with_dups): New function.\n\t(gen_rewrite_sequence): Likewise.\n\t(process_rtx): Handle DEFINE_INSN_AND_REWRITE.\n\t* read-rtl.c (apply_subst_iterator): Likewise.\n\t(add_condition_to_rtx, named_rtx_p): Likewise.\n\t(rtx_reader::read_rtx_operand): Likewise.\n\t* config/aarch64/aarch64-sve.md\n\t(while_ult<GPI:mode><PRED_ALL:mode>_cc): Rename to...\n\t(*while_ult<GPI:mode><PRED_ALL:mode>_cc): ...this and use\n\tdefine_insn_and_rewrite.\n\t(*cond_<optab><mode>_any): Turn into define_insn_and_rewrites.\n\tRemove separate define_split.\n\nFrom-SVN: r271815", "tree": {"sha": "a6089ff5ae9f140f131b42e288966eb32e0b353c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6089ff5ae9f140f131b42e288966eb32e0b353c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4fde1b378ad68fb2dec6719ed26c1b901488e03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4fde1b378ad68fb2dec6719ed26c1b901488e03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4fde1b378ad68fb2dec6719ed26c1b901488e03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4fde1b378ad68fb2dec6719ed26c1b901488e03/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b1bb4869e2708c1385352e4d960833e1b258859b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1bb4869e2708c1385352e4d960833e1b258859b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1bb4869e2708c1385352e4d960833e1b258859b"}], "stats": {"total": 311, "additions": 249, "deletions": 62}, "files": [{"sha": "0ab407543843b69d1dfb85f0fe8375f2c2d1a7f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4fde1b378ad68fb2dec6719ed26c1b901488e03", "patch": "@@ -1,3 +1,21 @@\n+2019-05-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/md.texi: Document define_insn_and_rewrite.\n+\t* rtl.def (DEFINE_INSN_AND_REWRITE): New rtx code.\n+\t* gensupport.c (queue_elem): Update comment.\n+\t(replace_operands_with_dups): New function.\n+\t(gen_rewrite_sequence): Likewise.\n+\t(process_rtx): Handle DEFINE_INSN_AND_REWRITE.\n+\t* read-rtl.c (apply_subst_iterator): Likewise.\n+\t(add_condition_to_rtx, named_rtx_p): Likewise.\n+\t(rtx_reader::read_rtx_operand): Likewise.\n+\t* config/aarch64/aarch64-sve.md\n+\t(while_ult<GPI:mode><PRED_ALL:mode>_cc): Rename to...\n+\t(*while_ult<GPI:mode><PRED_ALL:mode>_cc): ...this and use\n+\tdefine_insn_and_rewrite.\n+\t(*cond_<optab><mode>_any): Turn into define_insn_and_rewrites.\n+\tRemove separate define_split.\n+\n 2019-05-31  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-alias.c (type_has_components_p): New function."}, {"sha": "038762e19b891030a54968c6649ea6ce8cc5830e", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 34, "deletions": 53, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=f4fde1b378ad68fb2dec6719ed26c1b901488e03", "patch": "@@ -1345,7 +1345,7 @@\n ;; WHILELO sets the flags in the same way as a PTEST with a PTRUE GP.\n ;; Handle the case in which both results are useful.  The GP operand\n ;; to the PTEST isn't needed, so we allow it to be anything.\n-(define_insn_and_split \"while_ult<GPI:mode><PRED_ALL:mode>_cc\"\n+(define_insn_and_rewrite \"*while_ult<GPI:mode><PRED_ALL:mode>_cc\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC\n \t  (unspec:SI [(match_operand:PRED_ALL 1)\n@@ -1364,12 +1364,8 @@\n   ;; Force the compiler to drop the unused predicate operand, so that we\n   ;; don't have an unnecessary PTRUE.\n   \"&& !CONSTANT_P (operands[1])\"\n-  [(const_int 0)]\n   {\n-    emit_insn (gen_while_ult<GPI:mode><PRED_ALL:mode>_cc\n-\t       (operands[0], CONSTM1_RTX (<MODE>mode),\n-\t\toperands[2], operands[3]));\n-    DONE;\n+    operands[1] = CONSTM1_RTX (<MODE>mode);\n   }\n )\n \n@@ -2003,7 +1999,7 @@\n )\n \n ;; Synthetic predications with select unmatched.\n-(define_insn \"*cond_<optab><mode>_any\"\n+(define_insn_and_rewrite \"*cond_<optab><mode>_any\"\n   [(set (match_operand:SVE_I 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_I\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n@@ -2012,11 +2008,20 @@\n \t     (match_operand:SVE_I 3 \"register_operand\" \"w\"))\n \t   (match_operand:SVE_I 4 \"register_operand\"   \"w\")]\n \t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n+  \"TARGET_SVE\n+   && !(rtx_equal_p (operands[0], operands[4])\n+        || rtx_equal_p (operands[2], operands[4])\n+        || rtx_equal_p (operands[3], operands[4]))\"\n   \"#\"\n+  \"&& reload_completed\"\n+  {\n+    emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[2],\n+\t\t\t\t\t     operands[4], operands[1]));\n+    operands[4] = operands[2] = operands[0];\n+  }\n )\n \n-(define_insn \"*cond_<optab><mode>_any\"\n+(define_insn_and_rewrite \"*cond_<optab><mode>_any\"\n   [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_SDI\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n@@ -2025,33 +2030,17 @@\n \t     (match_operand:SVE_SDI 3 \"register_operand\" \"w\"))\n \t   (match_operand:SVE_SDI 4 \"register_operand\"   \"w\")]\n \t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n-  \"#\"\n-)\n-\n-(define_split\n-  [(set (match_operand:SVE_I 0 \"register_operand\")\n-\t(unspec:SVE_I\n-\t  [(match_operand:<VPRED> 1 \"register_operand\")\n-\t   (match_operator:SVE_I 5 \"aarch64_sve_any_binary_operator\"\n-\t     [(match_operand:SVE_I 2 \"register_operand\")\n-\t      (match_operand:SVE_I 3 \"register_operand\")])\n-\t   (match_operand:SVE_I 4 \"register_operand\")]\n-\t  UNSPEC_SEL))]\n-  \"TARGET_SVE && reload_completed\n+  \"TARGET_SVE\n    && !(rtx_equal_p (operands[0], operands[4])\n         || rtx_equal_p (operands[2], operands[4])\n         || rtx_equal_p (operands[3], operands[4]))\"\n-  ; Not matchable by any one insn or movprfx insn.  We need a separate select.\n-  [(set (match_dup 0)\n-\t(unspec:SVE_I [(match_dup 1) (match_dup 2) (match_dup 4)]\n-                      UNSPEC_SEL))\n-   (set (match_dup 0)\n-\t(unspec:SVE_I\n-\t  [(match_dup 1)\n-\t   (match_op_dup 5 [(match_dup 0) (match_dup 3)])\n-           (match_dup 0)]\n-\t  UNSPEC_SEL))]\n+  \"#\"\n+  \"&& reload_completed\"\n+  {\n+    emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[2],\n+\t\t\t\t\t     operands[4], operands[1]));\n+    operands[4] = operands[2] = operands[0];\n+  }\n )\n \n ;; Set operand 0 to the last active element in operand 3, or to tied\n@@ -2957,7 +2946,7 @@\n )\n \n ;; Synthetic predication of floating-point operations with select unmatched.\n-(define_insn_and_split \"*cond_<optab><mode>_any\"\n+(define_insn_and_rewrite \"*cond_<optab><mode>_any\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n@@ -2974,14 +2963,11 @@\n         || rtx_equal_p (operands[2], operands[4])\n         || rtx_equal_p (operands[3], operands[4]))\"\n   ; Not matchable by any one insn or movprfx insn.  We need a separate select.\n-  [(set (match_dup 0)\n-\t(unspec:SVE_F [(match_dup 1) (match_dup 2) (match_dup 4)] UNSPEC_SEL))\n-   (set (match_dup 0)\n-\t(unspec:SVE_F\n-\t  [(match_dup 1)\n-\t   (unspec:SVE_F [(match_dup 0) (match_dup 3)] SVE_COND_FP_BINARY)\n-           (match_dup 0)]\n-\t  UNSPEC_SEL))]\n+  {\n+    emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[2],\n+\t\t\t\t\t     operands[4], operands[1]));\n+    operands[4] = operands[2] = operands[0];\n+  }\n )\n \n ;; Predicated floating-point ternary operations with select.\n@@ -3044,7 +3030,7 @@\n \n ;; Predicated floating-point ternary operations in which the value for\n ;; inactive lanes is distinct from the other inputs.\n-(define_insn_and_split \"*cond_<optab><mode>_any\"\n+(define_insn_and_rewrite \"*cond_<optab><mode>_any\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=&w, &w, ?&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n@@ -3066,16 +3052,11 @@\n   \"&& reload_completed\n    && !CONSTANT_P (operands[5])\n    && !rtx_equal_p (operands[0], operands[5])\"\n-  [(set (match_dup 0)\n-\t(unspec:SVE_F [(match_dup 1) (match_dup 4) (match_dup 5)] UNSPEC_SEL))\n-   (set (match_dup 0)\n-\t(unspec:SVE_F\n-\t  [(match_dup 1)\n-\t   (unspec:SVE_F [(match_dup 2) (match_dup 3) (match_dup 0)]\n-\t\t\t SVE_COND_FP_TERNARY)\n-           (match_dup 0)]\n-\t  UNSPEC_SEL))]\n-  \"\"\n+  {\n+    emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[4],\n+\t\t\t\t\t     operands[5], operands[1]));\n+    operands[5] = operands[4] = operands[0];\n+  }\n   [(set_attr \"movprfx\" \"yes\")]\n )\n "}, {"sha": "4bc57d680af8ca9a1efd09a93c330674fd381c2d", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f4fde1b378ad68fb2dec6719ed26c1b901488e03", "patch": "@@ -8498,6 +8498,119 @@ functionality as two separate @code{define_insn} and @code{define_split}\n patterns.  It exists for compactness, and as a maintenance tool to prevent\n having to ensure the two patterns' templates match.\n \n+@findex define_insn_and_rewrite\n+It is sometimes useful to have a @code{define_insn_and_split}\n+that replaces specific operands of an instruction but leaves the\n+rest of the instruction pattern unchanged.  You can do this directly\n+with a @code{define_insn_and_split}, but it requires a\n+@var{new-insn-pattern-1} that repeats most of the original @var{insn-pattern}.\n+There is also the complication that an implicit @code{parallel} in\n+@var{insn-pattern} must become an explicit @code{parallel} in\n+@var{new-insn-pattern-1}, which is easy to overlook.\n+A simpler alternative is to use @code{define_insn_and_rewrite}, which\n+is a form of @code{define_insn_and_split} that automatically generates\n+@var{new-insn-pattern-1} by replacing each @code{match_operand}\n+in @var{insn-pattern} with a corresponding @code{match_dup}, and each\n+@code{match_operator} in the pattern with a corresponding @code{match_op_dup}.\n+The arguments are otherwise identical to @code{define_insn_and_split}:\n+\n+@smallexample\n+(define_insn_and_rewrite\n+  [@var{insn-pattern}]\n+  \"@var{condition}\"\n+  \"@var{output-template}\"\n+  \"@var{split-condition}\"\n+  \"@var{preparation-statements}\"\n+  [@var{insn-attributes}])\n+@end smallexample\n+\n+The @code{match_dup}s and @code{match_op_dup}s in the new\n+instruction pattern use any new operand values that the\n+@var{preparation-statements} store in the @code{operands} array,\n+as for a normal @code{define_insn_and_split}.  @var{preparation-statements}\n+can also emit additional instructions before the new instruction.\n+They can even emit an entirely different sequence of instructions and\n+use @code{DONE} to avoid emitting a new form of the original\n+instruction.\n+\n+The split in a @code{define_insn_and_rewrite} is only intended\n+to apply to existing instructions that match @var{insn-pattern}.\n+@var{split-condition} must therefore start with @code{&&},\n+so that the split condition applies on top of @var{condition}.\n+\n+Here is an example from the AArch64 SVE port, in which operand 1 is\n+known to be equivalent to an all-true constant and isn't used by the\n+output template:\n+\n+@smallexample\n+(define_insn_and_rewrite \"*while_ult<GPI:mode><PRED_ALL:mode>_cc\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC\n+          (unspec:SI [(match_operand:PRED_ALL 1)\n+                      (unspec:PRED_ALL\n+                        [(match_operand:GPI 2 \"aarch64_reg_or_zero\" \"rZ\")\n+                         (match_operand:GPI 3 \"aarch64_reg_or_zero\" \"rZ\")]\n+                        UNSPEC_WHILE_LO)]\n+                     UNSPEC_PTEST_PTRUE)\n+          (const_int 0)))\n+   (set (match_operand:PRED_ALL 0 \"register_operand\" \"=Upa\")\n+        (unspec:PRED_ALL [(match_dup 2)\n+                          (match_dup 3)]\n+                         UNSPEC_WHILE_LO))]\n+  \"TARGET_SVE\"\n+  \"whilelo\\t%0.<PRED_ALL:Vetype>, %<w>2, %<w>3\"\n+  ;; Force the compiler to drop the unused predicate operand, so that we\n+  ;; don't have an unnecessary PTRUE.\n+  \"&& !CONSTANT_P (operands[1])\"\n+  @{\n+    operands[1] = CONSTM1_RTX (<MODE>mode);\n+  @}\n+)\n+@end smallexample\n+\n+The splitter in this case simply replaces operand 1 with the constant\n+value that it is known to have.  The equivalent @code{define_insn_and_split}\n+would be:\n+\n+@smallexample\n+(define_insn_and_split \"*while_ult<GPI:mode><PRED_ALL:mode>_cc\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC\n+          (unspec:SI [(match_operand:PRED_ALL 1)\n+                      (unspec:PRED_ALL\n+                        [(match_operand:GPI 2 \"aarch64_reg_or_zero\" \"rZ\")\n+                         (match_operand:GPI 3 \"aarch64_reg_or_zero\" \"rZ\")]\n+                        UNSPEC_WHILE_LO)]\n+                     UNSPEC_PTEST_PTRUE)\n+          (const_int 0)))\n+   (set (match_operand:PRED_ALL 0 \"register_operand\" \"=Upa\")\n+        (unspec:PRED_ALL [(match_dup 2)\n+                          (match_dup 3)]\n+                         UNSPEC_WHILE_LO))]\n+  \"TARGET_SVE\"\n+  \"whilelo\\t%0.<PRED_ALL:Vetype>, %<w>2, %<w>3\"\n+  ;; Force the compiler to drop the unused predicate operand, so that we\n+  ;; don't have an unnecessary PTRUE.\n+  \"&& !CONSTANT_P (operands[1])\"\n+  [(parallel\n+     [(set (reg:CC CC_REGNUM)\n+           (compare:CC\n+             (unspec:SI [(match_dup 1)\n+                         (unspec:PRED_ALL [(match_dup 2)\n+                                           (match_dup 3)]\n+                                          UNSPEC_WHILE_LO)]\n+                        UNSPEC_PTEST_PTRUE)\n+             (const_int 0)))\n+      (set (match_dup 0)\n+           (unspec:PRED_ALL [(match_dup 2)\n+                             (match_dup 3)]\n+                            UNSPEC_WHILE_LO))])]\n+  @{\n+    operands[1] = CONSTM1_RTX (<MODE>mode);\n+  @}\n+)\n+@end smallexample\n+\n @end ifset\n @ifset INTERNALS\n @node Including Patterns"}, {"sha": "0150346d40915ae54b7707556a638f54e725a7e5", "filename": "gcc/gensupport.c", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=f4fde1b378ad68fb2dec6719ed26c1b901488e03", "patch": "@@ -70,8 +70,8 @@ struct queue_elem\n   rtx data;\n   file_location loc;\n   struct queue_elem *next;\n-  /* In a DEFINE_INSN that came from a DEFINE_INSN_AND_SPLIT, SPLIT\n-     points to the generated DEFINE_SPLIT.  */\n+  /* In a DEFINE_INSN that came from a DEFINE_INSN_AND_SPLIT or\n+     DEFINE_INSN_AND_REWRITE, SPLIT points to the generated DEFINE_SPLIT.  */\n   struct queue_elem *split;\n };\n \n@@ -485,6 +485,63 @@ remove_constraints (rtx part)\n       }\n }\n \n+/* Recursively replace MATCH_OPERANDs with MATCH_DUPs and MATCH_OPERATORs\n+   with MATCH_OP_DUPs in X.  */\n+\n+static rtx\n+replace_operands_with_dups (rtx x)\n+{\n+  if (x == 0)\n+    return x;\n+\n+  rtx newx;\n+  if (GET_CODE (x) == MATCH_OPERAND)\n+    {\n+      newx = rtx_alloc (MATCH_DUP);\n+      XINT (newx, 0) = XINT (x, 0);\n+    }\n+  else if (GET_CODE (x) == MATCH_OPERATOR)\n+    {\n+      newx = rtx_alloc (MATCH_OP_DUP);\n+      XINT (newx, 0) = XINT (x, 0);\n+      XVEC (newx, 1) = XVEC (x, 2);\n+    }\n+  else\n+    newx = shallow_copy_rtx (x);\n+\n+  const char *format_ptr = GET_RTX_FORMAT (GET_CODE (x));\n+  for (int i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)\n+    switch (*format_ptr++)\n+      {\n+      case 'e':\n+      case 'u':\n+\tXEXP (newx, i) = replace_operands_with_dups (XEXP (x, i));\n+\tbreak;\n+      case 'E':\n+\tif (XVEC (x, i) != NULL)\n+\t  {\n+\t    XVEC (newx, i) = rtvec_alloc (XVECLEN (x, i));\n+\t    for (int j = 0; j < XVECLEN (x, i); j++)\n+\t      XVECEXP (newx, i, j)\n+\t\t= replace_operands_with_dups (XVECEXP (x, i, j));\n+\t  }\n+\tbreak;\n+      }\n+  return newx;\n+}\n+\n+/* Convert matching pattern VEC from a DEFINE_INSN_AND_REWRITE into\n+   a sequence that should be generated by the splitter.  */\n+\n+static rtvec\n+gen_rewrite_sequence (rtvec vec)\n+{\n+  rtvec new_vec = rtvec_alloc (1);\n+  rtx x = add_implicit_parallel (vec);\n+  RTVEC_ELT (new_vec, 0) = replace_operands_with_dups (x);\n+  return new_vec;\n+}\n+\n /* Process a top level rtx in some way, queuing as appropriate.  */\n \n static void\n@@ -527,13 +584,15 @@ process_rtx (rtx desc, file_location loc)\n       break;\n \n     case DEFINE_INSN_AND_SPLIT:\n+    case DEFINE_INSN_AND_REWRITE:\n       {\n \tconst char *split_cond;\n \trtx split;\n \trtvec attr;\n \tint i;\n \tstruct queue_elem *insn_elem;\n \tstruct queue_elem *split_elem;\n+\tint split_code = (GET_CODE (desc) == DEFINE_INSN_AND_REWRITE ? 5 : 6);\n \n \t/* Create a split with values from the insn_and_split.  */\n \tsplit = rtx_alloc (DEFINE_SPLIT);\n@@ -555,12 +614,17 @@ process_rtx (rtx desc, file_location loc)\n \t    split_cond = rtx_reader_ptr->join_c_conditions (XSTR (desc, 2),\n \t\t\t\t\t\t\t    split_cond + 2);\n \t  }\n+\telse if (GET_CODE (desc) == DEFINE_INSN_AND_REWRITE)\n+\t  error_at (loc, \"the rewrite condition must start with `&&'\");\n \tXSTR (split, 1) = split_cond;\n-\tXVEC (split, 2) = XVEC (desc, 5);\n-\tXSTR (split, 3) = XSTR (desc, 6);\n+\tif (GET_CODE (desc) == DEFINE_INSN_AND_REWRITE)\n+\t  XVEC (split, 2) = gen_rewrite_sequence (XVEC (desc, 1));\n+\telse\n+\t  XVEC (split, 2) = XVEC (desc, 5);\n+\tXSTR (split, 3) = XSTR (desc, split_code);\n \n \t/* Fix up the DEFINE_INSN.  */\n-\tattr = XVEC (desc, 7);\n+\tattr = XVEC (desc, split_code + 1);\n \tPUT_CODE (desc, DEFINE_INSN);\n \tXVEC (desc, 4) = attr;\n "}, {"sha": "f37708f6967fda0f8193b48c8177a685117569c4", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=f4fde1b378ad68fb2dec6719ed26c1b901488e03", "patch": "@@ -286,9 +286,11 @@ apply_subst_iterator (rtx rt, unsigned int, int value)\n     return;\n   gcc_assert (GET_CODE (rt) == DEFINE_INSN\n \t      || GET_CODE (rt) == DEFINE_INSN_AND_SPLIT\n+\t      || GET_CODE (rt) == DEFINE_INSN_AND_REWRITE\n \t      || GET_CODE (rt) == DEFINE_EXPAND);\n \n-  int attrs = GET_CODE (rt) == DEFINE_INSN_AND_SPLIT ? 7 : 4;\n+  int attrs = (GET_CODE (rt) == DEFINE_INSN_AND_SPLIT ? 7\n+\t       : GET_CODE (rt) == DEFINE_INSN_AND_REWRITE ? 6 : 4);\n   attrs_vec = XVEC (rt, attrs);\n \n   /* If we've already added attribute 'current_iterator_name', then we\n@@ -549,6 +551,7 @@ add_condition_to_rtx (rtx x, const char *extra)\n       break;\n \n     case DEFINE_INSN_AND_SPLIT:\n+    case DEFINE_INSN_AND_REWRITE:\n       XSTR (x, 2) = add_condition_to_string (XSTR (x, 2), extra);\n       XSTR (x, 4) = add_condition_to_string (XSTR (x, 4), extra);\n       break;\n@@ -632,6 +635,7 @@ named_rtx_p (rtx x)\n     case DEFINE_EXPAND:\n     case DEFINE_INSN:\n     case DEFINE_INSN_AND_SPLIT:\n+    case DEFINE_INSN_AND_REWRITE:\n       return true;\n \n     default:\n@@ -1837,8 +1841,8 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n \t    break;\n \t  }\n \n-\t/* The output template slot of a DEFINE_INSN,\n-\t   DEFINE_INSN_AND_SPLIT, or DEFINE_PEEPHOLE automatically\n+\t/* The output template slot of a DEFINE_INSN, DEFINE_INSN_AND_SPLIT,\n+\t   DEFINE_INSN_AND_REWRITE or DEFINE_PEEPHOLE automatically\n \t   gets a star inserted as its first character, if it is\n \t   written with a brace block instead of a string constant.  */\n \tstar_if_braced = (format_ptr[idx] == 'T');\n@@ -1855,7 +1859,8 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n \tif (*stringbuf == '\\0'\n \t    && idx == 0\n \t    && (GET_CODE (return_rtx) == DEFINE_INSN\n-\t\t|| GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n+\t\t|| GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT\n+\t\t|| GET_CODE (return_rtx) == DEFINE_INSN_AND_REWRITE))\n \t  {\n \t    struct obstack *string_obstack = get_string_obstack ();\n \t    char line_name[20];"}, {"sha": "63b09b3d1c406ec74db5b4da96d36476104067b5", "filename": "gcc/rtl.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4fde1b378ad68fb2dec6719ed26c1b901488e03/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=f4fde1b378ad68fb2dec6719ed26c1b901488e03", "patch": "@@ -936,6 +936,12 @@ DEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", RTX_EXTRA)\n    7: optionally, a vector of attributes for this insn.  */\n DEF_RTL_EXPR(DEFINE_INSN_AND_SPLIT, \"define_insn_and_split\", \"sEsTsESV\", RTX_EXTRA)\n \n+/* A form of define_insn_and_split in which the split insn pattern (operand 5)\n+   is determined automatically by replacing match_operands with match_dups\n+   and match_operators with match_op_dups.  The operands are the same as\n+   define_insn_and_split but with operand 5 removed.  */\n+DEF_RTL_EXPR(DEFINE_INSN_AND_REWRITE, \"define_insn_and_rewrite\", \"sEsTsSV\", RTX_EXTRA)\n+\n /* Definition of an RTL peephole operation.\n    Follows the same arguments as define_split.  */\n DEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", RTX_EXTRA)"}]}