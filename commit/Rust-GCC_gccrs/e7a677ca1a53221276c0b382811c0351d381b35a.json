{"sha": "e7a677ca1a53221276c0b382811c0351d381b35a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdhNjc3Y2ExYTUzMjIxMjc2YzBiMzgyODExYzAzNTFkMzgxYjM1YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-12T18:30:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-12T18:30:40Z"}, "message": "ipa-devirt.c (type_with_linkage_p): New function.\n\n\n\t* ipa-devirt.c (type_with_linkage_p): New function.\n\t(type_in_anonymous_namespace_p): Move here from tree.c; assert that\n\ttype has linkage.\n\t(odr_type_p): Move here from ipa-utils.h; use type_with_linkage_p.\n\t(can_be_name_hashed_p): Simplify.\n\t(hash_odr_name): Check that type has linkage before checking if it is\n\tanonymous.\n\t(types_same_for_odr): Likewise.\n\t(odr_name_hasher::equal): Likewise.\n\t(odr_subtypes_equivalent_p): Likewise.\n\t(warn_types_mismatch): Likewise.\n\t(get_odr_type): Likewise.\n\t(odr_types_equivalent_p): Fix checking of TYPE_MAIN_VARIANT.\n\t* ipa-utils.h (odr_type_p): Move offline.\n\t* tree.c (need_assembler_name_p): Fix handling of types\n\twithout linkages.\n\t(type_in_anonymous_namespace_p): Move to ipa-devirt.c\n\nFrom-SVN: r223094", "tree": {"sha": "b8df808b4fa8ac89aaf5398200870e9e35e4c94b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8df808b4fa8ac89aaf5398200870e9e35e4c94b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7a677ca1a53221276c0b382811c0351d381b35a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a677ca1a53221276c0b382811c0351d381b35a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7a677ca1a53221276c0b382811c0351d381b35a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a677ca1a53221276c0b382811c0351d381b35a/comments", "author": null, "committer": null, "parents": [{"sha": "2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625"}], "stats": {"total": 243, "additions": 146, "deletions": 97}, "files": [{"sha": "065ae82d48a8ec9c31973dcb3d5a4655a22311e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a677ca1a53221276c0b382811c0351d381b35a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a677ca1a53221276c0b382811c0351d381b35a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7a677ca1a53221276c0b382811c0351d381b35a", "patch": "@@ -1,3 +1,23 @@\n+2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (type_with_linkage_p): New function.\n+\t(type_in_anonymous_namespace_p): Move here from tree.c; assert that\n+\ttype has linkage.\n+\t(odr_type_p): Move here from ipa-utils.h; use type_with_linkage_p.\n+\t(can_be_name_hashed_p): Simplify.\n+\t(hash_odr_name): Check that type has linkage before checking if it is\n+\tanonymous.\n+\t(types_same_for_odr): Likewise.\n+\t(odr_name_hasher::equal): Likewise.\n+\t(odr_subtypes_equivalent_p): Likewise.\n+\t(warn_types_mismatch): Likewise.\n+\t(get_odr_type): Likewise.\n+\t(odr_types_equivalent_p): Fix checking of TYPE_MAIN_VARIANT.\n+\t* ipa-utils.h (odr_type_p): Move offline.\n+\t* tree.c (need_assembler_name_p): Fix handling of types\n+\twithout linkages.\n+\t(type_in_anonymous_namespace_p): Move to ipa-devirt.c\n+\n 2015-05-12  David Malcolm  <dmalcolm@redhat.com>\n \n \t* timevar.c (timevar_enable): Delete in favor of..."}, {"sha": "c073ac879b2d6c88dc6f873730ec65f9fea2801c", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 103, "deletions": 52, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a677ca1a53221276c0b382811c0351d381b35a/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a677ca1a53221276c0b382811c0351d381b35a/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=e7a677ca1a53221276c0b382811c0351d381b35a", "patch": "@@ -245,6 +245,47 @@ struct GTY(()) odr_type_d\n   bool rtti_broken;\n };\n \n+/* Return true if T is a type with linkage defined.  */\n+\n+static bool\n+type_with_linkage_p (const_tree t)\n+{\n+  return (RECORD_OR_UNION_TYPE_P (t)\n+\t  || TREE_CODE (t) == ENUMERAL_TYPE);\n+}\n+\n+/* Return true if T is in anonymous namespace.\n+   This works only on those C++ types with linkage defined.  */\n+\n+bool\n+type_in_anonymous_namespace_p (const_tree t)\n+{\n+  gcc_assert (type_with_linkage_p (t));\n+  /* TREE_PUBLIC of TYPE_STUB_DECL may not be properly set for\n+     backend produced types (such as va_arg_type); those have CONTEXT NULL\n+     and never are considered anonymoius.  */\n+  if (!TYPE_CONTEXT (t))\n+    return false;\n+  return (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)));\n+}\n+\n+/* Return true of T is type with One Definition Rule info attached. \n+   It means that either it is anonymous type or it has assembler name\n+   set.  */\n+\n+bool\n+odr_type_p (const_tree t)\n+{\n+  if (type_with_linkage_p (t) && type_in_anonymous_namespace_p (t))\n+    return true;\n+  /* We do not have this information when not in LTO, but we do not need\n+     to care, since it is used only for type merging.  */\n+  gcc_checking_assert (in_lto_p || flag_lto);\n+\n+  return (TYPE_NAME (t)\n+          && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))));\n+}\n+\n /* Return TRUE if all derived types of T are known and thus\n    we may consider the walk of derived type complete.\n \n@@ -341,8 +382,7 @@ main_odr_variant (const_tree t)\n static bool\n can_be_name_hashed_p (tree t)\n {\n-  return (!in_lto_p || type_in_anonymous_namespace_p (t)\n-\t  || (TYPE_NAME (t) && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))));\n+  return (!in_lto_p || odr_type_p (t));\n }\n \n /* Hash type by its ODR name.  */\n@@ -358,7 +398,7 @@ hash_odr_name (const_tree t)\n     return htab_hash_pointer (t);\n \n   /* Anonymous types are unique.  */\n-  if (type_in_anonymous_namespace_p (t))\n+  if (type_with_linkage_p (t) && type_in_anonymous_namespace_p (t))\n     return htab_hash_pointer (t);\n \n   gcc_checking_assert (TYPE_NAME (t)\n@@ -381,7 +421,7 @@ can_be_vtable_hashed_p (tree t)\n   if (TYPE_MAIN_VARIANT (t) != t)\n     return false;\n   /* Anonymous namespace types are always handled by name hash.  */\n-  if (type_in_anonymous_namespace_p (t))\n+  if (type_with_linkage_p (t) && type_in_anonymous_namespace_p (t))\n     return false;\n   return (TREE_CODE (t) == RECORD_TYPE\n \t  && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)));\n@@ -455,8 +495,8 @@ types_same_for_odr (const_tree type1, const_tree type2, bool strict)\n \n   /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n      on the corresponding TYPE_STUB_DECL.  */\n-  if (type_in_anonymous_namespace_p (type1)\n-      || type_in_anonymous_namespace_p (type2))\n+  if ((type_with_linkage_p (type1) && type_in_anonymous_namespace_p (type1))\n+      || (type_with_linkage_p (type2) && type_in_anonymous_namespace_p (type2)))\n     return false;\n \n \n@@ -565,8 +605,8 @@ odr_name_hasher::equal (const odr_type_d *o1, const tree_node *t2)\n     return false;\n   /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n      on the corresponding TYPE_STUB_DECL.  */\n-  if (type_in_anonymous_namespace_p (t1)\n-      || type_in_anonymous_namespace_p (t2))\n+  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n+      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n     return false;\n   gcc_checking_assert (DECL_ASSEMBLER_NAME (TYPE_NAME (t1)));\n   gcc_checking_assert (DECL_ASSEMBLER_NAME (TYPE_NAME (t2)));\n@@ -642,7 +682,6 @@ static bool\n odr_subtypes_equivalent_p (tree t1, tree t2,\n \t\t\t   hash_set<type_pair,pair_traits> *visited)\n {\n-  bool an1, an2;\n \n   /* This can happen in incomplete types that should be handled earlier.  */\n   gcc_assert (t1 && t2);\n@@ -653,9 +692,8 @@ odr_subtypes_equivalent_p (tree t1, tree t2,\n     return true;\n \n   /* Anonymous namespace types must match exactly.  */\n-  an1 = type_in_anonymous_namespace_p (t1);\n-  an2 = type_in_anonymous_namespace_p (t2);\n-  if (an1 != an2 || an1)\n+  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n+      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n     return false;\n \n   /* For ODR types be sure to compare their names.\n@@ -1019,10 +1057,10 @@ warn_types_mismatch (tree t1, tree t2)\n     }\n   /* It is a quite common bug to reference anonymous namespace type in\n      non-anonymous namespace class.  */\n-  if (type_in_anonymous_namespace_p (t1)\n-      || type_in_anonymous_namespace_p (t2))\n+  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n+      || (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n     {\n-      if (!type_in_anonymous_namespace_p (t1))\n+      if (type_with_linkage_p (t1) && !type_in_anonymous_namespace_p (t1))\n \t{\n \t  tree tmp = t1;;\n \t  t1 = t2;\n@@ -1166,8 +1204,8 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n     return true;\n-  gcc_assert (!type_in_anonymous_namespace_p (t1));\n-  gcc_assert (!type_in_anonymous_namespace_p (t2));\n+  gcc_assert (!type_with_linkage_p (t1) || !type_in_anonymous_namespace_p (t1));\n+  gcc_assert (!type_with_linkage_p (t2) || !type_in_anonymous_namespace_p (t2));\n \n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n@@ -1498,43 +1536,53 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\treturn false;\n \t      }\n \t    if ((TYPE_MAIN_VARIANT (t1) == t1 || TYPE_MAIN_VARIANT (t2) == t2)\n+\t\t&& COMPLETE_TYPE_P (TYPE_MAIN_VARIANT (t1))\n+\t\t&& COMPLETE_TYPE_P (TYPE_MAIN_VARIANT (t2))\n+\t\t&& odr_type_p (TYPE_MAIN_VARIANT (t1))\n+\t\t&& odr_type_p (TYPE_MAIN_VARIANT (t2))\n \t\t&& (TYPE_METHODS (TYPE_MAIN_VARIANT (t1))\n \t\t    != TYPE_METHODS (TYPE_MAIN_VARIANT (t2))))\n \t      {\n-\t\tfor (f1 = TYPE_METHODS (TYPE_MAIN_VARIANT (t1)),\n-\t\t     f2 = TYPE_METHODS (TYPE_MAIN_VARIANT (t2));\n-\t\t     f1 && f2 ; f1 = DECL_CHAIN (f1), f2 = DECL_CHAIN (f2))\n-\t\t  {\n-\t\t    if (DECL_ASSEMBLER_NAME (f1) != DECL_ASSEMBLER_NAME (f2))\n-\t\t      {\n-\t\t\twarn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t\t  G_(\"a different method of same type \"\n-\t\t\t\t     \"is defined in another translation unit\"));\n-\t\t\treturn false;\n-\t\t      }\n-\t\t    if (DECL_VIRTUAL_P (f1) != DECL_VIRTUAL_P (f2))\n-\t\t      {\n-\t\t\twarn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t\t  G_(\"s definition that differs by virtual \"\n-\t\t\t\t     \"keyword in another translation unit\"));\n-\t\t\treturn false;\n-\t\t      }\n-\t\t    if (DECL_VINDEX (f1) != DECL_VINDEX (f2))\n-\t\t      {\n-\t\t\twarn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t\t  G_(\"virtual table layout differs in another \"\n-\t\t\t\t     \"translation unit\"));\n-\t\t\treturn false;\n-\t\t      }\n-\t\t    if (odr_subtypes_equivalent_p (TREE_TYPE (f1), TREE_TYPE (f2), visited))\n-\t\t      {\n-\t\t\twarn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t\t  G_(\"method with incompatible type is defined \"\n-\t\t\t\t     \"in another translation unit\"));\n-\t\t\treturn false;\n-\t\t      }\n-\t\t  }\n-\t\tif (f1 || f2)\n+\t\t/* Currently free_lang_data sets TYPE_METHODS to error_mark_node\n+\t\t   if it is non-NULL so this loop will never realy execute.  */\n+\t\tif (TYPE_METHODS (TYPE_MAIN_VARIANT (t1)) != error_mark_node\n+\t\t    && TYPE_METHODS (TYPE_MAIN_VARIANT (t2)) != error_mark_node)\n+\t\t  for (f1 = TYPE_METHODS (TYPE_MAIN_VARIANT (t1)),\n+\t\t       f2 = TYPE_METHODS (TYPE_MAIN_VARIANT (t2));\n+\t\t       f1 && f2 ; f1 = DECL_CHAIN (f1), f2 = DECL_CHAIN (f2))\n+\t\t    {\n+\t\t      if (DECL_ASSEMBLER_NAME (f1) != DECL_ASSEMBLER_NAME (f2))\n+\t\t\t{\n+\t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n+\t\t\t\t    G_(\"a different method of same type \"\n+\t\t\t\t       \"is defined in another \"\n+\t\t\t\t       \"translation unit\"));\n+\t\t\t  return false;\n+\t\t\t}\n+\t\t      if (DECL_VIRTUAL_P (f1) != DECL_VIRTUAL_P (f2))\n+\t\t\t{\n+\t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n+\t\t\t\t    G_(\"s definition that differs by virtual \"\n+\t\t\t\t       \"keyword in another translation unit\"));\n+\t\t\t  return false;\n+\t\t\t}\n+\t\t      if (DECL_VINDEX (f1) != DECL_VINDEX (f2))\n+\t\t\t{\n+\t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n+\t\t\t\t    G_(\"virtual table layout differs \"\n+\t\t\t\t       \"in another translation unit\"));\n+\t\t\t  return false;\n+\t\t\t}\n+\t\t      if (odr_subtypes_equivalent_p (TREE_TYPE (f1),\n+\t\t\t\t\t\t     TREE_TYPE (f2), visited))\n+\t\t\t{\n+\t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n+\t\t\t\t    G_(\"method with incompatible type is \"\n+\t\t\t\t       \"defined in another translation unit\"));\n+\t\t\t  return false;\n+\t\t\t}\n+\t\t    }\n+\t\tif ((f1 == NULL) != (f2 == NULL))\n \t\t  {\n \t\t    warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\t      G_(\"a type with different number of methods \"\n@@ -1976,7 +2024,10 @@ get_odr_type (tree type, bool insert)\n       val->type = type;\n       val->bases = vNULL;\n       val->derived_types = vNULL;\n-      val->anonymous_namespace = type_in_anonymous_namespace_p (type);\n+      if (type_with_linkage_p (type))\n+        val->anonymous_namespace = type_in_anonymous_namespace_p (type);\n+      else\n+\tval->anonymous_namespace = 0;\n       build_bases = COMPLETE_TYPE_P (val->type);\n       insert_to_odr_array = true;\n       if (slot)"}, {"sha": "13c59a830bafafa08b8e74c88ec7e9189f945685", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a677ca1a53221276c0b382811c0351d381b35a/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a677ca1a53221276c0b382811c0351d381b35a/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=e7a677ca1a53221276c0b382811c0351d381b35a", "patch": "@@ -63,6 +63,7 @@ possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n \t\t\t\t   void **cache_token = NULL,\n \t\t\t\t   bool speuclative = false);\n odr_type get_odr_type (tree, bool insert = false);\n+bool odr_type_p (const_tree t);\n bool possible_polymorphic_call_target_p (tree ref, gimple stmt, struct cgraph_node *n);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t     const ipa_polymorphic_call_context &);\n@@ -153,23 +154,6 @@ possible_polymorphic_call_target_p (struct cgraph_edge *e,\n \t\t\t\t\t     context, n);\n }\n \n-/* Return true of T is type with One Definition Rule info attached. \n-   It means that either it is anonymous type or it has assembler name\n-   set.  */\n-\n-static inline bool\n-odr_type_p (const_tree t)\n-{\n-  if (type_in_anonymous_namespace_p (t))\n-    return true;\n-  /* We do not have this information when not in LTO, but we do not need\n-     to care, since it is used only for type merging.  */\n-  gcc_assert (in_lto_p || flag_lto);\n-\n-  return (TYPE_NAME (t)\n-          && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))));\n-}\n-\n /* Return true if BINFO corresponds to a type with virtual methods. \n \n    Every type has several BINFOs.  One is the BINFO associated by the type"}, {"sha": "c899f7df38ab6e5f5fdc5e12bf0329ee80b48377", "filename": "gcc/tree.c", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a677ca1a53221276c0b382811c0351d381b35a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a677ca1a53221276c0b382811c0351d381b35a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e7a677ca1a53221276c0b382811c0351d381b35a", "patch": "@@ -5160,27 +5160,33 @@ free_lang_data_in_type (tree type)\n static inline bool\n need_assembler_name_p (tree decl)\n {\n-  /* We use DECL_ASSEMBLER_NAME to hold mangled type names for One Definition Rule\n-     merging.  */\n+  /* We use DECL_ASSEMBLER_NAME to hold mangled type names for One Definition\n+     Rule merging.  This makes type_odr_p to return true on those types during\n+     LTO and by comparing the mangled name, we can say what types are intended\n+     to be equivalent across compilation unit.\n+\n+     We do not store names of type_in_anonymous_namespace_p.\n+\n+     Record, union and enumeration type have linkage that allows use\n+     to check type_in_anonymous_namespace_p. We do not mangle compound types\n+     that always can be compared structurally.\n+\n+     Similarly for builtin types, we compare properties of their main variant.\n+     A special case are integer types where mangling do make differences\n+     between char/signed char/unsigned char etc.  Storing name for these makes\n+     e.g.  -fno-signed-char/-fsigned-char mismatches to be handled well.\n+     See cp/mangle.c:write_builtin_type for details.  */\n+\n   if (flag_lto_odr_type_mering\n       && TREE_CODE (decl) == TYPE_DECL\n       && DECL_NAME (decl)\n       && decl == TYPE_NAME (TREE_TYPE (decl))\n-      && !is_lang_specific (TREE_TYPE (decl))\n-      /* Save some work. Names of builtin types are always derived from\n-\t properties of its main variant.  A special case are integer types\n-\t where mangling do make differences between char/signed char/unsigned\n-\t char etc.  Storing name for these makes e.g.\n-\t -fno-signed-char/-fsigned-char mismatches to be handled well.\n-\n-\t See cp/mangle.c:write_builtin_type for details.  */\n-      && (TREE_CODE (TREE_TYPE (decl)) != VOID_TYPE\n-\t  && TREE_CODE (TREE_TYPE (decl)) != BOOLEAN_TYPE\n-\t  && TREE_CODE (TREE_TYPE (decl)) != REAL_TYPE\n-\t  && TREE_CODE (TREE_TYPE (decl)) != FIXED_POINT_TYPE)\n       && !TYPE_ARTIFICIAL (TREE_TYPE (decl))\n-      && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE)\n-      && !type_in_anonymous_namespace_p (TREE_TYPE (decl)))\n+      && (((RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl))\n+\t   || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n+\t   && !type_in_anonymous_namespace_p (TREE_TYPE (decl)))\n+\t  || TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE)\n+      && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n     return !DECL_ASSEMBLER_NAME_SET_P (decl);\n   /* Only FUNCTION_DECLs and VAR_DECLs are considered.  */\n   if (TREE_CODE (decl) != FUNCTION_DECL\n@@ -12037,18 +12043,6 @@ obj_type_ref_class (tree ref)\n   return TREE_TYPE (ref);\n }\n \n-/* Return true if T is in anonymous namespace.  */\n-\n-bool\n-type_in_anonymous_namespace_p (const_tree t)\n-{\n-  /* TREE_PUBLIC of TYPE_STUB_DECL may not be properly set for\n-     bulitin types; those have CONTEXT NULL.  */\n-  if (!TYPE_CONTEXT (t))\n-    return false;\n-  return (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)));\n-}\n-\n /* Lookup sub-BINFO of BINFO of TYPE at offset POS.  */\n \n static tree"}]}