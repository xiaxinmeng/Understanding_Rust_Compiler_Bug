{"sha": "24809ca8414a96ac5a8fbc781f688d20a513559b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ4MDljYTg0MTRhOTZhYzVhOGZiYzc4MWY2ODhkMjBhNTEzNTU5Yg==", "commit": {"author": {"name": "Robert Schuster", "email": "thebohemian@gmx.net", "date": "2005-04-19T04:50:06Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-19T04:50:06Z"}, "message": "EventHandler.java: Reworked documentation.\n\n2005-04-19  Robert Schuster <thebohemian@gmx.net>\n\n\t* java/beans/EventHandler.java: Reworked documentation.\n\t(invoke): Fixed behavior to match spec.\n\nFrom-SVN: r98372", "tree": {"sha": "b02f6301a9fce41d41f2792253ad9e52b30989f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b02f6301a9fce41d41f2792253ad9e52b30989f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24809ca8414a96ac5a8fbc781f688d20a513559b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24809ca8414a96ac5a8fbc781f688d20a513559b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24809ca8414a96ac5a8fbc781f688d20a513559b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24809ca8414a96ac5a8fbc781f688d20a513559b/comments", "author": {"login": "thebohemian", "id": 336602, "node_id": "MDQ6VXNlcjMzNjYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/336602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thebohemian", "html_url": "https://github.com/thebohemian", "followers_url": "https://api.github.com/users/thebohemian/followers", "following_url": "https://api.github.com/users/thebohemian/following{/other_user}", "gists_url": "https://api.github.com/users/thebohemian/gists{/gist_id}", "starred_url": "https://api.github.com/users/thebohemian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thebohemian/subscriptions", "organizations_url": "https://api.github.com/users/thebohemian/orgs", "repos_url": "https://api.github.com/users/thebohemian/repos", "events_url": "https://api.github.com/users/thebohemian/events{/privacy}", "received_events_url": "https://api.github.com/users/thebohemian/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "617c100078a35698529545129b84d75bf9d05d2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617c100078a35698529545129b84d75bf9d05d2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617c100078a35698529545129b84d75bf9d05d2b"}], "stats": {"total": 542, "additions": 382, "deletions": 160}, "files": [{"sha": "1aa3fc0327ea9c708909276f9c33cb56de25309a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24809ca8414a96ac5a8fbc781f688d20a513559b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24809ca8414a96ac5a8fbc781f688d20a513559b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=24809ca8414a96ac5a8fbc781f688d20a513559b", "patch": "@@ -1,3 +1,8 @@\n+2005-04-19  Robert Schuster <thebohemian@gmx.net>\n+\n+\t* java/beans/EventHandler.java: Reworked documentation.\n+\t(invoke): Fixed behavior to match spec.\n+\n 2005-04-19  Michael Koch  <konqueror@gmx.de>\n \n \t* java/awt/print/PrinterJob.java"}, {"sha": "e2ca1414606f5d7ddd70e999dc54f28f2f6bb569", "filename": "libjava/java/beans/EventHandler.java", "status": "modified", "additions": 377, "deletions": 160, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24809ca8414a96ac5a8fbc781f688d20a513559b/libjava%2Fjava%2Fbeans%2FEventHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24809ca8414a96ac5a8fbc781f688d20a513559b/libjava%2Fjava%2Fbeans%2FEventHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FEventHandler.java?ref=24809ca8414a96ac5a8fbc781f688d20a513559b", "patch": "@@ -1,5 +1,5 @@\n /* java.beans.EventHandler\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -44,26 +44,18 @@\n import java.lang.reflect.Proxy;\n \n /**\n- * class EventHandler\n- *\n- * EventHandler forms a bridge between dynamically created listeners and\n- * arbitrary properties and methods.  The idea is that a Proxy that implements\n- * a listener class calls the EventHandler when a listener method is called.\n- * The Proxy calls invoke(), which dispatches the event to a method, called\n- * the action, in another object, called the target.\n- *\n- * The event passed to the listener method is used to access a prespecified\n- * property, which in turn is passed to the action method.\n+ * <p>EventHandler forms a bridge between dynamically created listeners and\n+ * arbitrary properties and methods.</p>\n  * \n- * Normally, call EventHandler.create(), which constructs an EventHandler and\n- * a Proxy for the listener interface.  When the listenerMethod gets called on\n- * the proxy, it in turn calls invoke on the attached EventHandler.  The\n- * invoke call extracts the bean property from the event object and passes it\n- * to the action method of target object.\n- *\n- * TODO: Add examples of using this thing.\n+ * <p>You can use this class to easily create listener implementations for\n+ * some basic interactions between an event source and its target. Using\n+ * the three static methods named <code>create</code> you can create\n+ * these listener implementations.</p>\n  * \n+ * <p>See the documentation of each method for usage examples.</p>\n+ *  \n  * @author Jerry Quinn (jlquinn@optonline.net)\n+ * @author Robert Schuster (thebohemian@gmx.net)\n  * @since 1.4\n  */\n public class EventHandler implements InvocationHandler\n@@ -80,6 +72,9 @@ public class EventHandler implements InvocationHandler\n   // The property to extract from an event passed to listenerMethod.\n   private String property;\n \n+  // The target objects Class.\n+  private Class targetClass;\n+  \n   // String class doesn't already have a capitalize routine.\n   private String capitalize(String s)\n   {\n@@ -89,14 +84,15 @@ private String capitalize(String s)\n   /**\n    * Creates a new <code>EventHandler</code> instance.\n    *\n-   * Typical creation is done with the create method, not by newing an\n-   * EventHandler.\n+   * <p>Typical creation is done with the create method, not by knewing an\n+   * EventHandler.</p>\n    *\n-   * This constructs an EventHandler that will connect the method\n+   * <p>This constructs an EventHandler that will connect the method\n    * listenerMethodName to target.action, extracting eventPropertyName from\n-   * the first argument of listenerMethodName. and sending it to action.\n-   *\n-   *\n+   * the first argument of listenerMethodName. and sending it to action.</p>\n+   * \n+   * <p>Throws a <code>NullPointerException</code> if the <code>target</code>\n+   * argument is <code>null</code>. \n    *\n    * @param target Object that will perform the action.\n    * @param action A property or method of the target.\n@@ -107,38 +103,44 @@ public EventHandler(Object target, String action, String eventPropertyName,\n \t\t      String listenerMethodName)\n   {\n     this.target = target;\n+    \n+    // Retrieving the class is done for two reasons:\n+    // 1) The class object is needed very frequently in the invoke() method.\n+    // 2) The constructor should throw a NullPointerException if target is null.\n+    targetClass = target.getClass();\n+    \n     this.action = action;\t// Turn this into a method or do we wait till\n-\t\t\t\t// runtime\n+    \t\t// runtime\n     property = eventPropertyName;\n     listenerMethod = listenerMethodName;\n   }\n \n   /**\n-   * Return the event property name.\n+   * Returns the event property name.\n    */\n   public String getEventPropertyName()\n   {\n     return property;\n   }\n \n   /**\n-   * Return the listener's method name.\n+   * Returns the listener's method name.\n    */\n   public String getListenerMethodName()\n   {\n     return listenerMethod;\n   }\n \n   /**\n-   * Return the target object.\n+   * Returns the target object.\n    */\n   public Object getTarget()\n   {\n     return target;\n   }\n \n   /**\n-   * Return the action method name.\n+   * Returns the action method name.\n    */\n   public String getAction()\n   {\n@@ -156,12 +158,7 @@ public String getAction()\n   // value will be a wrapper.  If we then take the type of the wrapper and use\n   // it to locate the action method that takes the native type, it won't match.\n   private Object[] getProperty(Object o, String prop)\n-    throws NoSuchMethodException, IllegalAccessException, InvocationTargetException\n   {\n-    // Use the event object when the property name to extract is null.\n-    if (prop == null)\n-      return new Object[] {o, o.getClass()};\n-\n     // Isolate the first property name from a.b.c.\n     int pos;\n     String rest = null;\n@@ -179,121 +176,287 @@ private Object[] getProperty(Object o, String prop)\n \tgetter = o.getClass().getMethod(\"is\" + capitalize(prop),\n \t\t\t\t\t\t null);\n       }\n-    catch (NoSuchMethodException e)\n+    catch (NoSuchMethodException nsme1)\n       {\n-\t// Look for regular property getter getProperty\n-\tgetter = o.getClass().getMethod(\"get\" + capitalize(prop),\n+        try {\n+          // Look for regular property getter getProperty\n+          getter = o.getClass().getMethod(\"get\" + capitalize(prop),\n \t\t\t\t\t\t null);\n+        } catch(NoSuchMethodException nsme2) {\n+            try {\n+            // Finally look for a method of the name prop\n+            getter = o.getClass().getMethod(prop, null);\n+            } catch(NoSuchMethodException nsme3) {\n+                // Ok, give up with an intelligent hint for the user.\n+                throw new RuntimeException(\"Method not called: Could not find a property or method '\" + prop\n+                        + \"' in \" + o.getClass() + \" while following the property argument '\" + property + \"'.\");\n+            }\n+        }\n       }\n-    Object val = getter.invoke(o, null);\n-\n-    if (rest != null)\n-      return getProperty(val, rest);\n-\n-    return new Object[] {val, getter.getReturnType()};\n+    try {\n+      Object val = getter.invoke(o, null);\n+\n+      if (rest != null)\n+        return getProperty(val, rest);\n+\n+      return new Object[] {val, getter.getReturnType()};\n+    } catch(InvocationTargetException ite) {\n+        throw new RuntimeException(\"Method not called: Property or method '\" + prop + \"' has thrown an exception.\", ite);\n+    } catch(IllegalAccessException iae) {\n+        // This cannot happen because we looked up method with Class.getMethod()\n+        // which returns public methods only.\n+        throw (InternalError) new InternalError(\"Non-public method was invoked.\").initCause(iae);\n+    }\n   }\n \n-\n   /**\n-   * Invoke the event handler.\n-   *\n-   * Proxy is the object that was used, method is the method that was invoked\n-   * on object, and arguments is the set of arguments passed to this method.\n-   * We assume that the first argument is the event to extract a property\n-   * from.\n-   *\n-   * Assuming that method matches the listener method specified when creating\n-   * this EventHandler, the desired property is extracted from this argument.\n-   * The property is passed to target.setAction(), if possible.  Otherwise\n-   * target.action() is called, where action is the string fed to the\n-   * constructor.\n-   *\n-   * For now we punt on indexed properties.  Sun docs are not clear to me\n-   * about this.\n-   *\n-   * @param proxy The proxy object that had method invoked on it.\n-   * @param method The method that was invoked.\n-   * @param arguments Arguments to method.\n-   * @return Result of invoking target.action on the event property\n+   * Invokes the <code>EventHandler</code>.\n+   * \n+   * <p>This method is normally called by the listener's proxy implementation.</p>\n+   * \n+   * @param proxy The listener interface that is implemented using\n+   * the proxy mechanism.\n+   * @param method The method that was called on the proxy instance.\n+   * @param arguments The arguments which where given to the method.\n+   * @throws Throwable <code>NoSuchMethodException</code> is thrown when the EventHandler's\n+   * action method or property cannot be found.\n    */\n   public Object invoke(Object proxy, Method method, Object[] arguments)\n-    throws Exception\n   {\n-    // Do we actually need the proxy?\n-    if (method == null)\n-      throw new RuntimeException(\"Invoking null method\");\n+      try {\n+      // The method instance of the target object. We have to find out which\n+      // one we have to invoke.\n+      Method actionMethod = null;\n \n     // Listener methods that weren't specified are ignored.  If listenerMethod\n     // is null, then all listener methods are processed.\n     if (listenerMethod != null && !method.getName().equals(listenerMethod))\n       return null;\n \n-    // Extract the first arg from arguments and do getProperty on arg\n-    if (arguments == null || arguments.length == 0)\n-      return null;\n-    Object event = arguments[0]; // We hope :-)\n-\n-    // Obtain the property XXX propertyType keeps showing up null - why?\n-    // because the object inside getProperty changes, but the ref variable\n-    // can't change this way, dolt!  need a better way to get both values out\n-    // - need method and object to do the invoke and get return type\n-    Object v[] = getProperty(event, property);\n-    Object val = v[0];\n-    Class propertyType = (Class) v[1];\n-\n-    // Find the actual method of target to invoke.  We can't do this in the\n-    // constructor since we don't know the type of the property we extracted\n-    // from the event then.\n-    //\n-    // action can be either a property or a method.  Sun's docs seem to imply\n-    // that action should be treated as a property first, and then a method,\n-    // but don't specifically say it.\n-    //\n-    // XXX check what happens with native type wrappers.  The better thing to\n-    // do is look at the return type of the method\n-    Method actionMethod;\n-    try\n+    // If a property is defined we definitely need a valid object at\n+    // arguments[0] that can be used to retrieve a value to which the\n+    // property of the target gets set.\n+    if(property != null) {\n+      // Extracts the argument. We will let it fail with a NullPointerException\n+      // the caller used a listener method that has no arguments.\n+      Object event = arguments[0];\n+\n+      // Obtains the property XXX propertyType keeps showing up null - why?\n+      // because the object inside getProperty changes, but the ref variable\n+      // can't change this way, dolt!  need a better way to get both values out\n+      // - need method and object to do the invoke and get return type\n+      Object v[] = getProperty(event, property);\n+      Object[] args = new Object[] { v[0] };\n+      \n+      // Changes the class array that controls which method signature we are going\n+      // to look up in the target object.\n+      Class[] argTypes = new Class[] { initClass((Class) v[1]) };\n+    \n+      // Tries to  find a setter method to which we can apply the\n+      while(argTypes[0] != null) {\n+      try\n       {\n-\t// Look for a property setter for action.\n-\tactionMethod = \n-\t  target.getClass().getMethod(\"set\" + capitalize(action),\n-\t\t\t\t      new Class[] {propertyType});\n+        // Look for a property setter for action.\n+        actionMethod = targetClass.getMethod(\"set\" + capitalize(action), argTypes);\n+\n+        return actionMethod.invoke(target, args);\n       }\n     catch (NoSuchMethodException e)\n       {\n-\t// If action as property didn't work, try as method.\n-\ttry\n-\t  {\n-\t    actionMethod = \n-\t      target.getClass().getMethod(action, new Class[] {propertyType});\n-\t  }\n-\tcatch (NoSuchMethodException e1)\n-\t  {\n-\t    // When event property is null, we may call action with no args\n-\t    if (property == null)\n-\t      {\n-\t\tactionMethod =\n-\t\t  target.getClass().getMethod(action, null);\n-\t\treturn actionMethod.invoke(target, null);\n-\t      }\n-\t    else\n-\t      throw e1;\n-\t  }\n+        // If action as property didn't work, try as method later.\n+      }\n+    \n+      argTypes[0] = nextClass(argTypes[0]);\n+      }\n+      \n+      // We could not find a suitable setter method. Now we try again interpreting\n+      // action as the method name itself.\n+      // Since we probably have changed the block local argTypes array \n+      // we need to rebuild it.\n+      argTypes = new Class[] { initClass((Class) v[1]) };\n+    \n+      // Tries to  find a setter method to which we can apply the\n+      while(argTypes[0] != null) {\n+        try\n+        {\n+          actionMethod = targetClass.getMethod(action, argTypes);\n+\n+          return actionMethod.invoke(target, args);\n+        }\n+        catch (NoSuchMethodException e)\n+        {\n+        }\n+        \n+        argTypes[0] = nextClass(argTypes[0]);\n+      }\n+        \n+        throw new RuntimeException(\"Method not called: Could not find a public method named '\"\n+                + action + \"' in target \" + targetClass + \" which takes a '\"\n+                + v[1] + \"' argument or a property of this type.\");\n+      }      \n+  \n+    // If property was null we will search for a no-argument method here.\n+    // Note: The ordering of method lookups is important because we want to prefer no-argument\n+    // calls like the JDK does. This means if we have actionMethod() and actionMethod(Event) we will\n+    // call the first *EVEN* if we have a valid argument for the second method. This is behavior compliant\n+    // to the JDK.\n+    // If actionMethod() is not available but there is a actionMethod(Event) we take this. That makes us\n+    // more specification compliant than the JDK itself because this one will fail in such a case.\n+    try\n+      {\n+      actionMethod = targetClass.getMethod(action, null);\n+      }\n+    catch(NoSuchMethodException nsme)\n+      {\n+        // Note: If we want to be really strict the specification says that a no-argument method should\n+        // accept an EventObject (or subclass I guess). However since the official implementation is broken\n+        // anyways, it's more flexible without the EventObject restriction and we are compatible on everything\n+        // else this can stay this way.\n+        if(arguments != null && arguments.length >= 1/* && arguments[0] instanceof EventObject*/) {\n+            Class[] targetArgTypes = new Class[] { initClass(arguments[0].getClass()) };\n+            \n+            while(targetArgTypes[0] != null) {\n+                try\n+                {\n+                  // If no property exists we expect the first element of the arguments to be\n+                  // an EventObject which is then applied to the target method.\n+      \n+                  actionMethod = targetClass.getMethod(action, targetArgTypes);\n+              \n+                  return actionMethod.invoke(target, new Object[] { arguments[0] });\n+                }\n+                catch(NoSuchMethodException nsme2)\n+                {\n+                    \n+                }\n+                \n+                targetArgTypes[0] = nextClass(targetArgTypes[0]);\n+            }\n+          \n+        }\n       }\n \n+    // If we do not have a Method instance at this point this means that all our tries\n+    // failed. The JDK throws an ArrayIndexOutOfBoundsException in this case.\n+    if(actionMethod == null)\n+      throw new ArrayIndexOutOfBoundsException(0);\n+    \n     // Invoke target.action(property)\n-    return actionMethod.invoke(target, new Object[] {val});\n+    return actionMethod.invoke(target, null);\n+      } catch(InvocationTargetException ite) {\n+         throw new RuntimeException(ite.getCause());\n+      } catch(IllegalAccessException iae) {\n+          // Cannot happen because we always use getMethod() which returns public\n+          // methods only. Otherwise there is something seriously broken in\n+          // GNU Classpath.\n+          throw (InternalError) new InternalError(\"Non-public method was invoked.\").initCause(iae);\n+      }\n+  }\n+  \n+  /**\n+   * <p>Returns the primitive type for every wrapper class or the\n+   * class itself if it is no wrapper class.</p>\n+   * \n+   * <p>This is needed because to be able to find both kinds of methods:\n+   * One that takes a wrapper class as the first argument and one that\n+   * accepts a primitive instead.</p>\n+   */\n+  private Class initClass(Class klass) {\n+   if(klass == Boolean.class) {\n+    return Boolean.TYPE;    \n+   } else if(klass == Byte.class) {\n+    return Byte.TYPE;   \n+   } else if(klass == Short.class) {\n+    return Short.TYPE;   \n+   } else if(klass == Integer.class) {\n+    return Integer.TYPE;   \n+   } else if(klass == Long.class) {\n+    return Long.TYPE;   \n+   } else if(klass == Float.class) {\n+    return Float.TYPE;   \n+   } else if(klass == Double.class) {\n+    return Double.TYPE;   \n+   } else {\n+    return klass;   \n+   }\n   }\n \n   /**\n-   * Construct a new object to dispatch events.\n-   *\n-   * Equivalent to:\n-   * create(listenerInterface, target, action, null, null)\n+   * \n+   * \n+   * @param klass\n+   * @return\n+   */\n+  private Class nextClass(Class klass) {\n+    if(klass == Boolean.TYPE) {\n+    return Boolean.class;    \n+   } else if(klass == Byte.TYPE) {\n+    return Byte.class;   \n+   } else if(klass == Short.TYPE) {\n+    return Short.class;   \n+   } else if(klass == Integer.TYPE) {\n+    return Integer.class;   \n+   } else if(klass == Long.TYPE) {\n+    return Long.class;   \n+   } else if(klass == Float.TYPE) {\n+    return Float.class;   \n+   } else if(klass == Double.TYPE) {\n+    return Double.class;   \n+   } else {\n+    return klass.getSuperclass();\n+   }\n+   }\n+  \n+  /**\n+   * <p>Constructs an implementation of <code>listenerInterface</code>\n+   * to dispatch events.</p>\n+   * \n+   * <p>You can use such an implementation to simply call a public\n+   * no-argument method of an arbitrary target object or to forward\n+   * the first argument of the listener method to the target method.</p>\n+   * \n+   * <p>Call this method like:</p>\n+   * <code>\n+   * button.addActionListener((ActionListener)\n+   *    EventHandler.create(ActionListener.class, target, \"dispose\"));\n+   * </code>\n+   * \n+   * <p>to achieve the following behavior:</p>\n+   * <code>\n+   * button.addActionListener(new ActionListener() {\n+   *    public void actionPerformed(ActionEvent ae) {\n+   *        target.dispose();\n+   *    }\n+   * });\n+   * </code>\n+   * \n+   * <p>That means if you need a listener implementation that simply calls a\n+   * a no-argument method on a given instance for <strong>each</strong>\n+   * method of the listener interface.</p>\n+   * \n+   * <p>Note: The <code>action</code> is interpreted as a method name. If your target object\n+   * has no no-argument method of the given name the EventHandler tries to find\n+   * a method with the same name but which can accept the first argument of the\n+   * listener method. Usually this will be an event object but any other object\n+   * will be forwarded, too. Keep in mind that using a property name instead of a\n+   * real method here is wrong and will throw an <code>ArrayIndexOutOfBoundsException</code>\n+   * whenever one of the listener methods is called.<p/>\n    *\n-   * I.e. all listenerInterface methods are mapped to\n-   * target.action(EventObject) or target.action(), if the first doesn't\n-   * exist.\n+   * <p>The <code>EventHandler</code> will automatically convert primitives\n+   * to their wrapper class and vice versa. Furthermore it will call\n+   * a target method if it accepts a superclass of the type of the\n+   * first argument of the listener method.</p>\n+   * \n+   * <p>In case that the method of the target object throws an exception\n+   * it will be wrapped in a <code>RuntimeException</code> and thrown out\n+   * of the listener method.</p>\n+   * \n+   * <p>In case that the method of the target object cannot be found an\n+   * <code>ArrayIndexOutOfBoundsException</code> will be thrown when the\n+   * listener method is invoked.</p>\n+   * \n+   * <p>A call to this method is equivalent to:\n+   * <code>create(listenerInterface, target, action, null, null)</code></p>\n    *\n    * @param listenerInterface Listener interface to implement.\n    * @param target Object to invoke action on.\n@@ -306,14 +469,82 @@ public static Object create(Class listenerInterface, Object target, String actio\n   }\n \n   /**\n-   * Construct a new object to dispatch events.\n+   * <p>Constructs an implementation of <code>listenerInterface</code>\n+   * to dispatch events.</p>\n    *\n-   * Equivalent to:\n-   * create(listenerInterface, target, action, eventPropertyName, null)\n+   * <p>Use this method if you want to create an implementation that retrieves\n+   * a property value from the <b>first</b> argument of the listener method\n+   * and applies it to the target's property or method. This first argument\n+   * of the listener is usually an event object but any other object is\n+   * valid, too.</p>\n+   * \n+   * <p>You can set the value of <code>eventPropertyName</code> to \"prop\"\n+   * to denote the retrieval of a property named \"prop\" from the event\n+   * object. In case that no such property exists the <code>EventHandler</code>\n+   * will try to find a method with that name.</p>\n+   * \n+   * <p>If you set <code>eventPropertyName</code> to a value like this \"a.b.c\"\n+   * <code>EventHandler</code> will recursively evaluate the properties \"a\", \"b\"\n+   * and \"c\". Again if no property can be found the <code>EventHandler</code>\n+   * tries a method name instead. This allows mixing the names, too: \"a.toString\"\n+   * will retrieve the property \"a\" from the event object and will then call\n+   * the method \"toString\" on it.</p>\n+   * \n+   * <p>An exception thrown in any of these methods will provoke a\n+   * <code>RuntimeException</code> to be thrown which contains an\n+   * <code>InvocationTargetException</code> containing the triggering exception.</p>\n+   * \n+   * <p>If you set <code>eventPropertyName</code> to a non-null value the\n+   * <code>action</code> parameter will be interpreted as a property name\n+   * or a method name of the target object.</p>\n+   *   \n+   * <p>Any object retrieved from the event object and applied to the\n+   * target will converted from primitives to their wrapper class or\n+   * vice versa or applied to a method that accepts a superclass\n+   * of the object.</p>\n    *\n-   * I.e. all listenerInterface methods are mapped to\n-   * target.action(event.getEventPropertyName)\n+   * <p>Examples:</p>\n+   * <p>The following code:</p><code>\n+   * button.addActionListener(\n+   *    new ActionListener() {\n+   *        public void actionPerformed(ActionEvent ae) {\n+   *            Object o = ae.getSource().getClass().getName();\n+   *            textField.setText((String) o);\n+   *        }\n+   *    });\n+   * </code>\n+   * \n+   * <p>Can be expressed using the <code>EventHandler</code> like this:</p>\n+   * <p>\n+   * <code>button.addActionListener((ActionListener)\n+   *    EventHandler.create(ActionListener.class, textField, \"text\", \"source.class.name\");\n+   * <code>\n+   * </p>\n+   * \n+   * <p>As said above you can specify the target as a method, too:</p>\n+   * <p>\n+   * <code>button.addActionListener((ActionListener)\n+   *    EventHandler.create(ActionListener.class, textField, \"setText\", \"source.class.name\");\n+   * <code>\n+   * </p>\n+   * \n+   * <p>Furthermore you can use method names in the property:</p>\n+   * <p>\n+   * <code>button.addActionListener((ActionListener)\n+   *    EventHandler.create(ActionListener.class, textField, \"setText\", \"getSource.getClass.getName\");\n+   * <code>\n+   * </p>\n    * \n+   * <p>Finally you can mix names:</p>\n+   * <p>\n+   * <code>button.addActionListener((ActionListener)\n+   *    EventHandler.create(ActionListener.class, textField, \"setText\", \"source.getClass.name\");\n+   * <code>\n+   * </p>\n+   * \n+   * <p>A call to this method is equivalent to:\n+   * <code>create(listenerInterface, target, action, null, null)</code>\n+   * </p>\n    *\n    * @param listenerInterface Listener interface to implement.\n    * @param target Object to invoke action on.\n@@ -327,41 +558,27 @@ public static Object create(Class listenerInterface, Object target,\n     return create(listenerInterface, target, action, eventPropertyName, null);\n   }\n \n-\n   /**\n-   * Construct a new object to dispatch events.\n-   *\n-   * This creates an object that acts as a proxy for the method\n-   * listenerMethodName in listenerInterface.  When the listener method is\n-   * activated, the object extracts eventPropertyName from the event.  Then it\n-   * passes the property to the method target.setAction, or target.action if\n-   * action is not a property with a setter.\n-   *\n-   * For example, EventHandler.create(MouseListener.class, test, \"pushed\",\n-   * \"button\", \"mouseClicked\") generates a proxy object that implements\n-   * MouseListener, at least for the method mouseClicked().  The other methods\n-   * of MouseListener are null operations.  When mouseClicked is invoked, the\n-   * generated object extracts the button property from the MouseEvent,\n-   * i.e. event.getButton(), and calls test.setPushed() with the result.  So under\n-   * the covers the following happens:\n+   * <p>Constructs an implementation of <code>listenerInterface</code>\n+   * to dispatch events.</p>\n    *\n-   * <CODE>\n-   * object.mouseClicked(MouseEvent e) { test.setPushed(e.getButton()); }\n-   * </CODE>\n-   *\n-   * The Sun spec specifies a hierarchical property naming scheme.  Generally\n-   * if the property is a.b.c, this corresponds to event.getA().getB().getC()\n-   * or event.getA().getB().isC().  I don't see how you specify an indexed\n-   * property, though.  This may be a limitation of the Sun implementation as\n-   * well.  The spec doesn't seem to address it.\n+   * <p>Besides the functionality described for {@link create(Class, Object, String)}\n+   * and {@link create(Class, Object, String, String)} this method allows you\n+   * to filter the listener method that should have an effect. Look at these\n+   * method's documentation for more information about the <code>EventHandler</code>'s\n+   * usage.</p>\n    * \n-   * If eventPropertyName is null, EventHandler instead uses the event object\n-   * in place of a property, i.e. it calls target.action(EventObject).  If\n-   * there is no method named action taking an EventObject argument,\n-   * EventHandler looks for a method target.action() taking no arguments.\n-   *\n-   * If listenerMethodName is null, every method in listenerInterface gets\n-   * mapped to target.action, rather than the specified listener method.\n+   * <p>If you want to call <code>dispose</code> on a <code>JFrame</code> instance\n+   * when the <code>WindowListener.windowClosing()</code> method was invoked use\n+   * the following code:</p>\n+   * <p>\n+   * <code>\n+   * EventHandler.create(WindowListener.class, jframeInstance, \"dispose\", null, \"windowClosing\");\n+   * </code>\n+   * </p>\n+   * \n+   * <p>A <code>NullPointerException</code> is thrown if the <code>listenerInterface</code>\n+   * or <code>target</code> argument are <code>null</code>.\n    * \n    * @param listenerInterface Listener interface to implement.\n    * @param target Object to invoke action on."}]}