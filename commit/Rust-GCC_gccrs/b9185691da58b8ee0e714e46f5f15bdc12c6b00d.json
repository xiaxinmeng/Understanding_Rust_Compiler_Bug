{"sha": "b9185691da58b8ee0e714e46f5f15bdc12c6b00d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkxODU2OTFkYTU4YjhlZTBlNzE0ZTQ2ZjVmMTViZGMxMmM2YjAwZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-07-08T06:41:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-07-08T06:41:13Z"}, "message": "re PR bootstrap/16326 (Bootstrap failure after \"RTL prologue/epilogue for SPARC\" patch)\n\n\tPR bootstrap/16326\n\t* reorg.c: Revert 2004-06-30 change.\n\t(find_end_label): If HAVE_epilogue and !HAVE_return,\n\treturn 0 instead of creating a label at the end of the insn chain.\n\t(optimize_skip): Account for the failure mode of find_end_label.\n\t(fill_simple_delay_slots): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t(relax_delay_slots): Likewise.\n\nFrom-SVN: r84273", "tree": {"sha": "454ddf1767762dfc1ccdad5d13dd948be2f91726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/454ddf1767762dfc1ccdad5d13dd948be2f91726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9185691da58b8ee0e714e46f5f15bdc12c6b00d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9185691da58b8ee0e714e46f5f15bdc12c6b00d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9185691da58b8ee0e714e46f5f15bdc12c6b00d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9185691da58b8ee0e714e46f5f15bdc12c6b00d/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6d025598ff69c2a3771e33e909db556d3ac9443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d025598ff69c2a3771e33e909db556d3ac9443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6d025598ff69c2a3771e33e909db556d3ac9443"}], "stats": {"total": 158, "additions": 96, "deletions": 62}, "files": [{"sha": "9e1b8ee5d2fd4a0e28da79bce748732eb58f6048", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9185691da58b8ee0e714e46f5f15bdc12c6b00d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9185691da58b8ee0e714e46f5f15bdc12c6b00d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9185691da58b8ee0e714e46f5f15bdc12c6b00d", "patch": "@@ -1,3 +1,14 @@\n+2004-07-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR bootstrap/16326\n+\t* reorg.c: Revert 2004-06-30 change.\n+\t(find_end_label): If HAVE_epilogue and !HAVE_return,\n+\treturn 0 instead of creating a label at the end of the insn chain.\n+\t(optimize_skip): Account for the failure mode of find_end_label.\n+\t(fill_simple_delay_slots): Likewise.\n+\t(fill_slots_from_thread): Likewise.\n+\t(relax_delay_slots): Likewise.\n+\n 2004-07-08  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-flow.h (addressable_vars): Declare."}, {"sha": "eb3836696c1922e9ae25e12528e3e1c42a051c33", "filename": "gcc/reorg.c", "status": "modified", "additions": 85, "deletions": 62, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9185691da58b8ee0e714e46f5f15bdc12c6b00d/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9185691da58b8ee0e714e46f5f15bdc12c6b00d/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=b9185691da58b8ee0e714e46f5f15bdc12c6b00d", "patch": "@@ -317,23 +317,25 @@ insn_sets_resource_p (rtx insn, struct resources *res,\n   mark_set_resources (insn, &insn_sets, 0, include_delayed_effects);\n   return resource_conflicts_p (&insn_sets, res);\n }\n-\n-/* Return TRUE if INSN is a return, possibly with a filled delay slot.  */\n-\n-static bool\n-return_insn_p (rtx insn)\n-{\n-  if (GET_CODE (insn) == JUMP_INSN && GET_CODE (PATTERN (insn)) == RETURN)\n-    return true;\n-\n-  if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-    return return_insn_p (XVECEXP (PATTERN (insn), 0, 0));\n-\n-  return false;\n-}\n \f\n-/* Find a label at the end of the function or before a RETURN.  If there is\n-   none, make one.  */\n+/* Find a label at the end of the function or before a RETURN.  If there\n+   is none, try to make one.  If that fails, returns 0.\n+\n+   The property of such a label is that it is placed just before the\n+   epilogue or a bare RETURN insn, so that another bare RETURN can be\n+   turned into a jump to the label unconditionally.  In particular, the\n+   label cannot be placed before a RETURN insn with a filled delay slot.\n+\n+   ??? There may be a problem with the current implementation.  Suppose\n+   we start with a bare RETURN insn and call find_end_label.  It may set\n+   end_of_function_label just before the RETURN.  Suppose the machinery\n+   is able to fill the delay slot of the RETURN insn afterwards.  Then\n+   end_of_function_label is no longer valid according to the property\n+   described above and find_end_label will still return it unmodified.\n+   Note that this is probably mitigated by the following observation:\n+   once end_of_function_label is made, it is very likely the target of\n+   a jump, so filling the delay slot of the RETURN will be much more\n+   difficult.  */\n \n static rtx\n find_end_label (void)\n@@ -358,13 +360,15 @@ find_end_label (void)\n   /* When a target threads its epilogue we might already have a\n      suitable return insn.  If so put a label before it for the\n      end_of_function_label.  */\n-  if (GET_CODE (insn) == BARRIER && return_insn_p (PREV_INSN (insn)))\n+  if (GET_CODE (insn) == BARRIER\n+      && GET_CODE (PREV_INSN (insn)) == JUMP_INSN\n+      && GET_CODE (PATTERN (PREV_INSN (insn))) == RETURN)\n     {\n       rtx temp = PREV_INSN (PREV_INSN (insn));\n       end_of_function_label = gen_label_rtx ();\n       LABEL_NUSES (end_of_function_label) = 0;\n \n-      /* Put the label before an USE insn that may precede the RETURN insn.  */\n+      /* Put the label before an USE insns that may precede the RETURN insn.  */\n       while (GET_CODE (temp) == USE)\n \ttemp = PREV_INSN (temp);\n \n@@ -380,7 +384,8 @@ find_end_label (void)\n       /* If the basic block reorder pass moves the return insn to\n \t some other place try to locate it again and put our\n \t end_of_function_label there.  */\n-      while (insn && ! return_insn_p (insn))\n+      while (insn && ! (GET_CODE (insn) == JUMP_INSN\n+\t\t        && (GET_CODE (PATTERN (insn)) == RETURN)))\n \tinsn = PREV_INSN (insn);\n       if (insn)\n \t{\n@@ -395,6 +400,22 @@ find_end_label (void)\n \t}\n       else\n \t{\n+#ifdef HAVE_epilogue\n+\t  if (HAVE_epilogue\n+#ifdef HAVE_return\n+\t      && ! HAVE_return\n+#endif\n+\t      )\n+\t    {\n+\t      /* The RETURN insn has its delay slot filled so we cannot\n+\t\t emit the label just before it.  Since we already have\n+\t\t an epilogue and cannot emit a new RETURN, we cannot\n+\t\t emit the label at all.  */\n+\t      end_of_function_label = NULL_RTX;\n+\t      return end_of_function_label;\n+\t    }\n+#endif /* HAVE_epilogue */\n+\n \t  /* Otherwise, make a new label and emit a RETURN and BARRIER,\n \t     if needed.  */\n \t  emit_label (end_of_function_label);\n@@ -742,7 +763,6 @@ optimize_skip (rtx insn)\n   rtx trial = next_nonnote_insn (insn);\n   rtx next_trial = next_active_insn (trial);\n   rtx delay_list = 0;\n-  rtx target_label;\n   int flags;\n \n   flags = get_jump_flags (insn, JUMP_LABEL (insn));\n@@ -791,17 +811,20 @@ optimize_skip (rtx insn)\n \t  && (simplejump_p (next_trial)\n \t      || GET_CODE (PATTERN (next_trial)) == RETURN))\n \t{\n-\t  target_label = JUMP_LABEL (next_trial);\n+\t  rtx target_label = JUMP_LABEL (next_trial);\n \t  if (target_label == 0)\n \t    target_label = find_end_label ();\n \n-\t  /* Recompute the flags based on TARGET_LABEL since threading\n-\t     the jump to TARGET_LABEL may change the direction of the\n-\t     jump (which may change the circumstances in which the\n-\t     delay slot is nullified).  */\n-\t  flags = get_jump_flags (insn, target_label);\n-\t  if (eligible_for_annul_true (insn, 0, trial, flags))\n-\t    reorg_redirect_jump (insn, target_label);\n+\t  if (target_label)\n+\t    {\n+\t      /* Recompute the flags based on TARGET_LABEL since threading\n+\t\t the jump to TARGET_LABEL may change the direction of the\n+\t\t jump (which may change the circumstances in which the\n+\t\t delay slot is nullified).  */\n+\t      flags = get_jump_flags (insn, target_label);\n+\t      if (eligible_for_annul_true (insn, 0, trial, flags))\n+\t\treorg_redirect_jump (insn, target_label);\n+\t    }\n \t}\n \n       INSN_ANNULLED_BRANCH_P (insn) = 1;\n@@ -2373,15 +2396,18 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      else\n \t\tnew_label = find_end_label ();\n \n-\t      delay_list\n-\t\t= add_to_delay_list (copy_rtx (next_trial), delay_list);\n-\t      slots_filled++;\n-\t      reorg_redirect_jump (trial, new_label);\n-\n-\t      /* If we merged because we both jumped to the same place,\n-\t\t redirect the original insn also.  */\n-\t      if (target)\n-\t\treorg_redirect_jump (insn, new_label);\n+\t      if (new_label)\n+\t        {\n+\t\t  delay_list\n+\t\t    = add_to_delay_list (copy_rtx (next_trial), delay_list);\n+\t\t  slots_filled++;\n+\t\t  reorg_redirect_jump (trial, new_label);\n+\n+\t\t  /* If we merged because we both jumped to the same place,\n+\t\t     redirect the original insn also.  */\n+\t\t  if (target)\n+\t\t    reorg_redirect_jump (insn, new_label);\n+\t\t}\n \t    }\n \t}\n \n@@ -2926,7 +2952,8 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n       else\n \tlabel = get_label_before (new_thread);\n \n-      reorg_redirect_jump (insn, label);\n+      if (label)\n+\treorg_redirect_jump (insn, label);\n     }\n \n   return delay_list;\n@@ -3094,21 +3121,22 @@ relax_delay_slots (rtx first)\n \t  if (target_label == 0)\n \t    target_label = find_end_label ();\n \n-\t  if (next_active_insn (target_label) == next\n+\t  if (target_label && next_active_insn (target_label) == next\n \t      && ! condjump_in_parallel_p (insn))\n \t    {\n \t      delete_jump (insn);\n \t      continue;\n \t    }\n \n-\t  if (target_label != JUMP_LABEL (insn))\n+\t  if (target_label && target_label != JUMP_LABEL (insn))\n \t    reorg_redirect_jump (insn, target_label);\n \n \t  /* See if this jump branches around an unconditional jump.\n \t     If so, invert this jump and point it to the target of the\n \t     second jump.  */\n \t  if (next && GET_CODE (next) == JUMP_INSN\n \t      && (simplejump_p (next) || GET_CODE (PATTERN (next)) == RETURN)\n+\t      && target_label\n \t      && next_active_insn (target_label) == next_active_insn (next)\n \t      && no_labels_between_p (insn, next))\n \t    {\n@@ -3242,7 +3270,7 @@ relax_delay_slots (rtx first)\n \t  if (trial == 0)\n \t    trial = find_end_label ();\n \n-\t  if (trial != target_label\n+\t  if (trial && trial != target_label\n \t      && redirect_with_delay_slots_safe_p (delay_insn, trial, insn))\n \t    {\n \t      reorg_redirect_jump (delay_insn, trial);\n@@ -3256,23 +3284,24 @@ relax_delay_slots (rtx first)\n \t      && redundant_insn (trial, insn, 0)\n \t      && ! can_throw_internal (trial))\n \t    {\n-\t      rtx tmp;\n-\n \t      /* Figure out where to emit the special USE insn so we don't\n \t\t later incorrectly compute register live/death info.  */\n-\t      tmp = next_active_insn (trial);\n+\t      rtx tmp = next_active_insn (trial);\n \t      if (tmp == 0)\n \t\ttmp = find_end_label ();\n \n-\t      /* Insert the special USE insn and update dataflow info.  */\n-\t      update_block (trial, tmp);\n+\t      if (tmp)\n+\t        {\n+\t\t  /* Insert the special USE insn and update dataflow info.  */\n+\t\t  update_block (trial, tmp);\n \n-\t      /* Now emit a label before the special USE insn, and\n-\t\t redirect our jump to the new label.  */\n-\t      target_label = get_label_before (PREV_INSN (tmp));\n-\t      reorg_redirect_jump (delay_insn, target_label);\n-\t      next = insn;\n-\t      continue;\n+\t\t  /* Now emit a label before the special USE insn, and\n+\t\t     redirect our jump to the new label.  */\n+\t\t  target_label = get_label_before (PREV_INSN (tmp));\n+\t\t  reorg_redirect_jump (delay_insn, target_label);\n+\t\t  next = insn;\n+\t\t  continue;\n+\t\t}\n \t    }\n \n \t  /* Similarly, if it is an unconditional jump with one insn in its\n@@ -3286,17 +3315,10 @@ relax_delay_slots (rtx first)\n \t    {\n \t      target_label = JUMP_LABEL (XVECEXP (PATTERN (trial), 0, 0));\n \t      if (target_label == 0)\n-\t\t{\n-\t\t  target_label = find_end_label ();\n-\t\t  /* The following condition may be true if TRIAL contains\n-\t\t     the unique RETURN.  In this case, threading would be\n-\t\t     a nop and we would enter an infinite loop if we did it.  */\n-\t\t  if (next_active_insn (target_label) == trial)\n-\t\t    target_label = 0;\n-\t\t}\n+\t\ttarget_label = find_end_label ();\n \n \t      if (target_label\n-\t\t  && redirect_with_delay_slots_safe_p (delay_insn, target_label,\n+\t          && redirect_with_delay_slots_safe_p (delay_insn, target_label,\n \t\t\t\t\t\t       insn))\n \t\t{\n \t\t  reorg_redirect_jump (delay_insn, target_label);\n@@ -3382,7 +3404,8 @@ relax_delay_slots (rtx first)\n \t    label = find_end_label ();\n \n \t  /* find_end_label can generate a new label. Check this first.  */\n-\t  if (no_labels_between_p (insn, next)\n+\t  if (label\n+\t      && no_labels_between_p (insn, next)\n \t      && redirect_with_delay_slots_safe_p (delay_insn, label, insn))\n \t    {\n \t      /* Be careful how we do this to avoid deleting code or labels"}]}