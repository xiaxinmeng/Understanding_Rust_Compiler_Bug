{"sha": "bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFiMGEyNmRlNWNmZTRlOTllODk0ZDBiZTdlYzk4MzA3NmQ0OGNkZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-01-15T11:13:53Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-01-15T11:13:53Z"}, "message": "PR libstdc++/80276 fix template argument handling in type printers\n\n\tPR libstdc++/80276\n\t* python/libstdcxx/v6/printers.py (strip_inline_namespaces): New.\n\t(get_template_arg_list): New.\n\t(StdVariantPrinter._template_args): Remove, use get_template_arg_list\n\tinstead.\n\t(TemplateTypePrinter): Rewrite to work with gdb.Type objects instead\n\tof strings and regular expressions.\n\t(add_one_template_type_printer): Adapt to new TemplateTypePrinter.\n\t(FilteringTypePrinter): Add docstring. Match using startswith. Use\n\tstrip_inline_namespaces instead of strip_versioned_namespace.\n\t(add_one_type_printer): Prepend namespace to match argument.\n\t(register_type_printers): Add type printers for char16_t and char32_t\n\tstring types and for types using cxx11 ABI. Update calls to\n\tadd_one_template_type_printer to provide default argument dicts.\n\t* testsuite/libstdc++-prettyprinters/80276.cc: New test.\n\t* testsuite/libstdc++-prettyprinters/whatis.cc: Remove tests for\n\tbasic_string<unsigned char> and basic_string<signed char>.\n\t* testsuite/libstdc++-prettyprinters/whatis2.cc: Duplicate whatis.cc\n\tto test local variables, without overriding _GLIBCXX_USE_CXX11_ABI.\n\nFrom-SVN: r256689", "tree": {"sha": "bfb765317e9e4e7b23107ed6cca7d135c09afa29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfb765317e9e4e7b23107ed6cca7d135c09afa29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed99ae13bb59965285a91bbb86563390dc2038ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed99ae13bb59965285a91bbb86563390dc2038ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed99ae13bb59965285a91bbb86563390dc2038ac"}], "stats": {"total": 745, "additions": 582, "deletions": 163}, "files": [{"sha": "c059705cc5105218b97b8ba20bfb458b165bc5dc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "patch": "@@ -1,3 +1,25 @@\n+2018-01-15  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/80276\n+\t* python/libstdcxx/v6/printers.py (strip_inline_namespaces): New.\n+\t(get_template_arg_list): New.\n+\t(StdVariantPrinter._template_args): Remove, use get_template_arg_list\n+\tinstead.\n+\t(TemplateTypePrinter): Rewrite to work with gdb.Type objects instead\n+\tof strings and regular expressions.\n+\t(add_one_template_type_printer): Adapt to new TemplateTypePrinter.\n+\t(FilteringTypePrinter): Add docstring. Match using startswith. Use\n+\tstrip_inline_namespaces instead of strip_versioned_namespace.\n+\t(add_one_type_printer): Prepend namespace to match argument.\n+\t(register_type_printers): Add type printers for char16_t and char32_t\n+\tstring types and for types using cxx11 ABI. Update calls to\n+\tadd_one_template_type_printer to provide default argument dicts.\n+\t* testsuite/libstdc++-prettyprinters/80276.cc: New test.\n+\t* testsuite/libstdc++-prettyprinters/whatis.cc: Remove tests for\n+\tbasic_string<unsigned char> and basic_string<signed char>.\n+\t* testsuite/libstdc++-prettyprinters/whatis2.cc: Duplicate whatis.cc\n+\tto test local variables, without overriding _GLIBCXX_USE_CXX11_ABI.\n+\n 2018-01-14  Andreas Schwab  <schwab@linux-m68k.org>\n \n \tPR libstdc++/81092"}, {"sha": "c490880cd1060a467daa4348a8d16869ca67896e", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 222, "deletions": 148, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "patch": "@@ -101,8 +101,8 @@ def find_type(orig, name):\n \n _versioned_namespace = '__8::'\n \n-# Test if a type is a given template instantiation.\n def is_specialization_of(type, template_name):\n+    \"Test if a type is a given template instantiation.\"\n     global _versioned_namespace\n     if _versioned_namespace:\n         return re.match('^std::(%s)?%s<.*>$' % (_versioned_namespace, template_name), type) is not None\n@@ -114,6 +114,28 @@ def strip_versioned_namespace(typename):\n         return typename.replace(_versioned_namespace, '')\n     return typename\n \n+def strip_inline_namespaces(type_str):\n+    \"Remove known inline namespaces from the canonical name of a type.\"\n+    type_str = strip_versioned_namespace(type_str)\n+    type_str = type_str.replace('std::__cxx11::', 'std::')\n+    expt_ns = 'std::experimental::'\n+    for lfts_ns in ('fundamentals_v1', 'fundamentals_v2'):\n+        type_str = type_str.replace(expt_ns+lfts_ns+'::', expt_ns)\n+    fs_ns = expt_ns + 'filesystem::'\n+    type_str = type_str.replace(fs_ns+'v1::', fs_ns)\n+    return type_str\n+\n+def get_template_arg_list(type_obj):\n+    \"Return a type's template arguments as a list\"\n+    n = 0\n+    template_args = []\n+    while True:\n+        try:\n+            template_args.append(type_obj.template_argument(n))\n+        except:\n+            return template_args\n+        n += 1\n+\n class SmartPtrIterator(Iterator):\n     \"An iterator for smart pointer types with a single 'child' value\"\n \n@@ -1063,7 +1085,7 @@ class StdVariantPrinter(SingleObjContainerPrinter):\n     \"Print a std::variant\"\n \n     def __init__(self, typename, val):\n-        alternatives = self._template_args(val)\n+        alternatives = get_template_arg_list(val.type)\n         self.typename = strip_versioned_namespace(typename)\n         self.typename = \"%s<%s>\" % (self.typename, ', '.join([self._recognize(alt) for alt in alternatives]))\n         self.index = val['_M_index']\n@@ -1078,17 +1100,6 @@ def __init__(self, typename, val):\n             visualizer = gdb.default_visualizer(contained_value)\n         super (StdVariantPrinter, self).__init__(contained_value, visualizer, 'array')\n \n-    @staticmethod\n-    def _template_args(val):\n-        n = 0\n-        args = []\n-        while True:\n-            try:\n-                args.append(val.type.template_argument(n))\n-            except:\n-                return args\n-            n += 1\n-\n     def to_string(self):\n         if self.contained_value is None:\n             return \"%s [no contained value]\" % self.typename\n@@ -1294,102 +1305,188 @@ def __call__(self, val):\n \n class TemplateTypePrinter(object):\n     r\"\"\"\n-    A type printer for class templates.\n+    A type printer for class templates with default template arguments.\n \n-    Recognizes type names that match a regular expression.\n-    Replaces them with a formatted string which can use replacement field\n-    {N} to refer to the \\N subgroup of the regex match.\n-    Type printers are recusively applied to the subgroups.\n+    Recognizes specializations of class templates and prints them without\n+    any template arguments that use a default template argument.\n+    Type printers are recursively applied to the template arguments.\n \n-    This allows recognizing e.g. \"std::vector<(.*), std::allocator<\\\\1> >\"\n-    and replacing it with \"std::vector<{1}>\", omitting the template argument\n-    that uses the default type.\n+    e.g. replace \"std::vector<T, std::allocator<T> >\" with \"std::vector<T>\".\n     \"\"\"\n \n-    def __init__(self, name, pattern, subst):\n+    def __init__(self, name, defargs):\n         self.name = name\n-        self.pattern = re.compile(pattern)\n-        self.subst = subst\n+        self.defargs = defargs\n         self.enabled = True\n \n     class _recognizer(object):\n-        def __init__(self, pattern, subst):\n-            self.pattern = pattern\n-            self.subst = subst\n-            self.type_obj = None\n+        \"The recognizer class for TemplateTypePrinter.\"\n+\n+        def __init__(self, name, defargs):\n+            self.name = name\n+            self.defargs = defargs\n+            # self.type_obj = None\n \n         def recognize(self, type_obj):\n+            \"\"\"\n+            If type_obj is a specialization of self.name that uses all the\n+            default template arguments for the class template, then return\n+            a string representation of the type without default arguments.\n+            Otherwise, return None.\n+            \"\"\"\n+\n             if type_obj.tag is None:\n                 return None\n \n-            m = self.pattern.match(type_obj.tag)\n-            if m:\n-                subs = list(m.groups())\n-                for i, sub in enumerate(subs):\n-                    if ('{%d}' % (i+1)) in self.subst:\n-                        # apply recognizers to subgroup\n-                        try:\n-                            subtype = gdb.lookup_type(sub)\n-                        except gdb.error:\n-                            continue\n-                        rep = gdb.types.apply_type_recognizers(\n-                                gdb.types.get_type_recognizers(),\n-                                subtype)\n-                        if rep:\n-                            subs[i] = rep\n-                subs = [None] + subs\n-                return self.subst.format(*subs)\n-            return None\n+            if not type_obj.tag.startswith(self.name):\n+                return None\n+\n+            template_args = get_template_arg_list(type_obj)\n+            displayed_args = []\n+            require_defaulted = False\n+            for n in range(len(template_args)):\n+                # The actual template argument in the type:\n+                targ = template_args[n]\n+                # The default template argument for the class template:\n+                defarg = self.defargs.get(n)\n+                if defarg is not None:\n+                    # Substitute other template arguments into the default:\n+                    defarg = defarg.format(*template_args)\n+                    # Fail to recognize the type (by returning None)\n+                    # unless the actual argument is the same as the default.\n+                    try:\n+                        if targ != gdb.lookup_type(defarg):\n+                            return None\n+                    except gdb.error:\n+                        # Type lookup failed, just use string comparison:\n+                        if targ.tag != defarg:\n+                            return None\n+                    # All subsequent args must have defaults:\n+                    require_defaulted = True\n+                elif require_defaulted:\n+                    return None\n+                else:\n+                    # Recursively apply recognizers to the template argument\n+                    # and add it to the arguments that will be displayed:\n+                    displayed_args.append(self._recognize_subtype(targ))\n+\n+            # This assumes no class templates in the nested-name-specifier:\n+            template_name = type_obj.tag[0:type_obj.tag.find('<')]\n+            template_name = strip_inline_namespaces(template_name)\n+\n+            return template_name + '<' + ', '.join(displayed_args) + '>'\n+\n+        def _recognize_subtype(self, type_obj):\n+            \"\"\"Convert a gdb.Type to a string by applying recognizers,\n+            or if that fails then simply converting to a string.\"\"\"\n+\n+            if type_obj.code == gdb.TYPE_CODE_PTR:\n+                return self._recognize_subtype(type_obj.target()) + '*'\n+            if type_obj.code == gdb.TYPE_CODE_ARRAY:\n+                type_str = self._recognize_subtype(type_obj.target())\n+                if str(type_obj.strip_typedefs()).endswith('[]'):\n+                    return type_str + '[]' # array of unknown bound\n+                return \"%s[%d]\" % (type_str, type_obj.range()[1] + 1)\n+            if type_obj.code == gdb.TYPE_CODE_REF:\n+                return self._recognize_subtype(type_obj.target()) + '&'\n+            if hasattr(gdb, 'TYPE_CODE_RVALUE_REF'):\n+                if type_obj.code == gdb.TYPE_CODE_RVALUE_REF:\n+                    return self._recognize_subtype(type_obj.target()) + '&&'\n+\n+            type_str = gdb.types.apply_type_recognizers(\n+                    gdb.types.get_type_recognizers(), type_obj)\n+            if type_str:\n+                return type_str\n+            return str(type_obj)\n \n     def instantiate(self):\n-        return self._recognizer(self.pattern, self.subst)\n+        \"Return a recognizer object for this type printer.\"\n+        return self._recognizer(self.name, self.defargs)\n \n-def add_one_template_type_printer(obj, name, match, subst):\n-    match = '^std::' + match + '$'\n-    printer = TemplateTypePrinter(name, match, 'std::' + subst)\n+def add_one_template_type_printer(obj, name, defargs):\n+    r\"\"\"\n+    Add a type printer for a class template with default template arguments.\n+\n+    Args:\n+        name (str): The template-name of the class template.\n+        defargs (dict int:string) The default template arguments.\n+\n+    Types in defargs can refer to the Nth template-argument using {N}\n+    (with zero-based indices).\n+\n+    e.g. 'unordered_map' has these defargs:\n+    { 2: 'std::hash<{0}>',\n+      3: 'std::equal_to<{0}>',\n+      4: 'std::allocator<std::pair<const {0}, {1}> >' }\n+\n+    \"\"\"\n+    printer = TemplateTypePrinter('std::'+name, defargs)\n     gdb.types.register_type_printer(obj, printer)\n     if _versioned_namespace:\n         # Add second type printer for same type in versioned namespace:\n-        match = match.replace('std::', 'std::' + _versioned_namespace)\n-        printer = TemplateTypePrinter(name, match, 'std::' + subst)\n+        ns = 'std::' + _versioned_namespace\n+        defargs = { n: d.replace('std::', ns) for n,d in defargs.items() }\n+        printer = TemplateTypePrinter(ns+name, defargs)\n         gdb.types.register_type_printer(obj, printer)\n \n class FilteringTypePrinter(object):\n+    r\"\"\"\n+    A type printer that uses typedef names for common template specializations.\n+\n+    Args:\n+        match (str): The class template to recognize.\n+        name (str): The typedef-name that will be used instead.\n+\n+    Checks if a specialization of the class template 'match' is the same type\n+    as the typedef 'name', and prints it as 'name' instead.\n+\n+    e.g. if an instantiation of std::basic_istream<C, T> is the same type as\n+    std::istream then print it as std::istream.\n+    \"\"\"\n+\n     def __init__(self, match, name):\n         self.match = match\n         self.name = name\n         self.enabled = True\n \n     class _recognizer(object):\n+        \"The recognizer class for TemplateTypePrinter.\"\n+\n         def __init__(self, match, name):\n             self.match = match\n             self.name = name\n             self.type_obj = None\n \n         def recognize(self, type_obj):\n+            \"\"\"\n+            If type_obj starts with self.match and is the same type as\n+            self.name then return self.name, otherwise None.\n+            \"\"\"\n             if type_obj.tag is None:\n                 return None\n \n             if self.type_obj is None:\n-                if not self.match in type_obj.tag:\n+                if not type_obj.tag.startswith(self.match):\n                     # Filter didn't match.\n                     return None\n                 try:\n                     self.type_obj = gdb.lookup_type(self.name).strip_typedefs()\n                 except:\n                     pass\n             if self.type_obj == type_obj:\n-                return strip_versioned_namespace(self.name)\n+                return strip_inline_namespaces(self.name)\n             return None\n \n     def instantiate(self):\n+        \"Return a recognizer object for this type printer.\"\n         return self._recognizer(self.match, self.name)\n \n def add_one_type_printer(obj, match, name):\n-    printer = FilteringTypePrinter(match, 'std::' + name)\n+    printer = FilteringTypePrinter('std::' + match, 'std::' + name)\n     gdb.types.register_type_printer(obj, printer)\n     if _versioned_namespace:\n-        printer = FilteringTypePrinter(match, 'std::' + _versioned_namespace + name)\n+        ns = 'std::' + _versioned_namespace\n+        printer = FilteringTypePrinter(ns + match, ns + name)\n         gdb.types.register_type_printer(obj, printer)\n \n def register_type_printers(obj):\n@@ -1398,50 +1495,43 @@ def register_type_printers(obj):\n     if not _use_type_printing:\n         return\n \n-    for pfx in ('', 'w'):\n-        add_one_type_printer(obj, 'basic_string', pfx + 'string')\n-        add_one_type_printer(obj, 'basic_string_view', pfx + 'string_view')\n-        add_one_type_printer(obj, 'basic_ios', pfx + 'ios')\n-        add_one_type_printer(obj, 'basic_streambuf', pfx + 'streambuf')\n-        add_one_type_printer(obj, 'basic_istream', pfx + 'istream')\n-        add_one_type_printer(obj, 'basic_ostream', pfx + 'ostream')\n-        add_one_type_printer(obj, 'basic_iostream', pfx + 'iostream')\n-        add_one_type_printer(obj, 'basic_stringbuf', pfx + 'stringbuf')\n-        add_one_type_printer(obj, 'basic_istringstream',\n-                                 pfx + 'istringstream')\n-        add_one_type_printer(obj, 'basic_ostringstream',\n-                                 pfx + 'ostringstream')\n-        add_one_type_printer(obj, 'basic_stringstream',\n-                                 pfx + 'stringstream')\n-        add_one_type_printer(obj, 'basic_filebuf', pfx + 'filebuf')\n-        add_one_type_printer(obj, 'basic_ifstream', pfx + 'ifstream')\n-        add_one_type_printer(obj, 'basic_ofstream', pfx + 'ofstream')\n-        add_one_type_printer(obj, 'basic_fstream', pfx + 'fstream')\n-        add_one_type_printer(obj, 'basic_regex', pfx + 'regex')\n-        add_one_type_printer(obj, 'sub_match', pfx + 'csub_match')\n-        add_one_type_printer(obj, 'sub_match', pfx + 'ssub_match')\n-        add_one_type_printer(obj, 'match_results', pfx + 'cmatch')\n-        add_one_type_printer(obj, 'match_results', pfx + 'smatch')\n-        add_one_type_printer(obj, 'regex_iterator', pfx + 'cregex_iterator')\n-        add_one_type_printer(obj, 'regex_iterator', pfx + 'sregex_iterator')\n-        add_one_type_printer(obj, 'regex_token_iterator',\n-                                 pfx + 'cregex_token_iterator')\n-        add_one_type_printer(obj, 'regex_token_iterator',\n-                                 pfx + 'sregex_token_iterator')\n+    # Add type printers for typedefs std::string, std::wstring etc.\n+    for ch in ('', 'w', 'u16', 'u32'):\n+        add_one_type_printer(obj, 'basic_string', ch + 'string')\n+        add_one_type_printer(obj, '__cxx11::basic_string',\n+                             '__cxx11::' + ch + 'string')\n+        add_one_type_printer(obj, 'basic_string_view', ch + 'string_view')\n+\n+    # Add type printers for typedefs std::istream, std::wistream etc.\n+    for ch in ('', 'w'):\n+        for x in ('ios', 'streambuf', 'istream', 'ostream', 'iostream',\n+                  'filebuf', 'ifstream', 'ofstream', 'fstream'):\n+            add_one_type_printer(obj, 'basic_' + x, ch + x)\n+        for x in ('stringbuf', 'istringstream', 'ostringstream',\n+                  'stringstream'):\n+            add_one_type_printer(obj, 'basic_' + x, ch + x)\n+            # <sstream> types are in __cxx11 namespace, but typedefs aren'x:\n+            add_one_type_printer(obj, '__cxx11::basic_' + x, ch + x)\n+\n+    # Add type printers for typedefs regex, wregex, cmatch, wcmatch etc.\n+    for abi in ('', '__cxx11::'):\n+        for ch in ('', 'w'):\n+            add_one_type_printer(obj, abi + 'basic_regex', abi + ch + 'regex')\n+        for ch in ('c', 's', 'wc', 'ws'):\n+            add_one_type_printer(obj, abi + 'match_results', abi + ch + 'match')\n+            for x in ('sub_match', 'regex_iterator', 'regex_token_iterator'):\n+                add_one_type_printer(obj, abi + x, abi + ch + x)\n \n     # Note that we can't have a printer for std::wstreampos, because\n-    # it shares the same underlying type as std::streampos.\n+    # it is the same type as std::streampos.\n     add_one_type_printer(obj, 'fpos', 'streampos')\n \n-    add_one_type_printer(obj, 'basic_string', 'u16string')\n-    add_one_type_printer(obj, 'basic_string', 'u32string')\n-    add_one_type_printer(obj, 'basic_string_view', 'u16string_view')\n-    add_one_type_printer(obj, 'basic_string_view', 'u32string_view')\n-\n+    # Add type printers for <chrono> typedefs.\n     for dur in ('nanoseconds', 'microseconds', 'milliseconds',\n                 'seconds', 'minutes', 'hours'):\n         add_one_type_printer(obj, 'duration', dur)\n \n+    # Add type printers for <random> typedefs.\n     add_one_type_printer(obj, 'linear_congruential_engine', 'minstd_rand0')\n     add_one_type_printer(obj, 'linear_congruential_engine', 'minstd_rand')\n     add_one_type_printer(obj, 'mersenne_twister_engine', 'mt19937')\n@@ -1452,62 +1542,46 @@ def register_type_printers(obj):\n     add_one_type_printer(obj, 'discard_block_engine', 'ranlux48')\n     add_one_type_printer(obj, 'shuffle_order_engine', 'knuth_b')\n \n-    # Do not show defaulted template arguments in class templates\n-    add_one_template_type_printer(obj, 'unique_ptr<T>',\n-            'unique_ptr<(.*), std::default_delete<\\\\1 ?> >',\n-            'unique_ptr<{1}>')\n-\n-    add_one_template_type_printer(obj, 'basic_string<T>',\n-            'basic_string<((un)?signed char), std::char_traits<\\\\1 ?>, std::allocator<\\\\1 ?> >',\n-            'basic_string<{1}>')\n-\n-    add_one_template_type_printer(obj, 'deque<T>',\n-            'deque<(.*), std::allocator<\\\\1 ?> >',\n-            'deque<{1}>')\n-    add_one_template_type_printer(obj, 'forward_list<T>',\n-            'forward_list<(.*), std::allocator<\\\\1 ?> >',\n-            'forward_list<{1}>')\n-    add_one_template_type_printer(obj, 'list<T>',\n-            'list<(.*), std::allocator<\\\\1 ?> >',\n-            'list<{1}>')\n-    add_one_template_type_printer(obj, 'vector<T>',\n-            'vector<(.*), std::allocator<\\\\1 ?> >',\n-            'vector<{1}>')\n-    add_one_template_type_printer(obj, 'map<Key, T>',\n-            'map<(.*), (.*), std::less<\\\\1 ?>, std::allocator<std::pair<\\\\1 const, \\\\2 ?> > >',\n-            'map<{1}, {2}>')\n-    add_one_template_type_printer(obj, 'multimap<Key, T>',\n-            'multimap<(.*), (.*), std::less<\\\\1 ?>, std::allocator<std::pair<\\\\1 const, \\\\2 ?> > >',\n-            'multimap<{1}, {2}>')\n-    add_one_template_type_printer(obj, 'set<T>',\n-            'set<(.*), std::less<\\\\1 ?>, std::allocator<\\\\1 ?> >',\n-            'set<{1}>')\n-    add_one_template_type_printer(obj, 'multiset<T>',\n-            'multiset<(.*), std::less<\\\\1 ?>, std::allocator<\\\\1 ?> >',\n-            'multiset<{1}>')\n-    add_one_template_type_printer(obj, 'unordered_map<Key, T>',\n-            'unordered_map<(.*), (.*), std::hash<\\\\1 ?>, std::equal_to<\\\\1 ?>, std::allocator<std::pair<\\\\1 const, \\\\2 ?> > >',\n-            'unordered_map<{1}, {2}>')\n-    add_one_template_type_printer(obj, 'unordered_multimap<Key, T>',\n-            'unordered_multimap<(.*), (.*), std::hash<\\\\1 ?>, std::equal_to<\\\\1 ?>, std::allocator<std::pair<\\\\1 const, \\\\2 ?> > >',\n-            'unordered_multimap<{1}, {2}>')\n-    add_one_template_type_printer(obj, 'unordered_set<T>',\n-            'unordered_set<(.*), std::hash<\\\\1 ?>, std::equal_to<\\\\1 ?>, std::allocator<\\\\1 ?> >',\n-            'unordered_set<{1}>')\n-    add_one_template_type_printer(obj, 'unordered_multiset<T>',\n-            'unordered_multiset<(.*), std::hash<\\\\1 ?>, std::equal_to<\\\\1 ?>, std::allocator<\\\\1 ?> >',\n-            'unordered_multiset<{1}>')\n-\n-    # strip the \"fundamentals_v1\" inline namespace from these types\n-    add_one_template_type_printer(obj, 'any<T>',\n-            'experimental::fundamentals_v\\d::any<(.*)>',\n-            'experimental::any<\\\\1>')\n-    add_one_template_type_printer(obj, 'optional<T>',\n-            'experimental::fundamentals_v\\d::optional<(.*)>',\n-            'experimental::optional<\\\\1>')\n-    add_one_template_type_printer(obj, 'basic_string_view<C>',\n-            'experimental::fundamentals_v\\d::basic_string_view<(.*), std::char_traits<\\\\1> >',\n-            'experimental::basic_string_view<\\\\1>')\n+    # Add type printers for experimental::basic_string_view typedefs.\n+    ns = 'experimental::fundamentals_v1::'\n+    for ch in ('', 'w', 'u16', 'u32'):\n+        add_one_type_printer(obj, ns + 'basic_string_view',\n+                             ns + ch + 'string_view')\n+\n+    # Do not show defaulted template arguments in class templates.\n+    add_one_template_type_printer(obj, 'unique_ptr',\n+            { 1: 'std::default_delete<{0}>' })\n+    add_one_template_type_printer(obj, 'deque', { 1: 'std::allocator<{0}>'})\n+    add_one_template_type_printer(obj, 'forward_list', { 1: 'std::allocator<{0}>'})\n+    add_one_template_type_printer(obj, 'list', { 1: 'std::allocator<{0}>'})\n+    add_one_template_type_printer(obj, '__cxx11::list', { 1: 'std::allocator<{0}>'})\n+    add_one_template_type_printer(obj, 'vector', { 1: 'std::allocator<{0}>'})\n+    add_one_template_type_printer(obj, 'map',\n+            { 2: 'std::less<{0}>',\n+              3: 'std::allocator<std::pair<{0} const, {1}>>' })\n+    add_one_template_type_printer(obj, 'multimap',\n+            { 2: 'std::less<{0}>',\n+              3: 'std::allocator<std::pair<{0} const, {1}>>' })\n+    add_one_template_type_printer(obj, 'set',\n+            { 1: 'std::less<{0}>', 2: 'std::allocator<{0}>' })\n+    add_one_template_type_printer(obj, 'multiset',\n+            { 1: 'std::less<{0}>', 2: 'std::allocator<{0}>' })\n+    add_one_template_type_printer(obj, 'unordered_map',\n+            { 2: 'std::hash<{0}>',\n+              3: 'std::equal_to<{0}>',\n+              4: 'std::allocator<std::pair<{0} const, {1}>>'})\n+    add_one_template_type_printer(obj, 'unordered_multimap',\n+            { 2: 'std::hash<{0}>',\n+              3: 'std::equal_to<{0}>',\n+              4: 'std::allocator<std::pair<{0} const, {1}>>'})\n+    add_one_template_type_printer(obj, 'unordered_set',\n+            { 1: 'std::hash<{0}>',\n+              2: 'std::equal_to<{0}>',\n+              3: 'std::allocator<{0}>'})\n+    add_one_template_type_printer(obj, 'unordered_multiset',\n+            { 1: 'std::hash<{0}>',\n+              2: 'std::equal_to<{0}>',\n+              3: 'std::allocator<{0}>'})\n \n def register_libstdcxx_printers (obj):\n     \"Register libstdc++ pretty-printers with objfile Obj.\""}, {"sha": "343b344c32e116ed9a5c7b1b5cd7ecd3c2a4d99f", "filename": "libstdc++-v3/testsuite/libstdc++-prettyprinters/80276.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F80276.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F80276.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F80276.cc?ref=bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-g -O0\" }\n+// { dg-skip-if \"\" { *-*-* } { \"-D_GLIBCXX_PROFILE\" } }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <iostream>\n+#include <list>\n+#include <memory>\n+#include <set>\n+#include <string>\n+#include <vector>\n+\n+template<class T>\n+void\n+placeholder(const T *s)\n+{\n+  std::cout << (void *) s;\n+}\n+\n+int\n+main()\n+{\n+  using namespace std;\n+  unique_ptr<vector<unique_ptr<vector<int>*>>> p1;\n+  unique_ptr<vector<unique_ptr<set<int>*>>[]> p2;\n+  unique_ptr<set<unique_ptr<vector<int>*>>[10]> p3;\n+  unique_ptr<vector<unique_ptr<list<std::string>[]>>[99]> p4;\n+  // { dg-final { whatis-test p1 \"std::unique_ptr<std::vector<std::unique_ptr<std::vector<int>*>>>\" } }\n+  // { dg-final { whatis-test p2 \"std::unique_ptr<std::vector<std::unique_ptr<std::set<int>*>>\\[\\]>\" } }\n+  // { dg-final { whatis-test p3 \"std::unique_ptr<std::set<std::unique_ptr<std::vector<int>*>>\\[10\\]>\" } }\n+  // { dg-final { whatis-test p4 \"std::unique_ptr<std::vector<std::unique_ptr<std::list<std::string>\\[\\]>>\\[99\\]>\" } }\n+\n+  placeholder(&p1);\t\t// Mark SPOT\n+  placeholder(&p2);\n+  placeholder(&p3);\n+  placeholder(&p4);\n+\n+  std::cout << \"\\n\";\n+  return 0;\n+}\n+\n+// { dg-final { gdb-test SPOT } }"}, {"sha": "90f3994314b276efc45278f3195a07b2a19a3e0c", "filename": "libstdc++-v3/testsuite/libstdc++-prettyprinters/whatis.cc", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fwhatis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fwhatis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fwhatis.cc?ref=bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "patch": "@@ -19,7 +19,8 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// Type printers only recognize the old std::string for now.\n+// GDB can't find global variables using the abi_tag attribute.\n+// https://sourceware.org/bugzilla/show_bug.cgi?id=19436\n #define _GLIBCXX_USE_CXX11_ABI 0\n \n #include <string>\n@@ -49,8 +50,6 @@ struct holder\n   T *f;\n };\n \n-typedef std::basic_string<unsigned char> ustring;\n-\n // This test is written in a somewhat funny way.\n // Each type under test is used twice: first, to form a pointer type,\n // and second, as a template parameter.  This is done to work around\n@@ -165,14 +164,6 @@ std::knuth_b *knuth_b_ptr;\n holder<std::knuth_b> knuth_b_holder;\n // { dg-final { whatis-test knuth_b_holder \"holder<std::knuth_b>\" } }\n \n-ustring *ustring_ptr;\n-holder<ustring> ustring_holder;\n-// { dg-final { whatis-test ustring_holder \"holder<std::basic_string<unsigned char> >\" } }\n-\n-std::basic_string<signed char> *sstring_ptr;\n-holder< std::basic_string<signed char> > sstring_holder;\n-// { dg-final { whatis-test sstring_holder \"holder<std::basic_string<signed char> >\" } }\n-\n std::vector<std::deque<std::unique_ptr<char>>> *seq1_ptr;\n holder< std::vector<std::deque<std::unique_ptr<char>>> > seq1_holder;\n // { dg-final { whatis-test seq1_holder \"holder<std::vector<std::deque<std::unique_ptr<char>>> >\" } }\n@@ -271,10 +262,6 @@ main()\n   placeholder(&ranlux48_holder);\n   placeholder(&knuth_b_ptr);\n   placeholder(&knuth_b_holder);\n-  placeholder(&ustring_ptr);\n-  placeholder(&ustring_holder);\n-  placeholder(&sstring_ptr);\n-  placeholder(&sstring_holder);\n   placeholder(&seq1_ptr);\n   placeholder(&seq1_holder);\n   placeholder(&seq2_ptr);"}, {"sha": "c63615f8c42223770adb3975a6f6658fe3f8d732", "filename": "libstdc++-v3/testsuite/libstdc++-prettyprinters/whatis2.cc", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fwhatis2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bab0a26de5cfe4e99e894d0be7ec983076d48cdf/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fwhatis2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fwhatis2.cc?ref=bab0a26de5cfe4e99e894d0be7ec983076d48cdf", "patch": "@@ -0,0 +1,278 @@\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-g -O0\" }\n+// { dg-skip-if \"\" { *-*-* } { \"-D_GLIBCXX_PROFILE\" } }\n+\n+// Copyright (C) 2011-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <string>\n+#include <iostream>\n+#include <regex>\n+#include <memory>\n+#include <deque>\n+#include <forward_list>\n+#include <list>\n+#include <vector>\n+#include <map>\n+#include <set>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <random>\n+\n+template<class T>\n+void\n+placeholder(const T *s)\n+{\n+  std::cout << (void *) s;\n+}\n+\n+template<class T>\n+struct holder\n+{\n+  T *f;\n+};\n+\n+// This test is written in a somewhat funny way.\n+// Each type under test is used twice: first, to form a pointer type,\n+// and second, as a template parameter.  This is done to work around\n+// apparent GCC oddities.  The pointer type is needed to ensure that\n+// the typedef in question ends up in the debuginfo; while the\n+// template type is used to ensure that a typedef-less variant is\n+// presented to gdb.\n+\n+int\n+main()\n+{\n+  std::string *string_ptr;\n+  holder<std::string> string_holder;\n+// { dg-final { whatis-test string_holder \"holder<std::string>\" } }\n+  std::ios *ios_ptr;\n+  holder<std::ios> ios_holder;\n+// { dg-final { whatis-test ios_holder \"holder<std::ios>\" } }\n+  std::streambuf *streambuf_ptr;\n+  holder<std::streambuf> streambuf_holder;\n+// { dg-final { whatis-test streambuf_holder \"holder<std::streambuf>\" } }\n+  std::istream *istream_ptr;\n+  holder<std::istream> istream_holder;\n+// { dg-final { whatis-test istream_holder \"holder<std::istream>\" } }\n+  std::ostream *ostream_ptr;\n+  holder<std::ostream> ostream_holder;\n+// { dg-final { whatis-test ostream_holder \"holder<std::ostream>\" } }\n+  std::iostream *iostream_ptr;\n+  holder<std::iostream> iostream_holder;\n+// { dg-final { whatis-test iostream_holder \"holder<std::iostream>\" } }\n+  std::stringbuf *stringbuf_ptr;\n+  holder<std::stringbuf> stringbuf_holder;\n+// { dg-final { whatis-test stringbuf_holder \"holder<std::stringbuf>\" } }\n+  std::istringstream *istringstream_ptr;\n+  holder<std::istringstream> istringstream_holder;\n+// { dg-final { whatis-test istringstream_holder \"holder<std::istringstream>\" } }\n+  std::ostringstream *ostringstream_ptr;\n+  holder<std::ostringstream> ostringstream_holder;\n+// { dg-final { whatis-test ostringstream_holder \"holder<std::ostringstream>\" } }\n+  std::stringstream *stringstream_ptr;\n+  holder<std::stringstream> stringstream_holder;\n+// { dg-final { whatis-test stringstream_holder \"holder<std::stringstream>\" } }\n+  std::filebuf *filebuf_ptr;\n+  holder<std::filebuf> filebuf_holder;\n+// { dg-final { whatis-test filebuf_holder \"holder<std::filebuf>\" } }\n+  std::ifstream *ifstream_ptr;\n+  holder<std::ifstream> ifstream_holder;\n+// { dg-final { whatis-test ifstream_holder \"holder<std::ifstream>\" } }\n+  std::ofstream *ofstream_ptr;\n+  holder<std::ofstream> ofstream_holder;\n+// { dg-final { whatis-test ofstream_holder \"holder<std::ofstream>\" } }\n+  std::fstream *fstream_ptr;\n+  holder<std::fstream> fstream_holder;\n+// { dg-final { whatis-test fstream_holder \"holder<std::fstream>\" } }\n+  std::streampos *streampos_ptr;\n+  holder<std::streampos> streampos_holder;\n+// { dg-final { whatis-test streampos_holder \"holder<std::streampos>\" } }\n+  std::regex *regex_ptr;\n+  holder<std::regex> regex_holder;\n+// { dg-final { whatis-test regex_holder \"holder<std::regex>\" } }\n+std::csub_match *csub_match_ptr;\n+holder<std::csub_match> csub_match_holder;\n+// { dg-final { whatis-test csub_match_holder \"holder<std::csub_match>\" } }\n+  std::ssub_match *ssub_match_ptr;\n+  holder<std::ssub_match> ssub_match_holder;\n+// { dg-final { whatis-test ssub_match_holder \"holder<std::ssub_match>\" } }\n+  std::cmatch *cmatch_ptr;\n+  holder<std::cmatch> cmatch_holder;\n+// { dg-final { whatis-test cmatch_holder \"holder<std::cmatch>\" } }\n+  std::smatch *smatch_ptr;\n+  holder<std::smatch> smatch_holder;\n+// { dg-final { whatis-test smatch_holder \"holder<std::smatch>\" } }\n+  std::cregex_iterator *cregex_iterator_ptr;\n+  holder<std::cregex_iterator> cregex_iterator_holder;\n+// { dg-final { whatis-test cregex_iterator_holder \"holder<std::cregex_iterator>\" } }\n+  std::sregex_iterator *sregex_iterator_ptr;\n+  holder<std::sregex_iterator> sregex_iterator_holder;\n+// { dg-final { whatis-test sregex_iterator_holder \"holder<std::sregex_iterator>\" } }\n+  std::cregex_token_iterator *cregex_token_iterator_ptr;\n+  holder<std::cregex_token_iterator> cregex_token_iterator_holder;\n+// { dg-final { whatis-test cregex_token_iterator_holder \"holder<std::cregex_token_iterator>\" } }\n+  std::sregex_token_iterator *sregex_token_iterator_ptr;\n+  holder<std::sregex_token_iterator> sregex_token_iterator_holder;\n+// { dg-final { whatis-test sregex_token_iterator_holder \"holder<std::sregex_token_iterator>\" } }\n+  std::u16string *u16string_ptr;\n+  holder<std::u16string> u16string_holder;\n+// { dg-final { whatis-test u16string_holder \"holder<std::u16string>\" } }\n+  std::u32string *u32string_ptr;\n+  holder<std::u32string> u32string_holder;\n+// { dg-final { whatis-test u32string_holder \"holder<std::u32string>\" } }\n+  std::minstd_rand0 *minstd_rand0_ptr;\n+  holder<std::minstd_rand0> minstd_rand0_holder;\n+// { dg-final { whatis-test minstd_rand0_holder \"holder<std::minstd_rand0>\" } }\n+  std::minstd_rand *minstd_rand_ptr;\n+  holder<std::minstd_rand> minstd_rand_holder;\n+// { dg-final { whatis-test minstd_rand_holder \"holder<std::minstd_rand>\" } }\n+  std::mt19937 *mt19937_ptr;\n+  holder<std::mt19937> mt19937_holder;\n+// { dg-final { whatis-test mt19937_holder \"holder<std::mt19937>\" } }\n+  std::mt19937_64 *mt19937_64_ptr;\n+  holder<std::mt19937_64> mt19937_64_holder;\n+// { dg-final { whatis-test mt19937_64_holder \"holder<std::mt19937_64>\" } }\n+  std::ranlux24_base *ranlux24_base_ptr;\n+  holder<std::ranlux24_base> ranlux24_base_holder;\n+// { dg-final { whatis-test ranlux24_base_holder \"holder<std::ranlux24_base>\" } }\n+  std::ranlux48_base *ranlux48_base_ptr;\n+  holder<std::ranlux48_base> ranlux48_base_holder;\n+// { dg-final { whatis-test ranlux48_base_holder \"holder<std::ranlux48_base>\" } }\n+  std::ranlux24 *ranlux24_ptr;\n+  holder<std::ranlux24> ranlux24_holder;\n+// { dg-final { whatis-test ranlux24_holder \"holder<std::ranlux24>\" } }\n+  std::ranlux48 *ranlux48_ptr;\n+  holder<std::ranlux48> ranlux48_holder;\n+// { dg-final { whatis-test ranlux48_holder \"holder<std::ranlux48>\" } }\n+  std::knuth_b *knuth_b_ptr;\n+  holder<std::knuth_b> knuth_b_holder;\n+// { dg-final { whatis-test knuth_b_holder \"holder<std::knuth_b>\" } }\n+\n+  std::vector<std::deque<std::unique_ptr<char>>> *seq1_ptr;\n+  holder< std::vector<std::deque<std::unique_ptr<char>>> > seq1_holder;\n+// { dg-final { whatis-test seq1_holder \"holder<std::vector<std::deque<std::unique_ptr<char>>> >\" } }\n+\n+  std::list<std::forward_list<std::unique_ptr<char>>> *seq2_ptr;\n+  holder< std::list<std::forward_list<std::unique_ptr<char>>> > seq2_holder;\n+// { dg-final { whatis-test seq2_holder \"holder<std::list<std::forward_list<std::unique_ptr<char>>> >\" } }\n+\n+  std::map<int, std::set<int>> *assoc1_ptr;\n+  holder< std::map<int, std::set<int>> > assoc1_holder;\n+// { dg-final { whatis-test assoc1_holder \"holder<std::map<int, std::set<int>> >\" } }\n+\n+  std::multimap<int, std::multiset<int>> *assoc2_ptr;\n+  holder< std::multimap<int, std::multiset<int>> > assoc2_holder;\n+// { dg-final { whatis-test assoc2_holder \"holder<std::multimap<int, std::multiset<int>> >\" } }\n+\n+  std::unordered_map<int, std::unordered_set<int>> *unord1_ptr;\n+  holder< std::unordered_map<int, std::unordered_set<int>> > unord1_holder;\n+// { dg-final { whatis-test unord1_holder \"holder<std::unordered_map<int, std::unordered_set<int>> >\" } }\n+\n+  std::unordered_multimap<int, std::unordered_multiset<int>> *unord2_ptr;\n+  holder< std::unordered_multimap<int, std::unordered_multiset<int>> > unord2_holder;\n+// { dg-final { whatis-test unord2_holder \"holder<std::unordered_multimap<int, std::unordered_multiset<int>> >\" } }\n+\n+\n+  placeholder(&ios_ptr);\t\t// Mark SPOT\n+  placeholder(&ios_holder);\n+  placeholder(&string_ptr);\n+  placeholder(&string_holder);\n+  placeholder(&streambuf_ptr);\n+  placeholder(&streambuf_holder);\n+  placeholder(&istream_ptr);\n+  placeholder(&istream_holder);\n+  placeholder(&ostream_ptr);\n+  placeholder(&ostream_holder);\n+  placeholder(&iostream_ptr);\n+  placeholder(&iostream_holder);\n+  placeholder(&stringbuf_ptr);\n+  placeholder(&stringbuf_holder);\n+  placeholder(&istringstream_ptr);\n+  placeholder(&istringstream_holder);\n+  placeholder(&ostringstream_ptr);\n+  placeholder(&ostringstream_holder);\n+  placeholder(&stringstream_ptr);\n+  placeholder(&stringstream_holder);\n+  placeholder(&filebuf_ptr);\n+  placeholder(&filebuf_holder);\n+  placeholder(&ifstream_ptr);\n+  placeholder(&ifstream_holder);\n+  placeholder(&ofstream_ptr);\n+  placeholder(&ofstream_holder);\n+  placeholder(&fstream_ptr);\n+  placeholder(&fstream_holder);\n+  placeholder(&streampos_ptr);\n+  placeholder(&streampos_holder);\n+  placeholder(&regex_ptr);\n+  placeholder(&regex_holder);\n+  placeholder(&csub_match_ptr);\n+  placeholder(&csub_match_holder);\n+  placeholder(&ssub_match_ptr);\n+  placeholder(&ssub_match_holder);\n+  placeholder(&cmatch_ptr);\n+  placeholder(&cmatch_holder);\n+  placeholder(&smatch_ptr);\n+  placeholder(&smatch_holder);\n+  placeholder(&cregex_iterator_ptr);\n+  placeholder(&cregex_iterator_holder);\n+  placeholder(&sregex_iterator_ptr);\n+  placeholder(&sregex_iterator_holder);\n+  placeholder(&cregex_token_iterator_ptr);\n+  placeholder(&cregex_token_iterator_holder);\n+  placeholder(&sregex_token_iterator_ptr);\n+  placeholder(&sregex_token_iterator_holder);\n+  placeholder(&u16string_ptr);\n+  placeholder(&u16string_holder);\n+  placeholder(&u32string_ptr);\n+  placeholder(&u32string_holder);\n+  placeholder(&minstd_rand0_ptr);\n+  placeholder(&minstd_rand0_holder);\n+  placeholder(&minstd_rand_ptr);\n+  placeholder(&minstd_rand_holder);\n+  placeholder(&mt19937_ptr);\n+  placeholder(&mt19937_holder);\n+  placeholder(&mt19937_64_ptr);\n+  placeholder(&mt19937_64_holder);\n+  placeholder(&ranlux24_base_ptr);\n+  placeholder(&ranlux24_base_holder);\n+  placeholder(&ranlux48_base_ptr);\n+  placeholder(&ranlux48_base_holder);\n+  placeholder(&ranlux24_ptr);\n+  placeholder(&ranlux24_holder);\n+  placeholder(&ranlux48_ptr);\n+  placeholder(&ranlux48_holder);\n+  placeholder(&knuth_b_ptr);\n+  placeholder(&knuth_b_holder);\n+  placeholder(&seq1_ptr);\n+  placeholder(&seq1_holder);\n+  placeholder(&seq2_ptr);\n+  placeholder(&seq2_holder);\n+  placeholder(&assoc1_ptr);\n+  placeholder(&assoc1_holder);\n+  placeholder(&assoc2_ptr);\n+  placeholder(&assoc2_holder);\n+  placeholder(&unord1_ptr);\n+  placeholder(&unord1_holder);\n+  placeholder(&unord2_ptr);\n+  placeholder(&unord2_holder);\n+\n+  std::cout << \"\\n\";\n+  return 0;\n+}\n+\n+// { dg-final { gdb-test SPOT } }"}]}