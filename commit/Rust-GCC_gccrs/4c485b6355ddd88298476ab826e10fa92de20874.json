{"sha": "4c485b6355ddd88298476ab826e10fa92de20874", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM0ODViNjM1NWRkZDg4Mjk4NDc2YWI4MjZlMTBmYTkyZGUyMDg3NA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-11-29T05:44:58Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-11-29T05:44:58Z"}, "message": "stmt.c (expand_return): For BLKmode structure returns...\n\n\t* stmt.c (expand_return): For BLKmode structure returns, copy\n\tthe return value from memory into the return registers.  Use\n\tan integer mode rather than BLKmode for returning structures\n\tin registers.\n\nFrom-SVN: r8577", "tree": {"sha": "103a34c5b2e23428661cc1220bf53c3a29375de0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/103a34c5b2e23428661cc1220bf53c3a29375de0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c485b6355ddd88298476ab826e10fa92de20874", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c485b6355ddd88298476ab826e10fa92de20874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c485b6355ddd88298476ab826e10fa92de20874", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c485b6355ddd88298476ab826e10fa92de20874/comments", "author": null, "committer": null, "parents": [{"sha": "203436d9aa8c88b05d173c0584a3f51c83a6f7b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/203436d9aa8c88b05d173c0584a3f51c83a6f7b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/203436d9aa8c88b05d173c0584a3f51c83a6f7b6"}], "stats": {"total": 88, "additions": 87, "deletions": 1}, "files": [{"sha": "1ebf1a7ea9d79c07257990b578033da6c5e0d307", "filename": "gcc/stmt.c", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c485b6355ddd88298476ab826e10fa92de20874/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c485b6355ddd88298476ab826e10fa92de20874/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=4c485b6355ddd88298476ab826e10fa92de20874", "patch": "@@ -2634,7 +2634,93 @@ expand_return (retval)\n     }\n #endif /* HAVE_return */\n \n-  if (cleanups\n+  /* If the result is an aggregate that is being returned in one (or more)\n+     registers, load the registers here.  The compiler currently can't handle\n+     copying a BLKmode value into registers.  We could put this code in a\n+     more general area (for use by everyone instead of just function\n+     call/return), but until this feature is generally usable it is kept here\n+     (and in expand_call).  */\n+\n+  if (retval_rhs != 0\n+      && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n+      && GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) == REG)\n+    {\n+      int i;\n+      int big_endian_correction = 0;\n+      int bytes = int_size_in_bytes (TREE_TYPE (retval_rhs));\n+      int n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+      rtx *result_pseudos = (rtx *) alloca (sizeof (rtx) * n_regs);\n+      rtx result_reg = DECL_RTL (DECL_RESULT (current_function_decl));\n+      rtx result_val = expand_expr (retval_rhs, NULL_RTX, VOIDmode, 0);\n+      enum machine_mode tmpmode;\n+\n+      /* Structures smaller than a word are aligned to the least significant\n+\t byte (to the right).  On a BYTES_BIG_ENDIAN machine, this means we\n+\t must skip the empty high order bytes when calculating the bit\n+\t offset.  */\n+      if (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n+\tbig_endian_correction = (BITS_PER_WORD - (bytes * BITS_PER_UNIT));\n+\n+      for (i = 0; i < n_regs; i++)\n+\t{\n+\t  rtx reg = gen_reg_rtx (word_mode);\n+\t  rtx word = operand_subword_force (result_val, i, BLKmode);\n+\t  int bitsize = MIN (TYPE_ALIGN (TREE_TYPE (retval_rhs)),BITS_PER_WORD);\n+\t  int bitpos;\n+\n+\t  result_pseudos[i] = reg;\n+\n+\t  /* Clobber REG and move each partword into it.  Ensure we don't\n+\t     go past the end of the structure.  Note that the loop below\n+\t     works because we've already verified that padding and\n+\t     endianness are compatable.  */\n+\t  emit_insn (gen_rtx (CLOBBER, VOIDmode, reg));\n+\n+\t  for (bitpos = 0;\n+\t       bitpos < BITS_PER_WORD && bytes > 0;\n+\t       bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n+\t    {\n+\t      int xbitpos = bitpos + big_endian_correction;\n+\n+\t      store_bit_field (reg, bitsize, xbitpos, word_mode,\n+\t\t\t       extract_bit_field (word, bitsize, bitpos, 1,\n+\t\t\t\t\t\t  NULL_RTX, word_mode,\n+\t\t\t\t\t\t  word_mode,\n+\t\t\t\t\t\t  bitsize / BITS_PER_UNIT,\n+\t\t\t\t\t\t  BITS_PER_WORD),\n+\t\t\t       bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n+\t    }\n+\t}\n+\n+      /* Now that the value is in pseudos, copy it to the result reg(s).  */\n+      emit_queue ();\n+      free_temp_slots ();\n+      for (i = 0; i < n_regs; i++)\n+\temit_move_insn (gen_rtx (REG, word_mode, REGNO (result_reg) + i),\n+\t\t\tresult_pseudos[i]);\n+\n+      /* Find the smallest integer mode large enough to hold the\n+\t entire structure and use that mode instead of BLKmode\n+\t on the USE insn for the return register.   */\n+      bytes = int_size_in_bytes (TREE_TYPE (retval_rhs));\n+      for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   tmpmode != MAX_MACHINE_MODE;\n+\t   tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n+      {\n+\t/* Have we found a large enough mode?  */\n+\tif (GET_MODE_SIZE (tmpmode) >= bytes)\n+\t  break;\n+      }\n+\n+      /* No suitable mode found.  */\n+      if (tmpmode == MAX_MACHINE_MODE)\n+      abort ();\n+\n+      PUT_MODE (result_reg, tmpmode);\n+\n+      expand_value_return (result_reg);\n+    }\n+  else if (cleanups\n       && retval_rhs != 0\n       && TREE_TYPE (retval_rhs) != void_type_node\n       && GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) == REG)"}]}