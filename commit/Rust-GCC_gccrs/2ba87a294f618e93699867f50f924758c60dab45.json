{"sha": "2ba87a294f618e93699867f50f924758c60dab45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJhODdhMjk0ZjYxOGU5MzY5OTg2N2Y1MGY5MjQ3NThjNjBkYWI0NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-10-12T07:46:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-10-12T07:46:58Z"}, "message": "expr.h (copy_blkmode_to_reg): Declare.\n\ngcc/\n\t* expr.h (copy_blkmode_to_reg): Declare.\n\t* expr.c (copy_blkmode_to_reg): New function.\n\t(expand_assignment): Don't expand register RESULT_DECLs before\n\tthe lhs.  Use copy_blkmode_to_reg to copy BLKmode values into a\n\tRESULT_DECL register.\n\t(expand_expr_real_1): Handle BLKmode decls when looking for promotion.\n\t* stmt.c (expand_return): Move BLKmode-to-register code into\n\tcopy_blkmode_to_reg.\n\nFrom-SVN: r179839", "tree": {"sha": "4308de3c1a843d03ea183155046d08644a139ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4308de3c1a843d03ea183155046d08644a139ffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ba87a294f618e93699867f50f924758c60dab45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba87a294f618e93699867f50f924758c60dab45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba87a294f618e93699867f50f924758c60dab45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba87a294f618e93699867f50f924758c60dab45/comments", "author": null, "committer": null, "parents": [{"sha": "e755e54342572456e16194c427933aef5fcfbb69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e755e54342572456e16194c427933aef5fcfbb69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e755e54342572456e16194c427933aef5fcfbb69"}], "stats": {"total": 278, "additions": 165, "deletions": 113}, "files": [{"sha": "96d79e6e0e4c32b09e7f689002332a9e53fc5f01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba87a294f618e93699867f50f924758c60dab45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba87a294f618e93699867f50f924758c60dab45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ba87a294f618e93699867f50f924758c60dab45", "patch": "@@ -1,3 +1,14 @@\n+2011-10-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* expr.h (copy_blkmode_to_reg): Declare.\n+\t* expr.c (copy_blkmode_to_reg): New function.\n+\t(expand_assignment): Don't expand register RESULT_DECLs before\n+\tthe lhs.  Use copy_blkmode_to_reg to copy BLKmode values into a\n+\tRESULT_DECL register.\n+\t(expand_expr_real_1): Handle BLKmode decls when looking for promotion.\n+\t* stmt.c (expand_return): Move BLKmode-to-register code into\n+\tcopy_blkmode_to_reg.\n+\n 2011-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/49965"}, {"sha": "b020978f36742b86f7f33249f61c9bf10f00a080", "filename": "gcc/expr.c", "status": "modified", "additions": 123, "deletions": 7, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba87a294f618e93699867f50f924758c60dab45/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba87a294f618e93699867f50f924758c60dab45/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2ba87a294f618e93699867f50f924758c60dab45", "patch": "@@ -2180,6 +2180,112 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n   return tgtblk;\n }\n \n+/* Copy BLKmode value SRC into a register of mode MODE.  Return the\n+   register if it contains any data, otherwise return null.\n+\n+   This is used on targets that return BLKmode values in registers.  */\n+\n+rtx\n+copy_blkmode_to_reg (enum machine_mode mode, tree src)\n+{\n+  int i, n_regs;\n+  unsigned HOST_WIDE_INT bitpos, xbitpos, padding_correction = 0, bytes;\n+  unsigned int bitsize;\n+  rtx *dst_words, dst, x, src_word = NULL_RTX, dst_word = NULL_RTX;\n+  enum machine_mode dst_mode;\n+\n+  gcc_assert (TYPE_MODE (TREE_TYPE (src)) == BLKmode);\n+\n+  x = expand_normal (src);\n+\n+  bytes = int_size_in_bytes (TREE_TYPE (src));\n+  if (bytes == 0)\n+    return NULL_RTX;\n+\n+  /* If the structure doesn't take up a whole number of words, see\n+     whether the register value should be padded on the left or on\n+     the right.  Set PADDING_CORRECTION to the number of padding\n+     bits needed on the left side.\n+\n+     In most ABIs, the structure will be returned at the least end of\n+     the register, which translates to right padding on little-endian\n+     targets and left padding on big-endian targets.  The opposite\n+     holds if the structure is returned at the most significant\n+     end of the register.  */\n+  if (bytes % UNITS_PER_WORD != 0\n+      && (targetm.calls.return_in_msb (TREE_TYPE (src))\n+\t  ? !BYTES_BIG_ENDIAN\n+\t  : BYTES_BIG_ENDIAN))\n+    padding_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n+\t\t\t\t\t   * BITS_PER_UNIT));\n+\n+  n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  dst_words = XALLOCAVEC (rtx, n_regs);\n+  bitsize = MIN (TYPE_ALIGN (TREE_TYPE (src)), BITS_PER_WORD);\n+\n+  /* Copy the structure BITSIZE bits at a time.  */\n+  for (bitpos = 0, xbitpos = padding_correction;\n+       bitpos < bytes * BITS_PER_UNIT;\n+       bitpos += bitsize, xbitpos += bitsize)\n+    {\n+      /* We need a new destination pseudo each time xbitpos is\n+\t on a word boundary and when xbitpos == padding_correction\n+\t (the first time through).  */\n+      if (xbitpos % BITS_PER_WORD == 0\n+\t  || xbitpos == padding_correction)\n+\t{\n+\t  /* Generate an appropriate register.  */\n+\t  dst_word = gen_reg_rtx (word_mode);\n+\t  dst_words[xbitpos / BITS_PER_WORD] = dst_word;\n+\n+\t  /* Clear the destination before we move anything into it.  */\n+\t  emit_move_insn (dst_word, CONST0_RTX (word_mode));\n+\t}\n+\n+      /* We need a new source operand each time bitpos is on a word\n+\t boundary.  */\n+      if (bitpos % BITS_PER_WORD == 0)\n+\tsrc_word = operand_subword_force (x, bitpos / BITS_PER_WORD, BLKmode);\n+\n+      /* Use bitpos for the source extraction (left justified) and\n+\t xbitpos for the destination store (right justified).  */\n+      store_bit_field (dst_word, bitsize, xbitpos % BITS_PER_WORD,\n+\t\t       0, 0, word_mode,\n+\t\t       extract_bit_field (src_word, bitsize,\n+\t\t\t\t\t  bitpos % BITS_PER_WORD, 1, false,\n+\t\t\t\t\t  NULL_RTX, word_mode, word_mode));\n+    }\n+\n+  if (mode == BLKmode)\n+    {\n+      /* Find the smallest integer mode large enough to hold the\n+\t entire structure.  */\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n+\t/* Have we found a large enough mode?  */\n+\tif (GET_MODE_SIZE (mode) >= bytes)\n+\t  break;\n+\n+      /* A suitable mode should have been found.  */\n+      gcc_assert (mode != VOIDmode);\n+    }\n+\n+  if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (word_mode))\n+    dst_mode = word_mode;\n+  else\n+    dst_mode = mode;\n+  dst = gen_reg_rtx (dst_mode);\n+\n+  for (i = 0; i < n_regs; i++)\n+    emit_move_insn (operand_subword (dst, i, 0, dst_mode), dst_words[i]);\n+\n+  if (mode != dst_mode)\n+    dst = gen_lowpart (mode, dst);\n+\n+  return dst;\n+}\n+\n /* Add a USE expression for REG to the (possibly empty) list pointed\n    to by CALL_FUSAGE.  REG must denote a hard register.  */\n \n@@ -4720,7 +4826,9 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from, from)\n       && COMPLETE_TYPE_P (TREE_TYPE (from))\n       && TREE_CODE (TYPE_SIZE (TREE_TYPE (from))) == INTEGER_CST\n-      && ! (((TREE_CODE (to) == VAR_DECL || TREE_CODE (to) == PARM_DECL)\n+      && ! (((TREE_CODE (to) == VAR_DECL\n+\t      || TREE_CODE (to) == PARM_DECL\n+\t      || TREE_CODE (to) == RESULT_DECL)\n \t     && REG_P (DECL_RTL (to)))\n \t    || TREE_CODE (to) == SSA_NAME))\n     {\n@@ -4766,12 +4874,15 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       rtx temp;\n \n       push_temp_slots ();\n-      temp = expand_expr (from, NULL_RTX, GET_MODE (to_rtx), EXPAND_NORMAL);\n+      if (REG_P (to_rtx) && TYPE_MODE (TREE_TYPE (from)) == BLKmode)\n+\ttemp = copy_blkmode_to_reg (GET_MODE (to_rtx), from);\n+      else\n+\ttemp = expand_expr (from, NULL_RTX, GET_MODE (to_rtx), EXPAND_NORMAL);\n \n       if (GET_CODE (to_rtx) == PARALLEL)\n \temit_group_load (to_rtx, temp, TREE_TYPE (from),\n \t\t\t int_size_in_bytes (TREE_TYPE (from)));\n-      else\n+      else if (temp)\n \temit_move_insn (to_rtx, temp);\n \n       preserve_temp_slots (to_rtx);\n@@ -8955,10 +9066,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  return temp;\n \t}\n \n-      /* If the mode of DECL_RTL does not match that of the decl, it\n-\t must be a promoted value.  We return a SUBREG of the wanted mode,\n-\t but mark it so that we know that it was already extended.  */\n-      if (REG_P (decl_rtl) && GET_MODE (decl_rtl) != DECL_MODE (exp))\n+      /* If the mode of DECL_RTL does not match that of the decl,\n+\t there are two cases: we are dealing with a BLKmode value\n+\t that is returned in a register, or we are dealing with\n+\t a promoted value.  In the latter case, return a SUBREG\n+\t of the wanted mode, but mark it so that we know that it\n+\t was already extended.  */\n+      if (REG_P (decl_rtl)\n+\t  && DECL_MODE (exp) != BLKmode\n+\t  && GET_MODE (decl_rtl) != DECL_MODE (exp))\n \t{\n \t  enum machine_mode pmode;\n "}, {"sha": "1bf1369ac960cd64455d9d5c564ad9bf575ff216", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba87a294f618e93699867f50f924758c60dab45/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba87a294f618e93699867f50f924758c60dab45/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=2ba87a294f618e93699867f50f924758c60dab45", "patch": "@@ -325,6 +325,8 @@ extern rtx copy_blkmode_from_reg (rtx, rtx, tree);\n    Mode is TYPE_MODE of the non-promoted parameter, or VOIDmode.  */\n extern void use_reg_mode (rtx *, rtx, enum machine_mode);\n \n+extern rtx copy_blkmode_to_reg (enum machine_mode, tree);\n+\n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n static inline void\n use_reg (rtx *fusage, rtx reg)"}, {"sha": "af6439cd879781243396acd44a035d99c87747d9", "filename": "gcc/stmt.c", "status": "modified", "additions": 7, "deletions": 106, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba87a294f618e93699867f50f924758c60dab45/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba87a294f618e93699867f50f924758c60dab45/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=2ba87a294f618e93699867f50f924758c60dab45", "patch": "@@ -1685,120 +1685,21 @@ expand_return (tree retval)\n     expand_value_return (result_rtl);\n \n   /* If the result is an aggregate that is being returned in one (or more)\n-     registers, load the registers here.  The compiler currently can't handle\n-     copying a BLKmode value into registers.  We could put this code in a\n-     more general area (for use by everyone instead of just function\n-     call/return), but until this feature is generally usable it is kept here\n-     (and in expand_call).  */\n+     registers, load the registers here.  */\n \n   else if (retval_rhs != 0\n \t   && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n \t   && REG_P (result_rtl))\n     {\n-      int i;\n-      unsigned HOST_WIDE_INT bitpos, xbitpos;\n-      unsigned HOST_WIDE_INT padding_correction = 0;\n-      unsigned HOST_WIDE_INT bytes\n-\t= int_size_in_bytes (TREE_TYPE (retval_rhs));\n-      int n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-      unsigned int bitsize\n-\t= MIN (TYPE_ALIGN (TREE_TYPE (retval_rhs)), BITS_PER_WORD);\n-      rtx *result_pseudos = XALLOCAVEC (rtx, n_regs);\n-      rtx result_reg, src = NULL_RTX, dst = NULL_RTX;\n-      rtx result_val = expand_normal (retval_rhs);\n-      enum machine_mode tmpmode, result_reg_mode;\n-\n-      if (bytes == 0)\n+      val = copy_blkmode_to_reg (GET_MODE (result_rtl), retval_rhs);\n+      if (val)\n \t{\n-\t  expand_null_return ();\n-\t  return;\n-\t}\n-\n-      /* If the structure doesn't take up a whole number of words, see\n-\t whether the register value should be padded on the left or on\n-\t the right.  Set PADDING_CORRECTION to the number of padding\n-\t bits needed on the left side.\n-\n-\t In most ABIs, the structure will be returned at the least end of\n-\t the register, which translates to right padding on little-endian\n-\t targets and left padding on big-endian targets.  The opposite\n-\t holds if the structure is returned at the most significant\n-\t end of the register.  */\n-      if (bytes % UNITS_PER_WORD != 0\n-\t  && (targetm.calls.return_in_msb (TREE_TYPE (retval_rhs))\n-\t      ? !BYTES_BIG_ENDIAN\n-\t      : BYTES_BIG_ENDIAN))\n-\tpadding_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n-\t\t\t\t\t       * BITS_PER_UNIT));\n-\n-      /* Copy the structure BITSIZE bits at a time.  */\n-      for (bitpos = 0, xbitpos = padding_correction;\n-\t   bitpos < bytes * BITS_PER_UNIT;\n-\t   bitpos += bitsize, xbitpos += bitsize)\n-\t{\n-\t  /* We need a new destination pseudo each time xbitpos is\n-\t     on a word boundary and when xbitpos == padding_correction\n-\t     (the first time through).  */\n-\t  if (xbitpos % BITS_PER_WORD == 0\n-\t      || xbitpos == padding_correction)\n-\t    {\n-\t      /* Generate an appropriate register.  */\n-\t      dst = gen_reg_rtx (word_mode);\n-\t      result_pseudos[xbitpos / BITS_PER_WORD] = dst;\n-\n-\t      /* Clear the destination before we move anything into it.  */\n-\t      emit_move_insn (dst, CONST0_RTX (GET_MODE (dst)));\n-\t    }\n-\n-\t  /* We need a new source operand each time bitpos is on a word\n-\t     boundary.  */\n-\t  if (bitpos % BITS_PER_WORD == 0)\n-\t    src = operand_subword_force (result_val,\n-\t\t\t\t\t bitpos / BITS_PER_WORD,\n-\t\t\t\t\t BLKmode);\n-\n-\t  /* Use bitpos for the source extraction (left justified) and\n-\t     xbitpos for the destination store (right justified).  */\n-\t  store_bit_field (dst, bitsize, xbitpos % BITS_PER_WORD,\n-\t\t\t   0, 0, word_mode,\n-\t\t\t   extract_bit_field (src, bitsize,\n-\t\t\t\t\t      bitpos % BITS_PER_WORD, 1, false,\n-\t\t\t\t\t      NULL_RTX, word_mode, word_mode));\n-\t}\n-\n-      tmpmode = GET_MODE (result_rtl);\n-      if (tmpmode == BLKmode)\n-\t{\n-\t  /* Find the smallest integer mode large enough to hold the\n-\t     entire structure and use that mode instead of BLKmode\n-\t     on the USE insn for the return register.  */\n-\t  for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t       tmpmode != VOIDmode;\n-\t       tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n-\t    /* Have we found a large enough mode?  */\n-\t    if (GET_MODE_SIZE (tmpmode) >= bytes)\n-\t      break;\n-\n-\t  /* A suitable mode should have been found.  */\n-\t  gcc_assert (tmpmode != VOIDmode);\n-\n-\t  PUT_MODE (result_rtl, tmpmode);\n+\t  /* Use the mode of the result value on the return register.  */\n+\t  PUT_MODE (result_rtl, GET_MODE (val));\n+\t  expand_value_return (val);\n \t}\n-\n-      if (GET_MODE_SIZE (tmpmode) < GET_MODE_SIZE (word_mode))\n-\tresult_reg_mode = word_mode;\n       else\n-\tresult_reg_mode = tmpmode;\n-      result_reg = gen_reg_rtx (result_reg_mode);\n-\n-      for (i = 0; i < n_regs; i++)\n-\temit_move_insn (operand_subword (result_reg, i, 0, result_reg_mode),\n-\t\t\tresult_pseudos[i]);\n-\n-      if (tmpmode != result_reg_mode)\n-\tresult_reg = gen_lowpart (tmpmode, result_reg);\n-\n-      expand_value_return (result_reg);\n+\texpand_null_return ();\n     }\n   else if (retval_rhs != 0\n \t   && !VOID_TYPE_P (TREE_TYPE (retval_rhs))"}, {"sha": "37b61741ada94b55ebfefbb1b91f3dde3c8b0b60", "filename": "gcc/testsuite/g++.dg/pr48660.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba87a294f618e93699867f50f924758c60dab45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr48660.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba87a294f618e93699867f50f924758c60dab45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr48660.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr48660.C?ref=2ba87a294f618e93699867f50f924758c60dab45", "patch": "@@ -0,0 +1,22 @@\n+template<int N> struct val { char a[N]; };\n+\n+class Base\n+{\n+public:\n+  virtual val<1> get1() const = 0;\n+  virtual val<2> get2() const = 0;\n+  virtual val<3> get3() const = 0;\n+  virtual val<4> get4() const = 0;\n+};\n+\n+class Derived : public virtual Base\n+{\n+public:\n+  virtual val<1> get1() const { return foo->get1(); }\n+  virtual val<2> get2() const { return foo->get2(); }\n+  virtual val<3> get3() const { return foo->get3(); }\n+  virtual val<4> get4() const { return foo->get4(); }\n+  Base *foo;\n+};\n+\n+Base* make() { return new Derived; }"}]}