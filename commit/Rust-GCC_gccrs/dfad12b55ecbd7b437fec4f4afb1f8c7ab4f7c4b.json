{"sha": "dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZhZDEyYjU1ZWNiZDdiNDM3ZmVjNGY0YWZiMWY4YzdhYjRmN2M0Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-08-12T06:44:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-08-12T06:44:54Z"}, "message": "mips.h: Tweak various comments.\n\n\t* config/mips/mips.h: Tweak various comments.\n\t* config/mips/mips.c: Likewise.\n\nFrom-SVN: r70360", "tree": {"sha": "b95e78fd686f5d4b68c6ea99a9b6e9a79cadce2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b95e78fd686f5d4b68c6ea99a9b6e9a79cadce2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b/comments", "author": null, "committer": null, "parents": [{"sha": "e3f049a88eb7ab9c6aa2c61afd8c93c4c2d675c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f049a88eb7ab9c6aa2c61afd8c93c4c2d675c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3f049a88eb7ab9c6aa2c61afd8c93c4c2d675c9"}], "stats": {"total": 444, "additions": 102, "deletions": 342}, "files": [{"sha": "a9c4046cbfd01a2156500f897d9c4e360cbc5a2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b", "patch": "@@ -1,3 +1,8 @@\n+2003-08-12  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.h: Tweak various comments.\n+\t* config/mips/mips.c: Likewise.\n+\n 2003-08-11  James E Wilson  <wilson@tuliptree.org>\n \n \tPR optimization/11319"}, {"sha": "dc33b1625fd267db06702ebb584cafec9a7e553e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 43, "deletions": 74, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b", "patch": "@@ -1,4 +1,4 @@\n-/* Subroutines for insn-output.c for MIPS\n+/* Subroutines used for MIPS code generation.\n    Copyright (C) 1989, 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by A. Lichnewsky, lich@inria.inria.fr.\n@@ -310,8 +310,7 @@ struct mips_frame_info GTY(())\n \n struct machine_function GTY(()) {\n   /* Pseudo-reg holding the address of the current function when\n-     generating embedded PIC code.  Created by LEGITIMIZE_ADDRESS,\n-     used by mips_finalize_pic if it was created.  */\n+     generating embedded PIC code.  */\n   rtx embedded_pic_fnaddr_rtx;\n \n   /* Pseudo-reg holding the value of $28 in a mips16 function which\n@@ -436,9 +435,7 @@ struct mips_integer_op {\n /* Global variables for machine-dependent things.  */\n \n /* Threshold for data being put into the small data/bss area, instead\n-   of the normal data area (references to the small data/bss area take\n-   1 instruction, and use the global pointer, references to the normal\n-   data area takes 2 instructions).  */\n+   of the normal data area.  */\n int mips_section_threshold = -1;\n \n /* Count the number of .file directives, so that .loc is up to date.  */\n@@ -491,10 +488,10 @@ const struct mips_cpu_info *mips_arch_info;\n enum processor_type mips_tune;\n const struct mips_cpu_info *mips_tune_info;\n \n-/* which instruction set architecture to use.  */\n+/* Which instruction set architecture to use.  */\n int mips_isa;\n \n-/* which abi to use.  */\n+/* Which ABI to use.  */\n int mips_abi;\n \n /* Strings to hold which cpu and instruction set architecture to use.  */\n@@ -1320,8 +1317,7 @@ const_arith_operand (op, mode)\n }\n \n \n-/* Return truth value of whether OP can be used as an operands\n-   where a 16 bit integer is needed  */\n+/* Return true if OP is a register operand or a signed 16-bit constant.  */\n \n int\n arith_operand (op, mode)\n@@ -1342,8 +1338,8 @@ small_int (op, mode)\n }\n \n /* Return truth value of whether OP is a register or the constant 0.\n-   In mips16 mode, we only accept a register, since the mips16 does\n-   not have $0.  */\n+   Do not accept 0 in mips16 mode since $0 is not one of the core 8\n+   registers.  */\n \n int\n reg_or_0_operand (op, mode)\n@@ -1542,7 +1538,7 @@ consttable_operand (op, mode)\n   return CONSTANT_P (op);\n }\n \n-/* Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n+/* Return 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n    possibly with an offset.  */\n \n int\n@@ -2058,7 +2054,7 @@ mips_legitimize_move (mode, dest, src)\n \n \n /* Convert GOT and GP-relative accesses back into their original form.\n-   Used by bothh TARGET_DELEGITIMIZE_ADDRESS and FIND_BASE_TERM.  */\n+   Used by both TARGET_DELEGITIMIZE_ADDRESS and FIND_BASE_TERM.  */\n \n rtx\n mips_delegitimize_address (x)\n@@ -2318,8 +2314,8 @@ mips_rtx_costs (x, code, outer_code, total)\n             *total = COSTS_N_INSNS (1);\n           return true;\n         }\n-      /* We can use cmpi for an xor with an unsigned 16 bit value.  */\n \n+      /* We can use cmpi for an xor with an unsigned 16 bit value.  */\n       if ((outer_code) == XOR\n           && INTVAL (x) >= 0 && INTVAL (x) < 0x10000)\n         {\n@@ -3248,7 +3244,7 @@ gen_conditional_branch (operands, test_code)\n }\n \n /* Emit the common code for conditional moves.  OPERANDS is the array\n-   of operands passed to the conditional move defined_expand.  */\n+   of operands passed to the conditional move define_expand.  */\n \n void\n gen_conditional_move (operands)\n@@ -3334,8 +3330,8 @@ gen_conditional_move (operands)\n \t\t\t\t\t\toperands[2], operands[3])));\n }\n \n-/* Emit the common code for conditional moves.  OPERANDS is the array\n-   of operands passed to the conditional move defined_expand.  */\n+/* Emit a conditional trap.  OPERANDS is the array of operands passed to\n+   the conditional_trap expander.  */\n \n void\n mips_gen_conditional_trap (operands)\n@@ -3379,7 +3375,7 @@ mips_gen_conditional_trap (operands)\n    function, ARGS_SIZE is the size of the arguments and AUX is\n    the value passed to us by mips_function_arg.  SIBCALL_P is true\n    if we are expanding a sibling call, false if we're expanding\n-   normal call.  */\n+   a normal call.  */\n \n void\n mips_expand_call (result, addr, args_size, aux, sibcall_p)\n@@ -4473,11 +4469,11 @@ mips_va_arg (valist, type)\n \n \t\t TOP be the top of the register save area;\n \t\t OFF be the offset from TOP of the next register;\n-\t\t ADDR_RTX be the address of the argument; and\n+\t\t ADDR_RTX be the address of the argument;\n \t\t RSIZE be the number of bytes used to store the argument\n-\t\t   when it's in the register save area\n+\t\t   when it's in the register save area;\n \t\t OSIZE be the number of bytes used to store it when it's\n-\t\t   in the stack overflow area\n+\t\t   in the stack overflow area; and\n \t\t PADDING be (BYTES_BIG_ENDIAN ? OSIZE - RSIZE : 0)\n \n \t     The code we want is:\n@@ -5040,12 +5036,7 @@ override_options ()\n   mips_dbx_regno[HI_REGNUM] = MD_DBX_FIRST + 0;\n   mips_dbx_regno[LO_REGNUM] = MD_DBX_FIRST + 1;\n \n-  /* Set up array giving whether a given register can hold a given mode.\n-     At present, restrict ints from being in FP registers, because reload\n-     is a little enthusiastic about storing extra values in FP registers,\n-     and this is not good for things like OS kernels.  Also, due to the\n-     mandatory delay, it is as fast to load from cached memory as to move\n-     from the FP register.  */\n+  /* Set up array giving whether a given register can hold a given mode.  */\n \n   for (mode = VOIDmode;\n        mode != MAX_MACHINE_MODE;\n@@ -5249,31 +5240,11 @@ mips_debugger_offset (addr, offset)\n   return offset;\n }\n \f\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand X.  X is an RTL\n-   expression.\n-\n-   CODE is a value that can be used to specify one of several ways\n-   of printing the operand.  It is used when identical operands\n-   must be printed differently depending on the context.  CODE\n-   comes from the `%' specification that was used to request\n-   printing of the operand.  If the specification was just `%DIGIT'\n-   then CODE is 0; if the specification was `%LTR DIGIT' then CODE\n-   is the ASCII code for LTR.\n-\n-   If X is a register, this macro should print the register's name.\n-   The names can be found in an array `reg_names' whose type is\n-   `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n-\n-   When the machine description has a specification `%PUNCT' (a `%'\n-   followed by a punctuation character), this macro is called with\n-   a null pointer for X and the punctuation character for CODE.\n-\n-   The MIPS specific codes are:\n-\n-   'X'  X is CONST_INT, prints 32 bits in hexadecimal format = \"0x%08x\",\n-   'x'  X is CONST_INT, prints 16 bits in hexadecimal format = \"0x%04x\",\n-   'h'  X is HIGH, prints %hi(X),\n+/* Implement the PRINT_OPERAND macro.  The MIPS-specific operand codes are:\n+\n+   'X'  OP is CONST_INT, prints 32 bits in hexadecimal format = \"0x%08x\",\n+   'x'  OP is CONST_INT, prints 16 bits in hexadecimal format = \"0x%04x\",\n+   'h'  OP is HIGH, prints %hi(X),\n    'd'  output integer constant in decimal,\n    'z'\tif the operand is 0, use $0 instead of normal operand.\n    'D'  print second part of double-word register or memory operand.\n@@ -5283,13 +5254,16 @@ mips_debugger_offset (addr, offset)\n    'F'  print part of opcode for a floating-point branch condition.\n    'N'  print part of opcode for a branch condition, inverted.\n    'W'  print part of opcode for a floating-point branch condition, inverted.\n-   'S'  X is CODE_LABEL, print with prefix of \"LS\" (for embedded switch).\n+   'S'  OP is CODE_LABEL, print with prefix of \"LS\" (for embedded switch).\n    'B'  print 'z' for EQ, 'n' for NE\n    'b'  print 'n' for EQ, 'z' for NE\n    'T'  print 'f' for EQ, 't' for NE\n    't'  print 't' for EQ, 'f' for NE\n    'Z'  print register and a comma, but print nothing for $fcc0\n    'R'  print the reloc associated with LO_SUM\n+\n+   The punctuation characters are:\n+\n    '('\tTurn on .set noreorder\n    ')'\tTurn on .set reorder\n    '['\tTurn on .set noat\n@@ -5911,13 +5885,7 @@ mips_output_ascii (stream, string_param, len)\n   fprintf (stream, \"\\\"\\n\");\n }\n \f\n-/* Output at beginning of assembler file.\n-\n-   If we are optimizing to use the global pointer, create a temporary file to\n-   hold all of the text stuff, and write it out to the end. This is needed\n-   because the MIPS assembler is evidently one pass, and if it hasn't seen the\n-   relevant .comm/.lcomm/.extern/.sdata declaration when the code is\n-   processed, it generates a two instruction sequence.  */\n+/* Implement TARGET_ASM_FILE_START.  */\n \n static void\n mips_file_start ()\n@@ -6007,10 +5975,8 @@ mips_output_aligned_bss (stream, decl, name, size, align)\n }\n #endif\n \f\n-/* If we are optimizing the global pointer, emit the text section now and any\n-   small externs which did not have .comm, etc that are needed.  Also, give a\n-   warning if the data area is more than 32K and -pic because 3 instructions\n-   are needed to reference the data pointers.  */\n+/* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit\n+   .externs for any small-data variables that turned out to be external.  */\n \n static void\n mips_file_end ()\n@@ -7827,11 +7793,10 @@ mips_encode_section_info (decl, rtl, first)\n \n   default_encode_section_info (decl, rtl, first);\n }\n-\n-\n \f\n-/* Return register to use for a function return value with VALTYPE for\n-   function FUNC.  MODE is used instead of VALTYPE for LIBCALLs.  */\n+/* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n+   VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n+   VALTYPE is null and MODE is the mode of the return value.  */\n \n rtx\n mips_function_value (valtype, func, mode)\n@@ -9908,6 +9873,9 @@ mips_adjust_cost (insn, link, dep, cost)\n   return cost;\n }\n \n+/* Implement HARD_REGNO_NREGS.  The size of FP registers are controlled\n+   by UNITS_PER_FPREG.  All other registers are word sized.  */\n+\n unsigned int\n mips_hard_regno_nregs (regno, mode)\n     int regno;\n@@ -9919,15 +9887,16 @@ mips_hard_regno_nregs (regno, mode)\n     return ((GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG);\n }\n \n+/* Implement RETURN_IN_MEMORY.  Under the old (i.e., 32 and O64 ABIs)\n+   all BLKmode objects are returned in memory.  Under the new (N32 and\n+   64-bit MIPS ABIs) small structures are returned in a register.\n+   Objects with varying size must still be returned in memory, of\n+   course.  */\n+\n int\n mips_return_in_memory (type)\n      tree type;\n {\n-  /* Under the old (i.e., 32 and O64 ABIs) all BLKmode objects are\n-     returned in memory.  Under the new (N32 and 64-bit MIPS ABIs) small\n-     structures are returned in a register.  Objects with varying size\n-     must still be returned in memory, of course.  */\n-\n   if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n     return (TYPE_MODE (type) == BLKmode);\n   else"}, {"sha": "edf5583c819fb665f51a11763e42b5017e35a761", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 54, "deletions": 268, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=dfad12b55ecbd7b437fec4f4afb1f8c7ab4f7c4b", "patch": "@@ -925,21 +925,12 @@ extern const struct mips_cpu_info *mips_tune_info;\n    two-instruction gap.  */\n #define ISA_HAS_HILO_INTERLOCKS\t(TARGET_MIPS5500 || TARGET_SB1)\n \f\n-/* Switch  Recognition by gcc.c.  Add -G xx support */\n+/* Add -G xx support.  */\n \n #undef  SWITCH_TAKES_ARG\n #define SWITCH_TAKES_ARG(CHAR)\t\t\t\t\t\t\\\n   (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n \n-/* Sometimes certain combinations of command options do not make sense\n-   on a particular target machine.  You can define a macro\n-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n-   defined, is executed once just after all the command options have\n-   been parsed.\n-\n-   On the MIPS, it is used to handle -G.  We also use it to set up all\n-   of the tables referenced in the other macros.  */\n-\n #define OVERRIDE_OPTIONS override_options ()\n \n #define CONDITIONAL_REGISTER_USAGE mips_conditional_register_usage ()\n@@ -1208,10 +1199,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n /* How to renumber registers for dbx and gdb.  */\n #define DBX_REGISTER_NUMBER(REGNO) mips_dbx_regno[ (REGNO) ]\n \n-/* The mapping from gcc register number to DWARF 2 CFA column number.\n-   This mapping does not allow for tracking register 0, since SGI's broken\n-   dwarf reader thinks column 0 is used for the frame address, but since\n-   register 0 is fixed this is not a problem.  */\n+/* The mapping from gcc register number to DWARF 2 CFA column number.  */\n #define DWARF_FRAME_REGNUM(REG)\t\t\t\t\\\n   (REG == GP_REG_FIRST + 31 ? DWARF_FRAME_RETURN_COLUMN : REG)\n \n@@ -1248,15 +1236,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n \f\n /* Target machine storage layout */\n \n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-*/\n #define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n #define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n-\n-/* Define this if most significant word of a multiword number is the lowest.  */\n #define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n \n /* Define this to set the endianness to use in libgcc2.c, which can\n@@ -1292,48 +1273,23 @@ extern const struct mips_cpu_info *mips_tune_info;\n /* The number of bytes in a double.  */\n #define UNITS_PER_DOUBLE (TYPE_PRECISION (double_type_node) / BITS_PER_UNIT)\n \n-/* A C expression for the size in bits of the type `int' on the\n-   target machine.  If you don't define this, the default is one\n-   word.  */\n-#define INT_TYPE_SIZE (TARGET_INT64 ? 64 : 32)\n-\n /* Tell the preprocessor the maximum size of wchar_t.  */\n #ifndef MAX_WCHAR_TYPE_SIZE\n #ifndef WCHAR_TYPE_SIZE\n #define MAX_WCHAR_TYPE_SIZE 64\n #endif\n #endif\n \n-/* A C expression for the size in bits of the type `short' on the\n-   target machine.  If you don't define this, the default is half a\n-   word.  (If this would be less than one storage unit, it is\n-   rounded up to one unit.)  */\n+/* Set the sizes of the core types.  */\n #define SHORT_TYPE_SIZE 16\n-\n-/* A C expression for the size in bits of the type `long' on the\n-   target machine.  If you don't define this, the default is one\n-   word.  */\n+#define INT_TYPE_SIZE (TARGET_INT64 ? 64 : 32)\n #define LONG_TYPE_SIZE (TARGET_LONG64 ? 64 : 32)\n-#define MAX_LONG_TYPE_SIZE 64\n-\n-/* A C expression for the size in bits of the type `long long' on the\n-   target machine.  If you don't define this, the default is two\n-   words.  */\n #define LONG_LONG_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `float' on the\n-   target machine.  If you don't define this, the default is one\n-   word.  */\n-#define FLOAT_TYPE_SIZE 32\n+#define MAX_LONG_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `double' on the\n-   target machine.  If you don't define this, the default is two\n-   words.  */\n+#define FLOAT_TYPE_SIZE 32\n #define DOUBLE_TYPE_SIZE 64\n-\n-/* A C expression for the size in bits of the type `long double' on\n-   the target machine.  If you don't define this, the default is two\n-   words.  */\n #define LONG_DOUBLE_TYPE_SIZE \\\n   (mips_abi == ABI_N32 || mips_abi == ABI_64 ? 128 : 64)\n \n@@ -1376,8 +1332,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n /* There is no point aligning anything to a rounder boundary than this.  */\n #define BIGGEST_ALIGNMENT LONG_DOUBLE_TYPE_SIZE\n \n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n+/* All accesses must be aligned.  */\n #define STRICT_ALIGNMENT 1\n \n /* Define this if you wish to imitate the way many other C compilers\n@@ -1442,11 +1397,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n \n #define PAD_VARARGS_DOWN (TARGET_64BIT ? BYTES_BIG_ENDIAN : !BYTES_BIG_ENDIAN)\n \n-/* Define this macro if an argument declared as `char' or `short' in a\n-   prototype should actually be passed as an `int'.  In addition to\n-   avoiding errors in certain cases of mismatch, it also makes for\n-   better code on certain machines.  */\n-\n+/* Arguments declared as 'char' or 'short' in a prototype should be\n+   passed as 'int's.  */\n #define PROMOTE_PROTOTYPES 1\n \n /* Define if operations between registers always perform the operation\n@@ -1493,26 +1445,22 @@ extern const struct mips_cpu_info *mips_tune_info;\n \f\n /* Standard register usage.  */\n \n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n+/* Number of hardware registers.  We have:\n \n-   On the Mips, we have 32 integer registers, 32 floating point\n-   registers, 8 condition code registers, and the special registers\n-   hi and lo.  After that we have 32 COP0 registers, 32 COP2 registers,\n-   and 32 COP3 registers.  (COP1 is the floating-point processor.)\n-   The 8 condition code registers are only used if mips_isa >= 4.  */\n+   - 32 integer registers\n+   - 32 floating point registers\n+   - 8 condition code registers\n+   - 2 accumulator registers (hi and lo)\n+   - 32 registers each for coprocessors 0, 2 and 3\n+   - 6 dummy entries that were used at various times in the past.  */\n \n #define FIRST_PSEUDO_REGISTER 176\n \n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-\n-   On the MIPS, see conventions, page D-2  */\n+/* By default, fix the kernel registers ($26 and $27), the global\n+   pointer ($28) and the stack pointer ($29).  This can change\n+   depending on the command-line options.\n \n-/* Regarding coprocessor registers: without evidence to the contrary,\n+   Regarding coprocessor registers: without evidence to the contrary,\n    it's best to assume that each coprocessor register has a unique\n    use.  This can be overridden, in, e.g., override_options() or\n    CONDITIONAL_REGISTER_USAGE should the assumption be inappropriate\n@@ -1537,8 +1485,10 @@ extern const struct mips_cpu_info *mips_tune_info;\n }\n \n \n-/* Don't mark $31 as a call-clobbered register.  The idea is that\n-   it's really the call instructions themselves which clobber $31.\n+/* Set up this array for o32 by default.\n+\n+   Note that we don't mark $31 as a call-clobbered register.  The idea is\n+   that it's really the call instructions themselves which clobber $31.\n    We don't care what the called function does with it afterwards.\n \n    This approach makes it easier to implement sibcalls.  Unlike normal\n@@ -1564,14 +1514,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\\\n }\n \n-/* Like `CALL_USED_REGISTERS' but used to overcome a historical\n-   problem which makes CALL_USED_REGISTERS *always* include\n-   all the FIXED_REGISTERS.  Until this problem has been\n-   resolved this macro can be used to overcome this situation.\n-   In particular, block_propagate() requires this list\n-   be accurate, or we can remove registers which should be live.\n-   This macro is used in regs_invalidated_by_call.  */\n \n+/* Define this since $28, though fixed, is call-saved in many ABIs.  */\n \n #define CALL_REALLY_USED_REGISTERS                                      \\\n { /* General registers.  */                                             \\\n@@ -1636,8 +1580,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define HI_REGNUM\t(MD_REG_FIRST + 0)\n #define LO_REGNUM\t(MD_REG_FIRST + 1)\n \n-/* FPSW_REGNUM is the single condition code used if mips_isa < 4.  If\n-   mips_isa >= 4, it should not be used, and an arbitrary ST_REG\n+/* FPSW_REGNUM is the single condition code used if !ISA_HAS_8CC.\n+   If ISA_HAS_8CC, it should not be used, and an arbitrary ST_REG\n    should be used instead.  */\n #define FPSW_REGNUM\tST_REG_FIRST\n \n@@ -1668,24 +1612,10 @@ extern const struct mips_cpu_info *mips_tune_info;\n   (COP0_REG_P (REGNO) ? '0' : COP2_REG_P (REGNO) ? '2'\t\t\t\\\n    : COP3_REG_P (REGNO) ? '3' : '?')\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the MIPS, all general registers are one word long.  Except on\n-   the R4000 with the FR bit set, the floating point uses register\n-   pairs, with the second register not being allocable.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE) mips_hard_regno_nregs (REGNO, MODE)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE.  In 32 bit mode, require that DImode and DFmode be in even\n-   registers.  For DImode, this makes some of the insns easier to\n-   write, since you don't have to worry about a DImode value in\n-   registers 3 & 4, producing a result in 4 & 5.\n-\n-   To make the code simpler HARD_REGNO_MODE_OK now just references an\n+/* To make the code simpler, HARD_REGNO_MODE_OK just references an\n    array built in override_options.  Because machmodes.h is not yet\n    included before this file is processed, the MODE bound can't be\n    expressed here.  */\n@@ -1731,10 +1661,7 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 2)\n \n-/* If the structure value address is not passed in a register, define\n-   `STRUCT_VALUE' as an expression returning an RTX for the place\n-   where the address is passed.  If it returns 0, the address is\n-   passed as an \"invisible\" first argument.  */\n+/* Pass structure addresses as an \"invisible\" first argument.  */\n #define STRUCT_VALUE 0\n \n /* Mips registers used in prologue/epilogue code when the stack frame\n@@ -2179,13 +2106,6 @@ extern enum reg_class mips_char_to_class[256];\n    + (TARGET_ABICALLS && !TARGET_NEWABI\t\t\t\t\t\\\n       ? MIPS_STACK_ALIGN (UNITS_PER_WORD) : 0))\n \n-/* The return address for the current frame is in r31 if this is a leaf\n-   function.  Otherwise, it is on the stack.  It is at a variable offset\n-   from sp/fp/ap, so we define a fake hard register rap which is a\n-   pointer to the return address on the stack.  This always gets eliminated\n-   during reload to be either the frame pointer or the stack pointer plus\n-   an offset.  */\n-\n #define RETURN_ADDR_RTX mips_return_addr\n \n /* Since the mips16 ISA mode is encoded in the least-significant bit\n@@ -2200,33 +2120,7 @@ extern enum reg_class mips_char_to_class[256];\n \n #define TARGET_PTRMEMFUNC_VBIT_LOCATION ptrmemfunc_vbit_in_delta\n \n-/* If defined, this macro specifies a table of register pairs used to\n-   eliminate unneeded registers that point into the stack frame.  If\n-   it is not defined, the only elimination attempted by the compiler\n-   is to replace references to the frame pointer with references to\n-   the stack pointer.\n-\n-   The definition of this macro is a list of structure\n-   initializations, each of which specifies an original and\n-   replacement register.\n-\n-   On some machines, the position of the argument pointer is not\n-   known until the compilation is completed.  In such a case, a\n-   separate hard register must be used for the argument pointer.\n-   This register can be eliminated by replacing it with either the\n-   frame pointer or the argument pointer, depending on whether or not\n-   the frame pointer has been eliminated.\n-\n-   In this case, you might specify:\n-        #define ELIMINABLE_REGS  \\\n-        {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n-         {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \\\n-         {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n-\n-   Note that the elimination of the argument pointer with the stack\n-   pointer is specified first since that is the preferred elimination.\n-\n-   The eliminations to $17 are only used on the mips16.  See the\n+/* The eliminations to $17 are only used for mips16 code.  See the\n    definition of HARD_FRAME_POINTER_REGNUM.  */\n \n #define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n@@ -2237,82 +2131,37 @@ extern enum reg_class mips_char_to_class[256];\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\t\\\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 17}}\n \n-/* A C expression that returns nonzero if the compiler is allowed to\n-   try to replace register number FROM-REG with register number\n-   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n-   defined, and will usually be the constant 1, since most of the\n-   cases preventing register elimination are things that the compiler\n-   already knows about.\n-\n-   When not in mips16 and mips64, we can always eliminate to the\n-   frame pointer.  We can eliminate to the stack pointer unless\n-   a frame pointer is needed.  In mips16 mode, we need a frame\n-   pointer for a large frame; otherwise, reload may be unable\n-   to compute the address of a local variable, since there is\n-   no way to add a large constant to the stack pointer\n+/* We can always eliminate to the hard frame pointer.  We can eliminate\n+   to the stack pointer unless a frame pointer is needed.\n+\n+   In mips16 mode, we need a frame pointer for a large frame; otherwise,\n+   reload may be unable to compute the address of a local variable,\n+   since there is no way to add a large constant to the stack pointer\n    without using a temporary register.\n \n-   In mips16, for some instructions (eg lwu), we can't eliminate the\n+   Also, for some mips16 instructions (eg lwu), we can't eliminate the\n    frame pointer for the stack pointer.  These instructions are\n-   only generated in TARGET_64BIT mode.\n-   */\n-\n+   only generated in TARGET_64BIT mode.  */\n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n-   (((TO) == HARD_FRAME_POINTER_REGNUM \t\t\t\t        \\\n-\t  || ((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed\t\\\n-\t      && ! (TARGET_MIPS16 && TARGET_64BIT)\t\t\t\\\n-\t      && (! TARGET_MIPS16\t\t\t\t\t\\\n-\t          || compute_frame_size (get_frame_size ()) < 32768))))\n+  ((TO) == HARD_FRAME_POINTER_REGNUM \t\t\t\t        \\\n+   || ((TO) == STACK_POINTER_REGNUM && !frame_pointer_needed\t\t\\\n+       && !(TARGET_MIPS16 && TARGET_64BIT)\t\t\t\t\\\n+       && (!TARGET_MIPS16\t\t\t\t\t\t\\\n+\t   || compute_frame_size (get_frame_size ()) < 32768)))\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-\t(OFFSET) = mips_initial_elimination_offset ((FROM), (TO))\n+  (OFFSET) = mips_initial_elimination_offset ((FROM), (TO))\n \n-/* If defined, the maximum amount of space required for outgoing\n-   arguments will be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed\n-   onto the stack for each call; instead, the function prologue\n-   should increase the stack frame size by this amount.\n-\n-   It is not proper to define both `PUSH_ROUNDING' and\n-   `ACCUMULATE_OUTGOING_ARGS'.  */\n+/* Allocate stack space for arguments at the beginning of each function.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n-/* Offset from the argument pointer register to the first argument's\n-   address.  On some machines it may depend on the data type of the\n-   function.\n-\n-   If `ARGS_GROW_DOWNWARD', this is the offset to the location above\n-   the first argument's address.\n-\n-   On the MIPS, we must skip the first argument position if we are\n-   returning a structure or a union, to account for its address being\n-   passed in $4.  However, at the current time, this produces a compiler\n-   that can't bootstrap, so comment it out for now.  */\n-\n-#if 0\n-#define FIRST_PARM_OFFSET(FNDECL)\t\t\t\t\t\\\n-  (FNDECL != 0\t\t\t\t\t\t\t\t\\\n-   && TREE_TYPE (FNDECL) != 0\t\t\t\t\t\t\\\n-   && TREE_TYPE (TREE_TYPE (FNDECL)) != 0\t\t\t\t\\\n-   && (TREE_CODE (TREE_TYPE (TREE_TYPE (FNDECL))) == RECORD_TYPE\t\\\n-       || TREE_CODE (TREE_TYPE (TREE_TYPE (FNDECL))) == UNION_TYPE)\t\\\n-\t\t? UNITS_PER_WORD\t\t\t\t\t\\\n-\t\t: 0)\n-#else\n+/* The argument pointer always points to the first argument.  */\n #define FIRST_PARM_OFFSET(FNDECL) 0\n-#endif\n \n-/* When a parameter is passed in a register, stack space is still\n-   allocated for it.  For the MIPS, stack space must be allocated, cf\n-   Asm Lang Prog Guide page 7-8.\n-\n-   BEWARE that some space is also allocated for non existing arguments\n-   in register. In case an argument list is of form GF used registers\n-   are a0 (a2,a3), but we should push over a1...  */\n-\n-#define REG_PARM_STACK_SPACE(FNDECL) \t\t\t\t\t \\\n-  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\t\t\t \\\n-   ? (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL) \\\n+/* o32 and o64 reserve stack space for all argument registers.  */\n+#define REG_PARM_STACK_SPACE(FNDECL) \t\t\t\\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\t\\\n+   ? (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD)\t\t\\\n    : 0)\n \n /* Define this if it is the responsibility of the caller to\n@@ -2327,35 +2176,8 @@ extern enum reg_class mips_char_to_class[256];\n    ? 64 : 128)\n \n \f\n-/* A C expression that should indicate the number of bytes of its\n-   own arguments that a function pops on returning, or 0\n-   if the function pops no arguments and the caller must therefore\n-   pop them all after the function returns.\n-\n-   FUNDECL is the declaration node of the function (as a tree).\n-\n-   FUNTYPE is a C variable whose value is a tree node that\n-   describes the function in question.  Normally it is a node of\n-   type `FUNCTION_TYPE' that describes the data type of the function.\n-   From this it is possible to obtain the data types of the value\n-   and arguments (if known).\n-\n-   When a call to a library function is being considered, FUNTYPE\n-   will contain an identifier node for the library function.  Thus,\n-   if you need to distinguish among various library functions, you\n-   can do so by their names.  Note that \"library function\" in this\n-   context means a function used to perform arithmetic, whose name\n-   is known specially in the compiler and was not mentioned in the\n-   C code being compiled.\n-\n-   STACK-SIZE is the number of bytes of arguments passed on the\n-   stack.  If a variable number of bytes is passed, it is zero, and\n-   argument popping will always be the responsibility of the\n-   calling function.  */\n-\n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n \n-\n /* Symbolic macros for the registers used to return integer and floating\n    point values.  */\n \n@@ -2376,19 +2198,9 @@ extern enum reg_class mips_char_to_class[256];\n #define FP_ARG_FIRST (FP_REG_FIRST + 12)\n #define FP_ARG_LAST  (FP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n \n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  Because we define\n-   PROMOTE_FUNCTION_RETURN, we must promote the mode just as\n-   PROMOTE_MODE does.  */\n-\n #define LIBCALL_VALUE(MODE) \\\n   mips_function_value (NULL_TREE, NULL, (MODE))\n \n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n   mips_function_value ((VALTYPE), (FUNC), VOIDmode)\n \n@@ -2410,46 +2222,20 @@ extern enum reg_class mips_char_to_class[256];\n \t&& ((N) % FP_INC == 0) && mips_abi != ABI_O64))\t\t\\\n    && !fixed_regs[N])\n \n-/* A C expression which can inhibit the returning of certain function\n-   values in registers, based on the type of value.  A nonzero value says\n-   to return the function value in memory, just as large structures are\n-   always returned.  Here TYPE will be a C expression of type\n-   `tree', representing the data type of the value.\n-\n-   Note that values of mode `BLKmode' must be explicitly\n-   handled by this macro.  Also, the option `-fpcc-struct-return'\n-   takes effect regardless of this macro.  On most systems, it is\n-   possible to leave the macro undefined; this causes a default\n-   definition to be used, whose value is the constant 1 for BLKmode\n-   values, and 0 otherwise.\n-\n-   GCC normally converts 1 byte structures into chars, 2 byte\n-   structs into shorts, and 4 byte structs into ints, and returns\n-   them this way.  Defining the following macro overrides this,\n-   to give us MIPS cc compatibility.  */\n-\n-#define RETURN_IN_MEMORY(TYPE)\t\\\n-\tmips_return_in_memory (TYPE)\n+#define RETURN_IN_MEMORY(TYPE) mips_return_in_memory (TYPE)\n \n #define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n \t(PRETEND_SIZE) = mips_setup_incoming_varargs (&(CUM), (MODE),\t\\\n \t\t\t\t\t\t      (TYPE), (NO_RTL))\n \f\n #define STRICT_ARGUMENT_NAMING (mips_abi != ABI_32 && mips_abi != ABI_O64)\n \n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   This structure has to cope with two different argument allocation\n+/* This structure has to cope with two different argument allocation\n    schemes.  Most MIPS ABIs view the arguments as a struct, of which the\n    first N words go in registers and the rest go on the stack.  If I < N,\n    the Ith word might go in Ith integer argument register or the\n-   Ith floating-point one.  In some cases, it has to go in both (see\n-   function_arg).  For these ABIs, we only need to remember the number\n-   of words passed so far.\n+   Ith floating-point one.  For these ABIs, we only need to remember\n+   the number of words passed so far.\n \n    The EABI instead allocates the integer and floating-point arguments\n    separately.  The first N words of FP arguments go in FP registers,"}]}