{"sha": "d746e87d41548db18c07a1e400f3e446c71f27b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0NmU4N2Q0MTU0OGRiMThjMDdhMWU0MDBmM2U0NDZjNzFmMjdiNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-11-10T17:01:00Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-11-10T17:01:00Z"}, "message": "re PR c++/18369 (Segfault on braced new)\n\n\tPR c++/18369\n\t* init.c (build_new_1): Handle parenthesized type-ids that name an\n\tarray type.  Tidy.\n\n\tPR c++/18369\n\t* g++.dg/init/new12.C: New test.\n\nFrom-SVN: r90394", "tree": {"sha": "29af1a5a411111dc12fe0ef9a57841e7e1ebc56d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29af1a5a411111dc12fe0ef9a57841e7e1ebc56d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d746e87d41548db18c07a1e400f3e446c71f27b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d746e87d41548db18c07a1e400f3e446c71f27b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d746e87d41548db18c07a1e400f3e446c71f27b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d746e87d41548db18c07a1e400f3e446c71f27b4/comments", "author": null, "committer": null, "parents": [{"sha": "8393a290d26dfaa9d5ff3e7981a3b8a984645cc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8393a290d26dfaa9d5ff3e7981a3b8a984645cc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8393a290d26dfaa9d5ff3e7981a3b8a984645cc2"}], "stats": {"total": 151, "additions": 92, "deletions": 59}, "files": [{"sha": "a3d6abaf3c6084a70856fe7fbf20392b8d44460d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d746e87d41548db18c07a1e400f3e446c71f27b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d746e87d41548db18c07a1e400f3e446c71f27b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d746e87d41548db18c07a1e400f3e446c71f27b4", "patch": "@@ -1,3 +1,9 @@\n+2004-11-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18369\n+\t* init.c (build_new_1): Handle parenthesized type-ids that name an\n+\tarray type.  Tidy.\n+\n 2004-11-09  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* call.c, class.c, decl.c, decl2.c, error.c, mangle.c, parser.c,"}, {"sha": "9d00d4b6a4667a0286b37f203ba32fbe3f60eb77", "filename": "gcc/cp/init.c", "status": "modified", "additions": 75, "deletions": 59, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d746e87d41548db18c07a1e400f3e446c71f27b4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d746e87d41548db18c07a1e400f3e446c71f27b4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d746e87d41548db18c07a1e400f3e446c71f27b4", "patch": "@@ -1718,15 +1718,29 @@ static tree\n build_new_1 (tree exp)\n {\n   tree placement, init;\n-  tree true_type, size, rval;\n+  tree size, rval;\n+  /* True iff this is a call to \"operator new[]\" instead of just\n+     \"operator new\".  */   \n+  bool array_p = false;\n+  /* True iff ARRAY_P is true and the bound of the array type is\n+     not necessarily a compile time constant.  For example, VLA_P is\n+     true for \"new int[f()]\".  */\n+  bool vla_p = false;\n+  /* The type being allocated.  If ARRAY_P is true, this will be an \n+     ARRAY_TYPE.  */\n+  tree full_type;\n+  /* If ARRAY_P is true, the element type of the array.  This is an\n+     never ARRAY_TYPE; for something like \"new int[3][4]\", the\n+     ELT_TYPE is \"int\".  If ARRAY_P is false, this is the same type as\n+     FULL_TYPE.  */\n+  tree elt_type;\n   /* The type of the new-expression.  (This type is always a pointer\n      type.)  */\n   tree pointer_type;\n-  /* The type pointed to by POINTER_TYPE.  */\n+  /* The type pointed to by POINTER_TYPE.  This type may be different\n+     from ELT_TYPE for a multi-dimensional array; ELT_TYPE is never an\n+     ARRAY_TYPE, but TYPE may be an ARRAY_TYPE.  */\n   tree type;\n-  /* The type being allocated.  For \"new T[...]\" this will be an\n-     ARRAY_TYPE.  */\n-  tree full_type;\n   /* A pointer type pointing to to the FULL_TYPE.  */\n   tree full_pointer_type;\n   tree outer_nelts = NULL_TREE;\n@@ -1737,8 +1751,6 @@ build_new_1 (tree exp)\n   tree alloc_node;\n   tree alloc_fn;\n   tree cookie_expr, init_expr;\n-  int has_array = 0;\n-  enum tree_code code;\n   int nothrow, check_new;\n   /* Nonzero if the user wrote `::new' rather than just `new'.  */\n   int globally_qualified_p;\n@@ -1771,76 +1783,80 @@ build_new_1 (tree exp)\n     {\n       tree index;\n \n-      has_array = 1;\n       outer_nelts = nelts;\n+      array_p = true;\n \n       /* ??? The middle-end will error on us for building a VLA outside a \n \t function context.  Methinks that's not it's purvey.  So we'll do\n \t our own VLA layout later.  */\n-\n+      vla_p = true;\n       full_type = build_cplus_array_type (type, NULL_TREE);\n-\n       index = convert (sizetype, nelts);\n       index = size_binop (MINUS_EXPR, index, size_one_node);\n       TYPE_DOMAIN (full_type) = build_index_type (index);\n     }\n   else\n-    full_type = type;\n-\n-  true_type = type;\n-\n-  code = has_array ? VEC_NEW_EXPR : NEW_EXPR;\n+    {\n+      full_type = type;\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  array_p = true;\n+\t  nelts = array_type_nelts_top (type);\n+\t  outer_nelts = nelts;\n+\t  type = TREE_TYPE (type);\n+\t}\n+    }\n \n   /* If our base type is an array, then make sure we know how many elements\n      it has.  */\n-  while (TREE_CODE (true_type) == ARRAY_TYPE)\n-    {\n-      tree this_nelts = array_type_nelts_top (true_type);\n-      nelts = cp_build_binary_op (MULT_EXPR, nelts, this_nelts);\n-      true_type = TREE_TYPE (true_type);\n-    }\n+  for (elt_type = type;\n+       TREE_CODE (elt_type) == ARRAY_TYPE;\n+       elt_type = TREE_TYPE (elt_type))\n+    nelts = cp_build_binary_op (MULT_EXPR, nelts, \n+\t\t\t\tarray_type_nelts_top (elt_type));\n \n-  if (!complete_type_or_else (true_type, exp))\n+  if (!complete_type_or_else (elt_type, exp))\n     return error_mark_node;\n \n-  if (TREE_CODE (true_type) == VOID_TYPE)\n+  if (TREE_CODE (elt_type) == VOID_TYPE)\n     {\n       error (\"invalid type %<void%> for new\");\n       return error_mark_node;\n     }\n \n-  if (abstract_virtuals_error (NULL_TREE, true_type))\n+  if (abstract_virtuals_error (NULL_TREE, elt_type))\n     return error_mark_node;\n \n-  is_initialized = (TYPE_NEEDS_CONSTRUCTING (type) || init);\n-  if (CP_TYPE_CONST_P (true_type) && !is_initialized)\n+  is_initialized = (TYPE_NEEDS_CONSTRUCTING (elt_type) || init);\n+  if (CP_TYPE_CONST_P (elt_type) && !is_initialized)\n     {\n-      error (\"uninitialized const in %<new%> of %q#T\", true_type);\n+      error (\"uninitialized const in %<new%> of %q#T\", elt_type);\n       return error_mark_node;\n     }\n \n-  size = size_in_bytes (true_type);\n-  if (has_array)\n+  size = size_in_bytes (elt_type);\n+  if (array_p)\n     {\n-      tree n, bitsize;\n-\n-      /* Do our own VLA layout.  Setting TYPE_SIZE/_UNIT is necessary in\n-\t order for the <INIT_EXPR <*foo> <CONSTRUCTOR ...>> to be valid.  */\n-\n-      n = convert (sizetype, nelts);\n-      size = size_binop (MULT_EXPR, size, n);\n-      TYPE_SIZE_UNIT (full_type) = size;\n-\n-      n = convert (bitsizetype, nelts);\n-      bitsize = size_binop (MULT_EXPR, TYPE_SIZE (true_type), n);\n-      TYPE_SIZE (full_type) = bitsize;\n+      size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n+      if (vla_p)\n+\t{\n+\t  tree n, bitsize;\n+\n+\t  /* Do our own VLA layout.  Setting TYPE_SIZE/_UNIT is\n+\t     necessary in order for the <INIT_EXPR <*foo> <CONSTRUCTOR\n+\t     ...>> to be valid.  */\n+\t  TYPE_SIZE_UNIT (full_type) = size;\n+\t  n = convert (bitsizetype, nelts);\n+\t  bitsize = size_binop (MULT_EXPR, TYPE_SIZE (elt_type), n);\n+\t  TYPE_SIZE (full_type) = bitsize;\n+\t}\n     }\n \n   /* Allocate the object.  */\n-  if (! placement && TYPE_FOR_JAVA (true_type))\n+  if (! placement && TYPE_FOR_JAVA (elt_type))\n     {\n       tree class_addr, alloc_decl;\n-      tree class_decl = build_java_class_ref (true_type);\n+      tree class_decl = build_java_class_ref (elt_type);\n       static const char alloc_name[] = \"_Jv_AllocObject\";\n \n       use_java_new = 1;\n@@ -1867,32 +1883,32 @@ build_new_1 (tree exp)\n       tree fnname;\n       tree fns;\n \n-      fnname = ansi_opname (code);\n+      fnname = ansi_opname (array_p ? VEC_NEW_EXPR : NEW_EXPR);\n \n       if (!globally_qualified_p \n-\t  && CLASS_TYPE_P (true_type)\n-\t  && (has_array\n-\t      ? TYPE_HAS_ARRAY_NEW_OPERATOR (true_type)\n-\t      : TYPE_HAS_NEW_OPERATOR (true_type)))\n+\t  && CLASS_TYPE_P (elt_type)\n+\t  && (array_p\n+\t      ? TYPE_HAS_ARRAY_NEW_OPERATOR (elt_type)\n+\t      : TYPE_HAS_NEW_OPERATOR (elt_type)))\n \t{\n \t  /* Use a class-specific operator new.  */\n \t  /* If a cookie is required, add some extra space.  */\n-\t  if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n+\t  if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))\n \t    {\n-\t      cookie_size = targetm.cxx.get_cookie_size (true_type);\n+\t      cookie_size = targetm.cxx.get_cookie_size (elt_type);\n \t      size = size_binop (PLUS_EXPR, size, cookie_size);\n \t    }\n \t  /* Create the argument list.  */\n \t  args = tree_cons (NULL_TREE, size, placement);\n \t  /* Do name-lookup to find the appropriate operator.  */\n-\t  fns = lookup_fnfields (true_type, fnname, /*protect=*/2);\n+\t  fns = lookup_fnfields (elt_type, fnname, /*protect=*/2);\n \t  if (TREE_CODE (fns) == TREE_LIST)\n \t    {\n \t      error (\"request for member %qD is ambiguous\", fnname);\n \t      print_candidates (fns);\n \t      return error_mark_node;\n \t    }\n-\t  alloc_call = build_new_method_call (build_dummy_object (true_type),\n+\t  alloc_call = build_new_method_call (build_dummy_object (elt_type),\n \t\t\t\t\t      fns, args,\n \t\t\t\t\t      /*conversion_path=*/NULL_TREE,\n \t\t\t\t\t      LOOKUP_NORMAL);\n@@ -1901,8 +1917,8 @@ build_new_1 (tree exp)\n \t{\n \t  /* Use a global operator new.  */\n \t  /* See if a cookie might be required.  */\n-\t  if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n-\t    cookie_size = targetm.cxx.get_cookie_size (true_type);\n+\t  if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))\n+\t    cookie_size = targetm.cxx.get_cookie_size (elt_type);\n \t  else\n \t    cookie_size = NULL_TREE;\n \n@@ -1995,7 +2011,7 @@ build_new_1 (tree exp)\n \t\t\t       cookie_ptr, size_in_bytes (sizetype));\n \t  cookie = build_indirect_ref (cookie_ptr, NULL);\n \t  cookie = build2 (MODIFY_EXPR, sizetype, cookie,\n-\t\t\t   size_in_bytes(true_type));\n+\t\t\t   size_in_bytes(elt_type));\n \t  cookie_expr = build2 (COMPOUND_EXPR, TREE_TYPE (cookie_expr),\n \t\t\t\tcookie, cookie_expr);\n \t}\n@@ -2020,10 +2036,10 @@ build_new_1 (tree exp)\n \n       if (init == void_zero_node)\n \tinit = build_default_init (full_type, nelts);\n-      else if (init && has_array)\n+      else if (init && array_p)\n \tpedwarn (\"ISO C++ forbids initialization in array new\");\n \n-      if (has_array)\n+      if (array_p)\n \t{\n \t  init_expr\n \t    = build_vec_init (init_expr,\n@@ -2040,7 +2056,7 @@ build_new_1 (tree exp)\n \t{\n \t  init_expr = build_special_member_call (init_expr, \n \t\t\t\t\t\t complete_ctor_identifier,\n-\t\t\t\t\t\t init, true_type,\n+\t\t\t\t\t\t init, elt_type,\n \t\t\t\t\t\t LOOKUP_NORMAL);\n \t  stable = stabilize_init (init_expr, &init_preeval_expr);\n \t}\n@@ -2073,7 +2089,7 @@ build_new_1 (tree exp)\n \t freed.  */\n       if (flag_exceptions && ! use_java_new)\n \t{\n-\t  enum tree_code dcode = has_array ? VEC_DELETE_EXPR : DELETE_EXPR;\n+\t  enum tree_code dcode = array_p ? VEC_DELETE_EXPR : DELETE_EXPR;\n \t  tree cleanup;\n \n \t  /* The Standard is unclear here, but the right thing to do"}, {"sha": "427d8f4bde9cd492f535829fee984aeb3a15933e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d746e87d41548db18c07a1e400f3e446c71f27b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d746e87d41548db18c07a1e400f3e446c71f27b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d746e87d41548db18c07a1e400f3e446c71f27b4", "patch": "@@ -1,3 +1,8 @@\n+2004-11-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18369\n+\t* g++.dg/init/new12.C: New test.\n+\n 2004-11-10  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* gcc.target/sparc: New directory."}, {"sha": "ce2acb237e271221f54c9fd1f8130c79ab3cd7f7", "filename": "gcc/testsuite/g++.dg/init/new12.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d746e87d41548db18c07a1e400f3e446c71f27b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d746e87d41548db18c07a1e400f3e446c71f27b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew12.C?ref=d746e87d41548db18c07a1e400f3e446c71f27b4", "patch": "@@ -0,0 +1,6 @@\n+// PR c++/18369\n+\n+void breakme () \n+{\n+  int *v = new (int [5]);\n+}"}]}