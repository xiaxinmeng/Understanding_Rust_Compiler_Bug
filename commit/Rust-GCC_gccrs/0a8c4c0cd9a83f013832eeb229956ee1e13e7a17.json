{"sha": "0a8c4c0cd9a83f013832eeb229956ee1e13e7a17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE4YzRjMGNkOWE4M2YwMTM4MzJlZWIyMjk5NTZlZTFlMTNlN2ExNw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-18T23:45:59Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-18T23:45:59Z"}, "message": "Makefile.am (exception): Change exception.cc to exception_support.cc.\n\n\n2000-10-18   Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* libsupc++/Makefile.am (exception): Change exception.cc to\n\texception_support.cc.\n\t(CXXLINK): Remove bogus --tag CC.\n\t* libsupc++/Makefile.in: Regenerate.\n\t* libsupc++/exception.cc: Move to...\n\t* libsupc++/exception_support.cc: ...here.\n\n\t* src/Makefile.am: Remove bogus --tag CC.\n\t* src/Makefile.in: Regenerate.\n\n\t* include/bits/locale_facets.tcc (use_facet): Simplify.\n\t* include/bits/locale_facets.h (use_facet<ctype<char> >): Correct\n\tuse_facet declaration. Replace 'const ctype<T>' with ctype<T>.\n\t(use_facet<ctype<wchar_t> >): Same.\n\t* src/locale-inst.cc: Remove explicit instantiation.\n\t* src/locale.cc: Correct signature here too.\n\t(_Bad_use_facet::what()): Correct error string.\n\t* include/bits/localefwd.h: Correct comment.\n\n\t* mkcheck.in (C_DIR): Change libsupc++/include to libsupc++.\n\nFrom-SVN: r36945", "tree": {"sha": "2596e51eb69aa7d8f95f2f3e835f73f5f8e032ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2596e51eb69aa7d8f95f2f3e835f73f5f8e032ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a8c4c0cd9a83f013832eeb229956ee1e13e7a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8c4c0cd9a83f013832eeb229956ee1e13e7a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8c4c0cd9a83f013832eeb229956ee1e13e7a17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8c4c0cd9a83f013832eeb229956ee1e13e7a17/comments", "author": null, "committer": null, "parents": [{"sha": "b0166fda4546d30a415a7d5507fefa81d8daa807", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0166fda4546d30a415a7d5507fefa81d8daa807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0166fda4546d30a415a7d5507fefa81d8daa807"}], "stats": {"total": 403, "additions": 403, "deletions": 0}, "files": [{"sha": "886915c823bb5554ea93f59761ed7d5884193679", "filename": "libstdc++-v3/libsupc++/exception_support.cc", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8c4c0cd9a83f013832eeb229956ee1e13e7a17/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8c4c0cd9a83f013832eeb229956ee1e13e7a17/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc?ref=0a8c4c0cd9a83f013832eeb229956ee1e13e7a17", "patch": "@@ -0,0 +1,403 @@\n+// Functions for Exception Support for -*- C++ -*-\n+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation\n+\n+// This file is part of GNU CC.\n+\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#pragma implementation \"exception\"\n+\n+#include \"typeinfo\"\n+#include \"exception\"\n+#include <stddef.h>\n+#include \"gansidecl.h\" /* Needed to support macros used in eh-common.h. */\n+#include \"eh-common.h\"\n+\n+/* Define terminate, unexpected, set_terminate, set_unexpected as\n+   well as the default terminate func and default unexpected func.  */\n+\n+extern std::terminate_handler __terminate_func __attribute__((__noreturn__));\n+using std::terminate;\n+\n+void\n+std::terminate ()\n+{\n+  __terminate_func ();\n+}\n+\n+void\n+__default_unexpected ()\n+{\n+  terminate ();\n+}\n+\n+static std::unexpected_handler __unexpected_func __attribute__((__noreturn__))\n+  = __default_unexpected;\n+\n+std::terminate_handler\n+std::set_terminate (std::terminate_handler func)\n+{\n+  std::terminate_handler old = __terminate_func;\n+\n+  __terminate_func = func;\n+  return old;\n+}\n+\n+std::unexpected_handler\n+std::set_unexpected (std::unexpected_handler func)\n+{\n+  std::unexpected_handler old = __unexpected_func;\n+\n+  __unexpected_func = func;\n+  return old;\n+}\n+\n+void\n+std::unexpected ()\n+{\n+  __unexpected_func ();\n+}\n+\n+/* The type of a function called to clean up an exception object.\n+   (These will be destructors.)  Under the old ABI, these take a\n+   second argument (the `in-charge' argument), that indicates whether\n+   or not do delete the object, and whether or not to destroy virtual\n+   bases.  Under the new ABI, there is no second argument.  */\n+#if !defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+typedef void (*cleanup_fn)(void *, int);\n+/* The `2' is the value for the in-charge parameter that indicates\n+   that virtual bases should be destroyed.  */\n+#define CALL_CLEANUP(FN, THIS) FN (THIS, 2)\n+#else\n+typedef void (*cleanup_fn)(void *);\n+#define CALL_CLEANUP(FN, THIS) FN (THIS)\n+#endif\n+\n+/* C++-specific state about the current exception.\n+   This must match init_exception_processing().\n+\n+   Note that handlers and caught are not redundant; when rethrown, an\n+   exception can have multiple active handlers and still be considered\n+   uncaught.  */\n+\n+struct cp_eh_info\n+{\n+  __eh_info eh_info;\n+  void *value;\n+  void *type;\n+  cleanup_fn cleanup;\n+  bool caught;\n+  cp_eh_info *next;\n+  long handlers;\n+  void *original_value;\n+};\n+\n+/* Language-specific EH info pointer, defined in libgcc2. */\n+\n+extern \"C\" cp_eh_info **__get_eh_info (); \t// actually void **\n+\n+/* Exception allocate and free, defined in libgcc2. */\n+extern \"C\" void *__eh_alloc(size_t);\n+extern \"C\" void __eh_free(void *);\n+\n+/* Is P the type_info node for a pointer of some kind?  */\n+\n+extern bool __is_pointer (void *);\n+\n+\n+/* OLD Compiler hook to return a pointer to the info for the current exception.\n+   Used by get_eh_info ().  This fudges the actualy returned value to\n+   point to the beginning of what USE to be the cp_eh_info structure.\n+   THis is so that old code that dereferences this pointer will find\n+   things where it expects it to be.*/\n+extern \"C\" void *\n+__cp_exception_info (void)\n+{\n+  return &((*__get_eh_info ())->value);\n+}\n+\n+#define CP_EH_INFO ((cp_eh_info *) *__get_eh_info ())\n+\n+/* Old Compiler hook to return a pointer to the info for the current exception.\n+   Used by get_eh_info ().  */\n+\n+extern \"C\" cp_eh_info *\n+__cp_eh_info (void)\n+{\n+  cp_eh_info *p = CP_EH_INFO;\n+  return p;\n+}\n+\n+/* Compiler hook to return a pointer to the info for the current exception,\n+   Set the caught bit, and increment the number of handlers that are\n+   looking at this exception. This makes handlers smaller. */\n+\n+extern \"C\" cp_eh_info *\n+__start_cp_handler (void)\n+{\n+  cp_eh_info *p = CP_EH_INFO;\n+  p->caught = 1;\n+  p->handlers++;\n+  return p;\n+}\n+\n+extern \"C\" int __throw_type_match_rtti_2 (const void *, const void *,\n+\t\t\t\t\t void *, void **);\n+\n+extern \"C\" void *\n+__cplus_type_matcher (__eh_info *info_, void *match_info,\n+\t\t      exception_descriptor *exception_table)\n+{\n+  cp_eh_info *info = (cp_eh_info *)info_;\n+\n+  /* No exception table implies the old style mechanism, so don't check. */\n+  if (exception_table != NULL \n+      && exception_table->lang.language != EH_LANG_C_plus_plus)\n+    return NULL;\n+\n+  if (match_info == CATCH_ALL_TYPE)\n+    return (void *)1;\n+\n+  /* we don't worry about version info yet, there is only one version! */\n+  \n+  void *match_type = match_info;\n+  \n+#if !defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+  match_type  = ((void *(*)())match_type) ();\n+#endif\n+\n+  if (__throw_type_match_rtti_2 (match_type, info->type,\n+\t\t\t\t info->original_value, &info->value))\n+    // Arbitrary non-null pointer.\n+    return (void *)1;\n+  else\n+    return NULL;\n+}\n+\n+/* Compiler hook to push a new exception onto the stack.\n+   Used by expand_throw().  */\n+\n+extern \"C\" void\n+__cp_push_exception (void *value, void *type, cleanup_fn cleanup)\n+{\n+  cp_eh_info *p = (cp_eh_info *) __eh_alloc (sizeof (cp_eh_info));\n+\n+  p->value = value;\n+  p->type = type;\n+  p->cleanup = cleanup;\n+  p->handlers = 0;\n+  p->caught = false;\n+  p->original_value = value;\n+\n+  p->eh_info.match_function = __cplus_type_matcher;\n+  p->eh_info.language = EH_LANG_C_plus_plus;\n+  p->eh_info.version = 1;\n+\n+  cp_eh_info **q = __get_eh_info ();\n+\n+  p->next = *q;\n+  *q = p;\n+}\n+\n+/* Compiler hook to pop an exception that has been finalized.  Used by\n+   push_eh_cleanup().  P is the info for the exception caught by the\n+   current catch block.  */\n+\n+extern \"C\" void\n+__cp_pop_exception (cp_eh_info *p)\n+{\n+  cp_eh_info **stack = __get_eh_info ();\n+  cp_eh_info **q = stack;\n+\n+  --p->handlers;\n+\n+  /* Do nothing if our exception is being rethrown (i.e. if the active\n+     exception is our exception and it is uncaught).  */\n+  if (p == *q && !p->caught)\n+    return;\n+\n+  /* Don't really pop if there are still active handlers for our exception;\n+     rather, push it down past any uncaught exceptions.  */\n+  if (p->handlers != 0)\n+    {\n+      if (p == *q && p->next && !p->next->caught)\n+\t{\n+\t  q = &(p->next);\n+\t  while (1)\n+\t    {\n+\t      if (*q == 0 || (*q)->caught)\n+\t\tbreak;\n+\n+\t      q = &((*q)->next);\n+\t    }\n+\t  *stack = p->next;\n+\t  p->next = *q;\n+\t  *q = p;\n+\t}\n+      return;\n+    }\n+\n+  for (; *q; q = &((*q)->next))\n+    if (*q == p)\n+      break;\n+\n+  if (! *q)\n+    terminate ();\n+\n+  *q = p->next;\n+\n+  if (p->cleanup)\n+    // value may have been adjusted.\n+    CALL_CLEANUP (p->cleanup, p->original_value);\n+\n+  if (! __is_pointer (p->type))\n+    __eh_free (p->original_value);  // value may have been adjusted.\n+\n+  __eh_free (p);\n+}\n+\n+/* We're doing a rethrow.  Find the currently handled exception, mark it\n+   uncaught, and move it to the top of the EH stack.  */\n+\n+extern \"C\" void\n+__uncatch_exception (void)\n+{\n+  cp_eh_info **stack = __get_eh_info ();\n+  cp_eh_info **q = stack;\n+  cp_eh_info *p;\n+\n+  while (1)\n+    {\n+      p = *q;\n+\n+      if (p == 0)\n+\tterminate ();\n+      if (p->caught)\n+\tbreak;\n+\n+      q = &(p->next);\n+    }\n+\n+  if (q != stack)\n+    {\n+      *q = p->next;\n+      p->next = *stack;\n+      *stack = p;\n+    }\n+\n+  p->caught = false;\n+}\n+\n+/* As per [except.unexpected]:\n+   If an exception is thrown, we check it against the spec.  If it doesn't\n+   match, we call unexpected ().  If unexpected () throws, we check that\n+   exception against the spec.  If it doesn't match, if the spec allows\n+   bad_exception we throw that; otherwise we call terminate ().\n+\n+   The compiler treats an exception spec as a try block with a generic\n+   handler that just calls this function with a list of the allowed\n+   exception types, so we have an active exception that can be rethrown.\n+\n+   This function does not return.  */   \n+\n+extern \"C\" void\n+__check_eh_spec (int n, const void **spec)\n+{\n+  cp_eh_info *p = CP_EH_INFO;\n+  void *d;\n+\n+  for (int i = 0; i < n; ++i)\n+    {\n+      if (__throw_type_match_rtti_2 (spec[i], p->type, p->value, &d))\n+\tthrow;\n+    }\n+\n+  try\n+    {\n+      std::unexpected ();\n+    }\n+  catch (...)\n+    {\n+      // __exception_info is an artificial var pushed into each catch block.\n+      if (p != __exception_info)\n+\t{\n+\t  p = __exception_info;\n+\t  for (int i = 0; i < n; ++i)\n+\t    {\n+\t      if (__throw_type_match_rtti_2 (spec[i], p->type, p->value, &d))\n+\t\tthrow;\n+\t    }\n+\t}\n+\n+      const std::type_info &bad_exc = typeid (std::bad_exception);\n+      for (int i = 0; i < n; ++i)\n+\t{\n+\t  if (__throw_type_match_rtti_2 (spec[i], &bad_exc, p->value, &d))\n+\t    throw std::bad_exception ();\n+\t}\n+\n+      terminate ();\n+    }\n+}\n+\n+/* Special case of the above for throw() specs.  */\n+\n+extern \"C\" void\n+__check_null_eh_spec (void)\n+{\n+  __check_eh_spec (0, 0);\n+}\n+\n+// Helpers for rtti. Although these don't return, we give them return types so\n+// that the type system is not broken.\n+\n+extern \"C\" void *\n+__throw_bad_cast ()\n+{\n+  throw std::bad_cast ();\n+  return 0;\n+}\n+\n+extern \"C\" std::type_info const &\n+__throw_bad_typeid ()\n+{\n+  throw std::bad_typeid ();\n+  return typeid (void);\n+}\n+\n+/* Has the current exception been caught?  */\n+\n+bool\n+std::uncaught_exception ()\n+{\n+  cp_eh_info *p = CP_EH_INFO;\n+  return p && ! p->caught;\n+}\n+\n+const char * std::exception::\n+what () const\n+{\n+  return typeid (*this).name ();\n+}"}]}