{"sha": "3918b10802ce96c0c8cf477a0695856dc8d0919a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkxOGIxMDgwMmNlOTZjMGM4Y2Y0NzdhMDY5NTg1NmRjOGQwOTE5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-11-17T23:32:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-11-17T23:32:12Z"}, "message": "md.texi (setmem, movstr): Update documentation.\n\n\t* doc/md.texi (setmem, movstr): Update documentation.\n\t* builtins.c (determine_block_size): New function.\n\t(expand_builtin_memcpy): Use it and pass it to\n\temit_block_move_hints.\n\t(expand_builtin_memset_args): Use it and pass it to\n\tset_storage_via_setmem.\n\t* expr.c (emit_block_move_via_movmem): Add min_size/max_size parameters;\n\tupdate call to expander.\n\t(emit_block_move_hints): Add min_size/max_size parameters.\n\t(clear_storage_hints): Likewise.\n\t(set_storage_via_setmem): Likewise.\n\t(clear_storage): Update.\n\t* expr.h (emit_block_move_hints, clear_storage_hints,\n\tset_storage_via_setmem): Update prototype.\n\t* i386.c (ix86_expand_set_or_movmem): Add bounds; export.\n\t(ix86_expand_movmem, ix86_expand_setmem): Remove.\n\t(ix86_expand_movmem, ix86_expand_setmem): Remove.\n\t* i386.md (movmem, setmem): Pass parameters.\n\t\n\t* gcc.target/i386/memcpy-2.c: New testcase.\n\nFrom-SVN: r204926", "tree": {"sha": "947c4bdd1ca87f99c679541fdf303cfef4a00776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/947c4bdd1ca87f99c679541fdf303cfef4a00776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3918b10802ce96c0c8cf477a0695856dc8d0919a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3918b10802ce96c0c8cf477a0695856dc8d0919a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3918b10802ce96c0c8cf477a0695856dc8d0919a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3918b10802ce96c0c8cf477a0695856dc8d0919a/comments", "author": null, "committer": null, "parents": [{"sha": "2048a057063239900ff4b614c854f5a53bab55de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2048a057063239900ff4b614c854f5a53bab55de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2048a057063239900ff4b614c854f5a53bab55de"}], "stats": {"total": 260, "additions": 208, "deletions": 52}, "files": [{"sha": "d4e0260450f7edfbe09daf244d2064d20796db3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -1,3 +1,24 @@\n+2013-11-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* doc/md.texi (setmem, movstr): Update documentation.\n+\t* builtins.c (determine_block_size): New function.\n+\t(expand_builtin_memcpy): Use it and pass it to\n+\temit_block_move_hints.\n+\t(expand_builtin_memset_args): Use it and pass it to\n+\tset_storage_via_setmem.\n+\t* expr.c (emit_block_move_via_movmem): Add min_size/max_size parameters;\n+\tupdate call to expander.\n+\t(emit_block_move_hints): Add min_size/max_size parameters.\n+\t(clear_storage_hints): Likewise.\n+\t(set_storage_via_setmem): Likewise.\n+\t(clear_storage): Update.\n+\t* expr.h (emit_block_move_hints, clear_storage_hints,\n+\tset_storage_via_setmem): Update prototype.\n+\t* i386.c (ix86_expand_set_or_movmem): Add bounds; export.\n+\t(ix86_expand_movmem, ix86_expand_setmem): Remove.\n+\t(ix86_expand_movmem, ix86_expand_setmem): Remove.\n+\t* i386.md (movmem, setmem): Pass parameters.\n+\n 2013-11-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/59153"}, {"sha": "5c8577a8e82b1f7f54251c8d8c85e1e52c164335", "filename": "gcc/builtins.c", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -3095,6 +3095,51 @@ builtin_memcpy_read_str (void *data, HOST_WIDE_INT offset,\n   return c_readstr (str + offset, mode);\n }\n \n+/* LEN specify length of the block of memcpy/memset operation.\n+   Figure out its range and put it into MIN_SIZE/MAX_SIZE.  */\n+\n+static void\n+determine_block_size (tree len, rtx len_rtx,\n+\t\t      unsigned HOST_WIDE_INT *min_size,\n+\t\t      unsigned HOST_WIDE_INT *max_size)\n+{\n+  if (CONST_INT_P (len_rtx))\n+    {\n+      *min_size = *max_size = UINTVAL (len_rtx);\n+      return;\n+    }\n+  else\n+    {\n+      double_int min, max;\n+      if (TREE_CODE (len) == SSA_NAME \n+\t  && get_range_info (len, &min, &max) == VR_RANGE)\n+\t{\n+\t  if (min.fits_uhwi ())\n+\t    *min_size = min.to_uhwi ();\n+\t  else\n+\t    *min_size = 0;\n+\t  if (max.fits_uhwi ())\n+\t    *max_size = max.to_uhwi ();\n+\t  else\n+\t    *max_size = (HOST_WIDE_INT)-1;\n+\t}\n+      else\n+\t{\n+\t  if (host_integerp (TYPE_MIN_VALUE (TREE_TYPE (len)), 1))\n+\t    *min_size = tree_low_cst (TYPE_MIN_VALUE (TREE_TYPE (len)), 1);\n+\t  else\n+\t    *min_size = 0;\n+\t  if (host_integerp (TYPE_MAX_VALUE (TREE_TYPE (len)), 1))\n+\t    *max_size = tree_low_cst (TYPE_MAX_VALUE (TREE_TYPE (len)), 1);\n+\t  else\n+\t    *max_size = GET_MODE_MASK (GET_MODE (len_rtx));\n+\t}\n+    }\n+  gcc_checking_assert (*max_size <=\n+\t\t       (unsigned HOST_WIDE_INT)\n+\t\t\t  GET_MODE_MASK (GET_MODE (len_rtx)));\n+}\n+\n /* Expand a call EXP to the memcpy builtin.\n    Return NULL_RTX if we failed, the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient (and in\n@@ -3117,6 +3162,8 @@ expand_builtin_memcpy (tree exp, rtx target)\n       rtx dest_mem, src_mem, dest_addr, len_rtx;\n       HOST_WIDE_INT expected_size = -1;\n       unsigned int expected_align = 0;\n+      unsigned HOST_WIDE_INT min_size;\n+      unsigned HOST_WIDE_INT max_size;\n \n       /* If DEST is not a pointer type, call the normal function.  */\n       if (dest_align == 0)\n@@ -3136,6 +3183,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n       dest_mem = get_memory_rtx (dest, len);\n       set_mem_align (dest_mem, dest_align);\n       len_rtx = expand_normal (len);\n+      determine_block_size (len, len_rtx, &min_size, &max_size);\n       src_str = c_getstr (src);\n \n       /* If SRC is a string constant and block move would be done\n@@ -3164,7 +3212,8 @@ expand_builtin_memcpy (tree exp, rtx target)\n       dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx,\n \t\t\t\t         CALL_EXPR_TAILCALL (exp)\n \t\t\t\t         ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n-\t\t\t\t\t expected_align, expected_size);\n+\t\t\t\t\t expected_align, expected_size,\n+\t\t\t\t\t min_size, max_size);\n \n       if (dest_addr == 0)\n \t{\n@@ -3578,6 +3627,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   rtx dest_mem, dest_addr, len_rtx;\n   HOST_WIDE_INT expected_size = -1;\n   unsigned int expected_align = 0;\n+  unsigned HOST_WIDE_INT min_size;\n+  unsigned HOST_WIDE_INT max_size;\n \n   dest_align = get_pointer_alignment (dest);\n \n@@ -3606,6 +3657,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   len = builtin_save_expr (len);\n \n   len_rtx = expand_normal (len);\n+  determine_block_size (len, len_rtx, &min_size, &max_size);\n   dest_mem = get_memory_rtx (dest, len);\n   val_mode = TYPE_MODE (unsigned_char_type_node);\n \n@@ -3632,7 +3684,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t}\n       else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx,\n \t\t\t\t\tdest_align, expected_align,\n-\t\t\t\t\texpected_size))\n+\t\t\t\t\texpected_size, min_size, max_size))\n \tgoto do_libcall;\n \n       dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -3654,7 +3706,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n       else if (!set_storage_via_setmem (dest_mem, len_rtx,\n \t\t\t\t\tgen_int_mode (c, val_mode),\n \t\t\t\t\tdest_align, expected_align,\n-\t\t\t\t\texpected_size))\n+\t\t\t\t\texpected_size, min_size, max_size))\n \tgoto do_libcall;\n \n       dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -3666,7 +3718,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   dest_addr = clear_storage_hints (dest_mem, len_rtx,\n \t\t\t\t   CALL_EXPR_TAILCALL (orig_exp)\n \t\t\t\t   ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n-\t\t\t\t   expected_align, expected_size);\n+\t\t\t\t   expected_align, expected_size,\n+\t\t\t\t   min_size, max_size);\n \n   if (dest_addr == 0)\n     {"}, {"sha": "85ed7a200346e35b8129d6fd782b392a6dec1fd3", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -58,9 +58,9 @@ extern enum machine_mode ix86_cc_mode (enum rtx_code, rtx, rtx);\n extern int avx_vpermilp_parallel (rtx par, enum machine_mode mode);\n extern int avx_vperm2f128_parallel (rtx par, enum machine_mode mode);\n \n-extern bool ix86_expand_movmem (rtx, rtx, rtx, rtx, rtx, rtx);\n-extern bool ix86_expand_setmem (rtx, rtx, rtx, rtx, rtx, rtx);\n extern bool ix86_expand_strlen (rtx, rtx, rtx, rtx);\n+extern bool ix86_expand_set_or_movmem (rtx, rtx, rtx, rtx, rtx, rtx,\n+\t\t\t\t       rtx, rtx, rtx, bool);\n \n extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);"}, {"sha": "565d8fa6ae653db9f70460ec83c6446d35cb94be", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -23611,10 +23611,11 @@ promote_duplicated_reg_to_size (rtx val, int size_needed, int desired_align,\n \n      3) Main body: the copying loop itself, copying in SIZE_NEEDED chunks\n \twith specified algorithm.  */\n-static bool\n+bool\n ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n-\t\t\t      rtx align_exp, rtx expected_align_exp,\n-\t\t\t      rtx expected_size_exp, bool issetmem)\n+\t\t\t   rtx align_exp, rtx expected_align_exp,\n+\t\t\t   rtx expected_size_exp, rtx min_size_exp,\n+\t\t\t   rtx max_size_exp, bool issetmem)\n {\n   rtx destreg;\n   rtx srcreg = NULL;\n@@ -23654,6 +23655,10 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \n   if (CONST_INT_P (count_exp))\n     min_size = max_size = count = expected_size = INTVAL (count_exp);\n+  if (min_size_exp)\n+    min_size = INTVAL (min_size_exp);\n+  if (max_size_exp)\n+    max_size = INTVAL (max_size_exp);\n   if (CONST_INT_P (expected_size_exp) && count == 0)\n     expected_size = INTVAL (expected_size_exp);\n \n@@ -24058,24 +24063,6 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   return true;\n }\n \n-/* Wrapper for ix86_expand_set_or_movmem for memcpy case.  */\n-bool\n-ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n-\t\t    rtx expected_align_exp, rtx expected_size_exp)\n-{\n-  return ix86_expand_set_or_movmem (dst, src, count_exp, NULL, align_exp,\n-\t\t    expected_align_exp, expected_size_exp, false);\n-}\n-\n-/* Wrapper for ix86_expand_set_or_movmem for memset case.  */\n-bool\n-ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n-\t\t    rtx expected_align_exp, rtx expected_size_exp)\n-{\n-  return ix86_expand_set_or_movmem (dst, NULL, count_exp, val_exp, align_exp,\n-\t\t      expected_align_exp, expected_size_exp, true);\n-}\n-\n \n /* Expand the appropriate insns for doing strlen if not just doing\n    repnz; scasb"}, {"sha": "223a467510809f69bb587c604a0832855fb8806f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -15503,11 +15503,15 @@\n    (use (match_operand:SWI48 2 \"nonmemory_operand\"))\n    (use (match_operand:SWI48 3 \"const_int_operand\"))\n    (use (match_operand:SI 4 \"const_int_operand\"))\n-   (use (match_operand:SI 5 \"const_int_operand\"))]\n+   (use (match_operand:SI 5 \"const_int_operand\"))\n+   (use (match_operand:SI 6 \"\"))\n+   (use (match_operand:SI 7 \"\"))]\n   \"\"\n {\n- if (ix86_expand_movmem (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t operands[4], operands[5]))\n+ if (ix86_expand_set_or_movmem (operands[0], operands[1],\n+\t\t\t        operands[2], NULL, operands[3],\n+\t\t\t        operands[4], operands[5],\n+\t\t\t\toperands[6], operands[7], false))\n    DONE;\n  else\n    FAIL;\n@@ -15695,12 +15699,16 @@\n     (use (match_operand:QI 2 \"nonmemory_operand\"))\n     (use (match_operand 3 \"const_int_operand\"))\n     (use (match_operand:SI 4 \"const_int_operand\"))\n-    (use (match_operand:SI 5 \"const_int_operand\"))]\n+    (use (match_operand:SI 5 \"const_int_operand\"))\n+    (use (match_operand:SI 6 \"\"))\n+    (use (match_operand:SI 7 \"\"))]\n   \"\"\n {\n- if (ix86_expand_setmem (operands[0], operands[1],\n-\t\t\t operands[2], operands[3],\n-\t\t\t operands[4], operands[5]))\n+ if (ix86_expand_set_or_movmem (operands[0], NULL,\n+\t\t\t        operands[1], operands[2],\n+\t\t\t\toperands[3], operands[4],\n+\t\t\t        operands[5], operands[6],\n+\t\t\t\toperands[6], true))\n    DONE;\n  else\n    FAIL;"}, {"sha": "2054295f66be09c439c85699c869d7023dd6c728", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -5328,6 +5328,9 @@ destination and source strings are operands 1 and 2, and both are\n the expansion of this pattern should store in operand 0 the address in\n which the @code{NUL} terminator was stored in the destination string.\n \n+This patern has also several optional operands that are same as in\n+@code{setmem}.\n+\n @cindex @code{setmem@var{m}} instruction pattern\n @item @samp{setmem@var{m}}\n Block set instruction.  The destination string is the first operand,\n@@ -5347,6 +5350,8 @@ respectively.  The expected alignment differs from alignment in operand 4\n in a way that the blocks are not required to be aligned according to it in\n all cases. This expected alignment is also in bytes, just like operand 4.\n Expected size, when unknown, is set to @code{(const_int -1)}.\n+Operand 7 is the minimal size of the block and operand 8 is the\n+maximal size of the block (NULL if it can not be represented as CONST_INT).\n \n The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.\n "}, {"sha": "23854ccf5c780a74565420750cd203f8089035d1", "filename": "gcc/expr.c", "status": "modified", "additions": 76, "deletions": 15, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -128,7 +128,8 @@ struct store_by_pieces_d\n static void move_by_pieces_1 (insn_gen_fn, machine_mode,\n \t\t\t      struct move_by_pieces_d *);\n static bool block_move_libcall_safe_for_call_parm (void);\n-static bool emit_block_move_via_movmem (rtx, rtx, rtx, unsigned, unsigned, HOST_WIDE_INT);\n+static bool emit_block_move_via_movmem (rtx, rtx, rtx, unsigned, unsigned, HOST_WIDE_INT,\n+\t\t\t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT);\n static tree emit_block_move_libcall_fn (int);\n static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);\n static rtx clear_by_pieces_1 (void *, HOST_WIDE_INT, enum machine_mode);\n@@ -1119,13 +1120,18 @@ move_by_pieces_1 (insn_gen_fn genfun, machine_mode mode,\n    SIZE is an rtx that says how long they are.\n    ALIGN is the maximum alignment we can assume they have.\n    METHOD describes what kind of copy this is, and what mechanisms may be used.\n+   MIN_SIZE is the minimal size of block to move\n+   MAX_SIZE is the maximal size of block to move, if it can not be represented\n+   in unsigned HOST_WIDE_INT, than it is mask of all ones.\n \n    Return the address of the new block, if memcpy is called and returns it,\n    0 otherwise.  */\n \n rtx\n emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n-\t\t       unsigned int expected_align, HOST_WIDE_INT expected_size)\n+\t\t       unsigned int expected_align, HOST_WIDE_INT expected_size,\n+\t\t       unsigned HOST_WIDE_INT min_size,\n+\t\t       unsigned HOST_WIDE_INT max_size)\n {\n   bool may_use_call;\n   rtx retval = 0;\n@@ -1181,7 +1187,8 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n   if (CONST_INT_P (size) && MOVE_BY_PIECES_P (INTVAL (size), align))\n     move_by_pieces (x, y, INTVAL (size), align, 0);\n   else if (emit_block_move_via_movmem (x, y, size, align,\n-\t\t\t\t       expected_align, expected_size))\n+\t\t\t\t       expected_align, expected_size,\n+\t\t\t\t       min_size, max_size))\n     ;\n   else if (may_use_call\n \t   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x))\n@@ -1211,7 +1218,13 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n rtx\n emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n {\n-  return emit_block_move_hints (x, y, size, method, 0, -1);\n+  unsigned HOST_WIDE_INT max, min = 0;\n+  if (GET_CODE (size) == CONST_INT)\n+    min = max = UINTVAL (size);\n+  else\n+    max = GET_MODE_MASK (GET_MODE (size));\n+  return emit_block_move_hints (x, y, size, method, 0, -1,\n+\t\t\t\tmin, max);\n }\n \n /* A subroutine of emit_block_move.  Returns true if calling the\n@@ -1274,13 +1287,22 @@ block_move_libcall_safe_for_call_parm (void)\n \n static bool\n emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n-\t\t\t    unsigned int expected_align, HOST_WIDE_INT expected_size)\n+\t\t\t    unsigned int expected_align, HOST_WIDE_INT expected_size,\n+\t\t\t    unsigned HOST_WIDE_INT min_size,\n+\t\t\t    unsigned HOST_WIDE_INT max_size)\n {\n   int save_volatile_ok = volatile_ok;\n   enum machine_mode mode;\n \n   if (expected_align < align)\n     expected_align = align;\n+  if (expected_size != -1)\n+    {\n+      if ((unsigned HOST_WIDE_INT)expected_size > max_size)\n+\texpected_size = max_size;\n+      if ((unsigned HOST_WIDE_INT)expected_size < min_size)\n+\texpected_size = min_size;\n+    }\n \n   /* Since this is a move insn, we don't care about volatility.  */\n   volatile_ok = 1;\n@@ -1303,28 +1325,39 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t  && ((CONST_INT_P (size)\n \t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t   <= (GET_MODE_MASK (mode) >> 1)))\n+\t      || max_size <= (GET_MODE_MASK (mode) >> 1)\n \t      || GET_MODE_BITSIZE (mode) >= GET_MODE_BITSIZE (Pmode)))\n \t{\n-\t  struct expand_operand ops[6];\n+\t  struct expand_operand ops[8];\n \t  unsigned int nops;\n \n \t  /* ??? When called via emit_block_move_for_call, it'd be\n \t     nice if there were some way to inform the backend, so\n \t     that it doesn't fail the expansion because it thinks\n \t     emitting the libcall would be more efficient.  */\n \t  nops = insn_data[(int) code].n_generator_args;\n-\t  gcc_assert (nops == 4 || nops == 6);\n+\t  gcc_assert (nops == 4 || nops == 6 || nops == 8);\n \n \t  create_fixed_operand (&ops[0], x);\n \t  create_fixed_operand (&ops[1], y);\n \t  /* The check above guarantees that this size conversion is valid.  */\n \t  create_convert_operand_to (&ops[2], size, mode, true);\n \t  create_integer_operand (&ops[3], align / BITS_PER_UNIT);\n-\t  if (nops == 6)\n+\t  if (nops >= 6)\n \t    {\n \t      create_integer_operand (&ops[4], expected_align / BITS_PER_UNIT);\n \t      create_integer_operand (&ops[5], expected_size);\n \t    }\n+\t  if (nops == 8)\n+\t    {\n+\t      create_integer_operand (&ops[6], min_size);\n+\t      /* If we can not represent the maximal size,\n+\t\t make parameter NULL.  */\n+\t      if ((HOST_WIDE_INT) max_size != -1)\n+\t        create_integer_operand (&ops[7], max_size);\n+\t      else\n+\t\tcreate_fixed_operand (&ops[7], NULL);\n+\t    }\n \t  if (maybe_expand_insn (code, nops, ops))\n \t    {\n \t      volatile_ok = save_volatile_ok;\n@@ -2712,7 +2745,9 @@ store_by_pieces_2 (insn_gen_fn genfun, machine_mode mode,\n \n rtx\n clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n-\t\t     unsigned int expected_align, HOST_WIDE_INT expected_size)\n+\t\t     unsigned int expected_align, HOST_WIDE_INT expected_size,\n+\t\t     unsigned HOST_WIDE_INT min_size,\n+\t\t     unsigned HOST_WIDE_INT max_size)\n {\n   enum machine_mode mode = GET_MODE (object);\n   unsigned int align;\n@@ -2753,7 +2788,8 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n       && CLEAR_BY_PIECES_P (INTVAL (size), align))\n     clear_by_pieces (object, INTVAL (size), align);\n   else if (set_storage_via_setmem (object, size, const0_rtx, align,\n-\t\t\t\t   expected_align, expected_size))\n+\t\t\t\t   expected_align, expected_size,\n+\t\t\t\t   min_size, max_size))\n     ;\n   else if (ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (object)))\n     return set_storage_via_libcall (object, size, const0_rtx,\n@@ -2767,7 +2803,12 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n rtx\n clear_storage (rtx object, rtx size, enum block_op_methods method)\n {\n-  return clear_storage_hints (object, size, method, 0, -1);\n+  unsigned HOST_WIDE_INT max, min = 0;\n+  if (GET_CODE (size) == CONST_INT)\n+    min = max = UINTVAL (size);\n+  else\n+    max = GET_MODE_MASK (GET_MODE (size));\n+  return clear_storage_hints (object, size, method, 0, -1, min, max);\n }\n \n \n@@ -2864,7 +2905,9 @@ clear_storage_libcall_fn (int for_call)\n \n bool\n set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n-\t\t\tunsigned int expected_align, HOST_WIDE_INT expected_size)\n+\t\t\tunsigned int expected_align, HOST_WIDE_INT expected_size,\n+\t\t\tunsigned HOST_WIDE_INT min_size,\n+\t\t\tunsigned HOST_WIDE_INT max_size)\n {\n   /* Try the most limited insn first, because there's no point\n      including more than one in the machine description unless\n@@ -2874,6 +2917,13 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \n   if (expected_align < align)\n     expected_align = align;\n+  if (expected_size != -1)\n+    {\n+      if ((unsigned HOST_WIDE_INT)expected_size > max_size)\n+\texpected_size = max_size;\n+      if ((unsigned HOST_WIDE_INT)expected_size < min_size)\n+\texpected_size = min_size;\n+    }\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n@@ -2889,24 +2939,35 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t  && ((CONST_INT_P (size)\n \t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t   <= (GET_MODE_MASK (mode) >> 1)))\n+\t      || max_size <= (GET_MODE_MASK (mode) >> 1)\n \t      || GET_MODE_BITSIZE (mode) >= GET_MODE_BITSIZE (Pmode)))\n \t{\n-\t  struct expand_operand ops[6];\n+\t  struct expand_operand ops[8];\n \t  unsigned int nops;\n \n \t  nops = insn_data[(int) code].n_generator_args;\n-\t  gcc_assert (nops == 4 || nops == 6);\n+\t  gcc_assert (nops == 4 || nops == 6 || nops == 8);\n \n \t  create_fixed_operand (&ops[0], object);\n \t  /* The check above guarantees that this size conversion is valid.  */\n \t  create_convert_operand_to (&ops[1], size, mode, true);\n \t  create_convert_operand_from (&ops[2], val, byte_mode, true);\n \t  create_integer_operand (&ops[3], align / BITS_PER_UNIT);\n-\t  if (nops == 6)\n+\t  if (nops >= 6)\n \t    {\n \t      create_integer_operand (&ops[4], expected_align / BITS_PER_UNIT);\n \t      create_integer_operand (&ops[5], expected_size);\n \t    }\n+\t  if (nops == 8)\n+\t    {\n+\t      create_integer_operand (&ops[6], min_size);\n+\t      /* If we can not represent the maximal size,\n+\t\t make parameter NULL.  */\n+\t      if ((HOST_WIDE_INT) max_size != -1)\n+\t        create_integer_operand (&ops[7], max_size);\n+\t      else\n+\t\tcreate_fixed_operand (&ops[7], NULL);\n+\t    }\n \t  if (maybe_expand_insn (code, nops, ops))\n \t    return true;\n \t}"}, {"sha": "ae7609158958494b2da0b514efb3235c1977edee", "filename": "gcc/expr.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -300,7 +300,9 @@ extern void init_block_clear_fn (const char *);\n extern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);\n extern rtx emit_block_move_via_libcall (rtx, rtx, rtx, bool);\n extern rtx emit_block_move_hints (rtx, rtx, rtx, enum block_op_methods,\n-\t\t\t          unsigned int, HOST_WIDE_INT);\n+\t\t\t          unsigned int, HOST_WIDE_INT,\n+\t\t\t\t  unsigned HOST_WIDE_INT,\n+\t\t\t\t  unsigned HOST_WIDE_INT);\n extern bool emit_storent_insn (rtx to, rtx from);\n \n /* Copy all or part of a value X into registers starting at REGNO.\n@@ -361,13 +363,17 @@ extern void use_group_regs (rtx *, rtx);\n    If OBJECT has BLKmode, SIZE is its length in bytes.  */\n extern rtx clear_storage (rtx, rtx, enum block_op_methods);\n extern rtx clear_storage_hints (rtx, rtx, enum block_op_methods,\n-\t\t\t        unsigned int, HOST_WIDE_INT);\n+\t\t\t        unsigned int, HOST_WIDE_INT,\n+\t\t\t\tunsigned HOST_WIDE_INT,\n+\t\t\t\tunsigned HOST_WIDE_INT);\n /* The same, but always output an library call.  */\n rtx set_storage_via_libcall (rtx, rtx, rtx, bool);\n \n /* Expand a setmem pattern; return true if successful.  */\n extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int,\n-\t\t\t\t    unsigned int, HOST_WIDE_INT);\n+\t\t\t\t    unsigned int, HOST_WIDE_INT,\n+\t\t\t\t    unsigned HOST_WIDE_INT,\n+\t\t\t\t    unsigned HOST_WIDE_INT);\n \n extern unsigned HOST_WIDE_INT move_by_pieces_ninsns (unsigned HOST_WIDE_INT,\n \t\t\t\t\t\t     unsigned int,"}, {"sha": "4aac17c346e669c578b290f1ef24a159e2e27b5b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -1,3 +1,7 @@\n+2013-11-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.target/i386/memcpy-2.c: New testcase.\n+\n 2013-11-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/59153"}, {"sha": "fe53f2653a0b148236f5d9c90d70f264c7f70487", "filename": "gcc/testsuite/gcc.target/i386/memcpy-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3918b10802ce96c0c8cf477a0695856dc8d0919a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-2.c?ref=3918b10802ce96c0c8cf477a0695856dc8d0919a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* Memcpy should be inlined because block size is known.  */\n+/* { dg-final { scan-assembler-not \"memcpy\" } } */\n+void *a;\n+void *b;\n+t(unsigned int c)\n+{\n+  if (c<10)\n+    memcpy (a,b,c);\n+}"}]}