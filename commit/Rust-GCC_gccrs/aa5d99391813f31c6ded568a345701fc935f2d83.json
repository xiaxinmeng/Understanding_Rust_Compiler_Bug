{"sha": "aa5d99391813f31c6ded568a345701fc935f2d83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE1ZDk5MzkxODEzZjMxYzZkZWQ1NjhhMzQ1NzAxZmM5MzVmMmQ4Mw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2008-06-18T20:32:04Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2008-06-18T20:32:04Z"}, "message": "spu.c (reg_align): Remove.\n\n\t* config/spu/spu.c (reg_align): Remove.\n\t(regno_aligned_for_load): Also accept ARG_POINTER_REGNUM.\n\t(spu_split_load): Use regno_aligned_for_load instead of reg_align.\n\t(spu_split_store): Likewise.\n\nFrom-SVN: r136910", "tree": {"sha": "b4c5a1e0ccaef8288455e2da739c6ea10e9e251d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4c5a1e0ccaef8288455e2da739c6ea10e9e251d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa5d99391813f31c6ded568a345701fc935f2d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa5d99391813f31c6ded568a345701fc935f2d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa5d99391813f31c6ded568a345701fc935f2d83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa5d99391813f31c6ded568a345701fc935f2d83/comments", "author": null, "committer": null, "parents": [{"sha": "3d97d3ec1c9333140d996f703df1b6f98bfeb6e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d97d3ec1c9333140d996f703df1b6f98bfeb6e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d97d3ec1c9333140d996f703df1b6f98bfeb6e9"}], "stats": {"total": 31, "additions": 13, "deletions": 18}, "files": [{"sha": "60d2007391870a4be892f21e3c440595f28f4249", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa5d99391813f31c6ded568a345701fc935f2d83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa5d99391813f31c6ded568a345701fc935f2d83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa5d99391813f31c6ded568a345701fc935f2d83", "patch": "@@ -1,3 +1,10 @@\n+2008-06-18  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/spu/spu.c (reg_align): Remove.\n+\t(regno_aligned_for_load): Also accept ARG_POINTER_REGNUM.\n+\t(spu_split_load): Use regno_aligned_for_load instead of reg_align.\n+\t(spu_split_store): Likewise.\n+\n 2006-06-18  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \t* gcc/tree-vn.c: Fix typo in comment."}, {"sha": "4347d59d810f8f680e2714b0c3abcd2d814e9499", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa5d99391813f31c6ded568a345701fc935f2d83/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa5d99391813f31c6ded568a345701fc935f2d83/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=aa5d99391813f31c6ded568a345701fc935f2d83", "patch": "@@ -122,7 +122,6 @@ static tree spu_gimplify_va_arg_expr (tree valist, tree type, tree * pre_p,\n \t\t\t\t      tree * post_p);\n static int regno_aligned_for_load (int regno);\n static int store_with_one_insn_p (rtx mem);\n-static int reg_align (rtx reg);\n static int mem_is_padded_component_ref (rtx x);\n static bool spu_assemble_integer (rtx x, unsigned int size, int aligned_p);\n static void spu_asm_globalize_label (FILE * file, const char *name);\n@@ -3382,6 +3381,7 @@ regno_aligned_for_load (int regno)\n {\n   return regno == FRAME_POINTER_REGNUM\n     || (frame_pointer_needed && regno == HARD_FRAME_POINTER_REGNUM)\n+    || regno == ARG_POINTER_REGNUM\n     || regno == STACK_POINTER_REGNUM\n     || (regno >= FIRST_VIRTUAL_REGISTER \n \t&& regno <= LAST_VIRTUAL_REGISTER);\n@@ -3558,18 +3558,6 @@ spu_expand_mov (rtx * ops, enum machine_mode mode)\n   return 0;\n }\n \n-static int\n-reg_align (rtx reg)\n-{\n-  /* For now, only frame registers are known to be aligned at all times.\n-     We can't trust REGNO_POINTER_ALIGN because optimization will move\n-     registers around, potentially changing an \"aligned\" register in an\n-     address to an unaligned register, which would result in an invalid\n-     address. */\n-  int regno = REGNO (reg);\n-  return REGNO_PTR_FRAME_P (regno) ? REGNO_POINTER_ALIGN (regno) : 1;\n-}\n-\n void\n spu_split_load (rtx * ops)\n {\n@@ -3595,9 +3583,9 @@ spu_split_load (rtx * ops)\n        */\n       p0 = XEXP (addr, 0);\n       p1 = XEXP (addr, 1);\n-      if (reg_align (p0) < 128)\n+      if (REG_P (p0) && !regno_aligned_for_load (REGNO (p0)))\n \t{\n-\t  if (GET_CODE (p1) == REG && reg_align (p1) < 128)\n+\t  if (REG_P (p1) && !regno_aligned_for_load (REGNO (p1)))\n \t    {\n \t      emit_insn (gen_addsi3 (ops[3], p0, p1));\n \t      rot = ops[3];\n@@ -3613,13 +3601,13 @@ spu_split_load (rtx * ops)\n \t      p1 = GEN_INT (INTVAL (p1) & -16);\n \t      addr = gen_rtx_PLUS (SImode, p0, p1);\n \t    }\n-\t  else if (GET_CODE (p1) == REG && reg_align (p1) < 128)\n+\t  else if (REG_P (p1) && !regno_aligned_for_load (REGNO (p1)))\n \t    rot = p1;\n \t}\n     }\n   else if (GET_CODE (addr) == REG)\n     {\n-      if (reg_align (addr) < 128)\n+      if (!regno_aligned_for_load (REGNO (addr)))\n \trot = addr;\n     }\n   else if (GET_CODE (addr) == CONST)\n@@ -3764,7 +3752,7 @@ spu_split_store (rtx * ops)\n       set_mem_alias_set (lmem, 0);\n       emit_insn (gen_movti (reg, lmem));\n \n-      if (!p0 || reg_align (p0) >= 128)\n+      if (!p0 || regno_aligned_for_load (REGNO (p0)))\n \tp0 = stack_pointer_rtx;\n       if (!p1_lo)\n \tp1_lo = const0_rtx;"}]}