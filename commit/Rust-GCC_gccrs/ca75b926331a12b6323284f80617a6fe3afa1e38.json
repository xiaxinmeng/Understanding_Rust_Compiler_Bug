{"sha": "ca75b926331a12b6323284f80617a6fe3afa1e38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E3NWI5MjYzMzFhMTJiNjMyMzI4NGY4MDYxN2E2ZmUzYWZhMWUzOA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2009-09-20T15:39:22Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2009-09-20T15:39:22Z"}, "message": "re PR middle-end/30789 (complex folding inexact)\n\n\tPR middle-end/30789\n\t* builtins.c (do_mpc_arg2): Accept DO_NONFINITE parameter.\n\t(do_mpc_ckconv): Accept FORCE_CONVERT parameter.\n\t(fold_builtin_2, do_mpc_arg1): Update accordingly.\n\t* fold-const.c (const_binop): Likewise.\n\t* real.h (do_mpc_arg2): Update prototype.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-math-7.c: Update for testing Annex G\n\tcases in static initializers.\n\nFrom-SVN: r151904", "tree": {"sha": "659746d75cac0bc57cdf3050c02e53c1fd81275e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/659746d75cac0bc57cdf3050c02e53c1fd81275e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca75b926331a12b6323284f80617a6fe3afa1e38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca75b926331a12b6323284f80617a6fe3afa1e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca75b926331a12b6323284f80617a6fe3afa1e38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca75b926331a12b6323284f80617a6fe3afa1e38/comments", "author": null, "committer": null, "parents": [{"sha": "c4a80a2df36df59ceedcd1236dea299cba12349f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4a80a2df36df59ceedcd1236dea299cba12349f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4a80a2df36df59ceedcd1236dea299cba12349f"}], "stats": {"total": 97, "additions": 73, "deletions": 24}, "files": [{"sha": "af2d02cb580e502c41d2b4060038680827aa992b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca75b926331a12b6323284f80617a6fe3afa1e38", "patch": "@@ -1,3 +1,12 @@\n+2009-09-20  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR middle-end/30789\n+\t* builtins.c (do_mpc_arg2): Accept DO_NONFINITE parameter.\n+\t(do_mpc_ckconv): Accept FORCE_CONVERT parameter.\n+\t(fold_builtin_2, do_mpc_arg1): Update accordingly.\n+\t* fold-const.c (const_binop): Likewise.\n+\t* real.h (do_mpc_arg2): Update prototype.\n+\n 2009-09-20  Jan Hubicka  <jh@suse.cz>\n \n \t* dwarf2out.c (add_const_value_attribute): Return true if successful."}, {"sha": "fddb36c7a4d0a0cb080342fbdf60a53ea5d399c5", "filename": "gcc/builtins.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ca75b926331a12b6323284f80617a6fe3afa1e38", "patch": "@@ -10741,7 +10741,7 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE\n \t  && validate_arg (arg1, COMPLEX_TYPE)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg1))) == REAL_TYPE) \n-\treturn do_mpc_arg2 (arg0, arg1, type, mpc_pow);\n+\treturn do_mpc_arg2 (arg0, arg1, type, /*do_nonfinite=*/ 0, mpc_pow);\n     break;\n #endif\n \n@@ -13347,17 +13347,19 @@ do_mpfr_ckconv (mpfr_srcptr m, tree type, int inexact)\n    was not exactly calculated.  TYPE is the tree type for the result.\n    This function assumes that you cleared the MPFR flags and then\n    calculated M to see if anything subsequently set a flag prior to\n-   entering this function.  Return NULL_TREE if any checks fail.  */\n+   entering this function.  Return NULL_TREE if any checks fail, if\n+   FORCE_CONVERT is true, then bypass the checks.  */\n \n static tree\n-do_mpc_ckconv (mpc_srcptr m, tree type, int inexact)\n+do_mpc_ckconv (mpc_srcptr m, tree type, int inexact, int force_convert)\n {\n   /* Proceed iff we get a normal number, i.e. not NaN or Inf and no\n      overflow/underflow occurred.  If -frounding-math, proceed iff the\n      result of calling FUNC was exact.  */\n-  if (mpfr_number_p (mpc_realref (m)) && mpfr_number_p (mpc_imagref (m))\n-      && !mpfr_overflow_p () && !mpfr_underflow_p ()\n-      && (!flag_rounding_math || !inexact))\n+  if (force_convert\n+      || (mpfr_number_p (mpc_realref (m)) && mpfr_number_p (mpc_imagref (m))\n+\t  && !mpfr_overflow_p () && !mpfr_underflow_p ()\n+\t  && (!flag_rounding_math || !inexact)))\n     {\n       REAL_VALUE_TYPE re, im;\n \n@@ -13367,16 +13369,19 @@ do_mpc_ckconv (mpc_srcptr m, tree type, int inexact)\n \t check for overflow/underflow.  If the REAL_VALUE_TYPE is zero\n \t but the mpft_t is not, then we underflowed in the\n \t conversion.  */\n-      if (real_isfinite (&re) && real_isfinite (&im)\n-\t  && (re.cl == rvc_zero) == (mpfr_zero_p (mpc_realref (m)) != 0)\n-\t  && (im.cl == rvc_zero) == (mpfr_zero_p (mpc_imagref (m)) != 0))\n+      if (force_convert\n+\t  || (real_isfinite (&re) && real_isfinite (&im)\n+\t      && (re.cl == rvc_zero) == (mpfr_zero_p (mpc_realref (m)) != 0)\n+\t      && (im.cl == rvc_zero) == (mpfr_zero_p (mpc_imagref (m)) != 0)))\n         {\n \t  REAL_VALUE_TYPE re_mode, im_mode;\n \n \t  real_convert (&re_mode, TYPE_MODE (TREE_TYPE (type)), &re);\n \t  real_convert (&im_mode, TYPE_MODE (TREE_TYPE (type)), &im);\n \t  /* Proceed iff the specified mode can hold the value.  */\n-\t  if (real_identical (&re_mode, &re) && real_identical (&im_mode, &im))\n+\t  if (force_convert\n+\t      || (real_identical (&re_mode, &re)\n+\t\t  && real_identical (&im_mode, &im)))\n \t    return build_complex (type, build_real (TREE_TYPE (type), re_mode),\n \t\t\t\t  build_real (TREE_TYPE (type), im_mode));\n \t}\n@@ -13819,7 +13824,7 @@ do_mpc_arg1 (tree arg, tree type, int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n \t  mpfr_from_real (mpc_imagref(m), im, rnd);\n \t  mpfr_clear_flags ();\n \t  inexact = func (m, m, crnd);\n-\t  result = do_mpc_ckconv (m, type, inexact);\n+\t  result = do_mpc_ckconv (m, type, inexact, /*force_convert=*/ 0);\n \t  mpc_clear (m);\n \t}\n     }\n@@ -13831,11 +13836,13 @@ do_mpc_arg1 (tree arg, tree type, int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n    mpc function FUNC on it and return the resulting value as a tree\n    with type TYPE.  The mpfr precision is set to the precision of\n    TYPE.  We assume that function FUNC returns zero if the result\n-   could be calculated exactly within the requested precision.  */\n+   could be calculated exactly within the requested precision.  If\n+   DO_NONFINITE is true, then fold expressions containing Inf or NaN\n+   in the arguments and/or results.  */\n \n #ifdef HAVE_mpc\n tree\n-do_mpc_arg2 (tree arg0, tree arg1, tree type,\n+do_mpc_arg2 (tree arg0, tree arg1, tree type, int do_nonfinite,\n \t     int (*func)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t))\n {\n   tree result = NULL_TREE;\n@@ -13856,8 +13863,9 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type,\n       const REAL_VALUE_TYPE *const re1 = TREE_REAL_CST_PTR (TREE_REALPART (arg1));\n       const REAL_VALUE_TYPE *const im1 = TREE_REAL_CST_PTR (TREE_IMAGPART (arg1));\n \n-      if (real_isfinite (re0) && real_isfinite (im0)\n-\t  && real_isfinite (re1) && real_isfinite (im1))\n+      if (do_nonfinite\n+\t  || (real_isfinite (re0) && real_isfinite (im0)\n+\t      && real_isfinite (re1) && real_isfinite (im1)))\n         {\n \t  const struct real_format *const fmt =\n \t    REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (type)));\n@@ -13875,7 +13883,7 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type,\n \t  mpfr_from_real (mpc_imagref(m1), im1, rnd);\n \t  mpfr_clear_flags ();\n \t  inexact = func (m0, m0, m1, crnd);\n-\t  result = do_mpc_ckconv (m0, type, inexact);\n+\t  result = do_mpc_ckconv (m0, type, inexact, do_nonfinite);\n \t  mpc_clear (m0);\n \t  mpc_clear (m1);\n \t}"}, {"sha": "34e47c19e79c8df6b2b0dc61101d2b980b9a66c1", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ca75b926331a12b6323284f80617a6fe3afa1e38", "patch": "@@ -1974,7 +1974,9 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \tcase MULT_EXPR:\n #ifdef HAVE_mpc\n \t  if (COMPLEX_FLOAT_TYPE_P (type))\n-\t    return do_mpc_arg2 (arg1, arg2, type, mpc_mul);\n+\t    return do_mpc_arg2 (arg1, arg2, type,\n+\t\t\t\t/* do_nonfinite= */ folding_initializer,\n+\t\t\t\tmpc_mul);\n #endif\n \n \t  real = const_binop (MINUS_EXPR,\n@@ -1990,7 +1992,9 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \tcase RDIV_EXPR:\n #ifdef HAVE_mpc\n \t  if (COMPLEX_FLOAT_TYPE_P (type))\n-\t    return do_mpc_arg2 (arg1, arg2, type, mpc_div);\n+\t    return do_mpc_arg2 (arg1, arg2, type,\n+                                /* do_nonfinite= */ folding_initializer,\n+\t\t\t\tmpc_div);\n #endif\n \n \t  {"}, {"sha": "e72723e01ea313e93c93b7395ba71ede90d80b00", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=ca75b926331a12b6323284f80617a6fe3afa1e38", "patch": "@@ -27,7 +27,7 @@\n #ifdef HAVE_mpc\n #include <mpc.h>\n # ifdef HAVE_mpc\n-extern tree do_mpc_arg2 (tree, tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t));\n+extern tree do_mpc_arg2 (tree, tree, tree, int, int (*)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t));\n # endif\n # if MPC_VERSION >= MPC_VERSION_NUM(0,6,1)\n #  define HAVE_mpc_pow"}, {"sha": "127d213d7997844445588f937bab10dab358c9cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca75b926331a12b6323284f80617a6fe3afa1e38", "patch": "@@ -1,3 +1,8 @@\n+2009-09-20  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-7.c: Update for testing Annex G\n+\tcases in static initializers.\n+\n 2009-09-20  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* gcc.c-tortue/compile/pr39886.c: New."}, {"sha": "0d6307d653b552263e394560fe6e6c74d549884c", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-7.c", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca75b926331a12b6323284f80617a6fe3afa1e38/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-7.c?ref=ca75b926331a12b6323284f80617a6fe3afa1e38", "patch": "@@ -5,7 +5,7 @@\n    Origin: Kaveh R. Ghazi,  August 13, 2009.  */\n \n /* { dg-do run } */\n-/* { dg-require-effective-target mpc } */\n+/* { dg-require-effective-target mpc_pow } */\n /* { dg-add-options ieee } */\n \n extern void link_error(int);\n@@ -16,23 +16,43 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n } while (0)\n \n+/* Use this error function for cases which only evaluate at\n+   compile-time when optimizing.  */\n+#ifdef __OPTIMIZE__\n+# define ERROR_FUNC(X) link_error(X)\n+#else\n+# define ERROR_FUNC(X) __builtin_abort()\n+#endif\n+\n+/* Evaluate this expression at compile-time using static initializers.  */\n+#define STATICINIT_TESTIT(TYPE,X,OP,Y,RES) do { \\\n+  static const _Complex TYPE foo = (_Complex TYPE)(X) OP (_Complex TYPE)(Y); \\\n+  if (foo != (_Complex TYPE)(RES)) \\\n+    ERROR_FUNC (__LINE__); \\\n+} while (0)\n+\n /* Evaluate this expression at runtime.  */\n #define RUNTIME_TESTIT(TYPE,X,OP,Y,RES) do { \\\n-  volatile _Complex TYPE foo = (_Complex TYPE)(X); \\\n+  volatile _Complex TYPE foo; \\\n+  foo = (_Complex TYPE)(X); \\\n   foo OP##= (_Complex TYPE)(Y); \\\n-  if (foo != (_Complex TYPE)(RES)) __builtin_abort(); \\\n+  if (foo != (_Complex TYPE)(RES)) \\\n+    __builtin_abort(); \\\n } while (0)\n \n /* Evaluate this expression at compile-time and runtime.  */\n #define TESTIT(TYPE,X,OP,Y,RES) do { \\\n+  STATICINIT_TESTIT(TYPE,X,OP,Y,RES); \\\n   COMPILETIME_TESTIT(TYPE,X,OP,Y,RES); \\\n   RUNTIME_TESTIT(TYPE,X,OP,Y,RES); \\\n } while (0)\n \n /* Either the real or imaginary parts should be infinity.  */\n #define TEST_ONE_PART_INF(VAL) do { \\\n-  if (! __builtin_isinf(__real (VAL)) \\\n-      && ! __builtin_isinf(__imag (VAL))) \\\n+  static const _Complex double foo = (VAL); \\\n+  if (! __builtin_isinf(__real foo) && ! __builtin_isinf(__imag foo)) \\\n+    ERROR_FUNC (__LINE__); \\\n+  if (! __builtin_isinf(__real (VAL)) && ! __builtin_isinf(__imag (VAL))) \\\n     __builtin_abort(); \\\n } while (0)\n \n@@ -71,5 +91,8 @@ int main()\n   TEST_ONE_PART_INF ((_Complex double)1 / (_Complex double)0);\n   TEST_ONE_PART_INF ((VAL1) / (_Complex double)1);\n \n+  RUNTIME_TESTIT (double, 1, /, VAL1, 0);\n+  STATICINIT_TESTIT (double, 1, /, VAL1, 0);\n+\n   return 0;\n }"}]}