{"sha": "051c57dafd8c31f1f098c9c8439dfa3c26e92c2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxYzU3ZGFmZDhjMzFmMWYwOThjOWM4NDM5ZGZhM2MyNmU5MmMyYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-31T20:01:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-31T20:01:57Z"}, "message": "Makefile.in (c-decl.o): Depend on rtl.h and expr.h.\n\n\t* Makefile.in (c-decl.o): Depend on rtl.h and expr.h.\n\t* alias.c (struct alias_entry): alias_set is HOST_WIDE_INT.\n\t(REG_BASE_VALUE): Remove unneeded cast to unsigned.\n\t(get_alias_set_entry): ALIAS_SET arg is HOST_WIDE_INT.\n\t(find_base_decl): New function, from c_find_base_decl in c-common.c.\n\t(new_alias_set): Moved from tree.c; return is HOST_WIDE_INT.\n\t(get_alias_set): Likewise.\n\tMajor rework to do more things and allow language-specific code\n\tto just handle special-cases.\n\t(record_alias_subset): Args are HOST_WIDE_INT.\n\t(record_component_alias): Local vars are HOST_WIDE_INT.\n\tDon't handle COMPLEX_EXPR.\n\t(get_varargs_alias_set): Moved from builtins.c.\n\t(get_frame_alias_set): New function.\n\t* builtins.c (expand_builtin_return_address): Use frame alias set.\n\t(expand_builtin_setjmp, expand_builtin_longjmp): Use alias set\n\tfor setjmp buffer.\n\t(get_memory_rtx): Rework to use set_mem_attributes.\n\t(get_varargs_alias_set): Deleted from here.\n\t* c-common.c (c_apply_type_quals_to_decl): Alias sets now HOST_WIDE_INT.\n\t(c_find_base_decl): Deleted from here.\n\t(c_get_alias_set): Remove many cases and rework to just handle\n\tC-specific cases.\n\t* c-common.h (c_get_alias_set): Returns HOST_WIDE_INT.\n\t* c-decl.c (rtl.h, expr.h): Now included.\n\t(init_decl_processing): Call record_component_aliases on array types.\n\t(grokdeclarator): Likewise.\n\tSet TREE_ADDRESSABLE for all fields that are not bitfields.\n\t* c-typeck.c (common_type): Call record_component_aliases for array.\n\t* caller-save.c (setup_save_areas): Rework register loop for unsigned.\n\tSet all save areas to the frame alias set.\n\t* calls.c (initialie_argument_information): Call set_mem_attributes.\n\t(compute_argument_addresses, expand_call): Likewise.\n\t* explow.c (set_mem_attributes): New function.\n\t(stabilize): Use MEM_COPY_ATTRIBUTES and force_reg.\n\t* expr.c (struct move_by_pieces): Remove {to,from}_{struct,readonly}.\n\tLEN and OFFSET now HOST_WIDE_INT.\n\t(clear_by_pieces): Similar changes.\n\t(move_by_pieces): LEN now HOST_WIDE_INT; don't set deleted fields.\n\t(move_by_pieces_ninsns): Now returns unsigned HOST_WIDE_INT.\n\t(move_by_pieces_1): Don't use deleted fields, use MEM_COPY_ATTRIBUTES.\n\t(clear_by_pieces_1): Likewise.\n\t(emit_push_insn): Call set_mem_attributes.\n\t(expand_expr, case INDIRECT_REF): Likewise.\n\t(expand_expr, case VAR_DECL): Call change_address.\n\t* expr.h (ADD_PARM_SIZE, SUB_PARM_SIZE): Use host_integerp and\n\ttree_low_cst.\n\t(get_varargs_alias_set, get_frame_alias_set): New decls.\n\t(record_base_value, record_alias_subset, lang_get_alias_set): Likewise.\n\t(new_alias_set, set_mem_attributes): Likewse.\n\t* function.c (struct temp_slot): ALIAS_SET is HOST_WIDE_INT.\n\t(assign_stack_temp_for_type): Likewise.\n\tCan split slot even if alias set since can copy.\n\tSet MEM_ALIAS_SET and MEM_SET_IN_STRUCT_P.\n\t(assign_temp): Use host_integerp and tree_low_cst.\n\t(put_var_into_stack): Properly handle SAVE_EXPR.\n\t(put_addressof_into_stack): Likewise.\n\t(assign_parms): Call set_mem_attributes.\n\tDelete #if 0 code.\n\t(fix_lexical_address): Put reference to chain into frame alias set.\n\t(expand_function_start): Call set_mem_attributes.\n\t* integrate.c (expand_inline_function): Likewise.\n\t* recog.c (adj_offsettable_operand): Use MEM_COPY_ATTRIBUTES.\n\t* regmove.c (try_apply_stack_adjustment): Likewise.\n\t* reload.c (push_reload, make_memloc): Likewise.\n\t* reload1.c (alter_reg): Make alias sets for spilled pseudos.\n\t* rtl.def (MEM): Update comment.\n\t* rtl.h (MEM_ALIAS_SET): Now uses XCWINT.\n\t(move_by_pieces): Change length to HOST_WIDE_INT.\n\t(record_base_value, record_alias_subset): Delete from here.\n\t* stmt.c (expand_decl): Call set_mem_attributes.\n\t* stor-layout.c (finish_record_layout): Call record_component_aliases.i\n\t* toplev.c (compile_file): Call init_alias_once earlier.\n\t* tree.c (lang_get_alias_set, get_alias_set, new_alias_set): Deleted\n\tfrom here: now in alias.c.\n\t* tree.h (struct tree_type): alias_set is HOST_WIDE_INT.\n\t(struct tree_decl): Likewise.\n\t(get_alias_set, new_alias_set, lang_get_alias_set): Deleted from here.\n\t* varasm.c (make_function_rtl, make_decl_rtl): Call set_mem_attributes.\n\t(output_constant_def, force_const_mem): Likewise.\n\t* cp/Makefile.in (decl.o): Include ../expr.h.\n\t* cp/decl.c (expr.h): Include.\n\t(init_decl_processing): Call record_component_aliases for arrays.\n\t(grokdeclarator): Likewise.\n\tSet TREE_ADDRESSABLE for fields that aren't bitfields.\n\t* cp/tree.c (build_cplus_array_type_1): Call record_component_aliases.\n\nFrom-SVN: r34308", "tree": {"sha": "6a4159283d1645e0e5edf8223da6d8765ea85027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a4159283d1645e0e5edf8223da6d8765ea85027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/051c57dafd8c31f1f098c9c8439dfa3c26e92c2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051c57dafd8c31f1f098c9c8439dfa3c26e92c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051c57dafd8c31f1f098c9c8439dfa3c26e92c2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051c57dafd8c31f1f098c9c8439dfa3c26e92c2c/comments", "author": null, "committer": null, "parents": [{"sha": "26a41784e00005b8164087f1bfc6f046c26df619", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a41784e00005b8164087f1bfc6f046c26df619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26a41784e00005b8164087f1bfc6f046c26df619"}], "stats": {"total": 13, "additions": 13, "deletions": 0}, "files": [{"sha": "74ac13aba11343cd7e2efaddacc7ce7dec928b7b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051c57dafd8c31f1f098c9c8439dfa3c26e92c2c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051c57dafd8c31f1f098c9c8439dfa3c26e92c2c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=051c57dafd8c31f1f098c9c8439dfa3c26e92c2c", "patch": "@@ -30,9 +30,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n+#include \"rtl.h\"\n #include \"flags.h\"\n #include \"function.h\"\n #include \"output.h\"\n+#include \"expr.h\"\n #include \"c-tree.h\"\n #include \"c-lex.h\"\n #include \"toplev.h\"\n@@ -3012,13 +3014,19 @@ init_decl_processing ()\n      array type.  */\n   char_array_type_node\n     = build_array_type (char_type_node, array_domain_type);\n+\n   /* Likewise for arrays of ints.  */\n   int_array_type_node\n     = build_array_type (integer_type_node, array_domain_type);\n+\n   /* This is for wide string constants.  */\n   wchar_array_type_node\n     = build_array_type (wchar_type_node, array_domain_type);\n \n+  record_component_aliases (char_array_type_node);\n+  record_component_aliases (int_array_type_node);\n+  record_component_aliases (wchar_array_type_node);\n+\n   void_list_node = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n \n   default_function_type\n@@ -4399,6 +4407,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  type = build_array_type (type, itype);\n \t  if (type_quals)\n \t    type = c_build_qualified_type (type, type_quals);\n+\t  record_component_aliases (type);\n \n #if 0\t/* don't clear these; leave them set so that the array type\n \t   or the variable is itself const or volatile.  */\n@@ -4571,6 +4580,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       && TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type) == 0)\n     {\n       type = build_array_type (TREE_TYPE (type), 0);\n+      record_component_aliases (type);\n       if (size_varies)\n \tC_TYPE_VARIABLE_SIZE (type) = 1;\n     }\n@@ -4683,11 +4693,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n \t\t\t\t\t\t\t     type_quals),\n \t\t\t\t     TYPE_DOMAIN (type));\n+\t    record_component_aliases (type);\n #if 0 /* Leave the field const or volatile as well.  */\n \t    type_quals = TYPE_UNQUALIFIED;\n #endif\n \t  }\n \tdecl = build_decl (FIELD_DECL, declarator, type);\n+\tTREE_ADDRESSABLE (decl) = ! bitfield;\n \tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n       }\n@@ -4763,6 +4775,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n \t\t\t\t\t\t\t     type_quals),\n \t\t\t\t     TYPE_DOMAIN (type));\n+\t    record_component_aliases (type);\n #if 0 /* Leave the variable const or volatile as well.  */\n \t    type_quals = TYPE_UNQUALIFIED;\n #endif"}]}