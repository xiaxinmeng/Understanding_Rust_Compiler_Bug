{"sha": "a7da4881303a7bc9a59014f0d03cd946a9cdecec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdkYTQ4ODEzMDNhN2JjOWE1OTAxNGYwZDAzY2Q5NDZhOWNkZWNlYw==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2016-11-30T09:59:50Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-11-30T09:59:50Z"}, "message": "Implement LWG 2534, Constrain rvalue stream operators.\n\n* include/std/istream (__is_convertible_to_basic_istream): New.\n(__is_extractable): Likewise.\n(operator>>(basic_istream<_CharT, _Traits>&&, _Tp&&)):\nTurn the stream parameter into a template parameter\nand constrain.\n* include/std/ostream (__is_convertible_to_basic_ostream): New.\n(__is_insertable): Likewise.\n(operator<<(basic_ostream<_CharT, _Traits>&&, const _Tp&)):\nTurn the stream parameter into a template parameter\nand constrain.\n* testsuite/27_io/basic_istream/extractors_other/char/4.cc: New.\n* testsuite/27_io/basic_istream/extractors_other/wchar_t/4.cc:\nLikewise.\n* testsuite/27_io/basic_ostream/inserters_other/char/6.cc: Likewise.\n* testsuite/27_io/basic_ostream/inserters_other/wchar_t/6.cc: Likewise.\n\nFrom-SVN: r243006", "tree": {"sha": "a174bba7556763a15e784ab3eaadd32609000ff2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a174bba7556763a15e784ab3eaadd32609000ff2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7da4881303a7bc9a59014f0d03cd946a9cdecec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7da4881303a7bc9a59014f0d03cd946a9cdecec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7da4881303a7bc9a59014f0d03cd946a9cdecec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7da4881303a7bc9a59014f0d03cd946a9cdecec/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40109581065366e04c547d2bff6e8f7ff5646fb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40109581065366e04c547d2bff6e8f7ff5646fb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40109581065366e04c547d2bff6e8f7ff5646fb8"}], "stats": {"total": 469, "additions": 463, "deletions": 6}, "files": [{"sha": "fd26b1cfdf040a035cdaf2b92bb5e8ce67dce4ba", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a7da4881303a7bc9a59014f0d03cd946a9cdecec", "patch": "@@ -1,3 +1,22 @@\n+2016-11-30  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement LWG 2534, Constrain rvalue stream operators.\n+\t* include/std/istream (__is_convertible_to_basic_istream): New.\n+\t(__is_extractable): Likewise.\n+\t(operator>>(basic_istream<_CharT, _Traits>&&, _Tp&&)):\n+\tTurn the stream parameter into a template parameter\n+\tand constrain.\n+\t* include/std/ostream (__is_convertible_to_basic_ostream): New.\n+\t(__is_insertable): Likewise.\n+\t(operator<<(basic_ostream<_CharT, _Traits>&&, const _Tp&)):\n+\tTurn the stream parameter into a template parameter\n+\tand constrain.\n+\t* testsuite/27_io/basic_istream/extractors_other/char/4.cc: New.\n+\t* testsuite/27_io/basic_istream/extractors_other/wchar_t/4.cc:\n+\tLikewise.\n+\t* testsuite/27_io/basic_ostream/inserters_other/char/6.cc: Likewise.\n+\t* testsuite/27_io/basic_ostream/inserters_other/wchar_t/6.cc: Likewise.\n+\n 2016-11-30  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* testsuite/experimental/type_erased_allocator/2.cc: Add"}, {"sha": "4f0e940b2aa6064a8f6ab663304c7f840f42f458", "filename": "libstdc++-v3/include/std/istream", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream?ref=a7da4881303a7bc9a59014f0d03cd946a9cdecec", "patch": "@@ -908,6 +908,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     ws(basic_istream<_CharT, _Traits>& __is);\n \n #if __cplusplus >= 201103L\n+\n+  template<typename _Tp>\n+    struct __is_convertible_to_basic_istream\n+    {\n+      template<typename _Ch, typename _Up>\n+      static true_type __check(basic_istream<_Ch, _Up>*);\n+\n+      static false_type __check(void*);\n+    public:\n+      using type = decltype(__check(declval<_Tp*>()));\n+      constexpr static bool value = type::value;\n+  };\n+\n+  template<typename _Istream, typename _Tp, typename = void>\n+    struct __is_extractable : false_type {};\n+\n+  template<typename _Istream, typename _Tp>\n+    struct __is_extractable<_Istream, _Tp,\n+\t\t\t    __void_t<decltype(declval<_Istream&>()\n+\t\t\t\t\t      >> declval<_Tp>())>>\n+    : true_type {};\n+\n   // [27.7.1.6] Rvalue stream extraction\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // 2328. Rvalue stream extraction should use perfect forwarding\n@@ -921,9 +943,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  rvalue streams since they won't bind to the extractor functions\n    *  that take an lvalue reference.\n   */\n-  template<typename _CharT, typename _Traits, typename _Tp>\n-    inline basic_istream<_CharT, _Traits>&\n-    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp&& __x)\n+  template<typename _Istream, typename _Tp>\n+    inline\n+    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,\n+\t\t\t      __is_convertible_to_basic_istream<\n+\t\t\t\ttypename remove_reference<_Istream>::type>,\n+\t\t\t      __is_extractable<_Istream&, _Tp&&>>::value,\n+\t\t       _Istream&>::type\n+    operator>>(_Istream&& __is, _Tp&& __x)\n     {\n       __is >> std::forward<_Tp>(__x);\n       return __is;"}, {"sha": "a1fe892ccdbcd711149ad0f8c3e030797935480f", "filename": "libstdc++-v3/include/std/ostream", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream?ref=a7da4881303a7bc9a59014f0d03cd946a9cdecec", "patch": "@@ -613,6 +613,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __os.flush(); }\n \n #if __cplusplus >= 201103L\n+  template<typename _Tp>\n+    struct __is_convertible_to_basic_ostream\n+  {\n+    template<typename _Ch, typename _Up>\n+    static true_type __check(basic_ostream<_Ch, _Up>*);\n+\n+    static false_type __check(void*);\n+  public:\n+    using type = decltype(__check(declval<_Tp*>()));\n+    constexpr static bool value = type::value;\n+  };\n+\n+  template<typename _Ostream, typename _Tp, typename = void>\n+    struct __is_insertable : false_type {};\n+\n+  template<typename _Ostream, typename _Tp>\n+    struct __is_insertable<_Ostream, _Tp,\n+\t\t\t   __void_t<decltype(declval<_Ostream&>()\n+\t\t\t\t\t     << declval<const _Tp&>())>>\n+\t\t\t\t    : true_type {};\n+\n   /**\n    *  @brief  Generic inserter for rvalue stream\n    *  @param  __os  An input stream.\n@@ -623,9 +644,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  rvalue streams since they won't bind to the inserter functions\n    *  that take an lvalue reference.\n   */\n-  template<typename _CharT, typename _Traits, typename _Tp>\n-    inline basic_ostream<_CharT, _Traits>&\n-    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)\n+  template<typename _Ostream, typename _Tp>\n+    inline\n+    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,\n+\t\t\t      __is_convertible_to_basic_ostream<\n+\t\t\t\ttypename remove_reference<_Ostream>::type>,\n+\t\t\t      __is_insertable<_Ostream&, const _Tp&>>::value,\n+\t\t       _Ostream&>::type\n+\t\t\t\t      //basic_ostream<_CharT, _Traits>&\n+    operator<<(_Ostream&& __os, const _Tp& __x)\n     {\n       __os << __x;\n       return __os;"}, {"sha": "0922b0b643cf1c9381c03c5aa323d043c024435a", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/4.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fchar%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fchar%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fchar%2F4.cc?ref=a7da4881303a7bc9a59014f0d03cd946a9cdecec", "patch": "@@ -0,0 +1,96 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 27.6.2.5.3 basic_ostream manipulator inserters\n+\n+#include <sstream>\n+\n+struct X {};\n+std::istream& operator>>(std::istream&, X&) = delete;\n+\n+struct Y {};\n+std::istream& operator>>(std::istream& is, Y&) {return is;}\n+std::istream& operator>>(std::istream& is, Y&&) {return is;}\n+\n+struct Z{};\n+\n+template <class T>\n+auto f(T&&) -> decltype(void(std::declval<std::istream&>()\n+\t\t\t     >> std::declval<T&&>()),\n+\t\t\tstd::true_type());\n+\n+std::false_type f(...);\n+\n+template <class T>\n+auto g(T&&) -> decltype(void(std::declval<std::istream&&>()\n+\t\t\t     >> std::declval<T&&>()),\n+\t\t\tstd::true_type());\n+\n+std::false_type g(...);\n+\n+void test01()\n+{\n+  Y y;\n+  std::istringstream is;\n+  is >> y;\n+  is >> Y();\n+  std::istringstream() >> y;\n+  std::istringstream() >> Y();\n+  static_assert(!std::__is_extractable<std::istream&, X&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::istream&&, X&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::istream&, X&&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::istream&&, X&&>::value, \"\");\n+  static_assert(std::__is_extractable<std::istream&, Y&>::value, \"\");\n+  static_assert(std::__is_extractable<std::istream&&, Y&>::value, \"\");\n+  static_assert(std::__is_extractable<std::istream&, Y&&>::value, \"\");\n+  static_assert(std::__is_extractable<std::istream&&, Y&&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::istream&, Z&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::istream&&, Z&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::istream&, Z&&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::istream&&, Z&&>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<X&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<X&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Y&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Y&&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Z&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Z&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<X&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<X&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Y&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Y&&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Z&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Z&&>())),\n+\t\tstd::false_type>::value, \"\");\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "87c4ce420de71613ab78966131b5f03bfd2bc953", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/4.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fwchar_t%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fwchar_t%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fwchar_t%2F4.cc?ref=a7da4881303a7bc9a59014f0d03cd946a9cdecec", "patch": "@@ -0,0 +1,96 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 27.6.2.5.3 basic_ostream manipulator inserters\n+\n+#include <sstream>\n+\n+struct X {};\n+std::wistream& operator>>(std::wistream&, X&) = delete;\n+\n+struct Y {};\n+std::wistream& operator>>(std::wistream& is, Y&) {return is;}\n+std::wistream& operator>>(std::wistream& is, Y&&) {return is;}\n+\n+struct Z{};\n+\n+template <class T>\n+auto f(T&&) -> decltype(void(std::declval<std::wistream&>()\n+\t\t\t     >> std::declval<T&&>()),\n+\t\t\tstd::true_type());\n+\n+std::false_type f(...);\n+\n+template <class T>\n+auto g(T&&) -> decltype(void(std::declval<std::wistream&&>()\n+\t\t\t     >> std::declval<T&&>()),\n+\t\t\tstd::true_type());\n+\n+std::false_type g(...);\n+\n+void test01()\n+{\n+  Y y;\n+  std::wistringstream is;\n+  is >> y;\n+  is >> Y();\n+  std::wistringstream() >> y;\n+  std::wistringstream() >> Y();\n+  static_assert(!std::__is_extractable<std::wistream&, X&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::wistream&&, X&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::wistream&, X&&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::wistream&&, X&&>::value, \"\");\n+  static_assert(std::__is_extractable<std::wistream&, Y&>::value, \"\");\n+  static_assert(std::__is_extractable<std::wistream&&, Y&>::value, \"\");\n+  static_assert(std::__is_extractable<std::wistream&, Y&&>::value, \"\");\n+  static_assert(std::__is_extractable<std::wistream&&, Y&&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::wistream&, Z&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::wistream&&, Z&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::wistream&, Z&&>::value, \"\");\n+  static_assert(!std::__is_extractable<std::wistream&&, Z&&>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<X&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<X&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Y&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Y&&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Z&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Z&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<X&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<X&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Y&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Y&&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Z&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Z&&>())),\n+\t\tstd::false_type>::value, \"\");\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "f5b27f9ce1b4cd2d76882be2569bcb620381e699", "filename": "libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/6.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fchar%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fchar%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fchar%2F6.cc?ref=a7da4881303a7bc9a59014f0d03cd946a9cdecec", "patch": "@@ -0,0 +1,96 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 27.6.2.5.3 basic_ostream manipulator inserters\n+\n+#include <sstream>\n+\n+struct X {};\n+std::ostream& operator<<(std::ostream&, const X&) = delete;\n+\n+struct Y {};\n+std::ostream& operator<<(std::ostream& os, const Y&) {return os;}\n+std::ostream& operator<<(std::ostream&& os, const Y&) {return os;}\n+\n+struct Z{};\n+\n+template <class T>\n+auto f(T&&) -> decltype(void(std::declval<std::ostream&>()\n+\t\t\t     << std::declval<T&&>()),\n+\t\t\tstd::true_type());\n+\n+std::false_type f(...);\n+\n+template <class T>\n+auto g(T&&) -> decltype(void(std::declval<std::ostream&&>()\n+\t\t\t     << std::declval<T&&>()),\n+\t\t\tstd::true_type());\n+\n+std::false_type g(...);\n+\n+void test01()\n+{\n+  Y y;\n+  std::ostringstream os;\n+  os << y;\n+  os << Y();\n+  std::ostringstream() << y;\n+  std::ostringstream() << Y();\n+  static_assert(!std::__is_insertable<std::ostream&, X&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::ostream&&, X&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::ostream&, X&&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::ostream&&, X&&>::value, \"\");\n+  static_assert(std::__is_insertable<std::ostream&, Y&>::value, \"\");\n+  static_assert(std::__is_insertable<std::ostream&&, Y&&>::value, \"\");\n+  static_assert(std::__is_insertable<std::ostream&, Y&>::value, \"\");\n+  static_assert(std::__is_insertable<std::ostream&&, Y&&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::ostream&, Z&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::ostream&&, Z&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::ostream&, Z&&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::ostream&&, Z&&>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<X&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<X&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Y&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Y&&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Z&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Z&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<X&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<X&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Y&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Y&&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Z&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Z&&>())),\n+\t\tstd::false_type>::value, \"\");\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "1aed058f2e62eca4303720a048fa2db2a710e7fd", "filename": "libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/6.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fwchar_t%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7da4881303a7bc9a59014f0d03cd946a9cdecec/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fwchar_t%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Finserters_other%2Fwchar_t%2F6.cc?ref=a7da4881303a7bc9a59014f0d03cd946a9cdecec", "patch": "@@ -0,0 +1,96 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 27.6.2.5.3 basic_ostream manipulator inserters\n+\n+#include <sstream>\n+\n+struct X {};\n+std::wostream& operator<<(std::wostream&, const X&) = delete;\n+\n+struct Y {};\n+std::wostream& operator<<(std::wostream& os, const Y&) {return os;}\n+std::wostream& operator<<(std::wostream&& os, const Y&) {return os;}\n+\n+struct Z{};\n+\n+template <class T>\n+auto f(T&&) -> decltype(void(std::declval<std::wostream&>()\n+\t\t\t     << std::declval<T&&>()),\n+\t\t\tstd::true_type());\n+\n+std::false_type f(...);\n+\n+template <class T>\n+auto g(T&&) -> decltype(void(std::declval<std::wostream&&>()\n+\t\t\t     << std::declval<T&&>()),\n+\t\t\tstd::true_type());\n+\n+std::false_type g(...);\n+\n+void test01()\n+{\n+  Y y;\n+  std::wostringstream os;\n+  os << y;\n+  os << Y();\n+  std::wostringstream() << y;\n+  std::wostringstream() << Y();\n+  static_assert(!std::__is_insertable<std::wostream&, X&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::wostream&&, X&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::wostream&, X&&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::wostream&&, X&&>::value, \"\");\n+  static_assert(std::__is_insertable<std::wostream&, Y&>::value, \"\");\n+  static_assert(std::__is_insertable<std::wostream&&, Y&&>::value, \"\");\n+  static_assert(std::__is_insertable<std::wostream&, Y&>::value, \"\");\n+  static_assert(std::__is_insertable<std::wostream&&, Y&&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::wostream&, Z&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::wostream&&, Z&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::wostream&, Z&&>::value, \"\");\n+  static_assert(!std::__is_insertable<std::wostream&&, Z&&>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<X&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<X&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Y&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Y&&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Z&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(f(std::declval<Z&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<X&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<X&&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Y&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Y&&>())),\n+\t\tstd::true_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Z&>())),\n+\t\tstd::false_type>::value, \"\");\n+  static_assert(std::is_same<decltype(g(std::declval<Z&&>())),\n+\t\tstd::false_type>::value, \"\");\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}]}