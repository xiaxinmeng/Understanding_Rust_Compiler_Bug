{"sha": "0f40f9f7c68aadde4d52b4fc04d016b72451d238", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY0MGY5ZjdjNjhhYWRkZTRkNTJiNGZjMDRkMDE2YjcyNDUxZDIzOA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-06-28T21:50:09Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-06-28T21:50:09Z"}, "message": "i386.md: Global update to use new string syntax where it will improve readability.\n\n\t* config/i386/i386.md: Global update to use new string syntax\n\twhere it will improve readability.  Warning fixes:\n\t(*truncdfsf2_2): Abort if which_alternative is not 0 or 1.\n\t(*adddi_1_rex64, *adddi_2_rex64, *adddi_3_rex64,\n\t*adddi_4_rex64, *adddi_5_rex64): Cast 1 to unsigned int.\n\n\t* read-rtl.c: Syntactic sugar for C embedded in strings in\n\tmachine descriptions.\n\t(read_string): Break inner loop into separate function.  Takes\n\tan int.  Dispatch to read_quoted_string or read_braced_string\n\tas appropriate.  Automatically insert a leading star on braced\n\tstrings if STAR_IF_BRACED is true.\n\t(read_quoted_string, read_braced_string): New functions.\n\t* doc/rtl.texi, doc/md.texi: Document new syntax.  Update\n\texamples to match.\n\n\t* rtl.c: Split RTL reader (read_rtx, read_skip_spaces,\n\ttraverse_md_constants, fatal_with_file_and_line,\n\tfatal_expected_char, read_name, read_string, def_hash,\n\tdef_name_eq_p, read_constants, and related data) to its own\n\tfile.  Weed out now-unnecessary #includes.\n\t* read-rtl.c: New file.\n\t* Makefile.in (HOST_RTL): Add read-rtl.o.\n\t(read-rtl.o): New rule.\n\t(rtl.o, $(HOST_PREFIX_1)rtl.o): Update dependencies.\n\t* doc/gcc.texi (Passes): Talk briefly about the support\n\tlibrary used by genfoo.\n\t* doc/rtl.texi (Reading RTL): read_rtx is not available in the\n\tcompiler itself.\n\nFrom-SVN: r43646", "tree": {"sha": "ac4e7f001b87da3b312391bda96de6043b090057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac4e7f001b87da3b312391bda96de6043b090057"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f40f9f7c68aadde4d52b4fc04d016b72451d238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f40f9f7c68aadde4d52b4fc04d016b72451d238", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f40f9f7c68aadde4d52b4fc04d016b72451d238", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f40f9f7c68aadde4d52b4fc04d016b72451d238/comments", "author": null, "committer": null, "parents": [{"sha": "0168a84948b3ad7d0b02ff00947c90d003020bd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0168a84948b3ad7d0b02ff00947c90d003020bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0168a84948b3ad7d0b02ff00947c90d003020bd8"}], "stats": {"total": 4094, "additions": 2036, "deletions": 2058}, "files": [{"sha": "6b7ac2938f199ba08a3606e8e7691a67647cf03b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f40f9f7c68aadde4d52b4fc04d016b72451d238", "patch": "@@ -1,3 +1,35 @@\n+2001-06-28  Zack Weinberg  <zackw@stanford.edu>\n+\n+\t* config/i386/i386.md: Global update to use new string syntax\n+\twhere it will improve readability.  Warning fixes:\n+\t(*truncdfsf2_2): Abort if which_alternative is not 0 or 1.\n+\t(*adddi_1_rex64, *adddi_2_rex64, *adddi_3_rex64,\n+\t*adddi_4_rex64, *adddi_5_rex64): Cast 1 to unsigned int.\n+\n+\t* read-rtl.c: Syntactic sugar for C embedded in strings in\n+\tmachine descriptions.\n+\t(read_string): Break inner loop into separate function.  Takes\n+\tan int.  Dispatch to read_quoted_string or read_braced_string\n+\tas appropriate.  Automatically insert a leading star on braced\n+\tstrings if STAR_IF_BRACED is true.\n+\t(read_quoted_string, read_braced_string): New functions.\n+\t* doc/rtl.texi, doc/md.texi: Document new syntax.  Update\n+\texamples to match.\n+\n+\t* rtl.c: Split RTL reader (read_rtx, read_skip_spaces,\n+\ttraverse_md_constants, fatal_with_file_and_line,\n+\tfatal_expected_char, read_name, read_string, def_hash,\n+\tdef_name_eq_p, read_constants, and related data) to its own\n+\tfile.  Weed out now-unnecessary #includes.\n+\t* read-rtl.c: New file.\n+\t* Makefile.in (HOST_RTL): Add read-rtl.o.\n+\t(read-rtl.o): New rule.\n+\t(rtl.o, $(HOST_PREFIX_1)rtl.o): Update dependencies.\n+\t* doc/gcc.texi (Passes): Talk briefly about the support\n+\tlibrary used by genfoo.\n+\t* doc/rtl.texi (Reading RTL): read_rtx is not available in the\n+\tcompiler itself.\n+\n 2001-06-28  Stan Shebs  <shebs@apple.com>\n \n \t* config/darwin.h (REGISTER_TARGET_PRAGMAS): Define.\n@@ -121,7 +153,7 @@ Wed Jun 27 18:01:09 2001  Jeffrey A Law  (law@cygnus.com)\n \t. at end of sentences preceded by a capital letter with @..\n \n 2001-06-26  Daniel Berlin  <dan@cgsoftware.com>\n-\t\n+\n \t* doc/invoke.texi: Add description of max-gcse-passes param.\n \n \t* gcse.c (gcse_main): Use MAX_GCSE_PASSES instead of MAX_PASSES.\n@@ -439,7 +471,7 @@ Tue Jun 26 12:40:12 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t* config/ia64/quadlib.c: New.\n \t* config/ia64/t-hpux: New.\n \t* config/i386/i386.h (INTEL_EXTENDED_IEEE_FORMAT): Define to one.\n-\t\n+\n 2001-06-25  Jim Wilson  <wilson@redhat.com>\n \n \t* config/i960/t-960bare (i960-c.o): Add missing header dependencies.\n@@ -734,7 +766,7 @@ Thu Jun 21 22:15:10 2001  J\"orn Rennecke <amylaar@redhat.com>\n 2001-06-21  DJ Delorie  <dj@redhat.com>\n \n \t* integrate.c (mark_hard_reg_initial_vals): Check for NULL.\n-\t\n+\n \t* integrate.c (ggc.h): Include.\n \t(initial_value_pair, initial_value_struct,\n \tsetup_initial_hard_reg_value_integration): Add prototypes.\n@@ -796,7 +828,7 @@ Wed Jun 20 08:35:02 2001  Jeffrey A Law  (law@cygnus.com)\n \n \t* ssa.c (rename_block): Update parameter to remove_phi_alternative\n \t(convert_from_ssa): Do create REG_DEAD and REG_UNUSED notes when\n-\tre-running life analysis. \n+\tre-running life analysis.\n \n 2001-06-20  Stan Shebs  <shebs@apple.com>\n "}, {"sha": "7534235083da2ff2a61dd09b78a7a691075c9ed1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0f40f9f7c68aadde4d52b4fc04d016b72451d238", "patch": "@@ -633,7 +633,7 @@ LIBS =\t$(OBSTACK) $(INTLLIBS) @LIBS@ $(VFPRINTF) $(DOPRINT) \\\n HOST_LIBS = $(USE_HOST_OBSTACK) $(USE_HOST_VFPRINTF) \\\n \t    $(USE_HOST_DOPRINT) $(USE_HOST_STRSTR)\n \n-HOST_RTL = $(HOST_PREFIX)rtl.o $(HOST_PREFIX)bitmap.o \\\n+HOST_RTL = $(HOST_PREFIX)rtl.o read-rtl.o $(HOST_PREFIX)bitmap.o \\\n \t\t$(HOST_PREFIX)ggc-none.o gensupport.o hashtab.o safe-ctype.o\n \n HOST_PRINT = $(HOST_PREFIX)print-rtl.o\n@@ -1344,12 +1344,13 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) function.h \\\n \t  -c $(srcdir)/toplev.c\n main.o : main.c toplev.h\n \n-rtl.o : rtl.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) bitmap.h $(GGC_H) toplev.h\n+rtl.o : rtl.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) real.h $(GGC_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n print-rtl.o : print-rtl.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h \\\n     $(BASIC_BLOCK_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) hard-reg-set.h\n errors.o : errors.c $(GCONFIG_H) $(SYSTEM_H) errors.h\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n@@ -1704,6 +1705,10 @@ s-genrtl: gengenrtl$(build_exeext) $(srcdir)/move-if-change $(RTL_BASE_H)\n # about the target machine.  They do depend on config.h itself,\n # since that describes the host machine.\n \n+read-rtl.o: read-rtl.c $(HCONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n+  $(OBSTACK_H) $(HASHTAB_H)\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/read-rtl.c\n+\n gensupport.o: gensupport.c $(RTL_H) $(OBSTACK_H) $(SYSTEM_H) errors.h gensupport.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/gensupport.c\n \n@@ -1814,7 +1819,7 @@ gengenrtl.o : gengenrtl.c $(RTL_BASE_H) $(HCONFIG_H) $(SYSTEM_H) real.h\n # and HOST_PREFIX_1 is `foobar', just to ensure these rules don't conflict\n # with the rules for rtl.o, etc.\n $(HOST_PREFIX_1)rtl.o: $(srcdir)/rtl.c $(HCONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n-  bitmap.h $(GGC_H) toplev.h $(HASHTAB_H)\n+  $(GGC_H)\n \trm -f $(HOST_PREFIX)rtl.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/rtl.c > $(HOST_PREFIX)rtl.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)rtl.c"}, {"sha": "e788849a1e01a1838236bc446b142c0af2f73312", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1204, "deletions": 1415, "changes": 2619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0f40f9f7c68aadde4d52b4fc04d016b72451d238"}, {"sha": "6601ab61c7afee72c2d317b3462aaa8a49fdecae", "filename": "gcc/doc/gcc.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fdoc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fdoc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc.texi?ref=0f40f9f7c68aadde4d52b4fc04d016b72451d238", "patch": "@@ -3724,6 +3724,10 @@ and @file{rtl.def}, and subroutines in file @file{rtl.c}.  The tools\n @code{gen*} also use these files to read and work with the machine\n description RTL@.\n \n+@item\n+All the tools that read the machine description use support routines\n+found in @file{gensupport.c}, @file{errors.c}, and @file{read-rtl.c}.\n+\n @findex genconfig\n @item\n Several passes refer to the header file @file{insn-config.h} which"}, {"sha": "3d4d2b1a6d5b63ea5cb446c687efdeeea88d23d6", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=0f40f9f7c68aadde4d52b4fc04d016b72451d238", "patch": "@@ -184,9 +184,26 @@ Here is an actual example of an instruction pattern, for the 68000/68020.\n         (match_operand:SI 0 \"general_operand\" \"rm\"))]\n   \"\"\n   \"*\n-@{ if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))\n+@{ \n+  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))\n     return \\\"tstl %0\\\";\n-  return \\\"cmpl #0,%0\\\"; @}\")\n+  return \\\"cmpl #0,%0\\\"; \n+@}\")\n+@end example\n+\n+@noindent\n+This can also be written using braced strings:\n+\n+@example\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+        (match_operand:SI 0 \"general_operand\" \"rm\"))]\n+  \"\"\n+@{ \n+  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))\n+    return \"tstl %0\";\n+  return \"cmpl #0,%0\"; \n+@})\n @end example\n \n This is an instruction that sets the condition codes based on the value of\n@@ -620,6 +637,11 @@ template-string you want.  Most such templates use C string literals, which\n require doublequote characters to delimit them.  To include these\n doublequote characters in the string, prefix each one with @samp{\\}.\n \n+If the output control string is written as a brace block instead of a\n+double-quoted string, it is automatically assumed to be C code.  In that\n+case, it is not necessary to put in a leading asterisk, or to escape the\n+doublequotes surrounding C string literals.\n+\n The operands may be found in the array @code{operands}, whose C data type\n is @code{rtx []}.\n \n@@ -656,10 +678,10 @@ a pattern could use @code{which_alternative} to choose between them:\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,m\")\n         (const_int 0))]\n   \"\"\n-  \"*\n+  @{\n   return (which_alternative == 0\n-          ? \\\"clrreg %0\\\" : \\\"clrmem %0\\\");\n-  \")\n+          ? \"clrreg %0\" : \"clrmem %0\");\n+  @})\n @end smallexample\n \n The example above, where the assembler code to generate was\n@@ -3943,21 +3965,19 @@ Here is an example, taken from the 68000 machine description:\n    (set (match_operand:DF 0 \"register_operand\" \"=f\")\n         (match_operand:DF 1 \"register_operand\" \"ad\"))]\n   \"FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n-  \"*\n @{\n   rtx xoperands[2];\n   xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n #ifdef MOTOROLA\n-  output_asm_insn (\\\"move.l %1,(sp)\\\", xoperands);\n-  output_asm_insn (\\\"move.l %1,-(sp)\\\", operands);\n-  return \\\"fmove.d (sp)+,%0\\\";\n+  output_asm_insn (\"move.l %1,(sp)\", xoperands);\n+  output_asm_insn (\"move.l %1,-(sp)\", operands);\n+  return \"fmove.d (sp)+,%0\";\n #else\n-  output_asm_insn (\\\"movel %1,sp@@\\\", xoperands);\n-  output_asm_insn (\\\"movel %1,sp@@-\\\", operands);\n-  return \\\"fmoved sp@@+,%0\\\";\n+  output_asm_insn (\"movel %1,sp@@\", xoperands);\n+  output_asm_insn (\"movel %1,sp@@-\", operands);\n+  return \"fmoved sp@@+,%0\";\n #endif\n-@}\n-\")\n+@})\n @end smallexample\n \n @need 1000\n@@ -4656,11 +4676,10 @@ as follows:\n   [(set (pc)\n         (label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n-  \"*\n @{\n    return (get_attr_length (insn) == 4\n-           ? \\\"b %l0\\\" : \\\"l r15,=a(%l0); br r15\\\");\n-@}\"\n+           ? \"b %l0\" : \"l r15,=a(%l0); br r15\");\n+@}\n   [(set (attr \"length\") (if_then_else (lt (match_dup 0) (const_int 4096))\n                                       (const_int 4)\n                                       (const_int 6)))])"}, {"sha": "618322a43c3cc2839859648ff082936c09e413c4", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=0f40f9f7c68aadde4d52b4fc04d016b72451d238", "patch": "@@ -70,6 +70,21 @@ pointers instead of strings are valid.  Within RTL code, strings are most\n commonly found inside @code{symbol_ref} expressions, but they appear in\n other contexts in the RTL expressions that make up machine descriptions.\n \n+In a machine description, strings are normally written with double\n+quotes, as you would in C.  However, strings in machine descriptions may\n+extend over many lines, which is invalid C, and adjacent string\n+constants are not concatenated as they are in C.  Any string constant\n+may be surrounded with a single set of parentheses.  Sometimes this\n+makes the machine description easier to read.\n+\n+There is also a special syntax for strings, which can be useful when C\n+code is embedded in a machine description.  Wherever a string can\n+appear, it is also valid to write a C-style brace block.  The entire\n+brace block, including the outermost pair of braces, is considered to be\n+the string constant.  Double quote characters inside the braces are not\n+special.  Therefore, if you write string constants in the C code, you\n+need not escape each quote character with a backslash.\n+\n A vector contains an arbitrary number of pointers to expressions.  The\n number of elements in the vector is explicitly present in the vector.\n The written form of a vector consists of square brackets\n@@ -3182,11 +3197,10 @@ combiner is finished with the insn.  This is done by calling\n @section Reading RTL\n \n To read an RTL object from a file, call @code{read_rtx}.  It takes one\n-argument, a stdio stream, and returns a single RTL object.\n-\n-Reading RTL from a file is very slow.  This is not currently a\n-problem since reading RTL occurs only as part of building the\n-compiler.\n+argument, a stdio stream, and returns a single RTL object.  This routine\n+is defined in @file{read-rtl.c}.  It is not available in the compiler\n+itself, only the various programs that generate the compiler back end\n+from the machine description.\n \n People frequently have the idea of using RTL stored as text in a file as\n an interface between a language front end and the bulk of GCC@.  This"}, {"sha": "febab50b9687bcb36383b8d1e0d6157e7f9e3bbc", "filename": "gcc/read-rtl.c", "status": "added", "additions": 727, "deletions": 0, "changes": 727, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=0f40f9f7c68aadde4d52b4fc04d016b72451d238", "patch": "@@ -0,0 +1,727 @@\n+/* RTL reader for GNU C Compiler.\n+   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"hconfig.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+#include \"hashtab.h\"\n+\n+#define\tobstack_chunk_alloc\txmalloc\n+#define\tobstack_chunk_free\tfree\n+\n+static htab_t md_constants;\n+\n+static void fatal_with_file_and_line PARAMS ((FILE *, const char *, ...))\n+  ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n+static void fatal_expected_char PARAMS ((FILE *, int, int)) ATTRIBUTE_NORETURN;\n+static void read_name\t\tPARAMS ((char *, FILE *));\n+static char *read_string\tPARAMS ((struct obstack *, FILE *, int));\n+static char *read_quoted_string\tPARAMS ((struct obstack *, FILE *));\n+static char *read_braced_string\tPARAMS ((struct obstack *, FILE *));\n+static unsigned def_hash PARAMS ((const void *));\n+static int def_name_eq_p PARAMS ((const void *, const void *));\n+static void read_constants PARAMS ((FILE *infile, char *tmp_char));\n+\n+/* Subroutines of read_rtx.  */\n+\n+/* The current line number for the file.  */\n+int read_rtx_lineno = 1;\n+\n+/* The filename for aborting with file and line.  */\n+const char *read_rtx_filename = \"<unknown>\";\n+\n+static void\n+fatal_with_file_and_line VPARAMS ((FILE *infile, const char *msg, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  FILE *infile;\n+  const char *msg;\n+#endif\n+  va_list ap;\n+  char context[64];\n+  size_t i;\n+  int c;\n+\n+  VA_START (ap, msg);\n+\n+#ifndef ANSI_PROTOTYPES\n+  infile = va_arg (ap, FILE *);\n+  msg = va_arg (ap, const char *);\n+#endif\n+\n+  fprintf (stderr, \"%s:%d: \", read_rtx_filename, read_rtx_lineno);\n+  vfprintf (stderr, msg, ap);\n+  putc ('\\n', stderr);\n+\n+  /* Gather some following context.  */\n+  for (i = 0; i < sizeof(context)-1; ++i)\n+    {\n+      c = getc (infile);\n+      if (c == EOF)\n+\tbreak;\n+      if (c == '\\r' || c == '\\n')\n+\tbreak;\n+      context[i] = c;\n+    }\n+  context[i] = '\\0';\n+\n+  fprintf (stderr, \"%s:%d: following context is `%s'\\n\",\n+\t   read_rtx_filename, read_rtx_lineno, context);\n+\n+  va_end (ap);\n+  exit (1);\n+}\n+\n+/* Dump code after printing a message.  Used when read_rtx finds\n+   invalid data.  */\n+\n+static void\n+fatal_expected_char (infile, expected_c, actual_c)\n+     FILE *infile;\n+     int expected_c, actual_c;\n+{\n+  fatal_with_file_and_line (infile, \"expected character `%c', found `%c'\",\n+\t\t\t    expected_c, actual_c);\n+}\n+\n+/* Read chars from INFILE until a non-whitespace char\n+   and return that.  Comments, both Lisp style and C style,\n+   are treated as whitespace.\n+   Tools such as genflags use this function.  */\n+\n+int\n+read_skip_spaces (infile)\n+     FILE *infile;\n+{\n+  register int c;\n+  while (1)\n+    {\n+      c = getc (infile);\n+      switch (c)\n+\t{\n+\tcase '\\n':\n+\t  read_rtx_lineno++;\n+\t  break;\n+\n+\tcase ' ': case '\\t': case '\\f': case '\\r':\n+\t  break;\n+\n+\tcase ';':\n+\t  do\n+\t    c = getc (infile);\n+\t  while (c != '\\n' && c != EOF);\n+\t  read_rtx_lineno++;\n+\t  break;\n+\n+\tcase '/':\n+\t  {\n+\t    register int prevc;\n+\t    c = getc (infile);\n+\t    if (c != '*')\n+\t      fatal_expected_char (infile, '*', c);\n+\n+\t    prevc = 0;\n+\t    while ((c = getc (infile)) && c != EOF)\n+\t      {\n+\t\tif (c == '\\n')\n+\t\t   read_rtx_lineno++;\n+\t        else if (prevc == '*' && c == '/')\n+\t\t  break;\n+\t        prevc = c;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  return c;\n+\t}\n+    }\n+}\n+\n+/* Read an rtx code name into the buffer STR[].\n+   It is terminated by any of the punctuation chars of rtx printed syntax.  */\n+\n+static void\n+read_name (str, infile)\n+     char *str;\n+     FILE *infile;\n+{\n+  register char *p;\n+  register int c;\n+\n+  c = read_skip_spaces(infile);\n+\n+  p = str;\n+  while (1)\n+    {\n+      if (c == ' ' || c == '\\n' || c == '\\t' || c == '\\f')\n+\tbreak;\n+      if (c == ':' || c == ')' || c == ']' || c == '\"' || c == '/'\n+\t  || c == '(' || c == '[')\n+\t{\n+\t  ungetc (c, infile);\n+\t  break;\n+\t}\n+      *p++ = c;\n+      c = getc (infile);\n+    }\n+  if (p == str)\n+    fatal_with_file_and_line (infile, \"missing name or number\");\n+  if (c == '\\n')\n+    read_rtx_lineno++;\n+\n+  *p = 0;\n+\n+  if (md_constants)\n+    {\n+      /* Do constant expansion.  */\n+      struct md_constant *def;\n+\n+      p = str;\n+      do\n+\t{\n+\t  struct md_constant tmp_def;\n+\n+\t  tmp_def.name = p;\n+\t  def = htab_find (md_constants, &tmp_def);\n+\t  if (def)\n+\t    p = def->value;\n+\t} while (def);\n+      if (p != str)\n+\tstrcpy (str, p);\n+    }\n+}\n+\n+/* Read a double-quoted string onto the obstack.  Caller has scanned\n+   the leading quote.  */\n+static char *\n+read_quoted_string (ob, infile)\n+     struct obstack *ob;\n+     FILE *infile;\n+{\n+  int c;\n+  while (1)\n+    {\n+      c = getc (infile); /* Read the string  */\n+      if (c == '\\n')\n+\tread_rtx_lineno++;\n+      else if (c == '\\\\')\n+\t{\n+\t  c = getc (infile);\t/* Read the string  */\n+\t  /* \\; makes stuff for a C string constant containing\n+\t     newline and tab.  */\n+\t  if (c == ';')\n+\t    {\n+\t      obstack_grow (ob, \"\\\\n\\\\t\", 4);\n+\t      continue;\n+\t    }\n+\t  else if (c == '\\n')\n+\t    /* \\-newline: delete the backslash and update our idea of\n+\t       the line number.  */\n+\t    read_rtx_lineno++;\n+\t  else if (c == '\\\\' || c == '\"')\n+\t    ; /* \\\", \\\\ are a literal quote and backslash.  */\n+\t  else\n+\t    /* Backslash escapes we do not recognize are left unmolested.\n+\t       They may be handled by the C compiler (e.g. \\n, \\t) */\n+\t    {\n+\t      ungetc (c, infile);  /* put it back */\n+\t      c = '\\\\';\n+\t    }\n+\t}\n+      else if (c == '\"')\n+\tbreak;\n+\n+      obstack_1grow (ob, c);\n+    }\n+\n+  obstack_1grow (ob, 0);\n+  return obstack_finish (ob);\n+}\n+\n+/* Read a braced string (a la Tcl) onto the obstack.  Caller has\n+   scanned the leading brace.  Note that unlike quoted strings,\n+   the outermost braces _are_ included in the string constant.  */\n+static char *\n+read_braced_string (ob, infile)\n+     struct obstack *ob;\n+     FILE *infile;\n+{\n+  int c;\n+  int brace_depth = 1;  /* caller-processed */\n+\n+  obstack_1grow (ob, '{');\n+  while (brace_depth)\n+    {\n+      c = getc (infile); /* Read the string  */\n+      if (c == '\\n')\n+\tread_rtx_lineno++;\n+      else if (c == '{')\n+\tbrace_depth++;\n+      else if (c == '}')\n+\tbrace_depth--;\n+      else if (c == '\\\\')\n+\t{\n+\t  c = getc (infile);\t/* Read the string  */\n+\t  /* \\; makes stuff for a C string constant containing\n+\t     newline and tab.  */\n+\t  if (c == ';')\n+\t    {\n+\t      obstack_grow (ob, \"\\\\n\\\\t\", 4);\n+\t      continue;\n+\t    }\n+\t  else if (c == '\\n')\n+\t    /* \\-newline: delete the backslash and update our idea of\n+\t       the line number.  */\n+\t    read_rtx_lineno++;\n+\t  else if (c == '\\\\')\n+\t    ; /* \\\\ is a literal backslash */\n+\t  else\n+\t    /* Backslash escapes we do not recognize are left unmolested.\n+\t       They may be handled by the C compiler (e.g. \\n, \\t) */\n+\t    {\n+\t      ungetc (c, infile);  /* put it back */\n+\t      c = '\\\\';\n+\t    }\n+\t}\n+\n+      obstack_1grow (ob, c);\n+    }\n+      \n+  obstack_1grow (ob, 0);\n+  return obstack_finish (ob);\n+}\n+\n+/* Read some kind of string constant.  This is the high-level routine\n+   used by read_rtx.  It handles surrounding parentheses, leading star,\n+   and dispatch to the appropriate string constant reader.  */\n+\n+static char *\n+read_string (ob, infile, star_if_braced)\n+     struct obstack *ob;\n+     FILE *infile;\n+     int star_if_braced;\n+{\n+  char *stringbuf;\n+  int saw_paren = 0;\n+  int c;\n+\n+  c = read_skip_spaces (infile);\n+  if (c == '(')\n+    {\n+      saw_paren = 1;\n+      c = read_skip_spaces (infile);\n+    }\n+\n+  if (c == '\"')\n+    stringbuf = read_quoted_string (ob, infile);\n+  else if (c == '{')\n+    {\n+      if (star_if_braced)\n+\tobstack_1grow (ob, '*');\n+      stringbuf = read_braced_string (ob, infile);\n+    }\n+  else\n+    fatal_with_file_and_line (infile, \"expected `\\\"' or `{', found `%c'\", c);\n+       \n+  if (saw_paren)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c != ')')\n+\tfatal_expected_char (infile, ')', c);\n+    }\n+\n+  return stringbuf;\n+}\n+\f\n+/* Provide a version of a function to read a long long if the system does\n+   not provide one.  */\n+#if HOST_BITS_PER_WIDE_INT > HOST_BITS_PER_LONG && !defined(HAVE_ATOLL) && !defined(HAVE_ATOQ)\n+HOST_WIDE_INT\n+atoll(p)\n+    const char *p;\n+{\n+  int neg = 0;\n+  HOST_WIDE_INT tmp_wide;\n+\n+  while (ISSPACE(*p))\n+    p++;\n+  if (*p == '-')\n+    neg = 1, p++;\n+  else if (*p == '+')\n+    p++;\n+\n+  tmp_wide = 0;\n+  while (ISDIGIT(*p))\n+    {\n+      HOST_WIDE_INT new_wide = tmp_wide*10 + (*p - '0');\n+      if (new_wide < tmp_wide)\n+\t{\n+\t  /* Return INT_MAX equiv on overflow.  */\n+\t  tmp_wide = (~(unsigned HOST_WIDE_INT)0) >> 1;\n+\t  break;\n+\t}\n+      tmp_wide = new_wide;\n+      p++;\n+    }\n+\n+  if (neg)\n+    tmp_wide = -tmp_wide;\n+  return tmp_wide;\n+}\n+#endif\n+\n+/* Given a constant definition, return a hash code for its name.  */\n+static unsigned\n+def_hash (def)\n+     const void *def;\n+{\n+  unsigned result, i;\n+  const char *string = ((const struct md_constant *)def)->name;\n+\n+  for (result = i = 0;*string++ != '\\0'; i++)\n+    result += ((unsigned char) *string << (i % CHAR_BIT));\n+  return result;\n+}\n+\n+/* Given two constant definitions, return true if they have the same name.  */\n+static int\n+def_name_eq_p (def1, def2)\n+     const void *def1, *def2;\n+{\n+  return ! strcmp (((const struct md_constant *)def1)->name,\n+\t\t   ((const struct md_constant *)def2)->name);\n+}\n+\n+/* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer suitable\n+   to read a name or number into.  Process a define_constants directive,\n+   starting with the optional space after the \"define_constants\".  */\n+static void\n+read_constants (infile, tmp_char)\n+     FILE *infile;\n+     char *tmp_char;\n+{\n+  int c;\n+  htab_t defs;\n+\n+  c = read_skip_spaces (infile);\n+  if (c != '[')\n+    fatal_expected_char (infile, '[', c);\n+  defs = md_constants;\n+  if (! defs)\n+    defs = htab_create (32, def_hash, def_name_eq_p, (htab_del) 0);\n+  /* Disable constant expansion during definition processing.  */\n+  md_constants = 0;\n+  while ( (c = read_skip_spaces (infile)) != ']')\n+    {\n+      struct md_constant *def;\n+      void **entry_ptr;\n+\n+      if (c != '(')\n+\tfatal_expected_char (infile, '(', c);\n+      def = xmalloc (sizeof (struct md_constant));\n+      def->name = tmp_char;\n+      read_name (tmp_char, infile);\n+      entry_ptr = htab_find_slot (defs, def, TRUE);\n+      if (! *entry_ptr)\n+\tdef->name = xstrdup (tmp_char);\n+      c = read_skip_spaces (infile);\n+      ungetc (c, infile);\n+      read_name (tmp_char, infile);\n+      if (! *entry_ptr)\n+\t{\n+\t  def->value = xstrdup (tmp_char);\n+\t  *entry_ptr = def;\n+\t}\n+      else\n+\t{\n+\t  def = *entry_ptr;\n+\t  if (strcmp (def->value, tmp_char))\n+\t    fatal_with_file_and_line (infile,\n+\t\t\t\t      \"redefinition of %s, was %s, now %s\",\n+\t\t\t\t      def->name, def->value, tmp_char);\n+\t}\n+      c = read_skip_spaces (infile);\n+      if (c != ')')\n+\tfatal_expected_char (infile, ')', c);\n+    }\n+  md_constants = defs;\n+  c = read_skip_spaces (infile);\n+  if (c != ')')\n+    fatal_expected_char (infile, ')', c);\n+}\n+\n+/* For every constant definition, call CALLBACK with two arguments:\n+   a pointer a pointer to the constant definition and INFO.\n+   Stops when CALLBACK returns zero.  */\n+void\n+traverse_md_constants (callback, info)\n+     htab_trav callback;\n+     void *info;\n+{\n+  if (md_constants)\n+    htab_traverse (md_constants, callback, info);\n+}\n+\n+/* Read an rtx in printed representation from INFILE\n+   and return an actual rtx in core constructed accordingly.\n+   read_rtx is not used in the compiler proper, but rather in\n+   the utilities gen*.c that construct C code from machine descriptions.  */\n+\n+rtx\n+read_rtx (infile)\n+     FILE *infile;\n+{\n+  register int i, j;\n+  RTX_CODE tmp_code;\n+  register const char *format_ptr;\n+  /* tmp_char is a buffer used for reading decimal integers\n+     and names of rtx types and machine modes.\n+     Therefore, 256 must be enough.  */\n+  char tmp_char[256];\n+  rtx return_rtx;\n+  register int c;\n+  int tmp_int;\n+  HOST_WIDE_INT tmp_wide;\n+\n+  /* Obstack used for allocating RTL objects.  */\n+  static struct obstack rtl_obstack;\n+  static int initialized;\n+\n+  /* Linked list structure for making RTXs: */\n+  struct rtx_list\n+    {\n+      struct rtx_list *next;\n+      rtx value;\t\t/* Value of this node.  */\n+    };\n+\n+  if (!initialized) {\n+    obstack_init (&rtl_obstack);\n+    initialized = 1;\n+  }\n+\n+again:\n+  c = read_skip_spaces (infile); /* Should be open paren.  */\n+  if (c != '(')\n+    fatal_expected_char (infile, '(', c);\n+\n+  read_name (tmp_char, infile);\n+\n+  tmp_code = UNKNOWN;\n+\n+  if (! strcmp (tmp_char, \"define_constants\"))\n+    {\n+      read_constants (infile, tmp_char);\n+      goto again;\n+    }\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    if (! strcmp (tmp_char, GET_RTX_NAME (i)))\n+      {\n+\ttmp_code = (RTX_CODE) i;\t/* get value for name */\n+\tbreak;\n+      }\n+\n+  if (tmp_code == UNKNOWN)\n+    fatal_with_file_and_line (infile, \"unknown rtx code `%s'\", tmp_char);\n+\n+  /* (NIL) stands for an expression that isn't there.  */\n+  if (tmp_code == NIL)\n+    {\n+      /* Discard the closeparen.  */\n+      while ((c = getc (infile)) && c != ')')\n+\t;\n+\n+      return 0;\n+    }\n+\n+  /* If we end up with an insn expression then we free this space below.  */\n+  return_rtx = rtx_alloc (tmp_code);\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (return_rtx));\n+\n+  /* If what follows is `: mode ', read it and\n+     store the mode in the rtx.  */\n+\n+  i = read_skip_spaces (infile);\n+  if (i == ':')\n+    {\n+      read_name (tmp_char, infile);\n+      for (j = 0; j < NUM_MACHINE_MODES; j++)\n+\tif (! strcmp (GET_MODE_NAME (j), tmp_char))\n+\t  break;\n+\n+      if (j == MAX_MACHINE_MODE)\n+\tfatal_with_file_and_line (infile, \"unknown mode `%s'\", tmp_char);\n+\n+      PUT_MODE (return_rtx, (enum machine_mode) j);\n+    }\n+  else\n+    ungetc (i, infile);\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (return_rtx)); i++)\n+    switch (*format_ptr++)\n+      {\n+\t/* 0 means a field for internal use only.\n+\t   Don't expect it to be present in the input.  */\n+      case '0':\n+\tbreak;\n+\n+      case 'e':\n+      case 'u':\n+\tXEXP (return_rtx, i) = read_rtx (infile);\n+\tbreak;\n+\n+      case 'V':\n+\t/* 'V' is an optional vector: if a closeparen follows,\n+\t   just store NULL for this element.  */\n+\tc = read_skip_spaces (infile);\n+\tungetc (c, infile);\n+\tif (c == ')')\n+\t  {\n+\t    XVEC (return_rtx, i) = 0;\n+\t    break;\n+ \t  }\n+\t/* Now process the vector.  */\n+\n+      case 'E':\n+\t{\n+\t  /* Obstack to store scratch vector in.  */\n+\t  struct obstack vector_stack;\n+\t  int list_counter = 0;\n+\t  rtvec return_vec = NULL_RTVEC;\n+\n+\t  c = read_skip_spaces (infile);\n+\t  if (c != '[')\n+\t    fatal_expected_char (infile, '[', c);\n+\n+\t  /* add expressions to a list, while keeping a count */\n+\t  obstack_init (&vector_stack);\n+\t  while ((c = read_skip_spaces (infile)) && c != ']')\n+\t    {\n+\t      ungetc (c, infile);\n+\t      list_counter++;\n+\t      obstack_ptr_grow (&vector_stack, (PTR) read_rtx (infile));\n+\t    }\n+\t  if (list_counter > 0)\n+\t    {\n+\t      return_vec = rtvec_alloc (list_counter);\n+\t      memcpy (&return_vec->elem[0], obstack_finish (&vector_stack),\n+\t\t      list_counter * sizeof (rtx));\n+\t    }\n+\t  XVEC (return_rtx, i) = return_vec;\n+\t  obstack_free (&vector_stack, NULL);\n+\t  /* close bracket gotten */\n+\t}\n+\tbreak;\n+\n+      case 'S':\n+\t/* 'S' is an optional string: if a closeparen follows,\n+\t   just store NULL for this element.  */\n+\tc = read_skip_spaces (infile);\n+\tungetc (c, infile);\n+\tif (c == ')')\n+\t  {\n+\t    XSTR (return_rtx, i) = 0;\n+\t    break;\n+\t  }\n+\n+      case 's':\n+\t{\n+\t  char *stringbuf;\n+\n+\t  /* The output template slot of a DEFINE_INSN,\n+\t     DEFINE_INSN_AND_SPLIT, or DEFINE_PEEPHOLE automatically\n+\t     gets a star inserted as its first character, if it is\n+\t     written with a brace block instead of a string constant.  */\n+\t  int star_if_braced =\n+\t    ((i == 3 && (GET_CODE (return_rtx) == DEFINE_INSN\n+\t\t\t || GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n+\t     || (i == 2 && GET_CODE (return_rtx) == DEFINE_PEEPHOLE));\n+\t    \n+\t  stringbuf = read_string (&rtl_obstack, infile, star_if_braced);\n+\n+\t  /* For insn patterns, we want to provide a default name\n+\t     based on the file and line, like \"*foo.md:12\", if the\n+\t     given name is blank.  These are only for define_insn and\n+\t     define_insn_and_split, to aid debugging.  */\n+\t  if (*stringbuf == '\\0'\n+\t      && i == 0\n+\t      && (GET_CODE (return_rtx) == DEFINE_INSN\n+\t\t  || GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n+\t    {\n+\t      char line_name[20];\n+\t      const char *fn = (read_rtx_filename ? read_rtx_filename : \"rtx\");\n+\t      const char *slash;\n+\t      for (slash = fn; *slash; slash ++)\n+\t\tif (*slash == '/' || *slash == '\\\\' || *slash == ':')\n+\t\t  fn = slash + 1;\n+\t      obstack_1grow (&rtl_obstack, '*');\n+\t      obstack_grow (&rtl_obstack, fn, strlen (fn));\n+\t      sprintf (line_name, \":%d\", read_rtx_lineno);\n+\t      obstack_grow (&rtl_obstack, line_name, strlen (line_name)+1);\n+\t      stringbuf = (char *) obstack_finish (&rtl_obstack);\n+\t    }\n+\n+\t  XSTR (return_rtx, i) = stringbuf;\n+\t}\n+\tbreak;\n+\n+      case 'w':\n+\tread_name (tmp_char, infile);\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\ttmp_wide = atoi (tmp_char);\n+#else\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n+\ttmp_wide = atol (tmp_char);\n+#else\n+\t/* Prefer atoll over atoq, since the former is in the ISO C99 standard.\n+\t   But prefer not to use our hand-rolled function above either.  */\n+#if defined(HAVE_ATOLL) || !defined(HAVE_ATOQ)\n+\ttmp_wide = atoll (tmp_char);\n+#else\n+\ttmp_wide = atoq (tmp_char);\n+#endif\n+#endif\n+#endif\n+\tXWINT (return_rtx, i) = tmp_wide;\n+\tbreak;\n+\n+      case 'i':\n+      case 'n':\n+\tread_name (tmp_char, infile);\n+\ttmp_int = atoi (tmp_char);\n+\tXINT (return_rtx, i) = tmp_int;\n+\tbreak;\n+\n+      default:\n+\tfprintf (stderr,\n+\t\t \"switch format wrong in rtl.read_rtx(). format was: %c.\\n\",\n+\t\t format_ptr[-1]);\n+\tfprintf (stderr, \"\\tfile position: %ld\\n\", ftell (infile));\n+\tabort ();\n+      }\n+\n+  c = read_skip_spaces (infile);\n+  if (c != ')')\n+    fatal_expected_char (infile, ')', c);\n+\n+  return return_rtx;\n+}"}, {"sha": "0c84d752e3e7ca759b62fb74ba06ddc07e7de3c6", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 614, "changes": 616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f40f9f7c68aadde4d52b4fc04d016b72451d238/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=0f40f9f7c68aadde4d52b4fc04d016b72451d238", "patch": "@@ -1,5 +1,5 @@\n-/* Allocate and read RTL for GNU C Compiler.\n-   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000\n+/* RTL utility routines.\n+   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001\n    Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -19,19 +19,11 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"real.h\"\n-#include \"bitmap.h\"\n #include \"ggc.h\"\n-#include \"obstack.h\"\n-#include \"toplev.h\"\n-#include \"hashtab.h\"\n-\n-#define\tobstack_chunk_alloc\txmalloc\n-#define\tobstack_chunk_free\tfree\n \n \f\n /* Calculate the format for CONST_DOUBLE.  This depends on the relative\n@@ -292,17 +284,6 @@ const char * const reg_note_name[] =\n   \"REG_NON_LOCAL_GOTO\"\n };\n \n-static htab_t md_constants;\n-\n-static void fatal_with_file_and_line PARAMS ((FILE *, const char *, ...))\n-  ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n-static void fatal_expected_char PARAMS ((FILE *, int, int)) ATTRIBUTE_NORETURN;\n-static void read_name\t\tPARAMS ((char *, FILE *));\n-static char *read_string\tPARAMS ((struct obstack *, FILE *));\n-static unsigned def_hash PARAMS ((const void *));\n-static int def_name_eq_p PARAMS ((const void *, const void *));\n-static void read_constants PARAMS ((FILE *infile, char *tmp_char));\n-\n \f\n /* Allocate an rtx vector of N elements.\n    Store the length, and initialize all elements to zero.  */\n@@ -690,599 +671,6 @@ rtx_equal_p (x, y)\n   return 1;\n }\n \f\n-/* Subroutines of read_rtx.  */\n-\n-/* The current line number for the file.  */\n-int read_rtx_lineno = 1;\n-\n-/* The filename for aborting with file and line.  */\n-const char *read_rtx_filename = \"<unknown>\";\n-\n-static void\n-fatal_with_file_and_line VPARAMS ((FILE *infile, const char *msg, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  FILE *infile;\n-  const char *msg;\n-#endif\n-  va_list ap;\n-  char context[64];\n-  size_t i;\n-  int c;\n-\n-  VA_START (ap, msg);\n-\n-#ifndef ANSI_PROTOTYPES\n-  infile = va_arg (ap, FILE *);\n-  msg = va_arg (ap, const char *);\n-#endif\n-\n-  fprintf (stderr, \"%s:%d: \", read_rtx_filename, read_rtx_lineno);\n-  vfprintf (stderr, msg, ap);\n-  putc ('\\n', stderr);\n-\n-  /* Gather some following context.  */\n-  for (i = 0; i < sizeof(context)-1; ++i)\n-    {\n-      c = getc (infile);\n-      if (c == EOF)\n-\tbreak;\n-      if (c == '\\r' || c == '\\n')\n-\tbreak;\n-      context[i] = c;\n-    }\n-  context[i] = '\\0';\n-\n-  fprintf (stderr, \"%s:%d: following context is `%s'\\n\",\n-\t   read_rtx_filename, read_rtx_lineno, context);\n-\n-  va_end (ap);\n-  exit (1);\n-}\n-\n-/* Dump code after printing a message.  Used when read_rtx finds\n-   invalid data.  */\n-\n-static void\n-fatal_expected_char (infile, expected_c, actual_c)\n-     FILE *infile;\n-     int expected_c, actual_c;\n-{\n-  fatal_with_file_and_line (infile, \"expected character `%c', found `%c'\",\n-\t\t\t    expected_c, actual_c);\n-}\n-\n-/* Read chars from INFILE until a non-whitespace char\n-   and return that.  Comments, both Lisp style and C style,\n-   are treated as whitespace.\n-   Tools such as genflags use this function.  */\n-\n-int\n-read_skip_spaces (infile)\n-     FILE *infile;\n-{\n-  register int c;\n-  while (1)\n-    {\n-      c = getc (infile);\n-      switch (c)\n-\t{\n-\tcase '\\n':\n-\t  read_rtx_lineno++;\n-\t  break;\n-\n-\tcase ' ': case '\\t': case '\\f': case '\\r':\n-\t  break;\n-\n-\tcase ';':\n-\t  do\n-\t    c = getc (infile);\n-\t  while (c != '\\n' && c != EOF);\n-\t  read_rtx_lineno++;\n-\t  break;\n-\n-\tcase '/':\n-\t  {\n-\t    register int prevc;\n-\t    c = getc (infile);\n-\t    if (c != '*')\n-\t      fatal_expected_char (infile, '*', c);\n-\n-\t    prevc = 0;\n-\t    while ((c = getc (infile)) && c != EOF)\n-\t      {\n-\t\tif (c == '\\n')\n-\t\t   read_rtx_lineno++;\n-\t        else if (prevc == '*' && c == '/')\n-\t\t  break;\n-\t        prevc = c;\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  return c;\n-\t}\n-    }\n-}\n-\n-/* Read an rtx code name into the buffer STR[].\n-   It is terminated by any of the punctuation chars of rtx printed syntax.  */\n-\n-static void\n-read_name (str, infile)\n-     char *str;\n-     FILE *infile;\n-{\n-  register char *p;\n-  register int c;\n-\n-  c = read_skip_spaces(infile);\n-\n-  p = str;\n-  while (1)\n-    {\n-      if (c == ' ' || c == '\\n' || c == '\\t' || c == '\\f')\n-\tbreak;\n-      if (c == ':' || c == ')' || c == ']' || c == '\"' || c == '/'\n-\t  || c == '(' || c == '[')\n-\t{\n-\t  ungetc (c, infile);\n-\t  break;\n-\t}\n-      *p++ = c;\n-      c = getc (infile);\n-    }\n-  if (p == str)\n-    fatal_with_file_and_line (infile, \"missing name or number\");\n-  if (c == '\\n')\n-    read_rtx_lineno++;\n-\n-  *p = 0;\n-\n-  if (md_constants)\n-    {\n-      /* Do constant expansion.  */\n-      struct md_constant *def;\n-\n-      p = str;\n-      do\n-\t{\n-\t  struct md_constant tmp_def;\n-\n-\t  tmp_def.name = p;\n-\t  def = htab_find (md_constants, &tmp_def);\n-\t  if (def)\n-\t    p = def->value;\n-\t} while (def);\n-      if (p != str)\n-\tstrcpy (str, p);\n-    }\n-}\n-\n-/* Read a double-quoted string onto the obstack.  */\n-\n-static char *\n-read_string (ob, infile)\n-     struct obstack *ob;\n-     FILE *infile;\n-{\n-  char *stringbuf;\n-  int saw_paren = 0;\n-  int c;\n-\n-  c = read_skip_spaces (infile);\n-  if (c == '(')\n-    {\n-      saw_paren = 1;\n-      c = read_skip_spaces (infile);\n-    }\n-  if (c != '\"')\n-    fatal_expected_char (infile, '\"', c);\n-\n-  while (1)\n-    {\n-      c = getc (infile); /* Read the string  */\n-      if (c == '\\n')\n-\tread_rtx_lineno++;\n-      else if (c == '\\\\')\n-\t{\n-\t  c = getc (infile);\t/* Read the string  */\n-\t  /* \\; makes stuff for a C string constant containing\n-\t     newline and tab.  */\n-\t  if (c == ';')\n-\t    {\n-\t      obstack_grow (ob, \"\\\\n\\\\t\", 4);\n-\t      continue;\n-\t    }\n-\t  if (c == '\\n')\n-\t    read_rtx_lineno++;\n-\t}\n-      else if (c == '\"')\n-\tbreak;\n-\n-      obstack_1grow (ob, c);\n-    }\n-\n-  obstack_1grow (ob, 0);\n-  stringbuf = (char *) obstack_finish (ob);\n-\n-  if (saw_paren)\n-    {\n-      c = read_skip_spaces (infile);\n-      if (c != ')')\n-\tfatal_expected_char (infile, ')', c);\n-    }\n-\n-  return stringbuf;\n-}\n-\f\n-/* Provide a version of a function to read a long long if the system does\n-   not provide one.  */\n-#if HOST_BITS_PER_WIDE_INT > HOST_BITS_PER_LONG && !defined(HAVE_ATOLL) && !defined(HAVE_ATOQ)\n-HOST_WIDE_INT\n-atoll(p)\n-    const char *p;\n-{\n-  int neg = 0;\n-  HOST_WIDE_INT tmp_wide;\n-\n-  while (ISSPACE(*p))\n-    p++;\n-  if (*p == '-')\n-    neg = 1, p++;\n-  else if (*p == '+')\n-    p++;\n-\n-  tmp_wide = 0;\n-  while (ISDIGIT(*p))\n-    {\n-      HOST_WIDE_INT new_wide = tmp_wide*10 + (*p - '0');\n-      if (new_wide < tmp_wide)\n-\t{\n-\t  /* Return INT_MAX equiv on overflow.  */\n-\t  tmp_wide = (~(unsigned HOST_WIDE_INT)0) >> 1;\n-\t  break;\n-\t}\n-      tmp_wide = new_wide;\n-      p++;\n-    }\n-\n-  if (neg)\n-    tmp_wide = -tmp_wide;\n-  return tmp_wide;\n-}\n-#endif\n-\n-/* Given a constant definition, return a hash code for its name.  */\n-static unsigned\n-def_hash (def)\n-     const void *def;\n-{\n-  unsigned result, i;\n-  const char *string = ((const struct md_constant *)def)->name;\n-\n-  for (result = i = 0;*string++ != '\\0'; i++)\n-    result += ((unsigned char) *string << (i % CHAR_BIT));\n-  return result;\n-}\n-\n-/* Given two constant definitions, return true if they have the same name.  */\n-static int\n-def_name_eq_p (def1, def2)\n-     const void *def1, *def2;\n-{\n-  return ! strcmp (((const struct md_constant *)def1)->name,\n-\t\t   ((const struct md_constant *)def2)->name);\n-}\n-\n-/* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer suitable\n-   to read a name or number into.  Process a define_constants directive,\n-   starting with the optional space after the \"define_constants\".  */\n-static void\n-read_constants (infile, tmp_char)\n-     FILE *infile;\n-     char *tmp_char;\n-{\n-  int c;\n-  htab_t defs;\n-\n-  c = read_skip_spaces (infile);\n-  if (c != '[')\n-    fatal_expected_char (infile, '[', c);\n-  defs = md_constants;\n-  if (! defs)\n-    defs = htab_create (32, def_hash, def_name_eq_p, (htab_del) 0);\n-  /* Disable constant expansion during definition processing.  */\n-  md_constants = 0;\n-  while ( (c = read_skip_spaces (infile)) != ']')\n-    {\n-      struct md_constant *def;\n-      void **entry_ptr;\n-\n-      if (c != '(')\n-\tfatal_expected_char (infile, '(', c);\n-      def = xmalloc (sizeof (struct md_constant));\n-      def->name = tmp_char;\n-      read_name (tmp_char, infile);\n-      entry_ptr = htab_find_slot (defs, def, TRUE);\n-      if (! *entry_ptr)\n-\tdef->name = xstrdup (tmp_char);\n-      c = read_skip_spaces (infile);\n-      ungetc (c, infile);\n-      read_name (tmp_char, infile);\n-      if (! *entry_ptr)\n-\t{\n-\t  def->value = xstrdup (tmp_char);\n-\t  *entry_ptr = def;\n-\t}\n-      else\n-\t{\n-\t  def = *entry_ptr;\n-\t  if (strcmp (def->value, tmp_char))\n-\t    fatal_with_file_and_line (infile,\n-\t\t\t\t      \"redefinition of %s, was %s, now %s\",\n-\t\t\t\t      def->name, def->value, tmp_char);\n-\t}\n-      c = read_skip_spaces (infile);\n-      if (c != ')')\n-\tfatal_expected_char (infile, ')', c);\n-    }\n-  md_constants = defs;\n-  c = read_skip_spaces (infile);\n-  if (c != ')')\n-    fatal_expected_char (infile, ')', c);\n-}\n-\n-/* For every constant definition, call CALLBACK with two arguments:\n-   a pointer a pointer to the constant definition and INFO.\n-   Stops when CALLBACK returns zero.  */\n-void\n-traverse_md_constants (callback, info)\n-     htab_trav callback;\n-     void *info;\n-{\n-  if (md_constants)\n-    htab_traverse (md_constants, callback, info);\n-}\n-\n-/* Read an rtx in printed representation from INFILE\n-   and return an actual rtx in core constructed accordingly.\n-   read_rtx is not used in the compiler proper, but rather in\n-   the utilities gen*.c that construct C code from machine descriptions.  */\n-\n-rtx\n-read_rtx (infile)\n-     FILE *infile;\n-{\n-  register int i, j;\n-  RTX_CODE tmp_code;\n-  register const char *format_ptr;\n-  /* tmp_char is a buffer used for reading decimal integers\n-     and names of rtx types and machine modes.\n-     Therefore, 256 must be enough.  */\n-  char tmp_char[256];\n-  rtx return_rtx;\n-  register int c;\n-  int tmp_int;\n-  HOST_WIDE_INT tmp_wide;\n-\n-  /* Obstack used for allocating RTL objects.  */\n-  static struct obstack rtl_obstack;\n-  static int initialized;\n-\n-  /* Linked list structure for making RTXs: */\n-  struct rtx_list\n-    {\n-      struct rtx_list *next;\n-      rtx value;\t\t/* Value of this node.  */\n-    };\n-\n-  if (!initialized) {\n-    _obstack_begin (&rtl_obstack,0, 0,\n-\t\t    (void *(*) PARAMS ((long))) xmalloc,\n-\t\t    (void (*) PARAMS ((void *))) free);\n-    initialized = 1;\n-  }\n-\n-again:\n-  c = read_skip_spaces (infile); /* Should be open paren.  */\n-  if (c != '(')\n-    fatal_expected_char (infile, '(', c);\n-\n-  read_name (tmp_char, infile);\n-\n-  tmp_code = UNKNOWN;\n-\n-  if (! strcmp (tmp_char, \"define_constants\"))\n-    {\n-      read_constants (infile, tmp_char);\n-      goto again;\n-    }\n-  for (i = 0; i < NUM_RTX_CODE; i++)\n-    if (! strcmp (tmp_char, GET_RTX_NAME (i)))\n-      {\n-\ttmp_code = (RTX_CODE) i;\t/* get value for name */\n-\tbreak;\n-      }\n-\n-  if (tmp_code == UNKNOWN)\n-    fatal_with_file_and_line (infile, \"unknown rtx code `%s'\", tmp_char);\n-\n-  /* (NIL) stands for an expression that isn't there.  */\n-  if (tmp_code == NIL)\n-    {\n-      /* Discard the closeparen.  */\n-      while ((c = getc (infile)) && c != ')')\n-\t;\n-\n-      return 0;\n-    }\n-\n-  /* If we end up with an insn expression then we free this space below.  */\n-  return_rtx = rtx_alloc (tmp_code);\n-  format_ptr = GET_RTX_FORMAT (GET_CODE (return_rtx));\n-\n-  /* If what follows is `: mode ', read it and\n-     store the mode in the rtx.  */\n-\n-  i = read_skip_spaces (infile);\n-  if (i == ':')\n-    {\n-      read_name (tmp_char, infile);\n-      for (j = 0; j < NUM_MACHINE_MODES; j++)\n-\tif (! strcmp (GET_MODE_NAME (j), tmp_char))\n-\t  break;\n-\n-      if (j == MAX_MACHINE_MODE)\n-\tfatal_with_file_and_line (infile, \"unknown mode `%s'\", tmp_char);\n-\n-      PUT_MODE (return_rtx, (enum machine_mode) j);\n-    }\n-  else\n-    ungetc (i, infile);\n-\n-  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (return_rtx)); i++)\n-    switch (*format_ptr++)\n-      {\n-\t/* 0 means a field for internal use only.\n-\t   Don't expect it to be present in the input.  */\n-      case '0':\n-\tbreak;\n-\n-      case 'e':\n-      case 'u':\n-\tXEXP (return_rtx, i) = read_rtx (infile);\n-\tbreak;\n-\n-      case 'V':\n-\t/* 'V' is an optional vector: if a closeparen follows,\n-\t   just store NULL for this element.  */\n-\tc = read_skip_spaces (infile);\n-\tungetc (c, infile);\n-\tif (c == ')')\n-\t  {\n-\t    XVEC (return_rtx, i) = 0;\n-\t    break;\n- \t  }\n-\t/* Now process the vector.  */\n-\n-      case 'E':\n-\t{\n-\t  /* Obstack to store scratch vector in.  */\n-\t  struct obstack vector_stack;\n-\t  int list_counter = 0;\n-\t  rtvec return_vec = NULL_RTVEC;\n-\n-\t  c = read_skip_spaces (infile);\n-\t  if (c != '[')\n-\t    fatal_expected_char (infile, '[', c);\n-\n-\t  /* add expressions to a list, while keeping a count */\n-\t  obstack_init (&vector_stack);\n-\t  while ((c = read_skip_spaces (infile)) && c != ']')\n-\t    {\n-\t      ungetc (c, infile);\n-\t      list_counter++;\n-\t      obstack_ptr_grow (&vector_stack, (PTR) read_rtx (infile));\n-\t    }\n-\t  if (list_counter > 0)\n-\t    {\n-\t      return_vec = rtvec_alloc (list_counter);\n-\t      memcpy (&return_vec->elem[0], obstack_finish (&vector_stack),\n-\t\t      list_counter * sizeof (rtx));\n-\t    }\n-\t  XVEC (return_rtx, i) = return_vec;\n-\t  obstack_free (&vector_stack, NULL);\n-\t  /* close bracket gotten */\n-\t}\n-\tbreak;\n-\n-      case 'S':\n-\t/* 'S' is an optional string: if a closeparen follows,\n-\t   just store NULL for this element.  */\n-\tc = read_skip_spaces (infile);\n-\tungetc (c, infile);\n-\tif (c == ')')\n-\t  {\n-\t    XSTR (return_rtx, i) = 0;\n-\t    break;\n-\t  }\n-\n-      case 's':\n-\t{\n-\t  char *stringbuf;\n-\n-\t  stringbuf = read_string (&rtl_obstack, infile);\n-\n-\t  /* For insn patterns, we want to provide a default name\n-\t     based on the file and line, like \"*foo.md:12\", if the\n-\t     given name is blank.  These are only for define_insn and\n-\t     define_insn_and_split, to aid debugging.  */\n-\t  if (*stringbuf == '\\0'\n-\t      && i == 0\n-\t      && (GET_CODE (return_rtx) == DEFINE_INSN\n-\t\t  || GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n-\t    {\n-\t      char line_name[20];\n-\t      const char *fn = (read_rtx_filename ? read_rtx_filename : \"rtx\");\n-\t      const char *slash;\n-\t      for (slash = fn; *slash; slash ++)\n-\t\tif (*slash == '/' || *slash == '\\\\' || *slash == ':')\n-\t\t  fn = slash + 1;\n-\t      obstack_1grow (&rtl_obstack, '*');\n-\t      obstack_grow (&rtl_obstack, fn, strlen (fn));\n-\t      sprintf (line_name, \":%d\", read_rtx_lineno);\n-\t      obstack_grow (&rtl_obstack, line_name, strlen (line_name)+1);\n-\t      stringbuf = (char *) obstack_finish (&rtl_obstack);\n-\t    }\n-\n-\t  XSTR (return_rtx, i) = stringbuf;\n-\t}\n-\tbreak;\n-\n-      case 'w':\n-\tread_name (tmp_char, infile);\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\ttmp_wide = atoi (tmp_char);\n-#else\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n-\ttmp_wide = atol (tmp_char);\n-#else\n-\t/* Prefer atoll over atoq, since the former is in the ISO C99 standard.\n-\t   But prefer not to use our hand-rolled function above either.  */\n-#if defined(HAVE_ATOLL) || !defined(HAVE_ATOQ)\n-\ttmp_wide = atoll (tmp_char);\n-#else\n-\ttmp_wide = atoq (tmp_char);\n-#endif\n-#endif\n-#endif\n-\tXWINT (return_rtx, i) = tmp_wide;\n-\tbreak;\n-\n-      case 'i':\n-      case 'n':\n-\tread_name (tmp_char, infile);\n-\ttmp_int = atoi (tmp_char);\n-\tXINT (return_rtx, i) = tmp_int;\n-\tbreak;\n-\n-      default:\n-\tfprintf (stderr,\n-\t\t \"switch format wrong in rtl.read_rtx(). format was: %c.\\n\",\n-\t\t format_ptr[-1]);\n-\tfprintf (stderr, \"\\tfile position: %ld\\n\", ftell (infile));\n-\tabort ();\n-      }\n-\n-  c = read_skip_spaces (infile);\n-  if (c != ')')\n-    fatal_expected_char (infile, ')', c);\n-\n-  return return_rtx;\n-}\n-\n #if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007)\n void\n rtl_check_failed_bounds (r, n, file, line, func)"}]}