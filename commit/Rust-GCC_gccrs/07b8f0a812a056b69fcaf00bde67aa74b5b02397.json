{"sha": "07b8f0a812a056b69fcaf00bde67aa74b5b02397", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiOGYwYTgxMmEwNTZiNjlmY2FmMDBiZGU2N2FhNzRiNWIwMjM5Nw==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-09-02T14:29:37Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-09-02T14:29:37Z"}, "message": "target.def (class_likely_spilled_p): New hook.\n\n\t* target.def (class_likely_spilled_p): New hook.\n\t* doc/tm.texi.in (TARGET_CLASS_LIKELY_SPILLED_P): Document.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_class_likely_spilled_p): New function.\n\t* targhooks.h (default_class_likely_spilled_p): Declare.\n\t* regs.h (CLASS_LIKELY_SPILLED_P): Remove.\n\t* combine.c: (cant_combine_insn_p, likely_spilled_retval_p): Use\n\tTARGET_CLASS_LIKELY_SPILLED_P target hook. Use HARD_REGISTER_P macro.\n\tUse fixed_reg_set instead of fixed_regs.\n\t* cse.c (hash_rtx_cb): Use TARGET_CLASS_LIKELY_SPILLED_P target hook.\n\t* calls.c (avoid_likely_spilled_reg): Ditto.\n\t* ira-conflicts.c: (ira_build_conflicts): Ditto.\n\t* ira.c (update_equiv_regs): Ditto.\n\t* mode-switching.c (create_pre_exit): Ditto.\n\t* regmove.c (find_matches): Ditto.\n\t(regclass_compatible_p): Use TARGET_CLASS_LIKELY_SPILLED_P target\n\thook.\n\t* reload.c (SMALL_REGISTER_CLASS_P): Remove macro.\n\t(small_register_class_p): New inline function.\n\t(push_secondary_reload, find_reusable_reload, find_reloads): Use\n\tsmall_register_class_p instead of SMALL_REGISTER_CLASS_P.\n\n\t* config/i386/i386.h (CLASS_LIKELY_SPILLED_P): Remove.\n\t* config/i386/i386.c (ix86_class_likely_spilled_p): New.\n\t(TARGET_CLASS_LIKELY_SPILLED_P): Define.\n\nFrom-SVN: r163779", "tree": {"sha": "8800ae6420f6689c40bea9995085ad6bf47c0f65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8800ae6420f6689c40bea9995085ad6bf47c0f65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07b8f0a812a056b69fcaf00bde67aa74b5b02397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b8f0a812a056b69fcaf00bde67aa74b5b02397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b8f0a812a056b69fcaf00bde67aa74b5b02397", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b8f0a812a056b69fcaf00bde67aa74b5b02397/comments", "author": null, "committer": null, "parents": [{"sha": "844022b747eebc8f02c0e7b4165cc10b7521432e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844022b747eebc8f02c0e7b4165cc10b7521432e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/844022b747eebc8f02c0e7b4165cc10b7521432e"}], "stats": {"total": 212, "additions": 148, "deletions": 64}, "files": [{"sha": "8382f2b1f6a8343f751fcf00a0d13273b0349f82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -1,3 +1,31 @@\n+2010-09-02  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* target.def (class_likely_spilled_p): New hook.\n+\t* doc/tm.texi.in (TARGET_CLASS_LIKELY_SPILLED_P): Document.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_class_likely_spilled_p): New function.\n+\t* targhooks.h (default_class_likely_spilled_p): Declare.\n+\t* regs.h (CLASS_LIKELY_SPILLED_P): Remove.\n+\t* combine.c: (cant_combine_insn_p, likely_spilled_retval_p): Use\n+\tTARGET_CLASS_LIKELY_SPILLED_P target hook. Use HARD_REGISTER_P macro.\n+\tUse fixed_reg_set instead of fixed_regs.\n+\t* cse.c (hash_rtx_cb): Use TARGET_CLASS_LIKELY_SPILLED_P target hook.\n+\t* calls.c (avoid_likely_spilled_reg): Ditto.\n+\t* ira-conflicts.c: (ira_build_conflicts): Ditto.\n+\t* ira.c (update_equiv_regs): Ditto.\n+\t* mode-switching.c (create_pre_exit): Ditto.\n+\t* regmove.c (find_matches): Ditto.\n+\t(regclass_compatible_p): Use TARGET_CLASS_LIKELY_SPILLED_P target\n+\thook.\n+\t* reload.c (SMALL_REGISTER_CLASS_P): Remove macro.\n+\t(small_register_class_p): New inline function.\n+\t(push_secondary_reload, find_reusable_reload, find_reloads): Use\n+\tsmall_register_class_p instead of SMALL_REGISTER_CLASS_P.\n+\n+\t* config/i386/i386.h (CLASS_LIKELY_SPILLED_P): Remove.\n+\t* config/i386/i386.c (ix86_class_likely_spilled_p): New.\n+\t(TARGET_CLASS_LIKELY_SPILLED_P): Define.\n+\n 2010-09-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/44937"}, {"sha": "388883137be27c1f059773b08b68bbe70c9a54e3", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -1900,7 +1900,7 @@ avoid_likely_spilled_reg (rtx x)\n \n   if (REG_P (x)\n       && HARD_REGISTER_P (x)\n-      && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (REGNO (x))))\n+      && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (x))))\n     {\n       /* Make sure that we generate a REG rather than a CONCAT.\n \t Moves into CONCATs can need nontrivial instructions,"}, {"sha": "4c9495808b9a0fe1660760aeafeffb4e6f725bf7", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -2137,12 +2137,12 @@ cant_combine_insn_p (rtx insn)\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n   if (REG_P (src) && REG_P (dest)\n-      && ((REGNO (src) < FIRST_PSEUDO_REGISTER\n-\t   && ! fixed_regs[REGNO (src)]\n-\t   && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (REGNO (src))))\n-\t  || (REGNO (dest) < FIRST_PSEUDO_REGISTER\n-\t      && ! fixed_regs[REGNO (dest)]\n-\t      && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (REGNO (dest))))))\n+      && ((HARD_REGISTER_P (src)\n+\t   && ! TEST_HARD_REG_BIT (fixed_reg_set, REGNO (src))\n+\t   && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (src))))\n+\t  || (HARD_REGISTER_P (dest)\n+\t      && ! TEST_HARD_REG_BIT (fixed_reg_set, REGNO (dest))\n+\t      && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (dest))))))\n     return 1;\n \n   return 0;\n@@ -2223,7 +2223,7 @@ likely_spilled_retval_p (rtx insn)\n   do\n     {\n       if ((mask & 1 << nregs)\n-\t  && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (regno + nregs)))\n+\t  && targetm.class_likely_spilled_p (REGNO_REG_CLASS (regno + nregs)))\n \treturn 1;\n     } while (nregs--);\n   return 0;"}, {"sha": "0ff29934933d0b1eea9136b2130235e17c5e04f9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -26218,6 +26218,32 @@ ix86_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n   return NO_REGS;\n }\n \n+/* Implement TARGET_CLASS_LIKELY_SPILLED_P.  */\n+\n+static bool\n+ix86_class_likely_spilled_p (reg_class_t rclass)\n+{\n+  switch (rclass)\n+    {\n+      case AREG:\n+      case DREG:\n+      case CREG:\n+      case BREG:\n+      case AD_REGS:\n+      case SIREG:\n+      case DIREG:\n+      case SSE_FIRST_REG:\n+      case FP_TOP_REG:\n+      case FP_SECOND_REG:\n+\treturn true;\n+\n+      default:\n+\tbreak;\n+    }\n+\n+  return false;\n+}\n+\n /* If we are copying between general and FP registers, we need a memory\n    location. The same is true for SSE and MMX registers.\n \n@@ -31736,6 +31762,9 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD ix86_secondary_reload\n \n+#undef TARGET_CLASS_LIKELY_SPILLED_P\n+#define TARGET_CLASS_LIKELY_SPILLED_P ix86_class_likely_spilled_p\n+\n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n   ix86_builtin_vectorization_cost"}, {"sha": "cbf990a4e3726574ec0225cffd01c7a1b41960bf", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -1440,34 +1440,6 @@ enum reg_class\n   : (((((MODE) == XFmode ? 12 : GET_MODE_SIZE (MODE)))\t\t\t\\\n       + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* A C expression whose value is nonzero if pseudos that have been\n-   assigned to registers of class CLASS would likely be spilled\n-   because registers of CLASS are needed for spill registers.\n-\n-   The default value of this macro returns 1 if CLASS has exactly one\n-   register and zero otherwise.  On most machines, this default\n-   should be used.  Only define this macro to some other expression\n-   if pseudo allocated by `local-alloc.c' end up in memory because\n-   their hard registers were needed for spill registers.  If this\n-   macro returns nonzero for those classes, those pseudos will only\n-   be allocated by `global.c', which knows how to reallocate the\n-   pseudo to another register.  If there would not be another\n-   register available for reallocation, you should not change the\n-   definition of this macro since the only effect of such a\n-   definition would be to slow down register allocation.  */\n-\n-#define CLASS_LIKELY_SPILLED_P(CLASS)\t\t\t\t\t\\\n-  (((CLASS) == AREG)\t\t\t\t\t\t\t\\\n-   || ((CLASS) == DREG)\t\t\t\t\t\t\t\\\n-   || ((CLASS) == CREG)\t\t\t\t\t\t\t\\\n-   || ((CLASS) == BREG)\t\t\t\t\t\t\t\\\n-   || ((CLASS) == AD_REGS)\t\t\t\t\t\t\\\n-   || ((CLASS) == SIREG)\t\t\t\t\t\t\\\n-   || ((CLASS) == DIREG)\t\t\t\t\t\t\\\n-   || ((CLASS) == SSE_FIRST_REG)\t\t\t\t\t\\\n-   || ((CLASS) == FP_TOP_REG)\t\t\t\t\t\t\\\n-   || ((CLASS) == FP_SECOND_REG))\n-\n /* Return a class of registers that cannot change FROM mode to TO mode.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\"}, {"sha": "6857d3fad1a2e2d94be7e6af5e8668aeb4b2002e", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -2286,7 +2286,7 @@ hash_rtx_cb (const_rtx x, enum machine_mode mode,\n \n \t       On all machines, we can't record any global registers.\n \t       Nor should we record any register that is in a small\n-\t       class, as defined by CLASS_LIKELY_SPILLED_P.  */\n+\t       class, as defined by TARGET_CLASS_LIKELY_SPILLED_P.  */\n \t    bool record;\n \n \t    if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -2305,7 +2305,7 @@ hash_rtx_cb (const_rtx x, enum machine_mode mode,\n \t      record = true;\n \t    else if (targetm.small_register_classes_for_mode_p (GET_MODE (x)))\n \t      record = false;\n-\t    else if (CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (regno)))\n+\t    else if (targetm.class_likely_spilled_p (REGNO_REG_CLASS (regno)))\n \t      record = false;\n \t    else\n \t      record = true;"}, {"sha": "5954ea38c24e20ed2c416a92704f2e71d923a199", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -2858,6 +2858,24 @@ Do not define this macro if you do not define\n is @code{BITS_PER_WORD} bits wide is correct for your machine.\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_CLASS_LIKELY_SPILLED_P (reg_class_t @var{rclass})\n+A target hook which returns @code{true} if pseudos that have been assigned\n+to registers of class @var{rclass} would likely be spilled because\n+registers of @var{rclass} are needed for spill registers.\n+\n+The default version of this target hook returns @code{true} if @var{rclass}\n+has exactly one register and @code{false} otherwise.  On most machines, this\n+default should be used.  Only use this target hook to some other expression\n+if pseudos allocated by @file{local-alloc.c} end up in memory because their\n+hard registers were needed for spill registers.  If this target hook returns\n+@code{false} for those classes, those pseudos will only be allocated by\n+@file{global.c}, which knows how to reallocate the pseudo to another\n+register.  If there would not be another register available for reallocation,\n+you should not change the implementation of this target hook since\n+the only effect of such implementation would be to slow down register\n+allocation.\n+@end deftypefn\n+\n @defmac CLASS_LIKELY_SPILLED_P (@var{class})\n A C expression whose value is nonzero if pseudos that have been assigned\n to registers of class @var{class} would likely be spilled because"}, {"sha": "24f5c1b3a761e585bfae9896de15c07fc13402eb", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -2858,6 +2858,24 @@ Do not define this macro if you do not define\n is @code{BITS_PER_WORD} bits wide is correct for your machine.\n @end defmac\n \n+@hook TARGET_CLASS_LIKELY_SPILLED_P\n+A target hook which returns @code{true} if pseudos that have been assigned\n+to registers of class @var{rclass} would likely be spilled because\n+registers of @var{rclass} are needed for spill registers.\n+\n+The default version of this target hook returns @code{true} if @var{rclass}\n+has exactly one register and @code{false} otherwise.  On most machines, this\n+default should be used.  Only use this target hook to some other expression\n+if pseudos allocated by @file{local-alloc.c} end up in memory because their\n+hard registers were needed for spill registers.  If this target hook returns\n+@code{false} for those classes, those pseudos will only be allocated by\n+@file{global.c}, which knows how to reallocate the pseudo to another\n+register.  If there would not be another register available for reallocation,\n+you should not change the implementation of this target hook since\n+the only effect of such implementation would be to slow down register\n+allocation.\n+@end deftypefn\n+\n @defmac CLASS_LIKELY_SPILLED_P (@var{class})\n A C expression whose value is nonzero if pseudos that have been assigned\n to registers of class @var{class} would likely be spilled because"}, {"sha": "be79523359b4c268b88a12bcf89019a77e0328a3", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -864,7 +864,8 @@ ira_build_conflicts (void)\n \t  ira_free (conflicts);\n \t}\n     }\n-  if (! CLASS_LIKELY_SPILLED_P (base_reg_class (VOIDmode, ADDRESS, SCRATCH)))\n+  if (! targetm.class_likely_spilled_p (base_reg_class (VOIDmode, ADDRESS,\n+\t\t\t\t\t\t\tSCRATCH)))\n     CLEAR_HARD_REG_SET (temp_hard_reg_set);\n   else\n     {"}, {"sha": "71841d9cbd6032b8e351134ac2e7c92fbc578793", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -2363,7 +2363,7 @@ update_equiv_regs (void)\n \t  if (!REG_P (dest)\n \t      || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n \t      || reg_equiv[regno].init_insns == const0_rtx\n-\t      || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n+\t      || (targetm.class_likely_spilled_p (reg_preferred_class (regno))\n \t\t  && MEM_P (src) && ! reg_equiv[regno].is_arg_equivalence))\n \t    {\n \t      /* This might be setting a SUBREG of a pseudo, a pseudo that is"}, {"sha": "88dca023df91783deca59b9c73e976241adf8db5", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -387,7 +387,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t    gcc_assert (!nregs\n \t\t\t|| forced_late_switch\n \t\t\t|| short_block\n-\t\t\t|| !(CLASS_LIKELY_SPILLED_P\n+\t\t\t|| !(targetm.class_likely_spilled_p\n \t\t\t     (REGNO_REG_CLASS (ret_start)))\n \t\t\t|| (nregs\n \t\t\t    != hard_regno_nregs[ret_start][GET_MODE (ret_reg)])"}, {"sha": "f869403c7ab59a0d0423b64a9cc26e0c54c8ee64", "filename": "gcc/regmove.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -73,13 +73,13 @@ static int fixup_match_2 (rtx, rtx, rtx, rtx);\n /* Return nonzero if registers with CLASS1 and CLASS2 can be merged without\n    causing too much register allocation problems.  */\n static int\n-regclass_compatible_p (enum reg_class class0, enum reg_class class1)\n+regclass_compatible_p (reg_class_t class0, reg_class_t class1)\n {\n   return (class0 == class1\n \t  || (reg_class_subset_p (class0, class1)\n-\t      && ! CLASS_LIKELY_SPILLED_P (class0))\n+\t      && ! targetm.class_likely_spilled_p (class0))\n \t  || (reg_class_subset_p (class1, class0)\n-\t      && ! CLASS_LIKELY_SPILLED_P (class1)));\n+\t      && ! targetm.class_likely_spilled_p (class1)));\n }\n \n \f\n@@ -1337,7 +1337,7 @@ find_matches (rtx insn, struct match *matchp)\n \t  case 'j': case 'k': case 'l': case 'p': case 'q': case 't': case 'u':\n \t  case 'v': case 'w': case 'x': case 'y': case 'z': case 'A': case 'B':\n \t  case 'C': case 'D': case 'W': case 'Y': case 'Z':\n-\t    if (CLASS_LIKELY_SPILLED_P (REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p) ))\n+\t    if (targetm.class_likely_spilled_p (REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)))\n \t      likely_spilled[op_no] = 1;\n \t    break;\n \t  }"}, {"sha": "88fe9af0eb0d9c4387fadf38200b17151d90bcb8", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -227,12 +227,6 @@ extern int caller_save_needed;\n #define CALLER_SAVE_PROFITABLE(REFS, CALLS)  (4 * (CALLS) < (REFS))\n #endif\n \n-/* On most machines a register class is likely to be spilled if it\n-   only has one register.  */\n-#ifndef CLASS_LIKELY_SPILLED_P\n-#define CLASS_LIKELY_SPILLED_P(CLASS) (reg_class_size[(int) (CLASS)] == 1)\n-#endif\n-\n /* Select a register mode required for caller save of hard regno REGNO.  */\n #ifndef HARD_REGNO_CALLER_SAVE_MODE\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\"}, {"sha": "2df18a1dc59f6b605de5075ff24c9a692802951b", "filename": "gcc/reload.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -121,9 +121,14 @@ a register with any other reload.  */\n \n /* True if C is a non-empty register class that has too few registers\n    to be safely used as a reload target class.  */\n-#define SMALL_REGISTER_CLASS_P(C) \\\n-  (reg_class_size [(C)] == 1 \\\n-   || (reg_class_size [(C)] >= 1 && CLASS_LIKELY_SPILLED_P (C)))\n+\n+static inline bool\n+small_register_class_p (reg_class_t rclass)\n+{\n+  return (reg_class_size [(int) rclass] == 1\n+\t  || (reg_class_size [(int) rclass] >= 1 \n+\t      && targetm.class_likely_spilled_p (rclass)));\n+}\n \n \f\n /* All reloads of the current insn are recorded here.  See reload.h for\n@@ -438,7 +443,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t    || (! in_p && rld[s_reload].secondary_out_reload == t_reload))\n \t&& ((in_p && rld[s_reload].secondary_in_icode == t_icode)\n \t    || (! in_p && rld[s_reload].secondary_out_icode == t_icode))\n-\t&& (SMALL_REGISTER_CLASS_P (rclass)\n+\t&& (small_register_class_p (rclass)\n \t    || targetm.small_register_classes_for_mode_p (VOIDmode))\n \t&& MERGABLE_RELOADS (secondary_type, rld[s_reload].when_needed,\n \t\t\t     opnum, rld[s_reload].opnum))\n@@ -749,7 +754,7 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n \t    || (out != 0 && MATCHES (rld[i].out, out)\n \t\t&& (in == 0 || rld[i].in == 0 || MATCHES (rld[i].in, in))))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n-\t&& (SMALL_REGISTER_CLASS_P (rclass)\n+\t&& (small_register_class_p (rclass)\n \t    || targetm.small_register_classes_for_mode_p (VOIDmode))\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed, opnum, rld[i].opnum))\n       return i;\n@@ -775,7 +780,7 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n \t\t&& GET_RTX_CLASS (GET_CODE (in)) == RTX_AUTOINC\n \t\t&& MATCHES (XEXP (in, 0), rld[i].in)))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n-\t&& (SMALL_REGISTER_CLASS_P (rclass)\n+\t&& (small_register_class_p (rclass)\n \t    || targetm.small_register_classes_for_mode_p (VOIDmode))\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed,\n \t\t\t     opnum, rld[i].opnum))\n@@ -3588,7 +3593,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t      && this_alternative[i] != NO_REGS\n \t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n \t      && reg_class_size [(int) preferred_class[i]] > 0\n-\t      && ! SMALL_REGISTER_CLASS_P (preferred_class[i]))\n+\t      && ! small_register_class_p (preferred_class[i]))\n \t    {\n \t      if (! reg_class_subset_p (this_alternative[i],\n \t\t\t\t\tpreferred_class[i]))\n@@ -3646,7 +3651,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t{\n \t\t  /* If the output is in a non-empty few-regs class,\n \t\t     it's costly to reload it, so reload the input instead.  */\n-\t\t  if (SMALL_REGISTER_CLASS_P (this_alternative[i])\n+\t\t  if (small_register_class_p (this_alternative[i])\n \t\t      && (REG_P (recog_data.operand[j])\n \t\t\t  || GET_CODE (recog_data.operand[j]) == SUBREG))\n \t\t    {"}, {"sha": "adae839930b62e582634710bf6d35cf2e319c59a", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -2401,7 +2401,7 @@ get_rgn_sched_max_insns_priority (void)\n   return rgn_sched_info.sched_max_insns_priority;\n }\n \n-/* Determine if PAT sets a CLASS_LIKELY_SPILLED_P register.  */\n+/* Determine if PAT sets a TARGET_CLASS_LIKELY_SPILLED_P register.  */\n \n static bool\n sets_likely_spilled (rtx pat)\n@@ -2418,8 +2418,8 @@ sets_likely_spilled_1 (rtx x, const_rtx pat, void *data)\n \n   if (GET_CODE (pat) == SET\n       && REG_P (x)\n-      && REGNO (x) < FIRST_PSEUDO_REGISTER\n-      && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (REGNO (x))))\n+      && HARD_REGISTER_P (x)\n+      && targetm.class_likely_spilled_p (REGNO_REG_CLASS (REGNO (x))))\n     *ret = true;\n }\n \n@@ -2448,8 +2448,8 @@ add_branch_dependences (rtx head, rtx tail)\n \n      COND_EXEC insns cannot be moved past a branch (see e.g. PR17808).\n \n-     Insns setting CLASS_LIKELY_SPILLED_P registers (usually return values)\n-     are not moved before reload because we can wind up with register\n+     Insns setting TARGET_CLASS_LIKELY_SPILLED_P registers (usually return\n+     values) are not moved before reload because we can wind up with register\n      allocation failures.  */\n \n   while (tail != head && DEBUG_INSN_P (tail))"}, {"sha": "f11328bc23dbacf614f9d4b21adf4e32baae00fa", "filename": "gcc/target.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -1971,6 +1971,12 @@ DEFHOOK\n   secondary_reload_info *sri),\n  default_secondary_reload)\n \n+DEFHOOK\n+(class_likely_spilled_p,\n+ \"\",\n+ bool, (reg_class_t rclass),\n+ default_class_likely_spilled_p)\n+\n /* This target hook allows the backend to perform additional\n    processing while initializing for variable expansion.  */\n DEFHOOK"}, {"sha": "a0e24c06ae7530355ef577169814f43858585294", "filename": "gcc/targhooks.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -1220,4 +1220,16 @@ default_profile_before_prologue (void)\n #endif\n }\n \n+/* The default implementation of TARGET_CLASS_LIKELY_SPILLED_P.  */\n+\n+bool\n+default_class_likely_spilled_p (reg_class_t rclass)\n+{\n+#ifndef CLASS_LIKELY_SPILLED_P\n+  return (reg_class_size[(int) rclass] == 1);\n+#else\n+  return CLASS_LIKELY_SPILLED_P ((enum reg_class) rclass);\n+#endif\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "4073cbe1d9d0076df27f062ba43c5949189fe561", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b8f0a812a056b69fcaf00bde67aa74b5b02397/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=07b8f0a812a056b69fcaf00bde67aa74b5b02397", "patch": "@@ -152,3 +152,4 @@ extern int default_register_move_cost (enum machine_mode, reg_class_t,\n \t\t\t\t       reg_class_t);\n \n extern bool default_profile_before_prologue (void);\n+extern bool default_class_likely_spilled_p (reg_class_t);"}]}