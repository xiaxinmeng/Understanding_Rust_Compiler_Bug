{"sha": "947c2ce56cf736fb2c48ad3d777e7c352585ce16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3YzJjZTU2Y2Y3MzZmYjJjNDhhZDNkNzc3ZTdjMzUyNTg1Y2UxNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-01-14T07:38:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-01-14T07:38:18Z"}, "message": "[PATCH][PR tree-optimization/69270] Exploit VRP information in DOM\n\n\tPR tree-optimization/69270\n\t* tree-ssa-dom.c (ssa_name_has_boolean_range): New function.\n\t(record_edge_info): Use it.  Convert boolean_{true,false}_node\n\tto the type of op0.\n\n\tPR tree-optimization/69270\n\t* gcc.dg/tree-ssa/pr69270.c: New test.\n\nFrom-SVN: r232361", "tree": {"sha": "e2d540323b0a78d1cf4ebeecd230feb41d5aded8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2d540323b0a78d1cf4ebeecd230feb41d5aded8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/947c2ce56cf736fb2c48ad3d777e7c352585ce16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/947c2ce56cf736fb2c48ad3d777e7c352585ce16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/947c2ce56cf736fb2c48ad3d777e7c352585ce16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/947c2ce56cf736fb2c48ad3d777e7c352585ce16/comments", "author": null, "committer": null, "parents": [{"sha": "19860f48c4f999240d1b14278b6756cb6e614c80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19860f48c4f999240d1b14278b6756cb6e614c80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19860f48c4f999240d1b14278b6756cb6e614c80"}], "stats": {"total": 108, "additions": 95, "deletions": 13}, "files": [{"sha": "40e3dfb638b40f01b71dbcdf4c58a678632d9be5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947c2ce56cf736fb2c48ad3d777e7c352585ce16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947c2ce56cf736fb2c48ad3d777e7c352585ce16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=947c2ce56cf736fb2c48ad3d777e7c352585ce16", "patch": "@@ -1,3 +1,10 @@\n+2016-01-14  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/69270\n+\t* tree-ssa-dom.c (ssa_name_has_boolean_range): New function.\n+\t(record_edge_info): Use it.  Convert boolean_{true,false}_node\n+\tto the type of op0.\n+\n 2016-01-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/66487"}, {"sha": "63976ea51df29a75f93ca4f03876ebdaedb168ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947c2ce56cf736fb2c48ad3d777e7c352585ce16/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947c2ce56cf736fb2c48ad3d777e7c352585ce16/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=947c2ce56cf736fb2c48ad3d777e7c352585ce16", "patch": "@@ -1,3 +1,8 @@\n+2016-01-14  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/69270\n+\t* gcc.dg/tree-ssa/pr69270.c: New test.\n+\n 2016-01-13  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR c/66208"}, {"sha": "529b5212a2751e127626ecba582093b2f4bf208b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr69270.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947c2ce56cf736fb2c48ad3d777e7c352585ce16/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69270.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947c2ce56cf736fb2c48ad3d777e7c352585ce16/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69270.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69270.c?ref=947c2ce56cf736fb2c48ad3d777e7c352585ce16", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsplit-paths -fdump-tree-dom3-details\" } */\n+\n+/* There should be two references to bufferstep that turn into\n+   constants.  */\n+/* { dg-final { scan-tree-dump-times \"Replaced .bufferstep_\\[0-9\\]+. with constant .0.\" 1 \"dom3\"} } */\n+/* { dg-final { scan-tree-dump-times \"Replaced .bufferstep_\\[0-9\\]+. with constant .1.\" 1 \"dom3\"} } */\n+\n+/* And some assignments ought to fold down to constants.  */\n+/* { dg-final { scan-tree-dump-times \"Folded to: _\\[0-9\\]+ = 1;\" 2 \"dom3\"} } */\n+/* { dg-final { scan-tree-dump-times \"Folded to: _\\[0-9\\]+ = 0;\" 2 \"dom3\"} } */\n+\n+/* The XOR operations should have been optimized to constants.  */\n+/* { dg-final { scan-tree-dump-not \"bit_xor\" \"dom3\"} } */\n+\n+\n+extern int *stepsizeTable;\n+\n+void\n+adpcm_coder (signed char *outdata, int len)\n+{\n+  signed char *outp;\n+  int delta;\n+  int outputbuffer;\n+  int bufferstep = 0;\n+  outp = (signed char *) outdata;\n+  int step = 0;\n+  int index = 0;\n+  int diff = 0;\n+  for (; len > 0; len--)\n+    {\n+      delta = 0;\n+      if (diff >= step)\n+\tdelta = 4;\n+      step = stepsizeTable[index];\n+      if (bufferstep)\n+\toutputbuffer = (delta << 4) & 0xf0;\n+      else\n+\t*outp++ = (delta & 0x0f) | outputbuffer;\n+      bufferstep = !bufferstep;\n+    }\n+}"}, {"sha": "a9abed9a903d8acade6f1bd6f2575af6906fe26c", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/947c2ce56cf736fb2c48ad3d777e7c352585ce16/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/947c2ce56cf736fb2c48ad3d777e7c352585ce16/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=947c2ce56cf736fb2c48ad3d777e7c352585ce16", "patch": "@@ -316,6 +316,38 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n   edge_info->cond_equivalences.safe_push (c);\n }\n \n+/* Return TRUE is OP, an SSA_NAME has a range of values [0..1], false\n+   otherwise.\n+\n+   This can be because it is a boolean type, any type with\n+   a single bit of precision, or has known range of values\n+   it might old of [0..1] via VRP analysis.  */\n+\n+static bool\n+ssa_name_has_boolean_range (tree op)\n+{\n+  /* Boolean types always have a range [0..1].  */\n+  if (TREE_CODE (TREE_TYPE (op)) == BOOLEAN_TYPE)\n+    return true;\n+\n+  /* An integral type with a single bit of precision.  */\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (op))\n+      && TYPE_PRECISION (TREE_TYPE (op)) == 1)\n+    return true;\n+\n+  /* An integral type with more precision, but the object\n+     only takes on values [0..1] as determined by VRP\n+     analysis.  */\n+  wide_int min, max;\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (op))\n+      && get_range_info (op, &min, &max) == VR_RANGE\n+      && wi::eq_p (min, 0)\n+      && wi::eq_p (max, 1))\n+    return true;\n+\n+  return false;\n+}\n+\n /* We have finished optimizing BB, record any information implied by\n    taking a specific outgoing edge from BB.  */\n \n@@ -390,36 +422,32 @@ record_edge_info (basic_block bb)\n              can record an equivalence for OP0 rather than COND.  */\n           if ((code == EQ_EXPR || code == NE_EXPR)\n               && TREE_CODE (op0) == SSA_NAME\n-              && TREE_CODE (TREE_TYPE (op0)) == BOOLEAN_TYPE\n+\t      && ssa_name_has_boolean_range (op0)\n               && is_gimple_min_invariant (op1))\n             {\n+\t      tree true_val = fold_convert (TREE_TYPE (op0),\n+\t\t\t\t\t    boolean_true_node);\n+\t      tree false_val = fold_convert (TREE_TYPE (op0),\n+\t\t\t\t\t     boolean_false_node);\n               if (code == EQ_EXPR)\n                 {\n                   edge_info = allocate_edge_info (true_edge);\n                   edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1)\n-                                    ? boolean_false_node\n-                                    : boolean_true_node);\n+                  edge_info->rhs = (integer_zerop (op1) ? false_val : true_val);\n \n                   edge_info = allocate_edge_info (false_edge);\n                   edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1)\n-                                    ? boolean_true_node\n-                                    : boolean_false_node);\n+                  edge_info->rhs = (integer_zerop (op1) ? true_val : false_val);\n                 }\n               else\n                 {\n                   edge_info = allocate_edge_info (true_edge);\n                   edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1)\n-                                    ? boolean_true_node\n-                                    : boolean_false_node);\n+                  edge_info->rhs = (integer_zerop (op1) ? true_val : false_val);\n \n                   edge_info = allocate_edge_info (false_edge);\n                   edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1)\n-                                    ? boolean_false_node\n-                                    : boolean_true_node);\n+                  edge_info->rhs = (integer_zerop (op1) ? false_val : true_val);\n                 }\n             }\n           else if (is_gimple_min_invariant (op0)"}]}