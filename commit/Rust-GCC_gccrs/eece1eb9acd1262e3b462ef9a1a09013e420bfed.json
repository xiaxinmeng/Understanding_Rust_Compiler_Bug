{"sha": "eece1eb9acd1262e3b462ef9a1a09013e420bfed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVjZTFlYjlhY2QxMjYyZTNiNDYyZWY5YTFhMDkwMTNlNDIwYmZlZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-04-29T19:10:48Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-04-29T19:10:48Z"}, "message": "[multiple changes]\n\n2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/43896\n\t* symbol.c (add_proc_component,copy_vtab_proc_comps): Remove\n\tinitializers for PPC members of the vtabs.\n\n2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/42274\n\t* symbol.c (add_proc_component,add_proc_comps): Correctly set the 'ppc'\n\tattribute for all PPC members of the vtypes.\n\t(copy_vtab_proc_comps): Copy the correct interface.\n\t* trans.h (gfc_trans_assign_vtab_procs): Modified prototype.\n\t* trans-expr.c (gfc_trans_assign_vtab_procs): Pass the derived type as\n\ta dummy argument and make sure all PPC members of the vtab are\n\tinitialized correctly.\n\t(gfc_conv_derived_to_class,gfc_trans_class_assign): Additional argument\n\tin call to gfc_trans_assign_vtab_procs.\n\t* trans-stmt.c (gfc_trans_allocate): Ditto.\n\n2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43326\n\t* resolve.c (resolve_typebound_function): Renamed\n\tresolve_class_compcall.Do all the detection of class references\n\there.\n\t(resolve_typebound_subroutine): resolve_class_typebound_call\n\trenamed. Otherwise same as resolve_typebound_function.\n\t(gfc_resolve_expr): Call resolve_typebound_function.\n\t(resolve_code): Call resolve_typebound_subroutine.\n\n2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/43492\n\t* resolve.c (resolve_typebound_generic_call): For CLASS methods\n\tpass back the specific symtree name, rather than the target\n\tname.\n\n2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42353\n\t* resolve.c (resolve_structure_cons): Make the initializer of\n\tthe vtab component 'extends' the same type as the component.\n\n2010-04-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/42680\n\t* interface.c (check_interface1): Pass symbol name rather than NULL to\n\tgfc_compare_interfaces.(gfc_compare_interfaces): Add assert to\n\ttrap MULL. (gfc_compare_derived_types): Revert previous change\n\tincorporated incorrectly during merge from trunk, r155778.\n\t* resolve.c (check_generic_tbp_ambiguity): Pass symbol name rather\n\tthan NULL to gfc_compare_interfaces.\n\t* symbol.c (add_generic_specifics): Likewise.\n\n2010-02-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/42353\n\t* interface.c (gfc_compare_derived_types): Add condition for vtype.\n\t* symbol.c (gfc_find_derived_vtab): Sey access to private.\n\t(gfc_find_derived_vtab): Likewise.\n\t* module.c (ab_attribute): Add enumerator AB_VTAB.\n\t(mio_symbol_attribute): Use new attribute, AB_VTAB.\n\t(check_for_ambiguous): Likewise.\n\n2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n\t    Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41829\n\t* trans-expr.c (select_class_proc): Remove function.\n\t(conv_function_val): Delete reference to previous.\n\t(gfc_conv_derived_to_class): Add second argument to the call to\n\tgfc_find_derived_vtab.\n\t(gfc_conv_structure): Exclude proc_pointer components when\n\taccessing $data field of class objects.\n\t(gfc_trans_assign_vtab_procs): New function.\n\t(gfc_trans_class_assign): Add second argument to the call to\n\tgfc_find_derived_vtab.\n\t* symbol.c (gfc_build_class_symbol): Add delayed_vtab arg and\n\timplement holding off searching for the vptr derived type.\n\t(add_proc_component): New function.\n\t(add_proc_comps): New function.\n\t(add_procs_to_declared_vtab1): New function.\n\t(copy_vtab_proc_comps): New function.\n\t(add_procs_to_declared_vtab): New function.\n\t(void add_generic_specifics): New function.\n\t(add_generics_to_declared_vtab): New function.\n\t(gfc_find_derived_vtab): Add second argument to the call to\n\tgfc_find_derived_vtab. Add the calls to\n\tadd_procs_to_declared_vtab and add_generics_to_declared_vtab.\n\t* decl.c (build_sym, build_struct): Use new arg in calls to\n\tgfc_build_class_symbol.\n\t* gfortran.h : Add vtype bitfield to symbol_attr. Remove the\n\tdefinition of struct gfc_class_esym_list. Modify prototypes\n\tof gfc_build_class_symbol and gfc_find_derived_vtab.\n\t* trans-stmt.c (gfc_trans_allocate): Add second argument to the\n\tcall to gfc_find_derived_vtab.\n\t* module.c : Add the vtype attribute.\n\t* trans.h : Add prototype for gfc_trans_assign_vtab_procs.\n\t* resolve.c (resolve_typebound_generic_call): Add second arg\n\tto pass along the generic name for class methods.\n\t(resolve_typebound_call): The same.\n\t(resolve_compcall): Use the second arg to carry the generic\n\tname from the above. Remove the reference to class_esym.\n\t(check_members, check_class_members, resolve_class_esym,\n\thash_value_expr): Remove functions.\n\t(resolve_class_compcall, resolve_class_typebound_call): Modify\n\tto use vtable rather than member by member calls.\n\t(gfc_resolve_expr): Modify second arg in call to\n\tresolve_compcall.\n\t(resolve_select_type): Add second arg in call to\n\tgfc_find_derived_vtab.\n\t(resolve_code): Add second arg in call resolve_typebound_call.\n\t(resolve_fl_derived): Exclude vtypes from check for late\n\tprocedure definitions. Likewise for checking of explicit\n\tinterface and checking of pass arg.\n\t* iresolve.c (gfc_resolve_extends_type_of): Add second arg in\n\tcalls to gfc_find_derived_vtab.\n\t* match.c (select_type_set_tmp): Use new arg in call to\n\tgfc_build_class_symbol.\n\t* trans-decl.c (gfc_get_symbol_decl): Complete vtable if\n\tnecessary.\n\t* parse.c (endType): Finish incomplete classes.\n\n\n2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/42274\n\t* gfortran.dg/class_16.f03: New test.\n\n2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/42274\n\t* gfortran.dg/class_15.f03: New.\n\n2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43326\n\t* gfortran.dg/dynamic_dispatch_9.f03: New test.\n\n2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/43492\n\t* gfortran.dg/generic_22.f03 : New test.\n\n2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42353\n\t* gfortran.dg/class_14.f03: New test.\n\n2010-04-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/42680\n\t* gfortran.dg/interface_32.f90: New test.\n\n2009-04-29  Paul Thomas  <pault@gcc.gnu.org>\n\t    Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41829\n\t* gfortran.dg/dynamic_dispatch_5.f03 : Change to \"run\".\n\t* gfortran.dg/dynamic_dispatch_7.f03 : New test.\n\t* gfortran.dg/dynamic_dispatch_8.f03 : New test.\n\nFrom-SVN: r158910", "tree": {"sha": "3c9e7c6293e0d7d92f5dc1371a2d5dc41f706d41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c9e7c6293e0d7d92f5dc1371a2d5dc41f706d41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eece1eb9acd1262e3b462ef9a1a09013e420bfed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eece1eb9acd1262e3b462ef9a1a09013e420bfed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eece1eb9acd1262e3b462ef9a1a09013e420bfed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eece1eb9acd1262e3b462ef9a1a09013e420bfed/comments", "author": null, "committer": null, "parents": [{"sha": "716a34815b5cef49e6c019fbe48bc3803dcc890b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/716a34815b5cef49e6c019fbe48bc3803dcc890b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/716a34815b5cef49e6c019fbe48bc3803dcc890b"}], "stats": {"total": 1687, "additions": 1231, "deletions": 456}, "files": [{"sha": "39368cba6b17c6d5644d18be8b06881b3ec793b0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -1,3 +1,127 @@\n+2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/43896\n+\t* symbol.c (add_proc_component,copy_vtab_proc_comps): Remove\n+\tinitializers for PPC members of the vtabs.\n+\n+2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/42274\n+\t* symbol.c (add_proc_component,add_proc_comps): Correctly set the 'ppc'\n+\tattribute for all PPC members of the vtypes.\n+\t(copy_vtab_proc_comps): Copy the correct interface.\n+\t* trans.h (gfc_trans_assign_vtab_procs): Modified prototype.\n+\t* trans-expr.c (gfc_trans_assign_vtab_procs): Pass the derived type as\n+\ta dummy argument and make sure all PPC members of the vtab are\n+\tinitialized correctly.\n+\t(gfc_conv_derived_to_class,gfc_trans_class_assign): Additional argument\n+\tin call to gfc_trans_assign_vtab_procs.\n+\t* trans-stmt.c (gfc_trans_allocate): Ditto.\n+\n+2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43326\n+\t* resolve.c (resolve_typebound_function): Renamed\n+\tresolve_class_compcall.Do all the detection of class references\n+\there.\n+\t(resolve_typebound_subroutine): resolve_class_typebound_call\n+\trenamed. Otherwise same as resolve_typebound_function.\n+\t(gfc_resolve_expr): Call resolve_typebound_function.\n+\t(resolve_code): Call resolve_typebound_subroutine.\n+\n+2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/43492\n+\t* resolve.c (resolve_typebound_generic_call): For CLASS methods\n+\tpass back the specific symtree name, rather than the target\n+\tname.\n+\n+2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42353\n+\t* resolve.c (resolve_structure_cons): Make the initializer of\n+\tthe vtab component 'extends' the same type as the component.\n+\n+2010-04-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/42680\n+\t* interface.c (check_interface1): Pass symbol name rather than NULL to\n+\tgfc_compare_interfaces.(gfc_compare_interfaces): Add assert to\n+\ttrap MULL. (gfc_compare_derived_types): Revert previous change\n+\tincorporated incorrectly during merge from trunk, r155778.\n+\t* resolve.c (check_generic_tbp_ambiguity): Pass symbol name rather\n+\tthan NULL to gfc_compare_interfaces.\n+\t* symbol.c (add_generic_specifics): Likewise.\n+\n+2010-02-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/42353\n+\t* interface.c (gfc_compare_derived_types): Add condition for vtype.\n+\t* symbol.c (gfc_find_derived_vtab): Sey access to private.\n+\t(gfc_find_derived_vtab): Likewise.\n+\t* module.c (ab_attribute): Add enumerator AB_VTAB.\n+\t(mio_symbol_attribute): Use new attribute, AB_VTAB.\n+\t(check_for_ambiguous): Likewise.\n+\n+2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41829\n+\t* trans-expr.c (select_class_proc): Remove function.\n+\t(conv_function_val): Delete reference to previous.\n+\t(gfc_conv_derived_to_class): Add second argument to the call to\n+\tgfc_find_derived_vtab.\n+\t(gfc_conv_structure): Exclude proc_pointer components when\n+\taccessing $data field of class objects.\n+\t(gfc_trans_assign_vtab_procs): New function.\n+\t(gfc_trans_class_assign): Add second argument to the call to\n+\tgfc_find_derived_vtab.\n+\t* symbol.c (gfc_build_class_symbol): Add delayed_vtab arg and\n+\timplement holding off searching for the vptr derived type.\n+\t(add_proc_component): New function.\n+\t(add_proc_comps): New function.\n+\t(add_procs_to_declared_vtab1): New function.\n+\t(copy_vtab_proc_comps): New function.\n+\t(add_procs_to_declared_vtab): New function.\n+\t(void add_generic_specifics): New function.\n+\t(add_generics_to_declared_vtab): New function.\n+\t(gfc_find_derived_vtab): Add second argument to the call to\n+\tgfc_find_derived_vtab. Add the calls to\n+\tadd_procs_to_declared_vtab and add_generics_to_declared_vtab.\n+\t* decl.c (build_sym, build_struct): Use new arg in calls to\n+\tgfc_build_class_symbol.\n+\t* gfortran.h : Add vtype bitfield to symbol_attr. Remove the\n+\tdefinition of struct gfc_class_esym_list. Modify prototypes\n+\tof gfc_build_class_symbol and gfc_find_derived_vtab.\n+\t* trans-stmt.c (gfc_trans_allocate): Add second argument to the\n+\tcall to gfc_find_derived_vtab.\n+\t* module.c : Add the vtype attribute.\n+\t* trans.h : Add prototype for gfc_trans_assign_vtab_procs.\n+\t* resolve.c (resolve_typebound_generic_call): Add second arg\n+\tto pass along the generic name for class methods.\n+\t(resolve_typebound_call): The same.\n+\t(resolve_compcall): Use the second arg to carry the generic\n+\tname from the above. Remove the reference to class_esym.\n+\t(check_members, check_class_members, resolve_class_esym,\n+\thash_value_expr): Remove functions.\n+\t(resolve_class_compcall, resolve_class_typebound_call): Modify\n+\tto use vtable rather than member by member calls.\n+\t(gfc_resolve_expr): Modify second arg in call to\n+\tresolve_compcall.\n+\t(resolve_select_type): Add second arg in call to\n+\tgfc_find_derived_vtab.\n+\t(resolve_code): Add second arg in call resolve_typebound_call.\n+\t(resolve_fl_derived): Exclude vtypes from check for late\n+\tprocedure definitions. Likewise for checking of explicit\n+\tinterface and checking of pass arg.\n+\t* iresolve.c (gfc_resolve_extends_type_of): Add second arg in\n+\tcalls to gfc_find_derived_vtab.\n+\t* match.c (select_type_set_tmp): Use new arg in call to\n+\tgfc_build_class_symbol.\n+\t* trans-decl.c (gfc_get_symbol_decl): Complete vtable if\n+\tnecessary.\n+\t* parse.c (endType): Finish incomplete classes.\n+\n 2010-04-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "12dcf84d8b064c1793da8ad263ebcb1a6d928e85", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -1160,7 +1160,7 @@ build_sym (const char *name, gfc_charlen *cl,\n       sym->attr.class_ok = (sym->attr.dummy\n \t\t\t      || sym->attr.pointer\n \t\t\t      || sym->attr.allocatable) ? 1 : 0;\n-      gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as);\n+      gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as, false);\n     }\n \n   return SUCCESS;\n@@ -1570,7 +1570,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \n scalar:\n   if (c->ts.type == BT_CLASS)\n-    gfc_build_class_symbol (&c->ts, &c->attr, &c->as);\n+    gfc_build_class_symbol (&c->ts, &c->attr, &c->as, true);\n \n   return t;\n }"}, {"sha": "11ce974b7b8499024a060268edf4df95c55f75b3", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -691,7 +691,8 @@ typedef struct\n   unsigned extension:8;\t\t/* extension level of a derived type.  */\n   unsigned is_class:1;\t\t/* is a CLASS container.  */\n   unsigned class_ok:1;\t\t/* is a CLASS object with correct attributes.  */\n-  unsigned vtab:1;\t\t/* is a derived type vtab.  */\n+  unsigned vtab:1;\t\t/* is a derived type vtab, pointed to by CLASS objects.  */\n+  unsigned vtype:1;\t\t/* is a derived type of a vtab.  */\n \n   /* These flags are both in the typespec and attribute.  The attribute\n      list is what gets read from/written to a module file.  The typespec\n@@ -1615,17 +1616,6 @@ typedef struct gfc_intrinsic_sym\n gfc_intrinsic_sym;\n \n \n-typedef struct gfc_class_esym_list\n-{\n-  gfc_symbol *derived;\n-  gfc_symbol *esym;\n-  struct gfc_expr *hash_value;\n-  struct gfc_class_esym_list *next;\n-}\n-gfc_class_esym_list;\n-\n-#define gfc_get_class_esym_list() XCNEW (gfc_class_esym_list)\n-\n /* Expression nodes.  The expression node types deserve explanations,\n    since the last couple can be easily misconstrued:\n \n@@ -1717,7 +1707,6 @@ typedef struct gfc_expr\n       const char *name;\t/* Points to the ultimate name of the function */\n       gfc_intrinsic_sym *isym;\n       gfc_symbol *esym;\n-      gfc_class_esym_list *class_esym;\n     }\n     function;\n \n@@ -2526,8 +2515,8 @@ gfc_gsymbol *gfc_get_gsymbol (const char *);\n gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n-\t\t\t\tgfc_array_spec **);\n-gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);\n+\t\t\t\tgfc_array_spec **, bool);\n+gfc_symbol *gfc_find_derived_vtab (gfc_symbol *, bool);\n gfc_typebound_proc* gfc_get_typebound_proc (void);\n gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n gfc_symbol* gfc_get_ultimate_derived_super_type (gfc_symbol*);"}, {"sha": "38adf9b7393b75a9fcc8ebf8da9abd3fa151c9e1", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -1129,8 +1129,8 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,\n \tif (p->sym->name == q->sym->name && p->sym->module == q->sym->module)\n \t  continue;\n \n-\tif (gfc_compare_interfaces (p->sym, q->sym, q->sym->name, generic_flag, 0,\n-\t\t\t\t    NULL, 0))\n+\tif (gfc_compare_interfaces (p->sym, q->sym, q->sym->name, generic_flag,\n+\t\t\t\t    0, NULL, 0))\n \t  {\n \t    if (referenced)\n \t      gfc_error (\"Ambiguous interfaces '%s' and '%s' in %s at %L\","}, {"sha": "1c69f20bbc52db7c3959febf4f3f198213431ed8", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -832,7 +832,7 @@ gfc_resolve_extends_type_of (gfc_expr *f, gfc_expr *a, gfc_expr *mo)\n     gfc_add_component_ref (a, \"$vptr\");\n   else if (a->ts.type == BT_DERIVED)\n     {\n-      vtab = gfc_find_derived_vtab (a->ts.u.derived);\n+      vtab = gfc_find_derived_vtab (a->ts.u.derived, false);\n       /* Clear the old expr.  */\n       gfc_free_ref_list (a->ref);\n       memset (a, '\\0', sizeof (gfc_expr));\n@@ -848,7 +848,7 @@ gfc_resolve_extends_type_of (gfc_expr *f, gfc_expr *a, gfc_expr *mo)\n     gfc_add_component_ref (mo, \"$vptr\");\n   else if (mo->ts.type == BT_DERIVED)\n     {\n-      vtab = gfc_find_derived_vtab (mo->ts.u.derived);\n+      vtab = gfc_find_derived_vtab (mo->ts.u.derived, false);\n       /* Clear the old expr.  */\n       gfc_free_ref_list (mo->ref);\n       memset (mo, '\\0', sizeof (gfc_expr));"}, {"sha": "5f25e9661e5d162c18f7d8d23f03e5e8ae81ee21", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -4280,7 +4280,7 @@ select_type_set_tmp (gfc_typespec *ts)\n   if (ts->type == BT_CLASS)\n     {\n       gfc_build_class_symbol (&tmp->n.sym->ts, &tmp->n.sym->attr,\n-\t\t\t      &tmp->n.sym->as);\n+\t\t\t      &tmp->n.sym->as, false);\n       tmp->n.sym->attr.class_ok = 1;\n     }\n "}, {"sha": "a419d6bdd042b2962d2c2094b8badd1c8496da51", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -1674,7 +1674,7 @@ typedef enum\n   AB_POINTER_COMP, AB_PRIVATE_COMP, AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n-  AB_COARRAY_COMP\n+  AB_COARRAY_COMP, AB_VTYPE, AB_VTAB\n }\n ab_attribute;\n \n@@ -1720,6 +1720,8 @@ static const mstring attr_bits[] =\n     minit (\"IS_CLASS\", AB_IS_CLASS),\n     minit (\"PROCEDURE\", AB_PROCEDURE),\n     minit (\"PROC_POINTER\", AB_PROC_POINTER),\n+    minit (\"VTYPE\", AB_VTYPE),\n+    minit (\"VTAB\", AB_VTAB),\n     minit (NULL, -1)\n };\n \n@@ -1880,6 +1882,10 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_PROCEDURE, attr_bits);\n       if (attr->proc_pointer)\n \tMIO_NAME (ab_attribute) (AB_PROC_POINTER, attr_bits);\n+      if (attr->vtype)\n+\tMIO_NAME (ab_attribute) (AB_VTYPE, attr_bits);\n+      if (attr->vtab)\n+\tMIO_NAME (ab_attribute) (AB_VTAB, attr_bits);\n \n       mio_rparen ();\n \n@@ -2016,6 +2022,12 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_PROC_POINTER:\n \t      attr->proc_pointer = 1;\n \t      break;\n+\t    case AB_VTYPE:\n+\t      attr->vtype = 1;\n+\t      break;\n+\t    case AB_VTAB:\n+\t      attr->vtab = 1;\n+\t      break;\n \t    }\n \t}\n     }\n@@ -4201,6 +4213,9 @@ check_for_ambiguous (gfc_symbol *st_sym, pointer_info *info)\n   if (st_sym == rsym)\n     return false;\n \n+  if (st_sym->attr.vtab || st_sym->attr.vtype)\n+    return false;\n+\n   /* If the existing symbol is generic from a different module and\n      the new symbol is generic there can be no ambiguity.  */\n   if (st_sym->attr.generic"}, {"sha": "8ad52d28efb63b0916f50fbd2a7de58dc006ae9c", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -2110,6 +2110,22 @@ parse_derived (void)\n \t  || c->attr.access == ACCESS_PRIVATE\n \t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))\n \tsym->attr.private_comp = 1;\n+\n+     /* Fix up incomplete CLASS components.  */\n+     if (c->ts.type == BT_CLASS)\n+\t{\n+\t  gfc_component *data;\n+\t  gfc_component *vptr;\n+\t  gfc_symbol *vtab;\n+\t  data = gfc_find_component (c->ts.u.derived, \"$data\", true, true);\n+\t  vptr = gfc_find_component (c->ts.u.derived, \"$vptr\", true, true);\n+\t  if (vptr->ts.u.derived == NULL)\n+\t    {\n+\t      vtab = gfc_find_derived_vtab (data->ts.u.derived, false);\n+\t      gcc_assert (vtab);\n+\t      vptr->ts.u.derived = vtab->ts.u.derived;\n+\t    }\n+\t}\n     }\n \n   if (!seen_component)"}, {"sha": "93c5b484ce0188ab3d925cf886bb5f7eb6fe8130", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 133, "deletions": 271, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -898,7 +898,15 @@ resolve_structure_cons (gfc_expr *expr)\n       if (!gfc_compare_types (&cons->expr->ts, &comp->ts))\n \t{\n \t  t = FAILURE;\n-\t  if (comp->attr.pointer && cons->expr->ts.type != BT_UNKNOWN)\n+\t  if (strcmp (comp->name, \"$extends\") == 0)\n+\t    {\n+\t      /* Can afford to be brutal with the $extends initializer.\n+\t\t The derived type can get lost because it is PRIVATE\n+\t\t but it is not usage constrained by the standard.  */\n+\t      cons->expr->ts = comp->ts;\n+\t      t = SUCCESS;\n+\t    }\n+\t  else if (comp->attr.pointer && cons->expr->ts.type != BT_UNKNOWN)\n \t    gfc_error (\"The element in the derived type constructor at %L, \"\n \t\t       \"for pointer component '%s', is %s but should be %s\",\n \t\t       &cons->expr->where, comp->name,\n@@ -1874,13 +1882,12 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n      \n       /* Non-assumed length character functions.  */\n       if (sym->attr.function && sym->ts.type == BT_CHARACTER\n-\t    && gsym->ns->proc_name->ts.u.cl != NULL\n-\t    && gsym->ns->proc_name->ts.u.cl->length != NULL)\n+\t  && gsym->ns->proc_name->ts.u.cl->length != NULL)\n \t{\n \t  gfc_charlen *cl = sym->ts.u.cl;\n \n \t  if (!sym->attr.entry_master && sym->attr.if_source == IFSRC_UNKNOWN\n-                && cl && cl->length && cl->length->expr_type != EXPR_CONSTANT)\n+              && cl && cl->length && cl->length->expr_type != EXPR_CONSTANT)\n \t    {\n               gfc_error (\"Nonconstant character-length function '%s' at %L \"\n \t\t\t \"must have an explicit interface\", sym->name,\n@@ -5121,7 +5128,7 @@ resolve_typebound_static (gfc_expr* e, gfc_symtree** target,\n    the expression into a call of that binding.  */\n \n static gfc_try\n-resolve_typebound_generic_call (gfc_expr* e)\n+resolve_typebound_generic_call (gfc_expr* e, const char **name)\n {\n   gfc_typebound_proc* genproc;\n   const char* genname;\n@@ -5177,6 +5184,10 @@ resolve_typebound_generic_call (gfc_expr* e)\n \t  if (matches)\n \t    {\n \t      e->value.compcall.tbp = g->specific;\n+\t      /* Pass along the name for CLASS methods, where the vtab\n+\t\t procedure pointer component has to be referenced.  */\n+\t      if (name)\n+\t\t*name = g->specific_st->name;\n \t      goto success;\n \t    }\n \t}\n@@ -5195,7 +5206,7 @@ resolve_typebound_generic_call (gfc_expr* e)\n /* Resolve a call to a type-bound subroutine.  */\n \n static gfc_try\n-resolve_typebound_call (gfc_code* c)\n+resolve_typebound_call (gfc_code* c, const char **name)\n {\n   gfc_actual_arglist* newactual;\n   gfc_symtree* target;\n@@ -5211,7 +5222,12 @@ resolve_typebound_call (gfc_code* c)\n   if (check_typebound_baseobject (c->expr1) == FAILURE)\n     return FAILURE;\n \n-  if (resolve_typebound_generic_call (c->expr1) == FAILURE)\n+  /* Pass along the name for CLASS methods, where the vtab\n+     procedure pointer component has to be referenced.  */\n+  if (name)\n+    *name = c->expr1->value.compcall.name;\n+\n+  if (resolve_typebound_generic_call (c->expr1, name) == FAILURE)\n     return FAILURE;\n \n   /* Transform into an ordinary EXEC_CALL for now.  */\n@@ -5235,39 +5251,33 @@ resolve_typebound_call (gfc_code* c)\n }\n \n \n-/* Resolve a component-call expression.  This originally was intended\n-   only to see functions.  However, it is convenient to use it in \n-   resolving subroutine class methods, since we do not have to add a\n-   gfc_code each time. */\n+/* Resolve a component-call expression.  */\n static gfc_try\n-resolve_compcall (gfc_expr* e, bool fcn, bool class_members)\n+resolve_compcall (gfc_expr* e, const char **name)\n {\n   gfc_actual_arglist* newactual;\n   gfc_symtree* target;\n \n   /* Check that's really a FUNCTION.  */\n-  if (fcn && !e->value.compcall.tbp->function)\n+  if (!e->value.compcall.tbp->function)\n     {\n       gfc_error (\"'%s' at %L should be a FUNCTION\",\n \t\t e->value.compcall.name, &e->where);\n       return FAILURE;\n     }\n-  else if (!fcn && !e->value.compcall.tbp->subroutine)\n-    {\n-      /* To resolve class member calls, we borrow this bit\n-         of code to select the specific procedures.  */\n-      gfc_error (\"'%s' at %L should be a SUBROUTINE\",\n-\t\t e->value.compcall.name, &e->where);\n-      return FAILURE;\n-    }\n \n   /* These must not be assign-calls!  */\n   gcc_assert (!e->value.compcall.assign);\n \n   if (check_typebound_baseobject (e) == FAILURE)\n     return FAILURE;\n \n-  if (resolve_typebound_generic_call (e) == FAILURE)\n+  /* Pass along the name for CLASS methods, where the vtab\n+     procedure pointer component has to be referenced.  */\n+  if (name)\n+    *name = e->value.compcall.name;\n+\n+  if (resolve_typebound_generic_call (e, name) == FAILURE)\n     return FAILURE;\n   gcc_assert (!e->value.compcall.tbp->is_generic);\n \n@@ -5284,169 +5294,15 @@ resolve_compcall (gfc_expr* e, bool fcn, bool class_members)\n   e->value.function.actual = newactual;\n   e->value.function.name = NULL;\n   e->value.function.esym = target->n.sym;\n-  e->value.function.class_esym = NULL;\n   e->value.function.isym = NULL;\n   e->symtree = target;\n   e->ts = target->n.sym->ts;\n   e->expr_type = EXPR_FUNCTION;\n \n-  /* Resolution is not necessary when constructing component calls\n-     for class members, since this must only be done for the\n-     declared type, which is done afterwards.  */\n-  return !class_members ? gfc_resolve_expr (e) : SUCCESS;\n-}\n-\n-\n-/* Resolve a typebound call for the members in a class.  This group of\n-   functions implements dynamic dispatch in the provisional version\n-   of f03 OOP.  As soon as vtables are in place and contain pointers\n-   to methods, this will no longer be necessary.  */\n-static gfc_expr *list_e;\n-static gfc_try check_class_members (gfc_symbol *);\n-static gfc_try class_try;\n-static bool fcn_flag;\n-\n-\n-static void\n-check_members (gfc_symbol *derived)\n-{\n-  if (derived->attr.flavor == FL_DERIVED)\n-    (void) check_class_members (derived);\n-}\n-\n-\n-static gfc_try \n-check_class_members (gfc_symbol *derived)\n-{\n-  gfc_expr *e;\n-  gfc_symtree *tbp;\n-  gfc_class_esym_list *etmp;\n-\n-  e = gfc_copy_expr (list_e);\n-\n-  tbp = gfc_find_typebound_proc (derived, &class_try,\n-\t\t\t\t e->value.compcall.name,\n-\t\t\t\t false, &e->where);\n-\n-  if (tbp == NULL)\n-    {\n-      gfc_error (\"no typebound available procedure named '%s' at %L\",\n-\t\t e->value.compcall.name, &e->where);\n-      return FAILURE;\n-    }\n-\n-  /* If we have to match a passed class member, force the actual\n-      expression to have the correct type.  */\n-  if (!tbp->n.tb->nopass)\n-    {\n-      if (e->value.compcall.base_object == NULL)\n-\te->value.compcall.base_object = extract_compcall_passed_object (e);\n-\n-      if (e->value.compcall.base_object == NULL)\n-\treturn FAILURE;\n-\n-      if (!derived->attr.abstract)\n-\t{\n-\t  e->value.compcall.base_object->ts.type = BT_DERIVED;\n-\t  e->value.compcall.base_object->ts.u.derived = derived;\n-\t}\n-    }\n-\n-  e->value.compcall.tbp = tbp->n.tb;\n-  e->value.compcall.name = tbp->name;\n-\n-  /* Let the original expresssion catch the assertion in\n-     resolve_compcall, since this flag does not appear to be reset or\n-     copied in some systems.  */\n-  e->value.compcall.assign = 0;\n-\n-  /* Do the renaming, PASSing, generic => specific and other\n-     good things for each class member.  */\n-  class_try = (resolve_compcall (e, fcn_flag, true) == SUCCESS)\n-\t\t\t\t? class_try : FAILURE;\n-\n-  /* Now transfer the found symbol to the esym list.  */\n-  if (class_try == SUCCESS)\n-    {\n-      etmp = list_e->value.function.class_esym;\n-      list_e->value.function.class_esym\n-\t\t= gfc_get_class_esym_list();\n-      list_e->value.function.class_esym->next = etmp;\n-      list_e->value.function.class_esym->derived = derived;\n-      list_e->value.function.class_esym->esym\n-\t\t= e->value.function.esym;\n-    }\n-\n-  gfc_free_expr (e);\n-  \n-  /* Burrow down into grandchildren types.  */\n-  if (derived->f2k_derived)\n-    gfc_traverse_ns (derived->f2k_derived, check_members);\n-\n-  return SUCCESS;\n-}\n-\n-\n-/* Eliminate esym_lists where all the members point to the\n-   typebound procedure of the declared type; ie. one where\n-   type selection has no effect..  */\n-static void\n-resolve_class_esym (gfc_expr *e)\n-{\n-  gfc_class_esym_list *p, *q;\n-  bool empty = true;\n-\n-  gcc_assert (e && e->expr_type == EXPR_FUNCTION);\n-\n-  p = e->value.function.class_esym;\n-  if (p == NULL)\n-    return;\n-\n-  for (; p; p = p->next)\n-    empty = empty && (e->value.function.esym == p->esym);\n-\n-  if (empty)\n-    {\n-      p = e->value.function.class_esym;\n-      for (; p; p = q)\n-\t{\n-\t  q = p->next;\n-\t  gfc_free (p);\n-\t}\n-      e->value.function.class_esym = NULL;\n-   }\n-}\n-\n-\n-/* Generate an expression for the hash value, given the reference to\n-   the class of the final expression (class_ref), the base of the\n-   full reference list (new_ref), the declared type and the class\n-   object (st).  */\n-static gfc_expr*\n-hash_value_expr (gfc_ref *class_ref, gfc_ref *new_ref, gfc_symtree *st)\n-{\n-  gfc_expr *hash_value;\n-\n-  /* Build an expression for the correct hash_value; ie. that of the last\n-     CLASS reference.  */\n-  if (class_ref)\n-    {\n-      class_ref->next = NULL;\n-    }\n-  else\n-    {\n-      gfc_free_ref_list (new_ref);\n-      new_ref = NULL;\n-    }\n-  hash_value = gfc_get_expr ();\n-  hash_value->expr_type = EXPR_VARIABLE;\n-  hash_value->symtree = st;\n-  hash_value->symtree->n.sym->refs++;\n-  hash_value->ref = new_ref;\n-  gfc_add_component_ref (hash_value, \"$vptr\");\n-  gfc_add_component_ref (hash_value, \"$hash\");\n-\n-  return hash_value;\n+  /* Resolution is not necessary if this is a class subroutine; this\n+     function only has to identify the specific proc. Resolution of\n+     the call will be done next in resolve_typebound_call.  */\n+  return gfc_resolve_expr (e);\n }\n \n \n@@ -5483,146 +5339,151 @@ get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,\n }\n \n \n-/* Resolve the argument expressions so that any arguments expressions\n-   that include class methods are resolved before the current call.\n-   This is necessary because of the static variables used in CLASS\n-   method resolution.  */\n-static void\n-resolve_arg_exprs (gfc_actual_arglist *arg)\n-{ \n-  /* Resolve the actual arglist expressions.  */\n-  for (; arg; arg = arg->next)\n-    {\n-      if (arg->expr)\n-\tgfc_resolve_expr (arg->expr);\n-    }\n-}\n-\n-\n-/* Resolve a typebound function, or 'method'.  First separate all\n-   the non-CLASS references by calling resolve_compcall directly.\n-   Then treat the CLASS references by resolving for each of the class\n-   members in turn.  */\n+/* Resolve a typebound function, or 'method'. First separate all\n+   the non-CLASS references by calling resolve_compcall directly.  */\n \n static gfc_try\n resolve_typebound_function (gfc_expr* e)\n {\n-  gfc_symbol *derived, *declared;\n+  gfc_symbol *declared;\n+  gfc_component *c;\n   gfc_ref *new_ref;\n   gfc_ref *class_ref;\n   gfc_symtree *st;\n+  const char *name;\n+  const char *genname;\n+  gfc_typespec ts;\n \n   st = e->symtree;\n   if (st == NULL)\n-    return resolve_compcall (e, true, false);\n+    return resolve_compcall (e, NULL);\n \n   /* Get the CLASS declared type.  */\n   declared = get_declared_from_expr (&class_ref, &new_ref, e);\n \n   /* Weed out cases of the ultimate component being a derived type.  */\n   if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n-\t|| (!class_ref && st->n.sym->ts.type != BT_CLASS))\n+\t || (!class_ref && st->n.sym->ts.type != BT_CLASS))\n     {\n       gfc_free_ref_list (new_ref);\n-      return resolve_compcall (e, true, false);\n+      return resolve_compcall (e, NULL);\n     }\n \n-  /* Resolve the argument expressions,  */\n-  resolve_arg_exprs (e->value.function.actual); \n+  c = gfc_find_component (declared, \"$data\", true, true);\n+  declared = c->ts.u.derived;\n \n-  /* Get the data component, which is of the declared type.  */\n-  derived = declared->components->ts.u.derived;\n+  /* Keep the generic name so that the vtab reference can be made.  */\n+  genname = NULL; \n+  if (e->value.compcall.tbp->is_generic)\n+    genname = e->value.compcall.name;\n \n-  /* Resolve the function call for each member of the class.  */\n-  class_try = SUCCESS;\n-  fcn_flag = true;\n-  list_e = gfc_copy_expr (e);\n-\n-  if (check_class_members (derived) == FAILURE)\n-    return FAILURE;\n+  /* Treat the call as if it is a typebound procedure, in order to roll\n+     out the correct name for the specific function.  */\n+  resolve_compcall (e, &name);\n+  ts = e->ts;\n \n-  class_try = (resolve_compcall (e, true, false) == SUCCESS)\n-\t\t ? class_try : FAILURE;\n+  /* Then convert the expression to a procedure pointer component call.  */\n+  e->value.function.esym = NULL;\n+  e->symtree = st;\n \n-  /* Transfer the class list to the original expression.  Note that\n-     the class_esym list is cleaned up in trans-expr.c, as the calls\n-     are translated.  */\n-  e->value.function.class_esym = list_e->value.function.class_esym;\n-  list_e->value.function.class_esym = NULL;\n-  gfc_free_expr (list_e);\n-\n-  resolve_class_esym (e);\n+  if (class_ref)  \n+    {\n+      gfc_free_ref_list (class_ref->next);\n+      e->ref = new_ref;\n+    }\n \n-  /* More than one typebound procedure so transmit an expression for\n-     the hash_value as the selector.  */\n-  if (e->value.function.class_esym != NULL)\n-    e->value.function.class_esym->hash_value\n-\t\t= hash_value_expr (class_ref, new_ref, st);\n+  /* '$vptr' points to the vtab, which contains the procedure pointers.  */\n+  gfc_add_component_ref (e, \"$vptr\");\n+  if (genname)\n+    {\n+      /* A generic procedure needs the subsidiary vtabs and vtypes for\n+\t the specific procedures to have been build.  */\n+      gfc_symbol *vtab;\n+      vtab = gfc_find_derived_vtab (declared, true);\n+      gcc_assert (vtab);\n+      gfc_add_component_ref (e, genname);\n+    }\n+  gfc_add_component_ref (e, name);\n \n-  return class_try;\n+  /* Recover the typespec for the expression.  This is really only\n+     necessary for generic procedures, where the additional call\n+     to gfc_add_component_ref seems to throw the collection of the\n+     correct typespec.  */\n+  e->ts = ts;\n+  return SUCCESS;\n }\n \n-/* Resolve a typebound subroutine, or 'method'.  First separate all\n-   the non-CLASS references by calling resolve_typebound_call directly.\n-   Then treat the CLASS references by resolving for each of the class\n-   members in turn.  */\n+/* Resolve a typebound subroutine, or 'method'. First separate all\n+   the non-CLASS references by calling resolve_typebound_call\n+   directly.  */\n \n static gfc_try\n resolve_typebound_subroutine (gfc_code *code)\n {\n-  gfc_symbol *derived, *declared;\n+  gfc_symbol *declared;\n+  gfc_component *c;\n   gfc_ref *new_ref;\n   gfc_ref *class_ref;\n   gfc_symtree *st;\n+  const char *genname;\n+  const char *name;\n+  gfc_typespec ts;\n \n   st = code->expr1->symtree;\n   if (st == NULL)\n-    return resolve_typebound_call (code);\n+    return resolve_typebound_call (code, NULL);\n \n   /* Get the CLASS declared type.  */\n   declared = get_declared_from_expr (&class_ref, &new_ref, code->expr1);\n \n   /* Weed out cases of the ultimate component being a derived type.  */\n   if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n-\t|| (!class_ref && st->n.sym->ts.type != BT_CLASS))\n+\t || (!class_ref && st->n.sym->ts.type != BT_CLASS))\n     {\n       gfc_free_ref_list (new_ref);\n-      return resolve_typebound_call (code);\n+      return resolve_typebound_call (code, NULL);\n     } \n \n-  /* Resolve the argument expressions,  */\n-  resolve_arg_exprs (code->expr1->value.compcall.actual); \n-\n-  /* Get the data component, which is of the declared type.  */\n-  derived = declared->components->ts.u.derived;\n+  c = gfc_find_component (declared, \"$data\", true, true);\n+  declared = c->ts.u.derived;\n \n-  class_try = SUCCESS;\n-  fcn_flag = false;\n-  list_e = gfc_copy_expr (code->expr1);\n-\n-  if (check_class_members (derived) == FAILURE)\n-    return FAILURE;\n+  /* Keep the generic name so that the vtab reference can be made.  */\n+  genname = NULL; \n+  if (code->expr1->value.compcall.tbp->is_generic)\n+    genname = code->expr1->value.compcall.name;\n \n-  class_try = (resolve_typebound_call (code) == SUCCESS)\n-\t\t ? class_try : FAILURE;\n+  resolve_typebound_call (code, &name);\n+  ts = code->expr1->ts;\n \n-  /* Transfer the class list to the original expression.  Note that\n-     the class_esym list is cleaned up in trans-expr.c, as the calls\n-     are translated.  */\n-  code->expr1->value.function.class_esym\n-\t\t\t= list_e->value.function.class_esym;\n-  list_e->value.function.class_esym = NULL;\n-  gfc_free_expr (list_e);\n+  /* Then convert the expression to a procedure pointer component call.  */\n+  code->expr1->value.function.esym = NULL;\n+  code->expr1->symtree = st;\n \n-  resolve_class_esym (code->expr1);\n+  if (class_ref)  \n+    {\n+      gfc_free_ref_list (class_ref->next);\n+      code->expr1->ref = new_ref;\n+    }\n \n-  /* More than one typebound procedure so transmit an expression for\n-     the hash_value as the selector.  */\n-  if (code->expr1->value.function.class_esym != NULL)\n-    code->expr1->value.function.class_esym->hash_value\n-\t\t= hash_value_expr (class_ref, new_ref, st);\n+  /* '$vptr' points to the vtab, which contains the procedure pointers.  */\n+  gfc_add_component_ref (code->expr1, \"$vptr\");\n+  if (genname)\n+    {\n+      /* A generic procedure needs the subsidiary vtabs and vtypes for\n+\t the specific procedures to have been build.  */\n+      gfc_symbol *vtab;\n+      vtab = gfc_find_derived_vtab (declared, true);\n+      gcc_assert (vtab);\n+      gfc_add_component_ref (code->expr1, genname);\n+    }\n+  gfc_add_component_ref (code->expr1, name);\n \n-  return class_try;\n+  /* Recover the typespec for the expression.  This is really only\n+     necessary for generic procedures, where the additional call\n+     to gfc_add_component_ref seems to throw the collection of the\n+     correct typespec.  */\n+  code->expr1->ts = ts;\n+  return SUCCESS;\n }\n \n \n@@ -7372,7 +7233,7 @@ resolve_select_type (gfc_code *code)\n \t  tail->next = NULL;\n \t  default_case = tail;\n \t}\n-      \n+\n       /* More than one CLASS IS block?  */\n       if (class_is->block)\n \t{\n@@ -7428,7 +7289,7 @@ resolve_select_type (gfc_code *code)\n \t  new_st->expr1->value.function.actual = gfc_get_actual_arglist ();\n \t  new_st->expr1->value.function.actual->expr = gfc_get_variable_expr (code->expr1->symtree);\n \t  gfc_add_component_ref (new_st->expr1->value.function.actual->expr, \"$vptr\");\n-\t  vtab = gfc_find_derived_vtab (body->ext.case_list->ts.u.derived);\n+\t  vtab = gfc_find_derived_vtab (body->ext.case_list->ts.u.derived, true);\n \t  st = gfc_find_symtree (vtab->ns->sym_root, vtab->name);\n \t  new_st->expr1->value.function.actual->next = gfc_get_actual_arglist ();\n \t  new_st->expr1->value.function.actual->next->expr = gfc_get_variable_expr (st);\n@@ -10743,7 +10604,7 @@ resolve_fl_derived (gfc_symbol *sym)\n \n       if (c->attr.proc_pointer && c->ts.interface)\n \t{\n-\t  if (c->ts.interface->attr.procedure)\n+\t  if (c->ts.interface->attr.procedure && !sym->attr.vtype)\n \t    gfc_error (\"Interface '%s', used by procedure pointer component \"\n \t\t       \"'%s' at %L, is declared in a later PROCEDURE statement\",\n \t\t       c->ts.interface->name, c->name, &c->loc);\n@@ -10807,7 +10668,7 @@ resolve_fl_derived (gfc_symbol *sym)\n \t\t  c->ts.u.cl = cl;\n \t\t}\n \t    }\n-\t  else if (c->ts.interface->name[0] != '\\0')\n+\t  else if (c->ts.interface->name[0] != '\\0' && !sym->attr.vtype)\n \t    {\n \t      gfc_error (\"Interface '%s' of procedure pointer component \"\n \t\t\t \"'%s' at %L must be explicit\", c->ts.interface->name,\n@@ -10823,7 +10684,8 @@ resolve_fl_derived (gfc_symbol *sym)\n \t}\n \n       /* Procedure pointer components: Check PASS arg.  */\n-      if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0)\n+      if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0\n+\t  && !sym->attr.vtype)\n \t{\n \t  gfc_symbol* me_arg;\n "}, {"sha": "b19714cfca64457d13861b907b69fabde772464b", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 361, "deletions": 12, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -4708,7 +4708,7 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n \n gfc_try\n gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n-\t\t\tgfc_array_spec **as)\n+\t\t\tgfc_array_spec **as, bool delayed_vtab)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 5];\n   gfc_symbol *fclass;\n@@ -4763,9 +4763,14 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       if (gfc_add_component (fclass, \"$vptr\", &c) == FAILURE)\n \treturn FAILURE;\n       c->ts.type = BT_DERIVED;\n-      vtab = gfc_find_derived_vtab (ts->u.derived);\n-      gcc_assert (vtab);\n-      c->ts.u.derived = vtab->ts.u.derived;\n+      if (delayed_vtab)\n+\tc->ts.u.derived = NULL;\n+      else\n+\t{\n+\t  vtab = gfc_find_derived_vtab (ts->u.derived, false);\n+\t  gcc_assert (vtab);\n+\t  c->ts.u.derived = vtab->ts.u.derived;\n+\t}\n       c->attr.pointer = 1;\n     }\n \n@@ -4787,10 +4792,344 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n }\n \n \n-/* Find the symbol for a derived type's vtab.  */\n+static void\n+add_proc_component (gfc_component *c, gfc_symbol *vtype,\n+\t\t    gfc_symtree *st, gfc_symbol *specific,\n+\t\t    bool is_generic, bool is_generic_specific)\n+{\n+  /* Add procedure component.  */\n+  if (is_generic)\n+    {\n+      if (gfc_add_component (vtype, specific->name, &c) == FAILURE)\n+\treturn;\n+      c->ts.interface = specific;\n+    }\n+  else if (c && is_generic_specific)\n+    {\n+      c->ts.interface = st->n.tb->u.specific->n.sym;\n+    }\n+  else\n+    {\n+      c = gfc_find_component (vtype, st->name, true, true);\n+      if (!c && gfc_add_component (vtype, st->name, &c) == FAILURE)\n+\treturn;\n+      c->ts.interface = st->n.tb->u.specific->n.sym;\n+    }\n+\n+  if (!c->tb)\n+    c->tb = XCNEW (gfc_typebound_proc);\n+  *c->tb = *st->n.tb;\n+  c->tb->ppc = 1;\n+  c->attr.procedure = 1;\n+  c->attr.proc_pointer = 1;\n+  c->attr.flavor = FL_PROCEDURE;\n+  c->attr.access = ACCESS_PRIVATE;\n+  c->attr.external = 1;\n+  c->attr.untyped = 1;\n+  c->attr.if_source = IFSRC_IFBODY;\n+\n+  /* A static initializer cannot be used here because the specific\n+     function is not a constant; internal compiler error: in\n+     output_constant, at varasm.c:4623  */\n+  c->initializer = NULL;\n+}\n+\n+\n+static void\n+add_proc_comps (gfc_component *c, gfc_symbol *vtype,\n+\t\tgfc_symtree *st, bool is_generic)\n+{\n+  if (c == NULL && !is_generic)\n+    {\n+      add_proc_component (c, vtype, st, NULL, false, false);\n+    }\n+  else if (is_generic && st->n.tb && vtype->components == NULL)\n+    {\n+      gfc_tbp_generic* g;\n+      gfc_symbol * specific;\n+      for (g = st->n.tb->u.generic; g; g = g->next)\n+\t{\n+\t  if (!g->specific)\n+\t    continue;\n+\t  specific = g->specific->u.specific->n.sym;\n+\t  add_proc_component (NULL, vtype, st, specific, true, false);\n+\t}\n+    }\n+  else if (c->attr.proc_pointer && c->tb)\n+    {\n+      *c->tb = *st->n.tb;\n+      c->tb->ppc = 1;\n+      c->ts.interface = st->n.tb->u.specific->n.sym;\t  \n+    }\n+}\n+\n+static void\n+add_procs_to_declared_vtab1 (gfc_symtree *st, gfc_symbol *vtype,\n+\t\t\t     bool resolved)\n+{\n+  gfc_component *c;\n+  gfc_symbol *generic;\n+  char name[3 * GFC_MAX_SYMBOL_LEN + 10];\n+\n+  if (!st)\n+    return;\n+\n+  if (st->left)\n+    add_procs_to_declared_vtab1 (st->left, vtype, resolved);\n+\n+  if (st->right)\n+    add_procs_to_declared_vtab1 (st->right, vtype, resolved);\n+\n+  if (!st->n.tb)\n+    return;\n+\n+  if (!st->n.tb->is_generic && st->n.tb->u.specific)\n+    {\n+      c = gfc_find_component (vtype, st->name, true, true);\n+      add_proc_comps (c, vtype, st, false);\n+    }\n+  else if (st->n.tb->is_generic)\n+    {\n+      c = gfc_find_component (vtype, st->name, true, true);\n+\n+      if (c == NULL)\n+\t{\n+\t  /* Add derived type component with generic name.  */\n+\t  if (gfc_add_component (vtype, st->name, &c) == FAILURE)\n+\t    return;\n+\t  c->ts.type = BT_DERIVED;\n+\t  c->attr.flavor = FL_VARIABLE;\n+\t  c->attr.pointer = 1;\n+\n+\t  /* Add a special empty derived type as a placeholder.  */\n+\t  sprintf (name, \"$empty\");\n+\t  gfc_find_symbol (name, vtype->ns, 0, &generic);\n+\t  if (generic == NULL)\n+\t    {\n+\t      gfc_get_symbol (name, vtype->ns, &generic);\n+\t      generic->attr.flavor = FL_DERIVED;\n+\t      generic->refs++;\n+\t      gfc_set_sym_referenced (generic);\n+\t      generic->ts.type = BT_UNKNOWN;\n+\t      generic->attr.zero_comp = 1;\n+\t    }\n+\n+\t  c->ts.u.derived = generic;\n+\t}\n+    }\n+}\n+\n+\n+static void\n+copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype,\n+\t\t      bool resolved)\n+{\n+  gfc_component *c, *cmp;\n+  gfc_symbol *vtab;\n+\n+  vtab = gfc_find_derived_vtab (declared, resolved);\n+\n+  for (cmp = vtab->ts.u.derived->components; cmp; cmp = cmp->next)\n+    {\n+      if (gfc_find_component (vtype, cmp->name, true, true))\n+\tcontinue;\n+\n+      if (gfc_add_component (vtype, cmp->name, &c) == FAILURE)\n+\treturn;\n+\n+      if (cmp->ts.type == BT_DERIVED)\n+\t{\n+\t  c->ts = cmp->ts;\n+\t  c->ts.u.derived = cmp->ts.u.derived;\n+\t  c->attr.flavor = FL_VARIABLE;\n+\t  c->attr.pointer = 1;\n+\t  c->initializer = NULL;\n+\t  continue;\n+\t}\n+\n+      c->tb = XCNEW (gfc_typebound_proc);\n+      *c->tb = *cmp->tb;\n+      c->attr.procedure = 1;\n+      c->attr.proc_pointer = 1;\n+      c->attr.flavor = FL_PROCEDURE;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->attr.external = 1;\n+      c->ts.interface = cmp->ts.interface;\n+      c->attr.untyped = 1;\n+      c->attr.if_source = IFSRC_IFBODY;\n+      c->initializer = NULL;\n+    }\n+}\n+\n+static void\n+add_procs_to_declared_vtab (gfc_symbol *declared, gfc_symbol *vtype,\n+\t\t\t    gfc_symbol *derived, bool resolved)\n+{\n+  gfc_symbol* super_type;\n+\n+  super_type = gfc_get_derived_super_type (declared);\n+\n+  if (super_type && (super_type != declared))\n+    add_procs_to_declared_vtab (super_type, vtype, derived, resolved);\n+\n+  if (declared != derived)\n+    copy_vtab_proc_comps (declared, vtype, resolved);\n+\n+  if (declared->f2k_derived && declared->f2k_derived->tb_sym_root)\n+    add_procs_to_declared_vtab1 (declared->f2k_derived->tb_sym_root,\n+\t\t\t\t vtype, resolved);\n+\n+  if (declared->f2k_derived && declared->f2k_derived->tb_uop_root)\n+    add_procs_to_declared_vtab1 (declared->f2k_derived->tb_uop_root,\n+\t\t\t\t vtype, resolved);\n+}\n+\n+\n+static\n+void add_generic_specifics (gfc_symbol *declared, gfc_symbol *vtab,\n+\t\t\t    const char *name)\n+{\n+  gfc_tbp_generic* g;\n+  gfc_symbol * specific1;\n+  gfc_symbol * specific2;\n+  gfc_symtree *st = NULL;\n+  gfc_component *c;\n+\n+  /* Find the generic procedure using the component name.  */\n+  st = gfc_find_typebound_proc (declared, NULL, name, true, NULL);\n+  if (st == NULL)\n+    st = gfc_find_typebound_user_op (declared, NULL, name, true, NULL);\n+\n+  if (st == NULL)\n+    return;\n+\n+  /* Add procedure pointer components for the specific procedures. */\n+  for (g = st->n.tb->u.generic; g; g = g->next)\n+    {\n+      if (!g->specific)\n+\tcontinue;\n+      specific1 = g->specific_st->n.tb->u.specific->n.sym;\n+\n+      c = vtab->ts.u.derived->components;\n+      specific2 = NULL;\n+\n+      /* Override identical specific interface.  */\n+      if (vtab->ts.u.derived->components)\n+\t{\n+\t  for (; c; c= c->next)\n+\t    {\n+\t      specific2 = c->ts.interface;\n+\t      if (gfc_compare_interfaces (specific2, specific1,\n+\t\t\t\t\t  specific1->name, 0, 0, NULL, 0))\n+\t\tbreak;\n+\t    }\n+\t}\n+\n+      add_proc_component (c, vtab->ts.u.derived, g->specific_st,\n+\t\t\t  NULL, false, true);\n+      vtab->ts.u.derived->attr.zero_comp = 0;\n+    }\n+}\n+\n+\n+static void\n+add_generics_to_declared_vtab (gfc_symbol *declared, gfc_symbol *vtype,\n+\t\t\t       gfc_symbol *derived, bool resolved)\n+{\n+  gfc_component *cmp;\n+  gfc_symtree *st = NULL;\n+  gfc_symbol * vtab;\n+  char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n+  gfc_symbol* super_type;\n+\n+  gcc_assert (resolved);\n+\n+  for (cmp = vtype->components; cmp; cmp = cmp->next)\n+    {\n+      if (cmp->ts.type != BT_DERIVED)\n+\tcontinue;\n+\n+      /* The only derived type that does not represent a generic\n+\t procedure is the pointer to the parent vtab.  */\n+      if (cmp->ts.u.derived\n+\t    && strcmp (cmp->ts.u.derived->name, \"$extends\") == 0)\n+\tcontinue;\n+\n+      /* Find the generic procedure using the component name.  */\n+      st = gfc_find_typebound_proc (declared, NULL, cmp->name,\n+\t\t\t\t    true, NULL);\n+      if (st == NULL)\n+\tst = gfc_find_typebound_user_op (declared, NULL, cmp->name,\n+\t\t\t\t\t true, NULL);\n+\n+      /* Should be an error but we pass on it for now.  */\n+      if (st == NULL || !st->n.tb->is_generic)\n+\tcontinue;\n+\n+      vtab = NULL;\n+\n+      /* Build a vtab and a special vtype, with only the procedure\n+\t pointer fields, to carry the pointers to the specific\n+\t procedures.  Should this name ever be changed, the same\n+\t should be done in trans-expr.c(gfc_trans_assign_vtab_procs). */\n+      sprintf (name, \"vtab$%s$%s\", vtype->name, cmp->name);\n+      gfc_find_symbol (name, derived->ns, 0, &vtab);\n+      if (vtab == NULL)\n+\t{\n+\t  gfc_get_symbol (name, derived->ns, &vtab);\n+\t  vtab->ts.type = BT_DERIVED;\n+\t  vtab->attr.flavor = FL_VARIABLE;\n+\t  vtab->attr.target = 1;\n+\t  vtab->attr.save = SAVE_EXPLICIT;\n+\t  vtab->attr.vtab = 1;\n+\t  vtab->refs++;\n+\t  gfc_set_sym_referenced (vtab);\n+\t  sprintf (name, \"%s$%s\", vtype->name, cmp->name);\n+\t  \n+\t  gfc_find_symbol (name, derived->ns, 0, &cmp->ts.u.derived);\n+\t  if (cmp->ts.u.derived == NULL\n+\t\t|| (strcmp (cmp->ts.u.derived->name, \"$empty\") == 0))\n+\t    {\n+\t      gfc_get_symbol (name, derived->ns, &cmp->ts.u.derived);\n+\t      if (gfc_add_flavor (&cmp->ts.u.derived->attr, FL_DERIVED,\n+\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n+\t\treturn;\n+\t      cmp->ts.u.derived->refs++;\n+\t      gfc_set_sym_referenced (cmp->ts.u.derived);\n+\t      cmp->ts.u.derived->attr.vtype = 1;\n+\t      cmp->ts.u.derived->attr.zero_comp = 1;\n+\t    }\n+\t  vtab->ts.u.derived = cmp->ts.u.derived;\n+\t}\n+\n+      /* Store this for later use in setting the pointer.  */\n+      cmp->ts.interface = vtab;\n+\n+      if (vtab->ts.u.derived->components)\n+\tcontinue;\n+\n+      super_type = gfc_get_derived_super_type (declared);\n+\n+      if (super_type && (super_type != declared))\n+\tadd_generic_specifics (super_type, vtab, cmp->name);\n+\n+      add_generic_specifics (declared, vtab, cmp->name);\n+    }\n+}\n+\n+\n+/* Find the symbol for a derived type's vtab.  A vtab has the following\n+   fields:\n+   $hash\ta hash value used to identify the derived type\n+   $size\tthe size in bytes of the derived type\n+   $extends\ta pointer to the vtable of the parent derived type\n+   then:\n+   procedure pointer components for the specific typebound procedures\n+   structure pointers to reduced vtabs that contain procedure\n+   pointers to the specific procedures.  */\n \n gfc_symbol *\n-gfc_find_derived_vtab (gfc_symbol *derived)\n+gfc_find_derived_vtab (gfc_symbol *derived, bool resolved)\n {\n   gfc_namespace *ns;\n   gfc_symbol *vtab = NULL, *vtype = NULL;\n@@ -4815,7 +5154,6 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t  vtab->attr.target = 1;\n \t  vtab->attr.save = SAVE_EXPLICIT;\n \t  vtab->attr.vtab = 1;\n-\t  vtab->attr.access = ACCESS_PRIVATE;\n \t  vtab->refs++;\n \t  gfc_set_sym_referenced (vtab);\n \t  sprintf (name, \"vtype$%s\", derived->name);\n@@ -4832,7 +5170,6 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\treturn NULL;\n \t      vtype->refs++;\n \t      gfc_set_sym_referenced (vtype);\n-\t      vtype->attr.access = ACCESS_PRIVATE;\n \n \t      /* Add component '$hash'.  */\n \t      if (gfc_add_component (vtype, \"$hash\", &c) == FAILURE)\n@@ -4864,27 +5201,39 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      parent = gfc_get_derived_super_type (derived);\n \t      if (parent)\n \t\t{\n-\t\t  parent_vtab = gfc_find_derived_vtab (parent);\n+\t\t  parent_vtab = gfc_find_derived_vtab (parent, resolved);\n \t\t  c->ts.type = BT_DERIVED;\n \t\t  c->ts.u.derived = parent_vtab->ts.u.derived;\n \t\t  c->initializer = gfc_get_expr ();\n \t\t  c->initializer->expr_type = EXPR_VARIABLE;\n-\t\t  gfc_find_sym_tree (parent_vtab->name, parent_vtab->ns, 0,\n-\t\t\t\t     &c->initializer->symtree);\n+\t\t  gfc_find_sym_tree (parent_vtab->name, parent_vtab->ns,\n+\t\t\t\t     0, &c->initializer->symtree);\n \t\t}\n \t      else\n \t\t{\n \t\t  c->ts.type = BT_DERIVED;\n \t\t  c->ts.u.derived = vtype;\n \t\t  c->initializer = gfc_get_null_expr (NULL);\n \t\t}\n+\n+\t      add_procs_to_declared_vtab (derived, vtype, derived, resolved);\n+\t      vtype->attr.vtype = 1;\n \t    }\n-\t  vtab->ts.u.derived = vtype;\n \n+\t  vtab->ts.u.derived = vtype;\n \t  vtab->value = gfc_default_initializer (&vtab->ts);\n \t}\n     }\n \n+  /* Catch the call just before the backend declarations are built, so that\n+     the generic procedures have been resolved and the specific procedures\n+     have formal interfaces that can be compared.  */\n+  if (resolved\n+\t&& vtab->ts.u.derived\n+\t&& vtab->ts.u.derived->backend_decl == NULL)\n+    add_generics_to_declared_vtab (derived, vtab->ts.u.derived,\n+\t\t\t\t   derived, resolved);\n+\n   return vtab;\n }\n "}, {"sha": "2ad4e737259bf5fbae45d8e1cf3e4d81ad8134e2", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -1070,6 +1070,15 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   else\n     byref = 0;\n \n+  /* Make sure that the vtab for the declared type is completed.  */\n+  if (sym->ts.type == BT_CLASS)\n+    {\n+      gfc_component *c = gfc_find_component (sym->ts.u.derived,\n+\t\t\t\t\t     \"$data\", true, true);\n+      if (!c->ts.u.derived->backend_decl)\n+\tgfc_find_derived_vtab (c->ts.u.derived, true);\n+    }\n+\n   if ((sym->attr.dummy && ! sym->attr.function) || (sym->attr.result && byref))\n     {\n       /* Return via extra parameter.  */"}, {"sha": "dfd38cc7e778272c8bc89c8ac3648e8f31faa4bd", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 105, "deletions": 136, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -1532,141 +1532,11 @@ get_proc_ptr_comp (gfc_expr *e)\n }\n \n \n-/* Select a class typebound procedure at runtime.  */\n-static void\n-select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n-\t\t   tree declared, gfc_expr *expr)\n-{\n-  tree end_label;\n-  tree label;\n-  tree tmp;\n-  tree hash;\n-  stmtblock_t body;\n-  gfc_class_esym_list *next_elist, *tmp_elist;\n-  gfc_se tmpse;\n-\n-  /* Convert the hash expression.  */\n-  gfc_init_se (&tmpse, NULL);\n-  gfc_conv_expr (&tmpse, elist->hash_value);\n-  gfc_add_block_to_block (&se->pre, &tmpse.pre);\n-  hash = gfc_evaluate_now (tmpse.expr, &se->pre);\n-  gfc_add_block_to_block (&se->post, &tmpse.post);\n-\n-  /* Fix the function type to be that of the declared type method.  */\n-  declared = gfc_create_var (TREE_TYPE (declared), \"method\");\n-\n-  end_label = gfc_build_label_decl (NULL_TREE);\n-\n-  gfc_init_block (&body);\n-\n-  /* Go through the list of extensions.  */\n-  for (; elist; elist = next_elist)\n-    {\n-      /* This case has already been added.  */\n-      if (elist->derived == NULL)\n-\tgoto free_elist;\n-\n-      /* Skip abstract base types.  */\n-      if (elist->derived->attr.abstract)\n-       goto free_elist;\n-\n-      /* Run through the chain picking up all the cases that call the\n-\t same procedure.  */\n-      tmp_elist = elist;\n-      for (; elist; elist = elist->next)\n-\t{\n-\t  tree cval;\n-\n-\t  if (elist->esym != tmp_elist->esym)\n-\t    continue;\n-\n-\t  cval = build_int_cst (TREE_TYPE (hash),\n-\t\t\t\telist->derived->hash_value);\n-\t  /* Build a label for the hash value.  */\n-\t  label = gfc_build_label_decl (NULL_TREE);\n-\t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t     cval, NULL_TREE, label);\n-\t  gfc_add_expr_to_block (&body, tmp);\n-\n-\t  /* Null the reference the derived type so that this case is\n-\t     not used again.  */\n-\t  elist->derived = NULL;\n-\t}\n-\n-      elist = tmp_elist;\n-\n-      /* Get a pointer to the procedure,  */\n-      tmp = gfc_get_symbol_decl (elist->esym);\n-      if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n-\t{\n-\t  gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n-\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n-\t}\n-\n-      /* Assign the pointer to the appropriate procedure.  */\n-      gfc_add_modify (&body, declared,\n-\t\t      fold_convert (TREE_TYPE (declared), tmp));\n-\n-      /* Break to the end of the construct.  */\n-      tmp = build1_v (GOTO_EXPR, end_label);\n-      gfc_add_expr_to_block (&body, tmp);\n-\n-      /* Free the elists as we go; freeing them in gfc_free_expr causes\n-\t segfaults because it occurs too early and too often.  */\n-    free_elist:\n-      next_elist = elist->next;\n-      if (elist->hash_value)\n-\tgfc_free_expr (elist->hash_value);\n-      gfc_free (elist);\n-      elist = NULL;\n-    }\n-\n-  /* Default is an error.  */\n-  label = gfc_build_label_decl (NULL_TREE);\n-  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n-\t\t     NULL_TREE, NULL_TREE, label);\n-  gfc_add_expr_to_block (&body, tmp);\n-  tmp = gfc_trans_runtime_error (true, &expr->where,\n-\t\t\"internal error: bad hash value in dynamic dispatch\");\n-  gfc_add_expr_to_block (&body, tmp);\n-\n-  /* Write the switch expression.  */\n-  tmp = gfc_finish_block (&body);\n-  tmp = build3_v (SWITCH_EXPR, hash, tmp, NULL_TREE);\n-  gfc_add_expr_to_block (&se->pre, tmp);\n-\n-  tmp = build1_v (LABEL_EXPR, end_label);\n-  gfc_add_expr_to_block (&se->pre, tmp);\n-\n-  se->expr = declared;\n-  return;\n-}\n-\n-\n static void\n conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)\n {\n   tree tmp;\n \n-  if (expr && expr->symtree\n-\t&& expr->value.function.class_esym)\n-    {\n-      if (!sym->backend_decl)\n-\tsym->backend_decl = gfc_get_extern_function_decl (sym);\n-\n-      tmp = sym->backend_decl;\n-\n-      if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n-\t{\n-\t  gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n-\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n-\t}\n-\n-      select_class_proc (se, expr->value.function.class_esym,\n-\t\t\t tmp, expr);\n-      return;\n-    }\n-\n   if (gfc_is_proc_ptr_comp (expr, NULL))\n     tmp = get_proc_ptr_comp (expr);\n   else if (sym->attr.dummy)\n@@ -2614,8 +2484,9 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \n   /* Remember the vtab corresponds to the derived type\n     not to the class declared type.  */\n-  vtab = gfc_find_derived_vtab (e->ts.u.derived);\n+  vtab = gfc_find_derived_vtab (e->ts.u.derived, true);\n   gcc_assert (vtab);\n+  gfc_trans_assign_vtab_procs (&parmse->pre, e->ts.u.derived, vtab);\n   tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n   gfc_add_modify (&parmse->pre, ctree,\n \t\t  fold_convert (TREE_TYPE (ctree), tmp));\n@@ -4463,7 +4334,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       if (!c->expr || cm->attr.allocatable)\n         continue;\n \n-      if (cm->ts.type == BT_CLASS)\n+      if (cm->ts.type == BT_CLASS && !cm->attr.proc_pointer)\n \t{\n \t  gfc_component *data;\n \t  data = gfc_find_component (cm->ts.u.derived, \"$data\", true, true);\n@@ -4484,10 +4355,11 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       else if (cm->initializer && cm->initializer->expr_type != EXPR_NULL\n \t       && strcmp (cm->name, \"$extends\") == 0)\n \t{\n+\t  tree vtab;\n \t  gfc_symbol *vtabs;\n \t  vtabs = cm->initializer->symtree->n.sym;\n-\t  val = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtabs));\n-\t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n+\t  vtab = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtabs));\n+\t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, vtab);\n \t}\n       else\n \t{\n@@ -5579,6 +5451,103 @@ gfc_trans_assign (gfc_code * code)\n }\n \n \n+/* Generate code to assign typebound procedures to a derived vtab.  */\n+void gfc_trans_assign_vtab_procs (stmtblock_t *block, gfc_symbol *dt,\n+\t\t\t\t  gfc_symbol *vtab)\n+{\n+  gfc_component *cmp;\n+  tree vtb;\n+  tree ctree;\n+  tree proc;\n+  tree cond = NULL_TREE;\n+  stmtblock_t body;\n+  bool seen_extends;\n+\n+  /* Point to the first procedure pointer.  */\n+  cmp = gfc_find_component (vtab->ts.u.derived, \"$extends\", true, true);\n+\n+  seen_extends = (cmp != NULL);\n+\n+  vtb = gfc_get_symbol_decl (vtab);\n+\n+  if (seen_extends)\n+    {\n+      cmp = cmp->next;\n+      if (!cmp)\n+\treturn;\n+      ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl),\n+\t\t           vtb, cmp->backend_decl, NULL_TREE);\n+      cond = fold_build2 (EQ_EXPR, boolean_type_node, ctree,\n+\t\t\t   build_int_cst (TREE_TYPE (ctree), 0));\n+    }\n+  else\n+    {\n+      cmp = vtab->ts.u.derived->components; \n+    }\n+\n+  gfc_init_block (&body);\n+  for (; cmp; cmp = cmp->next)\n+    {\n+      gfc_symbol *target = NULL;\n+      \n+      /* Generic procedure - build its vtab.  */\n+      if (cmp->ts.type == BT_DERIVED && !cmp->tb)\n+\t{\n+\t  gfc_symbol *vt = cmp->ts.interface;\n+\n+\t  if (vt == NULL)\n+\t    {\n+\t      /* Use association loses the interface.  Obtain the vtab\n+\t\t by name instead.  */\n+\t      char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n+\t      sprintf (name, \"vtab$%s$%s\", vtab->ts.u.derived->name,\n+\t\t       cmp->name);\n+\t      gfc_find_symbol (name, vtab->ns, 0, &vt);\n+\t      if (vt == NULL)\n+\t\tcontinue;\n+\t    }\n+\n+\t  gfc_trans_assign_vtab_procs (&body, dt, vt);\n+\t  ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl),\n+\t\t\t       vtb, cmp->backend_decl, NULL_TREE);\n+\t  proc = gfc_get_symbol_decl (vt);\n+\t  proc = gfc_build_addr_expr (TREE_TYPE (ctree), proc);\n+\t  gfc_add_modify (&body, ctree, proc);\n+\t  continue;\n+\t}\n+\n+      /* This is required when typebound generic procedures are called\n+\t with derived type targets.  The specific procedures do not get\n+\t added to the vtype, which remains \"empty\".  */\n+      if (cmp->tb && cmp->tb->u.specific && cmp->tb->u.specific->n.sym)\n+\ttarget = cmp->tb->u.specific->n.sym;\n+      else\n+\t{\n+\t  gfc_symtree *st;\n+\t  st = gfc_find_typebound_proc (dt, NULL, cmp->name, false, NULL);\n+\t  if (st->n.tb && st->n.tb->u.specific)\n+\t    target = st->n.tb->u.specific->n.sym;\n+\t}\n+\n+      if (!target)\n+\tcontinue;\n+\n+      ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl),\n+\t\t\t   vtb, cmp->backend_decl, NULL_TREE);\n+      proc = gfc_get_symbol_decl (target);\n+      proc = gfc_build_addr_expr (TREE_TYPE (ctree), proc);\n+      gfc_add_modify (&body, ctree, proc);\n+    }\n+\n+  proc = gfc_finish_block (&body);\n+\n+  if (seen_extends)\n+    proc = build3_v (COND_EXPR, cond, proc, build_empty_stmt (input_location));\n+\n+  gfc_add_expr_to_block (block, proc);\n+}\n+\n+\n /* Translate an assignment to a CLASS object\n    (pointer or ordinary assignment).  */\n \n@@ -5620,9 +5589,9 @@ gfc_trans_class_assign (gfc_code *code)\n \t{\n \t  gfc_symbol *vtab;\n \t  gfc_symtree *st;\n-\t  vtab = gfc_find_derived_vtab (code->expr2->ts.u.derived);\n+\t  vtab = gfc_find_derived_vtab (code->expr2->ts.u.derived, true);\n \t  gcc_assert (vtab);\n-\n+\t  gfc_trans_assign_vtab_procs (&block, code->expr2->ts.u.derived, vtab);\n \t  rhs = gfc_get_expr ();\n \t  rhs->expr_type = EXPR_VARIABLE;\n \t  gfc_find_sym_tree (vtab->name, NULL, 1, &st);"}, {"sha": "0a2ad536ef16e47218c54ecb6bc2334c43b6e291", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -4278,8 +4278,9 @@ gfc_trans_allocate (gfc_code * code)\n \n \t      if (ts->type == BT_DERIVED)\n \t\t{\n-\t\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n+\t\t  vtab = gfc_find_derived_vtab (ts->u.derived, true);\n \t\t  gcc_assert (vtab);\n+\t\t  gfc_trans_assign_vtab_procs (&block, ts->u.derived, vtab);\n \t\t  gfc_init_se (&lse, NULL);\n \t\t  lse.want_pointer = 1;\n \t\t  gfc_conv_expr (&lse, lhs);"}, {"sha": "8e2b68846c0359032ecf7378d0b9850385f17ab0", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -492,6 +492,9 @@ tree gfc_trans_assignment (gfc_expr *, gfc_expr *, bool, bool);\n /* Generate code for a pointer assignment.  */\n tree gfc_trans_pointer_assignment (gfc_expr *, gfc_expr *);\n \n+/* Generate code to assign typebound procedures to a derived vtab.  */\n+void gfc_trans_assign_vtab_procs (stmtblock_t*, gfc_symbol*, gfc_symbol*);\n+\n /* Initialize function decls for library functions.  */\n void gfc_build_intrinsic_lib_fndecls (void);\n /* Create function decls for IO library functions.  */"}, {"sha": "7b9a134ba49b1f41e681e3a52810ecabbd7d3386", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -1,3 +1,41 @@\n+2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/42274\n+\t* gfortran.dg/class_16.f03: New test.\n+\n+2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/42274\n+\t* gfortran.dg/class_15.f03: New.\n+\n+2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43326\n+\t* gfortran.dg/dynamic_dispatch_9.f03: New test.\n+\n+2010-04-29  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/43492\n+\t* gfortran.dg/generic_22.f03 : New test.\n+\n+2010-04-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42353\n+\t* gfortran.dg/class_14.f03: New test.\n+\n+2010-04-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/42680\n+\t* gfortran.dg/interface_32.f90: New test.\n+\n+2009-04-29  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41829\n+\t* gfortran.dg/dynamic_dispatch_5.f03 : Change to \"run\".\n+\t* gfortran.dg/dynamic_dispatch_7.f03 : New test.\n+\t* gfortran.dg/dynamic_dispatch_8.f03 : New test.\n+\n 2010-04-28  Mike Stump  <mikestump@comcast.net>\n \n \t* g++.dg/uninit-pred-1_b.C: Use dg-message instead of"}, {"sha": "9b06b01f1ffa3587bdeffe18fcd9f93ab4d9c958", "filename": "gcc/testsuite/gfortran.dg/class_14.f03", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_14.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_14.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_14.f03?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do \"compile\" }\n+! Test the final fix for PR42353, in which a compilation error was\n+! occurring because the derived type of the initializer of the vtab\n+! component '$extends' was not the same as that of the component.\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de>\n+!\n+module abstract_vector\n+  implicit none\n+\n+  type, abstract :: vector_class\n+  end type vector_class\n+end module abstract_vector\n+!-------------------------\n+module concrete_vector\n+  use abstract_vector\n+  implicit none\n+\n+  type, extends(vector_class) :: trivial_vector_type\n+  end type trivial_vector_type\n+\n+  private :: my_assign\n+contains\n+  subroutine my_assign (this,v)\n+    class(trivial_vector_type), intent(inout) :: this\n+    class(vector_class),        intent(in)    :: v\n+  end subroutine my_assign\n+end module concrete_vector\n+!---------------------------\n+module concrete_gradient\n+  use abstract_vector\n+  implicit none\n+\n+  type, abstract, extends(vector_class) :: gradient_class\n+  end type gradient_class\n+\n+  type, extends(gradient_class) :: trivial_gradient_type\n+  end type trivial_gradient_type\n+\n+  private :: my_assign\n+contains\n+  subroutine my_assign (this,v)\n+    class(trivial_gradient_type), intent(inout) :: this\n+    class(vector_class),          intent(in)    :: v\n+  end subroutine my_assign\n+end module concrete_gradient\n+!----------------------------\n+module concrete_inner_product\n+  use concrete_vector\n+  use concrete_gradient\n+  implicit none\n+end module concrete_inner_product\n+! { dg-final { cleanup-modules \"abstract_vector concrete_vector\" } }\n+! { dg-final { cleanup-modules \"concrete_gradient concrete_inner_product\" } }"}, {"sha": "fbeb2a7e4cfbc62b7accc0d15622041920898d2f", "filename": "gcc/testsuite/gfortran.dg/class_15.f03", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_15.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_15.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_15.f03?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+!\n+! PR 42274: [fortran-dev Regression] ICE: segmentation fault\n+!\n+! Original test case by Salvatore Filippone <sfilippone@uniroma2.it>\n+! Modified by Janus Weil <janus@gcc.gnu.org>\n+\n+module mod_A\n+  type :: t1\n+  contains \n+    procedure,nopass :: fun\n+  end type\n+contains\n+  logical function fun()\n+  end function\n+end module\n+\n+module mod_B\n+  use mod_A\n+  type, extends(t1) :: t2\n+  contains\n+    procedure :: sub1\n+  end type\n+contains \n+  subroutine sub1(a)\n+    class(t2) :: a\n+  end subroutine\n+end module\n+\n+module mod_C\n+contains \n+  subroutine sub2(b)\n+    use mod_B\n+    type(t2) :: b\n+  end subroutine\n+end module\n+\n+module mod_D\n+  use mod_A\n+  use mod_C\n+end module\n+\n+! { dg-final { cleanup-modules \"mod_A mod_B mod_C mod_D\" } }"}, {"sha": "7d0d38f80bdb3a9b34c338157d7e54a3a4f897ef", "filename": "gcc/testsuite/gfortran.dg/class_16.f03", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_16.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_16.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_16.f03?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+!\n+! PR 43896: [fortran-dev Regression] ICE in gfc_conv_variable, at fortran/trans-expr.c:551\n+!\n+! Contributed by Fran Martinez Fadrique <fmartinez@gmv.com>\n+\n+module m_rotation_matrix\n+\n+  type t_rotation_matrix\n+    contains\n+      procedure :: array => rotation_matrix_array\n+  end type\n+\n+contains\n+\n+  function rotation_matrix_array( rot ) result(array)\n+    class(t_rotation_matrix) :: rot\n+    double precision, dimension(3,3)    :: array\n+  end function\n+\n+end module\n+\n+! { dg-final { cleanup-modules \"m_rotation_matrix\" } }"}, {"sha": "036c20092d57876d6749e7dd752e7fe1ce98ee8a", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_5.f03", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_5.f03?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do compile }\n+! { dg-do run }\n ! Tests the fix for PR4164656 in which the call to a%a%scal failed to compile.\n !\n ! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n@@ -166,7 +166,8 @@ subroutine s_scals(d,a,info)\n     integer :: err_act\n     character(len=20)  :: name='csnmi'\n     logical, parameter :: debug=.false.\n-    print *, \"s_scals\"\n+!    print *, \"s_scals\"\n+    info = 0\n     call a%a%scal(d,info)\n     return\n   end subroutine s_scals\n@@ -180,6 +181,7 @@ end module s_mat_mod\n     b%a => c\n     a => b\n     call a%scal (1.0_spk_, info)\n+    if (info .ne. 700) call abort\n end\n ! { dg-final { cleanup-modules \"const_mod base_mat_mod s_base_mat_mod s_mat_mod\" } }\n "}, {"sha": "3cd05104728780c6d678ce8972762c1d9e9728b1", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_7.f03", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_7.f03?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -7,8 +7,8 @@\n ! Contributed by Janus Weil <janus@gcc.gnu.org>\n !\n module m1\n-  type  :: t1\n-  contains \n+  type :: t1\n+  contains\n     procedure :: sizeof\n   end type\n contains\n@@ -17,11 +17,10 @@ integer function sizeof(a)\n     sizeof = 1\n   end function sizeof\n end module\n-\n-\n+\t\n module m2\n   use m1\n-  type, extends(t1) :: t2    \n+  type, extends(t1) :: t2\n   contains\n     procedure :: sizeof => sizeof2\n   end type\n@@ -32,19 +31,18 @@ integer function sizeof2(a)\n   end function\n end module\n \n-\n module m3\n   use m2\n   type :: t3\n-    class(t1), pointer  :: a \n+  class(t1), pointer :: a\n   contains\n     procedure :: sizeof => sizeof3\n   end type\n-contains \n+contains\n   integer function sizeof3(a)\n     class(t3) :: a\n     sizeof3 = a%a%sizeof()\n-  end function \n+  end function\n end module\n \n   use m1\n@@ -57,8 +55,7 @@ integer function sizeof3(a)\n   if ((z%sizeof() .ne. 1) .or. (z%a%sizeof() .ne. 1)) call abort\n   z%a => y\n   if ((z%sizeof() .ne. 2) .or. (z%a%sizeof() .ne. 2)) call abort\n-\n end\n \n ! { dg-final { cleanup-modules \"m1 m2 m3\" } }\n-\n+ \t"}, {"sha": "4f3d8069b433764be2035a00bc25a216c174d429", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_8.f03", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_8.f03?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -0,0 +1,108 @@\n+! { dg-do run }\n+!\n+! PR 41829: [OOP] Runtime error with dynamic dispatching.  Tests\n+! dynamic dispatch in a case where the caller knows nothing about\n+! the dynamic type at compile time.\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+!\n+module foo_mod\n+  type foo\n+    integer :: i \n+  contains\n+    procedure, pass(a) :: doit\n+    procedure, pass(a) :: getit\n+  end type foo\n+\n+  private doit,getit\n+contains\n+  subroutine  doit(a) \n+    class(foo) :: a\n+    \n+    a%i = 1\n+!    write(*,*) 'FOO%DOIT base version'\n+  end subroutine doit\n+  function getit(a) result(res)\n+    class(foo) :: a\n+    integer :: res\n+\n+    res = a%i\n+  end function getit\n+\n+end module foo_mod\n+module foo2_mod\n+  use foo_mod\n+\n+  type, extends(foo) :: foo2\n+    integer :: j\n+  contains\n+    procedure, pass(a) :: doit  => doit2\n+    procedure, pass(a) :: getit => getit2\n+  end type foo2\n+  \n+  private doit2, getit2\n+\n+contains\n+\n+  subroutine  doit2(a) \n+    class(foo2) :: a\n+    \n+    a%i = 2\n+    a%j = 3\n+!    write(*,*) 'FOO2%DOIT derived version'\n+  end subroutine doit2\n+  function getit2(a) result(res)\n+    class(foo2) :: a\n+    integer :: res\n+\n+    res = a%j\n+  end function getit2\n+    \n+end module foo2_mod\n+\n+module bar_mod \n+  use foo_mod\n+  type bar \n+    class(foo), allocatable :: a\n+  contains \n+    procedure, pass(a) :: doit\n+    procedure, pass(a) :: getit\n+  end type bar\n+  private doit,getit\n+  \n+contains\n+  subroutine doit(a)\n+    class(bar) :: a\n+    \n+    call a%a%doit()\n+  end subroutine doit\n+  function getit(a) result(res)\n+    class(bar) :: a\n+    integer :: res\n+\n+    res = a%a%getit()\n+  end function getit\n+end module bar_mod\n+\n+\n+program testd10\n+  use foo_mod\n+  use foo2_mod\n+  use bar_mod\n+  \n+  type(bar) :: a\n+\n+  allocate(foo :: a%a)\n+  call a%doit()\n+!  write(*,*) 'Getit value : ', a%getit()\n+  if (a%getit() .ne. 1) call abort\n+  deallocate(a%a)\n+  allocate(foo2 :: a%a)\n+  call a%doit()\n+!  write(*,*) 'Getit value : ', a%getit()\n+  if (a%getit() .ne. 3) call abort\n+\n+end program testd10\n+\n+! { dg-final { cleanup-modules \"foo_mod foo2_mod bar_mod\" } }\n+"}, {"sha": "bf6a3d5587027150aa017eb37c3b2b78f85a4058", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_9.f03", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_9.f03?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do run }\n+!\n+! [OOP] Ensure that different specifc interfaces are\n+! handled properly by dynamic dispatch.\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+!\n+module m\n+\n+ type :: t\n+ contains\n+  procedure :: a\n+  generic :: gen => a\n+ end type\n+\n+ type,extends(t) :: t2\n+ contains\n+  procedure :: b\n+  generic :: gen => b\n+ end type\n+\n+contains\n+\n+  real function a(ct,x)\n+    class(t) :: ct\n+    real :: x\n+    a=2*x\n+  end function\n+\n+  integer function b(ct,x)\n+    class(t2) :: ct\n+    integer :: x\n+    b=3*x\n+  end function\n+\n+end\n+\n+\n+ use m\n+ class(t), allocatable :: o1\n+ type (t) :: t1\n+ class(t2), allocatable :: o2\n+\n+ allocate(o1)\n+ allocate(o2)\n+\n+ if (t1%gen(2.0) .ne. o1%gen(2.0)) call abort\n+ if (t1%gen(2.0) .ne. o2%gen(2.0)) call abort\n+ if (o2%gen(3) .ne. 9) call abort\n+\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }\n+"}, {"sha": "1da49dee923a30f79a9e12793be0f2afbaba17a5", "filename": "gcc/testsuite/gfortran.dg/generic_22.f03", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_22.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_22.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_22.f03?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! Test the fix for PR43492, in which the generic call caused and ICE.\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+!\n+module base_mod\n+  \n+  type  :: base_mat\n+    integer, private     :: m, n\n+  contains \n+    procedure, pass(a) :: transp1 => base_transp1\n+    generic, public    :: transp => transp1\n+    procedure, pass(a) :: transc1 => base_transc1\n+    generic, public    :: transc => transc1\n+  end type base_mat\n+\n+contains\n+\n+  subroutine base_transp1(a)\n+    implicit none \n+    \n+    class(base_mat), intent(inout) :: a\n+    integer :: itmp\n+    itmp        = a%m\n+    a%m         = a%n\n+    a%n         = itmp\n+  end subroutine base_transp1\n+  subroutine base_transc1(a)\n+    implicit none \n+    class(base_mat), intent(inout) :: a\n+    \n+    call a%transp() \n+!!$    call a%transp1() \n+  end subroutine base_transc1\n+\n+\n+end module base_mod\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "6cdb091aecc7186c1c9932e0a32ec79dbe1d54d4", "filename": "gcc/testsuite/gfortran.dg/interface_32.f90", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_32.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eece1eb9acd1262e3b462ef9a1a09013e420bfed/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_32.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_32.f90?ref=eece1eb9acd1262e3b462ef9a1a09013e420bfed", "patch": "@@ -0,0 +1,81 @@\n+! { dg-do compile }\n+module m1\n+  implicit none\n+\n+  type, abstract :: vector_class\n+  end type vector_class\n+end module m1\n+!---------------------------------------------------------------\n+module m2\n+  use m1\n+  implicit none\n+\n+  type, abstract :: inner_product_class\n+  contains\n+    procedure(dot), deferred :: dot_v_v\n+    procedure(dot), deferred :: dot_g_g\n+    procedure(sub), deferred :: D_times_v\n+    procedure(sub), deferred :: D_times_g\n+  end type inner_product_class\n+\n+  abstract interface\n+    function dot (this,a,b)\n+      import :: inner_product_class\n+      import :: vector_class\n+      class(inner_product_class), intent(in) :: this\n+      class(vector_class),        intent(in) :: a,b\n+      real                                   :: dot\n+    end function\n+    subroutine sub (this,a)\n+      import :: inner_product_class\n+      import :: vector_class\n+      class(inner_product_class), intent(in)    :: this\n+      class(vector_class),        intent(inout) :: a\n+    end subroutine\n+  end interface\n+end module m2\n+!---------------------------------------------------------------\n+module m3\n+  use :: m1\n+  use :: m2\n+  implicit none\n+  private\n+  public :: gradient_class\n+\n+  type, abstract, extends(vector_class) :: gradient_class\n+    class(inner_product_class), pointer :: my_inner_product => NULL()\n+  contains\n+    procedure, non_overridable  :: inquire_inner_product\n+    procedure(op_g_v), deferred :: to_vector\n+  end type gradient_class\n+\n+  abstract interface\n+    subroutine op_g_v(this,v)\n+      import vector_class\n+      import gradient_class\n+      class(gradient_class), intent(in)    :: this\n+      class(vector_class),   intent(inout) :: v\n+    end subroutine\n+  end interface\n+contains\n+  function inquire_inner_product (this)\n+    class(gradient_class)               :: this\n+    class(inner_product_class), pointer :: inquire_inner_product\n+\n+    inquire_inner_product => this%my_inner_product\n+  end function inquire_inner_product\n+end module m3\n+!---------------------------------------------------------------\n+module m4\n+  use m3\n+  use m2\n+  implicit none\n+contains\n+  subroutine cg (g_initial)\n+    class(gradient_class),  intent(in)    :: g_initial\n+\n+    class(inner_product_class), pointer   :: ip_save\n+    ip_save => g_initial%inquire_inner_product()\n+  end subroutine cg\n+end module m4\n+! { dg-final { cleanup-modules \"m1 m2 m3 m4\" } }"}]}