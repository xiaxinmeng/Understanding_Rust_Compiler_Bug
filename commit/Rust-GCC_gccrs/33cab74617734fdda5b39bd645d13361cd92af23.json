{"sha": "33cab74617734fdda5b39bd645d13361cd92af23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNjYWI3NDYxNzczNGZkZGE1YjM5YmQ2NDVkMTMzNjFjZDkyYWYyMw==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2016-10-27T10:19:13Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2016-10-27T10:19:13Z"}, "message": "Adapt other atomic operations to ARMv8-M Baseline\n\n2016-10-27  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    * config/arm/arm.c (arm_split_atomic_op): Add function comment.  Add\n    logic to to decide whether to copy over old value to register for new\n    value.\n    * config/arm/sync.md: Add comments explaning why mode and code\n    attribute are not defined in iterators.md\n    (thumb1_atomic_op_str): New code attribute.\n    (thumb1_atomic_newop_str): Likewise.\n    (thumb1_atomic_fetch_op_str): Likewise.\n    (thumb1_atomic_fetch_newop_str): Likewise.\n    (thumb1_atomic_fetch_oldop_str): Likewise.\n    (atomic_exchange<mode>): Add new ARMv8-M Baseline only alternatives to\n    mirror the more restrictive constraints of the Thumb-1 insns after\n    split compared to Thumb-2 counterpart insns.\n    (atomic_<sync_optab><mode>): Likewise.  Add comment to keep constraints\n    in sync with non atomic version.\n    (atomic_nand<mode>): Likewise.\n    (atomic_fetch_<sync_optab><mode>): Likewise.\n    (atomic_fetch_nand<mode>): Likewise.\n    (atomic_<sync_optab>_fetch<mode>): Likewise.\n    (atomic_nand_fetch<mode>): Likewise.\n    * config/arm/thumb1.md (thumb1_addsi3): Add comment to keep contraint\n    in sync with atomic version.\n    (thumb1_subsi3_insn): Likewise.\n    (thumb1_andsi3_insn): Likewise.\n    (thumb1_iorsi3_insn): Likewise.\n    (thumb1_xorsi3_insn): Likewise.\n\nFrom-SVN: r241614", "tree": {"sha": "3908dbafeb8193cf3995942698b7b0604f5cb7a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3908dbafeb8193cf3995942698b7b0604f5cb7a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33cab74617734fdda5b39bd645d13361cd92af23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33cab74617734fdda5b39bd645d13361cd92af23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33cab74617734fdda5b39bd645d13361cd92af23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33cab74617734fdda5b39bd645d13361cd92af23/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5300487f1c9c92f1f5bbe1063a0240154815f47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5300487f1c9c92f1f5bbe1063a0240154815f47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5300487f1c9c92f1f5bbe1063a0240154815f47"}], "stats": {"total": 198, "additions": 161, "deletions": 37}, "files": [{"sha": "d1d53deada11be16efc2d667bdd5c761d4b7ee43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33cab74617734fdda5b39bd645d13361cd92af23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33cab74617734fdda5b39bd645d13361cd92af23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33cab74617734fdda5b39bd645d13361cd92af23", "patch": "@@ -1,3 +1,32 @@\n+2016-10-27  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* config/arm/arm.c (arm_split_atomic_op): Add function comment.  Add\n+\tlogic to to decide whether to copy over old value to register for new\n+\tvalue.\n+\t* config/arm/sync.md: Add comments explaning why mode and code\n+\tattribute are not defined in iterators.md\n+\t(thumb1_atomic_op_str): New code attribute.\n+\t(thumb1_atomic_newop_str): Likewise.\n+\t(thumb1_atomic_fetch_op_str): Likewise.\n+\t(thumb1_atomic_fetch_newop_str): Likewise.\n+\t(thumb1_atomic_fetch_oldop_str): Likewise.\n+\t(atomic_exchange<mode>): Add new ARMv8-M Baseline only alternatives to\n+\tmirror the more restrictive constraints of the Thumb-1 insns after\n+\tsplit compared to Thumb-2 counterpart insns.\n+\t(atomic_<sync_optab><mode>): Likewise.  Add comment to keep constraints\n+\tin sync with non atomic version.\n+\t(atomic_nand<mode>): Likewise.\n+\t(atomic_fetch_<sync_optab><mode>): Likewise.\n+\t(atomic_fetch_nand<mode>): Likewise.\n+\t(atomic_<sync_optab>_fetch<mode>): Likewise.\n+\t(atomic_nand_fetch<mode>): Likewise.\n+\t* config/arm/thumb1.md (thumb1_addsi3): Add comment to keep contraint\n+\tin sync with atomic version.\n+\t(thumb1_subsi3_insn): Likewise.\n+\t(thumb1_andsi3_insn): Likewise.\n+\t(thumb1_iorsi3_insn): Likewise.\n+\t(thumb1_xorsi3_insn): Likewise.\n+\n 2016-10-27  Nick Clifton  <nickc@redhat.com>\n \n \t* plugin.c (register_plugin_info): Produce an error message if the"}, {"sha": "3c4c7042d9c2101619722b5822b3d1ca37d637b9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33cab74617734fdda5b39bd645d13361cd92af23/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33cab74617734fdda5b39bd645d13361cd92af23/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=33cab74617734fdda5b39bd645d13361cd92af23", "patch": "@@ -28342,6 +28342,15 @@ arm_split_compare_and_swap (rtx operands[])\n     emit_label (label2);\n }\n \n+/* Split an atomic operation pattern.  Operation is given by CODE and is one\n+   of PLUS, MINUS, IOR, XOR, SET (for an exchange operation) or NOT (for a nand\n+   operation).  Operation is performed on the content at MEM and on VALUE\n+   following the memory model MODEL_RTX.  The content at MEM before and after\n+   the operation is returned in OLD_OUT and NEW_OUT respectively while the\n+   success of the operation is returned in COND.  Using a scratch register or\n+   an operand register for these determines what result is returned for that\n+   pattern.  */\n+\n void\n arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n \t\t     rtx value, rtx model_rtx, rtx cond)\n@@ -28350,6 +28359,7 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n   machine_mode mode = GET_MODE (mem);\n   machine_mode wmode = (mode == DImode ? DImode : SImode);\n   rtx_code_label *label;\n+  bool all_low_regs, bind_old_new;\n   rtx x;\n \n   bool is_armv8_sync = arm_arch8 && is_mm_sync (model);\n@@ -28384,6 +28394,28 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n \n   arm_emit_load_exclusive (mode, old_out, mem, use_acquire);\n \n+  /* Does the operation require destination and first operand to use the same\n+     register?  This is decided by register constraints of relevant insn\n+     patterns in thumb1.md.  */\n+  gcc_assert (!new_out || REG_P (new_out));\n+  all_low_regs = REG_P (value) && REGNO_REG_CLASS (REGNO (value)) == LO_REGS\n+\t\t && new_out && REGNO_REG_CLASS (REGNO (new_out)) == LO_REGS\n+\t\t && REGNO_REG_CLASS (REGNO (old_out)) == LO_REGS;\n+  bind_old_new =\n+    (TARGET_THUMB1\n+     && code != SET\n+     && code != MINUS\n+     && (code != PLUS || (!all_low_regs && !satisfies_constraint_L (value))));\n+\n+  /* We want to return the old value while putting the result of the operation\n+     in the same register as the old value so copy the old value over to the\n+     destination register and use that register for the operation.  */\n+  if (old_out && bind_old_new)\n+    {\n+      emit_move_insn (new_out, old_out);\n+      old_out = new_out;\n+    }\n+\n   switch (code)\n     {\n     case SET:"}, {"sha": "e7be492ba60f9a4d1964922b53955866960c0450", "filename": "gcc/config/arm/sync.md", "status": "modified", "additions": 80, "deletions": 37, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33cab74617734fdda5b39bd645d13361cd92af23/gcc%2Fconfig%2Farm%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33cab74617734fdda5b39bd645d13361cd92af23/gcc%2Fconfig%2Farm%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsync.md?ref=33cab74617734fdda5b39bd645d13361cd92af23", "patch": "@@ -248,15 +248,15 @@\n   [(set_attr \"arch\" \"32,v8mb,v8mb,v8mb\")])\n \n (define_insn_and_split \"atomic_exchange<mode>\"\n-  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r\")\t;; output\n-\t(match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua\"))\t;; memory\n+  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r,&r\")\t;; output\n+\t(match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua,Ua\"))\t;; memory\n    (set (match_dup 1)\n \t(unspec_volatile:QHSD\n-\t  [(match_operand:QHSD 2 \"s_register_operand\" \"r\")\t;; input\n+\t  [(match_operand:QHSD 2 \"s_register_operand\" \"r,r\")\t;; input\n \t   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n \t  VUNSPEC_ATOMIC_XCHG))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n+   (clobber (match_scratch:SI 4 \"=&r,&l\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -265,7 +265,11 @@\n     arm_split_atomic_op (SET, operands[0], NULL, operands[1],\n \t\t\t operands[2], operands[3], operands[4]);\n     DONE;\n-  })\n+  }\n+  [(set_attr \"arch\" \"32,v8mb\")])\n+\n+;; The following mode and code attribute are defined here because they are\n+;; specific to atomics and are not needed anywhere else.\n \n (define_mode_attr atomic_op_operand\n   [(QI \"reg_or_int_operand\")\n@@ -276,16 +280,24 @@\n (define_mode_attr atomic_op_str\n   [(QI \"rn\") (HI \"rn\") (SI \"rn\") (DI \"r\")])\n \n+(define_code_attr thumb1_atomic_op_str\n+  [(ior \"l,l\") (xor \"l,l\") (and \"l,l\") (plus \"lIJL,r\") (minus \"lPd,lPd\")])\n+\n+(define_code_attr thumb1_atomic_newop_str\n+  [(ior \"&l,&l\") (xor \"&l,&l\") (and \"&l,&l\") (plus \"&l,&r\") (minus \"&l,&l\")])\n+\n+;; Constraints of this pattern must be at least as strict as those of the non\n+;; atomic operations in thumb1.md and aim to be as permissive.\n (define_insn_and_split \"atomic_<sync_optab><mode>\"\n-  [(set (match_operand:QHSD 0 \"mem_noofs_operand\" \"+Ua\")\n+  [(set (match_operand:QHSD 0 \"mem_noofs_operand\" \"+Ua,Ua,Ua\")\n \t(unspec_volatile:QHSD\n \t  [(syncop:QHSD (match_dup 0)\n-\t     (match_operand:QHSD 1 \"<atomic_op_operand>\" \"<atomic_op_str>\"))\n+\t     (match_operand:QHSD 1 \"<atomic_op_operand>\" \"<atomic_op_str>,<thumb1_atomic_op_str>\"))\n \t   (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n \t  VUNSPEC_ATOMIC_OP))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:QHSD 3 \"=&r\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n+   (clobber (match_scratch:QHSD 3 \"=&r,<thumb1_atomic_newop_str>\"))\n+   (clobber (match_scratch:SI 4 \"=&r,&l,&l\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -294,19 +306,22 @@\n     arm_split_atomic_op (<CODE>, NULL, operands[3], operands[0],\n \t\t\t operands[1], operands[2], operands[4]);\n     DONE;\n-  })\n+  }\n+  [(set_attr \"arch\" \"32,v8mb,v8mb\")])\n \n+;; Constraints of this pattern must be at least as strict as those of the non\n+;; atomic NANDs in thumb1.md and aim to be as permissive.\n (define_insn_and_split \"atomic_nand<mode>\"\n-  [(set (match_operand:QHSD 0 \"mem_noofs_operand\" \"+Ua\")\n+  [(set (match_operand:QHSD 0 \"mem_noofs_operand\" \"+Ua,Ua\")\n \t(unspec_volatile:QHSD\n \t  [(not:QHSD\n \t     (and:QHSD (match_dup 0)\n-\t       (match_operand:QHSD 1 \"<atomic_op_operand>\" \"<atomic_op_str>\")))\n+\t       (match_operand:QHSD 1 \"<atomic_op_operand>\" \"<atomic_op_str>,l\")))\n \t   (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n \t  VUNSPEC_ATOMIC_OP))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:QHSD 3 \"=&r\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n+   (clobber (match_scratch:QHSD 3 \"=&r,&l\"))\n+   (clobber (match_scratch:SI 4 \"=&r,&l\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -315,20 +330,38 @@\n     arm_split_atomic_op (NOT, NULL, operands[3], operands[0],\n \t\t\t operands[1], operands[2], operands[4]);\n     DONE;\n-  })\n+  }\n+  [(set_attr \"arch\" \"32,v8mb\")])\n+\n+;; 3 alternatives are needed to represent constraints after split from\n+;; thumb1_addsi3: (i) case where operand1 and destination can be in different\n+;; registers, (ii) case where they are in the same low register and (iii) case\n+;; when they are in the same register without restriction on the register.  We\n+;; disparage slightly alternatives that require copying the old value into the\n+;; register for the new value (see bind_old_new in arm_split_atomic_op).\n+(define_code_attr thumb1_atomic_fetch_op_str\n+  [(ior \"l,l,l\") (xor \"l,l,l\") (and \"l,l,l\") (plus \"lL,?IJ,?r\") (minus \"lPd,lPd,lPd\")])\n \n+(define_code_attr thumb1_atomic_fetch_newop_str\n+  [(ior \"&l,&l,&l\") (xor \"&l,&l,&l\") (and \"&l,&l,&l\") (plus \"&l,&l,&r\") (minus \"&l,&l,&l\")])\n+\n+(define_code_attr thumb1_atomic_fetch_oldop_str\n+  [(ior \"&r,&r,&r\") (xor \"&r,&r,&r\") (and \"&r,&r,&r\") (plus \"&l,&r,&r\") (minus \"&l,&l,&l\")])\n+\n+;; Constraints of this pattern must be at least as strict as those of the non\n+;; atomic operations in thumb1.md and aim to be as permissive.\n (define_insn_and_split \"atomic_fetch_<sync_optab><mode>\"\n-  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r\")\n-\t(match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua\"))\n+  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r,<thumb1_atomic_fetch_oldop_str>\")\n+\t(match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua,Ua,Ua,Ua\"))\n    (set (match_dup 1)\n \t(unspec_volatile:QHSD\n \t  [(syncop:QHSD (match_dup 1)\n-\t     (match_operand:QHSD 2 \"<atomic_op_operand>\" \"<atomic_op_str>\"))\n+\t     (match_operand:QHSD 2 \"<atomic_op_operand>\" \"<atomic_op_str>,<thumb1_atomic_fetch_op_str>\"))\n \t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n \t  VUNSPEC_ATOMIC_OP))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:QHSD 4 \"=&r\"))\n-   (clobber (match_scratch:SI 5 \"=&r\"))]\n+   (clobber (match_scratch:QHSD 4 \"=&r,<thumb1_atomic_fetch_newop_str>\"))\n+   (clobber (match_scratch:SI 5 \"=&r,&l,&l,&l\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -337,21 +370,24 @@\n     arm_split_atomic_op (<CODE>, operands[0], operands[4], operands[1],\n \t\t\t operands[2], operands[3], operands[5]);\n     DONE;\n-  })\n+  }\n+  [(set_attr \"arch\" \"32,v8mb,v8mb,v8mb\")])\n \n+;; Constraints of this pattern must be at least as strict as those of the non\n+;; atomic NANDs in thumb1.md and aim to be as permissive.\n (define_insn_and_split \"atomic_fetch_nand<mode>\"\n-  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r\")\n-\t(match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua\"))\n+  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r,&r\")\n+\t(match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua,Ua\"))\n    (set (match_dup 1)\n \t(unspec_volatile:QHSD\n \t  [(not:QHSD\n \t     (and:QHSD (match_dup 1)\n-\t       (match_operand:QHSD 2 \"<atomic_op_operand>\" \"<atomic_op_str>\")))\n+\t       (match_operand:QHSD 2 \"<atomic_op_operand>\" \"<atomic_op_str>,l\")))\n \t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n \t  VUNSPEC_ATOMIC_OP))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:QHSD 4 \"=&r\"))\n-   (clobber (match_scratch:SI 5 \"=&r\"))]\n+   (clobber (match_scratch:QHSD 4 \"=&r,&l\"))\n+   (clobber (match_scratch:SI 5 \"=&r,&l\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -360,20 +396,23 @@\n     arm_split_atomic_op (NOT, operands[0], operands[4], operands[1],\n \t\t\t operands[2], operands[3], operands[5]);\n     DONE;\n-  })\n+  }\n+  [(set_attr \"arch\" \"32,v8mb\")])\n \n+;; Constraints of this pattern must be at least as strict as those of the non\n+;; atomic operations in thumb1.md and aim to be as permissive.\n (define_insn_and_split \"atomic_<sync_optab>_fetch<mode>\"\n-  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r\")\n+  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r,<thumb1_atomic_newop_str>\")\n \t(syncop:QHSD\n-\t  (match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua\")\n-\t  (match_operand:QHSD 2 \"<atomic_op_operand>\" \"<atomic_op_str>\")))\n+\t  (match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua,Ua,Ua\")\n+\t  (match_operand:QHSD 2 \"<atomic_op_operand>\" \"<atomic_op_str>,<thumb1_atomic_op_str>\")))\n    (set (match_dup 1)\n \t(unspec_volatile:QHSD\n \t  [(match_dup 1) (match_dup 2)\n \t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n \t  VUNSPEC_ATOMIC_OP))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n+   (clobber (match_scratch:SI 4 \"=&r,&l,&l\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -382,21 +421,24 @@\n     arm_split_atomic_op (<CODE>, NULL, operands[0], operands[1],\n \t\t\t operands[2], operands[3], operands[4]);\n     DONE;\n-  })\n+  }\n+  [(set_attr \"arch\" \"32,v8mb,v8mb\")])\n \n+;; Constraints of this pattern must be at least as strict as those of the non\n+;; atomic NANDs in thumb1.md and aim to be as permissive.\n (define_insn_and_split \"atomic_nand_fetch<mode>\"\n-  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r\")\n+  [(set (match_operand:QHSD 0 \"s_register_operand\" \"=&r,&l\")\n \t(not:QHSD\n \t  (and:QHSD\n-\t    (match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua\")\n-\t    (match_operand:QHSD 2 \"<atomic_op_operand>\" \"<atomic_op_str>\"))))\n+\t    (match_operand:QHSD 1 \"mem_noofs_operand\" \"+Ua,Ua\")\n+\t    (match_operand:QHSD 2 \"<atomic_op_operand>\" \"<atomic_op_str>,l\"))))\n    (set (match_dup 1)\n \t(unspec_volatile:QHSD\n \t  [(match_dup 1) (match_dup 2)\n \t   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n \t  VUNSPEC_ATOMIC_OP))\n    (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n+   (clobber (match_scratch:SI 4 \"=&r,&l\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -405,7 +447,8 @@\n     arm_split_atomic_op (NOT, NULL, operands[0], operands[1],\n \t\t\t operands[2], operands[3], operands[4]);\n     DONE;\n-  })\n+  }\n+  [(set_attr \"arch\" \"32,v8mb\")])\n \n (define_insn \"arm_load_exclusive<mode>\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")"}, {"sha": "5f0dffba89145321351331db821bdeaa0df54b10", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33cab74617734fdda5b39bd645d13361cd92af23/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33cab74617734fdda5b39bd645d13361cd92af23/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=33cab74617734fdda5b39bd645d13361cd92af23", "patch": "@@ -55,6 +55,10 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n+;; Changes to the constraints of this pattern must be propagated to those of\n+;; atomic additions in sync.md and to the logic for bind_old_new in\n+;; arm_split_atomic_op in arm.c.  These must be at least as strict as the\n+;; constraints here and aim to be as permissive.\n (define_insn_and_split \"*thumb1_addsi3\"\n   [(set (match_operand:SI          0 \"register_operand\" \"=l,l,l,*rk,*hk,l,k,l,l,l\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,l,*0,*0,k,k,0,l,k\")\n@@ -131,6 +135,10 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n+;; Changes to the constraints of this pattern must be propagated to those of\n+;; atomic subtractions in sync.md and to the logic for bind_old_new in\n+;; arm_split_atomic_op in arm.c.  These must be at least as strict as the\n+;; constraints here and aim to be as permissive.\n (define_insn \"thumb1_subsi3_insn\"\n   [(set (match_operand:SI           0 \"register_operand\" \"=l\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"l\")\n@@ -173,6 +181,10 @@\n    (set_attr \"type\" \"muls\")]\n )\n \n+;; Changes to the constraints of this pattern must be propagated to those of\n+;; atomic bitwise ANDs and NANDs in sync.md and to the logic for bind_old_new\n+;; in arm_split_atomic_op in arm.c.  These must be at least as strict as the\n+;; constraints here and aim to be as permissive.\n (define_insn \"*thumb1_andsi3_insn\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n@@ -227,6 +239,10 @@\n    (set_attr \"type\" \"logics_reg\")]\n )\n \n+;; Changes to the constraints of this pattern must be propagated to those of\n+;; atomic inclusive ORs in sync.md and to the logic for bind_old_new in\n+;; arm_split_atomic_op in arm.c.  These must be at least as strict as the\n+;; constraints here and aim to be as permissive.\n (define_insn \"*thumb1_iorsi3_insn\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n@@ -237,6 +253,10 @@\n    (set_attr \"conds\" \"set\")\n    (set_attr \"type\" \"logics_reg\")])\n \n+;; Changes to the constraints of this pattern must be propagated to those of\n+;; atomic exclusive ORs in sync.md and to the logic for bind_old_new in\n+;; arm_split_atomic_op in arm.c.  These must be at least as strict as the\n+;; constraints here and aim to be as permissive.\n (define_insn \"*thumb1_xorsi3_insn\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")"}]}