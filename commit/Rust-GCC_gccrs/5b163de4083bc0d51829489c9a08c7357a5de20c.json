{"sha": "5b163de4083bc0d51829489c9a08c7357a5de20c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIxNjNkZTQwODNiYzBkNTE4Mjk0ODljOWEwOGM3MzU3YTVkZTIwYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-25T03:06:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-25T03:06:16Z"}, "message": "typeck.c (common_type): Handle cv-qual unification for pointers to members.\n\n\t* typeck.c (common_type): Handle cv-qual unification for pointers\n\tto members.\n\t* decl.c (unqualified_namespace_lookup): Return error_mark_node\n\ton error.\n\t(lookup_name_real): Set LOOKUP_COMPLAIN when *not* parsing.\n\t* lex.c (do_identifier): If we got error_mark_node, call\n\tlookup_name again.\n\nFrom-SVN: r25967", "tree": {"sha": "08a5b1f87d7c24ecab479d4bc480cfa1d0eedfee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08a5b1f87d7c24ecab479d4bc480cfa1d0eedfee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b163de4083bc0d51829489c9a08c7357a5de20c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b163de4083bc0d51829489c9a08c7357a5de20c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b163de4083bc0d51829489c9a08c7357a5de20c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b163de4083bc0d51829489c9a08c7357a5de20c/comments", "author": null, "committer": null, "parents": [{"sha": "63681b5ff9a024c5fd85b4cc853e4c1238f97f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63681b5ff9a024c5fd85b4cc853e4c1238f97f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63681b5ff9a024c5fd85b4cc853e4c1238f97f12"}], "stats": {"total": 100, "additions": 67, "deletions": 33}, "files": [{"sha": "1a5033f54587ed72bec5dad615605a02c910d077", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b163de4083bc0d51829489c9a08c7357a5de20c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b163de4083bc0d51829489c9a08c7357a5de20c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5b163de4083bc0d51829489c9a08c7357a5de20c", "patch": "@@ -1,3 +1,14 @@\n+1999-03-25  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (common_type): Handle cv-qual unification for pointers\n+\tto members.\n+\n+\t* decl.c (unqualified_namespace_lookup): Return error_mark_node\n+\ton error.\n+\t(lookup_name_real): Set LOOKUP_COMPLAIN when *not* parsing.\n+\t* lex.c (do_identifier): If we got error_mark_node, call\n+\tlookup_name again.\n+\n 1999-03-24  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* class.c (finish_struct_1): Always reset TYPE_FIELDS for empty"}, {"sha": "f5e290205bbf5da05ed6a3027587a28c6497db82", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b163de4083bc0d51829489c9a08c7357a5de20c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b163de4083bc0d51829489c9a08c7357a5de20c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5b163de4083bc0d51829489c9a08c7357a5de20c", "patch": "@@ -5291,7 +5291,7 @@ unqualified_namespace_lookup (name, flags)\n \tif (!lookup_using_namespace (name, b, level->using_directives,\n                                      scope, flags))\n \t  /* Give up because of error. */\n-\t  return NULL_TREE;\n+\t  return error_mark_node;\n \n       /* Add all _DECLs seen through global using-directives. */\n       /* XXX local and global using lists should work equally. */\n@@ -5301,7 +5301,7 @@ unqualified_namespace_lookup (name, flags)\n \t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter), \n \t\t\t\t       scope, flags))\n \t    /* Give up because of error. */\n-\t    return NULL_TREE;\n+\t    return error_mark_node;\n \t  if (siter == scope) break;\n \t  siter = CP_DECL_CONTEXT (siter);\n \t}\n@@ -5388,8 +5388,6 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       prefer_type = looking_for_typename;\n \n       flags = lookup_flags (prefer_type, namespaces_only);\n-      /* During parsing, we need to complain. */\n-      flags |= LOOKUP_COMPLAIN;\n       /* If the next thing is '<', class templates are types. */\n       if (looking_for_template)\n         flags |= LOOKUP_TEMPLATES_EXPECTED;\n@@ -5463,7 +5461,11 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \tfrom_obj = val;\n     }\n   else\n-    flags = lookup_flags (prefer_type, namespaces_only);\n+    {\n+      flags = lookup_flags (prefer_type, namespaces_only);\n+      /* If we're not parsing, we need to complain. */\n+      flags |= LOOKUP_COMPLAIN;\n+    }\n \n   /* First, look in non-namespace scopes.  */\n   for (val = IDENTIFIER_BINDING (name); val; val = TREE_CHAIN (val))"}, {"sha": "9e3cbc1248cc22af864e1a81ba013317b71f872f", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b163de4083bc0d51829489c9a08c7357a5de20c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b163de4083bc0d51829489c9a08c7357a5de20c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=5b163de4083bc0d51829489c9a08c7357a5de20c", "patch": "@@ -2935,7 +2935,7 @@ do_identifier (token, parsing, args)\n      expressions instead).  */\n   if (args && !current_template_parms && (!id || is_global (id)))\n     /* If we have arguments and we only found global names, do Koenig\n-         lookup. */\n+       lookup. */\n     id = lookup_arg_dependent (token, id, args);\n \n   /* Remember that this name has been used in the class definition, as per\n@@ -2949,18 +2949,19 @@ do_identifier (token, parsing, args)\n \t after the class is complete.  (jason 3/12/97) */\n       && TREE_CODE (id) != OVERLOAD)\n     pushdecl_class_level (id);\n-    \n-  if (!id || id == error_mark_node)\n-    {\n-      if (id == error_mark_node && current_class_type != NULL_TREE)\n-\t{\n-\t  id = lookup_nested_field (token, 1);\n-\t  /* In lookup_nested_field(), we marked this so we can gracefully\n-\t     leave this whole mess.  */\n-\t  if (id && id != error_mark_node && TREE_TYPE (id) == error_mark_node)\n-\t    return id;\n-\t}\n \n+  if (id == error_mark_node)\n+    {\n+      /* lookup_name quietly returns error_mark_node if we're parsing,\n+\t as we don't want to complain about an identifier that ends up\n+\t being used as a declarator.  So we call it again to get the error\n+\t message.  */\n+      id = lookup_name (token, 0);\n+      return error_mark_node;\n+    }\n+      \n+  if (!id)\n+    {\n       if (current_template_parms)\n \treturn build_min_nt (LOOKUP_EXPR, token);\n       else if (IDENTIFIER_OPNAME_P (token))"}, {"sha": "701738c7307ad25cc7310781bbf665af99ae4189", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b163de4083bc0d51829489c9a08c7357a5de20c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b163de4083bc0d51829489c9a08c7357a5de20c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5b163de4083bc0d51829489c9a08c7357a5de20c", "patch": "@@ -562,14 +562,33 @@ common_type (t1, t2)\n  \t But ANSI C++ specifies doing this with the qualifiers.\n  \t So I turned it on again.  */\n       {\n-\ttree tt1 = TYPE_MAIN_VARIANT (TREE_TYPE (t1));\n-\ttree tt2 = TYPE_MAIN_VARIANT (TREE_TYPE (t2));\n-\tint type_quals = (CP_TYPE_QUALS (TREE_TYPE (t1)) \n-\t\t\t  | CP_TYPE_QUALS (TREE_TYPE (t2)));\n+\ttree tt1 = TREE_TYPE (t1);\n+\ttree tt2 = TREE_TYPE (t2);\n+\ttree b1, b2;\n+\tint type_quals;\n \ttree target;\n \n+\tif (TREE_CODE (tt1) == OFFSET_TYPE)\n+\t  {\n+\t    b1 = TYPE_OFFSET_BASETYPE (tt1);\n+\t    b2 = TYPE_OFFSET_BASETYPE (tt2);\n+\t    tt1 = TREE_TYPE (tt1);\n+\t    tt2 = TREE_TYPE (tt2);\n+\t  }\n+\telse\n+\t  b1 = b2 = NULL_TREE;\n+\n+\ttype_quals = (CP_TYPE_QUALS (tt1) | CP_TYPE_QUALS (tt2));\n+\ttt1 = TYPE_MAIN_VARIANT (tt1);\n+\ttt2 = TYPE_MAIN_VARIANT (tt2);\n+\n \tif (tt1 == tt2)\n \t  target = tt1;\n+\telse if (b1)\n+\t  {\n+\t    compiler_error (\"common_type called with uncommon member types\");\n+\t    target = tt1;\n+\t  }\n \telse if (tt1 == void_type_node || tt2 == void_type_node)\n \t  target = void_type_node;\n \telse if (tt1 == unknown_type_node)\n@@ -580,6 +599,16 @@ common_type (t1, t2)\n \t  target = common_type (tt1, tt2);\n \n \ttarget = cp_build_qualified_type (target, type_quals);\n+\n+\tif (b1)\n+\t  {\n+\t    if (same_type_p (b1, b2)\n+\t\t|| (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2)))\n+\t      target = build_offset_type (b2, target);\n+\t    else if (binfo_or_else (b2, b1))\n+\t      target = build_offset_type (b1, target);\n+\t  }\n+\n \tif (code1 == POINTER_TYPE)\n \t  t1 = build_pointer_type (target);\n \telse\n@@ -699,18 +728,9 @@ common_type (t1, t2)\n       return build_type_attribute_variant (t1, attributes);\n \n     case OFFSET_TYPE:\n-      if (TREE_TYPE (t1) == TREE_TYPE (t2))\n-\t{\n-\t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n-\t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n-\n-\t  if (same_type_p (b1, b2)\n-\t      || (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2)))\n-\t    return build_type_attribute_variant (t2, attributes);\n-\t  else if (binfo_or_else (b2, b1))\n-\t    return build_type_attribute_variant (t1, attributes);\n-\t}\n-      compiler_error (\"common_type called with uncommon member types\");\n+      /* Pointers to members should now be handled by the POINTER_TYPE\n+\t case above.  */\n+      my_friendly_abort (990325);\n \n     default:\n       return build_type_attribute_variant (t1, attributes);"}]}