{"sha": "c85663b1a886532c02cabf33da28ca867c177cc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg1NjYzYjFhODg2NTMyYzAyY2FiZjMzZGEyOGNhODY3YzE3N2NjMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-16T10:47:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-16T10:47:10Z"}, "message": "(set_nonvarying_address_components): Rework and also handle an AND\nused for non-aligned accesses.\n\nFrom-SVN: r7503", "tree": {"sha": "ba0d2c4d5235a8231510f2d07dc1561915708caf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba0d2c4d5235a8231510f2d07dc1561915708caf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c85663b1a886532c02cabf33da28ca867c177cc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85663b1a886532c02cabf33da28ca867c177cc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c85663b1a886532c02cabf33da28ca867c177cc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85663b1a886532c02cabf33da28ca867c177cc0/comments", "author": null, "committer": null, "parents": [{"sha": "88d0b2b86554cd8a5ae64ec08cf62d8dcd95f855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88d0b2b86554cd8a5ae64ec08cf62d8dcd95f855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88d0b2b86554cd8a5ae64ec08cf62d8dcd95f855"}], "stats": {"total": 64, "additions": 51, "deletions": 13}, "files": [{"sha": "a9dfa4d55cdf5bea63ee0922cf5d744f6a0e2e1d", "filename": "gcc/cse.c", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85663b1a886532c02cabf33da28ca867c177cc0/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85663b1a886532c02cabf33da28ca867c177cc0/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c85663b1a886532c02cabf33da28ca867c177cc0", "patch": "@@ -2240,7 +2240,7 @@ set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n      HOST_WIDE_INT *pstart, *pend;\n {\n   rtx base;\n-  int start, end;\n+  HOST_WIDE_INT start, end;\n \n   base = addr;\n   start = 0;\n@@ -2267,20 +2267,58 @@ set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n       base = qty_const[reg_qty[REGNO (XEXP (base, 0))]];\n     }\n \n-  /* By definition, operand1 of a LO_SUM is the associated constant\n-     address.  Use the associated constant address as the base instead.  */\n-  if (GET_CODE (base) == LO_SUM)\n-    base = XEXP (base, 1);\n-\n-  /* Strip off CONST.  */\n-  if (GET_CODE (base) == CONST)\n-    base = XEXP (base, 0);\n+  /* Handle everything that we can find inside an address that has been\n+     viewed as constant.  */\n \n-  if (GET_CODE (base) == PLUS\n-      && GET_CODE (XEXP (base, 1)) == CONST_INT)\n+  while (1)\n     {\n-      start += INTVAL (XEXP (base, 1));\n-      base = XEXP (base, 0);\n+      /* If no part of this switch does a \"continue\", the code outside\n+\t will exit this loop.  */\n+\n+      switch (GET_CODE (base))\n+\t{\n+\tcase LO_SUM:\n+\t  /* By definition, operand1 of a LO_SUM is the associated constant\n+\t     address.  Use the associated constant address as the base\n+\t     instead.  */\n+\t  base = XEXP (base, 1);\n+\t  continue;\n+\n+\tcase CONST:\n+\t  /* Strip off CONST.  */\n+\t  base = XEXP (base, 0);\n+\t  continue;\n+\n+\tcase PLUS:\n+\t  if (GET_CODE (XEXP (base, 1)) == CONST_INT)\n+\t    {\n+\t      start += INTVAL (XEXP (base, 1));\n+\t      base = XEXP (base, 0);\n+\t      continue;\n+\t    }\n+\t  break;\n+\n+\tcase AND:\n+\t  /* Handle the case of an AND which is the negative of a power of\n+\t     two.  This is used to represent unaligned memory operations.  */\n+\t  if (GET_CODE (XEXP (base, 1)) == CONST_INT\n+\t      && exact_log2 (- INTVAL (XEXP (base, 1))) > 0)\n+\t    {\n+\t      set_nonvarying_address_components (XEXP (base, 0), size,\n+\t\t\t\t\t\t pbase, pstart, pend);\n+\n+\t      /* Assume the worst misalignment.  START is affected, but not\n+\t\t END, so compensate but adjusting SIZE.  Don't lose any\n+\t\t constant we already had.  */\n+\n+\t      size = *pend - *pstart - INTVAL (XEXP (base, 1)) - 1;\n+\t      start += *pstart - INTVAL (XEXP (base, 1)) - 1;\n+\t      base = *pbase;\n+\t    }\n+\t  break;\n+\t}\n+\n+      break;\n     }\n \n   end = start + size;"}]}