{"sha": "2c2e8978f301562ab4d5881758eef93693d5b319", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyZTg5NzhmMzAxNTYyYWI0ZDU4ODE3NThlZWY5MzY5M2Q1YjMxOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-10-12T14:23:39Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-10-12T14:23:39Z"}, "message": "search.c (struct lookup_base_data_s): New.\n\n\t* search.c (struct lookup_base_data_s): New.\n\t(lookup_base_r): Replace with ...\n\t(dfs_lookup_base): ... this.\n\t(lookup_base): Use dfs_walk_all.\n\nFrom-SVN: r88934", "tree": {"sha": "dcd9d9902f0cff883d070b0448bdb325105a0bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcd9d9902f0cff883d070b0448bdb325105a0bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c2e8978f301562ab4d5881758eef93693d5b319", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2e8978f301562ab4d5881758eef93693d5b319", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c2e8978f301562ab4d5881758eef93693d5b319", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2e8978f301562ab4d5881758eef93693d5b319/comments", "author": null, "committer": null, "parents": [{"sha": "a3702807382bff86e48479f3b7e59831952b8537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3702807382bff86e48479f3b7e59831952b8537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3702807382bff86e48479f3b7e59831952b8537"}], "stats": {"total": 179, "additions": 100, "deletions": 79}, "files": [{"sha": "5b87487923defd7eb54c4a765a412df934a30545", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2e8978f301562ab4d5881758eef93693d5b319/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2e8978f301562ab4d5881758eef93693d5b319/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2c2e8978f301562ab4d5881758eef93693d5b319", "patch": "@@ -1,3 +1,10 @@\n+2004-10-12  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* search.c (struct lookup_base_data_s): New.\n+\t(lookup_base_r): Replace with ...\n+\t(dfs_lookup_base): ... this.\n+\t(lookup_base): Use dfs_walk_all.\n+\n 2004-10-12  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* search.c: Fix comment typos."}, {"sha": "9ab861f6aef45159c0f832bb2a394931ed376e97", "filename": "gcc/cp/search.c", "status": "modified", "additions": 93, "deletions": 79, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2e8978f301562ab4d5881758eef93693d5b319/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2e8978f301562ab4d5881758eef93693d5b319/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=2c2e8978f301562ab4d5881758eef93693d5b319", "patch": "@@ -37,9 +37,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"stack.h\"\n \n static int is_subobject_of_p (tree, tree);\n+static tree dfs_lookup_base (tree, void *);\n static tree dfs_dcast_hint_pre (tree, void *);\n static tree dfs_dcast_hint_post (tree, void *);\n-static base_kind lookup_base_r (tree, tree, base_access, bool, tree *);\n static tree dfs_debug_mark (tree, void *);\n static tree dfs_walk_once_r (tree, tree (*pre_fn) (tree, void *),\n \t\t\t     tree (*post_fn) (tree, void *), void *data);\n@@ -78,88 +78,75 @@ static int n_contexts_saved;\n #endif /* GATHER_STATISTICS */\n \n \f\n-/* Worker for lookup_base.  BINFO is the binfo we are searching at,\n-   BASE is the RECORD_TYPE we are searching for.  ACCESS is the\n-   required access checks.  IS_VIRTUAL indicates if BINFO is morally\n-   virtual.\n-\n-   If BINFO is of the required type, then *BINFO_PTR is examined to\n-   compare with any other instance of BASE we might have already\n-   discovered. *BINFO_PTR is initialized and a base_kind return value\n-   indicates what kind of base was located.\n-\n-   Otherwise BINFO's bases are searched.  */\n-\n-static base_kind\n-lookup_base_r (tree binfo, tree base, base_access access,\n-\t       bool is_virtual,\t\t\t/* inside a virtual part */\n-\t       tree *binfo_ptr)\n+/* Data for lookup_base and its workers.  */\n+\n+struct lookup_base_data_s\n {\n-  int i;\n-  tree base_binfo;\n-  base_kind found = bk_not_base;\n-  \n-  if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), base))\n-    {\n-      /* We have found a base. Check against what we have found\n-         already.  */\n-      found = bk_same_type;\n-      if (is_virtual)\n-\tfound = bk_via_virtual;\n-      \n-      if (!*binfo_ptr)\n-\t*binfo_ptr = binfo;\n-      else if (binfo != *binfo_ptr)\n-\t{\n-\t  if (access != ba_any)\n-\t    *binfo_ptr = NULL;\n-\t  else if (!is_virtual)\n-\t    /* Prefer a non-virtual base.  */\n-\t    *binfo_ptr = binfo;\n-\t  found = bk_ambig;\n-\t}\n-      \n-      return found;\n-    }\n-  \n-  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-    {\n-      base_kind bk;\n+  tree t;\t\t/* type being searched. */\n+  tree base;            /* The base type we're looking for.  */\n+  tree binfo;           /* Found binfo.  */\n+  bool via_virtual;  \t/* Found via a virtual path.  */\n+  bool ambiguous;\t/* Found multiply ambiguous */\n+  bool repeated_base;   /* Whether there are repeated bases in the\n+\t\t\t    hierarchy.  */\n+  bool want_any;  \t/* Whether we want any matching binfo.  */\n+};\n+\n+/* Worker function for lookup_base.  See if we've found the desired\n+   base and update DATA_ (a pointer to LOOKIP_BASE_DATA_S).  */\n \n-      bk = lookup_base_r (base_binfo, base,\n-\t\t    \t  access,\n-\t\t\t  is_virtual || BINFO_VIRTUAL_P (base_binfo),\n-\t\t\t  binfo_ptr);\n+static tree\n+dfs_lookup_base (tree binfo, void *data_)\n+{\n+  struct lookup_base_data_s *data = data_;\n \n-      switch (bk)\n+  if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), data->base))\n+    {\n+      if (!data->binfo)\n \t{\n-\tcase bk_ambig:\n-\t  if (access != ba_any)\n-\t    return bk;\n-\t  found = bk;\n-\t  break;\n+\t  data->binfo = binfo;\n+\t  data->via_virtual\n+\t    = binfo_via_virtual (data->binfo, data->t) != NULL_TREE;\n+\t  \n+\t  if (!data->repeated_base)\n+\t    /* If there are no repeated bases, we can stop now.  */\n+\t    return binfo;\n \t  \n-\tcase bk_same_type:\n-\t  bk = bk_proper_base;\n-\t  /* Fall through.  */\n-\tcase bk_proper_base:\n-\t  gcc_assert (found == bk_not_base);\n-\t  found = bk;\n-\t  break;\n+\t  if (data->want_any && !data->via_virtual)\n+\t    /* If this is a non-virtual base, then we can't do\n+\t       better.  */\n+\t    return binfo;\n \t  \n-\tcase bk_via_virtual:\n-\t  if (found != bk_ambig)\n-\t    found = bk;\n-\t  break;\n+\t  return dfs_skip_bases;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (binfo != data->binfo);\n \t  \n-\tcase bk_not_base:\n-\t  break;\n+\t  /* We've found more than one matching binfo.  */\n+\t  if (!data->want_any)\n+\t    {\n+\t      /* This is immediately ambiguous.  */\n+\t      data->binfo = NULL_TREE;\n+\t      data->ambiguous = true;\n+\t      return error_mark_node;\n+\t    }\n+\n+\t  /* Prefer one via a non-virtual path.  */\n+\t  if (!binfo_via_virtual (binfo, data->t))\n+\t    {\n+\t      data->binfo = binfo;\n+\t      data->via_virtual = false;\n+\t      return binfo;\n+\t    }\n \n-\tdefault:\n-\t  gcc_unreachable ();\n+\t  /* There must be repeated bases, otherwise we'd have stopped\n+\t     on the first base we found.  */\n+\t  return dfs_skip_bases;\n \t}\n     }\n-  return found;\n+  \n+  return NULL_TREE;\n }\n \n /* Returns true if type BASE is accessible in T.  (BASE is known to be\n@@ -202,8 +189,8 @@ accessible_base_p (tree t, tree base)\n tree\n lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n {\n-  tree binfo = NULL_TREE;\t/* The binfo we've found so far.  */\n-  tree t_binfo = NULL_TREE;\n+  tree binfo;\n+  tree t_binfo;\n   base_kind bk;\n   \n   if (t == error_mark_node || base == error_mark_node)\n@@ -219,7 +206,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n       t_binfo = t;\n       t = BINFO_TYPE (t);\n     }\n-  else  \n+  else\n     {\n       t = complete_type (TYPE_MAIN_VARIANT (t));\n       t_binfo = TYPE_BINFO (t);\n@@ -228,9 +215,33 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n   base = complete_type (TYPE_MAIN_VARIANT (base));\n \n   if (t_binfo)\n-    bk = lookup_base_r (t_binfo, base, access, 0, &binfo);\n+    {\n+      struct lookup_base_data_s data;\n+\n+      data.t = t;\n+      data.base = base;\n+      data.binfo = NULL_TREE;\n+      data.ambiguous = data.via_virtual = false;\n+      data.repeated_base = CLASSTYPE_REPEATED_BASE_P (t);\n+      data.want_any = access == ba_any;\n+\n+      dfs_walk_once (t_binfo, dfs_lookup_base, NULL, &data);\n+      binfo = data.binfo;\n+      \n+      if (!binfo)\n+\tbk = data.ambiguous ? bk_ambig : bk_not_base;\n+      else if (binfo == t_binfo)\n+\tbk = bk_same_type;\n+      else if (data.via_virtual)\n+\tbk = bk_via_virtual;\n+      else\n+\tbk = bk_proper_base;\n+    }\n   else\n-    bk = bk_not_base;\n+    {\n+      binfo = NULL_TREE;\n+      bk = bk_not_base;\n+    }\n \n   /* Check that the base is unambiguous and accessible.  */\n   if (access != ba_any)\n@@ -240,7 +251,6 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \tbreak;\n \n       case bk_ambig:\n-\tbinfo = NULL_TREE;\n \tif (!(access & ba_quiet))\n \t  {\n \t    error (\"%qT is an ambiguous base of %qT\", base, t);\n@@ -2415,6 +2425,10 @@ binfo_from_vbase (tree binfo)\n tree\n binfo_via_virtual (tree binfo, tree limit)\n {\n+  if (limit && !CLASSTYPE_VBASECLASSES (limit))\n+    /* LIMIT has no virtual bases, so BINFO cannot be via one.  */\n+    return NULL_TREE;\n+  \n   for (; binfo && !SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), limit);\n        binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     {"}]}