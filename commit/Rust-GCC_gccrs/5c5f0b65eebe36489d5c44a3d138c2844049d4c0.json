{"sha": "5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM1ZjBiNjVlZWJlMzY0ODlkNWM0NGEzZDEzOGMyODQ0MDQ5ZDRjMA==", "commit": {"author": {"name": "Igor Tsimbalist", "email": "igor.v.tsimbalist@intel.com", "date": "2017-10-20T13:09:38Z"}, "committer": {"name": "Igor Tsimbalist", "email": "itsimbal@gcc.gnu.org", "date": "2017-10-20T13:09:38Z"}, "message": "Add generic part for Intel CET enabling. The spec is available at\n\nhttps://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf\n\nA proposal is to introduce a target independent flag\n-fcf-protection=[none|branch|return|full] with a semantic to\ninstrument a code to control validness or integrity of control-flow\ntransfers using jump and call instructions. The main goal is to detect\nand block a possible malware execution through transfer the execution\nto unknown target address. Implementation could be either software or\ntarget based. Any target platforms can provide their implementation\nfor instrumentation under this option.\n\nThe compiler should instrument any control-flow transfer points in a\nprogram (ex. call/jmp/ret) as well as any landing pads, which are\ntargets of control-flow transfers.\n\nA new 'nocf_check' attribute is introduced to provide hand tuning\nsupport. The attribute directs the compiler to skip a call to a\nfunction and a function's landing pad from instrumentation. The\nattribute can be used for function and pointer to function types,\notherwise it will be ignored.\n\nCurrently all platforms except i386 will report the error and do no\ninstrumentation. i386 will provide the implementation based on a\nspecification published by Intel for a new technology called\nControl-flow Enforcement Technology (CET).\n\ngcc/c-family/\n\t* c-attribs.c (handle_nocf_check_attribute): New function.\n\t(c_common_attribute_table): Add 'nocf_check' handling.\n\ngcc/c/\n\t* gimple-parser.c: Add second argument NULL to\n\tgimple_build_call_from_tree.\n\ngcc/\n\t* attrib.c (comp_type_attributes): Check nocf_check attribute.\n\t* cfgexpand.c (expand_call_stmt): Set REG_CALL_NOCF_CHECK for\n\tcall insn.\n\t* combine.c (distribute_notes): Add REG_CALL_NOCF_CHECK handling.\n\t* common.opt: Add fcf-protection flag.\n\t* emit-rtl.c (try_split): Add REG_CALL_NOCF_CHECK handling.\n\t* flag-types.h: Add enum cf_protection_level.\n\t* gimple.c (gimple_build_call_from_tree): Add second parameter.\n\tAdd 'nocf_check' attribute propagation to gimple call.\n\t* gimple.h (gf_mask): Add GF_CALL_NOCF_CHECK.\n\t(gimple_build_call_from_tree): Update prototype.\n\t(gimple_call_nocf_check_p): New function.\n\t(gimple_call_set_nocf_check): Likewise.\n\t* gimplify.c: Add second argument to gimple_build_call_from_tree.\n\t* ipa-icf.c: Add nocf_check attribute in statement hash.\n\t* recog.c (peep2_attempt): Add REG_CALL_NOCF_CHECK handling.\n\t* reg-notes.def: Add REG_NOTE (CALL_NOCF_CHECK).\n\t* toplev.c (process_options): Add flag_cf_protection handling.\n\nFrom-SVN: r253936", "tree": {"sha": "07ee35844abbf2889c4ed953d998c4fe78bf9dd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07ee35844abbf2889c4ed953d998c4fe78bf9dd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/comments", "author": {"login": "itsimbal", "id": 29258612, "node_id": "MDQ6VXNlcjI5MjU4NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/29258612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/itsimbal", "html_url": "https://github.com/itsimbal", "followers_url": "https://api.github.com/users/itsimbal/followers", "following_url": "https://api.github.com/users/itsimbal/following{/other_user}", "gists_url": "https://api.github.com/users/itsimbal/gists{/gist_id}", "starred_url": "https://api.github.com/users/itsimbal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/itsimbal/subscriptions", "organizations_url": "https://api.github.com/users/itsimbal/orgs", "repos_url": "https://api.github.com/users/itsimbal/repos", "events_url": "https://api.github.com/users/itsimbal/events{/privacy}", "received_events_url": "https://api.github.com/users/itsimbal/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e64944ac65c3e0bb4115873f17b9c48f06c3813a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e64944ac65c3e0bb4115873f17b9c48f06c3813a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e64944ac65c3e0bb4115873f17b9c48f06c3813a"}], "stats": {"total": 196, "additions": 188, "deletions": 8}, "files": [{"sha": "4d2bb892ad7912e7bc792e4a8d26bdf809da906b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -1,3 +1,28 @@\n+2017-10-20  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n+\n+\t* c-attribs.c (handle_nocf_check_attribute): New function.\n+\t(c_common_attribute_table): Add 'nocf_check' handling.\n+\t* gimple-parser.c: Add second argument NULL to\n+\tgimple_build_call_from_tree.\n+\t* attrib.c (comp_type_attributes): Check nocf_check attribute.\n+\t* cfgexpand.c (expand_call_stmt): Set REG_CALL_NOCF_CHECK for\n+\tcall insn.\n+\t* combine.c (distribute_notes): Add REG_CALL_NOCF_CHECK handling.\n+\t* common.opt: Add fcf-protection flag.\n+\t* emit-rtl.c (try_split): Add REG_CALL_NOCF_CHECK handling.\n+\t* flag-types.h: Add enum cf_protection_level.\n+\t* gimple.c (gimple_build_call_from_tree): Add second parameter.\n+\tAdd 'nocf_check' attribute propagation to gimple call.\n+\t* gimple.h (gf_mask): Add GF_CALL_NOCF_CHECK.\n+\t(gimple_build_call_from_tree): Update prototype.\n+\t(gimple_call_nocf_check_p): New function.\n+\t(gimple_call_set_nocf_check): Likewise.\n+\t* gimplify.c: Add second argument to gimple_build_call_from_tree.\n+\t* ipa-icf.c: Add nocf_check attribute in statement hash.\n+\t* recog.c (peep2_attempt): Add REG_CALL_NOCF_CHECK handling.\n+\t* reg-notes.def: Add REG_NOTE (CALL_NOCF_CHECK).\n+\t* toplev.c (process_options): Add flag_cf_protection handling.\n+\n 2017-10-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* x86-tune-costs.h (core_cost): Fix div, move and sqrt latencies."}, {"sha": "ed76a8dab6f2bbc019049a366a4f07d32269c0c7", "filename": "gcc/attribs.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -1182,6 +1182,9 @@ comp_type_attributes (const_tree type1, const_tree type2)\n     }\n   if (lookup_attribute (\"transaction_safe\", CONST_CAST_TREE (a)))\n     return 0;\n+  if ((lookup_attribute (\"nocf_check\", TYPE_ATTRIBUTES (type1)) != NULL)\n+      ^ (lookup_attribute (\"nocf_check\", TYPE_ATTRIBUTES (type2)) != NULL))\n+    return 0;\n   /* As some type combinations - like default calling-convention - might\n      be compatible, we have to call the target hook to get the final result.  */\n   return targetm.comp_type_attributes (type1, type2);"}, {"sha": "bb75cba4c39d178eff51bd2028140ef068db9e2a", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -65,6 +65,7 @@ static tree handle_asan_odr_indicator_attribute (tree *, tree, tree, int,\n static tree handle_stack_protect_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noinline_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noclone_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_nocf_check_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noicf_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noipa_attribute (tree *, tree, tree, int, bool *);\n static tree handle_leaf_attribute (tree *, tree, tree, int, bool *);\n@@ -367,6 +368,8 @@ const struct attribute_spec c_common_attribute_table[] =\n   { \"patchable_function_entry\",\t1, 2, true, false, false,\n \t\t\t      handle_patchable_function_entry_attribute,\n \t\t\t      false },\n+  { \"nocf_check\",\t\t      0, 0, false, true, true,\n+\t\t\t      handle_nocf_check_attribute, true },\n   { NULL,                     0, 0, false, false, false, NULL, false }\n };\n \n@@ -772,6 +775,30 @@ handle_noclone_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle a \"nocf_check\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_nocf_check_attribute (tree *node, tree name,\n+\t\t\t  tree ARG_UNUSED (args),\n+\t\t\t  int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != METHOD_TYPE)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (!(flag_cf_protection & CF_BRANCH))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored. Use \"\n+\t\t\t\t\"-fcf-protection option to enable it\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"no_icf\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "c2e31df218cc8526b07296500e7b74c79e34f874", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -276,7 +276,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n       && TREE_CODE (lhs.value) == CALL_EXPR)\n     {\n       gimple *call;\n-      call = gimple_build_call_from_tree (lhs.value);\n+      call = gimple_build_call_from_tree (lhs.value, NULL);\n       gimple_seq_add_stmt (seq, call);\n       gimple_set_location (call, loc);\n       return;\n@@ -407,7 +407,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n       rhs = c_parser_gimple_unary_expression (parser);\n       if (rhs.value != error_mark_node)\n \t{\n-\t  gimple *call = gimple_build_call_from_tree (rhs.value);\n+\t  gimple *call = gimple_build_call_from_tree (rhs.value, NULL);\n \t  gimple_call_set_lhs (call, lhs.value);\n \t  gimple_seq_add_stmt (seq, call);\n \t  gimple_set_location (call, loc);"}, {"sha": "d0e078214895477a37efd447a37deb599feaa06f", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -2658,12 +2658,28 @@ expand_call_stmt (gcall *stmt)\n \t  }\n     }\n \n+  rtx_insn *before_call = get_last_insn ();\n   lhs = gimple_call_lhs (stmt);\n   if (lhs)\n     expand_assignment (lhs, exp, false);\n   else\n     expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n+  /* If the gimple call is an indirect call and has 'nocf_check'\n+     attribute find a generated CALL insn to mark it as no\n+     control-flow verification is needed.  */\n+  if (gimple_call_nocf_check_p (stmt)\n+      && !gimple_call_fndecl (stmt))\n+    {\n+      rtx_insn *last = get_last_insn ();\n+      while (!CALL_P (last)\n+\t     && last != before_call)\n+\tlast = PREV_INSN (last);\n+\n+      if (last != before_call)\n+\tadd_reg_note (last, REG_CALL_NOCF_CHECK, const0_rtx);\n+    }\n+\n   mark_transaction_restart_calls (stmt);\n }\n "}, {"sha": "a58bb1e9470c3eab338538defbe4722de1b12478", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -14185,6 +14185,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \tcase REG_SETJMP:\n \tcase REG_TM:\n \tcase REG_CALL_DECL:\n+\tcase REG_CALL_NOCF_CHECK:\n \t  /* These notes must remain with the call.  It should not be\n \t     possible for both I2 and I3 to be a call.  */\n \t  if (CALL_P (i3))"}, {"sha": "8d62ec5044d5c63e659cddc08b4fe076b1afbe90", "filename": "gcc/common.opt", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -1620,6 +1620,29 @@ finline-atomics\n Common Report Var(flag_inline_atomics) Init(1) Optimization\n Inline __atomic operations when a lock free instruction sequence is available.\n \n+fcf-protection\n+Common RejectNegative Alias(fcf-protection=,full)\n+\n+fcf-protection=\n+Common Report Joined RejectNegative Enum(cf_protection_level) Var(flag_cf_protection) Init(CF_NONE)\n+-fcf-protection=[full|branch|return|none]\tInstrument functions with checks to verify jump/call/return control-flow transfer\n+instructions have valid targets.\n+\n+Enum\n+Name(cf_protection_level) Type(enum cf_protection_level) UnknownError(unknown Cotrol-Flow Protection Level %qs)\n+\n+EnumValue\n+Enum(cf_protection_level) String(full) Value(CF_FULL)\n+\n+EnumValue\n+Enum(cf_protection_level) String(branch) Value(CF_BRANCH)\n+\n+EnumValue\n+Enum(cf_protection_level) String(return) Value(CF_RETURN)\n+\n+EnumValue\n+Enum(cf_protection_level) String(none) Value(CF_NONE)\n+\n finstrument-functions\n Common Report Var(flag_instrument_function_entry_exit)\n Instrument function entry and exit with profiling calls."}, {"sha": "d91988e902d456463b38c496a8216ed6b1d249a5", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -3789,6 +3789,7 @@ try_split (rtx pat, rtx_insn *trial, int last)\n \tcase REG_NORETURN:\n \tcase REG_SETJMP:\n \tcase REG_TM:\n+\tcase REG_CALL_NOCF_CHECK:\n \t  for (insn = insn_last; insn != NULL_RTX; insn = PREV_INSN (insn))\n \t    {\n \t      if (CALL_P (insn))"}, {"sha": "2b2302963f0511d289b703d626c1a90ed271577f", "filename": "gcc/flag-types.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -326,4 +326,13 @@ enum gfc_convert\n };\n \n \n+/* Control-Flow Protection values.  */\n+enum cf_protection_level\n+{\n+  CF_NONE = 0,\n+  CF_BRANCH = 1 << 0,\n+  CF_RETURN = 1 << 1,\n+  CF_FULL = CF_BRANCH | CF_RETURN,\n+  CF_SET = 1 << 2\n+};\n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "1f291e10286d4a7a9b66ca0fce84b56b2e826b74", "filename": "gcc/gimple.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -346,7 +346,7 @@ gimple_build_call_internal_vec (enum internal_fn fn, vec<tree> args)\n    this fact.  */\n \n gcall *\n-gimple_build_call_from_tree (tree t)\n+gimple_build_call_from_tree (tree t, tree fnptrtype)\n {\n   unsigned i, nargs;\n   gcall *call;\n@@ -379,6 +379,23 @@ gimple_build_call_from_tree (tree t)\n   gimple_set_no_warning (call, TREE_NO_WARNING (t));\n   gimple_call_set_with_bounds (call, CALL_WITH_BOUNDS_P (t));\n \n+  if (fnptrtype)\n+    {\n+      gimple_call_set_fntype (call, TREE_TYPE (fnptrtype));\n+\n+      /* Check if it's an indirect CALL and the type has the\n+ \t nocf_check attribute. In that case propagate the information\n+\t to the gimple CALL insn.  */\n+      if (!fndecl)\n+\t{\n+\t  gcc_assert (POINTER_TYPE_P (fnptrtype));\n+\t  tree fntype = TREE_TYPE (fnptrtype);\n+\n+\t  if (lookup_attribute (\"nocf_check\", TYPE_ATTRIBUTES (fntype)))\n+\t    gimple_call_set_nocf_check (call, TRUE);\n+\t}\n+    }\n+\n   return call;\n }\n "}, {"sha": "334def89398edcc6908662de735796057b074be3", "filename": "gcc/gimple.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -148,6 +148,7 @@ enum gf_mask {\n     GF_CALL_WITH_BOUNDS \t= 1 << 8,\n     GF_CALL_MUST_TAIL_CALL\t= 1 << 9,\n     GF_CALL_BY_DESCRIPTOR\t= 1 << 10,\n+    GF_CALL_NOCF_CHECK\t\t= 1 << 11,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n     GF_OMP_PARALLEL_GRID_PHONY = 1 << 1,\n     GF_OMP_TASK_TASKLOOP\t= 1 << 0,\n@@ -1425,7 +1426,7 @@ gcall *gimple_build_call (tree, unsigned, ...);\n gcall *gimple_build_call_valist (tree, unsigned, va_list);\n gcall *gimple_build_call_internal (enum internal_fn, unsigned, ...);\n gcall *gimple_build_call_internal_vec (enum internal_fn, vec<tree> );\n-gcall *gimple_build_call_from_tree (tree);\n+gcall *gimple_build_call_from_tree (tree, tree);\n gassign *gimple_build_assign (tree, tree CXX_MEM_STAT_INFO);\n gassign *gimple_build_assign (tree, enum tree_code,\n \t\t\t      tree, tree, tree CXX_MEM_STAT_INFO);\n@@ -2893,6 +2894,25 @@ gimple_call_set_with_bounds (gimple *gs, bool with_bounds)\n }\n \n \n+/* Return true if call GS is marked as nocf_check.  */\n+\n+static inline bool\n+gimple_call_nocf_check_p (const gcall *gs)\n+{\n+  return (gs->subcode & GF_CALL_NOCF_CHECK) != 0;\n+}\n+\n+/* Mark statement GS as nocf_check call.  */\n+\n+static inline void\n+gimple_call_set_nocf_check (gcall *gs, bool nocf_check)\n+{\n+  if (nocf_check)\n+    gs->subcode |= GF_CALL_NOCF_CHECK;\n+  else\n+    gs->subcode &= ~GF_CALL_NOCF_CHECK;\n+}\n+\n /* Return the target of internal call GS.  */\n \n static inline enum internal_fn"}, {"sha": "4c245103fc49fd2c80b9e36d82fe9b7f4545d485", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -3378,8 +3378,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n       /* The CALL_EXPR in *EXPR_P is already in GIMPLE form, so all we\n \t have to do is replicate it as a GIMPLE_CALL tuple.  */\n       gimple_stmt_iterator gsi;\n-      call = gimple_build_call_from_tree (*expr_p);\n-      gimple_call_set_fntype (call, TREE_TYPE (fnptrtype));\n+      call = gimple_build_call_from_tree (*expr_p, fnptrtype);\n       notice_special_calls (call);\n       if (EXPR_CILK_SPAWN (*expr_p))\n         gimplify_cilk_detach (pre_p);\n@@ -5660,8 +5659,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t\t\t\t\t    CALL_EXPR_ARG (*from_p, 2));\n \t  else\n \t    {\n-\t      call_stmt = gimple_build_call_from_tree (*from_p);\n-\t      gimple_call_set_fntype (call_stmt, TREE_TYPE (fnptrtype));\n+\t      call_stmt = gimple_build_call_from_tree (*from_p, fnptrtype);\n \t    }\n \t}\n       notice_special_calls (call_stmt);"}, {"sha": "e666d5ab2d00e8159114046a657b7ea6905da44a", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -1422,6 +1422,7 @@ sem_function::init (void)\n \t      }\n \t  }\n \n+\thstate.commit_flag ();\n \tgcode_hash = hstate.end ();\n \tbb_sizes.safe_push (nondbg_stmt_count);\n \n@@ -1644,6 +1645,11 @@ sem_function::hash_stmt (gimple *stmt, inchash::hash &hstate)\n \t  if (gimple_op (stmt, i))\n \t    add_type (TREE_TYPE (gimple_op (stmt, i)), hstate);\n \t}\n+      /* Consider nocf_check attribute in hash as it affects code\n+ \t generation.  */\n+      if (code == GIMPLE_CALL\n+\t  && flag_cf_protection & CF_BRANCH)\n+\thstate.add_flag (gimple_call_nocf_check_p (as_a <gcall *> (stmt)));\n     default:\n       break;\n     }"}, {"sha": "9aaa6cd7a73ce8737d1ac39baab5649bf12fcc21", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -3381,6 +3381,7 @@ peep2_attempt (basic_block bb, rtx_insn *insn, int match_len, rtx_insn *attempt)\n \t  case REG_NORETURN:\n \t  case REG_SETJMP:\n \t  case REG_TM:\n+\t  case REG_CALL_NOCF_CHECK:\n \t    add_reg_note (new_insn, REG_NOTE_KIND (note),\n \t\t\t  XEXP (note, 0));\n \t    break;"}, {"sha": "d83fc45ef72c80e9062b1267b4218a44ee3f6b36", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -232,3 +232,10 @@ REG_NOTE (STACK_CHECK)\n    The decl might not be available in the call due to splitting of the call\n    insn.  This note is a SYMBOL_REF.  */\n REG_NOTE (CALL_DECL)\n+\n+/* Indicate that a call should not be verified for control-flow consistency.\n+   The target address of the call is assumed as a valid address and no check\n+   to validate a branch to the target address is needed.  The call is marked\n+   when a called function has a 'notrack' attribute.  This note is used by the\n+   compiler when the option -fcf-protection=branch is specified.  */\n+REG_NOTE (CALL_NOCF_CHECK)"}, {"sha": "8c45e1df2af326cbcfc072976f54fff73122c34b", "filename": "gcc/toplev.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5f0b65eebe36489d5c44a3d138c2844049d4c0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5c5f0b65eebe36489d5c44a3d138c2844049d4c0", "patch": "@@ -1277,6 +1277,32 @@ process_options (void)\n \t   \"-floop-parallelize-all)\");\n #endif\n \n+  if (flag_cf_protection != CF_NONE\n+      && !(flag_cf_protection & CF_SET))\n+    {\n+      if (flag_cf_protection == CF_FULL)\n+\t{\n+\t  error_at (UNKNOWN_LOCATION,\n+\t\t    \"%<-fcf-protection=full%> is not supported for this \"\n+\t\t    \"target\");\n+\t  flag_cf_protection = CF_NONE;\n+\t}\n+      if (flag_cf_protection == CF_BRANCH)\n+\t{\n+\t  error_at (UNKNOWN_LOCATION,\n+\t\t    \"%<-fcf-protection=branch%> is not supported for this \"\n+\t\t    \"target\");\n+\t  flag_cf_protection = CF_NONE;\n+\t}\n+      if (flag_cf_protection == CF_RETURN)\n+\t{\n+\t  error_at (UNKNOWN_LOCATION,\n+\t\t    \"%<-fcf-protection=return%> is not supported for this \"\n+\t\t    \"target\");\n+\t  flag_cf_protection = CF_NONE;\n+\t}\n+    }\n+\n   if (flag_check_pointer_bounds)\n     {\n       if (targetm.chkp_bound_mode () == VOIDmode)"}]}