{"sha": "56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZlYjRjNzBlYTdhNzhhNTNmYmI2ZTc1OTdlNzRlN2JhMDRkNDU3MA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-01-07T21:29:11Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-01-07T21:29:11Z"}, "message": "Restore patch reverted on trunk instead of a branch\n\nFrom-SVN: r279972", "tree": {"sha": "37a396422db852926736ee67a4599304dd79f155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37a396422db852926736ee67a4599304dd79f155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570/comments", "author": null, "committer": null, "parents": [{"sha": "cdf77151aa5a75e8967984fe3f457d4a23261cb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf77151aa5a75e8967984fe3f457d4a23261cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdf77151aa5a75e8967984fe3f457d4a23261cb6"}], "stats": {"total": 92, "additions": 89, "deletions": 3}, "files": [{"sha": "c212257c15fb5bba43a5ef516cab2a8a1c043d30", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "patch": "@@ -6753,6 +6753,90 @@ hard_reg_and_mode_to_addr_mask (rtx reg, machine_mode mode)\n   return addr_mask;\n }\n \n+/* Helper function to adjust a vector address (ADDR) to point to a given\n+   element offset (ELEMENT_OFFSET).  This function handles updating addresses\n+   that use PLUS (i.e. a D_FORM address with an integer constant or an X_FORM\n+   address adding two registers).  If we can't update the address directly, we\n+   can use the base register temporary (BASE_TMP) to form a valid address.  The\n+   mode of the element within the vector is SCALAR_MODE.  */\n+\n+rtx\n+adjust_vec_address_plus (rtx addr,\n+\t\t\t rtx element_offset,\n+\t\t\t rtx base_tmp,\n+\t\t\t machine_mode scalar_mode)\n+{\n+  gcc_assert (GET_CODE (addr) == PLUS);\n+\n+  rtx new_addr = NULL;\n+  rtx op0 = XEXP (addr, 0);\n+  rtx op1 = XEXP (addr, 1);\n+  rtx insn;\n+\n+  gcc_assert (REG_P (op0) || SUBREG_P (op0));\n+\n+  if (CONST_INT_P (op1) && CONST_INT_P (element_offset))\n+    {\n+      HOST_WIDE_INT offset = INTVAL (op1) + INTVAL (element_offset);\n+      rtx offset_rtx = GEN_INT (offset);\n+      new_addr = gen_rtx_PLUS (Pmode, op0, offset_rtx);\n+\n+      enum insn_form iform = address_to_insn_form (new_addr, scalar_mode,\n+\t\t\t\t\t\t   NON_PREFIXED_DEFAULT);\n+\n+      /* If the address isn't valid, change REG+OFFSET into REG+REG.  */\n+      if (iform == INSN_FORM_BAD)\n+\t{\n+\t  /* The offset either overflowed or it might not be a valid DS/DQ\n+\t     offset, move offset to the temporary (which will likely be split),\n+\t     and do X-FORM addressing.  */\n+\t  emit_move_insn (base_tmp, offset_rtx);\n+\t  new_addr = gen_rtx_PLUS (Pmode, op0, base_tmp);\n+\t}\n+    }\n+\n+  else\n+    {\n+      bool op1_reg_p = (REG_P (op1) || SUBREG_P (op1));\n+      bool ele_reg_p = (REG_P (element_offset) || SUBREG_P (element_offset));\n+\n+      /* Note, ADDI requires the register being added to be a base\n+\t register.  If the register was R0, load it up into the temporary\n+\t and do the add.  */\n+      if (op1_reg_p\n+\t  && (ele_reg_p || reg_or_subregno (op1) != FIRST_GPR_REGNO))\n+\t{\n+\t  insn = gen_add3_insn (base_tmp, op1, element_offset);\n+\t  gcc_assert (insn != NULL_RTX);\n+\t  emit_insn (insn);\n+\t}\n+\n+      else if (ele_reg_p\n+\t       && reg_or_subregno (element_offset) != FIRST_GPR_REGNO)\n+\t{\n+\t  insn = gen_add3_insn (base_tmp, element_offset, op1);\n+\t  gcc_assert (insn != NULL_RTX);\n+\t  emit_insn (insn);\n+\t}\n+\n+      /* Make sure we don't overwrite the temporary if the element being\n+\t extracted is variable, and we've put the offset into base_tmp\n+\t previously.  */\n+      else if (reg_mentioned_p (base_tmp, element_offset))\n+\temit_insn (gen_add2_insn (base_tmp, op1));\n+\n+      else\n+\t{\n+\t  emit_move_insn (base_tmp, op1);\n+\t  emit_insn (gen_add2_insn (base_tmp, element_offset));\n+\t}\n+\n+      new_addr = gen_rtx_PLUS (Pmode, op0, base_tmp);\n+    }\n+\n+  return new_addr;\n+}\n+\n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n    within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n    temporary (BASE_TMP) to fixup the address.  Return the new memory address\n@@ -6898,6 +6982,8 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n \tvalid_addr_p = (addr_mask & RELOAD_REG_OFFSET) != 0;\n     }\n \n+  /* An address that is a single register is always valid for either indexed or\n+     offsettable loads.  */\n   else if (REG_P (new_addr) || SUBREG_P (new_addr))\n     valid_addr_p = true;\n "}, {"sha": "8b400fff65aedbe1dcc1396223086944c6e0972a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "patch": "@@ -462,7 +462,7 @@ offline_size (struct cgraph_node *node, ipa_size_summary *info)\n   return 0;\n }\n \n-/* Estimate the growth caused by inlining NODE into all callees.  */\n+/* Estimate the growth caused by inlining NODE into all callers.  */\n \n int\n estimate_growth (struct cgraph_node *node)"}, {"sha": "302badf1fcae6437fee3e168fd39aebb267f7e8c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "patch": "@@ -184,8 +184,8 @@ caller_growth_limits (struct cgraph_edge *e)\n      the function to shrink if it went over the limits by forced inlining.  */\n   newsize = estimate_size_after_inlining (to, e);\n   if (newsize >= ipa_size_summaries->get (what)->size\n-      && newsize > opt_for_fn (to->decl, param_large_function_insns)\n-      && newsize > limit)\n+      && (newsize > opt_for_fn (to->decl, param_large_function_insns)\n+\t  || newsize > limit))\n     {\n       e->inline_failed = CIF_LARGE_FUNCTION_GROWTH_LIMIT;\n       return false;"}]}