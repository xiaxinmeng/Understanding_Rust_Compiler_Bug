{"sha": "a3600c718eb2abf543cd17458e98899958cdd839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM2MDBjNzE4ZWIyYWJmNTQzY2QxNzQ1OGU5ODg5OTk1OGNkZDgzOQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2003-03-09T01:32:42Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2003-03-09T01:32:42Z"}, "message": "optabs.c (gen_move_insn): Move logic for synthesizing MODE_CC moves from here ...\n\n\t* optabs.c (gen_move_insn): Move logic for synthesizing MODE_CC\n\tmoves from here ...\n\t* expr.c (emit_move_insn_1): ... to here.\n\nFrom-SVN: r64015", "tree": {"sha": "5939b9c628058a9aab673e2656bd7d35a9246792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5939b9c628058a9aab673e2656bd7d35a9246792"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3600c718eb2abf543cd17458e98899958cdd839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3600c718eb2abf543cd17458e98899958cdd839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3600c718eb2abf543cd17458e98899958cdd839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3600c718eb2abf543cd17458e98899958cdd839/comments", "author": null, "committer": null, "parents": [{"sha": "a6e464ae019d39af515fe0e2be9a949ed75bce92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6e464ae019d39af515fe0e2be9a949ed75bce92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6e464ae019d39af515fe0e2be9a949ed75bce92"}], "stats": {"total": 120, "additions": 59, "deletions": 61}, "files": [{"sha": "ebd9e8a9ef00278d508c40ba0b405a8fe542e101", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3600c718eb2abf543cd17458e98899958cdd839/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3600c718eb2abf543cd17458e98899958cdd839/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3600c718eb2abf543cd17458e98899958cdd839", "patch": "@@ -1,5 +1,9 @@\n 2003-03-09  Hans-Peter Nilsson  <hp@bitrange.com>\n \n+\t* optabs.c (gen_move_insn): Move logic for synthesizing MODE_CC\n+\tmoves from here ...\n+\t* expr.c (emit_move_insn_1): ... to here.\n+\n \t* config/cris/aout.h (CRIS_CPP_SUBTARGET_SPEC): Move -D__AOUT__ to...\n \t(TARGET_OS_CPP_BUILTINS): New macro.\n \t* config/cris/cris.h (CRIS_CPP_SUBTARGET_SPEC): Move -D__ELF__ to..."}, {"sha": "46b264ea584e601f315fe20c50e0b1ecf0532f41", "filename": "gcc/expr.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3600c718eb2abf543cd17458e98899958cdd839/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3600c718eb2abf543cd17458e98899958cdd839/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a3600c718eb2abf543cd17458e98899958cdd839", "patch": "@@ -3384,6 +3384,61 @@ emit_move_insn_1 (x, y)\n       return get_last_insn ();\n     }\n \n+  /* Handle MODE_CC modes:  If we don't have a special move insn for this mode,\n+     find a mode to do it in.  If we have a movcc, use it.  Otherwise,\n+     find the MODE_INT mode of the same width.  */\n+  else if (GET_MODE_CLASS (mode) == MODE_CC\n+\t   && mov_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+    {\n+      enum insn_code insn_code;\n+      enum machine_mode tmode = VOIDmode;\n+      rtx x1 = x, y1 = y;\n+\n+      if (mode != CCmode\n+\t  && mov_optab->handlers[(int) CCmode].insn_code != CODE_FOR_nothing)\n+\ttmode = CCmode;\n+      else\n+\tfor (tmode = QImode; tmode != VOIDmode;\n+\t     tmode = GET_MODE_WIDER_MODE (tmode))\n+\t  if (GET_MODE_SIZE (tmode) == GET_MODE_SIZE (mode))\n+\t    break;\n+\n+      if (tmode == VOIDmode)\n+\tabort ();\n+\n+      /* Get X and Y in TMODE.  We can't use gen_lowpart here because it\n+\t may call change_address which is not appropriate if we were\n+\t called when a reload was in progress.  We don't have to worry\n+\t about changing the address since the size in bytes is supposed to\n+\t be the same.  Copy the MEM to change the mode and move any\n+\t substitutions from the old MEM to the new one.  */\n+\n+      if (reload_in_progress)\n+\t{\n+\t  x = gen_lowpart_common (tmode, x1);\n+\t  if (x == 0 && GET_CODE (x1) == MEM)\n+\t    {\n+\t      x = adjust_address_nv (x1, tmode, 0);\n+\t      copy_replacements (x1, x);\n+\t    }\n+\n+\t  y = gen_lowpart_common (tmode, y1);\n+\t  if (y == 0 && GET_CODE (y1) == MEM)\n+\t    {\n+\t      y = adjust_address_nv (y1, tmode, 0);\n+\t      copy_replacements (y1, y);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  x = gen_lowpart (tmode, x);\n+\t  y = gen_lowpart (tmode, y);\n+\t}\n+\t  \n+      insn_code = mov_optab->handlers[(int) tmode].insn_code;\n+      return emit_insn (GEN_FCN (insn_code) (x, y));\n+    }\n+\n   /* This will handle any multi-word or full-word mode that lacks a move_insn\n      pattern.  However, you will get better code if you define such patterns,\n      even if they must turn into multiple assembler instructions.  */"}, {"sha": "ffad83fb81e53d4128419452738c5218156add01", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3600c718eb2abf543cd17458e98899958cdd839/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3600c718eb2abf543cd17458e98899958cdd839/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a3600c718eb2abf543cd17458e98899958cdd839", "patch": "@@ -4654,69 +4654,8 @@ rtx\n gen_move_insn (x, y)\n      rtx x, y;\n {\n-  enum machine_mode mode = GET_MODE (x);\n-  enum insn_code insn_code;\n   rtx seq;\n \n-  if (mode == VOIDmode)\n-    mode = GET_MODE (y); \n-\n-  insn_code = mov_optab->handlers[(int) mode].insn_code;\n-\n-  /* Handle MODE_CC modes:  If we don't have a special move insn for this mode,\n-     find a mode to do it in.  If we have a movcc, use it.  Otherwise,\n-     find the MODE_INT mode of the same width.  */\n-\n-  if (GET_MODE_CLASS (mode) == MODE_CC && insn_code == CODE_FOR_nothing)\n-    {\n-      enum machine_mode tmode = VOIDmode;\n-      rtx x1 = x, y1 = y;\n-\n-      if (mode != CCmode\n-\t  && mov_optab->handlers[(int) CCmode].insn_code != CODE_FOR_nothing)\n-\ttmode = CCmode;\n-      else\n-\tfor (tmode = QImode; tmode != VOIDmode;\n-\t     tmode = GET_MODE_WIDER_MODE (tmode))\n-\t  if (GET_MODE_SIZE (tmode) == GET_MODE_SIZE (mode))\n-\t    break;\n-\n-      if (tmode == VOIDmode)\n-\tabort ();\n-\n-      /* Get X and Y in TMODE.  We can't use gen_lowpart here because it\n-\t may call change_address which is not appropriate if we were\n-\t called when a reload was in progress.  We don't have to worry\n-\t about changing the address since the size in bytes is supposed to\n-\t be the same.  Copy the MEM to change the mode and move any\n-\t substitutions from the old MEM to the new one.  */\n-\n-      if (reload_in_progress)\n-\t{\n-\t  x = gen_lowpart_common (tmode, x1);\n-\t  if (x == 0 && GET_CODE (x1) == MEM)\n-\t    {\n-\t      x = adjust_address_nv (x1, tmode, 0);\n-\t      copy_replacements (x1, x);\n-\t    }\n-\n-\t  y = gen_lowpart_common (tmode, y1);\n-\t  if (y == 0 && GET_CODE (y1) == MEM)\n-\t    {\n-\t      y = adjust_address_nv (y1, tmode, 0);\n-\t      copy_replacements (y1, y);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  x = gen_lowpart (tmode, x);\n-\t  y = gen_lowpart (tmode, y);\n-\t}\n-\t  \n-      insn_code = mov_optab->handlers[(int) tmode].insn_code;\n-      return (GEN_FCN (insn_code) (x, y));\n-    }\n-\n   start_sequence ();\n   emit_move_insn_1 (x, y);\n   seq = get_insns ();"}]}