{"sha": "f5bdba44f05bbdb1e50842f7012b7aee701a0b5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjViZGJhNDRmMDViYmRiMWU1MDg0MmY3MDEyYjdhZWU3MDFhMGI1Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-04-25T21:02:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-04-25T21:02:25Z"}, "message": "ia64.c (ia64_compute_frame_size): Allow inline asm to clobber ar.pfs and ar.unat.\n\n        * config/ia64/ia64.c (ia64_compute_frame_size): Allow inline asm\n        to clobber ar.pfs and ar.unat.\n        (ia64_expand_prologue): Force alloc instruction if ar.pfs saved;\n        fix test for spilling ar.pfs to the stack.\n\nFrom-SVN: r66074", "tree": {"sha": "e54730d0349ad4ccd8f036c4f96eaadc5e2f4305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e54730d0349ad4ccd8f036c4f96eaadc5e2f4305"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5bdba44f05bbdb1e50842f7012b7aee701a0b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5bdba44f05bbdb1e50842f7012b7aee701a0b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5bdba44f05bbdb1e50842f7012b7aee701a0b5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5bdba44f05bbdb1e50842f7012b7aee701a0b5b/comments", "author": null, "committer": null, "parents": [{"sha": "8f4e6cafdebdae2730db4650e5c97e19f21481b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4e6cafdebdae2730db4650e5c97e19f21481b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4e6cafdebdae2730db4650e5c97e19f21481b6"}], "stats": {"total": 33, "additions": 27, "deletions": 6}, "files": [{"sha": "db9496f0ade27584e0bb7d119a3b45fe505e9582", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5bdba44f05bbdb1e50842f7012b7aee701a0b5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5bdba44f05bbdb1e50842f7012b7aee701a0b5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5bdba44f05bbdb1e50842f7012b7aee701a0b5b", "patch": "@@ -1,4 +1,11 @@\n-2003-04-25  Richard  Henderson  <rth@redhat.com>\n+2003-04-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_compute_frame_size): Allow inline asm\n+\tto clobber ar.pfs and ar.unat.\n+\t(ia64_expand_prologue): Force alloc instruction if ar.pfs saved;\n+\tfix test for spilling ar.pfs to the stack.\n+\n+2003-04-25  Richard Henderson  <rth@redhat.com>\n \n         PR opt/10315 \n         * config/rs6000/rs6000.c (rs6000_emit_move): Only elide proper"}, {"sha": "3fb27dd50d0a5bdc9022d050e0c063a078c72ffa", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5bdba44f05bbdb1e50842f7012b7aee701a0b5b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5bdba44f05bbdb1e50842f7012b7aee701a0b5b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f5bdba44f05bbdb1e50842f7012b7aee701a0b5b", "patch": "@@ -1878,6 +1878,17 @@ ia64_compute_frame_size (size)\n \t  spill_size += 8;\n \t  n_spilled += 1;\n \t}\n+\n+      if (regs_ever_live[AR_PFS_REGNUM])\n+\t{\n+\t  SET_HARD_REG_BIT (mask, AR_PFS_REGNUM);\n+\t  current_frame_info.reg_save_ar_pfs = find_gr_spill (1);\n+\t  if (current_frame_info.reg_save_ar_pfs == 0)\n+\t    {\n+\t      extra_spill_size += 8;\n+\t      n_spilled += 1;\n+\t    }\n+\t}\n     }\n \n   /* Unwind descriptor hackery: things are most efficient if we allocate\n@@ -1916,8 +1927,10 @@ ia64_compute_frame_size (size)\n     }\n \n   /* If we're forced to use st8.spill, we're forced to save and restore\n-     ar.unat as well.  */\n-  if (spilled_gr_p || cfun->machine->n_varargs)\n+     ar.unat as well.  The check for existing liveness allows inline asm\n+     to touch ar.unat.  */\n+  if (spilled_gr_p || cfun->machine->n_varargs\n+      || regs_ever_live[AR_UNAT_REGNUM])\n     {\n       regs_ever_live[AR_UNAT_REGNUM] = 1;\n       SET_HARD_REG_BIT (mask, AR_UNAT_REGNUM);\n@@ -2378,7 +2391,8 @@ ia64_expand_prologue ()\n   /* We don't need an alloc instruction if we've used no outputs or locals.  */\n   if (current_frame_info.n_local_regs == 0\n       && current_frame_info.n_output_regs == 0\n-      && current_frame_info.n_input_regs <= current_function_args_info.int_regs)\n+      && current_frame_info.n_input_regs <= current_function_args_info.int_regs\n+      && !TEST_HARD_REG_BIT (current_frame_info.mask, AR_PFS_REGNUM))\n     {\n       /* If there is no alloc, but there are input registers used, then we\n \t need a .regstk directive.  */\n@@ -2540,8 +2554,8 @@ ia64_expand_prologue ()\n   /* The alloc insn already copied ar.pfs into a general register.  The\n      only thing we have to do now is copy that register to a stack slot\n      if we'd not allocated a local register for the job.  */\n-  if (current_frame_info.reg_save_ar_pfs == 0\n-      && ! current_function_is_leaf)\n+  if (TEST_HARD_REG_BIT (current_frame_info.mask, AR_PFS_REGNUM)\n+      && current_frame_info.reg_save_ar_pfs == 0)\n     {\n       reg = gen_rtx_REG (DImode, AR_PFS_REGNUM);\n       do_spill (gen_movdi_x, ar_pfs_save_reg, cfa_off, reg);"}]}