{"sha": "20e38fcf4ff4d96d4d12d2939a94495166811203", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBlMzhmY2Y0ZmY0ZDk2ZDRkMTJkMjkzOWE5NDQ5NTE2NjgxMTIwMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-04-15T18:51:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-04-15T18:51:49Z"}, "message": "re PR tree-optimization/47679 (Strange uninitialized warning after SRA)\n\n\tPR tree-optimization/47679\n\t* tree-ssa-dom.c (build_and_record_new_cond): Moved to avoid\n\tneed for forward declaration in upcoming changes.\n\t(record_conditions, record_edge_info): Likewise.\n\nFrom-SVN: r222130", "tree": {"sha": "8dbdf7b00a679005555d88ea1f9b3e4ecc4cb9aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dbdf7b00a679005555d88ea1f9b3e4ecc4cb9aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20e38fcf4ff4d96d4d12d2939a94495166811203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20e38fcf4ff4d96d4d12d2939a94495166811203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20e38fcf4ff4d96d4d12d2939a94495166811203", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20e38fcf4ff4d96d4d12d2939a94495166811203/comments", "author": null, "committer": null, "parents": [{"sha": "5283d1ecc4ed755bca87e31afd0deaf8af17591a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5283d1ecc4ed755bca87e31afd0deaf8af17591a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5283d1ecc4ed755bca87e31afd0deaf8af17591a"}], "stats": {"total": 696, "additions": 351, "deletions": 345}, "files": [{"sha": "afa9266d1f87ddd4a00af57b533cf149d06c8f3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20e38fcf4ff4d96d4d12d2939a94495166811203/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20e38fcf4ff4d96d4d12d2939a94495166811203/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20e38fcf4ff4d96d4d12d2939a94495166811203", "patch": "@@ -12,6 +12,11 @@\n \n 2015-04-15  Jeff Law  <law@redhat.com>\n \n+\tPR tree-optimization/47679\n+\t* tree-ssa-dom.c (build_and_record_new_cond): Moved to avoid\n+\tneed for forward declaration in upcoming changes.\n+\t(record_conditions, record_edge_info): Likewise.\n+\n \tPR rtl-optimization/42522\n \t* cse.c (fold_rtx): Try to simplify a ZERO_EXTRACT or\n \tSIGN_EXTRACT as a whole object rather than simplifying"}, {"sha": "907fa970775c02603b6f27c9625a8cf9f28bd637", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 346, "deletions": 345, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20e38fcf4ff4d96d4d12d2939a94495166811203/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20e38fcf4ff4d96d4d12d2939a94495166811203/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=20e38fcf4ff4d96d4d12d2939a94495166811203", "patch": "@@ -827,6 +827,317 @@ free_all_edge_infos (void)\n     }\n }\n \n+/* Build a cond_equivalence record indicating that the comparison\n+   CODE holds between operands OP0 and OP1 and push it to **P.  */\n+\n+static void\n+build_and_record_new_cond (enum tree_code code,\n+                           tree op0, tree op1,\n+                           vec<cond_equivalence> *p)\n+{\n+  cond_equivalence c;\n+  struct hashable_expr *cond = &c.cond;\n+\n+  gcc_assert (TREE_CODE_CLASS (code) == tcc_comparison);\n+\n+  cond->type = boolean_type_node;\n+  cond->kind = EXPR_BINARY;\n+  cond->ops.binary.op = code;\n+  cond->ops.binary.opnd0 = op0;\n+  cond->ops.binary.opnd1 = op1;\n+\n+  c.value = boolean_true_node;\n+  p->safe_push (c);\n+}\n+\n+/* Record that COND is true and INVERTED is false into the edge information\n+   structure.  Also record that any conditions dominated by COND are true\n+   as well.\n+\n+   For example, if a < b is true, then a <= b must also be true.  */\n+\n+static void\n+record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n+{\n+  tree op0, op1;\n+  cond_equivalence c;\n+\n+  if (!COMPARISON_CLASS_P (cond))\n+    return;\n+\n+  op0 = TREE_OPERAND (cond, 0);\n+  op1 = TREE_OPERAND (cond, 1);\n+\n+  switch (TREE_CODE (cond))\n+    {\n+    case LT_EXPR:\n+    case GT_EXPR:\n+      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n+\t{\n+\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n+\t\t\t\t     &edge_info->cond_equivalences);\n+\t  build_and_record_new_cond (LTGT_EXPR, op0, op1,\n+\t\t\t\t     &edge_info->cond_equivalences);\n+\t}\n+\n+      build_and_record_new_cond ((TREE_CODE (cond) == LT_EXPR\n+\t\t\t\t  ? LE_EXPR : GE_EXPR),\n+\t\t\t\t op0, op1, &edge_info->cond_equivalences);\n+      build_and_record_new_cond (NE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      break;\n+\n+    case GE_EXPR:\n+    case LE_EXPR:\n+      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n+\t{\n+\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n+\t\t\t\t     &edge_info->cond_equivalences);\n+\t}\n+      break;\n+\n+    case EQ_EXPR:\n+      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n+\t{\n+\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n+\t\t\t\t     &edge_info->cond_equivalences);\n+\t}\n+      build_and_record_new_cond (LE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      build_and_record_new_cond (GE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      break;\n+\n+    case UNORDERED_EXPR:\n+      build_and_record_new_cond (NE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      build_and_record_new_cond (UNLE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      build_and_record_new_cond (UNGE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      build_and_record_new_cond (UNEQ_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      build_and_record_new_cond (UNLT_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      build_and_record_new_cond (UNGT_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      break;\n+\n+    case UNLT_EXPR:\n+    case UNGT_EXPR:\n+      build_and_record_new_cond ((TREE_CODE (cond) == UNLT_EXPR\n+\t\t\t\t  ? UNLE_EXPR : UNGE_EXPR),\n+\t\t\t\t op0, op1, &edge_info->cond_equivalences);\n+      build_and_record_new_cond (NE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      break;\n+\n+    case UNEQ_EXPR:\n+      build_and_record_new_cond (UNLE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      build_and_record_new_cond (UNGE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      break;\n+\n+    case LTGT_EXPR:\n+      build_and_record_new_cond (NE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Now store the original true and false conditions into the first\n+     two slots.  */\n+  initialize_expr_from_cond (cond, &c.cond);\n+  c.value = boolean_true_node;\n+  edge_info->cond_equivalences.safe_push (c);\n+\n+  /* It is possible for INVERTED to be the negation of a comparison,\n+     and not a valid RHS or GIMPLE_COND condition.  This happens because\n+     invert_truthvalue may return such an expression when asked to invert\n+     a floating-point comparison.  These comparisons are not assumed to\n+     obey the trichotomy law.  */\n+  initialize_expr_from_cond (inverted, &c.cond);\n+  c.value = boolean_false_node;\n+  edge_info->cond_equivalences.safe_push (c);\n+}\n+\n+/* We have finished optimizing BB, record any information implied by\n+   taking a specific outgoing edge from BB.  */\n+\n+static void\n+record_edge_info (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  struct edge_info *edge_info;\n+\n+  if (! gsi_end_p (gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      location_t loc = gimple_location (stmt);\n+\n+      if (gimple_code (stmt) == GIMPLE_SWITCH)\n+\t{\n+\t  gswitch *switch_stmt = as_a <gswitch *> (stmt);\n+\t  tree index = gimple_switch_index (switch_stmt);\n+\n+\t  if (TREE_CODE (index) == SSA_NAME)\n+\t    {\n+\t      int i;\n+              int n_labels = gimple_switch_num_labels (switch_stmt);\n+\t      tree *info = XCNEWVEC (tree, last_basic_block_for_fn (cfun));\n+\t      edge e;\n+\t      edge_iterator ei;\n+\n+\t      for (i = 0; i < n_labels; i++)\n+\t\t{\n+\t\t  tree label = gimple_switch_label (switch_stmt, i);\n+\t\t  basic_block target_bb = label_to_block (CASE_LABEL (label));\n+\t\t  if (CASE_HIGH (label)\n+\t\t      || !CASE_LOW (label)\n+\t\t      || info[target_bb->index])\n+\t\t    info[target_bb->index] = error_mark_node;\n+\t\t  else\n+\t\t    info[target_bb->index] = label;\n+\t\t}\n+\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t{\n+\t\t  basic_block target_bb = e->dest;\n+\t\t  tree label = info[target_bb->index];\n+\n+\t\t  if (label != NULL && label != error_mark_node)\n+\t\t    {\n+\t\t      tree x = fold_convert_loc (loc, TREE_TYPE (index),\n+\t\t\t\t\t\t CASE_LOW (label));\n+\t\t      edge_info = allocate_edge_info (e);\n+\t\t      edge_info->lhs = index;\n+\t\t      edge_info->rhs = x;\n+\t\t    }\n+\t\t}\n+\t      free (info);\n+\t    }\n+\t}\n+\n+      /* A COND_EXPR may create equivalences too.  */\n+      if (gimple_code (stmt) == GIMPLE_COND)\n+\t{\n+\t  edge true_edge;\n+\t  edge false_edge;\n+\n+          tree op0 = gimple_cond_lhs (stmt);\n+          tree op1 = gimple_cond_rhs (stmt);\n+          enum tree_code code = gimple_cond_code (stmt);\n+\n+\t  extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+\n+          /* Special case comparing booleans against a constant as we\n+             know the value of OP0 on both arms of the branch.  i.e., we\n+             can record an equivalence for OP0 rather than COND.  */\n+          if ((code == EQ_EXPR || code == NE_EXPR)\n+              && TREE_CODE (op0) == SSA_NAME\n+              && TREE_CODE (TREE_TYPE (op0)) == BOOLEAN_TYPE\n+              && is_gimple_min_invariant (op1))\n+            {\n+              if (code == EQ_EXPR)\n+                {\n+                  edge_info = allocate_edge_info (true_edge);\n+                  edge_info->lhs = op0;\n+                  edge_info->rhs = (integer_zerop (op1)\n+                                    ? boolean_false_node\n+                                    : boolean_true_node);\n+\n+                  edge_info = allocate_edge_info (false_edge);\n+                  edge_info->lhs = op0;\n+                  edge_info->rhs = (integer_zerop (op1)\n+                                    ? boolean_true_node\n+                                    : boolean_false_node);\n+                }\n+              else\n+                {\n+                  edge_info = allocate_edge_info (true_edge);\n+                  edge_info->lhs = op0;\n+                  edge_info->rhs = (integer_zerop (op1)\n+                                    ? boolean_true_node\n+                                    : boolean_false_node);\n+\n+                  edge_info = allocate_edge_info (false_edge);\n+                  edge_info->lhs = op0;\n+                  edge_info->rhs = (integer_zerop (op1)\n+                                    ? boolean_false_node\n+                                    : boolean_true_node);\n+                }\n+            }\n+          else if (is_gimple_min_invariant (op0)\n+                   && (TREE_CODE (op1) == SSA_NAME\n+                       || is_gimple_min_invariant (op1)))\n+            {\n+              tree cond = build2 (code, boolean_type_node, op0, op1);\n+              tree inverted = invert_truthvalue_loc (loc, cond);\n+              bool can_infer_simple_equiv\n+                = !(HONOR_SIGNED_ZEROS (op0)\n+                    && real_zerop (op0));\n+              struct edge_info *edge_info;\n+\n+              edge_info = allocate_edge_info (true_edge);\n+              record_conditions (edge_info, cond, inverted);\n+\n+              if (can_infer_simple_equiv && code == EQ_EXPR)\n+                {\n+                  edge_info->lhs = op1;\n+                  edge_info->rhs = op0;\n+                }\n+\n+              edge_info = allocate_edge_info (false_edge);\n+              record_conditions (edge_info, inverted, cond);\n+\n+              if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n+                {\n+                  edge_info->lhs = op1;\n+                  edge_info->rhs = op0;\n+                }\n+            }\n+\n+          else if (TREE_CODE (op0) == SSA_NAME\n+                   && (TREE_CODE (op1) == SSA_NAME\n+                       || is_gimple_min_invariant (op1)))\n+            {\n+              tree cond = build2 (code, boolean_type_node, op0, op1);\n+              tree inverted = invert_truthvalue_loc (loc, cond);\n+              bool can_infer_simple_equiv\n+                = !(HONOR_SIGNED_ZEROS (op1)\n+                    && (TREE_CODE (op1) == SSA_NAME || real_zerop (op1)));\n+              struct edge_info *edge_info;\n+\n+              edge_info = allocate_edge_info (true_edge);\n+              record_conditions (edge_info, cond, inverted);\n+\n+              if (can_infer_simple_equiv && code == EQ_EXPR)\n+                {\n+                  edge_info->lhs = op0;\n+                  edge_info->rhs = op1;\n+                }\n+\n+              edge_info = allocate_edge_info (false_edge);\n+              record_conditions (edge_info, inverted, cond);\n+\n+              if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n+                {\n+                  edge_info->lhs = op0;\n+                  edge_info->rhs = op1;\n+                }\n+            }\n+        }\n+\n+      /* ??? TRUTH_NOT_EXPR can create an equivalence too.  */\n+    }\n+}\n+\n+\n class dom_opt_dom_walker : public dom_walker\n {\n public:\n@@ -1399,185 +1710,46 @@ debug_dominator_optimization_stats (void)\n }\n \n \n-/* Dump statistics for the hash table HTAB.  */\n-\n-static void\n-htab_statistics (FILE *file, const hash_table<expr_elt_hasher> &htab)\n-{\n-  fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n-\t   (long) htab.size (),\n-\t   (long) htab.elements (),\n-\t   htab.collisions ());\n-}\n-\n-\n-/* Enter condition equivalence into the expression hash table.\n-   This indicates that a conditional expression has a known\n-   boolean value.  */\n-\n-static void\n-record_cond (cond_equivalence *p)\n-{\n-  struct expr_hash_elt *element = XCNEW (struct expr_hash_elt);\n-  expr_hash_elt **slot;\n-\n-  initialize_hash_element_from_expr (&p->cond, p->value, element);\n-\n-  slot = avail_exprs->find_slot_with_hash (element, element->hash, INSERT);\n-  if (*slot == NULL)\n-    {\n-      *slot = element;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-          fprintf (dump_file, \"1>>> \");\n-          print_expr_hash_elt (dump_file, element);\n-        }\n-\n-      avail_exprs_stack.safe_push\n-\t(std::pair<expr_hash_elt_t, expr_hash_elt_t> (element, NULL));\n-    }\n-  else\n-    free_expr_hash_elt (element);\n-}\n-\n-/* Build a cond_equivalence record indicating that the comparison\n-   CODE holds between operands OP0 and OP1 and push it to **P.  */\n-\n-static void\n-build_and_record_new_cond (enum tree_code code,\n-                           tree op0, tree op1,\n-                           vec<cond_equivalence> *p)\n-{\n-  cond_equivalence c;\n-  struct hashable_expr *cond = &c.cond;\n-\n-  gcc_assert (TREE_CODE_CLASS (code) == tcc_comparison);\n-\n-  cond->type = boolean_type_node;\n-  cond->kind = EXPR_BINARY;\n-  cond->ops.binary.op = code;\n-  cond->ops.binary.opnd0 = op0;\n-  cond->ops.binary.opnd1 = op1;\n-\n-  c.value = boolean_true_node;\n-  p->safe_push (c);\n-}\n-\n-/* Record that COND is true and INVERTED is false into the edge information\n-   structure.  Also record that any conditions dominated by COND are true\n-   as well.\n-\n-   For example, if a < b is true, then a <= b must also be true.  */\n-\n-static void\n-record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n-{\n-  tree op0, op1;\n-  cond_equivalence c;\n-\n-  if (!COMPARISON_CLASS_P (cond))\n-    return;\n-\n-  op0 = TREE_OPERAND (cond, 0);\n-  op1 = TREE_OPERAND (cond, 1);\n-\n-  switch (TREE_CODE (cond))\n-    {\n-    case LT_EXPR:\n-    case GT_EXPR:\n-      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n-\t{\n-\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences);\n-\t  build_and_record_new_cond (LTGT_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences);\n-\t}\n-\n-      build_and_record_new_cond ((TREE_CODE (cond) == LT_EXPR\n-\t\t\t\t  ? LE_EXPR : GE_EXPR),\n-\t\t\t\t op0, op1, &edge_info->cond_equivalences);\n-      build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n-\n-    case GE_EXPR:\n-    case LE_EXPR:\n-      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n-\t{\n-\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences);\n-\t}\n-      break;\n-\n-    case EQ_EXPR:\n-      if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n-\t{\n-\t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences);\n-\t}\n-      build_and_record_new_cond (LE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (GE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n-\n-    case UNORDERED_EXPR:\n-      build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNLE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNGE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNEQ_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNLT_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNGT_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n-\n-    case UNLT_EXPR:\n-    case UNGT_EXPR:\n-      build_and_record_new_cond ((TREE_CODE (cond) == UNLT_EXPR\n-\t\t\t\t  ? UNLE_EXPR : UNGE_EXPR),\n-\t\t\t\t op0, op1, &edge_info->cond_equivalences);\n-      build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n+/* Dump statistics for the hash table HTAB.  */\n \n-    case UNEQ_EXPR:\n-      build_and_record_new_cond (UNLE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (UNGE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n+static void\n+htab_statistics (FILE *file, const hash_table<expr_elt_hasher> &htab)\n+{\n+  fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n+\t   (long) htab.size (),\n+\t   (long) htab.elements (),\n+\t   htab.collisions ());\n+}\n \n-    case LTGT_EXPR:\n-      build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences);\n-      break;\n \n-    default:\n-      break;\n-    }\n+/* Enter condition equivalence into the expression hash table.\n+   This indicates that a conditional expression has a known\n+   boolean value.  */\n \n-  /* Now store the original true and false conditions into the first\n-     two slots.  */\n-  initialize_expr_from_cond (cond, &c.cond);\n-  c.value = boolean_true_node;\n-  edge_info->cond_equivalences.safe_push (c);\n+static void\n+record_cond (cond_equivalence *p)\n+{\n+  struct expr_hash_elt *element = XCNEW (struct expr_hash_elt);\n+  expr_hash_elt **slot;\n \n-  /* It is possible for INVERTED to be the negation of a comparison,\n-     and not a valid RHS or GIMPLE_COND condition.  This happens because\n-     invert_truthvalue may return such an expression when asked to invert\n-     a floating-point comparison.  These comparisons are not assumed to\n-     obey the trichotomy law.  */\n-  initialize_expr_from_cond (inverted, &c.cond);\n-  c.value = boolean_false_node;\n-  edge_info->cond_equivalences.safe_push (c);\n+  initialize_hash_element_from_expr (&p->cond, p->value, element);\n+\n+  slot = avail_exprs->find_slot_with_hash (element, element->hash, INSERT);\n+  if (*slot == NULL)\n+    {\n+      *slot = element;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        {\n+          fprintf (dump_file, \"1>>> \");\n+          print_expr_hash_elt (dump_file, element);\n+        }\n+\n+      avail_exprs_stack.safe_push\n+\t(std::pair<expr_hash_elt_t, expr_hash_elt_t> (element, NULL));\n+    }\n+  else\n+    free_expr_hash_elt (element);\n }\n \n /* A helper function for record_const_or_copy and record_equality.\n@@ -1814,177 +1986,6 @@ cprop_into_successor_phis (basic_block bb)\n     }\n }\n \n-/* We have finished optimizing BB, record any information implied by\n-   taking a specific outgoing edge from BB.  */\n-\n-static void\n-record_edge_info (basic_block bb)\n-{\n-  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-  struct edge_info *edge_info;\n-\n-  if (! gsi_end_p (gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-      location_t loc = gimple_location (stmt);\n-\n-      if (gimple_code (stmt) == GIMPLE_SWITCH)\n-\t{\n-\t  gswitch *switch_stmt = as_a <gswitch *> (stmt);\n-\t  tree index = gimple_switch_index (switch_stmt);\n-\n-\t  if (TREE_CODE (index) == SSA_NAME)\n-\t    {\n-\t      int i;\n-              int n_labels = gimple_switch_num_labels (switch_stmt);\n-\t      tree *info = XCNEWVEC (tree, last_basic_block_for_fn (cfun));\n-\t      edge e;\n-\t      edge_iterator ei;\n-\n-\t      for (i = 0; i < n_labels; i++)\n-\t\t{\n-\t\t  tree label = gimple_switch_label (switch_stmt, i);\n-\t\t  basic_block target_bb = label_to_block (CASE_LABEL (label));\n-\t\t  if (CASE_HIGH (label)\n-\t\t      || !CASE_LOW (label)\n-\t\t      || info[target_bb->index])\n-\t\t    info[target_bb->index] = error_mark_node;\n-\t\t  else\n-\t\t    info[target_bb->index] = label;\n-\t\t}\n-\n-\t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t{\n-\t\t  basic_block target_bb = e->dest;\n-\t\t  tree label = info[target_bb->index];\n-\n-\t\t  if (label != NULL && label != error_mark_node)\n-\t\t    {\n-\t\t      tree x = fold_convert_loc (loc, TREE_TYPE (index),\n-\t\t\t\t\t\t CASE_LOW (label));\n-\t\t      edge_info = allocate_edge_info (e);\n-\t\t      edge_info->lhs = index;\n-\t\t      edge_info->rhs = x;\n-\t\t    }\n-\t\t}\n-\t      free (info);\n-\t    }\n-\t}\n-\n-      /* A COND_EXPR may create equivalences too.  */\n-      if (gimple_code (stmt) == GIMPLE_COND)\n-\t{\n-\t  edge true_edge;\n-\t  edge false_edge;\n-\n-          tree op0 = gimple_cond_lhs (stmt);\n-          tree op1 = gimple_cond_rhs (stmt);\n-          enum tree_code code = gimple_cond_code (stmt);\n-\n-\t  extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n-\n-          /* Special case comparing booleans against a constant as we\n-             know the value of OP0 on both arms of the branch.  i.e., we\n-             can record an equivalence for OP0 rather than COND.  */\n-          if ((code == EQ_EXPR || code == NE_EXPR)\n-              && TREE_CODE (op0) == SSA_NAME\n-              && TREE_CODE (TREE_TYPE (op0)) == BOOLEAN_TYPE\n-              && is_gimple_min_invariant (op1))\n-            {\n-              if (code == EQ_EXPR)\n-                {\n-                  edge_info = allocate_edge_info (true_edge);\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1)\n-                                    ? boolean_false_node\n-                                    : boolean_true_node);\n-\n-                  edge_info = allocate_edge_info (false_edge);\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1)\n-                                    ? boolean_true_node\n-                                    : boolean_false_node);\n-                }\n-              else\n-                {\n-                  edge_info = allocate_edge_info (true_edge);\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1)\n-                                    ? boolean_true_node\n-                                    : boolean_false_node);\n-\n-                  edge_info = allocate_edge_info (false_edge);\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = (integer_zerop (op1)\n-                                    ? boolean_false_node\n-                                    : boolean_true_node);\n-                }\n-            }\n-          else if (is_gimple_min_invariant (op0)\n-                   && (TREE_CODE (op1) == SSA_NAME\n-                       || is_gimple_min_invariant (op1)))\n-            {\n-              tree cond = build2 (code, boolean_type_node, op0, op1);\n-              tree inverted = invert_truthvalue_loc (loc, cond);\n-              bool can_infer_simple_equiv\n-                = !(HONOR_SIGNED_ZEROS (op0)\n-                    && real_zerop (op0));\n-              struct edge_info *edge_info;\n-\n-              edge_info = allocate_edge_info (true_edge);\n-              record_conditions (edge_info, cond, inverted);\n-\n-              if (can_infer_simple_equiv && code == EQ_EXPR)\n-                {\n-                  edge_info->lhs = op1;\n-                  edge_info->rhs = op0;\n-                }\n-\n-              edge_info = allocate_edge_info (false_edge);\n-              record_conditions (edge_info, inverted, cond);\n-\n-              if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n-                {\n-                  edge_info->lhs = op1;\n-                  edge_info->rhs = op0;\n-                }\n-            }\n-\n-          else if (TREE_CODE (op0) == SSA_NAME\n-                   && (TREE_CODE (op1) == SSA_NAME\n-                       || is_gimple_min_invariant (op1)))\n-            {\n-              tree cond = build2 (code, boolean_type_node, op0, op1);\n-              tree inverted = invert_truthvalue_loc (loc, cond);\n-              bool can_infer_simple_equiv\n-                = !(HONOR_SIGNED_ZEROS (op1)\n-                    && (TREE_CODE (op1) == SSA_NAME || real_zerop (op1)));\n-              struct edge_info *edge_info;\n-\n-              edge_info = allocate_edge_info (true_edge);\n-              record_conditions (edge_info, cond, inverted);\n-\n-              if (can_infer_simple_equiv && code == EQ_EXPR)\n-                {\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = op1;\n-                }\n-\n-              edge_info = allocate_edge_info (false_edge);\n-              record_conditions (edge_info, inverted, cond);\n-\n-              if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n-                {\n-                  edge_info->lhs = op0;\n-                  edge_info->rhs = op1;\n-                }\n-            }\n-        }\n-\n-      /* ??? TRUTH_NOT_EXPR can create an equivalence too.  */\n-    }\n-}\n-\n void\n dom_opt_dom_walker::before_dom_children (basic_block bb)\n {"}]}