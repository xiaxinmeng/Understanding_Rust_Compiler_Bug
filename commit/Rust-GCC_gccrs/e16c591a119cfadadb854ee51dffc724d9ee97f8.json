{"sha": "e16c591a119cfadadb854ee51dffc724d9ee97f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE2YzU5MWExMTljZmFkYWRiODU0ZWU1MWRmZmM3MjRkOWVlOTdmOA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-15T05:23:58Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-15T05:23:58Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r985", "tree": {"sha": "2cd9a2ba7bb7a66cefc41a9b5d7e29eea069a2cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cd9a2ba7bb7a66cefc41a9b5d7e29eea069a2cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e16c591a119cfadadb854ee51dffc724d9ee97f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16c591a119cfadadb854ee51dffc724d9ee97f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e16c591a119cfadadb854ee51dffc724d9ee97f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16c591a119cfadadb854ee51dffc724d9ee97f8/comments", "author": null, "committer": null, "parents": [{"sha": "611314a17ddd1e3f619e44ab9a745751fdafb2a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611314a17ddd1e3f619e44ab9a745751fdafb2a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611314a17ddd1e3f619e44ab9a745751fdafb2a9"}], "stats": {"total": 19, "additions": 19, "deletions": 0}, "files": [{"sha": "c2fc5e86a4fa58149e4301db6e7365cdd44f4210", "filename": "gcc/function.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16c591a119cfadadb854ee51dffc724d9ee97f8/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16c591a119cfadadb854ee51dffc724d9ee97f8/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e16c591a119cfadadb854ee51dffc724d9ee97f8", "patch": "@@ -2710,6 +2710,21 @@ assign_parms (fndecl, second_time)\n       if (second_time)\n \tcontinue;\n \n+      /* If we can't trust the parm stack slot to be aligned enough\n+\t for its ultimate type, don't use that slot after entry.\n+\t We'll make another stack slot, if we need one.  */\n+      {\n+#ifdef FUNCTION_ARG_BOUNDARY\n+\tint thisparm_boundary\n+\t  = FUNCTION_ARG_BOUNDARY (passed_mode, passed_type);\n+#else\n+\tint thisparm_boundary = PARM_BOUNDARY;\n+#endif\n+\n+\tif (GET_MODE_ALIGNMENT (nominal_mode) > thisparm_boundary)\n+\t  stack_parm = 0;\n+      }\n+\n       /* Now adjust STACK_PARM to the mode and precise location\n \t where this parameter should live during execution,\n \t if we discover that it must live in the stack during execution.\n@@ -2856,6 +2871,7 @@ assign_parms (fndecl, second_time)\n \t     as we make here would screw up life analysis for it.  */\n \t  if (nominal_mode == passed_mode\n \t      && GET_CODE (entry_parm) == MEM\n+\t      && entry_parm == stack_parm\n \t      && stack_offset.var == 0\n \t      && reg_mentioned_p (virtual_incoming_args_rtx,\n \t\t\t\t  XEXP (entry_parm, 0)))\n@@ -3088,6 +3104,9 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n #endif /* ARGS_GROW_DOWNWARD */\n }\n \n+/* Round the stack offset in *OFFSET_PTR up to a multiple of BOUNDARY.\n+   BOUNDARY is measured in bits, but must be a multiple of a storage unit.  */\n+\n static void\n pad_to_arg_alignment (offset_ptr, boundary)\n      struct args_size *offset_ptr;"}]}