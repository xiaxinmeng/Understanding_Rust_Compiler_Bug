{"sha": "81722fa979363c046801022c0c2c517f6ce3f0f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE3MjJmYTk3OTM2M2MwNDY4MDEwMjJjMGMyYzUxN2Y2Y2UzZjBmNw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-09T19:19:51Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-09T19:19:51Z"}, "message": "(emit_store_flag, expand_divmod): Use convert_modes.\n\nFrom-SVN: r5295", "tree": {"sha": "63d3258e187ee41731386ce0ced7de3ce3e46969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63d3258e187ee41731386ce0ced7de3ce3e46969"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81722fa979363c046801022c0c2c517f6ce3f0f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81722fa979363c046801022c0c2c517f6ce3f0f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81722fa979363c046801022c0c2c517f6ce3f0f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81722fa979363c046801022c0c2c517f6ce3f0f7/comments", "author": null, "committer": null, "parents": [{"sha": "b0bfa186290fe040e5451e4de867c7ec87d626cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0bfa186290fe040e5451e4de867c7ec87d626cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0bfa186290fe040e5451e4de867c7ec87d626cb"}], "stats": {"total": 10, "additions": 5, "deletions": 5}, "files": [{"sha": "21c771c14db2ae92f85c06358ed81a81c9d7df7c", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81722fa979363c046801022c0c2c517f6ce3f0f7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81722fa979363c046801022c0c2c517f6ce3f0f7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=81722fa979363c046801022c0c2c517f6ce3f0f7", "patch": "@@ -2369,9 +2369,9 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n      something.  */\n   if (compute_mode != mode)\n     {\n-      adjusted_op0 = op0 = convert_to_mode (compute_mode, op0, unsignedp);\n+      adjusted_op0 = op0 = convert_modes (compute_mode, mode, op0, unsignedp);\n       can_clobber_op0 = 1;\n-      op1 = convert_to_mode (compute_mode, op1, unsignedp);\n+      op1 = convert_modes (compute_mode, mode, op1, unsignedp);\n     }\n \n   /* If we are computing the remainder and one of the operands is a volatile\n@@ -2887,7 +2887,7 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n       if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (mode))\n \t{\n \t  op0 = protect_from_queue (op0, 0);\n-\t  op0 = convert_to_mode (target_mode, op0, 0);\n+\t  op0 = convert_modes (target_mode, mode, op0, 0);\n \t  mode = target_mode;\n \t}\n \n@@ -3127,9 +3127,9 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \ttem = expand_unop (mode, ffs_optab, op0, subtarget, 1);\n       else if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{\n-\t  mode = word_mode;\n \t  op0 = protect_from_queue (op0, 0);\n-\t  tem = convert_to_mode (mode, op0, 1);\n+\t  tem = convert_to_mode (word_mode, mode, op0, 1);\n+\t  mode = word_mode;\n \t}\n \n       if (tem != 0)"}]}