{"sha": "2b393f6f83903cb836676bbd042c1b99a6e7e6f7", "node_id": "C_kwDOANBUbNoAKDJiMzkzZjZmODM5MDNjYjgzNjY3NmJiZDA0MmMxYjk5YTZlN2U2Zjc", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-08-31T09:00:45Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-25T12:44:53Z"}, "message": "fortran: Move the clobber generation code\n\nThis change inlines the clobber generation code from\ngfc_conv_expr_reference to the single caller from where the add_clobber\nflag can be true, and removes the add_clobber argument.\n\nWhat motivates this is the standard making the procedure call a cause\nfor a variable to become undefined, which translates to a clobber\ngeneration, so clobber generation should be closely related to procedure\ncall generation, whereas it is rather orthogonal to variable reference\ngeneration.  Thus the generation of the clobber feels more appropriate\nin gfc_conv_procedure_call than in gfc_conv_expr_reference.\n\nBehaviour remains unchanged.\n\ngcc/fortran/ChangeLog:\n\n\t* trans.h (gfc_conv_expr_reference): Remove add_clobber\n\targument.\n\t* trans-expr.cc (gfc_conv_expr_reference): Ditto. Inline code\n\tdepending on add_clobber and conditions controlling it ...\n\t(gfc_conv_procedure_call): ... to here.", "tree": {"sha": "11dda7d311f3477abab35c27decdf9ea87544c25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11dda7d311f3477abab35c27decdf9ea87544c25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b393f6f83903cb836676bbd042c1b99a6e7e6f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b393f6f83903cb836676bbd042c1b99a6e7e6f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b393f6f83903cb836676bbd042c1b99a6e7e6f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b393f6f83903cb836676bbd042c1b99a6e7e6f7/comments", "author": null, "committer": null, "parents": [{"sha": "323c38c915f34883439e9e53b9eac5fe07cb8378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/323c38c915f34883439e9e53b9eac5fe07cb8378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/323c38c915f34883439e9e53b9eac5fe07cb8378"}], "stats": {"total": 63, "additions": 33, "deletions": 30}, "files": [{"sha": "7cdab1cc9b4e1920a5e9d1771811e6d25d6585e6", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b393f6f83903cb836676bbd042c1b99a6e7e6f7/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b393f6f83903cb836676bbd042c1b99a6e7e6f7/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=2b393f6f83903cb836676bbd042c1b99a6e7e6f7", "patch": "@@ -6395,7 +6395,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t&& e->symtree->n.sym->attr.pointer))\n \t\t\t&& fsym && fsym->attr.target)\n \t\t/* Make sure the function only gets called once.  */\n-\t\tgfc_conv_expr_reference (&parmse, e, false);\n+\t\tgfc_conv_expr_reference (&parmse, e);\n \t      else if (e->expr_type == EXPR_FUNCTION\n \t\t       && e->symtree->n.sym->result\n \t\t       && e->symtree->n.sym->result != e->symtree->n.sym\n@@ -6502,22 +6502,36 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      bool add_clobber;\n-\t\t      add_clobber = fsym && fsym->attr.intent == INTENT_OUT\n-\t\t\t&& !fsym->attr.allocatable && !fsym->attr.pointer\n-\t\t\t&& e->symtree && e->symtree->n.sym\n-\t\t\t&& !e->symtree->n.sym->attr.dimension\n-\t\t\t&& !e->symtree->n.sym->attr.pointer\n-\t\t\t&& !e->symtree->n.sym->attr.allocatable\n-\t\t\t/* See PR 41453.  */\n-\t\t\t&& !e->symtree->n.sym->attr.dummy\n-\t\t\t/* FIXME - PR 87395 and PR 41453  */\n-\t\t\t&& e->symtree->n.sym->attr.save == SAVE_NONE\n-\t\t\t&& !e->symtree->n.sym->attr.associate_var\n-\t\t\t&& e->ts.type != BT_CHARACTER && e->ts.type != BT_DERIVED\n-\t\t\t&& e->ts.type != BT_CLASS && !sym->attr.elemental;\n-\n-\t\t      gfc_conv_expr_reference (&parmse, e, add_clobber);\n+\t\t      gfc_conv_expr_reference (&parmse, e);\n+\n+\t\t      if (fsym\n+\t\t\t  && fsym->attr.intent == INTENT_OUT\n+\t\t\t  && !fsym->attr.allocatable\n+\t\t\t  && !fsym->attr.pointer\n+\t\t\t  && e->expr_type == EXPR_VARIABLE\n+\t\t\t  && e->ref == NULL\n+\t\t\t  && e->symtree\n+\t\t\t  && e->symtree->n.sym\n+\t\t\t  && !e->symtree->n.sym->attr.dimension\n+\t\t\t  && !e->symtree->n.sym->attr.pointer\n+\t\t\t  && !e->symtree->n.sym->attr.allocatable\n+\t\t\t  /* See PR 41453.  */\n+\t\t\t  && !e->symtree->n.sym->attr.dummy\n+\t\t\t  /* FIXME - PR 87395 and PR 41453  */\n+\t\t\t  && e->symtree->n.sym->attr.save == SAVE_NONE\n+\t\t\t  && !e->symtree->n.sym->attr.associate_var\n+\t\t\t  && e->ts.type != BT_CHARACTER\n+\t\t\t  && e->ts.type != BT_DERIVED\n+\t\t\t  && e->ts.type != BT_CLASS\n+\t\t\t  && !sym->attr.elemental)\n+\t\t\t{\n+\t\t\t  tree var;\n+\t\t\t  /* FIXME: This fails if var is passed by reference, see PR\n+\t\t\t     41453.  */\n+\t\t\t  var = e->symtree->n.sym->backend_decl;\n+\t\t\t  tree clobber = build_clobber (TREE_TYPE (var));\n+\t\t\t  gfc_add_modify (&se->pre, var, clobber);\n+\t\t\t}\n \t\t    }\n \t\t  /* Catch base objects that are not variables.  */\n \t\t  if (e->ts.type == BT_CLASS\n@@ -9484,7 +9498,7 @@ gfc_conv_expr_type (gfc_se * se, gfc_expr * expr, tree type)\n    values only.  */\n \n void\n-gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)\n+gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n {\n   gfc_ss *ss;\n   tree var;\n@@ -9524,16 +9538,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)\n \t  gfc_add_block_to_block (&se->pre, &se->post);\n \t  se->expr = var;\n \t}\n-      else if (add_clobber && expr->ref == NULL)\n-\t{\n-\t  tree clobber;\n-\t  tree var;\n-\t  /* FIXME: This fails if var is passed by reference, see PR\n-\t     41453.  */\n-\t  var = expr->symtree->n.sym->backend_decl;\n-\t  clobber = build_clobber (TREE_TYPE (var));\n-\t  gfc_add_modify (&se->pre, var, clobber);\n-\t}\n       return;\n     }\n "}, {"sha": "bc9035c1717e9053cabfe17ed2e3ad1d720d1e1c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b393f6f83903cb836676bbd042c1b99a6e7e6f7/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b393f6f83903cb836676bbd042c1b99a6e7e6f7/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=2b393f6f83903cb836676bbd042c1b99a6e7e6f7", "patch": "@@ -499,8 +499,7 @@ tree gfc_build_compare_string (tree, tree, tree, tree, int, enum tree_code);\n void gfc_conv_expr (gfc_se * se, gfc_expr * expr);\n void gfc_conv_expr_val (gfc_se * se, gfc_expr * expr);\n void gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr);\n-void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr,\n-\t\t\t      bool add_clobber = false);\n+void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr);\n void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);\n \n "}]}