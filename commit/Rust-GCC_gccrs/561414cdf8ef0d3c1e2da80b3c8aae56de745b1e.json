{"sha": "561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "node_id": "C_kwDOANBUbNoAKDU2MTQxNGNkZjhlZjBkM2MxZTJkYTgwYjNjOGFhZTU2ZGU3NDViMWU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-14T13:15:52Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-14T13:15:52Z"}, "message": "c++: processing_template_decl vs template depth [PR103408]\n\nWe use processing_template_decl in two slightly different ways: as a\nflag to signal that we're dealing with templated trees, and as a measure\nof the current syntactic template nesting depth.  This overloaded\nmeaning of p_t_d is conceptually confusing and leads to bugs that we end\nup working around in an ad-hoc fashion.\n\nThis patch replaces all uses of processing_template_decl that care about\nits magnitude to instead look at the depth of current_template_parms\nvia a new macro current_template_depth.  This allows us to eliminate 3\nworkarounds in the concepts code: two about non-templated\nrequires-expressions (in constraint.cc) and one about lambdas inside\nconstraints (in cp_parser_requires_clause_expression etc).  This also\nfixes the testcase in PR103408 about auto(x) used inside a non-templated\nrequires-expression.\n\nThe replacement was mostly mechanical, aside from two issues:\n\n  * In synthesize_implicit_template_parm, when introducing a new template\n    parameter list for an abbreviated function template, we need to add\n    the new level of current_template_parms sooner, before calling\n    process_template_parm, since this latter function now looks at\n    current_template_depth to determine the level of the new parameter.\n\n  * In instantiate_class_template_1 after substituting a template\n    friend declaration, we currently increment processing_template_decl\n    around the call to make_friend_class so that the friend_depth\n    computation within this subroutine yields a nonzero value.  We could\n    just replace this with an equivalent manipulation of\n    current_template_depth, but this patch instead rewrites the\n    friend_depth calculation within make_friend_class to not depend on\n    p_t_d / c_t_d at all when called from instantiate_class_template_1.\n\n\tPR c++/103408\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (type_deducible_p): Remove workaround for\n\tnon-templated requires-expressions.\n\t(normalize_placeholder_type_constraints): Likewise.\n\t* cp-tree.h (current_template_depth): Define.\n\t(PROCESSING_REAL_TEMPLATE_DECL): Inspect current_template_depth\n\tinstead of the magnitude of processing_template_decl.\n\t* decl.c (start_decl): Likewise.\n\t(grokfndecl): Likewise.\n\t(grokvardecl): Likewise.\n\t(grokdeclarator): Likewise.\n\t* friend.c (make_friend_class): Likewise.  Calculate\n\tfriend_depth differently when called at instantiation time\n\tinstead of parse time.\n\t(do_friend): Likewise.\n\t* parser.c (cp_parser_requires_clause_expression): Remove\n\tworkaround for lambdas inside constraints.\n\t(cp_parser_constraint_expression): Likewise.\n\t(cp_parser_requires_expression): Likewise.\n\t(synthesize_implicit_template_parm): Add to current_template_parms\n\tbefore calling process_template_parm.\n\t* pt.c (inline_needs_template_parms): Inspect\n\tcurrent_template_depth instead of the magnitude of\n\tprocessing_template_decl.\n\t(push_inline_template_parms_recursive): Likewise.\n\t(maybe_begin_member_template_processing): Likewise.\n\t(begin_template_parm_list): Likewise.\n\t(process_template_parm): Likewise.\n\t(end_template_parm_list): Likewise.\n\t(push_template_decl): Likewise.\n\t(add_inherited_template_parms): Likewise.\n\t(instantiate_class_template_1): Don't adjust\n\tprocessing_template_decl around the call to make_friend_class.\n\tadjust_processing_template_decl to adjust_template_depth.  Set\n\tcurrent_template_parms instead of processing_template_decl when\n\tadjust_template_depth.\n\t(make_auto_1): Inspect current_template_depth instead of the\n\tmagnitude of processing_template_decl.\n\t(splice_late_return_type): Likewise.\n\t* semantics.c (fixup_template_type): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/concepts/diagnostic18.C: Expect a \"constraints on a\n\tnon-templated function\" error.\n\t* g++.dg/cpp23/auto-fncast11.C: New test.", "tree": {"sha": "22bf362d19f6c751e5b95275d57a26fdcdcc9b43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22bf362d19f6c751e5b95275d57a26fdcdcc9b43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/comments", "author": null, "committer": null, "parents": [{"sha": "d8eae5abf3d9d1363980342889635ccee1a7090d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8eae5abf3d9d1363980342889635ccee1a7090d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8eae5abf3d9d1363980342889635ccee1a7090d"}], "stats": {"total": 152, "additions": 76, "deletions": 76}, "files": [{"sha": "566f4e38fac9a1e8664da1c6f0bd7799709fa343", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -2016,14 +2016,6 @@ type_deducible_p (tree expr, tree type, tree placeholder, tree args,\n      references are preserved in the result.  */\n   expr = force_paren_expr_uneval (expr);\n \n-  /* When args is NULL, we're evaluating a non-templated requires expression,\n-     but even those are parsed under processing_template_decl == 1, and so the\n-     placeholder 'auto' inside this return-type-requirement has level 2.  In\n-     order to have all parms and arguments match up for satisfaction, we need\n-     to pass an empty level of OUTER_TARGS in this case.  */\n-  if (!args)\n-    args = make_tree_vec (0);\n-\n   tree deduced_type = do_auto_deduction (type, expr, placeholder,\n \t\t\t\t\t info.complain, adc_requirement,\n \t\t\t\t\t /*outer_targs=*/args);\n@@ -3064,14 +3056,6 @@ normalize_placeholder_type_constraints (tree t, bool diag)\n      parameters for normalization.  */\n   tree initial_parms = TREE_PURPOSE (ci);\n \n-  if (!initial_parms && TEMPLATE_TYPE_LEVEL (t) == 2)\n-    /* This is a return-type-requirement of a non-templated requires-expression,\n-       which are parsed under processing_template_decl == 1 and empty\n-       current_template_parms; hence the 'auto' has level 2 and initial_parms\n-       is empty.  Fix up initial_parms to be consistent with the value of\n-       processing_template_decl whence the 'auto' was created.  */\n-    initial_parms = build_tree_list (size_int (1), make_tree_vec (0));\n-\n   /* The 'auto' itself is used as the first argument in its own constraints,\n      and its level is one greater than its template depth.  So in order to\n      capture all used template parameters, we need to add an extra level of"}, {"sha": "7f32cf56383cf4131eee704122f0df86ef53f4c2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -1886,6 +1886,8 @@ extern GTY(()) struct saved_scope *scope_chain;\n    stored in the TREE_VALUE.  */\n \n #define current_template_parms scope_chain->template_parms\n+#define current_template_depth \\\n+  (current_template_parms ? TMPL_PARMS_DEPTH (current_template_parms) : 0)\n \n #define processing_template_decl scope_chain->x_processing_template_decl\n #define processing_specialization scope_chain->x_processing_specialization\n@@ -5099,7 +5101,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    full specialization.  */\n #define PROCESSING_REAL_TEMPLATE_DECL_P() \\\n   (!processing_template_parmlist \\\n-   && processing_template_decl > template_class_depth (current_scope ()))\n+   && current_template_depth > template_class_depth (current_scope ()))\n \n /* Nonzero if this VAR_DECL or FUNCTION_DECL has already been\n    instantiated, i.e. its definition has been generated from the"}, {"sha": "7c2048c6acb783a406bc2b9f91ac97ec5da6d6f0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -5567,7 +5567,7 @@ start_decl (const cp_declarator *declarator,\n \n   if (TYPE_P (context) && COMPLETE_TYPE_P (complete_type (context)))\n     {\n-      bool this_tmpl = (processing_template_decl\n+      bool this_tmpl = (current_template_depth\n \t\t\t> template_class_depth (context));\n       if (VAR_P (decl))\n \t{\n@@ -9878,7 +9878,7 @@ grokfndecl (tree ctype,\n       tree ctx = friendp ? current_class_type : ctype;\n       bool block_local = TREE_CODE (current_scope ()) == FUNCTION_DECL;\n       bool memtmpl = (!block_local\n-\t\t      && (processing_template_decl\n+\t\t      && (current_template_depth\n \t\t\t  > template_class_depth (ctx)));\n       if (memtmpl)\n \t{\n@@ -10300,7 +10300,7 @@ grokfndecl (tree ctype,\n   if (ctype != NULL_TREE && check)\n     {\n       tree old_decl = check_classfn (ctype, decl,\n-\t\t\t\t     (processing_template_decl\n+\t\t\t\t     (current_template_depth\n \t\t\t\t      > template_class_depth (ctype))\n \t\t\t\t     ? current_template_parms\n \t\t\t\t     : NULL_TREE);\n@@ -10576,7 +10576,7 @@ grokvardecl (tree type,\n         }\n     }\n   else if (flag_concepts\n-\t   && processing_template_decl > template_class_depth (scope))\n+\t   && current_template_depth > template_class_depth (scope))\n     {\n       tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n       tree ci = build_constraints (reqs, NULL_TREE);\n@@ -13975,7 +13975,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \n \t\t/* Set the constraints on the declaration.  */\n-\t\tbool memtmpl = (processing_template_decl\n+\t\tbool memtmpl = (current_template_depth\n \t\t\t\t> template_class_depth (current_class_type));\n \t\tif (memtmpl)\n \t\t  {"}, {"sha": "e552659ab5777ad4cf73d16fa2d52b7088f0f353", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -261,7 +261,20 @@ make_friend_class (tree type, tree friend_type, bool complain)\n      The friend is a template friend iff FRIEND_DEPTH is nonzero.  */\n \n   int class_template_depth = template_class_depth (type);\n-  int friend_depth = processing_template_decl - class_template_depth;\n+  int friend_depth = 0;\n+  if (current_template_depth)\n+    /* When processing a friend declaration at parse time, just compare the\n+       current depth to that of the class template.  */\n+    friend_depth = current_template_depth - class_template_depth;\n+  else\n+    {\n+      /* Otherwise, we got here from instantiate_class_template.  Determine\n+\t the friend depth by looking at the template parameters used within\n+\t FRIEND_TYPE.  */\n+      gcc_checking_assert (class_template_depth == 0);\n+      while (uses_template_parms_level (friend_type, friend_depth + 1))\n+\t++friend_depth;\n+    }\n \n   if (! MAYBE_CLASS_TYPE_P (friend_type)\n       && TREE_CODE (friend_type) != TEMPLATE_TEMPLATE_PARM)\n@@ -351,8 +364,13 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t  tree name = TYPE_IDENTIFIER (friend_type);\n \t  tree decl;\n \n-\t  if (!uses_template_parms_level (ctype, class_template_depth\n-\t\t\t\t\t\t + friend_depth))\n+\t  /* We need to distinguish a TYPENAME_TYPE for the non-template\n+\t     class B in\n+\t       template<class T> friend class A<T>::B;\n+\t     vs for the class template B in\n+\t       template<class T> template<class U> friend class A<T>::B;  */\n+\t  if (current_template_depth\n+\t      && !uses_template_parms_level (ctype, current_template_depth))\n \t    template_member_p = true;\n \n \t  if (class_template_depth)\n@@ -517,7 +535,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t 3. TEMPLATE_MEMBER_P is true (for `W').  */\n \n       int class_template_depth = template_class_depth (current_class_type);\n-      int friend_depth = processing_template_decl - class_template_depth;\n+      int friend_depth = current_template_depth - class_template_depth;\n       /* We will figure this out later.  */\n       bool template_member_p = false;\n "}, {"sha": "c2564e51e41682391a2150ef029a831ce7606501", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -29779,14 +29779,9 @@ static tree\n cp_parser_requires_clause_expression (cp_parser *parser, bool lambda_p)\n {\n   processing_constraint_expression_sentinel parsing_constraint;\n-  temp_override<int> ovr (processing_template_decl);\n-  if (!processing_template_decl)\n-    /* Adjust processing_template_decl so that we always obtain template\n-       trees here.  We don't do the usual ++processing_template_decl\n-       because that would skew the template parameter depth of a lambda\n-       within if we're already inside a template.  */\n-    processing_template_decl = 1;\n+  ++processing_template_decl;\n   cp_expr expr = cp_parser_constraint_logical_or_expression (parser, lambda_p);\n+  --processing_template_decl;\n   if (check_for_bare_parameter_packs (expr))\n     expr = error_mark_node;\n   return expr;\n@@ -29805,12 +29800,10 @@ static tree\n cp_parser_constraint_expression (cp_parser *parser)\n {\n   processing_constraint_expression_sentinel parsing_constraint;\n-  temp_override<int> ovr (processing_template_decl);\n-  if (!processing_template_decl)\n-    /* As in cp_parser_requires_clause_expression.  */\n-    processing_template_decl = 1;\n+  ++processing_template_decl;\n   cp_expr expr = cp_parser_binary_expression (parser, false, true,\n \t\t\t\t\t      PREC_NOT_OPERATOR, NULL);\n+  --processing_template_decl;\n   if (check_for_bare_parameter_packs (expr))\n     expr = error_mark_node;\n   expr.maybe_add_location_wrapper ();\n@@ -29924,11 +29917,9 @@ cp_parser_requires_expression (cp_parser *parser)\n       parms = NULL_TREE;\n \n     /* Parse the requirement body. */\n-    temp_override<int> ovr (processing_template_decl);\n-    if (!processing_template_decl)\n-      /* As in cp_parser_requires_clause_expression.  */\n-      processing_template_decl = 1;\n+    ++processing_template_decl;\n     reqs = cp_parser_requirement_body (parser);\n+    --processing_template_decl;\n     if (reqs == error_mark_node)\n       return error_mark_node;\n   }\n@@ -48091,6 +48082,10 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n   gcc_assert(!proto || TREE_CODE (proto) == TYPE_DECL);\n   synth_tmpl_parm = finish_template_type_parm (class_type_node, synth_id);\n \n+  if (become_template)\n+    current_template_parms = tree_cons (size_int (current_template_depth + 1),\n+\t\t\t\t\tNULL_TREE, current_template_parms);\n+\n   /* Attach the constraint to the parm before processing.  */\n   tree node = build_tree_list (NULL_TREE, synth_tmpl_parm);\n   TREE_TYPE (node) = constr;\n@@ -48130,8 +48125,7 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n \n       tree new_parms = make_tree_vec (1);\n       TREE_VEC_ELT (new_parms, 0) = parser->implicit_template_parms;\n-      current_template_parms = tree_cons (size_int (processing_template_decl),\n-\t\t\t\t\t  new_parms, current_template_parms);\n+      TREE_VALUE (current_template_parms) = new_parms;\n     }\n   else\n     {"}, {"sha": "42133a30c97f7a4dabc8a1583ad0908c4a052aaa", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -448,7 +448,7 @@ inline_needs_template_parms (tree decl, bool nsdmi)\n     return false;\n \n   return (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (most_general_template (decl)))\n-\t  > (processing_template_decl + DECL_TEMPLATE_SPECIALIZATION (decl)));\n+\t  > (current_template_depth + DECL_TEMPLATE_SPECIALIZATION (decl)));\n }\n \n /* Subroutine of maybe_begin_member_template_processing.\n@@ -467,7 +467,7 @@ push_inline_template_parms_recursive (tree parmlist, int levels)\n \n   ++processing_template_decl;\n   current_template_parms\n-    = tree_cons (size_int (processing_template_decl),\n+    = tree_cons (size_int (current_template_depth + 1),\n \t\t parms, current_template_parms);\n   TEMPLATE_PARMS_FOR_INLINE (current_template_parms) = 1;\n \n@@ -523,7 +523,7 @@ maybe_begin_member_template_processing (tree decl)\n   if (inline_needs_template_parms (decl, nsdmi))\n     {\n       parms = DECL_TEMPLATE_PARMS (most_general_template (decl));\n-      levels = TMPL_PARMS_DEPTH (parms) - processing_template_decl;\n+      levels = TMPL_PARMS_DEPTH (parms) - current_template_depth;\n \n       if (DECL_TEMPLATE_SPECIALIZATION (decl))\n \t{\n@@ -716,7 +716,7 @@ begin_template_parm_list (void)\n \n   /* Add a dummy parameter level while we process the parameter list.  */\n   current_template_parms\n-    = tree_cons (size_int (processing_template_decl),\n+    = tree_cons (size_int (current_template_depth + 1),\n \t\t make_tree_vec (0),\n \t\t current_template_parms);\n }\n@@ -4613,8 +4613,8 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n       TREE_CONSTANT (decl) = 1;\n       TREE_READONLY (decl) = 1;\n       DECL_INITIAL (parm) = DECL_INITIAL (decl)\n-\t= build_template_parm_index (idx, processing_template_decl,\n-\t\t\t\t     processing_template_decl,\n+\t= build_template_parm_index (idx, current_template_depth,\n+\t\t\t\t     current_template_depth,\n \t\t\t\t     decl, TREE_TYPE (parm));\n \n       TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm))\n@@ -4655,8 +4655,8 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n       TYPE_STUB_DECL (t) = decl;\n       parm = decl;\n       TEMPLATE_TYPE_PARM_INDEX (t)\n-\t= build_template_parm_index (idx, processing_template_decl,\n-\t\t\t\t     processing_template_decl,\n+\t= build_template_parm_index (idx, current_template_depth,\n+\t\t\t\t     current_template_depth,\n \t\t\t\t     decl, TREE_TYPE (parm));\n       TEMPLATE_TYPE_PARAMETER_PACK (t) = is_parameter_pack;\n       if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n@@ -4705,7 +4705,7 @@ end_template_parm_list (tree parms)\n   current_template_parms = TREE_CHAIN (current_template_parms);\n \n   current_template_parms\n-    = tree_cons (size_int (processing_template_decl),\n+    = tree_cons (size_int (current_template_depth + 1),\n \t\t saved_parmlist, current_template_parms);\n \n   for (unsigned ix = 0; parms; ix++)\n@@ -5747,7 +5747,7 @@ push_template_decl (tree decl, bool is_friend)\n   /* See if this is a primary template.  */\n   bool is_primary = false;\n   if (is_friend && ctx\n-      && uses_template_parms_level (ctx, processing_template_decl))\n+      && uses_template_parms_level (ctx, current_template_depth))\n     /* A friend template that specifies a class context, i.e.\n          template <typename T> friend void A<T>::f();\n        is not primary.  */\n@@ -6157,7 +6157,7 @@ add_inherited_template_parms (tree fn, tree inherited)\n     = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (inherited));\n   inner_parms = copy_node (inner_parms);\n   tree parms\n-    = tree_cons (size_int (processing_template_decl + 1),\n+    = tree_cons (size_int (current_template_depth + 1),\n \t\t inner_parms, current_template_parms);\n   tree tmpl = build_template_decl (fn, parms, /*member*/true);\n   tree args = template_parms_to_args (parms);\n@@ -12165,13 +12165,10 @@ instantiate_class_template_1 (tree type)\n \t      /* Build new CLASSTYPE_FRIEND_CLASSES.  */\n \n \t      tree friend_type = t;\n-\t      bool adjust_processing_template_decl = false;\n-\n \t      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n \t\t{\n \t\t  /* template <class T> friend class C;  */\n \t\t  friend_type = tsubst_friend_class (friend_type, args);\n-\t\t  adjust_processing_template_decl = true;\n \t\t}\n \t      else if (TREE_CODE (friend_type) == UNBOUND_CLASS_TEMPLATE)\n \t\t{\n@@ -12180,7 +12177,6 @@ instantiate_class_template_1 (tree type)\n \t\t\t\t\ttf_warning_or_error, NULL_TREE);\n \t\t  if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n \t\t    friend_type = TREE_TYPE (friend_type);\n-\t\t  adjust_processing_template_decl = true;\n \t\t}\n \t      else if (TREE_CODE (friend_type) == TYPENAME_TYPE\n \t\t       || TREE_CODE (friend_type) == TEMPLATE_TYPE_PARM)\n@@ -12199,8 +12195,6 @@ instantiate_class_template_1 (tree type)\n \t\t  ++processing_template_decl;\n \t\t  friend_type = tsubst (friend_type, args,\n \t\t\t\t\ttf_warning_or_error, NULL_TREE);\n-\t\t  if (dependent_type_p (friend_type))\n-\t\t    adjust_processing_template_decl = true;\n \t\t  --processing_template_decl;\n \t\t}\n \t      else if (uses_template_parms (friend_type))\n@@ -12218,19 +12212,8 @@ instantiate_class_template_1 (tree type)\n \n \t\t We don't have to do anything in these cases.  */\n \n-\t      if (adjust_processing_template_decl)\n-\t\t/* Trick make_friend_class into realizing that the friend\n-\t\t   we're adding is a template, not an ordinary class.  It's\n-\t\t   important that we use make_friend_class since it will\n-\t\t   perform some error-checking and output cross-reference\n-\t\t   information.  */\n-\t\t++processing_template_decl;\n-\n \t      if (friend_type != error_mark_node)\n \t\tmake_friend_class (type, friend_type, /*complain=*/false);\n-\n-\t      if (adjust_processing_template_decl)\n-\t\t--processing_template_decl;\n \t    }\n \t  else\n \t    {\n@@ -28416,7 +28399,7 @@ make_auto_1 (tree name, bool set_canonical)\n   TYPE_NAME (au) = build_decl (input_location, TYPE_DECL, name, au);\n   TYPE_STUB_DECL (au) = TYPE_NAME (au);\n   TEMPLATE_TYPE_PARM_INDEX (au) = build_template_parm_index\n-    (0, processing_template_decl + 1, processing_template_decl + 1,\n+    (0, current_template_depth + 1, current_template_depth + 1,\n      TYPE_NAME (au), NULL_TREE);\n   if (set_canonical)\n     TYPE_CANONICAL (au) = canonical_type_parameter (au);\n@@ -30069,7 +30052,7 @@ splice_late_return_type (tree type, tree late_return_type)\n     }\n \n   if (tree auto_node = find_type_usage (type, is_auto))\n-    if (TEMPLATE_TYPE_LEVEL (auto_node) <= processing_template_decl)\n+    if (TEMPLATE_TYPE_LEVEL (auto_node) <= current_template_depth)\n       {\n \t/* In an abbreviated function template we didn't know we were dealing\n \t   with a function template when we saw the auto return type, so rebuild"}, {"sha": "d8b20ff5b1bd67db57a09a3b9a1a756e83a4ff01", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -3629,7 +3629,7 @@ fixup_template_type (tree type)\n   // the scope we're trying to enter.\n   tree parms = current_template_parms;\n   int depth = template_class_depth (type);\n-  for (int n = processing_template_decl; n > depth && parms; --n)\n+  for (int n = current_template_depth; n > depth && parms; --n)\n     parms = TREE_CHAIN (parms);\n   if (!parms)\n     return type;"}, {"sha": "c13b0472a6454d0758f35de9ddb87f77956beb73", "filename": "gcc/testsuite/g++.dg/concepts/diagnostic18.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fdiagnostic18.C?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -1,7 +1,7 @@\n // PR c++/100055\n // { dg-do compile { target concepts } }\n \n-void foo(auto&& arg) requires({}); // { dg-error \"statement-expressions are not allowed|braced-groups\" }\n+void foo(auto&& arg) requires({}); // { dg-error \"statement-expressions are not allowed|braced-groups|non-templated\" }\n \n template <auto = 0> requires ([]{}()); // { dg-error \"expected unqualified-id\" }\n-auto f() requires ([]{}());\n+auto f() requires ([]{}()); // { dg-error \"constraints on a non-templated\" }"}, {"sha": "669dda140355b8b0de75e9f69565478692e17ea5", "filename": "gcc/testsuite/g++.dg/cpp23/auto-fncast11.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fauto-fncast11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561414cdf8ef0d3c1e2da80b3c8aae56de745b1e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fauto-fncast11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fauto-fncast11.C?ref=561414cdf8ef0d3c1e2da80b3c8aae56de745b1e", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/103408\n+// { dg-do compile { target c++23 } }\n+\n+static_assert(requires { auto(0); });\n+static_assert(requires { auto{0}; });\n+\n+static_assert(requires { auto(auto(0)); });\n+static_assert(requires { auto{auto{0}}; });\n+\n+static_assert(requires { auto(auto(auto(0))); });\n+static_assert(requires { auto{auto{auto{0}}}; });\n+\n+static_assert(requires { requires auto(true); });\n+static_assert(requires { requires auto(auto(true)); });\n+\n+static_assert(!requires { requires auto(false); });\n+static_assert(!requires { requires auto(auto(false)); });\n+\n+auto f() requires (auto(false)); // { dg-error \"constraints on non-templated\" }"}]}