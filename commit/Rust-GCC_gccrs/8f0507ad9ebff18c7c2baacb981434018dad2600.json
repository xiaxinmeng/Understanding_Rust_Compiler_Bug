{"sha": "8f0507ad9ebff18c7c2baacb981434018dad2600", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYwNTA3YWQ5ZWJmZjE4YzdjMmJhYWNiOTgxNDM0MDE4ZGFkMjYwMA==", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-07-05T14:39:40Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:18Z"}, "message": "Type Resolve Struct initializtion of their fields", "tree": {"sha": "4d7a4d0c3d8d82af3ed0aacaac7accfc70d87b20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d7a4d0c3d8d82af3ed0aacaac7accfc70d87b20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f0507ad9ebff18c7c2baacb981434018dad2600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0507ad9ebff18c7c2baacb981434018dad2600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f0507ad9ebff18c7c2baacb981434018dad2600", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0507ad9ebff18c7c2baacb981434018dad2600/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d7ab6b109a7654c283705d90ff4c96f1266178a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7ab6b109a7654c283705d90ff4c96f1266178a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d7ab6b109a7654c283705d90ff4c96f1266178a"}], "stats": {"total": 126, "additions": 113, "deletions": 13}, "files": [{"sha": "8edebbad4edd07a07a4d8d48991ec36d8a7b6f92", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 105, "deletions": 6, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0507ad9ebff18c7c2baacb981434018dad2600/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0507ad9ebff18c7c2baacb981434018dad2600/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=8f0507ad9ebff18c7c2baacb981434018dad2600", "patch": "@@ -7,11 +7,12 @@\n       AST::PathIdentSegment seg (_X);                                          \\\n       auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n \tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n-\t\t\t\t  Linemap::unknown_location ()));              \\\n+\t\t\t\t  Linemap::predeclared_location ()));          \\\n       ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n       segs.push_back (::std::move (typePath));                                 \\\n-      auto bType = new AST::TypePath (::std::move (segs),                      \\\n-\t\t\t\t      Linemap::unknown_location (), false);    \\\n+      auto bType                                                               \\\n+\t= new AST::TypePath (::std::move (segs),                               \\\n+\t\t\t     Linemap::predeclared_location (), false);         \\\n       _S.InsertType (_X, bType);                                               \\\n     }                                                                          \\\n   while (0)\n@@ -413,22 +414,120 @@ TypeResolution::visit (AST::TupleExpr &expr)\n void\n TypeResolution::visit (AST::TupleIndexExpr &expr)\n {}\n+\n void\n TypeResolution::visit (AST::StructExprStruct &expr)\n {}\n+\n // void TypeResolution::visit(StructExprField& field) {}\n void\n TypeResolution::visit (AST::StructExprFieldIdentifier &field)\n {}\n+\n void\n TypeResolution::visit (AST::StructExprFieldIdentifierValue &field)\n-{}\n+{\n+  identifierBuffer = &field.field_name;\n+  field.value->accept_vis (*this);\n+}\n+\n void\n TypeResolution::visit (AST::StructExprFieldIndexValue &field)\n-{}\n+{\n+  tupleIndexBuffer = &field.index;\n+  field.value->accept_vis (*this);\n+}\n+\n void\n TypeResolution::visit (AST::StructExprStructFields &expr)\n-{}\n+{\n+  AST::StructStruct *decl = NULL;\n+  if (!scope.LookupStruct (expr.get_struct_name ().as_string (), &decl))\n+    {\n+      rust_error_at (expr.get_locus_slow (), \"unknown type\");\n+      return;\n+    }\n+\n+  for (auto &field : expr.fields)\n+    {\n+      identifierBuffer = NULL;\n+      tupleIndexBuffer = NULL;\n+\n+      auto before = typeBuffer.size ();\n+      field->accept_vis (*this);\n+      if (typeBuffer.size () <= before)\n+\t{\n+\t  rust_error_at (expr.get_locus_slow (),\n+\t\t\t \"unable to determine type for field\");\n+\t  return;\n+\t}\n+\n+      auto inferedType = typeBuffer.back ();\n+      typeBuffer.pop_back ();\n+\n+      // do we have a name for this\n+      if (identifierBuffer != NULL)\n+\t{\n+\t  AST::StructField *declField = NULL;\n+\t  for (auto &df : decl->fields)\n+\t    {\n+\t      if (identifierBuffer->compare (df.field_name) == 0)\n+\t\t{\n+\t\t  declField = &df;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  identifierBuffer = NULL;\n+\n+\t  if (declField == NULL)\n+\t    {\n+\t      rust_error_at (expr.get_locus_slow (), \"unknown field\");\n+\t      return;\n+\t    }\n+\n+\t  if (!typesAreCompatible (declField->field_type.get (), inferedType,\n+\t\t\t\t   expr.get_locus_slow ()))\n+\t    return;\n+\t}\n+      // do we have an index for this\n+      else if (tupleIndexBuffer != NULL)\n+\t{\n+\t  AST::StructField *declField = NULL;\n+\t  if (*tupleIndexBuffer < decl->fields.size ())\n+\t    {\n+\t      declField = &decl->fields[*tupleIndexBuffer];\n+\t    }\n+\t  tupleIndexBuffer = NULL;\n+\n+\t  if (declField == NULL)\n+\t    {\n+\t      rust_error_at (expr.get_locus_slow (), \"unknown field at index\");\n+\t      return;\n+\t    }\n+\n+\t  if (!typesAreCompatible (declField->field_type.get (), inferedType,\n+\t\t\t\t   expr.get_locus_slow ()))\n+\t    return;\n+\t}\n+      else\n+\t{\n+\t  rust_fatal_error (expr.get_locus_slow (), \"unknown field initialise\");\n+\t  return;\n+\t}\n+    }\n+\n+  // setup a path in type\n+  AST::PathIdentSegment seg (expr.get_struct_name ().as_string ());\n+  auto typePath = ::std::unique_ptr<AST::TypePathSegment> (\n+    new AST::TypePathSegment (::std::move (seg), false,\n+\t\t\t      expr.get_locus_slow ()));\n+  ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;\n+  segs.push_back (::std::move (typePath));\n+  auto bType\n+    = new AST::TypePath (::std::move (segs), expr.get_locus_slow (), false);\n+  typeBuffer.push_back (bType);\n+}\n+\n void\n TypeResolution::visit (AST::StructExprStructBase &expr)\n {}"}, {"sha": "6f74719c9b45179ef9d571fe7207ba4c5925892c", "filename": "gcc/rust/analysis/rust-type-resolution.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0507ad9ebff18c7c2baacb981434018dad2600/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0507ad9ebff18c7c2baacb981434018dad2600/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h?ref=8f0507ad9ebff18c7c2baacb981434018dad2600", "patch": "@@ -301,6 +301,8 @@ class TypeResolution : public Resolution\n   bool isTypeInScope (AST::Type *type, Location locus);\n \n   TypeScoping scope;\n+  std::string *identifierBuffer;\n+  int *tupleIndexBuffer;\n };\n \n } // namespace Analysis"}, {"sha": "91e176fa758c5667ad7e9100047e72829d6e50a3", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0507ad9ebff18c7c2baacb981434018dad2600/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0507ad9ebff18c7c2baacb981434018dad2600/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=8f0507ad9ebff18c7c2baacb981434018dad2600", "patch": "@@ -1671,13 +1671,11 @@ class StructExprStruct : public StructExpr\n // struct\n struct StructBase\n {\n-private:\n+public:\n   // Expr* base_struct;\n   ::std::unique_ptr<Expr> base_struct;\n \n   // TODO: should this store location data?\n-\n-public:\n   StructBase (::std::unique_ptr<Expr> base_struct_ptr)\n     : base_struct (::std::move (base_struct_ptr))\n   {}\n@@ -1749,11 +1747,11 @@ class StructExprField\n // Identifier-only variant of StructExprField AST node\n class StructExprFieldIdentifier : public StructExprField\n {\n+public:\n   Identifier field_name;\n \n   // TODO: should this store location data?\n \n-public:\n   StructExprFieldIdentifier (Identifier field_identifier)\n     : field_name (::std::move (field_identifier))\n   {}\n@@ -1776,6 +1774,7 @@ class StructExprFieldIdentifier : public StructExprField\n // abstract\n class StructExprFieldWithVal : public StructExprField\n {\n+public:\n   // Expr* value;\n   ::std::unique_ptr<Expr> value;\n \n@@ -1814,11 +1813,11 @@ class StructExprFieldWithVal : public StructExprField\n // Identifier and value variant of StructExprField AST node\n class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n {\n+public:\n   Identifier field_name;\n \n   // TODO: should this store location data?\n \n-public:\n   StructExprFieldIdentifierValue (Identifier field_identifier,\n \t\t\t\t  ::std::unique_ptr<Expr> field_value)\n     : StructExprFieldWithVal (::std::move (field_value)),\n@@ -1845,11 +1844,11 @@ class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n // Tuple index and value variant of StructExprField AST node\n class StructExprFieldIndexValue : public StructExprFieldWithVal\n {\n+public:\n   TupleIndex index;\n \n   // TODO: should this store location data?\n \n-public:\n   StructExprFieldIndexValue (TupleIndex tuple_index,\n \t\t\t     ::std::unique_ptr<Expr> field_value)\n     : StructExprFieldWithVal (::std::move (field_value)), index (tuple_index)\n@@ -1875,13 +1874,13 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n // AST node of a struct creator with fields\n class StructExprStructFields : public StructExprStruct\n {\n+public:\n   //::std::vector<StructExprField> fields;\n   ::std::vector< ::std::unique_ptr<StructExprField> > fields;\n \n   // bool has_struct_base;\n   StructBase struct_base;\n \n-public:\n   ::std::string as_string () const;\n \n   inline bool has_struct_base () const { return !struct_base.is_invalid (); }"}]}