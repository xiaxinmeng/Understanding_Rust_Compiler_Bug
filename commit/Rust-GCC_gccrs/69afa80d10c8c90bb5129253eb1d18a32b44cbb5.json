{"sha": "69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlhZmE4MGQxMGM4YzkwYmI1MTI5MjUzZWIxZDE4YTMyYjQ0Y2JiNQ==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-06-05T02:28:41Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-06-05T02:28:41Z"}, "message": "In include,\n\n\t* dyn-string.h: Move here from gcc/dyn-string.h.  Add new functions.\n\n\t* demangle.h (DMGL_GNU_NEW_ABI): New macro.\n\t(DMGL_STYLE_MASK): Or in DMGL_GNU_NEW_ABI.\n\t(current_demangling_style): Add gnu_new_abi_demangling.\n\t(GNU_NEW_ABI_DEMANGLING_STYLE_STRING): New macro.\n\t(GNU_NEW_ABI_DEMANGLING): Likewise.\n\t(cplus_demangle_new_abi): New declaration.\n\nIn libiberty,\n\n\t* Makefile.in (CFILES): Add cp-demangle.c and dyn-string.c.\n\t(REQUIRED_OFILES): Add cp-demangle.o and dyn-string.o.\n\t(cp-demangle.o): New dependency.\n\t(dyn-string.o): Likewise.\n\n\t* dyn-string.c: Move here from gcc/dyn-string.c.  Add new functions.\n\n\t* cplus-dem.c (libiberty_demanglers): Add initializer for new-ABI\n\tdemangler.\n\t(cplus_demangle): Call cplus_demangle_new_abi if in new-ABI\n\tdemangling mode.\n\t(gnu_new_abi_symbol_characters): New function.\n\t(main): Use gnu_new_abi_symbol_characters.  * cp-demangle.c: New\n\tfile.\n\t* cp-demangle.c: New file.\n\nFrom-SVN: r34397", "tree": {"sha": "78bcc08424b6a7e0df57d6cc138363c0ec3e70eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78bcc08424b6a7e0df57d6cc138363c0ec3e70eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/comments", "author": null, "committer": null, "parents": [{"sha": "0dc09a613b1a4ff4219da97ea6414d95ead56418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc09a613b1a4ff4219da97ea6414d95ead56418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc09a613b1a4ff4219da97ea6414d95ead56418"}], "stats": {"total": 3532, "additions": 3497, "deletions": 35}, "files": [{"sha": "c74f03e3204084de9b1dc2562cb154c145416925", "filename": "include/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "patch": "@@ -1,3 +1,14 @@\n+2000-06-04  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* dyn-string.h: Move here from gcc/dyn-string.h.  Add new functions.\n+\n+\t* demangle.h (DMGL_GNU_NEW_ABI): New macro.\n+\t(DMGL_STYLE_MASK): Or in DMGL_GNU_NEW_ABI. \n+\t(current_demangling_style): Add gnu_new_abi_demangling.\n+\t(GNU_NEW_ABI_DEMANGLING_STYLE_STRING): New macro.\n+\t(GNU_NEW_ABI_DEMANGLING): Likewise.\n+\t(cplus_demangle_new_abi): New declaration.\n+\t\n Tue May 30 16:53:34 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \n \t* floatformat.h (struct floatformat): Add field name."}, {"sha": "146c895d96bec834cf1d2717d2ab157f743c032c", "filename": "include/demangle.h", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "patch": "@@ -24,21 +24,23 @@\n \n /* Options passed to cplus_demangle (in 2nd parameter). */\n \n-#define DMGL_NO_OPTS\t0\t\t/* For readability... */\n-#define DMGL_PARAMS\t(1 << 0)\t/* Include function args */\n-#define DMGL_ANSI\t(1 << 1)\t/* Include const, volatile, etc */\n-#define DMGL_JAVA\t(1 << 2)\t/* Demangle as Java rather than C++. */\n-\n-#define DMGL_AUTO\t(1 << 8)\n-#define DMGL_GNU\t(1 << 9)\n-#define DMGL_LUCID\t(1 << 10)\n-#define DMGL_ARM\t(1 << 11)\n-#define DMGL_HP \t(1 << 12)       /* For the HP aCC compiler; same as ARM\n-                                           except for template arguments, etc. */\n-#define DMGL_EDG\t(1 << 13)\n+#define DMGL_NO_OPTS\t 0\t\t/* For readability... */\n+#define DMGL_PARAMS\t (1 << 0)\t/* Include function args */\n+#define DMGL_ANSI\t (1 << 1)\t/* Include const, volatile, etc */\n+#define DMGL_JAVA\t (1 << 2)\t/* Demangle as Java rather than C++. */\n+\n+#define DMGL_AUTO\t (1 << 8)\n+#define DMGL_GNU\t (1 << 9)\n+#define DMGL_LUCID\t (1 << 10)\n+#define DMGL_ARM\t (1 << 11)\n+#define DMGL_HP \t (1 << 12)       /* For the HP aCC compiler;\n+                                            same as ARM except for\n+                                            template arguments, etc. */\n+#define DMGL_EDG\t (1 << 13)\n+#define DMGL_GNU_NEW_ABI (1 << 14)\n \n /* If none of these are set, use 'current_demangling_style' as the default. */\n-#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG)\n+#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_NEW_ABI)\n \n /* Enumeration of possible demangling styles.\n \n@@ -56,17 +58,19 @@ extern enum demangling_styles\n   lucid_demangling = DMGL_LUCID,\n   arm_demangling = DMGL_ARM,\n   hp_demangling = DMGL_HP,\n-  edg_demangling = DMGL_EDG\n+  edg_demangling = DMGL_EDG,\n+  gnu_new_abi_demangling = DMGL_GNU_NEW_ABI,\n } current_demangling_style;\n \n /* Define string names for the various demangling styles. */\n \n-#define AUTO_DEMANGLING_STYLE_STRING\t\"auto\"\n-#define GNU_DEMANGLING_STYLE_STRING\t\"gnu\"\n-#define LUCID_DEMANGLING_STYLE_STRING\t\"lucid\"\n-#define ARM_DEMANGLING_STYLE_STRING\t\"arm\"\n-#define HP_DEMANGLING_STYLE_STRING\t\"hp\"\n-#define EDG_DEMANGLING_STYLE_STRING\t\"edg\"\n+#define AUTO_DEMANGLING_STYLE_STRING\t      \"auto\"\n+#define GNU_DEMANGLING_STYLE_STRING    \t      \"gnu\"\n+#define LUCID_DEMANGLING_STYLE_STRING\t      \"lucid\"\n+#define ARM_DEMANGLING_STYLE_STRING\t      \"arm\"\n+#define HP_DEMANGLING_STYLE_STRING\t      \"hp\"\n+#define EDG_DEMANGLING_STYLE_STRING\t      \"edg\"\n+#define GNU_NEW_ABI_DEMANGLING_STYLE_STRING   \"gnu-new-abi\"\n \n /* Some macros to test what demangling style is active. */\n \n@@ -77,6 +81,7 @@ extern enum demangling_styles\n #define ARM_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_ARM)\n #define HP_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_HP)\n #define EDG_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_EDG)\n+#define GNU_NEW_ABI_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU_NEW_ABI)\n \n /* Provide information about the available demangle styles. This code is\n    pulled from gdb into libiberty because it is useful to binutils also.  */\n@@ -107,4 +112,9 @@ cplus_demangle_set_style PARAMS ((enum demangling_styles style));\n \n extern enum demangling_styles \n cplus_demangle_name_to_style PARAMS ((const char *name));\n+\n+/* New-ABI demangling entry point, defined in cp-demangle.c.  */\n+extern char*\n+cplus_demangle_new_abi PARAMS ((const char* mangled));\n+\n #endif\t/* DEMANGLE_H */"}, {"sha": "30c0624baa26aa704de7b3b5a8e8bdab2ef24dd5", "filename": "include/dyn-string.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/include%2Fdyn-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/include%2Fdyn-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdyn-string.h?ref=69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "patch": "@@ -0,0 +1,64 @@\n+/* An abstract string datatype.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell (mark@markmitchell.com).\n+\n+This file is part of GNU CC.\n+   \n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+typedef struct dyn_string\n+{\n+  int allocated;\t/* The amount of space allocated for the string.  */\n+  int length;\t\t/* The actual length of the string.  */\n+  char *s;\t\t/* The string itself, NUL-terminated.  */\n+}* dyn_string_t;\n+\n+/* The length STR, in bytes, not including the terminating NUL.  */\n+#define dyn_string_length(STR)                                          \\\n+  ((STR)->length)\n+\n+/* The NTBS in which the contents of STR are stored.  */\n+#define dyn_string_buf(STR)                                             \\\n+  ((STR)->s)\n+\n+/* Compare DS1 to DS2 with strcmp.  */\n+#define dyn_string_compare(DS1, DS2)                                    \\\n+  (strcmp ((DS1)->s, (DS2)->s))\n+\n+\n+extern void dyn_string_init             PARAMS ((struct dyn_string *, int));\n+extern dyn_string_t dyn_string_new      PARAMS ((int));\n+extern void dyn_string_delete           PARAMS ((dyn_string_t));\n+extern char *dyn_string_release         PARAMS ((dyn_string_t));\n+extern dyn_string_t dyn_string_resize   PARAMS ((dyn_string_t, int));\n+extern void dyn_string_clear            PARAMS ((dyn_string_t));\n+extern void dyn_string_copy             PARAMS ((dyn_string_t, dyn_string_t));\n+extern void dyn_string_copy_cstr        PARAMS ((dyn_string_t, const char *));\n+extern void dyn_string_prepend          PARAMS ((dyn_string_t, dyn_string_t));\n+extern void dyn_string_prepend_cstr     PARAMS ((dyn_string_t, const char *));\n+extern void dyn_string_insert           PARAMS ((dyn_string_t, int,\n+\t\t\t\t\t\t dyn_string_t));\n+extern void dyn_string_insert_cstr      PARAMS ((dyn_string_t, int,\n+\t\t\t\t\t\t const char *));\n+extern dyn_string_t dyn_string_append   PARAMS ((dyn_string_t, dyn_string_t));\n+extern dyn_string_t dyn_string_append_cstr   \n+                                        PARAMS ((dyn_string_t, const char *));\n+extern dyn_string_t dyn_string_append_char\n+                                        PARAMS ((dyn_string_t, char));\n+extern void dyn_string_substring        PARAMS ((dyn_string_t, \n+\t\t\t\t\t\t dyn_string_t, int, int));\n+extern int dyn_string_eq                PARAMS ((dyn_string_t, dyn_string_t));"}, {"sha": "cbb7b4e691eecf7aa389a62725342679753ff36b", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "patch": "@@ -1,3 +1,21 @@\n+2000-06-04  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* Makefile.in (CFILES): Add cp-demangle.c and dyn-string.c.\n+\t(REQUIRED_OFILES): Add cp-demangle.o and dyn-string.o.\n+\t(cp-demangle.o): New dependency.\n+\t(dyn-string.o): Likewise.\n+\n+\t* dyn-string.c: Move here from gcc/dyn-string.c.  Add new functions.\n+\n+\t* cplus-dem.c (libiberty_demanglers): Add initializer for new-ABI\n+\tdemangler.\n+\t(cplus_demangle): Call cplus_demangle_new_abi if in new-ABI\n+\tdemangling mode.\n+\t(gnu_new_abi_symbol_characters): New function.\n+\t(main): Use gnu_new_abi_symbol_characters.  * cp-demangle.c: New\n+\tfile.\n+\t* cp-demangle.c: New file.\n+\t\n Tue May 30 16:45:25 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \n \t* floatformat.c: Add name to each floatformat field."}, {"sha": "a7890001af33568cd13ad3a625499afad79fd934", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "patch": "@@ -125,23 +125,25 @@ HFILES = alloca-conf.h\n # (alphabetical), and add them to REQUIRED_OFILES or funcs in\n # configure.in.\n CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n-\tbzero.c calloc.c choose-temp.c clock.c concat.c cplus-dem.c fdmatch.c \\\n-\tfnmatch.c getcwd.c getpwd.c getopt.c getopt1.c getpagesize.c\t      \\\n-\tgetruntime.c floatformat.c hashtab.c hex.c index.c insque.c memchr.c  \\\n-\tmemcmp.c memcpy.c memmove.c memset.c mkstemps.c objalloc.c obstack.c  \\\n-\tpartition.c pexecute.c putenv.c random.c rename.c rindex.c\t      \\\n-\tsetenv.c sigsetmask.c sort.c spaces.c splay-tree.c strcasecmp.c\t      \\\n-\tstrncasecmp.c strchr.c strdup.c strerror.c strncmp.c strrchr.c\t      \\\n-\tstrsignal.c strstr.c strtod.c strtol.c strtoul.c tmpnam.c\t      \\\n-\tvasprintf.c vfork.c vfprintf.c vprintf.c vsprintf.c waitpid.c\t      \\\n-\txatexit.c xexit.c xmalloc.c xmemdup.c xstrdup.c xstrerror.c\n+\tbzero.c calloc.c choose-temp.c clock.c concat.c cplus-dem.c\t      \\\n+        cp-demangle.c dyn-string.c fdmatch.c fnmatch.c getcwd.c\t\t      \\\n+\tgetpwd.c getopt.c getopt1.c getpagesize.c getruntime.c\t\t      \\\n+\tfloatformat.c hashtab.c hex.c index.c insque.c memchr.c memcmp.c      \\\n+\tmemcpy.c memmove.c memset.c mkstemps.c objalloc.c obstack.c\t      \\\n+\tpartition.c pexecute.c putenv.c random.c rename.c rindex.c setenv.c   \\\n+\tsigsetmask.c sort.c spaces.c splay-tree.c strcasecmp.c strncasecmp.c  \\\n+\tstrchr.c strdup.c strerror.c strncmp.c strrchr.c strsignal.c strstr.c \\\n+\tstrtod.c strtol.c strtoul.c tmpnam.c vasprintf.c vfork.c vfprintf.c   \\\n+\tvprintf.c vsprintf.c waitpid.c xatexit.c xexit.c xmalloc.c\t      \\\n+\txmemdup.c xstrdup.c xstrerror.c\n \n # These are always included in the library.\n-REQUIRED_OFILES = argv.o choose-temp.o concat.o cplus-dem.o \\\n-  fdmatch.o fnmatch.o getopt.o getopt1.o getpwd.o getruntime.o hashtab.o \\\n-  hex.o floatformat.o objalloc.o obstack.o partition.o pexecute.o sort.o \\\n-  spaces.o splay-tree.o strerror.o strsignal.o xatexit.o xexit.o xmalloc.o \\\n-  xmemdup.o xstrdup.o xstrerror.o\n+REQUIRED_OFILES = argv.o choose-temp.o concat.o cplus-dem.o cp-demangle.o \\\n+\tdyn-string.o fdmatch.o fnmatch.o getopt.o getopt1.o getpwd.o\t  \\\n+\tgetruntime.o hashtab.o hex.o floatformat.o objalloc.o obstack.o\t  \\\n+\tpartition.o pexecute.o sort.o spaces.o splay-tree.o strerror.o\t  \\\n+\tstrsignal.o xatexit.o xexit.o xmalloc.o xmemdup.o xstrdup.o\t  \\\n+\txstrerror.o\n \n $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS) $(ALLOCA)\n \trm -f $(TARGETLIB)\n@@ -261,6 +263,8 @@ choose-temp.o: config.h\n clock.o: config.h\n concat.o: $(INCDIR)/libiberty.h\n cplus-dem.o: config.h $(INCDIR)/demangle.h\n+cp-demangle.o: config.h $(INCDIR)/dyn-string.h\n+dyn-string.o: config.h $(INCDIR)/dyn-string.h\n fdmatch.o: $(INCDIR)/libiberty.h\n fnmatch.o: config.h $(INCDIR)/fnmatch.h\n getcwd.o: config.h"}, {"sha": "25f88db3e16f90ce856adce458dc1143e2ac4e3f", "filename": "libiberty/cp-demangle.c", "status": "added", "additions": 2997, "deletions": 0, "changes": 2997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "patch": "@@ -0,0 +1,2997 @@\n+/* Demangler for IA64 / g++ standard C++ ABI.\n+   Copyright (C) 2000 CodeSourcery LLC.\n+   Written by Alex Samuel <samuel@codesourcery.com>. \n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. \n+*/\n+\n+/* This file implements demangling of C++ names mangled according to\n+   the IA64 / g++ standard C++ ABI.  Use the cp_demangle function to\n+   demangle a mangled name, or compile with the preprocessor macro\n+   STANDALONE_DEMANGLER defined to create a demangling filter\n+   executable.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#include <ctype.h>\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#if defined(CP_DEMANGLE_DEBUG) || defined(STANDALONE_DEMANGLER)\n+#include <stdio.h>\n+#endif\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#include \"ansidecl.h\"\n+#include \"libiberty.h\"\n+#include \"dyn-string.h\"\n+\n+/* If CP_DEMANGLE_DEBUG is defined, a trace of the grammar evaluation,\n+   and other debugging output, will be generated. */\n+#ifdef CP_DEMANGLE_DEBUG\n+#define DEMANGLE_TRACE(PRODUCTION, DM) \\\n+  fprintf (stderr, \" -> %-24s at position %3d\\n\", \\\n+           (PRODUCTION), current_position (DM));\n+#else\n+#define DEMANGLE_TRACE(PRODUCTION, DM)\n+#endif\n+\n+/* If flag_verbose is zero, some simplifications will be made to the\n+   output to make it easier to read and supress details that are\n+   generally not of interest to the average C++ programmer.\n+   Otherwise, the demangled representation will attempt to convey as\n+   much information as the mangled form.  */\n+static int flag_verbose;\n+\n+/* If flag_strict is non-zero, demangle strictly according to the\n+   specification -- don't demangle special g++ manglings.  */\n+static int flag_strict;\n+\n+/* String_list_t is an extended form of dyn_string_t which provides a link\n+   field.  A string_list_t may safely be cast to and used as a\n+   dyn_string_t.  */\n+\n+struct string_list_def\n+{\n+  struct dyn_string string;\n+  struct string_list_def *next;\n+};\n+\n+typedef struct string_list_def *string_list_t;\n+\n+/* Data structure representing a potential substitution.  */\n+\n+struct substitution_def\n+{\n+  /* The demangled text of the substitution.  */\n+  dyn_string_t text;\n+\n+  /* The template parameter that this represents, indexed from zero.\n+     If this is not a template paramter number, the value is\n+     NOT_TEMPLATE_PARM.  */\n+  int template_parm_number;\n+\n+  /* Whether this substitution represents a template item.  */\n+  int template_p : 1;\n+};\n+\n+#define NOT_TEMPLATE_PARM (-1)\n+\n+/* Data structure representing a template argument list.  */\n+\n+struct template_arg_list_def\n+{\n+  /* The next (lower) template argument list in the stack of currently\n+     active template arguments.  */\n+  struct template_arg_list_def *next;\n+\n+  /* The first element in the list of template arguments in\n+     left-to-right order.  */\n+  string_list_t first_argument;\n+\n+  /* The last element in the arguments lists.  */\n+  string_list_t last_argument;\n+};\n+\n+typedef struct template_arg_list_def *template_arg_list_t;\n+\n+/* Data structure to maintain the state of the current demangling.  */\n+\n+struct demangling_def\n+{\n+  /* The full mangled name being mangled.  */\n+  char *name;\n+\n+  /* Pointer into name at the current position.  */\n+  char *next;\n+\n+  /* Stack for strings containing demangled result generated so far.\n+     Text is emitted to the topmost (first) string.  */\n+  string_list_t result;\n+\n+  /* The number of presently available substitutions.  */\n+  int num_substitutions;\n+\n+  /* The allocated size of the substitutions array.  */\n+  int substitutions_allocated;\n+\n+  /* An array of available substitutions.  The number of elements in\n+     the array is given by num_substitions, and the allocated array\n+     size in substitutions_size.  \n+\n+     The most recent substition is at the end, so\n+\n+       - `S_'  corresponds to substititutions[num_substitutions - 1] \n+       - `S0_' corresponds to substititutions[num_substitutions - 2]\n+\n+     etc. */\n+  struct substitution_def *substitutions;\n+\n+  /* The stack of template argument lists.  */\n+  template_arg_list_t template_arg_lists;\n+\n+  /* The most recently demangled source-name.  */\n+  dyn_string_t last_source_name;\n+};\n+\n+typedef struct demangling_def *demangling_t;\n+\n+/* This type is the standard return code from most functions.  Values\n+   other than STATUS_OK contain descriptive messages.  */\n+typedef const char *status_t;\n+\n+/* Special values that can be used as a status_t.  */\n+#define STATUS_OK             NULL\n+#define STATUS_ERROR          \"Error.\"\n+#define STATUS_UNIMPLEMENTED  \"Unimplemented.\"\n+#define STATUS_INTERNAL_ERROR \"Internal error.\"\n+\n+static void int_to_dyn_string \n+  PARAMS ((int, dyn_string_t));\n+static string_list_t string_list_new\n+  PARAMS ((int));\n+static void string_list_delete\n+  PARAMS ((string_list_t));\n+static void result_close_template_list \n+  PARAMS ((demangling_t));\n+static void result_push\n+  PARAMS ((demangling_t));\n+static string_list_t result_pop\n+  PARAMS ((demangling_t));\n+static int substitution_start\n+  PARAMS ((demangling_t));\n+static void substitution_add\n+  PARAMS ((demangling_t, int, int, int));\n+static dyn_string_t substitution_get\n+  PARAMS ((demangling_t, int, int *));\n+#ifdef CP_DEMANGLE_DEBUG\n+static void substitutions_print \n+  PARAMS ((demangling_t, FILE *));\n+#endif\n+static template_arg_list_t template_arg_list_new\n+  PARAMS ((void));\n+static void template_arg_list_delete\n+  PARAMS ((template_arg_list_t));\n+static void template_arg_list_add_arg \n+  PARAMS ((template_arg_list_t, string_list_t));\n+static string_list_t template_arg_list_get_arg\n+  PARAMS ((template_arg_list_t, int));\n+static void push_template_arg_list\n+  PARAMS ((demangling_t, template_arg_list_t));\n+static void pop_to_template_arg_list\n+  PARAMS ((demangling_t, template_arg_list_t));\n+#ifdef CP_DEMANGLE_DEBUG\n+static void template_arg_list_print\n+  PARAMS ((template_arg_list_t, FILE *));\n+#endif\n+static template_arg_list_t current_template_arg_list\n+  PARAMS ((demangling_t));\n+static demangling_t demangling_new\n+  PARAMS ((char *));\n+static void demangling_delete \n+  PARAMS ((demangling_t));\n+\n+/* The last character of DS.  Warning: DS is evaluated twice.  */\n+#define dyn_string_last_char(DS)                                        \\\n+  (dyn_string_buf (DS)[dyn_string_length (DS) - 1])\n+\n+/* Append a space character (` ') to DS if it does not already end\n+   with one.  */\n+#define dyn_string_append_space(DS)                                     \\\n+  do                                                                    \\\n+    {                                                                   \\\n+      if (dyn_string_length (DS) > 0                                    \\\n+          && dyn_string_last_char (DS) != ' ')                          \\\n+\tdyn_string_append_char ((DS), ' ');                             \\\n+    }                                                                   \\\n+  while (0)\n+\n+/* Returns the index of the current position in the mangled name.  */\n+#define current_position(DM)    ((DM)->next - (DM)->name)\n+\n+/* Returns the character at the current position of the mangled name.  */\n+#define peek_char(DM)           (*((DM)->next))\n+\n+/* Returns the character one past the current position of the mangled\n+   name.  */\n+#define peek_char_next(DM)                                              \\\n+  (peek_char (DM) == '\\0' ? '\\0' : (*((DM)->next + 1)))\n+\n+/* Returns the character at the current position, and advances the\n+   current position to the next character.  */\n+#define next_char(DM)           (*((DM)->next)++)\n+\n+/* Returns non-zero if the current position is the end of the mangled\n+   name, i.e. one past the last character.  */\n+#define end_of_name_p(DM)       (peek_char (DM) == '\\0')\n+\n+/* Advances the current position by one character.  */\n+#define advance_char(DM)        (++(DM)->next)\n+\n+/* Returns the string containing the current demangled result.  */\n+#define result_string(DM)       (&(DM)->result->string)\n+\n+/* Appends a dyn_string_t to the demangled result.  */\n+#define result_append_string(DM, STRING)                                \\\n+  dyn_string_append (&(DM)->result->string, (STRING))\n+\n+/* Appends NUL-terminated string CSTR to the demangled result.  */\n+#define result_append(DM, CSTR)                                         \\\n+  dyn_string_append_cstr (&(DM)->result->string, (CSTR))\n+\n+/* Appends character CHAR to the demangled result.  */\n+#define result_append_char(DM, CHAR)                                    \\\n+  dyn_string_append_char (&(DM)->result->string, (CHAR))\n+\n+/* The length of the current demangled result.  */\n+#define result_length(DM)                                               \\\n+  dyn_string_length (&(DM)->result->string)\n+\n+/* Appends a space to the demangled result if the last character is\n+   not a space.  */\n+#define result_append_space(DM)                                         \\\n+  dyn_string_append_space (&(DM)->result->string)\n+\n+/* Evaluate EXPR, which must produce a status_t.  If the status code\n+   indicates an error, return from the current function with that\n+   status code.  */\n+#define RETURN_IF_ERROR(EXPR)                                           \\\n+  do                                                                    \\\n+    {                                                                   \\\n+      status_t s = EXPR;                                                \\\n+      if (s != STATUS_OK)                                               \\\n+\treturn s;                                                       \\\n+    }                                                                   \\\n+  while (0)\n+\n+/* Appends a base 10 representation of VALUE to DS.  */\n+\n+static void \n+int_to_dyn_string (value, ds)\n+     int value;\n+     dyn_string_t ds;\n+{\n+  int i;\n+  int mask = 1;\n+\n+  /* Handle zero up front.  */\n+  if (value == 0)\n+    {\n+      dyn_string_append_char (ds, '0');\n+      return;\n+    }\n+\n+  /* For negative numbers, emit a minus sign.  */\n+  if (value < 0)\n+    {\n+      dyn_string_append_char (ds, '-');\n+      value = -value;\n+    }\n+  \n+  /* Find the power of 10 of the first digit.  */\n+  i = value;\n+  while (i > 9)\n+    {\n+      mask *= 10;\n+      i /= 10;\n+    }\n+\n+  /* Write the digits.  */\n+  while (mask > 0)\n+    {\n+      int digit = value / mask;\n+      dyn_string_append_char (ds, '0' + digit);\n+      value -= digit * mask;\n+      mask /= 10;\n+    }\n+}\n+\n+/* Creates a new string list node.  The contents of the string are\n+   empty, but the initial buffer allocation is LENGTH.  The string\n+   list node should be deleted with string_list_delete.  */\n+\n+static string_list_t \n+string_list_new (length)\n+     int length;\n+{\n+  string_list_t s = \n+    (string_list_t) xmalloc (sizeof (struct string_list_def));\n+  dyn_string_init ((dyn_string_t) s, length);\n+  return s;\n+}  \n+\n+/* Deletes the entire string list starting at NODE.  */\n+\n+static void\n+string_list_delete (node)\n+     string_list_t node;\n+{\n+  while (node != NULL)\n+    {\n+      string_list_t next = node->next;\n+      free (node);\n+      node = next;\n+    }\n+}\n+\n+/* Appends a greater-than character to the demangled result.  If the\n+   last character is a greater-than character, a space is inserted\n+   first, so that the two greater-than characters don't look like a\n+   right shift token.  */\n+\n+static void\n+result_close_template_list (dm)\n+     demangling_t dm;\n+{\n+  dyn_string_t s = &dm->result->string;\n+  if (dyn_string_last_char (s) == '>')\n+    dyn_string_append_char (s, ' ');\n+  dyn_string_append_char (s, '>');\n+}\n+\n+/* Allocates and pushes a new string onto the demangled results stack\n+   for DM.  Subsequent demangling with DM will emit to the new string.  */\n+\n+static void\n+result_push (dm)\n+     demangling_t dm;\n+{\n+  string_list_t new_string = string_list_new (0);\n+  new_string->next = (string_list_t) dm->result;\n+  dm->result = new_string;\n+}\n+\n+/* Removes and returns the topmost element on the demangled results\n+   stack for DM.  The caller assumes ownership for the returned\n+   string.  */\n+\n+static string_list_t\n+result_pop (dm)\n+     demangling_t dm;\n+{\n+  string_list_t top = dm->result;\n+  dm->result = top->next;\n+  return top;\n+}\n+\n+/* Returns the start position of a fragment of the demangled result\n+   that will be a substitution candidate.  Should be called at the\n+   start of productions that can add substitutions.  */\n+\n+static int\n+substitution_start (dm)\n+     demangling_t dm;\n+{\n+  return result_length (dm);\n+}\n+\n+/* Adds the suffix of the current demangled result of DM starting at\n+   START_POSITION as a potential substitution.  If TEMPLATE_P is\n+   non-zero, this potential substitution is a template-id.  \n+\n+   If TEMPLATE_PARM_NUMBER is not NOT_TEMPLATE_PARM, the substitution\n+   is for that particular <template-param>, and is distinct from other\n+   otherwise-identical types and other <template-param>s with\n+   different indices.  */\n+\n+static void\n+substitution_add (dm, start_position, template_p, template_parm_number)\n+     demangling_t dm;\n+     int start_position;\n+     int template_p;\n+     int template_parm_number;\n+{\n+  dyn_string_t result = result_string (dm);\n+  dyn_string_t substitution = dyn_string_new (0);\n+  int i;\n+\n+  dyn_string_substring (substitution, \n+\t\t\tresult, start_position, result_length (dm));\n+\n+  /* Check whether SUBSTITUTION already occurs.  */\n+  for (i = 0; i < dm->num_substitutions; ++i)\n+    if (dyn_string_eq (dm->substitutions[i].text, substitution)\n+\t&& dm->substitutions[i].template_parm_number == template_parm_number)\n+      /* Found SUBSTITUTION already present.  */\n+      {\n+\t/* Callers expect this function to take ownership of\n+\t   SUBSTITUTION, so delete it.  */\n+\tdyn_string_delete (substitution);\n+\treturn;\n+      }\n+\n+  /* If there's no room for the new entry, grow the array.  */\n+  if (dm->substitutions_allocated == dm->num_substitutions)\n+    {\n+      dm->substitutions_allocated *= 2;\n+      dm->substitutions = (struct substitution_def *) \n+\txrealloc (dm->substitutions,\n+\t\t  sizeof (struct substitution_def) \n+\t\t  * dm->substitutions_allocated);\n+    }\n+\n+  /* Add the substitution to the array.  */\n+  dm->substitutions[i].text = substitution;\n+  dm->substitutions[i].template_p = template_p;\n+  dm->substitutions[i].template_parm_number = template_parm_number;\n+  ++dm->num_substitutions;\n+\n+#ifdef CP_DEMANGLE_DEBUG\n+  substitutions_print (dm, stderr);\n+#endif\n+}\n+\n+/* Returns the Nth-most-recent substitution.  Sets *TEMPLATE_P to\n+   non-zero if the substitution is a template-id, zero otherwise.  \n+   N is numbered from zero.  DM retains ownership of the returned\n+   string.  If N is negative, or equal to or greater than the current\n+   number of substitution candidates, returns NULL.  */\n+\n+static dyn_string_t\n+substitution_get (dm, n, template_p)\n+     demangling_t dm;\n+     int n;\n+     int *template_p;\n+{\n+  struct substitution_def *sub;\n+\n+  /* Make sure N is in the valid range.  */\n+  if (n < 0 || n >= dm->num_substitutions)\n+    return NULL;\n+\n+  sub = &(dm->substitutions[n]);\n+  *template_p = sub->template_p;\n+  return sub->text;\n+}\n+\n+#ifdef CP_DEMANGLE_DEBUG\n+/* Debugging routine to print the current substitutions to FP.  */\n+\n+static void\n+substitutions_print (dm, fp)\n+     demangling_t dm;\n+     FILE *fp;\n+{\n+  int seq_id;\n+  int num = dm->num_substitutions;\n+\n+  fprintf (fp, \"SUBSTITUTIONS:\\n\");\n+  for (seq_id = -1; seq_id < num - 1; ++seq_id)\n+    {\n+      int template_p;\n+      dyn_string_t text = substitution_get (dm, seq_id + 1, &template_p);\n+\n+      if (seq_id == -1)\n+\tfprintf (fp, \" S_ \");\n+      else\n+\tfprintf (fp, \" S%d_\", seq_id);\n+      fprintf (fp, \" %c: %s\\n\", template_p ? '*' : ' ', dyn_string_buf (text));\n+    }\n+}\n+\n+#endif /* CP_DEMANGLE_DEBUG */\n+\n+/* Creates a new template argument list.  */\n+\n+static template_arg_list_t\n+template_arg_list_new (void)\n+{\n+  template_arg_list_t new_list \n+    = (template_arg_list_t) xmalloc (sizeof (struct template_arg_list_def));\n+  /* Initialize the new list to have no arguments.  */\n+  new_list->first_argument = NULL;\n+  new_list->last_argument = NULL;\n+  /* Return the new list.  */\n+  return new_list;\n+}\n+\n+/* Deletes a template argument list and the template arguments it\n+   contains.  */\n+\n+static void\n+template_arg_list_delete (list)\n+     template_arg_list_t list;\n+{\n+  /* If there are any arguments on LIST, delete them.  */\n+  if (list->first_argument != NULL)\n+    string_list_delete (list->first_argument);\n+  /* Delete LIST.  */\n+  free (list);\n+}\n+\n+/* Adds ARG to the template argument list ARG_LIST.  */\n+\n+static void \n+template_arg_list_add_arg (arg_list, arg)\n+     template_arg_list_t arg_list;\n+     string_list_t arg;\n+{\n+  if (arg_list->first_argument == NULL)\n+    /* If there were no arguments before, ARG is the first one.  */\n+    arg_list->first_argument = arg;\n+  else\n+    /* Make ARG the last argument on the list.  */\n+    arg_list->last_argument->next = arg;\n+  /* Make ARG the last on the list.  */\n+  arg_list->last_argument = arg;\n+  arg->next = NULL;\n+}\n+\n+/* Returns the template arugment at position INDEX in template\n+   argument list ARG_LIST.  */\n+\n+static string_list_t\n+template_arg_list_get_arg (arg_list, index)\n+     template_arg_list_t arg_list;\n+     int index;\n+{\n+  string_list_t arg = arg_list->first_argument;\n+  /* Scan down the list of arguments to find the one at position\n+     INDEX.  */\n+  while (index--)\n+    {\n+      arg = arg->next;\n+      if (arg == NULL)\n+\t/* Ran out of arguments before INDEX hit zero.  That's an\n+\t   error.  */\n+\treturn NULL;\n+    }\n+  /* Return the argument at position INDEX.  */\n+  return arg;\n+}\n+\n+/* Pushes ARG_LIST onto the top of the template argument list stack.  */\n+\n+static void\n+push_template_arg_list (dm, arg_list)\n+     demangling_t dm;\n+     template_arg_list_t arg_list;\n+{\n+  arg_list->next = dm->template_arg_lists;\n+  dm->template_arg_lists = arg_list;\n+#ifdef CP_DEMANGLE_DEBUG\n+  fprintf (stderr, \" ** pushing template arg list\\n\");\n+  template_arg_list_print (arg_list, stderr);\n+#endif \n+}\n+\n+/* Pops and deletes elements on the template argument list stack until\n+   arg_list is the topmost element.  If arg_list is NULL, all elements\n+   are popped and deleted.  */\n+\n+static void\n+pop_to_template_arg_list (dm, arg_list)\n+     demangling_t dm;\n+     template_arg_list_t arg_list;\n+{\n+  while (dm->template_arg_lists != arg_list)\n+    {\n+      template_arg_list_t top = dm->template_arg_lists;\n+      /* Disconnect the topmost element from the list.  */\n+      dm->template_arg_lists = top->next;\n+      /* Delete the popped element.  */\n+      template_arg_list_delete (top);\n+#ifdef CP_DEMANGLE_DEBUG\n+      fprintf (stderr, \" ** removing template arg list\\n\");\n+#endif\n+    }\n+}\n+\n+#ifdef CP_DEMANGLE_DEBUG\n+\n+/* Prints the contents of ARG_LIST to FP.  */\n+\n+static void\n+template_arg_list_print (arg_list, fp)\n+  template_arg_list_t arg_list;\n+  FILE *fp;\n+{\n+  string_list_t arg;\n+  int index = -1;\n+\n+  fprintf (fp, \"TEMPLATE ARGUMENT LIST:\\n\");\n+  for (arg = arg_list->first_argument; arg != NULL; arg = arg->next)\n+    {\n+      if (index == -1)\n+\tfprintf (fp, \" T_  : \");\n+      else\n+\tfprintf (fp, \" T%d_ : \", index);\n+      ++index;\n+      fprintf (fp, \"%s\\n\", dyn_string_buf ((dyn_string_t) arg));\n+    }\n+}\n+\n+#endif /* CP_DEMANGLE_DEBUG */\n+\n+/* Returns the topmost element on the stack of template argument\n+   lists.  If there is no list of template arguments, returns NULL.  */\n+\n+static template_arg_list_t\n+current_template_arg_list (dm)\n+     demangling_t dm;\n+{\n+  return dm->template_arg_lists;\n+}\n+\n+/* Allocates a demangling_t object for demangling mangled NAME.  A new\n+   result must be pushed before the returned object can be used.  */\n+\n+static demangling_t\n+demangling_new (name)\n+     char *name;\n+{\n+  demangling_t dm = (demangling_t) \n+    xmalloc (sizeof (struct demangling_def));\n+\n+  dm->name = name;\n+  dm->next = name;\n+  dm->result = NULL;\n+  dm->last_source_name = dyn_string_new (0);\n+  dm->num_substitutions = 0;\n+  dm->substitutions_allocated = 10;\n+  dm->substitutions = (struct substitution_def *) \n+    xmalloc (dm->substitutions_allocated * sizeof (struct substitution_def));\n+  dm->template_arg_lists = NULL;\n+\n+  return dm;\n+}\n+\n+/* Deallocates a demangling_t object and all memory associated with\n+   it.  */\n+\n+static void\n+demangling_delete (dm)\n+     demangling_t dm;\n+{\n+  int i;\n+  template_arg_list_t arg_list = dm->template_arg_lists;\n+\n+  /* Delete the stack of template argument lists.  */\n+  while (arg_list != NULL)\n+    {\n+      template_arg_list_t next = arg_list->next;\n+      template_arg_list_delete (arg_list);\n+      arg_list = next;\n+    }\n+  /* Delete the list of substitutions.  */\n+  for (i = dm->num_substitutions; --i >= 0; )\n+    dyn_string_delete (dm->substitutions[i].text);\n+  free (dm->substitutions);\n+  /* Delete the demangled result.  */\n+  string_list_delete (dm->result);\n+  /* Delete the stored identifier name.  */\n+  dyn_string_delete (dm->last_source_name);\n+  /* Delete the context object itself.  */\n+  free (dm);\n+}\n+\n+/* These functions demangle an alternative of the corresponding\n+   production in the mangling spec.  The first argument of each is a\n+   demangling context structure for the current demangling\n+   operation.  Most emit demangled text directly to the topmost result\n+   string on the result string stack in the demangling context\n+   structure.  */\n+\n+static status_t demangle_char\n+  PARAMS ((demangling_t, char));\n+static status_t demangle_mangled_name \n+  PARAMS ((demangling_t));\n+static status_t demangle_encoding\n+  PARAMS ((demangling_t));\n+static status_t demangle_name\n+  PARAMS ((demangling_t, int *));\n+static status_t demangle_nested_name\n+  PARAMS ((demangling_t, int *));\n+static status_t demangle_prefix\n+  PARAMS ((demangling_t, int *));\n+static status_t demangle_unqualified_name\n+  PARAMS ((demangling_t));\n+static status_t demangle_source_name\n+  PARAMS ((demangling_t));\n+static status_t demangle_number\n+  PARAMS ((demangling_t, int *, int, int));\n+static status_t demangle_number_literally\n+  PARAMS ((demangling_t, dyn_string_t, int, int));\n+static status_t demangle_identifier\n+  PARAMS ((demangling_t, int, dyn_string_t));\n+static status_t demangle_operator_name\n+  PARAMS ((demangling_t, int, int *));\n+static status_t demangle_special_name\n+  PARAMS ((demangling_t));\n+static status_t demangle_ctor_dtor_name\n+  PARAMS ((demangling_t));\n+static status_t demangle_type_ptr\n+  PARAMS ((demangling_t));\n+static status_t demangle_type\n+  PARAMS ((demangling_t));\n+static status_t demangle_CV_qualifiers\n+  PARAMS ((demangling_t, dyn_string_t));\n+static status_t demangle_builtin_type\n+  PARAMS ((demangling_t));\n+static status_t demangle_function_type\n+  PARAMS ((demangling_t, int));\n+static status_t demangle_bare_function_type\n+  PARAMS ((demangling_t, int));\n+static status_t demangle_class_enum_type\n+  PARAMS ((demangling_t, int *));\n+static status_t demangle_array_type\n+  PARAMS ((demangling_t));\n+static status_t demangle_template_param\n+  PARAMS ((demangling_t, int *));\n+static status_t demangle_template_args\n+  PARAMS ((demangling_t));\n+static status_t demangle_literal\n+  PARAMS ((demangling_t));\n+static status_t demangle_template_arg\n+  PARAMS ((demangling_t));\n+static status_t demangle_expression\n+  PARAMS ((demangling_t));;\n+static status_t demangle_scope_expression\n+  PARAMS ((demangling_t));\n+static status_t demangle_expr_primary\n+  PARAMS ((demangling_t));;\n+static status_t demangle_substitution\n+  PARAMS ((demangling_t, int *, int *));\n+static status_t demangle_local_name\n+  PARAMS ((demangling_t));\n+static status_t demangle_discriminator \n+  PARAMS ((demangling_t, int));\n+\n+/* When passed to demangle_bare_function_type, indicates that the\n+   function's return type is not encoded before its parameter types.  */\n+#define BFT_NO_RETURN_TYPE    -1\n+\n+/* Check that the next character is C.  If so, consume it.  If not,\n+   return an error.  */\n+\n+static status_t\n+demangle_char (dm, c)\n+     demangling_t dm;\n+     char c;\n+{\n+  static char *error_message = NULL;\n+\n+  if (peek_char (dm) == c)\n+    {\n+      advance_char (dm);\n+      return STATUS_OK;\n+    }\n+  else\n+    {\n+      if (error_message == NULL)\n+\terror_message = strdup (\"Expected ?\");\n+      error_message[9] = c;\n+      return error_message;\n+    }\n+}\n+\n+/* Demangles and emits a <mangled-name>.  \n+\n+    <mangled-name>      ::= _Z <encoding>  */\n+\n+static status_t\n+demangle_mangled_name (dm)\n+     demangling_t dm;\n+{\n+  DEMANGLE_TRACE (\"mangled-name\", dm);\n+  RETURN_IF_ERROR (demangle_char (dm, '_'));\n+  RETURN_IF_ERROR (demangle_char (dm, 'Z'));\n+  RETURN_IF_ERROR (demangle_encoding (dm));\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits an <encoding>.  \n+\n+    <encoding>\t\t::= <function name> <bare-function-type>\n+\t\t\t::= <data name>\n+\t\t\t::= <substitution>  */\n+\n+static status_t\n+demangle_encoding (dm)\n+     demangling_t dm;\n+{\n+  int template_p;\n+  int special_std_substitution;\n+  int start_position;\n+  int start = substitution_start (dm);\n+  template_arg_list_t old_arg_list = current_template_arg_list (dm);\n+  char peek = peek_char (dm);\n+\n+  DEMANGLE_TRACE (\"encoding\", dm);\n+  \n+  /* Remember where the name starts.  If it turns out to be a template\n+     function, we'll have to insert the return type here.  */\n+  start_position = result_length (dm);\n+\n+  if (peek == 'S')\n+    {\n+      RETURN_IF_ERROR (demangle_substitution (dm, &template_p,\n+\t\t\t\t\t      &special_std_substitution));\n+      if (special_std_substitution)\n+\t{\n+\t  /* This was the magic `std::' substitution.  */\n+\t  result_append (dm, \"::\");\n+\t  RETURN_IF_ERROR (demangle_encoding (dm));\n+\t}\n+    }\n+  else if (peek == 'G' || peek == 'T')\n+    RETURN_IF_ERROR (demangle_special_name (dm));\n+  else\n+    {\n+      /* Now demangle the name.  */\n+      RETURN_IF_ERROR (demangle_name (dm, &template_p));\n+\n+      /* If there's anything left, the name was a function name, with\n+\t maybe its return type, and its parameters types, following.  */\n+      if (!end_of_name_p (dm) \n+\t  && peek_char (dm) != 'E')\n+\t{\n+\t  if (template_p)\n+\t    /* Template functions have their return type encoded.  The\n+\t       return type should be inserted at start_position.  */\n+\t    RETURN_IF_ERROR \n+\t      (demangle_bare_function_type (dm, start_position));\n+\t  else\n+\t    /* Non-template functions don't have their return type\n+\t       encoded.  */\n+\t    RETURN_IF_ERROR \n+\t      (demangle_bare_function_type (dm, BFT_NO_RETURN_TYPE)); \n+\t}\n+\n+      substitution_add (dm, start, template_p, NOT_TEMPLATE_PARM);\n+    }\n+\n+  /* Pop off template argument lists that were built during the\n+     mangling of this name, to restore the old template context.  */\n+  pop_to_template_arg_list (dm, old_arg_list);\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <name>.\n+\n+    <name>              ::= <unscoped-name>\n+                        ::= <unscoped-template-name> <template-args>\n+\t\t\t::= <nested-name>\n+                        ::= <local-name>\n+\n+    <unscoped-name>     ::= <unqualified-name>\n+\t\t\t::= St <unqualified-name>   # ::std::\n+\n+    <unscoped-template-name>    \n+                        ::= <unscoped-name>\n+                        ::= <substitution>  */\n+\n+static status_t\n+demangle_name (dm, template_p)\n+     demangling_t dm;\n+     int *template_p;\n+{\n+  int special_std_substitution;\n+  int start = substitution_start (dm);\n+\n+  DEMANGLE_TRACE (\"name\", dm);\n+\n+  switch (peek_char (dm))\n+    {\n+    case 'N':\n+      /* This is a <nested-name>.  */\n+      RETURN_IF_ERROR (demangle_nested_name (dm, template_p));\n+      break;\n+\n+    case 'Z':\n+      RETURN_IF_ERROR (demangle_local_name (dm));\n+      break;\n+\n+    case 'S':\n+      /* The `St' substitution allows a name nested in std:: to appear\n+\t without being enclosed in a nested name.\n+\t   <name> ::= St <unqualified-name>     # ::std::  */\n+      if (peek_char_next (dm) == 't') \n+\t{\n+\t  (void) next_char (dm);\n+\t  (void) next_char (dm);\n+\t  result_append (dm, \"std::\");\n+\t  RETURN_IF_ERROR (demangle_unqualified_name (dm));\n+\t}\n+      else\n+\t{\n+\t  RETURN_IF_ERROR (demangle_substitution (dm, template_p,\n+\t\t\t\t\t\t  &special_std_substitution));\n+\t  if (special_std_substitution)\n+\t    {\n+\t      /* This was the magic `std::' substitution.  We can have\n+\t\t a <nested-name> or one of the unscoped names\n+\t\t following.  */\n+\t      result_append (dm, \"::\");\n+\t      RETURN_IF_ERROR (demangle_name (dm, template_p));\n+\t    }\n+\t}\n+      break;\n+\n+    default:\n+      /* This is an <unscoped-name> or <unscoped-template-name>.  */\n+      RETURN_IF_ERROR (demangle_unqualified_name (dm));\n+\n+      /* If the <unqualified-name> is followed by template args, this\n+\t is an <unscoped-template-name>.  */\n+      if (peek_char (dm) == 'I')\n+\t{\n+\t  /* Add a substitution for the unqualified template name.  */\n+\t  substitution_add (dm, start, 0, NOT_TEMPLATE_PARM);\n+\n+\t  RETURN_IF_ERROR (demangle_template_args (dm));\n+\t  *template_p = 1;\n+\t}\n+      else\n+\t*template_p = 0;\n+\n+      break;\n+    }\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <nested-name>. \n+\n+    <nested-name>       ::= N [<CV-qualifiers>] <prefix> <component> E  */\n+\n+static status_t\n+demangle_nested_name (dm, template_p)\n+     demangling_t dm;\n+     int *template_p;\n+{\n+  char peek;\n+\n+  DEMANGLE_TRACE (\"nested-name\", dm);\n+\n+  RETURN_IF_ERROR (demangle_char (dm, 'N'));\n+\n+  peek = peek_char (dm);\n+  if (peek == 'r' || peek == 'V' || peek == 'K')\n+    {\n+      /* Snarf up and emit CV qualifiers.  */\n+      dyn_string_t cv_qualifiers = dyn_string_new (24);\n+      demangle_CV_qualifiers (dm, cv_qualifiers);\n+      result_append_string (dm, cv_qualifiers);\n+      dyn_string_delete (cv_qualifiers);\n+      result_append_space (dm);\n+    }\n+  \n+  RETURN_IF_ERROR (demangle_prefix (dm, template_p));\n+  /* No need to demangle the final <component>; demangle_prefix will\n+     handle it.  */\n+  RETURN_IF_ERROR (demangle_char (dm, 'E'));\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <prefix>.\n+\n+    <prefix>            ::= <prefix> <component>\n+                        ::= <template-prefix> <template-args>\n+\t\t\t::= # empty\n+\t\t\t::= <substitution>\n+\n+    <template-prefix>   ::= <prefix>\n+                        ::= <substitution>\n+\n+    <component>         ::= <unqualified-name>\n+                        ::= <local-name>  */\n+\n+static status_t\n+demangle_prefix (dm, template_p)\n+     demangling_t dm;\n+     int *template_p;\n+{\n+  int start = substitution_start (dm);\n+  int nested = 0;\n+\n+  /* TEMPLATE_P is updated as we decend the nesting chain.  After\n+     <template-args>, it is set to non-zero; after everything else it\n+     is set to zero.  */\n+\n+  DEMANGLE_TRACE (\"prefix\", dm);\n+\n+  while (1)\n+    {\n+      char peek;\n+      int unused;\n+\n+      if (end_of_name_p (dm))\n+\treturn \"Unexpected end of name in <compound-name>.\";\n+\n+      peek = peek_char (dm);\n+      \n+      if (isdigit (peek)\n+\t  || (peek >= 'a' && peek <= 'z')\n+\t  || peek == 'C' || peek == 'D'\n+\t  || peek == 'S')\n+\t{\n+\t  /* We have another level of scope qualification.  */\n+\t  if (nested)\n+\t    result_append (dm, \"::\");\n+\t  else\n+\t    nested = 1;\n+\n+\t  if (peek == 'S')\n+\t    /* The substitution determines whether this is a\n+\t       template-id.   */\n+\t    RETURN_IF_ERROR (demangle_substitution (dm, template_p, \n+\t\t\t\t\t\t    &unused));\n+\t  else\n+\t    {\n+\t      RETURN_IF_ERROR (demangle_unqualified_name (dm));\n+\t      *template_p = 0;\n+\t    }\n+\t}\n+      else if (peek == 'Z')\n+\tRETURN_IF_ERROR (demangle_local_name (dm));\n+      else if (peek == 'I')\n+\t{\n+\t  if (*template_p)\n+\t    return STATUS_INTERNAL_ERROR;\n+\t  /* The template name is a substitution candidate.  */\n+\t  substitution_add (dm, start, 0, NOT_TEMPLATE_PARM);\n+\t  RETURN_IF_ERROR (demangle_template_args (dm));\n+\t  *template_p = 1;\n+\t}\n+      else if (peek == 'E')\n+\t/* All done.  */\n+\treturn STATUS_OK;\n+      else\n+\treturn \"Unexpected character in <compound-name>.\";\n+\n+      /* Add a new substitution for the prefix thus far.  */\n+      substitution_add (dm, start, *template_p, NOT_TEMPLATE_PARM);\n+    }\n+}\n+\n+/* Demangles and emits an <unqualified-name>.  If the\n+   <unqualified-name> is a function and the first element in the\n+   argument list should be taken to be its return type,\n+   ENCODE_RETURN_TYPE is non-zero.\n+\n+    <unqualified-name>  ::= <operator-name>\n+\t\t\t::= <special-name>  \n+\t\t\t::= <source-name>  */\n+\n+static status_t\n+demangle_unqualified_name (dm)\n+     demangling_t dm;\n+{\n+  char peek = peek_char (dm);\n+\n+  DEMANGLE_TRACE (\"unqualified-name\", dm);\n+\n+  if (isdigit (peek))\n+    RETURN_IF_ERROR (demangle_source_name (dm));\n+  else if (peek >= 'a' && peek <= 'z')\n+    {\n+      int num_args;\n+      RETURN_IF_ERROR (demangle_operator_name (dm, 0, &num_args));\n+    }\n+  else if (peek == 'C' || peek == 'D')\n+    RETURN_IF_ERROR (demangle_ctor_dtor_name (dm));\n+  else\n+    return \"Unexpected character in <unqualified-name>.\";\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits <source-name>.  \n+\n+    <source-name> ::= <length number> <identifier>  */\n+\n+static status_t\n+demangle_source_name (dm)\n+     demangling_t dm;\n+{\n+  int length;\n+\n+  DEMANGLE_TRACE (\"source-name\", dm);\n+\n+  /* Decode the length of the identifier.  */\n+  RETURN_IF_ERROR (demangle_number (dm, &length, 10, 0));\n+  if (length == 0)\n+    return \"Zero length in <source-name>.\";\n+\n+  /* Now the identifier itself.  It's placed into last_source_name,\n+     where it can be used to build a constructor or destructor name.  */\n+  RETURN_IF_ERROR (demangle_identifier (dm, length, \n+\t\t\t\t\tdm->last_source_name));\n+\n+  /* Emit it.  */\n+  result_append_string (dm, dm->last_source_name);\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles a number, either a <number> or a <positive-number> at the\n+   current position, consuming all consecutive digit characters.  Sets\n+   *VALUE to the resulting numberand returns STATUS_OK.  The number is\n+   interpreted as BASE, which must be either 10 or 36.  If IS_SIGNED\n+   is non-zero, negative numbers -- prefixed with `n' -- are accepted.\n+\n+    <number> ::= [n] <positive-number>\n+\n+    <positive-number> ::= <decimal integer>  */\n+\n+static status_t\n+demangle_number (dm, value, base, is_signed)\n+     demangling_t dm;\n+     int *value;\n+     int base;\n+     int is_signed;\n+{\n+  dyn_string_t number = dyn_string_new (10);\n+\n+  DEMANGLE_TRACE (\"number\", dm);\n+\n+  demangle_number_literally (dm, number, base, is_signed);\n+  *value = strtol (dyn_string_buf (number), NULL, base);\n+  dyn_string_delete (number);\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles a number at the current position.  The digits (and minus\n+   sign, if present) that make up the number are appended to STR.\n+   Only base-BASE digits are accepted; BASE must be either 10 or 36.\n+   If IS_SIGNED, negative numbers -- prefixed with `n' -- are\n+   accepted.  Does not consume a trailing underscore or other\n+   terminating character.  */\n+\n+static status_t\n+demangle_number_literally (dm, str, base, is_signed)\n+     demangling_t dm;\n+     dyn_string_t str;\n+     int base;\n+     int is_signed;\n+{\n+  DEMANGLE_TRACE (\"number*\", dm);\n+\n+  if (base != 10 && base != 36)\n+    return STATUS_INTERNAL_ERROR;\n+\n+  /* An `n' denotes a negative number.  */\n+  if (is_signed && peek_char (dm) == 'n')\n+    {\n+      /* Skip past the n.  */\n+      advance_char (dm);\n+      /* The normal way to write a negative number is with a minus\n+\t sign.  */\n+      dyn_string_append_char (str, '-');\n+    }\n+\n+  /* Loop until we hit a non-digit.  */\n+  while (1)\n+    {\n+      char peek = peek_char (dm);\n+      if (isdigit (peek)\n+\t  || (base == 36 && peek >= 'A' && peek <= 'Z'))\n+\t/* Accumulate digits.  */\n+\tdyn_string_append_char (str, next_char (dm));\n+      else\n+\t/* Not a digit?  All done.  */\n+\tbreak;\n+    }\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles an identifier at the current position of LENGTH\n+   characters and places it in IDENTIFIER.  */\n+\n+static status_t\n+demangle_identifier (dm, length, identifier)\n+     demangling_t dm;\n+     int length;\n+     dyn_string_t identifier;\n+{\n+  DEMANGLE_TRACE (\"identifier\", dm);\n+\n+  dyn_string_clear (identifier);\n+  dyn_string_resize (identifier, length);\n+  while (length-- > 0)\n+    {\n+      if (end_of_name_p (dm))\n+\treturn \"Unexpected end of name in <identifier>.\";\n+      dyn_string_append_char (identifier, next_char (dm));\n+    }\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits an <operator-name>.  If SHORT_NAME is non-zero,\n+   the short form is emitted; otherwise the full source form\n+   (`operator +' etc.) is emitted.  *NUM_ARGS is set to the number of\n+   operands that the operator takes.  \n+\n+    <operator-name>\n+                  ::= nw        # new           \n+                  ::= na        # new[]\n+                  ::= dl        # delete        \n+                  ::= da        # delete[]      \n+\t\t  ::= ps        # + (unary)\n+                  ::= ng        # - (unary)     \n+                  ::= ad        # & (unary)     \n+                  ::= de        # * (unary)     \n+                  ::= co        # ~             \n+                  ::= pl        # +             \n+                  ::= mi        # -             \n+                  ::= ml        # *             \n+                  ::= dv        # /             \n+                  ::= rm        # %             \n+                  ::= an        # &             \n+                  ::= or        # |             \n+                  ::= eo        # ^             \n+                  ::= aS        # =             \n+                  ::= pL        # +=            \n+                  ::= mI        # -=            \n+                  ::= mL        # *=            \n+                  ::= dV        # /=            \n+                  ::= rM        # %=            \n+                  ::= aN        # &=            \n+                  ::= oR        # |=            \n+                  ::= eO        # ^=            \n+                  ::= ls        # <<            \n+                  ::= rs        # >>            \n+                  ::= lS        # <<=           \n+                  ::= rS        # >>=           \n+                  ::= eq        # ==            \n+                  ::= ne        # !=            \n+                  ::= lt        # <             \n+                  ::= gt        # >             \n+                  ::= le        # <=            \n+                  ::= ge        # >=            \n+                  ::= nt        # !             \n+                  ::= aa        # &&            \n+                  ::= oo        # ||            \n+                  ::= pp        # ++            \n+                  ::= mm        # --            \n+                  ::= cm        # ,             \n+                  ::= pm        # ->*           \n+                  ::= pt        # ->            \n+                  ::= cl        # ()            \n+                  ::= ix        # []            \n+                  ::= qu        # ?\n+                  ::= sz        # sizeof \n+                  ::= cv <type> # cast        \n+                  ::= vx <source-name>  # vendor extended operator  */\n+\n+static status_t\n+demangle_operator_name (dm, short_name, num_args)\n+     demangling_t dm;\n+     int short_name;\n+     int *num_args;\n+{\n+  struct operator_code\n+  {\n+    /* The mangled code for this operator.  */\n+    char *code;\n+    /* The source name of this operator.  */\n+    char *name;\n+    /* The number of arguments this operator takes.  */\n+    int num_args;\n+  };\n+\n+  struct operator_code operators[] = \n+  {\n+    { \"aN\", \"&=\"       , 2 },\n+    { \"aS\", \"=\"        , 2 },\n+    { \"aa\", \"&&\"       , 2 },\n+    { \"ad\", \"&\"        , 1 },\n+    { \"an\", \"&\"        , 2 },\n+    { \"cl\", \"()\"       , 0 },\n+    { \"cm\", \",\"        , 2 },\n+    { \"co\", \"~\"        , 1 },\n+    { \"dV\", \"/=\"       , 2 },\n+    { \"da\", \"delete[]\" , 1 },\n+    { \"de\", \"*\"        , 1 },\n+    { \"dl\", \"delete\"   , 1 },\n+    { \"dv\", \"/\"        , 2 },\n+    { \"eO\", \"^=\"       , 2 },\n+    { \"eo\", \"^\"        , 2 },\n+    { \"eq\", \"==\"       , 2 },\n+    { \"ge\", \">=\"       , 2 },\n+    { \"gt\", \">\"        , 2 },\n+    { \"ix\", \"[]\"       , 2 },\n+    { \"lS\", \"<<=\"      , 2 },\n+    { \"le\", \"<=\"       , 2 },\n+    { \"ls\", \"<<\"       , 2 },\n+    { \"lt\", \"<\"        , 2 },\n+    { \"mI\", \"-=\"       , 2 },\n+    { \"mL\", \"*=\"       , 2 },\n+    { \"mi\", \"-\"        , 2 },\n+    { \"ml\", \"*\"        , 2 },\n+    { \"mm\", \"--\"       , 1 },\n+    { \"na\", \"new[]\"    , 1 },\n+    { \"ne\", \"!=\"       , 2 },\n+    { \"ng\", \"-\"        , 1 },\n+    { \"nt\", \"!\"        , 1 },\n+    { \"nw\", \"new\"      , 1 },\n+    { \"oR\", \"|=\"       , 2 },\n+    { \"oo\", \"||\"       , 2 },\n+    { \"or\", \"|\"        , 2 },\n+    { \"pL\", \"+=\"       , 2 },\n+    { \"pl\", \"+\"        , 2 },\n+    { \"pm\", \"->*\"      , 2 },\n+    { \"pp\", \"++\"       , 1 },\n+    { \"ps\", \"+\"        , 1 },\n+    { \"qu\", \"?\"        , 3 },\n+    { \"rM\", \"%=\"       , 2 },\n+    { \"rS\", \">>=\"      , 2 },\n+    { \"rm\", \"%\"        , 2 },\n+    { \"rs\", \">>\"       , 2 },\n+    { \"sz\", \"sizeof\"   , 1 }\n+  };\n+\n+  const int num_operators = \n+    sizeof (operators) / sizeof (struct operator_code);\n+\n+  int c0 = next_char (dm);\n+  int c1 = next_char (dm);\n+  struct operator_code* p1 = operators;\n+  struct operator_code* p2 = operators + num_operators;\n+\n+  DEMANGLE_TRACE (\"operator-name\", dm);\n+\n+  /* Is this a vendor extended operator?  */\n+  if (c0 == 'v' && c1 == 'x')\n+    {\n+      result_append (dm, \"operator\");\n+      RETURN_IF_ERROR (demangle_source_name (dm));\n+      *num_args = 0;\n+      return STATUS_OK;\n+    }\n+\n+  /* Is this a conversion operator?  */\n+  if (c0 == 'c' && c1 == 'v')\n+    {\n+      result_append (dm, \"operator \");\n+      /* Demangle the converted-to type.  */\n+      RETURN_IF_ERROR (demangle_type (dm));\n+      *num_args = 0;\n+      return STATUS_OK;\n+    }\n+\n+  /* Perform a binary search for the operator code.  */\n+  while (1)\n+    {\n+      struct operator_code* p = p1 + (p2 - p1) / 2;\n+      char match0 = p->code[0];\n+      char match1 = p->code[1];\n+\n+      if (c0 == match0 && c1 == match1)\n+\t/* Found it.  */\n+\t{\n+\t  if (!short_name)\n+\t    result_append (dm, \"operator\");\n+\t  result_append (dm, p->name);\n+\t  *num_args = p->num_args;\n+\n+\t  return STATUS_OK;\n+\t}\n+\n+      if (p == p1)\n+\t/* Couldn't find it.  */\n+\treturn \"Unknown code in <operator-name>.\";\n+\n+      /* Try again.  */\n+      if (c0 < match0 || (c0 == match0 && c1 < match1))\n+\tp2 = p;\n+      else\n+\tp1 = p;\n+    }\n+}\n+\n+/* Demangles and emits a <special-name>.  \n+\n+    <special-name> ::= GV <object name>   # Guard variable\n+                   ::= Th[n] <offset number> _ <base name> <base encoding>\n+                                          # non-virtual base override thunk\n+                   ::= Tv[n] <offset number> _ <vcall offset number> \n+                         _ <base encoding>\n+                                          # virtual base override thunk\n+                   ::= TV <type>          # virtual table\n+                   ::= TT <type>          # VTT\n+                   ::= TI <type>          # typeinfo structure\n+\t\t   ::= TS <type>          # typeinfo name  \n+\n+   Also demangles the special g++ mangling,\n+\n+    <special-name> ::= CT <type> <offset number> _ <base type>\n+                                          # construction vtable  */\n+\n+static status_t\n+demangle_special_name (dm)\n+     demangling_t dm;\n+{\n+  dyn_string_t number;\n+  int unused;\n+  char peek = peek_char (dm);\n+\n+  DEMANGLE_TRACE (\"special-name\", dm);\n+\n+  if (peek == 'G')\n+    {\n+      /* A guard variable name.  Consume the G.  */\n+      advance_char (dm);\n+      RETURN_IF_ERROR (demangle_char (dm, 'V'));\n+      result_append (dm, \"guard variable for \");\n+      RETURN_IF_ERROR (demangle_name (dm, &unused));\n+    }\n+  else if (peek == 'T')\n+    {\n+      /* Other C++ implementation miscellania.  Consume the T.  */\n+      advance_char (dm);\n+\n+      switch (peek_char (dm))\n+\t{\n+\tcase 'V':\n+\t  /* Virtual table.  */\n+\t  advance_char (dm);\n+\t  result_append (dm, \"vtable for \");\n+\t  RETURN_IF_ERROR (demangle_type (dm));\n+\t  break;\n+\n+\tcase 'T':\n+\t  /* VTT structure.  */\n+\t  advance_char (dm);\n+\t  result_append (dm, \"VTT for \");\n+\t  RETURN_IF_ERROR (demangle_type (dm));\n+\t  break;\n+\n+\tcase 'I':\n+\t  /* Typeinfo structure.  */\n+\t  advance_char (dm);\n+\t  result_append (dm, \"typeinfo for \");\n+\t  RETURN_IF_ERROR (demangle_type (dm));\n+\t  break;\n+\n+\tcase 'S':\n+\t  /* Character string containing type name, used in typeinfo. */\n+\t  advance_char (dm);\n+\t  result_append (dm, \"typeinfo name for \");\n+\t  RETURN_IF_ERROR (demangle_type (dm));\n+\t  break;\n+\n+\tcase 'h':\n+\t  /* Non-virtual thunk.  */\n+\t  advance_char (dm);\n+\t  result_append (dm, \"non-virtual thunk\");\n+\t  /* Demangle and emit the offset.  */\n+\t  number = dyn_string_new (4);\n+\t  demangle_number_literally (dm, number, 10, 1);\n+\t  /* Don't display the offset unless in verbose mode.  */\n+\t  if (flag_verbose)\n+\t    {\n+\t      result_append_char (dm, ' ');\n+\t      result_append_string (dm, number);\n+\t    }\n+\t  dyn_string_delete (number);\n+\t  /* Demangle the separator.  */\n+\t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n+\t  /* Demangle and emit the target name and function type.  */\n+\t  result_append (dm, \" to \");\n+\t  RETURN_IF_ERROR (demangle_encoding (dm));\n+\t  break;\n+\n+\tcase 'v':\n+\t  /* Virtual thunk.  */\n+\t  advance_char (dm);\n+\t  result_append (dm, \"virtual thunk \");\n+\t  /* Demangle and emit the offset.  */\n+\t  number = dyn_string_new (4);\n+\t  demangle_number_literally (dm, number, 10, 1);\n+\t  /* Don't display the offset unless in verbose mode.  */\n+\t  if (flag_verbose)\n+\t    {\n+\t      result_append_string (dm, number);\n+\t      result_append_char (dm, ' ');\n+\t    }\n+\t  dyn_string_delete (number);\n+\t  /* Demangle the separator.  */\n+\t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n+\t  /* Demangle and emit the vcall offset.  */\n+\t  number = dyn_string_new (4);\n+\t  demangle_number_literally (dm, number, 10, 1);\n+\t  /* Don't display the vcall offset unless in verbose mode.  */\n+\t  if (flag_verbose)\n+\t    {\n+\t      result_append_string (dm, number);\n+\t      result_append_char (dm, ' ');\n+\t    }\n+\t  dyn_string_delete (number);\n+\t  /* Demangle the separator.  */\n+\t  RETURN_IF_ERROR (demangle_char (dm, '_'));\n+\t  /* Demangle and emit the target function.  */\n+\t  result_append (dm, \"to \");\n+\t  RETURN_IF_ERROR (demangle_encoding (dm));\n+\t  break;\n+\n+\tcase 'C':\n+\t  /* TC is a special g++ mangling for a construction vtable. */\n+\t  if (!flag_strict)\n+\t    {\n+\t      advance_char (dm);\n+\t      result_append (dm, \"construction vtable for \");\n+\t      RETURN_IF_ERROR (demangle_type (dm));\n+\t      /* Demangle the offset.  */\n+\t      number = dyn_string_new (4);\n+\t      demangle_number_literally (dm, number, 10, 1);\n+\t      /* Demangle the underscore separator.  */\n+\t      RETURN_IF_ERROR (demangle_char (dm, '_'));\n+\t      /* Demangle the base type.  */\n+\t      result_append (dm, \"-in-\");\n+\t      RETURN_IF_ERROR (demangle_type (dm));\n+\t      /* Don't display the offset unless in verbose mode.  */\n+\t      if (flag_verbose)\n+\t\t{\n+\t\t  result_append_char (dm, ' ');\n+\t\t  result_append_string (dm, number);\n+\t\t}\n+\t      dyn_string_delete (number);\n+\t      break;\n+\t    }\n+\t  /* If flag_strict, fall through.  */\n+\n+\tdefault:\n+\t  return \"Unrecognized <special-name>.\";\n+\t}\n+    }\n+  else\n+    return STATUS_ERROR;\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <ctor-dtor-name>.  \n+   \n+    <ctor-dtor-name>\n+                   ::= C1  # complete object (in-charge) ctor\n+                   ::= C2  # base object (not-in-charge) ctor\n+                   ::= C3  # complete object (in-charge) allocating ctor\n+                   ::= C4  # base object (not-in-charge) allocating ctor\n+                   ::= D0  # deleting (in-charge) dtor\n+                   ::= D1  # complete object (in-charge) dtor\n+                   ::= D2  # base object (not-in-charge) dtor  */\n+\n+static status_t\n+demangle_ctor_dtor_name (dm)\n+     demangling_t dm;\n+{\n+  static const char *const ctor_flavors[] = \n+  {\n+    \"in-charge\",\n+    \"not-in-charge\",\n+    \"in-charge allocating\",\n+    \"not-in-charge allocating\"\n+  };\n+  static const char *const dtor_flavors[] = \n+  {\n+    \"in-charge deleting\",\n+    \"in-charge\",\n+    \"not-in-charge\"\n+  };\n+\n+  int flavor;\n+  char peek = peek_char (dm);\n+\n+  DEMANGLE_TRACE (\"ctor-dtor-name\", dm);\n+  \n+  if (peek == 'C')\n+    {\n+      /* A constructor name.  Consume the C.  */\n+      advance_char (dm);\n+      if (peek_char (dm) < '1' || peek_char (dm) > '4')\n+\treturn \"Unrecognized constructor.\";\n+      result_append_string (dm, dm->last_source_name);\n+      /* Print the flavor of the constructor if in verbose mode.  */\n+      flavor = next_char (dm) - '1';\n+      if (flag_verbose)\n+\t{\n+\t  result_append (dm, \"[\");\n+\t  result_append (dm, ctor_flavors[flavor]);\n+\t  result_append_char (dm, ']');\n+\t}\n+    }\n+  else if (peek == 'D')\n+    {\n+      /* A destructor name.  Consume the D.  */\n+      advance_char (dm);\n+      if (peek_char (dm) < '0' || peek_char (dm) > '2')\n+\treturn \"Unrecognized destructor.\";\n+      result_append_char (dm, '~');\n+      result_append_string (dm, dm->last_source_name);\n+      /* Print the flavor of the destructor if in verbose mode.  */\n+      flavor = next_char (dm) - '0';\n+      if (flag_verbose)\n+\t{\n+\t  result_append (dm, \" [\");\n+\t  result_append (dm, dtor_flavors[flavor]);\n+\t  result_append_char (dm, ']');\n+\t}\n+    }\n+  else\n+    return STATUS_ERROR;\n+\n+  return STATUS_OK;\n+}\n+\n+/* Handle pointer, reference, and pointer-to-member cases for\n+   demangle_type.  All consecutive `P's, `R's, and 'M's are joined to\n+   build a pointer/reference type.  We snarf all these, plus the\n+   following <type>, all at once since we need to know whether we have\n+   a pointer to data or pointer to function to construct the right\n+   output syntax.  C++'s pointer syntax is hairy.  \n+\n+     <type> ::= P <type>\n+            ::= R <type>\n+            ::= <pointer-to-member-type>\n+\n+     <pointer-to-member-type> ::= M </class/ type> </member/ type>  */\n+\n+static status_t\n+demangle_type_ptr (dm)\n+     demangling_t dm;\n+{\n+  char next;\n+  status_t status;\n+\n+  /* Collect pointer symbols into this string.  */\n+  dyn_string_t symbols = dyn_string_new (10);\n+\n+  DEMANGLE_TRACE (\"type*\", dm);\n+\n+  /* Scan forward, collecting pointers and references into symbols,\n+     until we hit something else.  Then emit the type.  */\n+  while (1)\n+    {\n+      next = peek_char (dm);\n+      if (next == 'P')\n+\t{\n+\t  dyn_string_append_char (symbols, '*');\n+\t  advance_char (dm);\n+\t}\n+      else if (next == 'R')\n+\t{\n+\t  dyn_string_append_char (symbols, '&');\n+\t  advance_char (dm);\n+\t}\n+      else if (next == 'M')\n+\t{\n+\t  /* Pointer-to-member.  */\n+\t  dyn_string_t class_type;\n+\n+\t  /* Eat the 'M'.  */\n+\t  advance_char (dm);\n+\n+\t  /* Capture the type of which this is a pointer-to-member.  */\n+\t  result_push (dm);\n+\t  RETURN_IF_ERROR (demangle_type (dm));\n+\t  class_type = (dyn_string_t) result_pop (dm);\n+\n+\t  /* Build the pointer-to-member notation.  It comes before\n+\t     other pointer and reference qualifiers -- */\n+\t  dyn_string_prepend_cstr (symbols, \"::*\");\n+\t  dyn_string_prepend (symbols, class_type);\n+\t  dyn_string_delete (class_type);\n+\n+\t  if (peek_char (dm) == 'F')\n+\t    continue;\n+\n+\t  /* Demangle the type of the pointed-to member.  */\n+\t  status = demangle_type (dm);\n+\t  /* Make it pretty.  */\n+\t  result_append_space (dm);\n+\t  /* Add the pointer-to-member syntax, and other pointer and\n+\t     reference symbols.  */\n+\t  result_append_string (dm, symbols);\n+\t  /* Clean up.  */\n+\t  dyn_string_delete (symbols);\n+\n+\t  RETURN_IF_ERROR (status);\n+\t  return STATUS_OK;\n+\t}\n+      else if (next == 'F')\n+\t{\n+\t  /* Ooh, tricky, a pointer-to-function.  */\n+\t  int position = result_length (dm);\n+\t  result_append_char (dm, '(');\n+\t  result_append_string (dm, symbols);\n+\t  result_append_char (dm, ')');\n+\t  dyn_string_delete (symbols);\n+\n+\t  RETURN_IF_ERROR (demangle_function_type (dm, position));\n+\t  return STATUS_OK;\n+\t}\n+      else\n+\t{\n+\t  /* No more pointe or reference tokens.  Finish up.  */\n+\t  status = demangle_type (dm);\n+\n+\t  result_append_string (dm, symbols);\n+\t  dyn_string_delete (symbols);\n+\n+\t  RETURN_IF_ERROR (status);\n+\t  return STATUS_OK;\n+\t}\n+    }\n+}\n+\n+/* Demangles and emits a <type>.  \n+\n+    <type> ::= <builtin-type>\n+\t   ::= <function-type>\n+\t   ::= <class-enum-type>\n+\t   ::= <array-type>\n+\t   ::= <pointer-to-member-type>\n+\t   ::= <template-param>\n+           ::= <CV-qualifiers> <type>\n+\t   ::= P <type>   # pointer-to\n+\t   ::= R <type>   # reference-to\n+\t   ::= C <type>   # complex pair (C 2000)\n+\t   ::= G <type>   # imaginary (C 2000)\n+\t   ::= U <source-name> <type>     # vendor extended type qualifier\n+\t   ::= <substitution>  */\n+\n+static status_t\n+demangle_type (dm)\n+     demangling_t dm;\n+{\n+  int start = substitution_start (dm);\n+  char peek = peek_char (dm);\n+  int template_p = 0;\n+  int special_std_substitution;\n+  int is_builtin_type = 0;\n+  template_arg_list_t old_arg_list = current_template_arg_list (dm);\n+  int template_parm = NOT_TEMPLATE_PARM;\n+\n+  DEMANGLE_TRACE (\"type\", dm);\n+\n+  /* A <class-enum-type> can start with a digit (a <source-name>), an\n+     N (a <nested-name>), or a Z (a <local-name>).  */\n+  if (isdigit (peek) || peek == 'N' || peek == 'Z')\n+    RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));\n+  else if (peek >= 'a' && peek <= 'z')\n+    {\n+      RETURN_IF_ERROR (demangle_builtin_type (dm));\n+      is_builtin_type = 1;\n+    }\n+  else\n+    switch (peek)\n+      {\n+      case 'r':\n+      case 'V':\n+      case 'K':\n+\t{\n+\t  status_t status;\n+\t  dyn_string_t cv_qualifiers = dyn_string_new (24);\n+\t  demangle_CV_qualifiers (dm, cv_qualifiers);\n+\n+\t  /* If the qualifiers apply to a pointer or reference, they\n+\t     need to come after the whole qualified type.  */\n+\t  if (peek_char (dm) == 'P' || peek_char (dm) == 'R')\n+\t    {\n+\t      status = demangle_type (dm);\n+\t      result_append_space (dm);\n+\t      result_append_string (dm, cv_qualifiers);\n+\t    }\n+\t  /* Otherwise, the qualifiers come first.  */\n+\t  else\n+\t    {\n+\t      result_append_string (dm, cv_qualifiers);\n+\t      result_append_space (dm);\n+\t      status = demangle_type (dm);\n+\t    }\n+\n+\t  dyn_string_delete (cv_qualifiers);\n+\t  RETURN_IF_ERROR (status);\n+\t}\n+\tbreak;\n+\n+      case 'F':\n+\treturn \"Non-pointer or -reference function type.\";\n+\n+      case 'A':\n+\tRETURN_IF_ERROR (demangle_array_type (dm));\n+\tbreak;\n+\n+      case 'T':\n+\tRETURN_IF_ERROR (demangle_template_param (dm, &template_parm));\n+\tbreak;\n+\n+      case 'S':\n+\tRETURN_IF_ERROR (demangle_substitution (dm, &template_p,\n+\t\t\t\t\t\t&special_std_substitution));\n+\tif (special_std_substitution)\n+\t  {\n+\t    /* This was the magic `std::' substitution.  What follows\n+\t       must be a class name in that namespace.  */\n+\t    result_append (dm, \"::\");\n+\t    RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));\n+\t  }\n+\tbreak;\n+\n+      case 'P':\n+      case 'R':\n+      case 'M':\n+\tRETURN_IF_ERROR (demangle_type_ptr (dm));\n+\tbreak;\n+\n+      case 'C':\n+\t/* A C99 complex type.  */\n+\tresult_append (dm, \"complex \");\n+\tadvance_char (dm);\n+\tRETURN_IF_ERROR (demangle_type (dm));\n+\tbreak;\n+\n+      case 'G':\n+\t/* A C99 imaginary type.  */\n+\tresult_append (dm, \"imaginary \");\n+\tadvance_char (dm);\n+\tRETURN_IF_ERROR (demangle_type (dm));\n+\tbreak;\n+\n+      case 'U':\n+\t/* Vendor extended type qualifier.  */\n+\tadvance_char (dm);\n+\tRETURN_IF_ERROR (demangle_source_name (dm));\n+\tresult_append_char (dm, ' ');\n+\tRETURN_IF_ERROR (demangle_type (dm));\n+\tbreak;\n+\n+      default:\n+\treturn \"Unexpected character in <type>.\";\n+      }\n+\n+  /* Unqualified builin types are not substitution candidates.  */\n+  if (!is_builtin_type)\n+    /* Add a new substitution for the type. If this type was a\n+       <template-param>, pass its index since from the point of\n+       substitutions, a <template-param> token is a substitution\n+       candidate distinct from the type that is substituted for it.  */\n+    substitution_add (dm, start, template_p, template_parm);\n+\n+  /* Pop off template argument lists added during mangling of this\n+     type.  */\n+  pop_to_template_arg_list (dm, old_arg_list);\n+\n+  return STATUS_OK;\n+}\n+\n+/* C++ source names of builtin types, indexed by the mangled code\n+   letter's position in the alphabet ('a' -> 0, 'b' -> 1, etc).  */\n+static const char *const builtin_type_names[26] = \n+{\n+  \"signed char\",              /* a */\n+  \"bool\",                     /* b */\n+  \"char\",                     /* c */\n+  \"double\",                   /* d */\n+  \"long double\",              /* e */\n+  \"float\",                    /* f */\n+  \"__float128\",               /* g */\n+  \"unsigned char\",            /* h */\n+  \"int\",                      /* i */\n+  \"unsigned\",                 /* j */\n+  NULL,                       /* k */\n+  \"long\",                     /* l */\n+  \"unsigned long\",            /* m */\n+  \"__int128\",                 /* n */\n+  \"unsigned __int128\",        /* o */\n+  NULL,                       /* p */\n+  NULL,                       /* q */\n+  NULL,                       /* r */\n+  \"short\",                    /* s */\n+  \"unsigned short\",           /* t */\n+  NULL,                       /* u */\n+  \"void\",                     /* v */\n+  \"wchar_t\",                  /* w */\n+  \"long long\",                /* x */\n+  \"unsigned long long\",       /* y */\n+  \"...\"                       /* z */\n+};\n+\n+/* Demangles and emits a <builtin-type>.  \n+\n+    <builtin-type> ::= v  # void\n+\t\t   ::= w  # wchar_t\n+\t\t   ::= b  # bool\n+\t\t   ::= c  # char\n+\t\t   ::= a  # signed char\n+\t\t   ::= h  # unsigned char\n+\t\t   ::= s  # short\n+\t\t   ::= t  # unsigned short\n+\t\t   ::= i  # int\n+\t\t   ::= j  # unsigned int\n+\t\t   ::= l  # long\n+\t\t   ::= m  # unsigned long\n+\t\t   ::= x  # long long, __int64\n+\t\t   ::= y  # unsigned long long, __int64\n+\t\t   ::= n  # __int128\n+\t\t   ::= o  # unsigned __int128\n+\t\t   ::= f  # float\n+\t\t   ::= d  # double\n+\t\t   ::= e  # long double, __float80\n+\t\t   ::= g  # __float128\n+\t\t   ::= z  # ellipsis\n+\t\t   ::= u <source-name>    # vendor extended type  */\n+\n+static status_t\n+demangle_builtin_type (dm)\n+     demangling_t dm;\n+{\n+\n+  char code = peek_char (dm);\n+\n+  DEMANGLE_TRACE (\"builtin-type\", dm);\n+\n+  if (code == 'u')\n+    {\n+      advance_char (dm);\n+      RETURN_IF_ERROR (demangle_source_name (dm));\n+      return STATUS_OK;\n+    }\n+  else if (code >= 'a' && code <= 'z')\n+    {\n+      const char *type_name = builtin_type_names[code - 'a'];\n+      if (type_name == NULL)\n+\treturn \"Unrecognized <builtin-type> code.\";\n+\n+      result_append (dm, type_name);\n+      advance_char (dm);\n+      return STATUS_OK;\n+    }\n+  else\n+    return \"Non-alphabetic <builtin-type> code.\";\n+}\n+\n+/* Demangles all consecutive CV-qualifiers (const, volatile, and\n+   restrict) at the current position.  The qualifiers are appended to\n+   QUALIFIERS.  Returns STATUS_OK.  */\n+\n+static status_t\n+demangle_CV_qualifiers (dm, qualifiers)\n+     demangling_t dm;\n+     dyn_string_t qualifiers;\n+{\n+  DEMANGLE_TRACE (\"CV-qualifiers\", dm);\n+\n+  while (1)\n+    {\n+      switch (peek_char (dm))\n+\t{\n+\tcase 'r':\n+\t  dyn_string_append_space (qualifiers);\n+\t  dyn_string_append_cstr (qualifiers, \"restrict\");\n+\t  break;\n+\n+\tcase 'V':\n+\t  dyn_string_append_space (qualifiers);\n+\t  dyn_string_append_cstr (qualifiers, \"volatile\");\n+\t  break;\n+\n+\tcase 'K':\n+\t  dyn_string_append_space (qualifiers);\n+\t  dyn_string_append_cstr (qualifiers, \"const\");\n+\t  break;\n+\n+\tdefault:\n+\t  return STATUS_OK;\n+\t}\n+\n+      advance_char (dm);\n+    }\n+}\n+\n+/* Demangles and emits a <function-type> FUNCTION_NAME_POS is the\n+   position in the result string of the start of the function\n+   identifier, at which the function's return type will be inserted.  \n+\n+    <function-type> ::= F [Y] <bare-function-type> E  */\n+\n+static status_t\n+demangle_function_type (dm, function_name_pos)\n+     demangling_t dm;\n+     int function_name_pos;\n+{\n+  DEMANGLE_TRACE (\"function-type\", dm);\n+  RETURN_IF_ERROR (demangle_char (dm, 'F'));  \n+  if (peek_char (dm) == 'Y')\n+    {\n+      /* Indicate this function has C linkage if in verbose mode.  */\n+      if (flag_verbose)\n+\tresult_append (dm, \" [extern \\\"C\\\"] \");\n+      advance_char (dm);\n+    }\n+  RETURN_IF_ERROR (demangle_bare_function_type (dm, function_name_pos));\n+  RETURN_IF_ERROR (demangle_char (dm, 'E'));\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <bare-function-type>.  RETURN_TYPE_POS is the\n+   position in the result string at which the function return type\n+   should be inserted.  If RETURN_TYPE_POS is BFT_NO_RETURN_TYPE, the\n+   function's return type is assumed not to be encoded.  \n+\n+    <bare-function-type> ::= <signature type>+  */\n+\n+static status_t\n+demangle_bare_function_type (dm, return_type_pos)\n+     demangling_t dm;\n+     int return_type_pos;\n+{\n+  /* Sequence is the index of the current function parameter, counting\n+     from zero.  The value -1 denotes the return type.  */\n+  int sequence = \n+    (return_type_pos == BFT_NO_RETURN_TYPE ? 0 : -1);\n+\n+  DEMANGLE_TRACE (\"bare-function-type\", dm);\n+\n+  result_append_char (dm, '(');\n+  while (!end_of_name_p (dm) && peek_char (dm) != 'E')\n+    {\n+      if (sequence == -1)\n+\t/* We're decoding the function's return type.  */\n+\t{\n+\t  dyn_string_t return_type;\n+\n+\t  /* Decode the return type off to the side.  */\n+\t  result_push (dm);\n+\t  RETURN_IF_ERROR (demangle_type (dm));\n+\t  return_type = (dyn_string_t) result_pop (dm);\n+\n+\t  /* Add a space to the end of the type.  */\n+\t  dyn_string_append_space (return_type);\n+\n+\t  /* Insert the return type where we've been asked to.  */\n+\t  dyn_string_insert (result_string (dm), return_type_pos, \n+\t\t\t return_type);\n+\t  dyn_string_delete (return_type);\n+\t}\n+      else \n+\t{\n+\t  /* Skip `void' parameter types.  One should only occur as\n+\t     the only type in a parameter list; in that case, we want\n+\t     to print `foo ()' instead of `foo (void)'.  */\n+\t  if (peek_char (dm) == 'v')\n+\t    {\n+\t      /* Consume the v.  */\n+\t      advance_char (dm);\n+\t      continue;\n+\t    }\n+\t  /* Separate parameter types by commas.  */\n+\t  if (sequence > 0)\n+\t    result_append (dm, \", \");\n+\t  /* Demangle the type.  */\n+\t  RETURN_IF_ERROR (demangle_type (dm));\n+\t}\n+\n+      ++sequence;\n+    }\n+  result_append_char (dm, ')');\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <class-enum-type>.  *TEMPLATE_P is set to\n+   non-zero if the type is a template-id, zero otherwise.  \n+\n+    <class-enum-type> ::= <name>  */\n+\n+static status_t\n+demangle_class_enum_type (dm, template_p)\n+     demangling_t dm;\n+     int *template_p;\n+{\n+  DEMANGLE_TRACE (\"class-enum-type\", dm);\n+\n+  RETURN_IF_ERROR (demangle_name (dm, template_p));\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits an <array-type>.  \n+\n+    <array-type> ::= A [<dimension number>] _ <element type>  */\n+\n+static status_t\n+demangle_array_type (dm)\n+     demangling_t dm;\n+{\n+  dyn_string_t array_size = dyn_string_new (10);\n+\n+  RETURN_IF_ERROR (demangle_char (dm, 'A'));\n+\n+  /* Demangle the array size into array_size.  */\n+  RETURN_IF_ERROR (demangle_number_literally (dm, array_size, 10, 0));\n+\n+  /* Demangle the base type of the array.  */\n+  RETURN_IF_ERROR (demangle_char (dm, '_'));\n+  RETURN_IF_ERROR (demangle_type (dm));\n+\n+  /* Emit the array dimension syntax.  */\n+  result_append_char (dm, '[');\n+  result_append_string (dm, array_size);\n+  result_append_char (dm, ']');\n+  dyn_string_delete (array_size);\n+  \n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <template-param>.  The zero-indexed position\n+   in the parameter list is placed in *TEMPLATE_PARM_NUMBER.  \n+\n+    <template-param> ::= T_       # first template parameter\n+                     ::= T <parameter-2 number> _  */\n+\n+static status_t\n+demangle_template_param (dm, template_parm_number)\n+     demangling_t dm;\n+     int *template_parm_number;\n+{\n+  int parm_number;\n+  template_arg_list_t current_arg_list = current_template_arg_list (dm);\n+  string_list_t arg;\n+\n+  DEMANGLE_TRACE (\"template-param\", dm);\n+\n+  /* Make sure there is a template argmust list in which to look up\n+     this parameter reference.  */\n+  if (current_arg_list == NULL)\n+    return \"Template parameter outside of template.\";\n+\n+  RETURN_IF_ERROR (demangle_char (dm, 'T'));\n+  if (peek_char (dm) == '_')\n+    parm_number = 0;\n+  else\n+    {\n+      RETURN_IF_ERROR (demangle_number (dm, &parm_number, 10, 0));\n+      ++parm_number;\n+    }\n+  RETURN_IF_ERROR (demangle_char (dm, '_'));\n+\n+  arg = template_arg_list_get_arg (current_arg_list, parm_number);\n+  if (arg == NULL)\n+    /* parm_number exceeded the number of arguments in the current\n+       template argument list.  */\n+    return \"Template parameter number out of bounds.\";\n+  result_append_string (dm, (dyn_string_t) arg);\n+\n+  if (peek_char (dm) == 'I')\n+    RETURN_IF_ERROR (demangle_template_args (dm));\n+\n+  *template_parm_number = parm_number;\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <template-args>.  \n+\n+    <template-args> ::= I <template-arg>+ E  */\n+\n+static status_t\n+demangle_template_args (dm)\n+     demangling_t dm;\n+{\n+  int first = 1;\n+  template_arg_list_t arg_list = template_arg_list_new ();\n+\n+  /* Preserve the most recently demangled source name.  */\n+  dyn_string_t old_last_source_name = dm->last_source_name;\n+  dm->last_source_name = dyn_string_new (0);\n+\n+  DEMANGLE_TRACE (\"template-args\", dm);\n+\n+  RETURN_IF_ERROR (demangle_char (dm, 'I'));\n+  result_append_char (dm, '<');\n+  do\n+    {\n+      string_list_t arg;\n+\n+      if (first)\n+\tfirst = 0;\n+      else\n+\tresult_append (dm, \", \");\n+\n+      /* Capture the template arg.  */\n+      result_push (dm);\n+      RETURN_IF_ERROR (demangle_template_arg (dm));\n+      arg = result_pop (dm);\n+\n+      /* Emit it in the demangled name.  */\n+      result_append_string (dm, (dyn_string_t) arg);\n+\n+      /* Save it for use in expanding <template-param>s.  */\n+      template_arg_list_add_arg (arg_list, arg);\n+    }\n+  while (peek_char (dm) != 'E');\n+  /* Append the '>'.  */\n+  result_close_template_list (dm);\n+\n+  /* Consume the 'E'.  */\n+  advance_char (dm);\n+\n+  /* Restore the most recent demangled source name.  */\n+  dyn_string_delete (dm->last_source_name);\n+  dm->last_source_name = old_last_source_name;\n+\n+  /* Push the list onto the top of the stack of template argument\n+     lists, so that arguments from it are used from now on when\n+     expanding <template-param>s.  */\n+  push_template_arg_list (dm, arg_list);\n+\n+  return STATUS_OK;\n+}\n+\n+/* This function, which does not correspond to a production in the\n+   mangling spec, handles the `literal' production for both\n+   <template-arg> and <expr-primary>.  It does not expect or consume\n+   the initial `L' or final `E'.  The demangling is given by:\n+\n+     <literal> ::= <type> </value/ number>\n+\n+   and the emitted output is `(type)number'.  */\n+\n+static status_t\n+demangle_literal (dm)\n+     demangling_t dm;\n+{\n+  dyn_string_t value = dyn_string_new (0);\n+  char peek = peek_char (dm);\n+\n+  DEMANGLE_TRACE (\"literal\", dm);\n+\n+  if (!flag_verbose && peek >= 'a' && peek <= 'z')\n+    {\n+      /* If not in verbose mode and this is a builtin type, see if we\n+\t can produce simpler numerical output.  In particular, for\n+\t integer types shorter than `long', just write the number\n+\t without type information; for bools, write `true' or `false'.\n+\t Other refinements could be made here too.  */\n+\n+      /* This constant string is used to map from <builtin-type> codes\n+\t (26 letters of the alphabet) to codes that determine how the \n+\t value will be displayed.  The codes are:\n+\t   b: display as bool\n+\t   i: display as int\n+           l: display as long\n+\t A space means the value will be represented using cast\n+\t notation. */\n+      static const char *const code_map = \"ibi    iii ll     ii  i  \";\n+\n+      char code = code_map[peek - 'a'];\n+      /* FIXME: Implement demangling of floats and doubles.  */\n+      if (code == 'u')\n+\treturn STATUS_UNIMPLEMENTED;\n+      if (code == 'b')\n+\t{\n+\t  /* It's a boolean.  */\n+\t  char value;\n+\n+\t  /* Consume the b.  */\n+\t  advance_char (dm);\n+\t  /* Look at the next character.  It should be 0 or 1,\n+\t     corresponding to false or true, respectively.  */\n+\t  value = peek_char (dm);\n+\t  if (value == '0')\n+\t    result_append (dm, \"false\");\n+\t  else if (value == '1')\n+\t    result_append (dm, \"true\");\n+\t  else\n+\t    return \"Unrecognized bool constant.\";\n+\t  /* Consume the 0 or 1.  */\n+\t  advance_char (dm);\n+\t  return STATUS_OK;\n+\t}\n+      else if (code == 'i' || code == 'l')\n+\t{\n+\t  /* It's an integer or long.  */\n+\n+\t  /* Consume the type character.  */\n+\t  advance_char (dm);\n+\t  /* Demangle the number and write it out.  */\n+\t  RETURN_IF_ERROR (demangle_number_literally (dm, value, 10, 1));\n+\t  result_append_string (dm, value);\n+\t  /* For long integers, append an l.  */\n+\t  if (code == 'l')\n+\t    result_append_char (dm, code);\n+\t  return STATUS_OK;\n+\t}\n+      /* ...else code == ' ', so fall through to represent this\n+\t literal's type explicitly using cast syntax.  */\n+    }\n+\n+  result_append_char (dm, '(');\n+  RETURN_IF_ERROR (demangle_type (dm));\n+  result_append_char (dm, ')');\n+\n+  RETURN_IF_ERROR (demangle_number_literally (dm, value, 10, 1));\n+  result_append_string (dm, value);\n+  dyn_string_delete (value);\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <template-arg>.  \n+\n+    <template-arg> ::= <type>                     # type\n+                   ::= L <type> <value number> E  # literal\n+                   ::= LZ <encoding> E            # external name\n+                   ::= X <expression> E           # expression  */\n+\n+static status_t\n+demangle_template_arg (dm)\n+     demangling_t dm;\n+{\n+  DEMANGLE_TRACE (\"template-arg\", dm);\n+\n+  switch (peek_char (dm))\n+    {\n+    case 'L':\n+      advance_char (dm);\n+\n+      if (peek_char (dm) == 'Z')\n+\t{\n+\t  /* External name.  */\n+\t  advance_char (dm);\n+\t  /* FIXME: Standard is contradictory here.  */\n+\t  RETURN_IF_ERROR (demangle_encoding (dm));\n+\t}\n+      else\n+\tRETURN_IF_ERROR (demangle_literal (dm));\n+      RETURN_IF_ERROR (demangle_char (dm, 'E'));\n+      break;\n+\n+    case 'X':\n+      /* Expression.  */\n+      advance_char (dm);\n+      RETURN_IF_ERROR (demangle_expression (dm));\n+      break;\n+\n+    default:\n+      RETURN_IF_ERROR (demangle_type (dm));\n+      break;\n+    }\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits an <expression>.\n+\n+    <expression> ::= <unary operator-name> <expression>\n+\t\t ::= <binary operator-name> <expression> <expression>\n+\t\t ::= <expr-primary>  \n+                 ::= <scope-expression>  */\n+\n+static status_t\n+demangle_expression (dm)\n+     demangling_t dm;\n+{\n+  char peek = peek_char (dm);\n+\n+  DEMANGLE_TRACE (\"expression\", dm);\n+\n+  if (peek == 'L' || peek == 'T')\n+    RETURN_IF_ERROR (demangle_expr_primary (dm));\n+  else if (peek == 's' && peek_char_next (dm) == 'r')\n+    RETURN_IF_ERROR (demangle_scope_expression (dm));\n+  else\n+    /* An operator expression.  */\n+    {\n+      int num_args;\n+      dyn_string_t operator_name;\n+\n+      /* We have an operator name.  Since we want to output binary\n+\t operations in infix notation, capture the operator name\n+\t first.  */\n+      result_push (dm);\n+      RETURN_IF_ERROR (demangle_operator_name (dm, 1, &num_args));\n+      operator_name = (dyn_string_t) result_pop (dm);\n+\n+      /* If it's binary, do an operand first.  */\n+      if (num_args > 1)\n+\t{\n+\t  result_append_char (dm, '(');\n+\t  RETURN_IF_ERROR (demangle_expression (dm));\n+\t  result_append_char (dm, ')');\n+\t}\n+\n+      /* Now emit the operator, followed by its second (if binary) or\n+\t only (if unary) operand.  */\n+      result_append_string (dm, operator_name);\n+      dyn_string_delete (operator_name);\n+      result_append_char (dm, '(');\n+      RETURN_IF_ERROR (demangle_expression (dm));\n+      result_append_char (dm, ')');\n+\n+      /* The ternary operator takes a third operand.  */\n+      if (num_args == 3)\n+\t{\n+\t  result_append (dm, \":(\");\n+\t  RETURN_IF_ERROR (demangle_expression (dm));\n+\t  result_append_char (dm, ')');\n+\t}\n+    }\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <scope-expression>.  \n+\n+    <scope-expression> ::= sr <qualifying type> <source-name>\n+                       ::= sr <qualifying type> <encoding>  */\n+\n+static status_t\n+demangle_scope_expression (dm)\n+     demangling_t dm;\n+{\n+  RETURN_IF_ERROR (demangle_char (dm, 's'));\n+  RETURN_IF_ERROR (demangle_char (dm, 'r'));\n+  RETURN_IF_ERROR (demangle_type (dm));\n+  result_append (dm, \"::\");\n+  RETURN_IF_ERROR (demangle_encoding (dm));\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits an <expr-primary>.  \n+\n+    <expr-primary> ::= <template-param>\n+\t\t   ::= L <type> <value number> E  # literal\n+\t\t   ::= L <mangled-name> E         # external name  */\n+\n+static status_t\n+demangle_expr_primary (dm)\n+     demangling_t dm;\n+{\n+  char peek = peek_char (dm);\n+  int unused;\n+\n+  DEMANGLE_TRACE (\"expr-primary\", dm);\n+\n+  if (peek == 'T')\n+    RETURN_IF_ERROR (demangle_template_param (dm, &unused));\n+  else if (peek == 'L')\n+    {\n+      /* Consume the `L'.  */\n+      advance_char (dm);\n+      peek = peek_char (dm);\n+\n+      if (peek == '_')\n+\tRETURN_IF_ERROR (demangle_mangled_name (dm));\n+      else\n+\tRETURN_IF_ERROR (demangle_literal (dm));\n+\n+      RETURN_IF_ERROR (demangle_char (dm, 'E'));\n+    }\n+  else\n+    return STATUS_ERROR;\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <substitution>.  Sets *TEMPLATE_P to non-zero\n+   if the substitution is the name of a template, zero otherwise.  If\n+   the substitution token is St, which corresponds to the `::std::'\n+   namespace and can appear in a non-nested name, sets\n+   *SPECIAL_STD_SUBSTITUTION to non-zero; zero otherwise.  \n+\n+     <substitution> ::= S <seq-id> _\n+                    ::= S_\n+\n+                    ::= St   # ::std::\n+                    ::= Sa   # ::std::allocator\n+                    ::= Sb   # ::std::basic_string\n+                    ::= Ss   # ::std::basic_string<char,\n+\t\t\t\t    \t\t   ::std::char_traits<char>,\n+\t\t\t\t\t\t   ::std::allocator<char> >\n+                    ::= Si   # ::std::basic_istream<char,  \n+                                                    std::char_traits<char> >\n+                    ::= So   # ::std::basic_ostream<char,  \n+                                                    std::char_traits<char> >\n+                    ::= Sd   # ::std::basic_iostream<char, \n+                                                     std::char_traits<char> >\n+*/\n+\n+static status_t\n+demangle_substitution (dm, template_p, special_std_substitution)\n+     demangling_t dm;\n+     int *template_p;\n+     int *special_std_substitution;\n+{\n+  int seq_id;\n+  int peek;\n+  dyn_string_t text;\n+\n+  DEMANGLE_TRACE (\"substitution\", dm);\n+\n+  RETURN_IF_ERROR (demangle_char (dm, 'S'));\n+  *special_std_substitution = 0;\n+\n+  /* Scan the substitution sequence index.  A missing number denotes\n+     the first index.  */\n+  peek = peek_char (dm);\n+  if (peek == '_')\n+    seq_id = -1;\n+  /* If the following character is 0-9 or a capital letter, interpret\n+     the sequence up to the next underscore as a base-36 substitution\n+     index.  */\n+  else if (isdigit (peek) \n+\t   || (peek >= 'A' && peek <= 'Z'))\n+    RETURN_IF_ERROR (demangle_number (dm, &seq_id, 36, 0));\n+  else \n+    {\n+      switch (peek)\n+\t{\n+\tcase 't':\n+\t  result_append (dm, \"std\");\n+\t  *special_std_substitution = 1;\n+\t  break;\n+\n+\tcase 'a':\n+\t  result_append (dm, \"std::allocator\");\n+\t  dyn_string_copy_cstr (dm->last_source_name, \"allocator\");\n+\t  break;\n+\n+\tcase 'b':\n+\t  result_append (dm, \"std::basic_string\");\n+\t  dyn_string_copy_cstr (dm->last_source_name, \"basic_string\");\n+\t  break;\n+\t  \n+\tcase 's':\n+\t  if (!flag_verbose)\n+\t    {\n+\t      result_append (dm, \"std::string\");\n+\t      dyn_string_copy_cstr (dm->last_source_name, \"string\");\n+\t    }\n+\t  else\n+\t    {\n+\t      result_append (dm, \"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\");\n+\t      dyn_string_copy_cstr (dm->last_source_name, \"basic_string\");\n+\t    }\n+\t  break;\n+\n+\tcase 'i':\n+\t  if (!flag_verbose)\n+\t    {\n+\t      result_append (dm, \"std::istream\");\n+\t      dyn_string_copy_cstr (dm->last_source_name, \"istream\");\n+\t    }\n+\t  else\n+\t    {\n+\t      result_append (dm, \"std::basic_istream<char, std::char_traints<char> >\");\n+\t      dyn_string_copy_cstr (dm->last_source_name, \"basic_istream\");\n+\t    }\n+\t  break;\n+\n+\tcase 'o':\n+\t  if (!flag_verbose)\n+\t    {\n+\t      result_append (dm, \"std::ostream\");\n+\t      dyn_string_copy_cstr (dm->last_source_name, \"ostream\");\n+\t    }\n+\t  else\n+\t    {\n+\t      result_append (dm, \"std::basic_ostream<char, std::char_traits<char> >\");\n+\t      dyn_string_copy_cstr (dm->last_source_name, \"basic_ostream\");\n+\t    }\n+\t  break;\n+\n+\tcase 'd':\n+\t  if (!flag_verbose) \n+\t    {\n+\t      result_append (dm, \"std::iostream\");\n+\t      dyn_string_copy_cstr (dm->last_source_name, \"iostream\");\n+\t    }\n+\t  else\n+\t    {\n+\t      result_append (dm, \"std::basic_iostream<char, std::char_traits<char> >\");\n+\t      dyn_string_copy_cstr (dm->last_source_name, \"basic_iostream\");\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  return \"Unrecognized <substitution>.\";\n+\t}\n+      \n+      advance_char (dm);\n+      return STATUS_OK;\n+    }\n+\n+  /* Look up the substitution text.  Since `S_' is the most recent\n+     substitution, `S0_' is the second-most-recent, etc., shift the\n+     numbering by one.  */\n+  text = substitution_get (dm, seq_id + 1, template_p);\n+  if (text == NULL)\n+    return \"Substitution number out of range.\";\n+\n+  /* Emit the substitution text.  */\n+  result_append_string (dm, text);\n+\n+  RETURN_IF_ERROR (demangle_char (dm, '_'));\n+  return STATUS_OK;\n+}\n+\n+/* Demangles and emits a <local-name>.  \n+\n+    <local-name> := Z <function encoding> E <entity name> [<discriminator>]\n+                 := Z <function encoding> E s [<discriminator>]  */\n+\n+static status_t\n+demangle_local_name (dm)\n+     demangling_t dm;\n+{\n+  DEMANGLE_TRACE (\"local-name\", dm);\n+\n+  RETURN_IF_ERROR (demangle_char (dm, 'Z'));\n+  RETURN_IF_ERROR (demangle_encoding (dm));\n+  RETURN_IF_ERROR (demangle_char (dm, 'E'));\n+  result_append (dm, \"'s \");\n+\n+  if (peek_char (dm) == 's')\n+    {\n+      /* Local character string literal.  */\n+      result_append (dm, \"string literal\");\n+      /* Consume the s.  */\n+      advance_char (dm);\n+      RETURN_IF_ERROR (demangle_discriminator (dm, 0));\n+    }\n+  else\n+    {\n+      int unused;\n+      result_append (dm, \"local \");\n+      /* Local name for some other entity.  Demangle its name.  */\n+      RETURN_IF_ERROR (demangle_name (dm, &unused));\n+      RETURN_IF_ERROR (demangle_discriminator (dm, 1));\n+     }\n+\n+   return STATUS_OK;\n+ }\n+\n+ /* Optimonally demangles and emits a <discriminator>.  If there is no\n+    <discriminator> at the current position in the mangled string, the\n+    descriminator is assumed to be zero.  Emit the discriminator number\n+    in parentheses, unless SUPPRESS_FIRST is non-zero and the\n+    discriminator is zero.  \n+\n+     <discriminator> ::= _ <number>  */\n+\n+static status_t\n+demangle_discriminator (dm, suppress_first)\n+     demangling_t dm;\n+     int suppress_first;\n+{\n+  /* Output for <discriminator>s to the demangled name is completely\n+     supressed if not in verbose mode.  */\n+\n+  if (peek_char (dm) == '_')\n+    {\n+      /* Consume the underscore.  */\n+      advance_char (dm);\n+      if (flag_verbose)\n+\tresult_append (dm, \" [#\");\n+      /* Check if there's a number following the underscore.  */\n+      if (isdigit (peek_char (dm)))\n+\t{\n+\t  int discriminator;\n+\t  /* Demangle the number.  */\n+\t  RETURN_IF_ERROR (demangle_number (dm, &discriminator, 10, 0));\n+\t  if (flag_verbose)\n+\t    /* Write the discriminator.  The mangled number is two\n+\t       less than the discriminator ordinal, counting from\n+\t       zero.  */\n+\t    int_to_dyn_string (discriminator + 2, \n+\t\t\t       (dyn_string_t) dm->result);\n+\t}\n+      else\n+\t{\n+\t  if (flag_verbose)\n+\t    /* A missing digit correspond to one.  */\n+\t    result_append_char (dm, '1');\n+\t}\n+      if (flag_verbose)\n+\tresult_append_char (dm, ']');\n+    }\n+  else if (!suppress_first)\n+    {\n+      if (flag_verbose)\n+\tresult_append (dm, \" [#0]\");\n+    }\n+\n+  return STATUS_OK;\n+}\n+\n+/* Demangle NAME into RESULT, which must be an initialized\n+   dyn_string_t.  On success, returns STATUS_OK.  On failure, returns\n+   an error message, and the contents of RESULT are unchanged.  */\n+\n+status_t\n+cp_demangle (name, result)\n+     char *name;\n+     dyn_string_t result;\n+{\n+  status_t status;\n+  int length = strlen (name);\n+\n+  if (length > 2 && name[0] == '_' && name[1] == 'Z')\n+    {\n+      demangling_t dm = demangling_new (name);\n+\n+      result_push (dm);\n+      status = demangle_mangled_name (dm);\n+\n+      if (status == STATUS_OK)\n+\t{\n+\t  dyn_string_t demangled = (dyn_string_t) result_pop (dm);\n+\t  dyn_string_copy (result, demangled);\n+\t  dyn_string_delete (demangled);\n+\t}\n+      \n+      demangling_delete (dm);\n+    }\n+  else\n+    {\n+      /* It's evidently not a mangled C++ name.  It could be the name\n+\t of something with C linkage, though, so just copy NAME into\n+\t RESULT.  */\n+      dyn_string_copy_cstr (result, name);\n+      status = STATUS_OK;\n+    }\n+\n+  return status;\n+}\n+\n+/* Variant entry point for integration with the existing cplus-dem\n+   demangler.  Attempts to demangle MANGLED.  If the demangling\n+   succeeds, returns a buffer, allocated with malloc, containing the\n+   demangled name.  The caller must deallocate the buffer using free.\n+   If the demangling failes, returns NULL.  */\n+\n+char *\n+cplus_demangle_new_abi (mangled)\n+     const char* mangled;\n+{\n+  /* Create a dyn_string to hold the demangled name.  */\n+  dyn_string_t demangled = dyn_string_new (0);\n+  /* Attempt the demangling.  */\n+  status_t status = cp_demangle ((char *) mangled, demangled);\n+  if (status == STATUS_OK)\n+    /* Demangling succeeded.  */\n+    {\n+      /* Grab the demangled result from the dyn_string.  It was\n+\t allocated with malloc, so we can return it directly.  */\n+      char *return_value = dyn_string_release (demangled);\n+      /* The dyn_string can go away.  */\n+      dyn_string_delete (demangled);\n+      /* Hand back the demangled name.  */\n+      return return_value;\n+    }\n+  else\n+    /* Demangling failed.  */\n+    {\n+      dyn_string_delete (demangled);\n+      return NULL;\n+    }\n+}\n+\n+#ifdef STANDALONE_DEMANGLER\n+\n+#include \"getopt.h\"\n+\n+static void print_usage\n+  PARAMS ((FILE* fp, int exit_value));\n+\n+/* Non-zero if CHAR is a character than can occur in a mangled name.  */\n+#define is_mangled_char(CHAR)  (isalnum (CHAR) || (CHAR) == '_')\n+\n+/* The name of this program, as invoked.  */\n+const char* program_name;\n+\n+/* Prints usage summary to FP and then exits with EXIT_VALUE.  */\n+\n+static void\n+print_usage (fp, exit_value)\n+     FILE* fp;\n+     int exit_value;\n+{\n+  fprintf (fp, \"Usage: %s [options] [names ...]\\n\", program_name);\n+  fprintf (fp, \"Options:\\n\", program_name);\n+  fprintf (fp, \"  -h,--help       Display this message.\\n\");\n+  fprintf (fp, \"  -s,--strict     Demangle standard names only.\\n\");\n+  fprintf (fp, \"  -v,--verbose    Produce verbose demanglings.\\n\");\n+  fprintf (fp, \"If names are provided, they are demangled.  Otherwise filters standard input.\\n\");\n+\n+  exit (exit_value);\n+}\n+\n+/* Option specification for getopt_long.  */\n+static struct option long_options[] = \n+{\n+  { \"help\",    no_argument, NULL, 'h' },\n+  { \"strict\",  no_argument, NULL, 's' },\n+  { \"verbose\", no_argument, NULL, 'v' },\n+  { NULL,      no_argument, NULL, 0   },\n+};\n+\n+/* Main entry for a demangling filter executable.  It will demangle\n+   its command line arguments, if any.  If none are provided, it will\n+   filter stdin to stdout, replacing any recognized mangled C++ names\n+   with their demangled equivalents.  */\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char *argv[];\n+{\n+  status_t status;\n+  int i;\n+  int opt_char;\n+\n+  /* Use the program name of this program, as invoked.  */\n+  program_name = argv[0];\n+\n+  /* Parse options.  */\n+  do \n+    {\n+      opt_char = getopt_long (argc, argv, \"hsv\", long_options, NULL);\n+      switch (opt_char)\n+\t{\n+\tcase '?':  /* Unrecognized option.  */\n+\t  print_usage (stderr, 1);\n+\t  break;\n+\n+\tcase 'h':\n+\t  print_usage (stdout, 0);\n+\t  break;\n+\n+\tcase 's':\n+\t  flag_strict = 1;\n+\t  break;\n+\n+\tcase 'v':\n+\t  flag_verbose = 1;\n+\t  break;\n+\t}\n+    }\n+  while (opt_char != -1);\n+\n+  if (optind == argc) \n+    /* No command line arguments were provided.  Filter stdin.  */\n+    {\n+      dyn_string_t mangled = dyn_string_new (3);\n+      dyn_string_t demangled = dyn_string_new (0);\n+      status_t status;\n+\n+      /* Read all of input.  */\n+      while (!feof (stdin))\n+\t{\n+\t  char c = getchar ();\n+\n+\t  /* The first character of a mangled name is an underscore.  */\n+\t  if (feof (stdin))\n+\t    break;\n+\t  if (c != '_')\n+\t    {\n+\t      /* It's not a mangled name.  Print the character and go\n+\t\t on.  */\n+\t      putchar (c);\n+\t      continue;\n+\t    }\n+\t  c = getchar ();\n+\t  \n+\t  /* The second character of a mangled name is a capital `Z'.  */\n+\t  if (feof (stdin))\n+\t    break;\n+\t  if (c != 'Z')\n+\t    {\n+\t      /* It's not a mangled name.  Print the previous\n+\t\t underscore, the `Z', and go on.  */\n+\t      putchar ('_');\n+\t      putchar (c);\n+\t      continue;\n+\t    }\n+\n+\t  /* Start keeping track of the candidate mangled name.  */\n+\t  dyn_string_append_char (mangled, '_');\n+\t  dyn_string_append_char (mangled, 'Z');\n+\n+\t  /* Pile characters into mangled until we hit one that can't\n+\t     occur in a mangled name.  */\n+\t  c = getchar ();\n+\t  while (!feof (stdin) && is_mangled_char (c))\n+\t    {\n+\t      dyn_string_append_char (mangled, c);\n+\t      if (feof (stdin))\n+\t\tbreak;\n+\t      c = getchar ();\n+\t    }\n+\n+\t  /* Attempt to demangle the name.  */\n+\t  status = cp_demangle (dyn_string_buf (mangled), demangled);\n+\n+\t  /* If the demangling succeeded, great!  Print out the\n+\t     demangled version.  */\n+\t  if (status == STATUS_OK)\n+\t    fputs (dyn_string_buf (demangled), stdout);\n+\t  /* Otherwise, it might not have been a mangled name.  Just\n+\t     print out the original text.  */\n+\t  else\n+\t    fputs (dyn_string_buf (mangled), stdout);\n+\n+\t  /* If we haven't hit EOF yet, we've read one character that\n+\t     can't occur in a mangled name, so print it out.  */\n+\t  if (!feof (stdin))\n+\t    putchar (c);\n+\n+\t  /* Clear the candidate mangled name, to start afresh next\n+\t     time we hit a `_Z'.  */\n+\t  dyn_string_clear (mangled);\n+\t}\n+\n+      dyn_string_delete (mangled);\n+      dyn_string_delete (demangled);\n+    }\n+  else\n+    /* Demangle command line arguments.  */\n+    {\n+      dyn_string_t result = dyn_string_new (0);\n+\n+      /* Loop over command line arguments.  */\n+      for (i = optind; i < argc; ++i)\n+\t{\n+\t  /* Attempt to demangle.  */\n+\t  status = cp_demangle (argv[i], result);\n+\n+\t  /* If it worked, print the demangled name.  */\n+\t  if (status == STATUS_OK)\n+\t    printf (\"%s\\n\", dyn_string_buf (result));\n+\t  /* If not, print the error message to stderr instead.  */\n+\t  else \n+\t    fprintf (stderr, \"%s\\n\", status);\n+\t}\n+      dyn_string_delete (result);\n+    }\n+\n+  return 0;\n+}\n+\n+#endif /* STANDALONE_DEMANGLER */"}, {"sha": "44d119681625e8833fa5a2af0c82178fcf9a8a58", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "patch": "@@ -290,6 +290,12 @@ struct demangler_engine libiberty_demanglers[] =\n       \"EDG style demangling\"\n   }\n   ,\n+  {\n+    GNU_NEW_ABI_DEMANGLING_STYLE_STRING,\n+    gnu_new_abi_demangling,\n+    \"GNU (g++) new-ABI-style demangling\"\n+  }\n+  ,\n   {\n     NULL, unknown_demangling, NULL\n   }\n@@ -876,6 +882,10 @@ cplus_demangle (mangled, options)\n   if ((work -> options & DMGL_STYLE_MASK) == 0)\n     work -> options |= (int) current_demangling_style & DMGL_STYLE_MASK;\n \n+  /* The new-ABI demangling is implemented elsewhere.  */\n+  if (GNU_NEW_ABI_DEMANGLING)\n+    return cplus_demangle_new_abi (mangled);\n+\n   ret = internal_cplus_demangle (work, mangled);\n   squangle_mop_up (work);\n   return (ret);\n@@ -4574,6 +4584,9 @@ standard_symbol_characters PARAMS ((void));\n static const char *\n hp_symbol_characters PARAMS ((void));\n \n+static const char *\n+gnu_new_abi_symbol_characters PARAMS ((void));\n+\n /* Return the string of non-alnum characters that may occur \n    as a valid symbol component, in the standard assembler symbol\n    syntax.  */\n@@ -4622,6 +4635,17 @@ hp_symbol_characters ()\n }\n \n \n+/* Return the string of non-alnum characters that may occur \n+   as a valid symbol component in the GNU standard C++ ABI mangling\n+   scheme.  */\n+\n+static const char *\n+gnu_new_abi_symbol_characters ()\n+{\n+  return \"_\";\n+}\n+\n+\n extern int main PARAMS ((int, char **));\n \n int\n@@ -4696,6 +4720,9 @@ main (argc, argv)\n \tcase hp_demangling:\n \t  valid_symbols = hp_symbol_characters ();\n \t  break;\n+\tcase gnu_new_abi_demangling:\n+\t  valid_symbols = gnu_new_abi_symbol_characters ();\n+\t  break;\n \tdefault:\n \t  /* Folks should explicitly indicate the appropriate alphabet for\n \t     each demangling.  Providing a default would allow the"}, {"sha": "f6fad61803155a3c4817691c82489b4eca0482fc", "filename": "libiberty/dyn-string.c", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2Fdyn-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69afa80d10c8c90bb5129253eb1d18a32b44cbb5/libiberty%2Fdyn-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fdyn-string.c?ref=69afa80d10c8c90bb5129253eb1d18a32b44cbb5", "patch": "@@ -0,0 +1,331 @@\n+/* An abstract string datatype.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell (mark@markmitchell.com).\n+\n+This file is part of GNU CC.\n+   \n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#include \"libiberty.h\"\n+#include \"dyn-string.h\"\n+\n+/* Performs in-place initialization of a dyn_string struct.  This\n+   function can be used with a dyn_string struct on the stack or\n+   embedded in another object.  The contents of of the string itself\n+   are still dynamically allocated.  The string initially is capable\n+   of holding at least SPACE characeters, including the terminating\n+   NUL.  If SPACE is 0, it will silently be increated to 1.  */\n+\n+void\n+dyn_string_init (ds_struct_ptr, space)\n+     struct dyn_string *ds_struct_ptr;\n+     int space;\n+{\n+  /* We need at least one byte in which to store the terminating NUL.  */\n+  if (space == 0)\n+    space = 1;\n+\n+  ds_struct_ptr->allocated = space;\n+  ds_struct_ptr->s = (char *) xmalloc (space);\n+  ds_struct_ptr->length = 0;\n+  ds_struct_ptr->s[0] = '\\0';\n+}    \n+\n+/* Create a new dynamic string capable of holding at least SPACE characters,\n+   including the terminating NUL.  If SPACE is 0, it will be silently\n+   increased to 1.  */\n+\n+dyn_string_t \n+dyn_string_new (space)\n+     int space;\n+{\n+  dyn_string_t result = (dyn_string_t) xmalloc (sizeof (struct dyn_string));\n+  dyn_string_init (result, space);\n+  return result;\n+}\n+\n+/* Free the memory used by DS.  */\n+\n+void \n+dyn_string_delete (ds)\n+     dyn_string_t ds;\n+{\n+  free (ds->s);\n+  free (ds);\n+}\n+\n+/* Returns the contents of DS in a buffer allocated with malloc.  It\n+   is the caller's responsibility to deallocate the buffer using free.\n+   DS is then set to the empty string.  */\n+\n+char*\n+dyn_string_release (ds)\n+     dyn_string_t ds;\n+{\n+  /* Store the old buffer.  */\n+  char* result = ds->s;\n+  /* The buffer is no longer owned by DS.  */\n+  ds->s = NULL;\n+  /* Reinitialize DS to the empty string.  */\n+  dyn_string_init (ds, 0);\n+  /* Return the old buffer.  */\n+  return result;\n+}\n+\n+/* Increase the capacity of DS so it can hold at least SPACE\n+   characters, plus the terminating NUL.  This function will not (at\n+   present) reduce the capacity of DS.  */\n+\n+dyn_string_t \n+dyn_string_resize (ds, space)\n+     dyn_string_t ds;\n+     int space;\n+{\n+  int new_allocated = ds->allocated;\n+\n+  /* Increase SPACE to hold the NUL termination.  */\n+  ++space;\n+\n+  while (space > new_allocated)\n+    new_allocated *= 2;\n+    \n+  if (new_allocated != ds->allocated)\n+    {\n+      /* We actually need more space.  */\n+      ds->allocated = new_allocated;\n+      ds->s = (char *) xrealloc (ds->s, ds->allocated);\n+    }\n+\n+  return ds;\n+}\n+\n+/* Sets the contents of DS to the empty string.  */\n+\n+void\n+dyn_string_clear (ds)\n+     dyn_string_t ds;\n+{\n+  /* A dyn_string always has room for at least the NUL terminator.  */\n+  ds->s[0] = '\\0';\n+  ds->length = 0;\n+}\n+\n+/* Makes the contents of DEST the same as the contents of SRC.  DEST\n+   and SRC must be distinct.  */\n+\n+void\n+dyn_string_copy (dest, src)\n+     dyn_string_t dest;\n+     dyn_string_t src;\n+{\n+  if (dest == src)\n+    abort ();\n+\n+  /* Make room in DEST.  */\n+  dyn_string_resize (dest, src->length);\n+  /* Copy DEST into SRC.  */\n+  strcpy (dest->s, src->s);\n+  /* Update the size of DEST.  */\n+  dest->length = src->length;\n+}\n+\n+/* Copies SRC, a NUL-terminated string, into DEST.  */\n+\n+void\n+dyn_string_copy_cstr (dest, src)\n+     dyn_string_t dest;\n+     const char *src;\n+{\n+  int length = strlen (src);\n+  /* Make room in DEST.  */\n+  dyn_string_resize (dest, length);\n+  /* Copy DEST into SRC.  */\n+  strcpy (dest->s, src);\n+  /* Update the size of DEST.  */\n+  dest->length = length;\n+}\n+\n+/* Inserts SRC at the beginning of DEST.  DEST is expanded as\n+   necessary.  SRC and DEST must be distinct.  */\n+\n+void \n+dyn_string_prepend (dest, src)\n+     dyn_string_t dest;\n+     dyn_string_t src;\n+{\n+  dyn_string_insert (dest, 0, src);\n+}\n+\n+/* Inserts SRC, a NUL-terminated string, at the beginning of DEST.\n+   DEST is expanded as necessary.  */\n+\n+void \n+dyn_string_prepend_cstr (dest, src)\n+     dyn_string_t dest;\n+     const char *src;\n+{\n+  dyn_string_insert_cstr (dest, 0, src);\n+}\n+\n+/* Inserts SRC into DEST starting at position POS.  DEST is expanded as\n+   necessary.  SRC and DEST must be distinct.  */\n+\n+void \n+dyn_string_insert (dest, pos, src)\n+     dyn_string_t dest;\n+     int pos;\n+     dyn_string_t src;\n+{\n+  int i;\n+\n+  if (src == dest)\n+    abort ();\n+\n+  dyn_string_resize (dest, dest->length + src->length);\n+  /* Make room for the insertion.  Be sure to copy the NUL.  */\n+  for (i = dest->length; i >= pos; --i)\n+    dest->s[i + src->length] = dest->s[i];\n+  /* Splice in the new stuff.  */\n+  strncpy (dest->s + pos, src->s, src->length);\n+  /* Compute the new length.  */\n+  dest->length += src->length;\n+}\n+\n+/* Inserts SRC, a NUL-terminated string, into DEST starting at\n+   position POS.  DEST is expanded as necessary.  */\n+\n+void \n+dyn_string_insert_cstr (dest, pos, src)\n+     dyn_string_t dest;\n+     int pos;\n+     const char *src;\n+{\n+  int i;\n+  int length = strlen (src);\n+\n+  dyn_string_resize (dest, dest->length + length);\n+  /* Make room for the insertion.  Be sure to copy the NUL.  */\n+  for (i = dest->length; i >= pos; --i)\n+    dest->s[i + length] = dest->s[i];\n+  /* Splice in the new stuff.  */\n+  strncpy (dest->s + pos, src, length);\n+  /* Compute the new length.  */\n+  dest->length += length;\n+}\n+\n+/* Append S to DS, resizing DS if necessary.  Returns DS.  */\n+\n+dyn_string_t\n+dyn_string_append (ds, s)\n+     dyn_string_t ds;\n+     dyn_string_t s;\n+{\n+  dyn_string_resize (ds, ds->length + s->length);\n+  strcpy (ds->s + ds->length, s->s);\n+  ds->length += s->length;\n+  return ds;\n+}\n+\n+/* Append the NUL-terminated string S to DS, resizing DS if necessary.\n+   Returns DS.  */\n+\n+dyn_string_t \n+dyn_string_append_cstr (ds, s)\n+     dyn_string_t ds;\n+     const char *s;\n+{\n+  int len = strlen (s);\n+\n+  /* The new length is the old length plus the size of our string, plus\n+     one for the null at the end.  */\n+  dyn_string_resize (ds, ds->length + len);\n+  strcpy (ds->s + ds->length, s);\n+  ds->length += len;\n+\n+  return ds;\n+}\n+\n+/* Appends C to the end of DS.  */\n+\n+dyn_string_t \n+dyn_string_append_char (ds, c)\n+     dyn_string_t ds;\n+     char c;\n+{\n+  /* Make room for the extra character.  */\n+  dyn_string_resize (ds, ds->length + 1);\n+  /* Append the character; it will overwrite the old NUL.  */\n+  ds->s[ds->length] = c;\n+  /* Add a new NUL at the end.  */\n+  ds->s[ds->length + 1] = '\\0';\n+  /* Update the length.  */\n+  ++(ds->length);\n+  return ds;\n+}\n+\n+/* Sets the contents of DEST to the substring of SRC starting at START\n+   and ending before END.  START must be less than or equal to END,\n+   and both must be between zero and the length of SRC, inclusive.  */\n+\n+void\n+dyn_string_substring (dest, src, start, end)\n+     dyn_string_t dest;\n+     dyn_string_t src;\n+     int start;\n+     int end;\n+{\n+  int i;\n+  int length = end - start;\n+\n+  if (start > end || start > src->length || end > src->length)\n+    abort ();\n+\n+  /* Make room for the substring.  */\n+  dyn_string_resize (dest, length);\n+  /* Copy the characters in the substring,  */\n+  for (i = length; --i >= 0; )\n+    dest->s[i] = src->s[start + i];\n+  /* NUL-terimate the result.  */\n+  dest->s[length] = '\\0';\n+  /* Record the length of the substring.  */\n+  dest->length = length;\n+}\n+\n+/* Returns non-zero if DS1 and DS2 have the same contents.  */\n+\n+int\n+dyn_string_eq (ds1, ds2)\n+     dyn_string_t ds1;\n+     dyn_string_t ds2;\n+{\n+  /* If DS1 and DS2 have different lengths, they must not be the same.  */\n+  if (ds1->length != ds2->length)\n+    return 0;\n+  else\n+    return !strcmp (ds1->s, ds2->s);\n+}"}]}