{"sha": "068e7338865ad5fea910a27f87c7007d8def8517", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY4ZTczMzg4NjVhZDVmZWE5MTBhMjdmODdjNzAwN2Q4ZGVmODUxNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2005-09-08T16:06:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-09-08T16:06:54Z"}, "message": "re PR fortran/19928 (Reference of constant derived type component causes failure)\n\n\tPR fortran/19928\n\t* trans-array.c (gfc_conv_array_ref): Call gfc_advance_se_ss_chain\n\tafter handling scalarized references.  Make \"indexse\" inherit from\n\t\"se\" when handling AR_ELEMENTs.\n\t(gfc_walk_variable_expr): Add GFC_SS_SCALAR entries for each\n\tsubstring or scalar reference that follows an array section.\n\t* trans-expr.c (gfc_conv_variable): When called from within a\n\tscalarization loop, start out with \"ref\" pointing to the scalarized\n\tpart of the reference.  Don't call gfc_advance_se_ss_chain here.\n\nFrom-SVN: r104035", "tree": {"sha": "11a35e0bc52376bedc27a635471ad8c8e20cb028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11a35e0bc52376bedc27a635471ad8c8e20cb028"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/068e7338865ad5fea910a27f87c7007d8def8517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068e7338865ad5fea910a27f87c7007d8def8517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/068e7338865ad5fea910a27f87c7007d8def8517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068e7338865ad5fea910a27f87c7007d8def8517/comments", "author": null, "committer": null, "parents": [{"sha": "dcc9eb26a3b11460bfd1fba9430505f274968b63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcc9eb26a3b11460bfd1fba9430505f274968b63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcc9eb26a3b11460bfd1fba9430505f274968b63"}], "stats": {"total": 96, "additions": 87, "deletions": 9}, "files": [{"sha": "e8e64addba83da222ed53010390db0913db753ba", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=068e7338865ad5fea910a27f87c7007d8def8517", "patch": "@@ -1,3 +1,15 @@\n+2005-09-08  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/19928\n+\t* trans-array.c (gfc_conv_array_ref): Call gfc_advance_se_ss_chain\n+\tafter handling scalarized references.  Make \"indexse\" inherit from\n+\t\"se\" when handling AR_ELEMENTs.\n+\t(gfc_walk_variable_expr): Add GFC_SS_SCALAR entries for each\n+\tsubstring or scalar reference that follows an array section.\n+\t* trans-expr.c (gfc_conv_variable): When called from within a\n+\tscalarization loop, start out with \"ref\" pointing to the scalarized\n+\tpart of the reference.  Don't call gfc_advance_se_ss_chain here.\n+\n 2005-09-07  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR fortran/23373"}, {"sha": "9012a0756a8fb566cc2cbd371e28bec346ef5853", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=068e7338865ad5fea910a27f87c7007d8def8517", "patch": "@@ -1660,6 +1660,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar)\n   if (ar->type != AR_ELEMENT)\n     {\n       gfc_conv_scalarized_array_ref (se, ar);\n+      gfc_advance_se_ss_chain (se);\n       return;\n     }\n \n@@ -1671,7 +1672,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar)\n   for (n = 0; n < ar->dimen; n++)\n     {\n       /* Calculate the index for this dimension.  */\n-      gfc_init_se (&indexse, NULL);\n+      gfc_init_se (&indexse, se);\n       gfc_conv_expr_type (&indexse, ar->start[n], gfc_array_index_type);\n       gfc_add_block_to_block (&se->pre, &indexse.pre);\n \n@@ -4082,17 +4083,42 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n   int n;\n \n   for (ref = expr->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)\n+      break;\n+\n+  for (; ref; ref = ref->next)\n     {\n-      /* We're only interested in array sections.  */\n+      if (ref->type == REF_SUBSTRING)\n+\t{\n+\t  newss = gfc_get_ss ();\n+\t  newss->type = GFC_SS_SCALAR;\n+\t  newss->expr = ref->u.ss.start;\n+\t  newss->next = ss;\n+\t  ss = newss;\n+\n+\t  newss = gfc_get_ss ();\n+\t  newss->type = GFC_SS_SCALAR;\n+\t  newss->expr = ref->u.ss.end;\n+\t  newss->next = ss;\n+\t  ss = newss;\n+\t}\n+\n+      /* We're only interested in array sections from now on.  */\n       if (ref->type != REF_ARRAY)\n \tcontinue;\n \n       ar = &ref->u.ar;\n       switch (ar->type)\n \t{\n \tcase AR_ELEMENT:\n-          /* TODO: Take elemental array references out of scalarization\n-             loop.  */\n+\t  for (n = 0; n < ar->dimen; n++)\n+\t    {\n+\t      newss = gfc_get_ss ();\n+\t      newss->type = GFC_SS_SCALAR;\n+\t      newss->expr = ar->start[n];\n+\t      newss->next = ss;\n+\t      ss = newss;\n+\t    }\n \t  break;\n \n \tcase AR_FULL:\n@@ -4115,7 +4141,8 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t      gcc_assert (ar->end[n] == NULL);\n \t      gcc_assert (ar->stride[n] == NULL);\n \t    }\n-\t  return newss;\n+\t  ss = newss;\n+\t  break;\n \n \tcase AR_SECTION:\n \t  newss = gfc_get_ss ();\n@@ -4182,7 +4209,7 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t    }\n \t  /* We should have at least one non-elemental dimension.  */\n \t  gcc_assert (newss->data.info.dimen > 0);\n-\t  return head;\n+\t  ss = newss;\n \t  break;\n \n \tdefault:"}, {"sha": "b20ed13fc862d151c4786ef0e7426818b726ee13", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=068e7338865ad5fea910a27f87c7007d8def8517", "patch": "@@ -305,7 +305,9 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       /* A scalarized term.  We already know the descriptor.  */\n       se->expr = se->ss->data.info.descriptor;\n       se->string_length = se->ss->string_length;\n-      ref = se->ss->data.info.ref;\n+      for (ref = se->ss->data.info.ref; ref; ref = ref->next)\n+\tif (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)\n+\t  break;\n     }\n   else\n     {\n@@ -444,8 +446,6 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       else \n \tse->expr = gfc_build_addr_expr (NULL, se->expr);\n     }\n-  if (se->ss != NULL)\n-    gfc_advance_se_ss_chain (se);\n }\n \n "}, {"sha": "f20a57650bf5ae719c6d461642c2f2d26029599e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=068e7338865ad5fea910a27f87c7007d8def8517", "patch": "@@ -1,3 +1,8 @@\n+2005-09-08  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/19928\n+\t* gfortran.dg/pr19928-1.f90, gfortran.dg/pr19928-2.f90: New tests.\n+\n 2005-09-08  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR obj-c++/16816"}, {"sha": "a8b04d8e5e4bc3176038a058fdc90297a5612435", "filename": "gcc/testsuite/gfortran.dg/pr19928-1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19928-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19928-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19928-1.f90?ref=068e7338865ad5fea910a27f87c7007d8def8517", "patch": "@@ -0,0 +1,11 @@\n+! PR 19928.  Check the use of constant substring indexes in a\n+! scalarization loop.\n+! { dg-do run }\n+program main\n+  implicit none\n+  character (len = 5), dimension (2) :: a\n+  character (len = 3), dimension (2) :: b\n+  a = (/ 'abcde', 'ghijk' /)\n+  b = a(:)(2:4)\n+  if (b(1) .ne. 'bcd' .or. b(2) .ne. 'hij') call abort\n+end program main"}, {"sha": "6bfdd0f30b27eff710c5475309276cf2fe3b887d", "filename": "gcc/testsuite/gfortran.dg/pr19928-2.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19928-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/068e7338865ad5fea910a27f87c7007d8def8517/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19928-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19928-2.f90?ref=068e7338865ad5fea910a27f87c7007d8def8517", "patch": "@@ -0,0 +1,23 @@\n+! Related to PR 19928.  Check that foo() is only called once per statement.\n+! { dg-do run }\n+program main\n+  implicit none\n+  type t\n+    integer, dimension (5) :: field\n+  end type t\n+  type (t), dimension (2) :: a\n+  integer :: calls, i, j\n+\n+  forall (i = 1:2, j = 1:5) a(i)%field(j) = i * 100 + j\n+  calls = 0\n+  if (sum (a%field(foo(calls))) .ne. 304) call abort\n+  if (calls .ne. 1) call abort\n+  if (sum (a(foo(calls))%field) .ne. 1015) call abort\n+  if (calls .ne. 2) call abort\n+contains\n+  function foo (calls)\n+    integer :: calls, foo\n+    calls = calls + 1\n+    foo = 2\n+  end function foo \n+end program main"}]}