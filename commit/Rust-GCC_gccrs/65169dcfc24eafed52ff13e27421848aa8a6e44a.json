{"sha": "65169dcfc24eafed52ff13e27421848aa8a6e44a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUxNjlkY2ZjMjRlYWZlZDUyZmYxM2UyNzQyMTg0OGFhOGE2ZTQ0YQ==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-01-29T01:41:22Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-01-29T01:41:22Z"}, "message": "[multiple changes]\n\n\nFri Jan  7 19:48:04 CET 2000  Jan Hubicka  <jh@suse.cz>\n\t* sbitmap.c (sbitmap_first_set_bit, sbitmap_last_set_bit): New\n\tfunction.\n\t* sbitmap.h (sbitmap_first_set_bit, sbitmap_last_set_bit): Declare.\n\t* basic_block.h (FLOW_LOOP_FIRST_BLOCK): New macro.\n\t(FLOW_LOOP_LAST_BLOCK): Likewise.\n\n2000-01-21  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n\n\t* basic-block.h (struct loop): New fields 'first' and 'last'.\n\t* flow.c (flow_loops_find): Compute loop->first and loop->last.\n\t(flow_loops_dump): Use loop->first to check for NOTE_INSN_LOOP_BEG\n\tand loop->last to check for NOTE_INSN_LOOP_END.\n\nFri Jan 28 10:57:58 2000  Jason Eckhardt  <jle@cygnus.com>\n\n\t* predict.c (estimate_probability): Use the new FIRST and LAST fields\n\tof the loop descriptor rather than HEADER and LATCH. Also added\n\tmissing break statements as well making some coding style modifications\n\tas suggested by Michael Hayes.\n\nFrom-SVN: r31679", "tree": {"sha": "b7e53416e72be71ecc8ff02e5544a3d4f9199174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7e53416e72be71ecc8ff02e5544a3d4f9199174"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65169dcfc24eafed52ff13e27421848aa8a6e44a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65169dcfc24eafed52ff13e27421848aa8a6e44a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65169dcfc24eafed52ff13e27421848aa8a6e44a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65169dcfc24eafed52ff13e27421848aa8a6e44a/comments", "author": null, "committer": null, "parents": [{"sha": "72af8e4e63da81d09ed612c5024c3aadfe1cd077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72af8e4e63da81d09ed612c5024c3aadfe1cd077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72af8e4e63da81d09ed612c5024c3aadfe1cd077"}], "stats": {"total": 114, "additions": 100, "deletions": 14}, "files": [{"sha": "fa19a6d3403b87ca18c63ecafe4d523550bfaf6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65169dcfc24eafed52ff13e27421848aa8a6e44a", "patch": "@@ -1,3 +1,24 @@\n+Fri Jan  7 19:48:04 CET 2000  Jan Hubicka  <jh@suse.cz>\n+\t* sbitmap.c (sbitmap_first_set_bit, sbitmap_last_set_bit): New\n+\tfunction.\n+\t* sbitmap.h (sbitmap_first_set_bit, sbitmap_last_set_bit): Declare.\n+\t* basic_block.h (FLOW_LOOP_FIRST_BLOCK): New macro.\n+\t(FLOW_LOOP_LAST_BLOCK): Likewise.\n+\n+2000-01-21  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* basic-block.h (struct loop): New fields 'first' and 'last'.\n+\t* flow.c (flow_loops_find): Compute loop->first and loop->last.\n+\t(flow_loops_dump): Use loop->first to check for NOTE_INSN_LOOP_BEG\n+\tand loop->last to check for NOTE_INSN_LOOP_END.\n+\n+Fri Jan 28 10:57:58 2000  Jason Eckhardt  <jle@cygnus.com>\n+\n+\t* predict.c (estimate_probability): Use the new FIRST and LAST fields\n+\tof the loop descriptor rather than HEADER and LATCH. Also added\n+\tmissing break statements as well making some coding style modifications\n+\tas suggested by Michael Hayes.\n+\n 2000-01-28  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (find_basic_blocks): Remove do_cleanup argument."}, {"sha": "57fb2a7f3eecdcdc65dbe008b0af7d21f695c770", "filename": "gcc/basic-block.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=65169dcfc24eafed52ff13e27421848aa8a6e44a", "patch": "@@ -239,6 +239,14 @@ struct loop\n   /* Basic block of loop pre-header or NULL if it does not exist.  */\n   basic_block pre_header;\n \n+  /* The first block in the loop.  This is not necessarily the same as\n+     the loop header.  */\n+  basic_block first;\n+\n+  /* The last block in the loop.  This is not necessarily the same as\n+     the loop latch.  */\n+  basic_block last;\n+\n   /* Bitmap of blocks contained within the loop.  */\n   sbitmap nodes;\n \n@@ -318,6 +326,8 @@ struct loop\n   int exit_count;\n };\n \n+#define FLOW_LOOP_FIRST_BLOCK(loop) sbitmap_first_set_bit ((loop).nodes)\n+#define FLOW_LOOP_LAST_BLOCK(loop) sbitmap_last_set_bit ((loop).nodes)\n \n /* Structure to hold CFG information about natural loops within a function.  */\n struct loops"}, {"sha": "73a967b3680dd4e1df53ec302d85d629ff1793a5", "filename": "gcc/flow.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=65169dcfc24eafed52ff13e27421848aa8a6e44a", "patch": "@@ -6465,16 +6465,16 @@ flow_loops_dump (loops, file, verbose)\n \t{\n \t  /* Print diagnostics to compare our concept of a loop with\n \t     what the loop notes say.  */\n-\t  if (GET_CODE (PREV_INSN (loop->header->head)) != NOTE\n-\t      || NOTE_LINE_NUMBER (PREV_INSN (loop->header->head))\n+\t  if (GET_CODE (PREV_INSN (loop->first->head)) != NOTE\n+\t      || NOTE_LINE_NUMBER (PREV_INSN (loop->first->head))\n \t      != NOTE_INSN_LOOP_BEG)\n \t    fprintf (file, \";; No NOTE_INSN_LOOP_BEG at %d\\n\", \n-\t\t     INSN_UID (PREV_INSN (loop->header->head)));\n-\t  if (GET_CODE (NEXT_INSN (loop->latch->end)) != NOTE\n-\t      || NOTE_LINE_NUMBER (NEXT_INSN (loop->latch->end))\n+\t\t     INSN_UID (PREV_INSN (loop->first->head)));\n+\t  if (GET_CODE (NEXT_INSN (loop->last->end)) != NOTE\n+\t      || NOTE_LINE_NUMBER (NEXT_INSN (loop->last->end))\n \t      != NOTE_INSN_LOOP_END)\n \t    fprintf (file, \";; No NOTE_INSN_LOOP_END at %d\\n\",\n-\t\t     INSN_UID (NEXT_INSN (loop->latch->end)));\n+\t\t     INSN_UID (NEXT_INSN (loop->last->end)));\n \t}\n     }\n \n@@ -6975,7 +6975,16 @@ flow_loops_find (loops)\n \t\t  loop->nodes = sbitmap_alloc (n_basic_blocks);\n \t\t  loop->num_nodes\n \t\t    = flow_loop_nodes_find (header, latch, loop->nodes);\n-\t\t  \n+\n+\t\t  /* Compute first and last blocks within the loop.\n+\t\t     These are often the same as the loop header and\n+\t\t     loop latch respectively, but this is not always\n+\t\t     the case.  */\n+\t\t  loop->first\n+\t\t    = BASIC_BLOCK (sbitmap_first_set_bit (loop->nodes));\n+\t\t  loop->last\n+\t\t    = BASIC_BLOCK (sbitmap_last_set_bit (loop->nodes));\t\n+\t  \n \t\t  /* Find edges which exit the loop.  Note that a node\n \t\t     may have several exit edges.  */\n \t\t  loop->num_exits"}, {"sha": "d8a588f6df02e4303c522eea498d0c1939515169", "filename": "gcc/predict.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=65169dcfc24eafed52ff13e27421848aa8a6e44a", "patch": "@@ -53,21 +53,22 @@\n    ??? In the next revision there will be a number of other predictors added\n    from the above references. Further, each heuristic will be factored out\n    into its own function for clarity (and to facilitate the combination of\n-   predictions). */\n+   predictions).  */\n \n void\n estimate_probability (loops_info)\n      struct loops *loops_info;\n {\n   int i;\n \n-  /* Try to predict out blocks in a loop that are not part of a natural loop */\n+  /* Try to predict out blocks in a loop that are not part of a\n+     natural loop.  */\n   for (i = 0; i < loops_info->num; i++)\n     {\n       int j;\n \n-      for (j = loops_info->array[i].header->index;\n-\t   j <= loops_info->array[i].latch->index;\n+      for (j = loops_info->array[i].first->index;\n+\t   j <= loops_info->array[i].last->index;\n \t   ++j)\n \t{\n \t  edge e;\n@@ -83,17 +84,18 @@ estimate_probability (loops_info)\n \t\t      || ! condjump_p (last_insn) || simplejump_p (last_insn))\n \t\t    continue;\n \t\t  cond = get_condition (last_insn, &earliest);\n-\t\t  if (!cond)\n+\t\t  if (! cond)\n \t\t    continue;\n \t\t  if (! find_reg_note (last_insn, REG_BR_PROB, 0))\n \t\t    REG_NOTES (last_insn)\n-\t\t      = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (REG_BR_PROB_BASE),\n+\t\t      = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t\t   GEN_INT (REG_BR_PROB_BASE),\n \t\t\t\t\t   REG_NOTES (last_insn));\n \t\t}\n \t}\n     }\n \n-  /* Try to predict condjumps using same algorithm as mostly_true_jump */\n+  /* Try to predict condjumps using same algorithm as mostly_true_jump.  */\n   for (i = 0; i < n_basic_blocks - 1; i++)\n     {\n       rtx last_insn = BLOCK_END (i);\n@@ -114,10 +116,13 @@ estimate_probability (loops_info)\n \tcase CONST_INT:\n \t  /* Unconditional branch.  */\n \t  prob = REG_BR_PROB_BASE / 2;\n+\t  break;\n \tcase EQ:\n \t  prob = REG_BR_PROB_BASE / 10;\n+\t  break;\n \tcase NE:\n \t  prob = REG_BR_PROB_BASE / 2;\n+\t  break;\n \tcase LE:\n \tcase LT:\n \t  if (XEXP (cond, 1) == const0_rtx)"}, {"sha": "0046c57736e76e27c9374cf97f71be81a4f68485", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=65169dcfc24eafed52ff13e27421848aa8a6e44a", "patch": "@@ -497,6 +497,44 @@ sbitmap_union_of_preds (dst, src, bb)\n     }\n }\n \n+/* Return number of first bit set in the bitmap, -1 if none.  */\n+\n+int\n+sbitmap_first_set_bit (bmap)\n+     sbitmap bmap;\n+{\n+  int n;\n+  EXECUTE_IF_SET_IN_SBITMAP (bmap, 0, n, { return n; });\n+  return -1;\n+}\n+\n+/* Return number of last bit set in the bitmap, -1 if none.  */\n+\n+int\n+sbitmap_last_set_bit (bmap)\n+     sbitmap bmap;\n+{\n+  int i;\n+  SBITMAP_ELT_TYPE *ptr = bmap->elms;\n+  for (i = bmap->size - 1; i >= 0; i--)\n+    {\n+      SBITMAP_ELT_TYPE word = ptr[i];\n+      if (word)\n+      {\n+        int index = (i + 1) * SBITMAP_ELT_BITS - 1;\n+        SBITMAP_ELT_TYPE mask = (SBITMAP_ELT_TYPE) 1 << (SBITMAP_ELT_BITS - 1);\n+        while (1)\n+          {\n+            if (word & mask)\n+              return index;\n+            mask >>= 1;\n+            index--;\n+          }\n+      }\n+    }\n+  return -1;\n+}\n+\n void\n dump_sbitmap (file, bmap)\n      FILE *file;"}, {"sha": "d5065461bcba536fc65e11776178c549c941fd40", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65169dcfc24eafed52ff13e27421848aa8a6e44a/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=65169dcfc24eafed52ff13e27421848aa8a6e44a", "patch": "@@ -114,6 +114,9 @@ extern int sbitmap_a_and_b PARAMS ((sbitmap, sbitmap, sbitmap));\n extern int sbitmap_a_or_b PARAMS ((sbitmap, sbitmap, sbitmap));\n extern int sbitmap_a_subset_b_p PARAMS ((sbitmap, sbitmap));\n \n+extern int sbitmap_first_set_bit PROTO ((sbitmap));\n+extern int sbitmap_last_set_bit PROTO ((sbitmap));\n+\n struct int_list;\n extern void sbitmap_intersect_of_predsucc PARAMS ((sbitmap, sbitmap *,\n \t\t\t\t\t\t  int, struct int_list **));"}]}