{"sha": "2caa2a6997baa662e90548083365c37313ccb86f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNhYTJhNjk5N2JhYTY2MmU5MDU0ODA4MzM2NWMzNzMxM2NjYjg2Zg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-06-19T23:42:00Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-06-19T23:42:00Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r34605,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r34606", "tree": {"sha": "aa689507cfd2ec1fa95ed5a8aa4b63dfaa825d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa689507cfd2ec1fa95ed5a8aa4b63dfaa825d16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2caa2a6997baa662e90548083365c37313ccb86f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2caa2a6997baa662e90548083365c37313ccb86f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2caa2a6997baa662e90548083365c37313ccb86f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2caa2a6997baa662e90548083365c37313ccb86f/comments", "author": null, "committer": null, "parents": [{"sha": "8ba7b39619276758927df440237b74cb23654eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba7b39619276758927df440237b74cb23654eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba7b39619276758927df440237b74cb23654eb4"}], "stats": {"total": 48, "additions": 42, "deletions": 6}, "files": [{"sha": "d7cd8996085bff60fa60408aff0662f7e054b821", "filename": "boehm-gc/cord/gc.h", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2caa2a6997baa662e90548083365c37313ccb86f/boehm-gc%2Fcord%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2caa2a6997baa662e90548083365c37313ccb86f/boehm-gc%2Fcord%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fgc.h?ref=2caa2a6997baa662e90548083365c37313ccb86f", "patch": "@@ -36,6 +36,14 @@\n #include \"libgc_globals.h\"\n #endif\n \n+#if defined(__MINGW32__) && defined(WIN32_THREADS)\n+# ifdef GC_BUILD\n+#   define GC_API __declspec(dllexport)\n+# else\n+#   define GC_API __declspec(dllimport)\n+# endif\n+#endif\n+\n #if defined(_MSC_VER) && defined(_DLL)\n # ifdef GC_BUILD\n #   define GC_API __declspec(dllexport)\n@@ -131,6 +139,17 @@ GC_API int GC_dont_expand;\n \t\t\t/* Dont expand heap unless explicitly requested */\n \t\t\t/* or forced to.\t\t\t\t*/\n \n+GC_API int GC_use_entire_heap;\n+\t\t/* Causes the nonincremental collector to use the\t*/\n+\t\t/* entire heap before collecting.  This was the only \t*/\n+\t\t/* option for GC versions < 5.0.  This sometimes\t*/\n+\t\t/* results in more large block fragmentation, since\t*/\n+\t\t/* very larg blocks will tend to get broken up\t\t*/\n+\t\t/* during each GC cycle.  It is likely to result in a\t*/\n+\t\t/* larger working set, but lower collection\t\t*/\n+\t\t/* frequencies, and hence fewer instructions executed\t*/\n+\t\t/* in the collector.\t\t\t\t\t*/\n+\n GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n \t\t\t    /* full collections.  Matters only if\t*/\n \t\t\t    /* GC_incremental is set.\t\t\t*/\n@@ -353,8 +372,7 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n \n #ifdef GC_ADD_CALLER\n #  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s,\n-\t\t          int i\n+#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s, int i\n #else\n #  define GC_EXTRAS __FILE__, __LINE__\n #  define GC_EXTRA_PARAMS GC_CONST char * s, int i\n@@ -388,6 +406,8 @@ GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n \tGC_debug_register_finalizer(p, f, d, of, od)\n #   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n \tGC_debug_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer_no_order(p, f, d, of, od)\n #   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);\n #   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)\n #   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)\n@@ -404,6 +424,8 @@ GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n \tGC_register_finalizer(p, f, d, of, od)\n #   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n \tGC_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n+\tGC_register_finalizer_no_order(p, f, d, of, od)\n #   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)\n #   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)\n #   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)\n@@ -482,6 +504,16 @@ GC_API void GC_debug_register_finalizer_ignore_self\n \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n \t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n \n+/* Another version of the above.  It ignores all cycles.        */\n+/* It should probably only be used by Java implementations.      */\n+GC_API void GC_register_finalizer_no_order\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer_no_order\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+\n+\n /* The following routine may be used to break cycles between\t*/\n /* finalizable objects, thus causing cyclic finalizable\t\t*/\n /* objects to be finalized in the correct order.  Standard\t*/\n@@ -538,6 +570,9 @@ GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));\n GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n \n+/* Returns !=0  if GC_invoke_finalizers has something to do. \t\t*/\n+GC_API int GC_should_invoke_finalizers GC_PROTO((void));\n+\n GC_API int GC_invoke_finalizers GC_PROTO((void));\n \t/* Run finalizers for all objects that are ready to\t*/\n \t/* be finalized.  Return the number of finalizers\t*/\n@@ -701,7 +736,8 @@ GC_API void (*GC_is_visible_print_proc)\n # endif /* SOLARIS_THREADS */\n \n \n-#if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+#if !defined(USE_LD_WRAP) && \\\n+    (defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS))\n /* We treat these similarly. */\n # include <pthread.h>\n # include <signal.h>\n@@ -715,8 +751,9 @@ GC_API void (*GC_is_visible_print_proc)\n # define pthread_create GC_pthread_create\n # define pthread_sigmask GC_pthread_sigmask\n # define pthread_join GC_pthread_join\n+# define dlopen GC_dlopen\n \n-#endif /* IRIX_THREADS || LINUX_THREADS */\n+#endif /* xxxxx_THREADS */\n \n # if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n \tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\"}, {"sha": "d7cd8996085bff60fa60408aff0662f7e054b821", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2caa2a6997baa662e90548083365c37313ccb86f/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2caa2a6997baa662e90548083365c37313ccb86f/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=2caa2a6997baa662e90548083365c37313ccb86f", "patch": "@@ -372,8 +372,7 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n \n #ifdef GC_ADD_CALLER\n #  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s,\n-\t\t          int i\n+#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s, int i\n #else\n #  define GC_EXTRAS __FILE__, __LINE__\n #  define GC_EXTRA_PARAMS GC_CONST char * s, int i"}]}