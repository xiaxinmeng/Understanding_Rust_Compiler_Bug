{"sha": "7c76b292a2c186c2f3019591a44d6010b5de8a6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M3NmIyOTJhMmMxODZjMmYzMDE5NTkxYTQ0ZDYwMTBiNWRlOGE2Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-01T17:15:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-01T17:15:54Z"}, "message": "tweak\n\nFrom-SVN: r18934", "tree": {"sha": "f0a1f34564d0c4d72b3a6d9eb337da8771d2f993", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0a1f34564d0c4d72b3a6d9eb337da8771d2f993"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c76b292a2c186c2f3019591a44d6010b5de8a6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c76b292a2c186c2f3019591a44d6010b5de8a6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c76b292a2c186c2f3019591a44d6010b5de8a6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c76b292a2c186c2f3019591a44d6010b5de8a6f/comments", "author": null, "committer": null, "parents": [{"sha": "570221c20101ecc72f193e2b88e39069e05c963d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570221c20101ecc72f193e2b88e39069e05c963d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/570221c20101ecc72f193e2b88e39069e05c963d"}], "stats": {"total": 32, "additions": 19, "deletions": 13}, "files": [{"sha": "b475015990a5b6effc03d5bad6b46de7e597fcef", "filename": "gcc/cp/call.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c76b292a2c186c2f3019591a44d6010b5de8a6f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c76b292a2c186c2f3019591a44d6010b5de8a6f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7c76b292a2c186c2f3019591a44d6010b5de8a6f", "patch": "@@ -494,6 +494,7 @@ build_call (function, result_type, parms)\n {\n   int is_constructor = 0;\n   tree tmp;\n+  tree decl;\n \n   function = build_addr_func (function);\n \n@@ -504,23 +505,28 @@ build_call (function, result_type, parms)\n     }\n \n   if (TREE_CODE (function) == ADDR_EXPR\n-      && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL\n-      && DECL_CONSTRUCTOR_P (TREE_OPERAND (function, 0)))\n+      && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL)\n+    decl = TREE_OPERAND (function, 0);\n+  else\n+    decl = NULL_TREE;\n+\n+  if (decl && DECL_CONSTRUCTOR_P (decl))\n     is_constructor = 1;\n \n-  /* Don't actually pass empty class objects to a function.  This is useful\n+  /* Don't pass empty class objects by value.  This is useful\n      for tags in STL, which are used to control overload resolution.\n      We don't need to handle other cases of copying empty classes.  */\n-  for (tmp = parms; tmp; tmp = TREE_CHAIN (tmp))\n-    if (is_empty_class (TREE_TYPE (TREE_VALUE (tmp)))\n-\t&& ! TREE_ADDRESSABLE (TREE_TYPE (TREE_VALUE (tmp))))\n-      {\n-\ttree t = make_node (RTL_EXPR);\n-\tTREE_TYPE (t) = TREE_TYPE (TREE_VALUE (tmp));\n-\tRTL_EXPR_RTL (t) = const0_rtx;\n-\tRTL_EXPR_SEQUENCE (t) = NULL_RTX;\n-\tTREE_VALUE (tmp) = t;\n-      }\n+  if (! decl || ! DECL_BUILT_IN (decl))\n+    for (tmp = parms; tmp; tmp = TREE_CHAIN (tmp))\n+      if (is_empty_class (TREE_TYPE (TREE_VALUE (tmp)))\n+\t  && ! TREE_ADDRESSABLE (TREE_TYPE (TREE_VALUE (tmp))))\n+\t{\n+\t  tree t = make_node (RTL_EXPR);\n+\t  TREE_TYPE (t) = TREE_TYPE (TREE_VALUE (tmp));\n+\t  RTL_EXPR_RTL (t) = const0_rtx;\n+\t  RTL_EXPR_SEQUENCE (t) = NULL_RTX;\n+\t  TREE_VALUE (tmp) = t;\n+\t}\n \n   function = build_nt (CALL_EXPR, function, parms, NULL_TREE);\n   TREE_HAS_CONSTRUCTOR (function) = is_constructor;"}]}