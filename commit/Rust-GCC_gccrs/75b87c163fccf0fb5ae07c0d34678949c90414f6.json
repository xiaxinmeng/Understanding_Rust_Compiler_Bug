{"sha": "75b87c163fccf0fb5ae07c0d34678949c90414f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzViODdjMTYzZmNjZjBmYjVhZTA3YzBkMzQ2Nzg5NDljOTA0MTRmNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T13:23:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T13:23:35Z"}, "message": "[multiple changes]\n\n2015-10-26  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch7.adb, exp_ch6.adb: Minor comment fix.\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb (Move_Or_Merge_Aspects): Move all aspects related\n\tto a single concurrent type declaration to the declaration\n\tof the anonymous object if they qualify.\n\t(Relocate_Aspect): Update comment on usage.\n\t* aspects.ads Add new sectioon on aspect specifications on single\n\tconcurrent types. Add new table Aspect_On_Anonymous_Object_OK.\n\t(Move_Or_Merge_Aspects): Udate the comment on usage.\n\t* atree.adb (Elist36): New routine.\n\t(Set_Elist36): New routine.\n\t* atree.ads (Elist36): New routine along with pragma Inline.\n\t(Set_Elist36): New routine along with pragma Inline.\n\t* atree.h: Elist36 is now an alias for Field36.\n\t* contracts.adb (Add_Contract_Item): Add processing\n\tfor protected units and extra processing for variables.\n\t(Analyze_Object_Contract): Code cleanup. The processing of\n\tPart_Of now depends on wherer the object is a constant or\n\ta variable. Add processing for pragmas Depends and Global\n\twhen they apply to a single concurrent object. Verify that a\n\tvariable which is part of a single concurrent type has full\n\tdefault initialization. Set/restore the SPARK_Mode of a single\n\tconcurrent object.\n\t(Analyze_Protected_Contract): New routine.\n\t* contracts.ads (Add_Contract_Item): Update the comment on usage.\n\t(Analyze_Object_Contract): Update the comment on usage.\n\t(Analyze_Protected_Contract): New routine.\n\t(Analyze_Task_Contract): Update the comment on usage.\n\t* einfo.adb Part_Of_Constituents now uses Elist10.\n\t(Anonymous_Object): New routine.\n\t(Contract): Code cleanup.\n\t(Has_Option): Remove the assumption that the only simple\n\toption is External.\n\t(Is_Synchronized_State): New routine.\n\t(Part_Of_Constituents): This attribute applies to\n\tvariables and uses Elist10.\n\t(Set_Anonymous_Object): New routine.\n\t(Set_Contract): Code cleanup.\n\t(Set_Part_Of_Constituents): This attribute applies to variables and\n\tuses Elist10.\n\t(Set_SPARK_Aux_Pragma): Code cleanup.\n\t(Set_SPARK_Aux_Pragma_Inherited): Code cleanup.\n\t(Set_SPARK_Pragma): Code cleanup. This attribute applies to\n\tvariables.\n\t(Set_SPARK_Pragma_Inherited): Code cleanup. This\n\tattribute applies to variables.\n\t(SPARK_Aux_Pragma): Code cleanup.\n\t(SPARK_Aux_Pragma_Inherited): Code cleanup.\n\t(SPARK_Pragma): Code cleanup. This attribute applies to variables.\n\t(SPARK_Pragma_Inherited): Code cleanup. This attribute applies\n\tto variables.\n\t(Write_Field9_Name): Remove the output for Part_Of_Constituents.\n\t(Write_Field10_Name): Add output for Part_Of_Constituents.\n\t(Write_Field30_Name): Add output for Anonymous_Object.\n\t(Write_Field34_Name): Output SPARK_Pragma\n\tfor protected types and variables.\n\t* einfo.ads: New attributes Anonymous_Object and\n\tIs_Synchronized_State along with usage in entities. Update\n\tthe documentation of attributes Contract Encapsulating_State\n\tPart_Of_Constituents SPARK_Aux_Pragma SPARK_Aux_Pragma_Inherited\n\tSPARK_Pragma SPARK_Pragma_Inherited (Anonymous_Object): New\n\troutine along with pragma Inline.\n\t(Is_Synchronized_State): New routine.\n\t(Set_Anonymous_Object): New routine along with pragma Inline.\n\t* freeze.adb (Freeze_Record_Type): Ensure that a non-synchronized\n\trecord does not have synchronized components.\n\t* sem_ch3.adb (Analyze_Declarations): Code cleanup. Analyze the\n\tcontract of protected units.\n\t* sem_ch9.adb Add with and use clauses for Sem_Prag. Code cleanup.\n\t(Analyze_Single_Protected_Declaration): Reimplemented.\n\t(Analyze_Single_Task_Declaration): Reimplemented.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Aspect Part_Of\n\tcan now apply to a single concurrent type declaration. Rely on\n\tInsert_Pragma to place the pragma.  Update the error message on\n\tusage to reflect the new context.\n\t(Insert_Pragma): When inserting\n\tpragmas for a protected or task type, create a definition if\n\tthe type lacks one.\n\t* sem_elab.adb (Check_A_Call): Code cleanup. Issue error message\n\trelated to elaboration issues for SPARK when SPARK_Mode is \"on\"\n\tand the offending entity comes from source.\n\t* sem_prag.adb (Analyze_Abstract_State): Add new flag\n\tSynchronous_Seen. Update the analysis of simple options Externa,\n\tGhost and Synchronous. Update various error messages to reflect\n\tthe use of single concurrent types.\n\t(Analyze_Depends_Global): Pragmas Depends and Global can now apply to\n\ta single task type or a single concurrent object created for a task\n\ttype.\n\t(Analyze_Depends_In_Decl_Part): Do not push a scope when the\n\tcontext is a single concurrent object.\t(Analyze_Part_Of):\n\tMoved out of Analyze_Pragma. The routine has a new profile\n\tand comment on usage.\n\t(Analyze_Part_Of_In_Decl_Part): New routine.\n\t(Analyze_Part_Of_Option): Update the call to Analyze_Part_Of.\n\t(Analyze_Pragma): Pragma Abstract_State can\n\tnow carry simple option Synchronous. Pragma Part_Of can now\n\tapply to a single concurrent type declaration. The analysis\n\tof pragma Part_Of is delayed when the context is a single\n\tconcurrent object.\n\t(Analyze_Refined_Depends_In_Decl_Part): Use the anonymous object when\n\tthe context is a single concurren type.\n\t(Analyze_Refined_Global_In_Decl_Part): Use the\n\tanonymous object when the context is a single concurren type.\n\t(Check_Ghost_Constituent): Removed.\n\t(Check_Matching_Constituent): Renamed to Match_Constituent.\n\t(Check_Matching_State): Renamed to Match_State.\n\t(Collect_Constituent): Update the comment\n\ton usage. Verify various legality rules related to ghost and\n\tsynchronized entities.\n\t(Find_Related_Declaration_Or_Body): A single task declaration is no\n\tlonger a valid context for a pragma.\n\t(Fix_Msg): Moved to Sem_Util.\n\t(Process_Overloadable): Add processing for single task objects.\n\t(Process_Visible_Part): Add processing for single concurrent\n\ttypes.\n\t(Relocate_Pragmas_To_Anonymous_Object): New routine.\n\t* sem_prag.ads Add new table Pragma_On_Anonymous_Object_OK.\n\t(Analyze_Part_Of_In_Decl_Part): New routine.\n\t(Relocate_Pragmas_To_Anonymous_Object): New routine.\n\t* sem_util.adb (Defining_Entity): Code cleanup.\n\t(Fix_Msg): Moved from Sem_Prag and augmented to handle\n\tmode replacements.\n\t(Has_Full_Default_Initialization): New routine.\n\t(Is_Descendant_Of_Suspension_Object): Moved out of\n\tIs_Effectively_Volatile.\n\t(Is_Single_Concurrent_Object): New routine.\n\t(Is_Single_Concurrent_Type): New routine.\n\t(Is_Single_Concurrent_Type_Declaration): New routine.\n\t(Is_Synchronized_Object): New routine.\n\t(Yields_Synchronized_Object): New routine.\n\t* sem_util.ads (Fix_Msg): Moved form Sem_Prag. Update the\n\tcomment on usage.\n\t(Has_Full_Default_Initialization): New routine.\n\t(Is_Single_Concurrent_Object): New routine.\n\t(Is_Single_Concurrent_Type): New routine.\n\t(Is_Single_Concurrent_Type_Declaration): New routine.\n\t(Is_Synchronized_Object): New routine.\n\t(Yields_Synchronized_Object): New routine.\n\t* snames.ads-tmpl: Add name Synchronous.\n\nFrom-SVN: r229357", "tree": {"sha": "ab8fd4ac18dee0c38a8322da3d66e51639f69f22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab8fd4ac18dee0c38a8322da3d66e51639f69f22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75b87c163fccf0fb5ae07c0d34678949c90414f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b87c163fccf0fb5ae07c0d34678949c90414f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b87c163fccf0fb5ae07c0d34678949c90414f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b87c163fccf0fb5ae07c0d34678949c90414f6/comments", "author": null, "committer": null, "parents": [{"sha": "90707ac1bbeaa670d0a93de3f4299254dd4579c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90707ac1bbeaa670d0a93de3f4299254dd4579c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90707ac1bbeaa670d0a93de3f4299254dd4579c9"}], "stats": {"total": 2783, "additions": 1962, "deletions": 821}, "files": [{"sha": "f93439edff31b4c0bc2f7c9f88661f179fd9890a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -1,3 +1,147 @@\n+2015-10-26  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch7.adb, exp_ch6.adb: Minor comment fix.\n+\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb (Move_Or_Merge_Aspects): Move all aspects related\n+\tto a single concurrent type declaration to the declaration\n+\tof the anonymous object if they qualify.\n+\t(Relocate_Aspect): Update comment on usage.\n+\t* aspects.ads Add new sectioon on aspect specifications on single\n+\tconcurrent types. Add new table Aspect_On_Anonymous_Object_OK.\n+\t(Move_Or_Merge_Aspects): Udate the comment on usage.\n+\t* atree.adb (Elist36): New routine.\n+\t(Set_Elist36): New routine.\n+\t* atree.ads (Elist36): New routine along with pragma Inline.\n+\t(Set_Elist36): New routine along with pragma Inline.\n+\t* atree.h: Elist36 is now an alias for Field36.\n+\t* contracts.adb (Add_Contract_Item): Add processing\n+\tfor protected units and extra processing for variables.\n+\t(Analyze_Object_Contract): Code cleanup. The processing of\n+\tPart_Of now depends on wherer the object is a constant or\n+\ta variable. Add processing for pragmas Depends and Global\n+\twhen they apply to a single concurrent object. Verify that a\n+\tvariable which is part of a single concurrent type has full\n+\tdefault initialization. Set/restore the SPARK_Mode of a single\n+\tconcurrent object.\n+\t(Analyze_Protected_Contract): New routine.\n+\t* contracts.ads (Add_Contract_Item): Update the comment on usage.\n+\t(Analyze_Object_Contract): Update the comment on usage.\n+\t(Analyze_Protected_Contract): New routine.\n+\t(Analyze_Task_Contract): Update the comment on usage.\n+\t* einfo.adb Part_Of_Constituents now uses Elist10.\n+\t(Anonymous_Object): New routine.\n+\t(Contract): Code cleanup.\n+\t(Has_Option): Remove the assumption that the only simple\n+\toption is External.\n+\t(Is_Synchronized_State): New routine.\n+\t(Part_Of_Constituents): This attribute applies to\n+\tvariables and uses Elist10.\n+\t(Set_Anonymous_Object): New routine.\n+\t(Set_Contract): Code cleanup.\n+\t(Set_Part_Of_Constituents): This attribute applies to variables and\n+\tuses Elist10.\n+\t(Set_SPARK_Aux_Pragma): Code cleanup.\n+\t(Set_SPARK_Aux_Pragma_Inherited): Code cleanup.\n+\t(Set_SPARK_Pragma): Code cleanup. This attribute applies to\n+\tvariables.\n+\t(Set_SPARK_Pragma_Inherited): Code cleanup. This\n+\tattribute applies to variables.\n+\t(SPARK_Aux_Pragma): Code cleanup.\n+\t(SPARK_Aux_Pragma_Inherited): Code cleanup.\n+\t(SPARK_Pragma): Code cleanup. This attribute applies to variables.\n+\t(SPARK_Pragma_Inherited): Code cleanup. This attribute applies\n+\tto variables.\n+\t(Write_Field9_Name): Remove the output for Part_Of_Constituents.\n+\t(Write_Field10_Name): Add output for Part_Of_Constituents.\n+\t(Write_Field30_Name): Add output for Anonymous_Object.\n+\t(Write_Field34_Name): Output SPARK_Pragma\n+\tfor protected types and variables.\n+\t* einfo.ads: New attributes Anonymous_Object and\n+\tIs_Synchronized_State along with usage in entities. Update\n+\tthe documentation of attributes Contract Encapsulating_State\n+\tPart_Of_Constituents SPARK_Aux_Pragma SPARK_Aux_Pragma_Inherited\n+\tSPARK_Pragma SPARK_Pragma_Inherited (Anonymous_Object): New\n+\troutine along with pragma Inline.\n+\t(Is_Synchronized_State): New routine.\n+\t(Set_Anonymous_Object): New routine along with pragma Inline.\n+\t* freeze.adb (Freeze_Record_Type): Ensure that a non-synchronized\n+\trecord does not have synchronized components.\n+\t* sem_ch3.adb (Analyze_Declarations): Code cleanup. Analyze the\n+\tcontract of protected units.\n+\t* sem_ch9.adb Add with and use clauses for Sem_Prag. Code cleanup.\n+\t(Analyze_Single_Protected_Declaration): Reimplemented.\n+\t(Analyze_Single_Task_Declaration): Reimplemented.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Aspect Part_Of\n+\tcan now apply to a single concurrent type declaration. Rely on\n+\tInsert_Pragma to place the pragma.  Update the error message on\n+\tusage to reflect the new context.\n+\t(Insert_Pragma): When inserting\n+\tpragmas for a protected or task type, create a definition if\n+\tthe type lacks one.\n+\t* sem_elab.adb (Check_A_Call): Code cleanup. Issue error message\n+\trelated to elaboration issues for SPARK when SPARK_Mode is \"on\"\n+\tand the offending entity comes from source.\n+\t* sem_prag.adb (Analyze_Abstract_State): Add new flag\n+\tSynchronous_Seen. Update the analysis of simple options Externa,\n+\tGhost and Synchronous. Update various error messages to reflect\n+\tthe use of single concurrent types.\n+\t(Analyze_Depends_Global): Pragmas Depends and Global can now apply to\n+\ta single task type or a single concurrent object created for a task\n+\ttype.\n+\t(Analyze_Depends_In_Decl_Part): Do not push a scope when the\n+\tcontext is a single concurrent object.\t(Analyze_Part_Of):\n+\tMoved out of Analyze_Pragma. The routine has a new profile\n+\tand comment on usage.\n+\t(Analyze_Part_Of_In_Decl_Part): New routine.\n+\t(Analyze_Part_Of_Option): Update the call to Analyze_Part_Of.\n+\t(Analyze_Pragma): Pragma Abstract_State can\n+\tnow carry simple option Synchronous. Pragma Part_Of can now\n+\tapply to a single concurrent type declaration. The analysis\n+\tof pragma Part_Of is delayed when the context is a single\n+\tconcurrent object.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Use the anonymous object when\n+\tthe context is a single concurren type.\n+\t(Analyze_Refined_Global_In_Decl_Part): Use the\n+\tanonymous object when the context is a single concurren type.\n+\t(Check_Ghost_Constituent): Removed.\n+\t(Check_Matching_Constituent): Renamed to Match_Constituent.\n+\t(Check_Matching_State): Renamed to Match_State.\n+\t(Collect_Constituent): Update the comment\n+\ton usage. Verify various legality rules related to ghost and\n+\tsynchronized entities.\n+\t(Find_Related_Declaration_Or_Body): A single task declaration is no\n+\tlonger a valid context for a pragma.\n+\t(Fix_Msg): Moved to Sem_Util.\n+\t(Process_Overloadable): Add processing for single task objects.\n+\t(Process_Visible_Part): Add processing for single concurrent\n+\ttypes.\n+\t(Relocate_Pragmas_To_Anonymous_Object): New routine.\n+\t* sem_prag.ads Add new table Pragma_On_Anonymous_Object_OK.\n+\t(Analyze_Part_Of_In_Decl_Part): New routine.\n+\t(Relocate_Pragmas_To_Anonymous_Object): New routine.\n+\t* sem_util.adb (Defining_Entity): Code cleanup.\n+\t(Fix_Msg): Moved from Sem_Prag and augmented to handle\n+\tmode replacements.\n+\t(Has_Full_Default_Initialization): New routine.\n+\t(Is_Descendant_Of_Suspension_Object): Moved out of\n+\tIs_Effectively_Volatile.\n+\t(Is_Single_Concurrent_Object): New routine.\n+\t(Is_Single_Concurrent_Type): New routine.\n+\t(Is_Single_Concurrent_Type_Declaration): New routine.\n+\t(Is_Synchronized_Object): New routine.\n+\t(Yields_Synchronized_Object): New routine.\n+\t* sem_util.ads (Fix_Msg): Moved form Sem_Prag. Update the\n+\tcomment on usage.\n+\t(Has_Full_Default_Initialization): New routine.\n+\t(Is_Single_Concurrent_Object): New routine.\n+\t(Is_Single_Concurrent_Type): New routine.\n+\t(Is_Single_Concurrent_Type_Declaration): New routine.\n+\t(Is_Synchronized_Object): New routine.\n+\t(Yields_Synchronized_Object): New routine.\n+\t* snames.ads-tmpl: Add name Synchronous.\n+\n 2015-10-26  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* sysdep.c (__gnat_get_task_options): Refine the workaround for"}, {"sha": "e2bf1ead8f71284842b994413493269b835c6ce0", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -338,8 +338,7 @@ package body Aspects is\n \n    procedure Move_Or_Merge_Aspects (From : Node_Id; To : Node_Id) is\n       procedure Relocate_Aspect (Asp : Node_Id);\n-      --  Asp denotes an aspect specification of node From. Relocate the Asp to\n-      --  the aspect specifications of node To (if any).\n+      --  Move aspect specification Asp to the aspect specifications of node To\n \n       ---------------------\n       -- Relocate_Aspect --\n@@ -360,8 +359,8 @@ package body Aspects is\n             Set_Has_Aspects (To);\n          end if;\n \n-         --  Remove the aspect from node From's aspect specifications and\n-         --  append it to node To.\n+         --  Remove the aspect from its original owner and relocate it to node\n+         --  To.\n \n          Remove (Asp);\n          Append (Asp, Asps);\n@@ -403,6 +402,23 @@ package body Aspects is\n                   Relocate_Aspect (Asp);\n                end if;\n \n+            --  When moving or merging aspects from a single concurrent type\n+            --  declaration, relocate only those aspects that may apply to the\n+            --  anonymous object created for the type.\n+\n+            --  Note: It is better to use Is_Single_Concurrent_Type_Declaration\n+            --  here, but Aspects and Sem_Util have incompatible licenses.\n+\n+            elsif Nkind_In\n+                    (Original_Node (From), N_Single_Protected_Declaration,\n+                                           N_Single_Task_Declaration)\n+            then\n+               Asp_Id := Get_Aspect_Id (Asp);\n+\n+               if Aspect_On_Anonymous_Object_OK (Asp_Id) then\n+                  Relocate_Aspect (Asp);\n+               end if;\n+\n             --  Default case - relocate the aspect to its new owner\n \n             else"}, {"sha": "55c51a14a6be77cd3a9fd362cb8e05c47d68bf64", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -794,7 +794,7 @@ package Aspects is\n    --    package body P with SPARK_Mode is ...;\n \n    --  The table should be synchronized with Pragma_On_Body_Or_Stub_OK in unit\n-   --  Sem_Prag if the aspects below are implemented by a pragma.\n+   --  Sem_Prag.\n \n    Aspect_On_Body_Or_Stub_OK : constant array (Aspect_Id) of Boolean :=\n      (Aspect_Refined_Depends              => True,\n@@ -804,6 +804,26 @@ package Aspects is\n       Aspect_Warnings                     => True,\n       others                              => False);\n \n+   -------------------------------------------------------------------\n+   -- Handling of Aspects Specifications on Single Concurrent Types --\n+   -------------------------------------------------------------------\n+\n+   --  Certain aspects that appear on the following nodes\n+\n+   --    N_Single_Protected_Declaration\n+   --    N_Single_Task_Declaration\n+\n+   --  are treated as if they apply to the anonymous object produced by the\n+   --  analysis of a single concurrent type. The following table lists all\n+   --  aspects that should apply to the anonymous object. The table should\n+   --  be synchronized with Pragma_On_Anonymous_Object_OK in unit Sem_Prag.\n+\n+   Aspect_On_Anonymous_Object_OK : constant array (Aspect_Id) of Boolean :=\n+     (Aspect_Depends                      => True,\n+      Aspect_Global                       => True,\n+      Aspect_Part_Of                      => True,\n+      others                              => False);\n+\n    ---------------------------------------------------\n    -- Handling of Aspect Specifications in the Tree --\n    ---------------------------------------------------\n@@ -861,10 +881,14 @@ package Aspects is\n \n    procedure Move_Or_Merge_Aspects (From : Node_Id; To : Node_Id);\n    --  Relocate the aspect specifications of node From to node To. If To has\n-   --  aspects, the aspects of From are added to the aspects of To. If From has\n-   --  no aspects, the routine has no effect. When From denotes a subprogram\n-   --  body stub that also acts as a spec, the only aspects relocated to node\n-   --  To are those from table Aspect_On_Body_Or_Stub_OK and preconditions.\n+   --  aspects, the aspects of From are appended to the aspects of To. If From\n+   --  has no aspects, the routine has no effect. Special behavior:\n+   --    * When node From denotes a subprogram body stub without a previous\n+   --      declaration, the only aspects relocated to node To are those found\n+   --      in table Aspect_On_Body_Or_Stub_OK.\n+   --    * When node From denotes a single synchronized type declaration, the\n+   --      only aspects relocated to node To are those found in table\n+   --      Aspect_On_Anonymous_Object_OK.\n \n    function Permits_Aspect_Specifications (N : Node_Id) return Boolean;\n    --  Returns True if the node N is a declaration node that permits aspect"}, {"sha": "8df26b40e303d405d66eaab69484724c19e1c1c1", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -3103,6 +3103,17 @@ package body Atree is\n          end if;\n       end Elist26;\n \n+      function Elist36 (N : Node_Id) return Elist_Id is\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Value : constant Union_Id := Nodes.Table (N + 6).Field6;\n+      begin\n+         if Value = 0 then\n+            return No_Elist;\n+         else\n+            return Elist_Id (Value);\n+         end if;\n+      end Elist36;\n+\n       function Name1 (N : Node_Id) return Name_Id is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5878,6 +5889,12 @@ package body Atree is\n          Nodes.Table (N + 4).Field8 := Union_Id (Val);\n       end Set_Elist26;\n \n+      procedure Set_Elist36 (N : Node_Id; Val : Elist_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field6 := Union_Id (Val);\n+      end Set_Elist36;\n+\n       procedure Set_Name1 (N : Node_Id; Val : Name_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "75939c68ed894c70ddf8fb259b7508272d1e1013", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -1412,6 +1412,9 @@ package Atree is\n       function Elist26 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist26);\n \n+      function Elist36 (N : Node_Id) return Elist_Id;\n+      pragma Inline (Elist36);\n+\n       function Name1 (N : Node_Id) return Name_Id;\n       pragma Inline (Name1);\n \n@@ -2769,6 +2772,9 @@ package Atree is\n       procedure Set_Elist26 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist26);\n \n+      procedure Set_Elist36 (N : Node_Id; Val : Elist_Id);\n+      pragma Inline (Set_Elist36);\n+\n       procedure Set_Name1 (N : Node_Id; Val : Name_Id);\n       pragma Inline (Set_Name1);\n "}, {"sha": "f92961ee7ec4550fc90c480994ed92e3a613c8f9", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -525,6 +525,7 @@ extern Node_Id Current_Error_Node;\n #define Elist24(N)    Field24 (N)\n #define Elist25(N)    Field25 (N)\n #define Elist26(N)    Field26 (N)\n+#define Elist36(N)    Field36 (N)\n \n #define Name1(N)      Field1  (N)\n #define Name2(N)      Field2  (N)"}, {"sha": "3e6258a11bbdd464553c068113a022ef7855235d", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 197, "deletions": 52, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -228,6 +228,19 @@ package body Contracts is\n             raise Program_Error;\n          end if;\n \n+      --  Protected units, the applicable pragmas are:\n+      --    Part_Of\n+\n+      elsif Ekind (Id) = E_Protected_Type then\n+         if Prag_Nam = Name_Part_Of then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n       --  Subprogram bodies, the applicable pragmas are:\n       --    Postcondition\n       --    Precondition\n@@ -268,9 +281,10 @@ package body Contracts is\n       --  Task units, the applicable pragmas are:\n       --    Depends\n       --    Global\n+      --    Part_Of\n \n       elsif Ekind (Id) = E_Task_Type then\n-         if Nam_In (Prag_Nam, Name_Depends, Name_Global) then\n+         if Nam_In (Prag_Nam, Name_Depends, Name_Global, Name_Part_Of) then\n             Add_Classification;\n \n          --  The pragma is not a proper contract item\n@@ -283,16 +297,20 @@ package body Contracts is\n       --    Async_Readers\n       --    Async_Writers\n       --    Constant_After_Elaboration\n+      --    Depends\n       --    Effective_Reads\n       --    Effective_Writes\n+      --    Global\n       --    Part_Of\n \n       elsif Ekind (Id) = E_Variable then\n          if Nam_In (Prag_Nam, Name_Async_Readers,\n                               Name_Async_Writers,\n                               Name_Constant_After_Elaboration,\n+                              Name_Depends,\n                               Name_Effective_Reads,\n                               Name_Effective_Writes,\n+                              Name_Global,\n                               Name_Part_Of)\n          then\n             Add_Classification;\n@@ -565,14 +583,17 @@ package body Contracts is\n    -----------------------------\n \n    procedure Analyze_Object_Contract (Obj_Id : Entity_Id) is\n-      Obj_Typ : constant Entity_Id := Etype (Obj_Id);\n-      AR_Val  : Boolean := False;\n-      AW_Val  : Boolean := False;\n-      ER_Val  : Boolean := False;\n-      EW_Val  : Boolean := False;\n-      Items   : Node_Id;\n-      Prag    : Node_Id;\n-      Seen    : Boolean := False;\n+      Obj_Typ      : constant Entity_Id := Etype (Obj_Id);\n+      AR_Val       : Boolean := False;\n+      AW_Val       : Boolean := False;\n+      Encap_Id     : Entity_Id;\n+      ER_Val       : Boolean := False;\n+      EW_Val       : Boolean := False;\n+      Items        : Node_Id;\n+      Mode         : SPARK_Mode_Type;\n+      Prag         : Node_Id;\n+      Restore_Mode : Boolean := False;\n+      Seen         : Boolean := False;\n \n    begin\n       --  The loop parameter in an element iterator over a formal container\n@@ -612,10 +633,106 @@ package body Contracts is\n             Error_Msg_N (\"constant cannot be volatile\", Obj_Id);\n          end if;\n \n+         Prag := Get_Pragma (Obj_Id, Pragma_Part_Of);\n+\n+         --  Check whether the lack of indicator Part_Of agrees with the\n+         --  placement of the constant with respect to the state space.\n+\n+         if No (Prag) then\n+            Check_Missing_Part_Of (Obj_Id);\n+         end if;\n+\n       --  Variable-related checks\n \n       else pragma Assert (Ekind (Obj_Id) = E_Variable);\n \n+         --  The anonymous object created for a single concurrent type inherits\n+         --  the SPARK_Mode from the type. Due to the timing of contract\n+         --  analysis, delayed pragmas may be subject to the wrong SPARK_Mode,\n+         --  usually that of the enclosing context. To remedy this, restore the\n+         --  original SPARK_Mode of the related variable.\n+\n+         if Is_Single_Concurrent_Object (Obj_Id)\n+           and then Present (SPARK_Pragma (Obj_Id))\n+         then\n+            Restore_Mode := True;\n+            Save_SPARK_Mode_And_Set (Obj_Id, Mode);\n+         end if;\n+\n+         --  Analyze all external properties\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Async_Readers);\n+\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n+            Seen := True;\n+         end if;\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Async_Writers);\n+\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n+            Seen := True;\n+         end if;\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Reads);\n+\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n+            Seen := True;\n+         end if;\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Writes);\n+\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n+            Seen := True;\n+         end if;\n+\n+         --  Verify the mutual interaction of the various external properties\n+\n+         if Seen then\n+            Check_External_Properties (Obj_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n+         end if;\n+\n+         --  The anonymous object created for a single concurrent type carries\n+         --  pragmas Depends and Globat of the type.\n+\n+         if Is_Single_Concurrent_Object (Obj_Id) then\n+\n+            --  Analyze Global first, as Depends may mention items classified\n+            --  in the global categorization.\n+\n+            Prag := Get_Pragma (Obj_Id, Pragma_Global);\n+\n+            if Present (Prag) then\n+               Analyze_Global_In_Decl_Part (Prag);\n+            end if;\n+\n+            --  Depends must be analyzed after Global in order to see the modes\n+            --  of all global items.\n+\n+            Prag := Get_Pragma (Obj_Id, Pragma_Depends);\n+\n+            if Present (Prag) then\n+               Analyze_Depends_In_Decl_Part (Prag);\n+            end if;\n+         end if;\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Part_Of);\n+\n+         --  Analyze indicator Part_Of\n+\n+         if Present (Prag) then\n+            Analyze_Part_Of_In_Decl_Part (Prag);\n+\n+         --  Otherwise check whether the lack of indicator Part_Of agrees with\n+         --  the placement of the variable with respect to the state space.\n+\n+         else\n+            Check_Missing_Part_Of (Obj_Id);\n+         end if;\n+\n          --  The following checks are relevant only when SPARK_Mode is on, as\n          --  they are not standard Ada legality rules. Internally generated\n          --  temporaries are ignored.\n@@ -661,6 +778,28 @@ package body Contracts is\n                      Obj_Id);\n                end if;\n             end if;\n+\n+            --  A variable whose Part_Of pragma specifies a single concurrent\n+            --  type as encapsulator must be (SPARK RM 9.4):\n+            --    * Of a type that defines full default initialization, or\n+            --    * Declared with a default value, or\n+            --    * Imported\n+\n+            Encap_Id := Encapsulating_State (Obj_Id);\n+\n+            if Present (Encap_Id)\n+              and then Is_Single_Concurrent_Object (Encap_Id)\n+              and then not Has_Full_Default_Initialization (Etype (Obj_Id))\n+              and then not Has_Initial_Value (Obj_Id)\n+              and then not Is_Imported (Obj_Id)\n+            then\n+               Error_Msg_N (\"& requires full default initialization\", Obj_Id);\n+\n+               Error_Msg_Name_1 := Chars (Encap_Id);\n+               Error_Msg_N\n+                 (Fix_Msg (Encap_Id, \"\\object acts as constituent of single \"\n+                  & \"protected type %\"), Obj_Id);\n+            end if;\n          end if;\n \n          if Is_Ghost_Entity (Obj_Id) then\n@@ -680,50 +819,12 @@ package body Contracts is\n             end if;\n          end if;\n \n-         --  Analyze all external properties\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Async_Readers);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n-            Seen := True;\n-         end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Async_Writers);\n+         --  Restore the SPARK_Mode of the enclosing context after all delayed\n+         --  pragmas have been analyzed.\n \n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n-            Seen := True;\n+         if Restore_Mode then\n+            Restore_SPARK_Mode (Mode);\n          end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Reads);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n-            Seen := True;\n-         end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Writes);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n-            Seen := True;\n-         end if;\n-\n-         --  Verify the mutual interaction of the various external properties\n-\n-         if Seen then\n-            Check_External_Properties (Obj_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n-         end if;\n-      end if;\n-\n-      --  Check whether the lack of indicator Part_Of agrees with the placement\n-      --  of the object with respect to the state space.\n-\n-      Prag := Get_Pragma (Obj_Id, Pragma_Part_Of);\n-\n-      if No (Prag) then\n-         Check_Missing_Part_Of (Obj_Id);\n       end if;\n \n       --  A ghost object cannot be imported or exported (SPARK RM 6.9(8)). One\n@@ -893,6 +994,50 @@ package body Contracts is\n       end if;\n    end Analyze_Package_Contract;\n \n+   --------------------------------\n+   -- Analyze_Protected_Contract --\n+   --------------------------------\n+\n+   procedure Analyze_Protected_Contract (Prot_Id : Entity_Id) is\n+      Items : constant Node_Id := Contract (Prot_Id);\n+      Mode  : SPARK_Mode_Type;\n+\n+   begin\n+      --  Do not analyze a contract multiple times\n+\n+      if Present (Items) then\n+         if Analyzed (Items) then\n+            return;\n+         else\n+            Set_Analyzed (Items);\n+         end if;\n+      end if;\n+\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related protected unit.\n+\n+      Save_SPARK_Mode_And_Set (Prot_Id, Mode);\n+\n+      --  A protected type must define full default initialization\n+      --  (SPARK RM 9.4). This check is relevant only when SPARK_Mode is on as\n+      --  it is not a standard Ada legality rule.\n+\n+      if SPARK_Mode = On\n+        and then not Has_Full_Default_Initialization (Prot_Id)\n+      then\n+         Error_Msg_N\n+           (\"protected type & must define full default initialization\",\n+            Prot_Id);\n+      end if;\n+\n+      --  Restore the SPARK_Mode of the enclosing context after all delayed\n+      --  pragmas have been analyzed.\n+\n+      Restore_SPARK_Mode (Mode);\n+   end Analyze_Protected_Contract;\n+\n    -------------------------------------------\n    -- Analyze_Subprogram_Body_Stub_Contract --\n    -------------------------------------------\n@@ -949,7 +1094,7 @@ package body Contracts is\n       --  Due to the timing of contract analysis, delayed pragmas may be\n       --  subject to the wrong SPARK_Mode, usually that of the enclosing\n       --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related subprogram body.\n+      --  related task unit.\n \n       Save_SPARK_Mode_And_Set (Task_Id, Mode);\n "}, {"sha": "96ea79f8b994099048f8418ff80613804679fd05", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -32,8 +32,9 @@ package Contracts is\n \n    procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n    --  Add pragma Prag to the contract of a constant, entry, entry family,\n-   --  [generic] package, package body, [generic] subprogram, subprogram body,\n-   --  variable or task unit denoted by Id. The following are valid pragmas:\n+   --  [generic] package, package body, protected unit, [generic] subprogram,\n+   --  subprogram body, variable or task unit denoted by Id. The following are\n+   --  valid pragmas:\n    --    Abstract_State\n    --    Async_Readers\n    --    Async_Writers\n@@ -91,8 +92,10 @@ package Contracts is\n    --  considered are:\n    --    Async_Readers\n    --    Async_Writers\n+   --    Depends           (single concurrent object)\n    --    Effective_Reads\n    --    Effective_Writes\n+   --    Global            (single concurrent object)\n    --    Part_Of\n \n    procedure Analyze_Package_Body_Contract\n@@ -114,8 +117,13 @@ package Contracts is\n    --    Initializes\n    --    Part_Of\n \n+   procedure Analyze_Protected_Contract (Prot_Id : Entity_Id);\n+   --  Analyze all delayed pragmas chained on the contract of protected unit\n+   --  Prot_Id if they appeared at the end of a declarative region. Currently\n+   --  there are no such pragmas.\n+\n    procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id);\n-   --  Analyze all delayed pragmas chained on the contract of a subprogram body\n+   --  Analyze all delayed pragmas chained on the contract of subprogram body\n    --  stub Stub_Id as if they appeared at the end of a declarative region. The\n    --  pragmas in question are:\n    --    Contract_Cases\n@@ -129,9 +137,9 @@ package Contracts is\n    --    Test_Case\n \n    procedure Analyze_Task_Contract (Task_Id : Entity_Id);\n-   --  Analyze all delayed pragmas chained on the contract of a task unit\n-   --  Task_Id as if they appeared at the end of a declarative region. The\n-   --  pragmas in question are:\n+   --  Analyze all delayed pragmas chained on the contract of task unit Task_Id\n+   --  as if they appeared at the end of a declarative region. The pragmas in\n+   --  question are:\n    --    Depends\n    --    Global\n "}, {"sha": "b618047ce045e9158959d0889033c4e636d7d44f", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 101, "deletions": 64, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -86,14 +86,14 @@ package body Einfo is\n \n    --    Class_Wide_Type                 Node9\n    --    Current_Value                   Node9\n-   --    Part_Of_Constituents            Elist9\n    --    Renaming_Map                    Uint9\n \n    --    Direct_Primitive_Operations     Elist10\n    --    Discriminal_Link                Node10\n    --    Float_Rep                       Uint10 (but returns Float_Rep_Kind)\n    --    Handler_Records                 List10\n    --    Normalized_Position_Max         Uint10\n+   --    Part_Of_Constituents            Elist10\n \n    --    Component_Bit_Offset            Uint11\n    --    Full_View                       Node11\n@@ -246,6 +246,7 @@ package body Einfo is\n    --    BIP_Initialization_Call         Node29\n    --    Subprograms_For_Type            Node29\n \n+   --    Anonymous_Object                Node30\n    --    Corresponding_Equality          Node30\n    --    Last_Aggregate_Assignment       Node30\n    --    Static_Initialization           Node30\n@@ -661,13 +662,7 @@ package body Einfo is\n \n       Opt := First (Expressions (Decl));\n       while Present (Opt) loop\n-\n-         --  Currently the only simple option allowed is External\n-\n-         if Nkind (Opt) = N_Identifier\n-           and then Chars (Opt) = Name_External\n-           and then Chars (Opt) = Option_Nam\n-         then\n+         if Nkind (Opt) = N_Identifier and then Chars (Opt) = Option_Nam then\n             return True;\n          end if;\n \n@@ -766,6 +761,12 @@ package body Einfo is\n       return Node36 (Id);\n    end Anonymous_Master;\n \n+   function Anonymous_Object (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Protected_Type, E_Task_Type));\n+      return Node30 (Id);\n+   end Anonymous_Object;\n+\n    function Associated_Entity (Id : E) return E is\n    begin\n       return Node37 (Id);\n@@ -1205,7 +1206,11 @@ package body Einfo is\n    function Contract (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Constant,         --  object variants\n+        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+                       E_Task_Body,\n+                       E_Task_Type)\n+           or else\n+         Ekind_In (Id, E_Constant,         --  object variants\n                        E_Variable)\n            or else\n          Ekind_In (Id, E_Entry,            --  overloadable variants\n@@ -1221,9 +1226,7 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind_In (Id, E_Task_Body,         --  synchronized variants\n-                       E_Task_Type,\n-                       E_Void));            --  special purpose\n+         Ekind (Id) = E_Void);             --  special purpose\n       return Node34 (Id);\n    end Contract;\n \n@@ -2847,8 +2850,8 @@ package body Einfo is\n \n    function Part_Of_Constituents (Id : E) return L is\n    begin\n-      pragma Assert (Ekind (Id) = E_Abstract_State);\n-      return Elist9 (Id);\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n+      return Elist10 (Id);\n    end Part_Of_Constituents;\n \n    function Partial_View_Has_Unknown_Discr (Id : E) return B is\n@@ -3113,31 +3116,36 @@ package body Einfo is\n    function SPARK_Aux_Pragma (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Generic_Package,  --  package variants\n-                       E_Package,\n-                       E_Package_Body)\n+        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+                       E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Protected_Type,   --  synchronized variants\n-                       E_Task_Type));\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n       return Node41 (Id);\n    end SPARK_Aux_Pragma;\n \n    function SPARK_Aux_Pragma_Inherited (Id : E) return B is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Generic_Package,  --  package variants\n-                       E_Package,\n-                       E_Package_Body)\n+        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+                       E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Protected_Type,   --  synchronized variants\n-                       E_Task_Type));\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n       return Flag266 (Id);\n    end SPARK_Aux_Pragma_Inherited;\n \n    function SPARK_Pragma (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Entry,            --  overloadable variants\n+        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n+                       E_Protected_Type,\n+                       E_Task_Body,\n+                       E_Task_Type)\n+          or else\n+         Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -3150,17 +3158,19 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind_In (Id, E_Protected_Body,   --  synchronized variants\n-                       E_Protected_Type,\n-                       E_Task_Body,\n-                       E_Task_Type));\n+         Ekind (Id) = E_Variable);         --  variable\n       return Node40 (Id);\n    end SPARK_Pragma;\n \n    function SPARK_Pragma_Inherited (Id : E) return B is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Entry,            --  overloadable variants\n+        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n+                       E_Protected_Type,\n+                       E_Task_Body,\n+                       E_Task_Type)\n+           or else\n+         Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -3173,10 +3183,7 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind_In (Id, E_Protected_Body,   --  synchronized variants\n-                       E_Protected_Type,\n-                       E_Task_Body,\n-                       E_Task_Type));\n+         Ekind (Id) = E_Variable);         --  variable\n       return Flag265 (Id);\n    end SPARK_Pragma_Inherited;\n \n@@ -3648,6 +3655,12 @@ package body Einfo is\n       Set_Node36 (Id, V);\n    end Set_Anonymous_Master;\n \n+   procedure Set_Anonymous_Object (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Protected_Type, E_Task_Type));\n+      Set_Node30 (Id, V);\n+   end Set_Anonymous_Object;\n+\n    procedure Set_Associated_Entity (Id : E; V : E) is\n    begin\n       Set_Node37 (Id, V);\n@@ -3839,7 +3852,11 @@ package body Einfo is\n    procedure Set_Contract (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Constant,         --  object variants\n+        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+                       E_Task_Body,\n+                       E_Task_Type)\n+           or else\n+         Ekind_In (Id, E_Constant,         --  object variants\n                        E_Variable)\n            or else\n          Ekind_In (Id, E_Entry,            --  overloadable variants\n@@ -3855,9 +3872,7 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind_In (Id, E_Task_Body,         --  synchronized variants\n-                       E_Task_Type,\n-                       E_Void));            --  special purpose\n+         Ekind (Id) = E_Void);             --  special purpose\n       Set_Node34 (Id, V);\n    end Set_Contract;\n \n@@ -5871,8 +5886,8 @@ package body Einfo is\n \n    procedure Set_Part_Of_Constituents (Id : E; V : L) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Abstract_State);\n-      Set_Elist9 (Id, V);\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n+      Set_Elist10 (Id, V);\n    end Set_Part_Of_Constituents;\n \n    procedure Set_Partial_View_Has_Unknown_Discr (Id : E; V : B := True) is\n@@ -6149,31 +6164,36 @@ package body Einfo is\n    procedure Set_SPARK_Aux_Pragma (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Generic_Package,  --  package variants\n-                       E_Package,\n-                       E_Package_Body)\n+        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+                       E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Protected_Type,   --  synchronized variants\n-                       E_Task_Type));\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n       Set_Node41 (Id, V);\n    end Set_SPARK_Aux_Pragma;\n \n    procedure Set_SPARK_Aux_Pragma_Inherited (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Generic_Package,  --  package variants\n-                       E_Package,\n-                       E_Package_Body)\n+        (Ekind_In (Id, E_Protected_Type,   --  concurrent variants\n+                       E_Task_Type)\n            or else\n-         Ekind_In (Id, E_Protected_Type,   --  synchronized variants\n-                       E_Task_Type));\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n       Set_Flag266 (Id, V);\n    end Set_SPARK_Aux_Pragma_Inherited;\n \n    procedure Set_SPARK_Pragma (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Entry,            --  overloadable variants\n+        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n+                       E_Protected_Type,\n+                       E_Task_Body,\n+                       E_Task_Type)\n+           or else\n+         Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -6186,17 +6206,19 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind_In (Id, E_Protected_Body,   --  synchronized variants\n-                       E_Protected_Type,\n-                       E_Task_Body,\n-                       E_Task_Type));\n+         Ekind (Id) = E_Variable);         --  variable\n       Set_Node40 (Id, V);\n    end Set_SPARK_Pragma;\n \n    procedure Set_SPARK_Pragma_Inherited (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Entry,            --  overloadable variants\n+        (Ekind_In (Id, E_Protected_Body,   --  concurrent variants\n+                       E_Protected_Type,\n+                       E_Task_Body,\n+                       E_Task_Type)\n+           or else\n+         Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n                        E_Function,\n                        E_Generic_Function,\n@@ -6209,10 +6231,7 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind_In (Id, E_Protected_Body,   --  synchronized variants\n-                       E_Protected_Type,\n-                       E_Task_Body,\n-                       E_Task_Type));\n+         Ekind (Id) = E_Variable);         --  variable\n       Set_Flag265 (Id, V);\n    end Set_SPARK_Pragma_Inherited;\n \n@@ -7744,6 +7763,17 @@ package body Einfo is\n       end if;\n    end Is_Synchronized_Interface;\n \n+   ---------------------------\n+   -- Is_Synchronized_State --\n+   ---------------------------\n+\n+   function Is_Synchronized_State (Id : E) return B is\n+   begin\n+      return\n+        Ekind (Id) = E_Abstract_State\n+          and then Has_Option (Id, Name_Synchronous);\n+   end Is_Synchronized_State;\n+\n    -----------------------\n    -- Is_Task_Interface --\n    -----------------------\n@@ -9249,9 +9279,6 @@ package body Einfo is\n          when Object_Kind                                  =>\n             Write_Str (\"Current_Value\");\n \n-         when E_Abstract_State                             =>\n-            Write_Str (\"Part_Of_Constituents\");\n-\n          when E_Function                                   |\n               E_Generic_Function                           |\n               E_Generic_Package                            |\n@@ -9297,6 +9324,10 @@ package body Einfo is\n               E_Discriminant                               =>\n             Write_Str (\"Normalized_Position_Max\");\n \n+         when E_Abstract_State                             |\n+              E_Variable                                   =>\n+            Write_Str (\"Part_Of_Constituents\");\n+\n          when others                                       =>\n             Write_Str (\"Field10??\");\n       end case;\n@@ -10134,6 +10165,10 @@ package body Einfo is\n    procedure Write_Field30_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Protected_Type                             |\n+              E_Task_Type                                  =>\n+            Write_Str (\"Anonymous_Object\");\n+\n          when E_Function                                   =>\n             Write_Str (\"Corresponding_Equality\");\n \n@@ -10232,6 +10267,7 @@ package body Einfo is\n               E_Package                                    |\n               E_Package_Body                               |\n               E_Procedure                                  |\n+              E_Protected_Type                             |\n               E_Subprogram_Body                            |\n               E_Task_Body                                  |\n               E_Task_Type                                  |\n@@ -10342,7 +10378,8 @@ package body Einfo is\n               E_Protected_Type                             |\n               E_Subprogram_Body                            |\n               E_Task_Body                                  |\n-              E_Task_Type                                  =>\n+              E_Task_Type                                  |\n+              E_Variable                                   =>\n             Write_Str (\"SPARK_Pragma\");\n \n          when others                                       =>"}, {"sha": "8b91ee4ad8fe1a50a28a4281dac48cac8a2d8440", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -444,6 +444,10 @@ package Einfo is\n --       finalization master that services most anonymous access-to-controlled\n --       allocations that occur within the unit.\n \n+--    Anonymous_Object (Node30)\n+--       Present in protected and task type entities. Contains the entity of\n+--       the anonymous object created for a single protected or task type.\n+\n --    Associated_Entity (Node37)\n --       Defined in all entities. This field is similar to Associated_Node, but\n --       applied to entities. The attribute links an entity from the generic\n@@ -706,9 +710,9 @@ package Einfo is\n \n --    Contract (Node34)\n --       Defined in constant, entry, entry family, operator, [generic] package,\n---       package body, [generic] subprogram, subprogram body, variable and task\n---       type entities. Points to the contract of the entity, holding various\n---       assertion items and data classifiers.\n+--       package body, protected type, [generic] subprogram, subprogram body,\n+--       variable and task type entities. Points to the contract of the entity,\n+--       holding various assertion items and data classifiers.\n \n --    Corresponding_Concurrent_Type (Node18)\n --       Defined in record types that are constructed by the expander to\n@@ -1074,9 +1078,9 @@ package Einfo is\n --       need to set the flag.\n \n --    Encapsulating_State (Node32)\n---       Defined in abstract states, constants and variables. Contains the\n---       entity of an ancestor state whose refinement utilizes this item as\n---       a constituent.\n+--       Defined in abstract state, constant and variable entities. Contains\n+--       the entity of an ancestor state or a single concurrent type whose\n+--       refinement utilizes this item as a constituent.\n \n --    Enclosing_Scope (Node18)\n --       Defined in labels. Denotes the innermost enclosing construct that\n@@ -3080,6 +3084,10 @@ package Einfo is\n --       synchronized, task, or protected, or is derived from a synchronized\n --       interface.\n \n+--    Is_Synchronized_State (synthesized)\n+--       Applies to all entities, true for abstract states that are subject to\n+--       option Synchronous.\n+\n --    Is_Tag (Flag78)\n --       Defined in E_Component and E_Constant entities. For regular tagged\n --       type this flag is set on the tag component (whose name is Name_uTag).\n@@ -3675,9 +3683,10 @@ package Einfo is\n --       case it points to the subtype of the parent type. This is the type\n --       that is used as the Etype of the _parent field.\n \n---    Part_Of_Constituents (Elist9)\n---       Present in abstract state entities. Contains all constituents that are\n---       subject to indicator Part_Of (both aspect and option variants).\n+--    Part_Of_Constituents (Elist10)\n+--       Present in abstract state and variable entities. Contains all\n+--       constituents that are subject to indicator Part_Of (both aspect and\n+--       option variants).\n \n --    Partial_View_Has_Unknown_Discr (Flag280)\n --       Present in all types. Set to Indicate that the partial view of a type\n@@ -4064,36 +4073,36 @@ package Einfo is\n --       as computed (as a power of two) by the compiler.\n \n --    SPARK_Aux_Pragma (Node41)\n---       Present in [generic] package specs, package bodies and synchronized\n---       types. For package specs and synchronized types it refers to the SPARK\n---       mode setting for the private part. This field points to the N_Pragma\n---       node that either appears in the private part or is inherited from the\n---       enclosing context. For package bodies, it refers to the SPARK mode of\n---       the elaboration sequence after the BEGIN. The fields points to the\n---       N_Pragma node that either appears in the statement sequence or is\n+--       Present in concurrent type, [generic] package spec and package body\n+--       entities. For concurrent types and package specs it refers to the\n+--       SPARK mode setting for the private part. This field points to the\n+--       N_Pragma node that either appears in the private part or is inherited\n+--       from the enclosing context. For package bodies, it refers to the SPARK\n+--       mode of the elaboration sequence after the BEGIN. The fields points to\n+--       the N_Pragma node that either appears in the statement sequence or is\n --       inherited from the enclosing context. In all cases, if the pragma is\n --       inherited, then the SPARK_Aux_Pragma_Inherited flag is set.\n \n --    SPARK_Aux_Pragma_Inherited (Flag266)\n---       Present in [generic] package specs, package bodies and synchronized\n---       types. Set if the SPARK_Aux_Pragma field points to a pragma that is\n+--       Present in concurrent type, [generic] package spec and package body\n+--       entities. Set if the SPARK_Aux_Pragma field points to a pragma that is\n --       inherited, rather than a local one.\n \n --    SPARK_Pragma (Node40)\n---       Present in entries, operators, [generic] packages, package bodies,\n---       [generic] subprograms, subprogram bodies and synchronized types.\n---       Points to the N_Pragma node that applies to the spec or body. This\n---       is either set by a local SPARK_Mode pragma or is inherited from the\n---       context (from an outer scope for the spec case or from the spec for\n---       the body case). In the case where it is inherited the flag\n---       SPARK_Pragma_Inherited is set. Empty if no SPARK_Mode pragma is\n---       applicable.\n+--       Present in concurrent type, entry, operator, [generic] package,\n+--       package body, [generic] subprogram, subprogram body and variable\n+--       entities. Points to the N_Pragma node that applies to the initial\n+--       declaration or body. This is either set by a local SPARK_Mode pragma\n+--       or is inherited from the context (from an outer scope for the spec\n+--       case or from the spec for the body case). In the case where it is\n+--       inherited the flag SPARK_Pragma_Inherited is set. Empty if no\n+--       SPARK_Mode pragma is applicable.\n \n --    SPARK_Pragma_Inherited (Flag265)\n---       Present in entries, operators, [generic] packages, package bodies,\n---       [generic] subprograms, subprogram bodies and synchronized types. Set\n---       if the SPARK_Pragma attribute points to a pragma that is inherited,\n---       rather than a local one.\n+--       Present in concurrent type, entry, operator, [generic] package,\n+--       package body, [generic] subprogram, subprogram body and variable\n+--       entities. Set if the SPARK_Pragma attribute points to a pragma that is\n+--       inherited, rather than a local one.\n \n --    Spec_Entity (Node19)\n --       Defined in package body entities. Points to corresponding package\n@@ -5507,7 +5516,7 @@ package Einfo is\n \n    --  E_Abstract_State\n    --    Refinement_Constituents             (Elist8)\n-   --    Part_Of_Constituents                (Elist9)\n+   --    Part_Of_Constituents                (Elist10)\n    --    Body_References                     (Elist16)\n    --    Non_Limited_View                    (Node19)\n    --    Encapsulating_State                 (Node32)\n@@ -5518,6 +5527,7 @@ package Einfo is\n    --    Has_Null_Refinement                 (synth)\n    --    Is_External_State                   (synth)\n    --    Is_Null_State                       (synth)\n+   --    Is_Synchronized_State               (synth)\n \n    --  E_Access_Protected_Subprogram_Type\n    --    Equivalent_Type                     (Node18)\n@@ -6248,6 +6258,8 @@ package Einfo is\n    --    Discriminant_Constraint             (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Stored_Constraint                   (Elist23)\n+   --    Anonymous_Object                    (Node30)\n+   --    Contract                            (Node34)\n    --    SPARK_Pragma                        (Node40)\n    --    SPARK_Aux_Pragma                    (Node41)\n    --    Sec_Stack_Needed_For_Return         (Flag167)  ???\n@@ -6261,6 +6273,7 @@ package Einfo is\n    --    Has_Interrupt_Handler               (synth)\n    --    Number_Entries                      (synth)\n    --    Scope_Depth                         (synth)\n+   --    (plus type attributes)\n \n    --  E_Record_Type\n    --  E_Record_Subtype\n@@ -6389,11 +6402,11 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Discriminant_Constraint             (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n-   --    Scope_Depth                         (synth)\n    --    Stored_Constraint                   (Elist23)\n    --    Task_Body_Procedure                 (Node25)\n    --    Storage_Size_Variable               (Node26)   (base type only)\n    --    Relative_Deadline_Variable          (Node28)   (base type only)\n+   --    Anonymous_Object                    (Node30)\n    --    Contract                            (Node34)\n    --    SPARK_Pragma                        (Node40)\n    --    SPARK_Aux_Pragma                    (Node41)\n@@ -6408,11 +6421,13 @@ package Einfo is\n    --    First_Component_Or_Discriminant     (synth)\n    --    Has_Entries                         (synth)\n    --    Number_Entries                      (synth)\n+   --    Scope_Depth                         (synth)\n    --    (plus type attributes)\n \n    --  E_Variable\n    --    Hiding_Loop_Variable                (Node8)\n    --    Current_Value                       (Node9)\n+   --    Part_Of_Constituents                (Elist10)\n    --    Esize                               (Uint12)\n    --    Extra_Accessibility                 (Node13)\n    --    Alignment                           (Uint14)\n@@ -6436,6 +6451,7 @@ package Einfo is\n    --    Encapsulating_State                 (Node32)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n+   --    SPARK_Pragma                        (Node40)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n@@ -6457,6 +6473,7 @@ package Einfo is\n    --    OK_To_Rename                        (Flag247)\n    --    Optimize_Alignment_Space            (Flag241)\n    --    Optimize_Alignment_Time             (Flag242)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Suppress_Initialization             (Flag105)\n    --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n@@ -6707,6 +6724,7 @@ package Einfo is\n    function Alias                               (Id : E) return E;\n    function Alignment                           (Id : E) return U;\n    function Anonymous_Master                    (Id : E) return E;\n+   function Anonymous_Object                    (Id : E) return E;\n    function Associated_Entity                   (Id : E) return E;\n    function Associated_Formal_Package           (Id : E) return E;\n    function Associated_Node_For_Itype           (Id : E) return N;\n@@ -7258,6 +7276,7 @@ package Einfo is\n    function Is_Standard_String_Type             (Id : E) return B;\n    function Is_String_Type                      (Id : E) return B;\n    function Is_Synchronized_Interface           (Id : E) return B;\n+   function Is_Synchronized_State               (Id : E) return B;\n    function Is_Task_Interface                   (Id : E) return B;\n    function Is_Task_Record_Type                 (Id : E) return B;\n    function Is_Wrapper_Package                  (Id : E) return B;\n@@ -7369,6 +7388,7 @@ package Einfo is\n    procedure Set_Alias                           (Id : E; V : E);\n    procedure Set_Alignment                       (Id : E; V : U);\n    procedure Set_Anonymous_Master                (Id : E; V : E);\n+   procedure Set_Anonymous_Object                (Id : E; V : E);\n    procedure Set_Associated_Entity               (Id : E; V : E);\n    procedure Set_Associated_Formal_Package       (Id : E; V : E);\n    procedure Set_Associated_Node_For_Itype       (Id : E; V : N);\n@@ -8148,6 +8168,7 @@ package Einfo is\n    pragma Inline (Alias);\n    pragma Inline (Alignment);\n    pragma Inline (Anonymous_Master);\n+   pragma Inline (Anonymous_Object);\n    pragma Inline (Associated_Entity);\n    pragma Inline (Associated_Formal_Package);\n    pragma Inline (Associated_Node_For_Itype);\n@@ -8655,6 +8676,7 @@ package Einfo is\n    pragma Inline (Set_Alias);\n    pragma Inline (Set_Alignment);\n    pragma Inline (Set_Anonymous_Master);\n+   pragma Inline (Set_Anonymous_Object);\n    pragma Inline (Set_Associated_Entity);\n    pragma Inline (Set_Associated_Formal_Package);\n    pragma Inline (Set_Associated_Node_For_Itype);"}, {"sha": "f95841e9f68095bd1fcd658637e8eb9a16a1c242", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -3291,7 +3291,7 @@ package body Exp_Ch6 is\n \n                if Subp = Eq_Prim_Op then\n \n-                  --  Mark the node as analyzed to avoid reanalizing this\n+                  --  Mark the node as analyzed to avoid reanalyzing this\n                   --  dispatching call (which would cause a never-ending loop)\n \n                   Prev_Call := Relocate_Node (Call_Node);"}, {"sha": "f4db92fb5c63fb954a1d49911559cc725c7ca6c6", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -1285,7 +1285,7 @@ package body Exp_Ch7 is\n             Prepend_To (Decls, Counter_Decl);\n             Prepend_To (Decls, Counter_Typ_Decl);\n \n-            --  The counter and its associated type must be manually analized\n+            --  The counter and its associated type must be manually analyzed\n             --  since N has already been analyzed. Use the scope of the spec\n             --  when inserting in a package.\n "}, {"sha": "e09fbd20239ceea3393068dbb3321fdf253d9d2d", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -4322,6 +4322,25 @@ package body Freeze is\n                   Next_Component (Comp);\n                end loop;\n             end if;\n+\n+            --  A type which does not yield a synchronized object cannot have\n+            --  a component that yields a synchronized object (SPARK RM 9.5).\n+\n+            if not Yields_Synchronized_Object (Rec) then\n+               Comp := First_Component (Rec);\n+               while Present (Comp) loop\n+                  if Comes_From_Source (Comp)\n+                    and then Yields_Synchronized_Object (Etype (Comp))\n+                  then\n+                     Error_Msg_Name_1 := Chars (Rec);\n+                     Error_Msg_N\n+                       (\"component & of non-synchronized type % cannot be \"\n+                        & \"synchronized\", Comp);\n+                  end if;\n+\n+                  Next_Component (Comp);\n+               end loop;\n+            end if;\n          end if;\n \n          --  Make sure that if we have an iterator aspect, then we have"}, {"sha": "d02d8e5bbfb3663fa101c78b91ab4e27a28b5fe4", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -1254,6 +1254,7 @@ package body Sem_Ch13 is\n          Aux   : Node_Id;\n          Decl  : Node_Id;\n          Decls : List_Id;\n+         Def   : Node_Id;\n \n       begin\n          --  When the aspect appears on a package, protected unit, subprogram\n@@ -1370,32 +1371,52 @@ package body Sem_Ch13 is\n          --       pragma Prag;\n \n          elsif Nkind (N) = N_Protected_Type_Declaration then\n-            Decls := Visible_Declarations (Protected_Definition (N));\n+            Def := Protected_Definition (N);\n+\n+            if No (Def) then\n+               Def :=\n+                 Make_Protected_Definition (Sloc (N),\n+                   Visible_Declarations => New_List,\n+                   End_Label            => Empty);\n+\n+               Set_Protected_Definition (N, Def);\n+            end if;\n+\n+            Decls := Visible_Declarations (Def);\n \n             if No (Decls) then\n                Decls := New_List;\n-               Set_Visible_Declarations (Protected_Definition (N), Decls);\n+               Set_Visible_Declarations (Def, Decls);\n             end if;\n \n             Prepend_To (Decls, Prag);\n \n-         --  When the aspect is associated with a task unit declaration with a\n-         --  definition, insert the generated pragma at the top of the visible\n-         --  declarations the emulate the behavior of a source pragma.\n+         --  When the aspect is associated with a task unit declaration, insert\n+         --  insert the generated pragma at the top of the visible declarations\n+         --  the emulate the behavior of a source pragma.\n \n          --    task [type] Prot with Aspect is\n \n          --    task [type] Prot is\n          --       pragma Prag;\n \n-         elsif Nkind (N) = N_Task_Type_Declaration\n-           and then Present (Task_Definition (N))\n-         then\n-            Decls := Visible_Declarations (Task_Definition (N));\n+         elsif Nkind (N) = N_Task_Type_Declaration then\n+            Def := Task_Definition (N);\n+\n+            if No (Def) then\n+               Def :=\n+                 Make_Task_Definition (Sloc (N),\n+                   Visible_Declarations => New_List,\n+                   End_Label            => Empty);\n+\n+               Set_Task_Definition (N, Def);\n+            end if;\n+\n+            Decls := Visible_Declarations (Def);\n \n             if No (Decls) then\n                Decls := New_List;\n-               Set_Visible_Declarations (Task_Definition (N), Decls);\n+               Set_Visible_Declarations (Def, Decls);\n             end if;\n \n             Prepend_To (Decls, Prag);\n@@ -2626,17 +2647,23 @@ package body Sem_Ch13 is\n                when Aspect_Part_Of =>\n                   if Nkind_In (N, N_Object_Declaration,\n                                   N_Package_Instantiation)\n+                    or else Is_Single_Concurrent_Type_Declaration (N)\n                   then\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Part_Of);\n \n+                     Decorate (Aspect, Aitem);\n+                     Insert_Pragma (Aitem);\n+                     goto Continue;\n+\n                   else\n                      Error_Msg_NE\n-                       (\"aspect & must apply to a variable or package \"\n-                        & \"instantiation\", Aspect, Id);\n+                       (\"aspect & must apply to package instantiation, \"\n+                        & \"object, single protected type or single task type\",\n+                        Aspect, Id);\n                   end if;\n \n                --  SPARK_Mode"}, {"sha": "881921d5d69dc86ce08ab06813fcde10cfc338b6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -2495,29 +2495,46 @@ package body Sem_Ch3 is\n             Analyze_Package_Body_Contract (Defining_Entity (Context));\n          end if;\n \n-         --  Analyze the contracts of all subprogram declarations, subprogram\n-         --  bodies and variables due to the delayed visibility needs of their\n-         --  aspects and pragmas.\n+         --  Analyze the contracts of eligible constructs (see below) due to\n+         --  the delayed visibility needs of their aspects and pragmas.\n \n          Decl := First (L);\n          while Present (Decl) loop\n-            if Nkind (Decl) = N_Object_Declaration then\n-               Analyze_Object_Contract (Defining_Entity (Decl));\n \n-            elsif Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n-                                  N_Entry_Declaration,\n-                                  N_Generic_Subprogram_Declaration,\n-                                  N_Subprogram_Declaration)\n+            --  Entry or subprogram declarations\n+\n+            if Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n+                               N_Entry_Declaration,\n+                               N_Generic_Subprogram_Declaration,\n+                               N_Subprogram_Declaration)\n             then\n                Analyze_Entry_Or_Subprogram_Contract (Defining_Entity (Decl));\n \n+            --  Entry or subprogram bodies\n+\n             elsif Nkind_In (Decl, N_Entry_Body, N_Subprogram_Body) then\n                Analyze_Entry_Or_Subprogram_Body_Contract\n                  (Defining_Entity (Decl));\n \n+            --  Objects\n+\n+            elsif Nkind (Decl) = N_Object_Declaration then\n+               Analyze_Object_Contract (Defining_Entity (Decl));\n+\n+            --  Protected untis\n+\n+            elsif Nkind_In (Decl, N_Protected_Type_Declaration,\n+                                  N_Single_Protected_Declaration)\n+            then\n+               Analyze_Protected_Contract (Defining_Entity (Decl));\n+\n+            --  Subprogram body stubs\n+\n             elsif Nkind (Decl) = N_Subprogram_Body_Stub then\n                Analyze_Subprogram_Body_Stub_Contract (Defining_Entity (Decl));\n \n+            --  Task units\n+\n             elsif Nkind_In (Decl, N_Single_Task_Declaration,\n                                   N_Task_Type_Declaration)\n             then"}, {"sha": "f3235dd52e4dde828be9689f4a04009dda502b74", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 140, "deletions": 79, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -50,6 +50,7 @@ with Sem_Ch6;   use Sem_Ch6;\n with Sem_Ch8;   use Sem_Ch8;\n with Sem_Ch13;  use Sem_Ch13;\n with Sem_Eval;  use Sem_Eval;\n+with Sem_Prag;  use Sem_Prag;\n with Sem_Res;   use Sem_Res;\n with Sem_Type;  use Sem_Type;\n with Sem_Util;  use Sem_Util;\n@@ -2112,20 +2113,23 @@ package body Sem_Ch9 is\n                  or else From_Aspect_Specification (Prio_Item)\n                then\n                   Error_Msg_Name_1 := Chars (Identifier (Prio_Item));\n-                  Error_Msg_NE (\"aspect% for & has no effect when Lock_Free\" &\n-                                \" given??\", Prio_Item, Id);\n+                  Error_Msg_NE\n+                    (\"aspect% for & has no effect when Lock_Free given??\",\n+                     Prio_Item, Id);\n \n                --  Pragma case\n \n                else\n                   Error_Msg_Name_1 := Pragma_Name (Prio_Item);\n-                  Error_Msg_NE (\"pragma% for & has no effect when Lock_Free\" &\n-                                \" given??\", Prio_Item, Id);\n+                  Error_Msg_NE\n+                    (\"pragma% for & has no effect when Lock_Free given??\",\n+                     Prio_Item, Id);\n                end if;\n             end if;\n          end;\n \n-         if not Allows_Lock_Free_Implementation (N, True) then\n+         if not Allows_Lock_Free_Implementation (N, Lock_Free_Given => True)\n+         then\n             return;\n          end if;\n       end if;\n@@ -2149,16 +2153,18 @@ package body Sem_Ch9 is\n                     or else From_Aspect_Specification (Prio_Item))\n                  and then Chars (Identifier (Prio_Item)) = Name_Priority\n                then\n-                  Error_Msg_N (\"aspect Interrupt_Priority is preferred \"\n-                               & \"in presence of handlers??\", Prio_Item);\n+                  Error_Msg_N\n+                    (\"aspect Interrupt_Priority is preferred in presence of \"\n+                     & \"handlers??\", Prio_Item);\n \n                --  Pragma case\n \n                elsif Nkind (Prio_Item) = N_Pragma\n                  and then Pragma_Name (Prio_Item) = Name_Priority\n                then\n-                  Error_Msg_N (\"pragma Interrupt_Priority is preferred \"\n-                               & \"in presence of handlers??\", Prio_Item);\n+                  Error_Msg_N\n+                    (\"pragma Interrupt_Priority is preferred in presence of \"\n+                     & \"handlers??\", Prio_Item);\n                end if;\n             end if;\n          end;\n@@ -2612,49 +2618,80 @@ package body Sem_Ch9 is\n    ------------------------------------------\n \n    procedure Analyze_Single_Protected_Declaration (N : Node_Id) is\n-      Loc    : constant Source_Ptr := Sloc (N);\n-      Id     : constant Node_Id    := Defining_Identifier (N);\n-      T      : Entity_Id;\n-      T_Decl : Node_Id;\n-      O_Decl : Node_Id;\n-      O_Name : constant Entity_Id := Id;\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Obj_Id   : constant Node_Id    := Defining_Identifier (N);\n+      Obj_Decl : Node_Id;\n+      Typ      : Entity_Id;\n \n    begin\n-      Generate_Definition (Id);\n+      Generate_Definition (Obj_Id);\n       Tasking_Used := True;\n \n-      --  The node is rewritten as a protected type declaration, in exact\n-      --  analogy with what is done with single tasks.\n+      --  A single protected declaration is transformed into a pair of an\n+      --  anonymous protected type and an object of that type. Generate:\n \n-      T :=\n-        Make_Defining_Identifier (Sloc (Id),\n-          New_External_Name (Chars (Id), 'T'));\n+      --    protected type Typ is ...;\n \n-      T_Decl :=\n+      Typ :=\n+        Make_Defining_Identifier (Sloc (Obj_Id),\n+          Chars => New_External_Name (Chars (Obj_Id), 'T'));\n+\n+      Rewrite (N,\n         Make_Protected_Type_Declaration (Loc,\n-         Defining_Identifier => T,\n+         Defining_Identifier => Typ,\n          Protected_Definition => Relocate_Node (Protected_Definition (N)),\n-         Interface_List       => Interface_List (N));\n+         Interface_List       => Interface_List (N)));\n+\n+      --  Use the original defining identifier of the single protected\n+      --  declaration in the generated object declaration to allow for debug\n+      --  information to be attached to it when compiling with -gnatD. The\n+      --  parent of the entity is the new object declaration. The single\n+      --  protected declaration is not used in semantics or code generation,\n+      --  but is scanned when generating debug information, and therefore needs\n+      --  the updated Sloc information from the entity (see Sprint). Generate:\n \n-      O_Decl :=\n+      --    Obj : Typ;\n+\n+      Obj_Decl :=\n         Make_Object_Declaration (Loc,\n-          Defining_Identifier => O_Name,\n-          Object_Definition   => Make_Identifier (Loc,  Chars (T)));\n+          Defining_Identifier => Obj_Id,\n+          Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+      --  Relocate the aspects that appear on the original single protected\n+      --  declaration to the object as the object is the visible name.\n+\n+      Set_Comes_From_Source (Obj_Decl, True);\n+\n+      Insert_After (N, Obj_Decl);\n+      Mark_Rewrite_Insertion (Obj_Decl);\n+\n+      --  Relocate aspect Part_Of from the the original single protected\n+      --  declaration to the anonymous object declaration. This emulates the\n+      --  placement of an equivalent source pragma.\n \n-      Rewrite (N, T_Decl);\n-      Insert_After (N, O_Decl);\n-      Mark_Rewrite_Insertion (O_Decl);\n+      Move_Or_Merge_Aspects (N, To => Obj_Decl);\n \n-      --  Enter names of type and object before analysis, because the name of\n-      --  the object may be used in its own body.\n+      --  Relocate pragma Part_Of from the visible declarations of the original\n+      --  single protected declaration to the anonymous object declaration. The\n+      --  new placement better reflects the role of the pragma.\n \n-      Enter_Name (T);\n-      Set_Ekind (T, E_Protected_Type);\n-      Set_Etype (T, T);\n+      Relocate_Pragmas_To_Anonymous_Object (N, Obj_Decl);\n \n-      Enter_Name (O_Name);\n-      Set_Ekind (O_Name, E_Variable);\n-      Set_Etype (O_Name, T);\n+      --  Enter the names of the anonymous protected type and the object before\n+      --  analysis takes places, because the name of the object may be used in\n+      --  its own body.\n+\n+      Enter_Name (Typ);\n+      Set_Ekind            (Typ, E_Protected_Type);\n+      Set_Etype            (Typ, Typ);\n+      Set_Anonymous_Object (Typ, Obj_Id);\n+\n+      Enter_Name (Obj_Id);\n+      Set_Ekind                  (Obj_Id, E_Variable);\n+      Set_Etype                  (Obj_Id, Typ);\n+      Set_Part_Of_Constituents   (Obj_Id, New_Elmt_List);\n+      Set_SPARK_Pragma           (Obj_Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Obj_Id);\n \n       --  Instead of calling Analyze on the new node, call the proper analysis\n       --  procedure directly. Otherwise the node would be expanded twice, with\n@@ -2663,7 +2700,7 @@ package body Sem_Ch9 is\n       Analyze_Protected_Type_Declaration (N);\n \n       if Has_Aspects (N) then\n-         Analyze_Aspect_Specifications (N, Id);\n+         Analyze_Aspect_Specifications (N, Obj_Id);\n       end if;\n    end Analyze_Single_Protected_Declaration;\n \n@@ -2672,58 +2709,81 @@ package body Sem_Ch9 is\n    -------------------------------------\n \n    procedure Analyze_Single_Task_Declaration (N : Node_Id) is\n-      Loc    : constant Source_Ptr := Sloc (N);\n-      Id     : constant Node_Id    := Defining_Identifier (N);\n-      T      : Entity_Id;\n-      T_Decl : Node_Id;\n-      O_Decl : Node_Id;\n-      O_Name : constant Entity_Id := Id;\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Obj_Id   : constant Node_Id    := Defining_Identifier (N);\n+      Obj_Decl : Node_Id;\n+      Typ      : Entity_Id;\n \n    begin\n-      Generate_Definition (Id);\n+      Generate_Definition (Obj_Id);\n       Tasking_Used := True;\n \n-      --  The node is rewritten as a task type declaration, followed by an\n-      --  object declaration of that anonymous task type.\n+      --  A single task declaration is transformed into a pait of an anonymous\n+      --  task type and an object of that type. Generate:\n+\n+      --    task type Typ is ...;\n \n-      T :=\n-        Make_Defining_Identifier (Sloc (Id),\n-          New_External_Name (Chars (Id), Suffix => \"TK\"));\n+      Typ :=\n+        Make_Defining_Identifier (Sloc (Obj_Id),\n+          Chars => New_External_Name (Chars (Obj_Id), Suffix => \"TK\"));\n \n-      T_Decl :=\n+      Rewrite (N,\n         Make_Task_Type_Declaration (Loc,\n-          Defining_Identifier => T,\n+          Defining_Identifier => Typ,\n           Task_Definition     => Relocate_Node (Task_Definition (N)),\n-          Interface_List      => Interface_List (N));\n-\n-      --  We use the original defining identifier of the single task in the\n-      --  generated object declaration, so that debugging information can\n-      --  be attached to it when compiling with -gnatD. The parent of the\n-      --  entity is the new object declaration. The single_task_declaration\n-      --  is not used further in semantics or code generation, but is scanned\n-      --  when generating debug information, and therefore needs the updated\n-      --  Sloc information for the entity (see Sprint). Aspect specifications\n-      --  are moved from the single task node to the object declaration node.\n-\n-      O_Decl :=\n+          Interface_List      => Interface_List (N)));\n+\n+      --  Use the original defining identifier of the single task declaration\n+      --  in the generated object declaration to allow for debug information\n+      --  to be attached to it when compiling with -gnatD. The parent of the\n+      --  entity is the new object declaration. The single task declaration\n+      --  is not used in semantics or code generation, but is scanned when\n+      --  generating debug information, and therefore needs the updated Sloc\n+      --  information from the entity (see Sprint). Generate:\n+\n+      --    Obj : Typ;\n+\n+      Obj_Decl :=\n         Make_Object_Declaration (Loc,\n-          Defining_Identifier => O_Name,\n-          Object_Definition   => Make_Identifier (Loc, Chars (T)));\n+          Defining_Identifier => Obj_Id,\n+          Object_Definition   => New_Occurrence_Of (Typ, Loc));\n \n-      Rewrite (N, T_Decl);\n-      Insert_After (N, O_Decl);\n-      Mark_Rewrite_Insertion (O_Decl);\n+      --  Relocate the aspects that appear on the original single protected\n+      --  declaration to the object as the object is the visible name.\n \n-      --  Enter names of type and object before analysis, because the name of\n-      --  the object may be used in its own body.\n+      Set_Comes_From_Source (Obj_Decl, True);\n \n-      Enter_Name (T);\n-      Set_Ekind (T, E_Task_Type);\n-      Set_Etype (T, T);\n+      Insert_After (N, Obj_Decl);\n+      Mark_Rewrite_Insertion (Obj_Decl);\n \n-      Enter_Name (O_Name);\n-      Set_Ekind (O_Name, E_Variable);\n-      Set_Etype (O_Name, T);\n+      --  Relocate aspects Depends, Global and Part_Of from the original single\n+      --  task declaration to the anonymous object declaration. This emulates\n+      --  the placement of an equivalent source pragma.\n+\n+      Move_Or_Merge_Aspects (N, To => Obj_Decl);\n+\n+      --  Relocate pragmas Depends, Global and Part_Of from the visible\n+      --  declarations of the original single protected declaration to the\n+      --  anonymous object declaration. The new placement better reflects the\n+      --  role of the pragmas.\n+\n+      Relocate_Pragmas_To_Anonymous_Object (N, Obj_Decl);\n+\n+      --  Enter the names of the anonymous task type and the object before\n+      --  analysis takes places, because the name of the object may be used\n+      --  in its own body.\n+\n+      Enter_Name (Typ);\n+      Set_Ekind            (Typ, E_Task_Type);\n+      Set_Etype            (Typ, Typ);\n+      Set_Anonymous_Object (Typ, Obj_Id);\n+\n+      Enter_Name (Obj_Id);\n+      Set_Ekind                  (Obj_Id, E_Variable);\n+      Set_Etype                  (Obj_Id, Typ);\n+      Set_Part_Of_Constituents   (Obj_Id, New_Elmt_List);\n+      Set_SPARK_Pragma           (Obj_Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Obj_Id);\n \n       --  Instead of calling Analyze on the new node, call the proper analysis\n       --  procedure directly. Otherwise the node would be expanded twice, with\n@@ -2732,7 +2792,7 @@ package body Sem_Ch9 is\n       Analyze_Task_Type_Declaration (N);\n \n       if Has_Aspects (N) then\n-         Analyze_Aspect_Specifications (N, Id);\n+         Analyze_Aspect_Specifications (N, Obj_Id);\n       end if;\n    end Analyze_Single_Task_Declaration;\n \n@@ -3499,4 +3559,5 @@ package body Sem_Ch9 is\n          Next_Entity (E);\n       end loop;\n    end Install_Declarations;\n+\n end Sem_Ch9;"}, {"sha": "7f3b42a8530f678da2d79122fd2671a6b0c6b7bb", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -567,16 +567,39 @@ package body Sem_Elab is\n \n       --  Local variables\n \n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Ent  : Entity_Id;\n-      Decl : Node_Id;\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Inst_Case : constant Boolean := Nkind (N) in N_Generic_Instantiation;\n+      --  Indicates if we have instantiation case\n+\n+      Ent                  : Entity_Id;\n+      Callee_Unit_Internal : Boolean;\n+      Caller_Unit_Internal : Boolean;\n+      Decl                 : Node_Id;\n+      Inst_Callee          : Source_Ptr;\n+      Inst_Caller          : Source_Ptr;\n+      Unit_Callee          : Unit_Number_Type;\n+      Unit_Caller          : Unit_Number_Type;\n+\n+      Body_Acts_As_Spec : Boolean;\n+      --  Set to true if call is to body acting as spec (no separate spec)\n+\n+      Cunit_SC : Boolean := False;\n+      --  Set to suppress dynamic elaboration checks where one of the\n+      --  enclosing scopes has Elaboration_Checks_Suppressed set, or else\n+      --  if a pragma Elaborate[_All] applies to that scope, in which case\n+      --  warnings on the scope are also suppressed. For the internal case,\n+      --  we ignore this flag.\n \n       E_Scope : Entity_Id;\n       --  Top level scope of entity for called subprogram. This value includes\n       --  following renamings and derivations, so this scope can be in a\n       --  non-visible unit. This is the scope that is to be investigated to\n       --  see whether an elaboration check is required.\n \n+      Issue_In_SPARK : Boolean;\n+      --  Flag set when a source entity is called during elaboration in SPARK\n+\n       W_Scope : Entity_Id;\n       --  Top level scope of directly called entity for subprogram. This\n       --  differs from E_Scope in the case where renamings or derivations\n@@ -589,28 +612,6 @@ package body Sem_Elab is\n       --  on this intermediate package. These special cases are handled in\n       --  Set_Elaboration_Constraint.\n \n-      Body_Acts_As_Spec : Boolean;\n-      --  Set to true if call is to body acting as spec (no separate spec)\n-\n-      Inst_Case : constant Boolean := Nkind (N) in N_Generic_Instantiation;\n-      --  Indicates if we have instantiation case\n-\n-      Caller_Unit_Internal : Boolean;\n-      Callee_Unit_Internal : Boolean;\n-\n-      Inst_Caller : Source_Ptr;\n-      Inst_Callee : Source_Ptr;\n-\n-      Unit_Caller : Unit_Number_Type;\n-      Unit_Callee : Unit_Number_Type;\n-\n-      Cunit_SC : Boolean := False;\n-      --  Set to suppress dynamic elaboration checks where one of the\n-      --  enclosing scopes has Elaboration_Checks_Suppressed set, or else\n-      --  if a pragma Elaborate[_All] applies to that scope, in which case\n-      --  warnings on the scope are also suppressed. For the internal case,\n-      --  we ignore this flag.\n-\n    --  Start of processing for Check_A_Call\n \n    begin\n@@ -752,9 +753,7 @@ package body Sem_Elab is\n       declare\n          Ent : constant Entity_Id := Get_Referenced_Ent (N);\n       begin\n-         if Is_Init_Proc (Ent)\n-           and then not In_Same_Extended_Unit (N, Ent)\n-         then\n+         if Is_Init_Proc (Ent) and then not In_Same_Extended_Unit (N, Ent) then\n             W_Scope := Scope (Ent);\n          else\n             W_Scope := E;\n@@ -967,6 +966,8 @@ package body Sem_Elab is\n          return;\n       end if;\n \n+      Issue_In_SPARK := SPARK_Mode = On and Comes_From_Source (Ent);\n+\n       --  Now check if an Elaborate_All (or dynamic check) is needed\n \n       if not Suppress_Elaboration_Warnings (Ent)\n@@ -980,10 +981,9 @@ package body Sem_Elab is\n          --  Instantiation case\n \n          if Inst_Case then\n-            if SPARK_Mode = On then\n+            if Issue_In_SPARK then\n                Error_Msg_NE\n                  (\"instantiation of & during elaboration in SPARK\", N, Ent);\n-\n             else\n                Elab_Warning\n                  (\"instantiation of & may raise Program_Error?l?\",\n@@ -999,7 +999,7 @@ package body Sem_Elab is\n \n          --  Variable reference in SPARK mode\n \n-         elsif Variable_Case then\n+         elsif Variable_Case and Issue_In_SPARK then\n             Error_Msg_NE\n               (\"reference to & during elaboration in SPARK\", N, Ent);\n \n@@ -1015,7 +1015,7 @@ package body Sem_Elab is\n                   \"info: implicit call to & during elaboration?$?\",\n                   Ent);\n \n-            elsif SPARK_Mode = On then\n+            elsif Issue_In_SPARK then\n                Error_Msg_NE (\"call to & during elaboration in SPARK\", N, Ent);\n \n             else\n@@ -1031,7 +1031,7 @@ package body Sem_Elab is\n          --  Case of Elaborate_All not present and required, for SPARK this\n          --  is an error, so give an error message.\n \n-         if SPARK_Mode = On then\n+         if Issue_In_SPARK then\n             Error_Msg_NE (\"\\Elaborate_All pragma required for&\", N, W_Scope);\n \n          --  Otherwise we generate an implicit pragma. For a subprogram"}, {"sha": "0b6e64d66a81e55409c4957cc5c16eb7114f9096", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 624, "deletions": 409, "changes": 1033, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -174,6 +174,19 @@ package body Sem_Prag is\n    --  to Uppercase or Lowercase, then a new string literal with appropriate\n    --  casing is constructed.\n \n+   procedure Analyze_Part_Of\n+     (Indic    : Node_Id;\n+      Item_Id  : Entity_Id;\n+      Encap    : Node_Id;\n+      Encap_Id : out Entity_Id;\n+      Legal    : out Boolean);\n+   --  Subsidiary to Analyze_Part_Of_In_Decl_Part, Analyze_Part_Of_Option and\n+   --  Analyze_Pragma. Perform full analysis of indicator Part_Of. Indic is the\n+   --  Part_Of indicator. Item_Id is the entity of an abstract state, object or\n+   --  package instantiation. Encap denotes the encapsulating state or single\n+   --  concurrent type. Encap_Id is the entity of Encap. Flag Legal is set when\n+   --  the indicator is legal.\n+\n    function Appears_In (List : Elist_Id; Item_Id : Entity_Id) return Boolean;\n    --  Subsidiary to analysis of pragmas Depends, Global and Refined_Depends.\n    --  Query whether a particular item appears in a mixed list of nodes and\n@@ -209,12 +222,6 @@ package body Sem_Prag is\n    --  Do_Checks is set, the routine reports duplicate pragmas. The routine\n    --  returns Empty when reaching the start of the node chain.\n \n-   function Fix_Msg (Id : Entity_Id; Msg : String) return String;\n-   --  Replace all occurrences of \"subprogram\" in string Msg with a specific\n-   --  word depending on the Ekind of Id as follows:\n-   --    * When Id is an entry [family], replace with \"entry\"\n-   --    * When Id is a task type, replace with \"task unit\"\n-\n    function Get_Base_Subprogram (Def_Id : Entity_Id) return Entity_Id;\n    --  If Def_Id refers to a renamed subprogram, then the base subprogram (the\n    --  original one, following the renaming chain) is returned. Otherwise the\n@@ -1636,11 +1643,17 @@ package body Sem_Prag is\n                Subp_Outputs => Subp_Outputs,\n                Global_Seen  => Global_Seen);\n \n+            --  When pragma [Refined_]Depends appears on a single concurrent\n+            --  type, it is relocated to the anonymous object.\n+\n+            if Is_Single_Concurrent_Object (Spec_Id) then\n+               null;\n+\n             --  Ensure that the formal parameters are visible when analyzing\n             --  all clauses. This falls out of the general rule of aspects\n             --  pertaining to subprogram declarations.\n \n-            if not In_Open_Scopes (Spec_Id) then\n+            elsif not In_Open_Scopes (Spec_Id) then\n                Restore_Scope := True;\n                Push_Scope (Spec_Id);\n \n@@ -2258,11 +2271,17 @@ package body Sem_Prag is\n       --  messages.\n \n       else\n+         --  When pragma [Refined_]Global appears on a single concurrent type,\n+         --  it is relocated to the anonymous object.\n+\n+         if Is_Single_Concurrent_Object (Spec_Id) then\n+            null;\n+\n          --  Ensure that the formal parameters are visible when processing an\n          --  item. This falls out of the general rule of aspects pertaining to\n          --  subprogram declarations.\n \n-         if not In_Open_Scopes (Spec_Id) then\n+         elsif not In_Open_Scopes (Spec_Id) then\n             Restore_Scope := True;\n             Push_Scope (Spec_Id);\n \n@@ -2709,6 +2728,287 @@ package body Sem_Prag is\n       Set_Is_Analyzed_Pragma (N);\n    end Analyze_Initializes_In_Decl_Part;\n \n+   ---------------------\n+   -- Analyze_Part_Of --\n+   ---------------------\n+\n+   procedure Analyze_Part_Of\n+     (Indic    : Node_Id;\n+      Item_Id  : Entity_Id;\n+      Encap    : Node_Id;\n+      Encap_Id : out Entity_Id;\n+      Legal    : out Boolean)\n+   is\n+      Encap_Typ   : Entity_Id;\n+      Item_Decl   : Node_Id;\n+      Pack_Id     : Entity_Id;\n+      Placement   : State_Space_Kind;\n+      Parent_Unit : Entity_Id;\n+\n+   begin\n+      --  Assume that the indicator is illegal\n+\n+      Encap_Id := Empty;\n+      Legal    := False;\n+\n+      if Nkind_In (Encap, N_Expanded_Name,\n+                          N_Identifier,\n+                          N_Selected_Component)\n+      then\n+         Analyze       (Encap);\n+         Resolve_State (Encap);\n+\n+         Encap_Id := Entity (Encap);\n+\n+         --  The encapsulator is an abstract state\n+\n+         if Ekind (Encap_Id) = E_Abstract_State then\n+            null;\n+\n+         --  The encapsulator is a single concurrent type (SPARK RM 9.3)\n+\n+         elsif Is_Single_Concurrent_Object (Encap_Id) then\n+            null;\n+\n+         --  Otherwise the encapsulator is not a legal choice\n+\n+         else\n+            SPARK_Msg_N\n+              (\"indicator Part_Of must denote abstract state, single \"\n+               & \"protected type or single task type\", Encap);\n+            return;\n+         end if;\n+\n+      --  This is a syntax error, always report\n+\n+      else\n+         Error_Msg_N\n+           (\"indicator Part_Of must denote abstract state, single protected \"\n+            & \"type or single task type\", Encap);\n+         return;\n+      end if;\n+\n+      --  Catch a case where indicator Part_Of denotes the abstract view of a\n+      --  variable which appears as an abstract state (SPARK RM 10.1.2 2).\n+\n+      if From_Limited_With (Encap_Id)\n+        and then Present (Non_Limited_View (Encap_Id))\n+        and then Ekind (Non_Limited_View (Encap_Id)) = E_Variable\n+      then\n+         SPARK_Msg_N (\"indicator Part_Of must denote abstract state\", Encap);\n+         SPARK_Msg_N (\"\\& denotes abstract view of object\", Encap);\n+         return;\n+      end if;\n+\n+      --  The encapsulator is an abstract state\n+\n+      if Ekind (Encap_Id) = E_Abstract_State then\n+\n+         --  Determine where the object, package instantiation or state lives\n+         --  with respect to the enclosing packages or package bodies.\n+\n+         Find_Placement_In_State_Space\n+           (Item_Id   => Item_Id,\n+            Placement => Placement,\n+            Pack_Id   => Pack_Id);\n+\n+         --  The item appears in a non-package construct with a declarative\n+         --  part (subprogram, block, etc). As such, the item is not allowed\n+         --  to be a part of an encapsulating state because the item is not\n+         --  visible.\n+\n+         if Placement = Not_In_Package then\n+            SPARK_Msg_N\n+              (\"indicator Part_Of cannot appear in this context \"\n+               & \"(SPARK RM 7.2.6(5))\", Indic);\n+            Error_Msg_Name_1 := Chars (Scope (Encap_Id));\n+            SPARK_Msg_NE\n+              (\"\\& is not part of the hidden state of package %\",\n+               Indic, Item_Id);\n+\n+         --  The item appears in the visible state space of some package. In\n+         --  general this scenario does not warrant Part_Of except when the\n+         --  package is a private child unit and the encapsulating state is\n+         --  declared in a parent unit or a public descendant of that parent\n+         --  unit.\n+\n+         elsif Placement = Visible_State_Space then\n+            if Is_Child_Unit (Pack_Id)\n+              and then Is_Private_Descendant (Pack_Id)\n+            then\n+               --  A variable or state abstraction which is part of the visible\n+               --  state of a private child unit (or one of its public\n+               --  descendants) must have its Part_Of indicator specified. The\n+               --  Part_Of indicator must denote a state abstraction declared\n+               --  by either the parent unit of the private unit or by a public\n+               --  descendant of that parent unit.\n+\n+               --  Find nearest private ancestor (which can be the current unit\n+               --  itself).\n+\n+               Parent_Unit := Pack_Id;\n+               while Present (Parent_Unit) loop\n+                  exit when\n+                    Private_Present\n+                      (Parent (Unit_Declaration_Node (Parent_Unit)));\n+                  Parent_Unit := Scope (Parent_Unit);\n+               end loop;\n+\n+               Parent_Unit := Scope (Parent_Unit);\n+\n+               if not Is_Child_Or_Sibling (Pack_Id, Scope (Encap_Id)) then\n+                  SPARK_Msg_NE\n+                    (\"indicator Part_Of must denote abstract state or public \"\n+                     & \"descendant of & (SPARK RM 7.2.6(3))\",\n+                     Indic, Parent_Unit);\n+\n+               elsif Scope (Encap_Id) = Parent_Unit\n+                 or else\n+                   (Is_Ancestor_Package (Parent_Unit, Scope (Encap_Id))\n+                     and then not Is_Private_Descendant (Scope (Encap_Id)))\n+               then\n+                  null;\n+\n+               else\n+                  SPARK_Msg_NE\n+                    (\"indicator Part_Of must denote abstract state or public \"\n+                     & \"descendant of & (SPARK RM 7.2.6(3))\",\n+                     Indic, Parent_Unit);\n+               end if;\n+\n+            --  Indicator Part_Of is not needed when the related package is not\n+            --  a private child unit or a public descendant thereof.\n+\n+            else\n+               SPARK_Msg_N\n+                 (\"indicator Part_Of cannot appear in this context \"\n+                  & \"(SPARK RM 7.2.6(5))\", Indic);\n+               Error_Msg_Name_1 := Chars (Pack_Id);\n+               SPARK_Msg_NE\n+                 (\"\\& is declared in the visible part of package %\",\n+                  Indic, Item_Id);\n+            end if;\n+\n+         --  When the item appears in the private state space of a package, the\n+         --  encapsulating state must be declared in the same package.\n+\n+         elsif Placement = Private_State_Space then\n+            if Scope (Encap_Id) /= Pack_Id then\n+               SPARK_Msg_NE\n+                 (\"indicator Part_Of must designate an abstract state of \"\n+                  & \"package & (SPARK RM 7.2.6(2))\", Indic, Pack_Id);\n+               Error_Msg_Name_1 := Chars (Pack_Id);\n+               SPARK_Msg_NE\n+                 (\"\\& is declared in the private part of package %\",\n+                  Indic, Item_Id);\n+            end if;\n+\n+         --  Items declared in the body state space of a package do not need\n+         --  Part_Of indicators as the refinement has already been seen.\n+\n+         else\n+            SPARK_Msg_N\n+              (\"indicator Part_Of cannot appear in this context \"\n+               & \"(SPARK RM 7.2.6(5))\", Indic);\n+\n+            if Scope (Encap_Id) = Pack_Id then\n+               Error_Msg_Name_1 := Chars (Pack_Id);\n+               SPARK_Msg_NE\n+                 (\"\\& is declared in the body of package %\", Indic, Item_Id);\n+            end if;\n+         end if;\n+\n+      --  The encapsulator is a single concurrent type\n+\n+      else\n+         Encap_Typ := Etype (Encap_Id);\n+\n+         --  Only abstract states and variables can act as constituents of an\n+         --  encapsulating single concurrent type.\n+\n+         if Ekind_In (Item_Id, E_Abstract_State, E_Variable) then\n+            null;\n+\n+         --  The constituent is a constant\n+\n+         elsif Ekind (Item_Id) = E_Constant then\n+            Error_Msg_Name_1 := Chars (Encap_Id);\n+            SPARK_Msg_NE\n+              (Fix_Msg (Encap_Typ, \"consant & cannot act as constituent of \"\n+               & \"single protected type %\"), Indic, Item_Id);\n+\n+         --  The constituent is a package instantiation\n+\n+         else\n+            Error_Msg_Name_1 := Chars (Encap_Id);\n+            SPARK_Msg_NE\n+              (Fix_Msg (Encap_Typ, \"package instantiation & cannot act as \"\n+               & \"constituent of single protected type %\"), Indic, Item_Id);\n+         end if;\n+\n+         --  When the item denotes an abstract state of a nested package, use\n+         --  the declaration of the package to detect proper placement.\n+\n+         --    package Pack is\n+         --       task T;\n+         --       package Nested\n+         --         with Abstract_State => (State with Part_Of => T)\n+\n+         if Ekind (Item_Id) = E_Abstract_State then\n+            Item_Decl := Unit_Declaration_Node (Scope (Item_Id));\n+         else\n+            Item_Decl := Declaration_Node (Item_Id);\n+         end if;\n+\n+         --  Both the item and its encapsulating single concurrent type must\n+         --  appear in the same declarative region (SPARK RM 9.3). Note that\n+         --  privacy is ignored.\n+\n+         if Parent (Item_Decl) /= Parent (Declaration_Node (Encap_Id)) then\n+            Error_Msg_Name_1 := Chars (Encap_Id);\n+            SPARK_Msg_NE\n+              (Fix_Msg (Encap_Typ, \"constituent & must be declared \"\n+               & \"immediately within the same region as single protected \"\n+               & \"type %\"), Indic, Item_Id);\n+         end if;\n+      end if;\n+\n+      Legal := True;\n+   end Analyze_Part_Of;\n+\n+   ----------------------------------\n+   -- Analyze_Part_Of_In_Decl_Part --\n+   ----------------------------------\n+\n+   procedure Analyze_Part_Of_In_Decl_Part (N : Node_Id) is\n+      Var_Decl : constant Node_Id   := Find_Related_Context (N);\n+      Var_Id   : constant Entity_Id := Defining_Entity (Var_Decl);\n+      Encap_Id : Entity_Id;\n+      Legal    : Boolean;\n+\n+   begin\n+      --  Detect any discrepancies between the placement of the variable with\n+      --  respect to general state space and the encapsulating state or single\n+      --  concurrent type.\n+\n+      Analyze_Part_Of\n+        (Indic    => N,\n+         Item_Id  => Var_Id,\n+         Encap    => Get_Pragma_Arg (First (Pragma_Argument_Associations (N))),\n+         Encap_Id => Encap_Id,\n+         Legal    => Legal);\n+\n+      --  The Part_Of indicator turns the variable into a constituent of the\n+      --  encapsulating state or single concurrent type.\n+\n+      if Legal then\n+         pragma Assert (Present (Encap_Id));\n+\n+         Append_Elmt (Var_Id, Part_Of_Constituents (Encap_Id));\n+         Set_Encapsulating_State (Var_Id, Encap_Id);\n+      end if;\n+   end Analyze_Part_Of_In_Decl_Part;\n+\n    --------------------\n    -- Analyze_Pragma --\n    --------------------\n@@ -2775,17 +3075,6 @@ package body Sem_Prag is\n       --  Inspect the remainder of the list containing pragma N and look for\n       --  a pragma that matches Id. If found, analyze the pragma.\n \n-      procedure Analyze_Part_Of\n-        (Item_Id : Entity_Id;\n-         State   : Node_Id;\n-         Indic   : Node_Id;\n-         Legal   : out Boolean);\n-      --  Subsidiary to the analysis of pragmas Abstract_State and Part_Of.\n-      --  Perform full analysis of indicator Part_Of. Item_Id is the entity of\n-      --  an abstract state, object, or package instantiation. State is the\n-      --  encapsulating state. Indic is the Part_Of indicator. Flag Legal is\n-      --  set when the indicator is legal.\n-\n       procedure Analyze_Pre_Post_Condition;\n       --  Subsidiary to the analysis of pragmas Precondition and Postcondition\n \n@@ -3374,6 +3663,16 @@ package body Sem_Prag is\n          elsif Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n             null;\n \n+         --  Object declaration of a single concurrent type\n+\n+         elsif Nkind (Subp_Decl) = N_Object_Declaration then\n+            null;\n+\n+         --  Single task type\n+\n+         elsif Nkind (Subp_Decl) = N_Single_Task_Declaration then\n+            null;\n+\n          --  Subprogram body acts as spec\n \n          elsif Nkind (Subp_Decl) = N_Subprogram_Body\n@@ -3393,7 +3692,7 @@ package body Sem_Prag is\n          elsif Nkind (Subp_Decl) = N_Subprogram_Declaration then\n             null;\n \n-         --  Task unit\n+         --  Task type\n \n          elsif Nkind (Subp_Decl) = N_Task_Type_Declaration then\n             null;\n@@ -3408,14 +3707,24 @@ package body Sem_Prag is\n          Legal   := True;\n          Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n-         --  When the related context is an entry, it must be a protected entry\n-         --  (SPARK RM 6.1.4(6)).\n+         --  When the related context is an entry, the entry must belong to a\n+         --  protected unit (SPARK RM 6.1.4(6)).\n \n          if Is_Entry_Declaration (Spec_Id)\n            and then Ekind (Scope (Spec_Id)) /= E_Protected_Type\n          then\n             Pragma_Misplaced;\n             return;\n+\n+         --  When the related context is an anonymous object created for a\n+         --  simple concurrent type, the type must be a task\n+         --  (SPARK RM 6.1.4(6)).\n+\n+         elsif Is_Single_Concurrent_Object (Spec_Id)\n+           and then Ekind (Etype (Spec_Id)) /= E_Task_Type\n+         then\n+            Pragma_Misplaced;\n+            return;\n          end if;\n \n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n@@ -3456,183 +3765,6 @@ package body Sem_Prag is\n          end loop;\n       end Analyze_If_Present;\n \n-      ---------------------\n-      -- Analyze_Part_Of --\n-      ---------------------\n-\n-      procedure Analyze_Part_Of\n-        (Item_Id : Entity_Id;\n-         State   : Node_Id;\n-         Indic   : Node_Id;\n-         Legal   : out Boolean)\n-      is\n-         Pack_Id     : Entity_Id;\n-         Placement   : State_Space_Kind;\n-         Parent_Unit : Entity_Id;\n-         State_Id    : Entity_Id;\n-\n-      begin\n-         --  Assume that the pragma/option is illegal\n-\n-         Legal := False;\n-\n-         if Nkind_In (State, N_Expanded_Name,\n-                             N_Identifier,\n-                             N_Selected_Component)\n-         then\n-            Analyze       (State);\n-            Resolve_State (State);\n-\n-            if Is_Entity_Name (State)\n-              and then Ekind (Entity (State)) = E_Abstract_State\n-            then\n-               State_Id := Entity (State);\n-\n-            else\n-               SPARK_Msg_N\n-                 (\"indicator Part_Of must denote an abstract state\", State);\n-               return;\n-            end if;\n-\n-         --  This is a syntax error, always report\n-\n-         else\n-            Error_Msg_N\n-              (\"indicator Part_Of must denote an abstract state\", State);\n-            return;\n-         end if;\n-\n-         --  Catch a case where indicator Part_Of denotes the abstract view of\n-         --  a variable which appears as an abstract state (SPARK RM 10.1.2 2).\n-\n-         if From_Limited_With (State_Id)\n-           and then Present (Non_Limited_View (State_Id))\n-           and then Ekind (Non_Limited_View (State_Id)) = E_Variable\n-         then\n-            SPARK_Msg_N\n-              (\"indicator Part_Of must denote an abstract state\", State);\n-            SPARK_Msg_N (\"\\& denotes abstract view of object\", State);\n-            return;\n-         end if;\n-\n-         --  Determine where the state, object or the package instantiation\n-         --  lives with respect to the enclosing packages or package bodies (if\n-         --  any). This placement dictates the legality of the encapsulating\n-         --  state.\n-\n-         Find_Placement_In_State_Space\n-           (Item_Id   => Item_Id,\n-            Placement => Placement,\n-            Pack_Id   => Pack_Id);\n-\n-         --  The item appears in a non-package construct with a declarative\n-         --  part (subprogram, block, etc). As such, the item is not allowed\n-         --  to be a part of an encapsulating state because the item is not\n-         --  visible.\n-\n-         if Placement = Not_In_Package then\n-            SPARK_Msg_N\n-              (\"indicator Part_Of cannot appear in this context \"\n-               & \"(SPARK RM 7.2.6(5))\", Indic);\n-            Error_Msg_Name_1 := Chars (Scope (State_Id));\n-            SPARK_Msg_NE\n-              (\"\\& is not part of the hidden state of package %\",\n-               Indic, Item_Id);\n-\n-         --  The item appears in the visible state space of some package. In\n-         --  general this scenario does not warrant Part_Of except when the\n-         --  package is a private child unit and the encapsulating state is\n-         --  declared in a parent unit or a public descendant of that parent\n-         --  unit.\n-\n-         elsif Placement = Visible_State_Space then\n-            if Is_Child_Unit (Pack_Id)\n-              and then Is_Private_Descendant (Pack_Id)\n-            then\n-               --  A variable or state abstraction which is part of the\n-               --  visible state of a private child unit (or one of its public\n-               --  descendants) must have its Part_Of indicator specified. The\n-               --  Part_Of indicator must denote a state abstraction declared\n-               --  by either the parent unit of the private unit or by a public\n-               --  descendant of that parent unit.\n-\n-               --  Find nearest private ancestor (which can be the current unit\n-               --  itself).\n-\n-               Parent_Unit := Pack_Id;\n-               while Present (Parent_Unit) loop\n-                  exit when Private_Present\n-                              (Parent (Unit_Declaration_Node (Parent_Unit)));\n-                  Parent_Unit := Scope (Parent_Unit);\n-               end loop;\n-\n-               Parent_Unit := Scope (Parent_Unit);\n-\n-               if not Is_Child_Or_Sibling (Pack_Id, Scope (State_Id)) then\n-                  SPARK_Msg_NE\n-                    (\"indicator Part_Of must denote an abstract state or \"\n-                     & \"public descendant of & (SPARK RM 7.2.6(3))\",\n-                       Indic, Parent_Unit);\n-\n-               elsif Scope (State_Id) = Parent_Unit\n-                 or else (Is_Ancestor_Package (Parent_Unit, Scope (State_Id))\n-                           and then\n-                             not Is_Private_Descendant (Scope (State_Id)))\n-               then\n-                  null;\n-\n-               else\n-                  SPARK_Msg_NE\n-                    (\"indicator Part_Of must denote an abstract state or \"\n-                     & \"public descendant of & (SPARK RM 7.2.6(3))\",\n-                       Indic, Parent_Unit);\n-               end if;\n-\n-            --  Indicator Part_Of is not needed when the related package is not\n-            --  a private child unit or a public descendant thereof.\n-\n-            else\n-               SPARK_Msg_N\n-                 (\"indicator Part_Of cannot appear in this context \"\n-                  & \"(SPARK RM 7.2.6(5))\", Indic);\n-               Error_Msg_Name_1 := Chars (Pack_Id);\n-               SPARK_Msg_NE\n-                 (\"\\& is declared in the visible part of package %\",\n-                  Indic, Item_Id);\n-            end if;\n-\n-         --  When the item appears in the private state space of a package, the\n-         --  encapsulating state must be declared in the same package.\n-\n-         elsif Placement = Private_State_Space then\n-            if Scope (State_Id) /= Pack_Id then\n-               SPARK_Msg_NE\n-                 (\"indicator Part_Of must designate an abstract state of \"\n-                  & \"package & (SPARK RM 7.2.6(2))\", Indic, Pack_Id);\n-               Error_Msg_Name_1 := Chars (Pack_Id);\n-               SPARK_Msg_NE\n-                 (\"\\& is declared in the private part of package %\",\n-                  Indic, Item_Id);\n-            end if;\n-\n-         --  Items declared in the body state space of a package do not need\n-         --  Part_Of indicators as the refinement has already been seen.\n-\n-         else\n-            SPARK_Msg_N\n-              (\"indicator Part_Of cannot appear in this context \"\n-               & \"(SPARK RM 7.2.6(5))\", Indic);\n-\n-            if Scope (State_Id) = Pack_Id then\n-               Error_Msg_Name_1 := Chars (Pack_Id);\n-               SPARK_Msg_NE\n-                 (\"\\& is declared in the body of package %\", Indic, Item_Id);\n-            end if;\n-         end if;\n-\n-         Legal := True;\n-      end Analyze_Part_Of;\n-\n       --------------------------------\n       -- Analyze_Pre_Post_Condition --\n       --------------------------------\n@@ -9681,7 +9813,7 @@ package body Sem_Prag is\n          --    SIMPLE_OPTION\n          --  | NAME_VALUE_OPTION\n \n-         --  SIMPLE_OPTION ::= Ghost\n+         --  SIMPLE_OPTION ::= Ghost | Synchronous\n \n          --  NAME_VALUE_OPTION ::=\n          --    Part_Of => ABSTRACT_STATE\n@@ -9751,13 +9883,15 @@ package body Sem_Prag is\n             is\n                --  Flags used to verify the consistency of options\n \n-               AR_Seen       : Boolean := False;\n-               AW_Seen       : Boolean := False;\n-               ER_Seen       : Boolean := False;\n-               EW_Seen       : Boolean := False;\n-               External_Seen : Boolean := False;\n-               Others_Seen   : Boolean := False;\n-               Part_Of_Seen  : Boolean := False;\n+               AR_Seen          : Boolean := False;\n+               AW_Seen          : Boolean := False;\n+               ER_Seen          : Boolean := False;\n+               EW_Seen          : Boolean := False;\n+               External_Seen    : Boolean := False;\n+               Ghost_Seen       : Boolean := False;\n+               Others_Seen      : Boolean := False;\n+               Part_Of_Seen     : Boolean := False;\n+               Synchronous_Seen : Boolean := False;\n \n                --  Flags used to store the static value of all external states'\n                --  expressions.\n@@ -9822,8 +9956,6 @@ package body Sem_Prag is\n                   Props  : Node_Id := Empty;\n \n                begin\n-                  Check_Duplicate_Option (Opt, External_Seen);\n-\n                   if Nkind (Opt) = N_Component_Association then\n                      Props := Expression (Opt);\n                   end if;\n@@ -9996,27 +10128,29 @@ package body Sem_Prag is\n                ----------------------------\n \n                procedure Analyze_Part_Of_Option (Opt : Node_Id) is\n-                  Encaps    : constant Node_Id := Expression (Opt);\n-                  Encaps_Id : Entity_Id;\n-                  Legal     : Boolean;\n+                  Encap    : constant Node_Id := Expression (Opt);\n+                  Encap_Id : Entity_Id;\n+                  Legal    : Boolean;\n \n                begin\n                   Check_Duplicate_Option (Opt, Part_Of_Seen);\n \n                   Analyze_Part_Of\n-                    (Item_Id => State_Id,\n-                     State   => Encaps,\n-                     Indic   => First (Choices (Opt)),\n-                     Legal   => Legal);\n+                    (Indic    => First (Choices (Opt)),\n+                     Item_Id  => State_Id,\n+                     Encap    => Encap,\n+                     Encap_Id => Encap_Id,\n+                     Legal    => Legal);\n \n-                  --  The Part_Of indicator turns an abstract state into a\n-                  --  constituent of the encapsulating state.\n+                  --  The Part_Of indicator transforms the abstract state into\n+                  --  a constituent of the encapsulating state or single\n+                  --  concurrent type.\n \n                   if Legal then\n-                     Encaps_Id := Entity (Encaps);\n+                     pragma Assert (Present (Encap_Id));\n \n-                     Append_Elmt (State_Id, Part_Of_Constituents (Encaps_Id));\n-                     Set_Encapsulating_State (State_Id, Encaps_Id);\n+                     Append_Elmt (State_Id, Part_Of_Constituents (Encap_Id));\n+                     Set_Encapsulating_State (State_Id, Encap_Id);\n                   end if;\n                end Analyze_Part_Of_Option;\n \n@@ -10179,26 +10313,41 @@ package body Sem_Prag is\n                         Ancestor_Part (State));\n                   end if;\n \n-                  --  Options External and Ghost appear as expressions\n+                  --  Options External, Ghost and Synchronous appear as\n+                  --  expressions.\n \n                   Opt := First (Expressions (State));\n                   while Present (Opt) loop\n                      if Nkind (Opt) = N_Identifier then\n+\n+                        --  External\n+\n                         if Chars (Opt) = Name_External then\n+                           Check_Duplicate_Option (Opt, External_Seen);\n                            Analyze_External_Option (Opt);\n \n+                        --  Ghost\n+\n                         elsif Chars (Opt) = Name_Ghost then\n+                           Check_Duplicate_Option (Opt, Ghost_Seen);\n+\n                            if Present (State_Id) then\n                               Set_Is_Ghost_Entity (State_Id);\n                            end if;\n \n+                        --  Synchronous\n+\n+                        elsif Chars (Opt) = Name_Synchronous then\n+                           Check_Duplicate_Option (Opt, Synchronous_Seen);\n+\n                         --  Option Part_Of without an encapsulating state is\n-                        --  illegal. (SPARK RM 7.1.4(9)).\n+                        --  illegal (SPARK RM 7.1.4(9)).\n \n                         elsif Chars (Opt) = Name_Part_Of then\n                            SPARK_Msg_N\n-                             (\"indicator Part_Of must denote an abstract \"\n-                              & \"state\", Opt);\n+                             (\"indicator Part_Of must denote abstract state, \"\n+                              & \"single protected type or single task type\",\n+                              Opt);\n \n                         --  Do not emit an error message when a previous state\n                         --  declaration with options was not parenthesized as\n@@ -17626,10 +17775,10 @@ package body Sem_Prag is\n \n             --  Local variables\n \n+            Encap    : Node_Id;\n+            Encap_Id : Entity_Id;\n             Item_Id  : Entity_Id;\n             Legal    : Boolean;\n-            State    : Node_Id;\n-            State_Id : Entity_Id;\n             Stmt     : Node_Id;\n \n          --  Start of processing for Part_Of\n@@ -17651,6 +17800,11 @@ package body Sem_Prag is\n             elsif Nkind (Stmt) = N_Package_Instantiation then\n                null;\n \n+            --  Single concurrent type declaration\n+\n+            elsif Is_Single_Concurrent_Type_Declaration (Stmt) then\n+               null;\n+\n             --  Otherwise the pragma is associated with an illegal construct\n \n             else\n@@ -17667,47 +17821,58 @@ package body Sem_Prag is\n             end if;\n \n             Item_Id := Defining_Entity (Stmt);\n-            State   := Get_Pragma_Arg  (Arg1);\n+            Encap   := Get_Pragma_Arg (Arg1);\n \n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n             Mark_Pragma_As_Ghost (N, Item_Id);\n \n-            --  Detect any discrepancies between the placement of the object\n-            --  or package instantiation with respect to state space and the\n-            --  encapsulating state.\n+            --  Chain the pragma on the contract for further processing by\n+            --  Analyze_Part_Of_In_Decl_Part or for completeness.\n \n-            Analyze_Part_Of\n-              (Item_Id => Item_Id,\n-               State   => State,\n-               Indic   => N,\n-               Legal   => Legal);\n+            Add_Contract_Item (N, Item_Id);\n \n-            if Legal then\n+            --  A variable may act as consituent of a single concurrent type\n+            --  which in turn could be declared after the variable. Due to this\n+            --  discrepancy, the full analysis of indicator Part_Of is delayed\n+            --  until the end of the enclosing declarative region (see routine\n+            --  Analyze_Part_Of_In_Decl_Part).\n \n-               --  Add the pragma to the contract of the item. This aids with\n-               --  the detection of a missing but required Part_Of indicator.\n+            if Ekind (Item_Id) = E_Variable then\n+               null;\n \n-               Add_Contract_Item (N, Item_Id);\n+            --  Otherwise indicator Part_Of applies to a constant or a package\n+            --  instantiation.\n \n-               --  The Part_Of indicator turns an object into a constituent of\n-               --  the encapsulating state.\n+            else\n+               --  Detect any discrepancies between the placement of the\n+               --  constant or package instantiation with respect to state\n+               --  space and the encapsulating state.\n \n-               State_Id := Entity (State);\n+               Analyze_Part_Of\n+                 (Indic    => N,\n+                  Item_Id  => Item_Id,\n+                  Encap    => Encap,\n+                  Encap_Id => Encap_Id,\n+                  Legal    => Legal);\n \n-               if Ekind_In (Item_Id, E_Constant, E_Variable) then\n-                  Append_Elmt (Item_Id, Part_Of_Constituents (State_Id));\n-                  Set_Encapsulating_State (Item_Id, State_Id);\n+               if Legal then\n+                  pragma Assert (Present (Encap_Id));\n \n-               --  Propagate the Part_Of indicator to the visible state space\n-               --  of the package instantiation.\n+                  if Ekind (Item_Id) = E_Constant then\n+                     Append_Elmt (Item_Id, Part_Of_Constituents (Encap_Id));\n+                     Set_Encapsulating_State (Item_Id, Encap_Id);\n \n-               else\n-                  Propagate_Part_Of\n-                    (Pack_Id  => Item_Id,\n-                     State_Id => State_Id,\n-                     Instance => Stmt);\n+                  --  Propagate the Part_Of indicator to the visible state\n+                  --  space of the package instantiation.\n+\n+                  else\n+                     Propagate_Part_Of\n+                       (Pack_Id  => Item_Id,\n+                        State_Id => Encap_Id,\n+                        Instance => Stmt);\n+                  end if;\n                end if;\n             end if;\n          end Part_Of;\n@@ -19963,7 +20128,8 @@ package body Sem_Prag is\n             --------------------------\n \n             procedure Process_Overloadable (Decl : Node_Id) is\n-               Spec_Id : constant Entity_Id := Defining_Entity (Decl);\n+               Spec_Id  : constant Entity_Id := Defining_Entity (Decl);\n+               Spec_Typ : constant Entity_Id := Etype (Spec_Id);\n \n             begin\n                Check_Library_Level_Entity (Spec_Id);\n@@ -19978,6 +20144,25 @@ package body Sem_Prag is\n \n                Set_SPARK_Pragma           (Spec_Id, N);\n                Set_SPARK_Pragma_Inherited (Spec_Id, False);\n+\n+               --  When the pragma applies to the anonymous object created for\n+               --  a single task type, decorate the type as well. This scenario\n+               --  arises when the single task type lacks a task definition,\n+               --  therefore there is no issue with respect to a potential\n+               --  pragma SPARK_Mode in the private part.\n+\n+               --    task type Anon_Task_Typ;\n+               --    Obj : Anon_Task_Typ;\n+               --    pragma SPARK_Mode ...;\n+\n+               if Is_Single_Concurrent_Object (Spec_Id)\n+                 and then Ekind (Spec_Typ) = E_Task_Type\n+               then\n+                  Set_SPARK_Pragma               (Spec_Typ, N);\n+                  Set_SPARK_Pragma_Inherited     (Spec_Typ, False);\n+                  Set_SPARK_Aux_Pragma           (Spec_Typ, N);\n+                  Set_SPARK_Aux_Pragma_Inherited (Spec_Typ, True);\n+               end if;\n             end Process_Overloadable;\n \n             --------------------------\n@@ -20032,6 +20217,7 @@ package body Sem_Prag is\n \n             procedure Process_Visible_Part (Decl : Node_Id) is\n                Spec_Id : constant Entity_Id := Defining_Entity (Decl);\n+               Obj_Id  : Entity_Id;\n \n             begin\n                Check_Library_Level_Entity (Spec_Id);\n@@ -20058,6 +20244,23 @@ package body Sem_Prag is\n                Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n                Set_SPARK_Aux_Pragma           (Spec_Id, N);\n                Set_SPARK_Aux_Pragma_Inherited (Spec_Id, True);\n+\n+               --  When the pragma applies to a single protected or task type,\n+               --  decorate the corresponding anonymous object as well.\n+\n+               --    protected Anon_Prot_Typ is\n+               --       pragma SPARK_Mode ...;\n+               --       ...\n+               --    end Anon_Prot_Typ;\n+\n+               --    Obj : Anon_Prot_Typ;\n+\n+               if Is_Single_Concurrent_Type (Spec_Id) then\n+                  Obj_Id := Anonymous_Object (Spec_Id);\n+\n+                  Set_SPARK_Pragma           (Obj_Id, N);\n+                  Set_SPARK_Pragma_Inherited (Obj_Id, False);\n+               end if;\n             end Process_Visible_Part;\n \n             -----------------------\n@@ -20165,19 +20368,6 @@ package body Sem_Prag is\n                      Process_Overloadable (Stmt);\n                      return;\n \n-                  --  The pragma applies to a task unit without a definition.\n-                  --  This also handles the case where a single task unit is\n-                  --  rewritten into a task type declaration.\n-\n-                  --    task [type] Tsk;\n-                  --    pragma SPARK_Mode ...;\n-\n-                  elsif Nkind_In (Stmt, N_Single_Task_Declaration,\n-                                        N_Task_Type_Declaration)\n-                  then\n-                     Process_Visible_Part (Stmt);\n-                     return;\n-\n                   --  Skip internally generated code\n \n                   elsif not Comes_From_Source (Stmt) then\n@@ -20202,6 +20392,20 @@ package body Sem_Prag is\n                      Process_Overloadable (Stmt);\n                      return;\n \n+                  --  The pragma applies to the anonymous object created for a\n+                  --  single concurrent type.\n+\n+                  --    protected type Anon_Prot_Typ ...;\n+                  --    Obj : Anon_Prot_Typ;\n+                  --    pragma SPARK_Mode ...;\n+\n+                  elsif Nkind (Stmt) = N_Object_Declaration\n+                    and then Is_Single_Concurrent_Object\n+                               (Defining_Entity (Stmt))\n+                  then\n+                     Process_Overloadable (Stmt);\n+                     return;\n+\n                   --  Otherwise the pragma does not apply to a legal construct\n                   --  or it does not appear at the top of a declarative or a\n                   --  statement list. Issue an error and stop the analysis.\n@@ -23469,6 +23673,15 @@ package body Sem_Prag is\n       end if;\n \n       Spec_Id := Unique_Defining_Entity (Body_Decl);\n+\n+      --  Use the anonymous object as the proper spec when Refined_Depends\n+      --  applies to the body of a single task type. The object carries the\n+      --  proper Chars as well as all non-refined versions of pragmas.\n+\n+      if Is_Single_Concurrent_Type (Spec_Id) then\n+         Spec_Id := Anonymous_Object (Spec_Id);\n+      end if;\n+\n       Depends := Get_Pragma (Spec_Id, Pragma_Depends);\n \n       --  Subprogram declarations lacks pragma Depends. Refined_Depends is\n@@ -24438,8 +24651,17 @@ package body Sem_Prag is\n       end if;\n \n       Spec_Id := Unique_Defining_Entity (Body_Decl);\n-      Global  := Get_Pragma (Spec_Id, Pragma_Global);\n-      Items   := Expression (Get_Argument (N, Spec_Id));\n+\n+      --  Use the anonymous object as the proper spec when Refined_Global\n+      --  applies to the body of a single task type. The object carries the\n+      --  proper Chars as well as all non-refined versions of pragmas.\n+\n+      if Is_Single_Concurrent_Type (Spec_Id) then\n+         Spec_Id := Anonymous_Object (Spec_Id);\n+      end if;\n+\n+      Global := Get_Pragma (Spec_Id, Pragma_Global);\n+      Items  := Expression (Get_Argument (N, Spec_Id));\n \n       --  The subprogram declaration lacks pragma Global. This renders\n       --  Refined_Global useless as there is nothing to refine.\n@@ -24636,7 +24858,7 @@ package body Sem_Prag is\n          --  should be set when the property applies to the refined state. If\n          --  this is not the case, emit an error message.\n \n-         procedure Check_Matching_State;\n+         procedure Match_State;\n          --  Determine whether the state being refined appears in list\n          --  Available_States. Emit an error when attempting to re-refine the\n          --  state or when the state is not defined in the package declaration,\n@@ -24650,33 +24872,86 @@ package body Sem_Prag is\n          -------------------------\n \n          procedure Analyze_Constituent (Constit : Node_Id) is\n-            procedure Check_Ghost_Constituent (Constit_Id : Entity_Id);\n-            --  Verify that the constituent Constit_Id is a Ghost entity if the\n-            --  abstract state being refined is also Ghost. If this is the case\n-            --  verify that the Ghost policy in effect at the point of state\n-            --  and constituent declaration is the same.\n-\n-            procedure Check_Matching_Constituent (Constit_Id : Entity_Id);\n+            procedure Match_Constituent (Constit_Id : Entity_Id);\n             --  Determine whether constituent Constit denoted by its entity\n             --  Constit_Id appears in Body_States. Emit an error when the\n             --  constituent is not a valid hidden state of the related package\n             --  or when it is used more than once. Otherwise remove the\n             --  constituent from Body_States.\n \n-            --------------------------------\n-            -- Check_Matching_Constituent --\n-            --------------------------------\n+            -----------------------\n+            -- Match_Constituent --\n+            -----------------------\n \n-            procedure Check_Matching_Constituent (Constit_Id : Entity_Id) is\n+            procedure Match_Constituent (Constit_Id : Entity_Id) is\n                procedure Collect_Constituent;\n-               --  Add constituent Constit_Id to the refinements of State_Id\n+               --  Verify the legality of constituent Constit_Id and add it to\n+               --  the refinements of State_Id.\n \n                -------------------------\n                -- Collect_Constituent --\n                -------------------------\n \n                procedure Collect_Constituent is\n                begin\n+                  if Is_Ghost_Entity (State_Id) then\n+                     if Is_Ghost_Entity (Constit_Id) then\n+\n+                        --  The Ghost policy in effect at the point of abstract\n+                        --  state declaration and constituent must match\n+                        --  (SPARK RM 6.9(16)).\n+\n+                        if Is_Checked_Ghost_Entity (State_Id)\n+                          and then Is_Ignored_Ghost_Entity (Constit_Id)\n+                        then\n+                           Error_Msg_Sloc := Sloc (Constit);\n+\n+                           SPARK_Msg_N\n+                             (\"incompatible ghost policies in effect\", State);\n+                           SPARK_Msg_NE\n+                             (\"\\abstract state & declared with ghost policy \"\n+                              & \"Check\", State, State_Id);\n+                           SPARK_Msg_NE\n+                             (\"\\constituent & declared # with ghost policy \"\n+                              & \"Ignore\", State, Constit_Id);\n+\n+                        elsif Is_Ignored_Ghost_Entity (State_Id)\n+                          and then Is_Checked_Ghost_Entity (Constit_Id)\n+                        then\n+                           Error_Msg_Sloc := Sloc (Constit);\n+\n+                           SPARK_Msg_N\n+                             (\"incompatible ghost policies in effect\", State);\n+                           SPARK_Msg_NE\n+                             (\"\\abstract state & declared with ghost policy \"\n+                              & \"Ignore\", State, State_Id);\n+                           SPARK_Msg_NE\n+                             (\"\\constituent & declared # with ghost policy \"\n+                              & \"Check\", State, Constit_Id);\n+                        end if;\n+\n+                     --  A constituent of a Ghost abstract state must be a\n+                     --  Ghost entity (SPARK RM 7.2.2(12)).\n+\n+                     else\n+                        SPARK_Msg_NE\n+                          (\"constituent of ghost state & must be ghost\",\n+                           Constit, State_Id);\n+                     end if;\n+                  end if;\n+\n+                  --  A synchronized state must be refined by a synchronized\n+                  --  object or another synchronized state (SPARK RM 9.6).\n+\n+                  if Is_Synchronized_State (State_Id)\n+                    and then not Is_Synchronized_Object (Constit_Id)\n+                    and then not Is_Synchronized_State (Constit_Id)\n+                  then\n+                     SPARK_Msg_NE\n+                       (\"constituent of synchronized state & must be \"\n+                        & \"synchronized\", Constit, State_Id);\n+                  end if;\n+\n                   --  Add the constituent to the list of processed items to aid\n                   --  with the detection of duplicates.\n \n@@ -24723,7 +24998,7 @@ package body Sem_Prag is\n \n                State_Elmt : Elmt_Id;\n \n-            --  Start of processing for Check_Matching_Constituent\n+            --  Start of processing for Match_Constituent\n \n             begin\n                --  Detect a duplicate use of a constituent\n@@ -24738,7 +25013,6 @@ package body Sem_Prag is\n \n                if Present (Encapsulating_State (Constit_Id)) then\n                   if Encapsulating_State (Constit_Id) = State_Id then\n-                     Check_Ghost_Constituent (Constit_Id);\n                      Remove (Part_Of_Constits, Constit_Id);\n                      Collect_Constituent;\n \n@@ -24751,8 +25025,8 @@ package body Sem_Prag is\n                        (\"& cannot act as constituent of state %\",\n                         Constit, Constit_Id);\n                      SPARK_Msg_NE\n-                       (\"\\Part_Of indicator specifies & as encapsulating \"\n-                        & \"state\", Constit, Encapsulating_State (Constit_Id));\n+                       (\"\\Part_Of indicator specifies encapsulator &\",\n+                        Constit, Encapsulating_State (Constit_Id));\n                   end if;\n \n                --  The only other source of legal constituents is the body\n@@ -24767,7 +25041,6 @@ package body Sem_Prag is\n                         --  been encountered.\n \n                         if Node (State_Elmt) = Constit_Id then\n-                           Check_Ghost_Constituent (Constit_Id);\n                            Remove_Elmt (Body_States, State_Elmt);\n                            Collect_Constituent;\n                            return;\n@@ -24797,60 +25070,7 @@ package body Sem_Prag is\n                         & \"hidden state of package %\", Constit, Constit_Id);\n                   end if;\n                end if;\n-            end Check_Matching_Constituent;\n-\n-            -----------------------------\n-            -- Check_Ghost_Constituent --\n-            -----------------------------\n-\n-            procedure Check_Ghost_Constituent (Constit_Id : Entity_Id) is\n-            begin\n-               if Is_Ghost_Entity (State_Id) then\n-                  if Is_Ghost_Entity (Constit_Id) then\n-\n-                     --  The Ghost policy in effect at the point of abstract\n-                     --  state declaration and constituent must match\n-                     --  (SPARK RM 6.9(16)).\n-\n-                     if Is_Checked_Ghost_Entity (State_Id)\n-                       and then Is_Ignored_Ghost_Entity (Constit_Id)\n-                     then\n-                        Error_Msg_Sloc := Sloc (Constit);\n-\n-                        SPARK_Msg_N\n-                          (\"incompatible ghost policies in effect\", State);\n-                        SPARK_Msg_NE\n-                          (\"\\abstract state & declared with ghost policy \"\n-                           & \"Check\", State, State_Id);\n-                        SPARK_Msg_NE\n-                          (\"\\constituent & declared # with ghost policy \"\n-                           & \"Ignore\", State, Constit_Id);\n-\n-                     elsif Is_Ignored_Ghost_Entity (State_Id)\n-                       and then Is_Checked_Ghost_Entity (Constit_Id)\n-                     then\n-                        Error_Msg_Sloc := Sloc (Constit);\n-\n-                        SPARK_Msg_N\n-                          (\"incompatible ghost policies in effect\", State);\n-                        SPARK_Msg_NE\n-                          (\"\\abstract state & declared with ghost policy \"\n-                           & \"Ignore\", State, State_Id);\n-                        SPARK_Msg_NE\n-                          (\"\\constituent & declared # with ghost policy \"\n-                           & \"Check\", State, Constit_Id);\n-                     end if;\n-\n-                  --  A constituent of a Ghost abstract state must be a Ghost\n-                  --  entity (SPARK RM 7.2.2(12)).\n-\n-                  else\n-                     SPARK_Msg_NE\n-                       (\"constituent of ghost state & must be ghost\",\n-                        Constit, State_Id);\n-                  end if;\n-               end if;\n-            end Check_Ghost_Constituent;\n+            end Match_Constituent;\n \n             --  Local variables\n \n@@ -24950,7 +25170,7 @@ package body Sem_Prag is\n                                               E_Constant,\n                                               E_Variable)\n                   then\n-                     Check_Matching_Constituent (Constit_Id);\n+                     Match_Constituent (Constit_Id);\n \n                   --  Otherwise the constituent is illegal\n \n@@ -25002,11 +25222,11 @@ package body Sem_Prag is\n             end if;\n          end Check_External_Property;\n \n-         --------------------------\n-         -- Check_Matching_State --\n-         --------------------------\n+         -----------------\n+         -- Match_State --\n+         -----------------\n \n-         procedure Check_Matching_State is\n+         procedure Match_State is\n             State_Elmt : Elmt_Id;\n \n          begin\n@@ -25046,7 +25266,7 @@ package body Sem_Prag is\n             SPARK_Msg_NE\n               (\"cannot refine state, & is not defined in package %\",\n                State, State_Id);\n-         end Check_Matching_State;\n+         end Match_State;\n \n          --------------------------------\n          -- Report_Unused_Constituents --\n@@ -25139,11 +25359,10 @@ package body Sem_Prag is\n             --  is not defined in the package declaration.\n \n             elsif Ekind (State_Id) = E_Abstract_State then\n-               Check_Matching_State;\n+               Match_State;\n \n             else\n-               SPARK_Msg_NE\n-                 (\"& must denote an abstract state\", State, State_Id);\n+               SPARK_Msg_NE (\"& must denote abstract state\", State, State_Id);\n                return;\n             end if;\n \n@@ -26119,7 +26338,7 @@ package body Sem_Prag is\n \n       begin\n          --  Since a constituent may be part of a larger constituent set, climb\n-         --  the encapsulated state chain looking for a state that appears in\n+         --  the encapsulating state chain looking for a state that appears in\n          --  the same context.\n \n          State_Id := Encapsulating_State (Constit_Id);\n@@ -26640,14 +26859,6 @@ package body Sem_Prag is\n                elsif Present (Generic_Parent (Specification (Stmt))) then\n                   return Stmt;\n                end if;\n-\n-            --  The pragma applies to a single task declaration rewritten as a\n-            --  task type.\n-\n-            elsif Nkind (Stmt) = N_Task_Type_Declaration\n-              and then Nkind (Original_Node (Stmt)) = N_Single_Task_Declaration\n-            then\n-               return Stmt;\n             end if;\n \n          --  Return the current construct which is either a subprogram body,\n@@ -26791,56 +27002,6 @@ package body Sem_Prag is\n       end if;\n    end Find_Related_Package_Or_Body;\n \n-   -------------\n-   -- Fix_Msg --\n-   -------------\n-\n-   function Fix_Msg (Id : Entity_Id; Msg : String) return String is\n-      Msg_Last  : constant Natural := Msg'Last;\n-      Msg_Index : Natural;\n-      Res       : String (Msg'Range) := (others => ' ');\n-      Res_Index : Natural;\n-\n-   begin\n-      --  Copy all characters from the input message Msg to result Res with\n-      --  suitable replacements.\n-\n-      Msg_Index := Msg'First;\n-      Res_Index := Res'First;\n-      while Msg_Index <= Msg_Last loop\n-\n-         --  Replace \"subprogram\" with a different word\n-\n-         if Msg_Index <= Msg_Last - 10\n-           and then Msg (Msg_Index .. Msg_Index + 9) = \"subprogram\"\n-         then\n-            if Ekind_In (Id, E_Entry, E_Entry_Family) then\n-               Res (Res_Index .. Res_Index + 4) := \"entry\";\n-               Res_Index := Res_Index + 5;\n-\n-            elsif Ekind_In (Id, E_Task_Body, E_Task_Type) then\n-               Res (Res_Index .. Res_Index + 8) := \"task unit\";\n-               Res_Index := Res_Index + 9;\n-\n-            else\n-               Res (Res_Index .. Res_Index + 9) := \"subprogram\";\n-               Res_Index := Res_Index + 10;\n-            end if;\n-\n-            Msg_Index := Msg_Index + 10;\n-\n-         --  Otherwise copy the character\n-\n-         else\n-            Res (Res_Index) := Msg (Msg_Index);\n-            Msg_Index := Msg_Index + 1;\n-            Res_Index := Res_Index + 1;\n-         end if;\n-      end loop;\n-\n-      return Res (Res'First .. Res_Index - 1);\n-   end Fix_Msg;\n-\n    ------------------\n    -- Get_Argument --\n    ------------------\n@@ -27692,6 +27853,60 @@ package body Sem_Prag is\n       end loop;\n    end Record_Possible_Body_Reference;\n \n+   ------------------------------------------\n+   -- Relocate_Pragmas_To_Anonymous_Object --\n+   ------------------------------------------\n+\n+   procedure Relocate_Pragmas_To_Anonymous_Object\n+     (Typ_Decl : Node_Id;\n+      Obj_Decl : Node_Id)\n+   is\n+      Decl      : Node_Id;\n+      Def       : Node_Id;\n+      Next_Decl : Node_Id;\n+\n+   begin\n+      if Nkind (Typ_Decl) = N_Protected_Type_Declaration then\n+         Def := Protected_Definition (Typ_Decl);\n+      else\n+         pragma Assert (Nkind (Typ_Decl) = N_Task_Type_Declaration);\n+         Def := Task_Definition (Typ_Decl);\n+      end if;\n+\n+      --  The concurrent definition has a visible declaration list. Inspect it\n+      --  and relocate all canidate pragmas.\n+\n+      if Present (Def) and then Present (Visible_Declarations (Def)) then\n+         Decl := First (Visible_Declarations (Def));\n+         while Present (Decl) loop\n+\n+            --  Preserve the following declaration for iteration purposes due\n+            --  to possible relocation of a pragma.\n+\n+            Next_Decl := Next (Decl);\n+\n+            if Nkind (Decl) = N_Pragma\n+              and then Pragma_On_Anonymous_Object_OK (Get_Pragma_Id (Decl))\n+            then\n+               Remove (Decl);\n+               Insert_After (Obj_Decl, Decl);\n+\n+            --  Skip internally generated code\n+\n+            elsif not Comes_From_Source (Decl) then\n+               null;\n+\n+            --  No candidate pragmas are available for relocation\n+\n+            else\n+               exit;\n+            end if;\n+\n+            Decl := Next_Decl;\n+         end loop;\n+      end if;\n+   end Relocate_Pragmas_To_Anonymous_Object;\n+\n    ------------------------------\n    -- Relocate_Pragmas_To_Body --\n    ------------------------------"}, {"sha": "7ec4ebb31e00070abe17f0cd8608dab2b0efeb17", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -151,10 +151,20 @@ package Sem_Prag is\n       Pragma_Type_Invariant_Class      => True,\n       others                           => False);\n \n+   --  The following table lists all the implementation-defined pragmas that\n+   --  should apply to the anonymous object produced by the analysis of a\n+   --  single protected or task type. The table should be synchronized with\n+   --  Aspect_On_Anonymous_Object_OK in unit Aspects.\n+\n+   Pragma_On_Anonymous_Object_OK : constant array (Pragma_Id) of Boolean :=\n+     (Pragma_Depends => True,\n+      Pragma_Global  => True,\n+      Pragma_Part_Of => True,\n+      others         => False);\n+\n    --  The following table lists all the implementation-defined pragmas that\n    --  may apply to a body stub (no language defined pragmas apply). The table\n-   --  should be synchronized with Aspect_On_Body_Or_Stub_OK in unit Aspects if\n-   --  the pragmas below implement an aspect.\n+   --  should be synchronized with Aspect_On_Body_Or_Stub_OK in unit Aspects.\n \n    Pragma_On_Body_Or_Stub_OK : constant array (Pragma_Id) of Boolean :=\n      (Pragma_Refined_Depends => True,\n@@ -195,9 +205,11 @@ package Sem_Prag is\n    procedure Analyze_Initializes_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Initializes\n \n+   procedure Analyze_Part_Of_In_Decl_Part (N : Node_Id);\n+   --  Perform full analysis of delayed pragma Part_Of\n+\n    procedure Analyze_Pre_Post_Condition_In_Decl_Part (N : Node_Id);\n-   --  Perform preanalysis of [refined] precondition or postcondition pragma\n-   --  N that appears on a subprogram declaration or body [stub].\n+   --  Perform full analysis of pragmas Precondition and Postcondition\n \n    procedure Analyze_Refined_Depends_In_Decl_Part (N : Node_Id);\n    --  Preform full analysis of delayed pragma Refined_Depends. This routine\n@@ -436,6 +448,14 @@ package Sem_Prag is\n    --  Suppress_All at this stage, since it can appear after the unit instead\n    --  of before (actually we allow it to appear anywhere).\n \n+   procedure Relocate_Pragmas_To_Anonymous_Object\n+     (Typ_Decl : Node_Id;\n+      Obj_Decl : Node_Id);\n+   --  Relocate all pragmas that appear in the visible declarations of task or\n+   --  protected type declaration Typ_Decl after the declaration of anonymous\n+   --  object Obj_Decl. Table Pragmas_On_Anonymous_Object_OK contains the list\n+   --  of candidate pragmas.\n+\n    procedure Relocate_Pragmas_To_Body\n      (Subp_Body   : Node_Id;\n       Target_Body : Node_Id := Empty);"}, {"sha": "3125b372d1fac460d79666c21aaf1a3ee2bbe8c0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 405, "deletions": 107, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -4951,75 +4951,71 @@ package body Sem_Util is\n    ---------------------\n \n    function Defining_Entity (N : Node_Id) return Entity_Id is\n-      K   : constant Node_Kind := Nkind (N);\n       Err : Entity_Id := Empty;\n \n    begin\n-      case K is\n-         when\n-           N_Subprogram_Declaration                 |\n-           N_Abstract_Subprogram_Declaration        |\n-           N_Subprogram_Body                        |\n-           N_Package_Declaration                    |\n-           N_Subprogram_Renaming_Declaration        |\n-           N_Subprogram_Body_Stub                   |\n-           N_Generic_Subprogram_Declaration         |\n-           N_Generic_Package_Declaration            |\n-           N_Formal_Subprogram_Declaration          |\n-           N_Expression_Function\n+      case Nkind (N) is\n+         when N_Abstract_Subprogram_Declaration        |\n+              N_Expression_Function                    |\n+              N_Formal_Subprogram_Declaration          |\n+              N_Generic_Package_Declaration            |\n+              N_Generic_Subprogram_Declaration         |\n+              N_Package_Declaration                    |\n+              N_Subprogram_Body                        |\n+              N_Subprogram_Body_Stub                   |\n+              N_Subprogram_Declaration                 |\n+              N_Subprogram_Renaming_Declaration\n          =>\n             return Defining_Entity (Specification (N));\n \n-         when\n-           N_Component_Declaration                  |\n-           N_Defining_Program_Unit_Name             |\n-           N_Discriminant_Specification             |\n-           N_Entry_Body                             |\n-           N_Entry_Declaration                      |\n-           N_Entry_Index_Specification              |\n-           N_Exception_Declaration                  |\n-           N_Exception_Renaming_Declaration         |\n-           N_Formal_Object_Declaration              |\n-           N_Formal_Package_Declaration             |\n-           N_Formal_Type_Declaration                |\n-           N_Full_Type_Declaration                  |\n-           N_Implicit_Label_Declaration             |\n-           N_Incomplete_Type_Declaration            |\n-           N_Loop_Parameter_Specification           |\n-           N_Number_Declaration                     |\n-           N_Object_Declaration                     |\n-           N_Object_Renaming_Declaration            |\n-           N_Package_Body_Stub                      |\n-           N_Parameter_Specification                |\n-           N_Private_Extension_Declaration          |\n-           N_Private_Type_Declaration               |\n-           N_Protected_Body                         |\n-           N_Protected_Body_Stub                    |\n-           N_Protected_Type_Declaration             |\n-           N_Single_Protected_Declaration           |\n-           N_Single_Task_Declaration                |\n-           N_Subtype_Declaration                    |\n-           N_Task_Body                              |\n-           N_Task_Body_Stub                         |\n-           N_Task_Type_Declaration\n+         when N_Component_Declaration                  |\n+              N_Defining_Program_Unit_Name             |\n+              N_Discriminant_Specification             |\n+              N_Entry_Body                             |\n+              N_Entry_Declaration                      |\n+              N_Entry_Index_Specification              |\n+              N_Exception_Declaration                  |\n+              N_Exception_Renaming_Declaration         |\n+              N_Formal_Object_Declaration              |\n+              N_Formal_Package_Declaration             |\n+              N_Formal_Type_Declaration                |\n+              N_Full_Type_Declaration                  |\n+              N_Implicit_Label_Declaration             |\n+              N_Incomplete_Type_Declaration            |\n+              N_Loop_Parameter_Specification           |\n+              N_Number_Declaration                     |\n+              N_Object_Declaration                     |\n+              N_Object_Renaming_Declaration            |\n+              N_Package_Body_Stub                      |\n+              N_Parameter_Specification                |\n+              N_Private_Extension_Declaration          |\n+              N_Private_Type_Declaration               |\n+              N_Protected_Body                         |\n+              N_Protected_Body_Stub                    |\n+              N_Protected_Type_Declaration             |\n+              N_Single_Protected_Declaration           |\n+              N_Single_Task_Declaration                |\n+              N_Subtype_Declaration                    |\n+              N_Task_Body                              |\n+              N_Task_Body_Stub                         |\n+              N_Task_Type_Declaration\n          =>\n             return Defining_Identifier (N);\n \n          when N_Subunit =>\n             return Defining_Entity (Proper_Body (N));\n \n-         when\n-           N_Function_Instantiation                 |\n-           N_Function_Specification                 |\n-           N_Generic_Function_Renaming_Declaration  |\n-           N_Generic_Package_Renaming_Declaration   |\n-           N_Generic_Procedure_Renaming_Declaration |\n-           N_Package_Body                           |\n-           N_Package_Instantiation                  |\n-           N_Package_Renaming_Declaration           |\n-           N_Package_Specification                  |\n-           N_Procedure_Instantiation                |\n-           N_Procedure_Specification\n+         when N_Function_Instantiation                 |\n+              N_Function_Specification                 |\n+              N_Generic_Function_Renaming_Declaration  |\n+              N_Generic_Package_Renaming_Declaration   |\n+              N_Generic_Procedure_Renaming_Declaration |\n+              N_Package_Body                           |\n+              N_Package_Instantiation                  |\n+              N_Package_Renaming_Declaration           |\n+              N_Package_Specification                  |\n+              N_Procedure_Instantiation                |\n+              N_Procedure_Specification\n          =>\n             declare\n                Nam : constant Node_Id := Defining_Unit_Name (N);\n@@ -5028,8 +5024,8 @@ package body Sem_Util is\n                if Nkind (Nam) in N_Entity then\n                   return Nam;\n \n-               --  For Error, make up a name and attach to declaration\n-               --  so we can continue semantic analysis\n+               --  For Error, make up a name and attach to declaration so we\n+               --  can continue semantic analysis.\n \n                elsif Nam = Error then\n                   Err := Make_Temporary (Sloc (N), 'T');\n@@ -5044,10 +5040,8 @@ package body Sem_Util is\n                end if;\n             end;\n \n-         when\n-           N_Block_Statement                        |\n-           N_Loop_Statement\n-         =>\n+         when N_Block_Statement                        |\n+              N_Loop_Statement                         =>\n             return Entity (Identifier (N));\n \n          when others =>\n@@ -7088,6 +7082,70 @@ package body Sem_Util is\n       end if;\n    end First_Actual;\n \n+   -------------\n+   -- Fix_Msg --\n+   -------------\n+\n+   function Fix_Msg (Id : Entity_Id; Msg : String) return String is\n+      Is_Task   : constant Boolean :=\n+                    Ekind_In (Id, E_Task_Body, E_Task_Type)\n+                      or else (Is_Single_Concurrent_Object (Id)\n+                                and then Ekind (Etype (Id)) = E_Task_Type);\n+      Msg_Last  : constant Natural := Msg'Last;\n+      Msg_Index : Natural;\n+      Res       : String (Msg'Range) := (others => ' ');\n+      Res_Index : Natural;\n+\n+   begin\n+      --  Copy all characters from the input message Msg to result Res with\n+      --  suitable replacements.\n+\n+      Msg_Index := Msg'First;\n+      Res_Index := Res'First;\n+      while Msg_Index <= Msg_Last loop\n+\n+         --  Replace \"subprogram\" with a different word\n+\n+         if Msg_Index <= Msg_Last - 10\n+           and then Msg (Msg_Index .. Msg_Index + 9) = \"subprogram\"\n+         then\n+            if Ekind_In (Id, E_Entry, E_Entry_Family) then\n+               Res (Res_Index .. Res_Index + 4) := \"entry\";\n+               Res_Index := Res_Index + 5;\n+\n+            elsif Is_Task then\n+               Res (Res_Index .. Res_Index + 8) := \"task unit\";\n+               Res_Index := Res_Index + 9;\n+\n+            else\n+               Res (Res_Index .. Res_Index + 9) := \"subprogram\";\n+               Res_Index := Res_Index + 10;\n+            end if;\n+\n+            Msg_Index := Msg_Index + 10;\n+\n+         --  Replace \"protected\" with a different word\n+\n+         elsif Msg_Index <= Msg_Last - 9\n+           and then Msg (Msg_Index .. Msg_Index + 8) = \"protected\"\n+           and then Is_Task\n+         then\n+            Res (Res_Index .. Res_Index + 3) := \"task\";\n+            Res_Index := Res_Index + 4;\n+            Msg_Index := Msg_Index + 9;\n+\n+         --  Otherwise copy the character\n+\n+         else\n+            Res (Res_Index) := Msg (Msg_Index);\n+            Msg_Index := Msg_Index + 1;\n+            Res_Index := Res_Index + 1;\n+         end if;\n+      end loop;\n+\n+      return Res (Res'First .. Res_Index - 1);\n+   end Fix_Msg;\n+\n    -----------------------\n    -- Gather_Components --\n    -----------------------\n@@ -8740,6 +8798,92 @@ package body Sem_Util is\n       end if;\n    end Has_Enabled_Property;\n \n+   -------------------------------------\n+   -- Has_Full_Default_Initialization --\n+   -------------------------------------\n+\n+   function Has_Full_Default_Initialization (Typ : Entity_Id) return Boolean is\n+      Comp : Entity_Id;\n+\n+   begin\n+      --  A scalar type is fully default initialized if it is subjec to aspect\n+      --  Default_Value.\n+\n+      if Is_Scalar_Type (Typ) then\n+         return Has_Default_Aspect (Typ);\n+\n+      --  An array type is fully default initialized if its element type is\n+      --  scalar and the array type carries aspect Default_Component_Value or\n+      --  the element type is fully default initialized.\n+\n+      elsif Is_Array_Type (Typ) then\n+         return\n+           Has_Default_Aspect (Typ)\n+             or else Has_Full_Default_Initialization (Component_Type (Typ));\n+\n+      --  A protected type, record type or type extension is fully default\n+      --  initialized if all its components either carry an initialization\n+      --  expression or have a type that is fully default initialized. The\n+      --  parent type of a type extension must be fully default initialized.\n+\n+      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n+\n+         --  Inspect all entities defined in the scope of the type, looking for\n+         --  uninitialized components.\n+\n+         Comp := First_Entity (Typ);\n+         while Present (Comp) loop\n+            if Ekind (Comp) = E_Component\n+              and then Comes_From_Source (Comp)\n+              and then No (Expression (Parent (Comp)))\n+              and then not Has_Full_Default_Initialization (Etype (Comp))\n+            then\n+               return False;\n+            end if;\n+\n+            Next_Entity (Comp);\n+         end loop;\n+\n+         --  Ensure that the parent type of a type extension is fully default\n+         --  initialized.\n+\n+         if Etype (Typ) /= Typ\n+           and then not Has_Full_Default_Initialization (Etype (Typ))\n+         then\n+            return False;\n+         end if;\n+\n+         --  If we get here, then all components and parent portion are fully\n+         --  default initialized.\n+\n+         return True;\n+\n+      --  A task type is fully default initialized by default\n+\n+      elsif Is_Task_Type (Typ) then\n+         return True;\n+      end if;\n+\n+      --  A private type and by extension its full view is fully default\n+      --  initialized if it is subject to pragma Default_Initial_Condition\n+      --  with a non-null argument or inherits the pragma from a parent type.\n+      --  Since any type can act as the full view of a private type, this check\n+      --  is separated from the circuitry above.\n+\n+      if Has_Default_Init_Cond (Typ)\n+        or else Has_Inherited_Default_Init_Cond (Typ)\n+      then\n+         return\n+           Nkind (First (Pragma_Argument_Associations (Get_Pragma\n+             (Typ, Pragma_Default_Initial_Condition)))) /= N_Null;\n+\n+      --  Otherwise the type is not fully default initialized\n+\n+      else\n+         return False;\n+      end if;\n+   end Has_Full_Default_Initialization;\n+\n    --------------------\n    -- Has_Infinities --\n    --------------------\n@@ -11357,6 +11501,42 @@ package body Sem_Util is\n       end if;\n    end Is_Descendent_Of;\n \n+   ----------------------------------------\n+   -- Is_Descendant_Of_Suspension_Object --\n+   ----------------------------------------\n+\n+   function Is_Descendant_Of_Suspension_Object\n+     (Typ : Entity_Id) return Boolean\n+   is\n+      Cur_Typ : Entity_Id;\n+      Par_Typ : Entity_Id;\n+\n+   begin\n+      --  Climb the type derivation chain checking each parent type against\n+      --  Suspension_Object.\n+\n+      Cur_Typ := Base_Type (Typ);\n+      while Present (Cur_Typ) loop\n+         Par_Typ := Etype (Cur_Typ);\n+\n+         --  The current type is a match\n+\n+         if Is_Suspension_Object (Cur_Typ) then\n+            return True;\n+\n+         --  Stop the traversal once the root of the derivation chain has been\n+         --  reached. In that case the current type is its own base type.\n+\n+         elsif Cur_Typ = Par_Typ then\n+            exit;\n+         end if;\n+\n+         Cur_Typ := Base_Type (Par_Typ);\n+      end loop;\n+\n+      return False;\n+   end Is_Descendant_Of_Suspension_Object;\n+\n    ---------------------------------------------\n    -- Is_Double_Precision_Floating_Point_Type --\n    ---------------------------------------------\n@@ -11376,50 +11556,6 @@ package body Sem_Util is\n    -----------------------------\n \n    function Is_Effectively_Volatile (Id : Entity_Id) return Boolean is\n-      function Is_Descendant_Of_Suspension_Object\n-        (Typ : Entity_Id) return Boolean;\n-      --  Determine whether type Typ is a descendant of type Suspension_Object\n-      --  defined in Ada.Synchronous_Task_Control.\n-\n-      ----------------------------------------\n-      -- Is_Descendant_Of_Suspension_Object --\n-      ----------------------------------------\n-\n-      function Is_Descendant_Of_Suspension_Object\n-        (Typ : Entity_Id) return Boolean\n-      is\n-         Cur_Typ : Entity_Id;\n-         Par_Typ : Entity_Id;\n-\n-      begin\n-         --  Climb the type derivation chain checking each parent type against\n-         --  Suspension_Object.\n-\n-         Cur_Typ := Base_Type (Typ);\n-         while Present (Cur_Typ) loop\n-            Par_Typ := Etype (Cur_Typ);\n-\n-            --  The current type is a match\n-\n-            if Is_Suspension_Object (Cur_Typ) then\n-               return True;\n-\n-            --  Stop the traversal once the root of the derivation chain has\n-            --  been reached. In that case the current type is its own base\n-            --  type.\n-\n-            elsif Cur_Typ = Par_Typ then\n-               exit;\n-            end if;\n-\n-            Cur_Typ := Base_Type (Par_Typ);\n-         end loop;\n-\n-         return False;\n-      end Is_Descendant_Of_Suspension_Object;\n-\n-   --  Start of processing for Is_Effectively_Volatile\n-\n    begin\n       if Is_Type (Id) then\n \n@@ -12969,6 +13105,41 @@ package body Sem_Util is\n       end if;\n    end Is_Selector_Name;\n \n+   ---------------------------------\n+   -- Is_Single_Concurrent_Object --\n+   ---------------------------------\n+\n+   function Is_Single_Concurrent_Object (Id : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Ekind (Id) = E_Variable\n+          and then Is_Single_Concurrent_Type (Etype (Id));\n+   end Is_Single_Concurrent_Object;\n+\n+   -------------------------------\n+   -- Is_Single_Concurrent_Type --\n+   -------------------------------\n+\n+   function Is_Single_Concurrent_Type (Id : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Ekind_In (Id, E_Protected_Type, E_Task_Type)\n+          and then Is_Single_Concurrent_Type_Declaration\n+                     (Declaration_Node (Id));\n+   end Is_Single_Concurrent_Type;\n+\n+   -------------------------------------------\n+   -- Is_Single_Concurrent_Type_Declaration --\n+   -------------------------------------------\n+\n+   function Is_Single_Concurrent_Type_Declaration\n+     (N : Node_Id) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Original_Node (N), N_Single_Protected_Declaration,\n+                                          N_Single_Task_Declaration);\n+   end Is_Single_Concurrent_Type_Declaration;\n+\n    ---------------------------------------------\n    -- Is_Single_Precision_Floating_Point_Type --\n    ---------------------------------------------\n@@ -13231,6 +13402,49 @@ package body Sem_Util is\n           and then Scope (Scope (Scope (Id))) = Standard_Standard;\n    end Is_Suspension_Object;\n \n+   ----------------------------\n+   -- Is_Synchronized_Object --\n+   ----------------------------\n+\n+   function Is_Synchronized_Object (Id : Entity_Id) return Boolean is\n+      Prag : Node_Id;\n+\n+   begin\n+      if Is_Object (Id) then\n+\n+         --  The object is synchronized if it is of a type that yields a\n+         --  synchronized object.\n+\n+         if Yields_Synchronized_Object (Etype (Id)) then\n+            return True;\n+\n+         --  The object is synchronized if it is atomic and Async_Writers is\n+         --  enabled.\n+\n+         elsif Is_Atomic (Id) and then Async_Writers_Enabled (Id) then\n+            return True;\n+\n+         --  A constant is a synchronized object by default\n+\n+         elsif Ekind (Id) = E_Constant then\n+            return True;\n+\n+         --  A variable is a synchronized object if it is subject to pragma\n+         --  Constant_After_Elaboration.\n+\n+         elsif Ekind (Id) = E_Variable then\n+            Prag := Get_Pragma (Id, Pragma_Constant_After_Elaboration);\n+\n+            return Present (Prag) and then Is_Enabled_Pragma (Prag);\n+         end if;\n+      end if;\n+\n+      --  Otherwise the input is not an object or it does not qualify as a\n+      --  synchronized object.\n+\n+      return False;\n+   end Is_Synchronized_Object;\n+\n    ---------------------------------\n    -- Is_Synchronized_Tagged_Type --\n    ---------------------------------\n@@ -19880,4 +20094,88 @@ package body Sem_Util is\n       end if;\n    end Wrong_Type;\n \n+   --------------------------------\n+   -- Yields_Synchronized_Object --\n+   --------------------------------\n+\n+   function Yields_Synchronized_Object (Typ : Entity_Id) return Boolean is\n+      Id : Entity_Id;\n+\n+   begin\n+      --  An array type yields a synchronized object if its component type\n+      --  yields a synchronized object.\n+\n+      if Is_Array_Type (Typ) then\n+         return Yields_Synchronized_Object (Component_Type (Typ));\n+\n+      --  A descendant of type Ada.Synchronous_Task_Control.Suspension_Object\n+      --  yields a synchronized object by default.\n+\n+      elsif Is_Descendant_Of_Suspension_Object (Typ) then\n+         return True;\n+\n+      --  A protected type yields a synchronized object by default\n+\n+      elsif Is_Protected_Type (Typ) then\n+         return True;\n+\n+      --  A record type or type extension yields a synchronized object when its\n+      --  discriminants (if any) lack default values and all components are of\n+      --  a type that yelds a synchronized object.\n+\n+      elsif Is_Record_Type (Typ) then\n+\n+         --  Inspect all entities defined in the scope of the type, looking for\n+         --  components of a type that does not yeld a synchronized object or\n+         --  for discriminants with default values.\n+\n+         Id := First_Entity (Typ);\n+         while Present (Id) loop\n+            if Comes_From_Source (Id) then\n+               if Ekind (Id) = E_Component\n+                 and then not Yields_Synchronized_Object (Etype (Id))\n+               then\n+                  return False;\n+\n+               elsif Ekind (Id) = E_Discriminant\n+                 and then Present (Expression (Parent (Id)))\n+               then\n+                  return False;\n+               end if;\n+            end if;\n+\n+            Next_Entity (Id);\n+         end loop;\n+\n+         --  Ensure that the parent type of a type extension yields a\n+         --  synchronized object.\n+\n+         if Etype (Typ) /= Typ\n+           and then not Yields_Synchronized_Object (Etype (Typ))\n+         then\n+            return False;\n+         end if;\n+\n+         --  If we get here, then all discriminants lack default values and all\n+         --  components are of a type that yields a synchronized object.\n+\n+         return True;\n+\n+      --  A synchronized interface type yields a synchronized object by default\n+\n+      elsif Is_Synchronized_Interface (Typ) then\n+         return True;\n+\n+      --  A task type yelds a synchronized object by default\n+\n+      elsif Is_Task_Type (Typ) then\n+         return True;\n+\n+      --  Otherwise the type does not yield a synchronized object\n+\n+      else\n+         return False;\n+      end if;\n+   end Yields_Synchronized_Object;\n+\n end Sem_Util;"}, {"sha": "95534d948d7ad7e87cd881e1c46024f8febe684e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -765,6 +765,17 @@ package Sem_Util is\n    --  Note that the value returned is always the expression (not the\n    --  N_Parameter_Association nodes, even if named association is used).\n \n+   function Fix_Msg (Id : Entity_Id; Msg : String) return String;\n+   --  Replace all occurrences of a particular word in string Msg depending on\n+   --  the Ekind of Id as follows:\n+   --    * Replace \"subprogram\" with\n+   --      - \"entry\" when Id is an entry [family]\n+   --      - \"task unit\" when Id is a single task object, task type or task\n+   --         body.\n+   --    * Replace \"protected\" with\n+   --      - \"task\" when Id is a single task object, task type or task body\n+   --  All other non-matching words remain as is\n+\n    procedure Gather_Components\n      (Typ           : Entity_Id;\n       Comp_List     : Node_Id;\n@@ -953,9 +964,6 @@ package Sem_Util is\n    --  as an access type internally, this function tests only for access types\n    --  known to the programmer. See also Has_Tagged_Component.\n \n-   function Has_Defaulted_Discriminants (Typ : Entity_Id) return Boolean;\n-   --  Simple predicate to test for defaulted discriminants\n-\n    type Alignment_Result is (Known_Compatible, Unknown, Known_Incompatible);\n    --  Result of Has_Compatible_Alignment test, description found below. Note\n    --  that the values are arranged in increasing order of problematicness.\n@@ -983,6 +991,9 @@ package Sem_Util is\n    function Has_Declarations (N : Node_Id) return Boolean;\n    --  Determines if the node can have declarations\n \n+   function Has_Defaulted_Discriminants (Typ : Entity_Id) return Boolean;\n+   --  Simple predicate to test for defaulted discriminants\n+\n    function Has_Denormals (E : Entity_Id) return Boolean;\n    --  Determines if the floating-point type E supports denormal numbers.\n    --  Returns False if E is not a floating-point type.\n@@ -997,6 +1008,19 @@ package Sem_Util is\n    --  Determine whether subprogram Subp_Id has an effectively volatile formal\n    --  parameter or returns an effectively volatile value.\n \n+   function Has_Full_Default_Initialization (Typ : Entity_Id) return Boolean;\n+   --  Determine whether type Typ defines \"full default initialization\" as\n+   --  specified by SPARK RM 3.1. To qualify as such, the type must be\n+   --    * A scalar type with specified Default_Value\n+   --    * An array-of-scalar type with specified Default_Component_Value\n+   --    * An array type whose element type defines full default initialization\n+   --    * A protected type, record type or type extension whose components\n+   --      either include a default expression or have a type which defines\n+   --      full default initialization. In the case of type extensions, the\n+   --      parent type defines full default initialization.\n+   --   * A task type\n+   --   * A private type whose Default_Initial_Condition is non-null\n+\n    function Has_Infinities (E : Entity_Id) return Boolean;\n    --  Determines if the range of the floating-point type E includes\n    --  infinities. Returns False if E is not a floating-point type.\n@@ -1274,6 +1298,13 @@ package Sem_Util is\n    --  This is the RM definition, a type is a descendent of another type if it\n    --  is the same type or is derived from a descendent of the other type.\n \n+   function Is_Descendant_Of_Suspension_Object\n+     (Typ : Entity_Id) return Boolean;\n+   --  Determine whether type Typ is a descendant of type Suspension_Object\n+   --  defined in Ada.Synchronous_Task_Control. This version is different from\n+   --  Is_Descendent_Of as the detection of Suspension_Object does not involve\n+   --  an entity and by extension a call to RTSfind.\n+\n    function Is_Double_Precision_Floating_Point_Type\n      (E : Entity_Id) return Boolean;\n    --  Return whether E is a double precision floating point type,\n@@ -1463,6 +1494,18 @@ package Sem_Util is\n    --  represent use of the N_Identifier node for a true identifier, when\n    --  normally such nodes represent a direct name.\n \n+   function Is_Single_Concurrent_Object (Id : Entity_Id) return Boolean;\n+   --  Determine whether arbitrary entity Id denotes the anonymous object\n+   --  created for a single protected or single task type.\n+\n+   function Is_Single_Concurrent_Type (Id : Entity_Id) return Boolean;\n+   --  Determine whether arbitrary entity Id denotes a single protected or\n+   --  single task type.\n+\n+   function Is_Single_Concurrent_Type_Declaration (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes the declaration of a single\n+   --  protected type or single task type.\n+\n    function Is_Single_Precision_Floating_Point_Type\n      (E : Entity_Id) return Boolean;\n    --  Return whether E is a single precision floating point type,\n@@ -1520,6 +1563,15 @@ package Sem_Util is\n    --  Determine whether arbitrary entity Id denotes Suspension_Object defined\n    --  in Ada.Synchronous_Task_Control.\n \n+   function Is_Synchronized_Object (Id : Entity_Id) return Boolean;\n+   --  Determine whether entity Id denotes an object and if it does, whether\n+   --  this object is synchronized as specified in SPARK RM 9.1. To qualify as\n+   --  such, the object must be\n+   --    * Of a type that yields a synchronized object\n+   --    * An atomic object with enabled Async_Writers\n+   --    * A constant\n+   --    * A variable subject to pragma Constant_After_Elaboration\n+\n    function Is_Synchronized_Tagged_Type (E : Entity_Id) return Boolean;\n    --  Returns True if E is a synchronized tagged type (AARM 3.9.4 (6/2))\n \n@@ -2161,4 +2213,15 @@ package Sem_Util is\n    --  does not have to be a subexpression, anything with an Etype field may\n    --  be used.\n \n+   function Yields_Synchronized_Object (Typ : Entity_Id) return Boolean;\n+   --  Determine whether type Typ \"yields synchronized object\" as specified by\n+   --  SPARK RM 9.1. To qualify as such, a type must be\n+   --    * An array type whose element type yields a synchronized object\n+   --    * A descendant of type Ada.Synchronous_Task_Control.Suspension_Object\n+   --    * A protected type\n+   --    * A record type or type extension without defaulted discriminants\n+   --      whose components are of a type that yields a synchronized object.\n+   --    * A synchronized interface type\n+   --    * A task type\n+\n end Sem_Util;"}, {"sha": "6d9ca7df3ca15af037c62bc1b8c9bdf4568d2c30", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b87c163fccf0fb5ae07c0d34678949c90414f6/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=75b87c163fccf0fb5ae07c0d34678949c90414f6", "patch": "@@ -788,6 +788,7 @@ package Snames is\n    Name_Strict                         : constant Name_Id := N + $;\n    Name_Subunit_File_Name              : constant Name_Id := N + $;\n    Name_Suppressed                     : constant Name_Id := N + $;\n+   Name_Synchronous                    : constant Name_Id := N + $;\n    Name_Task_Stack_Size_Default        : constant Name_Id := N + $;\n    Name_Task_Type                      : constant Name_Id := N + $;\n    Name_Time_Slicing_Enabled           : constant Name_Id := N + $;"}]}