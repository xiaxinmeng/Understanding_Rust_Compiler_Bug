{"sha": "94f56408db96e2e12f6e1322ed2c1c465df934f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRmNTY0MDhkYjk2ZTJlMTJmNmUxMzIyZWQyYzFjNDY1ZGY5MzRmNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-28T22:34:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-28T22:34:47Z"}, "message": "compiler, runtime: copy slice code from Go 1.7 runtime\n    \n    Change the compiler handle append as the gc compiler does: call a\n    function to grow the slice, but otherwise assign the new elements\n    directly to the final slice.\n    \n    For the current gccgo memory allocator the slice code has to call\n    runtime_newarray, not mallocgc directly, so that the allocator sets the\n    TypeInfo_Array bit in the type pointer.\n    \n    Rename the static function cnew to runtime_docnew, so that the stack\n    trace ignores it when ignoring runtime functions.  This was needed to\n    fix the runtime/pprof tests on 386.\n    \n    Reviewed-on: https://go-review.googlesource.com/32218\n\nFrom-SVN: r241667", "tree": {"sha": "f5eaac76bc47cc2637e5e30b9ff6c27499fac2d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5eaac76bc47cc2637e5e30b9ff6c27499fac2d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94f56408db96e2e12f6e1322ed2c1c465df934f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f56408db96e2e12f6e1322ed2c1c465df934f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94f56408db96e2e12f6e1322ed2c1c465df934f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f56408db96e2e12f6e1322ed2c1c465df934f6/comments", "author": null, "committer": null, "parents": [{"sha": "21f1031d6cc228e2b468338b3dfa4303d54ac207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f1031d6cc228e2b468338b3dfa4303d54ac207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21f1031d6cc228e2b468338b3dfa4303d54ac207"}], "stats": {"total": 1133, "additions": 661, "deletions": 472}, "files": [{"sha": "4d047056cbb6105b557cdb600b8e6e9a948eccef", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -1,4 +1,4 @@\n-5ddcdfb0b2bb992a70b391ab34bf15291a514e48\n+fe38baff61b9b9426a4f60ff078cf3c8722bf94d\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "bcea63d5a6e9a84613697eb510dbe868caec9a3b", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -284,20 +284,19 @@ Node::op_format() const\n \t\t  op << \"panic\";\n \t\t  break;\n \n-\t\tcase Runtime::APPEND:\n+\t\tcase Runtime::GROWSLICE:\n \t\t  op << \"append\";\n \t\t  break;\n \n-\t\tcase Runtime::COPY:\n+\t\tcase Runtime::SLICECOPY:\n+\t\tcase Runtime::SLICESTRINGCOPY:\n+\t\tcase Runtime::TYPEDSLICECOPY:\n \t\t  op << \"copy\";\n \t\t  break;\n \n \t\tcase Runtime::MAKECHAN:\n \t\tcase Runtime::MAKEMAP:\n-\t\tcase Runtime::MAKESLICE1:\n-\t\tcase Runtime::MAKESLICE2:\n-\t\tcase Runtime::MAKESLICE1BIG:\n-\t\tcase Runtime::MAKESLICE2BIG:\n+\t\tcase Runtime::MAKESLICE:\n \t\t  op << \"make\";\n \t\t  break;\n \n@@ -419,10 +418,7 @@ Node::is_big(Escape_context* context) const\n \t  Func_expression* fn = call->fn()->func_expression();\n \t  if (fn != NULL\n \t      && fn->is_runtime_function()\n-\t      && (fn->runtime_code() == Runtime::MAKESLICE1\n-\t\t  || fn->runtime_code() == Runtime::MAKESLICE2\n-\t\t  || fn->runtime_code() == Runtime::MAKESLICE1BIG\n-\t\t  || fn->runtime_code() == Runtime::MAKESLICE2BIG))\n+\t      && fn->runtime_code() == Runtime::MAKESLICE)\n \t    {\n \t      // Second argument is length.\n \t      Expression_list::iterator p = call->args()->begin();\n@@ -1201,13 +1197,25 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t\t}\n \t\tbreak;\n \n-\t      case Runtime::APPEND:\n+\t      case Runtime::GROWSLICE:\n \t\t{\n-\t\t  // Unlike gc/esc.go, a call to append has already had its\n-\t\t  // varargs lowered into a slice of arguments.\n-\t\t  // The content of the appended slice leaks.\n-\t\t  Node* appended = Node::make_node(call->args()->back());\n-\t\t  this->assign_deref(this->context_->sink(), appended);\n+\t\t  // The contents being appended leak.\n+\t\t  if (call->is_varargs())\n+\t\t    {\n+\t\t      Node* appended = Node::make_node(call->args()->back());\n+\t\t      this->assign_deref(this->context_->sink(), appended);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      for (Expression_list::const_iterator pa =\n+\t\t\t     call->args()->begin();\n+\t\t\t   pa != call->args()->end();\n+\t\t\t   ++pa)\n+\t\t\t{\n+\t\t\t  Node* arg = Node::make_node(*pa);\n+\t\t\t  this->assign(this->context_->sink(), arg);\n+\t\t\t}\n+\t\t    }\n \n \t\t  if (debug_level > 2)\n \t\t    go_error_at((*pexpr)->location(),\n@@ -1219,7 +1227,9 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t\t}\n \t\tbreak;\n \n-\t      case Runtime::COPY:\n+\t      case Runtime::SLICECOPY:\n+\t      case Runtime::SLICESTRINGCOPY:\n+\t      case Runtime::TYPEDSLICECOPY:\n \t\t{\n \t\t  // Lose track of the copied content.\n \t\t  Node* copied = Node::make_node(call->args()->back());\n@@ -1229,10 +1239,7 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \n \t      case Runtime::MAKECHAN:\n \t      case Runtime::MAKEMAP:\n-\t      case Runtime::MAKESLICE1:\n-\t      case Runtime::MAKESLICE2:\n-\t      case Runtime::MAKESLICE1BIG:\n-\t      case Runtime::MAKESLICE2BIG:\n+\t      case Runtime::MAKESLICE:\n \t      case Runtime::SLICEBYTETOSTRING:\n \t      case Runtime::SLICERUNETOSTRING:\n \t      case Runtime::STRINGTOSLICEBYTE:\n@@ -1829,7 +1836,7 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t      {\n \t\tswitch (fe->runtime_code())\n \t\t  {\n-\t\t  case Runtime::APPEND:\n+\t\t  case Runtime::GROWSLICE:\n \t\t    {\n \t\t      // Append returns the first argument.\n \t\t      // The subsequent arguments are already leaked because\n@@ -1841,10 +1848,7 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \n \t\t  case Runtime::MAKECHAN:\n \t\t  case Runtime::MAKEMAP:\n-\t\t  case Runtime::MAKESLICE1:\n-\t\t  case Runtime::MAKESLICE2:\n-\t\t  case Runtime::MAKESLICE1BIG:\n-\t\t  case Runtime::MAKESLICE2BIG:\n+\t\t  case Runtime::MAKESLICE:\n \t\t    // DST = make(...).\n \t\t  case Runtime::SLICEBYTETOSTRING:\n \t\t    // DST = string([]byte{...}).\n@@ -2608,7 +2612,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t{\n \t\t  switch (func->runtime_code())\n \t\t    {\n-\t\t    case Runtime::APPEND:\n+\t\t    case Runtime::GROWSLICE:\n \t\t      {\n \t\t\t// Propagate escape information to appendee.\n \t\t\tExpression* appendee = call->args()->front();\n@@ -2618,10 +2622,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \n \t\t    case Runtime::MAKECHAN:\n \t\t    case Runtime::MAKEMAP:\n-\t\t    case Runtime::MAKESLICE1:\n-\t\t    case Runtime::MAKESLICE2:\n-\t\t    case Runtime::MAKESLICE1BIG:\n-\t\t    case Runtime::MAKESLICE2BIG:\n+\t\t    case Runtime::MAKESLICE:\n \t\t    case Runtime::SLICEBYTETOSTRING:\n \t\t    case Runtime::SLICERUNETOSTRING:\n \t\t    case Runtime::STRINGTOSLICEBYTE:"}, {"sha": "7f9d365b6e23a9af1f9f87383dba1d0c44bdbef4", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 358, "deletions": 176, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -6951,7 +6951,9 @@ class Builtin_call_expression : public Call_expression\n   complex_type(Type*);\n \n   Expression*\n-  lower_make();\n+  lower_make(Statement_inserter*);\n+\n+  Expression* flatten_append(Gogo*, Named_object*, Statement_inserter*);\n \n   bool\n   check_int_value(Expression*, bool is_length);\n@@ -7052,7 +7054,7 @@ Builtin_call_expression::do_set_recover_arg(Expression* arg)\n // specific expressions.  We also convert to a constant if we can.\n \n Expression*\n-Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n+Builtin_call_expression::do_lower(Gogo*, Named_object* function,\n \t\t\t\t  Statement_inserter* inserter, int)\n {\n   if (this->is_error_expression())\n@@ -7130,7 +7132,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n       break;\n \n     case BUILTIN_MAKE:\n-      return this->lower_make();\n+      return this->lower_make(inserter);\n \n     case BUILTIN_RECOVER:\n       if (function != NULL)\n@@ -7144,30 +7146,6 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t}\n       break;\n \n-    case BUILTIN_APPEND:\n-      {\n-\t// Lower the varargs.\n-\tconst Expression_list* args = this->args();\n-\tif (args == NULL || args->empty())\n-\t  return this;\n-\tType* slice_type = args->front()->type();\n-\tif (!slice_type->is_slice_type())\n-\t  {\n-\t    if (slice_type->is_nil_type())\n-\t      go_error_at(args->front()->location(), \"use of untyped nil\");\n-\t    else\n-\t      go_error_at(args->front()->location(),\n-\t\t\t  \"argument 1 must be a slice\");\n-\t    this->set_is_error();\n-\t    return this;\n-\t  }\n-\tType* element_type = slice_type->array_type()->element_type();\n-\tthis->lower_varargs(gogo, function, inserter,\n-\t\t\t    Type::make_array_type(element_type, NULL),\n-\t\t\t    2, SLICE_STORAGE_DOES_NOT_ESCAPE);\n-      }\n-      break;\n-\n     case BUILTIN_DELETE:\n       {\n \t// Lower to a runtime function call.\n@@ -7233,7 +7211,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n // append into temporary expressions.\n \n Expression*\n-Builtin_call_expression::do_flatten(Gogo*, Named_object*,\n+Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n                                     Statement_inserter* inserter)\n {\n   Location loc = this->location();\n@@ -7244,6 +7222,8 @@ Builtin_call_expression::do_flatten(Gogo*, Named_object*,\n       break;\n \n     case BUILTIN_APPEND:\n+      return this->flatten_append(gogo, function, inserter);\n+\n     case BUILTIN_COPY:\n       {\n \tType* at = this->args()->front()->type();\n@@ -7285,16 +7265,19 @@ Builtin_call_expression::do_flatten(Gogo*, Named_object*,\n \n     case BUILTIN_LEN:\n     case BUILTIN_CAP:\n-      Expression_list::iterator pa = this->args()->begin();\n-      if (!(*pa)->is_variable()\n-\t  && ((*pa)->type()->map_type() != NULL\n-\t      || (*pa)->type()->channel_type() != NULL))\n-\t{\n-\t  Temporary_statement* temp =\n-\t    Statement::make_temporary(NULL, *pa, loc);\n-\t  inserter->insert(temp);\n-\t  *pa = Expression::make_temporary_reference(temp, loc);\n-\t}\n+      {\n+\tExpression_list::iterator pa = this->args()->begin();\n+\tif (!(*pa)->is_variable()\n+\t    && ((*pa)->type()->map_type() != NULL\n+\t\t|| (*pa)->type()->channel_type() != NULL))\n+\t  {\n+\t    Temporary_statement* temp =\n+\t      Statement::make_temporary(NULL, *pa, loc);\n+\t    inserter->insert(temp);\n+\t    *pa = Expression::make_temporary_reference(temp, loc);\n+\t  }\n+      }\n+      break;\n     }\n \n   return this;\n@@ -7303,7 +7286,7 @@ Builtin_call_expression::do_flatten(Gogo*, Named_object*,\n // Lower a make expression.\n \n Expression*\n-Builtin_call_expression::lower_make()\n+Builtin_call_expression::lower_make(Statement_inserter* inserter)\n {\n   Location loc = this->location();\n \n@@ -7340,10 +7323,6 @@ Builtin_call_expression::lower_make()\n       return Expression::make_error(this->location());\n     }\n \n-  bool have_big_args = false;\n-  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n-  int uintptr_bits = uintptr_type->integer_type()->bits();\n-\n   Type_context int_context(Type::lookup_integer_type(\"int\"), false);\n \n   ++parg;\n@@ -7363,9 +7342,6 @@ Builtin_call_expression::lower_make()\n       len_arg->determine_type(&int_context);\n       if (!this->check_int_value(len_arg, true))\n \treturn Expression::make_error(this->location());\n-      if (len_arg->type()->integer_type() != NULL\n-\t  && len_arg->type()->integer_type()->bits() > uintptr_bits)\n-\thave_big_args = true;\n       ++parg;\n     }\n \n@@ -7391,9 +7367,6 @@ Builtin_call_expression::lower_make()\n \t  return Expression::make_error(this->location());\n \t}\n \n-      if (cap_arg->type()->integer_type() != NULL\n-\t  && cap_arg->type()->integer_type()->bits() > uintptr_bits)\n-\thave_big_args = true;\n       ++parg;\n     }\n \n@@ -7404,34 +7377,236 @@ Builtin_call_expression::lower_make()\n     }\n \n   Location type_loc = first_arg->location();\n-  Expression* type_arg = Expression::make_type_descriptor(type, type_loc);\n \n   Expression* call;\n   if (is_slice)\n     {\n+      Type* et = type->array_type()->element_type();\n+      Expression* type_arg = Expression::make_type_descriptor(et, type_loc);\n       if (cap_arg == NULL)\n-\tcall = Runtime::make_call((have_big_args\n-\t\t\t\t   ? Runtime::MAKESLICE1BIG\n-\t\t\t\t   : Runtime::MAKESLICE1),\n-\t\t\t\t  loc, 2, type_arg, len_arg);\n-      else\n-\tcall = Runtime::make_call((have_big_args\n-\t\t\t\t   ? Runtime::MAKESLICE2BIG\n-\t\t\t\t   : Runtime::MAKESLICE2),\n-\t\t\t\t  loc, 3, type_arg, len_arg, cap_arg);\n+\t{\n+\t  Temporary_statement* temp = Statement::make_temporary(NULL,\n+\t\t\t\t\t\t\t\tlen_arg,\n+\t\t\t\t\t\t\t\tloc);\n+\t  inserter->insert(temp);\n+\t  len_arg = Expression::make_temporary_reference(temp, loc);\n+\t  cap_arg = Expression::make_temporary_reference(temp, loc);\n+\t}\n+      call = Runtime::make_call(Runtime::MAKESLICE, loc, 3, type_arg,\n+\t\t\t\tlen_arg, cap_arg);\n     }\n   else if (is_map)\n-    call = Runtime::make_call(Runtime::MAKEMAP, loc, 4, type_arg, len_arg,\n-\t\t\t      Expression::make_nil(loc),\n-\t\t\t      Expression::make_nil(loc));\n+    {\n+      Expression* type_arg = Expression::make_type_descriptor(type, type_loc);\n+      call = Runtime::make_call(Runtime::MAKEMAP, loc, 4, type_arg, len_arg,\n+\t\t\t\tExpression::make_nil(loc),\n+\t\t\t\tExpression::make_nil(loc));\n+    }\n   else if (is_chan)\n-    call = Runtime::make_call(Runtime::MAKECHAN, loc, 2, type_arg, len_arg);\n+    {\n+      Expression* type_arg = Expression::make_type_descriptor(type, type_loc);\n+      call = Runtime::make_call(Runtime::MAKECHAN, loc, 2, type_arg, len_arg);\n+    }\n   else\n     go_unreachable();\n \n   return Expression::make_unsafe_cast(type, call, loc);\n }\n \n+// Flatten a call to the predeclared append function.  We do this in\n+// the flatten phase, not the lowering phase, so that we run after\n+// type checking and after order_evaluations.\n+\n+Expression*\n+Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n+\t\t\t\t\tStatement_inserter* inserter)\n+{\n+  if (this->is_error_expression())\n+    return this;\n+\n+  Location loc = this->location();\n+\n+  const Expression_list* args = this->args();\n+  go_assert(args != NULL && !args->empty());\n+\n+  Type* slice_type = args->front()->type();\n+  go_assert(slice_type->is_slice_type());\n+  Type* element_type = slice_type->array_type()->element_type();\n+\n+  if (args->size() == 1)\n+    {\n+      // append(s) evaluates to s.\n+      return args->front();\n+    }\n+\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  Type* uint_type = Type::lookup_integer_type(\"uint\");\n+\n+  // Implementing\n+  //   append(s1, s2...)\n+  // or\n+  //   append(s1, a1, a2, a3, ...)\n+\n+  // s1tmp := s1\n+  Temporary_statement* s1tmp = Statement::make_temporary(NULL, args->front(),\n+\t\t\t\t\t\t\t loc);\n+  inserter->insert(s1tmp);\n+\n+  // l1tmp := len(s1tmp)\n+  Named_object* lenfn = gogo->lookup_global(\"len\");\n+  Expression* lenref = Expression::make_func_reference(lenfn, NULL, loc);\n+  Expression_list* call_args = new Expression_list();\n+  call_args->push_back(Expression::make_temporary_reference(s1tmp, loc));\n+  Expression* len = Expression::make_call(lenref, call_args, false, loc);\n+  gogo->lower_expression(function, inserter, &len);\n+  gogo->flatten_expression(function, inserter, &len);\n+  Temporary_statement* l1tmp = Statement::make_temporary(int_type, len, loc);\n+  inserter->insert(l1tmp);\n+\n+  Temporary_statement* s2tmp = NULL;\n+  Temporary_statement* l2tmp = NULL;\n+  Expression_list* add = NULL;\n+  Expression* len2;\n+  if (this->is_varargs())\n+    {\n+      go_assert(args->size() == 2);\n+\n+      // s2tmp := s2\n+      s2tmp = Statement::make_temporary(NULL, args->back(), loc);\n+      inserter->insert(s2tmp);\n+\n+      // l2tmp := len(s2tmp)\n+      lenref = Expression::make_func_reference(lenfn, NULL, loc);\n+      call_args = new Expression_list();\n+      call_args->push_back(Expression::make_temporary_reference(s2tmp, loc));\n+      len = Expression::make_call(lenref, call_args, false, loc);\n+      gogo->lower_expression(function, inserter, &len);\n+      gogo->flatten_expression(function, inserter, &len);\n+      l2tmp = Statement::make_temporary(int_type, len, loc);\n+      inserter->insert(l2tmp);\n+\n+      // len2 = l2tmp\n+      len2 = Expression::make_temporary_reference(l2tmp, loc);\n+    }\n+  else\n+    {\n+      // We have to ensure that all the arguments are in variables\n+      // now, because otherwise if one of them is an index expression\n+      // into the current slice we could overwrite it before we fetch\n+      // it.\n+      add = new Expression_list();\n+      Expression_list::const_iterator pa = args->begin();\n+      for (++pa; pa != args->end(); ++pa)\n+\t{\n+\t  if ((*pa)->is_variable())\n+\t    add->push_back(*pa);\n+\t  else\n+\t    {\n+\t      Temporary_statement* tmp = Statement::make_temporary(NULL, *pa,\n+\t\t\t\t\t\t\t\t   loc);\n+\t      inserter->insert(tmp);\n+\t      add->push_back(Expression::make_temporary_reference(tmp, loc));\n+\t    }\n+\t}\n+\n+      // len2 = len(add)\n+      len2 = Expression::make_integer_ul(add->size(), int_type, loc);\n+    }\n+\n+  // ntmp := l1tmp + len2\n+  Expression* ref = Expression::make_temporary_reference(l1tmp, loc);\n+  Expression* sum = Expression::make_binary(OPERATOR_PLUS, ref, len2, loc);\n+  gogo->lower_expression(function, inserter, &sum);\n+  gogo->flatten_expression(function, inserter, &sum);\n+  Temporary_statement* ntmp = Statement::make_temporary(int_type, sum, loc);\n+  inserter->insert(ntmp);\n+\n+  // s1tmp = uint(ntmp) > uint(cap(s1tmp)) ?\n+  //   growslice(type, s1tmp, ntmp) :\n+  //   s1tmp[:ntmp]\n+  // Using uint here means that if the computation of ntmp overflowed,\n+  // we will call growslice which will panic.\n+\n+  Expression* left = Expression::make_temporary_reference(ntmp, loc);\n+  left = Expression::make_cast(uint_type, left, loc);\n+\n+  Named_object* capfn = gogo->lookup_global(\"cap\");\n+  Expression* capref = Expression::make_func_reference(capfn, NULL, loc);\n+  call_args = new Expression_list();\n+  call_args->push_back(Expression::make_temporary_reference(s1tmp, loc));\n+  Expression* right = Expression::make_call(capref, call_args, false, loc);\n+  right = Expression::make_cast(uint_type, right, loc);\n+\n+  Expression* cond = Expression::make_binary(OPERATOR_GT, left, right, loc);\n+\n+  Expression* a1 = Expression::make_type_descriptor(element_type, loc);\n+  Expression* a2 = Expression::make_temporary_reference(s1tmp, loc);\n+  Expression* a3 = Expression::make_temporary_reference(ntmp, loc);\n+  Expression* call = Runtime::make_call(Runtime::GROWSLICE, loc, 3,\n+\t\t\t\t\ta1, a2, a3);\n+  call = Expression::make_unsafe_cast(slice_type, call, loc);\n+\n+  ref = Expression::make_temporary_reference(s1tmp, loc);\n+  Expression* zero = Expression::make_integer_ul(0, int_type, loc);\n+  Expression* ref2 = Expression::make_temporary_reference(ntmp, loc);\n+  // FIXME: Mark this index as not requiring bounds checks.\n+  ref = Expression::make_index(ref, zero, ref2, NULL, loc);\n+\n+  Expression* rhs = Expression::make_conditional(cond, call, ref, loc);\n+\n+  gogo->lower_expression(function, inserter, &rhs);\n+  gogo->flatten_expression(function, inserter, &rhs);\n+\n+  Expression* lhs = Expression::make_temporary_reference(s1tmp, loc);\n+  Statement* assign = Statement::make_assignment(lhs, rhs, loc);\n+  inserter->insert(assign);\n+\n+  if (this->is_varargs())\n+    {\n+      // copy(s1tmp[l1tmp:], s2tmp)\n+      a1 = Expression::make_temporary_reference(s1tmp, loc);\n+      ref = Expression::make_temporary_reference(l1tmp, loc);\n+      Expression* nil = Expression::make_nil(loc);\n+      // FIXME: Mark this index as not requiring bounds checks.\n+      a1 = Expression::make_index(a1, ref, nil, NULL, loc);\n+\n+      a2 = Expression::make_temporary_reference(s2tmp, loc);\n+\n+      Named_object* copyfn = gogo->lookup_global(\"copy\");\n+      Expression* copyref = Expression::make_func_reference(copyfn, NULL, loc);\n+      call_args = new Expression_list();\n+      call_args->push_back(a1);\n+      call_args->push_back(a2);\n+      call = Expression::make_call(copyref, call_args, false, loc);\n+      gogo->lower_expression(function, inserter, &call);\n+      gogo->flatten_expression(function, inserter, &call);\n+      inserter->insert(Statement::make_statement(call, false));\n+    }\n+  else\n+    {\n+      // For each argument:\n+      //  s1tmp[l1tmp+i] = a\n+      unsigned long i = 0;\n+      for (Expression_list::const_iterator pa = add->begin();\n+\t   pa != add->end();\n+\t   ++pa, ++i)\n+\t{\n+\t  ref = Expression::make_temporary_reference(s1tmp, loc);\n+\t  ref2 = Expression::make_temporary_reference(l1tmp, loc);\n+\t  Expression* off = Expression::make_integer_ul(i, int_type, loc);\n+\t  ref2 = Expression::make_binary(OPERATOR_PLUS, ref2, off, loc);\n+\t  // FIXME: Mark this index as not requiring bounds checks.\n+\t  lhs = Expression::make_index(ref, ref2, NULL, NULL, loc);\n+\t  gogo->lower_expression(function, inserter, &lhs);\n+\t  gogo->flatten_expression(function, inserter, &lhs);\n+\t  assign = Statement::make_assignment(lhs, *pa, loc);\n+\t  inserter->insert(assign);\n+\t}\n+    }\n+\n+  return Expression::make_temporary_reference(s1tmp, loc);\n+}\n+\n // Return whether an expression has an integer value.  Report an error\n // if not.  This is used when handling calls to the predeclared make\n // function.\n@@ -8011,6 +8186,7 @@ Builtin_call_expression::do_determine_type(const Type_context* context)\n \n   bool is_print;\n   Type* arg_type = NULL;\n+  Type* trailing_arg_types = NULL;\n   switch (this->code_)\n     {\n     case BUILTIN_PRINT:\n@@ -8047,6 +8223,16 @@ Builtin_call_expression::do_determine_type(const Type_context* context)\n       }\n       break;\n \n+    case BUILTIN_APPEND:\n+      if (!this->is_varargs()\n+\t  && args != NULL\n+\t  && !args->empty()\n+\t  && args->front()->type()->is_slice_type())\n+\ttrailing_arg_types =\n+\t  args->front()->type()->array_type()->element_type();\n+      is_print = false;\n+      break;\n+\n     default:\n       is_print = false;\n       break;\n@@ -8103,6 +8289,12 @@ Builtin_call_expression::do_determine_type(const Type_context* context)\n \t    }\n \n \t  (*pa)->determine_type(&subcontext);\n+\n+\t  if (trailing_arg_types != NULL)\n+\t    {\n+\t      arg_type = trailing_arg_types;\n+\t      trailing_arg_types = NULL;\n+\t    }\n \t}\n     }\n }\n@@ -8309,54 +8501,102 @@ Builtin_call_expression::do_check_types(Gogo*)\n     case BUILTIN_APPEND:\n       {\n \tconst Expression_list* args = this->args();\n-\tif (args == NULL || args->size() < 2)\n+\tif (args == NULL || args->empty())\n \t  {\n \t    this->report_error(_(\"not enough arguments\"));\n \t    break;\n \t  }\n-\tif (args->size() > 2)\n-\t  {\n-\t    this->report_error(_(\"too many arguments\"));\n-\t    break;\n-\t  }\n-\tif (args->front()->type()->is_error()\n-\t    || args->back()->type()->is_error())\n+\n+\tType* slice_type = args->front()->type();\n+\tif (!slice_type->is_slice_type())\n \t  {\n+\t    if (slice_type->is_error_type())\n+\t      break;\n+\t    if (slice_type->is_nil_type())\n+\t      go_error_at(args->front()->location(), \"use of untyped nil\");\n+\t    else\n+\t      go_error_at(args->front()->location(),\n+\t\t\t  \"argument 1 must be a slice\");\n \t    this->set_is_error();\n \t    break;\n \t  }\n \n-\tArray_type* at = args->front()->type()->array_type();\n-\tType* e = at->element_type();\n-\n-\t// The language permits appending a string to a []byte, as a\n-\t// special case.\n-\tif (args->back()->type()->is_string_type())\n+\tType* element_type = slice_type->array_type()->element_type();\n+\tif (this->is_varargs())\n \t  {\n-\t    if (e->integer_type() != NULL && e->integer_type()->is_byte())\n-\t      break;\n-\t  }\n+\t    if (!args->back()->type()->is_slice_type()\n+\t\t&& !args->back()->type()->is_string_type())\n+\t      {\n+\t\tgo_error_at(args->back()->location(),\n+\t\t\t    \"invalid use of %<...%> with non-slice/non-string\");\n+\t\tthis->set_is_error();\n+\t\tbreak;\n+\t      }\n \n-\t// The language says that the second argument must be\n-\t// assignable to a slice of the element type of the first\n-\t// argument.  We already know the first argument is a slice\n-\t// type.\n-\tType* arg2_type = Type::make_array_type(e, NULL);\n-\tstd::string reason;\n-\tif (!Type::are_assignable(arg2_type, args->back()->type(), &reason))\n-\t  {\n-\t    if (reason.empty())\n-\t      this->report_error(_(\"argument 2 has invalid type\"));\n+\t    if (args->size() < 2)\n+\t      {\n+\t\tthis->report_error(_(\"not enough arguments\"));\n+\t\tbreak;\n+\t      }\n+\t    if (args->size() > 2)\n+\t      {\n+\t\tthis->report_error(_(\"too many arguments\"));\n+\t\tbreak;\n+\t      }\n+\n+\t    if (args->back()->type()->is_string_type()\n+\t\t&& element_type->integer_type() != NULL\n+\t\t&& element_type->integer_type()->is_byte())\n+\t      {\n+\t\t// Permit append(s1, s2...) when s1 is a slice of\n+\t\t// bytes and s2 is a string type.\n+\t      }\n \t    else\n \t      {\n-\t\tgo_error_at(this->location(),\n-\t\t\t    \"argument 2 has invalid type (%s)\",\n-\t\t\t    reason.c_str());\n-\t\tthis->set_is_error();\n+\t\t// We have to test for assignment compatibility to a\n+\t\t// slice of the element type, which is not necessarily\n+\t\t// the same as the type of the first argument: the\n+\t\t// first argument might have a named type.\n+\t\tType* check_type = Type::make_array_type(element_type, NULL);\n+\t\tstd::string reason;\n+\t\tif (!Type::are_assignable(check_type, args->back()->type(),\n+\t\t\t\t\t  &reason))\n+\t\t  {\n+\t\t    if (reason.empty())\n+\t\t      go_error_at(args->back()->location(),\n+\t\t\t\t  \"argument 2 has invalid type\");\n+\t\t    else\n+\t\t      go_error_at(args->back()->location(),\n+\t\t\t\t  \"argument 2 has invalid type (%s)\",\n+\t\t\t\t  reason.c_str());\n+\t\t    this->set_is_error();\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    Expression_list::const_iterator pa = args->begin();\n+\t    int i = 2;\n+\t    for (++pa; pa != args->end(); ++pa, ++i)\n+\t      {\n+\t\tstd::string reason;\n+\t\tif (!Type::are_assignable(element_type, (*pa)->type(),\n+\t\t\t\t\t  &reason))\n+\t\t  {\n+\t\t    if (reason.empty())\n+\t\t      go_error_at((*pa)->location(),\n+\t\t\t\t  \"argument %d has incompatible type\", i);\n+\t\t    else\n+\t\t      go_error_at((*pa)->location(),\n+\t\t\t\t  \"argument %d has incompatible type (%s)\",\n+\t\t\t\t  i, reason.c_str());\n+\t\t    this->set_is_error();\n+\t\t  }\n \t      }\n \t  }\n-\tbreak;\n       }\n+      break;\n \n     case BUILTIN_REAL:\n     case BUILTIN_IMAG:\n@@ -8719,97 +8959,39 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \tType* arg1_type = arg1->type();\n \tArray_type* at = arg1_type->array_type();\n \tgo_assert(arg1->is_variable());\n-\tExpression* arg1_val = at->get_value_pointer(gogo, arg1);\n-\tExpression* arg1_len = at->get_length(gogo, arg1);\n+\n+\tExpression* call;\n \n \tType* arg2_type = arg2->type();\n         go_assert(arg2->is_variable());\n-\tExpression* arg2_val;\n-\tExpression* arg2_len;\n-\tif (arg2_type->is_slice_type())\n-\t  {\n-\t    at = arg2_type->array_type();\n-\t    arg2_val = at->get_value_pointer(gogo, arg2);\n-\t    arg2_len = at->get_length(gogo, arg2);\n-\t  }\n+\tif (arg2_type->is_string_type())\n+\t  call = Runtime::make_call(Runtime::SLICESTRINGCOPY, location,\n+\t\t\t\t    2, arg1, arg2);\n \telse\n \t  {\n-\t    go_assert(arg2->is_variable());\n-            arg2_val = Expression::make_string_info(arg2, STRING_INFO_DATA,\n-                                                    location);\n-\t    arg2_len = Expression::make_string_info(arg2, STRING_INFO_LENGTH,\n-                                                    location);\n+\t    Type* et = at->element_type();\n+\t    if (et->has_pointer())\n+\t      {\n+\t\tExpression* td = Expression::make_type_descriptor(et,\n+\t\t\t\t\t\t\t\t  location);\n+\t\tcall = Runtime::make_call(Runtime::TYPEDSLICECOPY, location,\n+\t\t\t\t\t  3, td, arg1, arg2);\n+\t      }\n+\t    else\n+\t      {\n+\t\tExpression* sz = Expression::make_type_info(et,\n+\t\t\t\t\t\t\t    TYPE_INFO_SIZE);\n+\t\tcall = Runtime::make_call(Runtime::SLICECOPY, location, 3,\n+\t\t\t\t\t  arg1, arg2, sz);\n+\t      }\n \t  }\n-        Expression* cond =\n-            Expression::make_binary(OPERATOR_LT, arg1_len, arg2_len, location);\n-        Expression* length =\n-            Expression::make_conditional(cond, arg1_len, arg2_len, location);\n-\n-\tType* element_type = at->element_type();\n-\tint64_t element_size;\n-        bool ok = element_type->backend_type_size(gogo, &element_size);\n-        if (!ok)\n-          {\n-            go_assert(saw_errors());\n-            return gogo->backend()->error_expression();\n-          }\n-\n-\tExpression* size_expr = Expression::make_integer_int64(element_size,\n-\t\t\t\t\t\t\t       length->type(),\n-\t\t\t\t\t\t\t       location);\n-        Expression* bytecount =\n-            Expression::make_binary(OPERATOR_MULT, size_expr, length, location);\n-        Expression* copy = Runtime::make_call(Runtime::COPY, location, 3,\n-                                              arg1_val, arg2_val, bytecount);\n \n-        Expression* compound = Expression::make_compound(copy, length, location);\n-        return compound->get_backend(context);\n+\treturn call->get_backend(context);\n       }\n \n     case BUILTIN_APPEND:\n-      {\n-\tconst Expression_list* args = this->args();\n-\tgo_assert(args != NULL && args->size() == 2);\n-\tExpression* arg1 = args->front();\n-\tExpression* arg2 = args->back();\n-\n-\tArray_type* at = arg1->type()->array_type();\n-\tType* element_type = at->element_type()->forwarded();\n-\n-        go_assert(arg2->is_variable());\n-\tExpression* arg2_val;\n-\tExpression* arg2_len;\n-\tint64_t size;\n-\tif (arg2->type()->is_string_type()\n-\t    && element_type->integer_type() != NULL\n-\t    && element_type->integer_type()->is_byte())\n-\t  {\n-\t    arg2_val = Expression::make_string_info(arg2, STRING_INFO_DATA,\n-\t\t\t\t\t\t    location);\n-\t    arg2_len = Expression::make_string_info(arg2, STRING_INFO_LENGTH,\n-\t\t\t\t\t\t    location);\n-\t    size = 1;\n-\t  }\n-\telse\n-\t  {\n-\t    arg2_val = at->get_value_pointer(gogo, arg2);\n-\t    arg2_len = at->get_length(gogo, arg2);\n-            bool ok = element_type->backend_type_size(gogo, &size);\n-            if (!ok)\n-              {\n-                go_assert(saw_errors());\n-                return gogo->backend()->error_expression();\n-              }\n-\t  }\n-        Expression* element_size =\n-\t  Expression::make_integer_int64(size, NULL, location);\n-\n-        Expression* append = Runtime::make_call(Runtime::APPEND, location, 4,\n-                                                arg1, arg2_val, arg2_len,\n-                                                element_size);\n-        append = Expression::make_unsafe_cast(arg1->type(), append, location);\n-        return append->get_backend(context);\n-      }\n+      // Handled in Builtin_call_expression::flatten_append.\n+      go_unreachable();\n \n     case BUILTIN_REAL:\n     case BUILTIN_IMAG:"}, {"sha": "77c48ecbaaf70b4e710ca1408beadd421ea4fac3", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -425,9 +425,9 @@ Runtime::name_to_code(const std::string& name)\n   else if (name == \"close\")\n     code = Runtime::CLOSE;\n   else if (name == \"copy\")\n-    code = Runtime::COPY;\n+    code = Runtime::SLICECOPY;\n   else if (name == \"append\")\n-    code = Runtime::APPEND;\n+    code = Runtime::GROWSLICE;\n   else if (name == \"delete\")\n     code = Runtime::MAPDELETE;\n   else"}, {"sha": "5d3ce67725d4890589f4a28e977827138bca55a7", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -87,12 +87,7 @@ DEF_GO_RUNTIME(COMPLEX128_DIV, \"__go_complex128_div\",\n \t       P2(COMPLEX128, COMPLEX128), R1(COMPLEX128))\n \n // Make a slice.\n-DEF_GO_RUNTIME(MAKESLICE1, \"__go_make_slice1\", P2(TYPE, UINTPTR), R1(SLICE))\n-DEF_GO_RUNTIME(MAKESLICE2, \"__go_make_slice2\", P3(TYPE, UINTPTR, UINTPTR),\n-\t       R1(SLICE))\n-DEF_GO_RUNTIME(MAKESLICE1BIG, \"__go_make_slice1_big\", P2(TYPE, UINT64),\n-\t       R1(SLICE))\n-DEF_GO_RUNTIME(MAKESLICE2BIG, \"__go_make_slice2_big\", P3(TYPE, UINT64, UINT64),\n+DEF_GO_RUNTIME(MAKESLICE, \"runtime.makeslice\", P3(TYPE, INT64, INT64),\n \t       R1(SLICE))\n \n \n@@ -211,11 +206,20 @@ DEF_GO_RUNTIME(CLOSE, \"runtime.closechan\", P1(CHAN), R0())\n \n \n // Copy.\n-DEF_GO_RUNTIME(COPY, \"__go_copy\", P3(POINTER, POINTER, UINTPTR), R0())\n+DEF_GO_RUNTIME(SLICECOPY, \"runtime.slicecopy\", P3(SLICE, SLICE, UINTPTR),\n+\t       R1(INT))\n \n-// Append.\n-DEF_GO_RUNTIME(APPEND, \"__go_append\", P4(SLICE, POINTER, UINTPTR, UINTPTR),\n-\t       R1(SLICE))\n+// Copy from string.\n+DEF_GO_RUNTIME(SLICESTRINGCOPY, \"runtime.slicestringcopy\", P2(SLICE, STRING),\n+\t       R1(INT))\n+\n+// Copy of value containing pointers.\n+DEF_GO_RUNTIME(TYPEDSLICECOPY, \"runtime.typedslicecopy\",\n+\t       P3(TYPE, SLICE, SLICE), R1(INT))\n+\n+\n+// Grow a slice for append.\n+DEF_GO_RUNTIME(GROWSLICE, \"runtime.growslice\", P3(TYPE, SLICE, INT), R1(SLICE))\n \n \n // Register roots (global variables) for the garbage collector."}, {"sha": "8237bb6af4d3f9c58d5855fea22083dea718f0fb", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -428,20 +428,17 @@ endif\n endif\n \n runtime_files = \\\n-\truntime/go-append.c \\\n \truntime/go-assert.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n \truntime/go-callers.c \\\n \truntime/go-cdiv.c \\\n \truntime/go-cgo.c \\\n \truntime/go-construct-map.c \\\n-\truntime/go-copy.c \\\n \truntime/go-defer.c \\\n \truntime/go-deferred-recover.c \\\n \truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n-\truntime/go-make-slice.c \\\n \truntime/go-matherr.c \\\n \truntime/go-memclr.c \\\n \truntime/go-memcmp.c \\"}, {"sha": "50fc3f63f3c7c20cfd7453416c699067b6c7c14b", "filename": "libgo/Makefile.in", "status": "modified", "additions": 16, "deletions": 44, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -237,23 +237,22 @@ libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_4 =  \\\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@\tgetncpu-bsd.lo\n @LIBGO_IS_LINUX_TRUE@am__objects_4 = getncpu-linux.lo\n-am__objects_5 = go-append.lo go-assert.lo go-breakpoint.lo \\\n-\tgo-caller.lo go-callers.lo go-cdiv.lo go-cgo.lo \\\n-\tgo-construct-map.lo go-copy.lo go-defer.lo \\\n-\tgo-deferred-recover.lo go-ffi.lo go-fieldtrack.lo \\\n-\tgo-make-slice.lo go-matherr.lo go-memclr.lo go-memcmp.lo \\\n-\tgo-memequal.lo go-memmove.lo go-nanotime.lo go-now.lo \\\n-\tgo-new.lo go-nosys.lo go-panic.lo go-recover.lo \\\n-\tgo-reflect-call.lo go-runtime-error.lo go-setenv.lo \\\n-\tgo-signal.lo go-strslice.lo go-type-complex.lo \\\n-\tgo-type-float.lo go-type-identity.lo go-type-string.lo \\\n-\tgo-typedesc-equal.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n-\tgo-unsafe-pointer.lo go-unsetenv.lo go-unwind.lo go-varargs.lo \\\n-\tenv_posix.lo heapdump.lo mcache.lo mcentral.lo \\\n-\t$(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo msize.lo \\\n-\tpanic.lo parfor.lo print.lo proc.lo runtime.lo signal_unix.lo \\\n-\tthread.lo $(am__objects_2) yield.lo $(am__objects_3) malloc.lo \\\n-\truntime1.lo sigqueue.lo $(am__objects_4)\n+am__objects_5 = go-assert.lo go-breakpoint.lo go-caller.lo \\\n+\tgo-callers.lo go-cdiv.lo go-cgo.lo go-construct-map.lo \\\n+\tgo-defer.lo go-deferred-recover.lo go-ffi.lo go-fieldtrack.lo \\\n+\tgo-matherr.lo go-memclr.lo go-memcmp.lo go-memequal.lo \\\n+\tgo-memmove.lo go-nanotime.lo go-now.lo go-new.lo go-nosys.lo \\\n+\tgo-panic.lo go-recover.lo go-reflect-call.lo \\\n+\tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strslice.lo \\\n+\tgo-type-complex.lo go-type-float.lo go-type-identity.lo \\\n+\tgo-type-string.lo go-typedesc-equal.lo go-unsafe-new.lo \\\n+\tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unsetenv.lo \\\n+\tgo-unwind.lo go-varargs.lo env_posix.lo heapdump.lo mcache.lo \\\n+\tmcentral.lo $(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo \\\n+\tmsize.lo panic.lo parfor.lo print.lo proc.lo runtime.lo \\\n+\tsignal_unix.lo thread.lo $(am__objects_2) yield.lo \\\n+\t$(am__objects_3) malloc.lo runtime1.lo sigqueue.lo \\\n+\t$(am__objects_4)\n am_libgo_llgo_la_OBJECTS = $(am__objects_5)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -824,20 +823,17 @@ toolexeclibgounicode_DATA = \\\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@runtime_getncpu_file = runtime/getncpu-bsd.c\n @LIBGO_IS_LINUX_TRUE@runtime_getncpu_file = runtime/getncpu-linux.c\n runtime_files = \\\n-\truntime/go-append.c \\\n \truntime/go-assert.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n \truntime/go-callers.c \\\n \truntime/go-cdiv.c \\\n \truntime/go-cgo.c \\\n \truntime/go-construct-map.c \\\n-\truntime/go-copy.c \\\n \truntime/go-defer.c \\\n \truntime/go-deferred-recover.c \\\n \truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n-\truntime/go-make-slice.c \\\n \truntime/go-matherr.c \\\n \truntime/go-memclr.c \\\n \truntime/go-memcmp.c \\\n@@ -1519,20 +1515,17 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-none.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-solaris.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-append.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-assert.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-breakpoint.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-caller.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-callers.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-cdiv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-cgo.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-construct-map.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-copy.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-defer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-deferred-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-fieldtrack.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-make-slice.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-matherr.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-memclr.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-memcmp.Plo@am__quote@\n@@ -1650,13 +1643,6 @@ libgolibbegin_a-go-libmain.obj: runtime/go-libmain.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgolibbegin_a_CFLAGS) $(CFLAGS) -c -o libgolibbegin_a-go-libmain.obj `if test -f 'runtime/go-libmain.c'; then $(CYGPATH_W) 'runtime/go-libmain.c'; else $(CYGPATH_W) '$(srcdir)/runtime/go-libmain.c'; fi`\n \n-go-append.lo: runtime/go-append.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-append.lo -MD -MP -MF $(DEPDIR)/go-append.Tpo -c -o go-append.lo `test -f 'runtime/go-append.c' || echo '$(srcdir)/'`runtime/go-append.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-append.Tpo $(DEPDIR)/go-append.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-append.c' object='go-append.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-append.lo `test -f 'runtime/go-append.c' || echo '$(srcdir)/'`runtime/go-append.c\n-\n go-assert.lo: runtime/go-assert.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-assert.lo -MD -MP -MF $(DEPDIR)/go-assert.Tpo -c -o go-assert.lo `test -f 'runtime/go-assert.c' || echo '$(srcdir)/'`runtime/go-assert.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-assert.Tpo $(DEPDIR)/go-assert.Plo\n@@ -1706,13 +1692,6 @@ go-construct-map.lo: runtime/go-construct-map.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-construct-map.lo `test -f 'runtime/go-construct-map.c' || echo '$(srcdir)/'`runtime/go-construct-map.c\n \n-go-copy.lo: runtime/go-copy.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-copy.lo -MD -MP -MF $(DEPDIR)/go-copy.Tpo -c -o go-copy.lo `test -f 'runtime/go-copy.c' || echo '$(srcdir)/'`runtime/go-copy.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-copy.Tpo $(DEPDIR)/go-copy.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-copy.c' object='go-copy.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-copy.lo `test -f 'runtime/go-copy.c' || echo '$(srcdir)/'`runtime/go-copy.c\n-\n go-defer.lo: runtime/go-defer.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-defer.lo -MD -MP -MF $(DEPDIR)/go-defer.Tpo -c -o go-defer.lo `test -f 'runtime/go-defer.c' || echo '$(srcdir)/'`runtime/go-defer.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-defer.Tpo $(DEPDIR)/go-defer.Plo\n@@ -1741,13 +1720,6 @@ go-fieldtrack.lo: runtime/go-fieldtrack.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-fieldtrack.lo `test -f 'runtime/go-fieldtrack.c' || echo '$(srcdir)/'`runtime/go-fieldtrack.c\n \n-go-make-slice.lo: runtime/go-make-slice.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-make-slice.lo -MD -MP -MF $(DEPDIR)/go-make-slice.Tpo -c -o go-make-slice.lo `test -f 'runtime/go-make-slice.c' || echo '$(srcdir)/'`runtime/go-make-slice.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-make-slice.Tpo $(DEPDIR)/go-make-slice.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-make-slice.c' object='go-make-slice.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-make-slice.lo `test -f 'runtime/go-make-slice.c' || echo '$(srcdir)/'`runtime/go-make-slice.c\n-\n go-matherr.lo: runtime/go-matherr.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-matherr.lo -MD -MP -MF $(DEPDIR)/go-matherr.Tpo -c -o go-matherr.lo `test -f 'runtime/go-matherr.c' || echo '$(srcdir)/'`runtime/go-matherr.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-matherr.Tpo $(DEPDIR)/go-matherr.Plo"}, {"sha": "4548a5b2321edbce84cff5c9c9a2129fc83d4e1f", "filename": "libgo/go/runtime/slice.go", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2Fgo%2Fruntime%2Fslice.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2Fgo%2Fruntime%2Fslice.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fslice.go?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname makeslice runtime.makeslice\n+//go:linkname growslice runtime.growslice\n+//go:linkname slicecopy runtime.slicecopy\n+//go:linkname slicestringcopy runtime.slicestringcopy\n+\n+type slice struct {\n+\tarray unsafe.Pointer\n+\tlen   int\n+\tcap   int\n+}\n+\n+// maxElems is a lookup table containing the maximum capacity for a slice.\n+// The index is the size of the slice element.\n+var maxElems = [...]uintptr{\n+\t^uintptr(0),\n+\t_MaxMem / 1, _MaxMem / 2, _MaxMem / 3, _MaxMem / 4,\n+\t_MaxMem / 5, _MaxMem / 6, _MaxMem / 7, _MaxMem / 8,\n+\t_MaxMem / 9, _MaxMem / 10, _MaxMem / 11, _MaxMem / 12,\n+\t_MaxMem / 13, _MaxMem / 14, _MaxMem / 15, _MaxMem / 16,\n+\t_MaxMem / 17, _MaxMem / 18, _MaxMem / 19, _MaxMem / 20,\n+\t_MaxMem / 21, _MaxMem / 22, _MaxMem / 23, _MaxMem / 24,\n+\t_MaxMem / 25, _MaxMem / 26, _MaxMem / 27, _MaxMem / 28,\n+\t_MaxMem / 29, _MaxMem / 30, _MaxMem / 31, _MaxMem / 32,\n+}\n+\n+// maxSliceCap returns the maximum capacity for a slice.\n+func maxSliceCap(elemsize uintptr) uintptr {\n+\tif elemsize < uintptr(len(maxElems)) {\n+\t\treturn maxElems[elemsize]\n+\t}\n+\treturn _MaxMem / elemsize\n+}\n+\n+// TODO: take uintptrs instead of int64s?\n+func makeslice(et *_type, len64, cap64 int64) slice {\n+\t// NOTE: The len > maxElements check here is not strictly necessary,\n+\t// but it produces a 'len out of range' error instead of a 'cap out of range' error\n+\t// when someone does make([]T, bignumber). 'cap out of range' is true too,\n+\t// but since the cap is only being supplied implicitly, saying len is clearer.\n+\t// See issue 4085.\n+\tmaxElements := maxSliceCap(et.size)\n+\tlen := int(len64)\n+\tif len64 < 0 || int64(len) != len64 || uintptr(len) > maxElements {\n+\t\tpanic(errorString(\"makeslice: len out of range\"))\n+\t}\n+\n+\tcap := int(cap64)\n+\tif cap < len || int64(cap) != cap64 || uintptr(cap) > maxElements {\n+\t\tpanic(errorString(\"makeslice: cap out of range\"))\n+\t}\n+\n+\t// gccgo's current garbage collector requires using newarray,\n+\t// not mallocgc here.  This can change back to mallocgc when\n+\t// we port the garbage collector.\n+\tp := newarray(et, cap)\n+\treturn slice{p, len, cap}\n+}\n+\n+// growslice handles slice growth during append.\n+// It is passed the slice element type, the old slice, and the desired new minimum capacity,\n+// and it returns a new slice with at least that capacity, with the old data\n+// copied into it.\n+// The new slice's length is set to the requested capacity.\n+func growslice(et *_type, old slice, cap int) slice {\n+\tif raceenabled {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer(&et))\n+\t\tracereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))\n+\t}\n+\tif msanenabled {\n+\t\tmsanread(old.array, uintptr(old.len*int(et.size)))\n+\t}\n+\n+\tif et.size == 0 {\n+\t\tif cap < old.cap {\n+\t\t\tpanic(errorString(\"growslice: cap out of range\"))\n+\t\t}\n+\t\t// append should not create a slice with nil pointer but non-zero len.\n+\t\t// We assume that append doesn't need to preserve old.array in this case.\n+\t\treturn slice{unsafe.Pointer(&zerobase), cap, cap}\n+\t}\n+\n+\tnewcap := old.cap\n+\tdoublecap := newcap + newcap\n+\tif cap > doublecap {\n+\t\tnewcap = cap\n+\t} else {\n+\t\tif old.len < 1024 {\n+\t\t\tnewcap = doublecap\n+\t\t} else {\n+\t\t\tfor newcap < cap {\n+\t\t\t\tnewcap += newcap / 4\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvar lenmem, capmem uintptr\n+\tconst ptrSize = unsafe.Sizeof((*byte)(nil))\n+\tswitch et.size {\n+\tcase 1:\n+\t\tlenmem = uintptr(old.len)\n+\t\tcapmem = roundupsize(uintptr(newcap))\n+\t\tnewcap = int(capmem)\n+\tcase ptrSize:\n+\t\tlenmem = uintptr(old.len) * ptrSize\n+\t\tcapmem = roundupsize(uintptr(newcap) * ptrSize)\n+\t\tnewcap = int(capmem / ptrSize)\n+\tdefault:\n+\t\tlenmem = uintptr(old.len) * et.size\n+\t\tcapmem = roundupsize(uintptr(newcap) * et.size)\n+\t\tnewcap = int(capmem / et.size)\n+\t}\n+\n+\tif cap < old.cap || uintptr(newcap) > maxSliceCap(et.size) {\n+\t\tpanic(errorString(\"growslice: cap out of range\"))\n+\t}\n+\n+\tvar p unsafe.Pointer\n+\tif et.kind&kindNoPointers != 0 {\n+\t\t// gccgo's current GC requires newarray, not mallocgc.\n+\t\tp = newarray(et, newcap)\n+\t\tmemmove(p, old.array, lenmem)\n+\t\t// The call to memclr is not needed for gccgo since\n+\t\t// the newarray function will zero the memory.\n+\t\t// Calling memclr is also wrong since we allocated\n+\t\t// newcap*et.size bytes, which is not the same as capmem.\n+\t\t// memclr(add(p, lenmem), capmem-lenmem)\n+\t} else {\n+\t\t// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.\n+\t\t// gccgo's current GC requires newarray, not mallocgc.\n+\t\tp = newarray(et, newcap)\n+\t\tif !writeBarrier.enabled {\n+\t\t\tmemmove(p, old.array, lenmem)\n+\t\t} else {\n+\t\t\tfor i := uintptr(0); i < lenmem; i += et.size {\n+\t\t\t\ttypedmemmove(et, add(p, i), add(old.array, i))\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn slice{p, cap, newcap}\n+}\n+\n+func slicecopy(to, fm slice, width uintptr) int {\n+\tif fm.len == 0 || to.len == 0 {\n+\t\treturn 0\n+\t}\n+\n+\tn := fm.len\n+\tif to.len < n {\n+\t\tn = to.len\n+\t}\n+\n+\tif width == 0 {\n+\t\treturn n\n+\t}\n+\n+\tif raceenabled {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer(&to))\n+\t\tpc := funcPC(slicecopy)\n+\t\tracewriterangepc(to.array, uintptr(n*int(width)), callerpc, pc)\n+\t\tracereadrangepc(fm.array, uintptr(n*int(width)), callerpc, pc)\n+\t}\n+\tif msanenabled {\n+\t\tmsanwrite(to.array, uintptr(n*int(width)))\n+\t\tmsanread(fm.array, uintptr(n*int(width)))\n+\t}\n+\n+\tsize := uintptr(n) * width\n+\tif size == 1 { // common case worth about 2x to do here\n+\t\t// TODO: is this still worth it with new memmove impl?\n+\t\t*(*byte)(to.array) = *(*byte)(fm.array) // known to be a byte pointer\n+\t} else {\n+\t\tmemmove(to.array, fm.array, size)\n+\t}\n+\treturn n\n+}\n+\n+func slicestringcopy(to []byte, fm string) int {\n+\tif len(fm) == 0 || len(to) == 0 {\n+\t\treturn 0\n+\t}\n+\n+\tn := len(fm)\n+\tif len(to) < n {\n+\t\tn = len(to)\n+\t}\n+\n+\tif raceenabled {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer(&to))\n+\t\tpc := funcPC(slicestringcopy)\n+\t\tracewriterangepc(unsafe.Pointer(&to[0]), uintptr(n), callerpc, pc)\n+\t}\n+\tif msanenabled {\n+\t\tmsanwrite(unsafe.Pointer(&to[0]), uintptr(n))\n+\t}\n+\n+\tmemmove(unsafe.Pointer(&to[0]), stringStructOf(&fm).str, uintptr(n))\n+\treturn n\n+}"}, {"sha": "755933de713db56be3ba56ab7dd12aa1a24dd240", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -253,11 +253,18 @@ func typedmemmove(typ *_type, dst, src unsafe.Pointer) {\n \tmemmove(dst, src, typ.size)\n }\n \n-// Here for gccgo unless and until we port slice.go.\n-type slice struct {\n-\tarray unsafe.Pointer\n-\tlen   int\n-\tcap   int\n+// Temporary for gccgo until we port mbarrier.go.\n+//go:linkname typedslicecopy runtime.typedslicecopy\n+func typedslicecopy(typ *_type, dst, src slice) int {\n+\tn := dst.len\n+\tif n > src.len {\n+\t\tn = src.len\n+\t}\n+\tif n == 0 {\n+\t\treturn 0\n+\t}\n+\tmemmove(dst.array, src.array, uintptr(n)*typ.size)\n+\treturn n\n }\n \n // Here for gccgo until we port malloc.go.\n@@ -474,3 +481,11 @@ func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {\n func writebarrierptr(dst *uintptr, src uintptr) {\n \t*dst = src\n }\n+\n+// Temporary for gccgo until we port malloc.go\n+var zerobase uintptr\n+\n+//go:linkname getZerobase runtime.getZerobase\n+func getZerobase() *uintptr {\n+\treturn &zerobase\n+}"}, {"sha": "1b2d49e53c1bc789e3018d4d2cd7351260a21193", "filename": "libgo/runtime/go-append.c", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f1031d6cc228e2b468338b3dfa4303d54ac207/libgo%2Fruntime%2Fgo-append.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f1031d6cc228e2b468338b3dfa4303d54ac207/libgo%2Fruntime%2Fgo-append.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-append.c?ref=21f1031d6cc228e2b468338b3dfa4303d54ac207", "patch": "@@ -1,74 +0,0 @@\n-/* go-append.c -- the go builtin append function.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-panic.h\"\n-#include \"go-type.h\"\n-#include \"array.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-/* We should be OK if we don't split the stack here, since the only\n-   libc functions we call are memcpy and memmove.  If we don't do\n-   this, we will always split the stack, because of memcpy and\n-   memmove.  */\n-extern struct __go_open_array\n-__go_append (struct __go_open_array, void *, uintptr_t, uintptr_t)\n-  __attribute__ ((no_split_stack));\n-\n-struct __go_open_array\n-__go_append (struct __go_open_array a, void *bvalues, uintptr_t bcount,\n-\t     uintptr_t element_size)\n-{\n-  uintptr_t ucount;\n-  intgo count;\n-\n-  if (bvalues == NULL || bcount == 0)\n-    return a;\n-\n-  ucount = (uintptr_t) a.__count + bcount;\n-  count = (intgo) ucount;\n-  if ((uintptr_t) count != ucount || count <= a.__count)\n-    runtime_panicstring (\"append: slice overflow\");\n-\n-  if (count > a.__capacity)\n-    {\n-      intgo m;\n-      uintptr capmem;\n-      void *n;\n-\n-      m = a.__capacity;\n-      if (m + m < count)\n-\tm = count;\n-      else\n-\t{\n-\t  do\n-\t    {\n-\t      if (a.__count < 1024)\n-\t\tm += m;\n-\t      else\n-\t\tm += m / 4;\n-\t    }\n-\t  while (m < count);\n-\t}\n-\n-      if (element_size > 0 && (uintptr) m > MaxMem / element_size)\n-\truntime_panicstring (\"growslice: cap out of range\");\n-\n-      capmem = runtime_roundupsize (m * element_size);\n-\n-      n = __go_alloc (capmem);\n-      __builtin_memcpy (n, a.__values, a.__count * element_size);\n-\n-      a.__values = n;\n-      a.__capacity = m;\n-    }\n-\n-  __builtin_memmove ((char *) a.__values + a.__count * element_size,\n-\t\t     bvalues, bcount * element_size);\n-  a.__count = count;\n-  return a;\n-}"}, {"sha": "05e16acbf1c48686ec76b7338473d537e5731723", "filename": "libgo/runtime/go-copy.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f1031d6cc228e2b468338b3dfa4303d54ac207/libgo%2Fruntime%2Fgo-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f1031d6cc228e2b468338b3dfa4303d54ac207/libgo%2Fruntime%2Fgo-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-copy.c?ref=21f1031d6cc228e2b468338b3dfa4303d54ac207", "patch": "@@ -1,22 +0,0 @@\n-/* go-append.c -- the go builtin copy function.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-#include <stdint.h>\n-\n-/* We should be OK if we don't split the stack here, since we are just\n-   calling memmove which shouldn't need much stack.  If we don't do\n-   this we will always split the stack, because of memmove.  */\n-\n-extern void\n-__go_copy (void *, void *, uintptr_t)\n-  __attribute__ ((no_split_stack));\n-\n-void\n-__go_copy (void *a, void *b, uintptr_t len)\n-{\n-  __builtin_memmove (a, b, len);\n-}"}, {"sha": "ccd07e5ac5115093a6d34bd255eafe0c33f549d0", "filename": "libgo/runtime/go-make-slice.c", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f1031d6cc228e2b468338b3dfa4303d54ac207/libgo%2Fruntime%2Fgo-make-slice.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f1031d6cc228e2b468338b3dfa4303d54ac207/libgo%2Fruntime%2Fgo-make-slice.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-make-slice.c?ref=21f1031d6cc228e2b468338b3dfa4303d54ac207", "patch": "@@ -1,99 +0,0 @@\n-/* go-make-slice.c -- make a slice.\n-\n-   Copyright 2011 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"go-type.h\"\n-#include \"array.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-/* Dummy word to use as base pointer for make([]T, 0).\n-   Since you cannot take the address of such a slice,\n-   you can't tell that they all have the same base pointer.  */\n-uintptr runtime_zerobase;\n-\n-struct __go_open_array\n-__go_make_slice2 (const struct __go_type_descriptor *td, uintptr_t len,\n-\t\t  uintptr_t cap)\n-{\n-  const struct __go_slice_type* std;\n-  intgo ilen;\n-  intgo icap;\n-  uintptr_t size;\n-  struct __go_open_array ret;\n-\n-  __go_assert ((td->__code & GO_CODE_MASK) == GO_SLICE);\n-  std = (const struct __go_slice_type *) td;\n-\n-  ilen = (intgo) len;\n-  if (ilen < 0\n-      || (uintptr_t) ilen != len\n-      || (std->__element_type->__size > 0\n-\t  && len > MaxMem / std->__element_type->__size))\n-    runtime_panicstring (\"makeslice: len out of range\");\n-\n-  icap = (intgo) cap;\n-  if (cap < len\n-      || (uintptr_t) icap != cap\n-      || (std->__element_type->__size > 0\n-\t  && cap > MaxMem / std->__element_type->__size))\n-    runtime_panicstring (\"makeslice: cap out of range\");\n-\n-  ret.__count = ilen;\n-  ret.__capacity = icap;\n-\n-  size = cap * std->__element_type->__size;\n-\n-  if (size == 0)\n-    ret.__values = &runtime_zerobase;\n-  else if ((std->__element_type->__code & GO_NO_POINTERS) != 0)\n-    ret.__values =\n-      runtime_mallocgc (size,\n-\t\t\t(uintptr) std->__element_type | TypeInfo_Array,\n-\t\t\tFlagNoScan);\n-  else\n-    ret.__values =\n-      runtime_mallocgc (size,\n-\t\t\t(uintptr) std->__element_type | TypeInfo_Array,\n-\t\t\t0);\n-\n-  return ret;\n-}\n-\n-struct __go_open_array\n-__go_make_slice1 (const struct __go_type_descriptor *td, uintptr_t len)\n-{\n-  return __go_make_slice2 (td, len, len);\n-}\n-\n-struct __go_open_array\n-__go_make_slice2_big (const struct __go_type_descriptor *td, uint64_t len,\n-\t\t      uint64_t cap)\n-{\n-  uintptr_t slen;\n-  uintptr_t scap;\n-\n-  slen = (uintptr_t) len;\n-  if ((uint64_t) slen != len)\n-    runtime_panicstring (\"makeslice: len out of range\");\n-\n-  scap = (uintptr_t) cap;\n-  if ((uint64_t) scap != cap)\n-    runtime_panicstring (\"makeslice: cap out of range\");\n-\n-  return __go_make_slice2 (td, slen, scap);\n-}\n-\n-struct __go_open_array\n-__go_make_slice1_big (const struct __go_type_descriptor *td, uint64_t len)\n-{\n-  return __go_make_slice2_big (td, len, len);\n-}"}, {"sha": "5cbdc4632fbdc801bcf88f6f8975a9493e22d911", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -81,7 +81,7 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \t\t// All 0-length allocations use this pointer.\n \t\t// The language does not require the allocations to\n \t\t// have distinct values.\n-\t\treturn &runtime_zerobase;\n+\t\treturn runtime_getZerobase();\n \t}\n \n \tg = runtime_g();\n@@ -881,7 +881,7 @@ func new(typ *Type) (ret *uint8) {\n }\n \n static void*\n-cnew(const Type *typ, intgo n, int32 objtyp)\n+runtime_docnew(const Type *typ, intgo n, int32 objtyp)\n {\n \tif((objtyp&(PtrSize-1)) != objtyp)\n \t\truntime_throw(\"runtime: invalid objtyp\");\n@@ -894,13 +894,13 @@ cnew(const Type *typ, intgo n, int32 objtyp)\n void*\n runtime_cnew(const Type *typ)\n {\n-\treturn cnew(typ, 1, TypeInfo_SingleObject);\n+\treturn runtime_docnew(typ, 1, TypeInfo_SingleObject);\n }\n \n void*\n runtime_cnewarray(const Type *typ, intgo n)\n {\n-\treturn cnew(typ, n, TypeInfo_Array);\n+\treturn runtime_docnew(typ, n, TypeInfo_Array);\n }\n \n func GC() {"}, {"sha": "501f1b41ace4f89b08571a6020f1f2b60236ff83", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f56408db96e2e12f6e1322ed2c1c465df934f6/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=94f56408db96e2e12f6e1322ed2c1c465df934f6", "patch": "@@ -234,7 +234,8 @@ enum\n /*\n  * external data\n  */\n-extern\tuintptr runtime_zerobase;\n+extern\tuintptr* runtime_getZerobase(void)\n+  __asm__(GOSYM_PREFIX \"runtime.getZerobase\");\n extern\tG**\truntime_allg;\n extern\tuintptr runtime_allglen;\n extern\tG*\truntime_lastg;"}]}