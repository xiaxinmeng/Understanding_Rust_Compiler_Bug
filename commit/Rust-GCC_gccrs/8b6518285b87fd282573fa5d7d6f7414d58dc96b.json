{"sha": "8b6518285b87fd282573fa5d7d6f7414d58dc96b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI2NTE4Mjg1Yjg3ZmQyODI1NzNmYTVkN2Q2Zjc0MTRkNThkYzk2Yg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2019-04-13T15:29:15Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-04-13T15:29:15Z"}, "message": "libphobos: Move rt.sections modules to gcc.sections\n\nThese modules depend on a mixture between how the compiler emits\nrun-time module information, and what functions are exposed by the\nplatform to inquire about loaded global and thread-local data sections.\n\nAs the upstream implementation is written to work only with how the\nreference D compiler writes out data, much of what is present does not\napply to the GCC D front-end.  So it has been moved to a non-upstream\nlocation in the source tree, where most of it will be rewritten once\neach port has been completed.\n\nThe only tested module sections/elf_shared.d has been cleaned up so that\nall deprecated declarations have been removed, as well as the brittle\nmodule collision checking, which required bss_sections.c.  All other\nports have been left unchanged apart from a commonizing of attributes.\n\nlibphobos/ChangeLog:\n\n2019-04-13  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\t* libdruntime/Makefile.am (DRUNTIME_CSOURCES): Remove bss_sections.c.\n\t(DRUNTIME_DSOURCES): Rename rt/sections_* modules to gcc/sections/*.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* libdruntime/gcc/sections/android.d: New file.\n\t* libdruntime/gcc/sections/elf_shared.d: New file.\n\t* libdruntime/gcc/sections/osx.d: New file.\n\t* libdruntime/gcc/sections/package.d: New file.\n\t* libdruntime/gcc/sections/solaris.d: New file.\n\t* libdruntime/gcc/sections/win32.d: New file.\n\t* libdruntime/gcc/sections/win64.d: New file.\n\t* libdruntime/rt/bss_section.c: Remove.\n\t* libdruntime/rt/sections.d: Publicly import gcc.sections.\n\t* libdruntime/rt/sections_android.d: Remove.\n\t* libdruntime/rt/sections_elf_shared.d: Remove.\n\t* libdruntime/rt/sections_osx.d: Remove.\n\t* libdruntime/rt/sections_solaris.d: Remove.\n\t* libdruntime/rt/sections_win32.d: Remove.\n\t* libdruntime/rt/sections_win64.d: Remove.\n\nFrom-SVN: r270341", "tree": {"sha": "513a3346a5fe38d485ac1a2ca28fc7336fcf3e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/513a3346a5fe38d485ac1a2ca28fc7336fcf3e33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b6518285b87fd282573fa5d7d6f7414d58dc96b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6518285b87fd282573fa5d7d6f7414d58dc96b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b6518285b87fd282573fa5d7d6f7414d58dc96b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6518285b87fd282573fa5d7d6f7414d58dc96b/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "151c5c0b80a30ba4316c86fcd0a7bf232a4ff127", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/151c5c0b80a30ba4316c86fcd0a7bf232a4ff127", "html_url": "https://github.com/Rust-GCC/gccrs/commit/151c5c0b80a30ba4316c86fcd0a7bf232a4ff127"}], "stats": {"total": 784, "additions": 414, "deletions": 370}, "files": [{"sha": "3dd4bbd68fa32864b3a156daa5f1cce9f3988d9c", "filename": "libphobos/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2FChangeLog?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -1,3 +1,24 @@\n+2019-04-13  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* libdruntime/Makefile.am (DRUNTIME_CSOURCES): Remove bss_sections.c.\n+\t(DRUNTIME_DSOURCES): Rename rt/sections_* modules to gcc/sections/*.\n+\t* libdruntime/Makefile.in: Regenerate.\n+\t* libdruntime/gcc/sections/android.d: New file.\n+\t* libdruntime/gcc/sections/elf_shared.d: New file.\n+\t* libdruntime/gcc/sections/osx.d: New file.\n+\t* libdruntime/gcc/sections/package.d: New file.\n+\t* libdruntime/gcc/sections/solaris.d: New file.\n+\t* libdruntime/gcc/sections/win32.d: New file.\n+\t* libdruntime/gcc/sections/win64.d: New file.\n+\t* libdruntime/rt/bss_section.c: Remove.\n+\t* libdruntime/rt/sections.d: Publicly import gcc.sections.\n+\t* libdruntime/rt/sections_android.d: Remove.\n+\t* libdruntime/rt/sections_elf_shared.d: Remove.\n+\t* libdruntime/rt/sections_osx.d: Remove.\n+\t* libdruntime/rt/sections_solaris.d: Remove.\n+\t* libdruntime/rt/sections_win32.d: Remove.\n+\t* libdruntime/rt/sections_win64.d: Remove.\n+\n 2019-04-12  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* configure.ac (AM_INIT_AUTOMAKE): Add subdir-objects."}, {"sha": "8e36ce214499f354f399b1197af720f80572eec5", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -122,7 +122,7 @@ DRUNTIME_DSOURCES_GENERATED = gcc/config.d gcc/libbacktrace.d\n # https://www.gnu.org/software/automake/manual/html_node/Wildcards.html\n DRUNTIME_SSOURCES = core/threadasm.S\n \n-DRUNTIME_CSOURCES = core/stdc/errno_.c rt/bss_section.c\n+DRUNTIME_CSOURCES = core/stdc/errno_.c\n \n DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/checkedint.d core/cpuid.d core/demangle.d core/exception.d \\\n@@ -140,14 +140,14 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/sync/config.d core/sync/exception.d core/sync/mutex.d \\\n \tcore/sync/rwmutex.d core/sync/semaphore.d core/thread.d core/time.d \\\n \tcore/vararg.d gcc/attribute.d gcc/backtrace.d gcc/builtins.d gcc/deh.d \\\n-\tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n-\tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n-\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n-\trt/arraycast.d rt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d \\\n-\trt/deh.d rt/dmain2.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n-\trt/minfo.d rt/monitor_.d rt/obj.d rt/qsort.d rt/sections.d \\\n-\trt/sections_android.d rt/sections_elf_shared.d rt/sections_osx.d \\\n-\trt/sections_solaris.d rt/sections_win32.d rt/sections_win64.d \\\n+\tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n+\tgcc/sections/package.d gcc/sections/solaris.d gcc/sections/win32.d \\\n+\tgcc/sections/win64.d gcc/unwind/arm.d gcc/unwind/arm_common.d \\\n+\tgcc/unwind/c6x.d gcc/unwind/generic.d gcc/unwind/package.d \\\n+\tgcc/unwind/pe.d object.d rt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d \\\n+\trt/arrayassign.d rt/arraycast.d rt/arraycat.d rt/cast_.d rt/config.d \\\n+\trt/critical_.d rt/deh.d rt/dmain2.d rt/invariant.d rt/lifetime.d \\\n+\trt/memory.d rt/minfo.d rt/monitor_.d rt/obj.d rt/qsort.d rt/sections.d \\\n \trt/switch_.d rt/tlsgc.d rt/typeinfo/ti_Acdouble.d \\\n \trt/typeinfo/ti_Acfloat.d rt/typeinfo/ti_Acreal.d \\\n \trt/typeinfo/ti_Adouble.d rt/typeinfo/ti_Afloat.d rt/typeinfo/ti_Ag.d \\"}, {"sha": "0a27afac545b804f41d315c81a26a06636134de8", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -194,39 +194,40 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/sync/exception.lo core/sync/mutex.lo core/sync/rwmutex.lo \\\n \tcore/sync/semaphore.lo core/thread.lo core/time.lo \\\n \tcore/vararg.lo gcc/attribute.lo gcc/backtrace.lo \\\n-\tgcc/builtins.lo gcc/deh.lo gcc/unwind/arm.lo \\\n+\tgcc/builtins.lo gcc/deh.lo gcc/sections/android.lo \\\n+\tgcc/sections/elf_shared.lo gcc/sections/osx.lo \\\n+\tgcc/sections/package.lo gcc/sections/solaris.lo \\\n+\tgcc/sections/win32.lo gcc/sections/win64.lo gcc/unwind/arm.lo \\\n \tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n \trt/arrayassign.lo rt/arraycast.lo rt/arraycat.lo rt/cast_.lo \\\n \trt/config.lo rt/critical_.lo rt/deh.lo rt/dmain2.lo \\\n \trt/invariant.lo rt/lifetime.lo rt/memory.lo rt/minfo.lo \\\n \trt/monitor_.lo rt/obj.lo rt/qsort.lo rt/sections.lo \\\n-\trt/sections_android.lo rt/sections_elf_shared.lo \\\n-\trt/sections_osx.lo rt/sections_solaris.lo rt/sections_win32.lo \\\n-\trt/sections_win64.lo rt/switch_.lo rt/tlsgc.lo \\\n-\trt/typeinfo/ti_Acdouble.lo rt/typeinfo/ti_Acfloat.lo \\\n-\trt/typeinfo/ti_Acreal.lo rt/typeinfo/ti_Adouble.lo \\\n-\trt/typeinfo/ti_Afloat.lo rt/typeinfo/ti_Ag.lo \\\n-\trt/typeinfo/ti_Aint.lo rt/typeinfo/ti_Along.lo \\\n-\trt/typeinfo/ti_Areal.lo rt/typeinfo/ti_Ashort.lo \\\n-\trt/typeinfo/ti_C.lo rt/typeinfo/ti_byte.lo \\\n-\trt/typeinfo/ti_cdouble.lo rt/typeinfo/ti_cent.lo \\\n-\trt/typeinfo/ti_cfloat.lo rt/typeinfo/ti_char.lo \\\n-\trt/typeinfo/ti_creal.lo rt/typeinfo/ti_dchar.lo \\\n-\trt/typeinfo/ti_delegate.lo rt/typeinfo/ti_double.lo \\\n-\trt/typeinfo/ti_float.lo rt/typeinfo/ti_idouble.lo \\\n-\trt/typeinfo/ti_ifloat.lo rt/typeinfo/ti_int.lo \\\n-\trt/typeinfo/ti_ireal.lo rt/typeinfo/ti_long.lo \\\n-\trt/typeinfo/ti_n.lo rt/typeinfo/ti_ptr.lo \\\n-\trt/typeinfo/ti_real.lo rt/typeinfo/ti_short.lo \\\n-\trt/typeinfo/ti_ubyte.lo rt/typeinfo/ti_ucent.lo \\\n-\trt/typeinfo/ti_uint.lo rt/typeinfo/ti_ulong.lo \\\n-\trt/typeinfo/ti_ushort.lo rt/typeinfo/ti_void.lo \\\n-\trt/typeinfo/ti_wchar.lo rt/util/array.lo \\\n-\trt/util/container/array.lo rt/util/container/common.lo \\\n-\trt/util/container/hashtab.lo rt/util/container/treap.lo \\\n-\trt/util/random.lo rt/util/typeinfo.lo rt/util/utf.lo\n+\trt/switch_.lo rt/tlsgc.lo rt/typeinfo/ti_Acdouble.lo \\\n+\trt/typeinfo/ti_Acfloat.lo rt/typeinfo/ti_Acreal.lo \\\n+\trt/typeinfo/ti_Adouble.lo rt/typeinfo/ti_Afloat.lo \\\n+\trt/typeinfo/ti_Ag.lo rt/typeinfo/ti_Aint.lo \\\n+\trt/typeinfo/ti_Along.lo rt/typeinfo/ti_Areal.lo \\\n+\trt/typeinfo/ti_Ashort.lo rt/typeinfo/ti_C.lo \\\n+\trt/typeinfo/ti_byte.lo rt/typeinfo/ti_cdouble.lo \\\n+\trt/typeinfo/ti_cent.lo rt/typeinfo/ti_cfloat.lo \\\n+\trt/typeinfo/ti_char.lo rt/typeinfo/ti_creal.lo \\\n+\trt/typeinfo/ti_dchar.lo rt/typeinfo/ti_delegate.lo \\\n+\trt/typeinfo/ti_double.lo rt/typeinfo/ti_float.lo \\\n+\trt/typeinfo/ti_idouble.lo rt/typeinfo/ti_ifloat.lo \\\n+\trt/typeinfo/ti_int.lo rt/typeinfo/ti_ireal.lo \\\n+\trt/typeinfo/ti_long.lo rt/typeinfo/ti_n.lo \\\n+\trt/typeinfo/ti_ptr.lo rt/typeinfo/ti_real.lo \\\n+\trt/typeinfo/ti_short.lo rt/typeinfo/ti_ubyte.lo \\\n+\trt/typeinfo/ti_ucent.lo rt/typeinfo/ti_uint.lo \\\n+\trt/typeinfo/ti_ulong.lo rt/typeinfo/ti_ushort.lo \\\n+\trt/typeinfo/ti_void.lo rt/typeinfo/ti_wchar.lo \\\n+\trt/util/array.lo rt/util/container/array.lo \\\n+\trt/util/container/common.lo rt/util/container/hashtab.lo \\\n+\trt/util/container/treap.lo rt/util/random.lo \\\n+\trt/util/typeinfo.lo rt/util/utf.lo\n am__objects_2 = gc/bits.lo gc/config.lo gc/gcinterface.lo \\\n \tgc/impl/conservative/gc.lo gc/impl/manual/gc.lo gc/os.lo \\\n \tgc/pooltable.lo gc/proxy.lo\n@@ -425,8 +426,7 @@ am__objects_27 = $(am__objects_1) $(am__objects_3) $(am__objects_5) \\\n \t$(am__objects_13) $(am__objects_15) $(am__objects_17) \\\n \t$(am__objects_19) $(am__objects_21) $(am__objects_23) \\\n \t$(am__objects_25) $(am__objects_26)\n-am__objects_28 = core/stdc/libgdruntime_la-errno_.lo \\\n-\trt/libgdruntime_la-bss_section.lo\n+am__objects_28 = core/stdc/libgdruntime_la-errno_.lo\n am__objects_29 = core/libgdruntime_la-threadasm.lo\n am__objects_30 = $(am__objects_27) $(am__objects_28) $(am__objects_29)\n am_libgdruntime_la_OBJECTS = $(am__objects_30)\n@@ -719,7 +719,7 @@ DRUNTIME_DSOURCES_GENERATED = gcc/config.d gcc/libbacktrace.d\n # Can't use wildcards here:\n # https://www.gnu.org/software/automake/manual/html_node/Wildcards.html\n DRUNTIME_SSOURCES = core/threadasm.S\n-DRUNTIME_CSOURCES = core/stdc/errno_.c rt/bss_section.c\n+DRUNTIME_CSOURCES = core/stdc/errno_.c\n DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/checkedint.d core/cpuid.d core/demangle.d core/exception.d \\\n \tcore/internal/abort.d core/internal/arrayop.d core/internal/convert.d \\\n@@ -736,14 +736,14 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/sync/config.d core/sync/exception.d core/sync/mutex.d \\\n \tcore/sync/rwmutex.d core/sync/semaphore.d core/thread.d core/time.d \\\n \tcore/vararg.d gcc/attribute.d gcc/backtrace.d gcc/builtins.d gcc/deh.d \\\n-\tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n-\tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n-\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n-\trt/arraycast.d rt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d \\\n-\trt/deh.d rt/dmain2.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n-\trt/minfo.d rt/monitor_.d rt/obj.d rt/qsort.d rt/sections.d \\\n-\trt/sections_android.d rt/sections_elf_shared.d rt/sections_osx.d \\\n-\trt/sections_solaris.d rt/sections_win32.d rt/sections_win64.d \\\n+\tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n+\tgcc/sections/package.d gcc/sections/solaris.d gcc/sections/win32.d \\\n+\tgcc/sections/win64.d gcc/unwind/arm.d gcc/unwind/arm_common.d \\\n+\tgcc/unwind/c6x.d gcc/unwind/generic.d gcc/unwind/package.d \\\n+\tgcc/unwind/pe.d object.d rt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d \\\n+\trt/arrayassign.d rt/arraycast.d rt/arraycat.d rt/cast_.d rt/config.d \\\n+\trt/critical_.d rt/deh.d rt/dmain2.d rt/invariant.d rt/lifetime.d \\\n+\trt/memory.d rt/minfo.d rt/monitor_.d rt/obj.d rt/qsort.d rt/sections.d \\\n \trt/switch_.d rt/tlsgc.d rt/typeinfo/ti_Acdouble.d \\\n \trt/typeinfo/ti_Acfloat.d rt/typeinfo/ti_Acreal.d \\\n \trt/typeinfo/ti_Adouble.d rt/typeinfo/ti_Afloat.d rt/typeinfo/ti_Ag.d \\\n@@ -1083,6 +1083,16 @@ gcc/attribute.lo: gcc/$(am__dirstamp)\n gcc/backtrace.lo: gcc/$(am__dirstamp)\n gcc/builtins.lo: gcc/$(am__dirstamp)\n gcc/deh.lo: gcc/$(am__dirstamp)\n+gcc/sections/$(am__dirstamp):\n+\t@$(MKDIR_P) gcc/sections\n+\t@: > gcc/sections/$(am__dirstamp)\n+gcc/sections/android.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/elf_shared.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/osx.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/package.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/solaris.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/win32.lo: gcc/sections/$(am__dirstamp)\n+gcc/sections/win64.lo: gcc/sections/$(am__dirstamp)\n gcc/unwind/$(am__dirstamp):\n \t@$(MKDIR_P) gcc/unwind\n \t@: > gcc/unwind/$(am__dirstamp)\n@@ -1115,12 +1125,6 @@ rt/monitor_.lo: rt/$(am__dirstamp)\n rt/obj.lo: rt/$(am__dirstamp)\n rt/qsort.lo: rt/$(am__dirstamp)\n rt/sections.lo: rt/$(am__dirstamp)\n-rt/sections_android.lo: rt/$(am__dirstamp)\n-rt/sections_elf_shared.lo: rt/$(am__dirstamp)\n-rt/sections_osx.lo: rt/$(am__dirstamp)\n-rt/sections_solaris.lo: rt/$(am__dirstamp)\n-rt/sections_win32.lo: rt/$(am__dirstamp)\n-rt/sections_win64.lo: rt/$(am__dirstamp)\n rt/switch_.lo: rt/$(am__dirstamp)\n rt/tlsgc.lo: rt/$(am__dirstamp)\n rt/typeinfo/$(am__dirstamp):\n@@ -1627,7 +1631,6 @@ core/sys/solaris/time.lo: core/sys/solaris/$(am__dirstamp)\n gcc/config.lo: gcc/$(am__dirstamp)\n gcc/libbacktrace.lo: gcc/$(am__dirstamp)\n core/stdc/libgdruntime_la-errno_.lo: core/stdc/$(am__dirstamp)\n-rt/libgdruntime_la-bss_section.lo: rt/$(am__dirstamp)\n core/libgdruntime_la-threadasm.lo: core/$(am__dirstamp)\n \n libgdruntime.la: $(libgdruntime_la_OBJECTS) $(libgdruntime_la_DEPENDENCIES) $(EXTRA_libgdruntime_la_DEPENDENCIES) \n@@ -1703,6 +1706,8 @@ mostlyclean-compile:\n \t-rm -f gc/impl/manual/*.lo\n \t-rm -f gcc/*.$(OBJEXT)\n \t-rm -f gcc/*.lo\n+\t-rm -f gcc/sections/*.$(OBJEXT)\n+\t-rm -f gcc/sections/*.lo\n \t-rm -f gcc/unwind/*.$(OBJEXT)\n \t-rm -f gcc/unwind/*.lo\n \t-rm -f gcstub/*.$(OBJEXT)\n@@ -1743,9 +1748,6 @@ core/libgdruntime_la-threadasm.lo: core/threadasm.S\n core/stdc/libgdruntime_la-errno_.lo: core/stdc/errno_.c\n \t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgdruntime_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o core/stdc/libgdruntime_la-errno_.lo `test -f 'core/stdc/errno_.c' || echo '$(srcdir)/'`core/stdc/errno_.c\n \n-rt/libgdruntime_la-bss_section.lo: rt/bss_section.c\n-\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgdruntime_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o rt/libgdruntime_la-bss_section.lo `test -f 'rt/bss_section.c' || echo '$(srcdir)/'`rt/bss_section.c\n-\n mostlyclean-libtool:\n \t-rm -f *.lo\n \n@@ -1785,6 +1787,7 @@ clean-libtool:\n \t-rm -rf gc/impl/conservative/.libs gc/impl/conservative/_libs\n \t-rm -rf gc/impl/manual/.libs gc/impl/manual/_libs\n \t-rm -rf gcc/.libs gcc/_libs\n+\t-rm -rf gcc/sections/.libs gcc/sections/_libs\n \t-rm -rf gcc/unwind/.libs gcc/unwind/_libs\n \t-rm -rf gcstub/.libs gcstub/_libs\n \t-rm -rf rt/.libs rt/_libs\n@@ -1931,6 +1934,7 @@ distclean-generic:\n \t-rm -f gc/impl/conservative/$(am__dirstamp)\n \t-rm -f gc/impl/manual/$(am__dirstamp)\n \t-rm -f gcc/$(am__dirstamp)\n+\t-rm -f gcc/sections/$(am__dirstamp)\n \t-rm -f gcc/unwind/$(am__dirstamp)\n \t-rm -f gcstub/$(am__dirstamp)\n \t-rm -f rt/$(am__dirstamp)"}, {"sha": "f00bb8926b73477cb8d61217058604c526b74b07", "filename": "libphobos/libdruntime/gcc/sections/android.d", "status": "renamed", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fandroid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fandroid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fandroid.d?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -1,14 +1,26 @@\n-/**\n- * Written in the D programming language.\n- * This module provides bionic-specific support for sections.\n- *\n- * Copyright: Copyright Martin Nowak 2012-2013.\n- * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n- * Authors:   Martin Nowak\n- * Source: $(DRUNTIMESRC src/rt/_sections_android.d)\n- */\n+// Bionic-specific support for sections.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n \n-module rt.sections_android;\n+module gcc.sections.android;\n \n version (CRuntime_Bionic):\n \n@@ -69,6 +81,8 @@ void initSections() nothrow @nogc\n \n     auto pbeg = cast(void*)&_tlsend;\n     auto pend = cast(void*)&__bss_end__;\n+    // _tlsend is a 32-bit int and may not be 64-bit void*-aligned, so align pbeg.\n+    version (D_LP64) pbeg = cast(void*)(cast(size_t)(pbeg + 7) & ~cast(size_t)7);\n     _sections._gcRanges[0] = pbeg[0 .. pend - pbeg];\n }\n \n@@ -105,32 +119,14 @@ void scanTLSRanges(void[]* rng, scope void delegate(void* pbeg, void* pend) noth\n  *       the corresponding address in the TLS dynamic per-thread data.\n  */\n \n-version (X86)\n+extern(C) void* __tls_get_addr( void* p ) nothrow @nogc\n {\n-    // NB: the compiler mangles this function as '___tls_get_addr'\n-    // even though it is extern(D)\n-    extern(D) void* ___tls_get_addr( void* p ) nothrow @nogc\n-    {\n-        debug(PRINTF) printf(\"  ___tls_get_addr input - %p\\n\", p);\n-        immutable offset = cast(size_t)(p - cast(void*)&_tlsstart);\n-        auto tls = getTLSBlockAlloc();\n-        assert(offset < tls.length);\n-        return tls.ptr + offset;\n-    }\n-}\n-else version (ARM)\n-{\n-    extern(C) void* __tls_get_addr( void** p ) nothrow @nogc\n-    {\n-        debug(PRINTF) printf(\"  __tls_get_addr input - %p\\n\", *p);\n-        immutable offset = cast(size_t)(*p - cast(void*)&_tlsstart);\n-        auto tls = getTLSBlockAlloc();\n-        assert(offset < tls.length);\n-        return tls.ptr + offset;\n-    }\n+    debug(PRINTF) printf(\"  __tls_get_addr input - %p\\n\", p);\n+    immutable offset = cast(size_t)(p - cast(void*)&_tlsstart);\n+    auto tls = getTLSBlockAlloc();\n+    assert(offset < tls.length);\n+    return tls.ptr + offset;\n }\n-else\n-    static assert( false, \"Android architecture not supported.\" );\n \n private:\n \n@@ -182,7 +178,7 @@ extern(C)\n \n         size_t __bss_end__;\n \n-        void* _tlsstart;\n-        void* _tlsend;\n+        int _tlsstart;\n+        int _tlsend;\n     }\n }", "previous_filename": "libphobos/libdruntime/rt/sections_android.d"}, {"sha": "f70c2329ade3cd0a70960df537bca89be0bbc3e0", "filename": "libphobos/libdruntime/gcc/sections/elf_shared.d", "status": "renamed", "additions": 146, "deletions": 194, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf_shared.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf_shared.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Felf_shared.d?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -1,18 +1,33 @@\n-/**\n- * Written in the D programming language.\n- * This module provides ELF-specific support for sections with shared libraries.\n- *\n- * Copyright: Copyright Martin Nowak 2012-2013.\n- * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n- * Authors:   Martin Nowak\n- * Source: $(DRUNTIMESRC src/rt/_sections_linux.d)\n- */\n+// ELF-specific support for sections with shared libraries.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n \n-module rt.sections_elf_shared;\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections.elf_shared;\n \n version (CRuntime_Glibc) enum SharedELF = true;\n+else version (CRuntime_Musl) enum SharedELF = true;\n else version (FreeBSD) enum SharedELF = true;\n else version (NetBSD) enum SharedELF = true;\n+else version (DragonFlyBSD) enum SharedELF = true;\n+else version (CRuntime_UClibc) enum SharedELF = true;\n else enum SharedELF = false;\n static if (SharedELF):\n \n@@ -40,6 +55,12 @@ else version (NetBSD)\n     import core.sys.netbsd.sys.elf;\n     import core.sys.netbsd.sys.link_elf;\n }\n+else version (DragonFlyBSD)\n+{\n+    import core.sys.dragonflybsd.dlfcn;\n+    import core.sys.dragonflybsd.sys.elf;\n+    import core.sys.dragonflybsd.sys.link_elf;\n+}\n else\n {\n     static assert(0, \"unimplemented\");\n@@ -51,6 +72,18 @@ import rt.minfo;\n import rt.util.container.array;\n import rt.util.container.hashtab;\n \n+/****\n+ * Asserts the specified condition, independent from -release, by abort()ing.\n+ * Regular assertions throw an AssertError and thus require an initialized\n+ * GC, which isn't the case (yet or anymore) for the startup/shutdown code in\n+ * this module (called by CRT ctors/dtors etc.).\n+ */\n+private void safeAssert(bool condition, scope string msg, size_t line = __LINE__) @nogc nothrow @safe\n+{\n+    import core.internal.abort;\n+    condition || abort(msg, __FILE__, line);\n+}\n+\n alias DSO SectionGroup;\n struct DSO\n {\n@@ -98,8 +131,8 @@ private:\n \n     invariant()\n     {\n-        assert(_moduleGroup.modules.length);\n-        assert(_tlsMod || !_tlsSize);\n+        safeAssert(_moduleGroup.modules.length > 0, \"No modules for DSO.\");\n+        safeAssert(_tlsMod || !_tlsSize, \"Inconsistent TLS fields for DSO.\");\n     }\n \n     ModuleGroup _moduleGroup;\n@@ -113,6 +146,12 @@ private:\n         Array!(DSO*) _deps; // D libraries needed by this DSO\n         void* _handle; // corresponding handle\n     }\n+\n+    // get the TLS range for the executing thread\n+    void[] tlsRange() const nothrow @nogc\n+    {\n+        return getTLSRange(_tlsMod, _tlsSize);\n+    }\n }\n \n /****\n@@ -122,6 +161,7 @@ __gshared bool _isRuntimeInitialized;\n \n \n version (FreeBSD) private __gshared void* dummy_ref;\n+version (DragonFlyBSD) private __gshared void* dummy_ref;\n version (NetBSD) private __gshared void* dummy_ref;\n \n /****\n@@ -132,6 +172,7 @@ void initSections() nothrow @nogc\n     _isRuntimeInitialized = true;\n     // reference symbol to support weak linkage\n     version (FreeBSD) dummy_ref = &_d_dso_registry;\n+    version (DragonFlyBSD) dummy_ref = &_d_dso_registry;\n     version (NetBSD) dummy_ref = &_d_dso_registry;\n }\n \n@@ -153,7 +194,7 @@ version (Shared)\n      */\n     Array!(ThreadDSO)* initTLSRanges() @nogc nothrow\n     {\n-        return &_loadedDSOs;\n+        return &_loadedDSOs();\n     }\n \n     void finiTLSRanges(Array!(ThreadDSO)* tdsos) @nogc nothrow\n@@ -181,7 +222,8 @@ version (Shared)\n             if (tdso._addCnt)\n             {\n                 // Increment the dlopen ref for explicitly loaded libraries to pin them.\n-                .dlopen(linkMapForHandle(tdso._pdso._handle).l_name, RTLD_LAZY) !is null || assert(0);\n+                const success = .dlopen(linkMapForHandle(tdso._pdso._handle).l_name, RTLD_LAZY) !is null;\n+                safeAssert(success, \"Failed to increment dlopen ref.\");\n                 (*res)[i]._addCnt = 1; // new array takes over the additional ref count\n             }\n         }\n@@ -197,7 +239,7 @@ version (Shared)\n             if (tdso._addCnt)\n             {\n                 auto handle = tdso._pdso._handle;\n-                handle !is null || assert(0);\n+                safeAssert(handle !is null, \"Invalid library handle.\");\n                 .dlclose(handle);\n             }\n         }\n@@ -209,7 +251,7 @@ version (Shared)\n     // of the parent thread.\n     void inheritLoadedLibraries(void* p) nothrow @nogc\n     {\n-        assert(_loadedDSOs.empty);\n+        safeAssert(_loadedDSOs.empty, \"DSOs have already been registered for this thread.\");\n         _loadedDSOs.swap(*cast(Array!(ThreadDSO)*)p);\n         .free(p);\n         foreach (ref dso; _loadedDSOs)\n@@ -227,7 +269,7 @@ version (Shared)\n             if (tdso._addCnt == 0) continue;\n \n             auto handle = tdso._pdso._handle;\n-            handle !is null || assert(0);\n+            safeAssert(handle !is null, \"Invalid DSO handle.\");\n             for (; tdso._addCnt > 0; --tdso._addCnt)\n                 .dlclose(handle);\n         }\n@@ -243,7 +285,7 @@ else\n      */\n     Array!(void[])* initTLSRanges() nothrow @nogc\n     {\n-        return &_tlsRanges;\n+        return &_tlsRanges();\n     }\n \n     void finiTLSRanges(Array!(void[])* rngs) nothrow @nogc\n@@ -260,10 +302,6 @@ else\n \n private:\n \n-// start of linked list for ModuleInfo references\n-version (FreeBSD) deprecated extern (C) __gshared void* _Dmodule_ref;\n-version (NetBSD) deprecated extern (C) __gshared void* _Dmodule_ref;\n-\n version (Shared)\n {\n     /*\n@@ -290,10 +328,10 @@ version (Shared)\n         // update the _tlsRange for the executing thread\n         void updateTLSRange() nothrow @nogc\n         {\n-            _tlsRange = getTLSRange(_pdso._tlsMod, _pdso._tlsSize);\n+            _tlsRange = _pdso.tlsRange();\n         }\n     }\n-    Array!(ThreadDSO) _loadedDSOs;\n+    @property ref Array!(ThreadDSO) _loadedDSOs() @nogc nothrow { static Array!(ThreadDSO) x; return x; }\n \n     /*\n      * Set to true during rt_loadLibrary/rt_unloadLibrary calls.\n@@ -305,7 +343,7 @@ version (Shared)\n      * The hash table is protected by a Mutex.\n      */\n     __gshared pthread_mutex_t _handleToDSOMutex;\n-    __gshared HashTab!(void*, DSO*) _handleToDSO;\n+    @property ref HashTab!(void*, DSO*) _handleToDSO() @nogc nothrow { __gshared HashTab!(void*, DSO*) x; return x; }\n \n     /*\n      * Section in executable that contains copy relocations.\n@@ -319,13 +357,13 @@ else\n      * Static DSOs loaded by the runtime linker. This includes the\n      * executable. These can't be unloaded.\n      */\n-    __gshared Array!(DSO*) _loadedDSOs;\n+    @property ref Array!(DSO*) _loadedDSOs() @nogc nothrow { __gshared Array!(DSO*) x; return x; }\n \n     /*\n      * Thread local array that contains TLS memory ranges for each\n      * library initialized in this thread.\n      */\n-    Array!(void[]) _tlsRanges;\n+    @property ref Array!(void[]) _tlsRanges() @nogc nothrow { static Array!(void[]) x; return x; }\n \n     enum _rtLoading = false;\n }\n@@ -334,8 +372,6 @@ else\n // Compiler to runtime interface.\n ///////////////////////////////////////////////////////////////////////////////\n \n-import gcc.config;\n-\n /*\n  * This data structure is generated by the compiler, and then passed to\n  * _d_dso_registry().\n@@ -357,7 +393,7 @@ T[] toRange(T)(T* beg, T* end) { return beg[0 .. end - beg]; }\n extern(C) void _d_dso_registry(CompilerDSOData* data)\n {\n     // only one supported currently\n-    data._version >= 1 || assert(0, \"corrupt DSO data version\");\n+    safeAssert(data._version >= 1, \"Incompatible compiler-generated DSO data version.\");\n \n     // no backlink => register\n     if (*data._slot is null)\n@@ -372,23 +408,15 @@ extern(C) void _d_dso_registry(CompilerDSOData* data)\n         pdso._moduleGroup = ModuleGroup(toRange(data._minfo_beg, data._minfo_end));\n \n         dl_phdr_info info = void;\n-        findDSOInfoForAddr(data._slot, &info) || assert(0);\n+        const headerFound = findDSOInfoForAddr(data._slot, &info);\n+        safeAssert(headerFound, \"Failed to find image header.\");\n \n         scanSegments(info, pdso);\n \n         version (Shared)\n         {\n             auto handle = handleForAddr(data._slot);\n \n-            if (firstDSO)\n-            {\n-                /// Assert that the first loaded DSO is druntime itself. Use a\n-                /// local druntime symbol (rt_get_bss_start) to get the handle.\n-                assert(handleForAddr(data._slot) == handleForAddr(&rt_get_bss_start));\n-                _copyRelocSection = getCopyRelocSection();\n-            }\n-            checkModuleCollisions(info, pdso._moduleGroup.modules, _copyRelocSection);\n-\n             getDependencies(info, pdso._deps);\n             pdso._handle = handle;\n             setDSOForHandle(pdso, pdso._handle);\n@@ -402,15 +430,15 @@ extern(C) void _d_dso_registry(CompilerDSOData* data)\n                  * thread with a refCnt of 1 and call the TlsCtors.\n                  */\n                 immutable ushort refCnt = 1, addCnt = 0;\n-                auto tlsRng = getTLSRange(pdso._tlsMod, pdso._tlsSize);\n-                _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt, tlsRng));\n+                _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt, pdso.tlsRange()));\n             }\n         }\n         else\n         {\n-            foreach (p; _loadedDSOs) assert(p !is pdso);\n+            foreach (p; _loadedDSOs)\n+                safeAssert(p !is pdso, \"DSO already registered.\");\n             _loadedDSOs.insertBack(pdso);\n-            _tlsRanges.insertBack(getTLSRange(pdso._tlsMod, pdso._tlsSize));\n+            _tlsRanges.insertBack(pdso.tlsRange());\n         }\n \n         // don't initialize modules before rt_init was called (see Bugzilla 11378)\n@@ -457,25 +485,31 @@ extern(C) void _d_dso_registry(CompilerDSOData* data)\n             }\n \n             unsetDSOForHandle(pdso, pdso._handle);\n-            pdso._handle = null;\n         }\n         else\n         {\n             // static DSOs are unloaded in reverse order\n-            assert(pdso._tlsSize == _tlsRanges.back.length);\n-            _tlsRanges.popBack();\n-            assert(pdso == _loadedDSOs.back);\n+            safeAssert(pdso == _loadedDSOs.back, \"DSO being unregistered isn't current last one.\");\n             _loadedDSOs.popBack();\n         }\n \n         freeDSO(pdso);\n \n-        if (_loadedDSOs.empty) finiLocks(); // last DSO\n+        // last DSO being unloaded => shutdown registry\n+        if (_loadedDSOs.empty)\n+        {\n+            version (Shared)\n+            {\n+                safeAssert(_handleToDSO.empty, \"_handleToDSO not in sync with _loadedDSOs.\");\n+                _handleToDSO.reset();\n+            }\n+            finiLocks();\n+        }\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n-// dynamic loading\n+// Dynamic loading\n ///////////////////////////////////////////////////////////////////////////////\n \n // Shared D libraries are only supported when linking against a shared druntime library.\n@@ -501,17 +535,16 @@ version (Shared)\n             foreach (dep; pdso._deps)\n                 incThreadRef(dep, false);\n             immutable ushort refCnt = 1, addCnt = incAdd ? 1 : 0;\n-            auto tlsRng = getTLSRange(pdso._tlsMod, pdso._tlsSize);\n-            _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt, tlsRng));\n+            _loadedDSOs.insertBack(ThreadDSO(pdso, refCnt, addCnt, pdso.tlsRange()));\n             pdso._moduleGroup.runTlsCtors();\n         }\n     }\n \n     void decThreadRef(DSO* pdso, bool decAdd)\n     {\n         auto tdata = findThreadDSO(pdso);\n-        tdata !is null || assert(0);\n-        !decAdd || tdata._addCnt > 0 || assert(0, \"Mismatching rt_unloadLibrary call.\");\n+        safeAssert(tdata !is null, \"Failed to find thread DSO.\");\n+        safeAssert(!decAdd || tdata._addCnt > 0, \"Mismatching rt_unloadLibrary call.\");\n \n         if (decAdd && --tdata._addCnt > 0) return;\n         if (--tdata._refCnt > 0) return;\n@@ -554,7 +587,7 @@ version (Shared)\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n-// helper functions\n+// Helper functions\n ///////////////////////////////////////////////////////////////////////////////\n \n void initLocks() nothrow @nogc\n@@ -603,29 +636,35 @@ version (Shared) void runFinalizers(DSO* pdso)\n void freeDSO(DSO* pdso) nothrow @nogc\n {\n     pdso._gcRanges.reset();\n-    version (Shared) pdso._codeSegments.reset();\n+    version (Shared)\n+    {\n+        pdso._codeSegments.reset();\n+        pdso._deps.reset();\n+        pdso._handle = null;\n+    }\n     .free(pdso);\n }\n \n version (Shared)\n {\n @nogc nothrow:\n-    link_map* linkMapForHandle(void* handle) nothrow @nogc\n+    link_map* linkMapForHandle(void* handle)\n     {\n         link_map* map;\n-        dlinfo(handle, RTLD_DI_LINKMAP, &map) == 0 || assert(0);\n+        const success = dlinfo(handle, RTLD_DI_LINKMAP, &map) == 0;\n+        safeAssert(success, \"Failed to get DSO info.\");\n         return map;\n     }\n \n-     link_map* exeLinkMap(link_map* map) nothrow @nogc\n+     link_map* exeLinkMap(link_map* map)\n      {\n-         assert(map);\n+         safeAssert(map !is null, \"Invalid link_map.\");\n          while (map.l_prev !is null)\n              map = map.l_prev;\n          return map;\n      }\n \n-    DSO* dsoForHandle(void* handle) nothrow @nogc\n+    DSO* dsoForHandle(void* handle)\n     {\n         DSO* pdso;\n         !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n@@ -635,23 +674,23 @@ version (Shared)\n         return pdso;\n     }\n \n-    void setDSOForHandle(DSO* pdso, void* handle) nothrow @nogc\n+    void setDSOForHandle(DSO* pdso, void* handle)\n     {\n         !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n-        assert(handle !in _handleToDSO);\n+        safeAssert(handle !in _handleToDSO, \"DSO already registered.\");\n         _handleToDSO[handle] = pdso;\n         !pthread_mutex_unlock(&_handleToDSOMutex) || assert(0);\n     }\n \n-    void unsetDSOForHandle(DSO* pdso, void* handle) nothrow @nogc\n+    void unsetDSOForHandle(DSO* pdso, void* handle)\n     {\n         !pthread_mutex_lock(&_handleToDSOMutex) || assert(0);\n-        assert(_handleToDSO[handle] == pdso);\n+        safeAssert(_handleToDSO[handle] == pdso, \"Handle doesn't match registered DSO.\");\n         _handleToDSO.remove(handle);\n         !pthread_mutex_unlock(&_handleToDSOMutex) || assert(0);\n     }\n \n-    void getDependencies(in ref dl_phdr_info info, ref Array!(DSO*) deps) nothrow @nogc\n+    void getDependencies(in ref dl_phdr_info info, ref Array!(DSO*) deps)\n     {\n         // get the entries of the .dynamic section\n         ElfW!\"Dyn\"[] dyns;\n@@ -670,12 +709,16 @@ version (Shared)\n         {\n             if (dyn.d_tag == DT_STRTAB)\n             {\n-                version (linux)\n+                version (CRuntime_Musl)\n+                    strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate\n+                else version (linux)\n                     strtab = cast(const(char)*)dyn.d_un.d_ptr;\n                 else version (FreeBSD)\n                     strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate\n                 else version (NetBSD)\n                     strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate\n+                else version (DragonFlyBSD)\n+                    strtab = cast(const(char)*)(info.dlpi_addr + dyn.d_un.d_ptr); // relocate\n                 else\n                     static assert(0, \"unimplemented\");\n                 break;\n@@ -692,14 +735,14 @@ version (Shared)\n             // get handle without loading the library\n             auto handle = handleForName(name);\n             // the runtime linker has already loaded all dependencies\n-            if (handle is null) assert(0);\n+            safeAssert(handle !is null, \"Failed to get library handle.\");\n             // if it's a D library\n             if (auto pdso = dsoForHandle(handle))\n                 deps.insertBack(pdso); // append it to the dependencies\n         }\n     }\n \n-    void* handleForName(const char* name) nothrow @nogc\n+    void* handleForName(const char* name)\n     {\n         auto handle = .dlopen(name, RTLD_NOLOAD | RTLD_LAZY);\n         if (handle !is null) .dlclose(handle); // drop reference count\n@@ -735,7 +778,7 @@ void scanSegments(in ref dl_phdr_info info, DSO* pdso) nothrow @nogc\n             break;\n \n         case PT_TLS: // TLS segment\n-            assert(!pdso._tlsSize); // is unique per DSO\n+            safeAssert(!pdso._tlsSize, \"Multiple TLS segments in image header.\");\n             pdso._tlsMod = info.dlpi_tls_modid;\n             pdso._tlsSize = phdr.p_memsz;\n             break;\n@@ -748,55 +791,51 @@ void scanSegments(in ref dl_phdr_info info, DSO* pdso) nothrow @nogc\n \n /**************************\n  * Input:\n- *      result  where the output is to be written; dl_phdr_info is a Linux struct\n+ *      result  where the output is to be written; dl_phdr_info is an OS struct\n  * Returns:\n  *      true if found, and *result is filled in\n  * References:\n  *      http://linux.die.net/man/3/dl_iterate_phdr\n  */\n-version (linux) bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null) nothrow @nogc\n+bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null) nothrow @nogc\n {\n-    static struct DG { const(void)* addr; dl_phdr_info* result; }\n+    version (linux)       enum IterateManually = true;\n+    else version (NetBSD) enum IterateManually = true;\n+    else                  enum IterateManually = false;\n \n-    extern(C) int callback(dl_phdr_info* info, size_t sz, void* arg) nothrow @nogc\n+    static if (IterateManually)\n     {\n-        auto p = cast(DG*)arg;\n-        if (findSegmentForAddr(*info, p.addr))\n+        static struct DG { const(void)* addr; dl_phdr_info* result; }\n+\n+        extern(C) int callback(dl_phdr_info* info, size_t sz, void* arg) nothrow @nogc\n         {\n-            if (p.result !is null) *p.result = *info;\n-            return 1; // break;\n+            auto p = cast(DG*)arg;\n+            if (findSegmentForAddr(*info, p.addr))\n+            {\n+                if (p.result !is null) *p.result = *info;\n+                return 1; // break;\n+            }\n+            return 0; // continue iteration\n         }\n-        return 0; // continue iteration\n-    }\n \n-    auto dg = DG(addr, result);\n+        auto dg = DG(addr, result);\n \n-    /* Linux function that walks through the list of an application's shared objects and\n-     * calls 'callback' once for each object, until either all shared objects\n-     * have been processed or 'callback' returns a nonzero value.\n-     */\n-    return dl_iterate_phdr(&callback, &dg) != 0;\n-}\n-else version (FreeBSD) bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null) nothrow @nogc\n-{\n-    return !!_rtld_addr_phdr(addr, result);\n-}\n-else version (NetBSD) bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null) nothrow @nogc\n-{\n-    static struct DG { const(void)* addr; dl_phdr_info* result; }\n-\n-    extern(C) int callback(dl_phdr_info* info, size_t sz, void* arg) nothrow @nogc\n+        /* OS function that walks through the list of an application's shared objects and\n+         * calls 'callback' once for each object, until either all shared objects\n+         * have been processed or 'callback' returns a nonzero value.\n+         */\n+        return dl_iterate_phdr(&callback, &dg) != 0;\n+    }\n+    else version (FreeBSD)\n     {\n-        auto p = cast(DG*)arg;\n-        if (findSegmentForAddr(*info, p.addr))\n-        {\n-            if (p.result !is null) *p.result = *info;\n-            return 1; // break;\n-        }\n-        return 0; // continue iteration\n+        return !!_rtld_addr_phdr(addr, result);\n+    }\n+    else version (DragonFlyBSD)\n+    {\n+        return !!_rtld_addr_phdr(addr, result);\n     }\n-    auto dg = DG(addr, result);\n-    return dl_iterate_phdr(&callback, &dg) != 0;\n+    else\n+        static assert(0, \"unimplemented\");\n }\n \n /*********************************\n@@ -823,12 +862,14 @@ bool findSegmentForAddr(in ref dl_phdr_info info, in void* addr, ElfW!\"Phdr\"* re\n version (linux) import core.sys.linux.errno : program_invocation_name;\n // should be in core.sys.freebsd.stdlib\n version (FreeBSD) extern(C) const(char)* getprogname() nothrow @nogc;\n+version (DragonFlyBSD) extern(C) const(char)* getprogname() nothrow @nogc;\n version (NetBSD) extern(C) const(char)* getprogname() nothrow @nogc;\n \n @property const(char)* progname() nothrow @nogc\n {\n     version (linux) return program_invocation_name;\n     version (FreeBSD) return getprogname();\n+    version (DragonFlyBSD) return getprogname();\n     version (NetBSD) return getprogname();\n }\n \n@@ -839,95 +880,6 @@ const(char)[] dsoName(const char* dlpi_name) nothrow @nogc\n     return p[0 .. strlen(p)];\n }\n \n-extern(C)\n-{\n-    void* rt_get_bss_start() @nogc nothrow;\n-    void* rt_get_end() @nogc nothrow;\n-}\n-\n-/// get the BSS section of the executable to check for copy relocations\n-const(void)[] getCopyRelocSection() nothrow @nogc\n-{\n-    auto bss_start = rt_get_bss_start();\n-    auto bss_end = rt_get_end();\n-    immutable bss_size = bss_end - bss_start;\n-\n-    /**\n-       Check whether __bss_start/_end both lie within the executable DSO.same DSO.\n-\n-       When a C host program dynamically loads druntime, i.e. it isn't linked\n-       against, __bss_start/_end might be defined in different DSOs, b/c the\n-       linker creates those symbols only when they are used.\n-       But as there are no copy relocations when dynamically loading a shared\n-       library, we can simply return a null bss range in that case.\n-    */\n-    if (bss_size <= 0)\n-        return null;\n-\n-    version (linux)\n-        enum ElfW!\"Addr\" exeBaseAddr = 0;\n-    else version (FreeBSD)\n-        enum ElfW!\"Addr\" exeBaseAddr = 0;\n-    else version (NetBSD)\n-        enum ElfW!\"Addr\" exeBaseAddr = 0;\n-\n-    dl_phdr_info info = void;\n-    findDSOInfoForAddr(bss_start, &info) || assert(0);\n-    if (info.dlpi_addr != exeBaseAddr)\n-        return null;\n-    findDSOInfoForAddr(bss_end - 1, &info) || assert(0);\n-    if (info.dlpi_addr != exeBaseAddr)\n-        return null;\n-\n-    return bss_start[0 .. bss_size];\n-}\n-\n-/**\n- * Check for module collisions. A module in a shared library collides\n- * with an existing module if it's ModuleInfo is interposed (search\n- * symbol interposition) by another DSO.  Therefor two modules with the\n- * same name do not collide if their DSOs are in separate symbol resolution\n- * chains.\n- */\n-void checkModuleCollisions(in ref dl_phdr_info info, in immutable(ModuleInfo)*[] modules,\n-                           in void[] copyRelocSection) nothrow @nogc\n-in { assert(modules.length); }\n-body\n-{\n-    immutable(ModuleInfo)* conflicting;\n-\n-    foreach (m; modules)\n-    {\n-        auto addr = cast(const(void*))m;\n-        if (cast(size_t)(addr - copyRelocSection.ptr) < copyRelocSection.length)\n-        {\n-            // Module is in .bss of the exe because it was copy relocated\n-        }\n-        else if (!findSegmentForAddr(info, addr))\n-        {\n-            // Module is in another DSO\n-            conflicting = m;\n-            break;\n-        }\n-    }\n-\n-    if (conflicting !is null)\n-    {\n-        dl_phdr_info other=void;\n-        findDSOInfoForAddr(conflicting, &other) || assert(0);\n-\n-        auto modname = conflicting.name;\n-        auto loading = dsoName(info.dlpi_name);\n-        auto existing = dsoName(other.dlpi_name);\n-        fprintf(stderr, \"Fatal Error while loading '%.*s':\\n\\tThe module '%.*s' is already defined in '%.*s'.\\n\",\n-                cast(int)loading.length, loading.ptr,\n-                cast(int)modname.length, modname.ptr,\n-                cast(int)existing.length, existing.ptr);\n-        import core.stdc.stdlib : _Exit;\n-        _Exit(1);\n-    }\n-}\n-\n /**************************\n  * Input:\n  *      addr  an internal address of a DSO", "previous_filename": "libphobos/libdruntime/rt/sections_elf_shared.d"}, {"sha": "55caee48a59cab74ec93fc2fc5b2c52d0e483d13", "filename": "libphobos/libdruntime/gcc/sections/osx.d", "status": "renamed", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fosx.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fosx.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fosx.d?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -1,16 +1,26 @@\n-/**\n- * Written in the D programming language.\n- * This module provides OSX-specific support for sections.\n- *\n- * Copyright: Copyright Digital Mars 2008 - 2012.\n- * License: Distributed under the\n- *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n- *    (See accompanying file LICENSE)\n- * Authors:   Walter Bright, Sean Kelly, Martin Nowak\n- * Source: $(DRUNTIMESRC src/rt/_sections_osx.d)\n- */\n+// OSX-specific support for sections.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n \n-module rt.sections_osx;\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections.osx;\n \n version (OSX):\n \n@@ -35,22 +45,22 @@ struct SectionGroup\n         return dg(_sections);\n     }\n \n-    @property immutable(ModuleInfo*)[] modules() const\n+    @property immutable(ModuleInfo*)[] modules() const nothrow @nogc\n     {\n         return _moduleGroup.modules;\n     }\n \n-    @property ref inout(ModuleGroup) moduleGroup() inout\n+    @property ref inout(ModuleGroup) moduleGroup() inout nothrow @nogc\n     {\n         return _moduleGroup;\n     }\n \n-    @property inout(void[])[] gcRanges() inout\n+    @property inout(void[])[] gcRanges() inout nothrow @nogc\n     {\n         return _gcRanges[];\n     }\n \n-    @property immutable(FuncTable)[] ehTables() const\n+    @property immutable(FuncTable)[] ehTables() const nothrow @nogc\n     {\n         return _ehTables[];\n     }\n@@ -70,7 +80,7 @@ __gshared bool _isRuntimeInitialized;\n /****\n  * Gets called on program startup just before GC is initialized.\n  */\n-void initSections()\n+void initSections() nothrow @nogc\n {\n     pthread_key_create(&_tlsKey, null);\n     _dyld_register_func_for_add_image(&sections_osx_onAddImage);\n@@ -80,19 +90,19 @@ void initSections()\n /***\n  * Gets called on program shutdown just after GC is terminated.\n  */\n-void finiSections()\n+void finiSections() nothrow @nogc\n {\n     _sections._gcRanges.reset();\n     pthread_key_delete(_tlsKey);\n     _isRuntimeInitialized = false;\n }\n \n-void[]* initTLSRanges()\n+void[]* initTLSRanges() nothrow @nogc\n {\n     return &getTLSBlock();\n }\n \n-void finiTLSRanges(void[]* rng)\n+void finiTLSRanges(void[]* rng) nothrow @nogc\n {\n     .free(rng.ptr);\n     .free(rng);\n@@ -148,7 +158,7 @@ body\n     assert(0);\n }\n \n-ref void[] getTLSBlock()\n+ref void[] getTLSBlock() nothrow @nogc\n {\n     auto pary = cast(void[]*)pthread_getspecific(_tlsKey);\n     if (pary is null)\n@@ -180,7 +190,6 @@ ref void[] getTLSBlockAlloc()\n     return *pary;\n }\n \n-\n __gshared SectionGroup _sections;\n \n extern (C) void sections_osx_onAddImage(in mach_header* h, intptr_t slide)\n@@ -245,12 +254,10 @@ struct SegRef\n     string sect;\n }\n \n-\n static immutable SegRef[] dataSegs = [{SEG_DATA, SECT_DATA},\n                                       {SEG_DATA, SECT_BSS},\n                                       {SEG_DATA, SECT_COMMON}];\n \n-\n ubyte[] getSection(in mach_header* header, intptr_t slide,\n                    in char* segmentName, in char* sectionName)\n {", "previous_filename": "libphobos/libdruntime/rt/sections_osx.d"}, {"sha": "07617ea977fa58da4c14e1da331f5dad46c8005f", "filename": "libphobos/libdruntime/gcc/sections/package.d", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fpackage.d?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -0,0 +1,48 @@\n+// Run-time support for retrieving platform-specific sections.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections;\n+\n+version (CRuntime_Glibc)\n+    public import gcc.sections.elf_shared;\n+else version (CRuntime_Musl)\n+    public import gcc.sections.elf_shared;\n+else version (CRuntime_UClibc)\n+    public import gcc.sections.elf_shared;\n+else version (FreeBSD)\n+    public import gcc.sections.elf_shared;\n+else version (NetBSD)\n+    public import gcc.sections.elf_shared;\n+else version (DragonFlyBSD)\n+    public import gcc.sections.elf_shared;\n+else version (Solaris)\n+    public import gcc.sections.solaris;\n+else version (OSX)\n+    public import gcc.sections.osx;\n+else version (CRuntime_DigitalMars)\n+    public import gcc.sections.win32;\n+else version (CRuntime_Microsoft)\n+    public import gcc.sections.win64;\n+else version (CRuntime_Bionic)\n+    public import gcc.sections.android;\n+else\n+    static assert(0, \"unimplemented\");"}, {"sha": "e66325b7a2c89fdb38f2e8bf3db5e743aa20ff24", "filename": "libphobos/libdruntime/gcc/sections/solaris.d", "status": "renamed", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fsolaris.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fsolaris.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fsolaris.d?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -1,14 +1,26 @@\n-/**\n- * Written in the D programming language.\n- * This module provides Solaris-specific support for sections.\n- *\n- * Copyright: Copyright Martin Nowak 2012-2013.\n- * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n- * Authors:   Martin Nowak\n- * Source: $(DRUNTIMESRC src/rt/_sections_solaris.d)\n- */\n-\n-module rt.sections_solaris;\n+// Solaris-specific support for sections.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections.solaris;\n \n version (Solaris):\n ", "previous_filename": "libphobos/libdruntime/rt/sections_solaris.d"}, {"sha": "4b76ca8999531f9e8edcd2145bd3ddbab7dc8457", "filename": "libphobos/libdruntime/gcc/sections/win32.d", "status": "renamed", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin32.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin32.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin32.d?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -1,16 +1,26 @@\n-/**\n- * Written in the D programming language.\n- * This module provides Win32-specific support for sections.\n- *\n- * Copyright: Copyright Digital Mars 2008 - 2012.\n- * License: Distributed under the\n- *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n- *    (See accompanying file LICENSE)\n- * Authors:   Walter Bright, Sean Kelly, Martin Nowak\n- * Source: $(DRUNTIMESRC src/rt/_sections_win32.d)\n- */\n-\n-module rt.sections_win32;\n+// Win32-specific support for sections.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections.win32;\n \n version (CRuntime_DigitalMars):\n ", "previous_filename": "libphobos/libdruntime/rt/sections_win32.d"}, {"sha": "b98c3527e706d148129ed6d117129745fdcd5d85", "filename": "libphobos/libdruntime/gcc/sections/win64.d", "status": "renamed", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin64.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin64.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fsections%2Fwin64.d?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -1,16 +1,26 @@\n-/**\n- * Written in the D programming language.\n- * This module provides Win32-specific support for sections.\n- *\n- * Copyright: Copyright Digital Mars 2008 - 2012.\n- * License: Distributed under the\n- *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n- *    (See accompanying file LICENSE)\n- * Authors:   Walter Bright, Sean Kelly, Martin Nowak\n- * Source: $(DRUNTIMESRC src/rt/_sections_win64.d)\n- */\n-\n-module rt.sections_win64;\n+// Win64-specific support for sections.\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+module gcc.sections.win64;\n \n version (CRuntime_Microsoft):\n \n@@ -271,7 +281,7 @@ struct IMAGE_NT_HEADERS\n \n struct IMAGE_SECTION_HEADER\n {\n-    char[8] Name;\n+    char[8] Name = 0;\n     union {\n         uint   PhysicalAddress;\n         uint   VirtualSize;", "previous_filename": "libphobos/libdruntime/rt/sections_win64.d"}, {"sha": "b00f40d51c0513a7ed15c34342d5be7d4c4deb9a", "filename": "libphobos/libdruntime/rt/bss_section.c", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/151c5c0b80a30ba4316c86fcd0a7bf232a4ff127/libphobos%2Flibdruntime%2Frt%2Fbss_section.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/151c5c0b80a30ba4316c86fcd0a7bf232a4ff127/libphobos%2Flibdruntime%2Frt%2Fbss_section.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fbss_section.c?ref=151c5c0b80a30ba4316c86fcd0a7bf232a4ff127", "patch": "@@ -1,21 +0,0 @@\n-/**\n- * This module is used to detect copy relocated ModuleInfos (located in .bss section).\n- *\n- * Copyright: Copyright Martin Nowak 2014-.\n- * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n- * Authors:   Martin Nowak\n- * Source: $(DRUNTIMESRC src/rt/_bss_section.c)\n- */\n-\n-/* These symbols are defined in the linker script and bracket the\n- * .bss, .lbss, .lrodata and .ldata sections.\n- */\n-#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n-// Need to use weak linkage to workaround a bug in ld.bfd (Bugzilla 13025).\n-extern int __attribute__((weak)) __bss_start, _end;\n-\n-__attribute__ ((visibility (\"hidden\"))) void* rt_get_bss_start();\n-__attribute__ ((visibility (\"hidden\"))) void* rt_get_end();\n-void* rt_get_bss_start() { return (void*)&__bss_start; }\n-void* rt_get_end() { return (void*)&_end; }\n-#endif"}, {"sha": "6009a79abc5d1d1384c75d1e13d0bfa97d53fc99", "filename": "libphobos/libdruntime/rt/sections.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Frt%2Fsections.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6518285b87fd282573fa5d7d6f7414d58dc96b/libphobos%2Flibdruntime%2Frt%2Fsections.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fsections.d?ref=8b6518285b87fd282573fa5d7d6f7414d58dc96b", "patch": "@@ -8,6 +8,9 @@\n  * Source: $(DRUNTIMESRC src/rt/_sections.d)\n  */\n \n+/* NOTE: This file has been patched from the original DMD distribution to\n+ * work with the GDC compiler.\n+ */\n module rt.sections;\n \n version (OSX)\n@@ -19,7 +22,9 @@ else version (TVOS)\n else version (WatchOS)\n     version = Darwin;\n \n-version (CRuntime_Glibc)\n+version (GNU)\n+    public import gcc.sections;\n+else version (CRuntime_Glibc)\n     public import rt.sections_elf_shared;\n else version (FreeBSD)\n     public import rt.sections_elf_shared;"}]}