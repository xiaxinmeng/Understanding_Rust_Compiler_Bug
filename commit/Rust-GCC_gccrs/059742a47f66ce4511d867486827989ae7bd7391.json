{"sha": "059742a47f66ce4511d867486827989ae7bd7391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU5NzQyYTQ3ZjY2Y2U0NTExZDg2NzQ4NjgyNzk4OWFlN2JkNzM5MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2014-02-14T20:26:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-02-14T20:26:31Z"}, "message": "re PR rtl-optimization/60131 (RTL check fail in rhs_regno)\n\n\tPR rtl-optimization/60131\n\t* ree.c (get_extended_src_reg): New function.\n\t(combine_reaching_defs): Use it rather than assuming location\n\tof REG.\n\t(find_and_remove_re): Verify first operand of extension is\n\ta REG before adding the insns to the copy list.\n\n\tPR rtl-optimization/60131\n\t* g++.dg/torture/pr60131.C: New test.\n\nFrom-SVN: r207792", "tree": {"sha": "09969290c7ea97e942a1f194ee131355d70fa1cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09969290c7ea97e942a1f194ee131355d70fa1cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/059742a47f66ce4511d867486827989ae7bd7391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059742a47f66ce4511d867486827989ae7bd7391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059742a47f66ce4511d867486827989ae7bd7391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059742a47f66ce4511d867486827989ae7bd7391/comments", "author": null, "committer": null, "parents": [{"sha": "88f7c49a8bfe6c9e7ac04da2ef3ba8281d3dba06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f7c49a8bfe6c9e7ac04da2ef3ba8281d3dba06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f7c49a8bfe6c9e7ac04da2ef3ba8281d3dba06"}], "stats": {"total": 74, "additions": 67, "deletions": 7}, "files": [{"sha": "59d1671f5ee6642b7002c4a59ffc6c75be192971", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059742a47f66ce4511d867486827989ae7bd7391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059742a47f66ce4511d867486827989ae7bd7391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=059742a47f66ce4511d867486827989ae7bd7391", "patch": "@@ -1,3 +1,12 @@\n+2014-02-14  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/60131\n+\t* ree.c (get_extended_src_reg): New function.\n+\t(combine_reaching_defs): Use it rather than assuming location\n+\tof REG.\n+\t(find_and_remove_re): Verify first operand of extension is\n+\ta REG before adding the insns to the copy list.\n+\n 2014-02-14  Roland McGrath  <mcgrathr@google.com>\n \n \t* configure.ac (HAVE_AS_IX86_UD2): New test for 'ud2' mnemonic."}, {"sha": "fcde9a0f3993d5a16281ed9a058cd3a040bd3db5", "filename": "gcc/ree.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059742a47f66ce4511d867486827989ae7bd7391/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059742a47f66ce4511d867486827989ae7bd7391/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=059742a47f66ce4511d867486827989ae7bd7391", "patch": "@@ -670,6 +670,18 @@ merge_def_and_ext (ext_cand *cand, rtx def_insn, ext_state *state)\n   return false;\n }\n \n+/* Given SRC, which should be one or more extensions of a REG, strip\n+   away the extensions and return the REG.  */\n+\n+static inline rtx\n+get_extended_src_reg (rtx src)\n+{\n+  while (GET_CODE (src) == SIGN_EXTEND || GET_CODE (src) == ZERO_EXTEND)\n+    src = XEXP (src, 0);\n+  gcc_assert (REG_P (src));\n+  return src;\n+}\n+\n /* This function goes through all reaching defs of the source\n    of the candidate for elimination (CAND) and tries to combine\n    the extension with the definition instruction.  The changes\n@@ -698,17 +710,23 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n \n   /* If the destination operand of the extension is a different\n      register than the source operand, then additional restrictions\n-     are needed.  */\n-  if ((REGNO (SET_DEST (PATTERN (cand->insn)))\n-       != REGNO (XEXP (SET_SRC (PATTERN (cand->insn)), 0))))\n+     are needed.  Note we have to handle cases where we have nested\n+     extensions in the source operand.  */\n+  if (REGNO (SET_DEST (PATTERN (cand->insn)))\n+      != REGNO (get_extended_src_reg (SET_SRC (PATTERN (cand->insn)))))\n     {\n       /* In theory we could handle more than one reaching def, it\n \t just makes the code to update the insn stream more complex.  */\n       if (state->defs_list.length () != 1)\n \treturn false;\n \n-      /* We require the candidate not already be modified.  This may\n-\t be overly conservative.  */\n+      /* We require the candidate not already be modified.  It may,\n+\t for example have been changed from a (sign_extend (reg))\n+\t into (zero_extend (sign_extend (reg)).\n+\n+\t Handling that case shouldn't be terribly difficult, but the code\n+\t here and the code to emit copies would need auditing.  Until\n+\t we see a need, this is the safe thing to do.  */\n       if (state->modified[INSN_UID (cand->insn)].kind != EXT_MODIFIED_NONE)\n \treturn false;\n \n@@ -999,8 +1017,13 @@ find_and_remove_re (void)\n           if (dump_file)\n             fprintf (dump_file, \"Eliminated the extension.\\n\");\n           num_realized++;\n-\t  if (REGNO (SET_DEST (PATTERN (curr_cand->insn)))\n-\t      != REGNO (XEXP (SET_SRC (PATTERN (curr_cand->insn)), 0)))\n+\t  /* If the RHS of the current candidate is not (extend (reg)), then\n+\t     we do not allow the optimization of extensions where\n+\t     the source and destination registers do not match.  Thus\n+\t     checking REG_P here is correct.  */\n+\t  if (REG_P (XEXP (SET_SRC (PATTERN (curr_cand->insn)), 0))\n+\t      && (REGNO (SET_DEST (PATTERN (curr_cand->insn)))\n+\t\t  != REGNO (XEXP (SET_SRC (PATTERN (curr_cand->insn)), 0))))\n \t    {\n               reinsn_copy_list.safe_push (curr_cand->insn);\n               reinsn_copy_list.safe_push (state.defs_list[0]);"}, {"sha": "0415b74e08e74d4cd7254ee099cacabbe922a1b2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059742a47f66ce4511d867486827989ae7bd7391/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059742a47f66ce4511d867486827989ae7bd7391/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=059742a47f66ce4511d867486827989ae7bd7391", "patch": "@@ -1,3 +1,8 @@\n+2014-02-14  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/60131\n+\t* g++.dg/torture/pr60131.C: New test.\n+\n 2014-02-14  Ian Bolton  <ian.bolton@arm.com>\n \n \t* gcc.target/arm/pr59858.c: Skip if -mfloat-abi=hard specified"}, {"sha": "23dde316df0baf48d372ee2e3067752357786676", "filename": "gcc/testsuite/g++.dg/torture/pr60131.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059742a47f66ce4511d867486827989ae7bd7391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60131.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059742a47f66ce4511d867486827989ae7bd7391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60131.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr60131.C?ref=059742a47f66ce4511d867486827989ae7bd7391", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+struct A { short a; };\n+int **b;\n+unsigned long c;\n+\n+bool foo ();\n+unsigned bar (unsigned i);\n+extern void baz () __attribute__((noreturn));\n+\n+int *\n+test (unsigned x, struct A *y)\n+{\n+  unsigned v;\n+  if (foo () || y[x].a == -1)\n+    {\n+      c = bar (x);\n+      return 0;\n+    }\n+  v = y[x].a;\n+  if (v >= 23)\n+    baz ();\n+  return b[v];\n+}"}]}