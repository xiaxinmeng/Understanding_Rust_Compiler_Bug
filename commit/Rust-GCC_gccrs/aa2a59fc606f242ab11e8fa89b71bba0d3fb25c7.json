{"sha": "aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyYTU5ZmM2MDZmMjQyYWIxMWU4ZmE4OWI3MWJiYTBkM2ZiMjVjNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-10-01T15:22:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-10-01T15:22:39Z"}, "message": "tree-ssa-dom.c (optimize_stmt): Make this a method within the dom_opt_dom_walker class with direct access to...\n\n\t* tree-ssa-dom.c (optimize_stmt): Make this a method within the\n\tdom_opt_dom_walker class with direct access to private members.\n\tAdd comments.  Call test_for_singularity.\n\t(dom_opt_dom_walker::before_dom_children): Corresponding changes.\n\t(dom_opt_dom_walker::after_dom_children): Do not lazily initialize\n\tm_dummy_cond anymore.\n\t(class dom_opt_dom_walker): Initialize m_dummy_cond member in the\n\tclass ctor.\n\t(pass_dominator:execute): Build the dummy_cond here and pass it\n\tto the dom_opt_dom_walker ctor.\n\t(test_for_singularity): New function.\n\n\t* gcc.dg/tree-ssa/ssa-dom-simplify-1.c: New test.\n\n2017-09-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\nFrom-SVN: r253329", "tree": {"sha": "c9fe638a89ad387ab792b39d17043cc4f3eb5e25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9fe638a89ad387ab792b39d17043cc4f3eb5e25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/comments", "author": null, "committer": null, "parents": [{"sha": "efa1d7a21633c6e2e66245a11ba4347baf3d1767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa1d7a21633c6e2e66245a11ba4347baf3d1767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efa1d7a21633c6e2e66245a11ba4347baf3d1767"}], "stats": {"total": 189, "additions": 163, "deletions": 26}, "files": [{"sha": "93dcaedbb4add7f4a0376b2e01158472119bc4fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7", "patch": "@@ -1,3 +1,17 @@\n+2017-10-01  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (optimize_stmt): Make this a method within the\n+\tdom_opt_dom_walker class with direct access to private members.\n+\tAdd comments.  Call test_for_singularity.\n+\t(dom_opt_dom_walker::before_dom_children): Corresponding changes.\n+\t(dom_opt_dom_walker::after_dom_children): Do not lazily initialize\n+\tm_dummy_cond anymore.\n+\t(class dom_opt_dom_walker): Initialize m_dummy_cond member in the\n+\tclass ctor.\n+\t(pass_dominator:execute): Build the dummy_cond here and pass it\n+\tto the dom_opt_dom_walker ctor. \n+\t(test_for_singularity): New function.\n+\n 2017-09-30  Krister Walfridsson  <krister.walfridsson@gmail.com>\n \t    Maya Rashish  <coypu@sdf.org>\n "}, {"sha": "d12fbdd86a5d51ba52f38036f008535877f45f85", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7", "patch": "@@ -1,3 +1,7 @@\n+2017-10-01  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/ssa-dom-simplify-1.c: New test.\n+\n 2017-10-01  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR fortran/61450"}, {"sha": "23741b60f6593c5ba9e5e49ed827c1c4473f16f5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-simplify-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-simplify-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-simplify-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-simplify-1.c?ref=aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -w -fdump-tree-dom2\" } */\n+\n+extern void frob (void);\n+extern void frob (void);\n+\n+void\n+rhs_to_tree (int x, int z)\n+{\n+  if (x >= 4)\n+    frob ();\n+  if (x >= 3)\n+    frob ();\n+}\n+\n+/* The second conditional should change into a simple equality test.  */\n+/* { dg-final { scan-tree-dump-times \"if \\\\(x_\\[0-9\\]+\\\\(D\\\\) == 3\\\\)\" 1 \"dom2\"} } */\n+"}, {"sha": "06be69a530cadb6c466d6cc6057e55f42ee8c214", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 127, "deletions": 26, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=aa2a59fc606f242ab11e8fa89b71bba0d3fb25c7", "patch": "@@ -103,9 +103,6 @@ struct opt_stats_d\n static struct opt_stats_d opt_stats;\n \n /* Local functions.  */\n-static edge optimize_stmt (basic_block, gimple_stmt_iterator,\n-\t\t\t   class const_and_copies *,\n-\t\t\t   class avail_exprs_stack *);\n static void record_equality (tree, tree, class const_and_copies *);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block,\n@@ -572,11 +569,12 @@ class dom_opt_dom_walker : public dom_walker\n public:\n   dom_opt_dom_walker (cdi_direction direction,\n \t\t      class const_and_copies *const_and_copies,\n-\t\t      class avail_exprs_stack *avail_exprs_stack)\n+\t\t      class avail_exprs_stack *avail_exprs_stack,\n+\t\t      gcond *dummy_cond)\n     : dom_walker (direction, true),\n       m_const_and_copies (const_and_copies),\n       m_avail_exprs_stack (avail_exprs_stack),\n-      m_dummy_cond (NULL) {}\n+      m_dummy_cond (dummy_cond) { }\n \n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n@@ -587,7 +585,14 @@ class dom_opt_dom_walker : public dom_walker\n   class const_and_copies *m_const_and_copies;\n   class avail_exprs_stack *m_avail_exprs_stack;\n \n+  /* Dummy condition to avoid creating lots of throw away statements.  */\n   gcond *m_dummy_cond;\n+\n+  /* Optimize a single statement within a basic block using the\n+     various tables mantained by DOM.  Returns the taken edge if\n+     the statement is a conditional with a statically determined\n+     value.  */\n+  edge optimize_stmt (basic_block, gimple_stmt_iterator);\n };\n \n /* Jump threading, redundancy elimination and const/copy propagation.\n@@ -684,10 +689,12 @@ pass_dominator::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     record_edge_info (bb);\n \n+  gcond *dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,\n+\t\t\t\t\t integer_zero_node, NULL, NULL);\n+\n   /* Recursively walk the dominator tree optimizing statements.  */\n-  dom_opt_dom_walker walker (CDI_DOMINATORS,\n-\t\t\t     const_and_copies,\n-\t\t\t     avail_exprs_stack);\n+  dom_opt_dom_walker walker (CDI_DOMINATORS, const_and_copies,\n+\t\t\t     avail_exprs_stack, dummy_cond);\n   walker.walk (fun->cfg->x_entry_block_ptr);\n \n   /* Look for blocks where we cleared EDGE_EXECUTABLE on an outgoing\n@@ -1348,8 +1355,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \n   edge taken_edge = NULL;\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    taken_edge\n-      = optimize_stmt (bb, gsi, m_const_and_copies, m_avail_exprs_stack);\n+    taken_edge = this->optimize_stmt (bb, gsi);\n \n   /* Now prepare to process dominated blocks.  */\n   record_edge_info (bb);\n@@ -1367,10 +1373,6 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n void\n dom_opt_dom_walker::after_dom_children (basic_block bb)\n {\n-  if (! m_dummy_cond)\n-    m_dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,\n-\t\t\t\t      integer_zero_node, NULL, NULL);\n-\n   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n \t\t\t m_avail_exprs_stack,\n \t\t\t simplify_stmt_for_jump_threading);\n@@ -1700,8 +1702,99 @@ cprop_into_stmt (gimple *stmt)\n     }\n }\n \n-/* Optimize the statement in block BB pointed to by iterator SI\n-   using equivalences from CONST_AND_COPIES and AVAIL_EXPRS_STACK.\n+/* If STMT contains a relational test, try to convert it into an\n+   equality test if there is only a single value which can ever\n+   make the test true.\n+\n+   For example, if the expression hash table contains:\n+\n+    TRUE = (i <= 1)\n+\n+   And we have a test within statement of i >= 1, then we can safely\n+   rewrite the test as i == 1 since there only a single value where\n+   the test is true.\n+\n+   This is similar to code in VRP.  */\n+\n+static void\n+test_for_singularity (gimple *stmt, gcond *dummy_cond,\n+\t\t      avail_exprs_stack *avail_exprs_stack)\n+{\n+  /* We want to support gimple conditionals as well as assignments\n+     where the RHS contains a conditional.  */\n+  if (is_gimple_assign (stmt) || gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      enum tree_code code = ERROR_MARK;\n+      tree lhs, rhs;\n+\n+      /* Extract the condition of interest from both forms we support.  */\n+      if (is_gimple_assign (stmt))\n+\t{\n+\t  code = gimple_assign_rhs_code (stmt);\n+\t  lhs = gimple_assign_rhs1 (stmt);\n+\t  rhs = gimple_assign_rhs2 (stmt);\n+\t}\n+      else if (gimple_code (stmt) == GIMPLE_COND)\n+\t{\n+\t  code = gimple_cond_code (as_a <gcond *> (stmt));\n+\t  lhs = gimple_cond_lhs (as_a <gcond *> (stmt));\n+\t  rhs = gimple_cond_rhs (as_a <gcond *> (stmt));\n+\t}\n+\n+      /* We're looking for a relational test using LE/GE.  Also note we can\n+\t canonicalize LT/GT tests against constants into LE/GT tests.  */\n+      if (code == LE_EXPR || code == GE_EXPR\n+\t  || ((code == LT_EXPR || code == GT_EXPR)\n+\t       && TREE_CODE (rhs) == INTEGER_CST))\n+\t{\n+\t  /* For LT_EXPR and GT_EXPR, canonicalize to LE_EXPR and GE_EXPR.  */\n+\t  if (code == LT_EXPR)\n+\t    rhs = fold_build2 (MINUS_EXPR, TREE_TYPE (rhs),\n+\t\t\t       rhs, build_int_cst (TREE_TYPE (rhs), 1));\n+\n+\t  if (code == GT_EXPR)\n+\t    rhs = fold_build2 (PLUS_EXPR, TREE_TYPE (rhs),\n+\t\t\t       rhs, build_int_cst (TREE_TYPE (rhs), 1));\n+\n+\t  /* Determine the code we want to check for in the hash table.  */\n+\t  enum tree_code test_code;\n+\t  if (code == GE_EXPR || code == GT_EXPR)\n+\t    test_code = LE_EXPR;\n+\t  else\n+\t    test_code = GE_EXPR;\n+\n+\t  /* Update the dummy statement so we can query the hash tables.  */\n+\t  gimple_cond_set_code (dummy_cond, test_code);\n+\t  gimple_cond_set_lhs (dummy_cond, lhs);\n+\t  gimple_cond_set_rhs (dummy_cond, rhs);\n+\t  tree cached_lhs\n+\t    = avail_exprs_stack->lookup_avail_expr (dummy_cond, false, false);\n+\n+\t  /* If the lookup returned 1 (true), then the expression we\n+\t     queried was in the hash table.  As a result there is only\n+\t     one value that makes the original conditional true.  Update\n+\t     STMT accordingly.  */\n+\t  if (cached_lhs && integer_onep (cached_lhs))\n+\t    {\n+\t      if (is_gimple_assign (stmt))\n+\t\t{\n+\t\t  gimple_assign_set_rhs_code (stmt, EQ_EXPR);\n+\t\t  gimple_assign_set_rhs2 (stmt, rhs);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t  gimple_cond_set_code (as_a <gcond *> (stmt), EQ_EXPR);\n+\t\t  gimple_cond_set_rhs (as_a <gcond *> (stmt), rhs);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Optimize the statement in block BB pointed to by iterator SI.\n \n    We try to perform some simplistic global redundancy elimination and\n    constant propagation:\n@@ -1714,12 +1807,15 @@ cprop_into_stmt (gimple *stmt)\n    2- Constant values and copy assignments.  This is used to do very\n       simplistic constant and copy propagation.  When a constant or copy\n       assignment is found, we map the value on the RHS of the assignment to\n-      the variable in the LHS in the CONST_AND_COPIES table.  */\n+      the variable in the LHS in the CONST_AND_COPIES table.\n \n-static edge\n-optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n-\t       class const_and_copies *const_and_copies,\n-\t       class avail_exprs_stack *avail_exprs_stack)\n+   3- Very simple redundant store elimination is performed.\n+\n+   4- We can simpify a condition to a constant or from a relational\n+      condition to an equality condition.  */\n+\n+edge\n+dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n {\n   gimple *stmt, *old_stmt;\n   bool may_optimize_p;\n@@ -1832,8 +1928,8 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t}\n \n       update_stmt_if_modified (stmt);\n-      eliminate_redundant_computations (&si, const_and_copies,\n-\t\t\t\t\tavail_exprs_stack);\n+      eliminate_redundant_computations (&si, m_const_and_copies,\n+\t\t\t\t\tm_avail_exprs_stack);\n       stmt = gsi_stmt (si);\n \n       /* Perform simple redundant store elimination.  */\n@@ -1855,8 +1951,8 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t  else\n \t    new_stmt = gimple_build_assign (rhs, lhs);\n \t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-\t  cached_lhs = avail_exprs_stack->lookup_avail_expr (new_stmt, false,\n-\t\t\t\t\t\t\t     false);\n+\t  cached_lhs = m_avail_exprs_stack->lookup_avail_expr (new_stmt, false,\n+\t\t\t\t\t\t\t       false);\n \t  if (cached_lhs && operand_equal_p (rhs, cached_lhs, 0))\n \t    {\n \t      basic_block bb = gimple_bb (stmt);\n@@ -1871,11 +1967,16 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t      return retval;\n \t    }\n \t}\n+\n+      /* If this statement was not redundant, we may still be able to simplify\n+\t it, which may in turn allow other part of DOM or other passes to do\n+\t a better job.  */\n+      test_for_singularity (stmt, m_dummy_cond, m_avail_exprs_stack);\n     }\n \n   /* Record any additional equivalences created by this statement.  */\n   if (is_gimple_assign (stmt))\n-    record_equivalences_from_stmt (stmt, may_optimize_p, avail_exprs_stack);\n+    record_equivalences_from_stmt (stmt, may_optimize_p, m_avail_exprs_stack);\n \n   /* If STMT is a COND_EXPR or SWITCH_EXPR and it was modified, then we may\n      know where it goes.  */"}]}