{"sha": "becfd6e57bd90a45e5ab409db85f2e69e5945213", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVjZmQ2ZTU3YmQ5MGE0NWU1YWI0MDlkYjg1ZjJlNjllNTk0NTIxMw==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2008-05-07T20:48:07Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-05-07T20:48:07Z"}, "message": "[multiple changes]\n\n2008-05-07 Kenneth Zadeck <zadeck@naturalbridge.com>\n\n        PATCH rtl/7335\n        PATCH rtl/33826\n        * see.c (see_copy_insn): Copy new pure const attributes for new\n        call.\n        * c-decl.c (merge_decls): Ditto.\n        * postreload.c (record_opr_changes): Change CONST_OR_PURE_CALL_P\n        to RTL_CONST_OR_PURE_CALL_P.\n        * tree.c (define_local_buitin): Rename DECL_IS_PURE to\n        DECL_PURE_P.  Initialized DECL_LOOPING_CONST_PURE.\n        (process_call_operands): Set tree_side_effects properly.\n        * tree.h (TREE_READONLY_DECL_P): Removed.\n        (DECL_IS_PURE): Renamed to DECL_PURE_P.\n        (DECL_LOOPING_OR_CONST_P): New macro.\n        (struct tree_function_decl): Added looping_const_or_pure_p.\n        (ECF_*) Renumbered.\n        (ECF_LOOPING_OR_CONST_P): New macro,\n        * rtlanal.c (pure_const_p): Removed.\n        * builtins.c (expand_builtin): Rename DECL_IS_PURE to DECL_PURE_P.\n        * reorg.c (delete_prior_computation) Changed CONST_OR_PURE_CALL_P\n        to RTL_CONST_CALL_P.\n        * ipa-pure-const.c (pure_const_state_e): Added looping field.\n        (check_decl, check_tree, check_call, scan_function): Initialize\n        looping.\n        (analyze_function): Rename DECL_IS_PURE to DECL_PURE_P.\n        (static_execute): Set looping true for recursive functions.\n        Undo setting state to IPA_NEITHER for recursive functions.\n        * cse.c (cse_insn): \n        * ifcvt.c (noce_can_store_speculate_p): Changed\n        CONST_OR_PURE_CALL_P and pure_call_p to RTL_CONST_CALL_P or \n        RTL_CONST_OR_PURE_CALL_P.\n        * dse.c (scan_insn): Ditto.\n        * local-alloc.c (validate_equiv_mem, memref_used_between_p): Ditto.\n        * gcse.c (oprs_not_seen_p) Changed CONST_OR_PURE_CALL_P to\n        RTL_CONST_OR_PURE_CALL_P.\n        (store_killed_in_insn): Changed CONST_OR_PURE_CALL_P and\n        pure_call_p to RTL_CONST_CALL_P.\n        * gimplify.c (gimplify_call_expr): Clear side effects for\n        non-looping pure and constant calls.\n        * calls.c (emit_call_1): Set rtl flags from ecf flags.\n        (flags_from_decl_or_type): Set ecf flags from decl flags.\n        (initialize_argument_information): Turn off\n        ECF_LOOPING_CONST_OR_PURE when turning off ECF_CONST.\n        Change const to pure if callee_copies is true rather than just\n        turning off const.\n        (expand_call): Turn off ECF_LOOPING_PURE_CONST_CALL and remove old\n        way of marking pure calls.\n        (emit_library_call_value_1): Turn off ECF_LOOPING_PURE_CONST_CALL.\n        Remove hack that was supposed to fix pr7335 and remove old\n        way of marking pure calls.\n        * emit-rtl.c (emit_copy_of_insn_after): Copy RTL_CONST_CALL_P,\n        RTL_PURE_CALL_P, RTL_LOOPING_CONST_OR_PURE_CALL_P.\n        * cselib.c (cselib_process_insn): Changed CONST_OR_PURE_CALL_P to\n        RTL_CONST_OR_PURE_CALL_P.\n        * tree-ssa-pre.c (can_value_number_call): Fixed spacing.\n        * loop-invariant.c (find_exits, find_invariant_bb): Changed\n        CONST_OR_PURE_CALL_P to RTL_CONST_OR_PURE_CALL_P.\n        * sched-deps.c (schedule_analyze): Ditto.\n        * rtl.h (struct rtx_def): Use call field, unchanging field, and\n        return_val field of calls to represent pure and const function\n        info.\n        (CONST_OR_PURE_CALL_P): Deleted macro.\n        (RTL_CONST_CALL_P, RTL_PURE_CALL_P,\n        RTL_LOOPING_CONST_OR_PURE_CALL_P, RTL_CONST_OR_PURE_P): New macros.\n        * tree-inline.c (copy_body_r): Changed TREE_READONLY_DECL_P to\n        TREE_READONLY.\n        * tree-optimize.c (execute_fixup_cfg): Added test for\n        ECF_LOOPING_CONST_OR_PURE.\n        * c-common.c (handle_pure_attribute): Changed DECL_IS_PURE to\n        DECL_PURE_P.\n        * tree-cfg.c (update_call_expr_flags): Do not clear tree side\n        effects for looping pure or const calls.\n        (verify_gimple_expr): Added verification code. \n        * config/alpha/alpha.c (alpha_legitimize_address,\n        alpha_emit_xfloating_libcall): Changed CONST_OR_PURE_CALL_P to\n        RTL_CONST_CALL_P.\n        * config/s390/s390.c (s390_emit_tls_call_insn): Ditto.\n        * config/rs6000/rs6000.c (rs6000_legitimize_tls_address): Ditto.\n        * config/mips/mips.c (mips_call_tls_get_addr): Ditto.\n        * cfgrtl.c (need_fake_edge_p): Changed CONST_OR_PURE_CALL_P to\n        RTL_CONST_OR_PURE_CALL_P.\n        * dce.c (deletable_insn_p): Allow non looping, non sibling, pure\n        and const calls to be deleted.\n\njava:\n2008-05-07  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* decl.c (java_init_decl_processing): Change DECL_IS_PURE to\n\tDECL_PURE_P.\n\ncp:\n2008-05-07 Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t * decl.c (duplicate_decls): Merge in DECL_PURE_P, TREE_READONLY,\n\t DECL_LOOPING_CONST_OR_PURE_P attributes.\n\t * rtti.c (build_dynamic_cast_1): Rename DECL_IS_PURE to\n\t DECL_PURE_P.\n\ngfortran:\n2008-05-07 Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t * trans-decl.c (gfc_get_extern_function_decl, build_function_decl):\n\t Rename DECL_IS_PURE to DECL_PURE_P.\n\nFrom-SVN: r135053", "tree": {"sha": "b1aaf0884496e7223907dc2c04ecd0cf5ded732f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1aaf0884496e7223907dc2c04ecd0cf5ded732f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/becfd6e57bd90a45e5ab409db85f2e69e5945213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/becfd6e57bd90a45e5ab409db85f2e69e5945213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/becfd6e57bd90a45e5ab409db85f2e69e5945213", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/becfd6e57bd90a45e5ab409db85f2e69e5945213/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d320458418faac54c634134195b6afa432dbb50c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d320458418faac54c634134195b6afa432dbb50c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d320458418faac54c634134195b6afa432dbb50c"}], "stats": {"total": 516, "additions": 338, "deletions": 178}, "files": [{"sha": "1104f77b2561472ec92880b6574f1fe243327412", "filename": "gcc/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1,3 +1,89 @@\n+2008-05-07 Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+        PATCH rtl/7335\n+        PATCH rtl/33826\n+        * see.c (see_copy_insn): Copy new pure const attributes for new\n+        call.\n+        * c-decl.c (merge_decls): Ditto.\n+        * postreload.c (record_opr_changes): Change CONST_OR_PURE_CALL_P\n+        to RTL_CONST_OR_PURE_CALL_P.\n+        * tree.c (define_local_buitin): Rename DECL_IS_PURE to\n+        DECL_PURE_P.  Initialized DECL_LOOPING_CONST_PURE.\n+        (process_call_operands): Set tree_side_effects properly.\n+        * tree.h (TREE_READONLY_DECL_P): Removed.\n+        (DECL_IS_PURE): Renamed to DECL_PURE_P.\n+        (DECL_LOOPING_OR_CONST_P): New macro.\n+        (struct tree_function_decl): Added looping_const_or_pure_p.\n+        (ECF_*) Renumbered.\n+        (ECF_LOOPING_OR_CONST_P): New macro,\n+        * rtlanal.c (pure_const_p): Removed.\n+        * builtins.c (expand_builtin): Rename DECL_IS_PURE to DECL_PURE_P.\n+        * reorg.c (delete_prior_computation) Changed CONST_OR_PURE_CALL_P\n+        to RTL_CONST_CALL_P.\n+        * ipa-pure-const.c (pure_const_state_e): Added looping field.\n+        (check_decl, check_tree, check_call, scan_function): Initialize\n+        looping.\n+        (analyze_function): Rename DECL_IS_PURE to DECL_PURE_P.\n+        (static_execute): Set looping true for recursive functions.\n+        Undo setting state to IPA_NEITHER for recursive functions.\n+        * cse.c (cse_insn): \n+        * ifcvt.c (noce_can_store_speculate_p): Changed\n+        CONST_OR_PURE_CALL_P and pure_call_p to RTL_CONST_CALL_P or \n+        RTL_CONST_OR_PURE_CALL_P.\n+        * dse.c (scan_insn): Ditto.\n+        * local-alloc.c (validate_equiv_mem, memref_used_between_p): Ditto.\n+        * gcse.c (oprs_not_seen_p) Changed CONST_OR_PURE_CALL_P to\n+        RTL_CONST_OR_PURE_CALL_P.\n+        (store_killed_in_insn): Changed CONST_OR_PURE_CALL_P and\n+        pure_call_p to RTL_CONST_CALL_P.\n+        * gimplify.c (gimplify_call_expr): Clear side effects for\n+        non-looping pure and constant calls.\n+        * calls.c (emit_call_1): Set rtl flags from ecf flags.\n+        (flags_from_decl_or_type): Set ecf flags from decl flags.\n+        (initialize_argument_information): Turn off\n+        ECF_LOOPING_CONST_OR_PURE when turning off ECF_CONST.\n+        Change const to pure if callee_copies is true rather than just\n+        turning off const.\n+        (expand_call): Turn off ECF_LOOPING_PURE_CONST_CALL and remove old\n+        way of marking pure calls.\n+        (emit_library_call_value_1): Turn off ECF_LOOPING_PURE_CONST_CALL.\n+        Remove hack that was supposed to fix pr7335 and remove old\n+        way of marking pure calls.\n+        * emit-rtl.c (emit_copy_of_insn_after): Copy RTL_CONST_CALL_P,\n+        RTL_PURE_CALL_P, RTL_LOOPING_CONST_OR_PURE_CALL_P.\n+        * cselib.c (cselib_process_insn): Changed CONST_OR_PURE_CALL_P to\n+        RTL_CONST_OR_PURE_CALL_P.\n+        * tree-ssa-pre.c (can_value_number_call): Fixed spacing.\n+        * loop-invariant.c (find_exits, find_invariant_bb): Changed\n+        CONST_OR_PURE_CALL_P to RTL_CONST_OR_PURE_CALL_P.\n+        * sched-deps.c (schedule_analyze): Ditto.\n+        * rtl.h (struct rtx_def): Use call field, unchanging field, and\n+        return_val field of calls to represent pure and const function\n+        info.\n+        (CONST_OR_PURE_CALL_P): Deleted macro.\n+        (RTL_CONST_CALL_P, RTL_PURE_CALL_P,\n+        RTL_LOOPING_CONST_OR_PURE_CALL_P, RTL_CONST_OR_PURE_P): New macros.\n+        * tree-inline.c (copy_body_r): Changed TREE_READONLY_DECL_P to\n+        TREE_READONLY.\n+        * tree-optimize.c (execute_fixup_cfg): Added test for\n+        ECF_LOOPING_CONST_OR_PURE.\n+        * c-common.c (handle_pure_attribute): Changed DECL_IS_PURE to\n+        DECL_PURE_P.\n+        * tree-cfg.c (update_call_expr_flags): Do not clear tree side\n+        effects for looping pure or const calls.\n+        (verify_gimple_expr): Added verification code. \n+        * config/alpha/alpha.c (alpha_legitimize_address,\n+        alpha_emit_xfloating_libcall): Changed CONST_OR_PURE_CALL_P to\n+        RTL_CONST_CALL_P.\n+        * config/s390/s390.c (s390_emit_tls_call_insn): Ditto.\n+        * config/rs6000/rs6000.c (rs6000_legitimize_tls_address): Ditto.\n+        * config/mips/mips.c (mips_call_tls_get_addr): Ditto.\n+        * cfgrtl.c (need_fake_edge_p): Changed CONST_OR_PURE_CALL_P to\n+        RTL_CONST_OR_PURE_CALL_P.\n+        * dce.c (deletable_insn_p): Allow non looping, non sibling, pure\n+        and const calls to be deleted.\n+\n+\n 2008-05-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/35714"}, {"sha": "61b427220560e0f8ec8d3ad936a47714211ba135", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -6098,7 +6098,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n      none of its arguments are volatile, we can avoid expanding the\n      built-in call and just evaluate the arguments for side-effects.  */\n   if (target == const0_rtx\n-      && (DECL_IS_PURE (fndecl) || TREE_READONLY (fndecl)))\n+      && (DECL_PURE_P (fndecl) || TREE_READONLY (fndecl)))\n     {\n       bool volatilep = false;\n       tree arg;"}, {"sha": "0c27b3e6eba8f5940b23a8bda79780ef562532ab", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -6019,7 +6019,7 @@ handle_pure_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n-    DECL_IS_PURE (*node) = 1;\n+    DECL_PURE_P (*node) = 1;\n   /* ??? TODO: Support types.  */\n   else\n     {"}, {"sha": "9abb4dfc65f2de9973372ea8b1d3c62d2b64e25b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1729,10 +1729,10 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n \t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n \t  TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n-\t  TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n \t  DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n \t  DECL_IS_OPERATOR_NEW (newdecl) |= DECL_IS_OPERATOR_NEW (olddecl);\n-\t  DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n+\t  TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n+\t  DECL_PURE_P (newdecl) |= DECL_PURE_P (olddecl);\n \t  DECL_IS_NOVOPS (newdecl) |= DECL_IS_NOVOPS (olddecl);\n \t}\n "}, {"sha": "429ccb4ed239932f62bebc873d2f759d69b522dc", "filename": "gcc/calls.c", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -359,21 +359,20 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n   /* Find the call we just emitted.  */\n   call_insn = last_call_insn ();\n \n-  /* Mark memory as used for \"pure\" function call.  */\n-  if (ecf_flags & ECF_PURE)\n-    call_fusage\n-      = gen_rtx_EXPR_LIST\n-\t(VOIDmode,\n-\t gen_rtx_USE (VOIDmode,\n-\t\t      gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode))),\n-\t call_fusage);\n-\n   /* Put the register usage information there.  */\n   add_function_usage_to (call_insn, call_fusage);\n \n   /* If this is a const call, then set the insn's unchanging bit.  */\n-  if (ecf_flags & (ECF_CONST | ECF_PURE))\n-    CONST_OR_PURE_CALL_P (call_insn) = 1;\n+  if (ecf_flags & ECF_CONST)\n+    RTL_CONST_CALL_P (call_insn) = 1;\n+\n+  /* If this is a pure call, then set the insn's unchanging bit.  */\n+  if (ecf_flags & ECF_PURE)\n+    RTL_PURE_CALL_P (call_insn) = 1;\n+\n+  /* If this is a const call, then set the insn's unchanging bit.  */\n+  if (ecf_flags & ECF_LOOPING_CONST_OR_PURE)\n+    RTL_LOOPING_CONST_OR_PURE_CALL_P (call_insn) = 1;\n \n   /* If this call can't throw, attach a REG_EH_REGION reg note to that\n      effect.  */\n@@ -580,19 +579,20 @@ flags_from_decl_or_type (const_tree exp)\n       if (DECL_IS_RETURNS_TWICE (exp))\n \tflags |= ECF_RETURNS_TWICE;\n \n-      /* The function exp may have the `pure' attribute.  */\n-      if (DECL_IS_PURE (exp))\n+      /* Process the pure and const attributes.  */\n+      if (TREE_READONLY (exp) && ! TREE_THIS_VOLATILE (exp))\n+\tflags |= ECF_CONST;\n+      if (DECL_PURE_P (exp))\n \tflags |= ECF_PURE;\n+      if (DECL_LOOPING_CONST_OR_PURE_P (exp))\n+\tflags |= ECF_LOOPING_CONST_OR_PURE;\n \n       if (DECL_IS_NOVOPS (exp))\n \tflags |= ECF_NOVOPS;\n \n       if (TREE_NOTHROW (exp))\n \tflags |= ECF_NOTHROW;\n \n-      if (TREE_READONLY (exp) && ! TREE_THIS_VOLATILE (exp))\n-\tflags |= ECF_CONST;\n-\n       flags = special_function_p (exp, flags);\n     }\n   else if (TYPE_P (exp) && TYPE_READONLY (exp) && ! TREE_THIS_VOLATILE (exp))\n@@ -1038,7 +1038,9 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t      args[i].tree_value = build_fold_addr_expr (args[i].tree_value);\n \t      type = TREE_TYPE (args[i].tree_value);\n \n-\t      *ecf_flags &= ~(ECF_CONST | ECF_LIBCALL_BLOCK);\n+\t      if (*ecf_flags & ECF_CONST)\n+\t\t*ecf_flags &= ~(ECF_CONST | ECF_LOOPING_CONST_OR_PURE);\n+\t      *ecf_flags &= ~ECF_LIBCALL_BLOCK;\n \t    }\n \t  else\n \t    {\n@@ -1073,10 +1075,19 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n \t      store_expr (args[i].tree_value, copy, 0, false);\n \n-\t      if (callee_copies)\n-\t\t*ecf_flags &= ~(ECF_CONST | ECF_LIBCALL_BLOCK);\n-\t      else\n-\t\t*ecf_flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n+\t      *ecf_flags &= ~(ECF_LIBCALL_BLOCK);\n+\n+\t      /* Just change the const function to pure and then let\n+\t\t the next test clear the pure based on\n+\t\t callee_copies.  */\n+\t      if (*ecf_flags & ECF_CONST)\n+\t\t{\n+\t\t  *ecf_flags &= ~ECF_CONST;\n+\t\t  *ecf_flags |= ECF_PURE;\n+\t\t}\n+\n+\t      if (!callee_copies && *ecf_flags & ECF_PURE)\n+\t\t*ecf_flags &= ~(ECF_PURE | ECF_LOOPING_CONST_OR_PURE);\n \n \t      args[i].tree_value\n \t\t= build_fold_addr_expr (make_tree (type, copy));\n@@ -2022,10 +2033,12 @@ expand_call (tree exp, rtx target, int ignore)\n   if (AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n     warning (OPT_Waggregate_return, \"function call has aggregate value\");\n \n-  /* If the result of a pure or const function call is ignored (or void),\n-     and none of its arguments are volatile, we can avoid expanding the\n-     call and just evaluate the arguments for side-effects.  */\n+  /* If the result of a non looping pure or const function call is\n+     ignored (or void), and none of its arguments are volatile, we can\n+     avoid expanding the call and just evaluate the arguments for\n+     side-effects.  */\n   if ((flags & (ECF_CONST | ECF_PURE))\n+      && (!(flags & ECF_LOOPING_CONST_OR_PURE))\n       && (ignore || target == const0_rtx\n \t  || TYPE_MODE (TREE_TYPE (exp)) == VOIDmode))\n     {\n@@ -2061,7 +2074,8 @@ expand_call (tree exp, rtx target, int ignore)\n   if (aggregate_value_p (exp, fndecl))\n     {\n       /* This call returns a big structure.  */\n-      flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n+      flags &= ~(ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE \n+\t\t | ECF_LIBCALL_BLOCK);\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n       {\n@@ -2852,13 +2866,6 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t    note = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t      args[i].initial_value, note);\n \t\t  note = gen_rtx_EXPR_LIST (VOIDmode, funexp, note);\n-\n-\t\t  if (flags & ECF_PURE)\n-\t\t    note = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\tgen_rtx_USE (VOIDmode,\n-\t\t\t\t     gen_rtx_MEM (BLKmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (VOIDmode))),\n-\t\t\tnote);\n \t\t}\n \t      emit_libcall_block (insns, temp, valreg, note);\n \n@@ -3369,7 +3376,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t    mem_value = assign_temp (tfom, 0, 1, 1);\n #endif\n \t  /* This call returns a big structure.  */\n-\t  flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n+\t  flags &= ~(ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE \n+\t\t     | ECF_LIBCALL_BLOCK);\n \t}\n     }\n   else\n@@ -3472,10 +3480,9 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t      end_sequence ();\n \t      emit_insn (insns);\n \t    }\n-\t  flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n \n-\t  /* If this was a CONST function, it is now PURE since\n-\t     it now reads memory.  */\n+\t  /* If this was a CONST function, it is now PURE since it now\n+\t     reads memory.  */\n \t  if (flags & ECF_CONST)\n \t    {\n \t      flags &= ~ECF_CONST;\n@@ -3901,14 +3908,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n \t  insns = get_insns ();\n \t  end_sequence ();\n-\n-\t  if (flags & ECF_PURE)\n-\t    note = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\tgen_rtx_USE (VOIDmode,\n-\t\t\t\t     gen_rtx_MEM (BLKmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (VOIDmode))),\n-\t\t\tnote);\n-\n \t  emit_libcall_block (insns, temp, valreg, note);\n \n \t  valreg = temp;"}, {"sha": "994fb16fc47fba48577bd7bfc58e584b9d2b5e77", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -2745,7 +2745,7 @@ need_fake_edge_p (const_rtx insn)\n   if ((CALL_P (insn)\n        && !SIBLING_CALL_P (insn)\n        && !find_reg_note (insn, REG_NORETURN, NULL)\n-       && !CONST_OR_PURE_CALL_P (insn)))\n+       && !(RTL_CONST_OR_PURE_CALL_P (insn))))\n     return true;\n \n   return ((GET_CODE (PATTERN (insn)) == ASM_OPERANDS"}, {"sha": "21b0590d66aaf48b938923fa62c36b38a297d5b9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -986,7 +986,7 @@ alpha_legitimize_address (rtx x, rtx scratch,\n \t  emit_insn (gen_movdi_er_tlsgd (r16, pic_offset_table_rtx, x, seq));\n \t  insn = gen_call_value_osf_tlsgd (r0, tga, seq);\n \t  insn = emit_call_insn (insn);\n-\t  CONST_OR_PURE_CALL_P (insn) = 1;\n+\t  RTL_CONST_CALL_P (insn) = 1;\n \t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r16);\n \n           insn = get_insns ();\n@@ -1007,7 +1007,7 @@ alpha_legitimize_address (rtx x, rtx scratch,\n \t  emit_insn (gen_movdi_er_tlsldm (r16, pic_offset_table_rtx, seq));\n \t  insn = gen_call_value_osf_tlsldm (r0, tga, seq);\n \t  insn = emit_call_insn (insn);\n-\t  CONST_OR_PURE_CALL_P (insn) = 1;\n+\t  RTL_CONST_CALL_P (insn) = 1;\n \t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r16);\n \n           insn = get_insns ();\n@@ -3013,7 +3013,7 @@ alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n   tmp = emit_call_insn (GEN_CALL_VALUE (reg, tmp, const0_rtx,\n \t\t\t\t\tconst0_rtx, const0_rtx));\n   CALL_INSN_FUNCTION_USAGE (tmp) = usage;\n-  CONST_OR_PURE_CALL_P (tmp) = 1;\n+  RTL_CONST_CALL_P (tmp) = 1;\n \n   tmp = get_insns ();\n   end_sequence ();"}, {"sha": "7d254fec8cb873d5bc2000472ea2013333575c62", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -7859,7 +7859,7 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n \t  insns = get_insns ();\n \t  end_sequence ();\n \n-\t  CONST_OR_PURE_CALL_P (insns) = 1;\n+\t  RTL_CONST_CALL_P (insns) = 1;\n \t  emit_libcall_block (insns, dest, rax, x);\n \t}\n       else if (TARGET_64BIT && TARGET_GNU2_TLS)\n@@ -7890,7 +7890,7 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n \n \t  note = gen_rtx_EXPR_LIST (VOIDmode, const0_rtx, NULL);\n \t  note = gen_rtx_EXPR_LIST (VOIDmode, ix86_tls_get_addr (), note);\n-\t  CONST_OR_PURE_CALL_P (insns) = 1;\n+\t  RTL_CONST_CALL_P (insns) = 1;\n \t  emit_libcall_block (insns, base, rax, note);\n \t}\n       else if (TARGET_64BIT && TARGET_GNU2_TLS)"}, {"sha": "de2e42a33c70effe513c95ffa3f6a19e10bd563a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -2371,7 +2371,7 @@ mips_call_tls_get_addr (rtx sym, enum mips_symbol_type type, rtx v0)\n   emit_insn (gen_rtx_SET (Pmode, a0,\n \t\t\t  gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, loc)));\n   insn = mips_expand_call (v0, mips_tls_symbol, const0_rtx, const0_rtx, false);\n-  CONST_OR_PURE_CALL_P (insn) = 1;\n+  RTL_CONST_CALL_P (insn) = 1;\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), a0);\n   insn = get_insns ();\n "}, {"sha": "2e0031a67c1fa4ec821e7602a09def1fc1bdbdb0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -3902,7 +3902,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t  tga = gen_rtx_MEM (Pmode, rs6000_tls_get_addr ());\n \t  insn = gen_call_value (r3, tga, const0_rtx, const0_rtx);\n \t  insn = emit_call_insn (insn);\n-\t  CONST_OR_PURE_CALL_P (insn) = 1;\n+\t  RTL_CONST_CALL_P (insn) = 1;\n \t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r3);\n \t  insn = get_insns ();\n \t  end_sequence ();\n@@ -3920,7 +3920,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t  tga = gen_rtx_MEM (Pmode, rs6000_tls_get_addr ());\n \t  insn = gen_call_value (r3, tga, const0_rtx, const0_rtx);\n \t  insn = emit_call_insn (insn);\n-\t  CONST_OR_PURE_CALL_P (insn) = 1;\n+\t  RTL_CONST_CALL_P (insn) = 1;\n \t  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r3);\n \t  insn = get_insns ();\n \t  end_sequence ();"}, {"sha": "95fee4d63c4005aa51a2a77b245178b0e22f73b8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -3178,7 +3178,7 @@ s390_emit_tls_call_insn (rtx result_reg, rtx tls_call)\n \t\t\t gen_rtx_REG (Pmode, RETURN_REGNUM));\n \n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), result_reg);\n-  CONST_OR_PURE_CALL_P (insn) = 1;\n+  RTL_CONST_CALL_P (insn) = 1;\n }\n \n /* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute"}, {"sha": "473db1456502f9f44519a36f113d58a81f4fde74", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1,3 +1,11 @@\n+2008-05-07 Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t * decl.c (duplicate_decls): Merge in DECL_PURE_P, TREE_READONLY,\n+\t DECL_LOOPING_CONST_OR_PURE_P attributes.\n+\t * rtti.c (build_dynamic_cast_1): Rename DECL_IS_PURE to\n+\t DECL_PURE_P.\n+\n+\n 2008-05-02  Simon Baldwin <simonb@google.com>\n \n \tPR bootstrap/36108"}, {"sha": "8b9b2114417db068aa066bb67eaddda642b34af1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1802,11 +1802,13 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n \t  DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n \t  TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n-\t  TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n \t  TREE_NOTHROW (newdecl) |= TREE_NOTHROW (olddecl);\n \t  DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n \t  DECL_IS_OPERATOR_NEW (newdecl) |= DECL_IS_OPERATOR_NEW (olddecl);\n-\t  DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n+\t  DECL_PURE_P (newdecl) |= DECL_PURE_P (olddecl);\n+\t  TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n+\t  DECL_LOOPING_CONST_OR_PURE_P (newdecl) \n+\t    |= DECL_LOOPING_CONST_OR_PURE_P (olddecl);\n \t  /* Keep the old RTL.  */\n \t  COPY_DECL_RTL (olddecl, newdecl);\n \t}"}, {"sha": "1dcd785371a7c19190af61cabd9b43e951d647ef", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -707,7 +707,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t\t   (NULL_TREE, ptrdiff_type_node, void_list_node))));\n \t      tmp = build_function_type (ptr_type_node, tmp);\n \t      dcast_fn = build_library_fn_ptr (name, tmp);\n-\t      DECL_IS_PURE (dcast_fn) = 1;\n+\t      DECL_PURE_P (dcast_fn) = 1;\n \t      pop_abi_namespace ();\n \t      dynamic_cast_node = dcast_fn;\n \t    }"}, {"sha": "23b61349455754c66b136f93422cf125c5a5bc71", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -5249,7 +5249,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n   if (CALL_P (insn))\n     {\n-      if (! CONST_OR_PURE_CALL_P (insn))\n+      if (!(RTL_CONST_OR_PURE_CALL_P (insn)))\n \tinvalidate_memory ();\n       invalidate_for_call ();\n     }"}, {"sha": "5d490941df881ba38db414c674e5391785875e94", "filename": "gcc/cselib.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1693,7 +1693,11 @@ cselib_process_insn (rtx insn)\n \t\t      GET_MODE (REG_VALUES (i)->elt->val_rtx))))\n \t  cselib_invalidate_regno (i, reg_raw_mode[i]);\n \n-      if (! CONST_OR_PURE_CALL_P (insn))\n+      /* Since it is not clear how cselib is going to be used, be\n+\t conservative here and treat looping pure or const functions\n+\t as if they were regular functions.  */\n+      if (RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)\n+\t  || !(RTL_CONST_OR_PURE_CALL_P (insn)))\n \tcselib_invalidate_mem (callmem);\n     }\n "}, {"sha": "403d09937e21ca6ecb0af997c05c3aace9f06c63", "filename": "gcc/dce.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -99,6 +99,15 @@ deletable_insn_p (rtx insn, bool fast)\n   rtx body, x;\n   int i;\n \n+  /* We can delete dead const or pure calls as long as they do not\n+     infinite loop and are not sibling calls.  The problem with\n+     sibling calls is that it is hard to see the result.  */\n+  if (CALL_P (insn) \n+      && (!SIBLING_CALL_P (insn))\n+      && (RTL_CONST_OR_PURE_CALL_P (insn)\n+\t  && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)))\n+    return true;\n+\n   if (!NONJUMP_INSN_P (insn))\n     return false;\n "}, {"sha": "c228938490512c9788298a1bd719397c90f7cd8f", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1967,7 +1967,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n       /* Const functions cannot do anything bad i.e. read memory,\n \t however, they can read their parameters which may have\n \t been pushed onto the stack.  */\n-      if (CONST_OR_PURE_CALL_P (insn) && !pure_call_p (insn))\n+      if (RTL_CONST_CALL_P (insn))\n \t{\n \t  insn_info_t i_ptr = active_local_stores;\n \t  insn_info_t last = NULL;"}, {"sha": "aec01517b6d7596a50ba6c1a051e9245935c7ffe", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -5464,7 +5464,10 @@ emit_copy_of_insn_after (rtx insn, rtx after)\n \tCALL_INSN_FUNCTION_USAGE (new)\n \t  = copy_insn (CALL_INSN_FUNCTION_USAGE (insn));\n       SIBLING_CALL_P (new) = SIBLING_CALL_P (insn);\n-      CONST_OR_PURE_CALL_P (new) = CONST_OR_PURE_CALL_P (insn);\n+      RTL_CONST_CALL_P (new) = RTL_CONST_CALL_P (insn);\n+      RTL_PURE_CALL_P (new) = RTL_PURE_CALL_P (insn);\n+      RTL_LOOPING_CONST_OR_PURE_CALL_P (new) \n+\t= RTL_LOOPING_CONST_OR_PURE_CALL_P (insn);\n       break;\n \n     default:"}, {"sha": "4906bbe414e959dddef033830ee054ffc37c95ab", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1,3 +1,8 @@\n+2008-05-07 Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t * trans-decl.c (gfc_get_extern_function_decl, build_function_decl):\n+\t Rename DECL_IS_PURE to DECL_PURE_P.\n+\n 2008-05-06  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* arith.c: (gfc_arith_concat, gfc_compare_string,"}, {"sha": "6e0b5425a913c66a34a689eac3dac235c10f49ff", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1197,7 +1197,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n   if (sym->attr.pure || sym->attr.elemental)\n     {\n       if (sym->attr.function && !gfc_return_by_reference (sym))\n-\tDECL_IS_PURE (fndecl) = 1;\n+\tDECL_PURE_P (fndecl) = 1;\n       /* TODO: check if pure SUBROUTINEs don't have INTENT(OUT)\n \t parameters and don't use alternate returns (is this\n \t allowed?). In that case, calls to them are meaningless, and\n@@ -1324,7 +1324,7 @@ build_function_decl (gfc_symbol * sym)\n \t including an alternate return. In that case it can also be\n \t marked as PURE. See also in gfc_get_extern_function_decl().  */\n       if (attr.function && !gfc_return_by_reference (sym))\n-\tDECL_IS_PURE (fndecl) = 1;\n+\tDECL_PURE_P (fndecl) = 1;\n       TREE_SIDE_EFFECTS (fndecl) = 0;\n     }\n "}, {"sha": "e881e86764eef708849af881408a885b6e2a6917", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -2309,7 +2309,7 @@ oprs_not_set_p (const_rtx x, const_rtx insn)\n static void\n mark_call (rtx insn)\n {\n-  if (! CONST_OR_PURE_CALL_P (insn))\n+  if (! RTL_CONST_OR_PURE_CALL_P (insn))\n     record_last_mem_set_info (insn);\n }\n \n@@ -5987,7 +5987,7 @@ store_killed_in_insn (const_rtx x, const_rtx x_regs, const_rtx insn, int after)\n     {\n       /* A normal or pure call might read from pattern,\n \t but a const call will not.  */\n-      if (! CONST_OR_PURE_CALL_P (insn) || pure_call_p (insn))\n+      if (RTL_CONST_CALL_P (insn))\n \treturn true;\n \n       /* But even a const call reads its parameters.  Check whether the"}, {"sha": "fc90fa35a2091359a97d45241ed69231139b115e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -2274,10 +2274,14 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   /* If the function is \"const\" or \"pure\", then clear TREE_SIDE_EFFECTS on its\n      decl.  This allows us to eliminate redundant or useless\n      calls to \"const\" functions.  */\n-  if (TREE_CODE (*expr_p) == CALL_EXPR\n-      && (call_expr_flags (*expr_p) & (ECF_CONST | ECF_PURE)))\n-    TREE_SIDE_EFFECTS (*expr_p) = 0;\n-\n+  if (TREE_CODE (*expr_p) == CALL_EXPR)\n+    {\n+      int flags = call_expr_flags (*expr_p);\n+      if (flags & (ECF_CONST | ECF_PURE)\n+\t  /* An infinite loop is considered a side effect.  */\n+\t  && !(flags & (ECF_LOOPING_CONST_OR_PURE)))\n+\tTREE_SIDE_EFFECTS (*expr_p) = 0;\n+    }\n   return ret;\n }\n "}, {"sha": "26ff9680baf0367e11c312df12588103739601ee", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -2168,9 +2168,7 @@ noce_can_store_speculate_p (basic_block top_bb, const_rtx mem)\n \t     unconditionally before the barrier.  */\n \t  if (INSN_P (insn)\n \t      && (volatile_insn_p (PATTERN (insn))\n-\t\t  || (CALL_P (insn)\n-\t\t      && (!CONST_OR_PURE_CALL_P (insn)\n-\t\t\t  || pure_call_p (insn)))))\n+\t\t  || (CALL_P (insn) && (!RTL_CONST_CALL_P (insn)))))\n \t    return false;\n \n \t  if (memory_modified_in_insn_p (mem, insn))"}, {"sha": "a2c920601ac76a97640193c341a1979526f80ab0", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -19,7 +19,8 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* This file mark functions as being either const (TREE_READONLY) or\n-   pure (DECL_IS_PURE).\n+   pure (DECL_PURE_P).  It can also set the a variant of these that\n+   are allowed to infinite loop (DECL_LOOPING_CONST_PURE_P).\n \n    This must be run after inlining decisions have been made since\n    otherwise, the local sets will not contain information that is\n@@ -69,6 +70,7 @@ enum pure_const_state_e\n struct funct_state_d \n {\n   enum pure_const_state_e pure_const_state;\n+  bool looping;\n   bool state_set_in_source;\n };\n \n@@ -95,6 +97,7 @@ check_decl (funct_state local,\n   if (lookup_attribute (\"used\", DECL_ATTRIBUTES (t)))\n     {\n       local->pure_const_state = IPA_NEITHER;\n+      local->looping = false;\n       return;\n     }\n \n@@ -103,6 +106,7 @@ check_decl (funct_state local,\n   if (TREE_THIS_VOLATILE (t)) \n     { \n       local->pure_const_state = IPA_NEITHER;\n+      local->looping = false;\n       return;\n     }\n \n@@ -116,6 +120,7 @@ check_decl (funct_state local,\n   if (checking_write) \n     {\n       local->pure_const_state = IPA_NEITHER;\n+      local->looping = false;\n       return;\n     }\n \n@@ -174,6 +179,7 @@ check_tree (funct_state local, tree t, bool checking_write)\n   if (TREE_THIS_VOLATILE (t))\n     {\n       local->pure_const_state = IPA_NEITHER;\n+      local->looping = false;\n       return;\n     }\n \n@@ -199,6 +205,7 @@ check_tree (funct_state local, tree t, bool checking_write)\n       if (checking_write) \n \t{\n \t  local->pure_const_state = IPA_NEITHER;\n+\t  local->looping = false;\n \t  return;\n \t}\n       else if (local->pure_const_state == IPA_CONST)\n@@ -346,14 +353,18 @@ check_call (funct_state local, tree call_expr)\n       /* When bad things happen to bad functions, they cannot be const\n \t or pure.  */\n       if (setjmp_call_p (callee_t))\n-\tlocal->pure_const_state = IPA_NEITHER;\n+\t{\n+\t  local->pure_const_state = IPA_NEITHER;\n+\t  local->looping = false;\n+\t}\n \n       if (DECL_BUILT_IN_CLASS (callee_t) == BUILT_IN_NORMAL)\n \tswitch (DECL_FUNCTION_CODE (callee_t))\n \t  {\n \t  case BUILT_IN_LONGJMP:\n \t  case BUILT_IN_NONLOCAL_GOTO:\n \t    local->pure_const_state = IPA_NEITHER;\n+\t    local->looping = false;\n \t    break;\n \t  default:\n \t    break;\n@@ -480,7 +491,10 @@ scan_function (tree *tp,\n     case LABEL_EXPR:\n       if (DECL_NONLOCAL (TREE_OPERAND (t, 0)))\n \t/* Target of long jump. */\n-\tlocal->pure_const_state = IPA_NEITHER;\n+\t{\n+\t  local->pure_const_state = IPA_NEITHER;\n+\t  local->looping = false;\n+\t}\n       break;\n \n     case CALL_EXPR: \n@@ -513,6 +527,10 @@ analyze_function (struct cgraph_node *fn)\n \n   l->pure_const_state = IPA_CONST;\n   l->state_set_in_source = false;\n+  if (DECL_LOOPING_CONST_OR_PURE_P (decl))\n+    l->looping = true;\n+  else\n+    l->looping = false;\n \n   /* If this function does not return normally or does not bind local,\n      do not touch this unless it has been marked as const or pure by the\n@@ -529,7 +547,7 @@ analyze_function (struct cgraph_node *fn)\n       l->pure_const_state = IPA_CONST;\n       l->state_set_in_source = true;\n     }\n-  if (DECL_IS_PURE (decl))\n+  if (DECL_PURE_P (decl))\n     {\n       l->pure_const_state = IPA_PURE;\n       l->state_set_in_source = true;\n@@ -644,6 +662,7 @@ static_execute (void)\n   for (i = 0; i < order_pos; i++ )\n     {\n       enum pure_const_state_e pure_const_state = IPA_CONST;\n+      bool looping = false;\n       int count = 0;\n       node = order[i];\n \n@@ -655,6 +674,9 @@ static_execute (void)\n \t  if (pure_const_state < w_l->pure_const_state)\n \t    pure_const_state = w_l->pure_const_state;\n \n+\t  if (w_l->looping)\n+\t    looping = true;\n+\n \t  if (pure_const_state == IPA_NEITHER) \n \t    break;\n \n@@ -663,45 +685,26 @@ static_execute (void)\n \t      struct cgraph_edge *e;\n \t      count++;\n \n-\t      /* FIXME!!!  Because of pr33826, we cannot have either\n-\t\t immediate or transitive recursive functions marked as\n-\t\t pure or const because dce can delete a function that\n-\t\t is in reality an infinite loop.  A better solution\n-\t\t than just outlawing them is to add another bit the\n-\t\t functions to distinguish recursive from non recursive\n-\t\t pure and const function.  This would allow the\n-\t\t recursive ones to be cse'd but not dce'd.  In this\n-\t\t same vein, we could allow functions with loops to\n-\t\t also be cse'd but not dce'd.\n-\n-\t\t Unfortunately we are late in stage 3, and the fix\n-\t\t described above is is not appropriate.  */\n \t      if (count > 1)\n-\t\t{\n-\t\t  pure_const_state = IPA_NEITHER;\n-\t\t  break;\n-\t\t}\n+\t\tlooping = true;\n \t\t    \n \t      for (e = w->callees; e; e = e->next_callee) \n \t\t{\n \t\t  struct cgraph_node *y = e->callee;\n \t\t  /* Only look at the master nodes and skip external nodes.  */\n \t\t  y = cgraph_master_clone (y);\n \n-\t\t  /* Check for immediate recursive functions.  See the\n-\t\t     FIXME above.  */\n \t\t  if (w == y)\n-\t\t    {\n-\t\t      pure_const_state = IPA_NEITHER;\n-\t\t      break;\n-\t\t    }\n+\t\t    looping = true;\n \t\t  if (y)\n \t\t    {\n \t\t      funct_state y_l = get_function_state (y);\n \t\t      if (pure_const_state < y_l->pure_const_state)\n \t\t\tpure_const_state = y_l->pure_const_state;\n \t\t      if (pure_const_state == IPA_NEITHER) \n \t\t\tbreak;\n+\t\t      if (y_l->looping)\n+\t\t\tlooping = true;\n \t\t    }\n \t\t}\n \t    }\n@@ -724,15 +727,19 @@ static_execute (void)\n \t\t{\n \t\tcase IPA_CONST:\n \t\t  TREE_READONLY (w->decl) = 1;\n+\t\t  DECL_LOOPING_CONST_OR_PURE_P (w->decl) = looping;\n \t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Function found to be const: %s\\n\",  \n+\t\t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",  \n+\t\t\t     looping ? \"looping \" : \"\",\n \t\t\t     lang_hooks.decl_printable_name(w->decl, 2)); \n \t\t  break;\n \t\t  \n \t\tcase IPA_PURE:\n-\t\t  DECL_IS_PURE (w->decl) = 1;\n+\t\t  DECL_PURE_P (w->decl) = 1;\n+\t\t  DECL_LOOPING_CONST_OR_PURE_P (w->decl) = looping;\n \t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Function found to be pure: %s\\n\",  \n+\t\t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",  \n+\t\t\t     looping ? \"looping \" : \"\",\n \t\t\t     lang_hooks.decl_printable_name(w->decl, 2)); \n \t\t  break;\n \t\t  "}, {"sha": "411806af5a854c5bc1f769f366a546f1f33568f2", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1,3 +1,8 @@\n+2008-05-07  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* decl.c (java_init_decl_processing): Change DECL_IS_PURE to\n+\tDECL_PURE_P.\n+\n 2008-04-23  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* class.c (build_utf8_ref): Don't set TREE_INVARIANT."}, {"sha": "fcc1c126e1119aca4a7fefdf874408cdbc3bafef", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -906,7 +906,7 @@ java_init_decl_processing (void)\n     = add_builtin_function (\"_Jv_ResolvePoolEntry\",\n \t\t\t    build_function_type (ptr_type_node, t),\n \t\t\t    0,NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_IS_PURE (soft_resolvepoolentry_node) = 1;\n+  DECL_PURE_P (soft_resolvepoolentry_node) = 1;\n   throw_node = add_builtin_function (\"_Jv_Throw\",\n \t\t\t\t     build_function_type (void_type_node, t),\n \t\t\t\t     0, NOT_BUILT_IN, NULL, NULL_TREE);\n@@ -1000,7 +1000,7 @@ java_init_decl_processing (void)\n     = add_builtin_function (\"_Jv_IsInstanceOf\",\n \t\t\t    build_function_type (boolean_type_node, t),\n \t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_IS_PURE (soft_instanceof_node) = 1;\n+  DECL_PURE_P (soft_instanceof_node) = 1;\n   t = tree_cons (NULL_TREE, object_ptr_type_node,\n \t\t tree_cons (NULL_TREE, object_ptr_type_node, endlink));\n   soft_checkarraystore_node\n@@ -1014,7 +1014,7 @@ java_init_decl_processing (void)\n     = add_builtin_function (\"_Jv_LookupInterfaceMethodIdx\",\n \t\t\t    build_function_type (ptr_type_node, t),\n \t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_IS_PURE (soft_lookupinterfacemethod_node) = 1;\n+  DECL_PURE_P (soft_lookupinterfacemethod_node) = 1;\n   t = tree_cons (NULL_TREE, ptr_type_node,\n \t\t tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t    tree_cons (NULL_TREE, ptr_type_node, endlink)));"}, {"sha": "9194d118691f36e8c82ce72c38e2d421b81a55fc", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -505,7 +505,7 @@ validate_equiv_mem (rtx start, rtx reg, rtx memref)\n \treturn 1;\n \n       if (CALL_P (insn) && ! MEM_READONLY_P (memref)\n-\t  && ! CONST_OR_PURE_CALL_P (insn))\n+\t  && ! RTL_CONST_OR_PURE_CALL_P (insn))\n \treturn 0;\n \n       note_stores (PATTERN (insn), validate_equiv_mem_from_store, NULL);\n@@ -781,9 +781,7 @@ memref_used_between_p (rtx memref, rtx start, rtx end)\n \treturn 1;\n \n       /* Nonconst functions may access memory.  */\n-      if (CALL_P (insn)\n-\t  && (! CONST_OR_PURE_CALL_P (insn)\n-\t      || pure_call_p (insn)))\n+      if (CALL_P (insn) && (! RTL_CONST_CALL_P (insn)))\n \treturn 1;\n     }\n "}, {"sha": "c586cf94804eca6820d7be67c09c88aef978dc62", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -563,7 +563,8 @@ find_exits (struct loop *loop, basic_block *body,\n \t  FOR_BB_INSNS (body[i], insn)\n \t    {\n \t      if (CALL_P (insn)\n-\t\t  && !CONST_OR_PURE_CALL_P (insn))\n+\t\t  && (RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)\n+\t\t      || !RTL_CONST_OR_PURE_CALL_P (insn)))\n \t\t{\n \t\t  has_call = true;\n \t\t  bitmap_set_bit (may_exit, i);\n@@ -904,7 +905,8 @@ find_invariants_bb (basic_block bb, bool always_reached, bool always_executed)\n \n       if (always_reached\n \t  && CALL_P (insn)\n-\t  && !CONST_OR_PURE_CALL_P (insn))\n+\t  && (RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)\n+\t      || ! RTL_CONST_OR_PURE_CALL_P (insn)))\n \talways_reached = false;\n     }\n }"}, {"sha": "4dc312d91cfbe6b63e1409f4b79bb30ab66a53ef", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -758,7 +758,7 @@ record_opr_changes (rtx insn)\n \t      }\n \t  }\n \n-      if (! CONST_OR_PURE_CALL_P (insn))\n+      if (! RTL_CONST_OR_PURE_CALL_P (insn))\n \trecord_last_mem_set_info (insn);\n     }\n }"}, {"sha": "c20c337d94438324ec7ad405f4e338389c4cf0ee", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -3155,7 +3155,7 @@ delete_prior_computation (rtx note, rtx insn)\n       /* If we reach a CALL which is not calling a const function\n \t or the callee pops the arguments, then give up.  */\n       if (CALL_P (our_prev)\n-\t  && (! CONST_OR_PURE_CALL_P (our_prev)\n+\t  && (! RTL_CONST_CALL_P (our_prev)\n \t      || GET_CODE (pat) != SET || GET_CODE (SET_SRC (pat)) != CALL))\n \tbreak;\n "}, {"sha": "b747a27f5924537ba7d878e07789210b92190da3", "filename": "gcc/rtl.h", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -253,14 +253,17 @@ struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      In a CODE_LABEL, part of the two-bit alternate entry field.  */\n   unsigned int jump : 1;\n   /* In a CODE_LABEL, part of the two-bit alternate entry field.\n-     1 in a MEM if it cannot trap.  */\n+     1 in a MEM if it cannot trap.  \n+     1 in a CALL_INSN logically equivalent to\n+       ECF_LOOPING_CONST_OR_PURE and DECL_LOOPING_CONST_OR_PURE_P. */\n   unsigned int call : 1;\n   /* 1 in a REG, MEM, or CONCAT if the value is set at most once, anywhere.\n      1 in a SUBREG if it references an unsigned object whose mode has been\n      from a promoted to a wider mode.\n      1 in a SYMBOL_REF if it addresses something in the per-function\n      constants pool.\n-     1 in a CALL_INSN, NOTE, or EXPR_LIST for a const or pure call.\n+     1 in a CALL_INSN logically equivalent to ECF_CONST and TREE_READONLY. \n+     1 in a NOTE, or EXPR_LIST for a const call.\n      1 in a JUMP_INSN, CALL_INSN, or INSN of an annulling branch.  */\n   unsigned int unchanging : 1;\n   /* 1 in a MEM or ASM_OPERANDS expression if the memory reference is volatile.\n@@ -303,7 +306,8 @@ struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n   unsigned frame_related : 1;\n   /* 1 in a REG or PARALLEL that is the current function's return value.\n      1 in a MEM if it refers to a scalar.\n-     1 in a SYMBOL_REF for a weak symbol.  */\n+     1 in a SYMBOL_REF for a weak symbol. \n+     1 in a CALL_INSN logically equivalent to ECF_PURE and DECL_PURE_P. */ \n   unsigned return_val : 1;\n \n   /* The first element of the operands of this rtx.\n@@ -765,10 +769,24 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n   (RTL_FLAG_CHECK6(\"INSN_DELETED_P\", (RTX), INSN, CALL_INSN, JUMP_INSN,\t\\\n \t\t   CODE_LABEL, BARRIER, NOTE)->volatil)\n \n+/* 1 if RTX is a call to a const function.  Built from ECF_CONST and\n+   TREE_READONLY.  */\n+#define RTL_CONST_CALL_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"RTL_CONST_CALL_P\", (RTX), CALL_INSN)->unchanging)\n+\n+/* 1 if RTX is a call to a pure function.  Built from ECF_PURE and\n+   DECL_PURE_P.  */\n+#define RTL_PURE_CALL_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"RTL_PURE_CALL_P\", (RTX), CALL_INSN)->return_val)\n+\n /* 1 if RTX is a call to a const or pure function.  */\n-#define CONST_OR_PURE_CALL_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK3(\"CONST_OR_PURE_CALL_P\", (RTX), CALL_INSN, NOTE,\t\\\n-\t\t   EXPR_LIST)->unchanging)\n+#define RTL_CONST_OR_PURE_CALL_P(RTX) \\\n+  (RTL_CONST_CALL_P(RTX) || RTL_PURE_CALL_P(RTX))\n+\n+/* 1 if RTX is a call to a looping const or pure function.  Built from\n+   ECF_LOOPING_CONST_OR_PURE and DECL_LOOPING_CONST_OR_PURE_P.  */\n+#define RTL_LOOPING_CONST_OR_PURE_CALL_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"CONST_OR_PURE_CALL_P\", (RTX), CALL_INSN)->call)\n \n /* 1 if RTX is a call_insn for a sibling call.  */\n #define SIBLING_CALL_P(RTX)\t\t\t\t\t\t\\\n@@ -1733,7 +1751,6 @@ extern rtx find_reg_equal_equiv_note (const_rtx);\n extern rtx find_constant_src (const_rtx);\n extern int find_reg_fusage (const_rtx, enum rtx_code, const_rtx);\n extern int find_regno_fusage (const_rtx, enum rtx_code, unsigned int);\n-extern int pure_call_p (const_rtx);\n extern void remove_note (rtx, const_rtx);\n extern void remove_reg_equal_equiv_notes (rtx);\n extern int side_effects_p (const_rtx);"}, {"sha": "f0dc512fcdf1337445c4530ad27c8bbed8c7fa47", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1846,29 +1846,6 @@ find_regno_fusage (const_rtx insn, enum rtx_code code, unsigned int regno)\n   return 0;\n }\n \n-/* Return true if INSN is a call to a pure function.  */\n-\n-int\n-pure_call_p (const_rtx insn)\n-{\n-  const_rtx link;\n-\n-  if (!CALL_P (insn) || ! CONST_OR_PURE_CALL_P (insn))\n-    return 0;\n-\n-  /* Look for the note that differentiates const and pure functions.  */\n-  for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n-    {\n-      rtx u, m;\n-\n-      if (GET_CODE (u = XEXP (link, 0)) == USE\n-\t  && MEM_P (m = XEXP (u, 0)) && GET_MODE (m) == BLKmode\n-\t  && GET_CODE (XEXP (m, 0)) == SCRATCH)\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n \f\n /* Remove register note NOTE from the REG_NOTES of INSN.  */\n "}, {"sha": "b62797f6a563fda554ab7f9864e5d6e93364f37f", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -2304,7 +2304,8 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n \t     all pending reads and writes, and start new dependencies starting\n \t     from here.  But only flush writes for constant calls (which may\n \t     be passed a pointer to something we haven't written yet).  */\n-\t  flush_pending_lists (deps, insn, true, !CONST_OR_PURE_CALL_P (insn));\n+\t  flush_pending_lists (deps, insn, true, \n+\t\t\t       ! RTL_CONST_OR_PURE_CALL_P (insn));\n \n \t  /* Remember the last function call for limiting lifetimes.  */\n \t  free_INSN_LIST_list (&deps->last_function_call);"}, {"sha": "6e5260b995aa2ffaf62ac5cb5c42baefddb9f99a", "filename": "gcc/see.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -2430,7 +2430,10 @@ see_copy_insn (rtx insn)\n \tCALL_INSN_FUNCTION_USAGE (ret)\n \t  = copy_rtx (CALL_INSN_FUNCTION_USAGE (insn));\n       SIBLING_CALL_P (ret) = SIBLING_CALL_P (insn);\n-      CONST_OR_PURE_CALL_P (ret) = CONST_OR_PURE_CALL_P (insn);\n+      RTL_CONST_CALL_P (ret) = RTL_CONST_CALL_P (insn);\n+      RTL_PURE_CALL_P (ret) = RTL_PURE_CALL_P (insn);\n+      RTL_LOOPING_CONST_OR_PURE_CALL_P (ret) \n+\t= RTL_LOOPING_CONST_OR_PURE_CALL_P (insn);\n     }\n   else\n     gcc_unreachable ();"}, {"sha": "f559030fc587da970a945f880d8bf14a93aad4ba", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -1792,9 +1792,11 @@ static void\n update_call_expr_flags (tree call)\n {\n   tree decl = get_callee_fndecl (call);\n+  int flags;\n   if (!decl)\n     return;\n-  if (call_expr_flags (call) & (ECF_CONST | ECF_PURE))\n+  flags = call_expr_flags (call);\n+  if (flags & (ECF_CONST | ECF_PURE) && !(flags & ECF_LOOPING_CONST_OR_PURE))\n     TREE_SIDE_EFFECTS (call) = 0;\n   if (TREE_NOTHROW (decl))\n     TREE_NOTHROW (call) = 1;\n@@ -3906,7 +3908,19 @@ verify_gimple_expr (tree expr)\n     case CALL_EXPR:\n       /* FIXME.  The C frontend passes unpromoted arguments in case it\n \t didn't see a function declaration before the call.  */\n-      return false;\n+      {\n+\ttree decl = CALL_EXPR_FN (expr);\n+\n+\tif (TREE_CODE (decl) == FUNCTION_DECL \n+\t    && DECL_LOOPING_CONST_OR_PURE_P (decl)\n+\t    && (!DECL_PURE_P (decl))\n+\t    && (!TREE_READONLY (decl)))\n+\t  {\n+\t    error (\"invalid pure const state for function\");\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n \n     case OBJ_TYPE_REF:\n       /* FIXME.  */"}, {"sha": "28727ccec0b4b8dda216da715063eb7b95c96b29", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -671,7 +671,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t    {\n \t      value = *n;\n \t      STRIP_TYPE_NOPS (value);\n-\t      if (TREE_CONSTANT (value) || TREE_READONLY_DECL_P (value))\n+\t      if (TREE_CONSTANT (value) || TREE_READONLY (value))\n \t\t{\n \t\t  *tp = build_empty_stmt ();\n \t\t  return copy_body_r (tp, walk_subtrees, data);"}, {"sha": "270353601da15a9c787ee4c2ea8409979a36a129", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -299,7 +299,8 @@ execute_fixup_cfg (void)\n \t    tree call = get_call_expr_in (stmt);\n \t    tree decl = call ? get_callee_fndecl (call) : NULL;\n \n-\t    if (decl && call_expr_flags (call) & (ECF_CONST | ECF_PURE)\n+\t    if (decl && call_expr_flags (call) & (ECF_CONST | ECF_PURE \n+\t\t\t\t\t\t  | ECF_LOOPING_CONST_OR_PURE)\n \t\t&& TREE_SIDE_EFFECTS (call))\n \t      {\n \t\tif (gimple_in_ssa_p (cfun))"}, {"sha": "a8db47dc06dbca2326f792c18275cbe5a3ee1260", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -2077,7 +2077,7 @@ can_value_number_call (tree stmt)\n {\n   tree call = get_call_expr_in (stmt);\n \n-  if (call_expr_flags (call)  & (ECF_PURE | ECF_CONST))\n+  if (call_expr_flags (call) & (ECF_PURE | ECF_CONST))\n     return true;\n   return false;\n }"}, {"sha": "182d86a5a1dc51589db95e2e97d3bb2abf8dc147", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -7373,7 +7373,9 @@ local_define_builtin (const char *name, tree type, enum built_in_function code,\n   if (ecf_flags & ECF_CONST)\n     TREE_READONLY (decl) = 1;\n   if (ecf_flags & ECF_PURE)\n-    DECL_IS_PURE (decl) = 1;\n+    DECL_PURE_P (decl) = 1;\n+  if (ecf_flags & ECF_LOOPING_CONST_OR_PURE)\n+    DECL_LOOPING_CONST_OR_PURE_P (decl) = 1;\n   if (ecf_flags & ECF_NORETURN)\n     TREE_THIS_VOLATILE (decl) = 1;\n   if (ecf_flags & ECF_NOTHROW)\n@@ -7766,7 +7768,7 @@ process_call_operands (tree t)\n       /* Calls have side-effects, except those to const or\n \t pure functions.  */\n       i = call_expr_flags (t);\n-      if (!(i & (ECF_CONST | ECF_PURE)))\n+      if ((i & ECF_LOOPING_CONST_OR_PURE) || !(i & (ECF_CONST | ECF_PURE)))\n \tside_effects = 1;\n     }\n   TREE_SIDE_EFFECTS (t) = side_effects;"}, {"sha": "0b4b443311d3834e53c87f5a924613023d198368", "filename": "gcc/tree.h", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/becfd6e57bd90a45e5ab409db85f2e69e5945213/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=becfd6e57bd90a45e5ab409db85f2e69e5945213", "patch": "@@ -788,7 +788,7 @@ enum tree_node_structure_enum {\n     &__t->phi.a[__i]; }))\n \n #define OMP_CLAUSE_ELT_CHECK(T, I) __extension__\t\t\t\\\n-(*({__typeof (T) const __t = (T);\t\t\t\t\t\t\\\n+(*({__typeof (T) const __t = (T);\t\t\t\t\t\\\n     const int __i = (I);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != OMP_CLAUSE)\t\t\t\t\t\\\n       tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,  \t\\\n@@ -1281,13 +1281,11 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define TREE_THIS_NOTRAP(NODE) ((NODE)->base.nothrow_flag)\n \n /* In a VAR_DECL, PARM_DECL or FIELD_DECL, or any kind of ..._REF node,\n-   nonzero means it may not be the lhs of an assignment.  */\n+   nonzero means it may not be the lhs of an assignment.  \n+   Nonzero in a FUNCTION_DECL means this function should be treated\n+   as \"const\" function (can only read its arguments).  */\n #define TREE_READONLY(NODE) (NON_TYPE_CHECK (NODE)->base.readonly_flag)\n \n-/* Nonzero if NODE is a _DECL with TREE_READONLY set.  */\n-#define TREE_READONLY_DECL_P(NODE)\\\n-\t(DECL_P (NODE) && TREE_READONLY (NODE))\n-\n /* Value of expression is constant.  Always on in all ..._CST nodes.  May\n    also appear in an expression or decl where the value is constant.  */\n #define TREE_CONSTANT(NODE) (NON_TYPE_CHECK (NODE)->base.constant_flag)\n@@ -3256,7 +3254,16 @@ struct tree_decl_non_common GTY(())\n \n /* Nonzero in a FUNCTION_DECL means this function should be treated\n    as \"pure\" function (like const function, but may read global memory).  */\n-#define DECL_IS_PURE(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.pure_flag)\n+#define DECL_PURE_P(NODE) (FUNCTION_DECL_CHECK (NODE)->function_decl.pure_flag)\n+\n+/* Nonzero only if one of TREE_READONLY or DECL_PURE_P is nonzero AND\n+   the const or pure function may not terminate.  When this is nonzero\n+   for a const or pure function, it can be dealt with by cse passes\n+   but cannot be removed by dce passes since you are not allowed to\n+   change an infinite looping program into one that terminates without\n+   error.  */\n+#define DECL_LOOPING_CONST_OR_PURE_P(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->function_decl.looping_const_or_pure_flag)\n \n /* Nonzero in a FUNCTION_DECL means this function should be treated\n    as \"novops\" function (function that does not read global memory,\n@@ -3354,16 +3361,18 @@ struct tree_function_decl GTY(())\n   unsigned returns_twice_flag : 1;\n   unsigned malloc_flag : 1;\n   unsigned operator_new_flag : 1;\n-  unsigned pure_flag : 1;\n   unsigned declared_inline_flag : 1;\n   unsigned regdecl_flag : 1;\n \n   unsigned inline_flag : 1;\n   unsigned no_instrument_function_entry_exit : 1;\n   unsigned no_limit_stack : 1;\n   unsigned disregard_inline_limits : 1;\n+  unsigned pure_flag : 1;\n+  unsigned looping_const_or_pure_flag : 1;\n+\n \n-  /* 4 bits left */\n+  /* 3 bits left */\n };\n \n /* For a TYPE_DECL, holds the \"original\" type.  (TREE_TYPE has the copy.) */\n@@ -4987,28 +4996,34 @@ extern tree build_duplicate_type (tree);\n \n /* Nonzero if this is a call to a function whose return value depends\n    solely on its arguments, has no side effects, and does not read\n-   global memory.  */\n-#define ECF_CONST\t\t1\n+   global memory.  This corresponds to TREE_READONLY for function\n+   decls.  */\n+#define ECF_CONST\t\t  (1 << 0)\n+/* Nonzero if this is a call to \"pure\" function (like const function,\n+   but may read memory.  This corresponds to DECL_PURE_P for function\n+   decls.  */\n+#define ECF_PURE\t\t  (1 << 1)\n+/* Nonzero if this is ECF_CONST or ECF_PURE but cannot be proven to no\n+   infinite loop.  This corresponds to DECL_LOOPING_CONST_OR_PURE_P\n+   for function decls.*/\n+#define ECF_LOOPING_CONST_OR_PURE (1 << 2)\n /* Nonzero if this call will never return.  */\n-#define ECF_NORETURN\t\t2\n+#define ECF_NORETURN\t\t  (1 << 3)\n /* Nonzero if this is a call to malloc or a related function.  */\n-#define ECF_MALLOC\t\t4\n+#define ECF_MALLOC\t\t  (1 << 4)\n /* Nonzero if it is plausible that this is a call to alloca.  */\n-#define ECF_MAY_BE_ALLOCA\t8\n+#define ECF_MAY_BE_ALLOCA\t  (1 << 5)\n /* Nonzero if this is a call to a function that won't throw an exception.  */\n-#define ECF_NOTHROW\t\t16\n+#define ECF_NOTHROW\t\t  (1 << 6)\n /* Nonzero if this is a call to setjmp or a related function.  */\n-#define ECF_RETURNS_TWICE\t32\n+#define ECF_RETURNS_TWICE\t  (1 << 7)\n /* Nonzero if this call replaces the current stack frame.  */\n-#define ECF_SIBCALL\t\t64\n-/* Nonzero if this is a call to \"pure\" function (like const function,\n-   but may read memory.  */\n-#define ECF_PURE\t\t128\n+#define ECF_SIBCALL\t\t  (1 << 8)\n /* Create libcall block around the call.  */\n-#define ECF_LIBCALL_BLOCK\t256\n+#define ECF_LIBCALL_BLOCK\t  (1 << 9)\n /* Function does not read or write memory (but may have side effects, so\n    it does not necessarily fit ECF_CONST).  */\n-#define ECF_NOVOPS\t\t512\n+#define ECF_NOVOPS\t\t  (1 << 10)\n \n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);"}]}