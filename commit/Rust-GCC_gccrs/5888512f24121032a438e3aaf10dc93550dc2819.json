{"sha": "5888512f24121032a438e3aaf10dc93550dc2819", "node_id": "C_kwDOANBUbNoAKDU4ODg1MTJmMjQxMjEwMzJhNDM4ZTNhYWYxMGRjOTM1NTBkYzI4MTk", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2021-11-07T13:39:59Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2021-11-16T18:07:50Z"}, "message": "fortran: Reverse actual vs dummy argument mapping\n\nThere was originally no way from an actual argument to get\nto the corresponding dummy argument, even if the job of sorting\nand matching actual with dummy arguments was done.\nThe closest was a field named actual in gfc_intrinsic_arg that was\nused as scratch data when sorting arguments of one specific call.\nHowever that value was overwritten later on as arguments of another\ncall to the same procedure were sorted and matched.\n\nThis change removes that field from gfc_intrinsic_arg and adds instead\na new field associated_dummy in gfc_actual_arglist.\n\nThe new field has as type a new wrapper struct gfc_dummy_arg that provides\na common interface to both dummy arguments of user-defined procedures\n(which have type gfc_formal_arglist) and dummy arguments of intrinsic procedures\n(which have type gfc_intrinsic_arg).\n\nAs the removed field was used in the code sorting and matching arguments,\nthat code has to be updated.  Two local vectors with matching indices\nare introduced for respectively dummy and actual arguments, and the\nloops are modified to use indices and update those argument vectors.\n\ngcc/fortran/ChangeLog:\n\t* gfortran.h (gfc_dummy_arg_kind, gfc_dummy_arg): New.\n\t(gfc_actual_arglist): New field associated_dummy.\n\t(gfc_intrinsic_arg): Remove field actual.\n\t* interface.c (get_nonintrinsic_dummy_arg): New.\n\t(gfc_compare_actual): Initialize associated_dummy.\n\t* intrinsic.c (get_intrinsic_dummy_arg): New.\n\t(sort_actual):\u00a0 Add argument vectors.\n\tUse loops with indices on argument vectors.\n\tInitialize associated_dummy.", "tree": {"sha": "08c69e079127c0ca933218c2bd9df5b92cfc2e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08c69e079127c0ca933218c2bd9df5b92cfc2e48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5888512f24121032a438e3aaf10dc93550dc2819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5888512f24121032a438e3aaf10dc93550dc2819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5888512f24121032a438e3aaf10dc93550dc2819", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5888512f24121032a438e3aaf10dc93550dc2819/comments", "author": null, "committer": null, "parents": [{"sha": "c31733c3bf57d4cfc31e8d7a95b0ba2cd41e6ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c31733c3bf57d4cfc31e8d7a95b0ba2cd41e6ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c31733c3bf57d4cfc31e8d7a95b0ba2cd41e6ea3"}], "stats": {"total": 95, "additions": 80, "deletions": 15}, "files": [{"sha": "86c096a9da742d4098b9d5d698e96bbc6a23da75", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5888512f24121032a438e3aaf10dc93550dc2819/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5888512f24121032a438e3aaf10dc93550dc2819/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5888512f24121032a438e3aaf10dc93550dc2819", "patch": "@@ -1199,6 +1199,9 @@ gfc_formal_arglist;\n #define gfc_get_formal_arglist() XCNEW (gfc_formal_arglist)\n \n \n+struct gfc_dummy_arg;\n+\n+\n /* The gfc_actual_arglist structure is for actual arguments and\n    for type parameter specification lists.  */\n typedef struct gfc_actual_arglist\n@@ -1215,6 +1218,11 @@ typedef struct gfc_actual_arglist\n   gfc_param_spec_type spec_type;\n \n   struct gfc_expr *expr;\n+\n+  /*  The dummy arg this actual arg is associated with, if the interface\n+      is explicit.  NULL otherwise.  */\n+  gfc_dummy_arg *associated_dummy;\n+\n   struct gfc_actual_arglist *next;\n }\n gfc_actual_arglist;\n@@ -2299,14 +2307,33 @@ typedef struct gfc_intrinsic_arg\n   gfc_typespec ts;\n   unsigned optional:1, value:1;\n   ENUM_BITFIELD (sym_intent) intent:2;\n-  gfc_actual_arglist *actual;\n \n   struct gfc_intrinsic_arg *next;\n-\n }\n gfc_intrinsic_arg;\n \n \n+typedef enum {\n+  GFC_UNDEFINED_DUMMY_ARG = 0,\n+  GFC_INTRINSIC_DUMMY_ARG,\n+  GFC_NON_INTRINSIC_DUMMY_ARG\n+}\n+gfc_dummy_arg_intrinsicness;\n+\n+/* dummy arg of either an intrinsic or a user-defined procedure.  */\n+struct gfc_dummy_arg\n+{\n+  gfc_dummy_arg_intrinsicness intrinsicness;\n+\n+  union {\n+    gfc_intrinsic_arg *intrinsic;\n+    gfc_formal_arglist *non_intrinsic;\n+  } u;\n+};\n+\n+#define gfc_get_dummy_arg() XCNEW (gfc_dummy_arg)\n+\n+\n /* Specifies the various kinds of check functions used to verify the\n    argument lists of intrinsic functions. fX with X an integer refer\n    to check functions of intrinsics with X arguments. f1m is used for"}, {"sha": "2c9d371ba2deb0a60cf849bdb09ca0896df88655", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5888512f24121032a438e3aaf10dc93550dc2819/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5888512f24121032a438e3aaf10dc93550dc2819/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=5888512f24121032a438e3aaf10dc93550dc2819", "patch": "@@ -3043,6 +3043,18 @@ lookup_arg_fuzzy (const char *arg, gfc_formal_arglist *arguments)\n }\n \n \n+static gfc_dummy_arg *\n+get_nonintrinsic_dummy_arg (gfc_formal_arglist *formal)\n+{\n+  gfc_dummy_arg * const dummy_arg = gfc_get_dummy_arg ();\n+\n+  dummy_arg->intrinsicness = GFC_NON_INTRINSIC_DUMMY_ARG;\n+  dummy_arg->u.non_intrinsic = formal;\n+\n+  return dummy_arg;\n+}\n+\n+\n /* Given formal and actual argument lists, see if they are compatible.\n    If they are compatible, the actual argument list is sorted to\n    correspond with the formal list, and elements for missing optional\n@@ -3151,6 +3163,8 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t\t   \"call at %L\", where);\n \t  return false;\n \t}\n+      else\n+\ta->associated_dummy = get_nonintrinsic_dummy_arg (f);\n \n       if (a->expr == NULL)\n \t{\n@@ -3680,9 +3694,12 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n   /* The argument lists are compatible.  We now relink a new actual\n      argument list with null arguments in the right places.  The head\n      of the list remains the head.  */\n-  for (i = 0; i < n; i++)\n+  for (f = formal, i = 0; f; f = f->next, i++)\n     if (new_arg[i] == NULL)\n-      new_arg[i] = gfc_get_actual_arglist ();\n+      {\n+\tnew_arg[i] = gfc_get_actual_arglist ();\n+\tnew_arg[i]->associated_dummy = get_nonintrinsic_dummy_arg (f);\n+      }\n \n   if (na != 0)\n     {"}, {"sha": "cb07326ef62b41918189240c5726a4d900516f31", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5888512f24121032a438e3aaf10dc93550dc2819/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5888512f24121032a438e3aaf10dc93550dc2819/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=5888512f24121032a438e3aaf10dc93550dc2819", "patch": "@@ -4237,6 +4237,18 @@ remove_nullargs (gfc_actual_arglist **ap)\n }\n \n \n+static gfc_dummy_arg *\n+get_intrinsic_dummy_arg (gfc_intrinsic_arg *intrinsic)\n+{\n+  gfc_dummy_arg * const dummy_arg = gfc_get_dummy_arg ();\n+\n+  dummy_arg->intrinsicness = GFC_INTRINSIC_DUMMY_ARG;\n+  dummy_arg->u.intrinsic = intrinsic;\n+\n+  return dummy_arg;\n+}\n+\n+\n /* Given an actual arglist and a formal arglist, sort the actual\n    arglist so that its arguments are in a one-to-one correspondence\n    with the format arglist.  Arguments that are not present are given\n@@ -4254,8 +4266,14 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n   remove_nullargs (ap);\n   actual = *ap;\n \n+  auto_vec<gfc_intrinsic_arg *> dummy_args;\n+  auto_vec<gfc_actual_arglist *> ordered_actual_args;\n+\n   for (f = formal; f; f = f->next)\n-    f->actual = NULL;\n+    dummy_args.safe_push (f);\n+\n+  ordered_actual_args.safe_grow_cleared (dummy_args.length (),\n+\t\t\t\t\t /* exact = */true);\n \n   f = formal;\n   a = actual;\n@@ -4307,7 +4325,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n \t}\n     }\n \n-  for (;;)\n+  for (int i = 0;; i++)\n     {\t\t/* Put the nonkeyword arguments in a 1:1 correspondence */\n       if (f == NULL)\n \tbreak;\n@@ -4317,7 +4335,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n       if (a->name != NULL)\n \tgoto keywords;\n \n-      f->actual = a;\n+      ordered_actual_args[i] = a;\n \n       f = f->next;\n       a = a->next;\n@@ -4335,7 +4353,8 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n      to be keyword arguments.  */\n   for (; a; a = a->next)\n     {\n-      for (f = formal; f; f = f->next)\n+      int idx;\n+      FOR_EACH_VEC_ELT (dummy_args, idx, f)\n \tif (strcmp (a->name, f->name) == 0)\n \t  break;\n \n@@ -4350,21 +4369,21 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n \t  return false;\n \t}\n \n-      if (f->actual != NULL)\n+      if (ordered_actual_args[idx] != NULL)\n \t{\n \t  gfc_error (\"Argument %qs appears twice in call to %qs at %L\",\n \t\t     f->name, name, where);\n \t  return false;\n \t}\n-\n-      f->actual = a;\n+      ordered_actual_args[idx] = a;\n     }\n \n optional:\n   /* At this point, all unmatched formal args must be optional.  */\n-  for (f = formal; f; f = f->next)\n+  int idx;\n+  FOR_EACH_VEC_ELT (dummy_args, idx, f)\n     {\n-      if (f->actual == NULL && f->optional == 0)\n+      if (ordered_actual_args[idx] == NULL && f->optional == 0)\n \t{\n \t  gfc_error (\"Missing actual argument %qs in call to %qs at %L\",\n \t\t     f->name, name, where);\n@@ -4377,9 +4396,9 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n      together in a way that corresponds with the formal list.  */\n   actual = NULL;\n \n-  for (f = formal; f; f = f->next)\n+  FOR_EACH_VEC_ELT (dummy_args, idx, f)\n     {\n-      a = f->actual;\n+      a = ordered_actual_args[idx];\n       if (a && a->label != NULL && f->ts.type)\n \t{\n \t  gfc_error (\"ALTERNATE RETURN not permitted at %L\", where);\n@@ -4392,6 +4411,8 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n \t  a->missing_arg_type = f->ts.type;\n \t}\n \n+      a->associated_dummy = get_intrinsic_dummy_arg (f);\n+\n       if (actual == NULL)\n \t*ap = a;\n       else"}]}