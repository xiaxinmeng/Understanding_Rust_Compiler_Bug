{"sha": "116eebd67408bc31ca138311c8ac7f4d2389c22f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE2ZWViZDY3NDA4YmMzMWNhMTM4MzExYzhhYzdmNGQyMzg5YzIyZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-19T05:26:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-19T05:26:48Z"}, "message": "emit-rtl.c (remove_unncessary_notes): Check that all NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes have an...\n\n\t* emit-rtl.c (remove_unncessary_notes): Check that all\n\tNOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes have an\n\tassociated NOTE_BLOCK.\n\t* function.h (identify_blocks): Update comments.\n\t(reorder_blocks): Declare.\n\t* function.c (identify_blocks): Don't take paramters.\n\t(reorder_blocks): Don't take parameters.\n\t* loop.h (find_loop_tree_blocks): Remove.\n\t(unroll_block_trees): Likewise.\n\t* loop.c (loop_optimize): Don't call find_loop_tree_blocks.  Use\n\treorder_blocks instead of unroll_block_trees.h\n\t* sibcall.c (optimize_sibling_and_tail_recursive_calls): Likewise.\n\t* stmt.c (find_loop_tree_blocks): Remove.\n\t(unroll_block_trees): Likewise.\n\t* toplev.c (rest_of_compilation): Don't call find_loop_tree_blocks\n\tin whole-function mode.\n\t* tree.h (reorder_blocks): Remove declaration.\n\nFrom-SVN: r32632", "tree": {"sha": "7e5085f497fa4f8351b62a15342abb5192c649b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e5085f497fa4f8351b62a15342abb5192c649b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/116eebd67408bc31ca138311c8ac7f4d2389c22f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/116eebd67408bc31ca138311c8ac7f4d2389c22f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/116eebd67408bc31ca138311c8ac7f4d2389c22f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/116eebd67408bc31ca138311c8ac7f4d2389c22f/comments", "author": null, "committer": null, "parents": [{"sha": "cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8ed629642bebaa19a2fe544f0c3efcafe835f2"}], "stats": {"total": 132, "additions": 62, "deletions": 70}, "files": [{"sha": "5f9babb94ddd57bafde45f21052364fe0f2857ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -1,5 +1,23 @@\n 2000-03-18  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* emit-rtl.c (remove_unncessary_notes): Check that all\n+\tNOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes have an\n+\tassociated NOTE_BLOCK.\n+\t* function.h (identify_blocks): Update comments.\n+\t(reorder_blocks): Declare.\n+\t* function.c (identify_blocks): Don't take paramters.\n+\t(reorder_blocks): Don't take parameters.\n+\t* loop.h (find_loop_tree_blocks): Remove.\n+\t(unroll_block_trees): Likewise.\n+\t* loop.c (loop_optimize): Don't call find_loop_tree_blocks.  Use\n+\treorder_blocks instead of unroll_block_trees.h\n+\t* sibcall.c (optimize_sibling_and_tail_recursive_calls): Likewise.\n+\t* stmt.c (find_loop_tree_blocks): Remove.\n+\t(unroll_block_trees): Likewise.\n+\t* toplev.c (rest_of_compilation): Don't call find_loop_tree_blocks\n+\tin whole-function mode.\n+\t* tree.h (reorder_blocks): Remove declaration.\n+\n \t* expr.c: Include intl.h.\n \t* Makefile.in (expr.o): Depend on intl.h.\n \t"}, {"sha": "764a5ad7f204c8f4aff3d33af5f37cbe4dcd74b2", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -2667,9 +2667,8 @@ remove_unncessary_notes ()\n   rtx insn;\n   rtx next;\n \n-  /* Remove NOTE_INSN_DELETED notes.  We must not remove the first\n-     instruction in the function because the compiler depends on the\n-     first instruction being a note.  */\n+  /* We must not remove the first instruction in the function because\n+     the compiler depends on the first instruction being a note.  */\n   for (insn = NEXT_INSN (get_insns ()); insn; insn = next)\n     {\n       /* Remember what's next.  */\n@@ -2679,6 +2678,14 @@ remove_unncessary_notes ()\n       if (GET_CODE (insn) != NOTE)\n \tcontinue;\n \n+      /* By now, all notes indicating lexical blocks should have\n+\t NOTE_BLOCK filled in.  */\n+      if ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n+\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t  && NOTE_BLOCK (insn) == NULL_TREE)\n+\tabort ();\n+\n+      /* Remove NOTE_INSN_DELETED notes.  */\n       if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n \tremove_insn (insn);\n       else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)"}, {"sha": "e994558fdc83c75ed1abc069409dfaea14d6db33", "filename": "gcc/function.c", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -5508,11 +5508,6 @@ round_trampoline_addr (tramp)\n   return tramp;\n }\n \f\n-/* The functions identify_blocks and reorder_blocks provide a way to\n-   reorder the tree of BLOCK nodes, for optimizers that reshuffle or\n-   duplicate portions of the RTL code.  Call identify_blocks before\n-   changing the RTL, and call reorder_blocks after.  */\n-\n /* Put all this function's BLOCK nodes including those that are chained\n    onto the first block into a vector, and return it.\n    Also store in each NOTE for the beginning or end of a block\n@@ -5521,13 +5516,12 @@ round_trampoline_addr (tramp)\n    and INSNS, the insn chain of the function.  */\n \n void\n-identify_blocks (block, insns)\n-     tree block;\n-     rtx insns;\n+identify_blocks ()\n {\n   int n_blocks;\n   tree *block_vector, *last_block_vector;\n   tree *block_stack;\n+  tree block = DECL_INITIAL (current_function_decl);\n \n   if (block == 0)\n     return;\n@@ -5537,8 +5531,10 @@ identify_blocks (block, insns)\n   block_vector = get_block_vector (block, &n_blocks);\n   block_stack = (tree *) xmalloc (n_blocks * sizeof (tree));\n \n-  last_block_vector = identify_blocks_1 (insns, block_vector + 1,\n-\t\t\t\t\t block_vector + n_blocks, block_stack);\n+  last_block_vector = identify_blocks_1 (get_insns (), \n+\t\t\t\t\t block_vector + 1,\n+\t\t\t\t\t block_vector + n_blocks, \n+\t\t\t\t\t block_stack);\n \n   /* If we didn't use all of the subblocks, we've misplaced block notes.  */\n   /* ??? This appears to happen all the time.  Latent bugs elsewhere?  */\n@@ -5616,36 +5612,30 @@ identify_blocks_1 (insns, block_vector, end_block_vector, orig_block_stack)\n   return block_vector;\n }\n \n-/* Given a revised instruction chain, rebuild the tree structure of\n-   BLOCK nodes to correspond to the new order of RTL.  The new block\n-   tree is inserted below TOP_BLOCK.  Returns the current top-level\n-   block.  */\n+/* Identify BLOCKs referenced by more than one\n+   NOTE_INSN_BLOCK_{BEG,END}, and create duplicate blocks. */\n \n-tree\n-reorder_blocks (block, insns)\n-     tree block;\n-     rtx insns;\n+void\n+reorder_blocks ()\n {\n-  tree current_block = block;\n+  tree block = DECL_INITIAL (current_function_decl);\n   varray_type block_stack;\n \n   if (block == NULL_TREE)\n-    return NULL_TREE;\n+    return;\n \n   VARRAY_TREE_INIT (block_stack, 10, \"block_stack\");\n \n-  /* Prune the old trees away, so that it doesn't get in the way.  */\n-  BLOCK_SUBBLOCKS (current_block) = 0;\n-  BLOCK_CHAIN (current_block) = 0;\n+  /* Prune the old trees away, so that they don't get in the way.  */\n+  BLOCK_SUBBLOCKS (block) = NULL_TREE;\n+  BLOCK_CHAIN (block) = NULL_TREE;\n \n-  reorder_blocks_1 (insns, current_block, &block_stack);\n+  reorder_blocks_1 (get_insns (), block, &block_stack);\n \n-  BLOCK_SUBBLOCKS (current_block)\n-    = blocks_nreverse (BLOCK_SUBBLOCKS (current_block));\n+  BLOCK_SUBBLOCKS (block)\n+    = blocks_nreverse (BLOCK_SUBBLOCKS (block));\n \n   VARRAY_FREE (block_stack);\n-\n-  return current_block;\n }\n \n /* Helper function for reorder_blocks.  Process the insn chain beginning"}, {"sha": "5c7aa414d30195148a024352a79f72ad31b128ae", "filename": "gcc/function.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -303,7 +303,7 @@ struct function\n \n   /* Nonzero if this function is being processed in function-at-a-time\n      mode.  In other words, if all tree structure for this function,\n-     including the BLOCK tree is created, before RTL generation\n+     including the BLOCK tree, is created before RTL generation\n      commences.  */\n   int x_whole_function_mode_p;\n \n@@ -548,10 +548,12 @@ struct function *find_function_data PARAMS ((tree));\n /* Pointer to chain of `struct function' for containing functions.  */\n extern struct function *outer_function_chain;\n \n-/* Put all this function's BLOCK nodes into a vector and return it.\n-   Also store in each NOTE for the beginning or end of a block\n-   the index of that block in the vector.  */\n-extern void identify_blocks PARAMS ((tree, rtx));\n+/* Set NOTE_BLOCK for each block note in the current function.  */\n+extern void identify_blocks PARAMS ((void));\n+\n+/* Identify BLOCKs referenced by more than one NOTE_INSN_BLOCK_{BEG,END},\n+   and create duplicate blocks.  */\n+extern void reorder_blocks PARAMS ((void));\n \n /* Set BLOCK_NUMBER for all the blocks in FN.  */\n extern void number_blocks PARAMS ((tree));"}, {"sha": "74ff0a6a7fd49e4681c0a9b993c9608dd01078e0", "filename": "gcc/loop.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -518,14 +518,6 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n     if (uid_luid[i] == 0)\n       uid_luid[i] = uid_luid[i - 1];\n \n-  /* If debugging and unrolling loops, we must replicate the tree\n-     nodes corresponding to the BLOCKs inside the loop, so that the\n-     original one to one mapping will remain.  We sometimes unroll\n-     loops even when unroll_p is false, so we must always do this when\n-     debugging.  */\n-  if (write_symbols != NO_DEBUG)\n-    find_loop_tree_blocks ();\n-\n   /* Determine if the function has indirect jump.  On some systems\n      this prevents low overhead loop instructions from being used.  */\n   indirect_jump_in_function = indirect_jump_in_function_p (f);\n@@ -540,9 +532,12 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n \tscan_loop (loop, unroll_p, bct_p);\n     }\n \n-  /* Replicate the BLOCKs.  */\n+  /* If there were lexical blocks inside the loop, they have been\n+     replicated.  We will now have more than one NOTE_INSN_BLOCK_BEG\n+     and NOTE_INSN_BLOCK_END for each such block.  We must duplicate\n+     the BLOCKs as well.  */\n   if (write_symbols != NO_DEBUG)\n-    unroll_block_trees ();\n+    reorder_blocks ();\n \n   end_alias_analysis ();\n "}, {"sha": "f7769f8ea4ac70a6f0a5840cff8cb23dd85f4ffd", "filename": "gcc/loop.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -248,6 +248,3 @@ int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n \n int loop_insn_first_p PARAMS ((rtx, rtx));\n \n-/* Forward declarations for non-static functions declared in stmt.c.  */\n-void find_loop_tree_blocks PARAMS ((void));\n-void unroll_block_trees PARAMS ((void));"}, {"sha": "bbb70243e72f665f54a7295ef2dcb9d360c2db46", "filename": "gcc/sibcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -571,7 +571,7 @@ optimize_sibling_and_tail_recursive_calls ()\n      CALL_PLACEHOLDER alternatives that we didn't emit.  Rebuild the\n      lexical block tree to correspond to the notes that still exist.  */\n   if (replaced_call_placeholder)\n-    unroll_block_trees ();\n+    reorder_blocks ();\n \n   /* This information will be invalid after inline expansion.  Kill it now.  */\n   free_basic_block_vars (0);"}, {"sha": "837df5cb670c4b7824feb6f0275e6a50dcde3134", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -6372,19 +6372,3 @@ emit_case_nodes (index, node, default_label, index_type)\n     }\n }\n \f\n-/* These routines are used by the loop unrolling code.  They copy BLOCK trees\n-   so that the debugging info will be correct for the unrolled loop.  */\n-\n-void\n-find_loop_tree_blocks ()\n-{\n-  identify_blocks (DECL_INITIAL (current_function_decl), get_insns ());\n-}\n-\n-void\n-unroll_block_trees ()\n-{\n-  tree block = DECL_INITIAL (current_function_decl);\n-\n-  reorder_blocks (block, get_insns ());\n-}"}, {"sha": "f304144b3c8a7b721a67522f60d7c3e6db51c5ad", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -2858,7 +2858,8 @@ rest_of_compilation (decl)\n \n   /* First, make sure that NOTE_BLOCK is set correctly for each\n      NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END note.  */\n-  find_loop_tree_blocks ();\n+  if (!cfun->x_whole_function_mode_p)\n+    identify_blocks ();\n \n   /* Then remove any notes we don't need.  That will make iterating\n      over the instruction sequence faster, and allow the garbage\n@@ -2868,7 +2869,7 @@ rest_of_compilation (decl)\n   /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n      tree in sensible shape.  So, we just recalculate it here.  */\n   if (cfun->x_whole_function_mode_p)\n-    unroll_block_trees ();\n+    reorder_blocks ();\n \n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */"}, {"sha": "1c5cebc3cf3a2e3f4b85c32edfbb5a53bbfc13e6", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116eebd67408bc31ca138311c8ac7f4d2389c22f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=116eebd67408bc31ca138311c8ac7f4d2389c22f", "patch": "@@ -2524,8 +2524,6 @@ extern void push_temp_slots\t\tPARAMS ((void));\n extern void preserve_temp_slots\t\tPARAMS ((struct rtx_def *));\n extern void preserve_rtl_expr_temps\tPARAMS ((tree));\n extern int aggregate_value_p\t\tPARAMS ((tree));\n-extern tree reorder_blocks\t\tPARAMS ((tree,\n-\t\t\t\t\t\tstruct rtx_def *));\n extern void free_temps_for_rtl_expr\tPARAMS ((tree));\n extern void instantiate_virtual_regs\tPARAMS ((tree, struct rtx_def *));\n extern void unshare_all_rtl\t\tPARAMS ((tree, struct rtx_def *));"}]}