{"sha": "3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E5Y2M2ODUzYWQxYTE4ODljOThjM2FlNmFiNzYyOGQwOWNhOWQ4Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-23T21:15:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-23T21:15:48Z"}, "message": "cp-tree.h (PUSH_GLOBAL, [...]): Delete.\n\n\t* cp-tree.h (PUSH_GLOBAL, PUSH_LOCAL, PUSH_USING): Delete.\n\t* name-lookup.c (create_local_binding): New.\n\t(update_binding): New.\n\t(pushdecl_maybe_friend_1): Rename to ...\n\t(do_pushdecl): ... this.  Reimplement.\n\t(pushdecl): Adjust.\n\t(push_overloaded_decl_1, push_overloaded_decl): Delete.\n\nFrom-SVN: r248387", "tree": {"sha": "b4b066822cc13a858257666c679cd732a8234af8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4b066822cc13a858257666c679cd732a8234af8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0c1ade45a7488e97c8d6c3aababec5c9d04f609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0c1ade45a7488e97c8d6c3aababec5c9d04f609", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0c1ade45a7488e97c8d6c3aababec5c9d04f609"}], "stats": {"total": 736, "additions": 292, "deletions": 444}, "files": [{"sha": "4a72b655318f4335ef99eb5e78c7f7815a6b9c99", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f", "patch": "@@ -1,3 +1,13 @@\n+2017-05-23  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (PUSH_GLOBAL, PUSH_LOCAL, PUSH_USING): Delete.\n+\t* name-lookup.c (create_local_binding): New.\n+\t(update_binding): New.\n+\t(pushdecl_maybe_friend_1): Rename to ...\n+\t(do_pushdecl): ... this.  Reimplement.\n+\t(pushdecl): Adjust.\n+\t(push_overloaded_decl_1, push_overloaded_decl): Delete.\n+\n 2017-05-23  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/80396 - built-in for make_integer_sequence."}, {"sha": "2ed9e5aa4738174768318a4628949a0c9eccef19", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f", "patch": "@@ -5312,14 +5312,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n \t\t\t\t   will be identical to\n \t\t\t\t   COMPARE_STRICT.  */\n \n-/* Used with push_overloaded_decl.  */\n-#define PUSH_GLOBAL\t     0  /* Push the DECL into namespace scope,\n-\t\t\t\t   regardless of the current scope.  */\n-#define PUSH_LOCAL\t     1  /* Push the DECL into the current\n-\t\t\t\t   scope.  */\n-#define PUSH_USING\t     2  /* We are pushing this DECL as the\n-\t\t\t\t   result of a using declaration.  */\n-\n /* Used with start function.  */\n #define SF_DEFAULT\t     0  /* No flags.  */\n #define SF_PRE_PARSED\t     1  /* The function declaration has"}, {"sha": "89d4e2ad1dbea229294cbbc6ba0a85babff30c43", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 282, "deletions": 436, "changes": 718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=3a9cc6853ad1a1889c98c3ae6ab7628d09ca9d8f", "patch": "@@ -48,7 +48,6 @@ struct scope_binding {\n };\n #define EMPTY_SCOPE_BINDING { NULL_TREE, NULL_TREE }\n \n-static tree push_overloaded_decl (tree, int, bool);\n static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n \t\t\t\t    tree, int);\n static bool qualified_lookup_using_namespace (tree, tree,\n@@ -61,6 +60,23 @@ static void consider_binding_level (tree name,\n static tree push_using_directive (tree);\n static void diagnose_name_conflict (tree, tree);\n \n+/* Create a local binding level for NAME.  */\n+\n+static cxx_binding *\n+create_local_binding (cp_binding_level *level, tree name)\n+{\n+  cxx_binding *binding = cxx_binding_make (NULL, NULL);\n+\n+  INHERITED_VALUE_BINDING_P (binding) = false;\n+  LOCAL_BINDING_P (binding) = true;\n+  binding->scope = level;\n+  binding->previous = IDENTIFIER_BINDING (name);\n+\n+  IDENTIFIER_BINDING (name) = binding;\n+  \n+  return binding;\n+}\n+\n /* Find the binding for NAME in namespace NS.  If CREATE_P is true,\n    make an empty binding if there wasn't one.  */\n \n@@ -1281,6 +1297,173 @@ matching_fn_p (tree one, tree two)\n   return true;\n }\n \n+/* Push DECL into nonclass LEVEL BINDING.  OLD is the current\n+   binding value (possibly with anticipated builtins stripped).\n+   Diagnose conflicts and return updated decl.  */\n+\n+static tree\n+update_binding (cp_binding_level *level, cxx_binding *binding,\n+\t\ttree old, tree decl, bool is_friend)\n+{\n+  tree to_val = decl;\n+  tree to_type = NULL_TREE;\n+\n+  gcc_assert (level->kind != sk_class);\n+  if (old == error_mark_node)\n+    old = NULL_TREE;\n+\n+  if (old && TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n+    {\n+      /* Slide the tdef out of the way.  We'll undo this below, if\n+\t we're pushing a matching tdef.  */\n+      to_type = old;\n+      old = NULL_TREE;\n+    }\n+\n+  if (DECL_DECLARES_FUNCTION_P (decl))\n+    {\n+      if (!old)\n+\t;\n+      else if (OVL_P (old))\n+\t{\n+\t  for (ovl_iterator iter (old); iter; ++iter)\n+\t    {\n+\t      tree fn = *iter;\n+\n+\t      if (iter.using_p () && matching_fn_p (fn, decl))\n+\t\t{\n+\t\t  /* If a function declaration in namespace scope or\n+\t\t     block scope has the same name and the same\n+\t\t     parameter-type- list (8.3.5) as a function\n+\t\t     introduced by a using-declaration, and the\n+\t\t     declarations do not declare the same function,\n+\t\t     the program is ill-formed.  [namespace.udecl]/14 */\n+\t\t  if (tree match = duplicate_decls (decl, fn, is_friend))\n+\t\t    return match;\n+\t\t  else\n+\t\t    /* FIXME: To preserve existing error behavior, we\n+\t\t       still push the decl.  This might change.  */\n+\t\t    diagnose_name_conflict (decl, fn);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\tgoto conflict;\n+\n+      to_val = ovl_insert (decl, old);\n+    }\n+  else if (to_type && TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      /* We thought we wanted to slide an artificial typedef out of\n+\t the way, to make way for another typedef.  That's not always\n+\t what we want to do.  */\n+      if (!DECL_ARTIFICIAL (decl))\n+\t; /* Slide.  */\n+      else if (same_type_p (TREE_TYPE (to_type), TREE_TYPE (decl)))\n+\t/* Two artificial decls to same type.  Do nothing.  */\n+\treturn to_type;\n+      else\n+\tgoto conflict;\n+    }\n+  else if (!old)\n+    ;\n+  else if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n+    {\n+      /* Slide DECL into the type slot.  */\n+      to_type = decl;\n+      to_val = old;\n+    }\n+  else if (TREE_CODE (old) != TREE_CODE (decl))\n+    /* Different kinds of decls conflict.  */\n+    goto conflict;\n+  else if (TREE_CODE (old) == TYPE_DECL)\n+    {\n+      if (DECL_ARTIFICIAL (decl))\n+\t{\n+\t  /* Slide DECL into the type slot instead.  */\n+\t  to_type = decl;\n+\t  to_val = old;\n+\t}\n+      else if (same_type_p (TREE_TYPE (old), TREE_TYPE (decl)))\n+\t/* Two type decls to the same type.  Do nothing.  */\n+\treturn old;\n+      else\n+\tgoto conflict;\n+    }\n+  else if (TREE_CODE (old) == NAMESPACE_DECL)\n+    {\n+      if (DECL_NAMESPACE_ALIAS (old) && DECL_NAMESPACE_ALIAS (decl)\n+\t  && ORIGINAL_NAMESPACE (old) == ORIGINAL_NAMESPACE (decl))\n+\t/* In a declarative region, a namespace-alias-definition can be\n+\t   used to redefine a namespace-alias declared in that declarative\n+\t   region to refer only to the namespace to which it already\n+\t   refers.  [namespace.alias] */\n+\treturn old;\n+      else\n+\tgoto conflict;\n+    }\n+  else if (TREE_CODE (old) == VAR_DECL)\n+    {\n+      /* There can be two block-scope declarations of the same\n+\t variable, so long as they are `extern' declarations.  */\n+      if (!DECL_EXTERNAL (old) || !DECL_EXTERNAL (decl))\n+\tgoto conflict;\n+      else if (tree match = duplicate_decls (decl, old, false))\n+\treturn match;\n+      else\n+\tgoto conflict;\n+    }\n+  else\n+    {\n+    conflict:\n+      diagnose_name_conflict (decl, old);\n+      to_val = NULL_TREE;\n+    }\n+\n+  if (to_val)\n+    {\n+      if (level->kind != sk_namespace\n+\t  && !to_type && binding->value && OVL_P (to_val))\n+\tupdate_local_overload (binding, to_val);\n+      else\n+\t{\n+\t  tree to_add = to_val;\n+      \n+\t  if (level->kind == sk_namespace)\n+\t    to_add = decl;\n+\t  else if (to_type == decl)\n+\t    to_add = decl;\n+\t  else if (TREE_CODE (to_add) == OVERLOAD)\n+\t    to_add = build_tree_list (NULL_TREE, to_add);\n+\n+\t  add_decl_to_level (level, to_add);\n+\t}\n+\n+      if (to_type == binding->type)\n+\tto_type = NULL_TREE;\n+\n+      if (to_type)\n+\t{\n+\t  gcc_checking_assert (TREE_CODE (to_type) == TYPE_DECL\n+\t\t\t       && DECL_ARTIFICIAL (to_type));\n+\n+\t  tree type = TREE_TYPE (to_type);\n+\t  if (to_type != decl\n+\t      && MAYBE_CLASS_TYPE_P (type) && warn_shadow\n+\t      && (!DECL_IN_SYSTEM_HEADER (decl)\n+\t\t  || !DECL_IN_SYSTEM_HEADER (to_type)))\n+\t    warning (OPT_Wshadow, \"%q#D hides constructor for %q#T\",\n+\t\t     decl, type);\n+\t}\n+\n+      if (to_type)\n+\tbinding->type = to_type;\n+      binding->value = to_val;\n+    }\n+\n+  return decl;\n+}\n+\n /* Map of identifiers to extern C functions (or LISTS thereof).  */\n \n static GTY(()) hash_map<lang_identifier *, tree> *extern_c_fns;\n@@ -1690,338 +1873,146 @@ set_local_extern_decl_linkage (tree decl, bool shadowed)\n     }\n }\n \n-/* Record a decl-node X as belonging to the current lexical scope.\n-   Check for errors (such as an incompatible declaration for the same\n-   name already seen in the same scope).  IS_FRIEND is true if X is\n+/* Record DECL as belonging to the current lexical scope.  Check for\n+   errors (such as an incompatible declaration for the same name\n+   already seen in the same scope).  IS_FRIEND is true if DECL is\n    declared as a friend.\n \n-   Returns either X or an old decl for the same name.\n-   If an old decl is returned, it may have been smashed\n-   to agree with what X says.  */\n+   Returns either DECL or an old decl for the same name.  If an old\n+   decl is returned, it may have been smashed to agree with what DECL\n+   says.  */\n \n static tree\n-pushdecl_maybe_friend_1 (tree x, bool is_friend)\n+do_pushdecl (tree decl, bool is_friend)\n {\n-  tree t;\n-  tree name;\n-  int need_new_binding;\n-\n-  if (x == error_mark_node)\n+  if (decl == error_mark_node)\n     return error_mark_node;\n \n-  need_new_binding = 1;\n+  if (!DECL_TEMPLATE_PARM_P (decl) && current_function_decl)\n+    set_decl_context_in_fn (current_function_decl, decl);\n \n-  if (!DECL_TEMPLATE_PARM_P (x) && current_function_decl)\n-    set_decl_context_in_fn (current_function_decl, x);\n+  /* The binding level we will be pushing into.  During local class\n+     pushing, we want to push to the containing scope.  */\n+  cp_binding_level *level = current_binding_level;\n+  while (level->kind == sk_class)\n+    level = level->level_chain;\n \n-  name = DECL_NAME (x);\n-  if (name)\n+  if (tree name = DECL_NAME (decl))\n     {\n-      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-\tname = TREE_OPERAND (name, 0);\n+      cxx_binding *binding = NULL;\n+      tree ns = NULL_TREE; /* Searched namespace.  */\n+      tree old = NULL_TREE;\n \n-      /* In case this decl was explicitly namespace-qualified, look it\n-\t up in its namespace context.  */\n-      if (DECL_NAMESPACE_SCOPE_P (x) && namespace_bindings_p ())\n-\tt = get_namespace_binding (CP_DECL_CONTEXT (x), name);\n-      else\n-\tt = lookup_name_innermost_nonclass_level (name);\n-\n-      if (current_function_decl && VAR_OR_FUNCTION_DECL_P (x)\n-\t  && DECL_EXTERNAL (x))\n-\tset_local_extern_decl_linkage (x, t != NULL_TREE);\n-\n-      /* If we are declaring a function, and the result of name-lookup\n-\t was an OVERLOAD, look for an overloaded instance that is\n-\t actually the same as the function we are declaring.  (If\n-\t there is one, we have to merge our declaration with the\n-\t previous declaration.)  */\n-      if (t && TREE_CODE (t) == OVERLOAD)\n+      if (level->kind == sk_namespace)\n \t{\n-\t  tree match;\n-\n-\t  if (TREE_CODE (x) == FUNCTION_DECL)\n-\t    for (match = t; match; match = OVL_NEXT (match))\n-\t      {\n-\t\tif (decls_match (OVL_CURRENT (match), x))\n-\t\t  break;\n-\t      }\n-\t  else\n-\t    /* Just choose one.  */\n-\t    match = t;\n-\n-\t  if (match)\n-\t    t = OVL_CURRENT (match);\n-\t  else\n-\t    t = NULL_TREE;\n+\t  /* We look in the decl's namespace for an existing\n+\t     declaration, even though we push into the current\n+\t     namespace.  */\n+\t  ns = (DECL_NAMESPACE_SCOPE_P (decl)\n+\t\t? CP_DECL_CONTEXT (decl) : current_namespace);\n+\t  /* Create the binding, if this is current namespace, because\n+\t     that's where we'll be pushing anyway.  */\n+\t  binding = find_namespace_binding (ns, name, ns == current_namespace);\n \t}\n+      else\n+\tbinding = find_local_binding (level, name);\n \n-      if (t && t != error_mark_node)\n-\t{\n-\t  if (TREE_CODE (t) == PARM_DECL)\n-\t    {\n-\t      /* Check for duplicate params.  */\n-\t      tree d = duplicate_decls (x, t, is_friend);\n-\t      if (d)\n-\t\treturn d;\n-\t    }\n-\t  else if ((DECL_EXTERN_C_FUNCTION_P (x)\n-\t\t    || DECL_FUNCTION_TEMPLATE_P (x))\n-\t\t   && is_overloaded_fn (t))\n-\t    /* Don't do anything just yet.  */;\n-\t  else if (t == wchar_decl_node)\n-\t    {\n-\t      if (! DECL_IN_SYSTEM_HEADER (x))\n-\t\tpedwarn (input_location, OPT_Wpedantic, \"redeclaration of %<wchar_t%> as %qT\",\n-\t\t\t TREE_TYPE (x));\n-\t      \n-\t      /* Throw away the redeclaration.  */\n-\t      return t;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree olddecl = duplicate_decls (x, t, is_friend);\n-\n-\t      /* If the redeclaration failed, we can stop at this\n-\t\t point.  */\n-\t      if (olddecl == error_mark_node)\n-\t\treturn error_mark_node;\n-\n-\t      if (olddecl)\n-\t\t{\n-\t\t  if (TREE_CODE (t) == TYPE_DECL)\n-\t\t    SET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n+      if (binding)\n+\told = binding->value;\n \n-\t\t  return t;\n-\t\t}\n-\t      else if (DECL_MAIN_P (x) && TREE_CODE (t) == FUNCTION_DECL)\n-\t\t{\n-\t\t  /* A redeclaration of main, but not a duplicate of the\n-\t\t     previous one.\n+      if (current_function_decl && VAR_OR_FUNCTION_DECL_P (decl)\n+\t  && DECL_EXTERNAL (decl))\n+\tset_local_extern_decl_linkage (decl, old != NULL_TREE);\n \n-\t\t     [basic.start.main]\n+      if (old == error_mark_node)\n+\told = NULL_TREE;\n \n-\t\t     This function shall not be overloaded.  */\n-\t\t  error (\"invalid redeclaration of %q+D\", t);\n-\t\t  error (\"as %qD\", x);\n-\t\t  /* We don't try to push this declaration since that\n-\t\t     causes a crash.  */\n-\t\t  return x;\n-\t\t}\n-\t    }\n-\t}\n+      for (ovl_iterator iter (old); iter; ++iter)\n+\tif (iter.using_p ())\n+\t  ; /* Ignore using decls here.  */\n+\telse if (tree match = duplicate_decls (decl, *iter, is_friend))\n+\t  return match;\n \n-      check_template_shadow (x);\n+      /* We are pushing a new decl.  */\n \n-      /* If this is a function conjured up by the back end, massage it\n-\t so it looks friendly.  */\n-      if (DECL_NON_THUNK_FUNCTION_P (x) && ! DECL_LANG_SPECIFIC (x))\n-\t{\n-\t  retrofit_lang_decl (x);\n-\t  SET_DECL_LANGUAGE (x, lang_c);\n-\t}\n+      /* Skip a hidden builtin we failed to match already.  */\n+      if (old && TREE_CODE (old) == FUNCTION_DECL\n+\t  && DECL_ANTICIPATED (old)\n+\t  && !DECL_HIDDEN_FRIEND_P (old))\n+\told = NULL_TREE;\n \n-      t = x;\n-      if (DECL_NON_THUNK_FUNCTION_P (x) && ! DECL_FUNCTION_MEMBER_P (x))\n-\t{\n-\t  t = push_overloaded_decl (x, PUSH_LOCAL, is_friend);\n-\t  if (!namespace_bindings_p ())\n-\t    /* We do not need to create a binding for this name;\n-\t       push_overloaded_decl will have already done so if\n-\t       necessary.  */\n-\t    need_new_binding = 0;\n-\t}\n-      else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_NAMESPACE_SCOPE_P (x))\n-\t{\n-\t  t = push_overloaded_decl (x, PUSH_GLOBAL, is_friend);\n-\t  if (t == x)\n-\t    add_decl_to_level (NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)), x);\n-\t}\n+      check_template_shadow (decl);\n \n-      if (DECL_DECLARES_FUNCTION_P (t))\n+      if (DECL_DECLARES_FUNCTION_P (decl))\n \t{\n-\t  check_default_args (t);\n+\t  check_default_args (decl);\n \n-\t  if (is_friend && t == x && !flag_friend_injection)\n+\t  if (is_friend)\n \t    {\n-\t      /* This is a new friend declaration of a function or a\n-\t\t function template, so hide it from ordinary function\n-\t\t lookup.  */\n-\t      DECL_ANTICIPATED (t) = 1;\n-\t      DECL_HIDDEN_FRIEND_P (t) = 1;\n+\t      if (level->kind != sk_namespace)\n+\t\t/* In a local class, a friend function declaration must\n+\t\t   find a matching decl in the innermost non-class scope.\n+\t\t   [class.friend/11] */\n+\t\terror (\"friend declaration %qD in local class without \"\n+\t\t       \"prior local declaration\", decl);\n+\t      else if (!flag_friend_injection)\n+\t\t/* Hide it from ordinary lookup.  */\n+\t\tDECL_ANTICIPATED (decl) = DECL_HIDDEN_FRIEND_P (decl) = true;\n \t    }\n \t}\n \n-      if (t != x || DECL_FUNCTION_TEMPLATE_P (t))\n-\treturn t;\n-\n-      /* If declaring a type as a typedef, copy the type (unless we're\n-\t at line 0), and install this TYPE_DECL as the new type's typedef\n-\t name.  See the extensive comment of set_underlying_type ().  */\n-      if (TREE_CODE (x) == TYPE_DECL)\n+      if (level->kind != sk_namespace)\n \t{\n-\t  tree type = TREE_TYPE (x);\n-\n-\t  if (DECL_IS_BUILTIN (x)\n-\t      || (TREE_TYPE (x) != error_mark_node\n-\t\t  && TYPE_NAME (type) != x\n-\t\t  /* We don't want to copy the type when all we're\n-\t\t     doing is making a TYPE_DECL for the purposes of\n-\t\t     inlining.  */\n-\t\t  && (!TYPE_NAME (type)\n-\t\t      || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x))))\n-\t    set_underlying_type (x);\n-\n-\t  if (type != error_mark_node\n-\t      && TYPE_IDENTIFIER (type))\n-\t    set_identifier_type_value (DECL_NAME (x), x);\n-\n-\t  /* If this is a locally defined typedef in a function that\n-\t     is not a template instantation, record it to implement\n-\t     -Wunused-local-typedefs.  */\n-\t  if (!instantiating_current_function_p ())\n-\t    record_locally_defined_typedef (x);\n-\t}\n-\n-      /* Multiple external decls of the same identifier ought to match.\n+\t  check_local_shadow (decl);\n \n-\t We get warnings about inline functions where they are defined.\n-\t We get warnings about other functions from push_overloaded_decl.\n+\t  if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\t    /* A local namespace alias.  */\n+\t    set_identifier_type_value (name, NULL_TREE);\n \n-\t Avoid duplicate warnings where they are used.  */\n-      if (TREE_PUBLIC (x) && TREE_CODE (x) != FUNCTION_DECL)\n-\t{\n-\t  tree decl;\n-\n-\t  decl = get_namespace_binding (current_namespace, name);\n-\t  if (decl && TREE_CODE (decl) == OVERLOAD)\n-\t    decl = OVL_FUNCTION (decl);\n-\n-\t  if (decl && decl != error_mark_node\n-\t      && (DECL_EXTERNAL (decl) || TREE_PUBLIC (decl))\n-\t      /* If different sort of thing, we already gave an error.  */\n-\t      && TREE_CODE (decl) == TREE_CODE (x)\n-\t      && !comptypes (TREE_TYPE (x), TREE_TYPE (decl),\n-\t\t\t     COMPARE_REDECLARATION))\n-\t    {\n-\t      if (permerror (input_location, \"type mismatch with previous \"\n-\t\t\t     \"external decl of %q#D\", x))\n-\t\tinform (DECL_SOURCE_LOCATION (decl),\n-\t\t\t\"previous external decl of %q#D\", decl);\n-\t    }\n+\t  if (!binding)\n+\t    binding = create_local_binding (level, name);\n \t}\n-\n-      /* This name is new in its binding level.\n-\t Install the new declaration and return it.  */\n-      if (namespace_bindings_p ())\n+      else if (!binding)\n \t{\n-\t  /* Install a global value.  */\n-\n-\t  /* If the first global decl has external linkage,\n-\t     warn if we later see static one.  */\n-\t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n-\t    TREE_PUBLIC (name) = 1;\n-\n-\t  /* Bind the name for the entity.  */\n-\t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n-\t\t&& t != NULL_TREE)\n-\t      && (TREE_CODE (x) == TYPE_DECL\n-\t\t  || VAR_P (x)\n-\t\t  || TREE_CODE (x) == NAMESPACE_DECL\n-\t\t  || TREE_CODE (x) == CONST_DECL\n-\t\t  || TREE_CODE (x) == TEMPLATE_DECL))\n-\t    set_namespace_binding (current_namespace, name, x);\n-\n-\t  /* If new decl is `static' and an `extern' was seen previously,\n-\t     warn about it.  */\n-\t  if (x != NULL_TREE && t != NULL_TREE && decls_match (x, t))\n-\t    warn_extern_redeclared_static (x, t);\n+\t  ns = current_namespace;\n+\t  binding = find_namespace_binding (ns, name, true);\n \t}\n-      else\n-\t{\n-\t  /* Here to install a non-global value.  */\n-\t  tree oldglobal = get_namespace_binding (current_namespace, name);\n-\t  tree oldlocal = NULL_TREE;\n-\t  cxx_binding *oldbinding = outer_binding (name, NULL, true);\n-\t  if (oldbinding)\n-\t    oldlocal = oldbinding->value;\n-\n-\t  check_local_shadow (x);\n-\n-\t  if (need_new_binding)\n-\t    {\n-\t      push_local_binding (name, x, false);\n-\t      /* Because push_local_binding will hook X on to the\n-\t\t current_binding_level's name list, we don't want to\n-\t\t do that again below.  */\n-\t      need_new_binding = 0;\n-\t    }\n \n-\t  /* If this is a TYPE_DECL, push it into the type value slot.  */\n-\t  if (TREE_CODE (x) == TYPE_DECL)\n-\t    set_identifier_type_value (name, x);\n+      old = update_binding (level, binding, old, decl, is_friend);\n \n-\t  /* Clear out any TYPE_DECL shadowed by a namespace so that\n-\t     we won't think this is a type.  The C struct hack doesn't\n-\t     go through namespaces.  */\n-\t  if (TREE_CODE (x) == NAMESPACE_DECL)\n-\t    set_identifier_type_value (name, NULL_TREE);\n+      if (old != decl)\n+\t/* An existing decl matched, use it.  */\n+\tdecl = old;\n+      else if (TREE_CODE (decl) == TYPE_DECL)\n+\t{\n+\t  tree type = TREE_TYPE (decl);\n \n-\t  if (oldlocal)\n+\t  if (type != error_mark_node)\n \t    {\n-\t      tree d = oldlocal;\n-\n-\t      while (oldlocal\n-\t\t     && VAR_P (oldlocal)\n-\t\t     && DECL_DEAD_FOR_LOCAL (oldlocal))\n-\t\toldlocal = DECL_SHADOWED_FOR_VAR (oldlocal);\n-\n-\t      if (oldlocal == NULL_TREE)\n-\t\toldlocal\n-\t\t  = get_namespace_binding (current_namespace, DECL_NAME (d));\n-\t    }\n+\t      if (TYPE_NAME (type) != decl)\n+\t\tset_underlying_type (decl);\n \n-\t  /* If this is an extern function declaration, see if we\n-\t     have a global definition or declaration for the function.  */\n-\t  if (oldlocal == NULL_TREE\n-\t      && DECL_EXTERNAL (x)\n-\t      && oldglobal != NULL_TREE\n-\t      && TREE_CODE (x) == FUNCTION_DECL\n-\t      && TREE_CODE (oldglobal) == FUNCTION_DECL)\n-\t    {\n-\t      /* We have one.  Their types must agree.  */\n-\t      if (decls_match (x, oldglobal))\n-\t\t/* OK */;\n+\t      if (!ns)\n+\t\tset_identifier_type_value_with_scope (name, decl, level);\n \t      else\n-\t\t{\n-\t\t  warning (0, \"extern declaration of %q#D doesn%'t match\", x);\n-\t\t  warning_at (DECL_SOURCE_LOCATION (oldglobal), 0,\n-\t\t\t      \"global declaration %q#D\", oldglobal);\n-\t\t}\n+\t\tSET_IDENTIFIER_TYPE_VALUE (name, global_type_node);\n \t    }\n-\t  /* If we have a local external declaration,\n-\t     and no file-scope declaration has yet been seen,\n-\t     then if we later have a file-scope decl it must not be static.  */\n-\t  if (oldlocal == NULL_TREE\n-\t      && oldglobal == NULL_TREE\n-\t      && DECL_EXTERNAL (x)\n-\t      && TREE_PUBLIC (x))\n-\t    TREE_PUBLIC (name) = 1;\n-\t}\n \n-      if (VAR_P (x))\n-\tmaybe_register_incomplete_var (x);\n-      if (TREE_CODE (x) == FUNCTION_DECL && DECL_EXTERN_C_P (x))\n-\t/* We need to check and register the fn now.  */\n-\tcheck_extern_c_conflict (x);\n+\t  /* If this is a locally defined typedef in a function that\n+\t     is not a template instantation, record it to implement\n+\t     -Wunused-local-typedefs.  */\n+\t  if (!instantiating_current_function_p ())\n+\t    record_locally_defined_typedef (decl);\n+\t}\n+      else if (VAR_P (decl))\n+\tmaybe_register_incomplete_var (decl);\n+      else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_EXTERN_C_P (decl))\n+\tcheck_extern_c_conflict (decl);\n     }\n+  else\n+    add_decl_to_level (level, decl);\n \n-  if (need_new_binding)\n-    add_decl_to_level (DECL_NAMESPACE_SCOPE_P (x)\n-\t\t       ? NAMESPACE_LEVEL (CP_DECL_CONTEXT (x))\n-\t\t       : current_binding_level, x);\n-\n-  return x;\n+  return decl;\n }\n \n /* Record a decl-node X as belonging to the current lexical scope.\n@@ -2032,7 +2023,7 @@ pushdecl (tree x, bool is_friend)\n {\n   tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = pushdecl_maybe_friend_1 (x, is_friend);\n+  ret = do_pushdecl (x, is_friend);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n@@ -2924,151 +2915,6 @@ pushdecl_outermost_localscope (tree x)\n   return ret;\n }\n \n-/* DECL is a FUNCTION_DECL for a non-member function, which may have\n-   other definitions already in place.  We get around this by making\n-   the value of the identifier point to a list of all the things that\n-   want to be referenced by that name.  It is then up to the users of\n-   that name to decide what to do with that list.\n-\n-   DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its\n-   DECL_TEMPLATE_RESULT.  It is dealt with the same way.\n-\n-   FLAGS is a bitwise-or of the following values:\n-     PUSH_LOCAL: Bind DECL in the current scope, rather than at\n-\t\t namespace scope.\n-     PUSH_USING: DECL is being pushed as the result of a using\n-\t\t declaration.\n-\n-   IS_FRIEND is true if this is a friend declaration.\n-\n-   The value returned may be a previous declaration if we guessed wrong\n-   about what language DECL should belong to (C or C++).  Otherwise,\n-   it's always DECL (and never something that's not a _DECL).  */\n-\n-static tree\n-push_overloaded_decl_1 (tree decl, int flags, bool is_friend)\n-{\n-  tree name = DECL_NAME (decl);\n-  tree old;\n-  tree new_binding;\n-  int doing_global = (namespace_bindings_p () || !(flags & PUSH_LOCAL));\n-\n-  if (doing_global)\n-    old = get_namespace_binding (CP_DECL_CONTEXT (decl), name);\n-  else\n-    old = lookup_name_innermost_nonclass_level (name);\n-\n-  if (old)\n-    {\n-      if (TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n-\t{\n-\t  tree t = TREE_TYPE (old);\n-\t  if (MAYBE_CLASS_TYPE_P (t) && warn_shadow\n-\t      && (! DECL_IN_SYSTEM_HEADER (decl)\n-\t\t  || ! DECL_IN_SYSTEM_HEADER (old)))\n-\t    warning (OPT_Wshadow, \"%q#D hides constructor for %q#T\", decl, t);\n-\t  old = NULL_TREE;\n-\t}\n-      else if (is_overloaded_fn (old))\n-\t{\n-\t  tree tmp;\n-\n-\t  for (tmp = old; tmp; tmp = OVL_NEXT (tmp))\n-\t    {\n-\t      tree fn = OVL_CURRENT (tmp);\n-\t      tree dup;\n-\n-\t      if (TREE_CODE (tmp) == OVERLOAD && OVL_USING_P (tmp)\n-\t\t  && !(flags & PUSH_USING)\n-\t\t  && matching_fn_p (fn, decl)\n-\t\t  && ! decls_match (fn, decl))\n-\t\tdiagnose_name_conflict (decl, fn);\n-\n-\t      dup = duplicate_decls (decl, fn, is_friend);\n-\t      /* If DECL was a redeclaration of FN -- even an invalid\n-\t\t one -- pass that information along to our caller.  */\n-\t      if (dup == fn || dup == error_mark_node)\n-\t\treturn dup;\n-\t    }\n-\n-\t  /* We don't overload implicit built-ins.  duplicate_decls()\n-\t     may fail to merge the decls if the new decl is e.g. a\n-\t     template function.  */\n-\t  if (TREE_CODE (old) == FUNCTION_DECL\n-\t      && DECL_ANTICIPATED (old)\n-\t      && !DECL_HIDDEN_FRIEND_P (old))\n-\t    old = NULL;\n-\t}\n-      else if (old == error_mark_node)\n-\t/* Ignore the undefined symbol marker.  */\n-\told = NULL_TREE;\n-      else\n-\t{\n-\t  error (\"previous non-function declaration %q+#D\", old);\n-\t  error (\"conflicts with function declaration %q#D\", decl);\n-\t  return decl;\n-\t}\n-    }\n-\n-  new_binding = ovl_insert (decl, old, flags & PUSH_USING);\n-\n-  if (doing_global)\n-    set_namespace_binding (current_namespace, name, new_binding);\n-  else\n-    {\n-      /* We only create an OVERLOAD if there was a previous binding at\n-\t this level, or if decl is a template. In the former case, we\n-\t need to remove the old binding and replace it with the new\n-\t binding.  We must also run through the NAMES on the binding\n-\t level where the name was bound to update the chain.  */\n-\n-      if (TREE_CODE (new_binding) == OVERLOAD && old)\n-\t{\n-\t  tree *d;\n-\n-\t  for (d = &IDENTIFIER_BINDING (name)->scope->names;\n-\t       *d;\n-\t       d = &TREE_CHAIN (*d))\n-\t    if (*d == old\n-\t\t|| (TREE_CODE (*d) == TREE_LIST\n-\t\t    && TREE_VALUE (*d) == old))\n-\t      {\n-\t\tif (TREE_CODE (*d) == TREE_LIST)\n-\t\t  /* Just replace the old binding with the new.  */\n-\t\t  TREE_VALUE (*d) = new_binding;\n-\t\telse\n-\t\t  /* Build a TREE_LIST to wrap the OVERLOAD.  */\n-\t\t  *d = tree_cons (NULL_TREE, new_binding,\n-\t\t\t\t  TREE_CHAIN (*d));\n-\n-\t\t/* And update the cxx_binding node.  */\n-\t\tIDENTIFIER_BINDING (name)->value = new_binding;\n-\t\treturn decl;\n-\t      }\n-\n-\t  /* We should always find a previous binding in this case.  */\n-\t  gcc_unreachable ();\n-\t}\n-\n-      /* Install the new binding.  */\n-      push_local_binding (name, new_binding, flags);\n-    }\n-\n-  return decl;\n-}\n-\n-/* Wrapper for push_overloaded_decl_1.  */\n-\n-static tree\n-push_overloaded_decl (tree decl, int flags, bool is_friend)\n-{\n-  tree ret;\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = push_overloaded_decl_1 (decl, flags, is_friend);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n /* Check a non-member using-declaration. Return the name and scope\n    being used, and the USING_DECL, or NULL_TREE on failure.  */\n "}]}