{"sha": "782331f47d52ccae5b8b183d4c76eb6e3068fd5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgyMzMxZjQ3ZDUyY2NhZTViOGIxODNkNGM3NmViNmUzMDY4ZmQ1ZQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-04-30T21:43:12Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-04-30T21:43:12Z"}, "message": "Bunch of fixes.  See ChangeLog.\n\nFrom-SVN: r9552", "tree": {"sha": "639b23f0b758b04f72a80ba923b40b4a0f2d9fee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/639b23f0b758b04f72a80ba923b40b4a0f2d9fee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/782331f47d52ccae5b8b183d4c76eb6e3068fd5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782331f47d52ccae5b8b183d4c76eb6e3068fd5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/782331f47d52ccae5b8b183d4c76eb6e3068fd5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782331f47d52ccae5b8b183d4c76eb6e3068fd5e/comments", "author": null, "committer": null, "parents": [{"sha": "7e2eb697791947145a2b1097f6a638bcc340b6e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2eb697791947145a2b1097f6a638bcc340b6e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e2eb697791947145a2b1097f6a638bcc340b6e5"}], "stats": {"total": 273, "additions": 181, "deletions": 92}, "files": [{"sha": "f25925ed788a62d1cae12993b91beec523ef9966", "filename": "gcc/cpplib.c", "status": "modified", "additions": 181, "deletions": 92, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/782331f47d52ccae5b8b183d4c76eb6e3068fd5e/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/782331f47d52ccae5b8b183d4c76eb6e3068fd5e/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=782331f47d52ccae5b8b183d4c76eb6e3068fd5e", "patch": "@@ -70,7 +70,6 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n #include <stdio.h>\n #include <signal.h>\n #ifdef __STDC__\n-#include <string.h>\n #include <stdlib.h>\n #endif\n \n@@ -903,6 +902,11 @@ file_cleanup (pbuf, pfile)\n      cpp_buffer *pbuf;\n      cpp_reader *pfile;\n {\n+  if (pbuf->buf)\n+    {\n+      free (pbuf->buf);\n+      pbuf->buf = 0;\n+    }\n   return 0;\n }\n \n@@ -1035,6 +1039,9 @@ cpp_skip_hspace (pfile)\n       else if (c == '\\\\' && PEEKN(1) == '\\n') {\n \tFORWARD(2);\n       }\n+      else if (c == '@' && CPP_BUFFER (pfile)->has_escapes\n+\t       && is_hor_space[PEEKN(1)])\n+\tFORWARD(2);\n       else return;\n     }\n }\n@@ -1276,18 +1283,18 @@ struct arglist {\n    MACRONAME is the macro name itself (so we can avoid recursive expansion)\n    and NAMELEN is its length in characters.\n    \n-Note that comments and backslash-newlines have already been deleted\n-from the argument.  */\n+   Note that comments, backslash-newlines, and leading white space\n+   have already been deleted from the argument.  */\n \n static DEFINITION *\n-collect_expansion (pfile, buf, end, nargs, arglist)\n+collect_expansion (pfile, buf, limit, nargs, arglist)\n      cpp_reader *pfile;\n-     U_CHAR *buf, *end;\n+     U_CHAR *buf, *limit;\n      int nargs;\n      struct arglist *arglist;\n {\n   DEFINITION *defn;\n-  register U_CHAR *p, *limit, *lastp, *exp_p;\n+  register U_CHAR *p, *lastp, *exp_p;\n   struct reflist *endpat = NULL;\n   /* Pointer to first nonspace after last ## seen.  */\n   U_CHAR *concat = 0;\n@@ -1301,24 +1308,24 @@ collect_expansion (pfile, buf, end, nargs, arglist)\n      thru the arg list on every potential symbol.  Profiling might say\n      that something smarter should happen. */\n \n-  if (end < buf)\n+  if (limit < buf)\n     abort ();\n \n   /* Find the beginning of the trailing whitespace.  */\n-  /* Find end of leading whitespace.  */\n-  limit = end;\n   p = buf;\n   while (p < limit && is_space[limit[-1]]) limit--;\n-  while (p < limit && is_space[*p]) p++;\n \n   /* Allocate space for the text in the macro definition.\n      Leading and trailing whitespace chars need 2 bytes each.\n      Each other input char may or may not need 1 byte,\n-     so this is an upper bound.\n-     The extra 2 are for invented trailing newline-marker and final null.  */\n+     so this is an upper bound.  The extra 5 are for invented\n+     leading and trailing newline-marker and final null.  */\n   maxsize = (sizeof (DEFINITION)\n-\t     + 2 * (end - limit) + 2 * (p - buf)\n-\t     + (limit - p) + 3);\n+\t     + (limit - p) + 5);\n+  /* Occurrences of '@' get doubled, so allocate extra space for them. */\n+  while (p < limit)\n+    if (*p++ == '@')\n+      maxsize++;\n   defn = (DEFINITION *) xcalloc (1, maxsize);\n \n   defn->nargs = nargs;\n@@ -1327,7 +1334,9 @@ collect_expansion (pfile, buf, end, nargs, arglist)\n \n   p = buf;\n \n-  /* Add one initial space (often removed by macroexpand). */\n+  /* Add one initial space escape-marker to prevent accidental\n+     token-pasting (often removed by macroexpand). */\n+  *exp_p++ = '@';\n   *exp_p++ = ' ';\n \n   if (limit - p >= 2 && p[0] == '#' && p[1] == '#') {\n@@ -1353,16 +1362,8 @@ collect_expansion (pfile, buf, end, nargs, arglist)\n           expected_delimiter = c;\n \tbreak;\n \n-\t/* Special hack: if a \\# is written in the #define\n-\t   include a # in the definition.  This is useless for C code\n-\t   but useful for preprocessing other things.  */\n-\n       case '\\\\':\n-\t/* \\# quotes a # even outside of strings.  */\n-\tif (p < limit && *p == '#' && !expected_delimiter) {\n-\t  exp_p--;\n-\t  *exp_p++ = *p++;\n-\t} else if (p < limit && expected_delimiter) {\n+\tif (p < limit && expected_delimiter) {\n \t  /* In a string, backslash goes through\n \t     and makes next char ordinary.  */\n \t  *exp_p++ = *p++;\n@@ -1523,16 +1524,14 @@ collect_expansion (pfile, buf, end, nargs, arglist)\n     }\n   }\n \n-  if (limit < end) {\n-    while (limit < end && is_space[*limit]) {\n-      *exp_p++ = *limit++;\n+  if (!CPP_TRADITIONAL (pfile) && expected_delimiter == 0)\n+    {\n+      /* If ANSI, put in a \"@ \" marker to prevent token pasting.\n+         But not if \"inside a string\" (which in ANSI mode\n+         happens only for -D option).  */\n+      *exp_p++ = '@';\n+      *exp_p++ = ' ';\n     }\n-  } else if (!CPP_TRADITIONAL (pfile) && expected_delimiter == 0) {\n-    /* There is no trailing whitespace, so invent some in ANSI mode.\n-       But not if \"inside a string\" (which in ANSI mode\n-       happens only for -D option).  */\n-    *exp_p++ = ' ';\n-  }\n \n   *exp_p = '\\0';\n \n@@ -1671,8 +1670,7 @@ create_definition (buf, limit, pfile, predefinition)\n     }\n \n     ++bp;\t\t\t/* skip paren */\n-    /* Skip exactly one space or tab if any.  */\n-    if (bp < limit && (*bp == ' ' || *bp == '\\t')) ++bp;\n+    SKIP_WHITE_SPACE (bp);\n     /* now everything from bp before limit is the definition. */\n     defn = collect_expansion (pfile, bp, limit, argno, arg_ptrs);\n     defn->rest_args = rest_args;\n@@ -1944,7 +1942,6 @@ struct argdata {\n   int raw_length, expand_length;\n   int stringified_length;\n   char newlines;\n-  char comments;\n   char use_count;\n };\n \n@@ -2016,20 +2013,15 @@ cpp_scan_buffer (pfile)\n }\n \n /*\n- * Rescan a string into pfile's buffer.\n+ * Rescan a string (which may have escape marks) into pfile's buffer.\n  * Place the result in pfile->token_buffer.\n  *\n  * The input is copied before it is scanned, so it is safe to pass\n  * it something from the token_buffer that will get overwritten\n  * (because it follows CPP_WRITTEN).  This is used by do_include.\n- *\n- * OUTPUT_MARKS nonzero means keep Newline markers found in the input\n- * and insert such markers when appropriate.  See `rescan' for details.\n- * OUTPUT_MARKS is 1 for macroexpanding a macro argument separately\n- * before substitution; it is 0 for other uses.\n  */\n \n-void\n+static void\n cpp_expand_to_buffer (pfile, buf, length)\n      cpp_reader *pfile;\n      U_CHAR *buf;\n@@ -2059,6 +2051,7 @@ cpp_expand_to_buffer (pfile, buf, length)\n   buf1[length] = 0;\n \n   ip = cpp_push_buffer (pfile, buf1, length);\n+  ip->has_escapes = 1;\n #if 0\n   ip->lineno = obuf.lineno = 1;\n #endif\n@@ -2249,7 +2242,7 @@ output_line_command (pfile, conditional, file_change)\n }\n \f\n /*\n- * Parse a macro argument and store the info on it into *ARGPTR.\n+ * Parse a macro argument and append the info on PFILE's token_buffer.\n  * REST_ARGS means to absorb the rest of the args.\n  * Return nonzero to indicate a syntax error.\n  */\n@@ -2734,6 +2727,8 @@ macroexpand (pfile, hp)\n     dump_single_macro (hp, pcp_outfile);\n #endif\n \n+  pfile->output_escapes++;\n+  \n   nargs = defn->nargs;\n \n   if (nargs >= 0)\n@@ -2886,6 +2881,13 @@ macroexpand (pfile, hp)\n \t\t\t     one space except within an string or char token.*/\n \t\t\t  if (is_space[c])\n \t\t\t    {\n+\t\t\t      if (CPP_WRITTEN (pfile) > arg->stringified\n+\t\t\t\t  && (CPP_PWRITTEN (pfile))[-1] == '@')\n+\t\t\t\t{\n+\t\t\t\t  /* \"@ \" escape markers are removed */\n+\t\t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n+\t\t\t\t  continue;\n+\t\t\t\t}\n \t\t\t      if (need_space == 0)\n \t\t\t\tneed_space = 1;\n \t\t\t      continue;\n@@ -2941,12 +2943,10 @@ macroexpand (pfile, hp)\n \t      if (args[ap->argno].expand_length < 0)\n \t\t{\n \t\t  args[ap->argno].expanded = CPP_WRITTEN (pfile);\n-\t\t  pfile->output_escapes++;\n \t\t  cpp_expand_to_buffer (pfile,\n \t\t\t\t\tARG_BASE + args[ap->argno].raw,\n \t\t\t\t\targs[ap->argno].raw_length);\n \n-\t\t  pfile->output_escapes--;\n \t\t  args[ap->argno].expand_length\n \t\t    = CPP_WRITTEN (pfile) - args[ap->argno].expanded;\n \t\t}\n@@ -3040,15 +3040,21 @@ macroexpand (pfile, hp)\n \t      if (!ap->raw_before && totlen > 0 && arg->expand_length\n \t\t  && !CPP_TRADITIONAL(pfile)\n \t\t  && unsafe_chars (xbuf[totlen-1], expanded[0]))\n-\t\txbuf[totlen++] = ' ';\n+\t\t{\n+\t\t  xbuf[totlen++] = '@';\n+\t\t  xbuf[totlen++] = ' ';\n+\t\t}\n \n \t      bcopy (expanded, xbuf + totlen, arg->expand_length);\n \t      totlen += arg->expand_length;\n \n \t      if (!ap->raw_after && totlen > 0 && offset < defn->length\n \t\t  && !CPP_TRADITIONAL(pfile)\n \t\t  && unsafe_chars (xbuf[totlen-1], exp[offset]))\n-\t\txbuf[totlen++] = ' ';\n+\t\t{\n+\t\t  xbuf[totlen++] = '@';\n+\t\t  xbuf[totlen++] = ' ';\n+\t\t}\n \n \t      /* If a macro argument with newlines is used multiple times,\n \t\t then only expand the newlines once.  This avoids creating\n@@ -3086,6 +3092,8 @@ macroexpand (pfile, hp)\n \n     }\n \n+  pfile->output_escapes--;\n+\n   /* Now put the expansion on the input stack\n      so our caller will commence reading from it.  */\n   push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n@@ -3113,7 +3121,7 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n   mbuf->cleanup = macro_cleanup;\n   mbuf->data = hp;\n \n-  /* The first char of the expansion should be a ' ' added by\n+  /* The first chars of the expansion should be a \"@ \" added by\n      collect_expansion.  This is to prevent accidental token-pasting\n      between the text preceding the macro invocation, and the macro\n      expansion text.\n@@ -3131,10 +3139,10 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n      Also, we don't need the extra space if the first char is '(',\n      or some other (less common) characters.  */\n \n-  if (xbuf[0] == ' '\n-      && (is_idchar[xbuf[1]] || xbuf[1] == '(' || xbuf[1] == '\\''\n-\t  || xbuf[1] == '\\\"'))\n-    mbuf->cur++;\n+  if (xbuf[0] == '@' && xbuf[1] == ' '\n+      && (is_idchar[xbuf[2]] || xbuf[2] == '(' || xbuf[2] == '\\''\n+\t  || xbuf[2] == '\\\"'))\n+    mbuf->cur += 2;\n }\n \f\n /* Like cpp_get_token, except that it does not read past end-of-line.\n@@ -3368,7 +3376,7 @@ do_include (pfile, keyword, unused1, unused2)\n     if (importing)\n       f = lookup_import (pfile, fname, NULL_PTR);\n     else\n-      f = open_include_file (fname, NULL_PTR);\n+      f = open_include_file (pfile, fname, NULL_PTR);\n     if (f == -2)\n       return 0;\t\t/* Already included this file */\n   } else {\n@@ -3413,7 +3421,7 @@ do_include (pfile, keyword, unused1, unused2)\n       if (importing)\n \tf = lookup_import (pfile, fname, searchptr);\n       else\n-\tf = open_include_file (fname, searchptr);\n+\tf = open_include_file (pfile, fname, searchptr);\n       if (f == -2)\n \treturn 0;\t\t\t/* Already included this file */\n #ifdef EACCES\n@@ -3453,7 +3461,7 @@ do_include (pfile, keyword, unused1, unused2)\n \n \t\t      if (searchptr->fname[0] == 0)\n \t\t\tcontinue;\n-\t\t      p = xmalloc (strlen (searchptr->fname)\n+\t\t      p = alloca (strlen (searchptr->fname)\n \t\t\t\t   + strlen (fname) + 2);\n \t\t      strcpy (p, searchptr->fname);\n \t\t      strcat (p, \"/\");\n@@ -3717,12 +3725,20 @@ static void\n delete_assertion (hp)\n      ASSERTION_HASHNODE *hp;\n {\n-\n+  struct tokenlist_list *tail;\n   if (hp->prev != NULL)\n     hp->prev->next = hp->next;\n   if (hp->next != NULL)\n     hp->next->prev = hp->prev;\n \n+  for (tail = hp->value; tail; )\n+    {\n+      struct tokenlist_list *next = tail->next;\n+      free_token_list (tail->tokens);\n+      free (tail);\n+      tail = next;\n+    }\n+\n   /* make sure that the bucket chain header that\n      the deleted guy was on points to the right thing afterwards. */\n   if (hp == *hp->bucket_hdr)\n@@ -4748,8 +4764,8 @@ cpp_get_token (pfile)\n \t      CPP_PUTC_Q (pfile, ' ');\n \t      return CPP_HSPACE;\n \t    }\n-\t  if (opts->for_lint) {\n #if 0\n+\t  if (opts->for_lint) {\n \t    U_CHAR *argbp;\n \t    int cmdlen, arglen;\n \t    char *lintcmd = get_lintcmd (ibp, limit, &argbp, &arglen, &cmdlen);\n@@ -4775,8 +4791,8 @@ cpp_get_token (pfile)\n \t      *(obp++) = ' ';\t/* just in case, if comments are copied thru */\n \t      *(obp++) = '/';\n \t    }\n-#endif\n \t  }\n+#endif\n \n \tcase '#':\n #if 0\n@@ -5004,6 +5020,14 @@ cpp_get_token (pfile)\n \t\t  parse_name (pfile, GETC ());\n \t\t  return CPP_NAME;\n \t\t}\n+\t      else if (is_space [c])\n+\t\t{\n+\t\t  CPP_RESERVE (pfile, 2);\n+\t\t  if (pfile->output_escapes)\n+\t\t    CPP_PUTC_Q (pfile, '@');\n+\t\t  CPP_PUTC_Q (pfile, c);\n+\t\t  return CPP_HSPACE;\n+\t\t}\n \t    }\n \t  if (pfile->output_escapes)\n \t    {\n@@ -5214,22 +5238,21 @@ cpp_get_token (pfile)\n \t\tCPP_SET_WRITTEN (pfile, before_name_written);\n \t      }\n \n-\t    /* An extra space is added to the end of a macro expansion\n+\t    /* An extra \"@ \" is added to the end of a macro expansion\n \t       to prevent accidental token pasting.  We prefer to avoid\n \t       unneeded extra spaces (for the sake of cpp-using tools like\n \t       imake).  Here we remove the space if it is safe to do so. */\n-\t    if (pfile->buffer->rlimit - pfile->buffer->cur >= 2\n+\t    if (pfile->buffer->rlimit - pfile->buffer->cur >= 3\n+\t\t&& pfile->buffer->rlimit[-2] == '@'\n \t\t&& pfile->buffer->rlimit[-1] == ' ')\n \t      {\n-\t\tint c1 = pfile->buffer->rlimit[-2];\n+\t\tint c1 = pfile->buffer->rlimit[-3];\n \t\tint c2 = CPP_BUF_PEEK (CPP_PREV_BUFFER (CPP_BUFFER (pfile)));\n \t\tif (c2 == EOF || ! unsafe_chars (c1, c2))\n-\t\t  pfile->buffer->rlimit--;\n+\t\t  pfile->buffer->rlimit -= 2;\n \t      }\n-\n-\t    goto get_next;\n \t  }\n-\t  return CPP_NAME;\n+\t  goto get_next;\n \n \tcase ' ':  case '\\t':  case '\\v':  case '\\r':\n \t  for (;;)\n@@ -5342,7 +5365,7 @@ import_hash (f)\n \n static int\n lookup_import (pfile, filename, searchptr)\n-cpp_reader *pfile;\n+     cpp_reader *pfile;\n      char *filename;\n      struct file_name_list *searchptr;\n {\n@@ -5363,7 +5386,7 @@ cpp_reader *pfile;\n     i = i->next;\n   }\n   /* Open it and try a match on inode/dev */\n-  fd = open_include_file (filename, searchptr);\n+  fd = open_include_file (pfile, filename, searchptr);\n   if (fd < 0)\n     return fd;\n   fstat (fd, &sb);\n@@ -5455,26 +5478,26 @@ read_filename_string (ch, f)\n   return alloc;\n }\n \n+/* This structure holds a linked list of file name maps, one per directory. */\n+struct file_name_map_list\n+{\n+  struct file_name_map_list *map_list_next;\n+  char *map_list_name;\n+  struct file_name_map *map_list_map;\n+};\n+\n /* Read the file name map file for DIRNAME.  */\n \n static struct file_name_map *\n-read_name_map (dirname)\n+read_name_map (pfile, dirname)\n+     cpp_reader *pfile;\n      char *dirname;\n {\n-  /* This structure holds a linked list of file name maps, one per\n-     directory.  */\n-  struct file_name_map_list\n-    {\n-      struct file_name_map_list *map_list_next;\n-      char *map_list_name;\n-      struct file_name_map *map_list_map;\n-    };\n-  static struct file_name_map_list *map_list;\n   register struct file_name_map_list *map_list_ptr;\n   char *name;\n   FILE *f;\n \n-  for (map_list_ptr = map_list; map_list_ptr;\n+  for (map_list_ptr = CPP_OPTIONS (pfile)->map_list; map_list_ptr;\n        map_list_ptr = map_list_ptr->map_list_next)\n     if (! strcmp (map_list_ptr->map_list_name, dirname))\n       return map_list_ptr->map_list_map;\n@@ -5535,8 +5558,8 @@ read_name_map (dirname)\n       fclose (f);\n     }\n   \n-  map_list_ptr->map_list_next = map_list;\n-  map_list = map_list_ptr;\n+  map_list_ptr->map_list_next = CPP_OPTIONS (pfile)->map_list;\n+  CPP_OPTIONS (pfile)->map_list = map_list_ptr;\n \n   return map_list_ptr->map_list_map;\n }  \n@@ -5547,7 +5570,8 @@ read_name_map (dirname)\n    read_name_map.  */\n \n static int\n-open_include_file (filename, searchptr)\n+open_include_file (pfile, filename, searchptr)\n+     cpp_reader *pfile;\n      char *filename;\n      struct file_name_list *searchptr;\n {\n@@ -5557,7 +5581,8 @@ open_include_file (filename, searchptr)\n \n   if (searchptr && ! searchptr->got_name_map)\n     {\n-      searchptr->name_map = read_name_map (searchptr->fname\n+      searchptr->name_map = read_name_map (pfile,\n+\t\t\t\t\t   searchptr->fname\n \t\t\t\t\t   ? searchptr->fname : \".\");\n       searchptr->got_name_map = 1;\n     }\n@@ -5606,7 +5631,7 @@ open_include_file (filename, searchptr)\n       dir[p - filename] = '\\0';\n       from = p + 1;\n     }\n-  for (map = read_name_map (dir); map; map = map->map_next)\n+  for (map = read_name_map (pfile, dir); map; map = map->map_next)\n     if (! strcmp (map->map_from, from))\n       return open (map->map_to, O_RDONLY, 0666);\n \n@@ -6783,6 +6808,74 @@ cpp_finish (pfile)\n \t}\n     }\n }\n+\n+/* Free resources used by PFILE. */\n+\n+void\n+cpp_cleanup (pfile)\n+     cpp_reader *pfile;\n+{\n+  int i;\n+  while ( CPP_BUFFER (pfile) != CPP_NULL_BUFFER (pfile))\n+    cpp_pop_buffer (pfile);\n+\n+  if (pfile->token_buffer)\n+    {\n+      free (pfile->token_buffer);\n+      pfile->token_buffer = NULL;\n+    }\n+\n+  if (pfile->deps_buffer)\n+    {\n+      free (pfile->deps_buffer);\n+      pfile->deps_buffer = NULL;\n+      pfile->deps_allocated_size = 0;\n+    }\n+\n+  while (pfile->if_stack)\n+    {\n+      IF_STACK_FRAME *temp = pfile->if_stack;\n+      pfile->if_stack = temp->next;\n+      free (temp);\n+    }\n+\n+  while (pfile->dont_repeat_files)\n+    {\n+      struct file_name_list *temp = pfile->dont_repeat_files;\n+      pfile->dont_repeat_files = temp->next;\n+      free (temp->fname);\n+      free (temp);\n+    }\n+\n+  while (pfile->all_include_files)\n+    {\n+      struct file_name_list *temp = pfile->all_include_files;\n+      pfile->all_include_files = temp->next;\n+      free (temp->fname);\n+      free (temp);\n+    }\n+\n+  for (i = IMPORT_HASH_SIZE; --i >= 0; )\n+    {\n+      register struct import_file *imp = pfile->import_hash_table[i];\n+      while (imp)\n+\t{\n+\t  struct import_file *next = imp->next;\n+\t  free (imp->name);\n+\t  free (imp);\n+\t  imp = next;\n+\t}\n+      pfile->import_hash_table[i] = 0;\n+    }\n+\n+  for (i = ASSERTION_HASHSIZE; --i >= 0; )\n+    {\n+      while (pfile->assertion_hashtab[i])\n+\tdelete_assertion (pfile->assertion_hashtab[i]);\n+    }\n+\n+  cpp_hash_cleanup (pfile);\n+}\n \f\n static int\n do_assert (pfile, keyword, buf, limit)\n@@ -6914,15 +7007,9 @@ do_unassert (pfile, keyword, buf, limit)\n \n     /* If no token list was specified, then eliminate this assertion\n        entirely.  */\n-    if (! tokens_specified) {\n-      struct tokenlist_list *next;\n-      for (tail = hp->value; tail; tail = next) {\n-\tnext = tail->next;\n-\tfree_token_list (tail->tokens);\n-\tfree (tail);\n-      }\n+    if (! tokens_specified)\n       delete_assertion (hp);\n-    } else {\n+    else {\n       /* If a list of tokens was given, then delete any matching list.  */\n \n       tail = hp->value;\n@@ -7528,4 +7615,6 @@ cpp_perror_with_name (pfile, name)\n  * Support for trigraphs.\n  *\n  * Support -dM flag (dump_all_macros).\n+ *\n+ * Support for_lint flag.\n  */"}]}