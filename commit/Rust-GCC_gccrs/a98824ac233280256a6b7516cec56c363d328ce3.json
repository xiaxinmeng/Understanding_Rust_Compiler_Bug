{"sha": "a98824ac233280256a6b7516cec56c363d328ce3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk4ODI0YWMyMzMyODAyNTZhNmI3NTE2Y2VjNTZjMzYzZDMyOGNlMw==", "commit": {"author": {"name": "Siddhesh Poyarekar", "email": "siddhesh@sourceware.org", "date": "2018-09-05T09:37:27Z"}, "committer": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gcc.gnu.org", "date": "2018-09-05T09:37:27Z"}, "message": "[aarch64] Avoid tag collisions for loads falkor\n\nThis is a rewrite of the tag collision avoidance patch that Kugan had\nwritten as a machine reorg pass back in February.\n\nThe falkor hardware prefetching system uses a combination of the\nsource, destination and offset to decide which prefetcher unit to\ntrain with the load.  This is great when loads in a loop are\nsequential but sub-optimal if there are unrelated loads in a loop that\ntag to the same prefetcher unit.\n\nThis pass attempts to rename the desination register of such colliding\nloads using routines available in regrename.c so that their tags do\nnot collide.  This shows some performance gains with mcf and xalancbmk\n(~5% each) and will be tweaked further.  The pass is placed near the\nfag end of the pass list so that subsequent passes don't inadvertantly\nend up undoing the renames.\n\n2018-07-02  Siddhesh Poyarekar  <siddhesh@sourceware.org>\n            Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n\n\t* config/aarch64/falkor-tag-collision-avoidance.c: New file.\n\t* config.gcc (extra_objs): Build it.\n\t* config/aarch64/t-aarch64 (falkor-tag-collision-avoidance.o):\n\tLikewise.\n\t* config/aarch64/aarch64-passes.def\n\t(pass_tag_collision_avoidance): New pass.\n\t* config/aarch64/aarch64.c (qdf24xx_tunings): Add\n\tAARCH64_EXTRA_TUNE_RENAME_LOAD_REGS to tuning_flags.\n\t(aarch64_classify_address): Remove static qualifier.\n\t(aarch64_address_info, aarch64_address_type): Move to...\n\t* config/aarch64/aarch64-protos.h: ... here.\n\t(make_pass_tag_collision_avoidance): New function.\n\t* config/aarch64/aarch64-tuning-flags.def (rename_load_regs):\n\tNew tuning flag.\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\nCo-Authored-By: Kugan Vivekanandarajah <kuganv@linaro.org>\n\nFrom-SVN: r264115", "tree": {"sha": "e0bc967c3951ffb158ba96325be0dccb7b7a02bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0bc967c3951ffb158ba96325be0dccb7b7a02bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a98824ac233280256a6b7516cec56c363d328ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a98824ac233280256a6b7516cec56c363d328ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a98824ac233280256a6b7516cec56c363d328ce3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a98824ac233280256a6b7516cec56c363d328ce3/comments", "author": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "41fbb3ec63cf38f10f3e8233b6388ee553578aa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41fbb3ec63cf38f10f3e8233b6388ee553578aa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41fbb3ec63cf38f10f3e8233b6388ee553578aa9"}], "stats": {"total": 1011, "additions": 965, "deletions": 46}, "files": [{"sha": "05fe124bf793e0c924b01710968d2078a0bf58fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a98824ac233280256a6b7516cec56c363d328ce3", "patch": "@@ -1,3 +1,21 @@\n+2018-09-05  Siddhesh Poyarekar  <siddhesh@sourceware.org>\n+\t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n+\n+\t* config/aarch64/falkor-tag-collision-avoidance.c: New file.\n+\t* config.gcc (extra_objs): Build it.\n+\t* config/aarch64/t-aarch64 (falkor-tag-collision-avoidance.o):\n+\tLikewise.\n+\t* config/aarch64/aarch64-passes.def\n+\t(pass_tag_collision_avoidance): New pass.\n+\t* config/aarch64/aarch64.c (qdf24xx_tunings): Add\n+\tAARCH64_EXTRA_TUNE_RENAME_LOAD_REGS to tuning_flags.\n+\t(aarch64_classify_address): Remove static qualifier.\n+\t(aarch64_address_info, aarch64_address_type): Move to...\n+\t* config/aarch64/aarch64-protos.h: ... here.\n+\t(make_pass_tag_collision_avoidance): New function.\n+\t* config/aarch64/aarch64-tuning-flags.def (rename_load_regs):\n+\tNew tuning flag.\n+\n 2018-09-05  Martin Liska  <mliska@suse.cz>\n \n \t* doc/gcov.texi: Update documentation of humar"}, {"sha": "6ad2ba4d1525e0e91ceb1a540d3846421dbbf3b9", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=a98824ac233280256a6b7516cec56c363d328ce3", "patch": "@@ -304,7 +304,7 @@ aarch64*-*-*)\n \textra_headers=\"arm_fp16.h arm_neon.h arm_acle.h\"\n \tc_target_objs=\"aarch64-c.o\"\n \tcxx_target_objs=\"aarch64-c.o\"\n-\textra_objs=\"aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o aarch64-speculation.o\"\n+\textra_objs=\"aarch64-builtins.o aarch-common.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.c\"\n \ttarget_has_targetm_common=yes\n \t;;"}, {"sha": "3982b6ea6290379e6ecac8046ebb27a14d2342f0", "filename": "gcc/config/aarch64/aarch64-passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-passes.def?ref=a98824ac233280256a6b7516cec56c363d328ce3", "patch": "@@ -20,3 +20,4 @@\n \n INSERT_PASS_AFTER (pass_regrename, 1, pass_fma_steering);\n INSERT_PASS_BEFORE (pass_reorder_blocks, 1, pass_track_speculation);\n+INSERT_PASS_AFTER (pass_machine_reorg, 1, pass_tag_collision_avoidance);"}, {"sha": "aae1db45ed69c14e306ccce056861a58d9acd834", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=a98824ac233280256a6b7516cec56c363d328ce3", "patch": "@@ -288,6 +288,49 @@ struct tune_params\n   const struct cpu_prefetch_tune *prefetch;\n };\n \n+/* Classifies an address.\n+\n+   ADDRESS_REG_IMM\n+       A simple base register plus immediate offset.\n+\n+   ADDRESS_REG_WB\n+       A base register indexed by immediate offset with writeback.\n+\n+   ADDRESS_REG_REG\n+       A base register indexed by (optionally scaled) register.\n+\n+   ADDRESS_REG_UXTW\n+       A base register indexed by (optionally scaled) zero-extended register.\n+\n+   ADDRESS_REG_SXTW\n+       A base register indexed by (optionally scaled) sign-extended register.\n+\n+   ADDRESS_LO_SUM\n+       A LO_SUM rtx with a base register and \"LO12\" symbol relocation.\n+\n+   ADDRESS_SYMBOLIC:\n+       A constant symbolic address, in pc-relative literal pool.  */\n+\n+enum aarch64_address_type {\n+  ADDRESS_REG_IMM,\n+  ADDRESS_REG_WB,\n+  ADDRESS_REG_REG,\n+  ADDRESS_REG_UXTW,\n+  ADDRESS_REG_SXTW,\n+  ADDRESS_LO_SUM,\n+  ADDRESS_SYMBOLIC\n+};\n+\n+/* Address information.  */\n+struct aarch64_address_info {\n+  enum aarch64_address_type type;\n+  rtx base;\n+  rtx offset;\n+  poly_int64 const_offset;\n+  int shift;\n+  enum aarch64_symbol_type symbol_type;\n+};\n+\n #define AARCH64_FUSION_PAIR(x, name) \\\n   AARCH64_FUSE_##name##_index, \n /* Supported fusion operations.  */\n@@ -561,6 +604,11 @@ void aarch64_swap_ldrstr_operands (rtx *, bool);\n extern void aarch64_asm_output_pool_epilogue (FILE *, const char *,\n \t\t\t\t\t      tree, HOST_WIDE_INT);\n \n+\n+extern bool aarch64_classify_address (struct aarch64_address_info *, rtx,\n+\t\t\t\t      machine_mode, bool,\n+\t\t\t\t      aarch64_addr_query_type = ADDR_QUERY_M);\n+\n /* Defined in common/config/aarch64-common.c.  */\n bool aarch64_handle_option (struct gcc_options *, struct gcc_options *,\n \t\t\t     const struct cl_decoded_option *, location_t);\n@@ -572,6 +620,7 @@ std::string aarch64_get_extension_string_for_isa_flags (unsigned long,\n \n rtl_opt_pass *make_pass_fma_steering (gcc::context *);\n rtl_opt_pass *make_pass_track_speculation (gcc::context *);\n+rtl_opt_pass *make_pass_tag_collision_avoidance (gcc::context *);\n \n poly_uint64 aarch64_regmode_natural_size (machine_mode);\n "}, {"sha": "88a2b25ab439af1deb47d5d42834f077c65bbdce", "filename": "gcc/config/aarch64/aarch64-tuning-flags.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Faarch64-tuning-flags.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Faarch64-tuning-flags.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-tuning-flags.def?ref=a98824ac233280256a6b7516cec56c363d328ce3", "patch": "@@ -44,4 +44,6 @@ AARCH64_EXTRA_TUNING_OPTION (\"cheap_shift_extend\", CHEAP_SHIFT_EXTEND)\n /* Disallow load/store pair instructions on Q-registers.  */\n AARCH64_EXTRA_TUNING_OPTION (\"no_ldp_stp_qregs\", NO_LDP_STP_QREGS)\n \n+AARCH64_EXTRA_TUNING_OPTION (\"rename_load_regs\", RENAME_LOAD_REGS)\n+\n #undef AARCH64_EXTRA_TUNING_OPTION"}, {"sha": "d088ef7ee0f256ad0d4f59d2735121de2dd67eba", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a98824ac233280256a6b7516cec56c363d328ce3", "patch": "@@ -78,48 +78,6 @@\n /* Defined for convenience.  */\n #define POINTER_BYTES (POINTER_SIZE / BITS_PER_UNIT)\n \n-/* Classifies an address.\n-\n-   ADDRESS_REG_IMM\n-       A simple base register plus immediate offset.\n-\n-   ADDRESS_REG_WB\n-       A base register indexed by immediate offset with writeback.\n-\n-   ADDRESS_REG_REG\n-       A base register indexed by (optionally scaled) register.\n-\n-   ADDRESS_REG_UXTW\n-       A base register indexed by (optionally scaled) zero-extended register.\n-\n-   ADDRESS_REG_SXTW\n-       A base register indexed by (optionally scaled) sign-extended register.\n-\n-   ADDRESS_LO_SUM\n-       A LO_SUM rtx with a base register and \"LO12\" symbol relocation.\n-\n-   ADDRESS_SYMBOLIC:\n-       A constant symbolic address, in pc-relative literal pool.  */\n-\n-enum aarch64_address_type {\n-  ADDRESS_REG_IMM,\n-  ADDRESS_REG_WB,\n-  ADDRESS_REG_REG,\n-  ADDRESS_REG_UXTW,\n-  ADDRESS_REG_SXTW,\n-  ADDRESS_LO_SUM,\n-  ADDRESS_SYMBOLIC\n-};\n-\n-struct aarch64_address_info {\n-  enum aarch64_address_type type;\n-  rtx base;\n-  rtx offset;\n-  poly_int64 const_offset;\n-  int shift;\n-  enum aarch64_symbol_type symbol_type;\n-};\n-\n /* Information about a legitimate vector immediate operand.  */\n struct simd_immediate_info\n {\n@@ -927,7 +885,7 @@ static const struct tune_params qdf24xx_tunings =\n   2,\t/* min_div_recip_mul_df.  */\n   0,\t/* max_case_values.  */\n   tune_params::AUTOPREFETCHER_WEAK,\t/* autoprefetcher_model.  */\n-  (AARCH64_EXTRA_TUNE_NONE),\t\t/* tune_flags.  */\n+  AARCH64_EXTRA_TUNE_RENAME_LOAD_REGS, /* tune_flags.  */\n   &qdf24xx_prefetch_tune\n };\n \n@@ -5671,10 +5629,10 @@ virt_or_elim_regno_p (unsigned regno)\n    If it is, fill in INFO appropriately.  STRICT_P is true if\n    REG_OK_STRICT is in effect.  */\n \n-static bool\n+bool\n aarch64_classify_address (struct aarch64_address_info *info,\n \t\t\t  rtx x, machine_mode mode, bool strict_p,\n-\t\t\t  aarch64_addr_query_type type = ADDR_QUERY_M)\n+\t\t\t  aarch64_addr_query_type type)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx op0, op1;"}, {"sha": "518954f143c0a434ff6d99f9429a95877d37f0cd", "filename": "gcc/config/aarch64/falkor-tag-collision-avoidance.c", "status": "added", "additions": 881, "deletions": 0, "changes": 881, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Ffalkor-tag-collision-avoidance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Ffalkor-tag-collision-avoidance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ffalkor-tag-collision-avoidance.c?ref=a98824ac233280256a6b7516cec56c363d328ce3", "patch": "@@ -0,0 +1,881 @@\n+/* Tag Collision Avoidance pass for Falkor.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#define INCLUDE_LIST\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"aarch64-protos.h\"\n+#include \"hash-map.h\"\n+#include \"cfgloop.h\"\n+#include \"cfgrtl.h\"\n+#include \"rtl-iter.h\"\n+#include \"df.h\"\n+#include \"memmodel.h\"\n+#include \"optabs.h\"\n+#include \"regs.h\"\n+#include \"recog.h\"\n+#include \"regrename.h\"\n+#include \"print-rtl.h\"\n+\n+/* The Falkor hardware prefetching system uses the encoding of the registers\n+   and offsets of loads to decide which of the multiple hardware prefetchers to\n+   assign the load to.  This has the positive effect of accelerating prefetches\n+   when all related loads with uniform strides are assigned to the same\n+   prefetcher unit.  The down side is that because of the way the assignment\n+   works, multiple unrelated loads may end up on the same prefetch unit, thus\n+   causing the unit to bounce between different sets of addresses and never\n+   train correctly.  The point of this pass is to avoid such collisions so that\n+   unrelated loads are spread out to different prefetchers.  It also makes a\n+   rudimentary attempt to ensure that related loads with the same tags don't\n+   get moved out unnecessarily.\n+\n+   Perhaps a future enhancement would be to make a more concerted attempt to\n+   get related loads under the same tag.  See the memcpy/memset implementation\n+   for falkor in glibc to understand the kind of impact this can have on\n+   falkor.\n+\n+   The assignment of loads is based on a tag that is computed from the encoding\n+   of the first destination register (the only destination in case of LDR), the\n+   base register and the offset (either the register or the immediate value, as\n+   encoded in the instruction).  This is what the 14 bit tag looks like:\n+\n+   |<- 6 bits ->|<- 4b ->|<- 4b ->|\n+   --------------------------------\n+   |  OFFSET    |  SRC   |  DST   |\n+   --------------------------------\n+\n+   For all cases, the SRC and DST are the 4 LSB of the encoding of the register\n+   in the instruction.  Offset computation is more involved and is as follows:\n+\n+   - For register offset addressing: 4 LSB of the offset register with the MSB\n+     of the 6 bits set to 1.\n+\n+   - For immediate offset: 4 LSB of the encoded immediate offset.  The encoding\n+     depends on the width of the load and is expressed as multiples of the\n+     width.\n+\n+   - For loads with update: 4 LSB of the offset.  The encoding here is the\n+     exact number by which the base is offset and incremented.\n+\n+   Based on the above it is clear that registers 0 and 16 will result in\n+   collisions, 1 and 17 and so on.  This pass detects such collisions within a\n+   def/use chain of the source register in a loop and tries to resolve the\n+   collision by renaming one of the destination registers.  */\n+\n+/* Get the destination part of the tag.  */\n+#define TAG_GET_DEST(__tag) ((__tag) & 0xf)\n+\n+/* Get the tag with the destination part updated.  */\n+#define TAG_UPDATE_DEST(__tag, __dest) (((__tag) & ~0xf) | (__dest & 0xf))\n+\n+#define MAX_PREFETCH_STRIDE 2048\n+\n+/* The instruction information structure.  This is used to cache information\n+   about the INSN that we derive when traversing through all of the insns in\n+   loops.  */\n+class tag_insn_info\n+{\n+public:\n+  rtx_insn *insn;\n+  rtx dest;\n+  rtx base;\n+  rtx offset;\n+  bool writeback;\n+  bool ldp;\n+\n+  tag_insn_info (rtx_insn *i, rtx d, rtx b, rtx o, bool w, bool p)\n+    : insn (i), dest (d), base (b), offset (o), writeback (w), ldp (p)\n+  {}\n+\n+  /* Compute the tag based on BASE, DEST and OFFSET of the load.  */\n+  unsigned tag ()\n+    {\n+      unsigned int_offset = 0;\n+      rtx offset = this->offset;\n+      unsigned dest = REGNO (this->dest);\n+      unsigned base = REGNO (this->base);\n+      machine_mode dest_mode = GET_MODE (this->dest);\n+\n+      /* Falkor does not support SVE; GET_LOAD_INFO ensures that the\n+\t destination mode is constant here.  */\n+      unsigned dest_mode_size = GET_MODE_SIZE (dest_mode).to_constant ();\n+\n+      /* For loads of larger than 16 bytes, the DEST part of the tag is 0.  */\n+      if ((dest_mode_size << this->ldp) > 16)\n+\tdest = 0;\n+\n+      if (offset && REG_P (offset))\n+\tint_offset = (1 << 5) | REGNO (offset);\n+      else if (offset && CONST_INT_P (offset))\n+\t{\n+\t  int_offset = INTVAL (offset);\n+\t  int_offset /= dest_mode_size;\n+\t  if (!this->writeback)\n+\t    int_offset >>= 2;\n+\t}\n+      return ((dest & 0xf)\n+\t      | ((base & 0xf) << 4)\n+\t      | ((int_offset & 0x3f) << 8));\n+    }\n+};\n+\n+/* Hash map to traverse and process instructions with colliding tags.  */\n+typedef hash_map <rtx, auto_vec <tag_insn_info *> > tag_map_t;\n+\n+/* Vector of instructions with colliding tags.  */\n+typedef auto_vec <tag_insn_info *> insn_info_list_t;\n+\n+/* Pair of instruction information and unavailable register set to pass to\n+   CHECK_COLLIDING_TAGS.  */\n+typedef std::pair <tag_insn_info *, HARD_REG_SET *> arg_pair_t;\n+\n+\n+/* Callback to free all tag_insn_info objects.  */\n+bool\n+free_insn_info (const rtx &t ATTRIBUTE_UNUSED, insn_info_list_t *v,\n+\t\tvoid *arg ATTRIBUTE_UNUSED)\n+{\n+  while (v->length () > 0)\n+    delete v->pop ();\n+\n+  return true;\n+}\n+\n+\n+/* Add all aliases of the register to the unavailable register set.  REG is the\n+   smallest register number that can then be used to reference its aliases.\n+   UNAVAILABLE is the hard register set to add the ignored register numbers to\n+   and MODE is the mode in which the registers would have been used.  */\n+static void\n+ignore_all_aliases (HARD_REG_SET *unavailable, machine_mode mode, unsigned reg)\n+{\n+  add_to_hard_reg_set (unavailable, mode, reg);\n+  add_to_hard_reg_set (unavailable, mode, reg + 16);\n+  add_to_hard_reg_set (unavailable, mode, reg + 32);\n+  add_to_hard_reg_set (unavailable, mode, reg + 48);\n+}\n+\n+\n+/* Callback to check which destination registers are unavailable to us for\n+   renaming because of the base and offset colliding.  This is a callback that\n+   gets called for every name value pair (T, V) in the TAG_MAP.  The ARG is an\n+   std::pair of the tag_insn_info of the original insn and the hard register\n+   set UNAVAILABLE that is used to record hard register numbers that cannot be\n+   used for the renaming.  This always returns true since we want to traverse\n+   through the entire TAG_MAP.  */\n+bool\n+check_colliding_tags (const rtx &t, const insn_info_list_t &v, arg_pair_t *arg)\n+{\n+  HARD_REG_SET *unavailable = arg->second;\n+  unsigned orig_tag = arg->first->tag ();\n+  unsigned tag = INTVAL (t);\n+  machine_mode mode = GET_MODE (arg->first->dest);\n+\n+  /* Can't collide with emptiness.  */\n+  if (v.length () == 0)\n+    return true;\n+\n+  /* Drop all aliased destination registers that result in the same\n+     tag.  It is not necessary to drop all of them but we do anyway\n+     because it is quicker than checking ranges.  */\n+  if (TAG_UPDATE_DEST (tag, 0) == TAG_UPDATE_DEST (orig_tag, 0))\n+    ignore_all_aliases (unavailable, mode, TAG_GET_DEST (tag));\n+\n+  return true;\n+}\n+\n+\n+/* Initialize and build a set of hard register numbers UNAVAILABLE to avoid for\n+   renaming.  INSN_INFO is the original insn, TAG_MAP is the map of the list of\n+   insns indexed by their tags, HEAD is the def/use chain head of the\n+   destination register of the original insn.  The routine returns the super\n+   class of register classes that may be used during the renaming.  */\n+static enum reg_class\n+init_unavailable (tag_insn_info *insn_info, tag_map_t &tag_map, du_head_p head,\n+\t\t  HARD_REG_SET *unavailable)\n+{\n+  unsigned dest = head->regno;\n+  enum reg_class super_class = NO_REGS;\n+  machine_mode mode = GET_MODE (insn_info->dest);\n+\n+  CLEAR_HARD_REG_SET (*unavailable);\n+\n+  for (struct du_chain *tmp = head->first; tmp; tmp = tmp->next_use)\n+    {\n+      if (DEBUG_INSN_P (tmp->insn))\n+\tcontinue;\n+\n+      IOR_COMPL_HARD_REG_SET (*unavailable, reg_class_contents[tmp->cl]);\n+      super_class = reg_class_superunion[(int) super_class][(int) tmp->cl];\n+    }\n+\n+  for (unsigned i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (fixed_regs[i] || global_regs[i])\n+      add_to_hard_reg_set (unavailable, mode, i);\n+\n+  arg_pair_t arg = arg_pair_t (insn_info, unavailable);\n+\n+  /* Exclude all registers that would lead to collisions with other loads.  */\n+  tag_map.traverse <arg_pair_t *, check_colliding_tags> (&arg);\n+\n+  /* Finally, also ignore all aliases of the current reg.  */\n+  ignore_all_aliases (unavailable, mode, dest & 0xf);\n+\n+  return super_class;\n+}\n+\n+\n+/* Find a suitable and available register and rename the chain of occurrences\n+   of the register  defined in the def/use chain headed by HEAD in which INSN\n+   exists.  CUR_TAG, TAGS and TAG_MAP are used to determine which registers are\n+   unavailable due to a potential collision due to the rename.  The routine\n+   returns the register number in case of a successful rename or -1 to indicate\n+   failure.  */\n+static int\n+rename_chain (tag_insn_info *insn_info, tag_map_t &tag_map, du_head_p head)\n+{\n+  unsigned dest_regno = head->regno;\n+\n+  if (head->cannot_rename || head->renamed)\n+    return -1;\n+\n+  HARD_REG_SET unavailable;\n+\n+  enum reg_class super_class = init_unavailable (insn_info, tag_map, head,\n+\t\t\t\t\t\t &unavailable);\n+\n+  unsigned new_regno = find_rename_reg (head, super_class, &unavailable,\n+\t\t\t\t\tdest_regno, false);\n+\n+  /* Attempt to rename as long as regrename doesn't just throw the same\n+     register at us.  */\n+  if (new_regno != dest_regno && regrename_do_replace (head, new_regno))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \"\\tInsn %d: Renamed %d to %d\\n\",\n+\t\t   INSN_UID (insn_info->insn), dest_regno, new_regno);\n+\n+      return new_regno;\n+    }\n+\n+  return -1;\n+}\n+\n+\n+/* Return true if REGNO is not safe to rename.  */\n+static bool\n+unsafe_rename_p (unsigned regno)\n+{\n+  /* Avoid renaming registers used for argument passing and return value.  In\n+     future we could be a little less conservative and walk through the basic\n+     blocks to see if there are any call or syscall sites.  */\n+  if (regno <= R8_REGNUM\n+      || (regno >= V0_REGNUM && regno < V8_REGNUM))\n+    return true;\n+\n+  /* Don't attempt to rename registers that may have specific meanings.  */\n+  switch (regno)\n+    {\n+    case LR_REGNUM:\n+    case HARD_FRAME_POINTER_REGNUM:\n+    case FRAME_POINTER_REGNUM:\n+    case STACK_POINTER_REGNUM:\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Go through the def/use chains for the register and find the chain for this\n+   insn to rename.  The function returns the hard register number in case of a\n+   successful rename and -1 otherwise.  */\n+static int\n+rename_dest (tag_insn_info *insn_info, tag_map_t &tag_map)\n+{\n+  struct du_chain *chain = NULL;\n+  du_head_p head = NULL;\n+  int i;\n+\n+  unsigned dest_regno = REGNO (insn_info->dest);\n+\n+  if (unsafe_rename_p (dest_regno))\n+    return -1;\n+\n+  /* Search the chain where this instruction is (one of) the root.  */\n+  rtx_insn *insn = insn_info->insn;\n+  operand_rr_info *dest_op_info = insn_rr[INSN_UID (insn)].op_info;\n+\n+  for (i = 0; i < dest_op_info->n_chains; i++)\n+    {\n+      /* The register tracked by this chain does not match the\n+\t destination register of insn.  */\n+      if (dest_op_info->heads[i]->regno != dest_regno)\n+\tcontinue;\n+\n+      head = dest_op_info->heads[i];\n+      /* The chain was merged in another, find the new head.  */\n+      if (!head->first)\n+\thead = regrename_chain_from_id (head->id);\n+\n+      for (chain = head->first; chain; chain = chain->next_use)\n+\t/* Found the insn in the chain, so try renaming the register in this\n+\t   chain.  */\n+\tif (chain->insn == insn)\n+\t  return rename_chain (insn_info, tag_map, head);\n+    }\n+\n+  return -1;\n+}\n+\n+\n+/* Flag to track if the map has changed.  */\n+static bool map_changed = false;\n+\n+/* The actual reallocation logic.  For each vector of collisions V, try to\n+   resolve the collision by attempting to rename the destination register of\n+   all but one of the loads.  This is a callback that is invoked for each\n+   name-value pair (T, V) in TAG_MAP.  The function returns true whenever it\n+   returns unchanged and false otherwise to halt traversal.  */\n+bool\n+avoid_collisions_1 (const rtx &t, insn_info_list_t *v, tag_map_t *tag_map)\n+{\n+  /* We need at least two loads to cause a tag collision, return unchanged.  */\n+  if (v->length () < 2)\n+    return true;\n+\n+  tag_insn_info *vec_start = v->pop ();\n+  tag_insn_info *insn_info = vec_start;\n+\n+  /* Try to rename at least one register to reduce the collision.  If we\n+     iterate all the way through, we end up dropping one of the loads from the\n+     list.  This is fine because we want at most one element to ensure that a\n+     subsequent rename attempt does not end up worsening the collision.  */\n+  do\n+    {\n+      int new_regno;\n+\n+      if ((new_regno = rename_dest (insn_info, *tag_map)) != -1)\n+\t{\n+\t  rtx new_tag = GEN_INT (TAG_UPDATE_DEST (INTVAL (t), new_regno));\n+\n+\t  tag_map->get_or_insert (new_tag).safe_push (insn_info);\n+\t  df_set_regs_ever_live (new_regno, true);\n+\t  map_changed = true;\n+\t  return false;\n+\t}\n+\n+      v->safe_insert (0, insn_info);\n+      insn_info = v->pop ();\n+    }\n+  while (insn_info != vec_start);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\t>> Failed to rename destination in insn %d\\n\\t>>\",\n+\t     INSN_UID (insn_info->insn));\n+\n+  /* Drop the last element and move on to the next tag.  */\n+  delete insn_info;\n+  return true;\n+}\n+\n+\n+/* For each set of collisions, attempt to rename the registers or insert a move\n+   to avoid the collision.  We repeatedly traverse through TAG_MAP using\n+   AVOID_COLLISIONS_1 trying to rename registers to avoid collisions until a\n+   full traversal results in no change in the map.  */\n+static void\n+avoid_collisions (tag_map_t &tag_map)\n+{\n+  do\n+    {\n+      map_changed = false;\n+      tag_map.traverse <tag_map_t *, avoid_collisions_1> (&tag_map);\n+    }\n+  while (map_changed);\n+}\n+\f\n+\n+\n+/* Find the use def chain in which INSN exists and then see if there is a\n+   definition inside the loop and outside it.  We use this as a simple\n+   approximation to determine whether the base register is an IV.  The basic\n+   idea is to find INSN in the use-def chains for its base register and find\n+   all definitions that reach it.  Of all these definitions, there should be at\n+   least one definition that is a simple addition of a constant value, either\n+   as a binary operation or a pre or post update.\n+\n+   The function returns true if the base register is estimated to be an IV.  */\n+static bool\n+iv_p (rtx_insn *insn, rtx reg, struct loop *loop)\n+{\n+  df_ref ause;\n+  unsigned regno = REGNO (reg);\n+\n+  /* Ignore loads from the stack.  */\n+  if (regno == SP_REGNUM)\n+    return false;\n+\n+  for (ause = DF_REG_USE_CHAIN (regno); ause; ause = DF_REF_NEXT_REG (ause))\n+    {\n+      if (!DF_REF_INSN_INFO (ause)\n+\t  || !NONDEBUG_INSN_P (DF_REF_INSN (ause)))\n+\tcontinue;\n+\n+      if (insn != DF_REF_INSN (ause))\n+\tcontinue;\n+\n+      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+      df_ref def_rec;\n+\n+      FOR_EACH_INSN_INFO_DEF (def_rec, insn_info)\n+\t{\n+\t  rtx_insn *insn = DF_REF_INSN (def_rec);\n+\t  basic_block bb = BLOCK_FOR_INSN (insn);\n+\n+\t  if (dominated_by_p (CDI_DOMINATORS, bb, loop->header)\n+\t      && bb->loop_father == loop)\n+\t    {\n+\t      if (recog_memoized (insn) < 0)\n+\t\tcontinue;\n+\n+\t      rtx pat = PATTERN (insn);\n+\n+\t      /* Prefetch or clobber; unlikely to be a constant stride.  The\n+\t\t falkor software prefetcher tuning is pretty conservative, so\n+\t\t its presence indicates that the access pattern is probably\n+\t\t strided but most likely with an unknown stride size or a\n+\t\t stride size that is quite large.  */\n+\t      if (GET_CODE (pat) != SET)\n+\t\tcontinue;\n+\n+\t      rtx x = SET_SRC (pat);\n+\t      if (GET_CODE (x) == ZERO_EXTRACT\n+\t\t  || GET_CODE (x) == ZERO_EXTEND\n+\t\t  || GET_CODE (x) == SIGN_EXTEND)\n+\t\tx = XEXP (x, 0);\n+\n+\t      /* Loading the value from memory; unlikely to be a constant\n+\t\t stride.  */\n+\t      if (MEM_P (x))\n+\t\tcontinue;\n+\n+\t      /* An increment or decrement by a constant MODE_SIZE amount or\n+\t\t the result of a binary expression is likely to be an IV.  */\n+\t      if (GET_CODE (x) == POST_INC\n+\t\t  || GET_CODE (x) == POST_DEC\n+\t\t  || GET_CODE (x) == PRE_INC\n+\t\t  || GET_CODE (x) == PRE_DEC)\n+\t\treturn true;\n+\t      else if (BINARY_P (x)\n+\t\t       && (CONST_INT_P (XEXP (x, 0))\n+\t\t\t   || CONST_INT_P (XEXP (x, 1))))\n+\t\t{\n+\t\t  rtx stride = (CONST_INT_P (XEXP (x, 0))\n+\t\t\t\t? XEXP (x, 0) : XEXP (x, 1));\n+\n+\t\t  /* Don't bother with very long strides because the prefetcher\n+\t\t     is unable to train on them anyway.  */\n+\t\t  if (INTVAL (stride) < MAX_PREFETCH_STRIDE)\n+\t\t    return true;\n+\t\t}\n+\t    }\n+\t}\n+      return false;\n+    }\n+  return false;\n+}\n+\n+\n+/* Return true if SRC is a strided load in the LOOP, false otherwise.\n+   If it is a strided load, set the BASE and OFFSET.  Also, if this is\n+   a pre/post increment load, set PRE_POST to true.  */\n+static bool\n+valid_src_p (rtx src, rtx_insn *insn, struct loop *loop, bool *pre_post,\n+\t     rtx *base, rtx *offset, bool load_pair)\n+{\n+  subrtx_var_iterator::array_type array;\n+  rtx x = NULL_RTX;\n+\n+  FOR_EACH_SUBRTX_VAR (iter, array, src, NONCONST)\n+    if (MEM_P (*iter))\n+      {\n+\tx = *iter;\n+\tbreak;\n+      }\n+\n+  if (!x)\n+    return false;\n+\n+  struct aarch64_address_info addr;\n+  machine_mode mode = GET_MODE (x);\n+\n+  if (!aarch64_classify_address (&addr, XEXP (x, 0), mode, true))\n+    return false;\n+\n+  unsigned regno = REGNO (addr.base);\n+  if (global_regs[regno] || fixed_regs[regno])\n+    return false;\n+\n+  if (addr.type == ADDRESS_REG_WB)\n+    {\n+      unsigned code = GET_CODE (XEXP (x, 0));\n+\n+      *pre_post = true;\n+      *base = addr.base;\n+\n+      if (code == PRE_MODIFY || code == POST_MODIFY)\n+\t*offset = addr.offset;\n+      else\n+\t{\n+\t  /*Writeback is only supported for fixed-width modes.  */\n+\t  unsigned int_offset = GET_MODE_SIZE (mode).to_constant ();\n+\n+\t  /* For post-incremented load pairs we would increment the base twice\n+\t     over, so make that adjustment.  */\n+\t  if (load_pair && (code == POST_INC || code == POST_DEC))\n+\t    int_offset *= 2;\n+\n+\t  *offset = GEN_INT (int_offset);\n+\t}\n+      return true;\n+    }\n+  else if (addr.type == ADDRESS_REG_IMM || addr.type == ADDRESS_REG_REG)\n+    {\n+      /* Check if the load is strided.  */\n+      if (!iv_p (insn, addr.base, loop))\n+\treturn false;\n+\n+      *base = addr.base;\n+      *offset = addr.offset;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Return true if INSN is a strided load in LOOP.  If it is a strided load, set\n+   the DEST, BASE and OFFSET.  Also, if this is a pre/post increment load, set\n+   PRE_POST to true.\n+\n+   The routine does checks on the destination of the insn and depends on\n+   STRIDED_LOAD_P to check the source and fill in the BASE and OFFSET.  */\n+static bool\n+get_load_info (rtx_insn *insn, struct loop *loop, rtx *dest, rtx *base,\n+\t       rtx *offset, bool *pre_post, bool *ldp)\n+{\n+  if (!INSN_P (insn) || recog_memoized (insn) < 0)\n+    return false;\n+\n+  rtx pat = PATTERN (insn);\n+  unsigned code = GET_CODE (pat);\n+  bool load_pair = (code == PARALLEL);\n+\n+  /* For a load pair we need only the first base and destination\n+     registers.  We however need to ensure that our pre/post increment\n+     offset is doubled; we do that in STRIDED_LOAD_P.  */\n+  if (load_pair)\n+    {\n+      pat = XVECEXP (pat, 0, 0);\n+      code = GET_CODE (pat);\n+    }\n+\n+  if (code != SET)\n+    return false;\n+\n+  rtx dest_rtx = SET_DEST (pat);\n+\n+  if (!REG_P (dest_rtx))\n+    return false;\n+\n+  unsigned regno = REGNO (dest_rtx);\n+  machine_mode mode = GET_MODE (dest_rtx);\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n+\n+  /* Falkor does not support SVE vectors.  */\n+  if (!GET_MODE_SIZE (mode).is_constant ())\n+    return false;\n+\n+  /* Ignore vector struct or lane loads.  */\n+  if (GET_MODE_SIZE (mode).to_constant ()\n+      != GET_MODE_SIZE (inner_mode).to_constant ())\n+    return false;\n+\n+  /* The largest width we want to bother with is a load of a pair of\n+     quad-words.  */\n+  if ((GET_MODE_SIZE (mode).to_constant () << load_pair)\n+      > GET_MODE_SIZE (OImode))\n+    return false;\n+\n+  /* Ignore loads into the stack pointer because it is unlikely to be a\n+     stream.  */\n+  if (regno == SP_REGNUM)\n+    return false;\n+\n+  if (valid_src_p (SET_SRC (pat), insn, loop, pre_post, base, offset,\n+\t\t   load_pair))\n+    {\n+      *dest = dest_rtx;\n+      *ldp = load_pair;\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Return whether INSN and CAND are in the same def/use chain.  */\n+static bool\n+in_same_chain (rtx_insn *insn, rtx_insn *cand, unsigned regno)\n+{\n+  struct du_chain *chain = NULL;\n+  du_head_p head = NULL;\n+  int i;\n+\n+  /* Search the chain where this instruction is (one of) the root.  */\n+  operand_rr_info *op_info = insn_rr[INSN_UID (insn)].op_info;\n+\n+  for (i = 0; i < op_info->n_chains; i++)\n+    {\n+      /* The register tracked by this chain does not match the\n+\t dest register of insn.  */\n+      if (op_info->heads[i]->regno != regno)\n+\tcontinue;\n+\n+      head = op_info->heads[i];\n+      /* The chain was merged in another, find the new head.  */\n+      if (!head->first)\n+\thead = regrename_chain_from_id (head->id);\n+\n+      bool found_insn = false, found_cand = false;\n+\n+      for (chain = head->first; chain; chain = chain->next_use)\n+\t{\n+\t  rtx *loc = &SET_DEST (PATTERN (chain->insn));\n+\n+\t  if (chain->loc != loc)\n+\t    continue;\n+\n+\t  if (chain->insn == insn)\n+\t    found_insn = true;\n+\n+\t  if (chain->insn == cand)\n+\t    found_cand = true;\n+\n+\t  if (found_insn && found_cand)\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Callback function to traverse the tag map and drop loads that have the same\n+   destination and and in the same chain of occurrence.  Routine always returns\n+   true to allow traversal through all of TAG_MAP.  */\n+bool\n+single_dest_per_chain (const rtx &t ATTRIBUTE_UNUSED, insn_info_list_t *v,\n+\t\t       void *arg ATTRIBUTE_UNUSED)\n+{\n+  for (int i = v->length () - 1; i>= 1; i--)\n+    {\n+      tag_insn_info *insn_info = (*v)[i];\n+\n+      for (int j = v->length () - 2; j >= 0; j--)\n+\t{\n+\t  /* Filter out destinations in the same chain.  */\n+\t  if (in_same_chain (insn_info->insn, (*v)[j]->insn,\n+\t\t\t     REGNO (insn_info->dest)))\n+\t    {\n+\t      v->ordered_remove (j);\n+\t      i = v->length ();\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Callback invoked for each name-value pair (T, INSN_INFO) to dump the insn\n+   list INSN_INFO for tag T.  */\n+bool\n+dump_insn_list (const rtx &t, const insn_info_list_t &insn_info,\n+\t\tvoid *unused ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (dump_file);\n+  fprintf (dump_file, \"Tag 0x%lx ::\\n\", INTVAL (t));\n+\n+  for (unsigned i = 0; i < insn_info.length (); i++)\n+    dump_insn_slim (dump_file, insn_info[i]->insn);\n+\n+  fprintf (dump_file, \"\\n\");\n+\n+  return true;\n+}\n+\n+\n+/* Record all loads in LOOP into TAG_MAP indexed by the falkor hardware\n+   prefetcher memory tags.  */\n+static void\n+record_loads (tag_map_t &tag_map, struct loop *loop)\n+{\n+  rtx_insn *insn;\n+  basic_block *body, bb;\n+\n+  body = get_loop_body (loop);\n+\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = body[i];\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  rtx base = NULL_RTX;\n+\t  rtx dest = NULL_RTX;\n+\t  rtx offset = NULL_RTX;\n+\t  bool writeback = false;\n+\t  bool ldp = false;\n+\n+\t  if (!INSN_P (insn) || DEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  if (get_load_info (insn, loop, &dest, &base, &offset, &writeback,\n+\t\t\t     &ldp))\n+\t    {\n+\t      tag_insn_info *i = new tag_insn_info (insn, dest, base, offset,\n+\t\t\t\t\t\t    writeback, ldp);\n+\t      rtx tag = GEN_INT (i->tag ());\n+\t      tag_map.get_or_insert (tag).safe_push (i);\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Loop %d: Tag map generated.\\n\", loop->num);\n+      tag_map.traverse <void *, dump_insn_list> (NULL);\n+    }\n+\n+  /* Try to reduce the dataset before launching into the rename attempt.  Drop\n+     destinations in the same collision chain that appear in the same def/use\n+     chain, all as defs.  These chains will move together in a rename so\n+     there's no point in keeping both in there.  */\n+  tag_map.traverse <void *, single_dest_per_chain> (NULL);\n+}\n+\n+\n+/* Tag collision avoidance pass for Falkor.  The pass runs in two phases for\n+   each loop; the first phase collects all loads that we consider as\n+   interesting for renaming into a tag-indexed map of lists.  The second phase\n+   renames the destination register of the loads in an attempt to spread out\n+   the loads into different tags.  */\n+void\n+execute_tag_collision_avoidance ()\n+{\n+  struct loop *loop;\n+\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n+  df_chain_add_problem (DF_UD_CHAIN);\n+  df_compute_regs_ever_live (true);\n+  df_analyze ();\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+\n+  regrename_init (true);\n+  regrename_analyze (NULL);\n+\n+  compute_bb_for_insn ();\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n+    {\n+      tag_map_t tag_map (512);\n+\n+      record_loads (tag_map, loop);\n+      avoid_collisions (tag_map);\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Loop %d: Completed rename.\\n\", loop->num);\n+\t  tag_map.traverse <void *, dump_insn_list> (NULL);\n+\t}\n+      tag_map.traverse <void *, free_insn_info> (NULL);\n+    }\n+\n+  loop_optimizer_finalize ();\n+  free_dominance_info (CDI_DOMINATORS);\n+  regrename_finish ();\n+}\n+\n+\n+const pass_data pass_data_tag_collision_avoidance =\n+{\n+  RTL_PASS, /* type */\n+  \"tag_collision_avoidance\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n+};\n+\n+\n+class pass_tag_collision_avoidance : public rtl_opt_pass\n+{\n+public:\n+  pass_tag_collision_avoidance (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_tag_collision_avoidance, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return ((aarch64_tune_params.extra_tuning_flags\n+\t       & AARCH64_EXTRA_TUNE_RENAME_LOAD_REGS)\n+\t      && optimize >= 2);\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      execute_tag_collision_avoidance ();\n+      return 0;\n+    }\n+\n+}; // class pass_tag_collision_avoidance\n+\n+\n+/* Create a new pass instance.  */\n+rtl_opt_pass *\n+make_pass_tag_collision_avoidance (gcc::context *ctxt)\n+{\n+  return new pass_tag_collision_avoidance (ctxt);\n+}"}, {"sha": "1576d05ba9d3decf852c41619f506ff935cd810d", "filename": "gcc/config/aarch64/t-aarch64", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a98824ac233280256a6b7516cec56c363d328ce3/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=a98824ac233280256a6b7516cec56c363d328ce3", "patch": "@@ -77,6 +77,16 @@ aarch64-speculation.o: $(srcdir)/config/aarch64/aarch64-speculation.cc \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_SPPFLAGS) $(INCLUDES) \\\n \t  $(srcdir)/config/aarch64/aarch64-speculation.cc\n \n+falkor-tag-collision-avoidance.o: \\\n+    $(srcdir)/config/aarch64/falkor-tag-collision-avoidance.c \\\n+    $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(REGS_H) insn-config.h $(RTL_BASE_H) \\\n+    dominance.h cfg.h cfganal.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(RECOG_H) \\\n+    output.h hash-map.h $(DF_H) $(OBSTACK_H) $(TARGET_H) $(RTL_H) \\\n+    $(CONTEXT_H) $(TREE_PASS_H) regrename.h \\\n+    $(srcdir)/config/aarch64/aarch64-protos.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/aarch64/falkor-tag-collision-avoidance.c\n+\n comma=,\n MULTILIB_OPTIONS    = $(subst $(comma),/, $(patsubst %, mabi=%, $(subst $(comma),$(comma)mabi=,$(TM_MULTILIB_CONFIG))))\n MULTILIB_DIRNAMES   = $(subst $(comma), ,$(TM_MULTILIB_CONFIG))"}]}