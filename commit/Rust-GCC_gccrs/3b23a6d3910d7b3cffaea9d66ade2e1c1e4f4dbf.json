{"sha": "3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IyM2E2ZDM5MTBkN2IzY2ZmYWVhOWQ2NmFkZTJlMWMxZTRmNGRiZg==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2008-05-20T10:00:20Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2008-05-20T10:00:20Z"}, "message": "i386-protos.h (ix86_return_in_memory): Removed.\n\n2008-05-20  Kai Tietz  <kai.tietz@onevision.com>\n\n\t* config/i386/i386-protos.h (ix86_return_in_memory): Removed.\n\t(ix86_i386elf_return_in_memory): Likewise.\n\t(ix86_i386interix_return_in_memory): Likewise.\n\t* config/i386/i386-interix.h (TARGET_RETURN_IN_MEMORY): Removed.\n\t(SUBTARGET_RETURN_IN_MEMORY): New.\n\t* config/i386/i386elf.h: Likewise.\n\t* config/i386/ptx4-i.h: Likewise.\n\t* config/i386/sol2-10.h: Likewise.\n\t* config/i386/sysv4.h: Likewise.\n\t* config/i386/vx-common.h: Likewise.\n\t* config/i386/i386.h (TARGET_RETURN_IN_MEMORY): Removed.\n\t* config/i386/i386.c (ix86_return_in_memory): Made static and\n\tmake use of optional SUBTARGET_RETURN_IN_MEMORY macro.\n\t(ix86_i386elf_return_in_memory): Removed.\n\t(ix86_i386interix_return_in_memory): Removed.\n\t(TARGET_RETURN_IN_MEMORY): Declared within i386.c only.\n\t* target-def.h (TARGET_RETURN_IN_MEMORY): Remove protection #ifdef.\n\nFrom-SVN: r135604", "tree": {"sha": "2c11e8e86d3bbf49bfda0758f76cc5eca170ef91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c11e8e86d3bbf49bfda0758f76cc5eca170ef91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/comments", "author": null, "committer": null, "parents": [{"sha": "be9ed5d52518529f4083d6b0f455dea7866e4ff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be9ed5d52518529f4083d6b0f455dea7866e4ff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be9ed5d52518529f4083d6b0f455dea7866e4ff0"}], "stats": {"total": 323, "additions": 224, "deletions": 99}, "files": [{"sha": "8d52eb24aab65d5d151aecbff1cf58b68fbcf5ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -1,3 +1,23 @@\n+2008-05-20  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* config/i386/i386-protos.h (ix86_return_in_memory): Removed.\n+\t(ix86_i386elf_return_in_memory): Likewise.\n+\t(ix86_i386interix_return_in_memory): Likewise.\n+\t* config/i386/i386-interix.h (TARGET_RETURN_IN_MEMORY): Removed.\n+\t(SUBTARGET_RETURN_IN_MEMORY): New.\n+\t* config/i386/i386elf.h: Likewise.\n+\t* config/i386/ptx4-i.h: Likewise.\n+\t* config/i386/sol2-10.h: Likewise.\n+\t* config/i386/sysv4.h: Likewise.\n+\t* config/i386/vx-common.h: Likewise.\n+\t* config/i386/i386.h (TARGET_RETURN_IN_MEMORY): Removed.\n+\t* config/i386/i386.c (ix86_return_in_memory): Made static and\n+\tmake use of optional SUBTARGET_RETURN_IN_MEMORY macro.\n+\t(ix86_i386elf_return_in_memory): Removed.\n+\t(ix86_i386interix_return_in_memory): Removed.\n+\t(TARGET_RETURN_IN_MEMORY): Declared within i386.c only.\n+\t* target-def.h (TARGET_RETURN_IN_MEMORY): Remove protection #ifdef.\n+\n 2008-05-20  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* cselib.c (cselib_record_sets): Use correct mode for IF_THEN_ELSE."}, {"sha": "7b7651603143a8c3614abb20de7821f55afe88b0", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -34,7 +34,10 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n #undef TARGET_64BIT_MS_ABI\n-#define TARGET_64BIT_MS_ABI TARGET_64BIT\n+#define TARGET_64BIT_MS_ABI (!cfun ? DEFAULT_ABI == MS_ABI : TARGET_64BIT && cfun->machine->call_abi == MS_ABI)\n+\n+#undef DEFAULT_ABI\n+#define DEFAULT_ABI (TARGET_64BIT ? MS_ABI : SYSV_ABI)\n \n #undef DBX_REGISTER_NUMBER\n #define DBX_REGISTER_NUMBER(n)\t\t\t\t\\\n@@ -123,12 +126,6 @@ along with GCC; see the file COPYING3.  If not see\n #undef LONG_TYPE_SIZE\n #define LONG_TYPE_SIZE 32\n \f\n-#undef REG_PARM_STACK_SPACE\n-#define REG_PARM_STACK_SPACE(FNDECL) (TARGET_64BIT_MS_ABI ? 32 : 0)\n-\n-#undef OUTGOING_REG_PARM_STACK_SPACE\n-#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) (TARGET_64BIT_MS_ABI ? 1 : 0)\n-\n #undef REGPARM_MAX\n #define REGPARM_MAX (TARGET_64BIT_MS_ABI ? 4 : 3)\n \n@@ -214,7 +211,7 @@ do {\t\t\t\t\t\t\\\n #define CHECK_STACK_LIMIT 4000\n \n #undef STACK_BOUNDARY\n-#define STACK_BOUNDARY\t(TARGET_64BIT_MS_ABI ? 128 : BITS_PER_WORD)\n+#define STACK_BOUNDARY\t(DEFAULT_ABI == MS_ABI ? 128 : BITS_PER_WORD)\n \n /* By default, target has a 80387, uses IEEE compatible arithmetic,\n    returns float values in the 387 and needs stack probes."}, {"sha": "40106d858693244c26c1a5209806f3e1a924549c", "filename": "gcc/config/i386/i386-interix.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-interix.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -357,5 +357,6 @@ extern void i386_pe_unique_section (tree, int);\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY ix86_i386interix_return_in_memory\n+#define SUBTARGET_RETURN_IN_MEMORY(TYPE, FNTYPE) \\\n+\t(TYPE_MODE (TYPE) == BLKmode \\\n+\t || (AGGREGATE_TYPE_P (TYPE) && int_size_in_bytes (TYPE) > 8 ))\n\\ No newline at end of file"}, {"sha": "ed86304b59b0435bbcac8ddb6687bfd7b47bf077", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -134,12 +134,12 @@ extern rtx ix86_libcall_value (enum machine_mode);\n extern bool ix86_function_value_regno_p (int);\n extern bool ix86_function_arg_regno_p (int);\n extern int ix86_function_arg_boundary (enum machine_mode, tree);\n-extern bool ix86_return_in_memory (const_tree, const_tree);\n extern bool ix86_sol10_return_in_memory (const_tree,const_tree);\n-extern bool ix86_i386elf_return_in_memory (const_tree,const_tree);\n-extern bool ix86_i386interix_return_in_memory (const_tree,const_tree);\n extern rtx ix86_force_to_memory (enum machine_mode, rtx);\n extern void ix86_free_from_memory (enum machine_mode);\n+extern int ix86_cfun_abi (void);\n+extern int ix86_function_abi (const_tree);\n+extern int ix86_function_type_abi (const_tree);\n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n \t\t\t\t  rtx, rtx, rtx, rtx);\n extern bool ix86_hard_regno_mode_ok (int, enum machine_mode);"}, {"sha": "eba44cbce7c723ccc828d28af0fd148d558a2eea", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 127, "deletions": 48, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -1618,8 +1618,12 @@ rtx ix86_compare_op0 = NULL_RTX;\n rtx ix86_compare_op1 = NULL_RTX;\n rtx ix86_compare_emitted = NULL_RTX;\n \n+/* Abi specific values for REGPARM_MAX */\n+#define X86_64_REGPARM_MAX 6\n+#define X86_64_SSE_REGPARM_MAX 8\n+\n /* Size of the register save area.  */\n-#define X86_64_VARARGS_SIZE (REGPARM_MAX * UNITS_PER_WORD + SSE_REGPARM_MAX * 16)\n+#define X86_64_VARARGS_SIZE (X86_64_REGPARM_MAX * UNITS_PER_WORD + X86_64_SSE_REGPARM_MAX * 16)\n \n /* Define the structure for the machine field in struct function.  */\n \n@@ -2306,11 +2310,11 @@ override_options (void)\n     }\n   else\n     {\n-      /* For TARGET_64BIT_MS_ABI, force pic on, in order to enable the\n+      /* For TARGET_64BIT and MS_ABI, force pic on, in order to enable the\n \t use of rip-relative addressing.  This eliminates fixups that\n \t would otherwise be needed if this object is to be placed in a\n \t DLL, and is essentially just as efficient as direct addressing.  */\n-      if (TARGET_64BIT_MS_ABI)\n+      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\n \tix86_cmodel = CM_SMALL_PIC, flag_pic = 1;\n       else if (TARGET_64BIT)\n \tix86_cmodel = flag_pic ? CM_SMALL_PIC : CM_SMALL;\n@@ -2761,8 +2765,9 @@ override_options (void)\n     set_param_value (\"l2-cache-size\", ix86_cost->l2_cache_size);\n \n   /* If using typedef char *va_list, signal that __builtin_va_start (&ap, 0)\n-     can be optimized to ap = __builtin_next_arg (0).  */\n-  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n+     can be optimized to ap = __builtin_next_arg (0).\n+     For abi switching it should be corrected.  */\n+  if (!TARGET_64BIT || DEFAULT_ABI == MS_ABI)\n     targetm.expand_builtin_va_start = NULL;\n }\n \f\n@@ -3160,7 +3165,7 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n   if (TARGET_64BIT)\n     {\n       /* Do not warn when emulating the MS ABI.  */\n-      if (!TARGET_64BIT_MS_ABI)\n+      if (TREE_CODE (*node) != FUNCTION_TYPE || !ix86_function_type_abi (*node))\n \twarning (OPT_Wattributes, \"%qs attribute ignored\",\n \t         IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n@@ -3263,7 +3268,11 @@ ix86_function_regparm (const_tree type, const_tree decl)\n   static bool error_issued;\n \n   if (TARGET_64BIT)\n-    return regparm;\n+    {\n+      if (ix86_function_type_abi (type) == DEFAULT_ABI)\n+        return regparm;\n+      return DEFAULT_ABI != SYSV_ABI ? 6 : 4; /* $$$$ */\n+    }\n \n   attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (type));\n   if (attr)\n@@ -3494,11 +3503,15 @@ ix86_function_arg_regno_p (int regno)\n         return true;\n     }\n \n+  /* TODO: The function should depend on current function ABI but\n+     builtins.c would need updating then. Therefore we use the\n+     default ABI.  */\n+\n   /* RAX is used as hidden argument to va_arg functions.  */\n-  if (!TARGET_64BIT_MS_ABI && regno == AX_REG)\n+  if (DEFAULT_ABI == SYSV_ABI && regno == AX_REG)\n     return true;\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (DEFAULT_ABI == MS_ABI)\n     parm_regs = x86_64_ms_abi_int_parameter_registers;\n   else\n     parm_regs = x86_64_int_parameter_registers;\n@@ -3523,6 +3536,57 @@ ix86_must_pass_in_stack (enum machine_mode mode, const_tree type)\n \t  && type && TREE_CODE (type) != VECTOR_TYPE);\n }\n \n+/* It returns the size, in bytes, of the area reserved for arguments passed\n+   in registers for the function represented by fndecl dependent to the used\n+   abi format.  */\n+unsigned int\n+ix86_reg_parm_stack_space (const_tree fndecl)\n+{\n+  int call_abi = 0;\n+  /* For libcalls it is possible that there is no fndecl at hand.\n+     Therefore assume for this case the default abi of the target.  */\n+  if (!fndecl)\n+    call_abi = DEFAULT_ABI;\n+  else\n+    call_abi = ix86_function_abi (fndecl);\n+  if (call_abi == 1)\n+    return 32;\n+  return 0;\n+}\n+\n+/* Returns value SYSV_ABI, MS_ABI dependent on fntype, specifying the\n+   call abi used.  */\n+int\n+ix86_function_type_abi (const_tree fntype)\n+{\n+  if (TARGET_64BIT && fntype != NULL)\n+    {\n+      if (DEFAULT_ABI == SYSV_ABI)\n+        return lookup_attribute (\"ms_abi\", TYPE_ATTRIBUTES (fntype)) ? MS_ABI : SYSV_ABI;\n+      else\n+        return lookup_attribute (\"sysv_abi\", TYPE_ATTRIBUTES (fntype)) ? SYSV_ABI : MS_ABI;\n+    }\n+  return DEFAULT_ABI;\n+}\n+\n+int\n+ix86_function_abi (const_tree fndecl)\n+{\n+  if (! fndecl)\n+    return DEFAULT_ABI;\n+  return ix86_function_type_abi (TREE_TYPE (fndecl));\n+}\n+\n+/* Returns value SYSV_ABI, MS_ABI dependent on cfun, specifying the\n+   call abi used.  */\n+int\n+ix86_cfun_abi (void)\n+{\n+  if (! cfun || ! TARGET_64BIT)\n+    return DEFAULT_ABI;\n+  return cfun->machine->call_abi;\n+}\n+\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n@@ -3538,8 +3602,20 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \n   /* Set up the number of registers to use for passing arguments.  */\n   cum->nregs = ix86_regparm;\n+  if (TARGET_64BIT)\n+    {\n+      if (cum->call_abi != DEFAULT_ABI)\n+        cum->nregs = DEFAULT_ABI != SYSV_ABI ? 6 : 4;\n+    }\n   if (TARGET_SSE)\n-    cum->sse_nregs = SSE_REGPARM_MAX;\n+    {\n+      cum->sse_nregs = SSE_REGPARM_MAX;\n+      if (TARGET_64BIT)\n+        {\n+          if (cum->call_abi != DEFAULT_ABI)\n+            cum->sse_nregs = DEFAULT_ABI != SYSV_ABI ? 8 : 4; /* $$$$ */\n+        }\n+    }\n   if (TARGET_MMX)\n     cum->mmx_nregs = MMX_REGPARM_MAX;\n   cum->warn_sse = true;\n@@ -4325,7 +4401,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (type)\n     mode = type_natural_mode (type);\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)\n     function_arg_advance_ms_64 (cum, bytes, words);\n   else if (TARGET_64BIT)\n     function_arg_advance_64 (cum, mode, type, words);\n@@ -4452,8 +4528,9 @@ function_arg_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (mode == VOIDmode)\n     return GEN_INT (cum->maybe_vaarg\n \t\t    ? (cum->sse_nregs < 0\n-\t\t       ? SSE_REGPARM_MAX\n-\t\t       : cum->sse_regno)\n+\t\t       ? (cum->call_abi == DEFAULT_ABI ? SSE_REGPARM_MAX\n+\t\t           \t\t\t       : (DEFAULT_ABI != SYSV_ABI ? 8 : 4)) /* $$$$ */\n+ \t       : cum->sse_regno)\n \t\t    : -1);\n \n   return construct_container (mode, orig_mode, type, 0, cum->nregs,\n@@ -4527,7 +4604,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n   if (type && TREE_CODE (type) == VECTOR_TYPE)\n     mode = type_natural_mode (type);\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)\n     return function_arg_ms_64 (cum, mode, omode, named, bytes);\n   else if (TARGET_64BIT)\n     return function_arg_64 (cum, mode, omode, type);\n@@ -4547,7 +4624,7 @@ ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   /* See Windows x64 Software Convention.  */\n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)\n     {\n       int msize = (int) GET_MODE_SIZE (mode);\n       if (type)\n@@ -4674,7 +4751,10 @@ ix86_function_value_regno_p (int regno)\n       return true;\n \n     case FIRST_FLOAT_REG:\n-      if (TARGET_64BIT_MS_ABI)\n+      /* TODO: The function should depend on current function ABI but\n+       builtins.c would need updating then. Therefore we use the\n+       default ABI.  */\n+      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\n \treturn false;\n       return TARGET_FLOAT_RETURNS_IN_80387;\n \n@@ -4765,7 +4845,7 @@ function_value_64 (enum machine_mode orig_mode, enum machine_mode mode,\n     }\n \n   ret = construct_container (mode, orig_mode, valtype, 1,\n-\t\t\t     REGPARM_MAX, SSE_REGPARM_MAX,\n+\t\t\t     X86_64_REGPARM_MAX, X86_64_SSE_REGPARM_MAX,\n \t\t\t     x86_64_int_return_registers, 0);\n \n   /* For zero sized structures, construct_container returns NULL, but we\n@@ -4813,7 +4893,7 @@ ix86_function_value_1 (const_tree valtype, const_tree fntype_or_decl,\n     fn = fntype_or_decl;\n   fntype = fn ? TREE_TYPE (fn) : fntype_or_decl;\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && ix86_function_type_abi (fntype) == MS_ABI)\n     return function_value_ms_64 (orig_mode, mode);\n   else if (TARGET_64BIT)\n     return function_value_64 (orig_mode, mode, valtype);\n@@ -4901,17 +4981,21 @@ return_in_memory_ms_64 (const_tree type, enum machine_mode mode)\n   return (size != 1 && size != 2 && size != 4 && size != 8);\n }\n \n-bool\n+static bool\n ix86_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n+#ifdef SUBTARGET_RETURN_IN_MEMORY\n+  return SUBTARGET_RETURN_IN_MEMORY (type, fntype);\n+#else\n   const enum machine_mode mode = type_natural_mode (type);\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && ix86_function_type_abi (fntype) == MS_ABI)\n     return return_in_memory_ms_64 (type, mode);\n   else if (TARGET_64BIT)\n     return return_in_memory_64 (type, mode);\n   else\n     return return_in_memory_32 (type, mode);\n+#endif\n }\n \n /* Return false iff TYPE is returned in memory.  This version is used\n@@ -4951,20 +5035,6 @@ ix86_sol10_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED\n   return size > 12;\n }\n \n-bool\n-ix86_i386elf_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n-{\n-  return (TYPE_MODE (type) == BLKmode\n-\t  || (VECTOR_MODE_P (TYPE_MODE (type)) && int_size_in_bytes (type) == 8));\n-}\n-\n-bool\n-ix86_i386interix_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n-{\n-  return (TYPE_MODE (type) == BLKmode\n-          || (AGGREGATE_TYPE_P (type) && int_size_in_bytes(type) > 8 ));\n-}\n-\n /* When returning SSE vector types, we have a choice of either\n      (1) being abi incompatible with a -march switch, or\n      (2) generating an error.\n@@ -5020,7 +5090,7 @@ ix86_build_builtin_va_list (void)\n   tree f_gpr, f_fpr, f_ovf, f_sav, record, type_decl;\n \n   /* For i386 we use plain pointer to argument area.  */\n-  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n+  if (!TARGET_64BIT || ix86_cfun_abi () == MS_ABI)\n     return build_pointer_type (char_type_node);\n \n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n@@ -5068,6 +5138,10 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n   rtx nsse_reg;\n   alias_set_type set;\n   int i;\n+  int regparm = ix86_regparm;\n+\n+  if((cum ? cum->call_abi : ix86_cfun_abi ()) != DEFAULT_ABI)\n+    regparm = DEFAULT_ABI != SYSV_ABI ? 6 : 4; /* $$$$ */\n \n   if (! cfun->va_list_gpr_size && ! cfun->va_list_fpr_size)\n     return;\n@@ -5087,7 +5161,7 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n   set = get_varargs_alias_set ();\n \n   for (i = cum->regno;\n-       i < ix86_regparm\n+       i < regparm\n        && i < cum->regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n        i++)\n     {\n@@ -5190,7 +5264,7 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (stdarg_p (fntype))\n     function_arg_advance (&next_cum, mode, type, 1);\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if ((cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)\n     setup_incoming_varargs_ms_64 (&next_cum);\n   else\n     setup_incoming_varargs_64 (&next_cum);\n@@ -5207,7 +5281,7 @@ ix86_va_start (tree valist, rtx nextarg)\n   tree type;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n+  if (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI)\n     {\n       std_expand_builtin_va_start (valist, nextarg);\n       return;\n@@ -5286,7 +5360,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   enum machine_mode nat_mode;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n+  if (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI)\n     return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n@@ -5308,7 +5382,8 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \n   nat_mode = type_natural_mode (type);\n   container = construct_container (nat_mode, TYPE_MODE (type), type, 0,\n-\t\t\t\t   REGPARM_MAX, SSE_REGPARM_MAX, intreg, 0);\n+\t\t\t\t   X86_64_REGPARM_MAX, X86_64_SSE_REGPARM_MAX,\n+\t\t\t\t   intreg, 0);\n \n   /* Pull the value out of the saved registers.  */\n \n@@ -5386,8 +5461,8 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       if (needed_sseregs)\n \t{\n \t  t = build_int_cst (TREE_TYPE (fpr),\n-\t\t\t     (SSE_REGPARM_MAX - needed_sseregs + 1) * 16\n-\t\t\t     + REGPARM_MAX * 8);\n+\t\t\t     (X86_64_SSE_REGPARM_MAX - needed_sseregs + 1) * 16\n+\t\t\t     + X86_64_REGPARM_MAX * 8);\n \t  t = build2 (GE_EXPR, boolean_type_node, fpr, t);\n \t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n \t  t = build3 (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n@@ -6513,9 +6588,9 @@ ix86_expand_prologue (void)\n       bool eax_live;\n       rtx t;\n \n-      gcc_assert (!TARGET_64BIT || TARGET_64BIT_MS_ABI);\n+      gcc_assert (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI);\n \n-      if (TARGET_64BIT_MS_ABI)\n+      if (cfun->machine->call_abi == MS_ABI)\n \teax_live = false;\n       else\n \teax_live = ix86_eax_live_at_start_p ();\n@@ -8325,7 +8400,7 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n #endif\n \t  assemble_name (file, name);\n \t}\n-      if (!TARGET_MACHO && !TARGET_64BIT_MS_ABI\n+      if (!TARGET_MACHO && !(TARGET_64BIT && DEFAULT_ABI == MS_ABI)\n \t  && code == 'P' && ! SYMBOL_REF_LOCAL_P (x))\n \tfputs (\"@PLT\", file);\n       break;\n@@ -16418,6 +16493,7 @@ ix86_init_machine_status (void)\n   f = GGC_CNEW (struct machine_function);\n   f->use_fast_prologue_epilogue_nregs = -1;\n   f->tls_descriptor_call_expanded_p = 0;\n+  f->call_abi = DEFAULT_ABI;\n \n   return f;\n }\n@@ -22994,7 +23070,7 @@ x86_this_parameter (tree function)\n     {\n       const int *parm_regs;\n \n-      if (TARGET_64BIT_MS_ABI)\n+      if (ix86_function_type_abi (type) == MS_ABI)\n         parm_regs = x86_64_ms_abi_int_parameter_registers;\n       else\n         parm_regs = x86_64_int_parameter_registers;\n@@ -23162,7 +23238,7 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n \toutput_asm_insn (\"jmp\\t%P0\", xops);\n       /* All thunks should be in the same object as their target,\n \t and thus binds_local_p should be true.  */\n-      else if (TARGET_64BIT_MS_ABI)\n+      else if (TARGET_64BIT && cfun->machine->call_abi == MS_ABI)\n \tgcc_unreachable ();\n       else\n \t{\n@@ -23245,7 +23321,7 @@ x86_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)\n       fprintf (file, \"\\tleaq\\t%sP%d@(%%rip),%%r11\\n\", LPREFIX, labelno);\n #endif\n \n-      if (!TARGET_64BIT_MS_ABI && flag_pic)\n+      if (DEFAULT_ABI == SYSV_ABI && flag_pic)\n \tfprintf (file, \"\\tcall\\t*%s@GOTPCREL(%%rip)\\n\", MCOUNT_NAME);\n       else\n \tfprintf (file, \"\\tcall\\t%s\\n\", MCOUNT_NAME);\n@@ -25795,6 +25871,9 @@ x86_builtin_vectorization_cost (bool runtime_test)\n }\n \n /* Initialize the GCC target structure.  */\n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY ix86_return_in_memory\n+\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE ix86_attribute_table\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES"}, {"sha": "45ce3c3df7657ae5edbd1b983f7d0236f46f52b1", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -446,7 +446,17 @@ extern tree x86_mfence;\n #define TARGET_MACHO 0\n \n /* Likewise, for the Windows 64-bit ABI.  */\n-#define TARGET_64BIT_MS_ABI 0\n+#define TARGET_64BIT_MS_ABI (TARGET_64BIT && ix86_cfun_abi () == MS_ABI)\n+\n+/* Available call abi.  */\n+enum\n+{\n+  SYSV_ABI = 0,\n+  MS_ABI = 1\n+};\n+\n+/* The default abi form used by target.  */\n+#define DEFAULT_ABI SYSV_ABI\n \n /* Subtargets may reset this to 1 in order to enable 96-bit long double\n    with the rounding mode forced to 53 bits.  */\n@@ -804,7 +814,8 @@ enum target_cpu_default\n #define PARM_BOUNDARY BITS_PER_WORD\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY BITS_PER_WORD\n+#define STACK_BOUNDARY\t(TARGET_64BIT && DEFAULT_ABI == MS_ABI ? 128 \\\n+\t\t\t\t\t\t\t       : BITS_PER_WORD)\n \n /* Boundary (in *bits*) on which the stack pointer prefers to be\n    aligned; the compiler cannot rely on having this alignment.  */\n@@ -1029,6 +1040,35 @@ enum target_cpu_default\n #define ORDER_REGS_FOR_LOCAL_ALLOC x86_order_regs_for_local_alloc ()\n \n \n+/* regclass.c  */\n+extern void init_regs (void);\n+\n+#define OVERRIDE_ABI_FORMAT(FNDECL) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+    if (FNDECL == NULL)\t\t\t\t\t\t\t\\\n+      cfun->machine->call_abi = DEFAULT_ABI;\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      cfun->machine->call_abi = ix86_function_type_abi (TREE_TYPE (FNDECL));\t\\\n+    if (cfun->machine->call_abi == MS_ABI && call_used_regs)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\t\\\n+        if (call_used_regs[4 /*RSI*/] != 0 || call_used_regs[5 /*RDI*/] != 0) \\\n+          {\t\t\t\t\t\t\t\t\\\n+\t    call_used_regs[4 /*RSI*/] = 0;                              \\\n+\t    call_used_regs[5 /*RDI*/] = 0;                              \\\n+            init_regs ();\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else if (TARGET_64BIT && call_used_regs)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        if (call_used_regs[4 /*RSI*/] != 1 || call_used_regs[5 /*RDI*/] != 1)\t\\\n+          {\t\t\t\t\t\t\t\t\\\n+\t    call_used_regs[4 /*RSI*/] = 1;                              \\\n+\t    call_used_regs[5 /*RDI*/] = 1;                              \\\n+            init_regs ();\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+   } while (0)\n+\n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n@@ -1079,11 +1119,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \tfor (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\t\t\\\n \t  reg_names[i] = \"\";\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_64BIT_MS_ABI)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        call_used_regs[4 /*RSI*/] = 0;                                  \\\n-        call_used_regs[5 /*RDI*/] = 0;                                  \\\n-      }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -1261,25 +1296,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define GOT_SYMBOL_NAME \"_GLOBAL_OFFSET_TABLE_\"\n \n-/* A C expression which can inhibit the returning of certain function\n-   values in registers, based on the type of value.  A nonzero value\n-   says to return the function value in memory, just as large\n-   structures are always returned.  Here TYPE will be a C expression\n-   of type `tree', representing the data type of the value.\n-\n-   Note that values of mode `BLKmode' must be explicitly handled by\n-   this macro.  Also, the option `-fpcc-struct-return' takes effect\n-   regardless of this macro.  On most systems, it is possible to\n-   leave the macro undefined; this causes a default definition to be\n-   used, whose value is the constant 1 for `BLKmode' values, and 0\n-   otherwise.\n-\n-   Do not use this macro to indicate that structures and unions\n-   should always be returned in memory.  You should instead use\n-   `DEFAULT_PCC_STRUCT_RETURN' to indicate this.  */\n-\n-#define TARGET_RETURN_IN_MEMORY ix86_return_in_memory\n-\n /* This is overridden by <cygwin.h>.  */\n #define MS_AGGREGATE_RETURN 0\n \n@@ -1628,7 +1644,11 @@ enum reg_class\n    This space can be allocated by the caller, or be a part of the\n    machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE' says\n    which.  */\n-#define REG_PARM_STACK_SPACE(FNDECL) 0\n+#define REG_PARM_STACK_SPACE(FNDECL) ix86_reg_parm_stack_space (FNDECL)\n+\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) (ix86_function_type_abi (FNTYPE) == MS_ABI ? 1 : 0)\n+\n+extern unsigned int ix86_reg_parm_stack_space (const_tree);\n \n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call.\n@@ -1690,6 +1710,8 @@ typedef struct ix86_args {\n   int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts.  */\n   int float_in_sse;\t\t/* 1 if in 32-bit mode SFmode (2 for DFmode) should\n \t\t\t\t   be passed in SSE registers.  Otherwise 0.  */\n+  int call_abi;\t\t\t/* Set to SYSV_ABI for sysv abi. Otherwise\n+ \t\t\t\t   MS_ABI for ms abi.  */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -2467,6 +2489,9 @@ struct machine_function GTY(())\n      ix86_current_function_calls_tls_descriptor macro for a better\n      approximation.  */\n   int tls_descriptor_call_expanded_p;\n+  /* This value is used for amd64 targets and specifies the current abi\n+     to be used. MS_ABI means ms abi. Otherwise SYSV_ABI means sysv abi.  */\n+  int call_abi;\n };\n \n #define ix86_stack_locals (cfun->machine->stack_locals)"}, {"sha": "d2fedad1b59c4792c18b4e283391c1f0e597d973", "filename": "gcc/config/i386/i386elf.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fi386elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386elf.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -29,8 +29,9 @@ along with GCC; see the file COPYING3.  If not see\n /* The ELF ABI for the i386 says that records and unions are returned\n    in memory.  */\n \n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY ix86_i386elf_return_in_memory\n+#define SUBTARGET_RETURN_IN_MEMORY(TYPE, FNTYPE) \\\n+\t(TYPE_MODE (TYPE) == BLKmode \\\n+\t || (VECTOR_MODE_P (TYPE_MODE (TYPE)) && int_size_in_bytes (TYPE) == 8))\n \n #undef CPP_SPEC\n #define CPP_SPEC \"\""}, {"sha": "7628896bc6a443df688bf35cb582c9e070b89926", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -38,7 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n       builtin_define_std (\"WINNT\");\t\t\t\t\\\n       builtin_define_with_int_value (\"_INTEGRAL_MAX_BITS\",\t\\\n \t\t\t\t     TYPE_PRECISION (intmax_type_node));\\\n-      if (TARGET_64BIT_MS_ABI)\t\t\t\t\t\\\n+      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n \t  builtin_define (\"__MINGW64__\");\t\t\t\\\n \t  builtin_define_std (\"WIN64\");\t\t\t\t\\"}, {"sha": "15959af70d31ab14639fc3b4609661e4dc2d0ba3", "filename": "gcc/config/i386/ptx4-i.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fptx4-i.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -27,8 +27,9 @@ along with GCC; see the file COPYING3.  If not see\n /* The svr4 ABI for the i386 says that records and unions are returned\n    in memory.  */\n \n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY ix86_i386elf_return_in_memory\n+#define SUBTARGET_RETURN_IN_MEMORY(TYPE, FNTYPE) \\\n+\t(TYPE_MODE (TYPE) == BLKmode \\\n+\t || (VECTOR_MODE_P (TYPE_MODE (TYPE)) && int_size_in_bytes (TYPE) == 8));\n \n #define TARGET_OS_CPP_BUILTINS()\t\t\\\n   do\t\t\t\t\t\t\\"}, {"sha": "3215c5d92c39c63ab82ce8d722ce8275101f710c", "filename": "gcc/config/i386/sol2-10.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fsol2-10.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fsol2-10.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsol2-10.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -110,5 +110,5 @@ along with GCC; see the file COPYING3.  If not see\n #undef TARGET_ASM_NAMED_SECTION\n #define TARGET_ASM_NAMED_SECTION i386_solaris_elf_named_section\n \n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY ix86_sol10_return_in_memory\n+#define SUBTARGET_RETURN_IN_MEMORY(TYPE, FNTYPE) \\\n+\tix86_sol10_return_in_memory (TYPE, FNTYPE)"}, {"sha": "267785be320d51aa43a57d8cc870ccfde8c42b5f", "filename": "gcc/config/i386/sysv4.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsysv4.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -25,8 +25,9 @@ along with GCC; see the file COPYING3.  If not see\n /* The svr4 ABI for the i386 says that records and unions are returned\n    in memory.  */\n \n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY ix86_i386elf_return_in_memory\n+#define SUBTARGET_RETURN_IN_MEMORY(TYPE, FNTYPE) \\\n+\t(TYPE_MODE (TYPE) == BLKmode \\\n+\t || (VECTOR_MODE_P (TYPE_MODE (TYPE)) && int_size_in_bytes (TYPE) == 8));\n \n /* Output at beginning of assembler file.  */\n /* The .file command should always begin the output.  */"}, {"sha": "4bf023e5e435dffe55a77e557b24379d045a1a21", "filename": "gcc/config/i386/vx-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fvx-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf/gcc%2Fconfig%2Fi386%2Fvx-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fvx-common.h?ref=3b23a6d3910d7b3cffaea9d66ade2e1c1e4f4dbf", "patch": "@@ -22,5 +22,5 @@ along with GCC; see the file COPYING3.  If not see\n \n /* VxWorks uses the same ABI as Solaris 10.  */\n \n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY ix86_sol10_return_in_memory\n+#define SUBTARGET_RETURN_IN_MEMORY(TYPE, FNTYPE) \\\n+\tix86_sol10_return_in_memory (TYPE, FNTYPE)"}]}