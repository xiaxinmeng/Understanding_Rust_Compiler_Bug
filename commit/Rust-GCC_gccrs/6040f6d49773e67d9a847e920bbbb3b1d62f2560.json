{"sha": "6040f6d49773e67d9a847e920bbbb3b1d62f2560", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA0MGY2ZDQ5NzczZTY3ZDlhODQ3ZTkyMGJiYmIzYjFkNjJmMjU2MA==", "commit": {"author": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2016-12-17T00:18:32Z"}, "committer": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2016-12-17T00:18:32Z"}, "message": "byte-in-either-range-0.c: New test.\n\ngcc/testsuite/ChangeLog:\n\n2016-12-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* gcc.target/powerpc/byte-in-either-range-0.c: New test.\n\t* gcc.target/powerpc/byte-in-either-range-1.c: New test.\n\t* gcc.target/powerpc/byte-in-range-0.c: New test.\n\t* gcc.target/powerpc/byte-in-range-1.c: New test.\n\t* gcc.target/powerpc/byte-in-set-0.c: New test.\n\t* gcc.target/powerpc/byte-in-set-1.c: New test.\n\t* gcc.target/powerpc/byte-in-set-2.c: New test.\n\n\ngcc/ChangeLog:\n\n2016-12-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* config/rs6000/altivec.md (UNSPEC_CMPRB): New unspec value.\n\t(UNSPEC_CMPRB2): New unspec value.\n\t(UNSPEC_CMPEQB): New unspec value.\n\t(cmprb): New expansion.\n\t(*cmprb_internal): New insn.\n\t(*setb_internal): New insn.\n\t(cmprb2): New expansion.\n\t(*cmprb2_internal): New insn.\n\t(cmpeqb): New expansion.\n\t(*cmpeqb_internal): New insn.\n\t* config/rs6000/rs6000-builtin.def (BU_P9_2): New macro.\n\t(BU_P9_64BIT_2): Likewise.\n\t(BU_P9_OVERLOAD_2): Likewise.\n\t(CMPRB): Add byte-in-range built-in function.\n\t(CMBRB2): Add byte-in-either-range built-in function.\n\t(CMPEQB): Add byte-in-set built-in function.\n\t(CMPRB): Add overload support for byte-in-range function.\n\t(CMPRB2): Add overload support for byte-in-either-range function.\n\t(CMPEQB): Add overload support for byte-in-set built-in function.\n\t* config/rs6000/rs6000-c.c (P9_BUILTIN_CMPRB): Macro expansion to\n\tdefine argument types for new builtin. \n\t(P9_BUILTIN_CMPRB2): Likewise.\n\t(P9_BUILTIN_CMPEQB): Likewise.\n\t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Rearrange\n\tthe order of presentation for certain built-in functions\n\t(scalar_extract_exp, scalar_extract_sig, scalar_insert_exp)\n\t(scalar_cmp_exp_gt, scalar_cmp_exp_lt, scalar_cmp_exp_eq)\n\t(scalar_cmp_exp_unordered, scalar_test_data_class)\n\t(scalar_test_neg) to improve locality and flow.  Document\n\tthe new __builtin_scalar_byte_in_set,\n\t__builtin_scalar_byte_in_range, and\n\t__builtin_scalar_byte_in_either_range functions.\n\nFrom-SVN: r243770", "tree": {"sha": "ea9851d8e7e5138b16ac4e64d27516b89184c168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea9851d8e7e5138b16ac4e64d27516b89184c168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6040f6d49773e67d9a847e920bbbb3b1d62f2560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6040f6d49773e67d9a847e920bbbb3b1d62f2560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6040f6d49773e67d9a847e920bbbb3b1d62f2560", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6040f6d49773e67d9a847e920bbbb3b1d62f2560/comments", "author": null, "committer": null, "parents": [{"sha": "68dde2bfdd3fe5e400a0155c421066902a634b8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68dde2bfdd3fe5e400a0155c421066902a634b8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68dde2bfdd3fe5e400a0155c421066902a634b8d"}], "stats": {"total": 460, "additions": 443, "deletions": 17}, "files": [{"sha": "889574146a4a3b064663af858c2513a20f635781", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -1,3 +1,38 @@\n+2016-12-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* config/rs6000/altivec.md (UNSPEC_CMPRB): New unspec value.\n+\t(UNSPEC_CMPRB2): New unspec value.\n+\t(UNSPEC_CMPEQB): New unspec value.\n+\t(cmprb): New expansion.\n+\t(*cmprb_internal): New insn.\n+\t(*setb_internal): New insn.\n+\t(cmprb2): New expansion.\n+\t(*cmprb2_internal): New insn.\n+\t(cmpeqb): New expansion.\n+\t(*cmpeqb_internal): New insn.\n+\t* config/rs6000/rs6000-builtin.def (BU_P9_2): New macro.\n+\t(BU_P9_64BIT_2): Likewise.\n+\t(BU_P9_OVERLOAD_2): Likewise.\n+\t(CMPRB): Add byte-in-range built-in function.\n+\t(CMBRB2): Add byte-in-either-range built-in function.\n+\t(CMPEQB): Add byte-in-set built-in function.\n+\t(CMPRB): Add overload support for byte-in-range function.\n+\t(CMPRB2): Add overload support for byte-in-either-range function.\n+\t(CMPEQB): Add overload support for byte-in-set built-in function.\n+\t* config/rs6000/rs6000-c.c (P9_BUILTIN_CMPRB): Macro expansion to\n+\tdefine argument types for new builtin. \n+\t(P9_BUILTIN_CMPRB2): Likewise.\n+\t(P9_BUILTIN_CMPEQB): Likewise.\n+\t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Rearrange\n+\tthe order of presentation for certain built-in functions\n+\t(scalar_extract_exp, scalar_extract_sig, scalar_insert_exp)\n+\t(scalar_cmp_exp_gt, scalar_cmp_exp_lt, scalar_cmp_exp_eq)\n+\t(scalar_cmp_exp_unordered, scalar_test_data_class)\n+\t(scalar_test_neg) to improve locality and flow.  Document\n+\tthe new __builtin_scalar_byte_in_set,\n+\t__builtin_scalar_byte_in_range, and\n+\t__builtin_scalar_byte_in_either_range functions.\n+\n 2016-12-16  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.md: New define_split above bswap<mode>2."}, {"sha": "6c0a5953d7cd553c59cdd68fe1c98e8cf0986fc6", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -153,6 +153,9 @@\n    UNSPEC_BCDADD\n    UNSPEC_BCDSUB\n    UNSPEC_BCD_OVERFLOW\n+   UNSPEC_CMPRB\n+   UNSPEC_CMPRB2\n+   UNSPEC_CMPEQB\n ])\n \n (define_c_enum \"unspecv\"\n@@ -3707,6 +3710,189 @@\n   \"darn %0,1\"\n   [(set_attr \"type\" \"integer\")])\n \n+;; Test byte within range.\n+;;\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the range specified by operand 2.\n+;; The bytes of operand 2 are organized as xx:xx:hi:lo.\n+;;\n+;; Return in target register operand 0 a value of 1 if lo <= vv and\n+;; vv <= hi.  Otherwise, set register operand 0 to 0.\n+;;\n+;; Though the instructions to which this expansion maps operate on\n+;; 64-bit registers, the current implementation only operates on\n+;; SI-mode operands as the high-order bits provide no information\n+;; that is not already available in the low-order bits.  To avoid the\n+;; costs of data widening operations, future enhancements might allow\n+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n+(define_expand \"cmprb\"\n+  [(set (match_dup 3)\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPRB))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(if_then_else:SI (lt (match_dup 3)\n+\t\t\t     (const_int 0))\n+\t\t\t (const_int -1)\n+\t\t\t (if_then_else (gt (match_dup 3)\n+\t\t\t\t\t   (const_int 0))\n+\t\t\t\t       (const_int 1)\n+\t\t\t\t       (const_int 0))))]\n+  \"TARGET_P9_MISC\"\n+{\n+  operands[3] = gen_reg_rtx (CCmode);\n+})\n+\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the range specified by operand 2.\n+;; The bytes of operand 2 are organized as xx:xx:hi:lo.\n+;;\n+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if\n+;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other\n+;; 3 bits of the target CR register are all set to 0.\n+(define_insn \"*cmprb_internal\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPRB))]\n+  \"TARGET_P9_MISC\"\n+  \"cmprb %0,0,%1,%2\"\n+  [(set_attr \"type\" \"logical\")])\n+\n+;; Set operand 0 register to -1 if the LT bit (0x8) of condition\n+;; register operand 1 is on.  Otherwise, set operand 0 register to 1\n+;; if the GT bit (0x4) of condition register operand 1 is on.\n+;; Otherwise, set operand 0 to 0.  Note that the result stored into\n+;; register operand 0 is non-zero iff either the LT or GT bits are on\n+;; within condition register operand 1.\n+(define_insn \"*setb_internal\"\n+   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t (if_then_else:SI (lt (match_operand:CC 1 \"cc_reg_operand\" \"y\")\n+\t\t\t      (const_int 0))\n+\t\t\t  (const_int -1)\n+\t\t\t  (if_then_else (gt (match_dup 1)\n+\t\t\t\t\t    (const_int 0))\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 0))))]\n+  \"TARGET_P9_MISC\"\n+  \"setb %0,%1\"\n+  [(set_attr \"type\" \"logical\")])\n+\n+;; Test byte within two ranges.\n+;;\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the range specified by operand 2.\n+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.\n+;;\n+;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and\n+;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register\n+;; operand 0 to 0.\n+;;\n+;; Though the instructions to which this expansion maps operate on\n+;; 64-bit registers, the current implementation only operates on\n+;; SI-mode operands as the high-order bits provide no information\n+;; that is not already available in the low-order bits.  To avoid the\n+;; costs of data widening operations, future enhancements might allow\n+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n+(define_expand \"cmprb2\"\n+  [(set (match_dup 3)\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPRB2))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(if_then_else:SI (lt (match_dup 3)\n+\t\t\t     (const_int 0))\n+\t\t\t (const_int -1)\n+\t\t\t (if_then_else (gt (match_dup 3)\n+\t\t\t\t\t   (const_int 0))\n+\t\t\t\t       (const_int 1)\n+\t\t\t\t       (const_int 0))))]\n+  \"TARGET_P9_MISC\"\n+{\n+  operands[3] = gen_reg_rtx (CCmode);\n+})\n+\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the ranges specified by operand 2.\n+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.\n+;;\n+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if\n+;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).\n+;; Otherwise, set the GT bit to 0.  The other 3 bits of the target\n+;; CR register are all set to 0.\n+(define_insn \"*cmprb2_internal\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPRB2))]\n+  \"TARGET_P9_MISC\"\n+  \"cmprb %0,1,%1,%2\"\n+  [(set_attr \"type\" \"logical\")])\n+\n+;; Test byte membership within set of 8 bytes.\n+;;\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the set specified by operand 2.\n+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.\n+;;\n+;; Return in target register operand 0 a value of 1 if vv equals one\n+;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set\n+;; register operand 0 to 0.  Note that the 8 byte values held within\n+;; operand 2 need not be unique.\n+;;\n+;; Though the instructions to which this expansion maps operate on\n+;; 64-bit registers, the current implementation requires that operands\n+;; 0 and 1 have mode SI as the high-order bits provide no information\n+;; that is not already available in the low-order bits.  To avoid the\n+;; costs of data widening operations, future enhancements might allow\n+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n+(define_expand \"cmpeqb\"\n+  [(set (match_dup 3)\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPEQB))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(if_then_else:SI (lt (match_dup 3)\n+\t\t\t     (const_int 0))\n+\t\t\t (const_int -1)\n+\t\t\t (if_then_else (gt (match_dup 3)\n+\t\t\t\t\t   (const_int 0))\n+\t\t\t\t       (const_int 1)\n+\t\t\t\t       (const_int 0))))]\n+  \"TARGET_P9_MISC && TARGET_64BIT\"\n+{\n+  operands[3] = gen_reg_rtx (CCmode);\n+})\n+\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the set specified by operand 2.\n+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.\n+;;\n+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv\n+;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,\n+;; set the GT bit to zero.  The other 3 bits of the target CR register\n+;; are all set to 0.\n+(define_insn \"*cmpeqb_internal\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n+\t (unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n+\t  UNSPEC_CMPEQB))]\n+  \"TARGET_P9_MISC && TARGET_64BIT\"\n+  \"cmpeqb %0,%1,%2\"\n+  [(set_attr \"type\" \"logical\")])\n+\n (define_expand \"bcd<bcd_add_sub>_<code>\"\n   [(parallel [(set (reg:CCFP CR6_REGNO)\n \t\t   (compare:CCFP"}, {"sha": "f29b226b9ab263c10786093f5dca1c498d11a537", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -898,6 +898,23 @@\n \t\t     | RS6000_BTC_PREDICATE),\t\t\t\t\\\n \t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n \n+#define BU_P9_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (P9_BUILTIN_SCALAR_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_scalar_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P9_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P9_64BIT_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (P9_BUILTIN_SCALAR_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_scalar_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P9_VECTOR\t\t\t\t\\\n+\t\t    | RS6000_BTM_64BIT,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n #define BU_P9V_OVERLOAD_1(ENUM, NAME)\t\t\t\t\t\\\n   RS6000_BUILTIN_1 (P9V_BUILTIN_VEC_ ## ENUM,\t\t/* ENUM */\t\\\n \t\t    \"__builtin_vec_\" NAME,\t\t/* NAME */\t\\\n@@ -921,6 +938,15 @@\n \t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n \t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n \t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n+#define BU_P9_OVERLOAD_2(ENUM, NAME)\t\t\t\t\t\\\n+  RS6000_BUILTIN_2 (P9_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P9_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n #endif\n \n \f\n@@ -2152,6 +2178,16 @@ BU_P9V_OVERLOAD_1 (VPRTYBD,\t\"vprtybd\")\n BU_P9V_OVERLOAD_1 (VPRTYBQ,\t\"vprtybq\")\n BU_P9V_OVERLOAD_1 (VPRTYBW,\t\"vprtybw\")\n \n+/* 2 argument functions added in ISA 3.0 (power9).  */\n+BU_P9_2 (CMPRB,\t\"byte_in_range\",\tCONST,\tcmprb)\n+BU_P9_2 (CMPRB2,\t\"byte_in_either_range\",\tCONST,\tcmprb2)\n+BU_P9_64BIT_2 (CMPEQB,\t\"byte_in_set\",\tCONST,\tcmpeqb)\n+\n+/* 2 argument overloaded functions added in ISA 3.0 (power9).  */\n+BU_P9_OVERLOAD_2 (CMPRB,\t\"byte_in_range\")\n+BU_P9_OVERLOAD_2 (CMPRB2,\t\"byte_in_either_range\")\n+BU_P9_OVERLOAD_2 (CMPEQB,\t\"byte_in_set\")\n+\n /* 1 argument IEEE 128-bit floating-point functions.  */\n BU_FLOAT128_1 (FABSQ,\t\t\"fabsq\",       CONST, abskf2)\n "}, {"sha": "57cac7bdc051e33bc9fac3337585bfdff6bbf0ef", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -4926,6 +4926,13 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P9V_BUILTIN_VEC_VPRTYBQ, P9V_BUILTIN_VPRTYBQ,\n     RS6000_BTI_UINTTI, RS6000_BTI_UINTTI, 0, 0 },\n \n+  { P9_BUILTIN_CMPRB, P9_BUILTIN_SCALAR_CMPRB,\n+    RS6000_BTI_INTSI, RS6000_BTI_UINTQI, RS6000_BTI_UINTSI, 0 },\n+  { P9_BUILTIN_CMPRB2, P9_BUILTIN_SCALAR_CMPRB2,\n+    RS6000_BTI_INTSI, RS6000_BTI_UINTQI, RS6000_BTI_UINTSI, 0 },\n+  { P9_BUILTIN_CMPEQB, P9_BUILTIN_SCALAR_CMPEQB,\n+    RS6000_BTI_INTSI, RS6000_BTI_UINTQI, RS6000_BTI_UINTDI, 0 },\n+\n   { P8V_BUILTIN_VEC_VPKUDUM, P8V_BUILTIN_VPKUDUM,\n     RS6000_BTI_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n   { P8V_BUILTIN_VEC_VPKUDUM, P8V_BUILTIN_VPKUDUM,"}, {"sha": "1f303bcb9aa1904fb48d541df3db3846028c52af", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -15117,6 +15117,27 @@ long long __builtin_darn (void);\n long long __builtin_darn_raw (void);\n int __builtin_darn_32 (void);\n \n+unsigned int scalar_extract_exp (double source);\n+unsigned long long int scalar_extract_sig (double source);\n+\n+double\n+scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);\n+\n+int scalar_cmp_exp_gt (double arg1, double arg2);\n+int scalar_cmp_exp_lt (double arg1, double arg2);\n+int scalar_cmp_exp_eq (double arg1, double arg2);\n+int scalar_cmp_exp_unordered (double arg1, double arg2);\n+\n+int scalar_test_data_class (float source, unsigned int condition);\n+int scalar_test_data_class (double source, unsigned int condition);\n+\n+int scalar_test_neg (float source);\n+int scalar_test_neg (double source);\n+\n+int __builtin_byte_in_set (unsigned char u, unsigned long long set);\n+int __builtin_byte_in_range (unsigned char u, unsigned int range);\n+int __builtin_byte_in_either_range (unsigned char u, unsigned int ranges);\n+\n int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal64 value);\n int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal128 value);\n int __builtin_dfp_dtstsfi_lt_dd (unsigned int comparison, _Decimal64 value);\n@@ -15136,23 +15157,6 @@ int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal64 value);\n int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);\n int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);\n int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);\n-\n-unsigned int scalar_extract_exp (double source);\n-unsigned long long int scalar_extract_sig (double source);\n-\n-double\n-scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);\n-\n-int scalar_cmp_exp_gt (double arg1, double arg2);\n-int scalar_cmp_exp_lt (double arg1, double arg2);\n-int scalar_cmp_exp_eq (double arg1, double arg2);\n-int scalar_cmp_exp_unordered (double arg1, double arg2);\n-\n-int scalar_test_data_class (float source, unsigned int condition);\n-int scalar_test_data_class (double source, unsigned int condition);\n-\n-int scalar_test_neg (float source);\n-int scalar_test_neg (double source);\n @end smallexample\n \n The @code{__builtin_darn} and @code{__builtin_darn_raw}\n@@ -15207,6 +15211,24 @@ If all of the enabled test conditions are false, the return value is 0.\n The @code{scalar_test_neg} built-in functions return a non-zero value\n if their @code{source} argument holds a negative value.\n \n+The @code{__builtin_byte_in_set} function requires a\n+64-bit environment supporting ISA 3.0 or later.  This function returns\n+a non-zero value if and only if its @code{u} argument exactly equals one of\n+the eight bytes contained within its 64-bit @code{set} argument.\n+\n+The @code{__builtin_byte_in_range} and\n+@code{__builtin_byte_in_either_range} require an environment\n+supporting ISA 3.0 or later.  For these two functions, the\n+@code{range} argument is encoded as 4 bytes, organized as\n+@code{hi_1:lo_1:hi_2:lo_2}.\n+The @code{__builtin_byte_in_range} function returns a\n+non-zero value if and only if its @code{u} argument is within the\n+range bounded between @code{lo_2} and @code{hi_2} inclusive.\n+The @code{__builtin_byte_in_either_range} function returns non-zero if\n+and only if its @code{u} argument is within either the range bounded\n+between @code{lo_1} and @code{hi_1} inclusive or the range bounded\n+between @code{lo_2} and @code{hi_2} inclusive.\n+\n The @code{__builtin_dfp_dtstsfi_lt} function returns a non-zero value\n if and only if the number of signficant digits of its @code{value} argument\n is less than its @code{comparison} argument.  The"}, {"sha": "11e6d9a288b61955190d9f91c9571994e99f5ab8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -1,3 +1,13 @@\n+2016-12-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* gcc.target/powerpc/byte-in-either-range-0.c: New test.\n+\t* gcc.target/powerpc/byte-in-either-range-1.c: New test.\n+\t* gcc.target/powerpc/byte-in-range-0.c: New test.\n+\t* gcc.target/powerpc/byte-in-range-1.c: New test.\n+\t* gcc.target/powerpc/byte-in-set-0.c: New test.\n+\t* gcc.target/powerpc/byte-in-set-1.c: New test.\n+\t* gcc.target/powerpc/byte-in-set-2.c: New test.\n+\n 2016-12-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/78622"}, {"sha": "c98c0a868130e291bcf41eff01ffdcf04cc9f861", "filename": "gcc/testsuite/gcc.target/powerpc/byte-in-either-range-0.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-either-range-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-either-range-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-either-range-0.c?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"\" { powerpc*-*-aix* } } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on both 32- and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+test_byte_in_either_range (unsigned char b,\n+\t\t\t   unsigned char first_lo_bound,\n+\t\t\t   unsigned char first_hi_bound,\n+\t\t\t   unsigned char second_lo_bound,\n+\t\t\t   unsigned char second_hi_bound)\n+{\n+  unsigned int range_encoding;\n+  range_encoding = ((first_hi_bound << 24) | (first_lo_bound << 16)\n+\t\t    | (second_hi_bound << 8) | second_lo_bound);\n+\n+  return __builtin_byte_in_either_range (b, range_encoding);\n+}\n+\n+/* { dg-final { scan-assembler \"cmprb\" } } */\n+/* { dg-final { scan-assembler \"setb\" } } */"}, {"sha": "52107c716c571f546060f76d144e3f05f591e1fd", "filename": "gcc/testsuite/gcc.target/powerpc/byte-in-either-range-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-either-range-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-either-range-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-either-range-1.c?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"\" { powerpc*-*-aix* } } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed on both 32- and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+test_byte_in_either_range (unsigned char b,\n+\t\t\t   unsigned char first_lo_bound,\n+\t\t\t   unsigned char first_hi_bound,\n+\t\t\t   unsigned char second_lo_bound,\n+\t\t\t   unsigned char second_hi_bound)\n+{\n+  unsigned int range_encoding;\n+  range_encoding = ((first_hi_bound << 24) | (first_lo_bound << 16)\n+\t\t    | (second_hi_bound << 8) | second_lo_bound);\n+\n+  return __builtin_byte_in_either_range (b, range_encoding); /* { dg-error \"Builtin function __builtin_scalar_byte_in_either_range requires\" } */\n+}"}, {"sha": "93f670d15f34a94c998deeb7257c96f33b29a896", "filename": "gcc/testsuite/gcc.target/powerpc/byte-in-range-0.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-range-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-range-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-range-0.c?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"\" { powerpc*-*-aix* } } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on both 32- and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+test_byte_in_range (unsigned char b,\n+\t\t    unsigned char low_range, unsigned char high_range)\n+{\n+  unsigned int range_encoding = (high_range << 8) | low_range;\n+  return __builtin_byte_in_range (b, range_encoding);\n+}\n+\n+/* { dg-final { scan-assembler \"cmprb\" } } */\n+/* { dg-final { scan-assembler \"setb\" } } */"}, {"sha": "aaf46d0f8f3518e6c61e8edd5e1ae1ab9eb8b4bd", "filename": "gcc/testsuite/gcc.target/powerpc/byte-in-range-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-range-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-range-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-range-1.c?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"\" { powerpc*-*-aix* } } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+int\n+test_byte_in_range (unsigned char b,\n+\t\t    unsigned char low_range, unsigned char high_range)\n+{\n+  unsigned int range_encoding = (high_range << 8) | low_range;\n+  return __builtin_byte_in_range (b, range_encoding); /* { dg-error \"Builtin function __builtin_scalar_byte_in_range requires\" } */\n+}\n+"}, {"sha": "e04fa7ce0cb1721f4aa4b63021e8fb9b4c3dc490", "filename": "gcc/testsuite/gcc.target/powerpc/byte-in-set-0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-0.c?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"\" { powerpc*-*-aix* } } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+test_byte_in_set (unsigned char b, unsigned long long set_members)\n+{\n+  return __builtin_byte_in_set (b, set_members);\n+}\n+\n+/* { dg-final { scan-assembler \"cmpeqb\" } } */\n+/* { dg-final { scan-assembler \"setb\" } } */"}, {"sha": "80c3a7d1a4d241caa6f1b9ae16769e977ac07f5e", "filename": "gcc/testsuite/gcc.target/powerpc/byte-in-set-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-1.c?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"\" { powerpc*-*-aix* } } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+int\n+test_byte_in_set (unsigned char b, unsigned long long set_members)\n+{\n+  return __builtin_byte_in_set (b, set_members); /* { dg-error \"Builtin function __builtin_scalar_byte_in_set requires\" } */\n+}"}, {"sha": "1915c70716235ede46ce92d80e74a32cfff880d6", "filename": "gcc/testsuite/gcc.target/powerpc/byte-in-set-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6040f6d49773e67d9a847e920bbbb3b1d62f2560/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbyte-in-set-2.c?ref=6040f6d49773e67d9a847e920bbbb3b1d62f2560", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"\" { powerpc*-*-aix* } } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+/* This test should succeed only on 32-bit configurations.  */\n+\n+int\n+test_byte_in_set (unsigned char b, unsigned long long set_members)\n+{\n+  return __builtin_byte_in_set (b, set_members); /* { dg-error \"Builtin function __builtin_byte_in_set not supported in this compiler configuration\" } */\n+}"}]}