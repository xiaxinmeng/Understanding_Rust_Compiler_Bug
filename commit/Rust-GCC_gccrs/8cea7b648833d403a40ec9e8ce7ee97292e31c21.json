{"sha": "8cea7b648833d403a40ec9e8ce7ee97292e31c21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNlYTdiNjQ4ODMzZDQwM2E0MGVjOWU4Y2U3ZWU5NzI5MmUzMWMyMQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2008-05-26T12:45:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-26T12:45:19Z"}, "message": "exp_ch4.adb (Expand_N_Type_Conversion): Minor code reformatting.\n\n2008-05-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Minor code reformatting.\n\tGenerate a tag check when the result subtype of a function, defined by\n\tan access definition, designates a specific tagged type.\n\t(Make_Tag_Check): New routine.\n\nFrom-SVN: r135916", "tree": {"sha": "253979bac5cebe40e3d661e5f69b1d810d8ba39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/253979bac5cebe40e3d661e5f69b1d810d8ba39a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cea7b648833d403a40ec9e8ce7ee97292e31c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cea7b648833d403a40ec9e8ce7ee97292e31c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cea7b648833d403a40ec9e8ce7ee97292e31c21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cea7b648833d403a40ec9e8ce7ee97292e31c21/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "41def521490f8909ab12bca7580171573e532d55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41def521490f8909ab12bca7580171573e532d55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41def521490f8909ab12bca7580171573e532d55"}], "stats": {"total": 176, "additions": 124, "deletions": 52}, "files": [{"sha": "1eb727392d9e5821ead6164c393e8f61c5243007", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 124, "deletions": 52, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cea7b648833d403a40ec9e8ce7ee97292e31c21/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cea7b648833d403a40ec9e8ce7ee97292e31c21/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8cea7b648833d403a40ec9e8ce7ee97292e31c21", "patch": "@@ -7583,79 +7583,151 @@ package body Exp_Ch4 is\n          --  Otherwise, proceed with processing tagged conversion\n \n          declare\n-            Actual_Operand_Type : Entity_Id;\n-            Actual_Target_Type  : Entity_Id;\n+            Actual_Op_Typ   : Entity_Id;\n+            Actual_Targ_Typ : Entity_Id;\n+            Make_Conversion : Boolean := False;\n+            Root_Op_Typ     : Entity_Id;\n \n-            Cond : Node_Id;\n+            procedure Make_Tag_Check (Targ_Typ : Entity_Id);\n+            --  Create a membership check to test whether Operand is a member\n+            --  of Targ_Typ. If the original Target_Type is an access, include\n+            --  a test for null value. The check is inserted at N.\n+\n+            --------------------\n+            -- Make_Tag_Check --\n+            --------------------\n+\n+            procedure Make_Tag_Check (Targ_Typ : Entity_Id) is\n+               Cond : Node_Id;\n+\n+            begin\n+               --  Generate:\n+               --    [Constraint_Error\n+               --       when Operand /= null\n+               --         and then Operand.all not in Targ_Typ]\n+\n+               if Is_Access_Type (Target_Type) then\n+                  Cond :=\n+                    Make_And_Then (Loc,\n+                      Left_Opnd =>\n+                        Make_Op_Ne (Loc,\n+                          Left_Opnd  => Duplicate_Subexpr_No_Checks (Operand),\n+                          Right_Opnd => Make_Null (Loc)),\n+\n+                      Right_Opnd =>\n+                        Make_Not_In (Loc,\n+                          Left_Opnd  =>\n+                            Make_Explicit_Dereference (Loc,\n+                              Prefix => Duplicate_Subexpr_No_Checks (Operand)),\n+                          Right_Opnd => New_Reference_To (Targ_Typ, Loc)));\n+\n+               --  Generate:\n+               --    [Constraint_Error when Operand not in Targ_Typ]\n+\n+               else\n+                  Cond :=\n+                    Make_Not_In (Loc,\n+                      Left_Opnd  => Duplicate_Subexpr_No_Checks (Operand),\n+                      Right_Opnd => New_Reference_To (Targ_Typ, Loc));\n+               end if;\n+\n+               Insert_Action (N,\n+                 Make_Raise_Constraint_Error (Loc,\n+                   Condition => Cond,\n+                   Reason    => CE_Tag_Check_Failed));\n+            end Make_Tag_Check;\n+\n+         --  Start of processing\n \n          begin\n             if Is_Access_Type (Target_Type) then\n-               Actual_Operand_Type := Designated_Type (Operand_Type);\n-               Actual_Target_Type  := Designated_Type (Target_Type);\n+               Actual_Op_Typ   := Designated_Type (Operand_Type);\n+               Actual_Targ_Typ := Designated_Type (Target_Type);\n \n             else\n-               Actual_Operand_Type := Operand_Type;\n-               Actual_Target_Type  := Target_Type;\n+               Actual_Op_Typ   := Operand_Type;\n+               Actual_Targ_Typ := Target_Type;\n             end if;\n \n+            Root_Op_Typ := Root_Type (Actual_Op_Typ);\n+\n             --  Ada 2005 (AI-251): Handle interface type conversion\n \n-            if Is_Interface (Actual_Operand_Type) then\n+            if Is_Interface (Actual_Op_Typ) then\n                Expand_Interface_Conversion (N, Is_Static => False);\n                return;\n             end if;\n \n-            if Is_Class_Wide_Type (Actual_Operand_Type)\n-              and then Root_Type (Actual_Operand_Type) /=  Actual_Target_Type\n-              and then Is_Ancestor\n-                         (Root_Type (Actual_Operand_Type),\n-                          Actual_Target_Type)\n-              and then not Tag_Checks_Suppressed (Actual_Target_Type)\n-            then\n-               --  Conversion is valid for any descendant of the target type\n+            if not Tag_Checks_Suppressed (Actual_Targ_Typ) then\n \n-               Actual_Target_Type := Class_Wide_Type (Actual_Target_Type);\n+               --  Create a runtime tag check for a downward class-wide type\n+               --  conversion.\n \n-               if Is_Access_Type (Target_Type) then\n-                  Cond :=\n-                     Make_And_Then (Loc,\n-                       Left_Opnd =>\n-                         Make_Op_Ne (Loc,\n-                           Left_Opnd  => Duplicate_Subexpr_No_Checks (Operand),\n-                           Right_Opnd => Make_Null (Loc)),\n+               if Is_Class_Wide_Type (Actual_Op_Typ)\n+                 and then Root_Op_Typ /= Actual_Targ_Typ\n+                 and then Is_Ancestor (Root_Op_Typ, Actual_Targ_Typ)\n+               then\n+                  Make_Tag_Check (Class_Wide_Type (Actual_Targ_Typ));\n+                  Make_Conversion := True;\n+               end if;\n \n-                       Right_Opnd =>\n-                         Make_Not_In (Loc,\n-                           Left_Opnd  =>\n-                             Make_Explicit_Dereference (Loc,\n-                               Prefix =>\n-                                 Duplicate_Subexpr_No_Checks (Operand)),\n-                           Right_Opnd =>\n-                             New_Reference_To (Actual_Target_Type, Loc)));\n+               --  AI05-0073: If the result subtype of the function is defined\n+               --  by an access_definition designating a specific tagged type\n+               --  T, a check is made that the result value is null or the tag\n+               --  of the object designated by the result value identifies T.\n+               --  Constraint_Error is raised if this check fails.\n \n-               else\n-                  Cond :=\n-                    Make_Not_In (Loc,\n-                      Left_Opnd  => Duplicate_Subexpr_No_Checks (Operand),\n-                      Right_Opnd =>\n-                        New_Reference_To (Actual_Target_Type, Loc));\n+               if Nkind (Parent (N)) = Sinfo.N_Return_Statement then\n+                  declare\n+                     Func     : Entity_Id := Current_Scope;\n+                     Func_Typ : Entity_Id;\n+\n+                  begin\n+                     --  Climb the scope stack looking for the enclosing\n+                     --  function.\n+\n+                     while Present (Func)\n+                       and then Ekind (Func) /= E_Function\n+                     loop\n+                        Func := Scope (Func);\n+                     end loop;\n+\n+                     --  The function's return subtype must be defined using\n+                     --  an access definition.\n+\n+                     if Nkind (Result_Definition (Parent (Func))) =\n+                          N_Access_Definition\n+                     then\n+                        Func_Typ := Directly_Designated_Type (Etype (Func));\n+\n+                        --  The return subtype denotes a specific tagged type,\n+                        --  in other words, a non class-wide type.\n+\n+                        if Is_Tagged_Type (Func_Typ)\n+                          and then not Is_Class_Wide_Type (Func_Typ)\n+                        then\n+                           Make_Tag_Check (Actual_Targ_Typ);\n+                           Make_Conversion := True;\n+                        end if;\n+                     end if;\n+                  end;\n                end if;\n \n-               Insert_Action (N,\n-                 Make_Raise_Constraint_Error (Loc,\n-                   Condition => Cond,\n-                   Reason    => CE_Tag_Check_Failed));\n+               --  We have generated a tag check for either a class-wide type\n+               --  conversion or for AI05-0073.\n \n-               declare\n-                  Conv : Node_Id;\n-               begin\n-                  Conv :=\n-                    Make_Unchecked_Type_Conversion (Loc,\n-                      Subtype_Mark => New_Occurrence_Of (Target_Type, Loc),\n-                      Expression => Relocate_Node (Expression (N)));\n-                  Rewrite (N, Conv);\n-                  Analyze_And_Resolve (N, Target_Type);\n-               end;\n+               if Make_Conversion then\n+                  declare\n+                     Conv : Node_Id;\n+                  begin\n+                     Conv :=\n+                       Make_Unchecked_Type_Conversion (Loc,\n+                         Subtype_Mark => New_Occurrence_Of (Target_Type, Loc),\n+                         Expression   => Relocate_Node (Expression (N)));\n+                     Rewrite (N, Conv);\n+                     Analyze_And_Resolve (N, Target_Type);\n+                  end;\n+               end if;\n             end if;\n          end;\n "}]}