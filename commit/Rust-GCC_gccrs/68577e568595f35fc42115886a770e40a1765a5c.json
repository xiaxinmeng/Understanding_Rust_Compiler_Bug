{"sha": "68577e568595f35fc42115886a770e40a1765a5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1NzdlNTY4NTk1ZjM1ZmM0MjExNTg4NmE3NzBlNDBhMTc2NWE1Yw==", "commit": {"author": {"name": "Erik Edelmann", "email": "erik.edelmann@iki.fi", "date": "2005-10-19T22:18:07Z"}, "committer": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2005-10-19T22:18:07Z"}, "message": "re PR fortran/21625 ([4.0 only] Nested derived type pointer component not initialized on ALLOCATE)\n\n\tPR fortran/21625\n\t* resolve.c (expr_to_initialize): New function.\n\t(resolve_allocate_expr): Take current statement as new\n\targument. Add default initializers to variables of\n\tderived types, if they need it.\n\t(resolve_code): Provide current statement as argument to\n\tresolve_allocate_expr().\n\nFrom-SVN: r105642", "tree": {"sha": "bdddb054ceeb27b7b2a6bfb470a6f2373f197886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdddb054ceeb27b7b2a6bfb470a6f2373f197886"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68577e568595f35fc42115886a770e40a1765a5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68577e568595f35fc42115886a770e40a1765a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68577e568595f35fc42115886a770e40a1765a5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68577e568595f35fc42115886a770e40a1765a5c/comments", "author": null, "committer": null, "parents": [{"sha": "8c2805d1aee6ccbfe5e1e6c090b02e88cc89d363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2805d1aee6ccbfe5e1e6c090b02e88cc89d363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2805d1aee6ccbfe5e1e6c090b02e88cc89d363"}], "stats": {"total": 59, "additions": 57, "deletions": 2}, "files": [{"sha": "fb776002194ca16b16d66549234386f72104ee41", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68577e568595f35fc42115886a770e40a1765a5c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68577e568595f35fc42115886a770e40a1765a5c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=68577e568595f35fc42115886a770e40a1765a5c", "patch": "@@ -1,3 +1,13 @@\n+2005-10-20  Erik Edelmann  <erik.edelmann@iki.fi>\n+\n+\tPR fortran/21625\n+\t* resolve.c (expr_to_initialize): New function.\n+\t(resolve_allocate_expr): Take current statement as new \n+\targument. Add default initializers to variables of\n+\tderived types, if they need it.\n+\t(resolve_code): Provide current statement as argument to\n+\tresolve_allocate_expr().\n+\n 2005-10-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/24440"}, {"sha": "26f11c50583d506b5bb09b74403e2adb5a8d4da9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68577e568595f35fc42115886a770e40a1765a5c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68577e568595f35fc42115886a770e40a1765a5c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=68577e568595f35fc42115886a770e40a1765a5c", "patch": "@@ -2609,17 +2609,49 @@ resolve_deallocate_expr (gfc_expr * e)\n }\n \n \n+/* Given the expression node e for an allocatable/pointer of derived type to be\n+   allocated, get the expression node to be initialized afterwards (needed for\n+   derived types with default initializers).  */\n+\n+static gfc_expr *\n+expr_to_initialize (gfc_expr * e)\n+{\n+  gfc_expr *result;\n+  gfc_ref *ref;\n+  int i;\n+\n+  result = gfc_copy_expr (e);\n+\n+  /* Change the last array reference from AR_ELEMENT to AR_FULL.  */\n+  for (ref = result->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->next == NULL)\n+      {\n+        ref->u.ar.type = AR_FULL;\n+\n+        for (i = 0; i < ref->u.ar.dimen; i++)\n+          ref->u.ar.start[i] = ref->u.ar.end[i] = ref->u.ar.stride[i] = NULL;\n+\n+        result->rank = ref->u.ar.dimen; \n+        break;\n+      }\n+\n+  return result;\n+}\n+\n+\n /* Resolve the expression in an ALLOCATE statement, doing the additional\n    checks to see whether the expression is OK or not.  The expression must\n    have a trailing array reference that gives the size of the array.  */\n \n static try\n-resolve_allocate_expr (gfc_expr * e)\n+resolve_allocate_expr (gfc_expr * e, gfc_code * code)\n {\n   int i, pointer, allocatable, dimension;\n   symbol_attribute attr;\n   gfc_ref *ref, *ref2;\n   gfc_array_ref *ar;\n+  gfc_code *init_st;\n+  gfc_expr *init_e;\n \n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n@@ -2674,6 +2706,19 @@ resolve_allocate_expr (gfc_expr * e)\n       return FAILURE;\n     }\n \n+  /* Add default initializer for those derived types that need them.  */\n+  if (e->ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&e->ts)))\n+    {\n+        init_st = gfc_get_code ();\n+        init_st->loc = code->loc;\n+        init_st->op = EXEC_ASSIGN;\n+        init_st->expr = expr_to_initialize (e);\n+        init_st->expr2 = init_e;\n+\n+        init_st->next = code->next;\n+        code->next = init_st;\n+    }\n+\n   if (pointer && dimension == 0)\n     return SUCCESS;\n \n@@ -4022,7 +4067,7 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \t\t       \"of type INTEGER\", &code->expr->where);\n \n \t  for (a = code->ext.alloc_list; a; a = a->next)\n-\t    resolve_allocate_expr (a->expr);\n+\t    resolve_allocate_expr (a->expr, code);\n \n \t  break;\n "}]}