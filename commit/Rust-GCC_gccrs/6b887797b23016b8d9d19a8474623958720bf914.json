{"sha": "6b887797b23016b8d9d19a8474623958720bf914", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI4ODc3OTdiMjMwMTZiOGQ5ZDE5YTg0NzQ2MjM5NTg3MjBiZjkxNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-09-05T04:26:10Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-09-05T04:26:10Z"}, "message": "re PR fortran/28908 (fold_convert fails for Fortran operator)\n\n2006-09-05 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/28908\n\tREGRESSION FIX\n\t* gfortran.h : Restore the gfc_dt_list structure and reference\n\tto it in gfc_namespace.\n\t* resolve.c (resolve_fl_derived): Restore the building of the\n\tlist of derived types for the current namespace. Modify the\n\trestored code so that a check is made to see if the symbol is\n\talready in the list.\n\t(resolve_fntype): Make sure that the specification block\n\tversion of the derived type is used for a module function that\n\treturns that type. \n\t* symbol.c (gfc_free_dt_list): Restore.\n\t(gfc_free_namespace): Restore call to previous.\n\t* trans-types.c (copy_dt_decls_ifequal): Restore.\n\t(gfc_get_derived_type): Restore all the paraphenalia for\n\tassociation of derived types, including calls to previous.\n\tModify the restored code such that all derived types are built\n\tif their symbols are found in the parent namespace; not just\n\tnon-module types.  Add backend_decls to like derived types in\n\tsibling namespaces, as well as that of the derived type.\n\n2006-09-05 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/28908\n\t* gfortran.dg/used_types_7.f90: New test.\n\t* gfortran.dg/used_types_8.f90: New test.\n\t* gfortran.dg/used_types_9.f90: New test.\n\nFrom-SVN: r116690", "tree": {"sha": "34273f5fee1aa7762e65f398f90e61ede32f6ffc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34273f5fee1aa7762e65f398f90e61ede32f6ffc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b887797b23016b8d9d19a8474623958720bf914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b887797b23016b8d9d19a8474623958720bf914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b887797b23016b8d9d19a8474623958720bf914", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b887797b23016b8d9d19a8474623958720bf914/comments", "author": null, "committer": null, "parents": [{"sha": "c9159c40f8660478b5ddee43fd5d7d35680eec42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9159c40f8660478b5ddee43fd5d7d35680eec42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9159c40f8660478b5ddee43fd5d7d35680eec42"}], "stats": {"total": 427, "additions": 292, "deletions": 135}, "files": [{"sha": "d7fbd115e098b69bc9b560e4cf6e793b1948ca0e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -1,3 +1,26 @@\n+2006-09-05 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/28908\n+\tREGRESSION FIX\n+\t* gfortran.h : Restore the gfc_dt_list structure and reference\n+\tto it in gfc_namespace.\n+\t* resolve.c (resolve_fl_derived): Restore the building of the\n+\tlist of derived types for the current namespace. Modify the\n+\trestored code so that a check is made to see if the symbol is\n+\talready in the list.\n+\t(resolve_fntype): Make sure that the specification block\n+\tversion of the derived type is used for a module function that\n+\treturns that type. \n+\t* symbol.c (gfc_free_dt_list): Restore.\n+\t(gfc_free_namespace): Restore call to previous.\n+\t* trans-types.c (copy_dt_decls_ifequal): Restore.\n+\t(gfc_get_derived_type): Restore all the paraphenalia for\n+\tassociation of derived types, including calls to previous.\n+\tModify the restored code such that all derived types are built\n+\tif their symbols are found in the parent namespace; not just\n+\tnon-module types.  Add backend_decls to like derived types in\n+\tsibling namespaces, as well as that of the derived type.\n+\n 2006-08-30  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* match.c: Fix a comment typo."}, {"sha": "01bcf976e54686275cc805184bc19af17ae729f9", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -927,6 +927,17 @@ typedef struct gfc_symtree\n }\n gfc_symtree;\n \n+/* A linked list of derived types in the namespace.  */\n+typedef struct gfc_dt_list\n+{\n+  struct gfc_symbol *derived;\n+  struct gfc_dt_list *next;\n+}\n+gfc_dt_list;\n+\n+#define gfc_get_dt_list() gfc_getmem(sizeof(gfc_dt_list))\n+\n+\n /* A namespace describes the contents of procedure, module or\n    interface block.  */\n /* ??? Anything else use these?  */\n@@ -989,6 +1000,9 @@ typedef struct gfc_namespace\n   /* A list of all alternate entry points to this procedure (or NULL).  */\n   gfc_entry_list *entries;\n \n+  /* A list of all derived types in this procedure (or NULL).  */\n+  gfc_dt_list *derived_types;\n+\n   /* Set to 1 if namespace is a BLOCK DATA program unit.  */\n   int is_block_data;\n }"}, {"sha": "b62a0411e9d90cafcb818094f3603341aee98425", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -5368,6 +5368,7 @@ static try\n resolve_fl_derived (gfc_symbol *sym)\n {\n   gfc_component *c;\n+  gfc_dt_list * dt_list;\n   int i;\n \n   for (c = sym->components; c != NULL; c = c->next)\n@@ -5430,6 +5431,19 @@ resolve_fl_derived (gfc_symbol *sym)\n \t}\n     }\n     \n+  /* Add derived type to the derived type list.  */\n+  for (dt_list = sym->ns->derived_types; dt_list; dt_list = dt_list->next)\n+    if (sym == dt_list->derived)\n+      break;\n+\n+  if (dt_list == NULL)\n+    {\n+      dt_list = gfc_get_dt_list ();\n+      dt_list->next = sym->ns->derived_types;\n+      dt_list->derived = sym;\n+      sym->ns->derived_types = dt_list;\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -6528,6 +6542,21 @@ resolve_fntype (gfc_namespace * ns)\n                  sym->name, &sym->declared_at, sym->ts.derived->name);\n     }\n \n+  /* Make sure that the type of a module derived type function is in the\n+     module namespace, by copying it from the namespace's derived type\n+     list, if necessary.  */\n+  if (sym->ts.type == BT_DERIVED\n+\t&& sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t&& sym->ts.derived->ns\n+\t&& sym->ns != sym->ts.derived->ns)\n+    {\n+      gfc_dt_list *dt = sym->ns->derived_types;\n+\n+      for (; dt; dt = dt->next)\n+        if (gfc_compare_derived_types (sym->ts.derived, dt->derived))\n+\t  sym->ts.derived = dt->derived;\n+    }\n+\n   if (ns->entries)\n     for (el = ns->entries->next; el; el = el->next)\n       {\n@@ -6666,7 +6695,6 @@ resolve_types (gfc_namespace * ns)\n     warn_unused_fortran_label (ns->st_labels);\n \n   gfc_resolve_uops (ns->uop_root);\n-    \n }\n \n "}, {"sha": "63e45ecb5fe7ae58fcf7800ff941afd6836305c2", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 23, "deletions": 132, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -1364,37 +1364,8 @@ gfc_add_component (gfc_symbol * sym, const char *name, gfc_component ** componen\n }\n \n \n-/* Recursive search for a renamed derived type.  */\n-\n-static gfc_symbol *\n-find_renamed_type (gfc_symbol * der, gfc_symtree * st)\n-{\n-  gfc_symbol *sym = NULL;\n-\n-  if (st == NULL)\n-    return NULL;\n-\n-  sym = find_renamed_type (der, st->left);\n-  if (sym != NULL)\n-    return sym;\n-\n-  sym = find_renamed_type (der, st->right);\n-  if (sym != NULL)\n-    return sym;\n-\n-  if (strcmp (der->name, st->n.sym->name) == 0\n-\t&& st->n.sym->attr.use_assoc\n-\t&& st->n.sym->attr.flavor == FL_DERIVED\n-\t&& gfc_compare_derived_types (der, st->n.sym))\n-    sym = st->n.sym;\n-\n-  return sym;\n-}\n-\n-/* Recursive function to switch derived types of all symbols in a\n-   namespace.  The formal namespaces contain references to derived\n-   types that can be left hanging by gfc_use_derived, so these must\n-   be switched too.  */\n+/* Recursive function to switch derived types of all symbol in a\n+   namespace.  */\n \n static void\n switch_types (gfc_symtree * st, gfc_symbol * from, gfc_symbol * to)\n@@ -1407,9 +1378,6 @@ switch_types (gfc_symtree * st, gfc_symbol * from, gfc_symbol * to)\n   sym = st->n.sym;\n   if (sym->ts.type == BT_DERIVED && sym->ts.derived == from)\n     sym->ts.derived = to;\n-  \n-  if (sym->formal_ns && sym->formal_ns->sym_root)\n-    switch_types (sym->formal_ns->sym_root, from, to);\n \n   switch_types (st->left, from, to);\n   switch_types (st->right, from, to);\n@@ -1440,103 +1408,20 @@ gfc_use_derived (gfc_symbol * sym)\n   gfc_symbol *s;\n   gfc_typespec *t;\n   gfc_symtree *st;\n-  gfc_component *c;\n-  gfc_namespace *ns;\n   int i;\n \n-  if (sym->ns->parent == NULL || sym->ns != gfc_current_ns)\n-    {\n-      /* Already defined in highest possible or sibling namespace.  */\n-      if (sym->components != NULL)\n-\treturn sym;\n-\n-      /*  There is no scope for finding a definition elsewhere.  */\n-      else\n-\tgoto bad;\n-    }\n-  else\n-    {\n-      /* This type can only be locally associated.  */\n-      if (!(sym->attr.use_assoc || sym->attr.sequence))\n-\treturn sym;\n+  if (sym->components != NULL)\n+    return sym;               /* Already defined.  */\n \n-      /* Derived types must be defined within an interface.  */\n-      if (gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY)\n-\treturn sym;\n-    }\n+  if (sym->ns->parent == NULL)\n+    goto bad;\n \n-  /* Look in parent namespace for a derived type of the same name.  */\n   if (gfc_find_symbol (sym->name, sym->ns->parent, 1, &s))\n     {\n       gfc_error (\"Symbol '%s' at %C is ambiguous\", sym->name);\n       return NULL;\n     }\n \n-  /* Look in sibling namespaces for a derived type of the same name.  */\n-  if (s == NULL && sym->attr.use_assoc && sym->ns->sibling)\n-    {\n-      ns = sym->ns->sibling;\n-      for (; ns; ns = ns->sibling)\n-\t{\n-\t  s = NULL;\n-\t  if (sym->ns == ns)\n-\t    break;\n-\n-\t  if (gfc_find_symbol (sym->name, ns, 1, &s))\n-\t    {\n-\t      gfc_error (\"Symbol '%s' at %C is ambiguous\", sym->name);\n-\t      return NULL;\n-\t    }\n-\n-\t  if (s != NULL && s->attr.flavor == FL_DERIVED)\n-\t    break;\n-\t}\n-    }\n-\n-  if (s == NULL || s->attr.flavor != FL_DERIVED)\n-    {\n-      /* Check to see if type has been renamed in parent namespace.  */\n-      s = find_renamed_type (sym, sym->ns->parent->sym_root);\n-      if (s != NULL)\n-\tgoto return_use_assoc;\n-\n-      /* See if sym is identical to renamed, use-associated derived\n-\t types in sibling namespaces.  */\n-      if (sym->attr.use_assoc\n-\t    && sym->ns->parent\n-\t    && sym->ns->parent->contained)\n-\t{\n-\t  ns = sym->ns->parent->contained;\n-\t  for (; ns; ns = ns->sibling)\n-\t    {\n-\t      if (sym->ns == ns)\n-\t\tbreak;\n-\n-\t      s = find_renamed_type (sym, ns->sym_root);\n-\n-\t      if (s != NULL)\n-\t\tgoto return_use_assoc;\n-\t    }\n-\t}\n-\n-      /* The local definition is all that there is.  */\n-      if (sym->components != NULL)\n-\t{\n-\t  /* Non-pointer derived type components have already been checked\n-\t     but pointer types need to be correctly associated.  */\n-\t  for (c = sym->components; c; c = c->next)\n-\t    if (c->ts.type == BT_DERIVED && c->pointer)\n-\t      c->ts.derived = gfc_use_derived (c->ts.derived);\n-\n-\t  return sym;\n-\t}\n-    }\n-\n-  /* Although the parent namespace has a derived type of the same name, it is\n-     not an identical derived type and so cannot be used.  */\n-  if (s != NULL && sym->components != NULL && !gfc_compare_derived_types (s, sym))\n-    return sym;\n-\n   if (s == NULL || s->attr.flavor != FL_DERIVED)\n     goto bad;\n \n@@ -1548,9 +1433,6 @@ gfc_use_derived (gfc_symbol * sym)\n \tt->derived = s;\n     }\n \n-  if (sym->attr.use_assoc)\n-    goto return_use_assoc;\n-\n   st = gfc_find_symtree (sym->ns->sym_root, sym->name);\n   st->n.sym = s;\n \n@@ -1567,14 +1449,6 @@ gfc_use_derived (gfc_symbol * sym)\n \n   return s;\n \n-return_use_assoc:\n-  /* Use associated types are not freed at this stage because some\n-     references remain to 'sym'.  We retain the symbol and leave it\n-     to be cleaned up by gfc_free_namespace, at the end of the\n-     compilation.  */\n-  switch_types (sym->ns->sym_root, sym, s);\n-  return s;\n-\n bad:\n   gfc_error (\"Derived type '%s' at %C is being used before it is defined\",\n \t     sym->name);\n@@ -2566,6 +2440,21 @@ free_sym_tree (gfc_symtree * sym_tree)\n }\n \n \n+/* Free a derived type list.  */\n+\n+static void\n+gfc_free_dt_list (gfc_dt_list * dt)\n+{\n+  gfc_dt_list *n;\n+\n+  for (; dt; dt = n)\n+    {\n+      n = dt->next;\n+      gfc_free (dt);\n+    }\n+}\n+\n+\n /* Free the gfc_equiv_info's.  */\n \n static void\n@@ -2628,6 +2517,8 @@ gfc_free_namespace (gfc_namespace * ns)\n   gfc_free_equiv (ns->equiv);\n   gfc_free_equiv_lists (ns->equiv_lists);\n \n+  gfc_free_dt_list (ns->derived_types);\n+\n   for (i = GFC_INTRINSIC_BEGIN; i != GFC_INTRINSIC_END; i++)\n     gfc_free_interface (ns->operator[i]);\n "}, {"sha": "4ecf94b4c9fc6941292965ab0004f8fa3602ab9f", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -1411,15 +1411,59 @@ gfc_add_field_to_struct (tree *fieldlist, tree context,\n }\n \n \n-/* Build a tree node for a derived type.  */\n+/* Copy the backend_decl and component backend_decls if\n+   the two derived type symbols are \"equal\", as described\n+   in 4.4.2 and resolved by gfc_compare_derived_types.  */\n+\n+static int\n+copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to)\n+{\n+  gfc_component *to_cm;\n+  gfc_component *from_cm;\n+\n+  if (from->backend_decl == NULL\n+\t|| !gfc_compare_derived_types (from, to))\n+    return 0;\n+\n+  to->backend_decl = from->backend_decl;\n+\n+  to_cm = to->components;\n+  from_cm = from->components;\n+\n+  /* Copy the component declarations.  If a component is itself\n+     a derived type, we need a copy of its component declarations.\n+     This is done by recursing into gfc_get_derived_type and\n+     ensures that the component's component declarations have\n+     been built.  If it is a character, we need the character \n+     length, as well.  */\n+  for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)\n+    {\n+      to_cm->backend_decl = from_cm->backend_decl;\n+      if (from_cm->ts.type == BT_DERIVED)\n+\tgfc_get_derived_type (to_cm->ts.derived);\n+\n+      else if (from_cm->ts.type == BT_CHARACTER)\n+\tto_cm->ts.cl->backend_decl = from_cm->ts.cl->backend_decl;\n+    }\n+\n+  return 1;\n+}\n+\n+\n+/* Build a tree node for a derived type.  If there are equal\n+   derived types, with different local names, these are built\n+   at the same time.  If an equal derived type has been built\n+   in a parent namespace, this is used.  */\n \n static tree\n gfc_get_derived_type (gfc_symbol * derived)\n {\n   tree typenode, field, field_type, fieldlist;\n   gfc_component *c;\n+  gfc_dt_list *dt;\n+  gfc_namespace * ns;\n \n-  gcc_assert (derived);\n+  gcc_assert (derived && derived->attr.flavor == FL_DERIVED);\n \n   /* derived->backend_decl != 0 means we saw it before, but its\n      components' backend_decl may have not been built.  */\n@@ -1433,6 +1477,27 @@ gfc_get_derived_type (gfc_symbol * derived)\n     }\n   else\n     {\n+      /* If an equal derived type is already available in the parent namespace,\n+\t use its backend declaration and those of its components, rather than\n+\t building anew so that potential dummy and actual arguments use the\n+\t same TREE_TYPE.  If an equal type is found without a backend_decl,\n+\t build the parent version and use it in the current namespace.  */\n+\n+      for (ns = derived->ns->parent; ns; ns = ns->parent)\n+\t{\n+\t  for (dt = ns->derived_types; dt; dt = dt->next)\n+\t    {\n+\t      if (dt->derived->backend_decl == NULL\n+\t\t    && gfc_compare_derived_types (dt->derived, derived))\n+\t\tgfc_get_derived_type (dt->derived);\n+\n+\t      if (copy_dt_decls_ifequal (dt->derived, derived))\n+\t\tbreak;\n+\t    }\n+\t  if (derived->backend_decl)\n+\t    goto other_equal_dts;\n+\t}\n+\n       /* We see this derived type first time, so build the type node.  */\n       typenode = make_node (RECORD_TYPE);\n       TYPE_NAME (typenode) = get_identifier (derived->name);\n@@ -1511,6 +1576,14 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n   derived->backend_decl = typenode;\n \n+other_equal_dts:\n+  /* Add this backend_decl to all the other, equal derived types and\n+     their components in this and sibling namespaces.  */\n+\n+  for (ns = derived->ns->sibling; ns; ns = ns->sibling)\n+    for (dt = ns->derived_types; dt; dt = dt->next)\n+      copy_dt_decls_ifequal (derived, dt->derived);\n+\n   return derived->backend_decl;\n }\n "}, {"sha": "0355796a543bb50bcbc5738efc8cfb1ea5040918", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -1,3 +1,10 @@\n+2006-09-05 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/28908\n+\t* gfortran.dg/used_types_7.f90: New test.\n+\t* gfortran.dg/used_types_8.f90: New test.\n+\t* gfortran.dg/used_types_9.f90: New test.\n+\n 2006-09-04  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.c-torture/compile/20060904-1.c: New test."}, {"sha": "91354005d21c5eaaabdf7991c66e09a1d03507ae", "filename": "gcc/testsuite/gfortran.dg/used_types_7.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_7.f90?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+! Tests the fix for a further regression caused by the\n+! fix for PR28788 and posted as PR28908. The problem was\n+! caused by the patch preventing interface derived types\n+! from associating with identical derived types in the\n+! containing namespaces.\n+!\n+! Contributed by HJ Lu  <hjl@lucon.org>\n+!\n+module bar\n+  implicit none\n+  public\n+  type ESMF_Time\n+    integer :: DD\n+  end type\n+end module bar\n+\n+module foo\n+  use bar\n+  implicit none\n+  private\n+  type ESMF_Clock\n+    type(ESMF_Time)  :: CurrTime\n+  end type\n+  interface operator (+)\n+    function add (x, y)\n+      use bar\n+      type(ESMF_Time) :: add\n+      type(ESMF_Time), intent(in) :: x\n+      type(ESMF_Time), intent(in) :: y\n+    end function add\n+  end interface\n+contains\n+  subroutine ESMF_ClockAdvance(clock)\n+    type(ESMF_Clock), intent(inout) :: clock\n+    clock%CurrTime = clock%CurrTime + clock%CurrTime\n+  end subroutine ESMF_ClockAdvance\n+end module foo\n+! { dg-final { cleanup-modules \"foo bar\" } }"}, {"sha": "58d2084f3629f038cea1d4d018f249dbbdd1442b", "filename": "gcc/testsuite/gfortran.dg/used_types_8.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_8.f90?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do compile }\n+! Tests the fix for a further regression caused by the\n+! fix for PR28788 and posted as PR28908. The problem was\n+! caused by the patch preventing interface derived types\n+! from associating with identical derived types in the\n+! containing namespaces.\n+!\n+! Contributed by HJ Lu  <hjl@lucon.org>\n+!\n+module bar\n+  implicit none\n+  public\n+  type ESMF_Time\n+  sequence\n+    integer :: MM\n+  end type\n+  public operator (+)\n+  private add\n+  interface operator (+)\n+  module procedure add\n+  end interface\n+contains\n+    function add (x, y)\n+      type(ESMF_Time) :: add\n+      type(ESMF_Time), intent(in) :: x\n+      type(ESMF_Time), intent(in) :: y\n+      add = x\n+    end function add\n+end module bar\n+\n+module foo\n+  use bar\n+  implicit none\n+  private\n+  type ESMF_Clock\n+  sequence\n+    type(ESMF_Time)  :: CurrTime\n+  end type\n+contains\n+  subroutine ESMF_ClockAdvance(clock)\n+  use bar\n+    type(ESMF_Clock), intent(inout) :: clock\n+    clock%CurrTime = clock%CurrTime + clock%CurrTime\n+  end subroutine ESMF_ClockAdvance\n+end module foo\n+! { dg-final { cleanup-modules \"foo bar\" } }"}, {"sha": "fc09d155c0fcad169aed7101ec83110b5330b512", "filename": "gcc/testsuite/gfortran.dg/used_types_9.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b887797b23016b8d9d19a8474623958720bf914/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_9.f90?ref=6b887797b23016b8d9d19a8474623958720bf914", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\r\n+! Tests the fix for a further regression caused by the\r\n+! fix for PR28788 and posted as PR28908. The problem was\r\n+! caused by the patch preventing interface derived types\r\n+! from associating with identical derived types in the\r\n+! containing namespaces.\r\n+!\r\n+! Contributed by HJ Lu  <hjl@lucon.org>\r\n+!\r\n+module bar\r\n+  implicit none\r\n+  public\r\n+  type domain_ptr\r\n+    type(domain), POINTER  :: ptr\r\n+  end type domain_ptr\r\n+  type domain\r\n+    TYPE(domain_ptr) , DIMENSION( : ) , POINTER         :: parents\r\n+    TYPE(domain_ptr) , DIMENSION( : ) , POINTER         :: nests\r\n+  end type domain\r\n+end module bar\r\n+\r\n+module foo\r\n+contains\r\n+  recursive subroutine integrate (grid)\r\n+    use bar\r\n+    implicit none\r\n+    type(domain), POINTER  :: grid\r\n+    interface\r\n+      subroutine solve_interface (grid)\r\n+        use bar\r\n+        TYPE (domain) grid\r\n+      end subroutine solve_interface\r\n+    end interface\r\n+  end subroutine integrate\r\n+end module foo\r\n+! { dg-final { cleanup-modules \"foo bar\" } }\r"}]}