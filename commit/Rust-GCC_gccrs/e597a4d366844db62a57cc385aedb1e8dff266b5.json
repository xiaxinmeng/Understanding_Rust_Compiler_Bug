{"sha": "e597a4d366844db62a57cc385aedb1e8dff266b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5N2E0ZDM2Njg0NGRiNjJhNTdjYzM4NWFlZGIxZThkZmYyNjZiNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-11-03T01:05:08Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-11-03T01:05:08Z"}, "message": "locale_facets.tcc (num_get<>::_M_extract_int): Evaluate *__beg the exact strict minimum number of times...\n\n2004-11-02  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_int):\n\tEvaluate *__beg the exact strict minimum number of times; likewise\n\tfor __beg != __end; slightly simplify main parsing loop.\n\nFrom-SVN: r90012", "tree": {"sha": "8278f7b33c552baf8aba4a1ea1e9deecbd183969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8278f7b33c552baf8aba4a1ea1e9deecbd183969"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e597a4d366844db62a57cc385aedb1e8dff266b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e597a4d366844db62a57cc385aedb1e8dff266b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e597a4d366844db62a57cc385aedb1e8dff266b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e597a4d366844db62a57cc385aedb1e8dff266b5/comments", "author": null, "committer": null, "parents": [{"sha": "36f4d1449ca5c83321e28cdffaf0182373b1e8d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f4d1449ca5c83321e28cdffaf0182373b1e8d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f4d1449ca5c83321e28cdffaf0182373b1e8d7"}], "stats": {"total": 163, "additions": 89, "deletions": 74}, "files": [{"sha": "9063603c0a29c997241a156c84aefee7b477be46", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597a4d366844db62a57cc385aedb1e8dff266b5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597a4d366844db62a57cc385aedb1e8dff266b5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e597a4d366844db62a57cc385aedb1e8dff266b5", "patch": "@@ -1,3 +1,9 @@\n+2004-11-02  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_int):\n+\tEvaluate *__beg the exact strict minimum number of times; likewise\n+\tfor __beg != __end; slightly simplify main parsing loop.\n+\n 2004-11-02  Benjamin Kosnik  <bkoz@redhat.com>\n   \t    Lothar Werzinger  <lothar@xcerla.com>\n \t\n@@ -34,9 +40,9 @@\n \t\n 2004-11-01  Chris Jefferson  <chris@bubblescope.net>\n \n-        PR libstdc++/18159\n-        * include/tr1/tuple (get(pair)): Change occurrences of _I to _Int.\n-        (get(const pair)): Likewise.\n+\tPR libstdc++/18159\n+\t* include/tr1/tuple (get(pair)): Change occurrences of _I to _Int.\n+\t(get(const pair)): Likewise.\n \n 2004-11-01  Paolo Carlini  <pcarlini@suse.de>\n "}, {"sha": "c32a65da765e66cbd351404b582f13c64f80a14f", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 80, "deletions": 71, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597a4d366844db62a57cc385aedb1e8dff266b5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597a4d366844db62a57cc385aedb1e8dff266b5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=e597a4d366844db62a57cc385aedb1e8dff266b5", "patch": "@@ -301,10 +301,8 @@ namespace std\n \t    }\n \t}\n \n-      // True if a mantissa is found.\n-      bool __found_mantissa = false;\n-\n       // Next, look for leading zeros.\n+      bool __found_mantissa = false;\n       while (!__testeof)\n \t{\n \t  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep\n@@ -452,64 +450,78 @@ namespace std\n \tconst locale& __loc = __io._M_getloc();\n \tconst __cache_type* __lc = __uc(__loc);\n \tconst _CharT* __lit = __lc->_M_atoms_in;\n+\tchar_type __c = char_type();\n \n \t// NB: Iff __basefield == 0, __base can change based on contents.\n \tconst ios_base::fmtflags __basefield = __io.flags()\n \t                                       & ios_base::basefield;\n \tconst bool __oct = __basefield == ios_base::oct;\n \tint __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);\n \n-\t// True if numeric digits are found.\n-\tbool __found_num = false;\n+\t// True if __beg becomes equal to __end.\n+\tbool __testeof = __beg == __end;\n \n \t// First check for sign.\n \tbool __negative = false;\n-\tif (__beg != __end)\n+\tif (!__testeof)\n \t  {\n-\t    const char_type __c = *__beg;\n+\t    __c = *__beg;\n \t    if (numeric_limits<_ValueT>::is_signed)\n \t      __negative = __c == __lit[__num_base::_S_iminus];\n \t    if ((__negative || __c == __lit[__num_base::_S_iplus])\n \t\t&& !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n \t\t&& !(__c == __lc->_M_decimal_point))\n-\t      ++__beg;\n+\t      {\n+\t\tif (++__beg != __end)\n+\t\t  __c = *__beg;\n+\t\telse\n+\t\t  __testeof = true;\n+\t      }\n \t  }\n \n \t// Next, look for leading zeros and check required digits\n \t// for base formats.\n-\twhile (__beg != __end)\n+\tbool __found_zero = false;\n+\twhile (!__testeof)\n \t  {\n-\t    const char_type __c = *__beg;\n \t    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep\n \t\t|| __c == __lc->_M_decimal_point)\n \t      break;\n \t    else if (__c == __lit[__num_base::_S_izero] \n-\t\t     && (!__found_num || __base == 10))\n-\t      {\n-\t\t__found_num = true;\n-\t\t++__beg;\n-\t      }\n-\t    else if (__found_num)\n+\t\t     && (!__found_zero || __base == 10))\n+\t      __found_zero = true;\n+\t    else if (__found_zero)\n \t      {\n \t\tif (__c == __lit[__num_base::_S_ix] \n \t\t    || __c == __lit[__num_base::_S_iX])\n \t\t  {\n \t\t    if (__basefield == 0)\n \t\t      __base = 16;\n \t\t    if (__base == 16)\n-\t\t      {\n-\t\t\t__found_num = false;\n-\t\t\t++__beg;\n-\t\t      }\n+\t\t      __found_zero = false;\n+\t\t    else\n+\t\t      break;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (__basefield == 0)\n+\t\t      __base = 8;\n+\t\t    break;\n \t\t  }\n-\t\telse if (__basefield == 0)\n-\t\t  __base = 8;\n-\t\tbreak;\n \t      }\n \t    else\n \t      break;\n-\t  }\n \n+\t    if (++__beg != __end)\n+\t      {\n+\t\t__c = *__beg;\n+\t\tif (!__found_zero)\n+\t\t  break;\n+\t      }\n+\t    else\n+\t      __testeof = true;\n+\t  }\n+\t\n \t// At this point, base is determined. If not hex, only allow\n \t// base digits as valid input.\n \tconst size_t __len = (__base == 16 ? __num_base::_S_iend\n@@ -522,15 +534,15 @@ namespace std\n \tint __sep_pos = 0;\n \tbool __overflow = false;\n \t_ValueT __result = 0;\n+\tconst char_type* __q;\n \tconst char_type* __lit_zero = __lit + __num_base::_S_izero;\n \tif (__negative)\n \t  {\n \t    const _ValueT __min = numeric_limits<_ValueT>::min() / __base;\n-\t    for (; __beg != __end; ++__beg)\n+\t    while (!__testeof)\n \t      {\n \t\t// According to 22.2.2.1.2, p8-9, first look for thousands_sep\n \t\t// and decimal_point.\n-\t\tconst char_type __c = *__beg;\n \t\tif (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n \t\t  {\n \t\t    // NB: Thousands separator at the beginning of a string\n@@ -548,39 +560,37 @@ namespace std\n \t\t  }\n \t\telse if (__c == __lc->_M_decimal_point)\n \t\t  break;\n-\t\telse\n+\t\telse if ((__q = __traits_type::find(__lit_zero, __len, __c)))\n \t\t  {\n-\t\t    const char_type* __q = __traits_type::find(__lit_zero, \n-\t\t\t\t\t\t\t       __len, __c);\n-\t\t    if (__q)\n+\t\t    int __digit = __q - __lit_zero;\n+\t\t    if (__digit > 15)\n+\t\t      __digit -= 6;\n+\t\t    if (__result < __min)\n+\t\t      __overflow = true;\n+\t\t    else\n \t\t      {\n-\t\t\tint __digit = __q - __lit_zero;\n-\t\t\tif (__digit > 15)\n-\t\t\t  __digit -= 6;\n-\t\t\tif (__result < __min)\n-\t\t\t  __overflow = true;\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    const _ValueT __new_result = (__result * __base\n-\t\t\t\t\t\t\t  - __digit);\n-\t\t\t    __overflow |= __new_result > __result;\n-\t\t\t    __result = __new_result;\n-\t\t\t    ++__sep_pos;\n-\t\t\t    __found_num = true;\n-\t\t\t  }\n+\t\t\tconst _ValueT __new_result = (__result * __base\n+\t\t\t\t\t\t      - __digit);\n+\t\t\t__overflow |= __new_result > __result;\n+\t\t\t__result = __new_result;\n+\t\t\t++__sep_pos;\n \t\t      }\n-\t\t    else\n-\t\t      // Not a valid input item.\n-\t\t      break;\n \t\t  }\n+\t\telse\n+\t\t  // Not a valid input item.\n+\t\t  break;\n+\n+\t\tif (++__beg != __end)\n+\t\t  __c = *__beg;\n+\t\telse\n+\t\t  __testeof = true;\n \t      }\n \t  }\n \telse\n \t  {\n \t    const _ValueT __max = numeric_limits<_ValueT>::max() / __base;\n-\t    for (; __beg != __end; ++__beg)\n+\t    while (!__testeof)\n \t      {\n-\t\tconst char_type __c = *__beg;\n \t\tif (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n \t\t  {\n \t\t    if (__sep_pos)\n@@ -596,30 +606,29 @@ namespace std\n \t\t  }\n \t\telse if (__c == __lc->_M_decimal_point)\n \t\t  break;\n-\t\telse\n+\t\telse if ((__q = __traits_type::find(__lit_zero, __len, __c)))\n \t\t  {\n-\t\t    const char_type* __q = __traits_type::find(__lit_zero,\n-\t\t\t\t\t\t\t       __len, __c);    \n-\t\t    if (__q)\n+\t\t    int __digit = __q - __lit_zero;\n+\t\t    if (__digit > 15)\n+\t\t      __digit -= 6;\n+\t\t    if (__result > __max)\n+\t\t      __overflow = true;\n+\t\t    else\n \t\t      {\n-\t\t\tint __digit = __q - __lit_zero;\n-\t\t\tif (__digit > 15)\n-\t\t\t  __digit -= 6;\n-\t\t\tif (__result > __max)\n-\t\t\t  __overflow = true;\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    const _ValueT __new_result = (__result * __base\n-\t\t\t\t\t\t\t  + __digit);\n-\t\t\t    __overflow |= __new_result < __result;\n-\t\t\t    __result = __new_result;\n-\t\t\t    ++__sep_pos;\n-\t\t\t    __found_num = true;\n-\t\t\t  }\n+\t\t\tconst _ValueT __new_result = (__result * __base\n+\t\t\t\t\t\t      + __digit);\n+\t\t\t__overflow |= __new_result < __result;\n+\t\t\t__result = __new_result;\n+\t\t\t++__sep_pos;\n \t\t      }\n-\t\t    else\n-\t\t      break;\n \t\t  }\n+\t\telse\n+\t\t  break;\n+\n+\t\tif (++__beg != __end)\n+\t\t  __c = *__beg;\n+\t\telse\n+\t\t  __testeof = true;\n \t      }\n \t  }\n \n@@ -637,12 +646,12 @@ namespace std\n \t  }\n \n \tif (!(__err & ios_base::failbit) && !__overflow\n-\t    && __found_num)\n+\t    && (__sep_pos || __found_zero || __found_grouping.size()))\n \t  __v = __result;\n \telse\n \t  __err |= ios_base::failbit;\n \n-\tif (__beg == __end)\n+\tif (__testeof)\n \t  __err |= ios_base::eofbit;\n \treturn __beg;\n       }"}]}