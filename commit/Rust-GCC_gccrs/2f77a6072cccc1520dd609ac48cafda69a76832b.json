{"sha": "2f77a6072cccc1520dd609ac48cafda69a76832b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY3N2E2MDcyY2NjYzE1MjBkZDYwOWFjNDhjYWZkYTY5YTc2ODMyYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:35:20Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:35:20Z"}, "message": "Change use to type-based pool allocator in lra.c.\n\n\t* lra.c (init_insn_regs): Use new type-based pool allocator.\n\t(new_insn_reg) Likewise.\n\t(free_insn_reg) Likewise.\n\t(free_insn_regs) Likewise.\n\t(finish_insn_regs) Likewise.\n\t(init_insn_recog_data) Likewise.\n\t(init_reg_info) Likewise.\n\t(finish_reg_info) Likewise.\n\t(lra_free_copies) Likewise.\n\t(lra_create_copy) Likewise.\n\t(invalidate_insn_data_regno_info) Likewise.\n\nFrom-SVN: r223945", "tree": {"sha": "008a159a89c869dd4720803459e82654d1921879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/008a159a89c869dd4720803459e82654d1921879"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f77a6072cccc1520dd609ac48cafda69a76832b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f77a6072cccc1520dd609ac48cafda69a76832b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f77a6072cccc1520dd609ac48cafda69a76832b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f77a6072cccc1520dd609ac48cafda69a76832b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb8abb1cf9f96365d7fa1f4583ab3cb845876f17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb8abb1cf9f96365d7fa1f4583ab3cb845876f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb8abb1cf9f96365d7fa1f4583ab3cb845876f17"}], "stats": {"total": 85, "additions": 55, "deletions": 30}, "files": [{"sha": "10b6a107b6ab83680285e820e55e7f6121118d6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f77a6072cccc1520dd609ac48cafda69a76832b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f77a6072cccc1520dd609ac48cafda69a76832b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f77a6072cccc1520dd609ac48cafda69a76832b", "patch": "@@ -1,3 +1,17 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* lra.c (init_insn_regs): Use new type-based pool allocator.\n+\t(new_insn_reg) Likewise.\n+\t(free_insn_reg) Likewise.\n+\t(free_insn_regs) Likewise.\n+\t(finish_insn_regs) Likewise.\n+\t(init_insn_recog_data) Likewise.\n+\t(init_reg_info) Likewise.\n+\t(finish_reg_info) Likewise.\n+\t(lra_free_copies) Likewise.\n+\t(lra_create_copy) Likewise.\n+\t(invalidate_insn_data_regno_info) Likewise.\n+\n 2015-06-01  Martin Liska  <mliska@suse.cz>\n \n \t* lra-lives.c (free_live_range): Use new type-based pool allocator."}, {"sha": "25bd3cefd818bb0eaca035f93f402008182c1bd4", "filename": "gcc/lra-int.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f77a6072cccc1520dd609ac48cafda69a76832b/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f77a6072cccc1520dd609ac48cafda69a76832b/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=2f77a6072cccc1520dd609ac48cafda69a76832b", "patch": "@@ -84,6 +84,22 @@ struct lra_copy\n   int regno1, regno2;\n   /* Next copy with correspondingly REGNO1 and REGNO2.\t*/\n   lra_copy_t regno1_next, regno2_next;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((lra_copy *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<lra_copy> pool;\n+\n };\n \n /* Common info about a register (pseudo or hard register).  */\n@@ -191,6 +207,21 @@ struct lra_insn_reg\n   int regno;\n   /* Next reg info of the same insn.  */\n   struct lra_insn_reg *next;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((lra_insn_reg *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<lra_insn_reg> pool;\n };\n \n /* Static part (common info for insns with the same ICODE) of LRA"}, {"sha": "456f618203dcdc5184a28c76ede54bced2b4cc12", "filename": "gcc/lra.c", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f77a6072cccc1520dd609ac48cafda69a76832b/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f77a6072cccc1520dd609ac48cafda69a76832b/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=2f77a6072cccc1520dd609ac48cafda69a76832b", "patch": "@@ -550,15 +550,7 @@ lra_update_dups (lra_insn_recog_data_t id, signed char *nops)\n    insns.  */\n \n /* Pools for insn reg info.  */\n-static alloc_pool insn_reg_pool;\n-\n-/* Initiate pool for insn reg info.  */\n-static void\n-init_insn_regs (void)\n-{\n-  insn_reg_pool\n-    = create_alloc_pool (\"insn regs\", sizeof (struct lra_insn_reg), 100);\n-}\n+pool_allocator<lra_insn_reg> lra_insn_reg::pool (\"insn regs\", 100);\n \n /* Create LRA insn related info about a reference to REGNO in INSN with\n    TYPE (in/out/inout), biggest reference mode MODE, flag that it is\n@@ -570,9 +562,7 @@ new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n \t      machine_mode mode,\n \t      bool subreg_p, bool early_clobber, struct lra_insn_reg *next)\n {\n-  struct lra_insn_reg *ir;\n-\n-  ir = (struct lra_insn_reg *) pool_alloc (insn_reg_pool);\n+  lra_insn_reg *ir = new lra_insn_reg ();\n   ir->type = type;\n   ir->biggest_mode = mode;\n   if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (lra_reg_info[regno].biggest_mode)\n@@ -585,13 +575,6 @@ new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n   return ir;\n }\n \n-/* Free insn reg info IR.  */\n-static void\n-free_insn_reg (struct lra_insn_reg *ir)\n-{\n-  pool_free (insn_reg_pool, ir);\n-}\n-\n /* Free insn reg info list IR.\t*/\n static void\n free_insn_regs (struct lra_insn_reg *ir)\n@@ -601,15 +584,15 @@ free_insn_regs (struct lra_insn_reg *ir)\n   for (; ir != NULL; ir = next_ir)\n     {\n       next_ir = ir->next;\n-      free_insn_reg (ir);\n+      delete ir;\n     }\n }\n \n /* Finish pool for insn reg info.  */\n static void\n finish_insn_regs (void)\n {\n-  free_alloc_pool (insn_reg_pool);\n+  lra_insn_reg::pool.release ();\n }\n \n \f\n@@ -737,7 +720,6 @@ init_insn_recog_data (void)\n {\n   lra_insn_recog_data_len = 0;\n   lra_insn_recog_data = NULL;\n-  init_insn_regs ();\n }\n \n /* Expand, if necessary, LRA data about insns.\t*/\n@@ -791,6 +773,8 @@ finish_insn_recog_data (void)\n     if ((data = lra_insn_recog_data[i]) != NULL)\n       free_insn_recog_data (data);\n   finish_insn_regs ();\n+  lra_copy::pool.release ();\n+  lra_insn_reg::pool.release ();\n   free (lra_insn_recog_data);\n }\n \n@@ -1310,7 +1294,7 @@ get_new_reg_value (void)\n }\n \n /* Pools for copies.  */\n-static alloc_pool copy_pool;\n+pool_allocator<lra_copy> lra_copy::pool (\"lra copies\", 100);\n \n /* Vec referring to pseudo copies.  */\n static vec<lra_copy_t> copy_vec;\n@@ -1350,8 +1334,6 @@ init_reg_info (void)\n   lra_reg_info = XNEWVEC (struct lra_reg, reg_info_size);\n   for (i = 0; i < reg_info_size; i++)\n     initialize_lra_reg_info_element (i);\n-  copy_pool\n-    = create_alloc_pool (\"lra copies\", sizeof (struct lra_copy), 100);\n   copy_vec.create (100);\n }\n \n@@ -1366,8 +1348,6 @@ finish_reg_info (void)\n     bitmap_clear (&lra_reg_info[i].insn_bitmap);\n   free (lra_reg_info);\n   reg_info_size = 0;\n-  free_alloc_pool (copy_pool);\n-  copy_vec.release ();\n }\n \n /* Expand common reg info if it is necessary.  */\n@@ -1394,7 +1374,7 @@ lra_free_copies (void)\n     {\n       cp = copy_vec.pop ();\n       lra_reg_info[cp->regno1].copies = lra_reg_info[cp->regno2].copies = NULL;\n-      pool_free (copy_pool, cp);\n+      delete cp;\n     }\n }\n \n@@ -1416,7 +1396,7 @@ lra_create_copy (int regno1, int regno2, int freq)\n       regno2 = regno1;\n       regno1 = temp;\n     }\n-  cp = (lra_copy_t) pool_alloc (copy_pool);\n+  cp = new lra_copy ();\n   copy_vec.safe_push (cp);\n   cp->regno1_dest_p = regno1_dest_p;\n   cp->freq = freq;\n@@ -1585,7 +1565,7 @@ invalidate_insn_data_regno_info (lra_insn_recog_data_t data, rtx_insn *insn,\n     {\n       i = ir->regno;\n       next_ir = ir->next;\n-      free_insn_reg (ir);\n+      delete ir;\n       bitmap_clear_bit (&lra_reg_info[i].insn_bitmap, uid);\n       if (i >= FIRST_PSEUDO_REGISTER && ! debug_p)\n \t{"}]}