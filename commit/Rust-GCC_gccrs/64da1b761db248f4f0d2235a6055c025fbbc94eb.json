{"sha": "64da1b761db248f4f0d2235a6055c025fbbc94eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRkYTFiNzYxZGIyNDhmNGYwZDIyMzVhNjA1NWMwMjVmYmJjOTRlYg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-27T21:06:35Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-27T21:13:33Z"}, "message": "c++: Delegating constructor in constexpr init [PR94772]\n\nIn the first testcase below, the call to the target constructor foo{} from foo's\ndelegating constructor is encoded as the INIT_EXPR\n\n  *(struct foo *) this = AGGR_INIT_EXPR <4, __ct_comp, D.2140, ...>;\n\nDuring initialization of the variable 'bar', we prematurely set TREE_READONLY on\nbar's CONSTRUCTOR in two places before the outer delegating constructor has\nreturned: first, at the end of cxx_eval_call_expression after evaluating the RHS\nof the above INIT_EXPR, and second, at the end of cxx_eval_store_expression\nafter having finished evaluating the above INIT_EXPR.  This then prevents the\nrest of the outer delegating constructor from mutating 'bar'.\n\nThis (hopefully minimally risky) patch makes cxx_eval_call_expression refrain\nfrom setting TREE_READONLY when evaluating the target constructor of a\ndelegating constructor.  It also makes cxx_eval_store_expression refrain from\nsetting TREE_READONLY when the object being initialized is \"*this', on the basis\nthat it should be the responsibility of the routine that set 'this' in the first\nplace to set the object's TREE_READONLY appropriately.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94772\n\t* constexpr.c (cxx_eval_call_expression): Don't set new_obj if we're\n\tevaluating the target constructor of a delegating constructor.\n\t(cxx_eval_store_expression): Don't set TREE_READONLY if the LHS of the\n\tINIT_EXPR is '*this'.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94772\n\t* g++.dg/cpp1y/constexpr-tracking-const23.C: New test.\n\t* g++.dg/cpp1y/constexpr-tracking-const24.C: New test.\n\t* g++.dg/cpp1y/constexpr-tracking-const25.C: New test.", "tree": {"sha": "cd386cb1de5cf78623cf6ce55493058e4c22b602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd386cb1de5cf78623cf6ce55493058e4c22b602"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64da1b761db248f4f0d2235a6055c025fbbc94eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64da1b761db248f4f0d2235a6055c025fbbc94eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64da1b761db248f4f0d2235a6055c025fbbc94eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64da1b761db248f4f0d2235a6055c025fbbc94eb/comments", "author": null, "committer": null, "parents": [{"sha": "067ebf841300127d9616ddde0b37db03cff60347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067ebf841300127d9616ddde0b37db03cff60347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/067ebf841300127d9616ddde0b37db03cff60347"}], "stats": {"total": 156, "additions": 155, "deletions": 1}, "files": [{"sha": "8cb958f36fb14ce62024b79f626791ecf354552e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=64da1b761db248f4f0d2235a6055c025fbbc94eb", "patch": "@@ -1,3 +1,11 @@\n+2020-04-27  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94772\n+\t* constexpr.c (cxx_eval_call_expression): Don't set new_obj if we're\n+\tevaluating the target constructor of a delegating constructor.\n+\t(cxx_eval_store_expression): Don't set TREE_READONLY if the LHS of the\n+\tINIT_EXPR is '*this'.\n+\n 2020-04-26  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/90320"}, {"sha": "637cb746576ec4423802d57808f95219dd0d993b", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=64da1b761db248f4f0d2235a6055c025fbbc94eb", "patch": "@@ -2371,6 +2371,21 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       STRIP_NOPS (new_obj);\n       if (TREE_CODE (new_obj) == ADDR_EXPR)\n \tnew_obj = TREE_OPERAND (new_obj, 0);\n+\n+      if (ctx->call && ctx->call->fundef\n+\t  && DECL_CONSTRUCTOR_P (ctx->call->fundef->decl))\n+\t{\n+\t  tree cur_obj = TREE_VEC_ELT (ctx->call->bindings, 0);\n+\t  STRIP_NOPS (cur_obj);\n+\t  if (TREE_CODE (cur_obj) == ADDR_EXPR)\n+\t    cur_obj = TREE_OPERAND (cur_obj, 0);\n+\t  if (new_obj == cur_obj)\n+\t    /* We're calling the target constructor of a delegating\n+\t       constructor, or accessing a base subobject through a\n+\t       NOP_EXPR as part of a call to a base constructor, so\n+\t       there is no new (sub)object.  */\n+\t    new_obj = NULL_TREE;\n+\t}\n     }\n \n   tree result = NULL_TREE;\n@@ -4950,7 +4965,18 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   if (TREE_CODE (t) == INIT_EXPR\n       && TREE_CODE (*valp) == CONSTRUCTOR\n       && TYPE_READONLY (type))\n-    TREE_READONLY (*valp) = true;\n+    {\n+      if (INDIRECT_REF_P (target)\n+\t  && (is_this_parameter\n+\t      (tree_strip_nop_conversions (TREE_OPERAND (target, 0)))))\n+\t/* We've just initialized '*this' (perhaps via the target\n+\t   constructor of a delegating constructor).  Leave it up to the\n+\t   caller that set 'this' to set TREE_READONLY appropriately.  */\n+\tgcc_checking_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t\t     (TREE_TYPE (target), type));\n+      else\n+\tTREE_READONLY (*valp) = true;\n+    }\n \n   /* Update TREE_CONSTANT and TREE_SIDE_EFFECTS on enclosing\n      CONSTRUCTORs, if any.  */"}, {"sha": "39a984c05e1804bae29fb9cf01f15ecf13f0945f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=64da1b761db248f4f0d2235a6055c025fbbc94eb", "patch": "@@ -1,3 +1,10 @@\n+2020-04-27  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94772\n+\t* g++.dg/cpp1y/constexpr-tracking-const23.C: New test.\n+\t* g++.dg/cpp1y/constexpr-tracking-const24.C: New test.\n+\t* g++.dg/cpp1y/constexpr-tracking-const25.C: New test.\n+\n 2020-04-27  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \tPR target/94697"}, {"sha": "c6643c78a6f3122b18fbcd9d226284004eccd15e", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-tracking-const23.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const23.C?ref=64da1b761db248f4f0d2235a6055c025fbbc94eb", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/94772\n+// { dg-do compile { target c++14 } }\n+\n+struct foo\n+{\n+  int x{};\n+\n+  constexpr foo() noexcept = default;\n+\n+  constexpr foo(int a) : foo{}\n+  { x = -a; }\n+\n+  constexpr foo(int a, int b) : foo{a}\n+  { x += a + b; }\n+};\n+\n+int main()\n+{\n+  constexpr foo bar{1, 2};\n+  static_assert(bar.x == 2, \"\");\n+}"}, {"sha": "2c923f69cf4c0ce2a8fd7a2edfee36d9cd3406a9", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-tracking-const24.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const24.C?ref=64da1b761db248f4f0d2235a6055c025fbbc94eb", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/94772\n+// { dg-do compile { target c++14 } }\n+\n+struct base\n+{\n+  base() = default;\n+\n+  constexpr base(int) : base{} { }\n+};\n+\n+struct foo : base\n+{\n+  int x{};\n+\n+  constexpr foo(int a) : base{a}\n+  { x = -a; }\n+\n+  constexpr foo(int a, int b) : foo{a}\n+  { x += a + b; }\n+};\n+\n+int main()\n+{\n+  constexpr foo bar{1, 2};\n+  static_assert(bar.x == 2, \"\");\n+}"}, {"sha": "499dd5c693710188a05e7b5c2cdf54aada19deca", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-tracking-const25.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64da1b761db248f4f0d2235a6055c025fbbc94eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-tracking-const25.C?ref=64da1b761db248f4f0d2235a6055c025fbbc94eb", "patch": "@@ -0,0 +1,66 @@\n+// PR c++/94772\n+// { dg-do compile { target c++14 } }\n+\n+template<int>\n+struct base\n+{\n+  int y{};\n+\n+  base() = default;\n+\n+  constexpr base(int a) : base{}\n+  { y = a; }\n+};\n+\n+struct foo : base<1>, base<2>\n+{\n+  int x{};\n+\n+  constexpr foo() : base<2>{}\n+  {\n+    ++x; --x;\n+    ++base<1>::y;\n+    ++base<2>::y;\n+  }\n+\n+  constexpr foo(int a) : base<2>{a}\n+  {\n+    x = -base<2>::y;\n+    ++base<1>::y;\n+    ++base<2>::y;\n+  }\n+\n+  constexpr foo(int a, int b) : foo{a}\n+  {\n+    x += a + b;\n+    ++base<1>::y;\n+    ++base<2>::y;\n+  }\n+\n+  constexpr foo(int a, int b, int c) : base<1>{a}\n+  {\n+    x += a + b + c;\n+    ++base<1>::y;\n+    ++base<2>::y;\n+  }\n+};\n+\n+#define SA(X) static_assert(X, #X)\n+\n+int main()\n+{\n+  constexpr foo bar1{1, 2};\n+  SA( bar1.x == 2 );\n+  SA( bar1.base<1>::y == 2 );\n+  SA( bar1.base<2>::y == 3 );\n+\n+  constexpr foo bar2{1, 2, 3};\n+  SA( bar2.x == 6 );\n+  SA( bar2.base<1>::y == 2 );\n+  SA( bar2.base<2>::y == 1 );\n+\n+  constexpr foo bar3{};\n+  SA( bar3.x == 0 );\n+  SA( bar3.base<1>::y == 1 );\n+  SA( bar3.base<2>::y == 1 );\n+}"}]}