{"sha": "ba5c3b24481744e06d1cf308b42ecef89587a4ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE1YzNiMjQ0ODE3NDRlMDZkMWNmMzA4YjQyZWNlZjg5NTg3YTRiYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-11T16:34:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-11T16:34:16Z"}, "message": "cprop.c: Adjust outdated comments throughout.\n\n\t* cprop.c: Adjust outdated comments throughout.\n\t(hash_scan_set): Rename PAT parameter into SET.\n\t(cprop_pavloc): Rename into...\n\t(cprop_avloc): ...this.\n\t(cprop_absaltered): Rename into...\n\t(cprop_kill): ...this.\n\t(alloc_cprop_mem): Adjust for above renaming.\n\t(free_cprop_mem): Likewise.\n\t(compute_cprop_data): Likewise.\n\t(compute_local_properties): Rename TRANSP parameter into KILL and\n\tadjust throughout.  Rework comments.\n\t(try_replace_reg): Fix long line.\n\t(cprop_jump): Likewise.\n\t(constprop_register): Fix prototype and take INSN last.\n\t(cprop_insn): Adjust calls to above function.  Fix long lines.\n\t(bypass_block): Likewise.\n\t(one_cprop_pass): Likewise.\n\nFrom-SVN: r181289", "tree": {"sha": "4b192c28f04356d37014b860c9d346e43d2dab1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b192c28f04356d37014b860c9d346e43d2dab1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba5c3b24481744e06d1cf308b42ecef89587a4ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba5c3b24481744e06d1cf308b42ecef89587a4ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba5c3b24481744e06d1cf308b42ecef89587a4ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba5c3b24481744e06d1cf308b42ecef89587a4ba/comments", "author": null, "committer": null, "parents": [{"sha": "ee66e604c3804ffb22c405972a2d0009bc10b969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee66e604c3804ffb22c405972a2d0009bc10b969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee66e604c3804ffb22c405972a2d0009bc10b969"}], "stats": {"total": 174, "additions": 100, "deletions": 74}, "files": [{"sha": "67d0defd048260cb3d2d6a0b79174d2decc8244f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba5c3b24481744e06d1cf308b42ecef89587a4ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba5c3b24481744e06d1cf308b42ecef89587a4ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba5c3b24481744e06d1cf308b42ecef89587a4ba", "patch": "@@ -1,3 +1,23 @@\n+2011-11-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* cprop.c: Adjust outdated comments throughout.\n+\t(hash_scan_set): Rename PAT parameter into SET.\n+\t(cprop_pavloc): Rename into...\n+\t(cprop_avloc): ...this.\n+\t(cprop_absaltered): Rename into...\n+\t(cprop_kill): ...this.\n+\t(alloc_cprop_mem): Adjust for above renaming.\n+\t(free_cprop_mem): Likewise.\n+\t(compute_cprop_data): Likewise.\n+\t(compute_local_properties): Rename TRANSP parameter into KILL and\n+\tadjust throughout.  Rework comments.\n+\t(try_replace_reg): Fix long line.\n+\t(cprop_jump): Likewise.\n+\t(constprop_register): Fix prototype and take INSN last.\n+\t(cprop_insn): Adjust calls to above function.  Fix long lines.\n+\t(bypass_block): Likewise.\n+\t(one_cprop_pass): Likewise.\n+\n 2011-11-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/elf.h (ELF_ASCII_ESCAPES): Rename from ESCAPES.\n@@ -23,6 +43,18 @@\n \tRevert\n \t2011-11-05  David S. Miller  <davem@davemloft.net>\n \n+\t* config/sparc/sparc.md (UNSPEC_SHORT_LOAD): New unspec.\n+\t(zero-extend_v8qi_vis, zero_extend_v4hi_vis): New expanders.\n+\t(*zero_extend_v8qi_<P:mode>_insn,\n+\t*zero_extend_v4hi_<P:mode>_insn): New insns.\n+\t* config/sparc/sparc.c (vector_init_move_words,\n+\tvector_init_prepare_elts, sparc_expand_vector_init_vis2,\n+\tsparc_expand_vector_init_vis1): New functions.\n+\t(vector_init_bshuffle): Rewrite to handle more cases and make use\n+\tof locs[] array prepared by vector_init_prepare_elts.\n+\t(vector_init_fpmerge, vector_init_faligndata): Delete.\n+\t(sparc_expand_vector_init): Rewrite using new infrastructure.\n+\n 2011-11-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* opts-common.c (generate_canonical_option): Free opt_text"}, {"sha": "9ee1efb1af6fd1c3efa8daf5be41dfadaadd6ecf", "filename": "gcc/cprop.c", "status": "modified", "additions": 68, "deletions": 74, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba5c3b24481744e06d1cf308b42ecef89587a4ba/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba5c3b24481744e06d1cf308b42ecef89587a4ba/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=ba5c3b24481744e06d1cf308b42ecef89587a4ba", "patch": "@@ -69,7 +69,7 @@ typedef struct occr *occr_t;\n DEF_VEC_P (occr_t);\n DEF_VEC_ALLOC_P (occr_t, heap);\n \n-/* Hash table entry for an assignment expressions.  */\n+/* Hash table entry for assignment expressions.  */\n \n struct expr\n {\n@@ -83,8 +83,8 @@ struct expr\n   struct expr *next_same_hash;\n   /* List of available occurrence in basic blocks in the function.\n      An \"available occurrence\" is one that is the last occurrence in the\n-     basic block and the operands are not modified by following statements in\n-     the basic block [including this insn].  */\n+     basic block and whose operands are not modified by following statements\n+     in the basic block [including this insn].  */\n   struct occr *avail_occr;\n };\n \n@@ -136,7 +136,6 @@ static int local_copy_prop_count;\n static int global_const_prop_count;\n /* Number of global copies propagated.  */\n static int global_copy_prop_count;\n-\f\n \n #define GOBNEW(T)\t\t((T *) cprop_alloc (sizeof (T)))\n #define GOBNEWVAR(T, S)\t\t((T *) cprop_alloc ((S)))\n@@ -256,14 +255,13 @@ cprop_constant_p (const_rtx x)\n   return CONSTANT_P (x) && (GET_CODE (x) != CONST || shared_const_p (x));\n }\n \n-/* Scan pattern PAT of INSN and add an entry to the hash TABLE (set or\n-   expression one).  */\n+/* Scan SET present in INSN and add an entry to the hash TABLE.  */\n \n static void\n-hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n+hash_scan_set (rtx set, rtx insn, struct hash_table_d *table)\n {\n-  rtx src = SET_SRC (pat);\n-  rtx dest = SET_DEST (pat);\n+  rtx src = SET_SRC (set);\n+  rtx dest = SET_DEST (set);\n \n   if (REG_P (dest)\n       && ! HARD_REGISTER_P (dest)\n@@ -288,7 +286,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t  && REG_NOTE_KIND (note) == REG_EQUAL\n \t  && !REG_P (src)\n \t  && cprop_constant_p (XEXP (note, 0)))\n-\tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n+\tsrc = XEXP (note, 0), set = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Record sets for constant/copy propagation.  */\n       if ((REG_P (src)\n@@ -300,16 +298,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n     }\n }\n \n-/* Process INSN and add hash table entries as appropriate.\n-\n-   Only available expressions that set a single pseudo-reg are recorded.\n-\n-   Single sets in a PARALLEL could be handled, but it's an extra complication\n-   that isn't dealt with right now.  The trick is handling the CLOBBERs that\n-   are also in the PARALLEL.  Later.\n-\n-   If SET_P is nonzero, this is for the assignment hash table,\n-   otherwise it is for the expression hash table.  */\n+/* Process INSN and add hash table entries as appropriate.  */\n \n static void\n hash_scan_insn (rtx insn, struct hash_table_d *table)\n@@ -332,6 +321,8 @@ hash_scan_insn (rtx insn, struct hash_table_d *table)\n       }\n }\n \n+/* Dump the hash table TABLE to file FILE under the name NAME.  */\n+\n static void\n dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n {\n@@ -373,6 +364,7 @@ dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n }\n \n /* Record as unavailable all registers that are DEF operands of INSN.  */\n+\n static void\n make_set_regs_unavailable (rtx insn)\n {\n@@ -383,7 +375,7 @@ make_set_regs_unavailable (rtx insn)\n     SET_REGNO_REG_SET (reg_set_bitmap, DF_REF_REGNO (*def_rec));\n }\n \n-/* Top level function to create an assignments hash table.\n+/* Top level function to create an assignment hash table.\n \n    Assignment entries are placed in the hash table if\n    - they are of the form (set (pseudo-reg) src),\n@@ -541,13 +533,12 @@ mark_oprs_set (rtx insn)\n   for (def_rec = DF_INSN_INFO_DEFS (insn_info); *def_rec; def_rec++)\n     SET_REGNO_REG_SET (reg_set_bitmap, DF_REF_REGNO (*def_rec));\n }\n-\n \f\n /* Compute copy/constant propagation working variables.  */\n \n /* Local properties of assignments.  */\n-static sbitmap *cprop_pavloc;\n-static sbitmap *cprop_absaltered;\n+static sbitmap *cprop_avloc;\n+static sbitmap *cprop_kill;\n \n /* Global properties of assignments (computed from the local properties).  */\n static sbitmap *cprop_avin;\n@@ -559,8 +550,8 @@ static sbitmap *cprop_avout;\n static void\n alloc_cprop_mem (int n_blocks, int n_sets)\n {\n-  cprop_pavloc = sbitmap_vector_alloc (n_blocks, n_sets);\n-  cprop_absaltered = sbitmap_vector_alloc (n_blocks, n_sets);\n+  cprop_avloc = sbitmap_vector_alloc (n_blocks, n_sets);\n+  cprop_kill = sbitmap_vector_alloc (n_blocks, n_sets);\n \n   cprop_avin = sbitmap_vector_alloc (n_blocks, n_sets);\n   cprop_avout = sbitmap_vector_alloc (n_blocks, n_sets);\n@@ -571,8 +562,8 @@ alloc_cprop_mem (int n_blocks, int n_sets)\n static void\n free_cprop_mem (void)\n {\n-  sbitmap_vector_free (cprop_pavloc);\n-  sbitmap_vector_free (cprop_absaltered);\n+  sbitmap_vector_free (cprop_avloc);\n+  sbitmap_vector_free (cprop_kill);\n   sbitmap_vector_free (cprop_avin);\n   sbitmap_vector_free (cprop_avout);\n }\n@@ -582,23 +573,23 @@ free_cprop_mem (void)\n    Local properties are those that are defined by the block, irrespective of\n    other blocks.\n \n-   An expression is transparent in a block if its operands are not modified\n-   in the block.\n+   An expression is killed in a block if its operands, either DEST or SRC, are\n+   modified in the block.\n \n    An expression is computed (locally available) in a block if it is computed\n    at least once and expression would contain the same value if the\n    computation was moved to the end of the block.\n \n-   TRANSP and COMP are destination sbitmaps for recording local properties.  */\n+   KILL and COMP are destination sbitmaps for recording local properties.  */\n \n static void\n-compute_local_properties (sbitmap *transp, sbitmap *comp,\n+compute_local_properties (sbitmap *kill, sbitmap *comp,\n \t\t\t  struct hash_table_d *table)\n {\n   unsigned int i;\n \n   /* Initialize the bitmaps that were passed in.  */\n-  sbitmap_vector_zero (transp, last_basic_block);\n+  sbitmap_vector_zero (kill, last_basic_block);\n   sbitmap_vector_zero (comp, last_basic_block);\n \n   for (i = 0; i < table->size; i++)\n@@ -611,20 +602,21 @@ compute_local_properties (sbitmap *transp, sbitmap *comp,\n \t  df_ref def;\n \t  struct occr *occr;\n \n-\t  /* The expression is transparent in a block if it is not killed,\n-\t     i.e. DEST and SRC are not set or clobbered in the block.\n-\t     We start by assuming all are transparent [none are killed],\n-\t     and then set the bits for those that are.  */\n+\t  /* For each definition of the destination pseudo-reg, the expression\n+\t     is killed in the block where the definition is.  */\n \t  for (def = DF_REG_DEF_CHAIN (REGNO (expr->dest));\n \t       def; def = DF_REF_NEXT_REG (def))\n-\t    SET_BIT (transp[DF_REF_BB (def)->index], indx);\n+\t    SET_BIT (kill[DF_REF_BB (def)->index], indx);\n+\n+\t  /* If the source is a pseudo-reg, for each definition of the source,\n+\t     the expression is killed in the block where the definition is.  */\n \t  if (REG_P (expr->src))\n \t    for (def = DF_REG_DEF_CHAIN (REGNO (expr->src));\n \t\t def; def = DF_REF_NEXT_REG (def))\n-\t      SET_BIT (transp[DF_REF_BB (def)->index], indx);\n+\t      SET_BIT (kill[DF_REF_BB (def)->index], indx);\n \n \t  /* The occurrences recorded in avail_occr are exactly those that\n-\t     we want to set to nonzero in COMP.  */\n+\t     are locally available in the block where they are.  */\n \t  for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n \t    {\n \t      SET_BIT (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n@@ -641,9 +633,8 @@ compute_local_properties (sbitmap *transp, sbitmap *comp,\n static void\n compute_cprop_data (void)\n {\n-  compute_local_properties (cprop_absaltered, cprop_pavloc, &set_hash_table);\n-  compute_available (cprop_pavloc, cprop_absaltered,\n-\t\t     cprop_avout, cprop_avin);\n+  compute_local_properties (cprop_kill, cprop_avloc, &set_hash_table);\n+  compute_available (cprop_avloc, cprop_kill, cprop_avout, cprop_avin);\n }\n \f\n /* Copy/constant propagation.  */\n@@ -748,9 +739,9 @@ try_replace_reg (rtx from, rtx to, rtx insn)\n \t\t\t simplify_replace_rtx (XEXP (note, 0), from, to));\n   if (!success && set && reg_mentioned_p (from, SET_SRC (set)))\n     {\n-      /* If above failed and this is a single set, try to simplify the source of\n-\t the set given our substitution.  We could perhaps try this for multiple\n-\t SETs, but it probably won't buy us anything.  */\n+      /* If above failed and this is a single set, try to simplify the source\n+\t of the set given our substitution.  We could perhaps try this for\n+\t multiple SETs, but it probably won't buy us anything.  */\n       src = simplify_replace_rtx (SET_SRC (set), from, to);\n \n       if (!rtx_equal_p (src, SET_SRC (set))\n@@ -770,7 +761,7 @@ try_replace_reg (rtx from, rtx to, rtx insn)\n          We could perhaps try this for multiple SETs, but it probably\n          won't buy us anything.  */\n       rtx dest = simplify_replace_rtx (SET_DEST (set), from, to);\n-      \n+\n       if (!rtx_equal_p (dest, SET_DEST (set))\n           && validate_change (insn, &SET_DEST (set), dest, 0))\n         success = 1;\n@@ -786,7 +777,7 @@ try_replace_reg (rtx from, rtx to, rtx insn)\n   return success;\n }\n \n-/* Find a set of REGNOs that are available on entry to INSN's block.  Returns\n+/* Find a set of REGNOs that are available on entry to INSN's block.  Return\n    NULL no such set is found.  */\n \n static struct expr *\n@@ -856,7 +847,7 @@ find_avail_set (int regno, rtx insn)\n    JUMP_INSNS.  JUMP must be a conditional jump.  If SETCC is non-NULL\n    it is the instruction that immediately precedes JUMP, and must be a\n    single SET of a register.  FROM is what we will try to replace,\n-   SRC is the constant we will try to substitute for it.  Returns nonzero\n+   SRC is the constant we will try to substitute for it.  Return nonzero\n    if a change was made.  */\n \n static int\n@@ -940,8 +931,8 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n   if (dump_file != NULL)\n     {\n       fprintf (dump_file,\n-\t       \"GLOBAL CONST-PROP: Replacing reg %d in jump_insn %d with constant \",\n-\t       REGNO (from), INSN_UID (jump));\n+\t       \"GLOBAL CONST-PROP: Replacing reg %d in jump_insn %d with\"\n+\t       \"constant \", REGNO (from), INSN_UID (jump));\n       print_rtl (dump_file, src);\n       fprintf (dump_file, \"\\n\");\n     }\n@@ -968,8 +959,12 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n   return 1;\n }\n \n-static bool\n-constprop_register (rtx insn, rtx from, rtx to)\n+/* Subroutine of cprop_insn that tries to propagate constants.  FROM is what\n+   we will try to replace, SRC is the constant we will try to substitute for\n+   it and INSN is the instruction where this will be happening.  */\n+\n+static int\n+constprop_register (rtx from, rtx src, rtx insn)\n {\n   rtx sset;\n \n@@ -981,13 +976,13 @@ constprop_register (rtx insn, rtx from, rtx to)\n     {\n       rtx dest = SET_DEST (sset);\n       if ((REG_P (dest) || CC0_P (dest))\n-\t  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn), from, to))\n+\t  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn),\n+\t\t\t from, src))\n \treturn 1;\n     }\n \n   /* Handle normal insns next.  */\n-  if (NONJUMP_INSN_P (insn)\n-      && try_replace_reg (from, to, insn))\n+  if (NONJUMP_INSN_P (insn) && try_replace_reg (from, src, insn))\n     return 1;\n \n   /* Try to propagate a CONST_INT into a conditional jump.\n@@ -997,12 +992,12 @@ constprop_register (rtx insn, rtx from, rtx to)\n      Right now the insn in question must look like\n      (set (pc) (if_then_else ...))  */\n   else if (any_condjump_p (insn) && onlyjump_p (insn))\n-    return cprop_jump (BLOCK_FOR_INSN (insn), NULL, insn, from, to);\n+    return cprop_jump (BLOCK_FOR_INSN (insn), NULL, insn, from, src);\n   return 0;\n }\n \n /* Perform constant and copy propagation on INSN.\n-   The result is nonzero if a change was made.  */\n+   Return nonzero if a change was made.  */\n \n static int\n cprop_insn (rtx insn)\n@@ -1044,14 +1039,16 @@ cprop_insn (rtx insn)\n       /* Constant propagation.  */\n       if (cprop_constant_p (src))\n \t{\n-          if (constprop_register (insn, reg_used, src))\n+          if (constprop_register (reg_used, src, insn))\n \t    {\n \t      changed_this_round = changed = 1;\n \t      global_const_prop_count++;\n \t      if (dump_file != NULL)\n \t\t{\n-\t\t  fprintf (dump_file, \"GLOBAL CONST-PROP: Replacing reg %d in \", regno);\n-\t\t  fprintf (dump_file, \"insn %d with constant \", INSN_UID (insn));\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"GLOBAL CONST-PROP: Replacing reg %d in \", regno);\n+\t\t  fprintf (dump_file, \"insn %d with constant \",\n+\t\t\t   INSN_UID (insn));\n \t\t  print_rtl (dump_file, src);\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n@@ -1069,7 +1066,8 @@ cprop_insn (rtx insn)\n \t      global_copy_prop_count++;\n \t      if (dump_file != NULL)\n \t\t{\n-\t\t  fprintf (dump_file, \"GLOBAL COPY-PROP: Replacing reg %d in insn %d\",\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"GLOBAL COPY-PROP: Replacing reg %d in insn %d\",\n \t\t\t   regno, INSN_UID (insn));\n \t\t  fprintf (dump_file, \" with reg %d\\n\", REGNO (src));\n \t\t}\n@@ -1175,7 +1173,7 @@ do_local_cprop (rtx x, rtx insn)\n \t\t  || ! MEM_P (XEXP (note, 0))))\n \t    newreg = this_rtx;\n \t}\n-      if (newcnst && constprop_register (insn, x, newcnst))\n+      if (newcnst && constprop_register (x, newcnst, insn))\n \t{\n \t  if (dump_file != NULL)\n \t    {\n@@ -1409,7 +1407,7 @@ find_implicit_sets (void)\n static int bypass_last_basic_block;\n \n /* Find a set of REGNO to a constant that is available at the end of basic\n-   block BB.  Returns NULL if no such set is found.  Based heavily upon\n+   block BB.  Return NULL if no such set is found.  Based heavily upon\n    find_avail_set.  */\n \n static struct expr *\n@@ -1444,7 +1442,6 @@ find_bypass_set (int regno, int bb)\n   return result;\n }\n \n-\n /* Subroutine of bypass_block that checks whether a pseudo is killed by\n    any of the instructions inserted on an edge.  Jump bypassing places\n    condition code setters on CFG edges using insert_insn_on_edge.  This\n@@ -1520,8 +1517,8 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t}\n \n       /* The irreducible loops created by redirecting of edges entering the\n-\t loop from outside would decrease effectiveness of some of the following\n-\t optimizations, so prevent this.  */\n+\t loop from outside would decrease effectiveness of some of the\n+\t following optimizations, so prevent this.  */\n       if (may_be_loop_header\n \t  && !(e->flags & EDGE_DFS_BACK))\n \t{\n@@ -1559,7 +1556,6 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t     edges of the CFG.  We can't bypass an outgoing edge that\n \t     has instructions associated with it, as these insns won't\n \t     get executed if the incoming edge is redirected.  */\n-\n \t  if (new_rtx == pc_rtx)\n \t    {\n \t      edest = FALLTHRU_EDGE (bb);\n@@ -1579,7 +1575,6 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t  /* Avoid unification of the edge with other edges from original\n \t     branch.  We would end up emitting the instruction on \"both\"\n \t     edges.  */\n-\n \t  if (dest && setcc && !CC0_P (SET_DEST (PATTERN (setcc)))\n \t      && find_edge (e->src, dest))\n \t    dest = NULL;\n@@ -1623,7 +1618,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n /* Find basic blocks with more than one predecessor that only contain a\n    single conditional jump.  If the result of the comparison is known at\n    compile-time from any incoming edge, redirect that edge to the\n-   appropriate target.  Returns nonzero if a change was made.\n+   appropriate target.  Return nonzero if a change was made.\n \n    This function is now mis-named, because we also handle indirect jumps.  */\n \n@@ -1687,7 +1682,7 @@ bypass_conditional_jumps (void)\n   return changed;\n }\n \f\n-/* Return true if the graph is too expensive to optimize. PASS is the\n+/* Return true if the graph is too expensive to optimize.  PASS is the\n    optimization about to be performed.  */\n \n static bool\n@@ -1726,7 +1721,6 @@ is_too_expensive (const char *pass)\n \n   return false;\n }\n-\n \f\n /* Main function for the CPROP pass.  */\n \n@@ -1800,7 +1794,8 @@ one_cprop_pass (void)\n       /* Allocate vars to track sets of regs.  */\n       reg_set_bitmap = ALLOC_REG_SET (NULL);\n \n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR, next_bb)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR,\n+\t\t      next_bb)\n \t{\n \t  /* Reset tables used to keep track of what's still valid [since\n \t     the start of the block].  */\n@@ -1841,7 +1836,6 @@ one_cprop_pass (void)\n \n   return changed;\n }\n-\n \f\n /* All the passes implemented in this file.  Each pass has its\n    own gate and execute function, and at the end of the file a"}]}