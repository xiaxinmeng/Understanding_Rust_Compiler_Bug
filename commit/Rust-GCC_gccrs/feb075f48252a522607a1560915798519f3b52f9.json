{"sha": "feb075f48252a522607a1560915798519f3b52f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmViMDc1ZjQ4MjUyYTUyMjYwN2ExNTYwOTE1Nzk4NTE5ZjNiNTJmOQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-10-06T19:40:54Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-10-06T19:40:54Z"}, "message": "lambda-code.c (lambda_loopnest_to_gcc_loopnest): Convert to use FOR_EACH_SSA_USE_OPERAND iterator, and propagate_value.\n\n2004-10-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Convert\n\tto use FOR_EACH_SSA_USE_OPERAND iterator, and propagate_value.\n\n2004-10-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* lambda-code.c (compute_nest_using_fourier_motzkin): New\n\tfunction.\n\t(lambda_compute_auxillary_space): Split from here.\n\n2004-10-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-loop-ivopts.c (expr_invariant_in_loop): Make non-static.\n\t* tree-flow.h: Add prototype.\n\t* lambda-code.c (invariant_in_loop_and_outer_loops): Use\n\texpr_invariant_in_loop.\n\nFrom-SVN: r88622", "tree": {"sha": "4321b758916356afaea20186d39bcc5a6948aa88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4321b758916356afaea20186d39bcc5a6948aa88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/feb075f48252a522607a1560915798519f3b52f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb075f48252a522607a1560915798519f3b52f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb075f48252a522607a1560915798519f3b52f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb075f48252a522607a1560915798519f3b52f9/comments", "author": null, "committer": null, "parents": [{"sha": "8813c9442890de0d133bc09b760799c3d7caa7d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8813c9442890de0d133bc09b760799c3d7caa7d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8813c9442890de0d133bc09b760799c3d7caa7d9"}], "stats": {"total": 352, "additions": 187, "deletions": 165}, "files": [{"sha": "2f75db9f998d89ec404e7e84e41983f0d827ed06", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 184, "deletions": 164, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb075f48252a522607a1560915798519f3b52f9/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb075f48252a522607a1560915798519f3b52f9/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=feb075f48252a522607a1560915798519f3b52f9", "patch": "@@ -489,25 +489,184 @@ lcm (int a, int b)\n   return (abs (a) * abs (b) / gcd (a, b));\n }\n \n+/* Perform Fourier-Motzkin elimination to calculate the bounds of the\n+   auxillary nest.\n+   Fourier-Motzkin is a way of reducing systems of linear inequality so that\n+   it is easy to calculate the answer and bounds.\n+   A sketch of how it works:\n+   Given a system of linear inequalities, ai * xj >= bk, you can always\n+   rewrite the constraints so they are all of the form\n+   a <= x, or x <= b, or x >= constant for some x in x1 ... xj (and some b\n+   in b1 ... bk, and some a in a1...ai)\n+   You can then eliminate this x from the non-constant inequalities by\n+   rewriting these as a <= b, x >= constant, and delete the x variable.\n+   You can then repeat this for any remaining x variables, and then we have\n+   an easy to use variable <= constant (or no variables at all) form that we\n+   can construct our bounds from. \n+   \n+   In our case, each time we eliminate, we construct part of the bound from\n+   the ith variable, then delete the ith variable. \n+   \n+   Remember the constant are in our vector a, our coefficient matrix is A,\n+   and our invariant coefficient matrix is B.\n+   \n+   SIZE is the size of the matrices being passed.\n+   DEPTH is the loop nest depth.\n+   INVARIANTS is the number of loop invariants.\n+   A, B, and a are the coefficient matrix, invariant coefficient, and a\n+   vector of constants, respectively.  */\n+\n+static lambda_loopnest \n+compute_nest_using_fourier_motzkin (int size,\n+\t\t\t\t    int depth, \n+\t\t\t\t    int invariants,\n+\t\t\t\t    lambda_matrix A,\n+\t\t\t\t    lambda_matrix B,\n+\t\t\t\t    lambda_vector a)\n+{\n+\n+  int multiple, f1, f2;\n+  int i, j, k;\n+  lambda_linear_expression expression;\n+  lambda_loop loop;\n+  lambda_loopnest auxillary_nest;\n+  lambda_matrix swapmatrix, A1, B1;\n+  lambda_vector swapvector, a1;\n+  int newsize;\n+\n+  A1 = lambda_matrix_new (128, depth);\n+  B1 = lambda_matrix_new (128, invariants);\n+  a1 = lambda_vector_new (128);\n+\n+  auxillary_nest = lambda_loopnest_new (depth, invariants);\n+\n+  for (i = depth - 1; i >= 0; i--)\n+    {\n+      loop = lambda_loop_new ();\n+      LN_LOOPS (auxillary_nest)[i] = loop;\n+      LL_STEP (loop) = 1;\n+\n+      for (j = 0; j < size; j++)\n+\t{\n+\t  if (A[j][i] < 0)\n+\t    {\n+\t      /* Any linear expression in the matrix with a coefficient less\n+\t\t than 0 becomes part of the new lower bound.  */ \n+\t      expression = lambda_linear_expression_new (depth, invariants);\n+\n+\t      for (k = 0; k < i; k++)\n+\t\tLLE_COEFFICIENTS (expression)[k] = A[j][k];\n+\n+\t      for (k = 0; k < invariants; k++)\n+\t\tLLE_INVARIANT_COEFFICIENTS (expression)[k] = -1 * B[j][k];\n+\n+\t      LLE_DENOMINATOR (expression) = -1 * A[j][i];\n+\t      LLE_CONSTANT (expression) = -1 * a[j];\n+\n+\t      /* Ignore if identical to the existing lower bound.  */\n+\t      if (!lle_equal (LL_LOWER_BOUND (loop),\n+\t\t\t      expression, depth, invariants))\n+\t\t{\n+\t\t  LLE_NEXT (expression) = LL_LOWER_BOUND (loop);\n+\t\t  LL_LOWER_BOUND (loop) = expression;\n+\t\t}\n+\n+\t    }\n+\t  else if (A[j][i] > 0)\n+\t    {\n+\t      /* Any linear expression with a coefficient greater than 0\n+\t\t becomes part of the new upper bound. */ \n+\t      expression = lambda_linear_expression_new (depth, invariants);\n+\t      for (k = 0; k < i; k++)\n+\t\tLLE_COEFFICIENTS (expression)[k] = -1 * A[j][k];\n+\n+\t      for (k = 0; k < invariants; k++)\n+\t\tLLE_INVARIANT_COEFFICIENTS (expression)[k] = B[j][k];\n+\n+\t      LLE_DENOMINATOR (expression) = A[j][i];\n+\t      LLE_CONSTANT (expression) = a[j];\n+\n+\t      /* Ignore if identical to the existing upper bound.  */\n+\t      if (!lle_equal (LL_UPPER_BOUND (loop),\n+\t\t\t      expression, depth, invariants))\n+\t\t{\n+\t\t  LLE_NEXT (expression) = LL_UPPER_BOUND (loop);\n+\t\t  LL_UPPER_BOUND (loop) = expression;\n+\t\t}\n+\n+\t    }\n+\t}\n+\n+      /* This portion creates a new system of linear inequalities by deleting\n+\t the i'th variable, reducing the system by one variable.  */\n+      newsize = 0;\n+      for (j = 0; j < size; j++)\n+\t{\n+\t  /* If the coefficient for the i'th variable is 0, then we can just\n+\t     eliminate the variable straightaway.  Otherwise, we have to\n+\t     multiply through by the coefficients we are eliminating.  */\n+\t  if (A[j][i] == 0)\n+\t    {\n+\t      lambda_vector_copy (A[j], A1[newsize], depth);\n+\t      lambda_vector_copy (B[j], B1[newsize], invariants);\n+\t      a1[newsize] = a[j];\n+\t      newsize++;\n+\t    }\n+\t  else if (A[j][i] > 0)\n+\t    {\n+\t      for (k = 0; k < size; k++)\n+\t\t{\n+\t\t  if (A[k][i] < 0)\n+\t\t    {\n+\t\t      multiple = lcm (A[j][i], A[k][i]);\n+\t\t      f1 = multiple / A[j][i];\n+\t\t      f2 = -1 * multiple / A[k][i];\n+\n+\t\t      lambda_vector_add_mc (A[j], f1, A[k], f2,\n+\t\t\t\t\t    A1[newsize], depth);\n+\t\t      lambda_vector_add_mc (B[j], f1, B[k], f2,\n+\t\t\t\t\t    B1[newsize], invariants);\n+\t\t      a1[newsize] = f1 * a[j] + f2 * a[k];\n+\t\t      newsize++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      swapmatrix = A;\n+      A = A1;\n+      A1 = swapmatrix;\n+\n+      swapmatrix = B;\n+      B = B1;\n+      B1 = swapmatrix;\n+\n+      swapvector = a;\n+      a = a1;\n+      a1 = swapvector;\n+\n+      size = newsize;\n+    }\n+\n+  return auxillary_nest;\n+}\n+\n /* Compute the loop bounds for the auxiliary space NEST.\n    Input system used is Ax <= b.  TRANS is the unimodular transformation.  */\n \n static lambda_loopnest\n lambda_compute_auxillary_space (lambda_loopnest nest,\n \t\t\t\tlambda_trans_matrix trans)\n {\n-  lambda_matrix A, B, A1, B1, temp0;\n-  lambda_vector a, a1, temp1;\n+  lambda_matrix A, B, A1, B1;\n+  lambda_vector a, a1;\n   lambda_matrix invertedtrans;\n-  int determinant, depth, invariants, size, newsize;\n-  int i, j, k;\n-  lambda_loopnest auxillary_nest;\n+  int determinant, depth, invariants, size;\n+  int i, j;\n   lambda_loop loop;\n   lambda_linear_expression expression;\n   lambda_lattice lattice;\n \n-  int multiple, f1, f2;\n-\n   depth = LN_DEPTH (nest);\n   invariants = LN_INVARIANTS (nest);\n \n@@ -623,136 +782,8 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n   /* A = A1 inv(U).  */\n   lambda_matrix_mult (A1, invertedtrans, A, size, depth, depth);\n \n-  /* Perform Fourier-Motzkin elimination to calculate the bounds of the\n-     auxillary nest.\n-     Fourier-Motzkin is a way of reducing systems of linear inequality so that\n-     it is easy to calculate the answer and bounds.\n-     A sketch of how it works:\n-     Given a system of linear inequalities, ai * xj >= bk, you can always\n-     rewrite the constraints so they are all of the form\n-     a <= x, or x <= b, or x >= constant for some x in x1 ... xj (and some b\n-     in b1 ... bk, and some a in a1...ai)\n-     You can then eliminate this x from the non-constant inequalities by\n-     rewriting these as a <= b, x >= constant, and delete the x variable.\n-     You can then repeat this for any remaining x variables, and then we have\n-     an easy to use variable <= constant (or no variables at all) form that we\n-     can construct our bounds from. \n-\n-     In our case, each time we eliminate, we construct part of the bound from\n-     the ith variable, then delete the ith variable. \n-\n-     Remember the constant are in our vector a, our coefficient matrix is A,\n-     and our invariant coefficient matrix is B  */\n-\n-  /* Swap B and B1, and a1 and a.  */\n-  temp0 = B1;\n-  B1 = B;\n-  B = temp0;\n-\n-  temp1 = a1;\n-  a1 = a;\n-  a = temp1;\n-\n-  auxillary_nest = lambda_loopnest_new (depth, invariants);\n-\n-  for (i = depth - 1; i >= 0; i--)\n-    {\n-      loop = lambda_loop_new ();\n-      LN_LOOPS (auxillary_nest)[i] = loop;\n-      LL_STEP (loop) = 1;\n-\n-      for (j = 0; j < size; j++)\n-\t{\n-\t  if (A[j][i] < 0)\n-\t    {\n-\t      /* Lower bound.  */\n-\t      expression = lambda_linear_expression_new (depth, invariants);\n-\n-\t      for (k = 0; k < i; k++)\n-\t\tLLE_COEFFICIENTS (expression)[k] = A[j][k];\n-\t      for (k = 0; k < invariants; k++)\n-\t\tLLE_INVARIANT_COEFFICIENTS (expression)[k] = -1 * B[j][k];\n-\t      LLE_DENOMINATOR (expression) = -1 * A[j][i];\n-\t      LLE_CONSTANT (expression) = -1 * a[j];\n-\t      /* Ignore if identical to the existing lower bound.  */\n-\t      if (!lle_equal (LL_LOWER_BOUND (loop),\n-\t\t\t      expression, depth, invariants))\n-\t\t{\n-\t\t  LLE_NEXT (expression) = LL_LOWER_BOUND (loop);\n-\t\t  LL_LOWER_BOUND (loop) = expression;\n-\t\t}\n-\n-\t    }\n-\t  else if (A[j][i] > 0)\n-\t    {\n-\t      /* Upper bound.  */\n-\t      expression = lambda_linear_expression_new (depth, invariants);\n-\t      for (k = 0; k < i; k++)\n-\t\tLLE_COEFFICIENTS (expression)[k] = -1 * A[j][k];\n-\t      LLE_CONSTANT (expression) = a[j];\n-\n-\t      for (k = 0; k < invariants; k++)\n-\t\tLLE_INVARIANT_COEFFICIENTS (expression)[k] = B[j][k];\n-\n-\t      LLE_DENOMINATOR (expression) = A[j][i];\n-\t      /* Ignore if identical to the existing upper bound.  */\n-\t      if (!lle_equal (LL_UPPER_BOUND (loop),\n-\t\t\t      expression, depth, invariants))\n-\t\t{\n-\t\t  LLE_NEXT (expression) = LL_UPPER_BOUND (loop);\n-\t\t  LL_UPPER_BOUND (loop) = expression;\n-\t\t}\n-\n-\t    }\n-\t}\n-      /* creates a new system by deleting the i'th variable.  */\n-      newsize = 0;\n-      for (j = 0; j < size; j++)\n-\t{\n-\t  if (A[j][i] == 0)\n-\t    {\n-\t      lambda_vector_copy (A[j], A1[newsize], depth);\n-\t      lambda_vector_copy (B[j], B1[newsize], invariants);\n-\t      a1[newsize] = a[j];\n-\t      newsize++;\n-\t    }\n-\t  else if (A[j][i] > 0)\n-\t    {\n-\t      for (k = 0; k < size; k++)\n-\t\t{\n-\t\t  if (A[k][i] < 0)\n-\t\t    {\n-\t\t      multiple = lcm (A[j][i], A[k][i]);\n-\t\t      f1 = multiple / A[j][i];\n-\t\t      f2 = -1 * multiple / A[k][i];\n-\n-\t\t      lambda_vector_add_mc (A[j], f1, A[k], f2,\n-\t\t\t\t\t    A1[newsize], depth);\n-\t\t      lambda_vector_add_mc (B[j], f1, B[k], f2,\n-\t\t\t\t\t    B1[newsize], invariants);\n-\t\t      a1[newsize] = f1 * a[j] + f2 * a[k];\n-\t\t      newsize++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      temp0 = A;\n-      A = A1;\n-      A1 = temp0;\n-\n-      temp0 = B;\n-      B = B1;\n-      B1 = temp0;\n-\n-      temp1 = a;\n-      a = a1;\n-      a1 = temp1;\n-\n-      size = newsize;\n-    }\n-\n-  return auxillary_nest;\n+  return compute_nest_using_fourier_motzkin (size, depth, invariants,\n+\t\t\t\t\t     A, B1, a1);\n }\n \n /* Compute the loop bounds for the target space, using the bounds of\n@@ -1165,27 +1196,18 @@ gcc_tree_to_linear_expression (int depth, tree expr,\n /* Return true if OP is invariant in LOOP and all outer loops.  */\n \n static bool\n-invariant_in_loop (struct loop *loop, tree op)\n+invariant_in_loop_and_outer_loops (struct loop *loop, tree op)\n {\n   if (is_gimple_min_invariant (op))\n     return true;\n   if (loop->depth == 0)\n     return true;\n-  if (TREE_CODE (op) == SSA_NAME)\n-    {\n-      tree def;\n-      def = SSA_NAME_DEF_STMT (op);\n-      if (TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL\n-\t  && IS_EMPTY_STMT (def))\n-\treturn true;\n-      if (IS_EMPTY_STMT (def))\n-\treturn false;\n-      if (loop->outer \n-\t  && !invariant_in_loop (loop->outer, op))\n-\t  return false;\n-      return !flow_bb_inside_loop_p (loop, bb_for_stmt (def));\n-    }\n-  return false;\n+  if (!expr_invariant_in_loop_p (loop, op))\n+    return false;\n+  if (loop->outer \n+      && !invariant_in_loop_and_outer_loops (loop->outer, op))\n+    return false;\n+  return true;\n }\n \n /* Generate a lambda loop from a gcc loop LOOP.  Return the new lambda loop,\n@@ -1352,10 +1374,10 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n     }\n   /* One part of the test may be a loop invariant tree.  */\n   if (TREE_CODE (TREE_OPERAND (test, 1)) == SSA_NAME\n-      && invariant_in_loop (loop, TREE_OPERAND (test, 1)))\n+      && invariant_in_loop_and_outer_loops (loop, TREE_OPERAND (test, 1)))\n     VEC_safe_push (tree, *invariants, TREE_OPERAND (test, 1));\n   else if (TREE_CODE (TREE_OPERAND (test, 0)) == SSA_NAME\n-\t   && invariant_in_loop (loop, TREE_OPERAND (test, 0)))\n+\t   && invariant_in_loop_and_outer_loops (loop, TREE_OPERAND (test, 0)))\n     VEC_safe_push (tree, *invariants, TREE_OPERAND (test, 0));\n   \n   /* The non-induction variable part of the test is the upper bound variable.\n@@ -1433,9 +1455,10 @@ find_induction_var_from_exit_cond (struct loop *loop)\n     case LE_EXPR:\n     case NE_EXPR:\n       ivarop = TREE_OPERAND (test, 0);\n-      break;\n+      break;      \n     case GT_EXPR:\n     case GE_EXPR:\n+    case EQ_EXPR:\n       ivarop = TREE_OPERAND (test, 1);\n       break;\n     default:\n@@ -1898,15 +1921,12 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       dataflow_t imm = get_immediate_uses (SSA_NAME_DEF_STMT (oldiv));\n       for (j = 0; j < num_immediate_uses (imm); j++)\n \t{\n-\t  size_t k;\n \t  tree stmt = immediate_use (imm, j);\n-\t  use_optype uses;\n-\t  get_stmt_operands (stmt);\n-\t  uses = STMT_USE_OPS (stmt);\n-\t  for (k = 0; k < NUM_USES (uses); k++)\n+\t  use_operand_p use_p;\n+\t  ssa_op_iter iter;\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n \t    {\n-\t      use_operand_p use = USE_OP_PTR (uses, k);\n-\t      if (USE_FROM_PTR (use) == oldiv)\n+\t      if (USE_FROM_PTR (use_p) == oldiv)\n \t\t{\n \t\t  tree newiv, stmts;\n \t\t  lambda_body_vector lbv;\n@@ -1921,7 +1941,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t\t  /* Insert the statements to build that\n \t\t     expression.  */\n \t\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n-\t\t  SET_USE (use, newiv);\n+\t\t  propagate_value (use_p, newiv);\n \t\t  modify_stmt (stmt);\n \t\t  \n \t\t}"}, {"sha": "007550b62e4d4741bae74a204e407bfd299dd617", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb075f48252a522607a1560915798519f3b52f9/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb075f48252a522607a1560915798519f3b52f9/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=feb075f48252a522607a1560915798519f3b52f9", "patch": "@@ -742,6 +742,8 @@ extern void build_ssa_operands (tree, stmt_ann_t, stmt_operands_p,\n /* In tree-loop-linear.c  */\n extern void linear_transform_loops (struct loops *);\n \n+/* In tree-ssa-loop-ivopts.c  */\n+extern bool expr_invariant_in_loop_p (struct loop *loop, tree expr);\n /* In gimplify.c  */\n \n tree force_gimple_operand (tree, tree *, bool, tree);"}, {"sha": "93ff3b74ce90ba8d80036bac85de04c1645f7a37", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb075f48252a522607a1560915798519f3b52f9/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb075f48252a522607a1560915798519f3b52f9/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=feb075f48252a522607a1560915798519f3b52f9", "patch": "@@ -1191,7 +1191,7 @@ find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n /* Returns true if expression EXPR is obviously invariant in LOOP,\n    i.e. if all its operands are defined outside of the LOOP.  */\n \n-static bool\n+bool\n expr_invariant_in_loop_p (struct loop *loop, tree expr)\n {\n   basic_block def_bb;"}]}