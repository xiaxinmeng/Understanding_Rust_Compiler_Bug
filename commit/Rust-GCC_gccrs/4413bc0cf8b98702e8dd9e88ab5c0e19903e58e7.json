{"sha": "4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "node_id": "C_kwDOANBUbNoAKDQ0MTNiYzBjZjhiOTg3MDJlOGRkOWU4OGFiNWMwZTE5OTAzZTU4ZTc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-03-30T17:13:48Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-11T08:47:22Z"}, "message": "Fix bad inherent overlap error\n\nWhen we examine HIR::ImplBlock's we determine if an impl might overlap\nanother impl based on the Self type. So for example you might have a\ngeneric structure Foo<T>(T), and an associated impl block for Foo<i32>, but\nthen go on to define an associated impl of Foo<T> the generic one will\noverlap any associated impl hiding the generic implementation.\n\nIn this case we have two generic impl blocks\n\n  *const [T]\n  *const T\n\nThis means the *const T might overlap with the slice one since it is\ngeneric. As bjorn3 pointed out in #1075, the correct implementation is to\nobserve that [T] is constrained by size but untill we have the auto trait\nof Sized we must example the two generic impls and just determine that\nthey are not-equal so for now this is the best implementation we can do.\n\nFixes #1075", "tree": {"sha": "0d48ee476e0e52a0c130da0b95b27f2423466613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d48ee476e0e52a0c130da0b95b27f2423466613"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e43a5c5373b341d217d2f5403f31f5174b8c4e2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e43a5c5373b341d217d2f5403f31f5174b8c4e2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e43a5c5373b341d217d2f5403f31f5174b8c4e2f"}], "stats": {"total": 107, "additions": 74, "deletions": 33}, "files": [{"sha": "9abf87280ad25878cfff24bd60935e0a1482f04e", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "patch": "@@ -123,7 +123,26 @@ class OverlappingImplItemPass : public TypeCheckBase\n \t      continue;\n \n \t    if (query->can_eq (candidate, false))\n-\t      possible_collision (it->second, iy->second);\n+\t      {\n+\t\t// we might be in the case that we have:\n+\t\t//\n+\t\t// *const T vs *const [T]\n+\t\t//\n+\t\t// so lets use an equality check when the\n+\t\t// candidates are both generic to be sure we dont emit a false\n+\t\t// positive\n+\n+\t\tbool a = query->is_concrete ();\n+\t\tbool b = candidate->is_concrete ();\n+\t\tbool both_generic = !a && !b;\n+\t\tif (both_generic)\n+\t\t  {\n+\t\t    if (!query->is_equal (*candidate))\n+\t\t      continue;\n+\t\t  }\n+\n+\t\tpossible_collision (it->second, iy->second);\n+\t      }\n \t  }\n       }\n   }\n@@ -152,8 +171,8 @@ class OverlappingImplItemPass : public TypeCheckBase\n   void collision_detected (HIR::ImplItem *query, HIR::ImplItem *dup,\n \t\t\t   const std::string &name)\n   {\n-    RichLocation r (query->get_locus ());\n-    r.add_range (dup->get_locus ());\n+    RichLocation r (dup->get_locus ());\n+    r.add_range (query->get_locus ());\n     rust_error_at (r, \"duplicate definitions with name %s\", name.c_str ());\n   }\n "}, {"sha": "fda505aa84e5d43dd86fec8ce70563c27c5107e0", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "patch": "@@ -284,7 +284,10 @@ class PathProbeType : public TypeCheckBase\n       return;\n \n     if (!receiver->can_eq (impl_block_ty, false))\n-      return;\n+      {\n+\tif (!impl_block_ty->can_eq (receiver, false))\n+\t  return;\n+      }\n \n     // lets visit the impl_item\n     item->accept_vis (*this);"}, {"sha": "b34db3bd44e3e5615a7c0e3010fc9b89da84c844", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "patch": "@@ -41,7 +41,10 @@ TypeBoundsProbe::scan ()\n \treturn true;\n \n       if (!receiver->can_eq (impl_type, false))\n-\treturn true;\n+\t{\n+\t  if (!impl_type->can_eq (receiver, false))\n+\t    return true;\n+\t}\n \n       possible_trait_paths.push_back ({impl->get_trait_ref ().get (), impl});\n       return true;"}, {"sha": "34c89639f6f1c7afa40de104f2b9293733ed83e1", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "patch": "@@ -886,8 +886,6 @@ class ArrayCmp : public BaseCmp\n     ok = true;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const ArrayType *base;\n@@ -916,8 +914,6 @@ class SliceCmp : public BaseCmp\n     ok = true;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const SliceType *base;\n@@ -939,8 +935,6 @@ class BoolCmp : public BaseCmp\n     ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const BoolType *base;\n@@ -965,8 +959,6 @@ class IntCmp : public BaseCmp\n     ok = type.get_int_kind () == base->get_int_kind ();\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const IntType *base;\n@@ -991,8 +983,6 @@ class UintCmp : public BaseCmp\n     ok = type.get_uint_kind () == base->get_uint_kind ();\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const UintType *base;\n@@ -1017,8 +1007,6 @@ class FloatCmp : public BaseCmp\n     ok = type.get_float_kind () == base->get_float_kind ();\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const FloatType *base;\n@@ -1120,8 +1108,6 @@ class TupleCmp : public BaseCmp\n     ok = true;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const TupleType *base;\n@@ -1143,8 +1129,6 @@ class USizeCmp : public BaseCmp\n \n   void visit (const USizeType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const USizeType *base;\n@@ -1166,8 +1150,6 @@ class ISizeCmp : public BaseCmp\n \n   void visit (const ISizeType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const ISizeType *base;\n@@ -1189,8 +1171,6 @@ class CharCmp : public BaseCmp\n \n   void visit (const CharType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const CharType *base;\n@@ -1365,8 +1345,6 @@ class StrCmp : public BaseCmp\n \n   void visit (const StrType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const StrType *base;\n@@ -1383,8 +1361,6 @@ class NeverCmp : public BaseCmp\n \n   void visit (const NeverType &type) override { ok = true; }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const NeverType *base;\n@@ -1478,8 +1454,6 @@ class DynamicCmp : public BaseCmp\n     ok = base->bounds_compatible (type, ref_locus, false);\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n "}, {"sha": "2a41632e693a6df235170416087065c88c93765e", "filename": "gcc/testsuite/rust/compile/generics7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics7.rs?ref=4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "patch": "@@ -15,7 +15,7 @@ impl Foo<char> {\n }\n \n impl<T> Foo<T> {\n-    fn bar(self) -> T { // { dg-error \"duplicate definitions with name bar\" }\n+    fn bar(self) -> T {\n         self.a\n     }\n }"}, {"sha": "ceefc5d2c6a3e51fdb8126746027cb201b8a6341", "filename": "gcc/testsuite/rust/compile/generics8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics8.rs?ref=4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "patch": "@@ -1,7 +1,7 @@\n struct Foo<A, B>(A, B);\n \n impl<T> Foo<i32, T> {\n-    fn test(a: T) -> T { // { dg-error \"duplicate definitions with name test\" }\n+    fn test(a: T) -> T {\n         a\n     }\n }"}, {"sha": "3bd6321a9408df29130fb8b7777d7ded8eea92e1", "filename": "gcc/testsuite/rust/compile/torture/issue-1075.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1075.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1075.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-1075.rs?ref=4413bc0cf8b98702e8dd9e88ab5c0e19903e58e7", "patch": "@@ -0,0 +1,42 @@\n+// { dg-additional-options \"-w\" }\n+extern \"rust-intrinsic\" {\n+    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+\n+struct FatPtr<T> {\n+    data: *const T,\n+    len: usize,\n+}\n+\n+union Repr<T> {\n+    rust: *const [T],\n+    rust_mut: *mut [T],\n+    raw: FatPtr<T>,\n+}\n+\n+impl<T> *const [T] {\n+    pub const fn len(self) -> usize {\n+        // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n+        // Only `std` can make this guarantee.\n+        let a = unsafe { Repr { rust: self }.raw };\n+        a.len\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+impl<T> *const T {\n+    pub const unsafe fn offset(self, count: isize) -> *const T {\n+        unsafe { offset(self, count) }\n+    }\n+\n+    pub const unsafe fn add(self, count: usize) -> Self {\n+        unsafe { self.offset(count as isize) }\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}"}]}