{"sha": "ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0OWNiN2JmZmE0ODI2MzkxZDllN2U3ZTkwZGMzMTg5YmUwYmY1MA==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2007-10-02T13:10:07Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2007-10-02T13:10:07Z"}, "message": "ra-conflict.c: New file.\n\n2007-09-02  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* ra-conflict.c: New file.\n\t* ra.h: New file.\n\t* reload.c (push_reload, find_dummy_reload): Change DF_RA_LIVE\n\tusage to DF_LIVE usage.\n\t* rtlanal.c (subreg_nregs_with_regno): New function.  \n\t* df-scan.c (df_def_record_1, df_uses_record): Add code to set\n\tDF_REF_EXTRACT, DF_REF_STRICT_LOWER_PART, and DF_REF_SUBREG flags.\n\t(df_has_eh_preds): Removed.\n\t(df_bb_refs_collect, df_bb_refs_collect, df_bb_refs_collect,\n\tdf_exit_block_uses_collect): Changed call from df_has_eh_preds to\n\tbb_has_eh_pred.\n\t* global.c (allocno, max_allocno, conflicts, allocno_row_words,\n\treg_allocno, EXECUTE_IF_SET_IN_ALLOCNO_SET): Moved to ra.h\n\t(SET_ALLOCNO_LIVE, CLEAR_ALLOCNO_LIVE): Moved to ra-conflicts.c.\n\t(regs_set, record_one_conflict, record_conflicts, mark_reg_store,\n\tmark_reg_clobber, mark_reg_conflicts, mark_reg_death): Deleted.\n\t(global_alloc): Turn off rescanning insns after call to\n\tglobal_conflicts and added call to set_preferences.\n\t(global_conflicts): Moved to ra-alloc.c.\n\t(set_preferences_1, set_preferences): New function.\n\t(mirror_conflicts): Changed types for various variables.\n\t(mark_elimination): Change DF_RA_LIVE\n\tusage to DF_LIVE usage.\n\t(build_insn_chain): Rewritten from scratch and made local.\n\t(print_insn_chain, print_insn_chains): New functions.\n\t(dump_conflicts): Do not print conflicts for fixed_regs.\n\t(rest_of_handle_global_alloc): Turn off insn rescanning.\n\t* hard-reg-set.h: Fixed comment.\n\t* local-alloc.c (update_equiv_regs): Change DF_RA_LIVE\n\tusage to DF_LIVE usage and delete refs to TOP sets.\n\t(block_alloc): Mark regs as live if they are in the artificial\n\tdefs at top of block.\n\t(find_stack_regs): New function.\n\t(rest_of_handle_local_alloc): Changed urec problem to live\n\tproblem and do not turn off df rescanning.\n\t* df.h (DF_UREC, DF_UREC_BB_INFO, DF_LIVE_TOP, DF_RA_LIVE_IN,\n\tDF_RA_LIVE_TOP, DF_RA_LIVE_OUT, df_urec_bb_info, df_urec,\n\tdf_urec_add_problem, df_urec_get_bb_info, df_has_eh_preds): Removed.\n\t(DF_CHAIN, DF_NOTE, DF_CHAIN): Renumbered.\n\t(DF_REF_EXTRACT, DF_REF_STRICT_LOWER_PART, DF_REF_SUBREG): New\n\tfields in df_ref_flags.  The rest have been renumbered.  \n\t* init-regs.c (initialize_uninitialized_regs): Enhanced debugging\n\tat -O1.\n\t* rtl.h (subreg_nregs_with_regno): New function.\n\t* df-problems.c: (df_get_live_out, df_get_live_in,\n\tdf_get_live_top): Removed reference to DF_RA_LIVE.\n\t(df_lr_reset, df_lr_transfer_function, df_live_free_bb_info,\n\tdf_live_alloc, df_live_reset, df_live_local_finalize,\n\tdf_live_free): Make top set only if different from in set.\n\t(df_lr_top_dump, df_live_top_dump): Only print top set if\n\tdifferent from in set.\n\t(df_lr_bb_local_compute): Removed unnecessary check.\n\t(df_urec_problem_data, df_urec_set_bb_info, df_urec_free_bb_info, \n\tdf_urec_alloc, df_urec_mark_reg_change, earlyclobber_regclass, \n\tdf_urec_check_earlyclobber, df_urec_mark_reg_use_for_earlyclobber,\n\tdf_urec_mark_reg_use_for_earlyclobber_1, df_urec_bb_local_compute,\n\tdf_urec_local_compute, df_urec_init, df_urec_local_finalize, \n\tdf_urec_confluence_n, df_urec_transfer_function, df_urec_free, \n\tdf_urec_top_dump, df_urec_bottom_dump, problem_UREC,\n\tdf_urec_add_problem): Removed.\n\t(df_simulate_fixup_sets): Changed call from df_has_eh_preds to\n\tbb_has_eh_pred. \n\t* Makefile.in (ra-conflict.o, ra.h): New dependencies.\n\t* basic_block.h (bb_has_abnormal_pred): New function.\n\t* reload1.c (compute_use_by_pseudos): Change DF_RA_LIVE\n\tusage to DF_LIVE usage.\n\nFrom-SVN: r128957", "tree": {"sha": "b10f5b41b330de2e7955bcee2d0e55e357b7321d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b10f5b41b330de2e7955bcee2d0e55e357b7321d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "746025f4bc8ee75426e096d533c9f0241c9905d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/746025f4bc8ee75426e096d533c9f0241c9905d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/746025f4bc8ee75426e096d533c9f0241c9905d8"}], "stats": {"total": 3702, "additions": 1965, "deletions": 1737}, "files": [{"sha": "476ca871393d2821ff1f73e87d6d72956840dbc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -1,3 +1,72 @@\n+2007-09-02  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* ra-conflict.c: New file.\n+\t* ra.h: New file.\n+\t* reload.c (push_reload, find_dummy_reload): Change DF_RA_LIVE\n+\tusage to DF_LIVE usage.\n+\t* rtlanal.c (subreg_nregs_with_regno): New function.  \n+\t* df-scan.c (df_def_record_1, df_uses_record): Add code to set\n+\tDF_REF_EXTRACT, DF_REF_STRICT_LOWER_PART, and DF_REF_SUBREG flags.\n+\t(df_has_eh_preds): Removed.\n+\t(df_bb_refs_collect, df_bb_refs_collect, df_bb_refs_collect,\n+\tdf_exit_block_uses_collect): Changed call from df_has_eh_preds to\n+\tbb_has_eh_pred.\n+\t* global.c (allocno, max_allocno, conflicts, allocno_row_words,\n+\treg_allocno, EXECUTE_IF_SET_IN_ALLOCNO_SET): Moved to ra.h\n+\t(SET_ALLOCNO_LIVE, CLEAR_ALLOCNO_LIVE): Moved to ra-conflicts.c.\n+\t(regs_set, record_one_conflict, record_conflicts, mark_reg_store,\n+\tmark_reg_clobber, mark_reg_conflicts, mark_reg_death): Deleted.\n+\t(global_alloc): Turn off rescanning insns after call to\n+\tglobal_conflicts and added call to set_preferences.\n+\t(global_conflicts): Moved to ra-alloc.c.\n+\t(set_preferences_1, set_preferences): New function.\n+\t(mirror_conflicts): Changed types for various variables.\n+\t(mark_elimination): Change DF_RA_LIVE\n+\tusage to DF_LIVE usage.\n+\t(build_insn_chain): Rewritten from scratch and made local.\n+\t(print_insn_chain, print_insn_chains): New functions.\n+\t(dump_conflicts): Do not print conflicts for fixed_regs.\n+\t(rest_of_handle_global_alloc): Turn off insn rescanning.\n+\t* hard-reg-set.h: Fixed comment.\n+\t* local-alloc.c (update_equiv_regs): Change DF_RA_LIVE\n+\tusage to DF_LIVE usage and delete refs to TOP sets.\n+\t(block_alloc): Mark regs as live if they are in the artificial\n+\tdefs at top of block.\n+\t(find_stack_regs): New function.\n+\t(rest_of_handle_local_alloc): Changed urec problem to live\n+\tproblem and do not turn off df rescanning.\n+\t* df.h (DF_UREC, DF_UREC_BB_INFO, DF_LIVE_TOP, DF_RA_LIVE_IN,\n+\tDF_RA_LIVE_TOP, DF_RA_LIVE_OUT, df_urec_bb_info, df_urec,\n+\tdf_urec_add_problem, df_urec_get_bb_info, df_has_eh_preds): Removed.\n+\t(DF_CHAIN, DF_NOTE, DF_CHAIN): Renumbered.\n+\t(DF_REF_EXTRACT, DF_REF_STRICT_LOWER_PART, DF_REF_SUBREG): New\n+\tfields in df_ref_flags.  The rest have been renumbered.  \n+\t* init-regs.c (initialize_uninitialized_regs): Enhanced debugging\n+\tat -O1.\n+\t* rtl.h (subreg_nregs_with_regno): New function.\n+\t* df-problems.c: (df_get_live_out, df_get_live_in,\n+\tdf_get_live_top): Removed reference to DF_RA_LIVE.\n+\t(df_lr_reset, df_lr_transfer_function, df_live_free_bb_info,\n+\tdf_live_alloc, df_live_reset, df_live_local_finalize,\n+\tdf_live_free): Make top set only if different from in set.\n+\t(df_lr_top_dump, df_live_top_dump): Only print top set if\n+\tdifferent from in set.\n+\t(df_lr_bb_local_compute): Removed unnecessary check.\n+\t(df_urec_problem_data, df_urec_set_bb_info, df_urec_free_bb_info, \n+\tdf_urec_alloc, df_urec_mark_reg_change, earlyclobber_regclass, \n+\tdf_urec_check_earlyclobber, df_urec_mark_reg_use_for_earlyclobber,\n+\tdf_urec_mark_reg_use_for_earlyclobber_1, df_urec_bb_local_compute,\n+\tdf_urec_local_compute, df_urec_init, df_urec_local_finalize, \n+\tdf_urec_confluence_n, df_urec_transfer_function, df_urec_free, \n+\tdf_urec_top_dump, df_urec_bottom_dump, problem_UREC,\n+\tdf_urec_add_problem): Removed.\n+\t(df_simulate_fixup_sets): Changed call from df_has_eh_preds to\n+\tbb_has_eh_pred. \n+\t* Makefile.in (ra-conflict.o, ra.h): New dependencies.\n+\t* basic_block.h (bb_has_abnormal_pred): New function.\n+\t* reload1.c (compute_use_by_pseudos): Change DF_RA_LIVE\n+\tusage to DF_LIVE usage.\n+\t\n 2007-10-02  Revital Eres  <eres@il.ibm.com>\n \n \t* config/rs6000/predicates.md (easy_vector_constant): Return false"}, {"sha": "02cdda54d756327c2a1a9c9cc505c7c7d9df0ce7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -791,6 +791,7 @@ FUNCTION_H = function.h $(TREE_H) $(HASHTAB_H)\n EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)\n OPTABS_H = optabs.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H) $(OBSTACK_H) $(BASIC_BLOCK_H) $(FUNCTION_H)\n+RA_H = ra.h $(REGS_H)\n RESOURCE_H = resource.h hard-reg-set.h\n SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H)\n INTEGRATE_H = integrate.h $(VARRAY_H)\n@@ -1100,6 +1101,7 @@ OBJS-common = \\\n \tprint-rtl.o \\\n \tprint-tree.o \\\n \tprofile.o \\\n+\tra-conflict.o \\\n \treal.o \\\n \trecog.o \\\n \treg-stack.o \\\n@@ -2702,7 +2704,11 @@ bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \\\n global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) reload.h $(FUNCTION_H) $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h output.h toplev.h $(TM_P_H) $(MACHMODE_H) tree-pass.h \\\n-   $(TIMEVAR_H) vecprim.h $(DF_H)\n+   $(TIMEVAR_H) vecprim.h $(DF_H) $(DBGCNT_H) $(RA_H)\n+ra-conflict.o : ra-conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(FLAGS_H) reload.h $(FUNCTION_H) $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n+   insn-config.h output.h toplev.h $(TM_P_H) $(MACHMODE_H) tree-pass.h \\\n+   $(TIMEVAR_H) vecprim.h $(DF_H) $(RA_H) sbitmap.h \n varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(HASHTAB_H) $(BCONFIG_H) $(VARRAY_H) toplev.h\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h vec.h $(GGC_H) \\"}, {"sha": "eb719ca26e016801ccbcb5e870ed109ddf8f5122", "filename": "gcc/basic-block.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -1135,6 +1135,21 @@ bb_has_eh_pred (basic_block bb)\n   return false;\n }\n \n+/* Return true when one of the predecessor edges of BB is marked with EDGE_ABNORMAL.  */\n+static inline bool\n+bb_has_abnormal_pred (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (e->flags & EDGE_ABNORMAL)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* In cfgloopmanip.c.  */\n extern edge mfb_kj_edge;\n bool mfb_keep_just (edge);"}, {"sha": "aca731104950645ab5d055dce6c27bdc0befe379", "filename": "gcc/dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -573,8 +573,8 @@ dce_process_block (basic_block bb, bool redo_out)\n   /* These regs are considered always live so if they end up dying\n      because of some def, we need to bring the back again.\n      Calling df_simulate_fixup_sets has the disadvantage of calling\n-     df_has_eh_preds once per insn, so we cache the information here.  */\n-  if (df_has_eh_preds (bb))\n+     bb_has_eh_pred once per insn, so we cache the information here.  */\n+  if (bb_has_eh_pred (bb))\n     au = df->eh_block_artificial_uses;\n   else\n     au = df->regular_block_artificial_uses;"}, {"sha": "dd56399be50b144f30c0af809ecd63545d6edef3", "filename": "gcc/df-problems.c", "status": "modified", "additions": 35, "deletions": 722, "changes": 757, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -71,9 +71,7 @@ df_get_live_out (basic_block bb)\n {\n   gcc_assert (df_lr);\n \n-  if (df_urec)\n-    return DF_RA_LIVE_OUT (bb);\n-  else if (df_live)\n+  if (df_live)\n     return DF_LIVE_OUT (bb);\n   else \n     return DF_LR_OUT (bb);\n@@ -89,31 +87,12 @@ df_get_live_in (basic_block bb)\n {\n   gcc_assert (df_lr);\n \n-  if (df_urec)\n-    return DF_RA_LIVE_IN (bb);\n-  else if (df_live)\n+  if (df_live)\n     return DF_LIVE_IN (bb);\n   else \n     return DF_LR_IN (bb);\n }\n \n-/* Get the live at top set for BB no matter what problem happens to be\n-   defined.  This function is used by the register allocators who\n-   choose different dataflow problems depending on the optimization\n-   level.  */\n-\n-bitmap\n-df_get_live_top (basic_block bb)\n-{\n-  gcc_assert (df_lr);\n-\n-  if (df_urec)\n-    return DF_RA_LIVE_TOP (bb);\n-  else \n-    return DF_LR_TOP (bb);\n-}\n-\n-\n /*----------------------------------------------------------------------------\n    Utility functions.\n ----------------------------------------------------------------------------*/\n@@ -210,9 +189,28 @@ df_unset_seen (void)\n    See df.h for details.\n    ----------------------------------------------------------------------------*/\n \n-/* See the comment at the top of the Reaching Uses problem for how the\n-   uses are represented in the kill sets. The same games are played\n-   here for the defs.  */\n+/* This problem plays a large number of games for the sake of\n+   efficiency.  \n+   \n+   1) The order of the bits in the bitvectors.  After the scanning\n+   phase, all of the defs are sorted.  All of the defs for the reg 0\n+   are first, followed by all defs for reg 1 and so on.\n+   \n+   2) There are two kill sets, one if the number of defs is less or\n+   equal to DF_SPARSE_THRESHOLD and another if the number of defs is\n+   greater.\n+\n+   <= : Data is built directly in the kill set.\n+\n+   > : One level of indirection is used to keep from generating long\n+   strings of 1 bits in the kill sets.  Bitvectors that are indexed\n+   by the regnum are used to represent that there is a killing def\n+   for the register.  The confluence and transfer functions use\n+   these along with the bitmap_clear_range call to remove ranges of\n+   bits without actually generating a knockout vector.\n+\n+   The kill and sparse_kill and the dense_invalidated_by_call and\n+   sparse_invalidated_by_call both play this game.  */\n \n /* Private data used to compute the solution for this problem.  These\n    data structures are not accessible outside of this module.  */\n@@ -740,14 +738,6 @@ df_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n     {\n       BITMAP_FREE (bb_info->use);\n       BITMAP_FREE (bb_info->def);\n-      if (bb_info->in == bb_info->top)\n-        bb_info->top = NULL;\n-      else\n-\t{\n-          BITMAP_FREE (bb_info->top);\n-          BITMAP_FREE (bb_info->ause);\n-          BITMAP_FREE (bb_info->adef);\n-\t}\n       BITMAP_FREE (bb_info->in);\n       BITMAP_FREE (bb_info->out);\n       pool_free (df_lr->block_pool, bb_info);\n@@ -777,11 +767,6 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t{ \n \t  bitmap_clear (bb_info->def);\n \t  bitmap_clear (bb_info->use);\n-\t  if (bb_info->adef)\n-\t    {\n-\t      bitmap_clear (bb_info->adef);\n-\t      bitmap_clear (bb_info->ause);\n-\t    }\n \t}\n       else\n \t{ \n@@ -791,9 +776,6 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t  bb_info->def = BITMAP_ALLOC (NULL);\n \t  bb_info->in = BITMAP_ALLOC (NULL);\n \t  bb_info->out = BITMAP_ALLOC (NULL);\n-          bb_info->top = bb_info->in;\n-          bb_info->adef = NULL;\n-          bb_info->ause = NULL;\n \t}\n     }\n \n@@ -815,7 +797,6 @@ df_lr_reset (bitmap all_blocks)\n       gcc_assert (bb_info);\n       bitmap_clear (bb_info->in);\n       bitmap_clear (bb_info->out);\n-      bitmap_clear (bb_info->top);\n     }\n }\n \n@@ -879,23 +860,18 @@ df_lr_bb_local_compute (unsigned int bb_index)\n \t  bitmap_set_bit (bb_info->use, DF_REF_REGNO (use));\n \t}\n     }\n-  /* Process the registers set in an exception handler.  */\n+\n+  /* Process the registers set in an exception handler or the hard\n+     frame pointer if this block is the target of a non local\n+     goto.  */\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n       struct df_ref *def = *def_rec;\n-      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\t  && (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))))\n+      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-\t  if (bb_info->adef == NULL)\n-\t    {\n-\t      gcc_assert (bb_info->ause == NULL);\n-\t      gcc_assert (bb_info->top == bb_info->in);\n-\t      bb_info->adef = BITMAP_ALLOC (NULL);\n-\t      bb_info->ause = BITMAP_ALLOC (NULL);\n-\t      bb_info->top = BITMAP_ALLOC (NULL);\n-\t    }\n-\t  bitmap_set_bit (bb_info->adef, dregno);\n+\t  bitmap_set_bit (bb_info->def, dregno);\n+\t  bitmap_clear_bit (bb_info->use, dregno);\n \t}\n     }\n   \n@@ -906,17 +882,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n       struct df_ref *use = *use_rec;\n       /* Add use to set of uses in this BB.  */\n       if (DF_REF_FLAGS (use) & DF_REF_AT_TOP)\n-\t{\n-\t  if (bb_info->adef == NULL)\n-\t    {\n-\t      gcc_assert (bb_info->ause == NULL);\n-\t      gcc_assert (bb_info->top == bb_info->in);\n-\t      bb_info->adef = BITMAP_ALLOC (NULL);\n-\t      bb_info->ause = BITMAP_ALLOC (NULL);\n-\t      bb_info->top = BITMAP_ALLOC (NULL);\n-\t    }\n-\t  bitmap_set_bit (bb_info->ause, DF_REF_REGNO (use));\n-\t}\n+\tbitmap_set_bit (bb_info->use, DF_REF_REGNO (use));\n     }\n #endif\n \n@@ -1041,19 +1007,8 @@ df_lr_transfer_function (int bb_index)\n   bitmap out = bb_info->out;\n   bitmap use = bb_info->use;\n   bitmap def = bb_info->def;\n-  bitmap top = bb_info->top;\n-  bitmap ause = bb_info->ause;\n-  bitmap adef = bb_info->adef;\n-  bool changed;\n-\n-  changed = bitmap_ior_and_compl (top, use, out, def);\n-  if (in != top)\n-    {\n-      gcc_assert (ause && adef);\n-      changed |= bitmap_ior_and_compl (in, ause, top, adef);\n-    }\n \n-  return changed;\n+  return bitmap_ior_and_compl (in, use, out, def);\n }\n \n \n@@ -1097,14 +1052,6 @@ df_lr_free (void)\n \t    {\n \t      BITMAP_FREE (bb_info->use);\n \t      BITMAP_FREE (bb_info->def);\n-\t      if (bb_info->in == bb_info->top)\n-\t        bb_info->top = NULL;\n-\t      else\n-\t\t{\n-\t          BITMAP_FREE (bb_info->top);\n-                  BITMAP_FREE (bb_info->ause);\n-                  BITMAP_FREE (bb_info->adef);\n-\t\t}\n \t      BITMAP_FREE (bb_info->in);\n \t      BITMAP_FREE (bb_info->out);\n \t    }\n@@ -1297,7 +1244,6 @@ df_lr_verify_transfer_functions (void)\n   bitmap saved_adef;\n   bitmap saved_ause;\n   bitmap all_blocks;\n-  bool need_as;\n \n   if (!df)\n     return;\n@@ -1326,33 +1272,9 @@ df_lr_verify_transfer_functions (void)\n \t      bitmap_clear (bb_info->def);\n \t      bitmap_clear (bb_info->use);\n \n-\t      if (bb_info->adef)\n-\t\t{\n-\t\t  need_as = true;\n-\t\t  bitmap_copy (saved_adef, bb_info->adef);\n-\t\t  bitmap_copy (saved_ause, bb_info->ause);\n-\t\t  bitmap_clear (bb_info->adef);\n-\t\t  bitmap_clear (bb_info->ause);\n-\t\t}\n-\t      else\n-\t\tneed_as = false;\n-\n \t      df_lr_bb_local_compute (bb->index);\n \t      gcc_assert (bitmap_equal_p (saved_def, bb_info->def));\n \t      gcc_assert (bitmap_equal_p (saved_use, bb_info->use));\n-\n-\t      if (need_as)\n-\t\t{\n-\t\t  gcc_assert (bb_info->adef);\n-\t\t  gcc_assert (bb_info->ause);\n-\t\t  gcc_assert (bitmap_equal_p (saved_adef, bb_info->adef));\n-\t\t  gcc_assert (bitmap_equal_p (saved_ause, bb_info->ause));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (!bb_info->adef);\n-\t\t  gcc_assert (!bb_info->ause);\n-\t\t}\n \t    }\n \t}\n       else\n@@ -1633,7 +1555,7 @@ df_live_local_finalize (bitmap all_blocks)\n \t{\n \t  struct df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n \t  struct df_live_bb_info *bb_live_info = df_live_get_bb_info (bb_index);\n-\t  \n+  \n \t  /* No register may reach a location where it is not used.  Thus\n \t     we trim the rr result to the places where it is used.  */\n \t  bitmap_and_into (bb_live_info->in, bb_lr_info->in);\n@@ -1913,615 +1835,6 @@ df_live_verify_transfer_functions (void)\n   BITMAP_FREE (saved_kill);\n   BITMAP_FREE (all_blocks);\n }\n-\n-\n-\f\n-/*----------------------------------------------------------------------------\n-   UNINITIALIZED REGISTERS WITH EARLYCLOBBER\n-\n-   Find the set of uses for registers that are reachable from the entry\n-   block without passing thru a definition.  In and out bitvectors are built\n-   for each basic block.  The regnum is used to index into these sets.\n-   See df.h for details.\n-\n-   This is a variant of the UR problem above that has a lot of special\n-   features just for the register allocation phase.  This problem\n-   should go away if someone would fix the interference graph.\n-\n-   ----------------------------------------------------------------------------*/\n-\n-/* Private data used to compute the solution for this problem.  These\n-   data structures are not accessible outside of this module.  */\n-struct df_urec_problem_data\n-{\n-  bool earlyclobbers_found;     /* True if any instruction contains an\n-\t\t\t\t   earlyclobber.  */\n-#ifdef STACK_REGS\n-  bitmap stack_regs;\t\t/* Registers that may be allocated to a STACK_REGS.  */\n-#endif\n-};\n-\n-\n-/* Set basic block info.  */\n-\n-static void\n-df_urec_set_bb_info (unsigned int index, \n-\t\t     struct df_urec_bb_info *bb_info)\n-{\n-  gcc_assert (df_urec);\n-  gcc_assert (index < df_urec->block_info_size);\n-  df_urec->block_info[index] = bb_info;\n-}\n-\n-\n-/* Free basic block info.  */\n-\n-static void\n-df_urec_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n-\t\t      void *vbb_info)\n-{\n-  struct df_urec_bb_info *bb_info = (struct df_urec_bb_info *) vbb_info;\n-  if (bb_info)\n-    {\n-      BITMAP_FREE (bb_info->gen);\n-      BITMAP_FREE (bb_info->kill);\n-      BITMAP_FREE (bb_info->in);\n-      BITMAP_FREE (bb_info->out);\n-      BITMAP_FREE (bb_info->earlyclobber);\n-      pool_free (df_urec->block_pool, bb_info);\n-    }\n-}\n-\n-\n-/* Allocate or reset bitmaps for DF_UREC blocks. The solution bits are\n-   not touched unless the block is new.  */\n-\n-static void \n-df_urec_alloc (bitmap all_blocks)\n-\n-{\n-  unsigned int bb_index;\n-  bitmap_iterator bi;\n-  struct df_urec_problem_data *problem_data\n-    = (struct df_urec_problem_data *) df_urec->problem_data;\n-\n-  if (!df_urec->block_pool)\n-    df_urec->block_pool = create_alloc_pool (\"df_urec_block pool\", \n-\t\t\t\t\t   sizeof (struct df_urec_bb_info), 50);\n-\n-  if (!df_urec->problem_data)\n-    {\n-      problem_data = XNEW (struct df_urec_problem_data);\n-      df_urec->problem_data = problem_data;\n-    }\n-  problem_data->earlyclobbers_found = false;\n-\n-  df_grow_bb_info (df_urec);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n-    {\n-      struct df_urec_bb_info *bb_info = df_urec_get_bb_info (bb_index);\n-      if (bb_info)\n-\t{ \n-\t  bitmap_clear (bb_info->kill);\n-\t  bitmap_clear (bb_info->gen);\n-\t  bitmap_clear (bb_info->earlyclobber);\n-\t}\n-      else\n-\t{ \n-\t  bb_info = (struct df_urec_bb_info *) pool_alloc (df_urec->block_pool);\n-\t  df_urec_set_bb_info (bb_index, bb_info);\n-\t  bb_info->kill = BITMAP_ALLOC (NULL);\n-\t  bb_info->gen = BITMAP_ALLOC (NULL);\n-\t  bb_info->in = BITMAP_ALLOC (NULL);\n-\t  bb_info->out = BITMAP_ALLOC (NULL);\n-          bb_info->top = BITMAP_ALLOC (NULL);\n-\t  bb_info->earlyclobber = BITMAP_ALLOC (NULL);\n-\t}\n-    }\n-  df_urec->optional_p = true;\n-}\n-\n-\n-/* The function modifies local info for register REG being changed in\n-   SETTER.  DATA is used to pass the current basic block info.  */\n-\n-static void\n-df_urec_mark_reg_change (rtx reg, const_rtx setter, void *data)\n-{\n-  int regno;\n-  int endregno;\n-  int i;\n-  struct df_urec_bb_info *bb_info = (struct df_urec_bb_info*) data;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-\n-  if (!REG_P (reg))\n-    return;\n-  \n-  regno = REGNO (reg);\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      endregno = END_HARD_REGNO (reg);\n-      for (i = regno; i < endregno; i++)\n-\t{\n-\t  bitmap_set_bit (bb_info->kill, i);\n-\t  \n-\t  if (GET_CODE (setter) != CLOBBER)\n-\t    bitmap_set_bit (bb_info->gen, i);\n-\t  else\n-\t    bitmap_clear_bit (bb_info->gen, i);\n-\t}\n-    }\n-  else\n-    {\n-      bitmap_set_bit (bb_info->kill, regno);\n-      \n-      if (GET_CODE (setter) != CLOBBER)\n-\tbitmap_set_bit (bb_info->gen, regno);\n-      else\n-\tbitmap_clear_bit (bb_info->gen, regno);\n-    }\n-}\n-/* Classes of registers which could be early clobbered in the current\n-   insn.  */\n-\n-static VEC(int,heap) *earlyclobber_regclass;\n-\n-/* This function finds and stores register classes that could be early\n-   clobbered in INSN.  If any earlyclobber classes are found, the function\n-   returns TRUE, in all other cases it returns FALSE.  */\n-\n-static bool\n-df_urec_check_earlyclobber (rtx insn)\n-{\n-  int opno;\n-  bool found = false;\n-\n-  extract_insn (insn);\n-\n-  VEC_truncate (int, earlyclobber_regclass, 0);\n-  for (opno = 0; opno < recog_data.n_operands; opno++)\n-    {\n-      char c;\n-      bool amp_p;\n-      int i;\n-      enum reg_class class;\n-      const char *p = recog_data.constraints[opno];\n-\n-      class = NO_REGS;\n-      amp_p = false;\n-      for (;;)\n-\t{\n-\t  c = *p;\n-\t  switch (c)\n-\t    {\n-\t    case '=':  case '+':  case '?':\n-\t    case '#':  case '!':\n-\t    case '*':  case '%':\n-\t    case 'm':  case '<':  case '>':  case 'V':  case 'o':\n-\t    case 'E':  case 'F':  case 'G':  case 'H':\n-\t    case 's':  case 'i':  case 'n':\n-\t    case 'I':  case 'J':  case 'K':  case 'L':\n-\t    case 'M':  case 'N':  case 'O':  case 'P':\n-\t    case 'X':\n-\t    case '0': case '1':  case '2':  case '3':  case '4':\n-\t    case '5': case '6':  case '7':  case '8':  case '9':\n-\t      /* These don't say anything we care about.  */\n-\t      break;\n-\n-\t    case '&':\n-\t      amp_p = true;\n-\t      break;\n-\t    case '\\0':\n-\t    case ',':\n-\t      if (amp_p && class != NO_REGS)\n-\t\t{\n-\t\t  int rc;\n-\n-\t\t  found = true;\n-\t\t  for (i = 0;\n-\t\t       VEC_iterate (int, earlyclobber_regclass, i, rc);\n-\t\t       i++)\n-\t\t    {\n-\t\t      if (rc == (int) class)\n-\t\t\tgoto found_rc;\n-\t\t    }\n-\n-\t\t  /* We use VEC_quick_push here because\n-\t\t     earlyclobber_regclass holds no more than\n-\t\t     N_REG_CLASSES elements. */\n-\t\t  VEC_quick_push (int, earlyclobber_regclass, (int) class);\n-\t\tfound_rc:\n-\t\t  ;\n-\t\t}\n-\t      \n-\t      amp_p = false;\n-\t      class = NO_REGS;\n-\t      break;\n-\n-\t    case 'r':\n-\t      class = GENERAL_REGS;\n-\t      break;\n-\n-\t    default:\n-\t      class = REG_CLASS_FROM_CONSTRAINT (c, p);\n-\t      break;\n-\t    }\n-\t  if (c == '\\0')\n-\t    break;\n-\t  p += CONSTRAINT_LEN (c, p);\n-\t}\n-    }\n-\n-  return found;\n-}\n-\n-/* The function checks that pseudo-register *X has a class\n-   intersecting with the class of pseudo-register could be early\n-   clobbered in the same insn.\n-\n-   This function is a no-op if earlyclobber_regclass is empty. \n-\n-   Reload can assign the same hard register to uninitialized\n-   pseudo-register and early clobbered pseudo-register in an insn if\n-   the pseudo-register is used first time in given BB and not lived at\n-   the BB start.  To prevent this we don't change life information for\n-   such pseudo-registers.  */\n-\n-static int\n-df_urec_mark_reg_use_for_earlyclobber (rtx *x, void *data)\n-{\n-  enum reg_class pref_class, alt_class;\n-  int i, regno;\n-  struct df_urec_bb_info *bb_info = (struct df_urec_bb_info*) data;\n-\n-  if (REG_P (*x) && REGNO (*x) >= FIRST_PSEUDO_REGISTER)\n-    {\n-      int rc;\n-\n-      regno = REGNO (*x);\n-      if (bitmap_bit_p (bb_info->kill, regno)\n-\t  || bitmap_bit_p (bb_info->gen, regno))\n-\treturn 0;\n-      pref_class = reg_preferred_class (regno);\n-      alt_class = reg_alternate_class (regno);\n-      for (i = 0; VEC_iterate (int, earlyclobber_regclass, i, rc); i++)\n-\t{\n-\t  if (reg_classes_intersect_p (rc, pref_class)\n-\t      || (rc != NO_REGS\n-\t\t  && reg_classes_intersect_p (rc, alt_class)))\n-\t    {\n-\t      bitmap_set_bit (bb_info->earlyclobber, regno);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n-/* The function processes all pseudo-registers in *X with the aid of\n-   previous function.  */\n-\n-static void\n-df_urec_mark_reg_use_for_earlyclobber_1 (rtx *x, void *data)\n-{\n-  for_each_rtx (x, df_urec_mark_reg_use_for_earlyclobber, data);\n-}\n-\n-\n-/* Compute local uninitialized register info for basic block BB.  */\n-\n-static void\n-df_urec_bb_local_compute (unsigned int bb_index)\n-{\n-  basic_block bb = BASIC_BLOCK (bb_index);\n-  struct df_urec_bb_info *bb_info = df_urec_get_bb_info (bb_index);\n-  rtx insn;\n-  struct df_ref **def_rec;\n-\n-  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n-    {\n-      struct df_ref *def = *def_rec;\n-      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\t{\n-\t  unsigned int regno = DF_REF_REGNO (def);\n-\t  bitmap_set_bit (bb_info->gen, regno);\n-\t}\n-    }\n-  \n-  FOR_BB_INSNS (bb, insn)\n-    {\n-      if (INSN_P (insn))\n-\t{\n-\t  note_stores (PATTERN (insn), df_urec_mark_reg_change, bb_info);\n-\t  if (df_urec_check_earlyclobber (insn))\n-\t    {\n-\t      struct df_urec_problem_data *problem_data\n-\t\t= (struct df_urec_problem_data *) df_urec->problem_data;\n-\t      problem_data->earlyclobbers_found = true;\n-\t      note_uses (&PATTERN (insn), \n-\t\t\t df_urec_mark_reg_use_for_earlyclobber_1, bb_info);\n-\t    }\n-\t}\n-    }\n-\n-  for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n-    {\n-      struct df_ref *def = *def_rec;\n-      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n-\t{\n-\t  unsigned int regno = DF_REF_REGNO (def);\n-\t  bitmap_set_bit (bb_info->gen, regno);\n-\t}\n-    }\n-}\n-\n-\n-/* Compute local uninitialized register info.  */\n-\n-static void\n-df_urec_local_compute (bitmap all_blocks)\n-{\n-  unsigned int bb_index;\n-  bitmap_iterator bi;\n-#ifdef STACK_REGS\n-  int i;\n-  HARD_REG_SET stack_hard_regs, used;\n-  struct df_urec_problem_data *problem_data\n-    = (struct df_urec_problem_data *) df_urec->problem_data;\n-  \n-  /* Any register that MAY be allocated to a register stack (like the\n-     387) is treated poorly.  Each such register is marked as being\n-     live everywhere.  This keeps the register allocator and the\n-     subsequent passes from doing anything useful with these values.\n-\n-     FIXME: This seems like an incredibly poor idea.  */\n-\n-  CLEAR_HARD_REG_SET (stack_hard_regs);\n-  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-    SET_HARD_REG_BIT (stack_hard_regs, i);\n-  problem_data->stack_regs = BITMAP_ALLOC (NULL);\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    {\n-      COPY_HARD_REG_SET (used, reg_class_contents[reg_preferred_class (i)]);\n-      IOR_HARD_REG_SET (used, reg_class_contents[reg_alternate_class (i)]);\n-      AND_HARD_REG_SET (used, stack_hard_regs);\n-      if (!hard_reg_set_empty_p (used))\n-\tbitmap_set_bit (problem_data->stack_regs, i);\n-    }\n-#endif\n-\n-  /* We know that earlyclobber_regclass holds no more than\n-    N_REG_CLASSES elements.  See df_urec_check_earlyclobber.  */\n-  earlyclobber_regclass = VEC_alloc (int, heap, N_REG_CLASSES);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n-    {\n-      df_urec_bb_local_compute (bb_index);\n-    }\n-\n-  VEC_free (int, heap, earlyclobber_regclass);\n-}\n-\n-\n-/* Initialize the solution vectors.  */\n-\n-static void \n-df_urec_init (bitmap all_blocks)\n-{\n-  unsigned int bb_index;\n-  bitmap_iterator bi;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n-    {\n-      struct df_urec_bb_info *bb_info = df_urec_get_bb_info (bb_index);\n-\n-      bitmap_copy (bb_info->out, bb_info->gen);\n-      bitmap_clear (bb_info->in);\n-    }\n-}\n-\n-\n-/* Or in the stack regs, hard regs and early clobber regs into the\n-   urec_in sets of all of the blocks.  */\n- \n-\n-static void\n-df_urec_local_finalize (bitmap all_blocks)\n-{\n-  bitmap tmp = BITMAP_ALLOC (NULL);\n-  bitmap_iterator bi;\n-  unsigned int bb_index;\n-  struct df_urec_problem_data *problem_data\n-    = (struct df_urec_problem_data *) df_urec->problem_data;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n-    {\n-      struct df_urec_bb_info *bb_info = df_urec_get_bb_info (bb_index);\n-      struct df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n-\n-      if (bb_index != ENTRY_BLOCK && bb_index != EXIT_BLOCK)\n-\t{\n-\t  if (problem_data->earlyclobbers_found)\n-\t    bitmap_ior_into (bb_info->in, bb_info->earlyclobber);\n-\t\n-#ifdef STACK_REGS\n-\t  /* We can not use the same stack register for uninitialized\n-\t     pseudo-register and another living pseudo-register\n-\t     because if the uninitialized pseudo-register dies,\n-\t     subsequent pass reg-stack will be confused (it will\n-\t     believe that the other register dies).  */\n-\t  bitmap_ior_into (bb_info->in, problem_data->stack_regs);\n-\t  bitmap_ior_into (bb_info->out, problem_data->stack_regs);\n-#endif\n-\t}\n-\n-      /* No register may reach a location where it is not used.  Thus\n-\t we trim the rr result to the places where it is used.  */\n-      bitmap_and_into (bb_info->in, bb_lr_info->in);\n-      bitmap_and_into (bb_info->out, bb_lr_info->out);\n-      bitmap_copy (bb_info->top, bb_info->in);\n-      if (bb_lr_info->adef)\n-        bitmap_ior_into (bb_info->top, bb_lr_info->adef);\n-      bitmap_and_into (bb_info->top, bb_lr_info->top);\n-#if 0\n-      /* Hard registers may still stick in the ur_out set, but not\n-\t be in the ur_in set, if their only mention was in a call\n-\t in this block.  This is because a call kills in the lr\n-\t problem but does not kill in the rr problem.  To clean\n-\t this up, we execute the transfer function on the lr_in\n-\t set and then use that to knock bits out of ur_out.  */\n-      bitmap_ior_and_compl (tmp, bb_info->gen, bb_lr_info->in, \n-\t\t\t    bb_info->kill);\n-      bitmap_and_into (bb_info->out, tmp);\n-#endif\n-    }\n-  \n-#ifdef STACK_REGS\n-  BITMAP_FREE (problem_data->stack_regs);\n-#endif\n-  BITMAP_FREE (tmp);\n-}\n-\n-\n-/* Confluence function that ignores fake edges.  */\n-\n-static void\n-df_urec_confluence_n (edge e)\n-{\n-  bitmap op1 = df_urec_get_bb_info (e->dest->index)->in;\n-  bitmap op2 = df_urec_get_bb_info (e->src->index)->out;\n- \n-  if (e->flags & EDGE_FAKE) \n-    return;\n-\n-  bitmap_ior_into (op1, op2);\n-} \n-\n-\n-/* Transfer function.  */\n-\n-static bool\n-df_urec_transfer_function (int bb_index)\n-{\n-  struct df_urec_bb_info *bb_info = df_urec_get_bb_info (bb_index);\n-  bitmap in = bb_info->in;\n-  bitmap out = bb_info->out;\n-  bitmap gen = bb_info->gen;\n-  bitmap kill = bb_info->kill;\n-\n-  return bitmap_ior_and_compl (out, gen, in, kill);\n-}\n-\n-\n-/* Free all storage associated with the problem.  */\n-\n-static void\n-df_urec_free (void)\n-{\n-  if (df_urec->block_info)\n-    {\n-      unsigned int i;\n-      \n-      for (i = 0; i < df_urec->block_info_size; i++)\n-\t{\n-\t  struct df_urec_bb_info *bb_info = df_urec_get_bb_info (i);\n-\t  if (bb_info)\n-\t    {\n-\t      BITMAP_FREE (bb_info->gen);\n-\t      BITMAP_FREE (bb_info->kill);\n-\t      BITMAP_FREE (bb_info->in);\n-\t      BITMAP_FREE (bb_info->out);\n-\t      BITMAP_FREE (bb_info->earlyclobber);\n-              BITMAP_FREE (bb_info->top);\n-\t    }\n-\t}\n-      \n-      free_alloc_pool (df_urec->block_pool);\n-      \n-      df_urec->block_info_size = 0;\n-      free (df_urec->block_info);\n-      free (df_urec->problem_data);\n-    }\n-  free (df_urec);\n-}\n-\n-\n-/* Debugging info at top of bb.  */\n-\n-static void\n-df_urec_top_dump (basic_block bb, FILE *file)\n-{\n-  struct df_urec_bb_info *bb_info = df_urec_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->in)\n-    return;\n-      \n-  fprintf (file, \";; urec  in  \\t\");\n-  df_print_regset (file, bb_info->in);\n-  fprintf (file, \";; urec  gen \\t\");\n-  df_print_regset (file, bb_info->gen);\n-  fprintf (file, \";; urec  kill\\t\");\n-  df_print_regset (file, bb_info->kill);\n-  fprintf (file, \";; urec  ec\\t\");\n-  df_print_regset (file, bb_info->earlyclobber);\n-}\n-\n-\n-/* Debugging info at bottom of bb.  */\n-\n-static void\n-df_urec_bottom_dump (basic_block bb, FILE *file)\n-{\n-  struct df_urec_bb_info *bb_info = df_urec_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->out)\n-    return;\n-  fprintf (file, \";; urec  out \\t\");\n-  df_print_regset (file, bb_info->out);\n-}\n-\n-\n-/* All of the information associated with every instance of the problem.  */\n-\n-static struct df_problem problem_UREC =\n-{\n-  DF_UREC,                    /* Problem id.  */\n-  DF_FORWARD,                 /* Direction.  */\n-  df_urec_alloc,              /* Allocate the problem specific data.  */\n-  NULL,                       /* Reset global information.  */\n-  df_urec_free_bb_info,       /* Free basic block info.  */\n-  df_urec_local_compute,      /* Local compute function.  */\n-  df_urec_init,               /* Init the solution specific data.  */\n-  df_worklist_dataflow,       /* Worklist solver.  */\n-  NULL,                       /* Confluence operator 0.  */ \n-  df_urec_confluence_n,       /* Confluence operator n.  */ \n-  df_urec_transfer_function,  /* Transfer function.  */\n-  df_urec_local_finalize,     /* Finalize function.  */\n-  df_urec_free,               /* Free all of the problem information.  */\n-  df_urec_free,               /* Remove this problem from the stack of dataflow problems.  */\n-  NULL,                       /* Debugging.  */\n-  df_urec_top_dump,           /* Debugging start block.  */\n-  df_urec_bottom_dump,        /* Debugging end block.  */\n-  NULL,                       /* Incremental solution verify start.  */\n-  NULL,                       /* Incremental solution verify end.  */\n-  &problem_LR,                /* Dependent problem.  */\n-  TV_DF_UREC,                 /* Timing variable.  */ \n-  false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n-};\n-\n-\n-/* Create a new DATAFLOW instance and add it to an existing instance\n-   of DF.  The returned structure is what is used to get at the\n-   solution.  */\n-\n-void\n-df_urec_add_problem (void)\n-{\n-  df_add_problem (&problem_UREC);\n-}\n-\n-\n \f\n /*----------------------------------------------------------------------------\n    CREATE DEF_USE (DU) and / or USE_DEF (UD) CHAINS\n@@ -3707,7 +3020,7 @@ df_simulate_fixup_sets (basic_block bb, bitmap live)\n {\n   /* These regs are considered always live so if they end up dying\n      because of some def, we need to bring the back again.  */\n-  if (df_has_eh_preds (bb))\n+  if (bb_has_eh_pred (bb))\n     bitmap_ior_into (live, df->eh_block_artificial_uses);\n   else\n     bitmap_ior_into (live, df->regular_block_artificial_uses);"}, {"sha": "f4ced0d34c94ae04c77caacd01b7b29d425b8e48", "filename": "gcc/df-scan.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -2752,23 +2752,37 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \t || GET_CODE (dst) == ZERO_EXTRACT)\n     {\n       flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL;\n+      if (GET_CODE (dst) == ZERO_EXTRACT)\n+\tflags |= DF_REF_EXTRACT;\n+      else\n+\tflags |= DF_REF_STRICT_LOWER_PART;\n+\n       loc = &XEXP (dst, 0);\n       dst = *loc;\n     }\n \n-  if (df_read_modify_subreg_p (dst))\n-    flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL;\n+  /* At this point if we do not have a reg or a subreg, just return.  */\n+  if (REG_P (dst))\n+    {\n+      df_ref_record (collection_rec, \n+\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags);\n \n-  if (REG_P (dst)\n-      || (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst))))\n-    df_ref_record (collection_rec, \n-                   dst, loc, bb, insn, DF_REF_REG_DEF, flags);\n+      /* We want to keep sp alive everywhere - by making all\n+\t writes to sp also use of sp. */\n+      if (REGNO (dst) == STACK_POINTER_REGNUM)\n+\tdf_ref_record (collection_rec,\n+\t\t       dst, NULL, bb, insn, DF_REF_REG_USE, flags);\n+    }\n+  else if (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst)))\n+    {\n+      if (df_read_modify_subreg_p (dst))\n+\tflags |= DF_REF_READ_WRITE | DF_REF_PARTIAL;\n \n-  /* We want to keep sp alive everywhere - by making all\n-     writes to sp also use of sp. */\n-  if (REG_P (dst) && REGNO (dst) == STACK_POINTER_REGNUM)\n-    df_ref_record (collection_rec,\n-               dst, NULL, bb, insn, DF_REF_REG_USE, flags);\n+      flags |= DF_REF_SUBREG;\n+\n+      df_ref_record (collection_rec, \n+\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags);\n+    }\n }\n \n \n@@ -2880,7 +2894,8 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t      if (df_read_modify_subreg_p (dst))\n \t\t{\n \t\t  df_uses_record (collection_rec, &SUBREG_REG (dst), \n-\t\t\t\t  DF_REF_REG_USE, bb, insn, flags | DF_REF_READ_WRITE);\n+\t\t\t\t  DF_REF_REG_USE, bb, insn, \n+\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG);\n \t\t  break;\n \t\t}\n \t      /* Fall through.  */\n@@ -2902,13 +2917,15 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tdst = XEXP (dst, 0);\n \t\tdf_uses_record (collection_rec, \n \t\t\t\t(GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp, \n-\t\t\t\tDF_REF_REG_USE, bb, insn, DF_REF_READ_WRITE);\n+\t\t\t\tDF_REF_REG_USE, bb, insn, \n+\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOWER_PART);\n \t      }\n \t      break;\n \t    case ZERO_EXTRACT:\n \t    case SIGN_EXTRACT:\n \t      df_uses_record (collection_rec, &XEXP (dst, 0), \n-\t\t\t      DF_REF_REG_USE, bb, insn, DF_REF_READ_WRITE);\n+\t\t\t      DF_REF_REG_USE, bb, insn, \n+\t\t\t      DF_REF_READ_WRITE | DF_REF_EXTRACT);\n \t      df_uses_record (collection_rec, &XEXP (dst, 1), \n \t\t\t      DF_REF_REG_USE, bb, insn, flags);\n \t      df_uses_record (collection_rec, &XEXP (dst, 2), \n@@ -3180,23 +3197,6 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n   df_canonize_collection_rec (collection_rec);\n }\n \n-/* Return true if any pred of BB is an eh.  */\n-\n-bool\n-df_has_eh_preds (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      if (e->flags & EDGE_EH)\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n-\n /* Recompute the luids for the insns in BB.  */\n \n void\n@@ -3261,7 +3261,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n     }\n \n #ifdef EH_RETURN_DATA_REGNO\n-  if (df_has_eh_preds (bb))\n+  if (bb_has_eh_pred (bb))\n     {\n       unsigned int i;\n       /* Mark the registers that will contain data for the handler.  */\n@@ -3278,7 +3278,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n \n \n #ifdef EH_USES\n-  if (df_has_eh_preds (bb))\n+  if (bb_has_eh_pred (bb))\n     {\n       unsigned int i;\n       /* This code is putting in an artificial ref for the use at the\n@@ -3310,7 +3310,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n     {\n       bitmap_iterator bi;\n       unsigned int regno;\n-      bitmap au = df_has_eh_preds (bb) \n+      bitmap au = bb_has_eh_pred (bb) \n \t? df->eh_block_artificial_uses \n \t: df->regular_block_artificial_uses;\n \n@@ -3481,8 +3481,6 @@ df_mark_reg (rtx reg, void *vset)\n }\n \n \n-\n-\n /* Set the bit for regs that are considered being defined at the entry. */\n \n static void\n@@ -3780,7 +3778,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n      I do not know why.  */\n   if (reload_completed \n       && !bitmap_bit_p (exit_block_uses, ARG_POINTER_REGNUM)\n-      && df_has_eh_preds (EXIT_BLOCK_PTR)\n+      && bb_has_eh_pred (EXIT_BLOCK_PTR)\n       && fixed_regs[ARG_POINTER_REGNUM])\n     df_ref_record (collection_rec, regno_reg_rtx[ARG_POINTER_REGNUM], NULL,\n \t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0);"}, {"sha": "a681249d1a6d96a68ce6a7a49a869fa05e0e47f1", "filename": "gcc/df.h", "status": "modified", "additions": 50, "deletions": 91, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -43,11 +43,9 @@ struct df_link;\n #define DF_SCAN  0 \n #define DF_LR    1      /* Live Registers backward. */\n #define DF_LIVE  2      /* Live Registers & Uninitialized Registers */\n-\n #define DF_RD    3      /* Reaching Defs. */\n-#define DF_UREC  4      /* Uninitialized Registers with Early Clobber. */\n-#define DF_CHAIN 5      /* Def-Use and/or Use-Def Chains. */\n-#define DF_NOTE  6      /* REG_DEF and REG_UNUSED notes. */\n+#define DF_CHAIN 4      /* Def-Use and/or Use-Def Chains. */\n+#define DF_NOTE  5      /* REG_DEF and REG_UNUSED notes. */\n \n #define DF_LAST_PROBLEM_PLUS1 (DF_NOTE + 1)\n \n@@ -70,10 +68,9 @@ enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n \n enum df_ref_flags\n   {\n-    /* Read-modify-write refs generate both a use and a def and\n-       these are marked with this flag to show that they are not\n-       independent.  */\n-    DF_REF_READ_WRITE = 1 << 0,\n+    /* This flag is set if this ref occurs inside of a conditional\n+       execution instruction.  */\n+    DF_REF_CONDITIONAL = 1 << 0,\n \n     /* If this flag is set for an artificial use or def, that ref\n        logically happens at the top of the block.  If it is not set\n@@ -85,14 +82,26 @@ enum df_ref_flags\n        note.  */\n     DF_REF_IN_NOTE = 1 << 2,\n \n+    /* This bit is true if this ref can make regs_ever_live true for\n+       this regno.  */\n+    DF_HARD_REG_LIVE = 1 << 3,\n+\n+\n+    /* This flag is set if this ref is a partial use or def of the\n+       associated register.  */\n+    DF_REF_PARTIAL = 1 << 4,\n+    \n+    /* Read-modify-write refs generate both a use and a def and\n+       these are marked with this flag to show that they are not\n+       independent.  */\n+    DF_REF_READ_WRITE = 1 << 5,\n+\n     /* This flag is set if this ref, generally a def, may clobber the\n        referenced register.  This is generally only set for hard\n        registers that cross a call site.  With better information\n        about calls, some of these could be changed in the future to\n        DF_REF_MUST_CLOBBER.  */\n-    DF_REF_MAY_CLOBBER = 1 << 3,\n-\n-\n+    DF_REF_MAY_CLOBBER = 1 << 6,\n \n     /* This flag is set if this ref, generally a def, is a real\n        clobber. This is not currently set for registers live across a\n@@ -103,34 +112,31 @@ enum df_ref_flags\n        clobber is to a subreg.  So in order to tell if the clobber\n        wipes out the entire register, it is necessary to also check\n        the DF_REF_PARTIAL flag.  */\n-    DF_REF_MUST_CLOBBER = 1 << 4,\n+    DF_REF_MUST_CLOBBER = 1 << 7,\n \n-    /* This bit is true if this ref is part of a multiword hardreg.  */\n-    DF_REF_MW_HARDREG = 1 << 5,\n \n-    /* This flag is set if this ref is a partial use or def of the\n-       associated register.  */\n-    DF_REF_PARTIAL = 1 << 6,\n-    \n-    /* This flag is set if this ref occurs inside of a conditional\n-       execution instruction.  */\n-    DF_REF_CONDITIONAL = 1 << 7,\n+    /* This flag is set if this ref is inside a pre/post modify.  */\n+    DF_REF_PRE_POST_MODIFY = 1 << 8,\n \n+    /* This flag is set if the ref contains a ZERO_EXTRACT or SIGN_EXTRACT.  */\n+    DF_REF_EXTRACT = 1 << 9,\n \n+    /* This flag is set if the ref contains a STRICT_LOWER_PART.  */\n+    DF_REF_STRICT_LOWER_PART = 1 << 10,\n \n-    /* This flag is set if this ref is inside a pre/post modify.  */\n-    DF_REF_PRE_POST_MODIFY = 1 << 8,\n+    /* This flag is set if the ref contains a SUBREG.  */\n+    DF_REF_SUBREG = 1 << 11,\n+\n+\n+    /* This bit is true if this ref is part of a multiword hardreg.  */\n+    DF_REF_MW_HARDREG = 1 << 12,\n \n     /* This flag is set if this ref is a usage of the stack pointer by\n        a function call.  */\n-    DF_REF_CALL_STACK_USAGE = 1 << 9,\n+    DF_REF_CALL_STACK_USAGE = 1 << 13,\n \n     /* This flag is used for verification of existing refs. */\n-    DF_REF_REG_MARKER = 1 << 10,\n-\n-    /* This bit is true if this ref can make regs_ever_live true for\n-       this regno.  */\n-    DF_HARD_REG_LIVE = 1 << 11\n+    DF_REF_REG_MARKER = 1 << 14\n   };\n \n /* The possible ordering of refs within the df_ref_info.  */\n@@ -544,25 +550,17 @@ struct df\n #define DF_SCAN_BB_INFO(BB) (df_scan_get_bb_info((BB)->index))\n #define DF_RD_BB_INFO(BB) (df_rd_get_bb_info((BB)->index))\n #define DF_LR_BB_INFO(BB) (df_lr_get_bb_info((BB)->index))\n-#define DF_UREC_BB_INFO(BB) (df_urec_get_bb_info((BB)->index))\n #define DF_LIVE_BB_INFO(BB) (df_live_get_bb_info((BB)->index))\n \n /* Most transformations that wish to use live register analysis will\n    use these macros.  This info is the and of the lr and live sets.  */\n #define DF_LIVE_IN(BB) (DF_LIVE_BB_INFO(BB)->in) \n #define DF_LIVE_OUT(BB) (DF_LIVE_BB_INFO(BB)->out) \n \n-\n-/* Live in for register allocation also takes into account several other factors.  */\n-#define DF_RA_LIVE_IN(BB) (DF_UREC_BB_INFO(BB)->in) \n-#define DF_RA_LIVE_TOP(BB) (DF_UREC_BB_INFO(BB)->top) \n-#define DF_RA_LIVE_OUT(BB) (DF_UREC_BB_INFO(BB)->out) \n-\n /* These macros are currently used by only reg-stack since it is not\n    tolerant of uninitialized variables.  This intolerance should be\n    fixed because it causes other problems.  */ \n #define DF_LR_IN(BB) (DF_LR_BB_INFO(BB)->in) \n-#define DF_LR_TOP(BB) (DF_LR_BB_INFO(BB)->top) \n #define DF_LR_OUT(BB) (DF_LR_BB_INFO(BB)->out) \n \n /* Macros to access the elements within the ref structure.  */\n@@ -685,11 +683,21 @@ extern bitmap df_invalidated_by_call;\n /* One of these structures is allocated for every basic block.  */\n struct df_scan_bb_info\n {\n-  /* Defs at the start of a basic block that is the target of an\n-     exception edge.  */\n+  /* The entry block has many artificial defs and these are at the\n+     bottom of the block.\n+\n+     Blocks that are targets of exception edges may have some\n+     artificial defs.  These are logically located at the top of the\n+     block.\n+\n+     Blocks that are the targets of non-local goto's have the hard\n+     frame pointer defined at the top of the block.  */\n   struct df_ref **artificial_defs;\n \n-  /* Uses of hard registers that are live at every block.  */\n+  /* Blocks that are targets of exception edges may have some\n+     artificial uses.  These are logically at the top of the block.\n+\n+     Most blocks have artificial uses at the bottom of the block.  */\n   struct df_ref **artificial_uses;\n };\n \n@@ -710,36 +718,18 @@ struct df_rd_bb_info\n };\n \n \n-/* Live registers.  All bitmaps are referenced by the register number.  \n-\n-   df_lr_bb_info:IN is the \"in\" set of the traditional dataflow sense\n-   which is the confluence of out sets of all predecessor blocks.\n-   The difference between IN and TOP is \n-   due to the artificial defs and uses at the top (DF_REF_TOP)\n-   (e.g. exception handling dispatch block, which can have\n-   a few registers defined by the runtime) - which is NOT included\n-   in the \"in\" set before this function but is included after.  \n-   For the initial live set of forward scanning, TOP should be used\n-   instead of IN - otherwise, artificial defs won't be in IN set\n-   causing the bad transformation. TOP set can not simply be\n-   the union of IN set and artificial defs at the top, \n-   because artificial defs might not be used at all,\n-   in which case those defs are not live at any point\n-   (except as a dangling def) - hence TOP has to be calculated\n-   during the LR problem computation and stored in df_lr_bb_info.  */\n+/* Live registers, a backwards dataflow problem.  All bitmaps are\n+   referenced by the register number.  */\n \n struct df_lr_bb_info \n {\n   /* Local sets to describe the basic blocks.  */\n   bitmap def;   /* The set of registers set in this block \n                    - except artificial defs at the top.  */\n   bitmap use;   /* The set of registers used in this block.  */\n-  bitmap adef;  /* The artificial defs at top. */\n-  bitmap ause;  /* The artificial uses at top. */\n \n   /* The results of the dataflow problem.  */\n   bitmap in;    /* Just before the block itself. */\n-  bitmap top;   /* Just before the first insn in the block. */\n   bitmap out;   /* At the bottom of the block.  */\n };\n \n@@ -761,23 +751,6 @@ struct df_live_bb_info\n };\n \n \n-/* Uninitialized registers.  All bitmaps are referenced by the register number.  */\n-struct df_urec_bb_info \n-{\n-  /* Local sets to describe the basic blocks.  */\n-  bitmap earlyclobber;  /* The set of registers that are referenced\n-\t\t\t   with an early clobber mode.  */\n-  /* Kill and gen are defined as in the UR problem.  */\n-  bitmap kill;\n-  bitmap gen;\n-\n-  /* The results of the dataflow problem.  */\n-  bitmap in;    /* Just before the block.  */\n-  bitmap top;   /* Just before the first insn in the block. */\n-  bitmap out;   /* At the bottom of the block.  */\n-};\n-\n-\n /* This is used for debugging and for the dumpers to find the latest\n    instance so that the df info can be added to the dumps.  This\n    should not be used by regular code.  */ \n@@ -786,7 +759,6 @@ extern struct df *df;\n #define df_rd    (df->problems_by_index[DF_RD])\n #define df_lr    (df->problems_by_index[DF_LR])\n #define df_live  (df->problems_by_index[DF_LIVE])\n-#define df_urec  (df->problems_by_index[DF_UREC])\n #define df_chain (df->problems_by_index[DF_CHAIN])\n #define df_note  (df->problems_by_index[DF_NOTE])\n \n@@ -861,7 +833,6 @@ extern void df_chain_unlink (struct df_ref *);\n extern void df_chain_copy (struct df_ref *, struct df_link *);\n extern bitmap df_get_live_in (basic_block);\n extern bitmap df_get_live_out (basic_block);\n-extern bitmap df_get_live_top (basic_block);\n extern void df_grow_bb_info (struct dataflow *);\n extern void df_chain_dump (struct df_link *, FILE *);\n extern void df_print_bb_index (basic_block bb, FILE *file);\n@@ -871,7 +842,6 @@ extern void df_lr_verify_transfer_functions (void);\n extern void df_live_verify_transfer_functions (void);\n extern void df_live_add_problem (void);\n extern void df_live_set_all_dirty (void);\n-extern void df_urec_add_problem (void);\n extern void df_chain_add_problem (enum df_chain_flags);\n extern void df_note_add_problem (void);\n extern void df_simulate_find_defs (rtx, bitmap);\n@@ -898,7 +868,6 @@ extern void df_bb_refs_record (int, bool);\n extern bool df_insn_rescan (rtx);\n extern void df_insn_rescan_all (void);\n extern void df_process_deferred_rescans (void);\n-extern bool df_has_eh_preds (basic_block);\n extern void df_recompute_luids (basic_block);\n extern void df_insn_change_bb (rtx);\n extern void df_maybe_reorganize_use_refs (enum df_ref_order);\n@@ -956,16 +925,6 @@ df_live_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline struct df_urec_bb_info *\n-df_urec_get_bb_info (unsigned int index)\n-{\n-  if (index < df_urec->block_info_size)\n-    return (struct df_urec_bb_info *) df_urec->block_info[index];\n-  else\n-    return NULL;\n-}\n-\n-\n /* Get the artificial defs for a basic block.  */\n \n static inline struct df_ref **"}, {"sha": "b71bf4162ca209d6b53a1dfc124bdca1c133d144", "filename": "gcc/global.c", "status": "modified", "additions": 393, "deletions": 837, "changes": 1230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"vecprim.h\"\n #include \"dbgcnt.h\"\n+#include \"ra.h\"\n \n /* This pass of the compiler performs global register allocation.\n    It assigns hard register numbers to all the pseudo registers\n@@ -62,10 +63,13 @@ along with GCC; see the file COPYING3.  If not see\n    reg numbers to allocnos and vice versa.\n    max_allocno gets the number of allocnos in use.\n \n-   2. Allocate a max_allocno by max_allocno conflict bit matrix and clear it.\n-   Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix\n-   for conflicts between allocnos and explicit hard register use\n-   (which includes use of pseudo-registers allocated by local_alloc).\n+   2. Allocate a max_allocno by max_allocno conflict bit matrix and\n+   clear it.  This is called \"conflict\".\n+\n+   Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix for\n+   conflicts between allocnos and explicit hard register use (which\n+   includes use of pseudo-registers allocated by local_alloc).  This\n+   is the hard_reg_conflicts inside each allocno.\n \n    3. For each basic block\n     walk forward through the block, recording which\n@@ -81,128 +85,16 @@ along with GCC; see the file COPYING3.  If not see\n    5. Allocate the variables in that order; each if possible into\n    a preferred register, else into another register.  */\n \f\n-/* Number of pseudo-registers which are candidates for allocation.  */\n-\n-static int max_allocno;\n-\n-/* Indexed by (pseudo) reg number, gives the allocno, or -1\n-   for pseudo registers which are not to be allocated.  */\n-\n-static int *reg_allocno;\n-\n-struct allocno\n-{\n-  int reg;\n-  /* Gives the number of consecutive hard registers needed by that\n-     pseudo reg.  */\n-  int size;\n-\n-  /* Number of calls crossed by each allocno.  */\n-  int calls_crossed;\n-\n-  /* Number of calls that might throw crossed by each allocno.  */\n-  int throwing_calls_crossed;\n-\n-  /* Number of refs to each allocno.  */\n-  int n_refs;\n-\n-  /* Frequency of uses of each allocno.  */\n-  int freq;\n-\n-  /* Guess at live length of each allocno.\n-     This is actually the max of the live lengths of the regs.  */\n-  int live_length;\n-\n-  /* Set of hard regs conflicting with allocno N.  */\n-\n-  HARD_REG_SET hard_reg_conflicts;\n-\n-  /* Set of hard regs preferred by allocno N.\n-     This is used to make allocnos go into regs that are copied to or from them,\n-     when possible, to reduce register shuffling.  */\n-\n-  HARD_REG_SET hard_reg_preferences;\n-\n-  /* Similar, but just counts register preferences made in simple copy\n-     operations, rather than arithmetic.  These are given priority because\n-     we can always eliminate an insn by using these, but using a register\n-     in the above list won't always eliminate an insn.  */\n-\n-  HARD_REG_SET hard_reg_copy_preferences;\n-\n-  /* Similar to hard_reg_preferences, but includes bits for subsequent\n-     registers when an allocno is multi-word.  The above variable is used for\n-     allocation while this is used to build reg_someone_prefers, below.  */\n-\n-  HARD_REG_SET hard_reg_full_preferences;\n-\n-  /* Set of hard registers that some later allocno has a preference for.  */\n-\n-  HARD_REG_SET regs_someone_prefers;\n-\n-#ifdef STACK_REGS\n-  /* Set to true if allocno can't be allocated in the stack register.  */\n-  bool no_stack_reg;\n-#endif\n-};\n-\n-static struct allocno *allocno;\n-\n /* A vector of the integers from 0 to max_allocno-1,\n    sorted in the order of first-to-be-allocated first.  */\n \n static int *allocno_order;\n \n-/* Define the number of bits in each element of `conflicts' and what\n-   type that element has.  We use the largest integer format on the\n-   host machine.  */\n-\n-#define INT_BITS HOST_BITS_PER_WIDE_INT\n-#define INT_TYPE HOST_WIDE_INT\n-\n-/* max_allocno by max_allocno array of bits,\n-   recording whether two allocno's conflict (can't go in the same\n-   hardware register).\n-\n-   `conflicts' is symmetric after the call to mirror_conflicts.  */\n-\n-static INT_TYPE *conflicts;\n-\n-/* Number of ints required to hold max_allocno bits.\n-   This is the length of a row in `conflicts'.  */\n-\n-static int allocno_row_words;\n-\n /* Two macros to test or store 1 in an element of `conflicts'.  */\n \n #define CONFLICTP(I, J) \\\n- (conflicts[(I) * allocno_row_words + (unsigned) (J) / INT_BITS]\t\\\n-  & ((INT_TYPE) 1 << ((unsigned) (J) % INT_BITS)))\n-\n-/* For any allocno set in ALLOCNO_SET, set ALLOCNO to that allocno,\n-   and execute CODE.  */\n-#define EXECUTE_IF_SET_IN_ALLOCNO_SET(ALLOCNO_SET, ALLOCNO, CODE)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  int i_;\t\t\t\t\t\t\t\t\\\n-  int allocno_;\t\t\t\t\t\t\t\t\\\n-  INT_TYPE *p_ = (ALLOCNO_SET);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (i_ = allocno_row_words - 1, allocno_ = 0; i_ >= 0;\t\t\\\n-       i_--, allocno_ += INT_BITS)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      unsigned INT_TYPE word_ = (unsigned INT_TYPE) *p_++;\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      for ((ALLOCNO) = allocno_; word_; word_ >>= 1, (ALLOCNO)++)\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (word_ & 1)\t\t\t\t\t\t\\\n-\t    {CODE;}\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Set of hard regs currently live (during scan of all insns).  */\n-\n-static HARD_REG_SET hard_regs_live;\n+ (conflicts[(I) * allocno_row_words + (unsigned) (J) / HOST_BITS_PER_WIDE_INT]\t\\\n+  & ((HOST_WIDE_INT) 1 << ((unsigned) (J) % HOST_BITS_PER_WIDE_INT)))\n \n /* Set of registers that global-alloc isn't supposed to use.  */\n \n@@ -230,21 +122,6 @@ static int local_reg_live_length[FIRST_PSEUDO_REGISTER];\n \n #define SET_REGBIT(TABLE, I, J)  SET_HARD_REG_BIT (allocno[I].TABLE, J)\n \n-/* Bit mask for allocnos live at current point in the scan.  */\n-\n-static INT_TYPE *allocnos_live;\n-\n-/* Test, set or clear bit number I in allocnos_live,\n-   a bit vector indexed by allocno.  */\n-\n-#define SET_ALLOCNO_LIVE(I)\t\t\t\t\\\n-  (allocnos_live[(unsigned) (I) / INT_BITS]\t\t\\\n-     |= ((INT_TYPE) 1 << ((unsigned) (I) % INT_BITS)))\n-\n-#define CLEAR_ALLOCNO_LIVE(I)\t\t\t\t\\\n-  (allocnos_live[(unsigned) (I) / INT_BITS]\t\t\\\n-     &= ~((INT_TYPE) 1 << ((unsigned) (I) % INT_BITS)))\n-\n /* This is turned off because it doesn't work right for DImode.\n    (And it is only used for DImode, so the other cases are worthless.)\n    The problem is that it isn't true that there is NO possibility of conflict;\n@@ -270,12 +147,6 @@ static struct { int allocno1, allocno2;}\n   no_conflict_pairs[NUM_NO_CONFLICT_PAIRS];\n #endif /* 0 */\n \n-/* Record all regs that are set in any one insn.\n-   Communication from mark_reg_{store,clobber} and global_conflicts.  */\n-\n-static VEC(rtx, heap) *regs_set;\n-\n-\n /* Return true if *LOC contains an asm.  */\n \n static int\n@@ -336,23 +207,13 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)\n static HARD_REG_SET eliminable_regset;\n \n static int allocno_compare (const void *, const void *);\n-static void global_conflicts (void);\n static void mirror_conflicts (void);\n static void expand_preferences (void);\n static void prune_preferences (void);\n+static void set_preferences (void);\n static void find_reg (int, HARD_REG_SET, int, int, int);\n-static void record_one_conflict (int);\n-static void record_conflicts (int *, int);\n-static void mark_reg_store (rtx, const_rtx, void *);\n-static void mark_reg_clobber (rtx, const_rtx, void *);\n-static void mark_reg_conflicts (rtx);\n-static void mark_reg_death (rtx);\n-static void set_preference (rtx, rtx);\n static void dump_conflicts (FILE *);\n-static void reg_becomes_live (rtx, const_rtx, void *);\n-static void reg_dies (int, enum machine_mode, struct insn_chain *);\n-\n-\n+static void build_insn_chain (void);\n \f\n \n /* Look through the list of eliminable registers.  Set ELIM_SET to the\n@@ -572,29 +433,33 @@ global_alloc (void)\n \t  fprintf (dump_file, \" %d\", (int)i);\n       fprintf (dump_file, \"\\n\");\n     }\n-  allocno_row_words = (max_allocno + INT_BITS - 1) / INT_BITS;\n+  allocno_row_words = (max_allocno + HOST_BITS_PER_WIDE_INT - 1) / HOST_BITS_PER_WIDE_INT;\n \n   /* We used to use alloca here, but the size of what it would try to\n      allocate would occasionally cause it to exceed the stack limit and\n      cause unpredictable core dumps.  Some examples were > 2Mb in size.  */\n-  conflicts = XCNEWVEC (INT_TYPE, max_allocno * allocno_row_words);\n-\n-  allocnos_live = XNEWVEC (INT_TYPE, allocno_row_words);\n+  conflicts = XCNEWVEC (HOST_WIDE_INT, max_allocno * allocno_row_words);\n \n   /* If there is work to be done (at least one reg to allocate),\n      perform global conflict analysis and allocate the regs.  */\n \n   if (max_allocno > 0)\n     {\n-      /* Make a vector that mark_reg_{store,clobber} will store in.  */\n-      if (!regs_set)\n-\tregs_set = VEC_alloc (rtx, heap, 10);\n-\n       /* Scan all the insns and compute the conflicts among allocnos\n \t and between allocnos and hard regs.  */\n \n       global_conflicts ();\n \n+      /* There is just too much going on in the register allocators to\n+\t keep things up to date.  At the end we have to rescan anyway\n+\t because things change when the reload_completed flag is set.  \n+\t So we just turn off scanning and we will rescan by hand.  \n+\n+\t However, we needed to do the rescanning before this point to\n+\t get the new insns scanned inserted by local_alloc scanned for\n+\t global_conflicts.  */\n+      df_set_flags (DF_NO_INSN_RESCAN);\n+\n       mirror_conflicts ();\n \n       /* Eliminate conflicts between pseudos and eliminable registers.  If\n@@ -604,6 +469,8 @@ global_alloc (void)\n \t So in either case, we can ignore the conflict.  Likewise for\n \t preferences.  */\n \n+      set_preferences ();\n+\n       for (i = 0; i < (size_t) max_allocno; i++)\n \t{\n \t  AND_COMPL_HARD_REG_SET (allocno[i].hard_reg_conflicts,\n@@ -679,15 +546,14 @@ global_alloc (void)\n   if (n_basic_blocks > NUM_FIXED_BLOCKS)\n #endif\n     {\n-      build_insn_chain (get_insns ());\n+      build_insn_chain ();\n       retval = reload (get_insns (), 1);\n     }\n \n   /* Clean up.  */\n   free (reg_allocno);\n   free (allocno);\n   free (conflicts);\n-  free (allocnos_live);\n \n   return retval;\n }\n@@ -720,238 +586,6 @@ allocno_compare (const void *v1p, const void *v2p)\n   return v1 - v2;\n }\n \f\n-/* Scan the rtl code and record all conflicts and register preferences in the\n-   conflict matrices and preference tables.  */\n-\n-static void\n-global_conflicts (void)\n-{\n-  unsigned i;\n-  basic_block b;\n-  rtx insn;\n-  int *block_start_allocnos;\n-\n-  block_start_allocnos = XNEWVEC (int, max_allocno);\n-\n-  FOR_EACH_BB (b)\n-    {\n-      memset (allocnos_live, 0, allocno_row_words * sizeof (INT_TYPE));\n-\n-      /* Initialize table of registers currently live\n-\t to the state at the beginning of this basic block.\n-\t This also marks the conflicts among hard registers\n-\t and any allocnos that are live.\n-\n-\t For pseudo-regs, there is only one bit for each one\n-\t no matter how many hard regs it occupies.\n-\t This is ok; we know the size from PSEUDO_REGNO_SIZE.\n-\t For explicit hard regs, we cannot know the size that way\n-\t since one hard reg can be used with various sizes.\n-\t Therefore, we must require that all the hard regs\n-\t implicitly live as part of a multi-word hard reg\n-\t be explicitly marked in basic_block_live_at_start.  */\n-\n-      {\n-\tint ax = 0;\n-\treg_set_iterator rsi;\n-\n-\tREG_SET_TO_HARD_REG_SET (hard_regs_live, DF_RA_LIVE_TOP (b));\n-\tEXECUTE_IF_SET_IN_REG_SET (DF_RA_LIVE_TOP (b), FIRST_PSEUDO_REGISTER, i, rsi)\n-\t  {\n-\t    int a = reg_allocno[i];\n-\t    if (a >= 0)\n-\t      {\n-\t\tSET_ALLOCNO_LIVE (a);\n-\t\tblock_start_allocnos[ax++] = a;\n-\t      }\n-\t    else if ((a = reg_renumber[i]) >= 0)\n-\t      add_to_hard_reg_set (&hard_regs_live, PSEUDO_REGNO_MODE (i), a);\n-\t  }\n-\n-\t/* Record that each allocno now live conflicts with each hard reg\n-\t   now live.\n-\n-\t   It is not necessary to mark any conflicts between pseudos at\n-\t   this point, even for pseudos which are live at the start of\n-\t   the basic block.\n-\n-\t     Given two pseudos X and Y and any point in the CFG P.\n-\n-\t     On any path to point P where X and Y are live one of the\n-\t     following conditions must be true:\n-\n-\t\t1. X is live at some instruction on the path that\n-\t\t   evaluates Y.\n-\n-\t\t2. Y is live at some instruction on the path that\n-\t\t   evaluates X.\n-\n-\t\t3. Either X or Y is not evaluated on the path to P\n-\t\t   (i.e. it is used uninitialized) and thus the\n-\t\t   conflict can be ignored.\n-\n-\t    In cases #1 and #2 the conflict will be recorded when we\n-\t    scan the instruction that makes either X or Y become live.  */\n-\trecord_conflicts (block_start_allocnos, ax);\n-\n-#ifdef EH_RETURN_DATA_REGNO\n-\tif (bb_has_eh_pred (b))\n-\t  {\n-\t    unsigned int i;\n-\t    \n-\t    for (i = 0; ; ++i)\n-\t      {\n-\t\tunsigned int regno = EH_RETURN_DATA_REGNO (i);\n-\t\tif (regno == INVALID_REGNUM)\n-\t\t  break;\n-\t\trecord_one_conflict (regno);\n-\t      }\n-\t  }\n-#endif\n-\n-\t/* Pseudos can't go in stack regs at the start of a basic block that\n-\t   is reached by an abnormal edge. Likewise for call clobbered regs,\n-\t   because caller-save, fixup_abnormal_edges and possibly the table\n-\t   driven EH machinery are not quite ready to handle such regs live\n-\t   across such edges.  */\n-\t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\n-\t  FOR_EACH_EDGE (e, ei, b->preds)\n-\t    if (e->flags & EDGE_ABNORMAL)\n-\t      break;\n-\n-\t  if (e != NULL)\n-\t    {\n-#ifdef STACK_REGS\n-\t      EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, ax,\n-\t\t\t\t\t     {\n-\t\t\t\t\t       allocno[ax].no_stack_reg = 1;\n-\t\t\t\t\t     });\n-\t      for (ax = FIRST_STACK_REG; ax <= LAST_STACK_REG; ax++)\n-\t\trecord_one_conflict (ax);\n-#endif\n-\n-\t      /* No need to record conflicts for call clobbered regs if we have\n-\t\t nonlocal labels around, as we don't ever try to allocate such\n-\t\t regs in this case.  */\n-\t      if (! current_function_has_nonlocal_label)\n-\t\tfor (ax = 0; ax < FIRST_PSEUDO_REGISTER; ax++)\n-\t\t  if (call_used_regs [ax])\n-\t\t    record_one_conflict (ax);\n-\t    }\n-\t}\n-      }\n-\n-      insn = BB_HEAD (b);\n-\n-      /* Scan the code of this basic block, noting which allocnos\n-\t and hard regs are born or die.  When one is born,\n-\t record a conflict with all others currently live.  */\n-\n-      while (1)\n-\t{\n-\t  RTX_CODE code = GET_CODE (insn);\n-\t  rtx link;\n-\n-\t  gcc_assert (VEC_empty (rtx, regs_set));\n-\t  if (code == INSN || code == CALL_INSN || code == JUMP_INSN)\n-\t    {\n-#if 0\n-\t      int i = 0;\n-\t      for (link = REG_NOTES (insn);\n-\t\t   link && i < NUM_NO_CONFLICT_PAIRS;\n-\t\t   link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_NO_CONFLICT)\n-\t\t  {\n-\t\t    no_conflict_pairs[i].allocno1\n-\t\t      = reg_allocno[REGNO (SET_DEST (PATTERN (insn)))];\n-\t\t    no_conflict_pairs[i].allocno2\n-\t\t      = reg_allocno[REGNO (XEXP (link, 0))];\n-\t\t    i++;\n-\t\t  }\n-#endif /* 0 */\n-\n-\t      /* Mark any registers clobbered by INSN as live,\n-\t\t so they conflict with the inputs.  */\n-\n-\t      note_stores (PATTERN (insn), mark_reg_clobber, NULL);\n-\n-#ifdef AUTO_INC_DEC\n-\t      /* Auto-increment instructions clobber the base\n-\t\t register.  */\n-\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_INC)\n-\t\t  mark_reg_store (XEXP (link, 0), NULL_RTX, NULL);\n-#endif\n-\t      /* Mark any registers dead after INSN as dead now.  */\n-\n-\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_DEAD)\n-\t\t  mark_reg_death (XEXP (link, 0));\n-\n-\t      /* Mark any registers set in INSN as live,\n-\t\t and mark them as conflicting with all other live regs.\n-\t\t Clobbers are processed again, so they conflict with\n-\t\t the registers that are set.  */\n-\n-\t      note_stores (PATTERN (insn), mark_reg_store, NULL);\n-\n-\t      /* If INSN has multiple outputs, then any reg that dies here\n-\t\t and is used inside of an output\n-\t\t must conflict with the other outputs.\n-\n-\t\t It is unsafe to use !single_set here since it will ignore an\n-\t\t unused output.  Just because an output is unused does not mean\n-\t\t the compiler can assume the side effect will not occur.\n-\t\t Consider if REG appears in the address of an output and we\n-\t\t reload the output.  If we allocate REG to the same hard\n-\t\t register as an unused output we could set the hard register\n-\t\t before the output reload insn.  */\n-\t      if (GET_CODE (PATTERN (insn)) == PARALLEL && multiple_sets (insn))\n-\t\tfor (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t\t  if (REG_NOTE_KIND (link) == REG_DEAD)\n-\t\t    {\n-\t\t      int used_in_output = 0;\n-\t\t      int i;\n-\t\t      rtx reg = XEXP (link, 0);\n-\n-\t\t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t\t\t{\n-\t\t\t  rtx set = XVECEXP (PATTERN (insn), 0, i);\n-\t\t\t  if (GET_CODE (set) == SET\n-\t\t\t      && !REG_P (SET_DEST (set))\n-\t\t\t      && !rtx_equal_p (reg, SET_DEST (set))\n-\t\t\t      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-\t\t\t    used_in_output = 1;\n-\t\t\t}\n-\t\t      if (used_in_output)\n-\t\t\tmark_reg_conflicts (reg);\n-\t\t    }\n-\n-\t      /* Mark any registers set in INSN and then never used.  */\n-\n-\t      while (!VEC_empty (rtx, regs_set))\n-\t\t{\n-\t\t  rtx reg = VEC_pop (rtx, regs_set);\n-\t\t  rtx note = find_regno_note (insn, REG_UNUSED,\n-\t\t\t\t\t      REGNO (reg));\n-\t\t  if (note)\n-\t\t    mark_reg_death (XEXP (note, 0));\n-\t\t}\n-\t    }\n-\n-\t  if (insn == BB_END (b))\n-\t    break;\n-\t  insn = NEXT_INSN (insn);\n-\t}\n-    }\n-\n-  /* Clean up.  */\n-  free (block_start_allocnos);\n-}\n-\n /* Expand the preference information by looking for cases where one allocno\n    dies in an insn that sets an allocno.  If those two allocnos don't conflict,\n    merge any preferences between those allocnos.  */\n@@ -999,6 +633,150 @@ expand_preferences (void)\n \t\t\t      allocno[a1].hard_reg_full_preferences);\n \t  }\n }\n+\n+\n+/* Try to set a preference for an allocno to a hard register.\n+   We are passed DEST and SRC which are the operands of a SET.  It is known\n+   that SRC is a register.  If SRC or the first operand of SRC is a register,\n+   try to set a preference.  If one of the two is a hard register and the other\n+   is a pseudo-register, mark the preference.\n+\n+   Note that we are not as aggressive as local-alloc in trying to tie a\n+   pseudo-register to a hard register.  */\n+\n+static void\n+set_preference (rtx dest, rtx src)\n+{\n+  unsigned int src_regno, dest_regno, end_regno;\n+  /* Amount to add to the hard regno for SRC, or subtract from that for DEST,\n+     to compensate for subregs in SRC or DEST.  */\n+  int offset = 0;\n+  unsigned int i;\n+  int copy = 1;\n+\n+  if (GET_RTX_FORMAT (GET_CODE (src))[0] == 'e')\n+    src = XEXP (src, 0), copy = 0;\n+\n+  /* Get the reg number for both SRC and DEST.\n+     If neither is a reg, give up.  */\n+\n+  if (REG_P (src))\n+    src_regno = REGNO (src);\n+  else if (GET_CODE (src) == SUBREG && REG_P (SUBREG_REG (src)))\n+    {\n+      src_regno = REGNO (SUBREG_REG (src));\n+\n+      if (REGNO (SUBREG_REG (src)) < FIRST_PSEUDO_REGISTER)\n+\toffset += subreg_regno_offset (REGNO (SUBREG_REG (src)),\n+\t\t\t\t       GET_MODE (SUBREG_REG (src)),\n+\t\t\t\t       SUBREG_BYTE (src),\n+\t\t\t\t       GET_MODE (src));\n+      else\n+\toffset += (SUBREG_BYTE (src)\n+\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (src)));\n+    }\n+  else\n+    return;\n+\n+  if (REG_P (dest))\n+    dest_regno = REGNO (dest);\n+  else if (GET_CODE (dest) == SUBREG && REG_P (SUBREG_REG (dest)))\n+    {\n+      dest_regno = REGNO (SUBREG_REG (dest));\n+\n+      if (REGNO (SUBREG_REG (dest)) < FIRST_PSEUDO_REGISTER)\n+\toffset -= subreg_regno_offset (REGNO (SUBREG_REG (dest)),\n+\t\t\t\t       GET_MODE (SUBREG_REG (dest)),\n+\t\t\t\t       SUBREG_BYTE (dest),\n+\t\t\t\t       GET_MODE (dest));\n+      else\n+\toffset -= (SUBREG_BYTE (dest)\n+\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (dest)));\n+    }\n+  else\n+    return;\n+\n+  /* Convert either or both to hard reg numbers.  */\n+\n+  if (reg_renumber[src_regno] >= 0)\n+    src_regno = reg_renumber[src_regno];\n+\n+  if (reg_renumber[dest_regno] >= 0)\n+    dest_regno = reg_renumber[dest_regno];\n+\n+  /* Now if one is a hard reg and the other is a global pseudo\n+     then give the other a preference.  */\n+\n+  if (dest_regno < FIRST_PSEUDO_REGISTER && src_regno >= FIRST_PSEUDO_REGISTER\n+      && reg_allocno[src_regno] >= 0)\n+    {\n+      dest_regno -= offset;\n+      if (dest_regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  if (copy)\n+\t    SET_REGBIT (hard_reg_copy_preferences,\n+\t\t\treg_allocno[src_regno], dest_regno);\n+\n+\t  SET_REGBIT (hard_reg_preferences,\n+\t\t      reg_allocno[src_regno], dest_regno);\n+\t  end_regno = end_hard_regno (GET_MODE (dest), dest_regno);\n+\t  for (i = dest_regno; i < end_regno; i++)\n+\t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[src_regno], i);\n+\t}\n+    }\n+\n+  if (src_regno < FIRST_PSEUDO_REGISTER && dest_regno >= FIRST_PSEUDO_REGISTER\n+      && reg_allocno[dest_regno] >= 0)\n+    {\n+      src_regno += offset;\n+      if (src_regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  if (copy)\n+\t    SET_REGBIT (hard_reg_copy_preferences,\n+\t\t\treg_allocno[dest_regno], src_regno);\n+\n+\t  SET_REGBIT (hard_reg_preferences,\n+\t\t      reg_allocno[dest_regno], src_regno);\n+\t  end_regno = end_hard_regno (GET_MODE (src), src_regno);\n+\t  for (i = src_regno; i < end_regno; i++)\n+\t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[dest_regno], i);\n+\t}\n+    }\n+}\n+\f\n+/* Helper function for set_preferences.  */\n+static void\n+set_preferences_1 (rtx reg, const_rtx setter, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (!REG_P (reg))\n+    return;\n+\n+  gcc_assert (setter);\n+  if (GET_CODE (setter) != CLOBBER)\n+    set_preference (reg, SET_SRC (setter));\n+}\n+\f\n+/* Scan all of the insns and initialize the preferences.  */\n+\n+static void \n+set_preferences (void)\n+{\n+  basic_block bb;\n+  rtx insn;\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS_REVERSE (bb, insn)\n+      {\n+\tif (!INSN_P (insn))\n+\t  continue;\t\n+\n+\tnote_stores (PATTERN (insn), set_preferences_1, NULL);\n+      }\n+}\n+\n+\n \f\n /* Prune the preferences for global registers to exclude registers that cannot\n    be used.\n@@ -1446,62 +1224,16 @@ retry_global_alloc (int regno, HARD_REG_SET forbidden_regs)\n     }\n }\n \f\n-/* Record a conflict between register REGNO\n-   and everything currently live.\n-   REGNO must not be a pseudo reg that was allocated\n-   by local_alloc; such numbers must be translated through\n-   reg_renumber before calling here.  */\n-\n+/* If CONFLICTP (i, j) is true, make sure CONFLICTP (j, i) is also true.  */\n static void\n-record_one_conflict (int regno)\n-{\n-  int j;\n-\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    /* When a hard register becomes live,\n-       record conflicts with live pseudo regs.  */\n-    EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, j,\n-      {\n-\tSET_HARD_REG_BIT (allocno[j].hard_reg_conflicts, regno);\n-      });\n-  else\n-    /* When a pseudo-register becomes live,\n-       record conflicts first with hard regs,\n-       then with other pseudo regs.  */\n-    {\n-      int ialloc = reg_allocno[regno];\n-      int ialloc_prod = ialloc * allocno_row_words;\n-\n-      IOR_HARD_REG_SET (allocno[ialloc].hard_reg_conflicts, hard_regs_live);\n-      for (j = allocno_row_words - 1; j >= 0; j--)\n-\tconflicts[ialloc_prod + j] |= allocnos_live[j];\n-    }\n-}\n-\n-/* Record all allocnos currently live as conflicting\n-   with all hard regs currently live.\n-\n-   ALLOCNO_VEC is a vector of LEN allocnos, all allocnos that\n-   are currently live.  Their bits are also flagged in allocnos_live.  */\n-\n-static void\n-record_conflicts (int *allocno_vec, int len)\n-{\n-  while (--len >= 0)\n-    IOR_HARD_REG_SET (allocno[allocno_vec[len]].hard_reg_conflicts,\n-                      hard_regs_live);\n-}\n-\n-/* If CONFLICTP (i, j) is true, make sure CONFLICTP (j, i) is also true.  */\n-static void\n-mirror_conflicts (void)\n+mirror_conflicts (void)\n {\n   int i, j;\n   int rw = allocno_row_words;\n-  int rwb = rw * INT_BITS;\n-  INT_TYPE *p = conflicts;\n-  INT_TYPE *q0 = conflicts, *q1, *q2;\n-  unsigned INT_TYPE mask;\n+  int rwb = rw * HOST_BITS_PER_WIDE_INT;\n+  HOST_WIDE_INT *p = conflicts;\n+  HOST_WIDE_INT *q0 = conflicts, *q1, *q2;\n+  unsigned HOST_WIDE_INT mask;\n \n   for (i = max_allocno - 1, mask = 1; i >= 0; i--, mask <<= 1)\n     {\n@@ -1512,9 +1244,9 @@ mirror_conflicts (void)\n \t}\n       for (j = allocno_row_words - 1, q1 = q0; j >= 0; j--, q1 += rwb)\n \t{\n-\t  unsigned INT_TYPE word;\n+\t  unsigned HOST_WIDE_INT word;\n \n-\t  for (word = (unsigned INT_TYPE) *p++, q2 = q1; word;\n+\t  for (word = (unsigned HOST_WIDE_INT) *p++, q2 = q1; word;\n \t       word >>= 1, q2 += rw)\n \t    {\n \t      if (word & 1)\n@@ -1524,252 +1256,6 @@ mirror_conflicts (void)\n     }\n }\n \f\n-/* Handle the case where REG is set by the insn being scanned,\n-   during the forward scan to accumulate conflicts.\n-   Store a 1 in regs_live or allocnos_live for this register, record how many\n-   consecutive hardware registers it actually needs,\n-   and record a conflict with all other registers already live.\n-\n-   Note that even if REG does not remain alive after this insn,\n-   we must mark it here as live, to ensure a conflict between\n-   REG and any other regs set in this insn that really do live.\n-   This is because those other regs could be considered after this.\n-\n-   REG might actually be something other than a register;\n-   if so, we do nothing.\n-\n-   SETTER is 0 if this register was modified by an auto-increment (i.e.,\n-   a REG_INC note was found for it).  */\n-\n-static void\n-mark_reg_store (rtx reg, const_rtx setter, void *data ATTRIBUTE_UNUSED)\n-{\n-  int regno;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-\n-  if (!REG_P (reg))\n-    return;\n-\n-  VEC_safe_push (rtx, heap, regs_set, reg);\n-\n-  if (setter && GET_CODE (setter) != CLOBBER)\n-    set_preference (reg, SET_SRC (setter));\n-\n-  regno = REGNO (reg);\n-\n-  /* Either this is one of the max_allocno pseudo regs not allocated,\n-     or it is or has a hardware reg.  First handle the pseudo-regs.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (reg_allocno[regno] >= 0)\n-\t{\n-\t  SET_ALLOCNO_LIVE (reg_allocno[regno]);\n-\t  record_one_conflict (regno);\n-\t}\n-    }\n-\n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno];\n-\n-  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n-    {\n-      int last = end_hard_regno (GET_MODE (reg), regno);\n-      while (regno < last)\n-\t{\n-\t  record_one_conflict (regno);\n-\t  SET_HARD_REG_BIT (hard_regs_live, regno);\n-\t  regno++;\n-\t}\n-    }\n-}\n-\f\n-/* Like mark_reg_store except notice just CLOBBERs; ignore SETs.  */\n-\n-static void\n-mark_reg_clobber (rtx reg, const_rtx setter, void *data)\n-{\n-  if (GET_CODE (setter) == CLOBBER)\n-    mark_reg_store (reg, setter, data);\n-}\n-\n-/* Record that REG has conflicts with all the regs currently live.\n-   Do not mark REG itself as live.  */\n-\n-static void\n-mark_reg_conflicts (rtx reg)\n-{\n-  int regno;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-\n-  if (!REG_P (reg))\n-    return;\n-\n-  regno = REGNO (reg);\n-\n-  /* Either this is one of the max_allocno pseudo regs not allocated,\n-     or it is or has a hardware reg.  First handle the pseudo-regs.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (reg_allocno[regno] >= 0)\n-\trecord_one_conflict (regno);\n-    }\n-\n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno];\n-\n-  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n-    {\n-      int last = end_hard_regno (GET_MODE (reg), regno);\n-      while (regno < last)\n-\t{\n-\t  record_one_conflict (regno);\n-\t  regno++;\n-\t}\n-    }\n-}\n-\f\n-/* Mark REG as being dead (following the insn being scanned now).\n-   Store a 0 in regs_live or allocnos_live for this register.  */\n-\n-static void\n-mark_reg_death (rtx reg)\n-{\n-  int regno = REGNO (reg);\n-\n-  /* Either this is one of the max_allocno pseudo regs not allocated,\n-     or it is a hardware reg.  First handle the pseudo-regs.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (reg_allocno[regno] >= 0)\n-\tCLEAR_ALLOCNO_LIVE (reg_allocno[regno]);\n-    }\n-\n-  /* For pseudo reg, see if it has been assigned a hardware reg.  */\n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno];\n-\n-  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n-    /* Pseudo regs already assigned hardware regs are treated\n-       almost the same as explicit hardware regs.  */\n-    remove_from_hard_reg_set (&hard_regs_live, GET_MODE (reg), regno);\n-}\n-\f\n-/* Try to set a preference for an allocno to a hard register.\n-   We are passed DEST and SRC which are the operands of a SET.  It is known\n-   that SRC is a register.  If SRC or the first operand of SRC is a register,\n-   try to set a preference.  If one of the two is a hard register and the other\n-   is a pseudo-register, mark the preference.\n-\n-   Note that we are not as aggressive as local-alloc in trying to tie a\n-   pseudo-register to a hard register.  */\n-\n-static void\n-set_preference (rtx dest, rtx src)\n-{\n-  unsigned int src_regno, dest_regno, end_regno;\n-  /* Amount to add to the hard regno for SRC, or subtract from that for DEST,\n-     to compensate for subregs in SRC or DEST.  */\n-  int offset = 0;\n-  unsigned int i;\n-  int copy = 1;\n-\n-  if (GET_RTX_FORMAT (GET_CODE (src))[0] == 'e')\n-    src = XEXP (src, 0), copy = 0;\n-\n-  /* Get the reg number for both SRC and DEST.\n-     If neither is a reg, give up.  */\n-\n-  if (REG_P (src))\n-    src_regno = REGNO (src);\n-  else if (GET_CODE (src) == SUBREG && REG_P (SUBREG_REG (src)))\n-    {\n-      src_regno = REGNO (SUBREG_REG (src));\n-\n-      if (REGNO (SUBREG_REG (src)) < FIRST_PSEUDO_REGISTER)\n-\toffset += subreg_regno_offset (REGNO (SUBREG_REG (src)),\n-\t\t\t\t       GET_MODE (SUBREG_REG (src)),\n-\t\t\t\t       SUBREG_BYTE (src),\n-\t\t\t\t       GET_MODE (src));\n-      else\n-\toffset += (SUBREG_BYTE (src)\n-\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (src)));\n-    }\n-  else\n-    return;\n-\n-  if (REG_P (dest))\n-    dest_regno = REGNO (dest);\n-  else if (GET_CODE (dest) == SUBREG && REG_P (SUBREG_REG (dest)))\n-    {\n-      dest_regno = REGNO (SUBREG_REG (dest));\n-\n-      if (REGNO (SUBREG_REG (dest)) < FIRST_PSEUDO_REGISTER)\n-\toffset -= subreg_regno_offset (REGNO (SUBREG_REG (dest)),\n-\t\t\t\t       GET_MODE (SUBREG_REG (dest)),\n-\t\t\t\t       SUBREG_BYTE (dest),\n-\t\t\t\t       GET_MODE (dest));\n-      else\n-\toffset -= (SUBREG_BYTE (dest)\n-\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (dest)));\n-    }\n-  else\n-    return;\n-\n-  /* Convert either or both to hard reg numbers.  */\n-\n-  if (reg_renumber[src_regno] >= 0)\n-    src_regno = reg_renumber[src_regno];\n-\n-  if (reg_renumber[dest_regno] >= 0)\n-    dest_regno = reg_renumber[dest_regno];\n-\n-  /* Now if one is a hard reg and the other is a global pseudo\n-     then give the other a preference.  */\n-\n-  if (dest_regno < FIRST_PSEUDO_REGISTER && src_regno >= FIRST_PSEUDO_REGISTER\n-      && reg_allocno[src_regno] >= 0)\n-    {\n-      dest_regno -= offset;\n-      if (dest_regno < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  if (copy)\n-\t    SET_REGBIT (hard_reg_copy_preferences,\n-\t\t\treg_allocno[src_regno], dest_regno);\n-\n-\t  SET_REGBIT (hard_reg_preferences,\n-\t\t      reg_allocno[src_regno], dest_regno);\n-\t  end_regno = end_hard_regno (GET_MODE (dest), dest_regno);\n-\t  for (i = dest_regno; i < end_regno; i++)\n-\t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[src_regno], i);\n-\t}\n-    }\n-\n-  if (src_regno < FIRST_PSEUDO_REGISTER && dest_regno >= FIRST_PSEUDO_REGISTER\n-      && reg_allocno[dest_regno] >= 0)\n-    {\n-      src_regno += offset;\n-      if (src_regno < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  if (copy)\n-\t    SET_REGBIT (hard_reg_copy_preferences,\n-\t\t\treg_allocno[dest_regno], src_regno);\n-\n-\t  SET_REGBIT (hard_reg_preferences,\n-\t\t      reg_allocno[dest_regno], src_regno);\n-\t  end_regno = end_hard_regno (GET_MODE (src), src_regno);\n-\t  for (i = src_regno; i < end_regno; i++)\n-\t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[dest_regno], i);\n-\t}\n-    }\n-}\n-\f\n /* Indicate that hard register number FROM was eliminated and replaced with\n    an offset from hard register number TO.  The status of hard registers live\n    at the start of a basic block is updated by replacing a use of FROM with\n@@ -1782,7 +1268,7 @@ mark_elimination (int from, int to)\n \n   FOR_EACH_BB (bb)\n     {\n-      regset r = DF_RA_LIVE_IN (bb);\n+      regset r = DF_LIVE_IN (bb);\n       if (REGNO_REG_SET_P (r, from))\n \t{\n \t  CLEAR_REGNO_REG_SET (r, from);\n@@ -1791,174 +1277,239 @@ mark_elimination (int from, int to)\n     }\n }\n \f\n-/* Used for communication between the following functions.  Holds the\n-   current life information.  */\n-static regset live_relevant_regs;\n-\n-/* Record in live_relevant_regs and REGS_SET that register REG became live.\n-   This is called via note_stores.  */\n static void\n-reg_becomes_live (rtx reg, const_rtx setter ATTRIBUTE_UNUSED, void *regs_set)\n+print_insn_chain (FILE *file, struct insn_chain *c)\n {\n-  int regno;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-\n-  if (!REG_P (reg))\n-    return;\n-\n-  regno = REGNO (reg);\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      int nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n-      while (nregs-- > 0)\n-\t{\n-\t  if (GET_CODE (setter) == CLOBBER)\n-\t    CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n-\t  else\n-\t    SET_REGNO_REG_SET (live_relevant_regs, regno);\n-\n-\t  if (!fixed_regs[regno])\n-\t    SET_REGNO_REG_SET ((regset) regs_set, regno);\n-\t  regno++;\n-\t}\n-    }\n-  else if (reg_renumber[regno] >= 0)\n-    {\n-      if (GET_CODE (setter) == CLOBBER)\n-\tCLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n-      else\n-\tSET_REGNO_REG_SET (live_relevant_regs, regno);\n-      SET_REGNO_REG_SET ((regset) regs_set, regno);\n-    }\n+  fprintf (file, \"insn=%d, \", INSN_UID(c->insn));\n+  bitmap_print (file, &c->live_throughout, \"live_throughout: \", \", \");\n+  bitmap_print (file, &c->dead_or_set, \"dead_or_set: \", \"\\n\");\n }\n \n-/* Record in live_relevant_regs that register REGNO died.  */\n static void\n-reg_dies (int regno, enum machine_mode mode, struct insn_chain *chain)\n+print_insn_chains (FILE *file)\n {\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      int nregs = hard_regno_nregs[regno][mode];\n-      while (nregs-- > 0)\n-\t{\n-\t  CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n-\t  if (! fixed_regs[regno])\n-\t    SET_REGNO_REG_SET (&chain->dead_or_set, regno);\n-\t  regno++;\n-\t}\n-    }\n-  else\n-    {\n-      CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n-      if (reg_renumber[regno] >= 0)\n-\tSET_REGNO_REG_SET (&chain->dead_or_set, regno);\n-    }\n+  struct insn_chain *c;\n+  for (c = reload_insn_chain; c ; c = c->next)\n+    print_insn_chain (file, c);\n }\n-\n /* Walk the insns of the current function and build reload_insn_chain,\n    and record register life information.  */\n-void\n-build_insn_chain (rtx first)\n+static void\n+build_insn_chain (void)\n {\n+  unsigned int i;\n   struct insn_chain **p = &reload_insn_chain;\n-  struct insn_chain *prev = 0;\n-  basic_block b = ENTRY_BLOCK_PTR->next_bb;\n+  basic_block bb;\n+  struct insn_chain *c = NULL;\n+  struct insn_chain *next = NULL;\n+  bitmap live_relevant_regs = BITMAP_ALLOC (NULL);\n+  bitmap elim_regset = BITMAP_ALLOC (NULL);\n+  /* live_subregs is a vector used to keep accurate information about\n+     which hardregs are live in multiword pseudos.  live_subregs and\n+     live_subregs_used are indexed by pseudo number.  The live_subreg\n+     entry for a particular pseudo is only used if the corresponding\n+     element is non zero in live_subregs_used.  The value in\n+     live_subregs_used is number of bytes that the pseudo can\n+     occupy.  */\n+  sbitmap *live_subregs = XCNEWVEC (sbitmap, max_regno);\n+  int *live_subregs_used = XNEWVEC (int, max_regno);\n \n-  live_relevant_regs = ALLOC_REG_SET (&reg_obstack);\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (eliminable_regset, i))\n+      bitmap_set_bit (elim_regset, i);\n \n-  for (; first; first = NEXT_INSN (first))\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      struct insn_chain *c;\n-\n-      if (first == BB_HEAD (b))\n+      bitmap_iterator bi;\n+      rtx insn;\n+      \n+      CLEAR_REG_SET (live_relevant_regs);\n+      memset (live_subregs_used, 0, max_regno * sizeof (int));\n+      \n+      EXECUTE_IF_SET_IN_BITMAP (df_get_live_out (bb), 0, i, bi)\n \t{\n-\t  unsigned i;\n-\t  bitmap_iterator bi;\n-\n-\t  CLEAR_REG_SET (live_relevant_regs);\n-\n-\t  EXECUTE_IF_SET_IN_BITMAP (df_get_live_top (b), 0, i, bi)\n-\t    {\n-\t      if (i < FIRST_PSEUDO_REGISTER\n-\t\t  ? ! TEST_HARD_REG_BIT (eliminable_regset, i)\n-\t\t  : reg_renumber[i] >= 0)\n-\t\tSET_REGNO_REG_SET (live_relevant_regs, i);\n-\t    }\n+\t  if (i >= FIRST_PSEUDO_REGISTER)\n+\t    break;\n+\t  bitmap_set_bit (live_relevant_regs, i);\n \t}\n \n-      if (!NOTE_P (first) && !BARRIER_P (first))\n+      EXECUTE_IF_SET_IN_BITMAP (df_get_live_out (bb), FIRST_PSEUDO_REGISTER, i, bi)\n \t{\n-\t  c = new_insn_chain ();\n-\t  c->prev = prev;\n-\t  prev = c;\n-\t  *p = c;\n-\t  p = &c->next;\n-\t  c->insn = first;\n-\t  c->block = b->index;\n-\n-\t  if (INSN_P (first))\n-\t    {\n-\t      rtx link;\n-\n-\t      /* Mark the death of everything that dies in this instruction.  */\n-\n-\t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_DEAD\n-\t\t    && REG_P (XEXP (link, 0)))\n-\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)),\n-\t\t\t    c);\n-\n-\t      COPY_REG_SET (&c->live_throughout, live_relevant_regs);\n-\n-\t      /* Mark everything born in this instruction as live.  */\n-\n-\t      note_stores (PATTERN (first), reg_becomes_live,\n-\t\t\t   &c->dead_or_set);\n-\t    }\n-\t  else\n-\t    COPY_REG_SET (&c->live_throughout, live_relevant_regs);\n+\t  if (reg_renumber[i] >= 0)\n+\t    bitmap_set_bit (live_relevant_regs, i);\n+\t}\n \n-\t  if (INSN_P (first))\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+\t{\n+\t  if (!NOTE_P (insn) && !BARRIER_P (insn))\n \t    {\n-\t      rtx link;\n+\t      unsigned int uid = INSN_UID (insn);\n+\t      struct df_ref **def_rec;\n+\t      struct df_ref **use_rec;\n+\n+\t      c = new_insn_chain ();\n+\t      c->next = next;\n+\t      next = c;\n+\t      *p = c;\n+\t      p = &c->prev;\n+\t      \n+\t      c->insn = insn;\n+\t      c->block = bb->index;\n+\n+\t      if (INSN_P (insn))\n+\t\tfor (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t\t  {\n+\t\t    struct df_ref *def = *def_rec;\n+\t\t    unsigned int regno = DF_REF_REGNO (def);\n+\t\t    \n+\t\t    /* Ignore may clobbers because these are generated\n+\t\t       from calls. However, every other kind of def is\n+\t\t       added to dead_or_set.  */\n+\t\t    if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n+\t\t      {\n+\t\t\tif (regno < FIRST_PSEUDO_REGISTER)\n+\t\t\t  {\n+\t\t\t    if (! fixed_regs[regno])\n+\t\t\t      bitmap_set_bit (&c->dead_or_set, regno);\n+\t\t\t  }\n+\t\t\telse if (reg_renumber[regno] >= 0)\n+\t\t\t  bitmap_set_bit (&c->dead_or_set, regno);\n+\t\t      }\n \n-\t      /* Mark anything that is set in this insn and then unused as dying.  */\n+\t\t    if ((regno < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+\t\t\t&& (!DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL)))\n+\t\t      {\n+\t\t\trtx reg = DF_REF_REG (def);\n+\t\t\t/* We can model subregs, but not if they are\n+\t\t\t   wrapped in ZERO_EXTRACTS.  */\n+\t\t\tif (GET_CODE (reg) == SUBREG\n+\t\t\t    && !DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT))\n+\t\t\t  {\n+\t\t\t    unsigned int start = SUBREG_BYTE (reg);\n+\t\t\t    unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n+\n+\t\t\t    ra_init_live_subregs (bitmap_bit_p (live_relevant_regs, regno), \n+\t\t\t\t\t\t  live_subregs, live_subregs_used,\n+\t\t\t\t\t\t  regno, reg);\n+\t\t\t    /* Ignore the paradoxical bits.  */\n+\t\t\t    if ((int)last > live_subregs_used[regno])\n+\t\t\t      last = live_subregs_used[regno];\n+\n+\t\t\t    while (start < last)\n+\t\t\t      {\n+\t\t\t\tRESET_BIT (live_subregs[regno], start);\n+\t\t\t\tstart++;\n+\t\t\t      }\n+\t\t\t    \n+\t\t\t    if (sbitmap_empty_p (live_subregs[regno]))\n+\t\t\t      {\n+\t\t\t\tlive_subregs_used[regno] = 0;\n+\t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      /* Set live_relevant_regs here because\n+\t\t\t\t that bit has to be true to get us to\n+\t\t\t\t look at the live_subregs fields.  */\n+\t\t\t      bitmap_set_bit (live_relevant_regs, regno);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    /* DF_REF_PARTIAL is generated for\n+\t\t\t       subregs, STRICT_LOW_PART, and\n+\t\t\t       ZERO_EXTRACT.  We handle the subreg\n+\t\t\t       case above so here we have to keep from\n+\t\t\t       modeling the def as a killing def.  */\n+\t\t\t    if (!DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL))\n+\t\t\t      {\n+\t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);\n+\t\t\t\tlive_subregs_used[regno] = 0;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n+\t  \n+\t      bitmap_and_compl_into (live_relevant_regs, elim_regset);\n+\t      bitmap_copy (&c->live_throughout, live_relevant_regs);\n \n-\t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_UNUSED\n-\t\t    && REG_P (XEXP (link, 0)))\n-\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)),\n-\t\t\t    c);\n+\t      if (INSN_P (insn))\n+\t\tfor (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t\t  {\n+\t\t    struct df_ref *use = *use_rec;\n+\t\t    unsigned int regno = DF_REF_REGNO (use);\n+\t\t    rtx reg = DF_REF_REG (use);\n+\t\t    \n+\t\t    /* DF_REF_READ_WRITE on a use means that this use\n+\t\t       is fabricated from a def that is a partial set\n+\t\t       to a multiword reg.  Here, we only model the\n+\t\t       subreg case that is not wrapped in ZERO_EXTRACT\n+\t\t       precisely so we do not need to look at the\n+\t\t       fabricated use. */\n+\t\t    if (DF_REF_FLAGS_IS_SET (use, DF_REF_READ_WRITE) \n+\t\t\t&& !DF_REF_FLAGS_IS_SET (use, DF_REF_EXTRACT) \n+\t\t\t&& DF_REF_FLAGS_IS_SET (use, DF_REF_SUBREG))\n+\t\t      continue;\n+\t\t    \n+\t\t    /* Add the last use of each var to dead_or_set.  */\n+\t\t    if (!bitmap_bit_p (live_relevant_regs, regno))\n+\t\t      {\n+\t\t\tif (regno < FIRST_PSEUDO_REGISTER)\n+\t\t\t  {\n+\t\t\t    if (! fixed_regs[regno])\n+\t\t\t      bitmap_set_bit (&c->dead_or_set, regno);\n+\t\t\t  }\n+\t\t\telse if (reg_renumber[regno] >= 0)\n+\t\t\t  bitmap_set_bit (&c->dead_or_set, regno);\n+\t\t      }\n+\t\t    \n+\t\t    if (regno < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+\t\t      {\n+\t\t\tif (GET_CODE (reg) == SUBREG\n+\t\t\t    && !DF_REF_FLAGS_IS_SET (use, DF_REF_EXTRACT)) \n+\t\t\t  {\n+\t\t\t    unsigned int start = SUBREG_BYTE (reg);\n+\t\t\t    unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n+\t\t\t    \n+\t\t\t    ra_init_live_subregs (bitmap_bit_p (live_relevant_regs, regno), \n+\t\t\t\t\t\t  live_subregs, live_subregs_used,\n+\t\t\t\t\t\t  regno, reg);\n+\t\t\t    \n+\t\t\t    /* Ignore the paradoxical bits.  */\n+\t\t\t    if ((int)last > live_subregs_used[regno])\n+\t\t\t      last = live_subregs_used[regno];\n+\n+\t\t\t    while (start < last)\n+\t\t\t      {\n+\t\t\t\tSET_BIT (live_subregs[regno], start);\n+\t\t\t\tstart++;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  /* Resetting the live_subregs_used is\n+\t\t\t     effectively saying do not use the subregs\n+\t\t\t     because we are reading the whole\n+\t\t\t     pseudo.  */\n+\t\t\t  live_subregs_used[regno] = 0;\n+\t\t\tbitmap_set_bit (live_relevant_regs, regno);\n+\t\t      }\n+\t\t  }\n \t    }\n \t}\n+    }\n \n-      if (first == BB_END (b))\n-\tb = b->next_bb;\n+  for (i = 0; i < (unsigned int)max_regno; i++)\n+    if (live_subregs[i])\n+      free (live_subregs[i]);\n \n-      /* Stop after we pass the end of the last basic block.  Verify that\n-\t no real insns are after the end of the last basic block.\n+  reload_insn_chain = c;\n+  *p = NULL;\n \n-\t We may want to reorganize the loop somewhat since this test should\n-\t always be the right exit test.  Allow an ADDR_VEC or ADDR_DIF_VEC if\n-\t the previous real insn is a JUMP_INSN.  */\n-      if (b == EXIT_BLOCK_PTR)\n-\t{\n-#ifdef ENABLE_CHECKING\n-\t  for (first = NEXT_INSN (first); first; first = NEXT_INSN (first))\n-\t    gcc_assert (!INSN_P (first)\n-\t\t\t|| GET_CODE (PATTERN (first)) == USE\n-\t\t\t|| ((GET_CODE (PATTERN (first)) == ADDR_VEC\n-\t\t\t     || GET_CODE (PATTERN (first)) == ADDR_DIFF_VEC)\n-\t\t\t    && prev_real_insn (first) != 0\n-\t\t\t    && JUMP_P (prev_real_insn (first))));\n-#endif\n-\t  break;\n-\t}\n-    }\n-  FREE_REG_SET (live_relevant_regs);\n-  *p = 0;\n+  free (live_subregs);\n+  free (live_subregs_used);\n+  BITMAP_FREE (live_relevant_regs);\n+  BITMAP_FREE (elim_regset);\n+\n+  if (dump_file)\n+    print_insn_chains (dump_file);\n }\n \f\n /* Print debugging trace information if -dg switch is given,\n@@ -2001,7 +1552,7 @@ dump_conflicts (FILE *file)\n \tif (CONFLICTP (j, i))\n \t  fprintf (file, \" %d\", allocno[j].reg);\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (allocno[i].hard_reg_conflicts, j))\n+\tif (TEST_HARD_REG_BIT (allocno[i].hard_reg_conflicts, j) && ! fixed_regs[j])\n \t  fprintf (file, \" %d\", j);\n       fprintf (file, \"\\n\");\n \n@@ -2055,8 +1606,13 @@ rest_of_handle_global_alloc (void)\n     failure = global_alloc ();\n   else\n     {\n+      /* There is just too much going on in the register allocators to\n+\t keep things up to date.  At the end we have to rescan anyway\n+\t because things change when the reload_completed flag is set.  \n+\t So we just turn off scanning and we will rescan by hand.  */\n+      df_set_flags (DF_NO_INSN_RESCAN);\n       compute_regsets (&eliminable_regset, &no_global_alloc_regs);\n-      build_insn_chain (get_insns ());\n+      build_insn_chain ();\n       df_set_flags (DF_NO_INSN_RESCAN);\n       failure = reload (get_insns (), 0);\n     }"}, {"sha": "21030fdd2dfeca37b4e02564c729df8642923467", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -380,7 +380,7 @@ hard_reg_set_empty_p (const HARD_REG_SET x)\n   return x[0] == 0 && x[1] == 0 && x[2] == 0 && x[3] == 0;\n }\n \n-#else /* FIRST_PSEUDO_REGISTER > 3*HOST_BITS_PER_WIDEST_FAST_INT */\n+#else /* FIRST_PSEUDO_REGISTER > 4*HOST_BITS_PER_WIDEST_FAST_INT */\n \n #define CLEAR_HARD_REG_SET(TO)  \\\n do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\"}, {"sha": "b835de07513fd3302f36c7909790e49853a21ce0", "filename": "gcc/init-regs.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -117,7 +117,11 @@ initialize_uninitialized_regs (void)\n     }\n \n   if (optimize == 1)\n-    df_remove_problem (df_live);\n+    {\n+      if (dump_file) \n+\tdf_dump (dump_file);\n+      df_remove_problem (df_live);\n+    }\n \n   BITMAP_FREE (already_genned);\n }"}, {"sha": "4ef1f021f03404e2ca2f3632a89cad94fc1fcb3b", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 68, "deletions": 20, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -1211,13 +1211,9 @@ update_equiv_regs (void)\n   if (!bitmap_empty_p (cleared_regs))\n     FOR_EACH_BB (bb)\n       {\n-\tbitmap_and_compl_into (DF_RA_LIVE_IN (bb), cleared_regs);\n-\tif (DF_RA_LIVE_TOP (bb))\n-\t  bitmap_and_compl_into (DF_RA_LIVE_TOP (bb), cleared_regs);\n-\tbitmap_and_compl_into (DF_RA_LIVE_OUT (bb), cleared_regs);\n+\tbitmap_and_compl_into (DF_LIVE_IN (bb), cleared_regs);\n+\tbitmap_and_compl_into (DF_LIVE_OUT (bb), cleared_regs);\n \tbitmap_and_compl_into (DF_LR_IN (bb), cleared_regs);\n-\tif (DF_LR_TOP (bb))\n-\t  bitmap_and_compl_into (DF_LR_TOP (bb), cleared_regs);\n \tbitmap_and_compl_into (DF_LR_OUT (bb), cleared_regs);\n       }\n \n@@ -1277,6 +1273,7 @@ block_alloc (int b)\n   int max_uid = get_max_uid ();\n   int *qty_order;\n   int no_conflict_combined_regno = -1;\n+  struct df_ref ** def_rec;\n \n   /* Count the instructions in the basic block.  */\n \n@@ -1299,7 +1296,19 @@ block_alloc (int b)\n \n   /* Initialize table of hardware registers currently live.  */\n \n-  REG_SET_TO_HARD_REG_SET (regs_live, DF_LR_TOP (BASIC_BLOCK (b)));\n+  REG_SET_TO_HARD_REG_SET (regs_live, DF_LR_IN (BASIC_BLOCK (b)));\n+\n+  /* This is conservative, as this would include registers that are\n+     artificial-def'ed-but-not-used.  However, artificial-defs are\n+     rare, and such uninitialized use is rarer still, and the chance\n+     of this having any performance impact is even less, while the\n+     benefit is not having to compute and keep the TOP set around.  */\n+  for (def_rec = df_get_artificial_defs (b); *def_rec; def_rec++)\n+    {\n+      int regno = DF_REF_REGNO (*def_rec);\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\tSET_HARD_REG_BIT (regs_live, regno);\n+    }\n \n   /* This loop scans the instructions of the basic block\n      and assigns quantities to registers.\n@@ -2502,6 +2511,49 @@ dump_local_alloc (FILE *file)\n       fprintf (file, \";; Register %d in %d.\\n\", i, reg_renumber[i]);\n }\n \n+#ifdef STACK_REGS\n+static void\n+find_stack_regs (void)\n+{\n+  bitmap stack_regs = BITMAP_ALLOC (NULL);\n+  int i;\n+  HARD_REG_SET stack_hard_regs, used;\n+  basic_block bb;\n+  \n+  /* Any register that MAY be allocated to a register stack (like the\n+     387) is treated poorly.  Each such register is marked as being\n+     live everywhere.  This keeps the register allocator and the\n+     subsequent passes from doing anything useful with these values.\n+\n+     FIXME: This seems like an incredibly poor idea.  */\n+\n+  CLEAR_HARD_REG_SET (stack_hard_regs);\n+  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+    SET_HARD_REG_BIT (stack_hard_regs, i);\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    {\n+      COPY_HARD_REG_SET (used, reg_class_contents[reg_preferred_class (i)]);\n+      IOR_HARD_REG_SET (used, reg_class_contents[reg_alternate_class (i)]);\n+      AND_HARD_REG_SET (used, stack_hard_regs);\n+      if (!hard_reg_set_empty_p (used))\n+\tbitmap_set_bit (stack_regs, i);\n+    }\n+\n+  if (dump_file)\n+    bitmap_print (dump_file, stack_regs, \"stack regs:\", \"\\n\");\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bitmap_ior_into (DF_LIVE_IN (bb), stack_regs);\n+      bitmap_and_into (DF_LIVE_IN (bb), DF_LR_IN (bb));\n+      bitmap_ior_into (DF_LIVE_OUT (bb), stack_regs);\n+      bitmap_and_into (DF_LIVE_OUT (bb), DF_LR_OUT (bb));\n+    }\n+  BITMAP_FREE (stack_regs);\n+}\n+#endif\n+\n /* Run old register allocator.  Return TRUE if we must exit\n    rest_of_compilation upon return.  */\n static unsigned int\n@@ -2512,26 +2564,22 @@ rest_of_handle_local_alloc (void)\n \n   df_note_add_problem ();\n \n-  if (optimize > 1)\n-    df_remove_problem (df_live);\n-  /* Create a new version of df that has the special version of UR if\n-     we are doing optimization.  */\n-  if (optimize)\n-    df_urec_add_problem ();\n+  if (optimize == 1)\n+    {\n+      df_live_add_problem ();\n+      df_live_set_all_dirty ();\n+    }\n #ifdef ENABLE_CHECKING\n   df->changeable_flags |= DF_VERIFY_SCHEDULED;\n #endif\n   df_analyze ();\n+#ifdef STACK_REGS\n+  if (optimize)\n+    find_stack_regs ();\n+#endif\n   regstat_init_n_sets_and_refs ();\n   regstat_compute_ri ();\n \n-  /* There is just too much going on in the register allocators to\n-     keep things up to date.  At the end we have to rescan anyway\n-     because things change when the reload_completed flag is set.  \n-     So we just turn off scanning and we will rescan by hand.  */\n-  df_set_flags (DF_NO_INSN_RESCAN);\n-\n-\n   /* If we are not optimizing, then this is the only place before\n      register allocation where dataflow is done.  And that is needed\n      to generate these warnings.  */"}, {"sha": "cd983ba8a4cad23d941e2db21163bf0f8e2a80f2", "filename": "gcc/ra-conflict.c", "status": "added", "additions": 1120, "deletions": 0, "changes": 1120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -0,0 +1,1120 @@\n+/* Allocate registers for pseudo-registers that span basic blocks.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"machmode.h\"\n+#include \"hard-reg-set.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"flags.h\"\n+#include \"regs.h\"\n+#include \"function.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"reload.h\"\n+#include \"output.h\"\n+#include \"toplev.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n+#include \"df.h\"\n+#include \"vecprim.h\"\n+#include \"ra.h\"\n+#include \"sbitmap.h\"\n+\n+/* Test, set or clear bit number I in allocnos_live,\n+   a bit vector indexed by allocno.  */\n+\n+#define SET_ALLOCNO_LIVE(A, I)\t\t\t\\\n+  ((A)[(unsigned) (I) / HOST_BITS_PER_WIDE_INT]\t\t\t\t\\\n+     |= ((HOST_WIDE_INT) 1 << ((unsigned) (I) % HOST_BITS_PER_WIDE_INT)))\n+\n+#define CLEAR_ALLOCNO_LIVE(A, I)\t\t\\\n+  ((A)[(unsigned) (I) / HOST_BITS_PER_WIDE_INT]\t\t\t\\\n+     &= ~((HOST_WIDE_INT) 1 << ((unsigned) (I) % HOST_BITS_PER_WIDE_INT)))\n+\n+#define GET_ALLOCNO_LIVE(A, I)\t\t\\\n+  ((A)[(unsigned) (I) / HOST_BITS_PER_WIDE_INT]\t\t\t\\\n+     & ((HOST_WIDE_INT) 1 << ((unsigned) (I) % HOST_BITS_PER_WIDE_INT)))\n+\n+/* Externs defined in regs.h.  */\n+\n+int max_allocno;\n+struct allocno *allocno;\n+HOST_WIDE_INT *conflicts;\n+int allocno_row_words;\n+int *reg_allocno;\n+\n+typedef struct df_ref * df_ref_t;\n+DEF_VEC_P(df_ref_t);\n+DEF_VEC_ALLOC_P(df_ref_t,heap);\n+\n+/* Add a conflict between R1 and R2.  */\n+\n+static void\n+record_one_conflict_between_regnos (enum machine_mode mode1, int r1, \n+\t\t\t\t    enum machine_mode mode2, int r2)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"  rocbr adding %d<=>%d\\n\", r1, r2);\n+  if (reg_allocno[r1] >= 0 && reg_allocno[r2] >= 0)\n+    {\n+      int tr1 = reg_allocno[r1];\n+      int tr2 = reg_allocno[r2];\n+      int ialloc_prod = tr1 * allocno_row_words;\n+\n+      SET_ALLOCNO_LIVE ((&conflicts[ialloc_prod]), tr2);\n+    }\n+  else if (reg_allocno[r1] >= 0)\n+    {\n+      int tr1 = reg_allocno[r1];\n+\n+      if (r2 < FIRST_PSEUDO_REGISTER)\n+\tadd_to_hard_reg_set (&allocno[tr1].hard_reg_conflicts, mode2, r2);\n+    }\n+  else if (reg_allocno[r2] >= 0)\n+    {\n+      int tr2 = reg_allocno[r2];\n+\n+      if (r1 < FIRST_PSEUDO_REGISTER)\n+        add_to_hard_reg_set (&allocno[tr2].hard_reg_conflicts, mode1, r1);\n+    }\n+\n+  /* Now, recursively handle the reg_renumber cases.  */\n+  if (reg_renumber[r1] >= 0)\n+    record_one_conflict_between_regnos (mode1, reg_renumber[r1], mode2, r2);\n+\n+  if (reg_renumber[r2] >= 0)\n+    record_one_conflict_between_regnos (mode1, r1, mode2, reg_renumber[r2]);\n+}\n+\n+\n+/* Record a conflict between register REGNO and everything currently\n+   live.  REGNO must not be a pseudo reg that was allocated by\n+   local_alloc; such numbers must be translated through reg_renumber\n+   before calling here.  */\n+\n+static void\n+record_one_conflict (HOST_WIDE_INT *allocnos_live, \n+\t\t     HARD_REG_SET *hard_regs_live, int regno)\n+{\n+  int i;\n+\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    /* When a hard register becomes live, record conflicts with live\n+       pseudo regs.  */\n+    EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+      {\n+\tSET_HARD_REG_BIT (allocno[i].hard_reg_conflicts, regno);\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"  roc adding %d<=>%d\\n\", allocno[i].reg, regno);\n+      });\n+  else\n+    /* When a pseudo-register becomes live, record conflicts first\n+       with hard regs, then with other pseudo regs.  */\n+    {\n+      int ialloc = reg_allocno[regno];\n+      int ialloc_prod = ialloc * allocno_row_words;\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"  roc adding %d<=>(\", regno);\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (TEST_HARD_REG_BIT (*hard_regs_live, i) \n+\t\t&& !TEST_HARD_REG_BIT (allocno[ialloc].hard_reg_conflicts, i))\n+\t      fprintf (dump_file, \"%d \", i);\n+\t  \n+\t  EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+\t    {\n+\t      if (!GET_ALLOCNO_LIVE (&conflicts[ialloc_prod], i))\n+\t\tfprintf (dump_file, \"%d \", allocno[i].reg);\n+\t    });\n+\t  fprintf (dump_file, \")\\n\");\n+\t}\n+\n+      IOR_HARD_REG_SET (allocno[ialloc].hard_reg_conflicts, *hard_regs_live);\n+\n+      for (i = allocno_row_words - 1; i >= 0; i--)\n+\tconflicts[ialloc_prod + i] |= allocnos_live[i];\n+    }\n+}\n+\n+\n+/* Handle the case where REG is set by the insn being scanned, during\n+   the backward scan to accumulate conflicts.  Record a conflict with\n+   all other registers already live.\n+\n+   REG might actually be something other than a register; if so, we do\n+   nothing.  */\n+\n+static void\n+mark_reg_store (HOST_WIDE_INT *allocnos_live, \n+\t\tHARD_REG_SET *hard_regs_live, \n+\t\tstruct df_ref *ref)\n+{\n+  rtx reg = DF_REF_REG (ref);\n+  unsigned int regno = DF_REF_REGNO (ref);\n+  enum machine_mode mode = GET_MODE (reg);\n+\n+  /* Either this is one of the max_allocno pseudo regs not allocated,\n+     or it is or has a hardware reg.  First handle the pseudo-regs.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER && reg_allocno[regno] >= 0)\n+    record_one_conflict (allocnos_live, hard_regs_live, regno);\n+\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno];\n+\n+  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n+  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n+    {\n+      unsigned int start = regno;\n+      unsigned int last = end_hard_regno (mode, regno);\n+      if ((GET_CODE (reg) == SUBREG) && !DF_REF_FLAGS_IS_SET (ref, DF_REF_EXTRACT))\n+\t{\n+\t  start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n+\t  last = start + subreg_nregs_with_regno (regno, reg);\n+\t}\n+\n+      regno = start;\n+      while (regno < last)\n+\trecord_one_conflict (allocnos_live, hard_regs_live, regno++);\n+    }\n+}\n+\n+\n+/* Return true if REGNO with MODE can be assigned to a register in\n+   CL.  */\n+\n+static bool\n+may_overlap_class_p (enum machine_mode mode, unsigned int regno, \n+\t\t     enum reg_class rc)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      enum reg_class pref_class = reg_preferred_class (regno);\n+      enum reg_class alt_class = reg_alternate_class (regno);\n+      return (reg_classes_intersect_p (rc, pref_class)\n+\t      || reg_classes_intersect_p (rc, alt_class));\n+    }\n+  else\n+    return in_hard_reg_set_p (reg_class_contents[rc], mode, regno);\n+}\n+\n+\n+/* SRC is an input operand to an instruction in which register DEST is\n+   an output operand.  SRC may be bound to a member of class SRC_CLASS\n+   and DEST may be bound to an earlyclobbered register that overlaps\n+   SRC_CLASS.  If SRC is a register that might be allocated a member\n+   of SRC_CLASS, add a conflict between it and DEST.  */\n+\n+static void\n+add_conflicts_for_earlyclobber (rtx dest, enum reg_class src_class, rtx src)\n+{\n+  if (GET_CODE (src) == SUBREG)\n+    src = SUBREG_REG (src);\n+  if (REG_P (src)\n+      && may_overlap_class_p (GET_MODE (src), REGNO (src), src_class))\n+    record_one_conflict_between_regnos (GET_MODE (src), REGNO (src),\n+                                        GET_MODE (dest), REGNO (dest));\n+}\n+\n+\n+/* Look at the defs in INSN and determine if any of them are marked as\n+   early clobber.  If they are marked as early clobber, add a conflict\n+   between any input operand that could be allocated to the same\n+   register.  */\n+\n+static void\n+set_conflicts_for_earlyclobber (rtx insn)\n+{\n+  int alt;\n+  int def;\n+  int use;\n+\n+  extract_insn (insn);\n+  preprocess_constraints ();\n+\n+  if (dump_file) \n+    fprintf (dump_file, \"  starting early clobber conflicts.\\n\");\n+\n+  for (alt = 0; alt < recog_data.n_alternatives; alt++)\n+    for (def = 0; def < recog_data.n_operands; def++)\n+      if ((recog_op_alt[def][alt].earlyclobber)\n+\t  && (recog_op_alt[def][alt].cl != NO_REGS))\n+\t{\n+\t  rtx dreg = recog_data.operand[def];\n+\t  enum machine_mode dmode = recog_data.operand_mode[def];\n+\t  if (GET_CODE (dreg) == SUBREG)\n+\t    dreg = SUBREG_REG (dreg);\n+\t  if (REG_P (dreg)\n+\t      &&  may_overlap_class_p (dmode, REGNO (dreg), recog_op_alt[def][alt].cl))\n+\n+\t    for (use = 0; use < recog_data.n_operands; use++)\n+\t      if (use != def\n+\t\t  && recog_data.operand_type[use] != OP_OUT\n+\t\t  && reg_classes_intersect_p (recog_op_alt[def][alt].cl,\n+\t\t\t\t\t      recog_op_alt[use][alt].cl))\n+\t\t{\n+\t\t  add_conflicts_for_earlyclobber (dreg,\n+\t\t\t\t\t\t  recog_op_alt[use][alt].cl,\n+\t\t\t\t\t\t  recog_data.operand[use]);\n+\t\t  /*  Reload may end up swapping commutative operands,\n+\t\t      so you have to take both orderings into account.\n+\t\t      The constraints for the two operands can be\n+\t\t      completely different.  (Indeed, if the\n+\t\t      constraints for the two operands are the same\n+\t\t      for all alternatives, there's no point marking\n+\t\t      them as commutative.)  */\n+\t\t  if (use < recog_data.n_operands + 1\n+\t\t      && recog_data.constraints[use][0] == '%')\n+\t\t    add_conflicts_for_earlyclobber (dreg,\n+\t\t\t\t\t\t    recog_op_alt[use][alt].cl,\n+\t\t\t\t\t\t    recog_data.operand[use + 1]);\n+\t\t}\n+\t}\n+\n+  if (dump_file) \n+    fprintf (dump_file, \"  finished early clobber conflicts.\\n\");\n+}\n+\n+\n+/* Init LIVE_SUBREGS[ALLOCNUM] and LIVE_SUBREGS_USED[ALLOCNUM] using\n+   REG to the the number of nregs, and INIT_VALUE to get the\n+   initialization.  ALLOCNUM need not be the regno of REG.  */\n+\n+void\n+ra_init_live_subregs (bool init_value, \n+\t\t      sbitmap *live_subregs, \n+\t\t      int *live_subregs_used,\n+\t\t      int allocnum, \n+\t\t      rtx reg)\n+{\n+  unsigned int regno = REGNO (SUBREG_REG (reg));\n+  int size = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n+\n+  gcc_assert (size > 0);\n+\n+  /* Been there, done that.  */\n+  if (live_subregs_used[allocnum])\n+    return;\n+\n+  /* Create a new one with zeros.  */\n+  if (live_subregs[allocnum] == NULL)\n+    live_subregs[allocnum] = sbitmap_alloc (size);\n+\n+  /* If the entire reg was live before blasting into subregs, we need\n+     to init all of the subregs to ones else init to 0.  */\n+  if (init_value)\n+    sbitmap_ones (live_subregs[allocnum]);\n+  else \n+    sbitmap_zero (live_subregs[allocnum]);\n+\n+  /* Set the number of bits that we really want.  */\n+  live_subregs_used[allocnum] = size;\n+}\n+\n+\n+/* Set REG to be not live in the sets ALLOCNOS_LIVE, LIVE_SUBREGS,\n+   HARD_REGS_LIVE.  If EXTRACT is false, assume that the entire reg is\n+   set not live even if REG is a subreg.  */\n+\n+inline static void\n+clear_reg_in_live (HOST_WIDE_INT *allocnos_live,\n+\t\t   sbitmap *live_subregs, \n+\t\t   int *live_subregs_used,\n+\t\t   HARD_REG_SET *hard_regs_live, \n+\t\t   rtx reg,\n+\t\t   bool extract)\n+{\n+  unsigned int regno = (GET_CODE (reg) == SUBREG) \n+    ? REGNO (SUBREG_REG (reg)): REGNO (reg);\n+  int allocnum = reg_allocno[regno];\n+\n+  if (allocnum >= 0)\n+    {\n+      if ((GET_CODE (reg) == SUBREG) && !extract)\n+\n+\t{\n+\t  unsigned int start = SUBREG_BYTE (reg);\n+\t  unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n+\n+\t  ra_init_live_subregs (GET_ALLOCNO_LIVE (allocnos_live, allocnum) != 0, \n+\t\t\t\tlive_subregs, live_subregs_used, allocnum, reg);\n+\n+\t  /* Ignore the paradoxical bits.  */\n+\t  if ((int)last > live_subregs_used[allocnum])\n+\t    last = live_subregs_used[allocnum];\n+\n+\t  while (start < last)\n+\t    {\n+\t      RESET_BIT (live_subregs[allocnum], start);\n+\t      start++;\n+\t    }\n+\n+\t  if (sbitmap_empty_p (live_subregs[allocnum]))\n+\t    {\n+\t      live_subregs_used[allocnum] = 0;\n+\t      CLEAR_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t    }\n+\t  else\n+\t    /* Set the allocnos live here because that bit has to be\n+\t       true to get us to look at the live_subregs fields.  */\n+\t    SET_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t}\n+      else\n+\t{\n+\t  /* Resetting the live_subregs_used is effectively saying do not use the \n+\t     subregs because we are writing the whole pseudo.  */\n+\t  live_subregs_used[allocnum] = 0;\n+\t  CLEAR_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t}\n+    }\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n+  if (! fixed_regs[regno])\n+    {\n+      unsigned int start = regno;\n+      if ((GET_CODE (reg) == SUBREG) && !extract)\n+\t{\n+\t  unsigned int last;\n+\t  start += SUBREG_BYTE (reg);\n+\t  last = start + subreg_nregs_with_regno (regno, reg);\n+\t  regno = start;\n+\n+\t  while (regno < last)\n+\t    {\n+\t      CLEAR_HARD_REG_BIT (*hard_regs_live, regno);\n+\t      regno++;\n+\t    }\n+\t}\n+      else\n+\tremove_from_hard_reg_set (hard_regs_live, GET_MODE (reg), regno);\n+    }\n+}\n+\n+\n+\n+/* Set REG to be live in the sets ALLOCNOS_LIVE, LIVE_SUBREGS,\n+   HARD_REGS_LIVE.  If EXTRACT is false, assume that the entire reg is\n+   set live even if REG is a subreg.  */\n+\n+inline static void\n+set_reg_in_live (HOST_WIDE_INT *allocnos_live, \n+\t\t sbitmap *live_subregs, \n+\t\t int *live_subregs_used,\n+\t\t HARD_REG_SET *hard_regs_live, \n+\t\t rtx reg,\n+\t\t bool extract)\n+{\n+  unsigned int regno = (GET_CODE (reg) == SUBREG) \n+    ? REGNO (SUBREG_REG (reg)): REGNO (reg);\n+  int allocnum = reg_allocno[regno];\n+\n+  if (allocnum >= 0)\n+    {\n+      if ((GET_CODE (reg) == SUBREG) && !extract)\n+\t{\n+\t  unsigned int start = SUBREG_BYTE (reg);\n+\t  unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n+\n+\t  ra_init_live_subregs (GET_ALLOCNO_LIVE (allocnos_live, allocnum) != 0, \n+\t\t\t\tlive_subregs, live_subregs_used, allocnum, reg);\n+\t  \n+\t  /* Ignore the paradoxical bits.  */\n+\t  if ((int)last > live_subregs_used[allocnum])\n+\t    last = live_subregs_used[allocnum];\n+\n+\t  while (start < last)\n+\t    {\n+\t      SET_BIT (live_subregs[allocnum], start);\n+\t      start++;\n+\t    }\n+\t}\n+      else\n+\t/* Resetting the live_subregs_used is effectively saying do not use the \n+\t   subregs because we are writing the whole pseudo.  */\n+\t  live_subregs_used[allocnum] = 0;\n+     \n+      SET_ALLOCNO_LIVE (allocnos_live, allocnum);\n+    }\n+      \n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n+  if (! fixed_regs[regno])\n+    {\n+      if ((GET_CODE (reg) == SUBREG) && !extract)\n+\t{\n+\t  unsigned int start = regno;\n+\t  unsigned int last;\n+\n+\t  start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n+\t  last = start + subreg_nregs_with_regno (regno, reg);\n+\t  regno = start;\n+\n+\t  while (regno < last)\n+\t    {\n+\t      SET_HARD_REG_BIT (*hard_regs_live, regno);\n+\t      regno++;\n+\t    }\n+\t}\n+      else\n+\tadd_to_hard_reg_set (hard_regs_live, GET_MODE (reg), regno);\n+    }\n+}\n+\n+\n+/* Add hard reg conflicts to RENUMBERS_LIVE assuming that pseudo in\n+   allocno[ALLOCNUM] is allocated to a set of hard regs starting at\n+   RENUMBER.\n+\n+   We are smart about the case where only subregs of REG have been\n+   set, as indicated by LIVE_SUBREGS[ALLOCNUM] and\n+   LIVE_SUBREGS_USED[ALLOCNUM].  See global_conflicts for description\n+   of LIVE_SUBREGS and LIVE_SUBREGS_USED.  */\n+\n+inline static void\n+set_renumbers_live (HARD_REG_SET *renumbers_live,   \n+\t\t    sbitmap *live_subregs, \n+\t\t    int *live_subregs_used,\n+\t\t    int allocnum, int renumber)\n+{\n+  /* The width of the pseudo.  */\n+  int nbytes = live_subregs_used[allocnum];\n+  int regno = allocno[allocnum].reg;\n+  enum machine_mode mode = GET_MODE (regno_reg_rtx[regno]);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"  set_renumbers_live %d->%d \", \n+\t     regno, renumber);\n+\n+  if (nbytes > 0)\n+    {\n+      int i;\n+      sbitmap live_subs = live_subregs[allocnum];\n+\n+      /* First figure out how many hard regs we are considering using.  */\n+      int target_nregs = hard_regno_nregs[renumber][mode];\n+\n+      /* Now figure out the number of bytes per hard reg.  Note that\n+\t this may be different that what would be obtained by looking\n+\t at the mode in the pseudo.  For instance, a complex number\n+\t made up of 2 32-bit parts gets mapped to 2 hard regs, even if\n+\t the hardregs are 64-bit floating point values.  */\n+      int target_width = nbytes / target_nregs;\n+      \n+      if (dump_file)\n+\tfprintf (dump_file, \"target_nregs=%d target_width=%d nbytes=%d\", \n+\t\t target_nregs, target_width, nbytes);\n+\n+      for (i = 0; i < target_nregs; i++)\n+\t{\n+\t  int j;\n+\t  bool set = false;\n+\t  for (j = 0; j < target_width; j++)\n+\t    {\n+\t      int reg_start = i * target_width;\n+\t      if (reg_start + j >= nbytes)\n+\t\tbreak;\n+\t      set |= TEST_BIT (live_subs, reg_start + j);\n+\t    }\n+\n+\t  if (set)\n+\t    SET_HARD_REG_BIT (*renumbers_live, renumber + i);\n+\t}\n+    }\n+  else\n+    add_to_hard_reg_set (renumbers_live, mode, renumber);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Dump out a REF with its reg_renumber range to FILE using\n+   PREFIX.  */\n+\n+static void\n+dump_ref (FILE *file, \n+\t  const char * prefix, \n+\t  const char * suffix, \n+\t  rtx reg,\n+\t  unsigned int regno,\n+\t  sbitmap *live_subregs, \n+\t  int *live_subregs_used\n+)\n+{\n+  int allocnum = reg_allocno[regno];\n+\n+  fprintf (file, \"%s %d\", prefix, regno);\n+  if (allocnum >= 0 \n+      && live_subregs_used[allocnum] > 0)\n+    {\n+      int j;\n+      char s = '[';\n+      \n+      for (j = 0; j < live_subregs_used[allocnum]; j++)\n+\tif (TEST_BIT (live_subregs[allocnum], j))\n+\t  {\n+\t    fprintf (dump_file, \"%c%d\", s, j);\n+\t    s = ',';\n+\t  }\n+      fprintf (dump_file, \"]\");\n+    }\n+\n+  if (reg_renumber[regno] >= 0)\n+    {\n+      enum machine_mode mode = GET_MODE (reg);\n+      unsigned int start;\n+      unsigned int last;\n+\n+      regno = reg_renumber[regno];\n+\n+      start = regno;\n+      last = end_hard_regno (mode, regno);\n+      if (GET_CODE (reg) == SUBREG)\n+\t{\n+\t  start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n+\t  last = start + subreg_nregs_with_regno (regno, reg);\n+\t}\n+\n+      if (start == last - 1)\n+\tfprintf (file, \"(%d)\", start);\n+      else \n+\tfprintf (file, \"(%d:%d..%d)\", regno, start, last-1);\n+    }\n+  fprintf (file, suffix);\n+}\n+\n+\n+/* Scan the rtl code and record all conflicts and register preferences in the\n+   conflict matrices and preference tables.  */\n+\n+void\n+global_conflicts (void)\n+{\n+  unsigned int i;\n+  basic_block bb;\n+  rtx insn;\n+\n+  /* Regs that have allocnos can be in either \n+     hard_regs_live (if regno < FIRST_PSEUDO_REGISTER) or \n+     allocnos_live (if regno >= FIRST_PSEUDO_REGISTER) or \n+     both if local_alloc has preallocated it and reg_renumber >= 0.  */\n+\n+  HARD_REG_SET hard_regs_live;\n+  HARD_REG_SET renumbers_live;\n+  HOST_WIDE_INT *allocnos_live;\n+  bitmap live = BITMAP_ALLOC (NULL);\n+  VEC (df_ref_t, heap) *clobbers = NULL;\n+  VEC (df_ref_t, heap) *dying_regs = NULL;\n+\n+  /* live_subregs is a vector used to keep accurate information about\n+     which hardregs are live in multiword pseudos.  live_subregs and\n+     live_subregs_used are indexed by reg_allocno.  The live_subreg\n+     entry for a particular pseudo is a bitmap with one bit per byte\n+     of the register.  It is only used if the corresponding element is\n+     non zero in live_subregs_used.  The value in live_subregs_used is\n+     number of bytes that the pseudo can occupy.  */\n+  sbitmap *live_subregs = XCNEWVEC (sbitmap, max_allocno);\n+  int *live_subregs_used = XNEWVEC (int, max_allocno);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"fixed registers : \"); \n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (fixed_regs[i])\n+\t  fprintf (dump_file, \"%d \", i);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  allocnos_live = XNEWVEC (HOST_WIDE_INT, allocno_row_words);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bitmap_iterator bi;\n+\n+      bitmap_copy (live, DF_LIVE_OUT (bb));\n+      df_simulate_artificial_refs_at_end (bb, live);\n+\n+      memset (allocnos_live, 0, allocno_row_words * sizeof (HOST_WIDE_INT));\n+      memset (live_subregs_used, 0, max_allocno * sizeof (int));\n+      CLEAR_HARD_REG_SET (hard_regs_live);\n+      CLEAR_HARD_REG_SET (renumbers_live);\n+\n+      /* Initialize allocnos_live and hard_regs_live for bottom of block.  */\n+      EXECUTE_IF_SET_IN_BITMAP (live, 0, i, bi)\n+\t{\n+\t  if (i >= FIRST_PSEUDO_REGISTER)\n+\t    break;\n+\t  if (! fixed_regs[i])\n+\t    SET_HARD_REG_BIT (hard_regs_live, i);\n+\t}\n+    \n+      EXECUTE_IF_SET_IN_BITMAP (live, FIRST_PSEUDO_REGISTER, i, bi)\n+\t{\n+\t  int allocnum = reg_allocno[i];\n+\n+\t  if (allocnum >= 0)\n+\t    {\n+\t      int renumber = reg_renumber[i];\n+\t      rtx reg = regno_reg_rtx[i];\n+\n+\t      set_reg_in_live (allocnos_live, live_subregs, live_subregs_used, \n+\t\t\t       &hard_regs_live, reg, false);\n+\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n+\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n+\t\t\t\t    allocnum, renumber);\n+\t    }\n+\t} \n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nstarting basic block %d\\n\\n\", bb->index);\n+\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+\t{\n+\t  unsigned int uid = INSN_UID (insn);\n+\t  struct df_ref **def_rec;\n+\t  struct df_ref **use_rec;\n+\n+\t  if (!INSN_P (insn))\n+\t    continue;\t\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"insn = %d live = hardregs [\", uid);\n+\t      \n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\tif (TEST_HARD_REG_BIT (hard_regs_live, i))\n+\t\t  fprintf (dump_file, \"%d \", i);\n+\n+\t      fprintf (dump_file, \"] renumbered [\");\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\tif (TEST_HARD_REG_BIT (renumbers_live, i))\n+\t\t  fprintf (dump_file, \"%d \", i);\n+\n+\t      fprintf (dump_file, \"] pseudos [\");\n+\t      EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+\t\t{\n+\t\t  dump_ref (dump_file, \" \", \"\", regno_reg_rtx[allocno[i].reg],\n+\t\t\t    allocno[i].reg, live_subregs, live_subregs_used);\n+\t\t});\n+\t      fprintf (dump_file, \"]\\n\");\n+\t    }\n+\n+\t  /* Add the defs into live.  Most of them will already be\n+\t     there, the ones that are missing are the unused ones and\n+\t     the clobbers.  We do this in order to make sure that\n+\t     interferences are added between every def and everything\n+\t     that is live across the insn.  These defs will be removed\n+\t     later.  */\n+\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t    {\n+\t      struct df_ref *def = *def_rec;\n+\n+\t      /* FIXME: Ignoring may clobbers is technically the wrong\n+\t\t thing to do.  However the old version of the this\n+\t\t code ignores may clobbers (and instead has many\n+\t\t places in the register allocator to handle these\n+\t\t constraints).  It is quite likely that with a new\n+\t\t allocator, the correct thing to do is to not ignore\n+\t\t the constraints and then do not put in the large\n+\t\t number of special checks.  */\n+\t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n+\t\t{\n+\t\t  rtx reg = DF_REF_REG (def);\n+\t\t  set_reg_in_live (allocnos_live, live_subregs, live_subregs_used, \n+\t\t\t\t   &hard_regs_live, reg, \n+\t\t\t\t   DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT));\n+\t\t  if (dump_file)\n+\t\t    dump_ref (dump_file, \"  adding def\", \"\\n\",\n+\t\t\t      reg, DF_REF_REGNO (def), live_subregs, live_subregs_used);\n+\t\t}\n+\t    }\n+\t  \n+\t  /* Add the hardregs into renumbers_live to build the\n+\t     interferences.  Renumbers_live will be rebuilt in the\n+\t     next step from scratch, so corrupting it here is no\n+\t     problem.  */\n+\t  IOR_HARD_REG_SET (renumbers_live, hard_regs_live);\n+\n+\t  /* Add the interferences for the defs.  */\n+\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t    {\n+\t      struct df_ref *def = *def_rec;\n+\t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n+\t\tmark_reg_store (allocnos_live, &renumbers_live, def);\n+\t    }\n+\t  \n+\t  /* Remove the defs from the live sets.  Leave the partial\n+\t     and conditional defs in the set because they do not\n+\t     kill.  */\n+\t  VEC_truncate (df_ref_t, clobbers, 0);\n+\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t    {\n+\t      struct df_ref *def = *def_rec;\n+\n+\t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n+\t\t{\n+\t\t  rtx reg = DF_REF_REG (def);\n+\n+\t\t  clear_reg_in_live (allocnos_live, live_subregs, live_subregs_used,\n+\t\t\t\t     &hard_regs_live, reg,\n+\t\t\t\t     DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT));\n+\t\t  if (dump_file)\n+\t\t    dump_ref (dump_file, \"  clearing def\", \"\\n\", \n+\t\t\t      reg, DF_REF_REGNO (def), live_subregs, live_subregs_used);\n+\t\t}\n+\t      \n+\t      if (DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER))\n+\t\tVEC_safe_push (df_ref_t, heap, clobbers, def);\n+\t    }\n+\t  \n+\t  /* Go thru all of the live pseudos and reset renumbers_live.\n+\t     We must start from scratch here because there could have\n+\t     been several pseudos alive that have the same\n+\t     reg_renumber and if we see a clobber for one of them, we\n+\t     cannot not want to kill the renumbers from the other\n+\t     pseudos.  */\n+\t  CLEAR_HARD_REG_SET (renumbers_live);\n+\t  EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+\t    {\n+\t      unsigned int regno = allocno[i].reg;\n+\t      int renumber = reg_renumber[regno];\n+\n+\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n+\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n+\t\t\t\t    i, renumber);\n+\t    }); \n+\t\t\t\t\t \n+\t  /* Add the uses to the live sets.  Keep track of the regs\n+\t     that are dying inside the insn, this set will be useful\n+\t     later.  */\n+\t  VEC_truncate (df_ref_t, dying_regs, 0);\n+\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t    {\n+\t      struct df_ref *use = *use_rec;\n+\t      unsigned int regno = DF_REF_REGNO (use);\n+\t      bool added = false;\n+\t      int renumber = reg_renumber[regno];\n+\t      int allocnum = reg_allocno[regno];\n+\t      bool renumbering = false;\n+\t      rtx reg = DF_REF_REG (use);\n+\n+\t      /* DF_REF_READ_WRITE on a use means that this use is\n+\t\t fabricated from a def that is a partial set to a\n+\t\t multiword reg.  Here, we only model the subreg case\n+\t\t precisely so we do not need to look at the fabricated\n+\t\t use unless that set also happens to wrapped in a\n+\t\t ZERO_EXTRACT. */\n+\t      if (DF_REF_FLAGS_IS_SET (use, DF_REF_READ_WRITE) \n+\t\t  && (!DF_REF_FLAGS_IS_SET (use, DF_REF_EXTRACT)) \n+\t\t  && DF_REF_FLAGS_IS_SET (use, DF_REF_SUBREG))\n+\t\tcontinue;\n+\t      \n+\t      if (dump_file)\n+\t\tdump_ref (dump_file, \"  seeing use\", \"\\n\",\n+\t\t\t  reg, regno, live_subregs, live_subregs_used);\n+\n+\t      if (allocnum >= 0)\n+\t\t{\n+\t\t  if (GET_CODE (reg) == SUBREG\n+\t\t      && !DF_REF_FLAGS_IS_SET (use, DF_REF_EXTRACT)) \n+\t\t    {\n+\t\t      unsigned int start = SUBREG_BYTE (reg);\n+\t\t      unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n+\n+\t\t      ra_init_live_subregs (GET_ALLOCNO_LIVE (allocnos_live, allocnum) != 0, \n+\t\t\t\t\t    live_subregs, live_subregs_used, allocnum, reg);\n+\t\t      \n+\t\t      /* Ignore the paradoxical bits.  */\n+\t\t      if ((int)last > live_subregs_used[allocnum])\n+\t\t\tlast = live_subregs_used[allocnum];\n+\t\t      \n+\t\t      while (start < last)\n+\t\t\t{\n+\t\t\t  if (!TEST_BIT (live_subregs[allocnum], start)) \n+\t\t\t    {\n+\t\t\t      if (dump_file)\n+\t\t\t\tfprintf (dump_file, \"    dying pseudo subreg %d[%d]\\n\", regno, start);\n+\t\t\t      SET_BIT (live_subregs[allocnum], start);\n+\t\t\t      \n+\t\t\t      added = true;\n+\t\t\t    }\n+\t\t\t  start++;\n+\t\t\t}\n+\t\t      \n+\t\t      SET_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n+\t\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n+\t\t\t\t\t    allocnum, renumber);\n+\t\t    }\n+\t\t  \n+\t\t  else if (GET_ALLOCNO_LIVE (allocnos_live, allocnum) == 0)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"    dying pseudo\\n\");\n+\t\t      \n+\t\t      /* Resetting the live_subregs_used is\n+\t\t\t effectively saying do not use the subregs\n+\t\t\t because we are reading the whole pseudo.  */\n+\t\t      live_subregs_used[allocnum] = 0;\n+\t\t      SET_ALLOCNO_LIVE (allocnos_live, allocnum);\n+\t\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n+\t\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n+\t\t\t\t\t    allocnum, renumber);\n+\t\t      added = true;\n+\t\t    }\n+\t\t}\n+\n+\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  regno = renumber;\n+\t\t  renumbering = true;\n+\t\t}\n+\t      \n+\t      if (regno < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  unsigned int start = regno;\n+\t\t  unsigned int last;\n+\t\t  if (GET_CODE (reg) == SUBREG)\n+\t\t    {\n+\t\t      start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t\t\t    SUBREG_BYTE (reg), GET_MODE (reg));\n+\t\t      last = start + subreg_nregs_with_regno (regno, reg);\n+\t\t    }\n+\t\t  else\n+\t\t    last = end_hard_regno (GET_MODE (reg), regno);\n+\t\t  \n+\t\t  regno = start;\n+\t\t  while (regno < last)\n+\t\t    {\n+\t\t      if ((!TEST_HARD_REG_BIT (hard_regs_live, regno)) \n+\t\t\t  && (!TEST_HARD_REG_BIT (renumbers_live, regno)) \n+\t\t\t  && ! fixed_regs[regno])\n+\t\t\t{\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file, \"    dying hard reg %d\\n\", regno);\n+\t\t\t  if (renumbering)\n+\t\t\t    SET_HARD_REG_BIT (renumbers_live, regno);\n+\t\t\t  else\n+\t\t\t    SET_HARD_REG_BIT (hard_regs_live, regno);\n+\t\t\t  \n+\t\t\t  added = true;\n+\t\t\t}\n+\t\t      regno++;\n+\t\t    }\n+\t\t}\n+\t      if (added)\n+\t\tVEC_safe_push (df_ref_t, heap, dying_regs, use);\n+\t    }\n+\t  \n+\t  /* These three cases are all closely related, they all deal\n+             with some set of outputs of the insn need to conflict\n+             with some of the registers that are used by the insn but\n+             die within the insn. If no registers die within the insn,\n+             the tests can be skipped. */\n+\n+\t  if (VEC_length (df_ref_t, dying_regs) > 0)\n+\t    {\n+\t      int k;\n+\t      /* There appears to be an ambiguity as to what a clobber\n+\t\t means in an insn.  In some cases, the clobber happens\n+\t\t within the processing of the insn and in some cases\n+\t\t it happens at the end of processing the insn.  There\n+\t\t is currently no way to distinguish these two cases so\n+\t\t this code causes real clobbers to interfere with\n+\t\t registers that die within an insn.\n+\n+\t\t This is consistent with the prior version of\n+\t\t interference graph builder but is was discovered\n+\t\t while developing this version of the code, that on\n+\t\t some architectures such as the x86-64, the clobbers\n+\t\t only appear to happen at the end of the insn.\n+\t\t However, the ppc-32 contains clobbers for which these\n+\t\t interferences are necessary.\n+\n+\t\t FIXME: We should consider either adding a new kind of\n+\t\t clobber, or adding a flag to the clobber distinguish\n+\t\t these two cases.  */\n+\t      for (k = VEC_length (df_ref_t, clobbers) - 1; k >= 0; k--)\n+\t\t{\n+\t\t  struct df_ref *def = VEC_index (df_ref_t, clobbers, k);\n+\t\t  int j;\n+\n+\t\t  for (j = VEC_length (df_ref_t, dying_regs) - 1; j >= 0; j--)\n+\t\t    {\n+\t\t      struct df_ref *use = VEC_index (df_ref_t, dying_regs, j);\n+\t\t      record_one_conflict_between_regnos (GET_MODE (DF_REF_REG (def)),\n+\t\t\t\t\t\t\t  DF_REF_REGNO (def),\n+\t\t\t\t\t\t\t  GET_MODE (DF_REF_REG (use)),\n+\t\t\t\t\t\t\t  DF_REF_REGNO (use));\n+\t\t    }\n+\t\t}\n+\n+\t      /* Early clobbers, by definition, need to not only\n+\t\t clobber the registers that are live accross the insn\n+\t\t but need to clobber the registers that die within the\n+\t\t insn.  The clobbering for registers live across the\n+\t\t insn is handled above.  */ \n+\t      set_conflicts_for_earlyclobber (insn);\n+\n+\t      /* If INSN is a store with multiple outputs, then any\n+\t\t reg that dies here and is used inside of the address\n+\t\t of the output must conflict with the other outputs.\n+\n+\t\t FIXME: There has been some discussion as to whether\n+\t\t this is right place to handle this issue.  This is a\n+\t\t hold over from an early version global conflicts.\n+\n+\t\t 1) There is some evidence that code only deals with a\n+\t\t bug that is only on the m68k.  The conditions of this\n+\t\t test are such that this case only triggers for a very\n+\t\t peculiar insn, one that is a parallel where one of\n+\t\t the sets is a store and the other sets a reg that is\n+\t\t used in the address of the store.  See\n+\t\t http://gcc.gnu.org/ml/gcc-patches/1998-12/msg00259.html\n+\n+\t\t 2) The situation that this is addressing is a bug in\n+\t\t the part of reload that handles stores, adding this\n+\t\t conflict only hides the problem.  (Of course no one\n+\t\t really wants to fix reload so it is understandable\n+\t\t why a bandaid was just added here.)\n+\n+\t\t Just because an output is unused does not mean the\n+\t\t compiler can assume the side effect will not occur.\n+\t\t Consider if REG appears in the address of an output\n+\t\t and we reload the output.  If we allocate REG to the\n+\t\t same hard register as an unused output we could set\n+\t\t the hard register before the output reload insn.\n+\n+\t\t 3) This could actually be handled by making the other\n+\t\t (non store) operand of the insn be an early clobber.\n+\t\t This would insert the same conflict, even if it is\n+\t\t not technically an early clobber.  */\n+\n+\t      /* It is unsafe to use !single_set here since it will ignore an\n+\t\t unused output.  */\n+\t      if (GET_CODE (PATTERN (insn)) == PARALLEL && multiple_sets (insn))\n+\t\t{ \n+\t\t  int j;\n+\t\t  for (j = VEC_length (df_ref_t, dying_regs) - 1; j >= 0; j--)\n+\t\t    {\n+\t\t      int used_in_output = 0;\n+\t\t      struct df_ref *use = VEC_index (df_ref_t, dying_regs, j);\n+\t\t      rtx reg = DF_REF_REG (use);\n+\t\t      int uregno = DF_REF_REGNO (use);\n+\t\t      enum machine_mode umode = GET_MODE (DF_REF_REG (use));\n+\t\t      int k;\n+\n+\t\t      for (k = XVECLEN (PATTERN (insn), 0) - 1; k >= 0; k--)\n+\t\t\t{\n+\t\t\t  rtx set = XVECEXP (PATTERN (insn), 0, k);\n+\t\t\t  if (GET_CODE (set) == SET\n+\t\t\t      && !REG_P (SET_DEST (set))\n+\t\t\t      && !rtx_equal_p (reg, SET_DEST (set))\n+\t\t\t      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+\t\t\t    used_in_output = 1;\n+\t\t\t}\n+\t\t      if (used_in_output)\n+\t\t\tfor (k = XVECLEN (PATTERN (insn), 0) - 1; k >= 0; k--)\n+\t\t\t  {\n+\t\t\t    rtx set = XVECEXP (PATTERN (insn), 0, k);\n+\t\t\t    if (GET_CODE (set) == SET\n+\t\t\t\t&& REG_P (SET_DEST (set))\n+\t\t\t\t&& !rtx_equal_p (reg, SET_DEST (set)))\n+\t\t\t      record_one_conflict_between_regnos (GET_MODE (SET_DEST (set)),\n+\t\t\t\t\t\t\t\t  REGNO (SET_DEST (set)), \n+\t\t\t\t\t\t\t\t  umode, uregno);\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+\t    /* Add the renumbers live to the hard_regs_live for the next few\n+\t calls.  All of this gets recomputed at the top of the loop so\n+\t there is no harm.  */\n+      IOR_HARD_REG_SET (hard_regs_live, renumbers_live);\n+\t  \n+#ifdef EH_RETURN_DATA_REGNO\n+      if (bb_has_eh_pred (bb))\n+\t{\n+\t  unsigned int i;\n+    \n+\t  for (i = 0; ; ++i)\n+\t    {\n+\t      unsigned int regno = EH_RETURN_DATA_REGNO (i);\n+\t      if (regno == INVALID_REGNUM)\n+\t\tbreak;\n+\t      record_one_conflict (allocnos_live, &hard_regs_live, regno);\n+\t    }\n+\t}\n+#endif\n+\n+      if (bb_has_abnormal_pred (bb))\n+\t{\n+\t  unsigned int i;\n+#ifdef STACK_REGS\n+\t  /* Pseudos can't go in stack regs at the start of a basic block that\n+\t     is reached by an abnormal edge. Likewise for call clobbered regs,\n+\t     because caller-save, fixup_abnormal_edges and possibly the table\n+\t     driven EH machinery are not quite ready to handle such regs live\n+\t     across such edges.  */\n+\t  EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, i,\n+\t\t\t\t\t {\n+\t\t\t\t\t   allocno[i].no_stack_reg = 1;\n+\t\t\t\t\t });\n+\n+\t  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+\t    record_one_conflict (allocnos_live, &hard_regs_live, i);\n+#endif\n+\t  \n+\t  /* No need to record conflicts for call clobbered regs if we have\n+\t     nonlocal labels around, as we don't ever try to allocate such\n+\t     regs in this case.  */\n+\t  if (! current_function_has_nonlocal_label)\n+\t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t      if (call_used_regs [i])\n+\t\trecord_one_conflict (allocnos_live, &hard_regs_live, i);\n+\t}\n+    }\n+  \n+  for (i = 0; i < (unsigned int)max_allocno; i++)\n+    if (live_subregs[i])\n+      free (live_subregs[i]);\n+\n+  /* Clean up.  */\n+  free (allocnos_live);\n+  free (live_subregs);\n+  free (live_subregs_used);\n+  VEC_free (df_ref_t, heap, dying_regs);\n+  VEC_free (df_ref_t, heap, clobbers);\n+  BITMAP_FREE (live);\n+}"}, {"sha": "52a1cc28beb876e9009113286bf70272b2fb2335", "filename": "gcc/ra.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -0,0 +1,133 @@\n+/* Define per-register tables for data flow info and register allocation.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RA_H\n+#define GCC_RA_H\n+\n+#include \"regs.h\"\n+\n+struct allocno\n+{\n+  int reg;\n+  /* Gives the number of consecutive hard registers needed by that\n+     pseudo reg.  */\n+  int size;\n+\n+  /* Number of calls crossed by each allocno.  */\n+  int calls_crossed;\n+\n+  /* Number of calls that might throw crossed by each allocno.  */\n+  int throwing_calls_crossed;\n+\n+  /* Number of refs to each allocno.  */\n+  int n_refs;\n+\n+  /* Frequency of uses of each allocno.  */\n+  int freq;\n+\n+  /* Guess at live length of each allocno.\n+     This is actually the max of the live lengths of the regs.  */\n+  int live_length;\n+\n+  /* Set of hard regs conflicting with allocno N.  */\n+\n+  HARD_REG_SET hard_reg_conflicts;\n+\n+  /* Set of hard regs preferred by allocno N.\n+     This is used to make allocnos go into regs that are copied to or from them,\n+     when possible, to reduce register shuffling.  */\n+\n+  HARD_REG_SET hard_reg_preferences;\n+\n+  /* Similar, but just counts register preferences made in simple copy\n+     operations, rather than arithmetic.  These are given priority because\n+     we can always eliminate an insn by using these, but using a register\n+     in the above list won't always eliminate an insn.  */\n+\n+  HARD_REG_SET hard_reg_copy_preferences;\n+\n+  /* Similar to hard_reg_preferences, but includes bits for subsequent\n+     registers when an allocno is multi-word.  The above variable is used for\n+     allocation while this is used to build reg_someone_prefers, below.  */\n+\n+  HARD_REG_SET hard_reg_full_preferences;\n+\n+  /* Set of hard registers that some later allocno has a preference for.  */\n+\n+  HARD_REG_SET regs_someone_prefers;\n+\n+#ifdef STACK_REGS\n+  /* Set to true if allocno can't be allocated in the stack register.  */\n+  bool no_stack_reg;\n+#endif\n+};\n+extern struct allocno *allocno;\n+\n+/* In ra-conflict.c  */\n+\n+/* Number of pseudo-registers which are candidates for allocation.  */\n+\n+extern int max_allocno;\n+\n+/* max_allocno by max_allocno array of bits, recording whether two\n+   allocno's conflict (can't go in the same hardware register).\n+\n+   `conflicts' is symmetric after the call to mirror_conflicts.  */\n+\n+extern HOST_WIDE_INT *conflicts;\n+\n+/* Number of ints required to hold max_allocno bits.\n+   This is the length of a row in `conflicts'.  */\n+\n+extern int allocno_row_words;\n+\n+/* Indexed by (pseudo) reg number, gives the allocno, or -1\n+   for pseudo registers which are not to be allocated.  */\n+\n+extern int *reg_allocno;\n+\n+extern void global_conflicts (void);\n+\n+/* In global.c  */\n+\n+/* For any allocno set in ALLOCNO_SET, set ALLOCNO to that allocno,\n+   and execute CODE.  */\n+#define EXECUTE_IF_SET_IN_ALLOCNO_SET(ALLOCNO_SET, ALLOCNO, CODE)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  int i_;\t\t\t\t\t\t\t\t\\\n+  int allocno_;\t\t\t\t\t\t\t\t\\\n+  HOST_WIDE_INT *p_ = (ALLOCNO_SET);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (i_ = allocno_row_words - 1, allocno_ = 0; i_ >= 0;\t\t\\\n+       i_--, allocno_ += HOST_BITS_PER_WIDE_INT)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      unsigned HOST_WIDE_INT word_ = (unsigned HOST_WIDE_INT) *p_++;\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for ((ALLOCNO) = allocno_; word_; word_ >>= 1, (ALLOCNO)++)\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (word_ & 1)\t\t\t\t\t\t\\\n+\t    {CODE;}\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+extern void ra_init_live_subregs (bool, sbitmap *, int *, int, rtx reg);\n+\n+\n+#endif /* GCC_RA_H */"}, {"sha": "c9c5fc5c5c0111752d81e9f6382ff0ba417741ac", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -1521,7 +1521,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    /* Check that we don't use a hardreg for an uninitialized\n \t       pseudo.  See also find_dummy_reload().  */\n \t    && (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t\t|| ! bitmap_bit_p (DF_RA_LIVE_OUT (ENTRY_BLOCK_PTR),\n+\t\t|| ! bitmap_bit_p (DF_LIVE_OUT (ENTRY_BLOCK_PTR),\n \t\t\t\t   ORIGINAL_REGNO (XEXP (note, 0))))\n \t    && ! refers_to_regno_for_reload_p (regno,\n \t\t\t\t\t       end_hard_regno (rel_mode,\n@@ -2000,7 +2000,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t   as they would clobber the other live pseudo using the same.\n \t   See also PR20973.  */\n       && (ORIGINAL_REGNO (in) < FIRST_PSEUDO_REGISTER\n-          || ! bitmap_bit_p (DF_RA_LIVE_OUT (ENTRY_BLOCK_PTR),\n+          || ! bitmap_bit_p (DF_LIVE_OUT (ENTRY_BLOCK_PTR),\n \t\t\t     ORIGINAL_REGNO (in))))\n     {\n       unsigned int regno = REGNO (in) + in_offset;"}, {"sha": "6f6e4f42124fe9c9dafa55e8e1f5187a1154586e", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -548,7 +548,7 @@ compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n       if (r < 0)\n \t{\n \t  /* reload_combine uses the information from\n-\t     DF_RA_LIVE_IN (BASIC_BLOCK), which might still\n+\t     DF_LIVE_IN (BASIC_BLOCK), which might still\n \t     contain registers that have not actually been allocated\n \t     since they have an equivalence.  */\n \t  gcc_assert (reload_completed);\n@@ -1158,10 +1158,7 @@ reload (rtx first, int global)\n \n   if (! frame_pointer_needed)\n     FOR_EACH_BB (bb)\n-      {\n-\tbitmap_clear_bit (df_get_live_in (bb), HARD_FRAME_POINTER_REGNUM);\n-\tbitmap_clear_bit (df_get_live_top (bb), HARD_FRAME_POINTER_REGNUM);\n-      }\n+      bitmap_clear_bit (df_get_live_in (bb), HARD_FRAME_POINTER_REGNUM);\n \t\n   /* Come here (with failure set nonzero) if we can't get enough spill\n      regs.  */"}, {"sha": "61160938ab5312026fae0c8f1e220c475848920c", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -1063,6 +1063,7 @@ extern bool subreg_offset_representable_p (unsigned int, enum machine_mode,\n \t\t\t\t\t   unsigned int, enum machine_mode);\n extern unsigned int subreg_regno (const_rtx);\n extern unsigned int subreg_nregs (const_rtx);\n+extern unsigned int subreg_nregs_with_regno (unsigned int, const_rtx);\n extern unsigned HOST_WIDE_INT nonzero_bits (const_rtx, enum machine_mode);\n extern unsigned int num_sign_bit_copies (const_rtx, enum machine_mode);\n extern bool constant_pool_constant_p (rtx);\n@@ -2172,7 +2173,6 @@ extern void dump_global_regs (FILE *);\n /* Yes, this ifdef is silly, but HARD_REG_SET is not always defined.  */\n extern void retry_global_alloc (int, HARD_REG_SET);\n #endif\n-extern void build_insn_chain (rtx);\n \n /* In regclass.c */\n extern int reg_classes_intersect_p (enum reg_class, enum reg_class);"}, {"sha": "423d6efcb8c7ccd2a77263f50bd7bef0a4252a8e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -3262,16 +3262,26 @@ subreg_regno (const_rtx x)\n    to.  */\n unsigned int\n subreg_nregs (const_rtx x)\n+{\n+  return subreg_nregs_with_regno (REGNO (SUBREG_REG (x)), x);\n+}\n+\n+/* Return the number of registers that a subreg REG with REGNO\n+   expression refers to.  This is a copy of the rtlanal.c:subreg_nregs\n+   changed so that the regno can be passed in. */\n+\n+unsigned int\n+subreg_nregs_with_regno (unsigned int regno, const_rtx x)\n {\n   struct subreg_info info;\n   rtx subreg = SUBREG_REG (x);\n-  int regno = REGNO (subreg);\n \n   subreg_get_info (regno, GET_MODE (subreg), SUBREG_BYTE (x), GET_MODE (x),\n \t\t   &info);\n   return info.nregs;\n }\n \n+\n struct parms_set_data\n {\n   int nregs;"}, {"sha": "3669a957bc7dde3c61b826887898f52a72d6c728", "filename": "libstdc++-v3/testsuite/tr1/6_containers/hash/operators/size_t.cc", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Fhash%2Foperators%2Fsize_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba49cb7bffa4826391d9e7e7e90dc3189be0bf50/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Fhash%2Foperators%2Fsize_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Fhash%2Foperators%2Fsize_t.cc?ref=ba49cb7bffa4826391d9e7e7e90dc3189be0bf50", "patch": "@@ -46,25 +46,25 @@ template<typename T>\n   \n void test01()\n {\n-  do_test<bool>();\n-  do_test<char>();\n-  do_test<signed char>();\n-  do_test<unsigned char>();\n-  do_test<short>();\n-  do_test<int>();\n-  do_test<long>();\n-  do_test<unsigned short>();\n-  do_test<unsigned int>();\n-  do_test<unsigned long>();\n-  do_test<int*>();\n-  do_test<std::string>();\n-  do_test<float>();\n-  do_test<double>();\n+  //  do_test<bool>();\n+  //  do_test<char>();\n+  //  do_test<signed char>();\n+  //  do_test<unsigned char>();\n+  //  do_test<short>();\n+  //  do_test<int>();\n+  //  do_test<long>();\n+  //  do_test<unsigned short>();\n+  //  do_test<unsigned int>();\n+  //  do_test<unsigned long>();\n+  //  do_test<int*>();\n+  //  do_test<std::string>();\n+  //  do_test<float>();\n+  //  do_test<double>();\n   do_test<long double>();\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n-  do_test<wchar_t>();\n-  do_test<std::wstring>();\n+  //  do_test<wchar_t>();\n+  //  do_test<std::wstring>();\n #endif\n }\n "}]}